00:00:04 <conal> ologNation: hey
00:00:04 <ologNation> I just computed that
00:00:12 <ologNation> there are 5 distinct words made of 1 letters
00:00:12 <ologNation> there are 13 distinct words made of 2 letters
00:00:12 <ologNation> there are 29 distinct words made of 3 letters
00:00:12 <ologNation> there are 53 distinct words made of 4 letters
00:00:12 <ologNation> there are 59 distinct words made of 5 letters
00:00:13 <ologNation> there are 60 distinct words made of 6 letters
00:00:15 <ologNation> where the letters are a = [1,2,3], b = [3,4,5], generating A_5
00:00:17 <ologNation> Pretty fun
00:00:22 <ologNation> Hope you are well.
00:00:29 <ologNation> I am tired now and must sleep.
00:00:40 <ologNation> This program (see paste) will help me tomorrow with my homework.
00:00:51 <ologNation> I must find all conjugacy classes of A_5.
00:00:59 <conal> ologNation: oh!  just /whois'd you.
00:01:01 <ologNation> Now (as soon as I've slept), I can find them explicitly.
00:01:08 <ologNation> I'm ralf.
00:01:15 <ologNation> We met in Portland at the ICFP.
00:01:37 <DigitalKiwi> you live in portland?
00:01:43 <ologNation> Eugene.
00:01:52 <ologNation> Grad student at U Oregon.
00:01:57 <ologNation> Really,r eally sleepy.
00:02:05 * ologNation drools and slumps on keyboard. 
00:02:14 <DigitalKiwi> i don't know where that is
00:02:33 <ologNation> Somehow a lot of really good coding gets done in that last hour before sleep.
00:02:44 <DigitalKiwi> one of the ops here is in portland though i think
00:02:59 <ologNation> http://maps.google.com/maps?f=d&source=s_d&saddr=Portland,+OR&daddr=Eugene+or&hl=en&geocode=&mra=ls&sll=37.0625,-95.677068&sspn=29.854268,86.572266&ie=UTF8&t=h&z=8
00:03:00 <DigitalKiwi> it's kind of like the ballmer peak
00:03:35 <DigitalKiwi> oh that's pretty close
00:03:40 <DigitalKiwi> relatively speaking
00:03:44 <DigitalKiwi> i drive that much every day
00:16:38 <dhun> I was looking for a string replace function, didn't find any, so made one myself. My question is, where is it in the libraries? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25188#a25188
00:19:48 <edwardk> preflex: xseen alpounet
00:19:48 <preflex>  alpounet was last seen on freenode/#haskell 13 hours, 9 minutes and 6 seconds ago, saying: same here
00:20:08 <dhun> well it must be there somehow, but it seems I can not find the name under which it is stored
00:20:44 <edwardk> have most of my slides for my talk on fingertrees ready
00:31:04 <ezyang> Whoo, fclabels taught me what covariance and contravariance are.
00:32:20 <idnar> does one of the Haskell XML libraries have some sexp-like way of constructing XML documents?
00:32:26 <idnar> I'm interested to see what the syntax looks like
00:33:36 * hackagebot graphics-formats-collada 0.2.0 - Load 3D geometry in the COLLADA format  http://hackage.haskell.org/package/graphics-formats-collada-0.2.0 (LukePalmer)
00:36:15 <ezyang> ekmett: Did BostonHaskell find another speaker?
00:36:21 <ezyang> *edwardk
00:44:52 <edwardk> ezyang: not yet
00:45:01 <edwardk> ezyang: I have 50+ slides though ;)
00:45:43 <xerox> could someone grab me http://www.springerlink.com/content/u038h5530353v772/ ?
00:46:35 <ezyang> Man, I'm really sad that I'll be missing this
00:46:45 <edwardk> ezyang: though i could probably stand to do more demonstration of actually using them. it took me that long to define and motivate them =/
00:47:25 <edwardk> ezyang: let me send you what i have slide-wise so far as a sanity check. if nothing else you get the sneak preview ;)
00:47:48 <ezyang> sure :^)
00:50:29 <edwardk> ezyang: try http://comonad.com/reader/wp-content/uploads/2010/03/Finger-Trees.pdf
00:50:43 <ezyang> got it
00:51:34 <ezyang> fromList (n :: [a]) is O(1)... well... of course :o)
00:51:41 <edwardk> =)
00:51:45 <edwardk> i had to let it win somewhere ;)
00:53:56 <ezyang> Whoa! Zippers have one finger.
00:54:02 <ezyang> Impressed.
00:54:29 <idnar> heh
00:55:07 <edwardk> yeah, i had a zipper get caught on one of mine last week, never did get it free. hopefully i will before they capture another.
00:55:56 <ezyang> Wow, now I'm even more sad I'll be missing the talk
00:55:59 <ezyang> this one's a keeper
00:56:25 <edwardk> what class is it that you're skipping me for anyways? =)
00:57:17 <edwardk> ezyang: the main worry that i have is that, like most of my talks, its a bit too abstract about the applications.
00:57:23 <ezyang> It's a humanities class, so it's small and the prof knows if you're missing
00:57:31 <edwardk> ah
00:57:40 <ezyang> edwardk: I think you're in a good spot for abstractness
00:57:43 <edwardk> or rather 'ah the humanit(y|ies)'
00:57:55 <ezyang> since people don't mind wanking about data structures.
00:57:59 <ezyang> (as far as I can tell)
00:58:03 <ezyang> edwardk: heh.
00:58:45 <edwardk> the main points i wanted to make were that fingers existed before hinze and paterson. they just made them faster and more functional, and that there is a reason for the 'slop' in the structure
00:59:00 <ezyang> And this is a very much, "Dust off what you remembered from your Data Structures and Algorithm class, and now let's go further!"
00:59:23 <edwardk> but to get there it took me pretty far afield, since i basically had to motivate it by taking a tour through all the cheesy variations on trees you can think of and then some
00:59:29 <ezyang> Yeah.
00:59:34 <ezyang> I don't mind. :-)
00:59:49 <ezyang> Though I'll need to read through the slides more carefully than in my sleep-depped state right now
01:00:10 <edwardk> I thought the Yaron Minsky quote was timely given that he was just up here at Northeastern and Harvard giving talks on "Effective ML"
01:00:44 <ezyang> (Any relation to the Marvin Minsky?)
01:01:05 <edwardk> i'll see if i can steal some time tomorrow to flesh it out further before the talk, but I'd be comfortable ending here if i had to tomorrow.
01:01:20 <edwardk> no idea, he's a jane street guy
01:02:04 <ezyang> Interesting.
01:02:30 <ezyang> ok, off to sleep now
01:02:38 <edwardk> it also turned out to be trickier than i thought it would be to figure out the connection between the 2-3 tree from the hinze and paterson paper and the one people would expect
01:02:39 <edwardk> k
01:02:41 <edwardk> night man
01:02:50 <ezyang> night :-)
01:07:43 * Saizan keeps seeing fingertrees everywhere
01:08:12 <edwardk> saizan: =)
01:09:02 <edwardk> my current 'they are everywhere!' effect is coming from these shape-annotated comonads that i've been using
01:09:23 <edwardk> jbapple: i stole one of your types about 3 hours ago ;)
01:09:37 <edwardk> doh, that was a signoff, not a signon
01:09:41 <edwardk> helps to read ;)
01:18:50 * hackagebot graphics-drawingcombinators 1.4.1 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.4.1 (LukePalmer)
01:22:17 <edwardk> getting some sleep as well
01:42:49 <o-_-o> is it even humanly possible to understand everything that is happening in haskell space ?
01:43:02 <pastorn> o-_-o: wut?
01:43:49 <o-_-o> pastorn, I have some 4 -5 tabs open with links from /r/haskell and each one is talking about something different and varied.
01:44:17 <pastorn> o-_-o: i have 14...
01:44:43 <o-_-o> pastorn, haha...you win!
01:45:34 <dcoutts_> o-_-o: the biannual HCAR (Haskell Communities and Activities Report) gives a very good overview of what is going on
01:45:37 <pastorn> o-_-o: i could kill some of them... now i have 9
01:45:44 <dcoutts_> o-_-o: http://www.haskell.org/communities/
01:46:52 <o-_-o> I could kill almost all of them except probably 4
01:47:12 <o-_-o> I can kill firefox, it is only cat theory
01:47:55 <o-_-o> http://www.haskell.org/pipermail/reactive/2008-November/000054.html
01:48:11 <o-_-o> these are the things that make haskell attractive :-)
01:50:00 <arcatan> i put a fmap in your fmap.. yeah, yeah, i go away
01:50:28 <pastorn> arcatan: u liek dem?
02:06:56 <Younder> spring is here..
02:07:18 <Younder> Toatally drenched in work on my functional language Formula.
02:07:53 <Younder> Still. its as much fun as one can have with our panths on ;)
02:08:11 * hackagebot hxt-cache 0.0.5 - Cache for HXT XML Documents and other binary data  http://hackage.haskell.org/package/hxt-cache-0.0.5 (UweSchmidt)
02:14:54 <pastorn> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
02:14:55 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
02:33:57 <opqdonut> @unpl fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))
02:33:58 <lambdabot> ((fix ((<$>) <$> ((:)))) <*> ((((\ h i -> i >>= h) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ d -> d * 2))
02:34:02 <opqdonut> gee thanks :D
02:43:14 <quicksilver> opqdonut: I don't think @unpl knows what <$> means
02:43:20 <quicksilver> opqdonut: otherwise it would have more scope.
02:43:29 <alpounet> hi
02:45:05 <opqdonut> quicksilver: figured as much
02:45:41 <pastorn> @type (<$>)
02:45:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:45:53 <pastorn> can't you just replace that with fmap?
02:46:13 <quicksilver> yes, <$> is fmap
02:46:20 <quicksilver> but @unpl and @pl don't know that.
02:46:33 <pastorn> found the code here: http://uncyclopedia.wikia.com/wiki/Haskell
02:46:37 <quicksilver> they also don't know its precedence or its associativity
02:46:43 <pastorn>     “Haskell is compiled from .hs-files which means HOMO SEXUAL”
02:46:45 <pastorn>     ~ Oscar Wilde on Haskell
02:46:49 <quicksilver> so they potentially get that completely wrong (haven't checked if they do)
02:52:25 * Maxdamantus thought Wilde died a century ago
02:53:10 <Younder> anyone have any recomentations of books on concurrent programming?
02:53:17 <ivanm> pastorn: :o
02:53:54 <Younder> I have already got 'The art of multiprocessor programmng'
02:54:19 <Maxdamantus> I see.. Uncyclopedia.
02:55:10 <Maxdamantus> Halflife logo O_o
02:55:32 * Maxdamantus always thought it looked kind of like Aphex Twin's logo.
02:56:29 <opqdonut> which both resemble a lambda
02:56:34 <opqdonut> guess which of these came first
02:56:41 <Maxdamantus> Oh, so that's what it is.
02:56:52 <Maxdamantus> Does the AT one have that intention too?
02:57:22 <Younder> haskell reduces to a form of lambda calculus before compilation
02:57:34 <Younder> called Fw
02:57:54 <idnar> @unpl fix$fmap `fmap`(:)`ap`((`fmap`((:[{- thor's mother -}])`fmap`))(=<<)`fmap`(*)`fmap`(*2))
02:57:55 <lambdabot> ((fix (fmap fmap ((:)))) >>= \ k -> (fmap (fmap (fmap (\ h i -> i >>= h) (\ b -> fmap (\ a -> a : []) b)) (*)) (\ d -> d * 2)) >>= \ j -> return (k j))
02:57:59 <opqdonut> I wouldn't try to fathom Richard D. James's intentions ;)
02:58:05 <idnar> @. pl unpl fix$fmap `fmap`(:)`ap`((`fmap`((:[{- thor's mother -}])`fmap`))(=<<)`fmap`(*)`fmap`(*2))
02:58:05 <lambdabot> (fmap (fmap (fmap (=<<) (fmap return)) (*)) (2 *) >>=) . (return .) =<< fix (fmap fmap (:))
02:59:00 <Younder> try implementin a funcional language or ... a tutorial by Simpn P. Jones et al
03:00:03 <Maxdamantus> Mmm.. I think it's the recursion so far that I can't think how would be implemented efficiently.
03:00:19 <Younder> actually leaned a great del about labda calculus from it. Previously only had that bardenrech book
03:00:57 <Younder> Maxdamantus, you have head of tail recursion?
03:01:03 <Maxdamantus> Yes.
03:01:24 <Younder> well then
03:01:32 <quicksilver> tail recursion is not the key observation on how haskell recursion is implemented.
03:01:33 <Maxdamantus> But Haskell looks like it can't all be done using tail recursion O_o
03:01:47 <quicksilver> have a look at the G-machine or the STG machine
03:01:53 <quicksilver> SPJ's book is a good reference.
03:02:04 <Younder> quicksilver, I have
03:02:24 <quicksilver> yes, you already said; I was recommending it to Maxdamantus
03:02:49 <Anchakor> hi, does anyone have any example code how would one make a program which computes something until the time (0.7s) runs out and then it returns what it has computed?
03:03:02 <Younder> quicksilver, you should probaly know that it was changed since it's inception to allow tail recursion usein a 'scheeme' model
03:04:07 <Maxdamantus> The way I see it it'd need a crazily complex caching system.
03:04:35 <Younder> all cashing systems are crazyly complex ;)
03:04:58 <quicksilver> Maxdamantus: there is not really a caching system involved in recursion.
03:05:01 <Maxdamantus> Not the caching itself, but what manages that
03:05:04 <Younder> solutions to a problem that shouldn't even be there
03:05:36 <quicksilver> Maxdamantus: I'm not capable of explaining the STG evaluation process concisely, it takes several pages and SPJ explains it better than me anyway.
03:05:45 <Maxdamantus> Heh.
03:05:55 <Younder> writing a cache friendly concurrent collector is proving quite the challenge..
03:05:57 <quicksilver> the only sense of 'caching' in haskell evaluation is that named values are only calculated once.
03:06:14 <quicksilver> thunks, once forced, overwrite themselves.
03:06:15 <Maxdamantus> Is that strictly true btw?
03:06:42 <opqdonut> not when parallelism comes into play
03:06:46 <quicksilver> Maxdamantus: it's strictly true if I define the terms carefully to mean what I need them to mean for it to be true :)
03:06:46 <opqdonut> but pretty much even then
03:06:56 <Younder> quicksilver, anyhow I never understood the choice of garbage collector used for Haskell
03:07:15 <Younder> it just seems wrong..
03:08:23 <Maxdamantus> I meant according to the language - I'd presume so though.
03:08:54 <Younder> Me I a using a 3 generational collector. first two are stop and copy an the third is a mark and sweep. if fragmented to much it does compaction.
03:08:55 <Maxdamantus> Obviously you don't need to use some STG thing to implement Haskell - it should be simple to implement if you have an infinite amount of memory.
03:09:57 <Younder> compaction is done to make it more cache friendly
03:10:04 <quicksilver> Maxdamantus: absolutely, you don't need STG
03:10:10 <quicksilver> Maxdamantus: it's just "efficient" in some sense
03:10:19 <quicksilver> and GHC no longer uses STG, in fact
03:10:33 <quicksilver> but it remains a very interesting book to read in terms of thinking about efficient ways to implement functional languages.
03:10:49 <quicksilver> you can quite happily implement haskell using a fairly naive lambda reduction strategy.
03:10:57 <Maxdamantus> So what is "STG" exactly?
03:11:04 <Maxdamantus> Is it the author's initials, or what?
03:11:05 <quicksilver> well, it's the spineless tagless G-machine.
03:11:09 <Maxdamantus> Wiki doesn't seem to help
03:11:10 <Maxdamantus> Ah.
03:11:43 <quicksilver> this is the book I mentioned, that Younder mentioned before I believe: http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
03:12:44 <Adamant> what does GHC use now instead of the STF, btw
03:13:12 <quicksilver> I don't think it has a name Adamant
03:13:24 <Maxdamantus> "The back end of the compiler transforms Core code into an internal representation of C--, via an intermediate language STG (short for "Spineless Tagless G-machine").[7]  The C-- code can then take one of two routes: either it is printed directly as C code, or it is converted into native machine code (the traditional "code generation" phase)."
03:13:29 <quicksilver> it's "the STG which has been hacked like this and like that and now it's something else"
03:13:36 <Adamant> ah
03:15:58 <Younder> quicksilver, yes I am reading it now. The original 1987 book
03:16:59 * Maxdamantus cbf figuring out how to use latex and tries the PDF version
03:17:15 <Younder> The one that describes transforming miranda into fw as well as making machine code for that G-machine (Fw)
03:18:41 <Younder> There is a later version that doesn't discuss translating into the G-macine
03:18:47 <Younder> machine
03:19:05 <fasta> There is also a more up to date guide to GHC after you read that book, IIRC.
03:19:36 <Maxdamantus> "Page 1 of 296" :\
03:20:18 <quicksil1er> gah.
03:20:54 * Maxdamantus likes looking for brief descriptions of these things and imagining how they might work in greater depth while he should be sleeping
03:21:06 <Maxdamantus> s/looking/looking on Wikipedia/
03:21:08 <quicksil1er> Maxdamantus: what I tried to say when freenode ran away from me was:
03:21:18 <quicksil1er> Maxdamantus: yes, that quote has not been strictly correct for quite some time.
03:21:22 <quicksil1er> even when the so-called "via-C" path was the dominant one (GHC 6.4 and 6.6) it wasn't really C
03:21:25 <ivanm> I have no idea about hosting, etc. but with all the frequent downtimes c.h.o, etc. have had recently would a virtual host on an EC2 service or something be better/more reliable?
03:21:29 <quicksil1er> it was a mess, which GCC compiled into another mess, which was mangled into a third mess, which could be assembled into native code.
03:21:40 <quicksil1er> the native code gens are now preferred anyway.
03:21:43 <Lemmih> Maxdamantus: All you really need to understand is how the two primitives 'eval' and 'apply' works.
03:21:48 <quicksil1er> and the STG is no longer entirely tagless and I'm don't know whether it is truly spineless.
03:22:09 <ivanm> quicksil1er: s/1/v/ ?
03:22:21 <Lemmih> Maxdamantus: All other things are just irrelevant implementation details.
03:22:24 <quicksil1er> ivanm: freenode thinks the old me is still around
03:22:30 <ivanm> quicksil1er: /ghost
03:22:38 <quicksil1er> ivanm: /shrug
03:22:39 <quicksil1er> ;)
03:22:42 <ivanm> heh
03:22:47 <ivanm> fair enough
03:23:39 <Maxdamantus> irssi turns v into 1? O_o
03:23:56 <Maxdamantus> It turns the t in my name to 1 - presumably because t looks similar to 1.
03:23:59 <ivanm> Maxdamantus: that's probably his backup nick
03:24:32 <Lemmih> Maxdamantus: GHC, lhc, jhc and uhc all uses eval/apply (and nothing else) to implement Haskell's nonstrict semantics.
03:24:39 <Maxdamantus> Mmm.. irssi seems to make them up automatically though.
03:27:03 <Younder> optimal garbage collection frequency seems to be about 60 Hx for 1 generatio stop and copy
03:27:10 <Younder> Hz
03:27:16 <hc_e> hi
03:28:25 <Younder> scheeme makes a pretty good fw style core
03:28:51 * Maxdamantus should probably look at scheme.
03:29:05 <Younder> I recommend 'Lisp in smallpeices' by Quinnec
03:30:39 <Younder> Lisp in Small Pieces
03:31:02 * Maxdamantus did Logo at school once, but forgot everything.
03:31:13 <Maxdamantus> I remember it had square brackets O_o
03:35:34 <Younder> well if you want to LEARN scheeme SICP (Structured Introduction to Computer Programming) is the way to go
03:36:11 <Younder> 'Lisp in small pieces' discusses implementing it
03:37:06 <Maxdamantus> Lisp has seemed to me something that's meant to be simple to implement
03:40:21 <Maxdamantus> I've heard of it specifically having tail recursion, so presumably it doesn't involve the recursion required for Haskell or something
03:40:21 <Younder> Well it isn't easy to make it efficient
03:40:21 <Maxdamantus> Efficient, maybe not.
03:40:21 <Maxdamantus> But there's not much of a limit to that.
03:40:21 <Younder> scheeme is basically lambda calculus so haskell is not so different
03:40:21 <Adamant> you can also ask in #scheme
03:40:21 <Maxdamantus> When you say scheeme, do you mean Scheme? O_o
03:40:21 <Younder> The same issues apply
03:40:21 <quicksilver> Maxdamantus: many lisp programmers will assume that tail calls are optimised, so it's commonly expected of lisp implementations.
03:40:25 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Robin Milner"]'
03:40:25 --- topic: set by Pseudonym!~ajb@torchwood.alicorna.net on [Tue Mar 23 22:12:43 2010]
03:40:25 --- names: list (clog yuriks_ Nomad010 perspectival niksnut iizukaway idnar alec mapreduce hrehf noam hc_e Katie alb bgs1001 lyn visof_ scree_ helgikrs maurer_ LeoD_ blackdog_ SubStack_ AnAdorab1eNick dever_ quaestor_ hugin_ chr1s_ killing-1oke koala_man lyndon companio1_square AndyP_ cYmen_ mwc_ aep_ snr kulin_ eek ksandstr_ noj_ kolmodin_ quicksilver BONUS mietek tew88_ aiko- ybit3 eb8490 flux cheater3 dju_ SecretofMana twanvl_ pasc1 \net obraun khiroc iblechbot dolio)
03:40:25 --- names: list (gio123 Raynes path[l] jonafan_ gogonkt pukka miclorb Xyzzy leino tomh- silver ivanm pyNem Schmallon Yakusa FunctorSalad_ shaleny tltstc amiri Taejo gehmehgeh triplez Fallen_Demon TR2N LouisJB_ waterlaz dpratt71 prateek Asztal sepp2k egoz Walt edon siracusa fridim dschoepe RayNbow `0660 Spockz Shown comak levitation[A] Younder jejansse tab maxter Philippa potatishandlarn Beetny nff masklinn EvanR-work Hunner_ TacticalGrace stenobot2010 shortcircuit netcat)
03:40:25 --- names: list (dionoea burp tromp_ nniro kevinclark Raku^ djinni thorkilnaur tavelram Valodim eyck objorn otulp bigorilla det Eghie Contra nekochan Draconx fabiim araujo Mr_Awesome DanC Philonous tov_ birkenfeld dfeuer dubhrosa dmpots orlandu63 dibblego chittoor mun_ rl Feuerbach fmardini m-i-l-a-n Ycros lsthemes roconnor m3ga trzkril eevar2 Spaceghost shag mdordal2 Cthulhon mreh bo0ts__ hackagebot danvet raichoo olsner d0ugal Exteris Stalafin snowbeard freiksenet bastl)
03:40:25 --- names: list (Bjorn^2 cydork dreixel tsbo fnordus shintah scm ketil Wardub_ novas0x2a sshc Torrieri sbahra augur tilman ydo otto_s_ zakwilson__ jkoshy bqf_ Poeir hadronzoo DigitalKiwi tommd kpreid fonz JuanDaugherty gwern juhp_ Bassetts taybin ttmrichter nanothief Mathnerd314 jacobian eevar__ quuxman theorbtwo saccade_ Gracenotes ilhvm Saizan pikhq dmwit Polarina aristid FliPPeh_ Trafalgard The_third_man fnord123 bbee jaj gereedy boyscared orbitz sbasuita ceii1 winxordie)
03:40:25 --- names: list (glguy thetallguy1 ickabob LouisJB jmg PsiOmega nominolo_ c9s dancor gbeshers droidcore myu2 somnium HeMan Nshag neurogeek fryguybob PepeSilvia Berengal smorg jmv Gertm necroforest flippo Cale cjs |Jedai| mun mjrosenb htoothrot mm_freak FauxFaux alpounet pielgrzym lambdabot Igloo dcoutts_ eldragon JaffaCake fasta Entroacceptor cozmic raymonvw IceDane Agnostos te StarFire equanimity tibbe samulihs nominolo vili1 Mowah OnionKnight Sgeo_ rankles lpsmith)
03:40:25 --- names: list (twobitsprite alexsuraci xinming systemfault twink preflex mauke orclev pkrumins LoRe timofonic b4taylor shrughes Choko stepnem Eelis Taggnostr2 woggle sclv Adamant [swift]1 CalJohn ClaudiusMaximus dual Sam__ sm_ newsham mikste wisemanby cognominal voker57 michael| joni6128 yahooooo sjanssen sm ingy blackh mexisme integral welterde Aisling Zeiris Amadiro Ferdirand Liskni_si ptrf MadX` jsk-afk Botje McManiaC deadguys mail rtaycher Dunearhp eno phnglui Zao)
03:40:25 --- names: list (ps-auxw iratsu SimonRC eikke flori alexbobp Aikawa QtPlatypus kynky saccade _2x2l m4thrick Twey CompanionCube kniu nlogax Apocalisp tensorpudding thetallguy electrogeek kermit mle magicman|gone dons ville rsaarelm frederik dwon benmachine jorizma mornfall solrize jvoorhis Maxdamantus sohum muhtimin joga miasma wto absentia hiredman drhodes mindCrime_ inr ricky Tass_ jimmyjazz14_ nathanic_work dcoutts wagle mfp lomeo nasloc__ shepheb Khisanth clarkb a11235)
03:40:25 --- names: list (edwinb d-snp Lars`` glith kyagrd kennethd trez epokal cjay nimred byorgey mq opqdonut ziman gdsx Vq Gabbie galdor DustyDingo Tinned_Tuna nothingmuch yottis MacCoaster qebab p_l danderson jbauman erg Deewiant endojelly encryptio dcolish soeren jayne koninkje_away xerox tviyLog ahlmal kar-1 luite exDM69 jvogel Runar o-_-o Arnar npouillard andrewsw djahandarie impl vpetro gds Laney fabjan ibid Innominate amontez creichen mfoemmel Jon igorgue arkx dropdrive Rooz)
03:40:25 --- names: list (inclement strobedream ve Boney drbean zygoloid defn Reisen greedo felipe_ emma josswr uorygl teratorn gbacon dogmaT_ cypher etpace clanehin futilius bd_ Davse_Bamse muep pettter epmf Sisu Lemmih shachaf norm2782 ibt beatmox hellige taruti sebbe1991 davidL jdsc_ Wolong koeien eagletmt tumult untwisted Veinor medical joed Ytinasni russell_h radhermit BrianHV willb pwerken mk64ftw_ shutdown_-h_now dqd tridactyla jmcarthur Nanar mlh TML syntaxglitch Stephan212)
03:40:25 --- names: list (kosmikus inhortte cyanoacry erk_ karld dino- Paradox924X ido chromakode palmje allbery_b ski jml ctrlfrea1 twn Ornedan_ chrissbx slabanja caligula__ Counter-Strike cebewee srcerer profmakx jrockway Tomas MrDomino^ jd10_ shadowspar UnderTaLker canvon tafryn megaTherion xcvii Cerulean majoh Ke guerrilla Blub\0 aleator Jiten tamiko harlekin cods Astro laz0r ath copton mattam mrshoe AnMaster inimino agemo zsol liff PHO_ arcatan dejones Bleadof pshc Becquerel)
03:40:25 --- names: list (dumael duairc ennen sproingie emias EvanR eintopf mux osfameron tomaw _br_ theclaw aavogt ehamberg jlouis Gilly SamB_irssi icee tyfon CosmicRay helino ponzao____ borism tmug Vulpyne int-e nornagon kwinz saiam dilinger bremner teukka ra1m0 jix HandheldPenguin ToRA Milo- Nereid fab__ dixie jamwt ahihi andersk mercury^ companion_cube wolverian jql amx And[y] bolmar matthew-_ stroan ezyang monochrom davean alip noddy ernst albertosantini DrSyzygy __marius__ mrd)
03:40:25 --- names: list (ahf kaol aslhk pastorn Baughn mokus_ go|dfish thoughtpolice regulate @ChanServ kalven suiside skaar sbok)
03:40:28 <quicksilver> Maxdamantus: it's not universal - elisp doesn't do TCO.
03:40:31 <Maxdamantus> Yeah, but the recursion in Haskell isn't simple tail recursion.
03:40:39 <quicksilver> I'm not sure what you mean by that.
03:40:44 <quicksilver> recursion is what it is.
03:40:59 <quicksilver> in haskell, and in lisp, a recursive call may sit in the tail position or it may not.
03:41:15 <quicksilver> the compiler may try to do a clever optimisation if the recursive call is in the tail position, or it may not.
03:41:37 <quicksilver> "tail recursion" is a syntactic property of certain expressions, that's all.
03:41:48 <Younder> haskell is lazy..
03:42:14 <Maxdamantus> Mmm.. That too, which probably both simplifies and complicates things.
03:42:18 <quicksilver> most compilation techniques have some kind of limit on "how deep" you may recurse. TCO is one way to avoid that limit in one specific case.
03:42:42 <quicksilver> non-strict languages permit an approach which avoids that limit in a different case too
03:42:53 <quicksilver> naively, "GC'ing the stack as you go along"
03:43:03 <Younder> Haskell by it's nature makes halting intractable
03:43:03 <quicksilver> that's what happens when you do "map (+1) [1..]"
03:43:22 <Younder> You need that my
03:45:17 <ManateeLazyCat> If i use command "darcs send -a", it will send all patches in *one* mail?
03:45:24 * Maxdamantus is trying to think of an example where tail recursion (not just at the tail) doesn't appear to work :\
03:45:50 <Younder> Maxdamantus, It mostly works
03:46:30 <Younder> The optimiser in GHC is quite clever
03:48:15 <Younder> Maxdamantus, It doen't work for anything that can't be eveluated as a loop. Like the number of permutations
03:48:35 <Younder> since you wonder
03:50:35 <Maxdamantus> I think I'm thinking of tree traversal, which would probably be similar
03:50:56 <Younder> Maxdamantus, nop
03:50:58 <Maxdamantus> Mmm.. Probably shouldn't need infinite recursion there anyway
03:51:46 <ManateeLazyCat> Darcs can send many patches separately?
03:51:54 <ivanm> yes
03:51:55 <Younder> nop
03:51:59 <ivanm> just send one at a time!
03:52:24 <Younder> ahh, OK
03:53:25 <Younder> For a moment there I  was confused
03:54:08 <ManateeLazyCat> ivanm: Example, i have 10 patches have record, have any tips that darcs will send those patches in 10 times?
03:54:24 <ivanm> wait, you want to send them all 10 times? :o
03:54:33 <ivanm> Younder: :D
03:54:34 <ManateeLazyCat> ivanm: No,
03:55:37 <ivanm> then what?
03:55:40 <ManateeLazyCat> ivanm: Example, i have patches : P1, P2, P3, i want darcs send those patches in different patches, and i know i can "yes" to first, exist, and "yes" to second.
03:56:03 <ManateeLazyCat> ivanm: But i want some tips that darcs can send every patches in different mail.
03:56:12 <ivanm> oh, you're sending by mail...
03:56:24 <Younder> mail?
03:56:46 <ivanm> Younder: darcs send
03:56:47 * ManateeLazyCat Oh, no my gtk2hs Cabal patches is too big than 300KB.
03:56:50 <ivanm> I take it they're too big to send together?
03:57:17 <ManateeLazyCat> ivanm: I use "darcs send" send all patches, 1.5MB.
03:57:19 <ivanm> doesn't look like it
03:57:24 <ivanm> ManateeLazyCat: try #darcs
03:57:29 <ManateeLazyCat> ivanm: So i send patche one by one, but still too big.
03:58:20 <Botje> ManateeLazyCat: darcs send includes all the history as well.
03:58:30 <Botje> so you're not going to gain much by sending them separately
03:58:52 <ivanm> darcs send --no-deps ?
03:58:54 <Entroacceptor> just zip them?
03:59:06 <ivanm> ManateeLazyCat: get a better mail provider? :p
03:59:09 <Botje> ManateeLazyCat: you could push your changes to a repository and ask the other person to pull from there
03:59:18 <ManateeLazyCat> ivanm: I use sendmail.
03:59:20 <Botje> zipping /could/ work
03:59:29 <ivanm> ManateeLazyCat: so do I
03:59:35 <ivanm> it has nothing to do with size limits AFAIK
03:59:51 <ManateeLazyCat> Botje: Yes, i have permission to push gtk2hs.
04:00:04 <ManateeLazyCat> Botje: But i want Axel review them before i push.
04:00:20 <Botje> ManateeLazyCat: so put your changes in a separate repository first?
04:00:31 <Saizan> ManateeLazyCat: use darcs send -O to get them to a file, gzip and send that
04:00:31 <Botje> and ask him to pull from there to inspect your changes
04:01:08 <ManateeLazyCat> Saizan: Thanks, i try to do that.
04:02:40 <ManateeLazyCat> All gtk2hs can install gtk2hs by Cabal if Axel apply my patches tonight.
04:02:51 <ManateeLazyCat> s/All gtk2hs/All gtk2hs users.
04:06:34 <eevar2> even the poor windows users?
04:07:02 <FunctorSalad_> you do gtk2hs now? :) I just saw you in my elisp folder yesterday IIRC
04:07:07 <ivanm> eevar2: doesn't make a difference?
04:07:14 <ManateeLazyCat> eevar2: Windows perhaps can't, but it's easy to fix because all packages install by Cabal.
04:07:18 <ivanm> FunctorSalad_: you saw eevar2 in a folder?
04:07:25 <FunctorSalad_> ivanm: ManateeLazyCat
04:07:29 <ivanm> ahhhh
04:07:36 <ManateeLazyCat> FunctorSalad_: Which elisp?
04:07:36 <ivanm> FunctorSalad_: he hates emacs now
04:07:59 <ManateeLazyCat> Yes, i hate so much.
04:08:03 <FunctorSalad_> ManateeLazyCat: maybe lazycat-toolkit (I was just organizing stuff)
04:08:16 <ManateeLazyCat> FunctorSalad_: Enjoy.
04:08:33 <FunctorSalad_> is this tongue-in-cheek or do you seriously dislike emacs now?
04:08:37 <FunctorSalad_> sorry, ot
04:08:49 * ManateeLazyCat I should send patch when i record one, and not send after record all, i need wait seconds. 
04:09:37 <ManateeLazyCat> FunctorSalad_: I'm developing my Haskell-Application-Platform to replace Emacs, firefox, all others.....
04:10:25 <jacobian> :)
04:10:53 <ManateeLazyCat> FunctorSalad_: Not kidding. :)
04:11:16 <blackdog_> elisp is the worst thing in the world apart from everything else
04:11:20 <FunctorSalad_> I much prefer Haskell too, but there's so much stuff already done in emacs that would have to be redone...
04:11:28 <ivanm> blackdog_: heh
04:11:33 <ivanm> FunctorSalad_: exactly
04:11:38 <Entroacceptor> and the lazy cat is doing that atm ;)
04:12:07 <eevar2> trimming the feature set a littel couldn't hurt when we're talking emacs
04:12:09 <ManateeLazyCat> FunctorSalad_: Problem is elisp try to do everything.
04:12:10 <Saizan> FunctorSalad_: or we could just add an elisp interpreter :)
04:12:20 <ManateeLazyCat> FunctorSalad_: I choose Haskell base on Gtk+
04:12:45 <ManateeLazyCat> FunctorSalad_: Then we can contribution code to Gtk+, then other peoples can use it.
04:12:59 <FunctorSalad_> Saizan: I thought about that for a second too... ideally, in a way where you can replace it with haskell step by step
04:13:10 <ManateeLazyCat> FunctorSalad_: Not like Emacs, you just can use it's feature in elisp.
04:13:17 <ManateeLazyCat> FunctorSalad_: Same to Haskell.
04:13:49 <ManateeLazyCat> FunctorSalad_: We need work together, and like elisp implementation, even elisp haven't that power.
04:13:50 <FunctorSalad_> ManateeLazyCat: hmm I don't see what's wrong with doing it all in one language... I thought it's elisp in particular
04:14:10 <ManateeLazyCat> FunctorSalad_: IMO, elisp is bad language for big project like Emacs.
04:14:31 <FunctorSalad_> I tend to agree FWIW (without knowing much in depth)
04:14:33 <ManateeLazyCat> FunctorSalad_: BTW, i'm not clone Emacs like Yi.
04:14:54 <ManateeLazyCat> FunctorSalad_: Dynamic type check is evil, that's why i hate elisp.
04:15:09 <ManateeLazyCat> FunctorSalad_: Even dynamic type check can make you do something cool.
04:15:11 <FunctorSalad_> ManateeLazyCat: sounds like the unix philosophyy (the part about reusable components you mention)
04:15:17 <ManateeLazyCat> FunctorSalad_: But dynamic check is not safe.
04:15:23 <FunctorSalad_> yeah
04:15:38 <FunctorSalad_> and is a performance cost
04:15:56 <ivanm> on the other hand, elisp has eval!
04:16:08 <ivanm> which is nicer for the kind of ad-hoc changes emacs lets you do
04:16:17 <FunctorSalad_> I found the "component" philosophy a bit lacking in graphical-app land too
04:16:21 <ManateeLazyCat> FunctorSalad_: I'm build multi-processes framework base on Haskell/Gtk+, so i don't care people write what extension, i just provide a safe, fast platform to protect core won't cash.
04:16:22 <FunctorSalad_> not that I could do it better
04:16:37 <blackdog_> ManateeLazyCat: something like UZBL, then?
04:16:53 <ManateeLazyCat> blackdog_: I won't use uzbl, we have finish webkit in gtk2hs.
04:17:02 <ManateeLazyCat> blackdog_: But most like that.
04:17:17 <FunctorSalad_> (the frameworks may be modular internally; I mean I can't combine them easily as a user, like I can with commandline apps)
04:17:41 <ManateeLazyCat> blackdog_: I build daemon processes to provide server, all extension running in separate child processes.
04:17:52 <ManateeLazyCat> FunctorSalad_: Use DBus.
04:17:57 <FunctorSalad_> ivanm: haskell has it too with the ghc api
04:18:08 <ManateeLazyCat> FunctorSalad_: I use DBus transform message between server process and plug-in process.
04:18:10 <FunctorSalad_> ivanm: way more effort, granted
04:18:13 <ivanm> yeah
04:18:31 <FunctorSalad_> ManateeLazyCat: I need to learn one of the haskell APIs for it
04:18:37 <FunctorSalad_> seemed a bit scary at first sight :o
04:19:02 <FunctorSalad_> (I could just call qdbus via System.Process I guess ;))
04:19:07 <ManateeLazyCat> FunctorSalad_: Happy hacking Haskell. :) I love it so much.
04:19:21 <ManateeLazyCat> FunctorSalad_: search dbus-core and dbus-client.
04:19:41 <ManateeLazyCat> FunctorSalad_: Finish by John, stable and fast, i have test it's API many times.
04:19:44 <FunctorSalad_> ManateeLazyCat: that's the most stable one?
04:19:55 <FunctorSalad_> (there's network-dbus or so, and another one I think)
04:20:01 <ManateeLazyCat> FunctorSalad_: Yes, i integrate it with my gtk2hs code.
04:20:06 <FunctorSalad_> I see
04:20:18 <ManateeLazyCat> FunctorSalad_: Trust me, dbus-core and dbus-client is best one.
04:20:24 <FunctorSalad_> ok :)
04:20:28 <ManateeLazyCat> FunctorSalad_: And most time, you just need APIs in dbus-client.
04:21:11 <FunctorSalad_> ivanm: higher-order functions often make eval unnecessary though (in fact I almost never need it in lisp either)
04:21:38 <FunctorSalad_> "macrolet" is a hidden eval though, isn't it? ;)
04:22:22 <ManateeLazyCat> FunctorSalad_: And use Haskell build big project like Emacs is very cool, it's give me more clean logic, not like write C as elisp syntax.
04:23:08 <FunctorSalad_> ManateeLazyCat: totally agreed
04:23:37 <ManateeLazyCat> FunctorSalad_: Because elisp is dynamic type check, it's bugs is endless.
04:23:45 <FunctorSalad_> the type system is a (weak) kind of proving system, after all
04:24:22 <FunctorSalad_> or strong, depending on how far you take it...
04:25:20 <ajcc> If I have any list, and give it as an argument to a function. Can I always use function (x:xs) to get the head and the tail of that list? (ignore the special case of an empty or single unit list) And why can I do so?
04:26:07 <Botje> ajcc: yes. you're decomposing the cons cell you get and binding the parts to variables
04:26:18 <Botje> (and a single unit list will still work)
04:28:00 <ManateeLazyCat> FunctorSalad_: Emacs bugs break my heart, really.
04:28:38 <ajcc> Botje: hmm, so it works just like 6:[1,2,3] in theoretical terms?
04:28:39 <ManateeLazyCat> FunctorSalad_: One time, because Emacs, i lost one day work....
04:29:03 <Botje> ajcc: 6:[1,2,3] is the same as 6:1:2:3:[]
04:30:24 <ajcc> Botje: yes, that's what confuses me a little. But I imagine I could get three of four or five variables from the list, if there was enought units in a list?
04:31:10 <Botje> yes.
04:31:41 <ajcc> Botje: Ok, then I think I understand it now :) Thanks!
04:32:06 <Botje> if the list is not big enough the pattern match will fail and you'll go to the next or get an error
04:32:28 <FunctorSalad_> ManateeLazyCat: many more debugging elisp, I suppose
04:33:44 <FliPPeh_> Could someone explain me the "log" function? When I use "log" in xcalc on the number 100, I get "2", but if I do it in GHCI, I'm getting...
04:33:47 <FliPPeh_> > log 100
04:33:48 <lambdabot>   4.605170185988092
04:33:51 <ajcc> Botje: and the list must be at least n-1 arguments long, since an empty list is still a list
04:34:07 <Saizan> FliPPeh_: it's base 2 log, not base 10
04:34:14 <Saizan> > logBase 10 100
04:34:14 <lambdabot>   2.0
04:34:20 <ManateeLazyCat> FunctorSalad_: Key is, i don't want waste time to debug bug, i want a mechanism to protect other sub-module won't crash, and result is multi-processes framework.
04:34:22 <FliPPeh_> Ahh, thanks a lot :)
04:34:52 <Botje> ajcc: ehh, yeah, i think so. try it and see :)
04:35:09 <ManateeLazyCat> FunctorSalad_: I want limit bug's bound.
04:35:37 <ManateeLazyCat> FunctorSalad_: Think this, some w3m bug freeze Emacs make you can't do anything except kill Emacs.
04:35:39 <Maxdamantus> Doesn't seem to be 2.
04:35:44 <Maxdamantus> Looks more like e.
04:35:45 <ManateeLazyCat> FunctorSalad_: And you lost you work.
04:36:04 <Saizan> ManateeLazyCat: yeah, sorry
04:36:14 <Saizan> err, to Maxdamantus
04:36:24 <FunctorSalad_> ManateeLazyCat: isn't that a bug in the elisp implementation itself? Thought condition-case should let you compartment errors away
04:36:55 <ManateeLazyCat> FunctorSalad_: Simple, any Emacs bug will crash all program and all sub-modules.
04:36:59 <FunctorSalad_> ManateeLazyCat: in fact, I use a macro that wraps every toplevel statement in condition-case, so my initfile doesn't abort if one thing is wrong ;)
04:37:00 <ManateeLazyCat> FunctorSalad_: And elisp is damn slow.
04:37:09 <Maxdamantus> > log e 100 where e x = 1/fac x + e (x - 1) where fac n = if n == 0 then 1 else n * fac (n - 1)
04:37:10 <lambdabot>   <no location info>: parse error on input `where'
04:37:15 <Maxdamantus> :(
04:37:46 <ManateeLazyCat> FunctorSalad_: But for code that written by other peoples?
04:39:07 <ManateeLazyCat> FunctorSalad_: Emacs try to use Text describe everything, and result is : it's wrong.
04:39:24 <Maxdamantus> > let e x = let fac n = if n == 0 then 1 else n * fac (n - 1) in if x == 0 then 1 else 1/fac x + e (x - 1) in log (e 100)
04:39:24 <lambdabot>   1.0
04:39:27 <Maxdamantus> Better.
04:39:52 * Maxdamantus wonders if e is already defined somewhere.
04:39:59 <ManateeLazyCat> FunctorSalad_: Emacs break my heart, i won't love it again. That's all.
04:40:00 <siracusa> > exp 1
04:40:01 <lambdabot>   2.718281828459045
04:40:04 <FunctorSalad_> ManateeLazyCat: I thought that if I wrap a (load "foo") in condition-case, my program is safe from any errors in that outside module, except if there's a bug in the language implementation itself
04:40:09 <Maxdamantus> Ah yeah. :\
04:40:12 <FunctorSalad_> I could be wrong
04:40:41 <blackdog_> ManateeLazyCat: yeah, threading & process separation in emacs is pretty bad
04:40:44 <ManateeLazyCat> FunctorSalad_: Only right way to protect un-catch exception is use multi-processes.
04:40:47 <FunctorSalad_> ManateeLazyCat: or maybe you mean the outside lib screws up the emacs environment so it doesn't help me much that my program continues
04:40:49 <FunctorSalad_> :)
04:41:29 <FunctorSalad_> ManateeLazyCat: "text for everything" instead of syntax trees? that'd be nice
04:42:25 <ManateeLazyCat> blackdog_: I separate all extensions from core, all sub-modules running it's own processes, and use DBus communications between core and extension, use GtkSocket/GtkPlug embed extension graphics to *one* Windows
04:42:30 <FunctorSalad_> the process barrier as a last resort is a good idea though
04:42:47 <max_atreides> I want to learn a functional language - is haskell good for that or should I start with something more pure like scheme?
04:42:57 <blackdog_>  FunctorSalad_: good enough for Chrome:)
04:43:03 <ManateeLazyCat> blackdog_: Then user control everything like Emacs, but all extension is running it's own processes, like Chrome, but not just browser.
04:43:16 <Saizan> max_atreides: that's the first time i saw someone call scheme more pure than haskell :)
04:43:21 <blackdog_> max_atreides: ooh, more pure. that'll raise some hackles;)
04:43:35 <FunctorSalad_> blackdog_: I was going to say it... that feature almost convinces me to use chrome, but ff extensions are still to useful
04:43:37 <Maxdamantus> I think he meant pure as in simplicit.
04:43:47 <blackdog_> max_atreides: more seriously, haskell is a fine way to learn functional languages.
04:43:54 <max_atreides> i apologize, i don't know much about functional languages
04:44:06 <Maxdamantus> Scheme's not purely functional afaik
04:44:26 <blackdog_> try real world haskell, if you want to learn how to do useful things in Haskell and learn the language at the same time
04:44:34 <ManateeLazyCat> After i finish gtk2hs Cabal process, and fix a bug of Gtk+ 2.20, i will release first version, then you know the implement detail
04:44:35 <blackdog_> it assumes you already know how to program, though
04:44:58 <blackdog_> FunctorSalad_: I run Chrome for actual browsing. Firebug for dev work.
04:45:02 <ManateeLazyCat> blackdog_: Yes, real world haskell is best practice.
04:45:08 <max_atreides> blackdog_: thanks, i'll check it out. yes, i have background in C and Python
04:45:19 <Saizan> i'm not sure if RWH teaches you a lot of what FP is, isn't it more geared towards getting things done?
04:45:22 <dcoutts_> I generally recommend "Programming in Haskell" for a more basic introduction
04:45:29 <ManateeLazyCat> FunctorSalad_: If you know Chrome, you will get. my design principle
04:45:47 <ManateeLazyCat> RWH just a starter.
04:45:49 <FunctorSalad_> ManateeLazyCat: yes, I think I can roughly see what you're up to :)
04:46:19 <ivanm> dcoutts_: weren't you the one that wrote the review saying that its use of symbols was bad?
04:46:25 <ivanm> Saizan: yup
04:46:31 <ManateeLazyCat> FunctorSalad_: But i'm not mean Emacs is bad, Emacs design is awesome even in today, just Stallman choose bad language to implement it.
04:46:40 <FunctorSalad_> can't disagree with extra robustness and speed (over dynamic langs, the speed part)
04:47:02 <blackdog_> Saizan: sure. but i think it's important to motivate learning more.
04:47:13 <dcoutts_> ivanm: yes, it's still the best however
04:47:19 <ivanm> hmmm....
04:47:31 <ivanm> I quite liked craft, but looking through it recently its obvious how old it is
04:47:36 <ivanm> I mean, it uses Float everywhere!
04:47:39 <max_atreides> sounds interested. yeah, i'm very interested to learn more about functional approach to programming - are there good books on design patterns for functional languages?
04:47:44 <max_atreides> *interesting
04:47:46 <FunctorSalad_> haskell may not be the fastest language, but somehow it feels like there's so much room for improvement with very-strongly typed languages
04:48:08 <FunctorSalad_> because the compiler just knows a lot more...
04:48:28 <ManateeLazyCat> FunctorSalad_: Yes, it's very fast that base on type-check. IMO.
04:49:09 <ManateeLazyCat> FunctorSalad_: I'm surprise other language will be faster if they're strongly like Haskell.
04:49:52 <blackdog_> max_atreides: many design patterns fade into simple function calls with higher-order functions
04:50:27 <blackdog_> max_atreides: but i did see a paper recently spruiking a few different FP patterns
04:51:53 <max_atre1des> blackdog_: thanks
04:52:50 <Maxdamantus> What's FP? Functionally pure?
04:53:03 <siracusa> Functional programming
04:53:04 <FliPPeh_> Functional Programming
04:53:07 <Maxdamantus> Ah.
04:53:08 <FliPPeh_> Damn, beat me to it
04:53:31 <ManateeLazyCat> dcoutts_: Darcs can't do compress when i run command "darcs send"
04:53:33 <ManateeLazyCat> ?
04:54:04 <ManateeLazyCat> dcoutts_: Then decompress those patches when apply?
04:54:32 <DerisionSnort> @msg lambdabot hell
04:54:32 <lambdabot> Not enough privileges
04:54:37 <ManateeLazyCat> dcoutts_: Because my Cabal patches is too big, i can use "darcs send" send patches to maillist.
04:54:59 <DerisionSnort> How do I talk in private with the lambdabot again? :)
04:55:09 <ivanm> DerisionSnort: /msg lambdabot
04:55:14 <DerisionSnort> thanks
04:55:57 <ManateeLazyCat> Darcs send can compress patches?
05:03:39 * ManateeLazyCat Have send gtk2hs Cabal patches to gtk2hs-devel, if anyone want install gtk2hs by Cabal (ghc 6.10 and 6.12), can pull darcs version and apply my patches for a try.
05:06:56 <ArkRost> Hi! Please someone tell me what operators I can overload in haskell?
05:07:06 <ivanm> ArkRost: those from a typeclass
05:07:16 <ManateeLazyCat> ArkRost: Typeclass.
05:07:19 <ivanm> which you overload by making your custom type an instance of that typeclass
05:07:30 <ivanm> e.g. +, *, - are from Num
05:07:43 <ArkRost> and what about =
05:07:48 <quicksilver> = is not an operator
05:07:49 <ivanm> but you can't overload $ or (.) (unless you explicitly don't import the default definition)
05:08:03 <ivanm> you can overload == by creating an Eq instance
05:08:03 <ArkRost> ok thanks
05:08:11 <ivanm> @hoogle haskell basic oleg
05:08:11 <lambdabot> No results found
05:08:14 <ivanm> @hoogle haskell basic
05:08:15 <lambdabot> No results found
05:08:28 <ivanm> wait, it wasn't oleg
05:08:28 <ivanm> duh
05:08:41 <quicksilver> ITYM google not hoogle
05:08:48 <quicksilver> and I think it was augustss
05:09:13 <ivanm> oh, and that ;-)
05:09:15 <ivanm> yeah, it was
05:09:26 <quicksilver> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
05:09:35 <ivanm> quicksilver: heh, just about to paste that
05:09:41 <ivanm> ArkRost: ^^ you can define :=, etc. though
05:13:01 <siracusa> You can use infix data constructors without the ``?
05:15:35 <benmachine> siracusa: no
05:15:37 <fax> > log 100 / log 1
05:15:38 <lambdabot>   Infinity
05:15:59 <benmachine> siracusa: you can however define a function instance for numbers such that 100 x is 100 applied to x
05:16:57 <siracusa> benmachine: Oh, that's weird :-)
05:20:25 <fax> > let m n = 2^n - 1 in (m . m . m . m . m) 2
05:20:30 <lambdabot>   mueval: ExitFailure 1
05:28:22 <jacobian> hmmm, paste is down
05:29:54 <quicksilver> yes, moonpatio is down :(
05:30:00 <quicksilver> use codepad.org, perhaps
05:41:03 <jacobian> http://codepad.org/QvLVsXt1
05:57:21 <FliPPeh_> How comes my GTK2Hs Program sometimes (out of the blue, no warnings) fails with GTK errors such as...
05:57:25 <FliPPeh_> GLib-GIO-CRITICAL **: g_file_equal: assertion `G_IS_FILE (file1)' failed
05:57:31 <FliPPeh_> Gtk:ERROR:gtkfilesystemmodel.c:330:node_set_visible: assertion failed: (row < model->files->len)
05:57:56 <FliPPeh_> The next run it works just great
05:59:09 <Saizan> concurrency maybe?
06:00:06 <FliPPeh_> Saizan: No concurrency going on
06:00:27 <FliPPeh_> However, I included a
06:00:28 <FliPPeh_> timeoutAddFull (yield >> return True) priorityDefaultIdle 100
06:00:41 <FliPPeh_> Just in case I needed it - could that be it?
06:00:55 <FliPPeh_> But I make no explicit use of concurrency
06:01:31 <ManateeLazyCat> FliPPeh_: Which gtk2hs version?
06:01:49 <FliPPeh_> 0.10.1-6
06:02:02 <FliPPeh_> The newest one my package manager offered me
06:02:31 <ManateeLazyCat> FliPPeh_: From you error, you give wrong argument to function "fileEqual"
06:02:48 <FliPPeh_> ManateeLazyCat: I don't use that function at all
06:03:17 <ManateeLazyCat> FliPPeh_: Maybe paste your code to gtk2hs-list, then we can help you.
06:03:44 <FliPPeh_> ManateeLazyCat: It's full of localized comments and about 3 files, I don't know which part is failing :/
06:04:03 <ManateeLazyCat> FliPPeh_: Binary search.
06:04:16 <Younder> FileEqual is flawed
06:05:08 <ManateeLazyCat> FliPPeh_: use putStrLn in someplace perhaps have bug, then tag deeply for test.
06:05:32 <ManateeLazyCat> Younder: Detail?
06:06:23 <ManateeLazyCat> FliPPeh_: Or running your program in gdb.
06:07:02 <blackh> Anyone here know why in 6.12.2, Data.ByteString.hGet doesn't return until the socket has actually closed? In 6.10.4 it would return as soon as it got some data.
06:07:59 <FliPPeh_> ManateeLazyCat: The GTK Interface won't even show up inside GDB
06:08:18 <blackh> No it doesn't - 6.10.4 is the same - it's definitely behaving differently but I need to pin it down.
06:08:22 <ManateeLazyCat> FliPPeh_: ? I always use gdb.
06:08:58 <ManateeLazyCat> FliPPeh_: Maybe you bug is at place that before widgetShowAll?
06:09:08 <FliPPeh_> Hmm...
06:09:39 <ManateeLazyCat> FliPPeh_: If you gtk2hs program is okay, it should be show in gdb.
06:09:54 <FliPPeh_> ManateeLazyCat: Figured it out, I just had a maximized window that was set to be always on top
06:10:12 <FliPPeh_> Fogort about that :)
06:10:19 <ManateeLazyCat> FliPPeh_: Fix now?
06:10:32 <FliPPeh_> Yes, I'll try tickling it to get the error to show up again
06:10:50 <dino-> ! community.haskell.org is down
06:11:16 <blackh> "If there is any data to read, then hGet will not block, instead  it will return whatever data is available without blocking.  It  only blocks if there is no data available to read."
06:11:18 <ManateeLazyCat> FliPPeh_: Find where the problem, if you think it's a bug of gtk2hs, rebuild minimum code to gtk2hs, then we can test and fix it.
06:11:23 <blackh> ^ This is lying in 6.10.4 and 6.12.2 - gah
06:11:30 <ManateeLazyCat> s/gtk2hs/gtk2hs-list
06:14:07 <FliPPeh_> Meh, can't reproduce.
06:30:24 <danderson> is there a package that specifically defines mutable ByteStrings?
06:30:39 <danderson> I'm looking for something I can use in ST, for crypto building blocks
06:31:04 <danderson> the idea being to combine lots of ST ops that mutate one of these mutable bytestrings, and freeze it only at the end of the many combined ST ops
06:31:27 <danderson> instead of copying for every single permutation, shuffle or twiddle
06:39:04 <dmwit> danderson: There's ST(U)Array Word8
06:39:04 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
06:39:11 <dmwit> ?messages
06:39:11 <lambdabot> dschoepe asked 22h 40m 4s ago: Do you have any objections against making a new release of xmonad-extras? The current one no longer compiles against the current libmpd.
06:39:32 <danderson> dmwit: cheers. I also found the vector library, which as I recall is the new hotness for array-ish operations, with stream fusion and all that
06:39:35 <dmwit> ?tell dschoepe to make a release any time
06:39:35 <lambdabot> Consider it noted.
06:39:54 <danderson> but I can't for the life of me find in the API how to freeze a mutable vector into an immutable vector
06:40:07 <danderson> I can only find the reverse operation, to copy an immutable vector into a mutable one
06:40:12 <dschoepe> dmwit: okay, I'll try to get EvalServer to work properly before the release though
06:40:12 <lambdabot> dschoepe: You have 1 new message. '/msg lambdabot @messages' to read it.
06:40:35 <zygoloid> danderson: you could make a 'newtype STByteString s = STBS ByteString; runSTByteString : (forall s. STByteString s) -> ByteString' easily enough i think
06:41:08 <zygoloid> danderson: use Data.ByteString.Unsafe's usafeUseAsCStringLen with unsafeIOToST to create the primitive operations
06:41:31 <danderson> hmm, sounds about right
06:41:39 <zygoloid> danderson: if you want to use ST(U)Array, then you want runSTArray
06:41:44 <danderson> I also just found vector's freezing operation, which is somewhat similar
06:42:05 <danderson> I'd rather have a mutable version of ByteString specifically, or something that can be O(1) converted to an immutable bytestring
06:42:09 <zygoloid> that should be :: (forall s. ST s (STByteString s)) i guess
06:42:24 <danderson> since the inputs and outputs of this module need to be ByteStrings to connect with the stuff around it
06:42:41 <zygoloid> well, unsafeUseAsCString exposes ByteString's implementation, so that's probably not a bad thing to use
06:43:43 <danderson> right, that works nicely. I'm looking into whether the vector library has a way of efficiently going to/from a bytestring
06:44:16 <quicksilver> zygoloid: how unsafe is it, though. Could be that you can't combine it with unsafeIOToST because GC can move the memory?
06:44:17 <danderson> (I care about vectors because it seems to me that stream fusion could make the combination of crypto primitives very efficient for almost free, if I can make the types jive)
06:44:42 <quicksilver> zygoloid: I think I'm asking whether bytestring storage is pinned.
06:45:09 <zygoloid> quicksilver: the memory's got to be pinned during unsafeUseAsCStringLen, right? otherwise that operation is /really/ unsafe!
06:45:34 <danderson> I vaguely recall that the implementation can decide to pin the underlying array for certain stuff
06:45:43 <danderson> presumably unsafeUseAsCStringLen would be one of them :)
06:45:49 <zygoloid> though to be honest i don't know anywhere near enough about this sort of stuff to be sure :(
06:46:05 <quicksilver> clearly you need to summon the mighty dcoutts_
06:46:22 <quicksilver> if I fetch the lamda-chicken, you get to work on the drawing the pentagram
06:46:28 <danderson> that would be good, yeah
06:46:47 <sioraiocht> Is there any good Criterion tutorial? or just the the examples/haddock documentation?
06:47:25 <EvanR-work> @hoogle on
06:47:25 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:47:25 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
06:47:25 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
06:48:15 * benmachine wonders why that isn't a => [a] -> a etc.
06:48:19 <MarcWeber> join #nixos
06:48:21 <benmachine> Eq a
06:48:30 <zygoloid> @hoogle runSTArray
06:48:30 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
06:48:36 <zygoloid> ^^ that type's wrong, isn't it?
06:48:44 <benmachine> how
06:49:07 <zygoloid> should be :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
06:49:19 <zygoloid> otherwise you can make an array of STRef s's
06:49:42 <quicksilver> yes, hoogle failed to parse the rank-2 type
06:49:45 <benmachine> according to ghci you're right
06:50:06 <FliPPeh_>  _gtk_file_chooser_embed_initial_focus: assertion `GTK_IS_FILE_CHOOSER_EMBED (chooser_embed)' failed
06:50:08 <fasta> Haskell is great for parsing, except nobody does it ;)
06:50:10 <dcoutts_> quicksilver, danderson: you summoned me. What evil are you practising? unsafeUseAsCStringLen, mm clearly evil.
06:50:11 <FliPPeh_> My program is breaking EVERYWHERE
06:50:33 <quicksilver> dcoutts_: danderson is after a mutable memory block with O(1) conversion to bytestring
06:50:33 <zygoloid> dcoutts_: STByteString!
06:51:16 <danderson> dcoutts_: I'm thinking about how to write efficient crypto primitives (permute according to incantation X, shuffle bytes, etc.), such that I can combine them and have them munge some mutable array, and freeze once all the ops are done.
06:51:32 <dcoutts_> zygoloid: yes, ByteString should use ST, not IO.
06:52:06 <danderson> ideally, I want it to work with a ByteString input, because it's going to end up on the network. I was also looking at the vector library, but I don't see any way offhand of getting an MVector from a ByteString without doing naughty things.
06:52:17 <zygoloid> dcoutts_: quicksilver raises the question of whether unsafeIOToST . unsafeUseAsCStringLen . (stToIO .) would be safe
06:52:23 <dcoutts_> danderson: you could do it with a copy of course
06:52:49 <dcoutts_> danderson: keep in mind that ByteStrings do not guarantee you any alignment, since anyone can drop 1 on them.
06:52:59 <zygoloid> (obviously you'd also need to wrap it up so that no-one can see that you're changing it)
06:53:43 * benmachine is not getting a response out of code.haskell.org
06:54:09 * zygoloid typoes downforeveryoneorjustmen.com
06:54:34 <benmachine> hah
06:54:46 <benmachine> but yeah I already checked
06:54:50 <benmachine> it said not just me
06:54:59 <silver> @src shiftR
06:54:59 <lambdabot> Source not found. I am sorry.
06:55:12 <zygoloid> benmachine: it's not just men!
06:55:21 <EvanR-work> "return x >> n;"
06:55:52 <benmachine> return x >> n = return x >>= const n = const n x = n
06:56:03 <danderson> dcoutts_: no alignment is fine, but I suppose the simplest would be to copy the ByteString into an MVector, muck about inside it, and then splat that back out to a ByteString. There must be a clever way of doing that last bit.
06:56:11 <fax> "cross-stage persistence" -- what the hell is this
06:56:23 <danderson> (clever as opposed to "freeze to a Vector, then copy to a ByteString")
06:56:27 <zygoloid> @pl shiftR x n = return x >> n
06:56:27 <lambdabot> shiftR = (>>) . return
06:56:30 <zygoloid> :(
06:56:46 <dcoutts_> danderson: yes, you could construct a ForeignPtr from the Vector's internal ByteArr#
06:57:39 <benmachine> zygoloid: well, it only works if the thing abides by the monad laws
06:57:43 <dcoutts_> zygoloid: there's not really anything you can do with a CStringLen in ST, so in that sense it's completely safe (and useless!)
06:57:45 <danderson> dcoutts_: that sounds delightfully dangerous, I'll see what I can do :)
06:58:20 <dcoutts_> danderson: it's safe if you comply with the rules for unsafeFreeze
06:58:34 <zygoloid> dcoutts_: heh, fair point. more accurately then, would poking at the bytes in such a manner be safe (without the stToIO)
06:58:43 <rl> danderson: Data.Vector.Storable.[Mutable.]unsafeToForeignPtr
06:58:55 <dcoutts_> zygoloid: no, you cannot modify the ByteString, that's impure
06:59:13 <gwern> impure! impure! impure!
06:59:14 <zygoloid> dcoutts_: as i said before, it would be wrapped up so you can't see it's changing from outside ST
06:59:16 <EvanR-work> @define impure
06:59:47 <dcoutts_> zygoloid: no it's not safe because other bits of code may have access to the ByteString
07:00:04 <dcoutts_> zygoloid: you'd need to guarantee that you've got the only copy
07:00:06 <zygoloid> dcoutts_: it would be wrapped in a non-exported constructor
07:00:27 <dcoutts_> zygoloid: that's orthogonal
07:00:34 <zygoloid> dcoutts_: essentially the idea was to provide an interface akin to that of STArray
07:00:54 <danderson> rl: ah, perfect, cheers.
07:01:18 <zygoloid> (so that you can only create an STByteString s within an ST s computation)
07:01:22 <dcoutts_> zygoloid: so then you don't need unsafeUseAsCStringLen at all
07:01:53 <dcoutts_> zygoloid: since if you're using an STArray interface then you're working on a mutable array, you can freeze it at the end into an immutable ByteString
07:02:22 <dcoutts_> you never need to play tricks with mutating a (morally) immutable object
07:03:37 <zygoloid> dcoutts_: well, the idea was to use ByteString as the implementation of STByteString; newtype STByteString s = STBS ByteString
07:03:49 <zygoloid> (rather than reimplement the low-level fiddling)
07:03:56 <dcoutts_> rl: does unsafeToForeignPtr just make a ForeignPtr directly from the [Mutable]ByteArray# ? what about pinning?
07:04:15 <Jonno_FTW> @src scanl
07:04:16 <lambdabot> scanl f q ls = q : case ls of
07:04:16 <lambdabot>     []   -> []
07:04:16 <lambdabot>     x:xs -> scanl f (f q x) xs
07:04:18 <Jonno_FTW> @src scanl
07:04:19 <lambdabot> scanl f q ls = q : case ls of
07:04:19 <lambdabot>     []   -> []
07:04:19 <lambdabot>     x:xs -> scanl f (f q x) xs
07:04:25 <dcoutts_> zygoloid: but that does not help, since ByteString does not provide any mutation operations, so you'd still need to do  low-level fiddling
07:04:29 <rl> dcoutts_: D.V.Storable memory is always pinned
07:04:46 <dcoutts_> rl: oh, I see
07:05:16 <rl> dcoutts_: D.V.Unboxed uses unpinned ByteArrays at the moment but I'm not sure it's a good idea anyway
07:05:52 <zygoloid> dcoutts_: no, but it does provide a load of other operations which could be helpful; take, drop, (++), etc.
07:05:57 <dcoutts_> rl: I don't see why it would not be a good idea. GHC already pins them over a certain size. For small vectors you want them movable.
07:06:06 * hackagebot libexpect 0.3.0 - Library for interacting with console applications via pseudoterminals.  http://hackage.haskell.org/package/libexpect-0.3.0 (StephenRoantree)
07:06:40 <dcoutts_> zygoloid: sounds like you just want to use Vector
07:07:07 <rl> dcoutts_: because caching the starting address of the vector instead of an offset into the ByteArray is sometimes a significant performance win with the current backend
07:07:33 <dcoutts_> rl: because it's crap at doing the indexing?
07:07:40 <rl> yep
07:07:43 <dcoutts_> ho hum
07:08:11 <rl> dcoutts_: haven't tried it with the llvm backend yet though
07:08:19 <zygoloid> dcoutts_: i don't actually want to do this. i just want to know if it's safe (specifically, quicksilver was concerned that the memory might get moved by the GC during the unsafeUseAsCStringLen)
07:08:48 <dcoutts_> zygoloid: no, what you get back from unsafeUseAsCStringLen is a Ptr, so it cannot move.
07:08:56 <dcoutts_> zygoloid: it's evil though, you should not do it
07:09:13 <Gertm> is RWH still a good resource for learning?
07:10:34 <McManiaC> how can I get a^^(2/3) ?
07:10:42 <McManiaC> > 5^^(2/3)
07:10:42 <lambdabot>   Ambiguous type variable `t' in the constraints:
07:10:42 <lambdabot>    `GHC.Real.Fractional t'
07:10:43 <lambdabot> ...
07:11:39 <quicksilver> > 5 ** (2/3)
07:11:40 <lambdabot>   2.924017738212866
07:11:49 <quicksilver> McManiaC: that's not what ^^ does, but maybe you want **
07:12:01 <McManiaC> hm
07:12:04 <McManiaC> what is ^^ ?
07:12:11 <quicksilver> ^^ is integer power
07:12:28 <benmachine> :t (^)
07:12:29 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
07:12:29 <quicksilver> therefore it can used safely with rationals
07:12:30 <benmachine> :t (^^)
07:12:31 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
07:12:33 <benmachine> :t (**)
07:12:34 <lambdabot> forall a. (Floating a) => a -> a -> a
07:12:41 <benmachine> all capable of different things
07:12:50 <quicksilver> > 6 ^^ (-5) :: Rational
07:12:51 <lambdabot>   1 % 7776
07:13:04 <McManiaC> hmkay
07:18:17 <edgar_> hi all
07:19:47 <edgar_> Is there at the moment anyone here?
07:20:07 <Axman6> there's hundreds of people here
07:20:11 <quicksilver> around 600, in fact
07:20:36 <Philonous> Most of them afk or not paying attention to the channel, though
07:21:05 <edgar_> Yeah that was what I meant :)
07:21:17 <Axman6> if you have a question just ask it
07:21:30 <Axman6> #1 rule of IRC: don't ask to ask, just ask
07:21:50 <Entroacceptor> rule #2, be patient
07:23:22 <edgar_> Lol, it was more like do I have to come back later question, but I understand your point. I had a question about FFI. I find many examples to import c functions to haskell, but there are little examples the otherway around. Does anyone knows a good tutorial or article?
07:23:55 <quicksilver> edgar_: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
07:25:32 <edgar_> Tnx, I haven't looked for the right thing. I was looking into shared libraries, but this is a much simpler approach.
07:26:21 <benmachine> rule #3, no shirts, no shoes
07:28:33 <FliPPeh_> I'm not sure if I like rule #3.
07:28:55 <edgar_> It is 30 degrees here, so the shirt and no shoes thing is no problem
07:29:18 <Axman6> only 30?
07:29:20 <FliPPeh_> And I was happy when it stopped snowing, 2 months ago.
07:29:27 <EvanR-work> 30C!
07:30:02 <edgar_> yeah, i am in holland and live at the highest appartment in a flat.
07:31:03 <edgar_> The roof is black, so it absorbs all the sunlight
07:34:09 <AlDoug> My professor briefly touched on Haskell last week, then gave us a problem set to do. In one of his examples he used the following code: http://pastie.org/939177
07:34:09 <ManateeLazyCat> What's wong with code.haskell.org ? Down again?
07:34:23 <AlDoug> Can anyone explain what the "\" means?
07:34:52 <Entroacceptor> AlDoug: it's called 'Lambda' ;)
07:34:58 <tromp_> it's the ascii equivlanet of lambdas
07:35:05 <Philonous> AlDoug: \x -> f x is the function that takes an argument, calles it x and returns f x
07:35:22 <EvanR-work> quick way to do an IO action on something if its not nothing
07:35:23 <Axman6> AlDoug: do you know lambda calculus?
07:35:52 <EvanR-work> maybe (return ()) action x?
07:35:58 <ManateeLazyCat> AlDoug: Do you use lisp language before?
07:36:13 <ManateeLazyCat> AlDoug: It's same thing as `lambda` in lisp.
07:36:22 <AlDoug> The function makes an infinite list of all integers form the given one (or 0 if none is given)
07:36:44 <Axman6> AlDoug: basically its how you write annonymous functions in haskell: map (\x -> x*x + 10) [1,2,3] for example
07:36:49 <tromp_> an elaborate way to write [0..]
07:36:55 <Axman6> > map (\x -> x*x + 10) [1,2,3]
07:36:56 <lambdabot>   [11,14,19]
07:38:46 <AlDoug> hmm
07:39:04 <ManateeLazyCat> Can you access code.haskell.org?
07:40:28 <AlDoug> Axman6: unfortunately, I never studied lambda calc
07:40:30 <FliPPeh_> ManateeLazyCat: About the Gtk2Hs issue.. If a function inside the IO monad, that has been called from a GUI-event, crashes, would that affect the GTK system?
07:40:39 <Axman6> AlDoug: no need really
07:40:45 <Axman6> it's a very simple concept
07:40:48 <FliPPeh_> Well, not crash
07:41:01 <FliPPeh_> But throw an exception.. that has been caught tho
07:41:13 <quicksilver> AlDoug: it's a way to have a function without giving it a name.
07:41:16 <FliPPeh_> I'm calling "moveFile" quite a lot
07:41:27 <Axman6> AlDoug: if you have f x = x + g x, you could rewrite that with a lambda expression as f = \x -> x + g x
07:41:31 <quicksilver> AlDoug: addOne x = x + 1 is the function which adds one to its parameter
07:41:49 <quicksilver> AlDoug: if you don't want to give it a name (addOne) you can just use (\x -> x + 1) directly in an expression.
07:42:40 <edgar_> that works, tnx again
07:42:57 <Philonous> Maybe one should mention that in haskell "f x" means "apply f to x". It would be "f(x)" in other languages.
07:43:38 <fax> I don't think it means apply f to x
07:44:49 <Philonous> fax: Yeah, it denotes the result of applying f to x rather than the action of applaying it.
07:45:14 <fax> yeah
07:45:41 <Philonous> Same difference, really ;)
07:45:59 <AlDoug> I think I get it now.
07:46:27 <fax> not erally
07:46:55 <aep> i can't compile this http://www.cse.unsw.edu.au/~dons/irc/bot.html.  i get this error http://codepad.org/8dM3AZi3 . but i cant find b :(
07:46:59 <AlDoug> One thing that thew me is that I have to write `mod` instead of mod to get a modulus
07:47:17 <EvanR-work> > mod 9 4
07:47:18 <lambdabot>   1
07:47:20 <quicksilver> only if you want to write it infix - between the operands.
07:47:25 <quicksilver> as EvanR-work just demonstrated :)
07:47:40 <EvanR-work> > divMod 9 4
07:47:41 <lambdabot>   (2,1)
07:47:43 <Axman6> `foo` makes foo an infix function.  x `mod` y can be written as mod x y (which is the default way to write it)
07:47:44 <aep> the line with the error is    "loop st    = catch (runReaderT run st) (const $ return ())"
07:47:52 <aep> i dont even know what that means
07:47:56 <quicksilver> aep: the exception library has changed (twice?) since that code was written
07:47:57 <EvanR-work> > quotRem 9 4
07:47:58 <lambdabot>   (2,1)
07:48:07 <aep> quicksilver: nice.
07:48:12 <FliPPeh_> > let (<%>) = mod in 10 <%> 5
07:48:13 <lambdabot>   0
07:48:17 <quicksilver> aep: try changing Control.Exception to Control.OldException at the top
07:48:17 <FliPPeh_> > let (<%>) = mod in 10 <%> 6
07:48:18 <lambdabot>   4
07:48:47 <EvanR-work> nots a gnarly operator to type ;)
07:48:51 <EvanR-work> thats^
07:48:56 <aep> quicksilver: that works indeed, thanks
07:49:04 <FliPPeh_> > let (%) = mod in 10 % 6
07:49:05 <lambdabot>   4
07:49:12 <EvanR-work> yay
07:49:12 <FliPPeh_> If you don't need complex numbers :)
07:49:17 <EvanR-work> > 10 % 6
07:49:18 <lambdabot>   5 % 3
07:49:23 <quicksilver> FliPPeh_: rational numbers?
07:49:30 <quicksilver> complex is :+
07:49:38 <FliPPeh_> Same thing for me!
07:49:42 <FliPPeh_> I'm a math newb!
07:49:45 <quicksilver> > (2 :+ 5, 2%5)
07:49:46 <lambdabot>   (2.0 :+ 5.0,2 % 5)
07:50:46 <EvanR-work> > exp mkPolar(pi,pi/2) + 1
07:50:47 <lambdabot>   No instance for (GHC.Num.Num
07:50:47 <lambdabot>                     ((a, a1) -> Data.Complex.C...
07:51:03 <EvanR-work> > exp mkPolar(pi pi/2) + 1
07:51:04 <lambdabot>   No instance for (GHC.Num.Num (a -> Data.Complex.Complex a))
07:51:04 <lambdabot>    arising from...
07:51:09 <EvanR-work> > exp (mkPolar(pi pi/2)) + 1
07:51:10 <lambdabot>   No instance for (GHC.Float.Floating
07:51:10 <lambdabot>                     (a1 -> Data.Complex...
07:51:27 <quicksilver> :t mkPolar
07:51:28 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
07:51:31 <Axman6> (pi pi)/2?
07:51:37 <quicksilver> > exp (mkPolar pi (pi/2)) + 1
07:51:38 <lambdabot>   (-2.220446049250313e-16) :+ 1.2246467991473535e-16
07:51:47 * quicksilver pats EvanR-work 
07:52:04 <EvanR-work> :(
07:52:06 <Axman6> > exp (0 :+ pi)
07:52:07 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
07:52:12 <Axman6> > exp (0 :+ pi) :: CReal
07:52:13 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
07:52:13 <lambdabot>         against infe...
07:52:23 <Axman6> > exp (0 :+ pi) :: Complex CReal
07:52:24 <lambdabot>   (-1.0) :+ 0.0
07:52:54 <quicksilver> > exp (mkPolar pi (pi/2)) + 1 :: Complex CReal
07:52:55 <lambdabot>   0.0 :+ 0.0
07:53:39 <quicksilver> although I'm not sure pi :: CReal is arbitrary precision?
07:54:15 <EvanR-work> arbitrary limits?
07:54:19 <gio123> is LINQ functional language?
07:54:43 <Axman6> i've hear it said it is
07:54:50 <Axman6> it's even a monad i think
07:55:14 <gio123> aha
07:55:22 <gio123> but it is based on OOP?
07:55:53 <EvanR-work> > runLINQ (return 5) BillGates
07:55:54 <lambdabot>   Not in scope: `runLINQ'Not in scope: data constructor `BillGates'
07:56:02 * Axman6 doesn't know much about LINQ other than what he just outlined :P
07:56:05 <quicksilver> I take it back. It looks like pi :: CReal is indeed arbitrary precision.
07:56:24 <quicksilver> SQL is declarative, so LINQ is.
07:56:33 <Philonous> gio123: object oriented and functional are not mutually exclusive
07:56:40 <quicksilver> It's a bit of a stretch to call SQL functional since it doesn't have a notion of first class function
07:56:50 <quicksilver> but it shares lots of properties with functional languages
07:57:02 <EvanR-work> is SQL turing complete?
07:57:06 <quicksilver> no
07:57:16 <EvanR-work> is there a critical feature if added would make it so?
07:57:16 <quicksilver> SQL3, or whatever they're calling it, is.
07:57:19 <Axman6> > showCReal 100 pi
07:57:19 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
07:57:30 <quicksilver> it doesn't have anything equivalent to general recursion.
07:57:38 <Axman6> i thought SQL was turing complete?
07:57:52 <quicksilver> SQL can't calculate transitive closure, for example.
07:57:55 <EvanR-work> is there a esoteric feature to add which would make it so? :)
07:58:06 <quicksilver> there is a recursion construct in SQL3
07:58:15 * Axman6 -> bed
07:58:20 <EvanR-work> like a Y combinator or something
07:58:33 <quicksilver> > take 50 . drop 500 $ showCReal pi
07:58:34 <lambdabot>   Couldn't match expected type `[a]'
07:58:34 <lambdabot>         against inferred type `Data.Numb...
07:58:43 <quicksilver> > take 50 . drop 500 $ showCReal 600 pi
07:58:44 <lambdabot>   "12983367336244065664308602139494639522473719070217"
08:00:15 <Axman6> > let f x = take 50 . drop x $ showCReal (x+100) pi in f 1000
08:00:16 <lambdabot>   "89380952572010654858632788659361533818279682303019"
08:00:19 <Axman6> > let f x = take 50 . drop x $ showCReal (x+100) pi in f 2000
08:00:21 <lambdabot>   "09946576407895126946839835259570982582262052248940"
08:01:48 <gio123> Philonous:Scala (pronounced /'sk??l?/ SKAH-l?  or /'ske?l?/ SKAY-l?) is a multi-paradigm  programming language designed to integrate features of object-oriented programming and functional programming.[1
08:02:04 <quicksilver> whois Younder
08:02:15 <Philonous> gio123: I was thinking of Ocaml. Object oriented ML
08:03:02 <gio123> I was trying to undestand what approaches are considered for xml transformations
08:03:08 <fryguybob> pi :: CReal apears to be using Machin's formula: pi = 16 * atan (fromRational (1 % 5)) - 4 * atan (fromRational (1 % 239))
08:03:21 <gio123> seems, most of languages for xml trasformation is functional style
08:03:34 <quicksilver> fryguybob: yes, I checked the source too :)
08:03:43 <quicksilver> fryguybob: ...and then I checked the source for atan
08:03:53 <quicksilver> fryguybob: and concluded it does indeed look like arbitrary precision
08:07:05 <EvanR-work> how do i 'reexport' something?
08:07:40 <quicksilver> you just export it in the normal way
08:07:49 <quicksilver> doesn't matter if you defined it locally or imported it from a module
08:08:01 <quicksilver> but there is a special syntax to re-export an entire module.
08:08:12 <EvanR-work> i dont have an export list
08:08:27 <EvanR-work> i want it to act like that but reexport a single thing from a module
08:08:40 <quicksilver> as far as I know you have to write an export list.
08:08:46 <EvanR-work> >_<
08:09:00 <EvanR-work> is there an export for "everything here"
08:09:35 <EvanR-work> module A (module A, B) where ;)
08:09:59 <Maxdamantus> Ah. I think I thought of something where tail recursion doesn't appear to work.. foo a b = foo a bar + foo bar b where bar = ...
08:10:02 <Maxdamantus> or something.
08:10:28 <quicksilver> Maxdamantus: I still don't know what you mean by "work"
08:10:36 <quicksilver> Maxdamantus: some recursion is tail recursion, some is not
08:10:53 <quicksilver> this is a property of the program syntax, completely independent of the compilation techniaues.
08:11:05 <quicksilver> f x = f (x+1) -- This is a tail call
08:11:18 <quicksilver> f x = 2 * f (x+1) -- this is not
08:11:25 <mun> does anyone know if there's a tool for making logical manipulations to formulae? e.g., given ALL x, y. f(x) = g(y) <=> ALL x. f(x) = g(x) & X, find possible formulae for X?
08:11:33 <EvanR-work> so a tail call is one where the top level is itself?
08:11:38 <quicksilver> yes.
08:11:38 <Maxdamantus> Why isn't the latter? O_o
08:11:51 <quicksilver> Maxdamantus: because the top call is (*), not f
08:12:04 <Cale> It's kind of funny that we still call it 'tail' recursion, when under lazy evaluation, it would probably better be named "head recursion" or something :)
08:12:23 <EnglishGent> Hello :)
08:12:29 <Maxdamantus> It's called tail recursion because of what it looks like in other languages.
08:12:34 <dolio> f x k = f (x+1) (k . (*2)) -- this is a tail call
08:12:47 <Maxdamantus> Where it will usually optimise when it calls itself at the end/tail of the function.
08:13:04 <Cale> Maxdamantus: Right, but under lazy evaluation, that's the *first* thing which happens
08:13:17 <Cale> (it calls itself with different parameters immediately)
08:13:34 <EnglishGent> rather specialist question (I'm trying to use a function from one of the crypto libraries)
08:13:48 <danderson> EnglishGent: which crypto library?
08:13:50 <Maxdamantus> Why does that depend on lazy?
08:13:53 <EnglishGent> does anyone know how to convert a ByteString into a list of Octet?
08:14:01 <quicksilver> EnglishGent: yes, unpack
08:14:03 <danderson> (unrelated question, I'm just wondering which you're using)
08:14:04 <Cale> Maxdamantus: Well, lazy evaluation is outermost-first
08:14:10 <quicksilver> (assuming Octet == Word8, which seems likely)
08:14:14 <EnglishGent> hi quicksilver - and thanks :)
08:14:27 <Cale> Maxdamantus: Whereas strict evaluation is innermost-first
08:14:29 <EvanR-work> Oct == 8
08:14:31 <EvanR-work> ;)
08:14:39 <quicksilver> type Octet = Word8
08:14:40 <quicksilver> yes.
08:14:43 <danderson> also note that doing crypto over lists, rather than directly on an array, is likely going to be painfully slow
08:14:53 <Maxdamantus> int foo(int x){return (x < 10? foo(x + 1) : 0) + x;}
08:15:16 <danderson> (that's why I'm messing with ByteString internals and the vector package, I want a crypto library for ByteStrings)
08:15:27 <Cale> @src foldl
08:15:27 <lambdabot> foldl f z []     = z
08:15:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:15:39 <EnglishGent> I'm doing it on files danderson - and some of them are big enough I dont want to load them into memory  all at once
08:15:56 <Cale> So, in the recursive case here, foldl just calls itself immediately. f doesn't have a chance to evaluate until the entire list is exhausted.
08:16:12 <Cale> (which is why foldl doesn't work with infinite lists)
08:16:25 <Cale> @src foldr
08:16:25 <lambdabot> foldr f z []     = z
08:16:25 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:16:40 <EvanR-work> Cale: on the other hand, scanl ;)
08:16:49 <Cale> foldr on the other hand, passes control to f first, allowing it to potentially do something with its first parameter
08:16:50 * Maxdamantus doesn't see how that's assosciated with laziness, but with functional..
08:16:58 <EnglishGent> how is everyone btw?due to work I havent been able to come by for a while :|
08:17:05 <Botje> hallo EnglishGent!
08:17:06 <Cale> Maxdamantus: Laziness is the evaluation order
08:17:16 * EnglishGent is trying to persuade people at work we should develop something in Haskell :)
08:17:22 <EnglishGent> hi Botje
08:17:24 <EnglishGent> :)
08:17:32 <EvanR-work> EnglishGent: good luck with that!
08:17:34 <EvanR-work> ;)
08:17:36 <Cale> (together with an optimisation to prevent the argument to a function from being evaluated more than once)
08:18:00 <danderson> EnglishGent: you'd still be able to do it on a block level with bytestrings. Lazy IO is nice for hacking up something quickly, but working up CPU heavy stuff like crypto over a list seems fairly inefficient
08:18:08 <Cale> Maxdamantus: I'm talking about the order in which expressions are being evaluated here, so the lazy/strict distinction is very important.
08:18:26 <danderson> that said, eh. Not all programs need to be super fast, and I do see the attraction of using some kind of stream cipher on a lazy list :)
08:18:34 <EvanR-work> > fst (undefined, 0)
08:18:35 <lambdabot>   *Exception: Prelude.undefined
08:18:39 <EvanR-work> > snd (undefined, 0)
08:18:40 <lambdabot>   0
08:19:04 <Maxdamantus> Hmm..
08:19:05 <FliPPeh_> How stable is Gtk2hs? I'd like to find out whether I fail, or IT fails.
08:19:23 <Cale> Maxdamantus: Perhaps an example will help:
08:19:27 <EvanR-work> > error "BOMB"
08:19:27 <Cale> foldl (+) 0 [1,2,3]
08:19:28 <lambdabot>   *Exception: BOMB
08:19:29 <Maxdamantus> That foldr looks like it could be done in C using FP though.
08:19:35 <Cale> -> foldl (+) (0 + 1) [2,3]
08:19:41 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
08:19:48 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
08:19:55 <Cale> -> ((0 + 1) + 2) + 3
08:20:06 <Maxdamantus> Yes. Isn't that the nature of functional programming though?
08:20:18 <Cale> The order of evaluation there is lazy evaluation.
08:20:25 <Cale> Under strict evaluation it would look like this:
08:20:25 <fasta> danderson, the cost of copying some bits is too high? To me it seems that effort can better be spend at a partial evaluator for GHC.
08:20:28 <Cale> foldl (+) 0 [1,2,3]
08:20:29 <dcoutts> FliPPeh_: it's stable enough for me to give a customer a warranty on a system using it.
08:20:40 <FliPPeh_> Meh...
08:20:49 <Cale> -> foldl (+) (0 + 1) [2,3]
08:20:52 <Cale> -> foldl (+) 1 [2,3]
08:20:57 <Cale> -> foldl (+) (1 + 2) [3]
08:21:01 <Cale> -> foldl (+) 3 [3]
08:21:07 <fasta> dcoutts_, what kind of warranty?
08:21:07 <Cale> -> foldl (+) (3 + 3) []
08:21:11 <Cale> -> foldl (+) 6 []
08:21:12 <Maxdamantus> Oh, I see what you mean.
08:21:14 <FliPPeh_> dcoutts: I had some strange crashes that should not be able to arise from MY code.
08:21:14 <Cale> -> 6
08:21:19 <CalJohn> you know, it would be really nice to have language support for things like Data.Vector, so [1,2,3] would could be inferred as a Vector instead of a list
08:21:24 <danderson> fasta: depending on the implementation of the crypto functions, there may be quite a few copies and seeking around all over the place
08:21:35 <CalJohn> is there such a thing as OverloadedLists ?
08:21:49 <fasta> danderson, and what is wrong with the existing C implementations?
08:21:55 <dcoutts> fasta: usual kind, ie will fix any flaws discovered
08:22:09 <fasta> danderson, unless you are building a military device, of course.
08:22:16 <danderson> fasta: most of them are located in OpenSSL, which has a rather bad track record of maintainable code and bugs
08:22:35 <dcoutts> FliPPeh_: I suggest you ask about it on the gtk2hs list, boil it down to a repeatable test case
08:22:54 <fasta> danderson, there is also a lot of domain specific knowledge in those libraries.
08:22:56 <danderson> fasta: but, yes. Pragmatically, you'd use one of the FFI bindings out to openssl. I'm mostly just playing around.
08:23:16 <FliPPeh_> dcoutts: I have no idea at all where those errors could possibly come from, so I can't create a test case
08:23:20 <fasta> danderson, RSA is easy for particular classes of inputs for example.
08:23:21 <Cale> Maxdamantus: So, because foldl does nothing but to call itself until it reaches the end of the list, it will never have a chance of doing anything useful when applied to an infinite list
08:23:37 <FliPPeh_> dcoutts: They happen seemlingly completly random
08:23:51 <fasta> danderson, so, it is not easy to make something which is perfectly secure.
08:23:51 <FliPPeh_> Glib-GIO-CRITICAL and Gtk:ERROR...
08:23:55 <danderson> fasta: I know. As I said, mostly just playing around. Wondering what an efficient implementation in just Haskell would look like.
08:24:06 <Cale> Maxdamantus: On the other hand, foldr, in the recursive case, immediately calls f, and the foldr will only continue if and when f needs to observe its second parameter
08:24:07 <FliPPeh_> I've been able to stress test my application for an hour without any crash
08:24:12 <FliPPeh_> And then it suddenly happens
08:24:16 <fasta> danderson, IMHO, it would look like it copies a lot, but in fact doesn't because the compiler works.
08:24:20 <Cale> Maxdamantus: So things like this will work:
08:24:26 <danderson> yes, I know. Even openssl fails at being perfectly secure in various cases :)
08:24:29 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..]
08:24:30 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
08:24:31 <dcoutts> FliPPeh_: well perhaps just post the whole thing
08:24:39 <Cale> (that's just map in disguise)
08:24:39 <EnglishGent> danderson: - some of the files are gigabytes in size - I found using LazyByteStream was much quicker for most of the stuff I want to do
08:24:58 <EnglishGent> if there's a way to buffer it & speed up more I'm quite happy to though :)
08:25:23 <danderson> fasta: perhaps. I'm more of the "try it and look at the core" sort of guy
08:25:51 <EnglishGent> oh - a completely unrelated question.. but whilst I'm here - is there a function [a] -> a that *isnt* expressible in terms of fold? I'm struggling to think of one! :)
08:26:29 <FliPPeh_> EnglishGent: A function that writes blog entries!
08:26:50 <Cale> EnglishGent: Is that level of polymorphism important to you?
08:27:09 <EnglishGent> Cale:  - no
08:27:41 <EnglishGent> it's just personal interest in theoretical underpinnings ... fold seems so general, I'm wondering what it *cant* do :)
08:27:48 <Cale> It's just that [a] -> a means the function will be undefined for empty lists, and whenever it's not undefined will pick some element of the list.
08:27:55 * hackagebot vector-algorithms 0.3.2 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.3.2 (DanDoel)
08:28:01 <Axman6> EnglishGent: (!! 0)?
08:28:41 <Cale> EnglishGent: there are things which foldr can't do easily... but it's possible to write fix in terms of foldr, and by adding more parameters, to compute essentially anything ;)
08:28:42 <Botje> Axman6: the First monoid :)
08:29:11 <EnglishGent> no - you could do that by having a Maybe value - and a function that sets it to Just a if it's nothing & otherwise ignores it's input
08:29:34 <EvanR-work> foldr can implement any function on the list, because all elements eventally get seen
08:29:41 <EvanR-work> it makes somethings easier, and some things harder
08:29:55 <EnglishGent> that's how it seems to me EvanR-work
08:30:07 <Botje> > foldr (\a b -> b `mappend` First a) mempty [1..5]
08:30:07 <EnglishGent> that (modulo side effects) it can do anything!
08:30:07 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe a))
08:30:08 <lambdabot>    arising from the ar...
08:30:11 <Cale> However, if you're talking about restricting foldr to 3 parameters only, then there are limitations
08:30:22 <sioraiocht> EvanR-work: umm, not paramorphisms
08:30:31 <EvanR-work> :o
08:30:41 <EnglishGent> what's a paramorphism?
08:31:11 <sioraiocht> A paramorphism (from Greek παρά, meaning "close together") is an extension of the concept of catamorphism to deal with a form which “eats its argument and keeps it too”[1][2]
08:31:23 <Cale> But if you allow the possibility of producing functions which take more parameters, you can get around those :)
08:31:28 * EnglishGent has gotten far enough through the math to know some kinds of morphism - but not that one :)
08:31:38 <Cale> For example, consider using foldr to write the 'last' function.
08:31:44 <Botje> > foldr (\a b -> First (Just a) `mappend` b) mempty [1..5]
08:31:45 <lambdabot>   First {getFirst = Just 1}
08:31:46 <sioraiocht> Cale: yeah, that sucks! =p
08:31:48 <Botje> tadaa! :)
08:32:19 <Cale> er, sorry, that's a poor example :)
08:32:24 <dmwit> > First . listToMaybe $ [1..5]
08:32:25 <lambdabot>   First {getFirst = Just 1}
08:32:34 <aavogt> > foldr (flip const) [1..5]
08:32:35 <lambdabot>   {[]->[1,2,3,4,5];[()]->[1,2,3,4,5];[(),()]->[1,2,3,4,5];[(),(),()]->[1,2,3,...
08:32:41 <aavogt> > foldr (flip const) undefined [1..5]
08:32:42 <lambdabot>   *Exception: Prelude.undefined
08:32:42 <Cale> hmm, no, it's fine :)
08:32:52 <aavogt> > foldr const undefined [1..5]
08:32:53 <lambdabot>   1
08:33:12 <dmwit> > foldr (const . Just) Nothing [1..5]
08:33:13 <lambdabot>   Just 1
08:34:54 <EvanR-work> i have a top level x = 0, and i have an expression somewhere (in another module) that doesnt foo x, where foo takes an Int. compiler complains that Int doesnt match Integer :(
08:35:03 <EvanR-work> s/doesnt/does/
08:35:54 <aavogt> EvanR-work: -XNoMonomorphismRestriction
08:35:56 <EvanR-work> i know Integer is the default, but shouldnt the inferrence tell foo x that 0 is a Int
08:36:04 <zygoloid> EvanR-work: only within the same module
08:36:09 <EvanR-work> mm okay
08:36:20 <zygoloid> this is part of why the monomorphism restriction is so icky
08:36:47 <EvanR-work> so an exported constant can have only one type for the entire program?
08:37:06 <aavogt> unless you annotate otherwise
08:37:39 <zygoloid> (or turn off the DMR)
08:38:33 <EvanR-work> so i guess i do foo . fromIntegral $ x
08:39:59 <Cale> With more parameters, it's easier to write last using foldr :)
08:40:06 <Cale> > foldr (\x xs -> xs . const x) id [1..5] undefined
08:40:07 <lambdabot>   5
08:40:49 <Cale> But I think it's impossible with only 3
08:40:59 <Cale> (and nothing wrapped around the outside)
08:41:58 <EvanR-work> > foldl (\x v -> x) 0 [1..5]
08:41:59 <lambdabot>   0
08:42:06 <Botje> > foldr (\a b -> b `mappend` First (Just a)) mempty [1..5]
08:42:07 <lambdabot>   First {getFirst = Just 5}
08:42:07 <EvanR-work> > foldl (\v x -> x) 0 [1..5]
08:42:08 <lambdabot>   5
08:42:12 <EvanR-work> ;)
08:42:13 <Botje> Cale: ^^
08:42:31 <Cale> Botje: Doesn't have the same type
08:42:38 <Botje> ah, like that
08:42:41 <Botje> no, that's true.
08:43:00 <EvanR-work> > foldr (\v x -> x) 0 [1..5]
08:43:01 <lambdabot>   0
08:43:06 <EvanR-work> > foldr (\x v -> x) 0 [1..5]
08:43:07 <lambdabot>   1
08:43:10 <EvanR-work> :(
08:43:25 <EvanR-work> the last one is the first one it sees
08:43:48 <aavogt> evaluation order isn't exactly specified
08:43:50 <EnglishGent> hmm .. I agree Cale - though I can do it if I'm allowed to return a tuple & take the 1st element of the tuple
08:44:04 <Cale> EnglishGent: sure
08:44:29 <aavogt> > foldr (\x v -> if v == 0 then x else v) 0 [1..5]
08:44:30 <lambdabot>   5
08:44:39 <EnglishGent> I guess that's what I was thinking of - that didnt fold let me specify effectively an arbitrary machine & then shove each element of a list through it
08:44:54 <Cale> But I think if you're restricted to an expression of the form (foldr f z) for some fixed f and z, it's impossible to write a function equivalent to 'last'
08:44:55 <EnglishGent> effectively specify*
08:45:12 <aavogt> Cale: how about allowing 'isBottom'?
08:45:25 <aavogt> as an alternative to  v == 0
08:45:32 <Cale> aavogt: Only if you promise to share your halting oracle with me
08:45:48 <EnglishGent> btw - complete aside - but is it $! to force evaluation?
08:45:48 <aavogt> @hoogle isBottom
08:45:48 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
08:45:59 <EvanR-work> @src ($!)
08:45:59 <lambdabot> f $! x = x `seq` f x
08:46:12 <aavogt> Cale: you can reliably catch / test for some bottoms :P
08:46:22 <EvanR-work> @quote explode
08:46:22 <lambdabot> ghc says: My brain just exploded.
08:46:28 <EvanR-work> @quote explode
08:46:28 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
08:46:36 <EvanR-work> @quote bottoms
08:46:37 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
08:46:37 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
08:46:38 <Cale> EnglishGent: $! is weakly-strict application, so *when* f $! x is evaluated, then it ensures x is evaluated before the result f x is made available
08:46:39 <aavogt> which is ok here, because we get to specify the bottom being caught
08:47:21 <Cale> aavogt: Well, being able to catch exceptions is another way to manage it, I suppose :)
08:48:05 <Cale> You need a bit more control in any case. When I add more parameters to foldr, I can use continuation passing style to essentially do the same thing :)
08:48:11 <EvanR-work> so foldr is restrictive
08:48:17 <quicksilver> or if you're allowed to map Just the list
08:48:22 <quicksilver> then you can use Nothing
08:48:38 <quicksilver> which is just like taking the exception catching thing inside the type system.
08:48:47 <aavogt> @src last
08:48:47 <lambdabot> last [x]    = x
08:48:47 <lambdabot> last (_:xs) = last xs
08:48:47 <lambdabot> last []     = undefined
08:48:51 * EnglishGent smirks at the 007 titles :)
08:49:03 <aavogt> seriously, it's not that hard to write last
08:49:13 <Cale> > foldr (\x xs -> case xs of Nothing -> Just x; _ -> xs) Nothing [1..5]
08:49:14 <lambdabot>   Just 5
08:49:26 <Cale> yep
08:49:57 <Cale> Now, let's write reverse using foldr :)
08:49:59 <EvanR-work> id like to see a proof that its impossible
08:50:09 <zygoloid> > foldr (\x r -> r <|> Just x) Nothing [1..5]
08:50:10 <lambdabot>   Just 5
08:50:29 <zygoloid> > foldl (\r x -> r <|> Just x) Nothing [1..5]
08:50:30 <lambdabot>   Just 1
08:50:56 <Cale> > foldr (\x xs -> xs . (x:)) id [1..5] []
08:51:00 <lambdabot>   [5,4,3,2,1]
08:51:11 <Cale> foldr with moar parameters is powerful :)
08:51:50 <Cale> I wonder if all you need is just the one, or if there's more that you could do with two extra parameters than there is that you could do with one.
08:53:35 <quicksilver> seems unlikely.
08:53:40 <quicksilver> the main trick is building a function
08:53:52 <quicksilver> functions with two parameters are no more powerful than functions with one, are they?
08:54:28 <Cale> Not usually, but we're talking about constructing functions with an exact type, and not permitting anything outside of the foldr
08:59:05 * hackagebot hpage 0.7.0 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.7.0 (FernandoBenavides)
08:59:12 <EnglishGent> wb magicman :)
09:02:03 <fax> any one know where to get posters of the reimann zeta function
09:25:16 <_2x2l> who's going to the boston haskell meet tonight?
09:30:56 <EvanR-work> @hoogle [[a],[b]] -> [(a, [b])]
09:30:57 <lambdabot> Parse error:
09:30:57 <lambdabot>   --count=20 "[[a],[b]] -> [(a, [b])]"
09:30:57 <lambdabot>                  ^
09:31:18 <EvanR-work> er
09:31:38 <benmachine> ([a],[b]) perhaps?
09:31:45 <EvanR-work> stupid HDBC, list of anything
09:32:05 <aavogt> then check out haskelldb
09:32:21 <EvanR-work> @hoogle [[a],[a]] -> [(a, [a])]
09:32:22 <lambdabot> Parse error:
09:32:22 <lambdabot>   --count=20 "[[a],[a]] -> [(a, [a])]"
09:32:22 <lambdabot>                  ^
09:32:50 <aavogt> there are way too many functions with that type
09:33:11 <aavogt> perhaps you're complaining about how regexes match?
09:33:29 <EvanR-work> i was complaining about all the different data in the list being the same type
09:33:56 <aavogt> > "hello somebody" =~ "(l.o).*(d.*y)" :: [[String]]
09:33:57 <lambdabot>   [["llo somebody","llo","dy"]]
09:34:04 <Amagineer> Is there some way to change the location that cabal stores its config file, on windows?
09:34:07 <EvanR-work> @hoogle [(a, b)] -> [(a, [b])]
09:34:07 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
09:37:10 <EvanR-work> (1,2) (1,4) (1,6) (4,6) -> (1, [2,4,6]) (4, [6])
09:37:58 <Cale> EvanR-work: [[a],[a]] is not a valid type
09:38:00 <benmachine> you'd need to sortBy (comparing fst) I think
09:38:04 <EvanR-work> Cale: yes
09:38:19 <EvanR-work> benmachine: yes, i grouped by
09:38:24 <EvanR-work> sort group
09:38:26 <benmachine> then groupBy ((==) `on` fst) and then unzip and head
09:39:05 <benmachine> :t map (first head) . unzip . groupBy ((==) `on` fst) . sortBy (comparing fst)
09:39:07 <lambdabot>     Couldn't match expected type `[([a], d)]'
09:39:07 <lambdabot>            against inferred type `([a1], [b])'
09:39:07 <lambdabot>     In the first argument of `(.)', namely `unzip'
09:39:12 <benmachine> ummm
09:39:19 <benmachine> :t groupBy ((==) `on` fst) . sortBy (comparing fst)
09:39:20 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [[(a, b)]]
09:39:24 * Cale had almost forgotten how stupid C library functions were. strtok is ridiculous.
09:39:33 <benmachine> :t map (first head . unzip) . groupBy ((==) `on` fst) . sortBy (comparing fst)
09:39:35 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, [b])]
09:41:02 <EvanR-work> :t first
09:41:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
09:41:10 <EvanR-work> @hoogle first
09:41:11 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
09:41:11 <lambdabot> Data.Monoid newtype First a
09:41:11 <lambdabot> Data.Monoid First :: Maybe a -> First a
09:41:16 <benmachine> :t first head
09:41:17 <lambdabot> forall c d. ([c], d) -> (c, d)
09:41:33 <EvanR-work> which module
09:41:36 <DanC> is strtok one of the C std lib functions where there's no argument to give the size of the buffer? or is that the one that's not thread-safe?
09:41:39 <benmachine> Control.Arrow
09:41:46 <Cale> DanC: Not thread-safe.
09:41:52 <benmachine> DanC: it's one of the many that's not thread-safe
09:41:58 <benmachine> and can't be used on constant strings
09:42:02 <EvanR-work> benmachine: thats pretty tight
09:42:15 <DanC> there's a lingering smell to it, though I don't recall exactly why...
09:42:43 <benmachine> @hoogle equating
09:42:43 <lambdabot> No results found
09:42:46 <benmachine> aw
09:43:14 <Eelis> @hoogle (x, y) -> (y, x)
09:43:15 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:43:15 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
09:43:15 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
09:43:20 <Eelis> o_O
09:43:24 <jmcarthur> oh sweet i just noticed there is a release of repa
09:43:46 <benmachine> :t (snd &&& fst)
09:43:47 <lambdabot> forall a c. (a, c) -> (c, a)
09:43:52 <Cale> You call it once with the string and delimiters, and it gives you the first token, and then you call it again with NULL as the parameter to get subsequent tokens.
09:44:29 <Cale> I'm not sure how this counts as at all a reasonable API design.
09:44:37 <jmcarthur> oh cool, it has generic indexing
09:45:23 <Cale> There's a strtok_r which at least gives you a way to refer to which set of calls to strtok_r you're dealing with.
09:46:08 <jmcarthur> Cale: ugh!
09:47:23 <Cale> But it seems like a really poor design for something which is absolutely trivial to handle in a stateless way.
09:50:29 <fax> @oeis 1,2,6,24
09:50:29 <lambdabot>  Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number ...
09:50:29 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
09:50:33 <DanC> clearly statelessness was under-appreciated at the time it was written... one wonders why it was ratified as part of the standard.
09:51:10 <tromp_> : t scanl
09:51:23 <tromp_> :t scanl
09:51:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:51:47 <tromp_> > scanl (*) 1 [1..]
09:51:48 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
09:52:02 <Cale> It's almost as if they went out of their way to write something that would break compositionality of programs.
09:52:41 <ezyang> strtok breaks almost every rule in the book. It's pretty impressive.
09:52:48 <ezyang> "All in the name of performance"
09:52:50 <jmcarthur> compositionality is not normally a major focus-point for C programmers
09:54:41 <pikhq> The C library is not an example of good API design.
09:54:57 <ezyang> I have to admit, though man somefunc is pretty handy
09:57:16 <theorbtwo> The C stdlib is *old*, for the most part.
09:57:42 <theorbtwo> Statelessness not being considered terribly important doesn't surprise me at all.
09:58:00 <zygoloid> "BUGS: Avoid using these functions."
09:58:28 <Eelis> > let (|:) = 3 in (|:)  -- i just discovered that this breaks when using -XArrows. is that to be expected, or is something wrong? (this  |:  operator is used by Data.List.NonEmpty)
09:58:29 <lambdabot>   3
09:58:36 <pikhq> Yeah, that's a pretty common one.
09:58:36 <Eelis> the breakage is just that it gives a syntax error
09:59:04 <pikhq> For instance, all the bloody buffer overflowy functions.
10:00:19 <Cale> Eelis: weird...
10:00:34 <zygoloid> Eelis: (| ... |) is arrow syntax
10:00:38 <Cale> aha!
10:00:42 <Eelis> oh..
10:00:44 <zygoloid> put spaces in!
10:01:00 <fax> yikes why does arrow define those brackets
10:01:07 <fax> that should be -XIdioms
10:01:21 <fax> (or even better -XtraBrackets)
10:01:29 <Eelis> zygoloid: ok, that worked. thanks! :)
10:01:48 <zygoloid> the brackets automatically lift functions to work on commands rather than values iirc
10:06:39 <danderson> hehehe, the description of Codec.Crypto.AES.Monad is lovely: "An occasionally pure, monadic interface to AES"
10:06:50 <chessguy> @hoogle join
10:06:51 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
10:06:51 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
10:06:51 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
10:07:13 <chessguy> @hoogle [String] -> Char -> String
10:07:13 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
10:07:13 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
10:07:13 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
10:08:32 <aavogt> @ty intersperse
10:08:33 <lambdabot> forall a. a -> [a] -> [a]
10:08:33 <ClaudiusMaximus> @hoogle [[a]] -> a -> [a]
10:08:33 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
10:08:33 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:08:33 <lambdabot> Data.Graph.Inductive.Internal.RootPath getPath :: Node -> RTree -> Path
10:13:09 <chessguy> ugh. what's the idiomatic way to turn "a,b,c" into ["a","b","c"]
10:13:35 <Philonous> @type wordsBy (==",")
10:13:36 <lambdabot> Not in scope: `wordsBy'
10:13:54 <Philonous> It's in the split package
10:14:00 <chessguy> figures
10:14:26 <fax> Philonous: how can you split by ==","? does it try every subsequence
10:14:55 <Philonous> fax: Actually that would give a type error. I meanto write wordsBy (==',')
10:15:10 <fax> ah okay
10:15:31 <Philonous> fax: Though there is splitOn, which does exactly what you describe
10:15:33 <zygoloid> > map (filter (/=',')) . groupBy (\a b -> b == ',') $ "a,b,c"
10:15:34 <lambdabot>   ["a","b","c"]
10:15:37 * zygoloid ducks
10:16:23 <benmachine> hah
10:16:32 <SonOfLilit> melon
10:16:58 <zygoloid> aubergine
10:17:38 <SonOfLilit> first, a question
10:17:56 <SonOfLilit> I've seen reference today to do notation as less idiomatic haskell
10:18:02 <SonOfLilit> is that correct, and if so, why?
10:18:11 <jmcarthur> well, not strictly
10:18:16 <SonOfLilit> what is right/wrong/worse with it?
10:18:20 <c_wraith> some people have a vendetta against do notation
10:18:23 <zygoloid> it can make code seem more imperative
10:18:46 <jmcarthur> do notation is very imperative. if your monad is imperative anyway, do notation is fairly natural
10:18:49 <Philonous> Syntactical sugar causes cancer of the semicolon
10:18:53 <jmcarthur> *is very imperative-looking
10:19:28 <chessguy> @type splitOn
10:19:29 <lambdabot> Not in scope: `splitOn'
10:19:38 <jmcarthur> but often it's helpful to make the combinators more explicit
10:19:45 <zygoloid> if what you're doing is applicative, applicative syntax can appear more functional
10:19:51 <aavogt> _more explicit_ ?
10:20:02 <chessguy> @type Data.Split.splitOn
10:20:03 <lambdabot> Couldn't find qualified module.
10:20:06 <pikhq> It really is a question of what makes what you're doing clearest.
10:20:22 <Philonous> @type Data.List.Split.splitOn
10:20:23 <lambdabot> Couldn't find qualified module.
10:20:36 <c_wraith> one time I wrote liftM4 just to not use do notation :)
10:20:44 <zygoloid> ("f <$> g a b <*> h c d" versus "do x <- g a b; y <- h c d; return (f x y)"
10:21:02 <Philonous> The second appears more readable to me
10:21:12 <pikhq> Philonous: What's wrong with you?
10:21:17 <SonOfLilit> lol
10:21:24 <zygoloid> once you know the former is just generalized function application, it can seem clearer
10:21:49 <SonOfLilit> haskell coders use so many operators...
10:21:52 <chessguy> @hoogle wordsBy
10:21:52 <lambdabot> No results found
10:22:11 <Philonous> pikhq: I'd use Kleisli and arrow syntax, though
10:22:11 <pikhq> SonOfLilit: "Operators" in Haskell are just infix functions.
10:22:19 <daviddarais> if by operator you mean combinator, then yes
10:22:28 <pikhq> Philonous: I beat you with <$> and <*>.
10:22:29 <SonOfLilit> yes
10:22:39 <[swift]1> does LYAH have a good discussion of applicative stuff? RWH didn't cover it much, unless its in one of the chapters I haven't read yet
10:22:41 <SonOfLilit> they know by heart so many different ways to combine
10:22:47 <pikhq> It's exceptionally clear for that purpose.
10:23:09 <[swift]1> the result is that i never use it
10:23:45 <pikhq> I don't think it has a treatment of applicatives yet.
10:23:52 <pikhq> Still. It's fairly simple.
10:24:00 <pikhq> I presume you know functors?
10:24:14 <zygoloid> [swift]1: it's pretty straightforward. Applicatives are like monads except the only operations you have are liftM<n> forall n. :D
10:24:20 <[swift]1> yeah
10:24:28 <pikhq> :t (<*>)
10:24:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:24:42 <pikhq> An applicative functor is a functor with that function also defined.
10:25:07 <pikhq> (<$>), also commonly seen with applicatives, is a synonym for fmap.
10:25:47 <zygoloid> liftA1 f x = f <$> x; liftA2 f x1 x2 = f <$> x1 <*> x2; liftA3 f x1 x2 x3 = f <$> x1 <*> x2 <*> x3; ...
10:26:11 <Cale> Not just that, an applicative functor has pure as well
10:26:19 <pikhq> Oh, *duh*.
10:26:20 <zygoloid> liftA0 f = pure f
10:26:22 <pikhq> :t pure
10:26:23 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:26:30 <pikhq> It also has that.
10:26:36 <pikhq> Analogies with return should be obvious. :)
10:26:43 <[swift]1> yeah, it looks a lot like return
10:27:01 <[swift]1> f :: * -> * means a function of arbitrary type?
10:27:08 <Cale> In the case of a monad, pure and return are the same
10:27:13 <zygoloid> [swift]1: clearly every monad is an applicative functor (and for every Monad instance there's a corresponding Applicative instance)
10:27:20 <Cale> Means a type-level function
10:27:41 <pikhq> That's just a kind annotation. It's an extension to Haskell's typesystem that Lambdabot always has on.
10:27:44 <Cale> * is the kind of all types
10:27:44 <zygoloid> but there are some functors, such as Either, where the Monad and Applicative instance aren't the same :o
10:27:56 <Cale> * -> * is the kind of type constructors with one type parameter
10:27:57 <chessguy> is there somewhere online that i can test code that requires a hoogle package?
10:28:01 <chessguy> err, a hackage
10:28:41 <[swift]1> Cale: ahh, so it applicative requires one type parameter for the same reason Monad does, right? makes sense
10:28:43 <Cale> So, for example, Maybe :: * -> *
10:28:45 <Cale> yeah
10:28:54 <Cale> :k Maybe
10:28:55 <lambdabot> * -> *
10:29:01 <Cale> :k Integer
10:29:01 <benmachine> zygoloid: don't have to be the same, but can be
10:29:02 <lambdabot> *
10:29:05 <Cale> :k Maybe Integer
10:29:06 <lambdabot> *
10:29:18 <jmcarthur> arguably should be the same though
10:29:25 <zygoloid> benmachine: isn't that what i said? :)
10:29:45 <benmachine> zygoloid: it is a generalisation of what you said, I suppose?
10:30:00 <benmachine> or a clarification
10:30:01 <benmachine> or
10:30:04 <benmachine> I'm just being odd
10:30:05 <[swift]1> so if i do f <$> a <*> b, essentially what's happening is that f is being lifted in some way (depending on the Applicative instance) and then applied to the arguments a and b?
10:30:07 <benmachine> any/all of those
10:30:22 <zygoloid> benmachine: seems more like you're disagreeing with Cale :)
10:30:33 <zygoloid> pure and return need not be the same
10:30:53 <zygoloid> however, making them different is... unethical :)
10:30:55 <Cale> It's a bug if pure and return are not the same
10:31:04 <benmachine> what about e.g. ZipList
10:31:11 <fax> it's against the law
10:31:12 <Cale> What about ZipList?
10:31:13 <Cale> It's not a monad
10:31:35 <jmcarthur> [swift]1: if (f :: a -> b -> c) and (x :: f a), (f <$> x :: f (b -> c)), so if (y :: f b), (f <$> x <*> y :: f c)
10:31:40 <SonOfLilit> I'm trying to write choiceOf k list :: Integer -> [a] -> [[a]] that gives me a list of all the sublists of a of size k and I'm having some type problems. Before I spend loads of time on them - is there a standard implementation?
10:32:00 <benmachine> wait, is there actually a law that pure = return if both are defined on a type?
10:32:07 <benmachine> like, specifically that
10:32:11 <jmcarthur> benmachine: there's not
10:32:11 <zygoloid> benmachine: nope.
10:32:16 <jmcarthur> i wish there was
10:32:30 <fax> SonOfLilit: I implemented this yesterday
10:32:35 <fax> or maybe the day before
10:32:37 <benmachine> well laws are only defined by people anyway so if you say there is loudly enough then it becomes true :P
10:32:39 <zygoloid> the only relation between Monad and Applicative is via the Functor instance. and that's guaranteed to be the same by the uniqueness of fmap
10:32:52 <Cale> zygoloid: ?
10:32:53 <benmachine> zygoloid: Monads aren't required to have Functor instances >_>
10:32:57 <Cale> No, I totally disagree.
10:33:06 <jmcarthur> fmap is unique?
10:33:06 <pikhq> benmachine: It's a bug if they don't.
10:33:12 <Cale> Every monad is an applicative, with pure = return and (<*>) = ap
10:33:17 <jmcarthur> that didn't occur to me before, btu that makes sense
10:33:33 <jmcarthur> Cale: zygoloid is just talking about base, not in general
10:33:41 <Cale> and I'd consider it a bug for the instance of Applicative not to equal that definition in the case that there are instances of both
10:33:59 <jmcarthur> Cale: we have a bug in base then ;)  (Either)
10:34:00 <zygoloid> have you filed a bug on Either?
10:34:16 <Cale> Either breaks that policy?
10:34:19 <jmcarthur> yes
10:34:21 <benmachine> pikhq: would you argue that for any type for which Functor can be instantiated, not having the instance is a bug?
10:34:24 <SonOfLilit> fax: can you paste your implementation?
10:34:31 <fax> SonOfLilit, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25068
10:34:34 <Cale> oh, because it's missing its monad instance altogether, you mean?
10:34:38 <SonOfLilit> thanks
10:34:40 <jmcarthur> Cale: no, it has one
10:34:49 <benmachine> it has one in Control.Monad.Error which is not base
10:34:54 <zygoloid> Cale: nope, because the Applicative collects all errors and the Monad produces the first
10:34:56 <SonOfLilit> I'll look at it after mine is fixed
10:35:00 <jmcarthur> benmachine: oh!
10:35:02 <jmcarthur> nevermind then
10:35:10 <zygoloid> this is, in a sense, the point of the Applicative/Monad distinction, so it's not obvious that Either is /wrong/
10:35:16 <jmcarthur> then the bug is in mtl
10:35:22 <pikhq> benmachine: In most situations, yes.
10:35:32 <benmachine> I don't know where if anywhere the Monoid e => Either e a instance is defined
10:35:56 <jmcarthur> i haven't seen it around
10:36:01 <pikhq> benmachine: I'd say it's a bug *for Monads in particular* since I consider it a bug that Monad is not defined such that all Monads are Functors.
10:36:07 <benmachine> does anyone actually *use* it :P
10:36:10 <jmcarthur> if i had i probably would have had some conflicting instances
10:36:22 <jmcarthur> i consider it a bug that Monad doesn't require Applicative
10:36:28 <fax> SonOfLilit: It was designed to be used with a probabilistic monad
10:36:29 <Cale> > Left "hello" `ap` Left "x"
10:36:29 <lambdabot>   Left "hello"
10:36:30 <zygoloid> jmcarthur: i agree with that :)
10:36:33 <Cale> > Left "hello" <*> Left "x"
10:36:34 <fax> SonOfLilit: So it would randomly drop n elements
10:36:34 <lambdabot>   No instance for (Control.Applicative.Applicative
10:36:34 <lambdabot>                     (Data....
10:36:39 <Cale> oy
10:36:55 <Cale> The applicative instance is apparently missing altogether in 6.10.4
10:36:57 <fax> SonOfLilit: But if we use it on the list monad, it will give all results instead of picking a random one
10:37:10 <Cale> But in 6.12.1, it looks like they match
10:37:13 <benmachine> well, mtl doesn't have any applicative stuff at all does it?
10:37:33 <fax> SonOfLilit: so rather than roll randomly being true or false, it should be [True],[True,False] or [False] (edge cases for p <= 0 and p >= 1)
10:38:04 <fax> SonOfLilit: so this implements a generalization of your spec - and it is also a generalization of nCk
10:38:08 <Cale> What's the supposed difference between the applicative instance and monad instance for Either?
10:38:22 <Cale> They seem to agree to me.
10:39:02 <zygoloid> Cale: last i checked, f <$> Left "a" <*> Left "b" is Left "ab", whereas liftM2 f (Left "a") (Left "b") is Left "a"
10:39:21 <benmachine> Cale: where are you getting these instances from?
10:39:34 <Cale> ghci> undefined <$> Left "hello" <*> Left "x"
10:39:35 <Cale> Left "hello"
10:39:43 <fax> SonOfLilit: Do you understand
10:39:47 <benmachine> after importing Data.Either and Control.Applicative I still don't have them
10:39:55 <Cale> benmachine: Which GHC?
10:40:02 <Cale> I'm using 6.12.1
10:40:08 <benmachine> me too
10:40:18 <Cale> Import Control.Monad.Instances maybe?
10:40:26 <zygoloid> Cale: must be a glitch in the matrix
10:40:39 <zygoloid> Cale: isn't that just for Monad ((->) r)?
10:40:46 <Cale> There's a bunch of stuff in there.
10:40:48 <benmachine> and Functor ((->) r)
10:40:55 <[swift]1> ok, read the Haskell wikibooks article on Applicative Functors on top of our discussion, and I think I get it
10:40:56 <benmachine> but I'm still not getting Applicative Either
10:41:23 <jmcarthur> i hate how this stuff is scattered around
10:41:27 <Cale> ah, Control.Monad.Either
10:41:41 <benmachine> I don't have it
10:41:45 <djahandarie> Nor do I
10:41:59 <fax> SonOfLilit hello /;/
10:41:59 <fax> ?
10:42:01 <djahandarie> @hoogle Either
10:42:02 <lambdabot> module Data.Either
10:42:02 <lambdabot> Prelude data Either a b
10:42:02 <lambdabot> Data.Either data Either a b
10:42:09 <SonOfLilit> fax: A lot of what you said went above my head in terms of concepts, but I understand the code (more or less), and I understand that there is a magical haskell way to make it give all the results
10:42:14 <SonOfLilit> how do I write it?
10:42:22 <fax> SonOfLilit: what didn't make sense?
10:42:41 <fax> it's not magic by the way
10:42:56 <fax> but it may be close to it
10:43:11 <SonOfLilit> the reference to list monad made sense but went over my head
10:43:19 <SonOfLilit> since I'm not familiar with it
10:43:29 <SonOfLilit> or with how this is used "over a monad"
10:43:40 <EvanR-work> im sure wizards dont consider what they do magic either ;)
10:43:51 <fax> SonOfLilit: Well the program was designed with randomness in mind, so for a simplified example imagine a function f that gives a random number from {1,2,3}
10:44:01 <SonOfLilit> yes
10:44:05 <benmachine> there is a Control.Monad.Either in category-extras
10:44:08 <[swift]1> so <$> / fmap lifts a function a -> b, but due to currying b may really be c -> d -> e. each application of <*> takes the resulting f (c -> d -> e) and applies the head of the list of curried functions. using these two you can easily lift a function of arbitrary arity
10:44:12 <fax> SonOfLilit: with the random monad for a bunch of executions we will get: 1,2,3,2,3,2,1,2,3,1,2,...
10:44:22 <fax> SonOfLilit, but for the list monad we will get [1,2,3]
10:44:22 <djahandarie> category-extras. >_> <-<
10:44:36 <zygoloid> [swift]1: exactly.
10:44:59 <fax> SonOfLilit, the reason is that random monad decides randomly which branch to take, and list monad takes every branch at once
10:45:09 <SonOfLilit> oh
10:45:12 <[swift]1> zygoloid: excellent. another tool in my toolbox!
10:45:14 <SonOfLilit> so how would I call it?
10:45:24 <fax> SonOfLilit, there may be other monads the program runs on too --- but I haven't thought of any
10:45:47 <fax> SonOfLilit: There are some preconditions on the use of this function,
10:46:01 <fax> SonOfLilit: length must equal the length of the list, and 0 <= n <= length.
10:46:16 <fax> bbl
10:51:31 <fax> bacb
10:51:57 * hackagebot MonadCatchIO-transformers 0.2.1.0 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.2.1.0 (AriePeterson)
10:57:49 <fax> SonOfLilit: clear? :p
11:05:18 <Kaidelong> So I can get wxWidgets examples to build here and run
11:05:24 <Kaidelong> but not wxHaskell ones
11:05:58 <Kaidelong> so I guess I need the latest development version of wxHaskell or something, but it is weird that it works on Windows XP
11:06:19 <cocon> how can the pointfree bot be private messaged?
11:06:28 <Kaidelong> like normal
11:06:35 <Kaidelong> query lambdabot
11:06:50 <Kaidelong> send commands to her in private
11:06:51 <cocon> query lambdabot @pf \x -> x
11:06:56 <matt_m> Does anyone know if Haskell (maybe just GHC?) has problems finding type class instances around equirecursive types?
11:06:58 <cocon> query lambdabot @pl \x -> x
11:07:06 <Kaidelong> cocon
11:07:11 <Kaidelong> use / to prefix commands
11:07:22 <Kaidelong> you should be able to use /msg or /query
11:07:33 <Kaidelong> or perhaps /alert
11:07:36 <Kaidelong> it depends on your client
11:07:55 <cocon> what comes after query or msg ?
11:08:10 <Kaidelong> use "/query lambdabot" if you're using a graphical client
11:08:20 <jmcarthur> i've never seen /query
11:08:22 <Kaidelong> it'll open a window which is a private chat between you and lambdabot
11:08:27 <jmcarthur> i've only ever seen /msg
11:08:51 <Kaidelong> otherwise
11:09:03 <Kaidelong> you could use "/msg lambdabot your message here"
11:09:06 <jmcarthur> the full format command looks like:  /msg lambdabot @pl \x -> f x
11:09:41 <cocon> jmcarthur: thanks, that worked
11:10:26 <Kaidelong> jmcarthur: query is generally for people using xChat or mIRC or the like
11:10:57 <Kaidelong> opens a new window for the conversation
11:11:53 <Kaidelong> irssi does it too
11:11:56 <jmcarthur> Kaidelong: ah. even when i used xchat i just used msg. never knew about query
11:12:50 <matt_m> I've got   foo :: (C f g) => f (Fix g) -> g (Fix g), and the bar :: (C f g) => g (Fix g),  bar = foo (undefined :: f (Fix g))
11:13:14 <matt_m> It's claiming it can't find instance (C f g) at the call to foo inside bar
11:13:26 <matt_m> which baffles me...  any ideas anyone ?
11:13:59 <matt_m> Fix f = In (f (Fix f))
11:15:31 <fax> matt_m have you defined show for Fix yet?
11:16:34 <matt_m> fax: No, why?
11:16:48 <fax> matt_m: oh actualyl I think it's a differen thing and all you need is XScopedTypeVariables
11:16:55 <fax> and some foralls
11:17:10 <matt_m> hmmmm
11:17:31 <matt_m> fax: I'll look into it, thanks
11:21:51 <matt_m> fax:  ScopedTypeVariables - isn't that enabled with glasgowExts?
11:22:09 <matt_m> fax: Where are you thinking I'd put foralls?
11:22:10 <fax> matt_m: I don't know - I think it should be the default because it's so useful
11:22:16 <fax> forall f g. C f g => ...
11:22:24 <matt_m> oho k
11:22:27 <matt_m> let me try that...
11:22:38 <fax> to ScopedTypeVariables, not having the foralls is a bit different
11:22:55 <matt_m> fax:  That did the job!
11:23:00 <fax> ah good
11:23:16 <matt_m> And yes, apparently that is part of the glasgow exts
11:23:46 <matt_m> fax: Much thanks
11:49:30 * hackagebot cpsa 2.0.4 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.0.4 (JohnRamsdell)
11:54:42 <mightybyte> Is there a good library for number formatting?  I'm looking for the ability to choose different formats based on parameters like sign, notation, number of decimal places, thousands separators, etc.  I haven't seen anything in hackage that does that.
11:55:25 <mauke> limited version: printf
11:55:41 <mightybyte> Yeah.  Not quite powerful enough.
11:57:32 * hackagebot web-routes-hsp 0.20 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.20 (JeremyShaw)
12:02:56 <zark> hello. i have a short question. i noticed that some packages have version numbers in the thousand range. like "2009.4.28". i believed them to be the releasedate. but  then they continued with 3000 and even 4000.
12:03:16 <zark> what is the pattern which i dont know about?
12:03:22 <jmcarthur> yeah they are following strange conventions i think, that's all
12:03:24 <mauke> insanity
12:03:58 <dolio> They were written in the future.
12:04:02 <zark> http://hackage.haskell.org/package/HTTP for example or http://hackage.haskell.org/package/graphviz
12:04:02 <jmcarthur> i think they started by doing years but then decided they wanted a more sane versioning scheme but were stuck with 2009.4 as the major version number
12:04:21 <jmcarthur> so it was a compromise to switch to 3000, 4000, etc.
12:04:52 <mauke> and File::Slurp (perl) is at version 9999.13 for some reason
12:05:10 <jmcarthur> still beats the tex versioning system
12:05:26 <EvanR-work> 9999 is gentoos way of denoting 'git HEAD' version, might be inspired
12:05:42 <jmcarthur> ew
12:06:12 <EvanR-work> its also the max damage you can do in four digits
12:07:11 <mauke> > 9e99
12:07:12 <lambdabot>   9.0e99
12:07:53 <EvanR-work> > 9e99 + 1
12:07:54 <lambdabot>   9.0e99
12:08:08 <jmcarthur> > 1/0
12:08:09 <lambdabot>   Infinity
12:08:16 <EvanR-work> > omega + 1
12:08:17 <lambdabot>   Not in scope: `omega'
12:09:58 <Twey> Needs more Eden
12:10:11 <BMeph> Maybe someone wanted to answer the meme: "Why, yes, it _is_ over 9000." ;)
12:10:41 <EvanR-work> number the versions using ordinals for a change of pace
12:11:01 <Twey> ninethousandth?
12:11:14 <Twey> HTTP the Nine-Thousandth
12:13:24 <Twey> HTTP ↀↂ
12:14:49 <djahandarie> jmcarthur, infinity isn't a number!
12:15:48 <tensorpudding> bitches don't know about my extended reals
12:16:02 <jmcarthur> djahandarie: nobody specified that it had to be a number. just that it had to be "maximum damage"
12:16:20 <jmcarthur> > (1/0) > 9e99
12:16:21 <lambdabot>   True
12:16:43 <djahandarie> I imagine a damage function requires subtraction though?
12:17:02 <Kaidelong> > (1/0) > (1/0)
12:17:03 <lambdabot>   False
12:17:09 <Kaidelong> good to see that works
12:17:31 <djahandarie> >9^9^9 > 9e99
12:17:38 <djahandarie> > 9^9^9 > 9e99
12:17:39 <lambdabot>   True
12:17:48 <djahandarie> Ugh
12:17:50 <djahandarie> Can't even count
12:17:52 <djahandarie> -_-
12:18:08 <Kaidelong> > (1/0) == (1/0)
12:18:09 <lambdabot>   True
12:18:12 <Kaidelong> what
12:18:21 <Kaidelong> isn't that supposed to be false?
12:18:39 <Kaidelong> or undefined, I guess
12:19:11 <djahandarie> We could always use busy beaver numbers
12:19:14 <mauke> no, infinity equals itself
12:19:17 <djahandarie> Except that we can't actually list them
12:19:56 <Kaidelong> mauke: I did not know that. I remember something about infinities of the same order being incomparable.
12:21:29 <Kaidelong> would "length [1..]" do anything bad to lambdabot?
12:21:39 <jmcarthur> > length [1..]
12:21:42 <lambdabot>   mueval-core: Time limit exceeded
12:21:46 <jmcarthur> that's all
12:21:50 <Kaidelong> ah I see
12:22:00 <mauke> > length [1 :: Int ..]
12:22:03 <lambdabot>   mueval-core: Time limit exceeded
12:22:10 <mauke> > length [1 :: Int16 ..]
12:22:11 <lambdabot>   32767
12:22:28 <Makoryu> > length [1 :: Int ..]
12:22:32 <lambdabot>   mueval-core: Time limit exceeded
12:22:34 <jmcarthur> > length [minBound :: Int8 ..]
12:22:35 <lambdabot>   256
12:22:52 <Kaidelong> I guess that means that infinite cardinalities are not sensible concept in the programming environment anyway
12:23:02 <fax> Kaidelong, why not?
12:23:19 <fax> ah because they don't have computational content
12:23:33 <fax> but some infinite ordinals can
12:23:37 <Kaidelong> they may if you wanted to do something like compare the length of two lists
12:23:45 <Kaidelong> and you want it to terminate even if a list is infinite
12:24:09 <djahandarie> > let a 0 n = n+1; a (m+1) 0 = a m 1; a (m+1) (n+1) = a m (a (m+1) n); a _ _ = 0 in a 9 9
12:24:11 <EvanR-work> you can have bigger than a countable list though, normally
12:24:13 <lambdabot>   mueval-core: Time limit exceeded
12:24:14 <Kaidelong> perhaps there were some attempts at that before with stuff like SETL?
12:24:32 <Kaidelong> not sure
12:24:56 <EvanR-work> Kaidelong: theres this cool function, isInfinite :: [a] -> Bool ;)
12:25:05 <EvanR-work> still trying to figure out how to write it
12:25:06 <djahandarie> Technically 5 characters for a 9 9 but still :P
12:25:33 <Kaidelong> EvanR-work: yes but say you make a function that takes a list and generates a list of all possible lists made of elements from the list
12:25:38 <jmcarthur> Kaidelong: you can compare lengths of two lists even if one of them is infinitely long if you use genericLength and lazy naturals
12:25:47 <Kaidelong> even if both are infinite, the output is always larger than the input
12:26:12 <jmcarthur> of course if both are infinite lists then it won't terminate
12:26:14 <fax> yeah that's ordinals up to omega
12:26:22 <fax> (co)data N = O | S N
12:26:30 <Kaidelong> Cantor proved it
12:26:33 <Kaidelong> I believe
12:26:51 <fax> Kaidelong yes I know that one
12:27:02 <fax> Cantor diagonalization
12:27:35 <jmcarthur> what is the argument that (1/0) == (1/0) should be True? seems to me that it should be _|_
12:27:52 <EvanR-work> Kaidelong: write a haskell list of all infinite streams of 1 or 0
12:27:54 <fax> jmcarthur, maybe something to do with Reimann sphere
12:28:05 <EvanR-work> maybe easy with a list comprehension
12:28:10 <mauke> jmcarthur: IEEE says so
12:28:33 <jmcarthur> mauke: well, that's not really what i meant :P
12:28:39 <fax> you can do every finite list
12:28:46 <fax> but you cannot contain every infinite stream
12:28:59 <fax> only the computable streams
12:30:01 <danderson> straw poll: I'm writing a library that implements a cryptographic authentication and symmetric key agreement protocol (STS). What should the module name be?
12:30:14 <EvanR-work> why cant you make an exponential algorithm that computes the next digit in each of the 2^n next possible lists?
12:30:21 <fax> Crytography.STS
12:30:23 <EvanR-work> granted it would stop at like step 10
12:31:04 <EvanR-work> forkIO even
12:32:11 <danderson> fax: why not, although nothing uses Cryptography.* yet
12:33:53 <dfkjjkfd> P
12:34:03 <fax> danderson (I'm mostly suggesting it to avoid someone creating the horrid abbrev. Crypto.)
12:34:15 <danderson> fax: too late, apparently
12:34:22 <fax> :(
12:34:31 <danderson> there's just one package that uses it though
12:34:59 <danderson> just the one key derivation algorithm
12:36:15 <danderson> I'll probably spam cafe and see about using Cryptography
12:37:35 <zark4711> cool. its my first time in this channel even though i have been programming hs for a year now as a hobby. so no i can ask all kinds of weird questions and there are actually people how can answer them. sorry (for myself) that the enlightment came so late.
12:37:54 <zark4711> here is one: what is >> actualy called?
12:38:14 <EvanR-work> bit shift right
12:38:16 <dolio> Much greater than.
12:38:41 <mauke> "then"
12:40:30 <fax> chevrons
12:41:56 <haskell_newbie> hello all
12:42:16 <haskell_newbie> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
12:42:25 <haskell_newbie> this one is working fine
12:42:48 <fax> haskll_newbie, I'd write it as  notNull = not . null
12:42:51 <haskell_newbie> but mine one is not let fun x= x*x in filter fun [1..10]
12:43:01 <fax> haskell_newbie, and infact it seems like notNull is extraneous now
12:43:13 <EvanR-work> > let notNull = not . null in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
12:43:14 <lambdabot>   [[1,2,3],[3,4,5],[2,2]]
12:43:19 <mauke> haskell_newbie: that's because x*x is not a boolean value
12:43:20 <fax> haskell_newbie: did you write the let fun x = x*x .. one?
12:43:40 <mauke> haskell_newbie: did you mean map instead of filter?
12:44:04 <EvanR-work> > let fun x = x*x > 0 in filter fun [1..10]
12:44:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:44:07 <haskell_newbie> @fax so predicate must return boolean
12:44:07 <lambdabot> The answer is: Yes! Haskell can do that.
12:44:17 <EvanR-work> lol
12:44:19 <benmachine> hah
12:44:23 <mauke> haskell_newbie: yes, that's what "predicate" means
12:44:29 <fax> haskell_newbie: huh? That didnt answer my question
12:44:57 <fax> in lisp they use -P in the name
12:45:17 <fax> but in haskell we don't have any linguistic hints, we just look at the type
12:46:39 <haskell_newbie> thank you all
12:46:41 <haskell_newbie> for answer
12:46:46 <fax> :(
12:46:58 <haskell_newbie> @fax
12:46:58 <lambdabot> The answer is: Yes! Haskell can do that.
12:47:01 <EvanR-work> > let fun x = x*x in map fun [1..10]
12:47:02 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
12:47:04 <haskell_newbie> i did not get u
12:47:18 <fax> haskell_newbie: I was wondering if you wrote this function, or if it was handed down to you
12:47:29 <haskell_newbie> no i wrote it
12:47:41 <fax> oh okay
12:47:42 <haskell_newbie> i am learning
12:47:45 <fax> what was it meant to do?
12:47:51 <haskell_newbie> so i am playing with function
12:48:01 <fax> are you trying to find square numbers?
12:48:13 <haskell_newbie> square a the values in the list
12:48:17 <fax> oh okay
12:48:23 <haskell_newbie> i got confused with  map
12:48:33 <Kaidelong> > map (\x->x*x) [1..10]
12:48:34 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
12:48:36 <Kaidelong> ah
12:48:48 <Kaidelong> yeah, check function types
12:49:10 <haskell_newbie>  i guess now i can learn more fast
12:49:28 <Kaidelong> @type filter
12:49:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:49:35 <Kaidelong> @type map
12:49:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:49:41 <haskell_newbie> with the help from u guys
12:50:01 <matt_m> Hmm, now I'm getting a different problem
12:51:57 <matt_m> fax:    foo :: forall f g. (C f g) => Fix g -> g (Fix g)
12:52:22 <matt_m> fax:  I put     foo x = bar x ,  it compiles and infers the following type for foo:
12:52:35 <matt_m> fax:    err        bar x = foo x
12:53:01 <matt_m> fax:   bar :: forall (f :: * -> *) (g :: * -> *). (C f g) => Fix g -> g (Fix g)
12:53:28 <matt_m> fax:  IF I copy that exact signature into the code for bar, it complains that it can't find the instance of C
12:54:01 <matt_m> Anyone seen a situation where the inferred annotation, if explicitly stated, gives an error?
12:54:47 <EvanR-work> yes
12:55:06 <EvanR-work> but i dont think i was putting the right annotation ;)
12:56:50 <matt_m> Well, I'm copy/pasting the annotation
12:56:58 <zark4711> may i ask pretty much the same question again in a different way. suppose you were to write the function ">>" in an imperative language and you were not able to overload the operator, what would you call it?
12:57:10 <jmcarthur> matt_m: it happens if the inferred type refers to bound variables from, say, your top level type signature. your type annotation may use the same names, but the variables will not necessarily be the same
12:57:17 <mauke> zark4711: which ">>"?
12:57:23 <copumpkin> has anyone played with repa yet?
12:57:30 <jmcarthur> copumpkin: i haven't, but i want to!
12:57:35 <copumpkin> :)
12:57:39 <fax> matt_m, can you paste some code that I can test?
12:57:48 <copumpkin> WARNING: Most of the functions that operate on indices don't perform bounds checks. Doing these checks would interfere with code optimisation and reduce performance.	 Indexing outside arrays, or failing to meet the stated obligations will likely cause heap corruption.
12:57:48 <zark4711> the one from the monadlib
12:57:48 <matt_m> jmcarthur:  Makes sense, but the only variables are quantified ...
12:57:50 <matt_m> That I can see
12:57:52 <fax> test meaning typecheck
12:57:54 <matt_m> Sure, I can paste it
12:57:55 <Makoryu> zark4711: You know that the implementation of (>>) depends on its type, right?
12:57:55 <matt_m> hold on
12:58:23 <jmcarthur> copumpkin: yeah i saw that :(
12:58:54 <copumpkin> jmcarthur: makes me wish I weren't so lazy and had improved the situation with static size/index checking!
12:59:06 <jmcarthur> heh
12:59:06 <zark4711> @makoryu: (>>) :: (Monad m) => m a -> m b -> m b
12:59:06 <lambdabot> Unknown command, try @list
12:59:10 <copumpkin> one day
12:59:19 <jmcarthur> that is especially needed with this kind of behavior
12:59:23 <copumpkin> yeah
13:00:11 <mauke> zark4711: yes, that depends on m
13:00:43 <zark4711> ah, i understand, what you mean now. suppose m is the IO monad
13:01:36 <matt_m> fax: http://pastebin.com/FYyuTpWe
13:01:39 <fryguybob> In IO I think "then" makes sense
13:01:39 <Makoryu> zark4711: It would pretty much just be a semicolon.
13:01:45 <jmcarthur> copumpkin: Array has a Num instance, but no Functor or Applicative... :(
13:01:59 <benmachine> Num wat
13:02:02 <benmachine> how does that work
13:02:14 <jmcarthur> benmachine: you can lift Num using Applicative
13:02:20 <benmachine> oh
13:02:23 <benmachine> yes I suppose so
13:02:25 <jmcarthur> benmachine: in this case it has ZipList semantics
13:02:29 <benmachine> oh right
13:02:35 <copumpkin> jmcarthur: aw
13:03:03 <zark4711> Makoryu: yes, that is what i thought to. (exept that i want to compose the functions without applying them and be able to apply them at a later time.
13:03:25 <copumpkin> "If you don't like turnips then this library probably isn't for you."
13:03:34 <jmcarthur> actually, fromInteger isn't implemented. i wonder if pure is not possible with ZipList semantics in repa
13:03:51 <jmcarthur> due to the whole shape thing
13:03:56 <fax> matt_m, so it says:
13:03:57 <fax>     Could not deduce (C f g) from the context (C f1 g)
13:03:59 <fax> is that the problem ?
13:04:03 <matt_m> yup
13:04:33 <fax> matt_m, what is f?
13:04:39 <matt_m> ?
13:04:50 <fax> in the types of both foo and bar
13:05:04 <matt_m> It's a data constructor
13:05:07 <zark4711> i am getting a headache in using objective-c. i have implemented objects that compute their properties layzily and passing some form of function objects all around.
13:05:12 <fax> but why is it there
13:05:20 <matt_m> oh right
13:05:27 <zark4711> it makes so much more sense.
13:05:37 <matt_m> fax: This is a reduction case from my real code
13:05:39 <zark4711> but somethimes it is hard to express
13:05:48 <fax> matt_m, I think something essential is missing
13:05:49 <ManateeLazyCat> @tell dcoutts I have fix how to reparent GtkPlug, and not use hack tip, maybe i should write some deom in gtk2hs for this complicated situation.
13:05:49 <lambdabot> Consider it noted.
13:06:03 <matt_m> fax:  Does getting rid of f fix it?
13:06:06 <matt_m> that's probably the problem
13:06:14 <matt_m> hmm
13:06:19 <matt_m> still seems like it would work though
13:06:46 <fax> matt_m, I Know how to fix this but I don't want to suggest it
13:06:54 <fax> matt_m because the real solution is probably better
13:07:15 <Makoryu> zark4711: Oh... oh god... lazy Obj-C...
13:07:17 <fax> matt_m, well maybe I will show you this and it might give some insight actually
13:08:12 <matt_m> fax:  In my real code, the use of f isn't trivial.  I wonder why it can't deduce that type class, though
13:08:32 <fax> matt_m, http://www.pasteit4me.com/430001
13:08:45 <zark4711> Makoryu: yes, that is about the best feature i introduced in my code. since there is so little memory on the iphone i just store function that will generate the value (e.g. load an image) if the image is needed and will release it again, when memory is short
13:08:53 <fax> matt_m, if we had explicit type application we would not have to fake it with the dummies this way
13:09:48 <matt_m> fax:  What does that do?
13:09:58 <matt_m> How many underscores is that at the bottom?
13:10:23 <Makoryu> zark4711: Ah. Well, lazy IO is one thing.
13:10:52 <fax> matt_m: I use __ rather than undefined when it's not a placeholder
13:11:00 <Makoryu> zark4711: I wouldn't like to introduce too much lazy evaluation into Apple's happy fun carnival of UIEvent horrors, though.
13:11:04 <matt_m> fax: ok
13:11:20 <Makoryu> Too much cognitive dissonance.
13:11:40 <zark4711> :)
13:12:10 <zark4711> ...only if it will make things easier and code shorter
13:14:24 <fax> matt_m, you can think of a function:   f :: forall a. a -> ...
13:14:46 <fax> matt_m, when there is an application say,  f 3  -- it's implicitly   f Int 3,  for example
13:14:51 <fax> but haskell doesnt support that,
13:15:00 <fax> so we can fake it by  f :: forall a. a -> a -> ...
13:15:04 <fax> f (__ :: Int) 3
13:15:48 <Kaidelong> > x where x = x+1
13:15:49 <lambdabot>   <no location info>: parse error on input `where'
13:15:56 <zark4711> Makoryu: the app i am writing is almost finished, has about 5000 lines of code and does pretty much nothing. it is not that my fingers bleed from typing. it is that i need to think about how i can combine 5 objects in an subtle way to get the same effect i could achieve in half a haskell line. but i thing i am on the wrong channel here to complain about that, because everybody here probably made similar experiences when they started with haskell.
13:16:06 <matt_m> fax:  No, I get it.  I was just testing it on the real code
13:16:10 <fax> matt_m, (but there may be better solutions in the more complicated code)
13:16:11 <matt_m> fax:  Looks like it works!
13:16:13 <matt_m> fax:  Thanks!
13:16:14 * zark4711 drank to much coffee and is talking too much
13:16:14 <fax> ah cool
13:16:19 <matt_m> fax:  (again).  Neat trick
13:16:46 <Kaidelong> I see lambdabot doesn't like let bindings
13:16:52 <matt_m> fax:  Though I still don't understand why the type checker is getting lost
13:17:13 <fax> matt_m, it's about fresh vs bound variables
13:17:34 <matt_m> fax:  I guess types are only infered through parameters and it never checks to see if there is an obvious choice for an unused type parameter
13:17:42 <Kaidelong> but I see that it doesn't terminate
13:17:46 <roconnor> Kaidelong: lambdabot is fine with let binding
13:17:52 <roconnor> > let x = 5 in x
13:17:52 <lambdabot>   5
13:17:59 <roconnor> > let x = y where y = 5 in x
13:18:00 <lambdabot>   5
13:18:10 <Kaidelong> oh ok, so just the syntax
13:18:20 <Kaidelong> > let x = x+1 in x
13:18:24 <lambdabot>   mueval-core: Time limit exceeded
13:18:29 <roconnor> lambdabot is execting an expression not a declaration
13:18:40 <Kaidelong> <Kaidelong> > x where x = x+1
13:18:44 <Kaidelong> that's what I did
13:18:52 <Kaidelong> that didn't work
13:19:02 <roconnor> ya, that isn't a proper piece of haskell syntax
13:19:04 <Kaidelong> so it was just the syntax was wrong, clearly
13:19:05 <Kaidelong> yeah
13:19:20 <roconnor> it is a substring of proper haskell syntax
13:19:35 <roconnor> but you've cut up the grammer improperly
13:19:47 <roconnor> where clauses are attached to bindings
13:19:54 <roconnor> and there are no bindings to be attached to
13:19:59 <Kaidelong> ah, I see
13:20:09 <roconnor> let introduces bindings
13:20:20 <fax> matt_m, yeah it will never pick a type arbitrarily, it tries for the most general possible -- that's why you need to pin it down sometimes
13:20:20 <roconnor> so you can use where inside bindings inside let
13:20:44 <Kaidelong> I wrote it that way because it was the most "natural" way I guess
13:20:53 <roconnor> ya
13:20:55 <Kaidelong> didn't realize the syntax was invalid
13:21:14 <jmcarthur> here is what writing C is like: 1. Do something. 2. Handle errors. 3. Go to 1.
13:21:28 <EvanR-work> 2 is optional
13:21:32 <Kaidelong> yes
13:21:35 <Kaidelong> I was about to say
13:21:40 <The_third_man> http://img.lulz.net:8080/src/1244999366345.jpg
13:21:40 <Kaidelong> but not in Java
13:21:46 <EvanR-work> unless you want to go insane
13:21:52 <jmcarthur> 2 is only optional if nobody is paying you.
13:21:54 <Kaidelong> well, in Java, it is optional, but you still have to explicit about it
13:22:14 <Kaidelong> which leads to people just writing everything with "throws"
13:22:55 <Kaidelong> the_third_man: nice find
13:24:06 <Kaidelong> do you know who is in that picture?
13:24:29 <copumpkin> I'd hope so
13:25:18 <Kaidelong> Could you tell me?
13:25:23 <Kaidelong> I'm not terribly good with faces
13:25:31 <Kaidelong> or memorizing people and dates
13:26:09 <Philonous> Is there an easy way to add haddock documentation to arguments of a function created with c2hs' {# fun #} pragma ?
13:26:20 <fax> Kaidelong: It's the yguy  that wrote the C book
13:26:52 <fax> Kaidelong, http://en.wikipedia.org/wiki/File:Ken_n_dennis.jpg
13:43:38 <SonOfLilit> Hello
13:44:51 <SonOfLilit> I am trying to write cartesian :: [[a]] -> [[a]] so that e.g. cartesian [[1,2],[3,4],[5]] = [[1,3,5],[1,4,5],[2,3,5],[2,4,5]]
13:45:10 <copumpkin> > sequence [[1,2],[3,4],[5]]
13:45:11 <lambdabot>   [[1,3,5],[1,4,5],[2,3,5],[2,4,5]]
13:45:16 <SonOfLilit> profiling shows that my implementation is taking up a lot of memory
13:45:18 * copumpkin coughs
13:46:33 <SonOfLilit> so (a) is there a standard implementation (b) how do I go about implementing it?
13:46:39 <matt_m> lol
13:47:00 <copumpkin> :t sequence
13:47:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:47:05 <copumpkin> @src sequence
13:47:05 <lambdabot> sequence []     = return []
13:47:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:47:05 <lambdabot> --OR
13:47:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:47:10 <copumpkin> SonOfLilit: ^
13:47:18 <copumpkin> not only is it standard, but it isn't specific to lists
13:47:27 <copumpkin> :t Control.Applicative.sequence
13:47:28 <lambdabot> Not in scope: `Control.Applicative.sequence'
13:47:41 <copumpkin> :t Data.Traversable.sequence
13:47:42 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
13:48:23 <fryguybob> @hoogle [[a]] -> [[a]]
13:48:23 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
13:48:24 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:48:24 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:49:03 <SonOfLilit> cool
13:49:14 <copumpkin> embrace the power of the list monad!!
13:49:17 <SonOfLilit> how would one go about finding all these standard functions?
13:49:25 <fryguybob> hoogle
13:49:28 <copumpkin> what fryguybob did
13:49:33 <copumpkin> and what he said
13:49:39 <fryguybob> :D
13:49:49 <andrewe> @src interact
13:49:49 <lambdabot> interact f = do s <- getContents; putStr (f s)
13:49:51 <SonOfLilit> I tried... I was looking for "[[a]]->[[a]]" and found many things but I think not this one
13:50:16 <copumpkin> well you need to understand the list monad to see why this works
13:50:58 <aavogt> @type Data.Traversable.sequenceA -- !!
13:50:59 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
13:52:57 <SonOfLilit> mmmm
13:53:05 <SonOfLilit> it changed the result of my program
13:53:16 <SonOfLilit> so either my implementation had a bug, or this one
13:53:26 <copumpkin> what's the difference between sequenceA and sequence in Data.Traversable?
13:53:28 <SonOfLilit> (it did speed it up by an order of magnitude, though)
13:53:37 <aavogt> copumpkin: Applicative vs Monad
13:53:39 <copumpkin> oh
13:53:42 <SonOfLilit> or this is not the same as my intention*
13:53:43 <copumpkin> fair enough
13:56:41 <SonOfLilit> seems like somewhere along the way before I came to ask questions I introduced some bug into my code :/ the tests fail
13:57:39 <copumpkin> at least you're testing
14:00:07 <bastl> Can a program check at runtime what packages are installed in GHC? and change behavior then?
14:00:27 <SonOfLilit> but I've lost the crucial point where I know *exactly* what change caused tests to fail, which is the best thing about testing
14:02:38 <fryguybob> Revision control to the rescue?
14:03:22 <EvanR-work> git bisect
14:03:39 <copumpkin> git trisect
14:04:19 <fryguybob> darcs trackdown?
14:04:23 <fax> git can't trisect
14:04:27 <fryguybob> hg bisect
14:04:31 <fax> its provably impossible
14:04:41 <EvanR-work> git unisect
14:04:52 <fryguybob> In general no, but for specific cases...
14:04:59 <copumpkin> git hangdrawandquarter
14:05:47 <SonOfLilit> I'm trying to shelve my changes in order to see if it was ok before them
14:05:57 <SonOfLilit> then I'll try to bring them in one by one
14:06:16 <jmcarthur> that's what git bisect is for
14:06:23 <jmcarthur> except it does one better by using binary search
14:06:38 <SonOfLilit> ah
14:06:43 <SonOfLilit> it's called stash, not shelve
14:06:50 <SonOfLilit> that's why I couldn't find the man page
14:06:55 <jmcarthur> heh
14:07:10 <jmcarthur> stash is only for working copy changes afaik
14:07:10 <SonOfLilit> I'm pretty sure the latest commit is still bug-free, so git bisect is irrelevant
14:07:15 <jmcarthur> ah okay
14:07:35 <jmcarthur> bug free :o
14:07:58 <copumpkin> prove it bug-free
14:08:29 <SonOfLilit> free from that specific bug*
14:08:49 <SonOfLilit> and... it indeed is
14:08:59 <SonOfLilit> now, to start reapplying my changes
14:15:47 <Philonous> bastl: Yes. You can call and parse the output of ghc-pkg list (if available).
14:15:50 * jmcarthur will write a haskell blog post tonight :o
14:16:29 <fax> about what???
14:16:30 <fax> link?
14:17:01 <djahandarie> If it is about how awesome I am, I approve.
14:17:05 <bastl> Philonous: simple and ugly :-) So there is no cool GHC.PKG module to access  the list ?
14:17:58 <Philonous> bastl None that I know of.
14:18:03 <copumpkin> jmcarthur: omg you haz blog?
14:18:12 <bastl> broken link : http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/GHC-Pack.html
14:18:43 <copumpkin> maybe try #ghc
14:19:34 <Philonous> bastl: Well, cabal has to have some code doing that. You might dig into the repo and look how they handle it.
14:20:55 <Philonous> bastl: But to my knowledge they are calling ghc-pkg dump
14:22:01 <bastl> Philonous: see Distribution.Simple.Program.HcPkg
14:23:15 <Philonous> bastl: Nice.
14:23:25 <bastl> Ah, and once again, i would like to learn how a function used elsewhere: give me all references to HcPkg.dump inside package cabal.
14:23:33 <bastl> *is used
14:27:41 <cocon> > quickCheckResult $ Test.QuickCheck.label "blah" (\_ -> False)
14:27:42 <lambdabot>   Not in scope: `quickCheckResult'Not in scope: `Test.QuickCheck.label'
14:27:43 <Polarina> I got this expression "2^2^2^2^2^2^2", which is very huge, but I only need the result modulus 'n' (n being somewhat small) -- how do I optimize this thing?
14:28:21 <cocon> quickCheck seems to ignore labels... am I doing sth wrong?
14:28:48 <mle> Polarina: perhaps define a function that does the ^ operation with a modulus?
14:29:00 <fax> Polarina, a^b `mod` m = a^(b `mod` m) `mod` m
14:29:10 <fax> you can use that to implement mles suggestion
14:29:22 <EvanR-work> :t flip evalRand g . mapM id
14:29:23 <lambdabot> forall a b. (RandomGen a, SimpleReflect.FromExpr a) => [Rand a b] -> [b]
14:29:32 <fax> even do it as a num instance witha type tag that says mod which m
14:29:56 <Polarina> fax, how do I use that for the entire sequence?
14:30:04 <fax> it's obvious
14:30:06 <EvanR-work> how do i dot this correctly, flip evalRand g (mapM foo _)
14:30:17 <EvanR-work> i want to be able to . stuff so the result goes in the _
14:30:18 <Polarina> fax, I don't see it. :(
14:30:24 <fax> > 2^2^2^2^2^2^2 :: Expr
14:30:29 <lambdabot>   mueval: ExitFailure 1
14:30:32 <fax> > 2^2^2^x^2^2^2 :: Expr
14:30:36 <fax> :/
14:30:38 <lambdabot>   mueval: ExitFailure 1
14:30:43 <fax> > x^x^x^x^x
14:30:47 <lambdabot>   mueval-core: Time limit exceeded
14:30:52 <mle> heh.
14:30:52 <fax> what is wrong with this thing?
14:31:16 <mle> fax: insert 25 cents
14:31:18 <fax> hehe
14:31:20 <Polarina> fax, I think I figured it out. :)
14:31:22 <Skiy> What is a good reason to learn haskell?
14:31:38 <Philonous> Skiy: You don't have to learn java
14:31:43 <Polarina> Skiy, functional programming.
14:31:43 <mle> Skiy: any language that makes you think about a problem differently is worth learning.
14:32:00 <mle> Using is more complicated.
14:32:22 <matt_m> Skiy:  I think that's the converse of a true statement
14:32:29 <matt_m> err mle
14:32:30 <matt_m> I mean
14:33:16 <mle> i'm in ur proof, inverting ur causality.
14:33:39 <Polarina> > 2^10243 `mod` 497
14:33:40 <lambdabot>   100
14:33:42 <Polarina> > 2^(10243 `mod` 497) `mod` 497
14:33:43 <lambdabot>   29
14:33:54 <fax> > (2^10243) `mod` 497
14:33:55 <lambdabot>   100
14:34:51 <copumpkin> preflex: seen mmorrow
14:34:51 <preflex>  mmorrow was last seen on #ghc 100 days, 18 hours, 37 minutes and 5 seconds ago, saying: * mmorrow is rtfm'ing
14:34:57 <copumpkin> preflex: seen psykotic
14:34:57 <preflex>  psykotic was last seen on #haskell 21 days, 15 hours, 35 minutes and 35 seconds ago, saying: and getting better about comonads, but i was trying to see how this notion of 'comonad with zipping' could be crystalized
14:34:59 <fax> oh man I was completely wrong, that's embarassing
14:35:08 <Polarina> fax, hehe.
14:38:12 <fax> > let square x = let y = x `mod` 7 in y*y in ((square . square . square . square) 2, (2^2^2^2^2)`mod`7)
14:38:14 <lambdabot>   (16,2)
14:40:08 <mle> hmmmmmm
14:40:55 <gio123> ?
14:47:07 <ksf> huh? no listlike instance for Maybe?
14:47:53 <copumpkin> what's listlike?
14:48:24 <ksf> http://hackage.haskell.org/packages/archive/ListLike/1.0.1/doc/html/Data-ListLike.html
14:48:45 <ksf> yet another typeclass to fix haskell
14:49:14 <Polarina> fax, having any luck? :)
14:49:34 <fax> I already solved it
14:49:59 <Polarina> fax, what's your solution?
14:50:01 <fax> for x^k you just pick large as possible p+q = k, then (x^p)*(x^q)
14:50:23 <fax> so it splits the big tower down into a tree of exponenets, which you can collapse down on the way up
14:50:35 <Polarina> Hmm...
14:50:36 <BMeph> Polarina: The solution is, just do the mod, Haskell will do you right. :)
14:51:07 <fax> Polarina, im really glad you brought this up because I won't forget that a^b`mod`m is NOT a^(b`mod`m)`mod`m in a hurry
14:51:52 <BMeph> > 12345^54321 `mod` 393381
14:51:53 <lambdabot>   121824
14:52:12 <BMeph> ...that's right! :O
14:52:19 <Polarina> BMeph, it does not.
14:52:27 <Polarina> BMeph, not for very large values.
14:53:33 <BMeph> Polarina: Ah, but for large values of a, b or k? :)
14:53:55 <Polarina> BMeph, a number that big that it won't fit in my 8 GiB RAM.
14:53:58 <copumpkin> it's probably worst for large values of b
14:54:46 <BMeph> compumpkin: I'd've thought it's worse for large values of k, since you can factor b, if necessary. :)
14:55:24 <copumpkin> well, the current situation was what we're talking about
15:04:48 <saml> yo man. given a list of digits, find A/B that is closest to pi. for example, "12345" ==> 42513/13524
15:04:54 <saml> > 42513/13524
15:04:55 <lambdabot>   3.143522626441881
15:05:03 <saml> do it!
15:05:12 <fax> hm, how?
15:05:21 <SubStack> oh there is a nifty trick for that
15:05:25 <SubStack> but I'm not telling
15:05:32 <saml> tell me. it's my interview question
15:05:34 <saml> i need a job
15:05:40 <fax> I want that job
15:05:45 <saml> no me
15:05:48 <copumpkin> seems questionable to ask us
15:05:57 <fax> I would like a job where you just get given stupid excersices like this, indefinietely
15:05:59 * SubStack applies to the job just to make saml look bad
15:06:05 <saml> oh crap i was applying for copumpkin's company
15:06:11 <copumpkin> :)
15:06:12 * fax is gonna time myself solving this
15:06:22 * saml asks in 4chan
15:06:23 <SubStack> readysetgo
15:06:40 <saml> SubStack: is it bit twiddling trick?
15:06:42 <Botje> saml: generate all permutations of 12345, then check all combinations?
15:06:44 <SubStack> negatory
15:06:56 <SubStack> bits are rarely twiddled in haskell
15:06:58 <copumpkin> seems silly to generate all permutations
15:06:59 <saml> Botje: nah... 10! is huge
15:07:02 <fax> saml: is there ever zeros in it?
15:07:11 <[swift]1> well it looks like the number of digits in the numerator and denominator is fixed..
15:07:17 <saml> fax: no idea
15:07:17 <Botje> saml: uh, you only need (5!)^2
15:07:22 <Botje> hardly "huge"
15:07:22 <fax> saml:.... ask
15:07:31 <Skiy> use an evolutionary algorithm to find a good solution for a and b
15:07:34 <SubStack> oh hah this is easier than I guessed
15:07:40 <[swift]1> this looks like a pretty simple dynamic programming problem
15:07:55 <Botje> saml: also, the first digits for numerator and denominator will always be 4 and 1
15:08:10 <fax> Botje :|
15:08:13 <saml> Botje: no.. what if input was "12"
15:08:22 <fax> I'm strill working on this don't ruin it guys
15:08:24 <Philonous> Botje: Well, if 4 or one are not in the list of digits?
15:08:24 <saml> > 21/12
15:08:25 <lambdabot>   1.75
15:08:30 <burp> minimization problem
15:08:42 <saml> let me do it myself
15:08:56 <Botje> Philonous: in this case, it is
15:08:57 <[swift]1> i really want to do it but i have to work to do dammit =)
15:09:05 <Skiy> why ask then
15:09:10 <saml> > pi
15:09:11 <lambdabot>   3.141592653589793
15:10:07 <pgs31> Evening folks
15:10:11 <Cale> hey
15:10:20 <saml> > let a / b = pi; f l = l / l in f "12345"
15:10:21 <lambdabot>   3.141592653589793
15:10:24 <saml> win
15:10:48 <jmcarthur> haha
15:10:58 <pgs31> I am after a bit of advice.. My real problem is a bit fiddly and involves the Get monad and a large file
15:11:05 <pgs31> but I think I can distill it down
15:11:24 <pgs31> If I say: main = do main
15:11:33 <pgs31> then I get a stack overflow, fair enough
15:11:44 <benmachine> if you optimise enough you might not
15:11:46 <pgs31> Is there a way to write moadic code like that in an iterative way?
15:11:46 <gio123> Cale: oj
15:11:56 <benmachine> hold on
15:11:58 <Cale> pgs31: hm?
15:12:02 <benmachine> main = main shouldn't stack overflow
15:12:08 <benmachine> it should just infinite loop
15:12:26 <jmcarthur> @undo do main
15:12:26 <lambdabot> main
15:12:45 <Cale> In fact, it should block with no CPU usage or say <<loop>>
15:12:59 <pgs31> ahh yes
15:13:06 <pgs31> I have a returns () at the end
15:13:12 <jmcarthur> aha
15:13:14 <benmachine> why no CPU usage?
15:13:18 <aavogt> it won't block if you use the threaded rts...
15:13:25 <Cale> benmachine: because it'll hit a blackhole
15:13:26 <copumpkin> no memory allocation
15:13:40 <benmachine> hmm ok
15:13:46 <Cale> benmachine: and the blackhole in the threaded runtime blocks and waits for the value to be evaluated
15:13:55 <jmcarthur> pgs31: forever (return ()) might fare better
15:13:59 <Cale> (in case it was just being evaluated in another thread)
15:14:00 <aavogt> to find the blackhole you must first find the blackhole
15:14:06 <benmachine> I just put 'main = main' in a file and runhaskelled it
15:14:10 <benmachine> it blocked
15:14:13 <copumpkin> > let blackhole = blackhole in blackhole
15:14:16 <Cale> yep, threaded runtime
15:14:17 <lambdabot>   mueval-core: Time limit exceeded
15:14:24 <benmachine> 'k
15:14:47 <pgs31> jmcarthur: yes, in this case - but what I am really trying to do is write a Get monadic function to parse a big file
15:15:05 <pgs31> jmcarthur: and it stack-overflows because it's recursing into itself
15:15:27 <jmcarthur> pgs31: if you wrote it the way you wrote that main function then i'm not surprised
15:15:41 <pgs31> jmcarthur: I'm still learnin'
15:15:48 <jmcarthur> pgs31: what do you expect it to do when you say  main = main >> return ()  ?
15:16:06 <jmcarthur> pgs31: if i know what you are expecting then i might be able to explain why it's not doing what you expect
15:16:32 <pgs31> jmcarthur: http://pastebin.com/J9Tcy7n8
15:16:43 <jmcarthur> pgs31: actually, i'll try something a bit easier to talk about:  main = main >> putStrLn "foo"
15:16:57 <jmcarthur> pgs31: do you see why that will never print "foo"?
15:17:09 <pgs31> jmcarthur: I expected it to stack overflow, but I was wondering how you write monadic functions (if that is the right term) which are iterative, not recursive
15:17:25 <pgs31> jmcarthur: yes, that makes perfect sense :)
15:17:25 <jmcarthur> :t iterateM
15:17:26 <lambdabot> Not in scope: `iterateM'
15:17:30 <jmcarthur> eh was worth a shot
15:17:33 <Cale> pgs31: There's no real difference between iterative and recursive.
15:17:41 <Cale> pgs31: It's just how you look at things.
15:18:04 <jmcarthur> pgs31: what's happening is you are expecting a result before you return anything
15:18:11 <pgs31> Cale: How do you mean? I mean, I want it not to use a new stack frame each time..
15:18:26 <Cale> pgs31: The stack doesn't even mean what it means in a strict evaluator anyway
15:18:41 * pgs31 rubs his head
15:19:05 <Cale> The stack basically consists of pattern matches which are waiting for the thing which they're matching against to be evaluated enough.
15:19:19 <daviddarais> pgs31: recursion that is really iteration will be turned into a loop that does not use stack frames by the compiler
15:20:13 <pgs31> daviddarais: I get that part, tail recursion right? I understand it in terms of pure functions.. but I don't see how to apply that in a 'do' block
15:20:30 <Cale> btw, that code also won't stack overflow if you add -O
15:20:33 <Cale> (or -O2)
15:20:47 <pgs31> Cale: Clever haskell magic :)
15:20:50 <Cale> It's not *really* about tail recursion either.
15:20:56 <daviddarais> pgs31: if you are looking for something like a for loop look at forM
15:21:00 <daviddarais> :t forM
15:21:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
15:21:33 <pgs31> daviddarais: that looks promising, along with iterateM as jmcarthur mentioned
15:21:39 <benmachine> pgs31: keep in mind that 'do' isn't magic
15:21:50 <Cale> The stack is not really related to evaluation in the same way that you're used to, and stack overflows basically indicate a problem where you have pattern matches that are nested too deeply.
15:21:53 <daviddarais> yeah, i think there is also sequenceM
15:21:55 <daviddarais> :t sequenceM
15:21:55 <lambdabot> Not in scope: `sequenceM'
15:21:58 <daviddarais> :t sequence
15:21:59 <benmachine> er
15:21:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:21:59 <saml> yo, is there rational number type?
15:22:04 <benmachine> saml: there is
15:22:08 <benmachine> it's called Rational :)
15:22:10 <saml> > 1/2+1/2
15:22:11 <lambdabot>   1.0
15:22:13 <Cale> (in this case, it's a little hard to explain what's going on, because it's inside the particular implementation of the IO monad in GHC)
15:22:14 <gwern> benmachine: lies!
15:22:15 <daviddarais> but for looping, you really need to just use tail calls
15:22:17 <gwern> @hoogle Rational
15:22:18 <saml> can it be 1/1 or 2/2 ?
15:22:18 <lambdabot> Prelude type Rational = Ratio Integer
15:22:18 <lambdabot> Data.Ratio type Rational = Ratio Integer
15:22:18 <lambdabot> Text.PrettyPrint.HughesPJ rational :: Rational -> Doc
15:22:26 <gwern> benmachine even got to lambdabot!
15:22:27 <saml> i mean, rational literal
15:22:27 <pgs31> benmachine: syntactic sugar for << and <<= right
15:22:33 * gwern doesn't know who to trust any more
15:22:35 <benmachine> pgs31: >> and >>= but yeah
15:22:39 <saml> > Ratio 1 2 + Ratio 1 2
15:22:40 <lambdabot>   Not in scope: data constructor `Ratio'Not in scope: data constructor `Ratio'
15:22:52 <jmcarthur> untilEmpty m = isEmpty >>= \e -> if e then return [] else liftM2 (:) m (untilEmpty m); getCurve = untilEmpty $ liftA2 (,) getFloat64le getFloat64le
15:23:02 <jmcarthur> ^^ off the top of my head, so might not work as i expect
15:23:11 <jmcarthur> pgs31: ^^
15:23:21 <fax> this is difficult
15:23:32 <jmcarthur> > 1%2 + 1%2  -- saml
15:23:33 <lambdabot>   1 % 1
15:23:58 <pgs31> jmcarthur: ooh. I don't understand that at all, but I will go and look up liftM2 and liftA2
15:24:10 <saml> jmcarthur: is this new addition? do i need to import something?
15:24:11 <jmcarthur> pgs31: oh i didn't mean to use both. they are the same thing, basically
15:24:16 <jmcarthur> saml: Data.Ratio
15:24:30 <pgs31> jmcarthur: thanks :)
15:24:36 <saml> jmcarthur: oh tahnksdfadafa versy much you are so cool
15:24:36 <jmcarthur> @src liftM2
15:24:36 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:24:39 <jmcarthur> pgs31: ^^
15:24:54 <pgs31> Cheers guys, I have enough ammunition for an evenings musing now ;)
15:24:54 <jmcarthur> saml: i know :)
15:25:23 <jmcarthur> > 1.2 :: Rational
15:25:24 <lambdabot>   6 % 5
15:25:28 <jmcarthur> saml: ^^
15:25:35 <jmcarthur> that works too
15:25:40 <lispy> > 3.14159 :: Rational
15:25:41 <lambdabot>   314159 % 100000
15:25:49 <lispy> > 22/7
15:25:50 <lambdabot>   3.142857142857143
15:26:06 <jmcarthur> > 22/7 :: Rational
15:26:06 <lambdabot>   22 % 7
15:28:24 <jmcarthur> are there free monad transformers? it just occurred to me
15:29:09 <benmachine> is there an IdentityT
15:29:33 <zark4711> ¡
15:29:37 <Cale> benmachine: It conceptually exists, but I don't think the mtl defines it
15:29:37 <jmcarthur> i'm going to guess free monad transformers don't exist, because nothing works out so cleanly, but of course that's not sound logic ;)
15:30:00 <fax> urgh I have to impnlement subtraction with carry
15:30:11 <jmcarthur> or rather it's not a good assumption
15:30:28 <saml> how do you do combinations?
15:30:35 <jmcarthur> combinations?
15:30:44 <benmachine> Cale: it would be *completely* redundant, right? :P
15:30:46 <jmcarthur> of what?
15:30:48 <BMeph> jmcarthur: Act now! Offer good while supplies last - operators are standing by! Here's how to order... ;þ
15:31:00 <saml> f "12" "ab" ==>  ["1a", "1b", "2a", "2b"]
15:31:07 <saml> is this called combination of two lists?
15:31:14 <Cale> benmachine: Sort of.
15:31:29 <Cale> benmachine: Unless we start working on monad transformer transformers
15:31:33 <benmachine> o_o
15:31:36 <saml> or nested for loop (or map)
15:31:39 <Claudius1aximus> > liftM2 "12" "ab"
15:31:39 <lambdabot>   Couldn't match expected type `a1 -> a2 -> r'
15:31:40 <lambdabot>         against inferred type ...
15:31:44 * benmachine melts
15:31:44 <Cale> saml: cartesian product
15:31:45 <Claudius1aximus> oops
15:31:53 <eugene_> how can i have a list that represents incremental evaluation of infinite fraction?
15:31:54 <Cale> > sequence ["12", "ab"]
15:31:55 <lambdabot>   ["1a","1b","2a","2b"]
15:31:59 <eugene_> like phi for example
15:32:15 <Cale> eugene_: A list of rationals?
15:32:26 <benmachine> is this the sort of thing that mapAccumR is for
15:32:49 <benmachine> I've never used it but I have a vague idea it's like iterate only more so
15:32:55 <eugene_> benmachine: may i have an example for phi?
15:32:57 <siracusa> :t mapAccumR
15:32:57 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:33:03 <benmachine> hmm
15:33:24 <benmachine> eugene_: no because I don't know how to use it and it's probably wrong anyway, I think I mean unfoldr which I can use
15:33:40 <eugene_> anything
15:33:48 <SonOfLilit> I'm looking for a sort of tracer for my haskell debugging
15:34:07 <SonOfLilit> hat seems about right, but very old
15:34:07 <lispy> SonOfLilit: ghci has a debugger
15:34:17 <benmachine> > unfoldr (\b -> let a = 1 + recip b in Just (a, a)) 1
15:34:18 <lambdabot>   [2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.619047619047619,...
15:34:21 <eugene_> i have a hard time wrapping my head around that without having to reevaluate the whole thing on each iteration
15:34:31 <benmachine> > unfoldr (\b -> let a = 1 + recip b in Just (a, a)) (1 % 0)
15:34:31 <lambdabot>   [*Exception: Ratio.%: zero denominator
15:34:32 <Cale> eugene_: do you mean the golden ratio?
15:34:34 <benmachine> err oops
15:34:36 <benmachine> > unfoldr (\b -> let a = 1 + recip b in Just (a, a)) (1 % 1)
15:34:37 <lambdabot>   [2 % 1,3 % 2,5 % 3,8 % 5,13 % 8,21 % 13,34 % 21,55 % 34,89 % 55,144 % 89,23...
15:34:42 <eugene_> Cale: yeah
15:34:54 <benmachine> whee fibonacci
15:34:55 <eugene_> :t recip
15:34:56 <lambdabot> forall a. (Fractional a) => a -> a
15:35:02 <BMeph> > let phi = 0%1:map(\(a%b)->(b%(a+b)) phi in take 10 phi
15:35:03 <lambdabot>   <no location info>: Parse error in pattern
15:35:07 <benmachine> recip x is just 1 / x
15:35:14 <lispy> :t recip
15:35:15 <lambdabot> forall a. (Fractional a) => a -> a
15:35:42 <Cale> @let newton f f' = iterate (\x -> x - f x / f' x)
15:35:44 <lambdabot>  Defined.
15:36:29 <lispy> > newton exp exp
15:36:33 <lambdabot>   mueval-core: Time limit exceeded
15:36:36 <Cale> > newton (\x -> x^2 - x - 1) (\x -> 2 x - 1) 1
15:36:36 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
15:36:36 <lambdabot>    arising from the literal `2' at <...
15:36:40 <Cale> err
15:36:46 <lispy> :t exp
15:36:46 <Cale> > newton (\x -> x^2 - x - 1) (\x -> 2*x - 1) 1
15:36:47 <lambdabot> forall a. (Floating a) => a -> a
15:36:47 <lambdabot>   [1.0,2.0,1.6666666666666667,1.619047619047619,1.618034447821682,1.618033988...
15:36:55 <benmachine> > unfoldr (pure . join (,) . (+1) . recip) (1 % 1)
15:36:56 <Cale> > newton (\x -> x^2 - x - 1) (\x -> 2*x - 1) 1 :: [Rational]
15:36:56 <lambdabot>   [2 % 1,3 % 2,5 % 3,8 % 5,13 % 8,21 % 13,34 % 21,55 % 34,89 % 55,144 % 89,23...
15:36:56 <lispy> > newton exp exp 1
15:36:57 <lambdabot>   [1 % 1,2 % 1,5 % 3,34 % 21,1597 % 987,3524578 % 2178309,17167680177565 % 10...
15:36:57 <lambdabot>   [1.0,0.0,-1.0,-2.0,-3.0,-4.0,-5.0,-6.0,-7.0,-8.0,-9.0,-10.0,-11.0,-12.0,-13...
15:37:22 <eugene_> dang, i feel the rust
15:37:26 <eugene_> :t iterate
15:37:26 <lambdabot> forall a. (a -> a) -> a -> [a]
15:37:28 <Cale> lispy: exp obviously doesn't have a root
15:37:53 <lispy> Cale: oh, right finding.  Duh.  *that* newton's method ;)
15:38:00 <lispy> er, root finding*
15:38:22 <saml> how do I find an element from a list that is closest to x
15:38:34 <Cale> > newton sin cos 3
15:38:35 <saml> f [1,2,3] 2.1 ==> 2
15:38:35 <lambdabot>   [3.0,3.142546543074278,3.141592653300477,3.141592653589793,3.14159265358979...
15:38:35 <benmachine> > let things = (1,1):map (\(a,b) -> (b,a+b)) things in map (uncurry (%)) things
15:38:36 <lambdabot>   [1 % 1,1 % 2,2 % 3,3 % 5,5 % 8,8 % 13,13 % 21,21 % 34,34 % 55,55 % 89,89 % ...
15:38:39 <lispy> saml: I don't know
15:38:42 <benmachine> oh whoops
15:38:46 <lispy> saml: what is x?
15:38:51 <eugene_> iterate seems like a perfect match for iterational evaluation :)
15:38:54 <lispy> saml: how do you measure distance?
15:38:58 <saml> lispy:    f   2.1  [1,2,3]  ==> 2
15:39:10 <benmachine> > let things = (1,1):map (\(a,b) -> (a+b,a)) things in map (uncurry (%)) things
15:39:11 <lambdabot>   [1 % 1,2 % 1,3 % 2,5 % 3,8 % 5,13 % 8,21 % 13,34 % 21,55 % 34,89 % 55,144 %...
15:39:20 * benmachine cheats slightly
15:39:43 <benmachine> > let things = (1,1):map (\(a,b) -> (a+b,a)) things in map (uncurry (/)) things
15:39:43 <lambdabot>   [1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619047619047...
15:39:45 <Cale> > minimumBy (comparing (\x -> abs (x-2.1))) [1,2,3]
15:39:45 <lambdabot>   2.0
15:40:09 <Cale> > minimumBy (comparing (\x -> abs (x-2.1))) [-10,5,20]
15:40:09 <lambdabot>   5.0
15:40:12 <saml> Cale:  thanks
15:40:34 <Cale> saml: You might just want to compute all the distances beforehand, and use those...
15:41:09 <Cale> > map snd . minimum . map (\x -> (abs (x-2.1), x)) $ [-10,5,20]
15:41:10 <lambdabot>   Couldn't match expected type `[(a, b)]'
15:41:10 <lambdabot>         against inferred type `(a1,...
15:41:22 <Cale> > snd . minimum . map (\x -> (abs (x-2.1), x)) $ [-10,5,20]
15:41:23 <lambdabot>   5.0
15:41:27 <saml> Cale: i fail to see difference
15:41:41 <Cale> saml: This way only computes the distance to 2.1 once for each element
15:41:45 <saml> does it optimize better with -O ?
15:41:58 <Cale> The other way computes them over and over, regardless of whether -O is turned on or not
15:42:10 <saml> Cale: ah!!!!!!!!!!!!!!! thanks
15:42:18 <benmachine> Cale: but if all you're doing is finding a minimum, you'd calculate it at most twice anyway right?
15:42:26 <benmachine> but I guess twice is more than once :P
15:42:33 <Cale> uhhh...
15:42:40 <Cale> Well, for the list of 3 elements only?
15:43:10 <Cale> I'm pretty sure you'd end up computing it once per element per comparison that that element is involved in
15:43:17 <djahandarie> I love when I stumble upon oleg's e-mails
15:43:19 <benmachine> no I mean you find the minimum of [a,b,c,d,e,f,g] by doing 6 comparisons
15:43:24 <djahandarie> http://www.haskell.org/pipermail/haskell/2004-November/014939.html
15:43:36 <benmachine> for example
15:43:48 <Cale> I suppose it's linear anyway, yeah
15:44:07 <benmachine> so it's not as important an optimisation as it might be for a sort
15:44:30 <benmachine> but could still be useful
15:45:46 <alpounet> anyone around willing to explain a bit what hidden markov models are ?
15:45:55 <alpounet> well, maybe more a topic for -blah
15:46:41 <eugene_> Cale: this is probably childs play for you.  how can you fix itarate?
15:46:55 <jlouis> computing them each time might be faster, given that the other solution does more memory handling
15:47:01 <copumpkin> > fix (interleave [0..])
15:47:02 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
15:47:51 <Cale> eugene_: Hm?
15:47:55 <SonOfLilit> I'm having a very hard time figuring how to work with the debugger
15:48:02 <Cale> eugene_: As in, find an element where it's reached a fixed point?
15:48:19 <eugene_> iterate is recursive
15:48:29 <Cale> eugene_: yes, it constructs an infinite list
15:48:31 <eugene_> fix is recursion abstraction
15:48:36 <benmachine> copumpkin: heh, neat
15:48:37 <Cale> okay
15:48:53 <benmachine> @. oeis run fix (interleave [0..])
15:48:54 <lambdabot>  Sequence not found.
15:48:56 <benmachine> :(
15:48:59 <Cale> fix iterate wouuld be ill-typed though
15:49:10 <eugene_> so how coul di use fix to implement iterate
15:49:14 <SonOfLilit> I have a function that gives the wrong results, and I want to figure out what it expands to
15:49:14 <Cale> oh!
15:49:28 <copumpkin> eugene_: fix can be used for anything that refers to itself, mechanically
15:49:30 <copumpkin> @src iterate
15:49:30 <lambdabot> iterate f x =  x : iterate f (f x)
15:49:44 <copumpkin> :t fix (\iterate f x -> x : iterate f (f x))
15:49:45 <Cale> fix (\iterate f x -> x : iterate f (f x))
15:49:45 <lambdabot> forall a. (a -> a) -> a -> [a]
15:49:52 <copumpkin> :)
15:50:08 <benmachine> replace = with -> and the beginning of the line with \
15:50:17 <eugene_> lol
15:50:19 <eugene_> ok
15:50:24 <copumpkin> it really is that simple
15:50:33 <benmachine> uh, with fix \
15:50:39 <copumpkin> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:50:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:50:49 <sshc> \la
15:50:56 <copumpkin> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
15:50:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:51:47 <siracusa> What extension must be enabled to write things like `:t head ?t' ?
15:51:59 <copumpkin> ImplicitParameters
15:51:59 <copumpkin> I think
15:52:02 * hackagebot happstack-facebook 0.21 - A package for building Facebook applications using Happstack  http://hackage.haskell.org/package/happstack-facebook-0.21 (JeremyShaw)
15:53:01 <siracusa> How do you you activate them in GHCI, it complains on :set -XImplicitParameters
15:53:08 <eugene_> thanks guys. #haskell is amazing as always!
15:53:18 <copumpkin> maybe ImplicitArguments
15:53:34 <copumpkin> ImplicitParams
15:53:36 <copumpkin> oh, of course
15:53:43 <benmachine> :set does tab-completion :)
15:53:45 <copumpkin> everything is spelled out except for some things
15:53:59 <benmachine> ghci> :set -XImplicitP
15:54:00 <benmachine> -XImplicitParams   -XImplicitPrelude
15:54:04 <siracusa> Ah
15:54:32 * benmachine should start putting LANGUAGE ImplicitPrelude, MonomorphismRestriction at the top of his files just to confuse people
15:54:38 <benmachine> or NoOverlappingInstances :P
15:54:56 <lispy> heh
15:55:09 <lispy> benmachine: it makes some sense in terms of future proofing, actually
15:55:15 <lispy> State your assumptions
15:55:34 <benmachine> kiiiinda
15:56:02 <benmachine> but I'd think LANGUAGE pragmas are more liable to change than the language itself
15:56:30 <eugene_> i have hard time understanding fix (again).  how can it work?
15:56:31 * benmachine wonders if -XNPlusKPatterns will continue to be supported
15:57:13 <Saizan> eugene_: seen this? http://www.vex.net/~trebla/haskell/fix.xhtml
15:57:32 <eugene_> Saizan: no, reading now
15:57:47 <SonOfLilit> can anybody help me with the ghci debugger?
15:58:50 <copumpkin> preflex: seen edwardk
15:58:50 <preflex>  edwardk was last seen on #haskell 14 hours, 36 minutes and 32 seconds ago, saying: getting some sleep as well
16:01:08 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=fix+(\fibs+->+0+%3A+1+%3A+zipWith+(%2B)+fibs+(tail+fibs)) augh, my sharing is terrible
16:02:04 <benmachine> (also I think something more fundamental is going wrong there... x should be evaluated in the let, but whatever)
16:02:10 <benmachine> (recursive bindings are just hard, okay?)
16:04:52 <benmachine> I think that *is* a valid evaluation of zipWith, just a hideous one that no self-respecting haskell compiler would actually use
16:05:09 <fax> saml: 42513/13524
16:05:47 <Saizan> yeah, you're doing call-by-name instead of call-by-need
16:05:50 <saml> fax: haha i did too
16:05:52 <saml> let me paste
16:06:28 <benmachine> Saizan: I think it's supposed to try to call by need, it just fails hard with recursive bindings
16:06:51 <benmachine> or, something.
16:07:05 <fax> this is too hard, I can't write an efficent program for this
16:07:12 <Saizan> benmachine: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+double+x+%3D+x+%2B+x+in+double+(double+5)
16:07:15 <fax> I got something workinng eventually but its slow
16:07:22 <benmachine> Saizan: mm, but how about
16:07:26 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+x+%3D+10+%2B+10+in+x+%2B+x
16:07:28 <saml> ghc doesn't generate .exe when module name is not Main ?
16:07:47 <saml> i have module Shit  with main :: IO ()
16:08:15 <Saizan> benmachine: ah, so it's something in between :)
16:08:29 <jlouis> saml: check the -main-is parameter
16:08:34 <benmachine> Saizan: if you abuse it hard enough you can force sharing:
16:08:35 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+double+x+%3D+let+y+%3D+x+in+y+%2B+y+in+double+(double+10)
16:08:49 <benmachine> but that tends to actually end up taking more steps :P
16:09:40 <SonOfLilit> this function is my main bottleneck now: occurence year offsets = max 0 (year - maximum offsets)
16:09:49 <SonOfLilit> anyone have an idea how to optimize it?
16:10:04 <saml> jlouis: i can't find such flag from manual
16:10:25 <jlouis> saml: man ghc followed by /-main-is
16:11:25 <saml> ghc: on the commandline: unrecognised flag: -main-is
16:11:32 <saml> maybe that's for new ghc
16:11:57 <systemfault> :(
16:11:58 <Saizan> benmachine: hah! http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+double+x+%3D+(let+y+%3D+x+in+y+%2B+y)+in+double+(double+5)
16:12:00 <Cale> SonOfLilit: Compile with -O2?
16:12:03 <systemfault> Saizan: Reread.
16:12:07 <systemfault> Eww
16:12:09 <benmachine> Saizan: no it says that for me too if I don't give -main-is an argument
16:12:10 <[swift]1> lets say I have two values of the same type. is there a way to check whether the same data constructor was used for them both?
16:12:12 <systemfault> saml:
16:12:14 <saml> jlouis: thanks. ghc --make -O2 Shit -main-is Shit.main
16:12:29 <benmachine> err not Saizan
16:12:50 <benmachine> Saizan: oh, yes, I pasted something very similar to that moments before you fell off the internet :P
16:13:12 <Saizan> benmachine: suspected so
16:13:57 <saml> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25191#a25191    optimize this. when I run > Shit.exe 123456789, it's so slow!!!!
16:16:48 <eugene_> wondering if i can mutilate Perl enough to implement fix
16:17:16 <ddarius> eugene_: Sure.
16:17:38 <eugene_> ddarius: goto's?
16:18:14 <eugene_> or ->()->()->() and hope we dont hit the limit?
16:18:21 <ddarius> eugene_: Perl has higher order functions.  You can use the non-recursive definition of Y.
16:18:22 <jlouis> saml: isn't that 131681894400 operations?
16:19:21 <jlouis> Assuming you can do one billion operations per second, it will take 131 seconds
16:21:41 * benmachine wonders whether case let p = e in x of is equivalent to let p = e in case x of
16:22:38 <benmachine> I guess not because the latter extends the bindings in p over the branches
16:22:47 <benmachine> ho hum, this is difficult
16:23:01 <ddarius> benmachine: Well you can ask that saying that p is not free in the branches.
16:23:38 <benmachine> ddarius: I can and that might be interesting, but it won't help me fix my bug :)
16:23:46 <benmachine> (because I can't make that guarantee in my case)
16:24:06 <ddarius> I thought you were just wondering.  Of course, you can throw in an alpha-renaming.
16:24:41 <[swift]1> let me try this question one more time. say I have data A = B String | C String, and I have two values of type A. is there a way i can check whether they are both B's or both C's other than manually writing out a bunch of pattern matching code?
16:24:42 <benmachine> hmm that might be necessary
16:25:01 <benmachine> [swift]1: how much is a bunch? :)
16:25:27 <[swift]1> benmachine: to put it in perspective, there might in reality be like 70 data constructors for A (this is generated code)
16:25:30 <benmachine> > case (Left (), Right ()) of (Left _, Left _) -> True; (Right _, Right _) -> True; _ -> False
16:25:31 <lambdabot>   False
16:25:52 <lispy> [swift]1: oh, in that case you probably want to use generic programming.
16:25:59 <benmachine> oh that would be a good idea
16:26:10 <Saizan> [swift]1: generate the pattern matching too? :) however if you derive Data you'll be able to get a Constr out of a value, and you can compare those
16:26:18 <lispy> [swift]1: like maybe template haskell or maybe some specialized package like DrIFT
16:27:20 <[swift]1> Saizan: is getting a Constr an expensive operation?
16:27:53 <[swift]1> lispy: haha well I could generate the pattern matching but I hoped there was a simple, pre-made solution
16:27:56 <benmachine> [swift]1: I wouldn't have thought so
16:28:03 <benmachine> Data.Data.toConstr is a typeclass method
16:28:43 <benmachine> so it probably operates in the most obvious fashion, i.e. a giant case
16:29:00 <Saizan> yeah
16:29:19 <[swift]1> haha i see, so it basically does the same thing as the pattern matching code i would have generated myself
16:29:27 <[swift]1> excellent! that's a great timesaver
16:29:31 <benmachine> :)
16:29:36 <benmachine> <3 syb
16:30:03 <ddarius> While I haven't really used any too much, the approach of Uniplate appeals to me more.
16:30:21 <[swift]1> yeah, i just read the first SYB paper last Friday and it was a revelation; really impressed with its flexibility and simplicity
16:30:33 <[swift]1> i'll have to read the followup papers soon
16:31:09 <saml> fax:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25191
16:31:19 <benmachine> ddarius: like any good idea, generics seem to have been done like five times; never spent the time to work out which is best :P
16:31:46 <benmachine> there was a paper comparing them but who has time to read papers? apparently everyone except me.
16:32:01 <lispy> benmachine: I feel the same way
16:32:01 <ddarius> benmachine: Don't start it.  It's a bad habit.
16:32:02 <[swift]1> ddarius: found a paper on Uniplate on Neil Mitchell's site; I'll check it out
16:32:14 <[swift]1> benmachine: do you have a citation for the paper comparing them? i'd be interested
16:32:21 <lispy> I stopped keeping a queue of papers to read because it overflowed.
16:33:01 <benmachine> [swift]1: uh, let me do some digging
16:33:27 <[swift]1> i tend to go nuts reading papers about whatever new thing i'm playing with
16:33:32 <[swift]1> currently that's haskell =)
16:33:57 <benmachine> http://lambda-the-ultimate.org/node/1926#comment-23411 here we go
16:34:11 <benmachine> err, scroll up
16:34:41 <[swift]1> benmachine: cool, thanks!
16:35:29 <benmachine> [swift]1: I skimmed to the end where they had a pretty table, so I don't guarantee it's any use :)
16:35:48 <[swift]1> benmachine: wow, i just saw in the comments that its 75 pages. might be a skim for me too!
17:02:45 <eugene_> ddarius: man, implementing iterate to return a generator using Y combinator in Perl is about to induce epilepsy in me
17:05:13 <SonOfLilit> is there a short for zipWith (*) ?
17:07:00 <systemfault> SonOfLilit: Not really afaik
17:07:05 <systemfault> Why?
17:09:01 <ddarius> systemfault: Because two whole tokens is just too damn much.
17:11:27 <SonOfLilit> because I seem to be using it so much, a prettier name would register better in my mind
17:11:45 <SonOfLilit> is there a standard library function to calculate nCr?
17:16:20 <systemfault> Applicative is just for applying functions to contained data, right?
17:16:33 <systemfault> *Application Functors
17:16:46 <ddarius> Stop thinking of functors as "containers"
17:17:24 <systemfault> well :( I'm seeing "Just" and "IO" as container.. :(
17:17:30 <systemfault> How should I think?
17:18:02 <dolio> Think of them as arrows between categories.
17:18:04 <syntaxglitch> functors aren't containers, monads aren't about sequencing, and monoids aren't about appending no matter what the stupid Prelude says
17:18:11 <syntaxglitch> ...sorry, reflex
17:18:24 <ddarius> syntaxglitch: The Prelude says none of those things.
17:18:49 <zachk> then what does The Prelude utter?
17:18:49 <syntaxglitch> ddarius, what's the name for the monoid operation, again?
17:19:02 <dolio> Monoid isn't in Prelude.
17:19:04 <ddarius> syntaxglitch: Monoid isn't a class in the Prelude.
17:19:12 <syntaxglitch> ah, right
17:19:20 <syntaxglitch> should have said standard libraries, sorry
17:19:29 <systemfault> :/
17:19:44 <syntaxglitch> I stand by the point that mappend is a terrible name though
17:19:46 * systemfault wipes his C++ from his brain.
17:19:48 <isaacsu> hi i am interested to learn haskell. I have a background in basic php webapp programming. Is there a good tutorial that I can work along with? (please be nice)
17:19:59 <systemfault> isaacsu: http://learnyouahaskell.com
17:20:18 <syntaxglitch> isaacsu, or Real World Haskell
17:20:34 <systemfault> Real World Haskell is harder imho..
17:20:51 * DigitalKiwi has been reading haskell for c programmers
17:20:54 <isaacsu> thanks guys
17:21:37 <systemfault> DigitalKiwi: What?
17:21:37 <Boney> I'm doing some tutoring for a class that covers haskell.
17:21:37 <Boney> the perscripted text is RWH.
17:21:37 <DigitalKiwi> http://www.haskell.org/~pairwise/intro/intro.html
17:21:37 <isaacsu> i've found that many haskell tutorials to be quite heavy on theory, which I can appreciate. but I'd like to learn with more examples
17:21:40 <syntaxglitch> systemfault, perhaps, but I think it presents stuff in a way that's more conventional from the perspective of the mythical average programmer
17:21:43 <systemfault> DigitalKiwi: Isn't that stupid? I mean, the first thing you should do when learning Haskell is forgetting your imperative mindset.
17:21:57 <DigitalKiwi> i think that's kind of the idea...
17:21:58 <systemfault> DigitalKiwi: And I'm still trying :)
17:22:10 <DigitalKiwi> anyway whatever
17:22:16 <ahihi> I'd like a "C for Haskell programmers"
17:22:17 <DigitalKiwi> i don't want another freaking argument tonight
17:22:41 * DigitalKiwi just got trolled by some f-wit saying you can't have percentages over 100
17:24:05 <isaacsu> the reason i want to learn haskell is to leave imperative programming behind
17:24:05 <systemfault> DigitalKiwi: :(
17:24:05 <isaacsu> so to speak
17:24:05 <syntaxglitch> DigitalKiwi, the correct response is "well, most of the time 100 is the highest... but this one goes to 110"
17:24:05 <[swift]1> DigitalKiwi: frankly, lots of people don't understand percentages
17:24:05 <systemfault> isaacsu: Both learnyouahaskell and RWH are online :)
17:24:05 <systemfault> isaacsu: Pick one and start learning :)
17:24:17 <DigitalKiwi> on a related note, i have a 113.33% in fortran lab
17:24:17 <isaacsu> ok thanks systemfault
17:24:22 <isaacsu> and syntaxglitch
17:24:36 <systemfault> DigitalKiwi: Hmm... congratulations :/
17:24:40 <syntaxglitch> isaacsu, good luck and have fun
17:25:07 <syntaxglitch> isaacsu, also, if you have questions you may want to hit up Stack Overflow
17:25:27 <syntaxglitch> beginner-ish Haskell questions tend to get good answers very quickly on SO
17:25:46 <DigitalKiwi> is there a #haskell-nubs ?
17:27:06 <applicative> isaacu, I was Learn You a Haskell is great.  Check out the "antiquated" Gentle Introduction to Haskell, which dons was rightly praising or reddit/r/haskell the other day. It's quite straightforward at least mostly.   http://www.reddit.com/r/haskell/comments/bvyxq/a_gentle_introduction_to_haskell_postrhw_and_lyah/
17:27:38 * syntaxglitch sometimes wonders how Norman Ramsey finds time for his day job given how active he is on SO
17:27:43 <applicative> isaacu, sorry, slightly illiterate that.  The reddit link links to the document.
17:28:24 <DigitalKiwi> my inner grammer nazi just had a field day
17:29:06 <applicative> my inner grammar nazis were conquered by by my inner grammar red army.
17:29:19 <ddarius> Freakin' commies.
17:29:28 <DigitalKiwi> lmao
17:29:33 <systemfault> applicative: Sorry for the highlights...
17:29:46 <ddarius> systemfault: It's his fault for choosing that nick.
17:29:50 <systemfault> Yeah..
17:30:25 <DigitalKiwi> i just updated ghc and now i get a systemfault every few minutes in ghci :(
17:30:56 <systemfault> DigitalKiwi: Lawlz.
17:31:04 <applicative> ddarius, I'll choose a new one, it's ridiculous.  But what should it be, zygohisto...?
17:31:04 <syntaxglitch> I used to have my client set to highlight on just "syntax"
17:31:13 <syntaxglitch> hanging around in programming channels ended that one right quick
17:31:27 <idnar> syntaxglitch: haha
17:31:34 <DigitalKiwi> gives a new meaning to 'syntax highlighting' amirite?
17:31:37 <syntaxglitch> applicative, how about "monad"
17:31:41 <syntaxglitch> DigitalKiwi, >:(
17:31:41 <systemfault> Applicative question.. when should I use pure? :(
17:31:47 <DigitalKiwi> i lalwed
17:31:49 <systemfault> In the real world..
17:32:23 <systemfault> > (+) <$> [1..3] <*> [2]
17:32:24 <lambdabot>   [3,4,5]
17:32:25 <applicative> when one of the terms you would have put in idiom brackets is not 'lifted', of course.
17:32:31 <syntaxglitch> systemfault, are you asking for real or just pinging applicative again?
17:32:38 <systemfault> syntaxglitch: For real :(
17:32:39 <syntaxglitch> pure seems pretty self-explanatory just from the type :\
17:32:52 <DigitalKiwi> :|
17:32:55 <syntaxglitch> it's basically the same as return for monads, if that helps
17:33:16 <DigitalKiwi> :/
17:33:16 <systemfault> I'll continue reading :/
17:33:20 <DigitalKiwi> =D
17:33:32 <isaacsu> thanks applicative, I'll check it out
17:33:52 <DigitalKiwi> hrm time to leave
17:33:56 <DigitalKiwi> bai
17:33:57 <systemfault> See you
17:34:10 <DigitalKiwi> i hope my system doesn't
17:34:14 <DigitalKiwi> systemfault while i am gone
17:34:14 <DigitalKiwi> ;D
17:34:18 <syntaxglitch> i.e., "I have something of type X and a Functor F, this lets me turn my something into the equivalent something of type (F X)"
17:34:42 <applicative> > [(+),(*),(-),(^)] <*> [2,3,4] <*> pure 5
17:34:42 <lambdabot>   [7,8,9,10,15,20,-3,-2,-1,32,243,1024]
17:35:12 <applicative> > [(+),(*),(-),(^)] <*> pure 2 <*> [1..5]
17:35:13 <lambdabot>   [3,4,5,6,7,2,4,6,8,10,1,0,-1,-2,-3,2,4,8,16,32]
17:35:42 <applicative> > pure (+) <*> [2,3,4] <*> [1..5]
17:35:43 <lambdabot>   [3,4,5,6,7,4,5,6,7,8,5,6,7,8,9]
17:35:59 <systemfault> Ah, I see
17:36:09 <SonOfLilit> is there a standard library function to calculate nCr?
17:36:27 <applicative> >  [(+),(*),(-),(^)] <*> [2,3,4] <*>  [1..5]
17:36:28 <lambdabot>   [3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,2,4,6,8,10,3,6,9,12,15,4,8,12,16,20,1,0,-1,-...
17:36:54 <Saizan> SonOfLilit: no
17:37:00 <applicative> > [(+),(*),(-),(^)]  <*> pure 2 <*> pure 5
17:37:00 <lambdabot>   [7,10,-3,32]
17:37:43 <isaacsu> i've been following Erik Meijer's Functional Programming on channel9 MSDN. any of you seen that series before?
17:37:46 <applicative> systemfault, maybe that was overkill, but nothing makes me happier
17:38:00 <systemfault> applicative: :)
17:38:43 <applicative> isaacu, I watch some of it, it's a little slow, but I liked it.  The textbook he uses, Hutton, is good, but a bit textbookish....
17:39:49 <applicative> issacu, pardon my grammar red army again....
17:40:34 <isaacsu> applicative: it's nice to have someone talk you through it, than to read. especially for a topic that is quite difficult for me
17:41:25 <applicative> Hutton's primer has another defect that makes it non ideal for privarte students, namely, it uses the special typesetting of some of the standardly used 'operators' and buries the information how to type them = which wouldnt be a problem with a teacher
17:41:50 <applicative> I think in Meijer's case, this was straightened out on the website in discussions
17:42:07 <isaacsu> yup
17:42:49 <applicative> so the monadic bind (>>=) is printed all curly, which is fine, unless you dont know how to type it..
17:43:02 <syntaxglitch> applicative, by "how to type them" I assume you mean "enable GHC's unicode syntax and use codepoint entry", right?
17:43:21 <theorbtwo> syntaxglitch: That'd be one (silly) way to do it.
17:43:25 <applicative> is there a unicode for (++) and (>>=) as they typeset them?
17:43:37 <syntaxglitch> I'm not sure, actually
17:43:40 <applicative> you can use a real lamba, i know
17:43:54 <syntaxglitch> lambdas don't work in GHC :(
17:44:06 <theorbtwo> applicative: The fact that they were able to typeset them that way suggests that there probably is a unicode character for it.
17:44:17 <gwern> unicode has math-only lmabdas, iirc
17:44:28 <gwern> dunno if those are the ones UnicodeSyntax wants
17:44:37 <syntaxglitch> gwern, it does, and it's also a lowercase letter
17:44:38 <applicative> I'm not sure, I think its a LaTeX tradition.  They are using the literate haskell machinery.
17:45:29 <applicative> If you use whatever machinery it is, you type it the way we do, but it gets typeset all curly....
17:45:46 <syntaxglitch> not that lambda being a letter is an unsurmountable obstacle, but otherwise being a valid identifier repurposing it for syntax would do weird things to GHC's lexing/parsing I imagine
17:46:00 <theorbtwo> gwern: Doesn't seem to, though I suppose it's possible that the copy of the UCD this utility is using is out of date.
17:46:21 <theorbtwo> λ, Λ, and ƛ.
17:46:30 <theorbtwo> lowercase, uppercase, and lowercase with stroke.
17:46:51 <syntaxglitch> at any rate, GHC's unicode syntax doesn't include lamdbas
17:46:54 <syntaxglitch> which makes me sad :(
17:48:04 <tensorpudding> Emacs has a thing which can prettify your code to show \ as λ and -> as →
17:48:17 <Cale> There's a special symbolic lambda in unicode.
17:48:19 <syntaxglitch> I think there's something on hackage that defines synonyms for a bunch of standard functions using the appropriate unicode symbols, though
17:48:36 <tensorpudding> As in, it doesn't change things in the file, it just displays them differently.
17:49:02 <Cale> 𝜆
17:49:14 <mamalujo> but, it would be more elegant to support whatever unicode one can throw at the compiler directly..
17:49:26 <tensorpudding> Italic lambda?
17:49:39 <Cale> yeah, U+1D706 MATHEMATICAL ITALIC SMALL LAMDA
17:49:52 <syntaxglitch> Cale, I'm under the impression that the math lambda codepoint still counts as a letter
17:49:53 <tensorpudding> I looked it up using emacs describe-char
17:50:07 <Cale> There's also 𝛌  U+1D6CC MATHEMATICAL BOLD SMALL LAMDA
17:50:22 <tensorpudding> There seem to be a lot of mathy symbols there.
17:50:42 <theorbtwo> Ah.  I was searching for lambda, rather then lamda.
17:50:42 <idnar> why italics?
17:51:03 <tensorpudding> hmm, they even have fraktur
17:51:15 <Cale> Yeah, it's still in the "Letter" unicode category
17:51:22 <syntaxglitch> heh, there's actually a GHC ticket for it: http://hackage.haskell.org/trac/ghc/ticket/1102
17:51:27 <systemfault> tensorpudding: It doesn't work that well
17:51:54 <systemfault> tensorpudding: Because it messes up the code.
17:51:56 <Cale> But presumably people wanting to use Greek words for identifiers wouldn't have a problem with it being used as syntax.
17:52:04 <tensorpudding> 𝕮𝔞𝔩𝔢!
17:52:07 <Cale> heh
17:52:15 <tensorpudding> that takes a long time to enter
17:52:39 <Adamant> tensorpudding: what symbols were those
17:52:49 <tensorpudding> fraktur symbols
17:52:56 <Cale> 𝕱𝖗𝖆𝖐𝖙𝖚𝖗 𝖎𝖘 𝕬𝖜𝖊𝖘𝖔𝖒𝖊
17:53:01 <tensorpudding> :)
17:53:37 <Adamant> yah, I need to get coverage of that
17:53:42 <Cale> Heh, I should write an X-chat plugin to make all my text in Fraktur, all the time. People with no unicode support would hate me.
17:53:47 <Adamant> especially since I'm picking up bits of German.
17:53:57 <tensorpudding> > map ord "𝕱𝖗𝖆𝖐𝖙𝖚𝖗 𝖎𝖘 𝕬𝖜𝖊𝖘𝖔𝖒𝖊"
17:53:58 <lambdabot>   [120177,120215,120198,120208,120217,120218,120215,32,120206,120216,32,12017...
17:54:02 <Saizan> i can't see those :\
17:54:05 <Adamant> Cale: I have Unicode support and I would hate you until I get some fonts to support it :P
17:54:26 <tensorpudding> Blackletter has a historic appeal, but is terribly unreadable.
17:54:26 <Saizan> exactly.
17:54:31 <Adamant> apparently OS X doesn't support it out of the box or I don't have something enabled
17:54:32 <syntaxglitch> I can read it just fine, I say Cale should go for it
17:54:39 <Cale> The Fraktur S is clever, I like it: 𝕾
17:54:54 <tensorpudding> That's impossible to read at this point size as S
17:55:14 <syntaxglitch> hmm
17:55:28 <syntaxglitch> someone should hack lambdabot to use unicode syntax for printing Haskell code
17:55:31 <syntaxglitch> :D
17:55:35 <Cale> It sort of does the top and bottom of the S first, and then finishes up in the middle
17:55:35 <systemfault> I just got a "click" in my head for applicative :D
17:55:46 <systemfault> > (,,) <$> (+1) <*> (+2) <*> (+3) $ 10
17:55:46 <lambdabot>   (11,12,13)
17:56:14 <idnar> I have unicode support, but apparently I don't have fonts with those characters
17:56:25 <ddarius> Cale: People with Unicode fonts would hate you.
17:56:33 <idnar> I think I removed some fonts the other day, maybe I should put them back
17:56:33 <tensorpudding> they even have script capitals 𝒜
17:56:59 <Cale> Weird, at the point where "MATHEMATICAL SCRIPT CAPITAL B" would go, my character map says "<not assigned>"
17:57:24 <tensorpudding> ..mine too
17:57:30 <tensorpudding> althose there is a bold
17:57:30 <Cale> It seems like a random subset of the alphabet is missing there.
17:57:38 <tensorpudding> 𝓑
17:57:40 * syntaxglitch really should get back to boxing his stuff up
17:58:01 <Cale> 𝒜𝒞𝒟𝒢𝒥𝒦𝒩𝒪𝒫𝒬𝒮𝒯𝒰𝒱𝒲𝒳𝒴𝒵
17:58:19 <syntaxglitch> Cale, wow, that's even less readable than the fraktur was
17:58:38 <eugene_> no, it' snice
17:59:02 <Adamant> Cale: hit me with the fraktur again
17:59:09 <Cale> 𝕱𝖗𝖆𝖐𝖙𝖚𝖗 𝖎𝖘 𝕬𝖜𝖊𝖘𝖔𝖒𝖊
17:59:16 <Adamant> :(
17:59:20 <Cale> 𝓒𝓪𝓽𝓮𝓰𝓸𝓻𝔂 𝓣𝓱𝓮𝓸𝓻𝔂
17:59:24 <Adamant> font no work
17:59:35 <tensorpudding> Do they have calligraphic latin characters?
17:59:58 <Cale> 𝔉𝔯𝔞𝔨𝔱𝔲𝔯 𝔦𝔰 𝔄𝔴𝔢𝔰𝔬𝔪𝔢
18:00:00 <Adamant> they have the kitchen sink and the bathroom in Unicode
18:00:02 <Cale> How about that one?
18:00:11 <Cale> (it's non-bold Fraktur)
18:00:33 <Adamant> Cale: yeah, nothing. Imported a fraktur ttf into Font Book
18:00:40 <idnar> hmm, even unifont doesn't seem to have those characters
18:00:44 <idnar> I wonder what's up with that
18:00:47 <Cale> 𝔹𝕝𝕒𝕔𝕜𝕓𝕠𝕒𝕣𝕕 𝔹𝕠𝕝𝕕
18:01:29 <Adamant> I wonder how much space it would take up to have complete coverage for everything Unicode
18:01:33 <Adamant> font-wise
18:01:38 <idnar> oh, those are outside plan 0
18:01:40 <idnar> *plane
18:01:40 <eugene_> Consolas
18:01:56 <Mathnerd314> Adamant: couple of MB
18:02:01 <Cale> 𒀱 has to be a contender for one of the most complicated-to-draw unicode characters.
18:02:14 <Kaidelong> Cale I can't see that with this font
18:02:20 <Cale> 𒂭 also
18:02:27 <tensorpudding> I can't see either of those either.
18:02:32 <Adamant> Kaidelong: I think the idea is that you can't see it :P
18:02:32 <Cale> They're complicated cuneiform signs
18:02:37 <idnar>  MPH 2B Damase is a SuperUnicode font, including ranges in Plane 1 and
18:02:37 <idnar>  ranges added in the latest release of the Unicode standard (4.1).
18:02:40 <idnar> let's try that
18:02:45 <Adamant> ah, Babylonian
18:02:54 * syntaxglitch can't see the cuniform :(
18:03:13 <systemfault> Cuniform? Is that sexual in any way? :P
18:03:17 <tensorpudding> Let me apt-get search ttf-babylonian
18:03:19 <systemfault> (Stupid joke)
18:03:19 <Adamant> for when you've learned Latin, Greek, and Hebrew and want to REALLY get classical
18:03:23 * Cale actually downloaded and installed a font specifically for it :P
18:03:29 <syntaxglitch> systemfault, :(
18:03:56 <tensorpudding> Cale: which font?
18:04:03 <systemfault> I'm using irssi here and cannot see most of the unicode chars :(
18:04:18 <idnar> hmm, still no luck
18:04:23 <syntaxglitch> okay, enough unicode for me, I need to do something useful
18:04:40 <idnar> systemfault: your font probably just doesn't have the chars
18:04:49 <tensorpudding> Emacs seems to do automatic replacing if the current font doesn't support the character
18:04:57 <Adamant> once you're done smacking us with fonts we can't read, I would like to know what you installed :P
18:05:04 <systemfault> tensorpudding: Emacs does too much ;)
18:05:13 <Adamant> dammit, Emacs
18:05:25 <Adamant> </xkcd>
18:05:46 <idnar> hmm, MPH 2B Damase is supposed to have cuneiform
18:06:10 <tensorpudding> at least, that's how it seems to be able to view CJK glyphs even though my font only supports Latin+Greek+Cyrillic
18:06:25 <Cale> I forget where I got it, but the file is Akkadian.otf
18:06:26 * idnar gives up
18:07:23 <applicative> I see, you're right about the lambda, it's a unicode arrow that the "\x ->" allows
18:07:31 <eugene_> emacs: old programming language that teaches dynamic scoping to noobs, that is good for writing plaintext editors; and ide for that language.
18:09:27 <Cale> dynamic scope is such fail
18:09:46 <Cale> It's hard to believe that emacs has managed to preserve it all this time
18:11:06 <copumpkin> yeah
18:11:44 <Mathnerd314> well, it's sometimes useful
18:12:01 <Mathnerd314> (maybe)
18:12:09 <Adamant> Cale: behold the power of legacy
18:12:28 <Adamant> I'm not sure dynamic scope is always fail, but dynamic scope is the default is definitely fail.
18:14:03 <Adamant> although doesn't Perl technically have dynamic scope without the 'my' keyword added?
18:14:23 <gwern> I think a lot of emacs code must use dynamic scope; the one paper I saw on compiling elisp to common lisp didn't get very far and seemed to founder on that
18:14:45 <Adamant> and CL supports dynamic scope, too.
18:15:03 <gwern> oh? maybe it was scheme then
18:15:10 <gwern> I read this paper years and years ago
18:15:13 <Adamant> yeah
18:15:16 <gwern> early 2000s oorc
18:15:21 <Adamant> who knows, haven't read it
18:15:44 <theorbtwo> Adamant: Perl allows for dynamic scoping, with local.  It doesn't do dynamic scoping, but rather package scoping, if you simply don't use 'my'.  Also, it's pretty rare to actually do so, there's very few places where you actualy want dynamic scoping.
18:16:27 <Adamant> theorbtwo: yeah. I get confused because terms evolve
18:16:36 <gwern> maybe it was http://www-pu.informatik.uni-tuebingen.de/users/knauel/selc-ifl.pdf
18:16:42 <gwern> that elsip->scheme
18:16:51 <gwern> wonder if anyone has worked on common lisp -> scheme
18:18:53 <applicative> systemfault, my inner red army tells me dollar signs are in bad taste, why write
18:18:59 <applicative> > (,,) <$> (+1) <*> (+2) <*> (+3) $ 10
18:19:00 <lambdabot>   (11,12,13)
18:19:09 <applicative> when you could write
18:19:27 <applicative> > ( pure (,,) <*> (+1) <*> (+2) <*> (+3) ) 10  -- or
18:19:28 <lambdabot>   (11,12,13)
18:19:32 <copumpkin> eugh
18:19:36 <gwern> (,,) ???
18:19:42 <applicative> > let f = pure (,,) <*> (+1) <*> (+2) <*> (+3) in f 10
18:19:43 <lambdabot>   (11,12,13)
18:19:53 <applicative> ok, i'm going too far.
18:19:54 <theorbtwo> :t pure
18:19:55 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
18:20:04 <gwern> I think given code like that I would write the tuple manipulation directly...
18:21:18 <applicative> gwern, you monadologist.   you probably like 'ap' and 'liftM17' ...
18:21:41 <systemfault> You dislike the $s?
18:21:42 <gwern> liftM17 is doing what you need to do! no ridiculous abstractions like Applicative
18:21:49 <Mathnerd314> liftA17...
18:21:53 <gwern> say it clearly and once :)
18:22:12 <applicative> gwern, i knew that if we called you a monadologist, you'd sign right up.
18:22:36 <gwern> applicative: it sounds fun :(
18:22:36 * syntaxglitch wonders about liftM-16
18:22:40 <syntaxglitch> sounds dangerous
18:22:49 <Mathnerd314> > liftA3 (,,) (+1) (+2) (+3) $ 10
18:22:50 <lambdabot>   (11,12,13)
18:22:51 <gwern> syntaxglitch: it's just like liftM15 only more so
18:22:53 <applicative> i look forward to the paradise of idiom brackets
18:23:04 <Mathnerd314> ^ applicative
18:23:17 <gwern> the programmer's paradise will never come; the dialetical abstractionism method is inherently flawed!
18:24:12 <applicative> now one shall take me from the paradise that McBride and Eoss have made for me.
18:24:16 <applicative> Ross
18:24:36 <gwern> *noone
18:24:39 <applicative> to paraphrase David Hilber
18:24:53 <gwern> yes yes, no one shall take us from the paradise that Cantor has made for us
18:24:59 <applicative> man, i'm using two broken keyboards to make up for each other
18:24:59 <Mathnerd314> I forget... did anyone ever give an example of a non-applicative functor?
18:25:09 <gwern> of course, as FPers we very much disagree. intuitionism ftw
18:25:39 * syntaxglitch asserts the nonexistence of real numbers, infinite sets, and denies the law of excluded middle
18:25:53 <gwern> whatever we can meaningfully say, we can program! if you can't say it, you can't whistle it either.
18:26:11 <applicative> Oh my God, Ramsey too.
18:26:48 <gwern> ramsey?
18:26:51 <applicative> what's a functor instance that's not applicative.  i'm forgetting...
18:27:06 <applicative> F P Ramsey is your whistling source
18:28:25 <gwern> ah, ok. I thought it was anscombe
18:28:30 <gwern> (whups)
18:28:57 <applicative> Could be wrong, I think it's a review of Witt. Tractatus.
18:29:13 <Adamant> gwern: Ramsey has a theory, Anscombe has a posse.
18:29:27 <gwern> 'As Wittgenstein's friend and colleague Frank Ramsey put it,. "What we can't say we can't say, and we can't whistle it either."
18:30:34 <gwern> it's kind of interesting how the same idea pops up - finite concrete representations. I'm reading E.T. Jayne's _Probability Theory_ and he's already laid out his program's dismissal of all infinities which aren't the well-defined limit of a concrete process, which obviously has connections to intuitionism
18:32:09 * syntaxglitch likes expressing probabilities as logits precisely because it makes the infinites more obvious, and more obviously absurd
18:32:20 <gwern> (he's right, I think, infinities do seem to fuck up everything they touch)
18:32:58 <gwern> syntaxglitch: he hasn't covered logits yet, but I'm still bogged down in product and sum rules, so maybe later in
18:33:09 <Mathnerd314> infinities are figments of your imagination. there are only unbounded limits.
18:33:30 <syntaxglitch> gwern, it's just a non-linear mapping of probabilities onto the entire number line
18:34:00 <syntaxglitch> making the implicit infinities in probabilities of exactly 0 or 1 into actual infinities
18:34:06 <gwern> syntaxglitch: what's the point of that? you can just map right back onto the 0-1 interval
18:34:59 <applicative> is that what a 'logit' does?
18:35:45 <syntaxglitch> if memory serves me at any rate, I haven't touched statistics recently
18:35:46 <gwern> applicative: see http://en.wikipedia.org/wiki/Logit
18:35:49 <applicative> i see. found it.  seems kind of cool.
18:36:05 <gwern> syntaxglitch: I think statistics may be under-served in haskell. I found the probability monad to be pretty interesting
18:36:06 <syntaxglitch> it's also a logarithmic scale if memory serves me, so probabilities add instead of multiply
18:36:20 <syntaxglitch> yeah, that's something I've been meaning to get around to
18:36:38 <syntaxglitch> I've been wanting to tinker with Bayesian inference a bit
18:37:17 <gwern> personally, my thought is 'paul graham is famous in part for applying bayes to spam; what else practical would bayes be good for?
18:38:11 <syntaxglitch> it seems to make an excellent foundation for statistical AI techniques
18:38:35 <gwern> bah, that's meaningless. AI is whatever computers can't do really really well
18:38:42 <syntaxglitch> though just bayesian networks alone don't really get you very far, being either laughably incomplete or impossibly intractable to compute
18:38:45 <applicative> gwern, i was reading about the probability monad not long ago .. there were some amusing blog posts about it.  but the Hackage code that went with them doesnt compile anymore, of course
18:39:05 <gwern> applicative: really? just cabal bitrot? should be easy to fix
18:39:15 <syntaxglitch> yes yes, AI is the god of the gaps of computer science :P
18:39:23 <syntaxglitch> "computers can do that? really? okay, it isn't AI anymore"
18:39:28 <applicative> http://www.randomhacks.net/articles/2007/02/22/bayes-rule-and-drug-tests and company, yeah it's just bitrot
18:39:42 <gwern> mm, no repo
18:39:54 <applicative> i was looking into it, but it seems measures were taken to correct it before, somehow this complicated it further
18:39:56 <gwern> hate working on stuff which has no repo
18:40:26 <syntaxglitch> but in this case I meant AI in the sense of "findings ways for programs to handwave approximate solutions to intractable problems"
18:41:14 <syntaxglitch> and statistical inference seems to be a useful foundation for writing programs that can BS their way through a problem
18:41:47 <applicative> http://hackage.haskell.org/package/ProbabilityMonads-0.1.0  is the package
18:42:00 <gwern> as I said, no repo to darcs send in patches
18:42:57 <saml> haskell makes me hyper
18:43:06 <systemfault> Haskell++
18:43:06 <applicative> Illegal instance declaration for `BayesDist (MaybeT (Rand g)) etc. etc.
18:43:30 <gwern> wait, the blog post includes a link
18:43:31 <gwern> darcs get http://www.randomhacks.net/darcs/probability
18:44:58 <gwern> applicative: you didn't run into the flexibleinstances error?
18:44:59 <applicative> i see, so now I have to darcs send ...  once I figure out the cure
18:45:16 <applicative> Yes, that's the main error
18:45:31 <gwern> I bet just removing them fixes it
18:46:10 <applicative> I think I tried that, and then something else went wrong, I should study it again.  The posts are excellent, so it ought to be easy for people to install
18:46:14 <gwern> hm. orphan instances are left over
18:47:26 <gwern> applicative: it compiles and installs for me with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25193#a25193
18:47:27 * syntaxglitch kind of wishes "Martin" on Stack Overflow would try a little bit harder before posting the fourth question about what seems to be the same simple parsing program, probably homework
18:48:23 <thethirdmoose_> Hi, I'm just learning Haskell, and I'm trying to write a simple merge sort. I'm trying to take the first half of a list, so I'm using (drop (round ((length a)/5)) a) where a is the list
18:48:28 <thethirdmoose_> but Haskell is yelling at me
18:48:50 <gwern> > 15 `div` 5
18:48:50 <lambdabot>   3
18:48:55 <thethirdmoose_> Is there a better way to do this?
18:49:07 <gwern> :t 15 `div` 5
18:49:08 <lambdabot> forall t. (Integral t) => t
18:49:16 <gwern> :t 15 / 3
18:49:17 <lambdabot> forall t. (Fractional t) => t
18:49:37 <thethirdmoose_> ah, OK
18:49:46 <thethirdmoose_> so i need to cast it to an int?
18:49:48 <thethirdmoose_> or a float
18:50:15 <systemfault> thethirdmoose_: No cast.. use div
18:50:16 <syntaxglitch> thethirdmoose_, you might want to keep in mind that list operations are linear in the number of elements touched, by the way
18:50:26 <gwern> > 15 / 3
18:50:27 <lambdabot>   5.0
18:50:32 <thethirdmoose_> ah, got it
18:50:32 <syntaxglitch> thethirdmoose_, traversing half the list just to drop it seems wasteful...
18:50:47 <thethirdmoose_> oh, does Haskell use linked lists instead of arrays?
18:50:49 <idnar> syntaxglitch: homeworkoverflow?
18:50:51 <gwern> thethirdmoose_: yes
18:51:00 <syntaxglitch> yeah, think of it as a linked list
18:51:40 <idnar> @src []
18:51:40 <lambdabot> data [] a = [] | a : [a]
18:51:44 <thethirdmoose_> eh, this is just to see if I understand haskell, so I don't really care about performance right now
18:52:17 <gwern> @hoogle Int -> [a] -> ([a],[a])
18:52:17 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
18:52:17 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
18:52:17 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
18:52:38 <syntaxglitch> not misusing lists seems like an important part of understanding Haskell to me... just promise not to touch (!!), okay?
18:53:24 <gwern> applicative: did you send in a patch?
18:53:39 <thethirdmoose_> ah, cool, thanks
18:53:45 <thethirdmoose_> i knew there must be a better way!
18:54:01 * syntaxglitch would be happy to see (!!) taken out back and shot, or at least removed from the standard libraries
18:55:14 <gwern> thethirdmoose_: unfortunately, since lists can be infinite, they don't come with any non-O(n) way to get their length, so 'splitAt (length list) list' is better than your concoction but not much better
18:55:43 <gwern> thethirdmoose_: finite lists, if you were curious, are Data.Sequence; o(1) length/size
18:56:02 <thethirdmoose_> gwern, can you use those in the same ways as you use regular lists?
18:56:08 <gwern> thethirdmoose_: more or less
18:56:16 <applicative> gwern, yes, that works .. no i didn't send in a patch, I gave up too quickly I see.
18:56:34 <gwern> thethirdmoose_: Seqs are a different type, so a lot of common list operations won't be defined for a Seq, I don't think
18:56:59 <thethirdmoose_> ok
18:58:30 <gwern> (people use lists because they're more familiar and convenient, though I think often people are always using long finite lists and so ought to use Seq instead)
19:01:03 <gwern> applicative: ok, I sent in a patch. turns out I only needed to remove 2 instances
19:02:18 <applicative> gwern, yes, it compiled after I did two ...
19:03:10 <applicative> gwern, well, maybe I'll get back to studying Bayes' rule and drug testing etc.....
19:07:33 <applicative> gwern, I hope E Kidd is paying attention to darcs send, he seems to have moved on to other things, a frequent cause of Hackage bitrot
19:07:54 * Cale thinks that people use lists often because they are the reification of loops, and not just because there are so many nice operations on them.
19:08:28 <saml> i use list because they are garbage collected
19:10:07 <djahandarie> Finger trees are damn cool
19:10:20 <alpounet> djahandarie, definitely
19:10:36 <applicative> i use lists because of their handsome syntactic support, check out those list comprehensions for example,
19:10:37 <djahandarie> I make this comments every time they come up, but I stand by it!
19:10:45 <Veinor> I went to the finger trees talk but I got lost
19:11:13 <djahandarie> Finger trees talk?
19:11:17 <djahandarie> I don't go to any talks. :(
19:11:23 <djahandarie> Usually because there aren't any around my area
19:11:25 <LeNsTR> hey
19:11:25 <Veinor> there was one at MIT earlier this night
19:11:37 <Veinor> the boston area haskell thing
19:11:41 <djahandarie> Grr
19:11:50 <ddarius> djahandarie: Where are you?
19:11:54 <djahandarie> edwardk said he was going to let me know when that was going to happen
19:12:04 <djahandarie> ddarius, storrs, CT
19:12:18 <djahandarie> I go to University of Connecticut
19:12:31 <djahandarie> The Boston one isn't too far, but its still quite a drive/trainride
19:13:03 * Veinor nods
19:13:06 <applicative> what did you learn about fingertrees, or not quite learn
19:13:17 <ddarius> djahandarie: Better off than I.  I think the closest Haskell thing is several hundred miles from me if not over 1,000.
19:13:25 <Veinor> basic information about them
19:13:28 <djahandarie> Ouch. :[
19:14:41 <ddarius> Boston's a mere 2,076 miles.
19:15:11 <djahandarie> It's 86.7 here
19:15:24 <djahandarie> 103 if I avoid tolls
19:15:41 <djahandarie> Wouldn't make up for the lost gas though
19:17:42 <Lajla> Why is this channel larger than #linguistics? twey, do you know this?
19:18:34 <djahandarie> Well, this is the official Haskell channel... I don't think #linguistics holds any official status across the world for linguistics disucssion.
19:19:02 <Lajla> official as in, sactioned by what ever body writes the Haskell standard, djahandarie?
19:19:24 <djahandarie> I don't know to what degree it is official, but it is on the wiki
19:19:37 <djahandarie> http://www.haskell.org/haskellwiki/IRC_channel
19:20:09 <Lajla> How official is Haskell.org?
19:20:25 <djahandarie> Very official, that's where the standard is hosted.
19:22:18 <Lajla> djahandarie, ahhh, intriguing.
19:22:29 <ddarius> djahandarie: The online version of the Report being there isn't what makes it official.  Also, the online version of the Report isn't the official one.
19:22:37 <Lajla> I would stil on intuition guess that more people on the planet randomly join a channel named #linguistics, than #haskell, but I guess I'm wrong.
19:23:01 <Lajla> Two men are fighting about who's telling me the right info, how romantic. <3
19:23:03 <ddarius> Lajla: It's not a question of whether they join, it's a question of whether they stay.
19:23:23 <ddarius> Lajla: Also, there are no doubt other linguistics channels on other networks.
19:23:39 <applicative> djahandarie, surely the wiki is just trying to distract you; the really cool haskell IRC is #exherbo-haskell, obviously.
19:25:09 <Veinor> ex...herbo?
19:25:25 <djahandarie> Veinor, some linux distro
19:25:27 <applicative> yeah, i had to look it up.... it's a gentoo splinter group.
19:25:29 <Veinor> ah.
19:25:56 <applicative> i thought it was an obscure principality
19:26:09 <Lajla> ddarius, ahh, good point about the other networks.
19:32:23 <gwern> applicative: if he doesn't care, I can upload it for him
19:32:42 * gwern thinks the Principality of Exherbo would be a good name
19:38:02 <applicative> gwern, yes you should upload it if he doesn't care... the posts are really interesting and could be hit upon by ... a potential convert.  It'd be a drag if they had trouble with cabal installing the library.
19:40:59 <jbapple> @seen edwardk
19:41:00 <lambdabot> Unknown command, try @list
19:41:50 <jbapple> preflex: xseen edwardk
19:41:50 <preflex>  edwardk was last seen on freenode/#haskell 18 hours, 19 minutes and 32 seconds ago, saying: getting some sleep as well
19:42:14 <ddarius> preflex: help xseen
19:42:14 <preflex>  xseen NICK - report when a user has been seen (on any network)
19:42:22 <ddarius> preflex: help seen
19:42:22 <preflex>  seen NICK - report when a user has been seen
19:43:33 <Agnostos> quick question: is there any reason why the installer for the windows haskell install should fail under windows 7?
19:45:05 <Agnostos> if not, would anyone know what the path variable is meant to have added onto it?
19:48:16 <Olathe> Agnostos: How did it fail ? Like it installed and now ghc can't be found on the command line ?
19:49:02 <Agnostos> as in, it stalls on the "setting path" then just dies.  i.e. reverts the lot back.
19:51:41 <Agnostos> install works fine on a windows xp enviroronment I have. so in theory I can copy all the files over, make some shortcuts etc. but I'm not sure what the path variables will be since the xp machine doesn't like to play nice when it comes to environmental variables.
19:52:59 <Olathe> Agnostos: Ahh, OK.
19:53:06 <Olathe> Let me check.
19:53:27 <Agnostos> thanks in advance Olathe
19:53:59 <Olathe> It looks like it only needs the bin directory in the path.
19:54:31 <Agnostos> ahh, okays.
19:54:39 <Agnostos> will remember to add that when I get home. :)
19:55:32 <Olathe> Alright :)
19:56:23 <solrize> wow, i just noticed i can say   [foo | blah]  instead of     if blah then [foo] else []
19:56:58 <Olathe> Hmm...
19:57:13 <dark> gwern, i'm still to understand what's up with intuitionism and all those weaker logics. (i've only been introduced to classical logic, first order logic and very basic set theory)
20:00:15 <applicative> Agnostos, if you're a windows expert maybe you can make something of the discussion on the libraries list just before the last windows installer was released  http://old.nabble.com/Haskell-Platform-2010.1.0.0-Windows-installer-RC2-tt28054976.html  http://old.nabble.com/Haskell-Platform-2010.1.0.0-Windows-installer-RC3-tt28080284.html  path subtleties were much discussed
20:00:59 <Agnostos> applicative: not really an expert. just deal with it a lot more then I'd like to.
20:01:53 <applicative> Agnostos, I was just emphasizing my own cretinousness...
20:03:34 <Agnostos> cretinousness??? oh... complaining about something.  I follow now. :)
20:04:07 <applicative> If you have trouble figuring it out, try when one of the giant brains who knows about it is on, like dcoutts
20:07:16 <Agnostos> heh, we've got one of the brains at work with me. I'm attempting to learn something of haskell but it really hurts the brain when you come from a java/C environment.
20:28:26 <jmillikin> Does Haddock support linking to identifiers which haven't been imported? The docs at < http://www.haskell.org/haddock/doc/html/ch03s08.html#id289950 > suggest it does, but I can't get it to generate a link.
20:28:47 <jmillikin> eg, 'Prelude.foldl' should link to the Prelude function
20:41:41 * BMeph enjoys the serenade of crickets...
20:45:53 <agnokapathetic> are there any libraries for 3d geometry? im trying to figure out line, rectangle (rectangular prism) intersections in 3D
20:50:15 <iaefai> chromakode: I ended up using your icon outline to create a more monocoloured H icon for my editor: http://i.imgur.com/DF7tm.png
20:52:10 <jbapple> agnokapathetic: Have you checked http://hackage.haskell.org/packages/archive/pkg-list.html ?
20:55:37 <agnokapathetic> jbapple: yeah, i see Data,SG which has intersection functions for .TwoDim but not for  .ThreeDim :(
20:56:34 <jbapple> Have you ever uploaded a package to hackage before?
20:56:52 <jbapple> If not, now would be a great time to start! :-)
20:57:25 <jbapple> Well not "now" so much as "when you finish writing a line/rectangular-prism intersection library"
20:59:16 <agnokapathetic> egad's Jim I'm a doctor (English Major) not a computational geometrist! but, yes if I do get around to writing this i'll be sure to share... i wonder if any of the raytracers do anything similiar
20:59:57 <jbapple> Did you see: http://www.mail-archive.com/haskell@haskell.org/msg14360.html
21:00:26 <jbapple> actually, scratch that
21:00:29 <jbapple> it's really mangled
21:00:43 <jbapple> and it's not, as it seemed to promise, FFI bindings to the PPL
21:01:04 <jbapple> I think the parma library is quite popular
21:01:43 <jbapple> http://www.dinkla.net/fp/cglib.html
21:02:38 * BMeph likes himself some parma on linguine
21:08:26 <DigitalKiwi> To git@github.com:Kiwi/curlpaste.git e9861b8..7481f79  master -> master
21:08:30 <DigitalKiwi> err wrong window
21:08:31 <DigitalKiwi> sorry
21:20:10 <chromakode> iaefai, fantastic! looking good
21:20:20 <iaefai> chromakode: thank you
21:20:26 <iaefai> I wasn't sure of the colours I used though
21:21:12 <chromakode> iaefai, I would suggest a little gradient on the edges, and since you're on OSX, a reflection
21:22:02 <iaefai> chromakode: I don't think a reflection would look the best on this icon, and no dock icons that I know of use it. But I can probably do the gradient.
21:22:37 <chromakode> fair enough
21:25:58 <iaefai> Has anyone made a DSL similar to BASIC in concept that would allow the adaptation of a simple language to a graphics library I am going to be making?
21:28:33 <Olathe> iaefai: Someone made BASIC: http://hackage.haskell.org/package/BASIC
21:29:07 <iaefai> Olathe: nice
21:29:24 <Jafet> (Which BASIC?)
21:30:16 <Olathe> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
21:31:36 <Jafet> Mmm, Pascal-BASIC
21:31:38 <iaefai> Olathe: Anyone made a more practical language? Such as Pascal :p
21:31:49 <iaefai> Logo? :P
21:32:27 <DigitalKiwi> real programmers don't use pascal
21:32:43 <DigitalKiwi> http://www.pbm.com/~lindahl/real.programmers.html
21:33:44 <iaefai> DigitalKiwi: You are right, I should have said Modula-2
21:34:18 * DigitalKiwi knows fortran!
21:34:26 * DigitalKiwi is a real prgrammer
21:34:28 <DigitalKiwi> *nod*
21:34:41 <blackdog> DigitalKiwi bitches about fortran in #haskell, though
21:34:49 <tensorpudding> Real programmers use PL/I
21:34:49 <blackdog> i think this makes him a quiche-eater
21:34:53 <DigitalKiwi> :(
21:35:11 <iaefai> blackdog: don't dis the quiche
21:35:15 <DigitalKiwi> i more complain about the incredibly retarded assignment than fortan as a language
21:35:29 <Jafet> @faq can Haskell serve quiche?
21:35:29 <lambdabot> The answer is: Yes! Haskell can do that.
21:35:34 <blackdog> DigitalKiwi: pretty sure it's a one-liner in haskell:)
21:35:41 <iaefai> DigitalKiwi: I looked at fortran once, but it looked quite difficult
21:36:14 <DigitalKiwi> blackdog: glguy wrote one of the functions in haskell and it was definitely not one line ;p
21:36:17 <Jafet> iaefai, make haskell your scripting language!
21:36:34 <iaefai> Jafet: not sure I want to do that :p
21:36:48 <blackdog> DigitalKiwi: it might be quite a long line...
21:36:57 <DigitalKiwi> well i already know a few other imperative langauges, including C an C++, so it's not too hard
21:37:20 <iaefai> DigitalKiwi: same here, but much of it baffled. Might be the lack of proper tutorials.
21:37:27 <iaefai> I would like a nice Prototype based language ontop of haskell
21:37:34 <tensorpudding> Once you know seventeen imperative languages, you know them all.
21:37:39 <DigitalKiwi> laskell!
21:37:44 <DigitalKiwi> lua+haskell
21:38:01 <DigitalKiwi> or haskellua
21:38:31 <Jafet> tensorpudding, which 17?
21:38:47 <tensorpudding> I don't know
21:39:01 <iaefai> How about: http://hackage.haskell.org/package/HJScript-0.4.9
21:42:03 <tensorpudding> the first 17 that came to my mind...
21:42:09 <tensorpudding> C, C++, Java, Python, Perl, Pascal, Brainf*ck, Visual Basic, Lua, Ruby, Smalltalk, Oberon, Objective-C, Eiffel, Fortran, Go.
21:42:41 <DigitalKiwi> that is 16
21:42:52 <Jafet> And Haskell!
21:42:59 <DigitalKiwi> not imperative ;p
21:43:06 <matt_m> Am I correct in my understanding that Haskell doesn't consider the context when choosing an instance?
21:43:13 <Jafet> @quote best
21:43:13 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
21:43:21 <matt_m> And if so, is there an extension that changes this?
21:43:29 <Jafet> @quote best imperative
21:43:29 <lambdabot> No quotes for this person. Just try something else.
21:43:49 <Cale> matt_m: Yes, you're right, and it's not avoidable.
21:44:04 <matt_m> Cale: thanks
21:44:12 <Cale> matt_m: When compiling a module, there's no way to know that there *won't* be an instance of something in a future module.
21:44:21 <DigitalKiwi> C sharp!
21:44:46 <Cale> matt_m: In order to guarantee this, we'd need the ability to "close" a class and say that there can't be any further instances of it.
21:45:11 <Jafet> -XFinalKeyword
21:45:23 <DigitalKiwi> bash, falcon, zsh, fortran, (is erlang imperative?), prolog?
21:45:24 <matt_m> Cale:  So?
21:45:36 <matt_m> Cale:  Why is it important to prevent that case?
21:45:51 <tensorpudding> My list isn't canonical.
21:45:55 <DigitalKiwi> ;p
21:46:02 <tensorpudding> Most of those languages are redundant.
21:46:20 <matt_m> Cale: In other words, I'm talking about behavior that would rule out an instance based on the context.
21:46:20 <tensorpudding> A few most people have never heard of.
21:46:29 <Cale> matt_m: yeah
21:46:30 <matt_m> (if I understand correctly)
21:46:39 <tensorpudding> Or at least, never seen in the wild.
21:46:44 <DigitalKiwi> i've heard of all of them :/
21:46:46 <matt_m> Cale:  So, it seems that in the worst case you just get an error when you might not get one later
21:47:02 <matt_m> Cale:  Or, there are overlapping instances, but yuo're not warned
21:47:03 <DigitalKiwi> what kind is ocaml?
21:47:11 <Cale> matt_m: and you can't do that because there's no way to tell when compiling the current module that there's not going to be an instance which makes the constraint satisfied
21:47:54 <matt_m> Cale:  The current behavior if the constraint is not satisfied is to issue an error
21:47:55 <Jafet> kiwi, the dysfunctional kind
21:48:51 <tensorpudding> OCaml is like ML, but with objects and shit
21:50:16 <matt_m> Cale:  It seems the worst case is not getting a warning that instances eventually overlap.
21:50:23 <Cale> hmm
21:50:33 <matt_m> Cale:  But anyway, thanks for the info!
21:50:43 <matt_m> Cale: This is a really helpful channel :)
21:50:51 <Saizan> the worst case is getting different instances for the same type in different places
21:51:03 <Cale> yeah
21:51:05 <matt_m> Saizan:  Yes
21:51:10 <Cale> I agree with Saizan there :)
21:51:56 <matt_m> Saizan:  That could in theory be avoided by including instance info with compiled modules, and issuing overlapping warnings at link time
21:52:20 <iaefai> BTW, can one make runhaskell do special stuff? For example, I would like to be able to compile a C module that my program requires (it makes it so mac osx thinks it is a bundle).
21:52:39 <matt_m> Saizan: Not looking at the context seems to seriously cripple type classes ... but maybe that's just my inexperience
21:52:50 <Cale> iaefai: Include the .c file on the commandline to ghc
21:53:23 <Cale> matt_m: I haven't really wanted to do it. What are you trying to do?
21:53:31 <iaefai> $ runhaskell unbundled.c anim.hs  >> unbundled.c:1:0: parse error on input `//#'
21:54:19 <Cale> iaefai: ghc --make unbundled.c anim.hs
21:54:36 <Cale> (don't use runhaskell for this)
21:55:02 <matt_m> Cale:  The monad zipper paper has instances for subtyping open sums, and they apparently overlap
21:55:05 <jmillikin> Does Haddock support linking to identifiers which haven't been imported? The docs at < http://www.haskell.org/haddock/doc/html/ch03s08.html#id289950 > suggest it does, but I can't get it to generate a link.
21:55:22 <matt_m> Cale: It's probably the same encoding as the datatypes a la carte paper
21:55:40 <iaefai> Is it possible to get cabal to output a proper app bundle?
21:55:57 <matt_m> The instances are:  f <: f,   f <: (f :+: g),  and f <: (h :+: g)
21:56:06 <Saizan> matt_m: that could be a closed class though, right?
21:56:29 <matt_m> Saizan: Sure - how do I close a class?
21:56:48 <Cale> jmillikin: I seem to vaguely recall something about commandline parameters...
21:57:12 <Saizan> matt_m: you can't :)
21:57:37 <blackdog> iaefai: you could presumably always wrap it with platypus or something similar
21:57:43 <matt_m> Saizan:  lol
21:57:47 <jmillikin> Cale: do you remember which options? I would assume Haddock doesn't need anything special to look up a module's path
21:57:53 <matt_m> Saizan:  That's my problem!
21:58:04 <Saizan> matt_m: hack GHC :)
21:58:09 <iaefai> What is platypus?
21:58:25 <Jafet> http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html Benchmarking C and "Haskell"
21:58:45 <matt_m> Saizan: I have the idea that I can make the instances nonoverlapping by changing the arbitrary sum to be more like a cons list
21:58:48 <Cale> jmillikin: --dump-interface and --read-interface, apparently
21:58:53 <jmillikin> Basically, I have [module A where import Module B] [Module B where foo :: Int -- ^ See 'A.bar' ] -- a submodule, which should reference its parent in documentation
21:59:10 <Saizan> matt_m: yeah, that sounds right
21:59:10 <matt_m> Saizan: Where the types of the head and tail are different
21:59:26 <iaefai> Would it be worthy to make a patch to cabal (whatever is the right cabal) to enable some form of bundle making?
21:59:27 <matt_m> Saizan:  But I'm fuzzy on the details...
21:59:54 <Saizan> matt_m: making :+: a type function that appends
22:01:14 <Cale> jmillikin: If you're generating the documentation separately, you can --dump-interface=<file> when generating the documentation for module B, and then --read-interface=<file> when generating it for module A... I think if you just do them both at the same time, they'll link across module boundaries anyway though. I haven't generated a lot of haddock by hand. (I tend to just let cabal do whatever it does)
22:01:41 <jmillikin> Cale: They're both in the same Cabal package. I'm not generating it by hand, just using "cabal haddock"
22:02:12 <Cale> jmillikin: Oh, and the links don't happen? Hmm...
22:02:20 <blackdog> iaefai: platypus creates mac apps out of binaries
22:02:39 <jmillikin> Right. It's inserted into the text as "See A.bar" -- it removes the quotes, but doesn't link it
22:02:42 <blackdog> if you want to do anything clever with the mac stuff, it's the wrong thing to do, but it's a nice hack
22:03:10 <iaefai> blackdog: sounds like functionality I could use. But some how I think a patch to cabal would make this very useful.
22:03:57 <iaefai> What role does Setup.hs play?
22:04:54 * shapr hugs blackdog 
22:05:00 <Saizan> matt_m: though Cons f r1 <: Cons f r2 and Cons f r1 <: Cons g r2 will continue to overlap
22:05:40 <blackdog> shapr: aw, cheers man
22:05:52 <matt_m> Saizan: Ya, what I think might work is distinguish between individual terms and lists proper at the type level somehow
22:06:09 <blackdog> iaefai: hm. do you think so? what would it add?
22:06:15 <matt_m> Saizan: Then have a rule that says   f <: f + l
22:06:33 <matt_m> Saizan:  And  l2 <: l1 + l2
22:06:49 <matt_m> Saizan: Where f is an individual and l, l1, l2 are lists
22:06:55 <blackdog> maybe a package that can take a cabal package and makes a mac app out of any executable could be useful, but it'd need someone to have that itch
22:07:01 <Saizan> matt_m: and + is?
22:07:11 <matt_m> Saizan: TBD :)
22:08:05 <matt_m> err, my second rule should have been:  l1 <: f + l2
22:08:34 <iaefai> blackdog: Basically, you could have Executable anim like I have, but instead say Bundle anim
22:09:02 <matt_m> Saizan:  So + is some operation that takes (individual list -> list)
22:09:06 <iaefai> It could just copy things separately, and even add something for assets if you need - like image files or whatnot. That would suit it very well to what I am doing.
22:09:48 <iaefai> Perhaps a separate Bundle is not the best way, because it is mac specific though.
22:10:46 <blackdog> iaefai: i suspect it's not going to be terribly high on the cabal devs' priority list any time soon, but maybe they'd take patches
22:11:03 <iaefai> blackdog: yeah, something I would look into
22:11:26 <iaefai> I did find this mention for an Setup.hs: http://www.mail-archive.com/wxhaskell-users@lists.sourceforge.net/msg00700.html
22:12:57 <matt_m> Saizan:  Ya, nevermind... clearly this can't work
22:14:55 <blackdog> iaefai: there's a data directory associated with haskell apps/libs anyway, isn't there? I wonder if you could just bundle that up
22:15:03 <Saizan> matt_m: well, you've to add a tag like Singleton (or Var since these look like Var and Weakening :)
22:15:29 <iaefai> blackdog: I don't know about it...
22:16:14 <matt_m> Saizan:  Can you elaborate?
22:17:01 <Saizan> matt_m: make the first rule "Single f <: f + l"
22:17:55 <Saizan> matt_m: just a wild guess :)
22:19:11 <iaefai> sleepy thyme...
22:20:13 <matt_m> Saizan:  I thought about adding some kind of unary ordinal to the type, but I'm still not seeing it
22:21:11 <matt_m> Saizan:  So what happens if I turn on AllowOverlappingInstances, and it picks an instance for which the context doesn't match?
22:21:43 <matt_m> Saizan:  Will it pick another instance at that point?
22:22:20 <Saizan> matt_m: no
22:22:32 <Saizan> it will just error out
22:23:50 <iaefai> Maybe I should implement applescript as a dsl... :p
22:24:21 <Cale> Offtopic, but this is cool: http://www.newgrounds.com/portal/view/534416
22:24:44 <matt_m> Saizan:  At runtime?
22:24:52 <Saizan> matt_m: no, at compile time
22:24:55 <matt_m> ya ok
22:25:29 <Saizan> btw, seen the comments here? http://wadler.blogspot.com/2008/02/data-types-la-carte.html , might give something to work on
22:25:39 <matt_m> Saizan:  If I only had some way to order the individuals...
22:25:51 <matt_m> Saizan: I had not - thanks
22:29:07 <matt_m> Saizan:  I gather that to be the gist of Oleg's comment:  close the space of types considered, so that the sums become ordered
22:29:10 <matt_m> elements
22:31:14 <Saizan> yeah
22:32:11 <matt_m> Saizan:  I'm gonna take a break - thanks for the help!
22:32:19 <Saizan> matt_m: np :)
22:33:33 <ezyang> What describes this pattern of computation: I have an array of elements, and I start running a function with the individual element and the array as a whole. If the function changes the individual element, restart the computation.
22:34:08 <ezyang> The intent is that eventually the array converges to some value that doesn't change any more
22:35:30 <Cale> fixEq f x | x == x' = x' | otherwise = fixEq f x' where x' = f x
22:35:51 <Cale> Something like that?
22:36:05 <ezyang> Hmmm
22:36:17 <Cale> I suppose you just want to test the one element...
22:36:38 <ezyang> that looks suspiciously like a fix point
22:36:47 <Cale> yeah
22:37:08 <ezyang> I guess that works
22:41:11 <glguy_> After playing with well-founded recursion in Agda the last few days I am offended by the way you casually define that function with no way to show that it ever terminates!
22:41:28 * glguy_ throws in a fixEq not
22:44:14 <idnar> glguy_: heh
22:51:03 <ac_4934> why haskell?
22:51:50 <ezyang> @faq World Peace
22:51:50 <lambdabot> The answer is: Yes! Haskell can do that.
22:51:51 <zachk> cause it hurts your head to grok it
22:52:43 <ezyang> More seriously, it makes you more aware of the nature of computation
22:53:02 <ac_4934> can't you code in python or c?
22:53:47 <zachk> haskell cuts down on the number of lines you need to write
22:54:00 <Jafet> ac, try to read more chapters of the trolling manual before an attempt
22:54:04 <ezyang> http://blog.ezyang.com/2010/01/why-haskell/
22:54:33 <ezyang> plug plug plug
22:55:05 <ac_4934> hmm
22:55:08 <ac_4934> php is good
22:55:35 <Jafet> > fix (show . ("why "++))
22:55:36 <lambdabot>   "\"why \\\"why \\\\\\\"why \\\\\\\\\\\\\\\"why \\\\\\\\\\\\\\\\\\\\\\\\\\\\...
22:55:37 <ac_4934> how to earn money?
22:56:41 <ezyang> Jafet: "hello hello hello; somebody say" (percussive noises)
23:00:45 <zark4711> as i just see fix (show . ("why "++))
23:00:58 <zark4711> is there any website that collects these kind of snippets?
23:01:42 <copumpkin> probably on the haskell wiki somewhere
23:02:18 <Jafet> Sit in here a few weeks and grep your log for ^>
23:02:37 <Jafet> Make sure to set --context
23:02:56 <zark4711> or any kind of code where somebody thought he was a genious or did something great with the language. i think such a site would be helpful to learners...pretty much everyone in some way or another
23:03:07 <ezyang> Functional Pearls?
23:03:25 <kingping> Hello
23:03:26 <Jafet> Genious code snippets aren't very helpful to learners
23:03:41 <zark4711> i mean learners not beginners
23:03:46 <kingping> Can I express this in Haskell ? http://en.wikipedia.org/wiki/Lambda_calculus#Recursion_and_fixed_points
23:03:59 <kingping> In particular g := ?r. ?n.(1, if n = 0; else n ? (r r (n-1)))
23:04:10 <Jafet> > fix error
23:04:11 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
23:04:14 <zark4711> i think some examples
23:04:50 <kingping> > let g = \r -> \n -> if n == 0 then 1 else n * (r r (n-1))
23:04:51 <lambdabot>   not an expression: `let g = \r -> \n -> if n == 0 then 1 else n * (r r (n-1...
23:05:12 <kingping> > (\r -> \n -> if n == 0 then 1 else n * (r r (n-1))) 5
23:05:13 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> a -> a
23:05:15 <zark4711> i think some examples would help to really understand stuff. hmm. i will think about that. and about the logging. i dont know if this message was for me but logging this channel would be a good idea
23:06:14 <ac_4934> child porn here?
23:06:27 <kingping> > (\r -> \n -> if n == 0 then 1 else n * (r  (n-1))) 4
23:06:28 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
23:06:28 <lambdabot>    arising from the literal `4' at <...
23:06:29 <Jafet> > fix (\fac n -> if n<0 then undefined else if n==0 then 1 else n * fac (n-1)) $ 5
23:06:29 <lambdabot>   120
23:06:34 <Jafet> :t fix
23:06:35 <lambdabot> forall a. (a -> a) -> a
23:07:02 <Saizan> fix cheats though, it's defined with recursion
23:07:13 <Jafet> > let Y f x = f f x in Y (\fac n -> if n<0 then undefined else if n==0 then 1 else n * fac (n-1)) 5 -- Y combinator
23:07:14 <lambdabot>   Not in scope: data constructor `Y'Not in scope: data constructor `Y'
23:07:20 <Jafet> Ergh.
23:07:36 <Jafet> That doesn't work anyway
23:07:40 <ac_4934> child porn here?
23:07:53 <kingping> lambda porn
23:08:13 <ac_4934> lambada
23:08:17 --- mode: ChanServ set +o Saizan
23:08:49 --- mode: Saizan set +b *!*ouple4674@92.37.228.*
23:08:49 --- kick: ac_4934 was kicked by Saizan (ac_4934)
23:08:54 <copumpkin> that was weird
23:08:56 --- mode: Saizan set -o saiam
23:09:00 --- mode: Saizan set -o Saizan
23:09:47 <Saizan> kingping: http://en.wikipedia.org/wiki/Y_combinator#Example_of_encoding_via_recursive_types <- this is the nearest you get to the Y combinator in haskell :)
23:10:21 <kingping> O thanks Saizan, I'm completely lost in terms..
23:10:33 <ManateeLazyCat> I use "maybeTransformM_ :: Monad m => Maybe a -> (a -> m ()) -> m ()" everywhere in my project, but i want change it to some symbol (similar as >>=) for less typing, anyone suggestion a good symbol and won't conflict with exist symbols?
23:11:07 <Jafet> I can imagine the standard answer now... "How do I define a Y combinator in Haskell?" "Mu."
23:11:15 <copumpkin> ManateeLazyCat: (??)
23:11:24 <ezyang> Random idea: hackage name collision wordle.
23:11:31 <copumpkin> you could use Mu to make a Y combinator?
23:11:42 <ManateeLazyCat> copumpkin: Maybe (?=>) ?
23:11:47 <copumpkin> hm
23:11:50 <Jafet> (Couldn't you?)
23:12:05 * ManateeLazyCat pasted "Maybe.hs" at http://paste2.org/get/799822
23:12:16 <ManateeLazyCat> copumpkin: Above is my Maybe functions.
23:12:34 <Saizan> Rec a ~ Mu (\t -> t -> a)
23:12:37 <ManateeLazyCat> copumpkin: I always use those funtions, and want use some symbol to replace long functions name.
23:13:08 <copumpkin> yeah, but it'd need another type
23:13:26 <copumpkin> type lambdas now!
23:14:03 <Saizan> ~ Mu (Flip (->) a)
23:14:41 <matt_m> Saizan:  Any idea how overlapping instances are resolved if you turn on IncoherentInstances?
23:14:42 <Saizan> you'd be lost in the newtype wrappings :)
23:14:59 <matt_m> Saizan:  (And if the two patterns on the right are essentially the same)
23:15:41 <Saizan> matt_m: i think it commits to the first
23:16:00 <Saizan> matt_m: though i've never used them much
23:16:05 <copumpkin> http://snapplr.com/k0tg
23:16:05 <matt_m> Saizan:  ok
23:16:21 <copumpkin> matt_m: ^
23:16:30 <copumpkin> I guess that doesn't really answer you :P
23:16:40 <copumpkin> but there's remarkably little information out there on incoherentinstances
23:17:23 <kingping> ;) http://mvanier.livejournal.com/2897.html
23:18:45 <matt_m> Saizan:  If I knew it broke the tie by order, I could just arrange for (f <: f :+: g) to be considered first
23:18:58 <matt_m> Saizan:  Only if that fails consider (f <: h :+: g)
23:19:26 <matt_m> That rule should work I think ... so I wonder if it breaks ties based on order
23:20:15 <matt_m> Or if it considered (f  <: f + g) to be more specific than (f <: h + g) that would work too
23:20:32 <Saizan> it probably will
23:20:50 <Saizan> i thought you wanted to avoid OverlappingInstances though
23:22:35 <matt_m> Saizan:  Ya I originally did, but I'm lowering the bar
23:23:24 <Saizan> then the solution by Ryan Ingram linked on the wadler post should fit
23:23:47 <kingping> The last r just looked spare to me in g := ?r. ?n.(1, if n = 0; else n ? (r r (n-1)))
23:23:58 <Saizan> or this one http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25194#a25194
23:25:39 <Saizan> kingping: well, r is going to be g itself, so it expects an r
23:26:06 <kingping> Ah, maybe.
23:28:54 <Peaker> I want a @djinn that uses all the arguments :)
23:29:01 <Peaker> @djinn ((er -> er -> er) -> (r -> r -> r)) -> ((er, t) -> (er, t) -> (er, t)) -> ((r, t) -> (r, t) -> (r, t))
23:29:01 <lambdabot> f _ _ _ (a, b) = (a, b)
23:29:04 <Peaker> That's cheating
23:29:08 <copumpkin> it tries to
23:29:10 <copumpkin> I thought
23:29:18 <Peaker> maybe -- so this might be impossible then
23:29:29 <copumpkin> what would you write tehre?
23:29:35 <copumpkin> I'm still trying to parse it, myself
23:29:41 <Peaker> I am not sure.. that's why I was asking djinn
23:29:45 <copumpkin> :)
23:30:03 <Peaker> I have   inImage2 :: ((Rect, TMap a) -> (Rect, TMap b) -> (Rect, TMap c)) -> Image a -> Image b -> Image c
23:30:07 <glguy_> copumpkin: you inspired me to twit
23:30:12 <copumpkin> glguy_: yay!
23:30:36 <Peaker> And   mappend :: (ExpandingRect, TMap a) -> (ExpandingRect, TMap a) -> (ExpandingRect, TMap a)
23:31:00 <Peaker> And:  withExpandingRect :: (ExpandingRect -> ExpandingRect -> ExpandingRect) -> Rect -> Rect -> Rect
23:31:06 <copumpkin> :o
23:31:09 <Peaker> I was wondering if those functions can be combined, I think they can't
23:31:17 <Peaker> So I asked djinn
23:31:34 <copumpkin> seems like it should be possible
23:31:50 <copumpkin> hmm, maybe not
23:31:59 <copumpkin> oh I guess not
23:32:17 <copumpkin> in the end you have give real parameters
23:32:18 <copumpkin> five
23:32:21 <Peaker> I spent a few hours toying with types
23:32:26 <Peaker> I got this interesting pattern:
23:32:32 <copumpkin> you have two actual options I thin
23:32:39 <Peaker> @let tup = uncurry (***)
23:32:40 <lambdabot>  Defined.
23:32:40 <copumpkin> and they're both pretty boring
23:32:46 <Peaker> @let result = (.)
23:32:46 <lambdabot>  Defined.
23:33:10 <Peaker> @type tup
23:33:10 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
23:33:18 <Peaker> @type (result . result) tup tup
23:33:19 <lambdabot> forall (a :: * -> * -> *) b c b' c' (a1 :: * -> * -> *) b1 b'1. (Functor (a1 (b1, b'1)), Arrow a, Arrow a1) => (a1 b1 (a b c), a1 b'1 (a b' c')) -> a1 (b1, b'1) (a (b, b') (c, c'))
23:33:25 <Peaker> Caleskell!
23:33:25 <copumpkin> eugh
23:33:40 <copumpkin> and too many arrows
23:33:47 <Peaker> Well, let me define otherwise then
23:33:51 <Peaker> @undef
23:34:04 <Peaker> @let tup :: (a -> a', b -> b') -> (a, b) -> (a', b') ; tup = uncurry (***)
23:34:05 <lambdabot>  Defined.
23:34:14 <Peaker> @let result = (Prelude..)
23:34:15 <lambdabot>  <local>:2:9: Not in scope: `Prelude..'
23:34:17 <Peaker> @let result = (P..)
23:34:18 <lambdabot>  <local>:2:9: Not in scope: `P..'
23:34:22 <copumpkin> eugh
23:34:26 <Peaker> Where's that?
23:34:29 <copumpkin> just fix the type
23:34:39 <Peaker> @let result f g x = f (g x)
23:34:39 <lambdabot>  Defined.
23:34:42 <Peaker> @type result
23:34:43 <lambdabot> forall t1 t2 t. (t1 -> t2) -> (t -> t1) -> t -> t2
23:34:45 <copumpkin> :P
23:34:53 <Peaker> @type tup
23:34:54 <lambdabot> forall a a' b b'. (a -> a', b -> b') -> (a, b) -> (a', b')
23:35:04 <Peaker> @let tup2 = (result . result) tup tup
23:35:05 <lambdabot>  Defined.
23:35:07 <Peaker> @type tup2
23:35:08 <lambdabot> forall a1 a a' b1 b b'. (a1 -> a -> a', b1 -> b -> b') -> (a1, b1) -> (a, b) -> (a', b')
23:35:22 <Peaker> @let tup3 = (result . result) tup2 tup
23:35:23 <lambdabot>  Defined.
23:35:27 <Peaker> @type tup3
23:35:27 <lambdabot> forall a2 a a1 a' b2 b b1 b'. (a2 -> a -> a1 -> a', b2 -> b -> b1 -> b') -> (a2, b2) -> (a, b) -> (a1, b1) -> (a', b')
23:35:30 <Peaker> this :-)
23:35:35 <Peaker> Might even be useful
23:36:04 <Peaker> Basically chaining (***) properly
23:36:08 <Peaker> like <*>
23:36:24 <Peaker> copumpkin, anyone, what are the boring options?  One is just using unExpandRect/ExpandRect (which I did)
23:36:31 <Peaker> s/anyone/anyway
23:36:45 <copumpkin> well, ((er -> er -> er) -> (r -> r -> r)) -> ((er, t) -> (er, t) -> (er, t)) -> (r, t) -> (r, t) -> (r, t)
23:36:54 <copumpkin> you have two (r, t) tuples you could return
23:37:02 <copumpkin> and that's about it
23:37:20 <Peaker> I want to really mappend
23:37:33 <copumpkin> but I mean, you need to think of what you could feed to what to get something else
23:37:44 <Peaker> Maybe I'll go back to having ExpandingRect in image, rather than the monoid-less rect
23:37:54 <copumpkin> you have functions and you have two (r, t) pairs
23:38:07 <copumpkin> and none of the functions let you grab an er that you could feed to one of the functions
23:39:24 <Peaker> brb
23:51:19 <matt_m> Saizan:  Yes, your pastebin is nice - organizing concats into a list - but I don't think it changes much from me
23:51:33 <matt_m> Saizan:  It comes down to the pair of overlapped instances at the end
23:53:52 <Saizan> matt_m: yeah
23:54:30 <Peaker> copumpkin, just restored my Image to contain an ExpandingRect, makes the Monoid clearer
23:55:33 <matt_m> Saizan:  It sounded like that Wadler thread was about making the relations symmetrical, not about about whether they worked
23:55:52 <matt_m> Saizan: But I'm seeing overlapped instance problems I think
23:56:32 <Maxdamantus> ZOMG parabolas.
23:57:10 <matt_m> Saizan:  Choice does not seem to depend on their textual ordering
23:57:22 <matt_m> Saizan:  Thanks again for your help!  Goodnight
23:57:43 <Saizan> matt_m: the most specific match will be used
23:57:47 * Maxdamantus gets parabolas on his terminal printing a list of the powers of two O_o
23:59:34 <Peaker> I thought vty was slow - but it turns out xterm/rxvt are super-slow :(
23:59:53 <Peaker> I wonder what terminal is close to the speed of a "physical" tty or the Mac one
