00:00:04 <Cale> opqdonut: wrong either and maybe
00:00:11 <Cale> opqdonut: He's talking about the functions
00:00:14 <opqdonut> ah
00:00:21 <opqdonut> yeah, awkward
00:01:18 <chrisdone> @hoogle Monoid a => (a -> b) -> (a -> b) -> a -> b
00:01:19 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
00:01:19 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
00:01:19 <lambdabot> Data.Generics.Aliases extQ :: (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
00:01:20 <chrisdone> perhaps?
00:01:24 <kmc> hmm, i'm defining "lists of T" as the least fixed point of the functor 1 + (K T) * I, which is all well and good, but I want it to be a functor on T as well
00:01:27 <Cale> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Cata.html
00:01:27 <avenge> applicative:  Well, now it seems to work, though strangely my other machine already had cabal 0.8.2 and didn't work.  Maybe this is a result of not being able to cabal upgrade...
00:01:28 <chrisdone> thanks hoogle *rolls eyes*
00:01:35 <kmc> what's to be done? it seems like a lack of kind-polymorphism is hurting me here
00:02:00 <Cale> 'cata' here is an abtraction of maybe, either, foldr, and other folds
00:02:23 <Cale> though you need to define your types as fixed points of algebras
00:02:32 <avenge> applicative:  Oh, spoke too soon.  Still doesn't work.  I guess the current state of hackage is just that happstack-data is busted.
00:02:33 <kmc> in full Haskell:  data U a = U; data K t a = K t; data I a = I a; type L t = Mu (U :+: (K t :*: I))
00:02:37 <Cale> (explicitly, rather than just using Haskell's normal machinery for that)
00:02:45 <chrisdone> hmm
00:02:56 <chrisdone> ok I'll look at that when I get home
00:03:42 <Cale> Er, sorry, fixed points of arbitrary functors, and you pass an algebra for that functor which specifies how to 'collapse' the structure.
00:04:26 <Cale> It's not really practical compared to just using the separate functions under normal circumstances.
00:04:50 <Cale> chrisdone: Why is it that you want to abstract over them?
00:05:04 <Cale> (Do you really need the polymorphism?)
00:06:03 <olsner> if you do need the polymorphism, maybe you can create a typeclass explicitly for what you want to do here
00:07:09 <avenge> applicative:  Hmm... maybe an optimization bug?  Thanks for the help.  http://groups.google.com/group/happs/browse_thread/thread/0c66c74294d8eabf/0f65ba6e4f7e822d#0f65ba6e4f7e822d
00:08:02 <jarick> Hello. I have a wee bit of an issue. I wish to putStr something of type [[a]] -> Int. putStr is String. How do I convert an Int to a String?
00:08:41 <kmc> jarick, show
00:08:43 <kmc> > show 3
00:08:44 <lambdabot>   "3"
00:08:51 <jarick> kmc: Ah, thanks.
00:08:58 <kmc> that answers your question, which doesn't make sense with the rest of what you said
00:09:31 <Jafet> > show [[1,2,3],[4,5,6],[7,8]]
00:09:32 <jarick> kmc: Sorry, rephrase. I want to putStr an Int.
00:09:32 <lambdabot>   "[[1,2,3],[4,5,6],[7,8]]"
00:10:03 <jarick> I have rolldiff :: Eq a => [[a]] -> Int.
00:10:07 <olsner> jarick: you can also use print, that's essentially putStr (show x)
00:10:18 <jarick> olsner: But that adds the newline, which I don't want.
00:10:23 <olsner> ah, right
00:10:35 <kmc> :t putStr . show
00:10:36 <lambdabot> forall a. (Show a) => a -> IO ()
00:10:45 <Jafet> print is putStrLn (show x), surely
00:10:47 <Jafet> @src print
00:10:47 <lambdabot> print x = putStrLn (show x)
00:12:04 <jarick> There we go. Sorted. Now to test if the damn rolling hash theory works.
00:12:10 <jarick> Thanks folks.
00:15:11 <Jafet> The theory works, but I'm not sure if your implementation of it does
00:15:40 <Vitka> :t show Int
00:15:41 <lambdabot> Not in scope: data constructor `Int'
00:15:50 <Vitka> ...
00:16:06 <Axman6> Vitka: what are you trying to do?
00:16:25 <Vitka> Nothing, really.
00:16:49 <jarick> Jafet: The implementation of the hash works against known test vectors, the theory is that irc logs, like all other naturally generated text, should demonstrate rather large variences
00:16:57 <tensorpudding> functions operate on values, not types
00:17:15 <Vitka> Oh, good point.
00:17:41 <jarick> i.e. it is unlikely that I will produce a string that has a small edit distance from what you produce, for some long value of string.
00:18:12 <jarick> I am expecting "lol" and such to appear often though.
00:18:25 <Jafet> jarick, you may want to look into robot9000
00:18:46 <chrisdone> Cale: sorry I'm just getting ready for work. I have this notion that I employ all the time that "if this value is 'empty' then do this withe the value, otherwise do that with the value". I use either, maybe, list :: b -> ([a] -> b) -> [a] -> b, bool :: b -> b -> a -> b, kind of thing. I was just wondering if there's an abstract version of that. a type class could handle all this but I don't know. anyway better be off. i'll check my logs
00:18:47 <chrisdone> when I get home
00:19:23 <jarick> Jafet: Looking. The xkcd thing?
00:19:47 <Jafet> I'm not sure if you can get logs from that channel, but it may be useful
00:21:17 <jarick> Jafet: Something tells me that #debian and #defocus are bad test sets.
00:21:31 <Jafet> I've never been in those, so I wouldn't know
00:21:39 <chrisdone> Cale: could also be quite good for when you want to return an error or emptyable value from a parser or something, I guess, ..
00:21:41 <tensorpudding> Nothing wrong with #debian.
00:21:44 <Jafet> You could use #ubuntu as a control specimen.
00:21:54 <tensorpudding> There might be a bit of bot chatter.
00:23:45 <jarick> Jafet: I'm looking for logs from assorted channels. Polled the colleagues for channels to look at, found several social channels that exhibit, after stripping the single word responses, rather decent varience.
00:24:14 <Jafet> Sounds like backwards science to me
00:24:34 <jarick> Jafet: How so?
00:24:44 <Jafet> Backtracking from the most desired result
00:24:50 <jarick> Ah, rephrase, I'm testing my algorithm against these channels.
00:25:01 <jarick> They demonstrate the expected behaviour.
00:25:12 <Jafet> I wouldn't doubt it.
00:25:27 <jarick> The channels were pulled at random from colleagues who were asked to provide channels with high traffic.
00:25:53 <jarick> Jafet: The idea is to distinguish human traffic from non-human traffic.
00:26:02 <jarick> At least, part of the idea is.
00:29:38 <avenge> applicative:  Problem solved.  The workaround is to install syb-with-data without documentation.  Totally weird, but haddock somehow corrupts the library or interface file!
00:29:41 <tensorpudding> @botsnack
00:29:41 <lambdabot> :)
00:37:29 <jarick> Jafet: If you see a problem in the technique, or need more clarification, please ask.
00:37:40 <jarick> It's really a toy project though.
00:38:37 <kmc> i'm doing some exercises with functor algebra, and have hit a brick wall
00:38:45 <kmc> http://codepad.org/wT54ACzh (the question is at the bottom)
00:50:50 <jarick> triplez_!
00:50:57 <triplez_> ?
01:04:11 <Dark_Shikari> If I have "data Program = Statement", and I have a function that takes a Statement as an argument, how do I pass a Program to it without haskell complaining about the types not matching?
01:05:02 <Taejo> Dark_Shikari: if you have that line, then there is only one program, called "Statement"
01:05:25 <Dark_Shikari> this is from a set of types defining an abstract syntax (which is recursive)
01:05:31 <Dark_Shikari> e.g. a Program is a Statement, a Statement is a set of possible statements
01:05:35 <Dark_Shikari> which can contain Expressions or other Statements, etc
01:05:51 <Taejo> that type is not recursive, though: it only has a single constructor, which takes no arguments
01:06:02 <Dark_Shikari> But it works if I don't infer types.
01:06:06 <Dark_Shikari> er, if I let it infer types
01:06:09 <Dark_Shikari> instead of telling it to use the correct ones.
01:06:20 <Taejo> you probably want "type Program = Statement", which says Program and Statement are the same type
01:06:57 <Taejo> or "data Program = Statement Statement" which says whenever s is a Statement, "Statement s" is a Program
01:07:23 <Dark_Shikari> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24741#a24741
01:07:28 <Dark_Shikari> that's the abstract syntax
01:07:43 <Dark_Shikari> it worked for my compiler, but I'm now writing an optimizer that traverses the parsetree
01:07:55 <Dark_Shikari> (NB: for toy language)
01:08:03 <Taejo> Dark_Shikari: does your language only have one program?
01:08:12 <Taejo> because your AST only has one Program
01:08:19 <Taejo> namely "Statement"
01:08:21 <Dark_Shikari> yes
01:08:24 <Dark_Shikari> there is only one program
01:08:26 <Dark_Shikari> note nothing can be a program
01:08:31 <Dark_Shikari> program is what the whole thing is
01:08:36 <Dark_Shikari> you pass it a program, which is a statement
01:08:40 <Dark_Shikari> the statement can be one of many things, etc
01:09:28 <Taejo> so you are saying there are as many programs as statements (i.e., infinitely many)?
01:09:38 <Dark_Shikari> um, you only pass the compiler one program at a time
01:09:44 <kmc> even HQ9+ has four programs
01:09:53 <Taejo> yes, but there are infinitely many *possible* programs
01:09:59 <Dark_Shikari> of course
01:10:04 <Dark_Shikari> because there are infinitely many possible statements
01:10:14 <Taejo> well your AST has only one possible Program
01:10:17 <kmc> Dark_Shikari, with that AST, this is the only program you can write:  Statement
01:10:19 <kmc> that's it
01:10:22 <kmc> not a value of *type* statemen
01:10:29 <kmc> the value *named* Statement
01:10:30 <Dark_Shikari> oh. oops.
01:10:33 <kmc> Statement :: Program
01:10:35 <Dark_Shikari> lol
01:10:57 <Dark_Shikari> ok, I'll kill that and just make a program a Statement.
01:11:04 <Dark_Shikari> type Program = Statement ?
01:11:06 <kmc> yeah, you might want "type Program = Statement"
01:11:09 <Taejo> yes
01:11:17 <Dark_Shikari> do I still need deriving show?
01:11:20 <Dark_Shikari> or is that implicit with a type?
01:11:27 <kmc> that gives you no safety between the two, i.e. you can mix "Program" and "Statement" freely
01:11:38 <kmc> it's implicit.  "type" is just a synonym
01:11:47 <kmc> think of it as a macro on types (and in this case, a simple substitution)
01:11:51 <Dark_Shikari> k
01:11:56 <Dark_Shikari> so same as typedef
01:11:58 <kmc> yeah
01:12:04 <Dark_Shikari> ok, now second bit
01:12:06 <Dark_Shikari> here's my simple optimizer
01:12:08 <Dark_Shikari> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24742#a24742
01:12:13 <Dark_Shikari> all it does is traverse the parsetree and fold constants
01:12:47 <kmc> btw, optimize and optimizeS will now have the same type and be totally equivalent
01:12:53 <Dark_Shikari> oof
01:12:59 <Dark_Shikari> well, actually, that should be fine
01:13:01 <Dark_Shikari> anyways, the problem is
01:13:04 <Dark_Shikari> Compile.hs:185:40:
01:13:04 <Dark_Shikari>     Couldn't match expected type `[Statement]'
01:13:04 <Dark_Shikari>            against inferred type `Statement'
01:13:10 <kmc> which line is that?
01:13:12 <Dark_Shikari> 24
01:13:23 <Dark_Shikari> the abstract syntax, as noted in the previous paste, allows "Statements [Statement]"
01:13:28 <Dark_Shikari> i.e. a list of statements
01:13:50 <Dark_Shikari> i.e. "Statements [Statement]" is a valid Statement
01:13:52 <Dark_Shikari> where Statements is the tag.
01:13:53 * Taejo can't see the problem
01:14:04 <kmc> :t (:)
01:14:05 <lambdabot> forall a. a -> [a] -> [a]
01:14:10 <Taejo> oh right
01:14:12 <Dark_Shikari> so I should be using ++?
01:14:19 <kmc> Dark_Shikari, no, because
01:14:20 <kmc> :t (++)
01:14:21 <lambdabot> forall m. (Monoid m) => m -> m -> m
01:14:24 <kmc> err
01:14:31 <kmc> [a] -> [a] -> [a]
01:14:36 <kmc> outside of crazy land ;)
01:14:46 <kmc> anyway, neither will operate on a statement
01:14:54 <Dark_Shikari> (optimizS statement) returns a Statement, i.e. a
01:15:02 <kmc> how about this definition:  optimizeS (Statements xs) = Statements (map optimizeS xs)
01:15:03 <Dark_Shikari> (optimize S (Statements rest)) returns a [Statement], i.e. [a]
01:15:06 <kmc> that will cover the [] case too
01:15:12 <Dark_Shikari> a : [a] -> [a]
01:15:46 <Dark_Shikari> It could refer to either `Prelude.map', imported from Prelude or `Map.map', imported from Data.Map
01:15:51 <Dark_Shikari> I assume I want Prelude.map?
01:15:56 <Taejo> yes
01:15:59 <kmc> you probably want a qualified import on Data.Map
01:16:06 <kmc> i usually do: import qualified Data.Map as M
01:16:50 <Dark_Shikari> well, finally got it to compile, let's see if the optimizer works.
01:16:59 * Dark_Shikari has found that whenever a haskell program compiles, it has a high odds of working
01:17:03 <Dark_Shikari> (strong typing is great)
01:17:04 <kmc> yes
01:17:11 <kmc> also, i think you're missing some constant folds
01:17:16 <Dark_Shikari> of course I spoke too soon
01:17:17 <Dark_Shikari> Compile: Compile.hs:(187,0)-(209,33): Non-exhaustive patterns in function optimizeE
01:17:20 <Dark_Shikari> kmc: yeah, I am
01:17:24 <Dark_Shikari> it only folds one level
01:17:28 <kmc> because when you recurse to optimize a subtree, you don't re-optimize once you get the result
01:17:29 <kmc> yeah
01:17:39 <Dark_Shikari> I figure I can just run it over and over ;)
01:17:43 <Dark_Shikari> until it stops changing the tree
01:17:44 <kmc> yeah that works
01:17:51 <kmc> there are more efficient ways, but that will work
01:17:53 <Dark_Shikari> yeah
01:18:03 <Dark_Shikari> ok, it seems optimizeE isn't exhaustive
01:18:11 <Taejo> but with general optimizations, you probably end up doing it that way
01:18:20 <Dark_Shikari> oh, because it doesn't handle the case of Num / Var
01:18:21 * Dark_Shikari fixes
01:18:44 <Taejo> Dark_Shikari: if you compile with -Wall you get warnings about inexhaustive patterns
01:20:25 <Dark_Shikari> heh, seems my optimize breaks one of my test cases.
01:22:06 <Dark_Shikari> lol.  my "times" does a plus
01:22:08 <Dark_Shikari> no wonder
01:23:45 <Dark_Shikari> ok, so I'm to the step of comparing the programs when doing that iterative step
01:23:50 <Dark_Shikari> but my programs don't implement Eq
01:23:56 <Dark_Shikari> can I just add Eq to Show and it'll Just Work?
01:24:00 <Taejo> yes
01:24:29 <Dark_Shikari> awesome.
01:24:35 <Dark_Shikari> 748 -> 671 bytecode size on my test sample.
01:24:55 <Dark_Shikari> only about 4 hours of work to write a toylanguage -> JVM compiler.  Not bad.
01:25:02 <Dark_Shikari> with optimization
01:25:07 <Dark_Shikari> er, utterly crappy optimization.
01:25:13 <Taejo> pretty good
01:31:21 <ivanm> preflex: seen Axman6
01:31:21 <preflex>  Axman6 was last seen on #haskell 1 hour, 15 minutes and 15 seconds ago, saying: Vitka: what are you trying to do?
01:32:39 <Adamant> why does the Haskell Platform install want me to shut down all other applications and reboot afterwards?
01:33:07 <Adamant> I would not think it should need that if it's not doing something like installing a kernel module
01:34:00 <Adamant> (on OS X, maybe it's due to the 32/64 bit issues somehow)
01:35:10 <ivanm> Adamant: maybe it was part of the generic make-an-installer tool (copied off the windows ones)?
01:35:37 <Adamant> ivanm: maybe, but the installer looks to be using the OS-native stuff
01:36:07 <Raynes> I doubt you really have to restart just to use the stuff, but some stuff might not be set right until you do, I imagine.
01:36:37 <Adamant> yeah. might just be CYA to avoid support issues that can be solved by -HUP or a reboot.
01:37:57 * hackagebot explicit-sharing 0.7 - Explicit Sharing of Monadic Effects  http://hackage.haskell.org/package/explicit-sharing-0.7 (SebastianFischer)
01:40:44 <quicksilver> Adamant: I hope that's just a bug in how the installer was packaged.
01:40:55 <quicksilver> I can't imagine any reason you'd need to restart after installing GHC.
01:41:07 <quicksilver> I've never installed after installing any previous release of it (on any platform, OSX or otherwise)
01:41:12 <Adamant> quicksilver: yeah, it seemed odd.
01:41:14 <quicksilver> *rebooted
01:41:24 <Adamant> it wasn't a true reboot, just a login/logout
01:43:12 <ivanm> Adamant: methinks I know why
01:43:17 <Adamant> or rather, the reverse :P
01:43:17 <ivanm> to reset your PATH variable, etc.
01:43:28 <Adamant> yeah, that might explain it
01:44:08 <ivanm> Adamant: as opposed to a, you know, source ~/.bashrc ...
01:44:14 <ivanm> hmmm.... patch-tag wants money...
01:44:54 <quicksilver> ivanm: Haha. If that's the reason, it's sick.
01:45:27 <ivanm> "sick" as in a euphemism for "cool"?
01:45:38 <ivanm> or as in it's a rotting corpse?
01:45:39 <ivanm> :p
01:46:08 <quicksilver> ivanm: rotting corpse.
01:46:34 <ivanm> yeah, figured you meant that one
02:01:57 <roconnor> what is patch-tag?
02:02:16 <dancor> http://patch-tag.com/
02:02:19 <dancor> darcs hosting
02:02:42 <roconnor> whoa
02:02:44 <roconnor> who runs that?
02:03:08 <quicksilver> thomas hartman is nominolo, IIRC
02:03:24 <quicksilver> no, wrong thomas
02:03:27 * quicksilver thinks again
02:03:47 <roconnor> it's very enterprising of him
02:05:17 <dancor> it's nice that something is rising out of the ashes of failed happs enterprising
02:11:13 <yottis> uhm, remind me, what was the recommended way to generate randomness?
02:11:28 <yottis> (ie the one that was actually random, and the performance didn't suck)
02:11:29 <quicksilver> well System.Random is simple enough.
02:11:52 <quicksilver> "actually random" is not a very clear phrase.
02:12:07 <quicksilver> you may read a few bytes from the "actually random" device on linux and similar OSes, perhaps.
02:12:13 <yottis> ok, i just recalled that there would have been several options of which one or two were not that good
02:12:15 <quicksilver> (and use that to seed your RNG)
02:12:22 <quicksilver> System.Random is fine for most uses.
02:12:31 <yottis> ok, thanks
02:12:31 <quicksilver> the mersenne one is better for some case.
02:12:47 <quicksilver> it's much faster but that only matters if you're trying to generate 100,000 numbers per second, or thereabouts.
02:13:01 <quicksilver> using your OS's hardware RNG may be better if you have one.
02:13:08 <quicksilver> or seeding from it may be a compromise.
02:19:24 <kmc> http://hackage.haskell.org/package/mwc-random-0.5.0.0 is recommended over mersenne now, i think
02:19:32 <kmc> (for yottis)
02:19:53 <kmc> it's used by criterion
02:25:09 * hackagebot nptools 0.2.0 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.2.0 (NicolasPouillard)
02:27:15 <helino> hi everyone! I would like to see how much memory my haskell program is using, i.e. total memory consumption. How do I profile this? (I'm using Ubuntu 9.10)
02:27:45 <Jafet> I use top
02:28:20 <quicksilver> if you want to know *how* it's using the memory, haskell has a heap profiler
02:28:29 <quicksilver> s/haskell/GHC/
02:28:39 <quicksilver> better heap profiling that most other languages AFAIK
02:28:51 <kmc> also much less predictable heap usage :)
02:29:18 <kmc> or perhaps s/less predictable/easily predicted/ ;)
02:29:28 <kmc> in a deterministic universe, all things are maximally predictable ;)
02:30:24 <Jafet> It may not be computably deterministic, although you could debate whether that counts
02:30:38 <quicksilver> kmc: also less intuitively predicted, based on intuition formed on other programming langauges.
02:30:39 <kmc> the Universe, or Haskell heap usage?
02:30:46 <kmc> right
02:31:01 <helino> i'm not that interested in *how* my program uses the memory, can the ghc profiler be used instead of top to see the total memory consumption?
02:31:21 <kmc> helino, did you run your program with:   ./myProg +RTS -s
02:31:22 <quicksilver> although I think it's generally true that the more automatic your memory management is, the less the programmer understand it
02:31:27 <kmc> that'll give you some basic statistics after it quits
02:31:36 <quicksilver> you can certainly make pretty bad mistakes with C++'s automatic-ish memory management.
02:31:40 <kmc> heh
02:31:45 <helino> kmc: thanks, i try it out
02:32:10 <kmc> quicksilver, unfortunately the converse does not hold
02:32:24 <kmc> you can have a C++ project with totally manual memory management that nobody understands ;P
02:32:41 <kmc> quicksilver, which automatic-ish management do you refer to?
02:32:46 <kmc> something like reference-counted smart pointers?
02:32:50 <quicksilver> kmc: for example, yes.
02:33:09 <kmc> what's the easy mistake there?
02:33:14 <quicksilver> automatic variables and automatic constructor/destructor calling
02:33:30 <quicksilver> kmc: failing to correctly understand 'ownership' of contained/pointed-to values
02:33:37 <kmc> mm
02:33:43 <quicksilver> leading to them either never being deallocated (memory leak) or deallocated too early (crash!)
02:33:50 <helino> kmc: thanks for the solution, this seems to be exactly the kind of data I'm intersted in
02:33:58 <kmc> but things like boost::shared_ptr make that significantly less of an issue
02:34:13 <quicksilver> kmc: only if you use them correctly
02:34:13 <kmc> i don't see why that'd be a net loss
02:34:25 <kmc> i think the ways to screw up using shared_ptr are all present without it too
02:34:45 <kmc> someone might hold onto a raw pointer, or they might take a shared_ptr by ref or ptr and not understand the significance
02:34:46 <quicksilver> kmc: in a recent survey of C++ code and developers, 0.01% understood how to use boost::shared_ptr, whilst 0.005% of C++ code actually used it.
02:34:56 <kmc> :(
02:35:24 <kmc> i don't believe that
02:35:33 <kmc> aren't all the mediocre developers drawn to Java and C# these days?
02:35:45 <kmc> not that you need be mediocre to develop in those languages
02:35:55 <kmc> it's just they do a much better job containing the amount of damage one bad developer can do
02:36:09 <kmc> and containing the amount of good that one good developer can do
02:37:01 <Jafet> kmc, you have to jump through hoops to get a raw pointer from shared_ptr
02:37:36 <Jafet> It's just reference counting, though, so it's not memory management
02:37:36 <Jafet> Also automatic memory management is generally incompatible with C++ due to destructors.
02:37:53 <kmc> if you consider shared_ptr "automatic" then it's not
02:38:35 <kmc> Jafet, err,  "T* shared_ptr<T>::get() const" ?
02:38:39 <kmc> it seems to be there, i think i've used it
02:39:13 <quicksilver> Jafet: I think it falls under the general umbrella of "memory management". It's a way to manage allocation and de-allocation. It's just a simple kind.
02:39:33 <Jafet> Well, C++ doesn't have a convention for tagging unsafe things
02:39:37 <zygoloid> kmc: it's a pretty large hoop which presents little difficulty for an experienced jumper :)
02:39:58 <kmc> any C++ programmer is by necessity an experienced hoop-jumper
02:40:05 <quicksilver> kmc: anyway, I was thinking more of the case where T contains internally an S, or an S*
02:40:10 <zygoloid> i'm surprised no-one's mentioned cycles in the shared_ptr ownership graph yet
02:40:14 <helino> speaking of benchmarking, does anyone know a good "problem" for simulating workload that doesn't require much memory?
02:40:16 <kmc> when all else fails, const_cast
02:40:19 <quicksilver> kmc: and T might sometimes be used as a shared_ptr and sometimes not.
02:40:29 <kmc> also i think that garbage collection is not incompatible with destructors if you consider the owner of a GC'd object to be the GC itself
02:40:36 <quicksilver> kmc: and the programmers haven't correctly sorted out the correct 'ownership' strategy.
02:40:50 <kmc> right
02:40:53 <kmc> that's asking for trouble
02:40:53 <quicksilver> believe me, it's possible to make mistakes in these cases :)
02:41:00 <helino> i used a very "dumb" fibonacci implementation, but it uses to much memory
02:41:00 <kmc> but you'd get the same trouble if you never used shared_ptr
02:41:05 <quicksilver> sure.
02:41:08 <Jafet> kmc, C++ is imperative, so destructors may have side effects. And you have to take into account the execution order of things, especially since C++ doesn't have a concurrency model yet.
02:41:19 <kmc> helino, the main benchmark suite for Haskell is called "nofib"
02:41:34 <Jafet> shared_ptr is reference counted, so it removes objects eagerly
02:41:36 <kmc> and there are the Shootout programs too
02:42:10 <helino> kmc: thanks agagin!
02:42:11 <kmc> imperative compared to what?
02:42:17 <kmc> Haskell is imperative, and finalizers may have side effects
02:42:22 <Jafet> Perhaps I meant impure
02:42:46 <kmc> anyway, yes
02:42:54 <quicksilver> Jafet: ... and the subtext of your remark, I guess, is that if you add GC to C++, then destructors can be called at any allocation point (presumably), whilst finalizer may inadvertantly rely on invariants which could easily be violated at an arbitrary allocation point ?
02:42:54 * zygoloid would take RAII over nondeterministic finalization any day
02:43:14 <kmc> RAII is clunky though
02:43:17 <kmc> in C++ i mean
02:43:37 <kmc> bracketing feels much more straightforward for all the simple cases
02:43:50 <quicksilver> the thing about RAII in C++ which annoyed me the most is that it isn't supported by the standard containers
02:44:02 <Jafet> quicksilver, basically not knowing when destructors are called complicates things
02:44:07 <quicksilver> standard containers of boost pointer classes can solve that
02:44:13 <kmc> @quote verbose.and.tedious
02:44:13 <lambdabot> BjarneStroustrup says: any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
02:44:17 <quicksilver> but at that point it starts to feel clunky.
02:44:28 <zygoloid> quicksilver: if you add GC to C++ i think the common wisdom is that finalization doesn't call the destructor
02:44:31 <kmc> having to make an RAII wrapper class for *every* value just to be exception safe is pretty damn clunky
02:45:02 <Jafet> zygoloid, C++ has no GC so the semantics are up to the particular GC extension. Boehm's lets you register finalizers manually.
02:45:16 <zygoloid> Jafet: c++0x will have 'minimal GC support'
02:45:29 <Jafet> Oh, I have not read about that yet.
02:45:37 <quicksilver> I suppose a reasonable compromise would be to run all the queued destructors explicitly and manually at some programmer-chosen safe point
02:45:43 <quicksilver> (top level of main loop, e.g.)
02:45:47 <zygoloid> Jafet: but yeah, with actual existing version of c++ i agree :)
02:46:05 <quicksilver> but I think you still have problems with the ordering of destructors of objects which are inter-related and happen to die at the same time.
02:46:37 <zygoloid> garbage cycles are a pain in any nondeterministic finalization scheme
02:47:39 * zygoloid back to making our 1MLoC C++ codebase threadsafe :O
02:47:42 <quicksilver> how does Java solve this?
02:47:44 <quicksilver> (does it?)
02:48:00 * quicksilver can't remember if Java has destructors or finalisers
02:48:10 <Jafet> zygoloid, http://www.nntp.perl.org/group/perl.golf/2002/07/msg1289.html
02:52:04 <zygoloid> Jafet: haha, that's weirdly beautiful :)
02:54:28 <quicksilver> Jafet: that is awesome.
02:54:33 <quicksilver> in the true meaning of the word 'awesome'
03:08:21 * hackagebot traypoweroff 0.9.0 - Tray Icon application to PowerOff / Reboot computer  http://hackage.haskell.org/package/traypoweroff-0.9.0 (LuisCabellos)
03:14:23 <Koen_> Hello?
03:14:47 <Koen_> I wonder if anyone can help me -- I am trying to install the Haskell Platform on Ubuntu
03:14:53 <Koen_> it is really hard :-(
03:15:23 <winxordie> Koen_: whatcha need?
03:15:52 <Koen_> Well, I really just wanted to have GHC 6.12, but it turns out I first need to install GHC 6.12 before I can install the Haskell platform
03:16:16 <dv-> Ubuntu 10.4 has ghc 6.12
03:16:25 <Koen_> Anyway, after installation, GHC 6.12 tells me: /usr/bin/ld: cannot find -lHSrtsmain
03:17:09 <winxordie> i'm assuming this is the old apt-get and then haskell-platform?
03:21:06 <winxordie> Koen_: I'd recommend reading this: http://sporkcode.wordpress.com/2009/07/11/installing-the-haskell-platform-in-ubuntu/
03:21:28 <winxordie> it's what I used to get the platform running on ubuntu; the comments are also useful
03:31:07 <Koen_> My problem is that GHC 6.12 does not work (so before I even involve the Haskell platform)
03:31:32 <Koen_> As I said, I get the error message: "/usr/bin/ld: cannot find -lHSrtsmain" at link-time
03:32:46 <Jafet> Is there some documentation for packaging ghc programs for systems which don't have ghc? I've looked at the ghc documentation but it's not obvious where this is discussed.
03:37:16 <Jafet> It seems that I could just include all the shared libraries or link statically, but that sounds too obvious
03:37:32 <winxordie> Koen_: I don't think 6.12's the one you're supposed to be using. I tried working with it myself a few months ago and got a stream of errors as well. You're going to have to use 6.10 and the 2009 source if I'm right. Something about them still working stuff out?
03:38:11 <winxordie> hypothetically, you could just cabal update afterwards whenever they've fixed it
03:38:36 <winxordie> *2009 platform source
03:38:36 <quicksilver> I don't think that's true.
03:38:37 <Koen_> Well, when I install the Haskell Platform it tells me to use GHC 6.12
03:38:43 <quicksilver> I think you should never, ever, cabal update.
03:38:47 <quicksilver> unless something has changed.
03:39:30 <winxordie> quicksilver: wouldn't that be the whole point of platform updating?
03:39:34 <quicksilver> Also, as far as I know, HP-2010 is 'out', and should work on linux, and in particular should work on ubuntu which is a pretty common linux.
03:39:44 <quicksilver> winxordie: as far as I know, cabal update just breaks everything.
03:39:57 <quicksilver> if I'm wrong, hopefully Saizan or dcoutts or some such knowledgeable type will correct me.
03:40:07 <quicksilver> cabal update can't (or couldn't) work out which libraries it was safe to upgrade.
03:40:26 <Koen_> The configure script has: "REQUIRED_GHC_VER=6.12.1"
03:40:45 <winxordie> wow. This is worse than I thought.
03:41:02 <Koen_> Well, I thought so too, quicksilver, but it is a nightmare to install HP-2010 on Ubuntu
03:41:28 <Koen_> I wanted to do this to get GHC 6.12, but I first need to install GHC 6.12 (which does not work), and then compile the HP-2010 using it
03:41:32 <Jafet> I have 6.12.1 installed on ubuntu, out of the box.
03:41:38 <Jafet> Download the tarball and unpack.
03:42:06 <Koen_> Installation went fine, but linking says "/usr/bin/ld: cannot find -lHSrtsmain"
03:42:17 <quicksilver> Koen_: as far as I know, HP releases are always linked to GHC versions
03:42:25 <quicksilver> HP-2010 is therefore, for 6.12.1
03:42:34 <Koen_> OK, but why do I need to compile from source?
03:42:46 <quicksilver> You shouldn't. The binary package should work for you.
03:42:49 <Koen_> Isn't the point with Haskell Platform to "just install and go"?
03:42:52 <quicksilver> yes.
03:42:55 <winxordie> lol.
03:43:07 <Koen_> which binary package?
03:43:09 <quicksilver> that ld error sounds like it might be as simple as a directory missing from /etc/ld.so.conf
03:43:47 <Koen_> On: http://hackage.haskell.org/platform/linux.html it says "Information for other systems: Ubuntu"
03:44:01 * quicksilver was going to suggest http://www.haskell.org/ghc/download_ghc_6_12_1.html#binaries
03:44:14 <Koen_> And there I find instructions to compile the HP using GHC 6.12
03:44:40 <Koen_> I used http://haskell.org/ghc/download_ghc_6_12_1.html to install GHC 6.12.1
03:44:47 <Koen_> exactly
03:44:54 <Jafet> Reading that page, I'd just install it with cabal
03:44:56 <Koen_> installation went fine, it is a binary installation
03:45:03 <Koen_> but I don't have cabal!
03:45:07 <Jafet> Why not!
03:45:21 <Koen_> because I have not managed to install the Haskell Platform!
03:45:32 <winxordie> oh chicken and egg.
03:45:38 <quicksilver> hmm. Maybe they decided not to do binary dists of HP for linux.
03:45:44 <Koen_> I may have been naive in thinking that, in order to install Haskell, I just download and install the Haskell Platform
03:45:56 <quicksilver> thinking they should be distribution specific?
03:46:17 <Koen_> but I first need to install GHC 6.12, and then cabal? And then what, go to hackage and install some more packages? So that I can *compile* HP-2010?
03:46:57 <dcoutts> quicksilver: right, we do not provide binaries on linux atm
03:46:57 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
03:47:13 <quicksilver> dcoutts: what advice would you give Koen_ ? What advice should I give the next person to ask?
03:47:23 <dcoutts> it's fairly straightforward though, install ghc and then grab the HP tarball
03:47:26 <quicksilver> what is the best way to install HP on ubuntu, in other words.
03:47:43 <dcoutts> quicksilver: for new users I'd suggest just using what comes with ubuntu
03:47:51 <Koen_> winxordie: what directory do you think is missing from /etc/ld.so.conf?
03:48:03 <Koen_> which is GHC 6.10
03:48:06 <dcoutts> quicksilver: there's no need for new users to be playing with beta releases
03:48:16 <winxordie> Koen_: I can't make heads or tails out of it is the thing. I've tried looking around for it.
03:48:16 <Koen_> no Haskell Platform, no cabal
03:48:39 <quicksilver> dcoutts: then we have a communication problem
03:48:46 <dcoutts> if ubuntu is still missing cabal-install, then that can be installed separately
03:48:53 <dcoutts> separately/directly
03:48:57 <quicksilver> dcoutts: nothing on http://hackage.haskell.org/platform/linux.html or http://hackage.haskell.org/platform/ suggests that there is anything remotely beta about HP-2010
03:49:02 <winxordie> 6.12 is in beta eh?
03:49:07 <quicksilver> dcoutts: it all looks very shiney and recommended and installable
03:49:16 <winxordie> I didn't know that 2010 was beta.
03:49:17 <dcoutts> quicksilver: sigh, yes, I've pointed this out to dons
03:49:19 <Koen_> AH, is HP-2010 in beta??
03:49:28 <Koen_> grrr
03:49:30 <Jafet> Koen, cabal-install is available separately, download and install that
03:49:37 <Koen_> and GHC 6.12.1 too?
03:49:38 <Jafet> Then you have cabal, which is useful on its own
03:49:50 <Jafet> No, 6.12 is a release
03:49:50 <quicksilver> dcoutts: OK, at least we agree where the communication fault is.
03:50:05 * quicksilver adds "HP-2010 is in beta, are you sure you want to be a beta-tester?" to his list of stock responses.
03:50:42 <Jafet> unsafeTestPlatform
03:50:58 <dcoutts> quicksilver: but if people are going to the HP download site rather than using their distro packages, then there's not a great deal of difference between the last HP and the current beta
03:51:46 <dcoutts> quicksilver: it's not that I would be saying to go install the older version instead, rather to use your distro packages unless you specifically need 6.12, most distros have 6.10 and cabal-install (except it seems debian/ubuntu)
03:52:19 <Koen_> OK, I just tried to install cabal-install and get the error: /usr/bin/ld: cannot find -lHSrtsmain
03:52:20 <Koen_> :-P
03:52:30 <Koen_> I should uninstall GHC 6.12.1 then
03:52:55 <Koen_> But if GHC 6.12.1 is not beta, why doesn't it work on my machine?
03:52:55 <quicksilver> dcoutts: debian has HP-2010 in sid, I think. But only 6.8 in stable.
03:53:03 <dcoutts> Koen_: that's pretty weird, not seen that before, ghc specificlally passes -L flags
03:53:20 <Jafet> Then your binutils might be borked.
03:53:25 <Koen_> Well, it only happens when I use my shiny new 6.12.1 installation
03:53:43 <Koen_> And, yes, as it happens, I specifically want 6.12 because I am compiling parallel programs
03:54:06 <Koen_> Ah, my binutils is borked, we are getting somewhere
03:54:15 <Koen_> How do I unbork my binutils?
03:54:24 <dcoutts> sounds unlikely
03:56:58 <pastorn> Koen_: do you *have* to use the platform? on ubuntu i just download the binary blob for GHC and then use cabal for my needs
03:57:30 <pastorn> it seems like the platform is mostly for windows users
03:58:46 <quicksilver> well, the platform is a good way to get a working cabal-install
03:59:01 <quicksilver> (including the libraries that cabal-install itsel requires)
03:59:13 <quicksilver> so it replaces the old bootstrap.sh, which failed in various circumstances.
03:59:21 <dcoutts> pastorn: it's not just for windows users, it's not just to help people get stuff installed, it's also to tell people what versions of packages to use so that we get greater compatibility across the community
03:59:27 <pastorn> quicksilver: never failed for me :)
04:00:05 <Jafet> Hm, couldn't the bootstrap be done in haskell?
04:04:29 <Koen_> pastorn: I just thought the platform was the easiest way
04:04:42 <Koen_> I also want to know what to recommend to my students when I teach my next Haskell course
04:04:55 <Koen_> right now, HP is something I do *not* recommend
04:05:39 <pastorn> Koen_: for ubuntu you should tell them to do 'sudo apt-get install ghc'
04:05:55 <Koen_> Duncan, BTW, about the server we have here: The current connection is ~100Mbit. If you keep below 100Gb per day, nobody will notice much. If you go much higher than that, we will have to move the server, which will mean extra costs for us.
04:06:31 <Koen_> pastorn, yes, that is what I tell them now, but they don't get any interesting libraries
04:06:40 <Koen_> so they will have to install cabal
04:06:48 <Koen_> and then cabal install the libraries
04:06:57 <Koen_> the HP is supposed to make all of this easy, no?
04:07:14 <quicksilver> if I had students using ubuntu, I would set up a local repository
04:07:28 <pastorn> quicksilver: that sounds like a good idea :)
04:07:29 <quicksilver> which included GHC 6.12 (assuming there is some reason you want 6.12, e.g. you are playing with the new parallel stuff)
04:07:35 <quicksilver> and the HP, as .debs obviously.
04:07:45 <Koen_> Why isn't there such a repository on haskell.org?
04:07:46 <quicksilver> I would start by looking at the .deb packaging in debian sid
04:07:51 <dcoutts> Koen_: I see, I think we're looking at ~2Gb per day forthe community server
04:07:55 <quicksilver> which is probably close to what you need for ubuntu.
04:08:01 <yuriks_> do the "ghc" packages in distros contain cabal?
04:08:21 <quicksilver> Koen_: because haskell.org doesn't want to work out how to cater for the intracacies of every possible dpkg-based distribution
04:08:23 <ivanm> yuriks_: yes
04:08:24 <quicksilver> (I assume)
04:08:26 <ivanm> but not cabal-install
04:08:29 <quicksilver> yuriks_: and yes, "No"
04:08:30 <dcoutts> Koen_: the debian people organise their own packages, that's probably the right way to go rather than trying to circumvent them (except for local uses)
04:08:44 <yuriks_> O_o??
04:08:49 <quicksilver> because what you meant was "the program 'cabal'" which is part of the package cabal-install
04:09:00 <quicksilver> not the library "Cabal" which is, indeed, part of GHC
04:09:07 <quicksilver> this naming mistake will haunt us forever
04:09:17 <ivanm> quicksilver: well, it comes with GHC; I wouldn't say it's _part_ of GHC
04:09:25 <quicksilver> it's pretty fundamental IMO.
04:09:44 <quicksilver> the ghc-pkg is part of GHC, Cabal-the-library is tightly integrated with that.
04:09:52 <Koen_> OK, I am still left with my problem, which really has nothing to do with the Haskell Platform.
04:10:11 <pastorn> Koen_: true :)
04:10:30 <pastorn> but a private ubuntu/debian repository is probably the simplest way to go
04:10:47 <pastorn> (seen from a students perspective)
04:10:51 <idnar> there's a haskell-platform package now
04:10:59 <Koen_> When I binary-install GHC 6.12.1 on Ubuntu, I get a strange linking error: /usr/bin/ld: cannot find -lHSrtsmain
04:11:21 <idnar> which depends on all of the relevant packages, although not the precise versions specified by the Haskell Platform (you'll just get whatever version is in Debian/Ubuntu at the time)
04:11:57 <yuriks_> wouldn't the simplest answer be "ship cabal-install with ghc"?
04:12:23 <Koen_> yuriks: that is what the Haskell Platform is supposed to be
04:12:24 * roconnor thought cabal-install was supposed to be shipped with ghc
04:13:02 <roconnor> HP is a collection of "standard" libraries that our dictator had declared are standard
04:13:06 <yuriks_> Koen_: but why? is cabal-install such a humongeous monster you need to ship it separately? haskell platform could simply be a starting set of libraries
04:13:45 <pastorn> Koen_: what OS are you running (precisely)?
04:13:46 <Koen_> asking "why" does not always lead to wisdom
04:13:53 <Koen_> Ubunty Karmic
04:13:56 <Koen_> u
04:13:56 <blackdog> Koen_: but wh
04:13:57 <blackdog> y?
04:14:08 <blackdog> sorry:) couldn't resist.
04:14:12 <Koen_> :)
04:14:51 <pastorn> Koen_: point me to an iso, please :)
04:15:04 <yuriks_> Koen_: I don't know that saying =P
04:15:04 <Koen_> Anyway, I thought the Haskell Platform would make the whole GHC/libraries/Cabal/hackage-jungle easier, but I was naive
04:15:31 <Koen_> pastorn: I don't believe I used an ISO, I upgraded from Jaunty
04:16:09 <ivanm> quicksilver: if it was part of GHC, then it wouldn't be available separately or be upgraded
04:16:17 <quicksilver> cabal-install can't ship with GHC because it depends on too many libraries which do not ship with GHC
04:16:35 <roconnor> quicksilver: but I thought the whole idea was to ship cabal-install with ghc
04:16:35 <quicksilver> GHC used to ship with a large bunch of arbitrarily chosen libraries
04:16:41 <yuriks_> hmmm
04:16:42 <quicksilver> roconnor: you were wrong. That was never the idea.
04:16:43 <pastorn> Koen_: i'll try out what will happend when the course actually starts (karmic fresh install with no ghc preinstalled) and see what happends...
04:16:43 <dcoutts> quicksilver: what is actually the problem here btw?
04:17:03 <quicksilver> this was bad because it trapped those libraries into the GHC versioning timetable
04:17:09 <quicksilver> and made it very hard to release patches to them etc.
04:17:10 <ivanm> roconnor: we have a dictator?
04:17:32 <ivanm> quicksilver: agreed; this is still a problem with bytestring, etc.
04:17:33 <quicksilver> So, the GHC team decided to strip down GHC (slowly) towards only shipping with a core of libraries which are actually needed by GHC itself
04:17:38 <dcoutts> quicksilver: in principle it should be simply get ghc, get HP tarball. I realise it's not quite as simple as on Windows and OSX where we ship combined binary installers but it's not that hard for people is it? what's the issue?
04:17:45 <quicksilver> the haskell-platform fills the gap
04:17:57 <quicksilver> the haskell-platform is to contain those libraries which 'most people' would 'reasonably' want
04:18:01 <yuriks_> makes sense
04:18:02 <roconnor> ivanm: yes, but I am exagerating a little
04:18:04 <quicksilver> a bit like the set which used to come with GHC itself.
04:18:21 <quicksilver> dcoutts: I'm not sure. I think the problem is that the GHC 6.12.1 binary doesn't work on Koen_'s ubuntu installation.
04:18:31 <quicksilver> dcoutts: and therefore he can't even get as far as installing the HP from source.
04:18:36 <dcoutts> ok, I see
04:18:43 <dcoutts> then we need a diagnosis of that
04:18:48 <ivanm> roconnor: *phew* I thought we had an intellectual oligarchy...
04:18:48 <quicksilver> the problem I"m currently addressing was just misinformation
04:18:55 <dcoutts> quicksilver: ok good :-)
04:18:56 <quicksilver> I was trying to set the record straight.
04:19:03 <ronwalf> Anyone really familiar with deriving Data and Typeable ?
04:19:06 <quicksilver> ivanm: we have an effortocracy.
04:19:11 <zygoloid> dcoutts: the error e's getting is "/usr/bin/ld: cannot find -lHSrtsmain"
04:19:27 <quicksilver> ivanm: if you can be bothered to do the work, you have an excellent chance of (de-facto) making the decisions simply because you did the work.
04:19:52 <quicksilver> if you can't be bothered to do any work, but do talk a lot on IRC, then you become a #haskell IRC op, but you don't really help solve hte problems :P
04:20:20 <roconnor> ivanm: oh, maybe it is an oligarchy:  Is there a group of people responsible for the contents of HP?
04:20:25 <zygoloid> but you do get to indoctrinate people who /will/ do the work with your opinions ;-)
04:20:42 <quicksilver> very occasionally.
04:20:54 <quicksilver> the intersection between {people who do work} and {people who listen to quicksilver} is awfully small, though.
04:20:57 <dcoutts> Koen_: if you've got a moment, perhaps you can talk to people in #ghc and work out what's going on with 6.12.1 on your box
04:22:30 <Koen_> dcoutts: good point
04:25:07 <Koen_> dcoutts: "Cannot send to channel #ghc"?
04:25:20 <pastorn> Koen_: /join #ghc
04:26:19 <ivanm> roconnor: dcoutts, etc. and the other people on the libraries list...
04:26:35 <ivanm> quicksilver: heh
04:27:37 <roconnor> quicksilver: cabal comes with ghc?
04:27:45 <ivanm> roconnor: yes
04:27:45 <quicksilver> roconnor: cabal-the-library comes with GHC
04:27:48 <ivanm> but not cabal-install
04:27:56 <roconnor> quicksilver: ah, that must have been my confusion
04:27:57 <quicksilver> cabal-the-program-which-is-part-of-cabal-install does not
04:28:08 <quicksilver> this naming decision will haunt us forever
04:28:13 <quicksilver> (as I have said before and will say again)
04:29:31 <ivanm> quicksilver: cabal-the-program-is-the-whole-point-of-the-cabal-install-package
04:29:39 <quicksilver> ivanm: indeed.
04:34:30 * hackagebot haxr 3000.6 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.6 (GracjanPolak)
04:40:06 <shapr> GOOD MORNING #HASKELL!
04:40:11 * shapr boings furiously
04:40:23 <quicksilver> morning shapr
04:40:30 <shapr> quicksilver: How's code?
04:40:31 <blackdog> you make me tired just looking at you
04:40:39 <blackdog> metaphorically speaking
04:40:46 <fax> hi shapr
04:40:51 <shapr> Good morning fax!
04:40:54 <quicksilver> shapr: bad, because it's not haskell.
04:40:59 * shapr throws drop bears at blackdog 
04:41:17 <blackdog> are you mad? they're forty foot tall and razor sharp!
04:41:17 <fax> im watching pom poko
04:41:41 <shapr> blackdog: You're right, picking them up could be dangerous for my health!
04:41:54 <fax> it's a cartoon about racoons that can cast magic spells... reminds me of #haskll ???
04:42:25 * shapr looks around for masked bandits
04:43:19 <ivanm> hey shapr!
04:43:30 <ivanm> shapr: why did you get jlouis to change haskelltorrent to combinatorrent?
04:43:38 <shapr> Because I like the name :-)
04:43:49 <shapr> I think cheesy names entertain people so they're more likely to download and try something.
04:44:54 <Philonous> I love sound reasoning in the morning.
04:45:24 <ivanm> but combinatorrent doesn't even make sense...
04:45:30 <quicksilver> although they kind of person to be amused by that (someone who knows what a combinator is) is probably quite likely to try haskell anyway.
04:45:35 <ivanm> oh, wait, as in COMBINATORrent?
04:45:38 <quicksilver> funny things don't have to make sense!
04:45:49 * ivanm was mentally pronouncing it differently
04:45:58 <ivanm> as in "combina-torrent"
04:46:29 <IgTest> test
04:46:49 <quicksilver> IgTest: can't hear you at the back, can you speak up?
04:54:15 <byorgey> good morning shapr!
04:58:29 <ivanm> hey byorgey
05:00:28 <Janni> Hello. I just noticed that haddockk (invoked by cabal install --enable-documentation) doesn't seem to generate the "instances" list anymore. Anyone got an idea why?
05:04:35 <ivanm> Janni: you sure?
05:04:40 * ivanm checks
05:05:04 <ivanm> Janni: for the class or for the data type
05:05:11 <Janni> I am sure, but I suppose that's my local setup.
05:05:11 <Janni> Both.
05:05:21 <ivanm> Janni: which version of cabal, cabal-install and haddock?
05:05:37 <ivanm> because it's definitely working here :s
05:05:40 <quicksilver> haddock had a long standing issue where the instances were only generated when everything was in scope?
05:05:51 <quicksilver> that is, haddock needs to be able to see the types, and the classes, simultaneously
05:05:56 <ivanm> (1.8.0.4, 0.8.2 and 2.6.0 respectively)
05:06:09 <Janni> haddock version 2.6.0  cabal-instnall version 0.8.0  using version 1.8.02 of the Cabal library
05:06:11 <quicksilver> so it should work fine for the case that the class and type and both inside the package being documented.
05:06:17 <ivanm> however, I _hate_ how haddock reveals instances of type classes that aren't exported... >_>
05:06:33 <quicksilver> there is no such thing as an unexported instance.
05:06:33 <ivanm> Janni: maybe it's a scoping issue like quicksilver says...
05:06:39 <quicksilver> instances are perfect and global
05:06:46 <quicksilver> to say anything else is HERESY!
05:06:47 <ivanm> quicksilver: even if the class isn't exported?
05:06:49 * quicksilver prepars the fires.
05:07:01 <ivanm> I'm not saying they aren't global...
05:07:16 <quicksilver> I'm not sure.
05:07:24 <ivanm> I'm just saying that if a user isn't meant to know about a class even existing, why is haddock going and telling them about it (even if they can't use it)?
05:07:30 <quicksilver> isn't exporting the class just about the ability to define new instances?
05:07:38 <quicksilver> even an un-exported class can appear in function signatures
05:07:48 <quicksilver> so you need to know about it so you know which types you're allowed to use.
05:08:10 <quicksilver> e.g. I export a function Foo x => x -> x
05:08:18 <quicksilver> even though I don't exxport the class Foo or any of its methods
05:08:24 <quicksilver> so you can't make new instances or manipulate them
05:08:37 <quicksilver> you still want to know what types are instances of Foo so you know what you can pass to my function?
05:08:40 <ivanm> quicksilver: well, I don't export the class, and I don't export any functions which have the class as a constraint in the type signature
05:08:43 <shapr>  byorgey: Goood morning!
05:08:47 <shapr> It's a great day for code!
05:09:35 <quicksilver> ivanm: that's a good point, yes.
05:09:45 <quicksilver> ivanm: but I think my answer explains how haddock behaves?
05:09:45 <dobblego> ivanm, I've hit that problem before
05:09:54 <ivanm> quicksilver: yeah
05:09:56 <quicksilver> (it can't/doesn't distinguish your case from mine)
05:10:10 <Janni> Looks like the instance lists are present in the HTML files. They just don't seem to show. I'm investigating....
05:10:42 <ivanm> quicksilver: I just tried it: the class isn't exported, so there's no way of even telling if it exists
05:10:54 <ivanm> doing an :info on a data type that instantiates it doesn't even real that class... >_>
05:11:08 <quicksilver> hmm
05:11:14 <quicksilver> that does sound like a haddock bug then
05:11:44 <ivanm> quicksilver: so I wonder if your scenario is even valid in cases like that...
05:11:45 * ivanm tests
05:13:58 <ivanm> quicksilver: however, if you export a function that uses that typeclass, its type signature is fully qualified but it works
05:14:03 <tibbe> any students who want to sign up for summer of code for haskell.org? Application deadline is tomorrow! http://www.haskell.org/pipermail/haskell-cafe/2010-April/075870.html
05:14:42 <tibbe> dcoutts: we've haven got as many student applications as I'd hope. The guy (Thomas) who's talking a lot about Cabal testing hasn't signed up for example.
05:14:42 <Itkovian> monad question. If I have an f :: a -> ErrorT String m b, and a g :: ErrorT String m' c where m' = StateT String m, how do I call f to get a result to further use in g? Given that >> and >>= both require the monad to be the same in both arguments.
05:14:54 <ivanm> tibbe: weird...
05:15:03 <ivanm> Itkovian: lift?
05:15:05 <ivanm> @hoogle lift
05:15:05 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
05:15:06 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
05:15:06 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
05:15:10 <dcoutts> tibbe: give him a kick!
05:15:29 <dcoutts> tibbe: send out more emails, when do applications close?
05:15:36 <zygoloid> if a module exports f :: Foo x => x -> x, but not the class Foo, and I want to write g :: Foo x => Int -> x -> x, can I give g a type signature?
05:16:05 <quicksilver> Itkovian: well, you have to think how that could make sense.
05:16:18 <quicksilver> Itkovian: how do you know what state to use to run "g" with?
05:16:51 <quicksilver> you can convert "f" which doesn't use state at all into an action which has a string State (which it ignores)
05:16:56 <quicksilver> and then they would be compatible.
05:17:15 <quicksilver> normally you try to work with signatures that use the typeclasses, though, not the FooT types directly.
05:17:22 <Itkovian> well, f does use state in the m and I need that state also in m'
05:18:42 <quicksilver> Itkovian: but my point is that f doesn't use the "StateT String" part
05:18:47 <quicksilver> so they are incompatible
05:18:56 <quicksilver> ...but you could obviously 'upgrade' f to use, but ignore, that.
05:20:12 <quicksilver> but it would all be simpler, possibly even automaticaly, if (f :: MonadError String m => a -> m b) and (g :: MonadState String m, MonadError String m => m c)
05:20:13 <Itkovian> quicksilver: indeed. it does not need that. the String is returned by f in the 'a', i.e., I need to get it out of the function value and into the State to pass it on.
05:20:18 <Itkovian> I don't think upgrading would be a good idea.
05:20:40 <quicksilver> the intended way to use the tranformers is via the typeclasses, not directly.
05:22:09 * Itkovian thinks.
05:25:19 <ivanm> obviously I'm the first person to use Cabal 1.8's new "executable depends on library" feature: http://hackage.haskell.org/trac/hackage/ticket/656
05:25:49 <dcoutts> ivanm: actually not, darcs was first
05:26:21 <ivanm> dcoutts: oh, for HEAD?
05:26:29 * ivanm wonders if they have this problem as well...
05:26:39 <ivanm> then again, darcs haddock docs are non-existent last I checked... >_>
05:26:51 <dcoutts> ivanm: I expect they do generate docs for the lib, not the tiny little exe
05:27:03 <ivanm> *nod*
05:27:12 <ivanm> yet I'm not trying to generate docs for the exe...
05:27:29 <dcoutts> oh ok
05:28:08 <ivanm> wow... doing "darcs pull" on the darcs source is _slow_ ... >_>
05:30:10 <tibbe> dcoutts: tomorrow, I emailed everyone who talked about applying on haskell-cafe
05:30:18 <tibbe> dcoutts: I emailed them yesterday
05:30:26 <tibbe> dcoutts: not all mentors are signed up either
05:30:26 <Itkovian> quicksilver: It would of course make sense for all functions to remain in the same monad stack. I am doing this for all exported functions, but I figures it would be better not to burden a module local function with the extended stack, of which I am only using the lower part.
05:30:29 <ivanm> dcoutts: :o haddock seems to be working for darcs :o
05:30:45 <quicksilver> Itkovian: I don't think all functions should be in the same monad stack.
05:30:50 * hackagebot alsa-pcm-tests 0.1 - Tests for the ALSA audio signal library.  http://hackage.haskell.org/package/alsa-pcm-tests-0.1 (HenningThielemann)
05:30:56 <quicksilver> Itkovian: I think functions should depend on precisely those capabilities which they require.
05:31:11 <quicksilver> (I.e. functions which don't modify the state should declare that in their signatures by not having that part of the state)
05:31:14 <quicksilver> that's how the typeclasses work
05:31:17 <quicksilver> they're like capabilities.
05:31:31 <quicksilver> s/state)/stack)/
05:32:03 <ivanm> dcoutts: *sigh* now I need to work out why darcs's haddock docs build but not mine... >_>
05:32:28 <zygoloid> @type let returnStateT a = StateT $ \s -> liftM (flip (,) s) a in ErrorT . returnStateT . runErrorT
05:32:29 <lambdabot> forall e a (m :: * -> *) s. (Monad m) => ErrorT e m a -> ErrorT e (StateT s m) a
05:33:59 <Itkovian> quicksilver: so then it's normal that my f, which uses part of the m' stack, i.e., the m is declared as such
05:35:35 <ivanm> dcoutts: I think I know why darcs works; they don't have the executable depend upon the library
05:35:45 <ivanm> tbh, I'm not sure why they're using cabal 1.8
05:36:03 <ivanm> the patch description is " Require Cabal 1.8, fix the build-deps dump in --exact-version."
05:37:22 <ronwalf> It's a bit of cross-IRCing, but can anyone figure out why ghc 6.10 likes this code but 6.12 doesn't? : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24746#a24750 (second one)
05:37:52 <ivanm> ronwalf: error messages?
05:38:33 <ivanm> but at a guess, something changed with syb...
05:39:52 <ronwalf> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24751#a24751
05:40:08 <ivanm> ronwalf: why not just do what it says?
05:40:16 <ivanm> oh, wait, forget that
05:40:30 <ivanm> no, wait, don't forget that
05:40:46 <ronwalf> ivanm: Because it doesn't work
05:40:53 <ivanm> *sigh* I'm confused
05:41:20 <ivanm> ronwalf: is that being generated by the first paste you gave which has the deriving statements for Const and Var?
05:41:28 <ronwalf> ivanm: Those instances already have deriving statements
05:41:32 * ivanm has never used Data, so doesn't really know what's going on
05:41:52 <ronwalf> Yes, that's where the error is coming from
05:42:16 <ronwalf> Adding the deriving instances doesn't work.  It actually seems to be that Data (Const :+: Var) isn't found
05:42:36 <ivanm> ronwalf: make Expr derive Data ?
05:42:39 <ivanm> I think that's your problem...
05:43:49 <ronwalf> It does derive data: "deriving instance (Typeable1 a, Data (a (Expr a))) => Data (Expr a)"
05:47:11 <ivanm> ronwalf: oh, right
05:47:29 <ivanm> any particular reason for not just having "deriving(Data)" on the end of the newtype definition?
05:50:20 <ronwalf> ivanm: There seem to be recursive issues
05:50:26 <ronwalf> Can't figure out how to make it work
05:50:49 <ivanm> neither can I ;-)
05:50:57 <ronwalf> Anyone getting a redirect loop with hackage trac ?
05:51:54 <ivanm> as in the trac for hackage itself?
05:52:01 * ivanm was just at the cabal trac with no problems...
05:52:12 <SamB_XP> ivanm: same trac, dat!
05:52:25 <ivanm> http://hackage.haskell.org/trac/hackage/wiki/HackageDB loads for me...
05:52:29 <dcoutts> ronwalf: what url?
05:52:38 <ronwalf> ivanm: I think the issue is that 'Data' for "newtype Expr f = In (f (Expr f)) " requires an instance for Data (f (Expr f)) first
05:52:45 <ivanm> heh
05:52:47 <ronwalf> dcoutts: http://hackage.haskell.org/trac/ghc/prefs/account
05:53:31 <dcoutts> ronwalf: works for me when logged out or logged in
05:53:35 <ronwalf> My code hurts my head so much
05:53:38 <ivanm> ronwalf: I get an error message
05:53:43 <ivanm> "Unknown preference panel"
05:53:48 <ivanm> (I'm logged out)
05:54:29 <Igloo> ronwalf: Does deleting cookies and restarting your browser fix it?
05:56:45 <ronwalf> Nope.  Logging in as my user kills it dead
05:57:01 * ronwalf needs trac for ghc trac
06:01:34 <quicksilver> ronwalf: using a proxy or mobile internet or both?
06:01:43 <quicksilver> GHC's trac doens't work for me over orange mobile internet
06:01:50 <quicksilver> their proxy breaks HTTP auth, I presume.
06:02:04 <quicksilver> (which is stupid, but doesn't annoy many people because almost no one uses HTTP auth)
06:02:29 <ronwalf> quicksilver: Neither.  Apparently my account went wonky, so Igloo deleted it and I re-registered
06:02:48 <quicksilver> ok, that's good.
06:02:54 <Igloo> ronwalf: So does it work now?
06:03:05 <ronwalf> Yes
06:03:07 <ronwalf> thank you
06:06:38 <shapr> @yow!
06:06:38 <lambdabot> Couldn't find fortune file
06:06:43 <shapr> I need to fix yow.
06:06:50 <fax> kick out the humans!
06:07:35 <SamB_XP> @yow!
06:07:35 <lambdabot> Couldn't find fortune file
06:07:43 <SamB_XP> @arr
06:07:43 <lambdabot> I'll keel haul ya fer that!
06:07:48 <SamB_XP> @arr
06:07:48 <lambdabot> I want me grog!
06:07:54 <SamB_XP> @arr id
06:07:54 <lambdabot> Swab the deck!
06:08:04 <shapr> Yarr, lambdabot won't cabal install because of the same quickcheck confusion!
06:08:20 * shapr kicks quickcheck
06:10:40 <shapr> What's the fix for the QuickCheck confusion?
06:13:36 <quicksilver> shapr: I don't know. Let's tear the whole packaging system down and start again?
06:13:53 <shapr> :-/
06:14:15 <quicksilver> I may just be in a bad mood since I'm behind on my todo list for today and haskell isn't even on it.
06:14:18 <ivanm> shapr: make everyone use QC-2
06:14:25 <shapr> I like that plan.
06:14:26 <quicksilver> but I genuinely don't know the solution, and it makes me sad.
06:14:28 * shapr hugs quicksilver 
06:14:31 <dmhouse> Hi guys. I've got an algorithm I've written in nice pure Haskell. Now I've realised that in order to work correctly it needs to make a random choice at a point quite deep down. What's a nice way to manage this?
06:14:33 <ivanm> shapr: even better: stop people from having QC, HUnit, etc. as unconditional deps
06:14:40 <shapr> ivanm: How would that work?
06:14:43 <dmhouse> It seems draconian to rewrite the whole thing in IO
06:14:48 <quicksilver> dmhouse: no need to use IO.
06:15:00 <quicksilver> dmhouse: just give it a random gen as a parameter
06:15:05 <ivanm> dmhouse: either pass a seed all the way down, or use bos' state-based PRNG library
06:15:06 <shapr> ivanm: Can cabal specify optional parts?
06:15:13 <ivanm> (which might need a state as well... >_>)
06:15:17 <dmhouse> quicksilver: oh, of course
06:15:17 <ivanm> shapr: configure flags
06:15:21 <shapr> hmm
06:15:33 * dmhouse suddenly realises why Data.Random is actually structured in the way that it is :)
06:15:39 <dmhouse> (It's only ever gotten in the way before.)
06:15:58 <shapr> If you're already using monads, you could wrap it up that way too.
06:16:08 * hackagebot regular 0.2.4 - Generic programming library for regular datatypes.  http://hackage.haskell.org/package/regular-0.2.4 (JosePedroMagalhaes)
06:16:10 <quicksilver> ivanm: but isn't the fundamental problem that whenever commonly used LibraryX gets a new version, and some packages but not others update to use it, users are screwed?
06:16:13 <ivanm> shapr: with the except of split packages (ala happstack) that need the testing stuff from other packages (since there's no way of specifying that package foo needs package bar build with flag baz enabled), most libraries should be able to split off the testing stuff into separate optional modules
06:16:33 <quicksilver> as soon as LibraryX gets a new version, I have to make a stark choice
06:16:38 <shapr> Yeah, that would make sense.
06:16:47 <ivanm> quicksilver: right, but in practice the only libraries with this problem are parsec and QC
06:16:49 <shapr> ivanm: So, do you want to write a blog post about how to do that?
06:16:52 <quicksilver> upgrade to new version and throw away *everything* I had which relied directly or indirectly on the old version
06:17:05 <quicksilver> or stick with the old and hold back from anything which uses the new
06:17:06 <ivanm> realistically, the problem is that there's no notion of non-exported deps, so ghc-pkg/cabal play it safe for now
06:17:07 <dmhouse> shapr: no, the code is nonmonadic for now
06:17:14 * dmhouse passes a random generator
06:17:14 <ivanm> shapr: I have to an extent...
06:17:23 <quicksilver> (I always pick the second, which is why until very recently I was using GHC 6.6)
06:17:24 <shapr> non-exported deps?
06:17:31 <ivanm> shapr: as in I wrote a bitching blog post, and someone told me how to do the flag stuff properly
06:17:33 <ivanm> which I now use
06:17:36 <shapr> ah!
06:17:58 <ivanm> shapr: most users of libraries that use parsec have no idea that it uses parsec since the parsec stuff isn't exported
06:17:59 <quicksilver> ivanm: as hackage gets better/more popular good LibraryXs presumably become more common.
06:18:30 <ivanm> as such, there should be no reason why two different versions of parsec are used by different deps
06:18:52 <ivanm> quicksilver: true, though this is likely to only occur with "lower level" libs
06:19:01 * ivanm never has the parsec problem because he uses polyparse!
06:19:22 <quicksilver> like syb, or derive, or th
06:19:49 <quicksilver> I see data-accessor getting more popular maybe that will be the next victim.
06:19:54 <quicksilver> I'm just moaning though, I'll be quiet.
06:19:58 <shapr> heh
06:20:02 <shapr> So what's the real fix?
06:20:27 <fax> shapr - I reinstall GHC sometimes
06:20:37 <shapr> And even better, what's the solution to getting lambdabot to be able to cabal install?
06:20:39 <ivanm> quicksilver: hmmm...
06:20:44 <shapr> NMU the libs that require QC1 ?
06:20:57 <ivanm> shapr: for ghc-pkg and cabal to recognise "soft" dependencies that are only used internally
06:21:10 <ivanm> shapr: AFAIK, lambdabot _is_ cabal-installable now...
06:21:15 <ivanm> at least for users, not global install
06:21:34 <shapr> it's not working for me
06:21:45 <ivanm> what's the error?
06:22:53 <SamB_XP> ivanm: so that you could have QC1 and QC2 used at the same time ?
06:23:14 <ivanm> SamB_XP: so that you can have foo depend on bar and baz, where bar uses QC1 and baz uses QC2
06:23:22 <ivanm> (and foo might even use one)
06:23:27 <SamB_XP> that's what I meant
06:23:47 <ivanm> then yes ;-)
06:23:55 <ivanm> SamB_XP: I interpreted as the one package using both ;-)
06:25:26 <ivanm> @ask mornfall for your cabal-1.8 patch for darcs, is it correct that it still builds all the modules twice (once for the library and once for the executable)?
06:25:27 <lambdabot> Consider it noted.
06:25:34 * ivanm -> land of nod
06:25:36 <ivanm> g'night all
06:25:39 <mornfall> ?
06:25:39 <lambdabot> mornfall: You have 1 new message. '/msg lambdabot @messages' to read it.
06:25:44 <amontez> :t 1
06:25:45 <lambdabot> forall t. (Num t) => t
06:25:46 <mornfall> lambdabot: Screw you.
06:26:49 <mornfall> I don't understand the question. There're 2 cabal-1.8 patches. One just requires 1.8, the second uses the new internal-lib feature.
06:27:07 <mornfall> But due to GHC 6.12 and cabal-install breakages, the latter is not mainlined yet.
06:27:22 <mornfall> The latter only builds things once (unless you want profiling library as well).
06:28:14 <ivanm> mornfall: yeah, I meant the first one
06:28:37 <ivanm> I take it the first one is there mainly to get it ready for the second one?
06:32:50 <mornfall> ivanm: The first one is there because we use Cabal APIs that broke compatibility between 1.6 and 1.8 so we can't have both at once.
06:32:57 <ivanm> *nod*
06:33:25 <ivanm> mornfall: OK, with your second patch: do you know if building haddock docs still works? or does http://hackage.haskell.org/trac/hackage/ticket/656 apply to it as well?
06:34:35 <ivanm> @ask Axman6 should we start asking people what they want to do at AusHack and who would be interested in organising a group booking at a hostel?
06:34:35 <lambdabot> Consider it noted.
06:34:40 <mornfall> No idea, I don't usually build haddocks locally.
06:35:05 <ivanm> *nod*
06:35:32 <SamB_XP> does adding the letter "s" make lodging cheaper ?
06:36:01 <Jafet> One little two little three little haddocks
06:36:01 <ivanm> SamB_XP: yes
06:36:11 <ivanm> SamB_XP: hostel == cheap place for backpackers, etc.
06:36:23 <ivanm> SamB_XP: http://en.wikipedia.org/wiki/Hostel
06:36:38 <SamB_XP> hmm ... what's a good way to get a list of the different splits of a list ?
06:36:52 <ivanm> SamB_XP: the split package?
06:36:54 <SamB_XP> @hoogle [a] -> [(a, a)]
06:36:55 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
06:36:55 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
06:36:55 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
06:37:14 <SamB_XP> @hackage split
06:37:14 <lambdabot> http://hackage.haskell.org/package/split
06:38:00 <SamB_XP> is that imported here ?
06:38:27 <SamB_XP> oh, I just wanted to split a list in TWO every possible way ...
06:38:28 <ivanm> nope
06:38:41 <ivanm> SamB_XP: partitions?
06:38:46 <ivanm> @hoogle partition
06:38:46 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
06:38:46 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
06:38:46 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
06:39:12 <SamB_XP> hehe
06:39:16 <ivanm> @hoogle (a -> Bool) -> [a] -> ([a], [a])
06:39:17 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
06:39:17 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
06:39:17 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
06:39:33 <ivanm> @src partition
06:39:34 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
06:39:34 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
06:39:34 <lambdabot>                               | otherwise = (ts, x:fs)
06:39:42 <ivanm> ^^ that's the one I'm talking about
06:39:44 <mornfall> Bah. If I say ghc -e 'import System.IO' -e 'hGetContents stdin" it complains about not in scope stuff... any idea why?
06:39:53 <ivanm> mornfall: use the one -e
06:40:03 <ivanm> ghc -e "import System.IO; hGetContents stdin"
06:40:11 <SamB_XP> ivanm: I only want to split it at different points in the middle
06:40:18 <mornfall> ivanm: parse error on input import
06:40:21 <mornfall> Hm. :)
06:40:33 <mornfall> I gotta be missing something.
06:40:39 <ivanm> mornfall: :/
06:40:46 <ivanm> SamB_XP: ohhhh.....
06:40:53 <ivanm> SamB_XP: no inbuilt function to do that AFAIK
06:41:04 <ivanm> SamB_XP: do your own recursive one
06:41:06 <SamB_XP> i.e. f "foo" = [("","foo"),("f","oo"),("fo","o"),("foo","")]
06:41:15 <ivanm> maybe base it on a permutation definition
06:41:36 * ivanm -> zzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
06:41:40 <ivanm> g'night all (again)
06:42:11 <Liskni_si> mornfall: it does work here
06:42:12 <mornfall> Oh! GHC too old. :))
06:42:16 <SamB_XP> > @pl \xs -> zip (inits xs) (tails xs)
06:42:18 <lambdabot>   <no location info>: parse error on input `@'
06:42:22 <SamB_XP> @pl \xs -> zip (inits xs) (tails xs)
06:42:22 <lambdabot> liftM2 zip inits tails
06:42:23 <mornfall> I was trying with 6.8 for whatever reason.
06:42:37 <SamB_XP> > liftM2 zip inits tails "Hello!"
06:42:39 <lambdabot>   [("","Hello!"),("H","ello!"),("He","llo!"),("Hel","lo!"),("Hell","o!"),("He...
06:42:44 <Liskni_si> oh. doesn't work on 6.6 either :-)
06:43:42 <SamB_XP> > [ x++"s"++y | (x,y) <- liftM2 zip inits tails "hotel" ]
06:43:44 <lambdabot>   ["shotel","hsotel","hostel","hotsel","hotesl","hotels"]
06:44:19 * SamB_XP wonders if it matters where you put the s ?
06:44:30 <ivanm> SamB_XP: yes
06:44:32 <mornfall> grep ^States-Vis *.metrics | cut -d: -f3 | ghc -e 'import System.IO' -e '(sum . map read . lines) `fmap` hGetContents stdin'
06:44:34 <ivanm> @wn hostel
06:44:35 <lambdabot> *** "hostel" wn "WordNet (r) 2.0"
06:44:35 <lambdabot> hostel
06:44:35 <lambdabot>      n 1: a hotel providing overnight lodging for travelers [syn: {hostelry},
06:44:35 <lambdabot>            {inn}, {lodge}]
06:44:35 <lambdabot>      2: inexpensive supervised lodging (especially for youths on
06:44:36 <ivanm> @wn hotel
06:44:37 <mornfall> Fun! : - )
06:44:37 <lambdabot>         bicycling trips) [syn: {youth hostel}, {student lodging}]
06:44:39 <lambdabot> *** "hotel" wn "WordNet (r) 2.0"
06:44:41 <lambdabot> hotel
06:44:43 <lambdabot>      n : a building where travelers can pay for lodging and meals and
06:44:45 <lambdabot>          other services
06:45:58 <Liskni_si> mornfall: ghc -e 'interact (show . sum . map read . lines)'
06:46:21 <mornfall> Liskni_si: Ah, that helps. I could not remember interact. :)
06:48:24 <benmachine> hGetContents stdin = getContents
06:48:29 <benmachine> the latter is in prelude
06:48:35 <benmachine> but like he said you don't need it
06:57:23 <mornfall> benmachine: I guess I like the getContents variant better (not needing the show).
07:04:39 <tibbe> what's Edward Z. Yang's handle?
07:04:39 <McManiaC> @faq Can Haskell give me milk & honey?
07:04:39 <lambdabot> The answer is: Yes! Haskell can do that.
07:05:30 <johannesh> @faq Can Haskell divide by Zero?
07:05:31 <lambdabot> The answer is: Yes! Haskell can do that.
07:05:56 <madf> > 1 / 0
07:05:57 <lambdabot>   Infinity
07:06:00 <madf> :)
07:06:06 <SamB_XP> > 1 / 0 :: CReal
07:06:10 <lambdabot>   mueval-core: Time limit exceeded
07:06:13 <SamB_XP> hehehe
07:06:36 <SamB_XP> that's kinda what I expected
07:06:59 <SamB_XP> since, you know, equality on CReal is only semi-decidable
07:07:10 <SamB_XP> or maybe I shoulda said in-eqaulity?
07:07:16 <SamB_XP> er. spelled better ;-P
07:07:58 <benmachine> tibbe: ezyang'd be a good guess
07:08:17 <tibbe> ezyang: ping
07:08:28 <tibbe> benmachine: thanks
07:10:46 <tibbe> @tell ezyang What did you use to create the diagrams in your zipper blog post?
07:10:46 <lambdabot> Consider it noted.
07:17:50 <Spaceghost> a
07:17:55 <Axman6> b
07:18:07 <jmcarthur> tibbe: it looks like they were just drawn manually
07:18:12 <dmhouse> > ['c'..]
07:18:13 <lambdabot>   "cdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\1...
07:18:19 <jmcarthur> which is a style that i strangely like
07:18:36 <jmcarthur> it feels fresh in a world of crisp lines and perfectly aligned nodes
07:18:50 <Axman6> liberating!
07:18:53 <idnar> c
07:19:01 <idnar> oh noes it's a trap
07:19:26 <roconnor> jmcarthur: link?
07:20:07 <jmcarthur> roconnor: http://blog.ezyang.com/2010/04/you-could-have-invented-zippers/
07:20:08 <tibbe> jmcarthur: was my guess, with paint?
07:20:16 <tibbe> as in MS Paint
07:20:24 <jmcarthur> conor mcbride does the hand drawn thing a lot too
07:20:35 * tibbe needs to draw some GC diagrams and dot is not laying things out in the way he wants
07:20:39 <jmcarthur> tibbe: i don't know
07:20:45 <tibbe> jmcarthur: pretty steady hand!
07:20:50 <jmcarthur> nah
07:21:02 <jmcarthur> maybe it was a scan?
07:21:07 <jmcarthur> or drawn with a tablet?
07:21:08 <tibbe> jmcarthur: If I'd draw using the mouse it would be way worse
07:21:23 <jmcarthur> i've drawn things like that by mouse before
07:21:24 <tibbe> jmcarthur: I don't see the "dittering" around the lines that you usually get from scanning
07:21:29 <jmcarthur> it would be some work
07:21:37 <jmcarthur> i suspect tablet then
07:22:12 <jmcarthur> honestly, those lines look like mouse drawings though
07:22:29 <jmcarthur> they have the unsteadiness i would expect
07:22:43 <dmhouse> tibbe: I'd recommend Inkscape
07:23:02 <jmcarthur> inkscape is pretty awesome
07:23:05 <jmcarthur> generally
07:23:24 <oxamus> no it is not
07:23:32 <oxamus> it is written in C++
07:23:33 <jmcarthur> oxamus: ?
07:23:34 <gwern> (inkscape is one of those apps I feel guilty for not learning, because I know I should use more diagrams and inkscape is the way to go)
07:23:36 <jmcarthur> *sigh*
07:23:51 <gwern> (graphviz as well; not so much gimp though)
07:23:54 <arthuraa> Hello, is there anyone here I could talk with about SoC projects?
07:23:59 <jmcarthur> yeah, skip gimp
07:24:00 <oxamus> it was actually ported to C++
07:24:04 <oxamus> from C
07:24:04 <fax> wow lifetime ban on anyone who dowloads stuff off the internet: Go britan!!!!
07:24:18 <roconnor> fax: link?
07:24:19 <jmcarthur> arthuraa: everybody!
07:24:21 <oxamus> had another name then
07:24:40 <oxamus> C++ just makes me die a little inside
07:24:53 <oxamus> just don't use it or support its use
07:24:53 <arthuraa> jmcarthur: nice =)
07:25:00 <jmcarthur> oxamus: many things are written in c++. it doesn't mean the software automatically is not awesome
07:25:08 <oxamus> yeah it does
07:25:14 <gwern> as long as I don't have to program c++ or deal with c++ bugs, I'm fine with inkscape being written in c++
07:25:19 <oxamus> you have to go full RMS against C++
07:25:20 <Axman6> clang is written in C++, and it's completely full of win
07:25:23 <Axman6> as is LLVM
07:25:25 <oxamus> wrong
07:25:26 <jmcarthur> arthuraa: i'm not sure who is planning to be mentors or whatnot, though
07:25:28 <oxamus> it's FAIL
07:25:34 <gwern> don't discourage use of an app until you have a replacement
07:25:40 <siracusa> Can someone help me with an idea how to parse Haskell expressions between two keywords (non-Haskell keywords), like `begin <expr> end'. I want to use Parsec and haskell-src-exts
07:25:46 <idnar> who cares what it was written in, as long as it works?
07:25:46 <roconnor> gwern: really?
07:25:49 <roconnor> hmm
07:25:52 <oxamus> gwern: that's the dumbest thing I've heard
07:26:02 <gwern> oxamus: your position is dumb and self-defeating
07:26:02 <jmcarthur> gwern: inkscape is actually competitive with pricey commercial products like illustrator, too, in my opinion
07:26:11 <oxamus> even cave walls is better than using inkscape for example
07:26:12 <Axman6> is oxamus  a troll or what?
07:26:19 <jmcarthur> i'm beginning to think so
07:26:20 <gwern> Axman6: very much so
07:26:21 <johannesh> yup
07:26:29 <Axman6> you're an op aren't you gwern?
07:26:34 <Jafet> Either he is, or he has not used 0.44 or newer.
07:26:35 <arthuraa> I was having a look at the project ideas that dons posted, there's a lot of interesting stuff... is there anything that has not been too much looked after?
07:26:38 <fax> I don't have a good link on it
07:26:39 <oxamus> troll?
07:26:42 <Jafet> In any case I see little difference.
07:26:44 <tibbe> dmhouse: it takes too long time to work with!
07:26:45 <fax> its' called digital economy
07:26:54 <oxamus> okay being critical of C++ is not trolling
07:27:03 <Axman6> no, we all do it
07:27:07 <Axman6> but you are being a troll
07:27:07 <dmhouse> tibbe: what sort of diagrams are you doing?
07:27:09 <oxamus> it's just sane
07:27:15 <jmcarthur> oxamus: but you aren't being critical, you're being irrational
07:27:29 <pikhq> oxamus: Being critical of C++ is actually the topic of discussion here. :P
07:27:43 <dmhouse> What's the language option called to enable me to write explicit for alls in my code (so I can get scoped type variables)? GHC 6.10.4 isn't liking ExplicitForAll
07:27:43 <tibbe> dmhouse: of objects and thunks in the young/old GC generations
07:27:49 <gwern> roconnor: well, think about it. without a replacement, advocacy directed at users is largely useless. user: 'I have a need for X; inkscape does X really well, better than anything else I know.' you: 'don't use inkscape, it's written in c++!' user: 'but I still need X' you: 'stfu noob you shouldn't want to do that'. user: 'mmkay, I'm gonna go use inkscape now...'
07:27:51 <pikhq> But, yeah. C++ is a horrible language, but it's *possible* to write good code in it.
07:28:01 <oxamus> I say just toss it
07:28:08 <stevan> hello, i got a question about pattern matching inside monads. imagine you are in a Either String b monad and you do P <- e  and it fails, you will get a Left "PM failure, line #"... i'd like to annotate that message with something more informative. here is some code that might explain what i'm trying to do better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24752#a24753 . it seems to me that someone ought to have ...
07:28:12 <roconnor> gwern: persumably if the software is worse than nothing, ... like the HP ..., then it is okay to be critical of it?
07:28:15 <stevan> ... thought about this before... thanks.
07:28:22 <Axman6> well, you'll have to toss GHC soon then, it'll be using LLVM, which is written in C++
07:28:32 <dmhouse> tibbe: well, why do you say inkscape takes too long? Compared to what?
07:28:40 <gwern> roconnor: well, then they don't 'have a need for X', so it's indeterminate
07:28:51 <oxamus> not as its primary backend
07:29:02 <roconnor> gwern: okay
07:29:05 <roconnor> :)
07:29:12 <oxamus> just use C its a better C++
07:29:17 <Axman6> oxamus: eventually it should be
07:29:23 <tibbe> dmhouse: to my patience level. :) The nice thing with doing it in dot is that I didn't have to think to much and just draw the graph.
07:29:37 <pikhq> stevan: I'm pretty sure the error from pattern matching there is done by the desugaring of do notation. You ought to be able to manually desugar the do notation, and then use your own error message.
07:29:44 <gwern> roconnor: arguments like 'you should not use anything written in c++ and no I don't have any replacements for you to do X with', are only useful when dircted at devs to encourage them to write a replacement, or if you are making a hypothetical argument - 'if there *were* a replacement, this is why you ought to use it: <argument why c++ shouldn't be used>'
07:29:45 <oxamus> Axman6: Well that means that LLVM should be ported to C so as to future proof it
07:29:46 <fax> "The controversial Bill seeks to curb online piracy, among several other major policies, all with the aim of stimulating the UK’s digital economy. It has caused ripples across the technology world, most notably because of its proposals regarding the suspension of repeat filesharers’ internet connections"
07:29:49 <pikhq> stevan: Not optimal, but that should work.
07:29:49 <jmcarthur> i actually find dot format to be quite annoying
07:29:54 <Axman6> heh
07:29:59 <fax> Illegal filesharers will face having their internet connections turned off under proposed legislation in the finalised Digital Economy Bill published today
07:30:01 <jmcarthur> nice for programmatic diagrams, not so much for by hand
07:30:03 <fax> fucking awesome
07:30:15 <arthuraa> for instance, are there many people interested in the llvm cross-compiler?
07:30:16 <gwern> fax: it's Britain, what do you expect?
07:30:19 <fax> you just find someone who you don't like, claim they're doing file sharing and cut them off the internet
07:30:19 <madf> is anyoen copying from France?
07:30:23 <madf> it didn't work there, you know.
07:30:24 <Axman6> when did C become future proof? it's not great at parallelism for one...
07:30:35 <dmhouse> tibbe: if you're drawing graphs, try using the connectors tool in Inkscape
07:30:36 <oxamus> Axman6: neither is C++
07:30:43 <pikhq> fax: I suggest starting with Members of Parliament.
07:30:44 <benmachine> @undo do { 0 <- x `catchError` y; z; }
07:30:45 <lambdabot> x `catchError` y >>= \ a -> case a of { 0 -> z; _ -> fail ""}
07:30:46 <Axman6> exactly
07:30:47 <fax> 14:30 < pikhq> fax: I suggest starting with Members of Parliament.
07:30:49 <fax> oops
07:30:54 <benmachine> @undo do { 0 <- x $ y; z; }
07:30:54 <lambdabot> x $ y >>= \ a -> case a of { 0 -> z; _ -> fail ""}
07:31:00 <benmachine> hmm
07:31:01 <tibbe> dmhouse: I'll give it a try
07:31:01 <madf> fax, they tried it in France, didn't work
07:31:13 <gwern> fax: I sometimes think that britain is a great example of demosclerosis - a good example of why governments should be razed completely and rebuilt every so often
07:31:13 <benmachine> looks like undo doesn't handle operator precedence correctly
07:31:23 <danderson> madf: actually, it did.
07:31:28 <gwern> benmachine: undo and pl break on a number of things
07:31:32 <pikhq> benmachine: Yeah, pretty naive.
07:31:35 <danderson> first threatening letters scheduled to go out in June or so.
07:31:46 <benmachine> well, "correctly" is an interesting question of course
07:31:50 <fax> Mr Timms said that Ofcom would be measuring the level of illegal downloading across the UK from “today onwards” -- wtf
07:31:52 <tibbe> dmhouse: one of the problems I have with inkscape is that I don't quite understand how to get the output to actually be of the *pixel* size I want
07:31:57 <benmachine> since it kind of assumes a scope which may or may not really be there
07:32:03 <madf> I am glad to live in a coutnry that prides itself in heavy illegal filesharing, with ISP ads trying to appeal to filesharers.
07:32:05 <fax> how can you measure that
07:32:14 <benmachine> but it'd be nice to make it assume prelude fixities
07:32:18 <fax> madf heh
07:32:24 <jmcarthur> madf: what country?
07:32:25 <dmhouse> tibbe: it's one of the options in the export dialogue. Ctrl+Shift+E if I recall correctly (or else it's "Export to bitmap" under the file menu)
07:32:30 <Axman6> stevan: the way i'd do it is: do { ...; let f (Left s) = Left (s ++ ", some more info"); f x = x; x <- f e)
07:32:32 <fax> I wish our country was run by people instead of disgusting fascists
07:32:38 <gwern> fax: have the isps identify how much traffic is potentially p2p?
07:32:39 <roconnor> there was something even more awesome than inkscape, thought it was directed at desktop publishing I think
07:32:42 <danderson> madf: well, technically, the french governmental org responsible for policing copyright infringement will need a judge to authorize the disconnection, but there's a court fast-track that lets them do that fairly easily
07:32:46 <tibbe> dmhouse: ok thanks
07:32:58 <roconnor> what was it, scrubs, no, something starting with s
07:32:59 <oxamus> well this LLVM thing is a problem
07:33:06 <luite> scribus
07:33:09 <roconnor> yes
07:33:10 <benmachine> f = either (++ ", some more info") id
07:33:18 <oxamus> I suggest someone port LLVM to haskell or C
07:33:26 * jmcarthur is about to ignore oxamus
07:33:31 <dmhouse> tibbe: if you just Ctrl+S, Inkscape will save it as an SVG, which is a vector format (so obviously you can't specify a pixel size)
07:33:35 <danderson> madf: but, in practice, yeah, it doesn't work. Since the law was enacted, p2p copyright infringement has decreased slightly, but other infringement channels increased so much that overall infringement actually increased slightly.
07:33:42 <roconnor> I did most of my thesis cover in inkscape, but then scrapped it and redid it in scribus
07:33:45 <gwern> oxamus: and where are you going to get all the man-years for such a port?
07:34:06 <Axman6> oxamus: i'd love to see LLVM ported to haskell actually
07:34:19 <jmcarthur> i agree on your opinion of c++, but not using software just because i don't like its implementation language would leave me in a very crippled state and is completely irrational
07:34:24 <roconnor> gwern: only need 1/10th the development team to do it in haskell :P
07:34:28 <Axman6> benmachine: i always forget about maybe and either :)
07:34:42 <tibbe> dmhouse: gah, how do I set the fill/stroke, I can't make a rectangle
07:34:43 <gwern> roconnor: great, so instead of needing a bunch of man-centuries, we only need 1 or 2!
07:34:43 <jmcarthur> Axman6: as would i. i just don't think not porting it to haskell is enough cause to say that llvm sucks
07:34:44 <oxamus> I make it a point to never use C++ software
07:34:56 <benmachine> Axman6: they're basically like condensed case expressions, it's really handy
07:35:01 <roconnor> gwern: that many people work on LLVM?
07:35:23 <oxamus> I think it could be done fast
07:35:29 <oxamus> it is well documented
07:35:37 <gwern> roconnor: llvm, last I checked, is at least a decade old, has a number of full-time contributors from a number of companies, and quite a bit of community input
07:35:40 <benmachine> oxamus: then do it! :P
07:35:43 <jmcarthur> get started
07:35:44 <oxamus> they have restricted themselves to a c++ subset
07:35:45 <dmhouse> tibbe: Ctrl+Shift+F
07:35:46 <Axman6> LLVM is very complex
07:35:51 <roconnor> woah
07:35:52 <oxamus> that is semi sane
07:36:05 <gwern> roconnor: besides the academic input and ancillary activity like bugtracking, design discussion, documentation, benchmarking, etc.
07:36:24 <gwern> huh. actually, llvm is exactly a decade old - first release in 2000, WP says
07:36:24 <Axman6> i think they must have, as Clang can now self compile, and compile LLVM, and they haven't implemented all of C++ yet
07:36:35 <ksf> dmhouse, tibe, you _can_ specify the display size of an svg.
07:36:38 <oxamus> well writing it in C++ was the worst idea anyone has ever had
07:36:55 <dmhouse> ksf: really? Why?
07:36:56 <ksf> you can specify how many dpi your internal units equal or something.
07:37:04 <goomba> llvm's API is pretty high quality as far as C++ goes
07:37:29 * EvilMachine is soo happy to be back in #Haskell. )jeez, the ##C channel is full of dicks, who first don't get your joke, despite a ";))" right behind it, and then ban you from posting. they should get out more often. ^^)
07:37:47 <jmcarthur> EvilMachine: ?
07:37:48 <benmachine> is the joke C++
07:37:59 <oxamus> I have not even been at ##c and I am banned there
07:38:01 <EvilMachine> lol
07:38:02 <oxamus> I wonder why
07:38:04 <EvilMachine> sorry, had to say it.
07:38:07 <dmhouse> Hmm, slightly worrying that doing g <- getStdGen in GHCi loads old-locale and old-time
07:38:27 <shepheb> some acquaintances of mine at school got the entire country (Canada) banned from #anime
07:38:36 <benmachine> it loads time for me
07:38:40 <shepheb> they kept screwing up the hostmasks, and eventually banned *.ca
07:38:49 <EvilMachine> i was just kicked like that and called a troll, for nothing. just because they completely misunderstood me. :(
07:38:51 <benmachine> heh
07:39:01 <EvilMachine> whatever
07:39:03 <gwern> EvilMachine: we understand you!
07:39:08 <EvilMachine> thanks
07:39:11 * EvilMachine cries
07:39:28 <EvilMachine> you know what they compared Haskell to? Visual Basic!! :(
07:39:34 <fax> k
07:39:35 <jmcarthur> o_O
07:39:46 <roconnor> O_o
07:39:48 <benmachine> O_O
07:39:51 <Axman6> EvilMachine: who did that?
07:39:53 <fax> fuck the UK
07:39:53 <Axman6> o.O
07:39:56 <jmcarthur> o_o
07:40:01 <Axman6> >_<
07:40:08 <benmachine> fax: thx :P
07:40:10 <Jafet> EvilMachine is not to be taken too seriously.
07:40:14 <jmcarthur> @_@
07:40:21 <gwern> actually, I saw a comparison by harrop, iirc, of haskell to VB
07:40:26 <gwern> recently
07:40:27 <Axman6> ö_ö
07:40:31 <jmcarthur> gwern: but... that's harrop
07:40:34 <benmachine> ò_ó
07:40:39 <EvilMachine> Jafet: actually i am. but let's get back on topic.
07:41:15 <oxamus> Haskell/VB
07:41:18 <Jafet> ##c is simply full of idiots. You responded to them, which was help-ending mistake
07:41:41 <oxamus> great
07:41:42 <benmachine> oxamus: division by zero error?
07:42:04 <goomba> oxamus: llvm includes c bindings
07:42:24 <goomba> they are hideous though
07:42:27 * Axman6 hopes the LLVM backend is using them
07:42:32 <Axman6> heh, or not
07:42:36 <emias> ##C might be full of idiots, but stating that C sucks is just boring and trolling, even if you add smileys.
07:43:02 <fax> this is a stupid discussion
07:43:04 <fax> who cares about C
07:43:05 <Associat0r> C++ > C
07:43:15 <Axman6> heh
07:43:31 <oxamus> not until the next sequence point
07:43:37 <oxamus> and it wont ever come
07:43:37 <goomba> the llvm-c bindings exist to call llvm from the language you are developing a back end for using llvm ^^
07:43:53 <jmcarthur> okay, i definitely need to write this irc client we were talking about here just so i can filter out boring conversation like C vs. C++
07:44:08 <oxamus> there is no C vs. C++
07:44:36 <byorgey> eight people are already registered for Hac phi 2010!
07:44:38 <shapr> THERE IS ONLY HASKELL!
07:44:40 <jmcarthur> it's brought up a lot and each time it gets closer to a flame war
07:44:43 <byorgey> http://haskell.org/haskellwiki/Hac_%CF%86
07:44:50 <benmachine> φ
07:44:59 <EvilMachine> shapr: way to be less evangelic than C coders. ;)
07:45:03 <stevenmarky> why would it turn into a flame war? C++ totally wins etc
07:45:05 <shapr> jmcarthur: Feel free to poke me when that happens, I will happily use my water hose to cool the flames.
07:45:16 <roconnor> fax: the law still has to pass the house of lords?
07:45:21 <fax> rconnor yeah
07:45:28 <benmachine> ohh
07:45:28 <oxamus> C++ is to C what lung cancer is to lung
07:45:30 --- mode: ChanServ set +o shapr
07:45:32 <benmachine> that's what you were talking about
07:45:35 <fax> roconnor, 'democracy' is pathetic here
07:45:36 * shapr picks up the firehose
07:45:50 <fax> we have this 'prime minister' figurehead and then politicians that nobody trusts
07:45:56 <benmachine> fax: I don't think anyone's got democracy right tbh
07:46:00 <shapr> oxamus: see this firehose? I wouldn't want to have to USE IT ON YOU!
07:46:07 <EvilMachine> my philosophy is: the best tool for the job. because sometimes you need to use assembler. :)
07:46:09 <benmachine> it's like communism except the US isn't actively trying to crush it
07:46:16 <benmachine> eer
07:46:21 <oxamus> shapr: http://www.youtube.com/watch?v=woySeSNBL3o
07:46:21 <benmachine> not overtly anyway
07:46:23 <benmachine> <_<\
07:46:29 <shapr> Wait what? Is this discussion about Haskell?
07:46:36 <Eelis> shapr: please hose the politics people!
07:46:39 * shapr gets ready to brush the infidels into #haskell-blah
07:46:50 * tibbe cheers
07:46:52 <EvilMachine> exactly. let's get back on topic, people
07:46:58 <shapr> y0 philosophy can be discussed thataway --> #haskell-blah
07:47:04 <jmcarthur> #haskell is not a democracy
07:47:12 <benmachine> maybe it should be!
07:47:12 <shapr> Right, I have absolute power.
07:47:14 <benmachine> I vote for me
07:47:19 <shapr> So I'm absolutely corrupt, thus you can offer me cookies.
07:47:22 <roconnor> how about that regular, shape-polymorphic, parallel arrays in Haskell ?
07:47:30 <jmcarthur> roconnor: pretty cool stuff
07:47:30 <shapr> roconnor: Ooh, what's that?
07:47:34 <jmcarthur> i want to get my hands on it
07:47:37 <EvilMachine> jmcarthur: so it is a "free market" (= law of the jungle = opposite of democracy) :D
07:47:40 <Axman6> heh: "Reply-To: UseTheYellowButton@ebay.com"
07:47:41 <oxamus> just make me op I will settle any C++ vs C flame
07:47:43 --- mode: ChanServ set +o jmcarthur
07:47:47 <tibbe> roconnor: I have yet to read the paper, I have 300 pages worth of papers on my desk that I want to read :(
07:47:58 <jmcarthur> :o i haz ops
07:48:02 <benmachine> :o
07:48:03 * EvilMachine is going to refrain from writing, until the channel has normalized again
07:48:22 <shapr> EvilMachine: As long as you want to write about Haskell, it's all good.
07:48:26 <oxamus> okay lads it is time to work
07:48:34 <Axman6> about time
07:48:42 <jmcarthur> shapr: http://justtesting.org/regular-shape-polymorphic-parallel-arrays-in
07:49:01 * benmachine wonders whether if you want to write a nice IRC client it's easier to take someone else's and basically fork it or start from scratch
07:49:20 <jmcarthur> benmachine: if i do it i'm starting from scratch. i'm particular and inefficient
07:49:21 -ChanServ(ChanServ@services.)- shapr set flags +votsriRfA on jmcarthur.
07:49:27 <Axman6> IRC's a fairly simple protocol. making a client for it isn't though
07:49:33 <benmachine> jmcarthur: hah, me too usually
07:49:43 <Jafet> IRC is a fairly simple, undocumented protocol
07:49:47 <benmachine> but I notice this leads to a pattern of me not getting anything done
07:49:49 <shapr> jmcarthur: For your on-topic-ness, you now have access to the firehose.
07:49:55 --- mode: shapr set -o shapr
07:50:10 <benmachine> or at least, I don't get anything done
07:50:21 <benmachine> this could or could not be correlated to the other thing
07:50:21 * jmcarthur holds the firehose nervously, afraid of the power he weilds
07:50:25 <shapr> :-P
07:50:52 <jmcarthur> benmachine: i think it's a very common problem among hobbyist programmers
07:51:26 <EvilMachine> benmachine: forking is not good, when you fork from Windows 98. since then you can only get a Windows ME. ^^. or in other words: depends on how flexible, modern and clean the architecture of what you want to fork it.
07:52:18 <benmachine> hircules is based on lambdabot, lambdabot is pretty scary
07:52:21 <sshc> What documentation exists for the IRC protocol?
07:52:36 <zygoloid> sshc: there's three RFCs depending on which protocol :)
07:52:41 <sshc> I was wanting to write an IRC botb in Haskell but haven't really got around to doing it yet
07:52:48 <sshc> zygoloid: Whichever Freenode's ircds use
07:53:02 <dv-> There are various ircd extensions that make life difficult though
07:53:10 <drhodes> Just upgraded my linux and the repo has 6.12.1 as the default ghc.  Should I use that, or do a manual install?  I tried the repo version and found that cabal install was broken.  What I really really wanted was leksah side-by-side with emacs. maybe I should just stick with 6.10 :<?
07:53:35 <benmachine> I've written an IRC bot in haskell
07:53:39 <dv-> drhodes: broken how?
07:53:41 <zygoloid> sshc: i think this is the one you want: http://irchelp.org/irchelp/rfc/rfc2812.txt
07:53:51 <jmcarthur> yeah, me too
07:53:52 <benmachine> well it's kind of schizophrenic whether it wants to be a bot or a client, it has an ncurses UI
07:54:02 <drhodes> dv-: one moment please
07:54:25 <jmcarthur> heh
07:54:29 * sshc bookmarks for future reference
07:54:31 <drhodes> dv-: failed to parse output of 'ghc-pkg dump'
07:54:38 <jmcarthur> i've not used ncurses before
07:54:49 <jmcarthur> was thinking of using it for this client if it ever happens
07:54:58 <drhodes> I've parsed the logs for #haskell and 12 people have had this problem, but it was awhile ago, so things may have changed.
07:55:14 * Jafet gives benmachine the honorary gimpsuit-shaped award trophy
07:55:22 <benmachine> thx
07:55:28 <dv-> drhodes: i had that problem. try getting the latest cabal-install
07:55:42 <drhodes> dv-: the tarball from hackage?
07:55:51 <sshc> zygoloid: Ah, thank you
07:55:52 <quicksilver> dv-: preferably your distribution package if it has one
07:56:00 <quicksilver> drhodes: sorry, that was for you
07:56:10 <benmachine> jmcarthur: I don't really think I should be starting another project this close to my exam term, but on the other hand it would be really nice to work with someone else on something for once
07:56:18 <quicksilver> if you're using your distribtuions ghc-6.12 you should probably use your distribution's cabal-install, if poss
07:56:32 <jmcarthur> benmachine: yeah, i don't think i should put aside yet another hobby project to start a new one
07:56:34 <benmachine> I don't do nearly enough collaborative things
07:56:58 <drhodes> quicksilver, dv- ok I'll try some new stuff that you've suggested, thanks.
07:57:18 <benmachine> I'm actually quite pleased with my pet project so I should probably stick to just the one for now >_>
07:59:56 <Axman6> benmachine: what is it at the moment?
08:00:23 <benmachine> Axman6: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
08:00:31 <benmachine> currently have three failing testcases, so wip
08:00:40 <benmachine> but I think it's coming along quite nicely
08:01:07 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=foldr+(%2B)+0+[1%2C2%2C3%2C4]
08:01:16 <Axman6> no map?
08:01:33 <Axman6> disappointed :(
08:01:40 <benmachine> I don't have to recompile to define it though
08:02:03 <benmachine> should I use the foldr version or the direct version?
08:02:20 * benmachine decides the latter
08:02:27 <Axman6> yeah
08:02:49 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=map+(%2B+3)+[1%2C2%2C3]
08:03:04 <benmachine> you can define it yourself with let of course
08:03:07 <Axman6> that was quick :)
08:03:10 <Axman6> ah nice
08:03:24 <quicksilver> benmachine: bit strange that [1,2,3,4] --> (1:[2,3,4]) is a step.
08:03:43 <benmachine> quicksilver: yeah, I did that originally because the code was just easier like that
08:03:52 <benmachine> I could fix it now but I'm doing other things
08:03:56 <quicksilver> I think I'd rather either have it (a) desugared always or (b) work directly on the sugared version.
08:04:00 <quicksilver> fair enough :)
08:04:05 <Axman6> benmachine: i like it
08:04:17 <benmachine> I'm not entirely convinced one way or the other
08:04:27 --- mode: ChanServ set -o jmcarthur
08:04:29 <Axman6> in fact, this is a great teaching tool, would you mind if i used it with some of the first year students i'm tutoring?
08:04:53 <byorgey> benmachine++
08:04:54 <benmachine> Axman6: you can if you like but if you just give it to them to play around with they will find the broken bits pretty quickly
08:04:55 <byorgey> very cool!
08:05:04 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=[1+..]
08:05:06 <Axman6> heh
08:05:41 <egaga> byorgey: there's this too http://tryhaskell.com/
08:05:56 <benmachine> hey but if you want to help develop it I'm open to the idea of allowing more access
08:06:16 <byorgey> egaga: yep, I know about that one, also very cool
08:06:17 <benmachine> I should probably make the CGI script link its own source
08:06:20 <benmachine> http://github.com/benmachine/stepeval
08:06:44 <byorgey> benmachine: I'm teaching a Haskell course in the fall, I'd be very interested in letting my students play with it =)
08:07:14 <benmachine> byorgey: if it's in the fall I have a massive summer holiday between now and then to work on it :D
08:07:52 <byorgey> benmachine: awesome, I'll look forward to seeing what you come up with then!
08:08:21 <benmachine> if you find any (of the many) bugs then let me know of course
08:08:45 <Eelis> benmachine: are you planning to also make a standalone tool out of it?
08:08:46 <Jafet> Hm, doesn't execute actions
08:08:56 <benmachine> Jafet: lol wut :P
08:09:04 <Jafet> I wonder how you evaluate stuff then
08:09:09 <benmachine> Eelis: there is a command line tool as well, not sure exactly what you mean
08:09:14 <benmachine> Jafet: by hand, as it were
08:09:21 <benmachine> it doesn't hook the GHC API or anything
08:09:31 <Eelis> benmachine: ok, that's what i wanted to know. having to go to some website to try things during development is no good :)
08:09:47 <benmachine> yeah
08:09:55 <Jafet> benmachine, is there a way to force evaluation?
08:10:00 <benmachine> Jafet: how do you mean?
08:10:09 <benmachine> there's no seq (yet)
08:10:13 <Jafet> Right now it seems to leave them in whnf
08:10:22 <Jafet> Oh, ok
08:10:24 <benmachine> it should try to nf them
08:10:43 <benmachine> but if your top-level thing is a function that's not in scope it won't evaluate any further
08:10:52 <benmachine> because it doesn't know if the function would use the arguments
08:11:01 <benmachine> if it's a constructor it should try to evaluate the components
08:11:04 <benmachine> what's your testcase?
08:11:21 <Eelis> what would also be cool would be if you started with the expression itself and could then select redexes to reduce step by step
08:12:24 <benmachine> Eelis: could be interesting yeah
08:12:29 <benmachine> but one thing at a time, eh? :P
08:12:37 <Eelis> naturally :)
08:12:51 <Jafet> Oh. I thought it would not accept unknown functions
08:13:08 <Jafet> How would you know the arity though..
08:13:12 <Jafet> Wait, nevermind
08:13:14 <benmachine> heheh
08:13:55 <Jafet> So it assumes any unknown name refers to a function
08:14:10 <benmachine> not exactly
08:14:17 <benmachine> an unknown name is just unknown
08:14:24 <benmachine> it doesn't even notice unless it tries to evaluate the name
08:14:30 <benmachine> at which point it just fails
08:14:54 <Jafet> I see now
08:15:09 <Jafet> That's pretty lazy in fact
08:15:21 <benmachine> yep
08:15:32 <benmachine> well, it's meant to work a bit like lambdabot's Exprs
08:15:44 <benmachine> so that you can evaluate some small part of a larger expression and it'll do the best it can
08:16:37 <benmachine> that's not really like lambdabot's Exprs but whatever
08:17:07 <roconnor> who is it who writes the zygohistomorphic prepromorphsims library stuff?
08:17:10 <roconnor> was it edwinb?
08:17:17 <benmachine> edwardk I think
08:17:21 <benmachine> who appears to be not here
08:17:25 <edwinb> wasn't me, it was a different tab completion ;)
08:17:32 <roconnor> edwinb: ah sorry then
08:17:43 <benmachine> ref. category-extras
08:18:20 <roconnor> @ask edwardk do you use associated types to implement your optimized monad transfomer stacks?
08:18:21 <lambdabot> Consider it noted.
08:18:22 <lpsmith> ugh... mirrorservice.org is showing up higher on google searches than haskell.org
08:18:41 <lpsmith> I'm finding that rather obnoxious
08:18:59 <Axman6> lpsmith: searching for what?
08:19:10 <lpsmith> just about anything haskell related
08:19:20 <lpsmith> "template haskell", for example
08:19:24 <lpsmith> hoogle
08:19:31 <[swift]> lpsmith: i've observed that as well; it's really annoying
08:19:39 <jmcarthur> ew
08:20:25 <Jafet> Hmm. That means people are linking to mirrorservice instead of the main site?
08:20:33 <Jafet> Try link:
08:20:49 <lpsmith> yeah, and of course mirrorservice's hoogle doesn't actually work,  as they don't have a way to mirror the functionality
08:21:55 <lpsmith> Jafet:  I don't think so,  I think it's more an issue that mirrorservice's pagerank is higher for some reason
08:22:03 <Jafet> Or that
08:22:07 <lpsmith> It's a legit service from the University of Kent
08:22:18 <Jafet> Perhaps because it mirrors loads of content under one hostname
08:22:32 <lpsmith> yeah;   including a lot of higher-profile projects
08:22:52 <benmachine> > let f (x -> y) = y in 0
08:22:54 <lambdabot>   Illegal view pattern:  (x -> y)
08:22:54 <lambdabot>  Use -XViewPatterns to enable view patterns
08:22:57 <benmachine> aw
08:23:19 <lpsmith> It's not some highly questionable mail list archive site or wiki mirroring site, for example, with lots of advertising and whatnot
08:24:27 * benmachine just came up with let repeat x = repeat' x repeat; repeat' x (repeat' x -> y) = x : y
08:26:33 <benmachine> which I term the silliest way of encoding recursion ever
08:28:46 <Axman6> heh
08:28:52 <lpsmith> benmachine:  the second argument to repeat' is meaningless
08:28:56 <benmachine> lpsmith: yep
08:29:02 <benmachine> hence silliness :)
08:29:36 <benmachine> it's interesting that view patterns are lazy enough for that to work though
08:31:35 <fax> repeat ((:) <$> id <*> repeat -> x) = x ?
08:32:55 <aavogt> is the function itself in scope there?
08:34:00 <benmachine> fax: seems so
08:35:31 <benmachine> similarly
08:35:36 <benmachine> repeat ((,) <$> id <*> repeat -> (x, xs)) = x:xs
08:38:11 <zygoloid> preflex: xseen lunabot
08:38:12 <preflex>  lunabot was last seen on freenode/#haskell 68 days, 8 hours, 15 minutes and 25 seconds ago, saying:  31
08:38:16 <zygoloid> ;(
08:38:19 <lpsmith> benmachine:  view patterns are just syntatic syntax,  e.g.   f (g -> x) = y   ===  f z = let x = g z in y
08:38:43 <benmachine> yeah I suppose so
08:38:51 <benmachine> still think it's neat though
08:39:05 <benmachine> (syntactic syntax, heh)
08:39:13 <lpsmith> lol
08:39:26 <lpsmith> syntactic sugar,  yeah, I didn't even catch tat
08:39:36 <Axman6> heh
08:40:07 <lpsmith> I wonder what non-syntactic syntax is... :)
08:40:22 <benmachine> lpsmith: it's not quite though because f (g -> x:xs) = y might move on to the next equation
08:40:28 <stevenmarky> wheres the g coming from in f z = let x = g z in y ?
08:40:52 <benmachine> so intuitively you think f (g -> x) should call g, but in actual fact (and for sensible reasons) it doesn't have to
08:41:02 <lpsmith> benmachine:  point taken
08:41:34 <lpsmith> stevenmarky, g comes from the left hand side:   z should be a fresh variable
08:43:42 <lpsmith> benmachine:  well,  f (g -> x:xs) would force the evaluation of at least a part of g
08:44:50 <aavogt> the easier translation is    f (g -> x:xs) = y     should be    f a | x:xs <- g = y
08:44:57 <wvd> Does the GUI library Fudgets have any success? It's an another way to use GUI's and I was wondering how it's view is in the Haskell community.
08:45:18 <aavogt> and then move on to converting it to case
08:45:55 <aavogt> wvd: I think it's more common to use gtk2hs or wxhaskell
08:46:08 <Axman6> wvd: never heard of it
08:46:46 <lpsmith> Fudgets was one of the first GUI libraries for haskell,  available before gtk or wxwindows even existed :o
08:47:08 <wvd> Kind of thinking to do a similar approach in Erlang
08:47:22 <wvd> But I was wondering how it was picked up by the Haskell community
08:47:33 <lpsmith> I really liked Erlang's tk binding;  I haven't messed with it's new wx binding
08:48:32 <stevenmarky> I don't see many people doing gui stuff with haskell
08:48:56 <wvd> Where's Haskell generaly used for?
08:49:05 <fax> wvd, los of stuff :P
08:49:18 <tac-tics> UI is like hell for a haskeller... lots of state :)
08:50:14 <tac-tics> Wvd, its a lot of research stuff, but there's a lot of stuff you'd find in any other lang
08:50:28 <tac-tics> Usually mixed togeter
08:50:52 <zygoloid> haha, "f (id -> x:xs) = x" gives a "Warning: Pattern match(es) are overlapped" in GHC 6.10.1
08:52:25 <quicksilver> zygoloid: is that the GHC version o fthe sound of one hand clapping?
08:52:29 <Axman6> wvd: everything
08:52:43 <jmcarthur> tac-tics: you mean existing UI libraries are hell for a haskeller
08:53:40 <jmcarthur> wvd: i use haskell for basically all my pet projects and some (but very little) at work
08:53:56 <jmcarthur> wvd: my current pet project is a 3d game engine
08:54:19 <wvd> In Haskell?
08:54:23 <jmcarthur> yeah
08:54:36 <tac-tics> Haskell is used for when you want to play golf.
08:54:43 <wvd> jmcarthur: Ah, cool
08:55:10 <wvd> jmcarthur: Just wondering, using SDL?
08:55:16 <jmcarthur> wvd: currently
08:55:30 <wvd> Just writing it in C and wrapping it up?
08:55:53 <jmcarthur> no, i'm writing it in haskell
08:56:42 <aavogt> zygoloid: that's fixed in 6.12.1
08:58:12 <jmcarthur> wvd: i'm using the sdl and openglraw bindings. i'm wrapping the openglraw bindings with my own more haskelly abstractions at the moment
08:58:55 <jmcarthur> but i'm thinking about abandoning that and just going with opengl or openglraw directly. opengl is a beast to wrap up!
08:59:04 <wvd> heh
08:59:07 <wvd> Anyway, bbl
08:59:39 <Absolute0> Disregarding the benefits are government programming jobs any good?
09:01:50 <tac-tics> I couldn't possibly imagine they are
09:01:52 <jmcarthur> not based on what i've heard from friends
09:01:53 <quicksilver> jmcarthur: I think OpenGL does a reasonable job (of wrapping openGLRaw)
09:01:56 <Jafet> Does working for the military count?
09:02:11 <quicksilver> jmcarthur: good enough that it would be plenty of work to do better.
09:02:12 <jmcarthur> quicksilver: it does, but i'm hoping to make something that hides the statefullnes a bit more
09:02:19 <quicksilver> jmcarthur: sure, but that's another level higher.
09:02:25 <quicksilver> jmcarthur: (yes, I agree of course)
09:02:31 <pastorn> jmcarthur: all the bindbuffer stuff?
09:02:34 <tac-tics> The government is always last in innovation, so they will be using the oldest tech
09:02:39 <quicksilver> I'd rather be wrapping OpenGL than OpenGLRaw...
09:02:45 <jmcarthur> quicksilver: plus something that supports opengl 3 and doesn't expose deprecated stuff
09:02:56 <stevenmarky> and there will be a lot of formality, requirement specifications, design documents
09:03:08 <jmcarthur> quicksilver: yeah i've thought about doing that as well. i just started with openglraw because it's easier to follow the opengl spec
09:03:13 * quicksilver nods
09:03:27 <Jafet> Nothing wrong with old tech.
09:03:28 <quicksilver> OpenGL's flaw is its lack of documentation.
09:03:33 <jmcarthur> yeah
09:03:35 <pastorn> indeed
09:03:39 <quicksilver> (here I'm referring to the haskell module by that name, if that's not clear)
09:03:51 <quicksilver> it makes some sensible decisions to make some opengl stuff more haskelly
09:03:53 <pastorn> took like 6 hours for me to get a texture on a triangle...
09:03:54 <jmcarthur> pastorn was complaining about that just the other day
09:04:00 <quicksilver> but you occasionally have to guess what Sven did
09:04:09 <pastorn> (with a c++ tutorial and haskells bindings)
09:04:10 <quicksilver> although with :browse and :info you can work most of it out pretty quickly.
09:04:12 <Jafet> It should be obvious from the types!
09:04:20 <quicksilver> it is quite often, yes, Jafet.
09:04:23 <Axman6> quicksilver: i think it assumes prior OpenGL C knowledge
09:04:25 <quicksilver> that's where :info comes in handy :)
09:04:28 <quicksilver> Axman6: oh, definitely.
09:04:40 <Jafet> No type signatures in the documentation?
09:04:41 <quicksilver> Axman6: only a total madman would attempt to use it without prior opengl knowledge.
09:04:46 <jmcarthur> honestly i don't think OpenGL makes things much easier than OpenGLRaw when you factor in the documentation side of things
09:04:49 <Axman6> heh
09:04:53 <pastorn> Jafet: no documentation in the documentation
09:05:04 <quicksilver> Jafet: :info comes in handy to, for example, find out the constructors of a type
09:05:08 <pastorn> quicksilver: that's me!
09:05:08 <Jafet> Sup dawg, I heard you like no docs
09:05:15 <jmcarthur> OpenGL does do a better job of documenting with types that OpenGLRaw
09:05:18 <jmcarthur> *than
09:05:20 <quicksilver> Jafet: (which turns out to be a simple enumeration of the choices, often)
09:06:03 <quicksilver> e.g. texImage2D :: Maybe CubeMapTarget -> Proxy -> Level -> PixelInternalFormat -> TextureSize2D -> Border -> PixelData a -> IO ()
09:06:22 <quicksilver> then if you use :info on 'PixelInternalFormat' and 'Level' and 'TextureSize2D'
09:06:25 <quicksilver> you can pretty much work it out
09:06:32 <jmcarthur> but here's my issue with it:  it's different enough from the opengl spec that it's difficult to transfer existing knowledge to it sometimes, but not really different enough to justify the extra difficulty
09:06:36 <quicksilver> (given also the C manpage for texture2D())
09:06:53 <quicksilver> jmcarthur: I have sympathy with that view, but don't entirely agree :)
09:07:09 <quicksilver> jmcarthur: in most cases where it differs, I think it does so for a convenient level of type security.
09:07:14 <quicksilver> jmcarthur: wrapping ints into enums, etc.
09:07:29 <quicksilver> turning multiple versions of the same call into Maybes
09:07:38 <pastorn> i know what it needs; examples
09:08:07 <quicksilver> yes, I learnt it from the examples.
09:08:25 <pastorn> the small code i posted on the mailing list for loading and compiling shaders should be put in OpenGL.GL.Shaders documentation
09:08:29 <quicksilver> I learnt it by comparing the haskell examples with the C examples which they translate, and correlating that information with internet tutorials.
09:08:45 <quicksilver> pastorn: yes, your small code is much appreciated and i fully intend to try it soon :)
09:08:52 <quicksilver> (I haven't done any shader work with HOpenGL yet)
09:09:11 <pastorn> quicksilver: i'll post my cleaned up version of a texture handling as well
09:09:54 <quicksilver> that would be nice too
09:09:57 <pastorn> (if my previous code is appreciated)
09:09:59 <quicksilver> pastorn++ # leading by example
09:09:59 <pastorn> cool
09:10:02 <pastorn> hehe
09:10:22 <pastorn> i'm translating chalmers CG course labs to haskell
09:10:45 <pastorn> they use c++ (or maybe it's just c)
09:10:47 <quicksilver> the hopengl list is quiet but it doesn't mean people aren't listening.
09:10:52 <quicksilver> At least one is :)
09:11:05 <pastorn> hehe... can i get comments on future stuff?
09:11:22 <jmcarthur> quicksilver: i see the whole thing about type safety, but most people are just going to end up wrapping stuff for their own uses anyway if they are doing anything remotely complex
09:11:23 <quicksilver> I'l try. Believe it or not I can't send email from the email client I used to read your messages :)
09:11:44 <pastorn> haha
09:11:49 <quicksilver> if this sounds stupid that's because, well, it is.
09:11:55 <pastorn> The_third_man: you're alive!
09:12:03 <pastorn> but then, you always were...
09:12:09 * pastorn whistles
09:14:24 <quicksilver> jmcarthur: actually the approach I'm taking at the moment is to have the higher-level part of my code modular away from opengl anyway
09:14:47 <quicksilver> jmcarthur: so the higher-level (and totally IO free) part just generates a scene-description object.
09:15:03 <pastorn> i don't think there's any really good way to wrap general types on the openGL stuff in a good way
09:15:11 <pastorn> if you do that you'll sacrifice stuff
09:15:13 <quicksilver> jmcarthur: then the code which actually renders the scene using opengl is relatively small anyway, and I don't mind that being rather imperative in style.
09:15:38 <pastorn> like the possibility to have interleaved and/or separate arrays for vertices/normals/texcoords
09:15:48 <pastorn> and lot's of other stuff
09:15:50 <jmcarthur> quicksilver: exactly. that's why i don't see much use for abstracting over openglraw unless it's going to be a really nice abstraction
09:16:05 <quicksilver> jmcarthur: OK, I think we're just agreeing then :)
09:16:24 * pastorn actually likes the types...
09:17:01 <quicksilver> it was a bit painful (although correct) to suddenly decide all the GLFoo types should be newtypes.
09:17:07 * hackagebot uuagc 0.9.18 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.18 (ArieMiddelkoop)
09:17:13 <quicksilver> I mean, they should have been newtypes all along, it was precisely the right decision.
09:17:26 <quicksilver> but to change suddenly did put a potentially painful slowdown onto existing code.
09:17:38 <pastorn> slowdown?
09:17:42 <pastorn> really?
09:17:51 <quicksilver> yes, [Double] -> [GLDouble] is no long a no-op
09:18:02 <pastorn> wut?
09:18:03 <quicksilver> (although, admittedly, you can cheat with unsafeCoerce and it will work)
09:18:13 <jmcarthur> but that breaks the abstraction
09:18:21 <pastorn> hmmm... i declare all my stuff as GLfloat
09:18:27 <quicksilver> as I said, it was the right decision
09:18:32 <pastorn> or GL*whatever*
09:18:32 <jmcarthur> yeah
09:18:33 <quicksilver> but it was painful to suddently change.
09:18:45 <benmachine> why is it necessary to use different types?
09:18:54 <jmcarthur> because opengl does
09:18:54 <quicksilver> benmachine: because the opengl API says they are different types.
09:19:02 <pastorn> benmachine: different platforms use different precision for the types
09:19:02 <benmachine> oh, I guess that's fair
09:19:11 <quicksilver> however, it's a bit frustrating in that in practice it's not true :)
09:19:17 <jmcarthur> yeah
09:19:19 <benmachine> couldn't they provide the newtype unwrappers?
09:19:28 <quicksilver> benmachine: no need - realToFrac works.
09:19:28 <pastorn> benmachine: NOWAI
09:19:33 <pastorn> hehe
09:19:35 <quicksilver> benmachine: but the point is, they aren't free.
09:19:48 <benmachine> newtype unwrappers aren't free?
09:19:49 <jmcarthur> realToFrac is definitely not free
09:19:53 <pastorn> can't they become free with some nice LLVM-optimizing?
09:20:00 <quicksilver> benmachine: id is O(0) but map id is O(n)
09:20:04 <quicksilver> benmachine: that's the basic problem.
09:20:06 <pastorn> i mean; it should detect stuff like that
09:20:09 <benmachine> quicksilver: map id is RULESed to id
09:20:10 <jmcarthur> a -> Rational -> b   :(
09:20:28 <quicksilver> benmachine: yes, but "map unFoo" isn't RULES to unsafeCoerce for every possible newtype Foo
09:20:37 <quicksilver> benmachine: even though logically it is the same.
09:20:38 <benmachine> I guess so
09:20:57 <quicksilver> pastorn: if it's statically visible (visible to the compiler) then yes.
09:21:09 <quicksilver> benmachine: of course, map id is free if it fuses with something
09:21:14 <quicksilver> so sometimes it all comes out in the wash
09:21:19 <quicksilver> it's the times that it doesn;t...
09:21:20 <znutar> there's still machines out there that don't use 32/64 bit ieee floats for GLfloat and GLdouble and so on?  Weird.
09:21:36 <quicksilver> znutar: no, everybody must use 32/64 bit ieee for glfloat/gldouble
09:21:45 <benmachine> quicksilver: okay, but the newtype unwrappers would still be better than realToFrac wouldn't they?
09:21:46 <quicksilver> znutar: the question is if they do for plain C float/double
09:21:57 <quicksilver> benmachine: the realToFrac is RULESed to the newtype unwrapper.
09:22:03 <quicksilver> or specialised. Or both.
09:22:04 <benmachine> ohh, I didn't know that
09:22:14 <quicksilver> it's a question of how much the static analyser can see
09:22:15 <benmachine> that's basically all I wanted then
09:22:23 <quicksilver> and whether the RULES phases get it right
09:22:24 <quicksilver> etc.
09:22:34 <quicksilver> static optimisation is a fragile beast.
09:22:45 <quicksilver> it's brittle based on things line inlining thresholds
09:23:12 <pastorn> hmmm...
09:23:46 <pastorn> my function that does bindBuffer >> vertexAttribPointer >> bindBuffer Nothing; i call that 'setBOLayout'
09:23:49 <pastorn> is that a good name?
09:24:17 <Axman6> what's BO mean?
09:24:23 <pastorn> BufferObject
09:24:38 <pastorn> http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-VertexArrays.html#v%3AvertexAttribPointer
09:24:45 <pastorn> gogo superdocs!
09:25:09 <pastorn> jmcarthur, quicksilver ^^ advice?
09:26:12 <pastorn> as it is now it takes 6 arguments :/
09:26:29 <quicksilver> the name is not obvious to me
09:26:42 <quicksilver> what does 'Layout' have to do with setting up a attribute?
09:26:51 <pastorn> quicksilver: layout in VRAM
09:27:04 <pastorn> element size, stride etc
09:27:52 <quicksilver> but calling vertexAttribPointer doesn't just set the stride, it sets the actual data, no?
09:28:29 <pastorn> no, you do that with bufferData
09:28:47 <pastorn> http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-BufferObjects.html
09:31:13 <quicksilver> ah yes of course
09:31:34 <pastorn> hehe
09:31:44 * quicksilver was in vertex-array mode
09:31:44 <kamatsu> wow, jdh is nasty
09:31:54 <kamatsu> he just spouted off a whole pile of ad hominem attacks at me
09:32:00 <pastorn> @slap quicksilver
09:32:00 * lambdabot clobbers quicksilver with an untyped language
09:32:10 <pastorn> to get you out of deprecation
09:32:22 <quicksilver> don't think VAs have been deprecated, nor will they be
09:32:26 <pastorn> @botsnack
09:32:27 <lambdabot> :)
09:32:52 <pastorn> no, they're not, but you should go through BOs
09:33:06 <quicksilver> anyhow, if you're trying to abstract the whole layout thing
09:33:22 <pastorn> i'm not
09:33:32 <quicksilver> then you're going to have to call setBOLayout once per attribute
09:33:33 <pastorn> i'm just trying to use it :)
09:33:46 <quicksilver> so I'd either (1) mention attribute in the name, since it's per-attribute
09:33:46 <ukl> hello.  I'm pondering about buying »The Haskell Road to Logic, Math and Programming« -- any input?  (I'm a math/philosophy student who likes logic -- maybe someone would advice another book instead of this one?)
09:34:04 <quicksilver> or (2) come up with an even more abstract approach which lets you set up all your attributes in one fell swoop
09:34:22 <quicksilver> the latter might be called setBOLayout, in my opinion
09:34:34 <kamatsu> is it at all worth arguing with jdh or should i just ignore him?
09:34:49 <fax> kamatsu: what would you get from it
09:34:52 <zygoloid> kamatsu: who is jdh?
09:35:08 <pastorn> kamatsu: was he the one who got banhammered yesterday?
09:35:17 <dolio> Ignore him, and @remember amusing his quotes.
09:35:24 <dolio> Er, his amusing quotes.
09:35:39 <quicksilver> I quite liked your first version
09:35:48 <quicksilver> it sounded good, although made little sense
09:35:51 <quicksilver> like poetry.
09:35:53 <dolio> :)
09:36:04 <dolio> @quote JonHarrop
09:36:04 <lambdabot> JonHarrop says: You annotated the types by hand because that is idiomatic Haskell. That is idiomatic Haskell because the type system is too easily misled by design (flaw).
09:36:46 <pastorn> quicksilver: sure, you could create your own datatype that holds all the possible configurations that data on VRAM could have and then just write a single function putInVRAM :: (ObjectName obj) => LolData -> IO obj; but that's not what i feel like doing...
09:36:58 <kamatsu> fax: well, is he able to see reason?
09:37:02 <kamatsu> fax: or is he just a troll
09:37:21 <fax> that's not for me to judge
09:37:28 <quicksilver> he is perfectly able to see reason and rather intelligent
09:37:37 <quicksilver> however he is a very skilled manipulator
09:37:40 <quicksilver> i.e. a troll.
09:37:45 <kamatsu> right
09:37:52 <kamatsu> so i couldn't have a legitimate argument with him?
09:37:55 <quicksilver> he chooses to respond in the way he thinks will get the kind of heat and light he wants
09:38:00 <quicksilver> he's rather good at it.
09:38:29 <kamatsu> why does he waste so much energy doing this?
09:38:38 <quicksilver> kamatsu: only if having a legitimate argument with you was the best course towards his goals
09:38:39 <dolio> To sell books/consulting.
09:38:46 <kamatsu> I come away from a perfectly reasonable discussion feeling quite insulted by his attacks on me personally.
09:38:55 <quicksilver> which are to publicise his company and his services
09:39:09 <kamatsu> what's his company/services?
09:39:18 <quicksilver> sounds like a lousy strategy but the fact he's still in business suggests it isn't as bad as you'd imagine
09:39:30 <dolio> He sells F# and OCaml consulting.
09:39:31 <fax> kamatsu - well it's a shame, some people don't think they are talking to real people since it's via the internet
09:39:31 <quicksilver> I hesitate to publicise it for him :)
09:39:44 <kamatsu> I see
09:40:02 <quicksilver> but you can google his books easily enough
09:40:13 <dcoutts_> quicksilver: though there's only the one of him, he's apparently not managed to grow his line of business
09:40:33 <quicksilver> dcoutts_: could be worse, then :)
09:40:34 <kamatsu> okay, i get that he likes OCaml and F#
09:40:37 <kamatsu> but why the haskell hate?
09:40:49 <quicksilver> he doesn't really hate haskell (or I doubt it)
09:40:55 <quicksilver> he used to sell haskell products/services at one point
09:41:03 <quicksilver> he just believes that publicity will get him more clients
09:41:32 <kamatsu> for e.g
09:41:37 <kamatsu> sorry for the big paste
09:41:39 <kamatsu> There's a reason why Haskell is virtually unheard of outside academia: it is a toy. Oh, and I see that you are an academic who tried and failed to start a company in the real world. Let me guess, you wasted your time whining on Reddit when you should have been shipping products and, instead of learning from your mistake, you ran back to academia with your tail between your legs where you now waste your time whining on Reddit at the tax payer's
09:41:49 <kamatsu> this seems like hate to me.
09:42:00 <dcoutts_> heh heh, nice quote
09:42:00 <quicksilver> it's certainly pretty horrible.
09:42:17 <fax> what the fuck reddit is an academy now
09:42:19 <quicksilver> Well, I"m not his psychiatrist, I can't explain all his actions I'm afraid :)
09:42:27 * dcoutts_ shipped a Haskell product this morning
09:42:30 <kamatsu> hehe
09:42:37 <quicksilver> dcoutts_: did it pass its tests?
09:42:42 <dcoutts_> of course
09:42:45 <idnar> heh
09:42:47 <pastorn> dcoutts_: cool :)
09:42:50 <pastorn> what does it do?
09:42:52 <quicksilver> hurrah! What could possibly go wrong?
09:43:18 <dcoutts_> pastorn: sorry, gotta wait for our press release to be approved
09:43:25 <pastorn> aww
09:43:31 <pastorn> can you tell us what field?
09:43:32 <kamatsu> dcoutts_: look forward to it
09:43:53 <kamatsu> maybe we should form an OCaml consulting company and try and compete jdh out of his space.
09:43:59 <kamatsu> nah.. involves too much ocaml
09:44:17 <dcoutts_> pastorn: not a product as such, project for a client
09:44:19 * hackagebot traypoweroff 1.0.0 - Tray Icon application to PowerOff / Reboot computer  http://hackage.haskell.org/package/traypoweroff-1.0.0 (LuisCabellos)
09:44:25 <Philonous> kamatsu: I guess he doesn't need help with that
09:44:39 <fax> why do people care if someone says "$language is not used in the real world"
09:45:00 <quicksilver> people care when other people say things that aren't true
09:45:06 <fax> whether that is true or false, it seems crazy like -- why does he care? There is some rule that unless someone already did it -- it wont work?
09:45:09 <dcoutts_> fax: because it puts them off learning it, people often learn languages with the hope they might be able to use it and get paid
09:45:11 <quicksilver> ...especially as part of a conversation which involves third parties
09:45:24 <quicksilver> it's very frustrating when you're trying to have a useful conversation on a mailing list
09:45:28 <pastorn> haha... the icon inside 'traypoweroff' is pretty cool :)
09:45:28 <quicksilver> (or indeed an IRC channel ;)
09:45:32 <kamatsu> or reddit
09:45:33 <dcoutts_> fax: not because everyone does stuff for the money, but it's nice to have your paid work be with tech that is fun
09:45:50 <quicksilver> and someone comes in and says something stupid, and wrong, but convincingly and authoritatively
09:45:56 <quicksilver> it derails the conversation.
09:46:02 <Philonous> fax: Argumentum ad populum. That seems to be pretty common in the IT world, actually. Just use the most popular language/solution/whatever. You don't get fired for using Java.
09:46:32 <dolio> It's common everywhere.
09:46:42 <fax> yeah the only reason some people (e.g. Gunther) can actually troll is because masses of people respond to their bullshit
09:47:00 <kamatsu> who is gunther?
09:47:05 <fax> if his posts were not replied to - there would be nothing to get annoyed about
09:47:15 <quicksilver> the annoying "how many females use haskell" troll on the cafe, kamatsu
09:47:18 <aavogt> kamatsu: see haskell-cafe
09:47:25 <kamatsu> ah, i'm not on haskell-cafe
09:47:31 <kamatsu> i assumed i could get all my haskell news from reddit
09:47:35 <kamatsu> should i subscribe?
09:47:41 <quicksilver> read the archives, see what you think
09:47:45 <kamatsu> hm,ok
09:47:46 <quicksilver> if you have the time to read, there is good stuff there.
09:47:48 <Philonous> fax: If they where not replied to, uninformed bystanders could get the impressions they are true.
09:47:51 <quicksilver> it's very high volume though
09:47:55 <fax> kamatsu - what I am talking about is definitely NOT haskell news
09:48:04 <quicksilver> (unread messages, 27810)
09:48:11 <quicksilver> but I've been busy for the last couple of years :)
09:48:13 <kamatsu> quicksilver: gmail label and archive
09:48:37 <Philonous> fax: And even more: They are uncontested and folklore.
09:48:41 <quicksilver> yes, it's quite manageable with the right tools.
09:48:56 <quicksilver> (btu some investment of time is required to get anything out of it, of course)
09:49:09 <fax> Philonous: "are there any women/gay haskellers" is not true or false it's just an offtopic question
09:49:19 <kamatsu> btw, females do you haskell, my best (female) friend uses it
09:49:33 <kamatsu> do *use
09:49:53 <aavogt> you must reply
09:49:55 <zygoloid> kamatsu: don't get drawn in!
09:49:59 <kamatsu> i won't
09:49:59 <benmachine> I haven't met anyone in person who uses haskell
09:50:10 <kamatsu> benmachine: ah, but where are you?
09:50:10 <benmachine> obviously I keep the wrong company
09:50:18 <Philonous> fax: Yes of course. I meant the "haskell is an academic toy"-line of trolling
09:50:27 <benmachine> kamatsu: london/cambridge, depending on term time/not
09:50:43 <fax> Philonous  - oh well I guess that is difference
09:50:43 <kamatsu> benmachine: plenty of english haskellers
09:50:46 <fax> differenent*
09:50:49 <benmachine> kamatsu: I know
09:50:56 <quicksilver> ivanm++ # http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
09:51:06 <quicksilver> ivanm++ # worthy of at least two karma points.
09:51:13 <benmachine> oh wait I think I've met one once
09:51:42 <gwern> quicksilver: that blog post is pretty mendacious
09:52:22 <benmachine> the thing I didn't like about that blog post is it told me what cabal isn't but not really what it is
09:52:33 <quicksilver> gwern: is it?
09:52:37 <orlandu63> can you have nested guards such as
09:52:39 <orlandu63> f x y
09:52:41 <orlandu63>     | x < 0
09:52:42 <gwern> quicksilver: yeah. it's shot through with bs
09:52:43 <orlandu63>         | y < 0 = 1
09:52:45 <orlandu63>         | otherwise = 2
09:52:50 <aavogt> gwern: what of my mueval patches?
09:52:58 <gwern> quicksilver: and arguments which are basically 'cabal is broken this way and has bugs, which is why it's not a package manager'
09:53:02 <gwern> aavogt: what patches?
09:53:11 <aavogt> I emailed you
09:53:13 <zygoloid> orlandu63: no. you have to write: f x y | x < 0, y < 0 = 1 | x < 0 = 2
09:53:13 <benmachine> orlandu63: no not exactly
09:53:23 <dcoutts_> benmachine: you should go to the London HUG (Haskell Users Group)
09:53:32 <aavogt> shall I send again? or to a different address?
09:53:36 * benmachine googles
09:53:42 <quicksilver> gwern: hmm. Then I'm too easily lead. BAA.
09:53:49 <quicksilver> gwern: maybe someone smart should post a rebuttable.
09:53:50 <Eelis> i didn't find the "cabal is not a package manager" post at all convincing either.
09:53:52 <quicksilver> rebuttal.
09:53:55 <zygoloid> orlandu63: you can do things like: "f x y | x < 0 = r where r | y < 0 = 0 | otherwise = 2" to avoid the repeated guard
09:54:09 <benmachine> londonhug.net domain has expired, apparently
09:54:25 <quicksilver> where by 'smart' I mean 'smart and knowledgeable', of course
09:54:34 <orlandu63> zygoloid: thank you
09:54:49 <dcoutts_> quicksilver, gwern: the only bit that makes sense to me is saying that it can never be a package manager because it does not automatically pull in system packages
09:55:20 <dcoutts_> the other things, like uninstall are simply missing features
09:55:28 <quicksilver> dcoutts_: there is definitely a fair amount of confusion about how we should correctly perceive the relationship between cabal-install and OS-provided stuff.
09:55:37 <quicksilver> maybe a coherent position statement would help?
09:55:42 <benmachine> dcoutts_: I found a webpage for it that only exists in google's cache because the domain expired, do you have any other resources?
09:55:45 <idnar> meh, I'm too tired to marshal my thoughts on this subject
09:55:50 <idnar> I guess I'll blog something later
09:56:04 <dcoutts_> quicksilver: I think it'd be accurate to say that cabal could be a secondary package manager (if it supported uninstall)
09:56:35 <zygoloid> in that specific case you can use view patterns: "f ((<0) -> True) y | y < 0 = 1 | otherwise = 2" (but i wouldn't recommend it!)
09:56:41 <oxamus> dons: I want my $5 dons. I stood out all day with that Haskell sign.
09:56:57 <dcoutts_> benmachine: oh, hmm, seems organisation has lapsed
09:57:07 <Eelis> what does one do if one develops an application that comprises multiple executables, some of which are written in Haskell? how do you integrate the cabal infrastructure with the rest of your regular project build/install infrastructure?
09:57:17 <wolgo> hi guys
09:57:17 <ddarius> quicksilver: cabal-install is not intended to replace an OS-package manager.  Use OS packages if they exist.  Use cabal-install to help in making OS packages.  Use cabal-install if there is no package.
09:57:41 <benmachine> found some mailing lists too that seem pretty inactive
09:57:47 <aavogt> Eelis: you can specify multiple haskell executables from a cabal file
09:58:03 <aavogt> what's the rest of your project using?
09:58:04 * benmachine is reaching firefox tabs critical mass, i.e. starting to have things that he can no longer remember where they came from or what they are for
09:58:11 <Eelis> aavogt: but what if i have 20 executables, 15 of which are, say, C++, built with SCons, and 5 are Haskell?
09:58:22 <oxamus> did someone say C++
09:58:27 <oxamus> ugh
09:58:37 <dcoutts_> Eelis: you use the Setup.hs interface as part of your build system, like you would for other sub-components that use a ./configure; make interface
09:58:39 <aavogt> you can probably convince scons to call your Setup.hs, or the other way around
09:58:44 <burp> is oxamus an automated troll bot?
09:59:03 <aavogt> burp: are you an automated troll detector?
09:59:08 <burp> aavogt: yes
09:59:11 <wolgo> benmachine: There is a term for that: tab hole
09:59:11 <chrisdone> benmachine: why don't you bookmark?
09:59:11 <oxamus> where is dons?
09:59:23 <oxamus> That guy owes me some cash
09:59:26 <burp> aavogt: why do you ask?
09:59:32 <zygoloid> oxamus: do you have a highlight for 'C++' set up in your client to remind you to troll?
09:59:34 <benmachine> chrisdone: because the condition sneaks up on me unexpectedly
09:59:36 <dcoutts_> Eelis: or you do the Haskell bits in SCons too, it's not that hard. Cabal does not have a monopoly on build systems. Cabal's build system is a bit crap really.
09:59:38 <gwern> quicksilver: well, look at some of the points. 'it just works' - come on! I mean, seriously. or 'it's patched', or 'integration' - like cabal deliberately installs things into nonstandard locations?
09:59:48 <aavogt> I suspected that was the case
09:59:55 <wolgo> when I get in a tab hole I bookmark all tabs in to a folder called SORT ME and I force myself to sort the book marks.
10:00:09 <wolgo> I found that I had over 2000 bookmarks two years ago.
10:00:20 <Eelis> dcoutts_: heh, seeing as how my whole example was basically designed to ultimately provoke an admission that cabal is crap, i'm now more than satisfied :P
10:00:26 <benmachine> heh
10:00:31 <oxamus> zygoloid: C++ is how nondeterminsim is defined these days
10:00:31 <chrisdone> wolgo: that's not really a lot, I don't think
10:00:32 <benmachine> usually I just bail
10:00:39 * wolgo is going to be a hoarder when he is old
10:00:41 <gwern> quicksilver: or his point about non-haskell deps - well, what happens when there are no non-haskell deps? or, isn't cabal already handling non-haskell deps with things like 'c-libraries:' or whatever
10:00:51 <wolgo> two thousand bookmarks?
10:00:52 * fax is going to be an astrobelt
10:00:59 <wolgo> that is too many
10:00:59 <dcoutts_> Eelis: I distinguish different bits, Cabal/cabal-install/hackage has many bits and aspects. Some are better than others.
10:01:00 <wolgo> for me
10:01:07 <Eelis> dcoutts_: fair enough
10:01:19 <wolgo> the tag feature is pretty good
10:01:25 <wolgo> that helps find what I am looking for
10:01:29 <dcoutts_> Eelis: as maintainer I'm well aware of the limitations and problems.
10:01:47 <pastorn>  gwern: it can check for foreign deps... but i've only encountered a few packages that does :/
10:02:14 <quicksilver> dcoutts_: ok, that's fair, but I think there is also the multiple versions problem
10:02:31 <quicksilver> dcoutts_: which distribution packages generally sidestep because they have the notion of a coherent 'distribution'
10:02:46 <dcoutts_> quicksilver: you mean the problem of not being able to use QC1 and 2 within a single set of deps?
10:02:46 <gwern> pastorn: exactly. you can't take something that cabal tries or wants to do, but does poorly or incompletely, and say, look! proof that cabal isn't a package manager!
10:02:48 <quicksilver> dcoutts_: (which is guaranteed to contain a coherent set of versions such that you can install any subset of packages safely)
10:03:05 <dcoutts_> quicksilver: indeed, a distro simple does not address that problem, it defines it out of existence.
10:03:09 <chrisdone> wolgo: let's say you view one interesting like a day, it would take 5/6 years to get 2000 bookmarks. let's say you view 5 interesting bookmarks a day, one year. let's say you don't have a job, maybe 20 interesting links a day, 3 months, ...
10:03:11 <quicksilver> dcoutts_: of course, cabal install is hardly alone here, CPAN has the same problem.
10:03:19 <quicksilver> dcoutts_: ...and that is the main reason I hate CPAN :)
10:03:34 <dcoutts_> quicksilver: because we're dealing with a changing system with less QA
10:03:38 <ddarius> quicksilver: Stick to the platform and/or OS packages.
10:03:43 <Eelis> dcoutts_: are you also the maintainer of cabal install, or is that someone else?
10:03:50 <quicksilver> ddarius: sensible.
10:03:52 <dcoutts_> Eelis: yes, both.
10:03:57 <benmachine> whether or not cabal is a package mananger I think it's a great distribution/development tool
10:03:58 <quicksilver> ddarius: If only I wasn't using a braindead OS with no package manager.
10:04:06 <quicksilver> ddarius: maybe I'll switch back to a sensible OS one day.
10:04:15 <chrisdone> wolgo: do you have a job?
10:04:17 <Eelis> dcoutts_: as you may have seen on haskell-cafe recently, hackage's naming policy makes it unattractive to some people (like me) who would otherwise wish to upload packages. unfortunately, it seems one cannot just put a package tarball online somewhere and say "cabal install http://url/of/the.tar.gz". would a feature request for this be looked upon favourably?
10:04:19 <wolgo> yes
10:04:23 <fax> if cabal was a package mananger I probably wouldn't have to keep reinstalling GHC
10:04:25 <gwern> nobody here has a real job
10:04:29 <wolgo> if I find 20 links a day
10:04:30 <gwern> we're all dead-end phd students
10:04:32 <dcoutts_> Eelis: it's on my TODO list
10:04:33 <ddarius> quicksilver: By "platform" I meant the Haskell Platform if that wasn't clear.  It should work fine on Windows.
10:04:37 <Eelis> dcoutts_: great! thanks
10:04:43 <dev0x> what is a REAL job?
10:04:43 <quicksilver> ddarius: sure. I'm using OSX.
10:04:50 <wolgo> then I am spending too much time reading shit and not enough time trying to understand haskell types
10:04:51 <quicksilver> ddarius: but I was refering to your second clause :)
10:04:53 <wolgo> zomg
10:04:55 <dcoutts_> Eelis: I started implementing it some time ago, havn't had much time recently.
10:05:09 <Eelis> alright
10:05:12 <chrisdone> dev0x: sitting on a hill, looking out for wearwolves -- that's not a real job
10:05:15 <quicksilver> ddarius: if I went back to debian I'd (a) use debian packages (b) learn how to easily build debs from cabal packages
10:05:21 <wolgo> I am at work right now actually
10:05:25 <quicksilver> ddarius: (c) possibly improve b if it could be better :)
10:05:38 <wolgo> figuring out how to implement a heap in ruby
10:05:51 * ddarius needs to go back to work.
10:06:06 <chrisdone> wolgo: one method is to use Hubris and then figure out how to implement a heap in Haskell
10:06:08 <wolgo> hey is there a haskell meetup group in san francisco?
10:06:25 <gwern> chrisdone: there aren't any wearwolves around, though; that's how you know those people on the hill are damn good
10:06:27 <dcoutts_> quicksilver: I discussed the QC1/2 issue with Simon and Simon the other day. I'd like to add the notion of private build depends for deps where you do not re-export any types (eg QC or parsec).
10:06:32 <wolgo> lets see if I can figure it out in haskell.
10:06:36 <gwern> chrisdone: look at how many police we have, yet there are still criminals!
10:06:49 <dcoutts_> quicksilver: that'd give cabal-install enough info to know that it's ok to have two versions in a single solution.
10:07:13 <benmachine> would that be enforceable?
10:07:18 <chrisdone> gwern: but it's cool to be a criminal because there's risk of being caught. I wouldn't wanna be a wearwolf if there's one poxy guard assigned to watch out for me
10:07:27 <fax> Saizan, have you had Machine assisted proofs in the theory of monads
10:07:27 <benmachine> or just an assertion "I know this won't break"
10:07:31 <oxamus> wearwolf
10:07:34 <oxamus> hahaha
10:07:37 <fax> Saizan: http://cs.ioc.ee/~james/PUBLICATION_files/Assisted_Monads.pdf
10:07:42 <gwern> chrisdone: one guard makes it awesome, like a duel.
10:07:43 <dcoutts_> benmachine: yes, we just check that exposed modules do not export types mentioning the private packages.
10:07:54 <gwern> chrisdone: Death Note wouldn't be awesome if L were a collective of 20 people
10:07:57 <benmachine> I guess that wouldn't be too hard to do
10:08:09 <oxamus> chrisdone: is a wearwolf some kind of fashion wolf?
10:08:14 <dcoutts_> benmachine: a hacky solution would be via ghc --show-iface. Something more robust could be implemented I'm sure.
10:08:18 <chrisdone> gwern: I haven't seen Death Note, does that have wearwolves?
10:08:21 <gwern> chrisdone: or _Enemy at the Gates_ - who cares if the germans had sent 30 crappy marksmen against the protagonist?
10:08:33 <gwern> chrisdone: it's cool cause it's *one* badass. the inverse law of ninjas, remember
10:08:34 <aavogt> gwern: mueval!?
10:08:41 <gwern> aavogt: pieval!!!
10:09:01 <chrisdone> gwern: true, true. Enemy at the Gates if fantastic for that reason
10:09:05 <theorbtwo> The pie is a lie?
10:09:23 <gwern> theorbtwo: you know the value of the pi, and the cost of nothing
10:09:38 <EvanR-work> why is crypto code in haskell node a good idea?
10:09:49 <EvanR-work> not*
10:10:21 <theorbtwo> EvanR-work: Because crypto is easy to get wrong, and when you get it wrong, Bad Things happen.
10:10:30 <gwern> EvanR-work: hard to get good performance, and it's hard to do important stuff like zeroing out memory when you're done
10:10:47 * gwern has no idea how you would zero out the RAM you just used
10:10:48 <theorbtwo> Use somebody else's tried and tested implementation of it instead.
10:10:55 <chrisdone> gwern: can you do that in c?
10:10:58 <dcoutts_> Eelis: ooi, how do you currently integrate a system consisting of bits written in different languages or developed separately that have their own build systems?
10:11:03 <gwern> chrisdone: apparently
10:11:10 <chrisdone> I don't know if memset(,..,0) is good enough
10:11:18 <gwern> chrisdone: I guess you overwrite something before calling free?
10:11:22 <chrisdone> I know more about wearwolves than cryptography
10:12:00 <Eelis> dcoutts_: languages shouldn't have their own build systems :)  things like make/SCons can be used to build anything
10:12:03 <chrisdone> gwern: well, I guess, but what about the VM and stuff like that? I don't know. it's not something I'd conject about if implementing, so..
10:12:21 <FauxFaux> memset() is explicitly not good enough on MS' C compiler; there's other functions that won't be optimised out.
10:12:25 <gwern> chrisdone: see, vm? that's going to kill performance
10:12:40 <dcoutts_> Eelis: sure that's fine, but there's quite a bit of knowledge required to do the build. There's a lot of detail.
10:13:11 <chrisdone> gwern: virtual memory? I guess so
10:13:14 <Eelis> dcoutts_: sure, you need a language specific dependency scanner, but that's not rocket science.
10:13:34 <dcoutts_> Eelis: the ideal of course would be a decent language neutral build system with a decent extension language and just a library for each language
10:13:45 <dcoutts_> Eelis: sadly there's no such tool
10:13:52 <Eelis> dcoutts_: you're describing SCons :)
10:13:58 <chrisdone> dcoutts_: I thought the same thing for documentation
10:14:19 <dcoutts_> Eelis: not from what I've heard, but I've never used it personally so I cannot say for sure
10:14:44 <dcoutts_> Eelis: it's a tad more than just dependency scanning, ghc already provides a -M flag.
10:15:08 <benmachine> reimplement SCons in haskell!
10:15:13 <Eelis> is that the same as --make? i always found that a dubious option.
10:15:29 <dcoutts_> Eelis: no, it generate makefile style depends, like gcc -M
10:15:34 <Eelis> oh
10:16:04 <dcoutts_> obviously the .hs files need to exist already, so your build system has to do the dep chasing for preprocessors etc
10:17:27 <Eelis> nothing special about that. lots of languages have various preprocessors and postprocessors. SCons provides the facilities to handle these properly
10:18:16 <dcoutts_> Eelis: I'm not saying it's impossible, on the contrary
10:18:33 <dcoutts_> but it is something you want to do once, rather than once per-package
10:19:22 <Eelis> absolutely. fortunately, SCons is python, so you'd just say "import Haskell" at the top of your SConstruct file to import the "scanner" and "builder"
10:19:46 <dcoutts_> great, would be nice to see someone implement that
10:19:52 <Eelis> and once Haskell becomes popular (any day now!), that module would be shipped with SCons
10:20:30 <pastorn> Eelis: any day!
10:21:12 <dcoutts_> Eelis: so when people use scons as the top level bit, and they have some sub-component that already has its own build system (eg autotools), presumably scons handles that ok, by calling configure; make etc right?
10:21:28 <Eelis> dcoutts_: i've no experience with that, but i imagine so
10:21:52 <dcoutts_> so that'd be the most straightforward way to work with cabalised components
10:22:08 <dcoutts_> since they have a command line API modelled on that of autotools
10:22:44 <Eelis> probably. hm, but how would it decide whether or not to use --user? or actually, i'm not sure registration is appropriate in the first place
10:22:56 <Eelis> this registration stuff is so nasty..
10:23:23 <dcoutts_> Eelis: it would presumably decide to register inplace, using a local package db
10:23:37 <Eelis> ok, didn't know that existed :)
10:23:48 <dcoutts_> but that's only needed for Haskell libs that will be used by other haskell exes or libs
10:24:05 <dcoutts_> if you're integrating into a bigger system then you're making an exe or a lib with a C api
10:24:08 <dcoutts_> so no registration
10:24:39 <Eelis> alright, sounds good
10:25:23 <FliPPeh__>    editorBuffer <- textBufferNew Nothing
10:25:23 <FliPPeh__>    editorView   <- textViewNewWithBuffer editorBuffer
10:25:28 <FliPPeh__> Can that be one-lined?
10:25:29 <FliPPeh__> ;o
10:25:39 <Eelis> why would you?
10:25:49 <Eelis> oh wait, you only need the editorBuffer once?
10:25:57 <Eelis> (in that case, >>=)
10:30:30 <FliPPeh__> Eelis: Yep, it's only for that editorView
10:32:42 <pastorn> quicksilver, jmcarthur: i hope you can live with java naming...
10:33:01 <pastorn> 'setPackedBOLayoutAndBindToAttrib'
10:33:11 <pastorn> it takes five arguments...
10:33:22 <sinelaw> And?
10:33:35 <sinelaw> i love code in function names
10:33:43 <pastorn> hehe...
10:34:21 <pastorn> i try to keep my function names at 10 or less characters, and argument names at less than 6 chars
10:35:48 <chrisdone> I use one letter variables when I can
10:36:01 <sinelaw> m 2
10:36:07 <sinelaw> but it's not good.
10:36:14 <benmachine> it's sometimes ok
10:36:46 <EvanR-work> functions should be small enough that letter variables are obvious, function names should be descriptive enough so you dont need to see the code anyway ;)
10:37:07 <quicksilver> dcoutts_: doesn't solve the general problem, though. The general problem is that when you have (public) depends on some commonly used libraryX you really really don't want to upgrade any of the pacakges on your machine until they are all tested with the new library.
10:37:12 <chrisdone> checkList :: Foo a => [a] -> (a -> Bool) -> Bool
10:37:12 <chrisdone> checkList l p = bar $ map p l ..
10:37:13 <pastorn> EvanR-work: that's not always possible...
10:37:41 <dcoutts_> quicksilver: you mean you want to pin the version of some dep
10:37:46 <quicksilver> dcoutts_: this is the problem that (as you pointed out) distributions sidestep somewhat. But they have frozen-in-time fixed-good versions and often that's what you want.
10:38:03 <quicksilver> dcoutts_: well, I just saying that "cabal install foo" will always give me the newest version of foo.
10:38:05 <dcoutts_> quicksilver: so you want to "install X, but keep this version of Y"
10:38:06 <EvanR-work> pastorn: probably, but a man can dream
10:38:11 <pastorn> :)
10:38:11 <quicksilver> dcoutts_: and that's not always what you need.
10:38:39 <quicksilver> dcoutts_: sometimes what you actually need is 'whichever version of foo has compatible dependencies with all the other stuff I will install or have installed already'
10:39:01 <quicksilver> dcoutts_: nothing forces (the latest versions of) every package on hackage to be internally consistent.
10:39:21 <dcoutts_> quicksilver: right, so if you could specify that some dep is pinned then you'd get the latest version that is compatible with that.
10:39:27 <quicksilver> dcoutts_: whereas, for example, the debian testing distribution is internally consistent by design.
10:39:40 <quicksilver> (and I think gentoo overlays have a similar property? but I don't understand how gentoo works)
10:40:02 <dcoutts_> quicksilver: no, only QA gives that, since they're source packages
10:40:33 <quicksilver> dcoutts_: but I (the user) don't even know which deps to pin. I just want to say "install foo and don't do anything I might regret"
10:40:51 <quicksilver> which is, admittedly, a fuzzy target
10:40:55 <quicksilver> and not always possible.
10:41:06 <quicksilver> ...but debian testing does solve it, albeit conseratively.
10:41:09 <dcoutts_> quicksilver: it would be quite possible to do what you're suggesting by default, it's just that that's often not what you want. You want the latest version of blah, even if that means not getting global consistency.
10:41:41 <quicksilver> dcoutts_: well, if I install blah onto a machine which already has many other owrking programs and libraries, I don't want installing blah to break any of them.
10:41:42 <dcoutts_> by global, I mean all the packages you've got installed using the same versions of all dependencies
10:41:50 <dcoutts_> quicksilver: certainly
10:42:01 <dcoutts_> but that can be done by installing multiple versions of stuff
10:42:16 <dcoutts_> and not mutating existing installed instances (nix style)
10:42:19 <quicksilver> yes. installing multiple versions of stuff helps.
10:43:25 <FliPPeh__> Anyone know how to change widget colors in gtk2hs?
10:46:15 * hackagebot hsbackup 0.1.1 - simple utility for rolling filesystem backups  http://hackage.haskell.org/package/hsbackup-0.1.1 (PetrRockai)
10:51:33 <quicksilver> dcoutts_: so here's a philosophical question for you. C apps tend not ot have versioned (source) dependencies. I can compile apache-ssl against a pretty wide range of opensll versions.
10:51:45 <quicksilver> dcoutts_: why is the siutation so much worse in a haskell context?
10:52:07 <dcoutts_> quicksilver: they do not change their APIs
10:52:42 <quicksilver> C librariey authors are more disciplined?
10:52:49 <benmachine> just older??
10:52:50 <[swift]> quicksilver: i think the C case is not as nice as you describe; linux distros often have several versions of a library installed side by side for this very reason
10:52:51 <quicksilver> C application authors are less likely to use libraries at all?
10:52:52 <benmachine> -?
10:53:10 <quicksilver> [swift]: yes but it tends to be only the major versions
10:53:16 <benmachine> quicksilver: I'd hazard that the average age of a haskell project is probably lower
10:53:17 <quicksilver> like ncurses4/ncurses5
10:53:23 <benmachine> don't know if that makes a huge difference, mind
10:53:29 <bremner> nah. the compiled files depend more finely than the source
10:54:09 <dcoutts_> quicksilver: they're also aiming for ABI compatibility so that they can upgrade shared libs.
10:54:18 <bremner> unlike C++, C doesn't actually screw up the ABI without human intervention
10:54:22 <quicksilver> perl libraries *do* have this problem. Keeping a consistent version set for testing/QA in perl is an issue you have to deal with.
10:55:25 <fax> this is cool man ttp://cs.ioc.ee/~james/PUBLICATION_files/Assisted_Monads.pdf
10:55:29 <fax> http://cs.ioc.ee/~james/PUBLICATION_files/Assisted_Monads.pdf
10:55:38 <Zao> text transfer protocol!
10:56:04 <EvanR-work> its much slower than http
10:57:58 <dcoutts_> quicksilver: anyway, it's not quite true that you can use any version of openssl, apache-2.2.14 needs >=dev-libs/openssl-0.9.8f as a source dependency
10:58:30 <quicksilver> well I said 'pretty wide range'
10:58:45 <quicksilver> also, if a new version of openssl comes out (to fix a problem) I'm pretty sure it will work with my old apache
10:58:58 <quicksilver> I guess they're just more disciplined about (both source and binary) compatibility.
10:59:04 <dcoutts_> yep
10:59:18 <quicksilver> they're less likely to change types because most of the time they don't bother to use types :P
10:59:26 <dcoutts_> some hackage packages are pretty good about source compatibility
10:59:28 <quicksilver> everything is an int, innit?
11:00:00 <dcoutts_> stable ABIs is something JaffaCake is working on
11:00:33 <dcoutts_> there's a performance trade-off however
11:00:37 * quicksilver nods
11:00:54 <FliPPeh__> Mehh
11:01:05 <FliPPeh__> I just want to change that GUI's color!
11:01:10 <sinelaw> i'm now writing stuff to control the segway
11:01:21 <FliPPeh__> Segway?
11:01:29 <sinelaw> that will be connected to the opencv bindings
11:01:29 <FliPPeh__> I want one.
11:01:35 <dcoutts_> FliPPeh__: there's a method on gtkwidget to change the base colour
11:01:37 <sinelaw> so that it may follow faces and run them over
11:02:08 <dcoutts_> quicksilver: it could also be that because we've got more flexible tools that package authors don't mind changing stuff more quickly. It might be our fault! :-)
11:02:29 <dcoutts_> quicksilver: if we made it harder, perhaps people would change APIs slower :-)
11:02:46 <quicksilver> dcoutts_: on balance I think most of t is your fault.
11:02:50 <quicksilver> ]
11:02:52 <dcoutts_> heh heh
11:02:58 <sinelaw> FliPPeh__, it belongs to the univ.
11:03:02 <quicksilver> ;)
11:03:26 <quicksilver> I guess it's partly a maturity thing. If thre was a haskell-opensll used bya c ommercially deployed haskell web server
11:03:38 <quicksilver> then the maintainer would presumably be more careful with versions of stuff.
11:03:53 <quicksilver> currently there is a lot of 0.01-code on hackage depending on other 0.01-code.
11:04:02 <quicksilver> (and that's a *good* thing!)
11:08:59 <benmachine> someone should survey the Stability field in hackage
11:09:14 <benmachine> I bet it'd come up with a vast majority of experimentals :)
11:10:25 <aavogt> another problem is that people tend not to update those things even if it changes
11:10:33 <ville> What sort of build system do people use for Haskell projects, or projects containing Haskell?
11:10:59 <aavogt> many interfaces that are "unstable" have not changed in years
11:11:05 <aavogt> ville: cabal?
11:11:36 <benmachine> ville: Haskell projects, Cabal is common, projects containing haskell, depends on what else it contains
11:11:49 <benmachine> (but probably not Cabal, in any case)
11:11:51 <dcoutts_> benmachine: I'm trying to deprecate the Stability field. It's useless.
11:11:52 <ville> aavogt: honestly I wouldn't know. Would you just use it for the Haskell parts for a mixed project?
11:13:05 <aavogt> depends on the other parts
11:13:09 <benmachine> dcoutts_: so I shouldn't bother including it in my cabal files?
11:13:30 <dcoutts_> benmachine: the PVP is much more useful.
11:13:43 <ville> Say the other parts are the usual suspects of C-like languages.
11:15:09 <zygoloid> ville: it's not too hard to get ghc to do the right thing in a makefile aiui
11:19:15 <quicksilver> arguably the most interesting advantage of using cabal is in order to be cabal-installable
11:19:45 <quicksilver> for a standalone app it's not at all hard to drive ghc with make/scons/whatever.
11:20:11 <quicksilver> ...but if you are cabal-installable then cabal-install will install your libraries
11:20:26 <quicksilver> which is convenient for users if you have dependencies.
11:20:33 <dcoutts_> you can use make as part of a Cabal-spec compliant package
11:20:39 <dcoutts_> it's just that nobody bothers
11:22:02 <nominolo|uni> anyone else have problems installing happstack-data with 6.12.1?
11:22:22 <nominolo|uni> dist/build/Happstack/Data/Default.o: unknown symbol `sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacyKZN_closure'
11:22:36 <nominolo|uni> inside template haskell
11:22:53 <ville> Alright have to see how this turns out, if it turns out at all.
11:22:56 <aavogt> rebuild syb with class without docs
11:23:07 <aavogt> nominolo|uni: it's a known cabal bug
11:24:09 <dcoutts_> aavogt: is it?
11:24:35 <dcoutts_> aavogt: oh, the problem of haddock stomping on .hi and .o files?
11:24:41 <lpsmith> nominolo|uni, aavogt:  I was able to build happstack-data via runghc Setup
11:25:01 <lpsmith> IIRC, that is
11:25:24 <aavogt> dcoutts_: exactly
11:25:28 <dcoutts_> aavogt: someone needs to write a patch for that one
11:25:35 * dcoutts_ almost certainly does not have time
11:25:40 <dcoutts_> not before 6.12.2
11:25:41 <aavogt> haha
11:25:49 <quicksilver> sounds more like a haddock bug than a cabal bug?
11:25:50 <nominolo|uni> ah, thanks that workd
11:26:14 <dcoutts_> quicksilver: that'd be another solution, get haddock to never write out .o or .hi files.
11:26:29 <dcoutts_> it really should not have to
11:26:31 <aavogt> libraries make me sad when the documentation disagrees with the code
11:27:01 <aavogt> dcoutts_: I think haddock has to run ghc to collect up instances or something like that
11:27:32 <aavogt> but it shouldn't overwrite the ones from the original build
11:27:43 <quicksilver> it could run with --output-dir=./haddock-tmp/
11:27:46 <quicksilver> couldn't it?
11:27:46 <dcoutts_> aavogt: sure, but it uses the ghc api directly, it should not need to clobber existing files. If it needs to write temp files that's fine.
11:28:02 <dcoutts_> quicksilver: try it, send in a Cabal patch quick! :-)
11:28:12 <quicksilver> that's probably not the right commandline option but something like that exists :)
11:28:18 <dcoutts_> if it works and looks sane then I'll apply it
11:28:27 <quicksilver> I think it might be -odir foo -hidir foo ?
11:28:28 <aavogt> well does the the ghc-api claim not to write temporary files?
11:28:40 <aavogt> "When used in a context where anything that is an instance of Read is expected, calls read to parse the item."
11:28:47 <dcoutts_> aavogt: you can ensure it doesn't. eg ghci doesn't
11:28:55 <aavogt> but there's only "(Num  t, Read  t) => Get_C  t"
11:29:01 <aavogt> dcoutts_: blame haddock then?
11:29:15 <dcoutts_> aavogt: I do! but Cabal could also workaround it
11:29:44 <aavogt> do the haddock devs know about this problem?
11:29:58 <nominolo|uni> aavogt, i think so
11:33:39 <aavogt> preflex: seen CosmicRay
11:33:39 <preflex>  CosmicRay was last seen on #haskell-blah 8 days, 23 hours, 17 minutes and 10 seconds ago, saying: I think the publishers arguing for high ebook prices are really doing themselves a disservice
11:36:15 * ksf wants a partial evaluator for haskell
11:36:35 <ksf> I think that'd be the best way to debug haskell
11:36:40 <ksf> ...code.
11:37:13 <ksf> considering that the main issue I run into is missing Show instances for function values.
11:37:31 <kevinulin> is there a standard abreviation for the the word "connection" for use in identifiers?
11:37:39 <ksf> conn
11:37:47 <ksf> sock for the socket
11:37:57 <kevinulin> thanks
11:41:36 <ben_m> I feel dirty for using an IORef :(
11:42:32 <zygoloid> if you're not unsafePerformIO'ing the newIORef, it's not /that/ dirty :)
11:43:11 <zygoloid> if you're just using IO for the Refs, you might want to use ST
11:43:15 <Cale> What are you using it for? It's not always a bad idea.
11:43:45 <ksf> unsafePerformIOing the newIORef is quite clean, actually. the truly hacky stull is unsafePerformIOing the reads and writes.
11:44:19 <Cale> Actually, I really don't like that use of unsafePerformIO either.
11:44:34 <pastorn> ben_m: when you do upOI on newIORef, be sure to do {-# NOINLINE #-} and you've got yourself a global variable :D
11:44:48 <ksf> Cale, wanna write a thingie that can partially apply values to the haskell-src-exts AST?
11:44:53 <Cale> Even though there are plenty of other things in the IO monad which act as global state, creating more is probably a bad idea.
11:45:19 <Cale> ksf: What do you mean by that?
11:45:33 <Cale> ksf: A partial evaluator for Haskell in terms of haskell-src-exts?
11:45:56 <ksf> er no, applicator.
11:46:06 <ksf> but you may evaluate under lambdas if you want, too.
11:46:16 <ksf> the idea is to provide a show instance for functions.
11:46:25 <ben_m> Using it for HOpenGL
11:46:29 <ben_m> Kinda doesn't work without it apparently
11:46:52 <Cale> ben_m: Oh, yeah, OpenGL is very stateful, unfortunately.
11:47:21 <Cale> ben_m: The OpenGL libraries come with their own sort of state variable abstraction too though.
11:47:21 <ben_m> aye :(
11:47:55 <Gracenotes> woo, I'm actually making some progress on my STG game idea, where you control stacked graph reduction
11:48:19 <Gracenotes> now the graphics end of it... eugh, I'm in trouble there
11:49:14 <pastorn> Gracenotes: howcome?
11:50:09 <Gracenotes> well, if it's an actual graph in any sense, there needs to be layout. I've tried my hand at graph layout before, with DAGs, and it's not all pretty... no guarantees this is planar either :)
11:50:55 <pastorn> uhm... i don't really understand...
11:51:09 <pastorn> and what do you mean by STG? a shmup?
11:52:03 <Gracenotes> spineless tagless g-machine, how GHC executes Haskell code. like a functional programming game.
11:52:18 <pastorn> uhm...
11:52:53 <ksf> hmmmm
11:52:54 <dolio> What's the game?
11:53:21 <ksf> actually, hare would be the right thing to write such an evaluator in.
11:53:25 <Gracenotes> you go from node to node, doing your code-running business. But not deterministically like GHC does it
11:53:45 <dolio> So you get to pick what nodes to reduce?
11:54:18 <pastorn> Gracenotes: what are you going to call it? "fold-o-rama"?
11:54:25 <Gracenotes> yeah, since the player's controlling it. and, for instance, when you enter a case statement, you move up physically, and once that's done, the alternative you take determines where you go when you move down a level again
11:55:08 <Gracenotes> which is much like a stack, so a top-down approach is how I'm thinking of it
11:55:10 <zygoloid> ksf: unsafePerformIOing the newIORef is only clean if you give it a monomorphic type. otherwise you've got a widget you can unsafeCoerce through
11:56:04 <zygoloid> (not that there aren't other ways of making such things within IO of course, but IORefs are usually typesafe...)
11:56:16 <Gracenotes> pastorn: Foldy the Functor? :/
11:56:26 <pastorn> hehe
11:56:36 <pastorn> Gracenotes: have you seen fluxus?
11:56:36 <jmcarthur> Mona Monad
11:56:50 <Gracenotes> nope
11:57:04 <Cale> zygoloid: What other ways?
11:57:08 <Vanadium> The Functionator?
11:57:09 <pastorn> it's a scheme graphical environment
11:57:31 <Cale> zygoloid: I suppose you might be able to do something with Ptrs for instances of Storable
11:57:37 <pastorn> Gracenotes: http://www.youtube.com/watch?v=lT7vGFoT92A
11:57:53 <pastorn> is that the kind of interface you are thinking of using?
11:57:55 <zygoloid> Cale: yeah, that's the sort of thing i was thinking of
11:58:11 <Cale> But even that is saner :)
11:58:40 <Gracenotes> pastorn: well, that's definitely a sort of programming game. I might try more for an analogy?
12:00:11 <dolio> I guess casting through Ptrs at least requires you to go through some kind of well-defined memory representation.
12:00:21 <zygoloid> Cale: foreign export ccall "coerce" id :: a -> a; foreign import ccall coerce :: a -> b
12:00:30 <zygoloid> :D
12:00:31 <Gracenotes> eh, all this thinking is kind of self-indulgent.. I have productive things to do. I think -.-
12:00:54 <Cale> zygoloid: Does that actually work?
12:01:03 <dolio> unsafeCoerce could theoretically let you observe internal bookkeeping stuff about the values in question.
12:01:08 * zygoloid tries...
12:03:11 <Gracenotes> dolio: you could find the earliest byte array in memory and start reading it until you get a page fault (or segfault, if GHC does that?)
12:03:32 <dolio> You can get GHC to segfault with unsafeCoerce.
12:03:38 <dolio> Although it can be harder than you might expect.
12:03:53 <zygoloid> Cale: sadly not. looks like the best you can do is castPtr :: Ptr a -> Ptr b, and that's already in Foreign.Ptr
12:03:57 <Gracenotes> I think coercing between functions gets you there pretty easily
12:04:15 <Gracenotes> I don't think you can coerce to a primitive value, though, right? because of the kind
12:04:23 <dolio> I think the difficulty depends on whether you're using GHCi or not, too.
12:04:46 <dolio> GHCi tends to catch you doing bad things without actually segfaulting.
12:04:59 <dolio> And prints out its own error before exiting.
12:06:31 <Gracenotes> (unsafeCoerce 0 :: a -> a) 0
12:07:38 <ben_m> pow! I can scale a box with my mouse wheel!
12:08:07 <LeoD> pow pow
12:08:10 <BMeph> Is there a tutorial for remedial counseling of procedural programming style? ;)
12:08:22 <Cale> Are the problems with (bad instances of) Ix and arrays still around?
12:08:49 <dolio> Gracenotes: Unsafe.Coerce.unsafeCoerce doesn't allow you to coerce to a primitive, but GHC.Prim.unsafeCoerce# does.
12:08:56 <zygoloid> Cale: i think that's been fixed. but iirc the issue with Dynamic with custom Typeable instances remains
12:09:09 <dolio> I'm not really sure how the difference is accomplished.
12:09:14 <Cale> Well, just custom Typeable instances.
12:09:30 <Cale> That's really hard to avoid though.
12:09:45 <Gracenotes> I never got why there are Ix of Orderings, for example
12:09:58 <zygoloid> you need Dynamic too. the flaw is that you can get at the 'unsafeCoerce' inside Dynamic in an unsafe way
12:10:04 <Cale> Gracenotes: Maybe you want to index a (very small) array using Ordering values?
12:10:24 <Cale> Gracenotes: There'd be no good reason *not* to have an instance of Ix for Ordering.
12:11:01 <dolio> I# (unsafeCoerce# id) is an easy segfault.
12:11:19 <illissius> hi. i have the "premature end of compressed stream" bug in cabal-install (i assume this is common?). however, i can download the index file with wget just fine. is there any way to force cabal to use it? or any way at all to get the damn thing to work without having to recompile it from source?
12:11:34 * zygoloid is disappointed that (unsafeCoerce "Hello world") :: Maybe Char gives (Just 'H') but :: (Char, Char, Char) segfaults
12:11:55 * zygoloid slaps self for not seeing the obvious
12:12:06 <illissius> (it happens when trying to do cabal update)
12:12:24 <Gracenotes> Cale: hm. Maybe if you want to keep some kind of count for each? I guess.
12:13:23 <Gracenotes> @instances Ix
12:13:23 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
12:13:48 <Gracenotes> @instances-importing Data.Array Ix
12:13:50 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
12:14:40 <dolio> zygoloid: Those two cases are kind of like casting between a 'struct a { foo x ; bar y }' and 'struct b { foo x }' in C, versus 'struct c { foo x ; bar y ; baz z }'.
12:14:52 <Cale> Gracenotes: Also note that you might want to use this instance along with the instance for pairs, say, and the instance for Integer or something.
12:15:05 <Cale> Gracenotes: To have an (Integer, Ordering) pair indexed array
12:15:32 <Cale> (No particular idea why you'd want that, but I can imagine it being frustrating if it didn't work)
12:15:53 <zygoloid> dolio: it's worse than that, even. i don't think GHC represents single-ctor types the same as multi-ctor types (at least my playing with unsafeCoerce suggests as much)
12:16:00 <arthuraa> Has anyone got any details about the llvm cross-compiler soc project idea?
12:16:13 <fax> "Inthis paper we showthat it is possible to divide by three."
12:16:17 <Cale> illissius: That typically happens if something goes wrong with your connection when downloading the file, I think.
12:16:17 <Gracenotes> yeah, frustratingly missing instances. sounds like something I've dealt with, but don't remember exactly what... hm
12:16:24 <fax> PeterG. Doyle and  John Horton Conway∗
12:16:32 <dolio> zygoloid: Yeah, that's also a potential issue. I'm not sure how that gets done.
12:17:06 <Gracenotes> well, it's a beautiful day, I really need to get out on the bike. before its too late (nooo)
12:17:08 <Gracenotes> *it's
12:17:12 <zygoloid> dolio: otherwise i might stand a chance with coercing to (Char, (Char, (Char, ())))
12:17:54 <dolio> zygoloid: Naively, you might expect them to all have some constructor tag. So presumably Nothing and [] might both be tagged by 0, while (:) and Just are 1, and thus translate fine.
12:18:24 <zygoloid> dolio: indeed that's how it behaves
12:18:28 <dolio> While the tuple might get confused seeing a 1 but expecting a 0. Or maybe it doesn't have a tag at all, or maybe it doesn't check the tag, so it wouldnt' matter what it is.
12:19:14 <illissius> Cale: it happens every time, as far as I can tell from googling because I'm behind a transparent proxy and there's a bug in the http lib and/or the ghc version it was compiled with
12:19:20 <zygoloid> is there a document anywhere describing how GHC actually represents values in memory?
12:19:30 <illissius> which sucks, because i don't have a package list at all yet so it's something of a bootstrapping problem
12:19:49 <dolio> zygoloid: For instance 'case unsafeCoerce "hello" of () -> "yes"' works fine.
12:19:50 <Cale> hmm
12:21:00 * BMeph thinks Ix Ordering is a stealthy means to incorporate a trinary system into Haskell...
12:21:06 <dolio> zygoloid: Also: case unsafeCoerce "hello" of (c, l) -> c : l :: String
12:21:13 <dolio> zygoloid: That gives you "hello".
12:21:27 <dolio> In GHCi, at least.
12:21:41 <zygoloid> dolio: i tried that. in ghc6.8 it gives me a segfault
12:21:46 <dolio> Heh.
12:21:50 <Gracenotes> it's agnostic of the constructor itself
12:21:59 <dolio> Okay, in 6.12.1, it gives "hello". :)
12:22:08 <dolio> On my machine. On Thursdays.
12:22:36 <Gracenotes> it's kind of surprising that it doesn't need a bit pattern to identify it, but I suppose it wouldn't have the object in the first place if it wasn't the right type, so.
12:23:23 <zygoloid> dolio: actually, your code works. i did: unsafeCoerce "hello" :: (Char, String). that segfaults.
12:23:48 <dolio> Oh. Huh.
12:24:05 <Gracenotes> then again, isn't it the case that case statements don't necessarily put anything new on the heap?
12:24:27 <zygoloid> dolio: case unsafeCoerce "hello" of (c, l) -> (c, l) :: (Char, String) -- segfaults too!
12:24:38 <dolio> Awesome.
12:24:40 <Gracenotes> they don't create a tuple, just create the c and l and pass it to the alternative
12:25:38 <zygoloid> dolio: changing it to (c, l) -> (l, c) :: (String, Char) fixes it. i think it's cunningly reusing the tuple
12:25:59 <dolio> Is this in ghci?
12:26:02 <zygoloid> (and the tuple isn't a tuple and explodes in show, i guess)
12:26:04 <zygoloid> dolio: yep.
12:26:10 <dolio> I wouldn't think it'd do that level of fanciness.
12:26:56 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24755#a24755 -- A concrete Typeable coercion example
12:27:14 <zygoloid> dolio: it really does seem to. (c, l) -> (c, l) fails but any other RHS seems to work
12:27:18 <Cale> (anyone want to try doing it without ScopedTypeVariables? :)
12:28:07 <dolio> Cale: Didn't Oleg's original example use typeOf ()?
12:28:44 <Cale> Oh, of course, we could just cast from one Mock to another.
12:29:31 <Cale> er, hmm
12:29:42 <leoncamel> What does "#" mean in Haskell ?
12:29:46 <dolio> data Mock b = Mock b ; typeOf _ = typeOf ()
12:29:51 <Cale> leoncamel: Nothing in particular
12:29:53 <dolio> Then you can cast from Mock a to Mock b?
12:30:20 <leoncamel> Cale: data Char = C# Char#
12:30:35 <leoncamel> Cale: what does this mean exactly ?
12:31:07 <Cale> leoncamel: Means that Char is a datatype with one constructor called C#, that takes a parameter of type Char#
12:31:15 <Cale> Char# is the type of unboxed characters
12:32:03 <Cale> Note that # isn't normally allowed in ordinary identifiers (it's a symbol character for use in infix operator names), but you can allow it with the MagicHash extension.
12:32:18 <FliPPeh__> Building webpages with Text.Xhtml is way funnier than writing the code yourself
12:32:20 <Cale> dolio: Ah, that avoids requiring the extra Typeable instance
12:32:20 <FliPPeh__> :/:/
12:32:42 <Cale> yeah, and the ambiguity too :)
12:32:59 <dolio> Cale: I seem to recall Oleg's original example having a higher-rank type somewhere, too, but now I can't remember why you'd use it.
12:33:09 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24755#a24756
12:33:35 <kmc> zygoloid, the GHC dev wiki has some information
12:33:40 <Cale> His original thing was to write an instance of Typeable for all types, using IncoherentInstances
12:33:42 <kmc> otherwise, the document you seek is the GHC source code :)
12:33:56 <Vanadium> Hm
12:34:10 <Vanadium> > let (#) = (+) in 2 # 2
12:34:12 <lambdabot>   <no location info>: parse error on input `)'
12:34:12 <Cale> leoncamel: But that's an internal detail of GHC's implementation of the Char type, which you'd normally think of as being primitive.
12:34:44 <leoncamel> Cale: OK, it is not the standard grammer I should master ?
12:35:20 <Cale> leoncamel: Well, # is used as a convention throughout GHC to mean "internal" or "unboxed"
12:36:18 <leoncamel> Cale: OK. thanks.
12:36:40 <Cale> leoncamel: I suppose you might have to care a bit about this stuff if you're doing low-level hackery to try to squeeze the last ounce of performance out of a Haskell program, but otherwise, you usually don't have to worry about unboxed types too much.
12:37:09 <fax> what do we know about total functions f :: Bool -> Bool?
12:37:15 <zygoloid> > let ( # ) = (+) in 2 # 2
12:37:16 <lambdabot>   4
12:37:27 <Cale> fax: We know there are 2^2 = 4 of them
12:37:37 <dolio> f . f = id?
12:37:53 <Cale> dolio: errr...
12:37:59 <zygoloid> Cale: i know of more than 4!
12:38:11 <fax> f . f . f = f
12:38:12 <dolio> Oh, right, that's not correct.
12:38:21 <fax> but you can't divide by f
12:38:24 <dolio> Yes, that's the correct one.
12:38:39 <fax> the question is why can you divide by 2 in e.g.   2xA = 2xB ==> A = B
12:38:51 <zygoloid> there's the 4 strict ones, const True, const False, const undefined and undefined. i think that's all of them.
12:38:55 <Cale> fax: What?
12:39:05 <Cale> fax: Are you talking about sets?
12:39:11 <dolio> const undefined is not total.
12:39:13 <fax> I don't know if it has to be sets
12:39:21 <fax> I don't think so
12:39:28 <zygoloid> dolio: oops, missed that word. that leaves 6
12:39:31 <leoncamel> Cale: OK, I am also curious that, how can I read the code generation of C/assembly ?
12:39:32 <fax> maybe sets is best
12:40:15 <sinelaw> preflex, seen Peaker
12:40:16 <preflex>  Peaker was last seen on #haskell 2 days, 22 hours, 40 minutes and 19 seconds ago, saying: jmcarthur, That kind of abstraction doesn't fare well in other languages either :)
12:40:17 <sinelaw> preflex, seen PeakerWork
12:40:17 <preflex>  PeakerWork was last seen on #haskell 1 day, 18 hours, 58 minutes and 16 seconds ago, saying: Saizan: Oh, that's as good as a "yes" :)
12:40:45 <Cale> leoncamel: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id2962393
12:40:54 <Cale> leoncamel: You can dump a lot of intermediate information
12:41:04 <MadHatterDude> Is there a simple, pointfree way of doing "(Maybe a, Maybe b) -> Maybe (a, b)"?
12:41:09 <Cale> (that lists the relevant GHC options)
12:41:15 <zygoloid> MadHatterDude: uncurry (liftM2 (,))
12:41:32 <zygoloid> @type uncurry (liftM2 (,))
12:41:33 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
12:41:33 <MadHatterDude> thanks
12:41:49 <leoncamel> Cale: Oh, thanks you very much.
12:42:32 <Cale> leoncamel: Of particular interest are -ddump-simpl which outputs the final core after simplification (Core is an austere low-level version of Haskell which is the final intermediate language in GHC that you'd call functional)
12:42:33 <MadHatterDude> @pl \f g h x y = f (g x) (h y)
12:42:33 <lambdabot> (line 1, column 12):
12:42:34 <lambdabot> unexpected "="
12:42:34 <lambdabot> expecting pattern or "->"
12:42:44 <MadHatterDude> @pl \f g h x y -> f (g x) (h y)
12:42:44 <lambdabot> ((flip . ((.) .)) .) . (.)
12:43:14 <FliPPeh__> What would be the parsec instruction to match on an empty line?
12:43:40 <Cale> leoncamel: and -ddump-asm and -ddump-cmm of course
12:43:46 <pastorn> FliPPeh__: return ()
12:43:51 <pastorn> hehe
12:43:52 <pastorn> nah
12:43:56 <FliPPeh__> :|
12:44:00 <FliPPeh__> You's trolling
12:44:01 <pastorn> char '\n'
12:44:18 <FliPPeh__> But how do I verify that I'm actually at the first character on the line?
12:44:21 <FliPPeh__> :/
12:44:28 <pastorn> i think there's a 'newline' in parsec that matchs both *nix and windows newline
12:44:36 <Cale> FliPPeh__: huh?
12:44:48 <pastorn> FliPPeh__: you'll just have to know that when you do your call :)
12:44:59 <Cale> FliPPeh__: That's not trolling, return () will match anything and not eat any characters. Do you want to know whether you're at the end of the string?
12:45:04 <Cale> FliPPeh__: You could use eof
12:45:12 <FliPPeh__> Given something like this "Some test\n\nDurrrr", the Durrrr should only be legal if there's in fact an empty line infront of it
12:45:18 <pastorn> Cale: actually i was trolling :p
12:45:22 <Cale> Newline in Haskell is always '\n'
12:45:30 <mercury^> Cale: do you know if sketches of categories instantiated in things different from Set have been studied? I instantiated them in Cat today and what I got was quite nice (intertwiners as morphisms between morphisms), so it would seem a good choice for 2-categories.
12:45:37 <fax> interesting thing about 2xA = 2xB is that the 'permutation' can swap elements of {1,2} with ones of b
12:45:41 <Cale> You should never have to worry about newline encoding regardless of which platform you run your program on.
12:45:42 <pastorn> Cale: well, '\r' exists as well
12:45:46 <FliPPeh__> What I want to do is write a Markdown parser
12:45:48 <leoncamel> Cale: Oh my god. what is the grammar of "-ddump-simpl"... I can't read it .
12:45:54 <FliPPeh__> I know there's already finished ones on hackage
12:45:59 <FliPPeh__> But I need to train my haskell-fu!
12:46:00 <Cale> It exists, but you won't get any when you read files in text mode.
12:46:23 <pastorn> FliPPeh__: p = string "some test" >> newline >> newline >> string "Durrrrrrrrrr"
12:46:28 <Cale> leoncamel: It's a heavily-simplified version of Haskell.
12:47:01 <mercury^> "simplified"
12:47:07 <Cale> leoncamel: With some additional syntax for annotations that you can probably ignore.
12:47:36 <Cale> leoncamel: Type applications for polymorphic functions are explicit.
12:47:38 <pastorn> leoncamel: when the actual compilation kicks in you want all code represented in as few ways as possible
12:47:58 <pastorn> leoncamel: so all list pretty printing etc. are transformed
12:48:36 <Cale> At the level of core, all pattern matching is done using case expressions, which only match one constructor at a time
12:48:38 <leoncamel> pastorn: Oh, nothing special, I am just curious the internal part of ghc.
12:49:01 <Cale> and let expressions are used to control what goes on the heap
12:49:18 <pastorn> Cale: oh, cool :)
12:49:46 <leoncamel> So, is the "-ddump-simpl" stuffs is the "standard" or "haskell 98 report"'s grammer? Or, it is ghc-specific one ?
12:49:52 <pastorn> Cale: does it also do where --> let?
12:49:53 <Cale> GHC-specific
12:50:18 <leoncamel> Cale: OK, thanks.
12:50:20 <Cale> pastorn: yes
12:50:51 <leoncamel> Cale: Is there any manual describ these grammars ?
12:50:56 <Cale> leoncamel: In fact, Haskell isn't standardised even as far as operational semantics, only in terms of the results and termination behaviour of programs.
12:51:10 <Cale> leoncamel: They're internal to GHC, so they change between versions.
12:51:15 <Cale> (slightly)
12:51:26 <Cale> But if you're familiar with Haskell, you should be able to read it (slowly)
12:52:11 <Cale> The most confusing part is probably all the identifiers that get generated by GHC and consist of random numbers and letters
12:52:28 <Cale> You could do a bunch of search and replaces on them as you work out what they refer to.
12:53:15 <leoncamel> Cale: OK. So, what does "@" mean ? for example "@ GHC.Integer.Type.Integer". It seems like a type indicator ?
12:53:30 <Cale> and after that, the weirdest thing would be the explicit type applications (which look like "@ (GHC.Types.Int)") whenever a polymorphic function is used, and you can mostly just ignore those
12:53:34 <Cale> yeah
12:53:42 <MadHatterDude> @pl let x = takeWhile id; y = dropWhile id in (\s -> (x s, y s)
12:53:42 <lambdabot> (line 1, column 60):
12:53:43 <lambdabot> unexpected end of input
12:53:43 <lambdabot> expecting variable, "(", operator or ")"
12:54:01 <EvanR-work> MadHatterDude: missing last )
12:54:07 <MadHatterDude> oh
12:54:12 <Cale> When you use, for example a typeclass polymorphic function at a specific type, some information has to be passed along there which is what that represents.
12:54:13 <MadHatterDude>  @pl let x = takeWhile id; y = dropWhile id in (\s -> (x s, y s))
12:54:33 <EvanR-work>  @src head
12:54:42 <MadHatterDude> @pl let x = takeWhile id; y = dropWhile id in (\s -> (x s, y s)
12:54:42 <lambdabot> (line 1, column 60):
12:54:42 <lambdabot> unexpected end of input
12:54:42 <lambdabot> expecting variable, "(", operator or ")"
12:54:43 <EvanR-work> extra space at the beginning not allowed!
12:54:56 <EvanR-work> MadHatterDude: missing last )
12:55:06 <MadHatterDude> i know
12:55:11 <sinelaw> what's a possible denotation for a robot? (that takes commands, performs then, gives telemetries)
12:55:21 <Cale> leoncamel: consider something like:
12:55:27 <Cale> main = do x <- getLine
12:55:27 <Cale>           print (read x :: Integer)
12:55:58 <sinelaw> i can't see how to model that concisely
12:56:03 <Cale> leoncamel: The function 'read' is polymorphic, and will parse the string x using a different parser depending on the type of its result
12:56:08 <fax> sinelaw use monad
12:56:29 <Cale> leoncamel: So some information about which parser to use needs to be passed in at some level.
12:56:48 <sinelaw> fax, what? i'm trying to define it abstractly, mathematically if you please
12:56:51 <Cale> leoncamel: So in the core, you'll see something like:
12:56:56 <fax> oh MATHEMATICIALLY
12:56:57 <sinelaw> not talking about haskell specifically
12:57:03 <fax> forget about monad then
12:57:11 <Cale> (Text.Read.read @ GHC.Integer.Internals.Integer GHC.Read.$f19 x_aft)
12:57:33 <sinelaw> fax, e.g. (Time->Commands) -> (Time->(Telemetries, ???))
12:57:44 <sinelaw> the "actions" part is my problem i guess
12:57:45 <fax> that looks like haskell
12:58:14 <sinelaw> fax, i'm just using haskell notations.
12:58:19 <Cale> leoncamel: Which applies the function read to a type parameter (Integer), and then to this funny $f19 thing which is presumably the dictionary of operations for the Read typeclass
12:58:31 <sinelaw> fax, which in this case coincide with the math ones, btw.
12:58:33 <leoncamel> Cale: I understood most of your example. But, what does "GHC.Read.$f19" mean exactly ?
12:58:38 <sinelaw> a robot is a function?
12:59:09 <sinelaw> the ??? could be "RobotState"
12:59:22 <sinelaw> i think that's how Yampa robot people did it.
12:59:24 <EvanR-work> a robot could have internal state, but doesnt it also have an environment
12:59:37 <sinelaw> where RobotState = position, velocity, etc.
12:59:43 <Cale> leoncamel: It's probably a record consisting of implementations for the operations in the Read typeclass for Integer values
13:00:07 <leoncamel> Cale: Oh. interesting ...
13:00:09 <sinelaw> EvanR-work, i'm not talking about internal state
13:00:28 <Cale> leoncamel: It'll be read's job to extract the appropriate operation from that record and use it to parse the string x_aft
13:00:30 <sinelaw> EvanR-work, RobotState would probably be "the robot's relation to it's environment"
13:00:37 <sinelaw> *its
13:01:20 <Cale> leoncamel: In the core for the same program, you'll also see:
13:01:41 <Cale> Actually, let's look at the whole thing, I'll stick it on hpaste
13:02:55 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24760#a24760
13:03:03 <Apocalisp> What do you call a morphism between functors?
13:03:12 <Cale> Apocalisp: a natural transformation
13:03:21 <Apocalisp> Cale: !
13:03:47 <Cale> leoncamel: So, in the definition of Main.main, you see the monad operation >>= gets used explicitly (the do-notation has been desugared)
13:03:52 <sinelaw> preflex, seen littlebear
13:03:53 <preflex>  littlebear was last seen on #httpd 20 hours, 24 minutes and 22 seconds ago, saying: jMCg: thehehehe, it works for my httpd
13:04:01 <Cale> and not only that, but >>= is applied to all the type parameters which it's polymorphic over
13:04:02 <sinelaw> what's his case
13:04:09 <pastorn> Cale: what are the [] after [GlobalId] ?
13:04:19 <Cale> pastorn: That, I'm not sure
13:04:29 <sinelaw> ops: someone temporarily ban littlebear?
13:04:44 <Cale> pastorn: Maybe strictness information, but these definitions aren't defining functions
13:04:54 <Cale> (so you get an empty list)
13:05:03 <pastorn> ok
13:05:11 --- mode: ChanServ set +o Cale
13:05:17 <sinelaw> seems to have stopped now
13:05:20 <Cale> oh, good
13:05:20 <shapr> Would be fun to write an Arduino emulator in Haskell.
13:05:22 --- mode: Cale set -o Cale
13:05:33 <Cale> shapr: Yeah, that'd be awesome. :)
13:06:07 <shapr> Are there any CPU emulators written in Haskell?
13:06:11 * shapr asks the internets
13:06:12 <Cale> leoncamel: Okay, so you have >>= and it's explicitly applied to the type IO (which is the monad we're using), and then to what should be a dictionary for the Monad typeclass for IO
13:06:26 <pastorn> shapr: OmegaGB is a Z80 emulator
13:06:29 <shapr> Whoa, OmegaGB
13:06:29 <pastorn> *has*
13:06:31 <shapr> pastorn: Right!
13:06:33 <Cale> and then to the type String, because it's being applied at the type IO String -> (String -> IO ()) -> IO ()
13:06:40 <Cale> and then lastly to the type ()
13:06:57 <Cale> (which is the type of the final result)
13:07:19 <Cale> and *then* finally it gets its first "real" parameter, which is getLine
13:08:15 <Cale> and its second parameter, which is a lambda
13:09:19 <leoncamel> Cale: BTW, which version of your GHC ?
13:09:47 <sinelaw> shapr, since i know you're into hardware, you might like this: http://www.altera.com/products/devkits/altera/kit-cyc3-embedded.html
13:10:09 <Cale> 6.10.4
13:10:17 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24760#a24761 -- here's the optimised output
13:11:17 <Cale> You get to see some direct references to the input and output handles then, and there's some unboxed stuff (unboxed pairs, specifically) creeping into the code
13:11:30 <leoncamel> Cale: Oh my . The optimized one is harder to read ...
13:11:34 <Cale> indeed
13:11:42 <shapr> sinelaw: Yow, I wonder if the latest version of Lava can dump netlists directly to that board? And Yow, I don't have $500 to spare.
13:11:45 <sinelaw> shapr, comes with an fpga, > 32mb ram, 800x480 lcd touchscreen, vga output, sd card reader, audio, ps/2, tv-in, serial port, ethernet...
13:11:45 <Cale> Some inlining has taken place
13:11:55 <shapr> sinelaw: Very cool, would be great for playing with Lava.
13:12:14 <sinelaw> shapr, i did some fpga stuff today in univ. it's nice
13:12:19 <sinelaw> yeah, expensive stuff
13:12:48 <shapr> Have you seen Lava? http://www.raintown.org/lava/
13:12:56 <fax> what's double infinity path
13:12:59 <sinelaw> shapr, yes
13:13:06 <fax> I guess that's like Z? where as singly infinite is like N
13:13:08 * benmachine wonders why there are two Main.mains, one of which has a : in front of it
13:13:23 <sinelaw> shapr, in univ. i need to use vhdl or verilog, so no time to try that out
13:13:33 <Cale> benmachine: That I have no idea.
13:13:37 <sinelaw> but lava looks cool
13:13:58 <shapr> Yeah, it appears to output netlists, so you might be able to use it instead of verilog or vhdl.
13:14:06 <sinelaw> i think it outputs vhdl too
13:14:25 <sinelaw> which is better because the fpga compiler can optimize it better to fit the chip?
13:14:42 <shapr> I don't know.
13:15:07 <Cale> leoncamel: One thing that we see in the optimised version is some explicit passing around of RealWorld values as part of the hacky implementation of the IO type.
13:15:52 <leoncamel> Cale: yes. The [] after "[GlobalId]" becomes harder to read then.
13:16:16 <Cale> ah, yeah, now we have some actual information in there
13:16:27 <Cale> [Arity 1  Str: DmdType L]
13:16:42 <leoncamel> Cale: Yes. But what does that mean ?
13:17:56 <Cale> Since this Main.a value that it's introduced is actually a function, it just says that the arity of the function is 1 (only waits for one parameter before returning a real result) and the strictness analyser gets to record some information there.
13:18:32 <Cale> It says that apparently the function is lazy in its input value
13:18:52 <Cale> Which means that it doesn't pattern match on it
13:19:01 <Cale> Which makes sense, because there actually are no values State# RealWorld to pattern match against
13:19:41 <Cale> it's just a token type to help the compiler keep straight which order the effects are supposed to happen in using its existing machinery for keeping data dependencies straight
13:20:12 <Cale> (the L is for lazy, you also sometimes see an S there)
13:20:17 <Cale> (for strict)
13:22:34 <xerox> Calelogue
13:23:09 <BMeph> shapr: Speaking of hardware, have you been following the latest hubbub about memristors?
13:23:41 <Cale> memristors are awesome
13:25:35 <Cale> A bunch of memristors arranged in a crossbar array not only serve as a memory, but can also compute logical implication, (set B to A implies B), which is computationally complete. :)
13:26:23 <chrisdone> what does computationally complete mean?
13:26:42 <Cale> Means you can combine operations of that type to get any computation you want.
13:27:18 <Cale> Well, implication on its own isn't technically computationally complete, you also need the constant False, but that's easy.
13:27:58 <Cale> So in the future, we might have computers whose RAM and CPU are the same thing, and if you need more processing power, you can just trade more memory to do processing.
13:29:31 <Cale> and they're really structurally incredibly simple -- a crossbar array of memristors, which would be driven by some multiplexing/demultiplexing stuff and some control logic implemented in transistors.
13:29:56 <leoncamel> Cale: OH. awesome ... When will it comes true ?
13:30:53 <Cale> Well... as I understand it, there are still some engineering problems with memristors (not quite so many use cycles as you'd want, but people seem not too concerned about this, as early transistors had similar issues)
13:31:29 <Cale> But now that we know that they exist and how to look for them, things are pretty exciting. :)
13:32:20 <dolio> They'll be available shortly after the OLED screens that were supposed to come out several years ago.
13:32:30 <Cale> http://www.youtube.com/watch?v=QFdDPzcZwbs
13:32:46 <Cale> That's a series of talks about memristors
13:33:31 <nus> dolio, [-:
13:33:34 <Cale> Starting with the basic abstract physics, and then about some of the physical implementations of it, and then a talk on what you might build with them.
13:33:38 <Dashkal> Sweet, I'm one step closer to writing my own pure sudoku solver.  I know it's been done, but I'm not finished with that damn puzzle until I write my own solver!
13:34:05 <jmcarthur> this sounds pretty cool
13:34:11 <jmcarthur> i will have to check this out later
13:34:13 <Cale> (and there are some other parts as well which are interesting, but I found the first part more interesting than the rest)
13:36:08 <Cale> The other awesome thing about memristors is that they're non-volatile memory, and only require power to read and write.
13:36:14 * nus already wnats portable hydrogen-cell fuelled memresistor transputer
13:37:10 <Cale> Actually, even more exciting would be a meminductor or memcapacitor, since you'd get (most of) your energy back, but nobody knows how to make those yet. :)
13:37:46 <MadHatterDude> What is wrong with "class PatternExpr a where { toPatternExpr :: a -> Pattern }"?
13:38:08 <Cale> MadHatterDude: Nothing?
13:38:28 * quicksilver remembers the transputer from Knight Tyme.
13:38:34 <MadHatterDude> Followed by "instance PatternExpr String where { toPatExpr s = ... }"
13:39:01 <fax> idk
13:39:05 <ClaudiusMaximus> TypeSynonymInstances ?
13:39:19 <MadHatterDude> I've tried with [Char]
13:39:28 <fax> what's the problem
13:39:41 <jmcarthur> hmm, does this hinder the ghc port to the iphone? http://daringfireball.net/2010/04/iphone_agreement_bans_flash_compiler
13:39:42 <quicksilver> MadHatterDude: TypeSynonym instances *and* FlexibleInstances
13:39:46 <MadHatterDude> Tells me that its illegal
13:39:51 <Cale> You also can't (in Haskell 98) define an instance for [Char], since it's a type constructor applied to a specific type
13:39:54 <MadHatterDude> ok
13:39:54 <fax> illegal why?
13:39:59 <Cale> (and not a type variable)
13:40:04 <fax> that's insanity
13:40:06 <quicksilver> (the hint is supposed to tell you what extension you miss isn't it?)
13:40:13 <dolio> Instances have to have the form T a b c ... in H98.
13:40:15 <fax> they shoudl have realized this while trying to implement show xD
13:40:31 <quicksilver> fax: the haskell98 committee felt that all instances of type constructors should be parametrically polymorphic
13:40:34 <Cale> :t showList
13:40:35 <lambdabot> forall a. (Show a) => [a] -> String -> String
13:40:36 <jmcarthur> and where is GLSL in that list of allowed langguages?
13:40:47 <Cale> ^^ what do you think that's for? ;)
13:40:47 <dolio> You have to use a trick for Show anyway, unless you have overlapping instances.
13:40:47 <fax> quicksilver: then why does Show work on strings
13:40:56 <quicksilver> fax: it's a disgusting hack.
13:40:56 <Cale> fax: Because of showList
13:40:57 <dolio> And overlapping instances are sketchy.
13:41:06 <fax> so like
13:41:10 <Cale> I don't think the hack is all *that* disgusting.
13:41:20 <fax> how can they have not realized this is a problem
13:41:22 <quicksilver> and as dolio says it's more about overlapping than flexible, really.
13:41:27 <fax> it seems like the most obvious thing ever
13:41:32 <fax> if you were designing the language
13:41:42 <quicksilver> they realised it's a debate, and they chose what seemed to be the right answer.
13:41:50 <quicksilver> without MPTCs I would probabky make the same choice.
13:41:58 <Vanadium> So what is the rule for what types can be instances? :I
13:41:59 <quicksilver> it's only with MPTCs that it becomes really annoying.
13:42:14 <quicksilver> Vanadium: the rule is, use FlexibleInstances and forget about it :)
13:42:19 <Cale> fax: Haskell 98 specified typeclasses in the most conservative possible way
13:42:26 <dcoutts_> illissius: re cabal update, does this happen every time, if so are you on windows using version 0.8.0 ?
13:42:37 <Cale> Instance selection in Haskell 98 is as easy as possible.
13:42:46 <fax> why didn't they make show on strings not abnormal?
13:42:52 <Cale> You only look at *one* thing in order to determine which instance to use: the top level type constructor
13:43:01 <fax> I mean who thinks 'lets add weird edge cases for no apparent reason'
13:43:30 <Cale> fax: because strings are practically unreadable if you write them all as lists of Chars
13:43:49 <MadHatterDude> Now I have a {-# LANGUAGE #-} with TypeSynonymInstances but it tells me I don't...
13:44:02 <fax> they can just use a function that prints strings
13:44:04 <fax> hm
13:44:16 <fax> no that is not a good solution in the case that strings are within some other structure
13:44:41 <Cale> ['U','n','l','e','s','s',' ','y','o','u',' ','r','e','a','l','l','y',' ','l','i','k','e',' ','r','e','a','d','i','n','g',' ','t','h','i','s','.']
13:44:51 <quicksilver> MadHatterDude: you need FlexibleInstances too?
13:45:15 <Cale> MadHatterDude: Doesn't the error message tell you which extension to turn on?
13:45:44 <Cale> I was pretty sure that one mentions FlexibleInstances
13:45:50 <Jafet> (:) 'O' ((:) 'r' ((:) ' ' ((:) 't' ((:) 'h' ((:) 'i' ((:) 's' ((:) '!' [])))))))
13:46:05 <quicksilver> Jafet++
13:46:14 <EvanR-work> > (:) 'O' ((:) 'r' ((:) ' ' ((:) 't' ((:) 'h' ((:) 'i' ((:) 's'  ((:) '!' [])))))))
13:46:15 <lambdabot>   "Or this!"
13:46:22 <quicksilver> although, in a way, that makes the opposite point too
13:46:26 <dolio> Even deriving show gets infix constructors right. :)
13:46:41 <quicksilver> show instances are pretty horrid for any non-trivial data structure
13:46:48 <quicksilver> isn't it a terrible hack to special-case it for String?
13:47:06 <quicksilver> since it will look horrid for any user-reimplementation of List.
13:47:13 <MadHatterDude> Cale: No, It says i dont need flexible
13:47:35 <EvanR-work> there should be a pretty printer for standard output of show
13:48:23 <jmcarthur> wow, i didn't realize the spec was apparently inconsistent with itself
13:48:37 <Cale> foo.hs:3:0:
13:48:38 <Cale>     Illegal instance declaration for `C String'
13:48:38 <Cale>         (All instance types must be of the form (T t1 ... tn)
13:48:38 <Cale>          where T is not a synonym.
13:48:38 <Cale>          Use -XTypeSynonymInstances if you want to disable this.)
13:48:38 <Cale>     In the instance declaration for `C String'
13:48:45 <pastorn> jmcarthur: which spec?
13:48:50 <jmcarthur> pastorn: h98
13:49:14 <MadHatterDude> Cale, that is what I see too, but I have a LANGUAGE pragma with it...
13:49:26 <Cale> Oh, interesting, TypeSynonymInstances implies FlexibleInstances, apparently
13:49:32 <Cale> error goes away when I add it
13:49:33 <jmcarthur> woah
13:49:48 <jmcarthur> then why do so many of my projects have both extensions? :\
13:49:58 <Cale> er, lol
13:50:04 <Cale> [Char] still fails
13:50:08 <jmcarthur> lol
13:50:12 <Cale> But String works
13:50:13 <jmcarthur> wow, that's bad
13:50:37 <fax> insane
13:50:38 <jmcarthur> i'd file a ticket for that one. that's lame
13:50:41 <Cale> yeah
13:50:45 <fax> the whole thing is wrong
13:50:51 <Cale> fax: eh?
13:50:59 <fax> string vs [char]
13:51:07 <fax> it just doesn't make sense
13:51:14 <jmcarthur> maybe if string was a newtype...
13:51:15 <Cale> fax: Yeah, they ought to be treated in the same way.
13:51:20 <fax> yes it could be a newtype
13:51:27 <jmcarthur> not that i'm advocating that as the solution
13:51:31 <EvanR-work> they arent??
13:51:34 <fax> maybe that technique had not been learned yet
13:51:39 <fax> when they were inventing the language
13:51:49 <Cale> fax: hm?
13:52:04 <aavogt> if string was a newtype say goodbye to nice pattern matching
13:52:05 <Cale> I *really* like that Strings are lists.
13:52:07 <quicksilver> it was undoubtedly considered to make string a newtype.
13:52:08 <jmcarthur> yeah
13:52:16 <quicksilver> but that means you can't map them, fold them, and filter them
13:52:16 <Cale> and that therefore you can apply all the list functions to them
13:52:19 <quicksilver> it's a trade-off
13:52:25 <fax> Cale what about these strange effects with typeclasses though
13:52:34 <Cale> Not a big deal.
13:52:37 <jmcarthur> fax: we could just have flexible instances
13:52:42 <jmcarthur> in the spec
13:52:49 <aavogt> and are there lists of Chars that are not also logically Strings?
13:52:51 <Cale> Though the TypeSynonymInstances bug is definitely a bug.
13:52:57 <fax> we could have coercions
13:53:04 <fax> that let you use list functions on a newtype of list
13:53:06 <jmcarthur> aavogt: sometimes, yes
13:53:16 <fax> hm
13:53:20 <fax> I wonder if that works
13:53:30 <Cale> fax: FlexibleInstances is a pretty uncontroversial language extension
13:53:32 <pastorn> jmcarthur: do you know of any cool DSLs on hackage i might use to generate a Texture3D?
13:53:34 <jmcarthur> aavogt: sometimes as a shortcut for individual chars i use a string literal though. it's handy :)
13:53:40 <jmcarthur> pastorn: i know of none
13:53:41 <pastorn> think: terrain with snowy tops
13:54:04 <jmcarthur> pastorn: i think that's the wrong way to go
13:54:14 <pastorn> ok?
13:54:16 <quicksilver> jmcarthur: flexibleinstances doesn't solve the show problem, of course - it just sends you down the overlapping path
13:54:29 <jmcarthur> pastorn: you don't just want vertical height to be the only factor. you also need to account for the slope of the mountain
13:54:30 <Gracenotes> isn't there hogre? if you don't mind doing C++y-OOP in Haskell?
13:54:42 <jmcarthur> quicksilver: oh it does. hmm
13:54:51 <quicksilver> and overlapping is definitely worse than the showList hack ;)
13:54:58 <pastorn> jmcarthur: oh, you mean i should take the actual terrain into account
13:55:06 <jmcarthur> pastorn: snow doesn't stick to the side of a cliff, for example
13:55:07 <Gracenotes> uh.. texture3d... nvm
13:55:14 <pastorn> yeah, you're right
13:55:16 <quicksilver> you could use a 1d texture for snowline, actually
13:55:29 <quicksilver> (but use a 'clever' lookup function which takes snow into account)
13:55:35 <quicksilver> slope!
13:55:38 <quicksilver> takes slope into account.
13:55:47 <pastorn> hmmm
13:56:02 <quicksilver> 3D textures use a lot of memory if you want them to be details, quite a big hammer to use.
13:56:03 <pastorn> buildTex3D :: HeightMap -> NormalMap -> Texture3D
13:56:26 <pastorn> but then it might as well be 2D
13:56:30 <FliPPeh__> Gah, Parsec is giving me the creeps again
13:56:42 <pastorn> FliPPeh__: what do you want to do now?
13:56:42 <MadHatterDude> If I can just get ghc to register "{-# LANGUAGE TypeSynonymInstances #-}" then I will have some awesome regexes
13:57:11 <FliPPeh__> pastorn: I want to split an input of "Hello\nWorld\n" to ["Hello", "World"] for example, but it will only grab the first "Hello" part, and abort
13:57:18 <FliPPeh__>  many1 . try $ parseTextBlock
13:57:22 <FliPPeh__> It should work.
13:57:34 <FliPPeh__> The try is because there's going to be more choices later
13:58:00 <FliPPeh__> parseTextBlock = (many1 $ noneOf eol) >>= return . MdText
13:58:05 <FliPPeh__>  eol = "\n"
13:58:07 <FliPPeh__> That's all
13:58:14 <FliPPeh__> Yet I wonder why it fails
13:59:42 <EvanR-work> > lines "Hello\nWorld\n"
13:59:43 <lambdabot>   ["Hello","World"]
13:59:54 <pastorn> hahahahhaha
13:59:54 <FliPPeh__> EvanR-work: If it only was that easy
13:59:56 <pastorn> EvanR-work: good :)
14:00:06 <aavogt> use liftM f   instead of     >>= return . f
14:00:08 <FliPPeh__> Try parsing a markdown file with "lines"
14:00:28 <EvanR-work> so eol != "\n" i take it
14:00:34 <pastorn> FliPPeh__: tried 'sepBy1'?
14:00:34 <aavogt> though fmap is almost equivalent
14:03:34 <dolio> Cale: This first talk on memristors seems to imply that there isn't any circuit element missing suggesting memductors or mempacitors like there is memristors.
14:06:45 <Cale> dolio: yeah, you have to look at some other variables
14:09:56 <lpsmith> huh,  why does cmdargs use unsafePerformIO?
14:10:53 <Cale> dolio: Specifically, I recall they're defined in terms of the integral of charge and flux, which don't have traditional names, but are well defined concepts anyway.
14:11:01 <Cale> lpsmith: cmdargs?
14:11:27 <dolio> Ah, okay.
14:11:36 <lpsmith> Cale:  http://hackage.haskell.org/package/cmdargs
14:11:47 <Cale> lpsmith: apparently it uses it to create a top-level IORef
14:11:56 <dolio> lpsmith: It uses evil for your convenience.
14:11:56 <Cale> which seems silly to me, but that's what it does
14:12:08 <Cale> {-# NOINLINE verbosity #-}
14:12:08 <Cale> verbosity :: IORef Int -- 0 = quiet, 1 = normal, 2 = verbose
14:12:08 <Cale> verbosity = unsafePerformIO $ newIORef 1
14:12:13 <Twey> Config
14:12:37 <Twey> Someone should've read Oleg's paper on class-as-config
14:12:50 <dmhouse> Out of interest, what would be the alternative to that IORef?
14:12:58 <dolio> Oh, this isn't the one I was thinking of.
14:13:19 <dmhouse> I presume its some verbosity parameter that affects many of the functions throughout the package
14:13:22 <Twey> dmhouse: Manual passing, Reader, or class-as-config
14:13:29 <dmhouse> If most of it is pure, Reader is a massive pain
14:13:32 <Twey> Yeah
14:13:33 <lpsmith> yeah,  I can see what it does,  but I'm trying to understand the justification for the approach
14:13:36 <Twey> As is manual passing
14:13:38 <dolio> A week or two back, someone pointed me to a package where the actual argument handling involved unsafePerformIO.
14:13:41 <Twey> Hence the class-as-config idea
14:13:53 <dmhouse> ?google class as config haskell
14:13:55 <lambdabot> http://www.haskell.org/haskellwiki/Xmonad/Using_xmonad_in_KDE
14:13:55 <lambdabot> Title: Xmonad/Using xmonad in KDE - HaskellWiki
14:14:03 <burp> "Building salvia-1.0.0... cannot satisfy -package-id stm-2.1.1.2-9e44809d58563cca54113fa78642d02e stm-2.1.1.2-9e44809d58563cca54113fa78642d02e is unusable due to missing or recursive dependencies: array-0.3.0.0-b96ee5db37b7b8c8ac703dc693fd568c base-4.2.0.0-b340bbd470b5859bcbb920aea62a12cf" what does this mean?
14:14:24 <BMeph> Cale, dolio: Rather, he points out that the regular form of the equations for caps and inds are wrong, but the integral form is right.
14:14:41 <dmhouse> Twey: link?
14:14:45 <burp> base 4.2.0.0 and array 0.3.0.0 are both installed, and also stm-2.1.1.2
14:14:57 <Cale> BMeph: I was referring to how memcapacitors and meminductors arise naturally
14:15:14 <Twey> dmhouse: Hm… link seems broken… http://okmij.org/ftp/Haskell/types.html#Prepose
14:15:59 <Cale> BMeph: By taking the integral *again*, and considering how there might be some device to mediate between those new variables
14:16:43 <Twey> Ah, here's one: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
14:16:43 <dmhouse> What are the disadvantages of the IORef approach?
14:16:47 <Twey> Damn, that was hard to find
14:16:58 <dmhouse> Twey: that first link seems to be right
14:17:03 <BMeph> Cale: Okay, that's fair. I'll have to look & listen to the talks again, I see. :)
14:17:14 <dmhouse> Oh, the outgoing link is broken, I see.
14:17:17 <Twey> Yeah.
14:17:22 <Twey> As is the backup I found on the mailing list.
14:17:38 <Twey> Anyway, there it is.
14:17:50 <lpsmith> dolio:  of the "args" packages on hackage,  only cmdargs uses unsafePerformIO,  parseargs and simpleargs do not
14:18:18 <Twey> dmhouse: Disadvantages to the IORef: unsafePerformIO, breaks optimisations, only allows one global configuration, requires manual unpacking
14:18:19 <dolio> Cale: Doesn't that give you... 6 new missing elements?
14:18:47 <Cale> BMeph: A memory capacitor is an element which defines a fixed relationship between the the flux and integral of charge, and then dually, a meminductor defines a fixed relationship between charge and the integral of flux.
14:18:55 <Cale> hmm, maybe there will be some others as well...
14:19:00 <alpounet> BMeph, Cale: link to the talk ?
14:19:27 <Cale> http://www.youtube.com/watch?v=QFdDPzcZwbs
14:20:00 <BMeph> All of the talks: http://www.youtube.com/view_play_list?p=F011AD9800F4E787
14:20:36 <BMeph> Cale: I'm reading the original '71 paper now... :)
14:20:38 <Cale> maybe up to 5 more devices, rather than 6
14:20:46 <fax> wbat the thell is 'applied math' why don'tthey call it beginners physics
14:21:03 <Cale> fax: Applied mathematics is usually the proper treatment of physics :)
14:21:15 <fax> wait so real physics is like
14:21:24 <Cale> fax: But it's really a more general term
14:21:33 <Cale> any practical application of mathematics
14:22:15 <fax> like programming
14:22:16 <fax> ?
14:22:51 <Twey> Or statistics
14:23:53 <garious> i have a C library that can be configured to write its output to a file descriptor, and i want that information as a Haskell String?  What can I do?
14:24:11 <mauke> pipe + fork
14:24:29 <garious> no posix API available
14:24:39 <Vanadium> Why not?
14:24:57 <garious> i'm on windows and am hoping to avoid linking to mingw
14:25:15 <Vanadium> ಠ_ಠ
14:25:23 <garious> actually, i'm not sure mingw has windows.  but i'd really like to not link to cygwin
14:25:32 <dcoutts_> garious: can't you configure it to write to something more sensible?
14:25:47 <dolio> lpsmith: Well, I don't think I have any chance of finding the thing I'm talking about. I don't think it was a dream, though. :)
14:25:56 <quicksilver> how can file descripotors exist if you don't have posix?
14:26:00 <dcoutts_> garious: even C code would have difficulty intercepting that output
14:26:06 <quicksilver> I thought windows just had some notion of 'handle', not fd
14:26:17 <Cale> fax: yep
14:26:22 <dcoutts_> quicksilver: windows C lib has file descriptors, they're really win32 handles
14:26:23 <dantheman_>   Hey all,  I have a (pretty long!) question for you re how to go about structuring a haskell program I'm designing. The program consists of a set of components each performing different tasks. Each  component runs in its own thread, and I want to  make them communicate with each other via channels (i.e. Chan from Control.Concurrent). This lets me keep everything nice and loosely coupled, and in many ways similar to the struct
14:26:31 <EvanR-work> posix like c code works fine on windows
14:26:46 <Cale> dantheman_: cut off at "similar to the struct"
14:26:47 <dantheman_> in it). The main thread of the program begins by creating all the channels needed by every component, (which in a sense form a graph), and then initializing each component with the channels that  it needs. The thing that's annoying me is that I have to pass the different channels a component needs as parameters to the initialization functions (and in many cases as parameters in functions internal to a component). Every time I 
14:26:59 <garious> hoping to avoid doing too much rework.  trying to use 'ucpp' a C preprocessor with a friendly BSD license
14:27:02 <Cale> dantheman_: cut off at "Every time I"
14:27:10 <dantheman_> definitions for all of these functions, even if no changes are needed in the body. I'd like a way to wrap all the channels into a single object that can be threaded though all these functions. Bearing in mind these channels may all have different types (e.g.  Chan a, Chan b etc), how would you suggest representing them?
14:27:39 <dcoutts_> dantheman_: a record?
14:27:41 <kevinulin> is there an 'Either' data type for 3 or more items?
14:27:51 <fax> keinulin, use Either twice
14:27:56 <kevinulin> hah
14:28:07 <EvanR-work> use different constructors
14:28:21 <dantheman_> Sorry, posted here again if its hard to read: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24764#a24764
14:28:27 <garious> EvanR: there's posix and there's ansi c.  i can use anything ansi
14:28:56 <EvanR-work> i think haskell works on windows, try that instead! ;)
14:29:09 <dantheman_> dcoutts: Thanks I'll check it out...
14:29:46 <garious> if my library were an executable, then I'd use readProcessWithExitCode, write to stdout, and capture it in haskell
14:30:33 <mauke> ansi c doesn't have file descriptors
14:30:42 <Cale> dantheman_: Yeah, a record
14:30:54 <Cale> dantheman_: (I concur ;)
14:31:02 <dcoutts_> dantheman_: it's probably best to have the set of channels for each component separately
14:31:21 <dantheman_> Yes, I intend to have them separately...
14:31:22 <dcoutts_> dantheman_: but within a component it's ok to bundle all the channels it needs and to pass that to internal functions
14:31:36 <dantheman_> I just want to have an extensible type like:
14:31:56 <dcoutts_> dantheman_: a record is the usual solution whenever you have a bunch of things that tend to get passed around together
14:31:57 <dantheman_> data ComponentChans = [Chan a]
14:32:12 <dantheman_> but in that case they must all have the same type a?
14:32:21 <dantheman_> Or am I misundersanding what  you mean by record?
14:32:26 <dcoutts_> dantheman_: right, so a list is not appropriate
14:32:36 <dcoutts_> since your channels have different types
14:32:44 <FliPPeh__> God
14:32:46 <FliPPeh__> I'm giving up
14:32:54 <fax> why
14:32:55 <Cale> FliPPeh__: What are you giving up on?
14:33:07 <kmc> Don't give up! Keep fuckin' that chicken
14:33:11 <FliPPeh__> Cale: Giving up on parsing this http://daringfireball.net/projects/markdown/index.text with Parsec
14:33:22 <FliPPeh__> It seems like an easy format
14:33:23 <kmc> FliPPeh__, pandoc can parse Markdown
14:33:27 <Cale> FliPPeh__: Markdown parsers already exist
14:33:29 <FliPPeh__> But I just can't get it together
14:33:30 <Cale> Yeah, use pandoc
14:33:32 <FliPPeh__> I know they exist
14:33:38 <FliPPeh__> But I want to learn freaking parsec
14:33:46 <fax> FliPPeh__????
14:33:54 <dcoutts_> start with a simpler problem that markdown
14:33:54 <fax> this is not a specification
14:33:56 <kmc> Markdown is not a very nice context-free grammar
14:33:57 <garious> pandoc parses markdown with parsec
14:33:57 <dantheman_> So do you mean use something like: ComponentChans = ComponentChans {chan1 :: Chan a, chan2 :: Chan b, chan3 :: Chan c}
14:33:57 <Cale> In that case, markdown seems like a hard thing to start with
14:34:21 <kmc> FliPPeh__, i'd start with something more regular and less idiosyncratic
14:34:22 <Cale> Maybe start with a simpler language.
14:34:31 <FliPPeh__> I had it parse the single blocks already, basically split by "\n\n"
14:34:36 <kmc> S-expressions are easy and they're useful too
14:34:45 <FliPPeh__> But then I had all the blocks as strings, and I'd have to recurse "parse"
14:34:51 <kmc> XML is the industrial re-invention of sexps, with more verbosity
14:34:52 <fax> recursive is okay
14:34:54 <kmc> you could parse that too
14:34:55 <MadHatterDude> Hmm what precendences to give...
14:34:55 <Cale> dantheman_: Yeah, only with better names :)
14:35:08 <Cale> dantheman_: and you probably want one such type for each type of component
14:35:24 <sinelaw> so Yampa guys implicitly defined a robot as a function: (Time -> Input) -> (Time -> Output)
14:35:27 <dantheman_> The problem with that is for every component I have to create a different type of ComponentChans
14:35:32 <fax> does Bayes' formula form a category?
14:35:33 <Cale> dantheman_: Then, when you want to add a channel, you just add it to the datatype, and nothing else changes, as long as you've been using the record syntax.
14:35:43 <sinelaw> which implies that given the same input, a robot will behave identically (give the same output)
14:35:54 <Cale> dantheman_: That's right, you do that.
14:36:09 <sinelaw> but this is only ok if "Input" includes the robot's environment (world state)
14:36:10 <Cale> dantheman_: Or is that considered too much?
14:36:29 <Cale> dantheman_: It seems not-too-unreasonable to me.
14:37:25 <sinelaw> fax, what sort of category would that be
14:37:30 <fax> CCC
14:38:03 <sinelaw> ah....(i know little about categories)
14:38:53 <garious> if i create a file in haskell, can i assume the handle is a FD that can be used in C?
14:39:09 <dantheman_> Hmm. Yes I guess it is. Its just that if in many cases different components have channels in common. It'd be nice if I could create a new ComponentChans by merging two or more other
14:39:13 <dantheman_> componentChans
14:39:26 <dantheman_> Instead of having to redefine each one explicitly
14:39:59 <FliPPeh__> What's a nice simple language to parse stuff for?
14:40:09 <Saizan> ?hoogle Handle -> IO FD
14:40:09 <lambdabot> Network.BufferType buf_hGetContents :: BufferOp a -> Handle -> IO a
14:40:10 <lambdabot> Network.BufferType buf_hGetLine :: BufferOp a -> Handle -> IO a
14:40:10 <lambdabot> Network.BufferType buf_hGet :: BufferOp a -> Handle -> Int -> IO a
14:40:10 <FauxFaux> Json.
14:40:22 <FliPPeh__> FauxFaux: I've already written a json parser :)
14:40:37 <Saizan> garious: however, i think there's an handleToFd somewhere under Posix
14:40:57 <mauke> which may close the handle
14:41:16 <dantheman_> So, something like : ComponentChans1 = ComponentChans1 {Chan a, Chan b},   ComponentChans2 = ComponentChans2 {Chan c, Chan d}, ComponentChans3 = (somehow!) ComponentChans1 + ComponentChans2, such that you can use the same accessor functions.
14:42:34 <EvanR-work> dantheman_: if its just a matter of passing the right chans to the right threads, and its too many chans to keep track of, i think the system is too complex
14:43:05 <EvanR-work> a fully connected graph microkernel sounds horrendous ;)
14:44:09 <kmc> garious, on UNIX, it will be a fd
14:44:20 <kmc> garious, it probably won't ever be a libc FILE*
14:44:23 <EvanR-work> w
14:44:46 <kmc> @type System.Posix.IO.handleToFd
14:44:47 <lambdabot> GHC.IOBase.Handle -> IO System.Posix.Types.Fd
14:44:54 <kmc> "This function has the side effect of closing the Handle and flushing its write buffer, if necessary."
14:45:39 <garious> okay, thanks all.  sounds like my best best is just reworking the code to write to a resizable string buffer
14:46:13 <kmc> garious, what are you trying to do?
14:46:40 <garious> kmc: trying to embed a C preprocessor in my haskell program
14:46:57 <dantheman_> EvanR.. I'm not sure. The thing is each of the different components do IO with an external api in different ways, and for testability reasons I'd like to be able to intercept all calls to that api, and generate my own callbacks in response.
14:47:11 <kmc> garious, i thought i saw a pure Haskell implementation of CPP somewhere
14:47:13 <dantheman_> Doing it this way makes that very easy and clean.
14:47:14 <garious> kmc: cpphs is LGPL, so i can't use that
14:47:18 <kmc> oh
14:50:09 <Philonous> Cabal complains that it doesn't find fuse.h even though it is located in /usr/local/include and the directory is listed in Include-Dirs in the cabal file. Any hints?
14:50:29 <dcoutts_> Philonous: it might be that it cannot be compiled
14:50:59 <dcoutts_> Philonous: cabal makes a little .c file that #includes the listed includes, if that cannot be compiled then cabal complains
14:51:21 <Philonous> dcoutts_ I see. I'll check that
14:53:45 <Philonous> dcoutts_ I take it cabal doesn't discriminate between compile errors when checking for includes?
14:54:27 <dcoutts_> Philonous: grepping the C compiler output would be a bit fragile. What it could do better though is to at least keep the log file and point you to it so you can check.
14:54:58 <dcoutts_> Philonous: we could probably also split it into a cpp'ing phase and a compiling phase
14:55:13 <dcoutts_> that'd distinguish failure to find headers, from the result not compiling
14:55:19 <dcoutts_> and again, from it not linking
14:55:30 <dcoutts_> we distinguish the linking already
14:56:41 <Philonous> dcoutts_ that would make a lot of sense, because the problem in my case wasn't that the header was not found but some different error. But all I get is "missing header file" which doesn't help at all
14:56:59 <dcoutts_> right, we've got open tickets on this issue
14:57:14 <dcoutts_> just need someone to find time to implement the known solutions
14:57:24 * dcoutts_ looks about for volunteers
14:57:52 <Philonous> dcoutts_ Thanks a bomb.
14:58:17 <kmc> dcoutts_, do you have a ticket link?
15:00:20 <sw17ch> dons: Does jdh show up more than I think, or do his appearances just resound loudly so that i don't miss any of them?
15:01:25 <dcoutts_> kmc: http://hackage.haskell.org/trac/hackage/ticket/532
15:04:22 <dcoutts_> kmc: lemme know if you have any Qs or need pointers
15:04:36 <dcoutts_> kmc: the code is in Cabal lib, D.S.Configure
15:04:39 <Philonous> dcoutts_ Though cabal is smart enough to set compiler flags on the test runs. Nice.
15:05:04 <dcoutts_> or nothing would work :-)
15:05:13 <dcoutts_> just crap at the error messages
15:07:57 <MadHatterDude> I have just come to looooooooooooove haskell's type inference and lazy semantics.
15:09:16 <oxamus> too bad haskell doesn't put out
15:09:25 <oxamus> not on the first date at least
15:09:39 <kmc> @vixen do you put out on the first date?
15:09:39 <lambdabot> yes i do
15:09:42 <kmc> there you go
15:09:47 <oxamus> lol
15:10:11 <MadHatterDude> oxamus: Me and Haskell almost have quarter anniversary
15:10:27 <pikhq> oxamus: It will have when you attempt to use the value of the first date.
15:10:29 <MadHatterDude> oxamus: And I am not your average guy in terms of IQ
15:10:33 <pikhq> Say, for talking about it.
15:12:09 <kmc> Haskell 98 is 12 years old...
15:12:14 <MadHatterDude> Anybody wanna see my brutal little regex-like text matcher?
15:14:53 <kmc> dcoutts_, so the idea is to write the c compiler's output to a temp file, then mention this in the error and rephrase to indicate that missing headers are only *probably* the cause?
15:16:34 <dcoutts_> kmc: I guess there are two parts, one is to split the test into two bits, pre-processing and then compiling; the error messages cabal should produce will be different in the different phases. Secondly yes we should capture the stderr of the C compiler and keep the file if it fails and mention it in the error message.
15:16:55 <MadHatterDude> damn, lookbehinds are impossible in my little implementation, but with some cunning, lookaheads can be used instead
15:18:16 <MadHatterDude> Maybe I should go to bed now...
15:18:44 <MadHatterDude> goToBedNow :: Maybe Bool
15:19:01 <shepheb> @roll 1d2
15:19:01 <lambdabot> Consider it noted.
15:19:05 <shepheb> uh
15:19:15 <shepheb> @dice 1d2
15:19:15 <lambdabot> 1d2 => 2
15:19:30 <MadHatterDude> @dice 1d1
15:19:30 <lambdabot> 1d1 => 1
15:22:09 <Mathnerd314> @help dice
15:22:10 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
15:22:21 <Mathnerd314> that should be Haskellizable...
15:23:03 <pastorn> is there any reason why i can't declare datatypes in GHCi?
15:24:04 <kmc> pastorn, because nobody has implemented the feature
15:24:29 <pastorn> that's the only reason?
15:24:48 <Jafet> Logically, ghci is supposed to be in a do-block
15:24:59 <kmc> it's not theoretically impossible, if that's what you're asking
15:25:19 <pastorn> kmc: that's assuring :)
15:25:26 <alpounet> there's a GHCi monad
15:25:43 <Jafet> Haha
15:26:01 <Jafet> You could replace the monad with carefully applied trace
15:31:45 <MadHatterDude> I am thinking of making the lovechild of Haskell and APL
15:33:34 <BMeph> MadHatterDude: So, Nial++? ;þ
15:34:00 <ski> @dice 1000d0
15:34:00 <lambdabot> 1000d0 => -26965397022934738615939577861835371004269...
15:34:17 <ski> mrf ?
15:34:19 <ski> @dice 100d0
15:34:19 <lambdabot> 100d0 => 46
15:34:22 <ski> @dice 100d0
15:34:22 <lambdabot> 100d0 => 51
15:34:24 <ski> @dice 100d1
15:34:24 <lambdabot> 100d1 => 100
15:34:28 <Jafet> You could call it ALPSkell
15:34:38 <Jafet> Since it lets you ski
15:34:52 <MadHatterDude> BMeph: More like Haskell with prefix and postfix operators and without lazyness
15:34:58 <MadHatterDude> Jafet: Lol
15:35:12 <ddarius> MadHatterDude: Have you looked at the Repa paper?
15:35:33 <MadHatterDude> ddarius: Quite sure I haven't
15:36:02 <BMeph> I prefer laziness. I also appreciate in in the PLs I use... ;þ
15:36:30 <Sgeo_> Is there a way to run Haskell stuff on Android?
15:36:36 <MadHatterDude> BMeph: Maybe I should make it lazy then...
15:36:54 <MadHatterDude> BMeph: I have been thinking something like implicit IO monad...
15:37:19 <Jafet> If you can't decide whether to use ASCII or the APL character set, hand it to Manatee and he'll make for you Chinese primitives
15:37:33 * BMeph shrugs
15:37:52 <ddarius> Cale: I'm pretty sure I've asked you this before but: Do you have any decent recommendations for online combinatorics resources (as in books/articles/etc.) as well as not necessarily online books?  Mostly introduction for someone with a decent amount of mathematical knowledge.
15:40:00 <pastorn> can i catch stuff from using 'error' with 'catch'?
15:40:12 <kmc> yes
15:40:16 <pastorn> nice
15:40:39 <Sgeo_> Can I catch _|_ with 'catch'? ;)
15:40:48 <ddarius> Sgeo_: Yes.
15:40:59 * Sgeo_ blinks
15:41:41 <Jafet> It's a bait-and-switch
15:43:08 <Sgeo_> ddarius, either you're claiming that Haskell has a general solution to the halting problem [not sure if I phrased that properly], or I'm missing something
15:43:33 <pikhq> :t catch
15:43:34 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:44:15 <pastorn> @type error
15:44:15 <pikhq> Sgeo_: Yup, looks like catch possesses arguments, and can thus be passed _|_.
15:44:16 <lambdabot> forall a. [Char] -> a
15:44:24 <kmc> you can't catch every _|_
15:44:43 <Vanadium> Did we not have a library for catching some _|_ at some point?
15:44:44 <kmc> "catch (evaluate (let x = x in x)) ..." will not catch
15:44:49 <kmc> @hackage spoon
15:44:49 <lambdabot> http://hackage.haskell.org/package/spoon
15:45:07 <pikhq> What's more, the IOError value being passed to that function can in fact be _|_. You may not be able to do anything with it, but it'll remain _|_.
15:45:14 <kmc> spoon is just an unsafePerformIO hack to get "pure" catching
15:45:44 <pikhq> Mmm, delicious, delicious laziness.
15:46:19 <Sgeo_> When GHC compiles to C, does it assume taht the compiler will be GCC?
15:46:20 <Mathnerd314> > let x = x in x
15:46:24 <lambdabot>   mueval-core: Time limit exceeded
15:46:29 <kmc> Sgeo_, by default, yes
15:46:43 <dcoutts_> Sgeo_: it uses gcc-specific features
15:46:54 <kmc> and it postprocesses the assembly output in a ghc-specific way
15:47:01 <kmc> err gcc-specific
15:47:11 <kmc> you can make an "unregistered" GHC build that's supposed to generate more portable C code
15:47:19 <Jafet> "Why do you ask?"
15:47:20 <Sgeo_> Someone mentioned to me being able to run C++ stuff on Android, which makes me think that maybe C, which means maybe Haskell programs
15:47:23 <wolgo> haha
15:47:23 <dcoutts_> yep, so for example it does not work with the sun gcc that uses the Sun C backend
15:47:32 <wolgo> what I have been trying to implement in ruby
15:47:42 <wolgo> heap and inserting into a sorted heap
15:47:43 <dcoutts_> Sgeo_: you'd want to compile directly to arm assembly rather than go via C
15:47:51 <wolgo> I implemented in one line of haskell in about 5 minutes
15:48:00 <kmc> Sgeo_, it seems that the future of GHC backends is LLVM
15:48:03 <wolgo> (ruby version is not working after 5 hours of work)
15:48:07 <wolgo> and I do not know haskell
15:48:10 <kmc> haha wolgo
15:48:13 <wolgo> what a joke
15:48:13 <dcoutts_> kmc: well, maybe
15:48:27 <Sgeo_> LLVM?
15:48:28 <wolgo> I seriously have ZERO haskell skills
15:48:28 <kmc> at least for portability
15:48:32 <kmc> @google LLVM
15:48:33 <lambdabot> http://llvm.org/
15:48:33 <lambdabot> Title: The LLVM Compiler Infrastructure Project
15:48:47 <wolgo> and it took me 5 minutes to work it out using lists and recursion...
15:48:56 <pikhq> That's the future backend for most compilation...
15:48:59 <kmc> wolgo, yup.  say what you want vs. say how to get what you want
15:49:00 <Sgeo_> So, would I use FFI C stuff to get to the Android SDK?
15:49:04 <kmc> Sgeo_, probably
15:49:04 <wolgo> I wish I was smart enough to understand types
15:49:09 <Mathnerd314> let f x = if (x `mod` 2 == 0) then (x / 2) else (3 * x + 1) in f 1
15:49:17 <Sgeo_> Why haven't I seen this type of stuff done before?
15:49:18 <kmc> but isn't the official Android SDK specific to Java, using their nonstandard Java bytecode?
15:49:24 <pikhq> wolgo: Not much to it, really.
15:49:24 <kmc> i don't know how native code stuff works on android
15:49:25 <Mathnerd314> > let f x = if (x `mod` 2 == 0) then (x / 2) else (3 * x + 1) in f 1
15:49:26 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:49:26 <lambdabot>    `GHC.Real.Integral t'
15:49:26 <lambdabot>   ...
15:49:43 <kmc> wolgo, i think any competent programmer can understand Haskell's type system
15:49:43 <Sgeo_> kmc, oh, I don't know
15:49:50 <kmc> not necessarily in a day
15:49:54 <wolgo> I am a noob lol.
15:49:59 <Sgeo_> A friend was showing me stuff on his Android phone, and mentioned C++
15:50:05 <wolgo> experience with a lot of languages
15:50:08 <wolgo> never able to pick one
15:50:19 <Philonous> To whom would I usually send patches for a cabal package? The maintainer?
15:50:24 <wolgo> but being able to express this in one line shows me how much garbage is out there.
15:50:28 <wolgo> this is how things should be.
15:50:33 <dcoutts_> Philonous: yes
15:50:39 <wolgo> what a crock of shit.
15:50:53 <wolgo> I wish i would have never learned any other language
15:50:55 <dcoutts_> Philonous: or wherever the maintainer has configured darcs send to send to
15:50:57 <kmc> wolgo, yes.  learning Haskell will make you bitter about all the mainstream industrially relevant languages
15:51:21 <pikhq> Sgeo_: It seems you can write *libraries* in a compiled language that gets loaded into the JVM.
15:51:28 <kmc> that big thick book of C++ "design patterns"?  what they're mostly doing is reinventing a couple wheels like "first-class function" and "polymorphism" over and over
15:51:32 <Jafet> kmc, that's like the story of the russian man who bought the amount of land he could walk around in a day
15:51:39 <kmc> Jafet, i don't know that one
15:51:39 <wolgo> kmc: I cannot stress it enough, I have NO training, no college, no high school and I am able to say "create a heap and insert to a sorted heap while keeping it sorted."
15:51:53 <wolgo> without understanding the type system or a large portion of the syntax.
15:51:56 <wolgo> that says a lot to me.
15:52:03 <Mathnerd314> > let f x = if x == 1 then 1 else if (x `mod` 2 == 0) then f (shiftR x 1) else f (3 * x + 1) in f 28
15:52:04 <tensorpudding> Haskell's kinda got a Lisp syndrome going on
15:52:05 <wolgo> people are doing it WRONG
15:52:05 <lambdabot>   1
15:52:09 <Jafet> kmc, he found out it was endless, tried to run as hard as he could around as much of it as possible, and died
15:52:21 <kmc> wolgo, you're a counterexample to all the people on reddit who think you need advanced category theory and an intuitive understanding of monads to do anything in Haskell
15:52:29 <kmc> you should go tell them how wrong they are
15:52:31 <pikhq> wolgo: Yes, they make data structures a massive pain.
15:52:39 <Jafet> kmc, or, "with how many ghc extensions?"
15:52:41 <wolgo> 500 lines to make a goddamn tree?
15:52:45 <tensorpudding> Though we hopefully don't have the same failing that caused Lisp to fail.
15:52:49 <wolgo> are you joking?
15:52:51 <tensorpudding> failings*
15:52:52 <kmc> tensorpudding, which syndrome, and which failing?
15:53:04 <wolgo> I feel irritated and gyped.
15:53:17 <wolgo> all this hype about python and ruby is bs
15:53:25 <tensorpudding> The syndrome of "our language is the best there is, but 'worse is better' and industrial practices are keeping us down"
15:53:28 <ski> @type div  -- Mathnerd314
15:53:29 <lambdabot> forall a. (Integral a) => a -> a -> a
15:53:39 <kmc> tensorpudding, but... it's true
15:53:46 <Mathnerd314> > let f x = if x == 1 then 1 else if (x `mod` 2 == 0) then f (x `div` 2) else f (3 * x + 1) in f 28
15:53:47 <lambdabot>   1
15:53:53 <tensorpudding> Yes, it's good to thinkyour language is the best.
15:54:03 <wolgo> anyhow
15:54:07 <kmc> when Haskell programmers talk about Haskell we always sound like True Believers
15:54:09 <wolgo> I just thought it was hilarious
15:54:11 <tensorpudding> But to be oblivious to its flaws, or why it doesn't get marketshare, is going to make you bitter and angry
15:54:16 <kmc> when C++ programmers talk about C++ they always prefix it witha bunch of apologies
15:54:21 <Jafet> I heard that syndrome five minutes ago in the next door channel
15:54:29 <pikhq> "Industrial patterns" are freaking still using C.
15:54:38 <kmc> to me LISP isn't a language, it's a toolkit for building your own language
15:54:41 <Jafet> Graham calls it Blub syndrome, I use the term for the irony value
15:54:48 <kmc> and so hard to get any traction, when there is total freedom in every direction
15:55:05 <tensorpudding> Oh, I'd heard of blub before.
15:55:09 <kmc> Haskell has a bit more structure to it, I hope that'd help industrially
15:55:12 <tensorpudding> Mostly disparagingly
15:55:20 <wolgo> the main reason that I have not used haskell is because the docs that I find are mucked up with a bunch of horseshit about stuff I do not know. Abelian groups, isomorphism blah blee
15:55:30 <wolgo> I want to know.
15:55:30 * Sgeo_ dislikes that in order to do practical things [say, getting the contents of a webpage] in Scheme, say, depends on the interpreter
15:55:32 <wolgo> lol
15:55:35 <Sgeo_> It's all interpreter specific
15:55:36 <wolgo> but I do not
15:55:44 <blackdog> well, erlang got some prominence in the web dev world through things like couchdb, right?
15:55:52 <blackdog> we should be able to do that, but safer and faster:)
15:55:55 <kmc> wolgo, there's plenty of more practical documentation out there
15:55:58 <tensorpudding> If Haskell actually, truly required you to learn category theory, it would deserve marginalization
15:56:06 <kmc> yes
15:56:12 <liyang> http://www.paulgraham.com/avg.html ← the Blub essay
15:56:13 <kmc> at least for now
15:56:13 <Apocalisp> What do you call a functor that maps every object A to an arrow (A ~> A)?
15:56:17 <tensorpudding> Well
15:56:35 <edwardk> wolgo: an isomorphism is a form of equivalence, it is a way of saying you can go from a -> b, and back again and vice versa without changing the thing in question
15:56:35 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:56:37 <kmc> Apocalisp, what's a pirate's favorite Arrow typeclass method
15:56:37 <tensorpudding> It's really demanding to expect programmers to use a system that requires that level of mathematical rigour.
15:56:46 <wolgo> but the use of recursion allowed me to nail something in 5 minutes, in haskell, a language that I want to know, that took me more than 5 hours to build a NON WORKING VERSION
15:56:49 <Sgeo_> Apocalisp, if this is a pun, it better be better than my pun (it probably is)
15:56:50 <tensorpudding> Especially when other languages provide great benefits and are far, far easier.
15:57:06 <Cale> Apocalisp: What are the arrows (A ~> A) -> (B ~> B)?
15:57:07 <Sgeo_> wolgo, may I see your Ruby?
15:57:14 <wolgo> Sgeo_: I deleted it
15:57:18 <tensorpudding> You could say that Haskell is immune though, since it was designed for research and until recently avoided popularity.
15:57:23 <wolgo> but it was a bunch of trash anyhow
15:57:33 <kmc> tensorpudding, sure, category theory is too much to expect of the average programmer
15:57:41 <kmc> good static typing and first-class functions aren't
15:57:48 <blackdog> first, let's shoot all the average programmers
15:57:49 <tensorpudding> Lisp was designed for research too, though.
15:57:50 <Cale> Apocalisp: Well, in any case there's no special name for it I think.
15:57:58 <kmc> also they are actually useful for writing good code
15:57:58 <wolgo> Sgeo_: you can find plenty of my ruby out there by looking at any terrible programmers ruby
15:58:02 <wolgo> actually I have a .swp file
15:58:03 <Apocalisp> @instances Monoid
15:58:04 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:58:04 <wolgo> one sec
15:58:04 <tensorpudding> (back in the days when computers were only being used for research or business)
15:58:07 <wolgo> I will show you
15:58:08 <Apocalisp> Endo!
15:58:20 <Jafet> blackdog, do you evaluate "average" before or at each step?
15:58:28 <kmc> i don't think many people use deep insights from category theory to write better practical Haskell code
15:58:29 <Cale> Apocalisp: Endo isn't a functor
15:58:31 <kmc> even if they have the insights
15:58:45 <Sgeo_> @quote Goldilocks
15:58:45 <lambdabot> No quotes match. Do you think like you type?
15:58:48 <Sgeo_> @quote Sgeo
15:58:48 <lambdabot> No quotes match. I've seen penguins that can type better than that.
15:58:51 <Sgeo_> Boo!
15:58:55 <blackdog> Jafet: :) not entirely serious. but your response to "this is hard, i don't understand" should not be a consistent "that's stupid and unnecessary"
15:58:57 <kmc> it seems category theory is not really about results anyway
15:58:59 <tensorpudding> kmc: If you restricted a programmer to Haskell 98, I think they would be able to learn it fine.
15:59:00 <Cale> Apocalisp: At least, not an endofunctor on the category of Haskell types (despite its name ;)
15:59:03 <pikhq> We just use category theory for ideas for some convenient functions is all.
15:59:07 <Apocalisp> hah
15:59:08 <kmc> but is about a common language for talking about different domains
15:59:11 <tensorpudding> But the multitude of extensions are really confusing.
15:59:28 <Cale> Extensions can be learned as needed
15:59:35 <kmc> yes
15:59:36 <tensorpudding> It helps that not every piece of software uses all of them, so you can learn them in stages.
15:59:39 <edwardk> @seen ezyang
15:59:39 <lambdabot> Unknown command, try @list
15:59:42 <kmc> and some of them are just lifting arbitrary restrictions from H98
15:59:45 <edwardk> preflex: xseen ezyang
15:59:46 <preflex>  ezyang was last seen on freenode/#haskell 22 hours, 9 minutes and 26 seconds ago, saying: I have a csv file and I want to graph it. What hackages do I want?
15:59:48 <kmc> so in a sense the language is simpler with the extension
15:59:56 <tensorpudding> But hearing about the monomorphism restriction would probably confuse most people
15:59:59 <Sgeo_> kmc, no monomorphism?
16:00:03 <Cale> and most of them are not really that complicated to understand -- maybe complicated to *implement* -- but usually not so hard to grasp their use
16:00:05 <wolgo> Sgeo_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24765#a24765
16:00:07 <ski> (kmc : edwardk tries :)
16:00:07 <wolgo> there you go
16:00:11 <wolgo> that is most of it
16:00:14 <kmc> for example
16:00:15 * Saizan thinks it was simpler with -fglasgow-exts
16:00:17 <kmc> haha
16:00:19 <wolgo> the .swp file did not have everything
16:00:21 <wolgo> anyhow
16:00:23 <kmc> -XKitchenSink
16:00:27 <Cale> tensorpudding: We should just do away with the monomorphism restriction entirel
16:00:28 <Cale> y
16:00:29 <tensorpudding> Functional data structures are also unfamiliar in general.
16:00:32 <Saizan> now some people are scared even of FlexibleInstances
16:00:42 <Sgeo_> I still don't quite get the monomorphism restriction?
16:00:52 <wolgo> the haskell version: nsertToSort val (x:xs) = if val > x then val:x:xs else x:insertToSort val xs
16:00:53 <tensorpudding> Though ezyang's post on zippers was pretty comprehensive
16:00:54 <EvanR> wolgo: you had trouble writing recursive algorithms in haskell?
16:00:56 <Cale> Okay, the monomorphism restriction is just this:
16:00:58 <tensorpudding> err, comprehensible
16:01:01 <wolgo> EvanR: no
16:01:05 <wolgo> the complete opposite
16:01:16 <Cale> If you have something which is a pattern binding (that is, an equation with no function parameters)
16:01:20 <Saizan> Sgeo_: read the explanation in the haskell 98 report, it's the clearest i've found
16:01:22 <EvanR> you had trouble not writing a recursive algorithm
16:01:28 <wolgo> haskell makes recursion the natural way to think
16:01:32 <wolgo> EvanR: yes
16:01:34 <Cale> then it cannot be typeclass polymorphic without an explicit type signature
16:01:36 <wolgo> I cannot do it in ruby
16:01:38 <wolgo> I do not know how.
16:01:43 <ski> (tensorpudding : though the DMR has nothing to do with the categorical concept of monomorphism ..)
16:01:44 <tensorpudding> MR unfortunately might be shooting too high
16:01:44 <EvanR> i thought ruby supported that
16:01:48 <wolgo> because I am a 29 year old hobbyist idiot
16:01:49 <wolgo> lol
16:02:00 <pikhq> EvanR: He implemented a somewhat-complex data structure in Haskell in 5 minutes, and failed to do the same in Ruby after 5 hours.
16:02:04 <tensorpudding> It's hard enough to find people who know how to program in the "stupid" languages!
16:02:12 <Jafet> Hell, you can do recursion in tex
16:02:24 <wolgo> EvanR: ruby does support it
16:02:35 <wolgo> what is hilarious is that I know almost zero haskell
16:02:36 <EvanR> oh , recursive structures?
16:02:41 <Apocalisp> Cale: I was considering that I can implement (List a) as a natural transformation (Fold a ~> Endo), where Fold a b = (a -> b -> b) and Endo b = b -> b
16:02:42 <Cale> Right, that confused me at first -- the first time I heard of it, I read the 'monomorphism' in "monomorphism restriction" as "monic morphism", rather than "opposite of polymorphism"
16:02:45 <wolgo> like, never written more than a 10 line program
16:02:46 <tensorpudding> Recursion would fry their brains, and they'd weep for days in a dark room staring at foldr until beads of bloody sweat formed on their brows
16:02:55 <ski> tensorpudding : would you have a link to that ezyang post ?
16:02:56 <wolgo> and I had the implementation finished in five minutes
16:03:01 <EvanR> wolgo: so basically youre saying haskell is awesome
16:03:03 <Vanadium> tensorpudding: Yeah, that is pretty much me
16:03:13 <tensorpudding> http://blog.ezyang.com/2010/04/you-could-have-invented-zippers/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+ezyang+%28Inside+245s%29&utm_content=Google+Reader
16:03:21 <Apocalisp> But since it's not a functor, then s/natural transformation/function
16:03:25 <tensorpudding> err, that was a googlereaderified
16:03:38 <kmc> the problem isn't really what features languages actually support, the problem is that enough programmers out there will look at you like you're from space if you use recursion or a first-class function
16:03:45 <Jafet> Only if you need pants.
16:03:53 <wolgo> EvanR: no, I do not know enough haskell to say that. I can say that in this instance I want to throw away everything I have ever learned and switch to only haskell or something like it.
16:04:05 <tensorpudding> (and yet Ruby has reduce, Ruby is an "easy" language right?)
16:04:07 <EvanR> sounds good to me
16:04:12 <wolgo> but that is just because I am pissed off
16:04:20 <wolgo> anyhow
16:04:25 <Cale> wolgo: Go for it ;)
16:04:28 <wolgo> I like ruby
16:04:32 <Jafet> wolgo, http://norvig.com/21-days.html
16:04:33 <wolgo> it is just, why.
16:04:33 <EvanR> ruby emphasizes OOP plus 'cool' syntactic constructs
16:04:44 <wolgo> why does it makes shit like a heap so hard?
16:04:53 <tensorpudding> I like ruby a lot.
16:05:02 <wolgo> I now can sort a heap, insert into it sorted and all that...
16:05:10 <wolgo> and I do not know how to implement that in ruby
16:05:17 <EvanR> you use a library
16:05:21 <wolgo> but, to be fair, I know little about DS&A
16:05:28 <Jafet> Ignore Norvig's python and lisp blub though, and he's not a brilliant programmer
16:05:30 <Cale> wolgo: This "why is everyone wasting their time with such crappy programming languages" thing is a not uncommon feeling when people start using Haskell, and I have to admit I felt/feel the same way.
16:05:38 <wolgo> so I cannot fault ruby, that is my fault
16:05:40 <kmc> "learn programming in three days" is a pretty different thing from "learn FooLang in three days"
16:05:41 <ski> Apocalisp : possibly it still is a dinatural transformation ..
16:05:44 <Cale> Of course, there's an obvious answer to it.
16:05:45 <Sgeo_> Ruby gives you 1001 different ways to do almost the exact same thing
16:05:48 <kmc> the latter is totally feasible, for some languages.  presuming you can already program
16:05:58 <Mathnerd314> Sgeo_: so does Haskell
16:06:04 <wolgo> I wrote a game in ruby, a towlr in 4 hours.
16:06:09 <wolgo> wit graphics and shit
16:06:10 <Cale> Popular programming languages are not popular because they are good, but because they are popular.
16:06:13 <wolgo> with*
16:06:14 <wolgo> but!
16:06:16 <Vanadium> Cale: I have a feeling of "I wish I could stop wasting my time with such crappy programming languages and actually solve problems in haskell"
16:06:22 <Mathnerd314> Sgeo_: http://www.willamette.edu/~fruehr/haskell/evolution.html or whatever
16:06:24 <Cale> And so employers can easily find people to program in them.
16:06:25 <wolgo> this has forced me to learn the haskell type system
16:06:31 <wolgo> which stops me in my tracks every time.
16:06:39 <wolgo> Maybe/Just
16:06:45 <wolgo> that is when I get thrown
16:06:46 <wolgo> lol
16:06:50 <Jafet> One could ask a related question actually, whether natural language can be ranked by usefulness.
16:06:55 <EvanR> Just x / Nothing
16:07:03 <Jafet> English would be perl
16:07:11 <Jafet> The ultimate glue
16:07:20 <wolgo> so...
16:07:21 <tensorpudding> I wish I could have thought of first-class functions, parametric polymorphism and ADT's
16:07:22 <Cale> wolgo: Okay, if t is any type at all, then a value of type Maybe t is either the value Nothing, or it is a value of the form Just x, where x is a value of type t
16:07:38 <wolgo> Cale:
16:07:39 <Cale> wolgo: It's a bit like lists of length at most 1, if that helps
16:07:40 <Jafet> Or bottom!
16:07:53 <wolgo> so Maybe Num is either Just a Num or nothing
16:08:08 <Cale> Yeah, though Num isn't a type, but a typeclass
16:08:12 <Vanadium> wolgo: In Ruby, stuff is either nil, or an object. In Haskell, stuff is always an object. So we use Maybe to make a type that can be something that is like nil
16:08:13 <Cale> Maybe Integer, perhaps
16:08:32 <EvanR> i dont know about object, data is immutable in haskell
16:08:56 <wolgo> Oh I think I see
16:09:15 <Jafet> :t Just 0
16:09:16 <lambdabot> forall t. (Num t) => Maybe t
16:09:17 <wolgo> so Maybe Type, if not Type then Nothing else Just Type?
16:09:30 <ski> this means that to use an `Maybe Integer' as an `Integer', you have to explicitly handle the `Nothing' case, as say what you want to happen in that case
16:09:35 <EvanR> data Maybe a = Nothing | Just a
16:09:35 <Vanadium> No, the point is that a type on its own is never "empty"
16:09:36 <Cale> yeah
16:09:50 <Cale> Er...
16:10:05 <Vanadium> We use Maybe T to be able to say "that name refers to Nothing, and not an actual value of the type T"
16:10:05 <Cale> People are saying things now that abuse terminology and confuse me ;)
16:10:07 <Jafet> One curious thing is that lots of languages don't have the concept of a sum or union type
16:10:14 <Jafet> Like ruby, I don't think
16:10:19 <Cale> Okay, let's just see an example or two
16:10:20 <Mathnerd314> does Haskell?
16:10:43 <ski> Mathnerd314 : via ADTs, yes
16:10:45 <Cale> So, we have the function lookup
16:10:47 <Cale> :t lookup
16:10:48 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:10:51 <Vanadium> Jafet: Is the OOP way to express sum types not just to make an inheritance hierarchy?
16:10:57 <Mathnerd314> ski: or typeclasses, I guess
16:11:21 <Cale> It takes a value of type a, and a list of pairs of values of type a and b, and produces a value of type Maybe b
16:11:24 <ski> well, you'd need closed classes for that to be exact
16:11:28 <wolgo> now we have an outtage
16:11:29 <wolgo> wtf
16:11:36 <kmc> Haskell doesn't have untagge dunions
16:11:46 <wolgo> mutable variables, nested for loops, nested ifs all piss me off
16:11:48 <kmc> except possibly through existentials
16:11:51 <wolgo> sick of this shit
16:12:02 <wolgo> brb
16:12:05 <wolgo> I want to understand
16:12:07 <EvanR> wolgo: welcome to the road to the stars ;)
16:12:08 <Cale> okay
16:12:42 <Jafet> Vanadium, I've stopped trying to visualize inheritance hierarchies that don't model is-a or Liskov relationships
16:12:54 <Jafet> So I can't bother to answer the question
16:12:55 <edwardk> ski: http://research.microsoft.com/en-us/um/people/simonpj/papers/not-not-ml/ the devil's offer is used in there
16:13:09 <edwardk> on p. 44
16:13:20 <EvanR> inheritance does let you easily do pattern matching
16:13:22 <EvanR> doesnt*
16:13:36 <Vanadium> It does with proper language support :V
16:13:38 <jmcarthur> not in client code
16:13:46 <EvanR> unless you do 'typeof' and a switch
16:13:46 <jmcarthur> well sure, with reflection perhaps
16:13:49 <kmc> scala has inheritance and pattern matching
16:13:57 <kmc> but i guess they have a way to make the hierarchies closed?
16:13:59 <edwardk> ski: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.7260&rep=rep1&type=pdf is probably a better reference though
16:14:12 <edwardk> ski: because it explains the story, and was the link i was looking for
16:14:12 <Vanadium> ruby at least lets you do "case value; when SomeType then...; when OtherType then..."
16:14:53 <kmc> typecase is pretty wretched
16:15:02 <Jafet> Vanadium, and all these types are made siblings of a hierarchy?
16:15:14 <kmc> a lot of the supposed flexibility of dynamic types comes from using the type system itself as a single, ad-hoc discriminated union
16:15:22 <Vanadium> All types are eventually subtypes of Object, so welp
16:15:24 <Jafet> That's... blatantly wrong.
16:15:29 <kmc> which is much uglier than defining your own tagged union types
16:15:52 <Jafet> There's been lots of work done by Liskov, Kay and others on object models, and people throw this work away
16:16:06 <Jafet> It almost makes me sad
16:16:15 <kmc> Jafet, most PL research is ignored by people designing "practical" languages
16:16:17 <kmc> just look at Go
16:16:50 <systemfault> Al-Go-ol 2010
16:16:59 <kmc> yes
16:17:05 <blackdog> kmc: on that note, Rob Pike spoke in Sydney on Go recently
16:17:19 <kmc> some language designs are based on computer science, and some are based on wanting to write device drivers for the PDP-11
16:17:26 <kmc> blackdog, cool
16:17:31 <blackdog> I asked him if interfaces in Go were related to typeclasses in Haskell, and he said he'd never looked at Haskell...
16:18:13 <EvanR> inspiring
16:18:28 <dcoutts_> blackdog: Go interfaces are more ad-hoc
16:18:35 <Jafet> Still successful at avoiding success
16:18:37 <kmc> Go also has no parametric polymorphism
16:18:38 <dcoutts_> more like duck typing as I understand it
16:18:52 <kmc> yes, you don't declare that a type conforms to an instance
16:19:06 <dcoutts_> right, it just does, if it defines the right names
16:19:24 <Mathnerd314> I'm looking for a boilerplate-free solution to the expression problem... advice?
16:19:27 <pikhq> dcoutts_: Duck typing except slightly better-defined.
16:19:32 <kmc> which is great, if your BitRegister and InternalCombustionEngine both have void shift(int n)
16:19:34 <ddarius> Mathnerd314: Ask google.
16:19:38 <kmc> now they're the same interface!
16:19:47 <blackdog> dcoutts_: i think it does some static checking
16:20:00 <EvanR> lol
16:20:09 <Saizan> blackdog: i hope.
16:20:15 <blackdog> it's not safe, though.
16:20:28 <dcoutts_> blackdog: right, it's static, as I understood it, it's the static equivalent of python style duck typing
16:20:32 <pikhq> kmc: Or your MissileCommandGame and your NuclearMissileSilo having void launchTheMissiles(void).
16:20:36 <kmc> hehe
16:20:49 <EvanR> then it would make sense
16:21:15 <pikhq> EvanR: Tell that to the remnants of humanity. All 0 of them.
16:21:15 <pikhq> :P
16:21:24 <Mathnerd314> ddarius: I haven't found any with google
16:21:25 <blackdog> "the static equivalent of duck typing" is a deceptively long way away from dynamic duck typing:)
16:21:28 <Saizan> dcoutts_: yeah, that's the part i liked
16:21:54 <wolgo> okay, I will give myself three hours to implement hangman in haskell.
16:21:56 <Jafet> Sounds similar to ML
16:21:57 <Vanadium> The static equivalent of duck typing is C++ templates, eh?
16:21:59 <ski> edwardk : ty
16:22:05 <wolgo> if I can do it. I will only program in haskell for 120 days.
16:22:07 <Saizan> Vanadium: god no
16:22:12 <ddarius> wolgo: After which point you will self-destruct.
16:22:22 <wolgo> ddarius: yes
16:22:25 <wolgo> I will rage
16:22:27 <ski> (is it related to `Not (Not (Either (Not a) a))' ?)
16:22:29 <blackdog> C++ templates made me confused about language design for years
16:22:34 <Vanadium> blackdog: Why? :(
16:22:44 <Vanadium> Saizan: But why, they basically work the same way
16:22:47 <blackdog> somehow i had compile-time metaprogramming and simple parametric polymorphism conflated.
16:22:50 <Vanadium> Assuming type deduction, etc
16:22:51 <pikhq> "WHY????"
16:23:00 <EvanR> c++ confuses people on a daily basis, most people
16:23:03 <blackdog> because that's the first thing you use it for in C++
16:23:20 <Saizan> Vanadium: C++ templates have all the mess about generating code and delayed checks, and the horrible interaction with the type based overloading
16:23:28 <blackdog> "yep, preprocessing is the only way to have parametric polymorphism."
16:23:32 <Vanadium> huh
16:23:38 <Jafet> Vanadium, C++ template is a masterwork. I've never seen any theoretical formalism for it, or found anything like it in other languages
16:23:57 <kmc> templates would be better if they were actually just a preprocessor
16:24:02 <Jafet> (Remember to increase -ftemplate-depth!)
16:24:05 <pikhq> Jafet: There is a formalism for it. It's the untyped lambda calculus.
16:24:09 <kmc> unfortunately the name resolution rules change subtly once you're in a template
16:24:36 <Jafet> pikhq, a non-trivial formalism
16:25:12 <EvanR> D has a template system
16:25:21 <kmc> for example if B<T> inherits from A<T>, then names in B<T>'s code resolve to unrelated things in the global namespace *before* they resolve to stuff in the base class A<T>
16:25:21 <pikhq> blackdog: Amusingly, C does polymorphism better than C++ does, often-times. :P
16:25:22 <kmc> go figure.
16:25:40 <Vanadium> kmc: Assuming the same T?
16:25:42 <kmc> polymorphism in C is brutal, unsafe, and beautifully simple
16:25:43 <kmc> yeah
16:25:51 <Vanadium> Neat
16:25:58 <EvanR> kmc: unsafe?
16:26:10 <ski> void *
16:26:11 <elly> There is no type but void*
16:26:13 <blackdog> pikhq: (void*) != polymorphic
16:26:14 <kmc> yes, polymorphism in C usually means pointer casting, in particular to/fro void*
16:26:18 <pikhq> Granted, it's through awful hacks that involve either being brutally unsafe or implementing a type system. But still.
16:26:39 <Jafet> I vote to rename all unsafe- functions to "disciplined"
16:26:50 <wolgo> so if I have a function that needs to do an IO action it must have a do?
16:26:52 <pikhq> blackdog: You need to implement half of a type system to do it right, mind. But this is actually done in C.
16:27:00 <benmachine> wolgo: do is never ever necessary
16:27:07 * ski votes to rename them to use a prefix `promise'
16:27:08 <EvanR> enum types plus switch cast can help
16:27:09 <benmachine> wolgo: it just makes things prettier sometimes
16:27:09 <Jafet> "disciplinedPerformIO"
16:27:10 <kmc> wolgo, no, "do" is just sugar for the operator (>>=)
16:27:23 <pikhq> wolgo: No, do is just syntactic sugar for some underlaying functions that string together IO actions into a single IO action.
16:27:28 <kmc> wolgo, http://haskell.org/haskellwiki/Introduction_to_IO
16:27:40 <Jafet> pikhq, it can be used with any Monad.
16:27:41 <ski> `promisePureIO',`promiseHeadOfNonEmpty',&c.
16:27:41 <blackdog> pikhq: sure. i always wonder about the value of that... gnome does something like that for implementing the object system, doesn't it?
16:27:50 <EvanR> wolgo: heres one:  myAction x = putChar x
16:27:52 <EvanR> no do
16:28:01 <benmachine> main = interact id
16:28:04 <Jafet> blackdog, the arcane technique is fully realized in udev
16:28:06 <kmc> wolgo, function application never "does" IO... it only returns a description, a "recipe" of how IO could be done.  and "do" and (>>=) are two ways of building IO-recipes out of smaller ones
16:28:11 <pikhq> Jafet: Yes, but noob. Easier to say "It works with IO. Oh, BTW. Also lists. And Maybe. And a bunch of other things, we call them monads."
16:28:13 <Jafet> Being gcc only and all
16:28:28 <pikhq> blackdog: Gnome actually has a full object system that happens to have a C API.
16:28:57 <wolgo> EvanR: myAction will only be able to be used in a function that takes a value and leaves an IO() right?
16:29:03 <EvanR> wolgo: no
16:29:03 <Vanadium> It looks a bit like C# :<
16:29:09 <Cale> http://cale.x.im/share/passive.png
16:29:16 <kmc> Gnome also has a full-fledged C#-like language that compiles to C using that object system
16:29:21 <EvanR> wolgo: you can for example return the io action as part of another structure to be used laster
16:29:22 <theorbtwo> Or, you know, C# looks a bit like it.
16:29:24 <EvanR> lataer
16:29:30 <Vanadium> Cale: quit summoning demons
16:29:34 <wolgo> laetar!
16:29:38 <EvanR> LATER
16:29:41 <pikhq> wolgo: No, you can actually futz with IO *values* anywhere. It just won't do anything unless somewhere, somehow, it's part of an action performed by main.
16:29:52 <systemfault> Ewwww Vala
16:29:54 <wolgo> okay
16:29:55 <wolgo> so
16:30:10 <wolgo> like c programs, haskell programs must have a main function
16:30:16 <kmc> wolgo, in Haskell it's not even a function
16:30:16 <Jafet> @remember benmachine main = interact id
16:30:17 <lambdabot> Good to know.
16:30:17 <wolgo> and main is where IO happens
16:30:23 <wolgo> ok
16:30:24 <EvanR> thats probably the only thing it has in common with c ;)
16:30:27 <benmachine> Jafet: why is that memorable? :P
16:30:33 <kmc> wolgo, the type of "main" is "IO ()".  it doesn't have a (->) it is type, so it's not a function
16:30:39 <kmc> it's just an IO-recipe
16:30:41 <wolgo> ahh I see
16:30:42 <Jafet> Most creative cat
16:30:44 <wolgo> that makes sense
16:30:49 <benmachine> oic, guess so
16:31:04 <wolgo> it is like a token that says "ZOMG IO IS INSIDE THIS BLOK!"
16:31:11 <ski> wolgo : re `Maybe' :
16:31:12 <ski> > case lookup 3 [(2,"foo"),(3,"bar"),(5,"baz")] of Nothing -> "not found"; Just s -> reverse s
16:31:13 <lambdabot>   "rab"
16:31:14 <EvanR> its like a burrito
16:31:15 <ski> > case lookup 4 [(2,"foo"),(3,"bar"),(5,"baz")] of Nothing -> "not found"; Just s -> reverse s
16:31:16 <lambdabot>   "not found"
16:31:26 <ski> @type lookup
16:31:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:31:57 <ski> wolgo : the `Maybe' in the result type means that if we want to access the result of type `b' (above `String'), we must handle the `Nothing' case, somehow
16:32:16 <EvanR> or not!
16:32:17 <EvanR> ;)
16:32:23 <ski> (if you really like the equivalent of `NullPointerException', you can use `fromJust :: Maybe a -> a', though)
16:32:42 <EvanR> you could not have a pattern for Nothing, or just fromJust
16:32:55 <EvanR> o, weird sentence
16:33:07 * EvanR shakes fist at Maybe
16:33:21 <ski> yes, but you must convert from `Maybe a' to `a', somehow, either by a pattern-match, or by calling a function that does it for you
16:33:27 <Jafet> EvanR, when you go to different Maybe stores you can get different burritos with Just a filling, but any store can make you a burrito with Nothing
16:33:29 <kmc> wolgo, you can get pretty far thinking of IO as a "tag" on function types warning that they're impure... but that model is wrong, and will mislead you later
16:33:31 <ski> you can't just forget about it
16:33:47 <FliPPeh__> grr, parsec recursion doesn't play by my rules :)
16:33:54 <wolgo> okay
16:34:00 <wolgo> well I am going to make hangman
16:34:05 <EvanR> not handling Nothing is not safe
16:34:05 <kmc> wolgo, the key thing is that in Haskell, evaluation and execution are two distinct processes
16:34:07 <wolgo> and a maze generator in haskell
16:34:16 <kevinulin> its better to think of IO as herpes
16:34:17 <kmc> evaluation is what happens e.g. when you apply a function to arguments and ask for the result
16:34:29 <Jafet> > map (liftM succ) [Just 1, Just 2, Nothing]
16:34:30 <lambdabot>   [Just 2,Just 3,Nothing]
16:34:41 <kmc> execution is what happens when you take an "IO recipe" and have the machine actually do what the recipe says
16:34:42 <wolgo> since ruby sucks ass for recursive data structures and has nothing but a bunch of if els if els if els for for for for
16:34:45 <ski> (and if you have just `String' instead of `Maybe String', then there is no equivalent of `null' (apart from maybe the empty string) .. well, there's the `_|_' value, but that "handles itself")
16:34:48 <EvanR> computations vs commands (tm)
16:35:02 <wolgo> ok
16:35:08 <wolgo> I will be back in one hour
16:35:12 <kmc> so a value like putStr of type (String -> IO ()) might look like a function with side effects
16:35:19 <wolgo> and by 9PM I will have a hangman.
16:35:23 <kmc> but it's actually a function whose evaluation returns a recipe, which you can then choose to execute or not
16:35:25 <Vanadium> Urgh, why does let (a :: Int, b) = ... require ScopedTypeVariables
16:35:30 <Jafet> kevinulin, radioactive waste!
16:35:44 <kmc> Vanadium, they used to have -XPatternSignatures but it was folded in for some reason
16:35:56 <wolgo> so putStrLn returns a present inside of an IO box that we open in an IO action block
16:36:13 <wolgo> > :t putStrLn
16:36:14 <lambdabot>   <no location info>: parse error on input `:'
16:36:17 <wolgo> zomg
16:36:17 <kmc> :t putStrLn
16:36:18 <lambdabot> String -> IO ()
16:36:20 <kmc> wolgo, sort of
16:36:35 <blackh1> wolgo: You're onto it.
16:36:37 <benmachine> a spacesuite of nuclear waste in the ocean next to a container of apples
16:36:43 <kmc> wolgo, take a look at that "Introduction to IO" page
16:36:50 <wolgo> ok
16:36:56 <wolgo> I will read it on the BART
16:36:59 <kmc> kewl
16:37:02 <wolgo> while raging
16:37:05 <EvanR> IO a is the type of a command that when executed results in type a
16:37:05 <mauke> .oO( how does a radioactive bear know what apples is? )
16:37:09 <ski> kmc : can you elaborate on how `IO a' "being" `() -> a', but with `IO'-side-effects, is wrong (and not just possibly misleading) =
16:37:15 <ski> s/=/?/
16:38:17 <benmachine> ski: it would probably give you weird ideas about when IO is executed
16:38:27 <benmachine> if you start using actions as first-class values
16:38:44 <Jafet> mauke, just liftM eat
16:38:52 <benmachine> like, const (return ()) (putStrLn "lol") doesn't print anything
16:39:09 <ski> (not if you say that that side-effecting function `() -> a' is not applied when you construct larger actions from it, but just when the larger action is executed .. i think)
16:39:47 <ski> (and of course, calling `seq' on such a function would not perform the side-effects, either)
16:41:16 <Saizan> (that seems to be quite fragile, tbh)
16:41:28 <benmachine> it does sound like confusion will result
16:41:38 <benmachine> it might not be irreconcilable with reality
16:41:39 <kevinulin> you confused me at hello
16:42:19 <Saizan> though DDC makes it work, right?
16:42:27 <Saizan> + effect typing
16:43:17 <Mathnerd314> @hoogle (IO a) -> (a, IO ())
16:43:17 <lambdabot> Data.Generics.Twins gmapAccumM :: (Data d, Monad m) => (a -> e -> (a, m e)) -> a -> d -> (a, m d)
16:43:17 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
16:43:17 <lambdabot> Data.Traversable mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
16:43:38 <mikste> make
16:43:49 <EvanR> No Makefile found.
16:43:59 <benmachine> Mathnerd314: what would that function applied to getLine look like?
16:44:01 <Vanadium> "Occurs check: cannot construct the infinite type: a = [a]" ought to be the most annoying error
16:44:15 <Mathnerd314> benmachine: ((),IO ())
16:44:29 <Cale> Vanadium: Would you prefer "type mismatch"?
16:44:32 <benmachine> Mathnerd314: er, getLine :: IO String so you're expecting (String, IO ())
16:44:37 <Mathnerd314> oh, yeah
16:44:40 <Mathnerd314> sorry
16:44:52 <benmachine> Mathnerd314: what would the string be?
16:44:54 <Mathnerd314> was thinking of print
16:44:56 <Vanadium> Cale: Actually, yes
16:45:15 <Jafet> Well is there some extension that can construct the infinite type a = [a]?
16:45:22 <ski> Saizan : well, the actual version would probably be more like `() -{IO}-> a', or something similar :)
16:45:26 <Cale> Jafet: No, but there could e
16:45:27 <EvanR> Mathnerd314: which string would it be?
16:45:27 <Cale> be*
16:45:32 <Mathnerd314> hmm... ok
16:45:43 <Cale> Jafet: It's just that essentially all occurrences of infinite types are bugs
16:45:46 <ski> ("DDC" standing for ?)
16:45:48 <Jafet> Then it seems strange to put a tautology in the error message
16:46:04 <Jafet> Rather than as you said, "type mismatch"
16:46:05 <Cale> eh?
16:46:07 <benmachine> :t f a = ("", () <$ a)
16:46:07 <lambdabot> parse error on input `='
16:46:12 <benmachine> :t let f a = ("", () <$ a) in f
16:46:13 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> ([Char], f ())
16:46:30 <benmachine> <_<
16:46:52 <ski> Jafet : .. in OCaml, there is the equivalent of that
16:47:00 <Mathnerd314> @hoogle (a, IO ()) -> (IO a)
16:47:00 <lambdabot> No results found
16:47:11 <Cale> What tautology?
16:47:27 <Jafet> Or rather, a vacuous truth
16:47:29 <Vanadium> I would like an IDE that looks at my definition and puts down a type signature with all deduced constraints and everything :effort:
16:47:39 <benmachine> Jafet: well no, it's telling you which particular type is the problem
16:47:49 <kevinulin> i have no formal education with networking, but is there any standardised naming for recieved data and data to be sent out?
16:48:00 <ski> otherwise, there's
16:48:01 <ski> @type In [In [],In [In []],In [In [],In [In []]]]
16:48:02 <lambdabot> Mu []
16:48:03 <Cale> I suppose it's true that GHC can't construct *any* infinite types, and so obviously it can't construct this one.
16:48:04 <benmachine> Jafet: it arises when you have something like, x:x - the type of : forces x to be a list of whatever type it is
16:48:11 <Jafet> I'm not saying it's useless, just strangely worded
16:48:26 <Cale> But it means that while typechecking, GHC has come across this equation which it can't solve because of this fact.
16:48:41 <benmachine> just like cannot match inferred type Char against expected type Int
16:48:43 <Vanadium> @pl \(a, b) -> a >>= \a' -> b >>= \b' -> return (a', b')
16:48:44 <lambdabot> uncurry (liftM2 (,))
16:48:47 <benmachine> you can never do that!
16:48:50 <Saizan> ski: (the Disciplined Disciple Compiler)
16:48:55 <ski> ah, ty
16:49:07 <ski> DDC has effect typing ?
16:49:14 <Cale> I don't like that DDC is strict.
16:49:32 <benmachine> Mathnerd314: if you want (a, IO ()) -> IO a have a look at (<$)
16:49:44 <benmachine> it's not exactly what you want but it's close
16:49:52 <benmachine> (can also be done with fmap)
16:49:59 <kmc> :t uncurry (<$)
16:50:00 <Saizan> kevinulin: depends: packet, message, ..
16:50:00 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a, f b) -> f a
16:50:26 <Gracenotes> as nice as google wave seems to be, why is it so slow sometimes?
16:50:29 <Mathnerd314> @src (<$)
16:50:30 <lambdabot> (<$) = (<$>) . const
16:50:37 <Saizan> ski: yes, afaiu
16:50:38 <Mathnerd314> @src (<$>)
16:50:38 <lambdabot> f <$> a = fmap f a
16:50:48 <ski> ok
16:50:57 * ski looks at
16:51:00 <ski> @wiki DDC
16:51:00 <lambdabot> http://www.haskell.org/haskellwiki/DDC
16:51:17 <Vanadium> Why does Data.ByteString.Lazy not have 'lines' :<
16:51:17 <benmachine> so x <$ a = fmap (const x) a
16:51:18 <Vanadium> @src lines
16:51:18 <lambdabot> Source not found. Maybe you made a typo?
16:51:33 <EvanR> @src words
16:51:33 <lambdabot> words s = case dropWhile isSpace s of
16:51:33 <lambdabot>     "" -> []
16:51:33 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:51:35 <mauke> did you look in .Char8?
16:51:40 <Gracenotes> DDC's type syntax ends up being kind of confusing.. :/
16:51:41 <Saizan> ?type Data.ByteString.Lazy.Char8.lines
16:51:42 <lambdabot> BSLC.ByteString -> [BSLC.ByteString]
16:51:43 <Vanadium> mauke: durr, no I did not
16:52:00 <Vanadium> Sorry :(
16:52:00 <Gracenotes> it breaks up arrows until they look like arrows no longer
16:52:30 <Saizan> broken arrows make me sad.
16:52:48 <Vanadium> Is there a way to make ghci compile something with -O2 before loading it?
16:52:59 <xerox> commuting arrows make Saizan happy
16:53:03 <ski> @type uncurry (((<*>) . ((,) <$>)))
16:53:04 <lambdabot> forall (f :: * -> *) a a1. (Applicative f) => (f a1, f a) -> f (a1, a)
16:53:11 <ski> @type uncurry (liftA2 (,))
16:53:12 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
16:53:46 <Gracenotes> Vanadium: you mean, compiling a file without loading it? o_O
16:54:02 <Vanadium> Gracenotes: I mean before bringing the symbols into the scope of the REPL
16:54:28 <monochrom> :!ghc -O2 -c Mine.hs
16:54:41 <Vanadium> Well, without me actively having to do that all the time
16:54:50 <Vanadium> Oh, well, I guess I better figure out how to make it faster mysefl
16:55:19 <benmachine> Vanadium: a .ghci file?
16:56:20 <Gracenotes> ghci ignores {-# OPTIONS O2 #-}?
16:56:28 <Gracenotes> *-
16:56:40 <Cale> ddarius: Oh! Sorry I missed your question back there. I unfortunately only know of texts which satisfy two of {good, at the beginner level, widely available}
16:57:35 <ddarius> Cale: What satisfies "good" and "widely available"?
16:57:37 <Vanadium> Oh, great, my program is fighting back by making the stack overflow >:[
16:58:14 <ddarius> and what satisfies "good" and "at the beginner level"?
16:59:41 <Cale> ddarius: good and widely available would be just about anything which discusses combinatorial species, as well as Jackson and Goulden's "Enumerative Combinatorics"
17:00:24 <Cale> ddarius: Good and at the beginner level is Prof Jackson's MATH 249 and C&O 330 course notes at Waterloo.
17:00:27 <Vanadium> Help, my program is too slow/overflowing: http://codepad.org/Uu04VOek
17:00:40 <EvanR> > init "abc"
17:00:40 <lambdabot>   "ab"
17:00:47 <EvanR> > init "abcd"
17:00:48 <lambdabot>   "abc"
17:01:04 <iago> hello, there is some *extended* doc of the GHC API?
17:01:06 <Cale> Apparently you can call up the printing services there and get them to ship a copy to you.
17:02:06 <Cale> At the beginner level and widely available is 'generatingfunctionology'. However, it is terrible.
17:02:57 <Saizan> Vanadium: i see a "lazy accumulator" there
17:03:30 <Cale> maybe try   case randomR (0, fromIntegral n) g of (p,g') -> ...
17:03:39 <Saizan> Vanadium: two actually.
17:03:56 <fax> I thought generatingfunctionology is fun but I am too much of a beginner to know any better :0
17:04:13 <Vanadium> Saizan: n and acc?
17:04:18 <Saizan> Vanadium: right
17:04:19 <Cale> fax: The problem with it is that it mostly misses the point of discussing generating series (at least in my mind)
17:04:31 <Vanadium> Surely n gets forced by the call to randomR and acc is not so much being accumulated on as occasionally replaced
17:04:39 <Cale> fax: and it does some things in a far more convoluted and less elucidating way than necessary
17:05:08 <Saizan> Vanadium: but you never force the call to randomR
17:05:22 <ski> what about <http://bergeron.math.uqam.ca/Species/especes.html> (haven't read yet) ?
17:05:23 <Vanadium> Saizan: but I compare the result double against 1
17:05:30 <Vanadium> oh, derp
17:05:34 <Vanadium> Thanks :)
17:05:35 <Saizan> Vanadium: yeah, but you're not strict in that!
17:05:38 <Saizan> :)
17:05:45 <ski> Cale : ^
17:06:37 <Cale> ski: That's good, but it goes way way too fast for beginners.
17:06:42 <ski> ok
17:06:43 <ski> (<http://www.cas.mcmaster.ca/~carette/species/> and <http://comonad.com/reader/2008/generatingfunctorology/> also claim to be relevant, for data types)
17:06:49 <Vanadium> Great, now it is within three times as slow as C++ :]
17:07:14 <Cale> The point of discussing generating series is that we can relate combinatorial operations on (weighted) sets to algebraic operations on series, and then decompose complicated combinatorial structures in terms of simpler ones and the operations, which gets us their generating series for free.
17:07:34 <Saizan> however you're right that acc doesn't fit the usual "lazy accumulator" pattern, because if/then/else reduces without evaluating its branches first
17:07:54 <Cale> The point is not to muck about with coefficients and obtain random formulas :)
17:08:11 <Vanadium> I thought of putting the whole thing into a strict State (g, a) monad
17:08:15 <Vanadium> clearly I should have done that
17:08:26 <ski> Cale : the latter of the beginner level would appear to be <http://www.math.uwaterloo.ca/~dgwagner/co330.html> ?
17:08:32 <monochrom> "strict State monad" is not strict in state.
17:08:49 <Vanadium> ... >:[
17:08:59 <Cale> ski: That's a different prof now...
17:08:59 <Saizan> monochrom, Vanadium: that would have probably forced the tuple returned by randomR though, so it should have worked
17:09:04 <monochrom> So much for reasoning by meaningful names.
17:09:31 <Cale> ski: I wonder if Jackson's notes are still available. I hope they are. They're popular enough that hopefully someone at print services thought to hang on to them :)
17:09:36 <Saizan> if you just say "State . randomR"
17:09:42 <Vanadium> I am not sure I understand what it is strict in
17:10:14 <monochrom> strict in actions. for example «undefine >> return 0» bombs
17:10:16 <Cale> The first thing any good combinatorics text should start with are the various lemmas relating the operations on series (addition, multiplication, composition, perhaps differentiation) to corresponding operations on weighted sets.
17:10:21 <Saizan> Vanadium: it's strict in the tuple holding your state and the returned value, since it uses a case .. of rather than a let to take it apart
17:10:41 <monochrom> «put undefined >> return 0» does not bomb
17:10:56 <Cale> (or perhaps species, if you're taking the highbrow route)
17:11:11 <ski> Cale : what uni was Jackson at ?
17:11:15 <Cale> ski: Waterloo
17:11:22 <Cale> ski: But he's retired.
17:11:31 <Cale> (shortly after I left)
17:11:51 <monochrom> And http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5481 shows what is so lazy about lazy state monad
17:12:39 <[c]> ACTION -> IO a
17:12:40 <ski> hm, would those notes have any relation to "Combinatorial Enumeration" <http://store.doverpublications.com/0486435970.html> by Ian P. Goulden,David M. Jackson (book) ?
17:12:50 <fax> I am feeling lazy
17:14:31 <Cale> ski: Yes, they're essentially that, but pared down to take out all the stuff that's not relevant to beginners, with a more modern treatment of the pattern algebra section, and more prose.
17:15:19 <Cale> Goulden and Jackson's bible is great, but it's encyclopedic in scope, which makes it hard to recommend to beginners.
17:15:37 <Cale> (at least as a primary text)
17:16:43 * ski wonders what a weighted set is ..
17:17:03 <ski> (ic)
17:17:15 <Vanadium> Any set but Set Float?
17:17:41 <Cale> A set S together with a function S -> N such that the preimage of any natural number is finite
17:17:49 <m3ga> the ddc channel is #disciplined and benl23 usually comes on line about this time of day.
17:18:00 <kamatsu> hey, so iPhone apps must now be originally written in C, C++ , or ObjC, compilers and objC code generators are out.
17:18:05 <Cale> w: S -> N is called a weight function
17:18:12 <kamatsu> does this put an end to that work getting Haskell running on the iPhone?
17:18:25 <pikhq> kamatsu: That appears to ban the use of the preprocessor.
17:18:33 <benmachine> Cale: where "finite" depends on what S is?
17:18:45 <benmachine> oh wait
17:18:52 <benmachine> finite in size
17:18:54 <Cale> yeah
17:19:07 <benmachine> why that?
17:19:10 <Cale> There are finitely many elements of S with any given weight
17:19:12 <kamatsu> pikhq: perhaps the preprocessor is considered part of C
17:19:23 <Cale> Well, it's so that the generating series will be well-defined
17:19:35 <pikhq> It most definitely bans any other metaprogramming technique in C.
17:19:46 <pikhq> And bans all but the worst for C++.
17:19:57 <Vanadium> Hey now
17:20:02 <Cale> If we have some weighted set (S,w), the (ordinary) generating series for S with respect to w is defined as the sum over all s in S of x^w(s)
17:20:19 <pikhq> Vanadium: Template metaprogramming is the worst metaprogramming technique I know of.
17:20:35 <benmachine> ah
17:20:39 <kamatsu> it's technically a more powerful type system than haskell's
17:20:47 <kamatsu> just implemented in a totally arse-backwards way
17:20:47 <dolio> Is it really worse than cpp?
17:20:58 <pikhq> dolio: Yes.
17:21:02 <dolio> Heh.
17:21:21 <Cale> This is taken as a sum in the ring of formal power series C[[x]] (where usually it doesn't matter which field we use, but it doesn't hurt to use the complex numbers)
17:21:22 <Jafet> Well it's worse for getting stuff done, else it's the most fun to play with
17:21:25 <Saizan> kamatsu: most of the time it feels like they forgot to put a typechecker in, though :)
17:22:17 <monochrom> «case randomR (0 :: Double, fromIntegral n) g of (p, g')» still stack-overflows in ghci
17:22:29 <Cale> So in order for that sum to be well-defined, we insist that there only be finitely many contributions to any given coefficient
17:22:30 <benmachine> Cale: so natural numbers with weighting function being the identity would be reasonable, but not natural numbers with (const 1)?
17:22:37 <Cale> right
17:22:54 <xerox> also |S| <= omega, I guess
17:23:02 <Cale> The natural numbers with the identity weight are an important weighted set, in fact, and they have generating series equal to 1/(1-x)
17:23:08 <fax> ~/win 12
17:23:27 <ddarius> Cale: Your thoughts on cycle index series?
17:23:29 <benmachine> oh I think I see
17:24:13 <Cale> ddarius: Awesome tool, but probably should come later on. For me, they came at the end of a second course in combinatorics.
17:24:16 <monochrom> and still stack-overflows in -O2
17:24:43 <Cale> 1/(1-x) = 1 + x + x^2 + x^3 + ...
17:25:01 <fax> that's a great one
17:25:03 <fax> how do you prove it
17:25:09 <fax> or how would you come about this?
17:25:13 <Jafet> Multiplication
17:25:14 <ski> (Cale : hm .. just wondering if it would work with `C' being `p-adic numbers' for some prime `p' ..)
17:25:17 <fax> I only know that rubbish one with the differentation
17:25:19 <Cale> Since (1-x) (1 + x + x^2 + ...) = (1 + x + x^2 + ...) - x*(1 + x + x^2 + ...)
17:25:25 <fax> oh there's theat linear equation way, that's nice too
17:25:26 <Cale> = (1 + x + x^2 + ...) - (x + x^2 + ...)
17:25:34 <Cale> = 1
17:25:44 <fax> aha
17:25:54 <Saizan> > case randomR (0 :: Double , undefined) (mkStdGen 42) of (_,_) -> ()
17:25:55 <lambdabot>   * Exception: Prelude.undefined
17:26:27 <Cale> ski: hehe, using rings with nonzero characteristic would be weird, but it would work
17:26:37 <Cale> For some values of "work"
17:27:43 <Cale> Er, I suppose p-adic numbers still have characteristic 0 though, don't they? You'd be fine.
17:27:53 <Jafet> The CReal series are neat
17:27:55 <Cale> Mostly your series have integer coefficients anyway
17:28:07 <Cale> and nonnegative integer coefficients even moreso
17:28:26 <xerox> yes they do
17:29:01 <Cale> Yeah, you could just use the natural numbers, but it's nice to have a little room to work with sometimes.
17:29:47 <Cale> Another thing which I find isn't covered nearly enough (or in a sufficiently useful form), is Lagrange's implicit function theorem for formal power series
17:30:18 <monochrom> > case randomR (0 :: Double , 5) (undefined) of (_,_) -> ()
17:30:18 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:30:19 <lambdabot>    `System.Random.RandomGen ...
17:30:28 <monochrom> > case randomR (0 :: Double , 5) (mkStdGen undefined) of (_,_) -> ()
17:30:29 <lambdabot>   ()
17:30:30 <Cale> You use it to get the generating series for recursively-defined structures
17:31:41 <Cale> It was far and away the most challenging theorem to understand and commit to memory in my first year of university ;)
17:32:02 <ski> hm `t(x) = x + t(x)^2', i.e. `t(x)^2 - t(x) + x = 0' would be then be `t(x) = sum_{i -> |N} C_i * x^i' for `C' giving catalan numbers (numbers of trees with a given size) .. iiuc
17:32:25 <Cale> yeah
17:32:41 <ski> (maybe off-by-one errors in there .. hm)
17:33:13 <fax> why isn'tit  t = 1 + t^2  ?
17:34:00 <ski> well, as i understand it, you need to parameterize by `x' to be able to tell the size of a tree (the number of `x's in it)
17:34:05 <Cale> yeah
17:34:43 <fax> huh
17:34:51 <fax> so you are counting the size of a tree rather than the number of trees
17:35:08 <xerox> both, the latter is the coefficient
17:35:20 <Cale> There are a couple of nearly-equivalent ways to do it: You can have that the set of trees T decomposes as {empty tree} union {single vertex} x T^2
17:35:21 <ski> we're counting the number of trees with `i' `x's in them, for each `i'
17:35:35 <Cale> and that gives the equation T(x) = 1 + x T(x)^2
17:35:41 <ski> that number of trees is the `C_i' coefficient of the `x^i' term in the sum above
17:36:00 <Cale> I suppose the way you have it counts the leaves
17:36:04 <Gracenotes> hm, it seems like almost every day you guys are talking about a branch a math I haven't heard of :P
17:36:06 <Jafet> Oh! This must be the weekly seminar
17:36:18 <ddarius> Gracenotes: There is a lot of math.
17:36:20 <Gracenotes> I feel so dumb
17:36:27 * Jafet pays attention
17:36:29 <fax> how many mathe is there
17:36:31 <fax> ??
17:36:49 <fax> Gracenotes you can study number theory
17:37:00 <ski> there are exactly `Beth_3' maths
17:37:07 <Cale> heh
17:37:08 * ski is jesting ..
17:37:38 <Cale> There are countably many mathematicses.
17:37:39 <Gracenotes> the generatingfunctorology post looked interesting
17:37:40 <ksf> malloc'ed memory is guaranteed not to be moved by the gc, is it?
17:38:10 <ksf> would anything in the rts be confused or segfault if the kernel would unmap some of it?
17:38:13 <ski> Cale : is there a way to construct the trees as `t(x) = 1 + x + t(x)^2', but modulo unit and associativity laws ?
17:38:43 <ski> (hm, no, not module associativity here .. that would just give sequences)
17:38:49 <Cale> Commutativity?
17:38:53 <Cale> This is where cycle index stuff comes in handy
17:39:06 <Cale> Where you want to quotient out by some symmetries
17:39:18 <Cale> Polya enumeration :)
17:39:34 <Jafet> malloc typically gets its own pages, so its unlikely that gc would store something there
17:39:34 <fax> my god the memory is bad
17:39:35 <ski> i suppose my real question was whether one can handle inductive types modulo some equivalence relation
17:39:36 <Jafet> (I'm guessing)
17:39:49 <fax> I have had to practice a lot of Polya enumeration and get it wrong _every_ _single_ _time_
17:39:54 <fax> it is the most painful thing
17:40:04 <Cale> ski: Roughly, but it makes things a good deal trickier in general.
17:40:06 <fax> and you thinking that if a program can do it..........
17:41:19 <ski> ok
17:41:22 <xerox> it's useful to use burnside's lemma first
17:41:30 <Cale> dolio and others in the memristor discussion, I think I know why some of the other apparently-possible relationships aren't being considered
17:41:50 <ski> (what is a memristor ?)
17:42:06 * ski looks up Polya enumeration
17:42:51 <Jafet> MY memory stirs
17:42:52 <Cale> It's a device for which charge (the integral of current) is related to flux (the integral of voltage) according to some function.
17:43:07 <Gracenotes> hm, I do know burnside's lemma... would probably need to expand my group theory mojo, if they're related
17:43:11 <Cale> Some monotone increasing function.
17:43:24 <xerox> Gracenotes: yeah, Polya generalizes Burnside
17:43:29 <ski> an analog integrator ?
17:44:06 <Jafet> For a hardcoded function
17:44:12 <Cale> ski: Basically. You run a current through it one way, and the resistance goes up, run it through the other way, resistance goes back down again
17:44:44 <Cale> It's a new passive circuit element which was conjectured to exist in the 1970's and just recently (2005 or so) discovered to actually exist.
17:45:19 <dolio> Cale: Why is that?
17:45:43 <Jafet> I wonder how Chua ever came to that sort of conjecture
17:46:02 <Cale> dolio: If you think about some of the other possible relationships, they seem to require energy input (though I'd have to check to be rigourous)
17:46:16 <xerox> Cale: wow it's only been seen in 2005? I remember reading on some old text in the library about a physical device doing exactly that (integration)
17:46:33 <kmc> there are plenty of analog integrators
17:46:42 <xerox> aaah, okay.
17:46:43 <Cale> For example, the integral q = k v device would have the property that if you put a charge on it, the voltage would have to keep increasing forever
17:47:10 <Cale> and the integral phi = k i device would respond to a voltage pulse by becoming a current source
17:47:38 <Cale> er, hmm
17:47:56 <Cale> (is that right?)
17:48:24 <Cale> Jafet: The way that he conjectured it is this...
17:48:46 <Cale> The traditional passive circuit elements relate 4 variables with each other:
17:49:38 <Cale> You have charge, q, its time derivative which is current, i, and you have magnetic flux, phi, and its time derivative, which is voltage, v.
17:49:41 <ski> (Gracenotes : for each set of branches of math one has heard about, there's always a branch of math not in that set)
17:50:11 <Cale> Of course, charge and current are related by definition, as are flux and voltage
17:50:24 <fax> jometry
17:50:45 <Cale> So that leaves 4 possible remaining relationships. 3 of which are given by the traditional circuit elements: the resistor relates current to voltage
17:51:20 <Cale> the capacitor relates charge and voltage, and the inductor relates current and flux
17:51:45 <monochrom> nice symmetry
17:51:49 <Cale> and so the natural question to ask from that perspective is "what relates charge and flux"?
17:51:57 <Cale> There ought to be an additional device
17:52:09 <Cale> and that's what the memristor is
17:52:11 <Jafet> I see
17:52:51 <fax> I wish I understood electronics
17:53:14 <ddarius> fax: Learn it.
17:53:28 <Cale> fax: MIT has wonderful lectures on YouTube
17:53:33 <fax> ok
17:53:36 <Cale> Start with 8.02
17:53:43 <Jafet> And your diagram proposes relationships between the integrals of charge and flux, whatever those mean
17:53:52 <Cale> and then there's 6.002 if you want the engineering side of things :)
17:54:00 <Cale> Jafet: yeah
17:54:25 <monochrom> I wish I understood MIT numbering scheme.
17:54:46 <Cale> Jafet: Other people (Chua included) have considered meminductors and memcapacitors, which I listed in that diagram
17:55:26 <Jafet> Anyone have any idea how they might be realized?
17:55:50 <Cale> Well, not really, though there are some heuristics for deciding if some material is one of them.
17:56:03 <Vanadium> Can lambdas do pattern matching on their arguments without a case?
17:56:08 <kmc> no
17:56:11 <Vanadium> boring
17:56:14 <benmachine> Vanadium: yes but only irrefutable
17:56:20 <kmc> not more than one pattern
17:56:23 <Cale> Vanadium: they can, but only one pattern
17:56:27 <kmc> > (\(Just x) -> ()) Nothing
17:56:28 <lambdabot>   * Exception: <interactive>:1:134-148: Non-exhaustive patterns in lambda
17:56:29 <Vanadium> What is wrong with \True -> 42 ; False -> 0
17:56:37 <kmc> it's not legal haskell syntax
17:56:40 <ski> no lambda-case
17:56:43 <Vanadium> It should be!
17:56:55 <benmachine> it's not very lambda at that point
17:56:56 <ski> (yes, something like that ought to be valid)
17:57:02 <kmc> \ case of True -> 42; False -> 0
17:57:03 <benmachine> lambdas are supposed to be small
17:57:12 <ski> why ?
17:57:20 <benmachine> because I say so
17:57:26 <ski> ah, ok then
17:57:27 <fax> lets make them only one line
17:57:32 <fax> the layout can enfore it
17:57:47 <Cale> Memcapacitors and meminductors would be extremely useful because they would give us memories without consuming energy (ideally)
17:57:49 <kmc> not easily
17:58:32 <ski> (OCaml has `function None -> foo | Some x -> bar x')
17:58:48 <aavogt> that looks crazy if foo is long
17:58:57 <Jafet> Wouldn't that violate the laws of thermodynamics?
17:58:59 <ski> not if you indent the `|' properly
17:59:12 <ski> (i.e. under the `function')
17:59:17 <monochrom> lambda-case will look just as crazy if foo is just as long.
17:59:26 <Cale> Jafet: Well, there would of course be some loss -- really even the wires have some resistance in them.
17:59:57 <Jafet> Or that other limit whose name I've forgotten
18:00:03 <Saizan> @remember Jafet <Jafet> Wouldn't that violate the laws of thermodynamics? <ski> not if you indent the `|' properly
18:00:03 <lambdabot> Okay.
18:00:20 <monochrom> ...
18:00:30 <ski> "let f x y = function\n      nil   -> ...\n      z:zs -> ..z..zs.."
18:00:38 <ski> (Saizan : hehe)
18:00:47 <Cale> Jafet: But just as with an ideal capacitor, you can put some charge there, and get your electrons back later, with no loss, a memcapacitor would be similar.
18:03:04 <dolio> Cale: So you mean he was only mentioning the combinations that had the properties he was interested in?
18:03:16 <dolio> Or is it more than that?
18:03:36 <Cale> dolio: that, and some of the other things seem like they should be physically impossible without an external power source
18:03:44 <dolio> Okay.
18:04:46 <Cale> dolio: But I might be mistaken about that
18:08:25 <Cale> It's just that, if you consider something like integral q dt = k v, that means that if you run a current through the device for a moment, you get up to some charge q before disconnecting the device, and then *that* is being integrated to provide the voltage. So without any current going through the device, we have that the voltage is rising (or falling) forever now, which seems implausible.
18:09:30 <dolio> Oh yeah.
18:09:32 <dolio> Okay.
18:10:17 <Cale> (On the other hand, I want one)
18:12:02 <Jafet> Well, you can't extrapolate from no samples.
18:12:15 <Jafet> Or one
18:12:34 <Cale> (Perhaps I'm mistaken, are we allowed to disconnect the device like that?)
18:12:50 <Vanadium> Since I discovered view patterns, I am writing the worst case statements
18:13:10 <k23z__> any equivalent to sympy in haskell ?
18:13:32 <ski> (Vanadium : s/writing/rewriting/ ?)
18:13:51 <Vanadium> No
18:14:00 <k23z__> Vanadium, talkin to me ?
18:14:03 <Vanadium> No
18:14:06 <Jafet> Why do you want a buggy incomplete algebra system in haskell
18:14:18 <Vanadium> ski: Now all my patterns look like (L.uncons -> Just (isFoo -> False, cs))
18:14:22 <ski> why are you writing worser `case' expressions after learning about view patterns ?
18:14:29 <Vanadium> Because they are so convenient!
18:14:34 <Cale> The other diagonal, integral phi t = k i, if we exposed it to a voltage pulse would build up some flux which would then be integrated to provide the current. So it's like an voltage-integrator controlled current source, which also seems like something that's not passive.
18:14:35 <monochrom> haskell is incomplete or inconsistent
18:14:55 <ski> (or both :)
18:16:39 * ski thinks `(foo -> f) x (Just y) = ...' should be allowed
18:17:00 <monochrom> what is the (foo -> f) part doing?
18:17:35 <ski> consider `(memo -> fib) 0 = 0; (memo -> fib) 1 = 1; (memo -> fib) n = fib (n-1) + fib (n-2)'
18:17:56 <ski> `memo -> fib = \x -> case x of ..fib..' already work, iirc
18:18:09 <benmachine> like decorators in python?
18:18:40 <benmachine> creating a function definition by definition a function and then passing it to a different one
18:18:45 <ski> so in that latter, the lambda expression is matched against `memo -> fib', which matches the result of applying `memo' on that lambda expression to the pattern `fib'
18:18:49 <benmachine> s/definition/defining
18:19:05 <kmc> benmachine, what about them?
18:19:06 <ski> which binds `fib' to a memoized version of the lambda (to be used recursively in the same lambda)
18:19:16 <kmc> benmachine, that sort of thing is pervasive in Haskell and has no special syntax
18:19:46 <benmachine> kmc: I am drawing a comparison between ski's idea and that one
18:19:55 <kmc> i mean if you like "map" is a "decorator" which turns a function on elements into a function on lists
18:19:57 <Vanadium> Monad transformers are scary
18:20:08 <kmc> hmm, i see
18:20:25 <kmc> strange
18:20:43 <kmc> Vanadium, i don't think so.  they are pretty clunky though
18:20:51 <ski> benmachine : you mean like `map -> toUppers = toUpper' ?
18:21:04 <benmachine> I guess so
18:21:06 <monochrom> this is not haskell98 right?
18:21:17 <Vanadium> Trying to do a thing that has a State and a Reader and can do IO
18:21:22 <ski> benmachine : or `(map -> frobList) x = ..actually frob x..'
18:21:24 <benmachine> monochrom: view patterns are not haskell 98; this isn't even just view patterns
18:21:32 <Vanadium> Is that a StateT a (ReaderT b IO) or the other way around? :3
18:21:36 <Saizan> "map -> toUppers = toUpper" works?
18:21:44 <kmc> Vanadium, in that case it might not matter
18:21:54 <kmc> @unmtl StateT a (ReaderT b IO) c
18:21:54 <benmachine> Vanadium: lambdabot's unmtl is invaluable here
18:21:54 <lambdabot> a -> b -> IO (c, a)
18:22:01 <kmc> @unmtl ReaderT a (StateT b IO) c
18:22:01 <lambdabot> a -> b -> IO (c, b)
18:22:09 <Vanadium> Well, that does seem relatively equivalent
18:22:23 <kmc> Reader is like read-only state
18:22:26 <benmachine> Saizan: presumably; it's a pattern binding not a function binding
18:22:27 <kmc> and Writer is like append-only state
18:22:32 <Vanadium> Yeah, that is what I want
18:22:42 <kmc> so they should commute with State -- it doesn't matter which order you glue together the states
18:22:47 <Vanadium> Okay
18:23:08 <ski> Saizan : yes .. but apparently you need brackets like `let (map -> toUppers) = toUpper' (no idea why)
18:23:53 * benmachine wonders if there are ambiguities
18:24:53 <ski> @unmtl StateT s (ReaderT r IO) a
18:24:53 <lambdabot> s -> r -> IO (a, s)
18:25:01 <ski> @unmtl ReaderT r (StateT s IO) a
18:25:02 <lambdabot> r -> s -> IO (a, s)
18:28:54 <benmachine> ski: case toUpper of map -> toUppers -> toUppers string?
18:29:18 <ski> hm, right, that's an ambiguity
18:29:18 <benmachine> that's erm, not ambiguous
18:29:22 <benmachine> well
18:29:30 <benmachine> it's not ambiguous if you read ahead to the ->
18:29:31 <ski> (or, it might be, i suppose)
18:29:36 <benmachine> the second
18:29:42 <benmachine> oh but wait
18:29:51 <benmachine> can the pattern in the RHS of a view pattern be a view pattern? :P
18:30:09 * ski is not terribly fond of using `->' for view patterns / transformational patterns, though
18:30:13 <ski> benmachine : yes
18:30:40 <ski> `foo -> bar -> x' being the same as `(bar . foo) -> x'
18:31:02 * ski wonders whether one needs brackets for the former one
18:31:08 <benmachine> ghci wants them
18:31:47 <benmachine> if you didn't need brackets there then the case expression would require you look at the whole line
18:32:10 <ski> .. yes it appears to want them
18:32:25 <benmachine> then the last section would be the expression, and all the leading bits would be nested patterns
18:32:28 <ski> *nod*
18:32:43 <benmachine> it'd be horrible for humans to read regardless of what the compiler thought :)
18:33:35 <ski> imo  inv f p  or maybe  f `inv` p  or  f inv p  might be nicer than  f -> p
18:34:19 <ski> (seeing as "morally" view patterns seems to be related to (one-sided, i think) inverses .. i'm not sure of the details, though)
18:34:42 <ski> (of course, that would require a new keyword, or keysymbol)
18:36:27 <ski> (hm .. `f >- p' ?)
18:36:57 <benmachine> it's like arrow syntax but the other way around
18:37:06 <benmachine> that is of no use to me because I don't know anything about arrow syntax
18:37:23 <Jafet> Looks like a blown-out umbrella
18:37:56 <ski> well, i suppose that wouldn't use `>-' in any similar way as arrow syntax uses it
18:38:05 <benmachine> f >-+o
18:39:18 <ski> (for arrow syntax, we have `p0 <- f -< e0' where `p0' is a pattern, `e0' is an expression mentioning the local arrow variables, and `f' is a normal haskell expression expressing the arrow that transforms `e0' to `p0')
18:40:41 <ski> (where "local arrow variables" are variables that are output from "arrow calls", like variables bound in `p0'; also including variables that come from the input of the current arrow (in the "arrow lambda" `proc p0 ->')
18:42:03 <ski> (i suppose `p <- f' or `f -> p' would be the corresponding part of the arrow syntax .. which brings us back full circle :)
18:42:24 <ski> (so, maybe there is actually a point to using `<-', there .. even if i don't like it much)
18:44:45 <Cale> Actually, just thought of something -- my argument about those integral/derivative devices only applies to the case where the function being considered is linear. Perhaps a differently shaped curve is possible
18:45:01 <ski> (since `f -< e0' could be seen as a "arrow expression", then `p0 <- f' could maybe be thought of as an "arrow pattern", and so this is analogous to `f -> p' being a *pattern* in view patterns)
18:48:28 <Philonous> Speaking of arrow syntax, it would be nice to have "p <- f" being sugar for "p <- f -< () "
18:48:58 <Sgeo_> lambdabot isn't responding to my msg
18:48:59 <Sgeo_> msgs
18:49:27 <Philonous> @botsnack
18:49:28 <lambdabot> :)
18:49:56 <Mathnerd314> @help botsnack
18:49:56 <lambdabot> botsnack. Feeds the bot a snack
18:50:17 <Mathnerd314> is it a healthy snack?
18:50:37 <Sgeo_> > 1 < 2 && 2 < 3
18:50:38 <lambdabot>   True
18:50:52 * Sgeo_ really needs to get precedence hammered into him somehow
18:51:11 <Mathnerd314> > 1 < 2 < 3
18:51:11 <lambdabot>   Precedence parsing error
18:51:12 <lambdabot>      cannot mix `GHC.Classes.<' [infix 4] and `GHC...
18:51:18 <Mathnerd314> as expected
18:51:25 <Philonous> Yes, lot's of fibres, ample sheafs, tangent planes
18:53:08 <ski> (hm, on this topic of pattern extensions, what do you think of the following (wacky) definitions :
18:53:42 <ski>    (let x^2 = a
18:53:51 <ski>         x*y = b) = (2,3)
18:54:02 <ski>   (defining `a' and `b')
18:54:15 <ski>    case lookup k0 [         ] of
18:54:21 <ski>      Nothing -> n
18:54:27 <ski>      Just v -> j v
18:54:34 <ski>      = n
18:54:42 <ski>   case lookup k0 ((k,v):kvs)
18:54:48 <ski>      Nothing -> n
18:54:51 <danderson> I think you badly need a pastebin
18:54:55 <ski>      Just v -> j v
18:55:04 <ski>        | k0 == k   = j v
18:55:10 <ski>        | otherwise = case lookup k0 kvs of
18:55:18 <ski>          Nothing -> n
18:55:19 <danderson> also, what? It's incomprehensible.
18:55:21 <ski>          Just v -> j v
18:55:29 <ski>  (defining `lookup')
18:55:42 <ski>  sorry, that got longer than i expected
18:55:43 <ski> )
18:56:06 <osaunders> I'm working with functional data structures in PHP. It's a very annoying experience.
18:56:36 <ski> i'm not really sure whether the above features would actually be useful (well, maybe the latter, but it could probably be achieved(sp?) in better ways)
18:56:38 <elly> osaunders: Eugh.
18:56:48 <Sgeo_> Hm. What happens if, with parallelization annotations, you do something like, say a `par` b `par` c `par` (a + b + c) by mistake?
18:57:00 <kamatsu> osaunders: i think i just vomited a little
18:57:09 <osaunders> Yes.
18:57:10 <ski> it is just allowing `let' and `case' to occur in pattern position, with the "obvious" interpretation that follows from the declarative reading
18:57:16 <osaunders> Thank you. You know my pain.
18:57:22 <Sgeo_> Will it still work, albeit not efficiently, or will it fail?
18:58:13 <ski> hm, in the first, there should be an `in (x,y)' at the end of the `let', i.e. `(let x^2 = a; x*y = b in (x,y)) = (2,3)'
18:58:18 <kmc> Sgeo_, the semantics of (a `par` b) are always the same as the semantics of b
18:58:21 <kmc> as far as i know
18:58:30 <kmc> (might be different in the presence of error / bottom values)
18:59:01 <kmc> Sgeo_, the problem with that annotation is that it will create sparks for a, b, c, then before those sparks have a chance to be made into a thread, it'll force a,b,c anyway in evaluating a+b+c
18:59:15 <ski> danderson : in the first, `(2,3)' is matched against' `(x,y)', then `x^2' is matched against the pattern `a' and `x*y' is matched against the pattern `b' .. only the variables bound by those latter matches (i.e. `a',`b') are bound by the whole pattern, `x' and `y' are local
18:59:17 <kmc> and then if those sparks ever get threads they'll find their closures already under evaluation and will be useless
18:59:21 <kmc> that's why we have pseq too
18:59:38 <kmc> a `par` b `pseq` (a + b)
18:59:42 <EvanR> osaunders: ive been working with php lately at work. the new anonymous function support is a joke
18:59:46 <Sgeo_> kmc, I just want to be sure that mistakes in annotation don't equate to an incorrect program
18:59:54 <osaunders> EvanR: Yep.
19:00:04 <kmc> ensures that one thread will be busy evaluating b before it gets a chance to force a
19:00:12 <Philonous> Sgeo_: No, par can't break you programm, but it can actually slow it down
19:00:19 <kmc> i love how all these languages are getting "new anonymous function support"
19:00:21 <kmc> welcome to 1936
19:00:41 <ski> the second `lookup' case is definig `lookup' in terms of what a `case' on a call to it means (like defining a function `f' in terms of what `f' applied to `x' is, `f x = ..x..', as opposed to `f = \x -> ..x..')
19:00:44 <EvanR> i think the emphasis on terminology 'user-defined function' highlights the designers understanding of anything well
19:01:36 <Jafet> EvanR, I once wrote a utility to find people's names in a database. It involved fuzzy matching closures implemented thrice in sql, php and javascript
19:01:36 <Jafet> And note that two of the three languages had no real closures
19:01:57 <EvanR> ._.
19:02:03 <Sgeo_> GHC should compile to Javascript
19:02:16 <jmcarthur> Sgeo_: we have a compiler for that ;)
19:02:18 * ski runs off as nobody probably understood a word he was saying :)
19:02:30 <jmcarthur> Sgeo_: i beleive it's yhc that can do that
19:02:36 <jmcarthur> *believe
19:02:44 <osaunders> I'm very sad because I wanted to write this web app in Haskell only it was taking too long to learn it so I had to give up and go back to PHP and now I've been using PHP for a while and I keep wanting to do functional stuff that is just too ugly in PHP.
19:02:49 <osaunders> :'-(
19:02:51 <dolio> ski: The second clause of lookup is especially confusing.
19:02:58 <Sgeo_> :t lookup
19:02:59 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:03:23 <kmc> osaunders, learning Haskell is a better use of your time
19:03:48 <EvanR> osaunders: yeah, especially because the only datatype in the language is a Data.Map, so you keep wanting to do sane operations on it without writing a four page for loop
19:03:50 <dolio> If you ask me.
19:03:53 <kniu> I just got a last-minute email from my university pointing me towards GSoC.
19:04:03 <Sgeo_> > lookup 5 [(5, 3), (5,2)] -- 3?
19:04:04 <lambdabot>   Just 3
19:04:05 <kniu> Deadline's tomorrow, and I like Haskell a lot.
19:04:17 <ski> dolio : one could write it in some variant ways .. but possibly you understand the basic idea ?
19:04:23 * ski really needs to run, though
19:04:38 <kniu> Can't come up with anything cool, though.
19:04:46 <Sgeo_> kniu, um, noticing GSoC at the last minute is the reason I'm not trying this year :/
19:04:50 <Sgeo_> Although maybe I will try
19:04:53 <osaunders> I've done quite a bit now. I have to finish this PHP version I think.
19:04:56 <Sgeo_> Last minute proposal, or something
19:04:58 <dolio> Yeah, I understand the idea. I think it's confusing to have the guards defining function cases in the middle of a case statement, which can also have guards.
19:04:59 <Sgeo_> Can't hurt
19:05:01 <SamB_XP> remind me why PHP stopped using Perl as its language?
19:05:06 <kniu> Well, if it gets rejected, so be it.
19:05:17 <fax> wat
19:05:29 <osaunders> SamB_XP: Huh?
19:05:30 <EvanR> SamB_XP: i was trying to figure that out a few days ago, why php supplanted perl
19:05:32 <kniu> All the "interesting" things I want to do with Haskell don't really "benefit the community".
19:05:53 <fax> what does benefit the community?
19:06:03 <kniu> I don't know.
19:06:04 <SamB_XP> osaunders: it used to be made with Perl
19:06:05 <arw> because perl hat some amount of sanity left. php removed that.
19:06:09 <kniu> That guy who did that LLVM backend.
19:06:15 <SamB_XP> using Perl as the language
19:06:16 <kniu> Or hacking on some language tool.
19:06:27 <SamB_XP> stood for Personal Home Page, it did
19:06:33 <EvanR> it makes no sense
19:06:34 <kamatsu> i think any interesting thing benefits the community
19:06:35 <osaunders> That was a long time ago.
19:06:42 <kniu> type-level stuff, libraries, coding utilities, etc.
19:06:50 <EvanR> php has devolved into something horrid and much less working than perl
19:06:54 <SamB_XP> kamatsu: even C++ ?
19:07:03 <kamatsu> SamB_XP: any interesting thing *in haskell*
19:07:05 <kniu> I just want to write interpreters for weird-ass toy languages.
19:07:11 <kamatsu> kniu: then do so :D
19:07:18 <kamatsu> lots of PL nerds use haskell
19:07:18 <SamB_XP> kamatsu: even unsafeInterleaveST ?
19:07:25 <osaunders> @quote oasis
19:07:25 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
19:07:29 <EvanR> just dont write interpreters for weird ass-toy languages
19:07:30 <kamatsu> SamB_XP: I'm sure someone's used that usefully.
19:07:55 <arw> kniu: grab the "write a lisp in 48h" tutorial and change the syntax to something more weird.
19:08:04 <kniu> arw, already done that.
19:08:08 <kniu> well, sort of.
19:08:40 * SamB_XP got sorta hung up on the numeric syntax
19:08:41 <kniu> I made a fexpr-based scheme dialect with pass-by-expression semantics and first-class contexts.
19:08:49 <kmc> nice!
19:08:51 <kamatsu> when I started university, I was a Lisper, but I hated sexps, so I wrote a pretty cool dynamic language that didn't use sexps and had infix operators, over time I realised I was writing haskell with macros and without a type system, and I sort  of gave up on the project
19:08:55 <arw> kniu: then create a prolog interpreter.
19:08:58 <kamatsu> it was in C, too, which wasn't very fun.
19:09:06 <kniu> prolog, eh?
19:09:15 <kmc> "dynamically typed Haskell with macros" would be a fun language
19:09:24 <kmc> but i'd implement in in Haskell, not C ;P
19:09:28 <kniu> macros? with Haskell's syntax?
19:09:28 <kamatsu> yeah
19:09:32 <osaunders> Isn't that Template Haskell?
19:09:34 <kniu> eeeh...
19:09:35 <kamatsu> kniu: well, not quite macros
19:09:36 <Philonous> kmc: Liskel gives you the macro part
19:09:41 <kamatsu> kniu: sorry, not quite Haskell syntax
19:09:42 <Sgeo_> Liskel?
19:09:50 <kamatsu> kniu: it was still internally sexps.
19:09:56 <Cale> kniu: Something I've suggested (and benmachine has a good start on it :) is a step-by-step lazy evaluator for Haskell code. I think things like that would be really useful for teaching as well as understanding performance of programs in terms of the toy operational semantics
19:09:59 <kniu> Haven't heard anything from the Liskell guy in a LONG time.
19:10:22 <kniu> Cale, you mean like a debugger/tracer ?
19:10:28 <kamatsu> Cale: would be interesting, I have one for lambda calculus.
19:10:40 <kniu> or just a plain interpreter that does things step by step?
19:11:11 <Cale> Well, keep everything at the level of syntax, and transform expressions step-by-step to do evaluation, showing each step to the user.
19:11:13 <SamB_XP> a tracer for didactive purposes
19:11:20 <kniu> ah.
19:11:25 <Cale> benmachine: what was that URL again?
19:11:46 <aavogt> you'll put cale out of business!
19:11:56 <SamB_XP> aavogt: lol!
19:12:32 <kniu> Sounds interesting.
19:13:32 <Vanadium> So much for monad transformers making my code more readable by getting rid of all the explicit arguments
19:13:55 <kmc> Vanadium, indeed
19:13:55 <Cale> oh, it was http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi but that's 403'd out now.
19:14:14 <kmc> Vanadium, i have a few thoughts on effective use of monad transformers, if you'd like to hear them
19:14:56 <kniu> Right now I'm writing a MLT path tracer in Haskell, though the path-mutation thing's got me stumped.
19:15:03 <aavogt> stuff like ErrorT can help to flatten out expressions
19:15:14 <Saizan> MLT?
19:15:27 <kniu> Metropolis Light Transport.
19:15:31 <Vanadium> kmc: I am not sure I am going to be able to follow, but sure
19:16:22 <kniu> use path-tracing to find a light path, then make changes to that path, whilst obeying some strange statistical rules, in order to explore the sample space.
19:16:26 <kmc> Vanadium, I think coding an entire program to a transformer stack is cumbersome.  Use the transformers to define a domain-specific monad; newtype-wrap it, and define some primatives
19:16:32 <kmc> then write the rest of your program in terms of those primitives
19:17:00 <aavogt> primates, in my programs?
19:17:08 <Axman6> TacticalGrace: you around?
19:17:11 <fax> @oies primate numbers
19:17:11 <lambdabot>  Sequence not found.
19:17:43 <Philonous> aavogt: I think the technical term is "indigenous people"
19:17:59 <kniu> A hundred monkeys can crank out a working compiler in a million years.
19:18:07 <Cale> http://github.com/benmachine/stepeval -- the offline version :)
19:18:08 <aavogt> ghc exports "indigenous functions"
19:18:08 <kniu> Give 'em Haskell, and they might do it in a thousand.
19:18:24 <aavogt> segregates them with a distinctive#
19:18:36 <Vanadium> If only do-syntax came with a rule that said that if "foo' <- foo; (if/case) foo'..." is valid, "(if/case) foo" shall be valid too and mean the former
19:19:04 <fax> the real problem is that if/then/else is wrong
19:19:07 <Cale> Vanadium: I don't like that
19:19:14 <fax> if we used something like say a... function
19:19:16 <aavogt> Vanadium: could you rephrase that?
19:19:19 <fax> then we could easily just add M to the name
19:19:38 <Cale> However, the case sections thing would solve the same problem with less ambiguity
19:19:50 <aavogt> what does it mean for foo' to be valid?
19:19:59 <Vanadium> typecheck, I guess
19:20:11 <Philonous> @type let ifM a b c = a >>= \p -> if p then b else c in ifM
19:20:12 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
19:20:40 <Cale> Just make it so that if you leave the scrutinee out of a case expression:  case of { ... }, it desugars to  (\x -> case x of {...})  (where x is a fresh variable of course)
19:20:44 <aavogt> @hoogle Dynamic -> Maybe a
19:20:45 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
19:20:45 <lambdabot> Prelude Just :: a -> Maybe a
19:20:45 <lambdabot> Data.Maybe Just :: a -> Maybe a
19:20:45 <Cale> and then you could write
19:20:50 <Cale> foo >>= case of ...
19:21:04 <Cale> and there'd be no need for the special case
19:21:18 * ManateeLazyCat pasted "My code." at http://paste2.org/get/764049
19:21:19 <ManateeLazyCat> Above code is neat? Or have better solution for that?
19:21:45 <aavogt> Vanadium: have a suitable fail method, then  do (fromDynamic -> Just foo') <- foo;  ...
19:21:55 <Axman6> Cale: i like this idea
19:22:40 <aavogt> if you actually want for the result of your foo computation to be typechecked...
19:22:43 <ManateeLazyCat> Can i use Templaste Haskell improve http://paste2.org/get/764049 ?
19:22:44 <aavogt> at runtime
19:22:44 <Cale> ManateeLazyCat: Rather than Foo _ _ _, you should use Foo {}
19:22:54 <Vanadium> Why at runtime?
19:23:11 <aavogt> you said typecheck
19:23:22 <Vanadium> I thought types happened at compile time
19:23:23 <ManateeLazyCat> Cale: Thanks, i change it.
19:23:30 <ManateeLazyCat> Cale: More suggestions?
19:23:30 <aavogt> which isn't something that you get to choose at runtime
19:23:33 <Cale> ManateeLazyCat: Even if your type isn't defined using record syntax, it's valid to do that
19:24:05 <SamB_XP> it's a clever extension ;-P
19:24:07 <aavogt> Vanadium: oh, I sort of see how you could convert your sugar to some typeclass...
19:24:39 <ManateeLazyCat> Cale: Because DBus message just accept [Variant], for type safe, i use above code check when pack and unpack.
19:24:45 <kmc> that's a clever use of view patterns
19:24:48 <aavogt> with your two (or more?) instance hopefully not overlapping
19:25:11 <ManateeLazyCat> Cale: Then user won't do mistake on DBus arguments.
19:25:20 <Cale> ManateeLazyCat: You might want unpackDaemonSignalArgs :: DaemonMember -> [Variant] -> Maybe DaemonSignalArgs
19:25:55 <ManateeLazyCat> Cale: I add error when mismatch.
19:25:55 <ManateeLazyCat>  
19:25:55 <Cale> You can use the do-notation for the Maybe monad to write that fairly simply.
19:26:04 <aavogt> ManateeLazyCat: put the type signatures in the variable bindings? like    Just (a :: Ty) = fromVariant x
19:26:08 <aavogt> though that's an extension
19:26:30 <ManateeLazyCat> Cale: Because if unpack a invalid DBus arguments should be a error.
19:26:51 <ManateeLazyCat> aavogt: Thanks for your tipes.
19:27:06 <Cale> ManateeLazyCat: Still, I think the code would come out a little cleaner that way.
19:27:20 <Cale> I'll hpaste...
19:27:25 <ManateeLazyCat> Cale: Thanks.
19:27:37 <aavogt> ManateeLazyCat: also, instead of all those underscores you can write   (Constr {}) , when you don't care about what it actually contains
19:27:54 <ManateeLazyCat> aavogt: GHC will check for me?
19:27:57 <aavogt> even if the data type was defined without field labels
19:28:28 <aavogt> ManateeLazyCat: I mean that you will have to change less code then if you change the number of parameters to your constructors
19:28:35 <pickles> also handy for future-proofing, so you can change the data type and not have to change the Constr{}
19:28:42 <aavogt> this is for checkDaemonSignalArgs
19:28:44 <ManateeLazyCat> aavogt: I see.
19:29:10 <aavogt> ManateeLazyCat: is Variant an existential?
19:29:29 <aavogt> like   data Variant = forall a. C a => Variant a ?
19:29:57 <ManateeLazyCat> aavogt: Variant is below type in dbus-core.
19:31:15 * ManateeLazyCat pasted "Variant define" at http://paste2.org/get/764054
19:31:15 <ManateeLazyCat> Above is Variant define in dbus-core/Types.hs
19:31:31 <aavogt> you can probably write unpackDaemonSignalArgs in a couple lines of TH
19:31:45 <aavogt> let me try :)
19:31:56 <Cale> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24770#a24770
19:31:56 <ManateeLazyCat> aavogt: Oh, thank you so much!
19:32:10 <ManateeLazyCat> aavogt: I haven't idea that how to use TH, less documentation.
19:32:24 <ManateeLazyCat> Cale: Thanks, i read it.
19:32:27 <Cale> Of course, it gets even cleaner if you use the applicative combinators
19:32:29 <Jafet> > less documentation
19:32:29 <Sgeo_> Is Haskell a good language for compiling one language into a very very similar language?
19:32:30 <lambdabot>   Not in scope: `less'Not in scope: `documentation'
19:32:40 <Jafet> Oops
19:32:43 <Sgeo_> Actually, is there anything Haskell ISN'T good for, other than getting a job?
19:32:44 <Axman6> Sgeo_: i'd say so
19:32:52 <Axman6> ouch
19:33:05 <SamB_XP> Axman6: what ?
19:33:15 <Jafet> Sgeo, running on your pal's macbook
19:33:22 <ManateeLazyCat> Cale: But i don't want Maybe.
19:33:23 <aavogt> running on your iphone
19:33:30 <Cale> ManateeLazyCat: I know, look at the bottom
19:33:31 <ManateeLazyCat> Cale: If mismatch, it's a error.
19:33:41 <SamB_XP> aavogt: especially 4.0 :-(
19:33:44 <Sgeo_> The yhc thing from before, though..
19:33:51 <Cale> ManateeLazyCat: We're just going *via* Maybe because that's what fromVariant gives us, and it makes collecting the errors easier
19:34:06 <Sgeo_> *shrug*. What about Android?
19:34:07 <ManateeLazyCat> Cale: Oh, i see. :)
19:34:13 <Sgeo_> Although I asked about that earlier >.>
19:34:47 <Axman6> @tell TacticalGrace Is there any chance we'd be able to work on Repa at AusHac? I'd quite like to work on it, but if it's a more closed project (ie, for a PhD or something), then that's fair enough
19:34:47 <lambdabot> Consider it noted.
19:34:55 <pickles> someone should make (>.>) an operator
19:35:17 <kmc> :t (>) . (>)
19:35:18 <lambdabot> forall a. (Ord (a -> Bool), Ord a) => a -> (a -> Bool) -> Bool
19:35:24 <kmc> :t let (>.>) = (>) . (>) in (>.>)
19:35:25 <lambdabot> forall a. (Ord a, Ord (a -> Bool)) => a -> (a -> Bool) -> Bool
19:35:36 <pickles> yay
19:36:10 <Jafet> Now define the constructor :-
19:36:20 <ManateeLazyCat> Cale: Wow, it's cool.
19:36:30 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24770#a24771
19:36:42 <Cale> ManateeLazyCat: There's even better using Control.Applicative :)
19:37:02 <ManateeLazyCat> Cale: More clean, and less work when change number of constructor.
19:37:15 <TacticalGrace> Axman6: Repa is not closed
19:37:16 <lambdabot> TacticalGrace: You have 1 new message. '/msg lambdabot @messages' to read it.
19:37:41 <TacticalGrace> Axman6: we just need to clean up the code and cabalise it
19:38:09 <TacticalGrace> Axman6: by the time of AusHac, it should be on hackage
19:38:39 <Cale> ManateeLazyCat: Yeah, if you have a ton of this stuff to do, you might even go further...
19:39:20 <ManateeLazyCat> Cale: In my old code, i need change every place for match number parameter of constructor.
19:39:35 <ManateeLazyCat> Cale: So i think #haskell must have people know how to improve it. :)
19:39:47 <Axman6> TacticalGrace: excellent :)
19:40:07 <kniu> The package versioning policy checker seems simple enough.
19:40:08 <ManateeLazyCat> Cale: I saw this tips before, i remember is aavogt teach me.
19:40:51 <kniu> However, I'm still fuzzy on what the "problem" is.
19:41:24 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24770#a24772
19:41:25 <ManateeLazyCat> Cale: Yes, your solution is flexibility.
19:41:51 <ManateeLazyCat> Cale: Cleaner. :)
19:43:57 <ManateeLazyCat> Cale: I need check Maybe at last, not check it for every fromVariant.
19:44:56 <Axman6> TacticalGrace: is this descriptiong accurate? http://www.haskell.org/haskellwiki/AusHac2010#Repa
19:45:28 <ManateeLazyCat> Cale: I think the second in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24770#a24771 is best.
19:45:55 <TacticalGrace> Axman6: that's fine
19:48:00 <ManateeLazyCat> Cale: Can i use TH generate http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24770#a24771 automatically? Because DaemonMember corresponding with DaemonSignalArgs.
19:52:24 <Vanadium> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24773#a24773 took me long enough
19:56:51 <applicative> Vanadium, curse that 'import "mtl" ..."  it messes with the syntax highlighting
19:57:17 <aavogt> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24770#a24774
19:57:41 <Vanadium> Curse monads-fd for messing with my imports :<
19:57:49 <Vanadium> also, ignore that redundant code :<
19:57:56 <ManateeLazyCat> aavogt: Thanks, i try.
19:58:41 <aavogt> the expression generated is just like the one you wrote, no?
19:59:13 <aavogt> though the funny variable names make it a bit difficult to follow
19:59:57 <aavogt> there should be a library of things like   foldl (\f x -> [| $f <*> $x |])
20:00:09 <Sgeo_> [| |]?
20:00:18 <Vanadium> (How do you call a haskell implementation of hangman? Hangman already starts with "ha")
20:00:22 <aavogt> Sgeo_: template haskell quote
20:00:33 <aavogt> Sgeo_: see the url I linked
20:00:34 <applicative> hahangman
20:00:40 <monochrom> haskeller
20:00:47 <ManateeLazyCat> aavogt: Looks complicated.
20:00:53 <monochrom> "hangman" is sexist anyway :)
20:01:01 <absentia> hask me anyting and I'll kell you no lies?
20:01:05 <applicative> Vanadium, I love "main = playHangman".  I think it should be a separate one-line module.
20:01:52 <monochrom> @remember absentia hask me anyting and I'll kell you no lies
20:01:52 <lambdabot> It is forever etched in my memory.
20:03:12 <Jafet> Implement mornington crescent with functors
20:03:33 <kmc> hask me anything and i'll keel you no lies
20:03:43 <kmc> @keel
20:03:44 <lambdabot> all i know is i have experienced my own death unhappening...
20:03:46 <Jafet> The aim is to name the Monad typeclass
20:03:46 <kmc> @keel
20:03:47 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
20:04:37 <Sgeo_> :t fromMaybe
20:04:37 <aavogt> ManateeLazyCat: it's not difficult to write. It's more or less a workaround to the fact that you can't manipulate patterns within haskell proper, or delay typechecking for a bit
20:04:38 <lambdabot> forall a. a -> Maybe a -> a
20:05:14 <ManateeLazyCat> aavogt: Yep, that's why i want to use TH instead check manually.
20:06:46 <aavogt> otherwise you could do something in haskell like:       foldl (<*>) (pure Constr) . mapM fromDynamic . take (getArityOf Constr {- probably available from Data.Data? -})
20:06:57 <Sgeo_> What would Erlang-style concurrency be called, exactly?
20:07:14 <Jafet> Erlang-style concurrency.
20:07:19 <aavogt> but you can't because mapM fromDynamic produces a list of values with all the same type
20:07:25 <Jafet> It is based on the actor model, mostly
20:07:26 <gwern> shared-nothing concurrency?
20:07:39 <gwern> as opposed to what we get with hasklel, shared-memory concurrency
20:07:48 <kmc> i had a lot of fun with this Haskell exercise: implement IORef using forkIO and Chan
20:07:52 <aavogt> kindergarten taught me haskell concurrency
20:08:31 <kmc> concurrent Haskell with Chan but no MVar/TVar/etc might be called "erlang-style"
20:08:38 <kmc> minus the actually distributed implementation
20:08:56 <aavogt> ManateeLazyCat: does it make sense to have two separate data types though? (one for tagging stuff and another to actually hold the values...)
20:09:02 <blackh> Isn't it referred to as "message-based concurrency"?
20:09:12 <gwern> kmc: I think the implementation is kind of important
20:09:36 <Jafet> Erlang does have message passing, and it's imperative
20:09:41 <ManateeLazyCat> aavogt: But TTag and T not i want.
20:09:44 <ManateeLazyCat> aavogt: Sorry.
20:09:57 <kmc> Haskell also has imperative message passing
20:10:02 <kmc> (in GHC's implementation, anyway)
20:10:14 <gwern> hm. hlint doesn't warn about 'x && True'
20:10:33 <aavogt> ManateeLazyCat: TTag -> DaemonMember   and T -> DaemonSignalArgs, no?
20:10:40 <kmc> TA an intro CS class and you will see a lot of "if x then True else False"
20:10:51 <aavogt> same names for the same style of data types
20:10:56 <Jafet> Well, being imperative it can, like reload other modules
20:11:06 <kmc> not sure what that has to do with "imperative"
20:11:12 <aavogt> kmc: x and x or y -- seen in python
20:11:16 <kmc> haha
20:11:25 <Jafet> I'm not sure how to reload modules in a functional static typed language, at least
20:11:51 <ManateeLazyCat> aavogt: Okay i try.
20:11:59 <gwern> aavogt: the parsing of that makes my head hurt
20:12:04 <aavogt> at least, I understood them to be the same
20:12:05 <gwern> aavogt: which way does it parse?
20:12:18 <aavogt> gwern: (x and x) or y
20:12:27 <gwern> huh
20:12:32 <kmc> * binds tighter than +
20:12:37 <Axman6> XX+Y
20:12:38 <SamB_XP> aavogt: okay, that's pretty useless ...
20:12:46 <Jafet> Maybe it's not commutative in python
20:12:49 <gwern> nope. hlint doesn't catch x && x either
20:12:51 <Jafet> I wouldn't be surprised
20:12:57 <kmc> i do sometimes write "if a then b else False"
20:13:01 <kmc> i think it can be clearer than a && b
20:13:10 <aavogt> no, it's not commutative
20:13:17 <aavogt> > True && undefined
20:13:18 <lambdabot>   * Exception: Prelude.undefined
20:13:25 <gwern> good ol short-cutting?
20:13:27 <aavogt> > True || undefined
20:13:29 <lambdabot>   True
20:13:34 <aavogt> >  undefined || True
20:13:34 <lambdabot>   * Exception: Prelude.undefined
20:13:46 <aavogt> no unamb here
20:14:28 <gwern> one day, when we're trapped & surrounded by encroaching lava, we'll suddenly look up, and there conal will be, dangling from an unamb, there to save the day
20:14:33 <Jafet> @src (||)
20:14:33 <lambdabot> True  || _ =  True
20:14:33 <lambdabot> False || x =  x
20:14:44 <SamB_XP> gwern: lava's not THAT bad!
20:14:56 * Sgeo_ read that as Java
20:15:13 <gwern> SamB_XP: my watch isn't rated for a depth more than 20 feet for lava-resistance
20:15:24 * twink remembers the section in Mitchell on parallel or and full abstraction for PCF.
20:16:13 <SamB_XP> I was given to understand that Lava was actualy a quite nice way to express circuits, if not given to the same type-level hijinx as VHDL...
20:16:43 <aavogt> SamB_XP: the use being that    x and y or z  behaves like   if x then y else z, when y isn't some value that is implicitly False
20:17:12 <gwern> some of these hits are interesting
20:17:13 <gwern>         (if b == Just True && length constrs > 1 && not (and noargs) then
20:17:25 <gwern> matches my 'True &&' string, alright
20:17:58 <aavogt> that's asking for case
20:18:12 <gwern> now, the question is, what the hell files are defining 'True && True = True'? if it isn't a Prelude compiler file, words will be had
20:18:33 <Axman6> heh
20:18:56 * gwern is unsure, though, about '    Third x1 == Third y1 = x1 == y1 && True
20:19:02 <aavogt> gwern: for some other values of True?
20:19:10 <aavogt> gwern: is that in derive?
20:19:16 <gwern> aavogt: I dunno
20:19:34 <applicative> Vanadium, randomWord = fst <$> ( pickRandom  <$> newStdGen <*> (L.lines <$> L.readFile "/usr/share/dict/words") )
20:20:06 <gwern> I need better find scripts
20:20:19 <gwern> 'find . -name "*.hs" -exec grep "&& True" {} \; -exec echo {} \;' isn't too great
20:20:26 <aavogt> gwern: well in any case, derive can infer instances only if you write stuff redundantly like that
20:20:40 <aavogt> so that it sees a base case or something
20:21:10 * Sgeo_  eews at the idea of programmers being forced to add redundant stuff
20:21:20 <Sgeo_> Just to satisfy the whims of some tool
20:21:34 <SamB_XP> Sgeo_: it's not just that
20:21:35 <gwern> what a tool that tool is
20:21:39 <aavogt> Sgeo_: the tool is quite amazing when it works
20:21:42 <SamB_XP> the tool NEEDS to know
20:21:51 <goomba> some tool? those developers have names
20:22:06 <aavogt> @hackage derive
20:22:07 <lambdabot> http://hackage.haskell.org/package/derive
20:22:07 <SamB_XP> or it can't GUESS what to do to save you from writing a *great deal* of redundant code
20:22:23 <SamB_XP> goomba: we're talking about ndm's baby, actually
20:22:34 <aavogt> preflex: seen ndm
20:22:34 <preflex>  ndm was last seen on #haskell 334 days, 17 hours, 3 minutes and 53 seconds ago, saying: plus with current compiler technology, it would be slower
20:22:46 <SamB_XP> wow, that's a long time ago!
20:22:55 <gwern> ever sine ndm got a real job, he's been too cool to hang out with us anymore
20:23:07 <monochrom> too overworked
20:23:08 <Axman6> pfft
20:23:09 <gwern> I say we strike him off the club roster. we'll need a new first tiger, of course
20:23:11 <SamB_XP> I think the applicable term is "busy"
20:23:30 <monochrom> in the Roman Empire, slaves are not allowed to IRC
20:23:53 <SamB_XP> monochrom: but that's okay, because their C programs can't terminate successfully anyways
20:24:05 <gwern> monochrom: wait, it's back? WHY DON'T PEOPLE TELL ME THESE THINGS
20:24:33 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24775#a24775 <-- I am pleasantly surprised that it seems no one is abusing && True
20:24:35 * ManateeLazyCat pasted "Test.hss" at http://paste2.org/get/764093
20:24:36 <ManateeLazyCat> aavogt: I wrote above code in Test.hs, but report "Not in scope: data constructor `DaemonMember' ?
20:24:52 <ManateeLazyCat> aavogt: It's in Manatee.DBus
20:25:00 <Sgeo_> True && True = True ?
20:25:00 <aavogt> ManateeLazyCat: note the double ''
20:25:01 <ManateeLazyCat> aavogt: And i have import it.
20:25:16 <aavogt> ''TypeName   'ConstructorName
20:26:44 * ManateeLazyCat pasted "Error" at http://paste2.org/get/764094
20:26:45 <ManateeLazyCat> aavogt: Ok, but got new error.
20:26:49 <applicative> If I have ghc 6.10 do I have LANGUAGE ViewPatterns ?
20:27:07 <aavogt> applicative: ghc --supported-languages ?
20:27:08 <Axman6> i believe so
20:27:17 <applicative> thanks
20:27:43 <aavogt> ManateeLazyCat: right, that TH is for an expression, not for a function declaration
20:27:50 <applicative> I do
20:27:57 <aavogt> you can work around it with    functionName = $( ... )
20:28:39 <aavogt> alternatively mess around with the function generating the TH to put that Exp in some constructor part of Dec
20:29:48 <ManateeLazyCat> aavogt: I'm confuse.
20:30:03 <ManateeLazyCat> aavogt: I can't understand TH syntax.
20:30:31 <applicative> hpaste is getting rid of blank lines?
20:30:44 <ManateeLazyCat> aavogt: Can you write that for me, then i can study it how to work.
20:31:04 <applicative> everything is shrinking on hpaste
20:31:13 <kamatsu> i feel like making a language, PHB, where an interface is called a "paradigm" and inheritance is called "enhancing" and a concurrent channel is called "synergy"
20:31:32 <aavogt> haha
20:31:42 <applicative> kamatsu, you'll go far.
20:31:52 <Jafet> @remember kamatsu i feel like making a language, PHB, where an interface is called a "paradigm" and inheritance is called "enhancing" and a concurrent channel is called "synergy"
20:31:52 <lambdabot> It is forever etched in my memory.
20:32:10 <ManateeLazyCat> aavogt: I know nothing about TH, that's why i ask here. :)
20:32:27 <ManateeLazyCat> aavogt: TH lack documentation.
20:32:34 <aavogt> no it doesn't
20:32:49 <ManateeLazyCat> aavogt: Link?
20:32:55 <applicative> kamatsu, i guess it's too late to throw in something about 'enterprise'
20:33:08 <kamatsu> hmm
20:33:25 <kamatsu> also needs "cutting-edge"
20:33:32 <applicative> bleeding
20:33:32 <aavogt> ManateeLazyCat: http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html is probably enough, and the library reference, and those papers linked
20:33:43 <kamatsu> applicative: both! maybe they're scope declarations
20:34:10 <applicative> i see, key  words strewn about
20:35:11 <applicative> enterprise Functor Maybe cuttingedge fmap f (Just x) =  ....
20:35:17 <Sgeo_> Um, help? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24776#a24776
20:35:25 <kamatsu> lol
20:35:45 <Sgeo_> I installed the older Platform a while ago, recently installed the newer one
20:35:50 <kmc> @quote enterprisevariant
20:35:51 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
20:36:02 <ManateeLazyCat> aavogt: Thanks.
20:36:05 <kamatsu> applicative: I was thinking more:
20:36:13 <ManateeLazyCat> aavogt: But looks just few examples. :)
20:36:15 <Axman6> applicative: s/fmap/GenericFunctorFunctionApplicationMethod/
20:36:17 <Jafet> applicative, a business enterprise should not dally around with maybes
20:36:22 <Sgeo_> Hm, actually, I still do have it installed
20:36:25 <kmc> there's a way to make TH print out the actual code it's generating
20:36:27 <kmc> that can be useful
20:36:31 <kamatsu> Maybe enhances paradigm Functor, going forward:
20:36:37 <Saizan> Sgeo_: though the new platform should come with the new cabal
20:36:46 <kamatsu>    cutting-edge fmap f (Just x) = ...
20:36:48 <Sgeo_> Hm
20:36:56 <Saizan> Sgeo_: maybe it's a Path issue, so the old cabal is shadowing the new one
20:37:08 <Saizan> Sgeo_: but i don't know how the windows platform installer works
20:37:37 * Axman6 pouts that fmap isn't an enterprise enabled name
20:37:42 <kamatsu> hmm
20:37:52 <kamatsu> ah:
20:37:54 <kamatsu> Maybe enhances paradigm Functor, going forward:
20:37:55 <wolgo> in a main = do blah section if I have a rleText <- readFile blah, the <- is indicative of an IO action being retrieved from the IO function that I have on the right of that operator
20:37:58 <kamatsu>    cutting-edge strategy f (Just x) = ...
20:37:59 <wolgo> right?
20:38:04 <elly> kamatsu: augh.
20:38:11 <Sgeo_> An old cabal [and nothing else] is in my path before the new platform
20:38:15 <ManateeLazyCat> kmc: TH can generate actucal code?
20:38:16 <Sgeo_> So I'll just update Cabal
20:38:38 <Axman6> kamatsu: still not enterprisised!
20:38:40 <kamatsu> wolgo: er, not really
20:38:42 <aavogt> it does generate actual code
20:38:47 <kmc> ManateeLazyCat, that's most of what it does
20:38:51 <kmc> but you can print the code as concrete syntax
20:38:56 <kamatsu> wolgo: readFile is a function that takes  an argument and returns an IO action
20:39:00 <aavogt>  -ddump-splices is incredibly useful
20:39:03 <kamatsu> wolgo: think of <-  as a way to "
20:39:04 <Sgeo_> cabal: "'cabal-install" is not valid syntax for a package name or package
20:39:04 <Sgeo_> dependency.
20:39:04 <kmc> ooh
20:39:06 <aavogt> if you have no idea what's going on
20:39:07 <kamatsu> "run" the io action
20:39:16 <arw> one could just rename maybe with an isomorphism. Enterprise x = YesSirHereIsYour x | YouAreSoFired
20:39:21 <wolgo> okay the value of the IO action that was reitrieved
20:39:25 <aavogt> especially if somebody else wrote the TH
20:39:27 <aavogt> ;)
20:39:27 <kamatsu> arw: awesome
20:39:38 <wolgo> <- assigns the value that was the result of the IO action
20:39:43 <wolgo> err, no
20:40:07 <applicative> arw, excellent, we can even keep Haskell
20:40:08 <kamatsu> wolgo: yes, that's  about right
20:40:11 <wolgo> <- says "Hi, please go do your job" to readFile or whatever IO function I have called yeah?
20:40:31 <kamatsu> IO function is not a valid word
20:40:42 <kamatsu> readFile is a function that takes a path and returns an IO action
20:40:45 <aavogt> how not?
20:40:54 <Axman6> public static data MightHaveValueObject objectType = HasValueObjectConstructor objectType | NoValueObjectConstructor
20:40:57 <kmc> "IO function" might be a shortcut for "function returning an IO action"
20:40:59 <kamatsu> aavogt: i mean that it has no well-defined meaning
20:41:03 <kmc> but those aren't special
20:41:11 <kamatsu> Axman6: that's Java, not Pointy Haired Boss
20:41:12 <kmc> they are ordinary pure side-effect-free functions
20:41:19 <aavogt> > words "readFile is a function that takes a path and returns an IO action" `union` words "IO function"
20:41:20 <lambdabot>   ["readFile","is","a","function","that","takes","a","path","and","returns","...
20:41:30 <aavogt> > words "readFile is a function that takes a path and returns an IO action" `intersection` words "IO function"
20:41:31 <lambdabot>   Not in scope: `intersection'
20:41:37 <aavogt> > words "readFile is a function that takes a path and returns an IO action" `intersect` words "IO function"
20:41:38 <lambdabot>   ["function","IO"]
20:41:56 * ManateeLazyCat pasted "Cleaner code." at http://paste2.org/get/764105
20:41:56 <ManateeLazyCat> aavogt: After clean work, i got above code, but i still need check `packDaemonSignalArgs` and `unpackDaemonSignalArgs`, looks TH is only way to save me from trouble.
20:42:07 <Jafet> You want to design an enterprise haskell?
20:42:09 <aavogt> hmm?
20:42:13 <wolgo> okay
20:42:17 <kamatsu> Jafet: I want to design a pointy-haired boss haskell
20:42:19 <wolgo> now that I can readFiles
20:42:21 <Axman6> Jafet: sure do
20:42:25 <kamatsu> Jafet: so, "paradigms", "synergy", "enhancing" etc.
20:42:26 <wolgo> I should be able to make a hangman
20:42:32 <aavogt> ManateeLazyCat: exercise for the reader?
20:42:34 <wolgo> /usr/share/dict!
20:42:42 <Jafet> > filter ((>=8).length) words "readFile is a function that takes a path and returns an IO action"
20:42:43 <lambdabot>   Couldn't match expected type `[[a]]'
20:42:43 <lambdabot>         against inferred type `GHC.Bas...
20:42:44 <kamatsu> wolgo: yup
20:42:47 <Jafet> > filter ((>=8).length) $ words "readFile is a function that takes a path and returns an IO action"
20:42:48 <lambdabot>   ["readFile","function"]
20:42:58 <Jafet> To start with
20:42:59 <ManateeLazyCat> aavogt: ?
20:43:17 <aavogt> you know that the unpackDyn produces expressions that are exactly like your unpackDaemonSignalArgs'
20:43:39 <applicative> in other words, the readFile of a path, is the action that returns the string that is its content, as the square of a number is its product with itself
20:43:52 <ManateeLazyCat> aavogt: I compile failed, but i try to learn TH now.
20:44:05 <ManateeLazyCat> aavogt: Otherwise check those type by hand is painful.
20:44:24 <applicative> more painful than TH?
20:44:33 <kmc> ManateeLazyCat, if m is a Q monad action, you can see the output concrete syntax with:   ppr <$> runQ m
20:44:34 <kmc> in GHCi
20:44:49 * aavogt would suggest that gfoldl could be appropriate for packDaemonSignalArgs, but I don't understand it's type
20:44:51 <kmc> GHCi> ppr <$> runQ [| 2 + 3 |]
20:44:52 <ManateeLazyCat> kmc: I know nothing about TH.
20:44:54 <ManateeLazyCat> :)
20:44:54 <kmc> 2 GHC.Num.+ 3
20:45:13 <aavogt> runQ is for the weak
20:45:16 <kmc> ManateeLazyCat, well, do you know what it does?
20:45:18 <Axman6> , [$ty|ppr|]
20:45:21 <aavogt> it doesn't let you play with reify et. al
20:45:28 <ManateeLazyCat> aavogt: Yep, because `packDaemonSignalArgs` just use `toVariant` wrap every element in list.
20:45:43 <applicative> wolgo, did they manage to answer your question?
20:45:54 <ManateeLazyCat> kmc: I want use TH generate above function automatically.
20:45:55 <wolgo> applicative: yes
20:46:08 <aavogt> right, so think about how regular the haskell syntax in the case expression is
20:46:13 <wolgo> I am dedicating 120 days to haskell if I can make hangman before 9:30PM PST
20:46:36 <ManateeLazyCat> kmc: I want TH scan `DaemonMember` and `DaemonSignalArgs`, then generate function `checkDaemonSignalArgs`, `packDaemonSignalArgs` `unpackDaemonSignalArgs` automatically.
20:46:36 <Axman6> IO is a bad place to start when using haskell
20:47:00 <Jafet> Can Haskell run on an old time sharing system?
20:47:12 <kmc> UNIX is an old time sharing system
20:47:12 <applicative> I cant get Vanadium's hangman to work, it keeps thinking the word it picked is "A".
20:47:13 <kmc> so yes :)
20:47:15 <Jafet> Seems to be how wolgo's brain works
20:47:31 <monochrom> linux is likely 30 years old
20:47:41 <ManateeLazyCat> aavogt: Variant is low-level type for DBus message.
20:47:43 <SamB_XP> monochrom: what ?
20:47:48 <SamB_XP> it's gone through a timewarp?
20:47:49 <Axman6> and long pass its prime
20:47:50 <Axman6> >_>
20:47:54 <SamB_XP> 'cause I thought it was from 1990
20:47:59 <SamB_XP> not 1980
20:48:02 <kmc> 1991 says the all-knowing wikipedia
20:48:05 <ManateeLazyCat> aavogt: So `fromVariant` convert any type to Variant (if you have instance it)
20:48:09 <monochrom> then 20 years
20:48:15 <kmc> GNU is older
20:48:16 <Jafet> Leeet's dooo the Tiiime Waaarp agaaiiin
20:48:17 <applicative> monochrom is advancing the 'Torvalds stole it' theory
20:48:21 <monochrom> there is a reason I added "likely"
20:48:25 <kmc> many parts of GNU/Linux are older than Linux
20:48:37 <SamB_XP> yeah ... the BSD!
20:48:38 <aavogt> it's exactly Data.Dynamic, ManateeLazyCat
20:48:52 <aavogt> > GNU / Linux
20:48:53 <lambdabot>   Not in scope: data constructor `GNU'Not in scope: data constructor `Linux'
20:49:10 <applicative> > Linus Torvalds
20:49:11 <lambdabot>   Not in scope: data constructor `Linus'Not in scope: data constructor `Torva...
20:49:29 <ManateeLazyCat> aavogt: Yep, but i need use `dbus-core` API.
20:49:47 <monochrom> "old time-sharing system" probably does not refer to just an OS, but a complete OS plus hardware plus terminals plus users plus electricity plus the lab cat.
20:50:03 <ManateeLazyCat> preflex @hackage dbus-core
20:50:11 <SamB_XP> monochrom: my Linuxen did not come with any cats :-(
20:50:13 <ManateeLazyCat> @hackage dbus-core
20:50:14 <lambdabot> http://hackage.haskell.org/package/dbus-core
20:50:22 <ManateeLazyCat> @hackage dbus-client
20:50:22 <lambdabot> http://hackage.haskell.org/package/dbus-client
20:50:23 <monochrom> the cat comes with the lab, not the OS
20:50:30 * SamB_XP supposes they didn't figure out how to fit them on the CDs
20:50:33 <monochrom> not even the hardware
20:50:34 <ManateeLazyCat> aavogt: I need above two package.
20:50:47 <Jafet> Doesn't the lab come with the hardware
20:50:50 <Jafet> Cheapskates
20:50:50 <ManateeLazyCat> aavogt: That do DBus interface for Haskell.
20:50:55 <monochrom> similarly the stupid users don't come with the OS
20:53:36 <wolgo> IO is a bad place to start with haskell? Why, that is what presents users with data isnt it?
20:54:03 <aavogt> it's a euphemism for haskellis a bad place to start
20:54:10 <shapr> ?
20:54:19 <winxordie> wolgo: I'd think monads are a bad place to start
20:54:23 <pastorn> wolgo: yeah, but no real computations are being done in IO
20:55:09 <Jafet> winxordie, Monad, monad, or monads?
20:55:35 <pastorn> wolgo: see IO as a door between the pure inner workings of haskell and the naughtyness on the outside of haskell
20:55:41 <aavogt> shapr: in that you have to learn how to use IO, and how to do useful computations before you can write useful interactive programs
20:55:44 <ManateeLazyCat> wolgo: You just need IO when you want communications with outside, that's mean you just need IO in that *point*, and most Haskell code keep pure.
20:55:51 * shapr shrugs
20:55:59 <winxordie> Jafet: Monda ;)
20:56:02 <winxordie> *Monad
20:56:02 <aavogt> so unless you have some other background, it's a lot to learn
20:56:03 <winxordie> gah.
20:56:06 <wolgo> all I need is to open a file and read a random string
20:56:12 <winxordie> although Monda would be cool too
20:56:15 <Jafet> class Gonad
20:56:21 <wolgo> so I only need the impure and evil IO monad
20:56:24 <winxordie> heh.
20:56:24 <wolgo> lol
20:56:30 <wolgo> or readFile
20:56:32 <pastorn> IO is a gateway monad to heavier monads, like Maybe, State, STM and ContT
20:56:32 <wolgo> and <-
20:56:47 <wolgo> well I will worry about all that monad business later
20:56:52 <ManateeLazyCat> aavogt: If $(unpackDyn ''DaemonMember ''DaemonSignalArgs) successful, where i can find code that generate by TH?
20:56:54 <applicative> wolgo, what are you going to do with the file contents?
20:56:59 <winxordie> wolgo: I personally <3 STmonad
20:57:09 <wolgo> 5 hours of ruby was condensed to 5 minutes of haskell without me even knowing haskell
20:57:21 <wolgo> so to say I am irritated is an understatement
20:57:32 <wolgo> I wasted more than 50% of my work day with ruby fail
20:57:34 <aavogt> ManateeLazyCat: you see here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24770#a24774
20:57:34 <wolgo> anyhow
20:58:00 <pastorn> wolgo: when i started doing haskell all i did was just test out my functions in GHCi
20:58:00 <wolgo> applicative: read a random line then take the word from that line and use is as the answer
20:58:10 <aavogt> you can get the code by running the actual splice while ghci has the -ddump-splices flag set
20:58:24 <wolgo> I have four files of my own implementation of the stdlibrary functions like foldr and map
20:58:25 <pastorn> wolgo: a random line from a file?
20:58:26 <aavogt> (with :set -ddump-splices or passed when you load it)
20:58:31 <wolgo> pastorn: yes
20:58:51 <pastorn> wolgo: don't do random just yet... you won't like it :p
20:58:56 <wolgo> pastorn: making hangman I am
20:58:58 <aavogt> is foldr terribly useful in an eager language?
20:59:28 <kmc> seems like it matters less whether you use foldl or foldr
20:59:44 <kmc> OCaml has both
20:59:45 <applicative> fst <$> ( pickRandom  <$> newStdGen <*> (lines <$> readFile "/usr/share/dict/words")
21:00:26 <ManateeLazyCat> aavogt: Thanks, the only thing i need to do is: Learn TH. :)
21:00:43 <applicative> wolgo, something like that.
21:00:43 <aavogt> does that actually work?
21:00:51 <pastorn> wolgo: writing that for you now :)
21:00:55 <Axman6> :t pickRandom
21:00:56 <lambdabot> Not in scope: `pickRandom'
21:00:58 <applicative> i'm presupposing  an ugly definition of pickRandom
21:01:00 <Axman6> :(
21:01:14 <applicative> I was referring to Vanadiums hangman.
21:01:25 <ManateeLazyCat> aavogt: So i just can see code by ghci?
21:01:33 <applicative> I'm applicativizing that too though.
21:01:39 <ManateeLazyCat> aavogt: Haven't any *.hs file that generate by TH?
21:02:10 <aavogt> I'm not aware of people using TH as a standalone preprocessor
21:02:53 <ManateeLazyCat> aavogt: If so, i just can check TH code with ghci.
21:03:11 <aavogt> -ddump-splices works with ghc too
21:03:45 <ManateeLazyCat> aavogt: So i can use TH generate *.hs file then compile that *.hs file by ghc?
21:04:15 * aavogt wonders if there have been any efforts to make TH a bit more separate from ghc
21:04:24 <aavogt> ManateeLazyCat: you can't do that
21:04:37 <ManateeLazyCat> aavogt: So it's hard to check TH code
21:04:40 <SamB_XP> aavogt: I don't think that's very practical
21:05:03 <pastorn> wolgo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24777
21:05:07 <ManateeLazyCat> aavogt: I was think TH should generate middle-code, then developer can check TH code.
21:05:09 <aavogt> SamB_XP: say you wanted to run TH generated code with hugs?
21:05:10 <applicative> my experience is that everything that uses TH fails when you cabal install it
21:05:28 <SamB_XP> aavogt: it the identifiers would come out wrong :-(
21:05:29 <aavogt> that's bad packaging
21:05:53 <aavogt> SamB_XP: also the pretty printing seems to be missing parentheses (though I think that got fixed)
21:06:30 <pastorn> wolgo: do you understand it?
21:06:38 <ManateeLazyCat> aavogt: In gtk2hs, we write middle-code in *.chs.pp file, then c2hs will generate *.hs file for ghc.
21:06:56 <kmc> when writing documentation, which is preferred:  "type class", "typeclass", or "type-class"?
21:07:03 <aavogt> class
21:07:04 <ManateeLazyCat> aavogt: If compile failed, we just need check *.hs will know where the problem.
21:07:14 <kmc> just "class"?
21:07:24 <aavogt> that's the keyword isn't it?
21:07:55 <aavogt> ManateeLazyCat: what does the developer need to check in the "middle-code"
21:07:57 <aavogt> ?
21:07:58 <ManateeLazyCat> applicative: What's your mean? "everything that uses TH fails when you cabal install it"
21:08:18 <aavogt> data-accessor-template is broken to cabal-install
21:08:30 <ManateeLazyCat> aavogt: Can fix it?
21:08:46 <monochrom> I found that "typeclass" is the most popular
21:09:06 <Saizan> monochrom: you can add some --constraint= to make it build.
21:09:14 <Saizan> err, ManateeLazyCat ^^
21:09:20 <aavogt> http://www.googlefight.com/index.php?lang=en_GB&word1=typeclass&word2=class
21:09:26 <monochrom> yeah I was wondering what I was building
21:10:06 <ManateeLazyCat> aavogt: Example, you write "$(unpackDyn ''DaemonMember ''DaemonSignalArgs)" to generate code for functoin `unpackDaemonSignalArgs', you can see it's code, TH just tell ghc, right?
21:10:35 <aavogt> ManateeLazyCat: there are two common places to put $( splices )
21:10:47 <aavogt> either in expressions, or at top-level
21:10:48 <monochrom> unfortunately, the haskell98 report uses "type classes" and "classes"
21:11:22 <ManateeLazyCat> s/can/can't see code.
21:11:23 <aavogt> with differing types for what's inside the parens
21:11:25 <monochrom> I suppose I'll go against the flow and go with the manual.
21:11:52 <aavogt> ManateeLazyCat: if you want to see the generated code, load the code that runs the splice with -ddump-splices
21:12:07 <aavogt> as has been said a couple times before
21:12:42 <aavogt> but if everything has the right type signature, and you thought about what you're doing when writing the TH, that isn't necessary
21:12:44 <ManateeLazyCat> aavogt: Thanks, i see.
21:13:11 <pastorn> wolgo: look at my code? do it or i'll cry!
21:13:36 <ManateeLazyCat> aavogt: I just want to know how to check generate code if i do mistake.
21:13:38 <monochrom> @djinn cry -> Either read cry
21:13:38 <lambdabot> f = Right
21:13:46 <monochrom> It says you should just cry.
21:14:00 <pastorn> @djinn Maybe cry
21:14:01 <lambdabot> f = Nothing
21:14:03 <pastorn> hah!
21:14:51 <pastorn> how do i encode the gödel incompleteness thingy in haskells typesystem to make djinn go ka-bloweh?
21:15:33 <aavogt> ManateeLazyCat: the generated code is typechecked
21:16:07 <aavogt> that should be more than enough assurance ;)
21:16:28 <winxordie> pastorn: You don't have to encode Godel incompleteness; it's built-in to most axiomatic systems. XD
21:16:50 <pastorn> how do i feed it to djinn?
21:17:04 <monochrom> djinn type system is not expressive enough
21:17:36 <pastorn> oh, what do i need?
21:17:42 <monochrom> you can't even have peano numbers and lists in djinn
21:18:01 <aavogt> "you get what you pay for"
21:18:17 <pastorn> haha
21:18:20 <monochrom> you need recursive data types. djinn lacks exactly that.
21:19:12 <aavogt> @djinn Mu ()
21:19:12 <lambdabot> Error: Undefined type Mu
21:19:25 <wolgo> pastorn:
21:19:31 <wolgo> I think I understand
21:19:49 <wolgo> FilePath is a typeclass or a datatype that is a string
21:20:16 <pastorn> FilePath is an alias for String
21:20:25 <pastorn> wolgo: in GHCi: ":i FilePath"
21:20:57 <pastorn> wolgo: :t is for functions and values, :i is for types and classes, and foreverything else there's :k
21:22:48 <wolgo> takeRandomLine takes a path argument and returns an IO string. fp is just the argument and it is a path, file contains the content of whatever fp is. let rows = lines file is a pure action being bound to rows, lineCount is a variable that contains the length of the rows list. randomRowNum <-(value from randomRIO) (random from range) not sure what return does other than express the randomRowNum'th cell of rows
21:22:55 <wolgo> is that right?
21:23:04 <wolgo> that seems pretty simple for takeRandomLine
21:23:15 <wolgo> I do not know that <$> is
21:23:21 <wolgo> that -> what
21:23:30 <wolgo> wait
21:23:37 <wolgo> that applies lines to readFile
21:23:40 <pastorn> wolgo: make sense
21:23:43 <wolgo> wait a minute
21:23:51 <wolgo> lines is not :t IO
21:23:58 <wolgo> why does readFile work
21:23:58 <pastorn> no
21:24:02 <wolgo> brb checking type
21:25:48 <wolgo> :t <$>
21:25:48 <pastorn> wolgo: if it's an IO type i get the value with "val <- myIOFun" if it's non-IO i get it by "let val = myPureFun"
21:25:49 <lambdabot> parse error on input `<$>'
21:25:52 <wolgo> forgot about that
21:26:07 <pastorn> wolgo: do not mess with <$> when you're starting out with haskell
21:26:24 <wolgo> what is it though
21:26:30 <applicative> curses, I can't applicativize pastorns definition, need 'join'
21:26:31 <pastorn> it's map
21:26:33 <Cale> <$> is another name for fmap
21:26:33 <wolgo> is it application for IO actions?
21:26:37 <wolgo> oh ok
21:27:17 <Cale> and fmap is a generalisation of map to types other than just lists
21:27:19 <applicative> wolgo, if readFile "a.txt" returns a string, then  head <$> readFile "a.txt"   returns the first character
21:27:24 <applicative> it couldn't be simpler
21:27:32 <applicative> don't let them make you use do notation
21:27:58 <applicative> (I'm just being eponymous, of course)
21:28:00 <pastorn> applicative: haha
21:28:02 <wolgo> well
21:28:09 <wolgo> then it is like $
21:28:13 <wolgo> but for IO
21:28:22 <wolgo> okay
21:28:26 <wolgo> well this code is pretty simple
21:28:42 <applicative> well, for any suitable pile of constructors, IO, Maybe, etc.
21:28:49 <wolgo> simpler than anything else I have read actually
21:28:55 <wolgo> more simple rather
21:29:03 <Jafet> Screw IO
21:29:09 <Jafet> @let hangman=let u=toUpper;c s t f []=map(\x->if elem x (map u t) then x else '_')s++"  "++take(length f)(map succ"=,{n,,{")++if length f>6 then map pred"!)hbnf!pwfs*"else"";c s t f (g:r)=if elem (u g) s then c s(g:t)f r else c s t(g:f)r;in c(map succ"G@MFL@M")[][]
21:29:11 <lambdabot>  Defined.
21:29:11 <ManateeLazyCat> aavogt: I see. TH will save me much time.
21:29:24 <Jafet> > hangman "asdfghjkl"
21:29:25 <pastorn> wolgo: people have a tendency to over-complicate haskell
21:29:26 <lambdabot>   "HA_G_A_  >-|o--"
21:29:45 <ManateeLazyCat> aavogt: Are you TH expert? :)
21:30:25 <ManateeLazyCat> http://www.googlefight.com/index.php?lang=en_GB&word1=emacs&word2=vim
21:30:26 <ManateeLazyCat> funny
21:30:50 <pastorn> yay!
21:31:03 <ManateeLazyCat> http://www.googlefight.com/index.php?lang=en_GB&word1=haskell&word2=elisp
21:31:22 <ManateeLazyCat> I want change above! :)
21:31:22 <wolgo> okay
21:31:28 <wolgo> I am going to make hangman
21:31:33 <wolgo> stop quizzing me
21:31:44 <ManateeLazyCat> :)
21:32:30 <ManateeLazyCat> If you want a Haskell Application OS, what's the name you like?
21:32:56 * shapr snickers
21:33:08 * SamB_XP laughs harder than that. out loud.
21:33:13 <ManateeLazyCat> Perhaps i will use your name for my project.
21:33:27 * shapr &
21:33:30 <ManateeLazyCat> I current use "Manatee"
21:33:48 <aavogt> ManateeLazyCat: I know enough for your problem
21:34:02 <ManateeLazyCat> But it's maybe a bad name, because when user use Google search "Manatee", it will got many information about real Manatee.
21:34:15 <pastorn> ManateeLazyCat: CurryCore
21:34:26 <pastorn> :)
21:34:30 <ManateeLazyCat> pastorn: Why?
21:34:34 <pastorn> dunno
21:34:38 <pastorn> sounds nice
21:34:48 <ManateeLazyCat> More names?
21:35:00 <ManateeLazyCat> "Manatee" is for my girlfriend.
21:35:04 <pastorn> "Pure"
21:35:13 <applicative> "Sensible
21:35:16 <ManateeLazyCat> pastorn: I want a name that Google can't search.
21:35:27 <pastorn> "Pure Curry"
21:35:35 <Jafet> You could take over "Vindaloo"
21:35:43 <ManateeLazyCat> pastorn: If people search that name, google will return my project, oh, yeap, that's a Haskell Application OS.
21:35:47 <applicative> ManateeLazyCat, you mean like "And"
21:36:08 <pastorn> a SECRET project :D
21:36:48 <ManateeLazyCat> pastorn: I will release it in this month.
21:37:22 <ManateeLazyCat> pastorn: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
21:37:27 <ManateeLazyCat> pastorn: http://farm3.static.flickr.com/2800/4448123474_3879e3f878_o.png
21:37:58 <pastorn> ManateeLazyCat: AwesomePrelude?
21:38:30 <Jonno_FTW> there's an awesome prelude now?
21:38:36 <ManateeLazyCat> pastorn: I'm now refactory code for better interface for "Application programmer".
21:38:47 <ManateeLazyCat> pastorn: I will release it when it's good enough.
21:38:54 <ManateeLazyCat> And easy to extension.
21:38:55 <pastorn> Jonno_FTW: it's for when you want to be able to do other programming languages in haskell
21:39:24 <Jonno_FTW> do?
21:39:24 <applicative> ManateeLazyCat, vim *and* emacs?  What a peace-nik
21:39:30 <ManateeLazyCat> pastorn: I will do a interface, that any problem match my interface will embedded in my project.
21:39:50 <Jafet> applicative, no, that's having also yi
21:39:58 <ManateeLazyCat> applicative: My project is replace emacs, vi, and firefox, chrome.
21:40:06 <pastorn> Jonno_FTW: yeah... think of it as using haskell to generate code in other languages
21:40:24 <pastorn> Jonno_FTW: but you get the type safety etc that you have in haskell (if you express yourself correctly)
21:40:32 <Jonno_FTW> sounds useful
21:40:43 <pastorn> ManateeLazyCat: that sounds awefully ambitious
21:41:04 <ManateeLazyCat> pastorn: Yep, that's why i call it "Application OS"
21:41:17 <SamB_XP> the WHAT now?
21:41:49 <ManateeLazyCat> pastorn: Aim is replace everything, and give user (haskeller) an uniform interface.
21:42:09 <ManateeLazyCat> SamB_XP: Editor, terminal, file-manager, web-browser.
21:42:20 <pastorn> so you're writing a window manager + tools?
21:42:26 <ManateeLazyCat> SamB_XP: I will add more extension when release.
21:42:35 <ManateeLazyCat> pastorn: No, not window manager.
21:42:39 <ManateeLazyCat> pastorn: Just application
21:42:45 <pastorn> oh, ok
21:42:51 <pastorn> extending terminals anything?
21:42:54 <applicative> pastorn, I apologize for my failed attempt at applicativizing your random line getting code bloque
21:42:57 <ManateeLazyCat> pastorn: Use GtkNotebook integrate with DBus do a multi-processes framework.
21:43:24 <pastorn> like... being able to trigger events when buttons are pressed etc.
21:43:34 <ManateeLazyCat> pastorn: Every tab is running standalone process for crash safe.
21:43:48 <pastorn> sounds cool
21:44:00 <ManateeLazyCat> pastorn: It's just framework, you can embedded any application in it.
21:44:29 <ManateeLazyCat> pastorn: If you much my API interface and Haskell FFI, i don't care your application language.
21:44:36 <pastorn> hmm... maybe Plan9 is the way to go...
21:44:55 <ManateeLazyCat> pastorn: So i want a cool name, best base on "Manatee"
21:45:07 <ManateeLazyCat> pastorn: I write this project for my GF.
21:46:16 <ManateeLazyCat> pastorn: My plan is use it like normal application (hide OS in it).
21:46:24 <pastorn> ManateeLazyCat: "Manateewlz"
21:46:34 <Jafet> Emphasize the tool
21:46:52 <aavogt> Hanatee
21:46:52 <pastorn> maybe with a dash
21:46:59 <pastorn> "mana-teewlz"
21:47:07 <ManateeLazyCat> pastorn: When it strong enough, i will drop gnome or kde (any desktop environment), you can use it when you login in.
21:47:27 <ManateeLazyCat> pastorn: Never window-manager, never anyother application.
21:47:29 <ManateeLazyCat> Just it.
21:47:40 <ManateeLazyCat> aavogt: Yep
21:47:40 <pastorn> ehm...
21:47:43 <pastorn> ok...
21:47:54 <Jafet> Fixing X will get you far.
21:47:59 <ManateeLazyCat> aavogt: I was think about that, Hanatee -- "Haskell with Manatee"
21:48:03 <Jafet> Go for a real clipboard.
21:48:23 <elly> 00:43 < pastorn> hmm... maybe Plan9 is the way to go...
21:48:27 <elly> ^ this is never the answer
21:48:32 <ManateeLazyCat> aavogt: Hanatee is listen cool?
21:48:33 <pastorn> hehe
21:48:38 <applicative> Plan Manatee
21:48:39 <pastorn> elly: i want better terminals
21:48:49 <pastorn> Planatee
21:48:49 <elly> plan 9 has the opposite of that :P
21:48:58 <pastorn> elly: nope
21:49:08 <pastorn> terminals in plan 9 are quite awesome
21:49:17 <ManateeLazyCat> aavogt: I just can write/read English, bad spoken English.
21:49:30 <pastorn> since they're a very updated version of terminals... you can put whatever you want in them, not only text
21:49:31 <elly> pastorn: odds are we will disagree about this forever, so let us not discuss it
21:49:47 <elly> ...that's not how they're actually implemented. That's just a window manager behavior.
21:50:00 <pastorn> ok... i give up
21:50:01 <applicative> pastorn, what do you put in besides text?
21:50:02 <elly> The WM can flip windows from 'text mode' to 'graphics mode', and does so for graphical programs :P
21:50:05 <ManateeLazyCat> pastorn: I plan rewrite a new temirnal in my project, because VTE library not model/view design, you can't view terminal context in different window.
21:50:08 <pastorn> you probably now more obout this than me
21:50:21 <elly> I have, in fact, written part of a window manager for plan 9
21:50:21 <aavogt> hanatee doesn't sound bad... quite feminine I think
21:50:32 <elly> I am intimately familiar with this particular part of the system, and it is kind of nasty :P
21:50:33 <ManateeLazyCat> applicative: Why "Plan Manatee" ? Can you explain?
21:51:00 * hackagebot uri 0.1.4 - Library for working with URIs  http://hackage.haskell.org/package/uri-0.1.4 (JaroslavGridin)
21:51:04 <aavogt> ManateeLazyCat: did you work out generating those pattern matches?
21:51:19 <aavogt> (with TH that is)
21:51:45 <ManateeLazyCat> aavogt: I will do that later, i'm lunch now. :)
21:52:33 <ManateeLazyCat> pastorn: I haven't seen any terminal powerful than term-mode in Emacs.
21:52:43 <ManateeLazyCat> pastorn: It's a model/view design.
21:52:52 <pastorn> ok
21:53:21 <Jafet> "火辣电脑系统"
21:53:38 <ManateeLazyCat> Jafet: 中国人
21:53:39 <ManateeLazyCat> ?
21:53:53 <Jafet> It makes a good test of your system's unicode and font support, too
21:54:17 <ManateeLazyCat> Jafet: Yep, my system support unicode good.
21:54:37 <Jafet> No use if it can't draw their glyphs.
21:54:59 <ManateeLazyCat> Jafet: My system  is base on Gtk+
21:55:19 <ManateeLazyCat> pastorn: Can you suggestions more cool name?
21:55:42 <Jafet> If you remove the gnome desktop, you're probably going to have to muck in the internals a bit
21:56:03 <ManateeLazyCat> Jafet: No, i won't
21:56:03 <pastorn> ManateeLazyCat: Mana-teewlz is the best i've got
21:56:24 <pastorn> unless i know your girlfriends name
21:56:43 <pastorn> ManateeLazyCat: ==> #haskell-blah
21:57:20 <ManateeLazyCat> Jafet: Most current desktop-environment (gnome, kde) is design for mouse, and less effective, i design a new system for geek, programmer,  engineer, for everyone that want to work efficient.
21:57:47 <elly> ManateeLazyCat: have you ever used any of: xmonad, ion, ratpoison, evilwm, awesome, dwm, wmii, larswm?
21:57:49 <ManateeLazyCat> pastorn: My GF is "Manatee", of course I'm "LazyCat". :)
21:57:52 <Jafet> Meh. If the mouse is there, work with it
21:58:08 <ManateeLazyCat> elly: I used to use xmonad, awesome
21:58:13 <lpsmith> Ok,  I'm not sure this is a wonderful idea yet;  but I'm experimenting with an idea that looks something like this:
21:58:24 <Jafet> Or any sort of cursor pointing device
21:58:24 <ManateeLazyCat> Jafet: Of course, it support mouse, but design for keyboard.
21:58:26 <Zao> ManateeLazyCat: Awesome as in the window mangager named 'awesome'?
21:58:38 <Zao> I hate that name, so ambigious.
21:58:58 <kmc> which compiler supports the extension "ExtensibleRecords"
21:59:13 <ManateeLazyCat> Zao: So better name?
21:59:21 <kmc> it's in Language.Haskell.Extension and apparently not supported by GHC
21:59:33 <wolgo>    The last statement in a 'do' construct must be an expression
21:59:33 <wolgo> Failed, modules loaded: none.
21:59:34 <Zao> ManateeLazyCat: Anything that isn't a common adjective, verb or noun.
21:59:41 <ManateeLazyCat> I'm not native English-Speaker, so i haven't idea about good name.
21:59:43 <lpsmith> data Record field = Record { foo :: field SyntaxType DataType,  bar :: field SyntaxType' DataType',  baz :: field SyntaxType'' DataType'' }
21:59:52 <c_wraith> wolgo: probably an indentation error.
22:00:05 <kmc> ah, not a compiler, it's Hugs apparently
22:00:06 <c_wraith> wolgo: unless you're trying to put an <- on the last line of a do block
22:00:09 <ManateeLazyCat> pastorn: What's mean "teewlz" ?
22:00:16 <c_wraith> wolgo: or a let, I suppose
22:00:33 <pastorn> tools = toolz = teewlz
22:00:39 <lpsmith> however,  apparently I can't derive data-accessor's for Record,  at least not with the standard hunk of template haskell
22:00:57 <lpsmith> any ideas/suggestions/critiques?
22:00:58 <ManateeLazyCat> pastorn: geek. :)
22:00:58 <danblick> If I have a function with two arguments, f :: X -> X -> Y, and I will never ever use the value (f x), would it be bad style to make this f :: (X, X) -> Y?
22:01:12 <pastorn> ManateeLazyCat: i'm not the one writing my own os...
22:01:27 <c_wraith> danblick: why would you want to?
22:01:27 <lpsmith> ManateeLazyCat, what window manager do you use now?
22:01:29 <Jafet> I'm not exactly sure if it's a good idea to name a system after a girlfriend. The last time someone did that we got debian
22:01:50 <c_wraith> danblick: constructing a tuple is more runtime work than just passing multiple args
22:02:12 <ManateeLazyCat> lpsmith: I use KDE window manager for test transparent feature.
22:02:46 <ManateeLazyCat> lpsmith: After release, i will drop Emacs, and return to Gnome for test compatible
22:02:51 <aavogt> c_wraith: hmm, it's the other way around in ML implementations apparently
22:03:07 <ManateeLazyCat> pastorn: How about Hanatee? compare with Emacs, which cool?
22:03:15 <danblick> c_wraith: thanks, ok.  i guess f :: X -> X -> Y seems nicer, and i wondered if i was paying something for it
22:03:19 <ManateeLazyCat> pastorn: I mean sound cool.
22:03:30 <c_wraith> aavogt:  It's probably actually the same with decent optimization.
22:03:38 <ManateeLazyCat> pastorn: I don't like name have "-".
22:04:00 <aavogt> probably
22:04:16 * ManateeLazyCat Hanatee is good name, just 1,850 result in Google :)
22:04:53 <Jafet> manatee, I think you're confused.
22:05:06 <Jafet> Usually, the name does not make the thing. The thing makes the name.
22:05:06 <ManateeLazyCat> I found Gtk+ application is running slow in KDE.
22:05:31 <ManateeLazyCat> Jafet: So named "HaskellApplicationOS" ?
22:05:46 <lpsmith> ManateeLazyCat, Hanatee makes me think of Hanford,  one of the most polluted sites on the planet.
22:05:57 <Jafet> It doesn't matter if google shoots a million results at you for your favourite word, because you know your site will eventually be on the first page of them.
22:06:09 <aavogt> get writing the program and wait for shapr to come up with a catchy name
22:06:56 <Jafet> The developers of Gnome evidently weren't worried that people might not find them through google
22:07:01 <ManateeLazyCat> aavogt: Who is shapr?
22:07:07 <Jafet> Or whatever the search engine was at the time
22:07:24 <ManateeLazyCat> Jafet: So can you suggestion with a name?
22:07:36 <aavogt> @get-shapr
22:07:36 <lambdabot> shapr!!
22:07:52 <ManateeLazyCat> preflex @seen shapr
22:07:53 <preflex>  shapr was last seen on #haskell 34 minutes and 25 seconds ago, saying: * shapr &
22:07:53 <Jafet> I already have. It's also in a more widely spoken language
22:09:31 <ManateeLazyCat> Okay, I need write my code now, i will listen user's name suggestion after it release.
22:09:56 <lpsmith> case in point that choosing a googlable name isn't neccessarily a good thing:  I can never remember what Debian decided to change the name of "cdrecord" to
22:10:23 <ManateeLazyCat> CD record?
22:10:34 <SamB_XP> wodim?
22:10:43 <lpsmith> no,  wodim,  I had to google "debian cdrecord" to find out
22:10:54 <lpsmith> I mean,  seriously WTF?
22:11:23 <SamB_XP> lpsmith: what do you mean, "no, wodim" -- I just SAID that!
22:11:44 <ManateeLazyCat> Bye, all. :)
22:12:07 <wolgo> I changed pickRandomLine to filter out the ' character
22:12:13 <wolgo> there are a lot of words in import System.Random
22:12:14 <wolgo> import Data.List
22:12:14 <wolgo> import Data.Char
22:12:14 <wolgo> import System.IO
22:12:19 <wolgo> jesus
22:12:20 <Jafet> (When's he going to write his own IRC client?)
22:12:22 <wolgo> sorry
22:12:23 <lpsmith> SamB_XP, sorry, I was typing that in response to ManateeLazyCat :)
22:12:30 <m3ga> lpsmith: it was legitimatley a for of the cdrecord project. see http://lwn.net/Articles/198171/
22:12:58 <m3ga> s/a for/a fork/
22:12:59 <wolgo> I meant /usr/share/dict/american-english
22:13:11 <lpsmith> m3ga, I'm not complaining about the fork,  I'm complaining about the name :)
22:13:47 <m3ga> lots of things have silly names. you can't blame debian for that :-)
22:14:35 <SamB_XP> but debian named it!
22:14:39 <SamB_XP> it's THEIR fork
22:15:25 <SamB_XP> (though they did have a fairly good reason for forking, I'm not at all sure they did an adequate job of it ...)
22:15:39 <pokoko222> doing lim (sinx/x)=1 with L`Hopital, can you call that a proof? :P
22:15:46 <monochrom> I am here.
22:16:12 <lpsmith> pokoko222, depends on the context :)
22:16:20 <lpsmith> For calc I,  it's good enough
22:16:21 <Axman6> and whether it's right :P
22:16:41 <pokoko222> yeah that, is it right, i guess the ultimate right way is to do it geometrically
22:16:54 <lpsmith> well,  lim {x -> 0) (sin x / x) is indeed 1 :)
22:17:53 <Axman6> aye
22:18:05 <Axman6> it's the sinc function no?
22:18:18 <Axman6> fairly important to signal processing
22:18:46 <monochrom> the complex version is called the zinc supplement
22:18:55 <elly> hahahaha
22:19:34 <Axman6> heh
22:20:52 <lpsmith> pokoko222, the problem with using L`Hopital to give that as a proof in a more sophisticated context is that typically,  the fact that lim_{x -> 0} (sin x / x) = 1  is used to prove that the derivative of sin is cos
22:21:34 <lpsmith> so it might be circular reasoning,  depending on how you proved what the derivative of sin is
22:21:35 <Jafet> You can do worse proofs
22:21:39 <Jafet> Take the power series
22:21:42 <pokoko222> heh
22:22:11 <lpsmith> But I daresay in Calc I,  l'hopital should be considered adequate proof of that fact
22:23:00 <pokoko222> i agree, it can not be called proof, in worst case it should be awarded "noobest proof ever" :D but it was so cool when i realized it, we did it with squeeze theorem and geometrically and now when i thought of it and l hopital, that works too...
22:23:21 <pokoko222> lpsmith do not dare :D
22:23:26 <lpsmith> I wouldn't call it noobest proof ever
22:23:45 <lpsmith> I produced a proof of the pythagorean theorem using trig identites once  :)
22:24:32 <lpsmith> namely,  (sin x)^2 + (cos x)^2 = 1
22:24:58 <jbapple> There is a very simple proof that the nth roots of 2 are irrational for n>=3.
22:24:58 <jbapple> It depends on Fermat's last theorem :-)
22:25:15 <lpsmith> jbapple, I assume you read rjlipton's blog :)
22:25:20 <jbapple> :-D
22:25:35 <monochrom> Hahaha
22:26:34 <pokoko222> monochrom sorry i started "dumb proofs" topic :P i am back to my book
22:27:37 <lpsmith> pokoko222, nothing to be sorry for, in my opinion.   It's a good thing to feel excited about :)
22:28:01 <tomberek> lpsmith: http://topologicalmusings.wordpress.com/2008/02/17/irrationality-of-nth-root-of-2/  i like it
22:28:06 <monochrom> Is it a good thing to be off-topic?
22:28:44 <lpsmith> there are worse things than being off topic,  and math does get discussed fairly regularly here
22:28:54 <monochrom> I will change that.
22:29:19 <jbapple> I am creating a cabal package that should include extra documentation files. Where should I put them? How should I label them in the .cabal file?
22:29:33 <jbapple> They aren't really data files OR source files
22:31:30 <aavogt> jbapple: can it be haddock-formatted?
22:31:38 <lpsmith> Worse things than being off topic:   1.  Not having conversation at all;   2.  Losing civility
22:31:53 <jbapple> aavogt: nope
22:32:03 <lpsmith> I'm sure there are more
22:32:04 <jbapple> They are actually Coq files
22:32:13 <lpsmith> But that's two I came up with off the top of my head
22:32:21 <aavogt> since in that case it might be sensible to have modules purely for documentation purposes
22:32:35 <lpsmith> Ok,  I'm not sure this is a wonderful idea yet;  but I'm experimenting with an idea that looks something like this:
22:33:01 <lpsmith> data Record field = Record { foo :: field SyntaxType DataType,  bar :: field SyntaxType' DataType',  baz :: field SyntaxType'' DataType'' }
22:33:09 <lpsmith> however,  apparently I can't derive data-accessor's for Record,  at least not with the standard hunk of template haskell
22:33:22 <lpsmith> any ideas/suggestions/critiques?
22:33:44 <jbapple> I could just leave the files out and point to their location on the web
22:33:56 <jbapple> But it seems better to include them all in one package
22:33:57 <aavogt> does data-accessor-template work for parameterized data types at all, lpsmith?
22:34:06 <lpsmith> aavogt, probably not
22:36:00 <lpsmith> it doesn't seem to work on type synonyms or newtypes
22:36:49 <lpsmith> and since my record unavoidably has a lot of fields,  I really don't want to write out that stuff by hand;  maybe it's time to learn a bit more template haskell
22:37:08 <lpsmith> Or maybe I should write it out by hand for now with the intention of replacing it with TH in the future
22:38:54 <aavogt> lpsmith: it isn't apparent to me why data-accesor-template write s kind signatures
22:39:39 <aavogt> I think if you knock that part out...
22:39:50 <lpsmith> hmm
22:42:28 <lpsmith> aavogt, ahh yes,  it does work on parameterized types where the parameters have kind :: *
22:42:55 <lpsmith> thanks for the tip;  I'll give it a try
22:43:55 <aavogt> lpsmith: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24782#a24782
22:44:20 <aavogt> seems to be just that the wrong type signatures are written by deriveAccessors
22:50:08 <siracusa> In what Haskell extension `aaa-bbb-ccc' denotes a list of identifiers [aaa, bbb, ccc]?
22:50:08 <wolgo> well I have the core of hangman built.
22:50:13 <wolgo> IO is not that bad
22:50:28 <wolgo> pretty easy for just printing and dealing with files, indentation is weird
22:50:38 <wolgo> better than ruby and python
22:50:48 <wolgo> once again I am going to try to learn haskel
22:50:49 <wolgo> l
22:50:56 <wolgo> thanks for the help people
22:51:16 <aavogt> siracusa: probably none...that's going to override the regular interpretation of -
22:52:49 <siracusa> aavogt: I'm having a glance at the Lexer in haskel-src-exts and it parses `-' separated identifiers as a list of them.
22:56:42 <aavogt> because they are actually separte identifiers, no?
22:58:15 <siracusa> You mean the same as aaa - bbb - ccc?
22:59:04 <aavogt> if it's parsed as something else due to some extension, then it should be apparetn from the context of that code?
23:01:06 <siracusa> Well, for me it's not. That's why I asked :-)
23:01:54 * ski notes lots of paste spam at moonpatio ..
23:11:04 <Axman6> kamatsu: I think i love you: http://www.reddit.com/r/programming/comments/bm1u8/safe_robust_programming_practices_in_haskell_via/c0nqcn2
23:12:45 <kmc> jdh30: -1,726 comment karma
23:13:01 <kmc> if you're gonna troll reddit, at least make lots of different accounts
23:13:08 <ezyang> ...
23:13:08 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
23:13:14 <ezyang> I didn't even think that was possible.
23:13:20 <ezyang> @messages
23:13:20 <lambdabot> tibbe said 16h 2m 34s ago: What did you use to create the diagrams in your zipper blog post?
23:13:28 <Cale> http://www.skipmore.com/freegames/synopsis/synopsis.html :)
23:13:37 <ezyang> tibbe: Why, good sir, that's the subject of tomorrow's blog post :-)
23:13:58 <tibbe> ezyang: but I want to know now now now :)
23:14:17 <Axman6> heh
23:14:20 <tibbe> ezyang: (cause I need some diagrams for a blog post)
23:14:31 <tibbe> ezyang: hand drawn and scanned?
23:14:40 <ezyang> hand drawn in Xournal on a tablet
23:17:51 <tibbe> ezyang: nice, I was thinking of getting a tablet yesterday
23:19:37 <kamatsu> Axman6: lol, thanks
23:20:52 <Axman6> also, dcoutts is once again my hero for being able to handle jdh: http://www.reddit.com/r/programming/comments/bm1u8/safe_robust_programming_practices_in_haskell_via/c0nqyvu
23:21:02 <kamatsu> i know, i was very impressed
23:21:03 <Axman6> s/hero/hero,
23:21:16 <Axman6> are you still at google by the way?
23:21:20 <kamatsu> nope
23:21:31 <Axman6> UNSW?
23:21:36 <kamatsu> yup
23:21:40 <kamatsu> working on my research project atm
23:21:50 <kamatsu> just implementing typeclass dictionaries in javascript
23:22:37 <Axman6> you weren't working on a JS backend for GHC were you?
23:22:46 <kamatsu> i will be, next year
23:22:53 <kamatsu> right now it's for a minimal lazy functional language
23:23:00 <Axman6> yeah i thought we'd talked about this before
23:23:06 <kamatsu> yeahy
23:23:19 <Axman6> looking forward to AusHac?
23:23:24 <kamatsu> when is it again?
23:23:27 <kamatsu> i got very sick recently
23:24:09 <Axman6> july 16-18
23:24:13 <Axman6> long way away
23:24:15 <kamatsu> ah, plenty of time
23:24:33 <kamatsu> might have some cool stuff to show by then
23:24:56 <Axman6> awesome :)
23:25:19 <kamatsu> it's already pretty awesome, lazy semantics seems to be working in js
23:25:25 <kamatsu> at least, i can make infinite data structures
23:25:55 <Axman6> whoot
23:26:08 <kamatsu> once i get typeclasses then i just need to make some  form of JS interface  so the DOM can be interacted with.
23:26:32 <kamatsu> also various optimizations such as tail call elimination and checking how badly i rape the heap
23:27:53 <Axman6> heh
23:28:02 <Axman6> gotta love a bit of heap rape
23:29:34 <Axman6> lets the computer/browser know who's boss
23:30:05 <FauxFaux> Corrective rape, if you will.
23:30:12 <ski> kamatsu : every tail-call, known tail-calls, known mutual tail-calls or known self-tail-calls ?
23:30:13 <blackdog>  good to see #haskell's keeping it classy.
23:31:39 <kamatsu> ski: any statically detectable tail call, including mutual tail calls
23:31:55 <kamatsu> i intend to just use an exception and unroll the stack
23:32:01 <kamatsu> i suppose it's optimization, not elimination
23:32:30 <ski> so if `f' calls an argument `g' in tail position, that will usually not be a tail-call, then ?
23:32:46 <kamatsu> ski: can you rephrase?
23:32:52 <lpsmith> lambdabot,  tell aavogt thanks!
23:33:01 <lpsmith> :-/
23:33:05 <lpsmith> > 2 + 3
23:33:06 <lambdabot>   5
23:33:18 <lpsmith> lambdabot,  @tell aavogt thanks!
23:33:18 <lambdabot> Consider it noted.
23:33:18 <ski>   foo f x y = f x (bar x (f y x))
23:33:27 <lpsmith> there we go
23:33:32 <aavogt> lpsmith: no problem
23:33:32 <lambdabot> aavogt: You have 1 new message. '/msg lambdabot @messages' to read it.
23:33:37 <ski>   then calling `foo baz 2 3' will call `baz' in tail-position
23:34:08 <ski> kamatsu : clear ?
23:34:12 <kamatsu> ski: that will be a tail call
23:34:41 <ski> even if the call to `foo' is not known at the time `foo' is compiled ?
23:34:52 <aavogt> lpsmith: the original bug being worked around here should probably be reported...
23:35:14 <ski> (assuming separate compilation, or dynamic loading or `eval' ..)
23:35:17 <aavogt> something to do with the code that makes the kind signature being quite off
23:35:18 <ManateeLazyCat> haskell.org is down again?
23:35:43 <aavogt> ie. making the * -> * -> * associate to the left when it shouldn't be that way
23:35:50 <kamatsu> ski: we don't have to know that it's foo
23:35:57 <ski> ok, ty
23:36:01 <kamatsu> ski: it throws a continuation which includes the environment.
23:36:27 <ManateeLazyCat> aavogt: Can you access haskell.org ?
23:36:29 <lpsmith> aavogt,  ok,  I will email the maintainer
23:36:29 <ski> so, that appears to me that it could be an implementation of proper tail calls, then
23:36:42 <ManateeLazyCat> I want read http://www.haskell.org/haskellwiki/Template_Haskell
23:36:54 <aavogt> I can't either
23:37:09 <ManateeLazyCat> aavogt: Why haskell.org always down?
23:37:18 <ManateeLazyCat> aavogt: Hardware not stable?
23:37:55 <aavogt> no idea. I'm not involved like that
23:38:43 <ManateeLazyCat> I'm worry the code on the haskell.org server.
23:39:23 <mjrosenb> i am kind of sad that while building ghc, it does not display the progress
23:40:18 <aavogt> I am sad that you build ghc
23:40:24 <aavogt> or are you hacking it?
23:40:33 <mjrosenb> aavogt: well, how else am i supposed to run it?
23:40:41 <aavogt> you download a binary
23:41:26 <mjrosenb> aavogt: the last binary available is 6.8.2
23:41:36 <aavogt> for who?
23:41:47 <aavogt> *which architecture?
23:41:50 <mjrosenb> and i happen to like the additions to the library in 6.10
23:41:53 <mjrosenb> alpha
23:42:20 <aavogt> interesting
23:43:45 * ManateeLazyCat I can use google cache for that. :)
23:43:56 * aavogt thinks it's back anyways
23:44:40 <mjrosenb> ManateeLazyCat: did you just type /me I?
23:44:56 <ManateeLazyCat> mjrosenb: Yes, i type /me
23:45:53 <ManateeLazyCat> aavogt: I plan develop a jabber client in my project when i drop Emacs.
23:46:07 <ManateeLazyCat> aavogt: For IRC, or other IM (such as Gtalk). :)
23:47:23 * ManateeLazyCat TH is another surprise after StateT. :)
23:48:09 <aavogt> well keep in mind that TH is often a less pretty solution than fancy stuff with typeclasses
23:49:29 <ManateeLazyCat> aavogt: Yes, for extension, i will use typeclasses always, but some core feature, like DBus message, i don't allowed user touch it.
23:49:48 <ManateeLazyCat> aavogt: This must be check in Daemon Process.
23:49:49 <aavogt> the staged implementation (splices run before the rest of the code) lets you do some stuff approximating dependent types
23:49:50 <tensorpudding> TH is mungy and inelegant.
23:50:13 <aavogt> (types depending on values that are known at compile time)
23:51:04 <aavogt> but the implementation kind of annoyingly forces you to write small modules
23:51:22 <aavogt> rather than figuring out itself that your bindings don't actually make any cycles
23:51:31 <aavogt> *splices
23:51:39 <ManateeLazyCat> aavogt: Types.hs ?
23:51:52 <ManateeLazyCat> aavogt: Haven't any cycle in my project, sweet.
23:52:04 <ManateeLazyCat> aavogt: Types.hs can fix cycle reference problem.
23:52:28 <aavogt> ManateeLazyCat: I mean that  $( x :: ExpQ ) , is typechecked in the same group as all other splices like it
23:53:32 <aavogt> so when you have multiple splices like that which produce polymorphic values, you basically lose type inference for those expressions
23:53:41 <aavogt> for practical purposes
23:53:56 <aavogt> actually, I'm not sure that type signatures can save it
23:54:09 <ManateeLazyCat> aavogt: Just keep TH in minimum scope?
23:54:26 <aavogt> the workaround is to split stuff into smaller modules, or change those ExpQ into DecQ
23:54:32 <aavogt> exactly
23:54:54 <lpsmith> mjrosenb, how  recent are the most recently manfactured Alphas, out of curiousity?
23:55:25 <aavogt> it's annoying, but I suppose it's the price you pay for typechecked metaprograms
23:56:19 <mjrosenb> lpsmith: i think there are some that were made within the last 5 years
23:56:30 <mjrosenb> lpsmith: however, this one was made ~15 years  ago
23:56:33 <lpsmith> lol
23:56:57 <lpsmith> I have an antique alpha,  I never got it working though :-/
23:57:07 <lpsmith> I don't have a keyboard for it
23:57:25 <aavogt> dh5 alphas
23:57:29 <mjrosenb> lpsmith: nor do i.
23:57:33 <lpsmith> at this point,  I think I'm going to get rid of it;  I dunno
23:57:46 <mjrosenb> lpsmith: you can do everything over the serial line
23:57:53 <lpsmith> hmm
23:58:02 <mjrosenb> lpsmith: if you happen to live in southern california, i'll take it off your hands :-p
23:58:46 <lpsmith> nope,  but I might be willing to ship it to you for a small fee
23:58:54 <tensorpudding> Who makes Alpha anymore?
23:59:07 * ski rescued a few sparc boxen, which he should probably try to plug up sometime ..
23:59:17 <tensorpudding> Didn't DEC die a good while ago?
23:59:37 <jbapple> I think DEC was purchased by Compaq was purchased by HP
23:59:42 <lpsmith> I'm thinking this one was manufactured circa 94-ish
23:59:55 <lpsmith> I think it's a bit older than yours
