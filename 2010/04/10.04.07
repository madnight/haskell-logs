00:00:02 <edwardk> ezyang: you might use http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/Text-Parsimony-Prim.html as a straw man. it was the very first draft or a parser i put together for parsimony. i never did post up any of the later builds
00:00:12 <edwardk> er s/or/of
00:00:24 <ezyang> ok
00:00:41 <ezyang> now, it's way past my bedtime
00:00:42 <edwardk> the next rev eliminated a lot of the unsafeCoerce machinery used in recognizing parsers
00:00:44 <ezyang> G'night all :-)
00:00:53 <edwardk> hey
00:00:56 * ezyang goes off to dream of zippers 
00:00:56 <edwardk> when you get a chance
00:01:05 <edwardk> i'd like to talk to you about getting a room for boston haskell or something
00:01:07 <edwardk> and restarting it
00:01:13 <edwardk> night man
00:01:33 <ezyang> edwardk: Oof, it ended up hibernating? That's disappointing :-(
00:01:39 <ezyang> sure thing
00:01:50 <edwardk> ezyang: i think ravi wound up more concerned with putting food on his table, understandably
00:02:05 <ezyang> indeed.
00:02:05 <edwardk> ezyang: so i figure it falls to me to rally the troops
00:02:10 <ezyang> :-)
00:02:24 <edwardk> ezyang: i'm sure i have a project or two i could talk about
00:02:32 <edwardk> ezyang: to bootstrap the sessions again
00:02:33 <chrisdone> http://www.reddit.com/r/haskell/comments/bn9to/type_checker_trivia_what_are_the_types_of_f_and_y/
00:02:36 <edwardk> but i'll let you get some sleep
00:02:45 <ezyang> bye!
00:02:58 <chrisdone> does this trip haskellers up? I worked it out and the answer was totally logical to me
00:03:23 <edwardk> chrisdone: they aren't the most general types, but it very very rarely is an issue
00:03:45 <edwardk> chrisdone: it does motivate some of the corner cases where you really want scoped type vars though
00:05:01 <chrisdone> edwardk: isn't this just straight unification?
00:07:58 <edwardk> chrisdone: nope. the constraint f places on y is that y must be assignable to that type. you can prove that you can't find the most general type here. haskell makes a best effort where ml and company would tell you to go screw yourself ;)
00:08:22 <edwardk> meacham summarized the result very effectively in the linked thread
00:10:59 <ski> edwardk : yes, i saw it
00:11:49 <ski> (i was thinking by "overapplication" you were talking about your currying macros in Scheme .. maybe that's not the case ?)
00:12:02 <edwardk> ski: nah, different need for overapplication
00:12:26 <ski> so you were referring to "overapplication" of the "array", there ?
00:13:01 <chrisdone> any wee bit of haskell coding will tell you haskell doesn't infer the most general type~
00:13:02 <edwardk> ski: there the problem is in every scheme currying macro i;ve ever found, if you curry a method that takes 2 arguments and pass it 4, they barf instead of calling, waiting for the result and passing the remaining two to it
00:13:17 <edwardk> ski: and i rely on that a lot to make usable monad sugar =)
00:14:20 <tibbe> edwardk: good morning :)
00:14:23 <edwardk> ski: heh the topic came up 3 times tonight, once in reference to arc which allows you to use its builtins as functions, the reference to the farray paste from the other day, and then the currying one.
00:14:45 <edwardk> heya tibbe, took me a bit longer than expected to get that post to the list out but its there ;)
00:14:52 <mpiechotka> Hello. Is there any way to get Data.Accessor library that autoderive definitions?
00:14:53 <tibbe> edwardk: just saw your email about SoC. Do you think it would make sense to personally email those people who posted project proposals on the mailing list but didn't sign up with Google yet?
00:15:00 <edwardk> yeah
00:15:17 <tibbe> edwardk: Do you want to do it or would you like me to
00:15:18 <tibbe> ?
00:15:54 <edwardk> we should probably email each of the candidate mentors on the People2010 page as well, to get them to sign up
00:16:19 <edwardk> depends, what timezone are you in? i'm pushing 3-4 AM local time ;)
00:17:06 <tibbe> edwardk: it's 9:16 am here so I can email the potential candidates now
00:17:17 <tibbe> edwardk: perhaps you could email the mentors tomorrow?
00:17:19 <edwardk> if you'll follow up with the students who posted to the haskell-cafe@ i'll send out an email to the mentors list from the People2010 page when i get up
00:17:20 <edwardk> yeah
00:17:32 <ski> edwardk : hm, which kind of built-ins in arc ?
00:17:35 <edwardk> or rather when i get a break at the office, which will be sometime thereafter
00:17:47 <edwardk> ski: lists and vectors let you index using them as functions
00:18:06 <tibbe> edwardk: ok
00:18:14 <tibbe> edwardk: I cannot see who has signed up as mentor already
00:18:22 <edwardk> ski: in kata i've been looking to allow you to use functors as their map function
00:18:32 <edwardk> lemme register you as a backup admin
00:18:52 <edwardk> sent
00:19:03 <edwardk> that should give you the ability to see everything
00:19:05 <tibbe> edwardk: thanks
00:19:30 <ski> edwardk : hm, yes i think i recall you saying something about that previously
00:19:47 <edwardk> ski: but i have to admit its a bit hackish =)
00:20:03 <ski> (iirc, Charity does something similar)
00:20:26 <tibbe> edwardk: isn't it possible to invite the mentors via the web interface?
00:20:41 <edwardk> ski: i do think its not a bad idea though for something like Kleisli though
00:20:59 <edwardk> tibbe: the invite there only seems to work if they have a userid
00:21:02 <ski> "Kleisli" here being ?
00:21:03 <edwardk> so they have to register for the site first
00:21:06 <tibbe> edwardk: I see
00:21:08 <edwardk> @src Kleisli
00:21:08 <lambdabot> Source not found. My mind is going. I can feel it.
00:21:14 <edwardk> @src Control.Arrow.Kleisli
00:21:14 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:21:14 <tibbe> edwardk: send them a normal email then I guess
00:21:17 <edwardk> yeah
00:21:46 <Gracenotes> hm, the Arch Haskell Platform link says "This package has been flagged out of date" - http://aur.archlinux.org/packages.php?ID=26279
00:21:52 <edwardk> tibbe: i figured i'd send the email with the invite summarizing where to go and to email me or to fill out the 'request to mentor' form
00:21:52 <ski> i'm not sure what you mean re `Control.Arrow.Kleisli' (which i know about)
00:21:54 <Gracenotes> that's not a good thing, is it? :)
00:22:02 <Gracenotes> :|
00:22:21 <tibbe> edwardk: ok
00:23:09 <ski> you want `Kleisli' to act as a function of type `forall a b0 b1 m. Monad m => (b0 -> b1) -> (Kleisli m a b0 -> Kleisli m a b1)' ?
00:23:35 <edwardk> ski: or even just a -> m b
00:24:14 * ski is not following what `Kleisli' has to do with functor-mapping :/
00:24:16 <edwardk> though the error messages for that are a lot worse than the farray case
00:24:35 <edwardk> ski: it doesn't, it was just another case of something that was very function-like
00:24:58 <edwardk> Kleisli m a b -- is a newtype around 'a -> m b'
00:25:52 <ski> yes .. i still don't see why you're mentioning this, though :/
00:26:16 <edwardk> ski: as yet another example of something you can apply is all
00:26:40 <edwardk> tibbe: thanks a bunch, btw.
00:26:50 <tibbe> edwardk: no problem
00:26:53 <ski> .. oh, ok
00:27:09 <ski> (sorry for being a hard-head)
00:27:11 <kmc> mpiechotka, http://hackage.haskell.org/package/data-accessor-template ?
00:27:17 <kmc> it doesn't seem to build on 6.12 though
00:27:28 <kmc> perhaps you will have better luck with fclabels or lenses
00:27:41 <mpiechotka> kmc: I worked it(failure on 6.12) out  ;)
00:27:51 <mpiechotka> kms: I'll check fclabels and lenses
00:28:16 <kmc> cool
00:28:31 <edwardk> ski: heh, probably my fault. I have trouble stringing together a coherent sentence when I'm fully conscious, it can't be easy to read the drivel that I spew forth when I'm this tired ;)
00:28:50 <ski> no worries :)
00:29:15 <edwardk> ok, i've decided the monad makes more sense with AIGs than NNF
00:29:34 <edwardk> NNF would require some very expensive gyrations, just to support 'not' on the bits in question, which is silly
00:30:20 <edwardk> i mocked up both to try them out. the benefit of NNF is that there are fewer fiddly bits (quite literally, each edge doesn't have a possible negation on it!)
00:30:58 <edwardk> but the expense of that is way too many applications of DeMorgan's law
00:32:11 <edwardk> the only other candidate representation i've been considering are these "NICE" graphs by some guy nearby here at Northeastern
00:34:44 <ski> ("AIG","NNF" ?)
00:34:57 <edwardk> and-inverter graph, and negation normal form.
00:35:18 <edwardk> an AIG is a graph that consists of ands where each edge may or may not be negated.
00:35:57 <edwardk> NNF consists of stratified tiers of k-ary ands and k-ary ors with negation only occuring on the literals
00:37:59 <ski> > let x = not (x && y); y = x && not y in x
00:38:03 <lambdabot>   mueval-core: Time limit exceeded
00:38:06 <ski> like that ?
00:38:31 <edwardk> yeah
00:38:32 <ski> (re `AIG', i.e.)
00:39:15 <ski> > [(x,y) | [x,y] <- replicateM 2 [False .. True] , x == not (x && y) , y == x && not y]
00:39:16 <lambdabot>   []
00:40:14 <edwardk> that would become something like the following concrete syntax for my sat solver: assert $ exists \x y -> (x === not (x && y)) && (y === (x && not y))
00:40:27 <gspr> Does anybody here have experience with the CArray package?
00:40:39 <edwardk> (it provides overloaded boolean sugar)
00:40:41 <ski> > [(x,y) | [x,y] <- replicateM 2 [False .. True] , x == not (x && y) , y == not (x && not y)]
00:40:42 <lambdabot>   [(True,False)]
00:40:49 <ski> > let x = not (x && y); y = not (x && not y) in x
00:40:53 <lambdabot>   mueval-core: Time limit exceeded
00:41:07 <edwardk> ski: and can correctly handle the don't care assignments if the result is defined for some inputs, etc.
00:41:56 <ski> rephrase that last ?
00:42:24 <edwardk> ski: your circuit there has a loop in it, so it may not be satisfiable
00:43:11 <edwardk> a couple of loops actually
00:43:15 <ski> (yes, i constructed it so that the possibly cycles in the graph would make it unsatifiable :)
00:43:36 <ski> (.. since i wondered whether you meant graph or DAG)
00:43:47 <edwardk> graph is fine here
00:44:21 <edwardk> i recover sharing through stable names and detect the SCC, i need to write a naive CNF converter for those cases, but nothing prevents them
00:44:24 <ski> > let x = not x || not y; y = not x || y in x
00:44:28 <lambdabot>   mueval-core: Time limit exceeded
00:44:34 <ski> > let x = not x || not y; y = not x in x
00:44:38 <lambdabot>   mueval-core: Time limit exceeded
00:45:25 * ski wonders how to "start off" cycles like this with initial values (possibly trying all), but such that the initial values are actually checked later, in a nice way
00:45:37 <ski> cf.
00:46:38 <ski> > fix $ \ns -> ns /\/ (map succ ns)
00:46:41 <lambdabot>   mueval-core: Time limit exceeded
00:46:43 <ski> > fix $ \ns -> 0 : tail (ns /\/ (map succ ns))
00:46:44 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
00:47:19 <ski> (the latter forcing the first element of `ns' to be `0', but is not actually checking later that the first element of the generated list actually is `0')
00:48:22 <edwardk> i'm going to get some sleep i just realized that i tried to type my last reply 5 times and didn't get anything coherent until now ;)
00:48:32 <edwardk> later man
00:51:49 <Jafet> @faq can haskell be like prolog?
00:51:50 <lambdabot> The answer is: Yes! Haskell can do that.
00:53:04 <ski> Jafet : hehe
00:53:09 <ski> > uncurry seq $ fix $ \ ~(_,ns) -> force_head 0 (ns /\/ map succ ns)
00:53:10 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
00:53:17 <ski> > uncurry seq $ fix $ \ ~(_,ns) -> force_head 0 (map succ ns /\/ ns)
00:53:18 <lambdabot>   * Exception: foo !
00:53:25 <Jafet> Foom
00:53:39 <ski> (not really very nice, though ..)
00:55:48 <gspr> When the functions in a package (in this case the FFT package) operate on on CArrays, does one have any hope of (perhaps unsafely) converting other types of data to CArray outside IO?
00:56:14 <gspr> (Clearly, CArrays and their relation to Data.Array.Storable and all the other gazillions of array types confuse me a lot :)
00:56:57 <jeeez> hi, can someone suggest a good book for haskell? [some math background for functional programming would be awesome]
00:57:56 <gspr> jeeez: I enjoyed Real World Haskell, but it (sadly) has no mathsy things
00:59:08 <jeeez> gspr: does it have a proper pdf i can print out? the version i got is just the html version put into a pdf.
00:59:29 <gspr> jeeez: I just bought it after reading the HTMLs for a while... it's cheap
00:59:56 <jeeez> gspr: where i live, no books are cheap! :\
01:00:09 <dv-> There are several more mathy Haskell books than RWH
01:00:19 <jeeez> dv-: open to suggestions!
01:00:44 <znutar>  Haskell Road to maths, logic and programming or whatever the name is is reasonably mathy
01:00:54 <siorai> jeeez: how Haskelly do you want it to be?
01:01:01 <siorai> There's Algebra of Programming
01:01:32 <jeeez> siorai: i want to learn functional programming, and the a fair knowledge of behind the scene work. :\
01:01:45 <jeeez> znutar: let me check it out
01:02:02 <siorai> jeeez: There's also Introduction to Functional Programming using Haskell
01:02:11 <gspr> jeeez: If books are expensive where you live, why not order from the book depository or another one of those amazon-busters? :)
01:03:13 <siorai> Those are both theory oriented approaches to functional programming
01:03:26 <jeeez> gspr: i should, that's why i'm trying to make a good choice! :)
01:05:05 <siorai> jeeez: There's also any number of papers upon which those works are based
01:05:11 <siorai> which should be free
01:05:48 <Jafet> Do you want to learn Haskell programming, or "math background for functional programming"?
01:06:54 <Jafet> For the latter, there are materials on category theory, type theory, denotational semantics, and so on
01:07:22 <jeeez> haskell programming. :\ and some answers for WHY some things are done the way they are, not just how to do it.
01:08:00 <Jafet> Sometimes the why comes from the math background.
01:10:01 <jeeez> i'm no scientist, so wont be able to understand all of it i guess
01:11:12 <siorai> Jafet: and sometimes it comes from the "because" background =p
01:11:37 <Jafet> Programming is hardly scientific anyway
01:12:02 <Jafet> Like the last function I wrote, total guesscoding
01:12:34 <siorai> Jafet: The nice thing about Haskell, though, is that if you get the types good enough, guesscoding can help you any awful lot
01:16:41 <ski> FCont> take 16 $ runFCont $ mfix $ \ns -> force_head 0 (ns /\/ map succ ns)
01:16:42 <ski> [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4]
01:16:54 <ski> FCont> take 16 $ runFCont $ mfix $ \ns -> force_head 0 (map succ ns /\/ ns)
01:17:03 <ski> *** Exception: unification failed
01:17:12 <ski> (:
01:20:11 <kevinulin> is there a purely functional hashtable?
01:20:59 <Baughn> Data.Map is too slow?
01:21:24 <kevinulin> nope, thats what i was looking for
01:21:25 <andersk> Or Data.IntMap?
01:21:26 <kevinulin> thanks
01:21:33 <Baughn> Those aren't hash tables, though. :P
01:21:40 <kevinulin> close enough :)
01:22:14 <Baughn> IIRC, there was some kind of theorem stating that you can't have an O(1) (in both read and write) purely functional table.. but I'm not sure, and those theorems tend to fail for lazy languages anyway
01:23:41 <kevinulin> ya i dont need it to be particularly efficient, just dont want to search a list everytime i want a specific value
01:25:35 <Baughn> Data.Map /is/ rather efficient, though. You'll be fine.
01:26:14 <danderson> yeah, unless the profiler shows otherwise, Data.Map won't be your bottleneck
01:29:04 <moshisushi> hello! i need to force evaluation of a value (because i do not want lazy evaluation to kick in inside of a mutex)
01:29:19 <moshisushi> can i do this in some nice way?
01:29:22 <moshisushi> i had a look at seq
01:29:31 <moshisushi> but it turns out you only get the rightmost value
01:29:32 <Baughn> Several. It depends on how much evaluation you need.
01:29:43 <jbapple> @google deepSeq
01:29:44 <lambdabot> No Result Found.
01:29:50 <jbapple> oh dear
01:29:55 <idnar> the... rightmost value?
01:29:59 <Baughn> putMVar $! foo -- will evaluate foo to WHNF before passing it to putMVar
01:30:07 <Baughn> @src ($1)
01:30:07 <lambdabot> Source not found. Sorry.
01:30:09 <Baughn> @src ($!)
01:30:09 <lambdabot> f $! x = x `seq` f x
01:30:26 <jbapple> idnar: WHNF, maybe
01:30:40 <jbapple> moshisushi: http://www.google.com/search?q=deepseq
01:30:47 <Baughn> moshisushi: There's also Control.Parallel.Strategies; using, and its various strategies
01:30:54 <moshisushi> thanks!!
01:31:22 <Baughn> deepseq will walk the entire structure, which can be annoying if you already know some parts are evaluated
01:32:44 * Baughn is a bit uncertain why DeepSeq exists; NFData seems to do the same thing
01:33:08 <dmwit> DeepSeq predates NFData, and is deprecated in favor of NFData.
01:33:11 <dmwit> I bleeve
01:33:23 <Baughn> Ah.
01:33:46 <Baughn> Yes, `using` rnf seems like a better way to go about it.
01:38:20 <moshisushi> Baughn: hehe what about (f x) $! id  ? :>
01:38:52 <Baughn> moshisushi: I believe that would fully evaluate id before passing it to (f x). xD
01:38:59 <dmwit> moshisushi: id is in WHNF already
01:39:11 <Baughn> id is in normal form, either
01:39:12 <dmwit> It is extremely easy for functions to be in WHNF.
01:39:13 <Baughn> *even
01:40:52 <turiya> hi
01:41:02 <moshisushi> Baughn: oh, of course i mean id $! (f x) heh
01:41:10 <turiya> what is the use of withMVar?
01:41:24 <dmwit> :t withMVar
01:41:25 <lambdabot> Not in scope: `withMVar'
01:41:34 <Baughn> moshisushi: That would be a no-op. A costly one.
01:41:37 <dmwit> turiya: It's handy for when you want to atomically update a shared variable.
01:42:28 <turiya> dmwit, what does it update to
01:42:39 <Baughn> turiya: Don't mix it with putMVar
01:42:45 <moshisushi> Baughn: eh ok? but doesn't this force the evaluation of (f x) ?
01:43:01 <Baughn> moshisushi: Only once the value of (id $! (f x)) is demanded
01:43:02 <dmwit> turiya: Sorry, I was thinking of the wrong function.
01:43:09 <dmwit> turiya: withMVar doesn't do any updates
01:43:23 <Baughn> moshisushi: Given that id doesn't actually do anything, that makes it a no-op.
01:43:24 <dmwit> turiya: withMVar is handy in the same way gets is handy =)
01:44:22 <turiya> the documentation says it is a wrapper - i dont understand that
01:44:50 <dmwit> turiya: It wraps getMVar and putMVar.
01:45:16 <dmwit> turiya: The real work it does is to make sure that the MVar isn't empty in case your (a -> IO b) action happens to throw an exception.
01:45:36 <Baughn> moshisushi: There is no way to say "evaluate this now", because there is no notion of /now/. (Except in IO, of course, which has an evaluate action for just that purpose.. er, but don't mind that right now)
01:45:38 <moshisushi> Baughn: but according to the definition of $! above, the (f x) part of id $! (f x) will be the left-hand side in a seq
01:46:17 <Baughn> moshisushi: $!, using, seq, etc. just create relationships. "If this is evaluated, then evaluate this other thing (first)."
01:46:19 <moshisushi> Baughn: i am in a do-block though.. so there is a "now" in a sense
01:46:41 <dmwit> turiya: do { x <- getMVar m; print (3 / x); putMVar x } -- this is unsafe, because (3/x) could throw a divide-by-zero exception and block all other threads that depend on m
01:47:01 <Baughn> moshisushi: There is no such thing as s do-block, it's just syntactical sugar. ;)
01:47:08 <dmwit> turiya: do { x <- withMVar m (\x -> return (3 / x)); print x } -- this is safe
01:47:09 <turiya> dmwit, hmm exceptions - what are they?
01:47:20 <moshisushi> Baughn: ok whatever :> i'm in a sequence
01:48:10 <turiya> and what if an "exception" is thrwon, what does withMVar do?
01:48:16 <Baughn> moshisushi: In any case, (id $! (f x)) just means "When (id $! (f x)) is evaluated, evaluate f x before you start".
01:48:17 <dmwit> turiya: Exceptions are indicators of serious problems or unexpected circumstances. Most programs don't handle them, just dieing if an exception is ever thrown.
01:48:24 <moshisushi> Baughn: yeah i see
01:48:30 <Baughn> moshisushi: id then proceeds to do nothing.
01:48:36 <dmwit> turiya: If an exception is thrown, withMVar puts the value back into the MVar, then rethrows the exception.
01:48:55 <Baughn> moshisushi: So it's no different from just saying (f x), which would still evaluate f x when f x is evaluated
01:49:17 <dmwit> So if you have a handler higher up in your call stack, it can do something about it while the other threads are going on their merry way, still using that MVar as if nothing went wrong.
01:50:51 <turiya> dmwit, ok.. so in the example that you gave, the value of m would not change is x = 0
01:51:10 <moshisushi> Baughn: so here is the actual problem.. i can't wait with evaluation until it's needed since it will be needed first inside a mutex. My program is blocked unnecessarily if evaluation takes place while holding the lock...
01:51:12 <dmwit> Well, the value *contained in m* would not change, right.
01:51:12 <Baughn> moshisushi: (Except that id x may have a runtime cost over just saying x, depending on how smart the optimizer is. It's very smart, though.)
01:52:11 <turiya> ok.. thats what i think i meant but am still not sure about values and containers yet..
01:52:47 <Baughn> moshisushi: The elegant way to solve that would be to create an IO action (foo :: a -> IO () or something) that grabs the mutex, and call foo $! val, or foo $! (val `using` rnf) if that's what fits.
01:53:04 <Baughn> moshisushi: It would also be possible to use Control.Exception.evaluate to do it "inline", but don't do that.
01:56:06 <moshisushi> Baughn: nice solution :>
01:56:08 <moshisushi> thanks!
02:10:11 * hackagebot hxt-xpath 8.5.4 - The XPath modules for HXT.  http://hackage.haskell.org/package/hxt-xpath-8.5.4 (UweSchmidt)
02:31:28 <turiya> dmwit, i finally understand.. :)
03:19:35 * hackagebot derive 2.3.0.1 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.3.0.1 (NeilMitchell)
03:28:53 <etpace> Anyone here use leksah? When trying to build a package I'm getting: Setup: Leksah.cabal:4: Unknown field 'build-type', any ideas?
03:52:25 <login-luks> zipWith (\ x y -> x y) (map map (map (/) [64,28])) (repeat [4,2])
03:53:03 <login-luks> hi, is there a more sensible way to do something like this?
03:54:12 <login-luks> using the list monad doesn't wor either because it merges the result lists (implicit join)
03:54:17 <Jafet> @pl \xs ys -> zipWith (\ x y -> x y) (map map (map (/) xs)) ys
03:54:17 <lambdabot> zipWith id . map (map . (/))
03:59:23 <Jafet> @pl \f xs ys -> zipWith (\ x y -> x y) (map map (map f xs)) ys
03:59:23 <lambdabot> ((zipWith id . map map) .) . map
03:59:44 <ski> @tell edwardk "devil's bargain version of Not (Not (Not a)) -> Not a" being ?
03:59:44 <lambdabot> Consider it noted.
03:59:59 <ski> @type \f xs ys -> zipWith (\ x y -> x y) (map map (map f xs)) ys
04:00:00 <lambdabot> forall a b a1. (a1 -> a -> b) -> [a1] -> [[a]] -> [[b]]
04:00:18 <quicksilver> lambdabot: well, (\x y -> x y) is normally called ($)
04:00:26 <ski> > zipWith (\ x y -> x y) (map map (map (/) [64,28])) (repeat [4,2])
04:00:27 <lambdabot>   [[16.0,32.0],[7.0,14.0]]
04:00:32 <Jafet> @pl \f xs ys -> zipWith (\ x y -> x y) (map map (map f xs)) (repeat ys)
04:00:33 <lambdabot> flip flip repeat . (((.) . zipWith id . map map) .) . map
04:00:37 * ski didn't actually read the code ;)
04:00:52 <Jafet> Oh, the nice looking code was incorrect
04:01:03 <quicksilver> login-luks: well, (\x y -> x y) is normally called ($)
04:01:12 <quicksilver> (incorrectly addressed first time)
04:01:26 <theorbtwo> I do wonder how much it'd help to define things like not not x = x.  (And yes, I know, "Not" and "not" are very different things.
04:01:44 <ski> (maybe you meant `not (not x) = x' ?)
04:01:53 <theorbtwo> D'oh, yes.
04:02:01 <quicksilver> "map map (map (/) xs)" is "map (map . (/)) xs" which may or may not be easier to read
04:02:04 <Jafet> :t not
04:02:05 <lambdabot> Bool -> Bool
04:02:20 <ski> theorbtwo: what do you mean by "define things like" that ?
04:02:40 <ski> > let not (not x) = x in not `map` [False,True]
04:02:41 <lambdabot>   <no location info>: Parse error in pattern
04:03:26 <theorbtwo> ski: not is presumably defined as not True = False ; not False = True.  Adding an equation for not (not x) would allow the pattern matcher to optimize that case away.
04:03:40 <quicksilver> we have RULES for that, theorbtwo
04:04:08 <quicksilver> {-# GHC_RULES not (not x) == x #-} or something, I forget the exact syntax.
04:04:17 <theorbtwo> As special cases in the compiler, or as something accessable for the ... right.
04:04:29 <quicksilver> that's how list fusion works, and the specialisation stuff which makes primitive types perform reasonably OK
04:07:52 <ski> @type \f -> zipWith ($) . map (map . f)
04:07:53 <lambdabot> forall a b a1. (a1 -> a -> b) -> [a1] -> [[a]] -> [[b]]
04:08:18 <ski> @type (zipWith ($) .) . map . (map .)
04:08:19 <lambdabot> forall a a1 b. (a -> a1 -> b) -> [a] -> [[a1]] -> [[b]]
04:11:25 <soul9> hi
04:16:08 <Jafet> > [64,28] >>= return.(`fmap` [6,2]). (/) -- list monad!
04:16:09 <lambdabot>   [[10.666666666666666,32.0],[4.666666666666667,14.0]]
04:17:18 <Twey> > (`fmap` [6, 2]) . (/) <$> [64, 28]
04:17:19 <lambdabot>   [[10.666666666666666,32.0],[4.666666666666667,14.0]]
04:20:15 <Jafet> > (. [4, 5]) . (,) <$> [1, 2, 3]
04:20:16 <lambdabot>   [[(1,4),(1,5)],[(2,4),(2,5)],[(3,4),(3,5)]]
04:21:41 <zygoloid> > fmap (\o -> fmap (o/) [6,2]) [64,28]
04:21:42 <lambdabot>   [[10.666666666666666,32.0],[4.666666666666667,14.0]]
04:28:10 <mreh> :t (o/)
04:28:11 <lambdabot> Expr -> Expr
04:30:16 <login-luks> thanks, I think I'll go with that:
04:30:25 <login-luks> \ xs ys -> ( zipWith id . map (map . (/)) ) [64,65] $ repeat [2,4]
04:30:39 <login-luks> uup wrong thing
04:30:46 <mreh> linear least squares: w = (X'X)^-1 . X'y -- I can derive w, but I can't understand how you get the bias term
04:31:04 <mreh> my notes say you substitute x for (x,1) and w for (w,b)
04:31:05 <login-luks> (\ f xs ys -> zipWith ($) (map (map.f) xs) $ repeat ys)
04:34:44 <login-luks> Jafet: oh, that with the list Monad isn't bad either!
04:45:27 <ski> > (`map` [64,28]) $ \x -> (`map` [6,2]) $ \y -> x/y  -- yet another variant
04:45:28 <lambdabot>   [[10.666666666666666,32.0],[4.666666666666667,14.0]]
04:45:46 <ski> @let pamf = flip fmap
04:45:47 <lambdabot>  Defined.
04:46:10 <ski> > [64,28] `pamf` \x -> [6,2] `pamf` \y -> x / y
04:46:11 <lambdabot>   [[10.666666666666666,32.0],[4.666666666666667,14.0]]
04:46:52 <ski> login-luks : ^ how about that one ?
04:47:09 <ski> (btw, also note
04:47:11 <ski> > (/) <$> [64,28] <*> [6,2]
04:47:12 <lambdabot>   [10.666666666666666,32.0,4.666666666666667,14.0]
04:47:17 <ski>  which is not eactly the same)
04:50:46 <ski> > (<$> [6,2]) . (/) <$> [64,28]  -- hum, which way does this associate ?
04:50:47 <lambdabot>   [[10.666666666666666,32.0],[4.666666666666667,14.0]]
04:53:28 <ski> > ((<$> [64,28]) . ((<$> [6,2]) .)) (/)  -- more silliness
04:53:29 <lambdabot>   [[10.666666666666666,32.0],[4.666666666666667,14.0]]
04:54:25 * ski thinks that's possibly enough variants :)
04:56:12 <ski> > let (.:) = (.) . (.) in ((<$> [64,28]) .: (<$> [6,2])) (flip (/))  -- well, ok. one more
04:56:13 <lambdabot>   [[10.666666666666666,4.666666666666667],[32.0,14.0]]
04:56:34 * ski notes that needs `transpose', somewhere
05:11:56 <copton> hello. There is a broken link on http://www.haskell.org/learning.html and the referenced email address afie@cs.uu.nl bounces. So maybe somebody here can fix this. The link to "Tour of the Haskell Syntax" results in a 404.
05:15:27 * hackagebot hlint 1.6.21 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.6.21 (NeilMitchell)
05:30:10 <helino> hello everyone! when running my concurrent haskell program using MVars, I get this error message: "thread blocked indefinitely in an MVar operation". what does that mean?
05:32:16 <fasta> helino, probably that GHC proved deadlock?
05:32:36 <fasta> helino, which in turn means that you made a mistake.
05:32:46 <helino> fasta: ok, thanks
05:33:10 <helino> what i'm trying to do is to wait for all the threads I create using forkIO in the main function
05:33:37 <fasta> helino, the documentation has an example demonstrating that already.
05:34:16 <fasta> Hmm, it looks like hell freezed over seeing that someone dared to touch a debugger project again ;)
05:35:37 <bastl> Hey, is anyone aware of a printed (citeable) version of the stuff presented here http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category ?
05:41:55 <Gracenotes> typeclassopedia might contain something about Hask
05:44:17 <helino> fasta: I know, but I wanted to try my own solution :) would you mind take a look at this code, I don't understand why it enters deadlock? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24732#a24732
05:44:59 <fasta> helino, you also have to use the threaded run-time probably.
05:45:18 <fasta> helino, that is, do you pass -threaded?
05:45:22 <helino> fasta: yes
05:45:35 <helino> and i'm running with +RTS -N2
05:50:56 <fasta> helino, it appears to be correct. That said, I wrote something similar years ago, which did work (now there are libraries which do the same things).
05:51:19 <fasta> helino, you should just try to inline the take and puts to simplify the problem.
05:53:13 <helino> fasta: it is correct :) the problem was at another place in my code
05:53:19 <helino> fasta: thanks for your help!
05:53:20 <zygoloid> helino: it probably means that 'worker' exited without hitting the 'putMVar'
05:53:26 <zygoloid> ... oh :)
05:53:47 <fasta> helino, there is this mantra of pasting a minimal example which shows the problem, you know? It exists for a reason. :)
05:54:00 <FunctorSalad> hmm does "cabal -fblah" falls back to disabling blah on failure? or is there some other reason why my yi builds without gtk
05:54:04 <FunctorSalad> *fall
05:54:10 <zygoloid> often in building the minimal example you'll find the problem :)
05:54:16 <FunctorSalad> `cabal install -fblah', even
05:54:21 <moshisushi> it's called talking to the bear...
05:54:25 <helino> zygoloid: you're correct :)
05:54:42 <fasta> Everything is correct today. How wonderful!
05:54:58 <FunctorSalad> everything in its right place
05:55:26 <fasta> helino, also your "threadlist" is not a threadlist.
05:55:30 <moshisushi> FunctorSalad: kick ass nickname :>
05:55:40 <FunctorSalad> moshisushi: ty :)
05:55:51 <helino> fasta: i know but i was out names :)
05:55:58 <helino> synclist is perhaps a better name
05:56:16 <fasta> helino, synchronizing_variables for the non-Haskell inclined or mvars?
05:57:13 <helino> fasta: yep, that's better
05:58:37 * quicksilver would call it "mvs" (short for mvars) like "xs"
05:58:42 <quicksilver> keypresses cost money!
05:59:43 <moshisushi> quicksilver: reverse-engineering your old code cost money :p
06:00:15 <quicksilver> when it's obviously a list of MVars (obvious from the type, and the context)
06:00:21 <quicksilver> I hardly think the variable name adds anything
06:00:31 <quicksilver> however, if you prefer, I have an alternative suggestion
06:00:46 <quicksilver> EnterpriseBusinessVectorizationSynchronisationContainerFactory
06:01:07 <fasta> If we had IDEs that worked that could work.
06:04:34 <SamB_XP> fasta: it would lead to premature wrapage!
06:05:04 <fasta> SamB_XP, ?
06:05:25 <SamB_XP> you would run up against the right margin far too quickly
06:05:59 <fasta> SamB_XP, my bottom margin is very far away.
06:06:24 <fasta> Anyway, I think Scheme code is very trivial to read, which is why I write Haskell like that.
06:06:25 <quicksilver> fasta: I'm quite interested to read about hothasktags on the cafe
06:06:42 * hackagebot concurrent-extra 0.5 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.5 (BasVanDijk)
06:06:47 <quicksilver> if that works and I can integrate it into emacs I might actually start using short names and qualified imports
06:07:30 <ivanm> I didn't get the point of that
06:07:39 <ivanm> how does it differ from hasktags (which I don't use either)?
06:07:47 <quicksilver> by understanding nested scopes
06:08:03 <quicksilver> and imports
06:08:14 <quicksilver> so if a name exists in two places (like mapM_, for example)
06:08:18 <quicksilver> it can jump to the right one.
06:08:52 <ivanm> as in the right definition?
06:08:55 <quicksilver> hasktags is just primitive and textual, it can't distinguish between two different 'mapM_'s
06:08:58 <quicksilver> yes.
06:09:03 * ivanm currently uses imenu to jump to a definition in a module
06:09:11 <ivanm> or do you mean it will load up the correct file as well?
06:09:51 <fasta> quicksilver, but it doesn't derive types?
06:10:05 <quicksilver> no idea ;)
06:10:43 * hackagebot threads 0.1 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.1 (BasVanDijk)
06:34:03 <Igloo> Does anyone know how I can get the time in, for example, PST8PDT using the time package?
06:36:09 <SamB_XP> ???
06:38:14 <quicksilver> Igloo: as far as I know you have to build the timezone object by hand
06:38:41 <quicksilver> TimeZone ((-7)*60)) True "PDT"
06:39:22 <Igloo> quicksilver: But then I have to know whether they're in DST or not myself
06:39:27 <quicksilver> yes
06:40:00 <Jafet> DST is arbitrarily set by governments
06:40:05 <quicksilver> as far as I know there is no haskell interface to the TZ database
06:40:14 <roconnor> Igloo: how can you figureout what time a given time means without knowing if it is DST or not?
06:40:15 <Jafet> You could ask the posix
06:40:24 <quicksilver> (is that part of POSIX? I don't see it in System.Posix, at least)
06:40:28 <roconnor> Igloo: if I say it is 2:00 am, which 2:00 am do I mean?
06:40:41 <quicksilver> roconnor: he wants the computer to know
06:40:45 <Igloo> roconnor: My OS already knows the answer
06:40:50 <quicksilver> and computers do know, typically.
06:40:55 <roconnor> how do computers know?
06:41:03 <quicksilver> because they have a great big database of timezone changes
06:41:07 <roconnor> it is the first 2:00 am or the second 2:00 am that day?
06:41:08 <quicksilver> kept up to date manually.
06:41:22 <roconnor> 2:00 am occurs twice in one day once a year
06:42:02 <Jafet> roconnor, huh?
06:42:07 <quicksilver> right. Not the problem I thought we were trying to solve though.
06:42:09 <Igloo> roconnor: It knows because of stuff in /usr/share/zoneinfo
06:42:28 <quicksilver> Jafet: the day that DST switches back off
06:42:46 <Jafet> It always happens at 2:00 am?
06:42:49 <quicksilver> Jafet: time goes 0100,0101,0102,....0159,0200,0101,....
06:42:50 <quicksilver> yes.
06:43:15 <Jafet> I've never been subjected to this strange timekeeping mechanism
06:43:40 <Igloo> Jafet: Where do you live?
06:43:42 <roconnor> Igloo: do you just want to display a given time?
06:43:49 <roconnor> Igloo: and not parse?
06:43:59 <roconnor> Jafet: lucky
06:44:01 <Jafet> In a poor country. We can't afford DST
06:44:07 <Jafet> Costs too much to license it
06:44:19 <ivanm> you can't afford daylight saving time?
06:44:46 <Igloo> roconnor: I need to know if the current time is earlier or later than 2:00 PST8PDT
06:44:58 <roconnor> ivanm: imagine the enormus cost to the economy when Bush decided to change DST in North America to save a few pennies.
06:45:09 <roconnor> all that software that needed to be changed
06:45:26 <ivanm> ummmm.... was it really that hard? >_>
06:45:28 <roconnor> Igloo: that sounds like an impossible task.
06:45:43 <Igloo> Why?
06:45:45 <roconnor> ivanm: ... I guess I don't really know.
06:45:58 <Jafet> Only for software that does not use something sane, like UTC time.
06:45:59 <ivanm> *shrug* I don't really see the point of DST anyway
06:46:33 <roconnor> Igloo: because 2:00 PST8PDT is ambigous one day a year.  It can refer to two different times 1 hour appart.
06:46:52 <roconnor> unless I'm misunderstanding something here.
06:46:53 * hackagebot nptools 0.1 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.1 (NicolasPouillard)
06:47:00 <Igloo> roconnor: I'm not too fussed about what happens on that edge case
06:47:17 <Igloo> roconnor: What I'm actually trying to do is to schedule a GHC build at 2am localtime
06:48:26 <roconnor> heh, you might save some grief by starting at 2:01 am :D
06:49:03 <roconnor> though perhaps there is only one 2:00 am
06:49:05 <Igloo> roconnor: Well, 4am if you prefer. I'm not worried about the day the time changes, I'm worried about the other 364
06:49:14 <roconnor> 1:59 is followed by 1:00
06:49:35 <Igloo> i.e. I want the build time relative to UTC to change by 1 hour for half the year
06:49:43 <roconnor> Igloo: anyhow, I guess the point is to show why it isn't really provided by the library
06:50:36 <Igloo> roconnor: I don't think that's true, because there are functions to do it for the current timezone. You just can't do it for an arbitrary timezone
06:51:34 <roconnor> Igloo: what do you mean by current timezone?
06:51:51 <roconnor> sure, given any specific offset from UTC you can do the computation.
06:52:46 <Igloo> roconnor: e.g. Data.Time.getZonedTime says "2010-04-07 14:52:00.387481 BST" for me
06:53:20 <dankna> a timezone, however, is more than an offset.  there are varying DST policies, there are leap seconds, ...
06:53:22 <Igloo> i.e. it will use either GMT or BST depending on whether the UK is in daylight saving time or not
06:53:39 <SamB_XP> I don't think leap seconds are part of time zones ?
06:53:44 <dankna> hm, perhaps they're not
06:53:59 <dankna> but DST is relatively complicated, anyhow.
06:54:06 <SamB_XP> I think most politicians aren't smart enough to even KNOW about leap seconds
06:54:09 <dankna> haha
06:54:10 <dankna> point taken
06:54:20 <Jafet> Only UTC has leap seeconds, anyhow
06:54:31 <Jafet> It has its own math ugliness for this reason
06:54:57 <SamB_XP> I figured everyone else must have them too then ?
06:55:00 <Igloo> It may be complex, but the computer already knows the answer...
06:55:08 <roconnor> there is no parsing version getZoneTime
06:56:33 <roconnor> perhaps all Igloo should do is run getZonedTime and check to see if it after 2:00 or not
06:57:02 <Igloo> roconnor: But that tells me about /my/ timezone. I need to know about other timezones
06:57:23 <dankna> can you maybe kludge it by setting your timezone to the timezone you need, temporarily?
06:57:55 <SamB_XP> in Haskell? are you serious?
06:57:56 <roconnor> Igloo: okay, I guess I understand now
06:58:11 <Twey> withTimeZone ;)
06:59:04 <roconnor> Igloo: I suppose you want a general conversion function from UTCTime to ZonedTime given a time region.
06:59:23 <Igloo> roconnor: Right
06:59:56 <roconnor> do you want one that specifically uses the /usr/whaterver/thingy? or one that makes use of an updated hackage module?
07:00:02 <Igloo> Setting TZ and TIMEZONE doesn't do it, so I don't know how I could kludge it by setting the timezone
07:00:06 <Jafet> Make a binding to tz
07:00:47 <Igloo> roconnor: I don't really care how it works, but something using the system timezone database is more likely to remain up-to-date
07:01:00 <roconnor> though it would be less portable
07:01:15 <Igloo> Well, it could work in different ways on different platforms
07:01:19 <SamB_XP> Igloo: as long as you aren't on, oh, an old version of Windows ...
07:01:20 <roconnor> anyhow I guess I don't know one that exists, but it would probably be reasonable to write.
07:01:57 <roconnor> Though if it reads the tzdata it will have to be in the IO monad
07:01:59 * hackagebot base-unicode-symbols 0.2 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2 (RoelVanDijk)
07:02:01 * hackagebot containers-unicode-symbols 0.3 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3 (RoelVanDijk)
07:02:44 <Igloo> I'm getting the current time, so need to be in IO anyway
07:02:52 <gio123> hi all, does somebody knows what is term is in beta eta long normal form?
07:04:36 <quicksilver> Igloo: if you're curoius how it works, the implementation is in time-1.1.4/cbits/HsTime.c
07:04:53 <gio123> hi all, does somebody knows what is term is in beta eta long normal form?
07:05:35 <quicksilver> Igloo: on unix it calls localtime(3) and looks inside the struct tm returned.
07:05:54 <quicksilver> Igloo: it *should* be affected by TZ, according to what I'm reading.
07:06:01 <quicksilver> (the environment variable, I mean)
07:06:29 <roconnor> is modifying the TZ environment variable thread safe?
07:06:34 <roconnor> :D
07:06:48 <roconnor> oh, you should spawn a new process first then.
07:07:25 <Igloo> Oh, hmm. setting TZ before running ghci does work, but 'System.Posix.setEnv "TZ" "PST8PDT" True' doesn't
07:07:39 <SamB_XP> roconnor: er, don't you mean spawn a new process WITH a new value of TZ ?
07:07:50 <roconnor> yes, that is what I meant
07:07:58 <SamB_XP> oh, wait, that's Windows-think
07:08:03 <roconnor> I think there is a version of exec that lets you pass env variables
07:08:09 <SamB_XP> there is!
07:08:43 <SamB_XP> (it's just that associating the process creation with the running of a new program that is Windows think)
07:09:22 <quicksilver> Igloo: system.posix.setenv is probably modifying a copy of the environment which is given to subprocesses not the running process's *actual* environment
07:09:25 <quicksilver> I imagine.
07:09:45 <SamB_XP> quicksilver: does it call C's setenv ?
07:09:51 <quicksilver> I don't know.
07:11:07 <roconnor> where is system.exec?
07:11:39 <roconnor> SamB_XP: can you create a new process without running a new program?
07:12:28 <Jafet> Define running a program
07:12:32 <Jafet> You can fork
07:13:27 <Twey> In fact you have to, in C
07:13:52 <quicksilver> SamB_XP: actaully, it does call setenv
07:14:08 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.4.0.0/src/System-Posix-Env.html#setEnv
07:14:12 * quicksilver wonders why it didn't work then.
07:14:21 <quicksilver> glibc caches TZ data at process load, or something daft?
07:14:50 <idnar> Twey: I guess you mean "in POSIX" or something?
07:15:12 <Twey> I thought that was implied
07:15:52 <roconnor> ah, system.Process
07:16:03 <Twey> My wording stemmed from the consideration that higher-level languages are likely to provide an abstraction to fork and exec in the same call (since it's a common case)
07:16:24 <quicksilver> especially since GHC's fork doesn't really work
07:16:33 <quicksilver> it's hard to use it with confidence :)
07:17:02 <Twey> It doesn't?
07:17:12 <roconnor> quicksilver: is there a better way to do this than using somthing like System.Process.runProcess?
07:17:17 <roconnor> is forkOS better?
07:17:22 <quicksilver> forkOS is unrelated
07:17:28 <quicksilver> forkOS just forks a haskell thread
07:17:32 <quicksilver> I would use System.Process.*
07:17:34 <Twey> No, that's forkIO
07:17:40 <Twey> forkOS forks a system thread
07:17:52 <quicksilver> counting to 10 slowly.
07:17:52 <Twey> (but not a process)
07:17:53 <mornfall> Twey: no, a bounded thread is the correct term :)
07:17:57 <roconnor> and a system thread will have it's own Environment, or is that OS specific?
07:18:03 <mornfall> or bound or whatever
07:18:04 <Twey> Fine :þ
07:18:07 <quicksilver> Twey: No, you are wrong.
07:18:15 <quicksilver> Twey: forkOS forks a haskell thread
07:18:21 <quicksilver> and is unrelated to System.Process.*
07:18:35 <quicksilver> it just happens to fork a bound one.
07:18:37 <roconnor> quicksilver: what will call the fork system call?
07:18:40 <Twey> It certainly is unrelated to System.Process.*
07:18:58 <quicksilver> roconnor: many of the calls in System.Process.* calls fork() to do its work
07:19:08 <quicksilver> (at least, they will on a POSIX system)
07:19:16 <quicksilver> but calling fork() directly is a bit hairy
07:19:23 <roconnor> ah right
07:19:23 <Twey> But I'm fairly sure that forkOS forks an OS thread (hence the name), which is its primary distinction from forkIO, which forks a bound thread (thanks, mornfall ☺)
07:19:24 <roconnor> haskell
07:19:26 <mornfall> It so happens that fork() is not quite available on all platforms...
07:19:32 <quicksilver> because, the GHC RTS isn't really decided to be forked
07:19:38 <quicksilver> Twey: no.
07:19:44 <quicksilver> Twey: it forks a haskell thread, which is bound.
07:19:53 <mornfall> Twey: No... forkIO forks a haskell thread, forkOS differs in that the thread is bound.
07:19:59 <roconnor> quicksilver: what's the diff between forkIO and for OS?
07:20:05 <roconnor> in your opinion :D
07:20:07 <quicksilver> roconnor: that forkOS fors a bound thread.
07:20:16 <mornfall> roconnor: forkOS is less efficient and only useful for weird FFI stuff. :)
07:20:45 <quicksilver> s/decided/designed/ (4 lines back)
07:20:50 <Twey> Ah, I suppose that is a useful distinction to make, as an OS thread might be reused?
07:20:53 <mornfall> I.e. you usually don't need it. Unless you understand the difference, don't use it. Haddocks for forkOS explain what you need to know to use it, too.
07:21:10 <roconnor> quicksilver: I read it that way :D
07:21:50 <quicksilver> you need forkOS if you are calling foreign libraries which use thread-local state
07:21:56 <quicksilver> (in the underlying OS sense of "thread-local")
07:22:09 <roconnor> okay
07:22:15 <quicksilver> most GUI libraries do that.
07:22:20 <quicksilver> the 'main' thread is *always* bound
07:22:24 <roconnor> anyhow, we are all agreed then that Igloo should use System.Process.runProcess
07:22:37 <quicksilver> so you can often avoid using forkOS and instead just make sure your GUI calls come from the main thread
07:22:50 <zygoloid> Twey: the haskell thread created by forkIO may execute IO actions on any OS thread. the haskell thread created by forkOS will only execute IO actions on a single OS thread.
07:23:10 <Twey> Aha.
07:23:14 <Saizan_> Twey: yeah, the fact that an haskell thread is bound to some OS thread doesn't mean that other haskell threads won't run on that OS one as well
07:23:25 <Twey> *nod*
07:25:26 <Vanadium> So the number of OS threads is entirely defined by that RTS option and you do not actually get to make more at runtime?
07:26:56 <quicksilver> I think you get a couple more, in fact
07:27:02 <quicksilver> an IO manager thread at least
07:27:09 <quicksilver> but basically, yes, what Vanadium said.
07:27:20 * ksf wants class aliases
07:27:50 <Twey> Apparently there's a preprocessor
07:27:50 <ksf> heck it's virtually the only time I ever use UndecidableInstances
07:27:51 <quicksilver> I think there is an FFI thread too.
07:27:57 <Vanadium> So if calling blocking FFI functions does not block all Haskell threads, does the runtime spawn more OS threads to execute blocking FFI function calls on?
07:28:11 <Vanadium> Oh, they are just sequential?
07:28:19 <quicksilver> no, I think you're right.
07:28:26 <quicksilver> I think it's potentially many
07:28:48 <quicksilver> (up to one per currently running FFI call)
07:29:13 <quicksilver> I look to JaffaCake for confirmation :)
07:29:41 <jmcarthur> surely not if it's a bound thread
07:29:47 <JaffaCake> Vanadium: the RTS spawns more threads, yes
07:30:14 <JaffaCake> in fact, it executes the FFI call on the current thread, and spawns another thread to carry on running Haskell code
07:30:20 <Vanadium> Neat
07:30:28 <quicksilver> JaffaCake: so total number of OS threads is 1 (IO manager) + N (RTS -N number) + M (number of FFI calls) ?
07:30:37 <JaffaCake> Vanadium: yes, it is :)
07:31:05 <JaffaCake> quicksilver: + number of forkOS threads
07:31:44 <JaffaCake> plus one for the main thread
07:32:42 <JaffaCake> oh, and the IO manager doesn't actually get its own OS thread, but it makes FFI calls so in practice it gets an OS thread
07:32:57 <roconnor> heh, the timezone data in zoneinfo seems to only go up to 2038
07:33:18 <roconnor> I guess unix is screwed after then in any case.
07:33:26 <Vanadium> I thought the main thread was counted within the +RTS -N number, whoops
07:33:55 <Vanadium> and after previous discussion I thought the forkOS threads had to share those threads too
07:35:55 <Igloo> There's definitely some caching going on: http://paste.debian.net/67867/
07:37:14 <JaffaCake> Vanadium: there are two kinds of OS threads: bound threads and worker threads.  There is one worker thread per CPU normally, more are created on demand by FFI calls.  The main thread and forkOS threads are bound threads.
07:37:53 <Vanadium> Does a thread being bound only mean that all its FFI happens on a specific OS thread, or that the bound thread is the only thread running FFI things on that particular OS thread?
07:38:03 * ksf suspects class aliases not being implemented yet is part of avoiding success...
07:38:10 <JaffaCake> Vanadium: the former
07:38:19 <Igloo> Aha, tzset() is the answer
07:38:40 <JaffaCake> Vanadium: well, actually both are true, I suppose
07:40:10 <quicksilver> JaffaCake: so bound threads never get re-used in any way?
07:40:22 <quicksilver> JaffaCake: neither other work, nor other FFI, will ever be scheduled onto a bound thread?
07:40:45 <ksf> "One reason I've failed to do so is because I have not come under enough
07:40:45 <ksf> pressure! If I thought there were dozens of people slavering at the chops for
07:40:45 <ksf> class aliases, that would put it more firmly on my radar." -- spj
07:40:47 <ksf> let's get going.
07:40:51 <JaffaCake> quicksilver: right, you should think of bound OS threads as belonging to the world outside Haskell
07:41:05 <JaffaCake> an OS thread calling into Haskell becomes a bound thread
07:41:24 <JaffaCake> forkOS is implemented as create thread; call Haskell; exit
07:42:23 <JaffaCake> this explains why the main thread is bound: because the C main() calls into Haskell
07:44:29 <Vanadium> JaffaCake: Aha, bound threads get created by calling a "blocking FFI function" that is really just the thread's IO action?
07:44:59 <Vanadium> err, I mean in runInBoundThread
07:45:18 <JaffaCake> yes
07:45:56 <JaffaCake> every call to a Haskell function from C creates a Haskell thread bound to the OS thread that made the call
07:46:23 <Twey> ksf: You contact him, and I'll get slavering
07:46:56 <quicksilver> I thought some smart person in this channel pointed out a flaw in class aliases
07:47:08 <quicksilver> however, please go ahead anyway ;)
07:47:11 <Twey> What flaw was that?
07:47:21 <quicksilver> I've have said, if I could remember :-/
07:47:48 <quicksilver> I'll join in the slavering if it helps.
07:47:53 <Twey> Heh, okay.
08:05:26 <freiksenet> hello
08:05:52 <freiksenet> I was thinking about one idea about type inference, I wonder if yoi can critisize it for me. It seems neat, but I definetly missed smthing
08:06:37 <freiksenet> why haskell inference doesn't automatically infer union types? imagine purely hypotetical function (\x -> if x = 1 then 2 else "bar")
08:06:42 <freiksenet> purely hypotetical
08:06:57 <roconnor> haskell doesn't have union types
08:07:05 <freiksenet> haskell will say that it is a bad function, why it doesn't infer it as Int -> Int | String
08:07:12 <freiksenet> wrong term, algebraic types
08:07:37 <roconnor> Int | String isn't a valid data declaration
08:07:44 <freiksenet> I know.
08:07:44 <roconnor> you need to tag them with constructors
08:08:06 <Jafet> Haskell is nominatively typed.
08:08:15 <maltem> I guess the question is more like "why does Haskell not have union types"
08:08:18 <freiksenet> I know that too, imagine you could declare "anonymous" types.
08:08:19 <sykopomp> I think the question is what kind of effect that would have on the type system, if it _were_ possible.
08:08:23 <Jafet> There is the Either type, which does what you want.
08:08:38 <Jafet> But it's ugly
08:08:49 <roconnor> sykopomp: it would possibly make everything typecheck
08:08:54 <ksf> ...the main problem seems to be pattern matching.
08:09:02 <freiksenet> sykopomp got it right, that's my question.
08:09:14 <Jafet> What's a "union type", maltem?
08:09:20 <sykopomp> roconnor: only until you start constraining the types with signatures.
08:09:23 <Jafet> Haskell has sum types all over the place, if that's what you mean.
08:09:33 <Jafet> And product types (records)
08:09:44 <freiksenet> hm, why Foo = Bar | Zuu isn't a union type?
08:09:46 <freiksenet> btw
08:09:46 <sykopomp> roconnor: so you could have a dynamic system during development that accepts whatever types you give it, and you can start constraining it as you experiment.
08:09:47 <roconnor> Jafet: a union type is like a tagless sum types
08:09:49 <sykopomp> no?
08:10:02 <roconnor> perhaps
08:10:03 <ksf> it gets problematic with polymorphic variants alone, union types would be much, much worse.
08:10:12 <Jafet> roconnor, what's tagless?
08:10:20 <roconnor> Jafet: without constructors
08:10:28 <sykopomp> ksf: pattern matching?
08:10:30 <roconnor> ya, like polymorphic varients, but even more crazy
08:10:31 <ksf> yep
08:10:39 <ksf> or rather, type inference wrt. patterns.
08:10:42 <freiksenet> ok, so union types are algebraic types without constructors?
08:10:44 <maltem> Jafet, I admit that I don't know any language that has (tagless) union types (subtyping with unsafe casts does not count)
08:10:50 <Jafet> roconnor, then it would no longer be nominative...
08:11:00 <roconnor> Jafet: what is nominative?
08:11:11 <sykopomp> ksf: Pattern matching could just not work with unions and require you to have individual cases for each type within the union, though.
08:11:14 <freiksenet> ksf: could you elaborate?
08:11:16 <Jafet> Based on names ("tags")
08:11:27 <Jafet> I've not used ML much, so I won't comment further.
08:11:36 <freiksenet> ML has union types?
08:11:46 <Jafet> No idea.
08:11:55 <fax> freiksenet of course
08:11:58 <ksf> ml as polymorphic variants
08:12:05 <ksf> ...but those have to be declared to extend one another.
08:12:10 <roconnor> freiksenet: ocaml has polymorphic varients
08:12:15 <Jafet> It all sounds icky to me.
08:12:32 <jmcarthur> Twey: i'd rather we get constraint synonyms and constraint families than class aliases. is there an argument for aliases over constraint families?
08:12:38 <freiksenet> ok, thanks a lot guys.
08:12:44 <ksf> freiksenet, the problem is figuring out whether something's a pattern match failure or an actual typing restraint.
08:12:58 <ksf> ...which confluates run-time and compile-time decisions.
08:13:01 <jmcarthur> oh i actually mean to target that to ksf
08:13:20 <ksf> jmcarthur, dunno.
08:13:26 <freiksenet> ksf: ok, I see
08:13:35 <Twey> jmcarthur: Pass — haven't seen that paper yet.  Reading now.
08:13:38 <ksf> I just don't want to write 100 superclass contstraints on each and every one of my functions.
08:14:06 <ksf> ...and I didn't write _any_ of those classes!
08:14:28 <ksf> well ok, one.
08:14:49 <sykopomp> ksf: I think this would mostly be useful for interactive development. Ideally, you'd end up with specific, named types everywhere, with type signatures.
08:15:06 <twink> Class aggregation language features?
08:15:06 <ksf> my current solution is class (Foo a, Bar b) => FooBar a b; instance (Foo a, Bar b) => FooBar a b
08:15:23 <jmcarthur> i guess class aliases can be a bit more syntactically convenient for some cases
08:15:31 <ksf> sykopomp, but you don't need to make union types a language feature to do that
08:15:59 <jmcarthur> ksf: that is an encoding of constraint synonyms :)
08:16:08 <ksf> yes.
08:16:15 <sykopomp> ksf: don't you have to if you cba to make a new type on the spot for every function you write?
08:16:27 <ksf> there's been some syntactic confusion in the past, and I fell for it, too.
08:16:32 <jmcarthur> sucks to use undecideable instances just for that though
08:17:26 <ksf> it sucks even more to put one or two classes in a module named Foo.Undecidable .
08:17:48 <ksf> http://hackage.haskell.org/trac/ghc/ticket/3547
08:17:57 <ksf> (the syntax sucks, I admit)
08:18:12 <jmcarthur> the paper points out that class aliases are not at odds with constraint synonyms. the former could be considered a syntax sugar on top of the latter
08:18:55 <maltem> I take it that the difference between constraint synonyms and class aliases is that you can write instances for the latter?
08:19:05 <jmcarthur> ksf: that's a nice idea, but i think we could come up with something more general
08:19:24 <jmcarthur> maltem: essentially. constraint synonyms also lead naturally to constraint families, though
08:19:37 <ksf> jmcarthur, that's not to replace class aliases.
08:19:45 <jmcarthur> ksf: i know
08:19:57 <ksf> it's also very useful for than one type family decl among thousands that happens to have nested calls.
08:20:19 <jmcarthur> ksf: but i think it would be nice to be able to treat certain extensions as pragmas attached to various constructs of the languages rather than an on/off switch
08:20:33 <jmcarthur> *language
08:21:09 <ksf> type instance {-# UNDECIDABLE #-} Foo a = Bar
08:21:54 <jmcarthur> or something
08:21:58 <ksf> I think both syntaxes have their benefits.
08:23:19 <jmcarthur> {-# UNDECIDABLE #-} instance (Foo a, Bar b) => FooBar a b where ...
08:23:38 <fax> o_o
08:23:45 <jmcarthur> or somewhere in there
08:25:19 <jmcarthur> {-# EXTENSIONS FooBar   UndecidableInstances, MultiParamTypeClasses #-}; instance (Foo a, Bar b) => FooBar a b where ...
08:31:34 <ksf> @src many
08:31:34 <lambdabot> Source not found. My pet ferret can type better than you!
08:32:33 <zygoloid> instance (Foo a, Bar b) => FooBar a b {-# JFDI #-} where ...
08:35:17 <orjan_> I'm trying to install wxcore and wx with cabal." I get error setup: Missing dependencies on foreign libraries:" To mee ir seems the libs are in /usr/lib. This on debian squeeze.
08:35:40 <ksf> you need the -dev version of those debian packages
08:35:57 <ksf> that is, the headers have to be in /usr/include.
08:36:30 <orjan_> like in: ii  libwxgtk2.8-dev                                 2.8.10.1-3                 wxWidgets Cross-platform C++ GUI toolkit (GTK+ development)
08:36:40 <ksf> looks like the right one
08:36:50 <ksf> I'm not on debian, though.
08:37:27 <ksf> you might want to consider switching to gentoo, instead
08:37:34 <jmcarthur> i hate how debian has separate dev packages
08:37:44 <orjan_> It's asking for wx_baseu-2.8 among others
08:38:05 <jmcarthur> heh, ksf and i are going to get into it again over whether somebody should switch to gentoo or arch :P
08:38:27 <sykopomp> arch gets my vote.
08:38:32 <jmcarthur> i like both
08:38:40 <maltem> What's wrong with debian's dev packages? I do realize seperating the headers out isn't usually worth the trouble
08:38:43 <sykopomp> I used to run gentoo. I'm happy I don't anymore.
08:38:58 <jmcarthur> sykopomp: same here, but i don't have any specific complaints about it, really
08:39:09 <jmcarthur> it's a bit more tedious sometimes
08:39:12 <ksf> maltem, what's wrong with asking a question? usually you give the answer, yourself.
08:39:16 <jmcarthur> but sometimes that's worth it
08:39:26 <orjan_> but libwx_baseu-2.8.so,0 is in /usr/lib
08:39:26 <sykopomp> jmcarthur: unnecessary build time is pretty annoying.
08:39:43 <sykopomp> and builds that break on your particular system are also annoying :)
08:39:52 <sykopomp> I like optionally building packages.
08:39:55 <sykopomp> Arch gets me that.
08:39:59 * sykopomp leaves it at that.
08:40:04 <jmcarthur> yeah, i like that as well
08:40:58 <maltem> ksf, I was thinking jmcarthur had more to say about it, due to his saying he "hates" them
08:41:12 <jmcarthur> maltem: oh, sorry, i missed that
08:41:30 <jmcarthur> maltem: i just find them insanely annoying. unexpected, hard to locate
08:41:50 <quicksilver> jmcarthur: how can you say they're unexpected, when you've clearly discusse this before
08:41:51 <jmcarthur> in combination with the other gripes i have about debian, i "hate" them ;)
08:41:54 <maltem> ok
08:42:01 <quicksilver> either you have a really bad memory, or you should expect them by now :)
08:42:23 <jmcarthur> quicksilver: it's unexpected because i usually have no idea what dev packages i've installed relative to the "normal" packages i've installed
08:42:35 <quicksilver> they serve two purposes, (1) to cut down on disk space and (2) to cut down on un-necessary dependency creep.
08:42:47 <quicksilver> (1) is not relevant to many people these days.
08:42:54 <quicksilver> but it was very important back in the day.
08:43:08 <quicksilver> 2 still has some utility.
08:43:21 <jmcarthur> (2) seems kind of funny to me considering how many packages usually get installed on a debian system compared to an arch system
08:43:28 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24735#a24735   <--- _that_ is how iteratees are meant to be used.
08:43:42 <ksf> including trasparent splice (that's sendfile/rcvfile) support
08:44:00 <danr> what is cw8 and w8c?
08:44:08 <ksf> Word8->Char
08:44:13 <orjan_> ok any hints on what more to check?
08:44:14 <danr> ok
08:44:35 <stevenmarky> where is WrappedByteString from?
08:44:43 <ksf> Data.Iteratee
08:45:17 <quicksilver> ksf: looks nice. Do you have any performance metrics?
08:45:26 <ksf> not yet
08:46:06 <quicksilver> it is my informal experience that code with lots of symbols capitalised likE thiS and lots of point free code will be very fast
08:46:09 <quicksilver> and written by dons.
08:46:17 <quicksilver> evidently you're a counterexample to the second part :)
08:46:36 <ksf> the first problem being <|> still being broken if one of both sides is any iteratee instead of a parser primitive, and the second that I don't have more than toy code written in it.
08:46:40 <maltem> ksf: Like attoparsec?
08:47:06 <ksf> attoparsec's <|> is broken?
08:47:43 <arw_> i'm installing haskell-platform in some (nfs-shared) directories with paths like /local/haskell-platform-20(09|10|..)
08:47:52 <maltem> ksf, no, I wasn't quick enough, I was asking if that way of doing iteratee I/O is comparable to attoparsec
08:47:55 <ksf> yoctoparsec has two modes: non-backtracking with left-factoring (the default) and non-backtracking without left-factoring (that's what's broken)
08:48:21 <ksf> you can't run arbitrary iteratees inside an attoparsec parser
08:48:40 <arw_> is it possible to configure cabal in a way so that i just need to type something like "cabal install --into=haskell-platform-2010 something"?
08:49:04 <arw_> i know about --local and --global, but can this be extended?
08:49:09 <ksf> also, I think it might backtrack in some situations.
08:50:03 <maltem> ksf, what does qualify as an "arbitrary iteratee"? Do you mean that it's not a transformer?
08:50:12 <ksf> otoh, attoparsec is most likely to be the better choice if your grammar is complex, or if you need more than abysmal error reporting
08:50:44 <ksf> parseI has a type that looks almost like EnumeratorN
08:50:55 <maltem> (It backtracks without being asked to do so? That would be not so nice.)
08:51:03 <ksf> ...but you can nest iteratees in parsers in iteratees in parsers in iteratees
08:51:35 <ksf> I would make them one and the same adt, but I like having to lift iteratees into the parser so I know which <|> I'm using.
08:52:23 <maltem> I was thinking that an attoparsec parser *is* an iteratee (it doesn't import Data.Iteratee, but still)
08:52:35 <ksf> ...because the parser's <|> is O(log choices) per input character, and iteratee's <|> is O(2)
08:52:59 <maltem> ah
08:53:04 <ksf> ...well, it just runs both iteratees and doesn't left-factor
08:53:06 <jmcarthur> hmm... you know what i want in cabal? a way to implicitly expose other packages from one package. it would facilitate metapackages  (build-depends: haskell-platform == 2010.*) or whatever... it would also be nice for things like GLUT so that it can automatically expose OpenGL, StateVar, etc. without you having to explicitly depend on them
08:53:50 <ksf> as for left-factoring you have to transform the parser input-token wise, and iteratees can consume more than one of those.
08:54:20 <ksf> jmcarthur, you mean... package synonyms?
08:54:40 <ksf> can you define new modules in package aliases?
08:56:29 <jmcarthur> ksf: yes, package synonyms!
08:57:04 <twink> O(2) is O(1)
08:57:36 <ksf> yes
08:58:05 <ksf> well that's O(choices) vs O(log choices)
08:58:43 <jmcarthur> ksf: yeah it would be nice to still be able to define new modules in these packages, so they are not strictly synonyms
08:59:10 <theorbtwo> While the O() notation's rules say that O(1) and O(2) are the same, that does not mean that you should neccessarly ignore the difference.
08:59:19 <jmcarthur> maybe an exposed-packages field in the cabal file
08:59:24 <maltem> jmcarthur, sounds interesting enough to me to file a ticket about
08:59:29 <jmcarthur> to go alongside exposed-modules
08:59:53 <arw_> theorbtwo: yes you should. O()-notation is just wrong for that purpose.
08:59:58 <ksf> forall n. log n < 64, anyway.
09:00:08 <ksf> so O(log n) == O(1)
09:00:26 <maltem> theorbtwo, well O(1) and O(2) *are* the same :p
09:00:50 <maltem> ksf, "for all interesting n"?
09:00:59 <theorbtwo> maltem: You have a choice of two algorithms.
09:01:02 <arw_> theorbtwo: thats the same as saying "just because 2+2 equals 4, that doesn't mean you should ignore the difference". but thats the whole point of "equals".
09:01:11 <ksf> for all that fit into memory
09:01:21 <twink> Say that f(n) = g(n) + O(h(n)) etc.
09:01:33 <theorbtwo> One takes one second to operate, always.  One takes two seconds to operate.
09:01:38 <theorbtwo> Which one is the better choice?
09:01:39 <maltem> theorbtwo, oh *that* difference
09:02:22 <arw_> that is a constant factor. not an asymptotic behaviour.
09:02:32 <arw_> O-notation just tells you the latter.
09:02:35 <maltem> > log (10^100)
09:02:36 <lambdabot>   230.25850929940458
09:02:41 <maltem> Hah!
09:02:55 <ksf> hmmm. <|>ing two side-effecting iteratees is of course interesting.
09:03:04 <FauxFaux> > log(10^100)/log(10)
09:03:05 <lambdabot>   100.0
09:03:39 <theorbtwo> Log with unspecified base tends to be base e.
09:04:06 <ksf> I'd write ld, but everyone else in CS used log.
09:04:18 <theorbtwo> I often find this interesting, since when I do logs, I almost always want base 2 or 10, not e.
09:04:42 <ksf> and you _can_ make that O(log n) O(1) with the current interface, btw.
09:04:59 <ksf> you just have to supply a perfect hash.
09:05:10 <theorbtwo> arw_: Which is another reason, BTW, that slavish worship of the cult of big O is a bad idea; it only tells you about behavior when your workload is above the crossover point.
09:05:42 <theorbtwo> Once you get to that point, the bits of your implementation that you didn't compute often are more important.
09:06:00 <theorbtwo> IO.  Possibly swapping, almost certianly not fitting in cache.
09:06:15 <quicksilver> arw_: not so.
09:06:25 <arw_> theorbtwo: yes, that is correct. for a practical implementation, O-notation is far less relevant than for theoretical reasoning about algorithms.
09:06:33 <quicksilver> even though 2+2 = 4, '2+2' and '4' are quite different syntactic terms
09:06:49 <quicksilver> which is just a pedantic way of pointing out that there is more then one sense of equality.
09:06:56 <quicksilver> and sometimes we communicate well even when we abuse notation
09:07:05 <quicksilver> ...indeed we communicate well *because* we abuse notation.
09:07:17 <Mathnerd314> I would argue that (2+2) and (4) are equivalent, however
09:07:45 <arw_> and sometimes everything breaks because somebody abused notation too much and somebody else misunderstood.
09:07:46 <Mathnerd314> assuming the language implements arithmetic
09:07:59 <quicksilver> arw_: sure. communication isn't perfect.
09:08:06 <quicksilver> let's not throw out the baby with the bath water.
09:08:21 <quicksilver> what ksf - and then theorbtwo - were trying to communicate were interesting things, notation or not.
09:09:00 <xerox> just take a book on logic from your library for a formal treatment
09:10:34 <Jafet> Hm. Haskell has no expmod?
09:11:10 <jmcarthur> maltem: http://hackage.haskell.org/trac/hackage/ticket/654
09:11:30 <xerox> e.g. Kunen - Set Theory, Ch.I, §14, Formalizing the metatheory.
09:13:43 <arw_> hm. when the configure/make of the haskell-platform says 'registering in the global package database'. will that be somewhere in the --prefix of ghc or haskell-platform or in some other general location/
09:14:14 * quicksilver prefers Quine, but can't find the article name
09:14:31 <quicksilver> arw_: as far as I know, haskell-platform doesn't go anywhere special
09:14:42 <quicksilver> it goes in either --local or --global as normal for anything using cabal
09:14:52 <quicksilver> (IIRC which one by default depends on your OS?)
09:15:49 <dcoutts> quicksilver: fyi, the default is --user on all OSs as of cabal-install-0.8.2, but people's existing config files are not changed, so only new users will notice
09:15:52 <arw_> its a little special around here. standard debian stable, but with a homebrew system of software installations under /local.
09:15:59 <quicksilver> dcoutts: thank you.
09:16:13 <quicksilver> dcoutts: I like to know so can I answer questions correctly here ;)
09:16:25 <maltem> arw_, »ghc-pkg list« shows where the package databases are
09:16:38 <Liskni_si> how much unsafe is using rebindable syntax to replace >>= etc. with the monad-param definitions?
09:17:02 <dcoutts> quicksilver: right, +1 for spreading good advice :-)
09:17:29 <arw_> maltem: thanks.
09:19:36 <arw_> 1818[snalwuer@faui02:haskell-platform-2010/haskell-platform-2010.1.0.0]# /local/haskell-platform-2010/bin/ghc-pkg list
09:19:39 <arw_> /local/haskell-platform-2010/lib/ghc-6.12.1/package.conf.d
09:19:46 <aavogt> this seems like a useful project: http://github.com/sebastiaanvisser/ghc-goals/ and it doesn't seem like the ghc-patch is necessary
09:19:59 <arw_> ah. it seems that it observes the prefix of ghc(-pkg)
09:20:27 <fax> "programmers today tend to build systems, not write functions or programs."
09:20:28 <fax> lol
09:20:36 <fax> what??
09:20:48 <arw_> because the 'global' config in ~/.cabal/config points to /usr/local.
09:21:23 <aavogt> Liskni_si: -XNoImplicitPrelude isn't particularly unsafe...
09:21:40 <etpace> anyone here use leksah? when trying to run a package, I get Unkown field 'build-type' and make failed
09:22:00 <Mathnerd314> does anything beginning with : have to be a data constructor?
09:22:06 <quicksilver> Mathnerd314: yes.
09:22:15 <quicksilver> Mathnerd314: except '::' which is magikal.
09:22:17 <Liskni_si> aavogt: I'm scared a bit since ghc manual says "Be warned: this is an experimental facility, with fewer checks than usual. Use -dcore-lint  to typecheck the desugared program. If Core Lint is happy you should be all right." and monad-param isn't very optimistic either
09:22:23 <Jafet> Hm, for some reason I used Int instead of Integer
09:22:31 <Jafet> Haskell needs strongly typed literals
09:23:27 <ksf> :t \f l r -> (\l r -> f <$> l <*> r) <$> l <*> r
09:23:28 <lambdabot> forall a a1 b (f :: * -> *) (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> a1 -> b) -> f1 (f a) -> f1 (f a1) -> f1 (f b)
09:24:02 <Mathnerd314> quicksilver: what's a good symbol to use instead of ':'?
09:24:07 <ksf> @pl \f l r -> (\l r -> f <$> l <*> r) <$> l <*> r
09:24:07 <lambdabot> (. (<*>)) . (.) . (<$>) . const . (. join (<*>)) . (<$>)
09:24:09 <quicksilver> Mathnerd314: for what purpose?
09:24:22 <Mathnerd314> I'm trying to write a ? b : c in Haskell
09:24:40 <ksf> :?
09:24:41 <Mathnerd314> and writing the definitions as I go
09:24:47 <ksf> or rather :!
09:24:54 <quicksilver> (<:>) ? (>:) ?
09:25:17 <quicksilver> a >? b >: c looks OK-ish to me
09:25:29 <ksf> or maybe :|:
09:25:39 <quicksilver> ksf: your suggestions all fail :)
09:25:40 <ksf> a ? b :|: c
09:25:48 <quicksilver> ksf: they begin with :, he's trying to avoid being a constructor?
09:25:56 <ksf> why that?
09:25:56 <Mathnerd314> > let a :|: b = a in 1 :|: 2
09:25:57 <lambdabot>   Not in scope: data constructor `:|:'Not in scope: data constructor `:|:'
09:26:03 <quicksilver> (admittedly there is another approach in which you *rely* on being a constructor.
09:26:20 <Mathnerd314> > let a |: b = a in 1 |: 2
09:26:21 <lambdabot>   1
09:27:10 <quicksilver> data Choice a = a :|: a; a ? (b :|: c) = if a then b else c
09:27:39 <quicksilver> and suitable infix definitions to make sure :|: binds tighter and you don't need the parens I have there
09:28:03 <Mathnerd314> let me paste what I have...
09:29:16 <Mathnerd314> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24736#a24736
09:30:04 <fax> this is anold trick
09:30:26 <fax> you seem to even use the same ops as before but maybe that's coincidence
09:30:45 <Mathnerd314> I was updating it as you were talking ;-)
09:32:31 <ddarius> (?) True = fst; (?) False = snd
09:33:28 <Mathnerd314> and : == (,)?
09:41:35 <ksf> I must say, the trickiest thing about parsers is getting greedyness and non-greediness to work as intended.
09:43:41 <Mathnerd314> maybe I should use a typeclass with fundeps...
09:44:04 <Mathnerd314> so that ? and : can be both infixr and infixl
09:45:41 <deech> Hi all, I am trying to understand catching/handling errors in Haskell. Aside from Control.Exception, Either and Maybe are there any other datatypes that help with this?
09:46:30 <liyang> deech: Control.Monad.Error
09:46:58 <zygoloid> > let False <?> x = mzero; True <?> x = return x; (<:>) = flip fromMaybe  in  True <?> 42 <:> 27
09:46:59 <Mathnerd314> I get the feeling that (1,(2,3)) /= ((1,2),3)
09:47:00 <lambdabot>   42
09:47:03 <zygoloid> Mathnerd314: ^^ that's how i do it
09:47:34 <quicksilver> Mathnerd314: right. They're not even the same type.
09:47:58 <Mathnerd314> well, if ^&%*& Haskell would let me compare objects of different types...
09:48:19 <deech> liyang: thanks!
09:48:48 <zygoloid> Mathnerd314: would you hope for any result other than False when comparing values of different types?
09:49:06 <Mathnerd314> yes; I would hope that (1,(2,3)) == ((1,2),3)
09:49:49 <Mathnerd314> I suppose could go dynamically-typed with (,) == ++...
09:49:55 <zygoloid> do you have a situation in mind where that comparison would even make sense?
09:50:30 <zygoloid> fwiw i don't know of any dynamically-type languages with tuples where (1,(2,3)) == ((1,2),3)
09:50:42 <elly> perl?
09:51:00 <Mathnerd314> yeah... (1,(2,3)) == ((1,2),3) == (1,2,3)
09:51:07 <elly> perl does an obnoxious thing where it flattens lists
09:51:19 <sepp2k> Perl has tuples?
09:51:43 <dankna> Mathner: class flattenable a where flatten :: a -> [Int]
09:51:45 <Saizan_> nice how you can often answer that sort of questions with "perl"
09:52:22 <dankna> but I'm at a loss for why you want this anyway
09:52:36 <quicksilver> Mathnerd314: nested tuples are much more useful than auto-flattening.
09:52:41 <Mathnerd314> dankna: actually it would just be "join"
09:52:42 <fax> lol
09:52:45 <quicksilver> if you want something flat, use a list. or ++.
09:52:55 * hackagebot hoopl 3.7.2.2 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.2.2 (NormanRamsey)
09:52:58 <elly> sepp2k: perl has... things...
09:53:04 <zygoloid> elly: holy cow you're right! how is this not breaking... everything? ;)
09:53:17 <quicksilver> it doesn't break anything
09:53:21 <elly> zygoloid: perl programmers know about it already
09:53:22 <Parkotron> Does anyone have hlint installed and be willing to run a file through it for me?
09:53:25 <quicksilver> (except the expectations of people who don't understand the language)
09:53:39 <elly> zygoloid: and use list refs instead: [[1, 2], 3] behaves as you'd exist
09:53:42 <elly> expect.
09:53:42 <zygoloid> quicksilver: it seems to break composability
09:53:45 <elly> my god, I am tired :P
09:53:48 <quicksilver> (1,(2,3)) is the same list as ((1,2),3) but [[1,2],3] and [1,[2,3]] are not.
09:54:04 <quicksilver> no, it just breaks your expectations about what () and , are.
09:54:08 <quicksilver> In perl they aren't tuples.
09:54:14 <quicksilver> e.g., in perl (1,,,,,,,2) = (1,2)
09:54:36 <quicksilver> different languages have language constructs which behave in different ways :)
09:55:06 <Parkotron> ...and each is special in its own way. :)
09:55:10 <zygoloid> quicksilver: in which case perl isn't a counterexample to my claim since the things aren't tuples
09:56:02 <quicksilver> true enough.
09:56:35 <zygoloid> erk. reading through perl documentation has made me feel unwell :(
09:59:10 <Parkotron> I'm about to submit this assignment (http://paste.pocoo.org/show/198832/) but I'd like to run it through hlint first. Unfortunately, I don't have hlint installed locally and I currently don't have the bandwidth to get a copy. If somebody could run it through hlint and repaste the results, I'd be most appreciative.
10:01:46 <Mathnerd314> so... how do I define a strongly-typed structure * a with operations unit :: a -> * a, ++ :: * a -> * a -> * a, a ++ (b ++ c) == (a ++ b) ++ c, fst :: * a -> a ?
10:02:03 <fax> huh
10:02:26 <Mathnerd314> * is a placeholder for some magic type
10:02:36 <Saizan_> * a = (a,[a]) ?
10:02:40 <Saizan_> i.e. a non-empty list?
10:03:21 <fax> it's not always possible to divide a type by an equational theory like that, and get a nice type again (or at least it's not always easy)
10:03:22 <Mathnerd314> oh, ++ is wrong... it should be * a -> * b -> * a b
10:03:39 <fax> so I would start with e.g.    data Star a where Unit :: a -> Star a ; PlusPlus :: Star a -> Star b -> Star b
10:03:52 <danr> * a b, what is that supossed to be?
10:04:00 <fax> then verify that every function defined on it satisfies these equations
10:04:14 <Mathnerd314> danr: some type involving a and b
10:04:51 <danr> like [a] -> [b] -> [(a,b)] ?
10:05:17 <Saizan_> Mathnerd314: with gadts: data Foo a b; data Star :: * -> * where Unit :: a -> Star a ; PlusPlus :: Star a -> Star b -> Star (Foo a b)
10:05:32 <danr> Saizan_: ok
10:05:57 <Mathnerd314> Saizan_: does that satisfy a ++ (b ++ c) == (a ++ b) ++ c ?
10:06:04 <fax> :/
10:06:05 <fax> read
10:06:11 <Saizan_> i was checking that.
10:06:29 <Saizan_> i guess it depends on how you define == :)
10:06:58 <Mathnerd314> ==: same type, comparable
10:07:01 <danr> well, you'd even get different types... Star (Foo (Star (Foo a b)))) c and Star (Foo a (Star (Foo b c)))
10:07:18 <Saizan_> danr: different types, but not those
10:07:36 <fax> Mathnerd314 you missed what I said ?
10:07:44 <Saizan_> that could be solved though, by reassociating the type tags
10:08:11 <Mathnerd314> right... how do I do that?
10:08:18 <Saizan_> you'd need to define ++ as a typeclass
10:08:22 <fax> Mathnerd314 ???
10:08:31 <fax> dammit people are so rude
10:08:51 <Mathnerd314> fax: ++ is not of type Star a -> Star b -> Star b
10:08:56 <fax> and
10:12:50 <Mathnerd314> hmm... what syntax is used for giving GADTs a deriving declaration?
10:14:00 <ksf> standalone deriving?
10:14:39 <Mathnerd314> I want to be able to show a Star...
10:14:52 <Twey> Same as usual for H98 types, or derive-gadt package for others
10:14:58 <ksf> to give birth to a star, you still have to have chaos in you.
10:16:11 * Mathnerd314 pointedly ignores ksf
10:16:38 <fax> I dunno this sucks I think you could just be less rude
10:17:25 <Mathnerd314> fax: explain to me how I'm rude :-(
10:18:28 <oxamus> Hello I am from JIDF, I'm afraid we are going to have to close this place down
10:19:00 <Mathnerd314> oxamus: why?
10:19:08 <oxamus> There has been Jew hate going on here
10:19:26 <burp> lol
10:19:28 <oxamus> http://en.wikipedia.org/wiki/Jewish_Internet_Defense_Force
10:19:40 <oxamus> Please disband it voluntarily
10:20:03 <oxamus> It also says in the tora that Haskell is actually some kind of demon
10:20:17 <burp> oh it does?
10:20:48 <burp> tell that haskell curry
10:21:05 <Sgeo> It's very pure for a demon
10:21:45 <burp> oxamus: close down #haskell-blah -.-
10:22:59 <Mathnerd314> oxamus: According to that article, the JIDF has done something with Facebook... I don't see Facebook closing down; why should #haskell?
10:24:02 <oxamus> They are antisemites
10:24:33 <bremner> wierdest troll this week
10:24:40 <Mathnerd314> oxamus: you're in #haskell... are you an antismite?
10:24:45 <Mathnerd314> *antisemite
10:24:55 <Saizan_> Mathnerd314: does this fit?:) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24737#a24737
10:25:03 <burp> yes I'm anti-smite ;)
10:26:51 <Saizan_> Parkotron: do you still need that hlint run?
10:27:10 <Saizan_> Parkotron: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24738#a24738
10:27:11 <oxamus> Mathnerd314: Are you one of those who worhsip admiral ackbar? Because they are nothing but trouble.
10:27:30 <Mathnerd314> oxamus: I asked you first
10:27:55 <oxamus> Of course not I am here delivering a PSA
10:28:07 <Saizan_> oxamus: this channel is about the programming language Haskell
10:28:24 <Saizan_> oxamus: stay on topic or leave.
10:29:04 <oxamus> That was exactly what Hitler said as well...
10:29:10 <burp> lol
10:29:22 <pastorn> banhammer?
10:29:30 <ezyang> banhammer.
10:29:37 --- mode: ChanServ set +o Saizan
10:29:39 <burp> wee :D
10:29:43 --- mode: Saizan set +b *!*55c89673@gateway/web/freenode/x-vrcevfwgqrdmifac
10:29:44 --- kick: oxamus was kicked by Saizan (oxamus)
10:29:49 <pastorn> \o/
10:29:52 <pastorn> rejoice!
10:29:54 <Saizan> took a while to change nick.
10:29:57 <burp> remarks:        For hacking, spamming or security problems send mail to abuse@bkkb.no
10:30:00 --- mode: Saizan set -o Saizan
10:30:11 <dankna> that really was a bizarre troll
10:31:48 <danr> \o/
10:31:50 * chrisdone peers at pastorn ಠ_ಠ
10:32:22 <pastorn> chrisdone: whut?
10:32:22 <Mathnerd314> I feel like I could have convinced him to disappear in a puff of logic... oh well.
10:32:55 <bremner> right, back to normal trolling.  Scala rulz!
10:33:00 <Twey> Heh
10:33:09 <burp> @karma scala
10:33:10 <lambdabot> scala has a karma of 3
10:33:17 <chrisdone> sounds too much like scales
10:33:36 <pastorn> @karma ffi
10:33:36 <lambdabot> ffi has a karma of 2
10:33:48 <pastorn> @karma dependent types
10:33:48 <lambdabot> dependent has a karma of 0
10:33:55 <pastorn> @karma dependent-types
10:33:55 <lambdabot> dependent-types has a karma of 0
10:34:17 <Saizan> dependent-types++
10:34:47 <fax> dependent types?
10:34:56 <orlandu63> is there a standard function that simply returns its argument?
10:35:02 <orlandu63> such as (\f x -> x)
10:35:03 <pastorn> orlandu63: id
10:35:03 <Twey> id
10:35:09 <pastorn> > id "hello"
10:35:10 <lambdabot>   "hello"
10:35:15 <orlandu63> thanks
10:35:19 <theorbtwo> > id _|_
10:35:19 <lambdabot>   <no location info>: parse error on input `|'
10:35:24 <theorbtwo> Aww.
10:35:28 <Twey> Well, (\f x -> x) would be (flip const)
10:35:40 <Twey> > flip const id 3
10:35:41 <lambdabot>   3
10:36:11 <orlandu63> why?
10:36:15 <orlandu63> @src id
10:36:15 <lambdabot> id x = x
10:36:49 <Twey> orlandu63: Because (\f x -> x) is a function that takes two arguments and returns the second.
10:37:01 <Twey> One argument is called ‘f’, and the other is called ‘x’.
10:37:03 <orlandu63> oh duh
10:38:11 <Mathnerd314> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24737#a24737 fits; why do you need to define data One a = a?
10:40:25 <Mathnerd314> *just data One a
10:41:56 <orlandu63> is there a function that returns the first n elements of a list
10:42:11 <Twey> orlandu63: take
10:42:15 <carnieri> > take 5 [1..10]
10:42:16 <lambdabot>   [1,2,3,4,5]
10:42:34 <orlandu63> can't believe i forgot that
10:42:34 <Twey> > take 5 [1, 2, 3]
10:42:35 <lambdabot>   [1,2,3]
10:42:38 <Twey> > take 5 []
10:42:39 <lambdabot>   []
10:43:00 <danr> > take 4 (Just [])
10:43:01 <lambdabot>   Couldn't match expected type `[a]'
10:43:02 <lambdabot>         against inferred type `Data.Mayb...
10:43:15 <Twey> > take 4 <$> Just []
10:43:16 <lambdabot>   Just []
10:43:25 <orlandu63> <$>
10:43:28 <orlandu63> that looks scray
10:43:30 <jmcarthur> :t (<$>)
10:43:30 <orlandu63> scary
10:43:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:43:32 <orlandu63> lol
10:43:34 <Twey> (<$>) = fmap
10:43:36 <jmcarthur> orlandu63: it's just fmap
10:43:48 <jmcarthur> > take 4 <$> Just [1..10]
10:43:49 <lambdabot>   Just [1,2,3,4]
10:49:38 <Saizan> Mathnerd314: to distinguish the non-Cons case at the type level, otherwise you get in a lot of trouble with overlapping patterns in both type family and type class instances
10:50:09 <Mathnerd314> ah.
10:53:10 <amontez> Hi. I am new to Haskell. What is a module?
10:53:47 <dankna> a file which contains code which may be linked with code from other modules
10:54:06 <amontez> How is code linked?
10:54:35 <dankna> from the command line; it depends on what build system you're using.  why are you asking?
10:54:57 <dankna> (there's ghc, ghc --make, hmake, and cabal, off the top of my head)
10:55:16 <dankna> (also there's non-ghc compilers)
10:57:16 <amontez> I want to understand the hierarchy of a Haskell program. Is there anything higher than the module?
10:57:28 <fax> hierarchical modules
10:57:34 <fax> then libraries
10:58:22 <amontez> A module contains libraries, or a library contains modules?
10:58:42 <Saizan> the latter
10:58:54 <amontez> Okay.
10:58:59 <Saizan> but the concept of "library" is not present in the language itself, only in the tools
11:04:33 <bluetaslem> Hi.
11:04:44 <bluetaslem> I'm getting an error I can't explain, on the use of ">"..
11:05:13 <c_wraith> bluetaslem: can you put your code and the error message on a pastbin?
11:05:17 <c_wraith> *pastebin
11:05:45 <bluetaslem> Pastebin?
11:05:55 <Twey> http://hpaste.org/
11:06:49 <bluetaslem> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24739
11:07:43 <bluetaslem> Can I get some help?
11:08:19 <bluetaslem> When I use "==" or "/=" instead of ">" or "<" or ">=" or "<=" it works fine.
11:08:30 <bluetaslem> So, why is it giving me an error?
11:08:56 <bluetaslem> Anyone?
11:09:15 <stevenmarky_> Seems to want you to specify that the parameter is an Ord ?
11:09:25 <bluetaslem> I have no idea.
11:09:29 <aavogt> because instanecs of Floating do not have to be ordered
11:09:35 <aavogt> bluetaslem: leave out the type signature
11:10:05 <aavogt> the correct typeclass context can be inferred
11:10:06 <bluetaslem> Okay..
11:10:19 <bluetaslem> WHY is it that ">" is not defined for FLoating?
11:10:27 <aavogt> because it's part of Ord
11:10:37 <aavogt> you can write    (Ord a, Floating a) => a -> Bool
11:11:14 <aavogt> > compare (1/0) (1/0.0)
11:11:15 <lambdabot>   EQ
11:11:26 <aavogt> > (1/0) == (1/0.0)
11:11:27 <lambdabot>   True
11:11:39 <aavogt> > compare (0/0) (0/0.0)
11:11:40 <lambdabot>   GT
11:11:44 <bluetaslem> I see.
11:12:08 <aavogt> well a general instance of Floating doesn't have to be ordered
11:12:15 <bluetaslem> Why?
11:12:19 <bluetaslem> How could they not be
11:12:33 <aavogt> I dunno, that's how they write the Floating class
11:12:33 <orlandu63> > 1/0
11:12:34 <lambdabot>   Infinity
11:12:38 <orlandu63> what
11:12:50 <bluetaslem> That doesn't make sense, but thanks anyways.
11:13:14 <orlandu63> infinity's a data type?
11:13:27 <danr> NaN /= NaN
11:13:30 <danr> > 0/0
11:13:30 <fax> it's the value
11:13:31 <lambdabot>   NaN
11:13:37 <danr> > 0/0 == 0/0
11:13:38 <lambdabot>   False
11:13:42 <bluetaslem> Infinity isn't recognized by my Interpreter.
11:13:47 <fax> yes that's a bug
11:13:59 <aavogt> because you can make arbitrary choices when arranging typeclasses
11:14:02 <fax> for some reason they defined it in that very oddway
11:14:24 <bluetaslem> Just curious..
11:14:26 <aavogt> in this case somebody wrote       class Num a => Floating a where ....
11:14:34 <aavogt> hmm, maybe not
11:14:36 <bluetaslem> Is there any way to construct a number based on a lsit of bools?
11:14:41 <bluetaslem> *list
11:15:04 <arcatan> there are many ways, for sure. how would you construct it?
11:15:34 <bluetaslem> In the sense that low-level languages store memory, "101" == 5
11:15:51 <aavogt> > show (1/0)
11:15:52 <lambdabot>   "Infinity"
11:16:03 <bluetaslem> Is there a built-in system to convert, or would you have to manually generate it?
11:16:07 <fax> bluetaslem, just do 1 + 2 * (0 + 2 * (1))?
11:16:18 <aavogt> how about negative numbers?
11:16:22 <arcatan> > foldl1 (\x y -> x * 2 + y) [1,0,1]
11:16:23 <lambdabot>   5
11:17:00 <aavogt> there are a number of different ways to see strings of bits as numbers
11:17:29 <bluetaslem> I see.
11:20:02 <orlandu63> arcatan: how did you even come up witht hat
11:21:35 <aavogt> > read "Infinity" :: Double
11:21:36 <lambdabot>   Infinity
11:21:49 <jmcarthur> > Infinity :: Double
11:21:50 <lambdabot>   Not in scope: data constructor `Infinity'
11:22:02 <jmcarthur> > infinity
11:22:02 <aavogt> odd that it isn't exported
11:22:03 <lambdabot>   Not in scope: `infinity'
11:22:14 <dankna> @hoogle Infinity
11:22:14 <lambdabot> No results found
11:22:21 <dankna> yes, that is odd
11:22:43 <aavogt> but I don't think anybody should need it anyways
11:22:58 <dankna> well, it is sometimes nice to use as a sentinel value in an iteration
11:23:10 <dankna> and in those cases, writing it with the constructor would be clearer than writing 1 / 0.
11:23:12 <aavogt> maybe instead of some wrapper for the Ord instance
11:25:31 <aavogt> @scheck \(ns::[Maybe Bool]) -> rnf (map fromJust . dropWhile isNothing . sort $ ns) `seq` True
11:25:31 <lambdabot>   Parse error in pattern at "->" (column 21)
11:26:00 <aavogt> @scheck \ns -> rnf (map fromJust . dropWhile isNothing . sort $ (ns `asTypeOf` (undefined::[Maybe Bool]))) `seq` True
11:26:00 <lambdabot>   "OK, passed 500 tests."
11:26:31 <aavogt> dankna: to abuse Ord instances like that one
11:26:47 <aavogt> when instead you probably want catMaybes
11:26:51 <dankna> hrm.
11:26:55 <dankna> point taken.
11:27:02 <aavogt> which would be more efficient anyways
11:30:24 <aavogt> perhaps somebody can come up with a better example
11:36:00 <zygoloid> > (sum . zipWith (*) (iterate (*2) 1)) [1,0,0,1,1,1,0,0,1,0,1]
11:36:01 <lambdabot>   1337
11:36:58 <fax> leet lol
11:37:25 <Apocalisp>  http://www.haskell.org/haskellwiki/Rank-N_types
11:37:49 <Apocalisp> What is it called, the process of moving quantifiers from the right to the left?
11:38:34 <fax> > let i = sqrt(-1) in i^(2/(i*pi)) :: Complex Double
11:38:35 <lambdabot>   No instance for (GHC.Real.Integral
11:38:35 <lambdabot>                     (Data.Complex.Comple...
11:38:39 <fax> > let i = sqrt(-1) in i**(2/(i*pi)) :: Complex Double
11:38:40 <lambdabot>   2.718281828459045 :+ 0.0
11:38:53 <Apocalisp> In other words, if a type system is not able to unify (forall a. a -> (forAll b. b -> b)) with (forAll a b. a -> b -> b), what feature is that system missing?
11:39:45 <dankna> mm.  not sure it has a name.  but I wouldn't know.
11:41:51 <fax> > let c = 2997924 ; m = 3.02449643e-17 in m*c^2
11:41:52 <lambdabot>   2.7182807777370046e-4
11:45:33 <Mathnerd314> Saizan: thank you; a ? b |: c is now working with infixr ? 1 and infix[lr] |: 2
11:45:45 <Mathnerd314> now for the other 4 cases
11:45:49 <Mathnerd314> *3
11:46:04 <sinelaw> heya
11:46:11 <fax> hi
11:46:39 <sinelaw> howzit? I was away for a week or two
11:46:57 <bluetaslem> Okay, new problem..
11:47:12 <bluetaslem> I have a List of Ints, I need it converted into Floats..
11:47:17 <bluetaslem> How should I go about doing that?
11:47:40 <bluetaslem> Should I construct a new list?
11:47:43 <sinelaw> @type fromInteger
11:47:44 <lambdabot> forall a. (Num a) => Integer -> a
11:48:00 <sinelaw> > map fromInteger [1,2,3] :: [Float]
11:48:00 <lambdabot>   [1.0,2.0,3.0]
11:48:19 <bluetaslem> Thanks.
12:01:56 <Mathnerd314> are type families and type classes orthogonal?
12:02:25 <Parkotron> Saizan: Thanks a lot. Sorry for not replying; I was in class.
12:02:43 <Parkotron> Only one suggestion. I'm pretty pleased with myself. :)
12:07:28 <jmcarthur> Mathnerd314: i don't know about orthogonal. more like two sides of the same coin i think
12:10:37 <kmc> Mathnerd314, they are both mechanisms for ad-hoc polymorphism
12:11:04 <kmc> there is a special form of type families (and type synonym families) which is used in type classes
12:11:41 <kmc> and sometimes a design with families effectively compels you to put some operations into a typeclass
12:12:09 <kmc> see section 7.7.1.2 of the GHC manual, after the bullet list
12:15:31 <Mathnerd314> my code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9487#a9487
12:16:11 <Mathnerd314> I guess the key thing is that type families aren't types...
12:16:58 <kmc> they are families of types :D
12:18:18 <Mathnerd314> but it works when I don't do an instance declaration and just declare (|:) :: (Star a) -> (Star b) -> (Star (Comp a b))
12:25:30 <Saizan> it should work if you stick to type families rather than fundeps
12:26:25 <Saizan> class Join a b where type JoinR a b :: *; (|:) :: a -> b -> c
12:28:46 <Saizan> Mathnerd314: btw, i'd go with Nothing :: Star Nil, and remove Unit/One
12:29:15 <Mathnerd314> Nothing is there as a placeholder; I'm still deciding whether I want it
12:34:28 <Saizan> uh, i screwed up the Join def
12:34:35 <Saizan> class Join a b where type JoinR a b :: *; (|:) :: a -> b -> JoinR a b
12:34:41 <Mathnerd314> yeah; I fixed it
12:35:32 * Mathnerd314 changes Question to use type families
12:36:16 <Mathnerd314> are fundeps going to be deprecated and replaced with type families?
12:37:11 <kmc> doubtful, at an implementation level
12:37:19 <kmc> but i expect more libraries will move towards type families
12:37:41 <BONUS> i don't think they'll be deprecated
12:43:09 * Saizan wants a "Type Equality" gadt that gets erased.
12:43:24 <fax> is it allowed to be erased?
12:43:44 <stevenmarky_> I'm going to try out Qt haskell.
12:43:49 <Saizan> and a way to reify stuck type family applications into type constructors
12:44:43 <kmc> can't you write coerce :: a -> b if you erase the equality gadt?
12:45:09 <Saizan> fax: i imagine i could ask ghc to normalize the proof at compile time, and diverge if i'm stupid :)
12:45:35 <kmc> coerce x = case undefined :: Eq a b of { Refl -> x }
12:45:51 <Saizan> kmc: see my comment above
12:45:54 <kmc> right
12:46:09 <kmc> but will it have access to the proof in order to normalize it?
12:46:43 <kmc> seems like this might require arbitrary normalization at compile time, not just of equality proofs
12:47:23 <Saizan> yes, in theory i could use information from other gadts to make my proof typecheck
12:48:22 <kmc> anyway, i too wish Haskell had dependent types
12:48:22 <Saizan> so maybe what i want is equality constraints in superclass contexts
12:49:05 <Saizan> typeclass resolution is done statically anyway.
12:49:17 <Saizan> *instance
12:50:08 <obraun> Leider nein. Es wird vermutlich noch eine Weile dauern :-(
12:50:25 * obraun is sorry. wrong channel
13:01:14 <scotd> is the "<-" syntax used anywhere besides generators inside list comprehensions?
13:02:32 <Saizan> in do-notation too
13:02:35 <scotd> and besides "do" expressions?
13:02:43 <monochrom> used in monad do-notation and arrow proc-notation.
13:02:46 <scotd> beat me to it :-)
13:03:04 <nominolo> and pattern guards
13:03:14 <nominolo> and view patterns
13:03:21 <scotd> ohhh... pattern guards
13:03:28 <Saizan> view patterns use ->, iirc
13:03:54 <nominolo> oh, indeed
13:06:10 <chrisdone> spekaing of whica hi haven't tried view patterns. mm
13:06:25 <chrisdone> anyone used them for anything useful want to show me their code?
13:07:04 <scotd> nominolo, is a pattern guard like "[ a+b | (a,b) <- zip fib tfib ]" ?   if so, is the only difference from a generator that a generator deals exclusively with numbers?
13:07:16 <scotd> like [1..100]
13:08:01 <Saizan> that's still a list comprehension
13:08:06 <nominolo> scotd: nope
13:08:42 <nominolo> scotd: pattern guards can only occur in guard position
13:08:53 <nominolo> scotd: they are very similar to generator expresions, though
13:09:50 <nominolo> > [ a*a | Just a <- [Just 4, Nothing, Just 5] ]
13:09:51 <lambdabot>   [16,25]
13:10:00 <Saizan> in a list comprehension when you've "a <- b" , if a is of type t, then b is of type [t]
13:10:14 <Saizan> in a pattern guard they both have the same type, iirc
13:10:24 <nominolo> yup
13:10:47 <nominolo> scotd: do you know about guards?
13:10:58 <scotd> parsing now
13:12:38 <nominolo> btw, in GHC the same data type is used for statements, list comprehension clauses, and guards
13:16:01 <scotd> so in "[x+1 | x <- [1..100], x `mod` 2]", then "x+1" is target, "x" is local binding, "[1..100]" is a generator, and "x `mod` 2" is the guard
13:16:14 <scotd> and a generator is also a list comprehension
13:16:29 <Saizan> no, the whole thing is a list comprehension
13:17:03 <nominolo> I think [1..100] is called an enumeration.  It's really just syntactic sugar for the call enumFromTo 1 100
13:17:05 <scotd> right, forgot to say that... just saying that [1..100] is also one?
13:17:14 <nominolo> no
13:17:17 <nominolo> it's just a list
13:17:33 <nominolo> a list comprehension takes the form  [ expr | ... ]
13:17:40 <scotd> ok, the haskell parser swaps it out with enumFromTo at compile time?
13:17:59 <nominolo> roughly speaking, yes
13:18:03 <scotd> and a list comprehension has to have a local binding
13:18:16 <Saizan> not necessarily
13:18:24 <Saizan> > [ () | True ]
13:18:25 <lambdabot>   [()]
13:18:34 <scotd> lol
13:18:50 <scotd> haskell is deceptively simple
13:18:55 <scotd> not
13:19:30 <Saizan> the definition of the list comprehension desugaring is like 5 lines in the haskell report, it might help :)
13:19:35 <street_dvd> What's a great text editor for haskell?
13:19:46 <kmc> street_dvd, whatever text editor you are comfortable with
13:20:14 <street_dvd> kmc: gedit?
13:20:25 <kmc> street_dvd, sure, why not
13:20:33 <street_dvd> kmc: thanks.
13:20:36 <kmc> Haskell syntax is (usually) whitespace-dependent, so it helps to have an editor that autoindents
13:20:39 <kmc> also, don't use tabs
13:20:49 <egaga> has there been any progress in pivotal or any other similar environment in haskell? http://www.cs.kent.ac.uk/projects/pivotal/index.html
13:21:57 <scotd> is the haskell community divided on the tabs/space issue like the python community?
13:22:05 <kmc> no
13:22:12 <fax> yes
13:22:18 <kmc> ;P
13:22:24 <kmc> i think we mostly agree that tabs are terrible
13:22:49 <kmc> an advantage over python is that there is always a whitespace-insensitive form
13:23:34 <scotd> fax, do you use tabs?
13:23:43 <scotd> kmc, thanks i was hoping so
13:23:54 <kmc> whitespace in haskell is just sugar for { } ;
13:23:57 <fax> I press the tab button but it is programmed to insert spaces
13:24:05 <Mathnerd314> what's a type that can be a value or a bool, but not both?
13:24:10 * Mathnerd314 smacks forehead
13:24:10 <kmc> what
13:24:21 <Mathnerd314> Either a Bool, right?
13:24:23 <scotd> kmc, i think that is the best solution
13:24:28 <kmc> Mathnerd314, your question makes no sense
13:24:40 <Mathnerd314> ok :-)
13:24:53 <kmc> boolean values are values
13:25:06 <kmc> scotd, yes
13:25:15 <nominolo> preflex: seen ndm
13:25:15 <preflex>  ndm was last seen on #haskell 333 days, 10 hours, 6 minutes and 34 seconds ago, saying: plus with current compiler technology, it would be slower
13:25:53 <mreh_> is there a comprehensive darcs guide, I'm a bit confused by the quickstart guide
13:26:48 <nominolo> mreh_: you mean other than http://darcs.net/manual/?
13:27:26 <mreh> sweeet
13:28:21 * hackagebot hoopl 3.7.3.3 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.3.3 (NormanRamsey)
13:29:55 <scotd> Saizan, I'm now the owner of one haskell98 report in html format and am perusing section 3.11, list comprehensions :-) thanks for the pointer
13:31:22 * hackagebot hoopl 3.7.3.4 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.3.4 (NormanRamsey)
13:32:31 <Janni> Hi. I hope someone can give me a hint for a (probably very easy) problem:
13:33:01 <Saizan> scotd: np
13:33:37 <Janni> If I have type signatures in my module that look like this: A n p e -> B n p e -> C n p e
13:34:10 <Janni> In other words: All the functions of the module are parametrised over (let's say) three types...
13:34:25 <Janni> What can I do to save characters?
13:34:40 <Mathnerd314> kmc: I needed a type for a ? b : c ? d : e, which is parsed such that possible values are b, d, and e. The fragment (a ? b : c) is of type Either b c, not the union of the types of b and c
13:34:41 <Janni> Which type system extensions should I look into?
13:35:55 <Janni> I'd need to have a simple mechanism that creates some kind of "type environment" that automatically parametrised "everything" by the same variables.
13:36:31 <Saizan> Janni: if they are somehow connected you could use type families to abstract over only one type
13:37:09 <Janni> Saizan: type families... a keyword to start reading. Thanks...
13:37:31 <Saizan> e.g. type family P n :: *; type family E n :: *; then you can be polymorphic in 'n' and get p and e as P n and E n
13:38:15 <Saizan> there isn't a general mechanism to abstract a bunch of types (or anything) at the module level :\
13:38:51 <Janni> No, no. I'd be happy with a good solution on the function level.
13:39:39 <Saizan> nothing there either
13:40:04 <Saizan> however you could just let type inference work for you
13:40:24 <Janni> You mean, no type signatures?
13:41:01 <Saizan> either that or copy/paste them from what ghci infers :)
13:41:12 <Saizan> in emacs i often use C-u C-c C-t for that.
13:42:07 <Janni> Right. But that doesn't make the code more beautiful (what this is all about).
13:42:09 <tensorpudding> You can often skip type signatures.
13:42:26 * Janni thinks... Isn't that what programming is all about anyway?
13:42:40 <tensorpudding> But if you use -Wall, it will warn you every time it defaults a type
13:43:03 <mreh> is darcs cleverer enough not to add its own directory to the repository?
13:43:23 <Janni> yes.
13:43:26 <tensorpudding> Yes?
13:43:32 <mreh> yes?
13:43:35 <mreh> or no?
13:43:37 <Janni> darcs add _darcs
13:43:37 <Janni> Skipping boring file _darcs
13:43:43 <tensorpudding> It would get really complicated otherwise, when committing would cause commitable changes?
13:43:56 <Janni> darcs failed:  No files were added
13:44:03 <mreh> is that actual program output?
13:44:05 <mreh> oh, heh
13:44:09 <Janni> yes.
13:44:20 <tensorpudding> It's good to add type signatures
13:44:43 <tensorpudding> Mostly, it becomes a habit when you start thinking of what a function is supposed to do, to write a type for it before actually defining it.
13:44:59 <mreh> then you start generalising
13:45:17 <tensorpudding> You don't need to generalize everything.
13:45:28 <Janni> Then you decide, that actually you want to abstract this into a library.
13:45:36 <Janni> Then you start writing a library.
13:46:14 <Janni> At least that's what happens to me all the time :-)
13:46:15 <mreh> you never know when you might need to use code again, write it as general as possible I say
13:47:22 <monochrom> "as general as possible" does not exist
13:47:36 <monochrom> like "a natural number as large as possible"
13:47:47 <fax> there might be a bigest natural number
13:47:53 <fax> if you add one to it you just go back to 0
13:48:07 <monochrom> you never know which direction of generalization you actually need later, so why bother generalizing in the wrong direction today
13:48:16 <[swift]> mreh: that used to be my attitude, but observing the rate of actual code reuse over the years convinced me that it is frequently wasted effort
13:48:23 <tensorpudding> Some generalizations are easy.
13:48:43 <fax> infact, All generalizations are easy
13:48:46 <tensorpudding> Some generalizations are premature.
13:49:06 <Saizan> be lazy.
13:49:25 <Janni> protect the environment
13:49:39 <tensorpudding> save the whales?
13:50:02 <monochrom> Yeah path of lowest resistance. Some generalizations actually give you lower resistance; do them.
13:50:30 <monochrom> @quote monochrom premature
13:50:30 <lambdabot> monochrom says: premature generality is the root of OOP
13:50:51 <tensorpudding> Heuristics can get you places.
13:50:58 <tensorpudding> Vague statements seem wise!
13:51:04 <monochrom> If you want OOP, go with unquestioned dogmatic premature generalizations.
13:52:48 <mreh> gah, how glob all files and children
13:52:56 <mreh> english me speak good
13:53:52 <mreh> I like to generalise /= I am doing OOP
13:54:16 <mreh> maybe I'm just young and exuberant
14:07:06 <jmcarthur> parametric polymorphism is my favorite generalization. applies to so many things yet actually leads to clearer code
14:07:43 <fax> I always let generalization happen when it can
14:08:31 <jmcarthur> fax: so you use class Mapping a where type Domain f; type Codomain f; ($) :: f -> Domain f -> Codomain f, instead of normal function application?
14:08:51 <fax> well not in ad-hoc ways like that
14:09:34 <jmcarthur> heh i switch variable names there
14:09:39 <jmcarthur> *switched
14:10:18 <mreh> If i'm going to patch frag, would I give it a new revision number?
14:10:41 <jmcarthur> mreh: you patching it for public or private use?
14:10:50 <jmcarthur> i guess even for private it might be a good idea
14:11:03 <mreh> jmcarthur, public right now
14:11:12 <jmcarthur> i'd version bump it
14:11:14 <mreh> I want to patch the bitrot initially
14:11:31 <mreh> you have to with hackageDB
14:11:51 <mreh> i suppose
14:13:29 <mreh> jmcarthur, by version you mean a new upstream version
14:13:42 <mreh> 1.1.2 -> 2.0.0
14:14:07 <aavogt> patch frag vs. patch tag
14:14:13 <jmcarthur> maybe just 1.2 or something. i'm not sure what versioning policies we have for executables
14:14:57 <Saizan> i would bump the third or fourth component if i was just making it build
14:15:06 <aavogt> so sad that derive can't make infer  shrink
14:15:19 <aavogt> since that function seems to break the rules
14:16:02 <Saizan> shrink?
14:16:10 <aavogt> in Arbitrary
14:18:13 <mreh> hasn't anyone tried adjusting the dependencies for frag?
14:21:35 <mreh> they're rather open ended
14:22:46 <jmcarthur> does anybody here use any distributed bug tracking tools? any reviews or comments?
14:23:49 <jmcarthur> i'm considering making one specifically for darcs with a darcs-like interface
14:24:38 <mreh> jmcarthur, i'm intrigued as to what this means
14:24:51 <jmcarthur> mreh: you can just google it. there are a few
14:25:02 <Veinor> blah
14:25:14 <Veinor> I just registered on the ghc trac so that I could comment on a bug
14:25:20 <jmcarthur> mreh: i thought of it independently a bit over a year ago but alas it had already been invented :P  i don't know if any of it's any good though
14:25:23 <Veinor> and trac is giving me an infinite loop
14:25:43 <jmcarthur> mreh: i played with one once and found it a bit tedious
14:25:51 <jmcarthur> but that was a whiel ago
14:25:53 <jmcarthur> *while
14:26:31 <Veinor> :/
14:28:21 <jmcarthur> one downside to distributed bug tracking, at least the ones that integrate with your dvcs, is that you have to apply patches in order to integrate the bugs into your own repository. seems like some extra work
14:28:37 <jmcarthur> *tickets other people create
14:35:42 * hackagebot hoopl 3.7.3.5 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.3.5 (NormanRamsey)
14:36:42 * hackagebot hoopl 3.7.4.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.4.0 (NormanRamsey)
14:37:27 <oxamus> dons?
14:38:02 <oxamus> dons: I stood outside with that Haskell sign all day. I want my 5$ dons.
14:49:17 <ivanm> hmmmm..... that hoopl library looks interesting, except that apart from that one line description there's not much else to say what it's for or how to use it...
14:50:49 <Saizan> there's a paper
14:51:01 <ivanm> oh? any idea where?
14:51:46 * hackagebot JSONb 1.0.0 - JSON parser that uses byte strings.  http://hackage.haskell.org/package/JSONb-1.0.0 (JasonDusek)
14:52:22 <ivanm> ahhh, found it
14:52:31 <Saizan> link?:)
14:52:47 <ivanm> http://www.cs.tufts.edu/~nr/pubs/dfopt-abstract.html
14:52:58 <ivanm> oh, it's for _compiler writers_, not us end user plebs :s
14:54:00 <Saizan> yeah
14:54:26 <Saizan> well, you'll end up writing a compiler sometime
14:54:33 * ivanm doubts it
14:57:01 <ivanm> @tell solidsnack looks like your commit descriptions are as good as mine ("Useless variable" for jsonb) :p
14:57:02 <lambdabot> Consider it noted.
15:22:01 <ben_m> Greetings! Is there a way to exit a HOpenGL program without ghci crashing with "warning: too many hs_exit()s
15:22:02 <ben_m> "
15:23:32 <kmc> ben_m, do you get the same problem with a standalone program?
15:38:58 <pokoko222> can someone please help me prove: (n+2)!>3^n ? i am muted on math temporarily so... :(
15:39:05 <pokoko222> in pm, so we dont flood here
15:39:11 * hackagebot concurrent-sa 1.0.0 - Concurrent simulated annealing system.  http://hackage.haskell.org/package/concurrent-sa-1.0.0 (LouisWasserman)
15:41:58 <mauke> pokoko222: induction
15:42:13 <oxamus> yes use an induction stove
15:42:26 <oxamus> cook that expression
15:42:34 <dancor> can we prove it using only haskell
15:42:42 <pokoko222> well i dunno where to go from (n+3)!>3^n+1
15:42:42 <xerox> why are you asking here pokoko222
15:42:59 <pokoko222> muted at math, xerox sorry i told them in pm, wont write no more, sorry
15:43:01 <kmc> because he got muted in #math
15:43:09 <fax> induction doesn't prove anything
15:43:10 <xerox> #haskell-blah is for non-haskell stuff, and #haskell people
15:44:20 <dancor> given f(n) and g(n), can you construct a type that only has some djinn if f(n) > g(n) for n >= 0.  something like that
15:44:35 <fax> > let factorial n = product [1..n] in  map (\n->(factorial(n+3),3^n+1)) [1..20]
15:44:36 <lambdabot>   [(24,4),(120,10),(720,28),(5040,82),(40320,244),(362880,730),(3628800,2188)...
15:44:41 <fax> QED
15:45:43 <mauke> I don't know, this looks like a really simple proof to me (2 or 3 steps). am I doing it wrong?
15:45:54 <kmc> pokoko222, you have (n+2)! > 3^n
15:46:02 <kmc> you want to prove (n+3)! > 3^(n+1)
15:46:07 <pokoko222> yes
15:46:11 <kmc> (note that 3^n+1 and 3^(n+1) are very different numbers)
15:46:13 <ben_m> kmc: Standalone?
15:46:18 <kmc> (n+3)! = (n+2)! * (n+3)
15:46:21 <pokoko222> 3^(n+1) kmc
15:46:26 <kmc> 3^(n+1) = 3*3^n
15:46:35 <fax> my proof is better than any other
15:46:46 <ben_m> kmc: When I don't run it in ghci, but rather using runhaskell, i get the same warning
15:46:54 <kmc> ben_m, what if you compile the program
15:46:57 <mauke> runhaskell is ghci
15:47:00 <ben_m> oh
15:47:04 <xerox> intuitively it's obvious why the inequality holds, on one side you multiply bigger and bigger numbers, on the other you multiply (the same number of) threes
15:47:24 <kmc> @check \n -> n < 0 || product [1..n+2] < 3^n
15:47:24 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
15:47:25 <pokoko222> xerox well you dont wanna answer that to a professor :)
15:47:29 <kmc> @check \n -> n < 0 || product [1..n+2] > 3^n
15:47:30 <lambdabot>   "OK, passed 500 tests."
15:47:41 <kmc> pokoko222, make the substitutions that i suggested
15:48:00 <dancor> xerox: indeed!  i love when problems have a way easier solution but they are given out to get you to apply some harder technique (induction)
15:48:17 <fax> induction SUX
15:48:21 <fax> ......twice
15:48:22 <xerox> pokoko222: that is what one reads from the induction proof.
15:48:25 <dancor> you could totally make a formal proof from that.  i guess it wouldn't be that different from the induction one
15:48:43 <dancor> fine
15:49:23 <pokoko222> ok kmc proof done thanks ;)
15:49:35 <ben_m> kmc: Trying to compile it gives me dozens of undefined reference errors
15:50:07 <ben_m> nevermind.
15:50:48 <kmc> ben_m, always compile with --make
15:50:51 <ben_m> kmc: No errors when compiling.
15:50:55 <ben_m> Huh, why?
15:51:02 <benmachine> it sorts out the packages for you
15:51:09 <benmachine> makes life 297% easier
15:51:19 <ben_m> neat.
15:52:04 <Mathnerd314> @pl f c (a,b) = if c then a else b
15:52:04 <lambdabot> f = (`ap` snd) . (. fst) . if'
15:52:15 <Mathnerd314> @src if'
15:52:15 <lambdabot> Source not found. Do you think like you type?
15:52:20 <Mathnerd314> @type if'
15:52:21 <lambdabot> Not in scope: `if''
15:52:27 <Mathnerd314> @hoogle if'
15:52:27 <lambdabot> No results found
15:52:40 <oxamus> dancor: induction is not a harder technique
15:53:06 <Mathnerd314> oxamus: have you given up on the destruction of #haskell ?
15:53:13 <fax> oxamus, first of all induction doesn't even prove anything
15:53:38 <oxamus> what kind of statement is that
15:53:40 <fax> oxamus, it's a template/machine that does it for you once you wind it up right
15:54:10 <dancor> oxamus: maybe not harder.  i think induction can solve more ploblems than "subsequent terms are always bigger even when compared independently" so i was thinking it's more powerful and harder
16:00:18 * hackagebot concurrent-sa 1.0.1 - Concurrent simulated annealing system.  http://hackage.haskell.org/package/concurrent-sa-1.0.1 (LouisWasserman)
16:30:02 <FunctorSalad_> is mmap a good idea for random-access output? (where you'd otherwise manipulate an array and finally dump that). Not really Haskell-specific :)
16:30:55 <dons> output?
16:30:56 <FunctorSalad_> e.g., writing a large bitmap
16:31:03 <dons> mmm. no.
16:31:18 <dons> so you'd mmap and output buffer. then write slots randomly?
16:31:45 <dons> why not just use a mutable array and dump that (e.g. vector or stuarray)
16:31:52 <dons> otherwise you'll need to write your own arrays library
16:32:10 <FunctorSalad_> which buffer do you mean there? otherwise, yes
16:32:39 <FunctorSalad_> well, I just need to write certain pixels, which would be a simple pointer addition
16:32:44 <FunctorSalad_> (to find the position)
16:32:55 <FunctorSalad_> the array seems redundant since this is one already
16:33:32 <FunctorSalad_> *embarassed* I couldn't figure out how to freeze the Data.Vector.Unboxed.Mutable :)
16:34:32 <FunctorSalad_> (maybe I don't need to do that... thought I had to do it because I had the array-mutation part in ST)
16:35:33 <FunctorSalad_> (and wanted to pass an immutable structure to the output-writer, for whatever reason)
16:35:41 <FunctorSalad_> (none probably)
16:36:12 <dons> FunctorSalad_: its actually a bit hard. unsafeFreeze
16:36:29 <dons> the vector library is a little more abstract than i'd like
16:38:02 <FunctorSalad_> apparently some methods are only in .Vector.Generic, not specialized and reexported in the .Unboxed hierarchy?
16:39:36 <FunctorSalad_> just out of curiosity, what's the problem with mmap for random-access output?
16:41:00 <FunctorSalad_> ah or maybe you didn't imply that there is one apart from lack of array-utility library
16:41:30 <dons> mfp: around?
16:42:02 <mfp> dons: yes. Is jdh30 deleting his own posts?
16:42:06 <deech> Hi all, I'm trying to understand how to deal with errors in Haskell. But most code I read on Hackage seems to just fail with 'error "somemessage"'. Is this good practice?
16:44:08 <FunctorSalad_> deech: for library code, not so much... the problem is that you can only catch such impur errors in IO
16:44:50 <FunctorSalad_> if error-handling is to be expected, you might want to represent errors in pure data
16:44:57 <monochrom> Depends on case-by-case importance.
16:45:50 <deech> FunctorSalad_: Yeah that makes sense to me, but Haskell's exception mechanism is not bad. I'm surprised more people don't use it.
16:46:14 <FunctorSalad_> (Either String is the basic example for an error monad, but that's not so good for list producers, since it requires the whole result to be evaluated (as far as necessary to know it succeeded) before the first element is returned)
16:46:33 <FunctorSalad_> (alternative: something like in the failable-list package)
16:47:05 <FunctorSalad_> (or iteratee)
16:47:09 <benmachine> deech: the error function as I see it is useful for situations that the programmer can easily avoid
16:47:16 <benmachine> like, calling head on an empty list
16:47:48 <monochrom> In some cases I don't even write my own «error "message"». I just let pattern matching fail.
16:48:03 <benmachine> I would do that but GHC bitches :P
16:48:26 <benmachine> there is an argument for making that omission obviously intentional anyway
16:48:32 <monochrom> But it will never have a chance to hit that state and bitch. I can prove it.
16:48:51 <FunctorSalad_> famous last words
16:48:53 <FunctorSalad_> ;)
16:49:02 <monochrom> This is why I don't bother with oh-so-resilient-error-handling and oh-so-graceful-exit.
16:49:16 <FunctorSalad_> error "cosmic ray"
16:49:28 <benmachine> monochrom: I mean compile warning, not at runtime
16:49:36 <xerox> @time CosmicRay
16:49:38 <deech> So in what cases is it justifies to use full-blown exceptions?
16:49:41 <monochrom> I don't turn that one on.
16:49:51 <benmachine> oh
16:49:54 <benmachine> it comes in handy for me
16:50:00 <ben_m> If anyone with OpenGL knowledge could tell me why this won't zoom out/in when I turn the mousewheel, that would be awesome: http://sprunge.us/aIEC?haskell
16:50:08 <benmachine> obviously I am just not as hawk-eyed about spotting mistakes as you :P
16:50:11 <monochrom> David Parnas has a complete treatment on why and how of exceptions.
16:50:37 <benmachine> I never liked exceptions because they always seemed rather implicit to me
16:50:58 <benmachine> I write python code and exceptions keep turning up in sneaky corners and killing stuff
16:51:02 <benmachine> this upsets me
16:51:04 <monochrom> look for "undesired events"
16:51:13 <pickles> exceptions always seem sloppy to me
16:51:25 <FunctorSalad_> monochrom: hmm resilience isn't just about pretty exits... also about the surrounding code not dying when an inessential subaction fails
16:51:28 <monochrom> for example "response to undesired events in software systems"
16:51:35 <benmachine> http://portal.acm.org/citation.cfm?id=807717 this?
16:51:36 <benmachine> oic
16:51:43 <deech> pickles: I don't like them either, but how to deal with IO problems like database connections dying etc?
16:52:12 <monochrom> database connections dying counts as undesired events and eligible for exception.
16:52:29 <pickles> deech: yeah, sometimes i can see them being necessary, i just like to design the system such that it's regular mechanisms are smart enough to catch errors w/o going into special cases too much
16:52:30 <kmc> there is an important difference between "programmer errors" and "exceptional situations"
16:53:16 <deech> When I code all the exceptions I've used so far have been IO related. For the pure code it is unnecessary.
16:53:18 <monochrom> programmer mistakes should be on pain of death rather than hidden by exceptions.
16:53:33 <FunctorSalad_> kmc: in a large enough system I might want to have resistance to programming errors in inessential parts too rather than expecting to fix them all
16:53:39 <kmc> that too
16:53:49 <jbapple> dons: yeah, do you know what is going on with jdh30 on reddit today?
16:54:32 <deech> Exceptions are also handy for code reading.
16:54:47 <pickles> deech: i have yet to do much error handling in Haskell. most of my db/io related error programming was written in PHP, so i'd just print an error message and exit
16:55:21 <benmachine> Error: Language appears to be PHP :(
16:55:24 <pickles> although I did write an assembler in haskell recently, but i wouldn't count that as standard error handling, since any parse 'errors' encountered were accumulated and reported to the user
16:55:33 <pickles> benmachine: lol
16:56:00 <benmachine> :P
16:56:16 <pickles> (and in the assembler i tried to keep running to accumulate as many errors as possible before quitting, since i've heard that's good practice)
16:56:33 <benmachine> sometimes that's a good idea
16:56:47 <benmachine> like when GHC finds all of the identifiers that aren't in scope instead of just one
16:56:56 <pickles> mhm
16:57:00 <benmachine> but it used to *really* annoy me when GCC would find a header file missing and try to continue
16:57:11 <pickles> heheh
16:57:13 <benmachine> you almost invariably got a long list of totally irrelevant errors following
16:57:25 <pickles> yeah, that can be annoying
16:57:37 <pickles> only experience would immediately lead you to the header
16:57:44 <benmachine> mm
16:57:44 <pickles> would be nice to have some inbetween
16:57:57 <benmachine> I don't think there's a general solution to the problem
16:57:58 <FunctorSalad_> hmm make just lets you choose
16:58:11 <theorbtwo> That's one of the strange things; it seems to me that making missing header files an immediate error, rather then warn-and-continue, would have fixed the problem.
16:58:12 <benmachine> you just have to have a sort of heuristic approach to it
16:58:17 <FunctorSalad_> (-B = go on)
16:58:21 <benmachine> warnings, errors, fatal errors, really really fatal errors
16:58:50 <ben_m> Blah, learning OpenGL with a language you're not really that familar with was a bad idea.
16:58:53 <pickles> and non-fatal errors that cause sterility
16:59:06 <FunctorSalad_> sterility?
16:59:06 <ben_m> Now I never know if I'm doing something wrong on the opengl side or the haskell side
16:59:22 <pickles> ben_m: try it in C/C++ first?
16:59:30 <ben_m> yeah I should.
16:59:34 <ben_m> Just so much less awesome :)
16:59:42 <pickles> FunctorSalad_: did i spell it wrong?
16:59:54 <benmachine> pickles: inability to reproduce?
16:59:58 <pickles> yes
17:00:04 <FunctorSalad_> pickles: no, spelled right
17:00:05 <pickles> was a joke...
17:00:13 <benmachine> I think we just didn't get it sorry :P
17:00:18 <theorbtwo> ben_m: It's interesting that you mention out-of-scope identifiers.  Perl deliberately *doesn't* report all out of scope identifiers, but only once per function per identifier, so you don't get overwhelemed with errors.
17:00:19 <pickles> lol np np
17:00:23 <FunctorSalad_> :)
17:00:48 <ben_m> benmachine: I think theorbtwo meant to tab complete you, not me.
17:00:54 <kmc> ben_m, i don't think it's that bad an idea
17:00:55 <benmachine> yes I thought so
17:00:58 <benmachine> I got highlighted anyway
17:01:01 <benmachine> because irssi is silly
17:01:03 <ben_m> kmc: What is?
17:01:04 <kmc> if your program typechecks it's probably an OpenGL error
17:01:08 <ben_m> oh
17:01:08 <kmc> ;)
17:01:24 <benmachine> theorbtwo: yeah I think GCC does that too
17:01:36 <ben_m> using opengl kind of forces you to use iorefs all over the place :/
17:01:38 <kmc> ben_m, OpenGL is typically silent about errors
17:01:44 <kmc> there is a way to make it noisy
17:01:59 <kmc> export LIBGL_DEBUG=1
17:02:20 <FunctorSalad_> there was some function to poll the errors on the haskell side too
17:02:30 <kmc> yes
17:02:37 <ben_m> yeah no errors with that
17:02:46 <ben_m> It's probably not an error, but just using things incorrectly with no result.
17:02:47 <kmc> http://www.cs.caltech.edu/courses/cs171/gl_errors.shtml
17:02:56 <ben_m> Trying to scale out/in when turning the mouse wheel
17:02:59 <ben_m> By using translate
17:03:36 <ben_m> source, if anyone wants to check: http://sprunge.us/aIEC?haskell
17:03:50 <aavogt> split it up. Does the mouse wheel do other stuff... can you scale in and out without responding to that event?
17:04:23 <ben_m> The event does get called, I had a print statement in there
17:04:34 <Mathnerd314> hmm... what's the opposite of Haskell?
17:04:35 <pickles> ben_m: try setting things up to use keys to zoom in/out for the time, to verify your code, then try w/ the mouse -- that way you can isolate where the error is?
17:05:24 <benmachine> oh my goodness I ONLY JUST worked out that leksah is haskell backwards (ish)
17:05:33 * benmachine epiphany
17:05:35 <kmc> > reverse "haskell"
17:05:36 <sleepynate> hahaha
17:05:36 <FunctorSalad_> (a good example IMNSHO of things that shouldn't be fatal is errors in hooks in emacs o_o)
17:05:36 <lambdabot>   "lleksah"
17:05:41 <Saizan> good lord!
17:05:58 <FunctorSalad_> (I want to find files even when some autocompletion thing didn't load)
17:06:06 <kmc> ben_m, err, i'd do translations in the modelview matrix
17:06:09 <pickles> and saizan is nazi ass!
17:06:20 <pickles> (sorry to pick on you saizan)
17:06:39 <Saizan> ah! that too!
17:06:58 <theorbtwo> > reverse "theorbtwo"
17:06:58 <Saizan> i guess you uncovered my secret identity which i didn't know i had
17:06:59 <lambdabot>   "owtbroeht"
17:07:13 <pickles> wellp, my work is done, the sovereignty of godwins law has been established here
17:07:43 <pickles> saizan: ;)
17:07:46 <benmachine> heheh
17:07:57 <systemfault> Is emacs the best haskell editor because of the haskell mode plugin?
17:08:10 <Saizan> yes.
17:08:14 <benmachine> systemfault: best is a subjective term
17:08:30 <benmachine> you can say "a lot of people use..." or "recommend..."
17:08:43 <kmc> haskell-mode is pretty good
17:08:43 * benmachine uses vim due to being too lazy to learn anything else
17:08:57 <kmc> it's not good enough to override what you're otherwise comfortable with
17:09:01 <kmc> whereas, say, agda-mode is
17:09:12 <fax> agda only takes about 10 mins to typecheck a file
17:09:13 <fax> :)
17:10:04 <Saizan> is there a cofree monoid?
17:10:24 <pickles> i misread that as coffee at first
17:10:45 <systemfault> Ok :)
17:10:55 <theorbtwo> coffee is it's own category.
17:11:13 <monochrom> I drank coffee yesterday
17:11:17 <Saizan> (i.e. a functor F : Set -> Mon that's right adjoint to the forgetful one Mon -> Set )
17:11:19 <monochrom> @quote monochrom coffee
17:11:19 <lambdabot> No quotes match. Do you think like you type?
17:11:23 <monochrom> @quote monochrom cofree
17:11:23 <lambdabot> No quotes match. Maybe you made a typo?
17:12:54 <dolio> Saizan: I think if you work it out, cofree monoids aren't very interesting.
17:13:03 <dolio> Something like the () monoid.
17:13:10 <Sgeo> What's a cofree monoid?
17:15:11 <tensorpudding> the dual to a free monoid?
17:15:28 <dolio> Saizan: Because cofree stuff is terminal, and the one-element monoid is terminal.
17:15:52 <Saizan> a functor F such that there's an isomorphism between arrows (A -> B) and (A ~> F B), where Monoid A, and ~> is the type of those functions which respect the monoid structure
17:15:56 <Saizan> for every A and B
17:17:19 <Saizan> dolio: oh, i was also wondering, isn't the one-element monoid initial too? you can only have an arrow that maps the only element to the unit of the target monoid
17:17:23 <dolio> Terminal even if you require it to have an embedding from some other set.
17:17:23 <FunctorSalad_> hmm what if A = trivial monoid, Saizan
17:17:34 * syntaxglitch wonders how a cofree monoid differs from a comonoid
17:17:54 <FunctorSalad_> 1 -> B (= B) ~iso~ 1 ~> F B (= singleton)
17:18:02 <FunctorSalad_> fail, I'd say =)
17:18:15 <FunctorSalad_> (F doesn't exist)
17:18:35 <FunctorSalad_> (didn't mean "you fail", I mean the condition)
17:19:03 <Saizan> how do you derive that F doesn't exist from there?
17:19:27 <FunctorSalad_> because B isn't isomorphic to a singleton set for arbitrary B
17:19:49 <FunctorSalad_> (1 ~> F B is always a singleton unless I'm going mad)
17:20:53 <Saizan> ah, yeah, that's what i was saying above, that 1 is initial
17:21:13 <dolio> Saizan: If you think about the underlying set, and homomorphisms, an initial monoid can't identify two different elements of the underlying set, because some other monoid might not. So, injecting directly into that monoid would be different than injecting into the initial monoid, and applying the homomorphism.
17:21:33 <FunctorSalad_> hmm I deduce "doesn't exist" rather than "not very interesting" from it though :)
17:21:52 <dolio> But, for a terminal monoid, having the injection go to a unified element is the same as injecting into a monoid that distinguishes the two elements, and then applying a homomorphism that unifies them.
17:22:01 * pickles needs to learn more math
17:22:09 <dolio> Which is why a cofree monoid can be one element (I think).
17:22:16 * xerox needs to buy pickles
17:22:30 <FunctorSalad_> ah, I meant the functor doesn't exist
17:23:23 <pickles> xerox: ... are... are you... are you coming on to me?
17:23:35 <xerox> maybe
17:23:59 <pickles> :t Maybe
17:24:00 <lambdabot> Not in scope: data constructor `Maybe'
17:24:02 <FunctorSalad_> dolio: you mean B fixed to singleton set, A varying?
17:24:11 <xerox> :k Maybe
17:24:12 <lambdabot> * -> *
17:24:15 <FunctorSalad_> then F B = trivial mononid does, I guess
17:25:20 <FunctorSalad_> (does work)
17:25:46 <dolio> I'm talking about cofree monoids over some set B.
17:26:13 <dolio> It would be a monoid M with an injection B -> M, such that M is terminal in the category of such monoids, I believe.
17:26:22 <dolio> If my intuition is correct.
17:26:24 <sleepynate> can anyone perhaps explain why this type isn't matching? http://proggit.pastebin.com/qPrujrb7
17:26:34 <xerox> this is so opaque :(
17:26:38 <dolio> Er, not a mathematical injection. An embedding.
17:26:43 <sleepynate> never used Network.Socket before ><
17:26:49 <dolio> Some function B -> M.
17:26:51 <FunctorSalad_> dolio: hmm I was understanding 'cofree monoid' as in Saizan's adjunction
17:27:16 <dolio> FunctorSalad_: Well, if my intuition is correct, then what I said amounts to the same thing.
17:27:31 <FunctorSalad_> forget(A) -> B     ~nat iso in A and B~         A -> cofree(B)
17:27:36 <kmc> i have a question about this "the one-hole context of T is the derivative of T" thing
17:27:38 <dolio> The cofree monoid functor would be right adjoint to the forgetful functor from Mon to Set.
17:28:00 <kmc> binary trees of X are mu T. 1 + X*T*T, right?
17:28:07 <FunctorSalad_> (A : Monoid, B : Set)
17:28:11 <Saizan> sleepynate: what's the type of addrFamily ?
17:28:17 <sleepynate> Family
17:28:31 <Saizan> ?hoogle addrFamily
17:28:31 <lambdabot> Network.Socket addrFamily :: AddrInfo -> Family
17:28:35 <sleepynate> erm... that's what it should pull out
17:28:47 <twink> kmc: yeah
17:29:01 <FunctorSalad_> dolio: ah, you reversed 'initial' to 'terminal' there, but you must reverse the arrow too
17:29:15 <dolio> Which arrow?
17:29:22 <dolio> M -> B?
17:29:27 <Saizan> sleepynate: are you sure that code corresponds to the error? it doesn't make much sense
17:29:32 <FunctorSalad_> dolio: yes
17:29:45 <kmc> it seems that the derivative of (1 + X*T*T) with respect to T is X*T + X*T
17:29:46 <FunctorSalad_> eh wait
17:30:15 <byorgey> kmc: that's right
17:30:28 <kmc> but here it seems the one-hole context is mu C. 1 + X*T*C + X*T*C:  http://blog.ezyang.com/2010/04/you-could-have-invented-zippers/
17:30:32 <sleepynate> Saizan: yea.. i actually jumped into ghc 'cause I didn't believe it would be off :/
17:30:34 <kmc> btw great post ezyang
17:30:37 <sleepynate> ghci*
17:30:57 <kmc> so i think i'm missing some step that comes after differentiating
17:31:50 <FunctorSalad_> dolio: nvm, it was right (thought for a moment that my 'A' was your 'B')
17:32:04 <FunctorSalad_> (but 'B' is 'B' and 'M' is 'A')
17:32:12 <dolio> :)
17:32:43 <byorgey> kmc: but 1 + X*T*T isn't the type of binary trees
17:32:51 <byorgey> kmc: you need to start with  mu T. 1 + X*T*T
17:33:02 <FunctorSalad_> 'injection' confused me though, aren't these things more like surjections if they exist? like eval: A^B x B -> A
17:33:22 <kmc> byorgey, what's the rule for differentiating a fixed point?
17:33:50 <sleepynate> Saizan: it's part of a function to essentially just dump something over TCP, like curl
17:33:54 <FunctorSalad_> (for the (_ x B) -| (_ ^ B) adjunction... or maybe I flipped that too)
17:34:04 <dolio> FunctorSalad_: I didn't mean injection as one-to-one. I made that mistake when I was writing the article on free stuff, too. I just meant some way to turn elements of the underlying set into elements of the monoid.
17:34:12 <Saizan> dolio: so the free monoid over some set S would be the initial object in the category of monoids over S ? but not the initial object in the general category of monoids, right?
17:34:25 <FunctorSalad_> I meant it figuratively too
17:34:26 <dolio> Saizan: Yes.
17:34:55 <FunctorSalad_> I pictured units as embeddings, counits as quotient maps
17:35:15 <FunctorSalad_> hmm I'm not thinking very straight at this time ;)
17:36:36 <FunctorSalad_> Saizan: one technique to show that adjoints don't exist is that the left adjoint preserves colimits (right:limits)
17:37:30 <byorgey> kmc: let me think about it for a minute
17:38:10 <Saizan> FunctorSalad_: i think i know those less than adjoints :)
17:38:13 <FunctorSalad_> (hope I didn't confuse something again there)
17:41:18 <dolio> What's the coproduct of the trivial monoid with itself? The trivial monoid?
17:41:29 <Saizan> ?type let addrs = undefined :: [AddrInfo] in addrFamily (head addrs)
17:41:30 <lambdabot>     Not in scope: type constructor or class `AddrInfo'
17:41:30 <lambdabot> Not in scope: `addrFamily'
17:42:07 <sleepynate> Saizan: yea, I tried on lambdabot earlier in ##proggit :/
17:42:12 <kmc> byorgey, i'm looking at Conor McBride's paper on this, but it's got some pretty heavy machinery
17:42:18 <kmc> that i have not yet worked through
17:42:36 <dolio> FunctorSalad_: In that case, the forgetful functor wouldn't preserve coproducts, right?
17:42:46 <dolio> And thus couldn't have a right adjoint?
17:42:54 <dolio> So maybe my intuition was wrong.
17:43:18 <dolio> FunctorSalad_: I'm starting to think you're right about the M -> B.
17:43:40 <kmc> byorgey, ah, he explains it
17:44:17 <Saizan> sleepynate: the code you pasted typechecks in my ghci, though
17:44:53 <byorgey> kmc: ok, good.  you have to be careful about which variable you're differentiating with respect to.
17:44:58 <kmc> d_x(µy.F) = d_x(F[y ← µy.F])  (expand the fixed point)
17:45:32 <Saizan> there are two ways to derive the type of the zipper iirc, depending on what you consider "context"
17:45:40 <kmc> = d_x(F)[y ← µy.F] + d_y(F)[y ← µy.F] * d_x(µy.F)
17:45:44 <kmc> by chain rule
17:46:00 <byorgey> kmc: if you have a functor F(X,T) and take the fixpoint  mu T. F(X,T) you get a list of d/dt F  structures, and finally a d/dx F  structure
17:46:21 <byorgey> I mean if you take the derivative of  mu T. F(X,T)
17:46:36 <fax> this is cool
17:46:57 <fax> mu T, F[T] means T[X] = F[X,T[X]] so the derivative is like??
17:46:59 <kmc> = µz. d_x(F)[y ← µy.F] + d_y(F)[y ← µy.F]*z
17:47:02 <sleepynate> Saizan: well poop
17:47:12 <byorgey> kmc: right, that makes sense
17:47:27 <kmc> yeah
17:47:29 <kmc> to me as well, sort of
17:47:31 <kmc> thanks :)
17:48:13 <sleepynate> Saizan: maybe I have a bad versioning of libraries or something
17:48:36 <FunctorSalad_> dolio: hmm right (@coproducts), the initial monoid is {*} so forgetful({*}) would have to be the empty set
17:48:47 <sleepynate> Saizan: i'll go investigate further.. thanks for your help :)
17:48:53 <dolio> FunctorSalad_: Oh, that's even easier.
17:48:55 <Saizan> sleepynate: np
17:49:14 <dolio> Okay, I'm convinced.
17:49:29 <FunctorSalad_> did you have something involving binary coproducts?
17:49:39 <Saizan> oh, forgetful({*}) is the empty set? i thought it'd be the singleton set
17:49:42 <FunctorSalad_> these are free products in monoid I guess
17:49:46 <dolio> FunctorSalad_: I was thinking: trivial + trivial = trivial
17:49:58 <FunctorSalad_> Saizan: it would have to be the empty set to preserve the initial obj
17:50:02 <FunctorSalad_> but it doesn't
17:50:09 <dolio> But forget(trivial) + forget(trivial) = 2.
17:50:15 <FunctorSalad_> (since forgetful({*}) = {*} indeed)
17:50:20 <ezyang> I have a csv file and I want to graph it. What hackages do I want?
17:50:25 <FunctorSalad_> dolio: oh, right
17:51:18 <dolio> Saizan: We've determined that the forgetful functor can't have a right adjoint, because it doesn't preserve colimits.
17:51:28 <FunctorSalad_> yes
17:51:45 <dolio> So there are no cofree monoids.
17:51:47 <Saizan> ah, ok, i was just guessing something like that was going on :)
17:52:28 <FunctorSalad_> dolio: this only showed that there isn't one for every set (but my prev argument showed that the only one is the trivial monoid)
17:53:19 <FunctorSalad_> (the homset bijection Set(1,B) ~ Mon(1,cofree(B)))
17:54:51 <FunctorSalad_> (for preserving colimits you need the whole functor cofree)
17:56:30 <dolio> I'm not sure Set(1, B) ~ Mon(1, cofree(B)) determines things uniquely up to isomorphism.
17:57:29 <dolio> It determines B to be terminal, I guess.
17:58:21 <dolio> Because Mon(1, cofree(B)) has one element regardless of what cofree(B) is.
17:59:57 <Mathnerd314> would if' b x y = if b then x else y be a fold?
18:00:06 <FunctorSalad_> dolio: I didn't mean it determines B; I mean that specialization alone shows it fails
18:00:30 <dolio> Oh, okay.
18:00:40 <FunctorSalad_> (specialized A := 1)
18:01:03 <dolio> Mathnerd314: Yes, possibly.
18:01:04 <Cale> Mathnerd314: It's sort of the catamorphism for Bool
18:01:23 <Mathnerd314> so is there some automatic ADT -> fold operation?
18:01:28 <dolio> If you consider Bool to be defined as the fixed point of a constant functor, then it definitely is. :)
18:01:32 <Cale> No, but there could be
18:01:37 <Cale> Charity has one
18:01:53 <FunctorSalad_> (for the reason you said: the right side is singleton regardless of cofree(B))
18:02:10 <Cale> Someone could probably do it with Template Haskell
18:03:15 <FunctorSalad_> Cale Mathnerd314 : there's fold-th. I tried to vastly extend it to cover GADTs but left it in an almost-done state when it got unappealingly messy
18:03:30 <FunctorSalad_> (the stuff it generates, not just my program ;))
18:03:37 <dolio> Epigram 2 has them, too. :)
18:03:55 <FunctorSalad_> for complex GADTs I guess you're better of with just writing out the case statement
18:04:11 <Cale> FunctorSalad_: Oh, cool. You should write a quasiquoter supporting a case-like syntax for folds :)
18:04:25 <fax> didn't mmorrow do that
18:04:33 <fax> mm maybe it didn't support GADTs
18:04:34 <Mathnerd314> FunctorSalad_: you mean th-fold?
18:04:42 <Mathnerd314> http://hackage.haskell.org/package/th-fold
18:04:46 <FunctorSalad_> Mathnerd314: yes
18:04:57 <Cale> I requested that various people familiar with TH do it a few times, not sure if anyone did :)
18:05:08 <FunctorSalad_> IIRC I sent in a patch with some of the additions, but got no reply
18:05:23 <FunctorSalad_> Cale: what would be the point of the case-like syntax?
18:05:30 <FunctorSalad_> (over just using 'case')
18:05:45 <FunctorSalad_> the fold is for when you want to just give the function, no?
18:06:44 <Cale> FunctorSalad_: It'd just look nice. For example, for the tree type: data Tree a = Tip | Branch a (Tree a) (Tree a), say, you could write something like   size = cata { Tip -> 0; Branch x l r -> 1 + l + r }
18:07:13 <Cale> That is, the recursion becomes implicit.
18:07:23 <fax> I like that
18:07:31 <FunctorSalad_> Cale: maybe just generate the Algebra type?
18:07:56 <Cale> Well, I guess it saves you from having to do that
18:08:00 <FunctorSalad_> TreeAlgebra a r = TA (r, r -> a -> r -> r)
18:08:15 <FunctorSalad_> (ignore unnecessary use of tuple)
18:08:49 <FunctorSalad_> the type for that gets evil with GADTs, though
18:09:10 <FunctorSalad_> you will have to cover an inductively defined set of types over r, not just r
18:09:16 <Cale> also, automatically trying to generate types has stupid issues like what to call the constructors and such
18:10:11 <FunctorSalad_> (since the type parameter of subexpressions is different from `a')
18:10:18 <FunctorSalad_> *type parameter instantiation
18:10:40 <fax> what wouldbe nice is a way to add new language constructs such as 'cata'
18:10:47 <FunctorSalad_> TH
18:11:04 <fax> or maybe just have th compiler written in a way that you can actually modify it without spending years learning how
18:11:09 <FunctorSalad_> just needs a bit more convenience ;)
18:11:15 <FunctorSalad_> (not sure how)
18:11:59 <FunctorSalad_> it's not that hard to learn, the AST manipulations are just a bit tedious
18:12:42 <FunctorSalad_> (for things were you can't use the quotation brackets)
18:12:58 <fax> haskell macros!
18:13:06 <fax> I have a great idea
18:14:00 <FunctorSalad_> well, TH *is* macros
18:14:14 <FunctorSalad_> just without having the advantage of the lang having a simple syntax like lisp
18:14:28 <FunctorSalad_> (hmm, sexp-haskell anyone? :D)
18:14:48 <Cale> That exists, it's called liskell
18:14:51 <FunctorSalad_> oh
18:14:55 <fax> nooo
18:16:39 <pickles> isn't that always the way
18:16:55 <pickles> you come up w/ a great idea only to find someone has already implemented it
18:17:08 <pickles> and there's already a whole community around it
18:19:39 <FunctorSalad_> hmm more often it's dead and you think you might as well start from scratch ;)
18:21:23 <FunctorSalad_> that's a disadvantage of 'avoid success at all costs', I guess...
18:21:36 <FunctorSalad_> (less chance of someone adopting a project)
18:21:37 <pickles> heheh
18:21:54 <FunctorSalad_> (a dead project, I mean)
18:22:08 <FunctorSalad_> (hmm, adopting dead things? analogy breakdown)
18:22:24 <brunodea> It`s only here or hpaste.org isnt working?
18:22:38 <pickles> i wanna twist that line to zombies somehow, but cant' think of a way
18:30:40 <Mathnerd314> hmmm... is this the most recent liskell activity? http://blog.clemens.endorphin.org/2009/01/liskell-standalone.html
18:32:52 <mjrosenb> was liskell haskell with lisp syntax, or lisp with haskell syntax?
18:33:04 <Dark_Shikari> "Prelude.read: no parse"  <--what in the world does this even mean?
18:33:23 <Axman6> > read "abc" :: Int
18:33:24 <lambdabot>   * Exception: Prelude.read: no parse
18:33:28 <Mathnerd314> mjrosenb: the former
18:33:31 <Dark_Shikari> what does it _mean_ though?
18:33:46 <Axman6> it means you gave it something that it can't read into a datatype
18:33:55 <Axman6> couldn't parse it
18:33:57 <Dark_Shikari> rather crappy error message, but I guess that works
18:34:01 <Mathnerd314> the read function you passed does not understand the string you gave it
18:34:14 <Axman6> Dark_Shikari: do you know what parsing is?
18:34:23 <Dark_Shikari> yes
18:34:30 <Dark_Shikari> "no parse" is rather useless
18:34:38 <Dark_Shikari> it could say "could not parse %d as integer"
18:34:58 <Dark_Shikari> er, %s
18:35:15 <Axman6> i take it you're new to haskell?
18:35:23 <Dark_Shikari> no, I've been using it a month or two
18:35:29 <Dark_Shikari> most other errors are a lot more verbose
18:35:32 <Dark_Shikari> as opposed to two words
18:35:50 * mjrosenb usually writes wrapper functions for everything to give more useful error messages
18:35:56 <blackdog> Dark_Shikari: Read is a bit impoverished, really.
18:35:58 <Dark_Shikari> lol
18:36:05 <Dark_Shikari> guess that works as well.
18:36:10 <blackdog> if you write parsec parsers, you'll usually get more reasonable messages
18:36:11 <Axman6> Read is usually poor man's parsing
18:36:24 * Dark_Shikari notes that it is not my code that's using read.
18:36:35 * mjrosenb found that read :: string -> double parses "" as 0.0 :(
18:36:55 <mjrosenb> :: String -> Double
18:37:12 <Mathnerd314> > read "" :: Double
18:37:13 <lambdabot>   * Exception: Prelude.read: no parse
18:37:14 <Dark_Shikari> oh, good, it seems that I wrote [0-9]* as my regex instead of [0-9]+
18:37:18 <Dark_Shikari> That explains that.
18:37:31 <blackdog> Dark_Shikari: you'd usually use read just for playing around, quick and dirty stuff.
18:37:33 <Mathnerd314> ^ mjrosenb
18:38:18 <mjrosenb> Mathnerd314: odd.  i know that something got 0.0 rather than the value that it was supposed to due to me discarding the actual value
18:38:41 * mjrosenb wonders if he discarded "13." from "13.0"
19:04:19 <Gracenotes> hey, I gave a talk on Haskell for my university's linux user group. Here are the slides: https://docs.google.com/fileview?id=0B_a5MxwyB_zYOTIwOWU3OWUtZjEyYy00YjU1LWJlYmYtY2FiNDc0N2YxMDA4&hl=en
19:05:01 <Gracenotes> it was kind of fun :)
19:08:26 * hackagebot hoopl 3.7.7.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.7.0 (NormanRamsey)
19:09:23 <Associat0r> guys what are the pro's and cons of Uniqueness typing vs Monads for IO?
19:09:45 <kmc> Associat0r, monads are much more general, we'd want to have them anyway
19:09:52 <kmc> and so once you have it, you might as well use it for IO too
19:10:06 <kmc> (that said whether a language "has monads" is really a matter of convenient syntax only)
19:10:20 <kmc> (you can implement monads in any language with first-class functions and polymorphism)
19:10:35 <Associat0r> kmc: I know about that
19:10:40 <dolio> Uniqueness typing requires you to directly use the RealWorld -> (a, RealWorld) 'model' of IO, which is pretty questionable.
19:10:58 <dolio> As far as I know, at least.
19:11:09 <kmc> uniqueness typing might be more easily compiled
19:11:15 <kmc> to efficient code
19:11:25 <kmc> to generate efficient code, GHC has to see pretty far into the definition of the IO monad
19:11:33 <kmc> which it has no problem doing, but lesser compilers might
19:11:56 <dolio> Uniqueness typing is much more attractive to me for mutable arrays.
19:12:11 <kmc> is uniqueness typing the same thing as linear types
19:12:21 <dolio> No. They're somewhat different.
19:12:24 <Associat0r> related
19:12:27 <ddarius> dolio: It requires no such thing.
19:12:47 <dolio> ddarius: What other module would you use? Some kind of unique continuation?
19:12:48 <Gracenotes> dolio: do they prevent you from accessing broken old references to the array?
19:13:25 <dolio> Seems to me that continuations would want more of a linear typing.
19:13:47 <ddarius> dolio: I assume "module" = "model".  You can do exactly what is done in Haskell.  There's no reason to have the IO type not be abstract in that setting as wel.
19:14:22 <ddarius> Yay, hoopl is on hackage.
19:14:29 <dolio> Well, yes. But then you're not talking about using uniqueness types in lieu of IO.
19:14:42 <dolio> You're talking about using uniqueness types to implement the IO abstraction.
19:14:48 * Mathnerd314 fails at learning Template Haskell
19:15:11 <SamB_XP> Mathnerd314: you cannot fail, you can only delay success
19:15:21 <ddarius> indefinitely
19:15:27 <SamB_XP> see, this is why we haven't managed to avoid success here in the Haskell community
19:15:35 <SamB_XP> like was our goal
19:15:57 <Mathnerd314> I want to figure out how that fold generator works...
19:16:05 <dolio> And yes, I meant "model". My fingers have a mind of their own.
19:16:58 <Mathnerd314> the first thing is that it has type Name -> ExpQ. How do I construct a Name?
19:17:12 <SamB_XP> dolio: what's the diff between "model" and "implement"?
19:18:00 <Saizan> Mathnerd314: usually by quoting something with ' if it's a value or '' if it's a type
19:18:18 <aavogt> @hoogle String -> Name
19:18:18 <lambdabot> Language.Haskell.TH mkName :: String -> Name
19:18:18 <lambdabot> Language.Haskell.TH.Syntax mkName :: String -> Name
19:18:18 <lambdabot> Language.Haskell.TH.Syntax mkNameL :: String -> Uniq -> Name
19:18:21 <Saizan> i.e. a = ''Int; show a == "Int"
19:19:00 <dolio> SamB_XP: When someone asks about advantages of uniqueness types with regard to IO, I presume they're talking about using uniqueness types directly, instead of dealing with an oft-maligned IO type.
19:19:32 <dolio> If the only use of uniqueness types is to implement the IO abstraction, then there's almost no reason for the average user to care.
19:21:28 <Mathnerd314> @hoogle reify
19:21:28 <lambdabot> Language.Haskell.TH reify :: Name -> Q Info
19:21:28 <lambdabot> Language.Haskell.TH.Syntax reify :: Name -> Q Info
19:21:28 <lambdabot> Language.Haskell.TH.Syntax qReify :: Quasi m => Name -> m Info
19:22:34 <Mathnerd314> how do I print a value of Q Info?
19:22:35 <dolio> Of course, I agree that if you're going to implement IO a as RealWorld -> (RealWorld, a), then it's nice to have the type system enforce correctness. But that way of thinking about IO is sketchy when you look at the full range of what gets put in IO, so I don't think I'd recommend using it directly in a program.
19:23:27 <dolio> Or as anything other than a hack low down in the compiler chain, that works, but isn't pretty.
19:24:36 <aavogt> Mathnerd314: (>>= stringE . show)?
19:25:26 <aavogt> or    runIO . print
19:25:36 <Axman6> runIO?
19:25:52 <aavogt> @hoogle runIO
19:25:52 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
19:25:53 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
19:25:53 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
19:30:06 <Mathnerd314> none of those work...
19:33:22 <aavogt> Mathnerd314: then you're using them wrong
19:33:39 <dolio> Gracenotes: Oh, sorry about not responding. I've not used Clean, so I'm not really sure how it works, but it'd be something like having a DiffArray where whether copying has to be done is checked in the type system.
19:33:55 <aavogt>   $( stringE . show =<< reify ''SomeTypeName )
19:34:18 <aavogt> runs the actual Q Expr, which is actually a String here
19:34:27 <Mathnerd314> ah, that works.
19:35:23 <dolio> So if you do in fact use it in a single-threaded manner, it can be optimized into mutable update, and so you could probably write direct-style, functional algorithms that nevertheless have the performance of something like ST.
19:36:34 <gwern> could. but last I looked clean was still beating haskell on the shootout
19:36:34 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
19:36:39 <gwern> @messages
19:36:39 <lambdabot> aavogt asked 2d 23h 28m 26s ago: can mueval have an interface to enable some -X flags?
19:37:18 <gwern> preflex: seen aavogt
19:37:19 <preflex>  aavogt was last seen on #haskell 3 minutes ago, saying: runs the actual Q Expr, which is actually a String here
19:37:22 <gwern> aavogt: some language extensions? I dunno, most of them are for types, not expressions, and I always worry about new holes
19:37:37 <aavogt> gwern: stuff like -XViewPatterns in particular
19:37:59 <gwern> aavogt: how would you use that in an expression?
19:38:17 <aavogt> let f (g -> y) = y in f something
19:38:53 <gwern> hm. you actually want that in mueval?
19:38:55 <aavogt> they have a pretty straightforward translation to pattern guards
19:39:01 <aavogt> no, I want it in \bot
19:39:22 * gwern means people would actually evaluate view pattern expressions?
19:40:20 <Gracenotes> dolio: oh, hey. that makes sense by the way, to the extent I thought about it when pkill -9 chrome apparently wiped out something the OS needed
19:40:22 <Gracenotes> from what I've seen of Clean, it doesn't look so different from Haskell on the surface..
19:40:56 <gwern> Gracenotes: it isn't. last I heard, they were even working on a frontend to the clean compiler that would take haskell 98
19:41:07 <Gracenotes> now DDC, that's some good stuff, to the extent I've grokked the codebase (barely)
19:41:37 <aavogt> well they can't unless they are accepted
19:41:41 <gwern> (but really, clean is pretty much dead)
19:42:42 <Mathnerd314> @hoogle instance Monad
19:42:43 <lambdabot> No results found
19:43:42 <Mathnerd314> hmm... there must be a command to show all the monads
19:43:56 <Mathnerd314> @instances Monad
19:43:56 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:44:18 <gwern> truly, lambdabot does more tricks than an evangelical pastor
19:44:43 <aavogt> but can it do some more?
19:44:46 <Mathnerd314> @src Either return
19:44:46 <lambdabot> return        = Right
19:44:51 <Mathnerd314> @src Either >>=
19:44:51 <lambdabot> Source not found. My pet ferret can type better than you!
19:44:56 <Mathnerd314> @src Either (>>=)
19:44:56 <lambdabot> Left  l >>= _ = Left l
19:44:57 <lambdabot> Right r >>= k = k r
19:46:08 <gwern> aavogt: I suppose it'd just be a matter of adding another cli flag and another line in the interpretre function
19:46:15 <gwern> aavogt: you could do it
19:48:20 <applicative> @src []  (>>=)
19:48:20 <lambdabot> Source not found. Maybe you made a typo?
19:48:40 <aavogt> what is the foundation for language extensions introducing holes?
19:49:16 <applicative> @src Maybe (>>=)
19:49:17 <lambdabot> (Just x) >>= k      = k x
19:49:17 <lambdabot> Nothing  >>= _      = Nothing
19:49:44 <SamB_XP> aavogt: well, the people who design them don't have mueval in mind, is part of it ;-P
19:51:06 <applicative> )))))))))))))))))***
19:51:30 <applicative> sorry, stepped on keyboard...
19:52:23 <gwern> aavogt: offhand, I don't know of any new holes introduced by ghc extensions, but I think part of that is no one who understands them has gone looking
19:52:28 <gwern> probably oleg knows a bunch
19:53:33 <applicative> @instances Functor
19:53:34 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:54:12 <applicative> It would be nice if lambdabot knew a simple tree type, to illustrate some points
19:56:04 <applicative> RWST r w s m  is all well and good
19:56:16 <Sgeo> RWS?
19:56:54 <applicative> Don't enquire.  It nearly killed me in the HPDF library
19:57:18 * Sgeo continues enquiring
19:58:52 <Sgeo> Does anyone ever use things like STRef s (STRef s a)?
20:01:04 <kmc> probably
20:01:09 <kmc> people use double and triple pointers in C
20:01:18 <kmc> i think i saw a quadruple pointer once
20:01:19 <Gracenotes> they're not too common though
20:01:43 <Pseudonym> Triple pointers are rare without some typedef indirection.
20:01:45 <Gracenotes> a true double pointer for something that you don't do pointer arithmetic (i.e. arrays) on
20:01:56 <systemfault> C++ doesn't have that problem :P
20:02:17 <applicative> @type newSTRef -- still looking
20:02:18 <lambdabot> forall a s. a -> ST s (STRef s a)
20:02:18 <Pseudonym> C++ has iterators that store pointers and iterators to iterators.
20:02:20 <Draconx|Laptop> double pointer is a terrible name for pointers to pointers, since there is something else called a double pointer, namely the type double *.
20:02:28 <kmc> heh
20:02:29 <kmc> that's true
20:02:31 <Gracenotes> oh. true.
20:02:36 <kmc> "pointer to double" might be a better name for it, though
20:02:40 <kmc> but verbose
20:02:43 <Pseudonym> "double" is a bad name for a double-precision floating point number.
20:03:06 <Draconx|Laptop> Pseudonym, maybe, but it is nevertheless ubiquitous.
20:03:07 <Pseudonym> ieee_754_extended_precision_t
20:03:11 <Pseudonym> Much better!
20:03:13 <Gracenotes> you could call a long a double, dword at least. (depending on whether you're keeping old definitions of dword)
20:03:26 <Draconx|Laptop> Pseudonym, extended precision means something else entirely in ieee 754.
20:03:26 <Sgeo> What would be some nice code to show someone who's never seen Haskell before?
20:03:35 <Pseudonym> True.
20:03:48 <Makoryu> I have devised a truly marvelous set of semantics for the WhatIsAMonad monad, but this IRC channel is too narrow to contain the definition.
20:04:03 <applicative> Sgeo, obviously an inefficient definition of quicksort
20:04:05 <Pseudonym> Sgeo: Depends what they're interested in.
20:04:16 <Gracenotes> one use for pointers^2 is passing it to a function, so the function can modify the data the pointer points to, or replace it with an entirely different pointer, malloc'd from somewhere else
20:04:26 <Sgeo> I think I'm more interested in showing them Haskell then they are at learning it
20:04:31 <Makoryu> Sgeo: http://neilmitchell.blogspot.com/2010/04/file-recovery-with-haskell.html <- I am bored so I'll suggest this
20:04:49 <wolgo> greetings friends
20:05:05 <wolgo> does it make sense to represent a tree with a list?
20:05:13 <Gracenotes> Sgeo: I'm glad you asked! I tried my hand today at a Haskell presentation for my school's linux group: http://docs.google.com/fileview?id=0B_a5MxwyB_zYOTIwOWU3OWUtZjEyYy00YjU1LWJlYmYtY2FiNDc0N2YxMDA4&hl=en
20:05:20 <wolgo> I ask in this room because you are friendly people.
20:05:33 <arw_> wolgo: sometimes, yes. generally, no.
20:05:42 <SamB_XP> wolgo: what language are you using ?
20:05:46 <gwern> Gracenotes: I would not have thought sbu students were very sympathetic to fpls
20:05:51 <arw_> wolgo: depends on what you intend to do and what you have to work with.
20:05:53 <Makoryu> wolgo: Usually you um well sometimes.
20:06:01 <wolgo> well I am using ruby
20:06:13 <Makoryu> （　≖‿≖）
20:06:15 <Gracenotes> Sgeo: at the end I have a huffman-to-dot program using the recently uploaded huffman package
20:06:16 <SamB_XP> wolgo: if I was going to use lists, there would probably be a lot of them involved ;-)
20:06:19 <wolgo> I am asking here because good answers and information is in this room
20:06:38 <Makoryu> wolgo: I never really found a good solution for representing trees in Ruby.
20:06:39 <pickles> and people actually talk ;)
20:06:48 <wolgo> SamB_XP: I am considering a hash too
20:06:52 <Gracenotes> gwern: well, maybe half a dozen people where there. I enjoyed it at least, and there was dialogue
20:06:55 <wolgo> Makoryu: yes I am noticing
20:06:56 <Gracenotes> *were
20:06:58 <gwern> ahah, at long last, I learn Gracenotes's last name
20:07:00 <SamB_XP> but only for a tree with nodes of arbitrary degree
20:07:04 <wolgo> I am teaching myself data structures
20:07:06 <BMeph> wolgo: According to Data.Tree, yes. ;)
20:07:14 <gwern> Gracenotes should've read _True Names and Other Dangers_ bwa ha ha
20:07:17 <wolgo> and modeling a tree is tough in ruby.
20:07:28 <wolgo> I know in haskell I might use a list of tuples
20:07:31 <Makoryu> wolgo: It's mainly just syntactically awkward
20:07:34 <wolgo> but I do not know haskell
20:07:37 <Gracenotes> gwern: it's not so hard to find, Mr. Branwen
20:07:41 <wolgo> Makoryu: yes, I have noticed
20:07:59 <gwern> Gracenotes: I didn't really try, so to have it handed to me on a silver platter is nice
20:08:13 <Makoryu> Also, why would you use a list of tuples (of all things) in Haskell, when you could use a tree datatype?
20:08:16 <Gracenotes> I do have a nytimes article linking my psuedonym and real name...
20:08:29 <SamB_XP> wolgo: well, why do you not know Haskell?
20:08:52 <Runar> wolgo: Modeling a tree is easy. It's just the cofree comonad for the list functor.
20:08:57 <Runar> Any foo know that
20:09:06 <SamB_XP> Runar: hush, you bar you!
20:09:19 <wolgo> SamB_XP: mainly because of things like what Runar said
20:09:20 <wolgo> lol
20:09:21 <pickles> damn, i read that as 'coffee' again...
20:09:27 <applicative> BMeph, what does Data.Tree say
20:09:35 <Runar> coffee is the dual of ffee
20:09:37 <SamB_XP> wolgo: he's just trying to scare you or ... be silly
20:09:41 <wolgo> I have written quite a few haskell programs
20:09:43 <wolgo> small ones
20:09:44 <SamB_XP> pickles: me too ;-)
20:09:51 <pickles> hehe
20:10:04 <Pseudonym> I wrote a small Haskell program once.  It was diff.
20:10:13 <SamB_XP> wolgo: just because you haven't a clue what Runar just said doesn't have a thing to do with whether you know Haskell ;-)
20:10:14 <Pseudonym> Haskell is nice like that.
20:10:21 <wolgo> I was making hangman and I could not output anything
20:10:30 <BMeph> applicative: Nothing, silly, it's a module! ;
20:10:34 <wolgo> I like haskell. I want to learn it
20:10:44 <Pseudonym> wolgo, you've come to the right place.
20:10:50 <wolgo> but I do not understand output
20:10:54 <Pseudonym> Aha.
20:10:54 <wolgo> or input
20:10:56 <SamB_XP> BMeph: surely it has some sources, and possibly some comments ;-P
20:11:10 <wolgo> and it makes it impossible for me to see my programs working
20:11:11 <Pseudonym> wolgo: Do you have access to a university library?
20:11:12 <applicative> Yes, in Data.Tree, a tree is a pair of a label and a list of trees
20:11:14 <wolgo> well, kind of
20:11:27 <pokoko222> someone wanna help me prove 1/a + 1/b + 1/c >= 9/a+b+c please?
20:11:38 <wolgo> Pseudonym: no but I have the internet though
20:11:43 <BMeph> SamB_XP: Surely it has it all. But you'd have to read them, they don't _say_ anything... ;
20:11:45 <Pseudonym> Excellent.
20:11:47 <SamB_XP> pokoko222: hmm, they weren't helping in #coq ?
20:11:48 <Pseudonym> http://book.realworldhaskell.org/ <- Start reading.
20:11:59 <wolgo> oh yes
20:12:01 <pokoko222> SamB_XP thnx will try there
20:12:08 <applicative> pokoko222 maybe we could use quickcheck
20:12:20 <pokoko222> applicative what is that?
20:12:21 <Pseudonym> If you need help, feel free to ask.  If the authors aren't here, the reviewers are.
20:12:31 <Sgeo> @quickcheck
20:12:31 <lambdabot> Unknown command, try @list
20:12:35 <aavogt> quickcheck is not a proof
20:12:36 <wolgo> I solved some python challenges in haskell
20:12:38 <gwern> @check \a b c ->  1/a + 1/b + 1/c >= 9/a+b+c
20:12:38 <applicative> @list
20:12:39 <lambdabot>   "Falsifiable, after 7 tests:\n1.25\n-1.0\n-2.0\n"
20:12:39 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:12:44 <Pseudonym> quick + check == proof?
20:12:49 <Pseudonym> That'd be fun to prove.
20:12:50 <applicative> there we go
20:12:51 <gwern> aavogt: quickcheck is a proof. of thousands of conjectures!
20:13:01 <aavogt> haha
20:13:11 <pokoko222> wow so it prooved this is wrong?
20:13:12 <ddarius> Usually 500.
20:13:24 <applicative> quickcheck does provide valid refutations, no
20:13:26 <SamB_XP> > \a b c ->  1/a + 1/b + 1/c >= 9/(a+b+c)
20:13:27 <lambdabot>   -0.375->
20:13:28 <lambdabot>    -0.375->
20:13:28 <lambdabot>      -0.375->
20:13:28 <lambdabot>        True
20:13:28 <lambdabot>      -0.75->
20:13:29 <lambdabot>        False
20:13:31 <lambdabot>   ...
20:13:34 <SamB_XP> @check \a b c ->  1/a + 1/b + 1/c >= 9/(a+b+c)
20:13:35 <lambdabot>   "Falsifiable, after 10 tests:\n-1.6666666666666665\n3.0\n2.0\n"
20:13:45 <gwern> pokoko222: I'm guessing that maybe there's a restriction you didn't mention
20:13:49 <Sgeo> Maybe it's true for Integers?
20:13:50 <gwern> pokoko222: naturals perhaps?
20:13:53 <aavogt> perhaps we shouldn't use Double here
20:13:55 <pokoko222> positive reals
20:13:56 <aavogt> or rationals
20:13:57 <Pseudonym> Positive reals?
20:13:58 <Pseudonym> Right.
20:14:06 <SamB_XP> @check \a b c -> 1/a + 1/b + 1/c >= (9/(a+b+c) :: Rational)
20:14:07 <lambdabot>   "Falsifiable, after 1 tests:\n(-1) % 1\n1 % 1\n1 % 1\n"
20:14:15 <SamB_XP> @type forall
20:14:16 <lambdabot> Not in scope: `forall'
20:14:22 <Pseudonym> @check \a b c -> 1/abs a + 1/abs b + 1/abs c >= 9/(abs a + abs b + abs c)
20:14:23 <lambdabot>   "OK, passed 500 tests."
20:14:28 <pokoko222> wow :D
20:14:36 <Sgeo> @check \a b c ->  (1/a + 1/b + 1/c >= 9/(a+b+c)) || a<0 || b<0 || c<0
20:14:36 <idnar> of course, that doesn't prove anything
20:14:36 <lambdabot>   "OK, passed 500 tests."
20:14:42 <applicative> pokoko222, this is not a  proof
20:14:45 <Pseudonym> Sgeo: abs checks more cases.
20:14:52 <Pseudonym> But yeah, you can do thqt too.
20:15:06 <pokoko222> applicative i know, i dont know how to do it formally
20:15:23 <ddarius> pokoko222: Simply calculate.
20:15:26 <applicative> it's even more awesome than a proof
20:15:34 <SamB_XP> well, if you can do it in Coq without unsound axioms ;-)
20:15:39 <gwern> calculate onward, and faith will come
20:16:15 * Sgeo should be studying for his history exam
20:16:21 <SamB_XP> oh, you mean he should calculate algebraicly eh?
20:16:27 <Sgeo> Can't use Haskell there :/
20:16:35 <gwern> SamB_XP: that's how I'd approach it. is there a better way?
20:16:40 <ddarius> SamB_XP: There's more than one way to calculate it.
20:16:48 <Runar> wolgo: What kind of tree do you want to model?
20:16:52 <SamB_XP> gwern: I dunno.
20:16:57 <applicative> \conqueror -> conqueror crossed the Rubicon
20:16:58 <SamB_XP> I'm not sure if I'd get it that way ...
20:17:03 * SamB_XP thinks
20:17:44 <SamB_XP> oh, I know what I'd do
20:17:49 <Sgeo> 1/a + 1/b + 1/c = bc/abc + ac/abc + ab/abc
20:17:51 <SamB_XP> I'd take all the bottoms off the fractins
20:18:03 <aavogt> triangle inequalities
20:18:27 <Pseudonym> Hint:
20:18:36 <Pseudonym> Arithmetic mean = (a + b + c)/3
20:18:46 <Pseudonym> Harmonic mean = 3/(1/a + 1/b + 1/c)
20:18:52 <Pseudonym> And arithmetic mean >= harmonic mean
20:18:55 <monochrom> Hint: This is not pokoko222's personal math tutoring room.
20:19:18 <SamB_XP> Pseudonym: are you suggesting that generalizing will make it easier ?
20:19:20 <kmc> monochrom, it is now, he got kicked out of #math
20:19:27 <Pseudonym> SamB: Perhaps.
20:19:31 <SamB_XP> kmc: that's not very hard ;-P
20:19:33 <ddarius> SamB_XP: Generalizing often simplifies.
20:19:37 <SamB_XP> I hear they kick you for sneezing
20:19:38 <ddarius> or at least clarifies.
20:19:41 <Pseudonym> Yeah.
20:19:43 <SamB_XP> ddarius: it's funny how that works!
20:19:49 <applicative> pokoko222, it surprises me that you can write this down and not do the calculation.
20:19:50 <monochrom> Well I can get him kicked out of #haskell too if that helps.
20:19:52 <ddarius> SamB_XP: Not really.
20:19:53 <SamB_XP> but yes, I've noticed it too
20:19:55 <Sgeo> How do you prove that arithmetic mean >= harmonic mean
20:19:58 <ddarius> SamB_XP: It's akin to parametricity.
20:19:58 <Pseudonym> Personally, when I see an elementary inequality, I try to generalise it to a classical inequality.
20:20:18 <SamB_XP> Pseudonym: I don't even know what that MEANS
20:20:19 <ddarius> Sgeo: Induction.
20:20:31 <SamB_XP> Sgeo: QuickCheck!
20:20:36 <Sgeo> lol
20:20:49 <monochrom> He is welcome to complain to #math "it is #math's fault that #haskell kicked me out"
20:20:51 <Pseudonym> SamB: Classical inequalities are inequalities like the triangle inequality, AM >= GM >= HM, Cauchy inequality etc.
20:21:03 <SamB_XP> Pseudonym: ah.
20:21:16 <SamB_XP> 0 > 1, that kind of thing?
20:21:30 <Pseudonym> For large values of 0.
20:21:31 <monochrom> 0>1 is a cool inequality :)
20:21:32 <kmc> @check \x -> 0 > 1
20:21:33 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
20:21:40 <applicative> there is a constant c such that 1/a >= c/a  clearly
20:21:44 <Pseudonym> @check \0 -> 0 > 1
20:21:45 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
20:22:08 <applicative> now we make an induction on the number of terms
20:22:13 <SamB_XP> @quickcheck \0 -> 0 > 1
20:22:13 <lambdabot> Unknown command, try @list
20:22:24 <SamB_XP> @scheck \0 -> 0 > 1
20:22:25 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
20:22:41 <SamB_XP> it's kinda funny you don't get, uh, _|_ from that ...
20:22:44 <applicative> @tzcheckk \0 -> 0>1
20:22:45 <lambdabot> Unknown command, try @list
20:23:02 <ddarius> monochrom: A crucial axiom of an ordered field.
20:23:20 <ddarius> Er..
20:23:24 <SamB_XP> lol
20:23:25 <ddarius> Almost...
20:23:26 <monochrom> hahaha
20:23:39 <SamB_XP> gotcha!
20:23:45 <ddarius> Well, certainly it would simplify ordered field theory.
20:24:07 <idnar> haha
20:24:15 <pokoko222> i dont wanna get monochrom mad, i am out of here ;)
20:24:19 <applicative> even some questions hitherto judged undecidable
20:24:35 <applicative> would be in our reach with 0>1
20:24:42 <SamB_XP> applicative: we could decide them BOTH WAYS, even!
20:24:53 <applicative> a wealth of results
20:24:55 <wolgo> Runar: sorry, a balanced tree.
20:25:06 <wolgo> I think I have the implementation figured out.
20:25:16 <Runar> wolgo: Like a red/black tree?
20:25:19 <wolgo> I am building a maze generator and a walking agent.
20:25:21 <Cale> ddarius: Perhaps you could publish some of the results in the Journal of the Empty Set
20:25:24 <wolgo> Runar: btree
20:25:55 <Pseudonym> Oh, cool.  I think I just came up with a geometric construction which proves pokoko222's inequality.
20:26:07 <Runar> wolgo: So just a binary tree
20:26:24 <wolgo> binary tree is unsorted and unbalanced right?
20:26:25 <Pseudonym> Neat.
20:26:27 <wolgo> no
20:26:29 <Cale> http://pic.blog.plover.com/math/major-screwups-4/emptyset.png
20:26:34 <wolgo> I want a sorted, balanced tree
20:26:35 <applicative> > let 0 = 1 in 1 + 1
20:26:36 <lambdabot>   2
20:26:51 <applicative> > let 0 = 1 in 0 + 0
20:26:52 <lambdabot>   0
20:27:27 <wolgo> Runar: oh!
20:27:30 <Sgeo> > GHC.Exts.maxTupleSize
20:27:31 <lambdabot>   Not in scope: `GHC.Exts.maxTupleSize'
20:27:33 <applicative> lambdabot is very conservative, even when you give her 0 = 1
20:27:37 <wolgo> self-balancing binary search tree
20:27:41 <pickles> > let a = 0 in a / a
20:27:41 <wolgo> that is what I want
20:27:42 <lambdabot>   NaN
20:27:51 <Runar> wolgo: http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps
20:27:53 <wolgo> also sorted though
20:27:56 <SamB_XP> > let !0 = 1 in "hi!"
20:27:57 <danblick> Lately I've been trying to figure out how to write an event-driven HTTP server.  When you receive some bytes from a socket, those bytes doesn't necessarily make up complete request, so you need to store partial requests while parsing the data you've got to see if you have a complete request yet.  I'm wondering if this is an appropriate place to use continuations; anyone know of any papers I should check out?
20:27:57 <lambdabot>   "* Exception: <interactive>:1:145-150: Non-exhaustive patterns in pattern b...
20:28:13 <Pseudonym> > case 1 of { 0 -> 1 + 1 }
20:28:14 <lambdabot>   * Exception: <interactive>:1:149-172: Non-exhaustive patterns in case
20:28:28 <Pseudonym> If Haskell doesn't have to do a conformality check, it won't.
20:28:33 <Pseudonym> > case 1 of { ~0 -> 1 + 1 }
20:28:34 <lambdabot>   2
20:29:04 <wolgo> rebalancing is not a problem
20:29:05 <Sgeo> Anyone want to try a tuple of size 63 in lambdabot?
20:29:10 <pickles> danblick: there's a copy of onlisp online that describes continuations
20:29:14 * ManateeLazyCat pasted "runTVarStateT" at http://paste2.org/get/762729
20:29:14 <ManateeLazyCat> Above `runTVarStateT` function integrate runStateT with TVar, enjoy!
20:29:18 <Pseudonym> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:29:19 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
20:29:20 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -
20:29:20 <lambdabot> > t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 ->
20:29:20 <lambdabot> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v,
20:29:20 <lambdabot>  w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64,
20:29:21 <lambdabot> t65, t66, t67, t68, t69, t70, t71, t72, t73, t74, t75, t76)
20:29:33 <SamB_XP> > (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:29:34 <lambdabot>   Context reduction stack overflow; size = 20
20:29:35 <lambdabot>  Use -fcontext-stack=N to incre...
20:29:44 <Sgeo> ??
20:29:45 <SamB_XP> whooooah
20:29:51 <pickles> danblick: i donno if it gives many example scenarios though, i havent finished that chapter yet
20:29:56 <applicative> > (,,,) 1 1 1 1
20:29:56 <SamB_XP> gwern: please boost the stack size to 128!
20:29:57 <lambdabot>   (1,1,1,1)
20:30:03 <SamB_XP> > (,,,)
20:30:04 <lambdabot>   {()->{()->{()->{()->((),(),(),())}}}}
20:30:11 <applicative> > (,,,,,,) 1 1 1 1 1 1 1
20:30:12 <lambdabot>   (1,1,1,1,1,1,1)
20:30:13 <wolgo> Runar: thank you for this.
20:30:27 <Pseudonym> > (,,,,,,) 1 1 1 1 1 1
20:30:28 <lambdabot>   {()->(1,1,1,1,1,1,())}
20:30:33 <applicative> > (,,,,,,),,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1
20:30:34 <lambdabot>   <no location info>: parse error on input `,'
20:30:39 <applicative> > (,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1
20:30:39 <Pseudonym> OK, when did this behaviour change?
20:30:40 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
20:30:40 <lambdabot>         against inferred type ...
20:30:41 <ManateeLazyCat> Maybe we should build new channel named: "#lambdabot", then haskeller will experiment code in #lambdabot, and talk in #haskell.
20:30:46 <danblick> quit spamming
20:30:50 <Runar> wolgo: That paper presents an immutable (persistent) self-balancing binary search tree with an extremely simple implementation.
20:30:54 <Pseudonym> @msg lambdabot @join #lambdabot
20:31:01 <Pseudonym> ManateeLazyCat: Done.
20:31:11 <monochrom> use /msg lambdabot > let x=x+1 in x
20:31:16 <wolgo> I dislike that languages are more complex than this.
20:31:20 <SamB_XP> did you just tell lambdabot to tell herself to join #lambdabot?
20:31:28 <SamB_XP> that's kinda silly
20:31:32 <SamB_XP> did she do it ?
20:31:36 <Pseudonym> I tried to, then I really did it.
20:31:36 <wolgo> like ruby or python implementation requires all kinds of bs dancing to get this done.
20:31:40 <applicative> I talk to her all the time, private messages.  She's the only one who understands me.
20:31:52 <gwern> @vixen but you understand me better than applicative, right?
20:31:54 <lambdabot> correct
20:31:57 <lambdabot> I just pretend to understand applicative.
20:31:58 <SamB_XP> applicative: but it would be funny if she listened to orders from herself!
20:32:00 <monochrom> lambdabot understands everyone
20:32:02 <danblick> haha
20:32:11 <wolgo> everything in haskell is so small but effective. I will learn it someday hahheh
20:32:14 <SamB_XP> > (1+$#!+1)
20:32:15 <lambdabot>   Not in scope: `+$#!+'
20:32:18 <lambdabot> I prefer "idiom" anyway.
20:32:25 <SamB_XP> monochrom: she doesn't seem to get me!
20:32:26 <applicative> fortunately we do not need to compete for her hand
20:32:28 <Sgeo> lambdabot seems to be nonfunctional in #lambdabot
20:32:35 <dons> wolgo: don't wait. learn it now. life is to short for bad code
20:32:40 <SamB_XP> Sgeo: what, she's imperative there ?
20:32:55 <pickles> "Life is too short for bad code."
20:32:56 <Pseudonym> Hmm.  Why won't lambdabot respond in #lambdabot?
20:32:57 <pickles> sage advice
20:33:03 <applicative> @quote dons wolgo: don't wait. learn it now. life is to short for bad code
20:33:03 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
20:33:11 <applicative> i forget the syntax
20:33:14 <SamB_XP> Pseudonym: maybe the cannel name confuses her?
20:33:14 <gwern> Pseudonym: perhaps you've found an interesting bug
20:33:19 <aavogt> rembember
20:33:33 <Pseudonym> lambdabots all the way down.
20:33:38 <applicative> @remember dons wolgo: don't wait. learn it now. life is to short for bad code
20:33:38 <lambdabot> It is stored.
20:33:48 <SamB_XP> Pseudonym: to experiment, name one haskell and join it here ;-P
20:34:26 <monochrom> what is "name one haskell and join it here"?
20:34:34 <danblick> pickles: thanks for the suggestion, i will check that out
20:34:53 <applicative> wolgo, you certainly won't have trouble representing trees.  You'll have too many options.
20:34:55 <monochrom> is it like "download haskell and paste it here"?
20:35:02 <Sgeo> Why is the in GHC.Exts, exactly?
20:35:18 <SamB_XP> monochrom: one == a lambdabot instance
20:35:27 <SamB_XP> that is, build
20:35:38 <monochrom> Oh I see now.
20:35:47 <ManateeLazyCat> Damn Emacs, crash again.
20:36:02 <monochrom> emacs never crashed on me.
20:36:03 <SamB_XP> I don't have the space required nor do I feel like waiting for her build on a PII 450 ;-)
20:36:12 <SamB_XP> monochrom: lucky you
20:36:20 <SamB_XP> I think I've probably crashed it at least once
20:36:26 <SamB_XP> or at least gotten it OOM killed
20:36:26 <applicative> ManateeLazyCat, sorry, I gave you reason to think there were more examples of OverloadedStrings in Data.Text than there were
20:36:27 * ddarius has built GHC on a Pentium 2 200
20:36:28 <Sgeo> I don't quite grok GHC.Exts.lazy
20:36:59 <Runar> wolgo: You're right, ruby doesn't make these things easy. There's a certain amount of hacking you have to do beforehand to get productive in it.
20:37:22 <monochrom> GHC.Exts.lazy is a trick to prevent optimiser from making something eager.
20:37:30 <ManateeLazyCat> We should keep #lambdabot always, then write topic in #haskell that notify every haskeller want to test code, goto #lambdabot. Keep #haskell clean.
20:37:36 <applicative> wolgo, face it, ruby doesn't compose.  it's not thinking, it coding.
20:37:56 <SamB_XP> ManateeLazyCat: well, maybe we should save it until lambdabot actually pays attention in there ;-P
20:37:58 <ManateeLazyCat> applicative: Thanks, OverloadedStrings is excellent
20:38:04 * twink just /msg's lambdabot
20:38:12 <Runar> Haskell: data Color = Red | Black
20:38:20 <SamB_XP> twink: but that gets so lonely!
20:38:25 <Pseudonym> @part #lambdabot
20:38:27 <applicative> I had forgotten how it worked, but studied it again, it's wonderful
20:38:31 <Pseudonym> No point staying there.
20:38:38 <ManateeLazyCat> SamB_XP: lambdabot is biggest spawn generator. :)
20:38:50 <SamB_XP> she has sex now ?
20:38:51 * twink does it until the exemplary code to have demo'd is worked out in full
20:38:52 <SamB_XP> where!?!?!
20:38:52 <Gracenotes> lambdabot, replicate!
20:38:58 <wolgo> lol
20:39:03 * ManateeLazyCat It's too bad i just can use IRC in terminal, emacs always crash. :-(
20:39:05 <wolgo> > replicate 3
20:39:06 <lambdabot>   {()->[(),(),()]}
20:39:08 <Runar> Ruby: Red = lambda {|x| lambda {|y| x }}; Black = lambda {|x| lambda {|y| y}}
20:39:14 <lambdabot> Unix processes reproduce asexually. I thought everyone knew that.
20:39:20 <applicative> lamdabot does not replicate.  she is very pure
20:39:29 <Sgeo> ChanServ's ignoring me
20:39:35 <applicative> > putStr "Hahahah loser!"
20:39:36 <lambdabot>   <IO ()>
20:39:39 <Sgeo> Oh, finnally
20:39:50 <SamB_XP> I didn't know chansever HAD an /ignore list
20:39:50 <wolgo> I have a question about a haskell program I wrote a while ago.
20:39:56 <Gracenotes> applicative: sure she replicates... but is it a reference to the same lambdabot, or is it an exact copy?
20:39:58 <wolgo> I will paste it.
20:40:05 <Gracenotes> we shall never know!
20:40:05 <SamB_XP> wolgo: to a bin, yes?
20:40:08 <Pseudonym> wolgo: The answer is "yes, writing it in Haskell was a good idea".
20:40:10 <applicative> she has instances
20:40:21 <Pseudonym> wolgo: We have hpaste for this, but I don't know if it's up.
20:40:30 <SamB_XP> Gracenotes: it's not an exact copy
20:40:35 <Pseudonym> Guess not.
20:40:40 <SamB_XP> you have to edit the config file and rebuild, don't you?
20:40:54 <pickles> > print ""
20:40:55 <lambdabot>   <IO ()>
20:40:57 <Saizan> to change the nick? no
20:40:58 <Sgeo> I don't think I'm considered to own the name lamdbabot
20:41:04 <Sgeo> *lambdabot
20:41:13 <SamB_XP> what? that's not in the .hs file nomore?
20:41:15 <SamB_XP> nice!
20:41:15 <applicative> see pickles she won't touch IO
20:41:17 <lambdabot> I own my own name.
20:41:19 <monochrom> lambdaborg
20:41:21 <pickles> > let say = print in say "good night, gracy"
20:41:21 <lambdabot>   <IO ()>
20:41:26 <pickles> damn
20:41:30 <Saizan> SamB_XP: there's an .rc
20:41:37 <lambdabot> But lambdabot is you and lambdabot is me. Expect us.
20:41:45 <applicative> she's playing hard to get, and purity will win
20:41:54 <SamB_XP> see, I guess I haven't really messed around w/ her since she got that .rc file
20:42:10 <lambdabot> I am you and you are me and we are all together.
20:42:20 <SamB_XP> and are we evil ?
20:42:41 <monochrom> I am all and only those who are not themselves.
20:42:44 <lambdabot> Incidentally, try that line on Eliza some time.
20:42:53 <Saizan> the nice/weird thing is how complicated the routing of the commands in the .rc to the plugin that interprets them actually is
20:42:59 <wolgo> http://pastebin.ca/1858500
20:43:03 <SamB_XP> monochrom: can't be
20:43:04 <wolgo> that is the old program
20:43:06 <applicative> why doesn't someone show up with a trivial type error for me to explain, it's my one talent.
20:43:16 <Pseudonym> > 1 + 'a'
20:43:16 <SamB_XP> that's not an expression in the current set theories
20:43:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
20:43:17 <lambdabot>    arising from the literal `1...
20:43:24 <Pseudonym> applicative: Go ahead.
20:43:39 <wolgo> it was a python challenge
20:43:41 <SamB_XP> applicative: yah, that works in C!
20:43:46 <aavogt> > let str = [1,2,3] in sum str / length str
20:43:47 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
20:43:47 <lambdabot>    arising from a use o...
20:43:48 <kmc> wolgo, are you avoiding "do" notation for a specific reason?
20:43:48 <wolgo> for opening a file and reading characters out of it
20:44:06 <kmc> it's good to know these (>>=) and related operators, but the "do" notation is often easier
20:44:13 <applicative> > 'a' + 'a'
20:44:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
20:44:15 <lambdabot>    arising from a use of `GHC....
20:44:21 <wolgo> is do for output and input?
20:44:23 <applicative> I don't need the 1
20:44:33 <pickles> wolgo: do is for monads
20:44:37 <wolgo> let me try to remember the do syntax
20:44:41 <wolgo> brb
20:44:45 <kmc> wolgo, "do" is syntactic sugar for (>>=)
20:44:46 <SamB_XP> applicative: you were supposed to explain it, not make it worse!
20:44:47 <aavogt> monad laws can still apply to simplify that code
20:44:53 <SamB_XP> or just as bad with fewer tokens
20:44:55 <SamB_XP> or anything
20:44:59 <kmc> wolgo, so that includes IO but a lot more
20:45:23 <kmc> wolgo, "do" and (>>=) both work for any "monad".  if you ask what a monad is, i'll just say "it's a type for which (>>=) works"
20:45:25 <applicative> the answer is: you only get to use + when the terms joined belong to the same type, and it's an instance of Num
20:45:33 <monochrom> > 'a' && Just False  {- type error for applicative -}
20:45:33 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:45:34 <lambdabot>         against inferred type ...
20:45:35 <kmc> that is, "Monad" is the name of an API, and (>>=) is the most important method in that API
20:45:35 <pickles> i'm off to bed, night all
20:45:55 <monochrom> or perhaps...
20:46:03 <monochrom> > "confused" && Just "wrong"
20:46:04 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:46:04 <lambdabot>         against inferred type ...
20:46:05 <applicative> monochrom, 'that's not nonsense, that's just false', as a friend of mine often says
20:46:24 <SamB_XP> applicative: or is it False?
20:46:26 <applicative> "confused" is not a Bool
20:46:28 <Saizan> wolgo: anyhow, what you pasted is just a bunch of definitions
20:46:35 <kmc> instance IsString Bool where ...
20:46:51 <Saizan> wolgo: you should plug them together in a main to make them do something
20:46:54 <kmc> fromString = not . null
20:46:54 <SamB_XP> (which we would probably call Void hereabouts?)
20:47:10 <applicative> did you see the device to Tweet your ghc type errors from emacs
20:47:20 <applicative> the first one was 'instance Monad Char'
20:47:22 <monochrom> no. does it exist?
20:47:44 <applicative> it about killed me.
20:47:48 <Sgeo> If unsafeInterleaveST is similar to unsafeInterleaveIO, how is unsafeInterleaveST unsafe?
20:47:51 <monochrom> first error of whom? who was the moron?
20:48:18 <Saizan> chrisdone!
20:48:49 <Saizan> Sgeo: in the same sense, that effects now depend on how much/when you force the result
20:49:05 <Sgeo> But what effects?
20:49:19 <Saizan> reading/writing the STRefs
20:49:23 <Saizan> and the STArrays
20:49:26 <Sgeo> To the outside world, runST someSTjunk is purely functional
20:49:26 <applicative> http://www.emacswiki.org/emacs/EmacsTweetHaskellTypeErrors
20:49:36 <Sgeo> And STRefs and STArrays can't be shared
20:49:38 <Sgeo> So..
20:49:49 <wolgo> ahh I see
20:49:51 <wolgo> one second
20:49:55 <Saizan> Sgeo: inside the same ST computation.
20:49:56 <kmc> Sgeo, but runST can observe the relative order between two ST actions
20:49:57 <wolgo> that was not the original file
20:50:07 <wolgo> I became disillusioned
20:50:49 <Sgeo> But runST $ unsafeInterleaveST $ do --whatever should be safe?
20:50:56 * SamB_XP quickly pulls the wool back over wolgo's eyes
20:50:58 <applicative> haha, he's still using it  http://twitter.com/christopherdone
20:51:09 <kmc> Sgeo, seems likely
20:51:11 <SamB_XP> Sgeo: no -- the computation can then see what order the results are forced in!
20:51:21 <SamB_XP> er, well, actually, yeah
20:51:25 <SamB_XP> THAT would be
20:51:27 <kmc> it still has different semantics
20:51:49 <AxleLonghorn> is there any way to define a function with the same name as a function in a module, while still having access to the module function, without getting the annoying ghc error about usage of the new function being ambiguous? I want to redefine "lookup = flip Prelude.lookup"
20:51:50 <kmc> well, that also depends if you're using lazy or strict ST.  maybe?
20:52:12 <kmc> AxleLonghorn, "import Prelude hiding(lookup); import qualified Prelude"
20:52:21 <kmc> once you have an explicit import for Prelude, the implicit ones are disabled
20:52:32 <applicative> hide lookup
20:52:47 <AxleLonghorn> cool, thanks
20:52:47 <Saizan> ?type unsafeInterleaveST
20:52:48 <lambdabot> Not in scope: `unsafeInterleaveST'
20:52:53 <Saizan> bah.
20:54:03 <AxleLonghorn> kmc, ghc now says it can't find the typeclass EQ
20:54:09 <kmc> EQ?
20:54:11 <kmc> it's named Eq
20:54:17 <kmc> and did you only hide lookup?
20:54:18 <AxleLonghorn> ah, lol, whoops
20:54:50 <applicative> Prelude defines the Eq class
20:54:53 <Saizan> > EQ
20:54:54 <lambdabot>   EQ
20:55:05 <applicative> > GT
20:55:06 <AxleLonghorn> I know, just a stupid mistake
20:55:06 <lambdabot>   GT
20:55:27 <applicative> @type GT
20:55:28 <lambdabot> Ordering
20:57:45 <Sgeo> > LT < EQ
20:57:46 <lambdabot>   True
20:57:57 <Sgeo> > LT `compare` EQ
20:57:58 <lambdabot>   LT
21:03:06 <Axman6> @src Eq compare
21:03:06 <lambdabot> Source not found. Do you think like you type?
21:03:09 <Axman6> :(
21:03:56 <blackdog> buck up, alex, you'll get it next time.
21:05:10 <kmc> @src () compare
21:05:10 <lambdabot> compare () () = EQ
21:05:23 <kmc> @src () (<=)
21:05:23 <lambdabot> () <= () = True
21:08:03 <aavogt> > () <= ()
21:08:04 <lambdabot>   True
21:08:31 <aavogt> > () > ()
21:08:31 <lambdabot>   False
21:09:58 <Axman6> @src (>)
21:09:58 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
21:11:35 <Axman6> @src () (>)
21:11:35 <lambdabot> () >  () = False
21:13:02 <ronwalf> So how likely is it that 'deriving Data' code should compile in ghc 6.10 but not ghc 6.12?
21:14:37 <Axman6> ronwalf: is it happening to you?
21:15:02 <ronwalf> axman6: Yes, although it's across modules
21:15:31 <ronwalf> I should probably just make a contained test case and post it
21:15:56 <ronwalf> Huh, so much for hpaste!
21:16:54 <ronwalf> It's a "No instances for (Data (...) arising from the 'deriving' clause of a data type declaration"
21:17:50 <ronwalf> Despite each of the missing datatypes having explicit deriving clauses
21:19:11 <Sgeo> :t I#
21:19:11 <lambdabot> Not in scope: data constructor `I#'
21:19:26 <kmc> @src Int
21:19:26 <lambdabot> data Int = I# Int#
21:19:51 <Axman6> :k I#
21:19:52 <lambdabot> Not in scope: type constructor or class `I#'
21:19:54 <Sgeo> :kind Int#
21:20:01 <Sgeo> :k Int#
21:20:02 <lambdabot> Not in scope: type constructor or class `Int#'
21:20:04 <kmc> that's GHC-specific btw
21:20:09 <kmc> Int# :: #
21:20:12 <Sgeo> What IS it, exactly?
21:20:19 <Veinor> 'there are other GHC compilers?'
21:20:24 <Veinor> er, haskell compilers
21:20:25 <Veinor> :P
21:20:26 <kmc> Int# is the type of "unboxed" machine-size integers
21:20:35 <kmc> Veinor, quite a few, though GHC far surpasses them all in popularity
21:20:43 <Veinor> oh wait
21:20:51 <Veinor> most places don't have the quotes = sarcasm convention
21:20:57 <Veinor> :P
21:20:59 <kmc> i figured it might be ;P
21:21:05 <kmc> anyway
21:21:10 <kmc> Int# is the type of unboxed ints
21:21:16 <kmc> I# is the data constructor for the normal Int type
21:22:01 <Veinor> :t I#
21:22:02 <lambdabot> Not in scope: data constructor `I#'
21:22:10 <Veinor> oh wait, that's a type constructor
21:22:11 <Veinor> whoops!
21:22:21 <Veinor> wait, hm, I'm tired
21:22:47 <kmc> I# :: Int# -> Int
21:23:39 <Sgeo> I don't quite understand "unboxed", nor why it exists
21:24:03 <kmc> Sgeo, http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
21:25:05 <kmc> Sgeo, a regular "Int" is represented in memory much the same way as any other value: by a pointer to a "closure" object in the heap.  a closure has a certain specific layout, and might represent either a value or a delay-evaluation "thunk"
21:25:27 <kmc> an Int# is represented in memory by a regular old machine-size integer
21:25:34 <Sgeo> Hm, so undefined :: Int# doesn't work
21:25:38 <kmc> right
21:25:39 <Sgeo> (reading)
21:25:51 <kmc> unboxed values are always strict
21:25:58 <kmc> because they aren't heap pointers; you'd have nowhere to put the thunk
21:27:04 <kmc> also you can't put them into polymorphic functions or datatypes, because polymorphism depends on this uniform representation of heap objects
21:28:25 <dons> Sgeo: kind error
21:28:30 <dons> no?
21:28:44 <dons> :t undefined :: GHC.Int.Int#
21:28:45 <lambdabot>     Not in scope: type constructor or class `GHC.Int.Int#'
21:28:49 <kmc> a type variable can be instantiated to a type of kind * but not of kind #
21:28:56 <dons> yeah
21:28:58 <kmc> i'm not sure how true that is
21:29:03 <kmc> but it seems to hold mostly
21:29:20 <dons> well, you can define undefined# = undefined# :)
21:29:57 <dons>     Recursive bang-pattern bindings aren't allowed: { !u = u }
21:29:58 <dons> whoa
21:30:09 <dons> sigh
21:30:14 <kmc> "Top-level bindings for unlifted types aren't allowed"
21:31:16 * Sgeo should be eating/studying
21:31:16 <dons>     Recursive bindings for unlifted types aren't allowed:
21:31:17 <dons>         { (u :: GHC.Prim.Int#) = u }
21:31:33 <kmc> it makes sense
21:31:44 <dons> so your challenge is: write a user-defined bottom value of unlifted kind.
21:31:51 <dons> and not of function kind
21:32:05 <dons> we can't use recursion though.
21:32:22 <kmc> you can't really create the value, because it'd be strict, no?
21:32:42 <dons> well, when demanded it wouldn't terminate
21:33:19 <dons> let (u :: GHC.Prim.Int#) = case 1# of 2# -> 1#
21:33:21 <dons> probably works
21:33:35 <dons> i.e. make it pattern failure
21:34:37 <dons> {-# LANGUAGE BangPatterns #-}
21:34:37 <dons> {-# LANGUAGE MagicHash    #-}
21:34:38 <dons> import GHC.Prim
21:34:38 <dons> main = do let !u = case 1# of 2# -> 1# print "done"
21:34:40 <wolgo> okay
21:34:55 <wolgo> I think the problem I have is understanding typrs
21:34:57 <wolgo> types
21:34:58 <wolgo> that is it
21:35:13 <wolgo> I am going to read about types.
21:35:44 <dons> kmc: but yes, you can't use such a value
21:36:55 <duaneb> dammit
21:37:02 <duaneb> I just tried to use "f += 1" in haskell
21:37:16 <kmc> > let (+=) = (+) in 2 += 3
21:37:17 <lambdabot>   5
21:37:19 <dons> f = succ f
21:37:22 <dons> hehe
21:37:41 <Sgeo> let f' = f+1?
21:37:52 <dons> > let f = succ f in f -- is more fun
21:37:53 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
21:38:02 <dons> > let f = succ f :: Int in f -- is more fun
21:38:06 <lambdabot>   mueval-core: Time limit exceeded
21:38:07 <kmc> :t let r += b = modifyIORef r (+b) in (+=)
21:38:08 <lambdabot> Not in scope: `modifyIORef'
21:38:48 <dons> let r += b = do x <- unsafeCoerce# r ; poke (unsafeCoerce# r) (x + 1) ...
21:39:18 <blackdog> jeez, don, if you're going to coerce and poke you could at least be safe about it.
21:39:48 * blackdog is hell of classy
21:47:52 <Sgeo> poke?
21:53:22 <kmc> poke?
21:53:31 <kmc> ekop
21:56:09 <kmc> :t map . first
21:56:10 <lambdabot> forall b c d. (b -> c) -> [(b, d)] -> [(c, d)]
22:04:39 <aavogt> @hoogle poke
22:04:39 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
22:04:39 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
22:04:39 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
22:06:43 <wavewave> can stream fusion fuse average  xs = sum xs / length xs ?
22:07:04 <wavewave> sum xs = foldr (+) 0 xs
22:07:17 <wavewave> length = foldr inc 0 xs
22:07:23 <wavewave> where inc x n = n+1
22:08:12 <wavewave> if xs is very large, this has a space leak.
22:08:30 <wavewave> but it can be easily cured using
22:08:45 <wavewave> a single traversal
22:08:54 <wavewave> foldr f (0,0) xs
22:09:23 <wavewave> where f x (p,q) = (x+p, q+1)
22:10:11 <wavewave> is there any automatic library which observe this optimization?
22:12:57 <leoncamel> I reinstall a package, for example mtl, by "cabal install mtl". Then, I do "ghc-pkg check". I got a lot of broken packages. Why? and how to fix them ? GHC-6.12.1.20100330 here.
22:16:39 <leoncamel> oops, s/"cabal install mtl"/"cabal install mtl --reinstall"
22:18:07 <Sgeo> @src (++)
22:18:08 <lambdabot> []     ++ ys = ys
22:18:08 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
22:18:08 <lambdabot> -- OR
22:18:08 <lambdabot> xs ++ ys = foldr (:) ys xs
22:18:57 <Sgeo> So, if I'm appending to the end of a list, and reading from the beginning, that's not inefficient, is it?
22:19:01 <Sgeo> O(1) all around?
22:19:28 <leoncamel> Sgeo: O(n) i think.
22:19:44 <Sgeo> :(
22:19:50 <wavewave> Sgeo: use Data.Seq or
22:20:00 <Sgeo> Laziness doesn't help somehow?
22:20:01 <wavewave> purely functional queue.
22:20:13 * Sgeo wants to write his own queue
22:20:55 <wavewave> Sgeo: read Okasaki's thesis.
22:21:36 <Sgeo> Doesn't that occasionally do a more than O(1) operation to switch things between lists though?
22:21:42 <wavewave> basically queue = frontlist, backlist
22:22:40 <wavewave> you mean from backlist -> frontlist ?
22:23:05 <Sgeo> Um, not sure which way, I last [and first] glanced at it hours ago
22:24:00 <wavewave> it is said to be amortized. I understand O(1) is still guaranteed after amortization.
22:25:02 <SamB_XP> that means that sometimes it will take longer, but only if it's already gone shorter a bunch of times
22:25:32 <kmc> amortized complexity is still worst-case complexity
22:25:56 <Sgeo> There's no way to be more efficient using ST or something
22:25:57 <Sgeo> ?
22:26:09 <SamB_XP> the worst-case complexity for any given operation is potentially much worse than the amortized complexity
22:26:43 <SamB_XP> but for a complete sequence of operations, it is the same
22:27:14 <idnar> I don't see how a queue could be O(1)
22:27:33 <idnar> mutable or otherwise
22:27:46 <kmc> Sgeo, you don't need mutability to make a queue faster than O(n)
22:27:46 <jbapple> amortized efficiency in the sense of Okasaki is different than usual. The functions used to add it all up operate sort of bakwards from the usual way. This often means that Okasaki's "amortized" is better than Tarjan's original "amortized"
22:27:52 <kmc> ah, strange
22:27:53 <jbapple> At leas, as I understand it.
22:28:00 <idnar> O(1) amortized is a different matter
22:28:22 <jbapple> idnar: which operations are you skeptical of?
22:28:52 <jbapple> Okasaki (and before him, Tarjan et al) showed queues with O(1) worst case enqueue and dequeue
22:29:01 <tensorpudding> I don't know if I could have invented zippers.
22:29:29 <SamB_XP> tensorpudding: just pretend you could've, it's good for your self esteem ;-)
22:29:37 * Sgeo is vaguely curious why Chrome decided it was an Explorer window
22:29:39 <idnar> jbapple: hmm, guess I'm not smart enough :P
22:30:19 <jbapple> idnar: You don't have to be smart enough to invent them yourself. Many of their papers are available for free online so you can stand on their giant shoulders
22:30:29 <jbapple> :-)
22:30:46 <idnar> jbapple: does the implementation assume an O(1) memory allocator?
22:31:15 <tensorpudding> Some academics have really small shoulders.
22:31:23 <tensorpudding> I don't think they'd want you to stand on them long.
22:31:26 <jbapple> idnar: I do not know what "an O(1) memory allocator" is. Do you mean that finding 1 free location in memory takes a constant amount of time?
22:31:29 <jbapple> If so, then yes
22:31:35 <jbapple> They do assume that
22:32:27 <SamB_XP> but isn't yours?
22:32:31 <jbapple> Otherwise, I do not think there is any worst-case O(1) queue, functional or not, unless allocation can be broken up into O(1) parts
22:34:30 <idnar> anyway, I don't want to implement it myself, I just want nice libraries on hackage that implement it for me ;)
22:37:05 <kamatsu> sigh, i knew it was a matter of time after criticizing ocaml on reddit that I'd get a jdh troll reply
22:40:26 <kmc> jdh trolls reddit?
22:40:43 <kamatsu> seems so
22:40:45 <idnar> you sound surprised
22:41:06 <kamatsu> he seems to be implying that make is superior to cabal
22:41:09 <applicative> kamatsu, what  could cause you to attack our sister language, however ugly she may be.
22:41:31 <kamatsu> applicative: I was criticizing the lack of visible community, or support infrastructure such as tools etc.
22:42:10 <applicative> jdh said, they are too busy writing important programs for major firms
22:43:05 <applicative> then pointed to wonderful tools like Il Duce
22:43:10 <tensorpudding> Ocaml has a charm.
22:44:07 <applicative> kamatsu, where is this no doubt priceless invective of flying frog
22:46:12 <Axman6> why can't jdh be a nice commercial user of a language, like dons, insgtead of constantly being a dick?
22:46:19 <Axman6> instead*
22:47:11 <idnar> heh
22:47:44 <applicative> its okay, we need to convert him to haskell, then he will be happy.
22:47:46 <idnar> most of the commercial users I know of $ANYTHING are way too busy actually getting work done to be dicks on the internet
22:48:24 <applicative> who knows maybe even dons was mean before he discovered haskell
22:48:33 <applicative> perish the thought
22:48:57 <m3ga> C++ makes me mean and moody
22:50:04 <applicative> "jdh30 -1 point 6 jours de a[-] F# really is groundbreaking."
22:50:11 <Sgeo> Why is Data.Seq.Seq's length using Int?
22:50:29 <Axman6> probably because []'s lenght does
22:50:46 <Axman6> length*
22:52:02 <Associat0r> applicative: well it kinda is
22:52:15 <tensorpudding> It's a good question, why does ocaml have a less visible community.
22:52:23 <Sgeo> Is O(log(0)) as undefined as log(0) is?
22:53:08 <Sgeo> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.3.0.0/Data-Sequence.html#11
22:53:26 <jbapple> Sgeo: an operation that s O(log(0)) takes a negative amount of time
22:53:49 <jbapple> It travels backwards in time more than i seconds for any positive value of i
22:54:07 <idnar> haha
22:54:12 <jbapple> It is best not to use operations that take negative time dues to space-time continuum problems
22:54:25 <Sgeo> Someone should exploit that property of Data.Seq.length to make communications back in time doable
22:54:33 <Sgeo> erm, Data.Seq.index
22:54:38 <jbapple> (In most papers, O(lg n) means O(max(1,lg n))
22:55:07 <jbapple> On a serious note, I think some amortized operations are legitimately O(0).
22:55:27 <tensorpudding> How can you have an operation that occurs instantly?
22:55:31 <jbapple> That is, they improve the potential (or insert more credits) than it takes to actually perform the operation
22:56:08 <jbapple> I have only seen that in imperative analysis, never using Okasaki's amortization calculation style
22:58:35 <Associat0r> "tensorpudding: It's a good question, why does ocaml have a less visible community." maybe too busy working on realworld stuff
23:01:05 <kamatsu> jdh says that make is better than cabal.
23:01:27 <applicative> Associat0r, I didnt mean to object to "F# really is groundbreaking.", it sounds great; just the mechanical character of the remark
23:02:25 <Yunga> hello
23:02:34 <kamatsu> I dispute that F# really is groundbreaking
23:02:36 <applicative> Yunga, hellp
23:02:41 <applicative> helo
23:02:47 <kamatsu> in terms of language design, it doesn't have anything new.
23:02:52 <kamatsu> it just runs on the CLR.
23:02:53 <applicative> excuse keyboard
23:03:28 <Associat0r> kamatsu: and it's performant
23:04:04 <Associat0r> kamatsu: in terms of language design not really, but it doesn't have to be
23:04:23 <jbapple> kamatsu: I said on reddit, and I repeat: it include Andrew Kennedy's unit types. That's new
23:04:38 <Associat0r> kamatsu: Scala is groundbreaking and Agda
23:04:47 <jbapple> I mean, he designed them 15 years ago, but it's still new to real compilers
23:04:55 <Associat0r> jbapple: but unit's of measure has been done before right?
23:05:07 <jbapple> Associat0r: Not in a production compiler
23:05:09 <erikc> not in a production language
23:06:39 <Associat0r> that's true
23:07:22 <erikc> good tooling + reasonably good perf + interoperability + deployability are a pretty powerful selling point
23:08:31 <Associat0r> yep
23:08:34 <kamatsu> jbapple: ah, good point
23:08:38 <Sgeo> > Data.Seq.fromList [1..]
23:08:39 <lambdabot>   Not in scope: `Data.Seq.fromList'
23:08:42 <Associat0r> that's what brought me to F#
23:08:48 <Sgeo> How do I get things like that in scope?
23:08:50 <kamatsu> Associat0r: Scala? Groundbreaking?
23:08:54 <kamatsu> Associat0r: Agda, sure
23:09:07 <Associat0r> kamatsu: Scala yes
23:09:08 <erikc> it'll be far far easier to sell F# into a typical organization vs Ocaml or Haskell
23:09:10 <blackdog> applicative: nah, don was frighteningly nice even at uni.
23:09:13 <kamatsu> Associat0r: explainhow
23:09:22 <jbapple> Sgeo: scope isn't going to help you here, Data.Seq can only represent finite lists
23:09:30 <kamatsu> erikc: that's just because of corporate opinion of .NET
23:09:36 <Axman6> > Seq.fromList [1..10]
23:09:36 <kamatsu> erikc: nothing to do with the language itself.
23:09:37 <lambdabot>   fromList [1,2,3,4,5,6,7,8,9,10]
23:09:47 <Sgeo> > Seq.fromList [1..]
23:09:55 <lambdabot>   mueval: ExitFailure 1
23:10:03 <Associat0r> kamatsu: the way it merges OO with FP is
23:10:07 <Sgeo> Doesn't it usually say timeout or something?
23:10:11 <kamatsu> Associat0r: well.. ocaml?
23:10:35 <applicative> blackdog, i of course expect it must be so.   I change my hypthesis; that's why he took to Haskell so readily
23:10:36 <Associat0r> kamatsu: is not new anymore
23:10:45 <kamatsu> Associat0r: Scala is basically Java with algebraic types and Tailcall optimization.
23:10:54 <jbapple> @source Seq.fromList
23:10:54 <lambdabot> Seq.fromList not available
23:11:04 <kamatsu> Associat0r: I  fail to see how anything it has done is innovative, seeing as OCaml already merged OO with FP.
23:11:11 <tensorpudding> Isn't OCaml about as old as Haskell?
23:11:13 <jbapple> kamatsu: Have you read the Scala papers?
23:11:26 <Associat0r> kamatsu: then you haven't looked closeley enough
23:11:29 <blackdog> kamatsu: urgh, you reckon? I don't think anyone actually uses the objecty bits of ocaml.
23:11:40 <kamatsu> blackdog: that's true
23:11:43 <Associat0r> kamatsu: it's got most of Haskell mixed with OO
23:11:49 <kamatsu> jbapple: nope, but I have written alot of scala
23:11:55 <Associat0r> kamatsu: in many cases goes even beyond Haskell
23:11:56 <kamatsu> Associat0r: yes, and? Not groundbreaking.
23:12:21 <kamatsu> not even Haskell was a groundbreaking language as such (although it was the first lazy language to be popular)
23:12:27 <erikc> kamatsu: i'd argue the implementation is innovative/groundbreaking by adapting FP to work in the typical programming reality of many companies
23:12:42 <kamatsu> erikc: I am talking about language being innovative, not implementation.
23:12:50 <erikc> okie
23:13:31 <kamatsu> I will concede that we have some groundbreaking implementations of not-groundbreaking functional languages
23:13:36 <jbapple> kamatsu: What recent language is groundbreaking, in your eyes?
23:13:46 <kamatsu> hmm
23:13:50 <Associat0r> kamatsu: Scala's extractors were new
23:13:58 <applicative> epilogue
23:14:02 <jbapple> kamatsu: I think you're setting the bar very high
23:14:11 <jbapple> applicative: do you mean Epigram?
23:14:29 <applicative> jbapple, yes, i'm mildly retarded
23:14:38 <Jafet> Haskell led to monad tutorials
23:14:40 <jbapple> applicative: And how is it groundbreaking compared to Agda and Lego and Coq?
23:14:44 <kamatsu> jbapple: I like alot of the stuff in Agda and Epigram, and also the work merging functional and logic languages (Mercury, Curry) is pretty groundbreaking stuff.
23:15:08 <jbapple> applicative: (I'm playing devil's advocate)
23:15:30 <applicative> I was really just thinking of it as more recent.  I cant get any version to compile
23:15:38 <applicative> oh i know, it has idiom brackets!
23:15:43 <jbapple> :-)
23:15:54 <kamatsu> I think intuitionistic type theory and similar things are fairly groundbreaking
23:16:15 <jbapple> kamatsu: They were invented long before Agda & Epigram
23:16:33 <kamatsu> jbapple: right, but Agda and Epigram are just some languages that come to mind which make use of it.
23:16:39 <kamatsu> The concept of lazy evaluation existed before miranda as well
23:16:53 <jbapple> Sigh
23:17:08 <Jafet> Lazy evaluation goes all the way back to delay/force, or even algol's call by name mechanism
23:17:15 <kamatsu> right
23:17:25 <kamatsu> but Miranda was the first language (afaik) to be lazy by default.
23:17:28 <Associat0r> wasn't K&R first
23:17:30 <Associat0r> ?
23:19:04 <kamatsu> K&R C?
23:19:17 <Associat0r> no K&R the language
23:19:30 <applicative> KRC
23:19:48 <kamatsu> oh
23:19:49 <kamatsu> KRC
23:19:52 <applicative> the Kent Recursive Calculator.  maybe it was lazy
23:19:55 <kamatsu> right, slipped my mind.
23:19:57 <kamatsu> yes it was lazy
23:20:03 <applicative> it certainly had a wonderful name
23:20:13 <Associat0r> ah yeah KRC
23:20:38 <applicative> Prof. Turner was clearly a master.
23:21:08 <kamatsu> SASL was also lazy
23:21:15 <Associat0r> yep
23:21:38 <Jafet> There isn't any agreeable definition to "groundbreaking"... I consider do-syntax an innovation of syntactic sugar
23:21:40 <kamatsu> right, so, I would call KRC et al. groundbreaking for introducing laziness by default
23:21:55 <Jafet> Similar to the discovery of saccharine
23:22:45 <applicative> > let ones = !:ones in take 10 ones
23:22:48 <lambdabot>   <no location info>: parse error on input `!:'
23:22:57 <applicative> > let ones = 1:ones in take 10 ones
23:22:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
23:23:16 <kamatsu> btw, how does Miranda and similar deal with IO ?
23:23:47 <Pseudonym> It didn't.
23:23:58 <applicative> I assume it had 'interact'
23:23:59 <Pseudonym> readfile :: string -> string
23:24:04 <Pseudonym> Oh, yeah, maybe.
23:24:19 <kamatsu> oh, but, that would mean you couldn't write nontrivial programs in miranda
23:25:09 <Associat0r> the way Scala is also ground breaking is the symmetry of it's features
23:25:15 <Pseudonym> http://www.cs.kent.ac.uk/people/staff/dat/miranda/manual/31/1.html
23:25:22 <kamatsu> Associat0r: what does that even mean?
23:25:22 <applicative> i assume Miranda IO was like first generation Haskell IO
23:25:33 <Pseudonym> No, first generation Haskell IO was continuation-based.
23:25:40 <Pseudonym> Miranda IO was essentially impure.
23:25:47 <Associat0r> like how you can have abstract fields and asbtract types in addition to abstract methods in classes
23:25:53 <applicative> i see.
23:26:02 <Associat0r> this way you can use them like ML's modules
23:26:17 <avenge> Does anyone know if there's an easy way to unmangle names or debug ghc linking problems?  Am trying to install happstack-data, and getting weird link errors like this (with both ghc-6.10 and 6.12):
23:26:18 <avenge> ghc: dist/build/Happstack/Data/Default.o: unknown symbol `sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacyMZN_closure'
23:26:29 <kamatsu> Associat0r: right, so is ML's modules not the groundbreaking part?
23:26:42 <Pseudonym> Hmm... OK, Miranda did have a system message-like system.
23:26:48 <Associat0r> kamatsu: well ML had a separate construct for it
23:26:50 <Pseudonym> But it didn't have the continuation-based primitives.
23:26:58 <kamatsu> Associat0r: not separate, ML had no objects.
23:27:15 <Associat0r> also scala's case classes double as OCaml's polymophic variants
23:27:34 <kamatsu> Associat0r: Case classes were an attempt to implement algebraic data types.
23:27:42 <kamatsu> I fail to see the innovation there
23:27:45 <roboshibby> re
23:27:48 <Associat0r> then it has implicits  which are like Haskell's typeclasses
23:28:04 <jbapple> http://infoscience.epfl.ch/getfile.py?docid=25028&name=Transactorsx&format=pdf&version=1
23:28:04 <roboshibby> what's the most fundamental collection/group base type? like number, text, binary, and?
23:28:08 <Associat0r> kamatsu: well they are done with normal classes
23:28:21 <Associat0r> kamatsu: and they are open
23:28:30 <kamatsu> Associat0r: I don't dispute that scala is a good language
23:28:32 <applicative> avenge:  very unpleasant error message
23:28:39 <Associat0r> kamatsu: I am not talking about good
23:28:39 <kamatsu> Associat0r: I dispute that any of those features are groundbreaking
23:28:47 <applicative> does ghc-pkg list show syb
23:28:59 <Associat0r> kamatsu: but you said it's Java with ADT's that's not true
23:29:14 <applicative> avenge, or rather syb-with-class i guess
23:29:18 <mxc> so, on planet.haskell.org, the first article now is one that sort of implies that US intervention in WW2 was wrong and a few articles down is one propagating the ridiculous idea that christians are persecuted in western countries because the gov doesn't force christianity on the entire population
23:29:21 <Adamant> everything since the Turing Machine and Lambda Calculus is just elaborations on a theme
23:29:33 <applicative> avenge, are you installing with cabal install?
23:29:34 <kamatsu> mxc: fantastic
23:29:35 <avenge> applicative: Yes, shows both.
23:29:39 <kamatsu> mxc: as it should be :P
23:29:44 <Associat0r> kamatsu: it also has higher kinded types
23:29:50 <mxc> whatever one's views on those subjects are, they dont seem particularly relevant to haskell, FP, or anything like that..
23:29:51 <avenge> Am running 'cabal install happstack-server'
23:29:51 <roboshibby> Adamant: what do you mean?
23:30:00 <kamatsu> Associat0r: Many, many languages had HKT's before Scala
23:30:02 <mxc> </rant>
23:30:15 <avenge> syb-0.1.0.1, syb-with-class-0.6
23:30:30 <Associat0r> kamatsu: but not in the same package
23:30:36 <kamatsu> Associat0r: "same package"?
23:30:37 <Adamant> roboshibby: I'm joking. Mostly I'm trying to be humorous about the fact people have different standards for 'groundbreaking'
23:30:45 <Associat0r> kamatsu: OO FP etc all in one
23:30:46 <roboshibby> ahh
23:30:53 <kamatsu> Associat0r: Once again, not groundbreaking.
23:31:05 <kamatsu> It has a nice combination of features, but none of those features are groundbreaking
23:31:08 <roboshibby> fellas, what's the minimum set of base types a programming language can have?
23:31:15 <Associat0r> kamatsu: it is groundbreaking
23:31:15 <kamatsu> hm
23:31:25 <avenge> roboshibby:  Just strings.
23:31:34 <roboshibby> really?
23:31:42 <kmc> roboshibby, in the untyped lambda calculus you have only functions
23:31:42 <roboshibby> not numbers etc?
23:31:45 <avenge> roboshibby:  This is what shell programming (or presumably tcl) is.
23:31:59 <roboshibby> so strings and then functions?
23:32:00 <kamatsu> avenge: I prefer functions
23:32:02 <kmc> roboshibby, and you can encode numbers, strings, lists, whatever else you want as functions
23:32:03 <jbapple> mxc: The second is what is sometimes called "Jihad envy"
23:32:06 <kamatsu> roboshibby: you only need functions.
23:32:14 <mxc> jbapple ++
23:32:26 <mxc> jbapple++
23:32:27 <avenge> kamatsu:  I prefer both...
23:32:30 <roboshibby> kamatsu: so if you have function type, you can replicate every other type?
23:32:32 <mxc> hm, oh well
23:32:36 <kamatsu> roboshibby: yes
23:32:40 <jbapple> "If you make fun of Christians, why won't you make fun of Muslims, too? Is it because you are too afraid?"
23:32:45 <Adamant> kamatsu: Henry Ford didn't invent the assembly line, but he was the primary reason most people in the US could afford a car. in that sense, what is the groundbreaking part?
23:32:57 <kmc> roboshibby, http://en.wikipedia.org/wiki/Church_encoding
23:32:57 <jbapple> Yes, if only people were still beheaded for blasphemy in Christian countries
23:33:07 <jbapple> Then the world would be a better place
23:33:07 <roboshibby> kamatsu, interesting. how can a function make numbers? strings? etc
23:33:09 <kamatsu> Adamant: I never said henry ford was groundbreaking in his cars
23:33:12 <applicative> avenge, not sure what to make of the linking error.  do you have more than one version of syb-with-class?
23:33:14 <kamatsu> Adamant: maybe in his business methods
23:33:30 <kamatsu> roboshibby: so, let's start with the simplest ideas: booleans
23:33:35 <avenge> applicative:  Nope, just one.  Even stranger is that the linking error doesn't happen at link time, but at compile time.
23:33:38 <Adamant> kamatsu: I'm saying that stuff like Ocaml is groundbreaking in the 'business method' sense
23:33:47 <Sgeo> Is this conversation about lambda calculus?
23:33:50 <kamatsu> roboshibby: TRUE = \xy.x    and FALSE = \xy.y
23:33:58 <Sgeo> yes it is
23:34:05 <kamatsu> Adamant: I never said OCaml wasn't groundbreaking
23:34:16 <kamatsu> Adamant: I said F# wasn't groundbreaking as a language, only its implementation
23:34:24 <Adamant> alright
23:34:30 <Adamant> I can agree with that
23:34:43 <avenge> [ 7 of 16] Compiling Happstack.Data.Proxy ( src/Happstack/Data/Proxy.hs, dist/build/Happstack/Data/Proxy.o )
23:34:44 <avenge> Loading package ghc-prim ... linking ... done.
23:34:44 <avenge> ...
23:34:44 <avenge> Loading package HaXml-1.13.3 ... linking ... done.
23:34:47 <avenge> ghc: dist/build/Happstack/Data/Default.o: unknown symbol `sybzmwithzmclasszm0zi6_DataziGenericsziSYBziWithClassziInstances_constrZMabMhZN_closure'
23:34:51 <avenge> Must be some template-haskell problem?
23:35:13 <kamatsu> roboshibby: Then, you can say something like AND = \ab.bab
23:35:51 <Associat0r> kamatsu: well F# is an ML I can finally use, no boxed float's good performance, good lib, good IDE, good support, good VM, op overloading, user defined value types, etc etc
23:35:51 <applicative> avenge, that's what's bugging me, it means it might not be in the usual range of errors.
23:36:40 <kamatsu> Associat0r: right, all implementation details.
23:36:45 <Associat0r> kamatsu: nicer syntax too
23:36:48 <applicative> avenge, it seems like the guys aren't thinking of anything.  There may be other times of day when you could  hit on a TH syb master
23:36:50 <kamatsu> I agree F# is nice!
23:36:53 <kamatsu> i just say it's not new
23:37:07 <applicative> this is #haskell, WE LIKE F#
23:37:17 <avenge> applicative:  Okay, well thanks anyway.
23:37:23 <Associat0r> ##fsharp if you like F#
23:37:31 <applicative> avenge, sorry, I'm not very expert
23:37:59 <applicative> this is #haskell we like #fsharp
23:38:44 <mxc> the problem with F# is that most of the time when you use it, its because you need to work with some .Net libraries
23:38:58 <mxc> BUT, all hte .Net libraries are written in a very mutable, imperative way.
23:38:59 <Associat0r> mxc: not really
23:39:02 <avenge> applicative:  I was using cabal-install 0.8.0.  I'm going to blow everything away ~/.ghc, ~/.cabal, and try again with 0.8.2...
23:39:18 <mxc> in the end it feels like writing c# with slightly more convenient syntax and closures
23:39:30 <Associat0r> mxc: before F# my primary language was C++
23:39:38 <mxc> associat0r well, that was my experience. not the fault of the language, just the situation
23:39:45 <applicative> you still need to ghc-pkg unregister the bad libraries, if that's what it is
23:40:09 <mxc> applicative - i thought the reason we like F# is because the people who wrote it (MSR) are the same people paying to develop GHC..
23:40:15 <applicative> or I think you can just --force-reinstall when you install with the better cabal
23:40:21 <Associat0r> mxc: the problem is most interestin libs are mutable anyway
23:40:29 <avenge> applicative:  Doesn't rm -rf ~/.ghc take care of unregistering?
23:40:34 <Associat0r> mxc: look at all the C and C++ libs
23:40:45 <mxc> associat0r - true
23:40:48 <applicative> will the new cabal put it back?
23:41:04 <mxc> associat0r - i'm trying to figure out the best way to use the bloomberg data API in haskell now
23:41:06 <siracusa> avenge: Any output on `ghc-pkg check'?
23:41:17 <mxc> will probably end up writing a wrapper process in java :(
23:42:40 <avenge> siracusa:  What check?  I already started bootstrapping cabal-install, so now I see packages again, but only network and parsec which I think just got installed.
23:43:19 <avenge> siracusa:  Oh, sorry, you mean literally.  No, that command shows no output.
23:43:28 <siracusa> Ok
23:43:43 <chrisdone> applicative: hahaha. that twitter error was a test. I needed a type-class error to demonstrate O_O
23:43:52 <applicative> avenge: I think what happens with removing ~/.ghc will depend on whether there is another.  I have a version of the platform that is installed deeper in, then my cabal packages and stuff
23:44:18 <applicative> chrisdone, i of course inferred that, it was the choice of a test that struck me as hilarious and brilliant
23:44:26 <chrisdone> oh, hahaha
23:44:44 <applicative> instance Monad ...what...uh...I know....Char
23:44:53 <chrisdone> :D
23:44:57 <idnar> heh
23:45:14 <applicative> where return x = x : "Hahahahah"
23:45:21 <avenge> applicative:  Well, I'm testing on multiple Linux distros with multiple versions of ghc, and can't get happstack-server installed.  On Gentoo I have system-wide haskell-platform, on ubuntu there are much fewer system wide packages and almost everything goes into my home directory.
23:46:19 <applicative> avenge, i see. so it should work.  siracusa may comprehend better.
23:48:19 <applicative> avenge, so for example syb is in opt/local syb-with-class in ~/, probably by cabal install happstack.    ...I notice that I have hidden syb for some reason...
23:49:19 <kmc> deriving instance (Show (f (Mu f))) => Show (Mu f)
23:49:23 <kmc> ...this works?!?
23:49:36 <avenge> applicative:  Well syb seems to come with ghc on ubuntu, but not syb-with-class.
23:50:09 <applicative> yeah, I think it used to be a regular library, now its a Platform library
23:50:57 <int-e> kmc: yes :)
23:53:20 <tac-tics> Is there such a thing as an ST transformer?
23:54:57 <Cale> tac-tics: no
23:55:29 <tac-tics> I was going to say nevermind, I found it, lol
23:55:31 <Cale> (Though probably not for any particularly deep reason)
23:55:37 <Cale> Oh?
23:55:47 <tac-tics> http://hackage.haskell.org/packages/archive/STMonadTrans/0.2/doc/html/Control-Monad-ST-Trans.html
23:55:59 <tac-tics> One of those ask, then google moments
23:56:18 <applicative> avenge, i wonder if you can find a happstack expert on here sometime.
23:56:25 <kmc> that's not too kosher
23:56:37 <opqdonut> kmc: if you think about it, the code is exactly the same as in the non-recursive case
23:56:45 <opqdonut> and the constraint is easy to generate
23:56:57 <Cale> Hmm, I wonder if this is really a monad transformer.
23:57:18 <Cale> The warning about lists is suspicious.
23:57:24 <kmc> yeah
23:57:36 <tac-tics> Is there any theory behind what constitues a monad transf.?
23:57:49 <Cale> The result should always be a monad.
23:58:00 <Cale> If the thing you apply it to is a monad, of course :)
23:58:05 <tac-tics> You can "lift" any monad to a transformer version, can you?
23:58:10 <Cale> No.
23:58:31 <chrisdone> is there an abstraction for either/maybe?
23:58:36 <chrisdone> :t either
23:58:36 <chrisdone> :t maybe
23:58:37 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:58:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:58:50 <Cale> chrisdone: They're catamorphisms, like foldr
23:59:10 <chrisdone> Cale: I'd like one function to handle either, maybe, and list. is that possible?
23:59:27 <Cale> Awkwardly
23:59:35 <opqdonut> you can make it handle any MonadPlus
23:59:37 <opqdonut> maybe
23:59:42 <opqdonut> or any applicative functor
23:59:52 <opqdonut> or any Traversable (which all of those are, I guess)
