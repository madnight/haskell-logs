00:33:43 <tibbe> good morning
00:34:03 <tibbe> (this is me secretly trying to get the bots to deliver me any new messages ;)
00:47:56 <Eelis> is there something analogous to OverloadedStrings but for lists? in my codebase i use a data type of nonempty lists all over the place, and it would be *much* nicer if i could just use  [x,y,z]  instead of  NeList x [y, z]
00:48:34 <dibblego> x |: [y, z] -- NonEmptyList on hackage
00:49:34 <Eelis> yes, i realize using an infix operator also helps, but it's still not as nice.
00:52:31 <Saizan_> maybe with NoImplicitPrelude? but i wouldn't bet on it
00:53:31 <Saizan_> wrong flag
00:55:15 <jbapple> I just upgraded GHCi and some of my keybindings don't work like they used to, like ctrl+leftarrow
00:55:25 <jbapple> I know I fixed this before, but I can't remember how
00:55:33 <jbapple> This is why I usually delay upgrading
00:55:52 <blackdog> that'd be a readline thing, wouldn't it?
00:56:16 <dibblego> ~/.haskeline
00:56:30 <Maxdamantus> Hmm.. Why does this not work? case t of [] -> t; t -> foo t
00:56:32 <jbapple> I though so, but I remember only having to install libreadline-compat, which I obviously must have already installed in GHCi 6.1.* is running
00:56:37 <Saizan_> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax <- was thinking of this but list syntax doesn't seem to be rebindable
00:56:41 <Maxdamantus> But this does: case t of [] -> []; t -> foo t
00:56:48 <jbapple> dibblego: what about .haskeline?
00:57:05 <Maxdamantus> "cannot construct the infinite type"
00:57:29 <Saizan_> jbapple: lately ghc started using haskeline in place of readline, and it has its own file for keybindings and options
00:57:32 <dibblego> jbapple, GHCi is likely to be using haskeline
00:57:32 <kulin> if i have "data ConnID = MkConnID Int" is the only way to get the Int value through pattern matching?
00:57:36 <Saizan_> ?google trac wiki haskeline
00:57:37 <lambdabot> No Result Found.
00:57:40 <Botje> Maxdamantus: what's the type of foo?
00:58:13 <Maxdamantus> [a] or something (this is actually inside foo)
00:58:21 <Botje> hmm
00:58:27 <Botje> can you put the full function on a pastebin?
00:58:37 <Saizan_> jbapple: http://trac.haskell.org/haskeline/wiki/KeyBindings
00:58:42 <Botje> hpaste is back online, apparently
00:58:55 <Maxdamantus> rcat (h:t) = h ++ case t of [] -> t; t -> rcat t
00:59:08 <Maxdamantus> It's not big, just that.. And it's not really a problem, just curious why.
00:59:46 <jbapple> Saizan_: thanks
00:59:46 <Maxdamantus> ([] works in place of the second use of t)
00:59:58 <jbapple> Why the switch off readline? licensing?
01:00:27 <Maxdamantus> Hmm.. Unless lists explicitly end with []
01:00:37 <roconnor> http://code.haskell.org/~aavogt/darcsVersions/contrib.png -- terrible terrible graph
01:00:43 <Maxdamantus> eh, that doesn't make sense.
01:01:05 <roconnor> dons: what software made that abomination of a chart?
01:01:44 <roconnor> please don't say it was Haskell Charts
01:01:56 <olsner> looks like gnuplot
01:02:05 <roconnor> good god
01:02:05 <Botje> Maxdamantus: i get an error either way.
01:02:24 <roconnor> I know gnuplot was bad, but this is even worse than I ever imagined
01:02:35 <Maxdamantus> So you get an error with this too? rcat (h:t) = h ++ case t of [] -> []; t -> rcat t
01:02:36 <Saizan_> jbapple: yeah :\
01:02:39 <Botje> Maxdamantus: which makes sense.
01:02:47 <roconnor> @tell dons plz switch from gnuplot to haskell chart.
01:02:47 <lambdabot> Consider it noted.
01:02:54 <Botje> Maxdamantus: let's say (h:t) is of type [a], right?
01:03:07 <Maxdamantus> Right
01:03:17 <Botje> you're doing "h ++ ...", which means that h must also be a list type
01:03:40 <Botje> so a = [a], and haskell gets confused
01:03:58 <Botje> you should do h : or [h] ++
01:04:01 <Maxdamantus> Yeah, I'm joining a list of strings.
01:04:05 <tensorpudding> Wow, that's a really nasty looking plot.
01:04:28 <Maxdamantus> > rcat ["foo", "bar", "baz"] -> "foobarbaz"
01:04:29 <lambdabot>   <no location info>: parse error on input `->'
01:04:38 <tensorpudding> Not sure how you'd get the x-axis labels to be vertical like that on accident.
01:04:53 <Botje> Maxdamantus: your first use of t should be a []
01:05:17 <Botje> case t of [] -> t -- the last t should be []
01:05:17 <Maxdamantus> First use? after the case?
01:06:00 <Botje> rcat (h:t) = h ++ (case t of [] -> []; t -> rcat t)
01:06:03 <Maxdamantus> Why? [] == t apparently
01:06:04 <jbapple> Saizan_ , dibblego : thanks, that helped! I have it fixed now
01:06:06 <Botje> writing it out this way works.
01:06:09 <Botje> Maxdamantus: no, the types differ.
01:06:30 <jbapple> RMS wins again ::shakes fist::
01:06:32 <Botje> rcat :: [[a]] -> [a]
01:06:56 <Botje> so the [] that you pattern match against is of type [[a]], but your return type is [a]
01:07:25 <Maxdamantus> Ohhhh
01:07:27 <siracusa> jbapple: I had a reconnect, how did you get it fixed?
01:07:42 * Maxdamantus gets it now
01:07:46 <Maxdamantus> Thanks.
01:09:55 <Botje> not all [] are created equal >:)
01:10:42 <Maxdamantus> Yep, just forgot for a minute that t was not the same type as h
01:14:11 <I_LIVE> how to convert list to array, and vice versa?
01:14:31 <siracusa> dibblego, Saizan_ : Can you please write the solution for jbapple's problem again, I missed it due to a reconnect!?
01:14:44 <fasta> I_LIVE, that's probably the wrong question to ask.
01:15:05 <fasta> I_LIVE, there is no such thing as "array", there are Arrays, STArrays, IOArrays, and so on.
01:15:18 <fasta> I_LIVE, the modules containing these types provide conversion routines.
01:15:30 <tibbe> How can I check if a function was exported for inlining by GHC (regardless of  if it actually was inlined at the call site)?
01:15:41 <tibbe> I guess it would appear in the .hi file but I can't read that.
01:16:11 <Botje> I_LIVE: listArray goes one way, elems goes the other.
01:18:05 <Twey> roconnor: gnuplot doesn't have to be bad
01:18:11 <Twey> It just has crappy defaults
01:27:24 <roconnor> Twey: do you have an example of a non crapy plot made by gnuplot?
01:27:58 <roconnor> for god sake, gnuplot in 3d mode didn't even draw it's quads in z-order!
01:27:59 <Twey> Ummm
01:28:24 <roconnor> it draws occuled quads in front of the the quads it is behind!
01:28:32 <roconnor> why does anyone use it!
01:28:38 * roconnor head 'splodes
01:29:17 <Twey> roconnor: http://twey.ath.cx/files/College/Subjects/Physics/Homework/2010-08/graph.png
01:30:04 <roconnor> Twey: thanks
01:32:36 <fasta> roconnor, are you sure there is no way to specify order?
01:33:18 <roconnor> fasta: oh I specified the order, it just draws the parametirc surface in the order of the parameters
01:33:36 <Saizan_> siracusa: http://trac.haskell.org/haskeline/wiki/KeyBindings
01:33:37 <roconnor> cause they are really lazy I guess.
01:33:58 <Saizan_> siracusa: fyi, there's a link to the logs in the topic :)
01:35:05 <roconnor> ooh
01:35:10 <siracusa> Saizan_: Thanks! Yes, I know about the logs, but I don't know the interval they are updated.
01:35:11 <roconnor> I've ranted about this before
01:35:14 <roconnor> fasta: http://r6.ca/blog/20050521T191500Z.html
01:36:03 <roconnor> The documentation says, "Colored quadrangles are plotted one after another. When plotting surfaces (`at s`), the later quadrangles overlap (overdraw) the previous ones."
01:36:04 <fasta> roconnor, I could tell you, but then I would not get a Haskell plot library.
01:36:24 <roconnor> :)
01:36:43 <fasta> roconnor, I think the Sage plot tools are quite good.
01:36:58 <fasta> roconnor, it is GPL, though, but it is nice for debugging.
01:37:02 <Eelis> what's a nice succinct way of writing [(x, y) | x <- a, y <- b] ?
01:37:09 <roconnor> Eelis: zip a b
01:37:18 <roconnor> er
01:37:22 <roconnor> sorry
01:37:29 <Eelis> :)
01:37:33 <roconnor> liftM2 (,) a b
01:37:48 <Eelis> ah, excellent. thanks!
01:37:52 <fasta> Eelis, I would just name it and don't care about how short it is :)
01:38:17 <roconnor> (,) <$> a <*> b
01:38:30 <fasta> roconnor, heh.
01:38:43 <roconnor> there ought to be a nice function in the applicative library for that
01:38:43 <fasta> roconnor, that's some nice line-noise.
01:39:54 <roconnor> but there isn't
01:40:12 <Eelis> i vaguely recall conor arguing for a syntax along the lines of [[ f x y ]] for applicative expressions. did anything ever came of that? can it be done with the various ghc extensions?
01:40:25 <roconnor> there is a library for that
01:40:41 <Eelis> do you happen to know the name? :)
01:40:59 <roconnor> http://www.haskell.org/haskellwiki/Idiom_brackets
01:41:01 <roconnor> hmm
01:41:03 <Saizan_> she also has those
01:41:08 <roconnor> is the library packaged somewhere?
01:43:06 <quicksilver> they don't really work, visually, IMO
01:43:17 <quicksilver> although a bit of syntax highlighting in a customisable editor would help.
01:43:56 <Eelis> can't one use TH to get something like  $(appl  f x y)  ?
01:44:39 <quicksilver> I would think almost certainly, yes
01:44:50 <quicksilver> you could use a quasiquoter too and define whatever syntax you like
01:44:51 <Saizan_> $(appl [| f x y |]) or [$appl| f x y |] if you want to do some parsing
01:45:29 <Saizan_> the problem (especially in the former case) is that the concept is somewhat broken wrt partial application
01:45:43 <Eelis> hm, i could also just do   #define appl(x) (iI x Ji)
01:46:15 <fasta> roconnor, you link to http://www.livejournal.com/users/r6/45953.html, but that is a dead link.
01:46:36 <Saizan_> is [[ (f x) y ]] translated to "f x <$> y" or "f <$> x <*> y"?
01:46:40 <roconnor> ya I just noticed that
01:46:45 <roconnor> I thought I fixed that all
01:50:31 <roconnor> fasta: the link is supposed to be to http://r6.ca/blog/20050521T185500Z.html
01:50:36 <roconnor> It will be fixed shortly
01:52:24 <fasta> roconnor, there is a BBC documentary about chaos too, which might interest you.
01:53:44 <roconnor> I've seen it
01:53:49 <roconnor> it was nice
01:56:40 <fasta> roconnor, there is another one about infinity, but I guess you have seen that one too already.
01:56:56 <roconnor> ugh, I have tens of posts with the same problem
01:57:12 <roconnor> which one is that?
01:57:58 <fasta> roconnor, about Godel, Boltzmann and Cantor.
01:58:26 <fasta> roconnor, and a bunch of academics saying how great they were.
02:00:51 <fasta> roconnor, there is also an interview with Chaitin (which he probably doesn't do that often).
02:01:14 <roconnor> ah
02:01:18 <roconnor> yes I remember that
02:15:07 <ivanm> hey Fallen_Demon
02:18:10 <Eelis> > let alternate [] x = x; alternate x [] = x; alternate (x:xs) (y:ys) = x : y : alternate xs ys in alternate "abcde" "12345" -- is there a nicer way to write this alternate function? is it perhaps already in the stdlib by another name?
02:18:11 <lambdabot>   "a1b2c3d4e5"
02:18:39 <ivanm> Eelis: some kind of zipWith?
02:18:49 <ivanm> but it won't give you those end lists, but cut it all off
02:18:59 <Eelis> i want the end lists
02:19:19 <ivanm> then no, there's no standard function that I can think of that does this
02:19:35 <Eelis> ok
02:20:25 <Botje> Eelis: alternate [] xs = xs; alternate (x:xs) ys = x : alternate ys xs
02:20:48 <Eelis> ah, neat!
02:21:15 <Eelis> really seems like a curious omission in Data.List to me though
02:21:59 <Eelis> considering that it has functions that do much more exotic things
02:22:57 <quicksilver> > concat $ transpose ["abcde","12345"]
02:22:58 <lambdabot>   "a1b2c3d4e5"
02:23:00 <quicksilver> Eelis: ^^
02:23:08 <ivanm> yeah, I've wanted variants of the zip* functions that appended the remaining list on the end (or at least used Either or something to indicate what the remaining list was)
02:23:14 <Botje> haha, quicksilver++
02:23:14 <ivanm> quicksilver: show off!
02:23:16 <Botje> nice one
02:23:18 <Eelis> quicksilver: ah, better still :) but won't the indirection make it slower than Botje's version?
02:23:29 <quicksilver> well, everything inlines, so who knows.
02:23:31 <ivanm> Eelis: use criterion to find out!
02:23:37 <Eelis> ivanm: i dare not!
02:23:50 <ivanm> whynot?
02:23:52 <ivanm> *why not
02:23:57 <quicksilver> but probably, yes, the direct recursion would be faster.
02:24:10 <Eelis> ivanm: i only ever do benchmarks with time(1)
02:24:21 <ivanm> heh
02:24:23 <ivanm> fine then, use that!
02:25:45 <Eelis> seems like it would need quite a bit of fusion to get translated into the direct recursive version
02:26:43 <ivanm> > concat $ transpose ["abc", "12345"]
02:26:44 <lambdabot>   "a1b2c345"
02:26:53 <ivanm> OK, it does append the rest of the list
02:35:03 <jarick> Hi. Anyone used Network.Pcap's dump?
02:35:30 <jarick> It expects a Ptr PktHdr. I get a PktHdr from loop.
02:36:01 <jarick> Obviously these are different datatypes, but the docs claim that "dump is designed so it can be easily used as a default callback function by dispatch or loop. "
02:36:15 <jarick> http://hackage.haskell.org/packages/archive/pcap/0.4.5/doc/html/Network-Pcap.html
02:36:53 <nainaide> How to wirite the following in Non-Record Syntax Mode ? data Frank a b = Frank {frankField :: b a} deriving (Show)
02:37:00 <nainaide> Thanks
02:37:22 <opqdonut> data Frank a b = Frank (b a) deriving Show
02:37:32 <opqdonut> was this an assignment?-)
02:37:40 * ivanm is wondering whether to abuse John Macfarlane's Makefile for pandoc for his own website written using pandoc or to just write a shell script
02:38:20 <ivanm> especially since I don't understand makefile syntax, and thus am not sure what's possible and what's not :s
02:38:21 <nainaide> noj, just read from "Learn you a Haskell"
02:38:53 <nainaide> how about function "frankField "  then?
02:39:17 <opqdonut> use pattern matching
02:39:17 <Botje> frankField (Frank x) = x
02:40:05 <nainaide> Botje,  why not  Frank x  y instead Frank x
02:40:38 <quicksilver> because Frank only has one parameter
02:40:44 <opqdonut> Frank only has one field which has type (b a)
02:40:45 <quicksilver> "b a" is a single type, not two types.
02:41:45 <nainaide> OOh, I see , I had thought  b a are two parameters
02:42:53 <quicksilver> "frankField :: b a" means it's only one; there is always exactly one type after a ::
02:43:03 <quicksilver> so, you have to conclude that 'b' is a type constructor
02:43:14 <quicksilver> and 'a' the parameter to the type constructor.
02:43:28 <quicksilver> an example would be "Frank Int Maybe", where "b a" becomes "Maybe Int"
02:43:39 <quicksilver> to be honest, things like that are not all that common.
02:43:49 <nainaide> quicksilver,  thanks, very good explaination
02:45:30 <jarick> Alternatively, is there such a thing as a a -> Ptr a?
02:46:18 <opqdonut> I don't think so
02:46:37 <Saizan_> jarick: if there isn't one you can write Storable a => a -> IO (Ptr a)
02:46:56 <Saizan_> by allocating a chunk of memory and using poke
02:48:10 <jarick> Saizan_: Possibly. But I am confused as to the authors' claims for Network.Pcap.
02:48:30 <jarick> It claims that dump is directly compatible as a callback.
02:50:01 <jarick> dump :: DumpHandle -> Ptr PktHdr -> Ptr Word8 -> IO ()
02:50:12 <jarick> Whereas the callback from loop expects
02:51:37 <jarick> PktHdr    -> Ptr Word8  -> IO ()
02:52:10 <jarick> I can generate a DumpHandle. Question was how to convert PktHeader (which loop gives me) into Ptr PktHdr
02:52:27 <quicksilver> well you can do it in IO
02:52:31 <quicksilver> which is OK, because you are in IO.
02:52:55 <jarick> quicksilver: How do you mean?
02:53:15 <quicksilver> there are functions in foreign.* to allocate Ptrs
02:53:41 <quicksilver> unfortunately I can't find them because someone seems to have broken the library docs on haskell.org
02:53:48 <jarick> quicksilver: I am looking for them now.
02:53:53 <quicksilver> @hoogle malloc
02:53:53 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
02:53:54 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
02:53:54 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
02:54:02 <quicksilver> 'malloc' is the simplest one.
02:54:12 <jarick> quicksilver: I don't want to malloc again.
02:54:20 <jarick> The data is already there.
02:54:26 <quicksilver> tough luck
02:54:28 <quicksilver> you have to malloc.
02:54:59 <jarick> quicksilver: And copy?
02:55:05 <jarick> That sounds painful.
02:55:52 <quicksilver> it's not a question of copy, it's a quesiton of serialise
02:56:21 <quicksilver> the in-memory format of a PktHdr may be entirely different from the format its Storable instance uses in a Ptr PktHdr
02:56:39 <jarick> True. You're right, there may be a need to copy.
02:56:40 <quicksilver> (or, it may not be all that different - depends on the instance, obviously)
02:57:01 <jarick> Or I shall go poke at the implementation until I get a Ptr PktHdr
02:57:03 <quicksilver> if you're scared of copying memory around you may find haskell a frightening language :)
02:57:17 <quicksilver> you won't find a way to get a Ptr to haskell values
02:57:23 <quicksilver> because haskell values can move at GC time
02:57:34 <quicksilver> so a pointer to them isn't safe.
02:57:36 <jarick> quicksilver: I intend to peek and poke at the C struct then.
02:57:44 <quicksilver> that's what Ptrs are for, yes
02:57:53 <jarick> Then I shall do that.
02:57:56 <quicksilver> (they're Ptrs to C structs in fixed locations, not haskell values)
02:58:02 <jarick> Now, off to home!
03:13:23 <EvanR> :t Ptr
03:13:23 <lambdabot> Not in scope: data constructor `Ptr'
03:13:30 <EvanR> @src Ptr
03:13:30 <lambdabot> data Ptr a = Ptr Addr#
03:16:30 <EvanR> @hoogle IO (Maybe a) -> IO [a]
03:16:30 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
03:16:30 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
03:16:30 <lambdabot> Network.Socket getAddrInfo :: Maybe AddrInfo -> Maybe HostName -> Maybe ServiceName -> IO [AddrInfo]
03:16:59 <dibblego> @type fmap maybeToList
03:17:01 <lambdabot> forall a (f :: * -> *). (Functor f) => f (Maybe a) -> f [a]
03:18:03 <EvanR> [a] is the x from Just x for all the Maybe a up to the first Nothing
03:18:41 <dibblego> did you mean [Maybe a] instead of (Maybe a) ?
03:18:52 <quicksilver> that would be map fromJust . takeWhile (not . isNothing)
03:18:58 <dibblego> @type fmap catMaybes
03:18:59 <lambdabot> forall a (f :: * -> *). (Functor f) => f [Maybe a] -> f [a]
03:19:11 <quicksilver> but as dibblego says, that suggests you have [Maybe a] not (Maybe a)
03:19:27 * hackagebot regex-pderiv 0.0.6 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pderiv-0.0.6 (KennyLu)
03:19:32 <EvanR> do an IO action that results in Maybe a until it results in Nothing and return the fromJusts
03:19:48 <dibblego> @type takeWhileM
03:19:48 <quicksilver> oh, I see.
03:19:49 <lambdabot> Not in scope: `takeWhileM'
03:19:54 <dibblego> boo
03:20:02 <quicksilver> there is nothing built in for that but it's simple enough.
03:20:18 <EvanR> one liner?
03:20:46 <EvanR> i could do it using a recursive function and a Sequence, or a list which finally reverses
03:21:44 <EvanR> unfoldM :: m (Maybe a) -> m [a]
03:23:17 <dibblego> you want to takeWhile isJust then catMaybes right?
03:23:30 <quicksilver> runUntilNothing act = do x <- act; case x of Nothing -> []; Just y -> fmap (y:) (runUntilNothing act)
03:23:31 <EvanR> theres no original list
03:23:39 <quicksilver> depends how you define 'one-liner' I guess
03:23:40 <Twey> notNothings a = a >>= maybe (return []) (flip fmap (maybes a) . (:))
03:23:52 <quicksilver> I'd probably write it in 3 lines.
03:24:00 <Twey> Er
03:24:03 <Twey> notNothings a = a >>= maybe (return []) (flip fmap (notNothings a) . (:))
03:24:22 <Twey> Hm
03:24:25 <EvanR> quicksilver: i think thats how i originally wrote it, but without the fmap, so it looked kind of hairy
03:24:34 <EvanR> Twey seems to be on to something
03:25:17 <EvanR> i would like it to be in order too, not reversed
03:25:30 <quicksilver> mine was in order
03:25:35 <EvanR> yes
03:25:47 <quicksilver> twey's is the same as mine, just using 'maybe' instead of my case
03:25:57 <quicksilver> any case on Maybe can be written using maybe
03:26:04 <quicksilver> but, to be honest, I find case just as short and clear
03:26:23 <Twey> I don't
03:26:27 <EvanR> i am annoyed by the pattern
03:26:29 <quicksilver> I did miss a return, too :)
03:26:30 <EvanR> x <- foo
03:26:31 <EvanR> case x of
03:26:34 <Twey> Yes
03:26:53 <Twey> It's considerably longer and more conceptually clumsy
03:27:22 <Twey> Are we in order?
03:27:29 <Twey> I think both of ours end up reversed
03:28:25 <Saizan_> mh, all of those fmaps over Maybe make me sad
03:28:26 <Twey> That's just a case of wrapping it with a fmap reverse, of course
03:28:37 <dibblego> Saizan_, I was just thinking that :)
03:28:41 <Twey> Saizan_: Nobody fmapped over Maybe :þ
03:29:08 <dibblego> I'm not sad though, since I am high on opioid analgesia
03:29:18 <Twey> The fmap is over the monad in both our cases
03:29:29 <Saizan_> ah, true, do we know in which monad act is?
03:29:33 <Twey> No
03:29:50 <Twey> I'm being sane and assuming that it's also a functor, though
03:29:58 <Saizan_> then i'm not so sad
03:30:06 <Twey> Good good ☺
03:30:07 <EvanR> im using it for IO
03:30:13 <Twey> What's up with fmapping over Maybe, anyway?
03:30:21 <Twey> It's useful in many cases.
03:30:53 <quicksilver> I think we do know it's IO, EvanR said so.
03:31:06 <Twey> We do, but there's no point in restricting it needlessly
03:31:15 <Saizan_> sure, but if you do it a lot you
03:31:23 <Saizan_> ops.
03:31:56 <Saizan_> however, the first thing is that it's strict, so if you make a big fmap f (fmap f ...) thunk it's going to use a lot of stack
03:32:22 <Twey> Eh?  If it's strict the thunks get evaluated so it doesn't use much stack, surely?
03:32:47 <Saizan_> > foldl (+) 0 [1..100000000]
03:32:53 <lambdabot>   mueval: ExitFailure 1
03:32:59 <Saizan_> bah.
03:33:45 <Twey> foldl' is the strict version
03:33:53 <Twey> > foldl' (+) 0 [1 .. 100000]
03:33:56 <lambdabot>   5000050000
03:33:57 <Saizan_> (+) is strict by itself
03:34:01 <Twey> Yeah
03:34:05 <Saizan_> that's why you need foldl'
03:34:13 <Saizan_> if it were lazy, it wouldn't stack overflow
03:34:19 <Twey> Oh
03:35:36 <Twinside> hi, I've got a compilation problem with my code ( http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25054#a25054 ), does someone has an idea why?
03:36:46 <Saizan_> Twey: you've the problem of being strict without being eager, also to not use stack and be eager we'd have to do a trasformation of our code here
03:38:20 <Saizan_> Twey: anyhow, the easiest solution would be to use Codensity Maybe which does the necessary transformations
03:44:06 <dolio> Twinside: You can't put the MArray context assertion outside of the runST. The variable s is brought into scope by runST, so any assertion you make about ST s outside won't be the right assertion.
03:45:37 <Zeiris> What's Haskell like for running on microcontrollers? Is it possible or practical?
03:45:40 <Twinside> ok, so, to fix my problem I have to put a type signature within the parenthesis?
03:45:49 <quicksilver> dolio: but his assertion outside the runST is forall s
03:45:59 <lazni> @src optional
03:45:59 <lambdabot> optional v = Just <$> v <|> pure Nothing
03:46:02 <quicksilver> dolio: so it should apply to all s including the s which gets used by this particular runST
03:46:06 <quicksilver> dolio: no?
03:46:45 <dolio> No. His function works for all s.
03:46:55 <dolio> Which has nothing to do with the s inside runST.
03:47:02 * quicksilver nods
03:47:06 <Twey> Zeiris: Should be
03:47:44 <Twey> It's not exactly designed to run in very low-resource environments, but there's no reason why it couldn't be done
03:48:09 <Zeiris> Well, even cheap uCs can be pretty powerful these days.
03:48:16 <dolio> Twinside: I'm not certain what the solution to your problem is. It's a weakness of that array library.
03:48:24 <Twey> Depending on the performance requirements, you might want a more bit-fiddly language like FORTH, though
03:50:08 <Twinside> hmm thats bad :-/
03:50:32 <zygoloid> Twinside: the trouble is, you implicitly get a 'forall s.' on your MArray constraint, but you want an 'exists s.'
03:51:47 <bremner> Zeiris: do you know about bitc?
03:52:04 <dolio> There's no way of expressing that 'a' being a valid type to put in an immutable unboxed array means that 'a' is also valid to put in mutable unboxed arrays.
03:52:18 <Twinside> any chance to get something working using typeclasses (to specialize the call to runST)?
03:52:21 <dolio> I think at least.
03:52:44 <Zeiris> bremner, not at all, but googling it now.
03:53:41 * zygoloid wonders if 'class MArray (STUArray s) a (ST s) => STUArrayable a; instance MArray (STUArray s) a (ST s) => STUArrayable a' would help
03:54:16 <dolio> I have a feeling that doesn't work.
03:54:36 <zygoloid> the class at least should require the MArray instance to be parametric over s, which should be all you need
03:55:04 <dolio> Well, the thing is, IOArray is also in MArray.
03:55:08 <dolio> And that has no parameter.
03:55:55 <dolio> ST may actually post-date the MArray class.
03:56:04 <dolio> Which could explain why it has problems.
03:56:40 <dolio> vector has all arrays properly parameterized.
03:58:48 <dolio> Twinside: So that's one option. You could switch your code to use the vector package. :)
03:59:35 <zygoloid> dolio: you're right, the class doesn't work because 's' isn't implicitly quantified and can't be explicitly quantified :(
03:59:51 <Saizan_> or use gadts and polymorphic components to pass the polymorphic dictionary in.
04:01:32 <Twinside> well, I've tried a workaround which seem to work
04:02:15 <Twinside> I introduce a class UPckable with only one method (Word32 -> Word32 -> ([Word32], [Word32], [a]) -> (UArray Word32 Word32, UArray Word32 Word32, UArray Word32 a)
04:02:30 <Twinside> and when introducing specialisation it seem to compile without any problem
04:28:53 <McManiaC> @src (:)
04:28:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:35:51 <ivanm> McManiaC: well, are you going to answer lambdabot or what?
04:36:56 * hackagebot CSPM-Frontend 0.3.0.3 - A CSP-M parser compatible with FDR-2.83  http://hackage.haskell.org/package/CSPM-Frontend-0.3.0.3 (MarcFontaine)
04:38:57 * hackagebot stm 2.1.2.0 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.1.2.0 (SimonMarlow)
04:46:40 <ivanm> anyone know if there's a map/mapM equivalent in bash?
04:47:43 <ivanm> that is, without doing an explicit loop
04:48:13 <quicksilver> yes, it's called ghci -e
04:48:16 <quicksilver> ;)
04:48:52 <McManiaC> ivanm: nope :>
04:49:02 <ivanm> @slap quicksilver
04:49:02 * lambdabot hits quicksilver with a hammer, so they breaks into a thousand pieces
04:49:20 <ivanm> I want to run pandoc on each of a list of input files
04:49:31 <quicksilver> why are you so scared of 'an explicit loop' ?
04:49:42 <ivanm> because surely there's a better way of doing it!
04:49:47 <quicksilver> it's not as if it's more than a few characters to type.
04:49:53 <quicksilver> define 'better'?
04:49:58 <ivanm> a one-liner!
04:50:06 <quicksilver> you can write loops in one line
04:50:07 <quicksilver> I always do
04:50:08 <McManiaC> for i in *; do
04:50:22 <arcatan> ivanm: xargs
04:50:24 <quicksilver> for i in *.foo; do pandoc $i > $i.html; done
04:53:36 <ivanm> last time I did something like this (a few years ago I was looping through a set of flags to test with), I used some monstrosity involving values like ({"foo", "bar"}); can't even recall what that is or what it does :s
04:53:40 <ivanm> arcatan: hmmm...
04:55:30 <QtPlatypus> ivanm: The map equivlent in bash is the pipeline.
04:55:36 <QtPlatypus> And filters.
04:55:37 <ivanm> huh?
04:55:41 <ivanm> isn't that function composition?
04:56:18 <quicksilver> for i in a b c d; do .... ; done;
04:56:32 <quicksilver> simple list literals don't require ({ monstrosities })
04:56:52 <quicksilver> xargs is another useful tool, too.
04:57:09 <ivanm> quicksilver: I wanted them defined up the top at the time IIRC
04:57:27 <ivanm> so when I changed it for a new machine, I didn't have to dig halfway through the script
04:57:32 * ivanm 's bash-fu is rather weak
04:58:18 <ivanm> quicksilver: and even in this case I would prefer to have all the values defined earlier rather than in the middle of the script
04:58:29 <ivanm> (so that I can do other things with them without having to copy-paste the entire list)
04:58:44 * ivanm wonders if it would just be easier to write a Haskell script to do all this...
04:59:01 <quicksilver> it would, yes.
04:59:03 <McManiaC> hmmm wtf
04:59:11 <quicksilver> always easier to use a langauge you know better
04:59:15 <McManiaC> why cant I send mails to the haskell-cafe ml?
04:59:20 <quicksilver> an haskell is a better language than bash anyway
04:59:31 <quicksilver> McManiaC: accidentally sending from a different address to the one you subscribed with?
04:59:54 <McManiaC> nope
05:03:10 <fasta> quicksilver, you mean that you can actually write parallel programs in Haskell without writing to a file?
05:03:32 <fasta> quicksilver, (no, you cannot do that in bash)
05:04:11 <ivanm> McManiaC: I just sent one, so it isn't the system that's wrong
05:04:19 <ivanm> fasta: heh
05:08:12 <samphippen> http://pastebin.com/BLGEjyMj is there a nicer way of rewriting this function?
05:08:19 <samphippen> there's a lot of duplicate code in there
05:09:44 <dolio> Matching against stack is probably preferable to doing the stuff with head/tail.
05:11:22 <dolio> Also, you can switch from using 4 separate binary constructors to a single BinOp constructor that contains a label for Add/Times/etc.
05:12:02 <kbp> is there any prelude function to make a string from char and num? for example 5*"a" = "aaaaa"
05:12:12 <quicksilver> or if you don't want to do that, you can at least make an auxiliary function for parsebinary
05:12:26 <quicksilver> but you'll get a considerably clearer code just by getting rid of the head/tail obscenities
05:12:37 <McManiaC> ivanm: mmmh :(
05:12:51 <dolio> @type \n -> concat . replicate n
05:12:52 <lambdabot> forall a. Int -> [a] -> [a]
05:13:08 <dolio> > concat . replicate 5 $ "abc"
05:13:10 <lambdabot>   "abcabcabcabcabc"
05:13:18 <kbp> thanks dolio
05:16:00 <McManiaC> samphippen: looks like a fold to me
05:17:25 <quicksilver> samphippen: http://pastebin.com/pLHr0aQY
05:17:38 <quicksilver> samphippen: is already a big improvement in readability, just by removing the head/tail noise
05:17:49 <quicksilver> however, your code is very suspicious to me; nothing is using the 'a' and 'b'
05:17:59 <samphippen> quicksilver, I'm aware
05:18:05 <quicksilver> and it looks like a forth-style stack language which is confused about whether it is using two stacks or one :)
05:18:10 <samphippen> I should change those to NULL NULL
05:18:22 <quicksilver> it seems to push results back onto the second stack but always take commands from the first
05:18:25 <quicksilver> or something.
05:18:54 <samphippen> quicksilver, the first is a queue
05:18:54 <rtaycher> is there a guide somewhere to haskell capitalizition ie when to use words_with_underlines and/or camelCase
05:20:07 <dolio> Always use camel case.
05:21:15 <Twey> samphippen: http://pastebin.com/4vN27TAD
05:21:31 <Twey> samphippen: It's a bit odd not to be using any of the parameters of the operators you pull from that list, though… perhaps you should be using a separate data-type?
05:21:48 <samphippen> Twey, I've just changed it
05:21:54 <samphippen> all those A's and B's are now NULL expressions
05:22:16 <quicksilver> NULL expressions sounds pretty horrid too :)
05:22:16 * hackagebot uuagc 0.9.21 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.21 (ArieMiddelkoop)
05:22:17 <Twey> (you can remove all the Foo {} -> Foo by using Data.Typeable or something, if you really want)
05:23:02 <siracusa> Twey: Can you use Foo {} even if Foo is not a record data constructor?
05:23:22 <Twey> siracusa: Yes
05:23:29 <siracusa> Cool
05:25:35 <Twey> siracusa: You just can't put anything inside it ☺
05:26:21 <siracusa> Twey: Sure, but it's great just for checking if a certain constructor is given
05:26:31 <Twey> Yeah.
05:28:54 <kbp> I have a function like func :: String -> String. I'd like to check if the input starts with string "Call function.." or "Return from...". Could anyone please help? I tried func ("Call function":xs) = ... or func ("Return from":xs) = ... but Haskell doesnt allow to do such pattern matching.
05:29:18 <quicksilver> you can spell it out in painful detail with 'C':'a':....
05:29:26 <quicksilver> or you can just use isPrefixOf
05:30:16 <kbp> which module the isPrefixOf belongs to?
05:30:25 <alpounet> @index isPrefixOf
05:30:25 <lambdabot> Data.List
05:30:26 <siracusa> Data.List
05:30:40 <Twey> Hm
05:30:55 <kbp> oh so it's already in Prelude, thank you :)
05:31:03 <Twey> I'd add a helper function and use view patterns, I think
05:32:17 <Twey> chopOff pref xs | isPrefixOf pref xs = Just (drop (length pref) xs) | otherwise = Nothing
05:32:53 <Twey> func (chopOff "Call function" -> Just xs) = …; func (chopOff "Return from" -> Just xs) -> …; func _ = error "Unknown command"
05:35:01 <EvanR> this is annoying
05:35:11 * zygoloid . o O ( func $(genPat [p|"Call function" ++ xs|]) = ... )
05:35:24 <EvanR> act >>= maybe (maybe []) (\x -> do\n -- works
05:35:37 <EvanR> act >>= maybe (return []) (\x -> do\n -- works
05:35:53 <EvanR> act >>= maybe (return []) $ \x -> do\n --does not
05:35:57 <kbp> Twey & zygoloid methods are complex for me (im just a newbie though)
05:36:07 <Botje> EvanR: because $ has a lower precedence than >>=
05:36:12 <Twey> zygoloid's is hypothetical ☺
05:36:27 <EvanR> how to fix
05:36:39 <Botje> kbp: func command | "Call function" `isPrefixOf` command = ...
05:37:00 <Twey> EvanR: $ scopes over the >>=
05:37:00 <EvanR> >>= $
05:37:20 <Twey> So that's (act >>= maybe (return [])) (\x -> …
05:37:25 <EvanR> yes
05:37:38 <Twey> You can fix it by using brackets ;)
05:37:43 <Twey> Or using prefix >>=
05:37:54 <EvanR> meh
05:38:01 <Twey> (act >>=) . maybe (return []) $ \x -> …
05:38:02 <EvanR> ill use parens
05:38:49 <EvanR> or
05:39:02 <EvanR> act >>= maybe (return []) foo where
05:39:05 <kbp> Interpret.hs:539:6: Not in scope: `isPrefixOf' <-- ??
05:39:09 <Twey> That works too
05:39:16 <Twey> kbp: import Data.List (isPrefixOf)
05:40:53 <kbp> ok cool, no error now
05:41:53 <EvanR> Twey: http://codepad.org/MworFFIy so is this one of those 'stack over flow' things, for a lot of not nothings, will the intermediate list get ginormous in memory
05:43:21 <Twey> EvanR: 1) Depends on the monad; 2) It's not an unfold
05:43:43 <Twey> That's the ‘untilNothing’ I wrote earlier, just with added redundancy :þ
05:44:14 <EvanR> what monad would it be ok with
05:44:21 <EvanR> and what about IO
05:44:30 <whald> anyone ever successfully used a DiffArray? http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays#DiffArray_.28module_Data.Array.Diff.29 says it's update operation takes O(n)
05:44:42 <Twey> next = flip liftM $ unfoldM act . (:)
05:45:00 <whald> doesnt this defeat the whole point of using a DiffArray in the first place?
05:45:06 <Twey> EvanR: It'll be okay for any monad — it'll just overflow if you use a strict one (as creating a ginormous list tends to do)
05:45:12 <Twey> IO will if big enough, yes
05:45:34 <Twey> Errr
05:46:17 <Twey> ((`liftM` unfoldM act) . (:))
05:47:05 <EvanR> would it be better to pass a Data.Sequence recursively and use |>
05:48:15 <fasta> whald, it is O(size of change)
05:48:28 <EvanR> whald: update in theory would be slow with diffarray if you are using 'and old version'
05:48:38 <fasta> whald, and DiffArrays are more like O(horrible * size of change).
05:48:41 <Twey> EvanR: No
05:48:56 <EvanR> no what
05:48:58 <Twey> EvanR: Whatever you do, you have to build up a big list of results
05:49:18 <Twey> Using a different data structure won't help that
05:49:25 <Twey> (the list is fine here)
05:49:37 <EvanR> just seems like im building it backwards
05:49:39 <whald> O(horrible * size of change) -- yeah, that's what it looks like... :-/
05:50:16 <EvanR> diffarray apparently has performance problems in the current implementation
05:53:33 <whald> my program currently spends 96% of it's time in the addSample function of http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25057#a25057
05:53:51 <whald> i'm not really sure if that's DiffArray's fault
05:55:33 <whald> and the samples being added to the image aren't exactly cheap to come up with
05:55:50 <pastorn> whald: yes, you're doing stuff with the newPixels
05:56:11 <pastorn> whald: consider using STArray for better performance
05:57:06 <whald> what do you mean with "doing stuff with"? i replace a single pixel et voila, that's my new image
05:57:14 <whald> where is the bad coming from?
05:57:29 <pastorn> whald: DiffArray has a difference list
05:57:44 <pastorn> so you are running O(changes_made + 1) for each update
05:58:25 <whald> i thought the "changes_made" comes to the stage only when accessing "old" versions of the array
05:58:47 <pastorn> whald: iirc. the DiffArray was removed from the standard libraries
05:58:51 <pastorn> or something similar
05:58:57 <pastorn> whald: in theory...
05:59:22 <whald> ok, so to get this usable I should go for STArray
05:59:35 <ivanm> graphviz now has a website! \o/ http://projects.haskell.org/graphviz/
05:59:37 <pastorn> that'd be my guess
06:00:01 <pastorn> @type (//)
06:00:02 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
06:00:58 <pastorn> whald: it could be that that might not be your bottleneck
06:01:13 <pastorn> whald: what happends with performance if you remove that 'seq' you have there?
06:02:07 <whald> pastorn: mompl, i'll try
06:03:16 <whald> ?!?! it's MUCH better
06:03:16 <lambdabot>  it's MUCH better
06:03:36 <pastorn> haha
06:03:37 <whald> ~12 % CPU time
06:03:42 <pastorn> awesome :)
06:04:01 <ivanm> is it just me or is projects.haskell.org really, really slow at the moment?
06:04:09 <pastorn> ah, ok... yeah, you don't need to have all of the array evaluated for just computing the next pixel...
06:04:22 <whald> I had a space leak before, and threw in that seq (which was pointless anyway)
06:05:05 <whald> thanks a lot, pastorn, that really helped... :-)
06:05:49 <pastorn> whald: now, please reflect over what your mistake was
06:07:46 <whald> "seq" is O(#pixels)?
06:08:12 <whald> while addsample could be O(1 + (that diff stuff i don't use anyway))?
06:08:22 <pastorn> well, for you it's O(pixels + changes), i'd guess
06:13:17 <fasta> whald, DiffArrays are just a factor of 20 slower than STArrays.
06:13:58 <fasta> whald, ah, never mind. I don't remember whether that is accurate. I think it is even more.
06:13:58 <pastorn> whald: if you ever need to backtrack, just remember a point that you should be able to jump back to and make a copy there
06:14:40 <quicksilver> or, depending exactly what you're doing, consider fingertrees, which exhibit good sharing between old and new
06:15:05 <quicksilver> but have very different constant factors of course.
06:15:58 * Maxdamantus wonders how trivial it'd be to implement something like a BF interpreter without using any of those funny non-recursion-based-stateful features.
06:16:39 <roconnor> what are funny non-recursion-based-stateful features?
06:17:29 <Maxdamantus> I dunno.. I just started learning it yesterday and when I searched on Google people were using tapes or something which appeared to store states
06:17:59 <Maxdamantus> where it = haskell
06:18:53 <pastorn> Maxdamantus: are you talking about turing machines?
06:18:58 <Maxdamantus> Sure.
06:19:47 <Saizan_> well, the evaluation model of BF assumes something like that
06:19:53 <Saizan_> iirc
06:19:57 <Maxdamantus> I think I can think of a crazy way it could be done.. Dunno if people are meant to do as crazy things as I'm thinking though.
06:20:35 <kbp> I call seq (sum [1..50000]) on one machine, all is fine, then call it on other maching and it produces this  warnign http://codepad.org/EEfXNv7X is there any idea how to fix it?
06:21:29 <Saizan_> kbp: give a type signature
06:21:39 <rtaycher> For some reason alge. data types record sytax is throwing these sort of errors hw1.lhs:11:19: Not in scope: `x' hw1.lhs:12:19: Not in scope: `y' hw1.lhs:13:19: Not in scope: `sixnumbers' where these are record field names? any help?
06:21:40 <Maxdamantus> .. where newmem = [m + if ptr == p then inc else 0 | (m, p) <- zip oldmem [0..]]
06:22:12 <Saizan_> kbp: though i'm not sure what's the point of seq (sum [1..50000])
06:22:12 <quicksilver> rtaycher: not unless you show us the code :P
06:22:52 <rtaycher> just that + > data Hex = Hex { x :: Int,
06:23:00 <rtaycher> y :: Int ,
06:23:00 <rtaycher> >                  sixnumbers :: Int Int [Int]
06:23:01 <lambdabot>   Not in scope: `sixnumbers'
06:23:02 <rtaycher> >                } derving (Show)
06:23:03 <lambdabot>   <no location info>: parse error on input `}'
06:23:14 <kbp> Saizan_: im not sure how to give a type signature to a list [1..50000] ... the seq.. something is to make the program delays for a few intervals
06:23:23 <quicksilver> rtaycher: you are trying to type a data type into ghci?
06:23:25 <Axman6> rtaycher: Int Int [Int]? that doesn't make any sense
06:23:32 <quicksilver> rtaycher: oh, fields can only have one type
06:23:56 <Toxaris> I try to use pandoc as a library, but an example from its website doesnt work for me, see http://hpaste.org/view?id=25058
06:24:14 <Saizan_> Maxdamantus: that's not crazy at all, it's normal to just create an updated version like that and pass it to the recursive call
06:24:42 <Toxaris> I get an "openFile: does not exist" error in a pure program!
06:24:45 <Maxdamantus> Oh. Hm.
06:24:50 <rtaycher> stupid of me, (used to be an non record based dta type with Int Int [Int], now seems to work
06:25:05 <Saizan_> kbp: e.g. seq (sum ([1..50000] :: [Int]))
06:27:39 <edwardk_> preflex: xseen cale
06:27:39 <preflex>  cale was last seen on freenode/#haskell 1 day, 12 minutes and 55 seconds ago, saying: (that way when cabal puts stuff there it just gets put in your user bin directory)
06:27:41 <kbp> Saizan_: ok it's fine now :)
06:30:47 <Toxaris> Maxdamantus: for bf, you may consider representing the memory as data Memory = Memory [Int] Int [Int]. The first list is everything to the left of the current position, the middle Int is the data at the current position, and the last [Int] is everything to the right of the current position. this way, you can reuse both [Int] when creating a new Memory with a changed middle Int.
06:36:41 <Saizan_> http://code.haskell.org/~Saizan/BrainFuck.hs <- a very convoluted interpreter
06:36:47 <roconnor> mmm, Memory comonad .... :P
06:36:48 * hackagebot Raincat 1.1.1 - A puzzle game written in Haskell with a cat in lead role  http://hackage.haskell.org/package/Raincat-1.1.1 (MikhailPobolovets)
06:38:03 <Saizan_> i should try to find a use for cobind..
06:39:10 <ivanm> dammit, now that it's been cabalised I have no reason not to try it :(
06:41:12 <fax> Cale?
06:41:22 <ivanm> preflex: xseen Cale
06:41:22 <preflex>  Cale was last seen on freenode/#haskell 1 day, 26 minutes and 38 seconds ago, saying: (that way when cabal puts stuff there it just gets put in your user bin directory)
06:43:04 <fax> "We can describe an algebraic number by writing down the equation it solves, and providing some description to say which root of the equation we're interested in" -- why do we have to pick which one?
06:43:25 <quicksilver> because we want to describe one algebraic number?
06:43:32 <quicksilver> not ambiguously describe several.
06:43:35 <fax> since a lot of people in #haskell reads sigfpe
06:44:56 <fax> well as I see it, if you define a number as 'one of the roots of an algebraic equation' -- any algebraic equation in terms of that root will hold true, no matter which root is chosen
06:45:19 <fax> it's only when you break out the trancendental functions (like, exp, sin, cos..) that you can tell the difference
06:45:28 <fax> but these functions are not in A -> A
06:45:44 <fax> ( http://blog.sigfpe.com/2010/04/on-representing-some-real-numbers.html )
06:46:06 <quicksilver> no, that's not true fax.
06:46:12 <fax> oh! why?
06:46:18 <quicksilver> if I define a number as "some root of x^2 - 1"
06:46:28 <quicksilver> then, tell me, does it satisfy the equation x - 1 = 0 ?
06:46:35 <fax> no it doesn't
06:46:39 <quicksilver> bzzt, wrong
06:46:41 <quicksilver> it does.
06:46:41 <fax> haha
06:46:43 <quicksilver> my number was 1.
06:47:14 <fax> okay I am trained to think (square root of -1) when I see something like x^2 - 1
06:47:22 <quicksilver> this is a very beautiful picture : http://en.wikipedia.org/wiki/File:Algebraicszoom.png
06:47:26 <fax> I should try to be more careful
06:47:35 <quicksilver> -1 has two square roots, by the way.
06:47:38 <fax> yes that picture is really lovely
06:47:48 <mail> this is the story
06:47:56 <mail> all about how my
06:47:57 * benmachine hugs quicksilver 
06:48:03 <mail> life got flip turned upside down
06:48:06 <benmachine> :t flip
06:48:07 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:48:32 <fax> That picture is evidence that the world we live in is just a bit algebraic structure (some philosopher said this.. I didn't make it up)
06:48:53 * hackagebot graphviz 2999.9.0.0 - Graphviz bindings for Haskell.  http://hackage.haskell.org/package/graphviz-2999.9.0.0 (IvanMiljenovic)
06:49:03 <quicksilver> well I'm not quite sure how he drew it - obviously every precise pixel location is rational and hence algebraic.
06:49:10 <fax> another thing I don't get is "Even though there are vastly more algebraic numbers than rational numbers"
06:49:14 <quicksilver> but I'm sure he had his methodology, and it is pretty.
06:49:15 <fax> how is there "more"
06:49:42 <quicksilver> only in the sense that every rational number is algebraic, but not vice versa
06:49:47 <quicksilver> not a very useful sense of 'more'
06:49:47 <fax> I can make nonsurjective functions both ways (only in one direction is it a homomorpism though)
06:49:52 <quicksilver> the cardinalities are the same.
06:49:56 <fax> yeah
06:50:01 <fax> it's a weird notion
06:50:13 <fax> that two sets the same size.. and one is bigger than the other
06:50:25 <fax> maybe he's writing like that for people that don't understand infinity
06:50:34 <quicksilver> more likely he himself doesn't understand :)
06:50:37 <alpounet> ivanm, good job on the new graphviz release
06:50:37 <benmachine> pretty much the definition of infinite is that it fits inside itself isn't it?
06:50:52 <ivanm> thanks alpounet
06:50:53 <quicksilver> not the normal definition in my experience
06:50:56 <quicksilver> but that is a valid one, yes.
06:51:09 <fax> benmachine: that's my justification for sayin I can make non-surjections both ways
06:51:12 <quicksilver> "an infinite set is one which admits a bijection to a proper subset of itself"
06:51:32 <benmachine> yeah
06:52:18 <benmachine> what other definitions are there?
06:52:24 <benmachine> out of interest, slightly oftopic
06:52:51 <EvanR-work> easy
06:52:55 <EvanR-work> a set of infinite if it is not finite
06:53:03 <fax> that's one of my favorite definitions :)
06:53:03 <EvanR-work> s/of/is/
06:53:09 <benmachine> a set is finite if it is not infinite? >_>
06:53:17 <roconnor> quick which definitions of infinite are different if you don't have AC?
06:53:18 <EvanR-work> you can define finite
06:53:22 <fax> infinite = not . finite -- sometimes you can make things simple
06:53:32 <fax> but sometimes that definition is not sufficient
06:53:44 <benmachine> EvanR-work: you can, you can define infinite too, but I'm looking for interesting ways of doing so :P
06:53:44 <quicksilver> benmachine: the natural definition is "a set is infinite if it admits an injection from all finite sets"
06:53:56 <quicksilver> benmachine: where by 'all finite sets' I am referring to the natural numbers
06:54:02 <quicksilver> which is why I call it a natural definition.
06:54:05 <benmachine> heh
06:54:06 <benmachine> okay
06:54:08 <fax> lol
06:54:21 <quicksilver> roconnor: AC only concerns us once we go "past" the countable numbers
06:54:21 <fax> I want to @remember that
06:54:40 <quicksilver> roconnor: the theory of the countably infinite is not affected by AC>
06:54:42 <benmachine> so basically a set that is bigger than any finite set
06:54:54 <fax> @remember quicksilver [on infinity] where by 'all finite sets' I am referring to the natural numbers. which is why I call it a natural definition.
06:54:54 <lambdabot> It is forever etched in my memory.
06:55:02 <benmachine> where finite is presumably of cardinality in N
06:55:21 <quicksilver> benmachine: yes, finite is having cardinality 0 or 1 or 2 or 3 or 4 or ....
06:55:35 <yottis> yes, surprisingly infinity is defined as the lack of finity :)
06:55:46 <EvanR-work> not so surprising!
06:57:00 <EvanR-work> a set if finite if all one to one mappings to N has a max
06:57:12 <yottis> no but it seems that people who start thinking about the concept try to imagine what that infinity is, when you really can't do that, just try to be ok with the fact that it's just bigger than anything that you can put a limit on
06:57:33 <benmachine> EvanR-work: ooh, that one sounds fun
06:57:37 <fax> yottis: linguistically it is not surprising
06:57:50 * ivanm -> land of nod
06:57:53 <benmachine> yottis: you can imagine what infinity is sort of
06:57:55 <ivanm> g'night all
06:57:58 <benmachine> night
06:58:10 <benmachine> just don't try to go, "even bigger than a million"
06:58:39 <yottis> yes and by thinking i meant enumerating :)
06:58:52 <mail> do set theory
06:59:03 <mail> then you learn about size of infinities
06:59:11 <Saizan_> yottis: does "quicksilv : "an infinite set is one which admits a bijection to a proper subset of itself"" fit that?
06:59:13 <mail> that'll do a number on you
06:59:22 <benmachine> mail: did that two terms ago :P
06:59:35 <yottis> yes i know that, i realize enumerating is a poor choice of words here.. more like "listing all the crap in the infinity"
06:59:40 <fax> how could you prove that two non-computable numbers are trancendental over each other?
06:59:53 <benmachine> although we only got to finite/countable/uncountable
07:00:13 <benmachine> beyond that it's just "really really uncountable"?
07:00:20 <fax> like if 0.1110101011... was halting number then 0.3330303033... is not trancendental
07:00:28 <fax> because it's just 3*..
07:01:13 <benmachine> fax: I'd hazard that there's no general way, so you could only do it if there was some information common to their definition
07:01:56 <benmachine> or wait, you mean prove that you *can't* get from one to the other
07:02:08 <EvanR-work> i learned about ordinal numbers the other day, its way more interesting than just size of sets ;)
07:02:30 <EvanR-work> though i dont know the relation between them
07:02:35 <EvanR-work> ordinal / cardinal
07:02:48 <EvanR-work> other than you can enumerate all cardinals with ordinals, given choice
07:03:00 <fax> EvanR; yeah ordinals are amazing
07:03:05 <yottis> i meant enumerable like "enumerable powers" in a constitution.. not the best word in this context :)
07:03:15 <fax> IMO they should teach ordinals and transfinite induction in primary school
07:03:32 <fax> that would make "infinity + 1" a MUCH more interesting game
07:03:36 <EvanR-work> haha
07:04:10 <Saizan_> hah
07:05:26 <EvanR-work> infinity to the infinity power!!!1
07:05:30 <EvanR-work> +1
07:05:42 <benmachine> factorial factorial factorial
07:05:50 <EvanR-work> :o
07:05:54 <EvanR-work> dont go there
07:07:18 <EvanR-work> its interesting 'how infinite' is irrelevant sometimes. like, people compete on naming the 'biggest' natural number, which takes about as much work as naming the biggest countable ordinal, which is 'way less' than uncountable ordinals
07:07:52 <edwardk_> once i understood infinity as a process rather than a number, it largely took the fun out of such games as a child ;)
07:08:11 <xerox> do you know about grossone
07:08:37 <xerox> it's like  non-standard analysis - take 2
07:08:56 <fax> http://www.grossone.com/arithmetic.html ?
07:08:57 <fax> this
07:09:18 <xerox> that guy made a talk in our univ last week
07:09:30 <xerox> (but I couldn't attend, so I just heard about what he said)
07:09:57 <roconnor> @quote calculator
07:09:58 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
07:10:00 <roconnor> @quote calculator
07:10:00 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
07:10:05 <roconnor> @quote StackCalculator
07:10:05 <lambdabot> No quotes match. My mind is going. I can feel it.
07:12:19 <EvanR-work> infinity computer, sounds useful
07:12:37 <EvanR-work> no more pesky finite precision errors ;)
07:12:43 <roconnor> @quote statck-calculator
07:12:43 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
07:13:09 <roconnor> @remember StackCalculator let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
07:13:09 <lambdabot> Okay.
07:13:13 <fax> "It is also conjectured that there is a terminating algorithm for finding such a sequence of operations, or if one doesn't exist, demonstrating this.
07:13:17 <fax> that does not make sense
07:13:19 <roconnor> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
07:13:20 <lambdabot>   5
07:13:25 <roconnor> fax: ^^
07:13:47 <Axman6> :o
07:13:49 <fax> roconnor oh ski showed me this a long time ago, that's neat
07:14:05 <roconnor> vaguely resembles idiom brackets
07:14:16 <Botje> why doesn't it complain that start has 6 arguments?
07:14:31 <quicksilver> because all functions have exactly one argument, Botje
07:14:38 <quicksilver> and start is declared as a function with one argument.
07:14:49 <Axman6> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 1 push 2 push 3 add add end
07:14:49 <fax> it's making very clever use of the type system
07:14:50 <lambdabot>   6
07:14:58 <roconnor> Botje: start returns a function
07:15:09 <Axman6> hmm, rankles is someone from my uni
07:15:19 <roconnor> well, start can return a function, and in this case it does
07:15:44 * Axman6 -> sleep
07:15:45 <Saizan_> no empty expression though.
07:15:56 <Saizan_> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start end
07:15:57 <lambdabot>   Couldn't match expected type `()' against inferred type `(t, t1)'
07:16:04 <roconnor> Botje: this is essentially using continuation passing style, if that helps
07:16:15 <roconnor> Saizan_: ouch
07:16:19 <roconnor> oh
07:16:24 <Botje> i can see that it's using CPS
07:16:24 <roconnor> empty stack means no result ot return
07:16:42 <Botje> but i don't see why it doesn't complain about start getting six arguments
07:17:01 <Saizan_> ?type let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start
07:17:02 <lambdabot> forall t. (() -> t) -> t
07:17:29 <benmachine> ?type let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in (start, push, add, end)
07:17:30 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8. (Num t4) => ((() -> t) -> t, t1 -> t2 -> ((t2, t1) -> t3) -> t3, (t4, (t4, t5)) -> ((t4, t5) -> t6) -> t6, (t7, t8) -> t7)
07:17:33 <benmachine> eep
07:17:39 <Botje> O_o
07:17:55 <quicksilver> Botje: because start returns a function?
07:18:07 <quicksilver> (which takes one argumetn and returns a function, which .....)
07:18:12 <benmachine> Botje: how about
07:18:15 <benmachine> > id id id id id id 4
07:18:16 <lambdabot>   4
07:18:25 <Botje> hmm
07:18:29 <pastorn> wat?
07:18:32 <Botje> i (think) i see
07:18:42 <pastorn> @type id id id id id
07:18:43 <lambdabot> forall a. a -> a
07:18:55 <Botje> that jarred my brain into thinking mode. thanks :)
07:18:55 <EvanR-work> the 'number of arguments' thing trips me up sometimes, compiler says i dont have enough in so many words, but sometimes i have too many and its ok :)
07:19:52 <benmachine> hmm I wonder if I should take my step evaluator idea and build a step typechecker
07:20:04 <EvanR-work> i suppose returning a function isnt that weird, most functions do that, any that 'take more than 1' ;)
07:20:34 <quicksilver> that's why I started off by remarking that all functions take exactly one argument
07:20:43 <benmachine> EvanR-work: yeah but you can get quite far into haskell without working that one out
07:20:48 <quicksilver> but apparently that wasn't quite the right clue required to jar Botje's brain today :)
07:21:01 <fax> Botje, you can have even more fun with this idea if you introduce GADTs
07:21:07 <EvanR-work> benmachine: so whats the type of start above
07:21:31 <quicksilver> data Moar fun where .....
07:21:35 <benmachine> EvanR-work: lambdabot quoted it as (() -> t) -> t
07:21:47 <fax> consider a recursive function f :: T a -> a, where the data type has a consrtuctor with type T (T a -> a)
07:22:16 <EvanR-work> where t can be a function
07:22:25 <benmachine> right
07:22:30 <EvanR-work> tricky business!
07:22:49 <benmachine> certainly :P
07:23:17 <jmcarthur> :t fix id
07:23:18 <lambdabot> forall a. a
07:23:39 <Saizan_> oh, god, i've some code with a gadt named Fun and a constructor Moar, but i don't have a "Moar fun" in it, i shall remedy that
07:24:39 <Saizan_> done.
07:26:07 <quicksilver> Saizan_++
07:26:21 <fax> haha the set of definable numbers is not definable
07:26:29 <fax> what am I reading @_@
07:26:55 <EvanR-work> 'the smallest subset of the reals which are not definable'
07:26:57 <EvanR-work> done
07:27:19 <lpsmith> Yes,  I remember that from real analysis,  but I don't understand all the details
07:27:21 <EvanR-work> i just defined the undefinable definables
07:28:00 <fax> what it is, I am taking exception to is calling D a set
07:28:06 <lpsmith> The problem is that you can't really nail down what "all possible interpretations" of a given string would be
07:29:50 <benmachine> EvanR-work: you've heard the one about the set of sets not containing themselves right >_>
07:30:17 <EvanR-work> yeah
07:31:47 <EvanR-work> cant axiom of choice do some magic here
07:31:57 <Eelis> has anyone ever considered/proposed an extension OverloadedApplication that would let one implement juxtaposition for non-function types? which would permit dubious things like making "m k" mean "lookup k m" when m is a map
07:32:09 <edwardk_> eelis: you can do it without anything fancy
07:32:18 <Eelis> edwardk_: how?
07:33:00 <edwardk_> @hpaste
07:33:00 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:33:13 <lpsmith> moonpatio has been down
07:33:16 <benmachine> http://hpaste.org/
07:33:35 <lpsmith> preflex, seen mmorrow
07:33:36 <preflex>  mmorrow was last seen on #ghc 98 days, 11 hours, 35 minutes and 50 seconds ago, saying: * mmorrow is rtfm'ing
07:33:40 <lpsmith> :-/
07:33:51 <Eelis> big manual
07:33:53 <benmachine> yeah nobody knows where he is
07:34:09 * hackagebot operational 0.2.0.0 - Implement monads by specifying operational semantics.  http://hackage.haskell.org/package/operational-0.2.0.0 (HeinrichApfelmus)
07:34:33 <edwardk_> Eelis: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25059#a25059
07:34:39 <edwardk_> the trick is the rank 2 type for FArray
07:35:01 <edwardk_> it is simultaneously a function and an Array ;)
07:35:42 <Eelis> edwardk_: but that requires you to change the data type, right? you couldn't retrofit it onto, say, Data.Map, could you?
07:35:54 <quicksilver> edwardk_: I didn't know you could do rank 2 type synonyms
07:36:05 <quicksilver> somehow that surprises me
07:36:30 <edwardk_> quicksilver: its the same as mechanically expanding with an explicit forall.
07:36:53 <benmachine> edwardk_: could you use that with a mutable array or similar?
07:37:42 <edwardk_> benmachine: it probably wouldn't be as pretty. it can be used for Map, Array, IntMap, [a], and a few others pretty nicely
07:38:31 <edwardk_> Eelis: you need to at least change how you use the data type, if not the data type itself.
07:38:38 <quicksilver> benmachine: mutable arrays don't have a vlue
07:38:46 <quicksilver> they only have a value at a particular moment in time
07:38:46 <edwardk_> and you often have to inteject 'pick' to force the choice of the non-function rep
07:38:52 <lpsmith> out of curiousity,  I don't suppose anybody ever mirrored moonpatio's hpaste?
07:39:07 <Eelis> edwardk_: right. so the hackishness of this solution is all too clear, and a hypothetical extension might still be worthwhile
07:39:12 <quicksilver> ...which moment you choose by placing them into a monadic action
07:39:16 <edwardk_> Anyone know what happened to mmorrow/moonpatio?
07:39:30 <quicksilver> No; presumably he got busy.
07:39:35 <quicksilver> preflex: seen mmorrow
07:39:35 <preflex>  mmorrow was last seen on #ghc 98 days, 11 hours, 41 minutes and 50 seconds ago, saying: * mmorrow is rtfm'ing
07:39:42 * EvanR-work recalls a previous conversation about arming the server with plastique incase the authorities found you
07:39:53 <edwardk_> Eelis: the problem in this space is that once you show that the existing tools are sufficient, but difficult, everyone shrugs and moves on. Look at OOHaskell ;)
07:44:06 <Eelis> edwardk_: i see. oh well.. :)
07:44:12 * hackagebot regex-pderiv 0.0.7 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pderiv-0.0.7 (KennyLu)
07:44:16 <quicksilver> jmm.
07:44:29 <benmachine> quicksilver: in theory though you could have marray index return IO value
07:44:39 <quicksilver> No mailing list posts or easily googleable footprint of mmorrow since december
07:44:43 <quicksilver> I hope he's OK.
07:44:48 <benmachine> so do we all
07:45:24 <edwardk_> hrmm in light of the existence regex-pderive i should dust off the fox-derivative-based version of my parallel applicative parser combinators and just put it out there
07:45:54 <edwardk_> its a significantly larger class of languages than just regular expressions.
07:46:13 * hackagebot bindings-librrd 0.2 - Low level bindings to RRDtool  http://hackage.haskell.org/package/bindings-librrd-0.2 (MasatakeDaimon)
07:46:39 <benmachine> the whois record for moonpatio has contact details but I guess that would be considered a little intrusive >_>
07:46:56 <xerox> just like a phonebook
07:47:21 <benmachine> well *I'm* not paying international rates :)
07:47:26 <EvanR-work> yesterday i was informed of a way to mess with individual bits of memorys using Ptr, ok, so what kind of performance can we expect from 'loops' that do this sort of thing relative to C
07:58:35 <edwardk_> preflex: xseen sclv
07:58:35 <preflex>  sclv was last seen on freenode/#haskell 9 days, 21 hours, 17 minutes and 21 seconds ago, saying: a two stage pass could do it though -- extract annotations and comments via a custom preprocessr and toss them in as some extra info accessible to the th...
08:16:28 <interferon> for testing purposes is it possible to compare two IO actions? so given like "foo str = putStrLn str" i could do (putStrLn "foo" == foo "foo")
08:16:57 <pastorn> jmcarthur: hello?
08:17:00 <shapr> Is IO an instance of Eq?
08:17:31 <danderson> no, iirc
08:17:35 <danderson> you can't compare two IO a
08:17:41 <danderson> you can execute them, and compare the resulting a
08:17:43 <uorygl> As far as I know, IO actions are very incomparable.
08:17:45 <danderson> but that's not what you wanted
08:18:08 <shapr> interferon: On the other hand, if whatever you've used to construct the IO actions is comparable, then you could do it ahead of time.
08:18:11 <danderson> wouldn't comparing IO actions be a restatement of the halting problem?
08:18:44 <danderson> assuming you don't just want to check for strict equality of implementation, but equality of side-effects and result
08:18:52 <interferon> shapr: that's true, but sometimes i'd like to say, given these input arguments, the following sequence of actions should occur
08:19:04 <shapr> interferon: Can you give me an example?
08:19:41 <FliPPeh_> Someone experienced in Gtk2HS? I'm currently writing every program with GUI in the same style, passing every function that needs GUI widgets a record "GUI" which includes all my widget objects.. this leads to raather unclean constructs like "entryGetText (fldSelectedEntry . guiFolderChoose $ gui)".
08:19:43 <interferon> not really, i'm just thinking about how i'd test IO-heavy parts of a haskell application
08:19:51 <FliPPeh_> Is there a better way?
08:20:14 <FliPPeh_> Strike that question, what IS the better way?
08:20:17 <danderson> interferon: since IO can perform arbitrary side-effects, feeding the same input doesn't guarantee identical output
08:20:20 <danderson> that's the whole bane of IO
08:20:31 <interferon> danderson: understood
08:20:34 <shapr> interferon: My approach is to have as much of the logic/code/etc in pure code, and as little as possible in IO.
08:20:35 <danderson> afaik, the only sane way of testing IO actions is to perform them
08:20:40 <danderson> and check that the result is what you expected
08:20:47 <interferon> i'm trying to see if the same chain of actions is built up
08:20:50 <danderson> and then separately check for any side-effects you expected
08:20:55 <interferon> shapr: true, that's what i do now
08:20:58 <ccasin> FliPPeh_: that's how I do it, though I can't speak for others.  Sometimes I break them up into smaller bits if there are logical grouping that make sense
08:20:59 <jmcarthur> pastorn: what's up?
08:21:00 <interferon> shapr: just curious
08:21:16 <shapr> interferon: There's QuickCheckM, but I've never gotten it to work right.
08:21:28 <FliPPeh_> ccasin: Yes, that's what I'm doing too. My big fat "GUI" type includes a smaller "FolderChoose" for a folder choosing dialog
08:21:28 <interferon> yeah it's pretty hard to find examples of it
08:21:33 <shapr> interferon: And QuickCheckM works as danderson describes, run it and check the result.
08:21:40 <interferon> ah
08:21:42 <pastorn> i was going to ask you some GL stuff, but i think it solved itself...
08:21:51 <jmcarthur> pastorn: ah, okay
08:21:55 <danderson> interferon: my gut feeling is that unless you have a pure module that builds an IR of actions, and then a separate "code generator" which converts that IR into IO actions, it doesn't seem possible.
08:22:05 <interferon> IR?
08:22:14 <ccasin> FliPPeh_: I also often get stuck using references here, because the various different parts of my code might need to modify things in this record
08:22:15 <shapr> intermediate representation?
08:22:25 <pastorn> jmcarthur: oh, one thing
08:22:34 <danderson> interferon: intermediate representation
08:22:36 <shapr> jmcarthur: Are you doing OpenGL tutorials? :-)
08:22:40 <danderson> essentially, build an IO action compiler
08:22:47 <pastorn> how do you push a matrix (with uniform) to the gfx card properly?
08:22:59 <danderson> instead of going directly from inputs to IO actions, you'd go from inputs to some intermediate pure representation of what you want to do
08:23:11 <danderson> and then have a separate module that converts that representation into IO actions
08:23:21 <shapr> edwardk: Hey, do you have a blog post about the lattice of linear/unique/etc? Like the talks you've given to me?
08:23:30 <pastorn> should it be 'array [r0c0, r0c1, r0c2, ... , r3c2, r3c3] >>= uniformv' ?
08:23:46 <pastorn> or should i flip r and c?
08:24:07 <danderson> you still have the same problem to test the Repr -> IO part of it, but it should reduce the surface to test from "does my complex function generate the same AST?" to "Does this intermediate representation object always convert to an IO action that does what I expect?"
08:24:33 <danderson> that said, it would be very annoying to write such code, the extra indirection is very clunky.
08:24:49 <shapr> On the other hand, it's not as clunky as a sudden segfault in your C code.
08:24:52 <jmcarthur> pastorn: i actually do not know at all. i'm no opengl expert ;)
08:25:00 <jmcarthur> shapr: nope
08:25:09 <danderson> so unless there is really a huge clear benefit in doing so, I'd just go with QuickCheckM and try to lift as much as possible into pure, QuickCheckable code
08:25:20 <EvanR-work> file command reports haskell source as java
08:25:49 <jmcarthur> pastorn: i think ogl likes column-major matrices, though i might be wrong. you'll want to check the spec
08:26:11 <bastl> Are there some common code-conventions? something i can link to ?
08:26:22 <gwern> EvanR-work: probably going off the caps
08:26:51 <gwern> EvanR-work: maybe we could suggest some heuristics - '::' is an unusual haskellism
08:27:59 <EvanR-work> the first few lines of a file are usually import
08:28:00 * shapr hugs gwern 
08:28:03 <EvanR-work> looks like java
08:28:12 <aavogt> http://urchin.earth.li/~ian/style/haskell.html
08:29:04 <gwern> EvanR-work: or 'module'
08:29:45 <gwern> perhaps we could point out that java imports end in semicolons, and haskell imports never do
08:30:25 * gwern wonders where to file a bug for a coreutil like file
08:30:51 <shapr> I think you'd only need to file patch to the file magic.
08:30:56 <benmachine> imports can end in semicolons
08:30:58 <ClaudiusMaximus> pastorn: the C API has a bool argument whether to transpose the matrix or not (not sure if it's exposed in hopengl though)
08:30:59 <aavogt> haskell imports may end in semicolons
08:31:13 <benmachine> they don't usually though
08:31:28 <EvanR-work> gwern: gotta track down RMS
08:31:34 <pastorn> ClaudiusMaximus: found it in the GLSL spec; uniform mat4 gl_ModelViewMatrix;
08:31:36 <gwern> benmachine: what
08:31:36 <pastorn> uniform mat4 gl_ProjectionMatrix;
08:31:42 <pastorn> built-in stuff :)
08:31:52 <quicksilver> deprecated stuff.
08:31:59 <benmachine> gwern: it's usually done by layout, but you can fit an entire file on one line if you like
08:32:06 <gwern> bleh
08:32:07 <pastorn> quicksilver: YOU'RE deprecated
08:32:09 <benmachine> :)
08:32:17 <quicksilver> >
08:32:18 <quicksilver> ?
08:32:20 <shapr> http://www.darwinsys.com/file/
08:32:38 <jmcarthur> pastorn: yeah, you should use the programmable pipeline
08:32:54 <jmcarthur> err
08:32:57 <jmcarthur> i misread things
08:32:58 <jmcarthur> nevermind
08:33:15 <gwern> I deprecate your mother for being loose
08:33:16 <jmcarthur> you should do the matrix math yourself, i mean ;)
08:33:57 <pastorn> quicksilver: until there's a proper matrix type in the OpenGL bindings i'll use the matrix stack
08:34:10 <pastorn> (proper = has an instance of Uniform)
08:34:58 <dmead> hi channel
08:34:59 <dmead> i luuuv you
08:35:26 <uorygl> Hi, dmead.
08:35:28 <benmachine> @vixen do you love dmead
08:35:28 <lambdabot> i wouldn't say i do love...
08:35:44 <dmead> :/
08:35:52 <dmead> brent?
08:35:55 <benmachine> can't win 'em all
08:36:11 <gwern> > 51309 + 39078
08:36:12 <lambdabot>   90387
08:36:23 <aavogt> > 1234 + 4321
08:36:24 <lambdabot>   5555
08:36:46 <benmachine> > let n = 1000 in (1 + recip n) ** n
08:36:47 <lambdabot>   2.7169239322355936
08:37:00 <burp> > exp 1
08:37:01 <lambdabot>   2.718281828459045
08:37:07 <benmachine> cheater >_>
08:38:00 <fax> gwern what are you calculating?!
08:38:07 <gwern> fax: my wikipedia edit count
08:38:10 <fax> benmachine... I wonder how that works
08:38:12 <dmead> strassen's algorithm?
08:38:15 * benmachine wonders what the "optimal n" is for that, before underflow screws it completely
08:38:17 <fax> gwern oh okay
08:38:20 <dmead> thats O(2.7somethingsomething)
08:39:47 <bastl> aavogt: that link was nice, is there more like that? especially how to break lines (long lists, type signatures etc.)
08:40:03 <benmachine> fax: I dunno but I guess you could try to prove that n log (1 + recip n) -> 1 as n -> inf
08:40:04 <fax> > let e n = (1 + recip n) ** n ; what (x:y:ys) = if x == y then what (y:ys) else (x,y) in what $ map (take 4 . show . e) [1000..]
08:40:08 <lambdabot>   mueval-core: Time limit exceeded
08:40:25 <fax> benmachine, ah of course! That should do it
08:40:30 <aavogt> bastl: I don't think that there is much consistency across projects with respect to those things
08:43:08 --- mode: bartol.freenode.net set +o ChanServ
08:43:12 <bastl> ok, means for me: nothing to refer to
08:43:12 <aavogt> existing code?
08:43:20 <aavogt> there might be something on the haskell wiki
08:43:40 <monochrom> good code looks like plain text files
08:44:14 <fax> > let e n = (1 + recip n) ** n in e 100000000000000
08:44:15 <lambdabot>   2.716110034087023
08:44:16 <fax> > let e n = (1 + recip n) ** n in e 500000000000000
08:44:17 <lambdabot>   2.7161100340870337
08:44:19 <fax> > let e n = (1 + recip n) ** n in e 800000000000000
08:44:20 <lambdabot>   2.9032015291838533
08:44:28 <fax> benmachine, it starts to break around here
08:44:41 <benmachine> neat
08:44:54 <benmachine> so we don't seem able to get better than 2.716
08:45:03 <aavogt> > exp 1
08:45:04 <lambdabot>   2.718281828459045
08:45:10 <benmachine> apart from like that :P
08:45:12 <fax> I thought it would break suddenly, but it actually breaks smoothly -- which I found interesting
08:45:27 <fax> if I had a program that makes graphs... I would graph it :/
08:45:37 <benmachine> fax: I imagine what happens is that there is some value of n after which recip n stops changing
08:45:43 <fax> plots*
08:45:55 <benmachine> or stops being accurate
08:46:14 <EvanR-work> :t (**)
08:46:16 <lambdabot> forall a. (Floating a) => a -> a -> a
08:46:22 <quicksilver> well, there is a value after which 1 + recip n == 1 (as Double) but you havent got there yet
08:46:33 <quicksilver> so it's not that.
08:46:51 <benmachine> > let n = 800000000000000 in n * recip n
08:46:52 <lambdabot>   1.0
08:47:07 * benmachine shrugs
08:47:09 <quicksilver> > let e n = (1 + recip n) ** n in e 800000000000000 :: CReal
08:47:10 <lambdabot>   2.7182818284590435364341446844513370837829
08:47:23 <monochrom> > let n = 800000000000000 in n * recip n == 1
08:47:24 <lambdabot>   True
08:47:28 <fax> > exp 1 :: CReal
08:47:29 <lambdabot>   2.7182818284590452353602874713526624977572
08:47:42 <fax> > length "2.71828182845904"
08:47:43 <lambdabot>   16
08:47:48 <benmachine> 14 dp
08:47:49 <fax> > log 800000000000000 / log 2
08:47:49 <lambdabot>   49.50699332842307
08:47:53 <fax> > log 800000000000000
08:47:54 <lambdabot>   34.315632843596475
08:47:59 <fax> I wonder why it's 16
08:48:16 <fax> > log 800000000000000 / log 10
08:48:17 <lambdabot>   14.903089986991942
08:48:34 <fax> > log 5000000 / log 10
08:48:35 <lambdabot>   6.698970004336019
08:48:46 <fax> > let e n = (1 + recip n) ** n in e 5000000 :: CReal
08:48:47 <lambdabot>   2.718281556630912224613105033267966512444
08:49:18 <fax> it seems to be the log base 10 which tells how many places this expression is correct to
08:49:50 <benmachine> that's quite neat
08:49:58 <fax> I wonder if it's true!
08:50:01 <benmachine> heh
08:50:03 <benmachine> there is that
08:51:41 <bastl> how would I deploy cabalized CGI scripts to a webserver's cgi-bin ? Can I use cabal-install for that ?
08:58:24 <DigitalKiwi> http://www.haskell.org/~pairwise/intro/intro.html opinions on this?
08:59:16 <EvanR-work> haha Part I: Where are the 'for' loops?
09:00:34 <Philonous1> I have an inifnite list (via cycle aFiniteList) stored in an IORef and I'm repeatedly reading it, dropping elements and writing the tail back to the ref. I'm not doing anything else but the CPU load steadily rises to 100%, what's going wrong there?
09:01:01 <EvanR-work> you can code C is any language ;) forM_ [2,5..24] $ \i -> do
09:01:18 <benmachine> Philonous1: you're appending to an infinite list? interesting :P
09:01:32 <benmachine> Philonous1: and why shouldn't the CPU do that as fast as it can?
09:01:52 <EvanR-work> doesnt sound like hes appending
09:01:54 <benmachine> oh
09:01:55 <benmachine> yeah
09:01:57 <Philonous1> benmachine: I'm not appending to an infinite list
09:01:58 <benmachine> writing the tail, right
09:02:07 <Botje> Philonous1: won't the list still reference the original list?
09:02:23 <Botje> thus preventing it from being collected?
09:02:26 <benmachine> why would you be surprised that it's using lots of CPU
09:02:30 <EvanR-work> unless there is blocking i/o or threadDelay, the cpu will be 100%
09:02:39 <Philonous1> benmachine: Well, that happens in a callback that is only called when jack needs more data
09:03:12 <benmachine> Philonous1: maybe jack is needing more data more often than you expected?
09:03:20 <benmachine> (who the hell is jack anyways)
09:03:25 <EvanR-work> you dont know jack
09:03:30 <benmachine> is he really demanding
09:04:03 <gwern> EvanR-work: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=499328
09:04:04 <Philonous1> benmachine: No, than CPU load would skyrocket and not increase steadily. I'd be surprised if Jack slowly increses it's frame rate
09:04:50 <EvanR-work> gwern: haha. nice ;)
09:04:51 <benmachine> Philonous1: is the finite list pretty long?
09:05:55 <benmachine> I could just about imagine that the first time through the finite list it has to allocate, but that eventually it stores the whole infinite list in memory (as a cyclic structure ofc) and then that's faster
09:05:58 <Philonous1> 48k elements
09:05:59 <benmachine> @src cycle
09:05:59 <lambdabot> cycle [] = undefined
09:05:59 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:06:01 <ido> :t (!)
09:06:02 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
09:06:05 <ido> :i (!)
09:06:17 <gwern> EvanR-work: more liike :(, 2 years and nothing
09:06:17 <ido> @src (!)
09:06:17 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
09:06:31 <ido> @src !
09:06:31 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
09:06:33 <EvanR-work> gwern: ah didnt see the date
09:06:35 <ido> hrm.
09:06:36 <benmachine> so you get let xs' = xs ++ xs' in xs', and then the first time through the list you need to expand out the ++
09:06:37 <ido> odd.
09:06:43 <gwern> EvanR-work: or the person :)
09:06:53 <benmachine> but subsequently it's just let xs' = 1 : 2 : 3 : whatever : xs' in xs'
09:07:16 <benmachine> why am I talking about this like I have any clue what I'm talking about
09:07:32 <benmachine> well what I said is true but I have no idea how much effect it has
09:08:27 <EvanR-work> i was very curious to see how haskell performs in conjunction with audio processing / synthesis
09:08:34 <Philonous1> benmachine: Come to think of it, ++ gets more expensive as the length of the list increases. That would explain why cycle is a very bad idea.
09:08:44 <benmachine> Philonous1: uhh, not really
09:08:44 <EvanR-work> jack in particular, having real time constraints
09:09:00 <benmachine> Philonous1: cycle creates a self-referential structure
09:09:01 <quicksilver> no, it's fine because the ++ is right associating.
09:09:06 <benmachine> also that
09:09:12 <quicksilver> > 1/48000
09:09:13 <lambdabot>   2.0833333333333333e-5
09:09:18 <quicksilver> 20 ms, right?
09:09:24 <quicksilver> no no, 20 us
09:09:43 <quicksilver> shouldn't be too tough to access an element once every 20 us
09:09:54 <quicksilver> you'd need to do more work to find out where the problem is though.
09:10:07 <fax> gwern?
09:10:16 <gwern> fax?
09:10:17 <fax> what's your opinion on the wording here http://en.wikipedia.org/wiki/Blum%27s_speedup_theorem ?
09:10:19 <Philonous1> quicksilver: The first 10 seconds my CPU load is about 1%, but it steadily climbs. So the problem can't be performance per se.
09:10:21 <fax> "'s speedup theorem states that for any complexity measure there are computable functions which have no smallest program."
09:10:47 <fax> gwern, I gather when it says 'smallest program' it doesn't mean in terms of program size, but some /other/measurement of the program
09:11:16 <gwern> smallest program?
09:11:29 <fax> gwern yeah
09:12:07 <gwern> fax: from the previous sentence, I'd guess small here means 'low complexity'
09:12:34 <mamalujo> hi! I was reading this way of making a class-parametrized class: http://okmij.org/ftp/Haskell/PeanoArithm.lhs
09:12:58 <fax> gwern, I misunderstood it when I read it :(
09:13:11 <mamalujo> how would the class Registry look like written w type families?
09:15:06 <quicksilver> Philonous1: well it's possible you failed to make the list cyclic, or you performed an operation which uncyclic-ed it.
09:15:11 <quicksilver> Philonous1: and you are holding onto the head of it.
09:15:22 <quicksilver> Philonous1: note that, if xs is cyclic, map (+1) xs is *not* cyclic.
09:16:11 <Philonous1> quicksilver: But 'drop 10 xs' still is ?
09:17:07 <aavogt> mamalujo: overlapping type families aren't allowed
09:17:32 <jkramer> Hi
09:18:23 <jkramer> Is there a syntax for "casting" read inline? Like for this example: main = getArgs >>= mapM_ (print . read)
09:18:34 <jkramer> Say I want read to read ints from args
09:18:44 <jkramer> How do I do that without a help function?
09:18:48 <aavogt> but you could write: class Registry clas a b c | clas a b -> c
09:18:59 <benmachine> jkramer: (read :: String -> Integer) ought to do the trick
09:19:14 <Philonous1> quicksilver: Curiousl. I tried it again to see of it leaks Ram (which it should When I hold on to the head), and suddenly it behaves.
09:19:18 <benmachine> :t show . (read :: String -> Bool)
09:19:19 <lambdabot> String -> String
09:19:19 <aavogt> class Registry clas a b where type C clas a b :: *
09:19:36 <jkramer> benmachine: Sweet, thanks
09:19:40 <aavogt> mamalujo: that would be the translation for that FD
09:20:21 <aavogt> @src asTypeOf
09:20:21 <lambdabot> asTypeOf = const
09:20:36 <aavogt> that's a convenient function for fixing types
09:20:40 <aavogt> @type asTypeOf
09:20:41 <mamalujo> aavogt: what would be the translation of instance Mul a b c => Registry RegMul a b c
09:20:41 <lambdabot> forall a. a -> a -> a
09:21:12 <aavogt> mamalujo: presumably Mul would have it's last parameter be an associated type too
09:21:12 <gwern> hm. what operators besides :: would java not have...
09:21:22 <aavogt> well even without that:
09:21:26 <gwern> @hoogle (>>=)
09:21:28 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:21:29 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:21:29 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:21:41 <mamalujo> given theres no type var c in the translation, how would one link Mul's c and Registry's c??
09:21:58 <aavogt>   instance (Mul a b c, C a b ~ c) => Registry RegMul a b
09:22:07 <mamalujo> aha
09:22:11 <gwern> weird. there's a surprising number of users of ; with import statements
09:22:31 <aavogt> gwern: looking for certain keywords?
09:22:45 <gwern> hlint, ddc, jhc,  open-witnesses, nobench, buddha, cabal, langage-c
09:22:56 <gwern> bnfc
09:22:59 <aavogt> hmm, cabal?
09:23:07 <mamalujo> thx!
09:23:09 <gwern> yeah, ./cabal/tests/systemTests/wash2hs/hs/WASHGenerator.hs:import Data.List;
09:23:11 <aavogt> I don't recall seeing that
09:23:25 <aavogt> right, only in the tests somebody contributed
09:24:18 <gwern> protocol-buffers, lhc, hera...
09:24:19 <aavogt> mamalujo: I don't think you can translate the whole of that article from FDs though
09:24:40 <Lemmih> gwern: lhc?
09:24:45 <gwern> yeah
09:24:50 <gwern> ./lhc/src/LhcMain.hs:import Data.Time; import Text.Printf
09:24:53 <gwern> eg
09:25:00 <mamalujo> I thought fd and tf were equivalent, or the latter even being more permissive?
09:25:01 <Lemmih> Oh.
09:25:17 <aavogt> FDs are closed, TF are open
09:25:22 <mamalujo> oh
09:25:32 <aavogt> so FDs are 'safe' to allow overlap
09:25:55 <mamalujo> so, we avait total type families being introduced for such translations?
09:26:27 <aavogt> I dunno, maybe it can be done
09:26:34 <gwern> Lemmih: plus a bunch of files apparently from jhc
09:26:47 <aavogt> I'm not an expert
09:29:03 <edwardk_> FDs _can_ be closed
09:29:03 <mamalujo> is there a browser based haskell console that supports recent ghc extensions - my distro is fairly old, and while I'll compile the platform these days, that takes much time if memory serves me
09:29:27 <edwardk_> well, we've historically allowed overlap for them
09:30:37 <edwardk_> aavogt: overlapping fundeps can just get you the wrong dictionary. overlapping type families get you the wrong type. in the former case you may not have confluence you expected but the types all line up.
09:30:43 <edwardk_> in the latter case you can unsafeCoerce
09:32:35 <edwardk_> and you currently can't do everything with a type/data families that you can do with MPTCs and fundeps (or vice versa)
09:32:45 <_radarsat1> if someone has a second, i'm trying to figure out how to compile pandoc from git, getting this problem: http://pastebin.com/0jbxTJUk  --how do i tell it to find my cabal-installed libraries?
09:32:57 <aavogt> edwardk_: but can you do the calculations like here with TFs http://okmij.org/ftp/Haskell/PeanoArithm.lhs  ?
09:33:22 <aavogt> _radarsat1: pass the --user flag
09:33:41 <_radarsat1> thanks!
09:33:41 <aavogt> better-yet, just run cabal install in the repo
09:33:46 <edwardk_> the heart of that article is the reversible Sum
09:34:01 <edwardk_> that is where MPTCs shine over type families
09:34:13 <aavogt> so to have a 3 parameter typeclass with two degrees of freedom
09:34:33 <edwardk_> you can wind up with an exponential explosion in the amount of code you write trying to use that with type families ;)
09:34:52 <_radarsat1> works, thanks, didn't realise it wouldn't default to user config
09:35:11 <edwardk_> more telling is to look at the HList internals and try the same thing
09:35:20 <edwardk_> you run into a number of problems
09:35:33 <mamalujo> edwardk_ what fascinates me most in that article is basically making classes first class entities, by the correspondance of RepMul type and Mul class
09:35:52 <mamalujo> by the Regisry class and it's instances
09:35:57 <gwern> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=499328
09:36:07 <gwern> EvanR-work: ^
09:36:09 <edwardk_> first class HBool t; instance HBool HTrue; instance HBool HFalse; class (HBool a, HBool b, HBool c) => HAnd a b c --
09:36:21 <edwardk_> even that very simple line says something you can't say with type families readily
09:36:55 <edwardk_> er HAnd a b c | a b -> c
09:37:02 <EvanR-work> gwern: yes
09:37:10 <EvanR-work> what am i supposed to notice
09:37:12 <aavogt> that one isn't reversible though
09:37:12 <edwardk_> that is that while HAnd is a function, you can effectively specify its domain and range.
09:37:17 <edwardk_> aavogt: sure
09:37:29 <edwardk_> my point is the instance constraints don't map cleanly
09:37:37 <gwern> EvanR-work: my submission
09:37:40 <edwardk_> so when you make that into a type family you need a class associated type
09:37:46 <EvanR-work> ah
09:37:55 <gwern> the idea being you could criqtie if and fix any errors I made or suggest even better heuristics
09:37:58 <aavogt> I mean if you have an constraint      HAnd HTrue a HTrue, you can't calculate  a ~ HTrue
09:38:18 <edwardk_> class (HBool a, HBool b, HBool (HAndT a b)) => HAnd a b where type HAndT a b :: *
09:38:37 <edwardk_> so now you have two names, and to USE HAnd, you have to mention both the class AND the type family.
09:38:47 <edwardk_> which turns into a notational mess
09:39:08 <edwardk_> so to effectively leverage type families for that type of function you drop the HBool constraints.
09:39:46 <aavogt> edwardk_: on the other hand, applying type functions instead of adding additional constraints sort of cleans up the type variable soup
09:39:50 <edwardk_> but then you lose the ability to effectively 'incrementally type check' your type family code, and just get some huge horrific error message if you ever use one of the bad instances that you defined somewhere else in yoru code
09:40:33 <edwardk_> aavogt: sure. my point is there is a clear trade-off. you are giving up that incrementality and putting all such checking off to the usage site.
09:40:50 <aavogt> or is that not really the case when you must specify that some types are equal?
09:41:28 <edwardk_> there isn't any good place to dangle such equality constraints
09:42:30 <edwardk_> and we saw above, that trying to mix both leads to repetitive messes like: hAnd :: And a b => a -> b -> AndT a b; hAnd = undefined
09:43:20 <edwardk_> i love type families when i can make them fit
09:43:47 <edwardk_> especially when 90% of the class doesn't care about the superfluous parameter.
09:44:12 <fasta> Type families make me think of C++, which is never a good thing.
09:44:13 <FunctorSalad> does anyone know why the haskell shell is dead apparently? seems like an interesting plan
09:44:17 <mamalujo> but, this paper makes some fairly strong claims about their equivalence: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.86.3059&rep=rep1&type=pdf
09:44:20 <edwardk_> i.e. having a closed cartesian category which knows its product type, exponential type, and what the identity is for its product type
09:44:24 <FunctorSalad> (hashell)
09:44:33 <FunctorSalad> (I'm sick of bash :p)
09:44:39 <shapr> zsh?
09:44:53 <edwardk_> CCC k => is way nicer to say than CCC k p h i => when 90% of your code doesn't care about p h or i
09:45:02 <edwardk_> er at least one of
09:45:05 <FunctorSalad> shapr: hmm, is it worthwhile to learn yet another lang instead of trying to do things in e.g. haskell?
09:45:10 <ksf> uniform sphere tesselation?
09:45:11 <gwern> FunctorSalad: there are several haskell shells or libraries if you want to get started with that...
09:45:24 <shapr> FunctorSalad: Um, I dunno.
09:45:27 <ksf> I've got the nasty feeling that I'd need geometry with pi sides for that...
09:45:32 <FunctorSalad> gwern: I see you're the uploader of hashell, but maintainer is 'none' :(
09:45:44 <gwern> FunctorSalad: I just packaged it, don't look at me
09:46:01 <FunctorSalad> gwern: oh, the frown wasn't directed at you, just at the dead project
09:46:57 <mamalujo> 'we claim that every program involving fd can be re-expressed to one using type families ..' and they give two translation schemas..
09:47:39 <mamalujo> they dont offer proofs..
09:47:57 <edwardk_> mamalujo: there are a lot of extensions: overlapping instances, incoherent instances, etc. that are far more damning when used with type families
09:48:00 <ksf> type families are turing complete with -XUndecidableInstances
09:49:01 <gwern>  108. Whenever two programmers meet to criticize their programs, both are silent.
09:49:06 <FunctorSalad> ghci with libraries seem close enough to a shell already. just need a little briefer syntax for very common things, maybe
09:49:30 <mamalujo> hm. I guess so, I think I stumbled upon a code snippet for I think 6.10 that used newtype and type families that made the compiler segfault or something..
09:49:32 <edwardk_> mamalujo: sadly some of those are quite useful in practice in the fundep world: i.e. TypeEq uses a lot of black magic
09:49:44 <FunctorSalad> (but mixing language and strings as bash does is taking it too far, I think)
09:50:01 <edwardk_> mamalujo: yeah we came up with a few when mucking around with the unboxed-containers lib
09:50:08 <FunctorSalad> maybe some convenient monads for tasks like modifying a string stream...
09:50:45 <edwardk_> FunctorSalad: and a way to repurpose pipe so the rest of the world sees it as a shell ;)
09:50:46 <FunctorSalad> (maybe there is one and I don't see it :) ParsecT (Writer [String])?
09:50:47 <FunctorSalad> )
09:51:46 <FunctorSalad> edwardk_: hmm why is that necessary?
09:51:57 <FunctorSalad> *naive*
09:52:17 <cjay> is there a way to tell cabal install to not delete the temporary files after a build failure?
09:52:29 <edwardk_> functorsalad: you can always go and define an oleg RMonad-like RArrow and use that to define your processes
09:53:11 <FunctorSalad> edwardk_: does oleg use that name as in the rmonad package?
09:53:15 <FunctorSalad> ("restricted")
09:53:34 <edwardk_> one of the first things i beat myself bloody on in haskell was understanding arrows and if pipes could me made arrows, but the need for some kind of Read/Show constraint on the args stops it
09:53:42 <ksf> is that an IxMonad with only one index?
09:53:49 <ksf> I think I saw it some time or the other
09:53:57 <nispaur> ohai
09:54:12 <edwardk_> he called them MN2 and MN3 in his inimitably obtuse style ;)
09:54:25 <edwardk_> but he did call them 'restricted monads'
09:54:34 <monochrom> "monad encounter of the 3rd kind"
09:54:44 <FunctorSalad> edwardk_: ok, so it's "restricted" too... are we talking about interoperability to the outside world or to other RArrows?
09:54:46 <edwardk_> http://okmij.org/ftp/Haskell/RestrictedMonad.lhs
09:55:07 <FunctorSalad> edwardk_: maybe he even came up with the term and someone else just packaged it as rmonad, dunno
09:55:12 <edwardk_> FunctorSalad: outside world. modeling pipes as arrow-like constructions so you can use the >>>, etc. sugar
09:55:27 <FunctorSalad> http://hackage.haskell.org/package/rmonad
09:55:53 <edwardk_> FunctorSalad: rmonad is definitely just Ganesh packaging his ideas and making the obvious generalizations
09:56:41 <FunctorSalad> edwardk_: hmm why would you need sophisticated types for the outside world, rather than just String -> IO String (or something with more explicit streaming rather than lazy IO)
09:57:04 <FunctorSalad> (and add argz and stderr to that)
09:57:30 <FunctorSalad> the interface to the outside world is pretty much fixed to that, I thought
09:58:05 <edwardk_> FunctorSalad: because this way you can type check your pipes, that you're generating content the other pipe can accept when possible.
09:58:29 <edwardk_> since you can use it both internally and externally that way
09:59:08 <FunctorSalad> edwardk_: but only if the other program is haskell too? (or something that recognizes the same types in the string representation)
09:59:33 <FunctorSalad> hmm if the toplevel is haskell I can see that becoming more important
09:59:44 <FunctorSalad> I was still thinking of "bash toplevel, invoking haskell parts" here :)
10:00:09 <edwardk_> FunctorSalad: the idea at the time was you could write a nice little body using arrow sugar, etc and compose little haskell and external processes that once you start the task all run in parallel feeding each other data
10:00:41 <edwardk_> nowadays the CHP guys are around so its a bit less novel ;)
10:00:43 <FunctorSalad> edwardk_: HSH does the convenient-mixing part, but without arrows
10:00:55 <edwardk_> *nods*
10:00:59 <FunctorSalad> (just types like (String -> String), (String -> IO String) etc)
10:01:08 <edwardk_> like i said, it was one of the first things i beat myself bloody on in haskell ;)
10:01:15 <FunctorSalad> oh
10:01:22 <edwardk_> not necessarily that it was the best idea
10:01:49 <FunctorSalad> before becoming aware that you need constrained arrows?
10:01:57 <FunctorSalad> (for read/show)
10:02:50 <FunctorSalad> ksf: IIRC the index is inert in IxMonad?
10:03:01 <edwardk_> yeah
10:03:20 <FunctorSalad> ksf: in rmonad, the "constraints" type is actually a type that proves that the argument type is Read/Show/whatever
10:03:22 <m_> That might be irrelevant, but can someone help me with setting up haskell-font-lock-symbols for haskell-mode for emacs?
10:03:25 <ksf> ...well, having only one index would require withXXX functions to change it
10:04:08 <edwardk_> ksf: in category-extras i have PMonads and IxMonads PMonads have one arg, (though not where you expect, for various fixpoint reasons) IxMonads have 2.
10:04:14 <FunctorSalad> (which is a bit annoying since you have to write out the case statement whenever you want the dictionary)
10:04:23 <edwardk_> er one extra arg, and 2 extra args respectively
10:04:43 <FunctorSalad> (the "proving" is by means of gadt pattern match)
10:05:17 <edwardk_> i rather like the way rmonad works, its pretty clean given how horrible its underlying goal is ;)
10:05:19 <FunctorSalad> I sometimes tried to make a fold function to shorten that pattern match, but usually ghc will require explicit annotations then, so you gain nothing
10:06:42 <ksf> haskell mutiprocess support isn't as much fun as it could be
10:07:04 <FunctorSalad> like "foldIsShow :: IsShow A -> A -> (forall a. Show a => a -> r) -> r"
10:07:06 <ksf> largely due to not being able to send functional values
10:07:26 <FunctorSalad> data IsShow a where IsShow :: Show a => IsShow a
10:07:30 <FunctorSalad> maybe I messed that up
10:07:54 <FliPPeh_> Am I crazy for doing a task that was given to us to be implemented in VB-Script in Haskell?
10:08:00 <FliPPeh_> :)
10:08:42 <FliPPeh_> My teacher doesn't even understand haskell as far as I know...
10:08:48 <FunctorSalad> you can stengthen it to "foldIsShow :: IsShow A -> A -> (forall a. (a ~ A, Show a) => a -> r) -> r", even
10:08:52 <fax> not crazy just pointles
10:08:53 <FliPPeh_> He'll have fun trying to figure it out :)
10:09:03 <fax> unless you do it polyglot
10:09:07 <FliPPeh_> fax: I can't do it in VBS, because I don't HAVE VBS!
10:09:11 <FliPPeh_> <- Linux
10:09:11 <FunctorSalad> edwardk_: how's the goal horrible?
10:09:14 <fax> ah
10:09:15 <EvanR-work> ksf: Chan (a -> b -> c) ;)
10:09:22 <FunctorSalad> edwardk_: seems like the goal is to have subcats of hask, more or less
10:09:31 <fax> yeah I tend to use LaTeX when everyone else uses WoRd
10:09:35 <ksf> FliPPeh_, by any means necessary, do everything you can to make assignments interesting
10:09:36 <FliPPeh_> :)
10:10:07 <FliPPeh_> Well, he actually told me I could use Haskell... but he'll have fun checking my code anyways.
10:11:15 <edwardk_> FunctorSalad: yeah but in this little world you lose all sorts of things like polymorphic recursion, etc.
10:14:10 <FunctorSalad> edwardk_: however, even a practical shell based on 'Stream -> [String] -> IO (Stream,Stream)" would be a large improvement over bash, IMHO ;)
10:14:17 <FunctorSalad> that's the iface to the outside world
10:14:18 <edwardk_> heh
10:14:27 <FunctorSalad> inside haskell I'd just compile stuff together I think
10:14:36 <FunctorSalad> as long as it's just for personal use
10:14:55 <edwardk_> at least swap out strings for ByteStrings ;)
10:15:06 <FunctorSalad> the string-list is supposed to be the argz
10:15:14 <FunctorSalad> "Stream" is to be determined
10:15:29 <FunctorSalad> maybe bytestring-based, yeah
10:15:42 <edwardk_> Stream -> Seq ByteString -> IO (Stream, Stream) -- no sense having your args not have an efficient count, etc.
10:15:46 <edwardk_> ;)
10:15:46 <c_wraith> When interacting at that level, it's important to work in bytes.
10:15:59 <FunctorSalad> edwardk_: didn't know BS was better than String at any length
10:16:05 <FunctorSalad> edwardk_: not saying that that isn't true :)
10:16:13 <FunctorSalad> *at every length
10:17:33 <FunctorSalad> I somehow thought it allocated a large chunk of memory for serious business, but that notion is not based on fact ;)
10:17:39 <FunctorSalad> the strict BS, at least
10:17:56 <edwardk_> FunctorSalad: nah, it allocates exactly the size needed
10:18:40 <edwardk_> it may take two passes to do it
10:18:53 <FunctorSalad> (hmm, what was I thinking... how would an immutable value make use of room to grow anyway...)
10:18:53 <edwardk_> there is a createAndTrim that isn't used very often as a fallback though
10:19:16 <edwardk_> for when you only have a loose upper bound on the size of the result
10:19:28 <FunctorSalad> ah :)
10:19:38 <EvanR-work> if i have a list of list of X, and i want a new list of list of X, all the same elements, but grouped differently?
10:19:48 <EvanR-work> concat groupBy?
10:20:03 <FunctorSalad> iirc groupBy works only on successive runs
10:20:03 <EvanR-work> groupBy . concat
10:20:18 <EvanR-work> sucessive runs?
10:20:20 <FunctorSalad> if they're arbitrarily mixed, you might want to index the buckets by a Data.Map or so
10:20:32 <EvanR-work> the buckets arent important
10:20:43 <EvanR-work> they are just groups
10:20:57 <FunctorSalad> > groupBy (\x y -> (mod x 2) == (mod y 2)) [1,3,5,6,8,1,3,5]
10:20:58 <lambdabot>   [[1,3,5],[6,8],[1,3,5]]
10:21:00 <FunctorSalad> that
10:21:19 <FunctorSalad> ok, bad example
10:21:26 <EvanR-work> :t groupBy
10:21:26 <FunctorSalad> > groupBy (\x y -> (mod x 2) == (mod y 2)) [1,3,5,6,8,-1,-3,-5]
10:21:26 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
10:21:27 <lambdabot>   [[1,3,5],[6,8],[-1,-3,-5]]
10:21:35 <EvanR-work> hrm binary op
10:21:38 <FunctorSalad> I mean it doesn't group the first and last one together
10:21:54 <EvanR-work> i want to group all elements satisfying some property
10:21:54 <FunctorSalad> yeah, I'd prefer a unary :key 99% of the time
10:22:08 <EvanR-work> doesnt depend on other elements
10:22:30 <EvanR-work> doesnt make sense, nevermind
10:22:38 <FunctorSalad> but you see what I meant with runs?
10:22:44 <tibbe> Is there such a thing as a church encoding or CPS encoding of a pair? I'm thinking "(a -> b -> (a, b)) -> (a, b)" instead of "(a, b)"
10:22:47 <FunctorSalad> they're only grouped when adjacent
10:22:52 <EvanR-work> right
10:23:09 <ksf> tibbe, think cons car cdr
10:23:17 <FunctorSalad> tibbe: "forall r. (a -> b -> r) -> r"
10:23:28 <EvanR-work> more concete, group all emails which have the same domain part
10:23:31 <FunctorSalad> invisibul pair :D
10:23:34 <tibbe> interesting
10:23:37 * tibbe thinks
10:23:44 <ksf> cons returns a function as thinrd parameter that selects one of two passed parameters
10:23:52 <ksf> ...that function then is passed in by car and cdr
10:24:00 <EvanR-work> @google data.list
10:24:02 <lambdabot> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Data-List.html
10:24:02 <lambdabot> Title: Data.List
10:24:18 <FunctorSalad> I don't know if that I wrote is faster than returning a pair from a function
10:24:28 <FunctorSalad> assuming the caller disassembles the pair anyway
10:24:33 <FunctorSalad> you seem to save an intermediate
10:25:03 <EvanR-work> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.1/Data-List.html
10:25:09 <ksf> tibbe, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_idx_1462
10:25:16 <ksf> (a bit down)
10:25:48 <tibbe> ksf: I actually read that the other day
10:26:05 <EvanR-work> FunctorSalad: group where the eq function is specify able
10:26:06 <EvanR-work> ?
10:26:08 <tibbe> ksf: I have a definition of Monoid for pairs and I'm trying to write it for my church encoding
10:26:17 <FunctorSalad> tibbe: my type says "if you tell me how to make an r out of an a and a b, I'll give you an r"
10:26:27 <FunctorSalad> which is isomorphic to "I have an a and a b" :)
10:26:33 <fax> tibbe: I know how to do that
10:26:56 <FunctorSalad> (because r is universally quantified, it covers everything you could possibly do with that a and b)
10:27:03 <EvanR-work> groupBy . sortBy . concat
10:27:24 <fax> tibbe: rewrite pattern matching and such in terms of functions (like fst and snd) -- then rewrite all functions on tuple to functions on church-tuple! that's all there is to it
10:27:25 <FunctorSalad> it's interesting what happens if r is restricted in form, see edwardk_ 's Ran functors :)
10:27:34 <tibbe> So I have: data MyPair a b = MP (forall r. (a -> b -> r) -> r)
10:27:45 <FunctorSalad> (where you have "g r" and "h r" for certain functors g and h, instead of just any r)
10:28:00 <edwardk_> FunctorSalad: =)
10:28:02 <tibbe> fax: I don't quite see it
10:28:04 <fax> fst (MP f) = f (\a b -> a)
10:28:08 <fax> snd (MP f) = f (\a b -> b)
10:28:11 <tibbe> fax: what would mappend look like for example?
10:28:12 <FunctorSalad> tibbe: yeah. you don't even need to wrap the type if you don't want to
10:28:23 <fax> tibbe: well show me your mappend written in terms of (,)
10:29:10 <FunctorSalad> edwardk_: it's like "I have an a and a b, but I'll only tell you what it is if you intend to produce something of the form "g r", and I'll actually give you an "h r" instead :p", isn't it? ;)
10:29:13 <edwardk_> tibbe: one sec. i have that exact fragment buried in a much larger example (the Ran stuff)
10:29:25 <tibbe> PairS $ let PairS a b  = unPair p1; PairS x y = unPair p2 in PairS (a `mappend` x) (b `mappend` y)
10:29:34 <tibbe> fax: ^^
10:29:50 <fax> oh okay you're using PairS which is the same as (,)
10:29:57 <fax> ?
10:30:02 <fax> I don't really see what is going on here
10:30:10 <tibbe> fax: yes, my actual pair is only polymorphic in one component
10:30:21 <fax> so uh
10:30:22 <EvanR-work> is there a random monad?
10:30:26 <fax> mappend = PairS $ let PairS a b  = unPair p1; PairS x y = unPair p2 in PairS (a `mappend` x) (b  `mappend` y)
10:30:29 <fax>  ?
10:30:40 <FunctorSalad> EvanR-work: monte-carlo
10:30:48 <tibbe> fax: yes, just pointwise mappend
10:31:06 <benmachine> MonadRandom?
10:31:16 <EvanR-work> @src MonadRandom
10:31:17 <lambdabot> Source not found. My brain just exploded
10:31:22 <benmachine> @hoogle MonadRandom
10:31:22 <lambdabot> No results found
10:31:24 * hackagebot web-routes-transformers 0.19 - Extends web-routes with some transformers instances for RouteT  http://hackage.haskell.org/package/web-routes-transformers-0.19 (JeremyShaw)
10:31:24 <benmachine> pfft
10:31:28 <benmachine> @hackage MonadRandom
10:31:28 <lambdabot> http://hackage.haskell.org/package/MonadRandom
10:31:33 <FunctorSalad> IIRC monte-carlo is optimized for quickly producing samples; it's not the explicit probablility monad
10:31:39 <FunctorSalad> which produces explicit distros
10:31:44 <fax> tibbe what's unPair?
10:31:48 <fax> and what's the definition of PariS
10:31:51 <fax> PairS
10:31:57 <EvanR-work> cool
10:32:23 <tibbe> fax: sorry, I had a double layer of newtypes
10:32:25 <FunctorSalad> (but is handicapped too by lack of Ord constraint, while we're at it)
10:32:28 <fax> that is a bit confusing
10:32:40 <FunctorSalad> since it can't collapse the distros, it has to keep association lists
10:32:42 <tibbe> fax: data PairS a = PairS a {-# UNPACK #-} !Builder    and   newtype HtmlM a = Html { unHtml :: PairS a }
10:32:46 <edwardk_> instance (Monoid a, Monoid b) => Monoid (MyPair a b) where mempty = MyPair (\k -> k mempty mempty); MyPair f `mappend` Mypair g = MyPair (\k -> f (\a b -> g (\a' b' -> k (a `mappend` a') (b `mappend` b'))))
10:32:51 <tibbe> fax: I was trying to simplify on the fly :)
10:33:18 <edwardk_> tibbe: something like that?
10:33:20 <tibbe> edwardk: what's the definition of MyPair
10:33:33 <FunctorSalad> edwardk_: I always found it curious what you're supposed to do if the "r" is constrained to monoid too!
10:33:38 <FunctorSalad> then you have a choice
10:33:40 <tibbe> edwardk: n/m I see
10:33:52 <fax> tibbe okay this is getting crazy
10:33:52 <FunctorSalad> mappend before or after the continuation...
10:34:04 <edwardk_> tibbe: i was using the one you used above. newtype MyPair a b = MyPair (forall r. (a -> b -> r) -> r)
10:34:32 <tibbe> edwardk I figured :)
10:34:49 <edwardk_> which is coincidentally, just a right kan extension of Identity along ((->)b), so there are all sorts of properties that hold for it ;)
10:35:19 <FunctorSalad> aka left adjoint :p
10:35:25 <fax> (p,q) `mappend` (x,y) = (p `mappend` x, q `mappend` y)
10:35:28 <FunctorSalad> unless I'm horribly confused
10:35:47 <fax> <=> a `mappend` b = (fst a `mappend` fst b, snd a `mappend` snd b)
10:36:13 <fax> ==> a `mappend` b = (fst' a `mappend` fst' b, snd' a `mappend` snd' b) -- where fst', and snd' operate on church tuples
10:36:17 <fax> that's what I was going for
10:36:28 <fax> but the newtypes and all that -- get in the way of clarity
10:36:48 <tibbe> fax: I think I get it, thanks
10:36:50 <edwardk_> FunctorSalad: yeah you're on the right track. given the adjunction between hom and prod you can use adjointToRan and ranToAdjoint to go back and forth to the traditional pair.
10:36:52 <FunctorSalad> I don't see where your `fst` and `snd` are coming from if we're still in the cps coding here, fax
10:36:58 <fax> you could also define an isomorphism between church and state to do:
10:36:59 <tibbe> gotta rush though
10:37:02 <edwardk_> FunctorSalad: http://comonad.com/reader/2008/kan-extensions-ii/ (look for adjointToRan)
10:37:04 <FunctorSalad> fax: but I couldn't follow that thread so maybe nvm me
10:37:07 <tibbe> thanks all!
10:37:12 <edwardk_> adjointToRan :: Adjunction f g => f a -> Ran g Identity a
10:37:25 <fax> (iso -> (p,q)) `mappend` (iso -> (x,y)) = uniso $  the old definition
10:37:38 <edwardk_> there is an instance for Adjunction ((,)e) ((->)e)
10:37:59 <FunctorSalad> edwardk_: ah, I didn't think anything there, just remembered that adjunctions are a special case of Ran and that xb is left adj to ->b ;)
10:38:04 <fax> FunctorSalad, I defined them above
10:38:15 <edwardk_> so that becomes (e,a) -> Ran ((->)e) Identity a  which is isomorphic to (e,a) -> MyPair e a ;)
10:38:20 <FunctorSalad> fax: ah
10:38:30 <fax> FunctorSalad, also I used (,) as a constructor for both normal and church tuples which was probably horrible confusing and misleading :/
10:38:36 <FunctorSalad> :o
10:38:46 * fax will try to not do that again
10:39:05 <fax> what is Ran?
10:39:32 <edwardk_> you can also go back using adjointToRan, so the isomorphism is witnessed, just by the code in category-extras, nothing new needs to be written here ;)
10:39:53 <edwardk_> fax: Ran is a 'right kan extension' it is a generalization of continuation passing style that comes from category theory.
10:40:25 <fax> haha I see: Right kAn extensioN
10:40:53 <FunctorSalad> fax: well, I had only skimmed it too, given the scrolling
10:40:55 <edwardk_> newtype Ran f g a = Ran { runRan :: forall r. (a -> f r) -> g r } -- is a usable definition for a right kan extension of two functors over Hask
10:41:02 <fax> edwardk_, if I know CPS and some really basic category theory will I be able to understand it ?
10:41:08 <edwardk_> though they only need to be of kind * -> *, not Hask functors
10:41:22 <edwardk_> fax: i hope so. i wrote up a few articles on the topic a while back
10:41:31 <fax> oh cool I'll look at yrou blog
10:41:32 <edwardk_> start here http://comonad.com/reader/2008/kan-extensions/
10:41:35 <ksf> CPS is more about getting used to it than understanding it
10:41:35 <fax> thank you!
10:41:46 <fax> ksf hehe like quantum physics ?
10:41:46 <edwardk_> there are two more after that
10:41:52 <edwardk_> and then i use it sporadically thereafter i think
10:42:04 <FunctorSalad> edwardk_: btw, do you think there's any use for the codensity of Set, which is an unconstrained functor?
10:42:14 <FunctorSalad> I think someone pointed out that it doesn't do what I'd like it to do
10:42:24 <FunctorSalad> (efficiency-wise)
10:42:37 <ksf> fax, not really. There's really not a lot to understand about CPS
10:43:06 <FunctorSalad> what was it... iirc, "newtype CSet a = CSet (forall r. Ord r => (a -> Set r) -> Set r)
10:43:18 <edwardk_> i use codensity as a form of 'bind fusion'. there what you get is a known association. so even though the associativity law breaks down on Set when you introduce functions, you get a predictable result
10:43:56 <FunctorSalad> my head spins if I try to think about whether that thing expand to efficient Set-handling or not :(
10:44:03 <FunctorSalad> *expands
10:44:24 <edwardk_> think of Codensity as a way to fix broken monads, it takes a near-monad that doesn't necessarily meet the associativity law and fixes the association
10:44:41 <FunctorSalad> oh. I hadn't even considered associativity
10:44:50 <FunctorSalad> just wanted to make Set a Functor and Monad
10:44:54 <edwardk_> *nods*
10:45:26 <edwardk_> with that you can make a functor/monad based set that has two constructors
10:45:31 <FunctorSalad> the Ord constraint has the possible advantage that you can union CSets
10:45:37 <FunctorSalad> on idea if that's a good idea
10:45:38 <edwardk_> and use that to fix its associativity
10:45:43 <edwardk_> i have it somewhere
10:46:00 <FunctorSalad> one for empty?
10:46:06 <FunctorSalad> I needed that somewhere too
10:46:14 <FunctorSalad> don't remember where
10:46:17 <edwardk_> nah, one for [a] and one fot Set a
10:46:22 <FunctorSalad> ah
10:46:49 <fax> hm
10:46:56 <edwardk_> and since the codensity fixes the associativity, it doesn't matter that your underlying layer isn't associative
10:47:07 <FunctorSalad> somehow I think it can't possibly work ;)
10:47:16 <FunctorSalad> (making Set an unconstrained Functor)
10:47:40 <edwardk_> it works, you just force people to extract values from it in an Ord instance
10:48:04 <FunctorSalad> at least, unless you make "checkpoints" at concrete types known to be Ord, where actual set operations are  done?
10:48:19 <FunctorSalad> since we can't conjure "Ord"s for all the intermediate types out of nothing, even if the final type is Ord
10:48:37 <edwardk_> they are always right associated, so you get all of the blow up associated with that path
10:48:53 <edwardk_> even if you internally parenthesized your binds the other way
10:49:18 <fax> "All concepts are Kan extensions" what does that mean :/
10:49:18 <FunctorSalad> btw how does set fail to be associative? if we ignore the hidden tree structure
10:49:47 <fax> FunctorSalad which operation
10:49:52 <edwardk_> you can't collapse a set of functions to be just the size of the number of distinct functions
10:50:19 <FunctorSalad> edwardk_: hmm wait... right-assoc means "substitute on the inside first, then on the outside"? if we have the bind = tree substitution or concatMap picture in mind
10:50:25 <EvanR-work> how to drop n random list elements
10:50:33 <FunctorSalad> (I see how that blows up, I think ;))
10:50:34 <svat> hi, i'm somewhat new to Haskell; could I ask for comments on some short code? (Here: http://stackoverflow.com/questions/2692152/2692561#2692561 ) In particular, I'm wondering why they seem to take so much memory, and whether I'm doing something obviously stupid.
10:51:02 <FunctorSalad> fax: the ones that need the Ord, like union, insert, member, ....
10:51:41 <edwardk_> FunctorSalad: you fuse together all the binds so you do one foo >>= \x -> (....) at a time, never using the >>= on the underlying monad with the parens the other way
10:51:52 <EvanR-work> could be done by shuffling and dropping the first n
10:51:57 <EvanR-work> but i think shuffling is not simple
10:52:25 <fax> I can only see EvanR, drop the first element with 1/n probability
10:52:35 <edwardk_> EvanR-work: there is a fisher-yates shuffle in hackage somewhere
10:52:36 <fax> oops
10:53:23 <fax> actually with m/n probability
10:53:38 <EvanR-work> just the first?
10:54:04 <FunctorSalad> edwardk_: I just have a hard time with the left/right thing so I tried to translate it to inside/outside ;)
10:54:14 <FunctorSalad> at the example of trees or lists
10:54:30 * hackagebot gt-tools 0.1.4 - Console and GUI interface for Google Translate service  http://hackage.haskell.org/package/gt-tools-0.1.4 (MikhailPobolovets)
10:55:03 <FunctorSalad> so apparently you build up a chain of deferred binds, and only collapse the thing to a no-duplicates set at the final type, it seems
10:55:18 <edwardk_> FunctorSalad: sadly, yes.
10:55:33 <edwardk_> FunctorSalad: it is a 'canonical form' at least
10:55:41 <edwardk_> but it is far from an intuitive or fast one
10:55:45 <fax> EvanR: probability chaneges as you move through
10:56:13 <FunctorSalad> edwardk_: but if your application has an Ord constraint, you could collapse the set whenever you have the constraint
10:56:29 <FunctorSalad> edwardk_: and just get the build-up when you code that is generic over the monad?
10:56:35 <FunctorSalad> *when you call code
10:56:49 <edwardk_> can you? you never get a normalization pass like that -- that would be a left association ;)
10:56:53 <EvanR-work> fax: sounds complex
10:56:58 <fax> it's not
10:57:12 <edwardk_> we associated all of those moments away
10:57:39 <edwardk_> you can of course make a non-monadic action like collapse :: a => Set a -> Set a
10:57:46 <edwardk_> er collapse :: Ord a => Set a -> Set a
10:58:12 <edwardk_> which isn't subjected to the monad laws inconveniently
10:58:17 <FunctorSalad> edwardk_: yes, I meant that
10:58:45 <FunctorSalad> the user code would do that, not the monad-generic code
11:00:15 <FunctorSalad> maybe "collapse (set >>= f)" is still less efficient than the specialized unionMap though
11:00:26 <EvanR-work> :t choose
11:00:27 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
11:00:38 <FunctorSalad> (hypothetical unionMap without lists, just sets)
11:00:42 <FunctorSalad> @ty unionMap
11:00:43 <lambdabot> Not in scope: `unionMap'
11:00:47 <FunctorSalad> @ty S.unionMap
11:00:48 <lambdabot> Couldn't find qualified module.
11:00:51 <FunctorSalad> @ty Set.unionMap
11:00:52 <lambdabot> Couldn't find qualified module.
11:01:15 <FunctorSalad> @ty foldMap
11:01:16 <lambdabot> Not in scope: `foldMap'
11:01:22 <EvanR-work> what the hell is choose
11:01:44 <EvanR-work> part of quickcheck
11:02:15 <edwardk_> FunctorSalad: the other problem is that when you're done, if you take a critical look at it, you can get the same effect with a lot less machinery and [a] ;)
11:02:17 <FunctorSalad> set_bind f = foldMap . set_fmap f, I guess
11:02:35 <FunctorSalad> edwardk_: hmm
11:03:04 <edwardk_> and a rule that you only extract from the result list via sort. ;)
11:03:12 <EvanR-work> is there something...   (f x) . (g x) -> (f ? g) ? x
11:03:40 <fax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25068
11:03:44 <fax> EvanR, look ^
11:03:56 <mauke> :t liftM2 (.)
11:03:57 <fax> roll will give True or False with probability p
11:03:57 <FunctorSalad> set_bind = foldMap, actually (where is my mind)
11:03:57 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
11:04:12 <FunctorSalad> if we take "m b" as the Monoid and "t = Set"
11:04:31 <mauke> :t liftM2 (Prelude..)
11:04:32 <fax> it would look even better as  caseM roll (n/length) of True -> ...
11:04:32 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
11:04:34 <FunctorSalad>   foldMap :: (Data.Monoid.Monoid m) => (a -> m) -> t a -> m
11:04:34 <EvanR-work> fax: more like flip eh ;)
11:04:48 <fax> EvanR, I called it flip before I realized that was taken
11:04:53 <EvanR-work> heh
11:05:02 <fax> EvanR also you have to pass in the length of the list
11:05:08 <fax> that's used in the calculations
11:05:46 <EvanR-work> so does this drop exactly n
11:05:59 <EvanR-work> if n is less than the length
11:06:40 <fax> EvanR, [assuming well formed inputs] you can see that if n is 0 it wont drop anything (hence it can't drop more than n), but you can also see that if n == length then it will drop all the elements (so it can't drop less than n)
11:06:46 <fax> that proves the functions drops exactly n elements
11:07:08 <fax> showing that it does it with equal probability is a bit more trick (I think we'd need to get out the weakest precondition calculus)
11:07:25 <EvanR-work> yes thats not obvious
11:07:36 <fax> by well formed inputs I mean that length really is length, and that n <= length
11:08:57 <strobedream> so what kind of problems do you guys use haskell for?
11:09:20 <pikhq> Little bit of everything.
11:09:25 <benmachine> I used it to write an application to whine at me when deadlines were approaching
11:09:28 <benmachine> I put it in my .bashrc
11:09:29 <pikhq> It's a well-implemented modern programming language.
11:09:34 <benmachine> 1. Tomorrow: Relativity supervision
11:09:34 <benmachine> 2. 4 weeks: Paper 1
11:09:37 * benmachine panics
11:09:44 <fax> strobedream: I use it to select random elements of a list.... :D
11:09:54 <strobedream> lol
11:10:11 <EvanR-work> im selecting random emails to send
11:10:26 <fax> strobedream -- also I wrote this yesterday http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25045#a25045
11:10:37 <strobedream> One of my classes is in haskell and I keep trying to figure out what I would use it for.
11:10:47 <roconnor> strobedream: searching through infinite sets in finite time
11:10:48 <benmachine> haskell is a general-purpose language
11:10:50 <fax> "if you have to ask.. you'll never know"
11:10:54 <benmachine> but there are some things it's particularly good for
11:10:58 <benmachine> I think parsing is one
11:10:59 <EvanR-work> strobedream: how about a platform game ;)
11:11:13 <roconnor> strobedream: http://raincat.bysusanlin.com/
11:12:02 <edwardk_> FunctorSalad: that doesn't solve your associativity problem though ;)
11:13:11 <FunctorSalad> edwardk_: ok I guess one would better start implementing restricted typeclasses o_o
11:13:26 <FunctorSalad> maybe ghc sugar for it
11:13:39 <FunctorSalad> but I don't know, maybe it's more involved that simple sugar
11:13:43 <ksf> strobedream, just use it for everything
11:14:05 <FunctorSalad> . o O (wth is a strobedream and why should I use it for everything) ;)
11:14:14 <EvanR-work> im trying to do a form that involves a sequence of >>= and (flip ($))
11:14:27 <ksf> it's usable for everything from scripting to systems programming to high-abstraction ivory stuff, you just have to use it a bit differently each time.
11:14:27 <EvanR-work> tricky
11:14:56 <FunctorSalad> I tend to agree with ksf, haskell is just fine or script-like things too
11:15:01 <FunctorSalad> *for
11:15:03 <strobedream> "high-abstraction ivory stuff" lol
11:15:25 <FunctorSalad> once you have all the libraries for filesystem stuff, regexes and so on conveniently set up
11:15:56 * ksf ponders writing an init system in haskell
11:17:41 <FunctorSalad> even with a one- or two-pages script, sometimes the typesystem is preferrable to debugging a bash script o_o
11:17:51 <EvanR-work> im annoyed by the difference between computing the 'next step' with a monadic action and a normal function. i have to use let or <-, or i have to use >>= or (flip ($))
11:18:30 <CyberGarp> I'm writing a parser using Parsec, and when something goes south in consuming characters it just stops with no error message, and the final output doesn't indicate that an error occurred. I suspect I'm making a fundamental mistake in the way I'm using Parsec.
11:18:38 <CyberGarp> Any one else have a similar issue?
11:18:47 <EvanR-work> :t (>>>)
11:18:48 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
11:18:54 <fax> EvanR-work: well we could have everything in monad... just most programs written in Identity
11:18:59 <FunctorSalad> EvanR-work: <- is for monads too
11:19:06 <fax> EvanR, then there would be no syntactic different between pure and other code
11:19:08 <EvanR-work> thats what i meant
11:19:10 <ksf> CyberGarp, are you using state?
11:19:14 <pikhq> CyberGarp: What are you using to actually execute the parser?
11:19:16 <CyberGarp> Yes.
11:19:20 <ksf> don't.
11:19:30 <EvanR-work> fax: well then i have to lift all my pure functions?
11:19:34 <EvanR-work> or does that not work
11:19:37 <FunctorSalad> EvanR-work: it's not that complex, (>>=) and return (and fail) are the only monad primitives
11:19:46 <CyberGarp> Just the basic test function as written in the documentation, it checks left and right. I used to get errors, but they vanished when I started using state. Hmmm..
11:19:49 <FunctorSalad> EvanR-work: and "do" and "<-" are just syntax
11:19:51 <ksf> that is, not until you deeply grok parsec's inner workings. it's easy to mess up stuff with state.
11:20:00 <FunctorSalad> EvanR-work: even lambdabot can compile it down to (>>=) for you
11:20:10 <pikhq> Mmm. Yeah. Parsec is already doing stuff with state.
11:20:25 <EvanR-work> FunctorSalad: what im saying is, i want to do x >>= f $> g $> y >>= return
11:20:26 <FliPPeh_> What happens when I call "mainGUI" inside an already running "mainGUI"?
11:20:27 <CyberGarp> ksf, Ah, then why expose it?
11:20:28 <FunctorSalad> sorry, didn't mean to offend our trusty bot
11:20:29 <FliPPeh_> Is it ignored?
11:20:31 <fax> EvanR: oh I just meant it in a "if we could start all over again knowing what we know now" kinda way
11:20:32 <m_> Hi
11:20:34 <FunctorSalad> @bot
11:20:34 <lambdabot> :)
11:20:35 <pikhq> And Parsec's internals are... fairly deep.
11:20:36 <ksf> usually you can get rid of state by doing a multi-pass parser.
11:20:38 <fax> the language that is
11:20:38 <EvanR-work> fax: oh
11:20:54 <CyberGarp> Ouch, I was trying to get by with a single pass.
11:21:04 <CyberGarp> I have a BNF grammar defined and almost working.
11:21:07 <pikhq> CyberGarp: Someone believed in letting you shoot yourself in the foot, I think.
11:21:15 <ksf> CyberGarp, because parsec seems to be attempting to be a complete solution for everything
11:21:20 <aavogt> :( http://trac.haskell.org/haddock is down
11:21:23 <FunctorSalad> CyberGarp: you mean something goes wrong in the input stream?
11:21:26 <EvanR-work> FunctorSalad: well, thats wrong, but i hope you get it
11:21:26 <FunctorSalad> to the parser
11:21:26 <CyberGarp> pikhq, ksf, okay.
11:21:36 <m_> Can somebody help me with building haskell-platform from source? I got 'no glEnd found' error. I'm using debian lenny and i have installed freeglut, freeglut-dev and other gl and glu packages, but for no avail.
11:21:49 <CyberGarp> FunctorSalad, yes
11:22:19 <aavogt> Igloo, dcoutts, dcoutts_, could you fix trac.haskell.org / code.haskell.org http?
11:22:21 <strobedream> :t $=
11:22:22 <lambdabot> parse error on input `$='
11:22:27 <strobedream> :t ($=)
11:22:28 <lambdabot> Not in scope: `$='
11:22:29 <FunctorSalad> CyberGarp: if your input is "String", that's a known issue with lazy IO hiding *too* much
11:22:39 <m_> Exact error is: checking for GL/gl.h... yes
11:22:39 <m_> checking for library containing glEnd... no
11:22:39 <m_> configure: error: The OpenGL C library is required
11:22:43 <FunctorSalad> CyberGarp: but Parsec can consume other kinds of Streams too
11:22:51 <benmachine> roconnor: raincat doesn't compile anymore :(
11:22:53 <CyberGarp> Hmmm.
11:23:00 <FunctorSalad> CyberGarp: I don't know if anyone did a stream with serious error-handling for parsec, though
11:23:03 <strobedream> I am getting an error with raincat.
11:23:32 <benmachine> strobedream: I got several, I think it doesn't compile with newer versions of the opengl bindings
11:23:41 <FunctorSalad> CyberGarp: IOW, if it is a broken pipe or something in the input stream, maybe it has nothing at all to do with parsec, but with lazy IO
11:23:46 <strobedream> error loading shared lib libgmp.so.3 no such file
11:23:48 <CyberGarp> interesting.
11:23:52 <edwardk_> FunctorSalad take a look at the 'constraint family' stuff that has started coming down the pike
11:23:52 <strobedream> benmachine: okay
11:24:05 <benmachine> strobedream: ah, that's a different error, I was compiling from source
11:24:05 <CyberGarp> So maybe " input <- readFile fname
11:24:06 <CyberGarp>     case runParser program emptyBngl fname input of"
11:24:16 <CyberGarp> isn't the way to go
11:24:18 <FunctorSalad> CyberGarp: readFile is lazy IO indeed
11:24:28 <benmachine> strobedream: you're still screwed though I think :) are you runnign arch linux perchance?
11:24:31 <CyberGarp> recommendations?
11:24:31 <FunctorSalad> CyberGarp: it can throw IO errors later down the line in what masquerades as pure code
11:24:41 <strobedream> benmachine: yeah I was just trying to run it. I'll mess with compiling it.
11:24:46 <FunctorSalad> when your "input" var is evaluated, it reads from the file
11:24:51 <strobedream> benmachine: yeah ubuntu
11:24:56 <FunctorSalad> not at the "input <- " statement
11:24:59 <benmachine> strobedream: that's not arch linux :P
11:25:03 <edwardk_> CyberGarp: there are a few things you can do. the easiest is to just force the entire list which makes sure all the IO has happened.
11:25:04 <strobedream> oh
11:25:07 <benmachine> never mind then
11:25:09 <strobedream> durh.
11:25:16 <CyberGarp> k
11:25:28 <benmachine> I've been told calling it archlinux is wrong but I guess that would avoid confusion
11:25:40 <FunctorSalad> CyberGarp: hGetLine is strict, IIRC
11:25:57 <strobedream> benmachine: yeah I have been having problems with 64-bit doing embedded stuff.
11:26:08 <benmachine> oh, yeah that would cause problems
11:26:14 <FunctorSalad> CyberGarp: (reads one line from the file at a time... either just get all the lines at once, or (much better for a huge file) do the lazyness manually)
11:26:52 <CyberGarp> Could I use System.IO.Strict.readFile ?
11:27:35 <monochrom> Yes.
11:27:43 <FunctorSalad> is that in base?
11:27:45 <FunctorSalad> never seen it
11:27:50 <CyberGarp> nope, it's in hackage
11:27:53 <FunctorSalad> ah :)
11:28:12 <strobedream> benmachine: I am just blaming my environment every chance I can get these days.
11:28:20 <FunctorSalad> I've seen huge speedups from an up-front strict read to stream processing, though
11:28:25 <benmachine> strobedream: :)
11:28:31 <FunctorSalad> (in this case it was with the arbtt-dump program)
11:28:37 <FliPPeh_> What could be wrong when "renameFile" REMOVES a file?
11:28:52 <CyberGarp> thanks everyone. That gives me plenty of ideas to pursue.
11:29:26 <FunctorSalad> (which is a slightly biased case, maybe ;) it just reads a bunch of records from a huge file and outputs them back readably)
11:32:40 <benmachine> strobedream: aha, I found an up-to-date git repository that compiles
11:32:49 <benmachine> ....aaaand segfaults
11:32:50 <benmachine> >:|
11:33:30 <strobedream> haskell segfaults?
11:33:45 <benmachine> makes use of C libraries
11:33:50 <benmachine> e.g. SDL and OpenGL
11:33:55 <strobedream> ah
11:33:56 <strobedream> of course
11:34:00 <benmachine> it's uncommon but it happens
11:34:04 <Berengal> Has anyone tried combining iteratees with continuations, reinverting the control but keeping the guarantees, or is that a bad idea?
11:39:23 * benmachine works out that the segfault comes from GLUT.createWindow but is now entirely stuck
11:39:44 <benmachine> in other news:
11:39:44 <benmachine> -- toGLdouble
11:39:44 <benmachine> toGLdouble :: a -> GLdouble
11:39:44 <benmachine> toGLdouble = unsafeCoerce
11:39:45 <benmachine> wat
11:40:00 <benmachine> that works I guess :/
11:40:16 <EvanR-work> unsafe stuff is fun
11:40:20 <EvanR-work> totally safe
11:40:35 <Berengal> unsafeHasturHasturHastur :: RealWorld -> Void
11:40:39 <benmachine> afaict it's nothing to do with the segfault though
11:41:25 <benmachine> bloxorz doesn't die horribly
11:41:33 <benmachine> (nor does it work properly, but hey)
11:42:42 <Berengal> unsafe stuff is pretty common in FFI calls...
11:43:59 <flazz> anyone remember a web page with a bunch of different fib definitions kinda joking about different programming styles? i think it had a purple bg
11:44:15 <mauke> @where evolution
11:44:15 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:44:37 <sm> how do I extract a field's value out of a Record returned by a haskelldb query ?
11:45:31 <flazz> mauke: thanks!
11:47:08 * benmachine can't get raincat to stop segfaulting
11:47:10 * benmachine cries
11:49:14 <Berengal> Can haz access violation?
11:49:27 <benmachine> well, quite
11:49:53 * Berengal managed to segfault java today, without resorting to C, and is quite proud of that.
11:50:02 <pikhq> That takes quite some work.
11:50:43 <Berengal> Now: I wonder what would happen if I did that on a server...
11:50:55 * Berengal has a plan for tomorrow
11:56:01 <scotty> I currently have a Data.map that maps from a's to b's and I have a function which returns a type b assigned to "fromJust (Map.lookup ...)".  This works fine, but now I want it to return a b if the lookup succeeds (I get a "(Just a)"), and throw an error such as error "lookup failed" if I get back a "Nothing".
11:56:55 <scotty> How can I accomplish this?
11:57:23 <thoughtpolice> f (Just x) = ...
11:57:36 <thoughtpolice> f Nothing = error "world ended"
11:58:22 <thoughtpolice> scotty: actually, won't fromJust do that for you?
11:58:28 <benmachine> scotty: you are doing the Wrong Thing :P
11:58:28 <thoughtpolice> documentation says: "The fromJust function extracts the element out of a Just and throws an error if its argument is Nothing."
11:58:50 <benmachine> scotty: also see, fromJust, fromMaybe . error, (!) in Data.Map
11:58:53 <scotty> Okay, so how can I make the error that fromJust gives more specific?
11:58:58 <scotty> benmachine: Okay
11:59:03 <benmachine> :t fromMaybe . error
11:59:04 <lambdabot> forall a. [Char] -> Maybe a -> a
11:59:10 <scotty> Ah
11:59:12 <scotty> Thanks
11:59:14 <benmachine> well
11:59:19 <benmachine> you'd probably actually use it as
11:59:25 <benmachine> fromMaybe (error "oh no!")
11:59:47 <Twey> ‘(fromMaybe . error) "Oh no!" foo’ looks pretty cool.
11:59:58 <benmachine> so does your face
12:00:19 <scotty> So, like: fromMaybe (Map.lookup a mappy) (error "oh no!")?
12:00:26 <benmachine> other way around
12:00:29 <benmachine> :t fromMaybe
12:00:30 <lambdabot> forall a. a -> Maybe a -> a
12:00:34 <scotty> Ah, whoops.
12:00:39 <benmachine> the first argument is "what to do if it's nothing"
12:00:43 <benmachine> see also
12:00:46 <benmachine> :t maybe
12:00:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:00:53 <scotty> Thank you very much!
12:00:57 <benmachine> "what to do if it's nothing" "what to do if it's just"
12:01:02 <scotty> I'm just starting to use monads.
12:01:11 <scotty> They're scary!
12:01:11 <benmachine> very concise way of expressing stuff normally done as a case statement
12:01:16 <benmachine> monads are overrated
12:01:18 <benmachine> tell your friends
12:01:23 <benmachine> well no they are not
12:01:28 <benmachine> their scariness is :P
12:01:36 <thaostra> wut
12:01:42 <scotty> Ha-ha... some people think Haskell is scary altogether.
12:01:46 <benmachine> some people do!
12:01:53 <benmachine> those people will never be truly happy
12:02:11 <scotty> I was talking to someone the other day and he said Haskell is for super math geniuses.
12:02:20 <sm> finally. record .!. Db.Table.field
12:02:20 <Twey> benmachine: Well thank you.
12:02:24 <c_wraith> I finally really understood monads when I was started learning Parsec.  And I realized that I just knew how its abstraction worked already.  And I realized that's all there is to monads.  A handy abstraction for combining smaller bits into larger ones.
12:02:26 <benmachine> that is a common misconception
12:02:29 <benmachine> well
12:02:38 <benmachine> it is for super maths geniuses and other people as well
12:02:41 <Twey> scotty: error "OH NO!!!" `fromMaybe` foo
12:02:52 <scotty> c_wraith: Yeah, I'm using parsec right now.
12:03:22 <benmachine> scotty: anyway if you like monads you shouldn't need error :P
12:03:23 <scotty> Twey: Why should I use infix?
12:03:26 <benmachine> you should just maybe around
12:03:30 <benmachine> scotty: because it's cute
12:03:44 <Twey> scotty: *shrug* Less brackets here
12:04:15 <benmachine> scotty: also don't listen to people who tell you what you should and should not do (i.e. me)
12:04:22 <scotty> benmachine: I would try to make the code prettier, but I gotta take one step at a time!
12:04:26 <benmachine> yeah
12:04:35 <benmachine> this is why my attitude is not helpful
12:04:36 <scotty> I'll leave it as an error for now.
12:04:51 <scotty> Before, it was just a fromJust, so it's getting better.
12:05:28 <EvanR-work> fromJust, risky business
12:05:51 <benmachine> well
12:06:01 <benmachine> sometimes all you can do is go "oh it broke"
12:06:14 <benmachine> error recovery is not always all it's cracked up to be :P
12:06:41 <Twey> > error "oh it broke" `fromMaybe` lookup "foo" [("foo", "bar"), ("baz", "quux")]
12:06:42 <lambdabot>   "bar"
12:07:10 <Twey> It saddens me that people from other languages rarely recognise this syntactic delight
12:08:15 <thaostra> maybe they just don't care?
12:08:49 <eggy_> Hello, how do I unpack something from the end of the list? Like, instead of (x:list) I need (list:x)
12:09:01 <benmachine> lists aren't good at that sort of thing
12:09:12 <benmachine> it can be done, see: the last function
12:09:18 <benmachine> but you basically have to look at the whole list
12:09:37 <eggy_> benmachine: if I use the last function, will it also pop the last element from the list?
12:09:52 <benmachine> have you heard of immutability? :P
12:09:58 <Twey> > init &&& last $ [1 .. 5]
12:09:59 <lambdabot>   ([1,2,3,4],5)
12:10:17 <benmachine> Twey is sensible
12:10:28 <eggy_> benmachine: well, yes, so how do I get a new list without the last element?
12:10:30 <benmachine> you could also do
12:10:41 <Twey> eggy_: init
12:10:47 <eggy_> Twey: oh, great, thanks
12:10:51 <benmachine> > case reverse [1,2,3,4,5] of (x:xs) -> (x, reverse xs)
12:10:52 <lambdabot>   (5,[1,2,3,4])
12:11:00 <Twey> (but same caveat applies: this is not desirable in terms of big-O)
12:11:09 <pikhq> Note that init will look at the entire list, and that it creates a whole new list.
12:11:15 <Twey> benmachine: That's just insane :þ
12:11:21 <pikhq> If you're doing it a lot, you should be using a better data structure.
12:11:23 <benmachine> Twey: well, it's silly for single items
12:11:26 <eggy_> Twey: so is there a better way entirely?
12:11:33 <benmachine> but if you're going to be taking stuff off the back of the list a lot
12:11:34 <Twey> eggy_: Yes: use a different data-structure.
12:11:39 <pikhq> eggy_: Well, what are you *doing*?
12:11:41 <benmachine> it's reasonable to reverse the list for a while
12:11:47 <Twey> benmachine: True
12:11:52 <aavogt> the implementation makes you prefer pattern match failures over partial functions
12:12:13 <benmachine> yeah, that too
12:12:15 <aavogt> at least, it's nicer to get  match failure module xyz, line 5
12:12:26 <benmachine> or you can easily put a [] case in
12:12:34 <monochrom> @quote monochrom monad
12:12:34 <lambdabot> monochrom says: If you're having trouble learning monads, try to learn something harder, like algebraic geometry.
12:12:38 <aavogt> but that's not as composable
12:12:47 <eggy_> Twey: pikhq I need to see if a list is symmetric, a stupid academic problem
12:12:59 <Twey> aavogt: That's not nice at all.  I got one of those in Data.Text the other day in the middle of my program's runtime, when I was asleep, in a concurrent program.
12:13:05 <benmachine> oh, there are easier ways of doing that I think
12:13:09 <Twey> I still have no idea what caused it.
12:13:10 <pikhq> Ah.
12:13:19 <aavogt> Twey: I mean if you're going to leave partial functions at all
12:13:24 <benmachine> Twey: better than "Prelude.undefined" though right?
12:13:29 <Twey> eggy_: Oh, well, if it's academic you might as well just do it the stupid way
12:13:30 <pikhq> There's a lot of ways of doing that, yeah.
12:13:37 <Twey> benmachine: Well, yeah :þ
12:13:42 <pikhq> But might as well do it very naively.
12:13:48 <Twey> aavogt: Well, you can give it a nice error at least.
12:13:49 <pikhq> Reverse the list and compare. >:D
12:13:52 <eggy_> Twey: yes, but I actually want to learn something :p
12:14:10 <benmachine> eggy_: well, xs == reverse xs is going to be what, half as efficient as the best way?
12:14:18 <benmachine> and it's so obvious what it does
12:14:33 <benmachine> sometimes more simpler = more better
12:14:37 <eggy_> Hmm, yes, that's a good idea, hadn't thought of that actually
12:14:39 <maltem> what's the best way?
12:14:56 <eggy_> pikhq: benmachine Twey thanks for the help :)
12:14:59 <benmachine> maltem: well, I'm no expert, but xs == reverse xs checks every element twice
12:15:02 <pikhq> maltem: Unless speed has become a factor, "xs == reverse xs".
12:15:08 <maltem> benmachine, ah right
12:15:22 <pikhq> Not because it's fast or anything, but because it's the most obvious method possible.
12:15:30 <pikhq> And that counts for a lot when speed doesn't matter.
12:15:43 <benmachine> you can look at it later and go, I know what that does
12:15:50 <benmachine> it's practically a definition of the problem :)
12:16:02 <Twey> maltem: ((==) `on` (\xs -> take (ceil $ length xs / 2))) xs (reverse xs)
12:16:05 <Twey> With fusion ☺
12:17:12 <benmachine> let divc x y = negate (negate x `quot` y) in divc 5 2
12:17:13 <Twey> genericLength, I guess
12:17:15 <benmachine> > let divc x y = negate (negate x `quot` y) in divc 5 2
12:17:16 <lambdabot>   2
12:17:19 <benmachine> oh
12:17:22 <benmachine> oh of couse
12:17:23 <Twey> benmachine: Fail :þ
12:17:26 <benmachine> > let divc x y = negate (negate x `div` y) in divc 5 2
12:17:27 <lambdabot>   3
12:17:29 <benmachine> there we go
12:17:36 <benmachine> (highly silly)
12:17:37 <Twey> A.K.A. ceil ;)
12:17:47 <benmachine> yes but no EVIL FLOATS
12:18:01 <Twey> Hmmm ☺
12:18:16 <benmachine> hmm I wonder if the default decl should default to Rational instead of Double
12:18:19 <benmachine> by er default
12:21:52 <scotty> Do the Standard Prelude functions discourage you from giving your functions conflicting names?
12:22:08 <scotty> Or do you just hide those functions?
12:22:28 <roconnor> scotty: I used tan in my colour library
12:22:49 <benmachine> heh
12:23:10 <benmachine> scotty: it's not completely unheard of to import Prelude hiding
12:23:18 <benmachine> it's not like, taboo or anything
12:23:25 <benmachine> but be sensible about writing code that might be confusing
12:23:30 <scotty> But in most cases, do people try to name their functions something else?
12:23:40 <benmachine> people do their own thing I think :)
12:23:45 <scotty> Hm...
12:23:51 <benmachine> it's less effort to just name them something else
12:24:04 <benmachine> even if just trivially
12:24:22 <benmachine> (you could call a function head' if you liked)
12:24:40 <scotty> Okay.  I guess I just haven't gotten comfortable with my preferences yet.
12:24:53 <scotty> I'm still battling it out in my brain.
12:25:42 <alpounet> yay gsoc results announced
12:25:51 <benmachine> do we win
12:27:07 <sm> where is the hackage instance that shows reverse dependencies ? I'd like to find code that uses haskelldb
12:28:31 <eggy_> humm, how can you do pattern matching to specify a list with one element?
12:28:38 <EvanR-work> [x]
12:28:49 <newsham> > let [x] = [5] in x
12:28:50 <lambdabot>   5
12:28:55 <eggy_> aww, I must be doing something else wrong then, thanks
12:41:58 <roconnor> I think I figured out how to cheat at raincat
12:42:13 <benmachine> does it involve not segfaulting
12:42:19 <eggy_> Did we align 'where' is the '=', or do we align it with the other clauses?
12:42:25 <roconnor> benmachine: raincat hasn't segfaulted on me
12:42:30 <roconnor> it's written in haskell!
12:42:32 <benmachine> heh
12:42:47 <benmachine> it uses unsafecoerce at some point but I don't think that's the problem
12:42:49 <roconnor> eggy_: I indent where 1 space
12:42:55 <benmachine> it's GLUT being mean to me
12:42:59 <fax> roconnor I can't run raincat
12:43:02 <fax> oh wait
12:43:04 <eggy_> roconnor: oh, ok, is that common?
12:43:08 <fax> raincat is an actual game
12:43:10 <roconnor> fax: I'm running it on my gf's laptop
12:43:17 <fax> I couldn't load that URL you linked earlier
12:43:34 <roconnor> fax, which one?
12:43:36 <benmachine> I wonder if it's wise for me to give my own code as an example of how I indent
12:43:38 <fax> I can't remember
12:43:39 <fax> :(
12:43:40 <fax> Ill look
12:43:43 <benmachine> given that no-one else has ever had to read my code ever
12:43:50 <fax> http://raincat.bysusanlin.com/
12:43:53 <benmachine> and even I think it's pretty wtf sometimes
12:43:53 <fax> oh it IS rainncat
12:44:00 <fax> it says Server not found
12:44:03 <benmachine> fax: there's a github thing which is newer
12:44:06 <fax> but I guess that's not really anything you can fix
12:44:15 <fax> (maybe I underestimate you though!)
12:44:25 <eggy_> benmachine: any reasonably complicated functional code is pretty wtf if you ask me
12:44:30 <benmachine> http://github.com/benmachine/stepeval/blob/master/src/Stepeval.hs this is how I indent
12:44:46 <roconnor> fax: hmm works for me
12:44:50 <eggy_> benmachine: thanks, I'll have a look
12:44:54 <roconnor> try a proxy server :P
12:45:04 <benmachine> it's weird how I think of 506 lines of haskell being lots
12:45:20 <benmachine> I've written two thousand lines of C in a tiny project
12:45:37 <benmachine> haskell is just an incredibly compact language
12:46:02 <burp> 506? did you rewrite the kernel? ;)
12:46:13 <eggy_> benmachine: seeing your code, I rest my case :)
12:46:15 <benmachine> :P
12:46:25 <benmachine> eggy_: that's partially my fault
12:46:32 <benmachine> ref. the no-one else reads my code comment
12:46:44 <roconnor> benmachine: damn raincat is like 3000 lines of code
12:47:22 <benmachine> 3004 by my count :P
12:47:37 <benmachine> oh, including dist/build/autogen/Paths_Raincat.hs
12:47:45 <benmachine> so probably 2975
12:49:03 <roconnor> 2944 by my count
12:56:39 <b4taylor> So I am at a standstill with parsing libraries. None of them want to be lazy as far as I can tell.
12:57:01 <opqdonut> lazy how exactly?
12:57:54 <b4taylor> opqdonut: For instance say I want to parse a bunch of "foo" strings in "foo foo foo ..."
12:58:05 <b4taylor> So I get ["Foo","Foo",...]
12:58:13 <b4taylor> But if I take 1, it still does all the computation.
12:58:33 <c_wraith> have you tried uu-parsinglib?  I know its author put some effort into laziness
12:59:05 <c_wraith> of course, if your parser is ambiguous, the engine has no choice but to examine the entire match.  That could also be an issue
12:59:37 <b4taylor> c_wraith: This could be my problem I suppose. Let me test this on a simpler case.
13:01:46 <b4taylor> Oh wait, obviously because it's wrapped in an Either.
13:02:02 <b4taylor> Which means my parser will run as long as it likes.
13:02:13 <c_wraith> Ah, yes.  It needs to determine which case it's in.
13:02:20 <b4taylor> Errr I mean can until it produces error or the result.
13:02:24 <b4taylor> Hmmmm this is a pickle.
13:02:42 <b4taylor> This makes pipelining a lexer into a parser harder.
13:05:12 <Berengal> polyparse has lazy parsing, but when I tried it I realized I had to extend my token stream with ParseError tokens or get undefined whenever I got a parse error. In the end I decided it wasn't worth it
13:06:26 <CyberGarp> Okay, I made IO strict ,and got rid of state. Parsec is still not generating decent errors. Is there an alternative parser out there for Haskell?
13:13:12 <monochrom> Oh God. "The library comes with *excessive documentation*, including a proof of the monad laws." --- operational-0.2.0.0 announcement.
13:14:14 <jmcarthur> excessive documentation is always a good thing
13:14:28 <monochrom> so excessive it contains correctness proofs
13:14:51 <monochrom> but yes more people should do this
13:15:11 <fax> gross!! prooks are yucky
13:15:17 <tensorpudding> Cons of Haskell: Too much documentation
13:15:21 <Berengal> As long as it's structured so I can skip the boring parts...
13:15:27 <ezyang> oh man, QuickCheck can save failed test cases? I didn't know that
13:17:57 <Trinithis> @faq Can Haskell make me popular?
13:17:57 <lambdabot> The answer is: Yes! Haskell can do that.
13:18:57 <c_wraith> b4taylor: uu-parsinglib has a slightly different model.  It's an error-correcting parser, that gives you a simultaneous lazy parse result and lazy list of errors (and what action it took to correct the error).  You might be able to use something like that more easily than something that has to determine up-front if there was a parse error or not..
13:24:07 <jbapple> When installing quickcheck with cabal-install I get warning about an old base, but:
13:24:07 <jbapple> $ cabal upgrade base
13:24:07 <jbapple> Resolving dependencies...
13:24:07 <jbapple> cabal: Distribution/Client/Dependency/TopDown.hs:171:37-73: Non-exhaustive patterns in lambda
13:24:38 <mauke> upgrading base sounds like a bad idea
13:25:02 <monochrom> can't really upgrade base. base is tied to ghc.
13:25:05 <Igloo> I didn't think cabal would let you upgrade base
13:25:27 <b4taylor> c_wraith: I suppose I can ignore this for now. If it becomes a problem, it'll be easy enough to rewrite.
13:25:38 <Igloo> Oh, that's an unhandled case in cabal-install, not a base build failure
13:26:22 <monochrom> I would choose an older version of quickcheck to be compatible with my version of ghc and base etc.
13:26:46 <benmachine> that's still a bug though
13:27:05 <jbapple> monochrom: I have the latest GHC, and the same base error occurs when installing QC1.2
13:27:12 <benmachine> it's true that you can't upgrade base but non-exhaustive patterns in lambda is a bad error message
13:27:39 <jbapple> sorry, it's not a base error, it's a warning
13:28:02 <jbapple> and:
13:28:05 <jbapple>  $ ghc-pkg list base
13:28:05 <jbapple> /usr/local/lib/ghc-6.12.2/package.conf.d
13:28:05 <jbapple>    base-3.0.3.2
13:28:05 <jbapple>    base-4.2.0.1
13:28:18 <Igloo> Right, but I think you'd get a real error refusing to upgrade base, if the bug were fixed
13:29:13 <jbapple> Igloo: Fair enough. I don't understand why cabal-install QC warns about an outdated base, though
13:29:25 <benmachine> that's a different issue
13:29:30 <benmachine> that cabal really needs to document better
13:29:34 <benmachine> because it confuses everyone :)
13:29:40 <Igloo> It's probably not get an upper bound on the base version, so cabal uses base 3 by default
13:29:58 <benmachine> basically when base upgraded from version 3 to 4 loads of packages broke because they didn't specify an upper bound
13:30:19 <benmachine> the only way to fix this in general was to make cabal-install default to base3 if no upper bound is specified
13:30:29 <benmachine> all new packages must specify an upper bound on base
13:30:36 <benmachine> or, should, anyway
13:31:22 <jbapple> that's pretty confusing.
13:31:37 <benmachine> well
13:31:44 <jbapple> But I think I understand why it is the way it is
13:31:45 <benmachine> it wasn't such an issue until GHC 6.12 came out
13:32:00 <benmachine> because it wasn't until 6.12 that using base3 was punishable by a warning
13:32:09 <benmachine> so most people didn't bother fixing it
13:36:55 <Veinor> random idea: remember the milk bindings
13:40:18 <pastorn> hello
13:40:30 <pastorn> how do i get a time to base events on?
13:40:44 <pastorn> i want a Double, so that i can base events on it
13:40:59 <monochrom> ONOES, reading the Monad Zipper draft leads to Monatron, Monatron leads to codensity.
13:41:11 <pastorn> Data.Time seems too messy to be of any use here
13:42:51 <ClaudiusMaximus> @hoogle utcr
13:42:52 <lambdabot> No results found
13:43:36 <ClaudiusMaximus> pastorn: http://hackage.haskell.org/packages/archive/hosc/0.7/doc/html/Sound-OpenSoundControl-Time.html#v:utcr
13:43:46 <ClaudiusMaximus> pastorn: is what i used in one project...
13:44:50 <pastorn> ClaudiusMaximus: cool
13:45:06 <ClaudiusMaximus> the source uses Data.Time
13:45:33 <sclv> Anyone try happstack with 6.12.2 yet?
13:48:08 <sunrayser> is there any chance to have these two data declarations separated? test = [d| data A = A B; data B = B A |] (like test = [d| data A = A B |] test2 = [d| data B = B A |] but that doesn't work)
13:49:56 <aavogt> sunrayser: sure, test has type   Q [Dec]
13:50:05 <sunrayser> well maybe I shoud pull them apart by splitting the [Dec]
13:50:16 <aavogt> and it has two elements
13:50:35 <sunrayser> can I split them outside the Q monad or only inside it?
13:50:52 <aavogt> only inside it
13:51:59 <sunrayser> ok, thanks.. it's just the fact that I'll have to put a whole AST representation into that Q [Dec] but maybe I can get along inside the Q
13:52:29 <sunrayser> I mean lots of declarations and wanted to keep the code tidy
13:53:53 <sunrayser> and is there any way other than separating with ";"? Like some tricky indentation or something
13:54:16 <aavogt> if you don't use the quotations you can keep them separate (though maybe you have to use newName, instead of ' to quote the types)
13:54:31 <aavogt> sunrayser: you can stick newlines in there
13:54:46 <sunrayser> aavogt: but that gives me parse error
13:55:00 <aavogt> sunrayser: put a newline before the first data
13:56:05 <sunrayser> aavogt: hmm, works for the 3rd try.. and what did you say about not using quotations?
13:56:28 <aavogt> you can construct those declarations yourself
13:56:33 <sunrayser> I didn't get the 'name notation yet, I'm using mkNames everywhere
13:57:13 <aavogt> sunrayser: if you use   'Foo  instead of   mkName "Foo"  typos will be caught earlier
13:57:26 <aavogt> well maybe not, but it's prettier that way
13:57:33 <sunrayser> aavogt: you mean manually entering DataD's and Dec's?
13:57:42 <aavogt> yeah
13:57:55 <sunrayser> that would be big... for me.. the original declaration list is around 250 lines
13:58:51 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25071#a25071
13:59:44 <aavogt> sunrayser: I meant using dataD and others
13:59:54 <sunrayser> aavogt: ok can you take a quick look at this? The question is: what can be done better? http://pastebin.com/ku7TLBJi
14:00:20 <sunrayser> I'm pretty new at TH
14:00:33 <aavogt> so the stuff with 'Name or ''Name instead of  mkName "Name"
14:00:44 <roconnor> @quote
14:00:45 <lambdabot> clarkb, says:  in CS they dont teach you to program...You learn Data Structures, Algorithms, Logic, Discrete Math, Language theory, etc and happen to pick up programming on the way
14:01:02 <mreh> true
14:01:02 <sunrayser> are they the same?
14:01:03 * hackagebot net-concurrent 0.0.1 - Concurrent over the network execution library  http://hackage.haskell.org/package/net-concurrent-0.0.1 (PaulSonkoly)
14:01:16 <aavogt> as far as I know
14:02:05 <sunrayser> aavogt: ok now what?  lexical error in string/character literal at character ')'
14:02:13 <sunrayser> for  AppT t (VarT $ 't)
14:02:31 <aavogt> {-# LANGUAGE TemplateHaskell #-}
14:03:18 <sunrayser> hmm, ok now stage error...
14:03:22 <aavogt> it might be a bit cleaner if you leave out some parentheses
14:03:43 <sunrayser> I only replaced one mkName with 't
14:04:20 <roconnor> what does (unsigned)(some_double) do in C?
14:04:23 <roconnor> does it round?
14:04:26 <roconnor> truncate?
14:04:44 <aavogt> sunrayser: I suppose that's the difference then. But you can use 'String and 'Int just fine
14:05:23 <aavogt> actually ''String ''Int, since those are types
14:05:30 <aavogt> not constructors (which get a single apostrophe)
14:05:54 <sunrayser> I was just pasting my error of Not in scope: data constructor `Int' :)
14:06:03 <mreh> roconnor: doesn't it go from unsigned to twos compliment
14:06:04 <sclv> are there changes with hGetContents in the new bytestring?
14:06:22 <mreh> it'll probably half it then negate that
14:06:36 <mreh> suck it and C... :D
14:07:14 <roconnor> mreh: when applied to a double?
14:07:27 <mreh> oh, you're going from twos compliment to unsigned
14:07:29 <sunrayser> aavogt: now some lexical errors, strange
14:07:46 <mreh> the most significant bit in two compliment is negative
14:07:54 <mreh> read it up
14:08:42 <roconnor> mreh: someone is casing double to unsigned
14:08:44 <mreh> what am I talkinga bout
14:09:04 <sunrayser> aavogt: wow two apostrophes work
14:09:06 <monochrom> roconnor: C standard 6.3.1.4 "When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined."
14:09:36 <roconnor> monochrom: thanks
14:09:40 <mreh> wow, that's quite an impressive sub-clause number
14:09:52 <sunrayser> aavogt: and that doesn't kill my syntax highlight
14:10:40 <dmead> > (read "1.0") :: Float
14:10:41 <lambdabot>   1.0
14:10:46 <dmead> > (read "1.0") :: String
14:10:46 <lambdabot>   "*Exception: Prelude.read: no parse
14:10:51 <dmead> > (read "1.0") :: Int
14:10:52 <lambdabot>   *Exception: Prelude.read: no parse
14:10:55 <dmead> > (read "1") :: Int
14:10:56 <lambdabot>   1
14:14:50 <aavogt> preflex: seen gwern
14:14:51 <preflex>  gwern was last seen on #xmonad 4 hours, 15 minutes and 23 seconds ago, saying: no
14:15:14 <jbapple> 7 Haskell projects accepted for Google Summer of Code 2010:
14:15:15 <newsham> > read "\"1.0\"" :: String
14:15:16 <lambdabot>   "1.0"
14:15:24 <jbapple> http://socghop.appspot.com/gsoc/program/list_projects/google/gsoc2010
14:15:27 <aavogt> @ask gwern is it intentional that Data/HList/MakeLabels.hs is not listed in the cabal file?
14:15:28 <lambdabot> Consider it noted.
14:15:46 <idnar> monochrom: I can't reconcile "fractional part is discarded" and "truncated toward zero"
14:15:53 <idnar> maybe I don't understand how floats are stored
14:16:55 <aavogt> as in, the TH there is a very small subset which is likely compatible across most versions of ghc
14:17:09 <newsham> idnar: same thing, no?
14:17:22 <newsham> -1.9  truncated towards zero = +0.9 to get -1.0
14:17:31 <newsham> 1.9 truncated towards zero = -0.9, to get 1.0
14:18:19 <idnar> newsham: yeah okay, maybe I just need more coffee
14:21:01 <aavogt> sunrayser: then pick an editor whose syntax highlighting respects TH :)
14:21:49 <sunrayser> aavogt: like which one? (if it works on Windows it's even better)
14:24:45 <_martin_> What's the best way to create a large Array that can be accessed from each iteration of a recursive function without copying it every time?
14:25:00 <ddarius> Just do it.
14:25:09 <_martin_> As a global variable, you mean?
14:25:16 <c_wraith> _martin_: you realize nothing is passed by copying in haskell?
14:25:25 <_martin_> No I didn't realize that, c_wraith
14:25:28 <benmachine> c_wraith: some things are modified by copying
14:25:29 <aavogt> sunrayser: the haskell modes for vim or emacs... but maybe some other editors have sane highlighting
14:25:40 <benmachine> _martin_: do you know about ST?
14:25:48 <_martin_> No.  Just came over from Python.
14:25:53 <benmachine> ah ok
14:26:08 <benmachine> well, until you care about performance, just do it
14:26:14 <benmachine> and hope the compiler does the right thing
14:26:26 <benmachine> when you've got a bit more experience you can look at the fastest ways of doing things
14:26:31 <benmachine> and the best ways of doing things
14:26:35 <sunrayser> aavogt: thanks for the tip (I'm using jEdit now)
14:26:42 <benmachine> but I wouldn't worry too much about it for now
14:26:49 <benmachine> wait
14:26:58 <benmachine> I assumed by accessed you meant modified
14:27:07 <benmachine> if you just meant accessed then that is easy
14:27:19 <benmachine> like c_wraith said, immutable values are passed by reference
14:27:28 <benmachine> hell, inlining means they're often not passed at all :P
14:27:42 <_martin_> oh ok
14:27:49 <_martin_> yeah immutable Array
14:27:59 <benmachine> immutable arrays won't be copied
14:28:09 <aavogt> they are copied when you update them though
14:28:21 <benmachine> yes
14:28:21 <_martin_> is "inlining" the same as a "where" clause?
14:28:26 <benmachine> no
14:28:38 <benmachine> inlining is a compiler optimisation
14:28:40 <benmachine> don't worry about it
14:28:53 <benmachine> either it happens or it doesn't, but basically it means that haskell function calls are very very cheap
14:28:59 <_martin_> Terrific
14:29:11 <benmachine> like, frequently zero cost because the compiler just removes them :P
14:29:22 <_martin_> Thanks for your help, benmachine and everyone!
14:29:26 <benmachine> np :)
14:57:42 <Philonous> The GPL covers the (inline) documentation of a source file as well, doesn't it?
14:58:32 <benmachine> I'd imagine so
14:59:38 <gwern> don't see how it couldn't
14:59:38 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
14:59:41 <gwern> @messages
14:59:41 <lambdabot> aavogt asked 44m 14s ago: is it intentional that Data/HList/MakeLabels.hs is not listed in the cabal file?
15:00:14 <gwern> aavogt: probably not
15:00:38 <gwern> aavogt: if I omitted it intentionally, as I think I would have, it would've been because it didn't compile. did you fix it?
15:01:43 <Philonous> Yes, it's sort of obvious. Though that means I have to make up my own documentation for about 50 or functions that I bind via FFI
15:02:59 <CyberGarp> I have a short example that shows my Parsec problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25072#a25072
15:03:29 <CyberGarp> Essentially when nothing is matched by the grammar, it consumes what it can and then exits without error. In this case, there is an "x" at the end of the string being parsed.
15:04:30 <aavogt> gwern: it compiles just fine without any changes
15:04:58 <gwern> even months back?
15:05:11 <aavogt> how do you mean months back?
15:05:29 <gwern> changes since my upload before last
15:05:59 <aavogt> CyberGarp: after you're done parsing your useful results, use the `eof' parser to make sure you've consumed everything
15:06:05 <CyberGarp> aah
15:06:19 <CyberGarp> I have that in the main one I was trying to simplify
15:06:25 <CyberGarp> but I made it "optional"
15:06:28 <CyberGarp> That must be it.
15:08:06 <aavogt> gwern: there's a patch 20100218005946 that comments some stuff out
15:08:30 <CyberGarp> YAH! My parser now blows chunks properly.
15:08:51 <monochrom> It is correct behaviour for commaSep (and a whole bunch of other combinators like «many») to do maximal munch but not err on things it doesn't recognize. This is the only way things like «do { char '('; commaSep variable; char ')' }» could possibly work.
15:09:19 <CyberGarp> monochrom, I knew that but it's been a long brain fart of a day.
15:09:26 <aavogt> gwern: so I suppose it was broken, but only because the t1, t2, t3 tests were uncommented
15:09:54 <gwern> aavogt: that'd explain it then. fire off a patch to oleg and mention that in the long comment I suppose
15:10:00 <aavogt> I did
15:10:05 <aavogt> before we had this conversation
15:11:13 <aavogt> also, HList has some semblance of haddock docs now
15:11:25 <aavogt> or will once those patches get applied
15:12:48 <aavogt> it's sort of disorganized in that you're supposed to guess which of the multiple implementations you're supposed to use
15:15:36 <mun__> in the mathematical logic context, given \forall a, b. f(a) = g(b) and \forall a. f(a) = g(a) would it be correct to say the set of *models* of the second formula is a subset of the *models* of the first?
15:17:03 <monochrom> the other way round. stronger statement, fewer models.
15:17:13 <DanC> I'm still studying this maxflow stuff, and I looked at this and thought it looked really inefficient: mf g s t = mfmg (augmentGraph g) s t
15:17:52 <DanC> why compute the whole augmentGraph and then trace from s to t? but then... haskell is non-strict; does the non-strictness cross function boundaries?
15:18:03 <DanC> (I'm just learning haskell)
15:18:07 <mun__> monochrom, yeah, the second is stronger right?
15:18:26 <monochrom> the first is stronger.
15:18:54 <mun__> monochrom, right. thanks
15:19:46 <benmachine> DanC: non-strict goes EVERYWHERE :O
15:20:27 <DanC> how is it implemented? is there a short article I could read?
15:21:01 <benmachine> non-strictness?
15:21:13 <[swift]1> so i have this piece of code "do { y <- x ; (everywhereM $ mkM f) $ y }"
15:21:19 <[swift]1> is there any way i can get rid of that bind?
15:21:20 <DanC> yeah... well... how do haskell compilers work in general?
15:21:35 <benmachine> with difficulty :P
15:21:38 <Botje> [swift]1: x >>= everywhereM . mkM f
15:21:46 <Botje> wait, no
15:21:52 <gwern> @undo do { y <- x ; (everywhereM $ mkM f) $ y }
15:21:53 <lambdabot> x >>= \ y -> (everywhereM $ mkM f) $ y
15:21:54 <Botje> [swift]1: x >>= (everywhereM $ mkM f)
15:22:01 <benmachine> well, by which I mean they tend to be highly ingenious devices
15:22:02 <monochrom> No short article. Apart from Cale's. But Cale doesn't store it in any electronic form. You have to ask him to manually type it out again. (What a roundabout way to demonstrate an implementation of non-strict.)
15:22:18 <gwern> benmachine: the classic answer is 'very well'
15:22:28 <benmachine> gwern: heh :)
15:22:28 <[swift]1> Botje, gwern: thanks!
15:22:32 <benmachine> there are loads of articles about the implementation of lazy languages
15:22:37 <benmachine> but I couldn't comment on "short"
15:22:41 <benmachine> because I don't tend to read them >_>
15:22:54 <benmachine> monochrom: hey have you seen my evaluator thing? :P
15:23:05 <benmachine> it was partly Cale-inspired (and -encouraged)
15:23:05 <monochrom> I think so.
15:23:10 <benmachine> k
15:23:12 <c_wraith> this is where I wish we had a gui for vacuum.
15:23:17 * benmachine stops talking about it then
15:23:17 <Philonous> DanC: Values are stored as so called "thunks", a pieve of code that, when called, produces the value. The first time it overwrites itself with the value it produced
15:23:25 <monochrom> Perhaps it will do for now.
15:23:38 <Philonous> DanC: The first time it is executed it overwrites iteself*
15:23:55 <monochrom> Does it work well for things like «take 3 (repeat 'x')»?
15:23:59 <DanC> wow. that's a *very* short article, Philonous. :)
15:24:38 <benmachine> monochrom: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=take+3+(repeat+'x') evidently not
15:24:56 <benmachine> hmmm
15:25:01 <DanC> does the interpreter work by compiling and running, a la scala (or python)? or is there a separate mechanism?
15:25:14 <DanC> (I guess perl is compiled too, sorta)
15:25:19 <benmachine> DanC: I believe ghci compiles to bytecode
15:25:22 <monochrom> err your Prelude lacks repeat.
15:25:25 <benmachine> but ghc compiles to native
15:25:32 <DanC> ok
15:25:37 <benmachine> oh well that wouldn't help :)
15:25:39 <tensorpudding> GHC also emits C if you tell it to.
15:25:42 <benmachine> but it still shouldn't error out
15:25:51 <sm> oh! now there's a haskell logo I like.. http://hackage.haskell.org/trac/summer-of-code/ticket/33
15:25:55 * benmachine goes and looks up need match
15:26:12 <benmachine> oh, patbind
15:26:14 <benmachine> huh
15:26:17 <DanC> is the bytecode language novel? or just a register/stack deely?
15:26:17 <Philonous> sm: Could as well be a scheme logo
15:26:28 * Cale wonders whether his brain doesn't count as 'electronic form'
15:26:29 <monochrom> You also lack the ability to compute 3-1 :)
15:26:30 <c_wraith> DanC: think of it in terms of constructors and pattern matching.  pattern matching drives evaluation.  When an expression is pattern matched on, that's what forces the evaluation of the constructor that is the head of the expression.
15:26:33 <sm> that is true
15:26:35 <benmachine> monochrom: I do not
15:26:50 <benmachine> monochrom: arithmetic is hard-coded for now; it's also computed lazily
15:27:00 <benmachine> oh hi Cale
15:27:04 * benmachine hugs Cale
15:27:14 <Cale> What's up?
15:27:17 <DanC> unless it's irrefutable, right c_wraith ?
15:27:22 <c_wraith> DanC: at that point, as much code will be executed as necessary for it to determine the constructor, then no more.
15:27:23 <benmachine> nothing in particular :)
15:27:43 <c_wraith> DanC:  sure.  the seq function is also an exception.  But those are exceptions, not the general rule
15:27:50 <DanC> right.ok.
15:29:31 <benmachine> monochrom: ooh I found a bug
15:29:38 <benmachine> this is going to keep me up :P
15:29:44 <monochrom> oh yuck
15:30:22 <benmachine> it's mostly going to keep me up because I'm halfway through a refactor so I can't easily just fix stuff >_>
15:30:29 <benmachine> everything else is in an incoherent state
15:30:50 <benmachine> and since I haven't touched it in like two weeks I have to first spend half an hour trying to work out what the heck I was doing anyways
15:31:17 <benmachine> heehee I implemented Show (Exp -> Exp) in an entirely silly way
15:33:02 <DanC> hmm... so code converted from haskell to scala could be quite inefficient, if I'm not real careful
15:33:15 <gwern> that's usually the case
15:33:37 <benmachine> converting from one language to another without respecting the differing ways of doing things
15:33:44 <benmachine> is never going to work particularly well
15:33:56 <benmachine> and haskell tends to have more different ways of doing things than most
15:33:57 <DanC> but haskell's differences are non-local
15:34:06 <DanC> yeah... more different than most
15:34:07 <dibblego> it won't work, let alone be inefficient
15:34:36 <gwern> probably be better off targeting the jvm directly
15:34:37 <DanC> won't work? care to elaborate?
15:34:40 <gwern> why go through scala?
15:34:52 <monochrom> > take 3 (repeat 'x')
15:34:53 <lambdabot>   "xxx"
15:35:01 <gwern> haskell has been compiled to jvm before, but to scala?
15:35:04 <monochrom> won't work in SML for example
15:35:26 <dibblego> Scala/Java doesn't have the libraries, is eager in its argument evaluation and emulating laziness in Scala is a hack that won't work
15:35:31 <monochrom> or this one...
15:35:39 <DanC> scala has lazy constructs; e.g. (repeat 'x') is pretty much like a scala stream
15:35:41 <monochrom> > const 0 (let x = x+1 in x)
15:35:42 <lambdabot>   0
15:36:10 <dibblego> consider changing all your HOFs that once took (a -> b) to now take ((=>A) => B) and since (=>A) won't unify with A now you're in a spot of bother
15:36:20 <dibblego> Scala's laziness is broken
15:36:27 <DanC> "HOF"?
15:36:37 <dibblego> also, no it's not like Stream (scala.Stream is even more broken)
15:36:44 <dibblego> Higher-Order Function
15:36:44 <c_wraith> higher-order functions
15:37:14 <DanC> hmm... argument by assertion. 2 can play at this game: yes, it is like Stream.
15:37:24 <c_wraith> whether a function is lazy or not shows up in the type in scala?  That's unfortunate.
15:37:37 <dibblego> it's not an argument by assertion; I just don't have the burden of proof :)
15:37:40 <benmachine> are they like python generators?
15:37:59 <dibblego> (furthermore, the brokenness of Stream is very well accepted by the Scala community)
15:38:16 <dibblego> no, Stream is like this: data Stream a = Nil | Cons !a (Stream a)
15:38:26 <benmachine> oh
15:38:47 <dibblego> and not quite like that because Scala's laziness itself is broken
15:39:25 <DanC> broken... care to elaborate?
15:39:31 <dibblego> I did earlier
15:40:01 <dibblego> map takes a function that is strict in its argument
15:40:05 <benmachine> you mean broken in that it's incompatible with strictness which is the default?
15:40:16 <dibblego> go right ahead and rewrite all the libraries and you're still with a big problem
15:40:22 <benmachine> why do I keep talking as if I know stuff
15:40:49 <dibblego> ((=>A) => B) is not unifiable with (A => B)
15:41:23 <DanC> is a unifiable with !a ?
15:41:50 <benmachine> well !a isn't a type really
15:41:58 <benmachine> it's the type a, and a strictness annotation
15:42:22 <benmachine> and yes, the type a is unifiable with a :)
15:42:44 <benmachine> in general strictness information isn't in the type in haskell
15:43:06 <benmachine> it's either implicit in the definition, explicit in the definition, or a property of some data constructor
15:43:22 <benmachine> (note, data constructor not type constructor)
15:44:24 <dmhouse> Hmm, can you have strictness annotations on a type variable?
15:44:24 <dmhouse> Surely they're just in patterns and constructor arguments
15:44:38 <benmachine> you can't have strictness annotations on type variables
15:44:42 <DanC> as to why scala... somebody suggested using hadoop to run this maxflow algorithm over a big data set.
15:44:46 <benmachine> except inasmuch as
15:44:51 <[swift]1> hmm, i feel like i don't really understand extT and extM in SYB. it seems like when I use a transformation constructed by: mkM (f `extM` g), the changes made by g are ignored. is that the expected result, and if so, how can I make it so that f and g's changes are both applied?
15:44:56 <DanC> doesn't seem like a good match to me
15:45:05 <DanC> but I'm studying the approach
15:45:09 <benmachine> data Strict a = Strict !a -- the stricness annotation is *kinda* on a type variable
15:45:15 <benmachine> but not in a type
15:45:39 <monochrom> Hahaha meaningful identifier
15:46:02 <benmachine> [swift]1: I'm not familiar with mkM but extT only applies the first function if the second one can't be applied
15:46:20 * DanC gets the T-5min warning for dinner
15:46:21 <benmachine> [swift]1: I guess you'd do something like f `extT` g . f
15:46:33 <benmachine> or f . g
15:47:02 <c_wraith> Is there some reason why unbox-strict-fields isn't the default behavior?
15:47:02 <[swift]1> benmachine: well the thing is, f and g can't be composed because i'm making changes to an AST and f and g operate on two different data types found within the AST
15:47:10 <benmachine> [swift]1: I think the way to think of extT is to imagine like a chain of functions, and the rightmost matching one is applied
15:47:19 <benmachine> [swift]1: then how can they both be applied?
15:47:25 <[swift]1> benmachine: surely they should be disjoint in my case, though?
15:47:40 <[swift]1> benmachine: they can both be applied to different parts of the AST
15:47:44 <benmachine> what do you mean by the changes made by g are ignored
15:48:03 <benmachine> differently typed parts of the AST I assume?
15:48:15 <[swift]1> benmachine: i mean that the new AST output by the transformation reflect only the changes made by f
15:48:21 <[swift]1> benmachine: right
15:48:56 <[swift]1> benmachine: each subtransformation (f and g) works correctly individually, but i can't figure out how to compose them without just calling everywhereM twice
15:49:54 <benmachine> [swift]1: hmm, perhaps if one of the functions is applied, it doesn't also recurse into the structure?
15:50:05 <benmachine> i.e. it only recurses when the function is not applicable
15:50:14 <benmachine> so then you'd have f being
15:50:18 <benmachine> everywhereM yourfunc . f
15:50:20 <benmachine> or something
15:50:42 <benmachine> I dunno I tend to use gmapT explicitly >_>
15:50:53 <benmachine> and I don't even know anything about the *M functions really
15:51:01 <benmachine> so I can't be of any further help
15:51:05 <[swift]1> benmachine: that's possible, though I thought there was an variation of everywhere specifically for that situation
15:51:19 <[swift]1> benmachine: (wanting to stop the recursion early)
15:51:36 <benmachine> there's a top-down and a bottom-up version
15:51:40 <benmachine> iirc
15:51:56 <benmachine> which differ in whether you recurse before or after applying the transformation
15:52:02 <[swift]1> benmachine: i was referring to everywhereBut actually
15:52:08 <benmachine> oh
15:52:16 <fps> could someone take a look at a short code snippet and point me in the right direction to get it working?
15:52:20 <benmachine> can I go back to saying "I dunno" that works well for me
15:52:33 <benmachine> fps: we can try :) hpaste.org
15:53:05 <[swift]1> benmachine: sounds good, that's the boat i'm in =) the SYB paper is mostly quite good but it'd be great if there were more detailed docs as well
15:53:42 <benmachine> [swift]1: imo there's no substitute for getting a ghci and just mucking about with it :)
15:53:44 <monochrom> fps: don't forget to unambiguously specify desired behaviour
15:54:34 <[swift]1> benmachine: =)
15:55:00 <fps> I am new to this...
15:55:21 <fps> I want to approximate the exponential function
15:55:39 <monochrom> nice
15:55:47 <fps> e.g. take 2 (exps 2)
15:56:11 <benmachine> that would give the first two approximations?
15:57:04 <fps> that should yield: 1 + 2/1!
15:57:05 * monochrom refrains from refining the specification to a solution, completely circumventing the planned erroneous code to be pasted
15:57:39 <monochrom> No, it should yield [1, 1+2/1!].
15:58:11 <monochrom> OTOH you could imagine (exps 2) !! 1 instead. And omit the ( )
15:58:35 <fps> ah, right
15:59:58 <fps> this is what I ultimately want: [1, 1 + x/1!, 1 + x/1! + x^2/2!, ..]
16:00:15 <benmachine> right
16:00:23 <benmachine> :t mapAccumR
16:00:24 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:00:41 <xerox> you can approximate exp by recursively applying the same lambda term
16:00:42 <benmachine> no that's not what you want
16:00:53 <benmachine> :t unfoldr -- maybe this
16:00:54 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:06:11 <scott__> Is there a subtraction analogue to sum for lists?
16:06:35 <monochrom> Perhaps there are infinitely many.
16:06:51 <monochrom> Here is one...
16:06:55 <scott__> Well, one in Haskell Prelude.  I know I could write foldl1 (-)
16:07:03 <c_wraith> :t negate . sum
16:07:04 <lambdabot> forall a. (Num a) => [a] -> a
16:07:11 <monochrom> > foldr1 subtract [3,1,4,1,5]
16:07:12 <lambdabot>   -4
16:07:50 <monochrom> monochrom's ambiguity hypothesis: if there are infinitely many, none is in the standard lib.
16:08:07 <c_wraith> the problem, of course, is that subtraction isn't associative.  My solution decides that each term is being subtracted from the running total, starting at zero
16:08:14 <p_l> monochrom: sounds a bit like Common Lisp..
16:08:26 <monochrom> Nice, great minds think alike.
16:08:34 <tromp_> > foldr1 subtract [3,1]
16:08:35 <lambdabot>   -2
16:08:56 <tromp_> > foldr1 subtract [3,1,4]
16:08:57 <lambdabot>   0
16:10:00 <Philonous> c_wraith: How is this different from subtracting the sum?
16:10:11 <cjay> @tell Lemmih the darcs url of SDL on hackage seems to be incorrect, and the example files for using the SDL binding on OS X are not in the tarball. Where can I find them?
16:10:11 <lambdabot> Consider it noted.
16:10:21 <c_wraith> Philonous: did you see my implementation?
16:10:26 <tromp_> it subtracts the sum of non-last from the last
16:10:34 <dolio> > (foldl1 (-) [1..10], negate $ sum [1..10])
16:10:35 <lambdabot>   (-53,-55)
16:11:05 <Philonous> c_wraith: No. But good to see I was not totally off base :>
16:12:54 <Lemmih> cjay: Yeah, sorry. I should really release a new version of hsSDL.
16:12:54 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
16:13:11 <dons> the SDL package is super popular
16:14:55 <Lemmih> cjay: To tell you the truth, I really don't know where the MacOSX example files are. The MacOSX stuff was added by a contributor who has mysteriously vanished in a puff of logic.
16:15:26 <Zao> Deep magic required to build things on OSX? I'm horribly surprised.
16:15:29 <cjay> uh
16:16:29 <Lemmih> Zao: SDL on Mac uses horrible CPP magic to initialize the library.
16:16:57 <Zao> Lemmih: I've had the honor of building native SDL on OSX once.
16:17:10 <Zao> Lemmih: I lost significant hair wrestling their bloody dyld.
16:17:24 <cjay> yeah when I read about the SDL initialization I had a hard time not to beat my head against the desk
16:17:43 <Zao> In the end, we settled for prebuilt binaries as I couldn't get it right after a week or two.
16:18:00 <Zao> Especially SDL_image and it's silly runtime loading of libpng and friends.
16:18:13 <Lemmih> Oh dear.
16:18:57 <cjay> well, macports can build it just fine
16:19:46 <syntaxglitch> hoorayz, complaining about SDL
16:20:35 <syntaxglitch> no that's fine SDL, you can replace main() using the C preprocessor, I'm sure that'll work just fine on Haskell code
16:20:38 * syntaxglitch grumbles
16:20:46 <benmachine> heh
16:21:15 <Zao> syntaxglitch: While the intent is a noble "ensure that platform bits are initialized", their implementation "#define main lol" isn't.
16:21:36 * syntaxglitch has used SDL with Haskell on three different operating systems, only Linux actually worked sensibly
16:21:52 <Zao> cjay: Can this fabled "macports" build a local non-superuser-needing one?
16:22:34 <cjay> Zao: no idea
16:22:42 * syntaxglitch assumes that everyone is aware of the obvious workaround, i.e. C wrapper that SDL can mess with that calls Haskell via FFI exports
16:22:45 <Lemmih> cjay: Brand new version out with the correct repo url.
16:22:56 * hackagebot SDL 0.5.10 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.5.10 (DavidHimmelstrup)
16:23:09 <Lemmih> I just love how easy it is to release new versions on hackage.
16:23:13 <interferon> is anyone doing work on a parallelized parsec?
16:23:15 <benmachine> :) n1
16:23:16 <cjay> Lemmih: thanks :)
16:23:27 <mun__> would it be correct to state  \forall t1, t2. f(t1) = g(t2) <=> \forall t1, t2. f(t1) = f(t2) /\ \forall t. f(t) = g(t) ?
16:25:40 <cjay> The OS X readme of the SDL binding says "We provide our own 'SDL_main' in c_main.c, which initializes the Haskell runtime and calls 'hs_main'". Is it hard to initialize the runtime from C?
16:25:43 <dolio> mun__: You should install Agda. Then you could write proofs to verify things like that.
16:26:17 <mun__> dolio, oh right
16:26:33 <syntaxglitch> cjay: just exporting a "main" function from Haskell via the FFI and calling that from C worked for me, I think
16:26:34 <mun__> dolio, but do you think that expression is correct?
16:26:39 <dolio> Yes.
16:26:41 <Lemmih> cjay: Not really. You can find the C file for doing it somewhere in the GHC docs.
16:27:19 <mun__> great thanks
16:27:20 <dolio> Well, I think the <= direction is correct.
16:27:22 <dons> jlouis: i can't parse this "The Erlang VM is much better at IO than the GHC compiler I wield and use for Haskell."
16:27:28 * syntaxglitch justed looked up some basic "how to use it" info on the FFI and it worked easily
16:27:40 <dolio> => seems right, too.
16:27:42 <benmachine> mun__: it sounds reasonable to me
16:27:47 <dons> jlouis: network socket io? io throughput? concurrent conns? and ghc vm vs erlang vm?
16:27:54 <mun__> benmachine, thanks
16:28:04 <dons> and you don't mean to use erlang vm vs ghc compiler (type error)
16:28:21 <benmachine> mun__: don't forget dolio :P
16:28:52 <mun__> thanks to u both, incl. dolio of course.
16:28:56 <cjay> syntaxglitch: thanks
16:29:06 <syntaxglitch> dons: I have a superball that rolls downhill faster than GHC does! Obviously this means that Haskell's performance is unacceptable.
16:30:08 <cjay> Lemmih: have you read syntaxglitch's answer? That makes me wonder if initializing the runtime is important or not.
16:30:27 <syntaxglitch> cjay, there's some minor initialization, I think
16:30:29 <dons> jlouis: you might mention the fact we have a major push for world-leading io scaling on at the moment, e.g. http://www.serpentine.com/blog/2010/01/22/new-ghc-io-manager-first-benchmark-numbers/
16:30:42 <cjay> ok
16:31:03 <syntaxglitch> I just remember it being stupidly simple to do, unlike everything else involving SDL apparently
16:31:15 <cjay> :)
16:31:32 <syntaxglitch> cjay: if you're still having trouble let me know, I'll dig out my code and hpaste it for you or something
16:31:47 <jlouis> dons: I agree the new IO layer will completely change the game in Haskells favor
16:32:40 <dons> see my early clarifying question
16:33:08 <dons> i don't quite understand the line currently (though i'm guessing at what you mean: something to do with scaling concurrent conns?)
16:33:25 <jlouis> no, network IO
16:33:32 <jlouis> we simply allocate too much
16:33:36 <dons> throughput?
16:33:47 <dons> oh. that's not ghc's fault. what library are you using?
16:33:52 <dons>  
16:34:01 <dons> e.g. zero-copy event + network-bytestring?
16:34:17 <jlouis> It is a combination of network-bytestring and Network.Socket at the moment
16:34:34 <dons> ok. so there's a known double copy in there somewhere that disappears when you move to event + network-bytestring.
16:34:36 <jlouis> zero-copy event I don't know about
16:34:43 <Lemmih> cjay: Well, you can try it out by linking with the rts after libsdl. Then it will use the 'main' from the rts instead of the 'main' from libsdl.
16:34:55 <jlouis> is it Tibbes event stuff?
16:34:57 <dons> but you should say that stuff "inefficiencies in memory use in the network socket layer"
16:35:00 <dons> jlouis: yeah.
16:35:07 <Lemmih> cjay: At least, I /think/ that's how I made it "work" once.
16:35:19 <dons> since "The Erlang VM is much better at IO than the GHC compiler I wield and use for Haskell." doesn't make sense to me :)
16:35:34 <jlouis> dons: i'll clarify it with an edit
16:35:34 <dons> i *bet* the erlang network lib is better optimized.
16:35:47 <dons> so relatively maturity of network/socket code in each lang. erlang wins
16:35:52 <dons> no questoin.
16:35:54 <jlouis> exactly
16:35:57 <dolio> mun__: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25077#a25077
16:36:13 <dons> ghc catching up with the epoll-based event io lib (and should win actually, given ghc's optimization skillz)
16:36:17 <Lemmih> cjay: Adding -lrts to ld-options or cc-options should do the trick, I think.
16:36:25 <dons> but prob. a year away from mainstream deployment
16:36:52 <dons> jlouis: thanks. i understand now. "much better at IO" makes my ears burn
16:37:20 <dons> good article, btw. rarely do we get to see such comparisons for such code bases
16:37:27 <dons> you could consider an experience report for e.g. HW
16:37:30 <syntaxglitch> Lemmih, for what it's worth I think my approach was to compile the C wrapper using gcc and let SDL mess with it, compile the Haskell files using GHC, then link all of the above at the end with GHC
16:37:44 <dons> at least some recommendations about what you'd like to be easier/possible in each toolchain
16:38:02 <jlouis> dons: edited, could you give it a glance?
16:38:15 <jlouis> and yes, I should perhaps do a write-up
16:39:00 <dons> i'd prob. specific say "the network IO layer (in particular, in memory use)"
16:39:02 <Lemmih> syntaxglitch: Yeah, that seems to be the correct approach.
16:39:07 <dons> since the IO layer isn't a real thing per se.
16:39:17 <dons> (i.e. erlang string io /= haskell bytestring ioo)
16:39:34 <dons> while presumably we share the underlying network/socket approaches
16:39:35 <mun__> in logic, is there a way to compute the following: C /\ D => C \/ ?? like as if it was to compute 1 + 2 = 2 + ??
16:39:47 <jlouis> In the Erlang VM, the C layer fill a buffer up with a "binary" and then this binary is sliced into windows. Thus parsing never calls realloc
16:40:06 <syntaxglitch> Lemmih, it was some minor relief that besides a few linker flags, the same C wrapper and makefile worked on both OS X and WinXP
16:40:09 <dons> that's how Data.Binary works
16:40:10 <jlouis> I would love to have that kind of approach for Haskell :P
16:40:12 <dons> but its not part of the vm.
16:40:17 <jlouis> right
16:40:27 <dons> its a library issue. and not related to io either (??)
16:40:29 <mun__> theorem provers let you verify but won't discover the missing sentence, right?
16:40:46 <dons> attoparsec is similar. we parse from buffers without reallocating.
16:40:48 * Lemmih is off to bed.
16:41:04 <jlouis> okie, then the attoparsec stuff I use now is fine
16:41:17 <dons> so in the network code, data is read off the wire with these 'views' onto the underlying packet?
16:41:25 <dons> or you mean zero-copying parsing?
16:41:41 * dons is confused again about what's being compared
16:42:04 <dons> attoparsec runs an incremental parser over a lazy bytestring, afaik, which ensures no reallocs/buffer chunking fun
16:42:29 <dons> now, you had me at the socket stuff. i know network-bytestring copies more than it should.
16:42:39 <dons> esp. if the erlang layer is written in C, not Erlang
16:43:26 <dons> do you use cereal or binary for parsing ?
16:43:39 <dons> or attoparsec only?
16:43:48 <jlouis> attoparsec currently. cereal for outgoing messages
16:43:56 <dons> interesting.
16:44:07 <dons> did the Mar 3 upgrade help? http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
16:44:11 <FunctorSalad> mun__, no, because the function (\x -> C \/ x) is not injective
16:44:38 <FunctorSalad> you need injectivity to "cancel" an operation like that
16:44:40 <jlouis> the outgoing parts doesn't show up in the profile graphs so I did not give it much attention
16:44:59 <mun__> FunctorSalad, but then could possible answers be generated?
16:45:09 <dons> might be interesting to do the parser in cereal (which was designed for parsing network protocol traffic here at galois) against attoparsec (designed for http headers :)
16:45:35 <FunctorSalad> mun__, in this case the equation can't be solved because any "C \/ x" will be stronger than C, but C /\ D is properly weaker than C
16:45:45 <FunctorSalad> mun__: (other way around)
16:46:00 <FunctorSalad> (swap stronger/weaker)
16:46:17 <dons> jlouis: anyway, interesting stuff.
16:46:39 <jlouis> dons: I have some changes coming up which improves several data representations internally. That ought to push Resident set size below 25 megabytes for most torrents
16:46:57 <mun__> FunctorSalad, but since the conclusion is weaker, why can't C \/ x be solved?
16:47:08 <CalJohn> > 2^31
16:47:09 <lambdabot>   2147483648
16:47:14 <jlouis> which is better than what etorrent ever did, I might add
16:47:30 <FunctorSalad> mun__, I thought you wanted a "C \/ x" formula that's *equivalent* to "C /\ D". don't know what you mean by 'solve'
16:47:41 <jlouis> I threw in another edit of the blogpost :)
16:48:12 <CalJohn> > 2^31 :: Int
16:48:13 <lambdabot>   2147483648
16:48:37 <mun__> FunctorSalad, oh. i meant, i'd like to find possible subformulae x can take.
16:49:21 <dons> jlouis: i think you can make a strong statement in the 'cons' for haskell: "If you're doing performance-oriented networking in Haskell, you *must* using bytestrings and network-bytestring, not String".
16:49:27 <dons> just say it, so no one makes that mistake again :)(
16:50:15 <mun__> FunctorSalad, e.g., x could be D
16:50:31 <dolio> x could be false.
16:51:01 <mun__> dolio, yes that's right.
16:51:14 <mun__> but are there supposed infinitely many possible instantiations?
16:51:31 <dolio> Well, false implies anything, so you can put anything in there.
16:51:43 <mads-> Hi. I would really like to learn Haskell. I come from a background in JAVA and C++. Can anyone recommend a good book?
16:52:01 <jlouis> dons: hah, done :)
16:52:06 <mun__> hmm ok
16:52:09 <[swift]1> hmm, cabal install packedstring isn't working for me (ghc 6.12.1); cabal says "base" needs to be in the build-depends, but I checked and it's already there
16:52:13 <IceDane> !rwh ?
16:52:16 <IceDane> meh
16:52:24 <IceDane> I suck at remembering ircbot commands
16:52:32 <dolio> You don't even need C /\ D. C => C \/ anything
16:52:40 <dons> [swift]1: probably you shouldn't use packedstring
16:52:50 <dons> [swift]1: but that's odd
16:52:54 <aavogt> @where rwh
16:52:54 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:53:05 <dons> you trying to install template-haskell, [swift]1 ?
16:53:10 <[swift]1> dons: i don't want to; my larger goal is using haskell-src-meta
16:53:13 <jlouis> dons: I sincerely hate it when people say "Haskell is slow". Because that is simply not true (as soon as you get the strictness right)
16:53:22 <[swift]1> dons: nah, that's working =)
16:53:39 <jlouis> and yes, I use a recent attoparsec
16:53:49 <dons> jlouis: ghc is a very good optimizing compiler, so yeah :)
16:53:53 <sproingie> naive idiomatic out-of-the-box haskell can often be called slow
16:53:58 <dons> and it has very fast threads.
16:54:00 <jlouis> indeed!
16:54:23 <dons> sproingie: so the point is whether haskell encourages naive code, and perhaps it does.
16:54:30 <sproingie> it's certainly more readable
16:54:40 <sproingie> well strings are about the same, but that's just one case
16:54:52 <dmead> > (read "1.0") :: Int
16:54:53 <lambdabot>   *Exception: Prelude.read: no parse
16:54:53 <sproingie> and when you get to mixing them you're really boned
16:54:59 <dmead> > (read "1") :: Int
16:55:00 <lambdabot>   1
16:55:03 <dmead> hey channel
16:55:12 <aavogt> hey dmead
16:55:16 <dmead> is there a way to typecheck something at runtime?
16:55:21 <dmead> like, that doesn't make a mess?
16:55:24 <mun__> dolio, sure. if i want to find x in \forall t1,t2. f(t1) = g(t2) <=> \forall t. f(t)=g(t) /\ X, X has to be something meaningful right?
16:55:34 <aavogt> no, Data.Dynamic is pretty ugly
16:56:07 <mun__> dolio, in that case, i'd expect \forall t1,t2. f(t1) = f(t2) to be a possible answer.
16:56:51 <aavogt> dmead: but what's your problem? consider that dynamic types is only a means to some end..
16:57:04 <FunctorSalad> mun__, that has no solution if there is t such that g(t) < f(t)
16:57:26 <FunctorSalad> like I said, you can't cancel "and" or "or" in the way you can cancel "+"
16:57:30 <FunctorSalad> it's not a group operation
16:57:38 <dolio> mun__: I wouldn't expect any tool to be able to solve something like that.
16:57:46 <orclev> how do you figure out where a particular class instance is located?
16:57:48 <FunctorSalad> "xor" is one though :)
16:58:09 <aavogt> orclev: :info ClassName in ghci
16:58:21 <dolio> mun__: Even proving it automatically if you supply a proposed X is probably an undecidable problem.
16:58:24 <orclev> aavogt: what if you don't have the instance imported yet?
16:58:38 <aavogt> then that doesn't work
16:58:39 <mun__> FunctorSalad, right..
16:58:44 <mun__> dolio, because it's FOL?
16:58:49 <dolio> Yes.
16:59:15 <dmead> > "poo"
16:59:16 <lambdabot>   "poo"
16:59:25 <orclev> the haddock for DiffTime claims there's an instance of Data defined for it, but I can't figure out what package it lives in
17:00:07 <aavogt> orclev: are you looking at documentation for your version of time?
17:00:18 <mun__> dolio, FunctorSalad thanks
17:00:37 <orclev> aavogt: I think, let me double check
17:00:47 <FunctorSalad> mun__, "and-ing" something with a fixed value C destroys information... it just "eats" anything that is larger than C :)
17:00:59 <aavogt> that instance is pretty new... I think it didn't exist when I wanted it half a year ago
17:01:02 * jlouis vanishes to the bed
17:01:14 <FunctorSalad> (I'm using order-words here, but in logic the order is simply "=>"
17:01:15 <FunctorSalad> )
17:02:15 <orclev> aavogt: yep, I'm .1 version behind the docs I'm looking at... figured the just released haskell platform would have the latest more or less of everything, but seems I was wrong
17:02:22 <FunctorSalad> while (+), XOR and (*) (unless C=0) don't :)
17:02:39 <[swift]1> trying to figure out this cabal error, i notice that i have both base-3.0.3.2 and base 4.2.0.0 installed. could this be the problem? (cabal is preferring the older base for building packedstring and it doesn't seem to work)
17:03:21 <monochrom> Suppose P⇒Q. The equation P = Q∧X has solutions. One solution is X=P. This is boring but it shows there are solutions.
17:03:29 <FunctorSalad> dolio, hmm... thought the emphasis here was on how to manipulate it symbolically, not decidability
17:03:38 <FunctorSalad> dolio, but I'm not sure
17:04:02 <monochrom> manipulate symbolically is a special case of decide.
17:04:14 <monochrom> probably decide is a special case of manipulate symbolically, too.
17:04:48 <FunctorSalad> monochrom, was that example in direct answer to me? about the g(t) = f(t) /\ X prob being unsolvable in some cases, even if X depends on t too
17:04:58 <monochrom> Agda is great for provable things but poor for unprovable things.
17:05:04 <FunctorSalad> (if any g(t) is > f(t))
17:05:17 <FunctorSalad> s/prob/prop/
17:05:46 <monochrom> I don't know whether it is a direct answer to you. I think it doesn't matter.
17:05:52 <FunctorSalad> I see that I had the sign backwards up there :)
17:06:13 <nominolo_> preflex: seen edwardk
17:06:14 <preflex>  edwardk was last seen on #haskell 3 days, 3 hours, 33 minutes and 28 seconds ago, saying: djahandarie: i'll take a look further when i get a chance
17:06:28 <djahandarie> o/
17:06:33 <djahandarie> Oh, not even me
17:06:34 * djahandarie sighs
17:06:35 <FunctorSalad> monochrom, you rarely refer to people by name, so it's a bit hard to know when you're correcting someone and when you're just explaining further :)
17:07:08 <monochrom> You can read what I say to decide.
17:07:11 <sproingie> i do that a lot too
17:07:44 <FunctorSalad> some and/or-equations do have equations, but I mean you can't solve them in the way you solve group terms
17:07:54 <FunctorSalad> *do have solutions
17:08:06 <dolio> FunctorSalad: If you want to know what X you can fill in for P => Q /\ X, then you have to in some sense decide the truth/provability of that sentence for any particular X.
17:08:15 <monochrom> Suppose someone claimed "P = Q∧X has solutions". Then what I said is "explain further". Suppose someone claimed "has no solution". Then what I said is correction.
17:09:00 <FunctorSalad> dolio, or just decide "P => Q", since that is the tightest case anyway
17:09:24 <FunctorSalad> err cancel that, that would be for \/
17:09:49 <FunctorSalad> for P => Q /\ X it's a bit less trivial to find the optimal X
17:09:54 <FunctorSalad> if any
17:10:06 <FunctorSalad> Q => P, I guess
17:10:32 <FunctorSalad> (and that's only a solution if P => Q...)
17:11:42 <dolio> And if P and Q are formulae in first-order logic (and X should be too), you're out of luck in general.
17:11:53 <FunctorSalad> so, I'd say "there are solutions iff P => Q, and in that case, the strongest solving X is Q => P"
17:12:22 <FunctorSalad> dolio, thought the P and Q are formal variables
17:12:26 <FunctorSalad> (atoms)
17:12:30 <mun__> FunctorSalad, dolio , but, theoretically, if i want to find X in \forall t1,t2. f(t1) = g(t2) <=> \forall t. f(t)=g(t) /\ X, a tool could try generating all possible models for the \forall t. f(t)=g(t) and find an expression that picks out models satisfying the antecedent, right?
17:12:55 <mun__> let alone decidability issues, that is.
17:13:38 <dmead> @hoogle unsafeperformio
17:13:38 <lambdabot> Foreign unsafePerformIO :: IO a -> a
17:13:38 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
17:13:40 <monochrom> In fact how do you parse  \forall t1,t2. f(t1) = g(t2) <=> \forall t. f(t)=g(t) /\ X ? I mean operator precedence and parenthesizing.
17:14:21 <dolio> He means the parenthesizing here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25077#a25077
17:14:27 <orclev> aavogt: ok, this time I double checked both the version of the library I'm using, and the haddock, but I can't find the instance... in this case it's for Convertible UTCTime SqlValue
17:14:52 <orclev> aavogt: the haddock for HDBC-2.2.4 claims there's an instance
17:15:53 <ologNation> I'm using DrIFT to derive XmlContent
17:16:18 <ologNation> I have a question, but I'm not sure how to say it.
17:16:23 <scotty> Can someone post an example read-eval-print program?
17:16:42 <scotty> I know about interact, but it only handles a single string.
17:16:51 <aavogt> orclev: unless it's in HDBC or the package that has convertible, I dunno where it would be
17:17:20 <aavogt> scotty: interact handles multiple lines if you break it up
17:17:44 <aavogt> @type \f -> interact (unlines . f . lines)
17:17:45 <lambdabot> ([String] -> [String]) -> IO ()
17:17:58 <scotty> But it also doesn't poll, right?
17:18:08 <orclev> aavogt: am I correct in assuming that if it's listed in the haddock for a package it has to be inside one of the modules defined in that package?
17:18:17 <aavogt> orclev: yes
17:18:29 <scotty> Ah, I found this: http://hackage.haskell.org/packages/archive/haskeline/0.6.2.2/doc/html/System-Console-Haskeline.html
17:18:36 <monochrom> An example read-eval-print program is «interact (unlines. map (show . (* 2) . read) . lines)». This is not "single string". Try it.
17:18:37 <aavogt> actually, it could be in one of the imports for that package
17:18:41 <scotty> Is this the most basic thing you could do?
17:18:54 * SubStack wonders if Haskeline has a vi mode
17:18:55 <aavogt> haskeline is a bit complicated
17:19:00 <scotty> Alright
17:19:02 <aavogt> SubStack: it claims to
17:19:14 <SubStack> aavogt: oh really!
17:19:19 <scotty> Well, doesn't interact wait until end of line to call your function?
17:19:22 <aavogt> yes really
17:19:37 * SubStack wishes to jump around as he does in a shell with set -o vi
17:19:46 <aavogt> scotty: well the problem with interact is that it might start outputting before you press enter
17:19:56 <aavogt> if your calculations are lazy enough...
17:20:07 <scotty> So, can you possibly post your version of a read-eval-print loop?
17:20:52 <monochrom> All read-eval-print loops wait until end of line.
17:20:58 <ologNation> I think that what I want is to tell it that Int derives XmlContent
17:21:02 <ologNation> But I don't know how to say that.
17:21:05 <aavogt>   forever $ do { l <- getLine; putStrLn (f l) }
17:21:54 <aavogt> monochrom: well say you use interact to prepend "foo" to your input...
17:22:08 <aavogt> then it is not a read-eval-print-loop?
17:22:17 <monochrom> well say mine is «interact (unlines. map (show . (* 2) . read) . lines)»
17:22:48 <monochrom> IIUC someone is claiming mine is not a real-eval-print loop. I challenge that. Show me empirical evidence.
17:23:06 <aavogt> I see
17:23:40 <aavogt> monochrom: you could still be wrong depending on what numeric defaulting set for your main
17:23:52 <scotty> I'm looking for a program that reads input until a carriage return, and the evaluates it.
17:23:53 <monochrom> Yes.
17:24:08 <aavogt> that should be exceedingly rare
17:24:30 <scotty> So, you type "3 enter 2 enter 1 enter" and it prints "3 2 1" after each press of enter.
17:24:59 <ray> so it looks into the future
17:25:15 <aavogt> @faq can haskell predict future user input?
17:25:15 <lambdabot> The answer is: Yes! Haskell can do that.
17:25:19 <monochrom> Or it prints "3 2 1" without looking.
17:25:32 <scotty> Argh
17:25:35 <monochrom> @hackage 3_2_1
17:25:35 <lambdabot> http://hackage.haskell.org/package/3_2_1
17:25:41 <scotty> So, you type "3 enter 2 enter 1 enter" and it prints "3\n2\n1" after each press of enter.
17:25:52 <scotty> No, I see what you mean.
17:26:08 <scotty> I phrased that poorly.
17:26:20 <scotty> It does not print the string "3 2 1" after each press of enter.
17:26:33 <scotty> Are you just screwing with me, or did you really not know what I meant?
17:26:35 <monochrom> Well mine prints "6\n4\n2\n"
17:26:53 <monochrom> (Have you even empirically tried?)
17:26:56 <scotty> I mean that after each press of enter it prints what you type.
17:27:18 <scotty> monochrom: Are you talking about the program with "forever" in it?
17:27:19 <monochrom> interact (unlines . lines)
17:27:51 <scotty> monochrom: No, I was trying the other example that was posted.
17:28:01 <monochrom> I am tired of needing to repeat myself. But here: <monochrom> An example read-eval-print program is «interact (unlines. map (show . (* 2) . read) . lines)». This is not "single string". Try it.
17:28:41 <SubStack> found it! editMode: Vi in .haskeline ^_^
17:28:55 * SubStack wonders where this is actually documented
17:29:17 <scotty> monochrom: It says "parse error."
17:29:19 <monochrom> The other example about forever (getLine and putStrLn) works too.
17:29:28 <[swift]1> argh. anyone got a copy of the haskell-src-meta patch for TH 2.4? the darcs repository mentioned on the haskell wiki appears to be down
17:29:30 <scotty> I couldn't get either to work.
17:29:51 <orlandu63> what does getContents do?
17:30:02 <scotty> Will they work in ghci, or do I have to compile them?
17:30:28 <aavogt> [swift]1: I have a copy on http://code.haskell.org/~aavogt, but that's down too
17:30:39 <monochrom> Mine works in GHCi. I just tried.
17:30:47 <[swift]1> aavogt: argh! =)
17:31:06 <scotty> This?: "interact (unlines. map (show . (* 2) . read) . lines)"
17:31:17 <monochrom> without the quotes
17:31:20 <scotty> Yeah
17:31:40 <monochrom> I can't reproduce your error.
17:31:45 <scotty> "parse error (possibly incorrect indentation)
17:31:55 <scotty> Hm...
17:32:20 <monochrom> reboot. reinstall ghc. buy a new computer. etc.
17:33:21 <[swift]1> aavogt: no idea if you'd know this, but do you think code.haskell.org might be back up soon?
17:34:02 <monochrom> :m + Control.Monad
17:34:09 <monochrom> forever $ do { l <- getLine; putStrLn l }
17:34:23 <monochrom> Entering those two lines into GHCi in that order also works.
17:34:44 <aavogt> I dunno when c.h.o is coming back
17:35:38 <[swift]1> aavogt: gotcha; at least my immediate problem is taken care of, though. thanks again!
17:36:13 <nus> hmm, looks like at least some daemons are running on c.h.o.
17:38:29 <nus> at least ssh is. an http request opens the socket then stucks :-/
17:41:15 <orclev> aavogt: I just solved the mystery of the missing Convertible UTCTime SqlValue instance
17:42:40 <orclev> on a scale of 1 to 10, how "bad" is it to tweak a cabal file to make a package "compatible" with a later one?
17:44:30 <aavogt> without breaking anything else?
17:44:39 <orclev> aavogt: presumably
17:45:00 <orclev> aavogt: problem is that the version of time I just installed to get the Data instances isn't compatible with the HDBC package
17:45:20 <orclev> aavogt: so HDBC doesn't "see" the UTCTime instances
17:45:38 <nus> orclev, that's what major/minor version numbers are.
17:46:08 <juhp> no utf8-string in ghc-6.12.2?
17:49:51 <Eduard_Munteanu> Hi.
17:52:21 <shapr> y0
17:54:11 <Eduard_Munteanu> I wonder... is there any Matlab/Octave (numerical) or Maxima (symbolic CAS) -like environment that uses Haskell?
17:54:31 <Eduard_Munteanu> It'd be pretty neat to replace that stuff.
17:54:45 <Eduard_Munteanu> and have Haskell syntax available.
17:54:50 <ologNation> Here's a paste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25079#a25079
17:56:37 <ologNation> It uses DrIFT to ...
17:58:59 <Eduard_Munteanu> ologNation: you meant that for me?
17:59:51 <ologNation> sure.
17:59:57 <ologNation> Do you know anything about drift?
18:00:44 <mamalujo> thats a generics tool?
18:01:52 <Eduard_Munteanu> Nope, lemme Google it...
18:02:27 <ologNation> Well, I'm using import Text.XML.HaXml.XmlContent
18:02:33 <ologNation> to "read" and "show" xml.
18:02:42 <ologNation> It is a great idea and seems to work well, but there's one thing.
18:03:00 <ologNation> You can only read and show things in the typeclass XmlContent.
18:03:09 <ologNation> And ghc doesn't let you simply "derive" this.
18:03:14 <orclev> is there a way to force cabal to install a package even if the dependencies aren't met?
18:03:22 <ologNation> So you have to use DrIFT to automatically write the instance declarations.
18:03:53 <ologNation> As you can see in my code (see paste above), I have a hand-made graph data type
18:03:59 <ologNation> and I am interested in writing it to a file as xml.
18:04:01 <Eduard_Munteanu> Yes...
18:04:23 <mamalujo> so it is a generics tool, a preprocessor that makes other classes have 'deriving' too. But I thought 'Instant Generics' was the most powerfull and fastest tool currently
18:04:29 <ologNation> I can use DrIFT to make it derive XmlContent, but since the Graph data type depends on Node and Edge,
18:04:36 <ologNation> these too must derive XmlContent.
18:04:49 <ologNation> mamalujo, I do not know about this.
18:05:09 <ologNation> The documentation for  Text.XML.HaXml.XmlContent
18:05:19 <ologNation> in the heirarchical libraries recommends DrIFT.
18:06:44 <orclev> so, no way to force cabal to install a package?
18:07:00 <Cale> orclev: "force"?
18:07:12 <aavogt> well you won't be able to compile it, if those dependencies were actually required
18:07:15 <orclev> Cale: complains that a dependency isn't being met
18:07:26 <Cale> orclev: If you don't have the dependencies it can't compile the code at all.
18:07:29 <orclev> aavogt: it compiles, I changed the cabal file to reference a later version
18:08:22 <Cale> It uses the dependency information in the .cabal file to determine how to compile the code in the first place.
18:08:51 <orclev> aavogt: it depends on convertible, and I hacked that one to use the latest version of time as well, but when I try to install HDBC it checks the dependency of convertible and decides it doesn't have the right time instance
18:09:01 <pielgrzym> hi :) I'm trying to understand some curried functions. I'm not sure of some list notation: zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys  < what is x in relation to xs? or y in relation to ys? I know I can create a list this way: 1:2:3:[] but I don't get this notation here :(
18:09:38 <Cale> pielgrzym: x and xs are just two variables, (x:xs) is a pattern which will match a nonempty list, and bind the first element of the list to x, and the remainder of the list to xs
18:10:01 <aavogt> xs stands for many x
18:10:01 <pielgrzym> Cale: aaah:) thanks a lot !!! :)
18:10:18 <Cale> Every list is either the empty list [], or is a nonempty list which has a first element x and a tail xs, written (x:xs)
18:10:19 <pielgrzym> aavogt: hehe, indeed :] now it makes sense :) aaaawesome :)
18:10:50 <orclev> when cabal checks the dependency of a package, does it pull that info off hackage, or can I find that file someplace and edit it?
18:10:55 <Eduard_Munteanu> You can think of it as 'this' and 'rest', 'rest' being xs.
18:10:56 <pielgrzym> Cale: we can't define the list other way round right? so how does 'last' work?
18:11:17 <pielgrzym> like xs:x
18:11:20 <Cale> pielgrzym: last [x] = x; last (x:xs) = last xs
18:11:27 <aavogt> > let xs:x = "hello" in x ++ [xs]
18:11:28 <lambdabot>   "elloh"
18:11:31 <Eduard_Munteanu> pielgrzym: the cons operator won't work that way.
18:11:43 <pielgrzym> God, this is sooo awesome :)
18:11:46 <aavogt> the variable names don't matter
18:11:48 <pielgrzym> Cale: recursion! hah
18:11:50 <Eduard_Munteanu> pielgrzym: x:xs means element x added to list xs.
18:11:54 <ologNation> I think that I will be happy if I figure out how to declare Int as an instance of XmlContent, or if I can figure out how to get Drift to do it for me.
18:11:55 <Cale> pielgrzym: xs:x will just bind the first element of the list to xs, and the rest of the list to x
18:11:57 <clanehin> This is a thing I did to memoize data streams, wish for feedback:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25080#a25080
18:12:20 <Cale> pielgrzym: which reverses the usual convention of naming lists with variable names ending in 's' (think plural)
18:12:21 <pielgrzym> Eduard_Munteanu, Cale: I understand - this was just to make my question more readable :)
18:12:24 <aavogt> why must haddock be so annoying?
18:12:32 <ologNation> aavogt, here here.
18:12:38 <orclev> aavogt: seconded
18:12:48 <orclev> or is that thirded?
18:12:59 <ologNation> orclev, thirded, I think.
18:13:00 <clanehin> fourthed
18:13:03 <Eduard_Munteanu> Cale: um, what do you mean, [1]:2 sure makes no sense :/
18:13:05 <ologNation> That's concensus.
18:13:15 <Eduard_Munteanu> > 1:[2]
18:13:15 * aavogt is trying to get Language.Haskell.TH to be pretty
18:13:16 <lambdabot>   [1,2]
18:13:20 <Eduard_Munteanu> > [1]:2
18:13:21 <lambdabot>   No instance for (GHC.Num.Num [[t]])
18:13:21 <lambdabot>    arising from the literal `2' at <int...
18:13:26 <Cale> Eduard_Munteanu: right, but (xs:x) is a perfectly good pattern to match against
18:13:49 <Cale> > let f [] = 0; f (xs:x) = 1 + f x in f [1,2,3]
18:13:50 <lambdabot>   3
18:13:52 <orclev> haddock is functional, not pretty (no pun intended)
18:14:02 <Cale> It's just confusing
18:14:12 <Cale> because it breaks our usual conventions about variable naming ;)
18:14:15 <pielgrzym> http://learnyouahaskell.com/higher-order-functions - there is this example of zipWith' here. Why doesn't it work at all in ghci and has to be :l from file instead? can't I declare types in ghci? I've tried let stuff :: a -> b but no success :/
18:14:16 <Eduard_Munteanu> Cale: oh.
18:14:36 <Cale> pielgrzym: ghci mostly just wants expressions, rather than declarations
18:14:51 <aavogt> well to be able to attach documentation to constructor parameters those constructors need named fields
18:14:55 <Cale> pielgrzym: Normally you should keep two windows open: one with your text editor and source code, the other with ghci
18:15:10 <Cale> pielgrzym: When you change the source, you can :r in ghci to reload the file
18:15:15 <aavogt> pielgrzym: that's allowed
18:15:19 <pielgrzym> Cale: ah, tmux'es split window comes in handy here :]
18:15:38 <pielgrzym> aavogt: the first sentence - I have to think it over;)
18:15:44 <Eduard_Munteanu> Or a tiling window manager ;)
18:15:54 <aavogt> > let f = ('a':) :: Char -> String -> String in f "-ok"
18:15:55 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
18:15:55 <lambdabot>         against inferred type...
18:16:02 <aavogt> > let f = ('a':) :: String -> String in f "-ok"
18:16:03 <lambdabot>   "a-ok"
18:16:12 <pielgrzym> Eduard_Munteanu: I already use xmonad :P that's how I've fell in love with haskell. xmonad is absolutely brilliant :)
18:16:21 <Eduard_Munteanu> pielgrzym: that's the spirit :)
18:16:43 <aavogt> but when f takes some arguments, you don't name them in the type signature that is attached to it's RHS
18:16:49 <Cale> pielgrzym: ghci will happen to accept declarations prefixed with 'let', but it won't accept all types of other declarations you might want to make, and it can e a bit finicky about keeping such temporary definitions around
18:17:00 <Cale> (when you reload a file, it seems to drop them)
18:17:09 <pielgrzym> aavogt: ah :) hmm
18:17:14 <orclev> xmonad is brillient, and so is haskell for the most part... but I'm slowly growing to hate class instances
18:17:35 <Cale> orclev: What about them?
18:18:20 <mamalujo> well, Id like to see about half a dozen extensions to class mechanism implemented :)
18:18:35 <Cale> mamalujo: anything in particular?
18:18:39 <orclev> Cale: you get wierd hard to diagnose errors when a package defines an instance for a type that's defined in another package
18:18:56 <Cale> orclev: yeah, orphans are irritating
18:19:33 <Cale> There's a general style rule which says that instances should go in either the module defining a class or the module defining the datatype
18:19:40 <Cale> But things don't always work out that way.
18:20:00 <aavogt> that's for compilation efficiency to
18:20:11 <mamalujo> class aliases, constrant families, closed classes, ability to pass an explicit dictionary, generalise defaulting mechanism..
18:20:20 <Cale> (and it's generally considered still a good thing that it's possible to define orphan instances, even though it can create these incompatibility problems)
18:20:51 <orclev> Cale: then there's the issue I have now, which is that I'm using time-1.2.0 because I want the Data UTCTime instance, but then I can't use Convertible UTCTime SqlValue because it's defined in HDBC-2.2.4 which links against time-1.1.4
18:20:56 <aavogt> mamalujo: what's different there from passing some data containing functions around anyways?
18:21:01 <Cale> I'm not sure I agree about the explicit dictionary passing thing, but the first three sound like good ideas to me
18:21:30 <aavogt> can't you already close classes through the module system?
18:21:35 <Eduard_Munteanu> Now that's interesting... our teacher telling us to write our Matlab code in a functional way. If only that was reasonable to do in Haskell...
18:21:43 <Cale> The explicit dictionary passing would act like implicit parameters, and those are already a questionable idea to begin with
18:21:54 <Eduard_Munteanu> But I'm afraid I'm gonna lose lots of time doing the same stuff in Haskell.
18:22:14 <mamalujo> aavogt, but the typing mechanism doesn't get the chance to exploit this fact
18:22:26 <Cale> orclev: Building everything against a consistent set of versions of the packages is always a good idea.
18:22:27 <aavogt> true
18:22:39 <mamalujo> and I saw a post on explicit dictionaries, yes it can be done, but its fairly messy
18:22:45 <Cale> orclev: I try to avoid having more than one version of any package installed. It can be tricky.
18:22:49 <orclev> Cale: yes, but I can't do that and still get an instance of Data for UTCTime
18:23:22 <Cale> orclev: Update HDBC to use the newer version of time?
18:23:39 <orclev> Cale: tried, complains that convertible depends on 1.1.4
18:23:51 <Cale> Okay, so then convertible needs updating as well.
18:23:57 <pielgrzym> ok, I've tried to make a function that will check if an element is in the list (the hard way :P). Apparently I'm an idiot: let isInside a [b] = isInside a (b:bs) | (a == b) = True | otherwise isInside a bs
18:23:59 <mamalujo> a paper on OO idioms in haskell shows how if one could declare a class closed , better specialisation of types could happen so you would in effect have a multimethods like mechanism in haskell..
18:24:02 <orclev> Cale: so I update that, and it works fine, but HDBC still seems to think convertible depends on the older version
18:24:38 <orclev> Cale: hence my question about if I could just cabal to install HDBC anyway
18:24:51 <orclev> just force that is
18:24:55 <Eduard_Munteanu> pielgrzym: have you included a definition for the case when [b] is empty?
18:24:58 <Cale> orclev: hmm... check the output of ghc-pkg describe convertible
18:25:15 <pielgrzym> Eduard_Munteanu: nope. let me tinker around it
18:25:22 <orclev> Cale: shows the right time version
18:25:25 <Philonous> Why would one want to have closed type classes?
18:25:28 <Cale> pielgrzym: Note: there's no way that your function would ever produce the value False
18:25:34 <Eduard_Munteanu> pielgrzym: you're pretty much depending on that whether or not you're supplying an empty list or not
18:26:07 <pielgrzym> Cale: true :D
18:26:10 <Cale> Well, really what we need (perhaps) is a proper kind system.
18:26:25 <pielgrzym> Eduard_Munteanu: indeed :) let me fix it
18:26:34 <Cale> Something like Tim Sheard's Omega
18:26:57 <Cale> Closed typeclasses would basically be an approximation to that
18:27:31 * orclev is about to give up on getting HStringTemplate, HDBC, and UTCTime to work together
18:27:46 <Cale> You could define typeclasses or type families which only had a specific set of types as instances, behaving a bit like kinds.
18:28:17 <mamalujo> simon said datakinds were on his todo list..
18:28:18 <dolio> Datakinds would probably be preferable.
18:28:30 <dolio> Although closed classes would be useful for other things.
18:28:30 <Cale> orclev: What does ghc-pkg describe convertible say that it's depending on?
18:28:50 <orclev> Cale: time-1.2.0.1
18:29:01 <Eduard_Munteanu> Yeah, I don't really get what kinds are for, it seems their use is pretty limited for internal stuff, like unboxed types.
18:29:38 <pielgrzym> Eduard_Munteanu, Cale: this is wrong too: http://wklej.org/id/323759/
18:29:38 <Cale> Eduard_Munteanu: Right now it is, because Haskell's kind system sucks.
18:29:42 <Eduard_Munteanu> There are only a handful of kinds. Can someone point why is this separatian necessary?
18:29:55 <Eduard_Munteanu> Cale: ah.
18:30:01 <orclev> Cale: maybe I need to force cabal to use the exact version of convertible I've got installed instead of trying to let it work it out on its own?
18:30:10 <aavogt> types for types
18:30:19 <Cale> orclev: Maybe hide or remove all the others
18:30:51 <Cale> pielgrzym: Only the type of that function is incorrect
18:31:01 <Philonous> Cale: Would closed type classes imply that the compiler understood that something is not in the type class? So that I could reason about all the types that are not instances of a class?
18:31:02 <Eduard_Munteanu> aavogt: I understand that, but kinds seem a hack considering you can't arbitrarily make types of types of types.
18:31:17 <Cale> pielgrzym: Consider that the type of (==) is (Eq a) => a -> a -> Bool
18:31:32 <pielgrzym> Cale: hmmm
18:31:34 <Cale> pielgrzym: So in your code, the values a and b must have the same type
18:31:40 <orclev> Cale: 1.0.9 is the only one I have installed... it's acting like cabal is fetching the data of hackage when trying to resolve the dependency in HDBC
18:31:51 <Cale> and moreover, that type, whatever it is, must be an instance of Eq
18:31:59 <pielgrzym> Cale: like isInside : a -> [a] -> Bool right?
18:32:10 <Cale> isInside :: (Eq a) => a -> [a] -> Bool
18:32:24 <ologNation> learnyouhaskell is one of the prettiest websites I've ever seen.
18:32:31 <Cale> isInside won't work for types 'a' which don't have an equality comparison
18:32:34 <pielgrzym> ah, this it this => stuff I have to read again :D
18:32:43 <Cale> For example, there's no way that it would work for lists of functions
18:32:45 <Cale> or IO actions
18:33:04 <Cale> because we can't compare if two functions compute the same thing (it's undecidable in general)
18:33:32 <Cale> orclev: hmmm
18:33:33 <Eduard_Munteanu> pielgrzym: a -> [b] might work for stuff like 5 and ['x', 'y'], for example
18:33:38 <Eduard_Munteanu> s/work/fit/
18:33:45 <Cale> Eduard_Munteanu: what?
18:34:04 <aavogt> for that to be total, you have to return an empty list
18:34:13 <Eduard_Munteanu> Cale: a list fits some arbitrary 'a'.
18:34:20 <orclev> does Cabal catch dependency data for packages someplace other than .cabal/packages?
18:34:40 <aavogt> ghc puts stuff in ~/.ghc
18:34:43 <pielgrzym> now it works :] I think I'm beggining to get some vague idea how this amazing thing works :)
18:34:50 <Eduard_Munteanu> so a function f :: a -> b can take vastly different types.
18:35:23 <pielgrzym> Eduard_Munteanu: you mean that the list has strings and the a is an integer?
18:35:24 <Cale> A function f :: a -> b can do nothing but to not terminate
18:35:47 <Eduard_Munteanu> Ah, crap, sorry... I meant a -> b -> blah
18:36:00 <dibblego> that also cannot terminate :)
18:36:29 <Cale> If a function is completely polymorphic in its input parameter, and that same type variable doesn't occur in the type of its result, then it means the function doesn't depend on the value of that parameter at all
18:36:48 <Cale> For example, if you have a function  f :: a -> Bool, it means that f doesn't observe its parameter of type a at all.
18:37:06 <Cale> There's no operation which applies to *all* types.
18:37:11 <Eduard_Munteanu> Oh, right.
18:37:24 <Philonous> @type \x -> x `seq` 5
18:37:25 <lambdabot> forall a t. (Num t) => a -> t
18:37:26 <dibblego> there are polymorphic operations, such as id
18:37:34 <EvanR> data construction
18:37:52 <Eduard_Munteanu> Cale: where would I look for proofs of something like that? I mean formal stuff.
18:37:56 <Cale> "If something could be anything, then nothing can be done with it."
18:38:00 <dibblego> @google free theorems
18:38:14 <EvanR> except put itin a container
18:38:15 <lambdabot> Plugin `search' failed with: thread killed
18:38:25 <ologNation> Here's a quite simple question, but I don't know the answer.
18:38:47 <ologNation> On the website "learnyouhaskell.com, how does it know what colors to put along the top margin?
18:38:49 <ologNation> It looks so good.
18:39:00 <Eduard_Munteanu> EvanR: you mean a -> Maybe a for example?
18:39:00 <ologNation> I am browsing the html and css files and I can't see it anywhere.
18:39:11 <ologNation> Is it a jpeg, or is this accomplished in html?
18:39:18 <Cale> Eduard_Munteanu: Well, it just comes from the fact that there are no primitive functions which act on values of a completely arbitrary type
18:39:30 <Cale> (apart from undefined)
18:39:56 <Eduard_Munteanu> Cale: hm, yeah, I understand that. But if I leave it at that I'll probably hit it again in some other circumstance :)
18:40:15 <EvanR> Eduard_Munteanu: yeah
18:40:44 <orclev> ok, I surrender, cabal has beaten me... I'm just going to go find some other type than UTCTime that I don't need to spend hours to get working
18:40:57 <DanC> "A String is represented as a list of Char values; each element of a list is allocated individually" <- really?
18:41:04 <DanC> (quote from http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html )
18:41:34 <orclev> DanC: I believe the compiler is free to optimize that, but in general it's my understanding that's the way it works
18:41:38 <Cale> ologNation: style.css
18:41:47 <Cale> .introcontent  {
18:41:47 <Cale> background-image:url("bg.png");
18:41:47 <Cale> }
18:41:48 <mle> DanC: Yes.  Other string types (ByteStrings, etc) have other characteristics.
18:42:04 <Eduard_Munteanu> Cale: what would this fit in... type theory?
18:42:07 <DanC> what do string literals denote?
18:42:19 <EvanR> [Char]
18:42:30 <orclev> DanC: "OK" == 'O':'K':[]
18:42:47 <orclev> > "OK" == 'O':'K':[]
18:42:48 <lambdabot>   True
18:43:05 <Cale> Eduard_Munteanu: I suppose, yeah.
18:43:08 <mamalujo> which is why its great "" syntax can be defaulted to ByteString.. would be nice if [] syntax would be defaultable to the self-unboxing lists dons had a few posts about..
18:43:14 <Cale> Eduard_Munteanu: It's referred to as parametricity.
18:43:22 <DanC> wild... not some other type that exports the list methods...
18:43:39 <Eduard_Munteanu> Cale: thanks, will try googling that.
18:43:41 <dolio> Or abstraction, originally.
18:43:42 <Eduard_Munteanu> and what dibblego said.
18:43:45 <DanC> I guess scala strings are Seq[Char] but not List[Char]
18:43:52 <mle> DanC: it can be made to use other types, as mamalujo said.
18:44:09 <EvanR> :t "a"
18:44:10 <lambdabot> [Char]
18:44:10 <Cale> Eduard_Munteanu: Actually, strictly speaking (no pun intended), there *is* one operation which Haskell has on values of an arbitrary type, and which slightly complicates this picture
18:44:24 <Cale> Eduard_Munteanu: It's called seq, and it messes everything up, just a little :)
18:44:26 <Eduard_Munteanu> fix?
18:44:29 <Eduard_Munteanu> Oh.
18:44:33 <dibblego> scala strings are java.lang.String and not List or Seq
18:44:36 <Eduard_Munteanu> :t seq
18:44:37 <lambdabot> forall a t. a -> t -> t
18:44:37 <EvanR> :t fix
18:44:38 <lambdabot> forall a. (a -> a) -> a
18:44:47 <dolio> fix is fine.
18:44:49 <dolio> @free fix
18:44:50 <lambdabot> f . g = h . f => f (fix g) = fix h
18:44:53 <dolio> Well, sort of.
18:44:55 <ologNation> Cale, Really?
18:44:59 <ologNation> The colors along the top margin?
18:45:01 <ologNation> Are you sure?
18:45:16 <ologNation> I browsed through there twice, and I didn't see anything that looked like it could have made all those colors.
18:45:28 <Eduard_Munteanu> @free seq
18:45:29 <lambdabot> g . seq x = seq (f x) . g
18:45:35 <Cale> ologNation: yes
18:45:39 <ologNation> I also browsed through the html file and I didn't see anything that seemed to reference a jpg or png of those colors.
18:45:47 <ologNation> I am hoping that it is in the style.css.
18:45:50 <Cale> ologNation: It's in style.css
18:45:50 <ologNation> can you tell me what section?
18:46:00 * ologNation is scrolling through style.css
18:46:01 <Cale> .introcontent
18:46:15 <orclev> haskell has ruined me... I tried to learn scala but I kept cringing and thinking how much nicer "x" was in haskell, where x was just about everything
18:46:19 <Cale> (I pasted the relevant part of the .css file into the channel)
18:46:31 <Cale> http://learnyouahaskell.com/bg.png
18:46:34 <dolio>  @free has hidden assumptions that (some of the) functions involved are strict.
18:47:00 <Cale> ologNation: If you don't have firebug, it's great for figuring stuff like this out.
18:47:07 <gwern> orclev: but, you don't have to worry about the IO monad, and you can call java libraries! isn't that enough you ingrate
18:47:18 <ologNation> found it!
18:47:19 <ologNation> bg.png.
18:47:22 <ologNation> Thanks cale.
18:47:35 <ologNation> That does leave me wondering how they made the png, but that's another story.
18:47:41 <ologNation> I'm sure that I could figure out a way to make it.
18:47:49 <ologNation> Maybe using imagemagick or something.
18:47:56 <ologNation> http://learnyouahaskell.com/bg.png
18:48:02 <ologNation> That's a pretty nice color composition.
18:48:28 <Cale> firebug has the nice property of listing all the css properties of things along with where those rules came from
18:48:35 <Cale> (what file and line)
18:48:53 <EvanR> chrome tools for the win
18:48:56 <dolio> The one for seq doesn't work, though, because: seq (_|_ x) (g y) = _|_ /= g (seq x y).
18:50:35 <aavogt> seq ftl
18:50:48 * ologNation is apt-get installing firebug. 
18:51:20 <Cale> ologNation: heh, I suppose you could do that, but it's a firefox extension which is installable from inside firefox itself
18:51:22 <orclev> ologNation: why not just use the regular extension installer?
18:52:26 <pielgrzym> ologNation: getfirebug.org
18:52:39 <pielgrzym> ologNation: err *.com
18:54:11 <IceDane> http://codepad.org/6co95NWQ Any hints?
18:54:16 <IceDane> trying to set up lambdabot
18:54:40 <Cale> Where'd you get the lambdabot code from?
18:54:54 <Cale> Whatever you do, don't install the one on hackage.
18:54:57 <IceDane> sec
18:55:01 <IceDane> http://www.haskell.org/haskellwiki/Lambdabot/Building
18:55:03 <IceDane> Followed this
18:55:06 <aavogt> IceDane: cabal install --constraint="tagsoup < 0.8"
18:55:26 <Cale> Oh, neat, I didn't even know that page existed.
18:55:30 * Eduard_Munteanu contemplates hmatrix
18:55:37 <IceDane> aavogt: It seems to working
18:55:44 <IceDane> I might just build temples in your honor
18:55:49 <aavogt> regardless of the benefits of the newer tagsoup, it's sort of overshadowed by the fact that it added a quickcheck dep
18:56:09 <djahandarie> What does it need quickcheck for?
18:56:17 <Cale> djahandarie: usually tests
18:56:49 <djahandarie> It'd pull the quickcheck dep for the tests? Wouldn't most packages have that dep then?
18:56:54 <Cale> It's an annoying problem with a lot of packages right now that testing frameworks add dependencies, and then those dependencies make packages incompatible with one another.
18:57:08 <djahandarie> Ah, I see.
18:57:10 <Cale> I think people are working on a way to solve this
18:57:14 <aavogt> only if you want your library to export your tests
18:57:24 <djahandarie> People will fix it! They always do.
18:57:25 <aavogt> which seems pointless in most cases
18:58:47 <ologNation> Cale, orclev pielgrzym Thx for the idea.  It will be cool to learn to use firefox in a new way.
18:58:52 <ologNation> I must be off to study now.  G
18:59:03 <ologNation> Geometry midterm on friday, don't-ya-know.
19:00:43 <IceDane> Gah, now it can't find readline-1.0.1.0 on cabal
19:00:47 <IceDane> What can I do about that?
19:03:04 <orclev> I can't figure out where cabal is getting the idea that convertible-1.0.9 depends on time <=1.1.4... I edited convertibles cabal file, I installed it, ghc-pkg shows it as depending on time-1.2.0... what more do I need to do?
19:14:42 <Saizan_> orclev: did you bump the version?
19:15:31 <orclev> Saizan_: not originally, but I just went around and bumped the version of everything and I finally got it all working
19:16:42 <Saizan_> when you edit some package you should stick a .1 at the end of the version, otherwise cabal assumes it'll be the same as the one on hackage
19:16:57 <orclev> Saizan_: well... mostly working... new error now at least, and one that thankfully doesn't have anything to do with the time, HDBC, or convertible
19:18:33 <DanC> what I meant was: scala strings are a subtype of CharSeq; they work like Seq in all the relevant library methods
19:27:09 <orclev> ... did hackage just fall over?
19:27:49 <monochrom> hackage seems to work for me
19:36:27 <orclev> monochrom: all the haddock is missing... I get 404s
19:37:31 <Saizan_> orclev: which in particular? the ones i tried work
19:37:55 <monochrom> I can see haddock. I can wget a tar.gz file.
19:38:33 <orclev> Saizan_: so far every one I've tried... here's one at random that comes back 404: http://hackage.haskell.org/package/Imlib
19:38:35 <monochrom> All those I try are not in my browser cache.
19:38:51 <monochrom> "Haskell binding for Imlib 2"
19:38:56 <Eduard_Munteanu> I have a problem using hmatrix. I get No instance for (Element Int)
19:39:01 <Eduard_Munteanu> when I do
19:39:15 <monochrom> "Upload date Mon Mar 30 21:09:58 UTC 2009"
19:39:22 <Saizan_> orclev: it works for me
19:39:24 <Eduard_Munteanu> matr = (2 >< 2) [1 .. 4]
19:39:27 <orclev> DNS issue maybe?... I get a page that says "
19:39:34 <monochrom> "updatesGetCoordinates :: ImlibUpdates -> IO (Int, Int, Int, Int)"
19:39:36 <Eduard_Munteanu> matr :: Matrix Int
19:39:39 <orclev> doh
19:39:40 <orclev> hold on
19:39:44 <Eduard_Munteanu> Any idea?
19:39:47 <orclev> The requested URL /package/Imlib was not found on this server.
19:40:43 <monochrom> one of us is under a middleman attack
19:41:06 <Eduard_Munteanu> Here's the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25085#a25085
19:41:07 <orclev> for me hackage.haskell.org resolves to 74.125.67.102... which is gw-in-f102.1e100.net
19:41:21 <monochrom> and screw intuitionistic logic, which unreasonably demands pointing out who. :)
19:41:39 <Saizan_> Eduard_Munteanu: check the haddock for the instances of Element maybe
19:41:39 <monochrom> 1e100.net is thoroughly google
19:41:42 <Eduard_Munteanu> Heh.
19:41:42 <orclev> hmm... 1e100.net is googles
19:41:51 <orclev> wtf
19:42:19 <orclev> yeah definitelty a DNS issue
19:42:54 <monochrom> hackage.haskell.org should be an alias for haskell.galois.com, which is an alias for abbot.galois.com, 69.30.63.204
19:43:17 <DanC> monochrom, as long as you're talking about finitely many things that you can name, intuitionistic logic doesn't deman pointing out which ;-)
19:43:29 <Eduard_Munteanu> Saizan_: hm, good point. And I tried with Double and it works.
19:43:40 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/hmatrix/0.8.3.1/doc/html/Data-Packed-Matrix.html#t%3AMatrix
19:44:01 <Eduard_Munteanu> Maybe nobody cared about Ints... I don't really care either, truth be told.
19:46:01 <monochrom> DanC: I have only two things, one is P, the other is ¬P. Please tell me how to prove P∨¬P in intuitionistic logic without pointing out which of P, ¬P is being proved.
19:46:17 <DanC> that's not two things; that's two propositions
19:46:32 <monochrom> OK two propositions.
19:46:38 <Saizan_> monochrom: define a \/ b = not (not a & not b)
19:46:45 <DanC> nope
19:46:53 <Saizan_> ;)
19:46:54 <DanC> demorgan's laws don't work in intuitionistic logic
19:47:18 <Saizan_> i'm just defining a new connective there
19:47:53 <DanC> monochrom, I can't. but that's not what you were doing
19:47:59 <Cale> One of De Morgan's laws works, the other doesn't, as I recall.
19:48:27 <DanC> you were doing: P(me) \/ P(you) => Ex P(x)
19:48:37 <DanC> which works just fine in intuitionistic logic.
19:49:26 <Saizan_> with the "main" existential of intuitionistic logic you'd have to specify who that x is in the proof
19:50:20 <monochrom> Tell me how to prove P(me) \/ P(you).
19:50:41 <DanC> I don't see the relevance.
19:51:14 <monochrom> <monochrom> one of us is under a middleman attack
19:51:16 <DanC> you said "one of us is under attack". i.e. Ex UnderAttack(x)
19:51:32 <monochrom> Yes. Tell me how to prove Ex UnderAttack(x)
19:51:57 <DanC> and I think you took as premises UnderAttack(monochrome) \/ UnderAttack(a2)
19:52:10 <monochrom> No, that is not the premise.
19:53:00 <monochrom> The premise is: ¬(me's browser result = you's browser result).
19:54:03 <DanC> well, that's not enough to get to Ex UnderAttack(x) under any logic I know of.
19:55:00 <monochrom> Of course some axiom linking browser result to UnderAttack is needed.
19:56:56 <monochrom> Here is one: ¬(Result(x) = IdealResult) ⇒ UnderAttack(x)
19:58:02 <Saizan_> do we have decidable equality for results?
19:59:05 <monochrom> I don't know. But perhaps doesn't matter. We now do have the observation of ¬(Result(me) = Result(you))
20:00:21 <DanC> well, it matters inasmuch as if we do, we can write Result(me) = IdealResult \/ not(Result(me) = IdealResult)
20:01:08 * DanC is looking up standard rules of inference for intuitionistic logic, trying to remember whether proof by cases is one of them and if not, how it relates
20:01:17 <Saizan_> and with  ¬(Result(me) = Result(you)) we can rule out the case where both Result(me) and Result(you) happens to be IdealResult
20:01:25 <Saizan_> hence proving Ex UnderAttack(x)
20:01:55 <DanC> that was too quick for me, Saizan_
20:04:02 <mamalujo> is it me, or is planet.haskell getting more and more difficult to access lately?
20:05:30 <djahandarie> Yeah, I was attacked by a 3-headed dragon the last time I tried to access
20:05:39 <nardy> heyy
20:05:55 <nardy> anyone here know how to work matlab
20:06:14 <Saizan_> DanC: define "decideIsIdeal x = Result(x) = IdealResult \/ not(Result(x) = IdealResult)" then if you do case analysis on both "decideIsIdeal me" and "decideIsIdeal you", you've 4 cases, in 3 you can you have an "not(Result(x) = IdealResult)" for at least one of me and you, in the fourth you've that "Result(me) = IdealResult /\ Result(you) = IdealResult", so "Result(me) = Result(you)" by transitivity, absurd.
20:06:49 <Saizan_> s/3 you can/3/
20:07:10 <monochrom> Proof by cases is in intuitionistic logic. Look for the ∨-elimination rule in natural deduction, and the ∨-left rule in intuitionistic sequent calculus.
20:07:13 <DanC> reductio ad absurdum is not intuitionistic
20:07:24 <Saizan_> it is
20:07:38 * DanC furrows brow
20:07:46 <Saizan_> ex falso quodlibet is valid in intuitionistic logic
20:07:59 <Saizan_> the thing that's not valid is double negation elimination
20:08:10 <flippo> This is different from intuitive?
20:08:30 <DanC> ok, yes, proof of _|_ from X is a proof of not(X). now I remember. (slowly)
20:08:44 <flippo> If so, did someone have to invent such an ugly word?
20:08:59 <Saizan_> yeah, so A & not(A) give you _|_
20:09:20 <Saizan_> flippo: they did :)
20:09:49 <monochrom> Saizan_'s method relies on adding axiom «Result(me) = IdealResult \/ not(Result(me) = IdealResult)» so you have something to case-analyse on.
20:10:31 <monochrom> "from false therefore Dilbert"
20:10:41 <Saizan_> monochrom: quantify over me, or add another for you :)
20:10:51 <DanC> yes, we're still waiting for you to answer how = works in the logic under discussion
20:11:13 <monochrom> oh oops, yeah, «Result(x) = IdealResult \/ not(Result(x) = IdealResult)», x free variable
20:12:14 <monochrom> At present we just need = a binary predicate with reflexive, transitive, symmetric
20:15:10 <Saizan_> do you think we can prove Ex UnderAttack(x) where E is the constructive existential with = only being an equivalence relation or not?
20:15:51 <DanC> yes, if he gives us «Result(x) = IdealResult \/ not(Result(x) = IdealResult)»,
20:17:36 <Saizan_> by "only" i meant without that :)
20:18:29 <DanC> I don't think so
20:22:25 <shapr> I have no idea what you guys are saying.
20:23:48 <DanC> yeah, well, don't lose any sleep over it.
20:23:49 <Saizan_> shapr: something like overanalysing a joke about constructive logic :)
20:24:30 <monochrom> haha
20:27:46 <Eduard_Munteanu> Good, got a nice fft working with hmatrix
20:27:51 <Eduard_Munteanu> and nicely plotted.
20:29:07 <shapr> Saizan_: Fair enough.
20:46:42 <ManateeLazyCat> Hi all, can you access code.haskell.org ?
20:47:31 <Saizan> ManateeLazyCat: no, the http server seem to have some problems
20:47:40 <Kaidelong> that explains my problem then
20:48:13 <ManateeLazyCat> Saizan: Maybe we need move gtk2hs to patch-tag.com
20:48:32 <ManateeLazyCat> Saizan: code.haskell.org always problem, again and again.
20:50:40 * ManateeLazyCat So many local repositories in my box, darcs gtk2hs, cabal gtk2hs, gtk2hs 2.18, gtk2hs 2.20, i'm going to crazy.
20:51:35 <siracusa> ManateeLazyCat: Hey, I also just wanted to get the gtk2hs repo, but no access :-(
20:56:59 <DanC> > :type +
20:57:00 <lambdabot>   <no location info>: parse error on input `:'
20:57:07 <DanC> > :type `+`
20:57:07 <lambdabot>   <no location info>: parse error on input `:'
20:57:12 <DanC> help?
20:57:13 <Axman6> :t (+)
20:57:14 <lambdabot> forall a. (Num a) => a -> a -> a
20:57:31 * DanC furrows brow
20:57:41 <Axman6> :tyoe (+)
20:57:44 <Axman6> :type (+)
20:57:48 <Axman6> hmm
20:57:55 <DanC> > type (+)
20:57:56 <lambdabot>   <no location info>: parse error on input `type'
20:58:03 <DanC> >:type (+)
20:58:08 <DanC> > :type (+)
20:58:09 <lambdabot>   <no location info>: parse error on input `:'
20:58:18 <DanC> > 1+1
20:58:19 <lambdabot>   2
20:58:26 <DanC> oh well
20:58:26 <Axman6> no >
20:58:30 <Axman6> :t 1
20:58:31 <lambdabot> forall t. (Num t) => t
20:58:37 <Axman6> > :t 1
20:58:38 <lambdabot>   <no location info>: parse error on input `:'
20:58:38 <Axman6> wrong
20:58:45 <DanC> the ()s address the issue at the ghci prompt
20:58:46 <Axman6> notice the angry face? >:t
20:58:54 <dancor> are there any examples for using Sound.Csound
20:59:31 <DanC> just when I was starting to read haskell at the lexical level. darn. why does (+) work but not `+` ?
20:59:32 * Kaidelong has really been driven into a corner with wxHaskell
20:59:59 <Axman6> because + isn't a function
21:00:03 <Axman6> i guess
21:00:14 <DanC> no, it is... but it's infix. () neutralizes fixity
21:00:20 <Axman6> basically, you need to wrap infix functions in brackets
21:01:26 <dancor> DanC: maybe   :type `+`   doesn't work for the same reason that   f = `+`  doesn't..?
21:01:44 <DanC> right. it's coming back to me now
21:02:23 <authorblues> is there a function that returns the first element in a list to satisfy a predicate?
21:02:41 <Axman6> head . filter p
21:03:04 <authorblues> will that short circuit in the way i want it to? because i have an infinite list
21:03:23 <Axman6> what do you mean? it'll return a value as soon as p is met
21:03:34 <Axman6> this is how laziness works
21:03:51 <authorblues> i know. i havent touched haskell in a while, and im just having a lot of mental blanks
21:03:59 <authorblues> sorry for the stupid question
21:04:28 <Axman6> you could always write your own: foo p (x:xs) | p x = x | otherwise = foo p xs
21:04:59 <Axman6> but, this will only work properly on lists that contain an element that p satisfies
21:05:13 <authorblues> that doesnt seem very haskell-esque. combining Prelude functions seems the right way in the haskell-mindset
21:05:51 <Axman6> hmm, the haskell mindset is to write good code, whether you feel that reinventing the wheel is a better way to do it or not
21:06:02 * Axman6 does not agree that there is a haskell mindset
21:06:38 <authorblues> reinventing the wheel just doesnt seem to satisfy the observed groupthink, but i am very very much a haskell newbie, so i could be way off base
21:06:41 <authorblues> thanks for the help
21:07:02 <siracusa> authorblues: In Data.List there's also find.
21:07:20 <Axman6> when learning haskell, you would be well advised to go and re write all prelude functions you use at least once, to make sure you understand them
21:07:37 <Axman6> rewrite them from scratch without reference to the prelude definitions*
21:07:49 <Axman6> :t find
21:07:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:08:43 <Axman6> find is probably the best solution to what you're after
21:09:05 <aavogt> @quote recursion.*go
21:09:05 <lambdabot> anonymous says: Primitive recursion is the goto of functional programming.
21:10:53 <aavogt> you must implement a typechecker before you may use it correctly
21:11:29 <orclev> primitive recursion? Would that be explicit recursion?
21:11:36 * DanC ponders... "Due to the thunking behavior of foldl, it is wise to avoid this function in real programs"
21:12:02 <Kaidelong> foldr has the same problem doesn't it?
21:12:45 <Kaidelong> evaluates the whole input list and constructs a tree
21:13:57 <orclev> is there a better way to write?: foo = randomRIO (1,10) : foo
21:14:20 <DanC> that agrees with my intuitions, Kaidelong  but as I'm new to haskell, my intuitions don't count for much
21:14:50 <aavogt> yes, primitive recursion refers to pattern matching on arguments and then calling the original function again
21:14:51 <Kaidelong> orclev: from what I understand, it gets treated a bit like an iterator from java
21:14:59 <Kaidelong> so it's fine
21:15:09 <aavogt> orclev: repeat (randomRIO (1,10)
21:15:11 <aavogt> )
21:15:52 <orclev> aavogt: ah, didn't know about that one... I had seen replicate, but that was't quite what I was looking for
21:17:07 <orclev> > liftM (take 10) $ repeat (randomRIO (1,10))
21:17:08 <lambdabot>   Couldn't match expected type `[a]'
21:17:09 <lambdabot>         against inferred type `GHC.IOBas...
21:17:12 <orclev> hmm
21:17:26 <orclev> > liftM (take 10) $ repeat (randomRIO (1,10) :: Int)
21:17:27 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:17:27 <lambdabot>         against inferred type ...
21:17:54 <orclev> oh... I forgot the sequence
21:18:32 <mamalujo> how much of haskell does lambdabot know?
21:19:08 <orclev> sequence . (take 10) . repeat $ (randomRIO (1,10) :: Int)
21:19:13 <orclev> > sequence . (take 10) . repeat $ (randomRIO (1,10) :: Int)
21:19:14 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:19:14 <lambdabot>         against inferred type ...
21:21:08 <siracusa> :t sequence . (take 10) . repeat $ randomRIO (1,10 :: Int)
21:21:09 <lambdabot> IO [Int]
21:21:10 <orclev> ah, I was close
21:21:14 <orclev> > sequence . (take 10) . repeat $ (randomRIO (1,10) :: IO Int)
21:21:15 <lambdabot>   <IO [Int]>
21:21:31 <aavogt> it has quite a few libraries loaded
21:21:41 <BMeph> :t liftM (ramdomRs (1,10)) getStdGen
21:21:42 <lambdabot> Not in scope: `ramdomRs'
21:21:47 <aavogt> > replicateM 10 (randomRIO (1,10) :: IO Int)
21:21:48 <lambdabot>   <IO [Int]>
21:22:12 <BMeph> :t liftM (System.Random.ramdomRs (1,10)) System.Random.getStdGen
21:22:13 <lambdabot> Not in scope: `System.Random.ramdomRs'
21:22:19 <BMeph> Bah!
21:22:38 <aavogt> it's best to pass the the generator state through though
21:22:42 <aavogt> *better
21:22:52 <aavogt> @type newStdGen
21:22:53 <lambdabot> IO StdGen
21:23:15 <BMeph> Anyway, that's how I'd do it - use a Random function that gives you a list of "random" numbers. :)
21:23:16 <aavogt> > randomRs (1,10) <$> newStdGen
21:23:17 <lambdabot>   <IO [Integer]>
21:23:45 <orclev> :i randomRs
21:24:00 <orclev> hmm... :i doesn't work?
21:24:03 <BMeph> @hoogle randomRs
21:24:04 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
21:24:23 <orclev> infinite list?
21:24:25 <BMeph> orclev: ...but @hoogle does. ;)
21:24:57 <BMeph> orclev: If not, then where would it end? ;)
21:25:14 <aavogt> but you lose the generator
21:25:18 <aavogt> the state that is
21:25:28 <dancor> you can split it beforehand
21:25:29 <orclev> BMeph: just making sure I understood it properly
21:25:43 <BMeph> aavogt: Is keeping the generator part of the solution? :)
21:26:17 <orclev> assuming you're single threaded, and not too concerned with the quality of your randomness, is there a good reason not to use the global random generator?
21:26:31 <aavogt> depends whether you want to be random afterwards
21:26:57 <aavogt> newStdGen is seeded from the clock
21:27:37 * BMeph looks up Cher's "If I Could Turn Back Time" on YouTube...
21:27:46 <orclev> the haddock for randomRIO makes it sound like theres a single global generater, not that it calls newStdGen every time
21:27:49 <aavogt> orclev: your code might be more confusing written that way
21:28:24 <aavogt> randomRIO would be allowed to do that
21:29:03 <BMeph> From the haddock: " -- | A variant of 'randomR' that uses the global random number generator
21:29:03 <BMeph>   -- (see "System.Random#globalrng").
21:29:03 <BMeph>   randomRIO :: (a,a) -> IO a
21:29:03 <BMeph>   randomRIO range  = getStdRandom (randomR range)"
21:30:03 <BMeph> It looks pretty clear to me, but I'm weird... ;
21:35:34 <Veinor> 'from the haddock'?
21:35:38 <Veinor> is that like 'from the english'?
21:36:07 <Axman6> it's like from the docs...
21:36:12 <Veinor> yeah, I know
22:05:38 <[swift]1> nice! i've got a non-hygienic replacement for the TH expression quasiquoter working
22:06:31 <[swift]1> was pretty tough to implement given that the TH quasiquoters and custom quasiquoters don't work the same way
22:06:58 <[swift]1> easily the most disgusting hack i've yet produced in haskell =)
22:07:54 <SubStack> quasiquotes have the most horrible interface
22:08:22 <[swift]1> SubStack: it's frustrating because they were _almost_ exactly what I needed but getting the last 5% was hard
22:08:55 <SubStack> I know the feeling
22:11:53 <[swift]1> here's an example of the improvement
22:12:37 <[swift]1> before: e <- [| ($(dyn ":") $(dyn "T_End") $(dyn "ts"), $(dyn "i")) |]
22:12:50 <[swift]1> now: e <- [$u| ((T_End : ts), i) |]
22:13:12 <[swift]1> drastically more readable imo
22:21:15 <deteego> I was just wondering if its possible to do something like this in haskell
22:21:16 <deteego> data Foobar = A Int | B String | C Double
22:21:17 <deteego> data Foobar2 = A B
22:22:10 <deteego> or am I forced to do something like this
22:22:11 <deteego> data A = A Int
22:22:11 <deteego> data B = B String
22:22:12 <deteego> data C = C Double
22:23:38 <[swift]1> when you write "data Foobar2 = A B", you mean for Foobar2 to have data constructors identical to Foobar's data constructors A and B?
22:26:07 <deteego> [swift]1: well the reasoning is
22:26:23 <deteego> [swift]1: uh ye
22:26:24 <deteego> *yes
22:26:37 <deteego> basically I want to (obviously) refer to Foobar generally
22:26:49 <deteego> but I want to also be able to refer to one of its data constructors specifically
22:27:41 <Saizan> there's not immediate way to refer to only a subset of the contructors of Foobar in a type
22:27:51 <deteego> ok
22:27:55 <[swift]1> there's template haskell =)
22:28:08 <[swift]1> but i'd be sure you'd explored your other options first
22:28:29 <deteego> well I already know about template haskell
22:28:36 <Saizan> "data Foobar2 = A B" if it's accepted defines A as a constructor of type "B -> Foobar2"
22:29:02 <deteego> well I could just do something like this
22:29:05 <deteego> data A = A Int
22:29:05 <deteego> data B = B String
22:29:05 <deteego> data C = C Double
22:29:06 <deteego> data Foobar A | B | C
22:29:26 <deteego> eh woops, data Foobar = Foobar A | B | C
22:29:32 <deteego> albeit it would be more wordy
22:29:33 <Saizan> data Foobar = AF A | BF B | CF C
22:29:43 <Saizan> you need constructors in Foobar too.
22:29:53 <[swift]1> i don't think that works
22:30:31 <Saizan> mine works
22:30:37 <[swift]1> Saizan: right, yours does
22:33:19 * hackagebot vector 0.6.0.1 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.6.0.1 (RomanLeshchinskiy)
22:33:21 <[swift]1> deteego: i'm curious about the problem you're trying to solve by doing this
22:35:15 <deteego> [swift]1: well basically im making a game, and im putting data types for every character that has attributes
22:36:27 <[swift]1> deteego: it sounds like you're basically trying to emulate the sort of structure you might get from subclasses in an OO language, right?
22:36:27 <deteego> for customization I would want to refer to a group of stats generally, but also every character has to have one of each stat as a data type for storing data
22:36:35 <deteego> [swift]1: sought of
22:36:56 <deteego> but not subclasses
22:37:09 <[swift]1> deteego: ah, that's an interesting wrinkle
22:37:39 <deteego> like assume a character has 4 stats, A B C and D
22:37:54 <deteego> I want a data type that stores those types for each character
22:39:06 <deteego> data Character = Character
22:39:06 <deteego> 	{ name		:: String,
22:39:07 <deteego> 	  stat_a	:: A,
22:39:07 <deteego> 	  stat_b	:: B,
22:39:07 <deteego> 	  stat_c	:: C,
22:39:09 <deteego> 	  stat_d	:: D
22:39:14 <deteego> 	}
22:39:28 <deteego> but I would also want to refer to those stats generally as a group
22:39:55 <deteego> for example to make a function that increases a certain stat, and as an argument the function would accept on of those stats as general
22:41:11 <[swift]1> the idea would be that you would increase the stat of every character simultaneously?
22:41:15 <[swift]1> that's the part i'm not clear on
22:41:33 <[swift]1> or you mean that the function will be parameterized by the stat to increase
22:41:37 <[swift]1> ?
22:41:42 <deteego> nono, this is more syntactic sugar stuff
22:42:16 <deteego> like lets say the stats A,B,C,D are belong under "Strength" stats
22:42:21 <deteego> so I would have a general function
22:42:54 <deteego> increaseStat Strength -> Int -> State....
22:43:00 <deteego> where Strength would be
22:43:17 <deteego> data Strength = Strength A | B | C | D
22:43:24 <deteego> (which obviously isn't possible)
22:44:13 <deteego> I would use the A, B, C, D constructors as I did above and use the Strength data type generally to refer to all of those
22:44:18 <[swift]1> ahh
22:44:26 <[swift]1> this sounding more and more like a job for template haskell
22:44:39 <deteego> well I learned template haskell yesterday
22:45:03 <deteego> but its pretty ugly, since there isn't splicing for quotations in data declerations
22:45:33 <deteego> Template Haskell would definitly make it less verbose though
22:48:06 <deteego> probably should do it though, since there is a lot of boiler plate code
22:49:49 <DanC> what is this $ thing?
22:50:08 <DanC> f $  x    =  f x
22:51:20 <deteego> [swift]1: tbh though, something like this should be possible without template haskell
22:51:48 <DanC> oh... hmm... "However, $ has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted"
22:51:49 <deteego> without having to manually do it for each data constructor
22:57:25 <deteego> is revised haskell still hapenning
22:57:51 <deteego> I mean the new revised haskell update from 98
23:05:25 <tensorpudding> haskell 2010 has been releaseed
23:05:57 <tensorpudding> it only has a few additions and changes though
23:06:43 <tensorpudding> more revisions from haskell prime are in the not-so-far future
23:08:40 <deteego> also is it possible to make custom classes derivable
23:10:51 <deteego> or is that only for base classes?
23:11:58 <tensorpudding> I don't think you can derive custom classes.
23:12:16 <tensorpudding> You can derive a few classes by default, and using a pragma you can derive Data and Typeable.
23:13:29 <monochrom> Saizan, DanC: hahahaha, http://www.vex.net/~trebla/tmp/middle.txt
23:13:42 <opqdonut> deteego: it is possible, using SYB or template haskell
23:13:49 <opqdonut> don't know more, though
23:13:56 <deteego> opqdonut: what is SYB?
23:14:22 <kynky>  scrap your boilerplate
23:14:27 <deteego> ah
23:14:37 <DanC> goodness
23:15:17 <deteego> sounds like another thing I need to learn
23:16:01 <monochrom> I learned intuitionistic logic recently. (in particular Kripke semantics so I can build and check counterexamples for unprovable things.) It's a good non-toy exercise for me.
23:17:52 * DanC can't read the 1st line of the proof... left-∀?
23:17:58 <monochrom> Yes.
23:18:35 <monochrom> With a forall premise, you can instantiate x to whatever you feel useful.
23:19:36 <DanC> aka instantiation? what's "left" about it?
23:19:55 <DanC> at least my intuition was right: Now we retract the premise ∀x. r(x)=i ∨ ¬(r(x)=i). ... Then U(me)∨U(you) is unprovable.
23:20:13 <Saizan> right-∀ would be the introduction rule?
23:20:25 <monochrom> In sequent speak, they like to say "rule for operator on the left" and "rule for operator on the right".
23:20:59 <monochrom> "left" means among the premises, "right" means conclusion, i.e., left and right of ⊢
23:21:16 <DanC> oh... left-∀ isn't a justification for the line above, but rather connecting the line above and below
23:21:38 * DanC hasn't spent much time with sequents
23:22:38 <monochrom> There is a way to translate sequent calculus "left" steps to natural deduction "elim" steps, "right" steps to natural deduction "intro" steps. You can translate proofs but not really translate the rules.
23:23:21 <DanC> weakening is roughly erasure? i.e. & elim?
23:24:09 <monochrom> Yeah, but roughly.
23:26:47 <DanC> do you use any tools that grok this sort of proof? have you tried coq or isabelle or the like?
23:27:19 <monochrom> I tried coq and hol. hol is classical.
23:28:09 <DanC> umm... hol has a classical module, but it's constructive at heart, no?
23:28:32 <monochrom> no. hol is classical at heart.
23:30:43 <DanC> "All the HOL systems use Robin Milner's LCF approach. " -- http://hol.sourceforge.net/
23:30:49 <DanC> where LCF = logic of computable functions.
23:31:01 <monochrom> "approach"
23:31:35 <monochrom> Here is the meaning of "approach". A spirit is adopted.
23:32:21 <DanC> oh... hmm... they build a classical logic on top?
23:32:32 <DanC> maybe I'm confusing HOL with Isabelle
23:32:40 <monochrom> Here is the spirit adopted. "theorem" is an abstract type, you can only obtain theorems from a few smart constructors. Each smart constructor's code is small, so hopefully there is no chance for bugs.
23:33:08 <Runar> What's the difference betweeh "data Foo x where" and "class Foo x where", exactly?
23:33:54 <monochrom> Another spirit adopted is HM typing for the meta level. Another spirit adopted is HM typing for the object level.
23:34:39 <monochrom> constructivism is not adopted.
23:35:12 <monochrom> Indeed look at this core axiom and have a heart attack: http://hol.sourceforge.net/kananaskis-5-helpdocs/help/src-sml/htmlsigs/boolTheory.html#BOOL_CASES_AX-val
23:35:39 <Saizan> Runar: the former defines a datatype, the latter a type class.
23:36:05 <Saizan> Runar: a type class has almost nothing in common with an OO class
23:36:20 <monochrom> Notice also this "boolTheory" module is fundamental; all other modules depend on it, and there is no replacement module giving alternatives for the logic connectives.
23:38:07 <Saizan> Runar: but anyhow, what comes after "where" in the data declarations are Foo's constructors, i.e. ways to build a value of type Foo x, while for the type class that's a list of methods that you need to implement to declare that x is an instance of Foo
23:39:02 <monochrom> In fact look further a few lines for SELECT_AX. This is even stronger than axiom of choice. This theorem prover kills all hints of constructivism.
23:39:16 <Runar> OK, that's what I was looking for. What follows where in a data declaration are data constructors. Thanks
23:42:13 <DanC> indeed, monochrom
23:42:37 <shepheb> okay, got that one
23:42:40 <shepheb> whoops
