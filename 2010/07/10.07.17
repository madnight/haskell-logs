00:00:21 <krainboltgreene> dibblego: Not only correct, but also stroking my ego! Five stars! :D
00:00:32 <Cale> PetRat: Well, you can use the Either String monad, sure
00:00:46 <dibblego> PetRat, you'll need a function :: String -> Either ErrMsg Something then use the Either monad
00:00:57 <Cale> PetRat: That's the sort of thing it tends to be good at.
00:01:26 <Cale> PetRat: However, as your parsing becomes more complex, you may want to consider using a parsing monad like Parsec or ReadP.
00:01:58 <Cale> (this is still pretty simple though)
00:02:07 <lhames> @src IO
00:02:07 <lambdabot> Source not found. You type like i drive.
00:02:45 <krainboltgreene> Did the bot just insult you?
00:02:46 <Cale> lhames: Which implementation are you interested in? GHC's hacky one? A useful mental model or two?
00:02:59 <lhames> Yes - the bot just insulted me.
00:03:02 <Cale> Yeah, for some reason the @src plugin does that sometimes
00:03:15 <PetRat> Cale: let me try to write this and see what you think
00:03:29 <lhames> Cale: GHC's hacky one would be interesting. :)
00:04:36 <Cale> newtype IO a
00:04:36 <Cale>   = GHC.IOBase.IO (GHC.Prim.State# GHC.Prim.RealWorld
00:04:36 <Cale>                    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
00:04:57 <Cale> (from ghci, :info IO)
00:05:08 <Cale> State# RealWorld is an empty type
00:05:54 <Cale> It's used by the compiler to basically use the existing machinery for keeping data dependencies straight to keep the order in which IO actions should execute clear.
00:06:07 <Cale> The functions put in there are typically impure.
00:06:32 <ivanm> BMeph: I can't have "sequence[_] = mapM[_] id", for the same reason that "mapM[_] = sequence[_] . map" :s
00:07:04 <ivanm> Cale: using ReadP for real parsing? really?
00:07:06 <PetRat> Cale: a version of the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27655#a27656
00:07:22 <Cale> ivanm: What, is there a problem with it? :)
00:07:41 <ivanm> I thought that it was a little limited compared to parsec, polyparse, uuparsing-lib, etc.
00:07:53 <PetRat> Cale: I was hoping for something even more compact though, but we'll see
00:07:57 <Cale> PetRat: I think you're missing a return/Right
00:08:12 <PetRat> Cale: oh yeah
00:08:14 <Cale> PetRat: You can now neaten this using the Applicative combinators :)
00:08:28 <ivanm> BMeph: wait, I lie; the error message comes from something else
00:08:43 <ivanm> no, wait, I _was_ right
00:08:46 <Cale> mkSomething2 s1 s2 = Something <$> safeRead s1 <*> safeRead s2
00:09:05 <Cale> ivanm: It has symmetric alternation, which is nice.
00:09:09 <lhames> Cale: Thanks for that!
00:09:13 <PetRat> Cale: does this require any instance declarations?
00:09:32 <ivanm> hmmm...
00:09:44 <Cale> PetRat: You might need to import Control.Monad.Error
00:09:44 <ivanm> *sigh* I don't think I'll get to any graph stuff this weekend at this rate...
00:09:55 <PetRat> Oh, I see. Either is an instance of Applicative already?
00:10:14 <Cale> PetRat: Well, it ought to be...
00:10:42 <Cale> Yeah, there's an instance in Control.Monad.Either
00:10:59 <Cale> er, Error, rather
00:11:12 <ivanm> BMeph: at least for sequence_ it doesn't work; seems to work for sequence
00:23:54 <PetRat> Cale: I wrote code similar to your example, but it is complaing there is no instance of Applicative
00:26:37 <PetRat> Is ErrorT declared an instance of Applicative anywhere in the standard libraries?
00:30:21 <Cale> PetRat: hmm, I was talking about Either, rather than ErrorT, but there ought to be instances of Applicative for ErrorT as well
00:30:35 <Cale> instance (Functor m, Monad m) => Applicative (ErrorT e m)
00:30:35 <Cale>   -- Defined in Control.Monad.Trans.Error
00:32:13 <soupdragon> how to stop getting annoyed with people and just be nice all the tiem??
00:32:51 <drbean> Be a teacher.
00:33:16 <soupdragon> once I had a teacher who get so angry she quit
00:33:20 <krainboltgreene> Aaaaaaaaaaaaaaahahahah.
00:33:23 <dibblego> introspect on your ultimate objective and observe that "getting annoyed" is a non-contribution
00:33:24 <krainboltgreene> Be a teacher. Right.
00:33:41 <soupdragon> dibblego, but I know it and it happens again and again :( I just don't learn
00:33:41 <krainboltgreene> Someone hasn't ever been near the teaching profession. :D
00:33:50 <PetRat> drbean: I find it's the rare teacher who doesn't get very annoyed with students sometimes. not the teacher's fault---teaching can be exasperating
00:33:56 <dibblego> soupdragon, how annoying :)
00:34:53 <PetRat> being a parent is probably the ultimate equanimity tester, while teacher is a close second
00:35:19 <soupdragon> dibblego hehe
00:35:34 <soupdragon> I beleive it's possible to change but I don't know how 
00:35:47 <PetRat> soupdragon: do you meditate?
00:36:04 <soupdragon> no - I did try for a while but well idk maybe I will start again 
00:36:11 <soupdragon> it's hard to tell if it's a waste of time or not
00:36:42 <PetRat> you have to practice equanimity in the small things --- how can you expect to sail through a huge challenge if you've never practiced the smaller ones?
00:37:36 <drbean> Regard social skills as a kind of computer programming.
00:38:11 <soupdragon> the problem is no user manual >:)
00:39:07 <ivanm> man 7 social-skills
00:39:31 <soupdragon> maybe I should work on a haskell tutorial
00:39:34 <roaldfre> mapAccumLU :: (UA  a, UA  b) => (c -> a -> c :*:  b) -> c -> UArr  a -> UArr  b  <-- what does the :*: syntax mean?
00:39:57 <soupdragon> roaldfre, think that's just an (unboxed) pair
00:44:34 <soupdragon> writing ah askell tutorial is a fun way to learn LaTeX
00:44:42 <soupdragon> what should I write about?????
00:44:50 <ivanm> what do you know?
00:44:56 <PetRat> Can someone give me a clue how to write an Applicative instance for Either String? My first attempt is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27659#a27659
00:45:02 <triyo> Noob question. I need to represent this simple math " 0 < attrDataLen < 4" in haskell but if I try that I get "cannot mix `<' [infix 4] and `<' [infix 4] in the same infix expression". What is the best way to represent this?
00:45:12 <soupdragon> PetRat, what is the problem with it? it looks okay
00:45:51 <soupdragon> triyo: I think that is basically an error there but you could try using infixr or infixl
00:46:05 <PetRat> "Illegal instance declaration for "Applicative (Either String)" All instance types must be of the form (T a1 .. an) etc.
00:46:07 <soupdragon> triyo: yeah because  0 < x < 4  doesn't work,  it has to be   0 < x && x < 4
00:46:22 <ivanm> triyo: 0 < attrDataLen && attrDataLen < 4"
00:46:36 <ivanm> a < b < c doesn't type check
00:46:44 <ivanm> and languages that let you do that are crazy and should be shot
00:47:00 <etpace> why?
00:47:19 <triyo> exactly why? :)
00:47:30 <etpace> sure it doesnt typecheck directly but its obvious what is happening, and its quite a bit neater
00:47:39 <PetRat> I imagine it has something to do with the inconsistent use of operators
00:47:45 <soupdragon> etpace, well... there are languages which do allow this, but they have a much more advanced (aka complicated) syntax mechanism
00:48:00 <soupdragon> PetRat, i don't really know what to say except you could try XFlexibleInstances
00:48:05 <PetRat> There is no way to interpret a < x < b as an expression formed from normal operators.
00:48:33 <ivanm> PetRat: yup
00:49:02 <ivanm> because a < b < c == (a < b) < c
00:49:08 <ivanm> left-fixity, etc.
00:49:27 <ivanm> and "it makes sense just looking at it" doesn't imply that it makes sense in terms of the types
00:49:40 <ivanm> maths is full of dodgy notation; computers aren't smart enough to understand all of it
00:50:03 <dibblego> it doesn't make sense looking at it
00:50:13 <PetRat> Python will accept a < b < c but probably must parse it differently than normal expressions.
00:50:30 <soupdragon> POLL:  What ("advanced") topics should I put in my tutorial?
00:50:38 <soupdragon> I'm gonna write about folds and GADTs
00:50:44 <soupdragon> and probably other stuff but not sure what
00:50:57 <soupdragon> I wont write about basic stuff because it's already been done (beter)
00:51:26 <soupdragon> dibblego: it makes sense if you consider the general idea,   a < b < c < ... < m  means each one is equal
00:51:40 <soupdragon> dibblego: and more generally   a < b = c <= d < e  means that a < e
00:51:58 <soupdragon> or  a -> b -> c -> d  to prove a long implication chain
00:52:12 <soupdragon> it's useful to have sequence like that and you can take the  LUB  to see what it does overall
00:52:18 <soupdragon> (I think LUB is the correct term..?)
00:52:22 <dibblego> soupdragon, I have to transform it to something that does make sense, to make sense of it, like you just did
00:53:04 <Cale> dibblego: It makes sense. It just means that each adjacent pair of elements satisfy the relation between them
00:53:40 <soupdragon> I like the chains because you will often see:
00:53:42 <soupdragon>   <program>
00:53:48 <soupdragon> = { explanation }
00:53:51 <soupdragon>   <program2>
00:53:55 <Jafet> "I wish Haskell had the syntax of popular language foo." "Write Haskell, not popular language foo."
00:53:57 <soupdragon> <= { explanation }
00:53:58 <dibblego> I simply disagree that it even comes close to making sense :)
00:53:58 <soupdragon>  ...
00:54:08 <Cale> dibblego: That's how it's defined.
00:54:16 <soupdragon> and you just take the LUB of all the operations to see what the entire derivation says
00:54:24 <soupdragon> but you only need to consider each step individually
00:54:33 <soupdragon> and that is proof
00:54:43 <dibblego> it's defined with an implicit subscript under each <
00:54:54 <soupdragon> subscript?
00:55:08 <dibblego> < /= <
00:55:15 <soupdragon> huh
00:55:22 <dibblego> exactly my thoughts
00:55:31 <soupdragon> ...................
00:55:34 <soupdragon> what are you talking about
00:55:34 <ivanm> Jafet: yup
00:55:44 <Cale> x_1 R_1 x_2 R_2 ... R_n x_(n+1) means that for each i between 1 and n, we have that x_i R_i x_(i+1), where the x_k are numbers, and the R_k are relations.
00:55:54 <dibblego> in the expression a < b < c, each symbol < has a distinct meaning
00:56:10 <Cale> So, for instance, that expression means that a < b and b < c
00:56:12 <soupdragon> ah
00:56:21 <ivanm> I suppose part of the problem in that mathematics we don't really have the concept of left/right associativity, but when programming we do
00:56:38 <soupdragon> you try to interpret it like this [[ a < b < c ]] = [[ a ]] [[ < ]] [[ b ]] [[ < ]] [[ c ]],  which would be the compositional reading
00:56:49 <soupdragon> but this is not the right way to read it
00:56:53 <Jafet> dibblego: you can define the meaning of this hypothetical new syntax by turning it into existing syntax.
00:57:07 <soupdragon> instead you should consider  [[ a < b < c ]] = [[ a < c ]]
00:57:09 <Jafet> It's silly though, because it's not as useful as, say, do-notation
00:57:18 <Cale> soupdragon: That's not enough.
00:57:20 <ivanm> so "a `op1` b `op2` c" (where op1 and op2 have the same associativity) is a valid mathematical statement on its own, but for code we have to consider left/right associativity as well
00:57:36 <Cale> soupdragon: It needs to be [[ a < b < c ]] = [[ a < b and b < c ]]
00:57:37 <dibblego> (a < [b) < c]
00:57:44 <Jafet> Since total ordering (Ord) is fully associative, it doesn't matter
00:57:48 <Cale> dibblego: Right.
00:57:57 <Jafet> But then would you make all methods of Ord reserved tokens?
00:58:38 <Cale> This notation is probably quite an awkward thing to add to Haskell.
00:58:40 <soupdragon> in the case of proofs like I said a moment ago you should consider _the entire expression_  [[ A_1 <O_1> A_2 <O_2> ... <O_n> A_{n+1} ]] = [[ A_1 <LUB(O_1,O_2,...,O_n)> A_{n+1} ]]
00:58:45 <Cale> I wouldn't recommend it.
00:58:50 <Cale> But it does make sense as a notation.
00:58:58 <soupdragon> but it is also important to note that each part has meaning alone
00:59:02 <Cale> It's great for mathematics in general.
00:59:11 <soupdragon> for example  [[ A_3 <O_3> ... <O_7> A_8 ]] 
00:59:59 <Cale> soupdragon: I think you misunderstand what a least upper bound is, perhaps.
01:00:13 <soupdragon> Cale, I wasn't sure if LUB is the correct name.
01:00:29 <soupdragon> what I mean is if you write   a < b = c <= d then you can say that a < d
01:00:30 <dibblego> when I say "doesn't make sense", I don't mean it as strongly as it seems
01:00:33 <Cale> a < b < c doesn't mean the same thing as a < c
01:00:40 <Cale> But it does imply a < c
01:00:44 <soupdragon> which operation is it that  F(<,=,<=) = <  ?
01:00:48 <gwern> preflex: seen dons 
01:00:48 <preflex>  dons was last seen on #haskell 2 hours, 13 minutes and 33 seconds ago, saying: luite: yes, i noticed  that.
01:01:02 <Cale> soupdragon: er...
01:01:04 <gwern> hm, I wonder if my message made it. someone said lb crashed yesterday
01:01:10 <Cale> soupdragon: Not sure what you're thinking of :)
01:01:36 <soupdragon> Cale, if you have chain like this you can find a relation to summarize it all
01:02:01 <gwern> dons: incase you didn't get my lb message - in your thesis you link the old UNSW lambdabot homepage (with old repo etc.). was that deliberate?
01:02:11 <Cale> soupdragon: You mean to summarize what it says about the first and last elements?
01:02:27 <Cale> (if you throw away the rest, you really are discarding information)
01:02:27 <soupdragon> yes
01:03:14 <soupdragon> if you had a chain of  A <=> B <= C <=> D <=> F then you would say A <= B because <= is weaker than <=>
01:04:24 <soupdragon> this is not the glb?
01:04:41 <Cale> Of course, you're using the fact that everything points in the right direction, along with various sorts of transitivity and equivalence there.
01:05:30 <Cale> A <= B > C  doesn't say much about how A and C are related, for example.
01:06:39 <soupdragon> R \subrelation S can be defined as an abbrevation for  A /\ S = R
01:06:40 <Cale> It's the transitivity of < which you're using when you infer a < c from a < b and b < c
01:06:53 <soupdragon> so (<=>) /\ (<=) = (<=)
01:06:58 <Cale> Sure.
01:07:02 <soupdragon> but  (<=) /\ (>) = empty relation
01:07:15 <Cale> and (<) /\ (=) is the empty relation as well
01:08:00 <krainboltgreene> Q: Why is this[http://imgur.com/cUuCW] so sexy? 
01:08:07 <krainboltgreene> Arg. http://imgur.com/cUuCW
01:09:00 <Cale> krainboltgreene: Because they purchased a stock photo for the background, and coloured the logo like it :)
01:09:14 <soupdragon> hmmmm
01:09:31 <soupdragon> there is really no operation for this ?
01:09:40 <krainboltgreene> Here's the link: http://code.haskell.org/haskell-platform/download-website/
01:10:01 <Zao> Too bad that it wraps on a modest 1920-wide monitor.
01:10:03 <Cale> soupdragon: In a restricted context, you could define one
01:10:04 <soupdragon> I must have just invented this fiction myself, I always thought I read it somewhere
01:10:17 <krainboltgreene> There's some things I'd change, yeah.
01:11:02 <Zao> A 137 KiB image is a bit scary too.
01:11:04 <Cale> Like, you could take the set {"<", "<=", "="}, and define  "<" * "=" = "<", etc.
01:11:39 <Cale> Zao: It's supposed to scale.
01:11:52 <Cale> Zao: But it doesn't in Firefox
01:12:05 <Cale> Scaling introduces a different problem though.
01:12:11 <Zao> Cale: It does scale in FF4 by the way.
01:12:24 <krainboltgreene> Maybe I should flex my skill on making a mock up for haskell.org.
01:12:35 <Zao> Cale: But still fails if your window is slim enough.
01:12:47 <Zao> Then it wraps vertically instead.
01:13:09 <Cale> yeah
01:13:38 <Cale> On my machine, I can't get it to wrap in either direction, because the picture is much larger than my display, and it doesn't scale.
01:13:50 <Zao> http://www.acc.umu.se/~zao/hpbg01.png
01:16:20 <Jafet> firefox only gets image scaling right if you use mozilla css extensions
01:17:47 <napping> An instance of the form IsString (... -> ...) makes for some interesting grammar
01:24:28 <ttt-> do you guys use haskell for shell commands?
01:25:00 <kamatsu> ttt-: what do you mean?
01:25:24 <soupdragon> in ghci I just :! 
01:25:39 <ttt-> to do quick things in a console window.. "take first word of the last ten lines"
01:26:04 <kamatsu> oh, i use shell sometimes and haskell some other times
01:26:15 <Zao> ttt-: shell builtins, standard tools or perl.
01:26:20 <kamatsu> that particular example is easily done in shell, but you could do it in haskell too
01:26:47 <roaldfre> I'm planning to implement a neural net lib in haskell. Speed is of course a major concern. Should I just work with lists, or something more exotic/speedy? (I know basic haskell, but I'm still uncomfortable with monads; this is supposed to be a learning experience) 
01:26:51 <soupdragon> can anyone remember what the  data T a = a :-> [T a]  is for?
01:27:18 <soupdragon> I guess you can make a trie
01:27:29 <kamatsu> main = interact  $ unlines . reverse . map (unwords . take 1 . words) . take 10 . reverse  . lines
01:27:42 <Taejo> soupdragon: I remember seeing (:->) used for tries
01:27:48 <kamatsu> actually unwords is not needed
01:27:56 <kamatsu> main = interact  $ unlines . reverse . map (take 1 . words) . take 10 . reverse  . lines
01:28:17 <kamatsu> main = interact  $ unlines . reverse . map (head . words) . take 10 . reverse  . lines
01:28:18 <ttt-> there are a bunch here http://www.haskell.org/haskellwiki/Applications_and_libraries/Operating_system#Haskell_shell_examples .. wondering which one to try
01:28:30 <Jafet> That's not getting you to any PGA Open.
01:28:41 <kamatsu> Jafet: any suggestions?
01:29:00 <ttt-> kamatsu, you'd have to open up a ghci first though.. it's not very handy
01:29:00 <Jafet> Use a perl iron
01:29:16 <Jafet> echo 'main = ...' | runhaskell
01:29:32 <kamatsu> ttt-: it depends on if i want to keep the script for later use
01:29:37 <kamatsu> ttt-: if not, then i may well just use shell
01:29:42 <kamatsu> but sometimes haskell is alot easier
01:29:50 <kamatsu> i.e, capitalizing the first letter of each word 
01:30:12 <kamatsu> the tasks many use perl for I use haskell for
01:31:24 <Jafet> You can invent a text processing prelude.
01:31:27 <ttt-> someone should hack up a version of the shell so can mix normal shell commands and haskell code in some way
01:31:43 <kamatsu> ttt-: hsh? :P
01:31:43 <Jafet> You'll still be far away from perl syntax, though.
01:31:47 <soupdragon> ttt-, I was thinking it woud be cool to write a shell monad
01:31:57 <soupdragon> some kind of combinator library which lets you do pipeline type stuff
01:32:12 * ttt- checks out hsh
01:32:16 <araujo> hashell!
01:32:16 <kamatsu> ttt-: it doesn't exist
01:32:21 <kamatsu> ttt-: it wasn't a real suggestion
01:32:23 <araujo> @where hashell
01:32:24 <lambdabot> haskell.org/hashell
01:32:40 <ttt-> http://darcs.complete.org/hsh
01:32:51 <ttt-> heh, there was a link on for it
01:33:02 <ttt-> but it doesnt work
01:33:28 <krainboltgreene> @where are my keys
01:33:29 <lambdabot> I know nothing about are.
01:35:51 <roaldfre> @where love
01:35:51 <lambdabot> http://en.wikipedia.org/wiki/Where_Is_Love%3F
01:36:24 <ttt-> @where where
01:36:24 <lambdabot> ^^^^^^
01:36:48 <ttt-> @where where where
01:36:48 <lambdabot> ^^^^^^
01:37:00 <krainboltgreene> @where lambdabot
01:37:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:37:15 <krainboltgreene> @where birth certificate
01:37:16 <lambdabot> I know nothing about birth.
01:37:20 <krainboltgreene> I bet.
01:37:29 <soupdragon> > 22/7+cos(22/7)+cos(22/7+cos(22/7))
01:37:30 <lambdabot>   1.6014913654825844
01:37:46 <soupdragon> doesn't look like pi to me
01:38:10 <soupdragon> > pi/2
01:38:12 <lambdabot>   1.5707963267948966
01:38:19 <Jonno_FTW> > 2*pi /3
01:38:20 <lambdabot>   2.0943951023931953
01:38:30 <soupdragon> > 157/100
01:38:31 <lambdabot>   1.57
01:38:36 <krainboltgreene> Um.
01:38:37 <soupdragon> > 158%100
01:38:38 <lambdabot>   79 % 50
01:38:46 <Jonno_FTW> > 3*pi /4
01:38:47 <lambdabot>   2.356194490192345
01:38:50 <soupdragon> > 2*(79/50+cos(79/50)+cos(79/50+cos(79/50)))
01:38:51 <lambdabot>   3.141592653589793
01:38:52 <krainboltgreene> Half of pi is more than pi?
01:39:04 <krainboltgreene> Wait.
01:39:11 <krainboltgreene> Yeah, I'm sleep deprived.
01:39:11 <soupdragon> > 2*(79/50+cos(79/50)))
01:39:13 <lambdabot>   <no location info>: parse error on input `)'
01:39:13 <soupdragon> > 2*(79/50+cos(79/50))
01:39:14 <lambdabot>   3.1415929134623837
01:39:26 <soupdragon> > 22/7+2*cos(79/50)
01:39:27 <lambdabot>   3.1244500563195263
01:39:30 <soupdragon> odd
01:39:34 <krainboltgreene> For some reason I was thinking pi was 1.41
01:39:36 <ttt-> does that converge to pi if you add more terms?
01:39:41 <soupdragon> hehe what
01:39:46 <soupdragon> ttt- yes apparently
01:39:52 <soupdragon> I've not thuoght of why yet
01:40:04 <soupdragon> > cos(pi/2)
01:40:05 <lambdabot>   6.123233995736766e-17
01:40:06 <soupdragon> ad that's why
01:40:07 <soupdragon> ^ 0
01:41:29 <ttt-> so the 79/50 is just a starting point?
01:42:21 * ttt- doesnt understand
01:42:46 <soupdragon> you do undersatnd
01:42:47 <soupdragon> you are right
01:42:56 <soupdragon> 79/50 is close to pi/2
01:44:09 <soupdragon> cos(pi/2) = 0, so pi/2 + cos(pi/2) = pi/2, but if x is close to pi/2 then x + cos(x) should be closer because the slope of the function is such that it falls toward pi
01:44:29 <soupdragon> > 9/5+sqrt(9/5)
01:44:30 <lambdabot>   3.141640786499874
01:44:50 <krainboltgreene> Why does Haskell.org have like, 5 different main pages?
01:45:00 <wli> soupdragon: http://en.wikipedia.org/wiki/Aerial_%28album%29 if you want the digits of pi sung to you
01:45:10 <soupdragon> wli heh cool
01:45:15 <soupdragon>  I know most of them already though
01:45:26 <soupdragon> what Kate Bush??
01:45:37 <soupdragon> I didn\t know about this
01:46:07 <soupdragon> OMG
01:46:15 <soupdragon> today I discovered 9/5+sqrt(9/5)
01:46:22 <soupdragon> this is due to Ramanujan
01:47:17 <soupdragon> > sqrt(sqrt(2143/22)) :: CReal
01:47:19 <lambdabot>   3.1415926525826461252060371796440223715579
01:48:05 <ttt-> > let z = 79/50 in z + cos(z) + cos(cos(z)) + cos(cos(cos(z))) 
01:48:06 <lambdabot>   3.1110920480454807
01:48:16 <ttt-> > let z = 66 in z + cos(z) + cos(cos(z)) + cos(cos(cos(z))) 
01:48:17 <lambdabot>   66.39835206907075
01:48:29 <ttt-> > let z = 1 in z + cos(z) + cos(cos(z)) + cos(cos(cos(z))) 
01:48:30 <lambdabot>   3.0521453122123123
01:48:53 <ttt-> doesnt work
01:48:58 <soupdragon> ttt-, no it's z_{n+1} = z_n + cos(z_n)
01:49:03 <soupdragon> so you have to go:
01:49:03 <soupdragon> z
01:49:06 <soupdragon> z + cos(z)
01:49:08 <soupdragon> z + cos(z) + cos(z + cos(z))
01:49:13 <soupdragon> z + cos(z) + cos(z + cos(z)) + cos(z + cos(z) + cos(z + cos(z)))
01:49:21 <soupdragon> it's like the fibonacci sequence, but with 'cos' put in 
01:50:17 <roaldfre> I'm planning to implement a neural net lib in haskell. Speed is of course a major concern. Should I just work with lists, or something more exotic/speedy? (I know basic haskell, but I'm still uncomfortable with monads; this is supposed to be a learning experience) 
01:50:41 <roaldfre> (sry for spam, noone answered above)
01:51:32 <soupdragon> roaldfre: oh yeah I forgot to mention it but there are some other people working on neural nets
01:52:18 <Jonno_FTW> I suggest using monads
01:52:59 <roaldfre> yes, I have found HNN, it uses UArrs I think. But I want to start from the ground up to learn
01:53:43 <roaldfre> monads to capture the state-like character?
01:57:12 <roaldfre> Also, if I would just use regular lists, will ghc be able to optimize that to a fast (unboxed) version, or do I really need to use a special data type, like the UArrs in HNN?
01:57:35 <soupdragon> > sin(1/5555555) :: CReal
01:57:37 <lambdabot>   0.0000001800000180000008279998883999612546
01:57:48 <napping> there are no unboxed lists
01:57:52 <ttt-> > let doTimes f 0 = f ;  doTimes f n = (doTimes f (n - 1)) . f ; step z = z + cos z in 2 * doTimes step 46500 3
01:57:53 <lambdabot>   3.141592653589793
01:57:55 <ttt-> woo
01:57:59 <soupdragon> hah
01:58:11 <ttt-> > let doTimes f 0 = f ;  doTimes f n = (doTimes f (n - 1)) . f ; step z = z + cos z in 2 * doTimes step 46500 1
01:58:12 <lambdabot>   3.141592653589793
01:58:21 <ttt-> > let doTimes f 0 = f ;  doTimes f n = (doTimes f (n - 1)) . f ; step z = z + cos z in 2 * doTimes step 46500 0
01:58:23 <lambdabot>   3.141592653589793
02:01:16 <soupdragon> > 2 * (product . take 10 $ iterate (\two -> 2/sqrt(2 + two)) 2)
02:01:17 <lambdabot>   10.857233377164027
02:02:38 <roaldfre> If I generate a new neural net/weight vector every trainig step, would ghc be able to recognize that he can discard the unused previous net and not allocate a new one every step (hammering the memory)?
02:03:36 <soupdragon> > 2^11 / (product . take 10 $ iterate (\two -> sqrt(2 + two)) (sqrt 2))
02:03:37 <lambdabot>   3.1415914215111997
02:05:00 <Jonno_FTW> roaldfre: have you looked at the lazy bytestring package? It has sometihng similar, but you may want to look into how the garbage collector works
02:06:45 <roaldfre> Jonno_FTW: thx for the pointers!
02:07:54 * krainboltgreene installs Haskell.
02:08:23 <ttt-> im not an expert, but isnt it best to optimize after you write a basic version first?
02:08:37 <soupdragon> it's sensible to choose efficent data structures
02:08:49 <Jonno_FTW> ^
02:09:20 <ttt-> after you notice it's slow
02:09:27 <ttt-> otherwise you should have bothered 
02:09:32 <ttt-> shouldnt*
02:11:14 <roaldfre> hmm, that lazy bytestring is a tad over my head :S
02:11:36 <Jonno_FTW> how long have you been learning haskell for?
02:13:25 <roaldfre> I did a one semester course on prolog and haskell. We learned basic haskell, no Monads. I'm willing to learn more, which is also the goal of the neural net lib
02:15:26 <roaldfre> Maybe I should just go for Data.Array.Vector.UArr, as used in HNN. (I assume the U in UArr means 'unboxed'?)
02:54:42 <drbean> > let firstC = \c (x:xs) -> c == x
02:54:43 <lambdabot>   not an expression: `let firstC = \c (x:xs) -> c == x'
02:55:26 <drbean> If I have firstC and do > firstC 'a' "dfsd", I get an error.
02:56:03 <drbean> It says expected type is `()'. But I am supplying a Char.
02:56:41 <drbean> It can't be that it can't determine the type.
02:56:58 <drbean> It would have allowed the Char in that case.
02:57:29 <drbean> What is the type `()'?
02:57:41 <Botje> it's the unit type
02:57:41 <gwern> > let firstC c (x:_) = c == x in firstC 'a' "dfsd"
02:57:42 <lambdabot>   False
02:57:46 * gwern shrugs
02:58:09 <angstrom> the type of () is ()
02:58:49 <drbean> The type of a type?
02:59:02 <Botje> it's like data () = ()
02:59:04 <c_wraith> No.  () is the only value of the type ()
02:59:20 <dibblego> data Unit = Unit
02:59:44 <drbean> A data constructor?
02:59:50 <Botje> yes
03:00:18 <Botje> haskell has inferred the correct type a -> [a] -> Bool, but it has to pick a type to fill in a, which happens to be ()
03:00:58 <drbean> the Unit type?
03:01:30 <Botje> yes
03:01:58 <Botje> drbean: however, if you give the function as gwern showed, haskell doesn't have to pick a type
03:02:12 <Botje> and it gets the type firstC :: (Eq a) => a -> [a] -> Bool
03:08:51 <drbean> If I define in firstC in a module, without a type signature, and try to load it, I get an ambiguous type variable 'a' error
03:09:39 <drbean> It's complaining about the use of `=='
03:10:10 <Botje> it shouldn't complain ..
03:10:19 <Botje> it should just give you a function definition
03:10:26 <Botje> did you also use the function in your module?
03:10:37 <drbean> It says use -fno-monomorphism-restriction
03:10:52 <drbean> No I just defined it.
03:12:49 <Botje> mine just loads, actually
03:12:55 <Botje> do you have anything else in the file?
03:13:28 <drbean> Yes. this is 6.8.3 approx.
03:14:50 <Botje> can you put the file on hpaste?
03:15:04 <Botje> because i can't reproduce it here, on 6.10
03:19:25 <drbean> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27660#a27660
03:20:03 <Botje> oh
03:20:11 <Botje> you're still using the explicit lambda
03:20:31 <Botje> firstS c (x:xs) = c == x
03:20:35 <Botje> this typechecks fine
03:21:42 <Botje> if you still want to use the explicit lambda you /have/ to give a type
03:21:45 <drbean> Oh.
03:21:54 <Botje> (or disable the monomorphism stuff, yes)
03:22:03 <drbean> Interesting.
03:23:56 <drbean> And in ghci, 'let firstS c (x:xs) = c == x'
03:24:15 <Botje> http://www.haskell.org/tutorial/pitfalls.html # for some information why this happens
03:24:20 <Botje> yeah
03:24:34 <drbean> And then running 'firstS 'd' "dfds" ', there is no error.
03:24:40 <dibblego> @hoogle Word64 -> Word64 -> Word64
03:24:41 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
03:24:41 <lambdabot> Prelude max :: Ord a => a -> a -> a
03:24:41 <lambdabot> Prelude min :: Ord a => a -> a -> a
03:24:56 <Botje> drbean: if you check the type you'll see it gets properly inferred
03:25:36 <Botje> drbean: try defining your function again with the explicit lambda and look at the type 
03:26:12 <drbean> Oh, look. It's () -> [()] -> Bool with the lambda.
03:46:42 <dibblego> @hoogle (Monad m, Monad n) => m (n a) -> (a -> m (n b)) -> m (n b)
03:46:43 <lambdabot> No results found
03:49:29 <dibblego> @type \a -> fmap join . (a >>=) . mapM
03:49:29 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => f [a1] -> (a1 -> f [a]) -> f [a]
04:23:16 <nlogax> hmm, i'm trying to upgrade yi, but it requires transformers >=0.0.1 && <0.2, hackage has 0.2.1.0, so it fails. does that mean i can't install it from hackage?
04:30:52 <Silvah> You can.
04:31:26 <Silvah> Install transformers-0.1.4.0 and it'll work.
05:22:28 <Silvah> Anyone's alive?
05:51:56 <ivanm> @. elite yow
05:51:57 <lambdabot> (OU|dn'7 FiNd fOr+un3 phil3
05:52:03 <ivanm> @. elite protontorpeedo
05:52:03 <lambdabot> Plugin `compose' failed with: Unknown command: "protontorpeedo"
05:52:06 <ivanm> @. elite protontorpedo
05:52:06 <lambdabot> As u zC41E 4nd COmP13xItY gR0\/\/s?
06:11:59 <Silvah> This means "no", am I right?
06:31:05 <Phyx-> Howdy, does anyone know if there's a better way to do http://phyx.pastebin.com/cGJH5Udu (mainly the check and cast) and would this be considered a hack?
06:34:16 <Botje> can't you try the cast directly?
06:35:24 <Phyx-> Botje: you mean just (x :: Var)
06:35:36 <Botje> cast x :: Maybe Var ?
06:36:51 <Phyx-> Botje: yeah, i could but I would never call the function with anything else, but the type has to remain generic, so someone *could* call it with something else
06:36:59 <Phyx-> but then the cast should fail
06:37:08 <Phyx-> right, the check isn't needed
06:37:11 <Phyx-> good point
06:39:11 <Phyx-> heh, why didn't i see that earlier
06:39:22 <Phyx-> that whole thing just reduces to "c x = fmap varType (cast x :: Maybe Var)"
06:39:25 <Phyx-> thanks Botje 
06:41:46 <Botje> hooray ! :)
06:43:32 <Phyx-> lol, now it won't work in 6.12 anymore, no instance for Typeable :P guess i could add an ifdef
06:46:21 <Phyx-> *** forall t a. GHC.Num.Num t => (t, [a]) -> (t, [a]) -> (t, [a])
06:46:23 <Phyx-> perfect
06:46:42 <Phyx-> well, i should probably drop the forall and GHC.Num
06:47:33 <aristid> @. elite type sum
06:47:34 <lambdabot> ph0R4lL A. (Num 4) => [4] -> 4
06:48:52 <Phyx-> o.O?
06:49:33 <Jafet> @. elite type fmap fmap fmap
06:49:34 <lambdabot> f0r4LL (F :: * -> *) a b (F1 :: * -> *). (phunCT0R f, FUncTOr f1) => (a -> B) -> f (f1 a) -> f (f1 B)
06:54:17 <Phyx-> ah i get it, just changed the output
06:54:20 <Phyx-> changes*
06:55:29 <Taejo> @. elite quote quicksilver 
06:55:29 <lambdabot> QUIcksiLvEr $ay5: or In jaV4, W3'D m4xe i+ M0r3 9ENEri( BY UzINg 4 pOlynoMI4lDIVIzIONopERAT0rphaC+oRy.
06:55:52 <Taejo> @. . elite elite quote quicksilver 
06:55:52 <lambdabot> Plugin `compose' failed with: Unknown command: "1337"
06:56:06 <Taejo> @. elite . elite quote quicksilver 
06:56:06 <lambdabot> qUIXX$I|\/3r 5ay$: N0, y0U Mi5pel7 >> as ;
06:56:17 <aristid> @. elite run text . intercalate ". " $ replicate 10 "yes it does"
06:56:18 <lambdabot> Y3s it doEz. yez it DOEz. Yez0rz i+ doe5. yEs it do3s. YE5 i+ d03S. YEz0rz I+ D03...
06:56:53 <Taejo> :t text
06:56:53 <lambdabot> String -> Doc
06:57:28 <Taejo> @. elite . type run text "id"
06:57:30 <lambdabot> phorA|l A. A -> a
06:57:57 <Phyx-> @. elite quote Phyx-
06:57:58 <lambdabot> fyX- zaYz: I5 @w|-|Ere Ops tHe EquIVa1Ent OF dIzpLAying A 8AT SigN4| iN +H3 sKY?
06:58:05 <Phyx-> wow, how unreadable
07:01:38 <Silvah> @. elite type (>>=)
07:01:40 <lambdabot> foR4Ll (M :: * -> *) 4 b. (Monad M) => /\/\ 4 -> (a -> /\/\ b) -> /\/\ B
07:02:35 <Silvah> Yeah, perfect if someone wants to frighten small programmers.
07:03:42 <Silvah> @. elite quote template
07:03:43 <lambdabot> qw31234 $aYs: foR +he MaJoRITY 0f 7azks, c++ tEMpLA+E$ pRoDu(e cOdE 7|-|a+ iz c|E4Rer aND be+TEr 7yPe-CHEcxED [7hAn HazKe|L].
07:03:58 <Phyx-> Silvah: or to send to kids over msn these days
07:04:00 <Jafet> @vixen What do you think about small programmers?
07:04:02 <lambdabot> a program? what do you mean a program??
07:07:53 <Silvah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27667#a27667 - could it be improved somehow?
07:11:08 <Phyx-> @src Maybe MonadPlus
07:11:09 <lambdabot> Source not found. Just try something else.
07:11:13 <Phyx-> @src MonadPlus Maybe
07:11:14 <lambdabot> Source not found. You speak an infinite deal of nothing
07:11:25 <rovar> anyone here familiar with xmonad happen to know how change a window from tiled to tabbed?
07:11:27 * Phyx- slaps boty
07:11:34 <rovar> i know it's off topic.. but xmonad is sleepy
07:15:57 <benmachine> @src Maybe mplus
07:15:57 <lambdabot> Nothing `mplus` ys = ys
07:15:57 <lambdabot> xs      `mplus` ys = xs
07:16:15 <Phyx-> I always forget how that command works
07:16:31 <benmachine> it just looks stuff up in a file
07:17:22 <kmc> Silvah, looks really good to me
07:18:37 <kmc> it's an asymmetric diff though
07:18:48 <kmc> is that what you wanted?
07:20:05 <Silvah> yup
07:20:30 <dcoutts> dibblego: ping
07:20:45 <chrisdone> hi
07:27:42 <Phyx-> weee, after stripping and packing the exe becomes 5mb
07:27:53 <Phyx-> much better than the 30mb ghc generates
07:27:54 <Phyx-> lol
07:28:42 <kmc> haha
07:28:55 <kmc> how did you pack?
07:28:58 <Phyx-> upx
07:29:49 <kmc> it doesn't do linux/elfarm :/
07:30:18 <Phyx-> it doesn't?
07:30:22 <Phyx-> i thought supported linux
07:30:39 <Phyx-> homepage says it supports elf
07:30:54 <kmc> only on i386, amd64, and ppc32 it seems
07:31:12 <Phyx-> but there's an ARM build of the tool itself
07:31:13 <Phyx-> odd
07:31:15 <kmc> oh
07:31:20 <kmc> maybe i'm misreading the manpage
07:31:32 <Jafet> "Supported executable formats: [...] arm-linux.elf"
07:31:36 <kmc> ok
07:31:53 <Jafet> Maybe it won't cross-compress executables
07:34:11 <Phyx-> hmm, ok, time to go spelunking in the GHC sources again
07:34:51 <kmc> hehe
07:34:53 <kmc> to what end?
07:36:47 <Saizan> it must be very crowded down there lately.
07:36:55 <Phyx-> lol
07:37:35 <Phyx-> kmc: well, find out how to implement a function i saw in a presentation of Simon, which i can't find, don't think he got time to make it.
07:38:18 <Phyx-> and figure out how getInfo works, I think that requires an Interactive session
07:40:19 <Phyx-> i'm having a weird problem
07:40:28 <Phyx-> ghc panics and says it can't find ghc-prim
07:40:33 <Phyx-> but ghc-pkg shows it
07:40:51 <Phyx-> and check shows no problems
07:42:41 <Phyx-> the error is
07:43:10 <Phyx-> "HSghc-prim-2.0.0.o: unknown symbol `_stg_getMaskingStatezh
07:45:02 <pastorn> @pl (\f g -> f >>= return . g)
07:45:03 <lambdabot> (. (return .)) . (>>=)
07:46:05 <pastorn> ah, fmap :D
07:46:35 <Phyx-> anyone got any suggestions
07:48:34 <Saizan> preflex: zdec _stg_getMaskingStatezh
07:48:34 <preflex>  _stg_getMaskingState#
07:54:23 * Phyx- kicks his ghc
07:54:28 <Phyx-> the old trusted method
07:54:50 <benmachine> Phyx-: it's not hidden, or anything?
07:54:55 <Jafet> That's a -10 to Computer Programming roll.
07:55:13 <Phyx-> benmachine: nope, if i compile an exe it works
07:55:21 <Phyx-> but ghci or a dll panic
08:14:10 <Phyx-> well, fixed, seems i somehow had a mixed compiled binary with 6.12 and 6.13
08:28:28 <Phyx-> lol, ghc just infered a type "t_ass"
08:29:06 <mreh> a.k.a bottom
08:29:26 <aristid> Phyx-: if you mix binaries of different ghc versions then you should kick yourself, not ghc :)
08:29:53 <FauxFaux> t_âŠ¥
08:29:58 <Phyx-> aristid: I wasn't the one who did it :) It was a series of unfortunate events
08:30:12 <Phyx-> mreh: lol, the last one is atleast politically correct
08:30:34 <aristid> Phyx-: that's what they always say
08:30:44 <mreh> I still can't get over the striking similarity of bottom and an actual bottom
08:31:01 <Jafet> (âŠ¥)
08:31:11 <mreh> bottom is a type right? the type containing just bottom
08:31:16 <mreh> or is that unit?
08:31:17 <FauxFaux> Jafet: {â—• â—¡ â—•}
08:31:47 <mreh> no wait, () is unit
08:31:49 <aristid> mreh: data Void?
08:32:44 <Jafet> Void#!
08:32:52 <Phyx-> Void*
08:33:29 <mreh> are you asking or telling, I don't know!
08:34:22 <Phyx-> mreh: i thought Bottom meant any type, unit would be the type containing only unit
08:34:43 <Phyx-> Bottom == undefined in haskell isn't it?
08:35:02 <mreh> I understand it's relevance to existential types
08:35:07 <mreh> its*
08:36:37 <Jafet> undefined is a kind of bottom.
08:37:11 <Saizan> the denotation of undefined is bottom
08:37:11 <Phyx-> let me rephrase what I mean, undefined is a realisation of the concept Bottom
08:37:25 <Saizan> bottom is a value in the denotational semantics
08:39:00 <Saizan> which is used to represent non-termination and other failures to evaluate an expression to another value
08:39:19 <Phyx-> Saizan: that's not necissarily the only definition. Bottom is used for various things, including describing a range over types in some type systems
08:39:23 <Phyx-> like FPH
08:39:44 <Phyx-> necessarily*
08:40:00 <Saizan> well, sure, in general bottom is just the least element in a lattice or partial order or what have you
08:40:18 <Jafet> Range over types? Never heard that phrase
08:40:22 <mreh> if I use something like transpose composed with foldl', does that mean I can avoid the inefficiency of the re-consing done by transpose?
08:41:31 <mreh> @src transpose
08:41:31 <lambdabot> transpose []             = []
08:41:31 <lambdabot> transpose ([]   : xss)   = transpose xss
08:41:32 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
08:41:33 <Phyx-> Jafet: i'm creative :)
08:41:58 <Saizan> it's called bottom precisely because when you draw a lattice it's usually on the lower end of the picture :)
08:42:06 <Phyx-> lol
08:42:39 <Saizan> there's also top
08:42:50 <mm_freak> RyanT5000: you were talking about making a game using yampaâ€¦  how do you actually run the game?  using 'reactimate' or something?
08:42:57 <Phyx-> Saizan: that i didn't know about
08:42:58 <mreh> sounds like the null pointer
08:43:08 <Jafet> But I still don't get why it's called spoon.
08:43:12 <mreh> mm_freak: that's generally the way
08:43:28 <mreh> unless you want to hand over the control of the game loop to another library
08:43:50 <mreh> s/library/other code
08:44:01 <Phyx-> hmm is there no getParentDirectory :: FilePath -> FilePath in Haskell?
08:44:31 <RyanT5000> mm_freak: yeah
08:44:41 <RyanT5000> not the entire game is in Yampa, though
08:44:46 <Saizan> Phyx-: maybe that's because there's no top in the cpo representing the domain of an haskell type :)
08:45:06 <RyanT5000> we've got sizeable chunks in pure, monadic, and foreign components
08:45:17 <Phyx-> Saizan: cpo?
08:45:19 <Saizan> Phyx-: System.FilePath should have something like that
08:45:37 <Saizan> Phyx-: complete partial order
08:45:57 <Phyx-> ah
08:46:09 <Phyx-> Saizan: thanks, I was looking in System.Directory
08:46:54 <Phyx-> > takeDirectory "C:\Foo\Ghh.hs"
08:46:55 <lambdabot>   <no location info>:
08:46:55 <lambdabot>      lexical error in string/character literal at chara...
08:47:02 <Phyx-> > takeDirectory "C:\\Foo\\Ghh.hs"
08:47:04 <lambdabot>   Not in scope: `takeDirectory'
08:48:25 <Phyx-> ok, that works
08:48:41 <chrisdone> > takeDirectory "C:\\Foo\\Ghh.hs"
08:48:42 <lambdabot>   "NEVER!"
08:49:13 <aristid> :t takeDirectory
08:49:14 <lambdabot> forall b. b -> [Char]
08:49:25 <aristid> > takeDirectory "/foo/bar"
08:49:26 <lambdabot>   "NEVER!"
08:49:39 <mreh> lol
08:49:40 <aristid> > takeDirectory undefined
08:49:42 <lambdabot>   "NEVER!"
08:49:44 <Phyx-> lol, a small file has 48 imports and 3 language extensions enabled
08:50:01 <Phyx-> well.. 2.. I no longer need existential types
08:51:03 <Phyx-> hmm i swear.. after tell ghc to inline these calls things became slower
08:51:15 <monochrom> if a package on hackage doesn't ask for base>=4 (it just asks for base>=3 or base), cabal-install selects base-3. how do I tell cabal-install to select base-4?
08:51:35 <Saizan> monochrom: --preference="base >= 4"
08:52:50 <Saizan> also, if the package works with both base-3 and base-4 it should add a base < 5 constraint, that way cabal-install won't be diffident and it'll pick base-4
08:57:18 <Phyx-> @pl (\base filename-> foldr id filename $ replicate (foldl (\n a->n + if a=='.' then 1 else 0) 0 base) takeDirectory)
08:57:19 <lambdabot> flip (foldr id) . flip replicate takeDirectory . foldl ((. flip (flip if' 1 . ('.' ==)) 0) . (+)) 0
08:57:22 <monochrom> yuck, curl asks for base-3 explicitly
08:57:23 <Phyx-> eh.. no..
08:58:52 <monochrom> thanks Saizan
08:59:48 <Saizan> np
09:01:16 <Saizan> anyhow you can mix packages built with base-3 and base-4, though i guess ghc-6.12 deprecation warnings aren't nice 
09:15:25 <Phyx-> spending hours debugging only to find you had the code in comment++
09:15:47 <Jafet> @karma spending hours debugging only to find you had the code in comment
09:15:47 <lambdabot> spending has a karma of 0
09:16:02 <Phyx-> lol
09:16:19 <Jafet> I would not want to be reborn as one!
09:16:53 <kmc> haha
09:17:43 <Phyx-> @karma
09:17:43 <lambdabot> You have a karma of 0
09:17:56 <Phyx-> could be worse
09:18:20 <kmc> > let x Â² () = x^2 in 7Â²()
09:18:21 <lambdabot>   <no location info>: lexical error at character '\178'
09:20:03 <Jafet> It's a numeric symbol, not punctuation
09:20:17 <kmc> :(
09:20:22 <kmc> â˜¹
09:20:38 <kmc> > let (â˜º) = (>) in 3 â˜º 4
09:20:40 <lambdabot>   False
09:22:05 <Jafet> ... unicode says that's a letter?
09:22:10 <Jafet> Or maybe my program is wrong
09:24:34 <Twey> > isAlpha 'â˜º'
09:24:36 <lambdabot>   False
09:24:40 <Twey> > isSymbol 'â˜º'
09:24:41 <lambdabot>   True
09:24:56 <ddarius> > isPunctuation 'â˜º'
09:24:58 <lambdabot>   False
09:25:40 <Twey> > map ($ 'Â²') [isAlpha, isNumber, isSymbol, isPunctuation]
09:25:41 <lambdabot>   [False,True,False,False]
09:25:55 <Twey> Well, that's odd
09:26:03 <benmachine> is it?
09:26:05 <Twey> Hm, I guess it makes sense.
09:26:17 <cuba> @type ^
09:26:18 <lambdabot> parse error on input `^'
09:26:21 <Twey> > 2Â²
09:26:22 <lambdabot>   <no location info>: lexical error at character '\178'
09:26:24 <benmachine> @type (^)
09:26:25 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
09:26:30 <Twey> â€” number literals like these would be nice
09:26:38 <cuba> @type (*)
09:26:39 <lambdabot> forall a. (Num a) => a -> a -> a
09:26:44 <benmachine> Twey: how nice, really?
09:26:44 <cuba> :)
09:27:02 <Phyx-> @type getInfo
09:27:03 <lambdabot> Not in scope: `getInfo'
09:27:19 <Twey> benmachine: Not very nice, but amusing :Ã¾
09:27:28 <Phyx-> @type GHC.getInfo
09:27:29 <lambdabot> Couldn't find qualified module.
09:27:34 <brachiel> > ² * ²
09:27:35 <lambdabot>   <no location info>: parse error on input `ï¿½'
09:27:36 <Phyx-> boo
09:27:52 <benmachine> Twey: mm, ok yes
09:28:13 <mornfall> How do you debug <<loop>>? :)
09:28:30 <ddarius> mornfall: You add -Wall and look for shadowed variable warnings.
09:28:55 <mornfall> ddarius: This is a lot more messy. :(
09:29:27 <ddarius> mornfall: Are you trying to do some knot-tying-like thing?
09:29:56 <mornfall> I am trying not to, actually. But I live dangerously wrt. instances.
09:30:19 <mornfall> What is mystifying me though, the <<loop>> I get in a place I wouldn't suspect of using the instances...
09:30:20 <ddarius> mornfall: Then most likely the error you have is due to inadvertently shadowing a variable.
09:31:32 <mornfall> Well, I can fix it by making a single instance more specific, actually.
09:31:38 <mornfall> (Which I don't want to, though.)
09:32:11 <c_wraith> then it's probably calling itself recursively, some unexpected way
09:32:28 <mornfall> (But I can keep the instance around in exactly the same form, I just need to make it more specific...)
09:32:57 <cuba> 123.123 * a - 123.123*b^0.16 wont work for a,b being Num
09:33:09 <mornfall> c_wraith: Well, I have added traces to a few places, and I don't see what could go wrong. :\
09:33:26 <mornfall> Also, using ghci debugger didn't tell me much.
09:33:47 <mornfall> I was just wondering if there was a way to get something out of GHC that could help identifying *what* is <<loop>>-ing.
09:34:39 <Jafet> :t (**)
09:34:40 <lambdabot> forall a. (Floating a) => a -> a -> a
09:34:43 <ddarius> mornfall: There is a way, but it is probably more hassle than just thinking about it.  The GHCi Debugger should be able to help, failing that, compiling with profiling and adding -xc as a run-time flag will produce a "stack trace" for it.
09:35:21 <c_wraith> mornfall, what are the instance heads for succeeding and failing?
09:35:30 <mornfall> <Main.CAF><Main.CAF><Main.CAF>testcmd: <<loop>>
09:35:31 <mornfall> Wow.
09:35:59 <ddarius> mornfall: Did you compile with -auto-all?  If so, add some SCC pragmas by hand.
09:36:09 <mornfall> ddarius: Yes, -auto-all.
09:36:28 <c_wraith> isn't there also -auto-caf-all?
09:36:40 <benmachine> -auto-all -caf-all
09:36:44 <c_wraith> al
09:36:46 <c_wraith> err, ah
09:36:53 * c_wraith picked the wrong register
09:36:59 <mornfall> <Main.CAF:$dCombine_rcMg><Main.CAF:$dCombine_rcMg><Main.CAF:$dCombine_rcMg>testcmd: <<loop>>
09:37:20 <mornfall> What'd _rcMg mean?
09:37:33 <benmachine> probably nothing useful
09:37:37 <Jafet> preflex: zdec Main.CAF:$dCombine_rcMg
09:37:38 <preflex>  Main.CAF:$dCombine_rcMg
09:38:23 <mornfall> combine is a class method (for the problematic class) so that hints somewhat...
09:38:41 <mornfall> I suspect I might have created a dictionary loop...
09:39:01 <mornfall> (overlapping, undecidable, flexible instances needed)
09:39:31 <mornfall> Ohwell, I'll have to get out of this differently.
09:40:10 <c_wraith> that's why I wanted to see your instance heads
09:41:05 <mornfall> class (Data cmd, Data flag, FlagType flag, Combine cmd flag)
09:41:06 <mornfall>       => RecordCommand cmd flag | cmd -> flag 
09:41:10 <mornfall> instance RecordCommand cmd flags => Combine cmd flags
09:41:16 <kmc> can GHCi debugger do something useful with <<loop>>?
09:41:23 <mornfall> I think this "Combine" loop above makes it fry.
09:41:30 <kmc> ah this was mentioned
09:41:43 * hackagebot RefSerialize 0.2.6 - Write to and read from Strings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.2.6 (AlbertoCorona)
09:42:03 <mornfall> (If I make the instance read instance Combine RecCommand Flag, all works)
09:42:28 <ddarius> mornfall: Yeah, that's a straigh up loop.
09:42:58 <mornfall> If I drop that Combine out of the superclass context, I get incoherent instances. :|
09:43:28 <mornfall> ddarius: Well, it is, but I was trying to work out what was going on inside GHC that's breaking.
09:43:46 <mornfall> ddarius: Since correct methods get called and *later* it loops hard-to-tell-where.
09:43:55 <c_wraith> mornfall: that's more advanced than my instance-fu. good luck :)
09:44:28 <mornfall> ddarius: Which is not what I'd expect. If it was looping on trying to find the right method, I wouldn't say a word...
09:48:52 <mornfall> Ok, fixxored.
09:49:18 <mornfall> Lifting an unrelated method of the class let me remove the Combine from superclass context.
09:49:23 <mornfall> +out
09:49:30 <mornfall> And all works.
09:49:33 <mornfall> \o/
09:50:42 <mornfall> Thanks all for help. :)
10:00:23 <ddarius> mornfall: Here's a low-level description of what is happening:  Your instance compiles to something like: combineDict :: RecordCommandDict c f -> CombineDict c f, RecordCommandDict will be a record type containing the methods and also fields holding the dictionaries for each superclass.  Let's say you have instance RecordCommand Int Bool, then you'll have recordCommandDict_Int_Bool = recordCommandDefaults { ..., superCombineDict = combineDict recordComman
10:00:23 <ddarius> dDict_Int_Bool }
10:01:11 <ddarius> All that should work out fine as long as a Combine method doesn't call a RecordCommand method that calls a Combine method and so forth.
10:01:47 <ddarius> I don't think you should get <<loop>> unless you have method definitions like, combineMethod1 = recordCommandMethod3 or some such.
10:03:38 <mornfall> ddarius: Actually, I have methods just like that, indeed. Thanks for explanation.
10:04:49 <ddarius> (Just to be clear, without method definitions like that you'd get an undetected infinite loop instead assuming the vicious cycle exists, e.g. eta expanding would simply lead to an undetected infinite loop.)
10:07:56 * hackagebot ty 0.0.2 - Typed type representations and equality proofs  http://hackage.haskell.org/package/ty-0.0.2 (ConalElliott)
10:09:18 <soupdragon>   Ty a `tyEq` Ty b | a == b    = unsafeCoerce (Just Refl)
10:09:19 <soupdragon> urfhh
10:09:23 <soupdragon> what the hell
10:10:34 <ddarius> conal: Wouldn't using the type equalities, the a ~ b stuff avoid the need for the entire Proof module?
10:11:14 <soupdragon> why so UNSAFE
10:12:38 <conal> ddarius: i doubt it.  might be enlightening to try, though.
10:12:38 <monochrom> because there is no safe way
10:13:47 * soupdragon knows a safe way but it doesn't let you do (->)
10:13:59 <soupdragon> no, it's forall. that it doesn't let you do
10:14:13 <conal> soupdragon: perhaps there's a safer way for the Ty instance of IsTy.  I don't use that instance, and I haven't tried to improve on it.
10:14:22 <soupdragon> you should delete it!
10:14:31 <soupdragon> make the world a safer place
10:15:11 <conal> soupdragon: do you think that Ty abstraction is unsafe?
10:15:15 <soupdragon> if you use something like  data Type t where UNIT :: Type () ; MAYBE :: Type t -> Maybe t ; ...   (which of course can be busted open and parametrized by a signature)
10:15:34 <monochrom> last night I rebuilt haskell platform. now I see a new version will be out in a week!
10:15:38 <soupdragon> then you can ture   `tyEq`  by pattern matching and  Just Refl  works without coercion 
10:15:51 <conal> soupdragon: yes, that's the style i use.
10:15:52 <ddarius> monochrom: The GHC developers are actively after you.
10:16:46 <soupdragon> conal, well I understand that if one satisfies all the preconditions about typerep etc etc then everything is fine but nobody (almost nobody) writes the proof
10:17:00 <conal> soupdragon: i put in the typerep version as a simple alternative, since TypeRep is widely used.
10:17:09 <soupdragon> it's because the compiler can't check proofs
10:21:54 <ddarius> conal: With suitable extensions, unfortunately also involving ImpredicativeTypes, you can write: class Ty a b where tyEq :: T a -> T b -> Maybe ((a ~ b) => ())
10:22:18 <ddarius> I'm not sure how you would write the instance using unsafeCoerce though.
10:23:33 <ddarius> I'm using GHC 6.10.4 so it might work better in a newer version of GHC.
10:23:44 <conal> ddarius: wow.  if you develop that idea, i'd love to hear about it.  do you blog?
10:23:55 <ddarius> No
10:26:41 <conal> ah, too bad.
10:27:55 <nominolo> preflex: seen chrisdone
10:27:56 <preflex>  chrisdone was last seen on #haskell-blah 1 hour, 22 minutes and 46 seconds ago, saying: "only serious"
10:29:03 <ddarius> conal: The benefit of the a~b approach is all the functions in the Data.Proof.EQ module would come for free, e.g. commEq.
10:29:15 <conal> ddarius: sounds great!
10:31:05 <conal> ddarius: and i'm not attached to having an instance for wrapped typereps.
10:44:30 <illissius`> aren't they removing ImpredicativeTypes for 6.14 though? i remember hearing something like that
10:53:55 <listofoptions> sigh...i hate being a newbie....can anyone help me with this ghci error: Type found where type variable expected
10:54:17 <c_wraith> listofoptions, can you hpaste the code?
10:54:21 <c_wraith> @where hpaste
10:54:21 <lambdabot> http://hpaste.org/
10:54:40 <benmachine> illissius`: removing or replacing with something else, iirc, it's deprecated in 6.12 according tot he user's guide
10:55:05 <c_wraith> As I recall, it was making the code for the typechecker nearly unmaintainable.
10:55:18 <listofoptions> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27673#a27673
10:55:23 <c_wraith> So they tore it out, and now simon marlow is re-implementing the type checker.
10:55:38 <c_wraith> Impredicative types may make a return if it can be added to the new type checker cleanly
10:56:02 <c_wraith> listofoptions, what line is the error coming from?
10:56:16 <listofoptions> the monad instance
10:56:20 <illissius`> simon m? i thought it was simon pj doing that. he wrote the paper about it at least, if we're thinking of the same thing
10:56:38 <c_wraith> Oh, I may have misremembered
10:57:00 <Gracenotes> did you compile it with Uknown as the constructor?
10:57:14 <Gracenotes> there seems to be a mismatch..
10:57:24 <listofoptions> hmm
10:57:26 <listofoptions> oh yeah
10:57:33 <c_wraith> ah, yes.  good catch, gracenotes
10:57:41 <listofoptions> comment out the transition function
10:57:53 * listofoptions forgot
10:57:59 <Gracenotes> not sure why it just wouldn't have been in scope though
10:58:17 <listofoptions> is that what the error ment?
10:58:49 <Gracenotes> ooh, no, I think there error came from using 'class' instead of 'instance'
10:58:49 <listofoptions> idk sometimes ghci doesnt like my code
10:59:01 <Gracenotes> instance Monad Indeterminate where [...]
10:59:06 <c_wraith> heh.  yes, that's the real problem
10:59:16 <Gracenotes> s/there/the/
10:59:18 * listofoptions UBER-facepalm
10:59:22 <JoeyA> Is it possible to use rank 2 types to do something like this?  foldr2 (\a b -> b a) (\one two three four -> one * two * three * four) [4,3,2,1]
10:59:23 <listofoptions> wow
10:59:26 <c_wraith> listofoptions, I don't think you can make a monad instance form that, though.
10:59:37 <c_wraith> Because Set has an Ord constraint
10:59:43 <JoeyA> The tricky bit here is that the type of the accumulator changes as you go up.
10:59:44 <c_wraith> And there's no way to get that constraint into the monad
10:59:55 <JoeyA> If we have foldr2 :: (forall b c. a -> b -> c) -> d -> [a] -> e, can't we do that?
11:00:02 <listofoptions> i was thinking about that
11:00:07 <Gracenotes> listofoptions: so you could say class Monad a where [...] and that would work
11:00:21 <listofoptions> i was intending an instance
11:00:22 <ddarius> JoeyA: That type makes no sense.
11:00:33 <Gracenotes> but s/ a / Blah /, it fails. that's why you got the error you did though
11:00:44 <Gracenotes> it's a syntactic error not a type system on
11:00:46 <listofoptions> thanks
11:00:46 <Gracenotes> one
11:02:51 <JoeyA> ddarius: Why not?  foldr2 would be a function that takes a polymorphic function that takes an item (of a fixed type) and a collector (of any type) and yields a new collector (of any type, even if it's different).  foldr then takes an initial collector and a list of items of type a, and yields a new collector of a possibly new type.
11:03:29 <ddarius> JoeyA: And what function has that type?  Can you name any?
11:03:32 <Philonous> JoeyA: Try to come up with a function of type "forall b c. a->b->c" .
11:03:37 <JoeyA> (\a b -> b a)
11:03:44 <ddarius> :t (\a b -> b a)
11:03:46 <lambdabot> forall t t1. t -> (t -> t1) -> t1
11:03:49 <ddarius> Nope.
11:03:49 <c_wraith> that's not forall b
11:03:56 <c_wraith> b needs to be a function for that implementation
11:04:15 <JoeyA> Indeed
11:04:28 <JoeyA> again, the example using it:  foldr2 (\a b -> b a) (\one two three four -> one * two * three * four) [4,3,2,1]
11:04:45 <JoeyA> It would start by taking that function of 4 arguments and apply 1 to it.
11:04:55 <JoeyA> Then it would take the function of 3 arguments and apply 2 to it.
11:04:57 <JoeyA> etc.
11:05:26 <JoeyA> The (probably illegal) thing here is that the type is changing as we go up.
11:05:36 <JoeyA> hence the forall b c
11:06:07 <Philonous> JoeyA: But that's not what you mean. the c is supposed to depend on the a and b you supply, isn't it?
11:06:23 <JoeyA> yes
11:07:12 <soupdragon> > map (%(2*2*3*5)) [1..2*2*3*5]
11:07:13 <lambdabot>   [1 % 60,1 % 30,1 % 20,1 % 15,1 % 12,1 % 10,7 % 60,2 % 15,3 % 20,1 % 6,11 % ...
11:07:18 <soupdragon> > map (%(2*3*5)) [1..2*3*5]
11:07:20 <lambdabot>   [1 % 30,1 % 15,1 % 10,2 % 15,1 % 6,1 % 5,7 % 30,4 % 15,3 % 10,1 % 3,11 % 30...
11:07:21 <ddarius> At any rate, we can push the forall e all the way inward getting the equivalent type: (forall b c. a -> b -> c) -> d -> [a] -> forall e. e.  There is only one value of type forall e. e.
11:07:23 <soupdragon> > map (%(2*3)) [1..2*3]
11:07:24 <lambdabot>   [1 % 6,1 % 3,1 % 2,2 % 3,5 % 6,1 % 1]
11:07:28 <Philonous> JoeyA: Well, you can do that. That's what fundeps/type families are for
11:08:55 <ddarius> (Similarly for the forall c, so the passed in function can only ever return one value.)
11:11:20 <JoeyA> I guess my question now is, why doesn't (\a b -> b a) qualify as an a -> b -> c function?  Can't a function be dropped in for b here, or is that simply not allowed?
11:11:24 <dons> gwern: yes, it was intentional, to link to a page I controlled, so the content would remain permanently about the version that includes dynamic loading
11:11:33 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27674#a27674 is there an advantage to a design like this?
11:11:48 <JoeyA> If we take const, for instance:  const :: a -> b -> a
11:11:48 <kmc> it seems a longwinded way of saying "type Shrinker = String -> [String]"
11:11:51 <JoeyA> Sure, we can just say:
11:12:00 <JoeyA> > const 5 1
11:12:01 <lambdabot>   5
11:12:07 <JoeyA> But we can also use a function:
11:12:14 <ddarius> JoeyA: By having the forall b only in the first argument you are saying that -foldr2- gets to choose what type b is, not the caller.
11:12:26 <JoeyA> > (const (+3) "ignored") 5
11:12:27 <lambdabot>   8
11:12:39 <JoeyA> right
11:12:44 <Philonous> JoeyA: The thing with Rank 2 types is that you demand that your function is _at least_ as polymorphic as what you specify
11:16:04 <ddarius> kmc: The dictionaries for Read and Show would also need to be included, so you'd have data Shrinker = Shrinker (String -> Shrinker) String (String -> [String])
11:16:20 <ddarius> And then you'd need to explicitly pass these dictionaries.
11:17:00 <JoeyA> I think I get what you meant here.  (\a b -> b a) isn't polymorphic enough, since it demands that b be a function.
11:17:28 <kmc> ddarius, ah, true
11:17:29 <ddarius> JoeyA: Yes, and, using my comment, foldr2 could demand that b be Double or Bool or both.
11:17:43 <Philonous> JoeyA: The example you gave (successively applying elements of a list to a function) is still possible with fundeps. I've done that myself 
11:18:30 <ddarius> Actually, encoding the Read instance seems particularly bad, what I wrote wouldn't actually work for that.
11:19:31 <kmc> yeah
11:20:24 <kmc> so the idea is that Shrinker instances' values are like functions, but are serializable
11:20:26 <kmc> ok
11:21:17 <kmc> and the instance holds data roughly equivalent to free variables
11:22:28 <kmc> which reminds me a bit of C++, where you have to write explicit structs of free variables for every first-class function
11:22:48 <kmc> but i don't think there's an easy way to implement serializable closures in vanilla haskell
11:23:27 <aavogt> the alternative is to question whether you really need to serialize those things
11:23:44 <soupdragon> "Contrary to everybody, this self contained paper will show that
11:23:44 <soupdragon> continued fractions are not only perfectly amenable to arithmetic, they are
11:23:44 <soupdragon> amenable to perfect arithmetic."
11:23:49 <kmc> i'd guess it has to do with xmonad's dynamic recompile/reloading, but i'm not sure
11:24:00 <dolio> It can be useful to serialize functions.
11:24:08 <dolio> For mobile code and stuff.
11:24:14 <soupdragon> that is academician for "shits about to go down"
11:24:15 <dolio> Alice does it well, I think.
11:24:52 <JoeyA> Thanks for the help.  My foldr2 example was mainly to understand rank 2 types more clearly.
11:25:21 <ddarius> JoeyA: Are you familiar with formal logic at all, things like first order predicate calculus?
11:26:21 <JoeyA> Yes, but I don't understand its nuances thoroughly.
11:27:09 <c_wraith> ok, at least Data.ByteString.unpack fuses properly with foldr.  But I still wish Data.ByteString.foldr was properly non-strict
11:29:24 <Phyx-> Oh I just can't stop playing with it
11:30:04 <Phyx-> ok... I realise, taken out of context, that sentence is erm.. very wrong
11:30:17 <kmc> @vixen Oh I just can't stop playing with it
11:30:19 <lambdabot> stop what?
11:30:41 <Phyx-> lol
11:30:55 <dafis> Phyx-, In context, what can't you stop playing with?
11:31:42 <ddarius> JoeyA: This isn't really an issue of "nuances."  It would be quite helpful if you could do some basic logical manipulations, proofs, and refutations in, e.g. first order logic.  Most of it will apply unchanged to Haskell.
11:32:12 <Phyx-> dafis: finally getting round to some minor bug fixes, taking a break from implementing big features since gHC is beating me with a stick
11:32:41 <dafis> Phyx-: Over what does GHC beat you?
11:33:01 <Phyx-> and just implemented that you can *actually* double click and have infered types inserted, and correct the infered types today so that the context get shown too.
11:33:29 <dafis> Phyx-: leksah?
11:33:41 <listofoptions> grr occurs error, cannot construct infinite type
11:34:19 <Phyx-> dafis: well, i'm trying to implement something that you give a source location and a module and it looks up what's at that location, but I can't find out where that information is. trying to trace what ghci does with getInfo but that's rather elaborate and works off some kinda of InteractiveContext
11:34:24 <Phyx-> dafis: no, visual haskell
11:35:04 <dafis> Phyx-: Sounds neat. But visual haskell is windows?
11:35:04 <napping> Phyx-: that't backwards from what :info does anyway
11:35:30 <Phyx-> napping: yes, but if I could find where it gets the information, i could change it to what I need
11:35:39 <Phyx-> dafis: affirmative 
11:36:03 <napping> Phyx-: It's a nice change to hear "GHC beating you wtih a stick" from someone actually working on the annoying bits in the guts, rather than complaining about the friendly type system
11:36:17 <dafis> Phyx-: then it's not for me :(
11:37:14 <Phyx-> dafis: lol, yeah, i figure it's mostly for people used to visual studio already
11:37:54 <c_wraith> man, inlinePerformIO is funny
11:37:57 <c_wraith> inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
11:38:24 <Phyx-> napping: well, i'll eventually figure it out, but it's just taking longer than expected. which is why rather than waste another day, i'm doing some minor things i've put off till now. like also not applying "candy" on comments or string literals
11:38:28 <ddarius> @src unsafePerformIO
11:38:28 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:38:49 <Saizan> c_wraith: who know ghc could conjure a RealWorld out of nowhere, eh?
11:38:54 <Saizan> *knew
11:39:25 <c_wraith> so...  does anyone have any evidence the real world existed before ghc?
11:39:31 <dafis> unsafePerformIO :: IO a -> a
11:39:31 <dafis> unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m)
11:39:44 <soupdragon> > (70*9999+29)/(12*9999+5)
11:39:46 <lambdabot>   5.8333319443634215
11:39:49 <soupdragon> > 70/12
11:39:49 <dankna> well, ghc is contained in the real world, so if it also created it, that would be a bit metacircular
11:39:50 <napping> Phyx-: I suspect you'll have to walk the module checking the location annotations
11:39:50 <lambdabot>   5.833333333333333
11:39:55 <napping> (or perhaps build some index)
11:40:06 <Saizan> dankna: that's why it's hard to bootstrap.
11:40:10 <dankna> haha yeah
11:40:13 <Philonous> c_wraith: I suspect it's the applied banach-tarski paradox 
11:41:04 <napping> Phyx-: HsSyn types are liberally sprinkled with Located wrappers
11:42:10 <Phyx-> napping: well, I thought about using TypeCheckedModule but that doesn't give me information about everything, only bindings defined in that module. i'll take a look at HsSyn 
11:42:16 <djahandarie> Anyone got a good name for (>> return ()) ?
11:42:17 <ddarius> "Step 1: Create the heavens and the earth."
11:42:28 <dafis> djahandarie, ignore
11:42:41 <ddarius> @hoogle m a -> m ()
11:42:42 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
11:42:42 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
11:42:42 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
11:42:44 <djahandarie> I did ignoreM
11:42:57 <aristid> :t (>> return ())
11:42:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
11:43:07 <Phyx-> napping: I also want to know from which module some function was imported, so I'm guessing that somewhere there's information about packages and imports. but I have no idea where.
11:43:07 <aristid> ddarius: there :P
11:43:25 <dafis> djahandarie, or "when True"
11:43:26 <aristid> :t fixM
11:43:27 <lambdabot> Not in scope: `fixM'
11:43:40 <c_wraith> :t (() <$)
11:43:41 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
11:43:45 <Saizan> dankna: wrong type
11:43:48 <Saizan> ?type when
11:43:49 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:44:14 <napping> Phyx-: that sounds like part of what :info does, so maybe looking at GHCi would help
11:44:26 <dafis> Saizan, arrgh, I always forget when's unnecessarily restricted type
11:44:29 <aristid> :t ignore
11:44:29 <lambdabot> Not in scope: `ignore'
11:44:39 <napping> Phyx-: mind you, I could never figure out where ghci was keeping the environment between statements
11:45:13 <Phyx-> napping: yeah, that's what I tried, so I trace it, and it seems that ghci does everything based on some "InteractiveContext" which I have yet to find where it creates it/updates it.
11:45:40 <cuba> what kidn of signature i should use when i want to pass a function and two lists to be used?
11:45:53 <cuba> like ::fct->[Int]->[Int]
11:46:06 <Phyx-> napping: then GHC exposes a function "getInfo" which when i call it just returns []. I also grabbed the code which ghci uses and tried executing it in a test. and it also returns [], so somewhere they're missing *some* state
11:46:07 <dankna> cuba: what's the type of the function?
11:46:10 <c_wraith> cuba, based on your description, that doesn't include a return type
11:46:12 <napping> Phyx-: can you use the TypecheckedSource?
11:46:12 <benmachine> dafis: how would you implement when more generally?
11:46:18 <dankna> and what c_wraith said
11:46:19 <cuba> arbitrary user defined
11:46:42 <napping> If you are tryping to figure out where things are defined, isn't it enough to know about bindings?
11:46:43 <dankna> not really doable in Haskell, but if you describe the purpose of this we can probably explain how to do it without that
11:46:51 <dafis> benmachine: when cond act = if cond then (act >> return ()) else return ()
11:47:00 <dankna> the type needs to be known at compile-time to the extent that the contents of the value are actually used for anything
11:47:05 <benmachine> dafis: hmm, fair enough I guess
11:47:06 <cuba> i want to write my own zipwith
11:47:06 <Phyx-> napping: well, TypeCheckedSource has the problem it'll only give me information about local bindings, but you might want information about a function defined elsewhere. like map for instance
11:47:13 <dankna> oh
11:47:19 <c_wraith> cuba: then start with the type of zipWith
11:47:21 <dankna> then the signature is like
11:47:22 <c_wraith> :t zipWith
11:47:23 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:47:28 <napping> Phyx-: I assumed you already found the right module
11:47:33 <dankna> yeah, what lambdabot said
11:47:47 <dankna> the (a -> b -> c) is a function taking two parameters of types a and b and returning a value of type c
11:48:10 <dankna> it's in parentheses so it itself is a function parameter to the function you're defining
11:48:13 <napping> Phyx-: is the ModuleInfo effective?
11:48:29 <Philonous> dankna: c might very well be another function, so an arbitrary function would have type (a->b). But you couldn't du much with that
11:48:32 <Phyx-> napping: well, the basic idea is, I'll load a module using the GHC api, which then loads all dependencies. so if the module typechecks, ghc should know where everything is.
11:48:39 <dankna> Philonous: yeah, indeed
11:48:42 <Phyx-> napping: I don't remember why I stopped loading at module info, let me check
11:48:47 <Philonous> dankna: sorry, I meant cuba
11:48:53 <dankna> oh, np
11:49:07 <cuba> mh okay thanks ill try if i understand it right
11:49:14 <dankna> cuba: if you wanted to work only on Ints it would be (Int -> Int -> Int) -> [Int] -> [Int] -> [Int].  if that makes it clearer.
11:49:16 <dankna> good luck
11:49:24 <cuba> thx mate
11:50:13 <portnov> @type map . uncurry3
11:50:14 <lambdabot> Not in scope: `uncurry3'
11:50:14 <c_wraith> I'm sure I optimize the wrong things.  I wrote a horrible function last night to do take, foldl', and drop all in the same pass.
11:50:23 <napping> Phyx-: modInfoLookupName and modTopLevelScope both look promising - and modInfoTyThings says it is only local definitions and those two do not
11:50:55 <napping> so, how do you get the typed module?
11:51:16 <Phyx-> napping: yeah, I'm gonna see what those give back, if they give what I want then I can rewrite to search based on location
11:52:12 <Phyx-> napping: just using the standard calls, adding a target, loading it up, parsing and typechcking, then I can just ask it for the structures
11:52:30 <Phyx-> I have some code in between to cache non-changed targets
11:52:34 <c_wraith> It ended up with the lovely type signature: (a -> b -> a) -> a -> Int -> [b] -> [a]
11:53:03 <c_wraith> err, no
11:53:19 <c_wraith> (a -> b -> a) -> a -> Int -> [b] -> (a, [b])
11:53:23 <Phyx-> napping: code basically looks like http://phyx.pastebin.com/KfCDdeez
11:53:32 <c_wraith> there.  That captures how awful it is. :)
11:53:56 <dafis> c_wraith: doesn't look so horrible
11:54:16 <Phyx-> napping: i use those IORefs to save partial information along the chain, so that if for instance typechecking fails, i still get information back from the parsing phase
11:54:16 <c_wraith> dafis: just in terms of optimizing something that surely didn't need it.
11:54:37 <c_wraith> Though I would be really happy if there was an efficient version of (take n &&& drop n)
11:54:49 <napping> c_wraith: is that not splitAt?
11:54:50 <c_wraith> In the standard libraries, that is.
11:54:57 <dafis> c_wraith: splitAt not efficient?
11:55:02 <Phyx-> napping: so that you can still navigate the source etc, but the IDE would just gray out every type information you previously had since it doesn't know if they're correct
11:55:18 <c_wraith> why can I never find any proof of the existance of splitAt when I want it? >_>
11:55:30 <cuba> my so with (Int->Int->Int) ive the two arguments and the result, but how does it knows that there is also a fucntion? i guess its not right this way as it wont work :) http://pastebin.com/tS4FE42x
11:55:38 <napping> perhaps you haven't imported Data.List?
11:55:39 <Saizan> ?hoogle Int -> [a] -> ([a],[a])
11:55:39 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
11:55:39 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
11:55:39 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
11:55:45 <napping> hmm
11:56:06 <Saizan> i've seen people claim that (take n &&& drop n) was more efficient though
11:56:13 <c_wraith> Apparently, I'm just bad at operating my brain. :)
11:56:38 <dafis> Saizan: any benchmarks?
11:56:47 <napping> Saizan: well, splitAt can't hang onto the head of the list
11:56:53 <dafis> I mean, did they cite any
11:57:22 <Saizan> dafis: yeah, but it was an hpaste
11:58:08 <c_wraith> does take fuse?
11:58:23 <dafis> c_wraith: it should
11:58:52 <cuba> ah i forgot the fct in the recurisve call
11:58:53 <cuba> nevermind
11:58:54 <cuba> :)
11:59:53 <c_wraith> does hayoo not index base or something?
12:02:14 <c_wraith> yep, take is implemented in terms of build
12:03:48 <napping> Phyx-: where is hsc_entrypoint?
12:04:59 <conal> anyone here running a ghc more recent than 6.12.1?  i have some code that hangs 6.12.1, and i'm wondering if a later version can handle it.
12:05:08 <conal> the code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27675
12:05:30 <conal> i would also appreciate advice about reformulating the instance to avoid nontermination.
12:06:04 <conal> while still using associated type synonyms rather than associated data types.
12:06:18 <Phyx-> napping: it's something I added myself, all the calls to the api require a ModuleName, but i found no way to find the modulename of the first file you gave it
12:06:25 <Phyx-> so I made one
12:07:19 <Phyx-> well, not *all* but the ones i needed, typechecking and parsing do
12:09:39 <napping> Phyx-: you are manufacturing a modulesummary?
12:10:43 <Phyx-> napping: effectively yes, though not a normal module summary, one tailored to the information i need
12:11:38 <c_wraith> Oh, hey, the rewrite-rules page in the ghc manual contains a list of list operations that fuse.
12:11:51 <dafis> conal: 6.12.3 is still compiling after more than a minute
12:12:19 <conal> dafis: thanks.
12:12:46 <dafis> conal: try HEAD?
12:12:49 <conal> i think i can see how ghc gets hung up in unwinding the type instances forever.
12:13:10 <napping> conal: I wrote some stuff a while back that needed to avoid that
12:13:15 <dafis> conal:  ghc-6.10.3 --make Nontermination.hs
12:13:15 <dafis> [1 of 1] Compiling Nontermination   ( Nontermination.hs, Nontermination.o )
12:13:15 <dafis> stack overflow: use +RTS -K<size> to increase it
12:13:45 <conal> dafis: oh -- 6.10.3 rather than 6.12.3
12:13:46 <napping> Not context stack overflow?
12:14:16 <dafis> conal: I tried the old one after ^Cing 6.12.3
12:14:24 <conal> dafis: ah, thx.
12:14:31 <Phyx-> :t mapM
12:14:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:15:22 <Phyx-> :t sequence
12:15:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:15:44 <conal> napping: did you find a way to avoid that sort of loop?
12:16:24 <napping> I think you are exploding in type Trie, not the instances
12:16:45 <conal> hm.  instances for recursive types typically depend on themselves.
12:16:48 <conal> napping: ah.
12:17:49 <conal> i guess i've defined an infinite type
12:18:17 <c_wraith> In such a subtle way that the occurs check didn't find it?
12:18:36 <conal> c_wraith: looks like it
12:18:38 * Phyx- wonders why ghc is getting slower and slower in compiling
12:18:39 <Phyx-> lol
12:18:46 <aristid> oO http://learnyousomeerlang.com/
12:18:56 <Phyx-> i must be doing something weird
12:21:43 <Phyx-> hrm.. seems GHC.parseName does more than just parse
12:22:35 <Phyx-> long live source code access!
12:22:51 <c_wraith> I really do have to wonder why erlang named their in-process db mnesia.  Seems...  counter-productive.
12:23:07 <c_wraith> Or at least, it highlights the one thing an in-process db shouldn't do. :)
12:23:20 <mauke> c_wraith: what, remember data?
12:23:30 <c_wraith> I can't recall. ;)
12:23:42 <mauke> that's a-mnesia, the opposite
12:24:53 <conal> here's a simpler example of an infinite type def: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27677
12:25:04 <soupdragon> ULLOL itss an octopus hahaha
12:27:06 <inetic> hi there, as part of learning haskell I'm trying to visualize my tree data structure using gtk2hs, I've done the drawing part but now I would like to be able to select some of the tree nodes and be able to manipulate them (like applying translation). In any other language I would keep pointers to the nodes I've selected, but I just can't come up with a functional way of doing this. Surely this isn't anything new, could someone please poin
12:27:06 <inetic> t me right direction?
12:28:35 <Botje> inetic: zippers?
12:29:01 <parek> :w
12:29:04 <parek> damn
12:29:08 <inetic> Botje, I've read something about zippers, but does it not hold only one "pointer"?
12:29:26 <applicative> inetic, the trees are independent of gtk2 hs, you are using gtk2hs to view them, so to say?
12:29:39 <inetic> applicative, indeed
12:30:10 <Botje> inetic: you can use a zipper to traverse a path into your datastructure, make a local change, and going back up
12:30:33 <Botje> and then you get a new datastructure
12:31:47 <inetic> Botje, hmm, I think I know what you mean, but the problem is that all the tutorials on zippers suggest having only one "finger" that points to a node in the tree
12:31:56 <kmc> inetic, presumably your gtk2hs calls are in the IO monad; you can store state in IO monad using IORef
12:32:06 <kmc> inetic, however some of the other suggestions here might be better from the learning perspective
12:32:27 <kmc> inetic, btw did you see the 'vacuum' library?
12:32:30 <Botje> inetic: oh, i didn't see you wanted multiple pointers :/
12:32:38 <Botje> inetic: does a change in one part affect another?
12:33:02 <Botje> otherwise you can use multiple paths and apply your changes sequentialy
12:33:05 <kmc> inetic, maybe you can assign a unique id to each node, and store state in a Â«Map Id NodeStateÂ», and update that
12:33:06 <applicative> if the nodes are suitably marked there is just the expedient of using fmap, is that too simplisitc?
12:33:06 <inetic> Botje, no, they should be independent
12:33:11 <kmc> where NodeState would have the position, etc.
12:35:12 <applicative> inetic, are the trees large? zippers are cool, and iorefs are sometimes needed, but I think they are aimed at efficiency mostly.
12:35:12 <sm> does this sound familiar to anyone: parseFromFile reads characters misencoded with ghc 6.12/linux/a utf8 locale/parsec 2
12:35:21 <inetic> applicative, kmc, I was thinking about that approach at first, then I've heart about the zippers and got confused it that I should use them and somehow extend them
12:36:17 <dafis> sm: are you sure that file is also utf-8 encoded?
12:36:52 <soupdragon> Is anyone here good at 4 dimensions?
12:36:57 <applicative> the really good use case for zippers is e.g. when you have an editor with a cursor in the middle of a potentially giant text.
12:37:08 * applicative dwells in four dimensions
12:37:15 <soupdragon> can you help me with 4D geometry
12:37:15 * monochrom is not sure whether to subscribe to haskell-cafe again. is more involved now
12:37:23 <dafis> soupdragon: depends
12:37:36 <sm> dafis: yes, /usr/bin/file says so
12:37:41 * applicative was really irritated by haskell cafe, but it seems to have improved lately.
12:37:42 <soupdragon> I want a 4D proof of herons formula (or Brahmagupta's formula, which implies Heron)
12:37:58 <Veinor> just look at n dimensions
12:38:00 <Veinor> and then let n = 4
12:38:02 <Veinor> :D
12:38:15 <sm> another encoding issue: ghci> readFile "unicode-Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ°.test"  fails with file does not exist - is this expected ?
12:38:31 <inetic> applicative, kmc, Botje, ok I'll try the approach where I'll replace the selected nodes with some kind of ID node and store the real nodes + it's subtree in a Map. Thanks
12:38:34 <dafis> sm: what happens if you just read it in and calculate the length? (to see whether it's I/O or parsec or what)
12:39:11 <soupdragon> help
12:39:14 <soupdragon> pease
12:39:22 <soupdragon> sqrt((sâˆ’a)(sâˆ’b)(sâˆ’c)(sâˆ’d))
12:39:36 <dafis> sm: "unicode-Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ°.test" is more or less expected to fail, the file path chars are truncated
12:39:43 <soupdragon> you're essentially taking the 'length' of a hypersquare
12:40:20 <inetic> applicative, you mentioned the example with editor and the finger would be the cursor, but even in such example you might need more then one finger (for example when selecting text you might need the beginning end end of the selection)
12:40:28 <monochrom> soupdragon please take your 4D geometry to #haskell-blah or other channels or pm.
12:40:46 <soupdragon> why don't you go away monochrom
12:41:22 <dafis> sm: you can try utf-8 encoding "unicode-Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ°.test" to a ByteString, unpack that ByteString (via D.BS.Char8) and see whether that FilePath points to your file
12:41:23 <kmc> i dunno i kind of like having our haskell discussions punctuated by the occasional non sequitor rational approximation of pi
12:41:48 <soupdragon> monochrom you just make the channel a worse place for everyone
12:41:49 <sm> I don't see why this should fail, indeed I thought I had done this before
12:42:11 <applicative> inetic, yes, but I think that sort of thing involves a departure from the super efficiency of the zipper structure. I was thinking of the yi editor as an example, though I haven't looked into it for a while
12:42:39 --- mode: ChanServ set +o monochrom
12:42:52 <inetic> applicative, fair enough :-)
12:42:53 <dafis> sm: file-path handling is a mess, because every system does it differently
12:42:57 --- mode: monochrom set +q *!*@unaffiliated/fax
12:43:06 --- mode: monochrom set -o monochrom
12:44:58 * wli suspects #math might be more apropos of the 4D geometry
12:46:19 --- mode: ChanServ set +o mauke
12:46:19 --- kick: soupdragon was kicked by mauke (soupdragon)
12:46:19 --- mode: mauke set +b *!*@unaffiliated/fax
12:47:12 <conal> did soupdragon just get banned?  i'm not finding him a problem.
12:47:31 <mauke> I thought she was a she
12:47:33 <kmc> <soupdragon> monochrom you just make the channel a worse place for everyone
12:47:34 <applicative> oh my god, i hope not.  
12:47:36 <kmc> not a wise thing to say to an op
12:47:38 <conal> is there some history?
12:47:59 <mauke> the ban was for the cycling after getting silenced
12:48:00 <sm> ok.. I guess file paths need to be utf-8 or at least encoded.. eg do: Codec.Binary.UTF8.String> readFile $ encodeString "unicode-Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ°.test" 
12:48:03 <conal> kmc: i'd hope people don't have to treat ops differently from non-ops
12:48:15 <kmc> well, i think it's not a wise thing to say to anyone
12:48:19 --- mode: mauke set -o mauke
12:48:32 <mauke> and also <soupdragon> fuck you monochrom you stupid cunt
12:48:34 <applicative> soupdragon's feelings were hurt
12:48:38 * lispy agrees with conal 
12:48:40 <EvanR> ghc uses dynamic dispatch for type class operations? is this runtime optimized with caching or something?
12:48:40 <conal> kmc: i'm with you there.  and yet i see a lot of that sort of thing in this room.
12:48:42 <applicative> oh, i didnt see that
12:48:42 <jkingkong> hey guys, sorry I asked this yesterday but after a lot of searching myself I still haven't come across a good answer. Is there a good way of splitting parallel arrays [: a :] by index?
12:48:51 <kmc> conal, of treating ops specially?
12:48:56 <c_wraith> I wouldn't be surprised if soupdragon was vixey
12:48:59 <jkingkong> (asking again since channel populations fluctuate)
12:49:21 <conal> kmc: no.  of saying things like "ou just make the channel a worse place for everyone"
12:49:30 <kmc> conal, you've seen that a lot? really?
12:49:39 * sm makes a decision to not spend his saturday afternoon chasing encoding issues
12:49:50 <Saizan> c_wraith: correct
12:50:04 <applicative> kmc that's not right to say, but it's no worse than a lot of unpleasantness people spread on our in principle cheery channel
12:50:19 <conal> kmc: a lot of things go on here that i'd like to see improved.  i don't see the "you just make ..." remark as qualitatively worse.
12:50:28 <kmc> ah
12:50:30 <EvanR> oh my god conal your message is flashing
12:50:33 <kmc> what other improvements would you like to see?
12:50:44 <conal> EvanR: flashing??
12:50:48 <EvanR> blink
12:50:55 * conal is confused
12:50:57 <kmc> yeah, there's a U0006 after my nick
12:51:02 <EvanR> lol
12:51:03 <kmc> > ord ''
12:51:04 <lambdabot>   <no location info>:
12:51:04 <lambdabot>      lexical error in string/character literal at chara...
12:51:07 <EvanR> wtf
12:51:08 * applicative sides with conal. only the one unusually vulgar misogynist epithet impresses him.  but it could be worse
12:51:22 * lispy is grateful his client doesn't display blinks
12:51:33 <kmc> leaving aside the present incident, how should we improve the channel?
12:51:35 <monochrom> I don't keep logs but it's the second time soupdragon said something similar to me. although the first time was like 0.5 years ago or 1 year ago. although the first time was a similar circumstance, I asked it to stop being extensively off-topic.
12:51:38 <jkingkong> i have to do something like drop n as = [: xs | i <- [n..(lengthP as-1)], xs <- as!:i:]
12:51:49 <kmc> i'm here basically all the time so i'd like to know what i and others should do better
12:51:51 <jkingkong> but this seems like an ugly solution
12:51:59 <kmc> jkingkong, there's takeP and dropP aren't there?
12:52:02 <kmc> in GHC.PArr at least
12:52:11 <kmc> or do i misunderstand what you want?
12:52:13 <lispy> Yes, asking people to move off-topic discussions seems to be tricky.
12:52:27 <djahandarie> Hm... I have a ReaderT over IO, but now I also need a StateT (really just for one single thing). It seems dirty to do a StateT and a ReaderT
12:52:44 <kmc> djahandarie, are you calling xmonad dirty?!?!?
12:52:44 <kmc> ;)
12:52:58 <djahandarie> Oh yeah, xmonad does do that doesn't it
12:53:01 <kmc> newtype X a = X (ReaderT XConf (StateT XState IO) a)
12:53:01 <djahandarie> Hmmm
12:53:07 <kmc> but it is a little questionable, *shrug*
12:53:21 <applicative> jkingkong, i wonder what the usual function is for un parallel arrays
12:53:33 * Saizan doesn't see it as problematic, unless you want to forkIO
12:53:38 <ttt-> of course it's dirty, it does IO :)
12:53:47 <jkingkong> applicative: well, usually it's splitAt for lists
12:54:15 <jkingkong> applicative I realize these are "arrays" but slicing an array is fairly common no?
12:54:27 <kmc> lispy, i think it should depend a lot on other conversations going on.  most OT in an otherwise empty channel is fine, maybe even beneficial.  on the other hand, when the channel nears the maximum usable message rate, OT should be the first to go
12:54:30 <jkingkong> applicative: I suppose what I'm looking for is a slicing function
12:54:35 <conal> kmc: i appreciate your interest.  i got discouraged a while back, first about issues in #haskell and then about finding anyone else interested in improving things.  i no longer have a summary or list of examples at my finger-tips, but if you're really interested, i can bring them up as i see them, and we could collaborate from there.  interested?
12:54:52 <jkingkong> kmc: GHC.PArr isn't really supported I don't think
12:55:10 <jkingkong> kmc: from the recent papers, it appears they are moving toward Data.Array.Parallel.Prelude
12:55:18 <kmc> but takeP isn't there?
12:55:27 <kmc> given that DPH is pretty experimental, it doesn't seem too bad to include the GHC module at present
12:55:39 <applicative> you want a function :: [:a:] -> [[:a:] ]
12:55:47 <kmc> conal, sure, i'm interested to hear what you have to say
12:56:00 <djahandarie> I don't think things are too bad in here
12:56:00 <conal> kmc: k
12:56:13 <djahandarie> Definitely far better than any other channel I've been in with this much activity :)
12:56:28 <mreh> good to keep it that way eh/
12:56:33 <applicative> Data.Vector.	slice	:: Int -> Int -> Vector a -> Vector a
12:56:44 <jkingkong> kmc: is it safe to use both GHC.PArr and Data.Array.Parallel?
12:56:47 <monochrom> I disagree that OT in an otherwise quiet channel is fine. It is the opposite. It drives people waiting for on-topic stuff away.
12:56:47 <kmc> yeah, and i think we have a reputation for being nice, and some amount of self-congratulation about it, so i'm especially interested to know what we should do better
12:56:48 <conal> djahandarie: yeah.  way better than in other rooms i've hung out in.
12:56:48 <applicative> Data.Array.Repa.	slice	:: Array (FullShape sl) e -> sl -> Array (SliceShape sl) e
12:56:59 <jkingkong> kmc: it appears that they implement [:a:] differently
12:57:03 <mreh> conal: tell us everything
12:57:06 <kmc> jkingkong, i've no idea, sorry :/
12:57:09 <mreh> we're dying to know
12:57:13 <jkingkong> applicative: i've looked at repa
12:57:23 <jkingkong> applicative: unfortunately, i need to work on boxed types
12:57:26 <mreh> I'm dying to know :)
12:57:30 <jkingkong> kmc: haha no problem thanks anyways
12:57:42 <raichoo> Hi, can somebody explain me what this kind means? ?? -> ? -> *
12:57:51 <aavogt> :k ->
12:57:52 <lambdabot> parse error on input `->'
12:57:55 <aavogt> :k (->)
12:57:56 <kmc> raichoo, ?? means "* or #"
12:57:56 <lambdabot> ?? -> ? -> *
12:58:02 <lispy> raichoo: ?? and ? are special kinds that GHC uses for implementation purposes.  You can pretend they are *
12:58:04 <kmc> ? means "* or # or (#)"
12:58:22 <kmc> raichoo, * is ordinary types, # are unboxed types, (#) are unboxed tuples
12:58:44 <raichoo> Wow ok, that's a lot of information to look up. Thanks :)
12:58:46 <cuba> i can use filter(\x->mod x 2 == 0) where x is each element of a list but how can i change the "2" in this example an type i can supply?
12:58:49 <kmc> so Â«(->) :: ?? -> ? -> *Â» means that functions can take boxed or unboxed types, can return those or also unboxed tuples, and that functions themselves are boxed types
12:58:59 <cuba> *with
12:59:21 <kmc> raichoo, returning an unboxed tuple is basically multiple-return
12:59:32 <kmc> avoiding the overhead of allocating a normal tuple in the heap
12:59:49 <raichoo> I have to read up unboxed types first :)
13:00:13 <conal> mreh: i can mention issues as i see them and see who's receptive.
13:00:16 <kmc> as such, unboxed tuples don't really have a representation in memory -- they're just plumbing to link a multi-return function to a "case" expression which immediately receives the returned values
13:00:34 <kmc> and so there's a lot of restrictions on where you can use them
13:00:57 <Veinor> cuba: I'm not sure what you want exactly
13:01:12 <kmc> raichoo, i'd start here: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/primitives.html
13:01:25 <EvanR> are existential types going to be officially added to ghc?
13:01:29 <raichoo> kmc: Thanks I'm already there :)
13:01:32 <cuba> i want to filter every element which is an multiply of an specific int
13:01:34 <kmc> cool :)
13:01:38 <lispy> EvanR: What do you mean
13:01:44 <EvanR> its an extension now right
13:02:01 <cuba> so i want to run filter with this mod statement == 0 where mod x y is supplied by my function calls
13:02:03 <mauke> extensions are officially added to ghc
13:02:11 <EvanR> erm are existential types going to be added to haskell
13:02:30 <aavogt> they are rarely officially removed
13:02:57 <lispy> EvanR: Well, GHC can enable/disable the extension as a default pretty easily if that's what you mean
13:02:59 <kmc> EvanR, likely eventually, but there's still some legitimate disagreement about how they should work
13:03:06 <dafis> cuba: foo n = filter ((== 0) . (`mod` n)) ?
13:03:08 <EvanR> kmc: like what
13:03:11 <kmc> EvanR, UHC provides a different and arguably better construct for existentials
13:03:21 <kmc> EvanR, UHC provides a real "exists a" quantifier
13:03:30 <EvanR> ah
13:03:31 <kmc> and allows you to use existential types without declaring a new wrapping type
13:03:44 <kmc> n :: exists a. (Show a) => a; n = 3 :: Int
13:03:53 <EvanR> thats pretty tight
13:03:55 <cuba> that might work thx
13:04:02 <Saizan> ah, so now UHC supports typeclass contexts in existentials?
13:04:10 <kmc> oh Saizan's right, it doesn't
13:04:13 <illissius> newtype Zero = Zero Zero interests me
13:04:14 <raichoo> kmc: Ok I got the idea. Many thanks.
13:04:18 <benmachine> so exists a . a
13:04:21 <benmachine> surely that isn't much use
13:04:24 <kmc> n :: exists a. (a, a -> String)
13:04:28 <benmachine> ah
13:04:29 <illissius> it's a type without a runtime representation right? or not?
13:04:40 <illissius> you can make one with `fix Zero` and pattern match on it just fine
13:04:54 <kmc> illissius, yeah, the only value in that type is âŠ¥
13:05:12 <kmc> replace "newtype" with "data" and you have an infinite number of values:  âŠ¥, Zero âŠ¥, Zero (Zero âŠ¥), etc.
13:06:05 <applicative> jkingkong, which library are you using?  Just wondering...
13:06:06 <illissius> kmc: but case (fix Zero) of (Zero z1) -> do stuff works
13:06:17 <illissius> or is that not a contradiction?
13:06:46 <mauke> illissius: no, because Zero doesn't exist at runtime
13:06:47 <kmc> (fix Zero) is âŠ¥
13:07:09 <mauke> illissius: so it's really just case (fix id) of z1 -> do stuff
13:07:15 <jkingkong> applicative: Data.Array.Parallel
13:07:15 <kmc> i think  Â«case fix Zero of (Zero _) -> ()Â» should be an infinite loop
13:07:23 <jkingkong> it's in the dph libraries included with GHC
13:07:26 <kmc> no different in principle from Â«case undefined of (Zero _) -> ()Â»
13:07:32 <illissius> but it's not :)
13:07:34 <kmc> it's not?
13:07:36 <illissius> i tried
13:07:41 <mauke> HELLO
13:08:26 <kmc> oh right
13:08:33 <kmc> mauke's right
13:08:40 <kmc> matching a newtype ctor doesn't force anything
13:09:09 <kmc> but Â«fix Zero `seq` ()Â» is a loop
13:09:16 <illissius> oh. indeed
13:09:25 <kmc> and it's not with "data"
13:09:31 <illissius> yeah I tried seq and got a loop too
13:10:09 <illissius> clever hacks are clever
13:10:41 <kmc> yeah
13:11:20 <illissius> hmm
13:12:05 <taladar> Hi, I ran into a little unit tests problem: Lots of my tests need RSA keys which take a while to compute (in the IO monad probably due to FFI/true random number generator access) and I need a way to generate them once and use them in several tests, it seems there is no existing mechanism for that in HUnit or any of the other frameworks on Hackage? Am I overlooking some obvious way to do it?
13:12:36 <illissius> given the only value in 'data Zero' is bottom as well, i assume the reason edwardk's using the newtype here is to avoid needing -XEmptyDataDecls?
13:13:06 <kmc> illissius, yeah, it's a common trick to get an empty type
13:13:12 <kmc> mentioned in the RWH FFI chapter iirc
13:13:19 <deech> Hi all, I am just upgraded to the latest GHC compiler and I installing the HTTP package through Cabal gives the following error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27681#a27681
13:13:22 <kmc> i prefer EmptyDataDecls
13:13:48 <illissius> is reading RWH worthwhile for non-beginners?
13:13:50 <deech> Any help is appreciated.
13:14:01 <dons> deech: try cabal install HTTP --constraint=base-3.0.3.1
13:14:06 <kmc> illissius, i think so
13:14:23 <deech> illissius: Some chapters, yes, the database/GUI ones for examples, others no, monad transformers for example.
13:14:32 <kmc> illissius, pick chapters that look interesting
13:14:43 <illissius> not like i don't have a huge stack of other things i should read, but maybe someday
13:15:04 <kmc> you can read a chapter in one sitting
13:15:12 <deech> dons: I get the error: cabal: dependency expected.
13:15:27 <illissius> I can read whatever other interesting paper or blog post in one sitting too :) (most of the time)
13:15:30 <taladar> if you have a smartphone there are very cheap ebook versions of RWH available for Android and I think for iPhone too
13:15:41 <dafis> deech: --constraint="base == 3.0.3.1"
13:15:55 <dafis> deech: with quotes
13:16:13 <kmc> illissius, i was a non-beginner and very much liked the STM and FFI chapters
13:16:56 <illissius> alright
13:17:04 <augustss> Howdy
13:17:06 <ddarius> c_wraith: soupdragon is vixey (among many other nicks)
13:17:08 <illissius> huge stack is huger, i guess :)
13:17:23 <ddarius> augustss: Heya, haven't seen you for a while (though that may be my own issue.)
13:17:29 <deech> I now get the follow error : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27681#a27682
13:17:57 <augustss> I've not been on in a while
13:18:30 <dons> deech: oh, sorry, cabal install HTTP --constraint="base ==3.0.3.1"
13:18:33 <dons> deech: or some variant
13:19:12 <applicative> deech, you have to make up cabal install's mind for it.
13:19:42 * sm is in dependency hell too
13:21:09 <dons> i'm confused as to why you have two versions of base 3.* installed.
13:21:23 <applicative> illissius, everything in RWH is wonderful, I thought, even simple thinks I understood; the writers are dropping details and tricks and wisdom all over the place
13:21:29 <dons> oh, you only have 
13:21:32 <dons> base-3.0.3.1 
13:21:49 <deech> dons: according to my ghc-pkg list I have base-4.2.0.2 installed. 
13:22:12 <deech> When I try to set --constraint="base == 4.2.0.2" I get the original error.
13:22:31 <dafis> deech: HTTP specifies base 3
13:23:10 <dons> deech: you should have both base 3 and base 4
13:23:17 <dons> $ ghc-pkg list base
13:25:47 <deech> dons: When I try to install base-3.0.3.2 I get the error: cabal: cannot configure base-3.0.3.2. It requires base >=4.0 && <4.3
13:25:47 <deech>  
13:26:04 <deech> I am not against hosing the install and starting over if need be.
13:26:11 <dafis> deech: don't install base
13:26:27 <dafis> deech: what does ghc-pkg list base say?
13:26:50 <deech> dafis: I only have base-4.2.0.2
13:27:04 <dafis> deech: which GHC version?
13:27:09 <applicative> baffling
13:27:14 <dons> deech: don't install base.
13:27:24 <dons> deech: so you have *no* base 3?
13:27:30 <dons> deech: what version of ghc are you using??
13:27:35 <deech> dons: correct.
13:27:39 <applicative> maybe its ghc 6.17
13:27:48 <deech> I am using GHC 6.12.3
13:27:55 <dons> no, this is wrong then.
13:28:14 <dons> deech: just use the Haskell Platform release candidate perhaps.
13:28:15 <dafis> deech: I have 6.12.3 too and I have base 3.0.3.2 also
13:28:33 <dons> for ghc 6.12.3 you should have:
13:28:35 <dons> $ ghc-pkg list base
13:28:35 <dons> /home/dons/lib/ghc-6.12.3/package.conf.d base-3.0.3.2 base-4.2.0.2
13:28:42 <dons> 3.0.3.2 and 4.2.0.2
13:28:45 <dons> if you don't, your system is hosed.
13:28:50 <dafis> deech: did you build from source or have you got yourself a binary?
13:29:00 <lispy> dons: are you going to OSCON?
13:29:02 <deech> dafis: GHC from binary
13:29:05 <dons> i'd suggest installing a binary from haskell.org/ghc of 6.12.3, then installing the Haskell Platform RC.
13:29:09 <applicative> what platform are you on deech?
13:29:13 <dons> lispy: nope
13:29:15 <deech> applicative: linux
13:29:28 <deech> dons: Do I need to remove packages or just install over top of them?
13:29:49 <dons> deech: you could just install ghc over the top, then install the HP http://www.galois.com/~dons/tmp/hp/
13:30:04 <dons> i wonder how you lost your base 3
13:30:28 <dons> the binary installers for ghc 6.12.3 should be fine for linux x86/x86_64
13:32:48 <deech> Ok I'm installing Haskell platform now. I'll let you know how it goes. Thanks for the help.
13:33:57 <applicative> deech, first you must install ghc again, right?  thats what has base 3 and base 4
13:34:26 <deech> applicative: oh, ok will do.
13:34:48 <dons> get ghc 6.12.3 first, then do the HP build.
13:34:56 <applicative> the platform is the great libraries, ... eg HTTP which already gave you trouble
13:39:16 <greygjhart> hi
13:40:38 <dafis> greygjhart: ho
13:40:52 <greygjhart> Are there common technical stuffs to avoid using variables ?
13:41:12 <lispy> greygjhart: depends on what you mean by variables.  Type variables are very nice.
13:41:22 <greygjhart> I'm quite new to Haskell
13:41:22 <dafis> greygjhart: what do you mean, avoid variables?
13:41:30 <c_wraith> I'm guessing point-free form
13:41:44 * applicative guesses mutable things
13:41:51 <lispy> greygjhart: do you mean because you can't mutate the values?
13:41:55 <greygjhart> well I've understood that there are no such things as variable (mutable ones) in haskell
13:42:12 <lispy> greygjhart: Yes, there are lots of ways to avoid needing mutable state
13:42:17 <kmc> greygjhart, there are mutable variables, like IORef and MVar
13:42:19 <greygjhart> but I can't manage to think differently
13:42:24 <applicative> greygjhart, there's all kinds of mutable things
13:42:28 <greygjhart> oh yes ?
13:42:29 <kmc> greygjhart, how are you learning Haskell?
13:42:33 <greygjhart> well
13:42:37 <dafis> greygjhart: it comes with experience
13:42:44 <mauke> greygjhart: what do you need them for?
13:42:50 <greygjhart> kinda reading stuff on need
13:43:00 <deech> greygjhart: What language are you currently familiar with?
13:43:10 <greygjhart> ocaml
13:43:23 <kmc> ah, well good ocaml code tends to avoid mutation too
13:43:29 <greygjhart> and I'm beginning to use C++ often
13:43:41 <greygjhart> yeah I know
13:43:41 <deech> greygjhart: so I take it you use "ref"s a lot?
13:44:07 <greygjhart> I'm not «what's a function» or anything but
13:44:15 <greygjhart> deech : no not at all
13:44:39 <greygjhart> it's just that I'm working on sth quite imperative
13:44:40 <applicative> greygjhart, it would be easier if there were a clear example of a problem you're inclined to think needs them.  
13:44:48 <greygjhart> yeah sure
13:45:05 <greygjhart> I wanna do a soft in two parts
13:45:20 <kmc> dons, can i ask you a question about the xmonad codebase?
13:45:34 <greygjhart> it's meant to be an IRC bot AND a proxy
13:45:45 <dons> kmc: sure
13:46:02 <greygjhart> ^^ no I mean I can connect to it, and then connect to IRC and chat all
13:46:26 <greygjhart> but I can go and the bot keep on answering in my place
13:46:28 <illissius> hmm. would it be unsound to be able to use type synonyms for classes as well? `type Mappable a = Functor a` or whatever
13:46:45 <kmc> illissius, class context aliases are a much-desired feature
13:46:51 <kmc> illissius, mostly to summarize a bunch of constraints with one word
13:47:01 <illissius> hmm
13:47:16 <greygjhart> and I haven't figured yet how to "store" the servers I'm connected to
13:47:40 <deech> dafis, dons: My HP just finished building any code that uses HTTP compiles fine. Thanks!
13:47:51 <greygjhart> I can't help thinking about a mutable list to store them
13:47:58 <greygjhart> any idea ?
13:48:04 <illissius> I'm not sure that's what I'm thinking of -- it's just that classes are treated as types in a lot of ways (they're represented by TyCons internally) so I was wondering
13:48:04 <mauke> greygjhart: why not an immutable list?
13:48:10 <greygjhart> ?
13:48:17 <djahandarie> Newtype Deriving sure is nifty
13:48:21 <illissius> I think being able to use type synonyms for them would let you alias a single constraint, but not multiple
13:48:27 <greygjhart> cause at first it's connected to nothing
13:48:28 <kmc> dons, i'm toying with the idea of writing a window manager for static/manual tiling layout
13:48:47 <greygjhart> and I want it to be able to join other IRC servers on the go
13:48:53 <applicative> greygjhart, presumably it will be an IO [ ...] in any case 
13:49:15 <dafis> greygjhart: StateT serverlist IO
13:49:23 <kmc> dons, and i'm wondering whether i should write this as a patch / extension to xmonad, or just use xmonad code as an example and start from scratch
13:49:27 <greygjhart> right, there's already a whole bunch of them in what I wrote so far
13:49:42 <greygjhart> dafis : what was that again ?
13:49:52 <lispy> kmc: I bet you could do that as an xmonad plugin
13:50:08 <dafis> greygjhart: a monad transformer, a state monad wrapped around IO
13:50:09 <lispy> kmc: As in, sounds good I bet you don't have to start from scratch unless you want to
13:50:21 <greygjhart> alright
13:50:41 <greygjhart> that's when I start to read about them, no ?
13:51:25 <dafis> greygjhart: might indeed be a good time to start reading about monad transformers
13:51:41 <dons> kmc: well, you could do like bluetile, and use xmonad-core as a library
13:51:45 <greygjhart> ok
13:52:01 <dafis> greygjhart: but to use them, you don't need to completely understand them :)
13:52:18 <greygjhart> There's so much to discover, I don't quite know where to read next sometimes
13:52:22 <greygjhart> so thanks a lot
13:53:08 <greygjhart> I'll read this (understand the more I can) and come back when I really can't deal with the rest : )
13:53:19 <greygjhart> thx again
13:53:52 <djahandarie> if I'm doing     newtype X a = X (ReaderT Y IO a) deriving (MonadReader Y)    , I should be able to use runReaderT and mapReaderT, right?
13:53:57 <greygjhart> bye
13:54:21 <aavogt> kmc: you could fix this up: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11526
13:54:21 <dafis> djahandarie: I don't think so
13:54:46 <kmc> djahandarie, no, those aren't generalized to all MonadReader
13:54:53 <kmc> djahandarie, but you can unwrap it of course
13:55:02 <djahandarie> Ah right
13:56:09 <kmc> aavogt, cool.  did you find fitting manual layout into xmonad to be awkward?
13:56:14 <djahandarie> What do you mean by unwrap it?
13:56:33 <kmc> djahandarie, that the value inside the X constructor can be passed to runReaderT
13:56:41 <dafis> djahandarie, unX :: X a -> ReaderT Y IO a
13:56:59 <djahandarie> Ah. That's kind of annoying though
13:56:59 <kmc> newtype X a = X { unX :: ReaderT Y IO a }
13:57:04 <dafis> djahandarie: then runReaderT . unX
13:57:21 <djahandarie> Isn't there some way I can just work with X directly?
13:57:35 <kmc> djahandarie, you ask for a new type, you get a new type ;)
13:57:41 <djahandarie> :(
13:57:59 <kmc> you could make it a synonym instead
13:58:15 <djahandarie> I was just taking xmonad's lead and using a newtype
13:58:23 <djahandarie> It was a synonym before
13:58:31 <kmc> you can define your own runX
13:59:57 <illissius> monad transformers question(s): is the reason you might want to use ReaderT/WriterT in addition to StateT, even though they're 'redundant', so that you can put different things in different places, or just so some code can be restricted to Reader/Writer? would you ever want to use multiple ReaderT or WriterT? how would you do that, if so? (lift . lift . ask everywhere?)
14:00:35 <kmc> illissius, http://tomschrijvers.blogspot.com/2010/03/bruno-oliveira-and-i-are-working-on.html
14:01:36 <illissius> kmc: yet more stuff to read! :) thanks
14:01:55 <djahandarie> That looks nifty kmc
14:02:22 <applicative> illisius, what are you doing, that you're piling up monad transformers?  just wondering...?
14:02:37 <illissius> applicative: nothing. it's a theoretical question
14:02:44 <applicative> illisius, i see
14:04:34 <illissius> I haven't used monad transformers before, just want to understand them better (obviously using them would be one way, but I don't have the "this is a problem I could use monad transformers to solve" intuition in a sufficient way yet)
14:05:21 <c_wraith> One thing I've found is that it's relatively common to combine sets of transformers in newtype wrappers, and sometimes you might end up nesting the same transformer multiple times that way.
14:05:27 <b0fh_ua> Hello! I am trying to insert several rows from a file with UTF-8 content, into the database (MySQL), which is also has UTF-8 type for mediumtext field. However for some reason encoding is broken
14:05:40 <kmc> i like to build a transformer stack, newtype it, and expose only a few domain-specific actions
14:06:02 <b0fh_ua> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27684#a27684
14:06:08 <c_wraith> kmc: exactly.  I sometimes combine stacks of transformers only into a single domain-specific transformer the same way.
14:07:56 <aavogt> kmc: you need to decide how to synchronize changes made to layout-specific state and xmonad's state
14:07:59 <c_wraith> Recently I added a transformer for validating input that's a combination of StateT (list of errors) and MaybeT (fail fast on input that's so broken validation can't continue).
14:08:32 <edwardk> illissius: yes, that was the only reason
14:08:32 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
14:09:17 <illissius> edwardk: k :)
14:09:18 <edwardk> @tell ivanm the generator/reducer stuff is largely based on the notions expressed by jan-willem maessen and guy steele for fortress
14:09:18 <lambdabot> Consider it noted.
14:09:23 <kmc> dons, i guess my complimentary question is: if i start from scratch using the Xlib bindings, how much X-related bs is there?
14:09:35 <edwardk> illissius: i tend to prefer emptydatadecls though
14:09:40 <c_wraith> (It's a transformer because sometimes you might want to use actions from an underlying monad in your validation process)
14:09:52 <edwardk> illissius: the 'Unused' class was needed to shut up the compiler about the fact that I never used the constructors ;)
14:09:57 <kmc> the xmonad core code is pretty small, but there's definitely a lot i don't immediately understand reading it
14:10:32 <illissius> edwardk: yeah I remembered that much
14:10:59 <dons> kmc: about 500 lines
14:11:10 <dons> kmc: i wouldn't start from scratch. X11 is a pain
14:11:13 <aavogt> kmc: so I guess you need to keep a copy of xmonad's focus-related state, to see what got changed to make the difference between layout state and the core's state
14:11:13 <applicative> b0fh_ua, what's the problem you are running into with it?
14:11:49 <illissius> edwardk: why Stable (s (Stable s a)) rather than just Stable (Stable s a)? it'd complain you don't use the s?
14:11:58 <b0fh_ua> applicative: looks like the data (strings) are encoded in UTF8 twice
14:12:02 <illissius> oh never mind, to make it clear it's a * -> *
14:12:31 <kmc> dons, s'pose i'm a masochist, what do i start reading? xlib manual and icccm?
14:12:39 <dafis> b0fh_ua: then feed it raw unencoded ByteStrings?
14:12:40 <kmc> to start from scratch i mean
14:13:04 <b0fh_ua> dafis: well, I don't do any encoding
14:13:33 <dafis> b0fh_ua: you use BStr.fromString
14:13:49 <b0fh_ua> but the content is utf8.
14:13:55 <b0fh_ua> okay, I'll try it now
14:13:56 <aavogt> dons: 3x that:
14:13:58 <aavogt> cat *.hs XMonad/*.{hsc,hs} | runghc tests/loc.hs
14:14:00 <aavogt> 1437
14:14:01 <applicative>  b0fh_ua, curses, cant test it - I cant install the mysql package   you use   BStr.lines . BStr.fromString 
14:14:56 <b0fh_ua> dafis: oh, there's no way to split on lines
14:15:17 <dafis> b0fh_ua: Data.ByteString.split 10 ?
14:15:31 <mauke> :t Data.ByteString.Char8.lines
14:15:32 <lambdabot> BSC.ByteString -> [BSC.ByteString]
14:16:03 <b0fh_ua> hm
14:16:42 <b0fh_ua> mauke: but there is utf-8 input
14:16:46 <b0fh_ua> not 8-bit one
14:16:49 <mauke> so?
14:17:02 <edwardk> illisius: checking. (its been a while) =)
14:17:14 <b0fh_ua> mauke: I tried that, and on utf-8 file it complained about wrong char sequence
14:17:30 <mauke> I don't believe that
14:17:32 <dafis> b0fh_ua: what complained?
14:19:09 <illissius> edwardk: pretty sure that's the reason -- this time to avoid KindSignatures :)
14:19:15 <b0fh_ua> let me double-check that
14:19:48 <applicative> should be using a getContents appropriate to the bytestring-utf8 module?
14:19:53 <edwardk> illissius: hah possibly. the s there is a (Store s) there no?
14:20:28 <edwardk> because it builds a stableptr and then stores it
14:21:29 <illissius> edwardk: not sure... i'm trying to make my way through that last part this very moment :)
14:21:30 <edwardk> i did go a bit overboard trying to avoid extensions in there
14:22:07 <applicative> b0fh_ua, I meant, maybe you should be importing System.IO.UTF8.getContents
14:22:59 <b0fh_ua> mauke: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27684#a27687
14:23:21 <edwardk> illissius: yeah it is. check the code for pointer, which makes basically retags with Stable
14:23:26 <b0fh_ua> this way I am getting same results - the content is broken, looks like it is double-encoded somewhere
14:24:55 <sm> why is cabal sdist telling me Could not find Paths_hledger with any suffix ?
14:25:29 <edwardk> sm: is that placed in the exposed modules by accident?
14:25:46 <Saizan> or other-modules even
14:25:53 <edwardk> yeah that too
14:26:17 <sm> ack, I thought I fixed that but there's another. good call, thank you
14:29:03 <dafis> b0fh_ua: http://hackage.haskell.org/packages/archive/HDBC/2.2.6/doc/html/Database-HDBC.html#t%3ASqlValue, section Unicode and ByteStrings
14:29:28 <dafis> that might be pertinent
14:31:28 * hackagebot hledger-lib 0.11 - Core types and utilities for working with hledger (or c++ ledger) data.  http://hackage.haskell.org/package/hledger-lib-0.11 (SimonMichael)
14:31:30 * hackagebot hledger 0.11 - A command-line (or curses or web-based) double-entry accounting tool.  http://hackage.haskell.org/package/hledger-0.11 (SimonMichael)
14:37:31 * hackagebot haskell-platform-test 2010.2.0.0 - A test system for the Haskell Platform environment  http://hackage.haskell.org/package/haskell-platform-test-2010.2.0.0 (DonaldStewart)
14:38:07 <djahandarie> dons, what does that do?
14:38:47 <sohum> is there any way to do polymorphic dispatch at runtime with a TypeRef? say, with a Data.Dynamic?
14:39:06 <sohum> (also, what exactly does Data.Dynamic buy you relative to a tuple?)
14:39:16 <kmc_> sohum, tuple? how is it like a tuple?
14:39:55 <dons> sohum: they're not comparable
14:39:55 <kmc_> sohum, "polymorphic dispatch at runtime" probably means you want to create a type class and/or an existential type wrapping that class
14:40:02 <kmc_> but it's often the long way around
14:40:10 <kmc_> just store the thing you would dispatch in the value you're dispatching
14:40:32 <kmc_> you don't need to define a new type to define new behaviors.  behaviors are functions or actions, they're first-class values
14:41:58 <sohum> kmc: well, in the sense that I haven't really figured out what I can do with it that's different from running fromDyn and typeRepOf on it
14:42:36 <sohum> kmc: we tried a typeclass. It still annoyed the typechecker with "ambiguous type variable".
14:42:56 <kmc> sohum, you can fix that probably
14:44:01 <b0fh_ua> dafis, applicative : solved. the problem was with MySQL server, it set the connection options for client with latin1 as a charset, so issuing "set names 'utf8'" fixed the issue.
14:44:05 <kmc> sohum, i still don't understand your question about Dynamic
14:44:32 <applicative> b0fh_ua, oh excellent. 
14:45:00 <sohum> kmc: I can't figure out a way to do anything with it that I couldn't do with a (Typeable a) => (a, TypeRef). and there has to be, right?
14:46:43 <kmc> sohum, Dynamic is close to Â«exists a. (Typeable a) => (a, TypeRef)Â» yes
14:46:58 <dafis> sohum: you can't have [toDyn True, toDyn 'o'] with such a tuple
14:47:19 <kmc> in GHC, Â«data Dynamic = forall a. (Typeable a) => Dynamic a TypeRefÂ»
14:47:24 <kmc> except that's not how it's actually implemented
14:47:28 <kmc> i think to avoid the ExistentialTypes extension
14:47:33 <dafis> you'd have to use (GHC.Any, TypeRep)
14:47:53 <kmc> sohum, perhaps you'd like to read the source to Data.Dynamic.  it's not long
14:47:59 <BaD_BoY> hello
14:48:04 <sohum> kmc: fair enough
14:48:04 <BaD_BoY> my name
14:48:07 <BaD_BoY> is ilia
14:48:09 <sohum> dafis: ah, yea, that makes sense
14:48:13 <BaD_BoY> ai em from albania
14:48:22 <BaD_BoY> speak like
14:48:40 <kmc> anyway, the existential aspect of Dynamic is important.  it hides the type until runtime.  an ordinary tuple won't do that
14:49:11 <sohum> kmc: I can't see a way to /use/ the type at runtime, though
14:49:22 <kmc> sohum, what do you mean?
14:49:48 <sohum> > let d = toDyn (4 :: Int)
14:49:50 <lambdabot>   not an expression: `let d = toDyn (4 :: Int)'
14:49:57 <kmc> you can get the TypeRep with dynTypeRep, or you can try a cast with fromDynamic
14:50:02 <sohum> @let d = toDyn (4 :: Int)
14:50:03 <lambdabot>  Defined.
14:50:12 <kmc> :t d
14:50:13 <lambdabot>     Ambiguous occurrence `d'
14:50:13 <lambdabot>     It could refer to either `L.d', defined at <local>:4:0
14:50:13 <lambdabot>                           or `SimpleReflect.d', imported from SimpleReflect at State/L.hs:73:0-32
14:50:23 <sohum> :t L.d
14:50:25 <lambdabot> Dynamic
14:50:31 <kmc> > fromDynamic L.d :: Maybe Char
14:50:32 <lambdabot>   Nothing
14:50:34 <mauke> @undefine
14:50:34 <kmc> > fromDynamic L.d :: Maybe Int
14:50:35 <lambdabot>   Not in scope: `L.d'
14:50:40 <kmc> ;P mauke
14:50:53 <kmc> > let d = toDyn (4 :: Int) in fromDynamic d :: Maybe Char
14:50:54 <lambdabot>   Nothing
14:50:54 <kmc> > let d = toDyn (4 :: Int) in fromDynamic d :: Maybe Int
14:50:55 <lambdabot>   Just 4
14:51:45 <sohum> > let d = toDyn (4 :: Int) in (+1) (fromDynamic d :: (Num a) => Maybe a)
14:51:46 <lambdabot>   Could not deduce (Data.Typeable.Typeable a)
14:51:46 <lambdabot>    from the context (GHC.Num.Nu...
14:51:58 <sohum> > let d = toDyn (4 :: Int) in (+1) (fromDynamic d :: (Num a, Typeable a) => Maybe a)
14:52:00 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
14:52:00 <lambdabot>    arising from a use of...
14:52:33 <dafis> > let d = toDyn (4 :: Int) in fmap (+1) (fromDynamic d :: (Num a, Typeable a) => Maybe a)
14:52:34 <lambdabot>   Nothing
14:53:00 <dafis> > let d = toDyn (4 :: Int) in fmap (+1) (fromDynamic d :: Maybe Int)
14:53:01 <lambdabot>   Just 5
14:53:47 <sohum> there's no way to not introduce the static information that it's an Int
14:53:56 <dafis> > let d = toDyn (4 :: Int) in fmap (+1) (fromDynamic d :: (Num a, Typeable a) => Maybe a) :: Maybe Int
14:53:57 <lambdabot>   Just 5
14:54:08 <kmc> sohum, what do you mean?
14:54:28 <kmc> sohum, when you create a Dynamic value, you have to know the static type of what you're putting in
14:54:47 <kmc> this much is true
14:55:00 <sohum> kmc: when you create it, sure. But you also need to know it where you use it, because you have to cast it to Maybe Int
14:55:13 <kmc> sohum, you don't have to know statically that the cast will succeed
14:55:18 <kmc> that's the point
14:55:24 <kmc> you can try several casts, and take the one which works
14:55:41 <kmc> or you can get the TypeRep and use it to choose a cast dynamically
14:56:09 <sohum> kmc: the latter sounds like what I'm looking for. would you mind giving a quick example?
14:56:36 <kmc> sohum, sure, but i'd also like to know what you're actually doing
14:56:43 <kmc> is there a reason a simple sum type won't suffice?
14:57:02 <sohum> kmc: trying to patch hubris to use polymorphic Haskell functions
14:57:32 <kmc> does Hubris not already have a type representing a ruby value of dynamic type?
14:57:42 <kmc> something like Â«data Value = VInt Int | VChar Char | ..Â»
14:58:11 <kmc> this is much more convenient than real dynamic typing
14:58:33 <sohum> kmc: it could be constructed, sure. But that feels computationally infeasible and not truly generic.
14:58:55 <kmc> sohum, it's typically the way you write an interpreter for or interface to a dynamically-typed language
14:59:04 <kmc> but if Hubris is already using Typeable instead, maybe that's better
14:59:39 <kmc> Typeable and Dynamic are mostly useful when the set of types you're dealing with is open
14:59:54 <kmc> i.e. other Haskell code outside your library can invent new types that your library has to be able to deal with
15:00:04 <sohum> that's basically the idea, yea
15:00:24 <kmc> ok
15:00:45 <kmc> well unfortunately TypeRep doesn't have an Ord instance, so you couldn't use it as a Data.Map key
15:01:14 <Saizan> there's a way around that, but it's a bit dodgy
15:01:28 <kmc> Saizan, involving an orphan Ord instance and unsafePerformIO?
15:01:35 <Saizan> yes
15:01:49 <aristid> wouldn't a newtype be nicer?
15:01:55 <kmc> newtype of what?
15:02:01 <aristid> of the TypeRep
15:02:01 <kmc> oh nicer than orphans? yeah
15:02:07 <kmc> but doesn't solve the other issue
15:02:16 <aristid> huh?
15:02:29 <kmc> typeRepKey :: TypeRep -> IO Int
15:02:55 <kmc> imo for a somewhat superfluous reason
15:02:58 <kmc> typeRepKey (TypeRep (Key i) _ _) = return i
15:03:13 <kmc> but the argument is that the key could change from run to run of the program
15:03:30 <kmc> but it's not going to change during a run
15:03:33 * ddarius remembers when Dynamic and plugins was new and there were issues with the interning dictionaries becoming incoherent particularly with plugins.
15:03:52 <kmc> i think this is a higher standard of purity than usual
15:03:54 <dons> due to static and dynamic linking of libs
15:04:00 <Saizan> yeah, i wonder what happens with the ghc-api
15:04:03 <kmc> yeah, that sounds like a huge can of worms
15:05:16 <monochrom> w00t Dynamic
15:06:15 <sohum> I'd need > let d = toDyn (4 :: Int) in ( (+1) :: (Num a => a -> a) ) $ someFunctionOf d < to actually compile and work, essentially. but since someFunctionOf :: Dynamic -> Int and :: Dynamic -> Char ... at /compile time/ to be appropriately generic and to appropriately satisfy the polymirphic dispatch on (+1), I don't know if it's at all possible to get around tht
15:07:18 <kmc> sohum, maybe the type you want isn't Dynamic, but Â«data SomeNum = forall a. (Num a) => SomeNum aÂ»
15:07:41 * hackagebot hledger-lib 0.11.1 - Core types and utilities for working with hledger (or c++ ledger) data.  http://hackage.haskell.org/package/hledger-lib-0.11.1 (SimonMichael)
15:07:43 * hackagebot hledger 0.11.1 - A command-line (or curses or web-based) double-entry accounting tool.  http://hackage.haskell.org/package/hledger-0.11.1 (SimonMichael)
15:08:39 <sohum> kmc: that wou;dn't work for non-Nums, though. Not everything is or should be an instance of Num?
15:08:46 <sohum> *-?
15:08:56 <kmc> sohum, well how are you going to apply (+1) to it if it's not Num?
15:09:48 <sohum> kmc: we know if it's Num or not at runtime, not compile time
15:09:58 <kmc> how's your above example supposed to work then?
15:10:05 <kmc> Â«( (+1) :: (Num a => a -> a) ) $ someFunctionOf dÂ»
15:10:15 <kmc> what happens if someFunctonOf observes that d's dynamic type is not in Num?
15:10:30 <sohum> runtime error would be fine
15:11:36 <kmc> so you said it's an important aspect of this project that Haskell code using your library be able to define new types and use it?
15:12:14 * monochrom has a sinister idea for this. combine Dynamic with existential. data SomeNum = forall a. (Num a) => SomeNum a; let d = toDyn (SomeNum (4 :: Int))
15:13:10 <monochrom> someFunctionOf :: Dynamic -> Maybe SomeNum; someFunctionOf = fromDynamic
15:13:17 <ddarius> monochrom: But you'll still have to check specifically for SomeNum at which point you are heading more and more toward just using a sum-type to begin with, which, in my opinion, is actually, the correct solution usually.
15:13:25 <kmc> sohum, i don't think you'll get anywhere if you let the user pass in absolutely any Haskell type whatsoever
15:13:33 <applicative> monochrom, No instance for (Typeable SomeNum) ...
15:14:03 <alpha> If I have a list and would take module 8 on all the elements in it, how would I do? map (mod 8) [...] does not work since it would take mod 8 element when I in fact want mod element 8
15:14:05 <ddarius> monochrom: That's similar but less convenient than a solution I suggested earlier for a different problem.
15:14:07 <kmc> sohum, i think you need to define a class for usable types, and require that they implement certain stuff
15:14:12 <monochrom> oh oops. {-# LANGUAGE DeriveDataTypeable #-} ... deriving Typeable...
15:14:25 <dafis> alpha: map (`mod` 8)
15:14:53 <kmc> sohum, and then instead of Dynamic, use an existential over that class
15:15:02 <applicative> > 18 `mod` 8
15:15:03 <lambdabot>   2
15:15:04 <kmc> (or skip the class and use an existential over an explicit dictionary of methods)
15:15:24 <alpha> dafis thanks. There should be some sort of reverse function that should be able to do this too. Do you know what function I am talking about? It does reverse the arguments or something
15:15:36 <dafis> alpha: flip
15:15:40 <dafis> :t flip
15:15:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:15:47 <kmc> :t Prelude.flip
15:15:48 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:15:48 <applicative> > flip mod 8 18
15:15:49 <lambdabot>   2
15:15:56 <alpha> dafis, thanks. I had forgotten its name :)
15:16:07 * dafis always forgets about Caleskell
15:16:36 <monochrom> In any case "Num a => a->a" is likely to cause more trouble because it would try to let an existential type escape.
15:16:43 * applicative is trying to grasp Caleskell flip
15:17:18 <dafis> applicative: instance Functor (a ->)
15:17:25 <benmachine> applicative: I don't think anyone's quite sure how it's better than ordinary flip
15:17:25 <monochrom> i.e., it is not like you can do "case blah of SomeNum n -> (f::Num a => a->a) n"
15:17:32 <applicative> i see that, but the signature looks like other memorable things
15:17:38 <benmachine> that is to say, it's not often that you want to use a Functor that isn't ((->) r)
15:17:59 <benmachine> it looks a bit like ap?
15:18:02 <applicative> benmachine, yeah other functors are silly, this is a functional language
15:18:03 <alpha> What is caleskell? I am not able to find a good page at google that explains what the word means
15:18:04 <applicative> :t ap
15:18:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:18:18 <applicative> its ap with return
15:18:31 <benmachine> or <*> with pure
15:18:40 <benmachine> sort of
15:18:44 <dafis> alpha: Caleskell is the nickname for the extensions built into lambdabot
15:18:50 <benmachine> for a sufficiently vague definition of "with"
15:18:53 <applicative> it's flip <$>
15:19:01 <kmc> Cale doesn't like the name though ;P
15:19:04 <applicative> no, idiotic
15:19:08 <benmachine> yeah it's not an official name
15:19:34 <applicative> kmc, well then he shouldn't mess with our types!  except its so interesting.
15:19:52 <Silvah> :t flip (join .) . fmap
15:19:52 <lambdabot> forall (m :: * -> *) a a1 b (f :: * -> *). (Monad m, Functor f) => (a1 -> b) -> ((f a1 -> f b) -> m (m a)) -> m a
15:19:53 <dafis> applicative: right
15:21:39 <applicative> alpha, some of the standard prelude functions are given more general types, which is frequently surprising.  
15:22:01 <applicative> :t (.) -- a typical example, of a piece with flip above
15:22:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:22:03 <Silvah> :t (join .) . flip fmap
15:22:04 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
15:22:24 <Silvah> ^^
15:22:26 <benmachine> :t (++)
15:22:27 <lambdabot> forall m. (Monoid m) => m -> m -> m
15:22:35 <applicative> alpha, so we see the function-composition is fmap for a suitable functor
15:22:48 <benmachine> @check take 3 ++ drop 3 == id
15:22:49 <lambdabot>   Couldn't match expected type `[a]'
15:22:57 <benmachine> @check take 3 ++ drop 3 == id :: [Int] -> [Int]
15:22:58 <lambdabot>   Couldn't match expected type `[a]'
15:23:07 * benmachine gives up
15:23:58 <sohum> kmc: so either way, we have to drop the idea of being generic with regard to Haskell types, right?
15:24:26 <ddarius> monochrom: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27234
15:24:47 <applicative> sohum, I was looking for actual uses of Data.Dynamic, and inevitable Pugs seems to be a major importer.  
15:24:53 <applicative> inevitably
15:26:18 <kmc> sohum, depends what you mean by generic?
15:27:03 <ddarius> The only time I can think of when Dynamic makes some sense is if you are just blindly holding the value for multiple independent "third-parties" and you only give it back.  Even then, there are usually much better ways than using Dynamic to handle that situation.
15:27:09 <Axman6> sohum! breakfast!
15:27:32 <kmc> sohum, users can define new types and use them with your code, they just need to specify a few things when they do so
15:27:39 <sohum> kmc: well, a future goal was to allow the user to specify ruby types and their conversion to haskell types and vice versa. a dictionary, by definition, would only enable that for functions we've thought about
15:27:41 <kmc> such as, whether their type is numeric, and if so what the numeric operations are
15:27:57 <kmc> sohum, sorry, i meant something different by "dictionary" than what's meant in Ruby or Python
15:28:14 <kmc> for example the dictionary for the Eq typeclass is
15:28:17 <sohum> Axman6: yea, hold onto your britches. I'll be a few minutes late.
15:28:27 <kmc> data EqD a = EqD { eq :: a -> a -> Bool, neq :: a -> a -> Bool }
15:28:45 <kmc> type classes are largely just sugar for passing values like this
15:29:01 <sohum> Axman6: (where "few" \in \{-1,0,...11\})
15:29:37 <Silvah> > "just testing"
15:29:37 <Silvah> lambdabot?
15:29:38 <lambdabot>   "just testing"
15:29:42 <Silvah> lambdabot died once again.
15:29:49 <Silvah> er
15:29:49 <kmc> @bot
15:29:49 <lambdabot> :)
15:29:57 <Silvah> Nevermind.
15:30:06 <kmc> sohum, so this approach is still open; the user can build a dictionary of operations
15:30:09 <kmc> i was imagining something like
15:30:27 <kmc> class Foo a where { getNum :: a -> Maybe NumD; ... }
15:30:35 <kmc> and then your type is an existential over Foo
15:30:43 <kmc> it's a little ornate though; there might be a better way
15:30:45 <lambdabot> The report of my death was an exaggeration.
15:31:34 <ddarius> kmc: The approach in the paste I gave to monochrom allows one to reuse the Num instances though it could be straight-forwardly adapted to explicit dictionaries.
15:31:42 <kmc> oh i missed the paste
15:31:57 <kmc> ddarius, found it
15:31:59 <kmc> looks good
15:32:01 <Silvah> > (join .) . flip fmap $ (Just 2) (return . (+3))
15:32:02 <lambdabot>   Couldn't match expected type `t -> m a'
15:32:02 <lambdabot>         against inferred type `Data...
15:32:11 <ddarius> (Indeed, the point and most of the complication in the code is to support reusing the Num instances.  It would be quite straightforward using explicit dictionaries.)
15:32:29 <kmc> sohum, did you see ddarius's paste? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27234
15:32:39 <sohum> kmc: poking through it now
15:33:27 <aristid> :t (0 : 1 :)
15:33:28 <lambdabot>     The operator `:' [infixr 5] of a section
15:33:28 <lambdabot>         must have lower precedence than that of the operand,
15:33:28 <lambdabot>           namely `:' [infixr 5]
15:34:03 <kmc> hmm, if you want you could put the "supportsNum _ = Nothing" as a default in Supports
15:34:20 <aristid> the precedence restriction seems a bit unnecessary
15:34:26 <kmc> oh and also i don't think you need the arg, because it's not inspected and the type appears in the result
15:35:04 <Silvah> These witches from Tar Valon have made all my code not compiling. 
15:35:09 <dafis> aristid: should (0 : 1 :) be ((0:) . (1:)) or ((0:1):) ?
15:35:15 <ddarius> kmc: You don't -need- it but the consider what the type of foo would be.
15:35:30 <aristid> dafis: the first
15:35:44 <kmc> ddarius, hmm yeah.  perhaps Â«Tagged a StringÂ»
15:35:45 <sohum> ddarius: this forces foo to have to be polymorphic, right?
15:35:55 <dafis> aristid: but when I have instance Num [Int] where... ?
15:36:00 <dibblego> Question: http://paste.pocoo.org/show/238872/
15:36:05 <ddarius> Also, not demonstrated in that paste, but intended is that there would be multiple supportsFoo methods for different classes.
15:36:34 <ddarius> sohum: If foo wasn't polymorphic, you wouldn't need this.
15:36:36 <kmc> yes
15:36:40 <aristid> dafis: isn't (:) right-associative?
15:37:17 <Silvah> ...and apparently they broke my English as well.
15:37:33 <kmc> ddarius, wait, why would dropping the unused arg to supportsNum change the type of foo?
15:37:42 <kmc> you still use the value a.  you'd just say "case supportsNum of"
15:37:47 <sohum> ddarius: the issue is that we'd want foo to be /anything/ specifiable by the user, so it could be mono or poly morphic. Forcing polymorphism might end up being the way to go...
15:37:50 <Silvah> </rant>
15:37:57 <sm> would anyone know offhand how to get cabal install to produce static binaries on linux ?
15:38:08 <ddarius> kmc: It doesn't have to, but the natural thing then would be to drop the first argument.  Leaving it, you'll need LexicallyScopedTypeVars or some asTypeOf fu.
15:38:24 <kmc> well you can't drop the first argument, it's used
15:38:31 <lispy> sm: Doesn't cabal have a configure flag for it?
15:38:32 <kmc> it's passed to show and such
15:39:52 <sohum> anyway, thanks guys, but I've got to head off to breakfast. I'll pop back in when I'm at the Hascathon
15:39:56 <ddarius> kmc: At any rate, it isn't necessary as I said.  I was working things out as I went along and I was just trying to get some code out there.
15:39:59 <lispy> sm: interesting.  I just checked and I couldn't find it, but I swear it had it at some point
15:40:12 <ddarius> I believe at times I had supportsNum returning types with no type parameter.
15:40:58 * sm nods
15:42:37 <dafis> aristid: Yes. So it could be resolved when all operators in a section have the same associativity.
15:42:41 <sm> jeez.. why is each attempt to cabal install gtk2hs-buildtools re-installing random, haskell98 etc. when these are already installed
15:43:18 <aristid> dafis: hmm
15:43:22 <aristid> > fix $ ([0,1] ++) . (zipWith (+) <*> tail)
15:43:23 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:43:27 * sm decides to forget about gtk support for today
15:43:51 <aristid> dafis: i wanted to do this with (0 : 1 :) first
15:44:41 <dafis> aristid: yeah, looks nicer than ((0:) . (1:))
15:45:13 <dafis> or (\xs -> 0 : 1: xs)
15:45:58 <dafis> aristid: but I guess it could be complicated to parse
15:46:22 --- mode: ChanServ set +o mauke
15:46:22 --- mode: mauke set -b *!*@unaffiliated/fax
15:46:34 <aristid> dafis: yeah quite imaginable
15:48:22 --- mode: mauke set -o mauke
15:57:35 <applicative> dibblego, I see, this is hard.  I cant think of a way that'd make sense of x and y, I can't extract the monad from the G m expressions...
16:08:28 <illissius> hooray, /me understands Data.Reflection! i is so smarts! :<
16:10:52 <aristid> illissius: i think i also almost understand it \o/
16:12:20 <illissius> aristid: the usage or the implementation? :D
16:12:34 <illissius> the latter is still somewhat hazy but after staring at it for hours i think i mostly get it
16:13:49 <aristid> illissius: well the implementation... for some stretched definition of almost
16:14:23 <illissius> yeah we're probably somewhere around the same place then
16:14:46 <Veinor> wow, has parsec really not been touched since 2001?
16:14:49 <illissius> all this make-the-type-inferencer-inference-the-types-we-want stuff makes you think backwards
16:15:10 <dafis> Veinor: parsec 3 is new
16:15:11 <Veinor> ... oh, it's been updated-ish.
16:15:19 <Veinor> why does the official documentation say copyright 2001? :/
16:15:44 <Saizan> because the documentation hasn't been touched since then :)
16:15:45 <dafis> Veinor: that's when it was originally written?
16:15:52 <Veinor> fair enough :P
16:16:16 <Saizan> if you refer to this one http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
16:16:22 <Veinor> yeah, that one.
16:17:19 <Veinor> then again I guess there's no reason to touch what isn't broken :)
16:18:07 <dons> Veinor: http://hackage.haskell.org/package/parsec-2.1.0.1
16:18:22 <Saizan> it doesn't cover the Stream and transformer generalization in parsec-3 though
16:18:30 * Veinor shrugs
16:18:38 <Veinor> maybe someone should update it then
16:18:54 <Veinor> :P
16:20:01 <Veinor> anyway, I assume the old parsec 2 documentation is still valid
16:20:04 <Veinor> for 2.1.0.1?
16:20:12 <dons> yup
16:20:34 <dibblego> applicative, precisely my problem! I am thinking of wrapping T in (m T) then defining the function once for T, then on a type-class for both T' m and G m
16:21:12 <colin_> Can someone help me out with a simple class compile issue?  I've been reading up on classes but I can't figure out why this won't work...
16:21:15 <colin_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27694#a27694
16:21:50 <kmc> colin_, because the signature for magnitude says it will turn the type a into any other type b
16:21:55 <kmc> perhaps you want a -> a
16:22:11 <colin_> But it is Vector2 a -> a
16:22:23 <kmc> but the class says magnitude :: (Floating b) => a -> b
16:22:27 <dafis> colin_, or a multi-parameter type class
16:22:35 <kmc> so it's valid for me to call that at type (Vector2 Rational) -> Double
16:23:04 <kmc> err not Rational because it's not in floating
16:23:08 <kmc> Vector2 Float -> Double
16:23:31 <colin_> hmmm
16:25:06 <kmc> you probably want the class to require that the output type is the same as the input type
16:25:38 <colin_> well... I want to require the output type the same as the parameter type for the Vector2
16:25:47 <kmc> oh right
16:26:03 <colin_> I don't understand how to express that
16:26:19 <kmc> class Magnitude v where magnitude :: (Floating a) => v a -> a
16:26:25 <kmc> instance Magnitude Vector2 where ...
16:26:58 <kmc> there are other, more flexible, more complicated ways
16:27:07 <colin_> oh... I see...
16:28:04 <colin_> That still isn't working....
16:28:16 <colin_> with the same definition for the instance that I have
16:29:41 <dafis> colin_: instance (Floating a) => Magnitude Vector2 where ...
16:30:31 <dafis> gah, without the (Floating a) => of course
16:31:17 <illissius> aristid: do you think it's possible to define withMonoid using a reader monad instead of reify/reflect? i tried but failed on mappend
16:31:31 <colin_> ok.... that works but let me see if I can understand why...
16:32:16 <aristid> :t withMonoid
16:32:17 <lambdabot> Not in scope: `withMonoid'
16:32:30 <colin_> Thanks for the help guys
16:32:36 <illissius> aristid: http://comonad.com/reader/2009/clearer-reflection/
16:33:16 <illissius> (you can also do that example there somewhat simpler with Tagged directly rather than making a separate M wrapper)
16:34:14 <jmcarthur> woah. why is it valid for a module to export itself? :P
16:34:36 <jmcarthur> i accidentally did that and it worked
16:34:50 <illissius> jmcarthur: same thing as if you don't define an export list
16:34:50 <kmc> jmcarthur, to get the default behavior from no export list (everything exported) and also reexport some other modules (which is never done by default)
16:34:58 <aristid> illissius: replace reflect with ask and it should work, i think
16:34:59 <illissius> except you get to export other things in addition
16:35:09 <kmc> module Foo(module Foo, module Bar) where { import Bar; ... }
16:35:12 <jmcarthur> kmc: it reexports other modules when you do that?
16:35:32 <jmcarthur> oh wait
16:35:34 <jmcarthur> oh i see now
16:35:34 <kmc> my example above exports everything in Foo plus whatever's exported by Bar
16:36:00 <jmcarthur> interesting
16:37:17 <aristid> illissius: and Reader instead of Tagged
16:37:28 <aristid> illissius: i haven't tried it though, why did it not work for you?
16:38:05 <illissius> i'll try... i was trying to do it with just (a ->)
16:38:15 <illissius> i haven't actually, erm, ever used a reader monad before :)
16:40:07 <aristid> yeah it's isn't really that necessary
16:40:22 <aristid> (->) has MonadReader too
16:40:35 <c_wraith> ReaderT is *way* more useful than Reader. :)
16:41:58 <Gracenotes> arguments aren't always worth abstraction away
16:42:03 <Gracenotes> *abstracting
16:48:20 <jmcarthur> ReaderT is one of the most useful transformers, in my experience
16:48:22 <illissius> aristid: yeah it works fine
16:48:23 <sioraiocht> Gracenotes: SO TRUE
16:48:27 <jmcarthur> but Reader is a nearly useless monad
16:48:44 <sioraiocht> Gracenotes: something that I feel like people lose sight of in the haskell abstraction game =p
16:49:04 <aristid> illissius: cool, why didn't it work before?
16:49:38 <jmcarthur> sioraiocht: what? you mean you don't prefer ReaderT Int (ReaderT String (Reader Bool)) a over Int -> String -> Bool -> a?
16:49:54 <jmcarthur> ;)
16:50:30 * sioraiocht blinks.
16:50:42 <sioraiocht> It's far too late for such data types
16:50:48 * jmcarthur blanks.
16:50:57 <illissius> aristid: i dunno, i was doing it wrong? was trying to do it without ask and couldn't figure it out
16:51:03 <Gracenotes> @unmtl ReaderT Int (ReaderT String (Reader Bool)) a
16:51:04 <lambdabot> Int -> String -> Bool -> a
16:51:09 <Gracenotes> o mai
16:51:14 <sioraiocht> neat trick
16:51:50 <jmcarthur> @mtl Int -> String -> Bool -> a
16:51:51 <lambdabot> Maybe you meant: ft map msg pl unmtl url
16:51:55 <jmcarthur> that would be something
16:51:57 <Gracenotes> :(
16:51:59 <sioraiocht> lol
16:52:34 <aristid> @unmtl ReaderT Int IO
16:52:35 <lambdabot> err: `ReaderT Int IO' is not applied to enough arguments, giving `/\A. Int -> IO A'
16:52:43 <aristid> @unmtl ReaderT Int IO a
16:52:43 <lambdabot> Int -> IO a
16:53:08 <Gracenotes> well, we can derive heuristics for it like @pl does
16:54:42 <Gracenotes> except the result type might be some convoluted wrapping of monads one on top of the other
16:57:04 <aristid> a -> b can become Reader a b, in doubt
16:58:21 <Gracenotes> well, only in argument = Reader, argument and result = State, result and monoid = Writer... well, maybe it can be done with pattern matching.. still
16:58:51 <Gracenotes> unless they also give you >>= and return, you can't sure 100% sure
17:00:03 <Gracenotes> *can't be
17:00:35 <aavogt> you can check whether b contains any a types
17:01:53 <orlandu63> what does mtl stand for?
17:02:10 <kmc> monad transformer library
17:02:47 <lispy> mucho typeful lambdas!
17:02:57 <kmc> Î›Î›Î›
17:04:04 <Gracenotes> aavogt: well, if it's a tuple
17:04:26 <Gracenotes> whatever you need to do so mtl is a partial inverse of unmtl
17:10:50 <juhp> gtk doesn't build with LANG=C :-/
17:15:30 <ddarius> Actually, MTL, at least originally, stood for Monad Template Library.
17:17:02 <ivanm> preflex: seen edwardk 
17:17:02 <preflex>  edwardk was last seen on #haskell 2 hours, 51 minutes and 9 seconds ago, saying: yeah that too
17:17:23 <ddarius> http://web.archive.org/web/20060626022339/http://haskell.org/hawiki/MonadTemplateLibrary
17:17:39 <kmc> yes, let's emulate C++
17:17:41 <kmc> for great success
17:18:18 <chrisdone> easier than compiling to it
17:18:20 <dolio> By using the word "template"?
17:19:15 <tim21> Is there any Haskell extension that will tell GHC to not check whether types are actually instances of the required type classes until compile time?
17:19:28 <ddarius> The Haddock for Parsec 3 is mostly copied from the old reference documentation, but suitably updated and obviously the new things have their own documentation.  The original Parsec letter is actually for Parsec 1 but applies equally to all versions of Parsec except for some module names and some slight changes in behaviour.
17:20:14 <sohum> kmc: you implied it's possible to cast dynamically with a TypeRep? 
17:20:31 <tim21> oops, i mean until runtime (d'oh)
17:20:35 <sohum> @hoogle Dynamic -> TypeRep -> a
17:20:35 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
17:20:36 <lambdabot> Prelude seq :: a -> b -> b
17:20:36 <lambdabot> Control.Parallel par :: a -> b -> b
17:23:37 <benmachine> @unmtl State s a
17:23:38 <lambdabot> s -> (a, s)
17:23:41 <tim21> I'm making a simple toy language and I want to compile to Haskell for speed. The behavior I want for the toy language is to check type-class instances at runtime; I could add compile-time checking but that would make the compiler more complicated, and it isn't worth it because it's just a toy. Is there a way to get Haskell not to check typeclass instances until runtime?
17:23:46 <benmachine> @unmtl ReaderT s (Writer s) a
17:23:46 <lambdabot> s -> (a, s)
17:24:34 <ddarius> tim21: That wouldn't even make much sense.
17:24:47 <tim21> ddarius: What do you mean?
17:24:58 <ddarius> (Short of pushing a decent chunk of the type checker into the executable.)
17:25:15 <ivanm> you want to do run-time compilation
17:25:23 <ivanm> that involves basically embedding ghc into your program
17:25:30 <benmachine> tim21: quite a lot of type information is discarded after type checking is complete
17:25:42 <ivanm> or implementing such functionality yourself
17:26:31 <ddarius> Despite type inference, Haskell is much more a Church-style lambda calculus insofar as Haskell programs don't even make sense without types.
17:26:50 <tim21> I don't want runtime type checking, just runtime typeclass checking.
17:26:55 <ivanm> same thing
17:27:07 <tim21> I disagree. Enlighten me, please.
17:27:09 <ivanm> tim21: there's no way you can reliably write an automatic isInstance function
17:27:20 <ivanm> without making a new typeclass and making explicit instances
17:28:05 <ivanm> see http://okmij.org/ftp/Haskell/types.html#class-based-overloading
17:28:15 <tim21> Thanks; I'll try making a "default" instance that just raises an error.
17:28:37 <illissius> aristid: you can even make Tagged s an instance of MonadReader heh
17:29:02 <aristid> illissius: how do you implement local?
17:29:28 <illissius> aristid: maybe you can do it prettier with combinators but this works for me: local f m = do { a <- ask; return $ reify a (retag m) }
17:29:28 <benmachine> @src Reader
17:29:29 <lambdabot> Source not found.
17:29:40 <illissius> (ask = reflect of course)
17:30:07 <ddarius> newtype Reader r a = Reader { runReader :: r -> a }
17:30:47 <benmachine> ddarius: heh, thanks
17:30:59 <Saizan> illissius: and f?
17:31:06 <illissius> Saizan: oh right, i just noticed
17:31:25 <illissius> reify (f a)
17:32:14 <illissius> i should add that 'works' in terms of 'compiles', i didn't try actually using local as has become obvious
17:33:04 <edwardk> illisius: the problem is that reflection doesn't own tagged so it shouldn't make instances for it
17:33:08 <edwardk> but yes, you could
17:33:15 <Cale> tim21: It seems unlikely that you'd be able to know if the type of some value belongs to a class at runtime unless you kept that type all along.
17:34:14 <tim21> Cale: I think I can get the effect I want by using -XOverlappingInstances and then defining a "default" instance which raises an error.
17:34:29 <tim21> Cale: (Not that I'm disagreeing with you.)
17:34:38 <Cale> tim21: If you don't erase the types attached to terms, then sure, you could do typeclass resolution at runtime.
17:35:42 <tim21> Cale: Of course. I just wasn't sure whether somewhere in the menagerie of GHC extensions there was an extension that *would* keep type information at runtime.
17:36:06 <Cale> tim21: The closest thing is Typeable, which is itself a class. :)
17:36:33 <Cale> But there's nothing for picking instances of classes at runtime.
17:37:01 <tim21> Cale: No, Typeable isn't at all what I want. I think I found a solution (see above).
17:38:16 <dolio> If the solution is overlapping instances, I think you're expecting them to do something they don't do.
17:38:28 <dolio> Because they have nothing to do with runtime resolution.
17:38:46 <Cale> tim21: So picking typeclass instances at compile time is fine, and you just want to pick one that gives errors if no other one exists.
17:39:41 <illissius> do other people have the sentiment that "Typeable is such a hack", or is it just me?
17:40:03 <ddarius> illissius: Typeable isn't -that- much of a hack, but it is extremely rare that it is what you want.
17:40:30 <Cale> The main problem with Typeable is that you're allowed to write your own instances of it.
17:40:34 <ddarius> Cale: tim21 is gone, by the way.
17:40:45 <Cale> Oh, I hadn't noticed.
17:40:46 <dolio> Oh yeah.
17:41:31 <illissius> it makes me feel like either (a) anything which uses it should be finding a better way, or (b) if there are valid use cases where that's not possible, then haskell should provide a nicer way to do these kinds of things
17:41:50 <Cale> illissius: hmm
17:42:01 <Veinor> in parsec, how do I say 'match as many non-colon characters as possible'?
17:42:02 <illissius> (spoken as someone who does use Typeable...)
17:42:18 <Veinor> so that I can grab the "foo" in "quux:bar:foo"
17:42:20 <dolio> jhc theoretically has a natural implementation of typeable.
17:42:41 <Axman6> @src Int
17:42:41 <lambdabot> data Int = I# Int#
17:42:50 <Axman6> @src Integer
17:42:50 <lambdabot> data Integer = S# Int#
17:42:50 <lambdabot>              | J# Int# ByteArray#
17:42:56 <Cale> illissius: Well, I rather like the way that you can write   instance Exception Foo   and get an instance without writing any code, whenever Foo is an instance of Typeable
17:43:15 <dolio> For every datatype you define, there is a constructor of a corresponding GADT, which could act as a type rep.
17:43:29 <dolio> Which is used for implementing type classes.
17:43:37 <ddarius> Veinor: You could write, many (satisfy (not (':'==)))
17:43:39 <aristid> :t I#
17:43:40 <lambdabot> Not in scope: data constructor `I#'
17:43:45 <dolio> I should say, there is a corresponding constructor of a GADT.
17:44:12 <Veinor> don't you mean satisfy (':' /=)? :P
17:44:29 <ddarius> Veinor: If you like code that type checks.
17:45:29 <Veinor> er... hm, wait, that's not what I want
17:45:40 <Veinor> I want to say "as many characters as possible, and then a colon"
17:45:42 <ddarius> Veinor: Your example didn't match what you said.
17:45:51 <Veinor> yes. basically I want the regex .*:
17:46:04 <hpc> aristid: I# :: Int# -> Int
17:46:13 <hpc> from the data definition
17:46:17 <illissius> dolio: hmm, that sounds interesting. the way how the compiler generates the TypeReps and you couldn't do it in plain haskell is mostly what makes it feel like a hack
17:46:17 <aristid> hpc: i wanted to see if it actually exists
17:46:21 <hpc> ah
17:46:21 <Philonous> Veinor: manyTill (char ':') ?
17:46:42 <dolio> illissius: If GHC had open GADTs, you could do it manually.
17:46:57 <Philonous> Veinor: Errr, wait
17:47:02 <Veinor> yeah.
17:47:05 <ivanm> Veinor: in polyparse, it'd be "liftM2 (++) (many (satisfy (/=':'))) (liftM return $ satisfy (==':'))"
17:47:19 <dolio> As it is, unsafeCoerce is used.
17:47:23 <ivanm> Philonous: will that get the colon as well?
17:47:32 <Cale> illissius: You can generate TypeReps in plain Haskell.
17:47:35 <Veinor> maybe I should just pull out the part I'm interested in via regexps and then use parsec on the constituent parts
17:47:35 <dolio> So, I'd say that in GHC, it's hackish. jhc would support it properly.
17:47:47 <ddarius> dolio: unsafeCoerce doesn't -need- to be used.
17:47:58 <Cale> Using mkTyConApp/mkAppTy/mkFunTy
17:47:58 <illissius> dolio: data families are sorta like open GADTs, though i'm not sufficiently awake at the moment to think it through
17:48:04 <Veinor> but now I'm curious as to how to do it in parsec.
17:48:07 <Philonous> Veinor: manyTill anyChar (char ':') 
17:48:19 <dolio> illissius: They aren't, really.
17:48:52 <ClaudiusMaximus> last `fmap` sepBy1 (char ':')     ?
17:48:53 <Veinor> Philonous: that won't work because it'll stop at the first :
17:49:01 <illissius> Cale: but only from existing Typeable(N)s though, no?
17:49:11 <dolio> ddarius: If you're content with a closed set of type reps. Or multiple type reps?
17:49:21 <Veinor> ClaudiusMaximus: ooh.
17:49:45 <illissius> dolio: so jhc has open GADTs? or it generates the whole closed GADT at compile time?
17:50:06 <Philonous> Veinor: Oh, you want it to be greedy? You could just say many (try $ manyTill anyChar (char ':'))
17:50:12 <Philonous> Veinor: And concat the result
17:50:31 <dolio> illissius: It doesn't have open GADTs as a language feature. But its implementation of type classes maintains (essentially) a GADT with one constructor for each datatype defined.
17:51:35 <dolio> So it already has all the machinery needed to implement Typeable safely.
17:51:39 <Veinor> Philonous: well, i'm only interested in what's after the last :
17:51:42 <Veinor> so I can just skipMany
17:51:51 <dolio> At least, based on some of the docs I've read.
17:52:20 <Veinor> but it works, thanks!
17:52:39 <dolio> Type classes in jhc are implemented by case analysis on the GADT, more or less.
17:53:28 <ddarius> Veinor: I would probably do something along the lines ClaudiusMaximus suggested and use sepBy.  Your specification requires infinite look ahead to do it the way you want which is less than desirable.
17:54:06 <Veinor> hm.
17:55:19 <ddarius> (Admittedly, the sepBy approach will also require infinite look ahead if the things being separated are strings of anything but ':'.
17:56:31 <ddarius> The "proper" thing to do, in this case, is consider the context so that you know when to stop, unless you do just want everything after the last colon until the end of the input.
17:57:27 <djahandarie> Hmmm, I forget the function for it, it's a generalized version of    something f (a,b) = (f a, b)
17:57:43 <ddarius> :t first
17:57:44 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
17:58:09 <Veinor> hm. is there a builtin that takes a predicate and splits a list on it?
17:58:17 <ddarius> :t span
17:58:18 <ddarius> :t break
17:58:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:58:19 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:58:22 <djahandarie> Ah right
17:58:23 <ddarius> @src span
17:58:23 <lambdabot> span _ xs@[]                     =  (xs, xs)
17:58:23 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
17:58:23 <lambdabot>                   | otherwise    =  ([],xs)
17:58:48 <lispy> > span (==5) [1..10]
17:58:49 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
17:58:57 <lispy> > break (==5) [1..10]
17:58:57 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
17:59:09 <ddarius> break = span . (not .) and vice versa
17:59:24 <djahandarie> The type signatures on arrows always confuse me
17:59:29 <Veinor> well, I was looking for like... f (==":") "a:b:c" = ["a", "b", "c"]
17:59:39 <djahandarie> Veinor, check out Data.List.Split
17:59:41 <ddarius> @hackage split
17:59:41 <lambdabot> http://hackage.haskell.org/package/split
17:59:57 <lispy> > span (/=5) [1..10]
17:59:58 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
18:00:09 <ddarius> That would be presumably, splitWhen
18:00:16 <Veinor> well, splitOn works too
18:00:27 <Veinor> since my predicate is just going to be ==':'
18:01:01 <lispy> ?src break
18:01:02 <lambdabot> break p =  span (not . p)
18:01:56 <Lycurgus> damn, I wanted to ask why e is CakeProphet yclept
18:13:01 <edwardk> illissius: couldn't implement MonadReader for Tagged. can't implement local!
18:13:01 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
18:13:44 <ivanm> hey edwardk 
18:15:04 <illissius> hmm what i wrote is probably just nonsense which typechecks then
18:22:25 <ddarius> edwardk: The documentation for reproxy is off, needs s/tag/proxy/g
18:22:37 <dolio> Arguably, that's because MonadReader is over-specified.
18:22:50 <dolio> You could split it into two classes.
18:22:56 <dolio> Which monadLib does, I believe.
18:25:08 <ivanm> does it make sense to implement scan{l,r} in terms of fold{l,r} ?
18:25:37 <hpc> :t scan
18:25:38 <lambdabot> Not in scope: `scan'
18:25:42 <hpc> :t scanl
18:25:43 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
18:25:44 <hpc> :t foldl
18:25:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:25:58 <ddarius> scanl isn't a foldl
18:26:05 <ddarius> @src scanl
18:26:06 <lambdabot> scanl f q ls = q : case ls of
18:26:06 <lambdabot>     []   -> []
18:26:06 <lambdabot>     x:xs -> scanl f (f q x) xs
18:27:00 <dolio> scanl is most naturally an unfoldr, I think.
18:27:01 <c_wraith> foldl = last scanl.  foldr = head scanr
18:27:39 <ivanm> c_wraith: yeah, I got that
18:27:46 <ivanm> just thinking about how to define the scan functions
18:27:54 <c_wraith> I'm not sure when scanr is ever useful. >_>
18:27:55 <ivanm> @hoogle unfoldr
18:27:55 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
18:27:55 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
18:27:55 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
18:28:01 <ivanm> hmmm...
18:31:21 <Cale> let scanr f z = foldr (\x zs -> case zs of (y:_) -> f x y : zs) [z] in scanr (-) 0 [1..5]
18:31:23 <Cale> > let scanr f z = foldr (\x zs -> case zs of (y:_) -> f x y : zs) [z] in scanr (-) 0 [1..5]
18:31:23 <lambdabot>   [3,-2,4,-1,5,0]
18:31:31 <Cale> > scanr (-) 0 [1..5]
18:31:32 <lambdabot>   [3,-2,4,-1,5,0]
18:32:52 <ivanm> yeah, might as well just do it by hand then
18:33:06 <ivanm> *sigh* so much for doing graph stuff this weekend
18:33:47 <jerryzhou1113> where can i download haskell books
18:34:30 <Cale> @where rwh
18:34:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:34:35 <Cale> @where yaht
18:34:35 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
18:34:37 <hpc> @where lyah
18:34:37 <lambdabot> http://www.learnyouahaskell.com/
18:34:45 <hpc> @where wikibook
18:34:46 <lambdabot> http://en.wikibooks.org/wiki/Haskell
18:35:54 * hackagebot haskell-src-meta-mwotton 0.1.0 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-mwotton-0.1.0 (MarkWotton)
18:37:11 <napping> Has anyone read chakravarty's (or does he have students now?) new paper
18:37:36 <Saizan> link?
18:38:02 <napping> http://tumblr.justtesting.org/post/823545068/singleton-a-general-purpose-dependently-typed-assembly
18:39:37 <Saizan> no, but looks nice :)
18:41:05 <mm_freak_> RyanT5000: thanks
18:41:52 <kmc> sohum, "cast dynamically with a TypeRep?" what do you mean?
18:42:13 <kmc> Data.Typeable.cast doesn't take the TypeRep directly; it'd be unsafe (you might pass the wrong one)
18:42:46 <napping> It is actually possible to break things by making a bogus instance of Typeable
18:43:54 <sohum> kmc: what did you mean when you said "0755.24  kmc> or you can get the TypeRep and use it to choose a cast dynamically", then?
18:44:08 <edwardk> ddarius: doh
18:44:13 <edwardk> ivanm: heya
18:44:20 <ivanm> took you long enough ;-)
18:44:50 <edwardk> ivanm: you were preempted by food
18:45:27 <ivanm> fair enough
18:45:34 <ivanm> you have to have your priorities straight!
18:46:02 <aristid> edwardk: illissius said that it is possible to implement MonadReader for Data.Reflection, and i think it would be possible, but i'm not quite sure. do you think there would be a problem with it?
18:46:17 <kmc> sohum, i meant that you could use it as a key in Data.Map or similar
18:46:26 <illissius> aristid: it typechecks but doesn't work right
18:46:27 <kmc> to choose an action to do something
18:46:42 <kmc> sohum, however there's a technical snag -- it doesn't implement Ord.  we have a workaround though
18:47:01 <aristid> illissius: how did you try to implement local?
18:47:43 <illissius> aristid: local f m = do { a <- ask; return $ reify (f a) (retag m) }
18:47:57 <illissius> aristid: see also: [03:12:37] <edwardk> illissius: couldn't implement MonadReader for Tagged. can't implement local!
18:48:31 <aristid> oh, missed that
18:48:42 <illissius> while that's not a proof it's a plenty strong indication of impossibility for me
18:51:43 <aristid> edwardk: was that a deliberate decision on your part, or was that mandated by the implementation?
18:52:07 <aristid> (to make local impossible)
18:52:07 <napping> kmc: what are you doing that for?
18:52:13 <kmc> doing what for?
18:52:30 <napping> keeping types in a map?
18:52:40 <kmc> i'm not, sohum is
18:53:00 <kmc> this is not the usual way to do dynamic dispatch in Haskell
18:53:01 * hackagebot interpolatedstring-qq-mwotton 0.1 - QuasiQuoter for Ruby-style multi-line interpolated strings.  http://hackage.haskell.org/package/interpolatedstring-qq-mwotton-0.1 (MarkWotton)
18:53:17 <kmc> indeed "dynamic dispatch" is not so special in a language where you can just store functions in values
18:53:22 <kmc> aka, any good language
18:53:25 <kmc> but we already discussed all this
18:54:07 <napping> It's worth noting you can make a perfectly typesafe version of the dynamic stuff with GADTs if you have a limited set of types
18:54:18 <kmc> yeah
18:54:28 <kmc> allegedly jhc does this, what with its whole-program compilation
18:54:42 <napping> oh, that's a bit different
18:54:43 <dolio> It's how it implements type classes.
18:55:13 <napping> I'm not sure if it's done in a typesafe way, or if that's just the compiler knowing everything
18:55:31 <dolio> 'instance C T where foo = ...' => 'foo T = ...'
18:55:42 <napping> iirc it uses pure type systems directly as the IR, so maybe it could
18:58:56 <ivanm> for an MPTC "Foo a b", is it possible to have a method that is only valid when the `b' type is a Bool or something?
18:59:13 <ivanm> (without using a hacky typeclass of which Bool is the only instance)
18:59:37 <kmc> wouldn't that be a superclass of Foo?
18:59:42 <kmc> class Foo a => Bar a b where
19:00:08 <mwotton> so, if anyone hates the idea of me repackaging matt morrow's stuff so I can actually install it from hackage, now's the time to complain :)
19:00:09 <kmc> put your method in Foo as a -> Bool -> ...
19:00:12 <ivanm> well, there's a fundep from a -> b
19:00:39 <ivanm> kmc: I want to have it as a class method if possible, not a function outside the class
19:00:47 <koninkje> ivanm: you can induce requirements that the type is equal to Bool (i.e. via ~ constraints)
19:00:57 <ivanm> that works with MPTCs as well? :o
19:01:16 <illissius> was about to say that
19:01:24 * koninkje was thinking of a cafe pose that did it for peano integers
19:01:28 <illissius> class Foo a b where foo :: b ~ Bool => b -> Bool
19:01:37 <illissius> which compiles, but didn't actually try using it for anything
19:02:01 <ivanm> it seems to be for type families (or at least wants the type families extension)
19:02:19 <illissius> yeah, ~ is from that
19:02:28 <ivanm> well, it seems to work
19:02:38 <illissius> does it let you define instances though?
19:02:41 <ivanm> but a bit weird that I have to enable TypeFamilies just for ~
19:02:45 <ivanm> illissius: haven't tried that
19:02:48 * ivanm tries
19:02:50 <koninkje> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27697#a27697
19:02:53 <kmc> ivanm, err, it's a class method of Foo
19:03:01 <ddarius> ivanm: It is kind of annoying.
19:03:07 <illissius> ivanm: it does for me as long as i give foo a default impl
19:03:14 <koninkje> ...for reference
19:03:20 <kmc> ivanm, what are you trying to do with this?
19:03:20 <illissius> if I try foo = undefined in the instance it errors
19:03:25 <ivanm> illissius: yeah, that's the thing; I have a default impl, but someone might want to override it
19:03:42 <illissius> they can override it as long as b ~ Bool in that instance, i think :)
19:04:00 <koninkje> ...though now that I look at it, I guess that's at the type level, not the term level
19:04:17 <ivanm> ddarius: but it is perfectly valid?
19:04:32 <CakeProphet> so if I have StateT IO ()
19:04:42 <CakeProphet> and IO actions are only executed when bound to main
19:04:44 <ddarius> ivanm: What is?  I was talking about having to enable TypeFamilies for equality constraints.
19:04:49 <CakeProphet> how do I bind my IO actions to main?
19:04:53 <kmc> CakeProphet, runStateT
19:04:55 <kmc> :t runStateT
19:04:56 <jmcarthur> CakeProphet: you have to use runStateT
19:04:56 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
19:05:10 <ivanm> ddarius: that's what I meant: it's valid to use equality constraints for non-type-family stuff?
19:05:11 <CakeProphet> kmc:  aaah, I didn't realize runStateT returned m (a,s)
19:05:15 <ddarius> ivanm: Yes.
19:05:45 <illissius> ivanm: sure.
19:06:17 <illissius> afaik it's only in TypeFamilies because that's what necessitated its introduction
19:06:45 <ddarius> Equality constraints are just delayed unification constraints.
19:06:45 <kmc> ivanm, so can you factor this class into several classes, some with fewer parameters?
19:06:52 <ivanm> kmc: 
19:06:53 <ivanm> gah
19:06:54 <ivanm> kmc: no
19:07:17 <ivanm> kmc: class Container c a | c -> a where ... singleton :: a -> c ... etc.
19:07:35 <kmc> ivanm, also, why'd you choose fundeps over asstypes?
19:07:37 <illissius> ivanm: i'd be curious whether the `foo :: b ~ Bool => b -> etc.` thing ends up working or if it blows up at some point
19:07:48 <ivanm> kmc: because superclass constraints are not yet available
19:07:53 <kmc> ok
19:08:05 <ivanm> (my initial version used ATs, but it made defining a functor-like class impossible)
19:08:10 <kmc> i see
19:09:40 <ddarius> illissius: I don't know if it will do what ivanm wants, because I don't know what he wants, but it seems like a perfectly legitimate and meaningful construct to me.
19:10:00 <ddarius> It should essentially delay type errors for that method to their uses.
19:11:09 <kmc> ivanm, so you've some class method which is only valid for containers of Bool?
19:11:13 <illissius> yeah, that was my assumption...
19:15:37 <ivanm> kmc: yup: and
19:15:59 <ivanm> and or
19:17:19 <mm_freak_> FRP sounds interesting, but somehow i'm failing to wrap my head around it
19:17:33 <illissius> ivanm: why methods rather than standalone functions?
19:17:50 <ivanm> illissius: in case someone has a better implementation for their data type
19:18:01 <ivanm> e.g. for Sets, you will have at most two Bool values anyway...
19:18:04 <ivanm> mm_freak_: agreed
19:18:18 <mm_freak_> ivanm: having the same problem?
19:18:34 <ivanm> yup
19:18:43 <ivanm> (including getting the point of FRP)
19:19:02 <ivanm> still don't understand the significance of "reactive" (or what is meant by "reactive")
19:19:04 <ddarius> mm_freak_: There are about 50 different things, vaguely related, that call themselves FRP.  That might be your problem.
19:19:21 <mm_freak_> ivanm: i'm trying with yampa, which makes much more sense to me than reactive
19:19:34 <jerryzhou1113> where can download realword haskell pdf?
19:19:41 <illissius> mm_freak_: yeah there was a yampa tutorial somewhere which made frp halfway-click for me
19:19:58 <ivanm> jerryzhou1113: you do so by buying it from O'Reilly
19:20:08 <mm_freak_> i've read a paper introducing it using an robot example
19:20:22 <illissius> hmm, i think the one i saw had a furnace
19:20:25 <illissius> it was exceedingly simple
19:20:27 <illissius> but made sense
19:20:47 <jerryzhou1113> i am poor
19:20:49 <mm_freak_> i'll try with a very simple test program now
19:20:55 <mm_freak_> maybe i can get it to work
19:21:13 <jmcarthur> mm_freak_: the basic idea behind classical frp (non-arrow) is that you have "continuously mutating" variables
19:21:17 <mm_freak_> i'm gonna make some particle go from (0,0) to (t,t) or something like that
19:21:50 <mm_freak_> jmcarthur: i understand the problem, which FRP is trying to solve (or does solve)
19:22:37 <jmcarthur> mm_freak_: well, i mean that is literally the semantics that classical frp provides
19:22:51 <jmcarthur> Behaviors are just continuously mutation variables
19:22:52 <ivanm> hooray, and for types that don't have the value being Bool it still works!!!
19:22:59 <jmcarthur> *mutation
19:23:03 <jmcarthur> **mutating
19:23:06 <ivanm> jerryzhou1113: then read it online
19:23:23 <ivanm> download individual pages
19:23:28 <ivanm> make your own PDF if you so wish
19:23:31 <kmc> ivanm, what solution did you use?
19:24:02 <ivanm> kmc: class Container c v | c -> v where ... and :: (v ~ Bool) :: c -> Bool
19:24:13 <ivanm> along with a default implementation using a fold
19:24:56 <mm_freak_> well, as said, yampa slowly makes sense to me
19:25:06 <napping> ivanm: really, (~ Bool) is just like using an IsBool class
19:25:12 <mm_freak_> but what would you people recommend for actual productive development?  reactive?
19:25:24 <ivanm> napping: except then I don't have to implement and expose an IsBool class
19:25:34 <napping> mm_freak_: as far as I know FRP is still mostly experimental
19:25:35 <illissius> mm_freak_: oh never mind, it was a reactive tutorial i saw http://www.formicite.com/dopage.php?frp/frp.html
19:25:37 <jmcarthur> mm_freak_: reactive has some major semantic and implementation bugs
19:25:38 <ivanm> with the possibilities of someone being stupid and creating an instance of IsBool for Int or something
19:25:42 <davekong> how important is it for (read . show) to be an identity function?
19:25:43 <illissius> which is why googling for yampa didn't turn it up
19:25:49 <ivanm> davekong: very
19:25:54 <jmcarthur> mm_freak_: yampa is more tried and true, despite the (IMO) uglier semantics
19:26:04 <napping> ivanm: really?
19:26:08 <ivanm> davekong: read and show are meant to be for serialisation of the code representation of values
19:26:10 <ivanm> napping: yes
19:26:16 <sohum> @hoogle String -> Int
19:26:17 <lambdabot> Test.HUnit.Base Label :: String -> Node
19:26:17 <lambdabot> Prelude read :: Read a => String -> a
19:26:17 <lambdabot> Text.Read read :: Read a => String -> a
19:26:20 <SKK> hello
19:26:24 <jmcarthur> *uglier API, i mean
19:26:42 <koninkje> davekong: for abstract types it needs only be observable identity
19:26:45 <jmcarthur> not a fan of the semantics either, but the interface is what i meant to say
19:26:50 <ivanm> the only time you shouldn't derive Show and Read is when you don't want to expose internal definitions (e.g. Map) or you can't (using TypeFamilies)
19:26:58 <CakeProphet> :::o
19:27:00 <SKK> anybody there?
19:27:03 <illissius> there was some other frp thing where they had a page-long incomprehensible proc notation with DSignal.various crap and such just to implement a button which adds 'a' to the end of its text when you click it
19:27:05 * ivanm waves idly in SKK's general direction
19:27:06 <napping> I've often made Show pretty-print for testing
19:27:08 <ivanm> SKK: no, no-one here
19:27:15 <illissius> which wasn't a very good first impression :)
19:27:22 <sohum> @hoogle Data.ByteString.ByteString -> Int
19:27:22 <ivanm> all this conversation is automated to give the appearance of liveliness in the community
19:27:23 <lambdabot> Parse error:
19:27:23 <lambdabot>   --count=20 "Data.ByteString.ByteString -> Int"
19:27:23 <SKK> ok, sorry, i thought there were people here
19:27:23 <lambdabot>                  ^
19:27:28 <ivanm> napping: which is _bad_
19:27:36 <napping> How bad?
19:27:37 <jmcarthur> wat
19:27:39 <ivanm> wtf?
19:27:46 <ivanm> napping: OK, lemme give you an example
19:27:50 <ivanm> you familiar with my graphviz library?
19:28:03 <napping> bad like segfaults bad?
19:28:13 <ivanm> jmcarthur: he seriously believed my joke about automated conversations?
19:28:21 <jmcarthur> i have no idea
19:28:22 <ivanm> napping: bad as in maintainability, usability and social conventions bad
19:28:30 <napping> or bad like things that say they depende on read and show not working?
19:28:35 <sohum> kmc: ah, right, fair enough
19:28:39 <ivanm> jmcarthur: seems to have quit IRC as well
19:28:55 <kmc> that was weird
19:29:18 <ivanm> OK, he registered his nick 24 weeks ago... and then has never bothered to authenticate on log-in since
19:29:20 <napping> Ah wait, read . show <= id is a bit different
19:29:29 <ivanm> "<= id" ?
19:29:32 <ivanm> that doesn't make sense
19:29:35 <napping> \subseteq
19:29:40 <mm_freak_> jmcarthur: yampa's semantics at least make sense to me
19:29:48 <ivanm> napping: if it maintains the identity and its valid code, it's OK
19:30:11 <c_wraith> ivanm: then what about all those data types that implement Show, but not Read?
19:30:17 <ivanm> napping: the idea is, you can show your data structure mid-debugging, save it, change your code, reload the file in ghci, and then paste that saved data structure in and keep using it
19:30:27 <ivanm> c_wraith: the instance writers should be shot... :@
19:30:29 <beutdeuce> question, i have a datatype Circle with one field "radius" that is of type Int. I want to write a function that computes an area of a circle, given a Circle type. I am having trouble with mismatched types Double and Int, since radius is an Int, but area returns a Double. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27698#a27698
19:30:30 <CakeProphet> ivanm:  why stipulate that it be valid code so long as the identity is maintained?
19:30:36 <ivanm> (that's one of my pet peeves I want to fix with FGL)
19:30:44 <jmcarthur> mm_freak_: largely they share semantics, actually
19:30:46 <napping> I was thinking the idea that you can paste the output of Show into a file
19:30:49 <ddarius> ivanm: One way it makes sense is by using the definability ordering.
19:30:50 <ivanm> CakeProphet: the idea is, you can show your data structure mid-debugging, save it, change your code, reload the file in ghci, and then paste that saved data structure in and keep using it
19:31:03 <ivanm> ddarius: what's that?
19:31:09 <napping> which is much more restrictive than saying you should be able to read
19:31:16 <ddarius> ivanm: The thing with bottom at the bottom.
19:31:20 <ivanm> beutdeuce: use fromIntegral to convert the Int to a Double
19:31:26 <napping> ivanm: precisely - hardly anything actuall has read . show == id
19:31:27 <ivanm> ddarius: I thought we all ignored bottom... ;-)
19:31:37 <ivanm> napping: huh? most things do
19:31:40 <beutdeuce> oh?
19:31:43 <mm_freak_> yampa's 'reactimate' function requires the time difference value to be non-zero
19:31:50 <mm_freak_> hmm
19:31:51 <napping> > show (undefinde, 12)
19:31:53 <lambdabot>   Not in scope: `undefinde'
19:31:56 <napping> > show (undefined, 12)
19:31:57 <lambdabot>   "(*Exception: Prelude.undefined
19:32:07 <napping> not something you can feed back to read
19:32:14 <ivanm> lists, Sets, Maps, Arrays, Seqs, numbers, etc.
19:32:24 <napping> ok, then lists
19:32:30 <napping> > [undefined,12] !! 1
19:32:31 <lambdabot>   12
19:32:34 <ivanm> napping: "undefined" is used to represent a crash-worthy error
19:32:38 <napping> > (id [undefined,12]) !! 1
19:32:39 <lambdabot>   12
19:32:42 <ddarius> ivanm: read . show is less defined than id in most cases.
19:32:45 <napping> > ((read . show) [undefined,12]) !! 1
19:32:46 <lambdabot>   *Exception: Prelude.undefined
19:33:01 <ivanm> ddarius: example (ignoring undefined/bottom) ?
19:33:12 <ivanm> I know of FGL, but it uses Show to pretty-print, not for code
19:33:13 <c_wraith> My opinion is that the relationship between read and show isn't important.  This is because both are quick and dirty hacks, and that Show is generally the more useful of the two.
19:33:18 <ddarius> ivanm: There is no definablitiy ordering ignoring bottom.
19:33:28 <beutdeuce> ivanm: why is it that :: Double didnt work, but when i simple do 1 :: Double, i get 1.0? Is it because 1 is a Num, rather than an Int ? Can i specify radius to be Num ?
19:33:31 <ivanm> c_wraith: if Show returns valid code, then yes
19:33:32 <napping> ivanm: that's precisely the difference between == and ordering
19:33:32 <mm_freak_> i mostly use printf to show things
19:33:32 <jmcarthur> mm_freak_: yeah, things like that are the semantic flaws i see in yampa. it exposes a requirement that events not occur faster than the sampling frequency, for example
19:33:36 <mm_freak_> and real parsers to read
19:33:48 <ivanm> beutdeuce: the magic of the fromInteger function that all numeric types have to define
19:33:51 <mm_freak_> (i like attoparsec, because i mostly work with ByteStrings anyway)
19:33:58 <ddarius> ivanm: And undefined isn't the only type of bottom out there.
19:34:03 <ivanm> because `1' is a valid definition of a Double
19:34:04 <jmcarthur> i prefer read and show to produce and consume valid haskell code
19:34:14 <napping> That's rather restrictive
19:34:18 <ivanm> but how do you define an ordering on functions?
19:34:19 <mm_freak_> jmcarthur: i understand
19:34:19 <jmcarthur> i don't think so
19:34:25 <ivanm> jmcarthur: exactly
19:34:25 <kmc> it's annoying that "deriving (Show)" breaks totally once you have one function field in one constructor
19:34:29 <ivanm> that's the point of them
19:34:34 <kmc> usually i just want that to print "<<fun>>" or something else useless
19:34:39 <kmc> since Show is for quick hacks anyway
19:34:42 <Phyx-> wb napping :)
19:34:45 <napping> IME taking advantage for GHCi automatically showing things and hooking Show up to a pretty printer is useful
19:34:46 <dolio> > ((id) [[1..], [12]]) !! 1
19:34:46 <ivanm> kmc: import Text.Function or whatever it is
19:34:47 <lambdabot>   [12]
19:34:52 <dolio> > ((read . show) [[1..], [12]]) !! 1
19:34:53 <lambdabot>   *Exception: Prelude.read: no parse
19:34:59 <ivanm> kmc: and I beg to differ that it's for hacks
19:35:03 <napping> Binary is for real serialization
19:35:04 <ivanm> it's very useful for debugging
19:35:06 <ddarius> There should be standard PrettyPrint and DebugPrint classes.
19:35:07 <dolio> > ((read . show) [[1..], [12]] :: [[Int]]) !! 1
19:35:12 <lambdabot>   mueval-core: Time limit exceeded
19:35:13 <mm_freak_> jmcarthur: so are there any other FRP libraries, which are useful for real apps?
19:35:14 <Zao> kmc: Wouldn't it be possible to write a TH snippet to derive slightly more clever Show instances?
19:35:14 <napping> ddarius: that would be best
19:35:15 <ivanm> ddarius: I disagree
19:35:28 <koninkje> ivanm: but isn't debugging a quick hack?
19:35:29 <mm_freak_> if not, i'll probably go with yampa anyway
19:35:29 <napping> kmc: for functions, you can import a show intance
19:35:29 <Zao> (I have no idea what TH is capable of)
19:35:33 <ivanm> since quite often you would want a different pretty representation of common values like Ints in different situations
19:35:38 <ivanm> koninkje: how is it a quick hack?
19:35:46 <c_wraith> For it to be useful for debugging, you need to be able to show some representation of values that cannot be reduced to (a finite amount of) code.
19:35:49 <ivanm> Zao: "slightly more clever"? how?
19:35:52 <jmcarthur> mm_freak_: there's elerea, buster, etc. i don't know much about them. i hear elerea is useful, but perhaps a bit less semantically refined
19:35:54 <koninkje> ivanm: well, once you're done you don't need it anymore :)
19:35:56 <ddarius> ivanm: I can agree with that, but at any rate, these concerns should be separated.
19:36:05 <ivanm> koninkje: except for other people using your code...
19:36:08 <koninkje> ivanm: I mean, debugging isn't part of the program semantics nor the user-facing code
19:36:09 <Zao> napping: Would you need different instances for different arities?
19:36:26 <jmcarthur> mm_freak_: i believe i also read that elerea is pretty fast compared to the alternatives, but take that with a grain of salt
19:36:31 * koninkje thinks error messages /= debugging
19:36:38 <ivanm> ddarius: e.g. for graphviz, I have to be able to parse values like .0 and "1e2" (note the quotes) as Doubles
19:36:45 <ivanm> and I don't really feel like newtyping Double
19:36:59 <mm_freak_> jmcarthur: i have the impression that FRP is generally slower than using some kind of classic event loop
19:37:10 <napping> Zao: considering the best you can do is pretty much just go "<<fun>>", so e.g. Int -> (Int -> Int) matches instance Show (a -> b) just fine
19:37:20 <mm_freak_> jmcarthur: but not from personal experience, but from what i read
19:37:22 <ddarius> ivanm: I don't understand how that relates to what I was saying.
19:37:25 <Zao> napping: Oh, right.
19:37:35 <napping> hmm, I suppose you could do evil magics with unsafeCoerce# or Ptr to find the info table and show instructions
19:37:36 <jmcarthur> mm_freak_: i don't think that is necessarily so. i've spent a little time building a stream fused frp library. i never finished it, but i think it could theoretically be nearly as fast as a standard loop
19:37:55 <mm_freak_> hmm, ok
19:37:58 <jmcarthur> or perhaps even as fast
19:38:10 <napping> ivanm: sounds like a case where you should expect to have to write a proper parser
19:38:12 <mm_freak_> i'm used to stack monads together and write a 'forever'
19:38:14 <ivanm> ddarius: having one big overall pretty-printing and parsing class wouldn't be useful in general anyway since you'd often have to have custom variants for different types of data
19:38:16 <napping> and just might get lucky
19:38:21 <mm_freak_> that's my usual way of dealing with such things
19:38:22 <ivanm> napping: well, yes, I did
19:38:51 <ivanm> besides, how would you pretty print soemthing of type "Array (Int, Int) (Maybe Char)" ?
19:38:52 <jmcarthur> mm_freak_: monad stacks can get pretty slow too, actually
19:38:53 <mm_freak_> the reason why i ask is:  i'd like to make games/simulations with lots and lots of particles
19:39:14 <ddarius> ivanm: I agreed with that and actually made a similar argument a few weeks ago.  But a standard DebugPrint class that is meant for output that is not necessarily meant to be machine readable would still be helpful.
19:39:15 <mm_freak_> jmcarthur: in my experience, they are very fast
19:39:26 <napping> ivanm: well, considering it needn't have anything to do with the instance you have for (Maybe Char) there's plenty of freedom
19:39:33 <jmcarthur> mm_freak_: unless the frp library does some stream fusion or something, i don't know that i would recommend that you do each particle as a separate behavior or something
19:39:38 <ivanm> ddarius: in which situations?
19:39:43 <mm_freak_> some people say that instead of using complicated monad transformer stacks you should just write a custom monad instead
19:39:50 <ddarius> ivanm: In all the situations people abuse Show for currently.
19:39:53 <napping> ddarius: in particular, a class like that should have some means of pruning values
19:39:59 <ivanm> a pretty-printed version of Map, graphs, etc. might be useful
19:40:06 <mm_freak_> but i don't believe that, especially since i use monad transformers for modularization of my code
19:40:06 <ivanm> but it wouldn't be derivable AFAIK
19:40:12 <jmcarthur> mm_freak_: a behavior of a collection of particles could work, but would be a bit less elegant. maybe could keep some good from frp while retaining particle effect performance though
19:40:18 <ddarius> Actually, not "all" of them since I think there are more than two concerns coupled into the current Show/Read classes.
19:40:21 <ivanm> ddarius: except they're typically likely to abuse them in different ways
19:40:31 <napping> ivanm: The fact that Show is used in ghci is much more significant the use by people who want crappy String-based serialization
19:40:32 <jmcarthur> mm_freak_: i too much prefer to use generic composed monads rather than writing custom ones
19:40:44 <napping> ivanm: I think it would help to separate both uses
19:40:49 <mm_freak_> jmcarthur: the particles are going to be independent, so sticking them together would pretty much destroy the point of FRP
19:40:54 <tolkad> > {5, 2}
19:40:55 <lambdabot>   <no location info>: parse error on input `{'
19:40:59 <tolkad> > {5; 2}
19:41:01 <lambdabot>   <no location info>: parse error on input `{'
19:41:07 <jmcarthur> mm_freak_: i haven't been *bitten* by that, but i have benchmarked it, and transformer stacks are indeed much slower than an unwrapped custom monad :\
19:41:15 <jmcarthur> mm_freak_: yeah... :(
19:41:17 <napping> and indeed perhaps to separate the idea of formatting a value in a way that can be copied into source as a third notion
19:41:18 <tolkad> > let {x = 5; y = 2} in x + y
19:41:19 <mm_freak_> hmm, ok
19:41:20 <lambdabot>   7
19:41:23 <tolkad> ah
19:41:33 <mm_freak_> jmcarthur: i haven't been bitten either, so who cares? =)
19:41:37 <jmcarthur> exactly
19:41:45 <jmcarthur> if i get bit, i'll write a custom one then
19:41:58 <mm_freak_> and i believe, some time GHC will optimize well enough so that the difference vanishes
19:42:01 <tolkad> let {class C a where f :: (Integral b) => a -> b; data T = T Int; instance C T where f (T i) = i} in f (T 5)
19:42:04 <tolkad> > let {class C a where f :: (Integral b) => a -> b; data T = T Int; instance C T where f (T i) = i} in f (T 5)
19:42:04 <ddarius> Yes, there are binary serialization, textual serialization, pretty printing, human readable debug output as a list of concerns.
19:42:06 <lambdabot>   <no location info>: parse error on input `class'
19:42:11 <tolkad> ???
19:42:15 <tolkad> why doesn't that work?
19:42:30 <tolkad> it gives me a different error in ghc
19:42:40 <tolkad> it says "Couldn't match expected type `b' against inferred type `Int'"
19:43:35 <tolkad> oh!
19:43:35 <dolio> No it doesn't.
19:43:41 <tolkad> nevermind, I forgot I have to use fromIntegral
19:43:43 <napping> Phyx-: any progress?
19:44:00 <napping> Phyx-: GHC API was hard, so I went shopping :)
19:44:00 <tolkad> dolio: well, I wrote it without the let syntax in ghc
19:44:18 <CakeProphet> :t loop
19:44:19 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
19:44:39 <mm_freak_> jmcarthur: something, which sucks with yampa is that it practically forces me to use IORefs
19:45:04 <jmcarthur> ew
19:45:14 <davekong> in conclusion using show to pretty-print 
19:45:46 <mm_freak_> jmcarthur: or is there a different way to save the time?  otherwise i wouldn't know how to calculate the time difference
19:45:49 <napping> davekong: the conclusion is you really ought to make read the inverse of show
19:45:53 <Phyx-> napping: ModuleInfo looks promising, But I decided to spend the day reducing my TODO list
19:46:04 <napping> davekong: this can be accomplished by not providing Read, if you like
19:46:14 <ddarius> The conclusion is that people are far from unjustified in abusing Show.
19:46:22 <Phyx-> I implemented alot of things I said I would "do later" and replaced quick and dirty code with proper ones etc
19:46:27 <Phyx-> overall pretty productive
19:46:37 <Phyx-> I'll try again tomorow with the ModuleInfo
19:46:43 <dolio> Use one of the pretty printing packages. It has nicer combinators anyway.
19:47:00 <napping> davekong: anyway, why are you asking?
19:47:09 * ivanm still wants a pretty-printing package that supports indentation with infinitely long lines
19:47:16 <dolio> wl-pprint even has a class for pretty printing.
19:47:22 <ivanm> pretty doesn't; AFAICT none of the rest do either :s
19:47:25 <napping> ivanm: which do you have trouble with?
19:47:39 <napping> can't you get that in ribbon mode with just about any of them?
19:47:48 <ddarius> dolio: Pretty printing isn't the only issue or the biggest arguably.  There are a few classes for pretty printing, but none of them are widely usede.
19:47:49 <davekong> napping: I was using show to pretty-print but then I read somewhere read . show should = id so I was wondering why
19:47:50 <ivanm> no, ribbon mode will zig-zag after a certain point
19:47:52 <ddarius> @hackage pretty-class
19:47:53 <lambdabot> http://hackage.haskell.org/package/pretty-class
19:48:16 <ddarius> @hackage prettyclass
19:48:16 <lambdabot> http://hackage.haskell.org/package/prettyclass
19:48:18 <ivanm> davekong: because it's meant to print and parse valid code representations of the value
19:48:29 <napping> davekong: well it is a reasonable thing to expect. In particular, how else should people be expected to learn what read expects?
19:48:38 <ivanm> and that requirement basically ensures that they're internally valid
19:48:51 <ddarius> While it would still likely be useful in practice, a class for pretty printing isn't that important or even desirable.
19:48:53 <dolio> Wow, a rational precedence level.
19:48:59 <ivanm> dolio: for what?
19:49:06 <dolio> For pPrintPrec.
19:49:12 <napping> davekong: Also, I would expect most of the time Show should include all the information in the value
19:49:19 <djahandarie> Gah
19:49:31 <napping> or at least all that you want to expose, in the case of abstract data types like Map
19:49:50 <djahandarie> I've been trying to make these two functions hook into each other for the past 15 minutes and I can't figure it out -_-
19:50:08 <davekong> napping: I mean I could implement Read and it might even make sense though will be some work
19:50:18 * hackagebot interpolatedstring-qq 0.2 - QuasiQuoter for Ruby-style multi-line interpolated strings.  http://hackage.haskell.org/package/interpolatedstring-qq-0.2 (ErikCharlebois)
19:50:20 <ddarius> However, a DebugPrint with a printLevels that prints a given number of recursive instantiations (however the implementor wants to interpret that) could be derived and used in GHCi with a GHCi configurable default.
19:50:26 <dolio> I guess that's useful in that you can always fit a new operator in between any two others.
19:50:32 <napping> davekong: implementing Read is entirely optional
19:50:50 <djahandarie> I have m a -> m b, but I want it to work like m (a, x) -> m (b, x)
19:50:51 <napping> davekong: what that's saying is that if you implement both they ought to agree
19:51:14 <djahandarie> I have no idea how to transform it like that though
19:51:19 <napping> davekong: just like a thing that is a monad and a functor really better have (fmap f m) and (m  >>= return . f) be identical
19:52:22 <ddarius> djahandarie: You want (essentially) a function (m a -> m b) -> (m (a, x) -> m (b, x)) ?
19:52:40 <djahandarie> Yes, basically
19:52:50 <davekong> napping: alright, thanks for the explanation
19:52:56 <davekong> and thanks ivanm
19:53:08 <koninkje> djahandarie: \f max -> max >>= \(a,x) -> f a >>= \b -> return (b,x)
19:53:11 <ivanm> np
19:53:31 <koninkje> djahandarie: though you can simplify it with pointlessness
19:53:44 <ivanm> well, there's one of mwotton's custom packages made redundant...
19:53:46 <napping> davekong: also, Read is much less important. It's usually code constructing values, whether part of a program or typed in ghci
19:54:05 <djahandarie> I was trying to do it with arrows and fmap but was failing hard
19:54:31 <napping> you (as a human using the shell) build values by calling the API and recieve values with Show
19:54:44 <tolkad> ok, let's say I have a class, with function f on an instance of the class. I want all instances of f to return a real number but beyond that I don't care what it returns. What should the type of f be?
19:54:51 <koninkje> I think the problem is that fmap@(a,b) is going to map the second component, which means lots of munging to flip things around
19:55:54 <tolkad> ok, let's say I have a class, with function f on an instance of the class. I want all instances of f to return a real number but beyond that I don't care the type of what they return. What should the type of f be?*
19:55:58 <koninkje> let swap (x,y) = (y,x) ; gmap f = swap . fmap f . swap
19:56:12 <napping> tolkad: what do you mean by "real number"?
19:56:22 <tolkad> napping: the mathematical definition?
19:56:31 <tolkad> napping: Some datatype of class Real
19:56:34 <djahandarie> koninkje, wouldn't yours be (a -> m b) -> (m (a, x) -> m (b, x))
19:56:50 <ivanm> tolkad: (RealFloat f) => a -> f ?
19:57:46 <ivanm> tolkad: note that each instance has its own distinct Real instance it returns (Foo always returns a Double), then you're going to need either MPTCs+FunDeps or an associated type
19:57:50 <koninkje> djahandarie: oops
19:58:52 <koninkje> djahandarie: \(f::m a->m b) (max::m(a,x)) -> max>>=\(a,x)-> f (return a) >>=\b-> return (b,x)
19:58:54 <mm_freak_> my first FRP program works =)
19:59:17 <napping> tolkad: more to the point, what do you expect the clients to be able to do with the value?
19:59:18 <koninkje> djahandarie: though that can't handle all (m a -> m b) since it allows the effects of the m(a,x) to escape
20:00:07 <tolkad> napping: any operation that's possible for all real numbers: addition, multiplication, etc.
20:00:13 <napping> tolkad: If you only promise to provide e.g. a RealFrac, then there's no point in a particular instance providing something fancier like a computable real
20:00:13 <ddarius> koninkje: Indeed, it causes m (a, x) to be executed exactly once regardless of the number of times f would execute m a.
20:00:17 <koninkje> djahandarie: I think, in general, the function you want doesn't exist since the side effects needed to create the x might be destroyed by the conversion of (m a) into (m b)
20:00:27 <napping> and then perhaps you should just fix it to Double or something
20:00:49 <tolkad> napping: but I want the instances to decide what type they want to return
20:00:54 <djahandarie> Hm
20:00:58 <napping> how does that help?
20:01:04 <ddarius> napping, tolkad: Note that the issues that lead to the Factory pattern in Java are relevant here.
20:01:15 <napping> if you know foo :: B -> exists t . (RealFrac t) => t
20:01:18 <tolkad> it's a really common concept in OOP programming
20:01:27 <napping> than the only thing callers can do is things they can do on any RealFrac
20:01:34 <koninkje> djahandarie: where "in general" means allowing all possible capturing of effects. If you don't need to capture effects, then things are easier
20:01:54 <napping> ddarius: really? I'm not aware of OO languages with decent parametricity results
20:02:28 <ddarius> napping: One issue is that you can't "make" a "generic" RealFrac, you can only make a concrete instance.
20:02:40 <napping> also, terminal coalgebras are kind of useless so there's not a decent notion of a "most generic" Foo for most OO things
20:03:43 <tolkad> In OOP, when you are defining an interface, you specify all functions as returning the most general class possible
20:04:05 <napping> ddarius: data RealFrac = forall r . (RealFrac r) => C r  is a generic realfrac
20:04:06 <ivanm> ddarius: well, fromIntegral will let you make a generic one... ;-)
20:04:20 <ivanm> @hoogle (RealFrac b) => a -> b
20:04:20 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:04:20 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:04:21 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
20:04:27 <ivanm> bah
20:04:40 <ddarius> napping: RealFrac (there) is a specific concrete type.
20:04:50 <napping> ddarius: into which any RealFrac can be mapped
20:05:05 <ddarius> Further more you have to write C someDouble or C someOtherRealFrac type.
20:05:15 <ivanm> napping: ugh
20:05:22 <ivanm> napping: why not just use Double?
20:05:32 <ddarius> Which is pretty much exactly analogous to RealFrac r = new Double(3.0);
20:05:54 <napping> ivanm, tolkad: well, that's kind of the point
20:06:15 <ivanm> napping: what is?
20:06:29 <ivanm> oh, right, you were telling tolkad to just use Double
20:06:36 <djahandarie> koninkje, I'm not really sure if I need to capture effects or not
20:06:41 <napping> actually returning a value of an unknown RealFrac type involves ugliness, and doesn't actually end up being more useful than standardizing on Double or perhaps Rational
20:06:42 <tolkad> -_-
20:06:47 <ivanm> sorry, I was mixing you and tolkad up (I thought you were wanting to be able to return 'any RealFrac type')
20:07:05 <tolkad> I don't WANT to use Double, I want to do exactly what I said I want to do
20:07:13 <djahandarie> This is my function    mapBot :: (IO (a, BotState) -> IO (b, BotState)) -> Bot a -> Bot b
20:07:17 <tolkad> Doubles do not have arbitrary precision
20:07:19 <ivanm> if you do want to let the instance choose which RealFrac instance to return, you can do that with either MPTCs+fundeps or an AT
20:07:23 <tolkad> which is what I want
20:07:28 <djahandarie> But I have an     IO () -> IO ()    which I need to fit in there somehow
20:07:28 <ivanm> tolkad: then use CReal
20:07:32 <ivanm> warning: it's slow
20:07:36 <napping> tolkad: then use a fundep (which may actually be usefl), or return a wrapper like that and no idea what you'll manage to do with it
20:07:40 <ddarius> tolkad: And a generic RealFrac also doesn't guarantee arbitrary precision.  Use a concrete type that does.
20:07:54 <tolkad> ivanm: well, I want class instances to be able to use CReals, or doubles, or whatever else might be able to store the value they want to store
20:08:05 <tolkad> that way, if I only end up storing doubles anyway, I have the speed that entails
20:08:08 <napping> tolkad: the question you didn't answer is whether there's a particular fixed type which will be returned for each instance
20:08:28 <ivanm> tolkad: if you have some class "class Foo a where ... foo :: (RealFloat f) => a -> f", does a constrain f?
20:08:32 <ivanm> or can any a return any f?
20:08:45 <napping> so the instance for Snob will always return Double, and the instance for Bleem will always return Rational, and so on?
20:09:18 <ddarius> djahandarie: There is no canonical way to "slip it in" there.
20:09:19 <ivanm> damn snobs :@
20:09:32 <tolkad> ddarius: after the value is returned to f, if I decide I want to do a calculation involving arbitrary precision, I can just cast to a type that supports that
20:09:34 <koninkje> djahandarie: do you have any sort of exception catching? or are side effects more "once and for all"?
20:09:35 <xcthulhu> Is there better automated theorem proving support for CReals over doubles or floats?
20:09:36 <geheimdienst> i pattern-match a 1-element list with foo (x:[]) = ... right?
20:09:38 <tolkad> returned from f*
20:09:55 <djahandarie> koninkje, that IO () -> IO () is actually the result of a handle
20:09:59 <xcthulhu> Via Haskabelle?
20:10:25 <ivanm> tolkad: nope, there's no way you can do that
20:10:40 <ivanm> since as someone (ddarius?) said, there's no way you can construct an arbitrary RealFloat
20:10:52 <ivanm> you can, however, use a conversion function to convert a Double to a CReal or soemthing
20:10:55 <ivanm> @hoogle Double -> CReal
20:10:55 <lambdabot> Warning: Unknown type CReal
20:10:56 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:10:56 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:11:10 <ivanm> xcthulhu: not sure what you're asking...
20:11:12 <ivanm> @hoogle Double -> Float
20:11:13 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
20:11:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:11:13 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:11:23 <ivanm> OK, realToFrac should support Double -> CReal as well
20:11:30 <xcthulhu> ivanm, http://isabelle.in.tum.de/haskabelle.html
20:11:32 <ivanm> > realToFrac 2 :: CReal
20:11:33 <lambdabot>   2.0
20:11:40 <ivanm> xcthulhu: no, I meant what you want to do
20:11:44 <tolkad> ivanm: but I can't do that, I don't know what instances of Real may have been imported by the instances of my class
20:11:48 <napping> ivanm: that show isntance is lies
20:11:51 <ddarius> You can also return the RealFloats you are given or have the user pass in a RealFloat making function, i.e. use the factory pattern.  It depends on what you are actually trying to do.
20:12:00 <tolkad> ivanm: so I can't write conversion functions between all of them
20:12:04 <ivanm> napping: yeah, because CReals can't be expressed directly
20:12:27 <ivanm> tolkad: ummm.... you fix your function to always return a Double or something, and then whenever youw ant to use a specific one you convert
20:12:52 <ivanm> tolkad: you have to choose some fixed thing somewhere: either f always returns a certain type, or the value that f is applied to chooses what type to use
20:13:02 <tolkad> ivanm: no, because then I can't use arbitrary precision if I want to, in either the instance or after I call f
20:13:14 <napping> tolkad: I'm having trouble guessing what you are doing where optionally returning CReal is needed and it's also possible you could ever care about performance
20:13:21 <ivanm> napping: technically, there shouldn't be any Show instance for CReal since it's a function, but the Num class requries one
20:13:32 <ivanm> tolkad: THEN HAVE IT ALWAYS RETURN A CREAL!!!!!
20:13:36 <xcthulhu> ivanm, Well, I was wondering if proving theorems about a function (+) :: CReal -> CReal -> CReal is easier than proving theorems about (+) :: Float -> Float -> Float
20:13:50 <ivanm> anyway, arbitrary precision is overrated unless you're doing a lot of scientific computing or something IMHO
20:13:56 <napping> ivanm: aha, lies upon lies. I bet they didn't implement signum properly either
20:13:57 <tolkad> ivanm: but I might decide I don't want to use a CReal in either case, then it would be more efficient to just use Doubles
20:14:01 <ivanm> xcthulhu: I think it'd be harder
20:14:04 <ivanm> napping: IIRC, they didn't
20:14:19 <ddarius> signum is not implementable
20:14:21 <napping> tolkad: You haven't answered the fundamental question
20:14:23 <ivanm> xcthulhu: since CReal is just a function, and even equality isn't defined properly on them
20:14:43 <napping> tolkad: For a instance of your class, will the method always return the same type of number?
20:15:28 <xcthulhu> ivanm, in Isabelle, you can prove f = g if you can prove f a = g a for all a
20:15:32 <kmc> what's all the shouting about
20:15:39 <tolkad> napping: I don't want my code to care about that
20:15:41 <xcthulhu> ivanm, So you use extensionality...
20:15:41 <ivanm> xcthulhu: except you can't prove that for CReals
20:15:46 <ivanm> AFAIK
20:15:50 <tolkad> napping: I don't want to decide that until compile time
20:15:50 <ivanm> preflex: seen roconnor
20:15:51 <preflex>  roconnor was last seen on #haskell-blah 1 day, 4 hours, 32 minutes and 12 seconds ago, saying: swap the arguments to -
20:16:05 <kmc> xcthulhu, hmm, interesting, that's independent of CIC
20:16:16 <ivanm> tolkad: you have to have a constraint somewhere, because it's not possible to construct a generic RealFloat
20:16:19 <ivanm> as we've already said
20:16:30 <tolkad> ivanm: I don't want to construct a generic RealFloat
20:16:32 <ivanm> xcthulhu: maybe ask roconnor when he's around (or @ask him)
20:16:33 <xcthulhu> kmc, it's a standard assumption of HOL (along with the axiom of infinity and choice).
20:16:33 <napping> tolkad: What do you mean you don't what to decide until compiler time?
20:16:35 * kmc wonders if he should learn Isabelle
20:16:37 <tolkad> ivanm: I want to construct a generic Real
20:16:39 <ddarius> tolkad: The question napping is asking is not something your code "cares" or "doesn't care" about, he's asking about the interface that you are exposing.
20:16:42 <ivanm> tolkad: whatever
20:16:49 <ivanm> it's not possible to construct a generic Real
20:16:54 <ivanm> unless it's an integral value
20:16:55 <napping> tolkad: I'm asking you how you will describe your type class in the documentation
20:17:04 <tolkad> napping: it might happen that all instances of my class have f return a Double, or some imported class somewhere might use something else
20:17:14 <dolio> ivanm: The problem with things like CReal is decidability not provability, generally.
20:17:17 <napping> tolkad: Ah, that's not quite what I asked
20:17:28 <ivanm> tolkad: there's no way I can define 2.5 programmatically and have it be valid for all Real instances
20:17:31 <ivanm> dolio: hmmm....
20:17:54 <ivanm> tolkad: so, can an instance choose which type of Real it returns?
20:17:56 <napping> tolkad: What's your class and method called anyway?
20:18:03 <ivanm> or does it have to return some arbitrary type of Real?
20:18:05 <tolkad> napping: C and f
20:18:09 <ddarius> ivanm: 5 / 2 should work, though there is little guarantee that it will be 2.5 as there are almost no laws or ranges given for those classes.
20:18:20 <ivanm> ddarius: well, that was an arbitrary example
20:18:43 <ivanm> I was about to do sqrt 2, then realised that you can use fromIntegral there...
20:18:49 <napping> tolkad: Okay. Three possiblities - The one you just seemed to mention, there is some real type R so in every t which is an instance of C, f :: t -> R
20:19:23 <ivanm> for every instance of C t there is some real type R_t such that f :: t -> R_t
20:19:29 <ddarius> tolkad: Write out the full class definition for this class as you envision it.
20:19:32 <napping> tolkad: second thing (the one that actually matters) - It is the case that for every t which is an istance of C, there is some real type R_t, so calling f on a t gives an R_t
20:19:35 <ivanm> or forall t, forall R, f :: t -> R
20:19:41 <ivanm> the last isn't possible
20:19:52 <ivanm> you need a "there exists" somewhere
20:20:01 <tolkad> ddarius: class C a where f :: (Real b) => a -> b
20:20:10 <ivanm> tolkad: that isn't possible in general
20:20:20 <tolkad> ivanm: that seems to compile
20:20:22 <ivanm> since you can't construct an arbitrary Real value
20:20:36 <napping> tolkad: third case, which will be much harder to handle, there may be some T that's an instance of C so one call of f on a T may give you a Double, and another call on a different T may give a Rational
20:20:37 <ivanm> tolkad: try using it
20:20:47 <tolkad> ivanm: yes I can, I can construct 5, that's an arbitrary Real number
20:21:00 <tolkad> > 5
20:21:01 <lambdabot>   5
20:21:05 <ivanm> tolkad: no, I meant that you can't define it such that it can return any arbitrary number
20:21:12 <tolkad> > 5 :: (Real x) => x
20:21:13 <lambdabot>   5
20:21:16 <tolkad> see?
20:21:24 <ivanm> if you only care about returning integral values, then it's not a problem
20:21:31 <ivanm> tolkad: without hard-coding it in
20:21:34 <tolkad> I just casted 5 to a Real
20:21:39 <ddarius> tolkad: That's defaulting to Double.
20:21:44 <ivanm> *sigh* you're kinda arguing my point here
20:21:48 <ddarius> tolkad: There are no "casts" in Haskell.
20:21:49 <napping> tolkad: a type (Real b) => x -> b
20:22:04 <napping> promises that for any Real the caller likes, you will return something of that type
20:22:21 <tolkad> hmm, I think I see how to define this now, I'll try and see if I get any compiler errors
20:22:27 <ivanm> tolkad: there is no way that an instance t can choose some arbitrary value from all possible Reals with 50 million decimal places and be guaranteed that it will be able to return it as some arbitrary Real instance
20:22:31 <napping> looking at the methods in Real, the only way you have to get values is by calling fromInteger in Num
20:22:33 <xcthulhu> tolkad, You can't construct the real number k in [0,1] where the nth binary digit is 1 if and only if the nth constructable Turing machine halts when given it's own numeral as input
20:22:40 <ivanm> tolkad: if you're only returning Integral values, then have it return an Integer or something
20:22:52 <ivanm> xcthulhu: thank you, there's a good example
20:22:53 <napping> tolkad: as long as your method builds all values by starting with integer, that's fine
20:22:55 <tolkad> ivanm: nah, I want it to return any Real
20:23:04 <koninkje> is there a ByteString version of System.Environment ?
20:23:08 <ivanm> tolkad: how would you return the example xcthulhu gave then?
20:23:13 <ivanm> koninkje: no
20:23:14 <napping> tolkad: also, if your method requires some arguments of the desired result type, that's fine
20:23:14 <tolkad> might be a CReal, might be a Double, might be an Integer
20:23:19 <napping> ivanm: you are confusing values and types
20:23:21 <koninkje> ivanm: alas
20:23:39 <ivanm> tolkad: will all the values being returned be an integral-like value?
20:23:46 <lispy> In the Cthulhu monad, is pure called pureEvil?
20:23:47 <mm_freak_> it seems like yampa is only suitable for simple applications =/
20:23:48 <ivanm> if so, then return an Integer and make it more explicit
20:24:06 <ivanm> otherwise, I could expect that some instance will return a value like what xcthulhu defined
20:24:12 <lispy> mm_freak_: why is that?
20:24:18 <napping> tolkad: I don't think Real is the clas you want, anyway
20:24:30 <napping> tolkad: but please to be answering my question
20:24:35 <ivanm> napping: well, that was the main objection I was talking about: how would you construct an arbitrary value of an arbitrary type
20:24:36 <lispy> mm_freak_: does Frag use yampa or arrows?
20:24:47 <napping> ivanm: by using class methods, of course
20:25:01 <ivanm> so in essence he's returning a CReal anyway
20:25:03 <mm_freak_> lispy: because app state is difficult to encodeâ€¦  only through explicit argument passing
20:25:13 <mm_freak_> lispy: IIRC frag has its own FRP system
20:25:43 <tolkad> wtf it didn't work
20:25:44 <mm_freak_> i'd try reactive, but it seems like it's not really mature yet =/
20:25:47 <napping> ivanm: optimization will work much better on a method that returns an arbitrary Fractional, than trying to fuse things with a CReal constructor
20:25:52 <tolkad> look, this is what I want to do: http://pastebin.com/BDLsuLi3
20:25:59 <ivanm> napping: true
20:26:01 <lispy> mm_freak_: So is yampa incompatible with layering over some sort of state or reader monad to manage that explicit state passing?
20:26:05 <tolkad> "  Couldn't match expected type `b' against inferred type `Double'"
20:26:09 <tolkad> that doesn't make any sense!?
20:26:12 <ivanm> tolkad: yup
20:26:17 <napping> tolkad: ah, your type is backwards
20:26:18 <tolkad> Double IS an instance of b
20:26:18 <xcthulhu> tolkad, The real numbers are a pretty crazy mathematical construction.  You can't construct all of them.  Because the sort of things you can construct form a countable list, and I'm sure you know about Cantor's diagonalization argument
20:26:22 <tolkad> it should be able to match it
20:26:27 <ddarius> Double doesn't have type forall b. Real b => b
20:26:28 <ivanm> because it doesn't know which arbitrary value to choose as the intermediary one
20:26:30 <tolkad> why wont it match -_-
20:26:46 <napping> tolkad: that's forall b . (Real b) => a -> b -- for any b at all that the caller wants, you have to be able to make one
20:26:54 <tolkad> I understand how this works, data types are like OOP classes, classes are like OOP interfaces
20:27:02 <ivanm> hell no
20:27:02 <ddarius> tolkad: No, they are not.
20:27:09 <ivanm> preflex: seen dibblego 
20:27:09 <preflex>  dibblego was last seen on #haskell 4 hours, 6 minutes and 35 seconds ago, saying: applicative, precisely my problem! I am thinking of wrapping T in (m T) then defining the function once for T, then on a type-class for both T' m and G m
20:27:10 <lispy> xcthulhu: yes, is addition in the reals even computable assuming you have to use a fixed number base?
20:27:13 <napping> Ah, that would be the problem!
20:27:14 * ivanm will let dibblego handle this
20:27:23 <lispy> xcthulhu: I was wondering about this the other day.
20:27:28 <ivanm> tolkad: so this is what I was asking befoer: does each instance constrain which Real instance it returns?
20:27:29 <napping> well, that and reading type signatures
20:27:42 <mm_freak_> lispy: yampa uses an arrow and its 'reactimate' function (used to run the reactive system) is stuck in the IO monad
20:27:48 <ivanm> tolkad: do you want the f in the T instance return a Double, or a Real?
20:28:01 <Cale> mm_freak_: We're using (a modified version of) Yampa for the game we're working on.
20:28:01 <ivanm> tolkad: Haskell's type classes aren't like Java's inheritance stuff
20:28:08 <napping> tolkad: you want a type that means something like (you can't actually write this) exists b . (Real b) => a -> b
20:28:09 <tolkad> ivanm: uh yeah, each instance can return any Real instance it likes, but each one always returns the same instance
20:28:09 <ivanm> Cale: you're working on a game? :o
20:28:10 <applicative> koninkje, I take it you noticed  System-Environment-UTF8 on hackage.  I'm not sure what your purpose is.  
20:28:21 <mm_freak_> Cale: how do you encode application state in yampa?
20:28:23 <lispy> Cale: you're working on a game?  Wonderful.  How is it going?  What is it about?
20:28:25 <tolkad> napping: yeah
20:28:27 <napping> tolkad: that is, all you promise the caller is that you are going to give them *some* instance of Real
20:28:31 <ivanm> Cale: that sounds like a rather "practical" thing for you :p
20:28:38 <koninkje> applicative: I was just hoping to use ByteStrings throughout. It's no big deal
20:28:38 <mm_freak_> hehe
20:28:43 <ivanm> tolkad: *sigh* then use MPTCs+fundeps or an associated type
20:28:45 <tolkad> napping: yeah, exactly like Java interfaces
20:28:48 <ivanm> like I said
20:28:50 <Cale> mm_freak_: Also, the AFRP library that frag has is basically Yampa.
20:28:52 <napping> tolkad: the first is more like -- hmm, <A extends Real> A foo()
20:29:00 <napping> or however the java generics go
20:29:16 <ddarius> napping: I much prefer C#'s syntax.
20:29:25 <napping> ddarius: oh, what's that?
20:29:32 <applicative> koninkje, yeah, it just does the obvious as a convenience. I wonder if there is a technical reason why there isn't a Bytestring version
20:29:36 <ddarius> A foo<A : Real>().
20:29:38 <napping> I've just been reading about Scala, which seems to be reasonably nice?
20:29:47 <ddarius> It does have the quirk that its binder scopes both ways.
20:29:50 <deech> Hi all, I am trying to understand the "join" function. From the type sig. it seems to remove one monadic layer. Why is such a function necessary?
20:29:50 <napping> very much an explicit type passing thing[]
20:29:51 <Cale> lispy: http://ipwnstudios.com/bloodknight/
20:30:07 <lispy> Cale: I had no idea you joined the team for ipwn
20:30:14 <ddarius> deech: Define "necessary."
20:30:21 <napping> deech: It's kind of that other way - having such a thing is what defines a monad
20:30:26 <ivanm> deech: because you might wish to remove a monadic layer?
20:30:29 <ddarius> lispy: You're not keeping up with #haskell news.
20:30:30 <xcthulhu> lispy, it's hard to say.  If you're representing real numbers with Cauchy sequences addition would be computable.  A cauchy sequence is just c :: Integer -> Rational, and so (c + d) x = (c x) + (d x) in this case.
20:30:33 <tolkad> this is like interface Real {/* addition, subtraction etc. functions*/} interface C {Real f();} class Double extends Real {/* implementation of Real functions */} class CReal extends Real {/* implementation of Real functions */}
20:30:35 <ivanm> napping: well, that's one way of defining a monad
20:30:36 <Cale> mm_freak_: Well, basically the same way you'd encode state in any game? One difference is that signal functions carry state with them as they run.
20:30:47 <ivanm> ddarius: heh did? :o
20:30:49 <napping> deech: or perhaps I should take that asking why "join" is ever useful?
20:30:49 <ivanm> when?
20:30:59 <systemfault> If i have a list of word, i would like to use intersperse with ", " but use " and " before the last element, how would I do that?
20:31:00 <napping> deech: really, >>= is much more often what you want to call
20:31:03 <ivanm> I know that blackh is, and he's been hacking on related stuff at AusHac...
20:31:08 <deech> napping: yes, I don't see an application.
20:31:13 <napping> tolkad: oh, we don't have inheritance
20:31:18 <lispy> ddarius: I guess not
20:31:22 <napping> tolkad: subtyping fucks up a lot of stuff
20:31:22 <tolkad> err not extends
20:31:24 <ivanm> deech: I've used it at times to remove a Maybe layer
20:31:24 <mm_freak_> Cale: so your reactive system is of type SF Config Config or something like that?
20:31:25 <tolkad> I meant implements
20:31:30 <xcthulhu> lispy, On the other hand, if your representation was, say, continued fractions... well, God help you.
20:31:34 <systemfault> How would I detect that it's the last element ?
20:31:34 <tolkad> this is like interface Real {/* addition, subtraction etc. functions*/} interface C {Real f();} class Double implements Real {/* implementation of Real functions */} class CReal implements Real {/* implementation of Real functions */}
20:31:47 <ivanm> deech: it's not necessary in the sense that a lot of times you can do it by hand, but it's handy to be able to do it in the arbitrary sense
20:31:49 <applicative> deech. like they said, the crucial thing that makes a functor a monad is that you can crush down the pileups so you can go from IO IO IO IO IO Char to IO Char
20:31:54 <ivanm> and things like IO aren't pattern-matchable
20:31:57 <lispy> xcthulhu: Ah, I hadn't thought about using Cauchy sequences...yes that's interesting
20:31:59 <napping> tolkad: the equivalent of a variable typed as an existential in Java is making a little box types like data AnyReal = forall t . (Real t) => C t
20:32:09 <ivanm> Cale: when did you join ipwn?
20:32:18 <tolkad> napping: oh, thanks, I'll use that
20:32:20 <napping> tolkad: but without escapes like runtime casting and whatever methods Object has, you can't do much with a thing in the box
20:32:25 <xcthulhu> lispy, Do you know about Baire space?
20:32:35 <Cale> ivanm: Several weeks ago
20:32:38 * applicative read "join ipwn" as a fragment of Haskell
20:32:43 <ddarius> tolkad: Yes and Haskell types and classes don't correspond to that.  Though there are ways to get the effect to varying degrees.
20:32:45 <ivanm> applicative: lol
20:32:57 <ivanm> Cale: sick of academia or just wanted to try something different?
20:33:05 <lispy> xcthulhu: In my adventures through real analysis I made it to the introduction to measurability and that was half a decade ago or more.  So, it doesn't sound familiar.
20:33:07 <tolkad> napping: "Not a data constructor: `forall'"
20:33:09 <ddarius> ivanm: Sick of no money.
20:33:16 <tolkad> napping: "Perhaps you intended to use -XExistentialQuantification"
20:33:17 <ivanm> heh
20:33:17 <Cale> ivanm: ddarius has it :)
20:33:18 <napping> tolkad: RankNTypes, I think?
20:33:24 <tolkad> napping: I guess I have to use that extension to make it work
20:33:26 <deech> applicative: I see. I just saw it in the ConfigParser package docs and was a little thrown. 
20:33:28 <napping> ah, there you go.
20:33:35 <Cale> ivanm: I wasn't actually in academia. I was studying various things on my own.
20:33:43 <ivanm> oh
20:33:45 <Cale> (I only have a BMath)
20:33:48 <ivanm> :o
20:33:53 * ivanm faints
20:33:56 <deech> In the "x <- join $ liftIO $ ..." context
20:34:00 <tolkad> napping: "Couldn't match expected type `AnyReal' against inferred type `Double'"
20:34:05 <tolkad> napping: your code doesn't work
20:34:09 <lispy> Yeah, Cale is grossly uneducated and clearly his input here is overrated ;)
20:34:10 <ivanm> Cale: you just crushed my hopes and dreams... :p
20:34:17 <napping> tolkad: you have to wrap a Double into an AnyReal like (C d)
20:34:31 <napping> tolkad: and also pattern match on the other end, and you won't know anything at all about the type you get out
20:34:31 * lispy thinks of Cale  like a good will hunting
20:34:46 <Cale> ivanm: It's not so hard to study things outside of academia, once you know how to study.
20:34:49 <ivanm> napping: even then, how would you add a Double and a FLoat wrapped in a AnyReal?
20:34:53 <ddarius> ivanm: How so?
20:34:55 <tolkad> napping: "Not in scope: data constructor `AnyReal'"
20:34:55 <napping> ivanm: you can't
20:34:57 <geheimdienst> could we judge cale not by the color of his robes but by the content of his character plz?
20:35:02 <lispy> "I just learn it on my own...it's easy.  Nuclear physics?  no problem.  All of category theory?  Yeah, easy.  Haskell?  *yawn*"
20:35:06 <ivanm> Cale: well, yes, except for time-wise
20:35:08 <ddarius> ivanm: (re "hopes and dreams")
20:35:10 <xcthulhu> lispy, Baire space is a topology on the functions "Integer -> Integer" that gets a lot of mileage by computer scientists who flirt with measure theory
20:35:13 <geheimdienst> content of his head
20:35:14 <mm_freak_> Cale: the problem i have is this:  i /could/ write my whole app using FRP, but the more state i introduce, the less FRP-like it feels
20:35:19 <ivanm> napping: so this isn't going to do what tolkad wanted anyway ;-)
20:35:19 <koninkje> geheimdienst++
20:35:22 <napping> tolkad: that's the type name - the constructor I wrote was just C
20:35:27 <mm_freak_> in other words:  it feels like i could have written the same without FRP in almost the same words
20:35:30 <ddarius> lispy: It is easy.
20:35:35 <ivanm> ddarius: nah, not really; I just thought that Cale was finishing off a PhD or something
20:35:41 <applicative> deech, i use join a lot because of my silly preference for fmap and <$> over monadic operators.  So e.g. join $ writeFile "backward.txt" <$> readFile "forward.txt"
20:35:45 <xcthulhu> lispy, Nat -> Nat (sorry)
20:35:53 <napping> tolkad: perhaps I should warn you again that this is neither idiomatic, nor useful
20:36:04 <mm_freak_> the only difference being that i would multiply each change by the time difference
20:36:04 <xcthulhu> lispy, I've heard theoreticians pronounce to me that it is the "the true" representation of the reals...
20:36:12 <lispy> xcthulhu: I see.  Yeah, I should probably dust off my books and learn measure theory better.
20:36:13 <tolkad> oh
20:36:13 <tolkad> thanks
20:36:13 <tolkad> napping: "No instance for (Show AnyReal)"
20:36:13 <tolkad> oh I have to get it out
20:36:13 <tolkad> I see
20:36:20 <applicative> sorry,  join $ writeFile "backward.txt" . reverse <$> readFile "forward.txt"
20:36:28 <ivanm> tolkad: except that with a forall, you can't really get it out...
20:36:31 <xcthulhu> lispy, Nah.  Are you into category theory?
20:36:38 <Cale> mm_freak_: Well, if you look at it one way, FRP is a mechanism for managing state while doing incremental computation of a bunch of things.
20:36:40 <ivanm> since you've lost what type it initially was
20:36:48 <napping> tolkad: It's sort of describing how to bodge together something with classloaders and bytecode generation if I really insisted I wanted to make Java do something
20:36:49 <ddarius> "The true representation" is an oxymoron.
20:37:02 <lispy> xcthulhu: not as of yet.  I know only what you need for haskell.  Which is to say, I look up the monad/functor laws when curious and ignore them otherwise :)
20:37:03 <napping> ddarius: sounds like *you* are into category theory :)
20:37:13 <ddarius> napping: That's well known.
20:37:36 <Cale> mm_freak_: If you simplify it a bit, Yampa basically works like this:  newtype Circuit a b = Circuit { runCircuit :: a -> (Circuit a b, b) }
20:37:39 <monochrom> the honest liar paradox and the true representation dilemma
20:38:13 <tolkad> WTF this error message makes no sense at all: Inferred type is less polymorphic than expected Quantified type variable `t' escapes When checking an existential match that binds x :: t The pattern(s) have type(s): AnyReal The body has type: t In the definition of `fromAnyReal': fromAnyReal (AnyRealC x) = x
20:38:14 <xcthulhu> lispy, Well... you might check out this book: http://books.google.com/books?id=ieq6WXOOcIcC
20:38:33 <mm_freak_> Cale: hmm, okâ€¦  but then is it really worth introducing the additional dependency and performance penalty?
20:38:37 <napping> tolkad: yeah, it's kind of a pain to work with those things
20:38:37 <ddarius> tolkad: You can make an instance for the various classes that just delegates into the internal representation BUT you will run into the binary method problem (from OO.)
20:38:49 <tolkad> napping: maybe this is a haskell bug
20:38:50 <napping> tolkad: you have no idea what value you are getting out, after all
20:39:03 <napping> what could the return type possibly be?
20:39:05 <Cale> mm_freak_: Where the result of runCircuit on some circuit and input value of type a is a new circuit (which contains your state) and an output value of type b
20:39:15 <lispy> xcthulhu: yes I might.  Thanks for the link.  Lately I've been interested in continuations.  Does that book have anything for me in that area?  They mention concurrency theory and transition systems.
20:39:16 <xcthulhu> lispy, This is a coalgebraic perspective on measure.  It's crazy theoretical but I'd say that this sort of approach is more appropriate to thinking about Haskell than more old-fashioned analysis
20:39:24 <Cale> mm_freak_: I don't know what you mean by performance penalty.
20:39:30 <napping> It would have to be "something that I don't know what type it is except that whatever type it is is an instance of Real"
20:39:32 <tolkad> napping: well I know it's an instance of Real, so I know it's an instance of Num, so I know it's an instance of Show so I should be able to call show on it
20:39:39 <napping> tolkad: right, and then return show
20:39:47 <napping> so, showAnyReal (AnyReal x) = show x
20:39:49 <napping> that works fine
20:40:06 <tolkad> napping: but it's easier to have this function to grab x out of the anyreal
20:40:11 <ivanm> is this some kind of weird GHC pragma? it's in the definition of words: {-partain:Char.-}
20:40:11 <ivanm> tolkad: *sigh* why won't you just accept that what you want doesn't really make sense?
20:40:19 <napping> tolkad: but again, what is the return type?
20:40:20 <mm_freak_> Cale: running a complicated FRP system is probably going to be slower than writing an explicit application loop with explicit time management, isn't that true?
20:40:25 <xcthulhu> lispy, Not as such.  The abstract study of continuations, in a categorical setting, falls more under "Domain Theory" and Coalgebra
20:40:25 <ddarius> xcthulhu: Coalgebraical approaches are often more useful for Computer Scientists than traditional representations.
20:40:26 <tolkad> napping: I don't care
20:40:31 <mm_freak_> Cale: for example if you have thousands of particles interacting
20:40:31 <tolkad> napping: I didn't give it one
20:40:44 <xcthulhu> ddarius, :D
20:40:52 <napping> tolkad: try writing f b = if b then "Hello" else False
20:41:06 <ivanm> napping: *shudder*
20:41:18 <ddarius> xcthulhu: Have you looked at J. J. M. M. Rutten's coalgebra stuff?
20:41:20 <napping> Haskell has types, it just tries to figure them out if you don't write them
20:41:21 <xcthulhu> ddarius, Well, for another thing, I can tell you that in Isabelle/HOL and HOL-Light nobody even uses the Lebesgue integral, since the guage integral is more general
20:41:21 <tolkad> > f b = if b then "Hello" else False
20:41:22 <lambdabot>   <no location info>: parse error on input `='
20:41:25 <Cale> mm_freak_: Don't get me wrong, Yampa has lots of problems. But performance wouldn't be at the top of my list. You'll do about as well as you would with any mechanism written in Haskell.
20:41:27 <tolkad> @let f b = if b then "Hello" else False
20:41:28 <lambdabot>  <local>:1:29:
20:41:29 <lambdabot>      Couldn't match expected type `[Char]' against inferred ty...
20:41:53 <napping> well, an AnyReal could have a Double or a Rational or other stuff
20:41:57 <Cale> mm_freak_: The main problem with Yampa is that it basically forces you to write your code as the geometric dual of the actual code that you'd like to write.
20:41:59 <geheimdienst> @instances Arrow (,)
20:41:59 <tolkad> hmm, does haskell have a class like Javas "Object" class?
20:41:59 <lambdabot> Couldn't find class `Arrow (,)'. Try @instances-importing
20:42:04 <geheimdienst> @instances Arrow (->)
20:42:05 <lambdabot> Couldn't find class `Arrow (->)'. Try @instances-importing
20:42:11 <xcthulhu> ddarius, Nope... I came into it from modal logic so I've only read my Prof's stuff on it so far
20:42:13 <geheimdienst> > :t Arrow (->)
20:42:14 <lambdabot>   <no location info>: parse error on input `:'
20:42:15 <napping> so it's going to be at least as much trouble to try to return the x directly
20:42:19 <napping> tolkad: no, it doesn't
20:42:20 <tolkad> napping: doesn't haskell have a class like Javas "Object" class?
20:42:21 <lispy> Cale: So, do we "like" structures like Circuit because they are open recursion in a monadic form?
20:42:22 <Cale> mm_freak_: You can't give names to signals, only to signal transformers.
20:42:23 <tolkad> napping: why not?
20:42:25 <geheimdienst> :t Arrow (->)
20:42:26 <lambdabot> parse error on input `->'
20:42:30 <napping> tolkad: cause it breaks lots and lots of stuff
20:42:39 <xcthulhu> ddarius, Any good reading you can recommend?
20:42:45 <napping> like, you know id can't screw around with your values
20:42:47 <mm_freak_> Cale: yes, but actually i like that concept
20:42:58 <mm_freak_> at least yet, because i haven't done anything serious with it
20:43:04 <lispy> Cale: it seems like that same structure comes up again and again.  Iteratees are very similar to that.
20:43:19 <mm_freak_> Cale: why do you use yampa?  what about the other alternatives?
20:43:41 <Cale> mm_freak_: There are not many other alternatives which are really practical, unfortunately.
20:43:43 <napping> tolkad: anyway, the proper description of the "x" you want to return is "Some type that's an instance of Real"
20:44:12 <Cale> mm_freak_: Once we get this game out, we'll start taking a look at FRP in general, and see if we can't come up with something nicer.
20:44:22 <napping> You might like to write that (exists t . (Real t) => t)
20:44:29 <mm_freak_> tolkad: a value of the "Object" type in java would best correspond to a value of type 'a' in haskell
20:44:33 <tolkad> napping: so... (Real x) => AnyReal -> x
20:44:36 <mm_freak_> i.e. no classes at all
20:44:45 <napping> tolkad: no, that's completely the wrong way
20:44:47 <ivanm> tolkad: because Haskell isn't an OO language
20:45:00 <tolkad> napping: but I'm casting x to a real
20:45:01 <napping> tolkad: that lets the *caller* decide what instance of Real they want back
20:45:07 <lispy> Cale: actually, maybe open recursion is a different meaning than I meant to give it.
20:45:14 <napping> you can't cast x to a real
20:45:31 <tolkad> but I know it's an instance of real, I want to cast to a more generic type
20:45:45 <napping> ??
20:45:51 <napping> I don't really understand what that means
20:46:06 <tolkad> like in Java: Number num = new Integer(5);
20:46:08 <napping> even in Java there's no particular relationship between classes that implement an interface
20:46:10 <ddarius> http://homepages.cwi.nl/~janr/papers/  The stuff on Behavioral Differential Equations is interesting though you'll likely find many other interesting things.  Bart Jacobs, a collaborator of Rutten's, also has quite a few papers on coalgebra applied to modal logic. http://www.cs.ru.nl/B.Jacobs/PAPERS/index.html  See around the late '90s and early 2000.
20:46:17 <mm_freak_> tolkad: try to understand why there is no defined function of type 'a -> b'
20:46:28 <mm_freak_> and why there is only one defined function of type 'a -> a'
20:46:34 <napping> the only thing that ties them together is that you can also make variables labled by the interface type IFoo
20:46:53 <napping> tolkad: but all that really is, is some kind of box that can hold values of any particular type that implements the interface
20:47:15 <tolkad> napping: yes but you can have a generic object of class/interface Number, and call any Number functions on it without know what specific class it is
20:47:22 <napping> In Haskell you have to define a wrapper like that yourself rather than having it built into the JVM, and for Real it will be a type like that AnyReal I made
20:47:25 <Cale> tolkad: Perhaps you're looking for Data.Dynamic?
20:47:40 <napping> Cale: we've mentioned enough evil stuff already!
20:47:42 <Cale> :t Data.Dynamic.toDyn
20:47:43 <lambdabot> forall a. (Typeable a) => a -> Dynamic
20:47:48 <Cale> :t Data.Dynamic.fromDyn
20:47:49 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
20:47:54 <Cale> :t Data.Dynamic.fromDynamic
20:47:55 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
20:47:57 <xcthulhu> ddarius, sweet.  But to be honest, I'm really very sick of modal logic and the diff-eq stuff looks more exciting
20:48:18 <napping> Cale: why don't you just suggest calling unsafeCoerce# wherever the compiler complains about types matching!?!?!
20:48:23 <ddarius> xcthulhu: I never got into modal logic very much, though I do find contextual modal type theory very interesting.
20:48:27 <Cale> napping: huh?
20:48:33 <Cale> napping: Dynamic is safe.
20:48:40 <mm_freak_> Cale: the input type of SF should really correspond to system input, i.e. WM events and keyboard presses?
20:48:43 <ddarius> xcthulhu: Bart Jacobs has plenty of other interesting papers.  His PhD thesis is good if somewhat brutal.
20:48:53 <mm_freak_> Cale: or am i getting that wrong?
20:48:56 <Cale> mm_freak_: It corresponds to lots of stuff
20:49:04 <ddarius> Cale: tolkad thinks that Haskell is Java
20:49:06 <napping> Cale: I'm trying to explain the distinction between (Real a) => T -> a
20:49:19 <napping> being a universal type that has to work for any Real a
20:49:31 <Cale> napping: Okay.
20:49:45 <xcthulhu> ddarius, Dutch PhD theses are often brutal.  That's the culture I'm afraid
20:49:45 <napping> and a pretend Javaish T -> Real being an existential that hides some particular instance of Real the caller doesn't know about
20:49:51 <Cale> napping: I was responding to the question about whether there's an analogue of Java's Object type.
20:50:15 <napping> Cale: as a question about the type system, not at all
20:50:27 <Cale> napping: Dynamic sort of fills the same purpose.
20:50:33 <ddarius> napping: Really the different thing between Haskell and Java in the Number n = new Double(3) example is Haskell doesn't have implicit "up-casts" so you have to explicitly inject the "subtype" into the "supertype"
20:50:35 <napping> as a common supertype?
20:50:45 <mm_freak_> Cale: but it's sufficient to encode the application state in the output type, right?
20:50:47 <Figs_> Hello
20:50:52 <ddarius> There is no analog to Java's Object type.  Period.
20:50:54 <Cale> In that you can cast upward to it from any Typeable type, and then back down with one of fromDyn or fromDynamic
20:51:01 * ivanm waves idly in Figs_'s general direction
20:51:08 <napping> ddarius: ah, the fan of category theory things all this super and subtyping stuff is really just a question of injection functions :)_
20:51:28 <Figs_> Is there a case insensitive version of parsec's "string" parser?
20:51:31 <koninkje> xcthulhu: that'd explain why all the Dutch phd's I've read have been awesome
20:51:33 <Cale> mm_freak_: A lot of state ends up in betweeen -- in fact, it can be a bit tricky memory-wise in that way.
20:51:36 <napping> who cares if something is really a subset as long as it works up to ismorphism :)
20:51:42 <mm_freak_> ddarius: a haskell value of type 'a' would correspond to a java value of type Object, but only very remotely
20:51:42 <ivanm> Figs_: you can probably write one...
20:51:53 * ivanm has done that using PolyParse
20:52:02 <Cale> mm_freak_: Each SF a b in your program, as it runs, may be accumulating state on its own.
20:52:06 <ddarius> mm_freak_: A Haskell value of type String would also correspond to Object, quite a bit less remotely, but still quite remotely.
20:52:09 <tolkad> wait if I'm using Data.Dynamic what should the type signature for f be? the one I want to be (Real b) a -> b
20:52:21 <tolkad> wait if I'm using Data.Dynamic what should the type signature for f be? the one I want to be (Real b, C a) => a -> b
20:52:32 <napping> tolkad: please don't use that. It's going to confuse the issue even more
20:52:42 <mm_freak_> tolkad: i have the impression that you're trying to write java in haskell
20:52:43 <Cale> mm_freak_: For example, there's an SF a [a] which gives as its results the lists of inputs seen so far.
20:52:52 <ddarius> napping: Subtyping doesn't have anything to do with subsets in type theory.
20:52:54 <xcthulhu> mm_freak_, It's not really possible to have a type (a -> b) -> c in Java
20:53:15 <mm_freak_> tolkad: you should try to understand the concept firstâ€¦  it is very different from java, and it is /not/ object oriented
20:53:17 <napping> ddarius: I think there's a bit of a difference between a canonical subtype relation, and arbitrary sets of injection functions
20:53:28 <Cale> mm_freak_: Let's use that Circuit type since it's close enough to Yampa, but without the silly built-in time stuff.
20:53:37 <ivanm> xcthulhu: oh, so there is _some_ sanity in Java's type system? :p
20:53:37 <napping> tolkad: if you want to work with an AnyReal, you have to box it back up when you are done anyway
20:53:40 <ddarius> napping: I agree hence the scare quotes.
20:53:52 <tolkad> @faq can I have write instances for class C a where f :: (Real b) a -> b
20:53:52 <lambdabot> The answer is: Yes! Haskell can do that.
20:54:03 <tolkad> @faq can I write instances for class C a where f :: (Real b) a -> b
20:54:03 <geheimdienst> guys, what was that trick again to apply a function to the snd of a tuple?
20:54:04 <lambdabot> The answer is: Yes! Haskell can do that.
20:54:05 <xcthulhu> ivanm, Not really.  Just no function passing.
20:54:20 <napping> geheimdienst: there may be a Functor instance on tuples
20:54:21 <xcthulhu> Well, there sort of is but it's horrible
20:54:38 <napping> tolkad: could you write a java function foo(Number x) {return x;}
20:54:43 <tolkad> napping: I didn't like that solution it was annoying, I'm trying to use this Data.Dynamic thing that supposedly works around the bug
20:54:47 <napping> with any return type but Number of Object?
20:54:49 <geheimdienst> yeah, i think it was some Functor witchcraft
20:54:53 <Cale> mm_freak_: Actually, #haskell-overflow :)
20:54:57 <xcthulhu> object passing doesn't really count
20:54:58 <geheimdienst> > fmap (+1) (1, 2)
20:54:59 <lambdabot>   (1,3)
20:55:07 <geheimdienst> it's a bingo!
20:55:10 <geheimdienst> thanks napping :)
20:55:11 <tolkad> napping: you can't have exclusive types
20:55:16 <napping> ??
20:55:21 <napping> "exclusive types"?
20:55:24 <tolkad> napping: types that exclude some class I mean
20:55:42 <napping> I have never heard of these before
20:55:50 <tolkad> napping: that's because they don't exist
20:55:59 <tolkad> napping: which is why I said you can't have them
20:56:12 <napping> ok, then why did you mention them? I don't think I mentioned them
20:56:12 <mm_freak_> hmm
20:56:22 <tolkad> napping: <napping> with any return type but Number of Object?
20:56:26 <mm_freak_> IMO if you write real haskell code, you never need Data.Dynamic
20:56:31 <ivanm> geheimdienst: second
20:56:31 <ivanm> > second succ ("Hi", 2)
20:56:31 <ivanm> lambdabot: wakey, wakey
20:56:31 <ivanm> geheimdienst: it's Control.Arrow.second
20:56:32 <lambdabot>   ("Hi",3)
20:56:32 <ivanm> oh, right, it works with the fmap instance
20:56:32 * ivanm sticks to using second
20:56:35 <ivanm> not sure if it's possible...
20:56:37 <napping> tolkad: Ah, I meant Number foo(Number x) {return x;} works
20:56:44 <napping> tolkad: and Object foo(Number x){return x;} works
20:56:46 <geheimdienst> > fmap (:[]) (1, 2)
20:56:47 <lambdabot>   (1,[2])
20:57:29 <napping> tolkad: but I don't know what else you could write, at least if Number is an interface with no superinterface
20:57:31 <tolkad> > third (1, 2, 3)
20:57:32 <lambdabot>   Not in scope: `third'
20:57:45 <tolkad> @let third (a, b, c) = c
20:57:47 <lambdabot>  Defined.
20:57:54 <tolkad> > third (1, 2, 3)
20:57:55 <lambdabot>   3
20:58:05 <tolkad> @let fourth (a, b, c, d) = d
20:58:06 <lambdabot>  Defined.
20:58:16 <tolkad> @let fifth (a, b, c, d, e) = e
20:58:17 <lambdabot>  Defined.
20:58:24 <mm_freak_> tolkad: that 'third' is different from 'first' and 'second'
20:58:30 <mm_freak_> its the continuation of 'fst' and 'snd'
20:58:37 <tolkad> @let first (a) = a
20:58:39 <lambdabot>  Defined.
20:58:46 <tolkad> @let second (a, b) = b
20:58:47 <lambdabot>  Defined.
20:58:49 <tolkad> mm_freak_: fixed
20:58:55 <napping> tolkad: How about I show you some code that might be useful?
20:58:56 <geheimdienst> woah. you know, i actually checked the Control.Arrow haddock before i asked. maybe my haskell-fu is improving. still, i didn't see second can be used for that
20:59:06 <ddarius> @undefine
20:59:24 <geheimdienst> @let umpteenth = last
20:59:25 <lambdabot>  Defined.
20:59:34 <geheimdienst> > umpteenth [1,2,3,4,5]
20:59:35 <lambdabot>   5
20:59:37 <ivanm> @undefine
20:59:44 <mm_freak_> tolkad: uhm
20:59:44 <ivanm> tolkad: fst and snd?
20:59:49 <mm_freak_> don't redefine first and second
20:59:51 <xcthulhu> Lists are very different than tupples
20:59:58 <ivanm> if you really want that kind of stuff, see the tuples package
21:00:24 <xcthulhu> *tuples
21:00:34 <geheimdienst> xcthulhu, yes but my haskell-fu is too weak to write a function that returns the last of a 100-tuple
21:00:46 <aavogt> you can use some template haskell
21:00:48 <ddarius> geheimdienst: There are no 100 tuples anyway.
21:00:52 <tolkad> @let type [x] = (x)
21:00:52 <lambdabot>   Illegal test declaration
21:00:56 <tolkad> 0_o
21:01:14 <aavogt> their types exist apparently
21:01:23 <tolkad> that should have worked
21:01:30 <aavogt> tolkad: type is a keyword
21:01:31 <ddarius> tolkad: No it shouldn't have.
21:01:52 <mm_freak_> > (first (+1) >>> second (+3)) (10,10)
21:01:53 <lambdabot>   (11,13)
21:01:54 <tolkad> aavogt: yeah i know I was using it
21:01:56 <napping> tolkad: here, i pasted something
21:02:09 <napping> tolkad: needs FunctionalDependencies
21:02:17 <napping> does that look like what you want?
21:02:33 <lispy> Cale: this is another example of that structure, except its at the type level: http://martijn.van.steenbergen.nl/journal/2010/06/24/generically-adding-position-information-to-a-datatype/
21:03:09 <napping> tolkad: (added to your pasge) http://pastebin.com/uwqP7gXe
21:03:19 <Cale> lispy: Well, recursive datatypes are useful :)
21:03:54 <lispy> Cale: it's true, but I think this particular pattern of their use is more common than some of the othrs
21:04:10 <lispy> Cale: It's the same shape as a parser
21:04:10 <Figs_> In case anyone's curious in the future, I found a case insentive string parse in hsemail.
21:04:20 <Figs_> http://hackage.haskell.org/packages/archive/hsemail/1.3/doc/html/Text-ParserCombinators-Parsec-Rfc2234.html
21:04:28 <tolkad> napping: where'd T come from?
21:04:41 <ivanm> mm_freak_: why not just use *** ?
21:04:45 <napping> tolkad: oh, oops, forgot to fix that. 
21:04:55 <napping> tolkad: I seem to have renamed your T to Approx
21:05:15 <aavogt>     A 63-tuple is too large for GHC
21:05:16 <aavogt>       (max size is 62)
21:05:33 <ddarius> aavogt: Did you think I was lying?
21:05:34 <djahandarie> I don't know how edwardk manages to find every single blog post semi-related to anything in category-extras and post in it
21:05:36 <napping> aavogt: really? I thought it was 97, for some reason
21:05:47 <ddarius> djahandarie: Everything is related to category theory.
21:05:47 <napping> Show and Eq stop being provided a bit earlier
21:05:54 <ddarius> djahandarie: Everything is a monoid too.
21:06:16 <djahandarie> ddarius, making that task even more difficult :P
21:06:16 <tolkad> napping: I thought that's using MultiParameterTypeClasses
21:06:19 <aavogt> ddarius: I wasn't sure what the limit was
21:06:23 <napping> tolkad: oh, that too
21:06:23 <ddarius> Where "a bit" is way, way earlier.
21:07:41 <mm_freak_> ivanm: because (***) hides 'first' and 'second'
21:07:53 <mm_freak_> it should demonstrate that 'first' and 'second' are not 'fst' and 'snd'
21:08:05 <ivanm> oh, you were just demonstrating them?
21:09:23 <napping> tolkad: I added all the bits to make it work
21:13:14 <tolkad> napping: I also needed XTypeSynonymInstances
21:13:35 <napping> tolkad: thought I included that when I added the LANGUAGE pragma
21:13:41 <napping> didn't remember Rational was a type sysnonym
21:15:06 <napping> anyway, every caller of f knows that they will get back a Real
21:15:22 <napping> they don't necessarily know which one, but at some calls it might be obvious
21:16:30 <edwardk> djahandarie: i read a lot of blogs ;)
21:16:53 <tolkad> napping: I get a bunch of errors when I try this: http://pastebin.com/AA6kJreN
21:17:13 <tolkad> oh wait I see why I made a typo
21:17:31 <napping> tolkad: um, * only works between the same types
21:17:58 <tolkad> I fixed it: http://pastebin.com/Fi0VQ3Em
21:18:01 <napping> however, mult :: (C a r, C b r) => a -> b -> r; mult a b = f a * f b
21:18:09 <tolkad> I used * because I want to multiply them
21:18:27 <tolkad> how should I write mult?
21:18:35 <napping> what do you want to do?
21:18:43 <tolkad> multiply them
21:18:46 <napping> There's no guarantee it makes sense to multiply them
21:18:57 <tolkad> of course it does, you can multiply an two real numbers
21:19:02 <tolkad> any two*
21:19:23 <napping> hmm, is that what Real actually means?
21:19:40 <tolkad> napping: it means they are real numbers
21:20:43 <napping> and which form do you want the result in?
21:21:11 <napping> that's certainly not what (*) does
21:22:26 <napping> how about switching to RealFrac
21:23:12 <napping> Where did you fix the typo?
21:23:42 * hackagebot interpolatedstring-qq-mwotton 0.1.1 - DO NOT USE THIS. interpolatedstring-qq works now.  http://hackage.haskell.org/package/interpolatedstring-qq-mwotton-0.1.1 (MarkWotton)
21:24:20 <ivanm> yay, tolkad has gone!!!
21:26:33 * geheimdienst is scared what people say when he leaves. but he'll never know.
21:26:41 <tolkad> I got disconnected because my router suddenly and temporarily ceased working...
21:26:42 <napping> not true! You can check the logs
21:26:56 <tolkad> napping: ?
21:26:57 <napping> unless you mean you'll never know because you don't want to check
21:27:10 <napping> tolkad: that was @ geheimdienst 
21:27:12 <Figs_> geheimdienst: Well, you could check the logs...
21:27:20 <napping> tolkad: I asked you where you fixed typos?
21:27:36 <tolkad> napping: I had a b instead of a c in the type signature for mult
21:27:41 <napping> anyway, you might try leaving the typeclasses for later
21:27:42 <Saizan> geheimdienst: there are public logs
21:27:53 <tolkad> so, anyway, I think I understand how all this works now... you can't do encapsulation the way you are supposed to in OOP
21:27:54 <Saizan> i guess i'm the third..
21:28:17 <Figs_> Yeah, we got beat even though we weren't napping...
21:28:32 <tolkad> it's completely backwards though, instead specifying the most generic type possible you specify the most specific
21:28:45 <ivanm> tolkad: strangely enough, FP /= OOP
21:28:58 <napping> well, some things are backwards. objects are essential coalgebraic, data algebraic
21:29:19 <napping> (that's math for "stuff is backwards")
21:29:42 <dolio> Haskell's data is both.
21:29:57 <napping> (and the position of the "co" means it's the OO one that's backwards)
21:30:02 <napping> ;)
21:30:09 <tolkad> even though this stuff is annoying, there's much more annoying stuff in OOP
21:31:22 <tolkad> like http://en.wikipedia.org/wiki/Multiple_dispatch#Java
21:31:49 <napping> tolkad: anyway, your example is just too simple
21:33:10 <napping> your C only has a way to pull a number of the thing - for all I know your real "f" is going to be something like "length" on data structures, there's not enough stuff to suggest it should even make sense to multiply two values from the same instance of C
21:33:18 <ivanm> OK, can anyone else confirm for me that when using haskell-mode for emacs with the new indentation stuff, the indenter chucks a hissy fit if you try giving a method a default definition using guards?
21:33:36 <dolio> That rings a bell.
21:33:40 <Figs_> Is there a way to force parsec to backtrack by default?
21:34:15 <ivanm> Figs_: nope
21:34:18 <ivanm> use polyparse for that
21:35:02 <ivanm> Figs_: see the fifth paragraph here: http://www.cs.york.ac.uk/fp/polyparse/#how
21:35:45 <napping> Figs_: there is "try" for limited backtracking
21:37:34 <Figs_> napping: The main issue is that I would have to add 'try' to basically everything, and it seems to be getting used internally in places I wasn't expecting, so I'm getting things where parsing "wtf" matches "w" and says the "t" was unexpected, rather than matching the second choice (case-insensitive "wtf")
21:38:11 <geheimdienst> > intercalate " " ["abc", "def"]
21:38:12 <lambdabot>   "abc def"
21:38:32 <Figs_> ivanm: I'll take a look, thanks.
21:39:56 <napping> Figs_: parsec is not good for ambigous grammars. If it's more lexical things like tokens overlapping keywords there are decent solutions
21:40:00 <ivanm> Figs_: note that polyparse doesn't have a lot of pre-defined combinators though
21:40:24 <ivanm> and IMHO, the definition of bracket for the lazy parser is wrong
21:40:44 <napping> case insensitive should be like ('w'<|>'W')>>('t'<|>'T')>>('f'<|>'F'), for example
21:41:04 <Figs_> napping: already solved case insensitive using caseString from hsemail
21:41:46 <ivanm> napping: ugh
21:42:03 <ivanm> doesn't parsec have something similar to polyparse's satisfy combinator?
21:42:05 <ivanm> @hoogle satisfy
21:42:06 <lambdabot> Text.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
21:42:06 <lambdabot> Text.ParserCombinators.ReadP satisfy :: (Char -> Bool) -> ReadP Char
21:42:06 <lambdabot> Text.ParserCombinators.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
21:42:08 <napping> oh, that too
21:42:11 <ivanm> yup, it does
21:42:14 <tolkad> ivanm: Use vim, it's better than emacs
21:42:20 <ivanm> @slap tolkad 
21:42:21 * lambdabot secretly deletes tolkad 's source code
21:42:25 <ivanm> \o/
21:42:34 <tolkad> ivanm: besides, emacs uses way too much memory
21:43:00 <ivanm> tolkad: just so you know: we might jokingly discuss editors here, but IMHO you're being a troll or else just plain rude
21:43:12 <ivanm> people can use whatever editor they want
21:43:15 <tolkad> ivanm: I'm kidding...
21:43:18 <Veinor> yeah, everybody knows pico is the one true editor
21:43:25 <ivanm> Veinor: that's ed, silly
21:43:28 <geheimdienst> ed is the standard editor
21:43:31 <Veinor> oh, whoops. my mistake
21:43:34 <ivanm> exactly!
21:43:46 <Figs_> I use notepad++ on Vista. I'm an evil bastard though, most likely.
21:43:51 <napping> ed!
21:43:52 <Figs_> ;)
21:43:53 <tolkad> lolvista
21:44:04 <tolkad> I have it too : (
21:44:09 <tolkad> but I don't use it
21:44:15 <tolkad> it's on my other partition
21:45:56 <napping> speaking of abuses of Haskell, I made an instance like IsString ([Expr]->Expr) to help writing some DSL ASTs the other day
21:46:21 <ivanm> *shudder*
21:46:23 <napping> Do (..) ["X"[1] =: "Y", ...], etc
21:46:55 <Saizan> fun
21:47:06 <tolkad> @let instance Show x where show x = "5"
21:47:07 <lambdabot>  Invalid declaration
21:47:26 <tolkad> can you define a generic instance like that?
21:47:34 <ivanm> no
21:47:38 <napping> Is lambdabot much more powerful than I remember, or is it still futile to feed it declarations
21:47:42 <ivanm> well, I lie: you can with overlappign isntances
21:47:45 <ivanm> but you shouldn't
21:47:55 <ivanm> napping: first of all, lambdabot is a she
21:47:58 <ivanm> not an it ;-)
21:48:13 <ivanm> and what do you mean by "feed it declarations"
21:48:15 <ivanm> ?
21:48:16 <Saizan> napping: futile, because they are explicitly filtered out
21:48:23 <napping> like data or class declarations
21:48:30 <napping> you know, the sorts of things ghci can't handle either
21:48:51 <Saizan> in lambdabot those wouldn't be a problem because @let pastes into an .hs file anyway
21:49:00 <napping> oh, fancy
21:49:33 <tolkad> is there like a -XEverything option for GHC?
21:49:40 <tolkad> it would make it easier for me
21:50:00 <Saizan> they aren't allowed because noone tried to check if it's safe to do so :)
21:50:15 <Saizan> with instance Typeable ... you can write unsafeCoerce afterall
21:50:18 <napping> the venerable -fglasgow-exts
21:50:46 <tolkad> > do print 5
21:50:48 <lambdabot>   <IO ()>
21:50:53 <tolkad> > do IO 5
21:50:54 <lambdabot>   Not in scope: data constructor `IO'
21:50:56 <Axman6> > print 5
21:50:57 <lambdabot>   <IO ()>
21:51:01 <tolkad> > do return 5
21:51:02 <lambdabot>   No instance for (GHC.Show.Show (m t))
21:51:02 <lambdabot>    arising from a use of `M6443726853...
21:51:05 <tolkad> > do return (5)
21:51:06 <lambdabot>   No instance for (GHC.Show.Show (m t))
21:51:07 <lambdabot>    arising from a use of `M7425736714...
21:51:07 <ketralnis> When an error message cites an "expected type" and an "inferred type", which is the "it's a X" and which is "but a caller expected a Y"?
21:51:17 <Axman6> do (foo) is the same as (foo)
21:51:35 <tolkad> > @let f IO (x) = x in f (do return (5))
21:51:36 <lambdabot>   <no location info>: parse error on input `@'
21:51:42 <tolkad> > let f IO (x) = x in f (do return (5))
21:51:43 <lambdabot>   Not in scope: data constructor `IO'
21:51:45 <Zao> ketralnis: That tends to confuse me too.
21:51:53 <Axman6> tolkad: what are you doing?
21:52:09 <tolkad> Axman6: trying to see if I can extract something from an IO in lambdabot
21:52:17 <applicative> ketrainis, "expected" means 'required' like "what is expect from a boy your age".
21:52:21 <Axman6> well, that's not how you'd do it
21:52:31 <tolkad> Axman6: well how then?
21:52:40 <applicative> ketrainis, "what is expected from a boy your age"
21:52:43 <Figs_> I'm trying to debug this to figure out why "wtf" isn't backtracked to. I think I probably screwed up the actionParser function. http://pastebin.com/ugksuXef
21:53:08 <Zao> > let x :: Int = "lol" in x
21:53:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:53:09 <lambdabot>         against inferred type ...
21:53:09 <Axman6> let foo (IO f) = f RealWorld in f (return 5)
21:53:10 <napping> Saizan: and unsafeCoerce leads quickly to exploits
21:53:12 <Figs_> (Yes, this is for a text adventure or mud, potentially.)
21:53:16 <Axman6> > let foo (IO f) = f RealWorld in f (return 5)
21:53:17 <lambdabot>   Not in scope: data constructor `IO'Not in scope: data constructor `RealWorld'
21:53:31 <Saizan> ketralnis: roughly in the inverse order, but it doesn't always fit those definitions
21:53:31 <napping> cast an Addr# into a thing expected to have an Info table and enter
21:53:41 <napping> hmm, maybe that doesn't quite work
21:54:12 <Saizan> napping: myUnsafePerformIO m = runST (unsafeCoerce m)
21:54:22 <tolkad> > let do x <- return (5) in x
21:54:23 <lambdabot>   <no location info>:
21:54:23 <lambdabot>      The last statement in a 'do' construct must be an ...
21:54:26 <Zao> I like the truncation of the error message from lambdabot there.
21:54:34 <tolkad> > let do x <- return (5) print x in x
21:54:35 <lambdabot>   <no location info>:
21:54:35 <lambdabot>      The last statement in a 'do' construct must be an ...
21:54:38 <napping> oh, right, you can just use IO. I was trying to figure out how to inject code
21:55:27 <tolkad> so wait how do you do it?
21:55:50 <napping> build a ByteString of shellcode and somehow case around so it ends up as the info pointer and gets entered
21:56:01 <tolkad> boldy going where no man has gone before: http://i.imgur.com/GOb63.jpg
21:56:05 <applicative> > length 'a'
21:56:06 <lambdabot>   Couldn't match expected type `[a]'
21:56:06 <lambdabot>         against inferred type `GHC.Types...
21:56:28 <Figs_> > length "a"
21:56:30 <lambdabot>   1
21:56:50 <applicative> It should just say "Couldn't match required type [a] against your stupid type ...."
21:57:23 <Zao> "Can't fit Int peg into [Char] hole!"
21:57:27 <ketralnis> I have a [Map Int Double] and I want to determine the mean Double for each Int. http://pastebin.com/nXpD02vW I'm getting "Occurs check: cannot construct the infinite type: a = [a]" which isn't terribly helpful
21:57:34 <tolkad> applicative: submit a patch
21:57:59 <Zao> ghc -finsults
21:58:06 <tolkad> ketralnis: is that using multiparametertypeclasses?
21:58:26 <applicative> Zao, yes, it should have witticisms like that too.  "At line x column n, you are trying to get me to fit an Int peg into [Char] hole!,  no way!"
21:58:28 <Zao> ketralnis: Any particular reason you've got a list of maps instead of a map to lists?
21:58:39 <ketralnis> tolkad:  I don't know what that is, so I'm guessing no :)
21:58:45 <Zao> applicative: On the other hand, my brain just exploded.
21:59:17 <tolkad> ketralnis: that's where you can have a class with multiple type parameters, like Map would be a class with the parameters Int, and Double
21:59:26 <applicative> What error gives rise to that? I can't remember
21:59:29 <napping> Figs_: what are you trying to parse?
21:59:31 <tolkad> ketralnis: it's enabled with -XMultiParamTypeClasses
21:59:51 <ketralnis> tolkad: I'm not passing any arguments, so I'm guessing now
21:59:54 <Axman6> you can't do IO in lam	
21:59:54 <Axman6> jdjdj
22:00:06 <Axman6> >_<
22:00:07 <Saizan> ketralnis: the arguments of values' are in the wrong order
22:00:15 <napping> ketralnis: that was wrong anyway. Map is a type, or more properly a type constructor
22:00:22 <Axman6> stupid UNSW network
22:00:41 <napping> tolkad: unlike Java, classes are not types
22:00:46 <ketralnis> Saizan: ah hah!
22:00:51 <ketralnis> Saizan: good catch
22:00:52 <applicative> Why does the error say "occurs check" by the way, the rest is intelligible.
22:01:16 <tolkad> napping: oh, yeah, I forgot
22:01:17 <ddarius> applicative: Read about unification.
22:01:19 <Figs_> napping: I'm trying to write a parser for a text adventure or MUD. Some examples of valid inputs are: "n", "north", "go north", "wtf", "hit the troll with the donkey" (not trying to parse this one just yet)
22:01:24 <napping> Figs_: in particular, damnX gets commited to "damn" because aiw succeeds
22:01:25 <ketralnis> applicative: sort of. Even knowing what I did wrong I'm not sure why it said what it did
22:01:26 <tolkad> napping: so what's [Map Int Double] mean?
22:01:36 <tolkad> napping: a list which can contain any of those?
22:01:39 <napping> tolkad: a list of maps from int to double
22:01:51 <ketralnis> tolkad: it's a list of maps from int to double. In python, [{1: 1.5}]
22:01:56 <tolkad> oh! Map is a type with multiple parameters
22:01:58 <applicative> ddarius, but there's the problem the 'occurs check' isn't grammatical....
22:02:45 <napping> Figs_: that can be fixed by only matching whole words, with something like notfollowedBy anyChar
22:02:53 <dolio> "Occurs check" is the name of the test that failed.
22:03:07 <napping> Figs_: or, look at all the token/leme parser that implements it nicely
22:03:40 <Zao> The check that is named "occurs".
22:03:42 <tolkad> so does GHC have something like -XEverything?
22:03:47 <applicative> dolio, I guess it's no worse than Error 7546 
22:04:00 <Zao> tolkad: Apart from -fglasgow-exts?
22:04:05 <Figs_> napping: I eventually want to be able to use things like: aiw ["hit", "smack", "attack"] >> ...
22:04:09 <tolkad> Zao: uh what's that?
22:04:22 <napping> Figs_: ah, wtf will start in West, backtrack looking for "west", cheer happliy when it matches the whole string "w", and then fail when it sees more characters
22:04:22 <Figs_> So wouldn't notfollowedBy anyChar fail there?
22:04:24 <dolio> The occurs check is when you check whether a the variable you're trying to unify with some other term appears in said term.
22:04:28 <tolkad> Zao: oh that works
22:04:32 <Zao> http://haskell.cs.yale.edu/ghc/docs/6.12.2/html/users_guide/ghc-language-features.html#options-language
22:04:34 <dolio> Or, occurs in said term.
22:04:45 <napping> Figs_: the try only allows backtracking until the thing inside succeeds
22:05:09 <napping> the way you defined aiw, it succeeds as soon as it sees the letters, without checking whether the word is actually done
22:05:16 <applicative> dolio, that helps a lot, thank you. 
22:05:43 <Saizan> ketralnis: btw, "srMeans = M.map mean . M.fromListWith (++) . map (fmap (:[])) . concatMap M.toList"
22:05:43 <Figs_> Is there a way to match the word boundary then, without reading in more input?
22:05:51 <napping> Figs_: that's what notFollowedBy does
22:05:54 <Figs_> oh
22:06:14 <napping> well, it examines the following characters, but doesn't consume them for purposes of parsing
22:06:29 <ketralnis> Saizan: maybe I'm thinking about this too hard, but doesn't that construct a giant list first, duplicating all of the sublists multiple times?
22:06:40 <Figs_> Ahh, ok thanks. That works now.
22:07:52 <napping> it might be best to tokenize in the first place
22:08:19 <applicative> ketralnis, is that wrong? I do it all the time. ...
22:08:31 <Figs_> I'd like to be able to handle dynamically adding new things to the parser, but yeah, if its too hairy, I might go and do that.
22:08:31 <Saizan> ketralnis: it flattens [UserCoord] into a single association list, i'm not sure what you think it's duplicated
22:08:46 <ketralnis> I'm hardly the right person to say what's wrong :) I've been learning for all of a week
22:08:56 <Saizan> ketralnis: anyhow the list will be produced lazily as it is consumed by M.fromListWith (++)
22:08:56 <ddarius> Saizan: Isn't there something like union or some such?
22:09:00 <napping> Figs_: I mean running the input through words first
22:09:16 <napping> do you really plan to mess with the lexical structure of english text?
22:09:29 <ddarius> :t M.unionsWith
22:09:30 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [M.Map k a] -> M.Map k a
22:09:38 <Saizan> the type doesn't fit
22:09:51 <ddarius> Ah, too strict.
22:09:57 <napping> what are you trying to do with unionsWith anyway?
22:10:06 <ddarius> But you could fmap with (:[]) first and then unionsWith.
22:10:45 <Saizan> yeah, but then i felt like fromListWith was simpler for some reason at that point..
22:11:09 <Figs_> I'm not sure exactly what I want to do at that level yet. I might go looking for plurals or some other constructions like that, but no, I'm mostly dealing with grammar rather than lexical issues.
22:11:41 <napping> if you built a parser for [String] instead of [Char] then a lot of this junk is easier
22:11:42 <Figs_> bleep is probably the extent of the complexity in that direction
22:11:45 <napping> satisfy (=="w")
22:11:57 <napping> and stuff like that will just work then
22:12:28 <Figs_> stuff like what will just work?
22:12:52 <napping> If you make a parser to work on String tokens
22:13:08 <Saizan> M.map mean . M.unionsWith (++) . map (fmap (:[])) <- actually makes more sense :)
22:13:33 <napping> then you couldn't confuse ["go","w","10","paces"] with ["go","wtf","a","badger"]
22:15:26 <Figs_> I think I may have done something like that in the original version I did in Python. It was quite a while ago... I had a rather convoluted parser that essentially loaded rules from a sexp DSL I hacked together...
22:15:35 <Figs_> Yeah, splitting words is probably a good idea.
22:16:25 <Figs_> I can always stick something back together and run it through another parser, I suppose, if I need to do something at a lower level.
22:17:23 <Figs_> Is there an easy way to convert over what I have to do that? I'm not very familar with Parsec yet.
22:18:32 <napping> Parsec should work on any token type
22:20:44 <napping> Figs_: check out "token" or "tokenPrim"
22:21:11 <napping> a little tricky stuff to define some primitive tokens, but then you can use all the same combinators and stuff
22:23:27 <daryoush_> testing
22:23:56 <Figs_> Hello daryoush_, your testing has been noticed. :O
22:24:08 <Axman6> TEST FAILURE!
22:24:26 <daryoush_> thanks, i was just setting up the client on new machine, it seems to work!
22:28:43 <ketralnis> Is there a reason to use "sqrt . sum $ â€¦" rather than "sqrt $ sum $ â€¦" other than aesthetics?
22:29:11 <applicative> Axman6, do you still use the Haskell textmate bundle?
22:29:46 <napping> those should be equivalent by Core
22:30:04 <napping> the first is a little easier to edit
22:30:11 <applicative> ketrainis, "sqrt . sum " makes sense all by itself, sqrt $ sum is a type violation all by itself
22:31:09 <Saizan> ?type sqrt $ sum
22:31:10 <lambdabot> forall a. (Floating a) => [a] -> a
22:31:17 <Figs_> What is â€¦" ?
22:31:20 <applicative> I saw that coming
22:31:30 <Figs_> It just comes up as garbage.
22:31:55 <Saizan> Figs_: unicode version of ..."
22:32:11 <Figs_> Oh. Apparently my IRC client sucks then.
22:32:26 * Figs_ glares at Trillian
22:33:31 * applicative is trying to come up with a floating instance that will cover sum
22:33:48 <ketralnis> When dealing with a 37k-item list, foldl dies with a stack overflow, whereas foldl' does not. Why would I not juse use foldl' for everything then?
22:34:55 <Figs_> ketralnis: Are you rewriting Reddit in Haskell or something? :)
22:35:10 <Axman6> ketralnis: kjhk	
22:35:29 <Axman6> in general, you should always use foldl'. foldl is almost always slower
22:35:33 <|marius|> ketralnis: for example, if the entirety of the accumulator isn't needed (or can/should be amortized)
22:35:57 <ketralnis> Figs_:  hehe, no. I'm just teaching myself haskell for fun, but I'm writing a kmeans implementation as a learning exercise :)
22:36:32 <Saizan> ketralnis: foldl makes sense when your step function is a constructor, there's nothing to force anyhow :)
22:37:46 <ketralnis> Ah I see, so if I were building a list from the fold, then foldl can be lazy. But if I'm building an integer, there's no point
22:38:32 <napping> but foldl is building the whole thing step by step
22:38:38 <ketralnis> It would be nice if foldl could just detect that based on its inferred type, but I can see that that would be a pain in the arse and pollute the standard library
22:38:50 <napping> so if you are folding : and [] for reverse, it doesn't hurt to be strict
22:38:54 <ketralnis> And doesn't work for everything anyway
22:38:54 <Saizan> ketralnis: when you're building something lazily by tearing down a list the one that makes most sense is foldr though.
22:39:30 <Saizan> ketralnis: since foldl will always get to the end of the input list before producing any result
22:48:01 <ivanm> does it make sense to have things like mapM defined on non-ordered containers (e.g. Sets)?
23:00:33 <aavogt> @instances Traversable
23:00:34 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
23:00:38 <aavogt> @instances-importing Traversable
23:00:39 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
23:00:47 <aavogt> @instances-importing Traversable Data.Traversable
23:00:48 <lambdabot> Couldn't find class `Data.Traversable'. Try @instances-importing
23:00:56 <aavogt> @instances-importing Data.Traversable Traversable
23:00:57 <lambdabot> Maybe, []
23:01:09 <aavogt> maybe there are others
23:01:15 <ivanm> the rest are in other libraries
23:01:34 <ivanm> but yeah, I forgot traversable had mapM
23:02:06 <aavogt> while the ordering may be arbitrary (or there are lots of ways to do it), it's better to have a way than none at all
23:02:29 <ivanm> thing is, Set isn't an instance of Traversable because it needs the Ord constraint; so I can't use that to tell if mapM makes sense for Set ;-)
23:02:29 <ivanm> aavogt: true
23:02:53 <aavogt> you can derive Traversable?
23:06:22 <edwardk> aavogt: its a ghc extension
23:06:29 <edwardk> {-# LANGUAGE DeriveTraversable #-}
23:06:37 <edwardk> you can derive functor and foldable as well
23:07:25 <ivanm> hey edwardk 
23:07:25 * ivanm is currently adding haddock docs to his initial version of his containers libs
23:07:25 <ivanm> so I'll hopefully make a release within the hour
23:07:25 <ivanm> aavogt: that won't work for Set though
23:21:33 <ivanm> hmmm..... with something like Seq where you can efficiently do something like (init xs, last xs), does it make sense to define foldl from the back rather than the way lists do it?
23:24:20 <ivanm> doesn't look like it :s
23:25:28 <Gracenotes> how would that go? still need to accumulate from the start of the list
23:26:01 <ivanm> yeah, I tried to fudge it but it doesn't work
23:26:18 <ivanm> since the semantics of foldl are very list-oriented in terms of how it works
23:26:42 <ivanm> if lisp had doubly-linked lists then foldl might have been different ;-)
23:27:17 <Gracenotes> yeah, foldr has the wonderful right Kan extension properties and whatnot
23:27:57 <ivanm> looking at the definition of foldl' in GHC: what's the point of the GHC-specific stuff?
23:28:54 <ivanm> just because it's more efficient in GHC but not necessarily other compilers?
23:29:14 <Gracenotes> lots of functions in Data.List have GHC-specific versions
23:29:24 <ivanm> yeah
23:29:32 <ivanm> GHC doesn't seem to like recursive definitions...
23:30:03 <ivanm> well, not to have the overall function be recursive and have an inner recursive function
23:36:16 <qwebirc40728> Why does "x <- mapM return [1..]" never return from GHCI?
23:37:41 <aavogt> mapM doesn't give you results until it has sequenced all the actions
23:38:13 <aavogt> (at least for IO, which you're using in ghci)
23:38:29 <qwebirc40728> Does that mean mapM cannot be used to process infinite lists?
23:39:57 <Heffalump> > mapM return [1..] :: [[Int]]
23:39:59 <lambdabot>   *Exception: stack overflow
23:40:23 <Heffalump> apparently not
23:40:26 <Heffalump> @src mapM
23:40:27 <lambdabot> mapM f as = sequence (map f as)
23:40:30 <Heffalump> @src sequence
23:40:31 <lambdabot> sequence []     = return []
23:40:31 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:40:31 <lambdabot> --OR
23:40:31 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:40:52 <Heffalump> ok, so it won't work for infinite lists in any monad. Shame.
23:41:19 <qwebirc40728> Boo.
23:41:23 <Heffalump> oh, perhaps in simple ones with a suitably lazy bind
23:41:37 <Peaker> It can work in the Identity monad, probably
23:41:39 <Heffalump> > mapM return [1..] 5
23:41:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:42:09 <Heffalump> yeah, if (>>=) doesn't need any info about its left argument, then it'll work
23:42:15 <Heffalump> but that won't be common
23:42:44 <Peaker> qwebirc40728, The IO action: mapM (anything) [1..]  depends on the actions of the entire infinite list before it can return any result
23:46:15 <Gracenotes> hmm
23:46:27 <Gracenotes> > runState (mapM ((>>get) . modify . (+)) [1..]) 0
23:46:28 <lambdabot>   ([1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
23:47:31 <lispy> Shouldn't the strictness of the underlying monad matter?
23:48:21 <Gracenotes> there's always unsafeInterleaveIO, woot
23:49:49 <Veinor> :t mapM
23:49:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:53:14 <Zao> http://hackage.haskell.org/package/interpolatedstring-qq-mwotton-0.1.1
23:53:19 <Zao> Interesting description :D
23:53:58 <koninkje> is there an instance of iteratee:Data.Iteratee.Base.StreamChunk.ReadableChunk ByteString anywhere?
23:54:07 <Zao> Upload a new package that's a fork of another package, three hours later declare it unfit as the original package "works".
23:54:32 <Gracenotes> you can get a tag 'superseded by' for hackage
23:54:52 <edwardk> Gracenotes: ooh, i should do that to a couple of packages
23:55:19 <Zao> I wonder what the difference between haskell-src-meta and haskell-src-meta-mwotton is.
23:55:20 <Veinor> I hve the most important decision ever
23:55:33 <Gracenotes> edwardk: well http://hackage.haskell.org/packages/archive/tagsoup-ht/0.2/tags
23:55:37 <Veinor> should I call my Dice module dice or data-dice for cabal purposes?
23:55:51 <Gracenotes> actually right now I'm working on getting a nice interface for deprecation in Hackage 2.0
23:56:20 <Gracenotes> per-package and per-package-version
23:56:30 <edwardk> Gracenotes: how does one specify that? just add a 'tags' file?
23:56:58 <Gracenotes> I think it has to be done by someone with access to the hackagedb filesystem
23:57:01 <edwardk> or do we have to beg someone there
23:57:02 <edwardk> ah
23:57:24 <edwardk> if you have access can you add a superseded by 'ad' to 'rad' ?
23:57:50 <Gracenotes> ah I don't
23:58:05 <edwardk> (and 'fad', since the authors of that are working with me on 'ad' as well)
23:58:11 <edwardk> oh well
23:58:18 <edwardk> i'll ping duncan or someone
23:58:48 <Zao> This sounds 'mad' :D
23:58:58 <Veinor> aren't you glad?
23:59:05 <lispy> That's rad!
23:59:33 <Zao> Veinor: Just a tad.
23:59:42 <Axman6> it's just a fad
23:59:46 <Gracenotes> oh that's a good idea, I should allow superseded in favor of multiple packages
23:59:51 <lispy> Always a cheerful lad
