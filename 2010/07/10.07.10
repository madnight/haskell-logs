00:00:39 <davekong> @mc :t |||
00:00:40 <lambdabot> Not enough privileges
00:01:26 <davekong> @hoogle |||
00:01:26 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
00:01:52 <davekong> @hoogle ||||
00:01:52 <lambdabot> No results found
00:04:58 <Eduard_Munteanu> xmonad uses |||
00:12:55 <tolkad> How do I read from a mutable vector without causing IO?
00:13:45 <ivanm> use ST instead?
00:14:05 <tolkad> ST?
00:14:26 <tolkad> I'm very new to haskell
00:14:26 <ivanm> @hoogle ST
00:14:26 <lambdabot> module Control.Monad.ST
00:14:27 <lambdabot> module Data.Array.ST
00:14:27 <lambdabot> Control.Monad.ST data ST s a
00:14:38 <ivanm> tolkad: if that's the case, you're better off not touching mutable vectors yet
00:14:48 <tolkad> ivanm: I wan't to use an array
00:14:51 <tolkad> want*
00:14:58 <ivanm> then use an immutable one
00:15:20 <tolkad> ivanm: I need to use a mutable array
00:15:25 <ivanm> Data.Array.IArray is probably the simplest
00:15:27 <ivanm> tolkad: why?
00:15:34 <tolkad> because I like to change stuff in arrays
00:15:39 <ivanm> or Data.Vector.Storable
00:15:40 <tolkad> if it's immutable I can't change it
00:15:54 <ivanm> tolkad: you do because you change it and create a new one
00:16:00 <ivanm> same as every other data structure in Haskell
00:16:11 <tensorpudding> not very efficient, that.
00:16:11 <ivanm> tolkad: lists are immutable, as are Sets, Maps, etc.
00:16:29 <ivanm> tensorpudding: yes, but easier to use if you're only starting out
00:16:38 <tolkad> ivanm: uh... unless GHC has some super magic optimization which would be awesome, that would be slow
00:16:40 <ivanm> though I'd imagine Data.Vector.Storable would be efficient enough
00:17:02 <tolkad> really though, that would be really cool
00:17:17 <ivanm> tolkad: for arrays, yes it usually ends up being inefficient
00:17:24 <ivanm> for other data structures, it isn't
00:17:30 <ivanm> tolkad: what are you wanting to do?
00:17:44 <ivanm> tolkad: note: immutable means "this value doesn't change", it doesn't mean it can't be re-used
00:18:02 <tolkad> ivanm: I want to use immutable arrays, but I want GHC to optimize it to a mutable array
00:18:10 <ivanm> e.g. if you have a list xs and want to cons x onto it, then the new list contains a pointer to the old list rather than copying the entire thing
00:18:20 <ivanm> tolkad: yeah, that's probably not going to happen
00:18:42 <majere> is haskell an apropriate first language
00:18:43 <ksf> sure it is.
00:18:49 <majere> was that directed to me?
00:18:52 <ksf> there's stream-fusion for vectors
00:18:56 <majere> guess not
00:19:02 <ksf> nope.
00:19:07 <ksf> but sure it is.
00:19:13 <ivanm> actually, Data.Vector.Storable seems to use mutable vectors under the hood IIUC
00:19:19 <majere>  /:
00:19:21 <ivanm> majere: sure it is!
00:19:32 <tolkad> ivanm: will it be as fast as using a mutable vector?
00:19:34 <majere> okie dokie.
00:19:35 <ivanm> ksf: that doesn't magically make array updates in-place though
00:19:39 <ivanm> tolkad: what are you wanting to do?
00:19:45 <ksf> ivanm, oh yes it does.
00:19:52 <majere> can someone point me to a book for a beginner
00:19:54 <ivanm> ksf: :o
00:19:55 <ksf> it fuses and then drops into ST
00:19:56 <tolkad> ivanm: nothing really, I'm just trying to learn haskell and I wanted to try arrays
00:19:57 <ivanm> @where LYAH
00:19:58 <lambdabot> http://www.learnyouahaskell.com/
00:19:59 <ivanm> majere: ^^
00:20:06 <majere> i saw that but
00:20:10 <tolkad> ivanm: because it's hard to do stuff without arrays
00:20:10 <majere> it looks incompleet
00:20:27 <tolkad> ivanm: IO type stuff that is
00:20:36 <ksf> majere, it's a very good start
00:20:36 <ivanm> if you want an actual paper book, there's Programming in Haskell by Hutton, Craft of Functional Programming by THompson and Haskell School of Expression by someone else
00:20:39 <ksf> @where rwh
00:20:39 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:20:43 <ksf> that's the second one
00:20:45 <tensorpudding> Is there an Edison class for vectors?
00:20:45 <ivanm> tolkad: huh? I hardly ever use arrays!
00:20:51 <ivanm> ksf: for a beginner? really?
00:20:53 <ivanm> tensorpudding: don't think so
00:20:56 <tolkad> ivanm: I use them all the time in other languages
00:21:02 <majere> ksf: thats good for a beginner?
00:21:09 <ivanm> majere: not really
00:21:16 <ivanm> see the other books I listed for better beginner books
00:21:18 <Eduard_Munteanu> Ideally it should be possible to deforestate some cases and make the underlying low-level representation use mutable data, right?
00:21:20 <majere> :/
00:21:30 <tensorpudding> It shouldn't be too hard to jimmy one up.
00:21:33 <ivanm> majere: note that out of those three, the first one is relatively new, the other two are a tad old
00:21:34 <majere> ivanm: the programming in haskell by hutton is a good beginner book?
00:21:39 <majere> oh
00:21:41 <tensorpudding> How many implementations of vectors are there anyway?
00:21:50 <ivanm> tensorpudding: well, I'm considering writing something similar to Edison next weekend at AusHack
00:21:50 <ksf> rwh is old?
00:21:52 <ivanm> majere: yup
00:21:57 <ivanm> ksf: I wasn't talking about RWH
00:22:09 * majere is confused at which ones you are recommending
00:22:12 <majere> is rwh good?
00:22:20 <Eduard_Munteanu> Technically, GHC is already doing it for accumulator variables and simple recursion, isn't it?
00:22:28 <ivanm> majere: these three: Programming in Haskell by Hutton, Craft of Functional Programming by THompson and Haskell School of Expression by someone else
00:22:40 <ivanm> majere: RWH is good, but not really aimed at someone that's never programmed before
00:22:49 <majere> oh
00:22:53 <ksf> which is where lyah comes in
00:22:54 <tolkad> btw, this API is confusing: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Mutable.html
00:22:56 <tensorpudding> Well, Edison supports sequences, bags/sets and maps, but it doesn't have anything like a vector.
00:23:01 <ivanm> tolkad: we use lists, maps, etc. the way other languages use arrays
00:23:27 <tolkad> what's that "RealWorld" thing? it looks unnecessary
00:23:30 <ivanm> tolkad: don't use the mutable one if you're only a beginner haskeller!
00:23:35 <majere> tolkad: what book are you reading?
00:23:43 <ivanm> tolkad: Real World Haskell? it's a medium to advanced book on Haskell
00:23:43 <Eduard_Munteanu> tolkad: why confusing?
00:23:45 <ivanm> really good
00:23:52 <ivanm> Eduard_Munteanu: all the PrimMonad stuff
00:23:57 <ivanm> he's a beginner
00:23:59 <tolkad> majere: I read learn you a haskell for great good
00:24:09 <majere> maybe ill try it
00:24:10 <tolkad> no no no, not that book
00:24:11 <ivanm> tolkad: what are you actually wanting to do with those arrays?
00:24:15 <tolkad> it's a type
00:24:15 <majere> tolkad: ?
00:24:18 <tolkad> RealWorld
00:24:20 <majere> oh
00:24:21 <tolkad> a class actually
00:24:22 <majere> hehe
00:24:24 <Eduard_Munteanu> Ah, well, you don't really need all that to use it.
00:24:26 <ivanm> tolkad: oh, that's a wrapper for IO
00:24:30 <ivanm> majere: as I said, don't use that
00:24:33 <ksf> RealWorld# is an implementation detail
00:24:36 <ivanm> use Data.Vector.Storable or something
00:24:41 <ksf> never mind those
00:24:43 <majere> ivanm: dont use lyah?
00:24:46 <tolkad> well it looks ugly
00:24:50 <ivanm> I've already learnt Haskell ;-)
00:24:51 <tolkad> can you get it out of my haskell please?
00:24:58 <ivanm> and I prefer proper grammar and a lack of silliness
00:25:00 <majere> ivanm: are you telling me not to use lyah?
00:25:03 <ivanm> tolkad: don't use it!
00:25:06 <ivanm> majere: not at all
00:25:14 <ivanm> majere: if you like that style, go ahead
00:25:19 <majere> 08:24 < ivanm> majere: as I said, don't use that
00:25:27 <ivanm> that was to tolkad ;-)
00:25:29 <majere> oh
00:25:51 <ivanm> if you want an actual paper book, I listed three above; programming is new but uses cool-looking symbols which can make typing the code and trying it out yourself difficult
00:26:00 <ivanm> I quite like Craft, but it's getting dated
00:26:06 <ivanm> SoE is also rather good
00:26:08 <ivanm> @where wikibook
00:26:09 <lambdabot> http://en.wikibooks.org/wiki/Haskell
00:26:13 <ivanm> majoh: ^^ here's another online tutorial
00:26:17 <ivanm> @where yaht
00:26:18 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
00:26:25 <ivanm> and another, that's being merged into the wikibook
00:26:37 <ivanm> tolkad: what are you wanting to do with Arrays?
00:27:01 <tolkad> ivanm: idk yet, I was planning to store stuff in them
00:27:02 <tensorpudding> Why is Edison needing replaced, anyway?
00:27:10 <tolkad> ivanm: I was going to start with Ints
00:27:21 <Eduard_Munteanu> tolkad: you don't really need arrays.
00:27:31 <ivanm> tensorpudding: some of its stuff is a bit weird, and why does it re-export all the types internally? :s
00:27:37 <ivanm> I just wanted a slimmer, cleaner API
00:27:38 <Eduard_Munteanu> Well you do, if you intend to implement matrix algorithms or stuff that's really hard to do otherwise.
00:27:50 <ivanm> tolkad: what kind of stuff?
00:27:55 <aavogt> tolkad:  a better question is which algorithms you think you need arrays for
00:27:57 <ivanm> why can't you use a list, or a Set, or a Map?
00:27:58 <tolkad> ivanm: Ints
00:28:12 <ivanm> > [1..10]
00:28:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:28:18 <ivanm> > Set.fromList [1..10]
00:28:20 <lambdabot>   Not in scope: `Set.fromList'
00:28:22 <ivanm> > S.fromList [1..10]
00:28:24 <lambdabot>   fromList [1,2,3,4,5,6,7,8,9,10]
00:28:24 <tolkad> aavogt: idk, the truth is, I came in here asking how to use a list as an array and someone told me to use Vector
00:28:32 <Eduard_Munteanu> tolkad: FWIW, you don't need to store stuff, you only need to specify a way to _produce_ it.
00:28:39 <ivanm> tolkad: you asked how to use mutable arrays!
00:29:00 <ivanm> Eduard_Munteanu: well, it depends
00:29:10 <Eduard_Munteanu> That's why we've got 2nd order functions and whatnot.
00:29:27 <ivanm> "2nd order" ?
00:29:39 <aavogt> it stops there :)
00:29:44 <tolkad> anyway, I think it's weird that haskell automatically collates IO in a do block
00:29:49 <Eduard_Munteanu> ivanm: as in higher order... (a -> a) -> a
00:29:50 <abhaya> Does Haskell have first class continuations or first class closures?
00:29:56 <tensorpudding> lists can be mutated, but not efficiently
00:29:57 <ivanm> Eduard_Munteanu: then say higher-order!
00:29:59 <tolkad> it doesn't seem very functionalish
00:30:12 <ivanm> tolkad: it's syntactic sugar
00:30:15 <Eduard_Munteanu> Heh, you have a point.
00:30:16 <ivanm> to make it look more imperative
00:30:17 <altious> hello
00:30:26 * ivanm waves idly in altious's general direction
00:30:52 <ivanm> tolkad: what are you wanting to do with those Ints?
00:31:03 <ksf> abhaya, all of them.
00:31:07 <tolkad> ivanm: I was going to enter them from command line
00:31:09 <ivanm> if you just want a collection of them and to see if you have one or not, use a Set
00:31:13 <tolkad> ivanm: and print them back out
00:31:16 <abhaya> ksf: What?
00:31:23 <ivanm> if you want some specific ordering of them, use a list
00:31:27 <Eduard_Munteanu> tolkad: let foo = [1, 2, 3]
00:31:29 <altious> should haskell pattern match ('1':_:'2':_:'3':_:'4':_:'5':_:'6':_:'7':_:'8':_:'9':_:'0') ?
00:31:36 <ivanm> @type interact
00:31:38 <lambdabot> (String -> String) -> IO ()
00:31:45 <tolkad> hmm, I'll try without a vector
00:31:46 <aavogt> that's not valid, altious
00:31:50 <ivanm> tolkad: "interact id" will do that :p
00:32:04 <altious> aavogt, we cannot have multiple wildcards?
00:32:04 <ivanm> altious: you need to end it with a list
00:32:08 <ksf> abhaya, both first class closures (well we call them functions) and continuations (which we also call functions)
00:32:09 <ivanm> so have :[] on the end or something
00:32:18 <altious> oh, ok
00:32:21 <aavogt> altious: no, you're asking for an infinite type
00:32:29 <aavogt> as ivanm pointed out
00:32:43 <altious> thanks
00:32:48 <Eduard_Munteanu> Ah, I misunderstood the meaning of cmdline.
00:33:37 <aavogt> well I'm sort of wrong on that, since the '1' is fixed
00:33:47 <Eduard_Munteanu> altious: anyway, you can't cons a list to another list.
00:33:52 <ivanm> tolkad: IMHO, a good way to learn is to treat the list as the ultimate data structure; use it to define "Sets", "Maps", "arrays", etc.
00:33:58 <Eduard_Munteanu> So that wildcard can't be a list.
00:34:08 <ivanm> (note that in imperative languages, they typically use arrays to simulate all the others)
00:34:08 <ManateeLazyCat> ivanm: You know my project and it's aim? Now I hesitate to release separately package for each module.
00:34:13 <Eduard_Munteanu> :t (:)
00:34:14 <aavogt> altious: it might be nicer to write a function that drops every other element, then you can write in the pattern  "1234567890"
00:34:15 <lambdabot> forall a. a -> [a] -> [a]
00:34:24 * ivanm gets flashbacks from having to define lists in Java using arrays
00:34:30 <ManateeLazyCat> ivanm: I'm fix the documentation of my project for ready release.
00:34:34 <ivanm> ManateeLazyCat: cool
00:34:41 <ivanm> so, what are you calling it?
00:34:47 <ManateeLazyCat> ivanm: Manatee
00:34:48 <altious> aasmith, it might :)
00:34:57 <Eduard_Munteanu> (Even if you're writing it using concatenation (++) it's not always decidable)
00:35:09 <aavogt> @hoogle stripPrefix
00:35:09 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
00:35:12 <ivanm> ManateeLazyCat: heh, decided to avoid thinking of a catch-all descriptinve name? :p
00:35:13 <ManateeLazyCat> ivanm: But i no idea whether release each sub-module (editor, file-manager, browser, pdf-viewer) in separate package.
00:35:37 <ivanm> ManateeLazyCat: depends; can they be released as separate packages and still interact
00:35:42 <ivanm> if so, that might be the better approach
00:35:45 <ivanm> let users get what they want
00:35:47 <ManateeLazyCat> ivanm: Infact, my project just for one person -- my girl. That's all! :)
00:35:52 <ivanm> heh
00:36:00 <aavogt> separate packages make for better hackage growth
00:36:02 <ivanm> have some core central package, and everything else plugs into it
00:36:09 <ivanm> aavogt: yeah; we can show off more! :p
00:36:17 <aavogt> you know how much we like that :)
00:36:48 <aavogt> I suppose it's just a constant factor though
00:37:19 * ManateeLazyCat pasted "directory tree." at http://paste2.org/get/909934
00:37:20 <ManateeLazyCat> ivanm: Above is my project directory tree.
00:37:51 <ManateeLazyCat> ivanm: I have split "Toolkit" "Core" "Extension" "Plugin" in different directory.
00:38:01 <ivanm> ManateeLazyCat: so, it's possible you can make everything under Extension into separate packages
00:38:07 <ivanm> and have the rest of it as a core package
00:38:14 <aavogt> but considering foo-transformers   foo-mtl foo-randomclassprovidingpackage, you might be able to explain the increasing growth rate
00:38:15 <ivanm> maybe even Plugins being separate
00:38:22 <ManateeLazyCat> ivanm: yes.
00:38:24 <ivanm> aavogt: yeah
00:38:53 <ManateeLazyCat> ivanm: But i'm not sure user like which? One package install everything OR install each sub-module one by one.
00:38:59 <ManateeLazyCat> ?
00:39:47 <ivanm> ManateeLazyCat: by having separate packages, it'll make it easier for other people to write their own extensions if they end up using your project
00:39:58 <ManateeLazyCat> ivanm: One package maybe handy, but my project will grow quickly, because it's aim is for Environment like Gnome.
00:39:58 <ivanm> the alternative is to do what xmonad does and have a core and a contrib
00:40:13 <ivanm> ManateeLazyCat: exactly, so having separate packages would make that easier
00:40:21 <ManateeLazyCat> ivanm: I see.
00:40:24 <ivanm> just define your own category in the cabal file as well and use that to make it easier to find
00:40:30 <tolkad> how do you recurse in an anonymous function?
00:40:33 <ivanm> (if you go the multi-package route)
00:40:39 <ivanm> tolkad: well, you can using the fix function
00:40:41 <ManateeLazyCat> ivanm: Suggestion for category?
00:40:50 <ivanm> but in general you're better off not using an anonymous function
00:41:00 <ivanm> ManateeLazyCat: well, your overall project is called "Manatee", right?
00:41:03 <ivanm> so use that
00:41:13 <Eduard_Munteanu> BTW, does anyone know any productivity studies (they don't need to be very formal) regarding Haskell vs. other, traditional programming languages, like C?
00:41:16 <ManateeLazyCat> ivanm: synopsis is "The Haskell/Gtk+ Integrated Live Environment"
00:41:21 <Eduard_Munteanu> or even Java?
00:41:40 <aavogt> you can also delegate the recursion to a more specific library function than fix
00:41:48 <ivanm> Eduard_Munteanu: there was one _way_ back that compared a whole bunch of languages for the USN IIRC
00:41:51 <ManateeLazyCat> ivanm: I don't like "Live Integrated Environment", because it's LIE. :)
00:41:52 <ivanm> can't recall where to find it though
00:42:13 <Eduard_Munteanu> ivanm: thanks, I'll look that up. What does the USN stand for?
00:42:16 <ivanm> aavogt: well, yes, but I was under the impression tolkad wanted to recurse on the anonymous function
00:42:29 <ivanm> tolkad: in general practice, only use lambda functions for small throw-away functions
00:42:36 <ivanm> Eduard_Munteanu: United States Navy
00:42:37 <ManateeLazyCat> ivanm: I plan to release: "Manatee-Toolkit", "Manatee-Core", "Manatee-Extension-Bla" "Manatee-Plugin-Bla"..
00:42:46 <Eduard_Munteanu> ivanm: thanks.
00:43:02 <ivanm> ManateeLazyCat: unless you can think of a reason why someone would only want one and not the other, I'd combine the toolkit and core
00:43:21 <Eduard_Munteanu> tolkad: if you still want to do it, there was something on Wikibooks IIRC on 'fix', read that.
00:43:27 <ivanm> also, don't worry about the extension or plugin bits, unless you think people are going to want to have an extension and a plugin with the same name
00:43:46 <Eduard_Munteanu> @src
00:43:47 <lambdabot> src <id>. Display the implementation of a standard function
00:43:49 <Eduard_Munteanu> @src fix
00:43:50 <lambdabot> fix f = let x = f x in x
00:44:03 <ManateeLazyCat> ivanm: Because *Extension* and *Plugin* is different for *Core*.
00:44:54 <ivanm> ManateeLazyCat: but does that matter in terms of package names?
00:46:23 <ManateeLazyCat> ivanm: Extension and Plugin both running in separate processes, but Extension is standalone with Daemon process, such as editor, file-manager...etc. Plugin is integrate with *Core* but running in separate process for protected *Core* won't crash.
00:46:47 <ivanm> yes, but does how its implemented/run make a difference to what you call it?
00:46:50 <Eduard_Munteanu> ivanm: found what you suggested here... http://www.haskell.org/haskellwiki/Applications
00:47:10 <kamatsu> is there some constraint I can use that will determine if a type is inhabited?
00:47:14 <Eduard_Munteanu> 2nd in 3 Reports on Experiences with Haskell
00:47:20 <ivanm> I mean, does Manatee care that the PDF viewer is in the Manatee-PDFViewer package rather than Manatee-Extension-PDFViewere package?
00:47:56 <ManateeLazyCat> ivanm: No, it's don't care name. 
00:48:21 <kamatsu> in particular, i would like to determine using a constraint if a type family has an instance for a given type.
00:48:22 <Eduard_Munteanu> Mmm should it care at all? For a DE/WM, it should only matter what the user has chosen and how to invoke it.
00:48:22 <ManateeLazyCat> ivanm: Just for distinguish *extension* and *plugin* for different usage.
00:48:23 <ivanm> ManateeLazyCat: right, so I think it'd be better to have the names not bother with "Extension" or "Plugin"
00:48:27 <ivanm> as it just makes it wordier
00:48:41 <ivanm> or, if just have one of them (say Plugin) have that explicit bit in the package name
00:49:14 <kamatsu> or, actually a data family
00:49:20 <ivanm> Eduard_Munteanu: yeah, that's the one I was thinking of
00:49:21 <kamatsu> no, a type family
00:49:51 <ManateeLazyCat> ivanm: You mean i just need "Manatee-Core" (include Toolkit *Core* and *Toolkit*), and "Manatee-Bla1", "Manatee-Bla2"... ?
00:49:51 <ivanm> Eduard_Munteanu: and for ManateeLazyCat's project, he's doing a cross between an IDE and a WM (so it would still need a WM)
00:49:51 <Eduard_Munteanu> LOL, now Awk has to be a really productive general-purpose language :P
00:50:11 <Eduard_Munteanu> I see.
00:50:19 <tolkad> see? nothing I write in haskell ever works: http://pastebin.com/iwPBQwAv
00:50:26 <ivanm> ManateeLazyCat: yes; maybe even just have Manatee, Manate-PDF, Manate-Browser, etc.
00:50:46 <ivanm> and by default stick the editor inside Manatee or something (so it will actually do something on its own)
00:50:54 <tolkad> any ideas on how to make that work?
00:50:55 <ManateeLazyCat> Eduard_Munteanu: http://farm5.static.flickr.com/4134/4762834054_6fd804f32e_b.jpg
00:51:20 <kamatsu> tolkad: what are you trying to do?
00:51:22 <ivanm> tolkad: what are you trying to do?
00:51:26 <ivanm> kamatsu: heh, jinks! :p
00:51:41 <ivanm> tolkad: I would go back to going through tutorials if I were you
00:51:42 <ManateeLazyCat> ivanm: About "Manatee-Toolkit", i want share it, i want work together with Leksah/Yi developer.
00:51:49 <tolkad> Read a list of any number of integers until I get something that's not an integer, and then print them back out in order
00:51:52 <ivanm> ManateeLazyCat: OK, maybe split it off then
00:52:11 <ivanm> ManateeLazyCat: but maybe you should check with them first, because there's no point in splitting off a package just because you can...
00:52:16 <tolkad> hmm, I could use another where
00:52:26 <ivanm> ManateeLazyCat: it's better IMHO to have an all-in-one package and then split it up down the track if need be
00:52:28 <kamatsu> tolkad: for starters, stop using the IO monad to do your pure computations
00:52:37 <ivanm> tolkad: that's probably not going to work too well
00:52:46 <ivanm> you can try using reads though to check if it's not an integer
00:52:51 <ivanm> @type reads
00:52:52 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:53:24 <kamatsu> i have a suspicion i could do what tolkad wants as a one liner
00:53:31 * kamatsu goes off to golf this
00:53:52 <ivanm> > let isInt str = case reads str :: [(Int, String)] of [(_,())] -> True, _ -> False in map isInt ["1", "hi", "1hi"]
00:53:53 <lambdabot>   <no location info>: parse error on input `,'
00:53:56 <ivanm> grrr...
00:53:56 <Eduard_Munteanu> ManateeLazyCat: ah, that's neat. I assume you're reusing existing engines for HTML/PDF viewing.
00:54:02 <ivanm> > let isInt str = case reads str :: [(Int, String)] of [(_,())] -> True; _ -> False in map isInt ["1", "hi", "1hi"]
00:54:03 <lambdabot>   Couldn't match expected type `GHC.Base.String'
00:54:03 <lambdabot>         against inferred typ...
00:54:04 <tolkad> wait, read doesn't return Maybe whatever?
00:54:11 <tolkad> which one is it that does?
00:54:11 <ManateeLazyCat> ivanm: I'm afraid all-in-one package will too *big*, because i have many sub-project (irc, mail, player, earth, map, dictory, download-manager, translater) need to integrate.
00:54:11 <ivanm> tolkad: no
00:54:13 <ivanm> > read "1"
00:54:14 <lambdabot>   *Exception: Prelude.read: no parse
00:54:17 <ivanm> > read "1" :: Int
00:54:18 <lambdabot>   1
00:54:20 <ivanm> > read "1h" :: Int
00:54:21 <lambdabot>   *Exception: Prelude.read: no parse
00:54:29 <ManateeLazyCat> Eduard_Munteanu: WebKit, i have binding it to webkit package (install by cabal)
00:54:32 <ivanm> ManateeLazyCat: I mean for the core & toolkit bit
00:54:40 <ManateeLazyCat> ivanm: Yes.
00:54:43 <ivanm> don't split off toolkit until you know that someone else will want it
00:54:57 <ManateeLazyCat> ivanm: I'm not sure Leksah's developer really need it.
00:55:01 <ivanm> ManateeLazyCat: webkit has a pdf viewer in it?
00:55:04 <ivanm> ManateeLazyCat: exactly
00:55:19 <ivanm> and it'll just make it harder for you to develop in the future if you split the packages up needlessly
00:55:23 <altious> No instance for (Integral [t]) ... In the expression: (floor (sqrt (1020304050607080900))) ... In a stmt of a list comprehension
00:55:26 <altious> eh?
00:55:29 <ManateeLazyCat> ivanm: webkit and pdf-viewer is in split extensive.
00:55:42 <ManateeLazyCat> ivanm: Yes.
00:55:47 <ivanm> altious: post the whole list comprehension
00:55:50 <tensorpudding> Being able to render PDF inside a browser might be nice.
00:55:55 <ManateeLazyCat> ivanm: IMO, i love all-in-one package.
00:55:59 <ManateeLazyCat> tensorpudding: Too slow.
00:56:16 <ManateeLazyCat> tensorpudding: I use poppler binding (i have releast it on hackage) to render pdf.
00:56:27 <ivanm> ManateeLazyCat: I think he means have a native inbuilt pdf viewer rather than having to use a plug-in like adobe provides
00:56:31 <ManateeLazyCat> tensorpudding: Render PDF in browser like Google do that is too *slow*.
00:56:35 <altious> http://pastie.org/1038632
00:56:37 <ivanm> so just make it part of your browser
00:56:46 <ManateeLazyCat> ivanm: I never use adobe code.
00:57:15 <ivanm> altious: and the entire error message?
00:57:30 <ivanm> because I _think_ you're trying to treat that list of values as a single Integer
00:57:39 <tensorpudding> It'd mostly be useful if it were possible to embed PDF inside HTML in some meaningful way.
00:57:41 <altious> sry. http://pastie.org/1038633
00:57:50 <aavogt> kamatsu: you were thinking about something like: main = interact $ unlines . (\x -> length x `seq` x) . takeWhile (all isDigit) . lines
00:57:54 <ivanm> ManateeLazyCat: right, but I think tensorpudding was saying that having a pdf viewer inbuilt into the browser rather than having to use adobe's plugin or google's viewer would be nice
00:58:02 <ivanm> rather than having to launch a separate window/process
00:58:04 <ManateeLazyCat> ivanm: I love all-in-one package, it's easy to modified all project, but i'm afraid all-in-one package will broken by some dependent, since some user don't want *all* those feature. 
00:58:06 <tensorpudding> Otherwise it's just adding new functionality to a browser that is somewhat orthogonal to browsing.
00:58:25 <ivanm> altious: I think you're bracketing is the problem
00:58:32 <ivanm> do you use floor anywhere else?
00:58:50 <ManateeLazyCat> ivanm: Emacs is all-in-one package. :)
00:59:15 <kamatsu> aavogt: yes..
00:59:16 <ivanm> [ x*x | x <- [ (floor $ sqrt 1020304050607080900) ... (ceiling $ sqrt 1929394959697989990)]]
00:59:19 <altious> ivan, no
00:59:20 <ivanm> > [ x*x | x <- [ (floor $ sqrt 1020304050607080900) ... (ceiling $ sqrt 1929394959697989990)]]
00:59:21 <lambdabot>   Not in scope: `...'
00:59:26 <ivanm> > [ x*x | x <- [ (floor $ sqrt 1020304050607080900) .. (ceiling $ sqrt 1929394959697989990)]]
00:59:27 <lambdabot>   [1020304050403020100,1020304052423222121,1020304054443424144,10203040564636...
00:59:28 <ivanm> altious: ^^
00:59:30 <PetRat> Looking at Control.Exception. Defined my own exception, MyExcept. I noticed that all it takes to make an instance is    "instance Exception MyExcept"  Why is this? Why not define the functions toException and fromException?
00:59:34 <ivanm> ManateeLazyCat: well, it allows extensions
00:59:38 <altious> ivan, thank a lot
00:59:56 <ivanm> np
00:59:57 <aavogt> it needs to add a newline when the first char isn't whitespace or a digit
01:00:05 <ivanm> aavogt: tolkad wanted something
01:00:10 <Eduard_Munteanu> PetRat: perhaps the class definition provides defaults.
01:00:11 <ManateeLazyCat> ivanm: I plan to patch gtk2hs to make i can Drop Any sub-module tab from *one* node to another, that's mean, you can drop out editor from project and just use editor.
01:00:24 <kamatsu> tolkad: there you go, aavogt posted a one liner
01:00:24 <ivanm> and I gave up on trying to get my case thing working...
01:00:50 <aavogt> the use of seq there is probably not obvious
01:01:09 <kamatsu> aavogt: is that just to prevent memory blowout in large cases?
01:01:16 <ivanm> aavogt: hmmm...
01:01:18 <ManateeLazyCat> tensorpudding: Why need embedded pdf-viewer in browser? I don't understand.
01:01:20 <kamatsu> aavogt: i'm not convinced that's necessary, it seems to print as it goes
01:01:21 <aavogt> it's to delay the output
01:01:30 <kamatsu> oh
01:01:32 <ivanm> ManateeLazyCat: say you're looking up papers online
01:01:36 <kamatsu> i'm fairly sure continuous output is fine
01:01:39 <ivanm> and you find a link to a pdf
01:01:40 <altious> > [floor $ sqrt 1020304050607080900 .. ceiling $ sqrt 1929394959697989990]
01:01:41 <lambdabot>   [1010101010,1010101011,1010101012,1010101013,1010101014,1010101015,10101010...
01:01:41 <aavogt> I thought that was a requirement
01:01:48 <ManateeLazyCat> ivanm: So Google viewer can do that.
01:01:54 <kamatsu> main = interact $ unlines . takeWhile (all isDigit) . lines
01:01:55 <tensorpudding> I don't think that including PDF viewing support in Webkit is terribly useful
01:02:07 <ivanm> ManateeLazyCat: currently, you have 3 options: use google viewer, use a plugin from adobe or someone and launch a stand-alone viewer
01:02:11 <PetRat> Eduard_Munteanu: right. I notice the default definition of fromException is "fromException (SomeException e) = case e"  what is cast?
01:02:29 <ivanm> the first is dodgy, the second causes memory leaks, etc. and the third requries launching a new window, etc.
01:02:37 <ManateeLazyCat> ivanm: Yes, i use myself pdf-viewer base on poppler binding (poppler is porting from xpdf).
01:02:37 <Eduard_Munteanu> PetRat: cast?
01:02:44 <Eduard_Munteanu> @src fromException
01:02:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
01:02:52 <Eduard_Munteanu> @hoogle fromException
01:02:53 <lambdabot> Control.Exception fromException :: Exception e => SomeException -> Maybe e
01:02:53 <lambdabot> Control.Exception.Base fromException :: Exception e => SomeException -> Maybe e
01:03:01 <ivanm> ManateeLazyCat: if, however, there was the option of launching the pdf viewer inside the editor as yet another tab, then you could mix and match your pdf viewing with your web browsing
01:03:07 <ivanm> Eduard_Munteanu: not everything is in @src
01:03:08 <kamatsu> so i take it from the lack of responses that there is no way to express in a constraint that "x" should not be an instance of some family?
01:03:16 <ivanm> only a few things that people explicitly put in
01:03:16 <aavogt> kamatsu: you might want to have   map (\x -> length x `seq` x) before unlines, so you don't have to mess around with ensuring how the buffering happens
01:03:21 <Eduard_Munteanu> ivanm: can't blame me for trying ;)
01:03:26 <ivanm> (since it isn't just looking the code up from hackage or something)
01:03:27 <ManateeLazyCat> ivanm: Google viewer just useful for oneline review, but it's still too slow to render pdf view. So pdf-viewer is helpful for local pdf file.
01:03:30 <tensorpudding> Opening a PDF in Preview, Adobe Reader, Evince, etc. is a decent compromise, I think.
01:03:39 <ivanm> kamatsu: not that I know of; I was trying to do something the opposite before
01:03:44 <ManateeLazyCat> ivanm: Yes, that's was i do.
01:03:45 <ivanm> kamatsu: actually...
01:03:49 <ManateeLazyCat> ivanm: Split window like Emacs.
01:03:53 <PetRat> Eduard: yes "cast" not case
01:04:00 <ManateeLazyCat> ivanm: You even can compare different part of same tab.
01:04:03 <kamatsu> or rather that SomeFamily x is uninhabited.
01:04:19 <ivanm> kamatsu: kinda the opposite, but maybe soemthing similar to what ddarius did here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27224
01:04:38 <ivanm> ManateeLazyCat: not a split window: have the pdf-viewer being just another tab in the browser
01:04:56 <ivanm> tensorpudding: yeah, but it's a PITA waiting for that other app to open
01:05:03 <altious> sry. what '$' in haskell is? is it some kind of function or simply a syntax construct?
01:05:08 <altious> $
01:05:10 <PetRat> hayoo says there is a "cast" in System.IO.ExplicitIOModes
01:05:11 <kamatsu> altious: it's a function
01:05:16 <ivanm> altious: function application
01:05:20 <ivanm> @src ($)
01:05:20 <kamatsu> altious: a $ b = a b
01:05:20 <lambdabot> f $ x = f x
01:05:22 <ivanm> @type ($)
01:05:23 <lambdabot> forall a b. (a -> b) -> a -> b
01:05:33 <tolkad> why doesn't this work then?
01:05:35 <ivanm> altious: f (g h) == f $ g h
01:05:36 <tolkad> http://pastebin.com/kAqvPXfg
01:05:42 <Eduard_Munteanu> @hoogle cast
01:05:42 <ivanm> lets you avoid extra parentheses ;-)
01:05:43 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
01:05:43 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
01:05:43 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
01:05:57 <altious> ivanm, yes, i know
01:05:58 <ManateeLazyCat> ivanm: Wait, i'm bit confusion, i paste my screenshot.
01:06:05 <Eduard_Munteanu> PetRat: probably the first ^
01:06:10 <kamatsu> tolkad: more importantly, why are you using the IO monad for something that can be done in a one line pure function?
01:06:12 <aavogt> tolkad: does it typecheck?
01:06:13 <ivanm> tolkad: error messages would be nice, but I highly suggest you go back and keep doing tutorials
01:06:21 <altious> was confused about In the first argument of `($)', namely `floor' ;)
01:06:22 <Eduard_Munteanu> @src cast
01:06:22 <lambdabot> Source not found. You type like i drive.
01:06:30 <Eduard_Munteanu> Meh...
01:06:33 <tolkad> kamatsu: yes but I still want to know why it didn't work
01:06:36 <ivanm> aavogt: I doubt it, if he's pasing in () as an initial value to loop
01:06:38 <Eduard_Munteanu> Probably just cast = Just
01:06:40 <aavogt> you should try to see which warnings ghc gives you. Say  -fwarn-unused-do-bind
01:06:40 <kamatsu> ivanm: that seems to be about classes, not families
01:06:45 <tolkad> Couldn't match expected type `[a]' against inferred type `IO b'
01:06:50 <tolkad> In the first argument of `continue', namely `loop'
01:06:50 <kamatsu> tolkad: where?
01:06:51 <ivanm> kamatsu: oh, right, sorry
01:06:53 <kamatsu> ah
01:07:38 <ivanm> altious: yeah, because f $ x = ($) f x, so `f' is the first argument to the ($) function
01:07:46 <tensorpudding> @type loop
01:07:48 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
01:07:53 <tensorpudding> hmm
01:07:55 <kamatsu> tensorpudding: loop is something he wrote
01:07:57 <PetRat> What does Typeable exist for, basically?
01:07:57 <tensorpudding> @type continue
01:07:59 <lambdabot> Not in scope: `continue'
01:08:01 <tensorpudding> blah
01:08:04 <ivanm> same as continue
01:08:10 <ivanm> tolkad: you're doing it wrong
01:08:19 <tolkad> ivanm: which part?
01:08:35 <ivanm> the whole thing
01:08:38 <ManateeLazyCat> ivanm: You mean i open pdf Tab in Browser tab-group?
01:08:42 <ivanm> yes
01:08:45 <ivanm> ManateeLazyCat: ^^
01:08:47 <tensorpudding> Typeable is required for Data.Data, which can scrap boilerplate
01:08:59 <ManateeLazyCat> ivanm: Why?
01:09:02 <kamatsu> tolkad: ivanm is trying to say that your code is very unidiomatic, and it's taking us far too long to figure out what it is supposed to do, let alone what's wrong wit hit
01:09:05 <tensorpudding> especially when you DeriveDataTypeable
01:09:10 <ivanm> ManateeLazyCat: to avoid having to go to another window
01:09:12 <ivanm> *shrug*
01:09:25 <ManateeLazyCat> ivanm: Switch window is automatic when you open pdf.
01:09:32 <ivanm> kamatsu: well, yes, that's a nice way of putting it ;-)
01:09:41 <ivanm> tolkad: learn to use Haskell before you try using it
01:09:45 <ManateeLazyCat> ivanm: And you won't lose anything since it's MVC design.
01:10:11 <ivanm> ManateeLazyCat: I wouldn't have it auto-switch, or at least make it configurable; some people (e.g. me) might not like random windows popping up
01:10:22 <ManateeLazyCat> ivanm: It can keep in child process to running even you switch it to invisible.
01:10:35 <ivanm> and I have no idea what "MVC" design is meant to be, but it sounds like one of those evil pattern things they tried to force into me in a 2nd year class at uni...
01:10:36 <ivanm> ;-)
01:10:51 <tensorpudding> MVC is what a decent number of web frameworks use
01:11:02 <Eduard_Munteanu> What's web? :P
01:11:07 <kamatsu> ivanm: MVC is basically separating IO from model, with a few more specific details thrown in
01:11:26 <kamatsu> ivanm: in my opinion, MVC has no real place in a purely functional language that does that separation anyway
01:11:27 <tensorpudding> you have a Model, that contains the data, the View, which provides an interface, and Controller which sorts things out
01:11:33 <ManateeLazyCat> ivanm: MVC (Model-View-Controller) mean you pdf-process still running in it's own process even you have switch to browser mode or other mode. 
01:11:40 <ivanm> kamatsu: ahhh, right
01:11:44 <ManateeLazyCat> ivanm: Just *View* not show.
01:11:57 <ivanm> kamatsu: so they're making a big hue and cry over what we try and do by default because it makes sense?
01:11:57 <ivanm> ;-)
01:12:00 <ManateeLazyCat> ivanm: But you *Model* and *Controller* still running in backend process.
01:12:03 * ivanm -> dinner
01:12:07 <kamatsu> ivanm: yes
01:12:14 <ManateeLazyCat> kamatsu: Really?
01:12:19 <Eduard_Munteanu> Something like Gtk does with the widgets and models where you actually put data in?
01:12:24 <Eduard_Munteanu> *like what
01:12:26 <abhaya> ivanm -> IRC
01:12:34 <ManateeLazyCat> Eduard_Munteanu: Like TextView and TextBuffer.
01:12:41 <ivanm> abhaya: no, I'm hungry and I want to eat dinner!
01:12:42 <kamatsu> so Model talks to View, View talks to Control, Control talks to MOdel.
01:12:45 <kamatsu> *Model
01:12:52 <Eduard_Munteanu> ManateeLazyCat: I see.
01:12:54 <ManateeLazyCat> Eduard_Munteanu: You can use TextBuffer keep file you current edit, TextView for view.
01:13:12 <kamatsu> imo the main advantage of MVC is just the separation of IO
01:13:17 <Eduard_Munteanu> Yeah, I used something similar for a list in Gtk2Hs.
01:13:17 <kamatsu> which we already do..
01:13:19 <kamatsu> so.. screw it
01:13:24 <tensorpudding> It became famous mostly because Ruby on Rails explicitly separates them
01:13:39 <Eduard_Munteanu> It fitted well with Haskellish concepts IMHO.
01:13:49 <ManateeLazyCat> ivanm: Do you use Emacs? My MVC framework more like Emacs' one, just every sub-module is running in separate process for crash-free.
01:14:08 <ManateeLazyCat> ivanm: Something like mix Emacs-Framework and GoogleChrome-Framework.
01:15:09 <tensorpudding> Huh, MVC was a Smalltalk innovation. Chalk up another to PARC.
01:15:37 <ManateeLazyCat> ivanm: It's too complicated for explain my idea, it's best to view my code after i release it. :)
01:15:48 <kamatsu> tensorpudding: most of the designy patternsy things came from Smalltalk
01:15:59 <kamatsu> alot of OO design theory came from smalltalk
01:16:16 <Eduard_Munteanu> Smalltalk was something.
01:16:17 <tensorpudding> MVC isn't really OO.
01:16:17 <kamatsu> ivanm: so, no luck checking if types are inhabited or not via constraints?
01:16:24 <ivanm> kamatsu: no idea tbh ;-)
01:16:30 <ivanm> not the kind of stuff I do
01:16:41 <ivanm> you'd be better off asking TacticalGrace...
01:16:47 <kamatsu> well, I wrote a perfectly normal operational transforms server
01:16:59 <kamatsu> and then I was like, hey, i can use fancy type system feature x..
01:17:04 * ivanm goes off to make & eat nachos
01:17:20 <kamatsu> and so now i have a gratuitious use of families and gadts etc.
01:17:56 <ManateeLazyCat> ivanm: Ok, so the result is: "Manatee-Core ==> Core and Toolkit" "Manatee-Editor" "Manatee-File-Manager" "Manatee-PDF-Viewer" "Manatee-Browser" "Manatee ==> Virtual package to mix all in one".
01:18:43 <ivanm> kamatsu: anyway, I asked before, might as well ask you: any idea if it's possible to write a function that does something like this: if this has a Show instance, then return "Just (show x(", otherwise, return Nothing ?
01:18:47 <ManateeLazyCat> "Manatee" is configuration package to mix *default* extension and plugin.
01:18:58 <ivanm> ManateeLazyCat: you can't really have virtual packages
01:19:11 <ivanm> you need to have some kind of code in every package
01:19:30 <aavogt> ivanm: do you know overlapping instances?
01:19:34 <aavogt> you'll need them
01:19:50 <ivanm> tried that
01:19:55 <altious> eh. haskell not as fast, as i expected ;)
01:19:58 <ManateeLazyCat> ivanm: That's another worried, i'm afraid Cabal can't do everything i want.
01:20:03 <ivanm> it doesn't like it when there's two overlapping instances :s
01:20:15 <kamatsu> ivanm: Couldn't you do it with a typeclass?
01:20:20 <ivanm> altious: that probably indicates that you didn't write it efficiently; Haskell can be quite fast if written correctly
01:20:30 <altious> ivan, sure
01:20:33 <kamatsu> class Foo x where
01:20:46 <ivanm> kamatsu: yeah, I tried that; but having both "instance (Show a) => Print a where ..." and "instance Print a where  ..." makes GHC complain
01:20:46 <kamatsu>    blah :: x -> Maybe String
01:20:53 <kamatsu> ivanm: no
01:20:57 <kamatsu> ivanm: just use a default method
01:21:04 <ManateeLazyCat> altious: Haskell is enough fast. IMO.
01:21:05 <kamatsu> the default implementation returns nothing
01:21:11 <kamatsu> the Show implementation returns show x..
01:21:12 <ivanm> kamatsu: I want it to automatically work for _any_ type...
01:21:25 <kamatsu> ivanm: yeah..?
01:21:28 <ManateeLazyCat> altious: And you can use Haskell write clean code efficiently.
01:21:31 <kamatsu> class Foo x where
01:21:36 <kamatsu>    blah :: x -> Maybe String
01:21:40 <ivanm> not having to explicitly write an instance for each type
01:21:41 <altious> any evident malpractices http://pastie.org/1038644 ?
01:21:42 <kamatsu>    blah _ = Nothing
01:21:58 <kamatsu> instance (Show a) => Foo a where
01:21:59 <ManateeLazyCat> kamatsu: Why not use deriving Show?
01:22:11 <kamatsu>    blah x = Just (show x)
01:22:13 <ivanm> altious: better off getting the digits library and using that
01:22:17 <ivanm> rather than show and pattern matching
01:22:22 <kamatsu> ManateeLazyCat: completely not what I want to do
01:22:46 <ivanm> kamatsu: yes, I can do that; but I can't then make all non-Show types return Nothing
01:22:58 <kamatsu> oh, right
01:23:04 <ivanm> since as soon as I have "instance Foo a where blah _ = Nothing", then I get duplicate instance problems
01:23:10 <altious> ivanm, i cannot imagine which numberical libraries could provide such functionality
01:23:20 <kamatsu> hm
01:23:26 <ivanm> the digits library!
01:23:27 <kamatsu> maybe there is a hacky way to do this
01:23:34 <ivanm> http://hackage.haskell.org/package/digits
01:23:38 <Eduard_Munteanu> Template Hacky!
01:23:52 <Heffalump> ivanm: yeah, I don't think the type system can express that because the instance head will really have to be 'a' in both cases
01:23:55 <altious> ivan, e.g. get set of numbers on specific positions?
01:23:59 <ivanm> kamatsu: I looked at oleg's site; he has 3 or 4 proposals; all of which require having explicit instances in some spot or another
01:24:02 <altious> *list
01:24:07 <ivanm> Heffalump: yeah, that's what I was afraid of :(
01:24:08 <kamatsu> ah
01:24:18 <ManateeLazyCat> ivanm: Now i understand i can't do everything, not technology reason, i haven't time finish everything.....
01:24:20 <kamatsu> i'm still many milliolegs short of a full oleg
01:24:29 <kamatsu> so I think if oleg can't do it, no one can
01:24:32 <altious> ivanm, sorry, i've got it )
01:24:47 <Eduard_Munteanu> That Oleg dude seems a legend...
01:24:49 <ManateeLazyCat> ivanm: Thanks for your suggestion, i will use your idea. :)
01:24:58 <kamatsu> Eduard_Munteanu: he's the unit of measurement of type system mastery
01:25:29 <ManateeLazyCat> kamatsu: Everything is possible.
01:25:30 <Eduard_Munteanu> kamatsu: heh, yeah, something like Uustalu & Vene for categorical stuff.
01:25:51 <kamatsu> ManateeLazyCat: Nope, for example, detecting if a type is inhabited in a constraint in GHC 6.12 is impossible
01:26:09 <PetRat> Using Control.Exception. I want to get rid of the lengthy type specifier on line 3, but without it the compiler complains of ambiguity. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27235#a27235
01:26:15 <ManateeLazyCat> kamatsu: But possible in the feature version. :)
01:26:22 <kamatsu> not necessarily
01:26:28 <kamatsu> i might bring it up to TacticalGrace
01:26:38 <kamatsu> and then he may have a really good reason why my idea is completely stupid
01:26:44 <ManateeLazyCat> kamatsu: If you want *do*, it's *must* possible...
01:26:50 <ivanm> PetRat: it's recommended you not use SomeException
01:26:53 <Heffalump> kamatsu: how would local resolution work with that kind of constraint?
01:26:56 <Eduard_Munteanu> What's TacticalGrace?
01:27:04 <Heffalump> you'd have to see the whole universe of types at once
01:27:11 <kamatsu> Eduard_Munteanu: GHC dev who happens to be my colleague and teacher.
01:27:14 <ivanm> Eduard_Munteanu: TacticalGrace == Manuel Chakravarty, a prof at UNSW
01:27:24 <PetRat> ivanm: does that relate to goal of getting rid of type indicator?
01:27:28 <Eduard_Munteanu> Gracenotes here?
01:27:33 <Eduard_Munteanu> I see.
01:27:38 <kamatsu> Eduard_Munteanu: no, TacticalGrace here
01:28:20 <ivanm> PetRat: my usual approach is to have something like: myTry :: IO a -> IO (EIther MyException a); myTry = try
01:28:21 <ManateeLazyCat> ivanm: I think you're vi user, right?
01:28:48 <ivanm> PetRat: it's recommended to not use SomeException because it wil even catch things like attempts to kill an app with Ctrl-c
01:28:51 <ivanm> ManateeLazyCat: no, emacs
01:29:09 <kamatsu> ivanm: get thee behind me, satan
01:29:11 <ManateeLazyCat> ivanm: Ok, i have some question about vi haskeller. :)
01:29:16 <ivanm> kamatsu: :o
01:29:23 <kamatsu> i am a vi-using haskeller
01:29:26 <PetRat> ivanm: I see. what if there are a number of exceptions I want to catch include "read: no parse", MyException, etc.
01:29:37 <ivanm> kamatsu: oh, I thought you were referring to what I was saying to PetRat ;-)
01:29:37 <kamatsu> although i use emacs for agda
01:29:43 <Eduard_Munteanu> I use vim too. Going to give yi a try though, at some point.
01:29:54 <kamatsu> i used yi awhile ago
01:29:55 <ManateeLazyCat> I'm not vi user, but i like vi keystroke design, something like "j/k/h/l", i wonder have other wonderful keystone?
01:29:56 <kamatsu> it's pretty nice
01:30:09 <ivanm> PetRat: in that case, it's usually recommended to have chains of try statements IIRC to catch the individual ones so you can do something different with each type of exception
01:30:10 <kamatsu> but it's not very well documented at the moment so I found customizing it difficult.
01:30:39 <kamatsu> ManateeLazyCat: vim has a few other gems too
01:30:52 * ivanm really goes off to have dinner this time
01:30:52 <ManateeLazyCat> kamatsu: Do you know any other keystroke in vi?
01:30:52 <Eduard_Munteanu> kamatsu: hm, I see, thanks for the heads up. I hope the haddock stuff will suffice.
01:30:57 <PetRat> ivanm: I'm not sure what a chain of try statements would look like, but give me a moment to try to figure it out. If I give up I'll ask you.
01:30:57 <kamatsu> the one thing about yi i really liked was the syntax-aware indentation.
01:31:13 <kamatsu> press space and the entire do block moves
01:31:15 <kamatsu> very nice.
01:31:16 <Eduard_Munteanu> ManateeLazyCat: d3wl?
01:31:21 <Eduard_Munteanu> :P
01:31:26 <ManateeLazyCat> Eduard_Munteanu: Link?
01:31:32 <kamatsu> ManateeLazyCat: sure, e.g . repeats the last action you did
01:32:01 <Eduard_Munteanu> ManateeLazyCat: that deletes 3 words
01:32:04 <Eduard_Munteanu> Ah, sorry, no 'l'
01:32:14 <Eduard_Munteanu> d3w
01:32:23 <ManateeLazyCat> Eduard_Munteanu: No, i mean *single* keystroke, like "j/k/h/l".
01:32:42 <kamatsu> ManateeLazyCat: why do you want to know? seems very arbitrary
01:32:45 <kamatsu> ManateeLazyCat: Just learn vim
01:32:52 <Eduard_Munteanu> Dunno, 'u'?
01:32:54 <Eduard_Munteanu> for undo.
01:33:07 <ManateeLazyCat> kamatsu: I'm a emacser. :)
01:33:13 <ManateeLazyCat> kamatsu: I use one-key.el
01:33:20 <ManateeLazyCat> kamatsu: For remember keystroke
01:33:31 <Eduard_Munteanu> 'p' for paste.
01:33:43 <Eduard_Munteanu> There are quite a lot, not so hard to come by.
01:34:09 <ManateeLazyCat> kamatsu: I use http://www.emacswiki.org/emacs/OneKey for press *single* keystroke, but Emacs help me remember all keystroke.
01:34:55 <ManateeLazyCat> kamatsu: When you press *single* keystroke recursively, i can do something like "d3wl"
01:34:59 <Eduard_Munteanu> kamatsu: I'd really like to do one thing vim can't: put a line/markup at the 80th column
01:35:16 <Eduard_Munteanu> irrespective of whether the line has any characters on it or not.
01:35:23 <ManateeLazyCat> Eduard_Munteanu: Do you know any other *single* keystroke?
01:35:35 <Eduard_Munteanu> And I'm hoping yi is scriptable enough.
01:35:53 <Eduard_Munteanu> ManateeLazyCat: yeah, 'x', for deleting a char.
01:36:14 <Eduard_Munteanu> But really there are lots. See the docs.
01:36:19 <ManateeLazyCat> Eduard_Munteanu: If you press space for scroll up one screen, so which keystroke to scroll down?
01:36:22 <Eduard_Munteanu> or 'o' for appending a new line.
01:36:57 <Eduard_Munteanu> ManateeLazyCat: um, I use pageup/pagedown usually.
01:37:20 <ManateeLazyCat> Eduard_Munteanu: In emacs, i use *space* scroll-up, *e" scroll-down. :)
01:38:03 <ManateeLazyCat> Eduard_Munteanu: I don't like move finger too far. :)
01:38:58 <PetRat> When you get "Exception: Prelude.read: no parse" what type of Exception is that?
01:39:04 <Eduard_Munteanu> ManateeLazyCat: yeah, that's true.
01:39:57 <ManateeLazyCat> Eduard_Munteanu: I'm not vi user, but i'm curious, you can use "d3wl" delete 3 words, but looks vi need switch between "command-mode" and "edit-mode" frequently? That's not painful?
01:40:54 <Eduard_Munteanu> ManateeLazyCat: not really painful, you generally use 'i' to switch to insert mode and 'ESC' to go back.
01:41:04 <alpounet_> hi
01:41:14 <Eduard_Munteanu> ManateeLazyCat: generally you shouldn't stay in insert mode unless you're typing text.
01:41:43 <alpounet_> does `all some_predicate some_list' stops testing list elements if the predicate fails at some moment on the list ? 
01:41:55 <ManateeLazyCat> Eduard_Munteanu: IMO, Emacs's keystroke is hard to press than vi. But in emacs, you can use M-* A-* something for command control, and use character to insert.
01:42:09 <Yrogirg> Hello! What's bad with this data type? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27236#a27236
01:42:34 <ManateeLazyCat> Eduard_Munteanu: I always mix "command operation" and "insert operation".
01:43:55 <Eduard_Munteanu> ManateeLazyCat: ah, you mean you have keystrokes to execute commands one-shot.
01:44:03 <Eduard_Munteanu> and return to inserting automatically.
01:44:10 <Eduard_Munteanu> Yeah, that's useful at times.
01:45:40 <ManateeLazyCat> Eduard_Munteanu: In emacs, you can use keystone execute command and don't touch buffer's insert status, when you want insert character, just typing character.
01:45:48 <ManateeLazyCat> Eduard_Munteanu: Don't need switch.
01:46:57 <Eduard_Munteanu> ManateeLazyCat: interesting, I don't know if that's possible in Vim (at least with the default bindings). Still, is it possible to switch to a permanent command mode in Emacs?
01:47:14 <Eduard_Munteanu> i.e. to make commands shorter if you're using lots at the present moment.
01:49:17 <ManateeLazyCat> http://www.emacswiki.org/emacs/OneKey
01:50:04 <ManateeLazyCat> Eduard_Munteanu: I develop one-key.el for let emacs remember for me, but it's still need switch something.
01:50:20 <ManateeLazyCat> Eduard_Munteanu: But i can mix "command" and "insert"
01:50:40 <ManateeLazyCat> Eduard_Munteanu: http://www.emacswiki.org/emacs/OneKey#toc11
01:51:11 <ManateeLazyCat> Eduard_Munteanu: It's not perfect, but much better than Emacs's default design.
01:51:25 <Eduard_Munteanu> I see.
01:52:34 <Yrogirg> nvm my question, I've solved it
01:53:20 <ManateeLazyCat> Eduard_Munteanu: vi's keystroke design is awesome for editor, but i think it's not suit mix environment that not just editor. Like my screenshot : http://farm5.static.flickr.com/4135/4771506102_4cccd58e8d_b.jpg
01:54:09 <ManateeLazyCat> Eduard_Munteanu: I don't like switch "command mode" "insert mode" frequently even "command mode" is really efficient.
01:55:31 <Eduard_Munteanu> ManateeLazyCat: oh, you're wondering whether to use Vi-like looks/feels on other kinds of applications.
01:55:38 <Eduard_Munteanu> ManateeLazyCat: have you seen Vimperator?
01:55:44 <ManateeLazyCat> Eduard_Munteanu: Yes.
01:56:06 <shachaf> vi doesn't have command-mode/insert-mode!
01:56:12 * shachaf wonders if this is a bad argument to get into.
01:56:13 <Twey> I think it's much better suited to e.g. a browser than to a text-editor.  Browsers require you to bugger about mode-shifting much less.
01:56:19 <ManateeLazyCat> Eduard_Munteanu: I want use Vi keystroke for all navigation buffer, such as file-manager, browser.
01:56:42 <ManateeLazyCat> Eduard_Munteanu: You can control those read-only buffer as Vi's keystroke.
01:57:05 <ManateeLazyCat> shachaf: Just for explain my point, not mean mode.
01:57:38 <shachaf> ManateeLazyCat: No, not you, me. :-)
01:57:53 <ksf> yep. real men don't need cursor keys while inserting
01:58:29 <ksf> insert "mode" is not so much a mode as a plain line buffer.
01:58:36 <ManateeLazyCat> Eduard_Munteanu: For editor, i perfer to use Emacs's keystroke, but for read-only mode, like file-mamager, browser, i prefer to use Vi keystroke design.
01:58:50 <shachaf> ksf: Insert "mode" is not so much a mode as an Escape-terminated command.
01:58:53 <ManateeLazyCat> Eduard_Munteanu: That's why i ask *single* keystroke in vi. :)
01:59:15 <ksf> in the olden days, vi wouldn't shift letters to the right as you inserted stuff, to save terminal bandwidth
01:59:32 <ksf> shachaf, yep, exactly. but vim makes it a mode
01:59:39 <Eduard_Munteanu> ManateeLazyCat: ah, I see your point.
01:59:56 <Eduard_Munteanu> Commands that work in insert mode.
01:59:58 <shachaf> ksf: In what sense does vim make it a mode?
02:00:11 <shachaf> 3iabc<esc> inserts abcabcabc
02:00:21 <ksf> you can exectude a hell a lot of stuff inside edit mode
02:00:28 <ManateeLazyCat> Eduard_Munteanu: So global keymap still use Emacs's Control-Alt-Shift keystroke, when i switch to *local* keymap, vi's keystroke is efficient. :)
02:01:28 <shachaf> ksf: Hmm, I suppose that's true.
02:01:44 <ManateeLazyCat> IMO, vi's keystore just wonderful for navigation in read-only buffer.
02:02:23 <shachaf> ksf: There's an (Esc-terminated) "insert mode" about as much as there's a (Ret-terminate) "search mode".
02:02:24 <Eduard_Munteanu> Technically, as ksf says, if you adopt a certain working style, switching becomes less of a problem.
02:02:26 <ksf> there's command, edit, visual (line/block) and ex mode.
02:02:51 <ksf> oh yes, search. that's distinct from ex.
02:02:55 <shachaf> Also replace.
02:03:07 <ksf> let's call it regex mode.
02:03:09 <Eduard_Munteanu> That goes with 'edit'
02:03:18 <shachaf> ksf: I mean 'R'-replace.
02:03:37 <ksf> *shudder*
02:03:41 <ksf> there's c, you know.
02:03:49 <ManateeLazyCat> Eduard_Munteanu: I use vimium operation Chrome like Vi, i want bring it to my own browser. :)
02:04:08 <Eduard_Munteanu> cw and friends is better, yeah.
02:04:15 <Twey> http://www.chromeextensions.org/other/vrome/
02:04:42 <Eduard_Munteanu> ManateeLazyCat: yeah, I use Vimperator too, it's really neat.
02:05:19 <ksf> .oO( c/foo<ret> )
02:05:31 <Eduard_Munteanu> And 'f' mode (key navigation) is really smart.
02:05:37 <shachaf> I always forget that you can use / that way.
02:05:47 <shachaf> I should force myself to do it for a while.
02:06:13 <ksf> I think the real power of vi comes from combination, not from single strokes
02:06:26 <ManateeLazyCat> Now i will release my project as soon as possible, let more people help me perfect it.
02:06:38 <ManateeLazyCat> The next thing is integrate haskell-interperter in it.
02:06:44 <ManateeLazyCat> after release
02:06:47 <Eduard_Munteanu> I usually use visual line to select then : and type the s command in to replace, if I have to do it on larger blocks.
02:06:53 <ksf> someone should extend the vi mode of yi so that it isn't a joke.
02:07:26 <Eduard_Munteanu> Ah, that makes me think whether I want to waste time on Yi :)
02:07:27 <ManateeLazyCat> ksf: Something like "d3wl" delete 3 words?
02:07:28 <ksf> ...especially the ex mode. basic things like line ranges are missing iirc
02:07:35 <Eduard_Munteanu> without the 'l'
02:07:44 <Eduard_Munteanu> ManateeLazyCat: ^
02:07:47 <shachaf> ksf: Yes, for N+M commands you get N*M combinations, as one person put it.
02:07:55 <ManateeLazyCat> Eduard_Munteanu: Editor in my project is base on GTK+ backend.
02:07:58 <shachaf> How's Yi? I haven't looked at it for a long time.
02:08:13 <ManateeLazyCat> Eduard_Munteanu: So it's more like Emacs
02:08:20 <ManateeLazyCat> Eduard_Munteanu: And not like Vi.
02:08:40 <Eduard_Munteanu> ManateeLazyCat: well, if you want to make it friendly, you shouldn't go the Vi way.
02:08:40 <ksf> it's the best bet to ever get a vi in leksah
02:08:44 <ManateeLazyCat> Eduard_Munteanu: But my project will integrate everything in one place, you don't type "M-Tab" to switch in different application.
02:08:59 <ManateeLazyCat> Eduard_Munteanu: Yeap
02:09:09 <ksf> dunno if leksah should wrap yi or the other way round, though.
02:09:26 <ManateeLazyCat> Eduard_Munteanu: Vi's is cool, but i think most newbine don't know how to operation it when first time use it.
02:09:32 <ManateeLazyCat> Eduard_Munteanu: Not friendly
02:09:42 <Eduard_Munteanu> Mmm, IDE, makes me cringe.
02:09:48 <ksf> I think a generic menu/windowing/widget thing is a thing that wouldn't be a bad feature for an editor.
02:09:57 <ManateeLazyCat> Eduard_Munteanu: I call it ILE
02:10:06 <ManateeLazyCat> Eduard_Munteanu: The Haskell/Gtk+ Integrated Live Environment
02:10:07 <ksf> and yi is eight megabytes and continuous swapping already anyways.
02:10:08 <Eduard_Munteanu> ManateeLazyCat: ah, no, I was referring to Leksah
02:10:23 <Eduard_Munteanu> Probably won't try it.
02:10:53 <ManateeLazyCat> Eduard_Munteanu: Since Yi, Leksah and my project all base on gtk2hs, i hope we will share same toolkit for editor. 
02:11:11 <Eduard_Munteanu> ksf: yeah. Vim/Gvim could be better I suppose.
02:11:18 <Eduard_Munteanu> But they are functional.
02:11:31 <ManateeLazyCat> Eduard_Munteanu: I even can embedded Emacs/Vi in my project if you just want use vi. :)
02:12:17 <ManateeLazyCat> Eduard_Munteanu: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
02:12:32 <Eduard_Munteanu> Basically you need to embed xterm in there :)
02:12:33 <ManateeLazyCat> Eduard_Munteanu: I'm guess it's too evil . :)
02:13:08 <ManateeLazyCat> Eduard_Munteanu: No, i plan to develop new terminal emulator base on Cariro/Gtk+
02:13:14 <ManateeLazyCat> Eduard_Munteanu: xterm is not MVC design.
02:13:44 <ManateeLazyCat> Eduard_Munteanu: You can't continue running command in xterm after you destroy is't render window.
02:14:12 <ManateeLazyCat> Eduard_Munteanu: I even build vte (terminal widget that use by gnome-temrinal) binding at hackage.
02:14:16 <Eduard_Munteanu> ManateeLazyCat: um, would 'screen' help you?
02:14:32 <ManateeLazyCat> Eduard_Munteanu: Unfortunately, vte widget is not MVC design.
02:14:48 <ManateeLazyCat> Eduard_Munteanu: You can use *screen* view different part of same terminal?
02:15:02 <Eduard_Munteanu> I don't think so.
02:15:12 <ManateeLazyCat> Eduard_Munteanu: Yep, that's what i want do.
02:15:40 <ManateeLazyCat> Eduard_Munteanu: You can view different part of *same* temrinal, and not split two window to view different terminal.
02:15:50 <ManateeLazyCat> Eduard_Munteanu: That's why i don't like xterm and vte. 
02:16:21 <ManateeLazyCat> Eduard_Munteanu: In http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png , i use 'vte' as temrinal, as you see, it's not MVC i want.
02:16:42 <Eduard_Munteanu> Well a hackish way to do it would be to use some sort of Xnest that works in your model, and spawn Xterms inthere :)
02:17:29 <Eduard_Munteanu> Yeah.
02:17:34 <ManateeLazyCat> Eduard_Munteanu: I prefer like MultiTerm in Emacs (http://www.emacswiki.org/emacs/MultiTerm).
02:17:49 <Eduard_Munteanu> I think you can scroll some VNC/Xnest :P
02:18:04 <ManateeLazyCat> Eduard_Munteanu: Xnest?
02:18:27 <ManateeLazyCat> Eduard_Munteanu: I hope it's a natural way to get different view for same model, and not *hacking* way ... :)
02:18:34 <Eduard_Munteanu> ManateeLazyCat: it's an X server you can spawn inside a window of a real X server.
02:18:42 <Eduard_Munteanu> No, not really natural.
02:20:01 <ManateeLazyCat> Eduard_Munteanu: My project is use GtkSocket/GtkPlug (base on XEmbeded protocol), from my experience, once you embedded X window in Gtk+ widget, you can't render same X window in other Gtk+ widget.
02:20:34 <ManateeLazyCat> Eduard_Munteanu: So Xnest perhaps not help with Gtk+ framework, must design MVC when you coding it.
02:24:46 <ManateeLazyCat> Eduard_Munteanu: I will reading resource of Xnset, thanks for link. :)
02:24:51 <akosch> can someone tell me why this thing runs into stack space overflow after some time? http://pastebin.com/f6c8XJ2R
02:24:57 <ManateeLazyCat> s/link/hint
02:25:47 <ManateeLazyCat> akosch: [1..] ?
02:26:08 <akosch> well the list should be garbage collected
02:27:48 <akosch> so any ideas?
02:30:47 <ClaudiusMaximus> @unpl uncurry ((. take 1)  . (++))
02:30:48 <lambdabot> uncurry (\ d g -> d ++ (take 1 g))
02:31:26 <ManateeLazyCat> Eduard_Munteanu: If Xnest can work, then i can embedded any gtk+/qt program in my project, and don't care it whether MVC design.
02:31:57 <Eduard_Munteanu> ManateeLazyCat: nah, don't count on that, it was said tongue-in-cheek
02:32:30 <ManateeLazyCat> Eduard_Munteanu: I know my project is evil. :)
02:32:35 <shachaf> akosch: It seems to work for me.
02:33:02 <ClaudiusMaximus> akosch: maybe try mapM_ instead of mapM
02:33:19 <ClaudiusMaximus> :t (mapM, mapM_)
02:33:20 <lambdabot> forall a (m :: * -> *) b a1 (m1 :: * -> *) b1. (Monad m, Monad m1) => ((a -> m b) -> [a] -> m [b], (a1 -> m1 b1) -> [a1] -> m1 ())
02:33:21 <akosch> it works for me too for some time
02:33:32 <shachaf> (Yes, you do want mapM_.)
02:33:37 <akosch> when i run it for a few hours i get stack space overflow
02:34:09 <shachaf> akosch: Note that main prints out a long list of [()..].
02:34:19 <ManateeLazyCat> Eduard_Munteanu: I'm dream this solution for all x11 program, adopter will take all render request from x11 program, then it render graphics in different *view* synchronous.
02:34:24 <akosch> but thanks for the suggestion, i will try mapM_
02:34:25 <shachaf> akosch: That's because of mapM.
02:35:04 <ClaudiusMaximus> type signatures would help - if you added    main :: IO ()   then it wouldn't typecheck as-is
02:35:19 <akosch> thanks again :)
02:37:03 <PetRat> This fails to catch a DivideByZero like I expected. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27237#a27237  What am I doing wrong? 
02:37:58 <shachaf> akosch: By the way, do you really find that code clearer in completely point-free style?
02:39:04 <ClaudiusMaximus> maybe it would be more efficient than replicateM applied separately to lots of args?  > words = map (:[]) chars ++ [ c : w | w <- words, c <- chars ]
02:40:07 <ClaudiusMaximus> > let chars = "aA@" in let words = map (:[]) chars ++ [ c : w | w <- words, c <- chars ] in take 15 words
02:40:08 <lambdabot>   ["a","A","@","aa","Aa","@a","aA","AA","@A","a@","A@","@@","aaa","Aaa","@aa"]
02:40:10 <PetRat> Oh, I remember. It's dreaded laziness meaning the thunk isn't evaluated until outside the try.
02:40:58 <akosch> shachaf: yeah, i will get around to do that too sometime :)
02:41:10 <ksf> ...you should'nt be dividing by zero in the first place, that's what's going wrong.
02:45:26 <ClaudiusMaximus> so my current project is working (v0.1) and optimized as far as i can (v0.2), but i still need to edit source and recompile to change what should be runtime options - is there a nice .ini/.rc file parser that someone can recommend?
02:45:54 <ClaudiusMaximus> i'll want to integrate it with command line arguments too; and sane defaults for each option..
02:46:21 <kmc> ClaudiusMaximus, for "edit and recompile" done right, see http://hackage.haskell.org/package/dyre
02:47:39 <kmc> otherwise maybe http://hackage.haskell.org/package/console-program is what you want?
02:48:03 <PetRat> ksf: is that a joke? I can't quite tell.
02:48:55 <ClaudiusMaximus> console-program is more along the lines of what i was thinking, dyre seems slightly heavyweight/overkill
02:49:24 <kmc> dyre is nice if you need config files with full abstraction and flexibility
02:49:47 <kmc> config files are almost the canonical example of something that starts out simple and becomes a weird ad-hoc general-purpose programming language
02:50:06 <kmc> so it can be worthwhile to preempt that by using e.g. Haskell or Python as your config language
02:51:40 <kmc> PetRat, did your earlier question about Typeable get answered?
02:51:52 <PetRat> Still stuck: can someone tell me how to force evalution of the thunk before the try?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27237#a27237
02:51:57 <ClaudiusMaximus> fair point - but right now it's total overkill and i just want to save 30 seconds each time i want to tweak a setting :)
02:52:01 <kmc> :t Control.Exception.evaluate
02:52:02 <lambdabot> forall a. a -> IO a
02:52:09 <kmc> PetRat, ^^^^
02:52:37 <PetRat> kmc: I have a hazy understanding, something to do with providing a mechanism for describing types, which leads to an ability to typecast, or something
02:52:40 <Taejo> does anyone else find it irritating that having *.o files around makes ghci *less* useful?
02:53:10 <kmc> PetRat, yeah.  it just lifts types into runtime, and provides a typecast operator which is useful for dynamically typed values, generic programming and the like
02:53:23 <kmc> Taejo, yes.  «:m + *Foo» to load Foo interpreted, iirc
02:53:31 <ClaudiusMaximus> Taejo: speed -vs- inspectability tradeoff?
02:53:36 <Taejo> oh, that helps
02:53:48 <PetRat> kmc: evaluate works 
02:53:51 <kmc> PetRat, so one quite simple library that uses Typeable is Data.Dynamic
02:54:44 <Taejo> ClaudiusMaximus: if I'm in ghci, I'm generally going for inspectability; but if there's a choice, I'm ok (though I still think it's the wrong default)
02:54:58 <kmc> PetRat, the fact that your "process" do-block is only a let and a return should indicate that you're not getting anything out of that monad
02:56:20 <kmc> what you have boils down to «try $ return (10 `div` read s)»
02:56:58 <PetRat> kmc: "not getting anything out of it" in what sense? nothing evaluated? no useful purpose for existence?
02:57:22 <kmc> you're not invoking any "special powers" of the monad.  you're just using "return"
02:57:31 <kmc> which by definition uses none of the special powers
02:57:51 <kmc> and indeed, "process" is by itself not IO-monad specific... it's only when you pass it to "try" that the type is fixed to IO
02:57:57 <zygoloid> i have f :: Work -> (Result, [Work]), which produces a list of additional work items to perform. i want to run all the work items (once each) and return a list of (Work,Result) pairs
02:58:11 <kmc> process :: (Read a, Monad m, Integral a) => String -> m a
02:58:14 <PetRat> kmc: well this is an initial test before it gets more complicated. I have an existing application which I want to add exception handling to.
02:58:20 <kmc> ok
02:58:54 <PetRat> kmc: do you happen to know the Exception type of a read parse error?
02:58:55 <zygoloid> i'd like to write that as: let work = nub $ initialWork ++ concat extraWork; (results, extraWork) = unzip (map f work) in zip work results
02:59:26 <zygoloid> but that seems impossible: there's no way i can see, while tying the knot, to get the 'work' list to end in [] rather than _|_.
02:59:43 <zygoloid> is there a composable way of doing this (where i can use nub rather than reimplementing it)
03:05:32 <kmc> PetRat, don't know.  you can check it with (\(SomeException e) -> show $ typeOf e)
03:05:34 <ksf> PetRat, use reads
03:05:38 <ksf> :t reads
03:05:39 <lambdabot> forall a. (Read a) => String -> [(a, String)]
03:05:40 <kmc> also, it will be different for read vs. readIO
03:05:59 <ksf> don't try to catch exceptions in pure code. that way lies insanity.
03:06:18 <ksf> ...the default catch doesn't work, and if you use one that works, it's non-portable.
03:06:29 <ksf> those exceptions aren't meant to be caught.
03:11:34 <kmc> ksf, catch in pure code, or catch exceptions thrown from pure code?
03:12:08 <kmc> to drop the purity terminology: catch by eval, or catch by exec what's thrown by eval?
03:12:22 <ksf> both.
03:12:33 <ksf> pure code should be total.
03:13:01 <kmc> the "default catch" is the H98 IOError stuff?
03:13:08 <ksf> yep
03:13:12 <ksf> the prelude one
03:20:13 <zygoloid> yuck, well, i got it working, but i'm not happy with the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27239#a27239  any ideas how to improve this?
03:20:47 <Ke> how would I force repoman back to upstream repository=
03:31:06 <PetRat> kmc: I was away but I see your idea about testing type
03:47:50 <PetRat> Are elegant short solutions that happen to be inefficient embraced in Haskell as one, not the only, desired feature?
03:49:00 <ivanm> huh?
03:49:04 <ivanm> wtf are you talking about?
03:49:18 <ivanm> we don't go out of our way to make our code inefficient if that's what you're meaning
03:51:14 <PetRat> Given a problem X, several people submit solutions A, B, and C. A is short and elegant but inefficient in space or time. Is A nevertheless admired for its brevity and considered something to learn from or strive for?
03:51:26 <kamatsu> not really
03:51:49 <kamatsu> if greater efficiency is required, don't strive for an inefficient solution
03:52:47 <PetRat> I mean that everything can be learned from. Every problem, when solved, brings at least a little new wisdom that can be used somewhere else. .....
03:52:50 <kamatsu> however if the inefficient solution is easier and it doesn't need to be efficient, then general programming practice says that you should use the inefficient solution if it is more maintainable
03:52:59 <ivanm> if the cost of the simpler solution is minimal, then usually you go with the simpler, more elegant solution unless its in a highly critical spot
03:53:04 <ivanm> AFAIK, that is done in _all_ languages
03:53:09 <kamatsu> yes
03:53:11 <ivanm> since you want to be able to understand and maintain your code
03:53:46 <Saizan> PetRat: when you have an elegant solution, it's a reason to try to make the efficient one as elegant as the first
03:53:55 * hackagebot wumpus-core 0.21.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.21.0 (StephenTetley)
03:53:55 <PetRat> Haskell textbook examples include some marvelously short programs, like the sieve of erastothones. Beginners learn from this at least.
03:54:21 <zygoloid> PetRat: pick the simplest, most elegant, most readable solution which meets your requirements (whether they be functional requirements, performance requirements, memory requirements or whatever else)
03:54:28 <PetRat> Saizan: yes, that's an interesting point. The elegant solution casts light on the problem.
03:55:24 <Saizan> e.g. some years ago shootout entries required all kinds of lowlevel tricks, now we get the efficiency with higher level code, because of improvements in both libraries and GHC
03:55:25 <zygoloid> so yes, elegant, short solutions are embraced as having a desirable feature.
03:55:40 <ivanm> PetRat: that isn't the real sieve of erastothones
03:55:48 <ivanm> @google the real sieve of erastothones haskell
03:55:49 <lambdabot> No Result Found.
03:55:51 <PetRat> zygoloid: your answer comes from a "production" perspective in which something needs to get done and you are using Haskell to do it. I'm a Haskell hobbyist and more in a learning mode, wandering leisurely through Haskell land.
03:55:51 <ivanm> bah
03:55:55 * hackagebot wumpus-basic 0.2.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.2.0 (StephenTetley)
03:55:57 * hackagebot wumpus-microprint 0.2.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.2.0 (StephenTetley)
03:56:10 <tensorpudding> @google the genuine sieve of eratosthenes
03:56:12 <lambdabot> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
03:56:12 <lambdabot> Title: The Genuine Sieve of Eratosthenes
03:56:34 <zygoloid> PetRat: yes, that's true. but even hobbyists have some requirements (even unwritten ones, like "have fun") :)
03:57:00 <kamatsu> PetRat: I would say if you're learning then you shouldn't strive to match inefficient solutions
03:57:02 <Saizan> "don't overheat my cpu"
03:57:12 <ivanm> tensorpudding: that's the one
03:57:17 <kamatsu> PetRat: instead strive to understand the efficiency/elegance tradeoffs of various solutions
03:57:17 <ivanm> real, genuine; same diff
03:57:18 <ivanm> ;-)
03:57:34 <ivanm> kamatsu: good point
03:57:55 <ivanm> in those cases, it's often nice to wrap an ugly but efficient data structure/API in a much nicer API
03:58:01 <tensorpudding> That paper is really popular.
03:58:13 <ivanm> (that is, when you absolutely need performance at can't do so elegantly directly)
03:58:20 <tensorpudding> Is there a high demand for implementing lists of primes?
03:58:35 <ivanm> not really AFAIK
03:58:56 <tensorpudding> I used it as the basis for a mini primality library for project euler
03:59:11 <kamatsu> ivanm: my main gripe with haskell is that we can't abstract pattern matches nicely ('cept view patterns)
03:59:19 <kamatsu> imo scala handles this better
03:59:25 <ivanm> oh? what kind of abstractions do you mean?
03:59:30 <kamatsu> well
03:59:32 <kamatsu> if i have a tree
03:59:47 <kamatsu> Node Val Left Right | Leaf Val
03:59:52 <kamatsu> easy implementation
04:00:07 <kamatsu> suppose i have some faster, but much uglier, implementation
04:00:25 <kamatsu> it would be nice to be able to substitute the implementation behind the scenes in the data constructors and patterns
04:00:37 <kmc> PetRat, i think elegant obviously-correct solutions are valuable even when inefficient.  they are often good reference implementations for testing the more efficient solution
04:00:54 <Blkt> good day everyone
04:01:04 <kmc> PetRat, you can write everything that way, then profile, then replace only what you need to
04:01:44 <kamatsu> PetRat: Also, haskell does trade away some performance gains for elegance, in that immutability by default does add a performance cost
04:01:45 * ivanm waves idly in Blkt's general direction
04:01:59 <kmc> yes, but it's still only a default
04:02:19 <PetRat> These are interesting answers. It's worth asking a question even if kinda dumb just to get some insight into peoples' thought processes.
04:02:27 <kamatsu> however restructuring to mutable has a significant impact on the design of your program
04:02:29 <ivanm> kamatsu: can you provide an actual example syntactic wise of what you mean?
04:03:00 <kamatsu> ivanm: i'm saying that you can't pattern match on an abstract data type
04:03:18 <ivanm> but you can in scala?
04:03:20 <ivanm> how do they do it?
04:03:21 <kamatsu> yes
04:03:33 <ivanm> sounds a bit like view patterns...
04:03:35 <kamatsu> yeah
04:03:42 <kamatsu> it's alot like view patterns
04:03:43 <kamatsu> except
04:03:53 <kamatsu> 1) you can construct data types that way
04:04:09 <kamatsu> 2) it looks like an ordinary pattern match
04:04:33 <ivanm> hmmm, maybe view-patterns + some type class magic for the constructor bit? ...
04:04:42 <illissius> so s/view patterns/views/ then?
04:04:49 <kamatsu> illissius: yeah
04:04:49 <illissius> iirc i read about "views" somewhere and it was that.
04:04:54 <kamatsu> right
04:05:21 <kamatsu> ivanm: also, view patterns are uglier than normal pattern matches which makes me sad.
04:05:58 <kamatsu> switching to an abstract underlying data structure means the elegance of your higher level algorithm can be clouded by syntactic noise
04:05:58 <augur> gooood morning peoples
04:06:09 <kmc> 'In other languages, once you succeed in the arduous task of getting your program to work, it may already be acceptably efficient... Someone used to developing software on this principle may find it difficult to overcome the idea that when a program works, it's finished. "In Lisp you can write programs in no time at all," he may think, "but boy, are they slow."'
04:06:11 <kmc> 'In this respect, using Lisp is like living in a rich country instead of a poor one: it may seem unfortunate that one has to work to stay thin, but surely this is better than working to stay alive, and being thin as a matter of course.'
04:06:18 <ivanm> kamatsu: well, they couldn't exactly _replace_ normal pattern matches...
04:06:19 <kmc> PetRat, ^^^^
04:06:21 <augur> anyone familiar with unification theory?
04:06:26 <ivanm> it's just a syntactic replacement, isn't it?
04:06:47 <kmc> kamatsu, what do you mean by (1)?
04:07:19 <kamatsu> kmc: essentially i mean i want to  define a data constructor that can be matched on
04:07:41 <kamatsu> kmc: but actually bears no relation necessarily to the actual implementation of a data structure
04:09:13 <kamatsu> it's mostly a syntactic complaint, just writing a constructor function and a view pattern do the trick but it means that using an abstract data type underneath your algorithm requires screwing around with the syntax and imo looks uglier
04:10:16 <kamatsu> i like the way scala has no distinction
04:10:29 <kamatsu> my gripe with scala is that the syntax of type decls is horrid
04:12:16 <kamatsu> i have way more complaints about scala than haskell, so i use haskell, but yeah, that one feature of scala is nice
04:14:18 <gwern> kmc: I like the obesity analogy
04:15:18 <kmc> :)
04:15:28 <PetRat> kmc: pretty amusing
04:15:28 <kmc> it's a quote from _On Lisp_
04:17:11 <kamatsu> hm
04:17:13 <kamatsu> actually
04:17:21 <kamatsu> looking at the viewpatterns trac page
04:17:38 <kamatsu> does the GHC ViewPatterns extension include a distinguished "View" typeclass for default views?
04:17:52 <kamatsu> cos that would basically address my complaint 
04:18:06 <aavogt> not that I've seen
04:18:09 <zygoloid> no
04:18:50 <illissius> here's a views proposal for haskell, if it hasn't been linked in the interim while my computer was being a dick: http://www.haskell.org/development/views.html
04:19:07 <illissius> (just look at the examples :)
04:19:24 <aavogt> @quote view.*pattern
04:19:24 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
04:20:46 <kamatsu> illissius: that's exactly what i want
04:21:26 <kamatsu> although view patterns WITH a default typeclass are also fine
04:23:36 <kmc> adding a new declaration form for views seems like overkill
04:23:51 <kmc> since it does essentially the same thing as an instance decl
04:24:16 <kamatsu> yeah
04:24:33 <kamatsu> the main thing i am  thinking about is ease of refactoring
04:24:33 <kmc> but i guess this document predates MPTC
04:24:51 <kamatsu> if i decide to abstract out a data type that previously was not abstract
04:24:57 <kamatsu> that is currently a world of pain
04:26:21 <kamatsu> if we have the same syntax for matching on views as we do datacons, then it would be as simple as defining a view that is the same as the old type for the new abstract one
04:29:43 <illissius> kamatsu: according to http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns even with a default type class the syntax would be different (-> ...)
04:31:05 <kamatsu> illissius: yes, but this at least isn't too hard to add
04:31:18 <kamatsu> i understand why you need differentiating syntax
04:32:27 <kamatsu> i don't like the => or detupling or demaybe-ing proposals though
04:33:01 <kamatsu> my main complaint is that -> looks funny without anything next to it
04:42:22 <kmc> what about types with more than one sensible view
04:42:23 <kmc> like Seq
04:43:42 <kamatsu> then you can use the -> notation as normal
04:43:52 <kamatsu> and have one as default
04:44:10 <kamatsu> (perhaps the list-like one)
04:57:34 <kmc> eh it's ugly to pick one
04:57:48 <kamatsu> or just don't specify a default?
04:57:50 <kmc> i'd just as soon have no View instance for Seq
04:57:56 <kamatsu> yeah
04:58:02 <kmc> or use a View class with no fundep, so it knows based on which ctors you map against
04:58:09 <kmc> but that has consequences elsewhere
04:58:11 <kamatsu> that would be nice
04:58:14 <kamatsu> hm?
04:59:38 <kmc> more ambiguity errors
05:00:14 <kmc> you'd have to have a signature for the thing you're viewing
05:00:19 <kmc> though, if the fundep went the other way
05:00:33 <kmc> view type determines hidden type
05:00:48 <kmc> then all you lose is the ability for two types to project to the same view
05:00:56 <kmc> i imagine lots of people will want their views to be lists or tuples
05:01:09 <kmc> but arguably they shouldn't do that
05:01:15 <kmc> it's a bit hard to argue against lists, since they have special syntax
05:03:29 <zeiris_> Are the Bool/Num instances of Monoid any real use?
05:03:58 <Cale> zeiris_: yes
05:04:13 <aavogt> how would you deconstruct multiple components without lists or tuples, kmc?
05:04:23 <dolio> I've seen them used with Writer.
05:04:31 <Cale> zeiris_: See things like the writer monad, and the Foldable instance for various structures.
05:05:06 <kmc> aavogt, using a custom view type
05:05:15 <kmc> like Seq does
05:05:16 <kmc> anyway bbl
05:06:41 <zeiris_> Sorry, I shoulda specified: the Any Bool/All Bool/etcetera, not straight bool.
05:11:54 <aavogt> there's a shortage of pretty constructors if everybody does that
05:23:47 <fxr> I'll try to interact with a device via telnet, do you know any libraries for this type of work?
05:25:01 <ivanm> in haskell? don't think there are any
05:25:05 <ivanm> maybe have a look at network...
05:25:24 <ivanm> actually, curl apparently has telnet bindings
05:25:35 <ivanm> http://hackage.haskell.org/package/curl
05:26:19 <fxr> oh it's just a transfer library
05:27:58 <ivanm> well, it's the only result for telnet that hayoo returned...
05:28:40 <ivanm> http://collectionofsolutions.blogspot.com/2009/07/haskell-telnet-client-to-run-command-on.html
05:30:45 <fxr> well I need a network interaction library not specifically a telnet lib
05:31:03 <ivanm> @hackage network
05:31:04 <lambdabot> http://hackage.haskell.org/package/network
05:32:23 <fxr> @hackage expect
05:32:23 <lambdabot> http://hackage.haskell.org/package/expect
05:40:27 <danderson> is there a nice way to lift just the first parameter of a function into a monad?
05:40:50 <danderson> (looking for a nice way to express when with a monadic, rather than pure, condition)
05:41:17 <ivanm> care to provide an example of what you want?
05:42:20 <danderson> :t Control.Monad.when
05:42:20 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:42:35 <danderson> I want (Monad m) => m Bool -> m () -> m ()
05:43:20 <danderson> it's easy enough to implement manually with cond >>= flip when act, just wondering if there's a HOF that can do the lifting of a single parameter of a function
05:43:22 <ivanm> @pl whenM mb a = mb >>= \ b -> when b a
05:43:22 <lambdabot> whenM = (. flip when) . (>>=)
05:43:27 <ivanm> *shrug*
05:43:46 <ivanm> it might be possible to automate that to an extent
05:44:11 <danderson> yeah, that's more or less the implementation I end up with
05:44:20 <ivanm> @type \ f mv -> mv >>= f
05:44:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
05:44:28 <danderson> like I said, it's trivial enough that I'm happy to leave it in a utility footer of my module
05:44:35 <ivanm> damn, the whole b is in the monad
05:44:44 <ivanm> whereas you want it to be a function in general...
05:54:32 <ivanm> @pl \ f g x -> (f x, g x)
05:54:33 <lambdabot> liftM2 (,)
05:54:49 <ivanm> hmmm, I thought there was some fancy arrow thing that did that
05:55:58 <benmachine> don't think pl knows about fancy arrow things
05:56:13 <ivanm> ahhhhh
05:56:14 <benmachine> :t \f g x -> (f &&& g) x
05:56:15 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
05:56:24 <ivanm> and yeah, that's the one I was thinking of
05:59:10 <orlandu63> can you pattern match against tuples with >2 elements?
05:59:34 <orlandu63> @pl \f (a,b,c) -> f a b c
05:59:34 <lambdabot> (line 1, column 8):
05:59:35 <lambdabot> unexpected ","
05:59:35 <lambdabot> expecting letter or digit, operator or ")"
05:59:35 <lambdabot> ambiguous use of a non associative operator
06:00:10 <ivanm> orlandu63: yes, but it seems @pl doesn't know about them
06:00:19 <ivanm> and there's no convenience functions for them (without TH, anyway)
06:00:37 <aristid> there's a tuple module iirc
06:00:48 <aristid> in hackage
06:01:39 <ivanm> yeah
06:01:41 <ivanm> @hackage tuple
06:01:42 <lambdabot> http://hackage.haskell.org/package/tuple
06:01:46 <orlandu63> oaky
06:01:52 <ivanm> and tuple-instances
06:02:18 <msieradzki> so you use select 1 (1,2,3) and you get 1 or something like that
06:02:42 <orlandu63> heh
06:03:00 <benmachine> msieradzki: the problem is that select 1 (1,2,3) and select 2 (1,2,3) might have different types
06:03:07 <benmachine> since (1,'a',id) is a valid tuple
06:03:24 <benmachine> (and indeed if you did want a tuple whose elements were all the same type, you could just use a list
06:03:27 <benmachine> )
06:03:28 <msieradzki> that's obvious :)
06:03:42 <benmachine> it's not obvious to everyone :P
06:03:46 <orlandu63> almost all of the functions in that module simply pattern match against 1- to 15-element tuples
06:03:48 <msieradzki> select3 1 ('a',1,"bc")
06:04:49 <benmachine> select3 :: Int -> (Char,Integer,String) -> Erk.
06:05:34 <aristid> select 1 (1, 2, 3) needs DT i think
06:06:39 <benmachine> certainly it can't be done without DTs
06:07:40 <aristid> which is the most popular high-level GUI package?:)
06:08:17 <ivanm> aristid: define "high-level"
06:08:27 <ivanm> AFAIK, no high-level GUI package is popular (fruit, etc.)
06:08:32 <ivanm> but there are gtk2hs and wx-haskell
06:10:18 <aristid> ivanm: high-level as in not gtk2hs oder wxHaskell ;)
06:11:06 <Jafet> Wrap one of those and make your own!
06:11:17 <ivanm> http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
06:11:21 <Jafet> Say it's "more portable"
06:11:28 <ivanm> none of them are popular
06:11:32 <ivanm> and most are dead AFAIK
06:11:59 <ivanm> the only real GUI libraries with any life in them AFAIK are gtk2hs and to a lesser extent wxhaskell (and ncurses, if you count that as a GUI)
06:12:07 <aristid> ivanm: i have the suspicion that arrows aren't that popular
06:12:28 <aristid> ncurses /= vty?
06:12:29 <ivanm> hmmm?
06:12:36 <ivanm> oh, and there's vty
06:12:38 <ivanm> forgot about that
06:12:46 <ivanm> Control.Arrow is relatively popular AFAIK... ;-)
06:12:47 <aristid> well most of the high-level gui libraries use arrows
06:13:31 <ivanm> I think it's more that its only recently that people have really started to care abotu GUIs in Haskell
06:13:33 <orlandu63> ivanm: if youre talking about hscurses its latest version is two years old
06:13:42 <ivanm> and those were all research projects that were never finished and maintained
06:13:52 <ivanm> orlandu63: oh? thought there was a newer one
06:13:53 <ivanm> *shrug*
06:16:08 <gwern> gtk2hs is bound for the Platform isn;t it?
06:16:08 <ivanm> heh, FranTk is so old, that it was a big thing to claim that it worked with GHC-4.04 ;-)
06:16:12 <gwern> I'd put my bet on that
06:16:16 <ivanm> gwern: highly possibly
06:16:24 <gwern> I mean, so I hear
06:16:55 <ivanm> it's definitely possible now
06:17:57 <ivanm> wow, fruit says it works with 5.02.2
06:17:59 <gwern> true, the big blocker was not really being cabalized
06:20:52 <danderson> the state of crypto libs in haskell is really quite sad :(
06:22:39 <mm_freak_> there are some high quality crypto packages
06:22:48 <danderson> really.
06:22:56 <danderson> I want to compute an HMAC.
06:22:57 <mm_freak_> but nothing, that brings all of them together
06:23:09 <mm_freak_> i don't like the Crypto package a lot
06:23:09 <danderson> the only package that purports to compute HMACs won't build on recent ghc
06:23:35 <danderson> there's work on building a crypto-api package that should help quite a bit
06:23:35 <ManateeLazyCat> What's your favorites terminal emulator? gnome-terminal, xterm, or other ?
06:23:47 <danderson> but that doesn't change the present :/
06:24:04 <orlandu63> urxvt is what i prefer
06:24:05 <ManateeLazyCat> danderson: Can you build better one?
06:24:06 <ivanm> ManateeLazyCat: I'm currently using evilvte
06:24:19 <mm_freak_> danderson: which hash function?
06:24:31 <ManateeLazyCat> ivanm: Also vte terminal.
06:24:39 <danderson> ManateeLazyCat: the whole point is that I don't want to build one, I have better things to do (like compute an HMAC and get on with my network protocol)
06:24:53 <mm_freak_> danderson: if it's SHA-2, then use the SHA2 package
06:24:55 <ManateeLazyCat> danderson: Ok.
06:25:01 <mm_freak_> it has a builtin 'hmac' function
06:25:38 <ManateeLazyCat> ivanm: Just iterm is MVC terminal emulator, unfortunately it's don't support gtk+ well.
06:25:40 <danderson> mm_freak_: oh, neat, I missed that (and so did hoogle)
06:25:43 <danderson> cheers.
06:25:59 <danderson> (and yes, I wanted SHA-2, so this is exactly what I need, albeit slightly hidden)
06:26:00 <mm_freak_> you're welcome
06:26:35 <ivanm> danderson: there's a new crypto-hash library...
06:27:11 <ManateeLazyCat> ivanm: I was a little afraid of release my project, because I'm afraid I do not have time to sleep.....
06:27:14 <danderson> ivanm: yes, and it contains only hash functions, not HMAC
06:27:30 <danderson> that said, looking at the implementation of hmac in SHA2, it's amazingly concise
06:27:35 <ivanm> ManateeLazyCat: heh
06:29:24 <danderson> whoa, what's this syntax: fixkey k (lenBytes -> len) = ...
06:29:25 <Jafet> HMAC has a concise definition.
06:29:37 <danderson> looks like it applies lenBytes to the 2nd argument and binds the result to len
06:29:39 <kmc> danderson, a view pattern
06:29:44 <kmc> ghc extensino
06:30:00 <ManateeLazyCat> ivanm: In 2007, my Germany friend recommend me share my Emacs extension, finally i release all elisp code. Since then I  got many crazy night.
06:30:01 <danderson> thanks for the keyword, /me looks it up
06:30:12 <kmc> danderson, and you're correct about how it works
06:30:47 <ManateeLazyCat> ivanm: The biggest disadvantage of my project is don't support haskell-interpreter like elisp for Emacs.
06:31:43 <ManateeLazyCat> ivanm: Maybe it's hard to implement hot-swapping feature for Graphics application.
06:31:47 <ivanm> ManateeLazyCat: you could possibly embed one in using hint
06:32:49 <ManateeLazyCat> ivanm: Yep, that's a solution, but it still need long time to explore...
06:33:35 <ManateeLazyCat> ivanm: I read some resource that written by RMS, it use *global variable* keep state in hot-swapping.
06:34:12 <ManateeLazyCat> ivanm: In Emacs, you even can use base64 string save image, but in gtk2hs, it's unknown space....
06:34:57 <ivanm> ManateeLazyCat: sounds a bit like what xmonad uses
06:35:03 <ivanm> maybe check out dyre for config stuff?
06:35:36 <ManateeLazyCat> ivanm: Infact, i have similar code implement yi/xmonad/dyre 's feature
06:35:43 <ManateeLazyCat> ivanm: But i still not happy.
06:35:54 <ManateeLazyCat> ivanm: Because we can't keep *all* state of gtk+
06:36:35 <ManateeLazyCat> ivanm: In Yi/XMonad/dyre aim, them don't lose state if just re-compile user's configuration file.
06:37:12 <ManateeLazyCat> ivanm: But i want do more than that, i want do a *fully* hot-swapping, not just user's configuration file, include all source code.
06:37:44 <ManateeLazyCat> ivanm: But once you touch *core* code, you will lose all extension *state* after you re-launch new entry.
06:37:58 <Jafet> That kind of architecture sounds like what you'd find in a modern polymorphic virus.
06:38:38 <ManateeLazyCat> Jafet: For current situation, i save current state to Binary, i will restore those state after re-launch in new entry.
06:39:15 <ManateeLazyCat> Jafet: But we can't save *all* state of gtk+, so we will lose some *state* after re-launch, more or less.....
06:39:50 <Jafet> If you follow the same algorithm to create the GUI objects, won't they end up the same?
06:40:21 <kmc> i think the feasible way to do hot-swap like this in Haskell is with separate processes
06:40:33 <kmc> i agree in principle something better should be possible
06:40:44 <kmc> but even ghci doesn't keep state when you reload code
06:40:48 <ManateeLazyCat> kmc: separate process? Can you more detail?
06:41:09 <Jafet> It's hard to keep state, anyway, when you change the code that operates on that state in the first place
06:41:28 <ManateeLazyCat> Jafet: Someone can, someone can't, depends on the widget implementation.
06:42:36 <ManateeLazyCat> Jafet: Current for my gtk2hs project, i just save/restore some important state, and not all state. Example, in editor, i will save (filepath, position)...etc.
06:43:24 <kmc> ManateeLazyCat, by "separate processes" i mean that you have a small non-hot-swappable program which talks to Gtk, and accepts commands from other processes
06:43:28 <ManateeLazyCat> Jafet: Example, you can't restore web-page state....
06:43:38 <kmc> various advantages and disadvantages here of course
06:44:43 <ManateeLazyCat> kmc: Hmm, i need think about your idea....
06:44:50 <Jafet> Throw in corba for good measure
06:45:03 <kmc> ManateeLazyCat, in some sense X is supposed to work like this already
06:45:18 <kmc> ManateeLazyCat, but the GUI toolkits like Gtk generally live only on the client side
06:50:01 <ManateeLazyCat> kmc: In my project, i have implementation separate process.
06:50:17 <ManateeLazyCat> kmc: Core is running in daemon process, all user's application in running in separate process.
06:50:46 <ManateeLazyCat> kmc: IMO, *fully* hot-swapping looks impossible for Core. 
06:51:13 <kmc> yeah
06:51:14 <ManateeLazyCat> kmc: I can try build many *layout*, make core simple and small enough.
06:51:24 <ManateeLazyCat> kmc: Then in most situation, core won't touch.
06:51:39 <ManateeLazyCat> kmc: Then we can implement hot-swapping in user's application space.
06:52:35 <Jafet> Core being, ghc runtime?
06:53:36 <ManateeLazyCat> kmc: I even think about *low-level* hot-swapping, that copy *core* process memory, then replace new value in memory data, then restore all *core* process.
06:53:49 <ManateeLazyCat> kmc: Just idea, don't know how to implement it.
06:54:16 <danderson> @hoogle Data.ByteString.ByteString -> Data.ByteString.Lazy.ByteString -> Data.ByteString.Lazy.ByteString
06:54:16 <lambdabot> Parse error:
06:54:16 <lambdabot>   --count=20 "Data.ByteString.ByteString -> Data.ByteString.Lazy.ByteString -> Data.ByteString.Lazy.ByteString"
06:54:16 <lambdabot>                  ^
06:54:22 <danderson> bah
06:54:26 <ManateeLazyCat> I think Emacs's hot-sawpping like this: C-Static-Core ++ Elisp Interpreter ++ User's elisp code.
06:54:57 <Jafet> emacs can't swap the core (and the core contains the interpreter), as far as I know
06:55:09 <ManateeLazyCat> Static-Core and elisp interpreter won't touch, so Emacs don't need restart, all user's elisp code can hot-swapping base on static-core.
06:55:19 <ManateeLazyCat> Jafet: Yep.
06:55:49 <Jafet> .oO(If you're cheeky, you can implement emacs in elisp and hot-swap it.)
06:56:09 <kmc> ManateeLazyCat, you can do the same thing in Haskell, mostly
06:56:20 <ManateeLazyCat> kmc: Yes, that's i'm doing.
06:56:39 <ManateeLazyCat> kmc: I guess you have seen the screenshot of my project? :)
06:57:38 <ManateeLazyCat> More practical way is keep core don't touch, any change for core will need re-launch, IMO.
06:58:24 <kmc> yes i have :)
07:00:59 <ManateeLazyCat> kmc: Currently, i need distinguish "develoer hot-swap" and "user hot-swap".
07:01:29 <ManateeLazyCat> kmc: "Developer hot-swap" for source code, "User hot-swap" for configuration file.
07:02:16 <ManateeLazyCat> kmc: Because developer's always touch source code, and it's impossible marshall all gtk+ state, so we will lose some state after hot-swap.
07:02:53 <ManateeLazyCat> But for user hot-swap, because configuration file is pure haskell code, so we won't lose anything after hot-sap...
07:05:09 <ManateeLazyCat> "Core hot-swapping" ++ "Configuration hot-swapping" ++ "Haskell interpreter", this is best way i can think... maybe have better way....
07:06:03 <ManateeLazyCat> Jafet: Since elisp is safe enough, i don't want waste time on Emacs.
07:06:08 <Jafet> There's a hot-swappable BSD kernel. I don't remember which.
07:06:16 <ManateeLazyCat> s/is safe/is not safe.
07:06:21 * ManateeLazyCat Damn .... :)
07:06:40 <Jafet> That's okay, the intention was clear.
07:06:45 <ManateeLazyCat> Jafet: hot-swappable kernel?
07:07:15 <p_l> ManateeLazyCat: BSD was core for many crazy things...
07:07:33 <ManateeLazyCat> p_l: I'm a Debian/Linux user. :)
07:07:48 <ManateeLazyCat> p_l: example?
07:09:26 <aristid> :t (++) `on` return
07:09:27 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Monad m) => a -> a -> m a
07:09:40 <aristid> :t (Prelude.++) `on` return
07:09:41 <kmc> ManateeLazyCat, you should switch to Debian/FreeBSD clearly ;P
07:09:41 <lambdabot> forall a. a -> a -> [a]
07:10:12 <ManateeLazyCat> kmc: But Linux have more developer. :)
07:11:03 <p_l> ManateeLazyCat: nearly everything that went with Mach, iirc
07:11:27 <p_l> Also, windows (srsly)
07:11:42 <p_l> except it wasn't core for it
07:11:52 <p_l> (but BSD forms the POSIX subsystem)
07:12:53 <ManateeLazyCat> IMO, hot-swapping is *layout* problem, touch lower level layout will save/restore more state. 
07:13:24 <ManateeLazyCat> If i use C implement everything, maybe i can hot-swapping everything...
07:15:39 <ManateeLazyCat> In other solution, don't use save/restore state, just keep process running, replace new value at original address... But looks dangerous.....
07:15:59 <Jafet> Don't go into this rashly...
07:16:20 <ManateeLazyCat> Because we don't know what will happened when we do those *replace*....
07:16:51 <Jafet> So, why do you need the core hot-swappable? For debugging, like the BSD devs?
07:16:52 <bnonym> caaaaarl
07:17:09 * ManateeLazyCat I hope Don will fix plugins with Cabal-1.8, then i can test my idea with plugins.
07:17:20 <p_l> ManateeLazyCat: you wan to hot swap code, I understand?
07:17:45 <ManateeLazyCat> p_l: I have works code like Yi/Xmonad did, but i want more advanced feature.
07:18:03 <ManateeLazyCat> p_l: Yes. i want
07:18:18 <p_l> ManateeLazyCat: well, you could look into implementation details of CL implementations like SBCL or CCL (especially in "developer" mode, i.e. with unlocked core)
07:18:37 <p_l> Might be kinda hard to do with GHC unless you're willing to get dirty with internals
07:19:00 <ManateeLazyCat> p_l: Yes, it's still unknown space in ghc....
07:20:00 <ManateeLazyCat> Jafet: Yes, i want it develop itself, and not just user configuration file.
07:20:36 <p_l> ManateeLazyCat: requirements for such functionality will probably go against quite a lot of optimisations performed by GHC
07:24:04 <ManateeLazyCat> p_l: I haven't touch ghc code, but i will try and see what's will happen...
07:26:43 <p_l> also look into Erlang
07:27:44 <ManateeLazyCat> p_l: Yes, i found Erlang has some hot-swapping feature, but i know nothing about Erlang ... :)
07:28:15 <Jafet> Have you read about von Neumann's "universal constructor"? Very interesting implications.
07:28:29 <ManateeLazyCat> Jafet: L		nk?
07:28:33 <ManateeLazyCat> Link?
07:28:35 <ClaudiusMaximus> kmc: i ended up using Lua for my config file with http://hackage.haskell.org/package/hslua-0.2 (though i think i'd rather it used my system's lua than whichever old version it bundles...)
07:29:12 <Jafet> A similar scenario is described by Thompson in "Trusting Trust".
07:30:32 <Jafet> lazycat: wikipedia suggests http://web.archive.org/web/20080105213853/www.walenz.org/vonNeumann/index.html Possibly too much detail, though.
07:30:34 <ManateeLazyCat> I was think a idea how to improve my English, i can add "Google Translater" filter in my irc lient, it can translate to English before i send Chinese message, then you guys can read English that translate from Chinese... :)
07:30:59 <Jafet> Then you would be even more incomprehensible than you are now
07:31:23 <soupdragon> but then google knows everything you say!
07:31:32 <Jafet> You'll also see replies to the translated messages instead of the ones you typed, which isn't a good idea for learning
07:31:45 <Jafet> soupdragon: it's google or ccp. Meh.
07:31:47 <ManateeLazyCat> Jafet: Yep, joking ... :)
07:32:06 <Loriel> Google is probably already indexing some publically viewable chatlogs of this place, anyway.
07:32:14 <ManateeLazyCat> Jafet: Robot translate is bad idea to learn language, i agree. :)
07:34:31 <ManateeLazyCat> Jafet: http://web.archive.org/web/20080105213853/www.walenz.org/vonNeumann/index.html looks convert by some pdf file, can ou give me the original link? 
07:35:35 <Jafet> That's a direct link from wikipedia. It's a paper book, and I can't help but notice that the domain name ends in a plural z..
07:36:06 <ManateeLazyCat> Jafet: So book name is "universal constructor" ?
07:36:50 <ManateeLazyCat> Jafet: This ? http://en.wikipedia.org/wiki/Von_Neumann_universal_constructor
07:38:00 <ManateeLazyCat> Jafet: Ok, thanks for book, i'm reading it.....
07:38:05 <soupdragon> @let solve p m = [ (x,y,z) | x <- [1..], y <- [1..x], z <- [1..y], p x y z`mod`m == 0 ]
07:38:05 <lambdabot>  Defined.
07:38:26 <soupdragon> > solve (\x y z -> 3*x^3 + 4*y^3 + 5*z^3) 5
07:38:27 <lambdabot>   [(3,1,1),(4,3,1),(4,3,2),(4,3,3),(5,5,1),(5,5,2),(5,5,3),(5,5,4),(5,5,5),(6...
07:38:29 <soupdragon> > solve (\x y z -> 3*x^3 + 4*y^3 + 5*z^3) 7
07:38:30 <lambdabot>   [(7,7,7),(8,8,7),(9,8,7),(9,9,7),(10,10,7),(11,8,7),(11,9,7),(11,11,7),(12,...
07:38:31 <Jafet> I didn't read most of it, either.
07:38:32 <soupdragon> > solve (\x y z -> 3*x^3 + 4*y^3 + 5*z^3) 11
07:38:33 <lambdabot>   [(2,1,1),(4,2,2),(4,4,3),(5,4,2),(5,5,1),(6,3,3),(6,5,2),(7,3,2),(8,2,1),(8...
07:39:16 <ManateeLazyCat> Jafet: "self-replicating machine" yes.... :)
07:39:22 <p_l> ManateeLazyCat: I really recommend Erlang, at least read up on OTP - it was designed from beginning to never "stop"
07:40:01 <ManateeLazyCat> p_l: You recommend "Erlang hot-swapping implement" Or "Erlang language replace Haskell"?
07:46:39 <interferon> suppose i want to write some combinators to describe a group of electronic components and the wiring between them for the purpose of running a simulation with them
07:46:39 <interferon> o
07:47:01 <interferon> once i have my network of components and wires, how can i refer to a specific component, e.g. "is lamp 4 on?"
07:47:21 <interferon> do i need some kind of labeling scheme?
07:47:39 <interferon> since each step through the simulation will create a "new" immutable network
07:50:07 <dancor> for software synth libs i see haskore thing and yampasynth.  i assume latter is faster, but a binding to timidity or some such would be better but doesn't exist yet?
07:53:59 <p_l> ManateeLazyCat: Either. OTP was *designed* for hot swap
07:54:07 <p_l> there's also Mozart
07:54:21 <p_l> though I don't know how well it does with regards to hot swap
07:55:03 <soupdragon> > 5 `mod` 1
07:55:04 <lambdabot>   0
07:55:05 <soupdragon> > 5 `mod` 0
07:55:06 <lambdabot>   *Exception: divide by zero
07:55:14 <p_l> a good Erlang system has two version numbers, the one of the code running the oldest operation and the one of the code you just loaded :)
07:55:15 <soupdragon> why not set (`mod` 0) = id
07:56:03 <kmc> Jafet, hmm.  universal constructors + trusting trust? sounds like _Glasshouse_
07:57:22 <dancor> a = b (mod m) iff m divides a - b
07:57:28 <kmc> interferon, one simple approach i've used is to provide a monadic API, where the user binds names
07:57:47 <Jafet> kmc: ok, but I don't care much for stross.
07:57:52 <kmc> do { (a,b) <- resistor 300; wire a b }
07:57:53 <dancor> > 0 `mod` 0
07:57:54 <lambdabot>   *Exception: divide by zero
07:57:54 <kmc> Jafet, ok
07:58:17 <kmc> Jafet, they have transporters which work by taking apart and reassembling matter, and somebody roots one of them...
07:58:19 <interferon> kmc: hmm, that's interesting
07:58:26 <benmachine> mod is supposed to be such that (a `div` b) * b + (a `mod` b) = a
07:58:36 <benmachine> with b = 0 that can't be satisfied
07:59:14 <aristid> > 0 `div` 0
07:59:15 <lambdabot>   *Exception: divide by zero
07:59:39 <kmc> this is a bit asymmetric because a wire is just a 0-ohm resistor
07:59:52 <kmc> another approach is to name the nets explicitly:
08:00:03 <kmc> do { a <- net; b <- net; resistor 300 a b; resistor 0 a b }
08:00:30 <kmc> interferon, you might want to look at the combinators Lava uses to describe logical circuits
08:00:45 <kmc> and also at the "type-safe observable sharing in Haskell" paper
08:00:49 <kmc> since it would help with implementation
08:01:23 <interferon> thanks
08:06:35 <soupdragon> :t comparing
08:06:36 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:07:21 <soupdragon> > let t x = [sqrt x,- sqrt x] in sortBy (comparing (\[a,b,c,d] ->abs (a+b+c+d - pi))) sequence [t 2,t 3,t 5,t 7]
08:07:22 <lambdabot>   Couldn't match expected type `[[t]]'
08:07:22 <lambdabot>         against inferred type `[m a] -...
08:07:26 <soupdragon> > let t x = [sqrt x,- sqrt x] in sortBy (comparing (\[a,b,c,d] ->abs (a+b+c+d - pi))) $ sequence [t 2,t 3,t 5,t 7]
08:07:26 <lambdabot>   [[1.4142135623730951,1.7320508075688772,2.23606797749979,-2.645751311064590...
08:08:03 <soupdragon> > let t x = [sqrt x,- sqrt x] in map (take 5 . show) . head . sortBy (comparing (\[a,b,c,d] ->abs (a+b+c+d - pi))) $ sequence [t 2,t 3,t 5,t 7]
08:08:04 <lambdabot>   ["1.414","1.732","2.236","-2.64"]
08:09:55 <soupdragon> is ther a better approximation of pi in square roots of primes than
08:09:58 <soupdragon> > sqrt(2)+sqrt(3)
08:09:59 <lambdabot>   3.1462643699419726
08:10:01 <soupdragon>  ?
08:17:54 <aristid> soupdragon: with two numbers, no
08:18:00 <soupdragon> :(
08:18:39 <aristid> hmm are coefficients allowed?
08:18:42 <soupdragon> yes
08:22:34 <aristid> > sqrt(13) - sqrt(12) + sqrt(9)
08:22:35 <lambdabot>   3.1414496603262347
08:22:38 <aristid> soupdragon: :)
08:22:51 <soupdragon> oh good!!!
08:23:10 <mtnviewmark> is this a project euler problem?  :-)
08:23:27 <aristid> > (\n -> minimumBy (compare `on` snd) [ (((a,x),(b,y),(c,z)),abs(a*sqrt(x) + b*sqrt(y) + c*sqrt(z) - pi)) | x <- [0..n], y <- [0..x], z <- [0..y], a <- [-1,1], b <- [-1,1], c <- [-1,1] ]) 30
08:23:28 <lambdabot>   (((1.0,13.0),(-1.0,12.0),(1.0,9.0)),1.429932635583775e-4)
08:23:28 <soupdragon> not to my knowledge]
08:24:16 <soupdragon> > (\n -> minimumBy (compare `on` snd) [ (((a,x),(b,y),(c,z),(d,w)),abs(a*sqrt(x) + b*sqrt(y) + c*sqrt(z) + d*sqrt(w) - pi)) | x <- [0..n], y <- [0..x], z <- [0..y], w <- [0..z], a <- [-1,1], b <- [-1,1], c <- [-1,1], d <- [-1,1] ]) 71
08:24:21 <lambdabot>   mueval: ExitFailure 1
08:25:09 <aristid> soupdragon: you're being mean to lambdabot's processor?
08:25:11 <kmc> integer coefficients? rationals?
08:25:13 <aristid> -?+!
08:26:03 <aristid> > sqrt(18)-2*sqrt(9)+2*sqrt(6)
08:26:04 <lambdabot>   3.1416201726856405
08:26:30 <aristid> soupdragon: i think you need to make stricter rules, because with integer coefficients it's too easy to make good approximations IMO
08:27:15 <davekong> what is a good name for storing an id? (given id is already taken by the function)
08:27:33 <kmc> davekong, how do you mean?
08:27:39 <mtnviewmark> well - and if the form is   n1*sqrt(p1) + n2*sqrt(p2),    if n1 & n2 can be positive or negative integers
08:27:53 <soupdragon> no no I Want to get good approximations
08:27:58 <mtnviewmark> I'm not sure that there is anyway to bound the problem- you couldn't prove a better solution doesn't exist
08:28:01 <jkingkong_> hi haskell, i had a question about getting interaction mode to work with haskell-mode. It appears that ghci can't load statements with #ifndef in them
08:28:31 <ksf> -XCPP?
08:28:33 <jkingkong_> it tells me there's a lexical error at the character "i"
08:28:36 <ksf> anyway, that won't work on the prompt.
08:28:38 <mtnviewmark> jkingkong I think you run   :s -XPP
08:28:44 <jkingkong_> ah
08:28:46 <mtnviewmark> er :s -XCPP
08:28:47 <davekong> kmc: like for tagging lines of input for debugging 
08:29:26 <jkingkong_> thanks
08:29:28 <jkingkong_> you guys are champions as usual
08:29:42 <davekong> id <- takeWhile (isDigit) "576 do this!"
08:31:43 <kmc> we are the champions, my friends
08:31:57 <mtnviewmark> davekong:  label <- takeWhile (isDigit) "42 answer!"
08:33:53 * ManateeLazyCat pasted "keymap" at http://paste2.org/get/910289
08:33:54 <ManateeLazyCat> ivanm: Can you help me review above keymap? Any suggestion are welcome.
08:34:25 <ManateeLazyCat> Any keystone geek can help me review keymap http://paste2.org/get/910289 ? Thanks!
08:35:12 * soupdragon wishes to be a keystone geek
08:35:16 <soupdragon> (because it sounds so cool)
08:35:38 <ManateeLazyCat> soupdragon: My new project design for keystroke geek. :)
08:35:54 <kmc> keystone geeks drink keystone light?
08:36:09 <ManateeLazyCat> kmc: typo, you know. :)
08:36:19 <kmc> :)
08:36:26 <ManateeLazyCat> kmc: keyboard geek. :)
08:37:01 <benmachine> augh none of the haskell-src-exts data types have Read instances
08:37:10 <ManateeLazyCat> kmc: How feeling http://paste2.org/get/910289 ? Any keystroke you don't like?
08:37:41 <benmachine> I don't suppose I can make TH generate standalone deriving decls?
08:38:05 <benmachine> hmm, maybe gread can help me here
08:39:24 <ManateeLazyCat> kmc: I have already used up the left side of the keyboard.  :)
08:40:16 <kmc> ManateeLazyCat, I use Dvorak, my suggestions are probably not helpful ;P
08:40:45 * benmachine wonders why gshow puts brackets in weird places
08:40:50 <ManateeLazyCat> kmc: Hehe... 
08:41:51 <ManateeLazyCat> kmc: Drop Emacs's Ctrl keystroke design, hard to type....
08:42:17 <kmc> Ctrl is not hard to type if it's in the correct position on the keyboard
08:43:04 <benmachine> augh, the annotated stuff doesn't have Data either
08:43:05 * benmachine cries
08:43:26 <benmachine> no it does
08:43:57 <ManateeLazyCat> 20 years ago, the keyboard Ctrl key at Alt key position of modern keyboard.
08:48:23 <kmc> i was thinking directly to the left of 'a'
08:48:30 <kmc> where this useless key labeled "Caps Lock" sits today
08:48:49 <Jafet> Unicomp actually sells keyboards with the keys swapped.
08:49:05 <Jafet> Now whether you'd pay $100 for one...
08:49:26 <kmc> unicomp keyboards are good for other reasons
08:49:28 <medfly> just swap the keyboard settings
08:49:29 * hackagebot FileManip 0.3.3 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/FileManip-0.3.3 (BryanOSullivan)
08:49:33 <ManateeLazyCat> kmc: You mean "a -> left, s -> down, d -> up, f -> right" ?
08:49:43 <kmc> but if you want to pay $100 just to have the key swapped, i have an xmodmaprc i'll sell you for only $20
08:49:54 <kmc> ManateeLazyCat, ?
08:49:56 <ManateeLazyCat> kmc: I use Microsoft-3000
08:50:07 <ManateeLazyCat> <kmc> i was thinking directly to the left of 'a' ?
08:50:14 <kmc> ManateeLazyCat, as a location for Ctrl
08:50:25 <ManateeLazyCat> kmc: Hmmm
08:50:25 <Jafet> Well, the labels are swapped. And software remaps won't work on the horror that is hardware capslock.
08:50:39 <kmc> who does that?
08:50:51 <kmc> labels should be as confusing as possible
08:51:47 <Jafet> Label one "Magic"
08:52:45 <Jafet> Magic-X Magic-C sounds strangely satisfying
08:53:35 <soupdragon> is there anywy way to do  (4*[0..2]^3-5)`mod`3
08:53:51 <soupdragon> > map (\i->(4*i^3-5)`mod`3) [0..2]
08:53:52 <lambdabot>   [1,2,0]
08:54:12 <Jafet> instance Num [Num] where
08:54:24 <soupdragon> > map (\i->(8*i^2)`mod`3) [1..2]
08:54:25 <lambdabot>   [2,2]
08:56:29 <soupdragon> > map (\i->(3*i^3-1)`mod`3) [0..2]
08:56:30 <lambdabot>   [2,2,2]
08:57:13 <soupdragon> > map (\i->(9*i^2)`mod`3) [0..2]
08:57:14 <lambdabot>   [0,0,0]
08:58:54 <benmachine> soupdragon: erm, if you multiply something by 9 and then mod 3, it's not terribly surprising that you get zero
08:59:06 <dons> yo pdx peeps. anyone coming down to #devnation?
08:59:34 <mreh> what's a pdx?
08:59:53 <dons> the city of portland, oregon. :)
09:00:45 * wli cries
09:00:51 <mreh> T_T
09:02:02 <ManateeLazyCat> dons: Can you fix plugins with Cabal-1.8, please? I want use it... 
09:02:45 <soupdragon> hey wli
09:02:48 <soupdragon> wli want to hear something cool
09:03:12 <soupdragon> wli, 3x^3+4y^3+5z^3=0 has solutions mod m for every m but it isn't solvable in integer
09:05:07 <aristid> > 1 * sqrt(30.0) + -3 * sqrt(18.0) + 3 * sqrt(12.0)
09:05:08 <lambdabot>   Precedence parsing error
09:05:08 <lambdabot>      cannot mix `GHC.Num.+' [infixl 6] and prefix ...
09:05:28 <soupdragon> > 1 * sqrt(30.0) - 3 * sqrt(18.0) + 3 * sqrt(12.0)
09:05:28 <lambdabot>   3.14160835910707
09:05:37 <soupdragon> cool
09:05:51 <aristid> took a while to compute :D
09:05:58 <aristid> of course with the dumbest algorithm ever
09:06:01 <mreh> have we become soupdragon's personal calculator?
09:06:22 <davekong> Jafet: well there are "Magic keys" in Linux at least
09:06:35 <aristid> mreh: no we have become soupdragon's personal pi finder
09:06:54 <mreh> I found you a pi, but I eated it
09:07:01 <aristid> an apple pi?
09:07:44 <mreh> it was only approximate
09:13:44 <mreh> your face when you saw e^i*pi +1 = 0 vvvvvv
09:19:33 <pacak> Is there any good online tutorials for Parsec? Or at least what is the easiest way to exclude '\n' char from whiteSpace in TokenParser?
09:21:36 <Ke> many (oneOf "\t ") oslt?
09:21:40 <aristid> soupdragon: i was hoping that adding e to the game would improve the approximation, but it did not work! :(
09:23:07 <soupdragon> aristid: maybe logarithm is more likely than e
09:23:51 <aristid> soupdragon: why?
09:24:09 <soupdragon> > exp(pi * sqrt(136)) :: CREal
09:24:11 <lambdabot>   Not in scope: type constructor or class `CREal'
09:24:11 <soupdragon> > exp(pi * sqrt(136)) :: CReal
09:24:12 <lambdabot>   8151279246142431.919930164198136708643722829067349427109
09:24:20 <soupdragon> > exp(pi * sqrt(163)) :: CReal
09:24:21 <lambdabot>   262537412640768743.9999999999992500725971981856888793538563
09:24:45 <soupdragon> so log 262537412640768743 is closed to pi * sqrt(163)
09:24:46 <pacak> Ke: It works fine when i use plain Parser, but i have more complex text to parse. Token parsec calls whiteSpace somewhere inside it.
09:25:10 <Ke> ah, I know nothing about that
09:26:16 <pacak> Ke: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html, Lexical analysis
09:29:08 <zeiris_> Are there any community-driven initiatives to document existing Hackage packages?
09:29:16 <Dashkal> pacak: Most parsers work via the lexeme parser.  lexeme is what's calling whitespace.  Unfortunately, I don't see a way to override the whitespace parser
09:29:36 * zeiris_ is reading the monoids docs, and is making slow progress due to not immediately knowing the exact definition of 'group'.
09:30:19 <Dashkal> TokenParser seems to be a poor fit for whitespace sensitive languages.
09:30:56 <pacak> Dashkal: What should i use then?
09:31:08 <soupdragon> class Group g where id :: g ; (&) :: g -> g -> g ; inv :: g -> g with id & x = id ; x & id = id ; x & (y & z) = (x & y) & z ; inv x & x = id
09:31:36 <Dashkal> You may need to do the job of TokenParser yourself.  So write your own lexeme and whitespace parsers
09:31:52 <soupdragon> zeiris_ ^  instance Group Integer where id = 0 ; (&) = (+) ; inv = negate,  instance Group (Rational \  {0}) where id = 1 ; (&) = (*) ; inv = reciprocal ; ...
09:31:59 <Dashkal> or, you could parse your text one line at a time
09:32:33 <Saizan> zeiris_: what refers to group in Data.Monoid's docs?
09:33:04 <pacak> Dashkal: Any good tutorial (or at least code sample) on creating lexeme parsers except parsec's source code?
09:34:17 <Dashkal> pacak: If your language really does split on newlines, look into splitting on newlines before you go to that extent
09:34:29 <Dashkal> readLine, parse, readLine, parse, etc
09:34:42 <Dashkal> But to answer your question, I know of none.
09:35:47 <pacak> Dashkal: it splits on newlines, but one line can contain escaped newlines ("\\\r\n") which should be ignored.
09:36:29 <Dashkal> ahh
09:37:41 <pacak> Dashkal: It seems, that i have to write half of parsec myself. Ok, thanks for your help :)
09:38:59 <Dashkal> pacak: Well, that's one route.  Another thought that comes to mind is parsing in two states.  First one to split into newlines (minding the escaped ones), second for the actual language work.  So feed the output of the first one into the second one as you go (note: this should be able to be done as a pipeline so you don't need to do it in two passes)
09:39:05 <Dashkal> stags*
09:39:07 <Dashkal> stages*
09:39:32 <zeiris_> Saizan: Data.Group is in monoids package. I'm not sure about the difference between minus and gsubtract.
09:45:41 <ksf> wait, I got an example source for layout parsing
09:47:53 <ksf> http://gist.github.com/384677
09:47:56 <ksf> there it is.
09:48:03 <ksf> not the best haskell, it's from my early days.
09:49:36 <ksf> ...note the hand-written tokenizer and the pass over the token stream that concats lines.
09:50:21 <ksf> also, the sweetest syntax imaginable for a lisp.
09:51:10 <pacak> ksf: Thank you, i'll try.
09:53:24 <soupdragon> > map (^3) [3,5,15,45]
09:53:25 <lambdabot>   [27,125,3375,91125]
09:53:42 <ksf> @hoogle (st -> a -> (st, [b])) -> st -> [a] -> (st, [b])
09:53:43 <lambdabot> Did you mean: ST a a -> a -> (ST a a, [b]) -> ST a a -> [a] -> (ST a a, [b]) /count=20
09:53:43 <lambdabot> Data.Generics.Twins gmapAccumM :: (Data d, Monad m) => (a -> e -> (a, m e)) -> a -> d -> (a, m d)
09:53:43 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (e -> r) -> e -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
09:54:15 <ksf> wait I re-invented that?
09:56:20 <monochrom> you re-invented scrap-your-boilerplate or something :)
09:56:47 <ksf> I called that function concatStateMapL
09:57:03 <ksf> one of those overly-generic folds.
09:57:55 <Saizan> ?type \f z -> fmap concat . mapAccumL f z
09:57:56 <lambdabot> forall a acc x. (acc -> x -> (acc, [a])) -> acc -> [x] -> (acc, [a])
09:58:27 <ksf> heh.
09:59:43 <Saizan> ?type \f z -> flip runState z . fmap concat . mapM f
09:59:44 <lambdabot> forall a a1 a2. (a2 -> State a [a1]) -> a -> [a2] -> ([a1], a)
09:59:59 <Saizan> ?type \f z -> flip runState z . fmap concat . mapM (State . f)
10:00:00 <lambdabot> forall a a1 a2. (a2 -> a -> ([a1], a)) -> a -> [a2] -> ([a1], a)
10:00:20 <Saizan> etc..
10:01:32 <ksf> I wasn't really capable of function composition, back then.
10:17:21 <sepp2k> How can I do the following in haskell: Read from stdin until the user presses ^d, then while processing that input ask the user for input again?
10:18:00 <Jafet> If by ^D you mean "close stdin"...
10:18:09 <Jafet> ... I suggest rethinking.
10:19:23 * ksf suggests haskelline
10:19:44 <ksf> eof is overrated.
10:19:53 <sepp2k> Jafet: Some tools do it (the ruby and perl interpreters for example), so it's not impossible.
10:20:17 <Jafet> That can only mean they change ^D to mean something else.
10:20:19 <ksf> you can re-open stdin
10:20:32 <Jafet> Ugh.
10:20:38 <ksf> exactly.
10:21:00 <ksf> ^D should close any shell-like thing.
10:21:30 <sepp2k> I'm not talking about the interactive interpreters.
10:21:33 <eevar> tapping eof can't be that hard?
10:21:40 <eevar> *trap
10:22:18 <ksf> if you want a separator, I suggest vertical tab.
10:22:38 <ksf> and use eof for the real end of input.
10:23:13 <Jafet> eevar: that made no sense.
10:23:35 <Jafet> EOF is the error code for when a file is closed.
10:23:40 <ksf> form feed would work, too.
10:24:06 <ksf> actually, ETB is the right thing. but ^W is taken up by many line editing tools.
10:24:50 <hpc> ETB?
10:24:59 <hpc> End Terminal Buffer?
10:25:16 <ksf> end of transmission block. 0x17
10:25:22 <hpc> ah
10:25:45 <ksf> there's also file, group, record and unit separator.
10:25:55 <ksf> ^\, ^], ^^ and ^_
10:27:32 <Jafet> NUL, ARCHAIC CONTROL CODE, ARCHAIC CONTROL CODE, ARCHAIC CONTROL CODE, ARCHAIC CONTROL CODE, ARCHAIC CONTROL CODE, DING, BACKSPACE, TAB, LINE FEED, ARCHAIC CONTROL CODE ...
10:28:21 <hpc> nifty, didn't know about those
10:29:54 <ksf> http://en.wikipedia.org/wiki/C0_and_C1_control_codes [+]
10:33:31 <cheater99> is a cons the same thing as a pair?
10:35:53 <ksf> depends on your pov.
10:35:59 <pikhq> cheater99: In certain contexts, yes.
10:36:00 <Jafet> Cons work in pairs.
10:36:16 <cheater99> what does that mean Jafet?
10:36:25 <pikhq> (in particular, Lisp contexts)
10:36:29 <cheater99> pikhq: ok. can you give me a context where it's not true?
10:36:33 <ksf> cons is usually meant to create lists and lists aren't done via tuples in haskell
10:36:36 <pikhq> cheater99: Haskell.
10:36:36 <pikhq> :)
10:36:48 <cheater99> what's a cons in haskell?
10:37:13 <ksf> it's still used as a substitute if you can't have : because your list-like thing isn't a []
10:37:21 <ksf> cheater99, whatever you make it to be.
10:37:27 <pikhq> (:) is a function of type a -> [a] -> [a] . No pairs involved.
10:37:35 <Jafet> "Pair of cons caught stealing car"
10:37:45 <cheater99> ok so in haskell, (:) is cons?
10:37:51 <pikhq> Though one can use (,) to do kinda-sorta-cons.
10:38:03 <cheater99> so what's cons in the general sense?
10:38:15 <ksf> there's no general meaning to that.
10:38:18 <Jafet> cheater99: what's cons?
10:38:23 <cheater99> you tell me
10:38:27 <cheater99> is it just a concatenation of a scalar item and a list?
10:38:34 <Jafet> Well then, it's just a word with no meaning.
10:38:34 <pikhq> Cons in the general sense is the function that constructs a list from an element and a list.
10:38:36 <ksf> there's the lisp meaning, which is: set car of a tuple to the first, cdr of the tuple to the second argument.
10:38:44 <ksf> strictly speaking, cons is equivalent to (,)
10:38:46 <soupdragon> My other car is a cds
10:38:52 <Jafet> We can't talk about a word with no meaning.
10:39:02 <ksf> ...but the similarities break down due to static typing.
10:39:11 <Jafet> Although we're really good at pretending to, judging from the scroll
10:39:14 <ksf> nested tuples have fixed length in haskell.
10:39:45 <Jafet> Dynamic!
10:39:48 <Jafet> Sorry, I coughed.
10:39:51 <ksf> heretic!
10:40:04 <cheater99> Jafet: i don't think you are being helpful
10:40:11 <cheater99> pikhq: great, thanks
10:40:26 <Jafet> pikhq is talking about a cons that is not the Lisp cons.
10:40:39 <cheater99> Jafet: i am ignoring further comments from you
10:40:42 <Jafet> I wonder what cons he means.
10:40:48 <soupdragon> cheater99: he's just a troll ignore him
10:40:49 <Jafet> You won't be the first.
10:40:54 <cheater99> soupdragon: ok
10:41:25 <cheater99> soupdragon: thanks
10:41:40 <soupdragon> np
10:41:56 <pikhq> Jafet: I'm well aware that the Lisp cons is just something with a car and a cdr. That it happens to be more general than the cons linked list in Lisp is immaterial for discussion of what the concept of cons is, IMO.
10:41:59 <cheater99> ksf: let me quickly check what car and cdf do
10:42:05 <cheater99> cdr
10:42:19 <soupdragon> car and cdr just project out the respective parts of a cons cell
10:42:28 <Jafet> pikhq: you like Tractatus? I'm guessing no
10:42:40 <pikhq> Jafet: Well, cons in the context of cons linked lists, which is all most people care about...
10:42:41 <soupdragon> (define (cons a b) (lambda (sel) (sel a b))) (define (car cons) (cons (lambda (a b) a))) ...
10:42:58 <Jafet> Whatever. You don't have to talk to me.
10:43:03 <soupdragon> in haskell it's fst/snd or head/tail
10:43:12 <cheater99> soupdragon: so the 'car' is the, for example, scalar value, while the cdr will be the rest of the list?
10:43:12 <soupdragon> (distinction made because of typing considerations)
10:43:39 <pikhq> cheater99: For the cons linked lists (the type [a] in Haskell), yes.
10:43:48 <cheater99> ok
10:54:07 <ksf> you can do more with cons than mere lists.
10:54:12 <ksf> binary trees, for example.
10:54:23 <ksf> tuples are the fundamental data type of lisp
10:55:02 <ksf> you've basically got a whole lisp if you have cons, car, cdr, lambda and cond.
10:55:22 <ksf> ...and as soupdragon showed you can get away without predefined cons car and cdr
11:03:12 * hackagebot mwc-random 0.5.1.3 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.5.1.3 (BryanOSullivan)
11:11:55 <bos> preflex: seen rl
11:11:55 <preflex>  rl was last seen on #ghc 15 days, 15 hours, 27 minutes and 54 seconds ago, saying: :)
11:12:09 <bos> ugh, nasty nasty performance problems with the primitive package.
11:12:32 <Zeiris> Reading the SPJ contract composition thing, it looks pretty neat. However, to play the devils advocate for a moment: what does it do that can't be done in, say, an OOP language? It builds a tree data structure. The basic functions + abstract Contract data type hide the implementation, but this could be done in, say, Java just fine.
11:13:37 <bos> @seen dons
11:13:38 <lambdabot> Unknown command, try @list
11:13:41 <bos> preflex: seen dons
11:13:41 <preflex>  dons was last seen on #haskell 2 hours, 13 minutes and 48 seconds ago, saying: the city of portland, oregon. :)
11:25:25 <ManateeLazyCat> It's possible to build *default instance* ?
11:26:09 <Jafet> Huh? You can give default definitions for class methods.
11:26:41 <hpc> if you mean like with "deriving", you use extensions for that
11:26:57 <hpc> @src (//)
11:26:58 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
11:27:00 <hpc> er
11:27:03 <hpc> @src (==)
11:27:04 <lambdabot> x == y = not (x /= y)
11:27:04 <mreh> can I just dive in yi if I know some vim? are there specifics like when opening multiple buffers?
11:27:06 <hpc> @src (/=)
11:27:07 <lambdabot> x /= y = not (x == y)
11:27:10 <mreh> or multiple views
11:27:35 * ManateeLazyCat pasted "type-class" at http://paste2.org/get/910444
11:27:36 <ManateeLazyCat> Jafet: Example, i have above type-class, i want any PageView use default method if it don't define it.
11:27:48 <benmachine> mreh: I found yi subtly different from vim in sufficiently many ways that it annoyed me and I went back to vim
11:27:55 <benmachine> but maybe I'm just not persistent enough
11:28:07 <Jafet> lazycat: so just fill in the default method
11:28:19 <mreh> benmachine: it's like some kind of ViMACS
11:28:29 <benmachine> mreh: heh, yes
11:28:34 <Jafet> class blabla where method :: bla; method = default
11:28:43 <mreh> pointless to include the Vi bindings if you're going to make it extensible
11:28:44 <hpc> how would one pronounce "ViMACS"?
11:28:54 <hpc> "veemax"?
11:28:57 <mreh> vee-max
11:29:07 <hpc> gotcha
11:29:11 <ManateeLazyCat> Jafet: If any PageView instance ignore some method, it's will use default method?
11:29:18 <hpc> yes
11:29:23 <Jafet> hpc: "Ohgodwhat"
11:29:32 <ManateeLazyCat> Cool.
11:29:45 <Jafet> lazycat: yeah
11:29:46 <hpc> so for the eq typeclass, you define one of (==) or (/=) and one defines the other
11:30:02 <hpc> or if they were mean, they could make both return True all the time
11:30:16 <hpc> and you wouldn't need to define either
11:30:35 <hpc> :P
11:31:11 <mreh> so what's the point of yi? it looks like suckering in Vi and EMACS users
11:31:19 <mreh> but I'm sure it has benefits
11:31:37 <benmachine> mreh: config's written in haskell woo
11:31:45 <ManateeLazyCat> Jafet: BTW, i must write default method define at same file that include type-class?
11:31:58 <Jafet> I... think so
11:32:03 <hpc> yes
11:32:08 <hpc> it has to be in the same indentation block
11:32:16 <hpc> like you can't have a do block span many files
11:32:32 <benmachine> hmm I wonder if I should keep old haskell programs I wrote
11:32:42 <benmachine> so I can look back on them when I'm old and go ha ha, what a noob
11:32:44 <ManateeLazyCat> Jafet: I put all type-class in Type.hs for avoid *cycle reference*.
11:32:54 <hpc> benmachine: always fun
11:32:54 <ksf> or vaymacs
11:33:03 <ManateeLazyCat> Jafet: And i don't want special import dirty Types.hs
11:33:09 <ksf> but then there's people (like me) who pronounce vi vee-eye
11:33:24 <Jafet> I think you should start addressing your questions to someone who can answer.
11:33:28 <benmachine> I pronounce it vim
11:33:41 <mreh> it's vee eye
11:33:55 <mreh> someone people call it six
11:34:01 <hpc> i pronounce it "microsoft word with a custom VBA script to convert to plaintext"
11:34:03 <hpc> :P
11:34:24 <mreh> set phasers to troll
11:34:25 <benmachine> ManateeLazyCat: it is possible to make GHC compile mutually-recursive modules
11:34:30 <benmachine> ManateeLazyCat: bit of a pain, though
11:34:53 <ManateeLazyCat> benmachine: I have pay for .hs-boot file. I don't want back. :)
11:35:03 <benmachine> hmm
11:35:17 <ManateeLazyCat> benmachine: I perfer to put all define in one Types.hs file.
11:35:21 <benmachine> just put everything in the same module, encapsulation is for wusses >_>
11:35:33 <benmachine> erm
11:35:37 <ManateeLazyCat> benmachine: Just type in one file.
11:35:42 <benmachine> yeah basically that's a difficult problem
11:35:48 <ManateeLazyCat> benmachine: Then all other module import Types.hs
11:36:06 <hpc> the best is when people do #include "includes.h"
11:36:10 <Dashkal> Is there a best practice for quickcheck, property definitions and modules?  Same module? Diff modules?  If diff, how does one test non-exported functions?
11:36:11 <hpc> or something similar
11:36:15 <ManateeLazyCat> benmachine: Trust me, Types.hs is much better .hs-boot file.
11:36:38 <hpc> all the complications of multiple files, all the pollution of one namespace
11:36:49 <ManateeLazyCat> benmachine: .hs-boot file won't fix problem when project is too big, it will crazy you.
11:36:50 <benmachine> ManateeLazyCat: oh I'm sure, but as you say it doesn't always work if you want to do default method definitions but all the stuff you need is in the modules that are trying to import you
11:37:01 <benmachine> erm
11:37:10 <benmachine> my sentence sooort of made sense, right?
11:38:36 <ManateeLazyCat> benmachine: When i was haskell newbine, i use .hs-boot file, when i fix one *cycle path*, will *jump* another cycle path, ..... until make you crazy.....
11:39:02 <benmachine> ok so don't do that then :P
11:39:06 <ManateeLazyCat> benmachine: Now i use multiple layout integrate Types.hs fix my problem.
11:40:35 * ManateeLazyCat ghc should disable .hs-boot ... it's just make thing worse ... 
11:41:27 <mreh> how a I suppose to learn yi? I can't find any docs
11:41:40 <ManateeLazyCat> mreh: Yi's documentation is poor. :)
11:41:41 <Dashkal> .hs-boot works wonders when used correctly
11:42:07 <ManateeLazyCat> Dashkal: If you just have two files, .hs-boot is okay.
11:42:18 <Dashkal> I've used it in larger projects
11:42:29 <ManateeLazyCat> Dashkal: Do you have Types.hs?
11:42:48 <ManateeLazyCat> Dashkal: BTW, how large? :)
11:42:57 <Dashkal> I define my major data types in their own modules
11:43:09 <Dashkal> Got it down to one cycle.  one .hs-boot file
11:43:40 <ManateeLazyCat> Dashkal: So you just have *one* .hs-boot file?
11:43:43 <Dashkal> 10 or so modules at current count
11:43:44 <Dashkal> just one
11:43:58 <Dashkal> You only need one .hs-boot file per cycle.
11:44:10 <ManateeLazyCat> Dashkal: If you have two or more .hs-boot file, you will know what's i mean. 
11:44:21 <Dashkal> I did some minor refactoring to get it to one
11:44:36 <Dashkal> And if you have many dependancy cycles, you may need to do the same
11:44:57 <ManateeLazyCat> Dashkal: If you need .hs-boot file, you will want use Types.hs instead it.
11:45:08 <benmachine> you could use a tool like SourceGraph
11:45:14 <benmachine> that might help you disentangle your cycles
11:45:29 <ManateeLazyCat> benmachine: I have use one that suggest by morrow
11:45:42 <ManateeLazyCat> benmachine: But nothing help if have too many cycle.
11:45:47 <Dashkal> Encapsulation.  I don't want every type in one huge file
11:46:16 <ManateeLazyCat> Dashkal: Not mean in one huge file, you can build many Types.hs, and put those Types.hs in different *layout*.
11:46:29 <Dashkal> So I reworked my dependancies so everything cycled on one module.  Put the .hs-boot there and called it good.
11:46:47 <ManateeLazyCat> Dashkal: Like *Types.hs pyramid*. :)
11:46:52 * Dashkal shudders
11:47:15 <ManateeLazyCat> Dashkal: Ok, just personal point, choose you like. :)
11:48:05 <hpc> i try to keep modules less than 200 lines, or 50 if i am making types, and export as few names as possible
11:48:41 * ManateeLazyCat I always export all function/type.... 
11:49:12 <Dashkal> If you always export everything, what value are you getting from modules at all?
11:49:34 <benmachine> making your head hurt less
11:49:49 <ManateeLazyCat> Dashkal: ^^^^^^^^^ :)
11:49:56 <Dashkal> That's kind of my point.  My head hurts less when I can reduce the surface area of my modules as much as possible
11:49:59 <hpc> for my IRC bot, i made a point to have every module export one function unless it really needed more
11:50:38 <Dashkal> This way, unless I'm actually working on a module, all I have to think about are the few functions and possibly data type exported
11:50:58 * ManateeLazyCat FunctionName = ModuleName ++ Action, so export everything is okay....
11:51:31 <Dashkal> import qualified?
11:51:52 <hpc> qualified imports are a sign that you aren't encapulating properly, imo
11:52:10 <Dashkal> Depends.  I've written a module or two that intentionally conflicts with prelude
11:52:16 <ManateeLazyCat> Dashkal: If you build good layout, you don't need qualified, i just use qualified with other people's library
11:52:20 <Dashkal> Because the functions had identical uses
11:52:35 <hpc> collisions excepted, of course
11:52:55 <hpc> when you have to import qualified just to keep the names manageable though...
11:53:28 <roconnor> hpc: what should I call Data.Colour.Names.tan ?
11:53:54 <Dashkal> Oh of course not.  But my modules are usually a type + some small number of functions that operate on that type.
11:54:18 <Dashkal> The only time I run into dependancy loops is in applications.  My application monad can run into loops with other modules that export actions for that monad
11:54:34 <Dashkal> I ran into that trying to write a command-dispatch system
11:55:03 <Dashkal> And I _really_ didn't want to put all the command dispatch code in with the application monad
11:56:30 <ManateeLazyCat> Dashkal: I use "Types.hs + Glue.hs ++ Many relative module" to fix *cycle reference*, of course, if a module make sure it won't import other module, i will put type define in it's own module.
11:57:07 <Dashkal> The fact that you go to such lengths is showing how much you're fighting the haskell module system.  Which is why I ask how much value you're getting from it
11:58:14 <ManateeLazyCat> Dashkal: I just give my suggestion, haven't any other mean...
11:58:24 <ManateeLazyCat> Dashkal: If you don't like, i will shut up....
11:59:14 <danharaj> References to dead projects on haskellwiki should be burned :|
11:59:41 <hpc> danharaj: god yes, especially on the opengl/al pages
11:59:44 <soupdragon> yeah that's always frustrating
12:00:11 <hpc> on the openAL page, every tutorial and doc page is a 404 or irrelevant
12:01:03 <danharaj> It's like Link Roulette
12:01:11 <mreh> to hell with openGL, use something high level
12:01:35 <mreh> lambdacube is a little donkey
12:02:03 <danharaj> in this case opengl is exactly what I want.
12:03:08 <hpc> i am using openGL so i can have experience at the low level for when i apply for a job at a game studio
12:03:23 <mreh> that's why I'm learning C++
12:03:38 <mreh> :D
12:03:38 <danharaj> I wish there were direct3d 10 bindings.
12:03:41 <danharaj> But that won't happen.
12:03:43 <hpc> i already learned that through Source
12:03:49 <danharaj> Unless I learn how to make bindings and do it myself.
12:03:51 <hpc> i considered writing D3D bindings
12:03:54 <hpc> yeah
12:04:08 <hpc> although i wanted D3D 11
12:04:13 <danharaj> D3D10/11 is so much nicer than any opengl.
12:04:14 <mreh> I'm going indie as soon as I finish this course
12:05:17 <mreh> what's cross platform like with haskell?
12:05:25 <danharaj> has anyone used GLFW?
12:05:40 <danharaj> I was going to go with SDL + OpenGL but...
12:05:51 <Dashkal> Haskell works fine cross-platform.  Even has bindings to cross-platform gui toolkits
12:06:19 <Philippa> eh, things can be a bitch on windows sometimes
12:06:23 <hpc> installing the openGL bindings on windows sucks hard
12:06:37 <danharaj> hpc : Oh god :|
12:06:37 <soupdragon> yeah and stuff like gtk etc doesn't work on mac 
12:06:39 <hpc> dunno about SDL or GUI toolkits
12:06:56 <danharaj> I managed to build wx with the project maintainer's help
12:07:03 <arw> opengl is easy on windows, given you have a nvidia card.
12:07:03 <Dashkal> I need to learn SDL.  I'm getting the urge to write a fractal generator in hs
12:07:24 <danharaj> If you use Haskell Platform it'll be a bitch, because the ghc version Platform uses is missing C++ support
12:07:46 <mreh> what does c++ have to do with it?
12:07:57 <danharaj> wx is a C++ library.
12:08:05 <mreh> owwh
12:08:17 <hpc> why would your GPU matter for openGL?
12:08:28 <hpc> ATI and NVidia have the same openGL abilities
12:08:31 <danharaj> Yeah, I've decided to just drop Haskell Platform and maintain my own set of libraries.
12:08:34 <Philippa> intel doesn't
12:08:40 <hpc> fuck intel
12:09:00 <Philippa> yeah? I don't have a PC that isn't stuck with intel at the moment and I'm far from the only person out there in that situation
12:09:10 <arw> hpc: the gpu doesn't matter, but the drivers do matter.
12:09:13 <mreh> laptops
12:09:28 <Philippa> mreh: exactly, they're most of the market these days
12:09:30 <hpc> arw: oh right... forgot about that
12:09:40 <arw> hpc: and last i checked, nvidias were better regarding working opengl on windows
12:09:41 <gcross> danharaj: if you are using wx, you can use wxHaskell
12:09:50 <mreh> wxFruit!
12:10:16 <Philippa> gcross: they're talking about the process of getting it to build
12:10:49 <gcross> doh, I wish that IRC had threads so that you could filter out where the conversation came from.  Thanks  :-)
12:10:50 <gcross> my bad
12:10:55 <danharaj> gcross: That's what I was talking about. You can't build wkHaskell with Haskell Platform because the GHC version Platform uses doesn't have C++ support for its copy of gcc (accidentally omitted) because wx is a C++ library.
12:11:08 <danharaj> wxHaskell*
12:11:13 <mreh> If I do go indie, I'll be a one man Q&A team
12:11:16 <mreh> fuuuun
12:11:18 <danharaj> beat me to it :p
12:11:36 <danharaj> mreh: what's your day job gonna be?
12:11:49 <mreh> danharaj: :|
12:12:16 <danharaj> mreh: of the indie developers I know of, most of them had a full time job before they could start living off of indie work.
12:13:11 <sshc> Would anybody suggest gtk2hs over gtk2hs?
12:13:17 <mreh> I'll probably busk, or work in clubs
12:13:24 <sshc> wxHaskell, rather
12:13:25 <danharaj> sshc: Wha?
12:13:27 <danharaj> oh
12:13:32 <sshc> Sorry :)
12:13:40 <Philippa> it's definitely not advisable to go full-time indie without either a pile of savings you're willing to lose outright or an existing library of titles that's selling well
12:14:00 <danharaj> sshc: It depends. What platform are you on, how much do you value cross-platform nativity, and are you using Haskell Platform?
12:14:15 <mreh> Philippa: gotta start somewhere
12:14:22 <mreh> the industry wants C++ programmers
12:14:30 <soupdragon> > 2*45+1
12:14:31 <lambdabot>   91
12:14:36 <sshc> danharaj: *I*'m not using the Haskell Platform, and *I*'m working on Linux; but I value portability.
12:14:46 <hpc> that's just a lack of creativity; they also want WoW clones and Devil May Cry
12:14:59 <Zeiris> Are there any Haskell libraries for doing accurate numeric calculations (financial ones, say)?
12:15:02 <sshc> danharaj: Actually, /me looks up Haskell Platform to make sure
12:15:20 <hpc> a good game can be made in any language
12:15:29 <mreh> of course it can
12:15:40 <sshc> danharaj: I don't think so, but I have a few cabal packages instaltled
12:15:45 <danharaj> sshc: Ok. IMO, gtk is balls on windows. It doesn't feel like a native app. That's why I use wx. However, building wx on windows is hard right now because it can't be done with Haskell Platform. I am not sure how easy it is to build gtk2hs, although apparently it can't be built on mac?
12:15:53 <mreh> the heavy lifting needs to be done in something high level enough though
12:15:56 <danharaj> wxhaskell* etc.
12:16:25 <sshc> Besides the non-better look, how else is eitther better than the other?
12:16:30 <sshc> non-native*
12:16:48 <danharaj> gtk2hs probably has more developers working on it.
12:17:02 <tg_afk> just make it a web app
12:17:05 <sshc> Can't cabal be installed on Windows and the gtk2hs package be installed?
12:17:14 <danharaj> IIRC the only main dev for wxhaskell is Jeremy
12:17:35 <Dashkal> Aren't there QT bindings now?
12:17:36 <sshc> Which is more convenient to work with?
12:17:43 <sshc> Or, which works better with Haskell?
12:17:45 <hpc> danharaj: you could try wrapping wx through some C code and using the existing C->Hs utility
12:18:02 <hpc> or is that what you are doing?
12:18:20 <danharaj> hpc: There's a workaround that involves installing mingw yourself, swapping the platform copy with yours, building and then swapping back but >_<
12:18:37 <hpc> sshc: cabal comes with the platform on windows
12:19:06 <danharaj> But when I did this I got errors when trying to build other binding libraries, so I just got pieces of the platform individually so I can update them independently without worrying.
12:19:20 <danharaj> sshc: I don't know. I haven't worked with gtk or gtk2hs
12:19:26 <danharaj> It should be reasonably easy for either.
12:20:43 <tg_> sshc: you're probably going to get better information by seeking out those who have written Hackage packages with those libraries
12:21:34 <danharaj> huh... when I install new packages I get warnings about prelude being deprecated.
12:21:47 <danharaj> But I have both base 3 and 4 installed. Why are they building with 3?
12:22:54 <Philippa> mreh: yeah, but realistically you probably need to start with another income source, that's all I'm saying
12:22:56 <sm> Zeiris: hledger does some financial stuff
12:23:07 <Heffalump> danharaj: because some dependency has demanded it, probably
12:23:28 <danharaj> Heffalump: Bah. So I'm being warned for something out of my hands?
12:23:29 <mreh> Philippa: have you seen the Brian Aker telephone video?
12:23:40 <Philippa> mreh: nope
12:23:59 <Heffalump> danharaj: potentially. Use --constraint 'base >= 4' and see what it complains about.
12:24:02 <benmachine> danharaj: that's usually the case with compiler warnings :P
12:24:02 <mreh> some guy wanted to start a consultancy, so he spent two years developing an OSS telephony system, so he needn't buy a whole system
12:24:29 <Philippa> mreh: heh, crazy
12:24:38 <benmachine> danharaj: cabal uses base3 in preference to base4 when packages don't specify an upper bound on their base version in the .cabal file
12:24:49 <Philippa> I'm guessing he consults regarding said system now, though
12:25:04 <mreh> Philippa: I don't know
12:25:06 <benmachine> danharaj: so if it's your package, base >= 3 && < 4.3 should do the trick
12:25:20 <mreh> it's pretty likely :)
12:25:24 <nettok> hello
12:25:29 <danharaj> benmachine: It's mtl. Why does cabal do that? I'm sure there's an almost rational reason. :p
12:25:45 <benmachine> danharaj: because lots of people who didn't explicitly say, no base 4 for me please
12:25:46 <mreh> I think it was called trixbox
12:25:52 <benmachine> got their packages broken when base 4 was released
12:25:56 <Philippa> either that or he's "not worth" making a video about, in the sense of "just another failure, who cares?" (well, the pile of people who're also just failures basically because they got unlucky? They probably care)
12:25:57 <benmachine> because it was incompatible
12:26:31 <nettok> I want to find all integral factors of a number, but I get type errors, this is the code...
12:26:34 <nettok> factors n = filter (\p -> fst p) [(n `mod` d == 0, n) | d <- [2..sqrt n]]
12:26:37 <danharaj> benmachine: ah, so I guess I shouldn't try to build it with base 4. Was it that big of a change between versions?
12:27:04 <benmachine> danharaj: Control.Exception in particular was almost completely rewritten
12:27:12 <benmachine> but some modules still will compile with both base versions
12:27:30 <Silvah> #haskell-blah
12:27:31 <nettok> I guess the problem is mixing sqrt and mod... any hint?
12:27:34 <benmachine> especially if they use the extensible-exceptions package
12:27:34 <Silvah> ugh
12:27:47 <benmachine> nettok: try ceiling $ sqrt n
12:27:59 <Silvah> I meant to join that channel, not to write its name ;)
12:28:13 <mreh> take it somewhere else
12:28:15 <mreh> :)
12:28:48 <Philippa> nettok: it's a good idea to post the error as well (at least the first line), save us typechecking the code ourselves
12:29:04 <Philippa> nettok: but I'd imagine that's the issue, yes
12:29:18 <nettok> Philippa: benmachine: i'll post the code and the errors...
12:29:22 <benmachine> nettok: minor stylistic note, (\p -> fst p) is equivalent to just "fst"
12:29:53 <nettok> Philippa: haha, right
12:30:11 <nettok> i meant... benmachine
12:30:15 <benmachine> :)
12:33:37 <nettok> Alex storm made my internet slow...
12:34:00 <nettok> benmachine:  Philippa: here's the code and error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27259#a27259
12:34:26 <nettok> i added ceiling there
12:34:55 <benmachine> hmm
12:35:02 <soupdragon> nettok, put {-# LANGUAGE NoMonomorphismRestriction #-} at the start of your file
12:35:06 <benmachine> ceiling . sqrt . fromIntegral
12:35:13 <benmachine> soupdragon: pretty sure that won't help
12:35:29 <benmachine> nettok: you need fromIntegral as well
12:36:16 <Silvah> Ah, strong type system.
12:36:21 <nettok> benmachine: thanks, no more compiler errors :)
12:36:43 <benmachine> nettok: would you like more general tips? just minor things
12:37:09 <nettok> yeah, I would really like tips, I am newbie
12:37:54 <Silvah> It's always entertaining to read all these "tips".
12:38:00 <benmachine> "tips"?
12:38:03 <benmachine> :O
12:38:05 * benmachine feels slighted
12:38:17 <tg_> just the tip(s)!
12:38:19 <Silvah> ...which are nitpicking, actually.
12:38:22 <benmachine> I was just going to draw attention to the existence of some library functions
12:38:32 <benmachine> e.g.
12:38:33 <benmachine> :t print
12:38:34 <lambdabot> forall a. (Show a) => a -> IO ()
12:38:52 <Taejo> can I get haskell-mode to display the type of the function under the cursor? (I'm a newbie to both emacs and haskell-mode)
12:38:56 <benmachine> :t or -- cf. True `elem`
12:38:58 <lambdabot> [Bool] -> Bool
12:39:19 <benmachine> :t notElem
12:39:20 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:39:44 <nettok> :o   I see
12:40:13 <Taejo> also, is it possible to make it impossible ( :-) ) to erase the prompt in the inferior haskell interpreter
12:40:24 <benmachine> good library knowledge is useful for writing short programs
12:40:41 <benmachine> something that comes with time :P
12:40:58 <Silvah> s/short/concise/
12:41:10 <benmachine> both!
12:41:16 <benmachine> but yeah fine concise is better
12:42:10 <soupdragon> @oies primes of the form 3n+1
12:42:11 <lambdabot>  Primes of the form 3n^2 - 1.
12:42:11 <lambdabot>  [2,11,47,107,191,431,587,971,1451,2027,2351,2699,3467,4799,5807,6911,7499,81...
12:42:13 * nettok nods
12:42:14 <soupdragon> -_-
12:44:02 <medfly> :t isPrime
12:44:03 <lambdabot> Not in scope: `isPrime'
12:44:07 <hpc> :t prime
12:44:08 <lambdabot> Not in scope: `prime'
12:44:48 <hpc> :t primes
12:44:48 <Silvah> :t aFunctionThatDoesntExist
12:44:49 <lambdabot> Not in scope: `primes'
12:44:50 <lambdabot> Not in scope: `aFunctionThatDoesntExist'
12:45:04 <geheimdienst> @hoogle prime
12:45:05 <lambdabot> Data.HashTable prime :: Int32
12:45:05 <lambdabot> Text.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
12:45:05 <lambdabot> Text.ParserCombinators.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m
12:45:05 <lambdabot> a
12:45:14 <nettok> looks good to me now:  factors n = map snd $ filter fst [(n `mod` d == 0, d) | d <- [2..(ceiling . sqrt . fromIntegral) n]]
12:45:30 <Silvah> > 0 >>= id
12:45:32 <lambdabot>   No instance for (GHC.Show.Show (m b))
12:45:32 <lambdabot>    arising from a use of `M2630763182...
12:45:46 <medfly> weird.
12:46:03 <hpc> :t (filter fst)
12:46:04 <lambdabot> forall b. [(Bool, b)] -> [(Bool, b)]
12:46:12 <hpc> :t filter
12:46:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:46:40 <hpc> you can put the condition in the comprehension rather than building a list of tuples
12:47:03 <nettok> mmm...
12:47:04 <hpc> [d | d <- [2..(ceiling . sqrt . fromIntegral) n], n `mod` d == 0]
12:47:13 <medfly> > take 50 (filter isPrime [3*n+1 | n <- [1..]])
12:47:14 <lambdabot>   [7,13,19,31,37,43,61,67,73,79,97,103,109,127,139,151,157,163,181,193,199,21...
12:47:26 <medfly> @oeis 7,13,19,31,37,43
12:47:27 <lambdabot>  Primes of form 6n + 1.
12:47:27 <lambdabot>  [7,13,19,31,37,43,61,67,73,79,97,103,109,127,139,151,157,163,181,193,199,211...
12:47:38 <medfly> well that works too.
12:47:40 <hpc> haha
12:48:04 <medfly> cause 3*n has to be even anyhow.
12:48:32 <nettok> hpc: Done. Thanks.
12:48:41 <benmachine> hpc: you put your ] in the wrong place there I think?
12:48:44 <benmachine> ph
12:48:45 <benmachine> oh
12:48:46 <benmachine> no
12:48:47 <geheimdienst> what is the factors function supposed to do?
12:48:48 <benmachine> I'm just being conused
12:48:49 <hpc> no, tis a lambda
12:48:50 <benmachine> f
12:49:17 <nettok> > let factors n = [d | d <- [2..(ceiling . sqrt . fromIntegral) n], n `mod` d == 0] in factors 13195
12:49:19 <lambdabot>   [5,7,13,29,35,65,91]
12:49:21 <hpc> geheimdienst: factors x = [list of factors of x]
12:49:23 <hpc> or that
12:49:55 <hpc> comprehensions took me a while to grok
12:50:05 <geheimdienst> okay. cause i played around with the "map snd $ filter fst" version, and it doesn't work :-)
12:50:14 <hpc> i still don't get the monad instance for list
12:50:40 <benmachine> it's not quite the list of factors of x, it's just those less than the sqrt
12:50:48 <benmachine> but the others are all easy to find when you have those
12:51:07 <hpc> oh wait, they aren't even prime factors
12:51:23 <Silvah> So the name is misleading.
12:51:38 <medfly> factors doesn't imply they're prime :)
12:52:06 <hpc> you could change it to [d | d <- [2..n], n `mod` d == 0]
12:52:15 <nettok> > let isPrime n = True `notElem` [n `mod` d == 0 | d <- [2..n-1]] in [5,7,13,29,35,65,91]
12:52:16 <lambdabot>   [5,7,13,29,35,65,91]
12:52:21 <hpc> medfly: it implies all of them ;)
12:52:29 <nettok> mmm... not good
12:52:29 <medfly> oh... right, that it does
12:52:44 <hpc> > let isPrime n = True `notElem` [n `mod` d == 0 | d <- [2..n-1]] in filter isPrime [5,7,13,29,35,65,91]
12:52:45 <lambdabot>   [5,7,13,29]
12:52:48 <nettok> > let isPrime n = True `notElem` [n `mod` d == 0 | d <- [2..n-1]] in isPrime [5,7,13,29,35,65,91]
12:52:49 <lambdabot>   No instance for (GHC.Real.Integral [t])
12:52:49 <lambdabot>    arising from a use of `isPrime' ...
12:52:59 <nettok> hpc: :P
12:53:00 <hpc> > let isPrime n = True `notElem` [n `mod` d == 0 | d <- [2..n-1]] in map isPrime [5,7,13,29,35,65,91]
12:53:01 <lambdabot>   [True,True,True,True,False,False,False]
12:53:29 <hpc> yay standard library :P
12:55:02 <geheimdienst> > let f = [n `mod` d == 0 | d <- [2..n-1]] in f 42
12:55:02 <lambdabot>   Couldn't match expected type `t1 -> t'
12:55:02 <lambdabot>         against inferred type `[GHC....
12:55:05 <medfly> > let factors n = [x | x <- [2..sqrt(n)], n `mod` x = 0] in factors 35
12:55:06 <lambdabot>   <no location info>: parse error on input `='
12:55:12 <medfly> uhh...
12:55:28 <medfly> @let facs n = [x | x <- [2..sqrt(n)], n `mod` x = 0]
12:55:29 <lambdabot>   Parse error: Equals
12:55:31 <geheimdienst> > let n = 42 in [n `mod` d == 0 | d <- [2..n-1]]
12:55:32 <hpc> > let factors n = [x | x <- [2..sqrt(n)], n `mod` x == 0] in factors 35
12:55:32 <lambdabot>   [True,True,False,False,True,True,False,False,False,False,False,False,True,F...
12:55:34 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:55:34 <lambdabot>    `GHC.Float.Floating t'
12:55:34 <lambdabot>  ...
12:55:42 <medfly> oh right
12:55:43 <geheimdienst> > let n = 42 in [n `mod` d | d <- [2..n-1]]
12:55:44 <lambdabot>   [0,0,2,2,0,0,2,6,2,9,6,3,0,12,10,8,6,4,2,0,20,19,18,17,16,15,14,13,12,11,10...
12:55:58 <medfly> @let facs n = [x | x <- [2..(sqrt n)], n `mod` x = 0]
12:55:58 <lambdabot>   Parse error: Equals
12:56:07 <medfly> @let facs n = [x | x <- [2..(sqrt n)], n `mod` x == 0]
12:56:09 <lambdabot>  Defined.
12:56:16 <medfly> > facs 35
12:56:17 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:56:17 <lambdabot>    `GHC.Real.Integral t'
12:56:18 <lambdabot>   ...
12:56:23 <benmachine> my iteratees are slow
12:56:49 <medfly> @undefine facs
12:56:54 <geheimdienst>  let isPrime n = filter (/=0) [n `mod` d | d <- [2..n-1]] in isPrime [5,7,13,29,35,65,91]
12:57:01 <geheimdienst> > let isPrime n = filter (/=0) [n `mod` d | d <- [2..n-1]] in isPrime [5,7,13,29,35,65,91]
12:57:01 <lambdabot>   No instance for (GHC.Real.Integral [t])
12:57:02 <lambdabot>    arising from a use of `e_1021571...
12:57:07 <medfly> > isPrime 5
12:57:08 <lambdabot>   Not in scope: `isPrime'
12:57:12 <medfly> oh, you undefined it
12:57:35 <hpc> "let ... in" doesn't span lines
12:57:39 <geheimdienst> > let isPrime n = filter (/=0) [n `mod` d | d <- [2..n-1]] in map isPrime [5,7,13,29,35,65,91]
12:57:40 <lambdabot>   [[1,2,1],[1,1,3,2,1],[1,1,1,3,1,6,5,4,3,2,1],[1,2,1,4,5,1,5,2,9,7,5,3,1,14,...
12:57:53 <geheimdienst> > let isPrime n = any (/=0) [n `mod` d | d <- [2..n-1]] in map isPrime [5,7,13,29,35,65,91]
12:57:54 <lambdabot>   [True,True,True,True,True,True,True]
12:58:04 <geheimdienst> > let isPrime n = all (/=0) [n `mod` d | d <- [2..n-1]] in map isPrime [5,7,13,29,35,65,91]
12:58:05 <lambdabot>   [True,True,True,True,False,False,False]
12:58:20 * geheimdienst uses the shotgun approach to programming, apparently
12:58:30 <hpc> >	> let isPrime n = all (/=0) [n `mod` d | d <- [2..n-1]] in isPrime 1
12:58:34 <hpc> er
12:58:41 <hpc> > let isPrime n = all (/=0) [n `mod` d | d <- [2..n-1]] in isPrime 1
12:58:42 <lambdabot>   True
12:58:47 <Silvah> Shotgun approach?
12:58:49 <hpc> > let isPrime n = all (/=0) [n `mod` d | d <- [2..n-1]] in isPrime 2
12:58:50 <lambdabot>   True
12:59:02 <hpc> > let isPrime n = all (/=0) [n `mod` d | d <- [2..n-1]] in isPrime 0 -- >:D
12:59:04 <lambdabot>   True
12:59:29 <geheimdienst> try "filter" ... oh, doesn't work. try "any" ... oh, wrong. maybe i meant "all" ...
12:59:54 <hpc> shoot so many bullets you are bound to hit the target
12:59:57 <geheimdienst> use library functions until some output appears that approaches what i wanted :-)
13:00:01 <hpc> to make the metaphor literal
13:00:34 <medfly> heh
13:00:55 <medfly> I used this.
13:00:58 <medfly> @let isPrime :: Integral a => a -> Bool; isPrime p = p > 1 && (all (\n -> p `mod` n /= 0 ) $ takeWhile (\n -> n*n <= p) [2..])
13:00:59 <lambdabot>  Defined.
13:01:11 <hpc> it works when the space of permutations is small
13:01:15 <Silvah> > let isPrime = randomR (0, 1) . mkStdGen in isPrime 2
13:01:16 <lambdabot>   (1,120042 40692)
13:01:23 <Silvah> er
13:01:27 <hpc> haha
13:01:56 <hpc> you aren't going to get it to be really random without unsafePerformIO
13:01:57 <Silvah> > let isPrime = (/= 0) . randomR (0, 1) . mkStdGen in isPrime 2
13:01:58 <lambdabot>   No instance for (GHC.Num.Num System.Random.StdGen)
13:01:59 <lambdabot>    arising from the lite...
13:02:10 <Silvah> eh...
13:02:35 <geheimdienst> > mkStdGen
13:02:36 <lambdabot>   Overlapping instances for GHC.Show.Show
13:02:37 <lambdabot>                              (GHC.T...
13:02:53 <Silvah> > let isPrime = (/= 0) . fst . randomR (0, 1) . mkStdGen in isPrime 2
13:02:54 <lambdabot>   True
13:03:06 <Silvah> lol, it works :D
13:03:32 * geheimdienst whips out quickcheck
13:03:39 <geheimdienst> let's see that function pass 100 tests
13:03:44 <geheimdienst> ;-)
13:03:44 <hpc> @check > let isPrime = (/= 0) . fst . randomR (0, 1) . mkStdGen in \x -> isPrime x = True
13:03:45 <lambdabot>   Parse error at "=" (column 77)
13:03:53 <hpc> @check let isPrime = (/= 0) . fst . randomR (0, 1) . mkStdGen in \x -> isPrime x = True
13:03:54 <lambdabot>   Parse error at "=" (column 75)
13:04:13 <aristid> > let isPrime = (/= 0) . fst . randomR (0, 1) . mkStdGen in isPrime 3
13:04:14 <lambdabot>   True
13:04:18 <aristid> > let isPrime = (/= 0) . fst . randomR (0, 1) . mkStdGen in isPrime 4
13:04:19 <lambdabot>   True
13:04:25 <aristid> MEEP
13:04:27 <geheimdienst> > let isPrime = const True in isPrime 2
13:04:28 <lambdabot>   True
13:04:30 <hpc> @check let isPrime = (/= 0) . fst . randomR (0, 1) . mkStdGen in \x -> isPrime x == True
13:04:31 <lambdabot>   "OK, passed 500 tests."
13:04:32 <geheimdienst> works!
13:04:50 <hpc> it passed the tests! it is correct!
13:05:38 <geheimdienst> @check False
13:05:39 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:06:00 <hpc> @check "Who cares?"
13:06:01 <lambdabot>   No instance for (Test.QuickCheck.Testable [GHC.Types.Char])
13:06:02 <lambdabot>    arising from...
13:06:04 <geheimdienst> so @check just makes sure it returns true all the time
13:06:17 <geheimdienst> @check const "Who cares?"
13:06:17 <lambdabot>   No instance for (Test.QuickCheck.Testable [GHC.Types.Char])
13:06:17 <lambdabot>    arising from...
13:06:24 <Silvah> > let isPrime = (/= 0) . fst . randomR (0, 1) . mkStdGen in False `elem` map isPrime [2..]
13:06:25 <lambdabot>   True
13:06:29 <geheimdienst> @check True
13:06:30 <lambdabot>   "OK, passed 500 tests."
13:06:45 <hpc> @check (const id "Who cares?")
13:06:46 <lambdabot>   "Arguments exhausted after 0 tests."
13:08:52 <Silvah> Huh?
13:09:54 <Silvah> Uhm, well.
13:12:49 <danharaj> building opengl on windows
13:12:52 <danharaj> I am nervous.
13:13:04 <danharaj> So many files being processed, and each one a potential fatal error.
13:13:19 <danharaj> huzzah victory
13:13:40 <Silvah> hpc: I didn't want it to be truly random.
13:16:08 <Dashkal> @check (id :: Bool -> Bool)
13:16:09 <lambdabot>   "Falsifiable, after 1 tests:\nFalse\n"
13:22:55 <soupdragon> > solve (\k a b -> k+b == 1 && 2*k+a==-1)
13:22:56 <lambdabot>   Not in scope: `solve'Not in scope: `==-'
13:24:40 <danharaj> oh god
13:31:11 <benmachine> @check liftM2 (||) id not
13:31:12 <lambdabot>   "OK, passed 500 tests."
13:31:20 <benmachine> @check liftM2 (&&) id not
13:31:21 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\n"
13:31:36 <aristid> @check (||) <$> id <*> not
13:31:37 <lambdabot>   "OK, passed 500 tests."
13:31:50 <mauke> liftM2 c id g better written as ap c g
13:32:16 <aristid> @check (||) <*> not
13:32:16 <lambdabot>   "OK, passed 500 tests."
13:32:33 <benmachine> @check id
13:32:34 <lambdabot>   "Arguments exhausted after 0 tests."
13:32:40 * benmachine still wonders what that's about
13:32:45 <aristid> @check id :: Int
13:32:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:32:51 <aristid> @check id :: Bool
13:32:51 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:32:54 <mauke> @check id :: Bool -> Bool
13:32:55 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> GHC.Bool.Bool'
13:33:11 <benmachine> @check (id :: Int -> Int)
13:33:12 <lambdabot>   No instance for (Test.QuickCheck.Testable GHC.Types.Int)
13:33:12 <lambdabot>    arising from a ...
13:34:15 <sclv> @check (id :: Bool -> Bool)
13:34:15 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\n"
13:34:35 <sclv> @check (id :: () -> ())
13:34:36 <lambdabot>   "Arguments exhausted after 0 tests."
13:34:48 <hpc> @check ()
13:34:49 <lambdabot>   "Arguments exhausted after 0 tests."
13:35:05 <soupdragon> so whats the LHC about?
13:35:50 <jbapple> soupdragon: sending tiny particles into each other very, very fast
13:35:52 <hpc> colliding hadrons
13:36:01 <soupdragon> but why?
13:36:05 <hpc> for science!
13:36:12 <jbapple> for grants!
13:36:14 <hpc> and to compensate for tiny penises
13:36:18 <soupdragon> I don't beleive in science
13:36:47 <jbapple> Also, I think it's a Haskell compiler designed for teaching about compilers
13:38:04 <Saizan> that's UHC
13:38:41 <geheimdienst> Glorious Glasgow Hadron Compiler System
13:38:51 <geheimdienst> Large Haskell Collider
13:39:00 <hpc> Literate Haskell Collider
13:39:24 <sclv> Lemmih's Hadron Collider
13:39:38 <soupdragon> there should be a #haskell category theory beginners club
13:39:43 <jbapple> Let's Halt (this) Cleverness
13:40:11 <tg_> soupdragon: that'd be a big club
13:40:26 <geheimdienst> ... big category ...
13:40:27 <soupdragon> tg_, good!
13:40:39 <soupdragon> seriously though I want to learn the category but it is very difficult
13:41:28 <danharaj> Can anyone help with building the GLUT bindings on windows? I found a blog entry describing this, but it is outdated.
13:41:39 <ezyang> What errors are you getting? 
13:41:55 * ezyang probably can't help, but you should post errors anyway 
13:42:03 <tg_> what a tease!
13:42:06 <tg_> hehe
13:42:17 <danharaj> ezyang: When I run a test program, I get "user error (unknown glut entry glutInit)"
13:42:33 <tg_> that's fantastic
13:42:38 <danharaj> I suspect it is because I messed up building freeGLUT and the glut bindings.
13:42:41 <ezyang> that doesn't sound like a build error. 
13:42:44 <danharaj> Also I like how it says it's my fault.
13:42:54 <ezyang> What source code emits that? 
13:42:59 <danharaj> ezyang: eh?
13:44:13 <ezyang> danharaj: As in, is C or Haskell emitting that error? 
13:44:19 <ezyang> A quick grep should tell you. 
13:44:30 <danharaj> ezyang: this is windows, I have no grapes.
13:45:02 <tommd> @go grep windows
13:45:02 <lambdabot> Maybe you meant: google googleit do
13:45:11 <tommd> A bad platform isn't an excuse to not have developer tools
13:45:15 <tommd> @google grep windows
13:45:16 <lambdabot> http://www.wingrep.com/
13:45:16 <lambdabot> Title: Windows Grep: Grep for Windows
13:45:51 <geheimdienst> i'm a little surprised you can build opengl and glut without having cygwin ...
13:45:58 <ezyang> me too... 
13:46:09 <danharaj> I just remembered I'm using msys and it has grep :p
13:46:27 <AlexForster> is there a less ugly way than terminal to do repl on mac os x?
13:46:37 <AlexForster> talking about tooling
13:47:08 <tommd> AlexForster: You could use tryhaskell...
13:47:31 <danharaj> so uh... how do you use grep?
13:47:34 <ezyang> danharaj: cabal unpack packagename, btw, to grab the HAskell source. 
13:47:36 <tommd> But if you're looking for IDLE, which I'd consider a prettier terminal then no, not that I know of.
13:47:43 <danharaj> ezyang: I has it.
13:47:48 <dons> Slides are up for Engineering Large Projects in a Functional Language - http://is.gd/dnaYP
13:47:58 <dons> just presented it downtown in Portland.
13:48:00 <tommd> danharaj: grep "user error (unknown glut entry" * -R
13:48:09 <ezyang> sweet. 
13:48:14 <dons> ezyang: has some things you might want  to take and distill at some point.
13:48:19 <tommd> If only I lived in Portland... oh, wait!
13:48:24 <dons> if only!!
13:48:33 <dons> boy it is a nice day for cycling out there 
13:50:02 <ezyang> I’m working on my Feo post first :-) 
13:50:29 <dobblego> <-- about to head off into the forest with my enduro motorcycle
13:50:29 <dkc> so i have a question trying to understand haskell types (from a ruby programmer)
13:50:36 <dkc> why can't i use them as values?
13:50:55 <dons> ezyang: ah great. XMT ftw.
13:51:01 <geheimdienst> what would you want to do with them then?
13:51:02 <dkc> have a data A, data B,  and then data C = (type A)
13:51:03 <sepp2k> dkc: Because that would make type checking a tad more complicated
13:51:04 <dons> tommd: you didn't see the XMT talk yesterday?
13:51:13 <danharaj> dkc: It would also break certain nice properties.
13:51:18 <danharaj> i.e. parametricity
13:51:44 <sepp2k> dkc: You can do that with  type C = A
13:52:06 <dkc> not really ... C is just a synonym for A
13:52:22 <sepp2k> Right, isn't that what your code was supposed to do?
13:52:31 <danharaj> tommd: Thanks, but I get: grep: invalid option -- R
13:52:44 <ezyang> lol 
13:52:47 <dkc> no it's more like i want to look at a value's type and do something based on that, dynamically
13:53:00 <ezyang> dkc: Typeable? 
13:53:03 <dkc> i don't need to *set* it or *change* it dynamically, but i'd like to read it
13:53:08 <dkc> (what's that? googling..)
13:53:27 <ezyang> (or maybe Reify. I haven't used any of those features, but it sounds like what you want.) 
13:53:29 <sepp2k> dkc: Plain old typeclasses might be sufficient for that.
13:53:44 <danharaj> dkc: While you can do that, with Typeable, it's not really a preferred technique in Haskell. Try typeclasses first.
13:54:08 <sshc> In a .cabal file, what do I need to replace "license: GPL" with to use version 2?
13:54:22 <benmachine> Typeable gets you a value-level representation of a type
13:54:59 <danharaj> eww GPL.
13:55:12 <dkc> ok that seems very handy
13:55:52 <danharaj> dkc: It is very powerful, but like I said, you shouldn't resort to it quickly. Haskell prefers using types statically rather than dynamically. I'm sure this is much different from Ruby.
13:56:08 <geheimdienst> danharaj, try: grep -ri "the error message" /source-code-directory/
13:56:44 <danharaj> geheimdienst: Thanks, if grep doesn't echo anything, does that mean nothing was found?
13:56:54 <geheimdienst> yes
13:56:55 <dkc> danharaj: ok i'll try to get around it (also because the haddock reads like greek to me)
13:57:39 <danharaj> geheimdienst: ok thanks. That means that it is the windows runtime telling me this, I suspect. I think it is trying to load a dll but failing, and I don't know why. The dll is right there.
13:58:00 <dkc> if i have a data type like data Message = Message { field1 :: Maybe Field1, ...., field72 :: Maybe Field72 }, is there some way to instantiate a message with all of the fields set by default to Nothing?
13:58:32 <geheimdienst> dude, you may want to use a list for that ... [Maybe Field]
13:58:41 <Zao> geheimdienst: Disjoint types.
13:58:56 <danharaj> make it a variant and don't try to encode the format in the type.
13:59:04 <danharaj> well, a sum type I should say.
13:59:05 <Zao> I assume they're not as similiar as the example shows.
13:59:21 <dkc> well
13:59:32 <dkc> each Field is a different possible field the message could have
13:59:34 <Zao> Of course, I'm guessing wildly.
13:59:43 <dkc> with varying numbers of parameters and stuff
13:59:50 <sshc> If I license code under a BSD license, do I need to put any extra comments regarding it in the source as a comment?
14:00:42 <tommd> dons: No, I missed that talk
14:00:46 <dkc> the reason i was doing it that way is that i've got MessageB which has an overlapping set of fields to MessageA
14:00:49 <tommd> danharaj: Then grep --help
14:00:50 <Philippa> you don't have to, though it's a good idea to reiterate your copyright in it and mention the license
14:02:07 <dkc> danharaj: what is a variant or a sum type?
14:02:10 <Zeiris> What are Haskell strengths and weaknesses with respect to writing games? Trees and lazy evaluation could be very interesting for 3D LOD and space partitioning. I suspect you could do interesting things with procedural content via combinators... Not sure what else. 
14:02:38 <dons> tommd: we'll have video, so no worries.
14:02:48 <Zeiris> In terms of weaknesses, I remember having severe doubts about 2D low-level arrays (per-pixel manipulation stuff, although I guess that's decades old and nobody does it now. :( )
14:03:42 <medfly> I know some people are working on a game in Haskell... best ask them :-p
14:04:29 <sepp2k> dkc: data Foo = Bar X | Baz Y Z
14:04:32 <Zeiris> I'm tempted to take something Haskell excells at, and try and center a simple game around the technology. My knowledge of the language isn't too deep though, so trees are al I can think of :)
14:04:42 <Philippa> Zeiris: strong static typing with inference is mostly good, but there's still a nasty typing problem for game simulation work (but you can use dynamics as a stopgap)
14:04:50 <Lemmih> Zeiris: There are quite good Haskell bindings to several graphical frameworks.
14:04:53 <mreh> medfly: that RPG?
14:05:00 <medfly> it counts, doesn't it?
14:05:05 <Philippa> dons: that reminds me, I have a potential solution to that problem I need to write up one of these years
14:05:09 <Zeiris> Yeah, the SDL and OpenGL bindings look quite nice. :3
14:05:25 <danharaj> ok this is such a bad hack, but I managed to solve it by getting a different .dll off the internet. I have no idea which version of glut it is built from but if it works...
14:05:55 <ezyang> they don't call it dll hell for nothin' 
14:06:02 <danharaj> Zeiris: Abandon hope if you're on windows and want to use SDL OpenGL. Hope gets in the way.
14:06:09 <mreh> medfly: yes, I can't remember the name
14:07:21 * hackagebot bird 0.0.9 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.9 (MattParker)
14:07:25 <dkc> so ... is there a way of initializing data A = A { f1 :: Maybe F1, f2 :: Maybe F2 } to A Nothing Nothing without explicitly writing out the Nothing's ?
14:07:25 <Zeiris> danharaj, I haven't used SDL before but GLUT + OpenGL should be extremely easy?
14:07:53 <danharaj> Zeiris: Building the libraries will be a pain.
14:08:06 <mauke> dkc: maybe with SYB, but even if not, you only have to do it once
14:08:22 <Zeiris> Hm, the examples I've tried built a simple GLUT application with ease.
14:08:30 <dkc> ok thx
14:08:35 <danharaj> Zeiris: If Haskell Platform comes with it, you'll be good.
14:08:40 <Zeiris> Re: strong static typing, I regularly run into design speedbumps where I want to store different types in a list, or vector or whatever.
14:08:43 <danharaj> But if you like to configure things yourself...
14:08:57 <mauke> dkc: import Data.Default; instance Default A where def = A def def  -- :-)
14:09:09 <Zeiris> I'm not sure whether that's an issue of unidiomatic design, or if there's some trick I'm unaware of.
14:09:44 <danharaj> Zeiris: You probably want to use something like data C = C1 A | C2 B
14:09:53 <dkc> ok cheers
14:10:44 <dkc> i think i'm going to give up on trying to encode my protocol into the type system, and just let a message be a Map from fieldnames -> values, and then encode the restrictions on the fieldnames into the parser, rather than trying to make the type system keep everything correct
14:11:37 <peeler> I have used SDL. It's good.
14:11:38 * soupdragon feels sad about all the wasted type level effort that could have gone into dependently typed programs
14:11:50 <peeler> I think it's a bit more flexible than GLUT.
14:13:24 <elliottcable> inimino 3» here as well, for good measure.
14:13:37 <inimino> ^.^
14:14:25 <dkc> someone should really make a way to let data A = [Any one of the instances of type class AField], where it could be different instances in varying elements of the list
14:14:27 <Philippa> soupdragon: so go take part in the development and industrialisation of dependently-typed programming
14:14:50 <mreh> what is "dependetly-typed programming"?
14:15:18 <Philippa> do you know what dependent types are?
14:15:33 <mreh> I've heard to functional dependencies
14:15:37 <sepp2k> dkc: Someone did. Google existential types.
14:15:38 <mreh> s/to/of
14:15:47 <mreh> my typing is whack
14:15:48 <dkc> sepp2k: nope they didn't
14:15:52 <Philippa> okay, that'd be a no. Roughly speaking, dependent types are when types depend on values
14:16:05 <Philippa> for example, instead of a 'list' type you might use a 'vector' type that's parameterised on the length of the list
14:16:12 <dkc> you can't actually *use* the elements of the list for anything if you make them existentially typed
14:16:36 <sepp2k> dkc: You can call AField's functions on them.
14:16:40 <Philippa> or rather, a family of them. The type of ++ tells you that the result's length is the sum of the parms' lengths
14:16:48 <sepp2k> What else could you possibly be able to do with them?
14:16:57 <Philippa> one consequence is that you can really run wild with the Curry-Howard isomorphism
14:17:00 <dkc> also - you can only put *one* of the instances in them
14:17:10 <sepp2k> dkc: Not true.
14:17:11 <dkc> the quantifier just lets you avoid specifying which  one
14:17:20 <mreh> okay, I've heard a lot about that
14:17:27 <mreh> no idea what it is
14:17:41 <mreh> but I'm sure it's important if we're programming in Haskell (Curry)
14:18:01 <sepp2k> dkc: Existential types differ from normal polymorphic types specifically in that you can put different instances in them.
14:18:06 <Philippa> the slogan version is "types are propositions, programs are proofs"
14:18:45 <Philippa> so the types can contain a full specification of what a given value is supposed to be/do, and the values can be accompanied by a proof that they meet the spec
14:18:55 <dkc> sepp2k: so last night I start off with data A = forall a. (AField a) => [a]
14:20:03 <mauke> dkc: syntax error
14:20:29 <dkc> right sorry ... with the constructor
14:21:25 * hackagebot bird 0.0.10 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.10 (MattParker)
14:21:54 <mreh> Philippa: sounds impressive
14:21:54 <mauke> dkc: where?
14:21:58 <mreh> but slow
14:22:09 <dkc> but ... data MsgA = forall a. (AField a) => MsgA [a]  , and then instance AField F1, instance AField F2, and finally MsgA [F1, F2]
14:22:09 <mreh> lots of extra computational baggage
14:22:11 <dkc> fails
14:22:36 <mauke> dkc: well, duh
14:22:59 <dkc> mauke: data MsgA = forall a. (AField a) => MsgA [a] gives no error.   MsgA [F1, F2] does (obviously)
14:23:03 <dkc> so ... how do i do this?
14:23:07 <dkc> i need [F1, F2]
14:23:15 <mreh> how do you go about computing a proof for an infinite set?
14:23:23 <mauke> data SomeField = forall a. (AField a) => C a
14:23:35 <mauke> [C F1, C F2]
14:23:42 <Philippa> mreh: go read up on coinductive datatypes :-)
14:23:45 <mauke> maybe add instance AField SomeField where ...
14:23:50 <Philippa> mreh: also, the proofs don't have to be 'run' at run-time
14:24:21 <dkc> so when I want to use data MsgA = [SomeField]
14:24:22 <Philippa> as edwinb's PhD thesis points out, dependently-typed programs can actually be faster than conventionally-typed ones - the compiler knows more
14:24:32 <dkc> how can I figure out what kind of fields they were?
14:24:43 <dkc> and get their data from them?
14:24:52 <mauke> dkc: you can't
14:25:26 <dkc> ok .. and there aren't workarounds to this? like some other way of structuring it?
14:25:59 <mauke> well, not really true
14:26:07 <mauke> you juse have to put all required operations in AField
14:26:13 <mauke> s/juse/just/
14:26:31 <CakeProphet> so
14:26:43 <CakeProphet> GADT are very good for designing interpreters yes?
14:27:53 <Philippa> CakeProphet: yeah, they're a big help there
14:28:14 <Philippa> it's far from all they're good at though - and a lot of problems are or involve interpreters if you squint right
14:29:59 <Heffalump> cabal: cannot configure haskeline-0.6.2.2. It requires base ==2.*
14:30:28 <Heffalump> how do I debug that? cabal install haskeline -v3 isn't helping me understand why cabal thinks it requires base 2 when the deps on hackage clearly state a range of alternatives.
14:31:43 <Igloo> The error comes from teh last configuration it tries, I think
14:32:03 <Philippa> that's rather confusing
14:32:47 <napping> dkc: you put the existential a little too far out
14:33:05 <napping> dkc: If you want a bunch of different instances of you type it has to be like [exists t. (C t) => t]
14:33:20 <napping> if you do exists t . (C t) =>[t], then you only have one place to make a choice
14:33:23 <geheimdienst> heffalump, when i run cabal info haskeline, i get "base == 2.*" and then later "base >=3 && <4.1"
14:33:51 <napping> so, like data AnyC where WrapC :: forall t . (C t) => t -> AnyC
14:33:54 <geheimdienst> there's 3 deps referring to versions of base, if i didn't miscount
14:34:01 <napping> and [AnyC]. pretty ugly, though
14:34:48 <geheimdienst> and yes, it's pretty unhelpful how these deps get printed :-(
14:35:46 <Heffalump> geheimdienst: yes, precisely
14:36:09 <napping> dkc: why don't use a simple data type with constructors for the alternatives?
14:36:27 <Heffalump> Igloo: ah, right. But then how do I find out about what else it tried?
14:37:53 <geheimdienst> heffalump, i guess you're building with the "base2" flag set: http://hackage.haskell.org/packages/archive/haskeline/0.6.2.2/haskeline.cabal
14:38:13 <geheimdienst> maybe it defaults to true
14:38:18 <Heffalump> not deliberately, certainly.
14:38:18 <napping> Philippa: you have some notions relevant to dons' talk?
14:38:40 <Heffalump> That would seem very unfortunate if it did! And I suspect it didn't in the past, because otherwise it'd never have worked.
14:38:49 <Heffalump> (I'm using GHC 6.13 here so something may be weird)
14:38:59 <Philippa> napping: I was talking about the mention of gamedev at the time
14:39:01 <Igloo> I haven't used cabal-install much, so don't know how best to debug it
14:39:24 <Philippa> one thought I do have about the talk is that 50K isn't necessarily everyone's idea of a large project, but mileage varies
14:39:40 <Heffalump> now I'm even more confused:
14:39:47 <CakeProphet> hmmm... the docs for Data.Generics.Basics and Instances  are apparently missing
14:39:54 <ddarius> Hmm...
14:40:10 <illissius> hmm
14:40:12 * ddarius wonders if the LED specifying whether his WiFi is operational is broken...
14:40:16 <illissius> template haskell is pretty ugly.
14:40:31 <illissius> works, though. that's a big advantage.
14:40:32 <Heffalump> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27265#a27265
14:41:41 <geheimdienst> heffalump, sometimes the defaults are unfortunate. the other day i wanted to install quickcheck, and "cabal install quickcheck" gave me some version that's years old and mostly undocumented. turns out there's a file "preferred-versions" which makes that so. you have to say quickcheck >=3 ...
14:41:59 <Heffalump> you mean the global default on hackage?
14:42:21 <Heffalump> I think that's a workaround for specific widely used packages, rather than something that happens frequently
14:42:29 <geheimdienst> yeah. just on the topic of weird default versions ...
14:42:43 <CakeProphet> so Data.Generic introduces a sort of structural typing system?
14:43:01 <Saizan> Heffalump: ghc-pkg list base ?
14:43:14 <Saizan> Heffalump: i suspect you've base-4.3.x
14:43:23 <napping> dkc: is your field list really extensible?
14:43:34 <Heffalump> Saizan: oh, duh. Yes
14:43:49 <Saizan> Heffalump: in that case, cabal unpack haskeline; edit .cabal; bump version; cabal install
14:43:54 <Heffalump> The message is kind of cryptic though :-)
14:44:03 <Heffalump> yes, now I understand the problem I can fix it
14:44:35 <Saizan> yeah, the message is not great..
14:44:41 <Heffalump> the defaulting of the flag is confusing too
14:45:12 <danharaj> how do you comment out lines in a .cabal file?
14:46:00 <Saizan> i guess that if all the alternatives fail cabal-install should report the error against the defaults..
14:46:08 <kau> Hello!
14:46:08 <Saizan> rather than the last alternative
14:46:14 <soupdragon> hi
14:46:18 <Saizan> (as it seems to be doing here)
14:46:27 <kau> do you know how to spawn a new console?
14:47:08 <Saizan> and "because of the top level dependency base -any" really means "because we want to use an installed version of base"
14:47:54 <Axman6> kau: huh? in haskell?
14:48:36 <kau> Axman6: yes, i'd like to have a multi console program
14:48:47 <Axman6> what do you mean?
14:49:01 <kau> several shell windows
14:50:11 <zygoloid> kau: i assume you mean on MS Windows? you could probably FFI to the appropriate system calls
14:50:16 <dkc> napping: sorry was afk
14:50:42 <zygoloid> kau: http://msdn.microsoft.com/en-us/library/ms682528(VS.85).aspx
14:50:48 <dkc> napping: that's what i want to do and would be the correct way probably (using a data type with lots of constructors)
14:51:00 <kau> zygoloid: no, not necessarily windows, on linux too.
14:51:06 <dkc> napping: but there are many different options ... maybe TemplateHaskell could help..
14:51:12 <zygoloid> kau: the concept of multiple console windows doesn't exist on linux.
14:51:19 <napping> what is this for again?
14:51:39 <zygoloid> kau: you don't create your own console there, you have a console given to you (or not) at startup
14:51:46 <kau> <zygoloid: when you run a program, it runs in a terminal... I'm like to have several output terminals
14:52:02 <napping> kau: that's an unusual use. Usually a terminal window wants to start it's own shell
14:52:02 <Axman6> :\
14:52:26 <zygoloid> kau: the easiest approach would be to require your users to start the program once in each console where you want output
14:52:37 <zygoloid> kau: you'd then need to set up a mechanism for your processes to talk to each other.
14:52:47 <napping> kau: I notice rxvt at least takes a -pty-fd option to connect to existing fds
14:52:48 <kau> <zygoloid: ok
14:52:52 <dkc> data MessageA = MessageA { f1 :: Maybe Field1, ...,  fN :: Maybe FieldN }
14:52:53 <napping> er, and existing pty
14:53:17 <dkc> data MessageB  = MessageB { some other set of fields which overlaps with MessageA's }
14:53:20 <dkc> there are lots of fields
14:53:25 <peeler> it seems like a case in which it would be better to separate your app into different components
14:53:33 <kau> <zygoloid: perhaps a system call would do?
14:54:05 <napping> dkc: ah, that's a bit unfortunate. O'Caml has a nice "polymorphic variant" thing for letting you have overlapping sets of constructors like tha
14:54:15 <zygoloid> kau: for what? there is no notion of 'spawn a new console window' on linux. you could start a specific terminal program as napping suggests though
14:54:39 <zygoloid> kau: if you want to go that way, it looks like you can use the unix-pty-light package on hackage to allocate a pty
14:54:45 <dkc> napping: i've been told about Typeable, HList and SYB/TemplateHaskell as options
14:54:56 <napping> dkc: what are these messages for?
14:55:04 <zygoloid> kau: but it won't be portable; you'll need another mechanism for windows (if you care about that)
14:55:05 <dkc> napping: it's a protocol
14:55:12 <kau> <zygoloid: i see
14:55:14 <dkc> napping: for stock quotes
14:55:43 <napping> this sounds like the sort of thing that is possible to represent precisely, but at the cost of using some very fancy stuff and taking some syntactic overhead
14:56:11 <dkc> yes, i'm seriously considering just giving up on making the type system do it and just encoding the whole thing as constants with Maps
14:56:37 <soupdragon> how do I show a digit?
14:56:39 <soupdragon> like 4 -> '4'
14:56:40 <napping> maps sound fairly reasonable if every field is options
14:56:49 <aristid> soupdragon: chr?
14:56:52 <soupdragon> > let p = 13 ; e x = x^2+1 ; d x = 2*x ; inv k = head [ u | u <- [1..p-1], (u * k) `mod` p == 1 ] ; a 0 = head [ a0 | a0 <- [0..p-1], (e a0) `mod` p == 0, d a0 /= 0 ] ; a i = let m = a (i-1) in m - inv (d m) * e (m) in showIntAtBase p chr (let k = 30 in (a k `mod` (p^k))) ""
14:56:54 <napping> and if you really need to run functions over ever single field
14:56:54 <dkc> napping: not every field, just a subset of fields :)
14:56:54 <aristid> oh wait
14:56:55 <aristid> heh
14:56:56 <lambdabot>   mueval-core: Time limit exceeded
14:57:03 <aristid> :t head . show
14:57:04 <lambdabot> forall a. (Show a) => a -> Char
14:57:19 <soupdragon> I need one that shows up to baes 13
14:57:24 <napping> If you could treat it as a list of differently typed fields, would you ever map over that list?
14:57:29 <mauke> > intToDigit 4
14:57:30 <lambdabot>   '4'
14:57:32 <soupdragon> > let p = 13 ; e x = x^2+1 ; d x = 2*x ; inv k = head [ u | u <- [1..p-1], (u * k) `mod` p == 1 ] ; a 0 = head [ a0 | a0 <- [0..p-1], (e a0) `mod` p == 0, d a0 /= 0 ] ; a i = let m = a (i-1) in m - inv (d m) * e (m) in showIntAtBase p (intToDigit) (let k = 20 in (a k `mod` (p^k))) ""
14:57:33 <mauke> > intToDigit 12
14:57:33 <lambdabot>   "5474036c688101550155"
14:57:34 <lambdabot>   'c'
14:57:42 <dkc> so run the same function on every message?
14:57:44 <aristid> > intToDigit 0
14:57:45 <lambdabot>   '0'
14:57:47 <zygoloid> > fix (head . show)
14:57:49 <aristid> > intToDigit 100
14:57:50 <lambdabot>   *Exception: Char.intToDigit: not a digit 100
14:57:50 <dkc> no
14:57:50 <lambdabot>   mueval-core: Time limit exceeded
14:57:58 <aristid> > intToDigit 16
14:57:59 <lambdabot>   *Exception: Char.intToDigit: not a digit 16
14:58:01 <zygoloid> > head . show $ (undefined :: Char)
14:58:01 <aristid> > intToDigit 15
14:58:02 <lambdabot>   *Exception: Prelude.undefined
14:58:02 <lambdabot>   'f'
14:58:13 <napping> dkc: no, on every field of a message
14:58:15 <zygoloid> that's disappointing :(  i wonder why show for Char isn't lazier
14:58:21 <aristid> hmm intToDigit is quite limited
14:58:24 <soupdragon> > let p = 13 ; e x = x^2+1 ; d x = 2*x ; inv k = head [ u | u <- [1..p-1], (u * k) `mod` p == 1 ] ; a 0 = head [ a0 | a0 <- [0..p-1], (e a0) `mod` p == 0, d a0 /= 0 ] ; a i = let m = a (i-1) in m - inv (d m) * e (m) in showIntAtBase p (intToDigit) ((let k = 20 in (a k `mod` (p^k)))^2) ""
14:58:25 <lambdabot>   "2282ba40b674829c011ccccccccccccccccccccc"
14:58:26 <kau> zygoloid: what i'm doing for the moment, is that i'm forkIO'ing a program in GHCI. But then this program does require inputs, and it all messes up with GHCI command line ;)
14:58:31 <soupdragon> the ccccccccccc means I got it right :P
14:58:49 <dkc> right, sorry - maybe
14:58:51 <soupdragon> thankss
14:59:01 <dkc> napping: the only case i can think of is that when i want to encode messages
14:59:02 <aristid> :t fix (head . show)
14:59:03 <lambdabot> Char
14:59:07 <soupdragon> sqrt(-1) = ...5474036c688101550155
14:59:11 <soupdragon> in 13
14:59:22 <napping> dkc: okay, then it sounds like you might as well make records with a variety of field types
14:59:23 <dkc> i'll want to go through every single field, render it as ascii, and then concatenate them
14:59:35 <napping> sure, that's easy with something like binary
14:59:36 <aristid> zygoloid: you want it to return '\''?
14:59:50 <zygoloid> yeah
14:59:55 <napping> put (Record f1 f2 f3 f4 ...) = do put f1; put f2; put f3; ...
15:00:23 <zygoloid> > head $ show (undefined :: String)
15:00:24 <lambdabot>   '"'
15:00:27 <dkc> napping: is there any way to generate code like that automatically? (e.g. a lisp macro?)
15:00:28 <zygoloid> aristid: ^^ like that, but for Char
15:00:39 <dkc> napping: because some of these messages have like 40 fields
15:00:42 <napping> dkc: um, you could try TH.
15:00:49 <danharaj> If I build a C Library with MSVC, will it make ghc explode or is it all cool if I bind to it?
15:00:52 <napping> dkc: 40 might be enough to break even.
15:00:58 <napping> actually, wait, can you derive binary?
15:01:21 <zygoloid> no. but you can derive Data, and that's probably enough
15:01:22 <dkc> i'm not sure ... does it just require my stuff to be made of normal data?
15:01:35 <Heffalump> saizan: can you help explain http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27267#a27267 ? For some reason cabal wants to reinstall unix despite it already being installed. (Which then fails for a dependent project, because the unix on hackage doesn't allow base-4.3)
15:01:59 <dkc> none of the fields are functions or anything weird .. they're all basically just strings and ints (i'd like to apply constraints to some of those, but i'll deal with that later)
15:03:25 <dkc> napping: what does deriving binary do?
15:03:36 <zygoloid> kau: fwiw, MSDN says "A process can be attached to at most one console." so you're out of luck on windows
15:04:15 <napping> dkc: binary is just a library (with a class Binary) for serialization
15:04:40 <kau> zygoloid: OK, it seems i must do some thread communication ;)
15:04:44 <napping> I guess you want to fit some text protocol anyway
15:04:48 <dkc> yep
15:05:01 <dkc> any chance you have a miraculous way to automate that?
15:05:18 <napping> dkc: you want to do mostly the same thing for each element?
15:05:41 <ddarius> danharaj: It should be fine.
15:05:54 <dkc> yeah each field has a number tag identifying it, and basically i just put tag=content, where content is pulled out of the data type
15:06:27 <dkc> in fact (!) - i should go find a querystring parser from one of the http libs, and just modify it a bit..
15:06:50 <Taejo> does haskell-mode only show the types of Prelude functions?
15:13:05 <soupdragon> can you implement hyperreal numbers in haskell?
15:13:20 <soupdragon> I think they are constructing using zorns lemon so you might not be able to program it
15:13:58 <napping> dkc: at some point, you want a constructor with 40 fields with no particular structure, you have to say that
15:14:36 <napping> dkc: It would be pretty straightforward to make a template haskell thing, assuming you know TH
15:15:21 <napping> I made one the other day that takes a record type and a list of field names, and makes a bunch of functions like get1 (Record x _ _ _ ...) = x, get2 (Record _ x _ _ ...) = x ...
15:15:39 <dkc> napping: yes that's what i need
15:15:59 <dkc> napping: basically i'd put the protocol into a bunch of data in a TH file, which would generate the same protocol in the type system in my actual file
15:16:26 <dkc> but i don't know TH ... i'm reading bulat's tutorial right now
15:17:47 <napping> you can try TH things in GHCi
15:18:01 <HugoDaniel2> hi
15:18:19 <dkc> napping: can't i use a parser generator to generate my parser? i feel like using TH is basically manually writing a parser generator
15:18:23 <dkc> in this case
15:18:47 <Saizan> Heffalump: when a package is both installed and available on hackage the dep. solver assumes that if it can't successfully configure the available one from scratch than it can't even use the installed one in the current install plan, which should be a safe assumption if no one edits .cabal files without bumping the version
15:19:02 <napping> dkc: are you just learning Haskell?
15:19:02 <aavogt> dkc: happy apparently gives you some haskell function
15:19:13 <dkc> napping: yes
15:19:46 <napping> It might be best to get it working in the straightforward way first
15:19:53 <Heffalump> Saizan: I see, thanks
15:20:16 <napping> Even if your parser is generated automatically you will probably need to connect it up to the types
15:20:20 <dkc> napping: i'm sure you're right, but that feels like total defeat.  if i wanted to do that, i'd have had it done in python 2 days ago :)
15:20:36 <lispy> hi
15:20:42 <napping> a rules like msg1 := field1 field2 field3 field4 ... field40 { Message1 $field1 $field2 ... $field40 }
15:21:03 <dkc> right i see
15:21:12 <napping> you might look at BNFC
15:21:14 <dkc> yeah it probably won't automatically nicely sugar the field names
15:21:44 <napping> It's limited to strict BNFC, but does construct a type as well as a parser and printer
15:22:21 <dkc> cool, googling
15:22:37 <napping> anyway, messing around with fancy stuff will save what, 40 lines of code for each message, and the sort that's easy to make with some editor help
15:23:10 <aavogt> deriving Data is probably going to be easier
15:23:13 <dkc> yeah ... my best idea so far has been to write python scripts to generate my haskell ... poor man's TH
15:23:19 <dkc> what does deriving Data do?
15:23:35 <aavogt> it gives you all the methods in the Data.Data.Data class
15:23:42 * hackagebot hstatistics 0.2.2.1 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.1 (VivianMcPhail)
15:24:10 <aavogt> for 'free', so if you can write your function in terms of those, it will work for any type that has (a correctly implemented) Data instance
15:24:18 <napping> Those were very tricky for me to understand even being comfortable with the rest of the language
15:25:06 <aavogt> I guess: there's lots of stuff in there you won't need
15:25:18 <napping> aavogt: in particular, there is a one-constructor type with a bunch of Show-able fields (or maybe a custom class)
15:25:34 <napping> the goal is to get the concatenation of show of each field
15:25:39 <aavogt> dkc: do you need to know what the labels for each field are?
15:26:09 <dkc> aavogt: yes i think so ... e.g. i'd like to be able to process each field differently
15:26:26 <dkc> aavogt: i don't really understand what you're asking though
15:26:40 <napping> hmm, maybe gfoldl from syb-with-class
15:26:55 <aavogt> I mean if you have   data Foo = Foo { a,b,c :: String },  do the names of  a, b or c matter?
15:26:58 <aavogt> (in the output)
15:27:18 <dkc> no, they don't ... just the types of a, b, an dc
15:27:21 <danharaj> oh joy
15:27:33 <aavogt> is everything flat, or is there some nesting to take care of?
15:27:35 <danharaj> the sdl-mixer library does not build
15:27:43 <dkc> flat
15:27:50 <danharaj> even using the same tricks used to build sdl sdl-ttf and sdl-image
15:27:59 <aavogt> then it's pretty easy =)
15:28:24 <dkc> aavogt: great!
15:28:56 <napping> aavogt: except you need a shop instance - so syb-with-class
15:29:08 <napping> aavogt: in particular, each field has a different type
15:29:25 <aavogt> napping: there's just a fixed set of types though
15:29:37 <aavogt> it's ok to enumerate the 5 or so
15:29:47 <napping> aavogt: if each field has a different type?
15:30:20 <aavogt> yeah, you just try each one in turn
15:30:37 <napping> aavogt: but then you are back up to O(n) code. lemme try syb-with-class
15:30:58 <aavogt> n is the number of types, not the number of fields
15:31:13 <napping> dkc: isn't that the same, in your plans?
15:31:52 <dkc> yes i would try all the fields and only use the ones that show up in the message
15:32:09 <napping> dkc: but do you want each field to have a different type in the record?
15:32:16 <napping> or  only a few types?
15:32:17 <aavogt> it looks different to me
15:32:31 <dkc> each field should have a different type
15:33:07 <aavogt>  try all fields vs. try all types fields could take vs. not enumerating any types by some magic that napping knows =)
15:33:28 <dkc> OR if i have data Field = Field1 String | Field2 Int | etc., if i could say that MessageA can only use fields such-an-such constructors
15:33:38 <dkc> but i think that can't happen, so they need to have different types
15:35:28 <adimit> Can I get ghci to print out actual Unicode instead of escape sequences when `show`ing stuff? My terminal can handle it...
15:36:01 <mauke> no, show doesn't care about your terminal
15:36:12 <mauke> also, there is no "actual unicode"
15:37:06 <adimit> well, there's a difference between a λ and a \955. I'd like the former, not the latter. But I wouldn't know how to achieve that...
15:37:22 <dkc> adimit: i think he means utf8/utf16 etc.
15:37:39 <mauke> which version of ghci?
15:37:41 <adimit> dkc: well, yeah. Sorry for my badly worded question.
15:37:51 <adimit> 6.12.1
15:38:15 <mauke> what does putStr "λ" say?
15:38:28 <mauke> (because that's broken in 6.10.2, which I have)
15:38:43 <adimit> It says the right thing. nice, thanks.
15:38:55 <adimit> I guess I'll just go with putStr . show  then.
15:39:14 <Saizan> instead of?
15:39:25 <adimit> just 'show'
15:39:56 <mauke> what
15:40:09 <adimit> i.e., my data structure has a 'Show' instance that emits unicode characters, not only ASCII. If I want to visualize that, I used to type 'show'
15:40:18 <adimit> as in show x, where x is the data structure.
15:40:24 <mauke> show "λ" is "\955"
15:40:39 <mauke> oh, ok
15:40:58 <adimit> yes, I thought one could change that (somehow internally.) But just putStr will be good enough for me. Thanks!
15:41:54 <dkc> aavogt: do you know of a nice syb tutorial? google is mainly turning up papers by people at utrecht
15:43:08 <aavogt> papers tend to be decent tutorials
15:43:35 <jmcarthur> yeah, they usually have to start from some sort of first principles anyway
15:44:08 <aavogt> though for your purposes, you just have to understand the methods  gmapQ, and how you'll try using  cast to see if your type in question actually is one you use
15:44:47 <napping> I'm confused, I have instance (Show a) => Sat (ShowContext a) where ...
15:45:01 <napping> and obviously Show Int, but I'm getting "no instance Sat (ShowContext Int)"
15:45:17 <aristid> > show "λ"
15:45:18 <lambdabot>   "\"\\955\""
15:45:21 <mauke> ok, that's weird
15:45:29 <aavogt> dkc: there are quite a few competing generics libraries, http://www.haskell.org/haskellwiki/Research_papers/Generics
15:45:37 <soupdragon> > show "?"
15:45:38 <lambdabot>   "\"?\""
15:45:47 <aristid> > text "λ"
15:45:47 <lambdabot>   λ
15:46:35 <dkc> i guess this is what's amazing and frustrating about haskell
15:47:14 <Saizan> the Scrap Your Boilerplate papers are quite nice
15:47:19 <jmcarthur> it gets frustrating and more amazing as you learn
15:47:26 <jmcarthur> *less frustrating and more amazingf
15:47:28 <jmcarthur> -f
15:47:42 <JasonFelice> Is there a library with a data type for parsing algebraic equations?
15:47:50 <soupdragon> why do people link to google books on forums?
15:47:55 <soupdragon> instead of just naming the book
15:48:05 <soupdragon> it's like gee thanks now I can look at copyright notices .....?
15:48:07 <napping> oh, it was trying to print the dictionary
15:48:09 <Katerina> Has anybody done a write-up of the SICP solutions in Haskell?
15:48:11 <napping> nm
15:48:17 <Saizan> though Uniplate is probably the easiest to work with, if it fits
15:48:21 <soupdragon> @go code poetry sicp 
15:48:22 <lambdabot> Maybe you meant: google googleit do
15:48:42 <napping> In syb-with-class, can you request that subterms have a class even if the top level doesnt?
15:48:59 <dkc> what's the difference between uniplate and syb in layman's terms?
15:49:15 <soupdragon> @go code poetics sicp in other languages
15:49:15 <lambdabot> Maybe you meant: google googleit do
15:49:25 <napping> uniplate is much simpler, but mostly only works if you want to extract sub-values of the same type
15:49:32 <napping> like, all nodes in a tree or something
15:49:48 <Saizan> you can do more things with syb, but the types are more complex
15:49:56 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27271#a27271
15:50:29 <aavogt> dkc: ^^
15:50:59 <jmcarthur> dkc: uniplate is simpler and many times is all you need. syb does more stuff
15:51:15 <Katerina> Thank you soupdragon
15:51:26 <aavogt> jmcarthur: is user code simpler? Or is it just easier to learn becuase there's less there?
15:51:49 <napping> dkc: syb is one of the most complicated haskell libraries, up there with HList
15:52:07 <dkc> haha .. HList is the other thing i was suggested to try
15:52:30 <jmcarthur> aavogt: i don't remember now
15:52:49 <dkc> i guess one way to scale a learning curve is to just flatten it with your face, which i seem to be doing now
15:53:17 <jmcarthur> @remember dkc one way to scale a learning curve is to just flatten it with your face
15:53:18 <Saizan> aavogt: the lack of higher-rank polymorphism makes everything less scary :)
15:53:18 <lambdabot> I will never forget.
15:54:01 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/curves.jpg - semirelated
15:54:17 <dkc> aavogt: i'm squinting at your hpaste
15:54:31 <jmcarthur> woah, comma in a url. i know it's valid, i just don't recall seeing it actually *used* before
15:55:12 <aavogt> dkc: the high level concept is simple even if the code isn't that simple
15:55:46 <aavogt> you don't need any classes if you list your types to try in the code that actually shows them
15:56:07 <jmcarthur> i just want to say this one thing: i have yet to take haskell for granted. every time i use it, i'm glad i'm not using a different language
15:56:30 <danharaj> ok I have a strong feeling that building the bindings for sdl-mixer was never tested on windows
15:56:42 <napping> jmcarthur: you've never missed polymorphic variants?
15:58:29 <dkc> aavogt: ok i think i need to read more about generics before i can parse this
15:58:32 <jmcarthur> napping: honestly, i don't even know what that is, so i guess not, at least not by that name
15:58:32 <aavogt> dkc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27271#a27272
15:58:41 <jmcarthur> i'm reading a paper now
15:59:21 <dkc> oooo
15:59:22 <aavogt> dkc: the top code is just a fancy version of the bottom one
15:59:58 <aavogt> so Typeable means that you may inspect the type of that value, which lets you do a type-safe cast (at runtime)
16:00:50 <aavogt>  cast x   gives you Nothing if the type you ask for doesn't match the one that the Typeable instance claims that piece of data has
16:00:53 <dkc> ~(x,xs) pulls apart .. what's the ~ for?
16:01:08 <jmcarthur> napping: alright, now that i know what that is, i can't say i've ever *wanted* it, but that may be because it wasn't a part of my vocabulary
16:01:22 <dkc> basically you've got 'cast'
16:01:23 <jmcarthur> i may run into cases that i want it now. i don't know
16:01:26 <dkc> which does some magic
16:01:43 <aavogt> dkc: taking apart   ts = undefined   would blow up without the ~
16:01:55 <aavogt> yes, Typeable and cast are magic
16:02:49 <dkc> is this the base Data.Generics library or some other one? i don't see those in the haddocks..
16:02:55 <dkc> cast and undefined
16:03:05 <aavogt> undefined is Prelude
16:03:18 <dkc> oops
16:03:30 <aavogt> @docs Data.Typeable
16:03:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
16:03:39 <mauke> @index cast
16:03:39 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
16:04:16 <dkc> ok this is quite nice
16:04:51 <napping> jmcarthur: it's handy when some processing eliminates some possible constructors
16:05:01 <dkc> (also, can i take \955bot home?)
16:05:07 <napping> or for less deep reasons if  you want to use a name in several types
16:05:13 <aavogt> with some more ghc extensions, you can make the definition of ts there nicer
16:05:27 <aavogt>  -XTypeOperators or something
16:06:58 <mauke> @where goa
16:06:58 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
16:07:13 <aavogt> napping: did you have any success trying the same but without having to explicitly list some types to try?
16:07:24 <napping> aavogt: where is your code?
16:07:28 <aavogt> (so to instead use 'all possible instances')
16:07:37 <aavogt> napping: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27271#a27272
16:07:54 <ivanm> is there a nicer way of doing this?
16:07:55 <ivanm> @pl \(a,b) (c,d) -> (f a c, g b d)
16:07:56 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. g) . flip . (((.) . (,)) .) . f)
16:08:03 <EvanR> in a case expr of, will the expr be 'fully evaluated' or only evaluated enough to check against the following patterns
16:08:19 <EvanR> 1:4:3:9:xs
16:08:42 <aavogt> > (f *** g) (a,b)
16:08:43 <lambdabot>   Ambiguous type variable `c' in the constraints:
16:08:43 <lambdabot>    `GHC.Show.Show c'
16:08:43 <lambdabot>      a...
16:08:47 <napping> EvanR: just enough
16:08:47 <aavogt> > (f *** g) (a,b) :: Expr
16:08:48 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
16:08:48 <lambdabot>         against inferred ...
16:08:56 <EvanR> interesting
16:09:09 <ivanm> aavogt: well, (f a *** g b) matches the type
16:09:15 <ivanm> but then it's not entirely point-free
16:09:16 <napping> aavogt: that looks pretty reasonabl
16:09:31 <ivanm> @pl \(a,b) -> (f a *** g b)
16:09:32 <lambdabot> uncurry ((. g) . (***) . f)
16:09:35 <ivanm> ugh
16:09:43 <danharaj> What mailing list should I post in to get help building sdl-mixer on windows?
16:09:50 <ivanm> danharaj: -cafe ?
16:09:51 <aavogt> you need an ap for tuples... perhaps one already exists
16:10:00 <ivanm> unless there's a specific sdl-haskell mailing list
16:10:04 <ivanm> aavogt: hmmm...
16:10:16 <ivanm> aavogt: wouldn't that only be for (a,) ?
16:10:20 <ivanm> same as the monad?
16:10:29 <danharaj> ivanm: thanks.
16:12:13 <napping> aavogt: aha, victory
16:13:32 <aavogt> @type \f g -> uncurry (\(x,y) -> (f *** g) (x,y))
16:13:33 <lambdabot>     Couldn't match expected type `b -> c'
16:13:33 <lambdabot>            against inferred type `(c1, c')'
16:13:33 <lambdabot>     Probable cause: `***' is applied to too many arguments
16:13:50 <aavogt> @type \f g -> (\(x,y) -> (f *** g) (x,y))
16:13:51 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
16:14:48 <aavogt> napping: where is it?
16:15:02 <napping> aavogt: attached to your paste
16:15:15 <napping> dkc: Check the paste, I think the code I eneded up with is actually fairly reasonable
16:15:34 <napping> the interesting call to the generic stuff is the gmapQ in the show function for Foo
16:17:51 <dkc> phoo .. ok
16:18:17 <dkc> @docs Data.Generics.SYB.WithClass.Basics
16:18:18 <lambdabot> Data.Generics.SYB.WithClass.Basics not available
16:18:28 <dkc> @docs Data.Generics.SYB
16:18:28 <lambdabot> Data.Generics.SYB not available
16:18:29 <napping> http://hackage.haskell.org/packages/archive/syb-with-class/0.6.1/doc/html/Data-Generics-SYB-WithClass-Basics.html
16:18:32 <napping> it's on hackage
16:18:40 * aavogt should properly learn/use GADTs some day
16:18:46 <dkc> he doesn't do hackage docs? :(
16:19:00 <napping> the GADT is a bit gratuitious
16:19:13 <napping> I could have said something like data ShowContext t = ShowDict (t -> String)
16:19:36 <napping> wrapping the shower function instead of using GADTs to add (Show t) to the context when you match on it
16:21:56 <aavogt> same with the ScopedTypeVariables and probably every other extensions you used :)
16:22:13 <napping> ScopedTypeVariables is used in showQ
16:22:28 <dkc> data ShowContext t where ShowDict :: (Show t) => ShowContext t is somewhat confusing, yes
16:22:45 <napping> though not essentially, I guess
16:22:54 <napping> all the class stuff comes from the generated instances
16:23:23 <napping> dkc: that means you are only allowed to use ShowDict to make a value of type ShowContext t if t is an instance of Show
16:24:01 <napping> so in the case in showQ, when you are inside the branch that was constructed with ShowDict you now know that the argument type must actually be an instance of Show, so it's okay to call "show"
16:24:24 <napping> but, easier just to pack along a value of type (t -> String) and call it
16:24:54 <haploid> what's the point of using lambda notation when you can save typing by passing in a function directly, e.g. (*3)
16:25:26 <mauke> haploid: complicated stuff gets ugly
16:25:49 <SevenInchBread> haploid:  what if the function you want to pass in can't be represented sanely as higher-orderisms?
16:26:04 <dkc> napping: so that 'where' is an syb thing
16:26:18 <haploid> allright, makes sense
16:26:31 <napping> which "where"? the only one I see is the type class thing
16:26:33 <napping> in the instance
16:26:45 <dkc> data ShowContext t where ShowDict :: (Show t) => ShowContext t
16:26:54 <napping> oh, that's GADTs
16:27:02 <dkc> ok that's what's confusing me
16:27:04 <napping> not a part of SYB
16:27:05 <dkc> but i think i get it now
16:27:16 <napping> where instroduces a list of constructors
16:27:26 <CakeProphet> :t withFile
16:27:26 <lambdabot> Not in scope: `withFile'
16:27:34 <CakeProphet> :t System.IO.withFile
16:27:35 <lambdabot> forall r. FilePath -> GHC.IOBase.IOMode -> (GHC.IOBase.Handle -> IO r) -> IO r
16:27:35 <aavogt> dkc: napping's code uses a different library that's sort of like syb, but lets you parameterize by classes or something, hence it's called syb-with-class
16:27:35 <napping> organized by whitespace like e.g. instance methods after where, or statements after do
16:27:51 <napping> for each you say ConstructorName :: type
16:28:06 <CakeProphet> haploid:  withFile is an example of a higher-order function that commonly is called with a lambda as argument.
16:28:06 <aavogt> the syntax is just like a typeclass
16:28:12 <napping> where the type can be a function but has to end up in some application of your type
16:28:39 <napping> but you can do stuff like data Test a where AnInt :: Test Int; AChar :: Test Char; Anything :: Test a
16:28:39 <CakeProphet> haploid:  withFile "filepath" ReadMode (h -> do {...})
16:29:08 <napping> unlike normally declared types, the return type of the constructor doesn't have to be completely polymorphic in all the type arguments of the type being delcared
16:29:25 <napping> but there I'm just using to transport around a "show" function
16:29:30 <aavogt> functions like those should use rank-2 polymorphism to prevent the abuse     withFile "" x return :: IO Handle , but it's closed!
16:29:37 <CakeProphet> napping:  is there a minimum amount of polymorphism required?
16:30:01 <napping> CakeProphet: not at all. You can do data T a where X :: T Int
16:30:27 <CakeProphet> napping:  well I mean... does it always have to be T a as the last type?
16:30:33 <dkc> ok ... so what is a ShowDict?
16:30:34 <napping> oh, yes it does
16:30:35 <aavogt> it might not be too ugly if you had a phantom type   Handle a
16:30:42 <napping> oh, yes it doestype
16:30:55 <napping> you are defining constructors of the new type, so they have to actually construct values in that type
16:33:11 <dkc> napping: i'm sorry, but despite your having performed magic, it's just totally over my head
16:33:41 <dkc> i think the tryTs2 is about as far as i can go right now without panicking
16:34:37 <CakeProphet> from what I can tell, and I've only recently been learning GADTs, it seems that it is simply a way to convey information about which constructor can be used by specifying type parameters that represent that information.
16:34:53 <JoeyA> Why do I get a missing .so error when I try loading HDBC-sqlite3-2.1.0.2 , despite having the package installed?
16:35:03 <napping> dkc: reload, I simplified it a little
16:35:09 <JoeyA> I can use it if I use ghc --make, but not with runghc or ghci
16:35:16 <soupdragon> CakeProphet: but also notice that when you pattern match on a constructor of a GADT that can cause the types in teh context to be refined
16:35:26 <CakeProphet> ah.
16:35:35 <CakeProphet> well, I suppose that fits into the same semantic idea
16:35:36 <JoeyA> (I'm on Ubuntu, and by "package", I meant the libghc6-hdbc-sqlite3-dev Ubuntu package
16:35:58 <CakeProphet> pattern matching over the construction /does/ restrict the type in GADTs... because the parameter represents information about which construction of a type is used.
16:36:20 <soupdragon> so the information flows both ways
16:37:14 <napping> dkc: Data ctx a means you can inspect "a" in generic ways, and that "a" and maybe some children are in the type class represented by ctx
16:37:30 <dkc> so what does the Sat class do?
16:37:37 <napping> that's how the context is used
16:37:50 <napping> Sat a just means that there is a value "dict" of type a
16:38:15 <napping> so you make a context type like my ShowContext, so that having a (ShowContext a) is about as good as knowing that a is an instance of Show
16:38:19 <CakeProphet> I'm not sure if GADTs are actually what I want to use though
16:38:21 <nettok> Is there something like a downloadable and comprehensible standard library documentation?
16:38:31 <CakeProphet> maybe when I get into building a domain-specific language, but at the moment I don't think they help.
16:38:42 <Zao> nettok: The docs for whatever core you have ought to be bundled with your compiler.
16:38:50 <Zao> and/or Haskell Platform.
16:38:54 <soupdragon> I'm interested in GADTs beyond the cheesy 'well typed interpreter'
16:39:04 <napping> dkc: oh, the "deriveOne ''Foo" line is a TH thing
16:39:09 <nettok> Zeo: GHC platform
16:39:13 <geheimdienst> zao, i think by "comprehensible" he didn't mean haddock ...
16:39:16 <nettok> Zao ...
16:39:18 <dkc> napping: what's it do?
16:39:27 <napping> dkc: it's invoking the macro deriveOne on ''Foo - which makes a symbol for the typename Foo
16:39:48 <napping> that just gives you the instance for the generic stuff - that takes care of knowing how many parameters there are and stuff like that
16:39:59 <nettok> so not?
16:40:02 <napping> so types get one instance of Data independent of the context
16:40:24 <napping> like instance (Data ctx a, Data ctx b, Sat (ctx (a,b))) => Data ctx (a,b)
16:40:38 <CakeProphet> soupdragon:  wouldn't GADTs restrict you in a sense. For example, what if you wanted a list of type T. Won't the forall constrain you to only allowing a particular constructor in the list? Would you need an existential in order to represent a list of any type T a?
16:40:44 <dkc> ok
16:40:57 <napping> so if you demand any particular Data ctx (a,b), it checks that (a,b) has the right instance, and the children are recursively in the type
16:41:38 <soupdragon> CakeProphet: data Exists p where WITNESS :: p a -> Exists p
16:41:43 <napping> oh, and you make a Sat instance like Show a => Sat (ShowContext a)
16:41:44 <soupdragon> Then [Exists T]
16:41:58 <dkc> ok so the deriveOne is why you can say Data ShowContext a in the next line?
16:42:04 <napping> so the typechecker trying to find Sat (ShowContext a) automatically reduces to looking for Show a
16:42:24 <napping> dkc: no, later down. The next line is just a polymorphic function
16:42:35 <nettok> :o  I think this is what I need http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
16:42:42 <napping> for any type a, if there happens to be an instance (Data ShowContext a) ...
16:43:17 <napping> in particular, it just uses the fact that (Sat (ctx a)) is a superclass of (Data ctx a) to show the value you give it directly
16:43:25 <dkc> ah! ok 
16:43:35 <dkc> i didn't know Sat is a superclass of Data
16:43:36 <napping> and the reason we care about that is the gmapQ call a few lines down
16:43:53 <napping> http://hackage.haskell.org/packages/archive/syb-with-class/0.6.1/doc/html/Data-Generics-SYB-WithClass-Basics.html#t%3AData
16:43:55 <soupdragon> why isn't there a haskell category theory beginners club
16:43:56 <soupdragon> ?????????
16:44:02 * geheimdienst stands corrected
16:44:04 <napping> soupdragon: cause you haven't founded one?
16:44:16 <soupdragon> I'm searching for one! and I havent foundde it
16:44:39 <napping> dkc: also Typeable is, but I don't use that, at least not directly
16:44:55 <CakeProphet> napping:  you must found one because you haven't found one. ha! :P
16:45:03 <CakeProphet> er... s/napping/soupdragon/
16:45:47 <napping> dkc: so, gmapQ takes a function that will get you an "r" for any "a" with Data ctx "a", and applies that to all the children to get a list of r
16:46:07 <napping> so, using it with the showQ gets a list of the result of calling show on all the children of the Foo
16:46:52 <aavogt> it looks like syb-with-class is more complicated than syb to me
16:47:00 <napping> and, I'm using that in instance Show Foo, because I had to make that Show instance so there would be an instance Sat (ShowContext Foo), so there would be an instance Data ShowContext Foo and we could use the stuff
16:47:07 <napping> aavogt: yes, but it lets you use classes
16:47:11 <dkc> ok what's the first Proxy argument of gmapQ for?
16:47:13 <soupdragon> "Nonetheless, eventually, as researchers in Computer Science or Logic, many will need to be familiar with the basic notions of Category Theory,"
16:47:35 <napping> aavogt: which is precisely what was wanted here, because children were Showable, rather than manually listing some types
16:48:05 <napping> dkc: Proxy is a phantom type. You just pass something of type (Proxy ctx) so it knows what ctx to work over. I'm not quite sure why that's needed
16:48:32 <aavogt> I believe it's there so you can extend existing generic functions
16:48:34 <napping> except I guess ctx is only mentioned in the type class constraints on the second argumnet, so it might not be able to infer which ctx just by checking it
16:48:55 * CakeProphet uses banana-morphisms to time travel.
16:49:51 <napping> just by looking at the inferred type of the second argument, that is
16:51:04 <luite> CakeProphet: through bananach-space/time?
16:51:10 <napping> ah, in particular if the argument was a function that didn't actually have that constraint
16:51:42 <CakeProphet> luite:  well, yes. That is a simplification of the morphism however. 
16:51:43 <CakeProphet> :P
16:52:31 <CakeProphet> I'm not entirely sure what on earth I would use Data.Data for.
16:53:05 <illissius> Data.Data is a nice name
16:53:14 <illissius> should follow it up with Control.Control, etc.
16:53:29 <illissius> Unsafe.Unsafe
16:53:50 <monochrom> Recursion.Recursion
16:54:15 <CakeProphet> LANGUAGE RecursiveModuleNames
16:54:50 <CakeProphet> module Recursion.Recursion where module Recursion = module Recursion.Recursion
16:54:58 <soupdragon> why do people keep telling the same Recursion joke over and over again?
16:55:13 <soupdragon> it is baseless humor
16:55:27 <CakeProphet> soupdragon:  perhaps they have a recursive definition of humor.
16:55:30 <CakeProphet> ...
16:55:35 <soupdragon> >:D
16:55:42 <CakeProphet> and it doesn't have to be baseless
16:55:52 <CakeProphet> sometimes there are terminating conditions. Usually involving deaths in the family and such.
16:55:56 <CakeProphet> bad time for jokes.
16:56:10 <dkc> ok i think i've basically parsed this
16:56:20 <fxr> hello, I'll try to write an application which connects a device via telnet and interacts by sending commands and parsing the output. any ideas will be helpful.
16:56:25 <chrisdone> soupdragon: now it's got scientific, it's official, these sites suck: http://kiboki.net:8000/
16:56:52 <CakeProphet> fxr:  I am doing just that, actually. Would you like to see some example code?
16:56:54 <soupdragon> what is that ??
16:57:02 <fxr> CakeProphet: will be wonderful
16:57:26 <chrisdone> just a little script that downloads the feeds, does a diff and uses that to calculate new stuff and movement (aka activity)
16:57:38 <dkc> chrisdone: is it hard to add HN?
16:57:40 <CakeProphet> fxr:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27281#a27281
16:58:10 <chrisdone> dkc: yeah, for some reason Network.HTTP doesn't want to download it. if i can be bothered figuring out why i'll add it
16:58:11 <CakeProphet> fxr: I'm making a MUD server. MUds run over telnet, so it's similar code to what you'd probably like. Though my system is going to be highly concurrent.
16:59:02 <chrisdone> maybe the crappy arc server that runs HN returns some nonstandard HTTP response
16:59:12 <CakeProphet> fxr:  basically you use functions from the Network module to set up a listening server. serverSocket <- listenOn (PortNumber 1234)
16:59:20 <CakeProphet> (handle, hostname, port) <- accept serverSocket
16:59:24 <aavogt> @remember soupdragon why do people keep telling the same Recursion joke over and over again?   it is baseless humor
16:59:24 <lambdabot> Done.
16:59:25 <dkc> napping: i can replace Show with something else, right?  this doesn't require any magic for Show itself?
16:59:50 <fxr> CakeProphet: nice, I know how to write a network server, I just wanna know if there are any expect like interface
17:00:13 <dkc> napping: like if i want to do this with a Get and Put class or something
17:01:08 <napping> dkc: not from show itself, no
17:01:22 <napping> although it does require instances of whatever class you use for all the field types
17:01:51 <CakeProphet> fxr: not that I know of. Might be a provisional package somewhere on hackage. You could just do it manually via parsing input.
17:02:10 <dkc> right .. so I would probably make my own class and use it to put the encoding/decoding rules into each field type
17:02:57 <CakeProphet> fxr:  if your commands are somewhat complicated you could use the Parsec library to build complex parsers for the syntax.
17:03:15 <napping> dkc: ooh, TH is actually not so bad
17:03:19 <CakeProphet> but I don't really know what you have in mind.
17:04:01 <fxr> I think I'll prefere attoparse
17:04:02 <fxr> c
17:04:36 <danharaj> attoparsec has worse error messages, so it'll be harder to work with
17:04:39 <dkc> napping, aavogt: thanks enormously
17:04:43 <napping> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27271#a27283
17:04:45 <danharaj> you probably wouldn't even notice the performance difference.
17:04:54 <napping> here, don't know why I started with syb
17:05:01 <dkc> oo ok i'll wait
17:05:06 <napping> well, cause I wanted to figure it out
17:05:18 <napping> anyway, load that up
17:05:29 <napping> make sure TH is on (:set -XTemplateHaskell) in ghci
17:06:00 <napping> and then write $('Foo 3 'show) to make (\(Foo x1 x2 x3) -> [show x1, show x2, show x3])
17:06:51 <dkc> Couldn't match expected type `t -> t1 -> ExpQ'
17:06:59 <dkc> ah sorry
17:07:27 * illissius is about to dist-upgrade on debian sid after not having upgraded for something like 9 months
17:07:36 <illissius> I'd say wish me luck, but it's pretty hopeless.
17:07:41 <CakeProphet> fxr:  actually you could probably write your own expect.
17:08:49 <lispy> illissius: I tend to find it works best if i upgrade everything to the latest for my current distro then dist upgrade. YMMV
17:09:09 <dkc> napping: Couldn't match expected type `t -> t1 -> ExpQ' against inferred type `Name'
17:09:19 <napping> dkc: loading it?
17:09:25 <napping> or trying to do something?
17:09:34 <dkc> > $('Foo 3 'show)
17:09:34 <geheimdienst> illissus: i find it works best if you install arch linux
17:09:35 <lambdabot>   <no location info>: parse error on input `$'
17:09:35 <geheimdienst> ;-)
17:09:40 <illissius> lispy: yeah, that's the plan
17:10:17 <illissius> I lied -- right now I'm only going start it downloading all the crap while I sleep, and then upgrade followed by dist-upgrade in the morning
17:11:49 <illissius> "Need to get 1,788MB of archives. After unpacking 23.2MB will be freed."
17:13:27 <dkc> huzzah!
17:13:55 <fxr> found libexpect package
17:15:01 <dkc> $(applyChilds 'Foo 3 'show) (Foo 1 'c' "str") --> ["1","'c'","\"str\""]
17:15:25 <CakeProphet> fxr:  oh nice.
17:18:33 <geheimdienst> so, am i getting this correctly? if something is a MonadPlus, then it's a Monad and a Monoid. meanwhile Monads and Monoids don't have a direct relationship
17:18:45 <ezyang> geheimdienst: In Haskell, correct. 
17:18:53 <ezyang> In Math, a monad is a monoid in the category of endofunctors. 
17:19:14 <geheimdienst> dude! i knew that only because of the joke
17:19:26 <ezyang> It’s funny because it’s true :-) 
17:19:28 <geheimdienst> do mathematicians actually say that and mean it?! unbelievable
17:19:46 <ezyang> http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html 
17:20:24 <ezyang> If you know what commuting diagrams are, Piponi’s pointless laws are the paths in the diagram that commute. 
17:20:30 <napping> dkc: if you use the reify function a bit you might be able to avoid specifying the number
17:20:41 <napping> What was the trick for looking at reify results?
17:21:29 <dkc> napping: sorry i'm still playing with this, using it to with record accsesors
17:21:52 <napping> dkc: it will have to be adjusted a little, but not too much
17:26:38 <dkc> ok napping i have to go .. thanks again for all your help.  i'm pretty sure from this i can figure out enough TH to make my thing do what it needs
17:27:11 <geheimdienst> ok thanks so far ... another question:
17:27:31 <geheimdienst> what is an Endo? the typeclassopedia doesn't talk about it. i saw it here: http://hackage.haskell.org/packages/archive/xmonad/latest/doc/html/src/XMonad-Core.html#line-144
17:28:00 <napping> endomorphism is a function a -> a
17:29:59 <geheimdienst> napping, but what does that mean? suppose i write "type ManageHook = Query (Endo WindowSet)", what does that Endo do?
17:30:10 <napping> oh, that's a different one
17:30:19 <napping> that Endo makes a monoid out of funtions
17:30:25 <napping> there's two reasonable instances
17:30:35 <napping> if b is a monoid, then a -> b is a monoid like
17:30:48 <napping> f `plus` g = \x -> (f x) `plus` (g x)
17:31:00 <napping> or if you take functions (a -> a), then you compose them
17:31:11 <napping> Endo a is the monoid of functions (a -> a)
17:31:41 <geheimdienst> napping, thank you for the explanation, but currently that's way over my head
17:33:31 <dons> chrisdone: around? were you working on wikimedia templates for haskell.org?
17:33:33 <dons> nominolo: ^^^
17:33:49 <dons> we lost the templates for haskell.org during the upgrade, so might as well install the new ones
17:35:46 <napping> dkc: still around?
17:37:24 <Cale> geheimdienst: Well, do you know what a monoid is, generally?
17:38:18 <geheimdienst> a thing where you can tack on stuff. this is called mappend
17:38:46 <Cale> geheimdienst: It's a set (or type) with a binary operation which:
17:38:49 <geheimdienst> and it has an empty element thingy, which if you mappend it, it doesn't change
17:39:08 <Cale> 1) Has an identity element 1 (or mempty) such that a * 1 = 1 * a = a
17:39:20 <Igloo> dons: I wouldn't spend too much time on the old site, as we're working on getting the new one up and running
17:39:21 <Cale> 2) Is associative: a * (b * c) = (a * b) * c
17:39:36 <aristid> geheimdienst: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Data-Monoid.html#Endo
17:39:43 <Cale> In the Monoid class, 1 is called mempty and * is called mappend
17:39:51 <Cale> Though those are pretty terrible names.
17:40:00 <geheimdienst> yes sir, i got that from the typeclassopedia
17:40:05 <Cale> okay
17:40:18 <Cale> So, suppose that m is any instance of Monoid at all
17:40:20 <dkc> napping: kinda :)
17:40:21 <geheimdienst> aristid, thanks, i've been looking at that (also its source code)
17:40:28 <Cale> and e is any type whatsoever
17:40:30 <aristid> geheimdienst: what's confusing about it?
17:40:42 <Cale> Then what we can do is to turn functions e -> m into a monoid
17:41:01 <napping> dkc: ok, this uses reify so you don't have to put the number http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27271#a27286
17:41:02 <aristid> Cale: that's not what current Endo does
17:41:09 <Cale> Where to multiply two functions, we simply multiply their results
17:41:18 <Cale> I'm not talking about Endo, I'm talking about the other instance
17:41:47 <Cale> So (f `mappend` g) x = (f x) `mappend` (g x)
17:41:53 <Cale> For each x
17:41:59 <dkc> napping: sweet.
17:42:06 <napping> $(applyChilds 'Just 'show) (Just True) ==> ["True"]
17:42:09 <soupdragon> it's intresting how functions inherit a lot of things
17:42:18 <napping> $(applyChilds '(,) 'show) ('X',False) ==> ["'X'","False"]
17:42:22 <aristid> Cale: you're talking about this one? instance (Monoid b) => Monoid (a -> b)
17:42:26 <soupdragon> like if you have a functions into a Ring, that is a Ring
17:42:55 <dkc> napping: is there such a thing as a generic deconstructor for a 1 element data type?
17:43:03 <soupdragon> actually . is there two rings of functions? ones multiplication is regular multiplication and the other is composition?
17:43:06 <Cale> aristid: yes
17:43:06 <geheimdienst> wait, f and g are those functions that take a type and yield a monoid, right?
17:43:11 <napping> other than this kind of TH thing?
17:43:14 <napping> no
17:43:26 <Cale> geheimdienst: That take a value of some type e, and produce an element in some monoid
17:43:28 <napping> wait, one element, or one constructor?
17:43:30 <chrisdone> dons: i started ages ago but i thought the guys on -cafe were sorting something out so i dropped it. could whip something clean and simple up tomorrow. go with the snap theme seems best
17:43:55 <chrisdone> nominolo: weren't you doing a wiki theme??
17:43:55 <Cale> geheimdienst: They don't take a type and give a monoid, that'd be some strange type-level thing :)
17:44:08 <dkc> dkc: one element
17:44:22 <geheimdienst> yeah, it gave me the creeps
17:44:23 <napping> um, you shouldn't need a destructor for that
17:44:26 <napping> like data I = I
17:44:33 <dkc> ah sorry than one constructor
17:44:34 <geheimdienst> okay. what's an element in a monoid? and instance of a monoid?
17:44:37 <dkc> like data Foo = Foo String
17:44:45 <dkc> data Bar = Bar String
17:45:00 <napping> If it's one argument, then this applyChilds might work
17:45:08 <napping> if you really need that
17:45:09 <dkc> with 'id I guess
17:45:21 <napping> I have no idea why you would want something like that
17:45:22 <aristid> geheimdienst: [1,2,3] :: [Int] <- element in the [Int] monoid
17:45:34 <dkc> napping: i was just kinda curious
17:45:56 <napping> nah, it would have to be some kind of generic programming thing, or maybe a typeclass
17:46:12 <geheimdienst> so your way of phrasing that is: the list [1,2,3] is an element in the monoid of all int-lists [Int], right?
17:46:19 <Cale> yeah
17:46:24 <geheimdienst> that's fucked up
17:46:27 <Cale> Why?
17:46:29 <geheimdienst> err, excuse me
17:46:30 <napping> btw, ''Foo gets the name of the type, and then reify will tell you about all constructors
17:46:47 <Cale> The word "monoid" refers to the type which has the operations on it
17:46:53 <Cale> Not to the values in that type
17:46:53 <napping> so if you want to build generic destructors or something you could
17:47:21 <napping> dkc: anyway, this has been a bit of a tour of some of the fancy bits
17:47:22 <Cale> Similarly to how when you say "monad" you're referring to type constructors like Maybe or IO, not to Just 5 or getLine
17:47:29 <dkc> the applyChilds does work, btw
17:47:52 <dkc> data Price = Price Int; $(applyChilds 'Price 'id) (Price 30)  --> [30]
17:47:56 <napping> dkc: but usually it's easier to switch to a representation that's easy to work with rather than build tools to help work with an awkward representation
17:48:32 <napping> unless you are getting something else out of it - like you picked the representation to give you some nice guarantees by leveraging the type system
17:48:54 <dkc> napping: well, exactly.  the point of this whole exercise was to make invalid messages impossible.
17:49:23 <Cale> geheimdienst: So if m is a monoid, then so is e -> m, where e is any type at all.
17:49:35 <dkc> napping: the thing is that to really do that I should be listing out all possible messages .. which is combinatorially massive
17:49:47 <Cale> Because we can combine two functions just by combining their results.
17:49:48 <napping> all possible messages?
17:49:49 <dkc> hence the TH stuff and type system trickery and all the rest of it
17:49:53 <napping> why would that be massive?
17:50:02 <Cale> But there's another instance of the Monoid class for functions
17:50:14 <napping> if anything, if there's some systematic way of organizing messages you could probably formalize that directly
17:50:15 <Cale> If a is any type, then we can make functions a -> a into a monoid
17:50:23 <Cale> Where to combine two functions, we just compose them
17:50:32 <Cale> and then the identity function is the identity
17:50:34 <napping> For example, another option is to use the GADT indices to limit message types
17:50:36 <dkc> the problem is that i'd like to give the type system a function message -> field
17:50:56 <Cale> (rather than the constant function which gives the identity value in the monoid m, like it was with functions e -> m)
17:50:59 <dkc> actually message -> [field]
17:51:02 <napping> dkc: you can make type level functions with fundeps or associated types
17:51:23 <napping> or there's phantom type hackery
17:51:26 <dkc> but i also want things to be syntactically easy to work with, and at a level of abstraction that i can manage (which most of our discussion tonight hasn't been...)
17:51:40 <dkc> so it's sort of a tricky set of requirements to meet
17:51:43 <geheimdienst> ok, so for the a -> a case, the monoid is just the dude who pipes the first function's result into the second function
17:51:55 <napping> data Field a b where OkInA :: Field a No; OkInB :: Field No b; OkInBoth a b
17:51:56 <Cale> geheimdienst: Yeah, that's what the monoid operation does
17:52:04 <Cale> geheimdienst: Of course, these two instances overlap
17:52:15 <napping> then msg A has [Field Yes No], msg B has [Field No Yes]
17:52:27 <Cale> geheimdienst: If m is a monoid and we have functions of type m -> m and try to mappend them, which behaviour do we want?
17:52:38 <napping> dkc: is there a fixed set of message types?
17:52:46 <dkc> yes
17:52:46 <Cale> geheimdienst: It's ambiguous and in fact, Haskell will complain about overlapping instances anyway
17:52:55 <Cale> geheimdienst: So what we do is to make a simple wrapper type
17:52:59 <dkc> fixed set of message types, fixed set of fields
17:53:04 <Cale> newtype Endo a = Endo (a -> a)
17:53:12 <dkc> each message type takes a subset of the fields
17:53:26 <dkc> and a subset of *those* are optional filds
17:53:26 <Cale> and then we can write the composing instance of Monoid for Endo a
17:54:30 <geheimdienst> oh god, this is complicated stuff
17:55:08 <napping> dkc: is there any more structure than that?
17:55:21 <dkc> well the subsets are predefined
17:55:23 <napping> groups of fields that are always omitted or included together, that sort of thing?
17:55:45 <dkc> i know for certain that messageA is going to take fields 1,7,18 and optional 22 and 25, but no others
17:55:51 <dkc> (for example)
17:56:31 <geheimdienst> ok cale, thank you very much for the patient explanation
17:56:45 <napping> because you can't compress an arbitrary specification
17:56:48 <geheimdienst> but this stuff is just too complicated. i give up
17:56:55 <geheimdienst> thanks a lot anyway
17:57:03 <napping> so, maybe just making records for message types listing the fields is the way to go
17:57:21 <solrize> lol "Instead, we should set aside our differences, Haskell and F# programmers alike--and OCaml and Scala and any others--that we might all come together in the spirit of brotherly love, join hands as one, and go run those C++-using bastards out of town once and for all."  (from reddit)
17:57:50 <napping> solrize: ah, if only we had a suitable C replacement
17:59:19 <dkc> napping: is there a way to make something like that syntactically comfortable to work with?
17:59:50 <otto_s> solrize: Sounds funny. Please provide a link.
17:59:55 <pikhq> napping: Add some pattern matching to C and you're most of the way there.
17:59:58 <lispy> napping: you mean like cyclone, rust, D, et al?
18:00:04 <dkc> i guess i could make a bunch of helper functions like    addField2 :: (Message a) => a -> a
18:00:23 <Cale> geheimdienst: I'm not actually sure what's complicated about it :)
18:00:31 <Cale> geheimdienst: Maybe an example or two would help
18:00:46 * hackagebot cfopu 0.1.0 - cfopu processor  http://hackage.haskell.org/package/cfopu-0.1.0 (ByronJohnson)
18:01:12 <geheimdienst> i guess it's simple in the way of "why, it's just a monoid in the category of endofunctors". it's simple iff you know a metric boatload of alien jargon
18:02:04 <napping> lispy: maybe cyclone, and Rust is promising but needs finishing
18:02:38 <napping> dkc: well, if you define the types with record syntax you will get accessors
18:02:53 <etpace> Would using a lexer (if its even possible) be quicker than a normal parser built ontop of bytestrings for parsing binary data
18:05:36 <napping> dkc: the only thing that's not nice is not being able to re-use field names, and the cases where you really want to do exactly the same thing to each of many fields, which the TH stuff covers
18:06:10 <napping> (though you might want to make another that takes a second function for the optional cases, if you want to handle just those Maybes directly)
18:06:26 <dkc> napping: actually i don't mind the field names .. i just mind defining functions that deconstruct 40 elements
18:06:49 <napping> if you declare a constructor C {field1 :: a, field2 :: b, ..}
18:07:11 <napping> then field1 gets defined as an extractor :: C -> a, and field2 as a function C -> b and so on
18:07:26 <dkc> napping: so for C { field1 :: Maybe a, field2 :: Maybe b ... }
18:07:41 <dkc> the only way to create C Nothing Nothing ... Nothing is to do just that, right?
18:07:48 <napping> I guess
18:07:59 <dkc> ok
18:08:04 <donri> Shouldn't everything except IO be possible to do concurrently, in Haskell, automatically?
18:08:11 <napping> do it once and give it a name
18:08:16 <napping> or, modify the TH a bit
18:08:45 <dkc> well i think i'm just going to use vim-fu rather than TH for now, and once i'm a bit more experienced in haskell, come back and do it elegantly
18:08:48 <napping> donri: well, there are data dependencies. It turns out if you try to do *everything* in parallel there's too much overhead, at least on standard hardware
18:09:06 <napping> dkc: right, for just applying to Nothing a bunch of times TH is overkill
18:09:26 <donri> Couldn't a system figure out an effective way to parallelize behind the scenes?
18:09:30 <dkc> donri: i guess everthing that doesn't happen in monads could be .. monads
18:09:39 <dkc> napping: yep ..
18:09:50 <napping> dkc: that's the problem. If you have (1 + 2) and try to evaluate 1 and 2 in parallel, it's too much work
18:10:05 <napping> if you even try to compute how much work evaluating the 1 and 2 in parallel will be, *that* is too much work
18:10:15 <soupdragon> can I ask a question about set theory/type theory
18:10:24 <soupdragon> (I think if anyon ehas an idea someone in #Haskell will)
18:10:48 <donri> napping: I was rather thinking maybe every function on a single core but not necessarily every function on the same core. But admittedly I have no understanding of these things. :D
18:11:18 <napping> donri: look at the Strategies stuff
18:11:23 <chrisdone> donri: how do you get the length of a list [a] concurrently?
18:11:29 <donri> I guess it comes down to that every function is a series of other functions
18:11:33 <napping> it's about providing hints with par, about where it might make sense to evaluate in parallel
18:11:48 <napping> with that sort of granularity control you can get decent speedups
18:11:59 <donri> chrisdone: No clue sir. I have no understanding of these things really.
18:12:11 <chrisdone> fibonacci concurrently?
18:12:12 <soupdragon> chrisdone, the flouride conspiracy --  doesn't .. hold much . water XD
18:12:27 <chrisdone> soupdragon: lol
18:12:58 <CakeProphet> :t empty
18:12:59 <lambdabot>     Ambiguous occurrence `empty'
18:12:59 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
18:13:00 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
18:13:07 <chrisdone> some problems are just linear
18:13:08 <CakeProphet> :t Data.Map.empty
18:13:09 <lambdabot> forall k a. M.Map k a
18:13:19 <chrisdone> soupdragon: got any haskell jokes?
18:13:30 <CakeProphet> are there any restrictions on what a map key can be?
18:13:36 <CakeProphet> or a map value?
18:13:48 <chrisdone> :t lookup
18:13:50 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:13:50 <lispy> CakeProphet: forall means for all :)
18:13:57 <chrisdone> :t Data.Map.lookup
18:13:58 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
18:14:09 <chrisdone> see "Ord k"
18:14:15 <lispy> Well, okay.  If you want to be able to use lookup, they need an ord instance
18:14:26 <chrisdone> lol
18:14:28 <lispy> ?instances Ord
18:14:30 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:14:31 <chrisdone> :t Data.Map.fromList
18:14:32 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
18:14:36 <CakeProphet> ah okay
18:14:48 <CakeProphet> so they can be anything... but you might have trouble using your data structure without the right typeclass.
18:15:09 <chrisdone> i don't think you can build a map without an Ord value
18:15:15 <chrisdone> :t Data.Map.insert
18:15:17 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
18:15:25 <lispy> CakeProphet: yeah. And it just comes down to which operations you need.  In the case of map, I think that pretty much requires Ord for everything
18:15:26 <CakeProphet> @instances Ord
18:15:27 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:15:39 <chrisdone> pretty sure the algorithm is a balanced tree so 
18:16:14 <lispy> CakeProphet: and if you're new to Haskell, this is the better way to define things.  The Ord instance could be on the Data declaration but it's much better to put it on the operations that actually use it
18:17:58 <chrisdone> what's the syntax for adding a typeclass to a data declaration?
18:18:18 <chrisdone> i wanted it the other day but couldn't remember it
18:18:26 <jmcarthur> as a constraint or in an existential?
18:18:31 <chrisdone> as a constraint
18:18:44 <jmcarthur> data Foo a => Bar a = Bar a
18:18:50 <jmcarthur> but i don't recommend doing that
18:18:54 <chrisdone> standard haskell 98?
18:18:57 <jmcarthur> it's not beneficial
18:18:58 <jmcarthur> i think so
18:19:43 <napping> it doesn't actually do anything useful
18:19:45 <jmcarthur> the whole thing is silly though. it doesn't even save you from having to specify the constraint elsewhere
18:19:52 <jmcarthur> right
18:20:04 <napping> the only thing it does, it only let you use the constructors in a context where you have (Foo a)
18:20:08 <chrisdone> yeah it was more of a reminder for myself to come back to later
18:20:21 <lispy> Yeah, I guess to have that behavior it would need to be, Bar a => Foo a = F a ...
18:20:37 <napping> it doesn't let you assume (Foo a) when you pattern match on it (as a GADT might), or automatically add constraints to functions mentioning the type
18:20:53 <lispy> yeah
18:21:00 <lispy> And it overly constrains things
18:21:09 <jmcarthur> the GADT version you allude to is just existential quantification
18:21:26 <jmcarthur> eh well
18:21:33 <jmcarthur> a generalized version of it i suppose
18:21:34 <lispy> data Foo = forall a. Bar a => F a, IIRC
18:21:37 <jmcarthur> so nevermind
18:22:13 <jmcarthur> data Foo a where F :: forall a . Bar a => Foo a  -- not quite the same as existential quantification i guess
18:22:22 <jmcarthur> the forall is redundant sorry
18:23:20 <lispy> Sometimes I wish forall wasn't optional
18:23:40 <lispy> I'm not a huge fan of the syntactic overhead, but many good extensions require its use anyway
18:23:44 <chrisdone> it's optional in a weird way
18:23:59 <lispy> And GHC will print the forall for you which can be confusing to beginners
18:24:03 <chrisdone> when i want to type it out i get "you can't do that without an extension"
18:25:39 <CakeProphet> would it be smart to import Data.Set as S and Data.Map as M?
18:25:46 <lispy> CakeProphet: yup!
18:25:47 <CakeProphet> and leave Data.List unqualified.
18:26:00 <napping> except that has to be "import qualified"
18:26:01 <lispy> CakeProphet: that's a pretty standard strategy
18:26:02 <chrisdone> import all modules qualified or explicitly
18:26:06 <napping> otherwise you still get the unqualified names
18:26:28 <lispy> Oh, and chrisdone has a point.  It's a bit of a pain to name everything you import, but it's nice later
18:26:30 <CakeProphet> gotcha
18:26:52 <napping> isn't there a ghc option to construct such an import list?
18:26:53 <chrisdone> lispy: my rule is, if the list is longer than one line, qualify it
18:27:05 <chrisdone> lispy: results in really nice, concise import lists in my exp
18:27:45 <SubStack> can always mix qualified imports with per-function imports too
18:27:45 <dkc> is there an extension somewhere that automatically derives 'Show' on any data types for which it can be derived?
18:27:53 <lispy> napping: GHC has some option related to imports but I forget what it checks.  I think it checks for unused modules?
18:28:21 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27289#a27289
18:28:22 <lispy> dkc: well, what do you mean?  After the fact?
18:28:41 <lispy> dkc: there is an extension for 'standalone deriving'
18:28:44 <napping> lispy: no! there is something that looks at your module and generates a set of imports that import exactly the names you use
18:28:46 <dkc> like something i can put at the top of my file rather than adding 'deriving Show' after each data type
18:28:51 <dkc> no i mean something much simpler than that
18:28:58 <CakeProphet> napping:  sounds like there would be ambiguity
18:29:03 <lispy> napping: oh, that sounds cool
18:29:07 <chrisdone> napping: sounds nice
18:29:31 <napping> CakeProphet: no, there would be an error if you actually used any ambigious names
18:29:34 <chrisdone> -Wall generally does this for you as you're coding
18:29:41 <lispy> dkc: Well, I guess you could use something like TH to do that
18:29:46 <dkc> yeeks
18:29:50 <dkc> never! :)
18:30:08 <lispy> But, adding 'deriving (Show, Eq, ...)' isn't so bad :)
18:30:28 <dkc> haskell needs more conventional weaponry and less nukes
18:30:31 <lispy> Unless you had like 1,000,000 data types
18:30:51 <lispy> What would be the conventional weaponry for this?
18:31:04 <CakeProphet> tired of all of those pesky import statements? here's a utility that dumps an import qualified for every standard module. Finally, less typing!
18:31:17 <napping> dkc: seriously, one line per type to derive Show?
18:31:18 <dkc> lispy: put {# -XShowables #-} on top of the file
18:31:42 <chrisdone> CakeProphet: http://gist.github.com/raw/463423/f8458d83b1a7cc26cdbf812747188993e50cd8a2/The%20Haskell%20module%20landscape
18:32:08 <dkc> actually just in ghci ... probably not necessary in the actual program
18:32:20 <chrisdone> unsafeGazeUponHaskellModuleLandscapeWriteSuicideNote
18:32:22 <napping> ah, then you can use the debugger stuff if you want
18:33:11 <CakeProphet> chrisdone:  is it odd that I'm getting flashbacks from Java programming?
18:35:04 <Gracenotes> protip: livecd+chroot saves lives
18:35:41 <donri> CakeProphet: Want some Java with that cake?
18:36:04 <Gracenotes> hm, so...
18:36:30 <CakeProphet> Animalia.Chordata.Mammalia.Primates.Hominidae.Homininae.Hominini.Homo.Sapiens.Sapiens.HumanInterface.Widget
18:36:53 <CakeProphet> otherwise our module name is ambiguous!
18:37:39 <pikhq> CakeProphet: Yeah, but Java doesn't let you do: import qualified The.Worlds.Longest.Class.Hierarchy.Md5sumGoesHere.CrcSumAlso.Widget as W
18:37:43 <pikhq> :P
18:37:46 <lispy> CakeProphet: actually, that's a bit over specified, IMO.  What Widget will Trolls use? ;)
18:38:10 <CakeProphet> lispy: by specifying the taxonomy there's no ambiguity there.
18:38:27 <CakeProphet> if you mix lizard widgets with human widgets... your code will reflect this with explicit module qualification. :)
18:40:05 <lispy> It is kind of interesting that the Haskell module system provides a form of polymorphism
18:40:51 <lispy> You can define the same names/types in two different modules, ones that could have wildly different implementations, and switch which one you're using by just changing the import
18:41:01 <Gracenotes> CakeProphet: don't prions have a widget? :(
18:41:05 <CakeProphet> yeah... like *.Lazy and *Strict
18:41:30 <CakeProphet> Gracenotes:  UI designers are a bit unsure of how to deal with the case of prions. It's an area of active research.
18:41:47 <lispy> That's a very useful example, but less surprising since Haskell types don't track the evaluation strategy
18:42:29 <CakeProphet> Moduleclasses. :)
18:42:45 <CakeProphet> (Collection Data.List)
18:42:46 <lispy> They really are a non-first class version of OO
18:43:51 <lispy> You can extend a module and export everything it exports to get a form of subtyping
18:44:12 <lispy> You can even redefine some existing parts (overriding) when you do that
18:44:53 <lispy> But what you can't do, is instantiate new modules at run-time (without doing something like hs-plugins)
18:45:05 <CakeProphet> Data.Map.Naive -- ensures the most naive implementation possible.
18:47:15 <CakeProphet> not to be confused with Data.Map.Enterprise
18:47:18 <CakeProphet> for the best business logic.
18:48:35 <lispy> I would prefer, Data.Map.FormallyVerified
18:48:40 <CakeProphet> psh
18:49:02 <CakeProphet> hmmm, I didn't even consider the fact that you could mix .Lazy with .Strict in a program
18:49:12 <CakeProphet> import some functions as lazy and others as strict.
18:49:39 <soupdragon> so what is the equvialent of a set
18:49:41 <soupdragon> in type theory ?
18:50:00 <CakeProphet> aren't types a kind of set?
18:50:01 <lispy> a type is a set plus operations
18:50:02 <soupdragon> I had thought  I -> T  (for some index type I) is roughly like a set T
18:50:15 <soupdragon> but what is the equivalent of I in set theory
18:50:21 <lispy> soupdragon: type classes can be used like sets
18:50:29 <lispy> sets of types
18:50:35 <soupdragon> a set of natural numbers could be {1,2,3}
18:50:41 <soupdragon> or it could be {2,4,6,...}
18:50:59 <lispy> data I = One | Two | Three
18:51:16 <soupdragon> but that's only sets of size 3
18:51:22 <soupdragon> what about set in general?
18:51:41 <lispy> We may need to restrict to countable sets
18:51:46 <soupdragon> this seem to be a fundamental difference
18:52:26 <soupdragon> it seems  like if N is natural numbers and O is ordinals, the type  N -> T  is quite different to  O -> T
18:52:53 <lispy> (but, I don't know if we _have_ to restrict to countable, it's just my intuition, but it could be very wrong!)
18:57:03 <CakeProphet> haha. I just thought of a silly question
18:57:21 <CakeProphet> "are && and || short-circuiting in Haskell?"
18:57:33 <dolio> Why do you need indices into a set?
18:57:47 <soupdragon> CakeProphet - actually it's a good question...
18:57:56 <tolkad> Ha, and you guys said I was doing it wrong. I got my program working: http://pastebin.com/rRCEzdhH
18:58:18 <soupdragon> dolio, I don't know if I even do, but I can't figure this out
18:58:19 <CakeProphet> tolkad:  well doing it wrong and working are completely different things...
18:58:28 <soupdragon> it just seemed the natural way to make a set of  things
18:59:10 <tolkad> CakeProphet: what's wrong with it?
18:59:30 <CakeProphet> tolkad:  dunno, I haven't looked. :D
19:00:24 <tolkad> hmm well people told me it was wrong without telling me why exactly
19:00:45 <soupdragon> when you say "set of natural numbers"  in set theory
19:00:53 <soupdragon> what is the analogue of that in type theory?
19:01:05 <soupdragon> I mean how many numbers are there in that set?
19:01:17 <dolio> You mean a subset of the natural numbers?
19:01:19 <soupdragon> it could be *any* cardinal????? 
19:01:33 <tolkad> soupdragon: no, |N| = aleph 1
19:01:41 <soupdragon> dolio, oh you are sugesting to use  T -> 2  rather than an index set
19:01:45 <tolkad> err 0
19:01:47 <tolkad> aleph 0
19:02:12 <soupdragon> the problem with this (negative definition) is that I cannot use it to define T -- but why is it then allowed in set theory?
19:02:35 <dolio> If you have P : Nat -> Prop, then Sigma Nat P is the type containing only naturals that satisfy P, more or less.
19:04:07 <dolio> And thus Nat -> Prop would, in a sense, be the type of subsets of Nat.
19:04:16 <dolio> At least, the ones you can describe in the language.
19:04:39 <soupdragon> maybe I just need to use T[i+1]
19:04:54 <soupdragon> only dependent on previously defined entities
19:09:37 <CakeProphet> bah... circular imports.
19:09:55 <CakeProphet> why can't they simply resolve nicely.
19:11:41 <tolkad> anyway, is it possible to have a mutable vector where reads don't cause IO?
19:11:44 <dons> Igloo: well, we need a new template anyway
19:11:49 <dons> the current thing looks pretty bad
19:12:39 <CakeProphet> tolkad:  my intuition says no.
19:12:45 <CakeProphet> as mutable = side-effects
19:13:29 <tolkad> oh, well anyway, where are mutable unboxed vectors?
19:13:58 <tolkad> oh, nevermind, they are in a seperate module
19:14:55 <soupdragon> I suppose if I leave the index as a parameter I can use the type itsself to define indices
19:15:09 <soupdragon> but types are finite
19:15:16 <soupdragon> so there is a fundamental limitation if I do that
19:15:20 <CakeProphet> tolkad:  ah, well there might be a mutable vector for ST. That would allow you to get a pure result from a stateful computation.
19:15:33 <tommd> tolkad: You probably want the 'vector' package.
19:15:34 <tommd> http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Unboxed-Mutable.html
19:15:43 <tommd> That is the haddock of the module you probably want.
19:15:50 <tommd> @hackage vector
19:15:51 <lambdabot> http://hackage.haskell.org/package/vector
19:16:15 <tolkad> you kow, that's actually kind of annoying. what if you wanted to have a class where an implementation would probably use a vector but some might be mutable and some might not
19:16:40 <tolkad> I might as well just have all my functions return IO
19:16:41 <CakeProphet> such a class wouldn't be possible...
19:16:50 <CakeProphet> and no, only ones that require side-effects.
19:16:50 <tolkad> CakeProphet: exactly
19:17:14 <tolkad> CakeProphet: well, reading doesn't cause side effects
19:17:18 <tommd> If you implement a function with a polymorphic type then you can only access the argument by the interfaces provided by the constraining classes.
19:17:54 <tommd> tolkad: So two threads writing "arr[1] = 1 ; arr[1] = 0;" doesn't cause a side-effect for readers?
19:18:29 <tolkad> tommd: writing that causes a side-effect, reading doesn't have any side effects it just reads it
19:18:58 <tommd> tolkad: It it isn't referentially transparent it isn't pure and must be IO.
19:19:26 <tolkad> well, I might as well just make all functions IO
19:19:38 <CakeProphet> tolkad:  ah but you see, reading isn't a pure operation. That is the main point. Not side-effects, but purity. Array and MArray can't be unified in Haskell because pure and impure operations require different types.
19:20:00 <CakeProphet> tolkad:  reading from a mutable data structure isn't pure, I mean.
19:20:09 <napping> tolkad: look up the freeze functions
19:20:17 <tommd> tolkad: Did you look at the package I linked?
19:20:28 <tommd> Yes, as napping said, I was going to point out 'freeze'.
19:20:58 <napping> freeze converts from a mutable MArray into an immutable IArray
19:22:25 <tolkad> let's say I want to write a file system stored in RAM in haskell. Would it be faster to use a mutable array or a list?
19:22:45 <tolkad> series of lists I should say
19:23:21 <tolkad> or will GHC probably optimize them to similar code?
19:23:33 <kmc> tolkad, those aren't your only options
19:23:38 <kmc> lists will probably be very slow
19:23:49 <tolkad> what other option do you have?
19:24:07 <kmc> not so much due to immutability but because they're singly-linked lists, they don't have good random access or updates
19:24:14 <kmc> tolkad, any other data structure...
19:24:23 <kmc> tolkad, for example Data.Map
19:24:32 <kmc> from file name to file contents
19:24:37 <napping> for a file system you should probably try to mmap as much as possible
19:24:46 <tolkad> kmc: how is Data.Map stored in haskell types?
19:25:04 <tommd> tolkad: Balanced trees right now, but there is an effort to change that.
19:25:34 <tommd> tolkad: There's also a Judy package if you want to use that.
19:25:51 <tolkad> tommd: I mean in haskell types... something like [(k, v)] I would think
19:25:56 <kmc> tolkad, a balanced binary search tree.  actually, if your key is a string filename, you're better off using something like bytestring-trie, which is a big-endian patricia tree
19:26:24 <tommd> tolkad: You seem to have a painfully limited idea of what a Haskell type can be.
19:26:34 <kmc> tolkad, what do you mean?  conceptually (Data.Map k v) is a little like [(k,v)] but they're not actually the same type
19:26:37 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Map.html
19:26:51 <tolkad> but... if they aren't mutable, wont haskell still have to rebuild the filesystem every time you change it?
19:26:55 <tommd> tolkad: data Map a = Nil | Fork (Map a) a (Map a) -- something like this.
19:27:07 <kmc> tolkad, only a little bit of it.  most of it will share memory with the old one
19:27:38 <kmc> tolkad, that's the flip side of immutability -- since you know the old copy won't change from under you, you can reuse most of it
19:27:52 <kmc> it's just like the situation with lists:
19:28:00 <kmc> > let x = "abc"; y = 'd':x in (x,y)
19:28:01 <lambdabot>   ("abc","dabc")
19:28:03 <tolkad> but... that would still be slower than using a mutable array
19:28:20 <kmc> here most of the storage of x and y is shared
19:28:29 <kmc> even though we "updated" x to add another element
19:28:36 <kmc> tolkad, it will probably be a bit slower, yes
19:28:51 <kmc> tolkad, it will be immensely faster than a list, mutable or no
19:30:59 <tommd> tolkad: Build your app, use a few primitives for your FS interface and try a few different backends.  I think one of Data.Map, vector, or judy will fill your needs.
19:31:23 <tommd> tolkad: There is a Haskell FS already - you should look at its design (HALFS)
19:31:28 <tommd> @hackage halfs
19:31:29 <lambdabot> http://hackage.haskell.org/package/halfs
19:35:22 <dons> there's a paper somewhere about it too
19:35:32 <tommd> Yes, that too.
19:35:32 <CakeProphet> how can I eliminate a circular import?
19:35:49 <tommd> Is it used still?
19:35:52 <soupdragon> "10. An example from computer science: Given a functional programming language L, there is an associated category, where the objects are the data types of L, and the arrows are the computable functions of L (“processes,” “procedures,” “programs”)."
19:37:47 <tommd> grrrr, cabal has broken halfs.  drat
19:37:52 <napping> CakeProphet: move all the things involved in a cycle into one module
19:38:02 <napping> CakeProphet: or do you mean how you can have a circular import?
19:38:18 <CakeProphet> napping:  no I meant how to fix it.
19:38:40 <napping> if it's working you don't really need to fix it
19:38:56 <CakeProphet> napping:  but in my case it's not because I have a circular import. :P
19:39:03 <CakeProphet> and GHC won't compile it.
19:39:36 <napping> Then what do you need to fix?
19:39:51 <dons> tommd: halfs was the open fork. the closed version is in use, yep.
19:40:01 <tommd> Yes, that's what I ment.
19:40:21 <CakeProphet> napping:  I don't know. That's my question.
19:40:38 <CakeProphet> can I fix it by only importing what I need instead of the whole module?
19:40:41 <geheimdienst> tommd, i've recently compiled halfs. what's your error?
19:40:49 <tommd> @google binutils.h
19:40:49 <lambdabot> No Result Found.
19:41:14 <napping> you are not making sense
19:41:16 <tommd> geheimdienst: binutils.h not found - the new cabal versions check for binutils.h and incorrectly reject halfs
19:41:37 <tommd> geheimdienst: binutils.h not found - the new cabal versions check for binutils.h and incorrectly reject halfs
19:41:39 <tommd> @google binutils.h
19:41:40 <lambdabot> No Result Found.
19:41:46 <tommd> Odd - I google for that with success
19:44:06 <CakeProphet> can I fix it by only importing what I need instead of the whole module?
19:44:07 <CakeProphet> er
19:44:15 <CakeProphet> accident. :P
19:45:09 <geheimdienst> sorry, i didn't get that kind of error. if it helps, i have no binutils.h in /usr/include or /usr/lib, and my cabal-install is 0.8
19:47:09 <monochrom> no, cicular import has to be fixed by not importing the whole module
19:52:48 <EvanR> with supercombinators does every top level CAF or function used deep in the program have to be passed to every combinator leading up to it?
19:53:38 <EvanR> like a giant environment
19:58:33 <tolkad> haskell is supposedly a function language but what's stopping people from just making every function cause IO?
19:58:44 <EvanR> nothing
19:59:17 <tolkad> then you could have all the benefits of haskell without any of the costs!
19:59:38 <EvanR> haskell actually has nicer imperative constructs than some other classic languages
20:00:18 <Veinor> tolkad: you wouldn't have the benefit of referential transparency or purity
20:00:32 <pikhq> tolkad: Monad: The Ultimate Imperative.
20:01:08 <dolio> IO not being able to happen at arbitrary points in the program isn't a cost. It's a benefit.
20:01:19 <geheimdienst> ultimately, all haskell programs run in the IO monad, because the main function is IO
20:01:43 <napping> also, types don't work so well with impeartive programs
20:01:50 <EvanR> its possible for 100% of the program to not use IO
20:01:51 <napping> It can control how the results are related to arguments
20:02:03 <napping> but has little to say about how state was changed by the call
20:02:17 <geheimdienst> evanr, maybe theoretically, but if the program never outputs anything, there's no point in running that program
20:02:26 <EvanR> yes
20:02:50 <EvanR> so the program can be 99% not using IO, and the top level is main = print (f input)
20:03:01 <tolkad> what's haskell's version of "volatile"?
20:03:13 <EvanR> unsafePerformIO? :)
20:03:38 <tolkad> like the modifier on a variable
20:03:44 <erikc> tolkad: there isnt one
20:04:06 <EvanR> variables stand for immutable values
20:04:09 <geheimdienst> evanr, don't name it! you should say "the function which must not be named"
20:04:34 <geheimdienst> or "the function only dons and dumbledore may call"
20:04:38 <EvanR> useSatanicDarkMagic
20:04:55 <pikhq> geheimdienst: It's unsafeSimonSaysPerformIO.
20:06:02 <solrize> @pl let x = 1:2:3:x
20:06:02 <lambdabot> (line 1, column 16):
20:06:02 <lambdabot> unexpected end of input
20:06:02 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++", "<+>", ";" or "in"
20:06:07 <solrize> @pl let x = 1:2:3:x in x
20:06:07 <lambdabot> fix ([1, 2, 3] ++)
20:06:10 <tolkad> you know, I don't understand how mutable vectors work internally... it must use haskell types somewhere inside it and you would think those would need to be rebuilt to be modified
20:06:42 <EvanR> what mutable vectors
20:06:54 <tolkad> Data.Vector.Mutable
20:07:04 <EvanR> if it uses IO, thats how they work
20:07:31 <napping> tolkad: there are primitive unsafe functions in IO for pointer stuff
20:07:41 <geheimdienst> i think more library functions should have names like harry potter spells ... perilusPerformio!
20:07:49 <EvanR> lol
20:07:57 <tolkad> napping: how are those implemented?
20:07:58 <pikhq> Insufficiently accurate Latin.
20:08:11 <dolio> Yes, and eatSlugs.
20:08:19 <pikhq> tolkad: Magic and fairy dust.
20:08:47 <tolkad> I don't believe in fairies : / you can't trick me
20:08:48 <geheimdienst> yeah because harry potter is the poster child of latin accuracy. give me a break
20:09:07 <erikc> tolkad: they're compiler builtins, see the Foreign module
20:09:18 <pikhq> tolkad: Careful, they might hear you.
20:09:33 <pikhq> geheimdienst: It's a complaint I have with the series.
20:09:40 <tolkad> erikc: nty, I'm proud to be an American citizen and I'm not looking into anything to do with illegals
20:09:54 <monochrom> olegIterateeStrike
20:10:24 * pikhq legalises illegal immigration
20:10:27 <pikhq> BWAHAHAHA
20:10:27 <dolio> ST and mutable arrays and such work because they force you to write code in a way such that it is safe for the compiler to implement operations with mutation.
20:12:23 <dolio> There's (more or less) nothing about them you couldn't implement purely in Haskell, except the optimization.
20:12:46 <EvanR> i asked about purely in haskell vectors/arrays
20:12:57 <EvanR> i dont know about that
20:13:08 <EvanR> index arithmetic just isnt functional
20:15:46 <napping> how about !!
20:16:00 <EvanR> far from a O(1) operation
20:16:32 <napping> we were not talking perofrmance
20:16:38 <napping> you can get O(log N), anyway
20:16:49 <EvanR> i would take any 1, however large
20:17:11 <EvanR> i am wondering if you can do better than log n, purely in haskell
20:17:23 <napping> you can't really do better than log N
20:17:35 <EvanR> is there a proof
20:17:46 <napping> sure, consider the size of your addresses
20:17:54 <tolkad> napping: are we sure it's not computable for haskell to compile to better than that?
20:18:29 <napping> Haskell? I was talking about C
20:18:59 <EvanR> well the addresses are 2^32 at the moment
20:19:14 <tolkad> so it is O(1)
20:19:34 <napping> no, so it is limited to O(1) data
20:19:46 <EvanR> if you consider a linear search through the entire finite memory space as the large 1 then yes
20:19:58 * EvanR pulls hair out
20:20:03 <CakeProphet> I'm not really sure I fully understand why circular imports are not possible.
20:20:19 <ddarius> CakeProphet: They are possible.
20:20:36 <CakeProphet> not according to GHC
20:20:37 <napping> CakeProphet: separate compilation is hard. You can make them work with an hs-boot file
20:21:11 <CakeProphet> would it be simpler to merge the modules? It makes everything cluttered...
20:21:12 <ddarius> CakeProphet: The Haskell Report explicitly allows mutually recursive modules.  GHC implements this in an annoying way, but it does implement it.
20:21:34 <CakeProphet> ddarius:  the way it implements it is via a hs-boot file?
20:21:54 <ddarius> CakeProphet: Usually mutually recursive sets of modules are very tightly coupled.  It makes sense to loosen the coupling or if that doesn't make sense, then they probably should be in the same module.
20:22:01 <ddarius> CakeProphet: Yes.
20:23:36 <CakeProphet> yeah it doesn't make sense in this case to loosen coupling.
20:23:45 <CakeProphet> the entitites in question /are/ coupled.
20:23:56 <EvanR> so the two modules arent really modular
20:24:11 <CakeProphet> well they are in the sense that they encapsulate different things
20:24:22 <EvanR> including each other
20:24:23 <CakeProphet> but those two things, specifically the data structures, reference each other.
20:24:45 <ddarius> The question isn't "do they" but "do they need to?"
20:24:49 <CakeProphet> yes.
20:24:55 <CakeProphet> they do.
20:25:02 <dolio> We need to get some MixML (I think that's the one) style modules.
20:25:04 <ddarius> Are you sure?  One can't take the other as a parameter?
20:25:44 <tolkad> what's an hs-boot file?
20:26:22 <CakeProphet> ddarius:  I guess. But I'd only ever use them together. There would be no need to parametrize. It's for the MUD again -- I'm defining rooms and players. Players go in rooms, rooms contain players. They need references to each other 
20:26:24 <tolkad> I'll look it up
20:26:45 <kmc> tolkad, http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/separate-compilation.html#mutual-recursion
20:26:48 <Dashkal> CakeProphet: Abstract rooms and players into an Entity type with constructors for both.
20:26:53 <kmc> tolkad, this is something that's almost never necessary
20:27:02 <tolkad> although, I prefer to use the irc expert system when I have questions rather than search engines
20:27:21 <tolkad> see? it can also function as a search engine
20:27:21 <CakeProphet> Dashkal:  I'm not quite sure what they have in common yet.
20:27:37 <Dashkal> CakeProphet: The ability to contain items
20:27:51 <CakeProphet> Dashkal:  well, no. No items in this case, actually. It's roleplay-oriented.
20:28:03 <CakeProphet> they seem pretty distinct to me.
20:28:06 <ddarius> CakeProphet: Doesn't sound like that to me.  Something along Dashkal's suggestion is probably possible.  You don't have to find something that generalizes both.  You could have that Rooms contain Entities and Players are just a special type of Entity or any of way of breaking the cycle.
20:28:13 <tolkad> that's stupid
20:28:20 <tolkad> that's not an implementation
20:28:36 <napping> CakeProphet: you can read about hs-boot files
20:28:49 <CakeProphet> napping:  I have already, actually. :)
20:30:03 <ddarius> Again, the solution to such problems is to think about interfaces rather than concrete types.  I could even say "Dependency Injection."
20:30:11 <CakeProphet> ddarius:  hmmm. maybe. I suppose I could dump them in the same module together since they are going to used together commonly. But I like the one-module-per-data-structure organization.
20:30:27 <ddarius> "Used together commonly" /= "coupled"
20:30:41 <CakeProphet> well, no, but they're both true in this case.
20:31:19 <Dashkal> CakeProphet: The way I delt with the multual reference case for that was to abstract "contains" out of both into their own module
20:31:42 <Dashkal> So I had an inventory system, then rooms and players had their code (but not data constructors!) elsewhere
20:32:37 <kmc> hi-boot files are a pain
20:32:42 <kmc> they're like C's header files
20:32:45 <kmc> which are a pain
20:32:51 <ddarius> At any rate, hs-boot files are essentially a crude system of interface files akin to .mli or .h files.
20:33:32 <CakeProphet> Dashkal:  well the reason I need to import is because the constructors of each type reference the other type in their constructor. I suppose I could use a typeclass to not require the mutual import, but I really don't want that to be necessary.
20:33:43 <ddarius> It would be nice if Haskell explicitly supported a notion of "interface file."
20:34:31 <Dashkal> CakeProphet: That sounds like hell to update.  How are you going to move entities without having to recreate the entire world?
20:34:42 <ddarius> CakeProphet: Or you could just parameterize.  Or, more crudely, you could pull out the recursive parts into their own module.
20:35:16 <EvanR> recreate the entire world for the win
20:35:36 <EvanR> or just recreate the list of locations
20:35:49 <Dashkal> You're going to want a data structure that require minimal changes when moving things around.  This is part of why I abstracted inventory out of entity.
20:35:49 <CakeProphet> Dashkal:  why would I need to recreate the entire world? I only need to update specific points.
20:36:16 <Dashkal> CakeProphet: erm, nevermind, I was imaginging the structure wrong
20:36:27 <CakeProphet> Dashkal:  I can show you the rough draft of what I've got if you like.
20:37:09 <Dashkal> I wouldn't be able to look.  Playing TF2.  Responding while dead :P
20:37:27 <CakeProphet> ah. Understandable then. :)
20:37:54 <CakeProphet> ddarius:  I don't really understand how I can seperate record fields from a data definition.
20:38:06 <Dashkal> But my point stands.  If the reason they are mulally dependant is because of the fact that they refer to each other, you can abstract _that_ out.
20:38:28 <CakeProphet> bah, but I don't wanna. :P
20:39:23 <EvanR> abstraction is great
20:39:25 <CakeProphet> Room Player. Player Room. ugly.
20:39:34 <CakeProphet> abstraction is great when you have a need for it
20:39:41 <EvanR> games need abstraction
20:39:48 <CakeProphet> but I only have /one/ Room type, and /one/ Player type. And I won't ever need more than one
20:39:52 <EvanR> Rooms and Players are not bits bytes and pointers
20:40:22 <EvanR> you simpler data and more functions
20:40:39 <EvanR> s/you/use/
20:41:03 <CakeProphet> I use /plenty/ of functions. This is Haskell. But my data is better organized into large sets together, I'm pretty sure.
20:41:15 <jmcarthur> i think you're doing it wrong
20:41:27 <CakeProphet> jmcarthur:  ah. well. that's interesting to note.
20:42:42 <jmcarthur> what is the distinction between a player having a room and a room having a player? does the player ever contain a room which itself does not contain the player?
20:43:01 <jmcarthur> because if not, i don't see any reason for both to refer to each other
20:43:14 <CakeProphet> hmmm...
20:43:17 <CakeProphet> I thought about that.
20:43:55 <CakeProphet> but... I don't know. Sometimes calling code will have only the player, and sometimes it will have only the room. Can I use a typeclass so that I don't need to lug the data around? I don't know how that would work.
20:44:20 <jmcarthur> i still stand by my earlier statement (a day or two ago?) that you're kind of stuck on some rather OO ideas in this design
20:44:29 <EvanR> maybe separate room data, player data, and whatever data you think links them
20:44:41 <jmcarthur> why not just write the client code and then write the implementation of its apis later?
20:44:57 <CakeProphet> EvanR:  the separation step is what confuses me. How do I do that?
20:45:02 <jmcarthur> *of the apis its using
20:45:20 <jmcarthur> CakeProphet: are you familier with what a join table is in databases?
20:45:32 <CakeProphet> actually no. I've never touched a database. :)
20:45:35 * CakeProphet is a hobbyist.
20:45:57 <jmcarthur> i'm a hobbyist too. i just happen to also code professionally ;)
20:46:07 <CakeProphet> ah. still an amateur at this point.
20:46:15 <tolkad> haskell should just allow circular imports without hs-boot files
20:46:16 <EvanR> a player can be in (at most?) one room
20:46:22 <CakeProphet> correct.
20:46:24 <EvanR> so theres a table of player -> room
20:46:28 <CakeProphet> a room can contain multiple players.
20:46:36 <jmcarthur> aha!
20:46:41 <CakeProphet> EvanR:  well, theoretically I suppose. Not in the current implementation no.
20:47:15 <CakeProphet> hmmmm
20:47:22 <CakeProphet> ....oh, I could do it that way actually.
20:47:28 <Dashkal> CakeProphet: Sorry, was paying attention elsewhere.  One nifty thing about the system I ended up with is that at the type level, any entity may contain any entity.  Restrictions on what kind of entity can contain what are handled at a different level.  So Players can't contain Rooms simply because the move function will block it via pattern matching
20:51:19 <tolkad> Dashkal: I assume this some sort of game? Your implementation of an environment seperated into rooms seems to be incomplete and erroneous. You should implement the room by simulating all of its physical components so it acts like it would in the real wold
20:51:21 <tolkad> world*
20:52:35 <ddarius> tolkad: The Haskell Report does allow circular imports and says nothing about hs-boot files (or, in fact, "source files" at all.)
20:52:58 <tolkad> ddarius: so why doesn't GHC do that?
20:53:19 <Dashkal> tolkad: I'm representing a MUD.  Rooms are a known entity in this context
20:53:22 <Dashkal> Text based RPG
20:54:34 <aavogt> circular imports probably can't take advantage of separate-compilation
20:54:35 <EvanR> the easiest way to represent a mud is with a database, or a table of rooms linked by room ids
20:54:37 <ddarius> tolkad: Because it complicates the implementation and no one has cared enough to really fix it, and, some argue, that the Report isn't being particularly reasonable on this case since it doesn't support a notion of "module interface."
20:54:45 <Dashkal> "Room" is a bit of a misnomer.  It's actually a "place where a player can be"
20:54:55 <EvanR> in MOO, object ids
20:55:15 <wli> Frankly I'd just shove it into pgsql and let the database be a database.
20:55:23 <EvanR> pointers, or in this case, directly inclusion would be a nightmare
20:56:35 <wli> I think pgsql still lacks multidimensional indexing (e.g. R trees) so that might be a problem with noncommercial databases, but OTOH if it's a problem for them, it's worse for DIY solutions.
20:56:35 <tolkad> Dashkal: and as I said before, your abstraction is inadequate in its representation of the world it is simulating. To be complete and correct, it should represent the world as the physical components that compromise it and implement the interactions between those components correctly
20:57:07 <tolkad> accurately*
20:58:04 <tolkad> Dashkal: you do want your MUD to be realistic, don't you?
20:58:57 <ddarius> tolkad: No, he doesn't.
20:59:10 <tolkad> Dashkal: I'd start with this: http://en.wikipedia.org/wiki/Standard_Model
20:59:12 <Dashkal> Not that realistic, no
20:59:50 <EvanR> standard model of particle physics?
21:00:23 <ddarius> EvanR: Yep.  The real world of tolkad has light and atoms but not gravity.
21:00:31 <EvanR> lol
21:00:38 <tolkad> ddarius: I said start
21:01:27 <EvanR> i have designed a lot of RPG systems in my time with varying levels of realism, but i have to say i have never tried to utilize QCD
21:02:15 * ddarius eats dark chocolate Jello pudding.
21:03:33 <p_l> ... sounds like DF
21:05:18 <wli> I had a vague idea at one point of trying to do something vaguely like imvu but with more accessible clothing design/etc. tools (mesh editors, don't even know enough about graphics to know what's really involved). I gave up after getting only a vague idea of how gargantuan the task would've been.
21:06:28 <dolio> That's why you stick with roguelike games. Much easier.
21:06:51 <dolio> Or text.
21:08:15 <EvanR> or pencil and paper!
21:08:16 <wli> Well, no, that's why roguelike games are "done" and the things like what I said actually have something to be creative about.
21:08:46 <davekong> Is there a way to update a field in a data structure without copying the whole thing into a new one?
21:09:31 <dolio> I'm not sure there's nothing to be creative about in roguelikes. Just nothing visual.
21:11:18 <tolkad> ddarius: also, his game might be taking place before Isaac Netwon invented gravity
21:11:32 <davekong> what? lol
21:12:03 <dolio> That was before all the standard model stuff was invented, too, so your link would be useless.
21:12:11 <wli> dolio: The text adventure construction problem is very well-understood. The HCI issues around video affairs OTOH are very poorly understood.
21:12:37 <tolkad> dolio: That stuff was discovered : / not "invented"
21:13:06 <CakeProphet> meh. I feel like restructuring everything. But I know I'll just restructure again.
21:14:30 <CakeProphet> essentially the outward interface to these objects is something like object -> ... -> STM value
21:14:42 <CakeProphet> differing by function.
21:15:09 <CakeProphet> location :: o -> STM Room
21:15:26 <CakeProphet> or some kind of typeclass for rooms. I don't know what though.
21:18:46 <CakeProphet> jmcarthur:  so what were you suggesting I do exactly?
21:21:38 <tommd> davekong: You are looking for the record update syntax?
21:21:38 <tommd> data Foo = Bar { field1 :: Int, field2 :: Float, ...}
21:21:38 <tommd> f x = x { field1 = 5}  -- other fields, such as field2, will be the same in x as f x
21:22:34 <davekong> tommd: yes, that's what I wanted, thanks
21:22:35 <tommd> notice this is building a new data structure (leaving the old one to be potentially GCed), but the component entries should be shared.
21:22:55 <CakeProphet> Dashkal: hmmm, okay so I've got MudPlayer and MudRoom typeclasses. So far they only have one function each: location and contents.
21:23:04 <CakeProphet> also MudRoom has two parameters, the room type and the contained type.
21:23:31 <CakeProphet> hmmm... well actually it should only have one. and then contents should simply return a list of MudPlayers
21:23:52 <solrize> yawn
21:23:54 <solrize> oops
21:31:15 <CakeProphet> ugh...
21:33:55 <CakeProphet> is it reasonable to have Tvars of structures containing Tvars? 
21:34:29 <CakeProphet> er nevermind
21:34:30 <Dashkal> I did that.  One to contain World, one each for each entity
21:34:36 <CakeProphet> I want IOrefs to structures containing Tvars. nevermind.
21:34:55 <CakeProphet> Dashkal:  I was considering doing it on the level of individual properties.
21:35:05 <CakeProphet> for minimum bottlenecks.
21:35:08 <CakeProphet> on concurrency.
21:35:49 <Dashkal> I felt that to be overkill.  How often will you be affecting multiple properties of the same entity concurrently?
21:36:02 <Dashkal> The only case I see for that is combat
21:36:18 <CakeProphet> Perhaps.
21:36:46 <CakeProphet> I suppose a Tvar for the global structure and then Tvars inside for each entity is reasonable.
21:37:05 <CakeProphet> and less tedious.
21:39:10 <CakeProphet> Dashkal:  at what point did you start using your Game monad stack? I haven't touched transformers yet.
21:39:40 <Dashkal> CakeProphet: I use it to contain game state.  So I didn't have to pass around World all over the place
21:40:13 <CakeProphet> Dashkal:  well I mean. do your utility functions return Game whatever? Or do they return State whatever, IO whatever, etc.
21:40:30 <Dashkal> They return Game a
21:40:44 <Dashkal> Game a is State over Reader over IO
21:43:11 <CakeProphet> Dashkal:  do your entity typeclasses use Game?
21:43:22 <Dashkal> Typeclasses?  I haven't needed them yet
21:43:38 <CakeProphet> Dashkal:  I thought you had an Entity typeclass?
21:43:43 <Dashkal> Entity = Room RoomData | Mobile MobData
21:43:48 <CakeProphet> ...oh
21:43:48 <Dashkal> data Entity...
21:46:22 <Dashkal> Things like moving entities around are handled via EntityRefs (basically a newtype over integer). 
21:46:28 <Dashkal> The ref is just the key for a map
21:46:59 <CakeProphet> Dashkal:  I guess you could have used Either for Entity as well.
21:47:08 <CakeProphet> type Entity = Either RoomData MobData
21:47:51 <tolkad> hey, if I'm using Graphics.UI.GLUT, why would I be getting the error "GLUT Warning: The following is a new check for GLUT 3.0; update your code."
21:47:53 <Dashkal> Same deal as data Entity = Room | Mob, really
21:48:12 <davekong> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LambdaHack
21:48:19 <Dashkal> I only use either for functions that can fail
21:48:41 <Dashkal> Usually I'll make my own type so as to be explicit
21:49:04 <tolkad> oh, I see, that's not it's own error message
21:49:13 <tolkad> that's a prefix for another one, nevermind
21:49:43 <CakeProphet> Dashkal:  hmmm, so is it a bad idea to directly contain data structures within each other? Or should I be passing around TVars and such?
21:49:59 <Dashkal> I don't understand the question
21:50:10 <CakeProphet> I think I already know the answer, actually. so nevermind.
21:50:34 <Dashkal> I don't pass around tvars, since everything is hiding in my StateT
21:50:48 <CakeProphet> not pass around, but contain in structures
21:50:51 <CakeProphet> at the moment I just have
21:50:55 <CakeProphet> currentRoom :: Maybe Room
21:50:57 <CakeProphet> inside my player structure
21:51:06 <CakeProphet> but maybe it should be something more opaque.
21:51:35 <Dashkal> I didn't do that.  My player structure contains an entityref.  the entityref points to a triplet: Parent (the room), Children (the inventory), and Entity (the actual chatracter data)
21:53:27 <CakeProphet> Dashkal:  alright I've figured it out. What I actually want is currentRoom :: Maybe (Tvar Room)
21:53:34 <CakeProphet> for my system.
21:55:31 <CakeProphet> pGroupMap :: Map String (TVar (Set (TVar Player)))
21:55:38 <CakeProphet> ...oh my. Time for some type synonyms.
21:56:13 <CakeProphet> though the outer Tvar may be unecessary.
22:02:36 <Dashkal> I try to keep my TVars one level deep.  World is the one exception
22:02:57 <CakeProphet> I think here it's justified.
22:07:07 <CakeProphet> is it possible to export modules without maintaining an explicit export list?
22:08:14 <Dashkal> If you want to export ALL symbols, omit the () entirely: module Foo where
22:08:27 <CakeProphet> ah okay.
22:09:06 <Dashkal> If you want to export NO symbols, use an empty ().  module Foo () where (not often useful, but hey)
22:11:05 <CakeProphet> Dashkal:  I'm considering having a Types module to export all Type names.
22:11:43 <Dashkal> My preference is still to export explicitly, but that's for style reasons.  I want a full list of symbols all in one place
22:12:17 <Dashkal> Note: even your module imports end up exported when you export all.
22:12:38 <tolkad> wtf?
22:12:43 <tolkad> I tried to use opengl in haskell
22:12:57 <tolkad> and it started adding random UI elements from different programs to my window
22:13:30 <CakeProphet> @src on
22:13:30 <lambdabot> (*) `on` f = \x y -> f x * f y
22:13:57 <CakeProphet> one of the handiest things ever.
22:13:57 <ivanm> Dashkal: I don't think that's true...
22:14:02 <ivanm> (that your module imports are exported)
22:14:04 * ivanm tests
22:14:35 <Dashkal> ivanm: The module imports were re-exported when testing in GHCI
22:14:36 <CakeProphet> Dashkal:  so far my only typeclass is Named. one function: getName
22:15:03 <ivanm> Dashkal: that's not the same thing ;-)
22:15:10 <ivanm> since you're comparing things that are in scope for _that module_
22:15:23 <ivanm> Dashkal: do ":browse Foo" in ghci to see what it actually exports
22:15:31 <ivanm> or else try importing it into another module
22:15:40 <Dashkal> let me know how your test goes.  I don't have ghci available.  I'd like to know if I'm wrong on this
22:15:41 * ivanm just tested this
22:15:49 <ivanm> and yes, you are ;-)
22:15:51 <Dashkal> ok
22:15:56 <Dashkal> delete the module export bit :P
22:16:04 <Dashkal> Apparently if you want them re-exported, you must do so explicitly
22:16:10 <ivanm> Dashkal: when you do "ghci Foo.hs", you're loading that module in scope, so you can see everything that module sees
22:16:26 <ivanm> Dashkal: yup, re-exporting imports must be done explicitly
22:16:32 <Dashkal> *nods* there be my confusion
22:16:44 <CakeProphet> ....I /really/ don't understand why module imports can't be circular. Perhaps the details of the algorithm make it difficult to do.
22:17:09 <Dashkal> CakeProphet: The reason is partly based in compiling.  With circular dependancies, which do you compile first?
22:17:39 <tolkad> I don't think GHC should be considered an implementation of haskell because it doesn't allow circular imports
22:17:44 <Dashkal> the .hs-boot file breaks the loop by providing the list of symbols that must be available, without having ot actually compile the associated .hs
22:17:46 <ivanm> CakeProphet: they can
22:17:53 <tolkad> Please do not call it one
22:17:56 <ivanm> it is just hard for both implementation and reasoning purposes
22:18:04 <ivanm> tolkad: sure it does
22:18:24 <ivanm> the Haskell standard doesn't say it _has_ to magically support circular imports without any extra info
22:18:31 <ivanm> so GHC matches that criteria
22:18:41 <ivanm> there are better reasons not to call GHC a valid Haskell implementation than that ;-)
22:19:00 <Dashkal> With type inference at play, I'm not sure how one would implement it without .hs-boot
22:19:03 <ivanm> CakeProphet: IMHO, if you want cyclic imports, you're doing it wrong
22:19:05 <tolkad> ivanm: like?
22:19:16 <CakeProphet> instance Named Player where getName = (==) `on` pName
22:19:17 <ivanm> tolkad: there are a few things it doesn't differently from the spec
22:19:28 <CakeProphet> er
22:19:29 <CakeProphet> ...
22:19:36 <CakeProphet> Eq Player and (==) instead of getName
22:19:38 <ivanm> tolkad: http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/bugs-and-infelicities.html#haskell98-divergence
22:19:54 <CakeProphet> technically that is a terrible definition of equality. But every player is guaranteed to have a unique name so...
22:20:08 <Dashkal> CakeProphet: Oh yeah, I nearly forgot.  I can remove my final cycle if I want to.  The reason I'm stuck with it is because I'm foolishly stubborn in not exporting IO actions from Game (so only Game.hs may access IO in the Game monad).
22:20:11 <ivanm> CakeProphet: sounds good enough to me
22:20:25 <Dashkal> If I relax that restirction, my last cycle goes poof, since I can then define Game in one file, and all the Game a actions in another
22:21:09 <CakeProphet> ivanm:  also I'm not entirely sure if it's wrong to want circular imports. I think there are good reasons for organizing tightly coupled things in different files.
22:21:15 <ivanm> if you have a cycle between Foo and Bar, then create another un-exported module Baz to break the cycle
22:21:32 <ivanm> CakeProphet: it makes it harder to reason about your code IMHO
22:21:37 <tolkad> wtf? tuples can't be arbitrarily sized?
22:21:38 <ivanm> at the very least it's a code smell
22:21:45 <CakeProphet> tolkad:  nope.
22:21:53 <tolkad> why?!?
22:21:55 <CakeProphet> only 63 or 64 constructors. Sorry.
22:22:15 <ivanm> tolkad: because they're manually created
22:22:24 <ivanm> I would argue that you should never use anything more than say a 5-tuple
22:22:30 <ivanm> (and even that's being generous)
22:22:31 <wli> Compiler magic would help.
22:22:48 <Dashkal> I rarely even use a triplet.  Only time I go that far is in pattern matching
22:22:58 <ivanm> since if you have anything bigger than that, it's something you would be better off creating a custom data structure for documenation reasons if nothing else
22:23:13 <CakeProphet> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
22:23:14 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w ->
22:23:14 <lambdabot> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33)
22:23:52 <ivanm> one of my big things with the new version of fgl (whatever we'll end up calling it) is to stop using 4-tuples and 3-tuples (for Context and LEdge respectively; the former is now a custom type, the latter is now (Edge g, b)
22:24:35 <CakeProphet> ivanm:  well my fix to avoid circular imports at the moment is to put the two modules into a massive monolithic one. Which I don't really like at all.
22:24:55 <davekong> Does Haskell get rid of old library stuff at some point are just keep throwing things in new name spaces?
22:25:17 <ivanm> davekong: If I understand you, the latter
22:25:31 <ivanm> in that it's still possible to dig up and use old packages
22:25:49 <ivanm> however, the actual libraries that get _used_ changes over time
22:25:53 <davekong> ivanm: yea, that is what I mean, it seems to create clutter though
22:26:29 <davekong> If I don't know the libraries well how do I know which Array lib to use?
22:26:42 <ivanm> davekong: that's one thing that Hackage 2.0 will hopefully solve
22:26:55 <ivanm> to add some social interaction there for people to comment on the preferred one, etc.
22:27:08 <ivanm> also, there is limited extent to deprecate and hide packages on hackage
22:27:26 <ivanm> note that Hackage is not just a repository of current packages: it's also meant to serve as a history of Haskell packages over time
22:27:40 <ivanm> as such, no package is actually removed (unless it's found to be malicious, illegal, etc.)
22:29:19 <tolkad> how could a package be illegal?
22:29:41 <davekong> breaks copyrights?
22:29:55 <tolkad> surely haskell programers don't believe in copyright law
22:30:11 <CakeProphet> if it launches missiles
22:30:21 <CakeProphet> well, maybe not.
22:30:31 <CakeProphet> I think missile launching programs are legal so nevermind.
22:30:36 <ivanm> tolkad: if someone stole code, etc.
22:30:43 <ivanm> and why shouldn't we believe in copyright law?
22:30:49 <ivanm> the lawyers have more money than us :(
22:30:55 <tolkad> ivanm: information wants to be free
22:31:10 <ivanm> tolkad: information also wants to be expensive because it's valuable
22:31:28 * ivanm is temtped every now and then to buy a USB missile launcher and write a library that contains an "unsafeLaunchMissle" function...
22:31:33 <tolkad> ivanm: only if it's not available, it's expensive until it's released
22:31:53 <Dashkal> CakeProphet: Re your monolithic module.  Can you remove some of the functions from the supermodule into two smaller ones, leaving the types in the supermodule?
22:32:10 <ivanm> tolkad: ideally, yes; atm that isn't really feasible
22:32:21 <ivanm> unless you have a large war chest to fend off the lawyers with
22:32:26 <ivanm> (using your own lawyers...)
22:32:29 <CakeProphet> Dashkal:  I suppose so. I considered separating the data structures from the functions. Would certainly be more tidy than what I have now.
22:32:47 <davekong> ivanm: or you go to some rebel country that does not care
22:32:58 <Dashkal> I share your preference for mostly keeping types with the functions that act on them, but I make exceptions in cases like this where it cleans things up
22:33:05 <ivanm> tolkad: http://en.wikipedia.org/wiki/Information_wants_to_be_free#History
22:33:09 <tolkad> ivanm: And my axe!
22:33:28 <ivanm> davekong: except most of them have limited technological infrastructure, or some other reason they're undesirable places to live
22:33:38 <ivanm> tolkad: *sigh*
22:33:39 <tolkad> ivanm: best way to fight off a lawyer you know, they are vulnerable to axe damage
22:33:41 <wli> There's the "liber, not gratis" argument also.
22:33:42 <Dashkal> mmm, anthropromorphising not just an inanimate thing, but an immetereal concept
22:34:08 <ivanm> wli: true
22:34:25 <tolkad> Dashkal: it's a metaphorical type thing
22:34:28 <ivanm> however it stands, we currently have to deal with copyrights, etc.
22:34:52 <Dashkal> tolkad: I know.  I just like making fun of the silly expression
22:34:58 <CakeProphet> instance (UniquelyNamed t) => Eq t where (==) = (==) `on` getName
22:35:02 <CakeProphet> why does GHC complain about this?
22:35:09 <Dashkal> :t on
22:35:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:35:28 <ivanm> CakeProphet: what's the error message?
22:35:36 <ivanm> CakeProphet: oh, right
22:35:52 <ivanm> if you do that kind of "automatic instance" thing, there are some issues involved
22:35:53 <CakeProphet> illegal instance declaration Eq t
22:36:01 <CakeProphet> +for
22:36:02 <ivanm> for starters, it blocks off the class from having more instances
22:36:38 <ivanm> CakeProphet: such functionality would be nice, but there are some technical issues (which I'm not familiar enough with to give)
22:36:57 <CakeProphet> would FlexibleInstances fix it?
22:37:09 <ivanm> you need OverlappingINstances for starters
22:37:13 <ivanm> Flexible might also be needed
22:37:21 <ivanm> usually, ghc will tell you which extensions are needed
22:37:38 <ivanm> @pl \ f -> (f &&& id)
22:37:38 <lambdabot> (&&& id)
22:38:00 <CakeProphet> ivanm:  I thought standard library instance declarations had forms similar to this?
22:38:20 <ivanm> CakeProphet: nope
22:38:26 <ivanm> no "auto-declaration" ones
22:38:31 <ivanm> they're all explicit for each type
22:39:03 <davekong> "Information Wants To Be Free, and Code Wants To Be Wrong."
22:39:06 <ivanm> CakeProphet: you _can_ do something like "newtype Foo a = Foo a; instance (UniquelyNamed t) => Eq (Foo t) where ..."
22:40:03 <CakeProphet> ...that's okay. I'll just make two declarations
22:42:25 <CakeProphet> I am amazed at how well Haskell's type system ensures semantic correctness.
22:43:34 <danharaj> Really? because that's what types are for.
22:43:36 <Dashkal> That's what hooked me on the language.  So many mistakes are impossible
22:43:50 <Dashkal> Then I go do PHP and cry myself to sleep :P
22:44:03 <ezyang> Poll: view patterns for parsing: clever or grody? 
22:44:04 <danharaj> The industry wields types like an ancient weapon of forgotten technology.
22:44:40 <ezyang> @remember danharaj  The industry wields types like an ancient weapon of forgotten technology. 
22:44:41 <lambdabot> I will never forget.
22:45:02 <CakeProphet> is there a way I can magically make deriving Show /always/ work?
22:45:17 <tolkad> @forget danharaj  The industry wields types like an ancient weapon of forgotten technology.
22:45:17 <CakeProphet> it seems to want all these pesky instance declarations that don't exist.
22:45:17 <lambdabot> Done.
22:45:25 <Dashkal> Of course not.  How do you show (a -> b)?
22:45:34 <Dashkal> Or TVar a?
22:45:35 <CakeProphet> like this: ""
22:45:38 <CakeProphet> so I can derive Show. :)
22:45:47 <Dashkal> don't derive it, just
22:45:52 <tolkad> sorry, just wanted to show that lambdabot lies
22:45:53 <tolkad> @remember danharaj  The industry wields types like an ancient weapon of forgotten technology. 
22:45:54 <lambdabot> Okay.
22:45:58 <Dashkal> If you aren't deriving to work with read, just implement it yourself
22:46:00 <ezyang> tolkad: haha 
22:46:20 <ezyang> CakeProphet: You ought to make sure it is legit Haskell as output, though 
22:46:24 <danharaj> lambdabot's memory is as fickle as gcc's build system :
22:46:24 <etpace> Hmm
22:46:25 <danharaj> :p*
22:46:41 <ezyang> I thought it was just convention, until I thought up of the pretty-printing trick and found out that two other people had independently come up with the same idea. 
22:46:46 <etpace> It seems my parallel attempt at merging gets destroyed by unix's sort, how upsetting
22:46:59 <danharaj> etpace: eh?
22:47:19 <CakeProphet> Dashkal:  well I do intend to instance Read as well. I was considering using Show and Read as serializers, but I'll probably make my own typeclass instead.
22:47:44 <etpace> have n sorted files, and would like to merge them into one, tried it without parallelelism, was too slow, made it a bit faster by paralleling it up
22:47:55 <etpace> but it still got destroyed very easily by unix sort and zcat
22:48:06 <Dashkal> CakeProphet: There's no way to read a -> b...
22:48:09 <Dashkal> Nor a TVar
22:48:25 <Dashkal> When you're doing things like this Read/Show don't work well for serialization
22:48:43 <CakeProphet> Dashkal:  but for debugging it would be nice if it just filled in a dummy string for Show.
22:48:44 <Dashkal> TVar makes serialization especially annoying
22:48:59 <Dashkal> Then make an instance yourself :P
22:49:14 <Dashkal> Show is designed as it is not for debugging but to work with Read
22:49:29 <CakeProphet> instance Show (TVar a) where show = "ha!"
22:49:41 <tolkad> is there anyway to declare a constructor with the {} syntax and export the functions that that generates without exporting the constructor itself and without specifying those functions by name?
22:50:13 <Dashkal> CakeProphet: In one rev of my scripting system I actually had instance Show ((->) a b) where show = "External Func"
22:50:17 <tolkad> like "Something (..) without Something"
22:50:35 <tolkad> err wait I don't think that even works
22:50:36 <tolkad> nevermind
22:51:39 <Dashkal> Then I realized I was being insane and stopped that :P
22:52:10 <Dashkal> I've actually decided to drop static typechecking.  It's more work than the payoff is worth.  TypeExceptions are acceptable when scripts are intended to be very short and of limited purpose.
22:53:05 <ezyang> Dashkal: throw-away scripts have a funny way of sticking around longer than you expect... 
22:53:20 <Dashkal> If I were going for an LPMud style where almost everything is in the language, it would be worth it
22:53:21 <danharaj> ... and that's how windows 3.1 was born.
22:53:24 <CakeProphet> Dashkal:  I don't think serialization with Tvars will be too bad. typeclass Persistent p where deflate :: p -> IO String; inflate :: String -> p
22:53:38 <Dashkal> ezyang: Fair enough.  But it's more that I know I won't follow through with static types.  Not unless I drop polymorphism.
22:53:55 <CakeProphet> Dashkal:  er... IO p actually. 
22:54:03 <danharaj> Yeah I gave up on static typing for an interpreter I made because of polymorphism.
22:54:19 <danharaj> I should work on implementing something like system F so I can get over that fear.
22:54:39 <Dashkal> CakeProphet: Manual serialization is doable, certainly.
22:55:11 <CakeProphet> Dashkal:  not very fun though. :)
22:55:38 <Dashkal> CakeProphet: I ran into one interesting issue.  In my mud, it's very unlikely that I'll be able to serialize the World object unless I do so synchronously.  Otherwise the player commands and AI would constantly clobber my poor serialize function and I'd run out of time in the current tick
22:56:16 <CakeProphet> Dashkal:  you use a tick system in a concurrent environment? Oh, I guess for combat and such.
22:56:27 <Dashkal> CakeProphet: And throttling
22:56:31 <CakeProphet> I always forget such things because I don't bother with them.
22:56:33 <Dashkal> CakeProphet: One command per 250ms
22:56:35 <CakeProphet> Dashkal:  ah, yes. 
22:57:01 <CakeProphet> Dashkal:  fortunately for me I don't have to worry about such things. Though I might impose delays between command reads.
22:57:07 <CakeProphet> to prevent spam.
22:57:24 <CakeProphet> throttled spam that is.
22:57:31 <Dashkal> *nods* You will want to worry about input spam, DOS attacks, etc.  Just to be thoural
22:57:56 <Dashkal> My current implementation is subject to a nasty DoS attack.  Send very large amounts of data and I'll memory 'leak'.
22:58:14 <Dashkal> Especially if there are no newlines in that data
22:58:24 <Dashkal> Since it'll never chunk off into commands
22:58:32 <CakeProphet> ah yes. I probably have plenty of vulnerabilities that I haven't even considered.
22:59:05 <Dashkal> I'm going to fix that by taking more manual control of the socket code.  hReadLine isn't so smart on a socket.
22:59:44 <CakeProphet> Dashkal:  How would you do that exactly? What functions?
23:00:13 <Dashkal> CakeProphet: I'll read word8s into a buffer, watching for newlines.  Convert to strings (assuming utf8 enclding), then hand off to the mud proper
23:00:23 <Dashkal> Buffer overflow? Kill the connection
23:01:03 <CakeProphet> ah okay.
23:02:01 <CakeProphet> Dashkal: I was actually considering the use of hGetContents instead of hGetLine so that commands defining Parsec parsers could operate over more than one line of data.
23:02:08 <CakeProphet> s/data/input
23:02:47 <Dashkal> My socket code is all nice and isolated.  So I should be able to do whatever I need to to make it work.  IO tricks, mutability, whatever.  This is interfacing with the metal so I feel less constrained.  (Of course this means I have to be MUCH more careful, since I'm walking away from some of the protections haskell offers)
23:03:22 <Dashkal> CakeProphet: That is an option, but if you aren't super careful you can be VERY susceptable to DoS attacks like the one I mentioned.
23:03:46 <Dashkal> Ex: feeding the mud a long stream of data that will never successfuly parse, but won't fail either
23:03:52 <CakeProphet> I don't expect a large playerbase, so I don't think the issue will arrise though.
23:04:05 <Dashkal> You only need one ticked off 14 year old script kiddie
23:04:10 <CakeProphet> haha. true.
23:05:15 <CakeProphet> would imposing line length limits in post-socket-read code prevent memory leaks?
23:05:57 <Dashkal> It could.  If your parser is coded such that no input can infinitely parse, you're home free.
23:06:30 <Jafet> Denial-of-service?
23:06:33 <Dashkal> But that's tricky.  Say you want to skip leading whitespace.  So they feed you [' '..].
23:06:51 <Dashkal> Jafet: yes.  DoS caused by resource exaustion
23:07:44 <CakeProphet> Dashkal:  psh. skipping leading whitespace is for people who want to accomodate stupidly formatted input. :P
23:07:46 <Jafet> Would you give an example?
23:07:57 <Dashkal> Jafet: I can give a concrete one.
23:08:10 <Dashkal> Jafet: My socket code currently uses hReadLine on a socket to get a line of input from a player
23:08:22 <Dashkal> What would happen if that player sends me an infinite string of space characters?
23:08:41 <edwardk> Dashkal: then they will be there for a while sending it ;)
23:08:51 <Dashkal> edwardk: Granted.  Not a super fast attack
23:09:16 <Dashkal> But if I were hosting on a VM with limited ram (common with mud hosts), It could work pretty quickly.
23:09:20 <CakeProphet> I wonder just how many spaces it would take...
23:09:39 <Jafet> Dashkal: then you patiently read each one and discard it.
23:09:45 <Dashkal> Your available RAM worth.  If I were to host on my home machine, well, 4 gigs + 8 gigs swap takes awhile to send :P
23:10:00 <Jafet> A LL(k) grammar helps, naturally.
23:10:03 <Dashkal> Jafet: How?  I'm using hReadLine.  I don't get the data until a \n is seen
23:10:23 <alexdong> newbie question: will anyone look at the code here and explain why compared to line #12, the indentation of line #36 doesn't work
23:10:27 <Jafet> Ah, you're talking about that. I assume plugging the stream direct to parser.
23:10:33 <Dashkal> This being my point.  My use of hReadLine is the mistake
23:10:54 <CakeProphet> alexdong:  certainly. can you give me a link?
23:10:57 <Dashkal> Jafet: Second example.  We're parsing the stream directly.  A command is [a-z]*
23:11:00 <tolkad> why does data A = (Num a) X [x :: a} result in a Not in scope: type variable `a'?
23:11:01 <Dashkal> So send infinite as
23:11:05 <tolkad> err
23:11:07 <alexdong> CakeProphet: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27300#a27300
23:11:08 <tolkad> why does data A = (Num a) => X [x :: a} result in a Not in scope: type variable `a'?
23:11:14 <tolkad> err
23:11:18 <tolkad> why does data A = (Num a) => X {x :: a} result in a Not in scope: type variable `a'?
23:11:29 <Dashkal> Now the parser cannot discard.  All of the as are potentially part of a valid identifier
23:12:10 <tolkad> what do you mean?
23:12:15 <Dashkal> Now I'll grant that this is not unsolvable, but the problem becomes apparent when you realize you now need to code maximal size into half a dozen parsers
23:12:38 <tolkad> huh?
23:12:39 <Dashkal> So my solution is to enforce a maximum number of bytes read right at the socket level, before sending to the parser.
23:12:56 <tolkad> Dashkal: what does my type error have to do with sockets?
23:13:10 <Dashkal> tolkad: Thread cross.  I'm in a different discussion :P
23:13:51 <Dashkal> tolkad: data A a
23:14:05 <Dashkal> tolkad: or use GADTs if you really want to hide the a
23:14:38 <Jafet> The syntax is data (Num a) => A a = ...
23:15:21 <CakeProphet> alexdong:  I can't even tell a difference between the two programs.
23:15:29 <Jafet> Dashkal: not if you use combinators. Then just change the rule defining identifiers.
23:15:43 <Jafet> Or, in fact, any BNF-like structured grammar
23:15:59 <tolkad> Jafet: I don't want a to be a type argument to A, I want it to just be a restriction on what you can pass to the constructor, like you would with an interface in Java
23:18:12 <Dashkal> Jafet: True, as long as you only have a small number of parsers that return an identifier of some sort, it can work that way.
23:18:21 <Jafet> tolkad: great.
23:18:31 <alexdong> CakeProphet: line #12's indentation is 2 tab while line #36 is 1. Don't know why #36 will cause a compilation error. 
23:18:42 <tolkad> Jafet: oh? so there's a way to do that?
23:19:30 <Dashkal> tolkad: GADTs can do it.  data A where A :: (Num n) => n -> A
23:19:50 <Dashkal> note the 'where'.  In GADT form, you specify the full type of the constructor.
23:23:56 <danharaj> hackage is being a jerk to me
23:25:03 <ddarius> danharaj: You probably forgot its anniversary.
23:25:23 <danharaj> heh. I keep getting 'connection closed by remote server' errors.
23:25:41 <ddarius> What the heck?  It's 1:30am.
23:27:16 <CakeProphet> how do you folks normally organize your files?
23:27:28 <CakeProphet> where do you put typeclasses and instance declarations in relation to data declares and functions?
23:28:20 * wli usually puts typeclass declarations between data type declarations and function declarations.
23:28:37 <CakeProphet> that's where mine are right now.
23:29:15 <danharaj> I put type classes at the top and instances at the bottom
23:30:18 <tolkad> Dashkal: didn't work, complains about Illegal generalised algebraic data declaration
23:30:19 * ddarius does NW and SE.  Quite a pain to maintain when I rotate my laptop.
23:30:47 <tolkad> Dashkal: I don't think standard haskell allows GADTS
23:31:16 <Dashkal> {-# LANGUAGE GADTs #-}
23:31:29 <Dashkal> The alternative is extentials, which require even more extensions
23:31:39 <Jafet> I write classes, pretend it's Easter, then write instances
23:33:57 <ski> Dashkal : .. even more ?
23:34:26 <ddarius> A new powerful extension versus an old limited extension.
23:34:37 <nettok> I sense a lot of hate in here http://www.reddit.com/r/programming/comments/co0ny/python_has_a_gil_and_lots_of_complainers/
23:34:51 <nettok> sorry.... wrong channel...
23:35:47 <ezyang> “I hear Haskell doesn’t have a GIL” 
23:36:39 <nettok> I have no idea about threads on haskell, still learning the basics
23:37:26 <nettok> ezyang: you posted a comment there :P
23:37:34 <ezyang> nettok: It’s true. 
23:38:22 <ezyang> nettok: Haskell has extremely compelling primitives for managing concurrency from dataflow land, so if you get a chance to play around with MVars and TVars you should. 
23:39:34 <nettok> ezyang: I'm sure someday I will
23:41:13 <klugefoo> Howdy, I'm new to haskell. Wikipedia says there's a few implementations of it out there. What's the Ubuntu of these (pardon the analogy)?
23:41:29 <nettok> haha
23:41:38 <tensorpudding> Haskell has a few compilers, but GHC is far and away the most important.
23:42:48 <tensorpudding> It is portable, included in the Haskell Platform, which is often considered the best way to acquire a working Haskell development platform
23:42:53 <Jafet> ghc is the ubuntu, debian, fedora, bsd and possibly even posix-2008 of haskell implementations.
23:43:19 <Jafet> If you ever need to port it to a new arch, it also becomes a gentoo
23:43:42 <tensorpudding> GHC has native code output as well as a nascent LLVM backend.
23:45:21 <malc_> tensorpudding: what's a Haskell Platform?
23:45:32 <ezyang> malc_: What you’d think of as Ubuntu. 
23:45:52 <malc_> ezyang: excuseme?
23:46:28 <tensorpudding> It's a package that includes GHC, a package management library Cabal, and a set of core libraries which are used by a great number of other Haskell programs and libraries
23:47:07 <tensorpudding> This package is available on Windows, Mac, and Linux.
23:47:23 <tensorpudding> and also available in source form
23:48:05 <klugefoo> hmm, on a mac with macports on it, I'll go check it out,
23:48:12 <tensorpudding> There is a Mac installer
23:48:17 <malc_> as usual i'm outta luck, linux/ppc only in form of debian packages, with all signs of dependency hell
23:48:30 <tensorpudding> Though it's only for Intel Mac.
23:49:59 <ivanm> hmmm, looks like I'm almost ready to release the new version of graphviz...
23:50:23 <ivanm> tensorpudding: you forgot to mention cabal-install
23:50:25 <tensorpudding> PPC is supported by GHC
23:50:38 <ivanm> I don't think PPC has a native backend though...
23:51:07 <malc_> tensorpudding: define supported, sure there are .debs lying around, doesn't help much if one does not use debian though
23:51:26 <tensorpudding> It can be bootstrapped and built on a PPC OSX system
23:51:36 <tensorpudding> Also it appears to have native codegen
23:52:02 <tensorpudding> though it is 32-bit only
23:52:34 <ivanm> ahhh
23:52:51 <ivanm> malc_: "supported" means "it will build and run, and there is a binary for it somewhere"
23:53:33 <malc_> ivanm: okay
23:53:33 <ivanm> huh, the 6.12.3 page seems to not work...
23:53:45 <malc_> but not being able to bootstrap it on a target system is a show stopper for me
23:53:46 <tensorpudding> There are not binaries distributed for recent versions, so you'll probably have to go through the painful process of bootstrap builds, or deal with whatever packages Debian has provided.
23:53:53 <tensorpudding> Lenny is stuck on 6.8 I think.
23:54:23 <ivanm> maybe even going back to the last C-only release in 6.2 or whatever it was, and bootstrap your way from there
23:54:25 <ivanm> *shudder*
23:54:36 <malc_> o
23:54:41 <malc_> erm
23:54:50 <malc_> no thanks..
23:56:17 <ddarius> ivanm: "C-only" ?
23:56:42 <ivanm> ddarius: well, you didn't need a Haskell compiler installed to build it
23:56:48 <ivanm> probably still used perl, etc.
23:57:38 <ivanm> (going from memory here; someone was telling me about this a while back)
23:57:54 <ivanm> huh, looks like as of 6.11 the recommended way is to do a cross-compile to build an unregisterised C
