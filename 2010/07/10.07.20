00:01:58 <Itkovian> dreixel: http://pastebin.org/407505
00:02:27 <etpace> Will readwritemode append to the end of hte file?
00:02:59 <nyingen> I'm trying to write a function like hGetContents, but instead of returning a lazy list of characters, I want it to return a lazy list of (String, Int) pairs, where the string is the next line, and the Int is the offset of that line in the file
00:03:05 <nyingen> not quite sure how to do it though
00:03:21 <nyingen> hints?
00:04:33 <manjunaths> how do I convert a Just a to a ?
00:04:39 <handonson> manjunaths: fromJust
00:04:52 <handonson> nyingen: can you write a 'strict' version of it?
00:04:57 <manjunaths> Not in scope: `fromJust'
00:05:01 <handonson> manjunaths: Data.Maybe
00:05:06 <manjunaths> ah ok
00:05:15 <handonson> import Data.Maybe (fromJust)
00:05:24 <nyingen> handonson: I could, but the rest of my program is already structured to work with a lazy list
00:05:30 <manjunaths> thanks
00:05:34 <dreixel> Itkovian: no idea. you can try playing with --constraint syb==2.1, or --constraint base==4.3.0.0, but I don't think that will help much
00:05:34 <handonson> nyingen: then write it and
00:05:38 <nyingen> the datafile is also very large
00:05:46 <handonson> nyingen: wrap the function with unsafeInterleavIO
00:05:51 <handonson> unsafeInterleaveIO
00:05:55 <handonson> was it?
00:05:56 <dreixel> Itkovian: I also hope it's not to do with syb being installed as user package...
00:06:12 <Itkovian> dreixel: could that be the case?
00:06:15 <handonson> i think so.
00:06:28 <ski> nyingen : it should be easy to do that from just a `String', i think
00:06:57 <dreixel> Itkovian: have you tried cabal install --user ?
00:07:07 <Itkovian> dreixel: It should be able to find that through dump --user, no?
00:07:10 <dreixel> or try to install syb as global.
00:07:17 <nyingen> ski: what do you mean?
00:07:17 <Itkovian> dreixel: nope, trying now
00:07:33 <dreixel> Itkovian: well, yes, I think so, but then again, I don't really understand what it's doing, so...
00:08:02 <ski> nyingen : i mean, loop through the `String' you get from `hGetContents', keeping track of a current position, and split off a line with position each time you see a newline (or end of string)
00:08:02 <Itkovian> installing parsec as --user does not help
00:08:12 <Itkovian> trying to install syb global
00:09:35 <nyingen> ski: ah, there's an added wrinkle here in that the datafile contains multilingual text in UTF8 encoding. I've been using Data.Text for the "strings", but I don't know of any way of extracting byte-offsets doing this
00:10:20 <Itkovian> argh. when sudoing it seems to be using the old ghc.
00:10:33 <earthy> 2]]
00:10:55 <ski> nyingen : hm, i suppose if you can't just depend on seeing newline characters, it becomes more complex
00:11:10 <nyingen> well, I can depend on the newlines
00:11:32 <nyingen> but since there's multibyte characters, I can't do something simple like counting the characters in the output strings
00:11:53 <ski> do you want offsets in terms of the original `Char's, or in terms of the UTF8 characters they encode ?
00:11:54 <Itkovian> this is so going to suck when I need this scripted
00:11:58 <ski> hm
00:12:03 <handonson> manjunaths: you know fromJust will throw an exception if a Nothing is given to it
00:12:05 <nyingen> ski: I need them in terms of the byte offsets in the file
00:12:56 <ski> and the `String' you get, is each `Char' an UTF8 character .. or (possibly) part of the encoding of such ?
00:13:10 <ski> (.. you get with `hGetContents', i.e.)
00:13:12 <handonson> manjunaths: so use it only if you are sure there's no change you will get a Nothing, or write some exception handling (in this case, i'd rather use pattern matching for Nothing and Just a instead of try and fromJust)
00:13:26 <handonson> change -> chance
00:14:09 <ski> manjunaths : or `fromMaybe (error "dang !") ...'
00:14:25 <nyingen> ski: I was actually reading the data with Data.Text.Lazy.IO.readFile, so I was getting a Text object out
00:14:48 <adnap> I'm reading this and getting so confused: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html  I need to see some decent examples!
00:14:52 <nyingen> which I then parceled into lines myself, lazily, using a pure function. But I can't figure out a way to handle the byte-counting that way
00:15:04 <ski> @type Data.Text.Lazy.IO.readFile
00:15:05 <lambdabot> Couldn't find qualified module.
00:15:20 <nyingen> I figured it would be better to write a variant of hGetContents that returned (Text, Int) pairs, but maybe there's a better approach?
00:15:37 <ski> maybe you can convert from `String' to `Text' ?
00:15:58 <nyingen> yeah, maybe
00:16:16 <ski> (so that you could first go from `String' to `[(Int,String)]' and then to `[(Int,Text)]')
00:16:22 <Itkovian> Frak. No sigar. syb is now installed system-wide, but still cabal refuses to find it when installing (a configured and built!) parsec
00:16:32 <handonson> adnap: not sure if this is what you want, but check http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
00:16:45 <Itkovian> cleaning and retrying
00:20:41 <adnap> handonson: A lot of tutorials and documentation seem to focus on calling C functions in Haskell, but I would like to see some examples of calling Haskell functions in C.  Specfically, I would like to know how to marshal user-defined Haskell types to C.
00:21:13 <handonson> calling Haskell functions in C?
00:21:25 <adnap> handonson: Yes
00:21:53 <handonson> the only way i know is to use some packages like plugins, Hint, dyre, metaplug, mueval, etc
00:22:06 <adnap> handonson: The FFI supports calling Haskell functions in C.
00:22:22 <dreixel> Itkovian: let me know if it works (or not)
00:22:28 <handonson> yeah you should be able to
00:22:40 <Itkovian> dreixel: well, I'm back to using Setup, but now complains about mtl
00:22:48 <Itkovian> installing that globally as well
00:22:49 <handonson> it's just that i've never seen that kind of usage actually taking place
00:23:11 <adnap> handonson: Let's say I have a function in Haskell that returns [Turtle].  What do I need to do to operate on this in C?
00:23:43 <handonson> I have no idea.
00:23:51 <adnap> handonson: Me either! XD
00:24:06 <napping> you just want to do FFI stuff?
00:24:13 <handonson> I personally wouldn't call Haskell functions in C, forever
00:24:25 <adnap> napping: What do you mean, "just want to"?
00:24:54 <napping> Are you just talking about basic calls back and forth?
00:25:26 <adnap> napping: That's not very specific, but yeah, I guess so.  That's what the FFI is for, right?
00:25:33 <napping> yeah
00:25:42 <adnap> Let me be very specific.
00:25:43 <napping> it doesn't say much about manipulating Haskell values from C
00:26:15 <Itkovian> dreixel: I'm in the building stage using runghc Setup
00:26:30 <adnap> I'm working with the rendering engine OGRE.  I want to do all of my logic in Haskell, but I need to give OGRE some basic information to render things.
00:26:33 <Itkovian> dreixel: it seems to work if syb and mtl are installed globally
00:27:17 <adnap> For instance, I might have a function that returns [Point], and I want to give that to OGRE to render something like a triangle.
00:27:19 <dreixel> Itkovian: ok, well, at least it works somehow... though you might want to report this
00:27:27 <dreixel> Itkovian: it might be an issue with cabal-install
00:27:31 <Itkovian> dreixel: report where?
00:28:05 <dreixel> Itkovian: here, I believe: http://hackage.haskell.org/trac/hackage/
00:28:26 <dreixel> Itkovian: or email cabal-devel@haskell.org
00:28:40 <napping> yeah, calling C functions is easy, builing a nice interface on top is harder
00:29:44 <Saizan> Itkovian: with Setup you've to pass --user if you want to use the user-installed packages
00:36:41 <Itkovian> Saizan: OK, and with cabal-install? Similar?
00:39:03 <napping> adnap: what have you made?
00:40:44 <Itkovian> Saizan: in any case, cabal install --user does not work.
00:42:05 <adnap> napping: Can you be more specific?
00:42:20 <napping> What are you making with the 3d stuff?
00:42:37 <napping> anything fancy yet?
00:43:12 <adnap> napping: Hopefully a game eventually.  Right now I'm just trying to figure out how to get C and Haskell to work together.
00:43:21 <napping> oh, have you read the FFI docs?
00:43:51 <adnap> napping: Yeah, I posted a link a few minutes ago to what I was reading.  It was kind of confusing, and lacked examples.
00:43:53 <Saizan> Itkovian: no, with cabal install --user is the default, i guess i'm missing some context tough :)
00:44:16 <Itkovian> Saizan: see also http://pastebin.org/407505
00:44:23 * Zao fondly remembers writing storable instances manually.
00:44:32 <napping> It's pretty straightforward - foreign import and export for calls, foreign export dynamic for callbacks
00:44:36 <Zao> Nowadays thankfully I have bindings-dsl to do the heavy lifting.
00:45:05 <napping> and all the stuff under Foreign to work with the raw data
00:45:07 <Zao> napping: foreign export wrapper too for generating a function pointer from a Haskell "function"
00:45:11 <adnap> napping: Right, but when I do a foreign export, my function is limited to specific types, right?
00:45:22 <napping> yeah, you can only pass out things C understands
00:45:52 <napping> mostly Ptr, Int, Float
00:45:59 <adnap> napping: So, what do you do if you want to do something like export a function whose type is Int -> [Int]?
00:46:36 <adnap> napping: Perhaps you even want something like Int -> [Point], where Point is a user-defined type.
00:46:37 <napping> well, if the C doesn't need to manipulate the list you can use the StableName stuff to get a void*
00:46:37 <ksf> hmmm maybe bdd's are the wrong approach, i'd still have to do a lot of bookkeeping as my input is a word, not eight one-bit registers.
00:46:55 * ksf zens folding over the word
00:47:16 <ksf> in the worst case, that should be 16 insns or so
00:47:33 <adnap> napping: I don't know about that.  Can you elaborate, or provide a link to some info?
00:47:42 <Saizan> Itkovian: you installed syb-0.2.1 by hand by editing the .cabal file?
00:48:10 <napping> oops, I meant Foreign.StablePtr
00:48:12 <Saizan> Itkovian: in that case you should bump the version to syb-0.2.1.1 first
00:48:24 <napping> If C just needs to hang onto a handle and pass it back to a callback
00:48:28 <Itkovian> Saizan: Yes. It refused to install on ghc 6.13.x and that has base-4.3.0.0
00:48:43 <Itkovian> Saizan: You mean the installed version?
00:49:42 <Saizan> Itkovian: well, you've to edit syb's .cabal file and put version: 0.2.1.1 there and reinstall it
00:49:43 <Itkovian> I only see 0.2.1 on hackage
00:49:57 <Itkovian> ah
00:50:01 <Itkovian> ok
00:50:07 <napping> you can wrap any Haskell value in a StablePtr and cast between StablePtr and void* for going through C - no other guarantees, though
00:50:31 <arcatan> adnap: if the only thing you want to do with FFI is to use OGRE, have you taken a look ot http://hackage.haskell.org/package/hogre?
00:50:47 <Saizan> Itkovian: otherwise cabal-install will deduce it can't use the installed syb-0.2.1 by the fact that it can't configure the hackage's corresponding version in the current context
00:51:19 <adnap> arcatan: I've seen it.  It's extremely limited.  Also, I plan on using other C libraries.
00:51:39 <adnap> arcatan: I don't want to have to rely on Haskell bindings for everything I want to use.
00:51:40 <arcatan> yeah, it is.
00:51:59 <adnap> napping: What will be the format of the data pointed to by void* is I do this?
00:52:08 <napping> Otherwise, you generally convert to something C  can understand on the Haskell side
00:52:14 <napping> with StablePtr the void* doesn't mean too much
00:52:45 <adnap> napping: Can I describe a simple scenario, and then you tell me how I might do it?
00:53:02 <roboshibby> hey guys, does haskell have atomic state operations built in? like a file system has read/write
00:53:04 <napping> probably
00:53:05 <Zao> If you want something C understands, have a Storable instance, allocate memory and poke your value(s) into it.
00:53:14 <Zao> Of course, you need to free it eventually then.
00:53:14 <napping> yeah, that's pretty much it
00:54:04 <adnap> napping: Let's say I have the data constructor data Point = Point Double Double Double.  Now, I also have a function that returns [Point].  Let's say my goal is to be able to call a function in C that spits out a bunch of floating point values which correspond to [Point].
00:54:21 <napping> so what signature do you want to expose in C?
00:54:54 <adnap> napping: Do I need to write a function in Haskell that takes [Point] and converts it to a pointer to CDouble?
00:55:09 <Zao> f :: Point -> [Point]     f p = callCWith p    -- like this?
00:55:44 <Zao> I can't say I quite understand the direction you want data to travel.
00:56:15 <Zao> Which language calls what function implemented in what language?
00:56:25 <napping> that's usually how you would return a list - probably one of the functions in Foreign.Marshal.Array converts the list like you want
00:56:27 <adnap> napping: I think the function should take no arguments and return double*.
00:56:37 <napping> and how do you know how long the array is?
00:56:37 <adnap> Zao: C calls a Haskell function.
00:57:10 <adnap> napping: I guess you could terminate with a specific identifier.  I don't know.  What do you suggest?
00:57:27 <napping> I don't know, it's your C library you are trying to support
00:58:09 <napping> the *0 functions support an end terminator like that
00:58:25 <adnap> napping: *0 functions?
00:58:33 <napping> withArray0, withArrayLen0, etc
00:59:11 <napping> I would expect a graphics library to have functions that you would want to pass an array, rather than calling out to client functions and expecting an array back
00:59:12 <Zao> I'd do it with a haskell function analogous to   Point* f(Point* in, uint32_t* len) { Point* ret = malloc(42 * sizeof(Point)); *len = 42; return ret; }
00:59:42 <Zao> Of course, you would then have to have a corresponding release function. Isn't C lovely.
01:00:04 <Zao> Or of course, have the caller allocate "sufficient" space.
01:00:45 <napping> The Foreign.* modules have everything you could want for allocating memory from the C heap, working with pointers (and pointer arithmetic), and so on
01:00:49 <roboshibby> hey guys, does haskell have atomic state operations built in? like a file system has read/write, load/store, etc
01:01:25 <adnap> napping: I don't know what you mean.  I know in OGRE, you can specify geometry by repeatedly making calls to a function where you pass something like a vertex.
01:01:49 <napping> there are some tools like c2hs to help, but in the end some Haskell function implements a C interface pretty directly using the Foreign stuff
01:02:15 <napping> adnap: well, wouldn't that be a C function like void glVertex3f(float, float, float)
01:02:30 <napping> which you could foreign import as CFloat -> CFloat -> CFloat -> IO ()
01:02:30 <adnap> napping: Yes, it's something similar to that.
01:02:45 <adnap> napping: You'
01:02:56 <napping> and then just do a nice happy mapM_ (\(Point a b c) -> glVertex3f_ a b c) points
01:02:56 <adnap> napping: You're suggesting I import the C functions to Haskell?
01:03:13 <napping> well, that's usually how it goes if there are C functions you want to call from Haskell
01:03:18 <Zao> If it's like  void enqueue(float*), you'd have it imported as   c'enqueue :: Ptr CFloat -> IO ()
01:03:27 <Zao> adnap: You seem quite confused to who consumes what.
01:03:41 <adnap> Zao: What do you mean?  You can do it either way.
01:03:47 <Zao> adnap: On one hand, you're talking about wrapping a C library, but in the next sentence you're talking about calling Haskell functions from C.
01:04:02 <napping> remember, it works fine to nest calls
01:04:03 <adnap> Zao: I was never talking about wrapping a C library.
01:04:33 <napping> roboshibby: what sort of operations? There are variables you can read and write
01:07:12 <adnap> napping: If I import the C functions into Haskell, how are they executed in the context of my C program?  For example, if my C code calls glBegin and glEnd, how to I trigger my Haskell code to supply vertices?
01:07:33 <napping> you'd export a Haskell function like send_the_vertices
01:07:46 <napping> call that between glBegin and glBegin, and it would call glVertex a bunch of times
01:07:53 <adnap> napping: Okay
01:08:25 <napping> It's usually easiest to keep data structures and traversals over them on the Haskell side
01:09:07 <napping> I think threads ought to work out, even if it matters
01:09:28 <adnap> napping: I will probably be doing networking code in C too.
01:09:55 <napping> IIRC it's promised that if C calls into Haskell, then any C calls made from the haskell function will happen in the same thread that originally called in
01:10:29 <adnap> napping: I might have structures in Haskell which represent players and their positions, and that information will need to be communicated to the C code.
01:11:04 <napping> well, then you will have to figure out how you want it represented and convert
01:11:28 <napping> for bit things like that, it might make sense to have an opaque void* on the C side and expose extra functions for
01:11:31 <napping> working with it
01:12:05 <adnap> napping: Yeah, I'm still trying to figure out where to draw the line between Haskell and C.  I really just want to have game logic in Haskell, and the rest in C.
01:13:03 <Zao> For what it's worth, my application is basically a small C++ application that calls a Haskell DLL that exports  'update, key, mouse, paint'.
01:13:21 <Zao> The Haskell DLL imports a C DLL with functions like create_sprite, draw_sprite, etc.
01:13:39 <Zao> Slightly convoluted, but "works" thus far.
01:13:41 <adnap> Zao: Okay
01:14:34 <adnap> Do you think I might also create classes in C++ which correspond to my types in Haskell?
01:14:50 <napping> It's a pain to keep two sets of things in sync
01:14:52 <Zao> Structs, sure.
01:15:21 <napping> Structs you might have to
01:15:22 <Zao> It would be more like deriving a Haskell type from the C one though.
01:15:35 <Zao> Much like how bindings-dsl does easily.
01:18:41 <adnap> Wont importing all my C functions be like having bidings, but with less work?
01:19:32 <Zao> Eh? Importing them would _be_ binding.
01:20:07 <Zao> Just a low level one without additional Haskell fluff.
01:20:13 <adnap> Zao: Right.  I guess I meant having something like HOgre.
01:20:21 <Zao> http://bitbucket.org/mauricio/bindings-dsl/wiki/Home <- my bestest friend in the world for low-level bindings.
01:21:13 <Zao> adnap: You could probably reuse some of the guts of HOgre.
01:21:37 <Zao> After all, OGRE is a C++ library, so binding it is not horribly trivial.
01:22:37 <adnap> Zao: So, this tool takes care of most of this?
01:23:04 <Zao> It's a set of handy hsc2hs macros.
01:24:57 <adnap> Zao: I don't know how to use hsc2hs yet.  I guess I better figure that out first.  This is all so daunting.  I like coding in Haskell.  I know how to code in C++.  Why does it have to be so hard to make them work together?!
01:25:27 <Zao> adnap: You _really_ want to have a C-ish interface inbetween.
01:26:16 <adnap> Zao: If there were enough libraries already written in Haskell, I would do everything in Haskell.
01:26:29 <Zao> So what are you missing on the H side?
01:27:06 <adnap> Zao: Decent physics, sound, and graphics libraries.
01:27:38 <adnap> Zao: Or decent bindings
01:28:48 <Peaker> Python has boost::python for C++ bindings
01:29:08 <Peaker> Maybe Haskell can have some C++-friendlier binding tool?
01:29:21 <Zao> Peaker: It's easier with python as it's rather OO-ish itself.
01:29:28 <Zao> Not much impedance mismatch there.
01:30:29 <Peaker> The "OO-ness" which they share seems to be the syntactic way methods are invoked on single-dispatched objects?
01:31:25 <adnap> Has anyone written networking code in Haskell?  Is it preferable to writing networking code in C++?
01:31:42 <quicksilver> yes, much preferable.
01:32:03 <quicksilver> To be honest I can't think of any kind of code that's preferable to write in C++. 
01:32:12 <adnap> quicksilver: Ha-ha..
01:32:19 <Peaker> hsc2hs kinda sucks -- making cross-compilation and other things problematic
01:32:53 <ksf> good news: there's a solution to every problem set I'm dealing with, though the margin is too narrow. bad news: I've got no idea how to do it in guaranteed finite time.
01:33:00 <Zao> adnap: I implemented the xtris protocol. It wasn't _too_ bad.
01:33:01 <Peaker> adnap, Look at "defend the king", it's a real time OpenGL game developed by yairchu using his own FRP framework (peakachu) and supports real-time network play
01:33:14 <Zao> I found it much nicer in Boost.Asio though.
01:33:32 <quicksilver> I don't think there is anything intrinsic about haskell which means you could do the equivalent of boost::python for it
01:33:36 <quicksilver> it's just no one has done so.
01:33:43 <quicksilver> s/could/couldn't/
01:33:55 <ksf> Language.Lua?
01:34:17 <Zao> quicksilver: There's a bit of difference in how Python loads things too.
01:34:35 <quicksilver> it's not like boost::python was an "easy" project.
01:34:42 <Zao> quicksilver: After all, an interopped Python module is just a DLL with some entry points.
01:34:42 <ksf> if you want a scripting language use lua, it's the only one properly designed for that niche.
01:34:46 <quicksilver> it's quite a substantial piece of work
01:34:48 <opqdonut> lua is awesome
01:34:58 <opqdonut> python sucks as an integrated scripting language
01:35:09 <Zao> While with a mythical Boost.Haskell, you'd have to emit hs files and all.
01:35:17 <Zao> quicksilver: It's quite scary.
01:35:17 <ksf> well you could probably roll a quick lisp or such, but then you could just as well use lua.
01:35:31 <adnap> Peaker: Does he use HOpenGL?!
01:35:35 <Peaker> opqdonut, Is Lua lexically scoped or dynamically scoped? I heard contradicting things
01:35:41 <Peaker> adnap, I don't know, it was a while ago, maybe?
01:36:07 <ksf> it's got full closures/objects/tables, so yes, you can do dynamic scoping.
01:36:20 <ksf> (everything in lua is a table)
01:37:26 <quicksilver> Peaker: it's primarily lexically scoped
01:37:30 <adnap> Peaker: Yeah, that's what it looks like.
01:37:36 <quicksilver> however since it has the tools over-ride "environments" explicitly
01:37:52 <quicksilver> you can arrange dynamic scoping by saving environment, modifying it, calling code, and restoring it.
01:38:25 <Peaker> quicksilver, I was worried that it encouraged use of dynamic scoping in general over lexical scoping, like elisp
01:38:30 <quicksilver> nope
01:38:43 <quicksilver> in general lua is a great scripting language for C/C++ apps and I assume it's quite nice for haskell too
01:38:57 <quicksilver> but that's not quite relevant to the C++/haskell game split we were talking about ;)
01:38:57 <Peaker> With hint, Haskell is probably a great scripting language for Haskell :)
01:39:06 <quicksilver> Peaker: yes. 
01:40:07 <kfish> does anyone have a vim syntax file for ghc core?
01:40:09 <Saizan> hint/ghc-api still feel quite hacky though, i guess they'll get more polished with use
01:54:21 <mornfall> How do I haddock GADT constructors?
01:54:59 <ksf> > 256^2
01:55:00 <lambdabot>   65536
01:55:04 <Peaker> When using a logged Berkeley DB with transaction support -- it seems the db "environment" contains an ever-growing log/journal. Once the journal is applied, I'd expect it to be deleted, anyone knows how to get rid of the ever growing journal?
01:55:52 <mornfall> Peaker: I think db_something (from the DB utils) removes the logs.
01:56:07 <mornfall> db_recover maybe?
01:56:13 <mornfall> Or maybe something else.
01:56:32 <Peaker> hmm.. this kinda sucks..
01:56:48 <Peaker> Maybe I should switch to some other key/value store soon.. I get to 10MB of logs in no time
01:56:57 <mornfall> Peaker: Oh. If you aren't in for the suckiness, you should probably try to avoid bdb... :P
01:57:16 <FauxFaux> 10mb?  OH NO
01:57:32 <Peaker> FauxFaux, I've just got a toy example, I want this to be scalable for large projects :)
01:57:36 <Peaker> mornfall, Really? I heard it was good
01:58:13 <mornfall> Peaker: Dunno. The project has lots of fancy words attached to it, but all the realworld applications always sucked horribly.
01:58:24 <mornfall> Peaker: Case study 1: subversion. Morale? Total failure.
01:58:46 <mornfall> Peaker: Case study 2: cyrus... Morale? If you like your data, never fill up your partition. Ever.
01:59:26 <mornfall> (Although to be honest, cyrus breaks down also for non-bdb-related issues, so this may not be completely cyrus's fault...)
01:59:42 <Peaker> "Redis" wikipedia page says it stores "everything in RAM" - though github uses it so probably not?
01:59:52 <Peaker> mornfall, and svn sucks for general reasons too :)
01:59:58 <Jonno_FTW> what is the opposite of null?
02:00:07 <mornfall> Jonno_FTW: not . null :D
02:00:30 <Jonno_FTW> in one word
02:00:33 <mornfall> Peaker: True, but since the FSFS switch, it no longer casually loses data.
02:01:13 <mornfall> Jonno_FTW: Doesn't seem to be there. You probably need to bind it.
02:01:55 <Jonno_FTW> Not a definition, but a name, so that I may give the function a name that is not notNull
02:02:42 <manjunaths> how do I force a function to be evaluated without printing it ?
02:02:53 <manjunaths> printing it's output
02:03:21 <Jonno_FTW> s <- output?
02:03:57 <mornfall> Peaker: Oh, case study 3: rpmdb aka "rpm once stuck won't get unstuck until you manually recover the database"...
02:04:00 <manjunaths> Jonno_FTW, sorry I don't understand
02:04:11 <Jonno_FTW> I need the antonym of Null
02:04:42 <mornfall> Jonno_FTW: notNull may actually be the best name, though...
02:04:56 <mornfall> nonempty could work
02:04:56 <manjunaths> Jonno_FTW, sorry I thought you were answering my question
02:05:08 <mornfall> manjunaths: He was.
02:05:17 <mornfall> :t evaluate
02:05:18 <lambdabot> Not in scope: `evaluate'
02:05:28 <mornfall> Control.Exception evaluate :: a -> IO a
02:05:41 <mornfall> ^^ that could help you (although it's just WHNF, I guess)
02:05:58 <mornfall> For anything more, you need deepseq, I reckon.
02:06:28 <Peaker> mornfall, heh, ok. I wonder what key/value store to use. I don't need a distributed model, but I want something that will scale well to hundreds of millions of keys
02:06:41 <Peaker> mornfall, many gigabytes of storage
02:07:03 <mornfall> Peaker: Well, any of the RDBMs on the market will work.
02:07:11 <mornfall> Although if you want embedded, then it's a hard call.
02:07:12 <Peaker> mornfall, R=relational?
02:07:20 <mornfall> Peaker: Yeah.
02:07:44 <Peaker> mornfall, I don't think I need relational.. I just need transaction support (basically crash resilience)
02:07:55 <manjunaths> ok...I don't know what to do with Control.Exception.evalute
02:07:58 <manjunaths> ok...I don't know what to do with Control.Exception.evaluate
02:07:59 <Peaker> mornfall, this is meant to store serialized code of potentially large projects
02:08:02 <manjunaths> thanks though
02:08:18 <mornfall> Peaker: You probably don't, but sadly, it's usually the easiest solution.
02:08:33 <mornfall> Peaker: You could try some of the new crop, like mongodb or couchdb. But I would be wary.
02:08:40 <mornfall> Peaker: (These aren't R.)
02:09:37 <mornfall> You can talk to couchdb from Haskell, but I would take the authors' praise with a grain of salt.
02:10:02 <mornfall> gtg, bbl :)
02:10:33 <Peaker> couchdb used via Javascript, written in Erlang, and kept in svn?? ahhh
02:12:05 <Saizan> manjunaths: what do you want to evaluate, specifically? can you paste some code?
02:12:15 <manjunaths> Saizan, ok
02:13:08 <manjunaths> please don't laugh http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27834#a27834
02:13:20 <manjunaths> I am writing a small program to test something
02:13:55 <Zao> My eyes! :D
02:14:04 <manjunaths> some other C program has given my an output and my haskell program is not, so I am trying to debug  a pure function, I have all the trace code all over the update function...
02:14:27 <manjunaths> but the last print statement needs to be there to get update to be evaluated
02:14:35 <manjunaths> this is completely screwing up my output
02:15:04 <manjunaths> so I don't want to have a print statement in main, but I want update to get evaluated so all the trace messages come out
02:15:18 <manjunaths> Zao, :-)
02:16:50 <Saizan> manjunaths: since k is a list seq is not enough
02:17:10 <manjunaths> Saizan, ok
02:17:19 <Zao> You want some kind of deepseq.
02:17:35 <Saizan> if Quaternion is an instance of NFData you can use "evaluate (rnf k)"
02:18:17 * hackagebot parallel 3.0.0.0 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.0.0.0 (SimonMarlow)
02:18:51 <manjunaths> Saizan, it is not an instance of NFData it is something I wrote
02:19:07 <Saizan> you could make it one then :)
02:19:11 <Saizan> how is it defined?
02:19:46 <manjunaths> w00t it worked
02:19:58 <manjunaths>      bleh = map (`seq` "wha") k
02:19:58 <manjunaths>   print bleh
02:20:06 <manjunaths> I changed the code to this and it worked
02:20:25 <manjunaths> now I get a bunch of "wha" which I can filter out I think
02:20:33 <Saizan> ...
02:20:38 <Zao> ...
02:20:41 <Saizan> there's a much cleaner way!
02:21:07 <manjunaths> ok
02:21:18 <manjunaths> Saizan, one moment
02:21:33 <Saizan> evaluate $ foldl' (flip seq) () k
02:21:34 <manjunaths> http://github.com/manjunaths/Mass-Spring-Simulator
02:21:46 <Saizan> ?type foldl' (flip seq) ()
02:21:47 <lambdabot> forall b. [b] -> ()
02:21:58 <Saizan> > foldl' (flip seq) () [1,3,undefined]
02:21:59 <lambdabot>   *Exception: Prelude.undefined
02:22:41 <manjunaths> > Prelude.foldl'
02:22:41 <lambdabot>   Not in scope: `Prelude.foldl''
02:22:46 <manjunaths> > foldl'
02:22:47 <lambdabot>   Overlapping instances for GHC.Show.Show
02:22:47 <lambdabot>                              ((a ->...
02:22:58 <manjunaths> where is foldl' defined ?
02:23:07 <Saizan> Data.List
02:23:12 <manjunaths> ah...ok
02:23:39 <manjunaths> ah...cool
02:23:50 <manjunaths> your incantation worked better
02:26:58 <Saizan>       9~9~9~9~9~9~9~
02:39:05 <Saizan> manjunaths: it's worthwile to learn about foldl', there are a few pages on the haskellwiki on it
02:41:33 <byorgey> RayNbow: I figure inserting a little irrelevant humor doesn't hurt now and then =)
02:41:42 <RayNbow> :)
02:54:27 * hackagebot parallel 3.1.0.0 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.1.0.0 (SimonMarlow)
02:55:20 <roboshibby> hey guys, does haskell have atomic state operations built in? like a file system has read/write, load/store, etc
02:55:34 <Zao> In what context?
02:55:36 <ivanm> not sure
02:55:54 <Zao> Atomic memory access? STM? Filesystem transactions?
02:56:50 * ivanm assumed roboshibby meant the latter, especially when considering what the ext4 devs were saying at one point about how everyone gets that wrong...
02:57:11 <roboshibby> what did i get wrong?
02:57:13 <roboshibby> i want to learn
02:57:19 <Zao> If you're on a decent Windows version, you could FFI some transactional NTFS.
02:58:01 <ivanm> Zao: isn't "decent windows version" an oxymoron? :p
02:58:07 <ivanm> or do you mean "relatively decent"?
02:58:27 <Saizan> roboshibby: what do you mean by atomc state operations, precisely?
02:58:50 <roboshibby> like accessors in other languages
02:58:55 <roboshibby> load/store
02:58:59 <roboshibby> observe/set
02:59:09 <roboshibby> the basic state ops
02:59:14 <Saizan> so like thread-safe mutable variables?
02:59:14 <roboshibby> are there even any others? heh
02:59:24 <ivanm> roboshibby: still not following what you're talking about
02:59:29 <ivanm> do you mean for files?
02:59:30 <roboshibby> ugh
02:59:31 <roboshibby> no
02:59:35 <ivanm> do you mean the State monad?
02:59:36 <roboshibby> properties
02:59:36 <ivanm> ST?
02:59:40 <ivanm> what properties?
02:59:46 <roboshibby> what's the state monad?
02:59:49 <ivanm> are you talking about Java's "thread safe" stuff?
02:59:50 <roboshibby> what does it do?
02:59:50 <Zao> I did ask in what context, but you completely ignored the question.
02:59:53 <ivanm> @hoogle State
02:59:53 <lambdabot> module Control.Monad.State
02:59:53 <lambdabot> Test.HUnit.Base data State
02:59:53 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
03:00:01 <Zao> STM is one approach. MVars is another.
03:00:11 <roboshibby> stm is state machine?
03:00:12 <ivanm> Zao: he replied asking what he did wrong...
03:00:13 <Zao> (the former letting you extend atomicity to more than one entity)
03:00:21 <Zao> ivanm: To your statement, that is.
03:00:23 <ivanm> roboshibby: STM is Software Transactional Memory
03:00:27 <roboshibby> oh
03:00:28 <ivanm> Zao: oh, right
03:00:42 <ivanm> roboshibby: it's used to avoid locks when doing concurrency
03:00:50 <roboshibby> how does stm work? 
03:01:01 <ivanm> as in how to use it?
03:01:01 <Zao> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf <- this might be a good read.
03:01:04 <ivanm> or the nuts and bolts?
03:01:06 <ivanm> roboshibby: what do you mean by properties?
03:01:39 <Saizan> ivanm: i think properties are like OpenGL's StateVar or GTK's attributes
03:01:40 <Zao> «Beautiful Concurrency» by the glorious SPJ.
03:02:05 <ivanm> Zao: is that the one with the reindeer example?
03:02:08 <Saizan> i got that in print as a bonus with my gsoc :)
03:02:21 <handonson> Haskell has the bets atomic state operation system ever
03:02:25 <ivanm> Saizan: the beautiful code book?
03:02:25 <handonson> best*
03:02:25 <mornfall> Boooh. :( Haddock hates me.
03:02:26 <Saizan> yeah, santa claus and the elves too
03:02:29 <Saizan> ivanm: yup
03:02:31 <ivanm> mornfall: in what sense?
03:03:41 <mornfall> ivanm: I can't figure out how to document GADT ctors.
03:03:42 <Zao> ivanm: Yeah.
03:03:56 <ivanm> mornfall: -- ^ ... ?
03:04:03 <mornfall> ivanm: Parse error.
03:04:10 <ivanm> ugh
03:04:12 <mornfall> Same as with -- |.
03:04:29 <Saizan> tsk, gadts should be self-documenting
03:04:48 <Saizan> i'm sure that's the reason why ;)
03:04:56 <ivanm> mornfall: sure it's not the actual comment that's got a problem?
03:04:57 <mornfall> I *could* use the plain syntax I guess.
03:05:18 <mornfall> ivanm:     parse error on input `-- | Foo.'
03:05:24 <ivanm> ugh :s
03:06:27 <mornfall> It's just an existential, so I can use the old syntax. Whatever...
03:08:05 <mornfall> Hm. If I remember how to do that...
03:08:45 <mornfall> I am now getting ambiguous types. :o
03:09:43 <mornfall> Ok got it.
03:10:32 * zygoloid has a working out-of-process vacuum: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27819
03:12:30 <Saizan> :O
03:13:06 <Saizan> how out-of-process?
03:13:06 <ivanm> *sigh* when I do @v `'insert'` c@ for haddock markup, it links to insert but uses straight quotes...
03:13:31 <zygoloid> Saizan: that was extracted from a completely separate process, via ptrace.
03:13:38 <zygoloid> (same machine though...)
03:13:41 <ivanm> hang on, even if I just do `insert` it links to insert without putting in the angled quotes...
03:14:24 <zygoloid> i've not implemented GHC version sniffing yet, so the attaching process needs to specify the GHC way of the debugee
03:14:31 <ivanm> I have to do @\`'insert``@ to get them to come out right... is that a bug?
03:14:37 <ivanm> preflex: seen waern
03:14:37 <preflex>  waern was last seen on #haskell 62 days, 12 hours, 49 minutes and 53 seconds ago, saying: I guess we have to actually have download and run it! ;-)
03:15:30 <zygoloid> Saizan: that's an extract of the output from this code: runProcessT pid . runStructT way $ heapRoots >>= mapM heapTree
03:16:23 <zygoloid> next step: findMySpaceLeak :)
03:16:52 <Saizan> eheh
03:17:16 <Saizan> no pointers for the IND_direct inside the THUNK though
03:17:40 <zygoloid> Saizan: that's because they're back-references
03:18:05 <zygoloid> that's a heap trace from a zipWith-style fibs
03:19:00 <zygoloid> ivanm: did your saying *sigh* cause sigh to quit? ;)
03:19:59 * Saizan is not sure what the role of the "$N" is
03:20:31 <ivanm> zygoloid: heh
03:20:45 <zygoloid> Saizan: that's just to identify back-references. so the $462 at the bottom is the same heap object as the $462 higher up
03:21:01 <Quaffe> Are there any tools to help reading the profile output of +RTS -p?
03:21:29 <ivanm> Quaffe: there's prof2dot
03:21:37 <ivanm> but you have to run it with a different flag, not -p
03:21:44 <ivanm> otherwise... what's so hard to read about it? ;-)
03:21:50 <Saizan> zygoloid: yeah, it just seems a bit overloaded, in the first case it's to identify a node, in the latter case it's to reference, but they are put in the same position
03:21:58 * ivanm feels that a text editor or a pager is a sufficient tool to read the output of +RTS -p
03:22:01 <zygoloid> Quaffe: there's hp2ps, but i'm not sure what RTS flags you need there
03:22:20 <ivanm> ketil: oh good, I'm not the only one who wasn't satisfied with the survey questions
03:22:29 <ivanm> *the available answers to the survey questions
03:22:38 <zygoloid> Saizan: yeah, that's a fair point. the text output was a quick hack :)
03:22:44 <Quaffe> ivanm: with a big list of functions I lose track of the indent level
03:23:31 <ketil> ivanm, :-)
03:24:38 <zygoloid> Saizan: i think i'll change the backreferences to something like "~> $462" when i get home.
03:25:10 <zygoloid> (also, recognising certain constructors like C#, I# and S# and pretty-printing their values would be nice)
03:26:06 <ksf> either noone has been crazy enough to attempt this, or everybody who did failed.
03:26:22 <Payne> hi to all
03:26:41 <Payne> I just started learning haskell and I have some questions
03:27:03 <Payne> so if anybody can help i will be really happy
03:27:19 <zygoloid> i think i could get it to print that as: [0,1,1,2,3,5,8,13,21] ++ $1:$2:$3 where $3 = s23u plusInteger $1 $2
03:27:34 <yairchu> Payne: anything specific?
03:27:37 <zygoloid> or something like that
03:27:39 <ksf> @faq can Haskell make Payne happy?
03:27:40 <lambdabot> The answer is: Yes! Haskell can do that.
03:27:59 <Payne> why does the expression -3 * 5 work but if I changes the argument order, it does not work
03:28:08 <Payne> and I must add parenthesis
03:28:08 <zygoloid> Payne: that's a bug in the haskell standard
03:28:13 <quicksilver> because minus is odd.
03:28:21 <quicksilver> it's quite annoying.
03:28:22 <Saizan> zygoloid: i wouldn't bother with the ++, since there's no (++) thunk there, or is it?
03:28:22 <Payne> hm
03:28:44 <ksf> other people say it's a feature of the haskell standard.
03:28:50 <ksf> in any case, unary minus is a hack
03:29:00 <Payne> same with function calls
03:29:06 <zygoloid> Saizan: no, fair enough. in the case of a fully-forced list i'd like to use [a,b,c,...] notation (and likewise i'd like to use "..." for [Char])
03:29:13 <Payne> and the operators are in fact function calls, right?
03:29:21 <Payne> so the minus is also the function call?
03:29:22 <quicksilver> Payne: well with function calls it's consistent
03:29:25 <zygoloid> but you're right, using ++ for a partially-forced list would be confusing
03:29:29 <quicksilver> > sin 3 * 5
03:29:30 <lambdabot>   0.7056000402993361
03:29:32 <quicksilver> > 5 * sin 3
03:29:33 <lambdabot>   0.7056000402993361
03:29:45 <quicksilver> Payne: no problem there - at least it's consisetent both ways around.
03:30:03 <zygoloid> http://hackage.haskell.org/trac/haskell-prime/wiki/NegationBindsTightly
03:30:09 <ksf> - 3 *  5 should be parsed as -(3 * 5)
03:30:29 <Payne> hm
03:30:37 <ksf> and in the 3 * -5 case the lexer is confused by two consecutive operators
03:30:51 <Payne> thanks
03:31:05 <Payne> and there is another problem with function calls
03:31:07 <Saizan> operators are functions semantically, but follow quite different parsing rules
03:31:22 <Payne> if I write add 3 5 it works
03:31:32 <Payne> but if I write add 3 add 3 5
03:31:37 <Payne> it does not
03:31:43 <Payne> and I must add parenthesis
03:31:47 <Saizan> you've to write add 3 (add 3 5)
03:31:47 <quicksilver> yes.
03:31:55 <ksf> ...because you're passing four arguments to the first add, in that case.
03:31:56 <ivanm> Payne: that's parsed as (add 3 add) 3 5
03:31:58 <quicksilver> add 5 add 3 5 is giving the first 'add' four arguments.
03:31:59 <ivanm> which doesn't make sense
03:32:10 <ivanm> > let add = (+) in add 3 $ add 3 5
03:32:10 <lambdabot>   11
03:32:36 <zygoloid> Saizan: what do you think of this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27819#a27839
03:32:38 <Saizan> > let add = (+) in add 3 add 3 5
03:32:39 <lambdabot>   11
03:32:58 <vanadium> > let add a _ b c = a + b + c in add 5 add 3 5
03:32:59 <lambdabot>   13
03:33:24 <Payne> thanks for explaining
03:33:25 <zygoloid> (I've put plusInteger in <> because it's in the SRT rather than in the closure -- i'm not sure if that's a good idea)
03:33:38 <quicksilver> Saizan: that's really confusing :)
03:33:44 <Payne> and the let I do not know, I am really haskell learner
03:34:26 <Saizan> zygoloid: that looks like it's summing the cons cells but i'm not sure what s23u does, however i very much like the general idea
03:34:35 <Payne> and the expression add 3 5 add 3 5
03:34:54 <Payne> dont work because it calls 2 functions and does not know wha t to do with results?
03:35:15 <Payne> or it does not call anything?
03:35:17 <Saizan> that's still giving 5 parameters to the first add function
03:35:18 <ivanm> Payne: "let ... in ..." is just a way of defining extra variables/functions to be used (the where block notation is syntactic sugar for let blocks)
03:35:33 <zygoloid> Saizan: yeah, the "what s23u does" bit is the key, and that's hard to tell from the binary. i'll be adding disassembly soon, but i'm not sure that's enough
03:35:34 <jedai> it try to apply (add 3 5) to add
03:36:00 <jedai> Payne: function application (the whitespace) is left associative
03:36:05 <Saizan> zygoloid: make sense then :)
03:36:10 <Saizan> zygoloid: *makes
03:36:19 <zygoloid> i'd like to get ghc to emit debug symbols when compiled in a 'debug' way at some point
03:36:29 <jedai> Payne: that is "f g x" means "(f g) x", not "f (g x)"
03:36:50 <zygoloid> Saizan: great, thanks for the feedback.
03:37:14 <Saizan> zygoloid: np :)
03:37:27 <jedai> Payne: "add 3 5" means "(add 3) 5" which works like that : "add 3" is a function that add 3 to its argument
03:38:02 <Payne> hm
03:38:05 <Payne> interesting
03:38:19 <jedai> Payne: All function in Haskell really have only one argument, but sometimes they returns functions, so you get the "illusion" that they take several argument
03:38:21 <Saizan> Payne: if you want to show the results of two separate expressions at once you can put them in a tuple
03:38:25 <Saizan> e.g.
03:38:31 <Saizan> > (3+5, 3+5)
03:38:32 <lambdabot>   (8,8)
03:39:03 <Payne> and what compiler do you use? I found a GHC. is it good?
03:39:29 <zygoloid> Payne: yes, GHC is very good.
03:39:47 <jedai> Payne: add type is "Int -> Int -> Int" but (->) is right-associative so the explicit type is really "Int -> (Int -> Int)" that is "a function that takes an Int and returns a function that takes an Int and returns an Int"
03:40:01 <ksf> ghc is the de-facto standard
03:40:17 <jedai> Payne: GHC is the best Haskell compiler right now and likely to stay so for years
03:40:28 <zygoloid> all the other haskell compilers are currently targeting a niche to some extent (be it beginners, whole-program optimization or whatever else)
03:40:45 <Payne> as well as do you know the book Learn You a Haskell for Great Good?
03:41:03 <Payne> because I found this book and it looks really interesting
03:41:10 <quicksilver> it's great fun
03:41:19 <zygoloid> yeah, BONUS has done a great job there
03:41:23 <quicksilver> although the tone probably annoys some people
03:41:38 <Payne> yes I just started but I really like the style
03:41:50 <jedai> Well it's better that a drone that put everyone to sleep ;)
03:42:34 <Payne> ok thanks for responses, I will try to dive into Haskell
03:43:00 <Payne> and the true is that haskell is not really used in companies, right?
03:43:18 <Payne> I mean real jobs as programmers in Haskell
03:43:42 <Saizan> well, there are quite a few people around here who have haskell jobs :)
03:44:26 <zygoloid> Payne: as a proportion of software jobs in the world, the number of haskell jobs is very small
03:44:48 <zygoloid> as a proportion of lazy functional programming jobs it's a lot higher :)
03:46:00 * Saizan feels sad for the clean guys
03:46:13 <zygoloid> it has a fair amount of traction in financial institutions. i've only talked to two investment banks about jobs, but they both use haskell
03:46:52 <Payne> ok I just want to ask, because I am exprerienced Java Programmer and I want to use some scripting language for the Java Platform and there are many parts from functional paradigm
03:46:55 * ksf doesn't.
03:47:02 <ksf> they should get their license and everything straight.
03:47:10 <Payne> and we learned Haskell in school
03:47:13 <Payne> but you know
03:47:15 <ksf> and they seem to concentrate way too much on windows.
03:47:31 <ksf> you can't push a language by concentrating on windows when you're not microsoft.
03:47:39 <Payne> right after procedural it looks very strange so I really dont get it
03:47:55 <zygoloid> Payne: yeah, it's a very different mindset
03:48:07 <ksf> everything's a view pattern?
03:48:45 <ksf> I'm not really firm in the pattern terminology, but there's stuff to be found there that relates to functional languages.
03:49:42 <ketil> Anybody know the current best practice for packaging .debs from .cabals?
03:52:38 <fasta> ketil, are you the guy who did the survey recently?
03:52:56 <ivanm> fasta: he responded to the query about the survey...
03:53:19 <fasta> ivanm, ah, right. 
03:53:29 <fasta> ketil, please ignore. 
03:53:41 <ivanm> ketil: srcinst?
03:53:47 <ivanm> (on hackage)
03:55:38 <Payne> any way to clear the console when I use GHC?
03:55:51 <Payne> because I test expressions and there are too much text now
03:58:24 <ivanm> within ghci?
03:58:29 <ivanm> don't think so
03:58:44 <fasta> Payne, if you run it in Emacs you can configure the number of lines to remember.
03:59:00 <ivanm> but then you lose tab-completion :(
03:59:04 * hackagebot regex-posix 0.94.4 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-posix-0.94.4 (ChrisKuklewicz)
03:59:16 <fasta> Payne, (since a lot of people run it in Emacs, nobody implements these kinds of features)
03:59:35 <fasta> ivanm, yes (the age old "the tools are really bad"-story)
04:00:03 <ivanm> fasta: well, I'd say it's more a toss-up between which functionality you prefer
04:00:25 * ivanm didn't actually realise you could do tab-completion in ghci for a couple of years after he started learning Haskell because he always used haskell-mode in emacs
04:00:33 <fasta> ivanm, it is perfectly possible to implement both in Emacs, but nobody cares enough. 
04:00:41 <ivanm> yeah
04:00:43 <fasta> ivanm, it wasn't possible for some years.
04:00:49 <Zao> sequence_ $ replicate 100 $ putStrLn ""
04:00:52 <ivanm> actually, I think some people have tried, but couldn't work out how
04:01:00 <Zao> Poor man's clear :D
04:01:07 <ivanm> Zao: lol
04:01:12 <Twey> sequence_ . replicate = replicateM_
04:01:22 <fasta> Zao, a good compiler will fix that. 
04:01:45 <ivanm> Zao: heh, put :clear replicateM_ 100 $ putStrLn ""' in your ~/.ghci ;-)
04:01:45 <fasta> Zao, not that we have such a compiler, but those are details. 
04:01:58 <Twey> But ‘putStrLn $ replicate 100 '\n'’ is more efficient.
04:02:36 <ivanm> well, it looks like the fix for regex-posix for that bug found by altmattr has been implemented
04:19:25 <ketil> ivanm: re srcinst, it will generate a binary .deb for my distribution, but no src debs to build binary debs for other distros, right?
04:19:37 <ketil> ivanm, any experience with it?
04:19:40 <ivanm> no idea... I use Gentoo ;-)
04:20:03 <ketil> Ah.  The penguin that swallowed a pufferfish-logo.
04:20:14 <ivanm> I just looked for "debian" and "apt" ;-)
04:20:21 <ivanm> ketil: huh?
04:20:37 <ivanm> our logo is a sexually confused bovine...
04:20:43 <ivanm> or else a stylised "g"
04:20:46 <ketil> re the gentooish linux logo, no?
04:21:14 <ivanm> this is a stylised "g": http://en.wikipedia.org/wiki/File:Gentoo_Linux_logo_matte.svg
04:21:29 <quicksilver> clear a left-handed pacman
04:21:35 <ivanm> Gentoo/OpenBSD might have its own logo...
04:21:41 <ivanm> quicksilver: you mean "clearly"?
04:21:54 <ketil> There was some debate on web design, the linux logo was the cross-eyed version, and I thought it came from gentoo.
04:22:02 * ketil is probably just confused.
04:22:09 <ivanm> yes, you are ;-)
04:22:14 <ketil> Although not so much sexually.
04:22:21 <ketil> nor bovinely.
04:22:31 <ivanm> well, the gentoo mascot is Larry the cow...
04:22:40 <ivanm> hence the sexual/gender confusion
04:23:17 <ksf> http://en.wikipedia.org/wiki/Gentoo_penguin
04:23:50 <eevar2> http://www.youtube.com/watch?v=FavUpD_IjVY -- more bovine
04:23:51 <ksf> "They are the fastest underwater swimming penguins, reaching speeds of 36 km/h[6]  . Gentoo are built for very harsh cold climates."
04:24:17 <ivanm> hence why the name "Gentoo" was chosen for the distribution
04:24:32 <vanadium> ksf: otoh gentoo is mostly useful for warming up those climates 8)
04:24:41 <ksf> yeah. ricers, all of them
04:24:46 <ksf> ...except me.
04:24:46 <ketil> ivanm, Ah.  It's the gentoo *users* who are cross-eyed, not their logo.  My mistake.
04:25:03 <ketil> (your reply to Miguel Mitrofanov)
04:25:03 <ivanm> ketil: ???
04:25:13 <ivanm> which reply?
04:25:26 <ketil> Message-ID: <87y6d9d4vo.fsf@gmail.com>
04:25:28 <vanadium> *goes away to dutifully emerge --sync/world*
04:26:29 <ivanm> ahhh, right
04:27:00 <ketil> Anyway, I can see Gentoo penguins from my office window.
04:27:05 * ivanm has already "paludis -s"d, and will rebuild overnight
04:27:13 <ivanm> ketil: you work in antartica?
04:27:16 <ivanm> or near a zoo?
04:27:33 <ketil> The latter (no surprise)
04:28:03 <ivanm> well, just checking...
04:28:32 * ivanm only found out that Cale was working for iPwn the other day; could have missed the news that ketil was on a research expedition to see if FP works better in Antartica or something...
04:28:43 <Twey> iPwn hired Cale?!
04:28:52 <ketil> http://malde.org/~ketil/penguins.jpg
04:28:57 <ivanm> Twey: yes
04:29:02 <Twey> Wow!
04:29:09 <Twey> That company really needs a better name.
04:29:16 <ivanm> agreed
04:29:48 <ketil> It's more important to have good people. :-)
04:30:06 <Twey> I find it hard to take it seriously, yet it's snapping up all the best Haskellers left, right, and centre.
04:30:15 <ketil> The picture is from my office view, btw.
04:30:17 <Tomsik> Is it some kind of a creepy-looking bearded man feeding penguins?
04:30:23 <Twey> ketil: Nice
04:30:39 <Twey> How can you tell he's creepy-looking?  He's facing away from the camera.
04:30:57 <Tomsik> He's got a beard.
04:30:58 <ivanm> ketil: I guessed that
04:30:58 <ketil> Twey, the downside is that they have this show with a lot of awful music twice a day.  Drives me nuts.
04:31:14 * ivanm writes a note to make sure Tomsik never sees a photo of him...
04:31:32 <Twey> ketil: Triple-glazing?
04:31:35 <ketil> Of course, he'll probably report me as a possible terrorist, seeing as I'm taking pictures and stuff.
04:31:41 <Twey> Haha.
04:31:44 <quicksilver> Cale works for iPwn? Excellent.
04:31:56 <Tomsik> It might be very wrong on my side, but that guy reminded me of one of Jon Lajoe things
04:32:04 <quicksilver> I always suspected that RyanT5000 was no man, but some assimilating robot from the future.
04:32:07 <ketil> Twey: Triple-glazing?
04:32:35 <ketil> Ah - sound proof windows?
04:32:52 <Twey> They also need a better website.  Sometimes I forget how awful it is.
04:33:01 <ketil> My preferred option is head phones, or just slacking on IRC until they shut up.
04:33:09 <Twey> ketil: Fair enough.
04:33:50 <quicksilver> Twey: why do they need a better website? How would that help achieve their objectives?
04:41:00 <Twey> quicksilver: For a start, it would allow people to read their site.
04:41:31 <Twey> quicksilver: It would also help them move away from the image of a game company consisting of one thirteen-year-old who just learnt Java.
04:42:28 <quicksilver> Twey: I can read their site. And that is not the image it projects to me. And if it did, who would care?
04:42:44 <quicksilver> young software houses don't have an image. They have an unfinished product.
04:42:51 <quicksilver> They should devote all their energies to the product.
04:43:00 <quicksilver> the website only matter at all when it becomes part of the marketing effort.
04:43:21 <Twey> Not to say that the product is less important, but if you're going to invest effort into a website anyway…
04:53:45 <Saizan> iPwn hiring made the rate of C++ rantings decline.
04:55:43 <quicksilver> surely not by giving cale a job? he's not a ranter.
04:57:10 * benmachine googles ipwn and finds ipwn.co.uk, that consists of <html><head><title>iPwn</title></head><body bgcolor="#000000"></table></body></html>
04:57:15 <Saizan> yeah, not cale :)
04:57:18 * benmachine blinks
04:57:21 <Phyx-> lol
04:57:57 * Saizan removes the blink tag from benmachine 
04:58:01 <benmachine> oh right, ipwnstudios.com
04:58:06 <Phyx-> they're too busy coding to make the site
04:58:21 * quicksilver traps Saizan in a <MARQUEE> and runs away.
04:58:42 <benmachine> oh right, ipwn is the one who thinks apple won't care enough to kick them off the iphone
04:58:47 * Saizan googles what a <marquee> is
04:59:26 <quicksilver> apple haven't bothered to kick off various other similar game development setups. Past performance is no guarantee of future returns, though.
04:59:30 <Phyx-> lool
04:59:40 * Phyx- sees Saizan scrolling off
04:59:48 <Saizan> oh my god.
05:01:19 * Phyx- adds a <shadow> too Saizan to complete it
05:01:36 <Phyx-> to*
05:01:41 <benmachine> quicksilver: yeah, I didn't mean to imply I thought they were wrong
05:02:19 * Saizan feels like he's back into 1996, but not any younger
05:02:32 <benmachine> @remember Saizan * Saizan googles what a <marquee> is \ <Saizan> oh my god.
05:02:33 <lambdabot> I will remember.
05:03:32 <nominolo> preflex: seen chrisdone
05:03:33 <preflex>  chrisdone was last seen on #haskell 16 hours, 19 minutes and 43 seconds ago, saying: jmcarthur: ok. maybe we could pick a date to try it
05:03:45 <Phyx-> Saizan: just put on the hip pants, it'll all come back
05:05:23 <Saizan> http://5magazine.files.wordpress.com/2009/11/keyboard-pants-21.jpg <- i should stop googling things.
05:06:07 <quicksilver> that's a motto to live by, Saizan.
05:06:23 <quicksilver> Possibly one to die by, too. "RIP Saizan. He should have stopped googling things."
05:06:28 <Phyx-> that looks... impracticle
05:06:36 <Phyx-> you'd be hitting your crotch too much
05:06:50 <arcatan> Saizan: does that actully work?
05:07:27 <Saizan> arcatan: let me google the answer to that.. oh wait.
05:07:28 <Phyx-> impractical*
05:09:52 * Phyx- hugs undefined
05:10:08 <Phyx-> best thing since unsafePerformIO :P
05:10:09 * Phyx- runs
05:10:39 <Deewiant> unsafePerformIO undefined -- even better
05:10:51 <Phyx-> that would end the world
05:11:04 <Deewiant> Best not run it
05:11:30 <Phyx-> RealWorld# thanks you :P
05:12:11 <Tomsik> Why is it RealWorld and not RealLife, would be kind of more realistic
05:12:28 <opqdonut> it could be TheMatrix too
05:12:48 <Tomsik> DoNotEnter :p
05:12:49 <Phyx-> because we all know programmers have no LIfe
05:12:54 <Phyx-> it would have been a lie
05:13:02 <Phyx-> the RealLife is a lie!
05:13:11 <Tomsik> RealLie more like
05:13:29 <arcatan> RealLifie is a Lie group!
05:13:39 <Tomsik> Oh my! It has limits!
05:14:04 <Phyx-> yes, around 80years on average
05:14:29 <handonson> how do you write a parser that give you everything until the endOfInput in Attoparsec
05:14:36 <handonson> gives*
05:16:12 <handonson> { many anyWord8 } would work, but i want a ByteString, and it doesn't seem to be a good choice to generate a [Word8] and pack it into ByteString again
05:16:30 <handonson> it will cause unnecessary overhead, i think
05:18:04 <Deewiant> If you want a strict bytestring that's probably the best you can do; the alternative is to cons, which is O(n) for each cons
05:18:06 <quicksilver> handonson: takeWhile (const True) ?
05:18:52 <handonson> quicksilver: wouldn't that try to (unnecessarily) uncons every time
05:19:00 <quicksilver> (I just looked through http://hackage.haskell.org/packages/archive/attoparsec/0.8.0.2/doc/html/Data-Attoparsec-Char8.html for things which had return type ByteString)
05:19:10 <quicksilver> I doubt it. Laziness is your friend.
05:20:36 <handonson> well it'd be perfect if laziness works there for me
05:20:52 <arcatan> hmm, #haskell has been quite blahhy recently. i nearly told you to move the attoparsec discussion over to #haskell.
05:20:56 <quicksilver> it uses Bytestring.span
05:21:06 <quicksilver> which is zero-copy.
05:21:11 <quicksilver> so I believe it is the right answer.
05:21:45 <Tomsik> it seems to me that #haskell and #haskell-blah are two almost parallel channels, but I'm kinda new here
05:22:50 <handonson> then i got lucky
05:22:54 <quicksilver> well their contracts are quite different.
05:22:55 <handonson> quicksilver: thanks
05:23:10 <zygoloid> Tomsik: #haskell is supposed to contain talk about haskell. #haskell-blah is supposed to contain the universe of discourse minus talk about haskell.
05:23:19 <quicksilver> but generally off-topic chatter here is OK as long as it's not impeding ontopic discussion
05:23:28 <quicksilver> if it is, you'll be asked to take it to another channel.
05:23:48 <quicksilver> it's quiet at the moment, probably due to summer.
05:23:50 <Phyx-> time to go spelunking again
05:23:51 <ivanm> Tomsik: then there's #haskell-overflow, #haskell-in-depth, etc. ;-)
05:24:04 <ivanm> quicksilver: huh? the cold outside doesn't say "summer" to me... :p
05:24:13 * Phyx- puts on his hardhat and lambda trousers and jumps head first in ghc-src
05:24:13 <zygoloid> -overflow versus -in-depth is i think an unclear distinction
05:24:38 <ivanm> zygoloid: overflow is if there are too many concurrent discussions going here, someone might want to move there to help distinguish what's what
05:24:54 <ivanm> -in-depth is meant to discuss the zygohistoric morphness of monads, etc. :p
05:25:09 <Phyx-> with no tutorials!
05:25:11 <Phyx-> 14:24:14 -!- Topic for #haskell-in-depth: Haskell in depth - slower paced discussion of use, theory, implementation etc with no monad tutorials!
05:25:11 <aristid> clearly we also need #haskell-in-depth-overflow and #haskell-blah-in-depth
05:25:14 <Phyx-> lol
05:25:18 <ivanm> Phyx-: no _monad_ tutorials
05:25:24 <ivanm> arrow tutorials are allowed
05:25:29 <Phyx-> lol!
05:25:43 <quicksilver> ivanm: due to summer in most of the civilized nations who participate here ;)
05:26:04 <Phyx-> there are still civilized nations left in this world?
05:26:37 * Phyx- wonders why, more and more of his search terms on google end up with google showing him someone's butt on the homepage
05:26:55 <handonson> do we have something like Read/Show classes for ByteStrings? or is that what Data.Binary is for?
05:27:50 <Tomsik> Honestly, what's the use of arrows? It seems rather marginal to me
05:28:15 <zygoloid> ivanm: why would people move to -in-depth if there were not too many concurrent discussions here, though?
05:28:38 <zygoloid> (that is, why take something on-topic off-channel if the channel is otherwise quiet?)
05:29:38 * Phyx- doesn't feel like coding today
05:30:02 <dibblego> Tomsik, to abstract both (->) and Kleisli m of course!
05:30:16 <quicksilver> handonson: probably that's what Binary is for, although there are flaws in that approach.
05:30:43 <benmachine> quicksilver: which flaws did you have in mind?
05:31:40 <Tomsik_> whoops, disconnected
05:31:42 <Tomsik_> <Tomsik> Honestly, what's the use of arrows? It seems rather marginal to me
05:31:48 <quicksilver> benmachine: no support for versioning, and being trapped with typeclasses
05:31:51 <ivanm> zygoloid: *shrug*
05:32:09 <ivanm> dibblego: I forget; what's the point of Kleisli?
05:32:15 <ivanm> Tomsik_: <dibblego> Tomsik, to abstract both (->) and Kleisli m of course!
05:32:22 <dibblego> to wrap a -> m b of course!
05:32:36 <ivanm> hmmm.....
05:32:39 <quicksilver> arrows don't feel very useful because there aren't many generally useful combinators on them.
05:32:42 <ivanm> can you provide an example?
05:32:45 <quicksilver> kleisli composition is pretty useful.
05:32:52 <quicksilver> which is why we have that anyway, unwrapped, as >=>
05:33:01 <ivanm> quicksilver: I find first, second, *** and &&& pretty useful on the (->) arrow...
05:33:05 <dibblego> ivanm, it's a bit sarcastic, but a -> m b (and therefore Kleisli m a b) pops up pretty often
05:33:23 <quicksilver> yes, but really you find them useful more as tuple combinators
05:33:29 <quicksilver> than anything they have to do with arrows.
05:33:30 <ivanm> yeah
05:33:45 <quicksilver> so, arrows have a 'point' when you're using the more fiddly combinators - like arrow notation.
05:33:54 <quicksilver> I'd never used arrow notation, although it has its adherents.
05:34:12 <quicksilver> I've used arrows for transformation/extracting - but never used any general combinators
05:34:20 <quicksilver> in fact, I didn't even bother to write the Arrow instance
05:34:30 <quicksilver> (the Applicative instance was more useful)
05:34:42 <dibblego> for what type constructor?
05:35:20 <quicksilver> mostly a -> [b]
05:35:40 <quicksilver> sometimes a -> Either Error [b]
05:35:48 <dibblego> I was using a -> EitherT ...
05:36:04 <dibblego> I shan't finish my story
05:36:26 <ivanm> dibblego: oh, I thought you were a bit Kleisli user (I seem to recall you saying you used them in scala as well)
05:37:10 <dibblego> ivanm, I am, but not necessarily explicitly (in Scala, I do, but only as an implication of Scala being kludgy)
05:37:19 <ivanm> aha
05:37:26 <quicksilver> almost all haskell users use kleisli morphisms a lot
05:37:33 <quicksilver> like, for example, putStrLn
05:37:39 <dibblego> I often prefer (>=>) to (>>=)
05:37:48 <quicksilver> but you don't need to use the arrow instance
05:37:50 <quicksilver> quite.
05:38:02 <quicksilver> :t getLine >=> putStrLn
05:38:03 <lambdabot>     Couldn't match expected type `a -> m b'
05:38:03 <lambdabot>            against inferred type `IO String'
05:38:03 <lambdabot>     In the first argument of `(>=>)', namely `getLine'
05:38:06 <benmachine> I seem to vaguely recall using arrows with Kleisli once
05:38:09 * quicksilver laughs
05:38:21 <quicksilver> :t (\_ -> getLine) >=> putStrLn
05:38:22 <lambdabot> forall a. a -> IO ()
05:38:24 <quicksilver> rather.
05:38:34 <benmachine> because I had two a -> Maybe b but I wanted a Maybe (b, b)
05:38:42 <benmachine> but then I realised I didn't have to after all, I think
05:38:53 <RayNbow> :t const getLine >=> putStrLn
05:38:53 <lambdabot> forall a. a -> IO ()
05:39:12 <benmachine> :t flip replicateM getLine >=> mapM_ putStrLn
05:39:13 <lambdabot> Int -> IO ()
05:42:18 <roboshibby> hey guys, can anyone offer a succinct 2 sentence explanation of what programming in Haskell is like?
05:42:32 <roboshibby> like a high level expression of how programming in Haskell is done
05:42:48 <dibblego> efficiently and without error
05:43:20 <roboshibby> sounds interesting. can you give a description more descriptive of the actual process of programming in it?
05:43:34 <Tomsik_> robertmassaioli: you write functions like in math with recursion, that's the basic idea
05:43:46 <Tomsik_> but the standard library supplies a lot of useful functions
05:43:59 <Tomsik_> which make code very, very compact
05:44:06 <Tomsik_> and type system is like heaven
05:44:18 <Tomsik_> catches 90% of bugs
05:45:19 <roboshibby> what's type system like?
05:45:35 <dibblego> heaven, exactly like heaven, surely you've visited?
05:45:48 <dibblego> why don't you try it mate?
05:46:12 <benmachine> I think the big thing about haskell coding is composability, you make lots of little bits that you know are right and then you glue them together to make big bits
05:48:15 <roboshibby> benmachine: how can you glue things together when return values are all different types and stuff?
05:48:59 <benmachine> roboshibby: I mean in a vague sense :P like if you have a function Char -> Bool and a function Bool -> Int, it's easy to make a function Char -> Int
05:49:17 <benmachine> roboshibby: and if you have twenty functions String -> String, it's easy to make one function that applies them all in turn
05:50:41 <dibblego> roboshibby, consider how you might (try to) glue things together when functions don't return a value at all! (void)
05:51:01 <roboshibby> shared instance variable?
05:51:02 <EvanR> not actually functions
05:51:11 <Tomsik_> roboshibby: there's operator '.', which works exactly like composition in math
05:51:21 <roboshibby> i dont know math
05:51:41 <Tomsik_> Um, composition of functions is a basic concept I thought
05:51:46 <dibblego> roboshibby, shared variables have adverse implications for the ability to "glue together"
05:51:56 <Tomsik_> like (f . g) (x) is f(g(x))
05:52:01 <benmachine> Tomsik_: fairly basic and yet it's quite possible to get as far as university without knowing it, I think
05:52:03 <ivanm> Tomsik_: not quite basic; IIRC it isn't taught in basic maths here even in high school
05:52:12 <ivanm> benmachine: yup
05:52:46 <ivanm> it's basic in the "I use maths to do stuff" sense, rather than "I need enough math to be able to tell how much I've overdrawn my credit card" sense
05:53:07 <Tomsik_> Well, I was in one of better high schools so we even had bits of power sets, countability etc. so I'm not sure what people have usually :p
05:53:45 <benmachine> roboshibby: with a shared variable if you want to run a function a bunch of times and collect all the results, you have to keep copying the value out, and you might get subtle mistakes if you do that wrong (especially with pointers)
05:53:54 <arcatan> probably varies between countries, too
05:54:04 <benmachine> roboshibby: with haskell it's easy to avoid that sort of mistake
05:54:22 <EvanR> mmm mvars
05:54:30 <roboshibby> ah ya 
05:54:34 <roboshibby> good point ben
05:54:57 <EvanR> let go of the 'store stuff in a variable' paradigm
05:55:18 <roboshibby> ?
05:55:33 <benmachine> roboshibby: basically, haskell makes it easy for you to know a lot about what's going on with a function without being able to see its source code
05:55:50 <Tomsik_> Why'd you want to store a value in variable if you can just use it without naming it 
05:55:54 <benmachine> because you know from the type signature that it can't do any IO or set some variable you don't know about
05:56:14 <benmachine> this makes it much easier to use other people's code without any nasty surprises
05:56:20 <EvanR> Tomsik_: you can name a value without storing it in a variable, in the sense of overwriting a register somewhere
05:56:21 <Tomsik_> There's no business with memory allocation and pointers too
05:56:33 <EvanR> let x = value in f x
05:56:46 <roboshibby> ben, sounds interesting
05:56:52 <roboshibby> what would hello world look like?
05:57:31 <benmachine> roboshibby: well, if a function does do IO its type signature must end in 'IO something'
05:57:50 <Tomsik_> helloworld is 
05:57:51 <dibblego> hello = print "hello world"
05:57:57 <benmachine> your program then does IO stuff by defining 'main' to be an IO something
05:57:57 <Tomsik_> main = putStr "hello world"
05:58:06 <Tomsik_> or something like that
05:58:11 <benmachine> and then 'main' does all the IO stuff that you wanted
05:58:19 <benmachine> yeah
05:58:33 <benmachine> main = putStrLn "hello world" -- because newlines are good for the soul
05:58:34 <handonson> hi, i'm a ByteString junkie
05:58:36 <handonson> {- hello.hs -}main = Data.ByteString.Char8.hPutStrLn System.IO.stdout $ Data.ByteString.UTF8.fromString "Hello, World!"
05:58:52 * benmachine pokes handonson in the eye
05:58:55 <Tomsik_> don't listen to handonson :p
05:58:58 <roboshibby> see i just dont understand what it means to program in haskell
05:59:03 <roboshibby> it doesn't even seem to have a syntax
05:59:13 <EvanR> dont worry about syntax
05:59:15 <benmachine> of course it has a syntax
05:59:19 <benmachine> it's just a slightly unusual one
05:59:26 <Tomsik_> It does have a lot of it! Like list comprehensions
05:59:31 <Tomsik_> which are highly useful
05:59:42 <benmachine> basically you are giving names to expressions, and then telling those expressions how to interact with each other
05:59:46 <Tomsik_> Like [2*n | n <- [1..10]] 
05:59:49 <aristid> handonson: how about using import qualified Data.Bytestring.Char8 as B?
05:59:54 <Tomsik_> > [2*n | n <- [1..10]] 
05:59:56 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
05:59:56 <EvanR> Tomsik_: i dont know about highly
06:00:12 <benmachine> I don't tend to use list comprehensions myself, but plenty of other people like them
06:00:15 <benmachine> so that's cool
06:00:21 <handonson> aristid: then you can't make out Data.ByteString and Data.ByteString.Char8 and Data.ByteString.UTF8
06:00:29 <Tomsik_> EvanR: depends on what you write of course 
06:00:40 <aristid> handonson: you can make different aliases for them :P
06:01:12 <roboshibby> man, it sounds tough
06:01:45 <Tomsik_> handonson is trying to scare you off
06:01:51 <Tomsik_> usually you don't do that
06:02:06 <handonson> what? I'm doing that RIGHT NOW in my code.
06:02:11 <handonson> no, i'm lying.
06:02:23 <benmachine> roboshibby: I think it's quite hard to start out with haskell, especially if you're used to other things, but once you're good at it you find that stuff that used to be hard in other languages is easy now
06:02:24 <handonson> you don't do anything tough in Haskell.
06:02:42 <benmachine> @quote the.impossible
06:02:43 <lambdabot> <autrijus> says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
06:03:20 <handonson> aristid: if I did, no one would have understood that code since people won't have any idea what those aliases really mean (not that people gave a damn to the current code)
06:03:20 * RayNbow once saw list comprehensions being used as a form of a guard
06:03:44 <RayNbow> (in Graham Hutton's code for the Count Down problem... somewhere he uses [n | n > 0] as a RHS expression)
06:04:10 <Botje> heh. that's cute
06:04:30 <benmachine> you need at least one feeder thing don't you?
06:04:35 <benmachine> like n <- return 5 or something
06:04:42 <quicksilver> > let n = 3 in [n | n > 0]
06:04:43 <lambdabot>   [3]
06:04:47 <benmachine> oh, right
06:04:52 <quicksilver> nope. Enclosing scope.
06:04:52 * benmachine shuts up
06:05:06 <quicksilver> and 0^0 = 1, etc ;)
06:05:09 <benmachine> heh
06:05:17 <RayNbow> > 0^0
06:05:18 <lambdabot>   1
06:05:26 <quicksilver> > let n = 3 in [n | n > 0, x <- []]
06:05:27 <lambdabot>   []
06:05:27 <Tomsik_> that's just sick, 0^0
06:05:29 <quicksilver> strange?
06:05:32 <quicksilver> x isn't mentioned.
06:05:36 <quicksilver> that's my point about 0^0.
06:05:57 <quicksilver> 0^1 is 0, obviously, but as I just demonstrated, list comps think that 0^0 is 1.
06:06:18 <RayNbow> quicksilver: while x isn't mentioned, the comprehension is still translated to something that maps over []
06:07:26 <quicksilver> RayNbow: I know what's happening.
06:07:43 <quicksilver> RayNbow: I was just demonstrating it to explain my apparently cryptic comment about 0^0
06:07:59 <RayNbow> oh right
06:12:39 <benmachine> @undo let n = 3 in [n | n > 0]
06:12:40 <lambdabot> let { n = 3} in if n > 0 then [n] else []
06:12:44 <benmachine> oh
06:13:44 <EvanR> roboshibby: haskell encourages, guides you to using good principles. even if you are not enterprising enough to use haskell in your projects or your job, you can apply these principles in other languages.
06:14:12 <roboshibby> yea i just dont even understand what haskell is
06:15:46 <Tomsik_> It's a programming language :p
06:16:07 <roboshibby> yea but like, the structure of programs, the organization, etc
06:16:09 <roboshibby> syntax
06:16:30 <mercury^> Probably you should learn you a haskell then.
06:16:32 <vanadium> You can define functions. You can also define records. Pretty vanilla stuff, really.
06:16:33 <EvanR> the structure of the program is a giant expression of type IO ()
06:16:40 <Tomsik_> It's a bit different, yeah
06:16:49 <Tomsik_> but after all it turns out to be great once you get used to this
06:17:04 <EvanR> made readable by giving names to lambda abstractions
06:17:34 <roboshibby> evanr, ok, hmm
06:17:45 <roboshibby> so how do you get started? what are some things you can do right away 
06:17:47 <Tomsik_> EvanR: maybe you're unaware, but "lambda abstractions" is not something that everyone knows of :p
06:18:01 <EvanR> cant hide the truth forever
06:18:01 <Tomsik_> robertmassaioli: you can run ghci, the interpreter
06:18:20 <Tomsik_> and get some tutorial, like learn you a haskell
06:18:21 <EvanR> most people probably dont get 'expression' either
06:18:39 <Tomsik_> EvanR: I hope you're kidding
06:18:44 <EvanR> ? : <- commonly known as the if statement in php ;)
06:19:28 <roboshibby> like 2 < 3 ? 1 : 0
06:19:30 <roboshibby> right?
06:19:57 <EvanR> yes, but its an expression, not a statement
06:19:57 <Tomsik_> php is a one huge walking horror
06:19:59 <EvanR> like this one
06:20:07 <EvanR> if (2 < 3) then 1 else 0
06:20:25 <EvanR> (thats haskell)
06:20:42 <aristid> > if 2 < 3 then 1 else 0
06:20:43 <lambdabot>   1
06:20:45 <Tomsik_> with explicit parenthesis
06:20:49 <EvanR> yes
06:21:03 <Tomsik_> fun fact is that you can never have too many of these
06:21:11 <Tomsik_> only it makes code harder to read
06:21:25 <handonson> what? attoparsec doesn't have <|>? what am I supposed to use then?
06:21:42 <Tomsik_> hackagebot: power of imaginaaaaAaaAAatioooooOOon!
06:22:10 <aristid> hackagebot: yes, you are a very unimaginative bot
06:22:55 <quicksilver> handonson: it does have <|>
06:23:02 <quicksilver> handonson: it comes from its Alternative instance
06:23:09 <DarkUnicorn> never heard someone mentioning " ? : " as "if statement" in php. it's usally called ternary operator
06:23:33 <Tomsik_> operator, bah
06:23:51 <Tomsik_> more like tetranary, it need an access to state of program too
06:23:57 <Tomsik_> and more like functional symbol
06:24:29 <handonson> i just realized that a <|> b <|> c <|> ... <|> n is same as choice [a, b, c, ..., d]
06:26:11 <quicksilver> handonson: yes.
06:27:07 <handonson> are they exactly the same?
06:27:13 <aristid> i think choice = foldr1 (<|>)
06:27:25 <handonson> like in terms of implementation
06:27:28 <Twey>  @src choice
06:27:30 <Twey> @src choice
06:27:30 <lambdabot> Source not found. It can only be attributed to human error.
06:27:37 <Twey> Hmph.
06:27:41 <Twey> But I'd imagine so.
06:27:57 <handonson> in attoparsec, it's
06:27:58 <handonson> choice = foldr (<|>) empty
06:28:07 <Twey> @let (y ?? n) p = if p then y else n
06:28:08 <lambdabot>  Defined.
06:28:17 <Twey> This is nicer.  ♥
06:28:28 <aristid> choice :: Alternative f => [f a] -> f a
06:28:28 <aristid> choice = foldr (<|>) empty
06:28:36 <aristid> handonson: that's the exact implementation
06:28:41 <aristid> in attoparsec
06:28:45 <handonson> aristid: just a little late
06:29:12 <aristid> handonson: phh
06:35:28 <EvanR-work> DarkUnicorn: you are giving the 'php community' a hell of a lot of credit
06:35:53 <EvanR-work> every other person in the channel genuinly doesnt know the difference
06:37:38 <EvanR-work> DarkUnicorn: or 'ternary statement' ;)
06:41:40 <ManateeLazyCat> How many "Micro Kernel" Operating System in this world?
06:42:21 <ivanm> quite a few
06:42:30 <ivanm> as for how many are seriously used... *shrug*
06:42:47 <ivanm> most mobile OSs are microkernel AFAIK, especially those based on the kernel from OKLabs
06:43:11 <ManateeLazyCat> ivanm: OKLabs? Link?
06:43:13 <DarkUnicorn> EvanR-work: i actually don't give them much credit, but i don't think they call it "if statement" :) maybe ternary statement, yes
06:43:39 <ManateeLazyCat> ivanm: http://www.ok-labs.com/ ?
06:44:11 <EvanR-work> DarkUnicorn: mainly i was talking about people not knowing what an expression is, and then i value added some extra ridicule for free
06:44:37 <ivanm> ManateeLazyCat: yup
06:44:52 <ivanm> ManateeLazyCat: they used Agda to prove the latest version of their kernel (which is not yet available)
06:45:13 <DarkUnicorn> EvanR-work: yeah, sorry about being nit-picking
06:45:32 <ManateeLazyCat> ivanm: I'm reading dons new paper, he said Linux kernel fixed many feature in it's static core. So i wonder have manay "micro kernel" OS in this world that support hot-swapping kernel by itself... :)
06:45:55 <roboshibby> smalltalk?
06:45:59 <ivanm> ManateeLazyCat: dunno; microkernels typically support hot-swapping drivers, etc. better
06:46:30 <ivanm> IIRC, the new windows kernel and the OSX kernel are microkernel based, but are more micro/macro-kernel hybrids
06:46:43 <ivanm> roboshibby: what about it?
06:47:03 <roboshibby> its vm supports hot swap i think
06:47:07 <roboshibby> run time
06:48:32 <ivanm> smalltalk is a language; we were talking about OSs
06:48:36 <ivanm> slight difference ;-)
06:49:46 <ManateeL`> ivanm: BTW, i think hs-plugins can fix my hot-swapping problem, just wait someone (or me) fix it. :)
06:52:06 <ivanm> cool
06:52:30 <ManateeL`> ivanm: You won't lost any gtk2hs state. :) 
06:53:11 <ManateeL`> ivanm: Don's new paper "Dynamic Extension of Typed Functional Languages" is awesome, you should read it. :)
06:54:37 <quicksilver> new paper?
06:54:40 <quicksilver> ManateeL`: link?
06:54:50 <ManateeL`> quicksilver: Wait.
06:55:21 <ManateeL`> quicksilver: http://www.cse.unsw.edu.au/~dons/papers/dons-phd-thesis.pdf
06:55:37 <quicksilver> ah, not new ;0
06:56:42 <ManateeL`> quicksilver: Infact, it's mix content of "Plugging Haskell In" and "Dynamic Application From Group Up", but add many detail that how to implement "Haskell Dynamic Plugin System".
06:57:15 <ManateeL`> quicksilver: Include how to implement hs-plugins. 
06:57:55 * ManateeL` Reading p143 of "Dynamic Extension of Typed Functional Languages"......
06:58:30 <ivanm> ManateeL`: is this a paper or a thesis?
06:58:38 <ivanm> because if it's a paper it's rather long...
06:58:48 <ManateeL`> ivanm: PhD thesis.
06:59:09 <ManateeL`> ivanm: I think Don copy many content from "Plugging Haskell In" and "Dynamic Application From Group Up"
06:59:23 <ManateeL`> :)
07:00:13 <ivanm> well, yes, theses are normally based heavily upon papers written during the phd
07:00:27 <ManateeL`> ivanm: Because hs-plugins still broken, I haven't test many idea in thesis.
07:00:34 <ivanm> *nod*
07:00:56 <ManateeL`> ivanm: If hs-plugins can work, i think we can build a powerful hot-swapping framework like Emacs, but much safe.
07:01:16 <quicksilver> hs-plugins can work, but it does no magic - it's just driving GHC
07:01:33 <quicksilver> if you can't fix hs-plugins you can use GHC directly or possibly hint (I think maybe hint doesn't bind everything you want)
07:01:42 <djahandarie> I think dons mentioned he was going to revisit it
07:02:02 <ManateeL`> quicksilver: No, i want to fix rather fork another package.
07:02:33 <ManateeL`> quicksilver: hs-plugins not just include dynamic linking, it's include many other features, such as "compile manager", 
07:02:55 <quicksilver> yup
07:03:03 <quicksilver> I read some of the papers althouhg admittedly it was a few years ago.
07:03:13 <quicksilver> good stuff in there.
07:03:30 <ManateeL`> quicksilver: I think hint just perfect for "small script job", i want dynamic link object file to running application to get good performance.
07:04:57 <ManateeL`> quicksilver: In Don's PhD thesis, he discuss those stuff *systematically*, include how to change your project to build plugin framework.
07:06:58 <ManateeL`> quicksilver: I like pdynload idea that integrate .hi file to link object file with type-check.
07:07:25 * hackagebot bio 0.4.5 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.4.5 (KetilMalde)
07:07:27 * hackagebot flower 0.3 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.3 (KetilMalde)
07:10:30 <ManateeL`> I think "Dynamic extension static language" is pretty cool, integrate safety and flexibility.
07:23:31 * hackagebot flowsim 0.2.6 - Simulate 454 pyrosequencing  http://hackage.haskell.org/package/flowsim-0.2.6 (KetilMalde)
07:23:33 * hackagebot bio 0.4.6 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.4.6 (KetilMalde)
07:34:56 <yottis> is there some up-to-date tutorial on happstack?
07:35:12 <yottis> http://tutorial.happstack.com/ <- this one?
07:35:28 <msieradzki> this one is pretty up-to-date
07:35:48 <msieradzki> just doesn't have all the useful stuff
07:35:57 <msieradzki> like formlets instead of manual parsing of POST
07:36:10 <yottis> ok
07:36:35 <msieradzki> it's also fugly because all code samples don't use hscolour or anything
07:36:46 <yottis> does scaling with multimaster really scale or is that wishful thinking?
07:40:16 <Saizan> i think the multimaster code got dropped, actually
07:40:39 <fasta> Wasn't that the only thing that was semi-interesting about it? 
07:41:04 <Phyx-> it's a sad moment when you can't even think of a dirty hack to solve your problem..
07:41:12 <fasta> It was supposed to be able to scale to EBay proportions. 
07:41:42 <fasta> If you have to switch to a different system just because you grow, you have already failed.
07:41:43 <Saizan> the people working on it stopped working on happstack
07:42:05 <Saizan> (*happs, actually)
07:42:49 <fasta> It's kind of unfortunate there was no return on investment for those developers.
07:43:23 <fasta> There are a lot more useless projects that get more funding. 
07:44:25 <jmcarthur> ugh... "Do I really want to be using a language where memoize is a PhD-level topic?"  <-- really?
07:45:14 <fasta> jmcarthur, random people from the Internet getting too much attention. Nothing to see there.
07:45:25 <Saizan> imho, HAppS always had too much focus on doing things automagically to be manageable and approachable
07:45:47 <quicksilver> jmcarthur: don't read online comments. Ever. They are deleterious to your sleep patterns, state of mind, and general mental health.
07:46:09 <fasta> quicksilver, isn't this an online comment? ;)
07:46:27 <jmcarthur> Saizan: really? i have always felt that it was the opposite (aside from the liberal use of TH, which i disagree with)
07:46:39 <quicksilver> hmm. Not in the sense I meant, at least. SNR is pretty good on IRC if you pick your channels wisely.
07:46:54 <quicksilver> comments on blog posts less so, comments on reddit... gah.
07:47:02 <jmcarthur> beats comments on youtube
07:47:13 <jmcarthur> which beats comments on 4chan
07:47:31 <quicksilver> possibly ;) I've never tried them.
07:47:39 <quicksilver> I went to youtube once to watch a video but I didn't inhale.
07:47:44 <jmcarthur> heh
07:48:22 <Saizan> jmcarthur: heh, true, for some things, like dealing with extracting info from datatypes [de]serializing them over xml or urlencode you had all this TH and generics magic, while it was quite lacking in more standard things like Cookie or multipart support.
07:48:57 <jmcarthur> lack of multipart doesn't surprise me, but cookie?
07:49:28 <fasta> If you want to be a PHP killer you must have cookies! Please, do not quote that. 
07:49:43 <jmcarthur> i thought happs had cookie support
07:49:47 <Saizan> there was actually support for cookies, not much for session data though
07:49:54 <jmcarthur> oh, that
07:50:37 <jmcarthur> eh, that doesn't bother me so much
07:50:42 <jmcarthur> rolling your own session data isn't so bad
07:51:30 <Saizan> no, but after a sufficient number of "rolling your own $x" there isn't much use for a framework :)
07:51:50 <jmcarthur> that's why you make libraries :P
07:52:00 <jmcarthur> my biggest problem with happs is calling it a "framework"
07:52:10 <Saizan> anyhow, what were you referring at when you said that it felt the "opposite"?
07:52:39 <jmcarthur> i've always felt that, in contrast to most other web "frameworks," that happs is not very magical
07:52:52 <jmcarthur> relative to other haskell libraries it's another matter
07:52:53 <EvanR-work> whats the matter? isnt Data.Map a framework?? :), how about c standard i/o framework stdio.h !?
07:52:59 <jmcarthur> which may be the standpoint you are coming from
07:53:01 <EvanR-work> everythings a framework!!!1
07:53:12 <jmcarthur> EvanR-work: a library ;)
07:53:29 <EvanR-work> you are not being hip enough
07:53:32 <EvanR-work> more jargon
07:53:37 <ski> "framework" being "don't call us, we'll call you" ?
07:53:41 <Saizan> jmcarthur: i referred to the extensive use of generics, mostly, though you might have avoided them, depending on which HAppS you saw and which parts you used :)
07:53:45 <jmcarthur> ski: right!
07:54:04 <jmcarthur> i never saw it defined though, so i might just be making it up
07:54:37 <EvanR-work> :m atexit
07:54:53 <jmcarthur> Saizan: i rarely use generics
07:54:56 <Saizan> but yeah, if you come from e.g. python's web frameworks (:P) HAppS was actually quite unmagical
07:55:01 <jmcarthur> well, generics in the haskell sense
07:55:12 <EvanR-work> int atexit(void (*func)(void)), calls func when program exits ;)
07:55:20 <jmcarthur> generics in most languages is essentially parametric polymorphism ;)
07:55:31 <EvanR-work> what are haskell generics?
07:55:43 <jmcarthur> i believe Saizan is referring to things like syb
07:55:49 <Saizan> eighr
07:55:51 <Saizan> *right
07:56:10 <quicksilver> haskell generics are things defined by induction over the structure of types
07:56:15 <Saizan> i.e. syb-with-class was maintained by the HAppS devs :)
07:56:26 * ski thought "generics in Haskell" was things like polytypic things
07:56:38 <jmcarthur> it's a badly overloaded word
07:56:51 <EvanR-work> :t genericLength
07:56:52 <lambdabot> forall b i. (Num i) => [b] -> i
07:56:54 <EvanR-work> \o/
07:56:57 <jmcarthur> heh
07:57:01 * ski gives EvanR-work a cokkie
07:57:09 <quicksilver> well "generic haskell" was a predecessor to the SYB stuff
07:57:10 <ski> s/ok/oo/
07:57:17 <quicksilver> induction over sum/product constructors
07:57:40 <ski> (hm .. istr the name "Patrik Janssen")
07:59:21 * Saizan wonders if it's wise to try to install all of hackage with only 1GB of ram
07:59:28 <handonson> attoparsec is behaving weird
08:00:01 <jmcarthur> Saizan: if you can install language-python then i bet you can install all of it
08:00:14 <handonson> i wrote { (try $ char8 ':') >> anyChar } and tried parsing "asdf"
08:00:18 <handonson> it fails
08:00:23 <handonson> what? why?
08:00:33 <quicksilver> because that dooesn't begin with a ':' ?
08:00:38 <handonson> 'try'
08:00:46 <quicksilver> 'yes' 'i' 'can' 'read'
08:00:46 <handonson> err wait
08:00:52 <handonson> isn't that for that
08:00:57 <quicksilver> try makes failure backtrack
08:01:01 <quicksilver> it doesn't make it not matter
08:01:19 <handonson> should i say many instead of try
08:01:30 <Saizan> optional?
08:01:41 <Saizan> ?type optional
08:01:42 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
08:02:13 <Saizan> > optional (Nothing :: Maybe ())
08:02:14 <lambdabot>   Just Nothing
08:02:33 <Saizan> that must be the most confusing optional example :)
08:03:34 <quicksilver> pretty confusing I think :)
08:03:56 <geheimdienst> > optional 42
08:03:56 <lambdabot>   No instance for (GHC.Show.Show (f (Data.Maybe.Maybe a)))
08:03:56 <quicksilver> but optional should work in AttoParsec, since it's a nice Alternative instance.
08:03:57 <lambdabot>    arising from a ...
08:04:04 <geheimdienst> > optional $ Just 42
08:04:04 <lambdabot>   Just (Just 42)
08:04:19 * ski was going to suggest  (2 +) `optional` 3  only to note in dismay that  Applicative (r ->)  appears to be missing
08:04:22 <geheimdienst> > optional Nothing
08:04:23 <lambdabot>   Just Nothing
08:04:24 <handonson> would (try x) <|> (return ()) instead of optional
08:04:39 <handonson> would (try x) <|> (return ()) work* instead of optional
08:04:52 * geheimdienst thinks "optional" is a synonym for Just
08:05:08 <aristid> @src optional
08:05:08 <lambdabot> optional v = Just <$> v <|> pure Nothing
08:05:10 <geheimdienst> ... conclusively determined by 30 seconds of lambdabot experiments
08:05:11 <handonson> wait, that would cause type mismatch
08:05:18 <ski> @type [Just,optional]
08:05:19 <lambdabot> forall a. [Maybe a -> Maybe (Maybe a)]
08:05:21 <ski> not so
08:05:40 <Saizan> handonson: see the source of optional, it's almost the same but the types match :)
08:05:49 <quicksilver> handonson: (Just <$> try x) <|> (return Nothing) would work
08:05:54 <quicksilver> handonson: ..and that's what optional is.
08:05:59 <quicksilver> (modulo return/pure)
08:06:09 <handonson> where is it
08:06:14 <Saizan> handonson: and you don't need try for (char8 ':')
08:06:15 <aristid> :t let optional v = Just <$> v <|> pure Nothing in optional
08:06:15 <quicksilver> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/Control-Applicative.html#optional
08:06:16 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
08:06:35 <quicksilver> Saizan: but that's interesting; it means optional won't work without try for longer things, right?
08:06:48 <quicksilver> this makes Parsec a pretty sick instance of Alternative.
08:06:56 <quicksilver> unless they defined <|> to use try, I suppose.
08:07:10 <handonson> what? seriously? i need to import Control.Applicative to use optional?
08:07:12 <ski> @check \x y -> Just (x :: Maybe Int) == optional x
08:07:13 <lambdabot>   "OK, passed 500 tests."
08:07:19 <quicksilver> handonson: you say that like it's a bad thing?
08:07:33 <quicksilver> attoparsec gets lots of its useful combinators from its Alternative instance.
08:07:37 <aristid> you can put Control.Applicative in your personal prelude
08:07:41 <quicksilver> that's nice structure, not a problem.
08:08:54 <handonson> now i remember i once used (try p >> return ()) <|> (return ()) instead of optional
08:10:27 <Saizan> quicksilver: i don't think it violates any Alternative laws, just not so nice to use as usual :)
08:10:27 <Twey> You never need brackets around a function call when there are operators involved
08:14:30 <jmcarthur> i do wish that all the "side effects" modules were in one module (Control.Applicative, Control.Monad, Control.Arrow, etc.)
08:14:56 <handonson> what would you call it
08:15:02 <jmcarthur> or at least that there was a somewhat standard module that exported all those
08:15:04 <jmcarthur> oh i dunno
08:15:05 <Saizan> Control ?
08:15:15 <jmcarthur> in the absense of Arrow i guess you could just called it Control.Functor
08:15:22 <handonson> Control.Harmful
08:15:32 <jmcarthur> Category and Arrow could be separate from that i guess
08:15:41 <quicksilver> Control.Computation
08:15:45 <jmcarthur> so have two modules: Control.Category and Control.Functor
08:15:59 <quicksilver> Control.NotionsOf.Computation
08:16:04 <jmcarthur> where Category also includes all the Arrow stuff and Functor includes Applicative and Monad and junk
08:16:13 <jmcarthur> heh
08:16:19 <handonson> Control.Effect
08:16:31 <handonson> Control.Effectful
08:16:56 <handonson> jmcarthur: write one
08:17:01 <Saizan> class Junk m where ..
08:18:09 <handonson> Saizan: and in the runtime, all instances of it will be collected by the GC very quickly
08:18:24 <nus> Control.Dirty.Tricks
08:18:31 <Saizan> you don't collect types :P
08:19:19 <geheimdienst> Control.Your.Emotions
08:19:59 <handonson> Control.Alt.Delete
08:20:51 <ski> Shift.To.Control
08:21:34 <ski> (Chung-Shieh Shan)
08:22:09 <geheimdienst> Control.Freak
08:23:23 <ksf> Control.Is.Laisez.Faire
08:25:12 <Tomsik_> Control.Everything
08:25:39 <conal> or just Everything.  Even Control is overly specific.
08:25:58 <BMeph> Control.The.World.With.My.Freeze.Ray
08:26:05 <mux> ksf: you miss an 's' </french_grammar_nazi>
08:26:14 <nus> Con.Troll
08:26:34 * BMeph thinks that nus Clearly won that round...
08:26:55 <ksf> spelling, actually. I should've known better.
08:27:18 <ksf> my french spelling and pronounciation is about three magnitudes better than my grammar and vocabulary.
08:27:39 <mux> c'est bon  savoir
08:27:41 * nus mass-invites half-the-channel to -blah (-;
08:27:52 * mux decides to leave work instead &
08:31:52 <jystic> What would be the best way to go about building a type like Latitude that is limited from -90 to 90 degrees?
08:32:33 <jystic> Would you just hide it constructor? or are there better ways?
08:32:37 <jystic> it's*
08:33:01 <jaspervdj> jystic: Yeah, I would hide the constructor
08:33:06 <ksf> use a sane coordinate system as base representation and convert to/from it?
08:33:43 <Entroacceptor> define 'sane'
08:33:49 <jystic> ECEF isn't that sane :)
08:34:14 <jystic> You can end up with positions inside the Earth's core
08:34:40 <jmcarthur> quaternions!
08:34:44 <Tomsik_> you can use some trig stuff
08:34:52 <jmcarthur> of course, that ends up having a "facing" direction, too
08:34:52 <Tomsik_> so -inf to inf is -90 to 90 degrees :p
08:35:16 <Entroacceptor> that's why I say that haskell's type system is too weak
08:35:21 <jmcarthur> Tomsik_: ew
08:35:22 <jystic> jmcarthur: quaternions would be ok, but they will have the same problem
08:35:23 <ksf> that'd be a good idea, iff floats wouldn't be so darn sparse around infinity.
08:36:05 <jmcarthur> could go with Word32 or Word64
08:36:15 <jmcarthur> [0..maxBound]
08:36:29 <Silvah> Int?
08:36:33 <jmcarthur> or the Int variants
08:36:40 <jmcarthur> [minBound..maxBound]
08:36:51 <reorg> what's the most efficient way to count the # of bits of an unsigned int? in C, one can shift then plus
08:36:58 <jystic> that's an interesting idea
08:37:11 <zygoloid> reorg: you mean, number of 1 bits?
08:37:19 <reorg> yes
08:37:22 <jaspervdj> reorg: You can shift and plus using Data.Bits
08:37:22 <ksf> > 1 `shiftL` 3
08:37:23 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:37:23 <lambdabot>    `Data.Bits.Bits a'
08:37:23 <lambdabot>      a...
08:37:24 <wli> Maybe just evenly spread out 2^32 or 2^64 sample points across the Riemann sphere.
08:37:27 <ksf> > 1 `shiftL` 3 :: Int
08:37:27 <lambdabot>   8
08:37:46 <wli> Subtract a few from that for NaN, infinity, etc.
08:38:30 <jmcarthur> clearly the best way is to sample from (mkStdGen 0) until you get the location you want and then store the number of times you had to sample it to get that
08:38:40 <fasta> reorg, there is an assembly instruction which does that.
08:38:42 <jystic> lol
08:39:01 <Silvah> Shifting and adding isn't the best idea.
08:39:32 <reorg> Silvah, what's the best way to do it then? 
08:39:38 <Silvah> fasta: alas, popcnt requires SSE4 or something.
08:39:59 <fasta> Silvah, ah, I didn't know it was that recent. I know my laptop has it. 
08:40:02 <reorg> fasta: assembly? you mean calling assembly from haskell?
08:40:11 <fasta> reorg, why not?
08:40:29 <zygoloid> > let ones :: Word32 -> Word32; ones n = foldl' (\n (s,m) -> (n .&. m) + ((n `shiftR` s) .&. m)) n [(1,0x55555555),(2,0x33333333),(4,0x0f0f0f0f),(8,0x00ff00ff),(16,0x0000ffff)] in map ones [0..10]
08:40:30 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2]
08:40:32 <ksf> yes, of course. you write assembly to a bytestring and then unsafeCoerce it to a function
08:40:33 <fasta> reorg, that's the most efficient it will get :)
08:40:33 <zygoloid> reorg: ^^ that's how i'd do it
08:40:49 <jmcarthur> ksf: ...
08:41:07 <fasta> reorg, but I doubt any specific function is that important.
08:41:12 <zygoloid> (portable and O(log(log n)).
08:42:11 <kuribas> I get an error: "Can't find interface-file declaration for variable ulist Probable cause: bug in .hi-boot file, or inconsistent .hi file Use -ddump-if-trace to get an idea of which file caused the error"
08:42:11 <kuribas>  
08:42:11 <kuribas> Where should I look for this .hi file?
08:42:11 <ksf> where the module is.
08:42:11 <zygoloid> kuribas: which module defines ulist?
08:42:17 <fasta> reorg, or use these methods:  http://popcnt.org/2007/09/magic-popcount-popcnt-command.html
08:42:27 <kuribas> my module: import Text.XML.HXT.Arrow.XHtml.Strict
08:42:31 <fasta> reorg, in short, not really a problem worth thinking about :)
08:42:59 <ksf> it'd be a good idea to export all those nice asm functions different arches have and then provide fallback implementations for portability, though.
08:43:00 <zygoloid> reorg: my code above is the same algorithm as the code at the bottom of that post fasta pasted
08:43:09 <Silvah> reorg: for instance, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27847#a27847
08:43:36 <fasta> zygoloid, I like your version better. 
08:43:55 <zygoloid> i wonder if GHC will compile it to nice code...
08:43:59 * zygoloid cranks up ghc-core
08:44:30 * quicksilver suspects note.
08:44:32 <quicksilver> not.
08:46:58 <kuribas> Why should there be an inconsisten .hi file?
08:47:08 <quicksilver> compiled with a different version of ghc perhaps?
08:47:19 <kuribas> I have only one version...
08:47:46 * ski for some reason read "O(log(..." as "Oleg(..." initially
08:49:12 <Saizan> kuribas: should be easy to just clean them though..
08:49:32 <Tomsik_> I heard that if you can do something in better than log(log n) time, it's doable in const time
08:49:34 <Tomsik_> so try harder :p
08:50:07 <reorg> where is foldl' defined?
08:50:13 <EvanR-work> antihaskell propaganda: haskellers say that IO code is nasty and should be safety separated from non IO code, and haskell enforces this to a large extent. but in reality, the reason they think IO code is so bad is that in their language they cant freely mix and use IO anywhere!
08:50:42 <EvanR-work> IO wouldnt be so bad if you could do it anywhere like in normal languages
08:50:59 <Saizan> people really say that?
08:51:03 <dibblego> reorg, Data.List and Data.Foldable
08:51:22 <fasta> Saizan, you have to remember they are people.
08:51:25 <EvanR-work> i do not know. i made it up
08:51:32 <kuribas> Saizan: I have removed the package, cleaned the source directory, recompiled, but I get the same error...
08:51:39 <monochrom> well, you are people too
08:51:48 <ski> @index foldl'
08:51:48 <lambdabot> Data.List
08:51:51 <Silvah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27848#a27848 - ugly, and I'm proud of it ^^
08:52:04 <reorg> thanks
08:52:09 <zygoloid> quicksilver: your suspicion is correct. it builds a nice tail-recursive loop out of the foldl', but that's it.
08:52:17 <Saizan> EvanR-work: thought so
08:54:01 <EvanR-work> i wouldnt be surprised though
08:54:22 <Silvah> heh, my code is pretty good actually, generated assembly is not bad ^^
08:54:32 <quicksilver> kuribas: I think that's very odd. What is the exact error?
08:55:48 <zygoloid> quicksilver: plus it's wasting time checking that the fst of each of the list elements is positive and doing a shiftL if not!
08:56:12 <quicksilver> zygoloid: micro-optimisation; the game that never ends :)
08:56:31 <quicksilver> if you can successfully deduce a globally applicable optimisation, though, that's great.
08:56:58 <monochrom> micro-optimization can be left as a dynamic programming exercise to the computer. that ends the game.
08:57:32 <conal> EvanR-work: if you read john backus's turing award lecture, you'll find more substantive & thoughtful concerns about imperative programming (eg IO).
08:58:10 <EvanR-work> ill have to do that
08:58:35 <quicksilver> conal: substantive? thoughtful? such things have no place in IRC! ;)
08:58:44 <conal> quicksilver: oops.  my bad!
08:58:52 <kuribas> quicksilver: I think I found the problem, I didn't export enough modules for hxt-xhtml.
08:58:57 <EvanR-work> i have a hard time justifying myself when i tell people here to avoid for loops
08:58:59 <monochrom> this is why john backus didn't give his lecture on IRC
08:59:01 <zygoloid> quicksilver: well, i think what this case needs is loop unrolling. :)
08:59:24 <quicksilver> zygoloid: someone did a prototype which unrolled loops using RULES didn't they?
08:59:35 <quicksilver> kuribas: OK. Still a very peculiar error message?
08:59:43 <conal> EvanR-work: i bet.  there are deep reasons.
08:59:47 <kuribas> quicksilver: yes
09:00:06 <conal> monochrom: :)
09:00:34 <kuribas> quicksilver: actually, I get another one later about the missing .hi files :)
09:01:03 <quicksilver> zygoloid: http://www.haskell.org/pipermail/glasgow-haskell-users/2009-February/016695.html
09:01:10 <quicksilver> zygoloid: (that was the discussion I was thinking of)
09:01:31 <fryguybob> I usually tell people the type of a for loop isn't interesting functionally.
09:08:39 <jmcarthur> for :: IORef a -> IO Bool -> IO () -> IO () -> IO ()  -- for is so complicated and useless!
09:08:51 <jmcarthur> dang i didn't get that right
09:09:20 <jmcarthur> for :: a -> (IORef a -> IO Bool) -> (IORef a -> IO ()) -> (IORef a -> IO ()) -> IORef a -> IO ()
09:09:30 <jmcarthur> or something
09:09:43 <ksf> I once tried to implement it and gave up.
09:09:49 <Tomsik_> This is madness!
09:09:58 <Tomsik_> Imperative hell.
09:10:47 <ksf> you can define variables in the () part of a for.
09:11:05 <jmcarthur> you mean declare them?
09:11:13 <ksf> er yes.
09:11:19 <jmcarthur> only in C99 or, in older versions, compiler extensions
09:11:25 <ksf> I mean you can define a binding to be a variable.
09:11:27 <fasta> jmcarthur, declare + initialize == define, no?
09:11:31 <ksf> java etc.
09:11:46 <jmcarthur> fasta: there are so many possible meanings. i was just making sure
09:11:58 <ksf> I don't think you need to initialise them
09:12:26 <Tomsik_> well, at least nobody's talking about "initiating" a variable
09:12:33 <Tomsik_> or "instantiating"
09:12:39 <jmcarthur> for :: a -> (a -> IO Bool) -> (a -> IO ()) -> (a -> IO ()) -> a -> IO ()
09:12:46 <fasta> @type for
09:12:48 <lambdabot> Not in scope: `for'
09:12:50 <ksf> ansi C allows declarations at the beginning of every block, though, that doesnt' seem to be widely known.
09:12:51 <fasta> @type forM
09:12:52 <jmcarthur> where the first 'a' is your "declarations"
09:12:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
09:13:13 <ksf> ...considering that everyone is declaring everything at the beginning of procedures.
09:13:42 <jmcarthur> fasta: forM is more like foreach, which is a lot more disciplined
09:14:13 <fasta> jmcarthur, ok, well then I just insert Lennarts' blog post about Basic.
09:14:21 <jmcarthur> heh
09:15:31 <jmcarthur> callCC is our dirty function
09:15:31 <jmcarthur> at least it's powerful though
09:15:31 <jmcarthur> and built from other language features
09:15:32 <ksf> I was _shocked_ when I realised that.
09:15:33 <mornfall> I wish haddock would hscolour the inline code examples....
09:15:43 <ksf> ...that callCC is not a primitive.
09:16:02 <mornfall> Why shocked?
09:16:30 <fasta> We don't really have callCC, imho. 
09:16:47 <ksf> because it just doesn't work in anything else but a lazy language, and strict were all I knew.
09:17:03 <fasta> But you can debate that with someone else ;)
09:17:09 <ksf> well, you can wrap your whole program in ContT
09:18:00 <mornfall> ksf: If you are so minded, I guess... :)
09:18:30 <jmcarthur> fasta: what does "real" callCC have that ours doesn't (i understand that mtl's callCC has the wrong type signature, but we can define one that is more general)?
09:19:10 <ksf> jmcarthur, it lives in the wrong monad.
09:19:11 <fasta> jmcarthur, just that it doesn't work without a corresponding runCont(T)
09:19:42 <ksf> ...in scheme, you can snatch the repl's continuation and worse stuff.
09:20:03 <fasta> ksf, I don't think you can in PLT Scheme anymore.
09:20:15 <fasta> ksf, at least that's what the delimited continuations are for.
09:20:30 <fasta> ksf, or rather that is the official excuse for inventing them ;)
09:20:42 <jmcarthur> i'm not sure i consider needing runCont(T) to be a bad thing, unless you have a case to make against it
09:20:51 <ksf> there's no real one
09:21:16 <ksf> you should plan to use continuations, or you shouldn't have to worry about them.
09:21:19 <fasta> jmcarthur, some people like to have everything available all the time, some don't. There is no formal argument, except for implementation costs. 
09:21:31 <jmcarthur> ah, then no argument
09:22:05 <jmcarthur> the former people wouldn't like haskell ;)
09:22:59 <ski> "Don't Ask: What Can The Computer do for ME?, But Rather: What CAN I do for the COMPUTER?"
09:23:42 <aristid> ski: the computer wants you to write in java
09:24:01 <Tomsik_> Is this some skynet
09:24:08 * ski would have expected Maple rather, in this case
09:24:27 <aristid> don't question the computer's choice
09:24:29 <ski> Tomsik_ : it's from the mathematician Doron Zeilberger
09:24:44 <Tomsik_> Zoidberg?
09:24:47 <Tomsik_> :p
09:25:03 <ski> <http://www.math.rutgers.edu/~zeilberg/Opinion36.html>
09:25:13 <int80_h> @hoogle lift
09:25:14 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
09:25:14 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
09:25:14 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
09:25:45 <ski> @hoogle lower
09:25:45 <lambdabot> Text.Parsec.Char lower :: Stream s m Char => ParsecT s u m Char
09:25:45 <lambdabot> Text.ParserCombinators.Parsec.Char lower :: Stream s m Char => ParsecT s u m Char
09:25:45 <lambdabot> Data.Char LowercaseLetter :: GeneralCategory
09:28:20 <ttt-> those are some scary signatures
09:29:26 <aristid> ttt-: you haven't seen scary yet :P
09:29:27 <ski> how so ?
09:29:38 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27853#a27853
09:29:44 <int80_h> ttt: tell me about it
09:29:54 <tg_zzz> yeah
09:30:02 <int80_h> If you look at my hpaste, I promise a funny title.
09:30:11 <tg_zzz> all that whole pastie does, is start a webpage which says "i'm firing the missles" but it makes coffee instead
09:30:22 <tg_zzz> great good!
09:30:33 <int80_h> heh
09:30:52 <monochrom> "learn how to eat for great food"
09:31:54 <int80_h> no takers?
09:32:09 <ski> int80_h> :t run . toWaiApp Blog
09:33:08 <int80_h> ski: so lifting is not the way to go here?
09:33:08 <ddarius> "So any theorem that a human can prove is, ipso facto, utterly trivial."
09:33:08 <int80_h> ski : I thought the error message told me to lift.
09:33:24 <ski> int80_h : no idea, yet
09:33:40 * ski needs to devour a few more of the types, first
09:33:55 <Tomsik_> ddarius: fact is that computers are even worse at this :p
09:34:06 <ski> int80_h> :t Blog  -- as well, i suppose
09:35:58 <int80_h> ski: *Main> :t Blog
09:35:58 <int80_h> Blog :: [Entry] -> Blog
09:37:11 <int80_h> ski: when I do this :t run . toWaiApp Blog, I get a type error in ghci
09:37:42 <ddarius> Tomsik_: Read ski's link.
09:38:03 <ddarius> At any rate, however true that is now, it will not remain true forever.
09:38:44 <Tomsik_> probably it will, even things that are decideable in 2EXPTIME are helluva slow
09:38:59 <ski> "In addition to permamnently published here, I was hoping to have this piece also published in the Notices of the American Math. Soc., so that non-surfers might benefit from it too. The Forum section editor, Susan Friedlander, decided to reject it. I wonder why?"
09:39:28 <ski> int80_h : ok, separate types of `run' and `toWaiApp', then ?
09:39:38 <ddarius> Another Hans Rosling talk!
09:39:56 <ski> where !?
09:40:10 * ski looks around, seeing nothing
09:42:42 <int80_h> :ski *Main> :t run
09:42:42 <int80_h> run :: Application -> IO ()
09:42:42 <int80_h> ski : *Main> :t toWaiApp
09:42:42 <int80_h> toWaiApp :: (Yesod y, YesodSite y) => y -> IO Application
09:42:43 <ddarius> ski: http://www.ted.com/speakers/hans_rosling.html  (I recommend watching them in order if you do watch them.)
09:42:43 <ski> int80_h : i see, you do want `liftM', not `lift'
09:42:43 <ski> (completely different animals)
09:43:09 <ski> also, i suspect you really only want one `Blog'
09:43:37 <ski> (presumably `(Yesod Blog,YesodSite Blog)' holds, yes ?)
09:43:45 <ddarius> Tomsik_: One issue that limits computers is often people require guaranteed results from computers, but no such constraints are placed on humans.  Humans don't have some magical decision procedure that computers lack, humans just use a whole bunch of heuristic methods.
09:43:50 <int80_h> ski: holds?
09:43:51 <ski> ddarius : ok
09:44:03 <ski> int80_h : is "is true" better ?
09:44:12 <ddarius> And at any rate, most computer programs are not given years or decades to find solutions.
09:44:21 <Tomsik_> well, that's true
09:44:35 <ski> using more words : `Blog' is an instance of both `Yesod' and `YesodSite'
09:45:10 <tromp_> if u'r given a decade, then best wait 9 years to start it on 10x faster computer
09:45:16 <int80_h> ski: I think so.
09:45:23 <int80_h> @hoogle liftM
09:45:23 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
09:45:23 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:45:23 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
09:45:31 <ski> int80_h : so .. do you want to figure out how to use `liftM' yourself, or should i spoil it ?
09:46:07 <int80_h> ski : give me a minute here. I want to try.
09:46:13 <aristid> if Applicative => Monad would hold, then we could drop liftM* and always use liftA \o/
09:46:14 <ddarius> tromp_: Too bad that doesn't work for humans.
09:46:21 <int80_h> ski: I suspect I may have to ask you to spoil it, but I want to attempt it
09:46:40 <ski> int80_h : actually, on saecond thought, i think `(=<<)' is more appropriate here, sorry (that or use an extra `do'-command, or use `join')
09:47:04 <ski> (s/or use `join'/or use `join' together with `liftM')
09:47:20 <int80_h> use =<< with do notation? egads!
09:47:32 <int80_h> I will try join and liftM
09:47:33 <ski> sure, it's better than using `(>>=)' (which would also work)
09:47:52 * ski didn't notice one of the `IO's above, initially
09:48:33 <ski> (int80_h : i hope you do see how using an extra `do'-command would work, though)
09:50:05 <int80_h> ski : I don't
09:50:22 <int80_h> ski: that seems clunky
09:50:30 <ski> which ?
09:50:40 <int80_h> ski using an extra do command
09:50:52 <ski> consider your types
09:51:02 <ski>   entries :: [Entry]
09:51:21 <ski>   Blog entries :: Blog
09:51:39 <ski>   toWaiApp (Blog entries) :: IO Application
09:51:51 <ski> but we had
09:51:55 <ski>   run :: Application -> IO ()
09:52:06 <ski> so these don't fit, directly
09:52:17 <ski> but if you do a `do'-command
09:52:30 <ski>   application <- toWaiApp (Blog entries)
09:52:33 <ski> then you'd get
09:52:40 <ski>   application :: Application
09:52:47 <ski> so then you can do
09:52:53 <ski>   run application :: IO ()
09:52:59 <ski> you see ?
09:53:50 <ski> now, if you want to use `liftM', the more specialized type of it, in this context, is
09:54:07 <ski>   liftM :: (a -> b) -> (IO a -> IO b)
09:54:25 <ski> we can use this to combine `run' with `toWaiApp (...)'
09:54:30 <ski> then we get
09:54:51 <ski>   liftM run (toWaiApp (...)) :: IO (IO ())
09:55:02 <ski> int80_h : are you following, so far ?
09:56:40 <aristid> @hoogle (a1 -> m a) -> m a1 -> m a
09:56:40 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
09:56:41 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
09:56:41 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:57:25 <aristid> ski: using join and liftM seems like a rather indirect method
09:58:13 <ttt-> someone should put some AI into a haskell editor
09:58:25 <ttt-> 'make a valid function from this'
09:58:29 <ski> aristid : yes, hence i suggested `(=<<)' :)
09:58:36 * ski pokes int80_h with a stick
09:58:52 <ttt-> does that exist already?
09:58:55 <ddarius> God damn Python.
09:59:08 <ddarius> @djinn a -> b -> a
09:59:09 <lambdabot> f a _ = a
09:59:32 <ttt-> i bet it's not that hard of a problem.. how many different valid things can you make with a couple of functions
09:59:35 <aristid> ski: essentially you're showing how (=<<) is derived from the more fundamental operations join and fmap :)
09:59:45 <Tomsik_> @djinn (a->a)->(b->b)->a->b->(a,b)
09:59:45 <lambdabot> f a b c d = (a c, b d)
09:59:48 <Tomsik_> cool
10:00:18 <ski> @djinn Maybe (Maybe a -> a) -> Maybe a
10:00:18 <lambdabot> f a =
10:00:18 <lambdabot>     case a of
10:00:18 <lambdabot>     Nothing -> Nothing
10:00:18 <lambdabot>     Just b -> Just (b (Just (b Nothing)))
10:00:25 <int80_h> ski: had a phone call, im back
10:01:27 <int80_h> ski: I'm reading what you wrote, so I must scroll up
10:01:44 * ski idly wonders whether phones typically support tail calls
10:02:07 * absentia has an iPhone, so his supposed fail calls.
10:02:08 <ski> (or "phone systems", i'd probably should say)
10:02:09 <ddarius> ski: If you program them in assembly, then presumably you do.
10:02:29 <int80_h> ski: I'm a little lost here
10:02:31 <int80_h> 18:52 < ski>   application <- toWaiApp (Blog entries)
10:02:31 <int80_h> 18:52 < ski> then you'd get
10:02:31 <int80_h> 18:52 < ski>   application :: Application
10:02:40 <ski> ddarius : i mean, if A calls B, can B forward A's call to C ?
10:02:52 <ddarius> ski: Sure.
10:03:02 * BMeph knows AT&T has over 40 years of "fail call optimization" experience...
10:03:16 <int80_h> I am having trouble with data types. I don't know how application <- toWaiApp (Blog entries) gets you application :: Application
10:03:31 <ski> int80_h : since `toWaiApp (Blog entries)' (the right-hand-side of the `<-' `do'-command) has type `IO Application', then `application' (the left-hand-side of `<-') will get type `Application'
10:03:42 <aristid> BMeph: i read that it's all due to san francisco hippies not wanting telephony towers
10:03:43 <ski> that's what `<-' in `do'-notation does
10:04:29 <int80_h> ski : gotch. I'm going to continue reading, then change the code
10:05:57 <int80_h> ski: I want to talk about the type of LiftM
10:06:05 <int80_h> liftM :: (a -> b) -> (IO a -> IO b)
10:06:07 <int80_h> liftM :: (a -> b) -> (IO a -> IO b)
10:06:08 <int80_h> liftM :: (a -> b) -> (IO a -> IO b)
10:06:13 * ski ponders evil plans of making a circle call, then shortening it to include zero participients ..
10:06:17 <int80_h> liftM :: (a -> b) -> (IO a -> IO b)
10:06:17 <int80_h> liftM :: (a -> b) -> (IO a -> IO b)
10:06:17 <int80_h> liftM :: (a -> b) -> (IO a -> IO b)
10:06:17 <int80_h> liftM :: (a -> b) -> (IO a -> IO b)
10:06:26 <int80_h> oops
10:06:28 <ski> .. though, presumably, it would be GCed at that point
10:06:30 <int80_h> sorry about the pasting
10:06:42 <ski> int80_h : yes ?
10:06:57 <int80_h> okay this type says liftM takes a function for an argument
10:07:05 <ski> e.g.
10:07:06 <int80_h> of any tpe
10:07:13 <ski>   foo <- liftM reverse getLine
10:07:15 <Zao> Can't we GC int80_h? :D
10:07:29 <int80_h> GC?
10:07:40 <ski> will run `getLine' to get a `String', and then run that through `reverse' before naming the result `foo'
10:07:49 <Zao> int80_h: Garbage collection.
10:07:57 <ski> (int80_h : sorry, unrelated .. and "GC" meaning "Garbage Collect", here)
10:08:20 <ddarius> ski: The phone companies can handle such situations.
10:08:24 <int80_h> ski : the last part of the type
10:08:30 <int80_h> > :t liftM
10:08:31 <lambdabot>   <no location info>: parse error on input `:'
10:08:35 <int80_h> oops
10:08:53 <ski> ddarius : i assumed so, after a full moments thought
10:09:02 <int80_h> liftM :: (a -> b) -> (IO a -> IO b)
10:09:13 <ski>   liftM :: (a -> b) -> (IO a -> IO b)
10:09:15 <ski> is the same as
10:09:18 <ski>   liftM :: (a -> b) -> IO a -> IO b
10:09:24 <ski> except the former is prettier :)
10:10:10 <int80_h> (IO a -> IO b), means the output of liftM is a function that now takes input of type IO to give output of type IO. is that right?
10:10:22 <ski> yes
10:10:27 <ski> so, since
10:10:37 <ski>   reverse :: String -> String  -- in the example above
10:10:46 <ski>   liftM reverse :: IO String -> IO String  -- in the example above
10:10:49 <ski> and then, since
10:10:54 <ski>   getLine :: IO String
10:10:55 <ski> so
10:11:04 <ski>   liftM reverse getLine :: IO String
10:11:20 <ski> similarly for the `liftM run (toWaiApp (...))' example
10:12:04 <int80_h> what does :: mean?
10:12:06 <ski> (except in that case, the `run' has type `run :: Application -> IO ()', so the result of the application will then have type `IO (IO ())')
10:12:12 <ski> "has type"
10:12:33 * int80_h has a light go off in his head
10:12:54 <int80_h> which is to say , turns on
10:12:55 * ski quickly lights it anew
10:13:25 <int80_h> english idiom is kooky
10:13:54 * benmachine imagines forwarding a call to himself and then watching as the exchange at the end of the road melts
10:14:08 <int80_h> okay I am going to try a re-write based on what you've told me here. brb
10:14:25 <benmachine> I think "go off" is more common with things like fireworks
10:14:41 <ski> (.. or maybe arrow bolts or something similar)
10:15:20 <int80_h> benmachine: yeah I was trying to invoke the fireworks imagery.
10:19:46 <deech> Hi all, does anyone know if the HTTP package package requires libcurl to be installed on the system?
10:20:02 <hydo> Negative.
10:20:13 <hydo> There's a separate lib for curl.
10:20:22 <hydo> Well, where lib = hackage package.
10:20:30 <jmcarthur> to build or to use? i don't know about the former, but i very much doubt the latter
10:20:50 <benmachine> pretty sure HTTP is pure haskell
10:21:21 <deech> I need to download binary files off the web using the HTTP package on Windows which doesn't come with curl.
10:21:34 <benmachine> that should be fine
10:22:06 <deech> benmachine: cool, that's awesome. I'm trying to make a case for using Haskell at work for a small utility. 
10:22:35 <int80_h> ski: thanks for your help. It's compiling now :)
10:22:48 <ski> int80_h : not so fast !
10:23:05 <ski> do you use `join' or an extra `do'-command ?
10:23:23 <int80_h> ski : yes I did, I will show you. Used an extra do command
10:23:48 <int80_h> ski: I will post it. it's 4 lines
10:23:50 <ski> (you should try all three alternatives, to get a feel for the tradeoffs)
10:24:09 <int80_h> ski: okay I will, I want to see this work first :)
10:24:48 <int80_h> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27807#a27854
10:24:57 <int80_h> ski: that's what I've done
10:25:27 <int80_h> ski: then when I have seen this work, I will try >>=, or is it =>>?
10:25:41 <ski> the ` :: IO()' type ascription there is not needed
10:25:46 <ski> @type (>>=)
10:25:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:25:50 <ski> @type (=<<)
10:25:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:25:57 <ski> anyway
10:26:03 <ski> did you follow up-to
10:26:14 <ski>   liftM run (toWaiApp (...)) :: IO (IO ())
10:26:15 <ski> ?
10:26:45 <beutdeuce> anyone here familiar with parsec?
10:26:54 <benmachine> beutdeuce: somewhat
10:26:59 <int80_h> ski : not yet. I will do that next
10:27:06 <benmachine> not so much the internals, but I've used it before
10:27:09 <benmachine> what's up?
10:27:34 <ski> int80_h : see the above reasoning for how that was arrived at (a couple of pages up, i surmise)
10:30:42 <beutdeuce> benmachine: I have a realtively general question about a function. I am not exactly sure what it does and how it does it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27855#a27855
10:30:53 <beutdeuce> relatively*
10:32:10 <beutdeuce> updated code (look at the third revision)
10:35:01 <benmachine> beutdeuce: the Prefix constructor doesn't take as many arguments as the Infix constructor, I guess having an associativity on a prefix constructor doesn't make sense
10:35:06 <benmachine> eeer, prefix operator
10:35:14 <benmachine> beutdeuce: I don't really understand your other questions
10:35:47 <beutdeuce> benmachine: what happens during "return f", and what is the significance of "string s" ?
10:36:42 <benmachine> beutdeuce: "string s" tries to match the input against "s"
10:37:26 <benmachine> beutdeuce: if it succeeds, then the "return f" makes the parser give back the value f
10:37:29 <int80_h> ski: okay my example code is running (sort of). I'm going to move on to the next version that you suggested
10:37:37 <beutdeuce> benmachine: oh, so op is a combinator that takes a string?
10:37:48 <benmachine> beutdeuce: s is a string, yes
10:38:05 <beutdeuce> benmachine: doesnt string construct a parser?
10:38:55 <benmachine> beutdeuce: yeah, string :: (Stream s m Char) => String -> ParsecT s u m String
10:39:34 <benmachine> 'string str' is a parser that tries to match the input against 'str' and then return it
10:39:37 <beutdeuce> so, string s will simply return a parser that matches against s
10:39:44 <benmachine> yes
10:39:50 <ski> beutdeuce : `string' constructs a parser, that when run (and if it succeeds), will return a `String'
10:40:08 <beutdeuce> what does the semicolon represent?
10:40:17 <beutdeuce> just another statement right?
10:40:25 <benmachine> the semicolon joins statements of a do-block
10:40:25 <int80_h> ski: I am trying the liftM approach right now
10:40:52 <benmachine> do{ string s; return f} = string s >> return f
10:40:54 <ski> int80_h : well, please tell when you agree with the type of `liftM run ...' :)
10:41:02 <ski>   do string s
10:41:05 <ski>      return f
10:41:35 <ski> the `;' (and the `{',`}'s) is a way to avoid using indentation blocks
10:41:57 <beutdeuce> benmachine: hm, so (>>) feeds the parser returned from "string s" to f, and returns the value of the result?
10:42:04 <ski> > let { x = 0 ; y = 1 } in (y,x)
10:42:06 <lambdabot>   (1,0)
10:42:26 <ski> hi esap
10:42:30 <benmachine> beutdeuce: no, not quite; I think you're thinking of >>=
10:42:45 <beutdeuce> benmachine: hm, what does (>>) do?
10:42:52 <ski> @src (>>)
10:42:52 <lambdabot> m >> k      = m >>= \_ -> k
10:43:11 <benmachine> beutdeuce: it says, when you've run the parser on the left, discard the value and run the parser on the right on the remaining input
10:43:20 * esap just wrote a Show instance that can print out value of 'undefined' :-)
10:43:30 <int80_h> ski : the idea is to use liftM with join?
10:43:38 <ski> esap : using some evil `spoon'-like magic ?
10:44:01 <ski> int80_h : if you think you have an idea, do elaborate
10:44:03 <esap> ski: well, actually, it only prints the type as an integer, but anyway :-)
10:44:14 <benmachine> beutdeuce: so when we've consumed some string with 'string str', we throw away the str and just return f instead
10:44:16 <beutdeuce> benmachine: hm, i see, though i do not understand why would one run "string s" to begin with if its output is discarded
10:44:29 <benmachine> beutdeuce: because it still consumes input
10:44:34 <esap> >  (undefined ::  Times (Succ (Succ (Succ Zero))) (Succ (Succ (Succ (Succ Zero)))))
10:44:34 <esap> 12
10:44:35 <lambdabot>   Not in scope: type constructor or class `Times'Not in scope: type construct...
10:44:41 <int80_h> ski: no no, I was asking. You said I should try the other approaches you suggested. I was asking if one of those approaches was to use liftM and join?
10:45:02 <ski> beutdeuce : to make sure there's input matching the contents of `s' in the data being parsed
10:45:13 <beutdeuce> benmachine: hm, and if input was not consumed, return f would never run (runtime error?)
10:45:26 <benmachine> beutdeuce: the parse would fail
10:45:34 <benmachine> beutdeuce: so yeah, return f would never be reached
10:45:43 <ski> int80_h : .. yes, but i'd rather you first tell whether you agreed with the last typing i got to in my derivation, when you had an NMI
10:45:51 <benmachine> your parse function would return Left error instead of Right parseresult
10:45:59 <ski> esap : ah. ok
10:46:13 <int80_h> NMI?
10:46:24 <beutdeuce> benmachine: ah, k, thnx a lot
10:46:27 <beutdeuce> ski: thnx too
10:46:41 <ski> (sorry, bad joke. "NMI" being "Non-Maskable Interrupt", in this case the phone call)
10:46:58 * hackagebot HSGEP 0.1.1 - Gene Expression Programming evolutionary algorithm in Haskell  http://hackage.haskell.org/package/HSGEP-0.1.1 (MatthewSottile)
10:47:05 <int80_h> ski : heh, I will try and find it and get back to you :)
10:47:16 <ski> (i.e. i assume it to be non-maskable, otherwise you clearly wouldn't have left IRC ! ;)
10:48:09 <ski> beutdeuce : have you seen the `Maybe'- or the `Either e'-monads before ?
10:48:44 <beutdeuce> ski: I am familiar with the data constructors, not sure about monads
10:48:52 <ski> esap : .. so, you've implemented type-level integers, you say .. negative ones, as well ?
10:50:22 <esap> ski: Well I don't have negative numbers yet - I haven't yet come up with examples where they would be useful :-)
10:51:19 <ski> > do x <- lookup 0 [(1,3),(0,2),(2,4)]; y <- lookup x [(9,"strawberry"),(1,"malkovich"),(2,"egregarious")]; return (x,y)
10:51:20 <lambdabot>   Just (2,"egregarious")
10:51:22 <esap> ski: I just needed naturals, because of element access to a polymorphic stack and queue. Positive numbers have been sufficient so far.
10:51:35 <ski> > do x <- lookup 1 [(1,3),(0,2),(2,4)]; y <- lookup x [(9,"strawberry"),(1,"malkovich"),(2,"egregarious")]; return (x,y)
10:51:36 <lambdabot>   Nothing
10:51:39 <ski> @type lookup
10:51:40 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:51:53 <ski> beutdeuce : ^ that's an example of using `Maybe' as a monad
10:52:17 <beutdeuce> ski: how is that a monad though?
10:52:26 <ski> @instance Monad
10:52:27 <lambdabot> Maybe you meant: instances instances-importing
10:52:30 <ski> @instances Monad
10:52:31 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:52:52 <ski> beutdeuce : there is an `instance Monad Maybe where ...' with definition of `return' and `(>>=)' for it
10:53:00 <ski> @src Maybe return
10:53:01 <lambdabot> return              = Just
10:53:04 <ski> @src Maybe (>>=)
10:53:04 <lambdabot> (Just x) >>= k      = k x
10:53:04 <lambdabot> Nothing  >>= _      = Nothing
10:53:23 <ski> beutdeuce : do you require more elaboration ?
10:53:43 <ski> esap : ok (though i assume zero could be handy as well)
10:53:58 <esap> ski: ok I do have Zero :-)
10:54:07 <int80_h> ski: I tried reading what you had written earlier but I'm having trouble following it
10:54:19 <ski> int80_h : ok
10:54:34 <ski> which part was too unclear to you ?
10:54:37 <beutdeuce> ski: I'm afraid i have yet to completely grasp the concept of a monad in the context of haskell (i am familiar in terms of category theory)
10:54:38 <int80_h> ski: I'm going to delete main, so I can put this code in ghci and play around with the types
10:54:50 <ski> (int80_h : .. or comment it out)
10:55:16 <ski> beutdeuce : well, the former is an instance of the latter :)
10:55:40 <int80_h> ski: okay let's think this out again
10:55:54 <Gracenotes> for maybe, unit :: Maybe (Maybe a) -> Maybe a --- unit (Just a) = a; unit Nothing = Nothing.
10:56:08 <Gracenotes> er make that join
10:56:11 <ski> beutdeuce : the point of the `Maybe' monad is that each `Maybe'-action (i.e. a value of type `Maybe a', for some type `a') can either succeed, yielding a single value of type `a', or it can fail, short-circuiting / aborting the rest of the `Maybe'-computation
10:56:16 <beutdeuce> ski: so i've heard :P
10:56:30 <Gracenotes> my head, it hurts. anyway blah blah value of chaining computations blah
10:56:31 <zygoloid> quicksilver: in case you're wondering, i did get some very tight code from that bit counting thing in the end, by a sort-of manual supercompilation
10:56:33 <beutdeuce> (in response to statement about monads being similar to category)
10:56:53 <ski> beutdeuce : in the above example, `lookup' can fail -- in case there is no key-value pair corresponding to the given key, in the given association list
10:56:57 <beutdeuce> ski: but cant that be simply expressed without the use of monads
10:57:23 <Tomsik__> monads are just a convinient way to do this
10:57:39 <beutdeuce> Tomsik__: how so?
10:57:45 <Tomsik__> do notation
10:57:52 <ski> beutdeuce : so, in the above, the stuff after each command only runs in case the previous command succeeded (and this holds true even if this whole `do'-block is called from another `do'-block in another function)
10:58:31 <beutdeuce> hm, i must have the wrong impression of the do block. Is it more than just an anonymous function ?
10:59:03 <mauke> beutdeuce: it's less
10:59:05 <ski> beutdeuce : `do'-notation is "just" a handy syntactic sugar for `(>>=)' (and also for `(>>)' and `fail')
10:59:22 <ski> @undo do x <- lookup 0 [(1,3),(0,2),(2,4)]; y <- lookup x [(9,"strawberry"),(1,"malkovich"),(2,"egregarious")]; return (x,y)
10:59:22 <lambdabot> lookup 0 [(1, 3), (0, 2), (2, 4)] >>= \ x -> lookup x [(9, "strawberry"), (1, "malkovich"), (2, "egregarious")] >>= \ y -> return (x, y)
10:59:45 <ski> int80_h : from the start ? ok
10:59:49 <zygoloid> @wn egregarious
10:59:52 <lambdabot> No match for "egregarious".
10:59:53 <beutdeuce> @type (>>=)
10:59:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:00:11 <beutdeuce> (m :: * -> *) ?
11:00:17 <int80_h> ski: yeah, I'm having trouble seperating signal from noise so far back in the channel text
11:00:20 <Tomsik__> it's a kind
11:00:33 <Tomsik__> you feed it a type and you get a type
11:00:36 <int80_h> ski: I have the code loaded in ghci, am ready to go over types.
11:00:36 <zygoloid> beutdeuce: it means that the type constructor m needs one more type (*) in order to produce a type (*)
11:00:47 <ski> beutdeuce : just ignore the part between `forall' and `.' for now, if you don't want to understand it atm
11:01:03 <beutdeuce> ski: i would love to understand ;)
11:01:14 <ski> int80_h : hm, maybe join #haskell-overflow, if you think it's too noisy atm ?
11:01:20 <beutdeuce> @type forall
11:01:21 <lambdabot> Not in scope: `forall'
11:01:39 <int80_h> ski: no it's fine now. I was referring to when you were explaining things earlier.
11:01:48 <ski> ok
11:01:49 <ski> so
11:01:53 <ski>   entries :: [Entry]
11:01:59 <ski> you agree with this ?
11:02:02 <int80_h> yes
11:02:08 <ski> and then you had
11:02:21 <ski>   Blog :: [Entry] -> Blog
11:02:22 <ski> so
11:02:31 <ski>   Blog entries :: Blog
11:02:33 <int80_h> hold up
11:02:49 <ski> you also had
11:02:53 <ski>   toWaiApp :: (Yesod y, YesodSite y) => y -> IO Application
11:03:06 <int80_h> Blog :: [Entry] -> says "Blog is of type [Entry] -> Blog"?
11:03:12 <ski> and since `(Yesod Blog,YesodSite Blog)', this specializes to
11:03:18 <int80_h> wait iwait :)
11:03:19 <ski>   toWaiApp :: Blog -> IO Application
11:03:21 <ski> so
11:03:38 <ski>   toWaiApp (Blog entries) :: IO Application
11:03:45 <int80_h> please wait
11:03:48 * ski waits
11:04:00 <int80_h> could you read what I typed earlier ^
11:04:28 <benmachine> yes, Blog is of type [Entry] -> Blog
11:04:46 <ski> yes, `Blog :: [Entry] -> Blog' says that `Blog' is of type `[Entry] -> Blog', i.e. is a function taking a list of `Entry'ies and giving back a `Blog'
11:05:03 <int80_h> what does that mean? It takes a function with input of type [Entry] and output of type Blog?
11:05:07 <ski> yes
11:05:12 <ski> er, no
11:05:14 <benmachine> it *is* a function
11:05:21 <int80_h> this seems to be self-referencial
11:05:26 <ski> `Blog' doesn't take a function. it *is* a function itself
11:05:32 <int80_h> ah
11:05:37 <benmachine> int80_h: ah, this is because types and constructors are allowed to have the same name
11:05:49 <benmachine> int80_h: Blog-the-type is not the same as Blog-the-function
11:05:56 <ski> apparently there is a definition somewhere like
11:06:04 <int80_h> damn. okay I'm with it now, but that is confusing.
11:06:04 <ski>   data Blog = Blog [Entry]
11:06:11 * ski would have preferred
11:06:14 <ski>   data Blog = MkBlog [Entry]
11:06:22 <ski> in that case we'd have had
11:06:29 <ski>   MkBlog :: [Entry] -> Blog
11:06:30 <ski> and so
11:06:35 <ski>   MkBlog entries :: Blog
11:06:42 <ski> ok ?
11:07:14 <int80_h> okay . yes. continue please, from the line where you discuss the type of Blog
11:07:35 <aristid> the kind of Blog is *
11:07:49 <benmachine> shh about kinds for now :P
11:08:08 <monochrom> beware of information overload
11:08:39 <ski> so, using the data constructor `Blog' (which i'd prefer were named `MkBlog' or something like that), we convert `entries', which have type `[Entry]' into `Blog entries' (alt. `MkBlog entries') of type `Blog' (which is the type (constructor), not the data constructor)
11:08:41 <int80_h> yeah, I'm jumping ahead trying to understand monads when I haven't gotten all the basics yet. heh
11:08:55 <EvanR-work> Cale: you there?
11:09:19 <int80_h> ski: okay I'm following so far
11:09:23 <ski> then, since
11:09:27 <ski>   toWaiApp :: (Yesod y, YesodSite y) => y -> IO Application
11:09:34 <ski> which in our case simplifies to
11:09:37 <monochrom> fictional log of #math for the sake of analogy: "<kid> hi how to solve x+3=4?" "<adult> do you know group theory?"
11:09:38 <ski>   toWaiApp :: Blog -> IO Application
11:09:39 <int80_h> wait please
11:09:41 <ski> (agree with that ?)
11:09:56 <benmachine> monochrom: but group theory is so cool!!
11:10:02 <kmc> monads mo problems
11:10:04 <int80_h> I want to express the above (the first expression) into english. Let me give it a try.
11:10:15 <ski> sure, ok
11:10:34 <mauke> comoney, coproblems
11:10:42 <int80_h> toWaiApp is a function with type...ugh the => messes me up I don't know what that means.
11:11:08 <ski> just ignore the `(Yesod y, YesodSite y) => ' on the first reading .. then you can add what it means afterwards
11:11:29 <beutdeuce> benmachine: if i would re-write the block as do{ p <- string s; return f}, would f be passed the string parser ?
11:11:57 <ski> beutdeuce : no
11:11:58 <benmachine> beutdeuce: no
11:12:04 <int80_h> ah then toWaiApp is a function that takes input of any type and gives output of type IO Application
11:12:11 <ski> yes
11:12:23 <int80_h> what does the => part mean?
11:12:27 <ski> now, the `(Yesod y, YesodSite y) => ' is a constraint on what type `y' can actually be
11:12:35 <ski> since it can't actually be *any* plain old type
11:12:49 <benmachine> beutdeuce: if the parse suceeds, p will equal s, but then you don't use p anyway
11:12:49 <beutdeuce> benmachine: do p <- e1; e2  =        e1 >>= \p -> e2, no?
11:12:51 <int80_h> so y is a tuple?
11:13:03 <benmachine> beutdeuce: yes
11:13:15 <int80_h> whose first value is of type Yesod, and second value is of type YesodSite?
11:13:18 <ski> not exactly (the tuple-like syntax there might be somewhat misleading, i suppose)
11:13:20 <benmachine> beutdeuce: but if e2 doesn't use p anywhere it's just discarded :)
11:13:33 <beutdeuce> benmachine: ah, right, k, makes sense
11:13:37 <beutdeuce> thnx
11:13:45 <int80_h> ski: could you correct my understanding then?
11:13:52 <ski> int80_h : `toWaiApp' is a function that takes one argument (not two or more), since there's only one `->' in the type
11:14:04 <ski> let's look at a simpler example
11:14:14 <ski>   negate :: Num a => a -> a
11:14:14 * hackagebot graph-rewriting-ski 0.5 - Two implementations of the SKI combinators as interactive graph rewrite systems  http://hackage.haskell.org/package/graph-rewriting-ski-0.5 (JanRochel)
11:14:18 <ski> > negate 42
11:14:19 <lambdabot>   -42
11:14:21 <ski> > negate (-7)
11:14:23 <lambdabot>   7
11:15:01 <ski> here, `negate' is a function that will take an argument of any type, call it `a', and return a result of type `a'
11:15:14 <ski> however, because of the `Num a => ', the `a' can't actually be *any* type
11:15:16 <ski> e.g.
11:15:22 <ski> > negate 'x'
11:15:23 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:15:23 <lambdabot>    arising from a use of `GHC....
11:15:25 <ski> doesn't work
11:15:54 <ski> the point is that `Num a => ' here expresses that the actual type `a' used must conform to the `Num' "interface"
11:15:55 <int80_h> > :t negate
11:15:56 <lambdabot>   <no location info>: parse error on input `:'
11:16:12 <ski> which in this case means that it must be a numeric type (more or less)
11:16:29 <int80_h> hold on trying to get negates type to look at
11:16:40 <mauke> <ski>   negate :: Num a => a -> a
11:16:49 <int80_h> ski: okay I see
11:16:49 <ski> e.g. the types `Int',`Integer',`Float',`Double',`Rational',`Complex Double' all are in class `Num'
11:16:53 <ski> @src Num
11:16:54 <lambdabot> class  (Eq a, Show a) => Num a  where
11:16:54 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:16:54 <lambdabot>     negate, abs, signum     :: a -> a
11:16:54 <lambdabot>     fromInteger             :: Integer -> a
11:17:19 <beutdeuce> what was that tool that unwraps operations such as (.) into more verbose calls?
11:17:19 <ski> any type `a' which supports `Num' has to provide implementations of those above functions
11:17:37 <ski> (also, it must already support the `Eq' and `Show' interfaces)
11:17:38 <benmachine> beutdeuce: lambdabot has @unpl
11:17:47 <benmachine> @unpl join (f . g)
11:17:48 <lambdabot> ((\ e -> f (g e)) >>= \ a -> a)
11:17:55 <beutdeuce> benmachine: ah, k, thnx
11:18:01 <int80_h> ski: let's go into haskell-overflow
11:18:16 <benmachine> @unpl join . (f . g)
11:18:17 <lambdabot> (\ c -> (f (g c)) >>= \ d -> d)
11:18:24 <beutdeuce> @unpl ([1,2,3,4,5] return . sqrt
11:18:24 <lambdabot> Unbalanced parentheses
11:18:29 * benmachine blinks
11:18:30 <beutdeuce> @unpl [1,2,3,4,5] return . sqrt
11:18:31 <lambdabot> (\ c -> [1, 2, 3, 4, 5] return (sqrt c))
11:18:37 <ski> int80_h : the reason  negate 'x'  doesn't work is that `Char' is not an instance of `Num' .. i.e. it doesn't support the `Num' "interface"
11:18:42 <ski> int80_h : ok
11:18:50 <benmachine> beutdeuce: are you missing a >>= there?
11:19:15 <beutdeuce> benmachine: no, though i have no idea how that operation works (and it does)
11:19:28 <beutdeuce> > [1,2,3,4,5] return . sqrt
11:19:29 <lambdabot>   Couldn't match expected type `t -> a -> b'
11:19:29 <lambdabot>         against inferred type `[...
11:19:31 <beutdeuce> hm
11:19:38 <beutdeuce> oh, yes
11:19:44 <beutdeuce> my bad, >>=
11:19:47 <beutdeuce> i was missing that
11:19:47 <benmachine> :)
11:20:00 <beutdeuce> > [1,2,3,4,5] >>= return . sqrt
11:20:01 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979]
11:20:11 <beutdeuce> @unpl [1,2,3,4,5] >>= return . sqrt
11:20:12 <lambdabot> (([1, 2, 3, 4, 5]) >>= \ c -> return (sqrt c))
11:20:39 <beutdeuce> im confused o.0
11:20:50 <benmachine> beutdeuce: why?
11:21:09 <zygoloid> @@ @do @unpl [1,2,3,4,5] >>= return . sqrt
11:21:10 <lambdabot>  (do { c <- ([1, 2, 3, 4, 5]); return (sqrt c)})
11:21:38 <monochrom> @do [1,2,3,4,5] >>= return . sqrt
11:21:39 <zygoloid> @@ @pl @undo @do @unpl [1,2,3,4,5] >>= return . sqrt
11:21:39 <lambdabot> do { a <- [1, 2, 3, 4, 5]; (return . sqrt) a}
11:21:39 <lambdabot>  sqrt `fmap` [1, 2, 3, 4, 5]
11:21:51 <zygoloid> :)
11:22:02 <beutdeuce> wait, so a list is a container that is an instance of Monad
11:22:11 <zygoloid> beutdeuce: that is correct.
11:22:30 <beutdeuce> @type (<-)
11:22:31 <lambdabot> parse error on input `<-'
11:22:37 <beutdeuce> hm
11:22:42 <benmachine> beutdeuce: <- is part of do-notation, it's special
11:22:42 <Silvah> It's not a function.
11:22:49 <beutdeuce> ah
11:23:03 <benmachine> just like -> is special because it's used in case and lambda
11:23:12 <beutdeuce> i see, what does it do?
11:23:25 <zygoloid> beutdeuce: it's just sugar
11:23:26 <monochrom> it is just syntax. does nothing.
11:23:34 <zygoloid> @undo do x <- v; f x
11:23:34 <lambdabot> v >>= \ x -> f x
11:23:37 <zygoloid> beutdeuce: ^^ for that
11:23:39 <monochrom> just like "o" does nothing in "do"
11:23:41 <Makoryu> @undo do { foo <- bar; baz foo } -- beutdeuce
11:23:41 <lambdabot> bar >>= \ foo -> baz foo
11:23:51 <deech> Is there any documentation (aside from Haddock) on the HTTP library?
11:23:52 <Silvah> Let me guess... yet another person trying to understand monads?
11:24:06 <benmachine> Silvah: another person trying to understand haskell :P
11:24:18 <benmachine> not a straightforward task!
11:24:34 <beutdeuce> @unpl c <- [1,2,3,4,5]
11:24:34 <lambdabot>  Parse error at "<-" (column 3)
11:24:45 <Silvah> Well, Haskell is simple.
11:24:55 <monochrom> I don't know of any doc of the HTTP library apart from its haddock
11:25:04 <beutdeuce> Silvah: it actually is, just requires a shift in thought
11:25:12 <Makoryu> beutdeuce: (<-) is not valid syntax outside of certain types of expressions
11:25:39 <Lemmih> But you need to be a genius to understand its simplicity.
11:26:27 <kmc> i don't think Haskell is that simple
11:26:55 <deech> Haskell is simple and really hard.
11:26:57 <kmc> i think there's a steep learning curve, and some of it is due to carrying over ideas from other languages, but a lot isn't
11:27:08 <beutdeuce> ok, since list is a monad, one can work with it in a do block, right?
11:27:08 <monochrom> Reductionism does not work for learning programming languages. You have to work with each whole construct at a time. You can't pick out a single symbol and expect it to make sense alone.
11:27:16 <kmc> beutdeuce, yes
11:27:29 <Makoryu> beutdeuce: Yep. In fact, you can rewrite list comprehensions in do notation
11:27:31 <kmc> > do { x <- [1,2,3]; y <- [10,20,30]; return (x+y) }
11:27:32 <lambdabot>   [11,21,31,12,22,32,13,23,33]
11:27:40 <kmc> > [ x+y | x <- [1,2,3]; y <- [10,20,30]]
11:27:41 <lambdabot>   <no location info>: parse error on input `;'
11:27:43 <Makoryu> beutdeuce: In fact, IIRC, do notation is based on list comprehensions :p
11:27:46 <kmc> > [ x+y | x <- [1,2,3], y <- [10,20,30]]
11:27:47 <lambdabot>   [11,21,31,12,22,32,13,23,33]
11:27:55 <beutdeuce> > what is the result of x after x <- [1,2,3] ?
11:27:56 <lambdabot>   <no location info>: parse error on input `of'
11:28:06 <mauke> beutdeuce: 1 and 2 and 3
11:28:10 <kmc> beutdeuce, a nondeterministic choice of 1, 2, or 3
11:28:11 <beutdeuce> mauke: a list?
11:28:12 <EvanR-work> monochrom: i hypothesize that a good way to learn from the ground up is to start with a web browser or compiler as the goal, and decompose it until each part is covered in detail
11:28:14 <monochrom> > do { x<-[1,2,3]; return x }
11:28:15 <lambdabot>   [1,2,3]
11:28:20 <mauke> beutdeuce: no, every value at the same time
11:28:20 <Silvah> List comprehension worked for all monads once, didn't it?
11:28:25 <beutdeuce> mauke: ah, ok, makes more sense
11:28:29 <beutdeuce> how does that work?
11:28:30 <ksf> ...both are based on simple funcitons.
11:28:35 <mauke> beutdeuce: it loops
11:28:36 <kmc> beutdeuce, the functon on the RHS of (>>=) gets called more than once
11:28:55 <beutdeuce> what would be the type signature of x after x <- [1,2,3] ?
11:28:59 <ksf> do-syntax on >>= etc. and comprehensions into concatMap
11:29:00 <kmc> Int or so
11:29:09 <kmc> do { x <- [1,2,3]; f x }   ==>  [1,2,3] >>= (\x -> f x)
11:29:11 <victor27> hey, I new to the language (reading Real World Haskell), only know java(beginner - intermediate) at the moment. Are value constructors comparable to constructors in java classes??
11:29:17 <Silvah> > concatMap (:[]) [1, 2, 3]
11:29:18 <lambdabot>   [1,2,3]
11:29:19 <kmc> victor27, only a little bit
11:29:20 <mauke> victor27: not really
11:29:44 <mauke> victor27: java constructors are initializers: the object already exists, they just set some values
11:29:47 <kmc> victor27, imo it's best to forget most of what you know about other languages when learning Haskell
11:29:48 <beutdeuce> @type concatMap
11:29:49 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
11:29:55 <victor27> k
11:29:58 <kmc> beutdeuce, and so that 'x' is really an argument in a lambda expression
11:30:14 <kmc> beutdeuce, but that function gets called more than once, in this case, because (>>=) for the list monad is (flip concatMap)
11:30:24 <kmc> so it gets called once with x=1 and once with x=2 and once with x=3
11:30:27 <kmc> and each time returns a list
11:30:30 <victor27> so in haskell there is no  concept of object creation?
11:30:35 <kmc> and then (>>=) glues all those lists together
11:30:44 <kmc> victor27, not a useful question to ask, imo
11:30:45 <mauke> victor27: depends on your definition of "object"
11:30:48 <beutdeuce> hm
11:31:10 <kmc> victor27, Haskell is declarative.  we say what things exist, not how to build them
11:31:11 <kmc> kind of
11:31:47 <victor27> k I think I get what you are saying. Will read on, maybe it will click. thanks
11:32:02 <kmc> victor27, and so there's kind of a concept of object creation, and kind of not, depending on what you mean by "object" and "creation" and "concept"
11:32:27 <ksf> kmc, nono that's what formalists do.
11:32:39 <Silvah> So there is or there is no?
11:32:40 <ksf> we _do_ say how to construct things.
11:32:56 <aristid> @remember kmc and so there's kind of a concept of object creation, and kind of not, depending on what you mean by "object" and "creation" and "concept"
11:32:56 <lambdabot> It is stored.
11:33:09 <beutdeuce> I think i understand do blocks and binds, hoorah! (feels so good once you get it)
11:33:10 <aristid> @quote object
11:33:10 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
11:33:19 <aristid> @quote object.*creation.*concept
11:33:19 <lambdabot> kmc says: and so there's kind of a concept of object creation, and kind of not, depending on what you mean by "object" and "creation" and "concept"
11:33:37 <victor27> thanks kmc I think I will learn more and get a more informed perspective. You answered the question I had originally.
11:34:13 <kmc> :)
11:35:14 <Silvah> We should finally find a less frightening name than "Monad".
11:35:28 <EvanR-work> how about Danom
11:35:43 <dafis> Dyad
11:35:49 <Makoryu> Silvah: http://groups.google.com/group/clojure/browse_thread/thread/0d429ea3bb13e2a0# <- How about DataStructure （　°‿‿°）
11:35:54 <Silvah> Trolloc?
11:36:25 <aristid> how about ApplicativeWithJoin :P
11:36:30 <EvanR-work> Imperator
11:37:23 * hackagebot hslua 0.3 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3 (GracjanPolak)
11:37:28 <beutdeuce> so, to make sure i understand, >>= takes a type 'a' (where a is an instance of Monad), it disassembles it (well, it allows one to work with the value of 'a' with regular functions), and then it returns this (monadic?) value. One could then use return to assemble the a again? Meh, not sure how to explain it
11:37:42 <cemerick> I thought I'd drop in and apologize for any irritation re: the absurd clojure "vs." haskell junk that's flown around today.  I'm afraid a tweet of mine may have prompted the proggit and hn threads (though they probably would have happened anyway).
11:37:47 <Silvah> MonoidalEndofunctor?
11:38:04 <Silvah> Er, nope, it's even worse than Monad.
11:38:53 <jmcarthur> cemerick: now we have to crucify you
11:39:06 <EvanR-work> beutdeuce: yes
11:39:08 <cemerick> jmcarthur: that's what I came here for! ;-)
11:39:14 <Makoryu> cemerick: When you take credit for something like that, you're supposed to pretend you were trolling all along and act like you're proud of it ;)
11:39:38 <monochrom> cemerick: don't worry, I am not a tiny bit irritated. I don't read twitter, proggit, or hn. Completely not disturbed. (What is hn anyway?)
11:39:41 <EvanR-work> beutdeuce: of course the disassembling part may not fully evaluate the a in m a
11:39:52 <jmcarthur> monochrom: hn = hacker news
11:39:53 <cemerick> Makoryu: I don't have the stones to play the asshole.
11:39:53 <EvanR-work> unless you are in a strict context, like IO
11:40:08 <beutdeuce> EvanR-work: hm, k
11:40:24 <Makoryu> cemerick: For a second I parsed that as if you were talking about a musical instrument. Now I must go invent that.
11:40:28 <jmcarthur> cemerick: sounds painful to pass anyway
11:40:32 <EvanR-work> beutdeuce: basically >>= is there to combine two actions into a bigger action
11:40:35 <Makoryu> cemerick: Once more you are a hero and a fount of inspiration
11:42:01 <cemerick> Makoryu: once more? :-)
11:42:45 <Runar> beutdeuce: >>= takes an (m a) ("a value of a in an environment m"), and a function that transforms a to b, returning (m b), its result in a (possibly modified) environment.
11:42:57 <Runar> beutdeuce: Have you looked at an implementation of >>= ?
11:43:38 <beutdeuce> > do { x <- [1,2,3,4,5]; return $ (\valueofainx -> valueofainx * valueofainx) x }
11:43:39 <lambdabot>   [1,4,9,16,25]
11:43:41 <beutdeuce> woot
11:44:22 <monochrom> value faux?
11:44:25 <cemerick> Anyway, I just wanted to drop off a valentine to #haskell from the Clojure world, e.g. http://twitter.com/cemerick/status/18990079169 and http://groups.google.com/group/clojure/msg/32b11b22ec104d4d Happy currying. :-)
11:45:46 <beutdeuce> > [1,2,3,4,5] >> return 1 --whoa whoa whoa, hold on, why did this happen?
11:45:47 <lambdabot>   [1,1,1,1,1]
11:45:51 <kmc> 'it's obvious that no Haskell 
11:45:51 <kmc> programmer UNDERSTANDS the language, especially the type system.'
11:46:11 <dafis> who said that?
11:46:11 <EvanR-work> beutdeuce: >> ignores the input
11:46:23 <kmc> someone on the internet who is wrong
11:46:25 <beutdeuce> EvanR-work: but why does it return a list of the same shape populated with 1's ?
11:46:42 <dafis> kmc: have you corrected him/her?
11:46:44 <mauke> beutdeuce: because it loops over [1,2,3,4,5] and returns 1 each time
11:46:46 <EvanR-work> beutdeuce: i dont know, whats does >>= mean for lists ;)
11:46:57 <kmc> dafis, no, rich hickey already did
11:47:01 <Gracenotes> is just so happens that >>= for lists is very much like concatMap
11:47:07 <dafis> For lists, (>>=) is concatMap
11:47:11 <Gracenotes> just flipped
11:47:13 <ksf> it is, in fact, flip concatMap
11:47:28 <EvanR-work> suddenly i love the list monad
11:47:36 <EvanR-work> i just got finished doing a shit load of concat maps
11:47:40 <Gracenotes> @type (>>=)
11:47:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:47:56 <Gracenotes> [a] -> (a -> [b]) -> [b]
11:48:02 <beutdeuce> mauke: EvanR-work oh, so return 1 sends 1 to the same monad [1,2,3,4,5] is in, which is a list of size 5
11:48:15 <mauke> beutdeuce: no
11:48:29 <Gracenotes> > concatMap (\_ -> [1]) [1, 2, 3, 4, 5]
11:48:30 <lambdabot>   [1,1,1,1,1]
11:48:54 <dafis> beutdeuce: [1,2,3,4,5] >> return 1 is concatMap (\_ -> [1]) (1,2,3,4,5]
11:49:28 <ksf> > [1,2,3,4,5] >> [1,2]
11:49:28 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
11:49:57 <ksf> > [1,2,3,4,5] >>= replicate [1]
11:49:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:49:58 <lambdabot>         against inferred type ...
11:50:04 <ksf> > [1,2,3,4,5] >>= flip replicate [1]
11:50:05 <lambdabot>   [[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1]]
11:50:15 <beutdeuce> @type flip
11:50:16 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:50:20 <EvanR-work> > [1,2,3,4,5] >> ['c']
11:50:21 <ksf> > length ([1,2,3,4,5] >>= flip replicate [1])
11:50:21 <lambdabot>   "ccccc"
11:50:22 <lambdabot>   15
11:50:22 <Gracenotes> oh eesh
11:50:38 <ksf> which is a roundabout way to implement sum.
11:50:48 <Gracenotes> beutdeuce: the type of flip is (a -> b -> c) -> (b -> a -> c)
11:51:04 <monochrom> > [3,2,1] >>= \_ -> ['a','b'] >>= \_ -> return 0
11:51:05 <lambdabot>   [0,0,0,0,0,0]
11:51:16 <beutdeuce> Gracenotes: using words, how does flip work?
11:51:18 <monochrom> figure out why there are six 0's.
11:51:25 <EvanR-work> @src flip
11:51:26 <lambdabot> flip f x y = f y x
11:51:28 <ksf> beutdeuce, flip the first two arguments.
11:51:49 <Gracenotes> subtract 10 4 == flip subtract 4 10
11:52:07 <beutdeuce> why would u use it in the first place, if you can just flip them yourself?
11:52:15 <ksf> I can't.
11:52:18 <ksf> :t replicate
11:52:19 <lambdabot> forall a. Int -> a -> [a]
11:52:24 <monochrom> I am not going to flip things myself.
11:52:25 <ksf> it took them in the wrong order.
11:52:51 <ksf> well, I could've written a lambda, but that's not pointless.
11:52:52 <pickles1> gar, someone's logged on as my nick
11:53:02 <EvanR-work> beutdeuce: you might not have control over the entire system, higher order functions will pass them a certain way, rather than configuring every higher order function you configure your given input function
11:53:03 <Gracenotes> pickles1: didn't you register it?
11:53:07 <pickles1> which is registered, last i checkd, anyone have any suggestions?
11:53:13 <pickles1> (sorry, off topic i know)
11:53:17 <pickles1> i registered pickles
11:53:18 <Gracenotes> try ghosting them
11:53:19 <mauke> pickles1: 1) log in 2) release the nick
11:53:24 <pickles1> hm
11:53:28 <Gracenotes> /msg nickserv help ghost
11:53:32 <pickles1> thx
11:53:34 <beutdeuce> hm
11:53:34 <ksf>  /msg nickserv ghost pickles
11:53:37 <beutdeuce> i see
11:53:37 <mauke> /msg nickserv help release
11:53:57 <Gracenotes> release is probably nicer than ghost
11:54:00 <EvanR-work> pickles1: interface vs implementation
11:54:01 <beutdeuce> brb later
11:54:50 <Gracenotes> not too much too concentrated I hope
11:54:57 <EvanR-work> i cringe whenever i see single procedures in js or php which take a giant configuration object
11:55:06 <pickles1> EvanR-work: i know, it's the principle of it tho :(
11:55:22 <EvanR-work> break the thing up into many smaller composable functions
11:55:40 <Gracenotes> do you also cringe when you see a ReaderT monad? -.-
11:55:54 <EvanR-work> yes
11:56:02 <Polarina> Is there any possibility of creating 64-bit Windows binaries with GHC?
11:56:04 <Gracenotes> heretic D:
11:56:10 <monochrom> xmonad takes a giant configuration object
11:56:24 <monochrom> ghc api takes a giant configuration object
11:56:49 <monochrom> parsec tokenizer takes a giant configuration object
11:56:54 <EvanR-work> at least with Reader the whole system can get the config without explicitly passing it around, so you have the ability to use many smaller functions to define the monstrosity
11:57:56 <EvanR-work> the equivalent of js or php is to split it up and pass the smaller configs to the components
11:58:15 <EvanR-work> or put the whole bitch in a single procedure
11:58:24 <monochrom> have fun: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/GHC.html#v%3ADynFlags
11:58:30 <msieradzki> you can write bad code in every language
11:59:20 <EvanR-work> you get more configurability by decomposing it
12:00:04 <Gracenotes> monochrom: o nos
12:01:51 <monochrom> fortunately parseDynamicFlags does almost everything for you.
12:05:58 <pickles1> hm, now it says "pickles" is temporarily unavailable
12:06:17 <mauke> pickles1: you need to release it again
12:07:07 <pickles> woot
12:07:09 <pickles> thx
12:07:19 <kakos> msieradzki: Good programmers will write good code and bad programmers will write bad code, but for a good programmer to write bad code – that takes Perl.
12:07:20 <pickles> (sry for off topic)
12:07:35 * EvanR-work ponders the semantics of perl
12:07:47 <pickles> would this be perls of wisdom from kakos?
12:07:59 <mauke> haters gonna hate
12:09:00 <pickles> i just did some C++ today for the first time in years
12:09:03 <pickles> it felt dirty
12:09:26 <EvanR-work> D:
12:10:01 <pickles> ironic, since i've been doign pure C for the past couple of weeks, feeling fine
12:10:17 <EvanR-work> totally different beasts
12:10:23 <pickles> mhm
12:10:41 <EvanR-work> c without side effects?
12:10:43 <pikhq> C is old. C++ makes the mistakes of old and adds its own. Totally different.
12:11:02 <Polarina> Is there anything similar to HGL (portable and simple), however, a lot more powerful and featureful?
12:11:02 <pickles> embedded C, so side effects required :(
12:11:13 <pickles> made it nice and modular tho
12:12:20 <Polarina> kakos, ... and Haskell.
12:14:13 <zygoloid> you get more disfigurability by it decomposing
12:14:34 <zygoloid> :o
12:14:56 <zygoloid> paste buffer fail ;(
12:19:39 <benmachine> hmm, I have a C function that allocates some memory, invokes a haskell callback, and then frees the memory
12:20:01 <benmachine> could the haskell callback prevent the memory being freed if it e.g. throws an exception?
12:20:30 <pikhq> Uh, I'm going with "yes".
12:20:49 <benmachine> so exceptions can propagate 'through' C code?
12:21:03 <benmachine> ho hum
12:21:12 <mauke> I don't think that's legal
12:21:23 <benmachine> mauke: that?
12:21:47 <illissius`> iirc if you throw an exception in a callback and don't catch it, the behaviour is undefined
12:21:54 <benmachine> oh right
12:21:56 <illissius`> (which probs means 'it crashes')
12:21:59 <benmachine> hmm
12:22:06 <benmachine> well, I can find out I guess
12:22:12 * benmachine tries to cook a testcase
12:23:09 <illissius`> anyway, the other way the haskell callback could prevent it from being freed, besides crashing, is if it never returned
12:23:34 <benmachine> yes but that's not exactly a memory leak
12:23:39 <illissius`> basically if it's bottom :) i don't think you can throw C++-style exceptions from within haskell
12:23:49 <benmachine> because the callback is presumably using the memory somehow
12:23:58 <benmachine> forever
12:24:07 <illissius`> right
12:24:36 <benmachine> I'm just trying to establish how likely a non-local exit from a haskell callback is
12:24:43 <benmachine> err, I think non-local exit is the term
12:24:58 <jystic> anyone know how i can get a list of the IPv4 addresses of the current computer (in haskell)?
12:25:15 <illissius`> i don't think it's possible but maybe I'm just not being imaginative enough...
12:25:36 <pokes> like more than 1 ipv4 address?
12:25:53 <jystic> well, if i have 2 network cards yeah
12:26:01 <illissius`> I mean, I guess the haskell code could foreign import longjmp, but...
12:26:03 <jystic> it's ok if i get loopback as well
12:26:13 <EvanR-work> you can have more than one ip address with only one network card
12:26:14 <benmachine> illissius`: that sounds evil, heh
12:26:18 <illissius`> yeah
12:26:33 <kmc> longjmp is likely to be a disaster
12:26:34 <jystic> EvanR-work: and in that case knowing both would be good
12:26:39 <benmachine> it's probably possible for me to just eliminate the allocation
12:26:40 <kmc> GHC code doesn't really use the C stack in a conventional way
12:26:46 <pokes> jystic: what platform?
12:26:49 <benmachine> currently I'm using vasprintf
12:26:49 <EvanR-work> jystic: theres POSIX
12:26:53 <EvanR-work> hrm
12:26:57 <EvanR-work> well Linux ;)
12:27:04 <benmachine> vsnprintf would probably be fine
12:27:08 <EvanR-work> reading the /proc filesystem
12:27:09 <jystic> hmm, i'd like it to work on windows and linux
12:27:15 <EvanR-work> not likely
12:27:24 <illissius`> benmachine: anyway, point is i don't think the allocation should be a problem
12:28:02 <benmachine> illissius`: I think I'll go see what exactly the FFI spec says about exceptions
12:28:06 <benmachine> but thanks :)
12:28:18 <jystic> i don't mind a different code path for different platforms, but it's not ideal
12:28:27 <illissius`> only way i can see it doesn't end up freed is if (a) you crash, which you shouldn't be doing anyway, or (b) don't return which is not really a problem
12:28:58 <illissius`> (or rather if it crashes it ends up freed, and so does everything else)
12:29:11 <benmachine> probably just writing in the docs "please return from me" is fine :P
12:29:17 <benmachine> illissius`: hah, yeah
12:31:43 <pickles> could the memory be freed in an atexit()?
12:33:47 <Tomsik_> when you finish your app
12:33:59 <Tomsik_> OS automatically frees all the memory it allocated
12:34:15 <Tomsik_> so what's the point of freeing anything atexit?
12:34:17 <pickles> ah, wasn't sure on that, thx
12:34:37 <mauke> Tomsik_: leak checking
12:34:44 <mauke> anything alive after that is a leak
12:35:02 <Tomsik_> well, it sounds like C anyway :p
12:37:39 <EvanR-work> Tomsik_: only to shut up memory debuggers
12:41:22 <Polarina> How do I install wx on Windows (I am using the haskell platform)? It is complaining about "wx-config" being missing.
12:42:10 <dafis> Polarina: you have to install the windows-port of wx-config
12:42:25 <Polarina> dofis, where do I find that?
12:42:36 <dafis> where to get it is mentioned on the wxHaskell wikipage, iirc
12:42:55 <welicious> hi all
12:43:08 <fryguybob> jystic: http://trac.haskell.org/network/ticket/5
12:44:21 <dafis> Polarina: http://sites.google.com/site/wxconfig/
12:44:28 <jystic> fryguybob: thanks for the info
12:44:54 <jystic> i'm running ubuntu at the moment though and i can't get 'getAddrInfo' to give me back anything but the loopback address :(
12:44:55 <pickles> bout time to go to the airport
12:45:02 <pickles> wish me luck on my job interview
12:45:06 <benmachine> hmm, if a thread is making a foreign call, the exception will not be raised until the call has completed
12:45:24 <benmachine> good luck, pickles
12:45:34 <dafis> from me too
12:45:38 <fryguybob> jystic: Humm, I run into what is described in the ticket on windows here.
12:45:41 <EvanR-work> exception from the foreign lib or exception from the runtime
12:46:03 <pickles> thx guys, later
12:46:06 <Polarina> dafis, thanks.
12:49:24 <jystic> fryguybob: getAddrInfo doesn't seem to giving me the details i need though (even on ubuntu), it is returning stuff, but every address is 127.0.0.1
12:51:17 <EvanR-work> jystic: you cant dns lookup your own information unless you are in the dns or the hosts file. the hosts file usually only has 127.0.0.1 in it for localhost
12:51:32 <EvanR-work> so that is not the way to get system information
12:51:48 <EvanR-work> you have to use a os specific api for each os
12:51:54 <jystic> yeah
12:52:25 <jystic> so getAddrInfo is just doing a dns lookup?
12:52:32 <EvanR-work> yes
12:52:38 <EvanR-work> including checking the hosts file
12:52:44 <jystic> ok, well it's never going to work for me
12:52:55 <jystic> thanks
12:52:59 <sproingie> only reliable way i know of is open a connection and use getsockname
12:53:18 <sproingie> since technically "my ip address" depends on where you're trying to go
12:53:30 <ski> @tell Silvah yes, list comprehensions were once monad comprehensions .. sadly that was removed going from Haskell 1.4 to Haskell 98
12:53:30 <lambdabot> Consider it noted.
12:54:01 <ski> Gracenotes : yes. it ought to be a `ReaderT r m' monad, for some `r' and monad `m'
12:54:42 <Gracenotes> hum?
12:54:56 <EvanR-work> mus
12:55:34 <monochrom> "my ip address" is non-unique. you can easily have 2. 3 if you have vpn.
12:55:55 <EvanR-work> on linux you can assign unlimited addresses to an interface
12:56:00 <EvanR-work> you can also have several interfaces
12:56:40 <EvanR-work> i think its the same in windows
12:57:01 * hackagebot graph-rewriting-ski 0.5.1 - Two implementations of the SKI combinators as interactive graph rewrite systems  http://hackage.haskell.org/package/graph-rewriting-ski-0.5.1 (JanRochel)
12:57:13 <ski> (Gracenotes : "do you also cringe when you see a ReaderT monad? -.-")
12:58:17 <Gracenotes> oops, I forget 'monad' has only one meaning
12:58:34 <Gracenotes> classic newbie mistake
12:58:40 <monochrom> you weak-minded people cringe too easily
12:58:50 <EvanR-work> which is defined in terms of mexican entres
12:58:56 <ski> beutdeuce : still wanting to hear about `forall' ?
12:59:14 <beutdeuce> ski: sure, i still dont know what its for or what it does
12:59:30 <ski> well, let's look at e.g.
12:59:34 <ski>   length :: [a] -> Int
13:00:05 <sproingie> most people want the ip address of their default route.  it'd be nice if there was a portable way to get that but no.
13:00:13 <beutdeuce> k
13:00:14 <ski> this says that `length' has type `[a] -> Int', iow that `length' is a function that takes an argument of type `[a]' and returns a result of type `Int'
13:00:37 <beutdeuce> right
13:00:37 <ski> now, you may ask, what is `a' ? (and that's a legitimate question)
13:00:55 <EvanR-work> sproingie: any or all of your interfaces or addresses may be directed to the default route destination
13:00:57 <bnonym> a is not b
13:01:05 <ski> the answer being that `a' can be any type you like, even different in different calls of `length'
13:01:09 <ski> hence
13:01:20 <ski> > (length "abc",length [0,1,2,3])
13:01:21 <lambdabot>   (3,4)
13:01:22 <monochrom> 'a' is a letter in the alphabet.
13:01:22 <ski> is legal
13:01:28 <monochrom> @quote monochrom nth
13:01:29 <lambdabot> No quotes match. :(
13:01:36 <monochrom> @quote monochrom letter
13:01:36 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
13:01:37 <bnonym> monochrom: actually not in every alphabet.
13:01:45 <fryguybob> jystic: On windows if I call getaddrinfo with localhost I get 127.0.0.1, if I call it with my "network name" I get my ip's.
13:01:53 <beutdeuce> right; therefore, length is a polymorphic function
13:01:58 <monochrom> I used to have a quote "n is the nth letter of the alphabet" :)
13:02:10 <ski> beutdeuce : exactly .. now, the above type signature of `length' is the way to write it in Haskell 98
13:02:15 <sproingie> EvanR-work: at which time it would be reasonable to pick one arbitrarily.  usually there's just one
13:02:25 <mauke> preflex: quote monochrom 
13:02:25 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
13:02:28 <ski> now GHC and Hugs (and ...) has an extension, which lets you write
13:02:29 <mauke> preflex: quote monochrom 
13:02:29 <preflex>  <monochrom> n is the nth English letter.
13:02:37 <ski>   length :: forall a. [a] -> Int
13:02:40 <monochrom> nice thanks
13:02:44 <sproingie> EvanR-work: problem is it's hard to find which interfaces are used for default route without actually attempting a connection
13:02:45 <ski> this is just being more explicit
13:02:55 <nolrai_psu> @hoogle :: Monad m => m a -> m b -> m a
13:02:55 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
13:02:55 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
13:02:55 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
13:03:18 <ski> beutdeuce : saying that `length', for any type `a' you (the caller) wants, is a function that takes a list of `a's, and returns an `Int'
13:03:44 <beutdeuce> ski: ah, i see... but what do the asterisks mean?
13:04:14 <ski> beutdeuce : (i'll take that afterwards) .. now you may ask what's the gain of writing the `forall's like that
13:04:26 <ski> the point is that, if we e.g. want to do
13:04:27 <beutdeuce> sure
13:04:42 <benmachine> nolrai_psu: are you looking for something specific?
13:04:50 <ski>   foo f = (f "abc",f [0,1,2,3])  -- a pretty strange example
13:05:05 <ski> here, we want to be able to pass `length' to `foo'
13:05:21 <ski> so that `foo length' simplifies to `(length "abc",length [0,1,2,3])'
13:05:37 <ski> the trouble now is that this isn't allowed by Haskell 98
13:05:54 <beutdeuce> right, so foo :: ([a] -> Int) -> (Int,Int)
13:05:58 <beutdeuce> oh?
13:06:02 <adnap> I have been talking about the FFI with people in here for a few days now.  I was wondering if someone could give me some advice on how to structure the following: I have some Haskell code that generates the vertices and normals of a terrain and I would like to send those vertices to some C++ code for use with an OGRE construct, Manual Object (http://www.ogre3d.org/tikiwiki/ManualObject), which is an object that takes vertices and normals and generates a model 
13:06:10 <ski> the reason is that the same argument `f' is used *polymorphically* within `foo'
13:06:38 <ski> beutdeuce : if you try `foo :: ([a] -> Int) -> (Int,Int)', which means `foo :: forall a. ([a] -> Int) -> (Int,Int)'
13:06:54 <beutdeuce> ruguht
13:06:56 <beutdeuce> right*
13:07:51 <ski> beutdeuce : that means that : for any type `a' the *caller* of `foo' chooses, if you pass a function of type `[a] -> Int', for *that* type `a', then `foo' will return an answer of type `(Int,Int)'
13:08:04 <ski> beutdeuce : but that's not at all what we wanted to do !
13:08:44 <jystic> fryguybob: hmm, it must depend on how the OS handles DNS requests (like EvanR-work) was saying, on my linux box i only get 127.0.0.1 even if i ask for my real hostname
13:08:57 <jystic> oops, like EvanR-work said*
13:09:01 <ski> beutdeuce : what we wanted was more like : if `foo' is given a function of type `[a] -> Int' for any type `a' the *callee* `foo' itself wants, then `foo' will return something of type `(Int,Int)'
13:09:07 <ski> and that is written like
13:09:14 <fryguybob> jystic: Yeah.
13:09:20 <ski>   foo :: (forall a. [a] -> Int) -> (Int,Int)
13:09:32 <ski> note how the argument type there now matches with
13:09:37 <ski>   length :: forall a. [a] -> Int
13:09:46 <benmachine> beutdeuce: a function forall a. ([a] -> Int) -> (Int, Int) could be given "read" as a first argument, even though read only works on String
13:10:01 <ski> now, we're passing the *polymorphic* function `length' to `foo'
13:10:11 <jystic> i've got some C code for obtaining the info under linux, and i've also found some stuff for doing it in windows so i'm just going to wrap it in haskell
13:10:12 <benmachine> (ski: that's right isn't it >_>)
13:10:44 <bewest> I'm trying to install haskell on my lucid ubuntu box
13:11:02 <beutdeuce> oh, i see, so it allows for first-class objects to be polymorphic, not just types
13:11:10 <ski> @type let foo :: forall a. ([a] -> Int) -> (Int, Int); foo = undefined  in  foo read
13:11:12 <lambdabot> (Int, Int)
13:11:19 <deech> Hi all, can someone help me with the HTTP library? I am trying to simply download a web-page. It works with "http://www.google.com"  but when I try a redirecting web-page it dies with an error. The code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27864#a27864. 
13:11:20 <ski> benmachine : ^ yes
13:11:33 <benmachine> awesome
13:11:35 <ski> beutdeuce : yes, let's compare this with
13:11:56 <ski>   filter :: (a -> Bool) -> ([a] -> [a])
13:12:04 <jystic> bewest: are you having some trouble with that?
13:12:07 <ski> let's pass `null' to this
13:12:21 <ski>   null :: forall a. [a] -> Bool
13:12:32 <ski> so, the type of `filter' we're actually using here is
13:12:54 <ski>   filter :: ([a] -> Bool) -> ([[a]] -> [[a]])
13:12:54 <bewest> jystic: yeah, I am.  I've tried several times.  I've actually been very successful at getting xmonad running using justinbogner's ppa
13:13:18 <bewest> it's my understanding that I should be able to install a proper version in say /usr/local/
13:13:30 <bewest> I'm interested specifically in running gitit
13:13:42 <ski> beutdeuce : in this case, since `filter' doesn't want a *polymorphic* argument, the `null' that is actually passed in `filter null xss' is not
13:13:45 <bewest> but it seems easier at this point if I can get a proper non-deb install working with cabal
13:13:46 <ski>   null :: forall a. [a] -> Bool
13:13:47 <ski> but
13:13:52 <ski>   null :: [a] -> Bool
13:13:59 <ski> i.e. a *monomorpic* instance of it
13:14:06 <bewest> jystic: I've cleaned out my /usr/local area after several failed attempts
13:14:22 <ski> (usually, `a' here would also be replaced with some concrete type, like `Catfood')
13:14:27 <jystic> bewest: how are you trying to install it?
13:14:30 <Saizan> bewest: tried the generic linux tarball on www.haskell.org/ghc/?
13:14:47 <jystic> bewest: with lucid i've just used the ghc in the standard ubuntu repositories because it's the latest version
13:15:05 <jystic> and i used cabal to install everything else that i needed
13:15:06 <bewest> jystic: did you do something special to get cabal working?
13:15:15 <jystic> i don't think so
13:15:35 <bewest> Saizan: I should be able to complete the entire process in an arbitrary prefix, yeah? /usr/local, ~/foo?
13:15:37 <proc> howdy, my haskell fellows
13:15:55 <ski> beutdeuce : in any case, to use this `forall' extension, passing polymorphic things to functions, then you *must* explicitly write a type signature for the function (`foo') above, since it's impossible to use type inference in general to determine such types
13:15:57 <jystic> cabal-install is a package in it's own right as well though (in the ubuntu repos)
13:15:58 <bewest> jystic: which packages did you install to start working with cabal?
13:16:15 <Saizan> bewest: ./configure takes a --prefix=, defaults to /usr/local
13:16:22 <beutdeuce> ski: ah, k. thnx
13:16:40 <bewest> Saizan: at that point, I still need a second package, or cabal and everything is ready to go?
13:17:07 <jystic> i think it's just ghc6 and cabal-install
13:17:10 <ski> beutdeuce : btw, pedantically speaking, there are no polymorphic types in Haskell .. only parametric types (like `Maybe' and `[]' and `Either String') .. and also types of polymorphic values, i.e. types of the form `forall a. ..a..'
13:17:29 <ski> beutdeuce : and that brings us to the `*'s, actually !
13:17:58 <jystic> my computer is not vanilla lucid though, i've upgraded from jaunty and i used to have the haskell platform installed from source before this release, it's possibly there's something fishy going on because of that
13:18:01 <Saizan> bewest: you need to install cabal-install separately at that point
13:18:02 <bewest> jystic: no -dev packages?
13:18:04 <beutdeuce> hm
13:18:10 <ski> beutdeuce : note that `Int', and `(Char,Bool)' and `Maybe (Int -> String)' are all "complete" types, i.e. there could possibly be values of such types
13:18:17 <jystic> bewest: no, no -dev packages
13:18:21 <benmachine> ski: how is it that type inference is impossible, but people can work out what annotations to add? people are currently better at working out higher-rank types than GHC?
13:18:21 <bewest> Saizan: from a tarball, not from deb
13:18:24 <jystic> i thought they might cause problems
13:18:37 <Saizan> bewest: right
13:18:48 <sproingie> as i've heard it, there's lots of functions a -> a for some particular a, but 'id' is the only one that's forall a. a -> a
13:19:10 <jystic> i don't need apt-get to manage my haskell packages, cabal does everything
13:19:16 <ski> beutdeuce : otoh, `Maybe' itself, as well as `State GameState', `(Char,)' (written `(,) Char' in Haskell) are *incomplete* types
13:19:21 <bewest> Saizan: ok, again, I should be able to get a hello-world type of state in any arbitrary directory?
13:20:04 <bewest> with the amount of mucking around I've been doing I'm wondering if I should try /usr/local again or go for /my/special/haskell type of thing
13:20:30 <sproingie> i use /opt for that
13:20:31 <Saizan> bewest: there's a --prefix there too, though while using cabal it'll store a bunch of things in ~/.cabal
13:20:32 <ski> beutdeuce : you need to say `Maybe' of *what* ? list of *what* ? a state-monad action with state being `GameState' returning *what* ? the type of pairs whose first component are `Char's and whose second component are *what* ? &c.
13:20:52 <beutdeuce> i see
13:21:00 <jystic> bewest: have you tried just ghc, ghc-doc, ghc-prof, cabal-install? and using cabal from then on
13:21:31 <bewest> jystic: I think so, at this point I've tried several variants of cabal-install from source and from deb
13:21:35 <ski> beutdeuce : i.e. you need to *apply* the *type*function* `Maybe' to the type `Int', apply the type function `[]' to `String', apply the type function `(,) Char' to `Bool', &c.
13:21:50 <bewest> so I'm partly wondering how to ensure I've got a sane environment
13:21:56 <ski> beutdeuce : so, even types have types of their own, of a sort .. this is called "kinds"
13:21:59 <ski> @kind Int
13:22:00 <lambdabot> *
13:22:06 <ski> @kind (Char,Bool)
13:22:07 <lambdabot> *
13:22:12 <ski> @kind (,) Char Bool
13:22:13 <lambdabot> *
13:22:14 <ski> @kind (,) Char
13:22:15 <lambdabot> * -> *
13:22:20 <ski> @kind (,)
13:22:21 <lambdabot> * -> * -> *
13:22:29 <ski> @kind State
13:22:30 <lambdabot> * -> * -> *
13:22:32 <ski> @kind StateT
13:22:33 <lambdabot> * -> (* -> *) -> * -> *
13:22:41 <jystic> bewest: yeah, it's hard to be sure isn't it
13:22:45 <ski> @kind StateT Int (State Bool) String
13:22:46 <lambdabot> *
13:23:09 <bewest> I tried a new config to get xmonad go out of it's way for flash and it seems to error about finding stuff that should be in the contrib package
13:23:11 <beutdeuce> so, ',' is a kind constructor?
13:23:15 <ski> beutdeuce : that's some examples
13:23:25 <ski> yes, `(,)' is a type constructor
13:23:55 <ski> it is the type function that, given a type, and a second type, constructs the type of pairs with components from the two given types
13:23:58 <ski> @type Either
13:23:59 <bewest> I can ask debian to force a reinstall and then use the resulting cabal-install to install itself
13:23:59 <lambdabot> Not in scope: data constructor `Either'
13:24:06 <ski> er
13:24:09 <ski> @kind Either
13:24:10 <lambdabot> * -> * -> *
13:24:17 <bewest> jystic: what prefix are you using when you use cabal?
13:24:23 <bewest> do you use --global or --user?
13:24:30 <benmachine> ski: of a sort, eh
13:24:41 <beutdeuce> interesting, when would one want/need to use kinds? For types that take types? e.g: data List a = Cons a (List a) | Empty ?
13:24:44 <ski> is similar, except instead of giving the type of pairs gives the type of values which can either be of the first given form, or of the second form
13:24:45 <beutdeuce> ski: ^
13:24:46 <jystic> i don't use anything, so i believe that defaults to --user
13:24:48 * benmachine three minutes late to that joke
13:24:55 <bewest> ah, I see
13:25:00 <Tomsik__> @instance Monad [::]
13:25:00 <lambdabot> Maybe you meant: instances instances-importing
13:25:05 <bewest> I would rather cabal not use my home directory
13:25:06 <Tomsik__> @instances Monad [::]
13:25:06 <lambdabot> Couldn't find class `Monad [::]'. Try @instances-importing
13:25:12 <ski> beutdeuce : yes, exactly .. for parametric types aka type functions
13:25:15 <byorgey> beutdeuce: sure, in that case List :: * -> *
13:25:17 <bewest> that's when things get hairy
13:25:34 <jystic> :)
13:25:39 <benmachine> bewest: it tends to be easier to fix things when they break
13:25:40 <Tomsik__> What the heck is [::]
13:25:42 <byorgey> bewest: by default cabal installs stuff in ~/.cabal
13:25:45 <benmachine> bewest: and they tend to break a lot >_>
13:25:53 <benmachine> Tomsik__: data parallel haskell I think?
13:26:03 <Janni> bewest: If you want --global by default, edit .cabal/config
13:26:12 * hackagebot sendfile 0.7.2 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.2 (JeremyShaw)
13:26:12 <bewest> I've been trying to track things in my home directory better
13:26:17 <byorgey> Tomsik__: I think it's the data parallel array constructor, e.g.  [: Int :] is the type of data parallel Int arrays
13:26:30 <bewest> and having the binaries installed in ~/bin gets me messed up
13:26:30 <ski> beutdeuce : the ("generic" /) parametric type `List' allows us to talk about `List Int' and `List (List String)' and `List (Bool,Int -> List Bool)', &c., so we don't have to repeat essentially the same shape in yet new types
13:26:36 <beutdeuce> ah, interesting, but when would you need to explicitly state that List :: * -> *, isn't it implied?
13:26:49 <Janni> bewest: they're installed in ~/.cabal/bin
13:26:54 <jystic> i actually like it in my home directory, that way i know what i've installed via cabal and what came with the standard ubuntu package
13:26:56 <paul424> who could point me to some materials about fixed point theory and ITS applicance in the CS  ? 
13:27:01 <Tomsik__> Where is State monad located? How do I use lambdabot to tell me that?
13:27:10 <Janni> bewest: EVERY thing is under ~/.cabal, so it won't interfere with the rest of your home directory.
13:27:12 <ski> beutdeuce : and, having constructed parametric types, this is what enables us to code *polymorphic* functions such as `reverse :: forall a. List a -> List a', &c.
13:27:23 <byorgey> beutdeuce: yes, most of the time, GHC can infer kinds
13:27:44 <byorgey> beutdeuce: it's never necessary to explicitly declare them unless you are using extensions like type families
13:27:52 <byorgey> then sometimes it can be necessary
13:28:01 <bewest> ok, so I'll try forcing debian to reinstall a couple things, use the resulting cabal-install to update/install itself, and then try again ( install gitit )
13:28:11 <Saizan> or you're using phantom type parameters..
13:28:12 * hackagebot convertible 1.0.9.1 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-1.0.9.1 (JohnGoerzen)
13:28:15 <ski> beutdeuce : yes, `List :: * -> *' is inferred from the definition `data List a = ..a..' .. but it can be good to know its kind, when doing trickier types .. or when you get a kind mismatch error
13:28:27 <jystic> bewest: i'll try to install gitit to see if it works for me
13:28:34 <beutdeuce> ski: benmachine: ah, got it! Thanks :)
13:28:49 <ski> byorgey : fwiw, i usually use them with GADTs ..
13:29:04 <beutdeuce>  byorgey: thnx too
13:29:25 <ski>   data Expr :: * -> *
13:29:27 <ski>     where
13:29:35 <ski>     Eval :: Expr (Expr a -> a)
13:29:36 <ski>     ...
13:29:39 <bewest> jystic: btw, are you using xmonad? if so, did you install it using cabal?
13:29:51 <byorgey> ski: me too, but it still isn't required there
13:29:55 * ski nods
13:29:59 <bewest> rather, how was it installed
13:30:14 <jystic> i'm not, i've been meaning to check it out though
13:30:29 <byorgey> ski: but maybe if you have a GADT indexed by things of kind * -> *, and it couldn't infer the kind from the types of the constructors...
13:31:13 * hackagebot HDBC 2.2.6.1 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.2.6.1 (JohnGoerzen)
13:31:21 <ski> (lately, i've started to use `data Foo a :: * -> * where ...' if the `a' parameter is always given as first argument to `Foo' in the constructor signatures .. thinking of it similarly to how Agda2 does it)
13:31:57 <ski> byorgey : could be, i'm not sure
13:32:10 <ski> beutdeuce : anyway, so in
13:32:13 <ski> @type length
13:32:14 <lambdabot> forall a. [a] -> Int
13:32:20 <ski> that can be written as
13:32:32 <ski>   length :: forall (a :: *). [a] -> Int
13:33:00 <ski> except that the kind `*' is assumed, if nothing else is said and the rest of the type doesn't force anything else
13:33:05 <ski> that should now explain
13:33:12 <ski> @type (>>=)
13:33:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:33:18 * paul424 asks who could point him to some materials about fixed point theory and ITS applicance in the CS  ?
13:33:26 <ski> beutdeuce : ^
13:33:32 <beutdeuce> mh
13:33:57 <Janni> Anybody knows a (very simple) tool, that extracts named chunks of code out of your source file? Suppose I have a bunch of .hs files and I want to "mark" parts of the code such that I can use it as example code for some document or a website and whenever I think that the code in the doc or the website should be updated I can simply run the tool that extracts these chunks out of the current version of the code. It is important for me that the marking of
13:34:17 <ski> @type let bind :: forall m a b. Monad m => m a -> (a -> m b) -> m b; bind = (>>=) in bind
13:34:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:34:31 <fffej> janni - use literal haskell and wrap custom delimters around it and a quick script?
13:34:36 <Janni> It's trivial to implement such a thing myself, but that's why it's boring.
13:34:59 <ski> beutdeuce : note that here the kind `* -> *' can actually be inferred (from how `m' is used in the type), but GHC apparently still wants to be verbose
13:35:12 <benmachine> Janni: your message got cut off after "It is improtant for me that the marking of"
13:35:22 <Janni> fffej: Yes, of course (literate Haskell wouldn't even be necessary)....
13:35:48 <Janni> benmachine: Hmm. Is that my client, freenode, #haskell, or your client?
13:36:00 <jystic> Janni: cut off for me too
13:36:08 <ski> Janni : the IRC protocol
13:36:14 <beutdeuce> ski: i had to pass a special argument to ghc to read forall, that is normal, right?
13:36:17 <Peaker> Anyone know how Cilk compares to nested data parallelism?
13:36:17 <ski> (it is broken in this regard)
13:36:21 <Janni> Not too important, but "It is important for me that the marking of the chunks can reside inside comments such that the
13:36:22 <Janni> +original files are valid Haskell (that's what rules out the tool Shuffle, I think)."
13:38:14 <ski> beutdeuce : yes, `-XRank2Types' (or s/2/N/) as an argument to ghc[i], or `{-# LANGUAGE Rank2Types #-}' at the top of your module
13:38:40 <beutdeuce> thnx
13:39:05 <ski> (beutdeuce : inside ghci, you can also enable it by `:set -XRank2Types')
13:39:19 <beutdeuce> oh, k, thats helpful
13:39:36 <ski> the difference between `Rank2Types' and `RankNTypes' types is that with the former you can only do things like
13:39:47 <ski>   foo :: (forall a. ..a..) -> ...
13:39:49 <ski> but not
13:39:58 <ski>   foo :: ((forall a. ..a..) -> ...) -> ...
13:40:10 <beutdeuce> k
13:40:20 <ski> but with the latter, you can nest your `forall's how far deep inside the left of `->'s you like
13:40:45 <ski> also note that these things also apply to type declarations, like
13:40:51 <Tomsik__> by the way, I recall something called "positive" and "strictly positive" types, is there anything about that in haskell?
13:41:18 <ski>   data Foo f = MkFoo (forall a b. f (a,b) -> f (b,a))
13:41:44 <aristid> i wish the typeclass Monad was defined in terms of join instead of (>>=)
13:41:58 <ski> (i.e. the data constructors of data types can have types like `MkFoo :: forall f. (forall a b. f (a,b) -> f (b,a)) -> Foo f', now)
13:42:01 <beutdeuce> ski: cool
13:42:12 <conal> aristid: me too.  join fits my brain much better than (>>=)
13:42:16 <Peaker> aristid, yeah that's more fundamental, probably.. optional one would be nicer
13:42:27 <jystic> bewest: gitit seemed to install fine for me, best of luck getting everything going, it's bed time for me!
13:42:40 <bewest> nice
13:42:44 <bewest> thanks jystic
13:42:45 <ski> aristid : i've often wished both `join' and `(>>=)' were available as methods in it .. preferably defined in terms of each other (which would require the `Functor' superclass)
13:42:54 <bewest> now it's clear that I have indeed messed things up
13:42:56 <Peaker> ski, Applicative :)
13:43:15 <EvanR-work> >>= seems straight forward, is join better?
13:43:17 <ski> beutdeuce : that is sometimes useful, though i can't come up with any simple example rn
13:43:24 <ski> Peaker : yes, directly or indirectly
13:44:01 <Peaker> EvanR-work, >>= is a composition of fmap and join, so when implementing >>= you are in a sense implementing both, rather than just one..  If you look at most >>= implementations they worry about both "flattening" the (m (m a)) to (m a) and applying the given function
13:44:02 <ski> EvanR-work : for `data Tree a = Leaf a | Branches [Tree a]' (e.g.), `join' is somewhat more natural
13:44:14 <BMeph> Janni: "long" comments would work, too. I.e., {- <insert meaningful annotation here> -}
13:44:27 <applicative> It seems to me they suit different ways of thinking.  >>= goes with a picture of a process, feeding values derived to the next thing. 
13:44:37 <ski> *nod*
13:45:02 * BMeph thinks "join" is 'straightforwarder' than '>>='...
13:45:15 <aristid> when trying to reason about the (r ->) instance of Monad, (>>=) is making it very hard for me
13:45:19 <aristid> @src (->) (>>=)
13:45:19 <lambdabot> f >>= k = \ r -> k (f r) r
13:45:26 <applicative> join goes with a different picture like the one used in metaphors of 'lift' or idiom etc.
13:45:46 <ski> Peaker : however, barring deforestation, `(>>=)' is often more efficient than `join' & `fmap' / `liftM'
13:45:48 <Janni> BMeph: Hmm, meaningful annotations are not a problem, I just wanted to know if anybody could recommend a tool to me that would extract chunks of code based on these annotations...
13:45:53 <Janni> But still, thanks.
13:46:37 <ski> @type \f k r -> (f >>= k) r
13:46:38 <lambdabot> forall a b t. (Monad ((->) t)) => (t -> a) -> (a -> t -> b) -> t -> b
13:48:00 <BMeph> Janni: Depending on what you wanted to do after extraction - and besides it, too, I guess, 'grep' should do fine. ;)
13:48:39 <bewest> I've managed to tell the debian install to include modules from my /usr/local install
13:49:06 <Janni> BMeph: Yeah, seems I have to hack together s.th. myself. I was just hoping there was some tool that could handle Haskell comments (in different ways), understand module structure etc.
13:49:09 <BMeph> @type \ f k  r -> k (f r) r
13:49:10 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
13:49:21 <bewest> causes ghc-pkg check -v3 to print: exec: 4: /usr/local/lib/ghc-6.10.1/ghc-pkg: not found
13:51:33 <applicative> I often want something equivalent to " join (f <$> x)", -- e.g. join (writeFile "backward.txt" . reverse <$> readFile "forward.txt")
13:52:12 <aristid> :t \f x -> join (f <$> x)
13:52:13 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a -> m a1) -> m a -> m a1
13:52:24 <magicman> That's (x >>= f)
13:52:25 <applicative> that fits with a picture of raising (here into IO) and lowering, but its  writeFile "backward.txt" . reverse =<< readFile "forward.txt"  which I can only read as >>=
13:52:56 <EvanR-work> quantum algebra!
13:53:13 <applicative> yeah I know, it's just that the whole apparatus of (x >>= f) fits with a sequencing picture, not a spatial one.
13:53:21 * hackagebot cereal 0.3.0.0 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.3.0.0 (TrevorElliott)
13:54:02 <listofoptions> i have no idea why i'm getting a parsing error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27865#a27865
13:54:42 <jmcarthur> applicative: i use =<< as a kind of function application (as opposed to sequencing)
13:55:15 <dafis> listofoptions: you forgot the outer parens in the list comprehension
13:55:25 <listofoptions> i did?
13:55:44 <aristid> :t (=<<)
13:55:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:55:45 <jmcarthur> applicative: you could even do something like this if you want it to look like composition:   writeFile "backward.txt" . reverse <=< readFile $ "forward.txt"
13:55:45 <dafis> listofoptions: fromList [(b,c),(d,e,f) |
13:56:04 <dafis> listofoptions: should be fromList [((b,c),(d,e,f)) |
13:56:16 <listofoptions> dafis: ahhh
13:56:32 <aristid> :t (=<<) :: (a -> b -> c) -> (b -> a) -> (b -> c)
13:56:33 <lambdabot> forall a b c. (a -> b -> c) -> (b -> a) -> b -> c
13:57:02 <listofoptions> dafis, thx
13:57:30 <jmcarthur> :t (<=<)
13:57:31 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:58:19 <aristid> :t (<=<) :: (b -> e -> c) -> (a -> e -> b) -> (a -> e -> c)
13:58:19 <lambdabot> forall b e c a. (b -> e -> c) -> (a -> e -> b) -> a -> e -> c
13:58:47 <ski> @type (writeFile "backward.txt" . reverse <=< readFile) "forward.txt"  -- i suppose
13:58:48 <applicative> jmcarthur, yeah, I was wanting a kind of 'application', I just can't adjust to (=<<) as expressing it.  But this is purely psychological....
13:58:48 <lambdabot> IO ()
13:58:57 <kyagrd> > 1 + 1
13:58:58 <lambdabot>   2
13:59:18 <ski> @type writeFile "backward.txt" =<< liftM reverse (readFile "forward.txt")  -- also
13:59:19 <lambdabot> IO ()
13:59:24 * hackagebot gray-code 0.2 - Gray code encoder/decoder.  http://hackage.haskell.org/package/gray-code-0.2 (SergeyAstanin)
13:59:29 <applicative> ski, that's kind of nice.  then i just have to think of a 'higher' composition. 
13:59:55 <jmcarthur> applicative: (<$<) = (=<<); (<.<) = (<=<)  -- if you want :)
13:59:56 <ski> @type writeFile "backward.txt" =<< reverse `liftM` readFile "forward.txt"  -- me tries this
13:59:57 <lambdabot> IO ()
14:00:12 <aristid> @type writeFile "backward.txt" =<< reverse <$> readFile "forward.txt"
14:00:13 <lambdabot> IO ()
14:00:45 <jmcarthur> i actually like those that i just suggested. the "<"s suggest the direction of effects and the "$" and "." suggest how they are composed
14:01:00 <aristid> ski: was `liftM` your intermediate step towards <$>?:D
14:01:01 <jmcarthur> *how their results are composed
14:01:24 <ski> jmcarthur : i'd prefer `(<$)' to `(<$<)', i think
14:01:34 * ski ponders that
14:01:51 <ski> aristid : nah, i'm not really fond of the symbol `<$>'
14:01:55 <jmcarthur> ski: i have normally used "<" in such operators as a convention to show which side has an effect
14:02:07 <jmcarthur> ski: but what i just proposed is inconsistent with that
14:02:07 <dafis> ski: (<$<) looks too fishy?
14:02:17 <applicative> jmcarthur, I was thinking of a pseudonym for =<< involving $.  I don't like the directedness, though. I was thinking its the standard directedness, left to right...
14:02:26 <ski> dafis : it looks like the right argument is "function-like" to me
14:02:42 <deech> Hi all, after some further research into the HTTP library I found that given certain URL codes (301,302,303,307) the library does not support "https". Are there other HTTP client libraries that you can recommend?
14:02:42 <aristid> ski: `liftM` is better? oO
14:02:50 <jmcarthur> applicative: <* and *> suggest direction of effects in a similar way
14:03:19 <ski> aristid : i know what it does, reads it quickly, is somewhat conservative, blahblahblah :)
14:03:23 <dafis> ski: yeah, that too
14:03:41 <aristid> ski: why not `fmap` then?
14:03:46 <Lemmih> deech: libcurl?
14:04:03 <applicative> but if we read f <*> x we go left to right, we view the <*> as 'elevated' idiom whitespace or whatever
14:04:11 <jmcarthur> yeah
14:04:23 <ski> aristid : anyway, it's the specific `<$>' (and `<*>') i have problems with .. `<$' and `<*' would be ok, imo
14:04:24 <jmcarthur> my opinion is that <$> should behave like <*>
14:04:35 <jmcarthur> and $> should be fmap
14:04:38 <aristid> ski: because they are too symmetric?
14:04:51 <ski> aristid : that's ok, as long as there's no extra `Functor' constraint being added to polymorphic code
14:04:59 <ski> aristid : yes, exactly
14:04:59 <jmcarthur> my <$< is out of place with those though, i think
14:05:05 <tommd> deech: There's also http-wget.
14:05:06 <deech> Lemmih: yeah that seems like my only option. Curious design choice though.
14:06:16 <deech> And a shame too because the python network libs do the right thing. 
14:06:49 <ski> aristid : imo, `<*>' looks like, in commutative `Applicative's, that `ma <*> mb' should be the same as `fmap (\(a,b) -> (b,a)) (mb <*> ma)' .. which doesn't make sense, type-wise
14:07:07 <tommd> deech: Don't forget about tagsoup
14:07:22 <tommd> It doesn't get talked about much these days, but NDM still maintains it.
14:07:36 <Tomsik__> really, it's all about your mind, it's notation :p
14:07:37 <aristid> :t (<*>)
14:07:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:07:47 <jmcarthur> :t \mb ma -> fmap (\(a,b) -> (b,a)) (mb <*> ma)
14:07:48 <lambdabot> forall t t1 (f :: * -> *) a. (Applicative f) => f (a -> (t, t1)) -> f a -> f (t1, t)
14:07:51 <Tomsik__> it could as well be #$%
14:08:06 <jmcarthur> bikeshedding is fun!
14:08:16 <ski> (iow, `<*>' would be an excellent name for the alternate `Applicative' primitive to `Applicative i => i (a -> b) -> (i a -> i b)', namely `Applicative i => i a -> i b -> i (a,b)')
14:08:42 <aristid> ski: i wonder if there's another way to define Applicative semantically instead of with (<*>)
14:08:59 <ski> aristid : using `Applicative i => i a -> i b -> i (a,b)' ?
14:09:13 <aristid> no tuples omg
14:09:40 <deech> tommd: Thanks I just looked at it and it offloads downloads to the HTTP library and so has the same restrictions. 
14:10:15 <aristid> ski: hmm my aversion to tuples is rather emotional
14:10:15 <jmcarthur> yes, clearly we should abandon tuples
14:10:36 <jmcarthur> it should be:  Applicative f => f a -> f b -> f (forall c . a -> b -> c)
14:10:50 <aristid> :t liftA2
14:10:50 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:10:57 <jmcarthur> oh that's wrong
14:11:03 <aristid> liftA2 (,) would be ski's <*>
14:11:09 <aristid> liftA2 id the current <*>
14:11:11 <jmcarthur> it should be:  Applicative f => f a -> f b -> f (forall c . (a -> b -> c) -> c)
14:11:39 <ski> @type (<*>) . fmap (,)
14:11:40 <lambdabot> forall (f :: * -> *) a a1. (Applicative f) => f a1 -> f a -> f (a1, a)
14:12:05 <ski> @let pair :: Applicative i => i a -> i b -> i (a,b); pair = (<*>) . fmap (,)
14:12:06 <lambdabot>  Defined.
14:12:30 <aristid> :t pai
14:12:31 <lambdabot> Not in scope: `pai'
14:12:33 <aristid> :t pair
14:12:34 <lambdabot> forall (i :: * -> *) a b. (Applicative i) => i a -> i b -> i (a, b)
14:12:39 <aristid> :t liftA2 (,)
14:12:40 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
14:12:50 <ski> @type (fmap ($) .) . pair
14:12:52 <lambdabot>     Couldn't match expected type `a -> b'
14:12:52 <lambdabot>            against inferred type `(a1, b1)'
14:12:52 <lambdabot>       Expected type: f a1 -> f b1 -> f (a -> b)
14:13:26 <aristid> ski: when dealing with the (r->) instance, join and liftA2 are much easier for me than (>>=) and (<*>)
14:14:13 <ski> @type (fmap (uncurry ($)) .) . pair  -- oh, right
14:14:14 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
14:14:41 <aristid> @type liftA2 ($)
14:14:42 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
14:14:44 <aristid> :P
14:14:52 <ski> aristid : and `liftA10' ?
14:15:01 <ski> (mostly joking)
14:15:01 <aristid> what about liftA10?
14:15:15 <ski> @type liftA10
14:15:17 <lambdabot> Not in scope: `liftA10'
14:15:21 <ski> it doesn't exist
14:15:39 <jmcarthur> things like that beg for dependent types
14:15:45 <aristid> jmcarthur: huh?
14:15:49 <aristid> lift 10?
14:15:57 <jmcarthur> aristid: then the number could be a parameter
14:16:02 <jmcarthur> yeah
14:16:21 <aristid> jmcarthur: a generic lift with arbitrary parameters might do too
14:16:36 <ski> aristid : hm, what about the `(w,)' instance, btw ?
14:17:28 <aristid> ski: what about it?
14:17:58 <ski> are `join' and `liftXN' easier than `(>>=)' and `(<*>)' for it ?
14:18:31 <aristid> uh, i haven't really had to think about it so much
14:18:47 <jmcarthur> @let pair' = liftA2 $ \a b f -> f a b
14:18:49 <lambdabot>  Defined.
14:18:52 <jmcarthur> :t pair'
14:18:53 <lambdabot> forall (f :: * -> *) a b t. (Applicative f) => f a -> f b -> f ((a -> b -> t) -> t)
14:18:54 <ski> @type \a b c -> (fst &&& snd) (ap a b)
14:18:55 <lambdabot> forall t c b a. (Monad ((,) c)) => (c, a -> b) -> (c, a) -> t -> (c, b)
14:19:39 <ski> @type let pair :: Applicative i => i a -> i b -> i (forall c. (a -> b -> c) -> c) in pair  -- ?
14:19:40 <lambdabot>     The type signature for `pair' lacks an accompanying binding
14:19:41 <lambdabot>       (The type signature must be given where `pair' is declared)
14:20:00 <freedrull> what is the <$> operator?
14:20:14 <jmcarthur> that forall c would require impredicative types and is not necessary
14:20:15 <ski> @type let pair :: Applicative i => i a -> i b -> i (forall c. (a -> b -> c) -> c); pair = undefined in pair  -- hmhm
14:20:16 <lambdabot> forall (i :: * -> *) a b. (Applicative i) => i a -> i b -> i (forall c. (a -> b -> c) -> c)
14:20:27 <ski> is not necessary for what ?
14:20:48 <jmcarthur> for the type to come out right... but i was actually wrong. it would be better for it to be there
14:20:52 <Janni> freedrull: infix for "ap"
14:20:59 <jmcarthur> so you could use the same result for different functions
14:21:27 <ski> freedrull : actually, `ap' is more like `(<*>)', while `(<$>)' being like `fmap' and `liftM'
14:21:37 * hackagebot diffarray 0.1 - DiffArray  http://hackage.haskell.org/package/diffarray-0.1 (IanLynagh)
14:21:44 <aristid> Janni: uh, no <$> is fmap
14:22:08 <Janni> Ups, yes, just noticed after looking it up.
14:22:09 <jmcarthur> oh, liftA2 is what's killing this i think
14:22:11 <freedrull> fmap 'and' liftM?
14:22:29 <aristid> ski: which module do i need for the (r,) instance of Monad?
14:22:43 <freedrull> sorry, its hard to google symbols -_-
14:22:58 <ski> jmcarthur : aye, like `callCC :: MonadCont m => ((a -> m (forall o. o)) -> m a) -> m a'
14:23:00 <aristid> freedrull: yes, fmap=liftM for all sane Monads
14:23:08 <jmcarthur> yeah
14:23:20 <ski> aristid : probably `Control.Monad.Writer' or `Control.Monad.Instances' or something like that
14:23:21 <jmcarthur> it would have to be defined that way from the start
14:23:22 <Tomsik__> which monads are not sane?
14:23:39 <jmcarthur> Tomsik__: ones which break the monad laws?
14:23:39 <ski> Tomsik__ : the non-monads
14:23:41 <Tomsik__> besides IO and ST
14:23:43 <jmcarthur> and are hence not monads
14:23:54 <jmcarthur> even IO and ST satisfy liftM=fmap
14:24:03 <aristid> ski: weird i only get Applicative for (r,)
14:24:12 <Tomsik__> Which ones don't?
14:24:19 <jmcarthur> ones that's aren't monads
14:24:25 <Tomsik__> Yeah, but which aren't
14:24:37 <Tomsik__> I mean, is there any common monad that isn't a monad?
14:24:38 <aristid> those which are not *this game is funny*
14:24:45 <jmcarthur> Tomsik__: you're assuming we have standard monads defined that aren't really monads
14:24:49 <jmcarthur> none that i know of
14:24:53 <jmcarthur> there are some on hackage
14:24:53 <Tomsik__> Okay
14:25:09 <jmcarthur> Event in the reactive package is a false monad
14:25:29 <jmcarthur> i know there are others, but that's all i can think of
14:25:37 <benmachine> IO and ST are law-abiding
14:25:55 <benmachine> hmm
14:25:59 <Tomsik__> but they're a step from being a heresy, aren't they
14:26:08 <Tomsik__> we keep them just because they've got a use, don't we
14:26:11 <aristid> no, they are outright heresy.
14:26:13 <jmcarthur> no, IO and ST are faithful implementations of "imperativeness"
14:26:18 <benmachine> wasn't at least one of ListT/LogicT only a monad if you ignored order?
14:26:53 <jmcarthur> it is the widespread use of IO where there is the potential to use simpler abstractions that is controversial
14:27:01 <beutdeuce> I want to write a simple lisp interpreter in Haskell. What tools/libraries (if any) should i go about using, and where can i find good documentation (I gave Parsec a a try, though some of the more important examples are probably outdated as they dont compile)?
14:27:18 <jmcarthur> beutdeuce: have you seen write yourself a scheme?
14:27:28 <msieradzki> Parsec examples work modulo module names
14:27:34 <msieradzki> man that sounded weird
14:27:37 <jmcarthur> beutdeuce: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
14:27:38 <ski> aristid : hm .. maybe it wasn't actually defined in there .. it's basically `Writer w' in any case
14:27:40 <beutdeuce> jmcarthur: i know it exists, but i dont want to see it as it will give it away :P
14:27:44 <jmcarthur> ah
14:27:52 <hpc> @unmtl Writer
14:27:52 <lambdabot> err: `Writer' is not applied to enough arguments, giving `/\A B. (B, A)'
14:28:00 <hpc> @unmtl Writer a
14:28:00 <lambdabot> err: `Writer a' is not applied to enough arguments, giving `/\A. (A, a)'
14:28:03 <jmcarthur> beutdeuce: rwh has a parsec chapter i think
14:28:46 <beutdeuce> jmcarthur: I have read it, didn't find it too useful though (I don't insist on sticking with Parsec necessarily, unless it is the best solution for my case)
14:28:50 <ski> @unmtl Writer w a
14:28:50 <Saizan> benmachine: no, it uses a separate >>- combinators for fair interleaving iirc
14:28:51 <lambdabot> (a, w)
14:28:53 <jmcarthur> beutdeuce: it's possible you could use one of the simpler applicative parser libraries though
14:29:12 <jmcarthur> i haven't given them much chance yet, so can't offer a fair comparison
14:29:16 <beutdeuce> jmcarthur: which would you recommend ?
14:29:17 <hpc> ski: i stopped when i noticed it was making a lambda-ish type function
14:29:28 <beutdeuce> ah, perhaps if you mention them, someone else might know ;)
14:29:30 <hpc> \A B. (B, A)
14:29:35 <jmcarthur> beutdeuce: i hear a lot about attoparsec, but that doesn't mean it's the best necessarily
14:29:50 <arcatan> at least people use it
14:29:56 <beutdeuce> anyone have feedback on attoparsec (in the context of writing a simple lisp interpreter)
14:30:26 <ski> aristid : `instance Monoid => Monad ((,) w) where {return = from . return; ma >>= amb = from (to ma >>= to . amb)}; from = swap . runWriter; to = Writer . swap; swap = snd &&& fst', basically
14:30:36 <Itkovian> Is there a tool to resolve (and potentially graph) the dependencies for a given set of cabal packages?
14:31:29 <jmcarthur> beutdeuce: actually, it looks like attoparsec is not purely an applicative parser library. i don't know where i got that idea
14:31:55 <beutdeuce> jmcarthur, makes a parser "applicative"?
14:31:58 <beutdeuce> what*
14:32:32 <ski> "applicative" as opposed to "monadic"
14:32:43 <jmcarthur> what ski said
14:32:55 <aristid> ski: that's a lame way to define it, relying on Writer :P
14:33:17 <jmcarthur> basically not allowing context-sensitive parsing, making the interface simpler and the implementation potentially faster
14:33:41 <jmcarthur> especially if backtracking is not possible
14:33:49 <beutdeuce> ah
14:34:06 <ski> aristid : that's just to get the same behaviour, including bottoms at right places (only possibly that is not the case, because of the need for `swap' because `Writer' (and `WriterT' and `State' and `StateT') has got the order in the pair the wrong way)
14:34:29 <ski> aristid : i'm sure you can define it from scratch, if you want to
14:35:24 <aristid> ski: yeah that definition is trivial apart from the need to swap due to runWriter's wrongness
14:35:33 <ski> beutdeuce : `Applicative' is a type class that fulfills a somewhat similar role as `Monad', except that `Applicative' is more general, and so also applies in some situations where `Monad' can't
14:36:01 <jmcarthur> beutdeuce: http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
14:36:07 * ski wonders whether anyone has added that as a ticket on the trac ..
14:37:22 <ski> beutdeuce : also, e.g. with parsers, an `Applicative' parser has the potential of being more efficient (because you can do less with the `Applicative' interface, because it's more general) than `Monad'ic parsers
14:37:35 <benmachine> I don't actually know of any applicative-only parsers
14:37:44 <ezyang> Useful names: TheMonad. 
14:37:59 <ski> (of course, this would only apply if the parser in question *can't* support the `Monad' interface)
14:38:01 <beutdeuce> ski: i see...hm, do you know where i can find documentation on attoparsec?
14:38:14 <ski> @hackage attoparsec
14:38:15 <lambdabot> http://hackage.haskell.org/package/attoparsec
14:38:19 <ski> maybe there ?
14:38:24 * ski hasn't used attoparsec
14:38:24 <jmcarthur> as i said, attoparsec is monadic after all
14:38:34 <beutdeuce> ski: would you say its a good choice for a beginner haskell programmer to write a lisp interpreter?
14:38:43 <beutdeuce> I just want to make sure im on the right path
14:38:52 <jmcarthur> i'd just go with what has the most documentation available (parsec)
14:38:55 <ski> beutdeuce : depends how full of an implementation you want to make :)
14:38:56 <jmcarthur> considering you are a beginner
14:39:00 <ski> (and which Lisp ?)
14:39:24 <sproingie> rewrite liskell.  add a REPL.  should be easy.
14:39:40 <jmcarthur> Write Yourself a Scheme in 48 Hours uses parsec, for the record
14:39:40 <beutdeuce> ski: my own lisp, and not very full, well, it should support higher-order functions, variables, etc...
14:39:56 <beutdeuce> jmcarthur: yes, but i dont want to see how its done
14:40:00 <ski> well, for a small interpreter thing, sure
14:40:08 <monadic_kid> does the mk/build.mk rules get used in the configure script?
14:40:10 <perimosocordiae> I wrote a basic Forth interpreter in Haskell, it was pretty simple but a good learning experience
14:40:27 <beutdeuce> perimosocordiae: cool, what tools/libraries did u use?
14:40:46 <jmcarthur> heh, forth syntax is so trivial you could probably just use the words function
14:40:57 <aristid> ski: join (m1,(m2,a)) = (m1 `mappend` m2, a) ?
14:41:01 <ski> (Forth has very little in the way of concrete syntax)
14:41:02 <nominolo_> preflex: seen chrisdone
14:41:02 <preflex>  chrisdone was last seen on #haskell 1 day, 1 hour, 57 minutes and 13 seconds ago, saying: jmcarthur: ok. maybe we could pick a date to try it
14:41:18 <ski> aristid : yes
14:41:19 <aristid> ski: if that is not wrong, yes, it would be simpler with join
14:41:56 <ski> aristid : the outer level is the "first" one, in the "computation" interpretation, so `m1' should be output before `m2'
14:41:59 <chrisdone> nominolo_: bump
14:42:07 <nominolo_> chrisdone: ah, hi there
14:42:28 <ski> @palomer
14:42:29 <lambdabot> Pfft
14:42:43 * ski was hoping for "Brump !"
14:43:34 <nominolo_> chrisdone: I decided to redesign after several more people objected to the "brown"
14:43:47 <nominolo_> it's now a 3-column layout http://lambda-haskell.galois.com/haskellwiki/Haskell
14:44:23 <nominolo_> it now uses a gradient instead of a picture.  might actually save some bandwidth, so that's not too bad
14:44:23 <chrisdone> ok
14:44:44 <nominolo_> the content still needs some work -- i'd like to have a short text and then 3 of 4 links per column
14:44:50 <aristid> (w,a) >>= f = let (w',a') = f a in (w `mappend` w',a') vs join (m1,(m2,a)) = (m1 `mappend` m2, a)
14:45:00 <nominolo_> but it's still a wiki so that can be done later on
14:45:18 <ski> aristid : *nod*
14:45:18 <aristid> ski: so again, separating fmap and join wins in terms of clarity
14:45:34 <ski> (retroactively)
14:46:04 <nominolo_> chrisdone: btw, wordpress has its login on the top left.  i also asked someone in the office to go to that site and log in and he had no issues at all finding it.
14:46:43 <nominolo_> chrisdone: we're targeting a computer literate audience, so that should be fine too
14:46:58 <ski> (.. hm, maybe that should be "futureactively", or whatever the antonyous word would be)
14:47:13 <c_wraith> ski: henceforth :P
14:47:24 <aristid> nominolo_: "This page has been accessed 3,300,058 times." oO
14:47:44 <nominolo_> aristid: that includes the old wiki ;)
14:47:53 <hpc> > (*) <$> [1, 2] <*> [2, 3]
14:47:56 <lambdabot>   [2,3,4,6]
14:49:30 <nominolo_> chrisdone: also the "Events" column should use a two line layout:  Title <br> place, date
14:49:52 <nominolo_> chrisdone: the Headlines will use ul { list-style: none; }
14:49:56 <Polarina> How do I install wx on Windows 7 with the Haskell Platform? I am having issues and I cannot find any instructions on the Internet. :(
14:50:46 <ski> > getZipList ((*) <$> ZipList [1, 2] <*> ZipList [2, 3])
14:50:48 <lambdabot>   [2,6]
14:52:24 <aristid> the ZipList made me think about a nicer syntax for list-like things
14:52:40 <aristid> especially perhaps for newtypes around lists
14:53:15 <aristid> getZipList $ (*) <$> [1,2] <*> [2,3] -- more beautiful
14:59:14 <chrisdone> nominolo_: i don't really like or agree with any of the web design you've done. you don't seem to want to listen, either. please do whatever you like without telling me about it :-)
14:59:21 <BMeph> ski: How about " 'preemptively' demonstrated"? ;)
15:00:11 <ski> BMeph : maybe ..
15:00:18 <Saizan> "class IsList l where type Elem l :: *; fromList :: [Elem l] -> l" <- and hook the sugar to this, or we could use edwardk's Reduce class
15:00:39 <ski> (i was hoping temporal logic would have something to say on the matter, but i can't find a good reference on it, atn)
15:01:05 <chrisdone> nominolo_: i haven't contributed anything and you're doing a bloody good job, so i don't mean to be rude
15:03:46 <applicative> Polarina, seems like there's no windows expert around.  :(  You have the Platform and cabal install and so on? 
15:05:04 <Polarina> applicative, yes. It's complaining about the environment variable WXCFG. It's recommending me to set it to gcc_dll\mswud, but there's no such file or directory on my computer.
15:05:46 <nominolo_> chrisdone: fair enough.
15:06:30 <nus> Polarina, which version of wxwindows are you using?
15:06:53 <Polarina> nus, 2.8.11
15:07:10 <nus> no "wxWidgets-2.8.11\lib\gcc_dll\mswud" ?
15:07:33 <Polarina> nus, no. I installed wxWidgets at C:\wxWidgets-2.8.11\
15:09:03 <nus> Polarina, what does search for build.cfg come up with?
15:09:51 <Polarina> nus, no exact matches. There's build.cfg.bak in build\bakefiles
15:12:05 <Polarina> nus, however, in the root, there are files that are commonly found in POSIX applications, such as configure, configre.in, aclocal.m4, etc.
15:12:55 <MHD0> Is there some clever way to update base by means of cabal?
15:13:06 <ezyang> No. 
15:13:18 <ezyang> If you try, you'll break everything ever and will have to nuke .cabal from orbit. 
15:13:26 <applicative> no, it's part of your ghc install
15:13:52 <applicative> MHD0 why do you think you need to do it, though
15:14:21 <MHD0> Cabal tells me I might need version 4.x ...
15:14:32 <applicative> what ghc version do you have
15:14:55 <MHD0> 6.12.1
15:15:19 <Polarina> nus, any ideas?
15:15:26 <applicative> you have base 4   check  > ghc-pkg list 
15:15:45 <applicative> ghc-pkg list should show base 3 and base 4
15:16:10 <ivanm> MHD0: that means that a package you're trying to install is using base-3, but the maintainer should update it to use base-4
15:16:21 <nus> Polarina, yep, build it separately, not by Cabal
15:16:30 <MHD0> Oh, yeah. Thanks for hat tip
15:16:33 <applicative> is it declaring that for everyting?
15:16:38 <Polarina> nus, wxWidgets or wx?
15:16:52 <MHD0> app: Some things
15:17:08 <dafis> Polarina: have you read http://haskell.org/haskellwiki/WxHaskell/Building ?
15:17:23 <Polarina> dafis, I have.
15:17:32 <applicative> MDH0, i hadn't noticed it.  
15:17:37 <dafis> Polarina: it doesn't mention windows 7, but it might still give a few pointers
15:17:47 <ivanm> applicative: if a package uses base-3, 6.12 will spit out a deprecation warning
15:17:57 <nus> Polarina, uhh, forget that, the page says the latest versions can't be built w/o Cabal
15:18:16 <Polarina> dafis, All goes well until it mentions gcc_dll.
15:18:28 <MHD0> applicative: It might have said so with everything...
15:18:32 <nus> Polarina, "Note: Microsoft compilers are no longer supported. The cabal build system cannot understand the output of wx-config for Microsoft compilers. "
15:18:43 <MHD0> Maybe Windows 7 has a say in the matter?
15:18:48 <Polarina> nus, I am using mingw.
15:18:51 <nus> Polarina, looks like your wxWindows installation was built by MS compiler
15:18:52 <dafis> Polarina: you could ask in the cafe
15:18:53 <ivanm> MHD0: if it's a deprecation warning, it's a problem with packages using base-3 not base-4
15:19:08 <Polarina> nus, I just took the binary from wxwidgets.org
15:19:10 <ivanm> MHD0: it just means that the maintainers of those packages should fix their packages up to use base-4
15:19:11 <MHD0> ivanm: Ok, thank you.
15:19:19 <MHD0> :P
15:19:19 <applicative> MHD0, in any case, it's just a warning then.   I was anticipating a different type of problem.
15:19:23 * ivanm already said that... ;-)
15:19:26 <nus> Polarina, yes, and it was built by msvc.
15:19:27 <applicative> i know
15:19:38 <nus> Polarina, hence no build.cfg
15:19:38 <monochrom> @quote monochrom fugue
15:19:39 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
15:19:42 <Polarina> nus, that would explain it.
15:19:49 <Polarina> I'll try building it myself.
15:19:56 <applicative> I try to keep up a kind of contrapuntal fugue here
15:20:33 <MHD0> I think I might love cabal install
15:21:02 <roboshibby> why?
15:21:25 <applicative> roboshibby, well, why not!
15:21:32 <monochrom> because it is lovely
15:21:50 <monochrom> everybody loves me, but I love only my cabal install
15:22:10 <applicative> even if nobody else loves me, cabal install loves me
15:22:25 <Peaker> I transliterated jdh's parallel in-place quicksort from FSharp to Haskell. surprise surprise, it's 20% shorter :)
15:22:38 <applicative> even if nobody else understands me, ghc understands me
15:23:04 <ivanm> Peaker: I still don't get how he can claim that Haskell sucks because his F# implementation is better when he can't actually write Haskell code...
15:23:22 <Tomsik__> "Only GHC understands me :((("
15:23:23 <MHD0> We are the haskell cult. All loves cabal, all worship quickcheck.
15:23:33 <Peaker> ivanm, heh, yeah
15:23:39 <applicative> Peaker, yeah, but it is it industrial strength or just another academic curiosity. 
15:23:49 <ivanm> Peaker: and wtf is with his hard-on for hash tables?
15:24:02 <Peaker> http://www.reddit.com/r/coding/comments/codqo/engineering_large_projects_in_a_functional/c0ur1tz
15:24:13 <sproingie> yay harrop
15:24:18 <Peaker> ivanm, he was just cherry-picking the worst GHC results in any benchmark and it probably happened to be hash tables
15:24:25 <applicative> obviously, real programmers use hash tables, didn't you take Hashtables 101 102 and 103
15:24:32 <ivanm> Peaker: true, because we really don't care about them
15:24:37 <dons> applicative: and they only insert
15:24:38 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
15:24:40 <dons> never lookup 
15:24:40 <monochrom> real script kiddies
15:24:50 <ivanm> applicative: I took a data structures + algorithms course that included hash tables, yes
15:24:59 <ivanm> but have never used them anywhere else
15:24:59 <Peaker> dons, Where can I find existing implementations of parallel in-place qsorts?
15:25:06 <dons> Peaker: hmm. probably in repa.
15:25:13 <monochrom> oh hahaha, a benchmark for inserting but not looking up? I know how to do it in O(1).
15:25:14 <dons> Peaker: but seriously, don't waste time on this guy
15:25:15 <MHD0> HAshtables, great in Lua, Python and Perl. Real functional programmes though use associative maps.
15:25:18 <dons> you will only get frustrated.
15:25:44 <Peaker> dons, well, writing code is educational.. I just learned some FSharp :)
15:25:48 <applicative> but he seems to have vanished... maybe to gather strength
15:26:02 <Peaker> dons, And it re-enforces that Haskell is nicer and beats FSharp at the imperative game :)
15:26:02 <MHD0> Btw, anyone into prolog?
15:26:09 <dons> Peaker: vector-algorithms has a good implementatoin of sorting
15:26:27 <MHD0> I started looking at it, but my haskell skills feels kinda in the way.
15:26:30 <Peaker> dons, where?
15:27:09 <dons> Peaker: http://hackage.haskell.org/package/vector-algorithms
15:27:10 <Peaker> dons, is it parallel?
15:27:12 <dolio> vector-algorithms doesn't do anything in parallel right now.
15:27:16 <dons> then port that to Repa, and get parallel sort
15:27:29 <dons> but you shouldn't waste man hours on this guy, he doesn't care what you actually produce
15:27:36 <Peaker> dons, would that avoid any extra copying?
15:27:48 <ddarius> type HashTable k a = (); insert :: HashTable k a -> k -> a -> HashTable k a; insert _ _ _ = ()
15:27:59 <dons> dolio wrote it, ask him :)
15:27:59 <Peaker> dons, well, Reddit users see this - and now I've got code examples to link to whenever he shows up :)
15:28:05 <ivanm> ddarius: lol
15:28:07 <Peaker> ddarius, I thought about that too :)
15:28:14 <dons> Peaker: yes, a simple clean example to link to without discussion each time is ok
15:28:16 <dolio> repa doesn't have mutable arrays, does it?
15:29:12 <Peaker> dons, jdh claimed that NDP qsort would incur extra copy penalties -- is that true?
15:29:13 <dons> http://hackage.haskell.org/package/repa-algorithms
15:29:23 <dons> Peaker: fusion removes that. see the 'recyling arrays' paper
15:29:32 <dons> its mutable arrays under the hood
15:29:36 <dons> jdh doesn't understand data parallelism
15:29:58 <dolio> Anyhow, it doesn't make much sense to port vector-algorithms to repa, in my opinion.
15:30:10 <dons> http://hackage.haskell.org/package/repa-algorithms
15:30:34 <dolio> It'd be a significant rewrite.
15:30:36 <dons> yup
15:30:39 <ivanm> dons: s/data parallelism/anything/ ;-)
15:30:56 <dons> well, that's true. he has a high opinion of his abilities though
15:31:04 <dons> so competence estimation bias
15:31:10 <ivanm> heh
15:32:48 <dons> and is remarkably quick to let people know they don't understand parallel programming, even with 2-3 decades in the field.
15:33:00 <dons> which raises a red flag imo.
15:33:23 <ivanm> was he one of the whole "but you need concurrency to implement parallelism!!!" responders to marlow's blog post last year ?
15:33:48 <dons> no, i don't think so.
15:33:52 <MHD0> Who are we talking about, and where can i watch this talk of his?
15:33:54 <ddarius> dons: Dunning-Kruger is what you are looking for.
15:33:57 <dons> don't waste time on this guy.
15:33:59 <dons> ddarius: ah yes.
15:34:05 <Peaker> dons, I think he's probably convincing some of the people who read his posts -- and the best way to counter his silliness is to produce counter-example code, which I've done for a golfed C qsort (the golfing I did for the Haskell one reached close) and now a parallel qsort which is much nicer than his fsharp one
15:34:08 <dons> build constructive things
15:34:11 <dolio> You need mutability to implement laziness.
15:34:21 <dons> Peaker: well done. upload to hackage
15:34:25 <dons> so we can all benefit
15:34:45 <ezyang> dolio: That was a pretty amazing discovery that I made when I was reading Okasaki's book. 
15:34:54 <ivanm> MHD0: jdh == John Harrop, a guy who has an OCaml/F# consultancy company + books that keeps denigrating Haskell, Lisp, etc. to try and "prove" that his chosen languages are better and that he should be hired to do stuff for you
15:35:02 <Peaker> dons, interesting idea, I haven't thought of it as worthy of any more than argument material :)  I think the in-place qsort one is probably not too interesting.. The parallel one might actually be
15:35:09 <ezyang> Memoized laziness is just carefully controlled mutation! 
15:35:27 <ddarius> The difference between call-by-name and call-by-need (laziness) is just sharing.  Mutability is all about sharing.  Arguably, sharing is the core of mutability.
15:35:41 <MHD0> ivanm: Sounds like an unsympathetic guy, because clearly haskell is superior.
15:35:42 <Peaker> dons, btw: I have a forkIO in there for the in-place destructive-write parallelism -- but it makes sense to support ST as well.. there's no forkST, but the forkIO here is safe in terms of determinism.. what should I do for ST support?
15:35:59 <MHD0> ivanm: Har har, hypocritical humour.
15:36:06 <dons> Peaker: unsafeIoToSt
15:36:20 <dolio> Peaker: unsafeIOtoST. I've considered doing it for vector-algorithms as well.
15:36:39 <Peaker> @type unsafeIOtoST . forkIO . unsafeSTtoIO
15:36:40 <lambdabot> Not in scope: `unsafeIOtoST'
15:36:40 <lambdabot> Not in scope: `forkIO'
15:36:40 <lambdabot> Not in scope: `unsafeSTtoIO'
15:37:01 <ddarius> It's not unsafe to go from ST to IO, that's essentially return . runST
15:37:07 <dons> yup
15:37:16 <dolio> It depends how you go there.
15:37:20 <dons> stToIO
15:37:24 <dons> unsafeIOToST
15:37:27 <dons> Control.Monad.ST
15:37:47 <dolio> It's only safe to go from ST RealWorld to IO.
15:38:08 <dolio> Or via a runST, but that will also limit your options.
15:39:19 <dolio> (forall s. ST s a) -> IO a is the latter.
15:39:23 <Peaker> I think I need a MonadFork constraint
15:39:32 <Peaker> If I want my code to be in either IO/ST
15:39:43 <dolio> unafeSTToIO goes ST s a -> IO a.
15:40:29 <dons> PrimMonad m :: m ()
15:40:36 <dons> in the style of vector.
15:40:51 <Peaker> dons, How do I get the fork operation?
15:41:13 <ddarius> @hoogle stToIO
15:41:13 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
15:41:14 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
15:41:14 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
15:41:47 <Peaker> @type Control.Monad.ST.unsafeIOToST . Control.Concurrent.forkIO . Control.Monad.ST.unsafeSTToIO
15:41:47 <lambdabot> forall s s1. ST s1 () -> ST s GHC.Conc.ThreadId
15:41:55 <Peaker> I am not sure if this ^^ is a sensible forkST operation
15:42:10 <Peaker> probably -- as long as you guarantee determinism
15:43:05 <ddarius> Indeed.  forkST is not safe in general.
15:44:09 <ddarius> Perhaps you can capture the pattern you need in a safe set of "primitives," e.g. IVars or something.
15:47:32 <Peaker> ddarius, what is an IVar?
15:47:45 <jmcarthur> a write-once reference
15:48:37 <jmcarthur> http://hackage.haskell.org/packages/archive/ivar-simple/0.1.0.1/doc/html/Data-IVar-Simple.html
15:48:54 <Peaker> ddarius, what I might need here is maybe a forkSTarray which takes an STArray s i a, splits it to (STArray s1 i a) for one sub-array, (STArray s2 i a) for a non-overlapping sub-array, and executes an (ST s1) and (ST s2) computations in parallel.. I think this would be safe?
15:49:27 <Peaker> I think this could be an interesting/cool primitive for parallel ST computations, actually?
15:50:16 <Peaker> Only when both the computations complete, the original (ST s) computation can carry on with a mutated array
15:50:56 <jmcarthur> only safe if you don't pass the array itself into the continuation
15:51:26 <dolio> You can't. The s would be wrong.
15:51:37 <jmcarthur> you could probably guarantee that by using another forall, but then you can't pass in anything from the outer scope
15:52:01 <Peaker> jmcarthur, I think it's ok that you can't because: A) it is indeed unsafe B) for parallel quicksort, I don't need any mutable vars to be passed
15:52:33 <jmcarthur> sounds reasonable
15:52:48 <Peaker> I wonder if this kind of primitive, along with MonadFork and a parallel quicksort generalized on it are worth a paper? :)
15:53:06 <dons> well, a good library of parallel array ops on top of Repa
15:53:06 <ezyang> Peaker: Have you seen the Orc paper? 
15:53:08 <dons> would be good
15:53:10 <Peaker> ezyang, nope
15:53:16 <jmcarthur> it seems like this would be better if you could use the spark queue rather than explicit threads
15:53:18 <ezyang> Go check it out. 
15:53:29 <ezyang> It's about halfway what you're looking for. 
15:53:33 <bewest> ugh. I'm still having problems.  when I use cabal to install gitit, it fails when trying to install this package: http://hackage.haskell.org/package/HStringTemplate-0.6.4
15:53:37 <bewest> which is a dependency
15:53:44 <bewest> it fails when building against parallel
15:53:47 <Peaker> ezyang, link?
15:53:58 <jmcarthur> i guess threads make sense here at least
15:53:58 <chrisdone> bewest: what is the error?
15:53:59 <Peaker> jmcarthur, not sure how to use that
15:54:25 <Peaker> jmcarthur, why is it cheaper to use the spark queue over forkIO? forkIO won't use a new thread if not necessary?
15:54:40 <bewest> chrisdone: http://pastebin.com/HCTx7mhh
15:54:43 <jmcarthur> Peaker: well, if you are only splitting it in half that it's not a big deal anyway
15:54:45 <Philippa> has anyone written/made available the "multiple error" applicative?
15:54:53 <Peaker> jmcarthur, recursively
15:54:57 <bewest> Text/StringTemplate/Base.hs:19:35:
15:54:57 <bewest>     Module `Control.Parallel.Strategies' does not export `rnf'
15:55:01 <jmcarthur> Peaker: but if you will be doing that pretty deeply then you end up with a lot of threads, which does have a lot more overhead than just sparks
15:55:04 <Philippa> like the error monad, except the error path carries a list of errors taken from all the RHSes of <*> ?
15:55:06 <Peaker> jmcarthur, though with a threshold of 1024 elements
15:55:25 <ezyang> code.galois.com/paper/2010/Hask-Orc-DRAFT.pdf 
15:55:26 <jmcarthur> Peaker: either way, in ST you don't have many options
15:55:27 <Peaker> jmcarthur, how can a spark be cheaper than a user-thread (forkIO, not forkOS)?
15:55:35 <bewest> I've tried encouraging cabal to try different versions of parallel and HStringTemplate
15:55:40 <Peaker> jmcarthur, oh, spark queue is just a list of thunks?
15:55:41 <jmcarthur> Peaker: the spark queue is cheaper than preemption
15:55:43 <jmcarthur> yeah
15:55:47 <Philippa> (it can also sensibly be turned into an error monad by having the monad instances doing the obvious things with singleton failures where appropriate)
15:56:20 <jmcarthur> Peaker: but in the presence of mutation and stuff, sparks are not possible
15:56:42 <jmcarthur> Peaker: there's no guarantee that they run at all, and probably no guarantees over order, either
15:57:28 <Peaker> jmcarthur, well, this parallel call is only for mutation purposes
15:57:31 <ski> MHD0 : Prolog is nice, mostly
15:57:43 <jmcarthur> yeah, then a forkIO is probably more appropriate, even if more expensive
15:57:47 <Peaker> jmcarthur, http://www.reddit.com/r/coding/comments/codqo/engineering_large_projects_in_a_functional/c0ur1tz?context=1
15:58:02 <jmcarthur> Peaker: this sounds like a job for nested data parallelism, to me :)
15:58:04 <ski> (Philippa : i recall starting on something like that, a long time ago)
15:58:07 <chrisdone> bewest: looking at the documentation for parallel, it removed rnf (and probably NFData) from the API around 2.x http://hackage.haskell.org/packages/archive/parallel/3.1.0.0/doc/html/Control-Parallel-Strategies.html
15:58:11 <jmcarthur> i don't know how well ndp is working though
15:58:20 <bewest> ok, so it is a versioning issue
15:58:22 <chrisdone> bewest: maybe hstringtemplate is just really old and needs updating
15:58:28 <Peaker> jmcarthur, well, yeah, but it might be useful to have an explicitly in-place parallel-sort too? not sure if NDP can guarantee in-place-ness?
15:58:44 <bewest> so if I can convince cabal to attempt compiling against the older version of parallel, it might work
15:58:56 <chrisdone> sure
15:58:57 <Philippa> ski: yeah, I imagine at least someone's toyed with it, I remember (sans the Applicative interface) Beelsebob listing it as an example in one of his "monads suck" rants
15:58:58 <ski> @tell MHD0 there's ##prolog, too
15:58:59 <lambdabot> Consider it noted.
15:59:21 <ezyang> Hey guys, what is the simplest nontrivial example of recursion on natural numbers you can think of? 
15:59:24 <chrisdone> bewest: personally i prefer to update out-of-date libraries if the changes are trivial
15:59:34 <jmcarthur> Peaker: i don't know either
15:59:43 <Tomsik__> ezyang: what was that conjecture, goldbach?
15:59:50 <Philippa> ezyang: define "nontrivial"
15:59:52 <ski> ezyang : what is nontrivial ?
15:59:55 <bewest> chrisdone: I'm not yet familiar enough with haskell. I'm but a poor user tring to use gitit
16:00:05 <chrisdone> oh, ok ;-)
16:00:05 <ezyang> Too complicated. 
16:00:10 <ski> ezyang : double-recursion ? course-of-values-recursion ?
16:00:22 <ezyang> ski: Hmm 
16:00:25 <chrisdone> bewest: you can see the versions here: http://hackage.haskell.org/package/parallel
16:00:29 <Philippa> "repeat n times" is an obvious one
16:00:34 <ski> ezyang : ackerman-like recursion ?
16:00:46 <Philippa> although obviously it's either foldNat or foldNatM
16:00:55 <Peaker> "Monads suck" is silly as sometimes Applicative is not enough
16:01:06 <bewest> chrisdone: when I turn give a -v to cabal, I can see it's using the newest version even though I've got several older ones installed
16:01:07 <Peaker> the extra power may cause trouble - but it is also very useful for some things
16:01:08 <chrisdone> ackermann is a good test of recursion
16:01:10 <Tomsik__> f (n+1) = if (f n) `mod` 2 == 0 then (f n)/2 else 3*(f n)+1
16:01:21 <bewest> how can I influence cabal's choice of which version to use?
16:01:27 <jmcarthur> who said "Monads suck"?
16:01:34 <Philippa> Peaker: Beelsebob was notably allergic to monads for a long time. Including some false claims like monads not having any notable architectural role...
16:01:36 <bewest> or do I need to somehow do it from source?
16:01:50 <Philippa> jmcarthur: Beelsebob did, repeatedly, once upon a time
16:01:55 <ezyang> Perhaps a slight explanation of what I'm actually trying to do: 
16:01:58 <Peaker> Can an STArray be "sliced" to get a new array that is actually a shared subset of the original one?
16:02:15 <chrisdone> i believe cabal install supports a way to provide the version of its dependencies
16:02:20 <chrisdone> can't remember it off the top of my head
16:02:22 <jmcarthur> most Data.Array.* types can be sliced
16:02:24 <Peaker> Philippa, "choose next monadic wrapper based on previous result"
16:02:24 <ski> ezyang : oh, actually <http://en.wikipedia.org/wiki/Double_recursion> wasn't what i had in mind .. i was thinking more of having `(Zero,Zero)',`(Succ m,Zero)',`(Zero,Succ n)',`(Succ m,Succ n)' cases
16:02:27 <jmcarthur> dunno about the mutable ones
16:02:41 <chrisdone> hi redocdam :)
16:03:03 <jmcarthur> oh nevermind, i'm full of it
16:03:10 <redocdam> chrisdone: what do you remember me for here?
16:03:20 <Philippa> Peaker: *I* don't think monads suck, although I'm well aware that there's a lot of useful things you can achieve by not using the monadic interface too freely, such as the multierror thing I just mentioned or numerous self-analysing things
16:03:23 <jmcarthur> there's always vector though, which i *know* allows slicing
16:03:38 <ezyang> Basically, I want to bound the size of the natural numbers I'm passing to this function, and then exhaustively prove that it always terminates. 
16:03:49 <ezyang> since the domain is finite. 
16:04:14 <ezyang> so I want a recursive function that is complex enough so that doing this is interesting, but simple enough that I can actually prove it terminates :-) 
16:04:22 <chrisdone> bewest: check out cabal install --help and look at --constraint, does that help?
16:04:34 <CakeProphet> Monads suck!
16:04:44 <chrisdone> e.g. cabal install foo --constraint bar==4.2
16:04:47 <Philippa> Peaker: I do wish we had 'applicative do' sugar commonly available though, because really one should write to the applicative interface by default and the monadic one where needed
16:04:48 <jmcarthur> Peaker: http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Unboxed-Mutable.html
16:04:49 <ski> Peaker : in the worst case, i suppose you could define `data Sliced arr ix el = MkSliced (ix,ix) (arr ix el)' ..
16:04:53 <chrisdone> someone correct me if i'm wrong
16:04:55 <Philippa> it exposes more structure to refactor around and exploit
16:05:04 <Peaker> Philippa, Yeah, Applicatives aren't opaque which is really cool.. also applicatives are naturally composable (liftA2 . liftA2 . ...) whereas monads don't (join . join  does not form a new monad)
16:05:15 * hackagebot alms 0.4.11 - a practical affine language  http://hackage.haskell.org/package/alms-0.4.11 (JesseTov)
16:05:19 <Tomsik__> ezyang: well, ackermann :p
16:05:28 <Tomsik__> it's not a primitive-recursive function
16:05:31 <Peaker> ski, But then I need to define instances of MArray with everything under the sun?
16:05:33 <bewest> chrisdone: aha, I'll try --constraint 'processing < 3.0' and see if the verbose output changes
16:05:37 <ezyang> Ackermann might work well. 
16:05:42 <chrisdone> bewest: nice
16:05:54 <ezyang> Maybe I should try super-simple, like f(0)=0; f(n)=1+f(n-1) first 
16:05:54 <redocdam> I don't like being greeted when I am about to troll, you ruined my whole day chrisdone 
16:05:55 <chrisdone> ackermann is n! right? or what was it
16:06:02 <ski> ezyang : well, Collatz .. except we don't know it terminates :)
16:06:03 <ezyang> chrisdone: lol. 
16:06:13 <ski> chrisdone : much much worse
16:06:17 <Tomsik__> or one from the collatz conjecture
16:06:20 <jmcarthur> ackerman has terrible complexity
16:06:28 <Peaker> chrisdone, Ackermann is a really really fast-growing function.. n! is peanuts next to ackermann in the HitchHiker's guide to Galaxy sense
16:06:30 <Tomsik__> only you can't prove it'll always terminate unless you're a really cool guy
16:06:37 <chrisdone> ski: really? maybe ackermann is even its own notation
16:06:50 <Tomsik__> though it's empirically tested that it terminates up to some huge number
16:07:03 <Philippa> Peaker: not only aren't they opaque, but you get more freedom in evaluation strategies than if you use >>= for everything
16:07:14 <ski> chrisdone : see e.g. the above WP link
16:07:33 <chrisdone> Tomsik__: i thought one point of ackermann was that it goes on forever but doesn't actually produce that large numbers, it's just the steps taken to produce are large
16:07:42 <Tomsik__> jmcarthur: if a function has a sane complexity then there's no way that termination proof is not a joke:p
16:07:46 <chrisdone> oh, no i'm wrong
16:08:00 <bewest> chrisdone: yeah, that seems to be fixing the problem, I'm making some more progress
16:08:03 <Philippa> hmm. I'm increasingly thinking I should run with the Anglohaskell talk I'm considering not least to get a bunch of stuff at least part-documented by way of slides
16:08:17 <Philippa> possibly turn it into a TMR article as well if I have time
16:08:18 <ddarius> Must remove α(n) factor.
16:08:23 <bewest> hmm how can I update the marked dependency in hackage?
16:08:31 <bewest> maybe I just drop an email
16:09:26 <CakeProphet> so wait, applicative is a superset of monads?
16:09:33 * ski seems to remember something about exponential of naturals being expressible through diophantine equations .. maybe something like that could be what ezyang wants ?
16:10:01 <chrisdone> bewest: usually the best bet. if there's no reply then i believe squatters rights say you get to upload a fixed version
16:10:20 <ski> (i.e. search upwards until you find a diophantine solution, the bound is given by the exponential)
16:10:37 <CakeProphet> hey guys! I just made a mathematical discovery
16:10:45 <CakeProphet> you can represent natural numbers as.... /arabic numerals/
16:10:54 <ddarius> Peaker: I had a phone call, but your runSTParArray thing should be safe.
16:11:10 <ddarius> Peaker: I am considering hacking something to do that.  The types would be interesting.
16:11:16 <ski> CakeProphet : yes every `Monad' can be made into an `Applicative'
16:11:34 <ddarius> CakeProphet: Given enough paper.
16:11:45 <CakeProphet> I honestly don't know much about applicative. Other than it's use as a liftM-n
16:12:07 <Peaker> ddarius, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27867#a27867
16:12:08 <ddarius> CakeProphet: Applicative == all you have is liftMn for all n.
16:12:15 <Peaker> ddarius, I don't have a sliceArray though :-( Not sure why it doesn't exist
16:12:19 <ski> Peaker : well, i was hoping you'd only need to define one instance of `MArray' for that
16:12:21 <jmcarthur> CakeProphet: you basically summarized applicative
16:12:22 <chrisdone> :t (<*>) -- the heart of applicative
16:12:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:12:47 <jmcarthur> Peaker: if you use STVector as i linked to earlier you get a slice function
16:12:51 <Peaker> ski, maybe that's the case, but I think I'd need to duplicate all the instances for all the unboxed types
16:12:53 <CakeProphet> ddarius:  so essentially, it's the operation of application... but within a parametric type?
16:13:03 <ski> Philippa : well idiom brackets (or better, my (unfinished) reflective syntax)
16:13:07 <Peaker> jmcarthur, oh, thanks, sorry I missed it
16:13:12 <ski> Peaker : hm .. could be
16:13:16 <ddarius> Peaker: Yeah, a binary version is relatively easy, though, yeah, you'll have to "hack" an appropriate "sliceArray."  I was considering if it was possible to make a version that takes a chunking parameter.
16:13:45 <ddarius> That would assume that fg and bg are the same operation though, is that the case for your example?
16:13:48 <Peaker> ski, as jmcarthur linked, I can use an STVector instead
16:13:51 <ddarius> For your use I mean.
16:14:02 <CakeProphet> :i Applicative
16:14:11 <Peaker> ddarius, Can't you express chunking by re-calling forkSTArray?
16:14:30 <ski> CakeProphet : you could say that, yes
16:14:34 <CakeProphet> hmmm. so pure = return for all Monads?
16:14:36 <Peaker> ddarius, all you need to prove is disjunction, so a single index seems enough
16:14:38 <ski> CakeProphet : yes
16:14:52 <CakeProphet> what's an example of an applicative that is not a monad?
16:15:13 <ski> CakeProphet : `class Functor i => Applicative i where pure :: a -> i a; (<*>) :: i (a -> b) -> (i a -> i b)'
16:15:18 <Philippa> ski: idiom brackets aren't actually as badly needed as a pointed variant
16:15:19 <ski> CakeProphet : `ZipList'
16:15:25 <ddarius> Peaker: You could, but the type would still need to be different or you would need to always write out the multiple calls to the "forkSTArray."  However, having a (forall s. ... ) argument should work fine and give the right guarantees.
16:15:37 <ski> Philippa : "pointed variant" ?
16:15:46 <CakeProphet> ski:  ah. I forgot about ZipList. That's fancy stuff. :)
16:15:49 <Philippa> ski: the applicative do. Something that lets you name the intermediates
16:15:54 <Peaker> ddarius, is my type missing foralls?
16:16:10 <Peaker> oh I see it does
16:16:42 <ddarius> Peaker: I don't think so.  But if I were making one that took a single action to apply to an unknown number of chunks, it would need to.
16:16:43 <Peaker> or maybe I'm not so sure
16:16:57 <ski> Philippa : with my syntax, i think it could be more or less `[> let x = [< ... >]; y = [< ... >] in ..x..y.. <]'
16:17:27 <Peaker> ddarius, wait, since I'm actually "runST'ing" (conceptually) the s1 and s2, I guess there really should be a forall in there, or you could "choose" s1=Int, s2=Int
16:17:28 <ski> (Philippa : and actually, that's nice that you made me think of this special case ..)
16:17:38 <bewest> chrisdone: looks like it's working
16:17:44 <bewest> thanks, all, for the help
16:17:58 <chrisdone> welcome :)
16:18:01 <Peaker> ddarius, I think http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27867#a27868 is safe
16:18:23 <Philippa> ski: hmm. Better than being kicked, but I'd rather skip the let given that the = makes it syntactically unambiguous?
16:18:43 <jmcarthur> Peaker: unsafeSTToIO  <-- couldn't you just use stToIO?
16:18:46 <ski> CakeProphet : also, parsers that pre-compute with static information
16:18:51 <jmcarthur> oh, wait, no you can't, nevermind
16:18:55 <jmcarthur> i forgot about the type
16:19:06 <SevenInchBread> ski:  are all Monads implicitly Applicative? I don't think Haskell can do that without UndecidableInstances right?
16:19:13 <Philippa> ski: also that's not widespread as an idea AFAICT? I tend to think of the original style idiom brackets that just insert <$> and <*> between the spaces unless told otherwise
16:19:17 <jmcarthur> then again you are using unsafeCoerce...
16:19:34 <Philippa> SevenInchBread: They aren't, but they are via a newtype
16:19:45 <ski> Philippa : well, the point here is that the thing inside `[> ... <]' looks like a normal Haskell expression (except that `[< ... >]' is allowed inside)
16:20:36 <chrisdone> :t (+) <$> pure 1
16:20:36 <chrisdone> :t (<*>)
16:20:36 <chrisdone> :t ((+) <$> pure 1) <*> pure 2
16:20:37 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a)
16:20:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:20:38 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a
16:20:39 <ski> Philippa : my idea was inspired by idiom brackets, but obviously i think my syntax is nicer :)
16:21:39 <chrisdone> Applicative is nice in the Formlets library
16:21:50 <zachk1> formlets?
16:22:18 <ski> Philippa : e.g. if you have `[> ((...) (...)) ((...) [< ... >]) <]', if you now want to do a side-effect inside the first `(...)', then you need to add idiom brackets all the way up from that spine, while in my syntax, you just add a `[< ... >]' inside it
16:22:45 <ski> @hackage formlets
16:22:46 <lambdabot> http://hackage.haskell.org/package/formlets
16:22:58 <davekong> what is the difference between Haddock 2.6.x and 2.7.x?
16:23:36 <SevenInchBread> @src liftA
16:23:36 <lambdabot> liftA f a = pure f <*> a
16:23:37 <ski> Philippa : as for widespread, i've only mentioned it more than in passing on IRC :)
16:23:49 <Peaker> ezyang, Can you help me find "the Orc paper"?
16:23:50 <Philippa> ski: yes, but you're sugaring for let
16:24:13 <ski> Philippa : and `case' and application, and values, and lambda
16:24:13 <Philippa> I mean yeah, it's nicer than no applicative do and just old-style brackets, sure
16:24:28 <ski> (did i miss any important expression kind ?)
16:24:37 <ddarius> ski: do
16:24:42 <Philippa> heh. How do lambdas and case work? Application's obvious already
16:24:43 <ski> ddarius : ty
16:24:58 <ski> Philippa : `case' is obvious .. lambda, not so obvious
16:24:59 * ddarius can just see the possibilities of crazy Applicative notation over Arrow notation over do-notation.
16:25:02 <Philippa> ddarius: heh. Do's not one of the five the semantics're generally reduced to though
16:25:22 <Philippa> ski: hmm, outer case only?
16:25:27 <zygoloid> @hoogle SupplyT
16:25:27 <lambdabot> No results found
16:25:36 <ezyang> Peaker: Does the link not work? 
16:25:58 <ski> Philippa : `case' (and `let') expands to `(>>=)' (except if either the "former" part or the latter "part" uses no side-effects, in which case you can use `(<*>)', as you noted above)
16:26:31 <dons> Peaker: that's clever sorting code, with `strat`
16:26:31 <Philippa> ew
16:26:38 <ski> also, if you have an application where only one part uses side-effects, you use `fmap' instead
16:26:41 <Philippa> that's no replacement for applicative do at all, then
16:26:52 <Peaker> ezyang, oh, I missed it.. too many people addressed me :)
16:27:01 <ski> Philippa : it's meant to be usable for all of `Functor',`Applicative',`Monad'
16:27:22 <ski> Philippa : also note the parenthetical remark (and what i said above)
16:27:25 <Philippa> oh, right, unless it uses no side-effects. At which point you've just got a suspiciously involved translation and I may as well have my applicative do in do while we're at it
16:27:26 <Philippa> yeah
16:27:27 <redocdam> dons: I stood outside all day with that Haskell sign, I want my $15
16:27:30 <Peaker> dons, Yeah, much nicer than his way of doing the parallel call there :)
16:27:49 <Peaker> dons, thanks :)
16:28:11 <br1> while compiling a custom module for ehc, the shuffle tool fails with hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
16:28:15 <ski> Philippa : i just think my idea is more parsimonious wrt syntax addition
16:28:17 <hpc> @unmtl State s a
16:28:17 <lambdabot> s -> (a, s)
16:28:22 <br1> how should I save my source files?
16:29:33 <dons> redocdam: why do you say that every few weeks?
16:29:48 <dons> Peaker: i'm guessing he won't know what imports and so on to add, to compile it
16:30:03 <Stalafin> is there a function removing white spaces from a string?
16:30:13 <Peaker> dons, I could put the full version too
16:30:14 <redocdam> dons: I am adding interest to it
16:30:16 <chrisdone> Stalafin: one is unwords . words
16:30:31 <ski> > filter (not . isSpace) "  is there a function removing white spaces from a string? "
16:30:32 <lambdabot>   "isthereafunctionremovingwhitespacesfromastring?"
16:31:02 <chrisdone> > unwords . words $ "  ground   control to  major   tom"
16:31:03 <lambdabot>   "ground control to major tom"
16:31:12 <Philippa> ski: tbh your answer to ado weirds me out a bit still, but hey. If you've got the semantic analysis required, there's no good reason not to pretty do up too
16:31:15 <Tomsik__> Thank you Chris.
16:31:19 <Tomsik__> :p
16:31:22 <ski> > (reverse . dropWhile isSpace . reverse . dropWhile isSpace) "  is there a function removing white spaces from a string? "
16:31:23 <lambdabot>   "is there a function removing white spaces from a string?"
16:31:47 <Stalafin> chrisdone, ski: thank you
16:31:51 <Philippa> ski: and I think there's pretty strong resistance to requiring semantic analysis just to parse on the compiler-writing side, and I don't blame 'em
16:32:56 <ski> Philippa : well, this isn't required for parsing, it's just an AST translation (and it doesn't require knowing the types, either)
16:33:13 <dons> Stalafin: concat . words ?
16:33:19 <dons> > words "just  testing  this"
16:33:20 <lambdabot>   ["just","testing","this"]
16:34:14 <br1> it seems emacs was the culprit
16:34:26 <ski> s/this isn't required for parsing/there's no semantic analysis required for parsing here/
16:34:32 <tolkad> Can we remove @undefine? so people don't always have their functions deleted?
16:34:33 <Philippa> ski: write it up and post to -cafe? We definitely need some more discussion on this, and I think I'm going to do a piece at AH on 'engineering with effects' that'll point out that better applicative and applicative/monad mix support is needed to encourage people to do the right thing, amongst other things
16:35:17 <tolkad> but why does't this work?
16:35:23 <tolkad> > let class X in 5
16:35:24 <lambdabot>   <no location info>: parse error on input `class'
16:35:32 <tolkad> > class X
16:35:33 <lambdabot>   <no location info>: parse error on input `class'
16:35:50 <tolkad> @class X
16:35:50 <lambdabot> Unknown command, try @list
16:35:55 <tolkad> @let class X
16:35:55 <lambdabot>  Invalid declaration
16:36:00 <aavogt> lambdabot only evaluates expressions for you
16:36:08 <tolkad> oh
16:36:27 <aavogt> (well other than @let, which seems only good for functions)
16:36:32 <Philippa> ski: to put it another way, I think it's time for a good strong mix of advocacy and effort making the tools available on this stuff :-)
16:37:05 <Philippa> (sadly I don't think the mixed do notation quite works while we don't have Applicative as a mandatory superclass of Monad, but hey)
16:37:20 <ski> Philippa : one problem is that to make this more useful, we really should have `Applicative' be a superclass of `Monad' .. otherwise the translation will often produce code that adds both `Applicative m' and `Monad m' constraints (or else it needs to grab into the type checker for info)
16:37:25 <Philippa> yeah
16:37:41 <Philippa> that's something to throw at the Haskell' folks
16:37:54 <Philippa> it's a breaking change, but it /really/ needs to happen
16:37:57 <tolkad> where is the monad class defined anyway?
16:38:08 <Peaker> cool convention, naming MonadIO instance constraint "io":  MonadIO io => ... -> io a
16:38:12 <ezyang> Prelude. 
16:38:14 <Peaker> gonna do that :)
16:38:59 <ski> aavogt : fixity declarations as well, i think
16:39:02 * ddarius <3 Hans Rosling.
16:39:21 <Philippa> Peaker: that's nice, where'd you spot it?
16:39:37 <Saizan> ski: so, what in Conor's idioms brackets is (| f x y |) would be [> [< f >] [< x >] [< y >] <] in your notation?
16:39:44 <aavogt> @let infixl 7 flip
16:39:44 <lambdabot>   Parse error: VarId "flip"
16:39:53 <aavogt> @let infixl 7 `flip`
16:39:54 <lambdabot>  Defined.
16:40:02 <aavogt> ski: interesting
16:40:11 <Peaker> Philippa, the ORC paper
16:40:27 <ddarius> aavogt: You can put a fixity declaration in a let.
16:40:35 <ski> Saizan : no
16:40:51 <aavogt> but it's also permitted outside here
16:40:51 <Philippa> ski: I think with ado you could start optimising/minimising the use of >>= too, beyond simply "is this all representable as applicative?" - which'd be a very, very good thing
16:41:11 <Peaker> Philippa, s/>>/*>
16:41:15 <Peaker> @type (*>)
16:41:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
16:41:19 <ski> Saizan : it would be `[> f [< x >] [< y >] <]' (assuming `x' and `y' aren't idiom brackets as well, in case it can be simplified)
16:41:30 <Philippa> Peaker: there's more you can do than that
16:41:44 <Peaker> Philippa, yeah, just mentioning it alongside "stop using >>="
16:41:47 <Philippa> (though >> really should be defined equal to *> these days anyway)
16:41:56 <Saizan> ski: ah, right, i forgot f was supposed to be pure there :)
16:42:08 <Philippa> Peaker: >> isn't a problem so long as it's not implemented in terms of >>=
16:42:31 <ski> Philippa : by `ado' i presume you mean something that looks like `do', but is more restrictive on what it allows ? (or maybe it translates more parsimoniously ?)
16:42:31 <Philippa> and if it is, then it's probably not a problem /anyway/ because that monad implementation clearly doesn't care
16:43:12 <Philippa> ski: well, the dumb version is just restricted to applicative, yeah. But I'd like a combined ado/do that optimises the structure, once we've got the type classes fixed
16:44:22 <Philippa> (I'm tired and using them a bit interchangeably, sorry for that)
16:45:32 <ski> Saizan : e.g. `(| id (| f x y |) (| g x (pure z) |) (| h y (pure z) |) |)' would correspond to `[> f [<x>] [<y>] (g [<x>] z) (h [<y>] z) <]'
16:45:56 <davekong> There a _good_ guide to haddock anywhere? The haddock page itself is not very pleasant
16:46:03 <ski> Philippa : ok
16:47:00 <Saizan> davekong: there should be a manual somewhere, not sure how up to date though
16:47:16 <aavogt> davekong: it may not be a guide, but you could look at how other projects use it
16:47:40 <Saizan> davekong: http://www.haskell.org/haddock/doc/html/index.html
16:48:06 <lispy1> davekong: you could write a sample program that is just an example of good haddock practices and upload it to hackage :)
16:48:23 <lispy1> upload it as: haddock-exampleprog or such
16:48:25 <Philippa> ski: identifying monadic 'choke points' and only using >>= there would be the main idea, anyway
16:48:41 <ski> Philippa : btw, i don't recall if `ado' is an invention of yours, or someone else .. is there a mail or something briefly (or not so briefly) explaining it somewhat more in detail ?
16:48:42 <Saizan> ski: does it mix well with HOFs? e.g. traverse
16:48:55 <aavogt> or a projet that uses all possible features :P
16:49:19 <ski> @type Data.Traversable.traverse
16:49:20 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:49:44 <Saizan> just mapM for applicative :)
16:49:49 <ski> Saizan : i think i know how to handle lambdas, if that's what you mean
16:50:13 <ski> Philippa : yea
16:50:51 <Philippa> ski: I know I'm one inventor, but I suspect others have too. The basic idea is "ado a <- $f; $g; $h ... a ... " => "(\ f g -> $h ... a ...) <$> f <* g"
16:51:17 <Philippa> (er, metasyntactic goof re the final f and g, but YSWIM?)
16:52:16 <ski> Philippa : so the restriction here is that the `<-'-bound variables may only be used in the final expression (for it to use `Applicative', rather than `Monad', at least)
16:52:34 <Philippa> ski: bingo
16:52:39 <ski> ty
16:53:16 <Philippa> I should probably write MultiError and get it on Hackage tonight
16:53:23 <Philippa> I guess it's a use for the caffeine I drank earlier
16:53:40 * aavogt has written a QQ for that sometime ago
16:53:53 <Saizan> ado?
16:53:55 * ski should probably go to sleep, soon
16:54:09 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26472
16:54:11 <ski> aavogt : code, or it didn't happen ! ;)
16:55:24 <Philippa> saiam: a hypothetical 'applicative do' that I just gave an informal translation scheme for above (at least if you can see where to use <*> and where to use <* or *> in it)
16:55:29 <Philippa> er, Saizan
16:56:05 <ski> aavogt : ty
16:56:23 <aavogt> ski: I don't know about desugaring to include traverse
16:56:37 <ski> aavogt : me neither :)
16:56:49 <dobblego> is there a monad transformer for Either err (Writer log (m T)) ?
16:57:14 <ddarius> Holy crap, a house made of meat.
16:57:33 <Tomsik__> where
16:57:34 <dobblego> yes, it feels like that too
16:57:35 * ski peers around, carefully
16:58:04 <dobblego> actually that's wrong
16:58:04 <aavogt> @unmtl WriterT log (ErrorT err m) a
16:58:05 <lambdabot> m (Either err (a, log))
16:58:20 <Philonous> Is there a good way to generate fresh identifiers for a piece of (illegal) haskell code? 
16:58:31 <dobblego> I think I have Writer/Either around the wrong way; after all, I want the log regardless
16:58:35 <tolkad> Where is the source for Monad?
16:58:41 <ski> @mtl [Int] -> Either String (Bool,[Int])
16:58:42 <dobblego> Control.Monad
16:58:42 <lambdabot> Maybe you meant: ft map msg pl unmtl url
16:58:51 <tolkad> oh
16:58:54 <tolkad> found it
16:58:57 <ski> @source Control.Monad
16:58:57 <tolkad> thanks
16:58:57 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
16:59:00 <dobblego> Writer log (Either err (m T))
16:59:41 <aavogt> Philonous: template haskell generates identifiers...
16:59:56 <aavogt> but you want illegal identifiers?
17:00:06 <ddarius> Tomsik__: http://www.ted.com/talks/mitchell_joachim_don_t_build_your_home_grow_it.html  (note: this has a flash video that will begin immediately)
17:00:20 <Tomsik__> uh, flash
17:00:20 <Philonous> aavogt: Yes, but the trouble is that I can't parse the code because it's not legal haskell before I'm done with it. 
17:00:20 <ski> dobblego : well, there's `ErrorT err (WriterT log m) T', i suppose
17:00:26 <ski> @unmtl ErrorT err (WriterT log m) T
17:00:27 <lambdabot> m (Either err T, log)
17:00:30 <Philippa> aavogt: cool. Too bad we don't get layout inside QQs atm :-(
17:00:36 <tolkad> @source IO
17:00:36 <lambdabot> IO not available
17:00:38 <tolkad> 0_o
17:00:42 <tolkad> I see something imported from IO
17:00:50 <tolkad> in here: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/System-IO.html
17:00:58 <ski> @unmtl Writer log (Either err (m T))
17:00:58 <lambdabot> (Either err (m T), log)
17:01:02 <dobblego> ski, I think I had it around the wrong way: WriterT log (ErrorT err m T)
17:01:11 <tolkad> 0_o
17:01:14 <tolkad> @source IO
17:01:14 <lambdabot> IO not available
17:01:15 <tolkad> @source IO
17:01:15 <lambdabot> IO not available
17:01:16 <tolkad> @source IO
17:01:16 <lambdabot> IO not available
17:01:19 <aavogt> Philippa: you do get the \n characters
17:01:25 <ddarius> Tomsik__: You can download the video as well in other formats.
17:01:42 <Tomsik__> well, watching something right now, gonna check later
17:01:51 <ski> dobblego : i adjusted for that .. except i'm doubting whether you really want `m' at that place in `Writer log (Either err (m T))'
17:01:58 <aavogt> but not how deep the first bit is, but that's ok if you like to put newlines right after those layout-triggering keywords
17:02:31 <dobblego> ski, m will likely be IO
17:02:34 <Philippa> aavogt: yeah, true. I guess you don't need to know the rest of the layout stack either. I've not used QQs enough to know how layout for haskell code inside the QQ plays out, is that a PITA?
17:02:41 <Philippa> (do you have to reimplement the layout algo?)
17:02:44 <ski> (dobblego : doesn't affect my comment :)
17:02:47 <tolkad> what was GHC bootstrapped with?
17:02:50 <aavogt> Philippa: that code should work fine looking at layout (at least I think haskell-src-exts does)
17:02:58 <aavogt> look at the comments in the paste
17:03:12 <dobblego> ski, ok, so I'm interested why you think it might be better absent
17:03:39 <dobblego> ski, I guess the IO should go to the outside of the stack
17:03:39 <ski> dobblego : not absent .. moved to the outside
17:03:43 <ski> @unmtl Writer log (Either err (m T))
17:03:43 <lambdabot> (Either err (m T), log)
17:03:46 <ski> @unmtl ErrorT err (WriterT log m) T
17:03:47 <lambdabot> m (Either err T, log)
17:03:57 <Philippa> aavogt: fair enough, I'm mostly skimming because my doing-stuff energies really want to go on writing MultiError if I'm going to concentrate on anything right now
17:04:33 <aavogt> do you have a short description of MultiError (or should I read the scrollback?)
17:04:34 <dobblego> m (Writer log (Either err T)) 
17:05:09 <ski> aavogt : like `Error err' but collect all the errors from both arguments of `(<*>)'
17:05:14 <tolkad> what was GHC bootstrapped with? I wonder if it's taint still remains... somewhere within GHCs bytecode, waiting to show itself
17:05:53 <ski> (well, hopefully also without the bothersome `Error err' constraint on the `Monad' and `MonadPlus' instances)
17:06:15 <dobblego> is this a different discussion relating to Error err?
17:06:25 <ski> yes
17:06:30 <tolkad> dobblego: we are talking about an evil presence within GHC
17:06:33 <dobblego> ok cheers for the help
17:06:56 <ski> (well, tolkad may talk about a third thing ..)
17:07:14 <Philippa> hmm. Maybe it's even better as a rose tree so that you can annotate errors on the way back up
17:07:19 <tolkad> the source forr the IO modules is "not available"... innocent error? or devious plot...
17:07:27 <tolkad> IO module*
17:07:28 <zygoloid> @remember redocdam I don't like being greeted when I am about to troll, you ruined my whole day chrisdone
17:07:28 <lambdabot> It is forever etched in my memory.
17:07:32 <ski> @unmtl m (Writer log (Either err T))
17:07:32 <lambdabot> m (Either err T, log)
17:07:40 <tolkad> @quote tolkad
17:07:40 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
17:07:44 <Philippa> though really that's something you can do with 'multicatch'
17:07:45 <ski> dobblego : compare with `@unmtl ErrorT err (WriterT log m) T' above
17:07:50 <dobblego> @unmtl ErrorT log (Writer log T)
17:07:50 <lambdabot> err: `ErrorT log (T, log)' is not applied to enough arguments.
17:08:10 <dobblego> ski, yes got it thanks
17:08:51 <dobblego> @unmtl WriterT log (Error err T)
17:08:51 <lambdabot> err: `WriterT log (Error err T)' is not applied to enough arguments, giving `/\A. Error err T (A, log)'
17:08:59 <dobblego> @unmtl WriterT log (Error err)
17:08:59 <lambdabot> err: `WriterT log (Error err)' is not applied to enough arguments, giving `/\A. Error err (A, log)'
17:09:13 <ski> @unmtl WriterT log (Either err) T
17:09:13 <lambdabot> Either err (T, log)
17:09:25 <dobblego> ah yeah duh
17:09:47 <ski> Philippa : will you add a `catchBind' thing, a la Exceptional Syntax ?
17:09:56 <dobblego> @source Control.Monad.Error
17:09:56 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
17:10:19 <Philippa> ski: er, haven't read Exceptional Syntax, FFTSAP? I don't intend to maintain this thing and you're welcome to the maintainer hat if you want it
17:10:38 <ski> @wn FFTSAP
17:10:40 <lambdabot> No match for "FFTSAP".
17:10:45 <Philippa> Feel Free To Submit A Patch
17:11:06 <tolkad> Ken Thompson explains how an evil presence can thrive within our computers, spreading its infections from compiler to compiler: http://docs.google.com/viewer?url=http://csc.lsu.edu/~durresi/CSC7502_04/reading/thompson.pdf
17:11:13 <duairc> What did the Haskeller have for breakfast?
17:11:32 <aavogt> sounds like a laziness joke
17:11:38 <duairc> Coco-monads :)
17:12:15 <Tomsik__> haskeller doesn't have a breakfast till he is dying from hunger
17:12:18 <Philippa> aavogt: sadly, I end up looking awfully lazy because I'm shite at getting things done. Hence wanting to limit scope, publish and get someone else maintaining it ASAP
17:12:19 <tolkad> Some people think this can be overcome by bootstrapping with two different compilers and comparing bytecode... those people fail to realize: they are all infected
17:12:38 <ski> Philippa : basic idea is just `catchBind :: M a -> (a -> M b) -> (E -> M b) -> M b', which is slightly cumbersome to make if it doesn't exist (and might be inefficient) .. you want this primitive when doing loops where you want to catch over each body, and if there's an error, branch out doing something else
17:13:16 <Philippa> ah, it's bind with a catch branch, gotcha
17:14:45 <ski> Philippa : if you wanna read later : <http://martin.jambon.free.fr/extend-ocaml-syntax.html#lettry>,<http://caml.inria.fr/pub/ml-archives/caml-list/2004/12/b5b79fcd4ea695b8e1e0aff740b07cf3.en.html>,<http://research.microsoft.com/~akenn/sml/ExceptionalSyntax.pdf>
17:15:49 <Philippa> ski: thanks
17:17:18 <Polarina> Why does a simple "hello world" wx program (http://codepad.org/bZW85UMG) compile into a 13 MiB executable with a 10 MiB DLL dependency?
17:20:04 <redocdam> all this join part bullshit filling my screen looks like perl code
17:20:51 <Philippa> have your client stop displaying it, then
17:21:15 <mats> hello! =) I'm attempting to compile the ghc runtime libraries (e.g. prelude, etc.) via an ANSI-C compatible compiler with Javascript as a target. I've tried to find ghc compile-options to statically link the libs into a big executable, but then I realized the linking phase occurs post-.hc-phase. Is it reasonable/meaningful to desire files like "somecorelib.hc"? Will this strategy run into terrible issues, or is there an easy way to tell ghc to compile things like 
17:21:17 <mats> Prelude into C?
17:21:21 <Philippa> Polarina: the executable'll probably be a lot smaller if you strip it, the DLL's part of wx I believe?
17:21:44 <Polarina> Philippa, yes, the DLL is wx -- I was wondering if it was possible to embeed it.
17:22:18 <tommd> Is -dynamic not an option?
17:22:22 <redocdam> embeed it? You want to make beeds?
17:22:34 <Polarina> Statically link it.
17:22:41 <Polarina> So I do not have to carry that DLL around.
17:22:42 <Philippa> Polarina: er, possibly if you don't mind rebuilding wx and the bindings and then linking it yourself, but if wx is LGPL then you probably don't want to
17:22:55 <Philippa> (I can't remember its license)
17:23:08 <redocdam> license never matters anyways
17:23:22 <Eduard_Munteanu> Hi.
17:23:47 <tommd> polarina: If you have the wx object then just run ghc -v --make blah.hs and redo the linking manually.
17:24:01 <tommd> (copy / paste the ld command and make modifications)
17:24:22 <Polarina> Ok, thanks. :)
17:24:33 <redocdam> someone needs to do something somehow about the SIMD issue in ghc
17:24:52 <redocdam> I will pay in bananas to get it done
17:24:54 <Philippa> ah, wx's license doesn't make you distribute object code
17:25:06 <Philippa> you'll get it done by monkeys, then
17:25:20 <redocdam> since it is mostly monkey business
17:28:38 <dobblego> @mtl Writer log (Either err T)
17:28:38 <lambdabot> Maybe you meant: ft map msg pl unmtl url
17:30:37 <ski> @unmtl Writer log (Either err T)
17:30:37 <lambdabot> (Either err T, log)
17:37:43 <Philippa> hrmm. I'm trying to decide if there's /ever/ a good use for single-catch in MultiError. Or failing that, what the behaviour of catch (f <$> throw ... <*> throw ...) handler is
17:38:03 <Philippa> (that is, does it see one error then pass the second through, or see both?)
17:44:43 <Polarina> How do I compile dynamic library for package "base"?
17:48:24 <Cale> This is odd. I just installed an http proxy on my machine and told my ipod to use it, and the consequence was an order of magnitude speed increase. (I'd noticed that while accessing other computers in my wireless network from my iPod was fast, and while accessing websites from those computers was fast, it was slow to use the web on my iPod for some reason. Now it's fine.
17:48:53 <ddarius> Philippa: I think that if you have it it should be the former behavior and there should be a separate function for the latter behavior.
17:49:09 <ddarius> Philippa: However, a consideration of the algebraic properties is probably in order.
17:49:55 <ddarius> Cale: Perhaps the previous approach wasn't caching?
17:50:05 <ddarius> (for external connections that is)
17:50:09 <ddarius> I'm guessing though.
17:50:14 <Philippa> I've got a "multicatch" that gets the whole list, I'm tempted to just forego catch for now except it /is/ a good idea in combination with the monad instance
17:50:22 * c_wraith notes that accidently defining a value in terms of itself is sometimes tough to debug
17:50:57 <Philippa> non-trivial handling almost all requires multicatch and filter anyway, AFAICT. Resumable handling could be a fun thing to do though
17:51:26 <Philippa> but for now this is really a proof of concept for the basic idea of having multiple errors from different pathways
17:51:27 <ddarius> c_wraith: Yep.
17:51:51 <c_wraith> What I don't understand is why it didn't result in CPU nor memory explosion.
17:51:59 <c_wraith> err, "or"
17:52:07 <ddarius> Why would it?
17:52:18 <Philippa> (thought: I should try building a couple of parsing combinator libraries out of a collection of underlying monads/transformers)
17:52:33 <dolio> ones = 1 : ones is quite small.
17:52:45 <dolio> Two pointers.
17:52:57 <c_wraith> Except I was creating an infinite strict bytestring, and attempting to print it
17:53:19 <tommd> creating one is really the hard part, once you do that printing is a snap!
17:53:19 <ddarius> c_wraith: Are you running with -threaded?
17:53:21 <c_wraith> That...  should use one of memory or CPU
17:53:23 <c_wraith> ddarius: yes
17:53:44 <ddarius> c_wraith: Then you get a blackhole situation, but instead of printing <<loop>> it blocks.
17:53:51 <c_wraith> ahhhh.
17:53:52 <c_wraith> ok.
17:53:55 <c_wraith> that explains it
17:54:02 <c_wraith> I didn't realize the threaded runtime would do that.
17:54:25 <ddarius> If you run it without the threaded runtime you should get a <<loop>> exception.
17:54:44 <c_wraith> Is there some situation in which a different thread allows escaping the black hole?  I wouldn't expect that...
17:55:44 <Cale> ddarius: Well, it wasn't, but this speeds up things even the first time.
17:55:58 <Cale> ddarius: Particularly downloads of single files.
17:56:47 <dolio> c_wraith: If you have two threads, and one starts evaluating something, it sets a black hole, which might be seen by the other, I think.
17:57:06 <dolio> So finding a black hole might not mean you've detected a loop.
17:57:08 <ddarius> Yes.  Two threads can want to evaluate the same thunk.
17:57:14 <Cale> I would get ~1MB/s connections from the iPod to machines in the local network, and for example, 200KB/s downloading a file from a particular website using another machine on my network. But 20KB/s or even slower downloading that same file from my iPod. Putting a proxy in the way sped things up.
17:57:25 <c_wraith> I guess a blackhole would need a thread id in it to allow loop detection
17:57:34 <ddarius> c_wraith: Something like that yes.
17:57:44 <c_wraith> And the runtime cost outweighs the benefit
17:57:48 <jrockway> oops, i accidentally wrote a monad tutorial :(
17:57:49 <jrockway> http://news.ycombinator.com/item?id=1533904
17:58:07 <ddarius> jrockway: Give yourself twenty lashes and program in Python for a week.
17:59:40 <jrockway> noooo!
17:59:46 <jrockway> anything but that!
18:00:50 <c_wraith> Ok.  Intercal
18:03:34 <EvanR> Cale: i heard you talk about systematically converting an imperative procedure into functional style
18:03:47 <EvanR> do you have a webpage for this or something to avoid a full repeat?
18:03:57 <ddarius> Compilers do that all the time.
18:07:57 <Philippa> ddarius: if catch rethrows then clearly that needs to get passed on. And catch can't resume. So I think the choices are down to "catch the first error" (you lose the result if you've got more than one error, though) and "catch a singleton error"
18:08:21 <Polarina> I compiled a simple wx program and it requires the DLL wxmsw28u_gcc_custom.dll to be present. Can I somehow rename that dll and make my executable find it?
18:23:06 * Eduard_Munteanu just reorganised his bookshelf by the bed... Awodey just wasn't fitting in there properly.
18:23:27 <Eduard_Munteanu> I'm thinking of ditching all non-interesting (and non-technical) stuff out of there these days.
18:23:31 <dolio> You got a hard copy of Category Theory?
18:23:42 <Eduard_Munteanu> dolio: yes, paperback, 2010 edition
18:24:20 <dolio> Oh. That's less pricey than I would have expected.
18:24:48 <Eduard_Munteanu> dolio: mm, I got it from amazon.co.uk, the price was okay...
18:25:16 <Eduard_Munteanu> Ah, there it is, 25.45 GBP
18:25:24 <dolio> Yeah.
18:25:56 <Eduard_Munteanu> I remember it was a bit more expensive on US Amazon.
18:25:59 <dolio> I generally expect text books on something like category theory to go for a lot, given the small market it's likely to have.
18:26:08 <Eduard_Munteanu> (just got it a week ago or so)
18:26:18 <dolio> Well, it's $50, which sounds about the same.
18:26:30 <dolio> Going by my usual $1 = 2 pounds assumption.
18:26:34 <dolio> Er, other way.
18:26:38 <dolio> $2 = 1 pound.
18:26:54 <Eduard_Munteanu> 25.45 British pounds = 38.90796 U.S. dollars
18:26:57 <Eduard_Munteanu> Google says ^^
18:27:04 <dolio> Oh. I'm off, then.
18:27:32 <Eduard_Munteanu> dolio: heh, yeah, I avoid GBP too, I always remember it's high and big.
18:27:52 <ddarius> Euro is a lot lower too
18:27:52 <tg_gym> soupdragon: ping?
18:29:19 <Philippa> the GBP price includes the equivalent of sales tax, too
18:30:03 <Eduard_Munteanu> Dunno how much sales tax they got in England.
18:30:27 <Philippa> it's going up to 20% :-(
18:30:37 <Eduard_Munteanu> But strangely Farnell charged me the sales tax in my country when I bought from them.
18:31:42 <Eduard_Munteanu> Philippa: actually we've got VAT and it was just raised from 19% to 24% here.
18:31:55 <jbapple> In this comment: http://www.reddit.com/r/coding/comments/cr1yk/haskells_hash_table_performance_revisited_with/c0upf7c , Simon M. says that you could select an unboxed array type for types that can be unboxed using "automatically-specialising version in Haskell (using type familiies)", but I'm having trouble getting that to work
18:32:25 <jbapple> I am getting the error message "Conflicting family instance declarations:"
18:32:42 <jbapple> After one generic instance and one specific instance.
18:32:49 <jbapple> Let me hpaste it . . .
18:32:53 <dolio> Overlapping instances are unsound for type families.
18:33:14 <dolio> Open type families, at least.
18:34:12 <jbapple> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27869#a27869
18:34:16 <jbapple> dolio: I see
18:34:38 <jbapple> So, I may have misunderstood Simon's comment, then
18:35:09 <dolio> I believe he means that you that for any unboxable type, you can have an array that is optimal for that type.
18:35:21 <dolio> Simply by Vector T.
18:35:33 <dolio> Which is what Data.Vector.Unboxed is.
18:35:49 <jbapple> Waht do you mean "Simply by Vector T"?
18:35:53 <Eduard_Munteanu> Mmm... if Agda is based on Martin-Loef type theory, then Haskell is based on <which> type theory?
18:36:00 <jbapple> If you don't ask for an unboxed vector, you won't get one, right?
18:36:06 <dolio> Eduard_Munteanu: System F_omega, sort of.
18:36:10 <dolio> Right.
18:36:16 <Eduard_Munteanu> I don't dare say Hindly-Milner, since that's only the inference algo.
18:36:25 <dolio> Mixing boxed and unboxed vectors would be more complex.
18:36:26 <Eduard_Munteanu> dolio: I see, thanks.
18:36:52 <dolio> Eduard_Munteanu: You could say HM, too. There's a particular type system that goes with the inference algorithm.
18:36:59 <dolio> Because it's inference for that specific system.
18:37:18 <Eduard_Munteanu> Ah.
18:37:35 <jbapple> dolio: That's exactly what I would like. I am disappointed if it's not possible, though I suppose that explains all the "Unboxed" all over the array libraries
18:37:40 <Eduard_Munteanu> I hope these will become clear once I go through (and order) TAPL.
18:37:45 <dolio> jbapple: If you wanted to mix, you'd have to have instances for every particular type. Unboxable ones would choose an unboxed representation, and everything else would choose a boxed vector.
18:38:19 <Eduard_Munteanu> Though I still get a feeling I'll have to go through research papers at some point.
18:38:20 <jbapple> And that's not really possible for an array library
18:38:56 <jbapple> Maybe derivable type classes would be a better choice
18:39:05 <dolio> It's possible. But it's kind of the same of problem as Typeable.
18:39:20 <dolio> Automatically detecting what is unboxable might be hard, too. I'm not sure.
18:39:35 <jbapple> I'm willing to specify "these are the only unboxables"
18:39:36 <dolio> I guess they probably have to do that for the DPH vectorization stuff, though.
18:39:51 <jbapple> I just want it to be really easy to say "here's another boxed type"
18:40:18 <jbapple> nooooooooooooooooooo, my dolio!
18:40:28 <jbapple> phew
18:40:46 <dolio> jbapple: I can't remember at the moment if you can have defaults for associated types, but if you can, you could make declaring a new boxed vector type easy.
18:40:52 <Eduard_Munteanu> Mmm, Agda type sigs gives me creeps...
18:41:14 <Eduard_Munteanu> (or Coq or what else I read :) )
18:41:16 <jbapple> dolio: that's a nice idea, I'll try that
18:41:42 <jbapple> I can't think of another way to do it off the top of my head
18:41:48 <dolio> If you get it working, you might want to submit it as a suggestion to vector.
18:42:40 <jbapple> I think users would still have to type "instance Arrayble (MyType a) where"
18:42:49 <jbapple> and just leave an empty instance
18:43:00 <dolio> Yes.
18:43:19 <dolio> vector could at least declare it for a wide variety of standard library types, though.
18:43:35 <Axman6> what are you after?
18:43:39 <jbapple> still: yuck
18:44:05 <dolio> Axman6: An array type that automatically chooses unboxed representation when possible, and boxed when not.
18:44:22 <Axman6> vector already does that i believe
18:44:31 <Axman6> using the generic interface
18:44:32 <dolio> Not that I know of.
18:44:54 <dolio> Well, you have to choose whether you want boxed or unboxed manually.
18:44:59 <dolio> You just get to use the same functions for both.
18:45:30 <dolio> You can use the same functions for any of the array implementations via Generic.
18:45:40 <dolio> Unboxed, boxed, Storable...
18:48:04 <jbapple> dolio: you mentioned that overlapping was unsound for open type families. Since I'm willing to specify all of the unboxed types, do you think it's possible to go through a GADT?
18:48:15 <jbapple> My intuition is that they are like closed type families
18:48:30 <jbapple> (I'm more familiar with GADTs than type fams, though)
18:48:39 <dolio> I don't think that's right.
18:49:00 <dolio> GADTs are like inductive families. Type families are like defining types by recursion.
18:50:38 <dolio> That is, defining vectors as "Inductive Vec (A : Type) : Nat -> Type ..." versus... Fixpoint (I'm not that informed about Coq)?
18:51:15 <dolio> Except type families are recursing over the structure of a type, not an inductive.
18:51:32 <dobblego> ski, I think I need to put that m back in 
18:54:06 <dolio> Anyhow, I'm not sure how you'd use GADTs to select an unboxed versus boxed representation.
18:54:35 <dolio> You could use them to wrap both boxed and unboxed vectors into the same type, but that doesn't seem like it'd be a whole lot better than using the Data.Vector.Generic stuff.
18:55:04 <Eduard_Munteanu> dolio: um, some paper I'm reading on Agda right now says inductive types are the type-theoretical way of referring to recursive types.
18:55:10 <jbapple> Because you still have to pick your poison when you start?
18:55:20 <Eduard_Munteanu> At least in Agda et al.
18:55:20 <dolio> Right. It doesn't happen automatically.
18:56:07 <dolio> Eduard_Munteanu: Inductive types are like the type theoretic analogue of Haskell's "data".
18:56:31 <dolio> Somewhat restricted to avoid infinite loops, usually.
18:56:32 <Eduard_Munteanu> dolio: oh right, it's referring to 'data' declarations.
18:56:32 <illissius`> semi-relatedly, are data families good for anything besides potential optimization of representation?
18:56:46 <Eduard_Munteanu> "recursive data type"
18:56:50 <jbapple> Maybe I can use Data.Generic after using Typeable to choose the array rep -- that is, just use it for new
18:58:16 <dolio> jbapple: Maybe an existential? chooseNew :: Chooseable e => (forall v. Generic.Vector v => v e -> r) -> r?
18:59:17 <dolio> I guess Chooseable could be Typeable.
18:59:49 <jbapple> dolio: but I really don't want users to have to write "instance Choosable " for their types
19:00:27 <dolio> You could use overlapping instances there.
19:00:34 <jbapple> oh!
19:01:09 <dolio> I don't know how having a quantified v would affect things, though.
19:01:51 <dolio> It'd be difficult to combine what you have with other vectors.
19:01:59 <jbapple> I still don't understand how chooseNew would work
19:03:28 <dolio> class Chooseable e where chooseNew :: (forall v. Generic.Vector v => v e -> r) -> r ; instance Chooseable a where chooseNew f = f (new :: Boxed.Vector a) ; instance Chooseable Double where chooseNew f = f (new :: Unboxed.Vector Double) ...
19:04:03 <jbapple> hm
19:04:16 <dolio> Something along those lines.
19:05:31 <jbapple> I still don't understand how you use it -- do you use chooseNew for every operation?
19:06:05 <dolio> That probably wouldn't work very well, because even for the same element type, the vectors would be incompatible.
19:06:23 <dolio> Once you have one vector, though, you can make more using Generic's new.
19:06:55 <tolkad> If I do data T = TA {x :: Int} what is the type of x?
19:07:20 <dolio> If it's the selector function, T -> Int.
19:07:31 <Philippa> *sigh* I'm having one of those errors where I want to see the typing so I don't have to spend half an hour trying to work out how to reconstruct it and figure out where this occurs check failure's coming from :-(
19:07:40 <tolkad> oh, so I could define it for other constructors of T too then...
19:08:02 <Philippa> also, how the hell do you get a failing occurs check while /generalising/?
19:08:30 <tolkad> no, that doesn't work... it says multiple declarations...
19:08:39 <tolkad> but it has the same type! why can't I...
19:09:19 <tolkad> is there anyway to have a function be a selector for one constructor but still work for others?
19:12:29 <tolkad> omg I just extracted strings from a binary generated by GHC for a simple program (2 lines)... it has 630 strings in there! most of them are different error messages
19:13:02 <dolio> jbapple: Anyhow, you could look at the Chooseable idea as existentially quantifying to turn a Generic.Vector dictionary into a value, and then using that value to program with. Which is kind of like having modules instead, and having a function that selects a module based on the element type.
19:13:04 <EvanR> 630 strings
19:13:19 <EvanR> is that like 0.1% of the total size of the binary
19:13:46 <jbapple> I see
19:14:01 <tolkad> is there anyway to tell GHC not to include all this stupid stuff
19:14:02 <tolkad> ?
19:15:06 <dolio> Why do you care?
19:15:28 <jbapple> dolio: I might try MPTCs without any FDs
19:15:38 <Eduard_Munteanu> Does it still do static linking by default?
19:15:38 <tolkad> dolio: I don't want binaries to be too big
19:15:49 <Eduard_Munteanu> Maybe you'd get a smaller binary by doing dynamic linking.
19:16:27 <tolkad> why is there a list of options in here?
19:16:45 <tolkad> "Usage: <prog> <args> [+RTS <rtsopts> | -RTS <args>] ... --RTS <args>"
19:16:45 <Eduard_Munteanu> tolkad: for the RTS I suppose.
19:17:42 <jbapple> tolkad: I think with 6.12.3 there is a flag to disallow specification of RTS options. If you turn that flag on (at compilation), maybe it will remove that info
19:17:58 <tolkad> oh, is there anyway to tell GHC to not include RTS at all?
19:18:10 <Eduard_Munteanu> tolkad: no, that won't work.
19:18:13 <handonson> > let f (a b) (c d) = a
19:18:14 <lambdabot>   <no location info>: Parse error in pattern
19:18:27 <handonson> why is this a parse error? i'm so ignorant
19:18:48 <Eduard_Munteanu> Though I really wish there was a way to just use a subset of Haskell that needed no RTS, define your own RTS and bind it. Would be neat for stuff like House.
19:19:04 <handonson> > let f a b c d = a
19:19:05 <lambdabot>   not an expression: `let f a b c d = a'
19:19:09 <tolkad> well what about just not include any interactive RTS stuff? (debug messages, runtime errors, runtime options, etc.)
19:19:13 <handonson> > let f a b c d = a in f 1
19:19:14 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1 -> t2 -> t3)
19:19:14 <lambdabot>    arising fr...
19:19:24 <Eduard_Munteanu> tolkad: see what jbapple told you
19:19:27 <handonson> > let f a b c d = a in f (1 :: Int)
19:19:27 <lambdabot>   Overlapping instances for GHC.Show.Show
19:19:28 <lambdabot>                              (t -> ...
19:19:40 <Eduard_Munteanu> handonson: you can't pattern match on function application.
19:19:42 <Philonous> handonson: (a b) ist not a legal pattern. See for example http://www.haskell.org/tutorial/patterns.html
19:20:03 <Eduard_Munteanu> Only on constructor application.
19:20:25 <Eduard_Munteanu> say: f (Foo a) = a
19:20:27 <handonson> ah, i see
19:20:32 <tolkad> oh, well, anyway, what about selector functions? can you make instances of them for other constructors?
19:20:49 <tolkad> like data T = TA {x :: Int} | TB
19:20:49 <tolkad> x TB = 5
19:21:09 <Eduard_Munteanu> tolkad: can you write that without record syntax?
19:21:19 <tolkad> Eduard_Munteanu: yes, I want to know if you can with it
19:22:09 <Eduard_Munteanu> tolkad: no, my point is TB has no x, therefore no selector for it.
19:22:23 <tolkad> but the type of the selector is T -> Int
19:22:59 <Eduard_Munteanu> tolkad: that doesn't really matter.
19:23:02 <Axman6> x is not a tutal function
19:23:05 <Axman6> total*
19:23:09 <tolkad> I do not like selectors.
19:23:23 <Eduard_Munteanu> tolkad: think of it as 'struct' in C.
19:23:24 <Axman6> no one likes haskell's record syntax
19:23:39 <tolkad> you can't use them for class instances
19:23:39 <dolio> Some people do, I think.
19:23:40 <Eduard_Munteanu> tolkad: it's really no point applying that to a struct that doesn't have that member.
19:23:42 <dolio> Not that I can name any.
19:24:08 <tolkad> Eduard_Munteanu: I was making a Vector struct
19:24:39 <tolkad> Eduard_Munteanu: I had one constructor for cartesian coordinates vectors
19:24:53 <tolkad> Eduard_Munteanu: and one for polar coordinates
19:25:12 <tolkad> Eduard_Munteanu: you see where I am going with this?
19:25:19 <Eduard_Munteanu> tolkad: yes.
19:25:41 <tolkad> oh well, guess I can't change the language
19:26:19 <Eduard_Munteanu> tolkad: I'm not sure using the selector is the best way though, even if you could.
19:26:46 <Axman6> tolkad: what would you like to be able to achieve specifically?
19:27:02 <Eduard_Munteanu> (and if you're considering R^3 vectors, it's probably overkill to use record syntax)
19:27:26 <dolio> He wants to define functions where one case is specified by record selectors, and others are defined by a separate, normal definition.
19:27:50 <tolkad> ^
19:28:00 <dolio> But that just isn't supported.
19:28:05 <Eduard_Munteanu> He should just pattern match by constructor in other functions.
19:28:23 <tolkad> yeah, it would be nice if it was supported, no real reason not to
19:28:27 <dolio> I'd just forgo records. It only saves like two lines.
19:29:06 <tolkad> is there anyway to specify in a function type declaration that the function must be total?
19:29:13 <dolio> No.
19:29:18 <tolkad> that would also be nice
19:29:56 <dolio> It would be complex, too.
19:31:37 <Draconx|Laptop> tolkad, consider that an infinite loop can have the type forall a . a.
19:31:43 <Eduard_Munteanu> It's always total in a sense if you take _|_ as definition ;)
19:32:31 <dolio> There are several ways in which you can write non-termination in Haskell.
19:33:10 <dolio> So to support enforced totality, you'd have to have a lot of specified restrictions on what you're allowed to use in that fragment.
19:33:16 <tolkad> dolio: I heard the type system is turing complete, this implies you can make the compiler never halt?
19:33:27 <dolio> Different rules for types, different rules for recursive functions...
19:33:49 <dolio> You can with some extensions.
19:34:14 <dolio> Like UndecidableInstances.
19:42:19 <sshc> Is there an equivalent of hGetContents that operates files in binary mode?
19:42:49 <ddarius> hSetBinary handle True
19:42:54 <ddarius> @hoogle hSetBinary
19:42:55 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
19:42:56 <Axman6> ByteString has its own functions to do that doesn't it?
19:43:15 <Axman6> also, what does binary mode mean...
19:43:52 <aavogt> it probably means you don't get newlines translated
19:44:08 <aavogt> also text encodings (whatever ghc does currently)
19:44:17 <aavogt> (which has changed recently)
19:45:03 <uranther> what does it mean when GHC returns this error on compiling? Possible fix: add an instance declaration for (Integral (IO t))
19:45:23 <aavogt> uranther: you're treating an IO action like a number
19:45:48 <tolkad> uranther: like (print 5) + 2
19:45:57 <Eduard_Munteanu> And the possible fix is just wrong :)
19:46:14 <Zeiris> Who's winning the war between MTL and libmonad? Are there any particular pros/cons for either?
19:46:16 <aavogt> it could make the code compile though
19:46:46 <uranther> so should I define a number type then?
19:47:30 <aavogt> @type toInteger
19:47:31 <lambdabot> forall a. (Integral a) => a -> Integer
19:47:57 <aavogt> you'll have trouble implementing methods like that one for   Integral (IO t)
19:49:55 <aavogt> uranther: if you show the code we might be able to say how you should combine some IO action and whatever function that's forcing the Integral constraint
19:50:25 <aavogt> > toInteger (return () :: IO ())
19:50:27 <lambdabot>   No instance for (GHC.Real.Integral (GHC.IOBase.IO ()))
19:50:27 <lambdabot>    arising from a us...
19:50:56 <applicative> uranther, you can use hpaste.org, or whatever
19:51:43 <uranther> indeed, pastebin doesn't have haskell syntax highlighting
19:52:34 <uranther> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27875#a27875
19:52:36 <applicative> uranther, this sort of type error is likely to be simple to repair but illuminating about Haskelly peculiarities
19:52:48 <davekong> codepad does
19:54:00 <uranther> I'm sure it's an easy fix.. I'm just starting out in haskell
19:54:03 <aavogt>  main = sumStep 3 999 + sumStep 5 999 - sumStep 15 999
19:54:08 <aavogt>  main = print $ sumStep 3 999 + sumStep 5 999 - sumStep 15 999
19:54:21 <uranther> what is $
19:54:24 <applicative> I see you are treating a number as if it were an action.  what aavogt said
19:54:34 <aavogt>  main = print (sumStep 3 999 + sumStep 5 999 - sumStep 15 999)   -- same thing
19:54:39 <davekong> @$
19:54:40 <lambdabot> Maybe you meant: . ? @ v
19:55:01 <davekong> @info $
19:55:02 <lambdabot> ($)
19:55:25 <uranther> ah, I got it to compile and run :)
19:55:27 <uranther> thanks guys
19:55:41 <aavogt> uranther: it's right associative function application, so it's the same as a space with appropriate parens
19:56:24 <uranther> nice
19:57:10 <davekong> ($) :: (a -> b) -> a -> b; infixr 0 $
19:57:14 <applicative> uranther, but the type issue is the main issue.  "main" has to be an action, but (sumStep 3 999 + sumStep 5 999 - sumStep 15 999) is a number
19:58:35 <applicative> the function "print" maps numbers and other 'showable' things to an action, in this case of writing to the screen.
19:59:28 * aavogt would skip teaching $ because it's only needed when reading code that uses it
19:59:31 <OCboy> hay anybody at home
19:59:40 <OCboy> some one alive here
20:00:20 <Axman6> uh, yes, there's over 600 people here
20:00:54 <OCboy> most of thema re bots 
20:01:01 <OCboy> and others bnc
20:01:08 <OCboy> and no humen around
20:01:22 <OCboy> so i have to make sure
20:01:25 <OCboy> :D
20:02:36 <Axman6> or you could just ask your question and wait for someone to answer it
20:02:46 <listofoptions> yup
20:02:58 <Axman6> afaik, there's only two or three bots in this channel
20:03:20 <OCboy> but i have no question
20:03:42 <Axman6> why are you here?
20:03:58 * applicative like Pinocchio hopes that someday he'll grow up to be a real bot.
20:04:06 <OCboy> coz it's most crowded channel in da server
20:04:23 <Axman6> do you even know what haskell is?
20:04:52 <OCboy> no, but i'll find out
20:05:00 <Axman6> >_<
20:05:31 <handonson> Can I pattern-match ByteStrings?
20:05:52 <Axman6> no
20:06:02 <Axman6> well, possibly, but not the elements inside them
20:06:18 <aavogt> use a view pattern possibly?
20:06:19 <Axman6> you might be able to pattern match on the bytestring constructors
20:06:26 <applicative> What are the constructors for Bytestring??
20:07:07 <Axman6> lazy bytestrings are sort of like lists, with arrays and some ints containing info in each cons cell
20:07:23 <handonson> it seems it works when I use if~then~else~ (since ByteString implements Eq) but doesn't when I use case~of~
20:07:32 <Axman6> like, BSC Int In ByteArray# ByteString
20:07:40 <Axman6> though, that's not what it actually is
20:07:41 <handonson> it just matches everything
20:07:54 <handonson> even GHC tells me "otherwise" is overlapping
20:08:06 <handonson> overlapped*
20:08:28 * Axman6 finds using otherwise in case expressions weird
20:08:30 <handonson> i think i have to stick with if then else
20:08:41 <Axman6> handonson: what are you trying to do?
20:08:52 <handonson> match a ByteString?
20:09:02 <aavogt> you can use _ instead of otherwise
20:09:25 <aavogt> most of the time... it depends on what your RHS of that case is
20:09:33 <Axman6> handonson: more specifically
20:09:43 <applicative> data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8)    {-# UNPACK #-} !Int   {-# UNPACK #-} !Int  
20:10:00 <handonson> I have a ByteString that could be, like, "STOP" "RESTART" "KILL"
20:10:13 <applicative> pattern match that....
20:10:36 <handonson> pattern match doesn't work apparently
20:11:15 <handonson> while (==) in if-then-else is working
20:11:22 <aavogt> you can write       case toList bs of "STOP" -> ..
20:12:46 <handonson> or Data.ByteString.UTF8.toString
20:13:26 <applicative> why do you want to convert to a regular string?
20:14:00 <handonson> what do you mean why?
20:14:06 <handonson> is there a better and safe way?
20:14:16 <Axman6> (==) is probably more efficient
20:14:16 <Axman6> and you can make your code cleaner by using OverloadedStrings
20:14:44 <applicative> I was wondering if he needed OverloadedStrings, but he said if then else and == were working
20:14:45 <tommd> handonson: Why not use OverloadedStrings?
20:15:04 <tommd> nm, noticed I was the third person to say that ;-)
20:15:15 <handonson> what are OverloadedStrings? is it like i write "blah" and it will be a ByteString?
20:15:20 <Axman6> yes
20:15:21 <applicative> exactly
20:15:22 <Axman6> exactly
20:15:24 <applicative> fugues again
20:15:24 <Axman6> heh
20:15:27 <tommd> {-# LANGUAGE OverloadedStrings #-}
20:15:38 <Axman6> then you can use if str = "STOP" then ..  else ...
20:15:39 <tommd> be sure you're importing the .Char8 version of bytestring
20:15:59 <handonson> will it handle UTF8 strings safely?
20:16:40 <handonson> because i have some UTF-8 strings in my code and i'm writing it like (Data.ByteString.UTF8.)fromString "blah"
20:16:46 <applicative> If it doesn't, I blame the strings.
20:17:32 <handonson> maybe i'll just write a macro that converts all "literal" to fromString "literal"
20:18:11 <tommd> Just make an isString instance for Data.ByteString.UTF8.ByteString
20:18:23 <applicative> thats the NonOverloadedStrings way, scrap this boilerplate!  
20:27:19 <EvanR> the haskell logo is so awesome
20:27:38 <EvanR> >\= ;)
20:30:04 <mm_freak_> the real one, yes
20:30:13 <mm_freak_> not that strange lambda in a circle
20:30:18 <EvanR> right right
20:30:24 <EvanR> the newer one
20:31:17 <Cale> I find it curious that the logo has been switched back on haskell.org
20:31:22 <mm_freak_> Axman6: actually i've never used (==) for strings
20:31:24 <Cale> When did that happen?
20:31:35 <technogeeky> dunno
20:31:39 <technogeeky> but it looks terribly out of place
20:31:43 <ddarius> Cale: The wiki was reverted when Haskell.org was down.
20:31:51 <mm_freak_> Cale: did you miss the news?  the server has been compromised, AFAIK
20:32:00 <technogeeky> sigh
20:32:05 <EvanR> time warp
20:32:07 <technogeeky> time to fix this problem in haskell...
20:32:22 <technogeeky> that's rather embarassing
20:32:28 <ddarius> technogeeky: Why?
20:32:30 <mm_freak_> we have some nice wiki systems in haskell…  why don't we use them?
20:32:43 <technogeeky> Well, the length of time for recovery and the reversion is embarassing
20:32:52 <Cale> mm_freak_: I'd heard about that quite a while back, but thought it had been fixed.
20:33:00 <ddarius> mm_freak_: Because we don't have anything as "nice" or at least as "mature" as MediaWiki and also we didn't have much or any when we switched to MediaWiki.
20:33:04 <mm_freak_> technogeeky: does that mean you're volunteering? ;)
20:33:28 <technogeeky> mm_freak_: I've got something in mind
20:33:41 <ddarius> technogeeky: I think that a server migration is occurring and so its just being left for when that finishes (?)
20:33:42 <technogeeky> gitit is an acceptable starting point for some of it
20:33:46 <technogeeky> ddarius: ah ok
20:34:43 <mm_freak_> Cale: dunno, i hope that we lost no content
20:34:47 <technogeeky> by the way: http://hackage.haskell.org/package/visual-prof
20:35:09 <technogeeky> you (we) absolutely need to include sample output (and input, hopefully) for something like this
20:35:36 <technogeeky> i'm not picking on him, it's a common problem with some great haskell libs :o
20:36:45 <mm_freak_> technogeeky: well, most haskell projects are single-man-projects
20:36:51 <technogeeky> I know
20:37:00 <technogeeky> i'm observing more than criticizing
20:37:05 <ddarius> Holy crap, github uses flash for a freakin' "copy this link" button and some other weird thing.
20:37:14 <technogeeky> but some of these problems are interrelated
20:37:15 <mm_freak_> and programmers are much better at programming than they are at designing/presenting =)
20:37:49 <mm_freak_> so to make a good product /with/ a good presentation, you need at least two people ;)
20:37:54 <pikhq> Very few programmers take the time to learn about any sort of presentation.
20:37:58 <technogeeky> haha, or one person who makes that his primary goal :)
20:38:19 <pikhq> Probably the last guy to do that was Knuth, who took a few years off to learn how to typeset. :P
20:38:33 <technogeeky> well, we've come a long way since then
20:38:40 <mm_freak_> pikhq: well, knuth was an idealist
20:38:51 <EvanR> present the designer with an interface to the raw data, let him to the rest, wait for someone to do the rest, or do it yourself but think very hard first ;)
20:38:53 <pikhq> mm_freak_: True, Knuth does not take "good enough" for an answer.
20:39:28 <technogeeky> I have this feeling that a powerful but lighthearted presentation layer directly on top of haskell + visualizations for types
20:39:38 <technogeeky> the resulting UI out of that, would be a "killer app"
20:39:40 <mm_freak_> pikhq: exactly, now consider that idealists are slow at being practical
20:39:48 <ddarius> If only Knuth knew something about programming language design.
20:40:03 <mm_freak_> EvanR: actually if there is some language to make the presentation in, i'm sure programmers can do that
20:40:16 <technogeeky> bah just brute force it
20:40:22 <mm_freak_> for example there is graphviz for graphs
20:40:39 <EvanR> meaning, some designer has made the front end for you ;)
20:40:42 <pikhq> ddarius: Oh, he knows plenty. About 70s language design.
20:40:44 <mm_freak_> unfortunately programmers hate to take screenshots, edit them and put them in HTML pages ;)
20:40:49 <mats> might anyone know how to tell ghc to turn Prelude and other libraries into .hc (Haskell C) files so they could be linked manually? thank you
20:40:58 <technogeeky> for example, for ghci to behave something like Mathematica
20:41:04 <ddarius> pikhq: No, TeX and other languages by Knuth were abominations even in the '70s.
20:41:28 <mm_freak_> pikhq: he didn't know much about language design, even in the 70s
20:41:35 <mm_freak_> in the 70s lisp was already old
20:41:42 <pikhq> Oh, wait, 70s had Lisp and C...
20:41:48 <ddarius> And Scheme and Smalltalk were being born.
20:41:53 <applicative> mats, don't know. 
20:41:55 <technogeeky> i find it surprising to see us talking about this
20:42:06 <pikhq> Okay, yeah, Knuth probably had assembly on the brain.
20:42:08 <technogeeky> given the giant leap between then and now :)
20:42:26 <tolkad> technogeeky: and the availability of the perfect programming environment, enterprise Java
20:42:34 <mm_freak_> pikhq: knuth could have invented brainfuck, but not unlambda =)
20:42:43 <technogeeky> tolkad: uhh?
20:42:47 <technogeeky> hehe
20:42:47 <pikhq> technogeeky: TeX is still the single best computer typesetting system. Well, when you consider the output, that is.
20:42:54 <EvanR> each programming language channel has a big name associated with it, mats, dennis ritchie, larry wall, who is the haskell guy?
20:42:56 <Eduard_Munteanu> TeX isn't that bad
20:43:09 <technogeeky> pikhq: for some definition of best.
20:43:13 <Eduard_Munteanu> At least if you use some sane macros like LaTeX.
20:43:17 <mm_freak_> EvanR: probably SPJ
20:43:21 <applicative> mats, not sure who would be the suitable expert, seems no one now...
20:43:23 <ddarius> TeX as a typesetting system isn't that bad especially with LaTeX over it.  As a programming language it is insane.
20:43:26 <technogeeky> Typesetting is a static process, though, right?
20:43:28 <Philippa> EvanR: there's no one guy
20:43:33 <mm_freak_> EvanR: but there is no one guy
20:43:38 <EvanR> ah
20:43:42 <Eduard_Munteanu> Yeah, I guess so.
20:43:45 <mm_freak_> a lot of people have done a lot of good work in/for haskell
20:43:45 <Philippa> SPJ's probably best-known outside the Haskell community, but he doesn't come here often
20:43:46 <EvanR> so its like the borg ;)
20:43:47 <pikhq> Yes, it's a pretty poor programming language.
20:43:48 <technogeeky> Rather, it's unidirectional.
20:44:07 <pikhq> It's the typesetter with the best output.
20:44:15 <mm_freak_> ddarius: it isn't even good for typesetting
20:44:40 <mm_freak_> if the automatics fail, you really have a problem
20:45:02 <pikhq> (I think this says more about everyone else than it does about Knuth, though. *Surely* some group of enterprising, insane folk could have started with Knuth's algorithms and tried to improve on things?)
20:45:03 <mats> well thanks =) I guess I'll check back another time. was trying get haskell running in a web browser (though slowly)
20:45:09 <Eduard_Munteanu> Figures/images tend to be a problem at times.
20:45:17 <mm_freak_> and honestly i find that modern office programs can do the same, too
20:45:18 <ddarius> pikhq: People have with varying success.
20:45:24 <ddarius> pikhq: One issue is CTAN.
20:45:35 <Philippa> yeah, more generally the network effects're a bitch
20:45:55 <tolkad> wait what's like the borg?
20:46:03 <pikhq> mm_freak_: Modern office programs have only just started to *kern*!
20:46:06 <Philippa> if you can't import people's TeX/LaTeX stuff, you lose
20:46:07 <applicative> mats, it sounds like a cool project, I'm not sure who can speak with good authority.
20:46:31 <mm_freak_> pikhq: yes, they aren't as good at details (kerning, ligatures, etc.) yet
20:46:45 <ddarius> There is a relatively popular Scheme based one that I can't remember the name of.
20:46:47 <mm_freak_> but they are catching up
20:46:48 <pikhq> And their algorithm for justifying text makes word-wrap look smart.
20:46:53 <applicative> are those details,i thought they were typesetting
20:47:02 <ddarius> mm_freak_: So tehy are good at typesetting except for the typesetting parts.
20:47:10 <pikhq> mm_freak_: Those details are a major part of what good typesetting *is*.
20:47:22 <technogeeky> pikhq: i think he just gave a humorous talk about the subject
20:47:23 <applicative> pikhq, it has to be so, they cant reapply knuth's algorithm every time you type a letter.
20:47:23 <Eduard_Munteanu> LaTeX is probably my first option when writing paper-ish stuff. It's also high on my list when doing other stuff.
20:47:47 <EvanR> with unlimited time and space.... you can do anything ;)
20:47:48 <mm_freak_> ddarius: i'm talking about stuff like layout, paragraph formatting, indices, etc.
20:47:48 <Eduard_Munteanu> I don't particularly like many things about it, but I got no other good choice.
20:47:57 <ddarius> pikhq: Incidentally, there is a functional description of Knuth's algorithm in a functional pearl or something like that.
20:48:10 <mm_freak_> ddarius: they really fail only at the details
20:48:18 <applicative> there is an ML version of the mathematical typesetting
20:48:21 <mm_freak_> pikhq: they are a part, but not a major part
20:48:27 <mm_freak_> typesetting is a huge topic
20:48:34 <technogeeky> are there any examples of gitit in use?
20:48:40 <applicative> i was thinking of the paragraph breaking.
20:48:42 <technogeeky> other than the canonical one
20:48:46 <Eduard_Munteanu> applicative: oh? That would be interesting.
20:48:54 <mm_freak_> ah, good point
20:48:59 <mm_freak_> LaTeX is good at typesetting math
20:49:06 <pikhq> mm_freak_: Yeah, uh, *those details are what made Knuth invent TeX*.
20:49:10 <cncl> ddarius: there is scheme2js (part of hop) and biwascheme
20:49:11 <technogeeky> snapdragon demonstrated some library that did quite well too
20:49:13 <technogeeky> in javascript
20:49:26 <applicative> yes, i tried to find it but it seems not to be on the obvious ML sites, didn't have the nerve to ask the authors.
20:49:47 <cncl> scheme2js compiles into javascript ahead of time (in bigloo), biwascheme interprets in browser
20:50:11 <davekong> mm_freak_: which is what it was designed for
20:50:14 <applicative> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.601
20:50:33 <applicative> ^^^ A Functional Description of T E X's Formula Layout (1997)
20:50:35 <mm_freak_> pikhq: that doesn't make it a major part
20:50:46 <cncl> both do tail-call optimization, though i think only scheme2js can assert that its continuations won't exceed a certain stack amount (it uses exceptions to emulate optimized continuations)
20:50:49 <Eduard_Munteanu> applicative: thanks.
20:51:05 <applicative> port it to Haskell, we'll make millions...
20:51:17 <tolkad> will it mess stuff up if sizeOfUnboxed returns different values for different inputs?
20:51:33 <technogeeky> millions... of kilobits of downloads
20:51:39 <technogeeky> and maybe a donation or three
20:52:51 <Eduard_Munteanu> Mmm, don't get me started :)
20:53:51 <mm_freak_> btw, somehow i feel urged to try out scala
20:54:03 <mm_freak_> haskell for backends, scala for frontends sounds like a neat idea
20:54:21 <mm_freak_> (unless there is a haskell → JVM compiler)
20:54:41 <ddarius> lout was the other popular one, not based on Scheme like I thought.
20:54:59 <Eduard_Munteanu> mm_freak_: I wish there was
20:55:04 <ddarius> I know someone started one in Common Lisp but it puttered out.  I don't know if it has been picked back up since then.
20:55:10 <mm_freak_> Eduard_Munteanu: don't wait for it
20:55:13 <Eduard_Munteanu> AFAIK, there was some .NET/Haskell project
20:55:32 <mm_freak_> note that haskell doesn't have all those OOP constructs, which java has
20:55:36 <BMeph> Does someone have a list of the three main things that macros are used for, similar (conceptually, no more) to the list of uses for functions in eagerly-evaluated languages?
20:55:39 <cncl> ddarius: parenscript?
20:55:45 <mm_freak_> i think, it would be very difficult to translate most of the java classes into haskell
20:56:20 <Eduard_Munteanu> mm_freak_: which is a hell of a reason to think of a nice language-agnostic bytecode/VM spec ;)
20:56:32 <mm_freak_> BMeph: macros in what sense?  C's #define or clisp style macros?
20:57:08 <mm_freak_> Eduard_Munteanu: you can't do much in the JVM without using java's classes, unless you want to reinvent the wheel
20:57:12 <mm_freak_> and it's a large wheel =)
20:57:13 <BMeph> mm_freak_: CL/Scheme/Clojure..."Lisp-style".
20:57:29 <mm_freak_> BMeph: mostly inventing new syntax
20:57:30 <Eduard_Munteanu> Yeah, .NET seems better at taking in other languages I think.
20:57:55 <mm_freak_> BMeph: just like you use higher order functions and things like monads/arrows in haskell
20:58:04 <ddarius> cncl: This: http://www.fractalconcept.com/asp/cl-typesetting
20:58:09 <cncl> oh oops
20:58:11 <mm_freak_> Eduard_Munteanu: no, .NET has similar assumptions about the language
20:58:14 <cncl> i thought we were talking about scheme in browser, haha
20:58:37 <BMeph> mm_freak_: Mostly, but not completely. I can think of three areas, one that Haskell covers without it, one that TH covers, and areas that TH doesn't.
20:58:44 <ddarius> BMeph: Actually I have a similar list somewhere on LtU.
20:58:46 <mm_freak_> in fact, there is not much difference between microsoft's CLR and sun's JVM, just that the CLR is probably much faster on x86
20:59:03 <BMeph> I was hoping someone had a "three uses" list handy, though.
20:59:03 <ddarius> What macros are used for and what they are needed for don't completely align though.
20:59:09 <mm_freak_> BMeph: could you give an example of the last category?
20:59:50 * BMeph ponders...
20:59:57 <ddarius> BMeph: Here's one list: http://lambda-the-ultimate.org/node/687#comment-18142
21:00:22 <mm_freak_> if even TH can't express it, it must be truly insane =)
21:01:31 <Eduard_Munteanu> I wonder if VM/bytecode design really has a significant impact on performance when it comes to language features, like OO, inheritance etc.
21:01:49 <Eduard_Munteanu> i.e. whether or not it's wise to dump those and simply specify something more or less language-agnostic.
21:02:46 <Eduard_Munteanu> In fact, paradigm-agnostic.
21:03:25 <BMeph> mm_freak_: Not necessarily. I'm thinking something like ML modules, if there were a Lisp equivalent, might qualify. Macros are much more succinct at syntactic massaging, as well. 
21:03:40 <mm_freak_> Eduard_Munteanu: it really depends on which featurs the VM employs
21:04:08 <ddarius> Eduard_Munteanu: It does have an impact unless you make some extremely well thought out choices.
21:04:09 <mm_freak_> for example if it doesn't support closures very well, then functional languages are screwed
21:05:07 <mm_freak_> BMeph: i don't know exactly what TH can do, but so far i have used haskell's facilities to do meta-things as well
21:05:30 <Eduard_Munteanu> Well I'm thinking you'd have some sort of spec for the bare VM itself, and then various other specs for each language which specify how things translate.
21:05:35 <mm_freak_> for example i use monad transformers a lot, including for modularizing my code
21:05:49 <Eduard_Munteanu> (i.e. how HashMap from Haskell maps to the VM, how HashMap from Java maps etc.)
21:06:08 <BMeph> Does anyone read Adam Megacz's blog?
21:06:21 <mm_freak_> don't know him
21:06:37 <Eduard_Munteanu> But I suppose I have to think about it better myself before speculating.
21:08:45 <ddarius> Eduard_Munteanu: You -can- do such things, it's just extremely hard to make it so that all languages can be given performant implementations.
21:09:53 <ddarius> Eduard_Munteanu: While I'm not aware of any serious high-performance implementations of it, you may want to look at the SEAM virtual machine.
21:10:12 <Eduard_Munteanu> ddarius: thanks, I'll have a look.
21:10:33 <mm_freak_> Eduard_Munteanu: just take haskell as an example
21:10:38 <mm_freak_> it needs some notion of thunks
21:10:49 <mm_freak_> otherwise you're going to implement a haskell interpreter in the VM
21:11:28 <Eduard_Munteanu> mm_freak_: yeah, but there's probably something very similar to thunks but more general.
21:13:11 <Eduard_Munteanu> mm_freak_: there might be some mapping of features, at least with more advanced languages like Java, but I think the problem is the mapping isn't really trivial.
21:13:19 <ddarius> Eduard_Munteanu: Sure, closures, but Haskell implementations use various tricks with thunks.
21:13:41 <Eduard_Munteanu> (i.e. for each new language you add VM support to, you need to specify a great deal)
21:13:56 <Eduard_Munteanu> I see.
21:14:12 <applicative> BMeph, I see Mr Megacz has a diatribe against laziness. 
21:14:56 <BMeph> applicative: He has many diatribes, as a PhD student should... ;)
21:15:19 <BMeph> (Especially a Berkeley PhD student... :)
21:16:00 <applicative> Assuming you are committed to a language free from side-effects, .... (conclusion) you should go for one without laziness.  
21:16:08 <applicative> Where do i find it
21:16:29 <Rotaerk> mmm laziness
21:16:34 <Rotaerk> a virtue I'm quite familiar with
21:17:13 <Lycurgus> it's not on topic, but asking because of size of room. Anyone used nessus?
21:17:29 <applicative> It isn't clear that his views aren't shared by e.g. Simon P J
21:17:48 <mm_freak_> Lycurgus: i did
21:18:08 <Lycurgus> is my negative impression unwarranted?
21:18:10 <mm_freak_> applicative: huh?
21:18:18 <BMeph> Rotaerk: I greatly like the Devil's Dictionary definition..."Laziness (LAY-zee-ness): The character flaw associated with avoidance of doing other peoples' work." ;)
21:18:26 <Lycurgus> mm_freak_, pm?
21:18:43 <Rotaerk> haha
21:18:45 <applicative> It seems to me SPJ says more than once that the value of laziness was principally that if enforced purity.   
21:18:45 <mm_freak_> Lycurgus: about what?  and btw, a smaller channel may still contain more knowledgable people about your topic
21:18:54 <ddarius> Eduard_Munteanu: Suffice to say, many, many people have tried such a thing to varying degrees of ambition and most, if not all, have failed.
21:18:59 <Rotaerk> BMeph, perfect; I'm going to use that.
21:19:08 <applicative> Take away laziness and instantly you are ML
21:19:10 <ddarius> Eduard_Munteanu: Even LLVM which aims at being low-level has issues.
21:19:13 <BMeph> Rotaerk: :)\
21:19:18 <Lycurgus> it (nessus) but nvrmnd.
21:19:53 <Eduard_Munteanu> ddarius: hm yes, that's another example.
21:20:03 <sshc> How are happstack and happs different?
21:20:15 <Rotaerk> one has a tack in it
21:20:18 <applicative> mm_freak_ this isn't a theoretical requirement, but somehow a psychological tendency...  The case I remember best is the video 'A Taste of Haskell' but I think its a refrain of his
21:20:21 <mm_freak_> Lycurgus: i don't think nessus is useful a lot…  manual inspection and carefully written configuration files are worth much more
21:20:25 <sshc> Rotaerk: How else are they different?
21:20:36 <sshc> Rotaerk: Also, I'm not referring to the words themselves.
21:20:38 <Eduard_Munteanu> ddarius: btw, I suppose we can compile Haskell through LLVM (and perhaps retain LLVM bytecode), right?
21:20:39 * Rotaerk delegates that responsibility to someone else.
21:20:46 <Eduard_Munteanu> I mean the later stages of compilation.
21:20:47 <mm_freak_> sshc: happstack is the way to go
21:21:17 <Lycurgus> mm_freak_, my impression too, but I since I am not a young Phd. I tried to avoid being over opionated
21:21:28 <sshc> I wonder why the happstack channel is in #happs 
21:21:31 <dolio> applicative: He doesn't say that's the only value of laziness. Just one in retrospect.
21:21:49 <Lycurgus> *try to
21:22:01 <Lycurgus> sshc: legacy
21:22:08 <applicative> dolio, it obviously isn't the only value, it isn't the one that got them going about laziness to begin with, for example
21:22:18 <Lycurgus> happs basically is happstack
21:22:19 <mm_freak_> sshc: happstack is a derivative of happs…  it's actively maintained
21:22:27 <Lycurgus> ore other way around
21:22:31 <applicative> it has plusses and minuses, purity has nothing but plusses
21:22:31 <Lycurgus> *or
21:22:32 <dolio> I'm pretty sure it isn't the motivating use of laziness, either.
21:22:41 <applicative> indeed not
21:22:48 <applicative> that's his point
21:23:04 <Lycurgus> *since I am not
21:23:08 <dolio> Oh, I misread. Sorry.
21:23:09 <sshc> Are they the same thing with different aliases, or are they different libraries?
21:23:19 <sshc> If they are different, which one is more recent?
21:23:33 <Lycurgus> different incarnations of the same underlying project
21:23:41 <Lycurgus> or project line if you will
21:23:46 <mm_freak_> well, i wouldn't want to miss laziness
21:24:20 <mm_freak_> i've got so much used to it that i find it difficult to program in an eagerly evaluated language
21:24:41 <applicative> notice the "discipline disciple" business, rejects laziness, but then just like spj's principle would predict ... it has all kinds of mutation baked in
21:24:42 <mm_freak_> (that makes it hard to program in virtually any other language, which is used practically)
21:25:16 <Lycurgus> sshc: it compete's currently with another project with a different philosophy ...
21:25:29 <Lycurgus> *competes
21:25:50 <mm_freak_> actually you can say that happstack is the continuation of happs
21:26:04 <Lycurgus> (snap framework)
21:26:46 <Lycurgus> and there's also something called Yesod, but it's not quite the same sort of thing
21:27:15 <ddarius> Happstack is a fork of Happs.
21:27:57 <sshc> ddarius: Thanks
21:28:01 <Lycurgus> i thought it was more the lineal descendent, with happs a dead branch of the same line of dev
21:28:38 <ddarius> Eduard_Munteanu: GHC can compile to LLVM, though that is a fairly recent addition.
21:29:21 <Eduard_Munteanu> Ah, I see.
21:30:10 <ManateeLazyCat> When i use hPutStrLn feed "input handle" that return by "runInteractiveProcess "/bin/bash" ["-s"] Nothing Nothing", looks no response, any trick? 
21:31:58 <ddarius> Lycurgus: The main developer of HAppS didn't have the time to continue development so it was unmaintained for a while.  Others took it up and cut it down quite a bit and made Happstack.
21:32:23 <Lycurgus> ddarius, Acknowledged.
21:35:31 <tommd> Still others took Happstack, cut it down quite a bit and made "helloworld" - which is the origin of all Hello World tutorials you now know.  True story.
21:35:34 <BMeph> I remember it was on a Scala blog, but someone was commenting a few months ago about how having eager-by-default gets tripped up by laziness mechanisms, much more than the blythe remarks of its implementation would have one believe.
21:35:51 <Cale> ManateeLazyCat: Make sure that the handles are flushed?
21:36:17 <BMeph> Cale: Really? "Jiggle the handle" is your advice? ;)
21:36:52 <Cale> BMeph: Without understanding the question better, that's all I can think of.
21:36:58 <ManateeLazyCat> Cale: I don't understand? putStrLn can't feed input handle?
21:37:33 <Cale> ManateeLazyCat: The string that it sent to the handle might be getting held in a buffer which is waiting to fill before it's all sent to the child process at once.
21:37:47 <Cale> ManateeLazyCat: If the handle is block buffered, in particular.
21:38:06 <Cale> ManateeLazyCat: in which case, your child process doesn't see anything at all yet
21:38:28 * BMeph gets a comfy position in his chair, and reads "Multi-Stage Programs are Generalized Arrows"...
21:39:37 <conal> BMeph: ooh -- sounds lovely
21:40:01 <BMeph> conal: http://arxiv.org/PS_cache/arxiv/pdf/1003/1003.5954v2.pdf
21:40:14 <conal> BMeph: thx!
21:41:32 <ManateeL`> Cale: Oh, after i use hFlushAll, problem fix. Thanks.
21:41:45 <ManateeL`> Cale: Don't know need use hFlush*.
21:42:35 <ManateeL`> Cale: BTW, How much cache?
21:43:00 <ManateeL`> Cale: I mean when time buffer will full?
21:44:43 <ManateeL`> Cale: "hSetBuffering inp NoBuffering" can work too. :)
21:47:02 <sshc> How is hGetContents defined lazily?
21:47:33 <napping> by evil lies
21:47:41 <tommd> interleavePerformIO
21:47:44 <tommd> (unsafe)
21:47:53 <napping> is that not unsafeInterleaveIO?
21:47:57 <tommd> or unsafeInterleaveIO
21:48:04 <napping> well, hmm, lazy
21:48:15 <napping> you might be able to give it some semantics
21:48:19 <sshc> How should I write lazy IO code?
21:48:19 <tommd> yeah, that.  I just always like to jump on the "interleavePerformIO" because it is unsafe but drops the word "unsafe"
21:48:25 <napping> made of lies about picking the infinite string at the start of the program
21:48:25 <tommd> safely
21:48:47 <napping> interact is reasonably safe
21:48:47 <tommd> @hoogle interleavePerformIO
21:48:48 <lambdabot> No results found
21:49:30 <napping> using unsafeInterleaveIO you can make something that looks like a lazy value, but really goes out an executes something in IO when you force it
21:49:54 <napping> hGetContents more or less does that with hGetChar to give you something that looks like a string
21:50:41 <napping> The most common surprising thing that can go wrong is if you close the file before the value has been completely used
21:51:30 <tommd> I'm getting frustrated by cmdargs and parseargs.  Bart (parseargs) seems to think people only need Int/Double/String for argument data while neil seems to think assuming data structure field names and non-functional/unsafe are good ways to set argument flags
21:52:15 <napping> what do those offer beyond GetOpt?
21:52:43 <tommd> good interfaces
21:52:52 <tommd> good meaning concise
21:53:48 <napping> I thought GetOpt was pretty concise
21:54:18 <napping> which of those new ones is nicer?
21:54:25 <tommd> they are competitive.
21:55:16 <tommd> Neil made some interesting choices by using data structure field names while Bart gives more flexibility in user interface but is more limiting with parsing the input before passing off.
21:56:24 <napping> looks to me like parseargs is a little wrapper around GetOpt
21:56:51 <napping> oh, argrecord is abstract
21:56:53 <napping> is it really unsafe?
21:57:28 <napping> I was saying, looks like the GetOpt idiom of having a record updated by all your argument functions, just with some generic programming to make the record
21:57:45 <ManateeL`> @hoogle interleavePerformIO
21:57:45 <lambdabot> No results found
21:58:56 <tommd> napping: I didn't think so, but haven't thought about it much.  I know cmdargs is
21:59:39 <tommd> ManateeL`: An invention of the bytestring package if you look into it you should find it in .Internal or some such.
22:01:49 <napping> we could really use a nicer record system
22:02:20 <napping> I like the structural types they have going in MLPolyR
22:06:33 <Gwern-away> @remember donw [of JavaScript booleans] I've heard of duck-typing, and static-typing, but this is the first time I've heard of Schrödinger-typing...
22:06:34 <lambdabot> It is stored.
22:06:46 <Gwern-away> @flush
22:06:46 <lambdabot> Not enough privileges
22:06:51 <Gwern-away> hm
22:06:57 <gwern> @flush
22:16:59 <etpace> what's the safe way to Prelude.read?
22:17:19 <napping> reads
22:17:43 <etpace> ty
22:17:57 <napping> I don't remember why it returns a list
22:18:57 <napping> I usually just matched with ((x,""):_) or []
22:19:08 <napping> or _, rather
22:19:33 <etpace> yeah, wondering why it isnt just String -> Maybe a
22:20:12 <napping> Well, the String is for the rest, so you can build your own
22:20:27 <pshc> I'm using the most recent Haskell Platform on OS X; trying to compile with -dynamic gives me "Perhaps you haven't installed the "dyn" libraries for package 'base'?"
22:21:10 <napping> and a list is useful inside a parser if you need to backtrack, but I can't remember any types with ambiguous parses
22:21:11 <pshc> Can't seem to reinstall base through cabal... do I need to recompile ghc or so?
22:21:25 <etpace> true enough, cheers
22:21:27 <napping> pshc: not on OS X, but that sounds like something to report as a bug
22:21:50 <pshc> er, what's not on OS X
22:21:57 <napping> me!
22:22:03 <pshc> oh haha yeah
22:22:15 <pshc> yeah this works fine on my eeeeeeee
22:22:18 <pshc> silly OS X
22:22:26 <napping> The shared library stuff was first done on OS X, so I don't think it's like a generic not implemented
22:22:32 <pshc> hmm
22:22:55 <pshc> like if I try "cabal install --reinstall --enable-shared base"
22:22:58 <napping> It sounds like somehow you ended up with only .a versions of the libraries
22:23:11 <pshc> I get: "Resolving dependencies..." "cabal: internal error: impossible"
22:23:21 <napping> that sounds like also a bug
22:23:24 <pshc> yeah
22:23:35 <pshc> will try reinstalling first, then file
22:29:23 <ddarius> napping: No standard types have ambiguous parses.
22:30:53 <ddarius> You may want to look at the safe package.
22:30:56 <ddarius> @hackage safe
22:30:57 <lambdabot> http://hackage.haskell.org/package/safe
22:31:00 <napping> Then I remmain confused why reads returns a list
22:31:45 <ddarius> napping: Because you might make a type that requires ambiguity internally.
22:32:00 <ddarius> (well, "benefits from")
22:32:05 <pshc> colon constructors etc.?
22:32:25 <napping> and you could introduce that internally in your parsing as well
22:32:42 <napping> wrap String -> Maybe (a,String) parsers into list producers or parser combinators, etc
22:32:58 <napping> I guess the type class is pretty old
22:33:47 <ddarius> napping: There could just be a readMaybe function in the Prelude, there's no reason for there not to be.
22:34:24 <napping> There's actually a ReadP version in GHC's Read class, not exported
22:43:06 <tolkad> Should instances of * for Num be commutative?
22:43:14 <tolkad> or is it ok for them to not be?
22:44:04 <tolkad> you know, I don't think it makes sense to make vectors an instance of Num... does it?
22:44:48 <Zao> tolkad: They're not horribly Num-y, apart from having operators that happen to be spelled similarly.
22:45:16 <arcatan> Num seems to be aimed at things with field structure, and I don't think vectors have natural field structure
22:47:54 <dolio> Num corresponds more to rings.
22:48:07 <napping> That said, they stole the nice operators, so it's not uncommon to abuse it a bit
22:48:12 <dolio> There's no multiplicative inverse, for instance.
22:48:29 <arcatan> oh, you're right
22:48:44 <dolio> It's ring + extra junk.
22:48:49 <ksf> rings suck.
22:48:54 <Eduard_Munteanu> IMHO, there should be Fields, Rings, Groups etc.
22:48:57 <tolkad> what are rings?
22:48:57 <ksf> I don't trust anything beyond semirings.
22:48:59 <napping> if you feel bad about that, you can look into rebindable syntax and libraries with saner classes
22:49:38 <Eduard_Munteanu> tolkad: (R, +, *) is a ring iff (R,+) is an abelian group and (R,*) is a monoid
22:49:41 <napping> tolkad: things that have a decent set of +, -, 0, 1, *, /. Includes matrices, for example
22:49:53 <napping> wait, that's a field
22:49:57 <tolkad> Eduard_Munteanu: what?
22:49:57 <napping> ring doesn't have to include /
22:50:03 <tolkad> 0_o
22:50:19 <Eduard_Munteanu> tolkad: ah, thought you had a background. Well, lemme put it another way.
22:50:21 <tolkad> oh, it's a class
22:50:29 <mm_freak_> tolkad: vectors as such are fine as Num (leaving some functions undefined)
22:50:36 <Eduard_Munteanu> tolkad: it's a set together with something that looks like addition and something that looks like multiplication.
22:50:52 <mm_freak_> but more correct would be a custom VectorSpace class
22:50:52 <Eduard_Munteanu> tolkad: in fact it's a mathematical object.
22:50:56 <napping> and subtraction, no?
22:51:11 <arcatan> yeah
22:51:27 <Eduard_Munteanu> The addition structure within the ring is a group.
22:51:32 <Eduard_Munteanu> So it does have substraction.
22:51:45 <napping> sure, but that wasn't implied by what you said
22:51:47 <Eduard_Munteanu> That comes with the existence of inverses
22:51:48 <mm_freak_> Eduard_Munteanu: in haskell there would be no difference between a Ring and a Field class
22:52:00 <tolkad> Eduard_Munteanu: oh, like the way ordinal number have their own arithmetic operations?
22:52:11 <arcatan> i'd suggest numeric-prelude, if i'd able to make sense what's going on there...
22:52:13 <Eduard_Munteanu> mm_freak_: not enforceable, true.
22:52:26 <mm_freak_> just like we have only a Monoid class, but no Group class
22:52:26 <napping> tolkad: sure, I think that's an example
22:52:38 <napping> pretty far out
22:52:48 <Eduard_Munteanu> tolkad: yeah, it's studying abstract properties. They call it abstract algebra.
22:52:59 <napping> matrices are a decent example
22:53:09 <mm_freak_> i think, the Num class puts it much simpler
22:53:11 <arcatan> rational numbers are a ring, as are real numbers and complex numbers, but there are more abstract examples, too.
22:53:22 <napping> you can't necessarily find an inverse, but you can add and multiple
22:53:29 <mm_freak_> instances of the Num class are numeric types and that's it =)
22:53:45 <mm_freak_> finding an inverse already requires Fractional
22:53:59 <mm_freak_> but only for multiplicative inverses
22:54:00 <Eduard_Munteanu> mm_freak_: admittedly you can define substraction by inverse, and also you can define non-Num-ish monoids.
22:54:10 <napping> mm_freak_: but then you can't use + for things that add but don't really multiply, like vectors
22:54:31 <mm_freak_> napping: (*) can be a dot product
22:54:36 <mm_freak_> ah no
22:54:41 <mm_freak_> the other product
22:54:46 <mm_freak_> the outer product
22:54:50 <napping> ?
22:54:53 <tolkad> you know, they could have just made the classes: Addable, Subtractable, Multiplyable, etc.
22:55:14 <mm_freak_> that product, which you use to find a normal vector of two vectors in ℝ³
22:55:22 <Eduard_Munteanu> By operation? Yeah, that makes sense somewhat.
22:55:25 <mm_freak_> i don't know what it's called in english
22:55:29 <napping> and only works in a 3 dimensions, yes
22:55:29 <Eduard_Munteanu> Woo... some more UTF-8
22:55:33 <arcatan> cross product
22:55:41 <mm_freak_> ah yeah, cross product
22:56:00 <Eduard_Munteanu> Outer product is okay too I guess, only it's more general.
22:56:14 <mm_freak_> yeah, thought so
22:56:42 <mm_freak_> anyway, to answer the question:  in general you want a VectorSpace class
22:57:54 <ddarius> mm_freak_: A Module class.
22:58:10 <napping> tolkad: yeah, that would help
22:58:25 <Eduard_Munteanu> Yeah, I guess they're actually modules.
22:58:43 <Eduard_Munteanu> Just like we use monoids for groups.
22:58:43 <tolkad> ooh I have an idea
22:58:49 <tolkad> \/ looks like a V
22:58:50 <napping> and then to explain why it actually makes sense to call all the things with the same operator, you make rules
22:58:59 <tolkad> which stands for "Vector"
22:59:10 <napping> like - should be inverse to +, and * should distribute over +, and so on
22:59:21 <Eduard_Munteanu> Would look more like 'join' to me.
22:59:23 <tolkad> \/* \/+ \/- etc.
22:59:43 <tolkad> I'm just kidding :P
22:59:55 <napping> just make a Num instance
23:00:01 <arcatan> my eyyyys
23:00:06 <napping> or look into rebindable syntax and define your own * and stuff
23:00:07 <arcatan> +e
23:00:18 <ddarius> Clean doesn't have type classes like Haskell but has a similar mechanism that overloads functions one at a time.
23:00:23 <napping> is the pragma just RebindableSyntax?
23:00:45 <ddarius> @hackage vector-space
23:00:45 <lambdabot> http://hackage.haskell.org/package/vector-space
23:01:12 <tolkad> I wonder if it's still possible to use the language if you exclude everything...
23:01:23 <mm_freak_> instance Num a => VectorSpace a a where type Product = a
23:01:27 <mm_freak_> why doesn't that work?
23:01:29 <napping> exclude?
23:01:34 <mm_freak_> it says it doesn't know 'a'
23:01:42 <tolkad> hiding
23:01:46 <Eduard_Munteanu> Meh, type classes are more interesting, Oleg gets to do lots of stuff with 'em :)
23:02:20 <napping> you can still do data types and functions on them
23:02:30 <ddarius> In two or three years we need to make a real new version of Haskell.
23:02:53 <napping> have to play with them in the interpreter, but you can define them
23:02:58 <Eduard_Munteanu> ddarius, what do you mean?
23:03:08 <RayNbow> everytime I see a discussion about vector spaces, I'm reminded of an awesome post by sigfpe ( http://blog.sigfpe.com/2009/05/trace-diagrams-with-monads.html )
23:03:31 <ddarius> Eduard_Munteanu: Something that bulldozes everything and rebuilds like the Haskell Reports up to and including Haskell 98.
23:03:52 <tolkad> @quote tolkad
23:03:52 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
23:04:11 <napping> ah, but what new experiment do we throw in?
23:04:22 <tolkad> ddarius: you mean haskell releases new language versions which are very un-backwards-compatible?
23:04:41 <napping> tolkad: more like it's getting to be time to design a successor language
23:05:15 <Eduard_Munteanu> ddarius: well it would certainly help to bring some stuff from Agda back too. I just hope compatibility reasons won't prevent it.
23:05:20 <ddarius> napping: Not too many.  If associated types work out, it would make many things more pretty.  We need to redo the standard libraries.  Undo some missteps.
23:05:32 <ddarius> Eduard_Munteanu: Haskell will never have dependent typing like Agda.
23:05:37 <Eduard_Munteanu> For the worse or better, Haskell is one of the better adopted languages.
23:05:43 <napping> that is, I disagree if "releases" indicates a general tendancy
23:05:45 <ddarius> napping: There are, arguably, successor languages to Haskell.
23:06:06 <napping> which?
23:06:17 <napping> I know of extensions
23:06:22 <ddarius> napping: It depends on what direction you want to go.  Agda is the most obvious.
23:06:40 <Eduard_Munteanu> ddarius: let me guess, because they can't be inferred? Or is Martin-Loef (any other dependent type theory?) type theory so dissimilar it won't do?
23:06:55 <tolkad> maybe you could give access to some features that aren't necessarily limited to turing complete execution environments
23:06:59 <napping> Okay, Agda is a fine language. Maybe a bit far on practical stuff to seem related
23:07:17 <tolkad> you know, super tasks and the like
23:07:18 <napping> tolkad: Agda does quite a lot of that. It's a good idea
23:07:30 <mm_freak_> (i'm starting to see why type families are more elegant than fundeps)
23:07:33 <ddarius> Eduard_Munteanu: By the time dependent types are ready to be put into a language like Haskell, there would already be a much better dependently-typed-from-the-ground-up language to use than some awkward hybrid into Haskell.
23:07:42 <Eduard_Munteanu> Yeah, just to be clear, I'm not talking about making it Haskell strictly total or imposing stuff like that.
23:07:43 <manjunaths> dibblego comes of as an elightist in the memoize thread on reddit :-/
23:08:05 <tolkad> napping: yeah, personally I execute all my programs on a zeno machine but most programming languages don't have the proper bindings I need
23:08:21 <napping> manjunaths: You seem to go to great lengths to avoid giving that impression ;)
23:08:34 <Eduard_Munteanu> ddarius: yeah, I see your point. We barely laid out practices and worked out details for Haskell...
23:08:44 <mm_freak_> now that agda has been mentioned…  actually i really only miss dependent types
23:08:47 <ddarius> Eduard_Munteanu: A language with dependent typing plus features that are commonly used in Haskell would be roughly equivalent to the Calculus of Constructions.
23:08:52 <manjunaths> napping, I have not posted in the thread ?
23:09:02 <mm_freak_> and not even that much actually, but it would be great to have them
23:09:03 <napping> manjunaths: I was just joking about your spelling.
23:09:16 <tolkad> napping: what do you think of the matter?
23:09:20 <manjunaths> napping, ah..right elitist
23:09:22 <mm_freak_> otherwise i don't think agda is ever going to be a practical general purpose programming language
23:09:28 <manjunaths> wonder where that came from
23:09:42 <ddarius> mm_freak_: They would be really nice to have upon occassion, but they are definitely not something that could just be enabled with a compiler flag.
23:09:47 <napping> tolkad: having functions that are known to terminate can be really handy
23:10:01 <mm_freak_> ddarius: yes, and they also shouldn't be overused
23:10:02 <ddarius> mm_freak_: I doubt it will either, but I imagine one will grow from it someday.
23:10:24 <manjunaths> I hate these threads on reddit, most people against haskell are trolls who've probably never tried it
23:10:27 <napping> We could do with some kind of extensible variants
23:10:40 <jrockway> brilliant: http://groups.google.com/group/clojure/msg/de500b27a81d7033
23:10:47 <napping> manjunaths: I don't think it's that bad, but I always have trouble with types
23:10:53 <tolkad> napping: yeah, I often want to execute an infinite number of operations in a finite amount of time, but haskell just doesn't let me do that
23:11:10 <mm_freak_> i wouldn't want my list type to become:  List IsSorted IsWhatever NumElements SomeOtherInfo a
23:11:23 <napping> tolkad: oh, you are talking about things past what a turing machine can do
23:11:24 <ddarius> The way I see Haskell going is that it will continue to push the edges and flirt with dependent typing but will never have it as an integral part of the language.
23:11:28 <edwardk> tolkad: i think you may need to rethink what is blocking you. there is this reality thing that also gets in the way ;)
23:11:28 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
23:11:30 <napping> tolkad: I mean it's helpful to make the language weaker
23:11:33 <manjunaths> napping, so do I, but once you get the hang of it, it feels really ...liberating
23:11:59 <ddarius> mm_freak_: Solving problems like that is one of the things the dependently typed programming community needs to figure out.
23:12:09 <mm_freak_> mergeSortedLists :: List Sorted _ _ _ a -> List Sorted _ _ _ a -> List Sorted _ _ _ a
23:12:11 <napping> manjunaths: I mean, when people say they don't like things, I'm not sure if they've never seen better than Java, or if they have good experience and some real issues anyway
23:12:14 <manjunaths> napping, but you can catch so many errors during compilation, I am rather impressed by it
23:12:26 <manjunaths> napping, I guess it is just inertia
23:12:38 <mm_freak_> ddarius: i think there isn't even a really useful concept of how to do I/O
23:12:52 <napping> manjunaths: sounds like you are still enjoying the upsides
23:12:57 <manjunaths> napping, I used to argue against C++ with my friend when I only knew C. I was young and probably bigoted :-)
23:13:02 <ddarius> mm_freak_: Right now there is a lack of some appropriate notion or pattern of "polymorphism" so that you can mix and match types without caring too much about what properties they encode.
23:13:17 <manjunaths> napping, yes, some perks of being a newbie I think :-)
23:13:18 <ddarius> It may just be that the best solution is to have proofs as a separate layer.
23:13:35 <tolkad> edwardk: that doesn't mean it can't be part of the language specification
23:13:39 <napping> The PROGRAM stuff in Coq is trying to sort out some of that
23:13:47 <napping> it's one answer at least
23:13:55 <manjunaths> napping, ok
23:14:24 <mm_freak_> ddarius: i agree…  proving correctness is difficult, even though proving theorems may be easy
23:14:28 <ddarius> Coq is definitely the most mature and advanced dependently typed system currently available, but it is geared as a proof assistant and less so as a programming language (though it may be the best dependently typed programming language currently)
23:14:51 <napping> manjunaths: you can do even stronger things with dependent types, but I think doing so still often takes a little too much effort
23:14:59 <mm_freak_> i didn't like Coq's syntax, and i want to write applications anyway
23:15:37 <napping> manjunaths: at least if your goal is to produce robust programs as quickly as possible. It gets better with more research, though
23:16:05 <manjunaths> napping, Yes I understand and I don't have the delusion that haskell is perfect :-)
23:16:18 <napping> Chlipala suggests it's best to write functions and prove things about them on the side, rather than encode everything into types
23:16:22 <ddarius> There have definitely been several large strides in usability of dependent types recently and there is a lot of activity currently.
23:16:31 <mm_freak_> btw, currently i have two instances…  one defines a base case, the other one defines a recursive case…  in the base case, the two instances are overlapping
23:16:44 <mm_freak_> the solution would be to disallow a certain type in a flexible instance
23:16:46 <mm_freak_> is that possible?
23:17:04 <ddarius> napping: Which can be done with any language with or without dependent typing.
23:17:06 <manjunaths> napping, yes, if haskell is even a little better than C++ and Java for writing good programs, I think I've achieved my goal by learning haskell
23:18:00 <mm_freak_> side note:  you can do dependently typed programming in haskell…  it's just not as powerful as in agda
23:18:00 <Eduard_Munteanu> Yeah, the way type sigs look in Agda sometimes is just so non-Haskell.
23:18:10 <napping> I would tend to agree - data structures include their invariants, but tacking extra info on the side with a { v | Proof } seems rarely worth the trouble
23:18:28 <mm_freak_> for example the following is well possible in haskell:  myHead :: List (Succ n) a -> a
23:18:41 <napping> mm_freak_: that's not really dependent typing
23:18:41 <mm_freak_> or:  sort :: List _ a -> List Sorted a
23:19:02 <napping> that's just ordinary type level stuff
23:19:03 <mm_freak_> napping: yes, but it solves some of the problems dependent types are designed to solve
23:19:15 <ddarius> mm_freak_: A very tiny part.
23:19:36 <ddarius> GADTs are probably the closest thing to dependent types that Haskell currently has.
23:19:58 <mm_freak_> you would need that in combination
23:20:23 <dolio> The sort one doesn't really do the work that dependent types do, either.
23:21:00 <Eduard_Munteanu> Some also talk of type families as type functions it seems.
23:21:02 <mm_freak_> data List s a where Empty :: List Sorted a, Cons :: a -> List _ a -> List Unsorted a
23:21:13 <ddarius> Eduard_Munteanu: Yes, but type functions aren't dependent types.
23:21:14 <Eduard_Munteanu> Which is also similar to dependent types.
23:21:21 <mm_freak_> s/_/s/
23:21:31 <Eduard_Munteanu> Yeah, it isn't the same thing. I saw it mentioned in a Coq tutorial.
23:21:41 <ddarius> Eduard_Munteanu: Type functions don't depend on values in any way.
23:22:14 <napping> If you don't have types depending on values, you don't have dependent types
23:22:30 <napping> GADTs are kind of in between
23:22:40 <dolio> Type families are a sort of type function you won't find in most dependently typed langauges, too.
23:22:51 <napping> you still don't have types depending on values, but you can learn more about your type environment by examining values
23:23:07 <Eduard_Munteanu> Ah, my mistake then, I think it was rather a replacement of type universes.
23:23:12 <napping> Type families are so easy to code up with a universe description of types, though
23:23:20 <napping> so it's not that different in a closed world
23:23:51 <ddarius> I wouldn't be surprised if a much more sophisticated kind level is in the future of Haskell.  Much in the vein of the Omega language.
23:23:51 <napping> Anyway, one thing I want in Haskell that's not dependent types is extensible variants
23:23:58 <dolio> Yes, that's true.
23:24:23 <napping> To say that certain constructors are not possible in certain parts of the program
23:24:39 <napping> some way to re-use constructor and field names would be nice too
23:24:44 <napping> Agda seems to do okay, somehow
23:24:47 <fffej> Is there a preference between c2hs and hsc2hs?   
23:24:47 <ddarius> Refinement types are something I'd like to see more work done on.
23:25:10 <ddarius> fffej: They are different tools with different, but overlapping goals.
23:25:23 <fffej> ddarius: can you elaborate?
23:25:48 <napping> both are for helping you generate FFI bindings, one tries to be a bit more full-service than the other
23:25:56 <napping> and ends up being a bit more complicated to learn as well
23:26:34 <Eduard_Munteanu> I think Agda/Coq have no kinds. There are simply small types, large types, even larger types etc. :)
23:26:41 <fffej> napping: full-service sounds good, which one would that be?
23:27:01 <napping> I think c2hs is the fancier one
23:27:05 <ddarius> fffej: I usually don't use any binding tools.
23:27:07 <ddarius> napping: It is.
23:27:16 <napping> actually, looking again hsc2hs seems to be more about interfacing to structs
23:27:30 <napping> by parsing headers and inserting offsets and stuff automatically
23:27:47 <napping> what's the other binding generator then?
23:28:51 <ddarius> napping: That's the only thing that you -really- need when doing FFI work that you can't do just from the raw FFI (as in you'd have to manually calculate and hard-code the offsets == really bad idea.)
23:28:57 <Eduard_Munteanu> I think I'm gonna continue with learning Coq for now, Agda isn't that widespread and documented.
23:29:06 <napping> both are interesting
23:29:14 <Eduard_Munteanu> (that looks like Haskell too, IMHO)
23:29:35 <ddarius> Agda has the benefit that (in version 2) it is geared toward being an actual programming language.
23:29:52 <napping> It's much better at pattern matching
23:30:16 <Eduard_Munteanu> ddarius: yeah, I cringed at the way they built a program using denotational semantics in Coq
23:30:25 <Eduard_Munteanu> and then 'eval'-ing it.
23:30:30 <Eduard_Munteanu> Not really a program though.
23:30:54 <napping> I think I've pretty much figured out how to use return clauses, and apply matches to (refl_equals _) and stuff to get connections between arguments and match results, but it's always a pain
23:31:22 <j4cbo> are there any tools that can reasonably help with reverse engineering a compiled program that was written in a functional language?
23:31:25 <Eduard_Munteanu> And yeah, I'm mainly looking at Agda 2.
23:31:25 <napping> on the other hand, tactics and notations are both quite nice
23:31:44 <napping> j4cbo: I know of no such things.
23:32:01 <j4cbo> that's what i thought
23:32:08 <napping> If you are trying to reverse engineer a Haskell program there's some decent information on GHC's runtime data structures
23:32:36 <Eduard_Munteanu> Decompilers for just about any language suck.
23:32:45 <j4cbo> actually, i've written a little crackme compiled with my own ML compiler, and i'm wondering how hard it will actually be to solve
23:33:03 <napping> Eduard_Munteanu: regarding the kind hierarchy, there's the tower of Set s
23:33:32 <Eduard_Munteanu> napping: yeah, I suppose that's infinite. A nice generalisation vs. the kind system.
23:33:54 <napping> Prop on the side is a different sort of thing
23:34:18 <napping> but the tower of Set_i is a quite direct extension, in a PTS kind of way
23:34:45 <napping> j4cbo: you wrote it yourself? What are you trying to solve then?
23:34:50 * hackagebot TypeCompose 0.8.0 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.8.0 (ConalElliott)
23:35:10 <Eduard_Munteanu> I wonder if that means it's not really meaningful in Haskell or a future language to have * -> * be a *.
23:35:12 <napping> Eduard_Munteanu: actually, Java decompilers can work pretty well
23:35:21 * ddarius imagines trying to deal with the output of GHC at the assembly level...
23:35:38 <j4cbo> napping: for other people to solve it.
23:35:40 <Eduard_Munteanu> napping: yeah, bytecode is an entirely different thing :)
23:35:40 <ddarius> Because JVM = linearized Java
23:35:44 <napping> in the JVM a method call bytecode includes a reference to the full string name to be called
23:36:10 <napping> j4cbo: Well, then it's their problem, right?
23:36:15 <Eduard_Munteanu> You also get the object structure.
23:36:24 <napping> just label it "Very Hard" if it turns out to be :)
23:36:33 <Eduard_Munteanu> And you know the types of the members, whether they're virtual etc.
23:36:50 * hackagebot functor-combo 0.0.0 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.0.0 (ConalElliott)
23:37:24 <dolio> * -> * is not a * in Haskell.
23:37:53 <Eduard_Munteanu> dolio: yeah, but it'd be interesting I suppose.
23:38:14 <napping> in practice it seems to be possible to pretend, by having the compiler infer universe levels
23:38:18 <dolio> You can do that, but it leads to an inconsistent logic.
23:38:32 <dolio> For instance, if you have * : *, that's rather like having a set of all sets.
23:38:34 <napping> so you write * -> * :: *
23:38:51 <napping> and it goes in and makes it *_i -> *_j :: *_{max i j}
23:39:02 <dolio> Yes, you can do that, too.
23:39:05 <Eduard_Munteanu> dolio: well yeah, you make them like classes and like Agda/Coq do with small/large sets.
23:39:25 <napping> infinite towers of universes and disassembling the results in 5 minutes
23:39:29 <Eduard_Munteanu> Then there's no Russel's paradox.
23:39:33 <dolio> I'm not sure how great letting the compiler infer universe levels is, though. Sometimes it's nice to be able to talk about them explicitly.
23:39:54 <napping> I think Agda handles it reasonably, by making it optional
23:39:58 <Eduard_Munteanu> Nah, inferring isn't that useful really.
23:40:07 <ddarius> BitBlaze and a spin-off project, BAP are probably the most active/comprehensive binary analysis tools out there.
23:40:27 <Eduard_Munteanu> Agda does no inferring AFAIK.
23:40:36 <Eduard_Munteanu> At all.
23:40:37 <ddarius> More geared towards security uses though.
23:40:47 <napping> Eduard_Munteanu: not true. They infer universe levels
23:41:08 <Eduard_Munteanu> I see.
23:41:17 <dolio> For instance, there was a guy who was doing work on an alternate model of type theory in Coq, and his work has universe inconsistency errors that aren't really errors.
23:41:22 <napping> and also plenty of types inside applications anyway
23:41:41 <napping> dolio: just because they were at the wrong level>
23:41:54 <dolio> Perhaps he could clear them up talking about the levels explicitly, but Coq doesn't let you do that.
23:41:54 <napping> j4cbo: I don't think ML code should be that hard, just different
23:42:21 <napping> j4cbo: you'd have to figure out the stack format, and object representations, and you would get very very very familiar with the inlined memory allocation call
23:42:24 <j4cbo> i think that's part of it - RE tools tend to make a lot of assumptions about stack frames and such
23:42:29 <dolio> Of course, maybe it's just a limitation in how Coq allows the levels to be instantiated, too, and not in the solver. I'm not sure.
23:42:42 <j4cbo> which is no good if the code has been CPS converted
23:42:52 <napping> well, you could have that too
23:43:04 <dolio> napping: I don't know what causes the errors exactly, but he stated that he can eliminate the errors by duplicating code.
23:43:16 <napping> hmm, dunno what would do that
23:43:23 <j4cbo> and once the GC runs, everything gets rearranged
23:43:34 <napping> oh, yeah, there would be that
23:43:47 <napping> although, you should be able to handle that if you are in the debugger
23:44:14 <napping> just alloc up a list that points to all the things you want to hang onto pointers to, and hang it off a root
23:44:53 <dolio> Eduard_Munteanu: Agda does a lot of inference, actually.
23:44:56 <ddarius> dolio: Coq doesn't have universe polymorphism, no?
23:45:03 <j4cbo> yeah, i think step 0 would be figure out the stack format
23:45:04 <j4cbo> er
23:45:06 <j4cbo> heap format
23:45:16 <napping> actual stacks are not that uncommon
23:45:33 <j4cbo> what the bits in a boxed integer/pointer indicate, etc
23:45:40 <Eduard_Munteanu> dolio: I see. Then perhaps they simply don't have inference for function types. I think that's true in either Coq or Agda.
23:45:48 <dolio> ddarius: It has something like it, but I'm not sure what all the restrictions on it are.
23:45:51 <ddarius> j4cbo: Depends.  If you just need to slightly tweak the behavior, often some fiddling and intuition is enough.
23:46:06 <Eduard_Munteanu> In any case, given the practices, I think inference is a bit overrated.
23:46:12 <mtnviewmark> woot - just booked my travel to the Haskell Symposium & Haskell Implementors Workshop
23:46:21 <ddarius> dolio: It sounds like it fakes it to some extent but doesn't really have it, but I'm not sure if that might have been changed recently.
23:46:23 <Eduard_Munteanu> (though it helps debugging stuff)
23:46:37 <napping> Eduard_Munteanu: um, are you joking?
23:46:46 <ddarius> Lack of universe polymorphism would definitely lead to cases where you need to duplicate code to get it to type check.
23:46:51 <dolio> ddarius: Like, you can define List (A : Type) : Type, and use it elsewhere as both 'List Set' and 'List True'. But there's some weird restrictions about instantiating something at two different levels in the same expression or something.
23:46:55 <napping> Eduard_Munteanu: Type parameters at applications need to be inferred
23:47:30 <Eduard_Munteanu> napping: nah, I'm just referring to inferring type sigs for functions.
23:47:31 <dolio> Maybe that's not a good example, because True can be lifted up the hierarchy, too.
23:48:01 <dolio> But yes, it's not really genuine universe polymorphism, I think.
23:48:02 <Eduard_Munteanu> napping: most just write type sigs properly, and it's better that way.
23:48:23 <napping> oh, yeah, that's hard to do
23:48:33 <Eduard_Munteanu> (existentials also need explicit type sigs)
23:48:49 <Eduard_Munteanu> Um, rather rank-2 types, I mean.
23:49:04 <napping> but there's still quite a lot of inference going on inside expressions
23:49:28 <ddarius> Not doing push-ups at all for five months really degrades your performance.
23:49:33 <Eduard_Munteanu> napping: hm, I thought type checking was a lot simpler than inferring.
23:49:55 <Eduard_Munteanu> (i.e. you don't need inference for checking, and it's easier to check than to infer)
23:50:10 <Eduard_Munteanu> Like in rank-N types.
23:50:28 <ddarius> Eduard_Munteanu: It's actually not always easier to check than infer, though that is the case (or at least they are equally hard) for most common type systems.
23:50:33 <napping> it takes higher order unification just to apply functions
23:50:56 <dolio> Eduard_Munteanu: Agda requires you to write signatures for all functions. But you can make it do inference of various things even in them.
23:51:04 <dobblego> is there an early break from foldM?
23:51:05 <dolio> 'foo : _' will make it try to infer a type for foo.
23:51:15 <dolio> Which is unlikely to work, I expect.
23:51:18 <Eduard_Munteanu> Oh.
23:51:32 <napping> dobblego: not unless you stack a transformer that supports it
23:51:42 <dolio> But you can do 'foo : forall a b c -> a -> b -> c' and it will try to infer the types of a, b and c.
23:51:51 <dobblego> I'm exhausted from stacking transformers
23:52:04 <dobblego> @src foldM
23:52:04 <lambdabot> foldM _ a []     = return a
23:52:04 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
23:52:16 <dobblego> I'll pattern-match, cheers
23:52:17 <dolio> Although that, too, is ambiguous, because although they must have type Set n, n could be any level.
23:52:39 <napping> j4cbo: what kind of ML are you using?
23:52:51 <Eduard_Munteanu> Hm, it'd be interesting to specify the level of forall.
23:53:14 <j4cbo> napping: Standard ML-ish (the elaborator is still quite incomplete)
23:53:18 <Eduard_Munteanu> Like not "it's not just forall a, but forall a of the same level"
23:53:22 <Eduard_Munteanu> *a, b
23:53:25 <napping> oh, writing your own
23:53:30 <j4cbo> yeah
23:53:37 <napping> That could make a harder puzzle
23:53:45 <dolio> But, if you have instead: 'forall n -> Vec T n', it can infer that n : Nat.
23:54:03 <napping> simpler code, but less supporting tools
23:54:22 <Eduard_Munteanu> dolio: oh, so that type can only depend on Nats? I'm just starting out in Coq/Agda.
23:54:33 <Eduard_Munteanu> *that type == types
23:54:50 <dolio> n is the size of the vector, so yes, it must be a natural.
23:55:00 <napping> this is in agda?
23:55:08 <dolio> And Agda can figure that out, so you don't have to write it elsewhere.
23:55:11 <napping> oh, yeah
23:55:37 <j4cbo> napping: yeah, it's really fun to play around with a compiler toolchain that's (almost) entirely my own code
23:57:17 <dobblego> @hoogle eitherM
23:57:17 <lambdabot> No results found
23:57:57 <Eduard_Munteanu> Have to go, goodbye and thanks for the pointers.
23:59:15 <kmc> hi lambdabot
