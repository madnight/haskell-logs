00:02:03 <etpace> does anyone know of a hackage package that has some stats tests for correlation? statistics seems to just have autocorrelation
00:04:51 <cads> thanks byorgey
00:04:56 <cads> I'll read more about it
00:06:13 <Axman6> :t join (&&&)
00:06:15 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
00:06:36 <Axman6> @pl \f (a, b) -> (f a, f b)
00:06:36 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
00:40:48 <refold> Why importing 'Control.Monad.Fix' has an effect on the type of 'fmap fmap fmap'?
00:42:24 <byorgey> refold: because Control.Monad.Fix exports (among other things) a Monad instance for ((->) e)
00:43:03 <byorgey> notice the types are the same except that without importing that module there is an extra type class constraint
00:43:35 <byorgey> but once that instance is in scope it can satisfy that constraint so it no longer needs to be mentioned explicitly
00:44:16 <refold> byorgey: Thanks!
00:44:54 <byorgey> sorry, I meant a Functor instance for ((->) e), but hopefully you figured that out =)
00:51:45 <sinelaw> ahlan!
00:53:43 * hackagebot cairo-appbase 0.2 - Template code for an app using GTK, Glade and Cairo graphics  http://hackage.haskell.org/package/cairo-appbase-0.2 (ConradParker)
01:00:01 <byorgey> sinelaw: ?
01:00:36 <sinelaw> byorgey, hi.
01:00:38 <sinelaw> :)
01:03:27 <byorgey> hi sinelaw =)
01:03:45 <sinelaw> byorgey, ahlan (or ahalan) is hi in arabic
01:03:54 <sinelaw> ...and in israeli hebrew
01:16:41 <zachk> gutentag ! 
01:25:57 * hackagebot easy-file 0.1.0 - Cross-platform File handling  http://hackage.haskell.org/package/easy-file-0.1.0 (KazuYamamoto)
01:37:26 <kfish> http://blog.kfish.org/2010/07/haskell-template-for-gtk-glade-cairo.html
01:38:40 <ivanm> OK, so kfish spams the channel with his blog and then leaves? :/
01:40:04 <kulin> classy
01:40:23 <beroal> is there a moferator?
01:40:57 <ivanm> you mean "moderator"?
01:41:16 <beroal> is here a moderator?
01:41:18 <ivanm> kfish usually hangs around here, and the blog post appears haskelly, so it's not like it was drive-by-spamming
01:41:27 <ivanm> beroal: we have ops if needed (spammers, trolls, etc.)
01:42:38 <beroal> I think posting links to someone's own blog is spam. If we want haskellish posts from someone, we can just subscribe to his/her blog.
01:42:56 <opqdonut> well you better part then
01:43:03 <opqdonut> since lots of people advertise their own posts here
01:43:09 <opqdonut> and I for one am interested
01:43:19 <opqdonut> I can't subscribe to every blog there is
01:43:20 <kmc> better to post it to reddit i think
01:43:36 <opqdonut> I don't read reddit :)
01:43:37 <beroal> yes, I usually is not here because no one can handle a discusion with 599 people.
01:43:51 <opqdonut> it's never a discussion with 599 people
01:44:00 <opqdonut> it might be 5 conversations at once, though, which can be unsettling
01:44:10 <quicksilver> not all that often, to be honest
01:44:27 <quicksilver> there are a lot of people here but it's not actually a noisy channel compared to some others I'm in with far fewer
01:44:27 <ivanm> opqdonut: planet.haskell.org !
01:44:44 <ivanm> but I've never seen anyone just randomly past a link to their blog here before
01:44:46 <opqdonut> quicksilver: agreed
01:44:53 <opqdonut> yeah planet is ok
01:44:53 <quicksilver> I'm sure I have.
01:44:55 <ivanm> as an answer to a discussion, yes (I've done it before)
01:44:57 <beroal> opqdonut: there is a lot of tools in Internet to handle such cases gently, without polluting discussions -- RSS, reddit, blog search.
01:45:16 <quicksilver> well, I certainly don't object to interesting haskell blog posts being posted here.
01:45:18 <opqdonut> conal mentions his new posts here quite often, i think
01:45:19 <ivanm> beroal: my comment was more on kfish leaving right after posting the link
01:45:22 <ivanm> quicksilver: agreed
01:45:23 <beroal> opqdonut: you can even subscribbe to blog search!
01:45:26 <quicksilver> sometimes they stimulate a discussion.
01:45:39 <ivanm> but without any discussion/background it's a little weird just to have the links on their lonesome
01:45:44 <opqdonut> sure
01:45:44 <beroal> ivanm: that is a special case of a problem. :)
01:45:51 <opqdonut> I appreciate links
01:45:58 <opqdonut> they tend to be chosen well
01:46:05 <quicksilver> it's a special case, but it's a non-problem, here at least.
01:46:13 <opqdonut> as opposed to the stuff from search engines :)
01:47:31 <beroal> ivanm: a link without a discussion is a spam. even viagra may be a legitimate discussion, if everyone want to discuss it.
01:48:05 <quicksilver> I think we're just going to have to disagree.
01:48:17 <ivanm> beroal: I believe I said something along those lines already...
01:48:18 <quicksilver> A link without discussion is no more spammy than any other kind of remark without discussion.
01:48:35 <quicksilver> anyone can utter a sentence here and have no one reply; that doesn't make it spam.
01:48:43 <quicksilver> a link is no more inherently spammy than any other remark.
01:48:49 <quicksilver> of course people have to choice to read it or not.
01:48:55 <ivanm> quicksilver: true
01:50:49 <beroal> quicksilver: I will not debate. I see no retional arguments.
01:52:20 <quicksilver> I thought I was being quite rational actually.
01:52:31 <quicksilver> He was the one irrationally defining a link as spam without explaining why.
01:52:59 <ivanm> quicksilver: well, he did say why (doesn't mean his arguments were rational)
01:53:25 <ivanm> but I've never seen him here before IIRC, and he didn't bother to bitch until I commented on it first...
01:54:19 <kulin> this seems like a big deal
01:54:38 <ivanm> kulin: it's a _HUGE_ deal!!!!!!
01:54:39 <ivanm> :p
01:57:14 * hackagebot pdynload 0.0.3 - pdynload is polymorphic dynamic linking library.  http://hackage.haskell.org/package/pdynload-0.0.3 (AndyStewart)
01:57:43 <ivanm> huh, ManateeLazyCat isn't online but is uploading packages...
01:57:55 <quicksilver> ;)
01:58:01 <quicksilver> that's not forbidden, I don't think
01:58:16 <ivanm> no, it isn't
01:58:25 <ivanm> but I wanted to ask him about it then realised he wasn't actually online ;-)
01:58:37 <jkramer_> Ahoy
01:58:53 <ivanm> @yarr!!
01:58:54 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
01:59:13 <jkramer_> When I define a function in ghci multiple times, is there a way to rollback and get an old version of the function?
01:59:40 <ivanm> scroll up and re-define it?
01:59:45 <jkramer_> Like: let x = 1 \ let x = 2 \ unlet x \ print x -> 1
01:59:50 <ivanm> nope
01:59:56 <jkramer_> Ok, I was just wondering
02:00:04 <quicksilver> except by using history perhaps
02:00:12 <quicksilver> to re-enter the previous line's codfe
02:00:21 <jkramer_> Because I defined mod2 multiple times and when I press mod2<tab>, it prints mod2 three times now
02:00:37 <jkramer_> I though there might be a way to access the old definitions
02:01:10 <ivanm> ghci's state doesn't have a rollback feature
02:01:21 <quicksilver> well, technically they still exist, but they're shadowed
02:01:21 <ivanm> that's what a source file + a VCS is for ;-)
02:01:37 <quicksilver> but there is no syntax for accessed enclosing scope's shadowed definitions
02:01:44 <jkramer_> ivanm: Sure, I'm just playing around and I was wondering because of the tab completion output
02:02:22 <ivanm> I usually want a slighly different thing: if I define a whole bunch of values in ghci, then edit the source file and re-load I have to redefine all those values :s
02:03:41 <quicksilver> there really ought to be a way to dump your history
02:03:42 <jkramer_> Put them in another script and load it :)
02:03:47 <quicksilver> (then you could grab the bits from that)
02:04:48 <ivanm> quicksilver: as in something akin to being able to record macros on the fly in emacs?
02:05:43 <jkramer_> Or a key-combo / :command to edit the current / last line in ghci in $EDITOR :)
02:05:48 <jkramer_> Like in ZSH
02:08:58 <b_jonas> jkramer_: bash has that too
02:09:35 <b_jonas> jkramer_: control-X control-E edits the current line in an external editor then runs it
02:10:19 <b_jonas> it's one of the very useful extensions that are in bash's readline but sadly not in the normal libreadline
02:10:54 <dobblego> @hoogle [Either a b] -> ([a], [b])
02:10:54 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
02:11:05 <dobblego> does that function generalise?
02:11:14 <b_jonas> generalize how?
02:11:22 <dobblego> dunno, that's the question :)
02:11:26 <dobblego> perhaps on the []
02:13:40 <ivanm> dibblego: just the partition function?
02:13:52 <dobblego> partitionEithers specifically
02:14:00 <ivanm> http://hackage.haskell.org/packages/archive/container-classes/0.0.0.0/doc/html/Data-Containers.html#v%3Apartition
02:14:07 <codolio> @type \es -> (do Left x <- es ; return x, do Right y <- es ; return y)
02:14:08 <lambdabot> forall (m :: * -> *) b b1. (Monad m) => m (Either b b1) -> (m b, m b1)
02:14:13 <ivanm> ^^ a generalised version of partition
02:14:28 <ivanm> codolio: heh
02:15:02 <dobblego> oh wait I've already generalised it to (Monad m), yeah thanks
02:15:47 <zark4711> hi. i have a short (english) language question. what would you call  '<' and '>' in the sense of brakets, delimiting them from '[', ']', '{', '}, '(' and ')'?
02:16:28 <dobblego> zark4711, I use "less then" and "greater than" even when not in the context of ordering
02:16:36 <zark4711> [] brackets, {} curly braces, () braces, [] ??? ?
02:17:00 <slabanja> [] square brackets, <> angle brackets?
02:17:07 <b_jonas> zark4711: angle brackets, yes
02:17:07 <zark4711> ah, square brackets
02:17:49 <zark4711> thank you!
02:18:31 <zark4711> angle brackets sounds good, too. i use less than and greater then most of the time, but in the context i am working on that would be missleading
02:18:46 <zark4711> angle brackets sound fine
02:19:34 <zark4711> sometimes i am stupid. why didnt i look at wikipedia first...
02:20:00 <ivanm> yeah, angle brackets is the one I've noermally seen
02:20:45 <zark4711> there is a page about brackets. so ( and ) are called brackets, too...hmm. when i was in the us and had a math class, we called them braces to distinguish them. i guess the naming is more a social convention
02:21:20 <ivanm> ( and ) are usually called parentheses, and { and } are braces or squiggly brackets
02:21:56 <b_jonas> the harder question is how you call them in short when you're reading out code
02:22:34 <b_jonas> it's probably dependent on the programming language but one possibility is ( open ) close < less > greater { begin } end [ left ] right
02:23:02 <ivanm> why are you reading out code?!?
02:23:26 <ivanm> dammit, this discussion of different styles of bracketing reminded me of a joke, but I can't seem to find it online :s
02:23:48 <b_jonas> ivanm: to talk with someone else irl, not on irc?
02:24:09 <ivanm> b_jonas: just show them the code?
02:24:25 <quicksilver> codolio: that does run the action twice, though
02:24:39 <codolio> Yeah.
02:24:41 <b_jonas> ivanm: what if they show you code with errors and you want to help them and direct them how to fix it?
02:24:43 <quicksilver> codolio: not sure if there is anything you can do about that.
02:24:51 <ivanm> b_jonas: red pens
02:24:51 <codolio> Probably not.
02:25:08 <b_jonas> ivanm: I for one don't like when someone does that with _my_ TFT
02:25:23 <b_jonas> also, there's the case when I'm just reading code for myself
02:25:24 <ivanm> b_jonas: fine then, comments
02:25:26 <b_jonas> I have to call it somehow
02:25:47 <b_jonas> even if it's just in my head
02:25:48 <quicksilver> calling () brackets is wrong, I think, but very common
02:26:02 <quicksilver> however, I pronounce [] and () both as bracket (in my head or aloud)
02:26:11 <quicksilver> and just expect the ambiguity to be somehow resolvable
02:26:14 <ivanm> quicksilver: it's apparently a UK thing
02:26:17 <quicksilver> {} I pronounce brace
02:26:27 <quicksilver> parenthesis is just too hard to say ;)
02:26:33 <ivanm> some interesting names: http://en.wikipedia.org/wiki/Bracket
02:26:42 <ivanm> quicksilver: how 'bout just barens?
02:26:46 <ivanm> *parens
02:26:47 <quicksilver> maybe.
02:26:52 <xkb> hi
02:26:57 <quicksilver> on reflection I don't say brace, I say 'curly bracket'.
02:27:02 * ivanm waves idly in xkb's general direction
02:27:09 <xkb> I'm trying to run and adapt this example: http://braincrater.wordpress.com/2010/07/22/ajax-chat-app-using-yesod/
02:27:15 <ivanm> quicksilver: yeah, I'm more likely to do that as well
02:27:50 <xkb> I'm getting an error around line 50 :( 
02:28:05 <xkb> "last statement in a 'do'...
02:28:16 <ivanm> xkb: since the blog post doesn't have line numbers, what is the actual bit of code it's referring to?
02:28:26 <xkb> :P
02:28:27 <ivanm> but my guess is that you didn't do the indentation properly
02:28:34 <xkb> its around the getHomeR function
02:28:42 <xkb> in the second do part
02:28:48 <xkb> client assignment
02:28:55 <ivanm> yes, your indentation is probably wrong
02:29:04 <xkb> aha
02:29:09 <xkb> on the patternmatch I suppose?
02:29:14 <ivanm> I find that "chan newTChan (_,x):_ -> dupTChan x" bit a bit strange :s
02:29:23 <ivanm> is there meant to be a case statement or something there?
02:29:23 <xkb> hehe same here
02:29:34 <xkb> I tried to factor that out to a function
02:29:39 <ivanm> maybe that should be "case" rather than "chan"...
02:29:46 <quicksilver> maybe a lamdba?
02:29:55 <quicksilver> I think his blog engine has eaten some vital characters
02:29:57 <quicksilver> perhaps a \
02:30:02 <ivanm> could be
02:30:12 <xkb> Ill try some variations :P
02:30:28 <xkb> not that familiar with the whole TChan business
02:30:29 <quicksilver> hmm
02:30:34 <quicksilver> "chan" isn't an identifier, is it?
02:30:34 <ivanm> xkb: easier just to email him and ask methinks
02:30:40 <ivanm> quicksilver: it's a variable AFAICT
02:30:45 <ivanm> maybe it should be chan <- newTChan ?
02:30:47 <quicksilver> so it shoul dbe chan <- newTChan
02:30:59 <ivanm> except <- worked everywhere else, so why not there? :s
02:31:09 <quicksilver> no idea.
02:31:18 <quicksilver> and newTChan doesn't take parameters anyway
02:31:22 <quicksilver> so that doesn't explain the next line
02:31:24 <xkb> indeed
02:31:29 <xkb> so why patternmatch at all?
02:31:32 <xkb> and on what
02:31:46 <xkb> I think it is supposed to match on the list of clients
02:31:47 <ivanm> yeah, looks like a whole chunk of code magically disappeared...
02:32:12 <quicksilver> I think it's a lambda, \(_,x):_ -> dupTChan x
02:32:20 <quicksilver> but I don't understand what it's supposed to be passed to
02:32:27 <quicksilver> should be a parameter to a HOF
02:32:31 <xkb> prob into the chan variable?
02:32:38 <xkb> hmm
02:32:47 <quicksilver> could be
02:33:02 <quicksilver> writeTChan chan ( \(_,x):_ -> dupTChan x
02:33:09 <quicksilver> but is that a chan of functions?
02:33:10 <quicksilver> I can't see ;)
02:33:36 <quicksilver> there is other garbled code later
02:33:41 <quicksilver> in 'getCheckR'
02:33:48 <quicksilver> see the Just c'
02:33:51 <quicksilver> looks like a missing case statement
02:33:53 <xkb> ah near the c invalid..
02:34:06 <quicksilver> eyes
02:34:08 <quicksilver> and more later
02:34:14 <xkb> blegh
02:34:16 <quicksilver> I think all case statements have been eaten by his blog
02:34:17 <quicksilver> somehow
02:34:22 <quicksilver> maybe email the author asking for the code
02:34:27 <xkb> yup will do
02:36:36 <ivanm> didn't I already suggest that? ;-)
02:36:43 <xkb> hehe
02:36:49 * xkb giveds credits
02:36:52 <xkb> -d
02:37:20 <quicksilver> ivanm: yes, I apologise.
02:37:40 <quicksilver> maybe email the author asking for the code [*] - With thanks for ivanm for his kind permission in re-using this excellent suggestion.
02:37:55 <ivanm> heh
02:38:06 <ivanm> no need to be that formal ;-)
02:38:34 <ivanm> I just find it interesting how someone (not always me) will suggest something, that suggestion gets ignored seemingly, then someone else suggests the same thing later on in the discussion
02:38:44 <ivanm> and suddenly it's a wonderful idea
02:39:48 <quicksilver> well I was thinking at first "maybe we dont' need to email the author, maybe we can work this out"
02:40:01 <quicksilver> and in the subsequent five minutes decided "actually this is too hard..."
02:40:19 <xkb> hehe I had the same train of thought
02:40:28 <xkb> it appears the author is on #haskell :)
02:40:35 <xkb> so I priv msg'd him
02:40:38 <xkb> or her
02:40:48 <xkb> seems like a him, Brian ;)
02:49:55 <ivanm> under what nick?
02:50:13 <ivanm> snarkyboojum: fyi, we now also have #haskell.au
02:51:01 <byorgey> braincrater.wordpress = shepheb, IIRC
02:51:54 <ivanm> oh?
02:52:04 <ivanm> preflex: seen shepheb 
02:52:04 <preflex>  shepheb was last seen on #xmonad 2 days, 18 hours, 5 minutes and 31 seconds ago, saying: you might want something like main = xmonad $ defaultConfig { layoutHook = smartBorders (layoutHook defaultConfig) }
02:52:35 <ivanm> could be
02:52:49 <byorgey> it is, I checked
02:52:49 <ivanm> oh, right, he is
02:52:52 <ivanm> his about page says so
02:52:54 <byorgey> xkb: Braden, not Brian
02:53:10 <ivanm> or Brain
02:53:12 <ivanm> that's a mouse
02:53:13 <ivanm> :p
03:02:22 <ivanm> I can use ":set -XCPP" in ghci to enable the C pre-processor
03:02:32 <ivanm> but how can I specify specific flags/options?
03:13:30 <ivanm> what name can I give to a class/type family (not sure which I'll use yet) that's sole purpose is to state that some type `a' contains some value `b' ?
03:13:35 <ivanm> (and I don't want to use "container")
03:19:04 <copumpkin> TacticalGrace: ping
03:19:32 <dobblego> ivan, functor
03:19:52 <ivanm> dobblego: no, I want to be able to use kind *
03:20:32 <dobblego> Identity?
03:20:50 <ivanm> doesn't really seem to fit...
03:22:16 <ivanm> I could just use "Contains", but it seems a little silly, especially if I then have a "Container" class :s
03:22:27 <dobblego> how does it look exactly?
03:23:13 <ivanm> well, I want to copy something like Heffalump's Suitable class: http://hackage.haskell.org/packages/archive/rmonad/0.5/doc/html/Data-Suitable.html
03:23:20 <ivanm> to put into container-classes
03:23:23 <ivanm> @hackage container-classes
03:23:23 <lambdabot> http://hackage.haskell.org/package/container-classes
03:23:38 <ivanm> so that I can define restricted versions of FOldable, etc.
03:24:39 <ivanm> @tell Heffalump another documentation error for rmonad: the description in the .cabal file talks about 0.4 and using mtl
03:24:39 <lambdabot> Consider it noted.
03:26:01 <ivanm> I'm going to need something like that since my current attempt at CFunctor, etc. don't work for things like Sets :s
03:26:52 <quicksilver> ivanm: will it have any methods?
03:26:56 <quicksilver> that might help with the naming.
03:27:14 <ivanm> no, I just wanted a class that I can have all the restrictions defined in
03:27:50 <b_jonas> if it has a method called foo, call the class Fooable
03:28:14 <quicksilver> b_jonas: something like that yes ;)
03:29:08 <b_jonas> if I upgraded from ghc 6.12.1 to 6.12.3, would I have to recompile all modules?
03:29:15 <ivanm> all packages, yes
03:29:19 <b_jonas> thanks
03:29:23 <ivanm> well, all library packages
03:29:29 <b_jonas> I might not want to upgrade, but I'd like to know
03:30:20 <b_jonas> sad
03:30:30 <ivanm> why?
03:30:45 <ivanm> you have to do the same thing when you upgrade gcc or something
03:30:58 <ivanm> (well, not quite; the ABI stays the same with most gcc upgrades)
03:31:20 <b_jonas> right, I wouldn't usually have to do that with gcc (unless the older gcc was buggy)
03:31:21 <ivanm> but libraries are a bit more tightly integrated into ghc in that ghc knows where they all are, etc.
03:31:39 <ivanm> on the other hand, most haskell libs are much faster to compile than C libs ;-)
03:32:14 <b_jonas> and if I upgrade perl from x.y.z to x.y.w I can keep using the same modules because the api is guaranteed to be binary compatible
03:32:23 <b_jonas> (except for 5.8.1 which had a bug)
03:32:30 <quicksilver> b_jonas: yup, GCC breaks binary compatibility very very rarely
03:32:35 <quicksilver> and perl breaks it only carefully
03:32:40 <b_jonas> quicksilver: even with C++?
03:32:42 <quicksilver> whereas GHC breaks it nearly all the time.
03:33:13 <quicksilver> I don't really follow C++ but certainly in the early days they broke binary compat every release
03:33:20 <quicksilver> it may or may not have stabilised.
03:35:15 <ivanm> does perl actually compile stuff though?
03:35:26 <b_jonas> ivanm: no, but there are extensions in C for it
03:35:46 <ivanm> so being able to upgrade perl without rebuilding deps doesn't mean much then ;-)
03:35:54 <b_jonas> ivanm: and those you have to recompile for major versions
03:36:18 <b_jonas> ivanm: not quite, you usually use quite a lot of non-pure-perl modules
03:36:23 <anandjeyahar> hello
03:36:35 <b_jonas> just like how many haskell modules use ffi too
03:36:38 <anandjeyahar> anybody using ghc on F12 
03:36:41 * ivanm waves idly in anandjeyahar's general direction
03:37:03 <ivanm> anandjeyahar: there probably are some, but I can't remember who uses fedora here atm
03:37:10 <anandjeyahar> hi
03:37:14 <anandjeyahar> Thanks ivan
03:37:23 <b_jonas> oh, fedora. I was just wondering what "F12" meant
03:37:36 <anandjeyahar> Huh.... the X11 library fails to install on fedora 12
03:37:50 <snarkyboojum> ivanm: thanks for the tip re #haskell.au :)
03:37:54 <ivanm> deteego: fyi, we also have #haskell.au ...
03:37:56 <ivanm> snarkyboojum: np!
03:38:13 <ivanm> anandjeyahar: with what error?
03:38:25 * ivanm assumes anandjeyahar refers to the haskell X11 library
03:40:22 <deteego> ivanm: thanks
03:40:25 <ivanm> np
03:43:54 <anandjeyahar> hi sorry lost connection
03:44:15 <ivanm> that's OK, we were only talking about you
03:44:16 <ivanm> :p
03:45:00 <anandjeyahar> Oh, fine.. so any idea where the real problem is...
03:45:10 <anandjeyahar> hope all good about me.*
03:45:11 <anandjeyahar> :>
03:45:12 <anandjeyahar> :P
03:45:13 <ivanm> well, you haven't given us any errors yet...
03:45:20 <ivanm> so it's a bit hard to diagnose what the problem is
03:47:59 <anandjeyahar_> hsc2hs: Main.hs:163:6-68: Irrefutable pattern failed for pattern (before, tpl : after)
03:48:13 <anandjeyahar_> here is the error... sorry lost connection again..
03:48:15 <anandjeyahar_> hsc2hs: Main.hs:163:6-68: Irrefutable pattern failed for pattern (before, tpl : after)
03:48:38 <ivanm> huh
03:49:05 <anandjeyahar_> ./configure gives a warning about unknown option --with-compiler but runs fine..
03:49:06 <ivanm> what was that from?
03:49:12 <ivanm> X11 doesn't have a Main.hs AFAIK...
03:49:21 <ivanm> (seeing as how it's a library, not an executable...)
03:49:24 <anandjeyahar_> That error was a from cabal install X11
03:49:41 <ivanm> but what was actually being installed?
03:49:43 <anandjeyahar> from within the X11 folder i downloaded and unpacked
03:49:48 <ivanm> was it trying to install something else as well?
03:50:00 <ivanm> anandjeyahar: doing "cabal install X11" won't use the one you downloaded and unpacked
03:50:05 <anandjeyahar> no X11 only..
03:50:07 <ivanm> for that, go into it and do "cabal install"
03:50:09 <ivanm> you sure?
03:50:30 <anandjeyahar> yeah that is what i am doing.. sure..
03:50:47 <ivanm> there's no Main.hs in the X11 tarball ;-)
03:50:57 <anandjeyahar> Hmm....
03:51:01 <anandjeyahar> let me search
03:51:15 <ivanm> "cabal install X11 --dry-run"
03:51:39 <ivanm> and which version of X11 is this? 1.5.0.0?
03:52:11 <anandjeyahar> yep....1.5.0.0
03:52:22 <anandjeyahar> i will try dry-run
03:53:05 <anandjeyahar> tells me X11-1.5.0.0 will be installed
03:53:50 <ivanm> that's it?
03:54:08 <ivanm> anandjeyahar: can you please paste the entire build log up somewhere?
03:54:33 <anandjeyahar> you mean the cabal install output right..
03:54:43 <anandjeyahar> will do...gimme a couple of minutes
04:01:10 <anandjeyahar> ivanm: btw, i ran it with -v option. i initially had problem with hsc2hs..
04:01:22 <anandjeyahar> http://pastebin.com/cTaDCSgj
04:01:45 <anandjeyahar> i can now get the same error running hsc2hs -version...
04:01:55 <ivanm> huh, looks like a bug in hsc2hs itself
04:02:43 <anandjeyahar> Damn.... ok i will look at bugs and  patches..
04:03:25 <ivanm> well, try going into #ghc and whinging until someone notices ;-)
04:04:02 <anandjeyahar> Thanks will do that :P
04:04:04 <ivanm> wow, google indexed your paste already...
04:04:18 * ivanm had tried searching for that error message and your paste was the only one that came up
04:04:32 <anandjeyahar> Whoa.... amazing...
04:06:51 <anandjeyahar> ivanm : do you think building will help? what is this hsc2hs? pardon my newbieness
04:07:26 <ivanm> hsc2hs is a way of generating Haskell bindings to C libraries
04:07:41 <ivanm> it comes with GHC, so it's not like you can just get yourself a newer version :s
04:08:13 <anandjeyahar> Hmm... may be i should try ghc 6.12 but it is not supported on F12
04:08:15 <anandjeyahar> :(
04:08:26 <anandjeyahar> All i wanted was to try out xmonad 
04:08:29 <anandjeyahar> :(
04:08:58 <anandjeyahar> ok thanks anyway..
04:09:08 <ivanm> there aren't any xmonad packages for fedora?
04:09:28 <ivanm> anandjeyahar: try #fedora-haskell
04:12:00 <anandjeyahar> both #ghc and #fedora-haskell... 
04:12:29 <anandjeyahar> xmonad package on fedora.....nope not as far as i know...i will ask on fedora-haskell 
04:13:29 <ivanm> anyway, isn't fedora 13 out?
04:13:52 <copumpkin> byorgey++
04:14:10 <anandjeyahar> yeah..but it is out..  i am just being paranoic about moving... as last time i got my laptop crashed....
04:14:11 <ivanm> I find mention of xmonad packages for F12... http://osdir.com/ml/fedora-package-announce/2009-12/msg00975.html
04:14:11 <copumpkin> we should put that up as A Master's Monad Manifesto
04:14:20 <ivanm> copumpkin: what's this?
04:14:25 <ivanm> what did byorgey do?
04:14:32 <copumpkin> byorgey's email a minute ago about how monads are hard
04:14:45 <ivanm> oh, my mail client hasn't synced it yet then
04:14:54 <ivanm> this in response to Kevin's thread?
04:15:18 <copumpkin> "Can we come out of a monad?"
04:15:25 <ivanm> yeah, that one
04:16:08 <ivanm> who said monads are easy?
04:16:12 <ivanm> I certainly didn't...
04:17:39 <copumpkin> I DID
04:18:19 <ivanm> did you? really?
04:18:24 <copumpkin> no
04:18:28 <ivanm> I don't recall seeing a response from a vegetable...
04:18:30 <ivanm> about to say...
04:18:34 <ivanm> copumpkin: so you're just lying now?
04:18:34 <ivanm> :p
04:18:37 <copumpkin> yes
04:18:40 <silver> why #ubuntu-haskell is empty :(
04:18:40 <copumpkin> I mean, no
04:18:54 <copumpkin> man, this proof is fugly
04:19:03 <hpc> pumpkins are a fruit, silly
04:19:03 <ivanm> silver: because people like Cale that use ubuntu don't bother asking their package manager for haskell stuff
04:19:11 <ivanm> copumpkin: which proof?
04:19:23 <ivanm> hpc: in the same way that tomatos are fruits, yes; but most people refuse to accept that
04:20:08 <copumpkin> ivanm: I'm trying to prove stuff about repa without its authors' consent :P
04:20:18 <Cassapanco> hello, I have a not-so-advanced question
04:20:18 <silver> reminds me about annoying orange
04:20:30 <ivanm> copumpkin: heh
04:20:41 <ivanm> Cassapanco: good, because we have not-so-advanced answers
04:20:42 <ivanm> ;-)
04:20:48 <Cassapanco> looking at the "Yet another Haskell tutorial" I found an exercise about rewriting following function in a point-free version: func5 f l = foldr (\x y -> f (y,x)) 0 l
04:21:16 <benmachine> that sounds fairly obnoxious
04:21:16 <Cassapanco> and this is the proposed solution: func5 = foldr (uncurry $ flip f) 0
04:21:44 <benmachine> Cassapanco: sounds like a mistake, they've removed f from the LHS but not the RHS
04:22:05 <Cassapanco> benmachine, a part of the 'f'
04:22:25 <Cassapanco> i'm a newbie, but the second function seems to be totally different
04:22:28 <quicksilver> flip foldr 0 . uncurry flip ?
04:22:34 <Cassapanco> it looks like a huge mistake
04:22:42 <ivanm> @pl func5 f l = foldr (\ x y -> f (y,x)) 0 l
04:22:42 <lambdabot> func5 = flip foldr 0 . (. flip (,)) . (.)
04:22:47 <benmachine> quicksilver: uncurry . flip?
04:23:05 <ivanm> Cassapanco: YAHT is rather old and not used much anymore
04:23:07 <benmachine> @pl \f x y -> f (x,y)
04:23:07 <lambdabot> (. (,)) . (.)
04:23:11 <benmachine> huh
04:23:37 <benmachine> Cassapanco: do you understand why we can get rid of the l?
04:23:41 <Cassapanco> ivan, on haskell site i read is "best tutorial available online" O_o
04:23:49 <ivanm> yeah, I don't get why it doesn't use uncurry...
04:23:55 <ivanm> Cassapanco: it is? :O
04:24:02 <benmachine> opinions differ I'm sure
04:24:03 <ivanm> obviously no-one's bothered to update that page ;-)
04:24:06 <benmachine> heh
04:24:06 <ivanm> benmachine: true
04:24:10 <ivanm> @where wikibook
04:24:10 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:24:12 <ivanm> @where lyah
04:24:12 <lambdabot> http://www.learnyouahaskell.com/
04:24:18 <ivanm> Cassapanco: ^^ two alternate online tutorials
04:24:29 <ivanm> (note that neither are finished, but YAHT is being incorporated into the wikibook)
04:24:31 <ivanm> @where tryhaskell
04:24:32 <lambdabot> http://tryhaskell.org/
04:24:32 <benmachine> it might be a bit of a pita to start again at this stage
04:24:34 <quicksilver> benmachine: actually it should be curry not uncurry
04:24:39 <ivanm> ^^ live tutorial
04:24:45 <ivanm> benmachine: true
04:25:05 <benmachine> quicksilver: oh yeah, weird
04:25:24 <Cassapanco> curry, not uncurry yes
04:25:28 <benmachine> :t curry flip
04:25:29 <lambdabot> forall a a1 b. a -> (a1 -> b) -> a1 -> (a, b)
04:25:32 <quicksilver> :t [\f l -> foldr (\x y -> f (y,x)) 0 l , flip foldr 0 . flip . curry]
04:25:33 <lambdabot> forall a a1. (Num a1) => [((a1, a) -> a1) -> [a] -> a1]
04:25:56 <Cassapanco> my solution was: func5 f = foldr (flip $ curry f) 0
04:25:56 * benmachine tries to work this out
04:26:12 <benmachine> :t curry f
04:26:13 <lambdabot> forall a b c. (Show a, Show b, SimpleReflect.FromExpr c) => a -> b -> c
04:26:16 <benmachine> er whoops
04:26:38 <benmachine> oh right
04:26:55 <benmachine> Cassapanco: your solution seems right, except inasmuch as it still has a point
04:27:11 <ivanm> benmachine: you have a point there...
04:27:12 <ivanm> ;-)
04:27:25 <Cassapanco> ouch... i have a point :P
04:27:55 <hpc> this exercise is pointless
04:28:03 <hpc> ;)
04:28:05 <Cassapanco> hehe
04:28:09 <benmachine> Cassapanco: i.e. ideally for total pointfree-ness you'd only have func5 = on the lhs
04:28:42 <benmachine> Cassapanco: however, getting it to that state makes it less readable rather than more - which makes the point that pointfree is to be used in moderation, I suppose
04:30:07 <Cassapanco> benmachine, of course. I only was playing with those exercises but that solution left me quite disappointed
04:31:26 <hpc> in addition, there are plenty of cases where making a function even partially pointfree will make the type of the function harder to see without explicit annotation
04:31:39 <hpc> although that's probably a case for mandatory type signatures, if anything
04:36:46 <benmachine> Cassapanco: http://en.wikibooks.org/wiki/Haskell/YAHT/Errata
04:37:09 <askhader> so what is wrong with this:  data Ilist a b = Empty | Icons a b   deriving(show)      iLength(Empty) = 0    iLength (Icons a b) = 1 + iLength(b)
04:37:20 <askhader> i get infinite type error.
04:37:56 <Cassapanco> benmachine, i didn't discovered something new :P
04:38:24 <Cassapanco> well, so i apologize. next time I will ask google first
04:38:49 <quicksilver> askhader: that implicitly requires that 'b' also be an IList
04:39:00 <quicksilver> askhader: ...and so on, recursively.
04:39:05 <benmachine> Cassapanco: aww, we like being asked stuff
04:39:17 <askhader> how do i stipulate this for ghci?
04:39:18 <quicksilver> leading to IList a (IList a1 (IList a2 (IList a3......
04:39:22 <quicksilver> whichi is an infinite type.
04:39:23 <hpc> make b an explicit IList a
04:39:37 <hpc> data IList a = Empty | Icons a (IList a)
04:39:45 <askhader> ahhhhhh
04:39:57 <askhader> ghci is too damn smart
04:39:58 <hpc> which is analogous to []
04:40:08 <hpc> data [a] = [] | a:[a]
04:40:24 <benmachine> hmm
04:40:54 <benmachine> newtype RList a = IList a (RList a) -- ?
04:41:04 <askhader> what type is 'a' representing in that data definition?
04:41:12 <askhader> hpc's
04:41:21 <hpc> askhader: anything
04:41:27 <benmachine> it's a type parameter
04:41:39 <hpc> String is an alias for [Char], a list of characters
04:41:44 <benmachine> it's like x in f x = x + 4, only at the type level
04:41:53 <Cassapanco> thanks to all, bye bye
04:41:54 <askhader> but why is the first element of the same type?
04:42:07 <benmachine> (sooort of... you're much more limited in what you can do with it, but it's the same concept)
04:42:25 <benmachine> askhader: er, what else would it be
04:42:59 <hpc> it's saying that (:) :: a -> [a] -> [a]
04:43:26 <hpc> if the list is a list of Characters, you should be putting characters in
04:43:30 <askhader> ah i see.
04:43:37 <askhader> yes makes sense
04:43:39 <benmachine> a list of a is either empty, or it's an a joined onto a list of a
04:43:40 <hpc> not doubles or file handles
04:43:50 <askhader> thankssss
04:54:49 <hpc> :t mapM_
04:54:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:55:19 <hpc> :t mapM
04:55:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:56:43 <hpc> @src sequence_
04:56:43 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
04:59:25 <Starfire> What is the difference between 'instance C a a' and 'instance (a1 ~ a2) => C a1 a2' ?
05:00:28 <quicksilver> the latter is valid and the former is not
05:00:32 <quicksilver> as far as I know.
05:00:44 <Starfire> GHC seems to accept both.
05:00:52 <quicksilver> hmm
05:00:55 <Starfire> Moreover, I get an overlapping instance error with the latter, but not the former.
05:01:08 <quicksilver> I don't know :-(
05:01:30 <Starfire> I can see why the latter results in an error (there is some ambiguity), but I don't understand why the former instance works in that case.
05:02:54 <Jagdwurst> Hi !
05:03:34 * ivanm waves idly in Jagdwurst's general direction
05:05:02 <geheimdienst> so, suppose i have some instances of EventMask: pointerMotionMask, propertyChangeMask, and a dozen others. now my program should take a command-line arg and find the correct instance from that String. do i have to do this? f "propertyChangeMask" = propertyChangeMask ; f "pointerMotionMask" = pointerMotionMask
05:05:17 <geheimdienst> ... or is there some witchcraft, maybe involving Data.Typeable?
05:05:39 <ivanm> probably the latter
05:05:44 <ivanm> if you can't just read it in
05:06:08 <Jagdwurst> is there any way to know,   whether  a value  of type (Maybe a)    == Nothing,   if  the type `a` is not a member of  `Eq` class
05:06:18 <ivanm> no
05:06:19 <new2haskell> Hello, can someone explain to me what this means "Don't forget that let bindings and where clauses create a mutually recursive nest of definitions, not a sequence of definitions." Thanks
05:06:20 <copumpkin> :t isNothing
05:06:21 <benmachine> yes
05:06:21 <lambdabot> forall a. Maybe a -> Bool
05:06:32 <ivanm> oh, wait, sorry, if it's Nothing :s
05:06:34 <benmachine> :t maybe True (const False)
05:06:35 <lambdabot> forall a. Maybe a -> Bool
05:06:47 * ivanm just read the "not a member of `Eq`" bit
05:06:57 <benmachine> reading is for losers
05:07:05 <benmachine> @hoogle isNothing
05:07:05 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
05:07:10 <Jagdwurst> which package has that?
05:07:15 <ivanm> new2haskell: "let x = y + 2; y = x + 2" <-- here, you aren't defining a new value of y based upon x
05:07:19 <hpc> new2haskell: you can define functions in a where or let in terms of things higher up or themselves
05:07:20 <Jagdwurst> ok,  thanks a lot :D
05:07:23 <ivanm> Jagdwurst: base, so it comes with GHC
05:07:34 <hpc> like ivanm's example or the definition of fix
05:07:38 <geheimdienst> ivanm, i think "just reading it in" won't work because EventMask is not an instance of Read and Show (i think) ... http://hackage.haskell.org/packages/archive/X11/latest/doc/html/Graphics-X11-Types.html#t:EventMask
05:07:43 <hpc> fix f = let x = f x in x
05:07:49 <hpc> > fix (1:)
05:07:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:07:57 <ivanm> new2haskell: so that in essence is trying to solve "x = y + 2; y = x + 2" as mutually recursive functions
05:08:03 <ivanm> and strangely enough there isn't a solution...
05:08:36 <ivanm> geheimdienst: sure it is
05:08:46 <ivanm> "type EvenMask = Mask"; "type Mask = Word32"
05:09:00 <b_jonas> > let { a = 1 : b; b = 2 : a; } in take 20 a -- ->new2haskell
05:09:01 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2]
05:09:04 <new2haskell> ivanm: thanks. so it is like the let* or letrc in ML?
05:09:12 <b_jonas> new2haskell: yes
05:09:13 <ivanm> new2haskell: no idea ;-)
05:09:19 * ivanm has never done any ML
05:09:20 <geheimdienst> oh i see. but wouldn't that mean that the user would have to know the numerical values ...?
05:09:28 <b_jonas> the b in the definition of a refers to the b defined later in that block
05:09:40 <b_jonas> so you can easily define recursive or mutually recursive functions
05:10:06 <b_jonas> new2haskell: it's like letrec in scheme, not like let*
05:10:24 <new2haskell> b_jonas: thanks
05:10:28 <b_jonas> let* is quite the opposite in this respect I think
05:10:29 <ivanm> geheimdienst: hmmm?
05:10:38 <b_jonas> I'm not sure about ML
05:11:35 <new2haskell> b_jonas: i was confused ML with Scheme. :)
05:11:42 <b_jonas> oh, good
05:11:43 <geheimdienst> i meant, this would work: (read "32") :: EventMask. but that's not user-friendly if you have to know that 32 stands for poopelFloopelMask
05:11:46 <b_jonas> I was worried
05:12:16 <ivanm> geheimdienst: yeah, well, arguably they should have defined wrappers around those values
05:12:52 <Nibble> what exactly does saying that $ has the lowest predecence mean?
05:12:53 <hpc> geheimdienst: you have it all wrong; 23 is the poopelFloopelMask
05:13:00 <geheimdienst> you mean EventMask should be a "data" instead of a "type", right?
05:13:01 <Nibble> I understand that you can use it instead of paranthesis
05:13:52 <geheimdienst> ^^ @ ivanm
05:13:52 <ivanm> Nibble: it means that things like + happen before $
05:14:00 <ivanm> geheimdienst: well, a newtype at least
05:14:08 <b_jonas> but it's a mask, you can or the values, can't you?
05:14:12 <geheimdienst> okay i see
05:14:22 <b_jonas> so the read would have to support oring
05:14:24 <Nibble> ivanm: ooooh
05:14:31 <ivanm> b_jonas: yes, but arguably you shouldn't
05:14:32 <Nibble> so it "magically" places itself you could say?
05:14:38 <b_jonas> like, I dunno, read "(fooMask .|. barMask)"
05:14:40 <ivanm> see the RWH bit where they do bindings to libpcre
05:14:43 <b_jonas> shouldn't it?
05:14:58 <quicksilver> I would think things like should be a nice custom ADT
05:15:09 <quicksilver> data MaskType = Poopel | Floopel | Beezel | Buzzel
05:15:16 <geheimdienst> b_jonas, well my program is really tiny, it would just take all of the command line args, "read" each one, and or the result together
05:15:34 <ivanm> Nibble: well, it means that "a <symb> b $ c" becomes "(a <symb> b) c", no matter what "<symb>" is
05:15:37 <b_jonas> geheimdienst: then it shouldn't be read, because read should usually round-trip with show
05:15:37 <geheimdienst> i'm not planning fancy syntax like "x .|. y"
05:15:41 <b_jonas> geheimdienst: it should be some other function
05:15:44 <ivanm> quicksilver: nice names ;-)
05:15:49 <Nibble> ivanm: ye
05:16:14 <ivanm> b_jonas: well, define appropriate Show instances as well
05:16:38 <b_jonas> (of course, there are exceptions, like foreignPointer x which can be shown but not read)
05:16:52 <ivanm> :o
05:17:02 <ivanm> does the Show instance return valid Haskell code?
05:17:14 <ivanm> StdGen's Show instance is a joke...
05:17:21 * ivanm can't recall if it can be Read or not
05:18:07 <b_jonas> ivanm: of course not, just like with newtypes
05:18:11 <b_jonas> ivanm: it gives a number I think
05:18:34 <geheimdienst> quicksilver, hm ... maybe i'll have to define a "data", but i'm trying to avoid it. i don't like copy-pasting all the EventMask instances out of the haddock and making my own silly tiny wrapper
05:18:35 <ivanm> b_jonas: huh? newtypes have valid Show instances (if you just derive them)
05:18:46 <b_jonas> ivanm: yes, but thye don't return valid haskell code
05:18:50 <ivanm> geheimdienst: go ping sjanssen about it
05:18:57 <ivanm> b_jonas: how don't they return valid haskell code?
05:19:20 <geheimdienst> ivanm, how do you mean? he should update the library ...?
05:19:28 <ivanm> geheimdienst: well, ask him why it's like that, etc.
05:19:32 <b_jonas> uh, I meant StablePtr, not ForeignPtr, sorry
05:19:46 <ivanm> it's highly unlikely he'd go and update the library at this point in time, unless someone is willing to submit a patch however
05:19:59 <ivanm> since IIRC, the only changes they're going to make to X11 are those that they need for xmonad
05:20:42 <ivanm> b_jonas: "newtype Foo = Bar Int deriving (Show)" <== this does indeed produce valid Haskell code for show
05:20:55 <ivanm> "show (Bar 2)" will return "Bar 2"
05:20:57 <b_jonas> ivanm: hmm, you're right, it does produce valid haskell code
05:21:00 <b_jonas> sorry, I was wrong
05:21:07 <ivanm> apology accepted
05:21:10 <ivanm> just don't do it again!
05:21:11 <ivanm> :p
05:21:12 <geheimdienst> okay i see. however i wasn't so much looking for this specific thing, i was thinking more of "is there an equivalent of java.lang.reflect in haskell"
05:21:44 <geheimdienst> (i guess my question was not entirely clear in the first place)
05:21:51 <ivanm> since i have no idea what reflect is...
05:21:59 <quicksilver> geheimdienst: no, there isn't, because haskell doesn't have any run time type information.
05:22:09 <quicksilver> geheimdienst: GHC erases all type information at compile time.
05:22:09 <ivanm> is he wanting an isInstance function?
05:22:21 <quicksilver> ...having said that, you can get a surprisingly long way towards java.lang.reflect
05:22:27 <ivanm> quicksilver: apparently we might get such functionality in the new type checker, though probably not until 6.16
05:22:34 <Twey> Cool
05:22:36 <ivanm> since something like that would be needed for superclass constraints
05:22:44 <quicksilver> with simple metaprogramming tools like Typeable, Dynamic, Data, etc.
05:22:50 * Twey looks forward to it.
05:22:52 <ivanm> not sure whether it would be good enough to have an isInstance function though :s
05:22:57 <quicksilver> ivanm: I really hope not. reflection is a cure far worse than the disease.
05:23:19 <ivanm> quicksilver: yeah, I think TacticalGrace was talking more about the info that the class dictionaries would have
05:23:21 <quicksilver> reflection encourages sloppy programming practices like trampling through abstraction barriers
05:23:22 <hpc> in java, i have only ever seen reflection used to make first-class functions
05:23:23 <geheimdienst> ivanm, given a String like "getFoobar", java's reflection lets you find that method and call it. also works for an object's fields etc.
05:23:47 <ivanm> geheimdienst: wait, it will turn "getFoobar" into .getFooBar() ?
05:23:55 <quicksilver> hpc: it's used pretty fundamentally to enable JavaBeans and similar technologies.
05:23:55 <ivanm> quicksilver: yeah, that sounds bad
05:23:58 <quicksilver> ivanm: yes.
05:24:12 <ivanm> but I would still like an isInstance function for a few things to make nice defaults for libraries, etc.
05:24:18 <quicksilver> ivanm: java has *everything* at runtime. runtime type info, complete symbol tables, etc.
05:24:24 <ivanm> *nod*
05:24:32 <ivanm> well, it kinda has to to be able to do JIT, doesn't it?
05:24:38 <quicksilver> don't think so.
05:24:44 <quicksilver> JIT doesn't care what variables are called.
05:24:46 <hpc> JIT is optional
05:24:48 <ivanm> true
05:24:56 <geheimdienst> quicksilver, in principle i agree that reflection can shoot you in the foot a lot. however for this thing, getting "enum" values from command-line args, it would be perfectly acceptable
05:24:59 <quicksilver> to some extend it has to do to enable its delayed linking / separate compilation model.
05:25:03 <b_jonas> and I'm wrong is the StablePtr stuff too, StablePtr does not directly have a Show instance, only through castStablePtrToPtr
05:25:10 <geheimdienst> * imho
05:25:12 <quicksilver> geheimdienst: I think that's better solved by something compile-time
05:25:16 <quicksilver> geheimdienst: simple metaprogramming
05:25:21 <quicksilver> like "deriving Read" does.
05:25:32 <quicksilver> (not necessarily using deriving Read itself... but something *like* that)
05:25:39 <ivanm> quicksilver: "simple" metaprogramming? :p
05:25:46 <geheimdienst> uh, but no compiler on earth, not even 6.16, knows at compile time what the command line args will be. right?
05:25:59 <quicksilver> geheimdienst: no, but at compile time it knows the valid possibilities
05:26:06 <drhodes> the will be strings
05:26:11 <quicksilver> so you construct the lookup function / recogniser function at compile time
05:26:13 <ivanm> geheimdienst: strangely enough, not the actual values...
05:26:45 <quicksilver> ivanm: yeah, deriving Read and deriving Show are simple metaprogramming. Simple to understand and use if not to implement.
05:27:03 <ivanm> quicksilver: yes, I was talking about implementation ;-)
05:27:06 * quicksilver nods
05:27:17 <ivanm> but you're saying work out a way of using derive or something to generate instances for you?
05:27:22 <quicksilver> yes.
05:27:30 <quicksilver> that's exactly what I'm saying.
05:27:44 <quicksilver> or, in extremise, a script you run at build time which runs over your modules and collects the info
05:27:58 <quicksilver> (if, for example, you want to build a list of all "plugin" modules without hardcoding it)
05:28:00 * ivanm tried to work out how to do something like that using TH or something for some classes; it was a disaster
05:28:20 <ivanm> due to having to deal with different kinds, etc.
05:28:25 <geheimdienst> i was actually wondering how ghci does that. i mean you can say :browse and things like that
05:28:36 <ivanm> geheimdienst: ghci uses bytecode of the source files
05:28:36 <geheimdienst> probably internal ghc witchcraft
05:28:47 <quicksilver> :browse only has exported/public symbols
05:28:48 <ivanm> or for compiled files, it just sees what gets exported
05:28:50 <quicksilver> those are in the .hi files
05:28:55 <ivanm> which is defined in the exported API
05:28:58 <ivanm> as quicksilver says
05:29:03 <quicksilver> for interpreted files, it is using the bytecode
05:29:11 <quicksilver> because it can - it is the interpreter after all!
05:29:26 <ivanm> heh
05:29:42 <geheimdienst> sounds like a lot of work. and i'm glad other people already did it for us
05:31:04 <quicksilver> you can use it if you want
05:31:07 <quicksilver> the GHC API is available
05:31:14 <quicksilver> but it's not stable or easy to use :-S
05:31:25 <ivanm> there's hint for some abstraction...
05:35:56 <geheimdienst> okay thanks so far, guys. very helpful as always :-)
05:36:26 * geheimdienst leaves #haskell a tiny little bit cleverer than he entered
05:36:36 <bobzhangatthu> Hi, how to turn on TransformListComp in ghci, thanks :)
05:40:48 <byorgey> bobzhangatthu: two ways: (1) pass -XTransformListComp to ghci on the command line, or (2) from within ghci you can say  :set -XTransformListComp
05:41:02 <bobzhangatthu> thanks
05:41:40 <ManateeLazyCat> hi, all. :)
05:45:36 <ivanm> hey ManateeLazyCat 
05:46:08 <ManateeLazyCat> ivanm: :)
05:46:26 <ManateeLazyCat> ivanm: @hackage pdynload
05:46:31 <ManateeLazyCat> @hackage pdynload
05:46:32 <lambdabot> http://hackage.haskell.org/package/pdynload
05:47:31 <ivanm> ManateeLazyCat: yeah, I saw that
05:47:35 <ivanm> is that your fork of plugins?
05:47:49 <ManateeLazyCat> ivanm: I use GHC-API re-implement pdynload of hs-plugins.
05:48:00 <ivanm> oh, it's a subset of plugins?
05:48:12 <ManateeLazyCat> ivanm: Infact, pdynload is enough.
05:48:27 <ManateeLazyCat> ivanm: It parse type/depend information from cabal/ghc database.
05:48:36 <ivanm> cool
05:48:38 <ManateeLazyCat> ivanm: Don't need user input path explicitly.
05:48:59 <ManateeLazyCat> ivanm: Because i add "runtime type checker", so it's perfect safety.
05:49:34 <ManateeLazyCat> ivanm: 'pdynload ("Prelude", "reverse") ([], "String -> String")' can load Prelude.revese, other function is same.
05:49:55 <Gracenotes> why type signature needed?
05:50:14 <Gracenotes> well there's probably a long explanation there actually -.-
05:50:18 <ManateeLazyCat> Gracenotes: Because it's will do a "runtime type check" make sure load safety.
05:50:19 <ivanm> Gracenotes: heh
05:50:22 <Gracenotes> related to the nature of the function
05:50:24 <ivanm> ManateeLazyCat: cool
05:50:32 <burp> already 15 minutes darcs cpu time for checking in 6k small files -.-
05:50:37 <ivanm> Gracenotes: he's trying to write plugins that can be inserted into a running program
05:50:45 <ManateeLazyCat> Gracenotes: If type mismatch, it will return Nothing protect application won't crash.
05:50:48 <Gracenotes> "runtime type check" sounds malicious D:
05:50:55 <Gracenotes> oh, Nothing. never mind.
05:51:08 <ManateeLazyCat> Gracenotes: I push "type check" to ghc compiler, so it's neat and simple.
05:51:11 <Gracenotes> a simple interface is a great idea
05:51:29 <Gracenotes> so long as said interface works :)
05:51:36 <ManateeLazyCat> Gracenotes: Yeap, infact we don't need so complicated API like hs-plugins
05:52:07 <ManateeLazyCat> Gracenotes: We just need tell Module/Symbol/Type tuple to plugins, then it load/link from cabal/ghc database.
05:52:28 <Gracenotes> fancy
05:52:37 <ManateeLazyCat> ivanm: Infact, "runtime type checker" is pretty simple if you read source code. :)
05:52:56 <ManateeLazyCat> ivanm: It support any type that compiler support, not like Dynamic need change user's code.
05:54:40 * ManateeLazyCat pasted "pdynload source code." at http://paste2.org/get/932891
05:54:45 <Gracenotes> you could also make a template haskell staticload ("Prelude", "reverse") ([], "String -> String") easily I think. maybe someone could supply a patch, but I suspect most people would want to write "import Prelude (reverse)" instead..
05:55:29 <ManateeLazyCat> Gracenotes: I don't need parse "import Prelude (reverse)". :)
05:55:56 <ManateeLazyCat> Gracenotes: ("Prelude", "reverse") give me clearer logic. :)
05:56:21 <Gracenotes> well, on the subject of that tricky business known as static linking
05:56:46 <cuba> is there something like a nop operation in haskell?
05:56:54 <arw> id
05:57:03 <Gracenotes> depends on the type of the nop
05:57:09 <ManateeLazyCat> ivanm: At http://paste2.org/get/932891, have function 'typecheck', it will generate temporary module to import depend module, then call "ghc -e typecheck TypeCheck.hs" check expression "typecheck = Data.List.reverse :: String -> String".
05:57:09 <Gracenotes> for an IO action, it's 'return ()'
05:57:27 <Gracenotes> you can do a conditional nop with when and unless
05:57:29 <cuba> like iterate (+1-1) 1
05:57:30 <ManateeLazyCat> ivanm: If evaluation successful, then i can use unsafeCoerce safety, won't crash.
05:57:35 <ivanm> cuba: what do you want it for?
05:57:37 <Gracenotes> oh. what arw said then
05:57:43 <Gracenotes> @src id
05:57:43 <lambdabot> id x = x
05:57:49 <quicksilver> > iterate id 1
05:57:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:57:56 <Gracenotes> > repeat 1
05:57:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:57:58 <quicksilver> I'm not sure it's really a nop though
05:58:06 <quicksilver> I have a feeling if you go far enough right, there's a 7
05:58:07 <ManateeLazyCat> ivanm: Now, i need think a best solution to mix pdynload and gtk2hs, don't need change some many code.
05:58:17 * ivanm was thinking of http://hackage.haskell.org/package/acme-dont
05:58:31 <ivanm> quicksilver: lol
05:58:34 <Gracenotes> available on arch, nice
05:59:00 <ivanm> Gracenotes: what is? acme-dont ?
05:59:05 <Gracenotes> yes
05:59:15 <ivanm> geez dons is stupid in some of the packaging decisions he makes
05:59:19 <ivanm> (IMHO, of course)
06:01:04 <ManateeLazyCat> ivanm: You can use pdynload, much simpler and stronger.
06:01:17 <ManateeLazyCat> ivanm: And keep forward-compatible since it use GHC-API. :)
06:01:19 <ivanm> ManateeLazyCat: well, I have no need to ;-)
06:02:18 <ManateeLazyCat> ivanm: Infact, don's path parse code confuse me, then i think "why i need user input module path? Use cabal's result isn't better?"
06:03:08 <ManateeLazyCat> ivanm: Then plugins author can split "module source code" and "update running code". 
06:03:26 <ManateeLazyCat> s/module source code/modify source code
06:04:16 <ManateeLazyCat> ivanm: Just modified code at "any path", then install by cabal, and press "reload" keystroke to update running application. :) 
06:05:28 <ManateeLazyCat> ivanm: Infact, pdynload don't care where the *.hs files, just care *.hi and *.o 
06:08:08 <pchiusano__> hello
06:15:01 * ManateeLazyCat Please tell me if some Windows/Gtk2hs user have time, i need help to make sure package 'gtk' can install on Windows..... 
06:16:43 <ManateeLazyCat> ivanm: Your graphviz package fix now? I want to use it generate beautiful manatee. :)
06:21:27 * ManateeLazyCat So quiet here....
06:22:56 * Phyx- drops a pin
06:26:31 <siracusa> ManateeLazyCat: I'm using Windows and I'm quite bored right now :-)
06:26:51 <ManateeLazyCat> siracusa: Can you pull darcs gtk2hs and try to install?
06:27:05 <siracusa> Ok
06:27:25 <ManateeLazyCat> siracusa: I'm sure gtk2hs/gtk/Graphics/UI/Gtk/General/Structs.hsc is break somehow.
06:27:28 <ManateeLazyCat> siracusa: Thanks.
06:28:05 <ManateeLazyCat> siracusa: If that okay, we will release gtk2hs-0.11.1 in short time.
06:28:14 <ManateeLazyCat> siracusa: Then add many API in gtk2hs-0.12.0
06:30:26 <burp> 60 cpu minutes for darcs checking in 6k small files -.-
06:30:35 <burp> time to use git
06:30:47 <ManateeLazyCat> burp: Maybe you need upgrade your darcs.
06:30:52 <burp> it's 2.4.4
06:31:09 <ManateeLazyCat> burp: I remember some old darcs have performance issue.
06:31:33 <ManateeLazyCat> burp: Can you talk in #darcs, maybe it's new bug. :)
06:31:53 <burp> yes, maybe but maybe it's just still O(n!) :(
06:32:24 <ManateeLazyCat> burp: I use darcs-2.4.4 too, pretty fast... :)
06:32:39 <burp> did you try checking in so many files?
06:34:49 <ManateeLazyCat> burp:  5731 files in gtk2hs.
06:34:52 <hamishmack> ManateeLazyCat: I had a quick go last weekend at building darcs gtk2hs on win32.  I built ok for me, but I had problems with template haskell and ghci.
06:34:54 <burp> hm ok
06:35:52 <ManateeLazyCat> hamishmack: Graphics.UI.Gtk.General.Struct.drawableGetID can work on Win32?
06:36:13 <ManateeLazyCat> hamishmack: Template haskell and ghci? Detail?
06:36:20 <hamishmack> ManateeLazyCat: I think the ghci issue is more locking added to the hsgthread.c
06:36:49 <ManateeLazyCat> hamishmack: Darcs still failed? I remember Axel have fix ghci problem.
06:36:53 <ManateeLazyCat> hamishmack: Is 64 bit?
06:38:37 <hamishmack> ManateeLazyCat: It looks like the same problem as last time on win32 ghci
06:39:24 <ManateeLazyCat> hamishmack: Can you add new ticket? If it's a bug of gtk2hs, we need fix it before gtk2hs-0.11.1
06:39:26 <hamishmack> the locking macros in gdk use static data init or something that is not supported when loading win32 dlls in ghci
06:42:08 <hamishmack> I think the fix might be to #ifdef out the locks on win32
06:42:58 <ManateeLazyCat> hamishmack: You need talk this with Axel, Axel handle those detail, i know nothing about Windows. 
06:44:43 <hamishmack> ManateeLazyCat: Will do.  I should have some time this weekend.
06:44:51 <ManateeLazyCat> hamishmack: Thanks. :)
06:46:44 * ManateeLazyCat pasted "drawableGetID test" at http://paste2.org/get/932932
06:46:46 <ManateeLazyCat> hamishmack: Can you test above code on Windows?
06:46:58 <ManateeLazyCat> hamishmack: I need make sure drawableGetID can works on Windows. 
06:48:11 <ManateeLazyCat> hamishmack: drawableGetID is api for get id of DrawableClass, it use gdk_x11_drawable_get_xid on UNIX, use gdk_win32_drawable_get_handle on Windows.
06:48:30 <hamishmack> ManateeLazyCat: I'll try
06:48:42 <ManateeLazyCat> hamishmack: Thanks.
06:49:41 <Baughn> @tell conal Some day, it would be nice if you'd write a blog entry on exactly what kind of thought process lets you come up with things like your newest zipper variant.
06:49:41 <lambdabot> Consider it noted.
06:52:08 <ManateeLazyCat> hamishmack: I remember ghci can't mix static and dynamic libraries...
07:01:56 <ManateeLazyCat> hamishmack: http://paste2.org/get/932932 can work?
07:02:10 <ManateeLazyCat> siracusa: Install gtk2hs-darcs successful?
07:02:24 <Nibble> guys, look, I made my own sum function
07:02:34 <b_jonas> Nibble: show it please
07:02:35 <Nibble> sum'x y = sum x y
07:03:04 <b_jonas> huh? isn't that a type error?
07:03:19 <siracusa> ManateeLazyCat: It's still building, but nearly finished.
07:04:01 <copumpkin> Nibble: you can eta reduce that to sum' = sum (assuming an extra space)
07:04:12 <pokoko222> 1/6=0.16666666666666666666666666666667 You see the 7 at the end? Well why then for this problem 1/6=0.1(6) and the 7 is not there http://projecteuler.net/index.php?section=problems&id=26
07:04:18 <pokoko222> oops sorry that was for math
07:04:30 <copumpkin> pokoko222: rounding
07:04:41 <ManateeLazyCat> siracusa: IIRC, you want Assistant module in next gtk2hs? 
07:05:16 <Phyx-> @src sum
07:05:16 <lambdabot> sum = foldl (+) 0
07:05:17 <pokoko222>  copumpkin so for the problem i can ignore the 7 and work as if there are infinite number of 6?
07:05:20 <siracusa> ManateeLazyCat: What does Assistant module do?
07:05:38 <ManateeLazyCat> siracusa: Oh, maybe another gusy.
07:05:41 <Nibble> b_jonas: I am just kidding -___-
07:05:49 <copumpkin> pokoko222: yes
07:05:59 <ManateeLazyCat> siracusa: I remember someone tall me he want Assistant in next gtk2hs.
07:06:11 <Nibble> and yes, it is a type error
07:06:15 <hamishmack> ManateeLazyCat: http://paste2.org/p/932942
07:06:52 <siracusa> ManateeLazyCat: No, it wasn't me.
07:09:21 <hamishmack> ManateeLazyCat: works ok without " :: Int "
07:09:31 <hamishmack> ManateeLazyCat: output is...
07:09:39 <hamishmack> ManateeLazyCat: GdkWindow Id : 0x004e02f2
07:10:31 <ManateeLazyCat> hamishmack: 0x004e02f2 looks is address of pointer and not like normal gdkWindow id.
07:11:34 <pokoko222> copumpkin so for this problem with what precision do i need to work? are 20 digits enough? i do this one in c++ 
07:11:49 <copumpkin> I have no idea what problem it is :P
07:11:58 <pokoko222> http://projecteuler.net/index.php?section=problems&id=26
07:12:14 <hamishmack> ManateeLazyCat: I presume it is an HWND as opposed to an X11 window id
07:12:18 <ManateeLazyCat> hamishmack: drawableGetID is wrong on Windows binding.
07:12:23 <copumpkin> you're not going to get anywhere using imprecise representations, pokoko222 
07:12:51 <pokoko222> hmm and precise means?
07:13:32 <ManateeLazyCat> hamishmack: I have ask in gtk+ list, gtk+ guys said just add API in GTK+-3, in GTK+-2, we need tweak gdk_x11_drawable_get_xid and gdk_win32_drawable_get_handle for different platform.
07:14:05 <nphg|laptop> copumpkin, well if he can get more than 1000 digits precision he should be fine
07:14:13 <copumpkin> I guess
07:14:33 <copumpkin> but it's not a very nice solution
07:14:42 <b_jonas> copumpkin: why not? I think it would be enough to use, say, 4000 digits, and guess from that. that's still quite fast. afterall, the repeating section plus the initial part can't be longer than 1000 digits. 
07:14:56 <nphg|laptop> to that I agree
07:15:03 <b_jonas> otoh it WOULD be easier doing it in another way, precisely
07:15:08 <b_jonas> I think
07:16:03 <pokoko222> how would i get 4000 digits of ? :D
07:16:11 <quicksilver> the point of the problem is to understand and solve the mathematical puzzle
07:16:16 <copumpkin> > showCReal 40000 (1/6)
07:16:17 <lambdabot>   "0.166666666666666666666666666666666666666666666666666666666666666666666666...
07:16:23 <ManateeLazyCat> hamishmack: Can you change "gdk_win32_drawable_get_handle :: (Ptr Drawable) -> IO (Ptr a)" to "gdk_win32_drawable_get_handle :: (Ptr Drawable) -> IO CInt" in gtk/Graphics/UI/Gtk/General/Structs.hsc and try again? Thanks.
07:16:24 <quicksilver> not by using an abritrary precision floating point type
07:16:25 <copumpkin> there, sledgehammer it
07:16:29 <quicksilver> but by thinking about the maths
07:16:30 <quicksilver> and solving it.
07:16:33 <quicksilver> it's up to you though.
07:16:50 <quicksilver> Lots of people come here thiking euler is a programming exercise but it isn't - it's a maths exercise.
07:17:05 <pokoko222> quicksilver yeah i wanna solve it the proper way, so can you clarify more about the math point i here?
07:17:05 <copumpkin> pokoko222: in general, euler problems will have a naive solution (that will often take years to complete) and a clever one
07:17:18 <pokoko222> yeah i want the clever one and work it for days
07:17:21 <ManateeLazyCat> hamishmack: I think "IO CInt" is right value to return.
07:17:27 <copumpkin> pokoko222: think about fractional representations of recurring digits
07:17:28 <quicksilver> copumpkin: unfortunately, in a few cases, computers are now so fast that the naive solution works ;)
07:17:29 <hamishmack> ManateeLazyCat: Not right now, but I'll give it a go tomorrow.
07:17:30 <copumpkin> and patterns about them
07:17:36 <ManateeLazyCat> hamishmack: Thanks.
07:19:33 <ManateeLazyCat> siracusa: Can you change "gdk_win32_drawable_get_handle :: (Ptr Drawable) -> IO (Ptr a)" to "gdk_win32_drawable_get_handle :: (Ptr Drawable) -> IO CInt" in gtk/Graphics/UI/Gtk/General/Structs.hsc and compile again?
07:20:05 <ManateeLazyCat> siracusa: Then test http://paste2.org/get/932932 with "ghc --make test.hs"
07:20:51 <ManateeLazyCat> siracusa: Thanks.
07:21:13 <ivanm> ManateeLazyCat: huh? when was it broken?
07:21:23 <siracusa> ManateeLazyCat: This requires only package gtk to be compiled again?
07:21:29 <ManateeLazyCat> siracusa: yes.
07:21:45 <ManateeLazyCat> ivanm: I'm test some gtk2hs on Windows.
07:21:55 <ivanm> well, AFAIK graphviz isn't broken....
07:22:02 <ivanm> it isn't perfect, but it works
07:22:15 <ManateeLazyCat> ivanm: Oh, you mean graphviz 
07:22:25 <ManateeLazyCat> ivanm: It can't works for me, unfortunately.
07:22:34 <ivanm> why not?
07:22:34 <ManateeLazyCat> ivanm: Some gtk2hs code break graphviz
07:22:45 <ivanm> ummmmm, I don't use gtk2hs
07:23:03 <ivanm> the only possible problem is in terms of using the gtk canvas output if you don't have that enabled
07:23:48 <ManateeLazyCat> ivanm: Oh, no graphviz, which your package generate svg ?
07:24:04 <ManateeLazyCat> ivanm: Sorry, i remember wrong name.
07:24:13 <ivanm> oh, you mean SourceGraph?
07:24:25 <siracusa> ManateeLazyCat: btw, the last build gives `Loading package gtk-0.11.0 ... linking ... <interactive>: c:\ghc\ghc-6.10.4\ext-lib\gtk-0.11.0\HSgtk-0.11.0.o: unknown symbol `__imp__gdk_threads_lock': unable to load package `gtk-0.11.0'' in GHCi.
07:24:33 <ivanm> it's broken on some source files because haskell-src-exts fails
07:24:40 <ivanm> admittedly, atm it only fails silently...
07:25:08 <ivanm> however, I'm not going to touch SourceGraph (apart from updating it when deps update) until I've got fgl, etc. sorted
07:25:20 <ManateeLazyCat> siracusa: Looks gtk2hs still have some bug on windows.
07:25:41 <ManateeLazyCat> siracusa: You have change Struct.hsc and re-compile gtk package?
07:25:59 <siracusa> ManateeLazyCat: No, I'll do that now.
07:26:42 <ManateeLazyCat> siracusa: From your error, it's looks mis some #ifdef in source code.
07:28:07 <Phyx-> wow...
07:28:17 <ManateeLazyCat> Phyx-: wow what?
07:28:32 <ManateeLazyCat> Phyx-: Beautiful SourceGraph?
07:28:40 <Phyx-> I just spend 5 minutes wondering why gcc was complaining about [wchar_t]
07:29:41 <Baughn> ..and it took me fifteen seconds to figure out. My first impulse was "Wait, why would it complain?".
07:29:42 <ivanm> Phyx-: and?
07:30:58 <silver> [wchar_t] mah_cool_list;?
07:31:07 <siracusa> ManateeLazyCat: This line `withForeignPtr drawable gdk_win32_drawable_get_handle' gives a compile error `Couldn't match expected type `Ptr a' against inferred type `CInt''
07:35:29 <ManateeLazyCat> siracusa: Then change "withForeignPtr drawable gdk_win32_drawable_get_handle" to "withForeignPtr drawable (liftM castPtr gdk_win32_drawable_get_handle)", and try again.
07:35:30 <ManateeLazyCat>  
07:35:38 <ManateeLazyCat> siracusa: Line 613
07:36:16 <Phyx-> ivanm: lol, should have been wchar_t*
07:36:26 <Phyx-> ManateeLazyCat: ^_^ guess I'm not alone
07:36:28 <ivanm> heh
07:36:36 <ivanm> oh, right, you were using haskell list notation...
07:36:58 <Phyx-> hehehe
07:38:50 <siracusa> ManateeLazyCat: `Couldn't match expected type `IO (Ptr a)' against inferred type `Ptr b''
07:42:49 <ManateeLazyCat> siracusa: Sorry, is "withForeignPtr drawable (liftM castPtr . gdk_win32_drawable_get_handle)", lost '.' :)
07:45:36 <siracusa> ManateeLazyCat: I'm sorry, now this one again: `Couldn't match expected type `Ptr a' against inferred type `CInt''
07:46:07 <ManateeLazyCat> siracusa: Forgot it, i let Axel help me test it on Windows.
07:46:13 <ManateeLazyCat> siracusa: Thanks for your time.
07:46:23 <siracusa> ManateeLazyCat: No problem :-)
07:48:03 <ManateeLazyCat> siracusa: I have build new ticket at http://hackage.haskell.org/trac/gtk2hs/ticket/1197 , thanks for report! :)
07:52:36 * hackagebot uu-parsinglib 2.5.0 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.0 (DoaitseSwierstra)
07:53:36 <siracusa> ManateeLazyCat: Now, how do I get back to the last working version? :-)
07:54:56 <ManateeLazyCat> siracusa: Because darcs version still tag 0.11.0, so it's last working version if you don't use drawableGetID.
07:55:42 <ManateeLazyCat> siracusa: If you don't want darcs version, you need re-install "pango gtk" from hackage. 
07:56:00 <ManateeLazyCat> siracusa: Because darcs version move some cairo code from `gtk` package to `pango` package.
07:56:41 <siracusa> ManateeLazyCat: Ok, I think I'll take the hackage version
07:58:17 <ManateeLazyCat> siracusa: Darcs version have new API that send gdk event cross-process. :)
07:58:34 <ManateeLazyCat> @hackage gtk-serialized-event
07:58:35 <lambdabot> http://hackage.haskell.org/package/gtk-serialized-event
07:59:38 <ManateeLazyCat> 'gtk-serialized-event' package integrate 'widgetEvent' (darcs version) can send gdk event from one process to another process.
08:05:48 * ManateeLazyCat Bye all, night. :)
08:09:16 <Quadrescence> generally, is printing a side effect? (not necessarily in haskell)
08:09:21 <copumpkin> yeah
08:09:26 <Quadrescence> thanks
08:09:52 <copumpkin> lol
08:10:37 <Phyx-> lol, that was a quick question
08:11:26 <roconnor> generally printing is *implemented* as a side effect (of evaluation)
08:11:56 <roconnor> being a side-effect is an aspect of impelmention, not a property of the effect itself
08:12:59 <Jafet> I want main effects and dessert effects
08:13:27 <b_jonas> .oO( in basic, printing is usually not a side effect of evaluating an expression, but of executing a statement. does that count too? )
08:13:30 <b_jonas> Jafet: lol
08:14:26 <roconnor> b_jonas: good point.  I've been thinking of ML too much
08:14:33 <b_jonas> .oO( in that regard, you could say that basic is a pure language because expressions can't have side effects (barring USR), only statements can. )
08:14:48 <b_jonas> .oO( but it's not a real one because the language of expressions is not complete )
08:15:03 <roconnor> b_jonas: I still think even in basic printing is a function call
08:15:20 <roconnor> and a side effect of *evalutaing* that function call (to nothing) is printing
08:15:49 <roconnor> maybe I'm wrong
08:15:57 <Baughn> quantumChoice :: RealWorld -> Int -> (RealWorld,RealWorld)
08:16:56 <EvanR-work> gawd not the quantum monad again
08:17:08 <Baughn> It's just QIO
08:20:32 <quicksilver> roconnor: in BASIC, printing is a keyword. I'd called that a "primitive operation"
08:20:51 <quicksilver> roconnor: you can choose to interpret all primops as being function calls, but that's not a very idiomatic view of basic, I guess.
08:21:02 <roconnor> oh ok
08:21:21 <roconnor> quicksilver: ya, you are right
08:21:56 <b_jonas> quicksilver, roconnor: my point is not that it's a primitive, but that syntactically a statement. simplifying, a basic program is a numbered list of lines, every line is a statement which is 
08:22:26 <quicksilver> Yes. BASIC has a strong statement/expression distinction
08:22:33 <b_jonas> made of a statement keyword and a list of arguments, the arguments being expressions. the expressions have a recursive grammar, with other expressions and builtin functions in it, but not statements.
08:22:39 <quicksilver> yeah.
08:22:52 <roconnor> ``In computer science, a function or expression is said to have a side effect if, in addition to producing a value, it also modifies some state or has an observable interaction with calling functions or the outside world.''
08:23:04 <roconnor> sounds like printing in BASIC isn't a side effect
08:23:08 <b_jonas> (that doesn't account for some arguments to statements which are not expressions, such as the variable for assignment)
08:23:49 <b_jonas> and the strange thing is, most expressions don't have side effects, only the statements have, plus the RND and USR functions;
08:24:08 <b_jonas> but that's not by design, it's accidental, there'd be nothing wrong with a builtin _function_ with side effects
08:24:27 <b_jonas> in fact some basics have an INPUT$ function that reads keystrokes etc
08:24:34 <b_jonas> functions or variables that read the time
08:24:51 <b_jonas> but most side effects, like assignment and printing, are statements
08:25:16 <b_jonas> I guess you could design a basic-like language where all side effects are in the statements
08:27:29 <roconnor> but they aren't side-effects
08:28:26 <roconnor> if you did that you'd have a nice pure langugage like haskell
08:28:42 <roconnor> the only thing you'd be missing would be user defined functions.
08:28:42 <b_jonas> er I don't think so
08:28:48 <roconnor> and data types
08:29:12 <roconnor> and classes
08:29:49 <b_jonas> and io actions as first-class values
08:29:53 <b_jonas> those are what make haskell pure
08:30:04 <b_jonas> right?
08:30:16 <b_jonas> not a syntactic distinction between statements and functions
08:30:18 <roconnor> without any primitive functions to take and malipluate IO actions, the point is moot.
08:31:26 <b_jonas> also, I guess by data types you don't only mean user-defined data types but also any kind of dynamic memory allocation and gc (except for REDIMming arrays)
08:31:28 <roconnor> You could imagine adding such primitive functions
08:31:48 <b_jonas> that is, no recursive data types at all
08:31:50 <b_jonas> like lists
08:31:53 <Phyx-> Ahh I love it when a plan comes together
08:32:22 <b_jonas> if you add all those missing stuff including lambdas, you get something ugly like current visual basic
08:32:27 <b_jonas> basic syntax just doesn't scale
08:32:28 <roconnor> b_jonas: You would have whatever dynamic memory allocation the basic primitives give you
08:33:07 <roconnor> does visual basic have lambdas?
08:33:20 <b_jonas> roconnor: I heared it does lately
08:33:30 <Phyx-> C# has lambdas
08:33:37 <Phyx-> I'm not so sure about VB
08:33:40 <roconnor> it probably also has functions with side effects
08:33:48 <roconnor> which is what we are trying to eliminate here.
08:33:49 <b_jonas> I just think basic syntax is just not suitable for this kind of thing, you just have to remove it
08:33:49 <Kaidelong> roconnor: it has for a while now
08:33:57 <Kaidelong> although I don't think they are CALLED lambdas
08:34:03 <b_jonas> if you want a modern language, it won't look like basic
08:34:13 <Kaidelong> Visual Basic doesn't really look like Basic
08:34:30 <roconnor> b_jonas: um, I think my point is getting lost here
08:34:30 <Kaidelong> so it certainly is proof enough of that
08:34:34 <b_jonas> you could keep unimportant details like UPPERCASE KEYWORDS etc
08:35:03 <roconnor> b_jonas: I just mean that if you make sure that all functions are side-effect free, which isn't much of a stretch, then BASIC would be a pure language.
08:35:18 <roconnor> without the ability to make user defined functions, I wouldn't call it a functional language
08:35:42 <b_jonas> or 40x25 screen on a glowing green monochrome crt, and slowness
08:35:51 <Jafet> Functional has three meanings when applied as an adjective to languages.
08:36:13 <roconnor> and it would still suck because BASIC doesn't even do structural programming.
08:36:25 <Jafet> Haskell definitely satisfies two; and some would say it also fulfils the third
08:36:39 <roconnor> Jafet: enumerate
08:36:54 <b_jonas> maybe even haskell would look like basic if it was uppercased and watched on such a monitor and with line numbers prepended and no indentation or layout
08:37:04 <b_jonas> roconnor: maybe yes. 
08:37:24 <b_jonas> roconnor: it can have structured programming without having user-defined functions at expression level though
08:37:42 <b_jonas> roconnor: if you add block-ifs and whiles and subs (user-defined _statements_)
08:37:46 <b_jonas> like modern basic
08:37:50 <b_jonas> but not user-defined functions
08:38:13 <Jafet> roconnor: 1) functions are first class 2) non-mathematical (side) effects are explicit 3) antonym of dysfunctional
08:38:44 <roconnor> is 2) really one of the definitions?
08:39:10 <Jafet> Bah. A word is defined when enough people use it with that definition
08:39:11 <roconnor> b_jonas: are you aware of http://hackage.haskell.org/packages/archive/BASIC/0.1.5.0/doc/html/Language-BASIC.html
08:39:19 <b_jonas> roconnor: yes
08:39:38 <b_jonas> roconnor: what I don't like in that is that it doesn't have the same operator overloaded for equality and assignment like real basic
08:39:47 <roconnor> Jafet: do people use definition 2) ?
08:39:53 <roconnor> I'd call 2) pure
08:40:08 <jmcarthur> roconnor: some call it "purely functional"
08:40:10 <Cale> I'd include purity as an important aspect of functional programming.
08:40:14 <roconnor> b_jonas: more type classes!
08:40:23 <jmcarthur> i prefer "pure, functional"
08:41:09 <roconnor> jmcarthur: hmm, in this imaginary basic we are talking about, 2) is satifised, but I don't think the word functional belong anywhere near this language.
08:41:29 <quicksilver> Cale: I would, too, but I'm increasingly realising this isn't what the world at large means by 'functional programming'.
08:41:30 <Jafet> Languages we have been using so far tend to be very of all three adjectives at once, or not much of them, so people are somewhat justified in this semantic compression I guess
08:41:53 <quicksilver> Cale: LISP is almost invariably classified as functional, but none of the popular dialects are remotely pure.
08:42:30 <roconnor> I'd rather say purity is an important aspect of programming
08:42:34 <roconnor> :)
08:43:27 <Cale> Common lisp especially isn't a very good language for functional programming in my experience. Scheme is better.
08:44:13 <jmcarthur> i recently have been sticking with 1)
08:44:47 <Kaidelong> I found both CLISP and Scheme unsatisfactory
08:44:59 <jmcarthur> purity is important, but i don't see why "functional" and "pure" need to be conflated, especially when we have two perfectly good separate words
08:45:11 <Kaidelong> for my learning experience, anyway
08:45:13 <roconnor> jmcarthur: that sounds good to me
08:46:01 <roconnor> b_jonas: I wonder if a structured pure version of BASIC would be nicer to program in than C.
08:46:49 <jmcarthur> i've wondered sometimes whether raw llvm assembler would be nicer to program than C
08:46:58 <Ke> =oP
08:47:21 <Cale> When I hear "functional programming language", I mostly think of the members of the ML family along with Haskell.
08:47:24 <jmcarthur> it's not pure, but at least it's SSA
08:47:31 <jmcarthur> or can be used as SSA
08:47:32 <roconnor> http://www.markshuttleworth.com/archives/439 
08:47:41 <roconnor> Tribalism is the enemy within
08:47:45 <Cale> Pattern matching is sort of important :)
08:48:22 <roconnor> jmcarthur: does llvm asmembly support structured programming?
08:48:27 <jmcarthur> i think purity naturally lends itself to ADTs. at least, i can't think of many nice ways to design a pure language without them
08:48:32 <jmcarthur> roconnor: i dunno
08:48:45 <jmcarthur> even if it doesn't, structured programming is as much a discipline as a language feature
08:48:56 <Cale> Lisps are functional programming languages to me in the same way that penguins are birds.
08:48:57 <roconnor> jmcarthur: this imaginary BASIC is pure and has no ADTs
08:49:03 <roconnor> jmcarthur: though perhaps it isn't nice.
08:49:31 <roconnor> jmcarthur: arguably functional  and object-oriented programming is as much a discipline as a language feature
08:49:34 <jmcarthur> @remember Cale Lisps are functional programming languages to me in the same way that penguins are birds.
08:49:35 <lambdabot> Okay.
08:49:58 <Ke> Cale: though technically lisp is not functional, but penguins are birds
08:50:01 <jmcarthur> roconnor: not if our definition for functional is 1)
08:50:01 <Phyx-> penguins rule man, don't knock the pengies
08:50:22 <b_jonas> heh, that reminds me to the penguin joke
08:50:40 <roconnor> jmcarthur: aw crap, I was using definition 2)
08:50:41 <Cale> Ke: Well, they have features which make functional programming possible, but it's awkward.
08:50:48 <roconnor> jmcarthur: insidious.
08:51:00 <Cale> and they're atypical among languages in which one might do functional programming
08:51:32 <Cale> (in the way that penguins aren't usually the first image to pop into one's mind when one hears "birds")
08:51:44 <roconnor> lisp is function according to definition 1)
08:51:51 <roconnor> functional
08:52:16 <Phyx-> are you guys making stuff up?
08:52:27 <Phyx-> or are you all just drunk already since it's friday
08:53:32 <Ke> anyways lisp is an abominatin with heretic type system
08:53:47 <Phyx-> lol "Cabal" really doesn't like tabs
08:53:47 <Cale> Lisp doesn't really have a type system
08:53:48 <Phyx-> :/
08:53:59 <Ke> indeed
08:54:44 <Cale> Phyx-: You should have already configured your editor not to produce them if you're working with Haskell anyway :)
08:55:26 <Phyx-> Cale: I whipped up the cabal file in notepad :)
08:55:49 <cuba> 33s
08:55:52 <jmcarthur> lisp is a file format
08:55:54 <Phyx-> I just didn't expect Cabal to say the equivalent of "gtfo"
08:55:57 <Phyx-> I like it...
08:56:18 <Cale> I think GHC should take the same policy with respect to nonstandard whitespace
08:56:26 <dcoutts> Phyx-: someone's gotta take a hard line on tabs :-)
08:56:39 <dcoutts> Phyx-: and it'd mess up the layout based parsing
08:56:47 <Cale> Tabs ought to be lexical errors.
08:56:50 <hewei> @help
08:56:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:56:58 <dcoutts> Cale: -fwarn-tabs -Wall
08:57:05 <Phyx-> dcoutts: you won't hear me complaing :) I whish ghc did it aswell
08:57:09 <dcoutts> or is it -wtabs 
08:57:17 <dcoutts> Phyx-: it will, if you ask it to
08:57:26 <hewei> @help list
08:57:26 <lambdabot> list [module|command]
08:57:27 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
08:57:31 <Cale> dcoutts: I don't want it to be a warning, and I don't want any switches ;)
08:57:38 <Phyx-> dcoutts: unfortunately, GHC itself won't compile then
08:57:39 <hewei> @list
08:57:39 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:57:41 <Cale> dcoutts: Just make it an error outright :)
08:57:52 <dcoutts> Cale: -Werror :-)
08:58:12 <hewei> @hoogle 
08:58:13 <lambdabot> No query entered
08:58:13 <lambdabot> Try --help for command line options
08:58:21 <hewei> @hoogle --query
08:58:22 <lambdabot> Unrecognised or malformed flags:
08:58:22 <lambdabot>   Unknown flag query
08:58:22 <lambdabot> For details on correct flags pass --help
08:58:27 <hewei> @hoogle --help
08:58:27 <lambdabot> Go to the website for full help, http://haskell.org/hoogle/
08:58:28 <lambdabot>  
08:58:28 <lambdabot> Flag reference:
08:58:39 <b_jonas> nah, there's nothing wrong with tabs as long as everyone agrees it counts as exactly 8 spaces even if you are indenting 4 or 5 or 6 spaces or whatever. just make your editor indent the line by 6 spaces when you press tab and collapse the spaces to tabs.
08:58:40 <hewei> @hoogle IOSLA
08:58:41 <lambdabot> No results found
08:58:42 <Phyx-> @hoogle a -> [a]
08:58:42 <lambdabot> Prelude repeat :: a -> [a]
08:58:42 <lambdabot> Data.List repeat :: a -> [a]
08:58:42 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
08:59:04 <b_jonas> (and unindent when you press backspace and keep indenting when you open a new line etc)
08:59:16 <Cale> b_jonas: Except that not all editors display them the same, and editing code with tabs in it is annoying.
08:59:45 <Phyx-> b_jonas: I would have agreed with you before I started editting GHC files. which use alot of tabs, and even though my editor replaces tabs by 8 spaces, sometimes i'm getting the weirdest syntax errors
08:59:45 <quicksilver> Cale: I believe (but may be mistaken) that LISP was called functional because it conveniently permitted functions as arguments to functions, and that's where the etymology of 'functional' begins. The intertubes are too full of junk for me to easily confirm this believe with a reference.
08:59:57 <hewei> @hoogle IO a -> a
08:59:58 <lambdabot> Foreign unsafePerformIO :: IO a -> a
08:59:58 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
08:59:58 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
09:00:31 <Cale> quicksilver: Sure. The general idea of what "functional programming" consists of has evolved since then though.
09:00:32 <aristid> hewei: but that's evil.
09:00:43 <b_jonas> Cale: some editors are broken. that can't be helped. tabs should be exactly 8 spaces everywhere, or don't use them. also, don't use them inside the line, only at the beginning of a line.
09:01:02 <Cale> b_jonas: I'd rather editors just never emit them at all.
09:01:04 <hewei> @hoogle IOLA b c -> IOSLA s b c 
09:01:05 <lambdabot> Warning: Unknown type IOLA
09:01:05 <lambdabot> No results found
09:01:14 <Cale> b_jonas: I see no good reason for them to exist.
09:01:17 <b_jonas> if you want to use spaces, you're free to, you can even expand tabs in my code, I won't really mind, but I think compilers should accept my tabs.
09:01:18 <aristid> with unsafePerformIO, would IO be a comonad?
09:01:22 * fryguybob friends don't let friends use tabs...
09:01:32 <Phyx-> lol
09:01:40 <Cale> aristid: no
09:01:44 <Phyx-> try #3
09:01:46 <b_jonas> we're in the 21st century with good editors.
09:01:55 * Phyx- hopes the project loads :)
09:02:02 <aristid> Cale: are some laws not held? because the types could be done
09:02:19 <Cale> aristid: Well, unsafePerformIO isn't a function
09:02:33 <aristid> extract = unsafePerformIO, duplicate = return
09:02:53 <fryguybob> b_jonas: My definition of a good editor is one where the file is always saved without tab characters.
09:03:06 <Cale> and so it's hard to say that any of the laws hold with a straight face :)
09:03:31 <aristid> Cale: and with pretending and handwaving? :D
09:03:43 * Phyx- curses
09:04:30 <b_jonas> Cale: you could consider unsafePerformIO if you accept that you must only call it on IO actions without observable side effects and that the compiler can't check this.
09:04:36 <Phyx-> @google required cabal fields haskell
09:04:37 <lambdabot> http://www.haskell.org/cabal/proposal/x611.html
09:04:37 <lambdabot> Title: The Cabal simple build infrastructure
09:04:47 <Phyx-> @google required cabal fields
09:04:48 <lambdabot> http://www.haskell.org/cabal/proposal/x611.html
09:04:48 <lambdabot> Title: The Cabal simple build infrastructure
09:05:15 <quicksilver> b_jonas: at that point IO degenerates to identity.
09:05:17 <aristid> b_jonas: that kind of handwaving, yeah :)
09:05:31 <quicksilver> and you're just saying that Identity is a comonad under runIdentity
09:05:41 <quicksilver> which it is, but that's about the most boring comonad imaginable.
09:05:43 <aristid> :t runST
09:05:44 <lambdabot> forall a. (forall s. ST s a) -> a
09:05:50 <Cale> I think it's time that everyone put tab aside, along with all those other weird ASCII control characters.
09:06:03 <aristid> Cale: wishful thinking :P
09:06:15 <Phyx-> what's a good default license for a haskell project?
09:06:23 <Phyx-> I have no idea bout licenses
09:06:26 <roconnor> Phyx-: I use MIT
09:06:29 <Cale> Phyx-: BSD
09:06:50 <Phyx-> BSD or MIT, any tie breakers?
09:06:53 <aristid> quicksilver: what about State? could that be a comonad?
09:06:56 <Cale> Most Haskell things use BSD
09:07:08 <roconnor> aristid: there is a state comonad, but it looks different
09:07:13 <noisetonepause> Phyx-: MIT an BSD are roughly equivalent
09:07:16 <Phyx-> ok, it's just the default anyway, so I'll make that BSD
09:07:36 <aristid> roconnor: different in what way?
09:07:44 <roconnor> Ya, I use MIT because at one point I concluded it was slightly better than BSD.  But I forget why
09:07:45 <fryguybob> BSD vs MIT == West coast vs East coast (USA) ?
09:08:14 <roconnor> State s a := s -> (s,a) is the state monad
09:09:48 <aristid> roconnor: is Context the comonad that you mean?
09:09:49 <hewei> How can I lift a (IOListArrow b c) to (IOStateListArrow s b c) please? 
09:09:50 <roconnor> State s a := (s,s -> a) is the state comonad?
09:10:30 <quicksilver> aristid: typically, interesting monads are not interesting comonads
09:10:32 <aristid> if s is a Monoid, the normal State can be a comonad too, no?
09:10:46 <quicksilver> defining extract using mempty?
09:10:50 <aristid> yeah
09:11:03 <quicksilver> sounds unlikely to be an interesting one.
09:11:10 <quicksilver> how do you define duplicate?
09:11:17 <aristid> duplicate = return :D
09:11:41 <quicksilver> I think duplicate = return essentially means you have no interesting comonadic structure.
09:11:54 <aristid> hmm
09:12:07 <aristid> quicksilver: my understanding of what makes comonads interesting is quite limited
09:14:41 <quicksilver> relative-time Behaviour makes quite a good comand
09:14:53 <quicksilver> but to really grok that you need to spend a bit of time thinking about Reactive.
09:15:02 <quicksilver> zippers make good comonads
09:15:22 <quicksilver> (those two comonads are, in a sense, the same kind of shape)
09:18:26 <aristid> quicksilver: Reactive?
09:19:31 <aristid> category-extras doesn't seem to have such a comonad
09:19:53 <quicksilver> it's not an abstract comomand
09:20:04 <quicksilver> it's a specific one, it only makes sense with the context.
09:20:20 <aristid> quicksilver: i suppose there's a paper? :)
09:20:35 <aristid> the first axiom of #haskell: There's a paper about it.
09:21:48 <quicksilver> aristid: yes, and in a weird quirk of fate the author of the paper joined the room 20 seconds afer you said that
09:22:31 <aristid> conal?
09:22:35 <quicksilver> right.
09:22:37 <quicksilver> aristid: http://conal.net/papers/simply-reactive/
09:22:52 <quicksilver> also http://haskell.org/haskellwiki/Reactive
09:23:18 <conal> you'll see that paper has been superceded.
09:23:18 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:24:18 <roconnor> quicksilver: there is something odd about zippers of lists.  People are lead to believe that focus is on the elements of the list, but really the focus in on the entire tail of the list (which could be empty)
09:24:26 <Nibble> hi
09:24:30 <roconnor> quicksilver: thus zippers are not necessairly comonads
09:24:45 <Nibble> maximum' (x:xs) how does haskell know that it needs to split the list into a head and a tail?
09:24:57 <Nibble> that's the definition of maximum'
09:24:59 <quicksilver> roconnor: you don't have to do it that way, do you?
09:25:00 <DrSyzygy> Nibble: That's how lists in Haskell are defined in the first place.
09:25:00 <roconnor> the pattern (x:xs) says so
09:25:07 <Nibble> DrSyzygy: a head and a tail?
09:25:08 <quicksilver> roconnor: I mean there is more than one way to define a zipper.
09:25:15 <roconnor> quicksilver: I don't know.  It is the official definition of a zipper
09:25:19 <Nibble> @src []
09:25:19 <lambdabot> data [] a = [] | a : [a]
09:25:25 <Nibble> I guess it is :)
09:25:25 <quicksilver> roconnor: you can choose to always focus on an element, except in the case the list is actually empty.
09:25:31 <Nibble> thanks you DrSyzygy 
09:25:34 <DrSyzygy> Nibble: Yup. Lists have : as their constructor, so if you're pattern matching on lists, you get a head a, and a tail as from the pattern match a:as.
09:25:36 <copumpkin> Nibble: singly linked list!
09:25:46 <Nibble> copumpkin: are they singly linked?
09:25:48 <quicksilver> conal: I did, I haven't read your new one yet.
09:25:51 <quicksilver> conal: push it on the stack :(
09:25:55 <copumpkin> Nibble: that definition says so :)
09:25:59 <DrSyzygy> Nibble: They are. Look at the definition.
09:26:04 <copumpkin> Nibble: doubly linked ones aren't very practical in haskell
09:26:06 <Phyx-> ok... what is this error "commitAndReleaseBuffer: invalid argument (Bad file descriptor)"
09:26:07 <DrSyzygy> : is the linker.
09:26:07 <roconnor> quicksilver: I suspsect that focusing on the nil element of a non-empty list is also important.
09:26:16 <Nibble> copumpkin: I can see the reason for that
09:26:22 <Nibble> since we do not have loops
09:26:26 <quicksilver> roconnor: for a non empty list you can choose to focus on elements, or between elements
09:26:42 <quicksilver> roconnor: I think either choice basically works for the kinds of things you normally do with zippers
09:26:49 <conal> quicksilver: it's very similar.  a renaming with a few improvements.
09:26:54 <roconnor> quicksilver: but one of those definitions is natural
09:27:01 <conal> small improvements.
09:27:07 * quicksilver nods
09:27:15 <roconnor> quicksilver: and the other I don't know how to generalize (not that I've tried)
09:27:20 <Nibble> so basically, [y] == x : xs?
09:27:37 <conal> Baughn: "Some day, it would be nice if you'd write a blog entry on exactly what kind of thought process lets you come up with things like your newest zipper variant."  Thanks for the encouragement.  I'd like to write such a post.
09:27:46 <copumpkin> Nibble: or []
09:27:59 <copumpkin> unless you mean y is an actual constant element
09:28:02 <roconnor> quicksilver: also I never thought of it as focusing between elements, that's an intersting point of view.
09:28:04 <copumpkin> [y] == y : []
09:28:11 <copumpkin> that's just syntactic sugar
09:28:18 <Phyx-> ah, it's trying to write to stdout
09:28:20 <Nibble> copumpkin: I meant y was a type
09:28:23 <Nibble> sorry, should have written a
09:28:36 <copumpkin> in that case, yep, it's either a cons cell or an empty list
09:28:47 <Nibble> ghc-pkg check gives me that zlib, http, network and parsec are broken
09:29:16 <roconnor> conal: where you trying to generalize zippers to arbitrary recursive species? ;)
09:29:17 <Nibble> tbh, cabal has been a real pain in the ass :(
09:29:39 <Nibble> first of all it is not finding the packages I installed, not sure if that is working now either
09:29:42 <Nibble> will check
09:30:26 <dcoutts> Nibble: you're using the 'cabal' program right? not runghc Setup.hs configure
09:30:34 <Nibble> dcoutts: yep
09:30:58 <dcoutts> Nibble: and you didn't accidentally install packages just for root or something
09:31:14 <Nibble> dcoutts: I don't think so, I use sudo but it installs them to .cabal
09:31:20 <conal> roconnor: i don't know what i was trying to do.  it started as a concrete graphics problem.  a data structure for continuous infinite images.  something i've been thinking about on & off for years.  and then recently motivated by the ipad gpu/resolution combo.
09:31:35 <roconnor> conal: ah.
09:31:58 <Nibble> dcoutts: yep, it is not finding packages. I will try to install it without sudo
09:32:00 <dcoutts> Nibble: mm, you may find you've now got files owned by root in your ~/.cabal dir
09:32:01 <roconnor> acutally, in that context as well left-right because unnatural
09:32:05 <Nibble> dcoutts: yep
09:32:09 <roconnor> (with species it becomes impossible)
09:32:21 <dcoutts> Nibble: cabal will find them if ghc-pkg list knows about them (ie if they really are registered)
09:32:25 <roconnor> s/because/becomes/
09:32:28 <conal> i tried writing a lazy infinite quad-tree zipper in obj-c and had to start over in haskell to get it right.  and then i started seeing patterns and playing with them.
09:33:23 <aristid> quicksilver, conal, thanks
09:33:47 <Nibble> http://pastebin.com/NjEpuz8J
09:33:55 <Nibble> that is what I get now
09:36:41 <Phyx-> aaarrrrrg
09:36:47 <Baughn> conal: Oh. Also, the zipper-post should probably include an example of the system you're replacing. And (links to) definitions of Const and such. ;)
09:37:08 <Baughn> conal: Which is to say, it's not quite (scientifically) publishable yet. :P
09:37:19 <hewei> @pl id
09:37:19 <lambdabot> id
09:37:21 <conal> Baughn: thanks :)
09:37:42 <Baughn> conal: It's the nice thing about HTML. Hyperlinks.
09:37:55 <Baughn> (And why a wikiword-capable blog engine is handy)
09:37:55 <conal> Baughn: yeah.
09:38:45 <conal> i use markdown to compose my posts, which i like a lot.  easy to format code and links.
09:39:04 <Cale> Nibble: Did you remove packages that originally came with your copy of GHC?
09:39:15 <Nibble> Cale: no idea, I do not think so
09:39:23 <Nibble> I just reinstalled ghc and it is still not working
09:39:25 <Phyx-> I have have verbosity in Cabal set to silent but it's still outputting that "configuring..." message
09:39:29 <Cale> hmm
09:39:33 <Phyx-> anyone know how to silence that?
09:39:45 <Nibble> Phyx-: a gun to its head will do the trick
09:39:59 <dcoutts> Phyx-: file a ticket
09:40:02 <conal> i thought i might have obnoxiously many citations already in my posts.  but maybe just obnoxiously many *self*-citations.
09:40:33 <Phyx-> dcoutts: lol :/
09:41:37 <Phyx-> dcoutts: nvm, there were just multiple places to set it :/ I got the correct one now
09:42:12 <conal> i wonder whether i could reconstruct where that 'f (Loc f a)' idea came from.  it popped up recently while i was playing with refactoring.  i was startled with the simplicity.
09:42:19 <Phyx-> I really need anything I compile to be silent since stdout doesn't exist
09:43:06 <aristid> playing  <- there are little boxes at the end? oO
09:44:08 <Baughn> conal: Indeed, that's the line that really popped out at me. It's so /obvious/..
09:44:12 <jmcarthur> conal: this is what i immediately thought of:  http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Cofree.html
09:44:18 <Baughn> By which I mean, patentable.
09:44:19 <jmcarthur> conal: outCofree, specifically
09:44:23 <conal> Baughn: yeah.
09:44:32 <jmcarthur> conal: it's not quite the same though
09:44:33 <conal> jmcarthur: thx.  looking.
09:44:48 <jmcarthur> conal: also see runCofree
09:45:02 <conal> jmcarthur: yeah.
09:45:42 <conal> jmcarthur: strikingly similar
09:45:49 <jmcarthur> conal: when i read your blog post i was thinking about trying to fit your framework into this, but i haven't thought enough about it yet
09:46:02 <jmcarthur> i haven't much free time right now due to job hunting
09:46:14 * hackagebot functor-combo 0.0.7 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.0.7 (ConalElliott)
09:46:15 <conal> jmcarthur: good luck!
09:46:20 <jmcarthur> thanks :)
09:46:26 <hewei> @version
09:46:27 <lambdabot> lambdabot 4.2.2.1
09:46:27 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:46:33 <Phyx-> well... that was anticlimactic :P
09:47:08 <Nibble> Cale: any ideas?
09:47:54 <Nibble> What distros/OS do you guys use btw, on arch cabal seems to be messed up
09:48:12 <conal> that was weird.  i made that functor-combo release yesterday.
09:48:39 <conal> maybe i put my computer to sleep before it finished the release script.
09:48:44 <conal> oops.
09:49:06 <conal> oh yeah.  my internet connection spazzed again.  :(
09:49:14 <Baughn> Nibble: I never, ever use my distro's version of haskell
09:49:26 <Baughn> (That said, Gentoo. But it doesn't matter. So yeah.)
09:49:52 <Cale> Nibble: I don't rely on my distribution (Ubuntu, presently) for any Haskell stuff. I get the generic linux binary package for GHC, and then grab the cabal-install tarball from hackage and install that.
09:50:05 <Cale> (and then from there, everything is easy)
09:50:16 <Jafet> debian's haskell-platform package seems working so far
09:50:18 <Baughn> I just use the cabal-install I compiled with my previous installation to install cabal-install. >_>
09:50:47 <b_jonas> don't you focus on the cons cell?
09:52:14 <c_wraith> In the past, debian's GHC install has broken ghci, and other things.  Hence, I also go with the "generic linux binary, install cabal-install from its tarball, and use it to manage the rest" approach
09:54:49 <Cale> Nibble: Another hint about setting things up: never install anything but GHC globally. It's much simpler if you accidentally mess up your packages to just blow away .cabal and .ghc in your home directory and start over, than to redo your GHC installation.
09:56:32 <fryguybob> @botsnack
09:56:33 <lambdabot> :)
09:58:54 <Nibble> Cale: Ok, but I have not
09:59:06 <Nibble> Cale: I will try that
09:59:08 <Nibble> another question
09:59:10 <Nibble> oh nvm
10:00:17 <Cale> btw, you *may* want to keep ~/.cabal/bin even if you do blow away the rest, since cabal-install is in there. Myself, I make ~/.cabal/bin into a symlink to ~/bin
10:00:46 <Saizan> you don't really need to blow away ~/.cabal
10:00:54 <dcoutts> note that cabal can create such symlinks automatically
10:01:08 <c_wraith> ooh.  how's that, dcoutts?
10:01:09 <dcoutts> ie install to ~/.cabal/bin but add symlinks in ~/bin
10:01:20 <dcoutts> c_wraith: in the ~/.cabal/config
10:03:48 <Nibble> Cale: seems like my packet manager installs cabal globally, that might mess things up
10:04:03 <Nibble> Cale: so you suggest I just remove cabal and ghc, and install the tarballs?
10:05:04 <Cale> Nibble: Well, that's how I'd do it. There's probably some less drastic way to clean things up, but figuring out exactly what's wrong when you have broken packages is troublesome.
10:05:23 <dcoutts> Nibble: ghc-pkg check is handy
10:05:35 <dcoutts> if it says things are fine, they probably are fine
10:05:50 <Nibble> dcoutts: they are not
10:06:16 <dcoutts> Nibble: so as Cale suggests, rm ~/.ghc and then consult ghc-pkg check again
10:06:30 <dcoutts> Nibble: that obviously unregisters all your per-user registered packages
10:06:43 <dcoutts> if you've got globally registered packages that are messed up, that's a bit more tricky
10:07:09 <Nibble> dcoutts: looks like stuff in .ghc was installed by the packet manager, which I run as root
10:07:47 <dcoutts> Nibble: your system package manager will not be touching your ~/.ghc dir in your home directory
10:08:12 <dcoutts> Nibble: but if you did sudo cabal install, then that would install things as root in your home dir, which is a bad thing
10:33:55 <krey_> hello, I'm trying to understand the continuation monad + callCC, and I'm doing a horrible job at it following this tutorial: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
10:34:18 <Zeiris> Is there anything higher-level than ansi-terminal for colored terminal stuff?
10:34:25 <krey_> any ideas/links to a good explanation?
10:34:28 <Zeiris> (Am about to write a wrapper for it, want to be sure not reinventing wheel.)
10:35:26 <Zeiris> Ah. ansi-wl-pprint looks nice.
10:45:56 <chrisdone> hi
10:45:59 <askhader> hi
10:49:16 <ganjanaut> hi
10:50:48 <geheimdienst> > repeat "hi"
10:50:49 <lambdabot>   ["hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi"...
10:51:35 <askhader> > (+1) 1
10:51:36 <lambdabot>   2
10:51:41 <askhader> Indeed.
10:52:00 <askhader> > [1,2..]
10:52:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:52:11 <BMeph> > succ 1
10:52:12 <lambdabot>   2
10:52:17 <askhader> > [3,6..]
10:52:17 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
10:52:28 <askhader> [1,1,5,9..]
10:52:33 <askhader> > [1,1,5,9..]
10:52:34 <lambdabot>   <no location info>: parse error on input `..'
10:52:41 <askhader> > [1,1..]
10:52:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:52:50 <BMeph> > let u f = f 1 in u succ
10:52:51 <lambdabot>   2
10:54:02 <geheimdienst> can you make your line end with "u succ" and then make her say "u 2"?
10:54:59 <BMeph> geheimdienst: See the @faq. ;)
10:55:30 <geheimdienst> @faq miss lambdabot, could you tell us that we suck?
10:55:31 <lambdabot> The answer is: Yes! Haskell can do that.
10:56:11 <askhader> > f "u succ" = "u 2"
10:56:11 <lambdabot>   <no location info>: parse error on input `='
10:56:23 <askhader> > let f "u succ" = "u 2" in f "u succ"
10:56:23 <lambdabot>   "u 2"
10:56:26 <askhader> =]
10:56:41 <geheimdienst> "u win"
10:56:49 <askhader> oh
10:56:59 <vanadium> > let u _ = "u 2" in u succ
10:57:00 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:57:00 <lambdabot>    `GHC.Enum.Enum a'
10:57:01 <lambdabot>      ar...
10:57:16 <askhader> > let f n = "u " ++ n in f "suc"
10:57:16 <vanadium> oh come on
10:57:17 <lambdabot>   "u suc"
10:57:27 <askhader> > let f n = "u " ++ n in f "swallow"
10:57:31 <lambdabot>   "u swallow"
10:57:39 <askhader> > let f n = "u " ++ n
10:57:39 <lambdabot>   not an expression: `let f n = "u " ++ n'
10:57:42 <askhader> =/
10:57:45 <askhader> I want a sandbox
10:57:54 <askhader> it's called ghci
10:57:57 <askhader> =]
10:58:07 <geheimdienst> i guess you can also private-message her
10:58:34 <ToRA> > let you f = f 0 `div` 1 `seq` (y,o,u,t,o,o) in you succ
10:58:35 <lambdabot>   (y,o,u,t,o,o)
10:58:49 <askhader>  ;t seq
10:58:52 <askhader> > :t seq
10:58:53 <lambdabot>   <no location info>: parse error on input `:'
10:59:07 <monochrom> :t seq
10:59:08 <lambdabot> forall a t. a -> t -> t
11:06:38 <CalmNelly> lambdabot: does my butt look fat?
11:07:21 <chrisdone> @vixen does calmnelly's butt look fat?
11:07:21 <lambdabot> good question
11:07:32 <aristid> @vixen 18 19 20
11:07:33 <lambdabot> oh, i used to be that old too
11:08:22 <jmcarthur> @vixen what's your phone number?
11:08:22 <lambdabot> no phone, sorry
11:08:24 <geheimdienst> > let you = fst . ((,) "you too") . ($ 0) in you succ
11:08:26 <lambdabot>   "you too"
11:08:38 <geheimdienst> pointfree and pointless
11:08:40 <CalmNelly> @vixen hello
11:08:40 <lambdabot> hiya
11:08:44 <CalmNelly> ahhhh
11:11:24 <CalmNelly> Does anyone know how to lift the string out of an Error message
11:12:01 <c_wraith> You mean an instance of Error?
11:12:05 <jmcarthur> CalmNelly: not sure what you mean. if what you were asking for was a function, what type would it have?
11:12:35 <c_wraith> show might do what you want, in an indirect manner.
11:12:43 <CalmNelly> i suppose Exception -> String
11:12:56 <c_wraith> What Exception?  Control.Exception?
11:13:21 <c_wraith> because that would be Exception e => e -> String
11:13:31 <CalmNelly> I'm not sure, here's my function: 
11:13:32 <CalmNelly> evalprop                :: String -> Prop
11:13:32 <CalmNelly> evalprop xs             =  case (parse props xs) of
11:13:32 <CalmNelly>                              [(n,[])]  -> n
11:13:32 <CalmNelly>                              [(_,out)] -> error ("unused input " ++ out)
11:13:32 <CalmNelly>                              []        -> error "invalid input"
11:13:40 <jmcarthur> oh you mean the _|_ kind of error
11:13:50 <jmcarthur> those, by design, you can't get strings from
11:13:57 <jmcarthur> in fact, you shouldn't even catch them
11:14:01 <CalmNelly> ahh shucks
11:14:04 <c_wraith> Oh.  I really wouldn't use error if you intend to recover from it.
11:14:21 <jmcarthur> if you want a real exception you should explicitly throw one (and then, only in IO ideally)
11:14:31 <jmcarthur> CalmNelly: if this is a pure function you should use Maybe or Either or something
11:14:40 <CalmNelly> hmm
11:14:42 <jmcarthur> i suppose Either, if you want an error message
11:14:44 <geheimdienst> isn't there a function "fail" in Monad? is that related?
11:14:58 <jmcarthur> geheimdienst: in the Error monad that would do it
11:15:15 <CalmNelly> in short, I'll have to change this function, correct?
11:15:20 <jmcarthur> yes
11:15:39 <CalmNelly> okay, that's what i wanted to know
11:15:42 <kulin> use Either, it is what a lot of other people do
11:15:49 <kulin> and use Right for the correct behavior, and Left for the error messages
11:15:51 <jmcarthur> CalmNelly: typically you would use error when that code path *should* not happen (programmer error)
11:16:07 <CalmNelly> oh i see
11:16:26 <CalmNelly> so if the user enters something that can't be parsed, then use Either
11:16:37 <jmcarthur> Either is one of many legit ways to handle it
11:16:46 <jmcarthur> i would recommend Either in this case
11:16:52 <CalmNelly> okee dokee, thanks
11:16:54 <jmcarthur> since it seems very simple
11:17:09 <CalmNelly> yeah, doesn't need to be too informative at the moment
11:17:19 <jmcarthur> evalProp :: String -> Either String Prop
11:17:25 <CalmNelly> In the end I will be trying to use Parsec
11:17:25 <c_wraith> I tend to use error mostly in code paths that require a library error or an external error to end up in.
11:17:33 <L3v1> hi, all.
11:17:48 <CalmNelly> ahhh
11:17:54 <kulin> parsec actually uses Either in this way too
11:18:21 <CalmNelly> currently Parsec is giving me a headache, so i want to try something simple first
11:18:34 <lispy> CalmNelly: what headache are you having?
11:18:37 <L3v1> should i ask GHC 6.12.3 installation question here?
11:19:00 <jmcarthur> geheimdienst: Either actually forms a monad, and the instance in Control.Monad.Error is actually completely screwed up so that fail does what you suggest
11:19:34 <jmcarthur> geheimdienst: screwed up because it's only actually defined as a Monad when the left element is an instance of Error, which has a String -> a method
11:19:42 <benmachine> L3v1: might as well try, if we aren't the people to ask we will probably know who is
11:20:08 <benmachine> oh you're already in #ghc
11:20:14 <CalmNelly> @lispy I'm trying to modify this example from evalprop                :: String -> Prop
11:20:14 <CalmNelly> evalprop xs             =  case (parse props xs) of
11:20:14 <CalmNelly>                              [(n,[])]  -> n
11:20:14 <CalmNelly>                              [(_,out)] -> error ("unused input " ++ out)
11:20:14 <CalmNelly>                              []        -> error "invalid input"
11:20:14 <lambdabot> No module "I'm trying to modify this example from evalprop                :: String -> Prop" loaded
11:20:16 <CalmNelly> oops
11:20:19 <geheimdienst> okay :) since everyone is bitching about the C.M.Error.Either thing, i guess it's best to avoid it?
11:20:41 <c_wraith> I've come to the conclusion I really don't like MonadError
11:20:50 <lispy> L3v1: here is typically better.  #ghc is for devs to discuss GHC
11:20:56 <jmcarthur> o_O
11:20:59 <jmcarthur> @lispy
11:21:00 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:21:01 <c_wraith> Of course, others may disagree
11:21:02 <jmcarthur> lol
11:21:09 <CalmNelly> @lispy I'm trying to change this example that uses ParsecToken for my own purposes, but I was having trouble compiling it
11:21:09 <lambdabot> No module "I'm trying to change this example that uses ParsecToken for my own purposes, but I was having trouble compiling it" loaded
11:21:26 <c_wraith> CalmNelly, please don't start lines with @ unless you're talking to lambdabot
11:21:28 <jmcarthur> CalmNelly: please don't use @ like that ;)
11:21:31 <monochrom> please don't use "@lispy". use "lispy:"
11:21:46 <CalmNelly> oh okay
11:22:00 <CalmNelly> lol, sorry
11:22:05 <L3v1> ok. i try to install GHC 6.12.3 on a ubuntu server, which i have only user privilige.
11:22:06 <jmcarthur> c_wraith: the main problem is that fail is in Monad
11:22:06 <geheimdienst> @lambdabot, do you like twitter at all?
11:22:07 <lambdabot> Unknown command, try @list
11:22:24 <lispy> L3v1: no problem
11:22:30 <jmcarthur> c_wraith: it would be better if we had a separate MonadFail. then we could have a more general Monad instance for Either and still have that nice fail behavior
11:22:53 <lispy> L3v1: use a prefix that is in a directory you control.  For example, ./configure --prefix=$HOME
11:22:54 <L3v1> so, i use --prefix=/home/levi/local.
11:22:59 <CalmNelly> @lambdabot, do you call Bill Gates to do your tech support?
11:22:59 <lambdabot> Unknown command, try @list
11:23:22 <monochrom> it's called @vixen
11:23:25 <jmcarthur> CalmNelly: @something means "invoke the <something> command
11:23:29 <jmcarthur> "
11:23:33 <CalmNelly> oh
11:23:42 <monochrom> unlearn twitter habits
11:23:48 <jmcarthur> @type show
11:23:49 <lambdabot> forall a. (Show a) => a -> String
11:23:54 <monochrom> unlearn mainstream programming habits too
11:24:22 <CalmNelly> i don't even use twitter, it's f***en ... you know.
11:24:26 <L3v1> then, i found the server with libgmp not installed, so i install it into the same folder. (/home/levi/local)
11:24:53 <c_wraith> oh, that makes things more interesting.
11:26:01 <L3v1> and configure again, give --with-gmp-libraries=/home/levi/local/lib and --with-gmp-include too.
11:27:23 <L3v1> the configure and make install passed. but ghc cannot compile, giving '/usr/bin/ld: cannot find -lgmp'.
11:28:34 <c_wraith> You might need to set LD_LIBRARY_PATH=/home/levi/local/lib
11:28:38 <c_wraith> in your shell
11:28:53 <L3v1> i have tried that. failed either.
11:29:16 <c_wraith> well, then, you've exceeded my knowledge of fixes.  Sorry I can't help.
11:29:44 <L3v1> bcuz, without that, the utils/ghc-pwd/ghc-pwd could not execute.
11:31:01 <nphg|laptop> L3v1, did you export LD_LIBRARY_PATH ?
11:31:16 <c_wraith> Oh, that's worth checking.  You do need to make sure subshells get it
11:31:26 <L3v1> yes, i did.
11:31:33 <nphg|laptop> bummer
11:32:53 <vanadium> Did you do it before calling configure?
11:32:59 <L3v1> yes.
11:33:18 <L3v1> configure calls ghc-pwd, which need the libgmp.so
11:35:59 <nphg|laptop> try LDFLAGS="-L/home/levi/local/lib"
11:36:51 <L3v1> by using google, i found the ghc ticket 957. that looks alike my problem. but, i tried the XXFLAGS, it does not work.
11:42:24 <L3v1> i also 'find | grep' all .mk, there are two var GMP_LIB_DIRS and GMP_INCLUDE_DIRS, both set in mk/config.mk (automaked correctly) and libraries/integer-gmp/gmp/config.mk (not automaked, empty value).
11:43:37 <L3v1> after modify the config.mk in lib integer-gmp to satisfy my config, it still not work.
11:44:05 <lodi> Hey all.  Quick question about monad transformer stacks:  assuming the semantics are the same either way, are there any efficiency gains to be had from reordering monad transformers?  Seems like >>= has to traverse through all layers, so I have to pay for the full monad stack regardless of which operations I use.
11:44:10 <L3v1> that's all what i did.
11:44:56 <c_wraith> lodi: operations in the transformer layers don't have to go down all the way.  So optimize based on what layer's operations you expect to use most.
11:49:04 <stelleg> @hoogle Bool -> Bool -> Bool
11:49:04 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
11:49:05 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
11:49:05 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
11:49:41 <stelleg> @hoogle Eq a => a -> a -> Bool
11:49:41 <lambdabot> Prelude (/=) :: Eq a => a -> a -> Bool
11:49:42 <lambdabot> Prelude (==) :: Eq a => a -> a -> Bool
11:49:42 <lambdabot> Data.Eq (/=) :: Eq a => a -> a -> Bool
11:51:51 * copumpkin yawns
11:52:33 * Phyx- pokes copumpkin with a stick
11:53:05 <lodi> c_wraith: so in the definition of StateT:  m >>= k  = StateT $ \s -> do          ~(a, s') <- runStateT m s          runStateT (k a) s'
11:53:39 <c_wraith> lodi:  I mean things that operate purely on the transformer level, like get and put, in the case of StateT
11:53:49 <c_wraith> Those operations never look into the underlying monad.
11:53:56 <lodi> (sorry for the formatting)... doesn't the first runStateT line end up recursing down through the inner monads?
11:55:09 <benmachine> the -cafe thread about monads suggests there are some seriously misguided tutorials going around
11:55:24 <benmachine> we should ask confused people to name and shame their tutors
11:55:37 <monochrom> it is hopeless
11:55:54 <lodi> c_wraith: right... ok so if I optimize the order I can get away with less lifting during the ordinary operations, but the >>= operations get slower with every transformer I add to the stack right? 
11:55:57 <c_wraith> I disagree with that thread, kind of.  I don't think monads are hard.  I just think you need to have a sufficient base of experience before they make sense to you.
11:56:03 <c_wraith> lodi: yes
11:56:46 <c_wraith> Which means there is no magical monad explanation possible.  All that you can do is use them until they make sense.
11:57:19 <monochrom> it's like numbers. there is no "tutorial" on numbers. you just get used to it.
11:57:20 <Philippa_> that's why I prefer the distinctly unmagical one that keeps getting bastardised as 'computations'
11:57:23 <benmachine> c_wraith: I think the hard thing about monads for people in that thread seems to be unlearning all the total nonsense someone's told them
11:58:00 <EvanR-work> "programmable semicolon" lol
11:58:05 <benmachine> for my own part, I'm cautious because I know that things can look much easier to understand when you already understand them
11:58:15 <Veinor> monads are programmable burritos!
11:58:27 <EvanR-work> "programmable burritos"
11:58:28 <c_wraith> mm, burritos.  lunch time.
11:58:29 <roconnor> what's wrong with programmable semicolons?
11:59:16 <monochrom> I like programmable semicolons
11:59:32 <monochrom> now I want programmable open-parentheses too
11:59:47 <Veinor> $
11:59:57 <Veinor> I want programmable whitespace!
12:00:15 <monochrom> $ is just programmable money
12:00:16 <roconnor> monochrom: applicative
12:00:34 <EvanR-work> @src Applicative
12:00:34 <lambdabot> class Functor f => Applicative f where
12:00:34 <lambdabot>     pure  :: a -> f a
12:00:34 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:00:51 <benmachine> you can get quasiquoters that do idiom brackets for you
12:02:11 <roconnor> Actaully maybe applicative is more like programable whitespace that Veinor wants
12:03:03 <EvanR-work> today a troll told me haskell is usable because Monad Applicative and Functor are set up in an ideal manner
12:03:09 <EvanR-work> among other non reasons
12:03:13 <EvanR-work> s/are/arent/
12:03:18 <roconnor> oh whew
12:03:22 <roconnor> I was going to say
12:03:24 <roconnor> :)
12:03:37 <roconnor> er
12:03:52 <roconnor> EvanR-work: s/usable/unusable?
12:04:03 <EvanR-work> yes
12:04:05 <EvanR-work> got dammit
12:04:10 <roconnor> :D
12:04:14 * EvanR-work bans himself from irc
12:04:26 <roconnor> I read it as unusable
12:04:33 <roconnor> I have predictive correction
12:04:43 <EvanR-work> yeah
12:04:55 <EvanR-work> our channel has error correcting codes
12:06:04 <Veinor> EvanR-work: you mean the fact that Monad doesn't require Functor and such?
12:06:21 <anupam> I'm facing a strange problem with types
12:06:35 <anupam> n s1 s2 = do
12:06:35 <anupam> s1' <- s1
12:06:36 <anupam> s2' <- s2
12:06:36 <anupam> return (s1' == s2')
12:06:36 <anupam> m a b = n [12] [13]
12:07:03 <benmachine> anupam: usually if you want to show us more than 3 lines of code, it's a good idea to use a pastebin
12:07:14 <benmachine> it avoids spamming the channel *and* it avoids your stuff getting lost
12:07:24 <EvanR-work> Veinor: i dont know exactly, but it seems theres some redundancy in those classes
12:07:27 <benmachine> see: hpaste.org
12:07:38 <sproingie> trolls don't usually go around saying things are usable
12:07:42 <anupam> ah okay thanks will paste and then get back
12:07:46 <acowley> Does anyone know how to make a FunPtr of a Haskell function to use a Finalizer such that the allocated FunPtr doesn't leak? Or do I really need to use a function pointer from a C file?
12:08:36 <acowley> I really want to register my own IO action as a finalizer, but the need for a FunPtr is raining on the parade.
12:08:42 <roconnor> this paper on levitation has a neat idea of using the typechecking phase to desugar syntax
12:10:38 <anupam> I pasted my small exmaple code here - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28405#a28405
12:11:12 <anupam> As you can see the generalisation of Eq typeclass is lost
12:11:40 <roconnor> anupam: what is the type of m?
12:11:47 <anupam> by simply evaluating the function m, without even using the result
12:12:05 <anupam> (Num t) => t -> t -> [Bool]
12:12:35 <anupam> in the second case
12:12:41 <anupam> and m :: t -> t1 -> [Bool] in the first case
12:12:50 <roconnor> anupam: oh I think this may be an instance of the fact that polymorphic recursive type inference is undecidable
12:13:11 <roconnor> anupam: you have to give the type of n by an annotation.
12:13:24 <lodi> anupam: isnt' this because m constrains the types?
12:14:57 <anupam> lodj: actually I guess the addition of monad complicates the types
12:14:59 <lodi> Num already has to be 'Eq', so it's redundant
12:15:01 <roconnor> lodi: m ignores it's parameters, so it doesn't really constrain it.
12:15:09 <anupam> let me come up with a simpler example
12:15:31 <roconnor> anupam: type inference doesn't always produce the most general type for recursive functions.
12:15:40 <anupam> roconner: adding this type annotation n :: (Eq a, Monad m) => m a -> m a -> m Bool causes an error
12:15:54 <roconnor> anupam: what error?
12:16:06 <stelleg> @hoogle Eq a => a -> [a] -> Bool
12:16:07 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
12:16:07 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
12:16:07 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
12:16:09 <roconnor> ah yes
12:16:13 <roconnor> lodi was right
12:16:15 <anupam>  Couldn't match expected type `m' against inferred type `[]'
12:16:16 <anupam>     In the expression: n [12] [13]
12:16:16 <anupam>     In the definition of `m': m a b = n [12] [13]
12:16:39 <anupam> yup looks like it
12:16:44 <roconnor> lodi: m returns a list.
12:16:57 <roconnor> lodi: so n must be working in the list monad
12:16:57 <anupam> but I'm sure my original (larger) code example does not have the same problem
12:17:07 <lodi> m ignores its arguments, but in the definition of n, it unifies the arguments of m with 'Num'
12:18:06 <roconnor> anupam: what happens when you give n the type (Eq t) -> [t] -> [t] -> [t]  ?
12:18:19 <roconnor> *(Eq t) =>
12:18:55 <conal> lodi: hi.  what's your nick about?  i grew up in lodi, california.
12:19:24 <anupam> hmm big error
12:19:36 <roconnor> er
12:19:44 <anupam> Couldn't match expected type `t' against inferred type `Bool'
12:19:45 <roconnor> shoudl be (Eq t) => [t] -> [t] -> [Bool]
12:19:46 <roconnor> sorry
12:20:23 <anupam> oh that works!
12:20:34 <anupam> n :: (Eq t) => [t] -> [t] -> [Bool]
12:20:43 <roconnor> okay so lodi and I were both right
12:20:47 <anupam> I'm not sure I understand why but it works
12:20:57 <roconnor> m is constraining the monad to be the list monad
12:21:16 <lodi> conal: actually it's my surname..  I've always wanted to visit the city sometime though :-)
12:21:18 <roconnor> but the lack of polymorphic recursive type inference failed to give n it's most general type
12:21:30 <roconnor> s/it's/its
12:21:45 <conal> lodi: ah!  i've never run into that surname. :)
12:21:56 <roconnor> anupam: wheren't you expecting n to use the Eq constraint?
12:22:10 <anupam> roconnor: so how does changing m into [] resolve the problem with recursive type inference?
12:22:23 <anupam> I was
12:22:28 <anupam> that's what I wanted
12:22:35 <anupam> instead of it using a Num instance
12:23:43 <lodi> conal: it's a popular italian name I've heard.  I'm russian though!
12:24:28 <conal> hm!
12:25:04 * Philippa_ ran into an interesting misconception re variable names from a friend trying tryhaskell
12:25:31 <Philippa_> she expected abc to be related in some manner to a,b and c
12:25:52 <Philippa_> (this sort of makes sense if someone's last sight of variables was doing algebra at school where variables're single letter names)
12:27:08 <EvanR-work> abc is shorthand for a * b * c
12:27:14 <roconnor> anupam: changign m to [] doesn't have anything really to do with recursive type inference.
12:27:32 <roconnor> anupam: the fact is that your m function returns a list and n calls m.
12:28:15 <roconnor> Philippa_: is there a variable named "abc" there?
12:28:40 <Philippa_> EvanR: for some value of *, yeah
12:28:54 <Philippa_> roconnor: there's one of the quizzes has you dealing with the pattern abc@(a,b,c)
12:29:01 <roconnor> ah
12:29:02 <roconnor> tricky
12:29:09 <Philippa_> as it happens abc /does/ have something to do with a, b and c, but only structurally
12:29:29 <roconnor> Philippa_: I take it your friend has no programming experince.  Is try haskell suitable for such a person?
12:29:34 <Philippa_> so yeah, spelling out somewhere how tokenisation for variables works isn't screwy
12:29:50 <roconnor> (obviously having no prior programing experience gives a head start for learning haskell overall)
12:29:58 <Philippa_> roconnor: she's actually done a little python but something hadn't quite clicked for some reason. She's been having fun with the try bits but failing all the quizzes first time
12:30:32 <sproingie> abc@(a,b,c) is really contrived.  is that supposed to be a tutorial?
12:30:39 <Philippa_> it's a quiz question
12:30:57 <lodi> anupam: n calls m, which is just n with the monad fixed to List and value fixed to Num... that gets unified with s1' and s2', then s1 and s2, which gives the whole expression that Num constraint
12:30:58 <Igloo> It's not that contrived
12:31:10 <Philippa_> yeah, I might call abc that given that tuple match
12:31:17 <sproingie> have a lot of structures called "abc" do you?
12:31:20 <Philippa_> and I do commonly do the equivalent with other constructors
12:31:34 <sproingie> if it's a tutorial, maybe color@(r,g,b)
12:31:46 <roconnor> sproingie: sounds like a good suggestion
12:32:04 <Igloo> If I had a tuple (a,b,c) that I wanted to name, I might call it abc (unless there's a better name for it, such as colour as you say)
12:32:43 <sproingie> that dovetails nicely into other topics like color@(h,s,v) and point@(x,y,z) and now let's do structures because tuples only go so far
12:33:06 <Philippa_> well, the quiz might be intending to test exactly that detail re @-patterns, but spelling out that variables work how they do and aren't any different to built-in functions is a good code-newbie thing
12:33:39 <sproingie> a quiz question you can probably make more contrived
12:34:53 <Philippa_> yeah, and it was one
12:37:57 <Philippa_> step 9 would be the place to explain that variables can be multi-char
12:38:42 <ag> please, somebody can explain how this works:zipWith ($) (cycle [f,id]) -- this is from RWH
12:39:11 <aristid> :t zipWith ($) (cycle [f,id])
12:39:12 <lambdabot> forall b. (Show b, SimpleReflect.FromExpr b) => [b] -> [b]
12:39:18 <aristid> :t \f -> zipWith ($) (cycle [f,id])
12:39:20 <lambdabot> forall b. (b -> b) -> [b] -> [b]
12:39:52 <ClaudiusMaximus> > zipWith ($) (cycle [f, id]) [a,b,c] [x,y,z]
12:39:52 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr] -> t'
12:39:53 <lambdabot>         against in...
12:39:58 <ClaudiusMaximus> oops
12:40:01 <ClaudiusMaximus> > zipWith ($) (cycle [f, id]) [a,b,c] 
12:40:02 <lambdabot>   [f a,b,f c]
12:40:08 <roconnor> ag: zipWith ($) takes a list of functions and a list of input and produces a list of outputs by applying the functions to the inputs pointwise
12:40:28 <roconnor> cylce [f,id] is a list of functions
12:40:46 * hackagebot monad-loops 0.3.1.1 - Monadic loops  http://hackage.haskell.org/package/monad-loops-0.3.1.1 (JamesCook)
12:41:19 <aristid> ag: what is this function used for?
12:41:20 <ag> Wow, thanks people
12:42:11 <roconnor> zipWith id would do the same with more confusing syntax ;)
12:42:34 <roconnor> > succ `id` 8
12:42:35 <lambdabot>   9
12:43:07 <ag> mapEveryOther f = zipWith ($) (cycle [f,id]) -- part of BarCode in ch.12 of RWH
12:43:24 <anupam> roconnor: I have reduced my code to the smallest case which reproduces the problem - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28406#a28406
12:43:51 <anupam> it's a simple state machine sort of a thing
12:43:51 <lodi> c_wraith:  I think I just got why there's a 'RWS' monad.  By defining a complicated single monad with all effects built in, you get a relatively efficient bind, and you don't have to pay for effects you don't use, right?
12:43:57 <anupam> but doesn't type compile
12:44:22 <roconnor> lodi: oh yes, in my experience making a custom monad is always faster
12:44:22 <c_wraith> lodi: pretty much.  Though you really shouldn't use RWS if you only need two of the three.
12:44:47 <roconnor> lodi: I use MTL stacks mostly for prototyping
12:45:04 <Phyx-> oh man, this feels so dirty, hahahh
12:45:06 * copumpkin_ pledges to always use fmap for function composition, id for application, and return for const from now on
12:45:38 <Phyx-> using reflection to modify a private member by using reflection to invoke a private method of that private member
12:45:42 <roconnor> anupam: what's the error?
12:45:54 <ClaudiusMaximus> i have a problem with too much sharing in nested list comprehensions, any ideas?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28407#a28407
12:46:04 <anupam> Contexts differ in length
12:46:05 <anupam>       (Use -XRelaxedPolyRec to allow this)
12:46:05 <anupam>     When matching the contexts of the signatures for
12:46:05 <anupam>       d_test :: forall b.
12:46:05 <anupam>                 (Eq b) =>
12:46:05 <anupam>                 b -> b -> DecisionState -> DecisionState -> ()
12:46:07 <anupam>       d :: DecisionState -> ()
12:46:16 <c_wraith> Wait, too much sharing is a problem?
12:46:22 <lodi> right.  Okay that's good news!  I actually have a monad stack that's about 4 levels deep now.  I was just thinking of potential improvements for later on...
12:46:24 <roconnor> ClaudiusMaximus: genreally sharing can be defeated by duplicating code using let statements
12:46:24 <anupam> it seems to want to unify Num and Bool
12:46:36 <ClaudiusMaximus> c_wraith: i'd rather recompute than use lots of memory
12:46:47 <c_wraith> Ah, ok
12:47:03 <ClaudiusMaximus> roconnor: right, not sure where to do that here
12:47:49 <roconnor> anupam: wow, I've never seen this error before
12:47:51 <edwardk> preflex: xseen ddarius
12:47:51 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
12:47:52 <preflex>  ddarius was last seen on freenode/#haskell 21 hours, 36 minutes and 55 seconds ago, saying: napping: I think you can.
12:48:15 <anupam> roconnor: yeah me neither
12:48:31 <copumpkin_> omg it's edwardk 
12:48:31 <edwardk> heya copumpkin_ welcome back to the internet, how was the trip?
12:48:54 <anupam> I tried reading the ghc docs on that error but managed to understand nothing
12:49:01 <edwardk> copumpkin_: if you're in the area, ddarius will be up for a few days
12:49:02 <copumpkin_> edwardk: very good! I messed up my arm at the end of the trip, but otherwise had loads of fun :P
12:49:02 <lodi> c_wraith, roconnor: okay thanks guys, that clears up a bunch of things
12:49:11 <copumpkin_> edwardk: dammit, I'm in rome now :(
12:49:19 * copumpkin_ wants to meet ddarius 
12:49:20 <edwardk> copumpkin_: hah, fair enough
12:49:46 <edwardk> copumpkin_: you likely to make i back towards boston in the next year or two? :0
12:50:00 <copumpkin_> I sort of hope so
12:50:06 <copumpkin_> really don't know what I'm doing for now though
12:50:41 <edwardk> find a nice phd program where they know what haskell _IS_ ;)
12:50:59 <copumpkin_> hah
12:51:09 <copumpkin_> nah, taking a break from academia :P
12:51:35 <benmachine> or hey if they didn't, maybe then you could write a phd paper about how amazing this new language was :P
12:52:22 <jmcarthur> i'm considering joining ipwn
12:52:26 <copumpkin_> lol
12:52:33 <copumpkin_> they teach it for undergrad
12:52:34 <edwardk> copumpkin_: fair enough. i look forward to your new work on higher order abstract dry-wall installation ;)
12:52:38 <copumpkin_> just that nobody uses it beyond that
12:52:49 <Apocalisp> My company is hiring in Boston
12:52:49 <copumpkin_> edwardk: lol, I hope it isn't that bad :P
12:52:58 <Nibble> I think I know what caused the error
12:52:59 <jmcarthur> Apocalisp: what does your company do?
12:53:11 <Nibble> some packages was not installed that HTTP required
12:53:15 <Nibble> but HTTP was installed
12:53:18 <Nibble> fail packaging
12:53:32 <Nibble> like mtl, network
12:53:33 <Nibble> etc
12:53:34 <Apocalisp> jmcarthur: Software for quantitavite analysis of investment strategies
12:53:38 <edwardk> they do cool stuff with finance in scala
12:53:45 <copumpkin_> edwardk: I'm doing an agda-flavored repa right now and proving stuff about it :P loads of fun, and the world's ugliest proofs
12:53:52 <jmcarthur> ah, quant
12:53:55 <copumpkin_> is that the same company that paul chiusano works for?
12:54:04 <Apocalisp> copumpkin_: Yes, the same one
12:54:07 <roconnor> ArchGT:
12:54:08 <copumpkin_> aha
12:54:10 <edwardk> copumpkin_: yeah
12:54:18 <roconnor> anupam: wow, Haskell is retarded!
12:54:28 <MHD0> What is that extension called that lets you capture constructors as variables in pattern matching?
12:54:31 <lambdabot> MHD0: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:33 <ArchGT> roconnor: ?
12:54:37 <roconnor> anupam: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28406#a28408 <-- this is a Haskell 98 work around
12:54:37 <copumpkin_> @remember roconnor wow, Haskell is retarded
12:54:37 <lambdabot> Nice!
12:54:41 <Apocalisp> We're writing a typed relational programming language with edwardk's help :)
12:54:48 <copumpkin_> :O
12:54:54 <roconnor> ArchGT: sorry, tab completion error picked your name :(
12:55:03 <ArchGT> oh
12:55:05 <ArchGT> ok
12:55:06 <edwardk> copumpkin: its sexy!
12:55:12 <Apocalisp> super-sexy
12:55:14 <copumpkin> is it public yet?
12:55:26 <jmcarthur> okay i'm convinced that i want to apply methinks
12:55:40 <roconnor> anupam: I would take your error to Haskell-cafe to get more opinions from smarter people
12:55:43 <copumpkin> I'd like to too
12:55:52 <copumpkin> but I need to fix my arm first
12:55:54 <edwardk> copumpkin: no, that what makes it an effective recruiting tool. you'd need to come work for them to see it ;)
12:55:56 <copumpkin> MRI on tuesday
12:56:00 <edwardk> copumpkin: what'd you do to your arm?
12:56:01 <copumpkin> lol
12:56:02 <jmcarthur> ew
12:56:14 <copumpkin> edwardk: probably torn rotator cuff
12:56:22 <copumpkin> really uncomfortable
12:56:38 <edwardk> nice. did much the same thing to my right shoulder a month or two back. its slowly healing up
12:56:47 <anupam> roconnor: wow! atleast the code you suppiled will let me live until I get a better answer :) Thanks!
12:57:16 <roconnor> anupam: I would just enable the required extentions
12:57:20 <roconnor> extension
12:57:34 <copumpkin> edwardk: was it painful? cause mine wasn't at first and then got unbearable and now is a bit better
12:57:36 <roconnor> rather than adding that pile of crap I defined.
12:57:42 <ray> i tore my reflector and translator cuffs
12:57:59 * copumpkin punches ray
12:58:12 <anupam> roconnor: oh actually I wasn't sure if the extension suggestion ghc made was correct
12:58:24 <anupam> I assumed that GHC was just really confused at this point!
12:58:31 <edwardk> copumpkin: thats basically how mine went, i was putting up weight at the gym and it flexed funny, and i just worked through it. then a few days later it hurt like hell
12:58:32 <anupam> I'll try the extension
12:58:53 <copumpkin> yeah :/ was in budapest and couldn't lie down or sleep for a few days
12:59:02 <edwardk> copumpkin: i wound up developing tendonitis in my opposite arm just beforehand, so i'm not able to do more or less anything at the gym these days =(
12:59:08 <copumpkin> wow
12:59:11 <copumpkin> that sucks
12:59:17 <roconnor> anupam: still, bring it to the problem to -cafe.  It seems like a bug in the H98 standard.
12:59:22 <roconnor> or a bug in GHC
12:59:51 <edwardk> the rotator cuff seems to be getting better, but the tendonitis will probably require surgery =/
13:00:37 <anupam> roconnor: the extension worked! I'll put it up on haskell-cafe as well
13:00:46 <edwardk> otoh, not being able to sleep has led to me getting a lot of haskell written lately ;)
13:01:03 <copumpkin> lol
13:01:12 <roconnor> I'm trying to find the specificaiton of this behaviour in H98
13:03:03 <edwardk> roconnor: you can do a little better if you wanted to make an empty 'data Proxy b' or the '98 equivalent: newtype Proxy b = Proxy (Proxy b) -- to avoid passing around undefineds
13:03:36 <roconnor> true
13:03:56 <roconnor> But really, the original code should have type checked
13:04:11 <roconnor> IMHO
13:04:22 * roconnor thinks about it
13:04:53 * hackagebot type-level-natural-number 1.0 - Simple, Haskell 2010-compatible type level natural numbers  http://hackage.haskell.org/package/type-level-natural-number-1.0 (GregoryCrosswhite)
13:04:53 <roconnor> is there some dictionary passing issue going on here?
13:05:09 <roconnor> no, it's fine
13:05:26 <roconnor> d statically can pass the needed dictionary to d_test
13:05:43 <roconnor> and d doesn't need any dictionary to be passed from d_test.
13:05:55 <roconnor> it should have type checked
13:06:16 * monochrom tries to invent "type-level-haskell98" - write haskell98 programs --- at the type level!
13:06:23 <edwardk> roconnor: circular definitions don't always get the most general signature. the issue can be fairly subtle, but i don't see at first glance how that would happen here
13:06:47 <edwardk> monochrom: the lack of kind polymorphism makes that task rather hellish. ;)
13:07:03 <Philippa_> it's only polymorphic recursion that doesn't always generalise properly
13:07:12 <edwardk> you wind up having to use an explicit type level ap combinator, type level type checking, type level kind checking, etc.
13:07:38 <edwardk> Philippa_: true
13:07:48 <roconnor> edwardk: it isn't a type inference problem.  d and d_test are fully annotated
13:07:59 <Philippa_> though I've managed to accidentally introduce it without realising before (via a screwed up type synonym)
13:08:04 <edwardk> roconnor: hence why i couldn't see how it applied ;)
13:08:07 <roconnor> :)
13:08:40 <ClaudiusMaximus> i fixed the space leak by adding "... + b - b" to force recomputation...
13:08:44 <ClaudiusMaximus> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28407#a28409
13:08:58 <edwardk> it is somewhat problematic because it needs to use defaulting
13:09:19 <roconnor> here is a similar retarded error but at least the workaround isn't onerous --> http://www.mail-archive.com/haskell@haskell.org/msg22546.html
13:09:40 <roconnor> http://www.mail-archive.com/haskell@haskell.org/msg22545.html <-- acutally here
13:10:12 <roconnor> basically it is a got "(Num a, Show a) =>" but expected "(Show a, Num a) =>" error.
13:10:13 <edwardk> roconnor: or here http://www.mail-archive.com/haskell@haskell.org/msg22547.html
13:10:32 <roconnor> ah finally a link to the report
13:11:43 <edwardk> hrmm i should have caught that. i was just reading through that section while hacking on a toy compiler
13:11:46 <roconnor> anupam: I found a simpler solution
13:11:51 <roconnor> anupam: remove the signature for d
13:12:38 <roconnor> Haskell: sometimes your type system makes me want to strangle you.
13:12:54 <edwardk> roconnor: only when dealing with mutual recursion =P
13:13:03 <roconnor> anupam: and still report your example to -cafe
13:13:12 <anupam> roconnor:  oh that makes no sense but it works
13:13:23 <anupam> will do that
13:13:47 <roconnor> anupam: the most retarded thing is that ghci reports the exact type signature that you aren't allowed to write in your code.
13:14:07 <anupam> yup! that's insane
13:14:56 <roconnor> It must be a bug in the H98 report
13:15:04 <roconnor> someone needs to fix it for Haskell Prime
13:15:36 <roconnor> Here is the retarded specification ``If the programmer supplies explicit type signatures for more than one variable in a declaration group, the contexts of these signatures must be identical up to renaming of the type variables.
13:16:31 <MHD0> I've been working around with some Logic monad and trying to solve einsteins riddle, but even if I structurally copy the code from prolog, it's still slow as hell. Can anybody give me some tips and tricks with Logic?
13:16:35 <napping> and sets of constraints are not considered identical?
13:16:38 <roconnor> anupam: thanks for introducing me to a new dark corner of the Haskell 98 report
13:17:03 <roconnor> napping: GHC inteprets this has they have to literally be in the same order
13:17:20 <napping> I was not aware that contexts could be taken as lists
13:17:35 <roconnor> napping: I don't know of any other case where order matters
13:17:49 <napping> I'm thinking of the HM(X) presentation
13:17:55 <roconnor> but anupam's problem isn't even with order
13:18:01 <Wolfspaw> how can i do that: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28410#a28410 ?
13:18:09 <napping> oh, the contexts just change a bit?
13:18:22 <roconnor> he is required to have the same context in a declaration, but since there is no type variable to contrain he isn't allowed to write it.
13:18:34 <napping> hmm
13:19:46 <kmc> Wolfspaw, you need a function of type String -> [Int] which breaks up a string into a list of digits
13:19:52 <kmc> since a string is already a list of chars, you can use map
13:19:54 <napping> Was an example pasted?
13:20:00 <Heffalump> roconnor: wouldn't it require a (potentially) expensive search to match them up?
13:20:04 <kmc> > map read "123456" :: [Int]
13:20:05 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:20:05 <lambdabot>         against inferred ty...
13:20:17 <Heffalump> In practice it probably wouldn't matter, though.
13:20:21 <kmc> > map (read . pure) "123456" :: [Int]
13:20:23 <lambdabot>   [1,2,3,4,5,6]
13:20:23 <napping> I'm having trouble thinking of a case where you end up with a constraint on a type not mentioned in the signature
13:20:35 <kmc> in this case, pure :: a -> [a]; pure x = [x]
13:20:40 <roconnor> n log n isn't so expensive
13:20:44 <kmc> it's from Control.Applicative
13:20:45 <napping> how could callers be compiled to pass the right dictionary?
13:21:16 <Wolfspaw> kmc: hm, ok. Thanks, i'll try! (i am also confused with the '<-' syntax. the way im using it is right?)
13:21:18 <roconnor> napping:  ``If the programmer supplies explicit type signatures for more than one variable in a declaration group, the contexts of these signatures must be identical up to renaming of the type variables.
13:21:44 <napping> Yes, and those constraint sets are identical up to renaming
13:22:03 <roconnor> napping: but if one function in the declairation group doesn't use the type variable
13:22:06 <kmc> Wolfspaw, it is.  you use "<-" to run an IO action and get the result
13:22:07 <napping> I don't see that the specification *requires* this behavior
13:22:14 <napping> ah, so that's how it goes
13:22:16 <kmc> whereas to just do some computation, without IO, you'd use "let"
13:22:16 <Wolfspaw> kmc: ok, thanks!
13:22:22 <kmc> let xdigs = map (read . pure) x
13:22:23 <napping> one function doesn't mention it at all, hmm
13:22:32 <napping> but, how does it call other functions from the group?
13:22:38 <roconnor> napping: but it is still required to use the same context (if it is declared)
13:22:57 <roconnor> napping: by using explicit constants of a staticly know type
13:22:59 <napping> only calls them at a particular instantiation?
13:23:03 <roconnor> yes
13:23:22 <napping> hmm, that is tricky
13:23:30 <napping> what's the point of the restriction anyway?
13:23:45 <napping> I thought GHC allowed arbitrary mutual recursion if all signatures were provided
13:24:19 <napping> anyway, I'm having a bit of trouble with ReadP
13:24:23 <roconnor> napping: I don't know. If all the signatures are given, there should be no type inference problem.  It would just be typechecking.
13:24:41 <napping> is there something like <++ which prefers the left results, but is permitted to backtrack if the overall parse would otherwise fail?
13:24:49 <roconnor> napping: I guess if more than one but not all signatures are given, things could get hairy
13:25:32 <napping> I would hope that would serve to cut edges
13:26:11 <napping> well, something to bring up for H2011, I guess
13:26:46 <Wolfspaw> i get a parse error in '<-' with :  euler9 = x <- readFile "listOfDigits.txt" 
13:26:49 <Wolfspaw> why? @.@
13:27:21 <roconnor> <- is only valid syntax in a do block
13:27:29 <Wolfspaw> hm, ok
13:27:36 <Wolfspaw> thanks!
13:29:16 <napping> ah, http://hackage.haskell.org/trac/haskell-prime/wiki/RelaxedDependencyAnalysis
13:29:46 <napping> anupam: are you compiling with that extension?
13:30:12 <anupam> napping: yes
13:30:15 <roconnor> napping: yes, that fixed his error
13:30:32 <napping> ok, so it's already fixed in 2010
13:31:12 <anupam> napping: I am using 2010
13:31:28 <roconnor> napping: that trac patch doesn't remove the offending final paragraph
13:32:33 <anupam> napping: sorry, atleast I'm using the latest haskell platform
13:35:26 <napping> anupam: I was talking about the new standard, I'm not sure what the new platform does
13:35:48 <Nibble> Guys, I finally got cabal working
13:35:49 <Nibble> pew
13:35:55 <napping> pew pew
13:36:11 <copumpkin> pew pew pew
13:36:23 <napping> cabal install monadius
13:41:09 * hackagebot hoopl 3.8.6.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.8.6.0 (NormanRamsey)
13:43:03 <chrisdone> > "at" ++ replicate 30 'a' ++ "ck of the killer tomatoes"
13:43:04 <lambdabot>   "ataaaaaaaaaaaaaaaaaaaaaaaaaaaaaack of the killer tomatoes"
13:43:13 <chrisdone> what's everyone up to?
13:43:39 <roconnor> chrisdone: I'm reading the art of levitation.
13:43:46 <monochrom> I am up to yet another "load module, get value, at runtime" lib
13:44:08 <krey__> can someone help me with the continuation monad + callCC?
13:44:11 <chrisdone> monochrom: hsplugins/hint type of thing?
13:44:18 <chrisdone> krey__: sure
13:44:49 <monochrom> oh so how would you use such a lib? do you "load one module, get one value, that's it for that module for a while"? or do you "load 10 modules, get 15 values" at once?
13:45:22 <krey__> chrisdone: so, I'm trying to understand how it works, I'm reading an introduction on it: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style but it's not really helping
13:45:54 <chrisdone> monochrom: hm, not following. I must've missed some conversation
13:46:01 <krey__> chrisdone: do you have any material / examples that would help me understand the definition and the usage of the monad?
13:46:06 <monochrom> my callCC examples are at http://www.vex.net/~trebla/haskell/cont-monad.xhtml
13:46:28 <chrisdone> krey__: so do you understand CPS?
13:46:58 <krey__> chrisdone: I think so
13:46:59 <napping> monochrom: both sound useful. The latter sounds more like the sort of thing a server of WM or something might use for a plugin/live upgrade system
13:47:26 <krey__> chrisdone: I've rewritten most of the list functions in CPS as an exercise
13:47:40 <napping> and the former perhaps handy in writing code. Ocassionally I have some test that uses biggish and expensive data
13:47:57 <napping> It would be nice to be able to keep that in memory, and reload the module I want to test on it as I edit
13:48:40 <monochrom> OK, sounds like everyone loves "reload" :)
13:51:13 <chrisdone> krey__: so in CPS we pass the continuation around explicitly when applying functions
13:51:35 <chrisdone> > let add x y = \f -> x + y in add 10 5 id
13:51:36 <lambdabot>   15
13:52:08 <chrisdone> krey__: but this is kind of inconvenient because most of the time we don't need to use the continuation
13:52:39 <chrisdone> krey__: so the continuation monad does the plumbing for us by implicitly creating continuations when we use (>>=)
13:53:04 <chrisdone> krey__: and so when we *do* finally want to use the current continuation, we use callC to get it
13:53:10 <chrisdone> krey__: follow all that right?
13:53:24 <krey__> chrisdone: yep
13:53:45 <krey__> chrisdone: well, not sure about the callCC bit...
13:54:26 <chrisdone> krey__: which part of it?
13:54:29 <ezyang> krey__: callCC's continuation does two things: ignores the implicit continuation and then uses its continuation. 
13:54:47 <monochrom> perhaps it just takes time
13:55:20 <Phyx-> hmmm why is there a lookup but no update for associated lists
13:56:09 <krey__> chrisdone, ezyang: I've never actually used any of this, how can we have more than one continuation?
13:56:13 * hackagebot zmidi-core 0.1.0 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.1.0 (StephenTetley)
13:56:35 <edwardk> callCC makes sense from the perspective that ultimately, a function of the form (a -> r) -> r can effectively either use the function it is supplied or not, and since it knows the choice of 'r' it may choose to use it multiple times. callCC just exposes that machinery to the function itself
13:56:36 <ezyang> krey__: There is only one future that will happen. 
13:56:41 <Nibble> @src []
13:56:42 <lambdabot> data [] a = [] | a : [a]
13:56:45 <ezyang> but there are many possible futures :-) 
13:57:00 <krey__> ezyang: care to illustrate?
13:57:20 <ddarius> edwardk: What have you been up to?
13:57:53 <edwardk> i.e. if you need ti write a function of type (a -> r) -> r, and have a value of type 'a' you can just pass it to the function. if you have a value of type 'r' you can just give it back, and if you know how to combine 'r's you can run the function multiple times, mishmash it in with some other values you have and get a usable result
13:58:11 <edwardk> ddarius: not much really. life got busy for a few days
14:00:20 * copumpkin is playing with the pig!
14:00:27 <BMeph> krey__: Have you ever used a conditional statement (if-statement)? ;)
14:01:11 * copumpkin is in the cochon prompt
14:01:44 <napping> sigh, why don't quasiquoters get passed the final parser?
14:01:45 <ezyang> http://web.mit.edu/~ezyang/Public/cont.png 
14:02:13 * BMeph has a new perspective of Viet Nam  and environs  being called "Cochin"...
14:02:55 <aledge> ezyang did chanson teach 6.945 with gjs?
14:03:01 <aledge> this year?
14:03:03 <copumpkin> ooh look at the purty picture
14:03:27 <ezyang> aledge: No. 
14:03:41 <BMeph> ezyang: Have you ever thought of moonlighting as a music DJ? You already have the perfect handle for it... ;)
14:03:49 <aledge> ezyang: oh. i only ask because your squiggles remind me of his drawings of setjmp when he was explaining call/cc
14:03:54 <ezyang> BMeph: Lolwut? 
14:04:02 <ezyang> aledge: Haha :-) 
14:04:03 <aledge> ezyang: not that it takes a huge leap of creativity to make squiggles :)
14:04:30 <ezyang> I wonder what Chris HAnson is doing these days. 
14:04:44 <aledge> well he left when i was taking it to go to google, but i didn't know if it was permanent or not
14:04:56 * BMeph would pay money for a burned CD of Dance Beats from "DJ EZYang"...
14:05:23 <ezyang> BMeph: Ah, I see :^) 
14:07:04 <ezyang> Fwiw, Alexy Radul helped teach 6.945 the year I took it. 
14:07:14 <aledge> he was the TA when i took it
14:08:43 <copumpkin> oh I met him at one of the haskell groups
14:11:56 <tom7> hi i m thinking of building pc, i want to check if all components are compatible, can someone help? 
14:12:27 <fryguybob> @where compatible
14:12:28 <lambdabot> I know nothing about compatible.
14:12:33 <copumpkin> this isn't the right channel for that, tom7 
14:12:40 <copumpkin> tom7: try #hardware maybe?
14:12:45 <copumpkin> I think that's a channel 
14:12:53 <napping> or search on the specific components you are thinking of
14:13:09 <tom7> i can give you guys my specification
14:13:19 <copumpkin> tom7: no, we are not experts at that
14:13:22 <tom7> pc specs
14:14:10 <roconnor> what is the data type for a free comonad?
14:14:17 <roconnor> given a functor
14:14:20 <copumpkin> tom7: what made you decide to come here? this isn't the right place for that kind of question :)
14:14:32 <copumpkin> roconnor: haven't come across one
14:14:39 <greap> Anyone coming across cabal not being able to read some files? """cabal: Couldn't read cabal file "./HaTeX/1.0.1/HaTeX.cabal"""" I usually just update cabal-install when this happens, but it doesn't seem to be fixing the issue.
14:14:40 <jmcarthur> roconnor: newtype Cofree f a = Cofree (a, f (Cofree f a))
14:14:45 <tom7> you are computer's geeks
14:14:50 <roconnor> jmcarthur: thanks
14:14:59 <tom7> that made me come here
14:15:02 <copumpkin> that's cofree!
14:15:14 <roconnor> it's a comonad!
14:15:17 <Philippa_> tom7: if you knew the community I'd point you at our off-topic chan, but you don't
14:15:19 <jmcarthur> roconnor: you did mean cofree, right?
14:15:20 <copumpkin> tom7: we're software and math geeks, but we don't necessarily know much about hardware :P
14:15:23 <napping> tom7: we're more theoretical. If you wanted to ask about brands of whiteboard markers, perhaps
14:15:28 <roconnor> jmcarthur: sure
14:15:28 <kmc> haha
14:15:42 <kmc> you academics are just out of touch
14:16:05 <Philippa_> I hear if you overclock by a factor of 2 you get some real hot hardware
14:16:15 <jmcarthur> roconnor: the difference between free monads and cofree comonads is just (,) vs. Either
14:16:43 <ddarius> jmcarthur: And mu v. nu.
14:16:46 * geheimdienst also recommends cocoafree cocoamonads
14:16:53 <roconnor> oh right!
14:17:05 <napping> ah, right T a = (a, F (T a))
14:17:08 <roconnor> the comonad is only the fixed point of cofree!
14:17:09 <jmcarthur> ddarius: i am not familiar with that
14:17:37 <Philippa_> jmcarthur: least vs greatest fixpoint
14:17:41 <jmcarthur> ah
14:17:53 <ddarius> jmcarthur: The free monad is the least fixed point, the cofree comonad is the greatest fixed point.  In Haskell, there is no difference, but in something like Agda or Coq there would be a difference.
14:17:55 <roconnor> oh wait
14:18:00 <roconnor> cofree is recursive
14:18:04 <roconnor> ya so it is a comonad
14:18:07 <roconnor> my bad
14:18:25 <jmcarthur> ddarius: interesting. i'll have to look that up some time to fully understand it
14:19:09 <jmcarthur> roconnor: type Cofree f a = Fix ((,) a :. f), if you prefer
14:19:16 <chrisdone> krey__: still struggling?
14:20:42 <napping> jmcarthur: how does the duplicate go?
14:21:06 <ddarius> napping: Follow the types.
14:21:09 <napping> c@(_, u) -> (c, fmap duplicate u)?
14:21:29 <edwardk> napping: yep
14:21:45 <napping> hmm, ok
14:22:59 <krey__> chrisdone: I think I'm missing something fundamental
14:23:11 <napping> krey__: have you used callcc in scheme or something?
14:23:37 <krey__> chrisdone: maybe I should learn to use the monad + when + callCC and then try to understand how it works?
14:23:48 <krey__> napping: nope, would learning scheme help?
14:23:56 <napping> not particularly
14:24:06 <kmc> scheme is simple and beautiful and you should learn it anyway ;P
14:24:19 <napping> but I've found I usually have to define a new datatype if I want to return the continuation out of the scope of the callCC
14:24:20 <ddarius> krey__: I'd recommend learning how to use call/cc in Scheme or SML/NJ or some language where it is a primitive and also looking at the CPS transform in detail.
14:24:26 <roconnor> kmc: isn't scheme just unsafeHaskell?
14:24:34 <kmc> ;P
14:24:50 <kmc> they're very different
14:24:53 <napping> roconnor: well, you can GC a lot of the details
14:25:01 <kmc> scheme is closer to Javascript or Ruby than to Haskell
14:25:03 <napping> and also the macro system is fairly pretty
14:25:26 <napping> PLT's scribble in particular is pretty nifty
14:25:37 <chrisdone> krey__: we can go through it if you like, I'll just ask you questions until you understand it
14:26:18 <ddarius> "You knew everything all along, it was just a matter of you recalling it."
14:26:30 <chrisdone> Socratic Questioning
14:26:46 <krey__> chrisdone: thank you, that would be very much appreciated!
14:26:59 <brong> i am new to haskell, what do you call the <*> function in applicative functor? how do u pronounce it? thanks!
14:27:09 <napping> maybe "ap"
14:27:12 <ddarius> brong: "apply"
14:27:12 <roconnor> ap
14:27:13 <monochrom> @quote monochrom modem
14:27:14 <lambdabot> No quotes match.
14:27:24 <napping> there's a function Control.Monad.ap, which is the same thing on Monad
14:27:27 <ddarius> The monad function ap corresponds to (<*>) when the applicative is a monad.
14:27:38 <monochrom> I miss that one. "Don't try to pronounce operators. You are not a modem."
14:27:41 <roconnor> @src (<*>) WrappedMonad
14:27:42 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:27:43 <brong> ddarius: thank you!
14:27:51 <benmachine> preflex: quote monochrom
14:27:52 <preflex>  <monochrom> Ever since people became atheist, they need replacements for religions. Programming languages fill that hole.
14:27:55 <benmachine> preflex: quote monochrom modem
14:27:55 <preflex>  no quotes found for monochrom modem
14:27:59 <napping> or, you might skip that
14:28:00 <benmachine> hmph
14:28:10 <napping> like, in a parser where it's just composition
14:28:54 <chrisdone> krey__: start from the basics and quickly work up, what is the type of (+)?
14:29:35 <krey__> let's say Int -> Int -> Int for simplicity
14:29:50 <chrisdone> cheeky, but okay
14:29:54 <chrisdone> krey__: let add x y = \f -> f (x + y), what is the type of 'add'?
14:29:57 <CakeProphet> I recently tried to explain lambda expressions to a former C programmer
14:30:01 <CakeProphet> ...took awhile.
14:30:13 <napping> CakeProphet: how did it go?
14:30:18 <ClaudiusMaximus> hooray for really boring heap profile graphs: http://claudiusmaximus.goto10.org/g/hp2pretty/hp2pretty-0.2.png
14:30:21 <napping> closure conversion and extra void* arguments?
14:30:26 <krey__> Int -> Int -> (Int -> r) -> r
14:30:46 <CakeProphet> napping:  well they've been learning Haskell slowly, so they finally caught on. Getting them to accept currying was much more frustrating.
14:30:58 <CakeProphet> but eventually it made sense to them. all the concepts are intuitive, but there are many.
14:31:01 <chrisdone> good
14:31:18 <napping> to be fair, lambdas are a lot harder in an imperative language with stack allocation
14:31:35 <jmcarthur> what? C++0X's lambdas are *awesome*
14:31:37 <jmcarthur> </sarcasm>
14:32:00 <napping> I'd like to see how to do them better
14:32:21 <CakeProphet> well, when I look for success in language design
14:32:23 <CakeProphet> I generally go to Java.
14:32:33 <chrisdone> krey__: and we have: let mult x y f = f (x * y)
14:32:37 <CakeProphet> and the way Java does it... is to scrap the whole idea altogether, and instead have anonymous classes.
14:32:42 <CakeProphet> problem solved!
14:32:47 <monochrom> to do lambdas better in mainstream languages: implement scheme there as a DSL...
14:32:50 <kmc> hahaha
14:32:50 <jmcarthur> CakeProphet: the way Java does it is marketing
14:33:01 <jmcarthur> success!
14:33:35 <chrisdone> krey__: consider:
14:33:35 <chrisdone> > let add x y f = f (x + y) in add 5 6 id
14:33:35 <chrisdone> and
14:33:35 <chrisdone> > let mult x y f = f (x * y) in mult 5 6 id
14:33:36 <lambdabot>   11
14:33:36 <lambdabot>   30
14:33:42 <chrisdone> krey__: now, we need to combine them
14:34:32 <chrisdone> krey__: how do I multiply 4 and 7 and then add 5 to it?
14:34:38 <chrisdone> (using 'mult' and 'add')
14:34:51 <CakeProphet> has anyone noticed, that imperitive/OO languages have just been trying to poorly re-invent functional programming lately?
14:35:14 <ddarius> monochrom: C# does lambdas better than Haskell!
14:35:15 <CakeProphet> with various new features. C++ and Java, mainly.
14:35:19 <kmc> yes, everyone has noticed that CakeProphet
14:35:26 <krey__> mult 4 7 (add 5) id
14:35:27 <hgolden> CakeProphet: anything worth reinventing is worth reinventing poorly.  ;-)
14:35:38 <kmc> but you shouldn't take C++ and Java to be the epitome of imperative or OO languages
14:35:43 <chrisdone> krey__: good stuff
14:35:49 <ddarius> FP is the new OOP.
14:36:02 <CakeProphet> kmc:  I certainly don't. they simply have the biggest sway it seems.
14:36:13 <kmc> i think they're losing the sway a lot
14:36:32 <chrisdone> krey__: so we write mult 5 6 (add 5) (mult 9) [ and so on] id
14:36:36 <CakeProphet> yeah. frankly, I'm amazed Python got anywhere.
14:36:40 <kmc> many people are dumping Java for other, non-shitty JVM languages
14:36:58 <krey__> chrisdone: yep
14:37:03 <kmc> and C++ is definitely seen as archaic by almost everyone
14:37:13 <kmc> although still used for high-performance and realtime stuff
14:37:15 <CakeProphet> I've be interested in porting Jython to Dalvik so I could program on Android in Python.
14:37:30 <CakeProphet> *I'd
14:37:33 <kmc> you should program in Haskell on Android
14:37:44 <chrisdone> krey__: now consider: str x f = f (show x)
14:37:45 <dkirk> it's more fun programming Android with Scala
14:37:48 <CakeProphet> ...well, that would require compilation to Dalvik vm
14:37:51 <kmc> CakeProphet, nope
14:37:55 <kmc> Android supports native code 
14:38:01 <Philippa_> it's worth remembering that OO used to be closer to (impure) FP
14:38:01 <CakeProphet> not for apps though...
14:38:04 <kmc> yes it does
14:38:14 <CakeProphet> ...oh. well, okay. o_o
14:38:16 <CakeProphet> I didn't know that.
14:38:26 <kmc> not for a *whole* app, but an app can have a native-code library
14:38:27 <CakeProphet> I thought it was almost exclusively Java running on Dalvik
14:38:28 <chrisdone> krey__: watch the types:
14:38:30 <chrisdone> :t let mult x y f = f (x * y) in mult 5 6
14:38:30 <chrisdone> :t let mult x y f = f (x * y); str x f = f (show x) in mult 5 6 str
14:38:31 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
14:38:31 <lambdabot> forall t. (String -> t) -> t
14:38:43 <napping> I think it's still an open question how to do nice lambdas in a systems programming language, like with explicit stack allocation and specified value layouts and so on
14:38:44 <chrisdone> krey__: do you see a pattern?
14:39:00 <napping> or for that matter, to make such a language memory-safe by using a type system
14:39:14 <CakeProphet> napping:  the solution is to probably not use lambdas in a systems programming language, though I could be wrong.
14:39:47 <roconnor> okay, I'll bite. How does C# do lambda and why is it better?
14:39:54 <Philippa_> napping: well, the problem's lexical scope and first class functions, not lambdas specifically
14:40:02 <CakeProphet> ...why can't static typed C-based language do type inference?
14:40:02 <napping> well, yes
14:40:24 <napping> they can, it just doesn't buy you a heck of a lot of memory safety
14:40:32 <napping> if you want to be explicitly freeing things and so on
14:40:39 <Philippa_> references copy fine (though hanging pointers're an issue), values are a problem
14:40:43 <chrisdone> krey__: the pattern is, we are stringing together computations of type: (a -> r) -> r
14:40:59 <napping> or, writing the allocators yourself
14:41:17 <krey__> chrisdone: yep
14:41:22 <CakeProphet> I don't exactly recall how C# does lambda... but it's pretty sensible. I wouldn't say it's "better" than Haskell's lambda though
14:41:26 <chrisdone> krey__: do you follow?
14:41:44 <napping> Philippa_: I assume you've seen Fluet's thesis? capabilities seem to handle dangling references pretty nicely
14:41:48 <krey__> chrisdone: I think so
14:41:54 <napping> though I'm not sure how you stop an optional GC from following them
14:42:02 <chrisdone> krey__: okay, so how does the Cont monad express this pattern in its type?
14:42:38 <krey__> chrisdone: type a is the intermediate type, type r is the result type
14:42:39 <ddarius> roconnor: It doesn't really do it better or worse.  There is nothing wrong with the way C# does lambdas as far as I know.  The syntax, though, is slightly more concise that Haskell syntax in some cases.
14:43:24 <CakeProphet> ddarius:  the return is optional for a single statement lambda, correct?
14:43:30 <ddarius> CakeProphet: Correct.
14:43:33 <chrisdone> krey__: if I have a value z :: Cont r a, how do I get a CPS computation of type (a -> r) -> r from it?
14:43:38 <ddarius> \x -> x Haskell, x => x C#
14:44:08 <CakeProphet> I thought it used some kind of block notation?
14:44:09 <krey__> chrisdone: runCont z?
14:44:22 <chrisdone> krey__: exactly
14:44:23 <ddarius> CakeProphet: You can put a block in there and there is also the old delegate notation.
14:45:06 <monochrom> @type runCont
14:45:07 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
14:45:29 <CakeProphet> but yes, C# is the cutting edge of Java-oriented programming. I'd almost say it makes it a reasonable programming style.
14:45:32 <monochrom> > runCont (return 5) show
14:45:33 <lambdabot>   "5"
14:45:48 <Philippa_> napping: IIRC the capabilities have to be tied to some additional features, but yes
14:45:52 <monochrom> > runCont (callCC (\c -> c 5 >> return 4) show
14:45:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:45:57 <monochrom> > runCont (callCC (\c -> c 5 >> return 4)) show
14:45:58 <lambdabot>   "5"
14:46:07 <napping> Philippa_: linearity, to support explicit freeing
14:46:24 <Philippa_> napping: exactly. It's an issue that a language does have to explicitly address
14:46:30 <aristid> :t runCont
14:46:31 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
14:46:38 <aristid> :t callCC
14:46:40 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:46:51 <napping> well, linearity seems generally useful if you are trying to make a systems language
14:47:05 <monochrom> for example ((a -> Cont r b) -> Cont r a) -> Cont r a
14:47:06 <napping> access under locks, unique data for pass-by-reference between cores, that sort of thing
14:47:16 <CakeProphet> has anyone else heard of Io?
14:47:17 <Philippa_> anyway, if you've got that working sensibly and you make the assumption that values are, well, /values/ and if you care about a chunk of mutable memory you'll take a reference, then you've got a viable situation if you just lambda-lift the functions and pass around an activation record with holes in it that can be copied per-use or even used linearly
14:47:26 <CakeProphet> I find Io quite an elegant language.
14:47:27 <monochrom> in my example above, c :: Int -> Cont r b
14:47:36 <CakeProphet> it's a shame it doesn't have a large community/support
14:47:51 <ddarius> Aren't there two languages named Io?
14:48:22 <monochrom> there is also a satellite of jupiter called Io
14:48:57 <CakeProphet> I only know of one. It's prototype OO. Like smalltalk but improved in syntax (in my opinion).
14:49:15 <CakeProphet> optional laziness in function arguments as well. allows you to define new control structures.
14:49:25 <chrisdone> krey__: so, supposing we have two values, a CPS computation, Cont r Int, and a function returning a CPS computation, String -> Cont r String
14:50:13 <ddarius> shapr: Hey Shae
14:50:36 <chrisdone> krey__: for example,
14:50:36 <chrisdone> @let a = Cont (\f -> f (10::Int))
14:50:36 <chrisdone> @let b = \n -> Cont (\f -> f (show (n::Int)))
14:50:36 <chrisdone> :t a
14:50:37 <lambdabot> Expr
14:50:38 <lambdabot>  Defined.
14:50:38 <lambdabot>  Defined.
14:50:39 <chrisdone> :t b
14:50:40 <lambdabot>     Ambiguous occurrence `b'
14:50:40 <lambdabot>     It could refer to either `L.b', defined at <local>:3:0
14:50:40 <lambdabot>                           or `SimpleReflect.b', imported from SimpleReflect at State/L.hs:73:0-32
14:50:44 <shapr> hiya ddarius!
14:50:48 <chrisdone> okay, ignore lambdabot. it's retarded
14:51:03 <ddarius> shapr: How's life?  Except I'm about to leave for like 20 minutes.
14:51:07 <chrisdone> krey__: the types are: a :: Cont r Int, b :: Int -> Cont r String
14:52:18 <chrisdone> krey__: so how do suppose we combine them to make a new Cont?
14:52:27 <Philippa_> out of interest, has someone made a call-by-name Cont(T)?
14:52:53 <CakeProphet> which language communities are the easies to control. Here's my guess: lisp and smalltalk
14:52:57 <CakeProphet> *easiest
14:53:01 <chrisdone> I don't know of any implementations
14:53:09 <Philippa_> "easiest to control"?
14:53:12 <CakeProphet> hahaha
14:53:13 <CakeProphet> troll
14:53:27 <Philippa_> VB6
14:53:37 <krey__> chrisdone: *thinking*
14:53:38 <CakeProphet> I have interesting typos when I get out of bed.
14:53:54 <aristid> :t L.b
14:53:56 <lambdabot> forall r. Int -> Cont r String
14:53:59 <aristid> chrisdone: :P
14:55:45 <krey__> chrisdone: so the result we want is return "10"?
14:56:18 <chrisdone> krey__: that's right :-)
14:56:29 * hackagebot hp2pretty 0.2 - generate pretty graphs from heap profiles  http://hackage.haskell.org/package/hp2pretty-0.2 (ClaudeHeilandAllen)
14:57:13 <CakeProphet> question
14:57:13 <chrisdone> krey__: however, that's after the CPS computation has finished completely
14:57:20 <CakeProphet> does Sophia sound like a good name for a language?
14:57:26 <chrisdone> krey__: consider a function 'combine', which takes our two values and returns a new Cont. what is the type of combine?
14:57:51 <geheimdienst> sounds like an un-googleable name
14:58:14 <chrisdone> geheimdienst: like ruby, python, c, java, ...
14:58:52 <krey__> :t (>>=)
14:58:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:58:54 <Phyx-> no..
14:59:02 <Phyx-> "clips" is an ungoogleable name
14:59:17 <geheimdienst> hm, i think java is pretty clear ... i mean there's only that island. same thing for ruby
14:59:35 <napping> http://www.google.com/search?q=clips+programming
14:59:42 <napping> seems to work pretty well
14:59:47 <geheimdienst> you're right about c however. they screwed that up completely. they absolutely didn't think about googlability. morons
15:00:23 <Phyx-> napping: when searching for something specific
15:00:24 <napping> search is not an issue unless there's already another programming language with the name
15:00:45 <krey__> chrisdone: runCont a b is wrong, but the only thing I can come up with :S
15:00:50 <napping> or you name it something truly ungoogleable, like +!>+
15:00:57 <benmachine> whichever one was named later out of java and javascript
15:01:05 <benmachine> someone needs to be hurt about that
15:01:07 <chrisdone> krey__: so what type do we get from runCont a?
15:01:20 <napping> benmachine: go after the netscape suits
15:01:36 <krey__> (Int -> r) -> r
15:01:43 <napping> something about a deal with Sun
15:01:44 <Phyx-> isn't javascript technically named "EcmaScript" or something?
15:01:56 <geheimdienst> javascript has about as much to do with java as carpet with car
15:02:21 <benmachine> geheimdienst: that is, in fact, the problem
15:02:27 <chrisdone> krey__: right. this is what we'll call the 'final' computation, it takes a continuation and returns a final result:
15:02:37 <chrisdone> > runCont L.a show
15:02:38 <lambdabot>   "10"
15:02:43 <chrisdone> > runCont L.a (*5)
15:02:44 <lambdabot>   50
15:03:21 <krey__> :t runCont L.a L.b
15:03:22 <lambdabot> forall r. Cont r String
15:04:04 <krey__> hmm
15:04:59 <chrisdone> that's a bit misleading
15:05:07 <chrisdone> :t runCont L.a
15:05:08 <lambdabot> forall r. (Int -> r) -> r
15:05:08 <chrisdone> :t L.b
15:05:09 <lambdabot> forall r. Int -> Cont r String
15:06:11 <chrisdone> I think my question was bad
15:06:47 <chrisdone> krey__: hm, no, it's okay. right, we can continue from here. that's a fine way to combine them if we never want to actually use the continuation
15:08:06 <krey__> runCont L.a L.b (++"00")
15:08:40 <BMeph> geheimdienst: Speaking of "ungoogleability", how ironic is "Google's Go"? ;
15:08:43 <krey__> > runCont L.a L.b (++"00")
15:08:44 <lambdabot>   Couldn't match expected type `([GHC.Types.Char]
15:08:44 <lambdabot>                            ...
15:09:09 <chrisdone> the type
15:09:17 <chrisdone> :t runCont L.a L.b
15:09:18 <lambdabot> forall r. Cont r String
15:09:42 <krey__> > runCont (runCont L.a L.b) (++"00")
15:09:43 <lambdabot>   "1000"
15:09:52 <chrisdone> right :-)
15:10:53 <BMeph> CakeProphet: Oh, just to give you an FYI: I'm doing an implementation rewrite I'm calling "Hebe". So, don't use it,please. ;)
15:11:25 <CakeProphet> BMeph:  Sophia is my name of choice.
15:11:29 <greap> Any ideas on the cabal package unreadability?
15:11:56 <Wolfspaw> Im confused in that matter: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28419#a28419 can someone enlight me a bit? #o.o#
15:12:49 <monochrom> "can we come out of the monadic closet?" :)
15:13:25 <geheimdienst> runClosetT
15:13:36 <monochrom> @type pure
15:13:37 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
15:14:08 <monochrom> "pure x" becomes "[x]" given the type context, i.e., f is []
15:14:21 <greap> Wolfspaw: pure turns each character into a string
15:14:34 <greap> read works on strings
15:14:38 <monochrom> you are looking at "map (\x -> read [x]) ['1','2',etc]
15:15:00 <monochrom> [read "1", read "2", etc]
15:15:10 <Wolfspaw> hmmmm, thanks monochrom greap! It makes sense now !
15:16:20 <BMeph> CakeProphet: Well, another reason why I mention it, is because the thing I'm rewriting is an interpreter for Io. The "other" Io, fortunately. ;)
15:16:35 <greap> Wolfspaw: I was just reading the applicative functors chapter from LYAHFGG. It was quite enlightening: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
15:16:50 <CakeProphet> BMeph:  I've never seen the other Io.
15:16:59 <chrisdone> krey__: hmm, the novel use of runCont confused me. it's just due to the nature of it returning what the function you give it returns
15:17:45 <chrisdone> :t runCont L.a L.b
15:17:46 <lambdabot> forall r. Cont r String
15:18:11 <chrisdone> @let z = \n -> Cont (\_ -> show (n::Int))
15:18:12 <lambdabot>  Defined.
15:18:31 <chrisdone> krey__: how do you combine a then z then b?
15:18:40 <Wolfspaw> greap: i love LYAHFGG, its great! I fast-read it once, and could'nt grasp all. So i have to re-read the more advanced parts, i'll re-read this chapter carefull now!
15:18:51 <chrisdone> :t L.z
15:18:52 <lambdabot> forall a. Int -> Cont String a
15:18:59 <BMeph> CakeProphet: If you're interested, the intro paper is in my Google Docs: http://bit.ly/9bvYkv
15:19:01 <chrisdone> :t L.b
15:19:02 <lambdabot> forall r. Int -> Cont r String
15:19:33 <aristid> Wolfspaw: lol i first didn't associate the abbreviation "LYAHFGG" with lyah
15:19:45 <aristid> @where lyah
15:19:46 <lambdabot> http://www.learnyouahaskell.com/
15:20:37 <Wolfspaw> monochrom: but i didnt understood the "can you get out of the monadic closet?" yet, can you explain it?  im curious xD
15:20:58 <Wolfspaw> aristid: hm, didnt know it was called as that, ill abbreviate correctly next time xD
15:21:00 <monochrom> It is a joke.
15:21:08 <Wolfspaw> ah xD
15:21:24 <monochrom> it is also unrelated
15:21:29 <Wolfspaw> ahh xD
15:21:34 * ezyang imagines monochrom saying that in as deadpan a voice as possible. 
15:21:43 <chrisdone> > runCont L.a L.b
15:21:44 <lambdabot>   No instance for (GHC.Show.Show
15:21:44 <lambdabot>                     (Control.Monad.Cont.Cont...
15:21:44 <chrisdone> > runCont L.a L.z
15:21:45 <lambdabot>   No instance for (GHC.Show.Show
15:21:45 <lambdabot>                     (Control.Monad.Cont.Cont...
15:22:00 <chrisdone> :t runCont L.a L.z
15:22:00 <lambdabot> forall a. Cont String a
15:22:02 <monochrom> I am a bot.
15:22:24 <monochrom> Exterminate all humans.
15:22:49 <aristid> monochrom exists for two reasons: replace lambdabot when he has an outage, and exterminate all humans.
15:23:08 <monochrom> lambdabot is a she. I am a he though.
15:23:10 * geheimdienst imagines everything monochrom says in bender's voice
15:23:22 <krey__> :t L.z
15:23:24 <lambdabot> forall a. Int -> Cont String a
15:23:25 <Wolfspaw> it maded me laugh in the "wisdom air" it passes, like a Kung Fu(haskell-fu) master teaching adepts in chalanging words. But i though it was related and thinked "What the hell... O_O"
15:23:26 <chrisdone> krey__: anyway, as you can see from this example, runCont :: Cont r a -> (a -> r) -> r, so runCont (runCont L.a L.z) :: (a -> String) -> String, so we can't keep using runCont to combine them
15:24:08 <krey__> chrisdone: the thing I don't get is join
15:24:19 <chrisdone> the function?
15:24:33 <krey__> I donno how to define it
15:24:43 <chrisdone> :t join -- this?
15:24:43 <FauxFaux> @src join
15:24:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:24:44 <lambdabot> join x =  x >>= id
15:24:49 <monochrom> Haskell kung-fu masters trap students in closets for training. When the students can kick open the door and get out of the closet, it means they can graduate.
15:25:00 <krey__> if I plug the type into djinn, it will define it for me
15:25:04 <krey__> so it should be obvious
15:25:16 <Wolfspaw> monochrom: rofl xD
15:25:17 <krey__> my idea of monad is (return, fmap, join)
15:25:42 <aristid> krey__: and the monad laws :)
15:25:49 <krey__> aristid: of course :)
15:26:09 <krey__> so if I could figure out how join works
15:26:22 <krey__> ...
15:26:26 <aristid> :t join
15:26:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:26:31 <Wolfspaw> xD
15:26:42 * geheimdienst got his monadic closet entrapment contraption from ikea. geheimdienst is still stuggling to even assemble it
15:28:01 <monochrom> you need an extra closet-transformer
15:28:17 <Wolfspaw> rofl xD
15:28:57 * geheimdienst hopes that the closet transformer is some kind of movie with megan fox
15:29:19 <chrisdone> Rob Schneider is, a monad!
15:29:30 <chrisdone> (Rated PG 13)
15:30:01 <aristid> chrisdone: woah you think 13 year olds should watch that kind of stuff?
15:30:34 <chrisdone> better than watching teen vampire movies
15:32:13 <monochrom> "monads are like PG-13 movies. safe to watch from outside. unsafe things are confined inside the closet."
15:32:43 <geheimdienst> how do you mean? unsafe things are inside the movie?
15:32:58 <CakeProphet> > let ^.^ = (+) in 3 ^.^ 4
15:32:59 <lambdabot>   <no location info>: parse error on input `^.^'
15:33:03 * geheimdienst has only ever been outside of movies
15:33:08 <CakeProphet> > let (^.^) = (+) in 3 ^.^ 4
15:33:09 <lambdabot>   7
15:33:22 <aristid> that operator looks like a vampire.
15:33:29 <chrisdone> ^_^
15:33:38 <monochrom> it means when unsafe things happens, the movie just shows you the outside of the closet.
15:33:40 <geheimdienst> looks like a happy cat if you ask me
15:34:09 <monochrom> and yet you still get the final fruit of the unsafe thing, such as a new baby 9 months later.
15:34:27 <geheimdienst> ah, got you. "unsafe things" as in, the guy and megan fox humping furiously
15:35:35 <CakeProphet> @hoogle (^.^)
15:35:35 <lambdabot> No results found
15:36:02 <CakeProphet> @hoogle (:$)
15:36:03 <lambdabot> No results found
15:38:25 <chrisdone> i think i failed to teach krey anything about the continuation monad :-(
15:38:45 * chrisdone waits for a consoling pat on the back
15:39:40 * copumpkin gives chrisdone a consoling pat on the back
15:40:24 <monochrom> talking is no substitute for waiting
15:42:14 <monochrom> when some people don't understand something, they think "let me talk my head off about this and/or get someone to talk their head off to explain". now they have two problems.
15:43:29 <monochrom> when they don't understand something (but they have already got all the material, information...), the best action is to just wait
15:44:14 <chrisdone> monochrom: I think the best action is to ask questions (of a book, a spec, a person, of yourself). that's how I learn
15:45:03 <chrisdone> or by "waiting" do you mean resting and coming back to it?
15:46:05 <chrisdone> or do you mean we, as channel dewllers, ought to wait?
15:46:59 <augur> conal: i dont get your alt view of zippers. which were the two operations for navigation?
15:47:30 <conal> augur: up & down.
15:47:52 <conal> oh -- i could have called them "up" and "downs"
15:48:05 <conal> hm.
15:48:15 <augur> oh ok.
15:48:26 * chrisdone jabs monochrom
15:49:13 <aristid> chrisdone: if you don't understand monochrom, talking will not help. you have to wait until you understand it.
15:49:36 <chrisdone> aristid: ~_~
15:50:46 <monochrom> haha
15:50:51 <augur> conal: is that quite the intent of huet's tho? i mean, i think huet wanted specific up/down/left/right stuff for precisely navigating through tree-like structures so you could replace this then that then that in three nav steps
15:51:32 <monochrom> I did include "(but they have already got all the material, information...)"
15:51:40 <augur> but with up/downs i think you'd have to add some filtering steps as well because downs takes you to not just one new zipper but a collection of all possible ones, yeah?
15:52:31 <conal> augur: yes, to a collection.  each element of which is an editable zipper.
15:52:38 <aristid> monochrom: it isn't clear who has to wait and who is "they"
15:53:10 <monochrom> the student should wait. but it doesn't hurt for the teacher to wait too
15:53:56 <conal> augur: i like the direction of your question: is something lost in simplifying the interface from huet's to mine.  maybe you could plunk that question onto the blog post.
15:54:17 <notabel> can GHC handle multiline Template Haskell declaration quotations?  I get "parse error (possibly incorrect indentation)" when I try.
15:57:14 <c_wraith> notabel: Yes, it just has its own whitespace rules.
15:57:32 <ezyang> GHC seems to attempt to wait for an FFI call to finish before acting on a SIGINT. Can I make it not do that? 
15:58:06 <notabel> c_wraith: any idea where that is documented?
15:58:24 <c_wraith> notabel, no.  I just discovered that some things don't work by trial and error.
15:58:43 <notabel> okay.  so far I've been doing the same, but all error :-)
15:59:36 <augur> conal: its interesting tho. i mean, im not sure the up/downs simplification is really a simplification, because you might as well just define some function that pulls out all possible one-hole contexts from an object i think, but i like any new perspective on context objects
16:00:21 <conal> augur: i share your uncertainty & curiosity.
16:00:28 <c_wraith> notabel: are you using a splice or a quote?
16:02:47 <notabel> I want to quote a (multiline) declaration, but it's within the context of a splice: $(f [d| ... decls over multiple lines ... |])
16:03:06 <notabel> the splice is top-level
16:03:32 <conal> augur: "some function that pulls out all possible one-hole contexts from an object" sounds to me like 'extract'.
16:04:14 <c_wraith> notabel, try putting the |] ) on the same line as the last decl
16:06:04 <notabel> c_wraith: the parse error is located at column 0 of the second line of the quotation, ie immediately after the newline
16:06:58 <augur> conal: maybe. i cant understand the definition of extract at all, unfortunately. but if thats what extract does, then up and down are just extras that you could do away with in the editting functions that Huet has
16:07:44 <conal> augur: i think so also.
16:08:36 <conal> and conversely
16:08:44 <conal> hence "another angle"
16:08:56 <augur> aha.
16:09:38 <conal> using the pattern functor itself *as* the collection tickles me!  and is more type-informative/safe.
16:10:47 <conal> also the factoring into functor-level operations (fill/extract) vs very simple & universal tree-level operations (up/down).
16:13:52 <conal> there's something very satisfying for me in finding exactly the right tool for the job.  as simple as possible, and no simpler.  such as using the pattern functor itself as the collection of sub-zippers.
16:15:18 <conal> which in turn eliminates all but one of the classical zipper's failure modes.
16:15:59 <conal> as generally occurs when shifting to a more precise type.
16:16:11 <djahandarie> -- Albert Einstein, almost :)
16:16:40 <monoidal> q: is it possible to write a list -> tuple conversion? The type would be [a] -> exists a. a
16:17:08 <monoidal> or precisely data Sth = forall a. Sth a; convert :: a -> Sth
16:17:11 <monoidal> * [a] -> Sth
16:17:44 <Heffalump> what would you expect to do with Sth afterwards?
16:18:06 <monoidal> nothing :) theoretical question.
16:18:21 <ivanm> monoidal: you'd have to special case every possible tuple type
16:18:24 <monoidal> of course adding some typeclass constraint shouldn't be hard
16:18:26 <Heffalump> well, nothing is precisely what you could do with Sth given the lack of class constraints
16:18:29 <Heffalump> ok :-)
16:18:42 <Heffalump> would making nested pairs be ok?
16:19:05 <monoidal> i'd like n-tuples
16:19:31 <c_wraith> :t fst . fst
16:19:32 <lambdabot> forall a b b1. ((a, b), b1) -> a
16:19:49 <c_wraith> a, b, and b1.  that's...  some naming scheme
16:19:49 <ivanm> Heffalump: how would you specify the type sig of nested pairs?
16:20:08 <ivanm> use a type class with overlapping instances to distinguish between (a,a), (a,(a,a)), etc. ?
16:20:23 <c_wraith> > text [maxBound :: Char] -- hmm
16:20:24 <monoidal> ivanm: convert (x:y) = case y of Sth b -> Sth (x,b)
16:20:24 <lambdabot>   
16:20:27 <ivanm> c_wraith: yeah, lambdabot is very imaginative
16:20:49 <c_wraith> Oh look, you can still crash those two's irc clients by asking lambdabot that.
16:20:53 <Philippa_> tuples really ought to be synonyms for something with more type-level structure these days
16:20:55 <ivanm> monoidal: what is the type sig of such a function?
16:20:56 <hpc> :t sizeOf
16:20:57 <lambdabot> Not in scope: `sizeOf'
16:21:04 <monoidal> invanm: convert :: [a] -> Sth
16:21:05 <ivanm> @slap c_wraith 
16:21:05 * lambdabot smacks c_wraith  about with a large trout
16:21:08 <monoidal> *ivanm
16:21:20 <ivanm> what's Sth ?
16:21:34 <monoidal> data Sth = forall a. Sth a. It's anything basically
16:21:47 <ivanm> ahhhh
16:21:53 <ivanm> cheater!
16:22:32 <Heffalump> ivanm: use () as the terminator, then you don't need overlapping instances
16:23:18 <ivanm> Heffalump: hmmm...
16:23:42 <nphg|laptop> :t text
16:23:44 <lambdabot> String -> Doc
16:26:33 <ivanm> nphg|laptop: it's part of Text.Pretty
16:26:35 <monoidal> is it possible to run TH runtime?
16:27:00 <ivanm> monoidal: you mean generate code at runtime?
16:27:08 <monoidal> ivanm: yes
16:27:12 <ivanm> you'd need to basically embed or use ghc at runtime to do that
16:27:26 <ivanm> so probably yes, but your binary is going to be rather large :p
16:34:49 <stelleg> brizzy!
16:36:04 <nphg|laptop> ivanm, thanks. didn't read you earlier, was distracted browsing hoogle
16:36:29 <ivanm> heh
16:38:46 <Ferdirand> win 23
16:38:48 <Ferdirand> oops
17:03:46 <fryguybob> @ping
17:03:47 <lambdabot> pong
17:10:10 <CakeProphet> how is &&& used in arrow notation?
17:10:18 <CakeProphet> @hoogle Arrow
17:10:19 <lambdabot> module Control.Arrow
17:10:19 <lambdabot> Control.Arrow class Category a => Arrow a
17:10:19 <lambdabot> Control.Arrow class Arrow a => ArrowApply a
17:10:37 <hpc> > (length &&& head) <$> group [[1,2],[4,5,6]]
17:10:37 <lambdabot>   [(1,[1,2]),(1,[4,5,6])]
17:10:49 <CakeProphet> :t group
17:10:51 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
17:10:56 <hpc> wait
17:11:01 <geheimdienst> > group [[1,2],[4,5,6]]
17:11:02 <lambdabot>   [[[1,2]],[[4,5,6]]]
17:11:12 <hpc> > (length &&& head) <$> group [1,2,3,1,2,1,1,3]
17:11:13 <lambdabot>   [(1,1),(1,2),(1,3),(1,1),(1,2),(2,1),(1,3)]
17:11:31 <geheimdienst> 	> (length &&& head) <$> [[1,2],[4,5,6]]
17:11:38 <geheimdienst> > (length &&& head) <$> [[1,2],[4,5,6]]
17:11:40 <lambdabot>   [(2,1),(3,4)]
17:11:53 <hpc> so in that, (length &&& head) builds a tuple where the first element is the length of the list passed and the second is the first element
17:12:16 <CakeProphet> so... what kind of structure would be used in digital signal processing? 
17:12:27 <CakeProphet> that can be made into an Arrow.
17:12:35 <geheimdienst> in other words, &&& applies both of the functions to the same argument. what the functions yielded comes out as a 2-tuple
17:12:38 <CakeProphet> I suppose functions would suffice.
17:12:55 <CakeProphet> yes, but
17:12:56 <hpc> (&&&) expresses any parallel computation
17:12:59 <CakeProphet> I mean in the syntax sugar
17:13:10 <CakeProphet> when is &&& used.
17:13:38 <ddarius> You can find a few translations for arrow notation in a few places.  It may be the case that (&&&) isn't used.
17:14:14 <aristid> :t id &&& id &&& id
17:14:15 <lambdabot> forall b. b -> (b, (b, b))
17:14:40 <aristid> fortunately category-extras has a more general &&&
17:14:43 <hpc> :t id *** id
17:14:44 <lambdabot> forall b b'. (b, b') -> (b, b')
17:14:53 <aristid> :t id *** id *** id
17:14:54 <CakeProphet> :t (&&&)
17:14:55 <lambdabot> forall b b1 b'. (b, (b1, b')) -> (b, (b1, b'))
17:14:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:15:07 <CakeProphet> what is the &&& of category-extras?
17:15:12 <CakeProphet> @hoogle (&&&)
17:15:13 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
17:15:14 <aristid> CakeProphet: wait a second
17:15:54 <CakeProphet> hmmm, I bet what I'm trying to do has already been done
17:16:09 <CakeProphet> a "signal processor" arrow. input signal type to output signal type.
17:16:23 <ClaudiusMaximus> f &&& g = arr dup >>> first f >>> second g   or something like that
17:16:47 <aristid> CakeProphet: maybe i remember it wrong, hmm
17:16:59 <aristid> it seems like it's actually just the first & second in http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html
17:17:01 <hpc> :t dup
17:17:02 <lambdabot> Not in scope: `dup'
17:17:20 <hpc> @let dup = join (,)
17:17:21 <lambdabot>  Defined.
17:17:27 <hpc> > dup 5
17:17:28 <lambdabot>   (5,5)
17:17:32 <CakeProphet> why tuples and not linked lists?
17:17:37 <CakeProphet> typing?
17:17:57 <aristid> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian.html#v%3A%26%26%26
17:18:00 <aristid> there, found it
17:18:01 <CakeProphet> tuples seem awkward in the case where you want to compute many things in parallel.
17:18:02 <hpc> tuples are heterogenous
17:18:10 <ClaudiusMaximus> CakeProphet: i tried embedding Faust DSP language in Haskell once, was very painful
17:18:11 <aristid> (&&&) is in Control.Category.Cartesian
17:18:11 <hpc> yeah, it is really awkward
17:18:17 <aristid> and it's more general than just tuples
17:18:28 <CakeProphet> ClaudiusMaximus:  I've seen Faust, it's interesting. You can do many similar things in Haskell can't you?
17:18:36 <hpc> :t (Control.Category.Cartesian.&&&)
17:18:37 <lambdabot> Couldn't find qualified module.
17:18:37 <CakeProphet> particularly recursive feedback loops.
17:18:59 <aristid> hpc: lambdabot does not have category-extras :)
17:20:30 <ClaudiusMaximus> CakeProphet: http://claudiusmaximus.goto10.org/cm/2009-12-04_heist_dataflow_algebra.html and http://claudiusmaximus.goto10.org/cm/2009-12-06_heist_busted.html if you're curious
17:20:44 <CakeProphet> I am.
17:21:23 <CakeProphet> in particular I'm looking for the sanest way to express time-domain continuous signals and operations on them.
17:22:35 <ddarius> Transfer functions ho!
17:23:05 <ClaudiusMaximus> what kind of operations?  how continuous do you need your continuity?
17:23:06 <CakeProphet> yes, functions seem like the best way to do operations. But what is a signal exactly, and what could I do to one?
17:23:28 <CakeProphet> ClaudiusMaximus:  only theoretical continuity. In reality I will be dealing with sample rates, but the idea is to make it a non-issue in the code.
17:23:38 <CakeProphet> at least in the pure signal processing.
17:23:41 <hpc> CakeProphet: start by implementing some of the simpler operational amplifiers, i think
17:24:14 <hpc> CakeProphet: and see where that gets you
17:24:59 <CakeProphet> linked lists are the best way to do discrete signals. but what about continuous?
17:25:17 <CakeProphet> perhaps I need a set of typeclass that can convert continuous operations to discrete ones.
17:25:20 <hpc> continuous signals are Time -> Amplitude, i think
17:25:30 <CakeProphet> s/set of typeclass/typeclass/
17:25:37 <CakeProphet> hpc:  correct.
17:25:40 * ddarius considers a coalgebraic view of a "topological" line.
17:26:06 <ddarius> There is that midpoint algebra thing, but I doubt it will be useful to you.
17:26:36 * ClaudiusMaximus wonders about pathological signals like  f t | isRational t = 1   | otherwise = 0
17:26:47 <ddarius> http://www.cs.bham.ac.uk/~mhe/papers/lics2001-revised.pdf
17:27:09 <CakeProphet> hmmm...
17:27:12 <ddarius> Some new paper here that look interesting: http://www.cs.bham.ac.uk/~mhe/papers/
17:27:42 <CakeProphet> essentially, I think there are different ways to represent the signal. The problem is a unified interface. Essentially I want a typeclass that can provide basic operations for any sort of representation
17:28:13 <CakeProphet> you might represent your signal directly as a function of time to amplitude, or you be represented as a discrete list (perhaps from an input source)
17:28:27 <CakeProphet> s/be/it can be/
17:29:44 <ClaudiusMaximus> i think causality is important for useful/musical signal processing because time seems to pass in one direction
17:29:47 <ddarius> ClaudiusMaximus: I kind of like hyperfunctions though I don't think they'd allow a signal that pathological (though they would allow e.g. the Dirac delta function.)  I personally think that a function like that should be banned.
17:30:08 <ClaudiusMaximus> ddarius: :)
17:31:15 <CakeProphet> ClaudiusMaximus:  temporal logic? :)
17:33:03 <CakeProphet> I think the basic typeclass operation is: "given a sample rate, convert your representation to a discrete linked list of type t"
17:33:29 <ClaudiusMaximus> arrows would be useful for dsp optimization if you could inspect them and transform them in more ways, but 'arr' breaks that so something else is needed
17:34:09 <ddarius> arr doesn't completely break that
17:34:59 <Philippa> ClaudiusMaximus: I guess you'd insist on implementing preverb by explicitly adding latency everywhere else :-)
17:35:22 <CakeProphet> so a signal representation that uses a time->amp function would use the sample-rate to apply t-values to the time function
17:35:39 <CakeProphet> f t1 : f t2 : f t3 : ...
17:35:43 <ClaudiusMaximus> Philippa: i was just thinking about reverse cymbals..
17:36:44 <CakeProphet> yeah, I'm thinking about how a delay-line would work.
17:36:54 <CakeProphet> I believe you'd need some kind of state.
17:37:02 <CakeProphet> or a lot more function arguments than time.
17:38:48 <CakeProphet> essentially you need a way to specify a backbuffer in continuous time units.
17:38:59 <ClaudiusMaximus> non-linear feedback could lead to systems with very different behaviour at different sample rates - so if you want  Time -> Value  to be "accurate" you'd need to have some kind of way of testing that your sampling scheme converges to the true continuous solution
17:39:01 <CakeProphet> and then a "sane" way to get that backbuffer in discrete units.
17:39:59 <CakeProphet> I don't actually thnk time -> value is the best way to do signals in the real world.
17:40:03 <CakeProphet> not most.
17:40:46 <CakeProphet> perhaps
17:40:58 <CakeProphet> time -> MStack v
17:42:06 <CakeProphet> in languages like csound you have a fixed sample rate for everything, which makes a lot of issues go away. That might be the best approach honestly.
17:42:57 <ClaudiusMaximus> in Pure-data you can have subpatches that are up/downsampled, if you need more accuracy/speed in certain places
17:44:56 <CakeProphet> ClaudiusMaximus:  so a patch has a initialization step, and then the time-varying stages.
17:45:12 <CakeProphet> in initialization you could set sample rate and such.
17:45:18 <CakeProphet> specify delay lines
17:45:52 <CakeProphet> hmmm, actually
17:46:20 <CakeProphet> for delay lines. you can just give every signal processor an indefinitely backtracking line, thanks to lazy evaluation. Does that sound right?
17:46:41 <ddarius> http://www.ittc.ku.edu/csdl/fpg/node/46
17:48:59 <CakeProphet> hmmm... okay.
17:49:14 <CakeProphet> so some operations are going to be working on a discrete signal, others continuous.
17:49:34 <CakeProphet> the trick is to convert between continuous/discrete-at-different-sample-rates effectively.
17:49:49 <Philippa> CakeProphet: how is lazy evaluation relevant to backtracking? Also, isn't this called a space leak? :p
17:50:20 <CakeProphet> ah. yeah. I suppose that wouldn't be effective.
17:50:41 <CakeProphet> so fixed-size delay lines are still needed.
17:51:00 <ClaudiusMaximus> CakeProphet: and then you throw in discrete events like noteon/noteoff messages and it gets even more horrible
17:51:10 <Philippa> and then you have to worry about some arsehole modulating the length of the delay line at runtime
17:52:20 <CakeProphet> ClaudiusMaximus:  well, this is purely for myself. I assume there are always hideous things people can do in any system.
17:52:32 <CakeProphet> er
17:52:43 <CakeProphet> Philippa, not claudiusmaximus
17:53:38 <CakeProphet> I think in most cases it's better to do DIGITAL signal processing with discrete, digital values.
17:54:13 <CakeProphet> so... discrete-only computations.
17:54:37 <Philippa> *nod*. Though watch out for quirks re events happening to different clocks
17:55:19 <Philippa> if you're doing strictly synthesis then there's an argument for starting out continuous
18:05:53 <CakeProphet> > let (|+|) = (+) in 2 |+| 2
18:05:54 <lambdabot>   4
18:08:12 <Philippa> y'know, when there's no reason for someone else to see it you should probably use your own interpreter or at least PM lambdabot
18:10:24 <new2haskell> hello, how can I know that members of 2 lists are not comparable, e.g [1,2] vs "ab"?
18:14:34 <ivanm> new2haskell: the type sigs are different
18:15:57 <new2haskell> ivanm: I'm writing a function that would say "incomparable" if it's given a String and a [Int]
18:16:39 <ezyang> new2haskell: No need, Haskell will tell you that :-) 
18:16:44 <Botje> new2haskell: but you know that at compiletime
18:16:49 <ezyang> > [1,2] == "Int" 
18:16:50 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
18:16:50 <lambdabot>    arising from the literal `1...
18:17:13 <ivanm> new2haskell: you can use Data.Dynamic to do that I think
18:18:44 <new2haskell> ivan: is there a try-catch mechanism in Haskell?
18:24:41 <new2haskell> oh, I just realized this: Can we use "case x of Char => doSth; Int => doSthElse" like in ML?
18:24:52 <ivanm> no
18:24:58 <ivanm> that's what type classes are for
18:30:09 <carter> that being said, that sort of case analysis idiom is kosher in scala (otoh every type in scala is implicitly nullable, shudder)
18:31:13 <roconnor> you can do that in ML?
18:31:22 <ddarius> roconnor: No.
18:31:40 <roconnor> new2haskell: types are erased
18:34:46 <new2haskell> rconnor: iirc, we can do that in ML as long as Char and Int are type constructor
18:35:18 <roconnor> sure
18:35:39 <roconnor> but those aren't types
18:35:43 <roconnor> they are constructors then
18:36:22 <ddarius> s/type constructor/data constructor/
18:36:36 <carter> new2haskell: thats expressible in haskell too, thats just a variant type. 
18:36:55 <roconnor> ddarius: right
18:37:28 <carter> new2haskell:  it can be thought (metaphorically ) of as a way of providing run time tagging, though thats not quite exact
18:37:55 <ddarius> carter: It is exactly run-time tagging.  It just isn't run-time -type- tagging.
18:39:09 <Philippa> ML doesn't have /type/ tagging either, does it?
18:39:15 <Philippa> ah, already covered
18:40:10 <new2haskell> thanks all
18:59:32 <ezyang> Is it confusing if I have Nothing signal success and Maybe ErrorInformation signal error? 
18:59:55 <bremner> yes
19:00:12 <ddarius> You could use Right () and Left ErrorInformation
19:00:26 <bremner> or make yer own ADT
19:00:31 <ezyang> That's what I originally wrote. 
19:00:38 <ezyang> and then I was like (that's isomorphic to Maybe) 
19:00:53 <bremner> sure, but with sensible labels.
19:00:58 <ezyang> yup 
19:01:23 <bremner> I mean, e.g. the maybe monad won't work for you anyway, right? so what does using maybe buy you?
19:01:26 <ddarius> If your function is called reportErrors then the Maybe is fine.
19:02:12 <ezyang> ddarius: I'm being evil and this is going into a synchronization MVar 
19:02:27 <benmachine> I think it's fine
19:02:49 <benmachine> if the type is Maybe ErrorInformation then it's natural to suppose Nothing is not an error
19:02:55 <benmachine> or rather
19:02:58 <benmachine> Nothing is not-an-error
19:08:24 <ezyang> Ok, so I'm this situation where I want to install a signal handler that catches ^C and puts you back into a REPL loop. 
19:08:31 <ezyang> I have some code that works fine if there is no FFI involved. 
19:09:10 <ezyang> However, if I invoke ^C while GHC is in a long-running FFI call, it'll handle the exception in Haskell (it'll even throw an exception), and then it'll go back to running the FFI call. 
19:09:17 <ezyang> I need it to /break out/ of the FFI call. 
19:10:06 <ezyang> I'm thinking that I'll need to sandbox the call in another thread. Does this sound correct? 
19:40:46 <ezyang> This is what I have so far: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28422#a28422 
19:40:58 <ezyang> The thread seems to continue executing even after trapping the signal. 
19:41:12 <augur> conal: you have any experience with proof systems?
19:41:55 <conal> augur: a long time ago.  i worked with higher-order unification and dependent typing in grad school.
19:42:27 <augur> hhmm.
19:43:54 <nha_> does the haskell platform come with a set of offline haddock references for the stdlib
19:44:33 <augur> conal: do you happen to know of any books on proof system algorithms? efficient proof search, etc.?
19:44:59 <conal> augur: not offhand.  good idea asking around on this channel.
19:45:22 <augur> well, #haskell is practically #computerscience, so..
19:45:49 <augur> and the actual compsci channels on freenode are filled with kids who have a passing interesting programming, not much else
19:49:42 <ddarius> augur: Texts on the implementation of logic languages will be somewhat relevant to some classes of proof systems.
19:51:27 <augur> ddarius: hmm. ill give some a look, tho i dont know of any real logic languages other than prolog
20:04:11 <ivanm> BinRoot: are you aware that you're having connection issues?
20:08:41 <dobblego> newtype K a b c = K (Either b c, a) -- is (K a b) a comonad?
20:09:00 <ivanm> ask edwardk ;-)
20:09:16 * ivanm have never understood what a comonad is
20:09:47 <ddarius> dobblego: No.
20:10:03 <ddarius> extract would have type K a b c -> c
20:10:34 <dobblego> oh yes -- I was right first time :)
20:11:01 <dobblego> I thought "there is no w a -> a therefore, no" then I convinced myself it wasn't needed; forgetting the Copointed constraint
20:11:21 <dobblego> thanks for saving me a bit of time
20:31:30 <absentia> n/win shrink 4
20:38:44 <kmc> s'pose i want to define a recursive type and a zipper for that type at the same time
20:39:38 <kmc> is there a particularly nice way to do this?
20:40:19 <ddarius> Just calculate the Zipper from it as Conal did in the recent post.
20:40:21 <kmc> seems like i'd describe the recursive functor structurally, then use a type family to differentiate it
20:40:59 <kmc> i bet some library already does this; is it worth it for a simple-ish case?
20:41:04 <kmc> ddarius, "Another angle on zippers"?
20:42:28 <kmc> or "Differentiation of higher-order types"?
20:57:13 <ddarius> The former.
20:57:35 <ddarius> Well, probably both.
21:12:13 <ivanm> allbery_b: so, who's right wrt minimal definition for a Monad? you or wren?
21:12:20 <ivanm> I didn't think you needed return with join...
21:12:49 <c_wraith> join and fmap don't add up to return
21:13:02 <kmc> you need all three
21:13:10 <dobblego> join+fmap+return you can't have only two
21:13:20 <ivanm> huh, I've heard a few times that all you need is join...
21:13:31 <kmc> fmap+return gives you a pointed functor only
21:14:05 <ddarius> return+bind or return+join+fmap
21:18:48 <allbery_b> yeh, wren is corrrect, you still need a way to pull a value into the monad
21:19:04 <allbery_b> I tossed that off a bit too quickly this afternoon
21:30:46 <kmc> @hoogle (<#>)
21:30:46 <lambdabot> No results found
21:33:37 <hewei> @help run
21:33:37 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
21:34:26 <hewei> :@src print
21:35:33 <hewei> @src id
21:35:34 <lambdabot> id x = x
21:35:45 <hewei> @src print
21:35:45 <lambdabot> print x = putStrLn (show x)
21:36:18 <hewei> @src (>>>)
21:36:19 <lambdabot> Source not found. :(
21:36:41 <hewei> @src (>>=)
21:36:42 <lambdabot> Source not found. :(
21:39:24 <hewei1> @help
21:39:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:43:29 <hewei> @type <$>
21:43:30 <lambdabot> parse error on input `<$>'
21:43:46 <hewei> @type (<$>)
21:43:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:43:59 <humasect> hey guys! how come killThread doesn't do killing of threads? am i missing something?
21:44:15 <humasect> does it matter if the thread in question is in threadDelay or socket accept?
21:55:41 <humasect> OnionKnight =)
21:59:08 <lispy> hey
22:05:24 <humasect> hello
22:05:52 <Axman6> hello humasect 
22:06:18 <humasect> hi~
22:17:07 <lars9> hi, why I can not apply sqrt on a Int?
22:17:26 <humasect> @type sqrt
22:17:27 <lambdabot> forall a. (Floating a) => a -> a
22:17:37 <lars9> sqrt in prelude is Floating a => a -> a, is there a sqrt for Int?
22:18:00 <humasect> it may be best to make Int a Floating for the sqrt
22:18:16 <humasect> because square root often results in floating numbers i believe..
22:18:40 <lars9> how to convert Int to Float then?
22:18:53 <humasect> i think its ..
22:18:54 <humasect> @type fromInteger
22:18:55 <lambdabot> forall a. (Num a) => Integer -> a
22:19:08 <lars9> cool, thanks
22:19:09 <humasect> yeah that should work
22:19:11 <humasect> np
22:22:26 <lars9> there is no fromInt?
22:22:42 <humasect> Int is an integral type i believe
22:22:56 <humasect> > sqrt $ fromInteger (5 :: Int)
22:22:57 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
22:22:57 <lambdabot>         agains...
22:23:06 <humasect> oh yeah
22:25:02 <humasect> how come it is an Int? =) 
22:27:52 <lars9> s
22:30:43 <dobblego> @type \(a1, a2) (b1, b2) -> let c = a1 `compare` a2 in if c == EQ then b1 `compare` b2 else c
22:30:44 <lambdabot> forall t t1. (Ord t, Ord t1) => (t, t) -> (t1, t1) -> Ordering
22:32:04 <dobblego> @type \(a1, b1) (a2, b2) -> let c = a1 `compare` a2 in if c == EQ then b1 `compare` b2 else c
22:32:05 <lambdabot> forall t t1. (Ord t, Ord t1) => (t, t1) -> (t, t1) -> Ordering
22:38:24 <ddarius> :t fromIntegral
22:38:25 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:49:50 <lars9> how to tell if a Float is an Int? for example sqrt 100 = 10.0, is an int
22:50:20 <Axman6> :t realToFrac
22:50:21 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
22:50:26 <Axman6> hmm
22:50:55 <humasect> the best way to tell if a Float is an Int is to realise that it is a Float and not an Int. =)
22:51:23 <lars9> ok...
22:52:29 <humasect> > sqrt $ (fromInteger (5 :: Int) :: Float)
22:52:30 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
22:52:30 <lambdabot>         agains...
22:52:41 <humasect> > sqrt $ (fromInteger (5 :: Int)) :: Float
22:52:41 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
22:52:42 <lambdabot>         agains...
22:52:57 <humasect> i dont know. there is a trick to it, but i wonder how come it is an Int if one needs to sqrt on it?
22:53:48 <Axman6> fromIntegral
22:54:16 <Ke> if floor and ceil are the same
22:54:28 <humasect> ah
22:54:48 <Ke> but no idea whether algorithms like sqrt guarantee exact result
22:54:52 <Axman6> > map (\x -> floor x == ceil x) [0,0.1..]
22:54:53 <lambdabot>   Not in scope: `ceil'
22:55:00 <Axman6> hmm
22:55:04 <Ke> humasect: typically this should not be used
22:55:27 <humasect> > map (\x -> floor x == ceiling x) [0,0.1..]
22:55:28 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,True,False,Fals...
22:55:37 <humasect> cool~
22:56:15 <Axman6> > (\x -> floor x == ceil x) 0.9999999
22:56:16 <lambdabot>   Not in scope: `ceil'
22:56:20 <Axman6> > (\x -> floor x == ceiling x) 0.9999999
22:56:21 <lambdabot>   False
22:56:25 <Axman6> > (\x -> floor x == ceiling x) 0.999999999
22:56:26 <lambdabot>   False
22:56:30 <Axman6> > (\x -> floor x == ceiling x) 0.99999999999999999999999]
22:56:31 <lambdabot>   <no location info>: parse error on input `]'
22:56:32 <Axman6> > (\x -> floor x == ceiling x) 0.99999999999999999999999
22:56:34 <lambdabot>   True
22:56:38 <humasect> =)
22:56:44 <Axman6> > 0.99999999999999999999999 
22:56:45 <lambdabot>   1.0
22:56:53 <Axman6> to be expected i guess
22:56:59 <humasect> > toRational 0.99999999999999999999
22:56:59 <lambdabot>   1 % 1
22:57:21 <humasect> > toInteger $ 1 % 999999999999
22:57:22 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t))
22:57:22 <lambdabot>    arising from a us...
22:57:29 <humasect> oops.
22:58:02 <dancor> why does reactive-fieldtrip depend on reactive-glut?
22:58:29 <dancor> i guess bc for fieldtrip "Our first renderer uses OpenGL"
23:04:21 <lars9> what happened to this piece of code? http://collabedit.com/78259
23:07:49 <humasect> try ->  sol :: Floating a => a -> (a, Bool) 
23:10:24 <JHaskly> Also try: b = (x * (x - 1) == (fromIntegral a))
23:10:32 <JHaskly> Worked for me
23:10:43 <lispy> That error message is somewhat misleading
23:10:52 <lispy> But, JHaskly is exactly right
23:11:00 <JHaskly> :)
23:11:08 <humasect> sol :: Floating a => a -> (a, Bool)          works when taking out the fromIntegral.
23:11:15 <lispy> The comparison of (x * (x -1)) and a forces them to be the same type
23:12:27 <lars9> awesome, thanks!
23:14:02 <dancor> how do you go from Float to GLfloat
23:15:17 <lispy> dancor: that I don't know
23:15:29 <lispy> dancor: isn't GLFloat just a type synonym?
23:15:42 <dancor> > ((4 :: Float) :: GLfloat)
23:15:44 <lambdabot>   Not in scope: type constructor or class `GLfloat'
23:16:00 <dancor> anyway it's not for me
23:16:25 <dancor> this works: ((fromRational (toRational (4 :: Float))) :: GLfloat)
23:16:29 <dancor> but is that the best way?
23:16:29 <lispy> http://cvs.haskell.org/Hugs/pages/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-BasicTypes.html
23:16:38 <lispy> That must be old, it says that GLFloat = Float
23:16:42 <dancor> i think it's old
23:17:29 <dancor> i have OpenGLRaw-1.1.0.1 which is latest on hackage
23:19:39 <lispy> hmm
23:20:40 <lars9> the convert of basic number types looks so complicated ...
23:20:46 <lispy> FLOATING_TYPE(GLfloat,tyConGLfloat,"GLfloat",CFloat)
23:21:29 <lispy> dancor: I think that line implies a GLfloat is the same as a CFloat
23:21:43 <lispy> dancor: therefore, I think you can convert it to Float the same ways you would a CFloat
23:23:42 <lars9> for example , f(x) = x*(x-1)/2, x is Integer, then f(x) must be integer too. how to convert x*(x-1)/2 back to integer?
23:23:58 <humasect> http://github.com/humasect/Nova/blob/master/Source/Nova/GL.hsc       this also uses natural float types afaik
23:24:07 <dancor> lispy: ok, can you think of anything better than fromRational . toRational?
23:24:09 <humasect> (not having to move between GLfloat and Float)
23:24:49 <dancor> lars9: you could use `div` 2 right?
23:25:34 <lars9> :i div
23:25:55 <lars9> dancor: ok, thanks
23:25:57 <dancor> :t let f x = x * (x - 1) `div` 2 in f
23:25:58 <lambdabot> forall a. (Integral a) => a -> a
23:26:31 <dancor> the trickiest ones for me involve realToFrac i think..
23:26:34 <dancor> :t realToFrac
23:26:35 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
23:28:15 <dancor> if it really is (fromRational . toRational) i hope it at least compiles to a sane/efficient answer..
23:30:05 <lispy> dancor: Well, it looks like there is a type constructor for it
23:30:23 <lispy> dancor: it's defined like, newtype CFloat = CFloat foo
23:30:28 <lispy> not sure yet what foo is
23:31:34 <lispy> dancor: we should be able to see what it compiles to
23:32:04 <lispy> dancor: what module do you import to get GLFloat?
23:34:04 <dancor> lispy: GLfloat is in Graphics.Rendering.OpenGL
23:34:13 <dancor> reexported by that anyway
23:36:43 <lispy> dancor: Well, the core for it still uses type classes
23:36:50 <lispy> I thnk anyway...
23:37:32 <lispy> dancor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28431#a28431
23:38:16 <dancor> hm idk core yet
23:38:35 <lispy> dancor: Well, the part that says F# is really good
23:38:43 <lispy> dancor: but what it does next is not so hot
23:38:48 <dancor> ok
23:39:05 <lispy> dancor: Sadly the constructor for CFloat and GLFloat don't look to be exposed
23:39:21 <lispy> dancor: which is really too bad, because they are the same type to C
23:42:28 <grazer> I'm wondering what the precedence is when using a function with infix notation?
23:43:18 <lispy> dancor: okay, those classes have nice trivial definitions for toRational and fromRational
23:43:28 <dancor> ok
23:43:47 <lispy> dancor: since they are newtypes it just adds or removes the newtype wrapper
23:43:52 <lispy> no runtime overhead
23:44:00 <dancor> ah
23:44:34 <lispy> Looking at the core, I think it hasn't fully specialized it for the simplicity of this case so there may be some overhead still
23:45:13 <lispy> To my eyes, it looks like it left some of the type class generality in there, but once it looks up the definitions those are trivial
23:45:16 <JoeyA> grazer:  Quoth the Haskell report:  "If no fixity declaration is given for `op` then it defaults to highest precedence and left associativity (see Section 4.4.2)."
23:45:49 <JoeyA> But the precedence can be specified.
23:46:08 <JoeyA> For instance, `div` is infixl 7, right alongside * and /
23:47:23 <JoeyA> So if you don't specify the precedence, you basically get an operator like !!
23:47:36 <dancor> lispy: ah guess what, realToFrac = fromRational . toRational
23:47:45 <lispy> dancor: heh, okay
23:47:48 <dancor> so that's the answer
23:48:30 <grazer> JoeyA: thanks.  What is the "highest precedence".  ghci with :info (!!) won't seem to tell me
23:48:31 <lispy> dancor: if GL and Foreign.C.Types exposed the constructors we could do even better here
23:49:01 <JoeyA> Precedence 9
23:49:07 <JoeyA> infixl 9, to be more precise
23:49:31 <grazer> Ahh, which is just lower than function application?
23:49:38 <JoeyA> . is infixr right
23:49:42 <Zeiris_> Is there a haddock page to view which packages use a certain package?
23:49:43 <JoeyA> infixr 9, I mean
23:49:50 <JoeyA> so it's the same precedence, meaning they'll conflict
23:50:41 <lispy> Zeiris_: someone has a reverse hackage that lets you see which packages use a specific package
23:51:07 <lispy> Zeiris_: http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
23:51:29 <lispy> Zeiris_: note the rev. deps link at the top
23:51:43 <Zeiris_> lispy, awesome, thanks :)
23:51:53 <JoeyA> example:
23:51:58 <JoeyA> :let mc f g x = f (g x)
23:52:06 <JoeyA> @let mc f g x = f (g x)
23:52:08 <lambdabot>  Defined.
23:52:16 <JoeyA> > (+3) . (*2) `mc` (+1) $ 3
23:52:17 <lambdabot>   Precedence parsing error
23:52:18 <lambdabot>      cannot mix `L..' [infixr 9] and `L.mc' [infix...
23:52:56 * lispy >>= sleep
23:52:57 <JoeyA> Well, good night
23:53:39 <grazer> > (+3) `mc` (*2) `mc` (+1) $ 3
23:53:40 <lambdabot>   11
