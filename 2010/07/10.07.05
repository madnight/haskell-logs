00:00:38 <BMeph> :unpl sortBy (flip compare `on` fst)
00:00:46 <BMeph> @unpl sortBy (flip compare `on` fst)
00:00:46 <lambdabot> sortBy (on (\ b c -> compare c b) fst)
00:01:12 <BMeph> @unpl on
00:01:13 <lambdabot> on
00:01:20 <BMeph> @unpl on f g
00:01:20 <lambdabot> on f g
00:01:23 <Veinor> @src on
00:01:23 <lambdabot> (*) `on` f = \x y -> f x * f y
00:02:01 <BMeph> Veinor: Excelent! Now, explain that to the 'unpl'  function... ;)
00:02:22 <Veinor> @unpl (*) `on` f
00:02:22 <lambdabot> (on (*) f)
00:04:48 <augur> ok peeps
00:04:58 <augur> whos familiar with Huet's zippers
00:06:10 <Saizan> who's not?
00:06:15 <augur> :p
00:06:27 <Rotaerk> your mom likes Huet's zippers
00:06:56 <Saizan> now, who is familiar with the concept of residual in the context of term rewriting systems?
00:07:21 <qwebirc39036> Who's familiar with sleep. It's past midnight.
00:09:14 <augur> saizan, theres a think in linguistics due to barker and shan in which they employ zipper-like operations to do continuation semantics for natural language
00:10:02 <augur> their interpretation is rather elegant, tho it doesn't map trivially to what huet did
00:11:12 <Saizan> makes some sense, continuations capture the "stack" which can also be seen as an evaluation context, which is the context part of a zipper for the AST
00:12:11 <Saizan> iiuc, but i don't have much experience with this
00:12:46 <augur> what i mean tho by saying that theirs is a rather elegant interpretation is that, from the tree object, you can do some simple graphical annotation and manipulations that correspond 1-to-1 with the barker-shan zipper data structures
00:14:18 <Saizan> do you have some concise presentation of both huet and barker-shan zippers handy?
00:14:58 <augur> eh. the original huet paper explains the data structures in programmatic terms, but not with full examples, nor with visualizations
00:15:14 <augur> the barker-shan stuff is in a paper of theirs called Types as Graphs
00:15:55 <Saizan> in general i've seen some differing opinions on what should be called the context
00:15:55 <augur> their stuff is on binary lists/pairs so their formulation is much simpler, but you can generalize it relatively easily
00:16:10 <augur> its really the graph interpretation that they give thats very useful
00:16:22 <augur> tho their visualizations of this interpretation make it somewhat hard to understand
00:17:00 <augur> in sum, you visualize the data structure as a tree, with a "branch" from the top going to nothing, denoting the root of the tree. branches going to nowhere denote the root, you see.
00:17:40 <augur> and you "push" a "Top" element in place of the root, in the process deriving a new root, which is visualized on the tree as a ring put on the original root branch, with its own root branch pointing left
00:18:00 <augur> "down" would be equivalent to moving the ring to the leftmost branch below
00:18:27 <augur> "up would be the opposite, "right" would be moving the ring to the branch to the right, and "left" would be to the left
00:19:18 <augur> and this maps transparently into a datastructure in which the nodes denote items, either lists or atoms, and you get the nodes by just forming the list from the branches in a clockwise fashion
00:19:58 <augur> tho this has nasty computational properties since a naive implementation would result in a lot of xs ++ [a]
00:21:55 <augur> tho i think going back up a tree doesnt require xs ++ [a] much, so its, i think, like huet's approach in that regard
00:22:55 <Zeiris> Is it possible to have a list :: (Enum a) => [a], with mixed types inside as long as they're all Enums?
00:25:36 <Saizan> not with that type
00:27:13 <Saizan> you need an "existential wrapper", data AnyEnum = forall a. Enum a => AnyEnum a, then you can have [AnyEnum (1::Int), AnyEnum True] :: [AnyEnum]
00:27:39 <Saizan> by patter matching on the AnyEnum constructor you'll have access to the Enum context
00:28:17 <Saizan> maybe you can also make an "instance Enum AnyEnum where .." if the methods of Enum permit
00:29:46 <FunctorSalad> idea about the quick-and-nasty haskell scripting: how about a #!/bin/compileRunHaskell ? ;)
00:29:58 <FunctorSalad> which would compile the file to some global cache
00:30:02 <FunctorSalad> then run it
00:30:32 <Saizan> makes sense
00:30:33 <FunctorSalad> lookup by filename and date I guess
00:30:48 <FunctorSalad> (checksum would be a bit slow for interactive utilities I guess)
00:31:19 <Saizan> well, the timestamp would just invalidate the cache, i guess?
00:31:37 <Saizan> s/cache/cached exe/
00:32:26 <FunctorSalad> yes, I thought you'd have a global table of triples (file,mtime,cached exe)
00:32:49 <FunctorSalad> if we have a hit, just run it, else compile
00:33:53 <FunctorSalad> ah I suppose your point is that the old versions shouldn't accumulate :) indeed
00:40:49 <handonson> Parsec has a side-effect.
00:41:04 <handonson> I'm seeing all natural language sentences as combination of parsers.
00:41:25 <handonson> This is such a horrible side-effect.
00:41:32 <Jafet> This is a well-known and potentially dangerous syndrome, commonly called homskyitis
00:41:37 <Jafet> Bah, chomskyitis
00:46:34 <augur> Saizan: Huet's solution seems to be a very good way of navigating through non-pairs
00:47:03 <augur> handonson, Jafet: what are you kids talking about. natural language, ey
00:47:21 <augur> Saizan: but given that cons lists are pairs, it might not be optimal
00:49:36 <Saizan> augur: the huet zipper for lists is Z a = ([a],a,[a]) i believe? such that you can reconstruct the original list with toList (prefix,element,suffix) = reverse prefix ++ [element] ++ suffix
00:50:26 <augur> its not ([a],a,[a]) tho, its ([a], Z a, [a])
00:51:13 <Saizan> left (xs, x, (y:ys)) = (x:xs, y, ys); right ((x:xs), y , ys) = (xs, x, y:ys)
00:51:54 <Saizan> mh, that doesn't much my understanding of zippers, but i've never read huet's original paper
00:52:06 <Saizan> s/much/match/
00:52:33 <augur> according to his original paper, left (Loc t p@(Node l:ls up rs)) = Loc l (Node ls up t:rs)
00:52:37 <dolio> It rather depends on whether you're talking about zippers for some T a, or for some T.
00:53:08 <augur> im not sure why i referenced p there :p
00:53:12 <augur> obviously unnecessary
00:53:14 <dolio> For a nice enough T a, you can get a zipper as something like a * DT a, I think.
00:53:24 <dolio> DT being the derivative of T.
00:54:05 <dolio> But for types T in general, I think you need to talk about lists of the derivative of the functor for which it's a fixed point, or something like that.
00:54:40 <dolio> If T = Mu F, then the zipper is [DF (Mu F)] or something.
00:55:42 <dolio> Or perhaps Mu F * [DF (Mu F)]. It's been a while.
00:56:20 <Amagineer> How would I go about declaring variables in an if expression in a do construct?
00:57:40 <Saizan> Amagineer: if you want to use do-notation inside if/then/else subexpressions you've to put another "do" there
00:57:49 <handonson> Is there ANY way I can properly write and use some Chiniese/Japanese/Korean in a Haskell source code? :(
00:58:26 <handonson> I mean, with GHC.
00:58:36 <Amagineer> What I mean is 
00:59:21 <Saizan> handonson: sure, just use utf-8
00:59:33 <Amagineer> I want to do something like
00:59:33 <Amagineer> do
00:59:33 <Amagineer> stuff
00:59:33 <Amagineer>     if condition
00:59:33 <Amagineer>       then
00:59:34 <Amagineer>         x = blah
00:59:34 <Amagineer>       else
00:59:35 <Amagineer>         x = bluh
00:59:35 <Amagineer> morestuff
00:59:43 <augur> Saizan: indeed, if you treat lists as just pairs, you can make zippers much more efficient than he has them in his paper
00:59:45 <handonson> Saizan: Have you ever even tried it?
00:59:47 <Saizan> augur: ah, you can't
00:59:53 <Saizan> Amagineer: ah, you can't
00:59:55 <augur> Saizan: you cant? why not?
00:59:59 <augur> oh ok.
01:00:00 <augur> lol
01:00:06 <Starfire> handonson: You should be able to use CJK identifiers with GHC.
01:00:19 <mle> Amagineer: just declare their value to be the result of the if...
01:00:33 <Amagineer> Thanks
01:00:34 <mle> let x = if cond then A else B
01:00:51 <handonson> Starfire: Well, anyone would hardly need to use CJK identifiers. I want Strings.
01:01:06 <Starfire> handonson: Those should work too, AFAIK.
01:01:15 <Saizan> they do work.
01:01:17 <mle> hmm, need a standard for utf-t6
01:01:18 <Starfire> handonson: http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
01:01:24 <handonson> No they don't.
01:02:16 <mle> i.e. unicode transport over a stream of 6trits
01:02:16 <Saizan> handonson: explain the problem you're having, please?:)
01:02:46 <handonson> Try compilng and executing main = putStrLn "(some CJK)" and see if the result is exactly the same as "(some CJK)".
01:03:19 <handonson> I'm quite surprised that you people are not even aware of this.
01:03:22 <Saizan> handonson: which version of ghc?
01:03:41 <handonson> Saizan: 6.12.1
01:03:43 <Saizan> and is CJK an encoding?
01:03:52 <handonson> Huh? No.
01:04:06 <handonson> CJK are characters.
01:04:07 <mle> CJK is a class of characters available in many encodings; ideographics
01:04:07 <augur> Saizan: left (Loc (x:xs) ys) = Loc x xs:ys ;   right (Loc (x:xs) ys) = Loc xs x:ys
01:04:16 <mle> Chinese/Japanese/Korean
01:04:59 <augur> using [Top] as the base case for ys. e.g. push xs = Loc xs [Top]
01:05:40 <Saizan> handonson: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26899#a26899
01:05:40 <handonson> If you try compiling and executing main = putStrLn "안녕", you will see "HU" instead of "안녕"
01:06:18 <Starfire> handonson: main = putStrLn "???" works for me.
01:06:28 * gwern wonders what handonson is writing. 'an-yang'?
01:06:33 <augur> you just have to have reverse operations   unleft (Loc x xs:ys) = Loc x:xs ys ;  unright (Loc xs x:ys) = Loc x:xs ys
01:06:42 <Starfire> Except that my IRC client refuses to output unicode, apparently. :P
01:06:43 <handonson> gwern: "An-Nyeong"
01:06:48 <augur> and pop (Loc xs [Top]) = xs
01:06:53 <gwern> handonson: what's that?
01:07:07 <handonson> gwern: Hello
01:07:12 <gwern> ah
01:07:18 <gwern> you forgot the 'world' then
01:07:20 <augur> that would be the barker-shan simplification to this
01:07:21 <Saizan> handonson: are your .hs files utf8?
01:07:26 <Starfire> handonson: Are you sure that your console locale settings etc. are all correct, and that you have saved your source file as UTF-8?
01:08:35 <handonson> Saizan: yup
01:08:56 <Saizan> i guess it's a problem with your locale/terminal then
01:09:19 <Saizan> since 6.12 ghc uses your locale to determine the input/output encoding
01:09:22 <Starfire> handonson: try to "export LC_ALL=en_US.UTF-8" before running the program.
01:12:10 <handonson> oh dear. I've just tried to tweak some settings of my console, and totally screwed it up. now it's printing a good sequence of mojibake.
01:12:42 <handonson> let me restart this.
01:19:39 <augur> handonson, Jafet: whats this styff with natural languages you're talking about tho?
01:19:49 <augur> i take it Parsec is some sort of parser?
01:20:20 <FunctorSalad> maybe your characters are operator token characters?
01:20:24 <Blkt> good day everyone
01:21:02 <FunctorSalad> nevermind my last line if you have the problem in string literals too
01:21:32 <FunctorSalad> Blkt: good day :)
01:22:26 <Axman6> argh! so bored!
01:22:58 <FunctorSalad> surely some tickets are feeling lonely Axman6 ;)
01:23:16 <gwern> voting on proposals is easy and rewarding
01:23:41 <FunctorSalad> we have that now?
01:23:53 <FunctorSalad> (regularly)
01:24:39 <gwern> I mean on reddit
01:24:42 <gwern> that subreddit
01:25:30 * tibbe is bored too.
01:25:45 <Jafet> There's something lower than reddit?
01:26:02 <Blkt> hi there FunctorSalad 
01:27:11 <gwern> Jafet: digg
01:27:14 <gwern> and facebook
01:27:38 <Jafet> Well, in haskell's hill sphere
01:30:36 <handonson> augur: Parsec is a parser with its unique approach, "combining" smaller parsers to construct a full-featured parser.
01:30:41 <handonson> The smaller parsers provided by Parsec are named like "many" or "oneOf" or "space"
01:30:44 <handonson> and the combination of these parsers look very similar to the natural language we use for describing the format.
01:31:12 <augur> ahh interesting
01:31:27 <augur> and whats this chomskyitis? XP
01:31:30 <quicksilver> handonson: not remotely unique, actually. Well-known in the literature for many years, and there are loads of other examples.
01:31:32 <handonson> That's why I said it has a side-effect of making me to think every English sentence around me is a Parsec parser.
01:31:34 <Jafet> (They do?)
01:31:47 <etpace> I have a simple: (noneOf "\n," `sepBy` (char ',')) and having import Text.Parsec etc, it complains that i need to add an instance decleration for Stream s m Char
01:31:50 <etpace> any ideas?
01:32:06 <augur> handonson: maybe they ARE a parsec parser :o
01:32:22 <handonson> the notorious MR again
01:32:28 <augur> maybe sentences in english are merely parsers for themselves!
01:32:29 <FunctorSalad> handonson: "reset" will fix your terminal too
01:32:31 <augur> :O
01:33:14 <handonson> quicksilver: purely out of curiosity i'd ask, would you name one for me?
01:33:54 <quicksilver> handonson: polyparse
01:33:55 <handonson> etpace: you may try adding {-# LANGUAGE NoMonomorphismRestriction #-} in the beginning of your source code.
01:33:56 <gwern> FunctorSalad: is that the same as 'clear'?
01:34:23 <FunctorSalad> gwern: AFAIK no
01:34:56 <FunctorSalad> gwern: 'reset' resets the arcana you can change with stty, AFAIK
01:44:18 <handonson> augur: For a precise definition of chomskyitis you should ask J·afet, but as explaining one's own joke is the most sinful thing in the world, I'd try instead:
01:44:21 <handonson> "Chomsky" (Noam Chomsky, the great linguist of our age whose theory is still actively learned and used in, for example, making parsers) + "-itis" (a suffix meaning "mental condition of being mad about ...")
01:45:11 <augur> well, i wouldnt say that chomsky's theories are very widely used at all, but ok
01:45:25 <c_wraith> chomsky formulated the description of languages as regular, context-free, and context-sensitive
01:45:34 <Jafet> Chomsky himself made a full recovery, and is now a leading expert on political natural language writing
01:45:40 <augur> and unrestricted
01:46:00 <c_wraith> and, IIRC, proved that those correspond to DFAs, PDAs, and Turing Machines
01:46:00 <augur> im quite aware of chomsky's contributions to our understanding of language ;)
01:46:29 <c_wraith> meaning he made quite a link between linguistics and computer science
01:46:38 <augur> that he did
01:46:39 <handonson> augur: he is still the most frequently quoted (in research papers) person among researchers who are still living
01:46:50 <augur> i know this as well :P
01:47:12 <handonson> undoubtedly whose theory is most actively being learned among everyone
01:47:34 <augur> if by his theory you mean the equivalencies in formal language theory, i suppose so
01:50:32 <qwebirc31535> @pl (\(a, b) -> ([a], b))
01:50:33 <lambdabot> first return
01:51:01 <augur> tho, handonson, for me his contributions to language go far far beyond the hierarchy
01:51:23 <c_wraith> I'm not going to say much about his other work.  But that was, in itself, a pretty groundbreaking discovery.  I appreciate that work regardless of his later political work
01:51:42 <augur> his political work is secondary for me
01:52:07 <handonson> I like him.
01:52:13 <handonson> Well, not that it matters at all...
01:52:22 <augur> i mean, i like his political work, but as far as language is concerned, his early work on language isn't as important to me as his later work
01:53:49 <dolio> But do you like him like him?
01:54:01 <augur> phrasal reduplication! :D
01:54:13 <augur> have i mentioned im a linguist? :P
01:54:18 <augur> that might clear up some things
01:56:06 <handonson> ByteString definitely needs to be in Prelude in Haskell Prime.
01:56:33 <handonson> Renamed to "Bytes", I'd prefer
01:57:11 <gwern> > 17.3 - 15.6
01:57:12 <lambdabot>   1.700000000000001
01:57:27 <gwern> what
01:57:27 <c_wraith> close enough for government work
01:57:37 <c_wraith> fp rounding error
01:57:43 <c_wraith> never believe an fp result
01:57:44 <gwern> > (17.3::CReal) - (15.6::CReal)
01:57:45 <lambdabot>   1.7
01:57:47 <gwern> oy
01:58:18 <c_wraith> ...  you didn't need to annotate both of them. :P
01:58:19 <gwern> c_wraith: I can't help but feel that that oughn't've run into a rounding error, the decimals are so large
01:58:21 <dolio> One of the previous Haskell standards had a binary blob type in the prelude.
01:58:38 <c_wraith> neither .3 nor .6 can be represented exactly in IEEE754
01:58:48 <gwern> death to the IEEE!
01:59:21 <Jafet> AIEEE
01:59:25 <c_wraith> only things that are sums of powers of two.  .5 and .25 and even .625...  those can be represented exactly
01:59:31 <c_wraith> .3, and .6?  no
01:59:48 <handonson> and functions like readFile, writeFile should be changed to handle ByteStrings by default, I think.
02:00:00 <wli> 3/5 and 3/10
02:00:45 <c_wraith> wli: those aren't IEEE 754 floating point representations
02:01:08 * hackagebot constructive-algebra 0.1.3 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.1.3 (AndersMortberg)
02:01:17 <FunctorSalad> and readProcess!
02:01:27 <wli> The point was to make the denominator more visible (since the denominator isn't 2^n it's not representable).
02:01:31 <FunctorSalad> though you can essentially just copypasta the code
02:01:41 <c_wraith> ah, good point.
02:02:55 <quicksilver> it's convention to display FP numbers to (at least) one fewer DP than the stored precision
02:02:59 <quicksilver> to 'hide' rounding errors
02:03:04 <quicksilver> that's what pocket calculators do
02:03:09 <quicksilver> but apparently haskell doesn't.
02:03:52 <wli> There's some other garbage with needing exact multiples of 2^n once you need an exponent and some limits on numerators.
02:04:02 <c_wraith> I kind of liked the convention java used for display: display the fewest bits such that the parse function would produce the exact same bit pattern, for normalized non-error fp numbers.
02:04:11 <c_wraith> err, display the fewest digits
02:04:33 <quicksilver> makes some sense, but in that case you will need 1.70...01 in this case
02:04:38 <quicksilver> it is a different bit pattern from 1.7
02:04:46 <c_wraith> Of course, that convention upset C programmers constantly.
02:05:52 <quicksilver> printf arbitrarily does 6dp for doubles + floats I think
02:06:04 <quicksilver> certainly it appears to here. So that sum yileds 1.700000
02:07:29 <wli> Floating point IO revolves a lot around shoehorning floating point numbers into tables and so on. Aligning decimal points, field widths, etc.
02:08:28 <quicksilver> if you're using floating point "seriously" then you understand the rounding issues and you choose rounding precisions appropriately.
02:08:48 <quicksilver> it's possibly to bound the errors from, e.g, addition.
02:09:06 <quicksilver> maximum error from n additions or subtractions is n epsilon, I think. If epsilon is the right name.
02:09:23 <quicksilver> but I'm sure most of the time people don't think about it that carefully.
02:11:26 <c_wraith> I only use fp in throwaway code, or code where I know it's just an approximation
02:12:01 <wli> Radix conversion makes the bits hard to translate to display digits.
02:13:37 <quicksilver> c_wraith: yes, in serious code it's often more appropriate to use fp than fp.
02:13:45 <quicksilver> yay for ambiguous abbreviations!
02:13:50 <c_wraith> yep! :)
02:16:34 <wli> Arbitrary-precision integers with enough syntactic sugar to avoid making them really hard to use are a big plus.
02:17:21 <wli> Floating point with some kind of property like that is a much bigger question wrt. API's etc.
02:17:22 <quicksilver> wli: although you have to be careful with execution times.
02:18:15 <quicksilver> personally I'd like fast, machine-native ints with signalled overflow
02:18:21 <quicksilver> unfortunately, I can not haz those :(
02:18:46 <quicksilver> which is particularly annoying since all hardware has a way to signal integer overflow.
02:18:50 <wli> The bigger question is what you do when they've overflowed.
02:19:03 <quicksilver> kill the program would be fine as a first approximation.
02:19:07 <wli> i.e. the arbitrary precision library
02:20:54 <wli> That would be avoiding the question since you're not executing once they've overflowed.
02:21:27 <c_wraith> in many cases, that's a reasonable approximation.
02:21:48 <c_wraith> "these numbers are bigger than this program was designed for.  crash, instead of proceeding with incorrect values"
02:22:25 <Gwern-away> my assembler text told me that C programs can't access the overflow flag
02:22:30 <Gwern-away> I found that kind of odd
02:22:57 <wli> That's not entirely true, but they have to use a library that does it in asm.
02:23:27 <wli> The standards aren't floating around for integer overflow either.
02:26:14 <wli> Kernels do this kind of crap all the time, though for the most part they ignore this particular issue (there's probably an exception somewhere).
02:26:50 <wli> They're littered with all these inline asm macro libraries etc.
02:50:44 <augur> i dont buy this derivative data type stuff
02:50:54 <augur> i think they got their math wrong
02:51:12 <augur> abbot et al, i mean
02:52:25 <Saizan> what doesn't work for you, in particular?
02:55:05 <augur> well, i dont understand what product is supposed to be
02:55:13 <augur> what is F*G by itself
02:56:12 <Saizan> pairs/cartesian product
02:56:58 <augur> truly? so if F = [1,2] and G = [3,4]
02:57:03 <Saizan> i.e. data A = C1 X Y | C2 Z would be written as A = (X*Y) + Z
02:57:06 <dolio> Those aren't types.
02:57:14 <augur> is it [(x,y) | x <- F, y <- G]
02:57:18 <augur> or is it (F,G)?
02:57:25 <Saizan> F and G aren't types
02:57:47 <augur> right but a cartesian product isnt a type either
02:58:02 <wli> Sums are coproducts.
02:58:15 <augur> and the abbot et al paper doesnt present it in terms of types
02:58:21 <Saizan> well, if you consider set as types it is
02:58:40 <wli> The rundown on differentiating F*G i.e. (F,G) might do something.
02:58:41 <augur> ok so F*G is the type (F,G) then?
02:58:46 <Saizan> yeah
02:58:55 <augur> ok
02:59:13 <augur> oh i think i see now
03:00:14 <augur> so d(F*G)/dX = dF/dX * G + F * dG/dX, assuming that X isnt F*G
03:01:05 <augur> well if it is, dF/dX should be empty, so dF/dX * G should be empty so the whole thing should be empty
03:01:17 <augur> aha!
03:01:20 <augur> interesting.
03:01:38 <augur> but is that correct? should dX/dX be Top, not {}?
03:02:12 <augur> where Top is the context, i mean, not the type. whatever the type of that context is, i suppose
03:03:36 <Saizan> dX/dX = 1, i'd say
03:04:30 <augur> but then what is dF/dX if F doesnt have any X's? it should be empty, right?
03:05:09 <Ke> 0
03:05:15 <Saizan> sure, it's like differentiating constants
03:05:33 <Saizan> well, not even like, it is that :)
03:05:36 <dolio> Yes.
03:06:37 <augur>  ok, but then what is so dF/dX for X not in F is empty, so dF/dX * G is empty so d(F*G)/dX is empty if X not in F or G
03:07:05 <augur> but if X = F*G then d(F*G)/dX = dX/dX
03:08:14 <augur> so we'd have a contradiction depending on which rule we used
03:08:35 <Saizan> i think you're doing something wrong with that implicit substitution/change of variable
03:08:47 <augur> no, not really
03:09:20 <augur> d(F*G)/d(F*G) = dF/d(F*G) * G + dG/d(F*G) * F
03:10:50 <dolio> You don't differentiate types with respect to arbitrary other types.
03:11:03 <augur> why not then
03:11:28 <Saizan> btw, wouldn't that be a problem in calculus too? there's nothing specific about types in there
03:11:31 <dolio> Because you don't do that in calculus either. If f(x) = 2*x, what is df/d2?
03:12:11 <dolio> What you do is differentiate type expressions parameterized by some variable with respect to that variable.
03:12:14 <augur> Saizan: no, because dx/dx is 0, but dX/dX cant be 0, unless 0 = {Top}
03:13:01 <augur> df/d2 makes no sense because 2 isnt a variable and never is
03:13:02 <Saizan> since when dx/dx is 0 in calculus?
03:13:13 <dolio> F*G isn't a variable, either.
03:13:17 <augur> er, sorry, 1. your right.
03:13:23 <augur> hah
03:13:25 <augur> :D
03:13:32 <augur> F*G isnt a variable no, but neither is X
03:13:41 <augur> the analogy is variables ~ types
03:13:48 <Saizan> no
03:13:51 <augur> or rather, functions ~ types
03:14:02 <Saizan> functions ~ parameterized types
03:14:07 <Saizan> variables ~ type variables
03:15:01 <augur> eh.. i suppose. i might be getting tripped up with calculus' abuse of notation crap
03:15:28 <dolio> I think you can couch this all in terms of functors.
03:15:29 <Saizan> yeah, it's a shame that they have imported that abuse :)
03:15:38 <augur> given that you have shit like df/dx = df/dg * dg/fx
03:15:53 <augur> dx***
03:16:07 <dolio> X |-> F X * G X is differentiable, and gives X |-> F X * DG X + DF X * G X
03:16:39 <dolio> Or, if you just talk about functors F * G => F * DG + DF * G, where * and + are lifted point-wise.
03:17:10 <dolio> I => K 1, I being the identity functor, and K T being the constantly T-valued functor.
03:17:14 <augur> yeah ok
03:17:15 <dolio> K T => K 0
03:17:20 <augur> it makes sense now
03:17:40 <augur> i was reading their paper with too much emphasis on their visualizations
03:18:03 <augur> which implied that the F, G, and X things were actual objects, not types
03:19:09 <augur> tho i suppose even if it were objects, d(f*g) = df*g + f*dg
03:19:32 <augur> but i think thats the extent of it
03:21:03 <augur> no but wait
03:21:58 <augur> for them, is dF inhabited by the context for a F alone?
03:22:08 <augur> it cant be, right
03:22:53 <augur> dList isnt possible a hole filled by a list, its a list with a hole in it
03:22:54 <augur> right
03:23:36 <augur> ok, now it makes sense even more
03:23:42 <augur> i was muddling things. :D
03:39:49 * ManateeLazyCat GTK+ some trick almost crazy me.....
03:41:26 <augur> hm. Saizan, is the typical zipper implemented in the inverted tree fashion that Huet does it, or do people generally just collect up paths of partial trees?
03:59:49 <tiryo> I have a haskell project that I manage with cabal. It creates an 'Executable', however, I also wish to expose it as a library. Can I do this in my .cabal file?
04:00:01 <dcoutts> yes
04:00:31 <tiryo> I want to define Library "Exposed-Modules" with "Executable" too...
04:00:40 <eflister> can anyone help me implement  (b -> c)  ->   (a -> m b)   ->  (a -> m c)
04:01:05 <tiryo> do I just put both in? Any example I can look at dcoutts?
04:01:09 <dcoutts> tiryo: yes, that's exactly what you do
04:01:18 <tiryo> dcoutts: thanks
04:01:39 <dcoutts> tiryo: any on hackage that are listed as lib and exe
04:02:05 <Botje> :t fmap
04:02:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:02:22 <Botje> eflister: take a look at fmap (or liftM)
04:02:39 <aristid> eflister: \m k a -> (m a) >>= k
04:02:44 <aristid> :t \m k a -> (m a) >>= k
04:02:44 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
04:02:49 <aristid> oh wait
04:02:50 <aristid> gnn
04:03:45 <eflister> botje: yeah i just don't know how to get that extra level of arguments on the last two arguments
04:04:00 <ManateeLazyCat> dcoutts: Any APIs to access bit-field in C structure? Or i must write C function to handle this?
04:04:26 <aristid> :t \k m a -> (m a) >>= return . 
04:04:26 <lambdabot> parse error (possibly incorrect indentation)
04:04:31 <dcoutts> ManateeLazyCat: that's what the Flags class is for in gtk2hs
04:04:33 <aristid> :t \k m a -> (m a) >>= return . k
04:04:33 <lambdabot> forall t (m :: * -> *) a a1. (Monad m) => (a -> a1) -> (t -> m a) -> t -> m a1
04:04:42 <aristid> eflister: does this look right?
04:04:50 <eflister> aristid: yeah thx!
04:05:37 <ManateeLazyCat> dcoutts: I don't understand, example have field "guint is_modifier : 1;" in C structure, how to serialized it's value?
04:05:53 <aristid> :t \a b c -> fmap a (b c)
04:05:54 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> f a) -> t -> f b
04:05:58 <ManateeLazyCat> dcoutts: Axel said it's impossible to do that except write some C fucntion.
04:06:04 <aristid> eflister: this seems to be even more general
04:06:07 <aristid> @pl \a b c -> fmap a (b c)
04:06:07 <lambdabot> (.) . fmap
04:06:24 <dcoutts> ManateeLazyCat: ah ok, yes. I thought you just meant an int type that is used for a bunch of flags.
04:06:48 <ManateeLazyCat> dcoutts: So it's impossible if i don't write C function?
04:07:04 <ManateeLazyCat> dcoutts: Ok,
04:07:25 <dcoutts> ManateeLazyCat: the FFI does not directly support bitfields, nor does c2hs I think
04:08:28 <ManateeLazyCat> dcoutts: Hmm, i try to avoid write C function to do that since it's easy to break....
04:09:03 <ManateeLazyCat> dcoutts: Ok, thanks for your help, i find another way to avoid access bitfield.
04:09:44 * ManateeLazyCat Research the source code of gtksocket-x11.c, then decide how to do next...
04:13:05 <aristid> eflister: and to go one more crazy, you could use fmap fmap fmap
04:14:15 <dibblego> @type let (∘∘) = fmap fmap fmap in (∘∘)
04:14:16 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
04:14:34 <MHD0> Anybody know something about Control.Monad.Logic
04:14:36 <MHD0> ?
04:14:54 <dibblego> MHD0, do you have a specific concern?
04:15:02 <MHD0> I can't figgure it out
04:15:17 <MHD0> It's like a mystery in it's type sigs
04:15:50 <MHD0> And I can't seem to make it do something usefull, everytime I hit a guard that doesn't qualify, it just hits bottom
04:15:51 <Jafet> Control.Moriarty
04:17:27 <MHD0> Also the observe vs. observeAll vs. runLogic just eludes me...
04:17:46 <zygoloid> i thought Control.Monad.Logic was just the list monad with a fair >>=?
04:18:00 <MHD0> I dunno
04:18:31 <zygoloid> @type (>>-)
04:18:32 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
04:18:55 <eflister> aristid: hmm, i think i asked the wrong question.  i've got a working mapM whose first argument is (a -> m b).  but i have (b -> b) that i want to process those b's with before they are collected by the mapM.  i can't see how to get \a b c -> fmap a (b c) to work with the mapM -- mapM will be providing the c's so i can't supply them myself...
04:19:22 <zygoloid> > take 10 $ [1..] >>= (\a -> map ((,) a) [1..])
04:19:23 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
04:19:25 <zygoloid> > take 10 $ [1..] >>- (\a -> map ((,) a) [1..])
04:19:27 <lambdabot>   [(1,1),(2,1),(1,2),(3,1),(1,3),(2,2),(1,4),(4,1),(1,5),(2,3)]
04:19:33 <aristid> :t mapM
04:19:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:20:19 <aristid> eflister: i guess you should explain your problem a bit better then:)
04:21:17 <eflister> aristid: :) well i want to modify mapM's first argument with (b -> b)
04:21:29 <hpc> :t fmap
04:21:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:21:45 <MHD0> Does anyone have some snippets with Control.Monad.Logic so I can kinda get a feeling with the use of it?
04:22:00 <aristid> eflister: then i think you CAN use fmap.fmap or the other variants that i showed.
04:22:20 <eflister> :t fmap . fmap
04:22:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:22:23 <Saizan> ?type \f g -> mapM (fmap g . f) -- eflister ?
04:22:24 <lambdabot> forall a b (m :: * -> *) a1. (Functor m, Monad m) => (a1 -> m a) -> (a -> b) -> [a1] -> m [b]
04:23:06 <zygoloid> eflister: you may as well apply the (b -> b) after you do the mapM. then it's (fmap . fmap) f $ mapM g xs
04:23:33 <eflister> Saizan: that looks good
04:23:43 <aristid> eflister: maybe you are getting confused by the curriedness of \a b c -> fmap a (b c)?
04:23:56 <zygoloid> @type (fmap . fmap) ?f $ mapM ?g ?xs
04:23:57 <lambdabot> forall (f :: * -> *) b a b1. (Functor f, ?f::b1 -> b, ?g::a -> f b1, ?xs::[a], Monad f) => f [b]
04:24:13 <aristid> eflister: if you call that functions with two arguments, a function with one argument is returned, which is what mapM wants
04:24:40 <aristid> zygoloid: why move the fmap.fmap outside? is that more efficient?
04:24:46 <eflister> zygoloid: i need it to be before the mapM, cuz its purpose is to reduce what mapM is going to have to process
04:24:49 <Saizan> eflister: "\f g -> mapM (fmap g . f)" and "\f g -> (fmap . fmap) f . mapM g" are extensionally the same
04:25:52 <Saizan> oh, then maybe you want \f g -> mapM (f . g) ?
04:26:26 <Saizan> eflister: what are the actual types involved?
04:26:54 <Saizan> i can't tell if the pure function has to go before or after the monadic one.
04:27:06 <alar> I have a lib that works with ByteStrings: strict or lazy, no matter which. How can I let the choise of ByteString to user of that lib?
04:28:07 <dafis> alar: How does it work with both types?
04:28:13 <Saizan> there's no standard way to abstract over such stream types
04:28:29 <Saizan> there are some ad-hoc ones in packages like HTTP
04:28:36 <Saizan> or HSH
04:28:39 <dafis> You'd need a type class or so to work with both
04:28:43 <zygoloid> aristid: it might affect efficiency, but not much. the benefit is that it gives you more subexpressions you can factor out
04:28:45 <eflister> Saizan: fmap g . f worked :) -- f :: Map a b -> Map a b and g :: c -> IO (Map a b)
04:28:49 <alar> dafis: both bytestrings have the same interface, I simply get Word8s from it
04:28:58 <zygoloid> aristid: (basically it lets you decompose your program into more, smaller pieces)
04:29:15 <Saizan> eflister: "fmap f . g" then, surely?
04:29:24 <dafis> alar: so it works with both, depending on which module you import?
04:29:28 <aristid> eflister: what i proposed would work too. because it's the same.
04:30:12 <aristid> zygoloid: so it's considered better style?
04:30:12 <alar> dafis: yes, but I have to import one of them into the lib, to define functions that it works with
04:30:32 <eflister> Saizan: whoops, yeah i was backwards
04:30:33 <alar> and it kills the possibility ofworking with the other ByteString
04:30:55 <dafis> alar: You could use lazy ByteStrings and give a means to wrap strict ByteStrings in lazy ones
04:31:11 <dafis> not ideal, but workable
04:31:12 <alar> dafis: how?
04:31:48 <alar> @hoogle Data.ByteString.Lazy.ByteString -> Data.ByteString.Strict.ByteString
04:31:49 <lambdabot> Parse error:
04:31:49 <lambdabot>   --count=20 "Data.ByteString.Lazy.ByteString -> Data.ByteString.Strict.ByteString"
04:31:49 <lambdabot>                  ^
04:31:53 <Saizan> it's easy to convert from strict to lazy, the bytestring lib offers it.
04:32:06 <Saizan> fromChunks . (:[])
04:32:14 <dafis> alar: in your lib, import both (qualified), expose a function, toLazyBS :: S.ByteString -> L.ByteString
04:32:36 <dafis> or what Siazan: said, let the users do it themselves :)
04:32:45 <mm_freak> i'm assuming that when i write 'a >> b >> c' in the IO monad, then upon execution the results of each of these computations is forced
04:32:50 <mm_freak> is this a portable assumption?
04:32:57 <dafis> alar: and then offer the interface for lazy ByteStrings
04:33:11 <aristid> mm_freak: huh? i'd think that the results of these computations are discarded and not forced.
04:33:22 <Saizan> mm_freak: the results don't get any forcing
04:33:24 <dafis> mm_freak, no, the *results* won't be forced
04:33:25 <aristid> except for c's result of course
04:33:40 <zygoloid> aristid: it's considered better style by me, at least :)
04:33:54 <mm_freak> hmm
04:34:03 <mm_freak> then what exactly is strict in the IO monad?
04:34:13 <Saizan> mm_freak: IO doesn't add any extra strictness, it only evaluates things enough to perform the side-effects
04:34:14 <aristid> mm_freak: the action itself i suppose
04:34:51 <aristid> zygoloid: fair enough, i suppose i have locality bias from doing too much c++ ;)
04:34:55 <mm_freak> how can you force evaluation of a computation without forcing anything about its result?
04:35:04 <alar> (>>=) is strict by its first argument
04:35:08 <alar> in IO monad
04:35:11 <Saizan> mm_freak: using strict or lazy to talk about the IO monad doesn't make much sense, unless you're talking about (>>=) being strict in its first argument
04:35:22 <Saizan> mm_freak: define computation?
04:35:40 <Saizan> the first argument of (>>=) is an IO action not its result, btw
04:35:49 <mm_freak> ok, let me ask differently
04:36:13 <mm_freak> the first argument of (>>=) is a computation (in my terminology)
04:36:35 <aristid>  > return undefined >> print "Hello"
04:36:35 <aristid> "Hello"
04:36:42 <quicksilver> (return <complex pure expression>) is an IO computation which can be both executed *and* evaluated without forcing the value inside.
04:36:45 <aristid> mm_freak: you see, the undefined is not forced
04:36:48 <MHD0> mm_freak: print 1 >> print 2 -- both return () but print 1's resulting () is not evaluated
04:36:55 <Saizan> undefined >> print "hello" -> you get an error
04:37:08 <mm_freak> that doesn't make sense
04:37:20 <MHD0> mm_freak: undefined :: a
04:37:20 <mm_freak> Prelude> let x = putStrLn "x"
04:37:20 <aristid> yes, it does
04:37:20 <mm_freak> Prelude> x `seq` putStrLn "y"
04:37:20 <mm_freak> y
04:37:35 <aristid> `seq` ist not >>
04:37:40 <mm_freak> forcing a computation doesn't make it evaluate
04:37:41 <MHD0> mm_freak: seq doesn't work that way
04:37:55 <Jafet> That evaluates putStrLn "x", producing a value of type IO().
04:38:05 <mm_freak> it just forces, you know, the computation…  in my mind, forcing computation means "building a program" in a sense
04:38:08 <MHD0> mm_freak: seq evaluates to WHNF, >> evaluates IO to end.
04:38:08 <mm_freak> not executing it
04:38:18 <Saizan> mm_freak: we usually use the term evaluate for what seq does, and execute to mean "perform side-effects"
04:38:25 <MHD0> mm_freak: executing /= evaluating
04:38:46 <Saizan> so yeah, in the #haskell terminology evaluate /= execute
04:38:49 <aristid> mm_freak: just try it out. type return undefined >> print "Hello" in ghci
04:38:57 <mm_freak> i get that
04:39:15 <aristid> then try print "a" `seq` print "b"
04:39:21 <aristid> you will notice that only b is printed
04:39:28 <mm_freak> i just don't get how this "forcing execution" fits into the theoretical model
04:39:50 <MHD0> mm_freak: Programming IS LITERALLY ALL ABOUT side effects
04:40:05 <MHD0> mm_freak: Without it, haskell would be boooring.
04:40:07 <Saizan> mm_freak: where have you read about "forcing execution"?
04:40:15 <Saizan> MHD0: i think we are way past that
04:40:26 <MHD0> Saizan: Oh, pray tell.
04:40:37 <Jafet> mm_freak, it obviously fits into the theoretical model of Haskell, which is not the same as the theoretical model of lambda calculus or whatever
04:40:43 <MHD0> Saizan: Oh, sorry read that wrong
04:41:03 <quicksilver> mm_freak: there isn't really a theoretical model of IO - or not one written down, anyway
04:41:07 <MHD0> Saizan: Read it as "There are ways past that" :P
04:41:14 <mm_freak> Jafet: not that model…  i think you don't understand the question
04:41:18 <quicksilver> clearly haskell scholars have a notion of what kind of theoretical model they expect.
04:41:44 <mm_freak> quicksilver: fair enough
04:41:49 <quicksilver> you might consider whether any of your questions can be re-phrased in terms of the other monads
04:41:59 <quicksilver> e.g. the state monad is on clear theoretical footing.
04:42:03 <mm_freak> i model the IO monad as one state monad with a very big state
04:42:10 <Jafet> Oh, that model.
04:42:11 <MHD0> mm_freak: try working with some other monads, you might figgue it out on your own
04:42:19 <mm_freak> but then there is no execution model, just an evaluation model
04:42:37 <MHD0> mm_freak: That's actually true
04:42:39 <mm_freak> because the IO monad by itself doesn't say anything about execution…  it couldn't even express it
04:42:49 <quicksilver> mm_freak: that's not a great model, by the way
04:42:58 <Saizan> mm_freak: that model is broken
04:43:24 <mm_freak> broken?  i'd say it's incomplete (concurrency)
04:46:17 <Saizan> if you use IO a = World -> (World,a), you can't explain how "(forever (print 1))" differs from "f s = f s", extensionally they are the same function
04:46:42 <Saizan> s :: World,  there
04:48:07 <mm_freak> yes, and that's why IO needs a separate execution model, which says something like:  whenever a new World value pops up, update the world
04:48:29 <Saizan> right, you've to look at the intermediate steps
04:48:31 <MHD0> Why doesn't this work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26911#a26911
04:48:45 <mm_freak> the two programs are semantically equivalent…  this is a direct consequence of haskell's type system
04:48:55 <mm_freak> so they can only differ in execution
04:49:06 <Saizan> then seeing "IO a" as an AST for an imperative language which gets interpreted by the RTS makes more sense
04:49:32 <MHD0> no wailt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26911#a26912
04:49:33 <Saizan> and it's easier to show the separation between evaluation of actions and execution of the side-effects they describe
04:49:51 <Saizan> and how the latter is not necessarily tied to evaluation of their results
04:50:38 <mm_freak> MHD0: i think the Logic monad has different semantics from the list monad
04:50:51 <Saizan> MHD0: what output do you actually get?
04:51:22 <MHD0> mm_freak: usually I just get to printing the list to 100 then it hits infinite loop.
04:51:25 <Saizan> MHD0: oh, also you lack some parenthese there..
04:51:29 <mm_freak> Saizan: the two programs you mentioned are semantically equivalent in all models
04:51:37 <mm_freak> so in the sense you described all models are broken
04:51:40 <MHD0> Saizan: Nvm, you get the idea
04:51:49 <Saizan> MHD0: eh? no.
04:52:07 <Saizan> mm_freak: eh? no.
04:52:11 <Saizan> that was for you :)
04:52:18 <mm_freak> ah =)
04:52:49 <Saizan> MHD0: well, you get an infinite loop because it's scanning all the naturals to try to find another that's less than 100
04:52:57 <MHD0> ok
04:53:00 <MHD0> w8
04:53:01 <Saizan> MHD0: it doesn't know that there won't be one
04:53:31 <Saizan> try "filter (<10) [1..]" you'll get a similar behaviour
04:53:35 <akosch> i remember there was a pattern matching syntax using @
04:53:46 <akosch> but i can't remember how it works
04:53:51 <akosch> could someone explain?
04:54:04 <MHD0> akosch: r @ (x:xs) -- r is the whole list
04:54:18 <mm_freak> Saizan, MHD0:  i don't see 'testing' getting used anywhere
04:54:19 <akosch> MHD0: thx
04:54:24 <mm_freak> i thought that 'main' is failing
04:54:48 <MHD0> mm_freak: Nvm that then -.- I fail today
04:55:00 <mm_freak> hehe
04:55:05 <Jafet> > genericLength [1..] > (fromInteger 42 :: Nat)
04:55:06 <lambdabot>   Not in scope: type constructor or class `Nat'
04:55:59 <mm_freak> Saizan: well, the state monad model gives you an evaluation model, so you can /ask/ for semantic equivalence
04:56:41 <mm_freak> i think that the AST approach just circumvents this by not giving an evaluation model at all
04:56:46 <Saizan> what's the point of having a model that gives you an equivalence that disregards all the important stuff about what you want to model?
04:57:16 <mm_freak> well, it makes it fit into the language, so you can reason about it
04:57:25 <mm_freak> the state monad model makes IO less of a special case
04:57:58 <Saizan> i think it makes more of a special case, because you're basically using side-effecting functions to make it work
04:58:19 <mm_freak> what do you mean?
04:58:43 <MHD0> Here we go, fixed my meaning: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26913#a26913
04:58:45 <Saizan> the part about updating worlds
04:59:13 <mm_freak> "updating worlds" doesn't make much sense, unless you have uniqueness types or something of that sort
04:59:31 <MHD0> If there just was a true Logic a instread of LogicT Identity a
04:59:37 <akosch> can i somehow rewrite this using scanl or foldl? http://pastebin.com/0J4DnKzm
04:59:48 <Saizan> i agree with saying that model doesn't make sense :)
04:59:55 <mm_freak> MHD0: ?
05:00:10 <mm_freak> Saizan: hehe, ok…  let's leave it at that =)
05:00:48 <MHD0> mm_freak: I just can't grok the inner workings of MonadTs
05:01:03 <MHD0> understand the concept, not the mechanics... yet
05:01:17 <mm_freak> MHD0: just remember that MonadT Id = Monad
05:01:31 <Saizan> MHD0: how is that related to your problem?
05:01:36 <mm_freak> once you figure out how you can use something different from Id, you get quite some monadic power =)
05:01:41 <MHD0> Yes, but that doesn't mean I can read LogicT definition.
05:02:19 <MHD0> mm_freak: I know HOW and WHY MonadT's are awesome, I just cna't understand the machinery behind the awesome... 
05:02:41 <mm_freak> MHD0: the result of a List computation is of type [a], i.e. multiple values
05:02:46 <Saizan> Logic definition wouldn't be very simple either.. though you could read oleg's paper
05:02:59 <mm_freak> the result of a ListT m computation is of type m [a], i.e. a computation, which could give multiple values
05:03:11 <MHD0> mm_freak: I wish the Logic a definition was not LogicT Id, so that I could read and understand it.
05:03:19 <mm_freak> and that's it, basically
05:03:31 <aristid> MHD0: Logic is a newtype, so it is not LogicT
05:03:32 <Saizan> mm_freak: using m [a] for ListT gives you a monad only when m is a commutative monad
05:03:33 <MHD0> mm_freak; I know the principles, I can't read the code.
05:03:54 <mm_freak> Saizan: i know, that's why i used ListT and not LogicT =)
05:04:38 <Saizan> MHD0: just remove the 'm' from the type signatures mentally?:)
05:04:48 <MHD0> aristid: Read the source code for Control.Monad.Logic and please inform me the line number of the definition of instance Monad Logic
05:04:57 <mm_freak> and remove the returns =)
05:05:47 <Saizan> MHD0: btw, to use it you shouldn't need to look at the implementation
05:05:58 <aristid> MHD0: instance MonadLogic Logic where    msplit m = Logic . liftM (liftM (fmap Logic)) $ msplit (unLogic m)
05:06:02 <MHD0> Saizan: Are you deliberately misunderstanding me? I cannot read the code, it's very hard to understand for me how the code works. ideally I'd like to write my own verison of a monad to get a feel for it, but when I cna't understand the definition in the forst place, it gets kinda difficult.
05:06:20 <mm_freak> MHD0: note that for the identity monad 'return' is theoretically the same as 'id'
05:06:32 <MHD0> mm_freak: I know that already
05:06:37 <aristid> MHD0: from http://hackage.haskell.org/packages/archive/logict/0.4/doc/html/src/Control-Monad-Logic.html (no line numbers :/)
05:06:46 <mm_freak> so just remove all returns and, as Saizan says, all 'm's
05:06:54 <aavogt> you don't have to be able to make something to be able to use it
05:07:32 <MHD0> aristid: newtype Logic a = Logic { unLogic :: LogicT Identity a }
05:07:43 <aristid> MHD0: yeah, as i said, it's a newtype
05:07:49 <aristid> it's not directly LogicT :)
05:07:50 <MHD0> I guess I'll go stare at the source code until it clicks...
05:08:17 <Saizan> MHD0: no, i just said that if you're mainly interested in using Logic, you shouldn't care so much about it's implementation
05:08:18 <MHD0> aristid: that reduce the problem to a previously unsolved one and we're still at square one...
05:08:33 <mm_freak> MHD0: i don't understand the Logic monad either
05:08:44 <MHD0> Saizan: I don't know how it works, can't make it do simple stuff...
05:08:55 <MHD0> Saizan: I'm eff'd
05:09:13 <MHD0> Saizan: I have literally no idea how to use even the interface...
05:09:37 <Saizan> MHD0: well your paste is not so far off
05:09:40 <MHD0> I can see no reason to even have three different observes, and what's the deal with runLogic?
05:09:56 <zygoloid> MHD0: you may find it beneficial to: 1) copy-paste the code somewhere you can modify it, 2) change the 'instance Monad (LogicT m)' to 'instance Monad (LogicT Identity)', then 3) systematically replace the Identity monad operations with what they actually do
05:09:57 <Saizan> MHD0: it's just that filtering an infinite stream is never going to give you a definite result
05:09:57 <MHD0> Saizan: Pray tell then, what need i do?
05:10:06 <mm_freak> MHD0: 'return x' is a computation, which results in a single value and 'mplus x y' or 'x <|> y' gives a computation, which results in the results of both x and y
05:10:26 <zygoloid> MHD0: then you should have a Monad instance for Logic with no transformer stuff in it
05:10:32 <MHD0> How do I make it track lists then?
05:11:13 <MHD0> If I wanna solve einsteins riddle, which can be done in 20 lines of prolog, I need lists...
05:11:49 <mm_freak> MHD0: why don't you just use the list monad anyway?
05:12:31 <mm_freak> the list monad is a MonadLogic instance, too
05:12:57 <zygoloid> MHD0: in order to understand what MonadLogic is for and how it works, you should probably first try to understand the list monad and what its shortcomings are wrt infinite lists.
05:13:01 <MHD0> nvm.
05:13:12 <Saizan> MHD0: do you have a less contrived example? because otherwise i'd just use "takeWhile (<100) (observeAll test)"
05:13:31 <MHD0> Saizan: not really...
05:15:04 <mm_freak> > foldr (<|>) empty . map pure $ [1..10]
05:15:05 <lambdabot>   Ambiguous occurrence `empty'
05:15:05 <lambdabot>  It could refer to either `Control.Applicative...
05:15:14 <mm_freak> > foldr (<|>) Control.Applicative.empty . map pure $ [1..10]
05:15:15 <lambdabot>   No instance for (GHC.Show.Show (f a))
05:15:15 <lambdabot>    arising from a use of `M2776580247...
05:15:33 <mm_freak> > foldr (<|>) Control.Applicative.empty . map pure $ [1..10] :: [Integer]
05:15:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:15:42 <mm_freak> > foldr (<|>) Control.Applicative.empty . map pure $ [1..10] :: Logic Integer
05:15:43 <lambdabot>   No instance for (GHC.Show.Show
05:15:43 <lambdabot>                     (Control.Monad.Logic.Log...
05:15:53 <mm_freak> > observerAll (foldr (<|>) Control.Applicative.empty . map pure $ [1..10] :: Logic Integer)
05:15:54 <lambdabot>   Not in scope: `observerAll'
05:16:00 <mm_freak> > observeAll (foldr (<|>) Control.Applicative.empty . map pure $ [1..10] :: Logic Integer)
05:16:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:16:19 <Saizan> MHD0: and the different observe functions are just for convenience, they could all be written in terms of runLogic
05:16:44 <mm_freak> what's the big difference between Logic and []?
05:17:15 <MHD0> mm_freak: I can do stuff with [] but not Logic?
05:17:41 <Saizan> mm_freak: efficiency
05:17:49 <mm_freak> MHD0: i'd expect the opposite, because to my limited mind they are equivalent
05:18:16 <mm_freak> Saizan: Logic is more efficient?  but only if i disrespect stream fusion and stuff, right?
05:18:24 <mm_freak> s/disrespect/disregard/
05:20:15 <Saizan> mm_freak: not sure how much fusion applies when you're using [] for backtracking computations
05:20:59 <mm_freak> probably not much, unless you use list functions somewhere in the middle
05:21:54 <Saizan> though a big point of foldr/build fusion is to optimize list comprehensions
05:21:57 <Saizan> so it does apply
05:22:35 <mm_freak> say it doesn't…  is Logic more efficient then?
05:22:44 <Saizan> anyhow, it's been a while since i've read LogicT paper :)
05:22:48 <mm_freak> say you really only collect values and you need all of them
05:23:01 <mm_freak> separately that is
05:23:23 <handonson> Is there any way I can writeFile with a file name of Chinese/Japanese/Korean?
05:25:04 <quicksilver> yes, but it's OS-dependent
05:25:15 <quicksilver> you will have to manually encode it into whatever encoding your OS uses in paths
05:25:50 <quicksilver> UTF-16 for win32, I believe. I further believe there is no formal standard for Linux but that GNOME + KDE user tools treat paths as UTF8.
05:26:08 <Saizan> mm_freak: Logic's definition is basically the church encoding of [], that's generally a win when you have left-nested applications of (>>=), also i imagine the explicit continuations make it easier to implement the more exotic operators
05:26:16 <handonson> quicksilver: No
05:26:28 <mm_freak> ah, ok
05:26:34 <mm_freak> Saizan: thank you
05:27:35 <handonson> quicksilver: when you specify the file name with String (and the code is in UTF-8), each character gets truncated to 8 bits
05:27:46 <quicksilver> handonson: which is why you encode it manually first.
05:28:04 <quicksilver> handonson: your String is not UTF-8.
05:28:10 <quicksilver> handonson: your String is a string. 
05:28:16 <quicksilver> you have to encode it to UTF-8
05:28:32 <quicksilver> (at which point it becomes a list of Bytes, pretending to be a String)
05:28:45 <handonson> then the function writeFile is seriously wrong
05:28:48 <quicksilver> yes
05:28:52 <quicksilver> it is all badly broken.
05:28:57 <quicksilver> I am telling you the workaround.
05:28:58 * hackagebot hlibev 0.2.5 - FFI interface to libev  http://hackage.haskell.org/package/hlibev-0.2.5 (AycanIrican)
05:29:02 <handonson> I see.
05:29:27 <handonson> Thanks for the information ... which is rather disappointing, though
05:31:04 <quicksilver> well, in their defence, when they wrote the standard it was not remotely clear how you were supposed to do unicode file names
05:31:15 <quicksilver> it is still not "really clear" on linux - there is just a de-facto standard.
05:31:21 <quicksilver> I think it's clearer on OSX/Win32.
05:31:45 <handonson> Hopefully writeFile :: ByteString -> ByteString -> IO () in Haskell Prime?
05:32:12 <quicksilver> in earlier linux times it was quite common to have paths encoded in your own locale
05:32:22 <quicksilver> (which makes no sense on a multi-user system, but there it is)
05:32:49 <handonson> "a list of Bytes, pretending to be a String" sounds really bad. It's like the elegant type system of Haskell is completely being laughed at.
05:33:00 <quicksilver> handonson: rather, hopefully writeFile :: String -> ByteString -> IO () with it actually do somethign sensible with unicode characters in the file name.
05:33:17 <quicksilver> (and also hopefully writeTextFile :: String -> String -> IO () which encodes the file body too)
05:33:33 <quicksilver> agreed. The type system is being broken.
05:34:13 <handonson> or writeTextFile :: String -> String -> String -> IO () with which you can specify the encoding
05:35:01 <handonson> but all I want for now is a writeFile :: ByteString -> ByteString -> IO (). ):
05:54:59 <tiryo> Anyone here familiar with the cool blaze-html library?
05:56:11 <tiryo> I have some quoting issue when using showHtml on String type
06:04:46 <dafis> tiryo: showHtml = string . show, perhaps you want string
06:05:23 <tiryo> dafis: oh I see, showHtml composes with show
06:13:04 <epicbeardman_> is it possible to overload functions on context? My memory says `no'
06:13:47 <Saizan> overloading is only via type classes, and it can be done on the result type
06:14:02 <Saizan> not sure what you want though :)
06:14:54 <epicbeardman_> yeah, nevermind, specious question
06:19:33 <hpc> someone was asking about that last week
06:19:50 <hpc> trying to make a function that performed ($) or (.) in context
06:20:40 <hpc> in situations where you would want to put multiple functions under a single name like that, you will either end up with the functions being so different they should have their own names
06:21:06 <hpc> or you get something like the aformentioned example, where ambiguity makes the function impossible to realize
06:21:42 <epicbeardman_> different names sounds like better design to me, but I'm involved in one of those silly internet debates, and ... alas.
06:21:58 <hpc> heh
06:21:58 <epicbeardman_> sometimes the answer really is, `you're doing it wrong
06:22:25 <hpc> the fun part is when they can't understand why it is wrong
06:22:49 <epicbeardman_> anyway, at this point in the battle, RTTI has been lobbed into my corner, lauded as a Good Thing (tm)
06:23:18 <epicbeardman_> I felt like I was mustard-gassed. RTTI? Put your different-but-similar types in an algebraic type, fool!
06:23:51 <zygoloid> epicbeardman_: if you mean, can you make instance selection select instances based on their contexts, then no, not really. the context isn't considered when deciding if an instance matches.
06:24:14 <epicbeardman_> zygoloid: that is what I thought, thanks
06:30:21 * hackagebot stm 2.1.2.1 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.1.2.1 (SimonMarlow)
06:30:59 <Baughn> http://haskell.org/haskellwiki/Performance/Parallel <- I think this page needs an update.
06:31:11 <Baughn> In particular, is the recommended parallel GHC still "6.12-HEAD"?
06:48:34 <ksf> does anyone know good continuation katas?
06:48:53 <ksf> ...not such stuff as http://programming-musings.org/2006/02/12/continuation-kata/ which you can solve easily in the list monad
06:49:59 <Jafet> I could do with some koans
06:51:08 <arw> (int *)NULL
06:51:35 <ksf> hmmm I could dig up advanced programming language design and implement the continuation stuff there in haskell
06:53:09 <ksf> it's one of those topics covered by virtually no textbooks. I think the reason is that people able to code in cps coincedence with people capable of self-study.
06:54:03 <ksf> ...please add "How to blow your mind in 1kloc" to the list of haskell books to write
06:54:33 <Jafet> In haskell I code only in cps
06:55:39 <McManiaC> whats the "big advantage" of STM vs. normal IORef/MVar/Chan etc...?
06:56:00 * ksf recommends spj's talk at oscom
06:56:10 <leino> I want to define the type "Nonnegative integer" (i.e. 0, 1, 2, ...) in Haskell, is there some nice way to do that?
06:56:10 <ksf> basically, you're not writing assembly.
06:56:13 <hpc> STM doesn't grant IO powers?
06:56:19 <ksf> STM actions are composable
06:56:37 <Jafet> leino: Data.Word is a practical approximation
06:56:39 <cheater99> hello
06:56:46 <cheater99> i am still revolted that ghci uses readline
06:57:00 <ksf> ...there's unsafeIOToSTM, but the IO will be re-executed each time the STM retries
06:57:04 <aristid> cheater99: i thought it uses a haskell replacement now?
06:57:11 <aristid> haskeline or so
06:57:19 <leino> Jafet: ok but I want to learn how to implement it. can I read the implementation of Data.Word somewhere?
06:57:20 <cheater99> it uses either or
06:57:23 <cheater99> both are bad
06:57:23 <ksf> to do IO based on an STM action, you usually return IO from the stm
06:57:30 <ksf> join . atomically $ is an idiom.
06:57:50 <Jafet> cheater99, funny, someone earlier came today with your name and seemed to want readline rather badly
06:57:54 <Ke> I bet haskelline doesn't have the search backward-action either
06:58:09 <cheater99> hahah
06:58:15 <cheater99> s/readline/editline.
06:58:19 <Jafet> leino: it's a direct mapping to machine words.
06:58:19 <cheater99> ghci uses editline now.
06:58:36 <cheater99> well caught.
06:58:37 <Jafet> Have you upgraded to 6.12?
06:58:51 <ksf> cheater99, blame GNU
06:58:56 <cheater99> ksf: for what?
06:59:04 <ksf> ...for not lgpl'ing readline
06:59:06 <cheater99> Jafet: i have not. what improvements are there?
06:59:14 <Saizan> ghc 6.12 uses haskeline
06:59:18 <Jafet> cheater99: no more editline!
06:59:30 <cheater99> Saizan: so does 6.10.4 which i have, supposedly
06:59:32 <Jafet> Besides a... number of other less significant improvements.
06:59:42 <aristid> cheater99: well blame YOU for using 6.10 then :P
06:59:47 <cheater99> Saizan: and it's pretty damn bad and doesn't work and falls back to editline.
07:00:20 <Saizan> haskeline won't fall back to editline
07:00:21 <cheater99> is there a shared lib compiled version of ghci 6.12 for ubuntu?
07:00:32 <Saizan> and it's not as nice as readline, but not as bad as editline :)
07:01:02 <Saizan> (newer haskeline versions are quite nicer, btw)
07:01:25 <cheater99> it makes me approach the ghci interpreter with this deep-seated hatred
07:01:37 <McManiaC> ksf: I just cant see what STM would be good for if you cant run IO in it
07:01:54 <cheater99> it's quite counter-productive when you hate what you're working with
07:01:59 <Saizan> McManiaC: you do IO around it :)
07:02:01 <cheater99> i would like to like haskell :(
07:03:17 <Saizan> McManiaC: the big advantage is that orElse/retry is much more composable, e.g. for when you want to wait on multiple blocking operations at once, also it can be more efficient in some cases as well as much slower in others
07:04:07 <Jafet> ksf: sometimes I get the feeling that call/cc is to control structures what Monad is to data structures
07:04:45 <Saizan> http://research.microsoft.com/~simonpj/papers/stm/#beautiful
07:04:52 <aristid> cheater99: then just stop using the OUTDATED ghc 6.10 and get yourself version 6.12
07:04:56 <theorbtwo> Jafet: That you are better off using call/cc to build control structures then as a control structure?
07:05:02 <ManateeLazyCat> Any GTK+ hacker at this channel?
07:05:03 <Jafet> They're essential building blocks in the formalism, but too abstract to convey anything meaningful.
07:05:14 <cheater99> aristid: i'm trying to figure out how to, but the latest package in ubuntu is 6.12
07:05:16 <cheater99> err
07:05:18 <cheater99> 6.10.
07:05:31 <aristid> cheater99: in ubuntu 10.04, the package is for 6.12
07:05:33 <Jafet> theorbtwo, call/cc is a control structure used to build other control structures
07:05:36 <aristid> cheater99: so update ubuntu
07:05:44 <cheater99> aristid: hmm.
07:05:53 <Saizan> haskell.org/ghc/ also has generic linux binary packages
07:05:59 <cheater99> aristid: i should try that, thanks
07:06:35 <cheater99> aristid: i'm surprised 9.10 doesn't get the same package versions
07:06:46 <hpc> it's ubuntu
07:06:58 <hpc> not a uniform distro like arch
07:07:09 <McManiaC> Saizan: so basicly you need STM when working with multiple mvars etc?
07:08:16 <ksf> yeah monadic code can easily end up being cps, when you write actions that take multiple continuations for different scenarios
07:08:33 <ksf> but that's hardly call/cc magic
07:08:34 <Jafet> ubuntu -- blending the cutting-edge of debian stable with the rock-solid foundation of debian testing
07:08:54 <theorbtwo> Jafet++
07:08:57 <Saizan> McManiaC: well, you don't _need_ STM, but it can be much nicer to work with when things are above some threshold of complexity
07:09:05 <McManiaC> "need" ;)
07:09:09 <McManiaC> "want"
07:09:19 <Jafet> "will end up reimplementing"
07:09:20 <McManiaC> Saizan: ok thx, that makes sense
07:09:40 <Saizan> McManiaC: this is a nice intro http://research.microsoft.com/~simonpj/papers/stm/#beautiful
07:09:53 <ManateeLazyCat> Jafet: The only reason that i chose Ubuntu is have more people test it. :)
07:10:18 <McManiaC> Saizan: thx :)
07:10:35 <cheater99> thanks for the hints guys
07:10:51 <ccasin> is ghc's loop detection documented somewhere?  I'm having a hard time finding it in the user guide
07:11:03 <ManateeLazyCat> McManiaC: I have use STM lots, works fine. free-lock, but sometimes you need lock with MVar. :)
07:22:13 <ksf> I think the main reason why there's not much call/cc going on in general haskell is laziness
07:24:16 <handonson> I was just about to write a function that un-HTML-escapes a string, and got this feeling that this must be a reinvention of wheel.
07:24:40 <handonson> Is there any built-in or lightweight library for this?
07:25:05 <Axman6> there won't be a built in one, but there's likely to be one on hackage
07:27:34 <handonson> yes, that is very likely, and I just can't locate one
07:28:15 <ksf> why would you want to unescape?
07:29:04 <ksf> pandoc might have a publicly exported function for that
07:29:14 <handonson> ksf: I've fetched some HTML from the web and parsed it, taking out the information I really want. now I want to save this in plaintext.
07:29:20 <ksf> ...and you get full-fledged document processing for free
07:29:38 <ksf> yeah but why are you escaping it in the first place?
07:29:53 <handonson> no, i didn't escape it
07:30:24 * ksf wouldn't know where to get escaped html on the webs
07:30:25 <handonson> it's just originally escaped. like "blah blah &quot;blah&quot; blah"
07:30:40 <handonson> or "blah blah &lt;blah&gt; blah"
07:30:44 <ksf> ah
07:30:51 <handonson> this is a VERY common practice, I firmly believe.
07:30:55 <ksf> I think you want pandoc
07:31:35 <ksf> http://johnmacfarlane.net/pandoc/doc/pandoc/Text-Pandoc-Readers-HTML.html
07:31:44 <handonson> pandoc looks remarkably gigantic. all i need is an unescape :: String -> String ...
07:31:55 <ksf> http://johnmacfarlane.net/pandoc/doc/pandoc/Text-Pandoc-Writers-Markdown.html
07:32:21 <ksf> it's biggish, but it's also standard
07:32:33 <Saizan> handonson: the HTTP package should have it
07:33:20 <Saizan> or maybe just urlDecode? anyhow, there should be something simpler than pandoc somewhere :)
07:33:31 <ksf> http shouldn't do html
07:33:36 <handonson> Saizan: this is actually more of an HTML issue, not HTTP. but i'd really appreciate if there is an unescape function in Network.HTTP
07:34:00 <handonson> it seems there isn't.
07:34:07 <ksf> ...and uri codecs are percent-encoded word8's and punycode for domain names.
07:34:55 <handonson> yeah, they look like %EE%EE%EE while what I want handles &ee;&ee;
07:35:52 <ksf> even worse, they're usually utf-encoded beneath that.
07:36:09 <ksf> that'd be properly called an IRI, then though
07:36:22 <handonson> why is it worse?
07:36:29 <zygoloid> I for international?
07:36:32 <theorbtwo> handonson: &#ee; would be character U+EE.  &ee; would be the character named ee, which doesnt't exist.
07:36:39 <ksf> internationalised resource identifier
07:36:44 <Saizan> handonson: how did you parse the html?
07:36:46 <ksf> there's an actual rfc for that
07:36:47 <zygoloid> as if internationalised is better than universal... ;)
07:37:02 <handonson> theorbtwo: I know there is no &ee;. that was just an example to show the format
07:37:13 <ksf> oh they're guaranteed to be normalised and stuff
07:37:20 <handonson> Saizan: Parsec
07:37:48 <theorbtwo> handonson: Yeah, and my point was that you got the format wrong, you dropped a #, which differenciates between decimal and hex escapes.
07:37:51 <ksf> and they've got a 1:1 mapping (not wholly bijective, thogh) to uris. that's where all those %s come from
07:38:26 <handonson> theorbtwo: no, i wasn't demonstrating the &#123; format. I was referring to the &lt; format
07:38:42 <ksf> handonson, worse as in "more stuff to have to care about"
07:39:05 <ksf> but then extending http to utf8 streams would be insanity.
07:39:27 <handonson> ksf: percent-encoding will be hardly needed if those are not UTF strings
07:39:50 <handonson> well, maybe %20 for whitespace
07:39:51 <ksf>  /?: etc
07:40:27 <ksf> #, too
07:40:34 <ksf> I'd have to look up the rfc
07:40:37 <theorbtwo> & comes up reasonably often as well.
07:41:02 <handonson> I never saw & and ? being escaped
07:41:19 <ksf> & isn't reserved in uris iirc, that's query-part specific
07:41:21 <siracusa> handonson: I found a function substHtmlEntities in package hxt-filter. The name sounds pretty promising it is what you want.
07:41:45 <ksf> that should be specced in html, forms and stuff.
07:41:54 <theorbtwo> ksf: And, thus, you will need to escape it when you want to have a query parameter that includes a &.
07:42:12 <handonson> siracusa: thanks a lot. let me check right away
07:42:50 <theorbtwo> The term "reserved" isn't overly helpful when talking about URIs; you really need to consider what you want this specific character to mean, and if it is a metacharacter in the current position.
07:43:11 <theorbtwo> Thankfully, you can get away with escaping things that aren't metacharacters, so long as you do escape everything that is.
07:44:21 <ksf>  / isn't a meta-character in query string as far as uri parsing is concerned, either
07:45:14 <ksf> hmmm seems I didn't implement that part, yet.
07:45:23 <ksf> only utf8 escaping
07:46:02 <ksf> ...but I already ended up using data PctEncoded c = Pct {unPct :: Int} | Chr {unChr :: c} for sanity's sake.
07:46:41 <handonson> What do you generally use when you want the str.replace("from", "to") function?
07:47:05 <ksf> an AST
07:47:24 <handonson> I mean in everyday Haskell
07:47:37 <ksf> an AST
07:47:55 <handonson> I thought this is a very commonly demanded function, and got surprised to see there's none for this in Prelude
07:48:28 <handonson> what is an AST? an Abstract Syntax Tree?
07:48:31 <ksf> yep
07:48:40 <ksf> parse your data, mess with it, then unparse
07:48:56 <ManateeLazyCat> ksf: Which RFC viewer do you use?
07:49:08 <handonson> I don't think I really need it for just a string replace...
07:49:15 <ksf> additional goodies are support for everything haskell has to offer, like generics
07:49:32 <ksf> and then another regex, and another replace, some mangling there...
07:49:36 <ksf> ManateeLazyCat, firefox
07:50:09 <ManateeLazyCat> ksf: If you use emacs, try my Irfc (http://www.emacswiki.org/emacs/Irfc), download RFC document automatically, and support link jump.
07:50:24 <ksf> NO I DON'T USE EMACS AND WON'T
07:50:33 <ManateeLazyCat> ksf: http://www.emacswiki.org/emacs/Irfc#toc7
07:50:39 <dafis> ksf: ed?
07:50:43 <ksf> vim
07:50:50 <dafis> heretic
07:51:10 <ksf> I'm perfectly capable of editing with ed, though.
07:51:26 <Saizan> heh, replace seems to be in many "misc utils" packages on hackage
07:51:29 <dafis> ksf: good
07:51:33 <ManateeLazyCat> ksf: My RFC viewer support link jump, if link document haven't found, download it automatically. :)
07:51:33 <ksf> the main reason I'm not using yi is that the ex mode is a joke
07:51:33 <Saizan> also in Data.Text though
07:51:50 <dafis> and stringsearch for ByteStrings
07:52:31 <ManateeLazyCat> ksf: Okay, just suggestion, i forgot you're emacs hater. :)
07:55:25 <handonson> okay, this looks good enough for string replace. http://bluebones.net/2007/01/replace-in-haskell/
07:55:57 <ManateeLazyCat> Bye all.
07:56:41 <handonson> wait, replace is in Data.Text?
07:57:08 <handonson> where's Data.Text?
07:57:14 <Saizan> yeah, but for the Text datatype
07:57:14 <Philippa> import Data.Text
07:57:19 <handonson> i mean its package name
07:57:19 <Saizan> which is in the package text
07:57:25 <Philippa> oh, right
07:58:08 <byorgey> someone ought to implement a module-name lookup on Hackage
07:58:27 <Saizan> hayoo works quite well for that
07:58:28 <byorgey> should be pretty trivial to implement... I guess just waiting for Hackage 2.0
07:58:57 <byorgey> sure, but hayoo's database only gets updated every so often, right?
07:59:05 <alar> is there a QuickChecker from standard class laws?
07:59:18 <alar> to test e.g. properties of read . show
07:59:25 <Saizan> no idea :)
07:59:43 <dafis> handonson: if you want to work on String, http://www.haskell.org/pipermail/haskell-cafe/2005-December/012927.html should be faster than your link
08:00:13 <handonson> Oh, cool!!!
08:00:18 <byorgey> alar: http://hackage.haskell.org/package/checkers ?
08:00:33 <alar> cool
08:00:39 <alar> @karma+ byorgrey
08:00:40 <lambdabot> byorgrey's karma raised to 1.
08:01:08 <byorgey> woah, karma! =D
08:01:26 <byorgey> sadly, karma seems to have all but died from #haskell culture
08:01:40 <Phyx-> @karma byorgey 
08:01:40 <lambdabot> byorgey has a karma of 21
08:01:44 <Phyx-> :O
08:01:50 <Phyx-> @karma Phyx- 
08:01:50 <lambdabot> You have a karma of 0
08:01:57 <Phyx-> well.. could be worse... could be negative
08:02:00 <dafis> @karma lambdabot
08:02:01 <lambdabot> lambdabot has a karma of 1
08:02:08 <alar> @karma+ byorgey
08:02:08 <lambdabot> byorgey's karma raised to 22.
08:02:13 <Philonous> Isn't karma something to be avoided? 
08:02:28 <hpc> positive karma is gained by good deeds
08:02:32 <dafis> Philonous, I think karma per se is neutral
08:02:33 <hpc> and ensures you luck in the future
08:03:19 <zygoloid> @karma- byorgrey
08:03:19 <lambdabot> byorgrey's karma lowered to 0.
08:03:20 <Philonous> hpc: Yes, but the ideal is no karma at all, because you can only acquire nirvana when you don't have any, not even positive 
08:03:21 <zygoloid> down with typos
08:04:00 <hpc> Philonous: did not know that
08:05:47 * byorgey doesn't understand how 22 - 1 = 0
08:06:03 <handonson> Does Haskell's syntax support a multi-line String? If not, is there any plan to?
08:06:10 <hpc> yes
08:06:13 <hpc> "\n"
08:06:13 <zygoloid> byorgey: via a typo of 'byorgrey'
08:06:19 <handonson> ...
08:06:26 <hpc> or do you mean "first line
08:06:29 <hpc> second line"?
08:06:31 <byorgey> handonson: it does.  just put a trailing \ at the end of the line, and then a beginning \ on the next line
08:06:32 <handonson> yup
08:06:36 <hpc> don't think so
08:06:40 <byorgey> "first line\
08:06:45 <handonson> byorgey: thanks
08:06:47 <byorgey>     \second line"
08:07:00 <byorgey> it even ignores leading whitespace before the second \
08:07:08 <dafis> byorgey, handonson: But don't use CPP then
08:07:16 <byorgey> who uses CPP?#
08:07:28 <zygoloid> handonson: be warned, the \ mechanism strips out the newline; it doesn't actually give you a multiline string.
08:07:44 <dafis> byorgey, well, I've seen a few packages with CPP in the extensions field
08:07:53 <ClaudiusMaximus> > "white\                    \space"
08:07:54 <lambdabot>   "whitespace"
08:07:54 <lambdabot> ClaudiusMaximus: You have 1 new message. '/msg lambdabot @messages' to read it.
08:07:55 <byorgey> I was being facetious =)
08:07:55 <hpc> ending each line with \n\ would work
08:08:01 <Axman6> :o
08:08:06 <zygoloid> if you want a heredoc-style thing, it's easy to make one with TH quasiquotes (and iirc there's a package on hackagedb which does just that)
08:08:14 <handonson> It would be great if Haskell had """multiline""" too...
08:08:43 <zygoloid> > (\as bs cs -> as++bs++cs) """multiline"""
08:08:44 <lambdabot>   "multiline"
08:08:51 <zygoloid> handonson: that would be ambiguous
08:09:12 <handonson> zygoloid: which is why "a""b" is not allowed in Python, I guess
08:09:26 <handonson> wait
08:09:35 <handonson> Python doesn't curry.
08:09:55 <hpc> python arguments are separated by commas, anyway
08:10:07 <hpc> you would never encounter "a" "b" even
08:10:10 <byorgey> try the interpolatedstring-perl6, interpolatedstring-qq, or Interpolation  packages
08:10:42 <zygoloid> http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.3.1/doc/html/Language-Haskell-Meta-QQ-Here.html
08:10:58 <byorgey> oh, nice, didn't know it was in haskell-src-meta
08:11:02 <zygoloid> ^^ this allows [$here| some mulitline string |]
08:12:36 <zygoloid> it's just: here = QuasiQuoter (litE . stringL) (litP . stringL)
08:14:41 <FunctorSalad> would it be appropriate to install a runhaskell variant in /bin? or is that off-limits? ;)
08:14:54 <FunctorSalad> #!/bin/hask vs. #!/usr/local/bin/hask
08:15:17 <byorgey> FunctorSalad: um, you can do whatever you like on your own machine =)
08:15:18 <arw> /usr/bin/hask perhaps
08:15:28 <FunctorSalad> (I'm making a 'interpreter' that actually compiles the script to a global cache)
08:15:37 <FunctorSalad> byorgey: I mean if it was to become a cabal package
08:15:38 <arw> /bin/ is usually reserved for stuff you machine needs to boot.
08:15:43 <Ferdirand> unless you need haskell for the boot process, which would be kind of leet
08:15:55 <FunctorSalad> oh, didn't know it's just for booting...
08:16:12 <arw> FunctorSalad: well, booting and administrative functions.
08:16:48 <FunctorSalad> I guess the user can always make a symlink /hask -> /usr/local/bin/hask..
08:17:10 <arw> FunctorSalad: the traditional distinction between /usr/bin and /bin is that /usr might be a network-mount, so everything that is only needed after networking works goes to /usr/bin, everything you need to make networking work goes to /bin
08:17:41 <FunctorSalad> arw: I see :)
08:18:39 <orlandu63> you should just usr /usr/local/bin, since that's where user-compiled binaries usually go
08:20:22 <FunctorSalad> yes, for that I wouldn't need any custom Setup.hs
08:28:33 <byorgey> anyone know any nice tricks for evaluating type families in ghci?
08:37:46 <FunctorSalad> byorgey: I don't know any, but does :t (undefined :: Zonk) work?
08:42:23 <handonson> in Parsec, "many c" fails where c = (try (string "-- END --") >> fail "end of content") <|> anyChar
08:42:34 <FunctorSalad> hmm is there no way to get ghc --make to build files that don't have the .hs suffix?
08:42:42 <handonson> i mean, it raises an Exception
08:43:10 <handonson> but I thought "many" should never raise an exception unless its argument consumed something and failed
08:43:44 <handonson> since string "-- END --" is surrounded by try, it doesn't consume anything even when it fails
08:43:47 <handonson> so i'm lost.
08:44:47 <quicksilver> handonson: you are calling (fail "end of content") unconditionally there
08:44:51 <quicksilver> handonson: it's outside the try.
08:44:56 <quicksilver> perhaps you wanted it inside the try?
08:45:21 <handonson> it is conditional
08:45:38 <handonson> if try fails, the right-hand argument of (>>) doesn't get called
08:45:43 <handonson> as far as i know.
08:46:19 <handonson> that's how Parsec's monad works iirc
08:47:06 <quicksilver> handonson: hmm you're right, I misunderstood.
08:47:20 <quicksilver> handonson: which exception gets raised?
08:47:32 <handonson> the one I specified with fail.
08:47:36 <handonson> "end of content"
08:48:16 <quicksilver> and was the -- END -- indeed there?
08:48:22 <handonson> yeap.
08:48:29 <quicksilver> ok so what are you surprised by?
08:48:30 <dafis> handonson: Then it's correct
08:48:50 <handonson> it's given to many
08:49:06 <handonson> many p tries p until p fails, then returns a list
08:49:11 <handonson> that's how i understood many
08:49:49 <handonson> so even if p has failed, an exception shouldn't be raised, i think
08:51:20 <mm_freak> exception?
08:51:39 <handonson> yes like
08:51:39 <handonson> *Main> main
08:51:40 <handonson> *** Exception: (line 809, column 191):
08:51:40 <handonson> end of content
08:52:10 <mm_freak> are you using parseTest?
08:52:27 <handonson> I don't think so, because I don't even know what it is
08:52:54 <duairc> I have a function type with a special kind of function composition... it's not a monad though, it doesn't have any notion of return. I wish I could just call my function composition function (>>) though and use do-notation with that.
08:53:13 <mm_freak> handonson: i parser itself should never raise an exception
08:53:28 <mm_freak> unless you specifically use 'throw' or 'error' or something
08:53:44 <byorgey> handonson: I could be wrong but I don't think the monadic "fail" method is the same as Parsec's notion of a failed parse
08:54:01 <byorgey> there's a parsec function for indicating a failed parse, I forget what it is
08:54:06 <osaunders> In this library <http://hackage.haskell.org/package/monads-fd> what is the purpose of wrapping all the modules in "Monad" and then "Control" modules?
08:54:10 <byorgey> but you could try mzero
08:54:28 <mm_freak> byorgey: 'fail' acts like mzero, but gives a reason, too, IIRC
08:54:29 <handonson> mm_freak: what? no. I've seen tons of exceptions so far. RBH says so too. http://book.realworldhaskell.org/read/using-parsec.html
08:54:45 <handonson> I mean RWH
08:55:03 <handonson> see all those exceptions
08:55:26 <mm_freak> yes, i do remember correctly
08:55:30 <mm_freak> yes, i do remember correctly
08:55:32 <handonson> uh, sorry. not exception but Either Left
08:55:56 <handonson> and i'm forcing Either. sorry for this
08:56:15 <quicksilver> instance Monad (ParsecT s u m) where ... fail msg = parserFail msg
08:56:28 <quicksilver> calling 'fail' is a fine way to indicate a parse failure, as far as I know
08:56:28 <byorgey> ah, you're right
08:56:31 <quicksilver> I'm sure I've done it before.
08:56:39 <mm_freak> duairc: if you could show us the signature…
08:57:02 <handonson> ...so, the correct description will be that, i think "many" should never return Left (unless its argument CONSUMES something and fail)
08:57:04 <zygoloid> i'm pretty sure i've used pattern match failure inside a 'do' to trigger a parse failure (think it was  Just x <- return $ M.lookup ...)
08:57:25 <handonson> but i'm seeing it now.
08:58:00 <duairc> mm_freak: (MonadTrans s, MonadTrans t, Monad m) => (s (t m) () -> IO (t m (), IO ())) -> (t m () -> IO (m (), IO ())) -> (s (t m) () -> IO (m (), IO ()))
08:58:08 <handonson> any idea? anyone? :(
08:59:07 <mm_freak> uh
08:59:09 <duairc> :)
08:59:12 <mm_freak> what a jungle
08:59:19 <mm_freak> ok, what does it do? =)
08:59:21 <byorgey> handonson: can you paste your code, together with the error message, on a pastebin?
08:59:47 <handonson> byorgey: sure. just a sec
08:59:48 <byorgey> such as hpaste.org
08:59:55 <quicksilver> handonson: watch:
08:59:56 <quicksilver> > parseTest (many (try (string "bbc") >> fail "boo")) "b"
08:59:57 <quicksilver> []
08:59:57 <lambdabot>   Not in scope: `parseTest'Not in scope: `try'Not in scope: `string'
09:00:06 <quicksilver> sorry, didn't mean to send that to lambdabot.
09:00:14 <quicksilver> point is, your basic pattern is fine.
09:00:27 <quicksilver> (try (string ...) >> fail) works correctly inside a 'many'
09:00:52 <quicksilver> if there are no occurences
09:00:55 <quicksilver> hmm
09:01:12 <byorgey> quicksilver, what if there are 1.5 occurrences?
09:01:25 <quicksilver> if there is one occurencs, I get the same 'problem' that handonson got.
09:01:29 <mm_freak> quicksilver: not if it parses
09:01:36 <duairc> mm_freak: It composes two functions. Each function takes a monad transformed value and returns in IO a tuple containing the unwrapped monadic value and an IO () action. Ugh, it's kinda not worth explaining yet
09:01:37 <mm_freak> parse (many $ try (char 'a') >> fail "abc") "abc" "abc"
09:01:37 <mm_freak> Left "abc" (line 1, column 2):
09:01:37 <mm_freak> abc
09:01:41 <quicksilver> parseTest (many (try (string "bbc") >> fail "boo")) "bbcb" 
09:01:48 <quicksilver> parse error at (line 1, column 4): boo
09:01:49 <osaunders> Does a module name in a Hackage package need to be unique in the whole of Hackage? Or are modules compartmentalized to packages?
09:02:15 <quicksilver> oh, I get it.
09:02:15 <mm_freak> osaunders: only packages need to be unique
09:02:16 <FunctorSalad> osaunders: they are, but it's really annoying if there's a clash
09:02:21 <quicksilver> handonson: if your "try" succeeds
09:02:24 <quicksilver> handonson: then it consumes the input
09:02:30 <quicksilver> handonson: and then your fail fails.
09:02:33 <quicksilver> and input has been consumed
09:02:37 <quicksilver> hence --> exception.
09:02:38 <osaunders> FunctorSalad: Why?
09:02:41 <FunctorSalad> you'll have to use PackageImports, or ghc-pkg hide all but one of the packages
09:02:50 <handonson> quicksilver: thank you A LOT.
09:02:53 <osaunders> Oh, OK.
09:02:57 <mm_freak> duairc: sorry, i don't get it
09:03:00 <zygoloid> osaunders: it's not so bad most of the time, since if you build with cabal the hiding is done for you
09:03:08 <handonson> that explains everything
09:03:27 <FunctorSalad> osaunders: a particularly bad one is "import Control.Monad.Reader" or so if you have both mtl and transformers visible
09:03:30 <handonson> quicksilver: do you think, then, it would work flawlessly if i just replace try with lookAhead?
09:03:33 <duairc> mm_freak: That's understandable, I don't think I can explain it concisely without explaining the whole project
09:03:44 <mm_freak> duairc: yeah, probably
09:04:05 <mm_freak> but maybe you can give an example use case?
09:04:20 <osaunders> FunctorSalad: Right so modules from all packages are sort of merged into one namespace unless you explicitly hide packages or get cabal to do it for you? 
09:04:30 <FunctorSalad> zygoloid: still annoying if you want to ghci the code or ghc it directly for some reason
09:04:45 <zygoloid> FunctorSalad: yeah, i'd really like a 'cabal ghci' command... :)
09:04:48 <FunctorSalad> (for that reason I disapprove of setting language flags in the cabal file)
09:04:57 <FunctorSalad> zygoloid: good idea
09:05:12 <FunctorSalad> though it isn't that hard to just make one's sources work as-is ;)
09:05:16 <zygoloid> not my idea originally, but i don't remember where i saw it first :)
09:05:17 <FunctorSalad> (PackageImports)
09:05:18 <soupdragon> how come #haskell-math is so small
09:05:28 <FunctorSalad> I didn't know it exists?
09:05:31 <soupdragon> people found something more important?
09:05:32 <duairc> mm_freak: I probably could, but I have to head out now, so I can't right now. Thanks anyway though!
09:05:39 <zygoloid> FunctorSalad: sadly the docs say that's not what PackageImports is for :(
09:05:54 <mm_freak> duairc: you're welcome…  bye
09:06:01 <FunctorSalad> zygoloid: why? doesn't work or is discouraged?
09:06:14 <zygoloid> FunctorSalad: though i do like that i can write a module using all of mtl, monads-tf and monads-fd simultaneously with PackageImports
09:06:43 <zygoloid> FunctorSalad: apparently we're supposed to use package hiding, and PackageImports is only there to allow base-3 to import base-4 :o
09:06:50 <zygoloid> iirc ag least
09:07:08 <tolkad> Is there anyway to call read so it works like String -> Maybe a? I want to be able to handle the parse error condition rather than fail with an error
09:07:18 <FunctorSalad> hmm doesn't make sense to me at first glance (of course you're just quoting it)
09:07:30 <aavogt> zygoloid: and they didn't have to reuse mtl's module names
09:07:43 <FunctorSalad> @ty readS
09:07:43 <lambdabot> Not in scope: `readS'
09:07:45 <FunctorSalad> @ty reads
09:07:45 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:07:47 <mm_freak> FunctorSalad: in general, in a cabalized project, module name clashes aren't much annoying
09:07:47 <handonson> Okay, to everyone who are interested: this is the final draft of my code that DOESN'T work. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26947#a26947
09:07:52 <FunctorSalad> @ tolkad 
09:08:21 <handonson> taking quicksilver's advice, I replaced 'try' with 'lookAhead', and got the same problem
09:08:22 <FunctorSalad> (that does a bit more than you asked for, it returns all the parses and leftover inputs, AFAIK)
09:08:26 <zygoloid> FunctorSalad: here's the documentation bit: "Note: you probably don't need to use this feature, it was added mainly so that we can build backwards-compatible versions of packages when APIs change. It can lead to fragile dependencies in the common case: modules occasionally move from one package to another, rendering any package-qualified imports broken"
09:08:29 <handonson> no, not exactly same
09:08:31 <mm_freak> but otherwise i agree…  use unique names to the best of your knowledge
09:08:46 <tolkad> FunctorSalad: thanks
09:09:03 <handonson> this time, it fails when the 'string' function starts to apply
09:09:09 <FunctorSalad> zygoloid: ok but that seems like it'd be really rare
09:09:33 <zygoloid> yeah, i agree. also, if modules move between packages, i'd think that'd break anything built with cabal anyway...
09:09:37 <FunctorSalad> and I don't see any other way to get it to load in out-of-the-box ghci
09:09:49 <FunctorSalad> (or can you -p in OPTIONS pragmas?)
09:10:08 <zygoloid> FunctorSalad: maybe in OPTIONS_GHC?
09:10:15 <FunctorSalad> is there a difference? :)
09:11:21 <FunctorSalad> (does reads ever return more than one parse?)
09:11:27 <handonson> when you change 'lookAhead' to 'try', you get a different error
09:11:45 <FunctorSalad> > reads "123" :: Integer
09:11:46 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
09:11:46 <lambdabot>         agains...
09:11:59 <FunctorSalad> > reads "123" :: [(Integer,String)]
09:12:00 <lambdabot>   [(123,"")]
09:12:08 <FunctorSalad> :|
09:12:47 <handonson> grr
09:13:08 <quicksilver> handonson: I don't understand what you want.
09:13:17 <quicksilver> handonson: do you want the --end-- to be consumed, or not?
09:13:50 <handonson> i want "many c" to consume everything until it meets "--end--"
09:14:03 <handonson> so "--end--" will be discarded.
09:14:17 <quicksilver> you *do* want "--end--" to be consumes, right?
09:14:37 <handonson> no
09:14:47 <quicksilver> you just said 'so "--end--" will be discarded'
09:15:00 <quicksilver> in your mind, what is the different between 'consumed' and 'discarded'.
09:15:01 <quicksilver> ?
09:15:05 <handonson> by discarded i meant not taken
09:15:10 <quicksilver> ah.
09:15:12 <handonson> okay, i want "abc" out of "abc--end--def"
09:15:20 <quicksilver> and you still want --end-- sitting at the head of the stream
09:15:24 <quicksilver> for the next parser to see?
09:15:40 <handonson> preferrably, but that doesn't matter that much.
09:16:53 <handonson> actually, since I already know that the string is "--end---", i won't need other parsers to parse it and give it to me.
09:17:21 <handonson> so... it doesn't matter.
09:18:01 <handonson> ...i just want "many c" to work!
09:19:12 <ksf> many (try anyChar) >> string "--end--"
09:19:26 <ksf> dunno if that try is necessary
09:19:31 <ksf> I think parsec has manyTill
09:19:49 <quicksilver> manyTill is the more natural way to do it
09:20:02 <quicksilver> but it doesn't produce a parser which can be wrapped in 'many' like handonson wants
09:20:27 <ksf> someTill?
09:20:29 <FunctorSalad> is there a portable System.Posix.Process.executeFile?
09:20:47 <FunctorSalad> (yes, I want to replace the process)
09:21:15 <ksf> ...and why wouldn't manyTill be non-wrappable in many?
09:21:16 <FunctorSalad> (may be premature opti, I didn't take any benchmarks)
09:21:21 <ksf> (at least if the till part is non-empty)
09:21:32 <ksf> double negation fail
09:21:33 <handonson> i want it this way because in the code { c = (lookAhead (string "--end--") >> fail "end of content") <|> anyChar }, anyChar is actually some other function that replaces some special characters
09:21:34 <quicksilver> ksf: he is asking for a parser which parses a single char
09:21:49 <quicksilver> ksf: such that many x will act as described
09:22:05 <quicksilver> (manyTill anyChar (try (string "--end--"))) works fine, for example
09:22:26 <handonson> really? let me try
09:22:31 * ksf thinks conversions shouldn't be done while parsing
09:22:37 <quicksilver> but it's not wrapped in many as required
09:22:41 * ezyang decides today, he will learn how to manually do Hindley-Milner type inference \o/ 
09:22:50 <ksf> ...charset conversions, that is.
09:23:50 <handonson> kfs: it just replaces special characters into tokens
09:24:08 <handonson> that's somethinig a parser would do, i think
09:24:15 <philosopher> is there an easy tokenizer ? something like words but with a custom delimiter ?
09:24:41 <zygoloid> philosopher: look in the Data.Split module in the split package on hackage.
09:24:54 <philosopher> zygoloid:  thanks
09:25:16 <ksf> it always depends on the parser. my point is that tokenising and parsing should be distinct activities, no matter which is done first.
09:25:49 <ksf> ...and without a prior tokenising pass, whitespace rules usually become a pain.
09:27:14 <quicksilver> handonson: I don't understand why (many ((lookAhead (string "--end--") >> fail "boo") <|> anyChar)) doesnt work
09:27:27 <quicksilver> handonson: I have some vague memory of a bug in lookAhead being discussed
09:28:03 <handonson> eww.
09:28:05 <quicksilver> handonson: here we are:
09:28:06 <quicksilver> http://www.mail-archive.com/haskell-cafe@haskell.org/msg63614.html
09:28:10 <quicksilver> it's a parsec bug.
09:28:48 <handonson> ...
09:28:52 <handonson> WHAT THE
09:29:10 <handonson> and it is still not fixed?
09:29:24 <handonson> that article is like a year ago
09:30:08 <FunctorSalad> tl;dr don't use lookAhead?
09:30:15 <FunctorSalad> didn't follow the problem exactly
09:30:35 <quicksilver> handonson: what you're doing is at odds with parsec's design assumptions, it's not clear how best to fix it, I think.
09:30:55 <quicksilver> I haven't thought about it very hard though
09:31:11 * ksf wonders why we don't just take the ideas from continuation-based web programming and do GUIs with it
09:32:09 <ksf> unlimited undo yay
09:32:12 <edwardk> ksf: you can if you want to model undo, but it turns out we don't want to be able to undo _everything_ so its tricky
09:32:35 <edwardk> i.e. typically undo doesn't move the scrollbars, etc.
09:32:46 <edwardk> (unless it refocuses you on where you made the edit)
09:32:59 <edwardk> and it doesn't re-resize your windows
09:33:01 <ksf> I wasn't thinking so much about the view as the model+controller
09:33:11 <edwardk> *nods* there you're probably fine
09:33:12 <FunctorSalad> "we call that a memory leak" (I'm not seriously making any point; I just found that answer cute the last time invertible computation was the topic) ksf
09:33:18 <ksf> ...hence the web analogy
09:33:45 <FunctorSalad> (btw, "continuation-based web programming"?)
09:33:56 <ksf> http://double.co.nz/pdf/inverting-back-the-inversion.pdf
09:34:01 <ksf> wash does it iirc
09:34:27 <ksf> in the web the problem arises naturally because the user has a back button
09:35:00 <hpc> you mean resolves naturally
09:35:17 <FunctorSalad> ksf: I avoid it (back button) like the plague with highly dynamic sites
09:35:19 <hpc> unless you mean a haskell browser, not a webserver
09:35:20 <ezyang> I dunno; when I browse the web I like opening lots of windows to the same site 
09:35:41 <FunctorSalad> (not to confuse the poor things with resends of no-longer-sensical data)
09:36:00 <ksf> hpc, I mean the web
09:36:13 <ksf> as in client/server via http
09:36:20 <FunctorSalad> (or make a double post)
09:36:58 <ksf> was it put or post that is indempotent?
09:37:14 <ezyang> post is certainly not idempotent 
09:37:29 <ezyang> though it's often a good idea to make it so. 
09:37:38 <FunctorSalad> 'get' is supposed to be, but would you bet on it with a random site? ;)
09:37:39 <ksf> then that's the one where firefox is warning
09:37:51 <arw> GET should always be idempotent and POST never is. don't know about PUT.
09:38:17 <FunctorSalad> POST is if you've guarded against it as ezyang suggests, no?
09:39:12 <arw> yes, maybe. but the spec says you shouldn't assume it.
09:39:55 <ksf> luckily, the site serving the html with post/put/get in it is the one implementing their semantics.
09:39:57 <FunctorSalad> ksf: I often try to jump back to a non-posty site using the dropdown menu of the back button, to avoid that
09:40:08 <FunctorSalad> (after you've done the stateful activity like logging in etc)
09:40:12 <ksf> yep
09:40:25 <ksf> that warning should have a "go back one more" button
09:41:50 <FunctorSalad> maybe it should surpress the post by default after going back and display a special red button "repeat post" as an extra site element
09:42:01 <FunctorSalad> that'd be way less intrusive
09:42:06 <ksf> yep
09:42:37 <ksf> ...up to the point of displaying an empty page in case the cache was pruned
09:45:53 <handonson> Why doesn't { manyTill anyChar (lookAhead $ string "--end--") } work while { manyTill anyChar (try $ string "--end--") } works?
09:46:27 <ClaudiusMaximus> is this useful function defined anywhere useful? sortOn p = map fst . sortBy (comparing snd) . map (\x -> (x, p x))
09:46:35 <aristid> :t manyTill
09:46:36 <lambdabot> Not in scope: `manyTill'
09:46:42 <aristid> handonson: where is manyTIll?
09:46:48 <handonson> Parsec.
09:46:58 <FunctorSalad> handonson: random idea... switch to something based on "many1 (noneOf "-")"?
09:47:18 <FunctorSalad> and check whether it's "--end--" after encountering a "-" only
09:47:49 <handonson> FunctorSalad: right, but i just want to know why the damn lookAhead doesn't work
09:48:14 <handonson> it's supposed to work that way according to the documentation
09:48:30 * ezyang fondly remembers debugging a broken Parsec expression 
09:48:43 <ezyang> (for certain definitions of "fondly", anyway) 
09:48:49 <ksf> isn't lookahead limited to one character only?
09:48:52 <ksf> (random guess)
09:49:10 <ezyang> handosen: I haven't been paying close attention, but have you broken down the Parsec expr you're tested into the smallest possible bit? 
09:49:21 <ezyang> *that isn't doing the right thing. 
09:49:27 <ksf> otherwise, there'd hardly be a reason to separate lookahead and backtracking (try)
09:49:55 <handonson> uhm... "lookAhead p" tries the parser p without consuming any input.
09:50:12 <FunctorSalad> handonson: but didn't we just learn that it's broken?
09:50:31 <FunctorSalad> the unfixed bug
09:50:40 <handonson> FunctorSalad: i understood that it wasn't universally broken for all purposes
09:50:58 <FunctorSalad> ah. didn't read what exactly is broken
09:51:38 <handonson> as quicksilver said what i tried earlier was "at odds with parsec's design assumptions,"
09:52:59 <FunctorSalad> ksf: I'm not a parsing master but I thought looking ahead a single character is "free" in parsec, while for more, you use 'try'
09:53:00 <Cale> So, I finally put it together yesterday that the diagrams everyone draws for Arrow computations are somewhat of a lie :)
09:53:33 <Cale> There's something which morally ought to be an Arrow axiom if those diagrams describe well-defined computations, and it's not.
09:53:52 <FunctorSalad> (I mean, you can do choice [ char '(' >> foo , bar ] without a try, assuming you want to commit to 'foo' if there's a parenthesis)
09:53:53 <Cale> The problem being that if it were an Arrow axiom, then Arrows wouldn't generalise monads.
09:54:34 <Cale> Specifically, (f *** g) >>> (h *** k) is not equal to (f >>> h) *** (g >>> k)
09:54:41 <Cale> interchange law fails
09:54:44 <FunctorSalad> (this won't steal the char from 'bar' to my knowledge, if it isn't '(')
09:54:52 * hackagebot speculation 0.9.0.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.9.0.0 (EdwardKmett)
09:55:23 * ezyang now understands HM-unification. “That was easy!” 
09:55:26 <Cale> So it actually matters how you turn the diagram into Arrow combinators
09:55:39 <Cale> (those two things have the same diagram of course)
09:55:59 <Cale> It looks like:
09:56:19 <Cale> >---[f]-->--[h]--->
09:56:24 <Cale> >---[g]-->--[k]--->
09:56:35 <ksf> "This essay is for people who, in web years, are older than
09:56:36 <ksf> dirt.  More specifically, if there was a period of time in
09:56:36 <ksf> which you programmed in a language which did not have garbage
09:56:36 <ksf> collection, then I mean you.  "
09:56:42 <ksf> dammit I'm old. ancient. so to say.
09:56:49 <ksf> and that was written in 2005!
09:57:00 <ezyang> Wow, 2005 is five years old >_< 
09:57:02 <Phyx-> > id 5
09:57:03 <lambdabot>   5
09:57:04 <FunctorSalad> "decompose the diagram horizontally or vertically first"? Cale
09:57:08 <Cale> FunctorSalad: right
09:57:13 <zygoloid> what if i still program in a language which does not have garbage collection?
09:57:19 <zygoloid> and what if i do so by choice? :)
09:57:27 <ksf> then you're a reactionist.
09:57:31 <Cale> FunctorSalad: and because the Arrow axioms aren't strong enough, it matters how you do that
09:57:34 <Phyx-> i do too
09:57:39 <Phyx-> I still love my C
09:57:45 <FunctorSalad> (I don't have the arrow diagrams pictured right now, but the interchange law is usually about this =))
09:58:25 <Cale> FunctorSalad: Well, I drew ascii-art for the diagram in consideration
09:58:28 <FunctorSalad> (yes, (,) isn't a product in the cat defined by the arrow)
09:58:32 <cheater99> where in the lambda cube is haskell located?
09:59:16 <FunctorSalad> (f,g) is unequal to swap . (g,f) . swap , am I remembering correctly?
09:59:16 <soupdragon> near the corner
09:59:35 <Cale> cheater99: We have terms depending on types, and types depending on types
09:59:45 <Cale> cheater99: but not types depending on terms
09:59:47 <cheater99> what about types depending on terms?
09:59:48 <cheater99> ok
09:59:50 <ezyang> :t swap 
09:59:52 <lambdabot> Not in scope: `swap'
09:59:58 <cheater99> why, and what does that mean?
10:00:02 <cheater99> i heard agda has that
10:00:09 <cheater99> but i know nothing of agda
10:00:32 <ezyang> Dependent typing, so to speak. 
10:00:57 <Cale> cheater99: Typical first example of dependent typing is sized-vectors
10:00:59 <technogeeky> ezyang: thanks for the MVC <-> pure FP article. It was interesting.
10:01:00 <FunctorSalad> ezyang: arr snd &&& arr fst or so :)
10:01:00 <zygoloid> we have runtime types which depend on terms
10:01:07 <soupdragon> in haskell you can form   f :: T -> T   F :: * -> *  but you can't form 'type functions'  F :: T -> *
10:01:11 <Cale> Where the size of a vector is an actual Integer
10:01:12 <ezyang> technogeeky: Yay! :-) 
10:01:14 <cheater99> Cale: so something like having a type Tuple(n)?
10:01:16 <FunctorSalad> arr (\(x,y) -> (y,x)) should work too
10:01:19 <Cale> cheater99: right
10:01:23 <soupdragon> Tuple :: Integer -> *
10:01:27 <cheater99> Cale: go on
10:01:28 <Cale> and then you want a concatenation operation
10:01:35 <cheater99> concatenation?
10:01:36 <Cale> Vector n -> Vector m -> Vector (n + m)
10:01:38 <cheater99> ok
10:01:41 <cheater99> go on
10:01:52 <Cale> and note that (n + m) is a computation on Integer values
10:02:08 <cheater99> yes.
10:02:13 <Cale> So this means that we have the compiler doing value computation to check the types
10:02:16 <FunctorSalad> @type arr snd &&& arr fst
10:02:16 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) (b, a)
10:02:24 <Cale> (possibly)
10:02:24 <FunctorSalad> looks good ;)
10:02:40 <cheater99> Cale: what could that be useful for?
10:02:58 <technogeeky> greetings conal.
10:02:58 <cheater99> Cale: i assume i could write a function polymorphic for Tuple(n) for all n?
10:03:04 <Cale> cheater99: yes
10:03:14 <cheater99> e.g. vector length
10:03:15 <conal> technogeeky: hey there
10:03:25 <FunctorSalad> (anyway, IIRC, (f***g) is not a simple mirror image of (g***f), since, say, a state arrow will perform the left computation first)
10:03:28 <Cale> cheater99: Well, vector length is almost trivial then :)
10:03:32 <FunctorSalad> (or the right one, but it is biased some way)
10:03:40 <cheater99> is there a chance haskell will receive this functionality at some point?
10:03:42 <twanvl> FunctorSalad: I don't think cale was talking about that identity
10:04:14 <Cale> FunctorSalad: Perhaps more to the point, first f >>> second g is not the same as second g >>> first f
10:04:16 <FunctorSalad> twanvl: not directly but I think it both boils down to how arrows aren't quite as symmetrical as the product notation makes you think
10:04:45 <FunctorSalad> *nod*
10:04:54 <Cale> People draw "first f" usually as f in a box with an extra wire running underneath it
10:05:04 <Cale> But that's not really how it looks in many Arrow instances.
10:05:38 <twanvl> it works as long as you don't move the boxes horizontally
10:05:41 <Cale> It's as if the circuit does something different depending on what order you solder the components onto the PCB :)
10:06:11 <FunctorSalad> twanvl: AIUI it's an issue even with "significant geometry" ;)
10:06:29 <FunctorSalad> since you can break down some diagrams either horiz-first or vert-first
10:06:51 <Cale> However, I think the most useful Arrow instances may actually satisfy the interchange law anyway
10:06:52 <twanvl> ->--[f]---------
10:06:52 <twanvl> ->--------[g]---
10:06:53 <twanvl> vs
10:06:53 <twanvl> ->--------[f]---
10:06:53 <twanvl> ->--[g]---------
10:06:59 <Cale> I've yet to actually check.
10:07:05 <Cale> twanvl: right
10:07:20 <FunctorSalad> (by "significant geometry" I mean that the diagram isn't just a graph, but 2d-cartesian)
10:07:54 <Cale> I think maybe Arrow shouldn't try to generalise monad, but instead take the interchange law as an additional axiom.
10:07:56 <FunctorSalad> Cale: state arrows seems to utterly fail at your example un-equation
10:08:10 <Cale> FunctorSalad: Right, and they're super-confusing to work with.
10:08:20 <twanvl> even in Kleisli [] the order of the output would change, I think
10:08:20 <Cale> But local state is okay
10:08:26 <FunctorSalad> but you'd lose almost all kleisli arrows
10:08:30 <Cale> (like the sort introduced by loops)
10:08:35 <Cale> Right, you would.
10:08:50 <Cale> That's what I meant when I said that perhaps Arrow shouldn't try to generalise monad.
10:09:01 <FunctorSalad> indeed
10:09:02 <cheater99> i guess the answer to my question is 'don't ask' :)
10:09:16 <Cale> cheater99: Sorry, which question?
10:09:22 <cheater99> ahh =)
10:09:25 <Cale> cheater99: I gave you an example of how they're useful.
10:09:33 <cheater99> i was wondering if haskell will ever get the functionality
10:09:37 <Cale> Oh, perhaps.
10:09:54 <cheater99> what are the biggest decision factors?
10:09:56 <twanvl> In haskell this is of course best modeled as  class Arrow a => IntercangeArrow a
10:10:07 <Cale> Or at some point, one of the dependently-typed languages will become practical enough that many of us start using it instead.
10:10:34 <cheater99> at which point haskell would probably keep up with the rest of the cool kids and get it too
10:10:45 <FunctorSalad> seems implausible
10:10:47 <cheater99> why does haskell not have dependent types right now?
10:10:49 <ksf> hey http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.2884 is neat.
10:10:51 <FunctorSalad> it'd be a whole new language
10:10:55 <cheater99> was it considered and rejected?
10:11:05 <soupdragon> I don't think anyone seriously considered this
10:11:07 <ezyang> more like wasn't invented 
10:11:11 <ksf> currying dialogs/wizards is a cool idea
10:11:11 <Cale> cheater99: Because it's a rather fundamental change, and it would be a lot of work to include it in the compiler post-hoc.
10:11:19 <aristid> Cale: if the rate of progress (respectively adoption, actually) doesn't increase massively, that may take a couple decades...
10:11:37 <Cale> aristid: Yeah, couple decades is all
10:11:44 <danharaj> you can call agda code from haskell can't you?
10:12:00 <soupdragon> all I know is that you can call haskell from agda
10:12:02 * hackagebot EuroIT 2010.2.5 - Library for using euro currency, italian language  http://hackage.haskell.org/package/EuroIT-2010.2.5 (PaoloVeronelli)
10:12:16 <cheater99> eh, it doesn't look like it's such a huge bad change to haskell
10:12:17 <Cale> You can generate Haskell code from Agda code, iirc.
10:12:17 <FunctorSalad> danharaj: with *dynamic* checks, presumably
10:12:20 <soupdragon> not sure about the other way around but being able to do it one way with an FP langauge solves both directions
10:12:26 <aristid> Cale: i'm confident that the internet will help us achieve faster progress than in the last 50 years.
10:12:30 <cheater99> i'm sure one hacker could sit down and put it in, in one month.
10:12:32 <Cale> cheater99: I made it look easy
10:12:42 <danharaj> cheater99: Dependent types are a fundamental change to almost every aspect of Haskell, syntax, type system, compiler implementation...
10:12:44 <cheater99> or at least some subset of it.
10:12:47 <soupdragon> The implications of dependent types are much further reaching than you could have realized in this short time
10:12:53 <FunctorSalad> cheater99: you might as well start from scratch, to exaggerate a little
10:13:06 <FunctorSalad> (the non-type-related parts would stay, granted)
10:13:14 <danharaj> You'd probably end up with something like Agda anyway.
10:13:15 <FunctorSalad> as per soupdragon 
10:13:22 <cheater99> but why would it be a *change*?
10:13:29 <cheater99> it looks like it would be an extension, rather than change
10:13:50 <soupdragon> it's a fundamental modification which permeates all aspects of the type system
10:13:51 <ezyang> I think cheater99 is thinking of something like {-# LANGUAGE AgdaMode #-} 
10:13:54 <benmachine> Cale: do you lose information going agda -> haskell though? I understood it as a sort of compilation process, a bit like (but not as severe as) going haskell -> cmm
10:13:55 <FunctorSalad> for one, there's no real distinction between compiletime and runtime anymore
10:13:58 <danharaj> Unlike polymorphism, dependent typing introduces computation into the type system.
10:13:59 <ksf> the tricky part is type inference, which is still a research problem for dependent types
10:14:02 <soupdragon> This is unlike small changes such as typeclasses or GADTs
10:14:06 <cheater99> 'non-dependent' types seem to be just dependent types with no parameters.
10:14:08 <Cale> benmachine: yeah
10:14:12 <FunctorSalad> whereas haskell is the opposite, it eliminates the type system almost totally upon compilation
10:14:13 <Cale> benmachine: It is a sort of compilation
10:14:18 <ksf> ...and haskell won't ever come without type inference. there'd be a revolt.
10:14:32 <soupdragon> you can do type inference with dependent types
10:15:00 <ksf> ...but those proof obligations become tricky...
10:15:04 <Cale> cheater99: You can have terms whose types recursively depend on those terms.
10:15:08 <cheater99> ksf: mhm
10:15:22 <cheater99> cale: explain please
10:16:27 <soupdragon> b-adic numbers are like binary (b=2), decimal (b=10), hexadecimal (b=16)
10:16:52 <hearit> Hello
10:16:56 <soupdragon> hi
10:17:08 <hearit> haskell its a good language to start learning it first of all?
10:17:15 <soupdragon> yes
10:17:19 <ezyang> yup 
10:17:21 <ezyang> @faq 
10:17:22 <lambdabot> The answer is: Yes! Haskell can do that.
10:17:26 <soupdragon> @lyah
10:17:26 <lambdabot> Unknown command, try @list
10:17:29 <soupdragon> @where lyah
10:17:29 <lambdabot> http://www.learnyouahaskell.com/
10:17:32 <hearit> i know html, css, javascript
10:17:34 <soupdragon> hearit, I would recommend this book ^
10:17:35 <hearit> ty sir
10:17:39 <danharaj> @where realworld
10:17:40 <lambdabot> I know nothing about realworld.
10:17:44 <cheater99> soupdragon: any idea what's up with bonus?
10:17:55 <bremner> @where rwh
10:17:56 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:18:02 <cheater99> soupdragon: lyah is broken and i'd sent him some patches, but i think maybe he forgot =)
10:18:14 <philosopher> how to find a substring in a given string ?
10:18:22 <soupdragon> probably best ask him when he is here
10:18:29 <hpc> what parts of lyah broke?
10:18:31 <cheater99> i never see him here
10:18:41 <cheater99> hpc: the highlighter
10:18:47 <hpc> ah
10:18:49 <cheater99> hpc: in 2 ways
10:19:42 <Cale> cheater99: I'm not the best person to ask about this, since I've never actually sat down and written a dependently typed program, but basically, you could have things like a type of trees parametrised by sets of trees which are allowed as children
10:19:58 <Cale> cheater99: who in turn each are typed in the same way
10:19:58 <tolkad> How do I use lists like multidimensional arrays in other programming languages? like [[]] but all sublists have the same length
10:20:12 <pikhq> tolkad: AAAAGH don't.
10:20:19 <tolkad> pikhq: why?
10:20:32 <Cale> cheater99: So you have funny recursive loops between types and terms then
10:20:32 <pikhq> Lists are a terrible, *terrible* replacement for arrays.
10:20:32 <pikhq> O(n) indexing.
10:20:32 <ezyang> tolkad: Check out the vector package 
10:20:34 <tolkad> pikhq: oh... so what do I use?
10:20:44 <pikhq> Check out the vector package.
10:20:55 <Cale> Why not just Data.Array to start with?
10:21:04 <FunctorSalad> IntMap (IntMap Foo) would be another option
10:21:04 <pikhq> Or Data.Array.
10:21:05 <Cale> We *do* have arrays :)
10:21:08 <Mathnerd314> @hackage vector
10:21:10 <lambdabot> http://hackage.haskell.org/package/vector
10:21:11 <tommd1> Vector is the new black, Data.Array isn't.
10:21:28 <tolkad> but... Vector is old in Java
10:21:30 <FunctorSalad> but isn't mutating pure arrays very slow too?
10:21:37 <FunctorSalad> or is that FUD ;)
10:21:44 <tommd1> tolkad: Vector was old in Mathematics before Java gotit.
10:21:48 <FunctorSalad> (nobody says you have to stay pure, sure)
10:21:56 <Cale> tolkad: Also, Vector is almost-but-not-quite completely unrelated to Java's Vector
10:21:56 <pikhq> FunctorSalad: You don't mutate them, you make a new array.
10:22:06 <tolkad> pickles: And I don't think it's O(n). GHC probably optimizes it to the same bytecode whatever you use
10:22:09 <FunctorSalad> pikhq: yes, I phrased it badly
10:22:13 <philosopher> someone ?
10:22:24 <Cale> philosopher: Oh sorry
10:22:26 <soupdragon> tolkad: data T a = a :>- [T a]
10:22:30 <tolkad> pikhq: actually you use realloc
10:22:33 <Cale> philosopher: Missed your question there. :)
10:22:41 <soupdragon> :t isInfixOf
10:22:42 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
10:22:43 <Cale> philosopher: You want the index, or just if it occurs?
10:22:58 <philosopher> the index
10:23:03 <pikhq> tolkad: Data.Array doesn't. It's immutable arrays.
10:23:17 <Cale> philosopher: You can use  findIndex (isPrefixOf needle) (tails haystack)
10:23:18 <tolkad> pikhq: well, it probably will optimize to use that mechanism
10:23:20 <pikhq> You *create a new array*.
10:23:39 <pikhq> tolkad: GHC is not magic.
10:23:39 <tolkad> pikhq: I trust GHC to optimize perfectly, whatever I write
10:23:52 <tommd1> tolkad: You must be new.
10:24:10 <pikhq> It's not very likely to turn O(n) indexing into O(1) indexing or O(n) space into O(1) space.
10:24:11 <philosopher> Cale:  wow lol
10:24:18 * technogeeky puts his magic hands back in the case.
10:24:22 <pikhq> (yes, it happens, but in specific cases, not in general.)
10:24:47 <tolkad> I guess it's because GHC isn't finished yet?
10:25:00 <benmachine> a GHC's work is never done
10:25:01 <pikhq> ... No, it's because GHC doesn't have magic superTuring powers.
10:25:02 <soupdragon> http://www.dcs.ed.ac.uk/home/mhe/plume/report.html
10:25:07 <cheater99> Cale: ahh
10:25:11 <soupdragon> Converted with LaTeX2HTML
10:25:14 <pikhq> And nor does any other compiler.
10:25:18 <soupdragon> does anyone know if there's a way to get the LaTeX?
10:25:31 <tolkad> pikhq: it just requires competent copmiler writers
10:25:44 <soupdragon> ah I found a .p
10:25:44 <Saizan> i thought superTuring powers were scheduled for ghc-6.16
10:25:44 <soupdragon> .ps
10:25:45 <pikhq> tolkad: No. Perfect optimisation is literally impossible.
10:25:49 <zygoloid> the notion of "let's write something horribly inefficient and pray the compiler can make good code" has been pretty thoroughly debunked
10:26:10 <tommd1> tolkad: You seem to be trying to troll, I'll be muting you now and hope you leave the channel.
10:26:18 <zygoloid> GHC can do some great optimizations, sure. but even fully-correct strictness analysis is in general not computable.
10:26:25 <tolkad> tommd1: I'm not troling
10:26:28 <tolkad> trolling*
10:26:40 <cheater99> then start saying things that are interesting
10:26:41 <tolkad> tommd1: perfect optimization is possible for small programs
10:26:52 <soupdragon> lol
10:26:54 <pikhq> Just not in the general case.
10:27:01 <pikhq> Halting problem says "no".
10:27:23 <soupdragon> hey this code is all in haskell
10:27:27 <soupdragon> # David Plume, jointly supervised by Alex Simpson and myself, implemented a calculator for exact real number computation as his BSc honours project. If you prefer, here is a postscript version  of the report. The implementation of the calculator is available in the following tar files: cgi_source.tar.gz, solaris_demo.tar.gz, v1.2.tar.gz. 
10:27:40 <soupdragon> very good
10:27:48 <tolkad> Kolmogorov complexity says no?
10:28:08 <soupdragon> I'm just waiting for someone to compare Godels Incompleteness theorem to Hitler now
10:28:11 <kynky> 10: print "hello world" , 20: goto 10 (is that optimized?)
10:28:27 <aristid> i still think people should write Goedel instead of Godel
10:28:40 <Saizan> kynky: what's there to optimize?:)
10:28:41 <pikhq> kynky: That's source code.
10:28:58 <pikhq> Paste some assembly and then we'll see.
10:29:00 <pikhq> :P
10:29:01 <mauke> I think people should write Gödel
10:29:06 <tolkad> aristid: goady better?
10:29:07 <kynky> :)
10:29:33 <mauke> or Göd̈ël̈
10:29:33 <soupdragon> maybe I'll start saying Kurt instead
10:29:42 <benmachine> heh
10:29:44 <kynky> noop
10:29:46 <benmachine> kurt's incompleteness theorems
10:30:02 <soupdragon> anyway this book is interesting but both HTML and Postscript versions are horrible to read
10:30:09 <mauke> Kür̈ẗ
10:30:37 <benmachine> hmm my deadkey system doesn't want to put an ¨ on an r
10:30:49 <mauke> deadkeys are inferior
10:30:54 <benmachine> I can do ẗ though
10:30:57 <soupdragon> :( why is haskell-math so dead
10:31:00 <twanvl> mäükë, stop that!
10:31:05 <mauke> Spin̈al Tap
10:31:23 <tolkad> Data.Vector isn't working
10:31:25 <tolkad> I can't import it
10:31:37 <mauke> yes, you can! just believe in yourself
10:31:44 <tolkad> "Failed to load interface for `Data.Vector':"
10:31:47 <aristid> mauke: do you use unicode combinators for that?
10:31:52 <mauke> aristid: yes
10:32:10 <aristid> cräzÿ mäükë
10:32:17 <Mathnerd314> tolkad: run 'cabal install vector' first
10:32:22 <tommd1> soupdragon: Who used to posed on haskell-math?  Perhaps they've moved to Isabelle, Agda, Coq, etc?
10:32:31 <Saizan> tolkad: restart ghci/ghc passing "-package vector"
10:32:56 <tolkad> uh... it wants me to run "cabal update"
10:32:57 <pikhq> Ï för önë lövë më sömë cömpösë këÿs.
10:33:29 <twanvl> tolkad: then do that first
10:33:32 <tolkad> now it wants me to cabal install caball-install 0_o
10:33:41 <pikhq> I need to set it to use some more combining characters though.
10:33:46 <mauke> c̈öm̈p̈ös̈ë k̈ëÿs̈
10:34:00 <zygoloid> hey guise, i herd there was some haskel going on here?
10:34:12 <tolkad> I think so
10:34:27 <tolkad> I been lerning them
10:34:59 <tolkad> kinda weerd tho, it wont let me print stuff wen i want to have put it in the main
10:35:07 <mauke> no, we're ℘ℰℛℒ only here
10:35:31 <zygoloid> mauke: oh dear. i wouldn't like to map ord on that :(
10:35:51 <mauke> > map ord "℘ℰℛℒ"
10:35:52 <lambdabot>   [8472,8496,8475,8466]
10:35:55 <tolkad> they should name it caball because haskell has two ls
10:36:16 <mauke> cabell because haskell has an 'e'
10:36:20 <Jafet> Shush! There is no "they".
10:36:31 <benmachine> common architecture for building applications and llamas
10:36:58 <tolkad> 0_o Undefined symbols: "___stginit_vectorzm0zi6zi0zi2_DataziVector_"
10:37:14 <aristid> mauke: each combinator seems to use TWO additional unicode symbols, is that true?
10:37:26 <tolkad> this vector thing is broke
10:37:42 <mauke> ghc --make
10:38:02 <mauke> aristid: huh?
10:38:41 <aristid> > map (\x -> (ord x, x)) "c̈öm̈p̈ös̈ë k̈ëÿs̈"
10:38:42 <lambdabot>   [(99,'c'),(776,'\776'),(246,'\246'),(109,'m'),(776,'\776'),(112,'p'),(776,'...
10:38:56 <aristid> note there are two symbols between c and m
10:39:25 <tolkad> mauke: that just made it say "Linking test..." and not generate an a.out
10:39:35 <mauke> tolkad: it made a test
10:39:36 <dancor> @src takeWhile
10:39:37 <lambdabot> takeWhile _ []                 =  []
10:39:37 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
10:39:37 <lambdabot>                    | otherwise =  []
10:39:47 <mauke> > map ord "c̈öm̈p̈ös̈ë k̈ëÿs̈"
10:39:49 <lambdabot>   [99,776,246,109,776,112,776,246,115,776,235,32,107,776,235,255,115,776]
10:40:09 <dancor> isn't it better reuse to implement takeWhile as fst on span
10:40:24 <zygoloid> > text $ zipWith (\o c -> toEnum (8360+fromEnum c+o)) [0,35,1,-2] "perl"
10:40:24 <lambdabot>   ℘ℰℛℒ
10:40:39 <dancor> with laziness aren't those the same performance?
10:40:51 <tolkad> mauke: oh, I know, my file is named test
10:40:59 <mauke> U+0063 (63): LATIN SMALL LETTER C [c]; U+0308 (cc 88): COMBINING DIAERESIS [̈]; U+00F6 (c3 b6): LATIN SMALL LETTER O WITH DIAERESIS [ö]; U+006D (6d): LATIN SMALL LETTER M [m]
10:41:03 <mauke> aristid: ^
10:41:11 <tolkad> oh, now it works
10:41:13 <tolkad> thanks!
10:41:50 <tolkad> oh, now it's a malformed mach-o file
10:41:55 <tolkad> this vector thing broke my haskell
10:42:04 <aristid> mauke: that's not what ghci and iconv show
10:42:11 <mauke> aristid: but it's the truth
10:42:24 <mauke> aristid: it's also what lambdabot shows
10:44:31 <aristid> oh, i was blind, sorry
10:44:45 <aristid> \246 instead of ö confused me :D
10:46:46 <tolkad> ok, if I import Data.Vector it has that undefined symbol error, and if I use --make and try to run the file it says malformed Mach-o file
10:48:14 <mauke> ok, what happens if you compile with 'ghc -package vector'?
10:49:19 <tolkad> that works
10:49:22 <tolkad> thanks!
10:49:57 <tolkad> The stable version of haskell uses llvm, right?
10:50:02 <tolkad> ghc*
10:50:47 <roaldfre> (wuh?)
10:54:11 <soupdragon> http://blog.sigfpe.com/2010/07/death-to-hydrae-or-denotational.html
10:54:16 <soupdragon> comments on this page are so funny
10:54:51 <tolkad> how do I make my type part of Unbox?
11:03:24 <Saizan> what is Unbox?
11:05:33 <dafis> Saizan, Unbox is a class in Data.Vector.Unboxed
11:06:16 <dafis> it's the class of types for which unboxed vectors exist, I think
11:08:17 <Saizan> tolkad: http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Unboxed.html <- the description here gives an example
11:11:17 <soupdragon> http://pastie.org/1031545.txt
11:11:23 <soupdragon> something really werd happening there
11:11:39 <soupdragon> oh dammit I just realized that I did something well stupid I always do this
11:11:57 <soupdragon> writing 0.666.. when I mean 6*7^(-1)+6*7^(-2)+6*7^(-3)
11:13:50 <tolkad> > [sqrt(1), sqrt(2) ..]
11:13:51 <lambdabot>   [1.0,1.4142135623730951,1.8284271247461903,2.2426406871192857,2.65685424949...
11:14:17 <Veinor> > map sqrt [1..]
11:14:17 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.449489742...
11:14:44 <soupdragon> > sqrt . [1..]
11:14:45 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.449489742...
11:15:01 <Veinor> pfft, you and your . as fmap :P
11:18:41 <aristid> Veinor: it confused me too
11:18:58 <Veinor> @src (.)
11:18:58 <lambdabot> (f . g) x = f (g x)
11:18:59 <lambdabot> NB: In lambdabot,  (.) = fmap
11:19:04 <Veinor> :P
11:21:03 <aristid> oh, i _know_ that (.) = fmap, i just didn't expect it when first reading it
11:21:58 <hpc> how does one cross-compile 32bit haskell on a 64bit machine?
11:22:22 <aristid> 32-bit haskell?
11:23:48 <hpc> i mean, make a 32bit executable
11:23:53 <hpc> with ghc --make
11:24:22 <aristid> hmm
11:24:42 <Saizan> with a 32bit ghc maybe
11:25:47 <aristid> maybe with -fvia-c?
11:26:11 <Saizan> the C code emitted is not portable
11:27:54 <aristid> how do the iPhone / Android people do that, then?
11:29:02 <Saizan> they hacked ghc
11:31:31 <peeler> is there a nice way to define an integer data type with 5 bits of precision? or just data Int5 = 0 | 1 | 2 ... etc ... | 31 ?
11:32:25 <ksf> the C code is portable, but the code from which it generates usually is not.
11:32:44 <ksf> well, modulo actual use of Int
11:32:48 <dafis> peeler: newtype Int5 = Int5 Int; made abstract, and (.&.) evrything with 31?
11:33:07 <aristid> :t (.&.)
11:33:08 <lambdabot>     Ambiguous occurrence `.&.'
11:33:08 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
11:33:08 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
11:33:08 <ksf> you can have a look at the ghc cross-bootstrap howto to get a sense of what's necessary
11:33:12 <dafis> probably faster than the data Int5 = 0 | 1 | ..
11:33:14 <ksf> (hint: you're going to swear)
11:33:22 <aristid> :t (Data.Bits..&.)
11:33:23 <lambdabot> forall a. (Bits a) => a -> a -> a
11:33:28 <ksf> the easy thing is to make a 32-bit chroot and compile there
11:33:32 <dafis> (which would gave to be Zero | One | .. anyway)
11:33:32 <Saizan> data Int5 = 0 | 1 | .. is not valid anyway
11:33:43 <peeler> hmm, ok
11:34:06 <Iago> but I0 | I1 | .. | I31 is ok
11:34:08 <Iago> :P
11:34:22 <Rened> Hello, I have data Twiddle = forall k. Knob k => Twiddle { tw_knob :: k, tw_setting :: Int } which gives me my brain just exploded when I attempt to unpack it. Is there a better way?
11:34:29 <c_wraith> verbose.  I'd be tempted to write TH code that's more verbose to generate it. :)
11:34:52 <tolkad> http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Unboxed.html
11:34:52 <tolkad> I'm trying to understand the example given in the description... but it all seems very complicated...
11:35:07 <Saizan> Rened: use case to upack it
11:35:47 <tolkad> in particular, I don't understand what type is being defined in those first two lines
11:36:22 <Rened> Hmm, case is not as nice as let in monadic code. I guess I could define a function to do the unpacking
11:36:39 <Saizan> tolkad: it's adding new instances to the data families MVector and Vector
11:36:43 <dafis> tolkad: first, you write the type family instance(s), then make those types instances of (M)Vector, then write instance Unbox blah
11:37:13 <Saizan> tolkad: TypeFamilies is a fairly recent extension, but you should find a description on haskellwiki
11:37:25 <Veinor> if I have a list xs, then evaluating the element at position n will cause the evaluated form to 'stick around', right?
11:37:46 <tolkad> ok, I just really started learning haskell yesterday I'm still getting used to it
11:38:20 <dafis> tolkad: then you shouldn't worry about Unbox for at least a week :)
11:38:20 <Saizan> maybe using Data.Vector is not so appropriate then :)
11:38:51 <Saizan> Veinor: yes, if you still have a reference to the list
11:39:11 <Veinor> right.
11:39:47 <Veinor> obviously if the list passes out of scope and gets GCd then you lose the reduction
11:46:25 <Veinor> @src concatMap
11:46:26 <lambdabot> concatMap f = foldr ((++) . f) []
11:46:29 <Veinor> @src [] >>=
11:46:30 <lambdabot> Source not found. :(
11:49:36 * hackagebot bird 0.0.7 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.7 (MattParker)
11:55:02 <aristid> @src [] (>>=)
11:55:02 <lambdabot> xs >>= f     = concatMap f xs
11:55:05 <aristid> yay
11:55:41 <Veinor> ah
11:55:55 <Veinor> @src Integer (>)
11:55:55 <lambdabot> Source not found. My pet ferret can type better than you!
12:00:19 <hpc> @src concatMap
12:00:19 <lambdabot> concatMap f = foldr ((++) . f) []
12:00:28 <hpc> oh
12:00:37 <tolkad> do you restrict something to a type the same way you restrict something to a typeclass?
12:00:38 * hpc reads scrollback
12:00:50 <tolkad> (Class type) => type
14:15:18 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
14:15:18 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Mon Jun 07 12:23:51 2010]
14:15:18 --- names: list (clog winxordie gilbertleung_ preflex jorizma alexbobP reb00t MrFahrenheit trie Eleanore nominolo orlandu63 Edward__ metaliving zax arnihermann miclorb PhilRod_ gnomnain tensorpudding Schmallon mun digitteknohippie edon mattrepl arjanb jeltsch ezeike pf_moore andreo sepp2k hpc Spewns Zolomon itewsh m4thrick wisemanby mtnviewmark base_16 raichoo twl hearit codolio illissius g_cross saccade_ programble andyjgill Iago epicbeardman_ Polarina akosch Jantaro tux21b)
14:15:18 --- names: list (tmug iratsu chrisdone ExtraSpice Tomsik nff buntfalke waern THC4k lpeterse_ jsdelfino lowasser bo0ts__ a11235 danten neurogeek__ mreh_ pao ulfdoz eagletmt dv- Blkt` technogeeky roconnor soupdragon scm LeNsTR okp MoALTz Raynes SubStack BCoppens brachiel philosopher Rayne Ziphilt lopex Itkovian guenni69 SyntaxNinja hiato emmanueloga alios fishey Jafet ajhager carlocci Grey_Fox pickles asap18 Cosmos95 danharaj gogonkt majoh gehmehgeh Jonno_FTW akamaus s76_)
14:15:18 --- names: list (sajith Darkovski philed maqr Taejo chid|sigma leino twanvl vili Icewing jbapple AqD|Home fxr drafty_ eevar dreixel___ apwb ihckt Shown Mowah Spockz niko FireFly comak willb dafis handonson mpiechotka dcoutts cheater99 zeiris_ siracusa ksf paper_cc bababfds grouzen_ noj daimrod mm_freak grouzen maxter G0SUB davidc_ rdd hrehf pukka Amagineer der_milan Chris waterlaz hackagebot dschoepe rdrake Berengal da-x augur amiri jabb jsgf echinus babusri shintah)
14:15:18 --- names: list (Philonous otto_s Ytinasni poseidon wang xinming FunctorSalad fonz objorn ybit drwho mvid Nshag theorbtwo Katovatzschyn dimmy Amadiro dju tommd1 Aszarsha_ bwr magicman gbeshers jesusabdullah adimit sm ksandstr Draconx|Laptop Draconx saccade noddy Aisling kynky mafs pcapriotti Blub\0 dual cozmic taruti raymonvw_ Axman6 ski aiko_ glith JaffaCake dibblego Lajla QtPlatypus Locke-mobile stenobot2010 Saizan tessier srh mattam nchaimov fhs aasmith_ lispy harlekin)
14:15:18 --- names: list (dMazz p_l iFire kermit keseldude Liskni_si milli ankit9 muep Fingerzam arcatan dankna Cale niksnut McManiaC HugoDaniel trez PepeSilvia wto kosmikus sahazel Raku^ alpounet thorkilnaur Jon Warrigal edwtjo creichen exDM69 boyscared otulp ernst shortcircuit palmje drhodes jonathan dax cyanoacry mrshoe theclaw jix arw EvanR-work eyck epmf tafryn sjanssen jth catenate ahihi caligula__ wli Raevel pizza_ yairchu Aikawa bburhans laz0r FauxFaux Jiten hellige)
14:15:18 --- names: list (Guest42356 baaba nornagon newsham ibid shachaf Colours sad0ur slaye albertosantini hzh Fireknight Cthulhon| Baughn pwerken jamwt npouillard mmagee lambdabot fpletz MacCoaster araujo IceDane kaol koninkje_away Starfire ingy Gilly seric snr ps-auxw Sisu TML lenbust andersk mfoemmel Hunner ahf sebbe1991 mike-burns nasloc__ aleator cYmen geekounet jonafan_ MasseR monochrom integral pikhq cjay Igloo scott_ afarmer asdfwef PsiOmega mmagee0 mornfall encryptio)
14:15:18 --- names: list (AnMaster cjs srcerer Philippa obraun shy` nionith bnonym plimsoll aleator_ novas0x2a ClaudiusMaximus lsthemes ville mlh eno dreacu666 Obfuscate stepnem ziman tilman jlouis welterde ptrf CompanionCube erk__ bd_ tltstc Nereid qz dqd alip stalker profmakx shutdown_-h_now ben andrewsw dcoutts_ mquin marienz septic ivan felipe_ olsner megaTherion tromp_ emias MadX` tomaw saiam dixie Veinor TheMagician ricky jsk jb55 jbauman companion_cube Counter-Strike eintopf)
14:15:18 --- names: list (dino- trzkril dogmaT vegai LionMadeOfLions dmwit Taggnostr iizukaway anode tamiko thetallguy1 And[y] makmanalp fabjan thoughtpolice electrogeek joga Apocalisp_ aristid Boney_ kloeri agemo srobertson wagle solrize nniro Zao mauke tew88 elzurk bbee tlax Cerulean Tinned_Tuna ehamberg canvon koala_man dancor drbean twn wjt untwisted aasmith burp hc_e alexsdutton jkramer_ etpace shawn_ DrSyzygy solidsnack SamB_irssi emma dfeuer Twey nimred anders^^ hiredman)
14:15:18 --- names: list (djahandarie alexsuraci qebab PHO_ ezyang absentia peddie_ Taggnostr2 skaar_ Stephan202 joed jd10 _br_ tab shepheb saurik flux LeoD chr1s_ danderson DustyDingo Vq gdsx OnionKnight b4taylor pimeys_ gereedy mietek Laney gds kevinclark igorgue_ ToRA norm2782 nlogax Rooz yrlnry nothingmuch duairc chitragupt luite muhtimin Paradox924X Exteris endojelly dionoea CosmicRay ath yottis Ornedan opqdonut cncl BrianHV helgikrs teratorn dwon cognominal nostrand` quaestor)
14:15:18 --- names: list (yahooooo netcat dropdrive sajkr inr zakwilson quuxman Deewiant Jaak levitation[A] `0660 joni6128 rokoteko defn benc___ petekaz ryanakca pkrumins fihi09 bezik flori erg tavelram Nanar Ke Tomas mrd sohum shajen mux clanehin kalven samferry _2x2l scree biiter kar-1 EvanR jayne twmi earthy zygoloid Botje int-e fab_ tridactyla nzfrio orbitz htoothrot Bleadof cods deavid clarkb_ inimino mfp dons deadguys teukka go|dfish samulihs birkenfeld kadoban Innominate)
14:15:18 --- names: list (bremner mk64ftw_ sbok ibt chromakode twobitsprite smly- ReinH mle sshc Twigathy dcolish dumael stroan SimonRC slabanja mjrosenb suiside cizra jmcarthur zsol StoneToad ve byorgey epokal desu Khisanth ido cypher- pettter edwinb aavogt davidL sproingie Reisen impl quicksilver davean ixzkn Yahovah AnAdorableNick elliottcable bill`` dejones karld Vulpyne companion_square Lemmih MrDomino idnar jdsc osfameron benmachine jml Heffalump tvaalen regulate matthew-_)
14:15:18 --- names: list (pastorn BONUS guerrilla @ChanServ dilinger allbery_b vpetro jql rhlampe jrockway cynick mercury^)
14:15:35 <Veinor> hooray for mplus!
14:15:38 <benmachine> hmm
14:15:52 <benmachine> mauke: that'd only work if return was a -> Maybe a, right?
14:16:35 <benmachine> I'd go with maybe calculateX (return . Just)
14:16:45 <mauke> no, it doesn't work at all
14:16:53 <FunctorSalad> data Nat n = IsZero (n :=: Zero) | forall m. IsSucc (Nat m) (n :=: Succ m)
14:16:54 <benmachine> er, maybe calculateX (return . Just) x
14:16:56 <FunctorSalad> @ mtnviewmark 
14:16:57 <benmachine> or
14:17:06 <benmachine> maybe calculateX (const $ return x) x
14:17:37 <FunctorSalad> type-level Peano integers using the dummy types "data Zero" and "data Succ n"
14:17:57 <soupdragon> that's clever
14:18:02 <soupdragon> to reduce GADTs to ADT+Equal
14:18:12 <mtnviewmark> Right - I see how it works for the "non-empty list" data type given on the GADTs for Dummies page too
14:18:41 <soupdragon> that non-empty list thing is so stupid
14:18:50 <soupdragon> someone should improve it
14:19:11 <mtnviewmark> but I also see that it then you may not be able to case on all constructors in all contexts
14:19:20 <FunctorSalad> nonempty lists are a GADT?
14:19:41 <soupdragon> it's completely unworkable to make nonempty lists this way
14:19:55 <soupdragon> I imagine they only wrote that up because they didn't have a better example that came to mind at the time
14:19:58 <FunctorSalad> isn't it just "data L a = Single a | Cons a (L a)"?
14:20:35 <andreo> mauke: mplus is what I need for my task, thanks!
14:20:53 <FunctorSalad> btw that type is pretty useful if you generalize the 'a' in single... then it's a stream with *lazy* errors
14:21:17 <FunctorSalad> Either monad for error handling breaks lazyness
14:21:27 <FunctorSalad> that type recovers it :)
14:22:26 <aavogt> it's almost like [Either a b]  vs.  Either a [b]
14:22:46 <FunctorSalad> yeah, the former would be "stream with lazy nonfatal errors" I guess
14:25:22 <ParsecNoob> in Parsec, I find the declaration data State  s u = State  { ... statePos  :: !SourcePos ... }
14:25:28 <ParsecNoob> I wonder what the ! stands for
14:25:33 <mauke> strictness
14:25:56 <ParsecNoob> hmmm
14:26:16 <ParsecNoob> really fast answer, thx
14:27:13 <aavogt> your other questions will be lazily evaluated
14:27:39 <ParsecNoob> lol
14:27:59 <FunctorSalad> it means that a State will always contain an evaluated SourcePos instead of a reference to some code that generates a SourcePos (a "thunk"). For certain values of 'evaluated'
14:28:30 <aasmith_> is (sum . map (\_ -> 1)) equal to (foldr (\_ x -> x + 1) 0) in terms of performance?
14:28:37 <FunctorSalad> (namely, it needn't be "deeply" evaluated, just the head (toplevel) constructor must be known)
14:28:52 <ParsecNoob> ah ok that makes it much clearer
14:28:59 <aasmith_> i think the answer is 'yes', but coming from non-functional langusges, i dont understand how
14:29:25 <benmachine> heehee nonfunctional
14:29:30 <aasmith_> :D
14:29:39 <hpc> :t foldr
14:29:40 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:29:45 <FunctorSalad> of course this distinction isn't a distinction if SourcePos is a basic type like Int
14:30:21 <FunctorSalad> or an enumeration of nullary ctors, like Bool
14:31:03 <benmachine> aasmith_: there may be differences in how effectively each is optimised, but they have the same algorithmic complexity and laziness properties
14:31:15 <benmachine> aasmith_: which are the most important bits in general
14:31:24 <FunctorSalad> (I think the concept I'm trying to express is 'flat order')
14:31:24 <aasmith_> ok
14:31:44 <aasmith_> so it seems to be better, stylistically, to prefer the first definition?
14:32:00 <benmachine> aasmith_: well, that's a matter of opinion I think
14:32:22 <aasmith_> i guess as much as style ever is a matter of opinion :)
14:32:31 <benmachine> aasmith_: oh wait, the answer might depend on how sum is implemented actually
14:33:02 <benmachine> I kind of assumed sum = foldr (+) 0 but that's the naive way of doing it
14:33:11 <aasmith_> ah
14:33:15 <benmachine> well
14:33:18 <ParsecNoob> FunctorSalad > thanks, I'll keep it in mind until I'll need a deeper understanding
14:33:30 <benmachine> the only difference is that it's better to use foldl'
14:34:20 <dafis> @src sum
14:34:21 <lambdabot> sum = foldl (+) 0
14:34:28 <aasmith_> :)
14:34:50 <benmachine> yeah
14:34:54 <FunctorSalad> aasmith_: if you need to know exactly how efficient each is, use the ghc-core utility
14:35:08 <benmachine> so if your other example was foldl (\_ x -> x + 1) 0
14:35:08 <dafis> and for common number types, ghc -O is clever enough to evaluate at each step and not build a thunk
14:35:15 <benmachine> then my original answer'd stand
14:35:20 <aasmith_> ok
14:35:37 <benmachine> I think :P
14:35:43 <dafis> foldr (+) 0 is better for a certain kind of lazy number types
14:35:43 <benmachine> maybe I should've just kept quiet >_>
14:35:44 <FunctorSalad> it's hard to deduce it dry-ly because rewrite rules might trigger, or maybe the strictness analyzer (no clue if it would detect this case)
14:35:46 <aasmith_> so there would be no intermediate list built between map'ing the list and sum'ing it
14:35:57 <dafis> (the typical Peano numbers, e.g.)
14:36:01 <benmachine> aasmith_: not necessarily
14:36:11 <benmachine> it's hard to guarantee either way
14:36:19 <Cale> It's the strictness analyser + inlining, I believe.
14:36:32 <benmachine> but there are optimisations that will glue together your list functions
14:36:42 <danharaj> fusion
14:36:47 <Cale> Or if you're talking about removing intermediate lists, that's the fusion rules
14:36:48 <dons> what do you guys think of this: http://i.imgur.com/m2yKr.png
14:36:54 <dons> running time of a haskell program as -A and -H vary
14:37:00 <FunctorSalad> it might somehow get fused with the thing it is applied to, too
14:37:08 <FunctorSalad> (or maybe that's compiler mysticism ;))
14:37:12 <benmachine> dons: pretty colours!
14:37:15 <aasmith_> hah
14:37:27 <dons> you give it a program, and it shows you where the best gc flags are
14:37:44 <dons> and also how complex application / gc / hardware interaction is.
14:37:49 <dafis> dons: awesome graph
14:37:57 <benmachine> so the fastest times are small allocation areas and middling heap sizes?
14:38:08 <Cale> dons: It might be nice to do it for a large spectrum of programs and figure out what GHC's defaults should be
14:38:15 <dons> Cale: yeah, that's the goal.
14:38:25 <dons> back in a little while, just finishing up the tool.
14:38:57 <FunctorSalad> didn't know about these parameters...
14:39:13 <FunctorSalad> (except that there are such parameters in +RTS ;))
14:39:15 <Cale> They're RTS parameters
14:39:20 <Cale> yeah
14:39:44 <FunctorSalad> btw RTS isn't disable-able yet, is it? ticket says 'fixed'
14:39:48 <FunctorSalad> for suid apps
14:39:59 <FunctorSalad> next release then I assume
14:40:05 <dons> ghc 6.12.3 (-rtsopts)
14:41:00 <FunctorSalad> thanks, didn't see that in the flag reference
14:41:10 <FunctorSalad> (maybe the manual was still 6.12.2)
14:41:24 <aavogt> there is a larger spectrum of programs than nofib?
14:41:37 <jesusabdullah> yesfib?
14:41:44 <Botje> filenotfoundfib.
14:41:48 <dons> that graph is binary-trees from the shootout, btw
14:42:25 <aavogt> the shootout probably isn't representative
14:42:35 <FunctorSalad> of what? ;)
14:43:26 <aavogt> of all programs (even those less optimized), of course
14:46:19 * FauxFaux high-fives Botje.
14:46:37 * Botje high-fives FauxFaux 
14:46:41 <Botje> someone had to say it
14:46:54 <Zao> Can't leave it hanging.
14:47:05 <Zao> Oh, that. Yes.
14:50:39 <jmcarthur> i'm still waiting for the ability to hardcode RTS flags into an executable straight from GHC without going through a wrapper
14:51:08 <aavogt> is portability the only concern for wrappers?
14:51:09 <jmcarthur> or has that actually been proposed and rejected at any point?
14:51:13 <mauke> I thought you could do that by defining a certain symbol
14:51:41 <jmcarthur> i thought the only way to do it and still only distribute an executable was by writing a C wrapper to call the haskell main
14:54:27 <edwardk> jmcarthur: you can tweak a few of these by defining symbols: http://www.macs.hw.ac.uk/~dsg/gph/docs/4.06/users_guide/runtime-control.html but i think for the most part you're stuck ;)
14:55:16 <mauke> http://haskell.org/ghc/docs/6.12.1/html/users_guide/runtime-control.html#rts-hooks
14:56:07 <djahandarie> dons, that's pretty nice
15:03:06 <nolrai_portland> @pl setThreadListeningToSignalSlot' signalSlot = newTVarIO =<< (forkIO . forever $ runSignalSlotOnce' signalSlot)
15:03:06 <lambdabot> setThreadListeningToSignalSlot' = (newTVarIO =<<) . forkIO . forever . runSignalSlotOnce'
15:03:19 <nolrai_portland> easy enough
15:06:35 <nolrai_portland> @source ThreadId
15:06:35 <lambdabot> ThreadId not available
15:11:30 <ManateeLazyCat> Wow, i found http://hackage.haskell.org/package/libmpd-0.4.1
15:21:14 <jmcarthur> oh that's nice enough. i thought i had to write a C main to do that
15:21:56 <jmcarthur> still would be nice to have a way to do that via GHC command line (or cabal) only
15:22:40 <monochrom> <3 ghc dynamic linking of shared libs :)
15:27:30 <monochrom> but every package used has to be built for sharing. any single exception gets ghc aborted.
15:28:16 <monochrom> OTOH an executable using the GHC API doesn't need to be 60MB now. :)
15:28:34 <monochrom> (I'm exaggerating with the 60MB part. :) )
15:29:21 <Veinor> @pl \p v x -> p x == v
15:29:21 <lambdabot> flip . ((==) .)
15:29:45 <Veinor> @pl \p x v -> p x == v
15:29:45 <lambdabot> ((==) .)
15:31:12 <mreh_> monochrom: is this new?
15:33:39 <monochrom> since 6.12
15:33:40 <nolrai_portland> I wish there was an $ for types.
15:35:02 <monochrom> I build my whole haskell platform without enabling shared lib. >_<
15:35:07 <monochrom> s/build/built/
15:37:01 <monochrom> hrm, it is probably not obvious how to tell haskell platform's configure to enable shared lib
15:38:00 <mreh_> monochrom: you built ghc with gcc? I am confused
15:39:18 <monochrom> perhaps I should just point you to: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/using-shared-libs.html
15:40:27 <mreh_> good news for licensing
15:41:44 <mreh_> our friend the flying frog comes up 4th when you search for "haskell news"
15:42:10 <mreh_> but I need my haskell is bite-sized digestible chunks
15:42:14 <mreh_> s/is/in
15:42:33 <monochrom> I need my haskell in bite-sized digestible chunks.
15:42:36 <monochrom> too.
15:42:49 <monochrom> I mean, who doesn't. It's almost tautological.
15:43:31 <mreh_> may I introduce you to the language specification?
15:44:12 <mreh_> of course I'm joking, but the salient features need to be highlighted
15:44:33 <mm_freak> mreh_: i can't find him on the first result page
15:44:37 <monochrom> the haskell98 report? I read it all the time. I just read it yesterday about imports and exports.
15:44:43 <mm_freak> but my browser is set to german
15:45:11 <mreh_> mm_freak, http://haskell-news.blogspot.com/
15:45:15 * soupdragon makes a note: pester mm_freak to help me understand this german textbook I can't read yet
15:45:19 <mreh_> check the names closely
15:45:26 <mm_freak> huh?!
15:45:28 <mm_freak> that's him?
15:45:36 <mreh_> :)
15:45:45 <mm_freak> yes, must be him
15:45:53 <mreh_> why would a haskeller advertise his text books
15:46:04 <mreh_> *him*
15:46:05 <soupdragon> oh my god
15:46:06 <soupdragon> LOLOLOL
15:46:07 <mm_freak> the post titles already suggest it's him
15:46:10 <soupdragon> "... and the impartial site Reddit"
15:46:33 <mreh_> He's clearly never spent any time there
15:46:53 <soupdragon> he's probably devoted a solid year of trolling to that site
15:48:36 <mreh_> I intend to see that troll die of starvation
15:51:21 <mreh_> http://www.youtube.com/watch?v=gv-KSWsraWY :D
15:51:38 <McManiaC> what exception does a "hGetChar" on a closed handle raise?
15:53:47 <mreh_> I think there's only one exception in haskell
15:54:12 * hackagebot bird 0.0.8 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.8 (MattParker)
15:54:56 <Jafet> Read manual for Control.Exception
16:03:32 <monochrom> hGetChar on a closed handle throws IOException or IOError (synonyms in GHC). isIllegalOperation applied to the exception says True.
16:03:52 <monochrom> System.IO.Error will help you
16:07:38 <soupdragon> I'm trying to list some number types that can have useful implementations with programs on them
16:07:55 <soupdragon> am I missing much http://pastie.org/1031910.txt ?
16:08:48 <technogeeky> quaternions?
16:08:52 <technogeeky> octonions?
16:09:16 <ski> (`|Z/(n)' meaning `|Z/(n*|Z)' ?)
16:09:27 <soupdragon> yes
16:11:01 <ski> well .. naturals
16:11:15 <technogeeky> hypercomplexes
16:11:28 <ski> maybe ordinals ?
16:11:35 <technogeeky> i don't know what the list is for
16:11:37 <zygoloid> algebraics?
16:11:46 <technogeeky> so i'll shut up until someone affirms or rejects my answers :o
16:12:04 <soupdragon> technogeeky I added everything you said so far to my list
16:12:28 * ski wonders whether there's a constructive conception of surreals
16:12:33 <zygoloid> soupdragon: forall a. a -> F
16:12:44 <technogeeky> ski: reallyreals
16:12:53 <ski> technogeeky : ?
16:12:59 <technogeeky> just being goofy
16:13:02 <technogeeky> still high from exercise :o
16:13:02 <zygoloid> (though i guess that's just vectors over F)
16:15:09 <ski> soupdragon : hm, you want quotients of polynomials, of course (but maybe you take that for granted)
16:15:33 <soupdragon> hadn't thought of that
16:15:34 <technogeeky> split complex
16:15:38 <technogeeky> split quaternions
16:15:44 <ski> so that integers become the quotient of polynomials over naturals, modulo `\x -> x + 1'
16:15:45 <technogeeky> splt - { ... whatever can go in here >
16:15:56 <ski> dual numbers
16:16:01 <technogeeky> yeah
16:16:23 <nolrai_portland> In what modual is the wait command?
16:16:27 <ski> (sedenions ? sextonions ?)
16:16:50 <technogeeky> ski: I think after 8 all of them are the same thing
16:16:53 <technogeeky> in Clifford algebras
16:17:17 <ski> @hoogle wait
16:17:17 <lambdabot> Control.Concurrent.QSem waitQSem :: QSem -> IO ()
16:17:17 <lambdabot> Control.Concurrent.QSemN waitQSemN :: QSemN -> Int -> IO ()
16:17:17 <lambdabot> System.IO hWaitForInput :: Handle -> Int -> IO Bool
16:17:27 <ski> @hoogle+
16:17:27 <nolrai_portland> forgot about hoogle
16:17:27 <lambdabot> Control.Concurrent threadWaitRead :: Fd -> IO ()
16:17:27 <lambdabot> Control.Concurrent threadWaitWrite :: Fd -> IO ()
16:17:39 <ski> no idea if you want any of those
16:17:47 <technogeeky> biquaternion
16:17:53 <technogeeky> which is evidently different from everthing else listed
16:18:03 <soupdragon> never haerd of biquaternion
16:18:16 <soupdragon> oh I see
16:18:24 <technogeeky> http://en.wikipedia.org/wiki/Biquaternion
16:18:39 <technogeeky> also hurtwitz quaternion
16:18:40 <technogeeky> :/
16:18:42 <nolrai_portland> ski: It got me to the right place.
16:19:23 <technogeeky> soup: can you repost the list?
16:20:36 <ski> what's `|F_(p^n)' ?
16:20:41 <soupdragon> finite fields
16:20:43 <technogeeky> hm. never heard of 'urelements'
16:20:45 <technogeeky> cool word
16:21:57 <nolrai_portland> technogeeky: :/ indeed.
16:22:15 <technogeeky> nolrai_portland: :o
16:23:07 * ski . o O ( <http://en.wikipedia.org/wiki/New_Foundations> re `urelements' )
16:23:16 <technogeeky> that... didn't work
16:27:38 <soupdragon> in my language certain types of function (linear transformations, permutations,..) will have printable representations
16:27:56 <technogeeky> language?
16:27:59 <technogeeky> what are you making?
16:28:01 <technogeeky> a math DSL?
16:30:24 * hackagebot ghc-gc-tune 0.1 - Graph performance of Haskell programs with different GC flags  http://hackage.haskell.org/package/ghc-gc-tune-0.1 (DonaldStewart)
16:30:37 <dons> ^^
16:31:10 <technogeeky> cheers dons.
18:41:30 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
18:41:30 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Mon Jun 07 12:23:51 2010]
18:41:30 --- names: list (clog horms FunctorSalad_ mattrepl dankna neurogeek__ dleslie g_cross ccasin adnap vili objorn G0SUB Eduard_Munteanu dolio TR2N tolkad MrFahrenheit mxweas kamatsu plediii iFire` ttmrichter BMeph lopex aavogt LeNsTR barcon332 theorbtwo ryanakca neorab zeussphinx disgrntld kfish jaj alios fhobia reb00t peeler bens QinGW Zeiris Nshag preflex seafood pizza_ _gaffer Edward__ Mathnerd314 lanthan amiri magicman regalia hgolden necroforest ksf m3ga bgs100)
18:41:30 --- names: list (nolrai_portland proq edwardk phenom_ dv_ mwc drk-sd Philonous nettok jethomas mm_freak sigh gilbertleung Gracenotes winxordie jorizma alexbobP Eleanore nominolo orlandu63 zax arnihermann gnomnain tensorpudding digitteknohippie ezeike m4thrick wisemanby base_16 hearit illissius programble Polarina akosch Jantaro tux21b tmug iratsu waern THC4k lowasser a11235 eagletmt dv- tg_afk roconnor soupdragon scm okp SubStack Ziphilt Itkovian guenni69 SyntaxNinja)
18:41:30 --- names: list (emmanueloga fishey carlocci Grey_Fox pickles asap18 danharaj gogonkt majoh Jonno_FTW akamaus s76_ Darkovski philed maqr chid|sigma leino twanvl jbapple AqD|Home fxr drafty_ eevar dreixel___ apwb ihckt Shown Mowah Spockz niko willb handonson mpiechotka dcoutts cheater99 siracusa noj grouzen davidc_ rdd Amagineer Chris hackagebot rdrake Berengal da-x augur jabb jsgf otto_s poseidon wang xinming FunctorSalad fonz drwho mvid Katovatzschyn Amadiro dju tommd1)
18:41:30 --- names: list (Aszarsha_ bwr gbeshers jesusabdullah adimit sm ksandstr Draconx|Laptop Draconx saccade noddy Aisling mafs pcapriotti Blub\0 dual cozmic taruti raymonvw_ Axman6 ski aiko_ glith JaffaCake dibblego Lajla QtPlatypus Locke-mobile stenobot2010 Saizan tessier srh mattam nchaimov fhs aasmith_ lispy harlekin dMazz p_l kermit keseldude Liskni_si milli ankit9 muep Fingerzam arcatan Cale niksnut McManiaC HugoDaniel trez PepeSilvia wto kosmikus sahazel Raku^ alpounet)
18:41:30 --- names: list (thorkilnaur Jon Warrigal edwtjo creichen exDM69 boyscared otulp ernst shortcircuit palmje drhodes jonathan dax cyanoacry mrshoe theclaw jix arw EvanR-work eyck epmf tafryn sjanssen catenate ahihi caligula__ wli Raevel yairchu Aikawa bburhans laz0r FauxFaux Jiten hellige Guest42356 baaba nornagon newsham ibid shachaf Colours sad0ur slaye albertosantini hzh Fireknight Cthulhon| Baughn pwerken jamwt npouillard mmagee lambdabot fpletz MacCoaster araujo IceDane)
18:41:30 --- names: list (kaol koninkje_away Starfire ingy Gilly seric snr ps-auxw Sisu TML lenbust andersk mfoemmel Hunner ahf sebbe1991 mike-burns nasloc__ aleator cYmen geekounet jonafan_ MasseR monochrom integral pikhq cjay Igloo scott_ afarmer asdfwef PsiOmega mmagee0 mornfall encryptio AnMaster cjs srcerer Philippa obraun shy` nionith bnonym plimsoll aleator_ novas0x2a ClaudiusMaximus lsthemes ville mlh eno dreacu666 Obfuscate stepnem ziman tilman jlouis welterde ptrf)
18:41:30 --- names: list (CompanionCube erk__ bd_ tltstc Nereid qz dqd alip stalker profmakx shutdown_-h_now ben andrewsw dcoutts_ mquin septic ivan felipe_ olsner megaTherion tromp_ emias MadX` tomaw saiam dixie Veinor TheMagician ricky jsk jb55 jbauman companion_cube Counter-Strike eintopf dino- trzkril dogmaT vegai LionMadeOfLions dmwit Taggnostr iizukaway anode tamiko thetallguy1 And[y] makmanalp fabjan thoughtpolice electrogeek joga Apocalisp_ aristid Boney_ kloeri agemo)
18:41:30 --- names: list (srobertson wagle solrize nniro Zao mauke tew88 elzurk bbee tlax Cerulean Tinned_Tuna ehamberg canvon koala_man dancor drbean twn wjt untwisted aasmith burp hc_e alexsdutton jkramer_ etpace shawn_ DrSyzygy solidsnack SamB_irssi dfeuer Twey nimred anders^^ hiredman djahandarie alexsuraci qebab PHO_ ezyang absentia peddie_ Taggnostr2 skaar_ Stephan202 joed jd10 _br_ tab shepheb saurik flux LeoD chr1s_ danderson DustyDingo Vq gdsx OnionKnight b4taylor pimeys_)
18:41:30 --- names: list (gereedy mietek Laney gds kevinclark igorgue_ ToRA norm2782 nlogax Rooz yrlnry nothingmuch duairc chitragupt luite muhtimin Paradox924X Exteris endojelly dionoea CosmicRay ath yottis Ornedan opqdonut cncl BrianHV helgikrs teratorn dwon cognominal nostrand` quaestor yahooooo netcat dropdrive sajkr inr zakwilson quuxman Deewiant Jaak levitation[A] `0660 joni6128 rokoteko defn benc___ petekaz pkrumins fihi09 bezik flori erg tavelram Ke Tomas mrd sohum shajen mux)
18:41:30 --- names: list (clanehin kalven samferry _2x2l scree biiter kar-1 EvanR jayne twmi earthy zygoloid Botje int-e fab_ tridactyla nzfrio orbitz htoothrot Bleadof cods deavid clarkb_ inimino mfp dons deadguys teukka go|dfish samulihs birkenfeld kadoban Innominate bremner sbok ibt chromakode twobitsprite smly- ReinH mle sshc Twigathy dcolish dumael stroan SimonRC slabanja mjrosenb suiside cizra jmcarthur zsol StoneToad ve byorgey epokal desu Khisanth ido cypher- pettter edwinb)
18:41:30 --- names: list (davidL sproingie Reisen impl quicksilver davean ixzkn Yahovah AnAdorableNick elliottcable bill`` dejones karld Vulpyne companion_square Lemmih MrDomino idnar jdsc osfameron benmachine jml Heffalump tvaalen regulate matthew-_ pastorn BONUS guerrilla @ChanServ dilinger allbery_b vpetro jql rhlampe jrockway cynick mercury^)
18:41:39 <aavogt> @type on subtract (^2)
18:41:40 <lambdabot> forall a. (Num a) => a -> a -> a
18:42:44 <FunctorSalad_> someone needed URL encoding earlier...  wget "http://$url" |& sed -e 's/^.*http:..//;q'
18:42:48 <FunctorSalad_> *giggle*
18:43:16 <Eduard_Munteanu> You can even 'spawn' it.
18:43:18 <FunctorSalad_> maybe the broken pipe will even stop the wget before it wastes bandwidth for nothing ;)
18:43:37 <Eduard_Munteanu> Oh, right :))
18:43:48 <FunctorSalad_> (the sed will quit after the first line)
18:46:30 <poseidon> So I started learning haskell today.  It's very much different from every language I've ever learned before. However, I think it looks very useful
18:47:39 <FunctorSalad_> that's the unifying belief of this assembly, yes =)
18:48:16 <tolkad> How do I add multiple things in the where of a function without newlines?
18:48:21 <Eduard_Munteanu> I hope there aren't any heretics...
18:48:22 <FunctorSalad_> (well, that and "I somehow added this channel to autojoin and don't bother with every deleting channels from it" ;))
18:48:35 <Eduard_Munteanu> Surely everybody follows the teachings of the great prophet Curry.
18:48:50 <aavogt> tolkad: layout is sugar for { ; }
18:49:23 <FunctorSalad_> where { x=fix error; y = bla }
18:49:37 <aavogt> > let x = a + b where { a = 1 ; b = 2 } in x
18:49:38 <lambdabot>   3
18:49:54 <Eduard_Munteanu> :t error
18:49:55 <lambdabot> forall a. [Char] -> a
18:49:59 <Eduard_Munteanu> :t fail
18:50:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
18:50:04 <poseidon> Well I originally decided to start learning it because my window manager was written in it (and I wanted to make some changes).
18:50:27 <FunctorSalad_> explicit braces are also kinda nice if you want to enclose some expression into something else without relayouting everything
18:50:27 <Eduard_Munteanu> Well it's not yours, it's mine.
18:50:41 <Eduard_Munteanu> I use it too, if you mean xmonad :)
18:50:43 <FunctorSalad_> (the code converges towards line noise, of course)
18:51:00 <poseidon> Yes.  xmonad is a great wm
18:51:03 <FunctorSalad_> but a prettyprinter should be able to restore it
18:51:04 <aavogt> it sounds like you need better editor support
18:51:23 <tolkad> everything I try in haskell ends up with a type error somewhere
18:51:29 <aavogt> FunctorSalad_: is there something prettier than haskell-src-exts for that printing?
18:51:29 <Eduard_Munteanu> poseidon: yeah, it's probably a pain to stare at the config file if you've never seen Haskell.
18:51:43 <FunctorSalad_> aavogt: hmm is the indenter supposed to be smart in vim's haskell mode?
18:51:49 <FunctorSalad_> maybe I missetuped it
18:51:53 <aavogt> FunctorSalad_: no, it's not
18:52:08 <Eduard_Munteanu> I mean to understand it, as opposed to replacing keybindings.
18:52:12 <FunctorSalad_> tolkad: that's why we love haskell...
18:52:24 <FunctorSalad_> it's a lot better than runtime errors
18:52:35 <tolkad> Bus Error
18:52:46 <poseidon> Eduard_Munteanu: that's why I decided to learn haskell.  I'm using the defualt config I found on the xmonad site right now.  However, I want to make some additions to make it work well with my practices and dual monitors
18:52:55 <Eduard_Munteanu> Oookay, now that's surely not a type error.
18:53:30 <tolkad> Eduard_Munteanu: really? I've been staring at my Bus class for hours
18:53:36 <FunctorSalad_> aavogt: emacs's was better, but I was sick of various other things
18:53:43 <FunctorSalad_> (in emacs generally)
18:54:43 <Eduard_Munteanu> poseidon: IIRC, the default config has some keybindings for working with Xinerama.
18:55:20 * Eduard_Munteanu remembers to have a look at Yi...
18:55:57 <Eduard_Munteanu> If it's Vim, eats ctags and can be configured in a saner script plus some goodies, perhaps I'll switch to it.
18:56:03 <soupdragon> blegh I hate when "prove" something and it's completely wrong
18:59:43 <FunctorSalad_> Eduard_Munteanu: I'd love to have a haskell-scriptable editor too but found it hard to get started with Yi
19:00:14 <FunctorSalad_> didn't seem to have any in-program help (maybe I just couldn't find it)
19:00:30 <FunctorSalad_> crucial feature IMHO
19:00:45 <FunctorSalad_> (I mean emacs's describe-function etc and vim's :help)
19:00:51 <Eduard_Munteanu> FunctorSalad_: um, I imagine it's mostly like configuring xmonad, you just look over Haddock stuff and other people's configs.
19:00:58 <Eduard_Munteanu> Ah.
19:01:42 <aavogt> editors are more complicated than window managers
19:01:49 <FunctorSalad_> well, I feel like haskell in general is missing a robust quick-help-for-thing-at-point tool
19:01:58 <Eduard_Munteanu> I really hope it can do one simple thing Vim can't...
19:02:07 <Eduard_Munteanu> Put a damn vertical line at the 80th column.
19:02:17 <FunctorSalad_> the functionality is partially there scattered over various projects
19:02:45 <Eduard_Munteanu> Or if it can't directly, I'll write it myself.
19:02:47 <FunctorSalad_> but I mean something that actually reliably indexes all my haskell source, haddock, and online haddock
19:03:03 <FunctorSalad_> not *** ctags or etags which you have to make manually all the time
19:03:08 <FunctorSalad_> (and locally)
19:03:57 <FunctorSalad_> Eduard_Munteanu: highlight ^.{80}? ;)
19:04:06 <FunctorSalad_> with a background colour
19:04:16 <Eduard_Munteanu> FunctorSalad_: lemme try it...
19:04:22 <FunctorSalad_> that's not the exact command
19:04:29 <Eduard_Munteanu> FunctorSalad_: oh.
19:04:44 <FunctorSalad_> :hi specifies the looks for existing categories
19:04:50 <FunctorSalad_> I think you want :syntax
19:05:14 <Eduard_Munteanu> FunctorSalad_: the thing is, I saw many ML/forum posts on that, but not one hinted it's possible to do that. AFAICT it can only markup if you go beyond the 80th column while writing.
19:05:25 <Eduard_Munteanu> or on existing text, but not on blank space.
19:05:44 <soupdragon> FunctorSalad ahaha I love this p-adic stuff
19:05:50 <soupdragon> I should have learned it earleir
19:06:08 <soupdragon> it's just like binary or whatever except weirder
19:06:18 <Eduard_Munteanu> soupdragon: by stuff you mean the general idea of p-adic numbers?
19:06:23 <soupdragon> yes
19:07:16 <Eduard_Munteanu> soupdragon: look on fractional/negative bases as well if you're into that thing :)
19:07:19 <FunctorSalad_> btw the right escaping is /^.\{0,80\}/
19:07:40 <FunctorSalad_> :syntax match Error /^.\{0,80\}/
19:07:42 <soupdragon> oh that was another thing I was kicking myself for not coming up with!
19:07:44 <FunctorSalad_> but doesn't quite do it
19:08:15 <FunctorSalad_> since it won't highlight parts of the screen that don't exist in the file
19:08:18 <Eduard_Munteanu> FunctorSalad_: exactly, it only works if there is text.
19:08:40 <Eduard_Munteanu> I could probably patch Vim though, but what the heck...
19:08:47 <FunctorSalad_> anyway, I originally intended it more as a ridiculously contrived workaround =)
19:08:58 <FunctorSalad_> there's probably a better way
19:09:01 <Mathnerd314> #ghc seems dead... so... I'm compiling GHC on Windows, and have this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27008#a27008
19:09:11 <Eduard_Munteanu> FunctorSalad_: actually that's what everybody suggested.
19:09:45 <FunctorSalad_> hehe
19:10:20 <FunctorSalad_> you could probably even get a line by highlighting just a subgroup ;) (the char after 79 chars)
19:10:29 <FunctorSalad_> if it wasn't for above prob
19:11:14 * Eduard_Munteanu was even contemplating doing some ugly hack on xterm to draw a vertical line, but couldn't spare a day :)
19:11:23 <FunctorSalad_> Eduard_Munteanu: fractional/negative? just as a base for ordinary numbers or actually like the p-adics?
19:11:38 <FunctorSalad_> hehe
19:11:49 <Eduard_Munteanu> FunctorSalad_: I know it for ordinary numbers. But it might work for p-adic.
19:11:53 <FunctorSalad_> or why not draw over the whole screen ;)
19:12:03 <FunctorSalad_> with some contraption to calculate the pixel ;)
19:12:18 <FunctorSalad_> (could you do that with xcompmgr or whatsit?)
19:12:30 <Eduard_Munteanu> FunctorSalad_: yeah, based on a value derived from the font size and xmonad border :)
19:12:50 <Eduard_Munteanu> Dunno, I never touched X API.
19:13:14 <FunctorSalad_> or it could empirically find it out by inserting 80 characters and parsing the screen
19:13:16 <FunctorSalad_> ;)))
19:13:24 <FunctorSalad_> (bitmap)
19:13:29 <Eduard_Munteanu> Heh, yeah.
19:13:57 <kmc> anyone know if i can use ghc --make with ghc -C?
19:14:02 <FunctorSalad_> (not what I'd really do, of course... font metrics are available buried somewhere in the x bindings)
19:14:06 <kmc> (just putting them both on the command line doesn't work)
19:14:06 <FunctorSalad_> (I think)
19:14:17 <kmc> i want to chase dependencies automatically, but only build .hc files
19:15:18 <FunctorSalad_> guess: --make -keep-tmp-files? if you don't mind the useless further compilation
19:15:25 <etpace> I have two parsec parsers, is there a combinator that will run both of them, and return their results, but if one of them fails it does so silently, and just does not return anything?
19:15:38 <FunctorSalad_> oh, there's even -keep-hc-file
19:16:09 <Eduard_Munteanu> Isn't ghc --make some ugly replacement for a proper build system?
19:16:29 <FunctorSalad_> ugly? never had an issue with it
19:16:35 <Eduard_Munteanu> I mean do real packages use that?
19:16:40 <aavogt> and it's not a replacement
19:16:58 <FunctorSalad_> well, it doesn't install your stuff or install deps
19:17:22 <FunctorSalad_> but it always did its job of topo-sorting and compiling sources for me
19:17:34 <Eduard_Munteanu> In most other compiled languages there's some way to ask the compiler for dependencies, then the build system goes over them automatically.
19:18:08 <FunctorSalad_> seems more convenient to skip dumping the deps to a makefile
19:18:29 <FunctorSalad_> and just have ghc follow the deps it calculated (as it does with --make)
19:19:06 <Eduard_Munteanu> I see.
19:19:39 <kmc> FunctorSalad_, that's what i'm doing now; i'm interested in avoiding the useless compilation
19:19:46 <kmc> Eduard_Munteanu, ghc also has -M for that
19:19:51 <kmc> but it's not used so much
19:19:58 <Eduard_Munteanu> Ah.
19:20:04 <kmc> real packages use cabal, almost by definition
19:20:17 <Eduard_Munteanu> kmc: well then you could use -M and run ghc -C on each of them.
19:20:20 <kmc> Eduard_Munteanu, yes
19:20:28 <kmc> i'm looking for something simpler
19:20:41 <kmc> ghc --make is extremely convenient
19:20:56 <kmc> and Cabal is a proper build system
19:20:57 <Eduard_Munteanu> Yeah, I use it too, but didn't work with big enough projects.
19:21:01 <kmc> and i don't think we're missing anything inbetween
19:21:07 <kmc> but what i'm doing is just weird and outside the norm
19:21:58 <kmc> etpace, how would it not return anything? would return in Maybe or such?
19:22:40 <kmc> etpace, and if the first parser consumes input before failing, what should be done?
19:23:23 <etpace> is there a way for a parsec parser to return multiple values?
19:23:40 <etpace> might be an easier way, my question before was a hackish way of doing so
19:24:02 <kmc> etpace, not as such -- you'd just return a list
19:24:07 <Eduard_Munteanu> kmc: did you try it? 'touch' a few files and perhaps use -v and see what happens.
19:24:17 <kmc> try what?
19:24:24 <Eduard_Munteanu> kmc: combining the two of them
19:24:29 <Eduard_Munteanu> --make and -C
19:24:30 <kmc> -M with -C
19:24:32 <kmc> oh
19:24:36 <etpace> hmm, the problem is that my other parsers don't return a list, is there a "flatten" that I can call to flatten the list or something?
19:24:36 <kmc> it says explicitly you can't use --make with -C
19:24:41 <Eduard_Munteanu> Oh.
19:24:49 <kmc> etpace, i'm not sure what you want
19:24:55 <FunctorSalad_> you could automize the -M with -C process with a haskell script ;)
19:24:58 <kmc> yeah i could
19:25:03 <kmc> i'm looking for easy answers
19:25:05 <kmc> ;P
19:26:23 <Eduard_Munteanu> Actually I'm not sure what would -M do for Haskell, there's a slight difference with C code.
19:26:37 <FunctorSalad_> btw I scribbled down a basic version of the #!/usr/bin/compileAndRunhaskell thing... seems useful
19:26:46 <Eduard_Munteanu> In C code, dependencies mean something along the lines of "check if headers modified".
19:27:01 <etpace> Basically my parsers return an a, so my end result is [a], but one of the parsers is a special case that wants to return two a's, now I guess i could make everything return [a] and concat at the end, but is there a combinator that takes a parser of [a] and changes it into a, and just returns each item into the final list
19:27:10 <FunctorSalad_> you can simply leave haskell scripts anywhere as you would leave bash scripts... yet they'll get compiled
19:27:11 <kmc> Eduard_Munteanu, for GHC, it produces a dependency of each .o file on some .hi files
19:27:12 <FunctorSalad_> (once only)
19:27:13 <Eduard_Munteanu> But in Haskell you don't have that, so it should compile even other compilation units.
19:27:17 <kmc> nice FunctorSalad_
19:27:24 <FunctorSalad_> (to a global cache)
19:27:33 <kmc> etpace, no there isn't
19:27:37 <Eduard_Munteanu> I see.
19:27:59 <kmc> there's a combinator that takes a parser of a and turns it into a parser of [a]
19:28:01 <FunctorSalad_> I'd upload it to hackage but I guess it needs some more customizability
19:28:03 <kmc> but the other direction wouldn't make any sense
19:28:21 <FunctorSalad_> like autoimports added to every source
19:28:41 <Eduard_Munteanu> etpace: could you refine your data type to be able to express that case too?
19:29:10 <Eduard_Munteanu> etpace: like data Return a = NormalCase a | SpecialCase (a, a)
19:29:18 <FunctorSalad_> (actually there's no limit on syntax modifications you could add to this system, to make haskell more convenient for shell scripts)
19:29:21 <kmc> i'd not use  atuple there
19:29:30 <peeler> if i have "class Argle where bargle::(Show b)=>a->b", that's valid code that GHCi loads happily
19:29:33 <Eduard_Munteanu> Um, yeah.
19:29:36 <peeler> but it seems impossible to have any instance
19:29:53 <kmc> peeler, it gives me an error
19:29:58 <kmc> No parameters for class `Argle'
19:30:06 <peeler> oh sorry
19:30:10 <peeler> Argle a
19:30:10 <kmc> it's definitely not valid H98
19:30:30 <kmc> oh sure
19:30:30 <FunctorSalad_> Show b doesn't help you to produce a b at all
19:30:35 <soupdragon> I would expect   instance Argle a where bargle = bargle   to work
19:30:39 <kmc> that's a valid class
19:30:42 <FunctorSalad_> and "forall b. a -> b" is impossible even for fixed a
19:30:47 <FunctorSalad_> execpt undefined
19:30:52 <peeler> instance Argle Char where bargle c = c
19:30:53 <kmc> and you can write instances, but bargle will never return a value successfully
19:30:54 <peeler> fails
19:30:59 <soupdragon> yes because c isn't b
19:31:00 <soupdragon> oops
19:31:00 <kmc> right, it has the wrong type
19:31:02 <soupdragon> yes because a isn't b
19:31:25 <kmc> the class is a red herring here.  bargle is just as impossible if it's (Show b) => Char -> b
19:31:57 <kmc> however, if Show were, say, Monoid, you could do it
19:32:01 <peeler> so the final returned value has to be a concrete type, not a class contrained type variable?
19:32:04 <kmc> no
19:32:13 <Eduard_Munteanu> peeler: it can be constrained.
19:32:16 <kmc> the issue here is that all we know about b is that it's in Show
19:32:20 <Eduard_Munteanu> In that case you can write it as a -> a
19:32:22 <kmc> and so all we can use to make a 'b' is what Show provides
19:32:25 <tolkad> if I have data X = X {a :: Integer} how do I make a an instance of a function for some class I want X to be part of?
19:32:41 <kmc> however, (Show b) provides no way to create values of type b, only a way to turn them into strings
19:32:46 <kmc> but other classes might provide that
19:32:46 <tolkad> if I have data X = X {a :: Integer} how do I make "a" an instance of a function for some class I want X to be part of?
19:33:13 <kmc> so it depends on the class
19:33:14 <Eduard_Munteanu> tolkad: forall a. Class a => ...
19:33:16 <FunctorSalad_> peeler: the reason you can't write an instance is that Show only lets you consume bs, but you want to produce a b
19:33:31 <kmc> for example, if you replace "Show" with "Read", then "Argle String" has a very natural instance
19:33:33 <FunctorSalad_> which isn't possible polymorphically
19:33:48 <peeler> ok, that makes some sense
19:33:51 <kmc> tolkad, what does that mean?  an "instance of a function"?
19:34:15 <Eduard_Munteanu> He probably asks for a restriction to some class.
19:34:16 <FunctorSalad_> (uh, bad way to say it... I mean it isn't possible without breaking parametricity through some ghc hack maybe)
19:34:19 <Eduard_Munteanu> Not an instance.
19:34:32 <kmc> i've no idea, because "a" there isn't polymorphic at all
19:34:42 <kmc> "a" is just a name for that field
19:34:45 <FunctorSalad_> I agree, the 'a' is a red herring
19:34:47 <Eduard_Munteanu> Oh, duh.
19:34:55 <tolkad> kmc: well... if I want make type to be part of a class, I need to do it like "instance Class X where <functions>"
19:35:01 <Eduard_Munteanu> Record syntax.
19:35:20 <tolkad> kmc: but I want those things in the { ... } in the data declaration to be implementing the class functions
19:35:30 <FunctorSalad_> (since to show impossibility, we assume you had an instance. that instantiates a to a *mono*type)
19:35:42 <Eduard_Munteanu> Is he asking for a GADT?
19:36:03 <Eduard_Munteanu> Otherwise I don't get it.
19:36:31 <peeler> so is there any way for me to say, hey GHC, I guarantee that all the instances will evaluate to instances of <some typeclass>
19:36:44 <FunctorSalad_> peeler: to reiterate, your class is legal, it just has no implementation for reasons that have nothing to do with typeclasses
19:37:10 <FunctorSalad_> (no impl other than bargle = undefined and bargle _ = undefined)
19:37:14 <tolkad> uh... like data X = X Integer
19:37:14 <tolkad> instance Class X where a X int = int
19:37:38 <tolkad> I think
19:37:42 <FunctorSalad_> (that these are different is another long story, but not the point ;))
19:37:42 <tolkad> I might be totally confused
19:38:20 <kmc> tolkad, it seems that you are
19:38:23 <tolkad> I want to do that with the data X = X {a :: Integer} syntax
19:38:35 <FunctorSalad_> peeler: you have no implementation because for any given monotype X, there is no function of type "forall b. Show b => X -> b"
19:38:38 <Eduard_Munteanu> That datatype is bound to a certain type.
19:38:47 <kmc> tolkad, «data X = X { a :: Integer }» is sugar for «data X = X Integer; a (X x) = x»
19:38:49 <FunctorSalad_> except the two trivial ones I gave
19:39:03 <kmc> tolkad, figure out what you want to do without the sugar
19:39:07 <kmc> then we can give advice on adding it
19:39:47 <peeler> i'm going to be confused about this one for a while.
19:40:00 <kmc> peeler, you can add a superclass constraint
19:40:05 <kmc> «class (Eq a) => Num a where ...»
19:40:17 <FunctorSalad_> peeler: it's about the impossibility of that type, not about classes
19:40:20 <tolkad> kmc: without sugar, I want data X = X Integer; instance SomeClass X where a (X x) = x
19:40:29 <Eduard_Munteanu> peeler: if you're familiar with the Curry-Howard isomorphism, that corresponds to a theorem where a fixed proposition X implies _any_ other proposition.
19:40:33 <kmc> tolkad, ah.  so you want to move the field accessors into a type class?
19:40:41 <tolkad> kmc: yes
19:40:43 <kmc> tolkad, can't be done directly.  you basically have to do it the non-sugary way
19:40:49 <tolkad> kmc: ah, ok
19:40:52 <tolkad> kmc: thank
19:40:56 <tolkad> thanks*
19:40:59 <kmc> tolkad, field labels are pretty primitive
19:41:03 <FunctorSalad_> Eduard_Munteanu: any proposition which implies String ;)
19:41:08 <kmc> tolkad, Haskell's record syntax is kind of sucky
19:41:10 <soupdragon> FunctorSalad (your probably gettnig bored of me by now ;d) I found that limit construction on here!
19:41:11 <soupdragon>  http://planetmath.org/encyclopedia/PAdicIntegers.html
19:41:13 <FunctorSalad_> which doesn't help you
19:41:15 <Eduard_Munteanu> Well, yeah.
19:41:16 <kmc> look at the fclabels package for some alternatives
19:41:30 <Eduard_Munteanu> We all know String is inhabited.
19:41:45 <FunctorSalad_> soupdragon: anything wrong with what I said about it?
19:41:49 <soupdragon> no
19:41:55 <soupdragon> dont think so
19:42:31 <Eduard_Munteanu> Actually some stuff I've seen use that as a definition for negation.
19:42:52 <FunctorSalad_> funny bruteforce argument for compactness there though ;)
19:42:53 <Eduard_Munteanu> i.e. a type synonim like type Not x = (forall a. x->a)
19:43:10 <tolkad> you guys have names for everything
19:43:12 <FunctorSalad_> (they use the theorem that arbitrary products of compact spaces are compact, apparently)
19:43:28 <FunctorSalad_> like?
19:43:56 <tolkad> like "monotype"... what's that supposed to mean? it seems redundant, if you use the word "type", you are referring to one type, otherwise you would use the word "types"
19:44:13 <FunctorSalad_> tolkad: as opposed to polymorphic type
19:44:29 <Eduard_Munteanu> tolkad: polymorphic types still refer to one type, it's only that it can be one of many.
19:44:35 <FunctorSalad_> a monotype uses no type variables
19:44:41 <danharaj> Most type systems distinguish between monotypes and polytypes. If you don't then the theory becomes significantly more complicated.
19:44:50 <FunctorSalad_> (no bound ones too? not sure, but probably not)
19:44:56 <tolkad> oh, it makes sense now
19:45:17 <kmc> danharaj, how do you mean?  does System F has this distinction?
19:45:21 <tolkad> a type along with a parameter can be thought of as a combination of two types, hence monotype and polytype
19:45:38 <kmc> not really
19:45:38 <danharaj> kmc: It was my understanding that if you restrict impredicativity, you make a distinction between monotypes and polytypes.
19:45:49 <tolkad> kmc: darn it, I thought I understood
19:45:56 <FunctorSalad_> the whole expression "forall a. a -> a" would be a polytype
19:45:58 <Eduard_Munteanu> The combination of types is really either a synonym or a constructor + type.
19:46:00 <kmc> tolkad, it's not a combination of two types.  it's a "function" on types
19:46:11 <kmc> "Maybe" is a function that takes a type x and gives you another type "Maybe x"
19:46:23 <kmc> that's why systems like System F have explicit lambdas and application for types
19:46:24 <FunctorSalad_> (or actually it's an expression denoting a polytype, for the lawyers ;))
19:46:31 <Eduard_Munteanu> You could call those functors, if you fancy that, I think.
19:46:36 <danharaj> (Maybe is a type operator, not a polymorphic type, non?)
19:46:43 <FunctorSalad_> danharaj: right
19:46:48 <tolkad> is there a type identity function?
19:47:14 <Eduard_Munteanu> I don't think you can spell it.
19:47:22 <danharaj> You can't spell it in Haskell.
19:47:32 <kmc> in SysF,  «map :: ∀a b → (a → b) → ([a] → [b])», and you'd apply it like «map Int String [1,2,3]».  to use Haskell-like syntax
19:47:41 <tolkad> Is my spelling that bad?
19:47:52 <Eduard_Munteanu> :)
19:47:52 <kmc> err
19:47:56 <danharaj> tolkad: no, we mean express it in Haskell syntax :D
19:47:57 <kmc> «map Int String show [1,2,3]»
19:48:24 <danharaj> tolkad: how much do you know about lambda calculus?
19:48:25 <FunctorSalad_> (btw, "forall a. a -> a" is not the same as "for every a, I have a function of type a -> a"
19:48:27 <FunctorSalad_> )
19:48:35 <tolkad> danharaj: I looked at the wikipedia page
19:48:35 <Eduard_Munteanu> There's no way to write a method like f :: a -> m a, where m a = a
19:48:38 <FunctorSalad_> the left one is more constrained
19:48:47 <tolkad> danharaj: it sorta made some sense
19:48:52 <FunctorSalad_> for details see 'parametricity'
19:49:21 <danharaj> tolkad: ok, if you want to understand this kind of stuff, the best book for beginners is "Types and Programming Languages" by Benjamine Pierce
19:49:22 <kmc> showAll = Λt. map t String show
19:49:23 <FunctorSalad_> (the forall a. a -> a has to treat all the types the same in a sense)
19:49:25 <Eduard_Munteanu> But you can write stuff like m (m a) -> m a if that's what you intend.
19:49:48 <danharaj> tolkad: This stuff is hard, even if it looks so simple, so don't get discouraged by mistakes :p
19:50:16 <Eduard_Munteanu> Perhaps it's fair to put a big warning there reading "MATH!".
19:50:35 <danharaj> Pff, any sufficiently advanced computer science is indistinguishable from abstract mathematics.
19:50:50 <soupdragon> hehe
19:50:55 <tolkad> I was thinking... maybe there's some way I could have all my functions return a tuple of (x, IO ()) and then I could use IO everywhere, and put actual return values in the x part
19:51:04 <FunctorSalad_> isn't that more a statement about the map than the territory? fields overlap
19:51:05 <danharaj> tolkad: nope.
19:51:13 <danharaj> tolkad: the type system is secure. No sneaking.
19:51:14 <FunctorSalad_> though it may contain some truth about the territory too
19:51:24 <Eduard_Munteanu> tolkad: you can't really.
19:52:01 <kmc> CS is math
19:52:06 <kmc> not just "advance computer science"
19:52:23 <tolkad> kmc: applied math?
19:52:23 <kmc> CS is a (poorly named) branch of math, like analysis or topology
19:52:27 <FunctorSalad_> you can't get an real actual 'x' and a recipe for a unit from a recipe for an 'x'
19:52:31 <Eduard_Munteanu> tolkad: instead be content with separating stuff into pure and monadic code, and binding function to function.
19:52:31 <FunctorSalad_> </cliche>
19:52:56 <danharaj> The structure of IO forces you such that you can only get values from input inside IO, put your own values inside IO (return), and use those values only to make more IO
19:52:59 <danharaj> (bind)
19:53:00 <FunctorSalad_> (without executing the recipe, of course, which would make the whole action a recipe again)
19:53:08 <Eduard_Munteanu> kmc: actually I disagree... math is a poor name for science.
19:53:20 <danharaj> Informatique
19:53:25 <danharaj> but that's dirty and french.
19:53:31 <FunctorSalad_> kmc: applied CS seems far from math
19:53:42 <danharaj> Applied math seems far from math.
19:53:46 <kmc> FunctorSalad_, then maybe we should draw that boundary elsewhere
19:53:48 <soupdragon> applied math is physics??
19:53:51 <kmc> i don't know
19:53:55 <Eduard_Munteanu> Just saying "math" says a lot, because you're talking about lots of different pure scientific branches.
19:53:58 <kmc> it's pointless arguing about words
19:54:00 <FunctorSalad_> (user interfaces and stuff? that stuff is important too, don't get me wrong)
19:54:11 <danharaj> kmc: I agree, philosophy is pointless.
19:54:13 * danharaj rimshot
19:54:18 <FunctorSalad_> kmc: indeed
19:54:27 <kmc> user interfaces? sounds like software engineering or usability engineering etc.
19:54:30 <kmc> not computer science
19:54:53 <FunctorSalad_> these aren't subfields? language again ;)
19:54:53 <danharaj> The vast majority of software engineering uses trivial bits of computer science.
19:55:07 <kmc> now there are some bits of what i'd call CS that are pretty applied
19:55:22 <danharaj> The most advanced abstractions the average programmer works with are cute little toys.
19:55:31 <Eduard_Munteanu> Now of course it's all math, since you're lumping a great body of knowledge only by its pureness vs applied.
19:55:37 <FunctorSalad_> there's applied math that uses computers, too ;)
19:56:23 <kmc> gdb says: "Killing inferior"
19:56:25 <kmc> harsh
19:57:07 <Eduard_Munteanu> danharaj: true, it's trivial in the sense it's known to be solvable.
19:57:12 <FunctorSalad_> 'kill' might have been a bad name choice
19:57:23 <Eduard_Munteanu> But judging by the complexity it isn't really.
19:57:40 <kmc> the way software is written in industry often bears little resemblance to either software engineering or computer science
19:57:50 <FunctorSalad_> no non-techy is going to believe me that 'kill'ing stuff is everywhere in linux/unix and not my twisted personal joke
19:58:01 <FunctorSalad_> if someone looks over your shoulder or so ;)
19:58:08 <danharaj> Eduard_Munteanu: I disagree, that stuff is trivial in complexity. Have you ever read Gang Of Four's Design Patterns? It think it's cute.
19:58:17 <danharaj> I*
19:58:21 <FunctorSalad_> especially with a bloody-red root prompt
19:58:21 <Eduard_Munteanu> FunctorSalad_: just tell your neighbor you're killing children :)
19:58:29 <kmc> sigh design patterns again
19:58:32 <djahandarie> I have a lock for a reason FunctorSalad_ 
19:58:32 <FunctorSalad_> ^^
19:58:51 <kmc> FunctorSalad_, it's common slang in many fields.  "to kill" often means to stop or shut down any machine or process
19:59:05 <danharaj> If Haskell had an analogue of Design Patterns, it would be a journal issue.
19:59:05 <Eduard_Munteanu> danharaj: ah. I thought you meant theoretical CS vs. actually writing applications.
19:59:09 <kmc> killing rumors, kill the engine, etc
19:59:09 <FunctorSalad_> uncyclopedia played a nice one on this...
19:59:20 <FunctorSalad_> screenshot of "htop" with subtitle "the process murderer"
19:59:26 <FunctorSalad_> on the linux article or so
19:59:26 <kmc> i prefer psdoom
19:59:45 <Eduard_Munteanu> Yeah, that's fun.
19:59:51 <FunctorSalad_> there's a 'slay' utility in apt too o_O
19:59:56 <kmc> recognizing "design patterns" is necessary and important, so that you can eliminate them with libraries or language extensions
20:00:02 <Eduard_Munteanu> Slay? I've seen that in QNX.
20:00:28 <kmc> in C++ and Java this is difficult, so you have to memorize the design patterns as meat-macros instead
20:00:46 <kmc> we have patterns in Haskell but they tend to piss people off, and eventually we get very clever libraries to avoid them (e.g. fclabels)
20:00:51 <soupdragon> don't understand how these things only have finitely many decimal places
20:00:54 <kmc> we don't see it as a good thing
20:01:06 <FunctorSalad_> Eduard_Munteanu: reaping zombified children...?
20:01:11 <Eduard_Munteanu> Codebases in general actually have a very high complexity, even though they're scientifically trivial.
20:01:12 <kmc> also the waters are muddied by the subsequent definition of "design pattern" as "anything the patterns community wants to encourage"
20:01:16 <FunctorSalad_> because you didn't properly listen to their death?
20:01:19 <FunctorSalad_> o_O
20:01:22 <Eduard_Munteanu> FunctorSalad_: aye. :)
20:01:28 <kmc> in other words many of them are not "patterns of code" at all, but vague best practices or ideas
20:01:51 <soupdragon> aha because p^-i diverges
20:02:03 <FunctorSalad_> soupdragon: these things=?
20:02:08 <soupdragon> p-adic
20:02:08 <necroforest> "meat macros"
20:02:10 <necroforest> i like that
20:02:10 <soupdragon> numbers
20:02:25 <kmc> 'the software crisis will be solved forever if i can get the word out about my Write Good Code Pattern and my Writing Code That Sucks Antipattern"
20:02:26 <FunctorSalad_> you mean stuff like 1/2 in 7-adic? that has infinite expansion
20:02:33 <FunctorSalad_> but to the *left*
20:02:34 <soupdragon> no I mean cauchy sequences of rationals
20:02:39 <FunctorSalad_> ah ok
20:02:43 <soupdragon> like (p^-i)
20:02:48 <soupdragon> it's not p-cauchy
20:03:12 <soupdragon> which explains why they have only finitely many decimal places
20:03:22 <soupdragon> where as real numbers can go on forever like pi
20:03:34 <Gracenotes> kmc: python doesn't have design patterns
20:03:38 <kmc> heh
20:03:40 <soupdragon> they go forever backwards lol
20:03:41 <Gracenotes> kmc: it has 'pythonic'
20:03:43 <danharaj> Python has olololol
20:03:46 <kmc> haha
20:03:52 <soupdragon> wonder what pi is in 7-adics
20:03:52 <Gracenotes> which is much, much worse
20:03:56 <Gracenotes> -.-
20:03:59 <soupdragon> does anyone know how to calculate it
20:04:05 <soupdragon> how many places would it  have ?
20:04:10 <FunctorSalad_> soupdragon: you mean the places after the period that you get from upgrading the p-adic integers to p-adic rats?
20:04:18 <soupdragon> yes
20:04:20 <FunctorSalad_> they're always finite? interesting
20:04:42 <soupdragon> FunctorSalad, I think we could use that earlier result too actually! (easier than the cauchy-ness stuff)
20:04:44 <FunctorSalad_> (well, it's true by definition from the algebraic adjoining of 1/p, but still)
20:04:53 <soupdragon> yes exactly that is a much neater proof
20:05:00 <necroforest> python has The One True Way, and anyone who disagrees is clearly a troll
20:05:11 <FunctorSalad_> (since freely adjoining stuff to an algebraic structure never produces actually infinite terms)
20:05:25 <FunctorSalad_> is it a proof?
20:05:36 <danharaj> Python has a hipster culture.
20:05:36 <Eduard_Munteanu> Adjoining?
20:05:43 <soupdragon> FunctorSalad, well I think so... but I don't have as much rigor as other folks
20:05:51 <Eduard_Munteanu> Like the opposite of forgetful?
20:06:18 <Eduard_Munteanu> Ah, no, it is specific to the p-adic discussion.
20:06:21 <FunctorSalad_> soupdragon: actually I was being vague; the thing I found 'interesting' was more how it's both finite as you say, and metrically complete
20:06:35 <FunctorSalad_> (which is not obvious from the algebraic construction, or is it?)
20:07:02 <soupdragon> are the integers complete
20:07:04 <soupdragon> ?
20:07:09 <soupdragon> I suppose not
20:07:44 <FunctorSalad_> hmm shouldn't they be? compact subset of a complete metric space?
20:07:45 <Eduard_Munteanu> soupdragon: here's another one for you, from analysis, I found it interesting a while ago: generalized derivatives and integrals. Like multiplicative derivatives and integral (instead of differential and summative)
20:07:47 <soupdragon> FunctorSalad: There is a cauchy sequence based proof in my book but I don't understand it :/
20:07:52 <FunctorSalad_> they fail to be a *field* though ;)
20:08:05 <Eduard_Munteanu> soupdragon: could look at "Product integral" for a taste.
20:08:31 <FunctorSalad_> soupdragon: I guess you have to do something with cauchy sequences at *some* point anyway
20:08:43 <FunctorSalad_> if you want to show that the metric and the algebraic construction are the same
20:08:44 <soupdragon> Eduard_Munteanu: oh man :D this looks interesting!
20:08:45 <Eduard_Munteanu> Some material for when the p-adic craze is over :P
20:09:44 <FunctorSalad_> or did you mean the ordinary integers?
20:10:02 <FunctorSalad_> they are metrically complete (every cauchy sequence is eventually constant)
20:10:07 <FunctorSalad_> so it converges
20:11:08 <FunctorSalad_> just demand the n for epsilon = 1/2
20:11:21 <FunctorSalad_> can't escape from that integer from that point on
20:11:24 <kmc> danharaj, Haskell is the hipster language... we talk about how much better it is and how people don't appreciate it, but we also hope that it stays underground
20:11:56 <FunctorSalad_> just because you're a hipster language doesn't mean you aren't really onto something ;)
20:12:01 <kmc> agreed
20:12:05 <Eduard_Munteanu> Heh, you mean you hope to be one of the few who mastered it.
20:12:16 <kmc> i mean "avoid success"
20:12:23 <SubStack> just look at ruby
20:12:25 <SubStack> poor language
20:12:33 <Eduard_Munteanu> Why, really...?
20:12:45 <kmc> is ruby that bad as a language?
20:12:56 <SubStack> it's a nice language, I meant poor in terms of expressing pity
20:13:03 <kmc> oh haha
20:13:04 <danharaj> kmc: We're not snooty, we're not conformist, and I sure as hell would like it if I could talk to someone about Haskell outside of this channel :p
20:13:09 <Eduard_Munteanu> :)
20:13:19 <soupdragon> FunctorSalad, not sure what the n for epsilon = 1/2 does
20:13:25 <danharaj> For every Haskell user there is an opinion on how Haskell' should look :p
20:13:31 <nolrai__> @pl \(zorder, posision, screenObject) -> screenObject zorder posision
20:13:31 <lambdabot> (line 1, column 19):
20:13:31 <lambdabot> unexpected ","
20:13:31 <lambdabot> expecting letter or digit, operator or ")"
20:13:31 <lambdabot> ambiguous use of a non associative operator
20:13:36 <soupdragon> FunctorSalad, oh no that's regular integers not Z_p
20:13:37 <soupdragon> okay
20:13:42 <FunctorSalad_> soupdragon: apply epsilon = 1/2 in the cauchy seq definition
20:13:42 <kmc> nolrai__, @pl doesn't do tuples bigger than pairs
20:13:47 <danharaj> We're aloof and out of touch. Not hipsters!
20:13:47 <FunctorSalad_> yes, regular ones
20:13:57 <FunctorSalad_> doesn't work for Z_p since Z_p is not discrete
20:14:03 <nolrai__> kmc: oh right it cant can it.
20:14:35 <FunctorSalad_> soupdragon: the ultrametric inequality might be handy 
20:14:57 <nolrai__> "the ultrametric inequality" band name or what?
20:15:04 <kmc> haha
20:15:05 <FunctorSalad_> d(x,y) <= max(d(x,z),d(z,y))
20:15:13 <soupdragon> hm
20:15:14 <FunctorSalad_> (or equality I guess)
20:15:25 <soupdragon> d(x,y) <= max(d(x,z),d(z,y)) ?? this is an odd one
20:15:29 <FunctorSalad_> (hmm is it an equality?)
20:15:43 <FunctorSalad_> that's why it's *ultra* :D
20:15:44 <Eduard_Munteanu> Isn't that the triangle inequality?
20:15:55 <Eduard_Munteanu> Oh, no.
20:16:05 <FunctorSalad_> no, it's a surreal ultra-triangle-inequality ;)
20:16:05 <Eduard_Munteanu> Missed the 'max' part.
20:16:19 <nolrai__> Oddly I think <= is still an inequality. hmm
20:16:20 <soupdragon> are you sure it goes <= rather than =>?
20:16:21 <Eduard_Munteanu> FunctorSalad_: hm seems to be at the inf-norm
20:16:51 <FunctorSalad_> (but it's obvious if you look at it as "distance = p^-n where n = number of common digits from the right"
20:16:52 <FunctorSalad_> )
20:17:18 <soupdragon> I can't barely understand it
20:17:27 <FunctorSalad_> actually I've confused myself now
20:17:32 <FunctorSalad_> (is it obvious?)
20:17:58 <FunctorSalad_> say x and y have n common trailing digits (n chosen maximally of course)
20:18:18 <tolkad> so, with a vector, how do you get an item by index
20:18:30 <soupdragon> d(x,y) <= max(d(x,z),d(z,y)) 
20:18:31 <soupdragon> this one
20:18:33 <FunctorSalad_> I guess you do a case analysis on the common digits of x and z / of y and z now
20:18:36 <soupdragon> I am still thinking about
20:18:47 <Eduard_Munteanu> tolkad: it probably depends on the vector implementation.
20:18:54 <Eduard_Munteanu> tolkad: what are you using exactly?
20:19:08 <Eduard_Munteanu> (I found DiffArray to be really nice)
20:20:10 <Eduard_Munteanu> Unless you mean a list, in which case it's:
20:20:12 <Eduard_Munteanu> :t (!!)
20:20:13 <lambdabot> forall a. [a] -> Int -> a
20:20:17 <FunctorSalad_> soupdragon: if either x and z, or y and z, have less than n digits in common, we're done
20:20:34 <FunctorSalad_> since then d(x,z) (resp d(y,z)) is larger than the LHS
20:20:35 <nolrai__> @ty sortBy
20:20:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
20:20:37 <soupdragon> ohh I see it now
20:20:58 <FunctorSalad_> otoh, it's impossible that both x,z and y,z have more than n digits in common
20:21:04 <FunctorSalad_> (transitivity would apply otherwise)
20:21:22 <soupdragon> FunctorSalad, mm!! then e.g.  0.0000000008 and 0.0000000004 are very far apart! (p-adically)
20:21:42 <FunctorSalad_> so only the case remains where x,z and y,z both have n digits in common too
20:21:56 <FunctorSalad_> I probably made a mistake
20:21:56 <idnar> is there a full-size version of http://www.galois.com/~dons/images/hackage-circo-thumb.png anywhere?
20:22:13 <nolrai__> soupdragon: except those would be represented by '99999...something' p-adically right?
20:22:14 <FunctorSalad_> soupdragon: you consider maximal common *trailing* segments though
20:22:19 <FunctorSalad_> since they expand from right to left
20:22:43 <FunctorSalad_> so d(....011 , .... 111) = 1/4
20:23:10 <soupdragon> nolrai__: I mean something like d(1/7^20,3/7^20) being 7-adically very distant --- I really need a convention like the 101101_2 type thing for binary
20:23:22 <FunctorSalad_> (that was 2-adic)
20:23:48 <soupdragon> FunctorSalad - that makes this stuff a LOT easier to understand and more concrete
20:24:44 <FunctorSalad_> soupdragon: by "digits in common" I always meant trailing segments that must be equal, not counting common digits over the whole infinite expansion
20:24:50 <FunctorSalad_> (just clarifying)
20:24:57 <soupdragon> yes
20:25:35 <FunctorSalad_> soupdragon: yes, it made it clearer for me too, e.g. balls are just digit expansions with the last n digits wildcarded)
20:25:55 <nolrai__> wow
20:25:56 <FunctorSalad_> typical 1/8-ball:  d(....1011???)
20:26:14 <peeler> is it a bad idea to think about data types as 'having' fields, like objects?
20:26:30 <soupdragon> peeler, constructors have fields not data types themselves
20:27:07 <soupdragon> so I'd say it's a bad idea unless the data type has a single constructor
20:27:17 <peeler> that's the situation i was thinking of, single constructor
20:27:30 <soupdragon> although you can abstract a bit and have a function   getFoo :: DataType -> Foo
20:27:34 <FunctorSalad_> or you admit indirect 'have'ing
20:27:41 <nolrai__> @hoogle on
20:27:41 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
20:27:41 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
20:27:41 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
20:27:49 <soupdragon> and even if Foo has multiple types it can make sense to think of DataType has having a 'Foo' fields (in the abstract sense)
20:27:57 <soupdragon> multiple constructors*
20:28:14 <FunctorSalad_> I has cheeseburger even if I only have cats who have cheeseburgers, no? of course it'd be wicked to actually take them from them
20:28:39 * Cale shakes the magic (1/8)-ball.
20:28:43 <soupdragon> lol
20:28:44 <FunctorSalad_> :D
20:28:47 <soupdragon> 8 isn't prime
20:28:52 <soupdragon> are yuo allowed that
20:28:53 <FunctorSalad_> Cale: was a coincidence
20:29:03 <FunctorSalad_> you can make balls for any real number
20:29:17 <soupdragon> hmmmm
20:29:23 <FunctorSalad_> but it will only matter which 2-n marks your epsilon passed
20:29:28 <soupdragon> yes slightly curious thing
20:29:36 <FunctorSalad_> 2^-n
20:29:36 <soupdragon> we still use real numbers for e.g. the metrics and all sorts of things
20:29:48 <tolkad> Eduard_Munteanu: Data.Vector.Generic.Vector
20:30:04 <FunctorSalad_> (so a 0.24-ball is as good as a 0.23-ball)
20:30:09 <FunctorSalad_> in 2-adic
20:30:11 <peeler> the reason i had/have the problem before with the unimplementable class is that i'd like to have a variety of single-contructor data types that contain Gtk widgets in addition to other attributes
20:30:14 <tolkad> Eduard_Munteanu: I decided to use that so I can decide which particular one to use elsewhere
20:30:46 <peeler> i was thinking that i could have a function that returns the drawable widget, when given any of the data types than instantiate it
20:30:53 <peeler> but that led to the unimplementable problem.
20:30:58 <nolrai__> @hoogle Render
20:30:58 <lambdabot> Text.PrettyPrint.HughesPJ render :: Doc -> String
20:30:58 <lambdabot> Text.Html renderHtml :: HTML html => html -> String
20:30:59 <lambdabot> Text.XHtml.Frameset renderHtml :: HTML html => html -> String
20:31:38 <FunctorSalad_> (with a 0.25-ball, you will have to specify open or closed, which I didn't with the 1/8 ;))
20:31:52 <FunctorSalad_> there be off-by-one errors
20:31:54 <peeler> that way i wouldn't have to have different functions to get the widget from different data types; but maybe i'm thinking about the problem wrong?
20:31:57 <soupdragon> omg
20:32:00 <tolkad> how do you get an element by index from a Data.Vector.Generic.Vector?
20:32:02 <peeler> in too much of an imperative, object oriented way?
20:32:04 <FunctorSalad_> but it seems I made a closed 1/8-ball?
20:32:08 <soupdragon> are you saying that it's open and closed/
20:32:08 <soupdragon> ?
20:32:36 <FunctorSalad_> no, I was just saying you need to specify whether you mean a <-ball or a <=-ball
20:32:45 <FunctorSalad_> if the radius is some 2^-n
20:33:03 <FunctorSalad_> but for other radii they'd be both open and closed, good point =)
20:33:39 <Cale> clopen balls
20:33:45 <nolrai__> peeler: you need a type class for that.
20:33:56 <Cale> Which metric space are you discussing?
20:34:11 <Cale> Ah, 2-adics?
20:34:30 <FunctorSalad_> yes
20:34:48 <Eduard_Munteanu> tolkad: http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Generic.html#4 
20:34:51 <peeler> right, which was where i hit my first problem. I tried to have: class GenericWidget a where widget::(Gtk.WidgetClass b)=>a->b
20:34:57 <Eduard_Munteanu> tolkad: I mean mainly (!)
20:35:07 <peeler> which you notice is exactly like the example class i gave that was unimplementable involving show
20:35:15 <tolkad> Eduard_Munteanu: yeah, that said it wasn't safe
20:35:18 <FunctorSalad_> err sorry, my 1/8-ball wildcards were co-correct
20:35:28 <tolkad> Eduard_Munteanu: I don't want it to just fail for no reason
20:35:34 <FunctorSalad_> an 1/8 ball specification should be more like:    ....????????110
20:35:42 <soupdragon> I see
20:35:47 <FunctorSalad_> (closed 1/8-ball)
20:35:47 <soupdragon> that is clear
20:35:57 <Eduard_Munteanu> tolkad: I think it is safe, you might need to use 'try'.
20:36:16 <tolkad> oh
20:36:25 <tolkad> I see, I didn't realize that ! was a function
20:36:26 <Eduard_Munteanu> tolkad: or better...
20:36:41 <FunctorSalad_> soupdragon: even that one is open as well, you're right
20:36:51 <FunctorSalad_> it's the open 0.126-ball, after all
20:36:54 <Eduard_Munteanu> tolkad: nah, nevermind.
20:36:55 <nolrai__> will it break stuff if I run "cabal install cabal-install"? (I am on windows)
20:36:57 <tolkad> nevermind, thanks
20:37:18 <Eduard_Munteanu> tolkad: yes, it's a function. The '!' is the infix operator.
20:37:21 <Eduard_Munteanu> @src +
20:37:21 <lambdabot> Source not found. Wrong!  You cheating scum!
20:37:24 <Eduard_Munteanu> @src (+)
20:37:24 <lambdabot> Source not found. :(
20:37:32 <Eduard_Munteanu> @src add
20:37:32 <lambdabot> Source not found. You speak an infinite deal of nothing
20:37:35 <Veinor> @src (!)
20:37:35 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
20:37:35 <Eduard_Munteanu> Damn lambdabot 
20:38:11 <peeler> nolrai__: I don't think i can accomplish this with a type class unless the method to get a widget returns a concrete type
20:38:53 <peeler> and it looks like the design of Gtk2hs has the concrete Widget type doing nothing, with the useful widgets only having WidgetClass in common
20:39:19 <nolrai__> peeler: yeah it would have to.  You could make it two operand typeclass.
20:39:30 <nolrai__> build your own?
20:39:48 * edwardk waves hello.
20:39:58 <Eduard_Munteanu> edwardk: hi.
20:40:20 <soupdragon> 'rational integer' wtf
20:40:20 <peeler> nolrai__: what would the second operand be?
20:40:28 <nolrai__> b
20:40:42 <nolrai__> Or am I totaly wrong?
20:40:54 <edwardk> Eduard_Munteanu: you ever figure out your thesis project?
20:41:30 <nolrai__> soupdragon: I do not want to meet an irational integer.
20:41:35 <peeler> nolrai__: actually i think that may well be simple, easy, and brief. hang on while i try it out.
20:41:38 <soupdragon> I do :P
20:41:49 <Eduard_Munteanu> edwardk: nah, not yet, I think I'll have to choose until October/November.
20:42:39 <Eduard_Munteanu> edwardk: I'm getting some reading material though, like TAPL and Awodey's last edition.
20:42:42 <Eduard_Munteanu> (2010)
20:42:42 <edwardk> looks like i need to work with equivalence classes in my lexer after all.
20:42:53 <edwardk> tapl is definitely good to have under your belt
20:43:14 <nolrai__> I need to install gtk2hsC2hs on windows, help?
20:45:32 <dons> nolrai__: its in the utils package for gtk
20:45:36 <edwardk> hrmm, the best skeleton of how to handle the equivalence classes that i can think of is to take the charsets i have (which are basically intsets with a flag to indicate if they are inverted) and extract the runs from them, so i know the first character of each range that is present or absent in the set. and then union those 'silhouettes' to get something i can mash into a flat array
20:46:05 <edwardk> if i union all of the sets present in my nfa i should get a fairly compact equivalence class representation
20:46:18 <edwardk> i could get a much nicer one if i took more care though
20:46:19 <soupdragon> hm seem to be able to view MD5 hashes of peoples passwords on LTU
20:46:22 <peeler> nolrai__: cabal install gtk2hs-buildtools?
20:46:37 * hackagebot ghc-gc-tune 0.2 - Graph performance of Haskell programs with different GC flags  http://hackage.haskell.org/package/ghc-gc-tune-0.2 (DonaldStewart)
20:47:01 <edwardk> by putting multiple ranges that are always used the same way in the same class) rather than making each range a class
20:48:31 <varnie> how can one realize what typeclasses put into function's signature ? 
20:48:59 <edwardk> but then my lookup table gets more muddled. at 21 bits for the char, i'd only have 11 bits to store the equivalence class in the same Int if i wanted to pack it into a Word32 array
20:49:14 <peeler> the multi-parameter class idea unfortunately isn't working out
20:49:16 <varnie> they depend on actions it performs, but are there any tricks ?
20:49:23 <edwardk> that'd get 2048 classes which should be enough for most practical lexers though
20:50:27 <edwardk> i think i'll just use the naive classifier system for now
20:50:36 <FunctorSalad_> soupdragon: 1. run an army of supercomputers to brute force one of them 2. ??? 3. .....
20:51:24 <FunctorSalad_> (is md5 even realistically bruteforceable yet?)
20:51:48 <tolkad> oh no, I managed to generate at least 10 errors in one file by making one small change
20:52:01 <FunctorSalad_> iirc the stuff they found about it only removed a dozen bits or so? (memory is vague)
20:52:03 <edwardk> FunctorSalad_: depends on if you need a fixed collision or can just settle for any collision.
20:52:14 <edwardk> you can do birthday attacks on md5 fairly readily
20:52:27 <Eduard_Munteanu> edwardk: considering characters do have some useful bit representation perhaps a radix tree based on the bits in the char would make sense?
20:52:36 <FunctorSalad_> that sqrt'ed the space if I remember correctly
20:52:47 <Eduard_Munteanu> FunctorSalad_: kinda.
20:53:00 <edwardk> Eduard_Munteanu: hrmm. worried about search time there though.
20:53:01 <FunctorSalad_> which would seem to make it close to practical
20:53:13 <Eduard_Munteanu> They say you should use something like SHA-256 if you're serious.
20:53:23 <FunctorSalad_> hmm soupdragon would need a preimage though AIUI
20:53:37 <Eduard_Munteanu> (They don't put passwords into /etc/passwd anymore, even if they're salted (which considerably alleviates the issue though))
20:53:48 <FunctorSalad_> (she said LTU is leaking people's hashed pws)
20:54:56 <FunctorSalad_> Eduard_Munteanu: "kinda" in the sense of expected number of trials, yes. of course the hash space stays the same=)
20:55:44 <edwardk> FunctorSalad_: kind of in the sense that the number of trials required to find two that collide, but it doesn't help you collide with a known target (like someone's encrypted password)
20:55:54 <FunctorSalad_> yep
20:56:13 <FunctorSalad_> that's what I meant by 'preimage' problem
20:56:18 <FunctorSalad_> (the latter)
20:56:39 <nolrai__> where is pkg-config?
20:57:44 <FunctorSalad_> it's not a haskell-thing, you're supposed to have it already
20:57:49 <FunctorSalad_> don't know much more about it :)
20:57:54 <nolrai__> gah
20:58:02 <Eduard_Munteanu> You can't really find pkgconfig on Windows.
20:58:05 <nolrai__> why am I on windows? why?
20:58:17 <FunctorSalad_> if cabal told you about it you probably just need to install some header package
20:58:19 <FunctorSalad_> ah
20:58:26 <FunctorSalad_> nvm the last part then
20:58:27 <varnie> in unix you can find it using for example "locate" command: locate pkg-config.
20:58:49 <Eduard_Munteanu> Or 'which', considering it's already in $PATH.
20:58:58 <varnie> agree.
20:59:07 <FunctorSalad_> . o O ( or type, avoiding even the new process... j/k )
20:59:34 <FunctorSalad_> (type, the bash builtin)
20:59:50 <varnie> works fine too
21:00:04 <Eduard_Munteanu> Hm, yeah.
21:00:27 <FunctorSalad_> wasn't criticizing you, just reminding myself how I'm wasting too much time with bash
21:00:53 <FunctorSalad_> (but I should benchmark builtins vs processes some time... curious how large the diff is)
21:01:22 <Eduard_Munteanu> Process creation isn't really fast.
21:02:33 <Eduard_Munteanu> Though it's probably one system call plus some work that's done in there.
21:03:17 <FunctorSalad_> is the env copied lazily on linux?
21:03:28 <peeler> Ok, all I'm trying to do is encapsulate, for example, a scrollable textview in Gtk such that the reference to the ScrolledWindow and the TextView are in the same data constructor. But I'd like to have some 'mainWidget' function that would give me the outermost wrapper, so that I could then put it inside another layout. Is there ANY way to have this 'mainWidget' function be polymorphic?
21:03:49 <FunctorSalad_> thought it was, but read somewhere that you should be parsimonious about env variables for process creation overhead reasons
21:03:56 <peeler> I'd really prefer not to have scrollableTextViewMainWidget, scrollablOtherThingMainWidget, etc.
21:03:56 <Eduard_Munteanu> FunctorSalad_: not sure, I think it's copied depending on exec variant.
21:04:12 <peeler> this is all i've been trying to do for about an hour now.
21:05:14 <varnie> back to my question, how one should know what typeclasses include in function's declaration ? 
21:05:15 <Eduard_Munteanu> peeler: um, you could bind them to whatever you want, and it's not a big deal if you're casting from XML.
21:05:42 <Eduard_Munteanu> varnie: that depends on the properties of the values the function expects.
21:06:02 <peeler> I'd really rather write the interface in code...?
21:06:04 <Eduard_Munteanu> varnie: e.g. if it wants to do 'print' on them, add Show.
21:06:18 <varnie> i.e. it depends on actions it performs, correctly ?
21:06:33 <nolrai__> varnie: ghc is good at figureing it out.
21:06:35 <Eduard_Munteanu> peeler: IMHO, that's not a good idea, but maybe there are reasons to do it your way.
21:06:52 <Eduard_Munteanu> varnie: yes,
21:06:59 <peeler> i also thought that having this polymorphic function would be easy with a type class
21:07:43 <varnie> thanks.
21:07:47 <peeler> but that doesn't appear to be possible in a way that is safe.
21:08:28 <peeler> Eduard_Munteanu: my experience with GUIs is mostly C++ with Qt, so maybe I'm coming at this problem in a totally wrong way
21:08:52 <varnie> can we say all haskell functions are curry their essence?
21:09:02 <soupdragon> varnie, yes :D
21:09:02 <peeler> I just don't like the idea of loading the interface from XML at runtime.
21:09:11 <varnie> curried ones, i.e.
21:09:16 <Eduard_Munteanu> peeler: most GUI toolkits I know offer some way of editing the layout into a XML file and reading it in the program.
21:09:18 <FunctorSalad_> varnie: it's the default; in principle you could uncurry everything
21:09:19 <soupdragon> Haskell Curry
21:09:42 <FunctorSalad_> s/default/convention/
21:09:57 <Eduard_Munteanu> varnie: actually that depends on how you write them...
21:10:10 <Eduard_Munteanu> e.g. A -> B -> C vs. (A, B) -> C
21:10:17 <peeler> Eduard_Munteanu: Qt has a similar GUI editor and XML output format, but it's used to generate code at compile time, not runtime
21:10:18 <varnie> hmm
21:10:26 <Eduard_Munteanu> But the inference is curried by default.
21:10:43 <Eduard_Munteanu> Um, I'm not sure about that, probably depends on how you refer to the argument.
21:10:48 <p_l> there's a script-like thing though that can be integrated with applications that use Qt
21:11:02 <FunctorSalad_> it's not a bias of the inference; f x y isn't legal application if f is uncurried
21:11:04 <p_l> (Qt's Kinetic)
21:11:14 <FunctorSalad_> (f (x,y) would be it)
21:11:17 <Eduard_Munteanu> FunctorSalad_: yeah, I corrected myself.
21:11:23 <Eduard_Munteanu> f (a, b) vs f a b
21:12:33 <peeler> p_l: all I'm saying is I'm much more comfortable writing the interface in code, and gtk2hs certainly appears to have all the necessary facilities to do so, so that's the route I'd like to take
21:12:58 <FunctorSalad_> so is there really no way to ghc --make blah where blah isn't suffixed with .hs?
21:13:10 <peeler> the problem that I'm having isn't even really inherent to gtk2hs itself, it's a matter of defining this polymorphic function
21:13:11 <FunctorSalad_> workaround being a symlink
21:13:23 <Eduard_Munteanu> peeler: even so, you should be able to use some ADT to give it shorter names.
21:13:29 <Eduard_Munteanu> Try record syntax.
21:13:36 <FunctorSalad_> ln -s $(realpath blah) /tmp/blah.hs && ghc --make /tmp/blah.hs
21:14:02 <peeler> Eduard_Munteanu: shorter names are fine, but is there really no way to just have a polymorphic function that does this?
21:14:09 <Eduard_Munteanu> FunctorSalad_: did you try -x ?
21:14:29 <peeler> at some point it's easier to just do it in C++
21:15:16 * Eduard_Munteanu reads again what peeler intends to do...
21:18:06 <peeler> Eduard_Munteanu: the idea was that I could simply have: class HasMainWidget a where mainWidget::(Gtk.WidgetClass b)=>a->b. But that's an unimplementable class.
21:19:38 <FunctorSalad_> Eduard_Munteanu: hmm "ghc -x bla --make program.bla"?
21:19:42 <FunctorSalad_> doesn't work :(
21:20:14 <Eduard_Munteanu> peeler: I'm not sure you're looking for a polymorphic function...
21:20:18 <Eduard_Munteanu> Maybe type families?
21:20:45 <Eduard_Munteanu> FunctorSalad_: no, try -x hs
21:20:52 <peeler> Eduard_Munteanu: looking that up now.
21:21:14 <Eduard_Munteanu> peeler: just to be sure... you want a function that discriminates by its argument type?
21:21:17 <FunctorSalad_> Eduard_Munteanu: perfect; thanks :)
21:21:33 <Eduard_Munteanu> FunctorSalad_: gcc has something similar.
21:24:31 <peeler> Eduard_Munteanu: yes; I'd like it to work for a variety of single-constructor data types which contain what could be considered 'main widgets'
21:26:11 <Eduard_Munteanu> peeler: technically that would work with classes, but not as you imagine.
21:26:22 <peeler> now, I suppose that I could have all of the 'mainWidget'-able types be constructors of a single data type, and use pattern matching for the 'mainWidget' function, but that's ugly
21:26:31 <peeler> Eduard_Munteanu: how would it work?
21:26:39 <Eduard_Munteanu> You'd have a class Widget. And then you'd define instances for every kind of widget.
21:26:59 <peeler> Eduard_Munteanu: That's what I tried to do
21:27:29 <Eduard_Munteanu> peeler: what do you intend your class member to do actually?
21:28:08 <Eduard_Munteanu> You could have a general polymorphical function like Widget a => a -> a, that calls Widget members to do actual work.
21:28:32 <Eduard_Munteanu> But stuff like forall b. a->b makes no sense.
21:29:42 <Eduard_Munteanu> So if you can give me an example of what you intend to apply on those widgets, that would help define the problem.
21:31:08 <Jafet> forall b. (B b) => a->b isn't uncommon
21:31:21 <Jafet> ...unless you're doing it with constructors
21:31:38 <luite> is there a method for listing all unique unlabeled, connected, undirected graphs with at most n vertices, without having to check each newly generated graph for isomorphism with an older one (I know about the approach with a canonical form, but that is at least as hard as solving isomorphism)
21:31:42 <Eduard_Munteanu> Jafet: well, his B is actually Show, which isn't that helpful
21:32:07 <peeler> Eduard_Munteanu: say you have: data ScrolledText = ScrolledText TextView ScrolledWindow. That encapsulates a scrolled text view, and it can have a nice initialization function. Now I want to put this scrolled text view inside a layout, like vPaned.
21:32:07 <Jafet> I suppose not
21:32:37 <Jafet> Wait, why Show a widget?
21:32:59 <peeler> for this, I would use Gtk's panedAdd1 function
21:33:14 <Eduard_Munteanu> Jafet: dunno, I think he gave that as an example.
21:33:26 <peeler> but the argument i'm going to pass to it isn't the ScrolledText, it's the ScrolledWindow /inside/ the ScrolledText
21:35:00 <Eduard_Munteanu> peeler: okay, this is simple then, you'd have something like...
21:35:02 <peeler> so what I really want to be able to do is panedAdd1 somePaneLayout $ mainWidget someScrolledWindow
21:35:11 <ManateeLazyCat> peeler: What's wrong with gtk2hs?
21:35:31 <iLeNsTR> It's agly :)
21:35:34 <peeler> i don't think there's anything wrong with gtk2hs; that's why I'm trying to use it.
21:35:52 <Draconx|Laptop> peeler, well, the biggest problem with gtk2hs is the one that I think is biting you here: you cannot define new widgets.
21:35:57 <ManateeLazyCat> peeler: I mean any problem use gtk2hs?
21:36:12 <ManateeLazyCat> peeler: I can help you.
21:36:30 <ManateeLazyCat> dons: I have test your ghc-gc-tune, looks buggy.
21:36:32 <Draconx|Laptop> peeler, in "raw" GTK+ code, one would do this sort of thing by creating a new widget.
21:36:50 <peeler> ok...
21:36:58 <Eduard_Munteanu> peeler: initAndAdd :: ScrolledText -> IO (); initAndAdd (ScrolledText a b) = do { init a; init b; add a; add b }
21:37:01 * ManateeLazyCat pasted "ghc-gc-tune error" at http://paste2.org/get/904993
21:37:02 <ManateeLazyCat> dons: One error like above.
21:37:11 <Eduard_Munteanu> peeler: isn't that enough?
21:37:26 * ManateeLazyCat pasted "ghc-gc-tune error" at http://paste2.org/get/904994
21:37:27 <ManateeLazyCat> dons: Another error like above.
21:37:31 <Eduard_Munteanu> Perhaps I got your point wrong.
21:38:53 <peeler> Eduard_Munteanu: I was hoping to be able to use a common 'mainWidget' function with a variety of data types that present this problem, and in a wide variety of circumstances
21:39:13 <peeler> initAndAdd is fairly specific
21:39:49 <ManateeLazyCat> peeler: Can you explain your problem again? I just login here....
21:40:27 <Draconx|Laptop> peeler, though I'm not sure why a type class doesn't suffice here?  class WidgetBunch a where mainWidget :: a -> GtkWidget; instance WidgetBunch ScrolledWindow where mainWidget = ...
21:40:28 <peeler> Ok, all I'm trying to do is encapsulate, for example, a scrollable textview in Gtk such that the reference to the ScrolledWindow and the TextView are in the 
21:40:31 <Eduard_Munteanu> peeler: ah, I see. Well then, you might want to look here: http://www.haskell.org/haskellwiki/Heterogenous_collections
21:40:31 <peeler>                 same data constructor. But I'd like to have some 'mainWidget' function that would give me the outermost wrapper, so that I could then put it inside another  layout. Is there ANY way to have this 'mainWidget' function be polymorphic
21:40:38 <Eduard_Munteanu> If you think it's worth it, go ahead.
21:40:57 <Draconx|Laptop> peeler, s/ScrolledWindow/ScrolledText/ or whatever you called it.
21:41:14 <peeler> (just reiterating for ManateeLazyCat above there)
21:41:47 <Eduard_Munteanu> Yeah, or type classes, but not as originally stated (with some forall b. a->b thingy)
21:42:09 <ManateeLazyCat> peeler: toWidget ?
21:42:36 <ManateeLazyCat> peeler: toWidget will convert all widgetClass type to widget, then you can use your function wrap this widget.
21:42:38 <ManateeLazyCat> toWidget :: WidgetClass o => o -> Widget                                                                                    
21:43:05 <ManateeLazyCat> peeler: Example, you can use "let anyWidget = toWidget scrolledWindow"
21:43:14 <peeler> ManateeLazyCat: I think this may be what I was looking for
21:43:37 <peeler> this way I can make the typeclass return a concrete Widget type, right?
21:43:51 <peeler> (or rather, the mainWidget method of the typeclass)
21:44:24 <ManateeLazyCat> peeler: You can write your "mainWidget" with this "mainWidget :: WidgetClass widget => widget -> bla ..."
21:44:44 <ManateeLazyCat> peeler: Then when you call "mainWidget (toWidget anyWidget) ..."
21:45:57 <ManateeLazyCat> peeler: If you want convert widget back to original type in mainWidget, you can use function "widgetName"
21:46:23 <ManateeLazyCat> peeler: widgetName will return the type name of widget, example, when you transfer (toWidget ScrolledWindow) in mainWidget. 
21:46:43 <ManateeLazyCat> peeler: "widgetName scrolledWindowWidget" will return "Just ScrolledWindow"
21:47:21 <ManateeLazyCat> peeler: Then you can use "castToScrolledWindow scrolledWindowWidget" to ScrolledWindow.
21:47:39 <peeler> ManateeLazyCat: that usage wouldn't really help me, because what I want to call mainWidget on is not a real gtk2hs widget, but an arbitrary data type that /contains/ a widget. However, the toWidget function /does/ help me out immensely, i think.
21:47:55 <peeler> hang on a second while i try to adapt what i was working with before
21:48:35 <peeler> YES! Thank you so much!
21:49:44 <ManateeLazyCat> peeler: You can write a type-class base on any /contains/, example, "class peepler a where mainWidget :: a -> IO ()"
21:50:16 <ManateeLazyCat> peeler: Then any /contain/ can implement interface function for it's own widget.
21:50:30 <peeler> ManateeLazyCat: this is what I am doing:
21:50:38 <ManateeLazyCat> peeler: And you got uniform call interface. :)
21:50:53 <Amagineer> I wrote a little marquee generator, and now I'm trying to set up a script to use it, however it keeps coming across an EOF when I read the input file and terminating, but not after running for a bit.
21:50:54 <peeler> class GenericWidget a where genericWidget::a->Widget
21:51:04 <Amagineer> Here's the marquee generator http://xmonadneer.pastebin.com/XCFPa6tA
21:51:13 <Amagineer> And the script http://xmonadneer.pastebin.com/8m9Xjb3u
21:51:31 <peeler> instance GenericWidget ScrolledText where genericWidget s = toWidget $ scrolledWindow s
21:51:33 <mbuf> is there any RSS feeds for packages in hackage.haskell.org, so I know when a new package has been released?
21:51:36 <ManateeLazyCat> peeler: I think you should write "genericWidget:: a -> (a -> IO b) -> IO b"
21:52:13 <ManateeLazyCat> peeler: You don't need convert back focusly.
21:52:35 <ManateeLazyCat> peeler: Of course, just suggestion, i don't know what's your need exactly.
21:53:36 <ManateeLazyCat> peeler: If you want convert widget back after you do "toWidget", use "widgetName", it's much safer to convert widget back.
21:53:36 <peeler> ManateeLazyCat: the type signature I used works without errors or warnings, but you definitely seem to know more about this, so can you explain the reasoning behind your type signature?
21:53:58 * ManateeLazyCat I'm developer of gtk2hs... :)
21:53:59 <Cale> Amagineer: Well, your script obliterates the file every time
21:54:43 <peeler> ManateeLazyCat: well then you certainly do know a LOT more about this. why the intermediate argument?
21:54:57 <peeler> (a->IO b)
21:55:07 <ManateeLazyCat> peeler: Example, you write "genericWidget :: a -> Widget" it will focus you convert any WidgetClass to Widget, infact, you want apply your Widget function with genericWidget, right?
21:55:10 <Cale> Amagineer: and if your program is in the middle of reading the file when it does that, there will be a problem
21:55:43 <peeler> ManateeLazyCat: ok...
21:55:49 <Amagineer> Alright, so what can I do to update the file without causing my program to stop?
21:55:55 <Cale> Amagineer: A better idea would just be to have your program read lines from, say, standard input, each one replacing the last. Then just pipe the output of that shell loop into it.
21:56:19 <Amagineer> Ah, thanks
21:57:19 <peeler> Thanks so much for the help everyone; I need to get some sleep. Goodnight!
21:59:17 <Cale> Amagineer: Oh, I just realised that you might actually need to use a thread to do that :)
21:59:31 <Cale> Amagineer: But don't worry, it's not so hard :)
21:59:51 <Amagineer> couldn't I just replace my readLines, with getLines?
22:00:31 <Cale> Amagineer: Well, I suppose you could... see if that works :)
22:01:06 <Cale> You're currently reading the file over and over
22:01:23 <Amagineer> Yeah, I know I couldn't think of a good way to update the marquee text
22:01:25 <Cale> which won't block, because the file is there :)
22:01:48 <Amagineer> Well
22:01:49 <Cale> But when you switch to using getLine, what will happen is that if there isn't a line of text available, the program will wait
22:01:59 <Amagineer> Replacing readLine with getLine seems to have worked
22:02:08 <Cale> Okay then, cool :)
22:02:15 <Amagineer> But when I only give it one line
22:02:19 <Amagineer> It still quits :​P
22:02:22 <ManateeLazyCat> mbuf: http://hackage.haskell.org/package/feed
22:02:25 <Amagineer> Not important at all
22:02:33 <ManateeLazyCat> mbuf: http://hackage.haskell.org/package/rss  and http://hackage.haskell.org/package/HaskellNet-0.2.3
22:02:38 <Amagineer> But it does
22:02:39 <Cale> Amagineer: Er, that's interesting
22:02:48 <Cale> Amagineer: Can I have your new program?
22:02:50 <Amagineer> echo "This be some text" | ./marquee 10 1
22:02:50 <Amagineer> This be so                                            
22:02:50 <Amagineer> marquee: <stdin>: hGetLine: end of file
22:02:54 <Amagineer> Sure, one sec
22:03:31 <Amagineer> http://xmonadneer.pastebin.com/tbLYVfqD
22:03:50 <tolkad> If I have a "class A a where f :: a -> a" and a "data Num a => B a = B a" how do I male an instance of B for A?
22:03:56 <mbuf> ManateeLazyCat: thanks
22:04:14 <ManateeLazyCat> np :)
22:04:50 <tolkad> will I need to declare a new instance of B for A for every different type argument I want to use with B?
22:05:00 <mbuf> ManateeLazyCat: I was wanting to know how I can get a feed for existing packages in hackage
22:05:01 <Cale> Amagineer: Oh, that's right, because echo closes the pipe.
22:05:06 <Amagineer> Ah
22:05:52 <mbuf> ManateeLazyCat: for example if http://hackage.haskell.org/package/rss has anew package, and there was an RSS feed that I could subscribe, a reader would update the same
22:05:55 <ManateeLazyCat> mbuf: I know http://hackage.haskell.org/packages/archive/recent.rss , and i think you *track package rss" should not too hard. "
22:06:09 <mbuf> ManateeLazyCat: okay
22:06:28 <Cale> Amagineer: (echo "hello"; while true; do sleep 1; done) | ./marquee 10 1
22:06:37 <Cale> Amagineer: That'll work, though it's silly of course :)
22:07:23 <Amagineer> while true; do echo "This be some text"; done | ./marquee 10 1
22:07:25 <Amagineer> Also works
22:07:27 <Cale> yeah
22:07:41 <ManateeLazyCat> mbuf: I remember Google Reader API can track any site's difference, maybe you can use it build your "package rss" 
22:07:49 <Cale> That first one will only print one line, because the next getLine will block
22:07:51 <mbuf> ManateeLazyCat: thanks for your inputs
22:07:58 <Amagineer> Yeah
22:08:25 <ManateeLazyCat> mbuf: Example, let Google Reader APIs track "http://hackage.haskell.org/packages/bla", when package bla update, it will got difference, you can update your rss.
22:08:35 <ManateeLazyCat> mbuf: But i don't the detail, just information. :)
22:08:43 <Cale> So, your marquee animation might not work properly if you don't keep polling stuff and feeding in input somewhere. You could fix that with a thread.
22:09:03 <mbuf> ManateeLazyCat: ok
22:09:05 <Eduard_Munteanu> tolkad: for Num you can use "deriving Num" after the data declaration.
22:09:23 <Amagineer> The constant polling is what I need
22:09:31 <Amagineer> I'm going to be using this to monitor mpd
22:09:32 <Eduard_Munteanu> tolkad: that won't work for non-builtin classes.
22:09:35 <Amagineer> And plug it into dzen
22:09:41 <tolkad> Eduard_Munteanu: How do I do it for those?
22:09:44 <Amagineer> So it should change whenever the song does
22:09:49 <Amagineer> Unless there's a better way to do that
22:10:01 <edwardk> gah intmap et all really need a monadic insert, insertWith, insertLookupWithKey etc.   it is a pain in the ass to build an efficient trie out of them directly
22:10:22 <Eduard_Munteanu> tolkad: well you can write something like data MyData a = Constructor a | Foo a deriving (Show, Ord, Num)
22:10:23 <tolkad> Eduard_Munteanu: and that's not the class I want an instance of B for, that's a restriction on the type argument of B
22:10:32 <edwardk> (you can't do a trie insert using the intmap.insert without first checking for membership, which means walking up and down the tree twice
22:10:44 <o-_-o> is there anything like INT_MAX in haskell ?
22:10:50 <edwardk> maxBound
22:10:54 <Eduard_Munteanu> tolkad: I see.
22:10:59 <edwardk> > maxBound :: Int
22:11:00 <lambdabot>   9223372036854775807
22:11:06 <edwardk> > maxBound :: Char
22:11:07 <lambdabot>   '\1114111'
22:11:47 <Eduard_Munteanu> tolkad: then yeah, basically you have to write instances for each function that deals with types belonging to those classes.
22:11:58 <Eduard_Munteanu> *for each type that'
22:12:04 <Eduard_Munteanu> s used by function
22:12:33 <Cale> Amagineer: Well, I'm not sure how mpc works, and, well, it's not really necessary that this be *super* efficient, but if mpc has a mode where it continues printing info only whenever there's a change, you could make the program work under those conditions, and continue to animate :)
22:14:02 <o-_-o> why is maxBound::Float wrong ?
22:14:02 <tolkad> Eduard_Munteanu: I can't do something like instance (Num t) => A (B t) where f B = B
22:14:20 <tolkad> you know, these type variables are confusing me
22:14:33 <edwardk> > maxBound :: Float
22:14:33 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
22:14:34 <lambdabot>    arising from a use of...
22:15:00 <edwardk> sadly bounded fails to work for Float and Double, because NaN compares funny with regards to Inf and -Inf
22:15:12 <soupdragon> what's homology?
22:15:19 <soupdragon> what do you have to know to underatsnd it
22:15:19 <Eduard_Munteanu> tolkad: um, f B = B doesn't make sense.
22:15:40 <Eduard_Munteanu> tolkad: type variables only go in signatures.
22:15:47 <o-_-o> edwardk, ah...well nevermind
22:15:52 <edwardk> > (0/0 <= 1/0, 0/0 >= 1/0, 0/0 <= -1/0, 0/0 >= -1/0)
22:15:52 <lambdabot>   (False,False,False,False)
22:15:53 <Cale> Amagineer: What you could do is have a main loop which reads using getLine, and simply plonks the line that it gets into an IORef using writeIORef. Before that, though, you'd just forkIO an IO action which does the marquee scrolling in a loop, reading the value of the IORef using readIORef.
22:16:04 <o-_-o> I took maxbound::Int and did a fromIntegral on it
22:16:10 <Eduard_Munteanu> tolkad: look at the monadic return for instance, say for the Maybe monad.
22:16:13 <tolkad> Eduard_Munteanu: uh... maybe it should be f B t = B t
22:16:23 <edwardk> be careful with that, because it won't saturate a double =)
22:16:39 <edwardk> if you want Inf, use 1/0 or -1/0 for -Inf
22:16:42 <edwardk> > 1/0
22:16:43 <lambdabot>   Infinity
22:16:50 <o-_-o> edwardk, ok...I know but I want some big number that is all
22:16:53 <Eduard_Munteanu> @src Maybe
22:16:53 <lambdabot> data Maybe a = Nothing | Just a
22:16:54 <o-_-o> hmmm
22:16:54 <tolkad> ?src Maybe
22:16:54 <lambdabot> data Maybe a = Nothing | Just a
22:16:55 <edwardk> *nods*
22:17:14 <Cale> soupdragon: Well, homology has a bit of a history to it. It was originally a way to associate an Abelian group to each topological space, which in some sense measured the 'holes' in that space.
22:17:20 <o-_-o> wow
22:17:21 <Eduard_Munteanu> tolkad: class Monad a where return :: x -> m x
22:17:28 <soupdragon> oh hey I have heard about this 'Abelian group to each topological space'
22:17:31 <o-_-o> > foldl min 1/0 [2,3,4]
22:17:32 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> a)
22:17:32 <lambdabot>    arising from a use of...
22:17:37 <soupdragon> that is very reassuing
22:17:42 <o-_-o> > foldl min (1/0) [2,3,4]
22:17:42 <lambdabot>   2.0
22:17:45 <o-_-o> wow
22:17:46 <Cale> Homotopy does that in a slightly different way
22:17:47 <Eduard_Munteanu> tolkad: then the instance for Maybe is: instance Monad (Maybe a) where return x = Just x
22:17:50 <o-_-o> I am blown away
22:17:51 <soupdragon> so is it sort a genralization?
22:18:00 <edwardk> (that uses the fact that -infinity and infinity are members of Float and Double
22:18:11 <Eduard_Munteanu> tolkad: so you see that the actual function body doesn't have type variables.
22:18:14 <Cale> Homotopy gives a non-Abelian group in general, which gives more information
22:18:16 <edwardk> > foldl min (1/0) []
22:18:17 <lambdabot>   Infinity
22:18:18 <Eduard_Munteanu> Only constructors, but that's another thing.
22:18:24 <Cale> but homotopy is harder to compute than homology
22:18:33 <o-_-o> edwardk, yes...but a language that understands Infinity...is a definite wow
22:18:42 <edwardk> o-_-o: nah you can do that same trick in c
22:18:47 <soupdragon> it's like an invarient then
22:18:48 <soupdragon> ?
22:18:49 <Eduard_Munteanu> tolkad: is that more clear now?
22:18:50 <Cale> yeah
22:19:06 <Cale> It's an invariant that we can associate to each topological space
22:19:16 <edwardk> its still an approximation, it just means that you maxed out the exponent range with a zero mantissa in a floating point value
22:19:17 <Cale> But since that point, homology has been generalised
22:19:28 <edwardk> (or is it a fully saturated mantissa, i can't recall)
22:19:48 <soupdragon> I keep hearing about motives and schemes but I think it will be a few years before I can even understand what they are
22:20:27 <tolkad> Eduard_Munteanu: maybe... let's see if I can get this to stop generating errors that don't make sense
22:20:52 <Cale> One starts to realise in the formulation that homology takes that it really doesn't have a whole lot to do with topology directly, but rather can work in a more general setting. So people now apply it to groups and other sorts of algebraic objects.
22:22:20 <o-_-o> damnit I love haskell
22:22:25 <soupdragon> thank you Cale !
22:22:48 <o-_-o> I have a bunch of files which have some values in them which are numbers, I have to pick the smallest of them
22:22:58 <o-_-o> for NCPUS in 2; do grep -r Wallclock work.${NCPUS}T.*|sed -e 's/^.*://g;s/^[ ]*//g'|bc|tr "\n" ","|sed -e 's/,$/\]\n/g;s/^/foldl min (1\/0) [/g'|ghci;done
22:23:20 <o-_-o> I did this...and now I have stopped working and started amusing myself with ghci
22:23:28 * o-_-o gets back to work
22:24:10 <o-_-o> so now I can just feed in the NUM_CPUS and it will choose the best run for those many number of CPUs
22:24:18 <Cale> You get a homology theory roughly whenever you have a functor from your type of mathematical object to a category of chain complexes, which are diagrams of abelian groups or modules ... -> A_2 -> A_1 -> A_0 -> A_(-1) -> A_(-2) -> ... connected by homomorphisms where the composition of any two consecutive maps in the chain is the zero homomorphism
22:24:20 <edwardk> =)
22:24:39 <keseldude> let's go shopping
22:24:42 <tolkad> soupdragon: motives are the reason somebody does something
22:25:02 <tolkad> soupdragon: a scheme is a plan, implied to be secret
22:25:37 <Cale> Then, the nth homology group associated with your object is the kernel of the nth map in the chain quotiented out by the image of the (n+1)th
22:25:38 <soupdragon> Cale dont think I can read that last thing you said
22:25:40 <o-_-o> can I prevent ghci from printing "Loading package ghc-prim ... linking ... done."
22:25:53 <soupdragon> I mean some of it is familiar.....
22:26:17 <tolkad> soupdragon: maybe you are remembering it from a past life
22:27:15 <tolkad> whoops, sorry accidentally started trolling
22:28:07 <Cale> soupdragon: Well, that's okay, it wasn't much of a detailed explanation anyway
22:31:00 <Cale> soupdragon: Schemes and motives arise more from algebraic geometry rather than algebraic topology. I don't know a *whole* lot about them, but I could probably describe some of the idea.
22:32:12 <Cale> Well, moreso for schemes than motives
22:33:06 <Eduard_Munteanu> Cale: what do you think... is model theory worth taking a look at, in the context of Haskell, type theory and this sort of fun stuff?
22:33:30 <Cale> Eduard_Munteanu: If you enjoy type theory, you'll probably also enjoy model theory
22:33:44 <Eduard_Munteanu> Cale: I see, thanks.
22:34:10 <soupdragon> I tried to read David Markers book on Model Theory but couldn't actually do any of the prbolems at the end of chapter one >:)
22:34:16 <soupdragon> so put that aside for another time
22:34:58 <Cale> Model theory, like type theory, can be quite dry a lot of the time. Most of the proofs are by structural induction on syntax of various things.
22:35:08 <Eduard_Munteanu> soupdragon: try doing the proofs yourself and read and understand those supplied, it might help.
22:35:16 <Cale> But there are some rather fantastic results and applications.
22:35:43 <Eduard_Munteanu> Cale: yeah, I just read that Godel's theorems fit under model theory.
22:35:58 <Cale> Yeah
22:36:18 <Cale> soupdragon: Something a bit prior to talking about schemes is the idea of a sheaf.
22:36:38 <Cale> soupdragon: Do you know what topological spaces, categories, and functors are?
22:37:22 <soupdragon> Cale not really - I mean I have dipped my toes into each but I can't say anything except the definitionsa
22:38:39 <Eduard_Munteanu> I know just enough to understand monads, but I'm going to fix that when Awodey's 2010 edition gets shipped here. :)
22:39:05 <Cale> Actually, it's presheaves that I like more than sheaves. Basically, if you have any topological space, you can take its collection of open sets, and turn that into a category whose arrows are just the inclusion maps, when one open set U is a subset of another, V, you have an arrow U -> V.
22:39:40 <soupdragon> ah it's like the category of integers with arrows when you have <=
22:39:47 <soupdragon> very simple category
22:39:49 <Cale> yeah
22:40:01 <Eduard_Munteanu> @src topological space
22:40:01 <lambdabot> Source not found. stty: unknown mode: doofus
22:40:06 <Eduard_Munteanu> Dang :)
22:40:12 <Cale> In general, if you have a preorder, you can turn it into a category with at most one arrow between two objects (and roughly vice-versa)
22:40:22 <Cale> Eduard_Munteanu: Want a definition?
22:40:48 <Eduard_Munteanu> Cale: just found on Wikipedia.
22:41:07 <Eduard_Munteanu> Seems a bit similar to closure systems.
22:41:16 <Eduard_Munteanu> (if I'm translating that correctly)
22:42:18 <Cale> But anyway, back to what a presheaf is, we can take this category and consider picking a functor from it to another category -- usually people look for contravariant functors, so when U -> V, then we have an arrow F(V) -> F(U)
22:43:31 <Eduard_Munteanu> The dual category?
22:43:34 <Cale> yeah
22:44:12 <Cale> You can think of a contravariant functor C -> D as being either a normal functor C^op -> D, or a normal functor C -> D^op
22:44:57 <Eduard_Munteanu> In this case it's C -> C^op I suppose.
22:45:22 <Cale> There are a bunch of ways to get hold of interesting such functors. Particularly common from geometry are ringed spaces, which are topological spaces where we have a ring R(U) associated with each of our open sets, and whenever we have an inclusion U -> V, we have a ring homomorphism R(V) -> R(U) (and there's a little more structure than this too)
22:46:51 <soupdragon> The ring here is a bit like the fundamental group?
22:47:01 <soupdragon> except looser
22:47:03 <varnie> could someone clarify are typeclasses and type constraints the same concepts or different ones?
22:47:22 <Cale> varnie: typeclasses are a type of type constraint, I would say
22:47:28 <Eduard_Munteanu> varnie: type constraints are specified as type classes.
22:47:40 <Eduard_Munteanu> What else? Type families?
22:47:43 <Cale> varnie: There are some other sorts of constraints now, like type equality constraints
22:47:47 <dolio> GHC has others. a ~ b.
22:47:51 <varnie> in other words type type classes are more general concept than type consraints, correctly ?
22:48:07 <Cale> varnie: the other way
22:48:13 * FunctorSalad_ found dual categories slightly awkward to do in coq...
22:48:35 <FunctorSalad_> if you make it a constructor, you'll never get C^op^op = C
22:48:47 <varnie> is it absolutely wrong to say they're similar in some way ?
22:48:48 <Cale> varnie: Typeclasses are a specific way to constrain type variables to range over a collection of types which supports a given interface of functions and values.
22:48:53 <FunctorSalad_> and carrying isomorphisms around forever is a pain too
22:49:18 <Eduard_Munteanu> varnie: a type constraint is when you write something like f :: Show a => a -> a
22:49:19 <varnie> Cale, yes, i understand this
22:49:20 <Cale> varnie: It's possible to imagine other sorts of constraints we might eventually want to talk about.
22:49:37 <ddarius> Like b ~ Int
22:49:42 <FunctorSalad_> an alternative is to have the dual really contain the same objects and morphisms, and only change the operations
22:49:51 <Cale> varnie: But they're certainly the main sort of constraint you'll see in Haskell programs.
22:49:54 <Eduard_Munteanu> dolio, ddarius: what's the name for that?
22:49:57 <FunctorSalad_> then your objects/morphisms won't "know their category", though
22:50:08 <dolio> For what?
22:50:10 <ddarius> Eduard_Munteanu: (Type) Equality constraint.
22:50:15 <edwardk> Eduard_Munteanu: equality constraints
22:50:18 <dolio> Oh.
22:50:20 <Eduard_Munteanu> I see.
22:50:24 <Eduard_Munteanu> I meant the ~.
22:50:33 <FunctorSalad_> 'equals'?
22:50:45 <Cale> FunctorSalad_: Right, that's the approach usually taken in mathematics -- objects belong to categories, but not necessarily to only one category
22:50:46 <varnie> i have to wrap my head around this
22:50:48 * ddarius needs to finish the OutsideIn(X) paper.
22:51:33 <Cale> varnie: Mainly you only have to worry about other sorts of constraints when considering type system extensions or other programming languages
22:52:04 <varnie> okay, thanks
22:52:05 <Cale> varnie: GHC now also has equality constraints, which assert that two types are equal
22:52:13 <Eduard_Munteanu> varnie: a type class defines things types belonging to that type class have in common. A type constraint specifies that a type variable belongs to a certain type class. They're a restriction.
22:52:23 <Cale> and there are also constraints involved in the system for implicit parameters
22:52:34 <varnie> i am newbie in Haskell so there're many things which i have to learn
22:52:38 <Cale> :t map ?f [1,2,3]
22:52:40 <lambdabot> forall a b. (?f::a -> b, Num a) => [b]
22:52:51 <FunctorSalad_> Cale: a practical issue with that is that *every* composition will have the category as argument
22:53:02 <FunctorSalad_> (at least you can hide it from printing in coq though)
22:53:17 <Cale> FunctorSalad_: Oh, yeah :)
22:53:47 <FunctorSalad_> it gets even more 'fun' when terms mysteriously fail to unify due to distinct hidden arguments =)
22:53:48 <Cale> FunctorSalad_: We get around that problem in mathematics basically by context.
22:53:54 <FunctorSalad_> yes
22:53:57 <Eduard_Munteanu> Heh.
22:54:44 <varnie> please list several common typeclasses and type constraints ?
22:54:51 <FunctorSalad_> as the final insult, applying equalities on arguments deeper down the dependence stack is a black art (to me anyway)
22:55:13 <FunctorSalad_> but that's not coq's fault alone, I guess it's a general dep-types issue
22:55:49 <Cale> varnie: Eq (equality testing, with (==) and (/=)), Ord (order testing with (>=), compare, etc.), Num (numbers with addition and multiplication), Fractional (Num + division)...
22:56:07 <Cale> Show (things which can be converted to a String representation)
22:56:15 <Cale> Read (things which can be parsed)
22:56:20 <varnie> Eq and such are type classes, right?
22:56:23 <Cale> yes
22:56:40 <Cale> Those are examples of typeclasses along with a description of roughly what their operations are
22:56:46 <FunctorSalad_> (unlike with simple types, you can make a ctor application "Foo x y" ill-typed by just changing the value of x...)
22:56:59 <Cale> So, we have:
22:57:00 <Eduard_Munteanu> varnie: Eq is a type class, but Eq can be used as a type constraint.
22:57:06 <Cale> class Eq a where
22:57:13 <Cale>   (==) :: a -> a -> Bool
22:57:18 <Cale>   (/=) :: a -> a -> Bool
22:57:20 <varnie> it gets more complicated ;)
22:57:22 <FunctorSalad_> (if the type of y depends on x)
22:57:49 <Cale> and now suppose we write a function which checks to see if an element is in some list
22:57:54 <Cale> Using (==) to compare
22:58:10 <ClaudiusMaximus> hm, how to make sure my worker threads (forkIO...) never run on the main thread?  because the main thread needs to wake up regularly for opengl callbacks, and the workers do long-running foreign computations
22:58:19 <Cale> Its general type will be (Eq a) => a -> [a] -> Bool
22:58:33 <varnie> Cale, this is clear
22:58:55 <Cale> :t let elem x [] = False; elem x (y:ys) = if x == y then True else elem x ys in elem
22:58:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
22:59:24 <dolio> How are you modeling category theory that this is a problem specific to op?
22:59:25 <Cale> varnie: So simply by using typeclass polymorphic functions, we get other typeclass polymorphic functions
22:59:50 <Cale> The "(Eq a) =>" in the type of my function here is a constraint
22:59:58 <FunctorSalad_> dolio: uh, I tried several different encodings back then
22:59:59 <dolio> In the dependent record method, you can have more than one category whose objects are integers (for instance).
23:00:37 <Cale> It says that the type variable 'a' can only be instantiated to types which support the operations of the Eq class
23:00:42 <dolio> Which strikes me as the most natural method for encoding various mathematical/algebraic theories.
23:00:51 <varnie> type variables behavious is managed by type constraints. this is more clearly for me , at least.
23:00:57 <varnie> behaviour*
23:00:59 <Cale> varnie: right
23:01:16 <FunctorSalad_> proposition equality + some axioms vs setoids, objects/morphisms may have a unique category or not, and then there'd the option to use non-dependent homsets and have 'dom' and 'cod' as primitives instead etc 
23:01:27 <FunctorSalad_> *propositional
23:01:29 <varnie> and type constraints are described by type classes in their turn.
23:01:44 <kmc> ClaudiusMaximus, a foreign call does not block the OS thread it's made from, unless the foreign call is marked "unsafe"
23:01:44 <Cale> varnie: Without the constraints, type variables range over all types, and there are precisely no operations you can perform on a value which could have any type at all. (You can only pass them around, not inspect them in any way)
23:01:45 <Eduard_Munteanu> varnie: yeah, basically you can't apply a function to some value if it doesn't fit the type constraint.
23:02:05 <FunctorSalad_> dolio: the special thing with op is that you expect it to be an involution without a second thought
23:02:09 <Eduard_Munteanu> varnie: yes, type classes are a way to define the actual constraint.
23:02:13 <kmc> ClaudiusMaximus, i believe non-"unsafe" foreign calls are trampolined to their own thread for execution
23:02:17 <kmc> own OS thread, i mean
23:02:37 <varnie> thanks for clarifications
23:03:09 <FunctorSalad_> dolio: it's obviously all possible, but the pragmatics are a headache
23:03:10 <dolio> It is for the typical record encoding, I think.
23:03:26 <FunctorSalad_> (at least it's in principle possible with setoids)
23:03:38 <dolio> Oh, yeah, I don't know about setoids.
23:03:45 <Cale> varnie: Something which often amuses people is the type of read
23:03:48 <Cale> :t read
23:03:49 <lambdabot> forall a. (Read a) => String -> a
23:03:56 <dolio> It might require some variety of proof irrelevance in that case.
23:03:57 <FunctorSalad_> but even then things may get weird if your *object* set is a setoid too...
23:04:05 <varnie> i have read about Read already, haha;)
23:04:13 <Cale> :)
23:04:14 <FunctorSalad_> apparently you need a coherent family of cast operations on the homsets then *sigh*
23:04:22 <Eduard_Munteanu> BTW, does GHC do any automatic parallelization on normal (non-FFI) code, since kmc mentioned that?
23:04:31 <FunctorSalad_> dolio: I meant setoids as an alternative to proof irrelevance
23:04:32 <Eduard_Munteanu> I imagine it's easier than in impure languages.
23:04:45 <Cale> It's a good example of something which is often tricky using subtype polymorphism which most people are familiar with from OO languages.
23:05:22 <kmc> Eduard_Munteanu, not fully automatic
23:05:28 <kmc> Eduard_Munteanu, but you can annotate code for parallel evaluation
23:05:31 <Cale> In OO, it's easy to make functions which are polymorphic on their parameter type, but hard to make ones which are polymorphic on their result type.
23:05:37 <kmc> without worrying about threads, communication, or synchronization
23:05:44 <FunctorSalad_> dolio: but with the typical record encoding and the dual cat, how do you sane-ly enter terms?
23:05:53 <Eduard_Munteanu> kmc: ah, I know that. GCC now has something fully automatic (AFAIK) based on Graphite.
23:06:03 <Cale> (this is because objects carry their methods along with them)
23:06:03 <kmc> ok
23:06:09 <FunctorSalad_> that is, *not* like this: "compose (dual cat1) x y z g f"
23:06:09 <dolio> FunctorSalad_: I mean irrelevance of the proofs of the equivalence relation for the setoid to make the categories equal, but you could consider categories to be setoids themselves, too.
23:06:26 <FunctorSalad_> the objects may be inferrable, admittedly
23:06:43 <tolkad> if I do class A where f x = x GHC says "`f' is not a (visible) method of class `A'"
23:06:51 <ClaudiusMaximus> kmc: hm the safe/unsafe thing confuses me - which one is the one i should use if i know i won't be calling back into haskell?
23:06:53 <FunctorSalad_> but the category very likely isn't if you have both cat1 and the dual in play at the same time
23:06:54 <tolkad> what am I doing wrong?
23:06:57 <tolkad> why isn't it visible?
23:07:04 <kmc> ClaudiusMaximus, unsafe.  but it has other implications as i said
23:07:11 <FunctorSalad_> dolio: ah
23:07:11 <Cale> tolkad: class definitions are supposed to consist of type signatures for the methods of your class
23:07:23 <Cale> tolkad: also, your class lacks a type parameter
23:07:26 <kmc> tolkad, within "class" you put type signatures.  you can also put a default implementation, but you have to put the sig first
23:07:35 <FunctorSalad_> dolio: maybe agda's way of opening modules locallly could help
23:07:46 <tolkad> ok, I made it class A b where f x = x
23:07:49 <tolkad> same problem
23:08:01 <Cale> tolkad: right, for the reason I just described :)
23:08:03 <tolkad> oh
23:08:09 <Cale> class A b where f :: b -> b
23:08:10 <Cale> perhaps
23:08:25 <dolio> FunctorSalad_: Yes, I'd probably open the relevant category locally.
23:08:26 <Cale> and then you can write instances of that class
23:08:29 <FunctorSalad_> (to enter compositions as infix operations, that is)
23:08:30 <kmc> classes define interfaces, and so the types are the important thing
23:08:35 <Cale> instance A Integer where f n = n + 1
23:08:41 <ClaudiusMaximus> kmc: right.  but i can use safe anyway to avoid blocking everything?
23:08:41 <Eduard_Munteanu> Since we're here I might ask something as well...
23:08:47 <kmc> ClaudiusMaximus, i think so
23:08:52 <dolio> And if I have to open two, each composition gets a different name.
23:09:11 <kmc> ClaudiusMaximus, so says the doc for forkOS -- explaining why you *don't* need forkOS in this situation
23:09:22 <ClaudiusMaximus> kmc: thanks :)
23:09:33 <Eduard_Munteanu> Is there any use of the type classes in conjuction with the Curry-Howard isomorphism? Meaning is it useful to represent some sort of second-order statements using type operators?
23:09:41 <Cale> tolkad: If you want there to be a default implementation for some methods (possibly in terms of the others), you can stick it in the class declaration
23:09:48 <FunctorSalad_> btw maybe it's less bureaucracy to just define "contravariant functor" instead of using ^op
23:09:54 <Cale> tolkad: Like  class A b where f :: b -> b; f x = x
23:09:59 <FunctorSalad_> (^op may still be useful for some proofs though)
23:10:11 <Cale> tolkad: Then we could make Integer an instance simply by writing   instance A Integer
23:10:13 <kmc> Eduard_Munteanu, as to your second question, it definitely is; that's how systems like Coq deal with second-order things
23:10:19 <kmc> Eduard_Munteanu, but i'm not sure how type operators relate to type classes
23:10:20 <Cale> tolkad: which will just take the default implementation
23:10:25 <tolkad> ?src Maybe
23:10:26 <lambdabot> data Maybe a = Nothing | Just a
23:10:27 <dolio> Well, one of the failings of encodings I've seen in type theory is that it doesn't get the nice duality results out of category theory.
23:10:29 <augur> cale! :D
23:10:37 <Cale> augur: yeah?
23:10:39 <augur> hey :)
23:10:42 <Cale> hello
23:10:47 <augur> hows life?
23:10:51 <Cale> okay
23:10:52 <FunctorSalad_> dolio: why?
23:11:01 <kmc> Eduard_Munteanu, type classes can be thought of as sugar for implicit function parameters, plus a single global namespace into which we store candidates for the arguments given at those parameters, indexed by type
23:11:02 <Eduard_Munteanu> kmc: I see, thanks. I meant defining methods (theorems) as f :: m p -> q, and saying that m is applied to p.
23:11:06 <FunctorSalad_> ah, maybe you mean the ones that need an extra layer of indirection
23:11:15 <dolio> Because defining coproduct on its own is likely to be nicer to work with.
23:11:20 <FunctorSalad_> (the theory of a category being self-dual)
23:11:32 <kmc> Eduard_Munteanu, well, it is applied to p.  in a dependently typed language, that application is the same thing as value-level application
23:11:34 <dolio> But you can't just say "coproduct is a product in the opposite category" to prove everything about the stand-alone thing.
23:11:39 <Eduard_Munteanu> kmc: wouldn't that be a case of schemata vs actual 2nd order propositions?
23:11:43 <kmc> Eduard_Munteanu, but there aren't any type classes there
23:11:47 <kmc> Eduard_Munteanu, would it?
23:12:03 <FunctorSalad_> dolio: the ideal would be if you could effortlessly *switch* between coproduct as its own concept, and the reduction to products/dual cats
23:12:08 <Eduard_Munteanu> kmc: sure, I meant class Class m where ...
23:12:11 <dolio> Right.
23:12:13 <kmc> oh
23:12:24 <FunctorSalad_> hence I find extensionality so tempting ;)
23:12:41 <kmc> Eduard_Munteanu, but that's not legal Haskell then -- type classes aren't types, even when applied
23:12:46 <dolio> Yes.
23:12:49 <kmc> err
23:12:55 <Eduard_Munteanu> Um... yeah.
23:12:55 <kmc> scratch that
23:13:06 <Eduard_Munteanu> Or...
23:13:11 <Eduard_Munteanu> No way, that works :)
23:13:14 <kmc> it does
23:13:34 <kmc> you didn't have a (Class m) constraint
23:13:38 <kmc> i suppose you mean that f is a method of Class?
23:13:46 <Eduard_Munteanu> kmc: yes, a method.
23:13:56 <kmc> anyway, in Coq and Agda you can represent second-order statements directly
23:14:03 <dolio> Homotopy type theory seems to be better in that regard than I expected. I guess someone recently showed that function extensionality holds as a consequence of the relevant axioms.
23:14:08 <Eduard_Munteanu> kmc, and defining it by default to provide proof. Maybe that works?
23:14:18 <Eduard_Munteanu> (by default == in type class)
23:14:40 <Eduard_Munteanu> Yeah, I really need to try dependent types somewhere.
23:14:47 <Eduard_Munteanu> (Agda probably)
23:14:51 <dolio> Which I thought someone had said it wouldn't, and that extensionality was bad from that perspective.
23:15:50 <Cale> dolio: Other people are working on Voevodsky's thing now too?
23:16:03 <edwardk> @type maybe id (:)
23:16:04 <lambdabot> forall a. Maybe a -> [a] -> [a]
23:16:40 <kmc> Eduard_Munteanu, you can quantify over a value of type (Prop → Prop).  because quantification is just lambda abstraction
23:16:40 <augur> Cale: you know these zippers of huets?
23:17:25 <dolio> Cale: Seems so. At least, the guy who seemed to be involved talking on the Agda list was someone else.
23:17:56 <dolio> Peter Lumsdaine.
23:18:10 <Eduard_Munteanu> kmc: hm, yes.
23:18:54 <Eduard_Munteanu> Actually, I'm thinking... do rank-k types correspond to k-order logic? Never thought of how they look in this context.
23:19:10 <dolio> No.
23:19:28 <Cale> dolio: Neat. I wonder if there's a particularly coherent description of it available now :)
23:20:08 <Eduard_Munteanu> dolio: actually no, yeah... A rank-2 type can be used to describe negation, but that isn't a second-order formula.
23:20:09 <Cale> dolio: I heard Voevodsky talk about it in a video online, but was only able to find some sketchy notes about it that I couldn't understand.
23:20:10 <dolio> The order of the logic corresponds to the kinds you're allowed to have.
23:20:27 <Eduard_Munteanu> dolio: ah, I see.
23:20:51 <dolio> I think, at least. I don't know if people actually talk about 3rd and 4th order logic.
23:20:54 <Cale> (The talk was somehow for a super-general audience, and didn't include any real details)
23:21:13 <Eduard_Munteanu> So a second-order formula would have * -> * propositions.
23:21:21 <Cale> Eduard_Munteanu: Second order logic generally means having quantifiers that range over sets or functions.
23:21:34 <Cale> Or relations
23:21:39 <dolio> Cale: The guy I mentioned has some kind of 'weak omega categories from intensional type theory' paper (and maybe talk). I haven't looked at it, though.
23:21:58 <dolio> Plain System F is usually said to correspond to second order logic.
23:22:04 <dolio> Because you can quantify over *.
23:22:15 <Eduard_Munteanu> Cale: I always thought first order means quantification over assertions, and second order quantification over first-order formulas and so on...
23:22:22 <dolio> Sometimes it's called F_2, I believe.
23:22:24 <Cale> Eduard_Munteanu: Of course, you can build set theory as a first order logic, but the difference here is in what the models look like.
23:22:49 <dolio> Then you have F_3 which has * -> *, and F_4 which allows (* -> *) -> *...
23:23:25 <Eduard_Munteanu> I wonder why we don't let * -> * be one particular case of *
23:23:29 <varnie> what operator in Haskell acts like C language's "/=" one ? (i.e. divide and assign ) . Or it is absent in Haskell realm because it makes no sense here?
23:23:32 <Cale> For example... suppose we're trying to axiomatise the real numbers. It can be shown that any first order system you try to devise where the quantifiers range over the real numbers will have countable models.
23:23:33 <dolio> And F_(n+1) allows k -> k', where k is a valid F_n kind, and k' is a valid F_(n+1) kind.
23:23:49 <dolio> And then F_omega allows them all.
23:23:56 <Cale> and thus, no matter how hard you try, you'll never completely pin down the real numbers like that
23:24:25 <Eduard_Munteanu> varnie: you could probably define something to expand to x <- x / y
23:24:28 <Cale> But if you have second order quantification, you can add the least upper bound property, which pins the real numbers down (up to isomorphism)
23:24:53 <dolio> From that perspective, I think F_1 is the simply-typed lambda calculus.
23:25:00 <FunctorSalad_> varnie: there's no mutating assignment on the 'rock bottom' of haskell, but if you have, for example, a state monad, you could use modify (/ 5) or whatever
23:25:02 <Cale> :t modifyIORef
23:25:03 <lambdabot> Not in scope: `modifyIORef'
23:25:06 <Cale> errr...
23:25:06 <Eduard_Munteanu> Cale: I see.
23:25:14 <varnie> ahha, i see
23:25:22 <varnie> i thought kinda so.
23:25:28 <Cale> :t Data.IORef.modifyIORef
23:25:28 <lambdabot> forall a. GHC.IOBase.IORef a -> (a -> a) -> IO ()
23:25:30 <Eduard_Munteanu> It'd be neat to be able to allow formulas like Church numbers, i.e. \x -> x x
23:25:36 <Cale> ^^ that's more general than C's /=
23:25:39 <FunctorSalad_> (assignment is a 'derived' concept in state monads)
23:26:16 <FunctorSalad_> it's a bit like time doesn't pass in physical models -- you just model time explicitly
23:26:30 <Cale> It takes an IORef (which is a mutable cell that IO actions can read and affect), and a function, and applies the function to the contents of the IORef
23:26:36 <Eduard_Munteanu> Yeah, that assumed the reassignment in the context of a monad, pure code can't take that.
23:26:45 <Cale> Well, it gives the IO action for applying the function to the contents of the IORef, rather :)
23:26:46 <dolio> \x -> x x isn't a Church numeral.
23:26:48 <FunctorSalad_> likewise, in pure haskell there's no mutation but we encode change of a state explicitly
23:27:23 <dolio> It's half of an infinite loop.
23:27:44 <Eduard_Munteanu> Ouch, my mistake.
23:27:47 <Cale> varnie: So "x /= 6" in C can be written as  modifyIORef x (/6)
23:27:48 <FunctorSalad_> (alternatively, there are the IORefs that have been mentioned, but that comes with the usual drawbacks of using IO)
23:28:04 <Cale> varnie: You could also invent an infix operator for this as well :)
23:28:09 <Eduard_Munteanu> It looked an awful lot like Peano, and when I called my Peanos Churches, people said I shouldn't :)
23:28:20 <Eduard_Munteanu> and I mixed it up :)
23:29:25 <Cale> varnie: If you were doing a lot of that sort of thing, you might write  (x =: f) = modifyIORef x f   or just  (=:) = modifyIORef
23:29:31 <FunctorSalad_> (you could even define (/=) so it will look like in C, but that operator is taken in haskell for inequality)
23:29:35 <Cale> and then you could write  x =: (/6)
23:29:53 <FunctorSalad_> (not in a 'hard' sense -- it's part of the stdlib, not a keyword)
23:30:09 <Eduard_Munteanu> Now, can someone remind me why naming Succ (Succ (Zero)) a Church is bad?
23:30:09 <varnie> yes,  i see. 
23:30:15 <Cale> With an advantage of this route being that you're not restricted to a handful of arithmetic functions
23:30:21 <Cale> x := sin  would also work :)
23:30:26 <Cale> er x =: sin
23:30:28 <Cale> rather :)
23:30:45 <varnie> few more steps will guide us to C syntax
23:31:07 <varnie> but do we need it?:)
23:31:18 <Cale> But we don't often do so much mutation of state that it's necessary
23:31:38 <Cale> There's a handy StateVar library on hackage which does something similar to this, but a little more fun
23:32:09 <varnie> just a proof of flexibility of Haskell i suppose ? :)
23:32:18 <Eduard_Munteanu> varnie: you probably need it to implement some stuff, like matrix algorithms.
23:32:18 <Cale> yeah
23:33:09 <Cale> Well, for things which are really pure, but need mutation, there's ST and STRef rather than IO and IORef. The advantage of ST is that you can wrap things up so nobody can tell you're cheating.
23:33:18 <FunctorSalad> Eduard_Munteanu: church encoding is just that, an encoding (of N in LC), while peano arith is a standalone theory?
23:33:21 <FunctorSalad> that was me
23:33:35 <Cale> (and you can't really cheat too much because you're only allowed memory effects which are local to the overall computation)
23:33:55 <Eduard_Munteanu> Heh, I see.
23:34:40 <dolio> Church encoding is lame sauce anyway. You can't even prove a strong induction principle for it in typical type theories. :)
23:35:28 <FunctorSalad> the same issue as in good old predicate logic?
23:35:47 <FunctorSalad> (where first-order logic isn't strong enough to pin N down)
23:36:33 <dolio> That might be too strong a statement, really. I'm not sure you can't do it in extensional type theory.
23:36:38 <FunctorSalad> (whereas second-order lacks a complete proof system satisfying the basic sanity laws, IIRC)
23:36:53 <edwardk> dolio: one might challenge that the typical type theories are lame sauce then ;)
23:37:29 <dolio> Maybe. There are other reasons why Church encoding is lame sauce, though.
23:37:46 <dolio> Like, you can't write an efficient paramorphism.
23:37:48 <FunctorSalad> I think you can't have it all for incompleteness reasons (though the I.T. at face value is only for first order predicate logic)
23:38:03 <FunctorSalad> surely people have transcribed it to type theories though
23:38:35 <FunctorSalad> (I mean, you can't have both a theory that has only N as model, and a proof system that enumerates all valid statements)
23:38:54 <FunctorSalad> *you can't have a logic that will admit both of these, even
23:38:58 <dolio> FunctorSalad: The proposed fix I've seen is to have parametricity theorems available from within the type theory, because you can prove strong induction from parametricity.
23:39:05 <dolio> I'm not convinced that's feasible though.
23:39:07 <FunctorSalad> first-order logic fails at the first, second-order at the second
23:39:11 <FunctorSalad> all IIRC
23:39:20 <Eduard_Munteanu> I think Godel's is only valid for first-order propositions, right?
23:39:32 <varnie> one more newbie question: how to find items in list using some predicate?
23:39:36 <FunctorSalad> Eduard_Munteanu: yeah I just pondered that too
23:39:42 <Cale> varnie: filter p xs
23:39:48 <varnie> okay;)
23:39:56 <edwardk> dolio: ooh, that sounds rather practical actually
23:39:59 <Eduard_Munteanu> Which means you could very well define a higher-order logic axiom system which proves itself.
23:40:20 <Eduard_Munteanu> (proves it's not inconsistent)
23:40:20 <FunctorSalad> but you can presumably encode any "effective" proof system in first-order logic with another layer of indirection
23:40:40 <FunctorSalad> (encode its syntax and inference rules)
23:40:56 <Eduard_Munteanu> I'd assume that too, that 2nd order can express 1st order and so on.
23:41:10 <edwardk> dolio: sounds like a bit of a slippery slope though, its not far from that to including enough information that you can reason about the fact that this construct is sound because you don't export some constructor from a module and so based on the only two locations it gets constructed....
23:41:30 <FunctorSalad> I mean 1st can "interpret" higher-order (that's what ZFC does)
23:41:31 <Eduard_Munteanu> (in fact k-order contains all other orders by definition I think)
23:41:32 <etpace> I'm getting a AlexWrapper-strict-bytestring: openFile: does not exist, i'm just trying to "recompile"| a LEx.x i've modified slightly from a package on hackage, and when trying to recompie I get this, any ideas?
23:41:42 <edwardk> control flow analysis at the type theoretic level
23:41:56 <FunctorSalad> ZFC is a first-order theory encoding higher-order stuff with an extra layer of indirection
23:42:17 <edwardk> etpace: clearly you need to use my more modern, but at yet unreleased lexer, which doesn't yet help you because it is unreleased ;)
23:42:20 <Eduard_Munteanu> FunctorSalad: AFAIK you're referring to axiom schemata, but that isn't logically equivalent to higher order.
23:42:40 <Eduard_Munteanu> A schemata means a parametrized axiom.
23:42:47 <FunctorSalad> hence the fun fact that ZFC has countable models, yet it can prove the existence of uncountable sets -- different layers :)
23:43:00 <Eduard_Munteanu> I'm gonna have to look that up.
23:43:13 <edwardk> etpace: if i had to guess it might not be able to find its data dir or it might have trouble finding the .x file
23:43:17 <dolio> edwardk: At the very least, it sounds dangerously close to your theory being able to prove too much about its own syntax, and being inconsistent.
23:43:25 <FunctorSalad> Eduard_Munteanu: I wasn't talking about these I think
23:43:30 <dolio> But it may walk the line.
23:43:40 <edwardk> dolio: yep
23:43:41 <Eduard_Munteanu> Presburger arithmetic can prove itself.
23:43:49 <FunctorSalad> (but by "sane" earlier I meant that the axiom schema is recursively enumerable or so)
23:43:57 <Eduard_Munteanu> But it can only define multiplication up to some value.
23:44:22 <edwardk> Eduard_Munteanu: yeah. but nobody wants to work in presburger arithmetic in their compiler ;)
23:44:35 <FunctorSalad> (otherwise, just take all true arithmetic sentences as your logic, incompleteness theorem "refuted" :D)
23:44:52 <Eduard_Munteanu> Heh, yeah.
23:45:44 <Eduard_Munteanu> Actually Presburger self-consistency is logically equivalent to using normal arithmetic but checking exhaustively up to a certain limit, I suppose.
23:46:34 <dolio> You can do better than Presburger arithmetic, I think.
23:46:50 <dolio> Dan Willard has stuff in that arena.
23:47:31 <FunctorSalad> <Eduard_Munteanu> Which means you could very well define a higher-order logic axiom system which proves itself.
23:47:31 <FunctorSalad> <Eduard_Munteanu> (proves it's not inconsistent) <-- you can do that in first order too, but I wouldn't trust the axiom ;)
23:48:04 <FunctorSalad> (extra axioms will never make a theory consistent if it wasn't before... you'd just add a lying axiom)
23:48:14 <Eduard_Munteanu> Yeah.
23:48:55 <Eduard_Munteanu> Basically Godel refers to 1st order systems with a certain complexity in terms of axioms.
23:49:22 <varnie> i am reading "Learn you a Haskell for a great good!" tutorial as a start, what tutorials/books would you advice me give a try next?
23:49:26 <Eduard_Munteanu> But you can have smaller systems which are consistent.
23:49:34 <Eduard_Munteanu> (though not complete)
23:49:43 <FunctorSalad> I know, but it seems like it could be transcribed to other logics (which we can't prove without nailing the concept of 'a logic' down)
23:50:38 <Eduard_Munteanu> FunctorSalad: that's simple, you have a handful of basic (meta-) axioms or rules. I don't think we dispute transitivity or stuff like that.
23:50:42 <FunctorSalad> but surely you won't ever have a logic that spits out all the true theorems of arithmetic, even if you paint it a bit different than first-order-logic so that Goedel's IT doesn't strictly apply?
23:51:24 <gwern> FunctorSalad: of course you can have such a logic - it spits out every theorem
23:51:40 <Eduard_Munteanu> gwern: forall b. a->b ?
23:51:47 <FunctorSalad> ah of course, "exactly the true ones" :p
23:51:55 <gwern> FunctorSalad: oh well, you didn't say that!
23:52:18 <Eduard_Munteanu> I mean by principle of explosion you can prove anything.
23:52:39 <ski> varnie : maybe "Haskell: The Craft of Functional Programming" ?
23:52:50 <Eduard_Munteanu> FunctorSalad: would that be a higher-order logic system? :)
23:52:52 <gwern> Eduard_Munteanu: oh, I don't usually see it formulated like that, but yes, it's easy to just take a contradiction as an axiom and then FunctorSalad's desire is fulfilled
23:52:54 <ski> or maybe "Real World Haskell" ?
23:53:06 <FunctorSalad> and "recursively enumerable results", though we can't make that rigorous because we don't have a space of all possible logics
23:53:14 <varnie> ski, thank you.
23:53:18 <Eduard_Munteanu> FunctorSalad: you could define it as an infinite-order system, where for all true statement t -> t :)
23:53:29 <FunctorSalad> (the old point that you can't pass to the formal from the informal by formal means)
23:53:59 <ski> varnie : there's a list at <http://www.haskell.org/haskellwiki/Books_and_tutorials>
23:54:17 <FunctorSalad> Eduard_Munteanu: higher-order logic doesn't help you if you don't have a proof system
23:54:32 <FunctorSalad> (to actually enumerate all valid sentences)
23:54:35 <solrize> :t if'
23:54:36 <lambdabot> Not in scope: `if''
23:55:22 <FunctorSalad> gwern: the revised desire? no
23:55:51 <solrize> theorems are provable, by definition. i think you meant all the true statements including the non-theorems ;)
23:57:02 <FunctorSalad> solrize: I already admitted that you can't possibly define the terms rigorously at the outermost frame
23:57:06 <Eduard_Munteanu> solrize: that's not so obvious in practice.
23:57:25 <FunctorSalad> a rigorous definition would again imply already having a background logic
23:57:27 <ski> i saw a funny style of defining a relation by defining a new inference system, and then saying that the relation between arguments hold iff a statement is derivable in the inference system
23:57:33 <FunctorSalad> so it wouldn't be the outermost frame
23:57:34 <FunctorSalad> ;)
23:57:42 <Eduard_Munteanu> Suppose you have a theorem concerning real numbers, which is true. You can see its effects, but can't check it by exhaustion.
23:58:14 <soupdragon> ski - isn't that the normal practice in e.g. type theory?
23:58:18 <FunctorSalad> solrize: AFAIK, the traditional definition of having a complete proof procedure is one such that all valid sentences are provable
23:58:21 <Eduard_Munteanu> Of course, we know that first order formulas are provable.
23:58:28 <FunctorSalad> where valid means 'true in every model'...
23:58:40 <solrize> right those are called "theorems"
23:58:46 <FunctorSalad> like I said, at some point it inevitably gets fuzzy
23:59:42 <ski> soupdragon : the main point was to define a certain relation (in what effectively became a meta-system) -- but they did that by inventing a new object system with inference rules ; i just don't recall seeing that style
23:59:52 <FunctorSalad> solrize: theorems are the provable sentences
