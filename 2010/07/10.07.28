00:00:10 <noteed> oups, not meant to write hear, sorry
00:09:44 <p00ya> lispy: did he just disable input, or output too?
00:11:44 <Axman6> @bf ., a
00:11:45 <lambdabot>  Done.
00:11:52 <Axman6> @bf ,. a
00:11:52 <lambdabot>  Done.
00:11:56 <Axman6> hmm
00:14:00 <ezyang> Huh?? 
00:15:36 <ezyang> Oh, *phew*, just the monomorphism restriction 
00:18:42 <ezyang> Huh. So let is /not/ just syntax sugar for a lambda+application 
00:18:55 <ezyang> because lambda+application forces the argument to be monomorphic. Maybe? 
00:18:59 <ezyang> actually, that seems bogus 
00:19:20 <noteed> no ezyang, you're right
00:19:43 <ezyang> oh, wow, it's true. 
00:21:18 <noteed> > let i = \x -> x in (i "hello", i 5)
00:21:19 <lambdabot>   ("hello",5)
00:21:29 <noteed> > let a f = (f "hello", f 5) in a (\ x -> x)
00:21:30 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
00:21:30 <lambdabot>    arising from the literal ...
00:22:14 <noteed> ezyang: ^^^ but you can achieve it with a type signature
00:23:00 <ezyang> yeah, I know 
00:23:08 <ezyang> wait, even in function application? 
00:23:13 <ezyang> oh, yeah, I guess that's true. 
00:25:33 <zachk2> A program without a loop and a structured variable isn't worth writing. --Alan J. Perlis http://web.archive.org/web/19990117034445/http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html
00:25:53 <manjunaths> argh...I am trying to translate some C++ code to haskell
00:25:59 <zachk2> dont do that 
00:26:00 <manjunaths> it is hell
00:26:04 <_Ray_> there's the problem :D
00:26:08 <zachk2> i tired it with java once 
00:26:08 <ezyang> iiuc, the monomorphism restriction will always pick the same default? 
00:26:11 <zachk2> tried it 
00:26:16 <manjunaths> ok
00:26:21 <manjunaths> what happened ?
00:26:37 <noteed> > let a :: (forall a . a -> a) -> (String,Int) = \f -> (f "hello", f 5) in a (\ x -> x)
00:26:38 <lambdabot>   ("hello",5)
00:26:40 <zachk2> i think i dropped the course and got more interested in math instead of cs/java 
00:26:44 <noteed> ezyang: ^^^
00:26:53 <manjunaths> zachk2, haha
00:27:19 <zachk2> funny && True 
00:27:28 <manjunaths> the C++ code is doing more than meets the eye somewhere and I can't figure it out
00:27:51 <zachk2> prolly some side effects buried in some method 
00:27:57 <manjunaths> I have translated the code down to every variable and also the test data generated by the C++ code works in haskell
00:28:00 <noteed> ezyang: but it uses -XRankNTypes to make it possible for f to be polymorphic
00:28:02 <manjunaths> but the program does not
00:28:05 <manjunaths> gack
00:28:14 <PetRat_> > Left "boo" `mplus` Right 3
00:28:14 <manjunaths> yes damn side effects
00:28:14 <lambdabot>   Right 3
00:28:29 <zachk2> wait i did the other thing
00:28:38 <zachk2> i wrote my assignment in haskell then translated it to java 
00:28:45 <manjunaths> ewww......
00:28:47 <zachk2> it worked in both 
00:28:52 <zachk2> but was painful in both 
00:28:59 <PetRat_> > mzero `mplus` Right 3
00:29:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:29:00 <lambdabot>    `Control.Monad.Error.Cla...
00:29:04 <manjunaths> zachk2, why painful in haskell ?
00:29:19 <zachk2> cause it was a silly cs assignment 
00:29:28 <PetRat_> mzero `mplus` Right 3 :: Either String Int
00:29:32 <manjunaths> zachk2, ah...o
00:29:34 <manjunaths> ok
00:29:39 <PetRat_> > mzero `mplus` Right 3 :: Either String Int
00:29:40 <lambdabot>   Right 3
00:29:54 <manjunaths> I am off to lunch, I think I need to learn the algorithm and rewrite it in haskell
00:30:00 <zachk2> i look at c like languages now and it almost feels like im reading assembler 
00:30:11 <zachk2> yes draw pictures and take notes 
00:30:23 <zachk2> good luck, cause you will need it ;) 
00:30:24 <manjunaths> zachk2, it is not so bad, but I am now understanding how dangerous side effects are
00:30:38 <manjunaths> zachk2, thanks
00:30:48 <PetRat_> Question: I'm reading Douglas Auclair's paper on MonadPlus and he says Left is usually considered a computational failure. I thought  mplus <failure> <something> was supposed to be <failure>
00:31:00 <PetRat_> > Left "boo" `mplus` Right 3
00:31:01 <lambdabot>   Right 3
00:31:08 <manjunaths> zachk2, how the side effects make the programs mysterious
00:31:33 <zachk2> yeap and 99% of programmers have no idea why there are so many bugs out there 
00:32:24 <Peaker> PetRat_, mplus is how you "Catch" failures, and indeed mplus between a Left and a Right will yield the Right
00:33:37 <noteed> Itkovian: what was the question you answered with 'parsec'?
00:33:39 <PetRat_> Peaker: in what sense "catch"?
00:34:11 <PetRat_> By the way I went back to the article and realized that the idea is for mplus to choose a *success* when presented with a failure and a sucess.
00:34:17 <PetRat_> > Nothing `mplus` Nothing
00:34:19 <lambdabot>   Nothing
00:34:24 <Peaker> PetRat_, x `mplus` y   sort of means "Take the successes available in x and y, allowing a bias towards x", so in the case of Either or Maybe, if "x" is success, it is taken. If it is error, y is taken
00:35:13 <PetRat_> How is mplus related to >>= ?
00:36:11 <Peaker> PetRat_, I don't recall any rules of that sort. I do know  mzero >>= anything = mzero
00:36:52 <Peaker> PetRat_, http://en.wikibooks.org/wiki/Haskell/MonadPlus#The_MonadPlus_laws
00:37:12 <PetRat_> Peaker: I guess I'm trying to wrap my head around Auclair's logic programming example, in a list monad.
00:37:42 <Peaker> PetRat_, don't know what that is
00:37:53 <opqdonut> the list monad represents multiple successes
00:37:56 <opqdonut> mplus is just (++)
00:38:38 <Twey> Peaker: Really?  I don't think mplus is necessarily left-biased.
00:38:41 <PetRat_> I'm not clear where the "mplus-ing" happens. I see do-notation.
00:39:01 <PetRat_> his article is here: http://www.haskell.org/sitewiki/images/6/6a/TMR-Issue11.pdf
00:39:22 <Peaker> Twey, I said "sort of" because it's not a law or anything, it's just a common observation
00:39:33 <Peaker> (If you're going to look at Either/Maybe instances anyway )
00:39:34 <Twey> Ah, okay.
00:39:35 <Peaker> :)
00:39:56 <Twey> There are special-purpose instances for both lying around in the standard libraries somewhere, I believe, with different biases.
00:44:30 <PetRat_> I coded up some examples here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28320#a28320   This is without do sugar. I get intuitively how each works, but what I'm not clear is where the list definition of mplus comes into play.
00:49:13 <ezyang> Huh, NoMonoPatBinds. Lol. 
00:50:12 <PetRat_> Where is the MonadPlus instance of [] defined?
00:51:28 <Peaker> PetRat_, >>= \_ -> mzero >> ...  will make the entire computation mzero in your example
00:51:42 <p00ya> PetRat_: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Monad.html#mplus
00:51:48 <Peaker> PetRat_, does example3 type-check?
00:52:58 <PetRat_> Peaker: error in example3, meant >>= not >>
00:53:35 <PetRat_> Peaker: I think my point of confusion is that the list monad behaves like that anyway. 
00:53:57 <PetRat_> Peaker: I wonder if the reason to use the MonadPlus instance is to use the guard function.
00:53:57 <Peaker> PetRat_, well, mzero=[], and []>>=_ = [].  And also, anything>>mzero = mzero
00:54:37 <Peaker> PetRat_, it's when you want to combine successful results or "fail" something (e.g: via guard)
00:56:01 <PetRat_> Peaker: what I believe is true is that the list monad, not the MonadPlus instance, already has that capability. However, it occurs to me that using the MonadPlus instance allows the use of 'guard' instead of lengthier code.
00:56:43 <Peaker> PetRat_, Well, if you restrict yourself to a specific type such a list, of course you can do anything a type-class can (e.g: MonadPlus). The point of type-classes is to allow your code to generalize to more types
00:57:03 <Peaker> PetRat_, MonadPlus, Monad, and any other class will not give you more expressive power when dealing with just lists
00:57:12 <Peaker> PetRat_, you could use concatMap instead of (>>=) when dealing with lists, too
00:57:24 <PetRat_> or list comprehensions...
00:57:25 <Peaker> So lists already have the capabilities in monad, too, of course :)
00:57:56 <tolkad> I'm pattern matching for an empty vector using Vector.Unboxed.null but I am getting the error message: Qualified variable in pattern
00:58:00 <tolkad> what does that mean?
00:58:04 <Peaker> PetRat_, List comprehensions are just combinations of (>>=), let and guard, which is concatMap, let and (if p then [()] else [])
00:58:22 <Peaker> tolkad, "null" is not a pattern, it is a function
00:58:37 <Peaker> tolkad, You can use a guard expression instead of a pattern when you want to apply functions
00:58:38 <PetRat_> Peaker: okay, but Auclair introduces his paper by saying how great MonadPlus is, and then it looks like nothing new happens except the use of guard. So I thought I was missing something.
00:58:41 <tolkad> oh, I need to use empty
00:58:59 <tolkad> no, that didn't work either...
00:59:09 <PetRat_> I wonder if Auclair's logic programming code could use an instance other than []
00:59:13 <tolkad> same problem... but empty isn't a function
00:59:30 <tolkad> empty is an empty vector. why can't I pattern match for it?
01:00:06 <tolkad> is it because I qualified imported Vector.Unboxed as V?
01:00:28 <tolkad> that is what the error message is implying, but I don't see why GHC would care
01:02:44 <tolkad> I will use a guard, but I am curious what the error message meant
01:02:55 <Peaker> PetRat_, Maybe the idea is that his code is generalized from lists to everything else?
01:04:05 <Peaker> tolkad, "Pattern-matching" is useful on *concrete* data structures. On abstract data structures, you shouldn't use pattern-matching, as it would expose their internal structure/implementation details.  Maybe "null" can be represented by multiple patterns in the implementation? What you want is the semantic "null" check rather than structural equivalenace check
01:04:48 <Peaker> tolkad, When you use "x" as a pattern, then it will bind into the name "x", shadowing any "x" in scope. If you imported "null" unqualified, and then pattern-matched into "null" you'd simply shadow "null" and get a new variable "null" of vector type that matches anything
01:05:00 <PetRat_> Peaker: he doesn't generalize it in the paper, but I am satisfied I understand what's going on there. thanks..
01:05:06 <Peaker> tolkad, When you try to pattern match into "Blah.null" then you get an error, you cannot bind into a qualified name
01:05:41 <tolkad> Peaker: ah, I understand
01:06:04 <Peaker> tolkad, does Vector expose its data constructors?
01:07:03 <tolkad> Peaker: Vector uses data families, which I do not understand
01:08:49 <tolkad> I will learn them eventually, but I am still practicing with basic haskell
01:09:17 <Peaker> tolkad, ok
01:10:49 <tolkad> I find it strange there is no builtin function along the lines of ioMap :: (a -> IO ()) -> [a] -> IO
01:11:08 <Peaker> tolkad, -> IO ... what?
01:11:13 <tolkad> I find it strange there is no builtin function along the lines of ioMap :: (a -> IO ()) -> [a] -> IO ()
01:11:17 <tolkad> whoops :P
01:11:25 <Peaker> @type mapM_
01:11:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
01:11:44 <tolkad> > mapM_ print [1..10]
01:11:46 <lambdabot>   <IO ()>
01:11:48 <tolkad> ah
01:11:52 <tolkad> I see, thank you
01:11:52 <Peaker> @hoogle (a -> IO ()) -> [a] -> IO ()
01:11:53 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
01:11:53 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
01:11:54 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
01:11:58 <Peaker> Automatic answer!
01:12:16 <tolkad> that is nifty
01:12:42 <Peaker> Neil Mitchell is awesome :)
01:13:20 <tolkad> it's too bad lists aren't implemented as a class, all these vector implementations have to define a new set of list-like functions
01:13:33 <Peaker> tolkad, I agree. There's a list class in the "List" package
01:15:12 <solrize> should that stuff be done with type families instead of classes?  i was wondering about that earlier because of the hassle of switching between strings and bytestrings
01:15:34 <tolkad> solrize: are type families part of standard haskell?
01:15:50 <solrize> not yet :)
01:16:00 <Peaker> solrize, I see "type/data families" as a nicer way of doing multi-param type-classes and fundeps
01:16:17 <Peaker> if it can be done with a single-param type-class, probably no need for type families
01:18:46 <solrize> well strings would use something like an associated type, i.e. string elements are chars, bytestring elements are word8 for regular bytestrings or char8 for bytestring.char8, there's also Text which i guess uses chars, etc
01:19:33 <tolkad> solrize: word8? do you mean Int8?
01:21:14 <tolkad> oh, I see, Word is haskell's version of uint
01:22:07 <cncl> are mutually recursive modules typically a discouraged style?
01:22:10 <quicksilver> some aspects of List already area  class.
01:22:24 <quicksilver> mapM_ and mapM are in Foldable and Traversable respectively.
01:22:55 <quicksilver> those are, IMO, better classes than 'ListLike'
01:25:01 <tolkad> How can mapM_ be in Foldable? it's type signature seems to be Monad m => (a -> m b) -> [a] -> m ()
01:25:24 <tolkad> or is this a different implementation of mapM_?
01:25:42 <kmc> cncl, yes
01:25:45 <kmc> tolkad, it is
01:25:49 <kmc> a different one
01:26:24 <kmc> yeah, designing good type classes for generic data structures is actually difficult
01:26:42 <kmc> a big ListLike class with every list operation is likely to be suboptimal
01:27:00 <kmc> Num has given us various headaches and is widely regarded as a language wart
01:27:14 <kmc> and that's for the supposedly simple idea of numbers
01:27:38 <tolkad> kmc: seperating them into classes like Foldable, and Traversable would be better
01:27:39 <quicksilver> tolkad: a strict generalisation.
01:27:49 <Twey> Why is it …M_ when it doesn't involve a monad?  :þ
01:27:58 <quicksilver> it does involve a monad.
01:28:03 <quicksilver> it doesn't involve lists.
01:28:24 <quicksilver> @type Data.Foldable.mapM_
01:28:25 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
01:28:27 <kmc> hmm? Data.Foldable.MapM_ involves monads
01:28:28 <tolkad> is there some way to import something hiding everything?
01:28:35 <Twey> Oh, okay.
01:28:35 <kmc> tolkad, import qualified?
01:28:38 <tolkad> without explicitly listing everything to hide?
01:28:41 <kmc> or
01:28:43 <kmc> import Foo()
01:28:45 <tolkad> kmc: something you have already imported
01:28:51 <tolkad> kmc: I'm thinking of prelude
01:28:52 <kmc> in general you can do import Foo(bar, baz) to get only bar and baz
01:29:01 <kmc> yeah it's common to see «import Prelude()»
01:29:02 <quicksilver> you can generalise it in that axis too, from Monad to Applicative
01:29:07 <kmc> well not that common ;P
01:29:14 <tolkad> kmc: oh, that unimports it?
01:29:18 <tolkad> kmc: I see.
01:29:39 <quicksilver> it's then called traverse_
01:29:42 <kmc> tolkad, you import with an explicit list of things to import, and that list is empty
01:29:45 <quicksilver> @type Data.Foldable.traverse_
01:29:46 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
01:29:58 <kmc> if you have an explicit import of Prelude, it drops the implicit one
01:30:04 <kmc> (that's a Prelude-specific rule)
01:30:38 <kmc> cncl, mutually recursive modules are not supported consistently by all compilers
01:30:43 <kmc> in GHC they are a pain in the ass
01:31:27 <tolkad> I am really starting to like haskell. In Java there is no way to get rid of implicitly imported packages
01:32:37 <tolkad> kmc: GHC requires you to create the haskell version of a C .h file?
01:32:57 <cncl> kmc yeah i can tell
01:38:14 <Peaker> Ito store a very large trie of all substrings of /usr/share/dict/words using Map/IntMap explodes the heap
01:38:22 <Peaker> what would be a good way to Trie on [Char] ?
01:39:11 <Peaker> I'm thinking of dropping into C :-(
01:40:30 <Peaker> hmm.. actually the space it takes adds up.. it doesn't take that much more than I'd expect
01:43:01 <tolkad> hmm, I have never used a trie before, although I do remember concieving of the idea before hearing about it
01:43:33 <kmc> tolkad, for mutual recursive modules? yes
01:43:39 <tolkad> anyway, I'm curious how you know what the optimal key length is at each tier? or is a byte just conventional?
01:43:59 <kmc> tolkad, in a patricia tree each layer eats as much of the string as is unambiguous
01:44:54 <tolkad> kmc: ceiling'd to a multiple of 8 bits I presume :P
01:46:13 <kmc> not sure
01:46:22 <kmc> what about the tries used by IntSet/Intmap
01:46:46 <ManateeLazyCat> I'm build "runtime type-checker", i want use "type Interface = Any type" hide type detail, so my question is, do you have any type that CAN'T describe by keyword 'type'?
01:47:13 <copumpkin> have you looked at Dynamic?
01:47:21 <ManateeLazyCat> copumpkin: Dynamic have limit.
01:47:47 <ManateeLazyCat> copumpkin: I'm build "dynamic-linking plugs library", i need "runtime type-checker" for any type that compiler support.
01:47:59 <ManateeLazyCat> copumpkin: Dynamic have limit, can't explain any type.
01:49:22 <ManateeLazyCat> copumpkin: My idea is I have two module Test and API, in module Test i have "_ = Plugin.testSymbol :: API.Interface", in mdou API i have "type API = AnyType"
01:49:22 <ManateeLazyCat>  
01:49:58 <ManateeLazyCat> copumpkin: Before i dynamic-liking any symbol in memory, i can build temporary module that contain "_ = Plugin.testSymbol :: API.Interface".
01:50:32 <ManateeLazyCat> copumpkin: If i can compile this temporary module, then type match, i can use unsafeCoerce safety to dynamic link symbol.
01:50:55 * hackagebot haskore-realtime 0.1.1 - Routines for realtime playback of Haskore songs  http://hackage.haskell.org/package/haskore-realtime-0.1.1 (HenningThielemann)
01:50:59 <tolkad> ManateeLazyCat: "Dynamic have limit" is grammatically incorrect, you could say "Using Dynamic has limits", or "Dynamic is limited"
01:51:15 <ManateeLazyCat> copumpkin: So i want use "type Interface = AnyType" in module API to hide any type detail.
01:51:44 <ManateeLazyCat> tolkad: Yes, Using Dynamic is big burden for my library user.
01:51:46 <copumpkin> ManateeLazyCat: you probably want Any from GHC.Prim, but that's what Dynamic is using behind the scenes too
01:52:02 <copumpkin> it's the only type you can safely unsafeCoerce to and from
01:53:29 <Eduard_Munteanu> Hi.
01:53:33 <ManateeLazyCat> copumpkin: I'm bulid plugins library, i don't want user write Dynamic code to wrap theirs type, it's burden, I want user just pass "symbol" and "type", then my library do rest thing, include "runtime type-check", "dynamic-link symbol".....
01:55:50 <tolkad> hmm, unsafeCoerce is very interesting
01:55:51 <ManateeLazyCat> copumpkin: My point is : "approaches to dynamics based on pattern matching or equality testing on type representations is that it can only approximate true type unification" 
01:56:08 <copumpkin> I don't really see how you can avoid it though
01:56:20 <tolkad> I can use it to learn how GHC stores things at runtime =D
01:56:21 <copumpkin> you're going to have to come up with a type representation unless you actually want to be unsafe
01:56:32 <copumpkin> tolkad: check out unpackClosure# too
01:56:57 * hackagebot haskore-supercollider 0.1.2 - Haskore back-end for SuperCollider  http://hackage.haskell.org/package/haskore-supercollider-0.1.2 (HenningThielemann)
01:57:01 <Eduard_Munteanu> Or check out GHC's source code.
01:57:10 * ManateeLazyCat pasted "Manatee.Plugins" at http://paste2.org/get/930361
01:57:13 <ManateeLazyCat> tolkad: Above is my plugins library, now i need add "runtime type-checker" for dynamic-link safety.
01:58:33 <ManateeLazyCat> copumpkin: My approach is push "type-check" to compiler, let compiler check type in runtime.
01:59:00 <copumpkin> but you're just pushing a representation of the type into the runtime, to allow the compiler to try, right?
01:59:20 <Eduard_Munteanu> Hm, I've been reading NICTA's article on seL4, the formally proven OS kernel. I'm a bit disappointed with the huge amount of effort, those guys must be on crack.
01:59:31 <ManateeLazyCat> copumpkin: Yes, i give compiler import information, let compiler try.
01:59:50 <Eduard_Munteanu> And I'm still not sure that proof provides hard guarantees.
01:59:57 <ManateeLazyCat> copumpkin: If compiler can compile temporary module, then type-check, i can use unsafeCoerce safety.
02:00:50 <copumpkin> yeah, sure
02:00:52 * ManateeLazyCat pasted "Temporary module" at http://paste2.org/get/930363
02:00:54 <ManateeLazyCat> copumpkin: Like above temporary module.
02:01:00 <copumpkin> but then you're linking to ghc api which is enormous
02:01:06 <Eduard_Munteanu> Transforming 5k some lines of code into 200k with a proof included really makes me wonder if there isn't a lot of room for making things _appear_ safe.
02:01:06 <copumpkin> I guess not such a big issue now that we have dynamic linking
02:02:31 <Eduard_Munteanu> Especially that they model C's quirkiness. That proof might not represent the end result at all.
02:03:19 <ManateeLazyCat> copumpkin: But let user use Dynamic is burden anyway....
02:04:10 <ManateeLazyCat> copumpkin: I have test, i need more 50% time for type-check in runtime.
02:04:24 <Eduard_Munteanu> Now if only the program could prove itself... Ah well.
02:04:46 <ManateeLazyCat> copumpkin: Or you have better idea? except use Dynamic....
02:05:20 <copumpkin> ManateeLazyCat: not really :/
02:05:46 <ManateeLazyCat> copumpkin: Ok, thanks for your suggestion, looks my idea is best solution . :)
02:06:50 <ManateeLazyCat> copumpkin: BTW, you can try my plugins library (http://paste2.org/get/930361), i haven't finish "runtime type-checker", but it works well.
02:06:55 <_Cactus_> hi
02:07:08 <_Cactus_> is there some tutorial for using the Haskell LLVM bindings?
02:07:28 * ManateeLazyCat pasted "test plugins library" at http://paste2.org/get/930372
02:07:44 <ManateeLazyCat> copumpkin: You can use above code for test.
02:07:55 * ManateeLazyCat Dinner, brb
02:07:56 <_Cactus_> i'm stumped by the 'alloca' instruction's type
02:10:49 <ManateeLazyCat> copumpkin: Last question : Have any type can't describe by keyword 'type' ? 
02:13:47 <ezyang> wow, that post took a long time 
02:14:04 <ezyang> On the plus side, I now know more about monomorphism and implicit parameters than I ever did before! 
02:17:11 <gour> i'm looking what would be adequate encoding for converting binary data (*.png & *.jpg images) into text to be inserted as BLOB into sqlite3 db? dataenc package support quite a few encodings...popular for the task is base64 with a big overhead...yEnc is another option...any suggestion?
02:19:47 <solrize> why text?
02:20:06 <gour> solrize: cause HDBC does not have support for inserting BLOBs
02:20:08 <solrize> and i dunno how well sqlite3 handles large blobs
02:20:28 <solrize> fix hdbc, requiring text is lame
02:20:50 <gour> solrize: well, we'll experiment...otoh, both monotone  & fossil scm store everything in sqlite3 db
02:21:06 <solrize> as blobs?
02:21:17 <solrize> is fossil any good?  i just happened to be looking at its docs a minute ago
02:21:19 <solrize> funny coincidence
02:21:49 <gour> solrize: it is, but i don't like its (non-standard) wiki...that's why i'll use monotone
02:22:09 <gour> solrize: there was/is heated debate about it on the ml 
02:22:15 <solrize> ic
02:23:24 <gour> since it cannot provide all-in-one solution for me, i plan to use monotone with indefero hosting which is supposed to get mtn support soon...btw, too bad there is no public darcs hosting with tracker, code review etc.
02:24:27 <solrize> what does hackage use?
02:25:17 <solrize> hmm, source to patch-tag was just released?
02:25:32 <gour> no idea...gigit?
02:26:17 <gour> there is nothing similar to bitbucket, git{hub,orious}, launchpad etc. with darcs
02:26:59 <gour> indefero looks ok (with mtn support)...btw, i've played a bit with bugseverywhere which has darcs support
02:27:32 <gour> back to the question...anything besides base64 and/or yEnc can you recommend?
02:29:11 <solrize> if hdbc is limited to text, who knows what crazy encoding it expects and what it might do with non-alphanumeric unescaped characters?  in this situation I tend to fall back on plain old hexadecimal and take the 2x expansion
02:31:24 <Stalafin> i figure any attempt at creating a haskell based shell failed? :)
02:33:19 <Gracenotes> gour: I thought patch-tag filled that role
02:33:35 <Gracenotes> in some respect
02:33:56 <Gracenotes> not sure how much of it, as I haven't used it
02:38:11 <gour> Gracenotes: it provides, iirc, only hosting
03:19:36 <tolkad> I'm trying to make an instance of Unbox
03:19:59 <tolkad> but I keep getting a "parse error in pattern" for my implementation of size#
03:20:06 <tolkad> even something like this fails: size# _ _ = 5
03:20:16 <byorgey> tolkad: have you enabled -XMagicHash ?
03:20:20 <tolkad> why doesn't that work? how is that a parse error?
03:20:31 <tolkad> byorgey: no... what's that?
03:21:23 <byorgey> tolkad: that's the extension to enable the special foo# syntax
03:21:36 <tolkad> byorgey: I don't think it's magic, it's part of the function name
03:21:39 <byorgey> tolkad: put {-# LANGUAGE MagicHash #-} at the top of your .hs file
03:21:44 <tolkad> byorgey: http://hackage.haskell.org/packages/archive/vector/0.3.1/doc/html/Data-Vector-Unboxed-Unbox.html
03:22:04 <tolkad> byorgey: see? I don't need any extensions, it's just part of the function name
03:22:29 <tolkad> I can't figure out why it isn't working though
03:22:30 <Starfire> I know that there's a Functor instance for ((,) a). Would it be possible to write an instance for the type (_, b), where _ is supposed to be the 'hole' ?
03:22:47 <byorgey> tolkad: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#magic-hash
03:22:58 <byorgey> tolkad: # is not valid as part of identifier names unless you turn on MagicHash
03:23:15 <tolkad> oh
03:23:21 <tolkad> well then they shouldn't use it!
03:23:28 <tolkad> I want my code to be portable...
03:24:46 <Starfire> What I mean is that currently fmap succ (1,1) = (1,2). Would it be possible to write an instance so that fmap succ (1,1) = (2,1) ?
03:25:37 <byorgey> Starfire: no, not without making a newtype for pairs and making an instance for that.
03:25:53 <byorgey> e.g. you could do  newtype Pair a b = Pair (b,a)
03:25:58 <byorgey> then make an instance Functor (Pair a)
03:26:13 <tolkad> hmm, another problem
03:26:18 <tolkad> I can't import Data.Vector.Unboxed.Unbox 0_o
03:26:21 <byorgey> but to express the "hole" you would need to be able to say something like   instance Functor (\a -> (a,b))
03:26:28 <tolkad> it says it can't find it, but I installed Data.Vector
03:26:29 <byorgey> and there are no type-level lambdas in Haskell
03:26:35 <Starfire> Yeah, I see.
03:28:06 <tolkad> huh, it's not in the package? http://hackage.haskell.org/packages/archive/vector/0.6.0.1/vector.cabal
03:28:31 <tolkad> why is unbox not in the package? how does Data.Vector.Unboxed even work if it doesn't have Unbox!?!?
03:28:55 <byorgey> tolkad: Data.Vector.Unboxed.Unbox only seems to exist in older versions of the vector package
03:30:07 <byorgey> presumably its functionality was folded into another module, or it was decided that its functionality should no longer be exported.
03:30:24 <byorgey> although I don't really know anything about the vector package in particular.
03:31:56 <tolkad> apparently it is now in Data.Vector.Unboxed.Base
03:32:08 <tolkad> thank you, I didn't know stuff got moved around like that
03:32:22 <tolkad> also google was pointing me to old versions of documentation
03:32:45 <Starfire> Ugh. I'm just about to write (fmap.fmap.fmap.fmap.fmap) in my program. :)
03:32:47 <byorgey> yeah, don't use google to search for documentation.  find the documentation on hackage, or search for it using hoogle or hayoo
03:32:53 <tolkad> fortunately the hackage.haskell.org website is not overzealous in preventing users from viewing directory listings like many sites
03:33:11 <byorgey> why would you need to view directory listings?
03:33:12 <tolkad> I was able to find the latest documentation by browsing a few directories up
03:33:20 <byorgey> oh, I see =)
03:33:20 <tolkad> http://hackage.haskell.org/packages/archive/vector/
03:33:24 <tolkad> yeah
03:33:31 <elitexray> is haskel hacker's language?
03:33:55 <tolkad> elitexray: only leet haxors
03:34:07 <elitexray> then which program is for unleet hackers?
03:34:25 <copumpkin> I'm a l33t hax0r and I use hask3l
03:34:28 <copumpkin> so yeah
03:34:47 <tolkad> elitexray: internet explorer for mac
03:34:47 <elitexray> what kind of things can you hack?
03:34:54 <tolkad> elitexray: minds
03:34:55 <copumpkin> I've hacked loads of things
03:35:03 <quicksilver> Starfire: normally that suggests you should newtype your stack of types and make the whole stack an instance of Functor.
03:35:06 <elitexray> can you hack linux?
03:35:18 <copumpkin> elitexray: depends what you mean by hack :)
03:35:24 <copumpkin> haskell can hack your brain though
03:35:36 <elitexray> penetrate multiple security layers
03:35:52 <copumpkin> this is not a "hacking" channel :P
03:35:55 <copumpkin> and that sounds like movie talk
03:36:04 <tolkad> copumpkin: sounds like trolling :P
03:36:09 <byorgey> elitexray: yes, that is best done using the SecurityT monad transformer together with a zygohistomorphic prepromorphism
03:36:13 <copumpkin> lol
03:36:21 <copumpkin> edwardk actually did have a security monad
03:36:27 <copumpkin> preflex: seen edwardk
03:36:28 <preflex>  edwardk was last seen on #haskell 1 day, 18 hours, 22 minutes and 28 seconds ago, saying: ps-auxw: good tip
03:36:30 * byorgey is not surprised
03:36:47 <Starfire> quicksilver: Yeah, that seems like a good idea.
03:36:55 <copumpkin> elitexray: anyway, no questionable hat colors in here please
03:37:04 * copumpkin has a very slightly off-white hat
03:37:11 <copumpkin> but only cause it's dirty
03:37:33 <Jafet> I thought we were men without hats.
03:37:43 <copumpkin> if you're a hacker you've gotta have a hat
03:37:45 <copumpkin> hatcker
03:37:59 <tolkad> elitexray: ha ha very funny, that will be enough trolling for now
03:39:46 <tolkad> elitexray: you should start by asking legitimate question, that will give people who helped you an emotional investment in believing you are not a troll, they will not want to think their work helping you was a waste. It makes you more believable
03:39:53 <tolkad> questions*
03:40:18 <elitexray> Thanks for the advice.
03:41:54 * Jafet does a safety dance.
03:46:41 <Eduard_Munteanu> How would I go about adding mutable state somewhere in a layoutHook in the xmonad config?
03:47:23 <Eduard_Munteanu> I want to update that state by a timer, but I'm clueless wrt how to just plug a State in there.
03:48:11 <quicksilver> possibly a question for #xmonad, Eduard_Munteanu ?
03:48:13 <angstrom> is haskell considered to be a "very high level programming language"?
03:48:38 <Eduard_Munteanu> quicksilver: hm, I'll try. I'm looking for general advice, I wouldn't know how to do it in a different large project.
03:48:38 <quicksilver> no, not generally.
03:48:53 <copumpkin> I consider it to be very high level
03:48:53 <quicksilver> Eduard_Munteanu: sure but the answer depends on how xmonad is designed.
03:48:58 <copumpkin> but potentially lowish level too
03:48:59 <quicksilver> since I don't know, I can't answer.
03:49:10 <quicksilver> copumpkin: "Very High Level" is a technical term.
03:49:17 <copumpkin> oh, ok
03:49:23 <copumpkin> what criteria?
03:49:28 <quicksilver> it normally refers to things with very special purpose abstractions
03:49:36 <Eduard_Munteanu> quicksilver: I see. Thought there was some quick recipe equivalent to "add member x to struct y and tell function z to update it" :)
03:49:38 <quicksilver> or very natural language like
03:49:47 <quicksilver> often limited to a single domain
03:49:51 <angstrom> I see.
03:49:53 <copumpkin> ah, ugh
03:49:56 <copumpkin> I don't want one of those then
03:49:59 <quicksilver> no.
03:50:14 <copumpkin> :)
03:50:14 <quicksilver> I don't think a "general purpose programming language" can be one of them.
03:50:20 <quicksilver> and haskell is definitely general purpose.
03:51:24 <copumpkin> :)
04:18:56 * hackagebot opensoundcontrol-ht 0.1.1 - Haskell OpenSoundControl utilities  http://hackage.haskell.org/package/opensoundcontrol-ht-0.1.1 (HenningThielemann)
04:43:03 * hackagebot supercollider-ht 0.1.1 - Haskell SuperCollider utilities  http://hackage.haskell.org/package/supercollider-ht-0.1.1 (HenningThielemann)
04:47:55 <Baughn> djahandarie: Yep. It is I.
04:50:06 * hackagebot haskore-supercollider 0.1.2.1 - Haskore back-end for SuperCollider  http://hackage.haskell.org/package/haskore-supercollider-0.1.2.1 (HenningThielemann)
05:25:26 <pchiusano_> hello
05:27:48 <silver> рш
05:27:49 <silver> hi
05:29:26 <pchiusano_> i am trying to understand the MonadFix class...
05:30:17 <pchiusano_> can anyone show me a good example of how mfix would be used?
05:30:28 <pchiusano_> say, for, Maybe
05:30:40 <ivanm> pchiusano_: similar to how you use fix
05:30:48 <ivanm> @hoogle mfix
05:30:48 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
05:30:56 <ivanm> @hoogle fix
05:30:56 <lambdabot> Data.Function fix :: (a -> a) -> a
05:30:56 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
05:30:56 <lambdabot> module Control.Monad.Fix
05:31:38 <pchiusano_> ivanm: fix I understand, it is computing f ( f ( f ( ... ) ...)
05:31:52 <ivanm> @type mfix (\ n -> if n==0 then Nothing else Just (n-1))
05:31:53 <lambdabot> forall a. (Num a) => Maybe a
05:31:53 <pchiusano_> so like fix (1:)
05:32:00 <ivanm> > mfix (\ n -> if n==0 then Nothing else Just (n-1))
05:32:04 <lambdabot>   mueval-core: Time limit exceeded
05:32:13 <ivanm> pchiusano_: exactly
05:32:22 <ivanm> you can define fibonacci with fix, but I can't recall how
05:32:36 <ivanm> (I think you pass a function around or something)
05:32:54 <quicksilver> pchiusano_: mfix is calculating f =<< ( f =<< ( .....
05:32:57 <pchiusano_> it doesn't seem like mfix has anything to do with monads then..
05:33:01 <quicksilver> if I got that right.
05:33:04 <ivanm> pchiusano_: sure it does
05:33:08 <ivanm> it's the monadic version of fix
05:33:12 <ivanm> it returns a monad
05:33:12 <quicksilver> it's exactly the same with a slightly altered form of application
05:33:14 <pchiusano_> quicksilver: ahhh
05:33:23 <ivanm> same as how you have mapM versus map
05:33:36 <byorgey> > fix ((1:) . scanl (+) 1)
05:33:38 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
05:33:46 <byorgey> ivanm, like that
05:34:19 <ivanm> no, wait, I meant factorial
05:34:24 <ivanm> I've seen fix used to define factorial
05:34:54 <pchiusano_> okay, thanks guys
05:35:02 <ClaudiusMaximus> ivanm: fix $ \fact n -> ...
05:35:21 <quicksilver> pchiusano_: I don't think you can easily construct an interesting example of mfix for Maybe
05:35:24 <ivanm> ClaudiusMaximus: yeah, that's right, you're basically doing fix on a function so you then supply a value
05:35:27 <byorgey> > let fact f n = if n == 0 then 1 else f (n-1) in fix fact 3
05:35:28 <lambdabot>   1
05:35:36 <ivanm> quicksilver: well, not one that works...
05:35:38 <byorgey> whoops
05:35:41 <pchiusano_> just like with fix, if the function passed to infix is strict then you get infinite loop
05:35:41 <byorgey> > let fact f n = if n == 0 then 1 else n * f (n-1) in fix fact 3
05:35:42 <lambdabot>   6
05:35:43 <quicksilver> pchiusano_: because, basically, you can't use Nothing, that doesn't partly define anything.
05:35:46 <ivanm> has anyone here actually used fix or mfix in real code?
05:35:52 <quicksilver> > mfix (\x -> Just (1:x))
05:35:53 <lambdabot>   Just [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:35:56 <ivanm> byorgey: *tsk, tsk* :p
05:36:19 <quicksilver> ivanm: well, I find recursion a clearer notation than fix, so I would use recursion.
05:36:24 <Starfire> > let e = exp 1; i = 0:+1 in e**(i *) + 1 $ pi
05:36:24 <ClaudiusMaximus> isn't MonadFix the foundation for recursive do?
05:36:25 <zygoloid> ivanm: fix? i don't think so. mfix? umm. actually, also no.
05:36:25 <lambdabot>   0.0 :+ 1.2246467991473532e-16
05:36:31 <ivanm> you mean explicit recursion?
05:36:33 <byorgey> ClaudiusMaximus: yes
05:36:38 <Saizan> quicksilver: mfix is not really  f =<< ( f =<< ( ..... because the effects are supposed to happen only once
05:36:45 <ivanm> ClaudiusMaximus: oh, mdo?
05:36:53 <quicksilver> Saizan: oh.... good point.
05:37:01 <quicksilver> mdo is obsolete
05:37:02 <pchiusano_> Saizan: what?
05:37:02 <byorgey> mdo is now do rec, or something like that
05:37:05 <quicksilver> it's recursive do now :)
05:37:07 <ivanm> yeah
05:37:17 <byorgey> but yes, that is translated away to something using mfix.
05:37:22 <zygoloid> RecursiveDo is dead, long live DoRec
05:37:45 <Saizan> pchiusano_: e.g. mfix (\_ -> putStrLn "foo" >> return 3) will print foo only once and return 3
05:38:10 <zygoloid> mfix (\n -> print n >> return 3) will print 3 once and return 3 :)
05:38:26 <Saizan> are you sure?
05:38:47 <ivanm> zygoloid: it will print foo ...
05:38:57 <ivanm> oh, wait, you were using your own thing
05:39:08 <Saizan> it'll get into a loop :)
05:39:15 <zygoloid> Saizan: hmm, no, it's too strict, innit ;-)
05:39:15 <ivanm> zygoloid: I get a <<loop>> here ...
05:39:22 <Saizan> zygoloid: yep :)
05:39:43 <pchiusano_> the function is strict in n
05:39:45 * zygoloid deploys stToIO . strictToLazyST . unsafeIOToST
05:40:09 <pchiusano_> but the example by Saizan would be fine
05:40:18 <zygoloid> hmm, is that just unsafeInterleaveIO?
05:40:19 <quicksilver> not sure that will affect the behaviour of the putChar# primitive zygoloid 
05:40:40 <quicksilver> (which is what makes print strict)
05:41:46 <zygoloid> quicksilver: right you are :)
05:42:30 <zygoloid> looks like it's actually not possible to make that example work ;(
05:43:17 <pchiusano_> ok, i gotta run, thanks guys :)
05:43:28 <quicksilver> except moving the print outside the mfix which is presumably not really what you're after.
05:43:47 <ivanm> with that regex "play" paper, what was the point of the weightings?
05:43:48 <zygoloid> is the MonadFix instance for IO actually useful, then? I guess you can use it successfully with IORefs?
05:44:13 <ivanm> and am I correct in assuming that the epsilon matches the empty list/string/whatever?
05:44:36 <ivanm> zygoloid: as Saizan said, you need MonadFix for do rec
05:45:00 <Saizan> mfix (\n -> forkIO (print n) >> return 3) >>= print . show -- haha, here you get both the loop and "3"
05:45:09 <zygoloid> ivanm: i think you misunderstand. i'm asking if do rec is useful for IO
05:45:11 <ivanm> Saizan: cheater!
05:45:20 <ivanm> zygoloid: ahhh
05:45:32 * ivanm has never understood the rationale for do rec, so wouldn't have a clue
05:47:07 <quicksilver> zygoloid: you can use it successfully with IORefs but not to do anything you can't do by constructing the mutually recursive pure values in a normal (recursive) let and then writing to the IORefs
05:47:42 <quicksilver> zygoloid: I think that's the general pattern - since the only useful knot-tying must be in parts which are independent of the IO execution, you might as well tie the knot in pure code.
05:48:57 <zygoloid> quicksilver: ok, that's interesting. are there monads where that's not the case?
05:49:04 <Saizan> in one of The Monad.Reader's there's a nice example of a one-pass assembler which handles forward references with do-rec
05:49:43 <roconnor> :)
05:49:49 <Saizan> i don't think that could be locally refactored into not needing do-rec
05:51:02 <roconnor> @src mfix IO
05:51:03 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:51:08 <roconnor> @src IO mfix
05:51:08 <lambdabot> mfix = fixIO
05:51:14 <roconnor> @src fixIO
05:51:15 <lambdabot> Source not found. Sorry.
05:51:48 <Saizan> something evil with an IORef
05:51:49 <roconnor> AFAIK fixIO is implemented using IORefs.
05:52:38 <roconnor> perhaps with a dash of unsafesomethingorother
05:53:18 <zygoloid> fixIO k = do r <- newIORef (throw NonTermination); v <- unsafeInterleaveIO (readIORef r); v' <- k v; writeIORef r v'; return v'
05:54:13 <Twey> That's pretty evil
05:57:33 <zygoloid> fix f = unsafePerformIO $ do r <- newIORef (throw NonTermination); v <- unsafeInterleaveIO (readIORef r); let v' = f v; writeIORef r v'; return v'
05:57:36 * zygoloid ducks
05:58:32 <msieradzki> is there 1 blessed 3D vector, 4x4 matrix and so on library?
05:59:21 <quicksilver> no, msieradzki.
05:59:45 <msieradzki> I'm looking for something like D3DX :)
06:00:27 <quicksilver> zygoloid: Well, you need to imagine an IO action which actually does some IO work, and still returns an output which depends lazily on its inputs.
06:00:38 <quicksilver> zygoloid: that is possible, but the IORef example isn't one if it.
06:01:49 <quicksilver> zygoloid: mfix (\n -> do l <- getLine; return (l++n))
06:01:49 <hpc> msieradzki: the closest you will likely get is the OpenGL library
06:03:54 <fffej> I'm trying to use Criterion to see how fast a server is by timing http requests - Criterion appears to be reporting numbers that are too high and if I introduce manual timing with "GetCPUTime" those numbers are lower.  Any pointers to what I'm doing wrong would be greatly appreciated
06:03:58 <quicksilver> zygoloid: ...still returns an output which depends lazily on its inputs *and* depends somehow on the IO performed, in order to be interesting.
06:05:19 <kowey> does the new -dynamic flag change the practicality of using the LGPL (as a GPL/BSD compromise) for Haskell libraries?
06:05:45 <kowey> my current understanding is the same as John's in http://code.google.com/p/pandoc/issues/detail?id=175#c5
06:08:41 <hpc> his assessment seems correct
06:08:56 <hpc> dynamic linking cuts off the license
06:09:10 <ski> (ivanm : s/returns a monad/returns a monadic action/ ..)
06:09:55 <copumpkin> we need dependent haskell to allow the returning of monads
06:21:36 <hpc> tuples are an instance of arrow, yes?
06:21:43 <copumpkin> no
06:22:02 <copumpkin> I dare you to write such an instance though
06:22:31 <hpc> heh
06:23:02 <quicksilver> instance Arrow (,) where arr f = (undefined, f undefined)
06:23:12 <copumpkin> lol
06:23:21 <quicksilver> (a,b) >>> (c,d) = (a,d)
06:23:33 <hpc> :t arr
06:23:34 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
06:25:36 <hpc> :t x &&& y &&& z
06:25:37 <lambdabot>     Couldn't match expected type `a b c' against inferred type `Expr'
06:25:37 <lambdabot>     In the first argument of `(&&&)', namely `x'
06:25:37 <lambdabot>     In the expression: x &&& y &&& z
06:25:50 <hpc> :t \x y z -> x &&& y &&& z
06:25:51 <lambdabot> forall (a :: * -> * -> *) b c c1 c'. (Arrow a) => a b c -> a b c1 -> a b c' -> a b (c, (c1, c'))
06:26:44 <hpc> :t fmap (&&&)
06:26:45 <lambdabot> forall (a :: * -> * -> *) b c c' (f :: * -> *). (Arrow a, Functor f) => f (a b c) -> f (a b c' -> a b (c, c'))
06:27:25 <hpc> > join (x, (y, z))
06:27:26 <lambdabot>   No instance for (GHC.Base.Monad ((,) SimpleReflect.Expr))
06:27:26 <lambdabot>    arising from a...
06:27:56 <hpc> i'll stop failing now
06:35:18 <hpc> > x `mplus` y
06:35:19 <lambdabot>   Couldn't match expected type `m a'
06:35:19 <lambdabot>         against inferred type `SimpleRef...
06:37:00 <Belimawr> algum brasileiro aki???
06:39:18 <jmcarthur> agh! kind polymorphism hurts my brain!
06:39:31 <jmcarthur> i haven't experienced this since i was first learning haskell
06:39:38 <petersen> finally found time to update hircules to ghc-6.12 will upload to hackage later
06:39:42 <jmcarthur> clearly i must master this
06:40:45 <hpc> o.o how does that work?
06:41:08 <jmcarthur> http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html
06:41:19 <jmcarthur> i think i'm getting it now
06:42:11 <hpc> ah! my brain!
06:45:03 <zenzike> Is there such thing as a "record function", ie, given a record type Foo { bar :: a, baz :: b }, is there sugared notation for creating the function of type Foo -> a -> a that changes just bar? (Maybe something like { bar = bar' }?)
06:45:18 <quicksilver> jmcarthur: the point is that when GHC sees "forall f. f a -> f b" it makes the "simplest assumption compatible with the signature"
06:45:51 <quicksilver> jmcarthur: I.e. it assumes a and b are simple types, *, and therefore f is * -> *
06:46:31 <quicksilver> zenzike: \bar' -> (\x -> x {bar = bar'})
06:46:34 <jmcarthur> zenzike: if foo is the name of the variable,  foo { bar = x } will return another Foo with bar changed to x
06:46:41 <quicksilver> zenzike: not particularly sugared, you will observe.
06:46:50 <zenzike> quicksilver: yeah, i figured that one by myself :-)
06:46:54 <quicksilver> This is why people like packages like data-accessor and fclabels.
06:47:08 <hpc> can the element to be changed be made first-class?
06:47:33 <hpc> as in \bar -> x {bar=bar'}
06:47:50 <zenzike> jmcarthur: thanks, I'd like to keep foo anonymous, so quicksilver's answer is nearly what I want, but it's just not sweet enough!
06:47:55 <jmcarthur> i don't understand that, hpc 
06:47:57 <hpc> er, nvm, ambiguous type
06:48:17 <jmcarthur> zenzike: yeah, you want data-accessor or fclabels or something
06:48:25 <zenzike> jmcarthur: thanks, I'll look into it
06:48:33 <quicksilver> hpc: no.
06:48:41 <quicksilver> hpc: see fclabels or data-accessor.
06:48:56 <quicksilver> field names are not first class.
06:51:05 <EvanR-work> the observations are first class they are just functions
06:51:28 <EvanR-work> but not updates
06:51:38 <EvanR-work> whats up with that!@
06:52:14 <quicksilver> they're not first class as field names.
06:52:23 <quicksilver> they are functions, but that's a mere shadow of their total purpose.
06:52:38 <quicksilver> in the same way Constructors are not first class - they degrade to mere functions, too.
06:58:02 <monoidal> i'm attempting to make data GraphMorphism a b = forall obj. Mor (forall x y. a x y -> b (obj x) (obj y)) instance of Category. it's miskinded - (* -> * -> *) -> (* -> * -> *) -> *, instead of * -> * -> *. ideas appreciated :)
06:58:46 <rwbarton> You need kind polymorphism
06:58:59 <rwbarton> Or a new Category' class
06:58:59 <quicksilver> monoidal: are you not the monoidal who wrote the blog article we were discussing 5 minutes ago?
06:59:09 <monoidal> yes, I'm attempting to expand the article
06:59:18 <monoidal> to show that monoids in Graph are categories
06:59:35 <quicksilver> rwbarton: then he has kind polymorphism because he's using UHC
06:59:52 <quicksilver> but you're still going to need to re-cast category in a polymorphic way, aren't you?
07:00:05 <monoidal> it's possible I'll use TH instead of kind polymorphism, to make it run on GHC
07:00:29 <rwbarton> the Category class should be inferred to be polymorphic already then
07:01:52 <monoidal> the problem is: with id :: x -> cat x x, kind of cat cannot be (* -> * -> *) -> (* -> * -> *) -> *. I don't know if it's definition of GraphMorphism wrong, or I should change Category somehow
07:02:22 <pokoko222> Did you guys work the Change-making problem in college?
07:04:06 <pokoko222> I had problems coming up with a solution by myself when i worked on euler problems, and now I understand this solution http://mitpress.mit.edu/sicp/full-text/sicp/book/node16.html
07:04:27 <pokoko222> but i think i would have never thought of it or it would have took me a lot to get to that 
07:04:55 <pokoko222> do you think you can solve that problem without seeing the solution first? do you remember these things or it is ok to remind yourself?
07:05:36 <pokoko222> i am just interested of how you guys deal with this problem specifically in terms, you solved it once and forgot it and now you must look at some reference, or you can solve it right away no problem?
07:06:04 <quicksilver> monoidal: ? surely id :: cat x x
07:06:09 <quicksilver> monoidal: not x -> cat x x
07:06:15 <copumpkin> meow
07:06:33 <monoidal> quicksilver: ah, thanks
07:06:57 <pokoko222> copumpkin PLEASE  your opinion on what i asked? please
07:07:11 <copumpkin> pokoko222: I solved that problem but didn't solve it in school
07:07:34 <pokoko222> copumpkin just like the link i gave?
07:07:39 <pokoko222> recursion
07:07:41 <copumpkin> didn't read it all
07:07:51 <copumpkin> but yeah, I guess
07:08:06 <pokoko222> so you could solve it now again? without looking at references or whatever? without feeling like reinventing the wheel?
07:08:47 <copumpkin> sure
07:08:55 <quicksilver> you either remember the solution or you remember the general "shape" of the "trick".
07:09:12 <quicksilver> I woudln't feel bad if you can't remember how to reconstruct it - it's just practice.
07:09:14 <copumpkin> yeah, that's the case with most stuff though, I think
07:09:22 <quicksilver> solve a few problems of that "shape" and you will start to remember the pattern.
07:09:38 <pokoko222> hmm well said, thank you very much guys
07:12:45 <pokoko222> i guess i should keep studying for college and working on euler project and things should work out with time :)
07:13:40 <msieradzki> just wanted to ask why Data.Tensor.Vector3 doesn't implement  Num
07:13:49 <msieradzki> but uhm Num  seems badly engineered
07:14:09 <interferon> are there any haskell parsing libraries that support error correction?
07:14:20 <msieradzki> what kind?
07:14:34 <msieradzki> last time I used parsec it reported error quite nicely
07:14:42 <Saizan> interferon: uu-parsinglib
07:14:47 <rwbarton> Num basically represents rings, if you ignore abs and signum
07:14:48 * hackagebot weighted-regexp 0.2.0.0 - Weighted Regular Expression Matcher  http://hackage.haskell.org/package/weighted-regexp-0.2.0.0 (SebastianFischer)
07:14:56 <interferon> Saizan: thanks
07:14:58 <rwbarton> Vector3 isn't a ring, you can't multiply
07:15:03 <msieradzki> magic word ignore
07:15:17 <msieradzki> (*) a -> a -> a doesn't work in R^3
07:16:00 <msieradzki> so it's something like if you ignore half of the interface (class) you can have it implementing it :)
07:16:02 <rwbarton> there are packages on hackage with classes for things like vector spaces
07:16:11 <msieradzki> saw one
07:16:18 <msieradzki> will check if I can get fast code using it
07:16:35 <rwbarton> I think it's generally considered normal to want to use Num for arbitrary rings, but not for arbitrary abelian groups
07:29:53 * hackagebot wai-extra 0.2.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.1 (MichaelSnoyman)
07:29:55 * hackagebot wai-handler-fastcgi 0.2.1 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.2.1 (MichaelSnoyman)
07:29:57 * hackagebot wai-handler-scgi 0.2.0 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-0.2.0 (MichaelSnoyman)
07:34:08 <cacalavaca> help
07:34:35 <Silvah> lol?
07:37:12 <Tomsik> @pl \(x,y) -> \(a,b) -> (x+a, y+b)
07:37:12 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
07:37:18 <Tomsik> oh shit
07:37:26 <Silvah> @unpl uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
07:37:27 <lambdabot> uncurry (\ ab f -> (\ p x -> ((,)) (ab + (fst p)) (f + x)) >>= \ ag -> snd >>= \ af -> return (ag af))
07:37:59 <Silvah> Yeah, I agree with you.
07:38:14 <Tomsik> I thought you could do something like \a -> \b ->(+) <$> a <*> b :/
07:39:22 <Silvah> @pl \(x,y) (a,b) -> (x+a, y+b)
07:39:23 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
07:39:57 <Twey> Um, I'm pretty sure that can be written better.
07:40:05 <monoidal> > (uncurry (+) *** uncurry (+)) ((1,2),(3,4)) -- Tomsik
07:40:06 <lambdabot>   (3,7)
07:40:51 <Saizan> > uncurry (\(x,y) -> \(a,b) -> (x+a, y+b)) ((1,2),(3,4)) 
07:40:52 <Tomsik> monoidal: that's still longer than  \(x,y) -> \(a,b) -> (x+a, y+b) :p
07:40:52 <lambdabot>   (4,6)
07:41:00 <Saizan> not the same, also
07:41:30 <monoidal> Tomsik: or \(x,y) (a,b) -> (x+a,y+b)
07:41:35 <Tomsik> yeah
07:42:08 <Tomsik> > let haha (x, y) (a,b) op = (op x a, op y b) in haha (1,2) (3,4) (+)
07:42:09 <lambdabot>   (4,6)
07:42:10 <roconnor> > swap (1,2)
07:42:11 <lambdabot>   Not in scope: `swap'
07:42:28 <Tomsik> it kind of looks like >>= to me
07:42:29 <Veinor> @unpl uncurry (+) *** uncurry (+)
07:42:29 <lambdabot> ((uncurry (+)) *** (uncurry (+)))
07:42:40 <Tomsik> but I'm categorynoob
07:42:47 <Saizan> > (uncurry (***) . ((+) *** (+)) $ (1,2)) (3,4)
07:42:49 <lambdabot>   (4,6)
07:43:20 <Tomsik> whoops, gotta run, see ya
07:43:24 <Saizan> > ((uncurry (***) .) . ((+) *** (+))) (1,2) (3,4)
07:43:26 <lambdabot>   Couldn't match expected type `t -> (a b c, a b' c')'
07:43:26 <lambdabot>         against inferr...
07:44:09 <Saizan> oh, duh
07:44:10 <monoidal> :t join (***) (uncurry (+))
07:44:11 <lambdabot> forall c. (Num c) => ((c, c), (c, c)) -> (c, c)
07:44:31 <Saizan> > (uncurry (***) . ((+) *** (+))) (1,2) (3,4)
07:44:33 <lambdabot>   (4,6)
07:45:13 <Saizan> we need support for product categories :)
07:45:51 <monoidal> @hoogle (x -> y -> z) -> (a -> b -> c) -> (x,a) -> (y,b) -> (z,c)
07:45:52 <lambdabot> No results found
07:50:40 <Stalafin> is there anyone here who uses haskell for any sort of small scripting things? stuff people would usually do with bash, perl, python?
07:51:21 <Silvah> Me, for instance.
07:52:54 <Stalafin> Silvah: are there any disadvantages to doing so? can you do all the stuff one can do with other languages?
07:53:11 <Jafet> I often use the glorious haskell calculator interface.
07:53:28 <monoidal> instance (Category c, Category d) => Category (Prod c d)
07:53:46 <Stalafin> Silvah: what about the speed? as i take it, the haskell interpreter compiles an executable which is then run... therefore, even if one does not actually compile the code, it still takes a lot of time
07:54:15 <jmcarthur> it compiled to bytecode, not binary
07:54:18 <jmcarthur> *compiles
07:57:27 <Silvah> A lot of time? It's comparable with "proper" scripting languages, so if it takes a lot of time in interpreted Haskell, it'd take a lot of time in e.g. Python, too.
07:58:30 <Twey> :t (uncurry $ on (***) (+))
07:58:31 <lambdabot> forall c. (Num c) => (c, c) -> (c, c) -> (c, c)
07:58:37 <Twey> Tomsik: ^
07:59:05 <Twey> :t uncurry (on (***) (+)) (3, 3) (1, 2)
07:59:06 <lambdabot> forall c. (Num c) => (c, c)
07:59:07 <Twey> > uncurry (on (***) (+)) (3, 3) (1, 2)
07:59:09 <lambdabot>   (4,5)
07:59:11 <Veinor> ooh
07:59:21 <Twey> Silvah: Not entirely true, since more effort is put into optimising e.g. Python
08:00:27 <Twey> Silvah: CPython is intended to be used as an interpreted language for real apps, whereas GHCi is only really intended to aid development
08:00:41 <ClaudiusMaximus> wheeeee two extra bang patterns and my code sped up by 37%, nicely
08:01:03 <Silvah> Twey: we're talking about "small scripting things", not about real apps.
08:01:11 <Twey> I guess
08:01:39 <roconnor> ClaudiusMaximus: where?
08:01:48 * roconnor prefers to speed code up by making it more lazy
08:02:47 <ClaudiusMaximus> roconnor: let !v = readDouble bytestring in insertWith' ...
08:03:06 <Silvah> It doesn't matter whether it does the work in 0.01 s or 0.2 s, as long as it works correctly and doesn't take too much time.
08:03:29 <ClaudiusMaximus> roconnor: http://claudiusmaximus.goto10.org/g/misc/bsl.png << before || after >> http://claudiusmaximus.goto10.org/g/misc/bang.png
08:04:30 <jmcarthur> when possible i prefer to use strict data types instead of bang patterns. i feel that it is cleaner and more predictable
08:04:34 <roconnor> ClaudiusMaximus: that seems like a fair use of !
08:04:45 <jmcarthur> and i haven't had a space leak since i began with that policy
08:04:54 <jmcarthur> i don't know that i can justify it logically though
08:05:24 <ClaudiusMaximus> well, BangPatterns is a language extension, so that's one reason not to use it i guess
08:05:32 <jmcarthur> i'm not opposed to extensions
08:05:42 <jmcarthur> i use them very liberally, even
08:06:12 <jmcarthur> i love your hp output
08:06:32 <ClaudiusMaximus> thanks :)
08:06:45 <roconnor> ClaudiusMaximus: well, my problem is more with seq than with bang patterns
08:06:55 <roconnor> ClaudiusMaximus: but this use of seq is fine.
08:07:07 <roconnor> ClaudiusMaximus: it is really nothing more than a case statement
08:07:29 <roconnor> but compressed down into one character
08:08:15 <ClaudiusMaximus> i'm quite impressed with how much memory was saved by switching from String to ByteString.Lazy.Char8 - around a 5-fold decrease
08:09:07 <ttmrichter> ClaudiusMaximus: Wouldn't that be roughly the savings from, you know, a 32-bit pointer per character?
08:09:38 <ClaudiusMaximus> ttmrichter: well, i guess so
08:09:56 <ClaudiusMaximus> and i'm on 64bit..
08:11:04 <ClaudiusMaximus> under 4mins and 240MB to process a 37MB .hp file, so far
08:11:12 <jmcarthur> > let foo x = undefined in foo `seq` 5
08:11:13 <lambdabot>   5
08:11:53 <jmcarthur> i've been curious about the hp file format. i presume it's pretty simple
08:11:55 <ClaudiusMaximus> and the output stage currently unpacks to String and then packs back to ByteString
08:12:01 <ClaudiusMaximus> it is exceedingly simple
08:12:49 <ClaudiusMaximus> take a look at one, it's just BEGIN_SAMPLE 42.34\nfoo  64\nbar  38\n...\nEND_SAMPLE 42.34\n etc
08:12:56 <jmcarthur> ah nice
08:15:05 <monoidal> is there a category abstraction that doesn't require Hask to be set of objects?
08:15:15 <monoidal> in category-extras most probably
08:15:34 <roconnor> is there a category abstraction that does require Hask to be set of objects?
08:15:48 <monoidal> roconnor: Control.Category
08:16:17 <roconnor> in what way does that require Hask to be a set of objects.
08:16:19 <roconnor> er
08:16:26 <roconnor> maybe I don't know what you mean by "set of objects"
08:16:31 <monoidal> you have to give id :: c x x for all x
08:16:40 <monoidal> similarily for composition
08:17:00 <JoeyA> How would I go about doing something like this?  http://codepad.org/oR0KyuFN
08:17:03 <roconnor> isn't that a requirement to be a category?
08:17:10 <cuba> any1 here actually coding haskell for profit?
08:17:17 <jmcarthur> monoidal: what is the alternative you are looking for?
08:17:34 <monoidal> I meant "for all x" in Hask. I can't create unit category for example, only a discrete category full of objects
08:17:54 <monoidal> or the empty category
08:17:55 <JoeyA> Does what I'm trying to do require rank 2 types or something?
08:18:11 <jmcarthur> ah, so you mean thing sort of thing that we mean when we talk about "restricted monads"?
08:18:19 <monoidal> jmcarthur: yes
08:18:25 <roconnor> JoeyA: it requriest existential types
08:18:25 <jmcarthur> s/mean thing/mean the same/
08:18:30 <roconnor> *requires
08:18:33 <jmcarthur> i don't know of any
08:18:50 <monoidal> JoeyA: use existential type: forall b. http://codepad.org/oR0KyuFN
08:18:54 <jmcarthur> even in category-extras
08:18:59 <monoidal> * forall b. Apply (b -> a) b
08:19:33 <jmcarthur> http://hackage.haskell.org/package/data-category
08:19:34 <monoidal> JoeyA: or, make Foo a b instead of Foo a
08:19:39 <jmcarthur> might have something in there
08:19:59 <monoidal> thanks
08:20:15 <jmcarthur> yeah, that appears to have them
08:20:39 <jmcarthur> unusual formulation though
08:20:50 <roconnor> JoeyA's code reminds me of CoYoneda
08:21:13 <roconnor> I'd be tempted to remove Yield and just use Apply id
08:22:39 <jmcarthur> that's kind of a cool functor there
08:23:14 <int80_h> what do people use to render literate haskell onto an html page, where somethign like <code> foo </code> is recognized as haskell code?
08:23:16 <jmcarthur> looks i guess like distilled stream fusion with a "force" option
08:23:39 <jmcarthur> int80_h: i think pandoc has some cool options for that sort of thing
08:24:01 <jmcarthur> int80_h: for converting markdown with literate haskell into html and stuff
08:24:32 <jmcarthur> int80_h: if it's a blog there are also syntax highlighting plugins for a lot of engines. there are also a couple javascript highlighters i think
08:25:02 <int80_h> jmacarthur: thanks :)
08:25:32 <BMeph> JoeyA: In case you hadn't done it yet, "forall b." fixes it: http://codepad.org/nGqz1MLw
08:28:30 <JoeyA> Indeed, thanks
08:34:10 * hackagebot DSTM 0.1 - A framework for using STM within distributed systems  http://hackage.haskell.org/package/DSTM-0.1 (FrankKupke)
08:34:12 <ClaudiusMaximus> should i be using arrays instead of   accumulate = transpose . map (scanl (+) 0) . transpose :: [[Double]] -> [[Double]] ?
08:35:19 <ClaudiusMaximus> wondering what kind of array more than anything, really
08:35:50 <nominolo> wow, didn't know that Ordering has a Monoid instance
08:36:22 <ClaudiusMaximus> i recall some neat tricks with that
08:38:17 <ClaudiusMaximus> :t runSTUArray
08:38:18 <lambdabot> Not in scope: `runSTUArray'
08:38:26 <ClaudiusMaximus> @hoogle runSTUArray
08:38:26 <lambdabot> Data.Array.ST runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
08:38:31 <ManateeLazyCat> How to make ghc compile *.hs file and DON'T generate *.o/*.hi files?
08:38:56 <nominolo> ManateeLazyCat: there is a flag for that
08:39:05 <ManateeLazyCat> nominolo: Which flag?
08:39:06 <ManateeLazyCat> :)
08:39:12 <ClaudiusMaximus> hm, compile but generate no output?
08:39:19 <ManateeLazyCat> ClaudiusMaximus: Yes.
08:39:53 <ManateeLazyCat> ClaudiusMaximus: I use ghc as "runtime type checker" on temporary *.hs file, so i don't need output.
08:40:04 <nominolo> -fno-code
08:40:05 <ClaudiusMaximus> probably -E
08:40:15 <ManateeLazyCat> nominolo: Thanks
08:40:24 <nominolo> it might still write .hi files, not sure.
08:40:34 <ClaudiusMaximus>     -E		stop after generating preprocessed, de-litted Haskell
08:40:35 <ManateeLazyCat> nominolo: I try.
08:49:02 <ManateeLazyCat> "ghc -e expression Foo.hs" can work, no *.o/*.hi files generate. 
08:52:29 <ClaudiusMaximus> @hoogle [a] -> UArray Int a
08:52:29 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
08:52:29 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
08:52:29 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
09:00:05 <Tomsik> @src on
09:00:06 <lambdabot> (*) `on` f = \x y -> f x * f y
09:00:18 <Tomsik> @where on
09:00:19 <lambdabot> I know nothing about on.
09:00:49 <ski> @index on
09:00:50 <lambdabot> bzzt
09:01:07 <ski> @botsmack
09:01:07 <lambdabot> :)
09:01:08 <ski> @type Data.Function.on
09:01:09 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:05:09 <quicksilver> @docs on
09:05:09 <lambdabot> on not available
09:07:42 <conal> BMeph: hi.  i see you assigned http://hackage.haskell.org/trac/ghc/ticket/4220 to me.  intentional?  i don't know what meaning people assign to being owner.  i don't intend to submit a patch, as i don't have the required ghc-fu.
09:07:42 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:09:05 <conal> BMeph: oh -- just got your note via lambdabot about you assigning ownership to me.  i'm going to unassign and leave for someone qualified  to make the fix.
09:11:00 <BMeph> conal: Hello. Really, I just did it because the Trac sorts bugs by owner, not by folks who want to be notified by it. I didn't realize that ownership of a bug is supposed to indicate an intent to fix the bug. It makes sense, now that you said^Wwrote something about it. :)
09:11:54 <conal> BMeph: ah, okay.  i'm glad to know also (about semantics of "owner").  thanks.
09:12:54 <quicksilver> conal: to answer simon's question, the foldable instance should produce 'mempty', and the traversable instance should be unsafeCoerce#, right?
09:13:53 <conal> quicksilver: i don't know.  haven't thought about it.
09:14:01 * ski wonders what the proper solution, instead of using `unsafeCoerce#' would be ..
09:15:36 <ski> (.. i suppose OCaml's polymorphic variants gives something like what we want .. but is there a nice way to adapt that behaviour in this circumstance to typing matchings on `data' (or `newtype') declarations ?)
09:16:40 <quicksilver> ski: higher order unification on the Constructors?
09:16:54 <quicksilver> f (?C a) = (?C a)
09:17:23 <ManateeLazyCat> ski: runtime type match?
09:17:39 <quicksilver> the thing is, that in principle rebuilds the cons cell - but, to be honest, it's an implementation detail of GHC that you can use unsafeCoerce#
09:20:32 <quicksilver> the traversable instance is pure . unsafeCoerce#, rather.
09:22:19 <ski> with polymorphic variants, if you say  fun ma amb -> match ma with `Right a -> amb a | e -> e  then since it knows  e  can't be using the  `Right  constructor, we can just reuse the same  e
09:23:17 <quicksilver> ski: yeah.
09:23:39 <quicksilver> ski:  which may or may not actually be O(1), that's an implementation detai.
09:24:29 <ski> so .. i suppose something similar for `data' constructors would be to note that in `case Right a -> ..a.. ; e -> e' the `e' can't be of the `Right' constructor .. and since that was the only constructor naming the `a' type variable in `Either e a', we can say that the catch-all case `e' there has type `forall a. Either e a'
09:24:50 <ski> .. i'm not sure whether this complication would be worth the extra complexity, though
09:27:04 <hpc> :t \e -> case Right a -> a; e -> e
09:27:05 <lambdabot> parse error on input `->'
09:27:29 <hpc> hmm
09:28:05 <quicksilver> ski: I have some vague memory of a discussion with SPJ about this once, in the specific case of either
09:28:27 <ski> @type \e -> case e of Right a -> a; e -> e
09:28:28 <lambdabot>     Occurs check: cannot construct the infinite type: t = Either t1 t
09:28:28 <lambdabot>       Expected type: t
09:28:28 <lambdabot>       Inferred type: Either t1 t
09:28:43 <ski> quicksilver : `either' or `Either' ?
09:29:01 <quicksilver> ski: w.r.t "why do (\x -> case x of Right a -> Right a; Left a -> Left a) have a different type to (\x -> case x of a@(Right _) -> a; b@(Left _) -> b)
09:29:25 <quicksilver> that's not quite what I meant.
09:29:29 <quicksilver> but you get the idea.
09:29:41 <ski> yeah, that's more or less the same issue
09:31:12 <ski> if in `case ma of Right a -> ..a.. ; e -> e', the `e' got type `forall a. Either e a', then the `b' in `\x -> case x of a@(Right _) -> ..a..; b@(Left _) -> ..b..' could as well
09:31:52 <ski> (now, retro-typing things further back would be more shady ..)
09:41:30 * hackagebot omnicodec 0.3.1 - data encoding and decoding command line utilities  http://hackage.haskell.org/package/omnicodec-0.3.1 (MagnusTherning)
09:42:33 <copumpkin> > (m + 1) * (n + 1)
09:42:34 <lambdabot>   (m + 1) * (n + 1)
09:50:33 * hackagebot reactive 0.11.5 - Push-pull functional reactive programming  http://hackage.haskell.org/package/reactive-0.11.5 (ConalElliott)
09:51:37 <conal> that update tracks some ghc changes and a change to TypeCompose
09:56:21 <zenzike> conal: "This version of Reactive has some serious bugs that show up particularly with some uses of the Event monad" is that still true?
09:56:45 <conal> zenzike: yeah.  i haven't worked on reactive in a while.
09:57:10 <zenzike> righto
09:57:43 <aavogt> performance or 'correctness'?
09:58:05 <Veinor> depends
09:58:19 <aavogt> > (m :+ 1)**2
09:58:19 <Veinor> 'if you don't care about correctness why are you programming in haskell?'
09:58:20 <lambdabot>   No instance for (GHC.Float.RealFloat SimpleReflect.Expr)
09:58:20 <lambdabot>    arising from a ...
09:58:45 <psilva> I'm having a tuple ("a", "b", "c", ["e","f"]) ... how do I access ["e","f"] ?
09:58:46 <aavogt> sometimes things are correct enough
09:58:56 <copumpkin> psilva: with pattern matching
09:58:58 <copumpkin> only way
09:59:02 <aavogt> @hackage tuple
09:59:03 <lambdabot> http://hackage.haskell.org/package/tuple
09:59:14 <copumpkin> or that, but tuples are fugly
09:59:24 <copumpkin> just use custom adts :P
09:59:32 <aavogt> yes. That one just does the pattern matching for you.
09:59:41 <psilva> copumpkin: actually I did "bla666bla666bla" =~ "[0-9](bla)...(.)" :: (String,String,String,[String]) ... but how do I access the result? :P
10:00:14 <aavogt> the pattern match is best here then
10:00:31 <aavogt> it might even make the type signature unnecessary there
10:01:28 <psilva> sorry I don't get it ;) e.g. in Ruby I say "dfsdbla89bla".match(Regexp.new "bla(89)bla")[1] and I get the result in brackets I want
10:01:56 <psilva> I'd like to do the same in haskell
10:03:36 <Veinor> you can't really index into tuples nicely
10:03:41 <aavogt> > let (x,y,z,w) = "bla666bla666bla" =~ "[0-9](bla)...(.)" :: (String,String,String,[String]) in (w,x,y,z)
10:03:41 <lambdabot>   (["bla","b"],"bla66","6bla666b","la")
10:04:34 <psilva> hmm
10:04:38 <aavogt> > let (x,y,z,w) = "bla666bla666bla" =~ "[0-9](bla)...(.)" in (('a':x ++ y ++ z) : w)
10:04:39 <lambdabot>   ["abla666bla666bla","bla","b"]
10:05:23 <hpc> =~ should really return a record, rather than using type specification as a hack
10:05:44 <jmcarthur> :t (=~)
10:05:45 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
10:05:49 <jmcarthur> icky
10:05:54 <Veinor> eww
10:06:06 <Saizan> http://hackage.haskell.org/packages/archive/regex-compat/0.93.1/doc/html/Text-Regex.html <- regex-compat for a sane interface
10:06:08 <aavogt> hpc: maybe laziness wouldn't be sufficient?
10:06:09 <hpc> it's the worst type i have ever seen
10:06:18 <Veinor> hpc: printf?
10:06:26 <copumpkin> printf isn't that bad
10:06:28 <jmcarthur> not the worst i've seen by far
10:06:30 <hpc> :t printf
10:06:31 <lambdabot> forall r. (PrintfType r) => String -> r
10:06:56 <hpc> that at least isn't insane
10:07:04 <Veinor> printf is written in such a way so that you can either print to a string or stdout with the same function
10:07:08 <Veinor> I always thought that was hilarious
10:07:16 <copumpkin> I don't like that at all :P
10:07:18 <jmcarthur> yeah i'm not a fan of that
10:07:23 <copumpkin> I'd take out the IO instance
10:07:30 <aavogt> it comes at no cost though
10:07:43 <copumpkin> aavogt: except forcing you to put a signature sometimes when you wouldn't have to otherwise
10:07:47 <jmcarthur> there's a line between abstraction and magic
10:08:03 <Saizan> copumpkin: really?
10:08:09 <copumpkin> actually maybe not
10:08:12 <Veinor> if we want to be in line with other languages, we should technically rename the String instance to sprintf
10:08:15 <jmcarthur> there's an IO instance. why not have instances for all the other pointed functors?
10:08:17 <aavogt> copumpkin: how do you force the last  PrintfType to be String
10:08:19 <hpc> the regex-compat package is still a bit yuck
10:08:35 <jmcarthur> actually, that's not even what the IO instance does
10:08:47 <Saizan> the 4-tuple is not so nice
10:08:49 <Axman6> > printf "test %s %d" "hello" 3 :: String
10:08:51 <lambdabot>   "test hello 3"
10:09:19 <aavogt> you need some kind of annotation (or other function applied to the result) to say there are no more arguments
10:09:22 <DarkMalloc> Hello there copumpkin :)
10:09:26 <copumpkin> allo
10:09:47 <Axman6> > printf "test %s %d" "hello" 3
10:09:48 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:09:49 <lambdabot>    `Text.Printf.PrintfType ...
10:09:54 <Axman6> :t printf
10:09:54 <Veinor> I still say we should rename it sprintf
10:09:55 <lambdabot> forall r. (PrintfType r) => String -> r
10:10:02 <hpc> also, it uses Maybe [String] with Just [] being an impossibility
10:10:08 <DarkMalloc> copumpkin: I put my name down as "possible" for AngloSaxon :)
10:10:18 <Axman6> @instances PrintfType
10:10:18 <DarkMalloc> Gary corrections
10:10:19 <copumpkin> Anglohaskell :o
10:10:19 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
10:10:21 <DarkMalloc> Garh*
10:10:22 <hpc> which would be funny if it wasn't the only alternative
10:10:32 <DarkMalloc> copumpkin: on iPhone :P
10:10:36 <Axman6> @instances-importing Text.Printf.PrintfType
10:10:37 <lambdabot> IO a
10:10:37 <aavogt> you could do printf taking tuples...
10:10:38 <DarkMalloc> Yeah, AngloHaskell :)
10:10:42 <Axman6> :(
10:10:46 <Veinor> IsChar c => PrintfType [c]
10:10:48 <Veinor> PrintfType (IO a)
10:10:49 <aavogt> but those seem to be bounded afaict
10:10:50 <Veinor> (PrintfArg a, PrintfType r) => PrintfType (a -> r)
10:11:18 <Veinor> aavogt: yeah, but the bound is fairly large
10:11:49 <aavogt> a curried printf wouldn't be bounded though
10:11:56 <hpc> @instances IsChar
10:11:56 <lambdabot> Couldn't find class `IsChar'. Try @instances-importing
10:12:08 <Veinor> Char is the only IsChar ;)
10:12:26 <Veinor> also, yeah, you can only have 62-element tuples
10:12:39 <Axman6> that's not true
10:12:42 <hpc> i thought it was 64
10:12:48 <Veinor> > length "(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)"
10:12:49 <lambdabot>   63
10:12:51 <Veinor> 61
10:12:58 <Veinor> oh wait no 62
10:13:03 <Axman6> you can have them any size you like
10:13:16 <Veinor> really?
10:13:16 <hpc> and they only stopped there because of a bug that limits data declarations in a single file
10:13:17 <Axman6> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
10:13:18 <aavogt> Axman6: not with ghc
10:13:18 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
10:13:18 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -
10:13:18 <lambdabot> > y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -
10:13:18 <lambdabot> > t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> (
10:13:18 <lambdabot> a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51,
10:13:20 <lambdabot> t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70, t71, t72, t73, t74, t75, t76, t77, t78, t79, t80, t81, t82)
10:13:23 <Axman6> aavogt: yes with GHC
10:13:25 <jmcarthur> :o
10:13:28 <Veinor> :O
10:13:33 <hpc> O.O
10:13:34 <aavogt> Axman6: construct such a value
10:13:37 <Axman6> also, easiest way to spam the channel
10:13:43 <monoidal> it gives a linker error then
10:13:46 <jmcarthur> not easiest
10:13:48 <copumpkin> Axman6: ghc limits it to 62
10:13:55 <wli> There should be compiler magic for tuples as big as you want, if not in ghc then in some ideal compiler. Instances OTOH...
10:14:03 <Veinor> but really when would you need anything larger than, like... a 8-tuple?
10:14:13 <copumpkin> you should never need more than a 2-tuple
10:14:21 <hpc> i have never even needed 3
10:14:26 <Axman6> > (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
10:14:27 <lambdabot>   A 80-tuple is too large for GHC
10:14:28 <lambdabot>    (max size is 62)
10:14:28 <lambdabot>    Workaround: use nest...
10:14:32 <Axman6> bah
10:14:40 <monoidal> and (,,,,,) 1 1 1 ... 1 will give a linker error
10:14:42 <Axman6> well it can type any tuple anyway
10:14:57 <hpc> > (,,,,,) 1 1 1 1 1 1
10:14:58 <lambdabot>   (1,1,1,1,1,1)
10:15:04 <Ivo__> hi
10:15:10 <Axman6> 'lo
10:15:13 <wli> Instances are tougher but the compiler magic argument sees implementations not giving instances for more than some small number.
10:15:24 <monoidal> > let x = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
10:15:24 <lambdabot>   not an expression: `let x = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...
10:15:27 <Ivo__> im trying the tryhaskell.org site; i've done languages like c, java, python before
10:15:41 <monoidal> > seq ((,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) 0
10:15:42 <jmcarthur> Ivo__: awesome!
10:15:42 <lambdabot>   0
10:15:55 <Axman6> Ivo__: forget everything you know about them, it will make life a lot easier :)
10:16:01 <jmcarthur> indeed
10:16:05 <Ivo__> im wondering why you need the 'in <x>' bit
10:16:10 <Ivo__> in a let statement
10:16:15 <Ivo__> if its a statement
10:16:24 <hpc> as someone who came from java, python, and c++, the easiest tutorial to follow is learn you a haskell
10:16:29 <Axman6> > let x = 3
10:16:30 <lambdabot>   not an expression: `let x = 3'
10:16:30 <jmcarthur> Ivo__: because the entire let ... in ... syntax is itself an expression
10:16:34 <Axman6> Ivo__: what should that return?
10:16:35 <monoidal> Ivo__: there are no statements in haskell
10:16:45 <Ivo__> aha
10:16:53 <roconnor> the scope of the variable binding for a let statement doesn't extend past the in
10:16:56 <aavogt> monoidal: what is     pat <- exp  in do notation?
10:16:58 <monoidal> you can build expressions like "let ... in ...", "if ... then ... else ..." (notice mandatory else) etc
10:16:59 <copumpkin> let expression
10:17:00 <Ivo__> so is let .. in .. an expression? that's supposed to return something?
10:17:05 <hpc> "let x = 3" gives 3 the name x within the scope of the next statement
10:17:09 <copumpkin> there's a let "statement" in do notation
10:17:09 <hpc> er, expression
10:17:18 <hpc> "let x = 3 in x" is 3
10:17:21 <monoidal> aavogt: stay silent :)
10:17:24 <hpc> "let x = 3 in x+2" is 5
10:17:26 <hpc> etc
10:17:28 <jmcarthur> Ivo__: and for the record, there is no "in" required once you are using do notation (which i doubt you can even do on tryhaskell)
10:17:42 <Ivo__> ohh hangon
10:17:43 <jmcarthur> copumpkin: is it a statement if it's sugar?
10:17:46 <Axman6> urgh, why are people so unhelpful in here?
10:17:51 <Ivo__> so let is just binding something on that particular line
10:17:53 <roconnor> > let x = 3 in (let x = 4 in \y -> (y,x)) x
10:17:55 <lambdabot>   (3,4)
10:17:56 <Ivo__> not making a 'variable'
10:18:00 <Veinor> right
10:18:08 <copumpkin> jmcarthur: one might argue that as a user you shouldn't know or care what is sugar and what is "real" :P
10:18:09 <jmcarthur> Ivo__: it binds something into the scope of the expression following in only
10:18:09 <Axman6> if he's just started using tryhaskell.org, what are the chances he has any idea about do notation?
10:18:13 <copumpkin> everything is sugar at some level
10:18:32 <jmcarthur> copumpkin: i would disagree with that when it's *syntax* sugar
10:18:34 <Veinor> everything is sugar for assembly!
10:18:43 <hpc> Ivo__: make more sense now?
10:18:45 <Ivo__> im starting a discrete structures course
10:19:05 <monoidal> Veinor: are you saying assembly is a terminal object in category of languages?
10:19:13 <applicative> everything is sugar for atoms and the void. 
10:19:30 <aavogt> Veinor: it's sugar for electrons?
10:19:31 <hpc> atoms are sugar for fluctuations in space-time caused by energy
10:19:32 <Ivo__> yah, thanks roconnor, hpc, jmcarthur 
10:19:38 <jmcarthur> > (let x = 1 in x) + 2  -- Ivo__: this is what i mean when i say that let forms an expression
10:19:39 <lambdabot>   3
10:20:10 <roconnor> jmcarthur: good example
10:20:12 <Ivo__> i get what it means now.. i was thinking let might be the keyword for declaring a variable
10:20:23 <roconnor> > let x = 3 in (let x = 4 in x) + x
10:20:24 <lambdabot>   7
10:20:24 <hpc> Ivo__: god no, this isn't VB
10:20:25 <Veinor> monoidal: sure!
10:20:26 <hpc> :D
10:20:32 <Ivo__> hehe
10:20:36 <jmcarthur> it's for binding a variable in some scope
10:20:53 <hpc> variable is a misnomer, too
10:20:59 <hpc> get in the habit of saying "value"
10:21:09 <Ivo__> arg
10:21:14 <jmcarthur> hpc: i think variable is perfectly fine
10:21:23 <Axman6> Ivo__: you should know, variables in haskell aren't the variables you're used to. they're immutable
10:21:23 <Ivo__> stupid tutorial, telling me ive defined a function when i just bound it for one line
10:21:25 <roconnor> in haskell variables don't vary, just like in math.
10:21:26 <jmcarthur> it doesn't vary over time, but it can vary depending on inputs
10:21:57 <applicative> Ivo__, except for the ones that are mutable?
10:22:02 <monoidal> Ivo__: if you just write "let x = ..." without in, it's a special syntax in interpreter
10:22:02 <jmcarthur> Ivo__: in ghci (and maybe tryhaskell) you can just say let x = 5 without the "in" part and it should be in scope later
10:22:34 <Ivo__> jmcarthur: tryhaskell doesn't like it
10:22:39 <jmcarthur> ah
10:22:40 <Ivo__> thinks it isn't an expression
10:22:48 <jmcarthur> and it's right, there
10:22:48 <Ivo__> is eveyrthing an expression? or most things?
10:22:51 <hpc> do notation isn't something to concern yourself with yet, in any event
10:23:14 <hpc> there are expressions, name bindings
10:23:14 <Ivo__> since when are irc channels friendly >_>
10:23:21 <hpc> and patterns
10:23:27 <Ivo__> those 3 things?
10:23:30 <roconnor> Ivo__: in a real haskell module you will have declariations as well as expressions
10:23:34 <jmcarthur> there are a lot of things
10:23:40 <Ivo__> awww
10:23:40 <hpc> a name binding is a let, or anything else that gives something a name
10:23:43 <jmcarthur> s/declarations/annotations/
10:23:46 <Ivo__> oh well i suppose i well learn em
10:24:09 <hpc> a pattern is like the force push in star wars; it is totally magic, and you use it constantly
10:24:21 <jmcarthur> Ivo__: yeah, this channel is one of the best i've ever been to
10:24:44 <roconnor> expressions, declarations, patterns, and statements ... thoses are the major classes.
10:24:48 <jmcarthur> and we love newbies :)
10:25:00 <roconnor> anything else?
10:25:03 <hpc> newbies mean we need to try harder; we aren't avoiding success
10:25:08 <roconnor> there are minor things like imports and whatnot
10:25:10 <jmcarthur> heh
10:25:11 <Ivo__> instead of let square x = x * x in map square [1..10]
10:25:13 <c_wraith> they taste delicious!  err, I wasn't supposed to let that out, was I?
10:25:14 <ClaudiusMaximus> roconnor: you'll be pleased that i think i found a case where adding more laziness will hopefully speed things up (i was doing:  take (15 `max` length ...) which is clearly stupid)
10:25:20 <Ivo__> you u do map <something> [1..10] ?
10:25:27 <roconnor> ClaudiusMaximus: horray!
10:25:34 <jmcarthur> > map (\x -> x * x) [1..10]
10:25:35 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:25:40 <jmcarthur> Ivo__: ^^
10:25:40 <hpc> that's a lambda
10:25:41 <roconnor> ClaudiusMaximus: that just becomes take 15 ?
10:25:42 <Axman6> > map (\x -> x*x) [1..10]
10:25:43 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:25:45 <jmcarthur> and there are shorter ways yet
10:25:57 <hpc> > map (join (*)) [1..10]
10:25:58 <Ivo__> oh ok lambdas
10:25:58 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:26:07 <jmcarthur> > join (*) <$> [1..10]
10:26:08 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:26:25 <roconnor> ClaudiusMaximus: or more complicated like take 15 (zipWith const l1l) ?
10:26:31 <monoidal> Ivo__: lambdas are expressions, just like let .. in .. or if .. then .. else
10:26:37 <c_wraith> > map (^2) [1..10]
10:26:38 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:26:46 * roconnor finds zipWith const funny
10:26:49 <Ivo__> where do i go to find out what join does
10:26:53 <applicative> @type  (join (*)) 
10:26:54 <lambdabot> forall a. (Num a) => a -> a
10:26:58 <jmcarthur> Ivo__: don't bother yet
10:27:02 <hpc> > [1..10] <$ (^2)
10:27:03 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [t])
10:27:03 <lambdabot>    arising from a use of...
10:27:06 <c_wraith> roconnor, where did you see that?
10:27:09 <ClaudiusMaximus> roconnor: now i'm confused, i think it should reall yhave been `min` in htere
10:27:12 <hpc> > [1..10] $> (^2)
10:27:12 <lambdabot>   Not in scope: `$>'
10:27:13 <roconnor> c_wraith: I wrote it :)
10:27:17 <monoidal> Ivo__: in this context, join f x is same as f x x
10:27:25 * ClaudiusMaximus needs to go ponder
10:27:27 <roconnor> ClaudiusMaximus: oh right, I was reading it as min
10:27:28 <c_wraith> roconnor: I guess..  it shortens the second list, potentially.
10:27:34 <jmcarthur> Ivo__: in *this particular case*, join takes a function that takes two arguments of the same type and turns it into a function that only takes one
10:27:37 <Ivo__> can anyone get tryhaskell.org to work in chrome?
10:27:48 <jmcarthur> Ivo__: it works in chrome for me
10:28:22 <hpc> works on an older iron build here
10:29:54 <ClaudiusMaximus> roconnor: now it's   "take (length . take 15 $ ...) ..." but probably zipWith const would be better
10:30:08 <hpc> what do you guys think of a "newbie claim" system? rather than having a tornado of explanations in #haskell, someone claims the newbie as theirs and handles it via pm or temp channel
10:30:27 <roconnor> zipWith const (take 15 ...) ...
10:30:31 <hpc> :t zipWith const
10:30:32 <lambdabot> forall a b. [a] -> [b] -> [a]
10:30:33 <Ivo__> weird... i get http://i.imgur.com/RoTUg.png
10:30:39 <Ferdirand> hpc: but then other silent newbies do not benefit from the explanation
10:30:48 <roconnor> er flip (zipWith const) (take 15 ...)
10:31:14 <ClaudiusMaximus> roconnor: yep
10:31:16 <applicative> hpc, but it's only when I get corrected correcting a greener newbie, that I learn anything...
10:31:23 <roconnor> ClaudiusMaximus: zipWith const will be lazier
10:31:53 <hpc> > zipWith const [1,2,3] [4,5,6]
10:31:53 <jmcarthur> hpc: yeah, lurkers learn as much here as speakers
10:31:54 <lambdabot>   [1,2,3]
10:32:07 <Ivo__> how do i use @type? @type (toUpper) doesn't work so far
10:32:16 <jmcarthur> @type toUpper
10:32:17 <lambdabot> Char -> Char
10:32:18 <hpc> that's a lambdabot thing
10:32:23 <roconnor> ClaudiusMaximus: I still find it a bit unusual to want.
10:32:30 <hpc> in tryhaskell, use ':t'
10:32:34 <hpc> :t toUpper
10:32:35 <lambdabot> Char -> Char
10:32:37 <jmcarthur> Ivo__: in ghci you would say ":t toUpper" ... no idea if it works in tryhaskell
10:32:47 <Ivo__> ah tah, :t works
10:35:03 <roconnor> Ivo__: are you reading learnyouahaskell ?
10:35:14 <Ivo__> roconnor: tryhaskell.org
10:35:29 <roconnor> oh does it come with a tutorial?
10:35:44 <Ivo__> roconnor: it _is_ a tutorial, afaik
10:35:49 <roconnor> ah
10:35:51 <roconnor> neat
10:36:11 <Ivo__> like tryruby.org
10:36:15 * hackagebot weighted-regexp 0.3.0.0 - Weighted Regular Expression Matcher  http://hackage.haskell.org/package/weighted-regexp-0.3.0.0 (SebastianFischer)
10:36:22 <ClaudiusMaximus> roconnor: maybe this explains >> sizes = map snd ccTotals ; total = sum' sizes ; limit = 0.99 * total ; bigs = takeWhile (< limit) . drop 1 . scanl (+) 0 $ sizes ; bands = zipWith const ccTotals $ take 15 bigs
10:37:24 <ClaudiusMaximus> roconnor: where ccTotals is sorted with largest snd first
10:37:38 <pickles> > :t lambdabot
10:37:39 <lambdabot>   <no location info>: parse error on input `:'
10:37:43 <roconnor> give me a sec to chew on this
10:37:52 <pickles> :t lambdabot
10:37:53 <lambdabot> Not in scope: `lambdabot'
10:38:12 <jmcarthur> Ivo__: learnyouahaskell.com and realworldhaskell.org are good resources once you have exhausted the tryhaskell tutorial
10:38:16 <roconnor> ClaudiusMaximus: what is the type of ccTotals?
10:38:23 <ClaudiusMaximus> roconnor: it discards all the smallest bands that sum to less than 1% of the grand total
10:38:27 <ClaudiusMaximus> roconnor: hold on..
10:38:41 <ClaudiusMaximus> roconnor: [(ByteString, Double)]
10:39:04 <roconnor> good, and what does this data mean?
10:39:17 <Ivo__> jmcarthur: thanks
10:39:54 <roconnor> ClaudiusMaximus: okay, I'm starting to understand this
10:40:06 <interferon> Are haskell's semantics different in any meaningful way from typed lambda calculus?  Everything ultimately reduces to function application, right?
10:40:08 <ClaudiusMaximus> roconnor: the string is the cost center label from a heap profile, the double is the sum of all the heap profile samples for that cost center
10:40:11 <Ivo__> why doesn't it like:    let a = fsb "xyz" in a
10:40:35 <Ivo__> (not in scope, apparently)
10:40:43 <roconnor> interferon: haskell has case statements
10:41:21 <jmcarthur> Ivo__: what is fsb?
10:41:33 <zachk> frontside bus? 
10:41:36 <Ivo__> arg *let a = fst "xyz" in a - couldn't match expected type
10:41:52 <jmcarthur> Ivo__: fst is for tuples
10:41:56 <jmcarthur> Ivo__: do you mean head?
10:42:02 <zygoloid> interferon: haskell is turing complete, whereas STLC is strongly-normalizing
10:42:02 <fryguybob> > fst (1, 2)
10:42:03 <lambdabot>   1
10:42:07 <jmcarthur> > head "xyz"
10:42:08 <lambdabot>   'x'
10:42:20 <Ivo__> fst _only_ works on tuples?
10:42:23 <interferon> Roconnor: that's it?  And can't case statements be broken down into lambdas as well?
10:42:24 <jmcarthur> right
10:42:29 <monoidal> Ivo__: yes, and only on 2-tuples
10:42:31 <jmcarthur> Ivo__: in fact, fst only works on 2-tuples
10:42:39 <jmcarthur> to my disappointment
10:42:40 <fryguybob> > fst (1, 2, 3)
10:42:40 <zygoloid> interferon: haskell has recursive let
10:42:41 <lambdabot>   Couldn't match expected type `(a, b)'
10:42:41 <lambdabot>         against inferred type `(t, t1...
10:43:03 <Ivo__> couldn't they just make a function that works on n-tuples
10:43:10 <jmcarthur> Ivo__: there are ways
10:43:26 <fryguybob> > let fst (a,_,_) = a in fst (1, 2, 3)
10:43:27 <lambdabot>   1
10:43:34 <monoidal> interferon: if you desugar ADT's and case with Church encoding, Haskell is exactly lambda calculus with fixpoint operator
10:43:42 <jmcarthur> well sure that works on 3-tuples
10:44:13 <c_wraith> Are there any commonly-agreed-upon typographical symbols for types?  I'm tempted to start using old-fashioned basic symbols like $ % and !
10:44:22 <roconnor> interferon: perhaps, but the translation is a bit tricky, if it is at all possible.
10:44:32 <sproingie> let c$ = "foo"
10:44:38 <zygoloid> c_wraith: alpha, beta, etc?
10:44:55 <c_wraith> oh, sorry, I meant concrete types.
10:44:56 <jmcarthur> Ivo__: tuples are uncommon enough that we don't really need a lot of accessors for them (although more would be nice, and there are libraries providing more)
10:45:25 <zygoloid> c_wraith: you don't have a natural name for the type though? concrete but unspecified?
10:45:34 <ClaudiusMaximus> hmm, this is exploding in a shower of pulped RAM :(     sizeable = sortBy (flip $ comparing snd) . toList . unionsWith (+)
10:45:57 <c_wraith> I want to create a set of infix operators for string, integer, and double, so I'm looking for single-character punctuation markers for each of them
10:46:30 <roconnor> ClaudiusMaximus: heh, you know you wouldn't have to complete teh sort of ccTotals if you didn't discard this limit thing :)
10:46:45 <Ivo__> fryguybob: so that's an overridden function there?
10:46:50 <c_wraith> I guess I could try to create a typeclass, allowing me to use the same symbol for them all
10:47:00 <c_wraith> Meaning I wouldn't care.
10:47:01 <c_wraith> :)
10:47:14 <zygoloid> Ivo__: it's a local binding of fst, shadowing the global one.
10:47:17 <roconnor> hey everone, what is the complexity of take n (sort l) in haskell ?
10:47:25 <ClaudiusMaximus> roconnor: not exactly, i still need to sort to get the bands in the graph in a meaningful order
10:47:30 <fryguybob> Ivo__: ^^ what zygoloid said.
10:47:41 <ClaudiusMaximus> roconnor: like hp2ps with biggest on top (or optionally roughest on top)
10:47:44 <zygoloid> roconnor: depends how much of the result you actually look at, and how sort is implemented ;-)
10:47:50 <roconnor> ClaudiusMaximus: I mean that take m (sort l) runs in better than n*log n time
10:48:32 <roconnor> ClaudiusMaximus: actually, you could calculate the limit from the unsorted data
10:49:04 <interferon> monoidal: And that includes pattern matching?
10:49:05 <roconnor> ClaudiusMaximus: ... granted right now I'm talking about optimization only in the academic sense.  I have no idea how much time you are spending sorting.  Probably very little :)
10:49:30 <ClaudiusMaximus> roconnor: about 10 seconds it seems, but i'm more concerned about the memory spike
10:49:43 <roconnor> zygoloid: however ghc implements sort.  say the list is of length n and we look at the first m elements.
10:49:44 <interferon> roconnor: Why is it so difficult?  Aren't case statements just fancied-up conditionals?
10:49:57 <zygoloid> roconnor: i have a vague memory that it's O(n log m).
10:50:01 <Ivo__> what's wrong with let (a:b)­ = (10,"­abc") in a
10:50:03 <roconnor> ClaudiusMaximus: the sort causes a memory spike?
10:50:03 <fryguybob> Ivo__: In practice I've never used "fst" for 3-tuples, pattern matching is usually a better option.
10:50:10 <monoidal> interferon: pattern matching can be considered sugar: www.itu.dk/people/mir/typesafepatterns.pdf 
10:50:45 <roconnor> ClaudiusMaximus: was the program you are writing generating pretty graphs you posted?
10:50:51 <ClaudiusMaximus> roconnor: http://claudiusmaximus.goto10.org/g/misc/spike.png
10:50:54 <ClaudiusMaximus> roconnor: yes
10:50:58 <roconnor> :)
10:51:07 <roconnor> ClaudiusMaximus: are you using haskell-charts?
10:51:26 <ClaudiusMaximus> no, handcoded svg strings at the moment
10:51:47 <interferon> monoidal: Thanks for the link
10:51:49 <Ivo__> if there is fst, is there anything for lst?
10:51:49 <ClaudiusMaximus> (yes, it's ugly, but was quick to get working and i can replace it later)
10:51:58 <fryguybob> Ivo__: snd
10:52:05 <fryguybob> > snd (1, 2)
10:52:06 <lambdabot>   2
10:52:30 <roconnor> ClaudiusMaximus: that's pretty good for hand made svg 
10:52:54 <Ivo__> let (a:b)­ = (10:1­2) in a
10:52:57 <ClaudiusMaximus> roconnor: :)
10:52:59 <zygoloid> > thd (1,2)
10:52:59 <lambdabot>   ;(
10:53:00 <int80_h> exit
10:53:07 <Ivo__> why won't that work D:
10:53:12 <roconnor> anyhow if you immediately do a take 15 after your sort, then sort will run a little faster   .... And probably use a little less memory
10:53:26 <zygoloid> Ivo__: because (:) wants a list on the right hand side.
10:53:50 <zygoloid> > let (a:b) = [10,12] in a
10:53:51 <lambdabot>   10
10:53:51 <roconnor> but I don't know how best to reduce the memory use of sort, other than using an in place sort using starray.
10:53:57 <ClaudiusMaximus> i think i need to split up that sizeable into smaller bits so i can see where the memory is going, perhaps unionsWith
10:54:03 <fryguybob> > let (a:as) = (10:12:[]) in a
10:54:05 <lambdabot>   10
10:54:05 <fryguybob> > let (a:as) = (10:12:[]) in as
10:54:07 <lambdabot>   [12]
10:54:17 <Ivo__> let (a:_)­ = (10,1­2) in a
10:54:38 <fryguybob> > let (a,_) = (10,12) in a
10:54:39 <lambdabot>   10
10:55:05 <fryguybob> > (:) == (,)
10:55:06 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(a, [a])'
10:56:22 <zachk> you cant compare functions, its noncomputable 
10:56:46 <zachk> if you could im betting it would be trivial to solve the halting problem 
10:57:09 <jmcarthur> there are classes of functions that you can compare (perhaps inefficiently)
10:57:16 <monoidal> zachk: functions on noncompact sets
10:57:35 <Ivo__> so : is for lists and strings and , is for tuples
10:57:38 <monoidal> zachk: see http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
10:57:42 <jmcarthur> http://hackage.haskell.org/package/enumerable
10:58:11 <monoidal> zachk: it's mind-blowing that you cannot compare functions of type Integer -> Bool, but you can compare functions (Integer -> Bool) -> Bool
10:58:25 <zygoloid> Ivo__: correct. strings are in fact just lists of Char
10:58:26 <jmcarthur> Ivo__: they aren't quite the same though ("4:5" doesn't make [4,5], but "(4,5)" makes (4,5))
10:58:36 <jmcarthur> :t (:)
10:58:37 <lambdabot> forall a. a -> [a] -> [a]
10:58:38 <jmcarthur> :t (,)
10:58:39 <lambdabot> forall a b. a -> b -> (a, b)
10:58:50 <Axman6> Ivo__: it should be noted that tuples are sort of special in haskell. (a,b) and (a,b,c) aren't really related at all, apart from the fact they're both tuples
10:59:06 <fryguybob> @src String
10:59:07 <lambdabot> type String = [Char]
10:59:25 <monoidal> > ['a','b','c'] --Ivo__
10:59:26 <lambdabot>   "abc"
11:00:24 <hpc> > 'a':'b':'c':[]
11:00:25 <lambdabot>   "abc"
11:00:59 <ClaudiusMaximus> :t unionsWith (+)
11:01:00 <lambdabot> Not in scope: `unionsWith'
11:01:04 <ClaudiusMaximus> :t M.unionsWith (+)
11:01:05 <lambdabot> forall a k. (Num a, Ord k) => [M.Map k a] -> M.Map k a
11:01:36 <roconnor> ClaudiusMaximus: what is your key type?
11:01:53 <ClaudiusMaximus> roconnor: ByteString.Lazy.Char8
11:02:02 <c_wraith> Urgh.  Is there any way to get type inference for an expression that can only have one type because of the set of instances declared?
11:02:18 <ClaudiusMaximus> roconnor: moreover in the parsing stage i make sure to eliminate duplicate strings
11:02:56 <ClaudiusMaximus> roconnor: (not that that makes any difference in comparison time, i suspect)
11:03:13 <ClaudiusMaximus> but it does improve memory usage
11:03:26 <Nibble> Hello again!
11:03:38 <ClaudiusMaximus> i think i need to get the numbers into arrays as soon as possible
11:04:03 <c_wraith> The only instance of Num I declared an instance of this class for was Integer..  But ghc doesn't use that information when unifying types, so it doesn't know that my Num literal has to be an integer, so it's blowing up.
11:04:13 <Nibble> ClaudiusMaximus: arrays?
11:04:22 <ClaudiusMaximus> Nibble: yes
11:04:28 <Nibble> has haskell those?
11:04:29 <ClaudiusMaximus> @hoogle UArray
11:04:29 <lambdabot> Data.Array.Unboxed data UArray i e
11:04:29 <lambdabot> Data.Array.IO castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
11:04:29 <lambdabot> Data.Array.IO.Internals castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
11:04:38 <Nibble> I guess they have
11:04:50 <roconnor> STarrays!
11:04:58 <c_wraith> I really just want to avoid having to explicitly annotate the types of the numeric literals.  urgh.
11:05:09 <roconnor> c_wraith: defaulting
11:05:22 <Axman6> haskell has lots of array types Nibble 
11:05:28 <Nibble> Axman6: ok.
11:05:35 <ClaudiusMaximus> > let default = 42 in default
11:05:36 <lambdabot>   <no location info>: parse error on input `default'
11:05:52 <c_wraith> roconnor, I tried that, but it didn't change anything.  maybe I got the syntax wrong.
11:06:04 <c_wraith> It should have just been a line "default (Integer)"?
11:06:12 <roconnor> I think so
11:06:21 <aavogt> maybe without parens
11:06:21 <c_wraith> Yeah, that didn't solve the problem at all.
11:06:26 <Nibble> does you guys know of any good example code that I can look at to see the uses of stuff in haskell?
11:06:34 <c_wraith> No, the parens were necessary.  compile error without them
11:06:43 <roconnor> c_wraith: strange
11:07:10 <aavogt> I don't see the pattern for when parens are needed for fixities and defaulting
11:07:14 <fryguybob> @where hackage
11:07:14 <lambdabot> http://hackage.haskell.org/package/
11:07:21 <fryguybob> Nibble: ^^
11:07:57 <c_wraith> I think it's because it's attempting to unify '(Num t) => t' with 'MyClass a => a' that defaulting doesn't apply.
11:08:00 <Nibble> fryguybob: sure
11:08:00 <rwbarton> defaulting normally only applies when the classes involved are all standard library ones
11:08:13 <rwbarton> you might want to use extended defaulting rules (I forget the option name)
11:08:52 <c_wraith> rwbarton, I'll look for it.  thanks for the hint.
11:09:11 <napping> So, view patterns in GHC - do they just support the basic (view -> pat) syntax?
11:09:46 <napping> or did the Maybe sugar from the wiki page get a different syntax?
11:10:23 <aavogt> there is no implicit Just constructor
11:10:46 <c_wraith> looks like there's a flag, -fextended-default-rules.  let me see if that works for me
11:10:48 <napping> the wiki page proposes (view => pat) as sugar for (view -> Just pat)
11:11:01 <napping> oh well, it's not a huge deal
11:11:06 <Axman6> why specialise on Maybe? :\
11:11:23 <napping> well, that is pretty much what patterns work in anyway
11:12:01 <c_wraith> Turning on just that option reduces the compile errors to warnings.  I bet re-adding the default declaration removes the warnings, too
11:12:09 <Zao> Blargh, it seems like I've got to resort to StateT a IO b over State a b :(
11:12:27 <Nibble> I guess odd checks if a number is even or not?
11:12:30 <Nibble> odd*
11:12:31 <Zao> I need pointer-like thingies :(
11:12:37 <Zao> @src odd
11:12:37 <lambdabot> odd = not . even
11:12:48 <applicative> > map odd [1..23]
11:12:49 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
11:12:53 <Zao> @src even
11:12:54 <lambdabot> even n = n `rem` 2 == 0
11:12:55 <c_wraith> Nope, adding default (Integer) didn't get rid of the warnings.  But extended defaulting at least makes it compile.
11:12:57 <roconnor> Zao: data.accessor is a pointer like thing
11:13:11 <roconnor> Zao: ... and probably fclabels as well, but I've never used them.
11:13:41 <Nibble> Zao: that's a nice definition of odd lol
11:13:47 <Nibble> if it is not even
11:13:51 <Nibble> it is odd ^^
11:14:31 <Nibble> any good editors for haskell?
11:14:37 <Zao> roconnor: I basically need to represent a connected trisoup, with each triangle referencing its neighbours.
11:14:37 <Nibble> Currently I am using nano
11:14:46 <Zao> roconnor: With the ability to add and remove triangles.
11:15:10 <rwbarton> c_wraith: there's probably a flag to turn off defaulting warnings if you don't want them
11:15:38 <hpc> Nibble: anything with syntax highlighting should work swimmingly
11:15:43 <rwbarton> c_wraith: also, it's generally better to use language flags if one is available, I guess the name might be ExtendedDefaultRules
11:15:47 <Nibble> ok.
11:15:50 <Nibble> vim perhaps
11:15:52 <Zao> I guess what I need is a way to get an unique name an M.Map from that to the tri, and store names in the tris.
11:16:10 <c_wraith> rwbarton, the language pragma only applies to things in -X arguments, I thought.
11:16:12 <Zao> I just haven't managed to come up with a way to generate said names without suffering from IO.
11:16:13 <Nibble> any good colorschemes for vim?
11:16:21 <hpc> the default is about perfect
11:16:24 <Zao> Nibble: wombat256, inkpot, zenburn
11:16:33 <Zao> I lean towards the darker kind.
11:16:39 <napping> Zao: perhaps a splittable unique tree?
11:16:42 <rwbarton> c_wraith: right, so you can write {-# LANGUAGE ExtendedDefaultRules #-}
11:16:55 <c_wraith> But it's a -f flag, not a -X flag
11:16:59 <rwbarton> you can't write a LANGUAGE pragma for disabling warning
11:17:07 <rwbarton> It seems to exist as a -X flag too, unless you are using an older version
11:17:12 <Nibble> in haskell for indenting, do you usually use tabs or spaces?
11:17:17 <Nibble> and how many
11:17:19 <c_wraith> oh.  just docs lying to me, then
11:17:35 <monoidal> Nibble: spaces only, tabs shouldn't be used, but are equivalent to tabstop 8
11:17:53 <Veinor> spaces, and I use however many haskell-mode uses :D
11:18:05 <Nibble> Veinor: haskell mode?
11:18:08 <Nibble> tell me more
11:18:11 <Veinor> emacs mode for editing haskell
11:18:13 <roconnor> Zao: why do you want to be able to add and remove triangles?
11:18:21 <Nibble> Veinor: oh
11:20:16 <hpc> sometimes i think they picked 8 spaces deliberately, to make it so uncomfortable that changing to spaces is almost mandatory
11:20:48 <Zao> roconnor: Because I am triangulating a point cloud.
11:21:05 <Zao> roconnor: The algorithm is based on incremental addition and occasional removal of triangles.
11:21:06 <jmcarthur> 8 spaces is what tab means
11:21:13 <roconnor> Zao: why not build an immutable triangle point cloud in one go?
11:21:20 <roconnor> Zao: ah
11:21:22 <roconnor> stupid algorithms
11:21:29 <Nibble> oh lol
11:21:32 <Zao> roconnor: I'm in a State KitchenSink ().
11:21:33 <Nibble> zenburn didn't highlight stuff
11:21:41 <Zao> Nibble: Do you have syn on?
11:21:47 <Nibble> only let-in and do and that stuff
11:21:53 <c_wraith> there we go.  -fno-warn-type-defaults
11:22:01 <Zao> Nibble: You do realize that that's not anything the colourscheme is aware of?
11:22:18 <Zao> It may of course map several things to the same colour, of course.
11:22:36 <jmcarthur> hpc: http://en.wikipedia.org/wiki/Tab_key   "Instead settable tab stops were rather quickly replaced with fixed tab stops, at every multiple of 8 characters horizontally and every 6 lines vertically."
11:22:56 <Nibble> Zao: well, I am into vim colorschemes that much
11:23:42 <napping> hmm, it seems th-lift does not like infix constructors
11:23:46 <monoidal> jmcarthur: GHC seems to interpret tab as going to next multiple of 8
11:24:03 <napping> Why I even need Lift Rational to derive an instance for Dec I don't know
11:24:03 <Zao> I guess I could just use an incrementing serial number and abuse that.
11:24:07 <jmcarthur> monoidal: interesting
11:24:14 <napping> Zao: that's wht unique trees give you
11:24:14 <Zao> Not O(1) access, but it'll do.
11:24:17 <jmcarthur> monoidal: although you should have spaces before tabs if you are at all sane ;)
11:24:20 <jmcarthur> *shouldn't
11:24:22 <napping> but we pretend, so it is pure
11:24:23 <Zao> napping: I guess I've got to read up on those.
11:24:39 <napping> the idea is you make a lazy infinite binary tree
11:24:52 <napping> where each node is really just unsafePerformIO around incremented a (synchronized?) counter
11:24:59 <monoidal> jmcarthur: i mean, a line starting space-space-tab-... is equivalent to a line starting with tab-...
11:25:28 <jmcarthur> i got that
11:25:33 <napping> formally, your (newUniqueTree :: IO UniqueTree) picks some arbitrary tree of distinct integers
11:26:03 <jmcarthur> your point was that ghc doesn't do it at a "fixed" width either
11:26:18 <jmcarthur> it just has fixed tab stops every 8 columns
11:26:32 <monoidal> yes
11:28:27 <ManateeLazyCat> GHC-API was introduced which GHC version?
11:29:02 <calsaverini> hi
11:29:04 <aavogt> it has experienced some changes
11:29:12 <aavogt> ManateeLazyCat: so that's probably not important
11:29:49 <calsaverini> did anyone know of machine learning software implemented in haskell?
11:29:57 <ManateeLazyCat> aavogt: I have build dynamic-linking library that implement by GHC-API, i want know which GHC version introduced GHC-API.
11:30:16 <calsaverini> particularly inference in markov random fields with message passing algorithms
11:30:17 <ManateeLazyCat> aavogt: Then adjust build-depends in .cabal
11:30:47 <aavogt> ManateeLazyCat: it can fail to work for older ghcs even if they have those GHC modules
11:30:51 <copumpkin> calsaverini: haven't heard of anything along those lines
11:31:17 <copumpkin> I implemented BP/sum-product and a few CRF-related things a while ago but don't have the code with me
11:31:23 <copumpkin> and it needs testing etc.
11:31:27 <ManateeLazyCat> aavogt: I don't care older GHC since i use GHC-API.
11:31:53 <ManateeLazyCat> aavogt: Maybe i need set "ghc >= 6.12"
11:32:12 <copumpkin> can't you just depend on ghc api?
11:32:14 <aavogt> ManateeLazyCat: the ghc api changes
11:32:30 * hackagebot haskore-supercollider 0.1.2.2 - Haskore back-end for SuperCollider  http://hackage.haskell.org/package/haskore-supercollider-0.1.2.2 (HenningThielemann)
11:32:45 <calsaverini> copumpkin: I was willing to implement a BP for general graphs.
11:32:50 <ManateeLazyCat> aavogt: ?
11:33:32 <copumpkin> calsaverini: that'd be cool, especially if you can do the sum-product stuff
11:33:48 <copumpkin> if you give me time to get an enclosure for my hard drive I can give you my old code
11:33:50 <calsaverini> copumpkin: how difficult it was in your case? 
11:33:56 <copumpkin> not terribly difficult
11:34:36 <copumpkin> the issue is that all the descriptions of the algorithms describe it in terms of destrutive update
11:34:54 <ManateeLazyCat> aavogt: My plugins library : https://patch-tag.com/r/AndyStewart/manatee-plugins/snapshot/current/content/pretty/Manatee/Plugins.hs
11:35:00 <copumpkin> I just approximated that using a Map iirc, 
11:35:10 <copumpkin> it wasn't great but not terrible
11:35:18 <napping> ah, RecC is for records
11:35:23 <copumpkin> could've done it in ST with a bit less overhead I guess
11:35:32 <napping> that makes a bit more sense
11:35:46 <ManateeLazyCat> aavogt: Why you said GHC-API probably not important?
11:35:57 <aavogt> ManateeLazyCat: some parts existed a long time ago: http://www.haskell.org/ghc/docs/6.4-latest/html/libraries/base/GHC-Exts.html
11:36:21 <aavogt> ManateeLazyCat: your question asked what the first version of ghc to have the ghc-api was
11:36:34 <ManateeLazyCat> aavogt: Hmm, i see.
11:37:00 <ManateeLazyCat> aavogt: Now i just support ghc-6.12 or later version.
11:37:31 <aavogt> the two versions seem to be the same all the time
11:37:37 <aavogt> (ghc-version and ghc-api version)
11:39:44 <ManateeLazyCat> aavogt: Ok, thanks for explain, i use "ghc >= 6.12" in my cabal file.
11:40:12 <ski> ("My brain just exploded. I can't handle pattern bindings for existential or GADT data constructors." bah!)
11:46:10 <ahmedkotb> hi
11:48:19 <Zao> Hello there.
11:48:45 <EvanR-work> > print "Hello World"
11:48:46 <lambdabot>   <IO ()>
11:49:02 <Phyx-> EvanR-work: fail :P
11:49:11 <ahmedkotb> print "hello haskell world" :)
11:49:26 <EvanR-work> i meant to do that
11:49:31 <EvanR-work> (tm)
11:51:03 <Jafet> > show (print "a") == show (print "b")
11:51:05 <lambdabot>   True
11:53:45 <EvanR-work> o_O
11:53:50 <EvanR-work> ah show
11:53:59 <EvanR-work> > (print "a") == (print "b")
11:54:00 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.IOBase.IO ()))
11:54:01 <lambdabot>    arising from a use o...
11:58:42 <napping> where's that typeclass version of djinn?
12:03:05 <napping> http://okmij.org/ftp/Haskell/de-typechecker.lhs
12:03:21 <napping> I wonder if it could be improved to work without the explicit type argument
12:04:07 <Nibble> guys, why doesn't this work: hecker.lhs
12:04:08 <Nibble> 21:02 < napping> I wonder if it could be improved to w
12:04:11 <Nibble> oh shit
12:04:13 <Nibble> wrong paste
12:04:18 <Nibble> listOfSqrts =  [m | m <- [n^2 | n <- [1..]], odd m, n < 10000]
12:04:31 <Nibble> Not in scope: `n'
12:04:37 <napping> cause it's not in scope
12:04:40 <Axman6> well, its not in scope
12:04:44 <Nibble> napping:no shit
12:04:52 <Nibble> but, why is it not in scope?
12:04:59 <Axman6> n can only be seen inside [n^2 | n <- [1..]]
12:05:08 <napping> like in, say (let m = (let n = 12 in (n, 'X')) in show m ++ show n
12:05:14 <Nibble> oh ok
12:05:16 <Axman6> [n^2 | n <- [1..], n < 1000] would work
12:05:40 <napping> best to write [1..10000] so it will terminate, though
12:05:45 <Nibble> Axman6: well, I need the check of odd ones
12:05:48 <Axman6> yeah
12:06:02 <monoidal> or takeWhile (<1000^2)...
12:06:05 <napping> filtering [1..] gives you a list of items with an infinite loop at the end
12:06:16 <Axman6> [n^2 | n <- [1..10000]]
12:06:21 <twanvl> [m | n <- [1..], let m = n^2, odd m, n < 10000]
12:07:29 <Nibble> Axman6: hu? that removes the oddity check
12:07:49 <Axman6> i wasn't suggesting that's all you need...
12:07:54 <monoidal> [1,3..1000]
12:08:08 <Axman6> i was saying that you need [n^2 | n <- [1..]] -> [n^2 | n <- [1..10000]]
12:08:28 <Nibble> monoidal: sure, I know that is possible. But I am not trying to solve a problem. I am more trying to learn what works, what not and scoping in haskell
12:08:41 * hackagebot vorbiscomment 0.0.2 - Reading of Vorbis comments from Ogg Vorbis files  http://hackage.haskell.org/package/vorbiscomment-0.0.2 (ChrisWagner)
12:09:21 <napping> it's pretty lexical, check the report
12:09:51 <napping> I don't remember exactly how "where" clauses work, but the rest is pretty straightforward
12:10:34 <napping> for the most part, a binding scopes over the smallest enclosing expression
12:10:49 <napping> except case bindings are in scope only in that alternative
12:11:21 <napping> and various cases like pattern guards and do <-/let are only visible left-to-right
12:12:10 <Nibble> napping so
12:12:28 <Nibble> a variable inside for example a list comprehension
12:12:40 <Nibble> is only valid inside the list comprehension?
12:12:48 <napping> the smallest actual expression that includes the var <- bit is the list comprehension
12:13:05 <napping> so yeah, that follows what I suggested
12:13:23 <napping> anyway, it wouldn't make much sense outside. What value would it get?
12:13:24 <yokto> hi i've wanted to know - what is the deal with Qt in haskell? - there are two projects it seems "qthaskell" and "HQK" - but it seems they are not used very widely - there are no ubuntu packages ... - and if you download them they both contain lots of code that is machine generated - neither of them uses "smoke", an engine to make qt-kde bindings - why?
12:14:24 <Zao> yokto: Maybe smoke depends on a lot of KDE and other silly stuff?
12:14:38 <napping> sounds like it could be handy
12:14:47 <Zao> yokto: I'd expect that a hand-made binding might be more haskellic.
12:15:09 <napping> I don't think the Qt bindings are too popular, gtk2hs is older
12:15:22 <tg_> whoever decided to choose it, I just spit water onto my desk because of the Haskell on a Horse name
12:16:14 <yokto> ok then what about the machine generated code - is there no way to build every thing from source?
12:16:39 <yokto> btw smoke looks realy easy would any1 be interested in smoke made qt,kde bindings?
12:16:42 <Zao> yokto: What source?
12:17:03 <Zao> You need to more or less manually wrap things, and I assume those bindings are partly machine generated.
12:17:11 <napping> I don't know about the Qt bindings, but in gtk2hs there are tools to generate the automatic bindings, but the usual "source" bundle includes their output
12:17:13 <Zao> It's not like you can include a .h and all will be fine.
12:17:32 <napping> then there's a layer of nicer Haskell interfaces built on the direct bindings
12:17:41 * Zao huggles bindings-dsl.
12:17:48 <napping> I would guess something like that could work for Qt as well
12:17:57 <moep> has someone the adress of this irc channel, would like to add it in start up in chatzilla, got randomly here through a tutorial
12:18:13 <yokto> yes but smoke is already a more or less nice layer
12:18:18 <Zao> moep: irc.freenode.net; #haskell
12:18:22 <moep> thnaks
12:18:27 <napping> I mean like using typeclasses to simplify interfaces and stuff
12:18:50 <napping> smoke seems like it might have all the metadata you'd need to make a direct interface
12:18:55 <ClaudiusMaximus> http://claudiusmaximus.goto10.org/g/misc/spike.png <<before]   two hours well spent :)   [after>> http://claudiusmaximus.goto10.org/g/misc/spike-gone.png
12:18:58 <dcoutts_> napping: it's not quite automatic, the files are generated and then finished by hand.
12:19:19 <dcoutts_> napping: since there's not quite enough info to generate them fully automatically
12:19:20 <yokto> yes the (nice interface) approch HQK uses i quite well extlained in a paper - and it looks good
12:19:24 <napping> I was messing around with some of that a while back
12:19:24 <Zao> ClaudiusMaximus: Hooray.
12:19:49 <Zao> I wonder how much of the beast that is "Qt" that those bindings expose.
12:20:07 <napping> yokto: well, I don't use Qt much so I probably wouldn't use bindings either
12:20:11 <ClaudiusMaximus> it feels slightly unclean that i got rid of the memory spike by computing running totals during parsing instead of afterwards, but if it works it works...
12:20:14 <Zao> I mean, there's strings, container templates, signalling, windowing, networking, ohgodmakeitstop.
12:20:42 <napping> ClaudiusMaximus: were you perhaps building a giant thunk during the summing?>
12:20:43 <Zao> It's the EMACS of libraries. :D
12:20:45 * hackagebot pdynload 0.0.1 - pdynload is polymorphic dynamic linking library.  http://hackage.haskell.org/package/pdynload-0.0.1 (AndyStewart)
12:20:47 <ManateeLazyCat> I have finish "polymorphic dynamic loading" library -- pdynload, at http://hackage.haskell.org/package/pdynload , any suggestion and bugs are welcome!
12:21:40 <ClaudiusMaximus> napping: something like that - i had a big [Map ByteString Double] and   unionsWith (+)  exploded
12:21:53 <napping> oh, it sure would
12:22:08 <napping> need to force those Doubles
12:22:10 <ManateeLazyCat> pdynload is same principle as hs-plugins's function pdynload, but much simple and easy to use. Re-implement with GHC-API.
12:22:20 <napping> there's no unionsWith'
12:22:23 <ClaudiusMaximus> i know
12:23:32 <ClaudiusMaximus> anyway, my parser state now has Map ByteString ByteString (to intern symbols, otherwise the repeated strings consume too much memory, and a Map ByteString Double for the running totals
12:23:46 <napping> so, unionsWith is actually just a fold of unionWith
12:25:04 <napping> Data.Map could use some stricter functions
12:25:23 <ClaudiusMaximus> the fuzzy bit at the end of the graph is my next target
12:25:36 <napping> for time, or what?
12:25:40 <ClaudiusMaximus> time
12:26:16 <ClaudiusMaximus> i'm guessing it spends far too long doing ByteString -> String -> ByteString conversions
12:26:55 <ClaudiusMaximus> it was easier to hack it to do that when i converted from Prelude.interact to ByteString.interact, than to do it the right way
12:27:31 <napping> would a Data.Map.adjust' be helpful?
12:28:19 <ksf> Map won't be a trie, and comparison on strings is notoriously expensive
12:28:35 <ksf> try listmap or something from the gmap package
12:29:32 <c_wraith> napping: absolutely.  adjust is one of the worst offenders for potential space leaks
12:29:38 <ksf> you might even be able to hack up a proper trie for bytestrings with InjectKeys
12:29:42 <ClaudiusMaximus> :t M.adjust
12:29:43 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
12:29:55 <ClaudiusMaximus> i'm not using that one
12:29:58 <ClaudiusMaximus> :t M.alter
12:29:59 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
12:30:11 <ClaudiusMaximus> ^^ that one seems to be ok
12:30:37 <napping> well, it has to force the Maybe to decide what to do
12:30:38 <ksf> you're aware of the fact that each of those O( log n ) comparisons takes time proportional to the length of your strings, don't you?
12:30:57 <napping> if it's a win to intern them, they are probably quite short
12:31:07 <ClaudiusMaximus> ksf: i am, but they're around 30 chars max
12:31:08 <ksf> ...which is especially bad if you have a lot of common prefixes.
12:31:37 <ClaudiusMaximus> ksf: this is .hp cost centers, and yes, a trie might make more sense indeed
12:33:04 <ksf> hmmm.
12:33:27 <ksf> If you feel like it, you can implement generic deduping in terms of SYB
12:36:50 * hackagebot HStringTemplate 0.6.5 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.5 (SterlingClover)
12:37:03 <tg_> Was "A Play on Regular Expressions" influenced by GEB?
12:37:06 <tg_> anyone know?
12:40:31 <jmcarthur> there is a bytestring-trie package, but it apparently performs pretty badly
13:01:42 <fryguybob> @botsnack
13:01:43 <lambdabot> :)
13:02:02 <Nibble> lol
13:06:04 <djahandarie> Baughn, :)
13:06:27 <Baughn> djahandarie: What am I doing in #lurk, you ask?
13:06:35 <Baughn> Well, let me regale you with the tale.
13:06:39 <Baughn> To put it simply..
13:06:41 <Baughn> I'm lurking!
13:08:49 <djahandarie> Heh
13:09:00 <djahandarie> Was more surprised that you were on Rizon :P
13:09:12 <Baughn> Shouldn't be. I'm very anime-happy. :P
13:12:32 <p_l> djahandarie: be wary, he might pull you into lurking on fanfiction sites...
13:13:06 <djahandarie> lol
13:13:15 <p_l> 4srsly
13:15:08 <Baughn> djahandarie: I will, you know.
13:16:41 * p_l is a victim
13:16:56 <p_l> I thoroughly enjoyed it, though :P
13:20:16 <Nibble> @src put
13:20:16 <lambdabot> Source not found. I am sorry.
13:20:20 <Nibble> hum
13:20:28 <Nibble> @info Put
13:20:28 <copumpkin> :t put
13:20:28 <lambdabot> Put
13:20:29 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
13:22:26 <Veinor> thing that I just noticed: in the portability field, there's no distinction between 'not portable to non-GHC' and 'not portable to non-Linux'
13:27:04 * hackagebot bluetile 0.5.1 - full-featured tiling for the GNOME desktop environment  http://hackage.haskell.org/package/bluetile-0.5.1 (JanVornberger)
13:29:17 <Baughn> "cabal: Codec.Compression.Zlib: premature end of compressed stream" <- Set http_proxy for cabal update via superproxoid, get this. Any ideas?
13:29:18 <c_wraith> huh.  syz looks intriguing.
13:29:30 <Baughn> Wel, specifically I'm wondering if anyone else sees the same error. ;)
13:30:25 <Nibble> zax, swe?
13:30:38 <dcoutts_> Baughn: is it getting truncated?
13:32:17 <Baughn> dcoutts_: Presumably. Hm, let's see if I wget it..
13:32:34 <dcoutts_> Baughn: cabal update -v3 should help too
13:32:42 <Nibble> @t Complex
13:32:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:32:49 <Nibble> @info Complex
13:32:49 <lambdabot> Complex
13:32:53 <Nibble> uh?
13:33:11 <fryguybob> @src Complex
13:33:12 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
13:33:15 <Nibble> ah
13:33:19 <Nibble> fryguybob: thanks :)
13:33:26 <Nibble> RealFloat
13:33:28 <Baughn> dcoutts_: Not overly. I get an empty file.
13:33:35 <Nibble> that's just what Float And Double derives
13:33:36 <Nibble> right?
13:33:39 <Nibble> base-type for floats
13:33:49 <Baughn> dcoutts_: Everything appears to be working, as far as I can tell..
13:34:25 <Baughn> dcoutts_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28332#a28332
13:34:33 <Baughn> Guess wireshark is my next move.
13:34:41 <fryguybob> @google RealFloat haskell report
13:34:42 <lambdabot> http://www.haskell.org/onlinereport/complex.html
13:34:42 <lambdabot> Title: The Haskell 98 Library Report: Complex Numbers
13:34:52 <Axman6> @instances RealFloat
13:34:53 <lambdabot> Double, Float
13:35:06 <Nibble> Axman6: seems I was right
13:35:12 <Nibble> why doesn't info work on it?
13:35:22 <Nibble> @info RealFloat
13:35:22 <lambdabot> RealFloat
13:35:28 <Nibble> too much data?
13:35:32 <Axman6> info in lambdabot is completely useless
13:35:38 <Nibble> ok
13:35:44 <Nibble> I thought it was implemented through ghci?
13:36:07 * hackagebot twidge 1.0.4 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.0.4 (JohnGoerzen)
13:36:07 <Baughn> ..wireshark is too big, I'm not installing that via phone.
13:37:01 <monoidal> :i RealFloat
13:37:08 <rwbarton>  @info is actually spelling-corrected to @undo
13:38:05 <rwbarton> @info do {x <- [1, 2, 3]; return (x * x)}
13:38:05 <lambdabot> [1, 2, 3] >>= \ x -> return (x * x)
13:38:21 <Nibble> hmm, is lists monads?
13:38:26 <ezyang> yes. 
13:38:29 <Nibble> ok.
13:38:35 <Axman6> @instances Monad
13:38:36 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:38:42 <rwbarton> Not that @undo actually cares about that, but yes
13:38:50 <Nibble> @instances Writer
13:38:50 <lambdabot> Couldn't find class `Writer'. Try @instances-importing
13:38:58 <Baughn> Nibble: ANything for which you can define a reasonable fmap, ap and join is a monad. [a] counts, yes.
13:38:59 <Nibble> @instances-importing Writer
13:38:59 <lambdabot> Couldn't find class `Writer'. Try @instances-importing
13:39:01 <monoidal> Writer is a type, Monad is a type class
13:39:10 <Nibble> oh
13:39:10 <monoidal> well, Writer w a
13:39:48 <Baughn> There are actually several reasonable monads for lists. Well, at least two.
13:39:56 <jmcarthur> two?
13:40:02 <Baughn> ZipList too
13:40:07 <Axman6> there's a zipWith version too right?
13:40:09 <monoidal> ZipList is not from a monad
13:40:09 <jmcarthur> ZipList isn't a monad
13:40:19 <jmcarthur> it's only a monad if it's an infinite list
13:40:26 <jmcarthur> but that would just be a stream
13:40:45 <monoidal> infinite stream is really Natural -> a, which is reader
13:40:51 <jmcarthur> exactly
13:41:07 <Nibble> What is this thing with arrows
13:41:08 <Nibble> anyhow
13:41:14 <jmcarthur> Natural -> Maybe a does form an applicative, but not a monad
13:41:14 <Nibble> a <- xs
13:41:18 <Nibble> for example
13:41:36 <jmcarthur> @undo do { a <- xs ; foo a }
13:41:36 <lambdabot> xs >>= \ a -> foo a
13:41:36 <copumpkin> jmcarthur: that isn't really isomorphic to lists though
13:41:41 <copumpkin> since you could have lists with "holes"
13:41:44 <jmcarthur> Nibble: ^^
13:41:57 <Nibble> jmcarthur: what?
13:42:00 <jmcarthur> copumpkin: you're right it's not
13:42:10 <jmcarthur> Nibble: the arrows are syntax sugar
13:42:10 <Nibble> oh
13:42:24 <Nibble> jmcarthur: ok
13:42:32 <Baughn> Gah, I can't handle >>=. Someone rewrite the monad laws in terms of fmap/ap/join, please. ;_;
13:42:50 <Baughn> ..let's see.
13:42:57 <Nibble> >>= glues together two functions?
13:43:01 <jmcarthur> copumpkin: in fact, it's possible that what i said is not a monad may in fact be a monad
13:43:04 <jmcarthur> i was really far off
13:43:09 <Nibble> I am a bit tired of this syntax sugar
13:43:13 <jmcarthur> it is a monad
13:43:16 <ezyang> Baughn: Use kleisli composition :-) 
13:43:26 <jmcarthur> @unmtl Reader r Maybe a
13:43:26 <lambdabot> err: `r -> Maybe' is not a type function.
13:43:30 <copumpkin> Nibble: it isn't syntactic sugar, it's just a regular defined function, but no it doesn't glue together functions
13:43:34 <jmcarthur> @unmtl ReaderT r Maybe a
13:43:34 <lambdabot> r -> Maybe a
13:43:43 <Baughn> Nibble: >>= :: m a -> (a -> m b) -> m b
13:43:45 <Nibble> copumpkin: I am not saying that >>= is sugar
13:43:54 <Baughn> Nibble: ..aand that's *all* there is. Well, plus the monad laws.
13:44:02 <jmcarthur> Nibble: >>= glues together *actions*
13:44:14 <disgrntld> Why does the Monad typeclass have return? Doesn't Monad -> Applicative Functor? And doesn't Applicative Functor have pure already?
13:44:17 <jmcarthur> uh...
13:44:17 <copumpkin> well it glues an action to a function returning another action :)
13:44:17 <Nibble> jmcarthur: nitpicking :P
13:44:19 <Baughn> Nibble: There's no deeper meaning. This is the big secret of monads: There's no secret.
13:44:30 <Nibble> Baughn: ok
13:44:31 <copumpkin> disgrntld: it shouldn't, but it doesn't imply applicative
13:44:37 <Nibble> let me just read that first
13:44:38 <monoidal> disgrntld: yes, but Monad is not a subclass of Applicative (it should be)
13:44:38 <copumpkin> disgrntld: applicative was "invented" after monad
13:44:44 <disgrntld> gotcha, makes sense
13:44:46 <Baughn> disgrntld: Hysterical raisins. Applicative *should* be a superclass of monad, but isn't.
13:45:04 <disgrntld> can you give me a counterexample?
13:45:15 <Nibble> what is this deal with m a and m b
13:45:17 <Nibble> haven't seen it before
13:45:29 <disgrntld> ..and airplane food
13:45:35 <Baughn> disgrntld: Every sane monad can be trivially instanced as an applicative functor
13:45:38 <copumpkin> Nibble: m is a monad, and a and b are type parameters
13:45:43 <monoidal> Nibble: type application, just like Maybe Int
13:45:43 <jmcarthur> Nibble: that's just a way of saying "some type constructor m applies to some type a"
13:45:45 <copumpkin> Nibble: all polymorphic
13:46:01 <disgrntld> Baughn: ok, will I run into an common Monads that aren't?
13:46:14 <copumpkin> aren't what?
13:46:19 <disgrntld> applicative functors
13:46:21 <hpc> Set isn't applicative
13:46:23 <Baughn> disgrntld: You might, but only in very old libraries (mtl...? I think)
13:46:27 <jmcarthur> disgrntld: all applicatives are monads, but not all Applicatives are Monads :(
13:46:27 <hpc> iirc
13:46:30 <disgrntld> cool, enlightening
13:46:39 <ezyang> Let's say I have the type Pass a | Fail b | Intermediate c. Is the MonadPlus instance for this sufficiently obvious? 
13:46:40 <jmcarthur> hpc: but Set isn't a monad either
13:46:40 <copumpkin> hpc: it can't be
13:46:50 <copumpkin> hpc: it can't even be Functor
13:47:01 <monoidal> disgrntld: even if you have a monad that hasn't applicative instance, you can use WrapMonad constructor and treat a monad as applicative
13:47:02 <disgrntld> wait, what jmcarthur? I thought it went the other way: (most) all Monads are Applicative Functors?
13:47:06 <c_wraith> jmcarthur, isn't that backwards?  aren't all monads applicatives?
13:47:09 <hpc> ah, i remember Set messing with something...
13:47:15 <c_wraith> I mean, ZipList isn't a monad
13:47:16 <Baughn> ezyang: ..not really. I mean, what's Pass `mplus` Fail?
13:47:18 <jmcarthur> c_wraith, disgrntld: woops
13:47:21 <jmcarthur> quite so
13:47:22 <Nibble> copumpkin: oh so m is the function
13:47:23 <Nibble> ah
13:47:23 <copumpkin> c_wraith: potentially, yes, but in practice, people may have forgotten :P
13:47:29 <ezyang> Baughn: contradiction! 
13:47:29 <jmcarthur> sorry for the confusion
13:47:40 <Baughn> ezyang: Non-total functions are demonic!
13:47:41 <copumpkin> Nibble: m is a type function
13:47:42 <c_wraith> copumpkin, yes.  :)
13:47:49 <disgrntld> I almost gave up thinking I understood it jmcarthur ;)
13:47:54 <ezyang> It's true. Maybe I shouldn't then. 
13:48:02 <Baughn> ezyang: You should at least try to express it in the type system instead. ;)
13:48:04 <jmcarthur> disgrntld: it was a mere slip :)
13:48:25 <copumpkin> @djinn Not (a, Not a)
13:48:26 <lambdabot> f (a, b) = b a
13:48:27 <disgrntld> now I've got monad fever
13:48:31 <Baughn> ezyang: Also, I have no clue what the monad instance might be.
13:48:35 <disgrntld> ..horrible rashes
13:48:37 <disgrntld> :D
13:48:49 <ezyang> Baughn: It's Intermediate with success and failure continuations 
13:48:51 <Baughn> ezyang: ..monad is a /one-parameter/ type constructor, you know?
13:48:53 <copumpkin> @djinn Either a b -> Not a -> b
13:48:54 <lambdabot> f a b =
13:48:54 <lambdabot>     case a of
13:48:54 <lambdabot>     Left c -> void (b c)
13:48:54 <lambdabot>     Right d -> d
13:48:57 <Baughn> *monads should be
13:49:07 <ezyang> So, let instance Monad (Intermediate a b) where ... 
13:49:18 <Baughn> ezyang: Bzzt!
13:49:21 <jmcarthur> err
13:49:26 <jmcarthur> mising up types and values there?
13:49:27 <Baughn> ezyang: Intermediate is a value constructor, not a type
13:49:30 <jmcarthur> *mixing, even
13:49:44 <copumpkin> @djinn Not (Not (Either a (Not a)))
13:49:44 <ezyang> data Intermediate a b c = Pass a | Fail b | Intermediate c 
13:49:44 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
13:49:55 <Baughn> Oh. Ah.
13:50:00 <Baughn> Hm. Well, that could work.
13:50:02 <jmcarthur> okay, i see the intent now
13:50:05 <monoidal> you mean Intermediate a b c?
13:50:06 <copumpkin> @djinn Not (Not ((Not (Not a)) -> a))
13:50:07 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
13:50:11 <jmcarthur> Pass and Fail dominate?
13:50:11 * copumpkin shuts up
13:50:24 <jmcarthur> which dominates between Pass and Fail?
13:50:25 <Nibble> @src eval
13:50:25 <lambdabot> Source not found. Wrong!  You cheating scum!
13:50:33 <Baughn> ezyang: Generally.. first write your program. Then see if your type is a monad, afte ryou've used it some and can tell what the combinators are.
13:50:40 <ezyang> jmcarthur: Yeah 
13:50:42 <applicative> disgrntld, maybe it shows all monads are applicative that there is WrapMonad in Contol.Applicative, which semi-automates an Applicative instance, but there is also boilerplate instance Functor MyMonad where fmap = mapM ;  instance Applicative MyMonad where (*) = ap ; pure = return
13:50:45 <Nibble> @src even
13:50:45 <Veinor> what's void?
13:50:45 <lambdabot> even n = n `rem` 2 == 0
13:50:53 <Nibble> @src rem
13:50:53 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:50:57 <ezyang> Baughn: I've already got a program; right now I'm trying to decide if there are extra instances I should add to this monad 
13:50:59 <monoidal> Veinor: void :: Void -> a, where Void is empty
13:51:06 <applicative> what am I saying mapM. its liftM
13:51:13 <Veinor> so Void is an uninhabited type?
13:51:13 <Nibble> what does rem do?
13:51:19 <monoidal> Veinor: yes (only _|_)
13:51:20 <jmcarthur> ezyang: what is Pass x >> Fail y  or  Fail x >> Pass y ?
13:51:20 <ezyang> For example, MonadPlus would kind of make sense for a "here are a bunch of tactics that might or might not work" 
13:51:22 <Veinor> > 8 `rem` 3
13:51:23 <lambdabot>   2
13:51:23 <Nibble> does it change the value of n? xD
13:51:30 <Baughn> ezyang: If you have an mplus/mzero-like function set already, then sure, make it a monadplus. If you don't, why bother?
13:51:31 <Axman6> @src Void
13:51:31 <lambdabot> Source not found. Maybe you made a typo?
13:51:33 <ezyang> jmcarthur: Pass x and Fail x 
13:51:34 <monoidal> Nibble: remainder
13:51:35 <copumpkin> we like to pretend _|_ doesn't exist for djinny purposes
13:51:36 <Baughn> Unless you're making a library..
13:51:43 <disgrntld> ok, thanks applicative
13:51:52 <Nibble> monoidal: remainder after integer division I guess?
13:51:58 <jmcarthur> ezyang: then your type is isomorphic to what Either's monad *should* be like IMO
13:52:01 <Nibble> like % in C?
13:52:07 <Veinor> yeah.
13:52:12 <ezyang> Baughn: I don't. But the purpose of this exercise is so that I don't force other people to have to orphan instances / newtype 
13:52:17 <jmcarthur> ezyang: type Intermediate a b c = Either (Either a b) c
13:52:17 <monoidal> Nibble: yes. it's C-style with negative numbers. if you want positive remainder, use mod.
13:52:25 <ezyang> jmcarthur: Yup. 
13:52:30 <jmcarthur> ezyang: that forms a monad with Maybe-like semantics, so i think your type does too
13:52:38 <monoidal> > (-1 `mod` 3, 1 `rem` 3) -- Nibble
13:52:39 <lambdabot>   (-1,1)
13:52:41 <jmcarthur> ezyang: you might be able to see if there is an Either MonadPlus as well, but i don't know
13:52:49 <ezyang> So I guess maybe I should copy the "true" Either monad's typeclasses 
13:52:50 <monoidal> > (-1 `mod` 3, -1 `rem` 3) -- Nibble *
13:52:51 <lambdabot>   (-1,-1)
13:53:04 <monoidal> > ((-1) `mod` 3, (-1) `rem` 3) -- Nibble *
13:53:05 <lambdabot>   (2,-1)
13:53:18 <hpc> > (mod &&& rem) -1 3
13:53:19 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (b -> b, b -> b))
13:53:19 <lambdabot>    arising ...
13:53:22 <jmcarthur> ezyang: normally i would suggest newtype with generalized newtype deriving here, but base's either instances are stupid
13:53:57 <Axman6> :t liftM2 (,) mod rem
13:53:58 <lambdabot> forall a. (Integral a) => a -> (a -> a, a -> a)
13:54:25 <ezyang> jmcarthur: Yeah. Do you know of a package that defines non-silly instances for something ismorphic to Either a? 
13:54:36 <jmcarthur> not off the top of my head :(
13:54:52 <jmcarthur> aside from my alt-stdlib abandonware
13:55:05 <jmcarthur> which is completely incompatible with base
13:55:11 <dcoutts_> Baughn: any luck? there's a couple tickets on the hackage trac about downloads and proxies, you might see if anything looks familiar.
13:55:19 <jmcarthur> and, well, abandonware :)
13:55:27 <copumpkin> lol
13:55:32 <copumpkin> you abandoned it!?
13:55:33 <copumpkin> aww
13:55:42 <Nibble> I really need some simple program to look at, so I get what all these concepts are used for
13:55:46 <Nibble> any suggestions?
13:55:47 <jmcarthur> copumpkin: the code is still up and i still intend to *someday* make a few libraries out of it
13:56:10 <jmcarthur> copumpkin: but my goals of making something that can substitute for base have been dropped
13:56:21 <Baughn> dcoutts_: Downloading wireshark on a 1kB/s connection. Call me again in an hour.
13:56:21 <jmcarthur> and i'm not actively working on it
13:56:45 <copumpkin> ah
13:57:21 <napping> Baughn: is there some way to save the stream before it reaches the decompressor?
13:57:24 <jmcarthur> and by "make a few libraries out of it" i mean "use it as an idea bank" rather than "extract code from it"
13:57:41 <Baughn> napping: That's what wireshark is for. ;)
13:57:56 <napping> how about using something you already have?
13:58:08 <napping> even a tracing function with unsafePerformIO?
13:58:27 <Nibble> this code, data Peer = Peer SockAddr
13:58:35 <Baughn> ..nah. I've /got/ an hour.
13:59:02 <Baughn> Nibble: Hm. I'd newtype it.
13:59:04 <napping> I wonder if it might be getting truncated somewhere in the code anyway
13:59:09 <Nibble> I was told yesterday that the same type constructor
13:59:24 <Nibble> oh, let me rephrase that
13:59:49 <Nibble> I was told that using the same Type constructor name as the Type name was usually only done when there is only one Type constructor
13:59:58 <jmcarthur> i especially like the Arrow stuff i put in alt-stdlib (which is to say i replaced it with some generalized bifunctor classes), so that might be the first thing i pull out of it
14:00:24 <napping> Nibble: if you have one constructor of one argument, a newtype is almost exactly the same
14:00:46 <napping> but it lets you borrow existing instances with "deriving", and it's a bit more efficient too
14:01:10 <Baughn> It also loses you one possible (bottom) value, which is usually fine
14:01:10 <jmcarthur> using a newtype asserts an isomorphism between your new type and its implementation
14:01:29 <jmcarthur> using data simply says "i have a type and here's its implementation"
14:01:56 <Baughn> Well, it says at least "I have a type". ;)
14:02:00 <napping> what a mix of styles
14:02:02 <Nibble> I am not sure I get this with type yet.
14:02:05 <jmcarthur> heh, with EmptyDataDecls, sure
14:02:11 <napping> newtype says "I was a new type just like this old one"
14:02:26 <jmcarthur> s/was/want/?
14:02:30 <napping> yes
14:02:32 <Nibble> can Types have arguments?
14:02:37 <jmcarthur> yes
14:02:46 <napping> even newtypes
14:02:47 <Baughn> No?
14:02:55 <EvanR-work> higher kinded types right
14:03:13 <jmcarthur> Baughn: oh, pendanticaly, no :P
14:03:17 <Nibble> what is higher kind types
14:03:21 <Veinor> what do you mean 'arguments'?
14:03:26 <Baughn> I'm never quite sure, is * -> * really a type?
14:03:30 <monoidal> it's a kind
14:03:34 <Nibble> Veinor: well, parameters
14:03:35 <Baughn> Nibble: Maybe, Monad, List, etc.
14:03:35 <Nibble> input
14:03:36 <napping> Baughn: that's a kind.
14:03:45 <Baughn> napping: ..thank you.
14:03:47 <napping> colloquially, a "type" is anything that *has* a kind
14:03:49 <Itkovian> Given a [String], each String representing some output, that may or may not be present, and I need to get some of the numbers that are on those lines -- each line has data in a different spot -- what would be the method of choice to get that data? 
14:03:51 <jmcarthur> * -> * is the kind of a type constructor, which i guess some could say is not a type
14:03:54 <Baughn> I meant "types of kind not *"
14:03:57 <Veinor> Nibble: You mean like a type for vectors that's parameterized on the length of the vector?
14:04:04 <Baughn> Hm, though I suppose I just answered myself. :P
14:04:17 <Itkovian> Essentially, it's the criterion output, i.e., benchmark name, sample count, mean, stdev, etc.
14:04:22 <Nibble> Veinor: not sure
14:04:33 <jmcarthur> Baughn: is something of type (a -> b) a value? :)
14:05:07 <Baughn> jmcarthur: *poke Java* *poke poke*
14:05:09 <Nibble> http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source/StackSet.hs
14:05:13 <Nibble> like that first code
14:05:53 <napping> I think only types of kind "*" contain values
14:06:07 <Baughn> That much iss certainly true.
14:06:44 <monoidal> @djinn ((a -> Bool) -> Bool) -> ((b -> Bool) -> Bool) -> ((a,b) -> Bool) -> Bool
14:06:44 <Baughn> Only types of kind * can go into the final program compilation..
14:06:44 <lambdabot> f _ _ _ = False
14:06:58 <Nibble> I can't take this much abstraction, I need some code examples to understand it :(
14:07:09 <jmcarthur> Nibble: what are you learning from?
14:07:17 * hackagebot heist 0.2.3 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.2.3 (DougBeardsley)
14:07:31 <Nibble> jmcarthur: learnyouahaskell,there are plenty of examples but it is not covering everything
14:07:37 <jmcarthur> ah
14:07:56 <copumpkin> monoidal: nice
14:07:59 <napping> well, one nice higher-kinded example is data Fix f = In (f (Fix f))
14:08:10 <jmcarthur> Nibble: well, you can feel free to suppliment that with realworldhaskell. i wouldn't skip too far ahead though. some things can be left unexplained until you need to understand it
14:08:22 <monoidal> copumpkin: ?
14:08:24 <napping> also monad transformers, as one of the type parameters is the base monad (which will have kind *->*)
14:08:28 <copumpkin> monoidal: that djinn :P
14:08:33 <monoidal> ah :)
14:08:36 <Nibble> I guess I am back to reading
14:08:44 <Veinor> yeah, I can't figure out how to construct a value of that type either
14:08:54 <copumpkin> Veinor: really? :P
14:08:56 <monoidal> i was trying to show products of searchable sets are searchable
14:09:12 <napping> Nibble: have you looked at the Report at all?
14:09:35 <jmcarthur> @djinn ((a -> Bool) -> Bool) -> ((b -> Bool) -> Bool) -> (a -> b -> Bool) -> Bool
14:09:35 <lambdabot> f _ _ _ = False
14:09:38 <napping> I think some things are more complicated in specific cases than they are in general, even if the general case is pretty abstract
14:09:39 <Nibble> napping: report of what?
14:09:49 <kmc> @where report
14:09:50 <lambdabot> http://www.haskell.org/onlinereport/
14:10:04 <napping> the language standard, at least for Haskell 98
14:10:07 <jmcarthur> oh, it doesn't know how to combine the resulting bools
14:10:18 * hackagebot uu-parsinglib 2.4.4 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.4.4 (DoaitseSwierstra)
14:10:18 <jmcarthur> @djinn ((a -> Bool) -> Bool) -> ((b -> Bool) -> Bool) -> (a -> b -> Bool) -> (Bool -> Bool -> Bool) -> Bool
14:10:19 <lambdabot> f _ _ _ a = a False False
14:10:26 <Nibble> napping: I have came across it during my searches
14:10:27 <jmcarthur> ?
14:10:38 <jmcarthur> bah
14:10:52 <napping> jmcarthur: what did you expect?
14:11:12 <copumpkin> it's supposed to try to use all its parameters, I thought
14:11:13 <napping> in particular, how do you propose to make an (a -> Bool) or a (b -> Bool) from that (a -> b -> Bool)?
14:11:19 <copumpkin> but I guess it doesn't have a way to do that
14:11:53 <napping> @djinn ((a -> Bool) -> Bool) -> ((b -> Bool) -> Bool) -> (a  -> b -> Bool) -> (Bool -> Bool -> Bool) -> a -> b -> Bool
14:11:53 <jmcarthur> napping: oh i was just using monoidal's attempt as a baseline. didn't realize it actually didn't make sense :P
14:11:54 <lambdabot> f _ _ a b c =
14:11:54 <lambdabot>     case b False False of
14:11:54 <lambdabot>     False -> a c
14:11:54 <lambdabot>     True -> case b False True of
14:11:54 <lambdabot>             False -> a c
14:11:56 <lambdabot>             True -> case b True False of
14:11:58 <lambdabot>                     False -> a c
14:12:00 <lambdabot>                     True -> case b True True of
14:12:02 <lambdabot>                             False -> a c
14:12:04 <lambdabot>                             True -> \ d ->
14:12:05 <copumpkin> oh god
14:12:06 <lambdabot>                                     case a c d of
14:12:08 <lambdabot>                                     False -> True
14:12:08 <jmcarthur> oh god
14:12:10 <lambdabot> Plugin `djinn' failed with: thread killed
14:12:10 <jmcarthur> lol
14:12:14 <Heffalump> :-)
14:12:21 <jmcarthur> copumpkin: jinx!
14:12:23 <monoidal>  All the programs discussed here are correctly guessed by Djinn, just from knowledge of their types, except the binary and infinite product algorithms. 
14:12:23 <copumpkin> :P
14:12:36 <Heffalump> someone make Bool a monad already
14:12:44 <jmcarthur> a... monad?
14:12:50 <jmcarthur> you mean a monoid?
14:12:51 <copumpkin> Bool a
14:13:08 <Veinor> Heffalump: yes, but how?
14:13:09 <copumpkin> Bool :: * -> *
14:13:10 <jmcarthur> Any and All are monoids :)
14:13:14 <hpc> Bool the typeclass is yuck
14:13:32 <jmcarthur> what Bool typeclass?
14:13:35 <hpc> or Bool the parameterized type
14:13:40 <hpc> the idea of it
14:13:41 <monoidal> Bool meant as Boolean algebra/lattice?
14:13:41 <jmcarthur> ah
14:14:25 <hpc> if you really want perly booleans, use \x -> x == mzero
14:14:33 <c_wraith> gah.  I just edited what I thought was pure code, and am consisently segfaulting when I wasn't before. <_<
14:14:36 <Nibble> haskell does overloading by using classes?
14:14:37 <hpc> er, (mzero ==)
14:14:44 <monoidal> Nibble: in a sense, yes
14:14:50 <Nibble> And is classes there to make functions act on types in a specific way?
14:15:07 <Veinor> I've always wondered why !! isn't defined on a typeclass
14:15:10 <hpc> classes are like java interfaces, sorta
14:15:12 <Veinor> it'd make bytestring code nicer.
14:15:13 <monoidal> Nibble: but, Haskell's 'classes' are not like OOP classes, rather like interfaces
14:15:16 <EvanR-work> c_wraith: search for unsafePerformIO ;)
14:15:22 <Nibble> monoidal: I do not know what interfaces are
14:15:30 <monoidal> concept in OOP
14:15:31 <Nibble> well, I do, but not java ones
14:15:49 <EvanR-work> abstract class
14:15:57 <Nibble> interfaces defines what functions the implementers of it should have 
14:16:00 <Nibble> right?
14:16:07 <Veinor> it's like, an interface says 'if you want to implement me, you need to define these functions'
14:16:08 <monoidal> Nibble: yes
14:16:10 <hpc> yes
14:16:15 <Axman6> Nibble: in java, they're a way of saying, objects of this class implement the methods defined in this class
14:16:18 <EvanR-work> give or take region beliefs about how an abstract class differs from inteface
14:16:25 <Veinor> haskell does that but lets you write default implementations
14:16:26 <napping> Nibble: the important bit is different types implementing an interface are otherwise unrelated
14:16:27 <EvanR-work> regional*
14:16:47 <Nibble> monoidal: I do not want to ask too much here, but could you provide an example of how this is used?
14:16:49 <hpc> an abstract class is probably closer to a typeclass than an interface; you can provide a default definition for a function
14:17:09 <monoidal> Nibble: class Eq a where (==) :: a -> a -> Bool
14:17:17 <Veinor> right.
14:17:20 <copumpkin> @djinn Either a b -> (a -> c) -> (b -> c) -> c
14:17:20 <Axman6> @src Num
14:17:20 <lambdabot> f a b c =
14:17:20 <lambdabot>     case a of
14:17:20 <lambdabot>     Left d -> b d
14:17:20 <lambdabot>     Right e -> c e
14:17:21 <lambdabot> class  (Eq a, Show a) => Num a  where
14:17:22 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:17:24 <lambdabot>     negate, abs, signum     :: a -> a
14:17:26 <Nibble> monoidal: how would the implemention of that be?
14:17:26 <lambdabot>     fromInteger             :: Integer -> a
14:17:31 <Nibble> I mean definition
14:17:34 <copumpkin> @djinn ((a -> c) -> (b -> c) -> c) -> Either a b
14:17:35 <lambdabot> -- f cannot be realized.
14:17:36 <Veinor> Nibble: It's up to the type.
14:17:40 <Axman6> things that implement Num can use (+), (*) etc
14:17:42 <copumpkin> so sad
14:17:43 <c_wraith> gdb tells me the segfault is in a function named s4T6_info().
14:17:48 <Nibble> Veinor: like an Int
14:17:51 <monoidal> Nibble: instance Eq Bool where False == False = True; True == True = True; _ == _ = False
14:17:54 <c_wraith> Is that something ghc creates?
14:17:58 <copumpkin> c_wraith: yeah
14:18:08 <Nibble> monoidal: it's starting to make more sense now
14:18:10 <Veinor> Int does something.
14:18:20 <c_wraith> copumpkin: where can I find out about it?
14:18:28 <copumpkin> the dragons' lair
14:18:34 <c_wraith> ghc src?
14:18:36 <Nibble> that adheres to what the interface(or was it closer to typeclass? what is a typeclass?)
14:18:47 <copumpkin> a typeclass is a relation on types
14:18:53 <Nibble> on types?
14:19:08 <Nibble> you mean that it is a function acting on a type, or?
14:19:10 <napping> c_wraith: that's compiled from your code
14:19:23 <EvanR-work> a relation isnt necessarily a function
14:19:24 <copumpkin> Nibble: more like a set of types or tuples of types
14:19:31 <ddarius> Nibble: It is a relation (in the unary case, you can say a set).
14:19:37 <napping> c_wraith: it sure looks like you have a bad unsafeCoerce# somewhere
14:19:49 <c_wraith> Hmm.  Must be in a library.
14:20:06 <c_wraith> Sadly, there are 3 in use in the code I changed.
14:20:10 <napping> oh
14:20:21 <napping> why?
14:20:34 <c_wraith> hard to figure out which is at fault
14:20:42 <napping> what are they there for?
14:20:57 <napping> what kind of code needs unsafeCoerce#?
14:21:20 <copumpkin> Data.Dynamic uses it safely
14:21:29 <Veinor> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/GHC-Types.html#Int
14:21:33 <Veinor> Is this link broken for anyone else?
14:21:51 <c_wraith> There are three libs in use there..  utf8-string, JSONb, and HUnit.  I'd suspect utf8-string first.
14:23:06 <Nibble> copumpkin: so
14:23:21 <Nibble> to make an definition of the type class
14:23:26 <Nibble> I would make an instance of it?
14:23:36 <napping> Data.Dynamic, and program extraction from more strongly typed languages
14:23:49 <napping> c_wraith: seriously, what are those casts doing there?
14:24:16 <c_wraith> napping: I'm doing no casts myself.
14:24:42 <copumpkin> Nibble: well, you define a class by specifying what (if any) "witnesses" it must have
14:24:53 <c_wraith> wtf.
14:25:04 <copumpkin> Nibble: then you create instances for specific types and say how those witnesses behave for those types
14:25:04 <c_wraith> adding a debug putStrLn prevents the segfault
14:25:11 <copumpkin> nice!
14:25:36 <Veinor> c_wraith: load-bearing printf!
14:25:51 <napping> c_wraith: a badly cast value can hang around for a while, until you try to pattern match on it and find more constructors or less constructor arguments than you are expecting
14:26:23 <napping> You said earlier there were three calls to unsafeCoerce# in the code you changed
14:27:07 <Nibble> class Eq a where, what does the a mean?
14:27:20 <Nibble> is it an argument?
14:27:22 <c_wraith> napping, I meant there were three external libraries.
14:27:23 <pokoko222> how does one become the best computer scientist ever?
14:27:26 <Nibble> oh, forgive me. Parameter/input
14:27:46 <Nibble> pokoko222: you learn from these guys, and eat your math-books
14:27:55 <ClaudiusMaximus> wow, my program spends 70% of its allocs and 80% of its time converting from between ByteStrings and Doubles (each direction has about the same cost in my .prof)
14:27:56 <Veinor> Nibble: a is the type you're saying is an instance of Eq
14:28:15 <Nibble> Veinor: so, a :: Eq?
14:28:20 <Veinor> so 'if a is an instance of Eq, then it implements these things'
14:28:25 <copumpkin> it isn't a typing relation
14:28:25 <ClaudiusMaximus> i must be doing it wrong
14:28:28 <c_wraith> ok, printing an empty string there doesn't prevent the segfault, but printing the error message string does.  So clearly, it has to do with forcing the error message string.
14:28:33 <tommd> ClaudiusMaximus: Pulling values from bytestrings is really costly.  Particularly if you do byte reads with something like Binary.
14:28:35 <ddarius> ClaudiusMaximus: Are you storing in a binary format, or is essentially textual?
14:28:39 <copumpkin> Nibble: a can be an instance of many different classes
14:28:42 <copumpkin> or none at all
14:28:56 <ClaudiusMaximus> ddarius: it's text (.hp in, .svg out)
14:28:59 <c_wraith> Forcing the error message string involves the use of JSONb and utf8-string
14:29:10 <pokoko222> Nibble i eat math books as vegetables
14:29:16 <tommd> ClaudiusMaximus: pureMD5, which is where I first ran into this problem, could get a 2x speed up if it assumed alignment and used an unsafePerformIO + peek.
14:29:17 <ddarius> ClaudiusMaximus: Then, unless you are doing some heavy processing, that doesn't sound unreasonable.
14:29:25 <Nibble> Veinor: can't one define a variable to be a class?
14:29:29 <Nibble> type class. sorry
14:29:36 <tommd> ClaudiusMaximus: Oh, text, nevermind!
14:29:51 <c_wraith> I still suspect something inside of utf8-string
14:30:06 <c_wraith> I'm going to just go ahead and switch libraries and see if that helps.
14:30:07 <ClaudiusMaximus> tommd: hehe, thanks for replying, i may need binary IO at some point
14:30:28 <copumpkin> Nibble: for an idea, let's take (==) :: (Eq a) => a -> a -> Bool... do you see what that's trying to say? do you see how it's different from a -> a -> Bool and why the latter wouldn't work?
14:30:42 <Nibble> yes
14:31:01 <ClaudiusMaximus> ddarius: i suppose the processing isn't really heavy at all, or i just optimized it enough
14:31:10 <Nibble> because it says that it only works for types that derives Eq, the equality stuff
14:31:15 <copumpkin> so Eq a is basically a statement about a, which is polymorphic. But it restricts the range of types a can take on to those that have been made instances of Eq
14:31:35 <Nibble> a -> a -> Bool basically means two of the same type, evaluates to Bool
14:31:42 <Nibble> well, not since haskell is curried
14:31:42 <EvanR-work> is 2x speedup really that important
14:31:43 <Nibble> but wtf
14:31:47 <Nibble> wth*
14:31:57 <Nibble> EvanR-work: depends on how much time is spent on that code
14:32:03 <copumpkin> Nibble: a -> a -> Bool could be written, but would necessarily be trivial
14:32:07 <ddarius> ClaudiusMaximus: If you are really gung-ho about it, you can try pre-converting it to a binary format, reading that in and seeing how big a difference it makes.
14:32:19 <EvanR-work> thats almost the most trivial speedup covered in computer science class under 'constant factor is irrelevant' complexity classes
14:32:32 <copumpkin> Nibble: that is because the fully general a type variable provides no information to the function, so it can't assume anything
14:32:47 <Nibble> ok
14:32:50 <copumpkin> the parameters to (==) could be crazy functions or even empty types, for all the function knows
14:32:58 <EvanR-work> worse case scenario your 1s computation take 2s or your 100ns computation takes 200ns
14:33:12 <ddarius> I believe there are fourteen distinct functions of type forall a. a -> a -> Bool
14:33:22 <ClaudiusMaximus> ddarius: sounds like too much trouble to me, i think
14:33:33 <ddarius> ClaudiusMaximus: Probably unless you actually have a performance problem.
14:34:00 <monoidal> ddarius: [seq a] [seq b] [undefined/True/False]?
14:34:01 <Nibble> copumpkin: I understand that, since basically everything evaluates to numbers at some point or another
14:34:19 <copumpkin> I wouldn't think of it in those terms
14:34:27 <copumpkin> this is abstract math, not running on a real cpu
14:34:29 <ddarius> EvanR-work: Most compiler implementors, for example, would be thrilled with an optimization that gave a 50% reduction in time.
14:34:47 <EvanR-work> globally alright
14:34:51 <copumpkin> it's all about the knowledge you can acquire about values of a polymorphic type
14:34:57 <EvanR-work> but this is an md5sum
14:35:09 <Nibble> how do I find smallest Int in a list?
14:35:15 <monoidal> minimum
14:35:16 <EvanR-work> > min [1,2,3,4,5]
14:35:17 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
14:35:17 <lambdabot>    arising from a use ...
14:35:22 <Zao> @src minimum
14:35:23 <lambdabot> minimum [] = undefined
14:35:23 <lambdabot> minimum xs = foldl1 min xs
14:35:23 <copumpkin> if you have a function of [a] -> Int, even if you have full control over the definition of the function, you can do nothing to ever inspect the values of the list
14:35:24 <benmachine> :t foldr min
14:35:25 <lambdabot> forall a. (Ord a) => a -> [a] -> a
14:35:26 <lispy1> > foldr min [1 .. 5]
14:35:27 <copumpkin> Nibble: ^
14:35:28 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
14:35:28 <lambdabot>    arising from a us...
14:35:33 <EvanR-work> > let min = minimum in min [1,2,3,5]
14:35:34 <lambdabot>   1
14:35:38 <lispy1> > foldr1 min [1..5]
14:35:39 <lambdabot>   1
14:35:54 <ddarius> monoidal: There are four possibilities for strictness in the arguments times three possible return results plus undefined and \_ -> undefined and I think there is also \!_ -> undefined which would make 15.
14:35:58 <Nibble> how do I bind two numbers into a tuple?
14:36:00 <Nibble> zip?
14:36:07 <EvanR-work> > (1,2)
14:36:09 <lambdabot>   (1,2)
14:36:11 <copumpkin> > minimum [1,6,2,4,-5)
14:36:13 <lambdabot>   <no location info>: parse error on input `)'
14:36:14 <copumpkin> > minimum [1,6,2,4,-5]
14:36:15 <lambdabot>   -5
14:36:25 <copumpkin> :t minimum
14:36:26 <lambdabot> forall a. (Ord a) => [a] -> a
14:36:31 <copumpkin> it needs Ord, unsurprisingly
14:36:33 <Nibble> EvanR-work: so, x y > (x, y) ?
14:37:02 <EvanR-work> eh?
14:37:12 <IceDane> I was thinking about buying a book on math/computer science, and was wondering about discrete mathematics.. Does anyone know of any good, introductory material in this category? I know it isn't a haskell question, but I also know you guys are the guys to ask about this :P
14:37:14 <benmachine> ddarius: is there a difference between \_ -> undefined and \!_ -> undefined?
14:37:25 <EvanR-work> Nibble: (,) is a function to put two things in a tuple
14:37:31 <EvanR-work> > (,) 4 6
14:37:32 <lambdabot>   (4,6)
14:37:36 <EvanR-work> > (4,6)
14:37:37 <lambdabot>   (4,6)
14:37:41 <Nibble> EvanR-work: oh
14:37:44 <Nibble> I love haskell
14:37:45 <Nibble> lol
14:37:51 <ddarius> benmachine: I'm wondering about that.  I'm starting to think not, which removes four other solutions.
14:37:51 <Nibble> that's just amazing
14:38:02 <Nibble> in most languages, that is just syntax
14:38:02 <EvanR-work> its gimmicky ;)
14:38:06 <monoidal> ddarius: and between seq x undefined and undefined
14:38:08 <copumpkin> Nibble: it may seem weird, but even (->) is a function that takes two types and gives a type
14:38:24 <copumpkin> at least the type-level one
14:38:25 <EvanR-work> > (4,) 9
14:38:27 <lambdabot>   <no location info>: parse error on input `)'
14:38:29 <EvanR-work> cra
14:38:30 <EvanR-work> p
14:38:33 <copumpkin> :k (->)
14:38:34 <ddarius> monoidal: That's pretty much the same question.
14:38:34 <lambdabot> ?? -> ? -> *
14:38:44 <Nibble> copumpkin: I know that one, somone made a @t on it for me when I asked
14:38:51 <copumpkin> :k (->) Int -- is all functions with a domain of Int
14:38:52 <lambdabot> ? -> *
14:38:52 <lispy1> EvanR-work: IIRC, there is an extension for tuple slices
14:38:53 <copumpkin> ah ok :)
14:39:02 <copumpkin> yep
14:39:06 <copumpkin> as of 6.12
14:39:07 <lispy1> so that (4,) 9 == (4,9)
14:39:24 <monoidal> -XTupleSections
14:39:27 <EvanR-work> i suppose its not that different from ((,) 4) 9
14:39:38 <EvanR-work> > map ((,) 4) [1,2,3,4]
14:39:39 <lambdabot>   [(4,1),(4,2),(4,3),(4,4)]
14:39:48 <c_wraith> ok, not utf8-string.
14:40:06 <EvanR-work> too much syntactic sugar rots the brain
14:40:20 <ddarius> So there are at least 11 solutions.
14:40:21 <Nibble> class someClass a where
14:40:24 <DrSyzygy> EvanR-work: Not true!!!
14:40:28 <monoidal> ddarius: also there's lub (seq x ()) (seq y ()) if you consider lub to be safe
14:40:31 <Nibble> I get malformed head of type or class declaration
14:40:33 <EvanR-work> case in point
14:40:35 <Nibble> ideas?
14:40:45 <DrSyzygy> :t lub
14:40:47 <lambdabot> Not in scope: `lub'
14:40:54 <EvanR-work> :t lube
14:40:56 <lambdabot> Not in scope: `lube'
14:41:10 <monoidal> in this case lub is also known as unambv
14:41:52 <monoidal> * unamb. http://hackage.haskell.org/package/lub
14:42:09 <Nibble> nvm, I think I solved it
14:42:11 <monoidal> for example, (undefined, 1) `lub` (3, undefined) == (3,1)
14:42:25 <ddarius> monoidal: I don't believe that adds any solutions in this case.
14:42:29 <Nibble> instances works like types? 
14:42:52 <monoidal> ddarius: \x y -> seq (seq x () `lub` seq y ()) False
14:42:58 <johan__> This questions must have been asked over and over, but still: I'm looking for a tutorial to Haskell, and not to loose concentration I must be able to play around and see things happen, which would mean I/O. When I learned PHP, I could try over and over, step by step learning the language. So far, the Haskell tutorials I've come across mostly discusses datatypes and different sorts of syntatic sugar, but there's no exciting output or interactivity. Any sugges
14:43:00 <monoidal> ddarius: it's not expressible without lub
14:43:00 <Veinor> EvanR-work: I think that's in haskell'
14:43:27 <Nibble> how do you do comments in haskell?
14:43:31 <johan__> Nibble: --
14:43:38 <napping> johan__: you could start with ghci
14:43:39 <copumpkin> johan__: you got truncated at Any sugges
14:43:57 <Veinor> -- is the comment marker, yeah
14:43:59 <johan__> copumpkin: Ah, that was at the end, I was asking for suggestions :)
14:44:08 <EvanR-work> johan__: best way to learn is to do. write a game or something
14:44:09 <napping> If you've written any code in a module you can load it in ghci and run functions and things
14:44:28 <Nibble> guys, I have this instance
14:44:30 <Nibble> instance SomeClass SomeInstance where
14:44:34 <Nibble> this class
14:44:35 <Nibble> class SomeClass a where
14:44:43 <johan__> napping: I may have misunderstood, but ghci just lets me write, small, small snippets of code? I am not able to create multi-line functions(?)
14:44:44 <napping> or maybe pick something that has some IO, between interact and Read it's not too hard to make something basic and fragile
14:44:45 <Nibble> Not in scope: type constructor or class `SomeInstance'
14:44:45 <benmachine> johan__: I found tutorials frustrating because it took a while to achieve anything, but if you stick with it it will pay off
14:44:47 <ddarius> monoidal: Yeah, you're right.
14:44:53 <napping> johan__: you can load a file in ghci
14:44:57 <copumpkin> Nibble: you need to make a type callsed SomeInstance first
14:44:59 <ddarius> That would make it 13 solutions at least.
14:45:03 <napping> like (ghci Module.hs)
14:45:03 <copumpkin> well, "first" in haskell terms
14:45:06 <benmachine> johan__: you load a file in ghci, edit it with :edit and :reload
14:45:08 <napping> it should come back *Module>
14:45:10 <benmachine> or :e and :r
14:45:10 <Nibble> copumpkin: xD
14:45:25 <napping> and then everything defined or imported into that module will be in scope at the prompt
14:45:26 <johan__> EvanR-work: I'd gladly write a game, but I have trouble even grasping basic stuff such as all the a -> a -> a -> a expressions that keeps popping up :)
14:45:34 <napping> also, the prompt is mostly like the inside of a do binding
14:45:37 <Philippa> johan__: ghci is very much your friend for interactive work. Just sit there with ghci and a text editor and load/reload files as you go
14:45:41 <napping> so you can at least accumulate functions and things like
14:45:44 <EvanR-work> johan__: a function that takes three a and produces an a ;)
14:45:49 <napping> let myFun a b = blah
14:45:51 <Veinor> napping: yeah, IIRC the ghci prompt is basically inside an IO do-block
14:45:52 <applicative> johan__, one extremely simple kind of IO is to make a little pipe-able unix executable with "interact"
14:45:55 <napping> and then call it on later prompts
14:45:57 <applicative> @type interact
14:45:58 <lambdabot> (String -> String) -> IO ()
14:46:08 <johan__> EvanR-work: How can I know it doesn't take two a and produce two a?
14:46:15 <copumpkin> you can make surprisingly interactive programs with interact and careful forcin
14:46:23 <Philippa> johan__: because producing two a would be (a,a)
14:46:30 <EvanR-work> johan__: well, it *does* take two a and produce a (a -> a)
14:46:37 <napping> I wouldn't go too far from working with datatypes, if you want to see interesting stuff
14:46:39 <EvanR-work> a new function
14:46:41 <Veinor> or one a and produce an (a -> a -> a)
14:46:46 <ddarius> Without seq there would be only 3 solutions and only 2 without bottom.
14:46:46 <napping> IO is fairly boring
14:46:51 <napping> well, I guess you could mess around with threads
14:46:55 <monoidal> johan__: function arrow is right associative: a -> a -> a -> a means a -> (a -> (a -> a))
14:47:05 <copumpkin> napping: I agree
14:47:13 <copumpkin> you won't learn anything much distinctive about haskell by playing with IO
14:47:22 <copumpkin> if you're just starting out
14:47:30 <EvanR-work> forkIO, MVar ...
14:47:30 <Nibble> johan__: look upp curried functions
14:47:31 <copumpkin> it'll feel like clunky syntax for stuff you're used to
14:47:37 <Nibble> and make sure you understand them
14:47:45 <napping> Probably the most impressive easy stuff uses lazy infinite trees
14:47:59 <napping> I think those were the things that held my interest
14:48:04 <johan__> Veinor, monoidal , Philippa: You guys are confusing me. "a -> a -> a-> a" does that *just* take three "a" and produce one "a", or can it do all combinations, from taking 0 a and produce 4 a, to taking 4 a and produce 0 a?
14:48:12 <ClaudiusMaximus> ddarius: well, i found out i don't have a performance problem at all: http://pastebin.ca/1910437
14:48:15 <Philippa> johan__: the former
14:48:16 <EvanR-work> johan__: yes
14:48:27 <Philippa> EvanR-work: no, read the question again
14:48:30 <EvanR-work> gah
14:48:31 <napping> johan__: once you add the parentheses (a -> (a -> (a -> a)))
14:48:32 <monoidal> johan__: it takes 3 a's and gives one a. No other possibility
14:48:37 <copumpkin> :t curry
14:48:38 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:48:45 <napping> you see that three of the "a" are on the left of an arrow, and only one is on the right
14:49:04 <EvanR-work> :t (,,)
14:49:05 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
14:49:08 <EvanR-work> :t (,,) 4
14:49:09 <lambdabot> forall t b c. (Num t) => b -> c -> (t, b, c)
14:49:11 <EvanR-work> :t (,,) 4 5
14:49:13 <lambdabot> forall t t1 c. (Num t, Num t1) => c -> (t, t1, c)
14:49:19 <benmachine> johan__: if you give it less than three a's, you get a function
14:49:20 <EvanR-work> cool that is complex ;)
14:49:22 <johan__> napping: What is it called, is it a function declaration, a type declaration, a function head or...?
14:49:29 <benmachine> a function that wants the rest of the a's
14:49:36 <napping> a -> a -> a -> a is a type
14:49:40 <napping> rather than any of those things
14:49:45 <Veinor> if I say f :: a -> a -> a -> a, that's a type declaration
14:49:50 <Veinor> I'm declaring that f has that type
14:50:01 <c_wraith> ok...  the segfault is in bytestring -> string conversion, in both utf8-string and utf8-light libs.
14:50:05 <Philippa> I'd call that an annotation, myself. Type declarations are what type, datatype etc do
14:50:07 <c_wraith> I *really* hope they use the same code.
14:50:09 <ddarius> ClaudiusMaximus: That only demonstrates that you (arguably) have no more of a performance problem than hp2ps
14:50:14 <Veinor> type annotation, then
14:50:15 <johan__> Allright, and a type is not a function, it's rather a datacontainer? Like a framework of what data to hold?
14:50:22 <napping> Philippa: signature, perhaps?
14:50:24 <applicative> is there an interesting funtion with polymorphic type a -> a -> a -> a ?
14:50:30 <Philippa> a type is something that describes a value
14:50:37 <copumpkin> ∀ {a b c} {A : Set a} {B : A → Set b} {C : Σ A B → Set c} → ((x : A) → (y : B x) → C (x , y)) → ((p : Σ A B) → C p)
14:50:43 <applicative> first x y z = x
14:50:47 <applicative> ha
14:50:48 <Philippa> applicative: depends what you think interesting means, but probably not
14:50:49 <napping> Philippa: to distinguish top level from expression or binding annotations
14:50:50 <ClaudiusMaximus> ddarius: right :)
14:50:51 <copumpkin> special points for anyone who recognizes that
14:51:01 <Philippa> napping: it /is/ a binding annotation, though
14:51:10 <napping> hmm, well, I guess so
14:51:17 <Axman6> johan__: it's a specification of what types the function can accept and produce
14:51:20 <monoidal> johan__: once you know filters, maps and folds you can try this: http://www.cse.chalmers.se/~wouter/Teaching/Asteroids.zip
14:51:23 <c_wraith> wow.  utf8-light is all one file
14:51:38 <johan__> Philippa: I can have multiple values of a type, common types are int, char and so, but I can construct my own?
14:51:44 <monoidal> johan__: it's a game, but to play you have to fill out the game logic
14:51:53 <EvanR-work> > (,,)
14:51:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> c -> (a, b, c))
14:51:55 <lambdabot>    arisi...
14:51:57 <Axman6> johan__: that's one of the best things about haskell :)
14:52:02 <applicative> Johan_ can you construct you own?  ....
14:52:04 <napping> johan__: yeah, have you seen "data" declarations?
14:52:07 <Philippa> johan__: yes, you can use data to introduce new types/type constructors, and you can combine constructors to build types
14:52:10 <applicative> you've come to the right place....
14:52:15 <napping> johan__: that's one thing that doesn't work at the ghci prompt, so you have to put them in a file
14:52:20 <copumpkin> nobody recognizes it? :P
14:52:27 <Veinor> applicative: you can prove that the only functions of type a -> a -> a -> a are the obvious ones
14:52:28 <napping> copumpkin: looks like some agda
14:52:30 <johan__> monoidal: Great! The reason to why I'm here is actualy that I'll start learning Haskell at Chalmers, which had the game :)
14:52:34 <c_wraith> utf8-light is has a bunch of ByteString unsafeIndex operations.
14:52:35 <copumpkin> napping: I mean what the function actually is :P
14:52:35 <Axman6> johan__: you can create a binary tree that can hold values of any type like this: data Tree a = Leaf | Node a (Tree a) (Tree a)
14:52:39 <copumpkin> it's a fairly well known one
14:52:40 * applicative is still parsing, he needs an agda tutorial again
14:52:40 <napping> wait, isn't that a fully dependent curry?
14:52:40 <c_wraith> that's a likely candidate for segfaulting
14:52:46 <copumpkin> napping: yeah :P
14:52:47 <copumpkin> good job
14:53:06 <triyo> I am trying to get my head around the MonadPlus. In a nutshell, whats the purpose of this type class?
14:53:07 <johan__> Yeah, the btree-thing have I stumbled across :)
14:53:21 <ddarius> copumpkin: I ignored your heretical Agda-speak.
14:53:35 <copumpkin> lol
14:53:42 <hpc> :t (++)
14:53:43 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:53:47 * copumpkin wants some steak-burning
14:53:48 <johan__> It strikes me how nice guys are here, normally (#php, #c, #javascript...) they're just rude to newcomers :)
14:53:50 <napping> hmm, I think it needs a bit nicer telescope notation, or something
14:53:56 <hpc> @src MonadPlus
14:53:56 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:54:03 <copumpkin> johan__: I'll be rude to you if you feel more at home that way
14:54:03 <napping> triyo: http://okmij.org/ftp/Computation/monads.html#fair-bt-stream
14:54:17 <napping> triyo: usually for things that have alternatives like that. Also in parsers
14:54:18 <copumpkin> johan__: otherwise, you can ask lambdabot for @src of unknown functions if you want rudeness
14:54:25 <EvanR-work> johan__: thats because they are little bitches
14:54:33 <ddarius> @src tombOfTheUnknownFunction
14:54:34 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:54:38 <johan__> @src map
14:54:38 <lambdabot> map _ []     = []
14:54:39 <lambdabot> map f (x:xs) = f x : map f xs
14:54:43 <Axman6> johan__: well, if you had to write code in php, C or JS, you'd be pretty pissed off and rude too right? ;)
14:54:47 <fryguybob> @src copumpkin
14:54:48 <copumpkin> @src mapp
14:54:48 <lambdabot> Source not found. I feel much better now.
14:54:48 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:55:04 <Philippa> EvanR: oi. Less misogynistic language, thanks
14:55:11 <EvanR-work> Axman6: stfu!
14:55:15 * EvanR-work goes back to php
14:55:22 <ezyang> Is there a well known typeclass like monoid except w/o mappend? 
14:55:28 <Veinor> hpc: wait, caleskell uses (++) for mappend?
14:55:28 <johan__> Axman6: Actually, I'm kinda comfortable in PHP, but the no-side-effects-think seems to be a good idea, although I've never thought about it specificly
14:55:33 <ezyang> like, Zero or something? 
14:55:33 <napping> um, what would the point of that be?
14:55:36 <copumpkin> ezyang: o.O
14:55:36 <napping> "pointed"?
14:55:42 <benmachine> not pointed
14:55:43 <monoidal> pointed is for a -> f a
14:55:45 <benmachine> that's a -> f a
14:55:47 <napping> well, syb-with-class has an "occupied" thing
14:55:48 <hpc> @hoogle MonadPlus
14:55:48 <lambdabot> Control.Monad class Monad m => MonadPlus m
14:55:50 <copumpkin> ezyang: how can it even have an identity if it has no operation?
14:55:57 <EvanR-work> johan__: the nice thing about haskell is that you can take these sanity preserving principles back to the real world with you, even into php land
14:55:59 <triyo> napping: oh I see. This is similar to Alternative type class right?
14:55:59 <monoidal> but mathematically, "pointed set" *is* a set with distinguished element
14:56:05 <Nibble> EvanR-work: seriously? I can't say that I am a pro-programmer because I do not make a living on it, and besides I am only 14 years old. But I can say that it sucks without being afraid of someone proving otherwise.
14:56:09 <benmachine> copumpkin: it just has a "thing"
14:56:19 <ezyang> copumpkin: Identity doesn't really make sense, I suppose 
14:56:22 <napping> triyo: pretty much, just for full Monads
14:56:30 <ezyang> All I need is a distinguished element. 
14:56:31 <applicative> surely it's uncurry?
14:56:39 <applicative> @type uncurry
14:56:40 <napping> ezyang: I don't think there's a standard class for that, no
14:56:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:56:51 <EvanR-work> Nibble: note sure what youre referring to
14:56:53 <napping> ezyang: syb-with-class has one for class witnesses
14:56:54 <ezyang> Am I bad person if I use Monoid, and don't use mappend? 
14:56:55 <copumpkin> applicative: yeah, you're right
14:57:01 <ddarius> ezyang: Yes.
14:57:01 <copumpkin> ezyang: yesh!
14:57:05 <monoidal> ezyang: Yes
14:57:10 <ezyang> Ok :-) 
14:57:18 <napping> like, you make a data type "ShowDict a", and an instance of (Occupied (ShowDict Int)), etc.
14:57:23 <copumpkin> class I'mSpecial a where special :: a
14:57:27 <ddarius> ezyang: I think there might be a library that defines a "Default" class, but it isn't "standard."
14:57:29 <napping> .. it's not actually called Occupied, but I forget
14:57:38 <copumpkin> I think it's mauke's
14:57:41 <Nibble> EvanR-work:23:54 < EvanR-work> Axman6: stfu!
14:57:41 <triyo> napping: what do you mean full Monads? 
14:57:41 <Nibble> 23:54  * EvanR-work goes back to php
14:57:41 <copumpkin> which means it must be good
14:57:51 <napping> triyo: well, an applicative isn't necessarily a monad
14:58:06 <napping> you can't do the equivalent of (m >>= \x -> if pred x then m2 else m3)
14:58:08 <triyo> napping: right, I see what you mean
14:58:09 <EvanR-work> Nibble: that was a joke, which referrenced a previous message
14:58:12 <ezyang> The measure I'm applying is approx something like MaybeT or MonadCatchIO 
14:58:25 <ezyang> if there's nothing standard, I guess I can punt. 
14:58:33 <c_wraith> By the way, MaybeT and MonadCatchIO don't work together. :)
14:58:34 <Nibble> EvanR-work: ok.
14:58:36 <napping> triyo: the classes really ought to be related a bit more, but Monad is older and it's hard to wedge in superclasses
14:58:48 <ezyang> erm, MonadCatchIO-mtl 
14:58:57 <ezyang> unless you mean something different :^) 
14:59:05 <c_wraith> You can't write an instance of MonadCatchIO such that MonadCatchIO's implementation of finally works correctly in MaybeT
14:59:13 <ezyang> Huh. 
14:59:32 <ezyang> Is this proven to be the case? 
15:00:17 <c_wraith> Yes.  bracket would have to be a typeclass method.
15:00:40 <c_wraith> You can't implement bracket in terms of catch and >>= along when your >>= can alter control flow
15:00:47 <c_wraith> err, *alone
15:01:03 <EvanR-work> seems theres a lot of error handling frameworks for haskell
15:01:15 <EvanR-work> great thing about standards ;)
15:01:26 <johan__> I'm in /home/johan/dtek/Asteroids, trying to compile Main.hs with ghc and the compiler refuses, it cannot load the interface Graphics.UI.WX. I guess I should find it in the Hackage package list and somehow donwload and extract a .hs file, however, I cannot find the Graphics.UI.WX ath the package list, what to do?
15:01:43 <monoidal> johan__: cabal install wx
15:02:15 <ezyang> Hmm. Is there a typeclass for additive operation with no identity? 
15:02:27 <monoidal> ezyang: semigroup?
15:02:37 <ezyang> Plausible. 
15:03:03 <napping> johan__: that's a module name, you can find packages containing it with the search
15:03:09 <copumpkin> it's not anywhere standard though
15:03:11 <ezyang> Though the algebra dependency would be kind of funny :^) 
15:03:29 <Philippa> EvanR-work: there's a reason for it. Hell, I proposed one the other day (and coded it up, but haven't released it)
15:03:40 <Veinor> GHC uses git for development now, right?
15:03:42 <Philippa> EvanR-work: they do different things and are useful in different circumstances
15:03:45 <copumpkin> Veinor: nope
15:03:51 <copumpkin> Veinor: they were planning to move but changed their minds
15:03:55 <Veinor> I could've sworn it did.
15:03:58 <EvanR-work> Philippa: so how do you decide what to do in new code?
15:03:59 <Axman6> darcs got good
15:04:02 <copumpkin> not unless it changed in the last month
15:04:10 <Veinor> aw
15:04:15 <Veinor> I don't want to have to learn another vcs :(
15:04:41 <Veinor> (in the rather unlikely event I decide to hack on GHC)
15:04:42 <johan__> So I got Cabal up and running, updated, found the package and now: "wx-0.12.1.6 depends on wxcore-0.12.1.6 which failed to install" ExitFailure 1
15:04:44 <Philippa> EvanR-work: by looking at your needs
15:04:46 <johan__> Any ideas?
15:04:57 <Veinor> johan__: try cabal install wxcore
15:05:01 <Veinor> and see why it fails to install
15:05:06 <napping> you probably don't have the C package installed
15:05:11 <EvanR-work> Philippa: usually i want to catch errors in IO and in whatever C library i happen to be using
15:05:13 <napping> like, the actually wx library
15:05:14 <msieradzki> error is somewhere above I guess
15:05:21 <EvanR-work> and throw my own errors in IO
15:05:29 <Philippa> the obvious questions are ones like "is IO involved?", "how many errors do I need to handle?" "do I need to care about catching myself, or can I leave it free for the user to pick?"
15:05:32 <dcoutts_> johan__: and last time I looked, wx had to be installed globally
15:05:53 <Philippa> EvanR-work: then you might want to use the IO-specific framework
15:05:56 <napping> johan__: apt-get install libwxgtk2.8-dev, maybe
15:06:03 <johan__> dcoutts_: I cannot tell the difference between locally and glablly, I ran the cabal install wx as root
15:06:05 <EvanR-work> Philippa: yeah but theres a different one for each set of bindings
15:06:15 <napping> that should end up global
15:06:16 <EvanR-work> in addition to the 'standard' IOException thing
15:06:46 <dcoutts_> johan__: if you run it as root, make sure you use the --global flag or you're in danger of installing it per-user for the root user.
15:06:47 <ezyang> Is there any reason why you would want to use the MonadFix instance of Either? 
15:06:55 <ezyang> I can't really think of a good reason. 
15:07:09 <Philippa> EvanR-work: can't comment on that so much, I don't do a lot of IO-bound work so I'm not running into that problem. I'd imagine you want to pick one as your 'unifying' framework for whenever errors escape outside the binding's 'scope', or at least have identifiable systems that use specific setups
15:07:40 <Philippa> systems that just have return types with errors in them are actually fairly easy to unify with the exception mechanism
15:07:55 <Nibble> http://beta.yapaste.com/fU
15:07:58 <Philippa> you're just integrating the binding's error /reporting/ with your error /handling/
15:08:04 <Nibble>     Not in scope: type constructor or class `ValueConstructor'
15:08:06 <EvanR-work> Philippa: if i werent doing IO, i dont see a need for exceptions at all. any 'error' or 'undefines' are basically bugs
15:08:14 <Nibble> Any ideas on what is not working?
15:08:15 <EvanR-work> and Maybe
15:08:26 <EvanR-work> pure code doesnt need magic exceptions
15:08:33 <Philippa> EvanR-work: pure code can have a use for exception-like constructs too
15:08:37 <EvanR-work> bah
15:08:42 <EvanR-work> complexity
15:08:53 <Philippa> you use them to reduce it :-)
15:09:11 <EvanR-work> sounds like reducing complexity with 'goto' to me
15:09:32 <Phyx-> goto? :P
15:09:33 <Phyx-> :O
15:09:36 <Philippa> you realise that, for example, <|> in parsec effectively 'catches' parse errors?
15:10:06 <Philippa> or you might be catching object-language source errors in an interpreter
15:10:32 <EvanR-work> Writer ?
15:10:46 <Philippa> Writer /logs/, it doesn't back you out of a big stack of calls
15:10:59 <EvanR-work> Maybe
15:11:14 <Philippa> Maybe's monad instance effectively gives you exceptions, yes
15:11:26 <EvanR-work> WriterT Maybe ;)
15:11:37 <arw> exceptions don't reduce complexity, they just pretend to. the call-stack-smashing of the average exception mechanism is far worse than handling a few more Maybes.
15:11:40 <Philippa> bad idea, you probably want Maybe(T) Writer
15:11:43 <EvanR-work> bah @ imperative programming
15:11:48 <Axman6> Nibble: you need data, not type, and the instance is completely wrong, should be of the form (ValueConstructor x1 y2) <> (ValueConstructor x2 y2) = ...
15:12:04 <Philippa> arw: I'm talking about the semantics, implement it however the hell you want
15:12:37 <arw> Philippa: the semantics is no better. "jump to wherever the hell the exception is caught" is ugly.
15:12:59 <Philippa> arw: sometimes that's pretty much the semantics the problem domain asks for
15:13:04 <Nibble> Axman6: oh ok
15:13:35 <Philippa> admittedly it's comparatively rare that I actually have catches within a monad with exception-like circumstances, usually the 'catch' I care about is where I make the run call. But mileage varies
15:14:16 <c_wraith> ok, I was blaming the wrong library.
15:14:17 <Nibble> Axman6: so, on the code, I would do what? (Int [x]) <> (Int [y])
15:14:37 <Axman6> no, you'd need exactly what i wrote
15:14:47 <Axman6> (ValueConstructor x1 y2) <> (ValueConstructor x2 y2) = ...
15:14:58 <arw> Philippa: thats not what is asked for, thats what people interpret when they only know exceptions
15:15:34 <Philippa> arw: you can't say that without knowing /all/ problem domains
15:16:11 <Philippa> and manually piping it about with Maybes to the exact same effect is no better
15:16:17 <arw> Philippa: yes i can. the necessity of any language construct is up to the user.
15:16:54 <Nibble> Axman6: oh... I didn't remember I had ValueConstructor defined(I defined it myself.. just didn't remember) ultra fail
15:17:26 <arw> Philippa: in intercal, everybody considers COMEFROM to be necessary and what the problem domain asks for. that doesn't mean, that anybody else would even think of it.
15:17:30 <Philippa> arw: who said anything about necessity?
15:17:38 <Nibble> Axman6: this? (ValueConstructor [x]) <> (ValueConstructor [y])
15:17:51 <arw> Philippa: "the problem domain asks for it" == "its necessary"
15:18:04 <Philippa> no, it doesn't. It just means "it is the direct encoding of the problem"
15:18:06 <Axman6> doesn't ValueConstructor have two lists in it?
15:18:25 <arw> Philippa: well. the direct encoding of any loop is GOTO.
15:18:27 <benmachine> does SomeClass even use its parameter?
15:18:37 <napping> arw: or perhaps map
15:18:38 <johan__> @src starts
15:18:38 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:18:51 <micahjohnston> arw: the direct encoding of any loop is not goto
15:19:03 <micahjohnston> arw: what about in a processor where there is no jmp, and control flow is achieved differently
15:19:03 <arw> napping: exactly my point. that depends on the person interpreting the problem.
15:19:08 <Axman6> benmachine: hmm, classes which don't even use their parameters, that could be useful...
15:19:25 <Philippa> arw: no, not unless your problem domain already specifies imperative programming and is written in terms of low-level imperative code
15:19:31 <napping> arw: so if there exists one person who doesn't want a feature a language or library shouldn't include it?
15:19:38 <napping> arw: I'm not really sure what you are arguing here
15:19:41 <Nibble> Axman6: ooooh
15:19:53 <Philippa> if it does then hey, goto might be the right construct to use, at least for the purpose of showing your code does the right thing
15:20:11 <Philippa> (my girlfriend works in circumstances where that's getting on for true)
15:20:13 <benmachine> napping: if you include every feature ever wanted by anybody, you get <insertleastfavouritelanguage>
15:20:30 <Nibble> Axman6: didn't really do anything
15:20:31 <Nibble> wait
15:20:36 <copumpkin> data Maybe a = OHO a | NULL
15:20:47 <arw> napping: no. i'm just arguing that a) exceptions are ugly and b) exceptions are not the only solution to error handling and c) exceptions are not the "natural" solution to error handling
15:20:52 <Philippa> in the meantime, I resent you simply re-running the Blub argument on me without having any actual light to shed
15:21:04 <Philippa> they're the natural solution for /some/ error handling
15:21:19 <Nibble> Axman6: http://beta.yapaste.com/ff
15:21:20 <aristid> copumpkin: is renaming the constructors of Maybe and Either the new fashion?
15:21:22 <johan__> In the Asteroids game I am currently looking at, this row can be found: "main = start asteroids", however, "start" does not seem to be a Haskell keyword, nor something that your rude bot knows about. Any ideas?
15:21:27 <EvanR-work> data Maybe a = ORLY a | FAIL
15:21:31 <Eduard_Munteanu> Hm, why would anyone not export a data definition from its module if it's used in a function sig?
15:21:51 <Axman6> Nibble: why are you using q? that should be a
15:21:52 <Philippa> johan__: check the modules it imports
15:21:53 <napping> johan__: almost certainly defined somewhere in the source
15:22:09 <benmachine> johan__: this is why explicit import lists are useful :P
15:22:09 <johan__> napping: Not in the source file I have, but perhaps in an import
15:22:12 <micahjohnston> johan__: I seem to remember it might be part of wxhaskell
15:22:14 <copumpkin> aristid: data Either a = WithUs a | AgainstUs Void
15:22:15 <napping> johan__: I'd guess that wouter introduced some notion of a "Game" or "Animation" or something, and "start" is the one that runs it
15:22:16 <Axman6> also, you want (ValueConstructor xs) <> (ValueConstructor ys) = ...
15:22:39 <arw> Philippa: goto is perfectly fine for cleaning up in the case of an error when you don't want to nest too deep. but thats never a problem you will need to solve in haskell, you don't write 200 line functions anyways.
15:22:44 <hpc> as long as we are renaming Maybe, at least get the meme right
15:22:53 <hpc> data ORLY a = YARLY a | NOWAI
15:22:54 <johan__> napping: From the line, can you tell that "start" is a function and "asteroids" is a function reference passed to "start"?
15:22:58 <dankna> I write 200-line functionsin Haskell :(
15:23:02 * ddarius has written a 900+ line function in Haskell.
15:23:03 <dankna> I suddenly feel that I am doing it wrong
15:23:09 <aristid> hpc: NOWAI
15:23:10 <Axman6> dankna: you are
15:23:10 <napping> johan__: yeah, after = comes an expression
15:23:14 <Philippa> arw: your point?
15:23:17 <copumpkin> dankna: if ddarius has written bigger ones, you're safe
15:23:18 <dankna> but it's never a problem I need to solve in Haskell because Haskell has bracket
15:23:21 <dankna> haha okay
15:23:24 <aristid> ddarius: does that make you feel dirty? :P
15:23:29 <acowley> Anyone ever try passing a "-i" option to GHC through cabal install via "--ghc-option='-iblah'" ?
15:23:39 <arw> Philippa: i guess i've lost it and should get another beer.
15:23:47 <napping> johan__: can you do ghci Main.hs
15:23:57 <ddarius> aristid: GHC choked on it pretty hard, but would eventually compile it.
15:24:04 <napping> deleting that .hi or .o first if there is one, to get the "*" prompt
15:24:14 <napping> then :info start will tell you where it comes from
15:24:27 <arw> Philippa: i don't know the translation of "nix fuer ungut", but maybe somebody can translate.
15:24:30 <Axman6> Nibble: basically, there's not much that you've written that makes sense
15:24:33 <Philippa> arw: you should, and you should be more careful about making grand blanket statements. You don't generally like exception handling, that's fine. But unless you've got a good replacement for it in all possible situations, or at least something new to tell us about? Yeah
15:24:35 <aristid> ddarius: why didn't you split it into multiple functions?
15:24:54 <Nibble> Axman6: well, that's the problem (:P)
15:24:59 <johan__> napping: Nopes, there are modules missing
15:25:02 <Nibble> why should it be a?
15:25:05 <ddarius> aristid: I did at one point, but it didn't make any difference (to the compile times or, really, to the structure.)
15:25:06 <napping> hmm, that's not good
15:25:09 <napping> missing?
15:25:09 <Philippa> arw: fair enough
15:25:17 <johan__> napping: I couldn't compile either, but at least I could look at the source :)
15:25:28 <napping> oh, are you still having trouble installing wx?
15:25:28 <Axman6> Nibble: that really depends what you want the class to do
15:25:34 <Philippa> (seems somewhere along the lines of 'no offence intended'?)
15:25:41 <arw> Philippa: yes.
15:25:45 <aristid> ddarius: you're saying the code didn't become better by splitting-up?
15:25:52 <ddarius> aristid: Correct.
15:26:10 <napping> arw: is that plattdeutsch?
15:26:24 <dcoutts_> acowley: why would you want to do that?
15:26:31 <aristid> napping: without platt-
15:26:36 <arw> Philippa: something like "our disagreement is strictly professional and i don't want to pursue it further, lets go our ways peacefully"
15:27:03 <arw> napping: it is more common in the north i guess, but its not plattdeutsch
15:27:03 <acowley> dcoutts_: I'm doing something weird, and I want to append items to the Hs-Source-Dirs field of each target in a .cabal file from the command line
15:27:17 <Eduard_Munteanu> Ok, this really sucks: some xmonad module exports foo :: a -> Crap a, but if want to write a similar function, I can't spell the type sig because they didn't care to export Crap. Any ideas to get around it?
15:27:20 <Axman6> Nibble: try http://beta.yapaste.com/fG
15:27:25 <Philippa> FWIW, I make local uses of ErrorT and the likes all the damn time, and it genuinely simplifies my code
15:27:25 <dcoutts_> acowley: fair enough. What are you doing OOI?
15:27:25 <ddarius> More problems should be solved with duels.
15:27:40 <acowley> dcoutts_: OOI?
15:27:49 <dcoutts_> acowley: "out of interest"
15:27:50 <napping> Eduard_Munteanu: do you really need to give the type signature?
15:28:26 <napping> if it is essential to constrian the return type you can probably swing it with asTypeOf
15:28:27 <Nibble> Axman6: didn't work,     Couldn't match expected type `Int'
15:28:28 <Nibble>            against inferred type `[Int] -> [Int]'
15:28:31 <dcoutts_> acowley: meaning I don't really need to know, I'm just interested :-)
15:28:34 <Eduard_Munteanu> napping: I guess so, something's not right there and I'm just trying random stuff to get to the core of the problem :)
15:28:44 <acowley> dcoutts_: Ah, well I'm integrating with another build system that lists dependencies in an XML file. I can track down all the directories I need to, then I generate a bunch of Haskell code. For compilation, I just need those directories to be passed to GHC.
15:28:51 <Eduard_Munteanu> napping: hm, will try that, thanks.
15:28:52 <dcoutts_> acowley: I'm Cabal maintainer so I'm interested in how people use it, limitations etc.
15:28:57 <acowley> dcoutts_: My current solution is a Custom build.
15:29:07 <Nibble> shouldn't it be [a] -> [a] Axman6?
15:29:19 <Axman6> no, it should be: http://beta.yapaste.com/fe
15:29:31 <acowley> dcoutts_: But that's frustrating me because I also need to pass custom --bindir and --libdir options that I can't figure out how to do from Setup.hs, which forces me to rely on a cabal install wrapper even with my custom Setup.hs.
15:29:54 <Nibble> Axman6: no? same error
15:30:09 <acowley> dcoutts_: And the salt in the wound is that my BuildInfo needs to name all the targets to append these new directories, so I need to manually make sure my Setup.hs is in sync in with the .cabal file.
15:30:12 <dcoutts_> acowley: ah I see. You should be able to pass flags via the UserHooks interface.
15:30:15 <Axman6> where's the error?
15:30:25 <Nibble> Axman6: wait, let me try it one time
15:30:40 <acowley> dcoutts_: I spent a jolly long time trying to figure out how to do that and have since given up :/
15:31:05 <acowley> dcoutts_: But it still wouldn't solve my problem of needing to hard code the build targets from the .cabal in my Setup.hs.
15:31:13 <dcoutts_> acowley: if you have time, an email to the cabal-devel mailing list describing your use case would be useful to us, something to think about in the design of the Cabal lib api
15:31:30 <dcoutts_> acowley: you can get the description of the .cabal file in the Setup.hd
15:31:36 <dcoutts_> erm .hs
15:31:53 <Nibble> Axman6:  In the first argument of `(,)', namely `(min xs)'
15:32:05 <acowley> dcoutts_: Right now I hook preBuild, and I didn't see a list of targets in the package there.
15:32:07 <Axman6> what's the error, the whole thing
15:32:20 <ivanm> @type min
15:32:21 <lambdabot> forall a. (Ord a) => a -> a -> a
15:32:24 <interferon> does hoogle support wildcards, e.g/ " * -> Int" returns any function that takes any number of arguments and returns an int ?
15:32:28 <acowley> dcoutts_: I can send an email; I don't know how useful my experience is as I'm aware I'm doing something unorthodox that is likely a bad idea.
15:32:29 <ivanm> Nibble: ^^ if xs is a list, then min doesn't do what you want
15:32:32 <ivanm> you want _minimum_
15:32:38 <dcoutts_> acowley: since really you're implementing a custom build system and trying to reuse much of the existing functionality.
15:32:42 <Axman6> oh right, it should be (minimum xs, minimum ys)
15:32:59 <Nibble> ivanm: what do I need then, this part worked before I think
15:33:12 <ivanm> Nibble: I already said, as did Axman6 ;-)
15:33:14 <acowley> dcoutts_: Yes. The main point is that I want the Haskell side of this project to be able to utilize cabal install and hackage while still somewhat fitting in with another build system.
15:33:19 <dcoutts_> acowley: we know the Cabal lib api is basically crap for users that want to do builds directly, e.g. IDEs (as opposed to command line clients like Setup.hs or cabal-install)
15:33:24 <ivanm> @pl \ xs ys -> (minimum xs, minimum ys)
15:33:24 <lambdabot> (. minimum) . (,) . minimum
15:33:48 <ddarius> :t liftA2 (,) ($ xs) ($ ys) minimum
15:33:49 <lambdabot> Not in scope: `xs'
15:33:50 <lambdabot> Not in scope: `ys'
15:33:51 <monoidal> ivanm: minimum &&& minimum
15:34:00 <ddarius> @pl \xs ys -> liftA2 (,) ($ xs) ($ ys) minimum
15:34:00 <lambdabot> flip flip minimum . (. flip id) . liftA2 (,) . flip id
15:34:03 <dcoutts_> acowley: the buildHook receives the PackageDescription
15:34:14 <Nibble> ivanm: Slow on the buttons :)
15:34:28 <ivanm> Nibble: heh
15:34:34 <dcoutts_> acowley: you could use that one, just make sure you call the original build hook too
15:34:41 <Eduard_Munteanu> Ok, let me rephrase the issue in a generic manner.
15:34:44 <ivanm> monoidal: that's what I was trying to get
15:34:49 <benmachine> monoidal: erm, not quite the same
15:34:50 <acowley> dcoutts_: but what can I do in buildHook? It returns IO ()
15:35:00 <benmachine> :t curry (minimum *** minimum)
15:35:01 <lambdabot> forall a a1. (Ord a, Ord a1) => [a] -> [a1] -> (a, a1)
15:35:02 <monoidal> oh, yes, must be uncurried
15:35:04 <monoidal> *curried
15:35:35 <dcoutts_> acowley: oh, you'd call the original build with a modified PackageDescription or LocalBuildInfo
15:35:56 <dcoutts_> acowley: the HookedBuildInfo just gets merged into the PackageDescription, there's a function to do that.
15:36:12 <Eduard_Munteanu> Say I use a framework and I need to provide it a function func :: Foo -> Bar. Now I want to do IO in func to keep some state I can modify. How do I do that without changing the lib code?
15:36:23 <c_wraith> agh.
15:36:40 <ddarius> Eduard_Munteanu: You can't.
15:36:52 <c_wraith> a carefully chosen deepseq prevents the segfault.  But I can't decompose it any further.
15:37:01 <c_wraith> I don't understand what's going on.
15:37:13 <ddarius> Eduard_Munteanu: The library could be relying on the fact that the function is pure.  And likely implicitly is.
15:37:22 <Nibble> holy shit, it works
15:37:37 <Eduard_Munteanu> ddarius: yeah, but I still want to :). How should I approach it? I'm trying to make an xmonad binding that toggles a borders when a timer fires. But the layout hook is pure :(
15:37:51 <Eduard_Munteanu> *border
15:37:56 <Nibble> but I feel it could be beutified, could someone look at it(especially the last four lines?
15:38:00 <Nibble> http://beta.yapaste.com/f9
15:38:02 <acowley> dcoutts_: Right now I use the hsSourceDirs field of the BuildInfo struct to do my path munging. Where would that go in buildHook? Would I have to generate a UserHooks in buildHook that's customized for each build target?
15:38:12 <Nibble> I mean, do I really have to do it that way?
15:38:44 <Axman6> Nibble: the brackets aren't needed
15:38:48 <monoidal> Nibble: you don't need parenthesis: ValueConstructor([1,2,3])
15:38:50 <Axman6> so, test12 = ValueConstructor([5,6,7])
15:38:57 <Axman6> so, test12 = ValueConstructor [5,6,7] even
15:38:57 <monoidal> Nibble: ValueConstructor [1,2,3]
15:39:02 <dcoutts_> acowley: you mean you currently generate a HookedBuildInfo record that adds an extra hsSourceDirs field
15:39:17 <acowley> Yes
15:39:22 <Eduard_Munteanu> Ah, perhaps I can IO-ize the whole xmonad call, though I'm not sure if that flies with xmonad.
15:39:24 <ddarius> Eduard_Munteanu: You can try to use unsafePerformIO but I'm pretty sure it wouldn't work right.
15:39:25 <acowley> dcoutts_: Yes, sorry I was unclear.
15:39:29 <dcoutts_> acowley: so you'd write a function to look at and produce a modified version of a PackageDescription, and pass that to the real build
15:39:32 <Axman6> Nibble: also, don't write (,) (blah) (foo), just write (blah, foo)
15:39:36 <Eduard_Munteanu> ddarius: heh, already did, no effects whatsoever :)
15:39:47 <Eduard_Munteanu> even with noinline and that stuff.
15:40:19 <dcoutts_> acowley: ie it can look at the existing lib and exes in the package (hopefully in a generic way) and add the extra info to the BuildInfo of each lib/exe
15:40:44 <ddarius> Eduard_Munteanu: I suspect you'd actually want it to be inlined in this case but it would still be extremely unreliable and probably would still not work.
15:41:11 <dcoutts_> acowley: see the implementation of updatePackageDescription for reference
15:41:56 <Nibble> Axman6: sure, just I thought that one was clearer ^^
15:42:00 <acowley> dcoutts_: Okay, I can give that a shot. That would address my problem with the hard coded build targets in my Setup.hs. Is one of those structures a place where I could stick my --bindir and --libdir options?
15:42:02 <Axman6> it's not
15:42:11 <Axman6> it's gross ;(
15:42:17 <Nibble> I am a fan of prefix functions when they are not basic arithmetic expressions
15:42:28 <Nibble> like, +,-,*,/
15:42:31 <dcoutts_> acowley: the bindir etc is in the LocalBuildInfo, in the installDirTemplates
15:42:34 <Nibble> doing those prefix is just gross
15:42:54 <ddarius> Nibble: (,) is not an operator.  You can't write just: xs, ys
15:43:07 <Nibble> ddarius: it's a function
15:43:09 <Nibble> ok
15:43:18 <dcoutts_> acowley: the monoid instance is useful in both situations for merging in the extra info
15:43:27 <Nibble> just wrote operator because I am new to haskell, and the lingua
15:43:31 <Nibble> oh no
15:43:35 <Nibble> let me rephrase that
15:44:06 <Nibble> and all the words for everything
15:44:20 <Nibble> but I just noticed
15:44:25 <dcoutts_> acowley: oh, hmm, maybe monoid is not useful for the InstallDirs case
15:44:26 <ddarius> Nibble: My point wasn't terminology.  My point is that (xs,ys) is special syntax, not just the , operator being used.
15:44:27 <Nibble> you can't do (minimum xs) `(,)` (minimum ys)
15:44:39 <Nibble> ddarius: ah, terminology, that was the word.
15:44:43 <acowley> dcoutts_: monoid instance of what?
15:44:48 <ddarius> Nibble: You can't do `(+)` either.
15:44:49 <micahjohnston> Nibble: you can't put expressions within ``, only names
15:45:01 <dcoutts_> acowley: BuildInfo
15:45:01 <Nibble> ddarius: that's kinda obvious, since both are functions
15:45:14 <Nibble> micahjohnston: ok, just thought it was worth a shot
15:45:22 <Nibble> could always irritate someone
15:45:25 <acowley> dcoutts_: ah, for adding my hsSourceDirs
15:48:10 <acowley> dcoutts_: Ah, I remember now, I was also scared off by InstallDirTemplates
15:48:14 <pswoo> is there a better way, in general, of doing something like (Map.fromList . f . Map.toList $ m)?
15:48:29 <ddarius> pswoo: Use fmap.
15:48:33 <dcoutts_> acowley: sorry, I rewrote it to be slightly less scary :-)
15:48:35 <acowley> dcoutts_: Simply replacing the two fields I'm interested in wasn't (isn't) an obvious operation to me.
15:48:44 <Heffalump> pswoo: so you want to change the keys?
15:49:01 <pswoo> the map is getting larger in the process though
15:49:02 <ddarius> Er, if you want to change the keys too then I'm not sure that there is.
15:49:08 <dcoutts_> acowley: hopefully it's just a matter of installDirs { bindir = ..., libdir = ... }
15:49:40 <acowley> dcoutts_: You mean installDirTemplates { bindir = ..., libdir = ...} ?
15:50:09 <acowley> dcoutts_: Because LocalBuildInfo just has an installDirTemplates field
15:50:15 <dcoutts_> acowley: it'd be (installDirTemplates lbi) { ... }
15:50:42 <ddarius> pswoo: You could use toList and then have f insert into the original map rather than rebuilding the entire map if that would be a better cost trade-off.
15:52:25 <pswoo> cost isn't an issue at this point.. just don't want to come back later and not understand why i had to do that :)
15:53:01 <ddarius> pswoo: You should think of toList as returning something like Java's iterator() or C#'s GetEnumerator().  
15:53:20 <Phyx-> eh?
15:54:37 <pswoo> that's basically how its being used in this case
15:55:05 <psilva> is it possible that when concatenating two lists the result is empty though one list is non-empty? I'm having a weird problem... http://pastebin.org/426579
15:55:30 <Heffalump> pswoo: I don't know of any better way than your code.
15:55:56 <pswoo> thanks heff
16:01:53 * hackagebot hp2pretty 0.1 - generate pretty graphs from heap profiles  http://hackage.haskell.org/package/hp2pretty-0.1 (ClaudeHeilandAllen)
16:01:57 <Phyx-> psilva: no, that's not possible, I'm no regexp expert, but isn't it your rmatch that's the problem?
16:02:00 <Phyx-> you
16:02:25 <Phyx-> you're pattern is "(.*),(.*)" so when you eventually only have 1 entry wouldn't it return nothing
16:02:57 <psilva> Phyx: ok... so then concatenating nothing with something yields nothing?
16:03:11 <Phyx-> no, that yields something
16:03:16 <Phyx-> > [] ++ [ol]
16:03:17 <lambdabot>   Not in scope: `ol'
16:03:22 <Phyx-> > [] ++ ["lol"]
16:03:23 <lambdabot>   ["lol"]
16:03:26 <psilva> ;)
16:03:27 <Phyx-> @src (++)
16:03:27 <lambdabot> []     ++ ys = ys
16:03:27 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:03:27 <lambdabot> -- OR
16:03:27 <lambdabot> xs ++ ys = foldr (:) ys xs
16:04:04 <Phyx-> psilva: out of curiousity, why are you using a regexpr to write a split?
16:04:51 <psilva> but I have this split_dbg and split... split_dbg returns [last tmp], split return (......) + [last tmp]... just naively I would guess that split always returns more
16:05:28 <psilva> Phys-: I'm kind of new to haskell... I didn't know how to implement it differently (besides I need to use a lot of regexpr in my code anyway)
16:06:22 <Phyx-> psilva: yes, but your rmatch can return [] in a recursive call
16:06:36 <Phyx-> in spit you recure on the head of the result of the rmatch
16:06:47 <Phyx-> say the result no longer has the pattern you're looking for
16:06:52 <Phyx-> the result of rmatch would be []
16:06:53 <psilva> yeah
16:06:56 <psilva> right
16:06:56 <Phyx-> head is failing on that
16:08:23 <acowley> dcoutts_: I have my buildHook going, but now I'm not sure how to get my fully customized preBuild hook to run.
16:08:29 <Phyx-> it's not the (++) but the head, you should check that tmp is null before you call head
16:08:35 <philip_> Phyx-: sorry... got kicked out or something
16:08:47 <Phyx-> mkay
16:08:48 <philip_> Phyx-: oh ok..
16:09:05 <philip_> Phyx-: well I'll try that... thank you a lot
16:09:37 <dcoutts_> acowley: it should still work, or you can put it all in the build hook. Cabal just runs them in sequence (and merges the hooked build info into the package description)
16:09:41 <Phyx-> philip_: there's a function "null" for that btw
16:09:43 <acowley> dcoutts_: That is to say, I inspect the PackageDescription in order to generate a HookedBuildInfo that has a modified hsSourceDirs field for each build target in the package. I also modify LocalBuildInfo to have the parameters I want.
16:09:46 <Phyx-> > null []
16:09:47 <lambdabot>   True
16:09:54 <philip_> is null == [] ?
16:10:15 <acowley> dcoutts_: So now I try calling (buildHook simpleUserHooks) with customized parameters, but it's not finding my other paths
16:10:17 <Phyx-> :t null
16:10:18 <lambdabot> forall a. [a] -> Bool
16:10:24 <Zao> @src null
16:10:25 <lambdabot> null []     = True
16:10:25 <lambdabot> null (_:_)  = False
16:10:32 <Phyx-> philip_: null just checks in constant time if the list is empty or not
16:10:41 <philip_> oooh ok
16:10:45 <acowley> dcoutts_: I tried priting my custom HookedBuildInfo in my buildHook function, and it is being generated correctly, but it seems to not be having an effect.
16:10:53 <acowley> dcoutts_: re/priting/printing
16:11:23 <philip_> Phyx-: yeah just build a check into rmatch... now it works... nice :)
16:11:54 <acowley> dcoutts_: I think my confusion here is that I want to supply a HookedBuildInfo, but the buildHook function takes a UserHooks.
16:12:10 <acowley> dcoutts_: So I'm giving it a modified UserHooks, but I don't know if it's having an effect
16:12:13 <c_wraith> ...  just double-checking...  this line should do *nothing* denotationally, right?  msg `deepseq` return ()
16:12:16 <philip_> well mostly gotta put it into split...
16:12:19 <dcoutts_> acowley: and you're using updatePackageDescription to merge the HookedBuildInfo into the PackageDescription you pass to the original buildHook ?
16:12:27 <acowley> dcoutts_: !!
16:12:34 <c_wraith> assuming that's one line in the middle of a do block
16:12:42 <Phyx-> philip_: :), if you're new to haskell though, a good excersize is to write that without regexp
16:12:47 <dcoutts_> acowley: somehow you have to modify the PackageDescription you pass to the real build
16:13:08 <dcoutts_> acowley: perhaps it'd be easier if you pasted something for me to see
16:13:24 <ddarius> c_wraith: It should be bottom if msg contains bottom and from there it depends on the monad, but most likely the whole thing will be monad.
16:13:34 <ddarius> s/monad.$/bottom./
16:13:41 <philip_> Phyx: hm ok... I guess I need to check out the documentation much more for that ;)
16:13:51 <c_wraith> ddarius: the monad's IO.  And msg is a non-bottom string.
16:14:08 <dcoutts_> acowley: you don't have to use HookedBuildInfo+updatePackageDescription, you can just update the PackageDescription directly.
16:14:12 <c_wraith> that is, the string contains no bottoms anywhere
16:14:28 <Phyx-> philip_: well, you don't need any more language features than what you have there. You should just think about how you can use recursion to do it
16:14:41 <c_wraith> but program behavior is differing depending on whether I have that line there or not.  aaaarg
16:14:46 <acowley> dcoutts_: Yes, that got my paths working! Thank you! Now my bindir isn't working.
16:15:07 <acowley> dcoutts_: But this is more progress than I could possibly have made on my own, many thanks.
16:15:18 <ddarius> c_wraith: Then it shouldn't matter denotationally unless there is some unsafePerformIO/unsafeInterleaveIO
16:15:21 <dcoutts_> acowley: so presumably you're making a new lbi, and passing that to the real build
16:15:31 <philip_> Phyx-: I see
16:15:41 <acowley> dcoutts_: Yes
16:15:49 <acowley> lbi' = lbi { installDirTemplates = customDirs }
16:15:49 <acowley>           customDirs = oldDirs { bindir = toPathTemplate "bin"
16:15:49 <acowley>                                , libdir = toPathTemplate "lib" }
16:15:49 <acowley>           oldDirs = installDirTemplates lbi
16:16:31 <benmachine> c_wraith: try using evaluate
16:16:35 <dcoutts_> acowley: ah, you'll need to do the same thing for other hooks, in particular copy and install.
16:16:48 <benmachine> c_wraith: evaluate (msg `deepSeq` ())
16:17:06 <dcoutts_> acowley: changes you make to the local build info is not persistent, unless you do it in the configure step I think
16:17:10 <benmachine> c_wraith: evaluate guarantees ordering of evaluation in your IO stuff
16:17:14 <benmachine> or wait
16:17:17 <benmachine> that's not what you wanted
16:17:18 <benmachine> never mind
16:17:28 <acowley> dcoutts_: that's unfortunate :)
16:17:55 <c_wraith> I think I'm going insane.  first segfaults, now this, as I'm trying to nail down the source of the segfaults
16:17:59 <dcoutts_> acowley: though it's also an advantage
16:18:29 <acowley> dcoutts_: I'm a selfish man
16:18:42 <ddarius> c_wraith: Can you post the code?
16:18:45 <dcoutts_> acowley: perhaps you can just do it in the configure hook
16:19:04 <dcoutts_> acowley: the lbi produced there gets saved to a file and used in the other hooks
16:19:10 <c_wraith> ddarius: I was in the middle of trying to simplify it to postable when I ran into this.  As soon as I do, I will.
16:19:39 <acowley> dcoutts_: confHook doesn't give me an already-created LBI
16:19:47 <acowley> dcoutts_: Should I do postConf?
16:20:01 <dcoutts_> acowley: the configure step is what creates the local build info in the first place
16:20:12 <dcoutts_> acowley: so you'd retrieve it and return a modified copy
16:20:29 <dcoutts_> acowley: ie run the real configure hook, grab the lbi, return modified version
16:20:30 <acowley> dcoutts_: Okay, I'll give it a shot
16:21:31 <dcoutts_> acowley: btw, just so you know, you shouldn't release public packages that mess with the user's selected install dirs, it's not polite :-)  but you can do it for private packages.
16:21:54 <acowley> dcoutts_: Yeah, I've been worried about that
16:22:14 <dcoutts_> acowley: why do you need to change the install dirs?
16:22:34 <acowley> dcoutts_: several reasons (typing...)
16:22:50 <acowley> dcoutts_: there is a launch system that knows to look in "bin" directories underneat package directories
16:23:02 <dcoutts_> acowley: or is it just an easier way than writing code to call the build system with parameters
16:23:15 <acowley> dcoutts_: secondly, there are some horribly generically named executables that I wouldn't want to polute .cabal/bin
16:23:40 <acowley> dcoutts_: Doing that is fine, too. Perhaps I should leave it at that.
16:23:59 <acowley> dcoutts_: I already have a little command line utility one of whose subcommands is "build" that invokes cabal install with bindir and libdir specified.
16:24:14 <dcoutts_> acowley: conceptually cabal splits the configure/build into package author role and deploy role, in a custom system those roles are often the same person
16:24:48 <acowley> dcoutts_: I'm mildly concerned about people accidentally typing cabal install and ending up clobbering the same "MyProgram" executable (or what have you) in their .cabal/bin
16:25:31 <acowley> dcoutts_: But I do appreciate the nastyness of taking over the installation targets
16:25:34 <dcoutts_> acowley: so are they programs that really ought not to be on the $PATH at all? e.g. in a libexec dir?
16:25:42 <acowley> dcoutts_: That's right
16:26:09 <dcoutts_> acowley: ah ok, cabal does know about a libexec dir, but doesn't do much with it at the moment. Only way to use it is in custom code in Setup.hs
16:26:20 <dcoutts_> acowley: that might be a better solution in future if we make that easier to use.
16:26:36 <dcoutts_> acowley: there's a ticket about it, you can add yourself to the cc list
16:26:57 <acowley> dcoutts_: So what would you have me do at the moment? I can leave in my shell command to invoke cabal install with appropriate options, or I can wire in where these things are supposed to go?
16:27:02 <dcoutts_> acowley: http://hackage.haskell.org/trac/hackage/ticket/717
16:28:18 <dcoutts_> acowley: the simplest thing is to stick with the shell script, the more sophisticated thing would be to override the copy/install hook and install the exes in the libexec dir instead of the bin dir. That may be more effort than it's worth however. I've not done it so I can't say how annoying it'd be to code.
16:28:50 <acowley> dcoutts_: The issue here is that these executables are intended to be launched by another program that looks in the "bin" directory.
16:29:15 <acowley> dcoutts_: So I don't think there's actually any time when a user would want them outside of that conventional path.
16:29:55 <dcoutts_> acowley: ah ok, libexec is basically for private progs that do not live on the path and are called by other programs that know where to look for them (or get told explicitly where to look)
16:30:36 <acowley> dcoutts_: Thanks to your help I seem to have everything I mentioned earlier working!
16:30:44 <dcoutts_> great
16:31:05 <acowley> dcoutts_: I will bear this potential program with installation directories in mind.
16:33:39 * FunctorSalad complains about putting statements right after a do. You'd assume that this is an equivalence transformation... sed -i 's/fromJust/ ( fromMaybe moreHelpfulError ) /g' **/*.hs
16:34:22 <dibblego> is (##>) a valid operator? and if so, is it a bug that hlint borks?
16:34:42 <copumpkin> > let (##>) = (+) in 5 ##> 6
16:34:43 <lambdabot>   11
16:35:26 <dibblego> that's what I suspected, thanks
16:35:46 <Heffalump> if hlint borks, it's probably a haskell-src-exts bug
16:35:54 <FunctorSalad> magicness applies only to whole maybe-operator-tokens :) --++ is legal too
16:36:04 <aristid> > let (##>) = 5 in (##>)
16:36:04 <FunctorSalad> I hope...
16:36:05 <lambdabot>   5
16:36:13 <dibblego> yes I'm emailing haskell-src-exts now
16:36:25 <FunctorSalad> > (\(--++) -> 1) 2
16:36:25 <lambdabot>   1
16:36:29 <dibblego> (author)
16:36:35 <micahjohnston> > let (>>>>>>>>>>>>>>>>) = (+) in 5 (>>>>>>>>>>>>>>>>) 6
16:36:36 <lambdabot>   Ambiguous type variable `t' in the constraint:
16:36:37 <lambdabot>    `GHC.Num.Num t' arising f...
16:36:50 <micahjohnston> :/
16:37:05 <micahjohnston> wait
16:37:06 <micahjohnston> lol
16:37:16 <micahjohnston> > let (>>>>>>>>>>>>>>>>) = (+) in 5 >>>>>>>>>>>>>>>> 6
16:37:17 <lambdabot>   11
16:37:35 <FunctorSalad> by the way, my point was that the apparently harmless transformation breaks programs like:
16:37:51 <FunctorSalad> fromJust $ do print 1
16:38:01 <FunctorSalad>                print 2
16:38:11 <dibblego> it was FunctorSalad's comment that reminded me to run hlint
16:38:14 <FunctorSalad> the 'print's are supposed to be aligned ;)
16:38:21 <FunctorSalad> hehe
16:38:51 <FunctorSalad> (had to count the spaces manually since I have a proportional font here ;))
16:39:11 <copumpkin> pity it doesn't match my proportional font
16:39:16 <copumpkin> you should've been more altruistic
16:39:26 <dibblego> leksah occasionally messes that up
16:39:28 <FunctorSalad> nevermind that that program is broken in the first place
16:39:35 <FunctorSalad> copumpkin: I was :( it doesn't match mine either
16:39:43 <copumpkin> fail
16:39:49 <FunctorSalad> I counted 14 spaces
16:39:53 <FunctorSalad> so it works on monospace
16:40:22 <FunctorSalad> assuming that a simple plurality use monospace ;)
16:40:42 <FunctorSalad> if you count all the spacewise-different proportional fonts separately
16:45:08 <dibblego> does category-extras have a class Cofunctor f where comap :: (a -> b) -> f b -> f a?
16:45:19 <ezyang> yes. 
16:45:25 <ezyang> It's called ContraFunctor, I think 
16:45:35 <copumpkin> yep
16:45:37 <dibblego> ah
16:45:43 <ezyang> in Control.Functor.Contra 
16:45:43 <dibblego> google should know I meant that
16:45:44 <copumpkin> contramap
16:45:54 <dibblego> thanks
16:45:56 <conal> dibblego: also TypeCompose.  which misguidedly uses the name "Cofunctor".
16:46:05 <dibblego> conal, yeah I found that one
16:46:10 <conal> i'll change it at some point.
16:47:33 <dibblego> what's the objectino to the name?
16:49:04 <Axman6> dibblego: you're an aussie right?
16:49:11 <dibblego> right, Brisbane
16:49:27 <copumpkin> it's a trap!
16:49:30 <Axman6> care to join us in $haskell.au?
16:49:34 <Axman6> #*
16:49:43 <dibblego> mk
16:54:09 <c_wraith> agh.  total failure to generate a minimal test case :(
16:55:46 <danderson> oh fer pete's sake
16:55:56 <danderson> anyone have an example of how to actually use the haskell regex libs?
16:56:19 <danderson> the libraries are a delightful nugget of beautiful, abstract... undocumented code.
16:57:29 <danderson> ah, found bos' blog post. Looks like the closest to real docs.
16:57:39 <aristid> danderson: documentation is a disgrace to the elegance of the code
16:57:45 <kmc> it's an awful api
16:58:04 <danderson> yeah, just like blueprints are a disgrace to an abstract sculpture
16:58:14 <danderson> but here I was hoping to use the regex libs as an engineering tool
16:58:35 <danderson> rather than sip cocktails around it while making up seemingly insightful criticism
16:59:18 <acowley> danderson: Coming across that regex interface is like a right of passage
16:59:42 <acowley> danderson: The first time I hit them, I didn't program in Haskell for a week, I think.
16:59:48 <danderson> heh
17:00:01 <danderson> acowley: looking at bos' blog post, I actually did decode the API correctly
17:00:05 <danderson> which makes me rather happy
17:00:20 <danderson> the only thing I didn't grok was why =~ exploded because I didn't specify the result type
17:00:20 <acowley> danderson: There you go, so their seeming inscrutability was actually a good thing for you :)
17:00:33 <acowley> danderson: ah, well that's sort of the chief mystery
17:00:47 <danderson> yeah, so I still suck you see :P
17:00:50 <acowley> danderson: then the fun of figuring out what you can ask it to return begins
17:01:02 <danderson> yeah
17:01:13 <kmc> the packages like regex-pcre, regex-posix provide more reasonable concrete APIs
17:01:14 <danderson> "What if I ask it for bananas, will it run the monkey monad on the input?"
17:01:19 <acowley> danderson: Part of me still thinks it's a parsec marketing tool
17:01:30 <kmc> rather than trying to use the stupidly overloaded typeclass
17:01:42 <kmc> you can just import Text.Regex.Posix.String and have a nice concrete "compile" and "execute"
17:01:53 <danderson> well, the overloaded typeclass does feel very perlish once you know how to make it not explode
17:01:57 <danderson> which is reasonably neat
17:02:08 <acowley> kmc: too easy
17:02:09 <kmc> yes, i don't think any part of Haskell should feel Perlish
17:02:10 <danderson> it's just a pity the doc prelude doesn't just say this
17:02:24 <kmc> Haddock is really not set up for documenting that kind of API
17:02:33 <danderson> heh
17:02:35 <kmc> it would be better to just give 10 example signatures for (=~)
17:02:43 <kmc> rather than the real sig and a list of instances
17:03:18 <FunctorSalad> my way to cope with it is to just always use the [[String]] return type
17:03:20 <FunctorSalad> (or Bool)
17:03:29 <FunctorSalad> the former has all you need usually...
17:03:34 <kmc> i would say that making a Perlish API in Haskell is, at best, a curiosity like making BASIC as an EDSL
17:03:52 <kmc> oh there's also this "regexpr" lib
17:04:04 <danderson> it feels like the code associated with a research paper
17:04:14 <FunctorSalad> (outer list enumerates different matches, inner list is [whole match, capture 1, capture 2, ...])
17:04:18 <danderson> "Look, haskell types are so awesome I can make regexes look like language syntax!"
17:04:51 <FunctorSalad> danderson: I was outraged by the interface too, but with [[String]] it just works ;))
17:05:01 <danderson> FunctorSalad: yeah yeah, I know (now)
17:05:14 <kmc> well
17:05:22 <kmc> Haskell's =~ is far more overloaded than Perl's
17:05:34 <aristid> even more?
17:05:40 <kmc> in Perl it just produces a boolean, or an iterator that sets a bunch of global vars
17:05:45 <kmc> i don't think there's another option?
17:05:48 <kmc> but it's been a long time
17:06:00 <FunctorSalad> .... yet it doesn't have a substitution instance, or does it
17:06:00 <aristid> kmc: it can also return arrays, and some other things i think
17:06:05 <kmc> ah
17:06:07 <kmc> so maybe it's comparable
17:06:08 <danderson> what, only 2 possible outcomes for a half-line of perl code?
17:06:11 <aristid> you can do substitutions with =~
17:06:12 <danderson> unthinkable!
17:06:18 <kmc> true
17:06:37 <FunctorSalad> by reassembling the string after changing some captures? sure
17:06:47 <aristid> FunctorSalad: no, in perl
17:06:55 <aristid> $x =~ s/a/b/
17:06:56 <FunctorSalad> ok, I meant haskell ;)
17:07:04 <aristid> :)
17:12:26 <ManateeLazyCatBo> hello, i use Chrome login IRC, just test.
17:18:33 <Phyx-> >t (=~)
17:18:38 <Phyx-> :t (=~)
17:18:38 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
17:18:49 <Phyx-> -.-
17:18:56 <Phyx-> too long
17:19:39 <Gracenotes> is there a nicer way to say: \m -> if (Set/Map/...).null m then Nothing else Just m
17:20:12 <Gracenotes> because I'm using it all the time with nested collections. but it's an ungainly expression
17:20:23 <Phyx-> guard (Set/Map/...).null m) >> return m
17:20:24 <Phyx-> maybe?
17:20:32 <aristid> :t (=~) :: (RegexMaker Regex CompOption ExecOption b, RegexContext Regex a c) => a -> b -> c
17:20:34 <lambdabot> forall a b c. (RegexContext Regex a c, RegexMaker Regex CompOption ExecOption b) => a -> b -> c
17:20:42 <hpc> :t guard
17:20:43 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:21:01 <hpc> @src guard
17:21:02 <lambdabot> guard True  =  return ()
17:21:02 <lambdabot> guard False =  mzero
17:21:11 <Gracenotes> :t liftM2 (>>) (guard . Map.null) return
17:21:12 <lambdabot> Couldn't find qualified module.
17:21:21 <hpc> whoa, that's a sweet mzero trick
17:21:21 <Gracenotes> :t liftM2 (>>) (guard . null) return
17:21:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m [a]
17:21:35 <Gracenotes> well a bit less ungainly at least
17:21:44 <hpc> also, would it be too much to ask for @src to provide a type signature along with the code?
17:21:54 <Gracenotes> but not much less awkward in the middle of a large expression
17:22:12 <Phyx-> Gracenotes: bind it to an operator and use that then
17:22:20 <Phyx-> or a function
17:22:28 <Phyx-> depending on your tastes :)
17:22:36 <Gracenotes> that's what I've been doing. half a dozen times in various modules
17:22:52 <ezyang> In haddock, should I use @True@ or 'True'? 
17:23:00 <ezyang> (i.e. hyperlink or not?) 
17:23:02 <hpc> Gracenotes: do it in one and import
17:23:14 <dcoutts_> ezyang: most people know what True/False are
17:23:30 <ezyang> ok 
17:23:34 <hpc> ezyang: the implementation of booleans shouldn't be enough of a mystery to merit it
17:23:42 <Gracenotes> hpc: I'm ambivalent about utility modules...
17:23:44 <hpc> or if they are, a deeper problem is at work
17:24:12 <Phyx-> I have been putting of coding for 48 hours now....
17:24:13 <Phyx-> *sigh*
17:24:22 <hpc> Gracenotes: at some point, i find they become inevitable; i have been trying to avoid them myself, recently and always seem to come back to them
17:24:47 <hpc> there's too much useful stuff that doesn't belong in any particular place or is so ubiquitous that it has to be in everything
17:25:05 <Phyx-> hpc: I just create a Util module then, that I just share
17:25:54 <hpc> Phyx-: same here, although i have a habit of remaking it every time, as the domain of useful combinators shifts between projects
17:26:05 <hpc> probably a bad habit, but meh
17:26:09 <Phyx-> heheh
17:28:03 <hpc> i try to make a hierarchy of Util, so for an irc bot i have math, network, http, regex (so necessary...) utils
17:28:28 <Gracenotes> I don't really like regex with ircbots
17:28:35 <hpc> plus a core one for stuff like (cascade a | cascade a == a = a; | otherwise = cascade a
17:28:57 <hpc> i use it as a cheap way of yanking a few things out of html
17:29:10 <hpc> by cheap i mean "parsec breaks my skull"
17:29:18 <napping> how about TagSoup?
17:29:25 <Gracenotes> html?
17:29:36 <hpc> like @wn
17:29:42 <Axman6> > let cascade a | cascade a == a = a | otherwise = cascade a in cascade 1
17:29:43 <lambdabot>   *Exception: stack overflow
17:29:46 <hpc> i use it to track folding@home stats
17:29:54 <Gracenotes> oh. I'd go with tagsoup personally here
17:29:57 <pswoo> on that note.. is there really no allEqual function in Data.List? i have to (null xs || all (==head xs) xs)?
17:30:03 <Gracenotes> but I thought you meant for parsing IRC itself
17:30:20 <hpc> no, for irc i have another util ;)
17:30:47 <c_wraith> :t \xs -> length (group xs) == 1
17:30:48 <Gracenotes> parsec works well there. you shouldn't write your own html parsers though. unless you're *writing* an html parser.
17:30:48 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:30:49 <Axman6> > foldr (==) True [1,2,3]
17:30:50 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
17:30:50 <lambdabot>    arising from the literal `1'...
17:31:38 <hpc> it works out nicely, and i can trivially write extra functionality into the bot
17:31:42 <Gracenotes> pswoo: if you want to take a roundabout approach, (null . drop 1 . group)
17:31:59 <hpc> like, it took me a day to add user-made function definitions
17:32:14 <dcoutts_> pswoo: or:  and (zipWith (==) xs (tail xs))
17:32:23 <pswoo> heh, i'm sure theres a dozen ways to do it
17:32:36 <pswoo> just reflecting on its absence
17:32:41 <hpc> then when i made my symbolic differentiator, custom functions worked out of the box
17:32:46 <dcoutts_> oh, erm it'd have to be drop 1, not tail
17:32:46 <Gracenotes> yeah.
17:32:59 <hpc> (my "a day" estimate is my free time; i am not by any means that slow :D)
17:33:37 <hpc> drop 1 == tail
17:33:43 <hpc> null . tail . group
17:33:46 <dcoutts_> hpc: not quite
17:34:00 <hpc> oh right, the pattern can fail for tail
17:34:02 <hpc> :(
17:34:13 <dcoutts_> pswoo: point is, the standard list lib does not follow the philosophy of naming every frequently used function, rather it lets you write endless combinations
17:34:15 <Gracenotes> and drop 1 has the quirk of not failing
17:34:32 <dcoutts_> it's a feature :-)
17:34:41 <c_wraith> :t all (uncurry (==)) . (ap zip $ drop 1)
17:34:42 <lambdabot> forall b. (Eq b) => [b] -> Bool
17:35:03 <c_wraith> Ok, I'm just being silly
17:35:31 <dcoutts_> @pl \xs -> and (zipWith (==) xs (drop 1 xs))
17:35:32 <lambdabot> and . ap (zipWith (==)) (drop 1)
17:35:39 <pswoo> haha
17:36:22 <pswoo> probably underestimated by far when i said 'a dozen'
17:36:34 <aristid> :t and . (zipWith (==) <*> drop 1)
17:36:36 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:37:03 <aristid> c_wraith: why ap zip $ when you could zip <*>
17:37:16 <c_wraith> oh, good point
17:37:48 <c_wraith> :t all (uncurry (==)) . (zip <*> drop 1)
17:37:50 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:37:50 <pswoo> whats <*>?... (those operators are always impossible to google!)
17:38:06 <c_wraith> <*> is the same as ap, except defined on Applicative instead of Monad
17:38:14 <c_wraith> :t ap
17:38:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:38:19 <c_wraith> :t <*>
17:38:20 <lambdabot> parse error on input `<*>'
17:38:25 <c_wraith> :t (<*>)
17:38:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:38:35 <ezyang> How many functions is too many functions for a Haskell module?
17:38:39 <pswoo> ah.. haven't tackled applicative yet
17:38:59 <hpc> applicative is a wonderful typeclass; i use it near everywhere
17:39:16 <aristid> ezyang: 17.
17:39:25 <aristid> or was it 170?
17:39:33 <c_wraith> I thought numeric answers were always 42
17:39:36 <ezyang> very helpful 8) 
17:39:43 <pswoo> 37 is a good one too
17:39:44 <dcoutts_> ezyang: I usually start to worry when a module is getting into the high 100's of lines
17:40:01 <c_wraith> pswoo: in a row?
17:40:17 <ezyang> I'm at about 700 
17:40:29 <c_wraith> May or may not be too many.
17:40:37 <c_wraith> Are people expected to use them all?
17:40:51 <dcoutts_> ezyang: when you hit 1000 you've definitely gone too far :-)
17:41:00 <Phyx-> you guys really have modules that small?
17:41:02 <ezyang> No. 
17:41:06 <hpc> my criteria of a good module is how many functions it /exports/
17:41:06 <Phyx-> I rarely have anything below 500 :(
17:41:10 <pswoo> read that 37 is most likely answer to "name a small random number"
17:41:20 <hpc> i tend to write them to export either all of them or exactly one
17:41:24 <ezyang> I did some spring cleaning and I roughly have the following types of functions: 
17:41:51 <ezyang> constants, modification, querying, generic operations and unsafe operations 
17:41:54 <Gracenotes> pswoo: oh, I finally figured out the best way to implement your all-equal function
17:41:57 <ezyang> two monads. 
17:42:13 <Gracenotes> rnf (sortBy (\x y -> let c = compare x y in seq (unsafePerformIO $ when (c /= EQ) $ modifyMVar_ var (const . return $ False)) c) list) `seq` unsafePerformIO (readMVar var)
17:42:35 <dcoutts_> @slap Gracenotes 
17:42:35 <lambdabot> stop telling me what to do
17:42:41 <hpc> i so approve of your use of safety
17:42:49 <hpc> but only wish you could include multithreading
17:42:58 <Phyx-> but ok, how about line with, with modules of on average 100lins how wide are your lines?
17:43:01 <Gracenotes> I'll put that on the feature list
17:43:07 <Phyx-> Mine are generally not very wide, which could explain the amount of lines
17:43:52 <pswoo> wow.. so easy
17:43:59 <hpc> do you design to have shorter expressions, or do you just wrap lines?
17:44:14 <Phyx-> hpc: i design to have shorter expressions
17:44:19 <Phyx-> I break off long compositions aswell
17:44:28 <gcross> Quick question:  is there a function in the libraries that lets me skip every n elements of a (finite-length, not necessarily a multiple of n) list?
17:44:39 <ezyang> I write stuff like 'make =<< handleAbcError "Io_ReadAiger" (ioReadAiger f True)' 
17:44:41 <gcross> I could easily write one myself but I figure I shouldn't have to.  :-)
17:45:48 <gcross> @hoogle Int -> [a] -> [a]
17:45:49 <lambdabot> Prelude drop :: Int -> [a] -> [a]
17:45:49 <lambdabot> Prelude take :: Int -> [a] -> [a]
17:45:49 <lambdabot> Data.List drop :: Int -> [a] -> [a]
17:46:25 <absentia> xn
17:46:25 <absentia> xn
17:47:27 <dcoutts_> > let skipEveryN n = unfoldr (\xs -> case xs of [] -> Nothing; (x:xs) -> Just (x, drop n xs)) in skipEveryN 3 [0..20]
17:47:27 <lambdabot>   [0,4,8,12,16,20]
17:48:08 <dcoutts_> gcross: btw, the answer is no, there isn't in the standard libs
17:48:17 <gcross> dcoutts_:  Okay, thanks!
17:48:44 <gcross> > [0,4..20]
17:48:45 <lambdabot>   [0,4,8,12,16,20]
17:48:58 <dcoutts_> gcross: did I correctly guess what you meant btw?
17:49:26 <gcross> Yes
17:49:50 * dcoutts_ recommends the underappreciated unfoldr
17:49:58 <hpc> :t unfoldr
17:49:59 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:50:06 <hpc> ooh
17:50:22 <gcross> dcoutts:_  I thought for a moment that it just skipped every n integers, but I see now that it does want I wanted.  :-)
17:52:08 <dcoutts_> @google the underappreciated unfold
17:52:11 <lambdabot> http://portal.acm.org/citation.cfm?id=289455
17:52:11 <lambdabot> Title: The under-appreciated unfold
17:52:20 <dcoutts_> it's a good paper btw
17:52:28 <gcross> dcoutts_:  I wouldn't have thought of that particular solution using unfoldr;  thanks.  :-)
17:52:55 <dcoutts_> functional programmers, know thy folds and unfolds :-)
17:53:13 <aristid> > let everyN n = catMaybes . zipWith (\a b -> guard (a `mod` n == 1) >> return b) [1..] in everyN 4 [0..20]
17:53:14 <lambdabot>   [0,4,8,12,16,20]
17:53:28 <hpc> :t unfoldr_
17:53:28 <aristid> :D
17:53:28 <lambdabot> Not in scope: `unfoldr_'
17:53:50 <hpc> unfoldr_ would just be Stream, wouldn't it...
17:53:58 <interferon> can someone explain how the io monad enforces ordering?
17:54:12 <kmc> by definition
17:54:12 <dcoutts_> hpc: you mean an infinite unfolding?
17:54:16 <kmc> (>>) says what the ordering is
17:54:19 <hpc> dcoutts: yeah
17:54:20 <kmc> (a >> b) means "do a, then b)
17:54:32 <kmc> interferon, unless you mean you want the low-level details of how the IO monad is implemented in GHC, say
17:54:37 <kmc> that's a whole other ball of worms
17:54:56 <dcoutts_> hpc: you can do almost the same with iterate
17:54:56 <kmc> interferon, note that IO monad does not directly enforce order of evaluation, only order of execution
17:54:57 <ezyang> kmc: I thought monads had some implicit ordering baked into them? 
17:55:04 <kmc> it does this by defining what "execution" means
17:55:17 <interferon> but if the language is lazy, how do you ensure a before b?
17:55:29 <kmc> interferon, because evaluation and execution are different things
17:55:33 <kmc> evaluation is lazy and on-demand
17:55:44 <kmc> execution is performed in the order specified by (>>)
17:55:45 <Philippa_> ezyang: nevertheless, if they don't use seq, it's still just forcing the standard order of execution to do certain things - much like CPS can
17:55:51 <kmc> if i make a string that says "take out the garbage, then feed the cat"
17:55:58 <kmc> we don't care when this string is evaluated
17:56:03 <kmc> it's just a description of some stuff to do
17:56:18 <kmc> and doing the stuff is totally different from evaluating the string
17:56:33 <kmc> and the order of doing stuff is determined by the word "then" in the string, and not by when i evaluate the first dozen characters versus the last dozen
17:56:41 <aavogt> it should depend on the definition of (>>)
17:56:50 <aristid> @src (>>)
17:56:51 <lambdabot> m >> k      = m >>= \_ -> k
17:56:57 <hpc> haha
17:57:26 <hpc> the definition of (>>=), then
17:57:34 <aavogt> @src State
17:57:34 <lambdabot> Source not found. Just try something else.
17:57:38 <dcoutts_> hpc: but yes, the natural unfold for an infinite stream type would be (s -> (s, a)) -> s -> [a]
17:57:54 <aristid> hpc: (>>=) is a class method and doesn't have only one implementation
17:58:11 <hpc> aristid: indeed the point i was driving at
17:58:16 <dcoutts_> hpc: which can be derived given the functor describing the stream type
17:59:19 <hpc> dcoutts_: i just noticed the similarity between Stream and State
17:59:29 <hpc> i feel like the ending of 2001
17:59:39 <interferon> kmc: i guess i see.  so the haskell runtime which executes the IO monad returned from main is what enforces order?
17:59:47 <kmc> interferon, yes, exactly
17:59:51 <aristid> :t let (.:) = ((.).(.)) in join .: fmap
17:59:53 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
17:59:54 <aavogt> @src IO
17:59:54 <lambdabot> Source not found. You untyped fool!
18:00:01 <aristid> hpc: there's your >>=
18:00:05 <aavogt> @src IO (>>=)
18:00:06 <lambdabot> m >>= k     = bindIO m k
18:00:07 <interferon> so it's extralingual
18:00:16 <kmc> interferon, notionally, by pattern-matching on some data type built up by (>>=)
18:00:30 <hpc> aristid: now define join >:3
18:00:46 <aavogt> forcing evaluation order is within the language. Side effects you control aren't
18:00:49 <aristid> @src join
18:00:50 <lambdabot> join x =  x >>= id
18:00:54 <aristid> hpc: :D
18:01:04 <hpc> :D
18:01:35 <kmc> interferon, it's extralingual in that the Report does not specify how IO values are represented, or how exactly they are executed
18:01:47 <kmc> and you could not implement it in portable pure Haskell without using IO already
18:02:05 <aavogt> who here writes H98?
18:02:33 <kmc> aavogt, i don't go out of my way to do so, but i don't end up using extensions in each and every project
18:02:36 <hpc> i think my code is H98... all i know is i don't use extensions or flags
18:02:48 <kmc> technically if you use module names with '.' in them, you're not H98
18:02:53 <kmc> but that's a tiny trivial thing
18:03:14 <aavogt> it's not for ambiguity
18:03:19 <Igloo> It's an approved addendum
18:03:22 <aavogt>  A.B.C.D
18:03:28 <Igloo> And in H2010, of course
18:03:30 <kmc> oh
18:03:37 <hpc> if i find i need an extension, i try and design a better solution first
18:04:02 <hpc> like, i almost needed RankNTypes until i found that a static-typed scenegraph is better form
18:04:05 <kmc> i think that perhaps the only really essential type extension is RankNTypes
18:04:20 <Philippa_> RankN and GADTs
18:04:36 <Philippa_> anything with type classes, you can do without
18:04:45 <kmc> GADTs can be emulated with somewhat less safe phantom-typing schemes, or with type classes (c.f. "finally tagless")
18:04:50 <kmc> it's not perfect but you get by
18:04:59 <kmc> RankN, or at least Rank2 is really essential,
18:05:02 <aristid> kmc: why not use GADTs?
18:05:10 <Philippa_> yeah, once you've got Rank2 you can encode
18:05:14 <kmc> and you can encode existentials with RankN
18:05:19 <kmc> aristid, i'm not saying don't use GADTs
18:05:23 <carter> i'm having a silly syntax error in instantiating  a Stream for a data type so I can us Parsec,  is the thie appropriate contxt to ask what i'm doing wrong?
18:05:29 <Philippa_> I'd sooner take GADTs as primitive than type classes for things that need GADTs
18:05:29 <carter> *can use parsc
18:05:38 <kmc> i'm saying that, if you want for whatever reason to avoid extensions, GADTs can usually be done without
18:05:48 <Philippa_> carter: sure, give us details
18:05:50 <kmc> whereas it's hard to get rid of RankNTypes
18:05:55 <kmc> when you need them
18:06:00 <carter> instance (Monad m) => Stream SimplePhrase m String where
18:06:00 <carter> 	    uncons (SPhrase [] [])  = return $ Nothing
18:06:00 <carter> 		uncons (SPhrase [] pn)  = return $ Just (pn,SPhrase [] [])
18:06:00 <carter> 		uncons (SPhrase (t:ts) []) = return $ Just (unNom t, SPhrase ts [])  
18:06:00 <carter> 	    uncons (SPhrase (t:ts) pnct )= return $ Just (unNom t,SPhrase ts pnct)
18:06:00 <kmc> e.g. runST
18:06:04 <carter> is my instance def
18:06:08 <kmc> carter, don't paste code here, use hpaste.org or codepad.org
18:06:13 <carter> ohh
18:06:13 <carter> ok
18:06:15 <aristid> :t runST
18:06:17 <lambdabot> forall a. (forall s. ST s a) -> a
18:07:01 <hpc> dependent types can be a nice extension
18:07:37 <Philippa_> yeah, it might be nice to experiment with dependent types with a simple "no IO, no unsafePerform*" rule
18:07:59 <Philippa_> but doing them well really wants a new language design
18:08:09 <Long> hi guys, what is the different between  [x,y] and (x,y)
18:08:24 * hackagebot functor-combo 0.0.3 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.0.3 (ConalElliott)
18:08:28 <Philippa_> one is a list, the other's a tuple
18:08:38 <hpc> [x,y] is a list of two things of the same type
18:08:43 <Philippa_> each tuple type has a fixed number of elements of (potentially differing) type
18:08:48 <Philippa_> hpc just covered lists
18:08:49 <hpc> (x,y) is a tuple of two things that could be different types
18:09:08 <hpc> (1, 'b')
18:09:14 <hpc> > (1, 'b')
18:09:15 <lambdabot>   (1,'b')
18:09:20 <hpc> > [1, 'b']
18:09:21 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
18:09:21 <lambdabot>    arising from the literal `1...
18:09:33 <Long> oh yes, i got it,   thanks a lot
18:09:36 <Gracenotes> lists go from head to tail. you can access any element of the tuple at any time (it's like a makeshift struct), you have to traverse a list to get its last element
18:13:02 <carter> hahah, turns out I hadn't configured textmate to convert tabs to spaces
18:13:16 <carter> thanks nonetheless
18:14:57 <carter> a related question: is ghci supposed to interpret a data type definition as a type synonym it has only one case?
18:15:06 <carter> if it has only once case?
18:15:08 <dmwit> no
18:15:20 <dmwit> data, newtype, and type are all different beasts
18:15:24 <carter> i know
18:15:42 <carter> ohh, but for type classes, will it complain if i use String rather than [Char]?
18:15:46 <dmwit> In particular: data introduces a "tag" that has different laziness properties, and newtype introduces a type that doesn't match the old one in type-checking.
18:15:51 <carter> i know :)
18:16:03 <dmwit> String is not a data type definition...
18:16:07 <carter> true
18:16:22 <dmwit> Anyway, it should complain about exactly the same things whether you use String or [Char].
18:16:32 <dmwit> (That's the whole point of a type synonym.)
18:17:04 <Phyx-> @src Char
18:17:04 <lambdabot> data Char = C# Char#
18:17:05 <carter> fact
18:17:09 <carter> thnkee
18:17:12 <Phyx-> ohh csharp
18:17:22 <carter> i know my plt, just rusty on my ghc errorr message skills
18:17:27 <carter> thanks!
18:18:05 <kmc> you need -XTypeSynonymInstances to declare a String instance, probably
18:18:26 <Phyx-> why isn't that in Haskell98 anyway?
18:18:38 <kmc> but you also need -XFlexibleInstances to do either String or [Char]
18:18:53 <kmc> because it's not of the form (T a b .. z)
18:19:05 <Philippa_> isn't there already a [tok] stream?
18:20:05 <carter> got those flag covered :), hackage -> text.parsec.String -> source code 
18:20:07 <Phyx-> kmc: right, but (And bare in mind, I haven't read the whole of H98) but why does it have to be T a b .. z
18:20:16 <kmc> well that's what the spec says
18:20:20 <kmc> as to why it says that, i'm not sure
18:20:30 <kmc> Haskell's type class design was somewhat conservative
18:20:41 <kmc> there's that paper "Type classes: exploring the design space"
18:20:51 <kmc> which describes more complicated systems which were known at the time
18:20:55 <kmc> (the paper predates Haskell 98)
18:20:55 <carter> my stream instance basically looks like Stream ([String], String) m String
18:21:07 <Phyx-> hmmm
18:21:16 * Phyx- would like to pick the brain of a commitee member
18:21:17 <aavogt> kmc: is there stuff there that's unimplemented?
18:21:20 <kmc> yes i think so
18:21:22 <kmc> like backtracking
18:21:38 <Phyx-> kmc: if you know, is it in H2010?
18:21:40 <Philippa_> there'll be things there that won't ever be implemented
18:21:42 <aavogt> so instance selection based on the head?
18:21:49 <kmc> is what Phyx- ?
18:21:58 <kmc> if you only allow (T a b .. z), then you can't have overlapping instances, unless they have identical heads
18:21:59 <Philippa_> the whole point is it's supposed to cover a whole bunch of options not all of which'll be desirable or desirable at once
18:22:02 <kmc> and so maybe that was desirable
18:22:12 <Phyx-> kmc: that you can have instances on forms of just T
18:22:13 <aavogt> err, context
18:22:26 <pswoo> whats my best bet for doing (perhaps limited) type inference in a lightweight manner?
18:22:38 <Philippa_> yeah, initially you didn't even have constructor classes so instances were fixed to types (as in, kind *)
18:22:39 <carter> does anyone know if Peng Li's thread/event code and the example TCP/IP stack code live on anywhere?
18:22:47 <carter> from ~ 4 years ago
18:22:50 <Phyx-> ghc doesn't match context anyway
18:22:54 <carter> i know the paper's still accessible
18:22:55 <carter> but
18:22:58 <carter> not sure about the code
18:22:59 <Philippa_> pswoo: learn a bit about constraint systems, work from there
18:23:01 <kmc> FlexibleInstances is not in H2010.  http://www.haskell.org/pipermail/haskell/2009-November/021750.html
18:23:25 <Phyx-> aww
18:23:33 <kmc> pswoo, read TaPL, it explains how to do type inference for STLC, as well as ML-style let polymorphism
18:23:35 <Philippa_> pswoo: hindley-milner type inference is basically equality constraints on types plus instantiation and generalisation
18:23:53 <Phyx-> "DoAndIfThenElse" wtf?
18:24:06 <Philippa_> kmc: yeah, but it's really, really bad for trying to learn about anything more complicated, and ATTaPL only really tells you more about more H-M-based stuff
18:24:24 <Philippa_> pswoo: local type inference is mostly about only using constraints that are 'locally' available
18:24:26 <kmc> the tiny summary of inference is that you write a type checker, but every time you would check that two types are equal, you instead bind each to a fresh unification variable and add an equation equating them
18:24:28 <napping> Philippa_: that allows if <expr> [;] then <expr> [;] else <expr>
18:24:33 <kmc> then after you've collected these equations, you unify them
18:24:35 <napping> Phyx-, rather
18:25:17 <Philippa_> kmc: well, you can solve as you go, and unification's just the solving strategy, and the general form is 'constraints' rather than equality
18:25:18 <aavogt> "you unify them"
18:25:29 <kmc> yeah true
18:25:38 <kmc> but in H-M you only have quality constraints, right
18:25:43 <Philippa_> equality, yes
18:25:46 <Phyx-> napping: hm? as in, you can for instance ommit the else?
18:25:48 <kmc> err yes
18:25:53 <pswoo> hm.. alright
18:25:56 <Phyx-> ah there's a link explaining
18:26:07 <Philippa_> aavogt: as in '[term] unification' ala prolog
18:26:08 <kmc> Phyx-, no, it's syntactic only, so that you're allowed to make "then" and "else" line up with "if" in layout
18:26:38 <Phyx-> kmc: oh ok.. did that really need fixing? :P
18:26:41 <napping> Phyx-: the new thing is the optional semicolons
18:26:42 <pswoo> but the situation is indended to be very limited
18:26:49 <napping> so you don't have to indend them in a do block
18:26:54 <Philippa_> pswoo: if you're dealing with a more complex type system you'll have to do some thinking about what kinds of constraints you can reasonably work with and solve. Sometimes it helps to reformulate a manifestly-typed version of the language in terms of the constraints it generates and checks first
18:27:42 <Phyx-> napping: ah, I've never actually run into that, I tend to use case expressions over ifs
18:27:56 <Philippa_> pswoo: most 'limited' setups do constraint solving as they walk the AST, if that helps any. But thinking in terms of constraints is the way to go, even if you don't use the concept directly in the code because you've fused them away (constraints getting generated and immediately solved)
18:28:34 <aavogt> Philippa_: well how you can say that some type is the most general one to fit all constraints seems to be the difficult part, not collecting up constraints
18:29:14 * aavogt has so far been content to use type inference without knowing the implementation
18:29:22 <Philippa_> aavogt: yes, kmc was covering H-M inference where it's solved by unifying and generalising on the unconstrained variables
18:29:40 <Philippa_> and "unifying" refers to a very well-documented algorithm that you can google yourself
18:30:14 <Philippa_> (and which pretty much corresponds to what you'd do solving an equation on terms on paper)
18:31:09 <Phyx-> HM is rather easy
18:31:13 <Philippa_> the only difference to dealing with 'ordinary' equations is that the values're tree-structured, and that's something you handle in the obvious recursive manner
18:32:28 <Philippa_> pswoo: it'd probably help if you asked more specific questions. That said, #haskell isn't actually about type systems
18:33:14 <pswoo> think i should decide just how thorough to be before i proceed.. the scope is very limited, had hoped i could do it in a few hundred lines max
18:33:26 <Philippa_> that depends on the type system involed
18:33:30 <Philippa_> *involved
18:33:40 <Philippa_> but hindley-milner is easy to do in that much code
18:34:23 <pswoo> Philippa: well the language at hand is haskell
18:34:30 <Philippa_> ah. All of it?
18:34:49 <Philippa_> there's a paper, Typing Haskell In Haskell, that'll get you a good chunk of the way there for something like H98
18:35:13 <Philippa_> if you want to do GHC haskell in that few lines, probably not - the constraints involved're fairly complex
18:35:24 <Philippa_> that, and GADTs complicate things somewhat
18:35:24 <pswoo> no.. specifically, take an expression - knowing types of some symbols but not all - infer the type of the expression's value. any needed symbols for which type is not known causes a failure and that's ok
18:36:04 <Philippa_> yeah, but do you care about type classes? MPTCs? Associated types?
18:36:08 <pswoo> found a page on haskell.org but the links are mostly dead
18:36:23 <Philippa_> read THIH, anyway
18:36:29 <pswoo> alright
18:36:40 <Philippa_> (what's this for?)
18:37:21 <pswoo> the string is not assumed to lie in any context other than the known symbols (practically, maybe 3 or 4) and Prelude (maybe not even all of that)
18:37:37 <pswoo> code generation
18:38:03 <pswoo> (specifically parser generation)
18:38:23 <Philippa_> why do you need to do type inference for that?
18:38:41 <Philippa_> Prelude's enough to pull type classes in, anyway
18:38:44 <pswoo> are you familiar with Pappy?
18:39:03 <Philippa_> not particularly - was that the PEG/packrat one?
18:39:29 <Philippa_> you might be better off using the GHC API if you can, anyway
18:39:57 <pswoo> yeah. anyway, in packrat parsing you need to pass around the derivations matrix and the type of nonterminals needs to be known to construct it
18:40:05 <pswoo> i'll look into that
18:40:26 <Philippa_> ah, because you have to make a type declaration for it. That's a PITA, yeah
18:40:36 <pswoo> mhm
18:40:52 <pswoo> but not for proper nonterminals - the grammar author can just declare those
18:40:52 <Philippa_> personally I'd just force the user to supply annotations, but I'm a lazy bitch like that :-)
18:41:16 <pswoo> its star and plus rules that are the PITA
18:41:34 <pswoo> they need to be rewritten as nonterminals behind the scenes
18:42:02 <pswoo> (or you lose linear time parsing)
18:42:22 <pswoo> and for THAT you need to resolve the type of the rule under the star/plus
18:48:52 <carter> couldn't you alternatively use the GHC as a library functionality ?
18:49:11 <carter> if its Haskell 98?
18:49:46 <pswoo> im reading the API atm
19:33:24 <lispy> Philippa_: IIRC, type checking for dependent types is simpler than gadt type checking in hasklel
19:34:17 <Philippa_> not by much with the current approach, and there's a lot more to having a good dependently-typed language than pushing yourself to the other side of the lambda cube
19:34:32 <pickles> nite all
19:40:24 <dolio> To get GADTs, you need to check inductive families for your dependently typed language.
19:40:38 <dolio> Which is a lot more of a hassle than the calculus of constructions.
19:46:13 <dolio> Of course, dependently typed languages frequently worry about termination, so that adds a lot of the complexity to checking inductive families.
19:48:23 <Veinor> > atanh 1
19:48:24 <lambdabot>   Infinity
19:48:27 <Veinor> > atanh (-1)
19:48:28 <lambdabot>   NaN
19:48:35 <Veinor> why isn't it -Infinity?
19:50:13 <dolio> > atanh (-0.9999999)
19:50:14 <lambdabot>   -8.405621391042292
19:50:22 <dolio> > atanh (-0.999999999999999)
19:50:23 <lambdabot>   -17.616361586450413
19:50:27 <dolio> > atanh (-0.99999999999999999999)
19:50:28 <lambdabot>   NaN
19:51:10 <dolio> > atanh (-1 :: Float)
19:51:10 <lambdabot>   NaN
19:51:23 <dolio> Blame IEEE, I guess.
19:51:47 <Veinor> yeah, but I think that IEEE would say that it should be -Infinity
19:52:25 <Veinor> like, c does it as -Infinity I think
19:55:23 <lispy> > atanh ( -1 :: CReal )
19:55:27 <lambdabot>   mueval-core: Time limit exceeded
19:55:35 <dolio> Well, that's not going to work.
19:56:17 <Phyx-> To atanh 1 and beyond!
19:56:23 <Phyx-> hmm just doesn't have the same ring to it
19:56:35 <ddarius> dolio: Well you should make it, and don't give me that halting problem line.  We think solutions here, not problems!
19:56:48 <Phyx-> @src atanh
19:56:48 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:57:14 <Phyx-> what class specifies those?
19:57:19 <Veinor> @src Float atanh
19:57:20 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:57:22 <Veinor> @src atanh Float
19:57:23 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:57:23 <dolio> ddarius: I could probably make a value that converged to 1, and get back a value that progressively diverges.
19:57:30 <dolio> I'm not sure if CReal exposes enough to do that, though.
19:57:46 <lispy> ddarius: The halting problem is not real.  The british gov't paid Turing to make that up so we would have a reason to go to war with Germany.
19:57:48 <Veinor> atanh is in Floating
19:58:09 <Veinor> ugh, why are the source links on half the pages I get back from hoogle broken :/
19:58:11 <Veinor> like on http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Prelude.html#t%3ADouble
19:59:15 <Veinor> okay, it's not broken
19:59:27 <ddarius> lispy: Well it worked except that the German trickery continues.
19:59:30 <Veinor> anyway,     atanh x = log ((x+1.0) / sqrt (1.0-x*x))
20:00:33 <dolio> @type CR
20:00:33 <lambdabot> Not in scope: data constructor `CR'
20:00:36 <Phyx-> @src Float CReal
20:00:37 <lambdabot> Source not found.
20:00:44 <Phyx-> @src CReal Float
20:00:44 <lambdabot> Source not found. Do you think like you type?
20:00:54 <Veinor> so when x = 1, that becomes log (2.0 / 0.0) which is obviously +Infinity, and when x = -1, it becomes log (0.0 / 0.0)
20:00:55 <lispy> Floating
20:01:12 <dolio> Nope, CReal doesn't let you construct CReals except via arithmetic and constants.
20:01:20 <Phyx-> @src CReal Floating
20:01:20 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:01:26 <Phyx-> @src Floating CReal
20:01:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:01:28 <Veinor> which should be NaN
20:01:32 <Phyx-> it hates me :/
20:01:50 <ddarius> Phyx-: It doesn't have the source.  CReal isn't anywhere near standard.
20:02:46 <lispy> C for Continuous?
20:02:47 <eduardohf> someone from brazil?
20:03:02 <lispy> eduardohf: No, but I've heard they drink a lot of coffee in brazil
20:03:06 <ddarius> lispy: "Computable" presumably.
20:03:32 <eduardohf> coffee :)
20:03:33 <lispy> ddarius: Sort of ironic that using them doesn't terminate then
20:03:43 <Phyx-> ddarius: lol
20:04:12 <ddarius> eduardohf: There are quite a few people from Brazil in the Haskell community.  There may be a localized channel for Brazilian Haskellers as well.
20:04:16 <Phyx-> @src Floating Float
20:04:16 <lambdabot> Source not found. My pet ferret can type better than you!
20:04:22 <Phyx-> @src Float Floating
20:04:22 <lambdabot> Source not found. Do you think like you type?
20:04:27 <Phyx-> meh
20:04:56 <ddarius> Phyx-: @src is populated with an arbitrary selection of hand entered programs.
20:05:05 <eduardohf> ddarius: I will try to find some channel
20:05:13 <lispy> In SMP concurrent programming you can use locks because everything shares memory.  Are there forms of non-shared memory concurrency that have some form of locking or otherwise deciding who gets to modify something?
20:05:14 <eduardohf> ddarius: thanks!
20:05:37 <ddarius> eduardohf: There is/was a #haskell.pt though I don't know how active it is.
20:05:48 <Phyx-> ddarius: oh, thought it was just grabbing things from source
20:06:58 <ddarius> lispy: You can use locks in a distributed scenario as well, it's just more silly.
20:08:28 <lispy> ddarius: I'm specifically interested in concurrency models that don't have a central authority to enforce serialization around the lock
20:08:50 <lispy> But that still provide some mechanism for dealing with contention
20:11:16 <lispy> I noticed that all VCS I know of support optimistic 'locking', that is the STM style.  You try the computation and the first person to write to a shared value wins and everyone else must retry.  Some VCS also support pessimistic locks, like CVS/SVN where files can require you to take the lock first.  I don't think DVCS have a notion of pessimistic lock.
20:11:27 <lispy> It seems that if such a notion exists, that distributed concurrency already has it
20:13:38 <ddarius> lispy: Nothing keeps a repo from giving out a revokable capability to write to only the first comer until that user says they're done.
20:14:44 <ddarius> Also, STM is not inherently optimistic.
20:15:35 <lispy> ddarius: Well in dvcs you don't know if other repos exist until you merge, typically
20:16:09 <lispy> ddarius: So, afaict, there isn't a way to globally say, "Hey, no one can get write access to this until I'm done."
20:17:56 <ddarius> lispy: There should be some entity (concurrent process) that mitigates access to a particular repo.  No one should be able to write to the repo without a write capability.  If you don't have that write capability (which is a thing not a "permission"), then you can't write to the repo.  There's no need to ask anyone else anything.
20:19:34 <ddarius> s/mitigate/mediate/
20:20:45 <lispy> No I don't think that's the solution at all :)
20:21:11 <lispy> I'm talking about locking at the granularity of files and/or lines of files.  Not repository wide
20:21:46 <ddarius> lispy: This can be applied at the level of files or lines of files (though the latter might get heavy-weight.)
20:22:12 <lispy> ddarius: maybe we should take this to blah
20:23:22 <lispy> ddarius: the reason the locking works well for svn is because your local copy is read-only until you request the lock.  Once you request it you have it until your next commit.
20:23:48 <lispy> I suspect there just isn't a way to have pessimistic locks for dvcs
20:29:23 <ddarius> lispy: What you're saying doesn't make sense to me.  I suspect I'm misapprehending some aspect of the scenario(s).
20:34:37 <etpace> hmm
20:35:30 <etpace> I've got a function that is supposed to delay for a certain amount of time, but i think the calculation needed for that delay is significant, i'm trying to find out the actual dealy (rather than the one called to threaDelay) by diffing getCPUTime, but it doesnt seem to be working
20:35:37 <etpace> any ideas?
20:44:52 <dibblego> http://paste.pocoo.org/show/242924/ does this function exist in the libraries/hackage?
20:45:30 <interferon> is there a function "Chan a -> IO [a]" that atomically empties a channel and returns its contents?
20:46:27 <interferon> i want to build an order queue that can store orders as they accumulate and then, after a period of time has passed, all those orders will be processed as a unit and the queue will start accepting orders again
20:52:53 <tg_> double buffering?
20:53:48 <BMeph> interferon: Control.Concurrent.Chan.getChanContents
20:54:08 <interferon> BMeph: i see that, but i don't think it empties the channel
20:54:53 <interferon> is there some other concurrency primitive that's better for me?  maybe just an "MVar [Order]" into which i add orders one at a time and then empty out when i'm ready to process?
20:54:56 <BMeph> interferon: Well, that depends on what you mean by "empty"...y'see, laziness twists that up a bit... ;)
20:54:58 <interferon> tg_: is that for me?
20:55:21 <tg_> interferon: i'm just babbling.
20:55:31 <tg_> that just sounds like what you're doing
20:55:50 <interferon> BMeph: the concurrency functions have ordering guarantees, they're in IO
20:56:02 <BMeph> interferon: But, yeah, for your purposes, I'd use an MVar [Orders].
20:56:05 <interferon> tg_: i'm making a very simple simulation of a stock exchange as a learning exercise
20:56:17 <interferon> BMeph: yeah i think that would work.  thanks!
20:56:57 <BMeph> interferon: The ordering is not an issue. The issue is this: if you plan to put more orders into the channel, how does it know when you've put them all in, so that it can tell you that you've gotten them all out? ;)
20:57:12 <interferon> BMeph: because it's atomic
20:57:31 <BMeph> interferon: Atomicity is not the issue. Laziness is the issue.
20:57:38 <interferon> BMeph: oh i see what you're saying
20:57:44 <BMeph> ... :)
20:58:12 <BMeph> interferon: That's why I think the MVar will work better for your purposes.
20:58:35 <interferon> BMeph: but i don't think laziness is an issue here.  the list elements themselves might be thunks but the addition of an item to the list should happen in order
21:04:20 <interferon> :type modifyMVar
21:05:00 <interferon> @type modifyMVar
21:05:02 <lambdabot> Not in scope: `modifyMVar'
21:05:49 <interferon> @type Control.Concurrent.MVar.modifyMVar
21:05:51 <lambdabot> forall a b. GHC.IOBase.MVar a -> (a -> IO (a, b)) -> IO b
21:06:52 <interferon> so that's a weird type
21:07:07 <interferon> i'm returning a tuple of the original contents, and the new contents?
21:09:15 <raceRider> I have a newbie State Monad and REPL question at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28334#a28334
21:10:52 <pastorn> raceRider: the state is not a variable like in other languages
21:10:59 <pastorn> the state is solely dependent on the input
21:11:48 <pastorn> raceRider: try addOne 99 + addOne 99
21:12:21 <raceRider> pastron: I get 200, which is correct
21:13:03 <pastorn> ok, addOne 9 + addOne 99
21:13:08 <raceRider> pastorn: so this state is unlike let, which in REPL is maintained
21:13:36 <interferon> raceRider: the state is recreated on each call to execState
21:13:43 <raceRider> I  get 110, which is also corect.
21:14:02 <pastorn> raceRider: and if you run it again, without reloading?
21:14:15 <raceRider> still 110
21:14:18 <pastorn> right
21:14:23 <pastorn> see, no state is maintained
21:14:36 <interferon> pastorn: the state is maintained within the execState call
21:14:46 <raceRider> I see what you're saying. Important tidbit I missed
21:14:48 <pastorn> the State monad is just a convenience construct for handling variables
21:14:59 <interferon> sorry that was meant for raceRider :)
21:15:15 <raceRider> thx pastorn
21:15:18 <interferon> raceRider: the State name is somewhat misleading
21:15:28 <raceRider> yes I see that now
21:15:51 <interferon> raceRider: if you really want something that will persist across function calls, you need to use IORefs in the IO monad
21:15:58 <interferon> raceRider: but that is not The Haskell Way
21:16:09 <raceRider> what is the Haskell way then?
21:16:28 <pastorn> raceRider: lots of small, pure functions :)
21:16:42 <raceRider> Besides IORefs, I mean, to persist 
21:16:44 <pastorn> raceRider: you might use IORefs/MVars etc. for performance
21:17:01 <pastorn> raceRider: well, use the State whenever you can :)
21:17:10 <interferon> raceRider: to avoid global state
21:17:41 <interferon> raceRider: in this case, there's no need for state at all.  "tick n = n + 1"
21:17:43 <pastorn> raceRider: if you *really* want a global variable, of type 'a' you can do something like this:
21:18:25 <pastorn> myGVar = unsafePerformIO $ newIORef initValue
21:18:34 <pastorn> {-# NOINLINE myGVar #-}
21:18:37 <interferon> unclean, unclean!
21:18:40 <pastorn> indeed
21:18:50 <raceRider> I need something that keeps a running value all day while data is being captured, parsed, and acted upon in different threads. I wanted to do this in Haskell for a change
21:18:52 <pastorn> but it can clean up some type signatures :)
21:19:09 <pastorn> raceRider: i'd recommend Chans
21:19:19 <raceRider> Chans?
21:19:35 <interferon> raceRider: look at Chans, MVars and TVars
21:19:38 <pastorn> @where Chan
21:19:39 <lambdabot> I know nothing about chan.
21:19:39 <interferon> raceRider: book.realworldhaskell.org
21:19:48 <raceRider> okay
21:19:51 <pastorn> raceRider: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Concurrent-Chan.html
21:20:08 <pastorn> raceRider: a Chan is a double linked list, of sorts
21:20:14 <pastorn> one writing end and one reading end
21:21:02 <raceRider> FIFO?
21:21:03 <pastorn> so you fork off your workers and they use writeChan when they have something done, then in some other thread you use readChan to get them, in FIFO order
21:21:25 <raceRider> that's what I was looking for.
21:21:44 <pastorn> raceRider: though i'm not entirely clear about what happends if you use dupChan, but i'm sure someone here must know
21:22:11 <raceRider> let me take a stab at it first, thanks for the help
21:22:46 <pastorn> raceRider: for example, this lite (i have it in main) gives me all keypresses in a (Chan Char)
21:22:51 <pastorn> forkIO $ forever (getChar >>= writeChan chan)
21:23:47 <BMeph> pastorn: Haskell's answer to "tee". :)
21:23:49 <raceRider> cool
21:24:02 <pastorn> BMeph: wut?
21:25:15 <interferon> pastorn: a unix command that splits text into two commands
21:25:18 <BMeph> pastorn Sorry, I meant: 'tee(2)'. ;)
21:26:09 <pastorn> tee seems very identity-stream-like
21:27:13 <peddie> anyone got a sec for a cabal problem?  ghc --version gives 6.12.3 as I expect; cabal refuses to install the 'vector' package because it can't find a version of ghc >= 6.9
21:29:35 <BMeph> peddie: How are you installing the package?
21:29:54 <peddie> "cabal install vector"
21:30:32 <BMeph> peddie: Okay, just making sure. Next Q: when was the last time you did a "cabal update"?
21:31:00 <peddie> about 10 seconds after it gave me the error for the first time :)
21:32:33 <BMeph> paddie: Heh-heh, fair enough. :)
21:32:41 <peddie> so "ghc-pkg list" shows vector as being broken; also if I type "cabal list ghc" it seems to have the correct version
21:32:55 <peddie> don't know if either of those is useful
21:33:20 <pastorn> raceRider: PM
21:33:36 <BMeph> paddie: ghc-pkg recache?
21:34:17 <peddie> hmm, no luck (same error)
21:35:58 <BMeph> paddie: Is it (vector) in two or more depos?
21:36:36 <peddie> sorry, not sure what you mean by "depos"
21:37:06 <BMeph> The "package.conf.d" listings when you do a "ghc-pkg list".
21:37:12 <peddie> oh
21:38:20 <peddie> ah, so it's currently installed only for user
21:39:47 <BMeph> paddie: Even better, then. "ghc-pkg unregister" and then re-do the "cabal install".
21:40:34 <BMeph> paddie: ...as well as any other packages it complains about, when you do the unregister. ;)
21:41:02 <peddie> BMeph: same error after vector is unregistered.  do you mean that I should unregister everything it considers broken?
21:44:05 <BMeph> paddie: Let's see what the errors say - could you put it on hpaste, please?
21:46:03 <peddie> 28336
21:46:24 <peddie> peddie@alqamar:math(master☠)$ cabal install vector
21:46:26 <peddie> Resolving dependencies...
21:46:28 <peddie> cabal: cannot configure vector-0.6.0.2. It requires ghc >=6.9
21:46:30 <peddie> There is no available version of ghc that satisfies >=6.9
21:46:32 <peddie> oops, sorry
21:53:43 <peddie> BMeph: any ideas?  I haven't found exactly where the check occurs or where I might be able to override it
21:55:46 <peddie> BMeph: also ghc-6.12.3 is listed as being a broken package; perhaps I am really out of luck and have to reinstall everything?
21:57:57 <JoeyA> How would I do something like this?  http://codepad.org/x7Lsnm3K
21:58:21 <JoeyA> The idea is, data Foo a is something that, when "extracted", results in an a.
21:58:39 <ezyang> JoeyA: Why "special"? 
21:58:43 <JoeyA> But one of the possible types of Foo only extracts to result in one type.
21:58:52 <ezyang> I bet you want a show a 
21:59:02 <ezyang> but that's not clear 
21:59:07 <JoeyA> This is a simplified example of what I'm doing.
21:59:31 <JoeyA> Granted, I could say Special a and make a function called special that produces Special "special"
22:00:05 <JoeyA> The problem is, I can't just attach data to it like that because it's coming from somewhere else.
22:01:10 <JoeyA> This might be a clearer example:  http://codepad.org/H7h2rCOC
22:02:01 <JoeyA> It's like I want to be able to say data Foo a = Thing a; data Foo String = Special String
22:06:32 <JoeyA> Hmm, here's a workaround:  http://codepad.org/Br5QVSZM
22:06:41 <JoeyA> Not entirely sure it does what I want yet.
22:08:11 <JoeyA> It's a bit awkward because (suppose) I want (++ " is special") to be part of extract's logic.  I have to hide it in an ancillary constructor (which is fine), but it seems like I could do better.
22:08:37 <alex_kidd> i found out today by trying it that you can shift tab backwards on internet forms
22:08:48 <alex_kidd> it made me so (sadly) happy
22:09:13 <JoeyA> heh
22:14:35 <JoeyA> Here's another way to put it:  http://codepad.org/rYrN0tVi
22:16:03 <JoeyA> Although Thing applies to constructing polymorphic Foos, Special only applies to constructing Foos of type String.
22:16:13 <JoeyA> (parameterized with type String, that is)
22:17:09 <JoeyA> Special only deals in String; if in Foo a, a is not a String, but the Foo in question is a Special, it doesn't make sense (and the public API will ensure you cannot construct one)
22:19:48 <JoeyA> Hmm, but if I drop in a (String -> a) function that's set to id, it may be a nonissue.
22:46:33 <etpace> What's the best way to round a double to one decimal point?
22:46:55 <etpace> > read $ printf "%.1f" 1.53
22:46:56 <lambdabot>   *Exception: Prelude.read: no parse
22:47:45 <lispy> > read $ printf "%.1f" 1.53 :: Double
22:47:46 <lambdabot>   1.5
22:47:50 <ulfdoz> round (pi * 10) / 10.0
22:48:05 <lispy> ulfdoz: that's not actually guaranteed
22:48:15 <ulfdoz> uh? why?
22:48:25 <lispy> floating point division is inexact
22:48:44 <lispy> You could get 3.139999999
22:48:51 <lispy> or some such non-sense
22:49:07 <ulfdoz> oh, yes. sounds reasonable.
22:49:48 <etpace> > (1000*) $ (read $ printf "%.1f" 1.53 :: Double)
22:49:49 <lambdabot>   1500.0
22:53:26 <mlh> adding 0.5 and truncating I think is the usual way
22:58:32 <ArchGT> I'm new to haskell & xmonad and i'm having trouble understanding this line on a .xmobarrc file:        , commands = [ Run Weather "EGPF" ["-t"," <tempF>F","-L","64","-H","77","--normal","green","--high","red","--low","lightblue"] 36000
22:59:11 <ArchGT> what's the "EGPF" value?
22:59:30 <Veinor> Ask #xmonad ?
23:00:21 <ArchGT> so it's not a haskell expression?
23:01:23 <lispy> ArchGT: it is haskell
23:01:33 <Veinor> it is haskell, but not everybody in here uses xmonad
23:01:53 <lispy> I use xmonad but I don't know what xmobar is
23:01:59 <lispy> never used it
23:02:19 <p_l> and the "EGPF" in question is actually airport code
23:03:18 <ArchGT> ok, thanks
23:04:03 <etpace> it's not actually haskell iirc, more like psuedohaskell
23:05:07 <MasseR> ArchGT: EGPF is an ICAO code used in aeronautics to designate airports
23:05:19 <MasseR> EGPF seems to be Glasgow International
23:05:58 <ArchGT> o.0
23:06:51 <p_l> ArchGT: simply, that line pulls weather from the airport and displays it according to parameters. #xmonad might know how to understand those
23:06:58 <ArchGT> so it calls a command named Weather with the parameter "EGPF"
23:07:23 <p_l> a built-in command
23:07:31 <ArchGT> oh
23:08:25 <ArchGT> thanks
23:13:18 <Ivo__> for filter :: (a -> Bool) -> [a] -> [a], is that saying that filter takes a function that maps values to booleans, then makes that function a list and returns a list of that function :S
23:13:28 <Ivo__> bit confused
23:14:38 <cabbage`> I believe it will return the subset of the list for which the function returns true
23:14:56 <Ivo__> oh no; it takes a function that maps on to a list, and spits out a function that maps from some list to some list
23:15:23 <Ivo__> (just looking at what the general type descriptions mean)
23:15:30 <Ivo__> do you ever have more than three arrows?
23:15:44 <cabbage`> well this function basically takes two arguments, the first is a function and the second is a list
23:16:09 <cabbage`> and it returns the result of applying that function to every element of the list and yielding only those for which the function returned true
23:16:41 <Ivo__> you do you garner, from its type definition, that it takes two arguements?
23:16:45 <cabbage`> well
23:16:51 <cabbage`> you could just apply it to a single argument, a function
23:17:21 <cabbage`> and then you'd have a partially applied (curried) function that takes a list and returns a filtered list. 
23:17:40 <cabbage`> basically in some sense all functions just take a single argument
23:18:22 <Ivo__> do you ever have 'actualy' 2 argument functions? or is it always the result of currying?
23:18:35 <cabbage`> i'm pretty sure it's always just currying
23:18:40 <cabbage`> unless you consider taking a tuple to be two arguments
23:18:41 <Ivo__> ok cool
23:18:51 <Ivo__> ty cabbage` 
23:18:53 <cabbage`> np
23:20:32 <Ivo__> what's the difference between -> and =>
23:21:35 <Veinor> => is used for typeclasses, -> is used for types
23:21:49 <Veinor> so (Eq a) => a -> a -> Bool
23:22:20 <Veinor> the (Eq a) on the left of the => is a restriction on the types that can be substituted for a
23:25:40 <scotty> Has anyone used Data.Binary?  I have a problem with the ByteString type.  After importing Data.Binary and Data.ByteString, if I put "ByteString" in my function signature, I get "Couldn't match expected type 'ByteString' against inferred type 'Data.ByteString.Lazy.Internal.ByteString'".  However, if I use this type instead, it says the type constructor is not in scope.
23:29:15 <scotty> Nevermind, I got it!
23:29:25 <Veinor> what was the problem?
23:35:55 <PetRat> Confusion to be found here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28339#a28339
23:36:19 <PetRat> Trying to understand something very clever Douglas Auclair does with StateT on []
23:42:02 <PetRat> Confusion to be found here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28339#a28339
23:42:03 <PetRat> Trying to understand something very clever Douglas Auclair does with StateT on []
23:42:31 <scotty> Veinor: I needed to import Data.ByteString.Lazy.Internal
23:42:49 <Veinor> ah
23:43:13 <dolio> PetRat: list has type [a], but you're trying to use it as if it had type StateT [a] [] a.
23:43:37 <dolio> Because action in that do block in choose' has that type.
23:44:00 <scotty> How in your data constructor can you specify a type that belongs to a certain type class?
23:46:46 <PetRat> dolio: I suspected that was the problem, but how to I access the inner monad (if that is the right way to put it)?
23:46:51 <RayNbow> hmm, http://lambda-the-ultimate.org/node/4026  <--  this book looks nice :)
23:46:59 <RayNbow> (not yet published though :()
23:55:01 <dolio> PetRat: Look into 'lift'.
23:56:24 <PetRat> dolio: I'm familiar with some uses of lift, but I don't know how to apply that in my current situation or where I would look to find this information
23:56:54 <dolio> @type (lift [1,2,3] :: StateT s [] Int)
23:56:55 <lambdabot> forall s. StateT s [] Int
23:58:03 <scotty> If I want to define a type that is either an instance Num, or a list of instances of Num, how would I do that?
23:58:06 <PetRat> holy smokes it works if you just put lift in front of the list variable
