00:00:05 <gwern> tehgeekmeister: maybe it slows down and works incrementally or perhaps it all fits in memory and ghc just isn't GC'ing very often
00:00:05 <CakeProphet> and it only has 6 concepts. :)
00:00:06 <Cale> tehgeekmeister: I'm going to try installing bytestring-trie and using that, and see if it's any better.
00:00:41 <Wolfspaw> CakeProphet: nah, i prefer more concepts and more expressiveness for diving into the deepness xD
00:00:43 <Figs_> CakeProphet: You'd probably like OISC then.
00:00:48 <CakeProphet> @src ,[..,]
00:00:49 <lambdabot> Source not found. It can only be attributed to human error.
00:00:54 <tehgeekmeister> Cale: btw, it just runs faster using sets in ruby, still uses 300mb of ram.
00:00:57 <CakeProphet> Figs_:  subtract and branch if zero. :)
00:01:04 <tehgeekmeister> (330, actually.)
00:01:04 <CakeProphet> @bf ,[..,]
00:01:04 <Figs_> precisely.
00:01:04 <lambdabot>  Done.
00:01:22 <CakeProphet> no input for bf?
00:01:32 <Figs_> actually no
00:01:37 <Axman6> @bf ,[..,]
00:01:38 <lambdabot>  Done.
00:01:42 <Figs_> subtract and branch if negative
00:02:12 <Figs_> I'd have to think for a while about subzero.
00:02:18 * tehgeekmeister wonders why it should take 10x the memory to put things in a set instead of listing them.
00:03:09 <gwern> tehgeekmeister: building a tree? as opposed to what might be an array in memory
00:03:22 <CakeProphet> Figs_:  I my IRC nick lives in #esoteric too. :) I am an enthusiast.
00:03:27 <Axman6> Sets aren't very memory efficient
00:03:38 <tehgeekmeister> gwern: right, i'm aware the tree adds overhead.  i just wouldn't have imagined it'd be nearly that much.
00:03:42 <Cale> tehgeekmeister: Got it down to ~50MB with bytestring-trie
00:03:51 <tehgeekmeister> Cale: w00t!
00:04:08 <Figs_> CakeProphet: We may have talked there in the distant past.
00:04:56 <Figs_> (I haven't been on IRC much for the last year or more for some reason.)
00:04:57 <CakeProphet> probably. It's been a few years but I've started logging into freenode again.
00:07:06 <shapr> How's the invasion?
00:07:37 <CakeProphet> shapr:  coming along fine. Maybe Haskell will hit mainstream now. :P
00:07:55 <dolio> It wasn't mainstream before?
00:07:56 <shapr> I think it already has, but maybe that's just compared to ~9 years ago.
00:08:06 <CakeProphet> hmmm, I suppose so
00:08:08 <CakeProphet> I meant in industry.
00:08:24 <shapr> CakeProphet: 9 years ago, it was an esoteric language.
00:08:42 <CakeProphet> shapr:  it's certainly come up, but I would still say it's fairly "underground".
00:09:41 <CakeProphet> but I'm comparing it to C and Java.
00:09:52 <CakeProphet> it's certainly at the top of the list, at this point.
00:10:17 <plotti> hi
00:10:19 <plotti> hi
00:10:23 <dolio> I'm not sure getting linked on reddit pute you at mainstream status, either.
00:10:25 <shapr> Hi plotti, learning Haskell?
00:10:30 <plotti> yap
00:10:33 <plotti> :)
00:10:38 <shapr> plotti: Got any questions?
00:10:50 <CakeProphet> dolio:  ha, it wasn't meant to be taken literally. :)
00:10:57 <plotti> the syntax looks a bit like ruby
00:11:15 <shapr> Hm, yeah... but no explicit end.
00:11:16 <CakeProphet> I guess the operators could give that impression?
00:11:29 <shapr> And whitespace is significant.
00:11:34 <plotti> true
00:11:50 <shachaf> Haskell syntax looks like Ruby?
00:11:59 <plotti> if i have some questions i will come back to you, have a nice day 
00:12:00 <plotti> no
00:12:03 <plotti> not really
00:12:08 <shapr> plotti: Ok, feel free to ask any questions.
00:12:16 <tehgeekmeister> Cale:  these tries don't seem to like lazy bytestrings?
00:12:18 <shachaf> I like Haskell syntax and don't mind Ruby (though I don't like the end), but I think of them as very different.
00:12:24 <shapr> @yow !
00:12:24 <lambdabot> Couldn't find fortune file
00:12:34 <shapr> @quote
00:12:34 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
00:12:37 <Figs_> What exactly are you guys trie-ing?
00:12:43 <shapr> I should have fixed that bug years ago :-(
00:12:57 <shachaf> @quote
00:12:57 <lambdabot> psychobot says: "),... on in the problem gibber, where your large egg yolks."
00:13:23 <shapr> That bug is in the original version of the Quote.hs plugin :-/
00:14:10 <gwern> @quote gwern
00:14:10 <lambdabot> gwern says: [wrt dons dissertation/defense being due shortly] 'I am half-raptor, and know neither fear nor fatigue.'
00:14:34 <gwern> @quote gwern
00:14:34 <lambdabot> gwern says: [regarding the naming of Monoids] we will call them CuteFluffableThings, since you can put more fluff into them, but no one would remove fluff from a cute thing
00:14:40 <shachaf> gwern: I believe that is considered bad form.
00:14:50 <gwern> fine
00:14:52 <gwern> @quote shachaf 
00:14:52 <lambdabot> shachaf says: monochrom: Emacs is also a joke. :-)
00:14:54 * shachaf is just bitter that his only entry in @quote is a stupid clich√© joke.
00:15:02 * gwern doesn't think that's funny either
00:15:09 <arch1> hello to all: i.ve a query : is possible trace a function recursive 
00:15:14 <gwern> shachaf: maybe you just aren't blessed with any wit
00:15:17 <shachaf> @forget shachaf monochrom: Emacs is also a joke. :-)
00:15:17 <lambdabot> Done.
00:15:20 <shachaf> @flush
00:15:20 <lambdabot> Not enough privileges
00:15:27 <gwern> @flush
00:15:55 <tehgeekmeister> what does one do about type errors where Data.ByteString.Internal.ByteString doesn't match Data.ByteString.Lazy.Char8?
00:16:07 <shapr> arch1: Yes, it is possible, assuming I understand your question.
00:16:19 <shachaf> @admin + shachaf
00:16:21 <shachaf> @flush
00:16:24 <shachaf> @admin - shachaf
00:16:58 <arch1> ok shapr : how i can trace the function:  permutationsOf xs = [x:xs' | x <- xs, xs' <- permutationsOf (delete x xs)]
00:17:00 <aavogt> tehgeekmeister: you have to convert it to a strict bytestring
00:17:16 <aavogt> or perhaps find a version of your trie that uses lazy bytestrings
00:17:23 <tehgeekmeister> aavogt: can one test equality between strict and lazy bytestrings?
00:17:27 <tehgeekmeister> if so, that's absolutely fine
00:17:28 <gwern> tehgeekmeister: strict->lazy is toChunks, lazy->strict is fromChunks
00:17:39 <gwern> or something like that
00:17:43 <aavogt> mmm, chunks
00:17:52 <gwern> it's bad for performance to convert
00:17:58 <shapr> arch1: Sadly, it's bedtime, and my brain is off :-( but I know it's possible.
00:18:11 <shachaf> arch1: Paper and pencil.
00:18:18 <tehgeekmeister> yeah, i can read it in as strict, that's fine, just so long as i can compare lazy and strict bytestrings
00:18:52 <arch1> shapr : thank  
00:18:59 <aavogt> arch1: permutationsOf xs = [x:xs' | x <- xs, Debug.Trace.trace "something happened" True, xs' <- permutationsOf (delete x xs)]
00:19:26 <aavogt> but you can put some other string in there
00:20:46 <tehgeekmeister> nope, you can't compare them.  boo.  =/
00:20:49 <tehgeekmeister> not without converting
00:20:51 <arch1> shachaf : ok for  pencil but if the function is complex nested is not simple and a trace can help 
00:21:31 <arch1> aavogt : thank 
00:21:59 <Figs_> tehgeekmeister: What exactly are you trying to do, anyway?
00:22:18 <tehgeekmeister> linking words to their wiktionary definitions, at this stage
00:22:31 <tehgeekmeister> in a text file
00:22:35 <tehgeekmeister> well, html
00:22:47 <tehgeekmeister> it starts text, turns into badly formatted html
00:23:22 <Figs_> So you're trying to test if a word is in the dictionary before linking to it?
00:23:36 <Figs_> Or am I completely misunderstanding?
00:24:13 <Cale> tehgeekmeister: Oh, you're trying bytestring-trie?
00:24:37 <tehgeekmeister> Cale: yep
00:25:09 <tehgeekmeister> i'll have to convert every word from a lazy to a strict bytestring to do this
00:25:13 <tehgeekmeister> or use strict bytestrings the whole way
00:25:19 <Cale> tehgeekmeister: Do you have another lazy bytestring which you're comparing with? You can read the list as a strict bytestring and turn it into a trie without using too much memory 
00:25:44 <tehgeekmeister> yeah, i have another lazy one i compare to.  but it's not huge either, i could probably get away with strict.
00:26:01 <tehgeekmeister> eventually there may be large ones, but that's a very distant eventually
00:26:23 <tehgeekmeister> actually, no, there'll just be lots of small ones, never big ones.  yeah, i'll just use strict.
00:26:57 <Figs_> tehgeekmeister: Are you using the trie to check if a word should be linked or not?
00:27:07 <Cale> Figs_: yeah
00:27:14 <tehgeekmeister> yep
00:27:42 <Figs_> Is the goal to use those specific words for some reason, or just to ignore boring words?
00:28:20 <etpace> If I have a directory Foo/Bar/Bin/Main.hs can I do import Foo.Bar.Bin to load Main.hs?
00:28:23 <tehgeekmeister> i just don't want to link to words that are undefined
00:28:34 <tehgeekmeister> or, as i add more features, try to use definitions that don't exist
00:28:39 <Cale> etpace: Foo.Bar.Bin.Main
00:28:58 <etpace> theres no way I can access a file via Foo.Bar.Bin?
00:29:10 <Cale> You could have Foo/Bar/Bin.hs
00:29:19 <Cale> Or Foo.Bar.Bin.hs
00:29:33 <etpace> was hoping for a psuedo "index.hs"
00:30:15 <Cale> etpace: These are just the default search paths. If you pass the files on the GHC commandline, I think you can name the modules whatever you want
00:32:26 <chrisdone> i'm defining a custom build program for my cabal package. what's the way to pass custom parameters to it so that cabal-install won't process them?
00:32:57 <tehgeekmeister> heh.  now i get a stack overflow.  =P
00:34:14 <Figs_> I need to go to bed. Good luck.
00:34:46 <chrisdone> i basically want to use cabal to run/restart my nginx and fastcgi processes for me
00:35:09 <tehgeekmeister> it runs *much* slower strict
00:36:12 <tehgeekmeister> goes from a few seconds to over two minutes.  guess lazy is better.
00:36:16 <tehgeekmeister> (and it uses just as much memory!)
00:36:28 <tehgeekmeister> (oh, no.  more.)
00:37:42 <sh10151> Oof, google interview kind of owned me
00:37:49 <Gracenotes> hm? I have ScopedTypeVariables but still GHC complains about bound rigid type variables??
00:38:05 <Gracenotes> this is not good
00:38:09 <aavogt> they are rigid, or they are supposed to be rigid?
00:38:29 <aavogt> perhaps you're missing the forall keyword
00:38:29 <Gracenotes> what they are supposed to be is the same
00:38:34 <Gracenotes> ...aha
00:39:13 <Gracenotes> er hm 
00:39:22 <aavogt> chrisdone: use flags in your cabal file
00:39:36 <xanderking0> hi all
00:39:38 <aavogt> some steps in the Setup.lhs get to look at which flags are set
00:39:49 <xanderking0> what?
00:39:50 <ketralnis> :t !!
00:39:50 <lambdabot> parse error on input `!!'
00:39:58 <ketralnis> :t (!!)
00:39:59 <lambdabot> forall a. [a] -> Int -> a
00:39:59 <xanderking0> yeah me to
00:40:00 <Gracenotes> aavogt: well after a few combinations of foralls, I got it. haven't used scoped types in a while.
00:40:17 <Gracenotes> sh10151: well you never know. what sort of job was it for?
00:40:32 <aavogt> Gracenotes: the scoping is sort of inconsistent between instances and functions
00:40:55 <sh10151> Site reliability engineer
00:40:58 <aavogt> though I suppose it's that way for instances because classes have scoped type variables already
00:41:08 <sh10151> It was just the phone interview
00:41:17 <Gracenotes> yeah the constraint is an Ord constraint
00:41:54 <Gracenotes> forall on the top-level type signature is all that was needed, the implicit ones worked fine in the where clause signatures
00:41:55 <sh10151> Interestingly enough the guy asked me questions about the stuff I claimed to know least about in the textured discussion
00:42:07 <sh10151> Er, recruiter discussion, damn iPhone
00:43:43 <Gracenotes> and there we have it, transitive closure in 18 uncluttered lines
00:44:52 <chrisdone> aavogt: cabal test foo seems to be a more flexible option
00:45:18 <aavogt> cabal test is a new feature?
00:45:29 <chrisdone> aavogt: since april, I suppose
00:45:38 <chrisdone> it's a hook that you implement in the Setup.hs file
00:45:55 <chrisdone> $ cabal test nginx zot
00:45:56 <chrisdone> ["nginx","zot"]
00:46:10 <chrisdone> main :: IO ()
00:46:10 <chrisdone> main = defaultMainWithHooks simpleUserHooks { runTests = tests }
00:46:10 <chrisdone> tests :: Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO ()
00:46:10 <chrisdone> tests args _ _ _ = do
00:46:13 <chrisdone>   putStrLn $ show args
00:47:07 <drbean> In lambda calculus application, is the function applied to the argument, or the argument applied to the function?
00:47:33 <Axman6> function is applied to the argument, that's how i've always been taught
00:48:01 <chrisdone> "a lambda abstraction Œªx.t represents an anonymous function that takes a single input, and the Œª is said to bind x  in t, and an application ts represents the application of input s to some function t"
00:49:09 <sh10151> Sounds a little like the difference between applicative and normal order?
00:49:36 <drbean> What's that difference?
00:50:34 <chrisdone> SICP uses them interchangeably
00:50:35 <SevenInchBread> @quote CakeProphet
00:50:35 <lambdabot> CakeProphet says: brainfuck is synonymous with efficiency.
00:50:46 <SevenInchBread> ...oh. don't remember that.
00:51:01 <chrisdone> "When we introduced compound procedures in chapter 1, we used the substitution model of evaluation (section [*]) to define what is meant by applying a procedure to arguments"
00:51:09 <chrisdone> -- procedure is applied to arguments
00:51:15 <sh10151> Applicative order is strict evaluation, normal is lazy, more or less
00:51:23 <CakeProphet> chrisdone:  that sounds like it's from SICP.
00:51:26 <CakeProphet> am I right?
00:51:27 <chrisdone> then it says "Apply the value of the operator subexpression to the values of the operand subexpressions."
00:51:45 <chrisdone> so yeah, Sussman and Abelson use it interchangeably in the context of Scheme
00:51:45 <CakeProphet> chrisdone:  what's cool is that the substition model of evaluation from that book actually /works/ in Haskell. :)
00:52:04 <CakeProphet> whereas in Scheme it doesn't, due to implicit state.
00:52:24 <drbean> wikipedia says leftmost, innermost redex as opposed to leftmost, outermost.
00:56:59 <drbean> Operator is the function and the operand is the argument. So, applying the value of the operator subexpression to the values of the operand supexpressions is applying the function to the arguments, isn't it?
00:59:15 <ksf> > [product [1..64] `div` (product [1..k] * product [1..64-k]) | k <- [0..64]]
00:59:16 <lambdabot>   [1,64,2016,41664,635376,7624512,74974368,621216192,4426165368,27540584512,1...
01:03:51 <Zik> haskell connerie
01:05:03 * hackagebot shaker 0.1 - simple and interactive command-line build tool  http://hackage.haskell.org/package/shaker-0.1 (AnthoninBonnefoy)
01:05:05 * hackagebot texmath 0.2.0.4 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.2.0.4 (JohnMacFarlane)
01:06:02 <ksf> I'm trying to get an efficient mapping from 0..0xff to 32bits that minimises overlapping bits for arbitrary sets of 0..0xff
01:06:42 <ksf> ..."efficient" as in a couple of shifts and xors or such. 
01:07:04 * hackagebot kit 0.3 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.3 (NickPartridge)
01:07:41 <pozic> Do OpenMP and all of the concurrency APIs in GHC solve the same problems? Is there anyone of them that does things obviously better?
01:15:01 <CakeProphet> is there a point where you can have too many type synonyms?
01:15:27 <CakeProphet> well, I guess the answer to that is yes. 
01:16:10 <CakeProphet> I'm just wondering if it makes sense to use type synonyms /a lot/ for documentation purposes, or if too many will obfuscate the meaning of type signatures.
01:16:58 <ksf> both
01:17:17 <sh10151> I think it depends on the types.
01:17:36 <c_wraith> I don't use type synonyms often.
01:17:55 <v0|d> hey how can i make C-c M-. work with cabal?
01:18:22 <v0|d> i want some/all packages to be also kept in source and to be able to go to definition as i want.
01:18:46 <pozic> CakeProphet: they almost always turn into newtypes or data types in my systems.
01:19:12 <byorgey> CakeProphet: too many will definitely obfuscate the meaning of type signatures.
01:19:25 <byorgey> in my opinion this has actually taken place in the GHC source itself.
01:20:33 <CakeProphet> I suppose I agree. type signatures should really only document types... and not other things.
01:20:43 <CakeProphet> though I see some cases as useful: like FilePath
01:21:10 <Wolfspaw> Is there a connection between "pure" from Control.Applicative and "return" from Monads? Both return the samething under the same type annotation o.o
01:21:45 <Wolfspaw> pure 5 :: Maybe Int , return 5 :: Maybe Int .    for example
01:21:47 <byorgey> Wolfspaw: they are the same thing.
01:21:57 <Wolfspaw> byorgey: hm =O
01:22:13 <CakeProphet> let hm =0 in hm
01:22:15 <CakeProphet> ...
01:22:28 <byorgey> Wolfspaw: it's just that Monad was already around before Applicative was invented
01:22:37 <byorgey> hence the duplication
01:22:56 <Wolfspaw> byorgey: every Applicative is a Monad?
01:23:01 <byorgey> it really should be something like   class Applicative m => Monad m where (>>=) :: ...
01:23:07 <byorgey> Wolfspaw: no, the other way around.
01:23:46 <Wolfspaw> byorgey: ok , thanks !
01:24:11 <byorgey> @remember Wolfspaw let hm =0 in hm
01:24:11 <lambdabot> Done.
01:25:18 <CakeProphet> what's the associativity of backquoted functions?
01:27:01 <dolio> You can specify it.
01:27:10 <dolio> But default is infixl 9, as I recall.
01:27:21 <dolio> Same as every operator.
01:27:45 <CakeProphet> ah, didn't realize that was the operator default.
01:27:54 <CakeProphet> that's pretty high precedence.
01:28:04 <dolio> I'm 90% sure.
01:28:26 <byorgey> in some sense it doesn't matter what the default is, if you are relying on the default you're doing it wrong.
01:28:38 <byorgey> if you care, set the associativity and precedence explicitly.
01:28:54 <CakeProphet> psh, normative answers? in my #haskell?
01:29:39 <dolio> > let infixl 5 `add` ; add = (+) ; infixl 6 `mul` ; mul = (*) in 2 `mul` 3 `add` 4 `mul` 5
01:29:40 <lambdabot>   26
01:29:42 <byorgey> all answers should be normative.
01:30:20 <CakeProphet> byorgey:  I disagree. I believe they should simply answer the question, and not state what "ought" to be done instead, as that is a subjective notion. :)
01:30:30 * CakeProphet just finished studying for a philosophy final...
01:31:17 <byorgey> CakeProphet: it was a joke. =)
01:31:30 <CakeProphet> hmmm... -double checks- ah.
01:31:37 <CakeProphet> "should"?
01:31:59 <CakeProphet> is that the punch line?
01:32:13 <Philippa> it oughtn't be?
01:32:17 <byorgey> I was making a normative statement about normative ... oh never mind ;)
01:32:31 <CakeProphet> haha.
01:32:34 <CakeProphet> okay. just making sure I got it.
01:33:10 <gwern> CakeProphet: hm, if that's the best you can do with is/ought, I hope it was a 100 level PHI
01:33:48 <byorgey> good old gwern
01:34:14 <CakeProphet> "Kant is a normative programming language. A Kant program declares what the program ought to do, but not what it must do. In this sense it is non-deterministic."
01:34:27 <gwern> -_-
01:34:34 <gwern> wouldn't you rather write in Hume or Occam?
01:35:05 <CakeProphet> nah, Occam is too parsimonious.
01:35:15 <dolio> Occam has too many versions, as I recall.
01:35:21 <dolio> And it's hard to tell which is current.
01:35:23 <gwern> byorgey: I mean really, hume's is-ought distinction is one of the basic topics! it's not presumptuous of me to expect him to know it
01:35:53 <Jafet> Is it possible to program in wittgenstein?
01:35:55 <gwern> dolio: all the cool kids like the Kolmogorov complexity version of Occam's razor :)
01:36:10 <gwern> Jafet: I don't think I've ever heard of a PL named Wittgenstein
01:36:17 <dolio> The latest version is version pi, I guess.
01:36:26 <dolio> 1, 2, 2.1, pi.
01:36:49 <pozic> gwern: by cool kids you mean people with extraordinary large beards? 
01:37:00 <Jafet> Oh wait, you're all talking about real languages.
01:37:01 <gwern> pozic: but you repeat yourself
01:37:12 <dolio> Hume and Occam are both real languages.
01:37:22 <dolio> I don't remember if Kant is.
01:37:23 <byorgey> hahaha Jafet =)
01:37:28 <CakeProphet> ...no, it's not
01:37:36 <pozic> gwern: No, I don't.
01:37:52 <CakeProphet> I made it up, because a normative programming language sounds interesting and possibly disasterous/hilarious
01:38:08 <gwern> KANT is sort of real: http://www.math.tu-berlin.de/~kant/kash.html
01:39:38 <gwern> CakeProphet: maybe you would like the Uncyclopedia entries, eg. on Objectivist c
01:40:16 <CakeProphet> there /might/ be some kind of use for normative statements in programming languages. Perhaps as a description how a source of external IO /should/ behave?
01:40:19 <CakeProphet> I don't know.
01:40:44 <gwern> CakeProphet: well, there are 'assertions' - check that such a logical property holds over variables/state and ext if it's false
01:41:16 <CakeProphet> right. that's similar I suppose.
01:41:16 <gwern>  @hoogle assert
01:41:17 <pozic> CakeProphet: philosophy and computers have nothing in common. 
01:41:20 <sh10151> Brouwer. That's the pl we need.
01:41:22 <gwern> pozic: lies!
01:41:29 <gwern> @hoogle assert
01:41:29 <lambdabot> Control.Exception assert :: Bool -> a -> a
01:41:29 <lambdabot> Control.OldException assert :: Bool -> a -> a
01:41:29 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
01:41:51 <CakeProphet> pozic:  well, in the literal sense of that statement, I mostly agree. :)
01:41:58 <pozic> CakeProphet: or at least nothing useful. 
01:42:17 <CakeProphet> but I think computer science and philosophy have things in common, for sure. 
01:42:22 <CakeProphet> related questions.
01:42:26 <CakeProphet> questions/problems, rather
01:42:32 <sh10151> Brouwer would be SQL maybe, at least in null handling...
01:42:55 <gwern> bah, computer science is logic, and logic has always been philosophy-related 
01:42:56 <falbani> Hi...
01:43:04 <pozic> CakeProphet: no, CS has questions that have an actual answer or the answer is that there can never be an answer given a particular model of computation. Philosophy does not have that.
01:43:39 <gwern> to say nothing of philosophy of mind, which boils down to 'can a computer be a mind, and if not, then what on earth is a mind anyway?'
01:43:43 <wli> SQL has a number of relatively foul aspects. There should be cleaner ways to build languages around relational algebra.
01:44:05 <sh10151> Philosophy has boatloads of answers when you put them in a particular context
01:44:08 <pozic> gwern: I mean exactly questions like that. They are completely useless and will never have an answer. 
01:44:40 <sh10151> There's just more latitude in selecting philosophical models than in computational models
01:44:48 <gwern> you'll find how useless it is if a real AI is ever developed, cripes
01:44:57 <CakeProphet> pozic:  techically questions in philosophy have real answers... we're just puny humans.
01:45:14 <CakeProphet> with wee human brains.
01:45:44 <Philippa> I suspect you'll find there's an assumption you've just made there, too
01:45:45 <falbani> I need some directions for learning how to organize mutable data for a game written in haskell... Anyone knows if there is any open-source well-commented-code game written in haskell for take a look and maybe learn?
01:45:48 <sh10151> wli: I think Tutorial D is supposed to be better than SQL...
01:45:51 <pozic> CakeProphet: but since the answers cannot be proven they are useless. 
01:46:15 <pozic> CakeProphet: an oracle can come by and say to me "you have free will", that doesn't mean that I actually have. 
01:46:23 <gwern> falbani: well commented is debatable. why not just look at everything in the games section of hackage?
01:46:49 <falbani> gwern: I was doing it right now... but maybe someone can speed up my search :D
01:46:51 <pozic> gwern: there is not a single piece of AI tech based on philosophy. 
01:46:54 <sh10151> pozic: no empirical statement can be proven, yet we have plenty of use for them...
01:47:22 <v0|d> hm what is the probable reason cabal complaining that it cannot find a package although i've just cabal install'd it?
01:47:29 <pozic> sh10151: that is where you go wrong. The proof is the sequence of states the universe went through. 
01:47:44 <gwern> pozic: that's quite a statement. you don't consider anything done or influenced by minsky or hofstadter or metzinger, just to name 3 that come to mind quickly, to count?
01:47:47 <pozic> sh10151: you could record that and offer that to someone as proof. 
01:48:00 <ksf> too many ones.
01:48:04 <ksf> always too many ones.
01:48:15 <pozic> gwern: I was influenced by hofstadter, but decided his opinions were worthless after a few years.
01:48:26 <pozic> gwern: minsky, not a bit. 
01:48:29 <ksf> there's so many combinations with only 2 or three ones in 0..2^32, why don't I hit them.
01:48:35 <sh10151> pozic: even if I granted you that, it doesn't prove things like gravity
01:48:35 <pozic> gwern: I must admit I don't know metzinger.
01:48:58 <pozic> sh10151: it doesn't prove anything for subsequent states of the universe, sure.
01:49:15 <pozic> sh10151: and in a sense I actually agree with that given my ideas about how the universe works. 
01:49:19 <Philippa> it doesn't actually prove anything about anything outside your own head, strictly speaking
01:49:22 <byorgey> ksf: um... are you serious?
01:49:36 <falbani> I wrote simple games in others languages (other paradigms) and used haskell a lot for mathematical tasks and other simple things, but never realized how I would organize mutable data for a game....
01:49:44 <ksf> byorgey, yes.
01:49:54 <sh10151> pozic: But the theory of gravity us useful yet it cannot be proven, so the statement that unprovable propositions are useless is false.
01:50:02 <sh10151> Provably so ;$
01:50:10 <ksf> I want to map 0..256 onto 0..2^32 so that overlap is minimised for any set of bytes.
01:50:20 <ksf> ...for a bloom filter.
01:50:32 <pozic> sh10151: the theory of gravity has lots of data associated with it, an oracle saying you have free will has no such data. 
01:50:39 <pozic> sh10151: it's just one bit. 
01:51:07 <byorgey> ksf: there are only 5456 length-32 bit strings with exactly 2 or 3 ones.
01:51:21 <ksf> yes.
01:51:31 <sh10151> Sure, but that doesn't constitute proof. Unless all swans are really white, of course.
01:51:34 <ksf> I'd be content to get _any_ of them with an efficient mapping.
01:51:39 <CakeProphet> pozic:  with the right assumptions, philosophy /can/ do more than evoke long IRC discussions. :)
01:51:47 <byorgey> ksf: that gives you about a 1 in 10^6 chance of getting one if you randomly generate such a bit string.
01:51:49 <CakeProphet> though this might be a better topic for -blah
01:52:02 <gwern> falbani: the obvious way to write a game is just a big record containing your global state, with a recursive function
01:52:12 <gwern> falbani: this is how a number of games like shu-thing and monadius do it, iirc
01:52:17 * hackagebot timeplot 0.1.5 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.1.5 (EugeneKirpichov)
01:52:18 <pozic> CakeProphet: I studied philosophy on all levels below Phd and I haven't seen anything practical come out of it. 
01:52:53 <sh10151> pozic: what did you think of Rorty?
01:53:11 <pozic> sh10151: I studied some courses, not the whole curriculum. 
01:53:23 <CakeProphet> pozic:  well, I won't give you the usual length defense of philosophy (short version: a tool for critical thought)... but yeah, I disagree.
01:53:29 <CakeProphet> *lengthy
01:53:36 <falbani> gwern: thanks! I was reading Mage's code and saw exactly that... but having your confirmation is very useful
01:54:00 <ksf> byorgey, well, I'm currently randomly generating algorithms because I can't think of the right one...
01:54:03 <sh10151> Pozic: I'd give him some attention if I were you; he has some similar criticisms.
01:54:12 <gwern> sh10151: you probably don't care, but my impression of rorty is pretty negative. he's alright when it comes to politics, but everything else is a waste
01:54:13 <pozic> CakeProphet: critical thinking does not require you to read what other people said.
01:54:26 <falbani> gwern: no need to use things like state monad?
01:54:33 <CakeProphet> ksf:  hmmm, I wonder if you could randomly generate algorithms with an algorithm. I mean, theoretically you can, but I'd like to see it in action.
01:54:41 <CakeProphet> pozic:  ah, well yeah.
01:54:46 <ksf> CakeProphet, you can.
01:54:49 <gwern> falbani: well, state monad is rather like passing a record around
01:54:57 <pozic> CakeProphet: especially not people who only studied philosophy. E.g. someone like Einstein can be given some attention when he says God plays no dice, but even that is kind of useless to listen to. 
01:54:59 <CakeProphet> pozic:  I tend to get bogged down with reading about what other people said and then talking in terms of it.
01:55:15 <ksf> e.g. perfect hash generators, or extreme case-switch optimizing.
01:55:37 <CakeProphet> ksf:  extreme case-switch optimizing? That sounds like a sport.
01:55:51 <sh10151> Gwern: he is certainly not a philosopher's philosopher :$
01:56:04 <v0|d> hey thnx for the answer #haskell.
01:56:18 <pozic> CakeProphet: If you want to know about algorithms, stop wasting your time on philosophy. 
01:56:28 <gwern> no kidding. "let's turn philosophy into meaningless vaguely political gibberish like the french already did!"
01:57:04 <CakeProphet> pozic:  well, I never implied I was using philosophy for such. :3
01:58:12 <byorgey> v0|d: it could be because the package was installed locally but you are now trying to build something globally
01:58:24 <byorgey> v0|d: and the sarcasm is not necessary.
01:58:25 <sh10151> Gwern: French seemed to prefer vaguely scientific gibberish
01:58:38 <CakeProphet> pozic:  so you may reserve your jadedness for someone more idealistic, if you wish.
01:58:42 <byorgey> ok, to -blah please
01:58:48 <gwern> sh10151: that's just a fashion. sometimes scientific jargon is in, sometimes out...
01:58:55 <byorgey> this prevents people from asking questions.
01:59:18 <CakeProphet> byorgey:  agreed. Though I'm actually going to go idle now.
01:59:27 <CakeProphet> so I guess it doesn't matter.
01:59:35 <v0|d> byorgey: show me a nice way of getting attention please and let me follow.
02:03:11 <deteego> does anyone here use haskell-mode for vim by any chance?
02:03:21 <deteego> I am getting an error when editing .hs files
02:03:27 <deteego> E666: compiler not supported: ghc
02:03:43 <deteego> even though GHC is installed and the scripts are installed the correct place
02:04:52 <deteego> im refering to this plugin http://projects.haskell.org/haskellmode-vim/
02:08:42 <ksf> ...I'm going to just produce all of them, attempt to find a good set and then do the rest via a lookup table.
02:12:05 <ksf> ...and for starters. I'm going to take RANDOM ones.
02:12:55 <wind> that is neat
02:13:04 <wind> anybody home?
02:13:37 <wind> is this an empty place or what?
02:13:50 <ksf> no, we're merely all busy coding
02:13:59 <applicative> hello wind
02:14:07 <wind> sorry... good to hear from someone.
02:14:14 <pozic> wind: there are chat logs you know...
02:14:19 <wind> hello.  that means this actually works.
02:14:32 <pozic> wind: which you could have used to predict that your question was rather silly. 
02:14:53 <wind> good point.
02:20:39 <deteego> actually nvm
02:42:33 * hackagebot darcs-benchmark 0.1.8.2 - Comparative benchmark suite for darcs.  http://hackage.haskell.org/package/darcs-benchmark-0.1.8.2 (EricKow)
02:46:01 <randomnut> hi
02:56:14 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27934#a27934
02:56:18 <chrisdone> which one do you like better?
02:57:57 <chrisdone> tibbe: tell me which one you like better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27934#a27934
02:59:54 <dibblego> @check let f = reverse in \x y -> f x ++ f y == f (y ++ x) -- is there a function besides reverse for which this property holds?
02:59:55 <lambdabot>   "OK, passed 500 tests."
03:03:40 <pozic> chrisdone: I like neither. 
03:04:08 <pozic> chrisdone: I did like your tryhaskell.org website. 
03:05:09 <triyo> I have the following code snippet: http://gist.github.com/485798 that I need some assistance with please. 'lu' is of type 'Maybe [String]'
03:05:56 <triyo> This code works however, it gives me undesired results when ul is Nothing
03:06:24 <triyo> not to say that the liftM or filer are wrong
03:06:39 <quicksilver> chrisdone: I prefer the second but like neither :)
03:07:37 <triyo> for example, this part:    filter (not . userP) `liftM` lu ... seems to return Just [] instead of what I will essential need: a Nothing
03:10:34 <triyo> hmm, don't think thats true, it does actuality return Nothing as expected. Must be something else
03:11:13 <arcatan> yeah, that should return Nothing if lu is Nothing
03:11:24 <PeakerWork> I have a Transaction monad -- and I now want to have a phantom type-tag about whether it's a read-only or writer transaction... I want to be able to chain read-only and writer transactions to yield writer transactions. I don't want to "wrap" read-only transactions as writer ones, if possible... The type of (>>=) won't allow this.. anyone has any idea?
03:11:42 <triyo> arcatan: just ran it in ghci session and it is indeed nothing.
03:12:08 <PeakerWork> IOW, I want something like:   (>>=) :: Transaction Read a -> (a -> Transaction Write b) -> Transaction Write b
03:12:31 <PeakerWork> of course I could make my own bind with a more general type -- but then I wouldn't be able to use monadic combinators :(
03:13:19 <benc___> something like a typeclass for writers, and a typeclass for readers, and the transactions that are read-only transactions inmplement both type classes?
03:13:30 * benc___ hasn't really thought that through
03:13:58 <triyo> ohh, I got it... My filter on occesions will land uip with an empty list, hence Just [] of course.....but I need to turn those cases into Nothing and not Just []
03:14:10 <triyo> *occasions 
03:14:17 <chrisdone> quicksilver: you like neither?
03:16:32 <quicksilver> chrisdone: I find them both hard to read. But the first is definitely worse.
03:16:58 <quicksilver> chrisdone: in the second the definitions appear strangely ordered and I don't know the relative precedence of <=< and . without looking it up.
03:17:36 <quicksilver> PeakerWork: capabilities.
03:17:47 <quicksilver> PeakerWork: MonadReadTransaction, MonadWriteTransaction.
03:17:50 <PeakerWork> benc___: not sure if its two or one typeclass
03:18:15 <PeakerWork> quicksilver: but then can I use monadic combinators?
03:18:17 <quicksilver> a transaction which only reads has type (MonadWriteTransaction m) => m a
03:18:19 <quicksilver> PeakerWork: yes.
03:18:28 <quicksilver> a transaction which only reads... well you get the picture.
03:18:52 <quicksilver> if you combine them the inferred type will be (MonadWriteTransaction m, MonadReadTransaction m) => m a
03:18:56 <quicksilver> which is fine
03:19:08 <quicksilver> (assuming your concrete Transaction monad implements both typeclasses which of course it will)
03:26:39 <cncl> i found a bug in GHC, but i don't know how to search to see if someone else has found it
03:27:50 <quicksilver> there is a GHC bug tracker, cncl : http://hackage.haskell.org/trac/ghc/
03:27:53 <cncl> erroneous overlap in pattern match warning when using OverloadedStrings and two layers or more of overloaded string literals in a pattern
03:28:45 <cncl> so if you have two data/newtypes, one containing the other, and they both have IsString instances and OverloadedStrings is enabled, you can get an errant overlap warning in pattern matching if you use a literal and then a variable
03:29:07 <cncl> that's incredibly obscure but i will feel like a champion if i'm the first to have found it
03:29:49 <quicksilver> I think its' not reported. I searched for OverloadedStrings and foud only 6 bugs, yours wasn't one of them
03:30:01 <cncl> awesome. do i get a trophy?!
03:30:16 <cncl> i've never found a new compiler bug before in my life
03:32:23 <triyo> is there a more idiomatic way to handle this 'justConv' in my code snippet: http://gist.github.com/485821?
03:33:36 <quicksilver> don't think so.
03:34:35 <triyo> quicksilver: thanks
03:35:14 <PeakerWork> quicksilver: awesome, thanks :)
03:35:59 <quicksilver> PeakerWork: glad it works for you :)
03:36:17 <quicksilver> PeakerWork: to make your way work requires generalised monads. Possible in principle but you have to lift all the combinators to that setting.
03:36:26 <quicksilver> PeakerWork: the typeclass way (hack?) works with the current setup better.
03:38:28 <PeakerWork> quicksilver: I haven't yet checked it works, but a bit of thought says it should.. a bit different though:  Transaction will be parameterized on a type-var and the class restrictions will be CapRead/CapWrite on that type param, I think
03:41:27 <quicksilver> sounds like it will work too
03:42:01 <Tomsik> are redditers over?
03:42:14 <Jonno_FTW> over what?
03:42:34 <pozic> I don't seem to recall an asteroid wiping them all out. 
03:43:54 <Tomsik> > "aaare you there?"
03:43:54 <lambdabot>   "aaare you there?"
03:43:58 <Tomsik> yay
03:48:28 <tibbe> chrisdone, back from lunch. better in what sense?
03:48:51 <tibbe> chrisdone, general code layout?
04:03:16 <tibbe> chrisdone, I'm not sure
04:24:29 <opqdonut> gah, why does every package have to have its own definition of Stream
04:24:52 <RayNbow> opqdonut: perhaps for the same reason every programmer tends to reinvent the wheel?
04:25:04 <RayNbow> (because it's their wheel then)
04:25:09 <opqdonut> I'm just trying to use stream fusion
04:25:31 <opqdonut> but all the array/vector packages have their own Stream type that doesn't mesh with the one in stream-fusion
04:29:58 <opqdonut> hmm, storablevector seems better
04:30:04 <opqdonut> (than vector)
04:34:49 <dafis> > tail $ take 12 (fix ((1 :) . scanl (+) 0))
04:34:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55]
04:35:00 <dafis> ah, she's back :D
04:37:31 <hpc> @src scanl
04:37:31 <lambdabot> scanl f q ls = q : case ls of
04:37:31 <lambdabot>     []   -> []
04:37:31 <lambdabot>     x:xs -> scanl f (f q x) xs
04:38:33 <hpc> scanl (+) 0 [1..5]
04:38:37 <hpc> > scanl (+) 0 [1..5]
04:38:38 <lambdabot>   [0,1,3,6,10,15]
04:45:21 * hackagebot lhs2tex 1.16 - Preprocessor for typesetting Haskell sources with LaTeX  http://hackage.haskell.org/package/lhs2tex-1.16 (AndresLoeh)
04:45:30 <CalJohn_> why does cabal default to not installing profiling libraries?
04:46:09 <quicksilver> CalJohn_: to save compilation time, because most cabal users probably dont' need them.
04:46:11 <Zao> Useless for most users?
04:46:12 <dafis> CalJohn_: presumably, many people don't want them, and it takes longer to build
04:46:54 <dafis> CalJohn_: set library profiling to True in your ~/.cabal/config
04:47:51 <CalJohn_> I think they're probably not useless to most programmers, and while I know about that default, you have to chase dependancies by hand with --reinstall to get profiling after you have installed without :(
04:48:13 <dafis> CalJohn_: yes, that's a pain
04:48:29 <CalJohn_> every haskeller I know forgets to set that config line to true when they reinstall cabal
04:48:54 <CalJohn_> *install
04:48:55 <dafis> CalJohn_: reinstalling cabal doesn't change the config
04:49:12 <dafis> oh, the first install
04:49:45 <CalJohn_> yeah, it's just that as you move from machine to machine, you need to do cabal over again, and I now have done this 5 or 6 times
04:50:00 <dafis> I suppose it would be a good idea to have cabal give a startup message to that effect
04:50:14 <CalJohn_> (laptop, desktop, uni machine, the big machine at uni etc)
04:50:31 <CalJohn_> yeah, i might send those cabal people an email asking them to do that
04:50:46 <CalJohn_> those evil caballers, who mean me only harm
04:51:01 <dafis> CalJohn_: even better would be sending a patch :)
04:55:30 <CalJohn_> :)! yes
04:59:26 * hackagebot tagsoup 0.10.1 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.10.1 (NeilMitchell)
05:06:51 <nanothief> I'm trying to write a c extension in haskell. I have a basic extension at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27937#a27937 . However while it works when I load it in ghci (eg ghci\nimport MyTest\nadd42 3\n> 45), loading it in a separate file eg test.hs results in an error (ghc couldn't find the symbol add42). What is going wrong?
05:08:18 <zygoloid> nanothief: how are you 'loading it in a separate file'?
05:08:51 <nanothief> zygoloid: eg in the paste i have a file test.hs, I did runhaskell test.hs (resulting in the error)
05:09:31 <danderson> nanothief: just as a sidenote, since you have a cabal file, you don't need the runhaskell script. Just run `cabal install` in the directory with the .cabal file.
05:10:01 <zygoloid> nanothief: if you build test.hs with ghc --make, does it work?
05:10:07 <nanothief> danderson: oh right thanks
05:10:19 <Chaze> parallel list comprehensions are confusing: let strings = [x:xs | xs<-"":strings | x<-['a','b']]
05:10:25 <Chaze> why isn't this infinite?
05:10:59 <zygoloid> Chaze: because parallel list comprehensions are zips, and zips stop when the shorter list stops.
05:10:59 <nanothief> zygoloid: no, I get this error:http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27938#a27938
05:11:16 <Chaze> zygoloid: i see.
05:12:23 <nanothief> zygoloid: oh wait it did work, just not when I did it in the same directory as the cabal + MyTest.hs files
05:12:24 <zygoloid> Chaze: i suspect you don't want a parallel list comprehension there, and just want a , instead of the second |.
05:12:46 <Chaze> zygoloid: yeah, that's what the expression was originally like :)
05:12:57 <Chaze> just wrote an haskell exam :D
05:13:11 <zygoloid> Chaze: an alternative:
05:13:20 <wuehlmaus> how do i assign a value to a variable not using something like let var = function which as i understand is only a temporary variable ? [ yes, i am a bloody beginner :) ]
05:13:29 <zygoloid> > let strings = [x:xs | xs <- "":strings | x <- cycle ['a','b']]
05:13:30 <lambdabot>   not an expression: `let strings = [x:xs | xs <- "":strings | x <- cycle ['a...
05:13:33 <zygoloid> > let strings = [x:xs | xs <- "":strings | x <- cycle ['a','b']] in strings
05:13:34 <lambdabot>   ["a","ba","aba","baba","ababa","bababa","abababa","babababa","ababababa","b...
05:14:07 <danderson> nanothief: (reproducing your package locally to take a look, one min)
05:14:23 <zygoloid> nanothief: what happens if you use runhaskell from another directory?
05:14:43 <nanothief> danderson, zygoloid: I may have figured out the problem, having the test.hs file in a different dir made the problem stop
05:15:08 <zygoloid> nanothief: i think it's building a test.o from test.c and overwriting it with the test.o from test.hs
05:15:19 <zygoloid> i've had a problem along those lines with the FFI before
05:15:48 <nanothief> i thought it might be using the MyTest.hs file in the directory rather than the MyTest module extension
05:17:26 <zygoloid> are they different?
05:18:00 <nanothief> well thanks for the help (ghc --make showed the problem when it was compiling the MyTest.hs file as well)
05:18:12 <nanothief> zygoloid: no they are the same
05:28:36 * hackagebot ldif 0.0.8 - The LDAP Data Interchange Format (LDIF) parser  http://hackage.haskell.org/package/ldif-0.0.8 (RadoslavDorcik)
05:30:03 <opqdonut> anybody familiar with the vector package?
05:30:15 <opqdonut> I can't seem to find a function Stream a -> Vector a anywhere...
05:30:29 <opqdonut> so what's Data.Vector.Fusion.Stream for then?
05:31:18 <opqdonut> ah, it's under D.V.Generic
05:32:48 <PeakerWork> ScopedTypeVars should probably always be in.. when debugging type errors, it's a big pain to enable it..
05:33:37 <Paczesiowa> and it shouldn't require explicit foralls
05:34:54 <quicksilver> Paczesiowa: it has to require explicit foralls if it doesn't want to break haskell98 compatibility.
05:35:18 <quicksilver> (well, it has to require *something* specific, at least)
05:35:38 <Paczesiowa> off with H98's head!
05:36:01 <pozic> The basic problem is that Haskell is not extensible in its type-system. 
05:36:39 <pozic> Languages that are not extensible always generate discussion and controversy, while properly designed systems don't have that problem. 
05:36:57 <Paczesiowa> pozic: what systems are those?
05:37:20 <pozic> Paczesiowa: For dynamically typed languages, Common Lisp for example. 
05:37:35 <pozic> Paczesiowa: for statically typed languages, QiII. 
05:37:55 <pozic> Paczesiowa: or Shen, as I believe it is called today. 
05:38:36 <deteego> I like Haskell because as a language it puts limits in the areas it should, and allows freedom in the areas it should
05:38:40 <pozic> Paczesiowa: killing backwards compatibility is about the stupiest thing one can do with a language, imho. 
05:39:08 <Paczesiowa> pozic: so bring back n+k patterns:)
05:39:12 <quicksilver> I don't think it's possible to anticipate all the possible axes of extensibility
05:39:24 <quicksilver> the best you can do is anticipate and permit some.
05:39:30 <Paczesiowa> pozic: got any links on that shen?
05:39:35 <pozic> quicksilver: read a book on QiII and we talk again. 
05:39:37 <deteego> I don't really see a good reason as to why Haskell needs a completely extensible type system
05:39:50 <quicksilver> pozic: OK. We will never talk again. Shame.
05:40:12 <pozic> quicksilver: we can still talk on other subjects. 
05:40:53 <pozic> @google shen Mark Tarver 
05:40:54 <lambdabot> No Result Found.
05:41:26 <pozic> Paczesiowa: type that in Google and the first link should get you started. 
05:41:45 <pozic> QiII is however not as practical yet as GHC in a number of areas. 
05:42:17 <pozic> For example, no STM and other concurrency sweetness.
05:42:28 <deteego> Im searching QiII and getting nothing of relevance
05:42:50 <pozic> http://groups.google.com/group/Qilang?lnk=srg
05:42:52 <dafis> deteego: search Qi + programming language
05:42:55 <v0|d> fxr: unsafeperformIO $ pompa
05:43:48 <pozic> Some people in Silicon Valley are trying to use it to develop a language for mobile phones without destroying the language in the process. 
05:44:02 <deteego> dafis: thanks
05:44:06 <pozic> Basically slimming down the number of primitives, etc. 
05:44:23 <fxr> v0|d: unauthorized access to the system detected...
05:44:50 <v0|d> fxr: proceed with gordon freeman.
05:45:12 <dafis> pozic: if it only hadn't that butt-ugly Lispy syntax
05:45:40 <stacey> in the command "let abc@(¬≠a,b,c) = (10,2¬≠0,30) in (abc,¬≠a,b,c)", whats the "abc@" for?
05:45:40 <pozic> dafis: that's something you only say because you never programmed in Lisp for any length of time.
05:46:02 <pozic> stacey: bind abc to whatever is after the @.
05:46:10 <fxr> v0|d: but you slept well, no you slept well, you slept very good :)
05:46:11 <pozic> stacey: read the report. 
05:46:12 <dafis> pozic: that's because I find the syntax ugly
05:46:34 <stacey> ah. thanks pozic 
05:46:34 <pozic> dafis: if you really care about the syntax, you can invent another syntax.
05:47:04 <stacey> pozic: what report?
05:47:23 <dafis> stacey: the Haskell language report
05:47:25 <Paczesiowa> pozic: "read the report" for tryhaskell people?
05:47:31 <benmachine> reading the report is kinda boring
05:47:36 <benmachine> tutorials are fine
05:47:42 <dafis> stacey: pozic probably didn't suspect you came via tryhaskell
05:47:50 <pozic> Paczesiowa: I have no idea he/she comes via tryhaskell.
05:47:57 <benmachine> telling people to read the report is silly anyway :P
05:48:05 <benmachine> read the wiki is much better, where's that page
05:48:43 <dafis> stacey: abc@(a,b,c) = (10,20,30) means, bind the name abc to the entire tuple and bind a, b, c to its components
05:48:59 <pozic> dafis: I already told him/her that. 
05:49:28 <dafis> pozic: not verbose enough perhaps :)
05:49:31 <stacey> I found the wiki -- http://www.haskell.org/ 
05:49:51 <benmachine> http://haskell.org/haskellwiki/Keywords#.40
05:50:05 <benmachine> (lots of other useful stuff on that page)
05:50:19 <stacey> okay, thanks benmachine 
05:50:39 <pozic> stacey: if you want to learn Haskell, find a purpose. 
05:50:45 <deteego> ....
05:50:50 <pozic> stacey: learning for the void probably doesn't work.
05:50:57 <deteego> that has to be the most generic advice I have every heard
05:51:00 <ksf> is ghc smart enough to remove the bounds check for a word8-indexed array with Ix (0,255) or do I need unsafeAt?
05:51:31 <benmachine> pozic: yes it does :P
05:51:37 * benmachine learnt for the void
05:51:39 <pozic> deteego: yet, nobody seems to follow it. 
05:51:49 <dafis> ksf: I'm not 100% sure, but use unsafeAt
05:52:00 <pozic> benmachine: you never ever have written anything useful in Haskell?
05:52:12 <benmachine> pozic: I only wrote useful things after learning it
05:52:21 <benmachine> I didn't have those ideas while I was reading about the language
05:52:24 <pozic> benmachine: how much time did it take you to "learn"?
05:52:32 <deteego> pozic: on the previous topic, you believe that lisp or qi is better then haskell in theory due to their type systems being extensible?
05:52:37 <benmachine> well, I'm still learning of course :P
05:52:53 <darq> hello. Can somebody tell me how to convert IO FilePath to String because i get Couldn't match expected type `String' against inferred type `IO FilePath'
05:52:56 <pozic> deteego: Common Lisp and Qi are completely different languages.
05:52:57 <benmachine> so it depends what you mean but for most more specific questions the answer is "don't know"
05:53:06 <benmachine> probably O(weeks)
05:53:26 <pozic> deteego: I think Qi solves typing issues better than Haskell. 
05:53:44 <Axman6> @src FilePath
05:53:44 <lambdabot> type FilePath = String
05:53:49 <dafis> darq: you have to use the FilePath (which is an alias for String) indide IO
05:54:07 <deteego> pozic: I know they are different languages, I was just asking if that was your premise
05:54:30 <dafis> darq: like getDirectoryContents "." >>= \files -> something with files
05:54:34 <Axman6> > let fToS :: FilePath -> String; fToS x = x in f ("/hello/" :: FilePath)
05:54:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:54:34 <lambdabot>    `GHC.Show.Show a'
05:54:34 <lambdabot>      a...
05:54:36 <deteego> pozic: what typing issues do you believe Haskell has?
05:54:36 <pozic> deteego: so, I answered that already, right?
05:54:42 <deteego> pozic: yes :p
05:54:51 <darq> i use getCurrentDirectory 
05:54:58 <Zao> My typing issues with Haskell is that I feel the pressure to write as tight code as possible.
05:55:08 <pozic> deteego: for example implementing the type of primes is harder in Haskell. 
05:55:40 <dafis> darq: the principle is the same
05:56:15 <pozic> deteego: in terms of computational type power, Haskell + extensions is Turing-Complete, but in practice, Qi is much more elegant. 
05:56:18 <dafis> pozic: what do you mean by "the type of primes"?
05:56:22 <pozic> deteego: Haskell was not designed to do that. 
05:56:27 <Axman6> > let fToS :: FilePath -> String; fToS x = x in fToS ("/hello/" :: FilePath)
05:56:28 <lambdabot>   "/hello/"
05:56:57 <benmachine> darq: in principle, you can't convert an IO FilePath to a String, but you can convert a function that takes a String into a function that takes an IO FilePath
05:57:09 <deteego> pozic: what dafis said, are you regerring to implementing primes as a type or?
05:57:20 <pozic> dafis: read the whole Qi page tutorial and you would know.
05:57:26 <Axman6> > let fToS :: FilePath -> (FilePath, String); fToS x = (x,x) in fToS ("/hello/" :: FilePath)
05:57:27 <lambdabot>   ("/hello/","/hello/")
05:57:30 <pozic> deteego: yes, as a type.
05:57:45 <dafis> pozic: I'm on the wikipedia page now
05:57:49 <darq> hmm.. i pretty new to haskell and i use wxhaskell .. this is the line >>> staticText f [text := getCurrentDirectory]
05:57:53 <deteego> pozic: reading up on its implementation in Haskell now
05:58:32 <nanothief> darq: oh you are trying to do IO String -> String in practice, isn't possible (without unsafe functions)
05:58:46 <pozic> This is also sort of nice: http://programmingkungfuqi.blogspot.com/2007/05/sk-combinator-in-qi-type-system.html
05:58:59 <pozic> deteego: there is a Haskell implementation?
05:59:14 <deteego> pozic: http://www.haskell.org/haskellwiki/Prime_numbers
05:59:34 <pozic> deteego: oh
06:00:06 <pozic> deteego: that is not done in the type system.
06:00:11 <nanothief> you need to do that line in an IO function, and get the current directory using <- syntax, eg main = do\ndir<- getCurrentDirectory\n staticText f [text := dir]
06:00:14 <drhodes> data Primes = 2 | 3 | 5 | 7 ..
06:00:14 <Cads> is there anything recommended for writing distributed code across more than one computer?
06:00:16 <deteego> deteego: no, I just finished reading
06:00:27 <deteego> pozic: no, I just finished reading
06:00:34 <nanothief> (never used wxhaskell, so I'm not sure what context that function appears in)
06:00:34 <deteego> thought they were getting to it
06:00:35 <cads> parallel ghc doesn't seem to be recent
06:01:26 <stacey> pozic: What's wrong with learning for the void?
06:01:35 <benmachine> darq: which module does staticText come from
06:01:55 <benmachine> stacey: it can be harder to be motivated, I think, but I don't personally think there's anything wrong with it
06:02:06 <darq> this is from wxhaskell
06:02:18 <benmachine> darq: yes but which module in particular
06:02:21 <benmachine> which import
06:02:41 <darq> import Graphics.UI.WX
06:02:55 <pozic> stacey: it simply is not possible to become an expert in an area by just staring at a screen without doing anything. 
06:03:23 <benmachine> oh, that just re-exports everything else hmph
06:03:30 <pozic> stacey: it's the same reason you don't just read a book about mathematics. You do some exercises. 
06:04:56 <darq> thx nanothief . solved:)
06:05:15 <nanothief> np
06:07:25 <Tomsik> :t nanothief
06:07:26 <lambdabot> Not in scope: `nanothief'
06:07:32 <Tomsik> :t solved
06:07:33 <lambdabot> Not in scope: `solved'
06:07:36 <Tomsik> :(
06:07:40 <nanothief> ?
06:07:46 <Tomsik> he composed you with solved
06:07:53 <Tomsik> :t (.)
06:07:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:07:58 <nanothief> ha right
06:09:05 <stacey> pozic: so what are considered good scenarios to use haskell?
06:10:53 <pozic> stacey: solving a new problem and possibly using existing C libraries for computations that are not limited by resources. 
06:11:23 <pozic> stacey: you can also use it to get a feeling for a particular problem domain. 
06:11:50 <pozic> stacey: then you can prototype a sane API in Haskell and optionally port it to C for example if you need extreme performance. 
06:11:58 <pozic> stacey: note that you don't have to port to C. 
06:12:26 <pozic> stacey: that's something one would only do in a significant lower percentage than one would do in e.g. a scripting language.
06:12:42 <stacey> pozic: How does haskell rate in performance compared to c?
06:12:54 <pozic> stacey: it is mostly comparing apples to oranges.
06:13:03 <pozic> stacey: C is not as safe as Haskell. 
06:13:07 <Tomsik> stacey: usually haskell is less than two times slower
06:13:13 <stacey> pozic: safe?
06:13:23 <pozic> stacey: you won't see a segfault in Haskell.
06:13:23 <Tomsik> compared to java being twenty times slower not that rarely
06:13:37 <pozic> stacey: Tomsik is overstating things.
06:13:44 <Tomsik> oh come on :(
06:14:02 <pozic> stacey: you can get within a factor of 2, but you basically have to use GHC then. 
06:14:11 <Tomsik> pozic: create table of 1 000 000 integers in C, Java and Haskell
06:14:11 <pozic> It won't be "Haskell". 
06:14:35 <pozic> GHC also doesn't have the best optimizer in the world. 
06:14:51 <pozic> GHC creates acceptable performance, but performs no miracles.
06:16:00 <stacey> pozic: Is haskell platform independant?
06:16:04 <Tomsik> Sometimes when GC comes in there's a little freezup, but it's rather short
06:16:17 <pozic> stacey: a lot more than C and C++ are.
06:16:20 <somnium> Tomsik: I've never seen a benchmark with java 20x slower than C (usually around a factor of 2), link? 
06:16:26 <jmcarthur> haskell, c, and java do not have speeds
06:16:39 <Tomsik> somnium: create table of a million integers
06:16:52 <pozic> Tomsik: silly benchmarks are useless.
06:16:54 <Tomsik> at least some time ago, it took java 20 times longer than C
06:17:08 <stacey> pozic: what do you mean "a lot more"
06:17:11 <jmcarthur> java is very fast. you managed to find a corner case
06:17:11 <somnium> Tomsik: some time ago = 1999?
06:17:18 <Tomsik> but if not java, python is way slower too :p
06:17:25 <pozic> stacey: I mean that in the C standard a lot of stuff is "implementation defined".
06:17:33 <jmcarthur> but i just contradicted myself by saying that a language is fast
06:17:34 <quicksilver> Tomsik: microbenchmarks like that are of limited ues.
06:17:37 <Tomsik> jmcarthur: I can't see java as fast when I've used a few java apps, they're all horribly slow :/
06:17:38 <pozic> stacey: in the Haskell standard there are lot less mentions of that.
06:17:40 <jmcarthur> i'm trying not to do that anymore
06:17:49 <jmcarthur> Tomsik: java UI /= java
06:18:08 <Tomsik> how to do UI in java without java UI? :p
06:18:27 <Phyx-> why is there so many talks about java in here these days?
06:18:35 * Phyx- checks channel topic
06:18:41 <stacey> How is the "speed" of a language calsulated? is it just a matter of implementing the same thing in both languages and seeing which one is quicker?
06:18:44 <jmcarthur> Tomsik: i'm saying that headless apps written in java tend to perform very well vs. similar app written in C
06:18:47 <pozic> Phyx-: probably because Haskell is getting "popular".
06:19:01 <jmcarthur> stacey: usually, which is why it's bull crap
06:19:14 <jmcarthur> stacey: because different language implementations will favor different benchmarks
06:19:28 <stacey> jmcarthur: I agree. different languages are designed for different implementations
06:19:32 <jmcarthur> stacey: and usually people use microbenchmarks like allocating an array of a million elements
06:19:40 <jmcarthur> which are totally unrealistic
06:19:59 <pozic> I am pretty sure that allocating an array of a million elements is exactly as fast in C as in Java. 
06:20:05 <Phyx-> pozic: I want it to stay obscure then
06:20:22 <Tomsik> pozic: not due to GC
06:20:25 <Tomsik> IIRC
06:20:25 <pozic> Phyx-: or people should not put #haskell on a public website. 
06:20:29 <pozic> Tomsik: non-sense.
06:20:36 <pozic> Tomsik: nonsense*
06:20:51 <pozic> Tomsik: there is no fundamental reason for that to be so, unless it is a bad implementation. 
06:20:59 <jmcarthur> Tomsik: GCed language implementations actually tend to have faster allocation functions than non-GCed languages
06:21:06 <dafis> Tomsik: GC comes only into play if you allocat multiple arrays
06:21:07 <Tomsik> hm
06:21:18 <Ke> doesn't sun java do some bizarre virtual memory stuff on linux
06:21:22 <Tomsik> well, I guess you know better what you are talking about
06:21:26 <pozic> I like low-level languages on which high-level are build, because less can go wrong. 
06:21:45 <pozic> But 99.99% of people that build these systems do not agree, so we end up with crap.
06:21:46 <Phyx-> > id
06:21:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:21:47 <lambdabot>    arising from a use of `...
06:21:52 <Phyx-> wb lambdabot 
06:21:56 <Tomsik> brb
06:22:02 <pozic> built*
06:22:03 <Ke> jmcarthur: one would expect the system call to be the bottleneck in huge allocations
06:22:44 <pozic> In the end the largest bottleneck is probably the programmer, unless you have a really bad implementation.
06:22:47 <jmcarthur> Ke: assuming a syscall is necessary
06:23:04 <pozic> (when talking about relatively static languages)
06:23:15 <pozic> Things like Ruby cannot really be saved by the programmer.
06:23:29 <jmcarthur> Ke: an RTS with GC that reserves or already has memory up front will tend to use a very fast custom allocator
06:24:00 <jmcarthur> Ke: and even using malloc you don't necessarily do a syscall
06:24:22 <quicksilver> normal allocation in GHC is a pointer increment. This is much much faster than malloc.
06:24:26 <spraoi> @type fmap fmap fmap fmap fmap
06:24:27 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
06:24:28 <Ke> jmcarthur: for allocs larger than 12kB(by default) you do
06:24:37 <spraoi> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap
06:24:38 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
06:24:40 <jmcarthur> depending on the OS
06:24:50 <jmcarthur> and the userspace library you're using
06:24:51 <Ke> pfft
06:25:15 <Ke> =oP
06:25:36 <jmcarthur> as a counterexample, malloc on the xbox 360, i recently found out, *always* issues a syscall
06:25:58 <jmcarthur> which is fine because most games should use their own allocators anyway
06:26:04 <pozic> One consequence of the design of GHC is that you can only use GHC to build GHC, which is bad from a security point of view. 
06:26:49 <ksf> I cna haz unboxed Word128?
06:27:15 <Saizan> UArray Bool ?
06:27:22 <ksf> brrrr.
06:27:29 <ksf> I want a _register_.
06:27:37 <jmcarthur> does UArray Bool pack the Bools?
06:27:41 <Saizan> yes
06:27:43 <jmcarthur> nice
06:27:44 <ksf> it does
06:28:25 <Saizan> (# Word64# , Word64# #) ?
06:28:41 <Saizan> (can you put unboxed types in an unboxed tuple?)
06:29:05 <dafis> Saizan: yes
06:29:09 <pozic> Saizan: if you cannot, you also cannot put them in a data.
06:29:18 <pozic> Saizan: which means, that you can.
06:29:42 <pozic> Of course, you cannot do so in Haskell, only in GHC.
06:29:51 <Saizan> pozic: you can't write data Foo = Foo Word64# Word64# , in fact
06:30:04 <ksf> all of that won't give me a sse register.
06:30:32 <dafis> Saizan: but you can write data Foo = Foo {-# UNPACK #-} !Word64 {-# UNPACK #-} !Word64
06:30:39 <pozic> ksf: use harp?
06:30:41 <Saizan> dafis: sure
06:31:00 * Phyx- wants typeclasses that take # kinds
06:31:13 <quicksilver> ksf: it wouldn't be *that* hard to add SSE types of the kind you are imagining to GHC.
06:31:13 <pozic> ksf: since sse register is certainly not in the Haskell report ;)
06:31:15 <ksf> pattern matching ?!
06:31:24 <quicksilver> ksf: I looked at it for a bit but didn't have the time to get properly into it.
06:32:16 <jmcarthur> i would like to see SSE types exposed just so they can be utilized by these fancy array libraries we have
06:32:52 <ksf> yep.
06:33:06 <ksf> Data.largeword doesn't come with UArray instances
06:34:05 <sbahra> Well, adding SSE types is one thing, utilizing them efficiently is the problem I would imagine. :-)
06:34:26 <ksf> I only need a couple of ands, an xor and cmp.
06:34:33 <jmcarthur> sbahra: probably wouldn't be too difficult to use them in an existing array library, probably
06:34:52 <Ke> I wouldn't like to see such low level concepts in haskell
06:34:54 <quicksilver> first step is to add them to Cmm, the primops, and the codegen.
06:34:57 <sbahra> ksf, in which case it would be fine. Would be non-trivial you require checking specific values in the register, etc...
06:35:00 <jmcarthur> sbahra: using associated data types or something to hide that the SSE types are being used, etc.
06:35:12 <ksf> mapping 256 values to a mere 64 bits without having them all overlap is the hard problem.
06:35:13 <quicksilver> that's routine - but requires familiarity with all those bits.
06:35:20 <jmcarthur> Ke: GHC already exposes tons of low level primitives. that's all we are talking about here is primitives
06:35:22 <sbahra> jmcarthur, right, the issue is marshalling the data from/to XMM registers efficiently. 
06:35:38 <quicksilver> step two is working out some way to GHC to use them in its compilation process :)
06:35:45 <jmcarthur> sbahra: with stream fusion i don't see that being i big issue
06:36:05 <ksf> well I could call bleeding memcmp...
06:36:21 <jmcarthur> *a
06:37:02 <pozic> jmcarthur: IMHO, compiler writers should figure out how they can use specific x86 extensions in arbitrary code. 
06:37:25 <pozic> jmcarthur: otherwise the whole concept of a portable language is thrown away.
06:37:40 <ksf> portability is ensured by providing fallbacks.
06:38:08 <pozic> ksf: yes, but I mean that the end-user, in this case you, shouldn't even have to think about a particular arch.
06:38:18 <ksf> it's not like one would have to emulate floating-point with a register set that lacks even integer multiplication these days.
06:38:18 <jmcarthur> pozic: if the array library is abstracting properly then you don't care about the implementation
06:38:42 <jmcarthur> pozic: conditional compilation is your friend :)
06:39:02 <ksf> it's definitely a thing dph should do.
06:39:16 <Ke> one of those friends haskell doesn't have ;o)
06:39:24 <jmcarthur> i am not a big believer in portability or backward compatibility anyway
06:39:30 <Ke> !
06:39:30 <ksf> heck I don't know why people didn't start out with simd there.
06:40:10 <pozic> jmcarthur: don't worry, I have used conditional compilation. 
06:40:41 <jmcarthur> haskell is a research language, and i see no reason we should be restrained from cool ideas just because people might use be relying on old versions
06:40:57 <ksf> anyway, when I .|. my elements together I get suspiciously many f's in the output.
06:41:04 <jmcarthur> and haskell *implementations* are even farther removed from the language
06:41:30 <ksf> the _easy_ way would be to use Word256 and use a bit per element...
06:42:35 <jmcarthur> i'm cool with having a slower-moving standard haskell spec, but i don't personally care to be limited by it. i'll take advantage of implementation-specific features
06:44:12 <pozic> jmcarthur: there is little measurably progress in Haskell implementations, because there are so little that implement everything GHC does.
06:44:22 <pozic> measurable*
06:44:56 <jmcarthur> do you mean to say that the leaps and bounds that GHC makes have left other implementations in the dust and made them unattractive to improve?
06:45:02 <ksf> otoh, if I change my step size to a nibble instead of a byte I get a sed width of 16bits and can match two bits of the result at the same time.
06:45:27 <ksf> heck no four, easily, 8 on 64 bit archs.
06:45:31 <benmachine> the latest version of jhc looked vaguely interesting
06:45:42 <jmcarthur> lhc looks cool to me, too
06:45:49 <jmcarthur> lots of cool things come from yhc
06:45:50 <quicksilver> pozic: I don't know. This last year or so, we have UHC, LHC, and JHC verions released
06:45:55 <pozic> jmcarthur: I would use different words, but it is not easy to implement the whole system from scratch in let's say a year.
06:45:59 <jmcarthur> uhc i haven't even looked at yet
06:46:01 <quicksilver> there is definitely progress.
06:46:08 <ksf> but then, we don't have word4's, either.
06:46:10 <pozic> jmcarthur: lhc is a fork, no?
06:46:18 <jmcarthur> it is, but with drastic changes
06:46:35 <pozic> jmcarthur: uhc does not do everything and is a decade long research program.
06:46:37 <Saizan> lhc is no longer a fork of jhc
06:46:43 <Saizan> but it uses ghc as a frontend
06:47:05 <jmcarthur> Saizan: how does something become "no longer" a fork?
06:47:11 <jmcarthur> stopp pulling patches from the ancestor?
06:47:13 <jmcarthur> -p
06:47:22 <quicksilver> they threw out hte JHC code
06:47:23 <Saizan> jmcarthur: scrapping the old code entirely
06:47:25 <jmcarthur> ah
06:47:29 <jmcarthur> i didn't know they did that
06:47:31 <ksf> hmmm. this needs to be adaptive.
06:47:36 <pozic> Saizan: and it still works?
06:47:46 <pozic> Saizan: ok, that's news for me.
06:48:06 <Lemmih> pozic: Well, it kinda works.
06:48:17 <jmcarthur> on my machine it *thinks* about working
06:48:45 <pozic> Lemmih: your links are dead. 
06:48:47 <Lemmih> pozic: Benchmarks comparing GHC, LHC, JHC and UHC will be up in a few days.
06:48:52 <jmcarthur> ooh
06:48:58 <Lemmih> pozic: Oh, which ones?
06:49:01 <pozic> Lemmih: the one to GRIN at least on the first page.
06:49:12 <pozic> Lemmih: it seems this person has left chalmers.
06:49:52 <pozic> Lemmih: there was already such a benchmark, right? I think UHC is new in the list, though.
06:49:52 <Lemmih> pozic: Ah, yeah. I should update the wiki. The are mirrored here: http://lhc-compiler.blogspot.com/2010/06/mirroring-boquists-grin-papers.html
06:50:55 <pozic> Lemmih: do you have a picture of that guy? 
06:51:36 <Lemmih> pozic: Of Urban boquist?
06:51:40 <pozic> Lemmih: yes
06:51:54 <pozic> Lemmih: I think there are lots of people who worked on GRIN. What's so special about his Phd thesis? 
06:52:31 <ksf> but then if I got 16 targets for my bloomier filter the 8 to 64-bit mapping won't clash that much.
06:52:37 <pozic> Most leet website ever? http://0xff.ath.cx/~as/
06:53:13 <Lemmih> pozic: He detailed how high level features are implemented using GRIN and showed why it would be quite efficient.
06:53:30 <Lemmih> pozic: The new benchmark report will look something like this: http://mirror.seize.it/report.html
06:53:51 <pozic> Lemmih: I think I have seen that one before. 
06:54:18 <pozic> Lemmih: but very useful as a kind of incentive.
06:54:25 <Lemmih> pozic: Yeah, I stole the design from nobench.
06:56:39 <Lemmih> pozic: Here's a picture of Urban: http://se.linkedin.com/pub/urban-boquist/3/69a/a42
06:57:00 <pozic> Lemmih: thanks
06:57:55 <Phyx-> oh my, those are some small text
07:13:29 <nphpcmtkwhcivjzy> Hello, everyone. Literate Haskell question. In GHC, is there a way to compile a text file as literate Haskell without renaming it *.lhs?
07:14:02 <Igloo> -x lhs I think
07:14:03 <roconnor> http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/c0uvqqo  -- why does this typecheck?
07:14:15 <roconnor> I don't see any use of Fix.
07:14:20 <nphpcmtkwhcivjzy> Igloo: Thanks, I'll try that.
07:14:21 <roconnor> like I was expecting
07:15:09 <nphpcmtkwhcivjzy> Igloo: Yes, that was it. Thanks!
07:15:29 <djahandarie> Is there a Haskell user group in Tokyo?
07:15:43 <Saizan> roconnor: hylo is "cata alg . ana coalg" the Fix is where they are composed together
07:16:20 <Saizan> though hylo is also "deforested" so the Fix doesn't appear in the implementation either
07:18:34 <djahandarie> That's a nice solution
07:19:16 <nphpcmtkwhcivjzy> Another literate Haskell question. Is there a good way use the non-Bird style syntax in an HTML file? (I'd prefer to make it clear to the reader that something is code by putting it in a colored div or something.)
07:24:42 <fryguybob> @botsnack
07:24:43 <lambdabot> :)
07:25:30 <dafis> nphpcmtkwhcivjzy: <div class="code"><!-- \n\\begin{code}\n--> code goes here <!--\n\\end{code}\n--></div>
07:25:43 <dafis> qbotsnack
07:25:49 <dafis> @botsnack
07:25:49 <lambdabot> :)
07:25:54 <pozic> What's the ||-symbol used on http://en.wikipedia.org/wiki/Hylomorphism_%28computer_science%29 ?
07:25:56 <dafis> AltGr fail :(
07:26:05 <nphpcmtkwhcivjzy> dafis: Wonderful, I'll try that out!
07:26:27 <djahandarie> Why does the Control.Category in base use "cat" instead of "~>"?
07:27:17 <benmachine> because TypeOperators is non-standard, perhaps
07:27:21 <applicative> don't you have to add "TypeOPerators
07:27:29 <applicative> like benmachine said
07:27:42 <djahandarie> Ah right
07:28:36 <Saizan> pozic: A || B = (A , B) i'd guess, the notation from the barbed wire paper has always been puzzling
07:29:03 <quicksilver> or A x B in more standard notation in that context
07:29:11 <djahandarie> ezyang has a good post on the notation
07:29:13 <quicksilver> but I'm equallly surprised by the || notation.
07:29:32 <djahandarie> http://blog.ezyang.com/2010/05/bananas-lenses-envelopes-and-barbed-wire-a-translation-guide/
07:29:38 <dafis> nphpcmtkwhcivjzy: Oops, --> is a symbol for ghc, so you'd have to end your HTML comments with "code}\n-- -->" instead of "code}\n-->"
07:30:01 <applicative> moronic question, if I am comparing two executables for time etc. and someone asks if the disk cache is the same, how do I tell?   
07:30:12 <applicative> i'm testing a hylomorphism of course!
07:30:14 <dafis> s/symbol for ghc/operator in Haskell/
07:30:41 <quicksilver> applicative: run each one multiple times. If there are caching effects the later runs will be faster.
07:30:41 <Saizan> | = Either and || = (,) ? this is madness
07:30:44 <fryguybob> pozic: It says "where (b,a') = g a" so I'd go with (,) too.
07:31:00 <DrSyzygy> Saizan: That's what the barbed wire paper does?
07:31:21 <DrSyzygy> Tsk. Everyone knows that Either is + and (,) is * (or x) !! ;-)
07:31:24 <pozic> Saizan: if it is madness I just ignore the concept until someone writes down something decent. 
07:31:27 <applicative> thanks quicksilver, that makes sense.  it was plain my testing was going to be lame and anecdotal anywa..
07:31:28 <dafis> Saizan: What the ?
07:32:05 <Saizan> DrSyzygy: yeah, according to ezyang translation table :)
07:32:20 <pozic> Saizan: I happily programmed without them for years. Now, catamorphism clearly have a lot of used, but combinations of combinations of combinations are at some point going to have negative value.
07:32:32 <pozic> use*
07:33:00 <Saizan> well, actually, once you have a generalized hylo it subsumes all the zoo, i'm told
07:33:34 <ksf> I could _really_ use those bytewise operations.
07:33:34 <Saizan> pozic: if it's any help, the anamorphism for [a] is unfoldr
07:33:36 <pozic> Saizan: the whole zoo? I think there were about 10 or so. 
07:33:46 <pozic> Saizan: yes, I knew that.
07:34:27 <Saizan> pozic: yeah, that's what i gather, you should ask edwardk if you're interested :)
07:35:39 <fffej> I'm trying to use the (awesome!) criterion package, but I'm unable to get it to display output.  I've got GTK2HS installed and (hopefully) all the relevant libs - any ideas what I'm missing?
07:37:09 <roconnor> Saizan: the "real filesystem" structure is fileSystem root = fmap fileSystem (f root), but we never build it.
07:38:47 <Saizan> roconnor: i guess that's true for the right f :)
07:38:58 <applicative> fffej, I haven't been able to build the display, but don't you need a flag, -fchart    cabal install criterion -fchart  (i think)
07:39:14 <Saizan> roconnor: since that's "ana f" afaiu
07:39:16 <roconnor> Saizan: I would have never of thought of using coalgebras.
07:39:29 <applicative> cabal install criterion -fchart 
07:39:46 <fffej> applicative: thanks for the hint, that's definitely installing a whole host of charting components
07:40:39 <Saizan> roconnor: i never did either in such situations, i resorted to unsafeInterleaveIO once.
07:40:44 <roconnor> Saizan: suddenly catagory-extras is looking a lot more practical
07:40:51 <applicative> fffej, yeah, it uses this http://hackage.haskell.org/package/Chart to get to cairo or whatever
07:41:14 <Saizan> roconnor: heh, yeah :)
07:41:33 <roconnor> this needs to be the poster-child for category-extras
07:41:49 <fffej> applicative: hmmm, still no luck - png / win don't work with -k still.  Is there any documentation on the flgs?
07:42:21 <roconnor> Saizan: every instinct tells me to wrap up an algrebra by taking it's fixedpoint, or ana as you call it.
07:42:47 <roconnor> @hoogle ana
07:42:47 <lambdabot> Language.Haskell.TH.Syntax DataName :: NameSpace
07:42:47 <lambdabot> Language.Haskell.TH tupleDataName :: Int -> Name
07:42:47 <lambdabot> Language.Haskell.TH.Syntax tupleDataName :: Int -> Name
07:42:59 <dafis> :D
07:42:59 <Saizan> roconnor: coalgebra, you mean?
07:43:01 <applicative> fffej, sorry, I'm not the one to ask, I couldn't get as far as you have, myself....
07:43:08 <roconnor> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Ana.html#v%3Aana
07:43:13 <roconnor> Saizan: yes, coalgebra
07:44:31 <fffej> applicative: thanks for trying :)
07:45:36 <Saizan> roconnor: i guess Haskell has spoiled us with all the laziness, and we find in trouble when there's some non-lazy monad in the way
07:45:51 <roconnor> is hylo actually defined as cata alg . ana coalg
07:46:17 <roconnor> no
07:46:19 <roconnor> right
07:46:22 <roconnor> it's defined right there
07:46:25 <Saizan> yeah
07:46:30 <roconnor> hylo g f = f . fmap (hylo g f) . g
07:46:52 <roconnor> what is coalg?
07:47:00 <Saizan> g
07:47:00 <roconnor> a newtype constructor?
07:47:03 <roconnor> oh
07:47:09 <djahandarie> hylo isn't actually used in that though, hyloM is
07:47:11 <roconnor> ok
07:47:26 <roconnor> so hylo g f = cata f . ana g  ?
07:47:34 <Saizan> yep
07:47:42 <roconnor> djahandarie: I'm starting simple here :)
07:48:26 <ketil> how do I hide a package from ghc --make?  "ghc-pkg hide" doesn't seem to do it..
07:48:36 <Axman6> :t let hylo g f = f . fmap (hylo g f) . g in hylo
07:48:37 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a -> f a) -> (f b -> b) -> a -> b
07:48:50 <mwc> Grrrrrrrrr. What idiot thought instance Storable Bool was a good idea?!
07:49:14 <Axman6> > let hylo g f = f . fmap (hylo g f) . g in hylo return head 1
07:49:14 <quicksilver> ketil: I think if you want to choose packages you don't use --make
07:49:18 <lambdabot>   mueval-core: Time limit exceeded
07:49:27 <ketil> quicksilver, hm, ok.
07:49:28 <zygoloid> mwc: pretty sure i used that instance yesterday ;-)
07:49:29 <ebzzry> What is the current suggested textbook on learning Haskell now?
07:49:34 <Saizan> ketil: that should work actually, but there's also -hide-package
07:49:38 <quicksilver> ketil: i.e. you list packages manually with -package, or you use cabal and list the packages in your .cabal
07:49:47 <roconnor> @type Data.Traversable.mapM
07:49:47 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
07:49:57 <roconnor> @type mapM
07:49:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:50:05 <quicksilver> mwc: well, Storable is really for C/FFI. Presumably instance Storable Bool matches the C/C++ 'bool' types?
07:50:11 <mwc> zygoloid: the problem is that it defines sizeOf True = 4, while in say C++, sizeof(bool) = 1.
07:50:18 <mwc> quicksilver: but it doesn't, that's why it's a PITA
07:50:21 <Saizan> ketil, quicksilver: but you still pass --make so that it handles the local sources
07:50:34 <mwc> have to create  a newtype to override the storable instance I guess
07:50:35 <applicative> ebzzry, you mean a proper 'textbook' or good books etc. to read?
07:50:46 <quicksilver> mwc: hmm.
07:50:58 <quicksilver> mwc: odd:)
07:51:39 <mwc> Well, it can be worked around with a newtype CPPBool 
07:51:43 <roconnor> Saizan: hyloM isn't part of catagory-extras?
07:51:46 <ebzzry> applicative: a proper textbook
07:52:43 <Saizan> roconnor: you should be able to write it in terms of g_hylo
07:53:02 <Axman6> BONUS: heh, why must everything have a paper?
07:53:04 <roconnor> ya
07:53:15 <Saizan> mh, maye notw.
07:53:55 <applicative> there is Hutton Programming in Haskell, which is sort of elementary, and several older ones.
07:54:56 <ksf> pcmpqw. that's darn hard to emulate.
07:55:05 <ebzzry> applicative: Which is better, Programming Haskell or Real 
07:55:20 <ebzzry> applicative: Which is better, Programming in Haskell or Real World Haskell?
07:55:23 <int80_h> good day everyone
07:56:02 <roconnor> Saizan: hmm, it is starting to look like you can't
07:56:15 <dafis> hi int80_h 
07:56:56 <byorgey> ebzzry: what sort of programming and maths backgrounds do you have, and why you are learning Haskell?
07:57:04 <applicative> ebzzry, they are completely different.  Programming in Haskell is pitched at students, RWH at practical programmers
07:57:25 <msieradzki> rwh has mostly toy examples
07:57:39 <byorgey> toy?
07:57:47 <msieradzki> long toy examples if you want
07:58:17 <applicative> it is a primer for the use of Haskell, not for writing operating systems or something
08:00:09 <MacDada> hi ;]
08:00:25 <MacDada> im just going through the tutorial :)
08:00:44 <applicative> MacDada, good work.  
08:02:09 <applicative> Our friends here can explain, e.g. mysterious error messages to you...
08:02:27 <ebzzry> byorgey: I'm coming from Lisp with pretty much average math knowledge.
08:02:57 <ebzzry> applicative: OK. So it looks like I'll take a stab at PIH first, then RWH next.
08:03:08 <applicative> MacDada, welcome to the Syntax Crisis Center
08:03:50 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27940#a27941
08:03:53 <applicative> ebzzry, there is also the Learn You a Haskell tutorial which people like.  
08:04:06 <int80_h> good I think I may have some trouble with syntax in the above hpaste
08:04:20 * ksf would like to have inline llvm assembly
08:04:35 <ksf> ...using foreign calls, if necessary.
08:04:41 <MacDada> i didnt know what haskell is until i got here from polish kind of digg site :] but im a programmer so let's give it a chance ;)
08:05:30 <ebzzry> applicative: noted
08:05:34 <ski> int80_h : lo
08:05:45 <applicative> int80_h, should you have brackets around rawlist?
08:05:52 <int80_h> ski: hi there :)
08:06:06 <ksf> well, I could use language.c and do exactly that.
08:06:27 <ski> (int80_h : you said `hi' yesterday)
08:06:32 <int80_h> ski : I've started modifying that code we worked over the other day. It's comign together.
08:06:40 <applicative> int80_h, listMerge [rawlist] = map ripList [rawlist]  
08:06:42 <ski> int80_h : your `rawlist' is a `String' not a `[String]'
08:06:43 <int80_h> ski : I did :)
08:07:02 <MacDada> What does 'tuple' mean? It's not listed in my dict...
08:07:05 <ski> int80_h : the pattern `[rawlist]' only matches lists which contain exactly one element
08:07:21 <ski> MacDada : a 2-tuple is a pair, a 3-tuple is a triple, &c.
08:08:17 <benmachine> MacDada: (a, b) is a tuple, (a,b,c) is a different kind of tuple
08:08:35 <applicative> MacDada, "tuple" is local jargon, I think from  ML 
08:08:49 <ksf> it's maths jargon
08:08:49 <dafis> applicative: from maths, actually
08:08:59 <applicative> no way, 
08:09:03 <ksf> lispers call them cons cells.
08:09:15 <dafis> quadruple, quintuple, sex*tuple*, sep*tuple*, oc*tuple*, ...
08:09:25 <fryguybob> wow, this definition is wrong: http://www.merriam-webster.com/dictionary/tuple
08:09:27 <applicative> dadis, that s right of course
08:09:44 <ski> (cons cells are used both to emulate (homogenous) lists, as well as tuples, in Lisps)
08:09:45 <ksf> ...the t is part of the number, though.
08:09:52 <applicative> its the jargon that detached "tuple" and makes a word of it
08:10:05 <dafis> fryguybob: it's MW, surprised?
08:10:10 <applicative> and you hardly need math to have sextuples
08:10:50 <dafis> applicative: mathematicians use n-tuple since (at least) the 19th century
08:10:56 <dafis> long before ML
08:11:03 <ksf> to be specific, they're _unlabeled product types_.
08:11:08 <ksf> (I just made that up)
08:11:09 <applicative> nb, the thing discussed is the "combining form", isn't it.
08:11:24 <roconnor> Saizan: I suspect that dolorules's solution is essentially the same as winterkoninkje's
08:11:26 <applicative> dafis, n-tuple is fine too.   thats not the word we use
08:11:31 <roconnor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27904#a27904
08:11:39 <applicative> moreover n-tuples are typically homogeneous
08:11:48 <MacDada> well, i checked the wikipedia article on 'tuple' and i dont see a reason to use tuple instead of just a regular list
08:11:50 <ksf> those are called lists.
08:12:09 <applicative> roconnor, it's just that it's way more beautiful :)
08:12:11 <int80_h> ski : I don't understand why [rawlist] only matches lists containing one element
08:12:12 <ksf> ...and we've got n-tuple support, at least theoretically. there's Data.Nthable.
08:12:13 <dafis> applicative: tuple for n-tuple with not-fixed n
08:12:49 * ski wonders whether that continues like : novuple, decuple, undecuple, dodecuple, &c.
08:12:51 <roconnor> dolio's (s -> IO (Either (FilePath,Integer) (FilePath, [s])))  lines up with winterkoninkje's monadic coalgebra String -> IO (FS String)
08:13:00 <roconnor> applicative: which one is more beautiful?
08:13:03 <dafis> int80_h: because [var] is shorthand for (var : [])
08:13:19 <ski> int80_h : `[12]' is a list containing only `12', also, if `rawlist' is `12', then `[rawlist]' is a list containing only `12'
08:13:30 <applicative> dafis, that's what we say.  but a mathematician might say an n-space  or n-blah-space is a set of n-tuples.  There tuple is not a separate noun
08:13:38 <applicative> roconnor, I was going with doliorules
08:13:41 <ski> int80_h : patterns have the same syntax as the expressions they match (with a few discrepancies)
08:13:56 <ski> > let rawlist = 12 in [rawlist]
08:13:56 <lambdabot>   [12]
08:14:04 <ksf> int80_h, you probably want either "xs" or "x:xs".
08:14:05 <dafis> applicative: you mean all my professors lied to me in calculus?
08:14:14 <roconnor> applicative: I think that winterkoninkje's is more beautiful.  He makes it look like a simple isntance of a generic problem.
08:14:19 <ksf> matching "x:[]" aka "[x]" is rare
08:14:31 <roconnor> applicative: but I've just started studying dolio's solution
08:14:37 <ksf> ...you rather match "[]" as bottom case.
08:14:51 <applicative> dafis the only only question here, is whether they use the word "tuple" as a separate noun.  This is just a failure to communicate.  
08:14:52 * ski matches it as top case
08:15:07 <dafis> applicative: they did
08:15:16 <roconnor> Saizan, applicative: presumably dolio's annihilate is hylo
08:15:20 <ksf> well yes bottom cases should go to the top.
08:15:38 <ksf> applicative, yes they do.
08:15:44 <applicative> roconnor, hmmm.  'annihilate' was more wonderful
08:15:54 <applicative> what's an example sentence.
08:15:59 <roconnor> applicative: more wonderful than hyloM?
08:16:30 <ski> MacDada : lists are for when all the elements are the same type (so you can do the same kind of operations on them), while the length of the list is generally unknown (before you check it)
08:16:35 <applicative> roconnor, yeah
08:16:39 <roconnor> :O
08:16:59 <ski> MacDada : while tuples are for when you know the number of parts beforehand, and each part can have a different type
08:17:16 <pozic> What do you think about OpenMP?
08:17:50 <ski> (ksf : i'd say "positional product types")
08:18:00 <Twey> 16:09:21 < fryguybob> wow, this definition is wrong: http://www.merriam-webster.com/dictionary/tuple
08:18:01 <ksf> "Imaginary numbers are the tuple (j,sqrt (-1) * k) where j,k `elem` R"
08:18:16 <Twey> Gosh!  Merriam‚ÄìWebster is *wrong*!  Somebody call the press!
08:18:20 <ksf> ski, but records may be positional, too.
08:18:21 <roconnor> ksf: those are complex numbers
08:18:26 <ksf> indeed.
08:18:30 <applicative> why not pairs?
08:18:43 <ski> int80_h : you understand the problem ?
08:18:44 <ksf> hmmm.
08:18:52 * ksf wonders whether it's the same in german.
08:18:54 <ski> ksf : only if you use the non-record syntax
08:18:59 <int80_h> ski : can we go to haskell_overflow?
08:19:09 <Twey> MacDada: In Haskell, a tuple has a length defined at compile-time, and lists must be homogeneous.
08:19:10 <int80_h> or is it haskell-overflow?
08:19:16 <ski> int80_h : itym #haskell-overflow
08:19:31 <ksf> hmmm yes it is.
08:19:33 <MacDada> so a tuple is like an array?
08:19:39 <Phyx-> no
08:19:41 <jmcarthur> not really
08:19:42 <Twey> MacDada: No
08:19:43 <ksf> that's what happens if you don't pay attention in maths.
08:19:44 <applicative> it's funny, I wasn't sure about this claim, but if you search scholar.google for tuple, you'll see the mathematicians systematically use it as a combining form, eg "n-tuple" , the computer scientists as an independent noun.  
08:19:54 <Twey> MacDada: A tuple is like a makeshift data-type
08:20:05 <jmcarthur> arrays are usually assumed to be heterogeneous. you also don't necessarily know the length of an array statically
08:20:19 <ski> ksf : typically the `sqrt (-1) * ' would not be included, if one did a pair representation ..
08:20:19 <roconnor> Saizan: is there a name for the pair (a, Coalgebra f a)? (aka the parameters needed for ana) ?
08:20:27 <Twey> MacDada: It expresses the case where you want to pass a certain number of values in a single value place
08:20:46 <Twey> MacDada: For example, a function that returns both a String and an Integer would typically have a return type (String, Int)
08:20:53 <ksf> applicative, they certainly won't use n-tuple if they mean a two-element tuple.
08:21:02 <ksf> but they use n>2-tuples a lot.
08:21:07 <fryguybob> Twey: I'm not shocked that it's wrong, just at *how* wrong it is.
08:21:14 <Saizan> roconnor: those solutions are very similar but not quite isomorphic, dolio took "Fix FS" and viewed it as "FreeMonad (\r -> (String, [r])) String" before rolling up all the machinery
08:21:30 <jmcarthur> MacDada: tuples are kind of (but not exactly) like cartesian product, if you know what that is
08:21:31 <applicative> ksf, my remarks are no longer a priori, nor from memory 
08:21:40 <Twey> MacDada: A list, on the other hand, expresses the case where you want to pass an unknown (and potentially empty or infinite) number of values of the same type
08:21:52 <int80_h> ski: can you come to haskell-overflow?
08:22:08 <Axman6> MacDada: a tuple is a thing that can cold two or more things (though t tuple that can hold two things is different to a tuple that can hold three things, they're not actually related)
08:22:13 <Saizan> roconnor: iirc that's related to the density monad over 'f', but i'm not that sure.
08:22:20 <jmcarthur> where tuples differ from cartesian product is that (,) is not associative. there are probably other ways they differ, perhaps having to do with _|_
08:22:37 <ski> MacDada : e.g., there's a function, `div' that performs integral division. also there's a function `mod' that computes the remainder in integral division. sometimes you want both at the same time; then you can use the function `divMod', which will return a pair of the quotient and the remainder -- typically, but not always, you take apart the pair to get the two parts right after the call
08:22:42 <applicative> 28,300 uses of "n-tuple" 
08:22:43 <Saizan> roconnor: err, it'd be the density comonad, so maybe i'm just wrong :)
08:22:48 <ksf> a tuple is a triple (a -> b -> a x b, a x b -> a, a x b -> b)
08:22:53 <Twey> fryguybob: MW has been crap since its inception.  The only thing that still surprises *me* about it is that some people still consider it authoritative.
08:22:54 <ski> MacDada : so, tuples are often used for "multiple results" of a function
08:23:38 <int80_h> ski:okay I'll stay here. Here's my confusion. String is a list right?
08:23:47 <ksf> [Char], to be precise.
08:23:56 <ksf> and Chars are UCS codepoints.
08:24:17 <ski> > let (n,d) = (17,5); (q,r) = n `divMod` q in concat ["the quotient of ",show n," and ",show d," is ",show q," and the remainder is ",show r]
08:24:20 <lambdabot>   mueval-core: Time limit exceeded
08:24:27 <ski> @botsmack
08:24:28 <lambdabot> :)
08:24:30 <ski> > let (n,d) = (17,5); (q,r) = n `divMod` q in concat ["the quotient of ",show n," and ",show d," is ",show q," and the remainder is ",show r]
08:24:34 <lambdabot>   mueval-core: Time limit exceeded
08:24:41 <jmcarthur> D:
08:24:49 <ski> .. oh
08:24:57 <ski> > let (n,d) = (17,5); (q,r) = n `divMod` d in concat ["the quotient of ",show n," and ",show d," is ",show q," and the remainder is ",show r]  -- typo :)
08:24:58 <lambdabot>   "the quotient of 17 and 5 is 3 and the remainder is 2"
08:25:02 <ski> MacDada : ^
08:25:38 <shachaf> > let (n,d) = (17,5); (q,r) = n `quotRem` d in concat ["the quotient of ",show n," and ",show d," is ",show q," and the remainder is ",show r]
08:25:38 <lambdabot>   "the quotient of 17 and 5 is 3 and the remainder is 2"
08:25:56 <roconnor> Saizan: I don't get how this line from doilo's solution works:
08:25:59 <int80_h> ski: did you see my response to your question? it scrolls by so fast :)
08:26:02 <roconnor> instance Monad (Unfold n) where
08:26:03 <roconnor>   return a = U () (\_ -> return (Left a))
08:26:11 <ski> int80_h : yes, `String' is `[Char]' .. but that's unrelated to your problem .. you could just as well pass an `[Int]', and try to say `foo [rawlist] = ..rawlist..'
08:26:48 <roconnor> Saizan: return needs to return a forall s. U s ( s -> yadda)), but dolio is explitily using () which has type () and not type s for any s.
08:27:04 <ksf> int80_h, if you write something inside square brackets, it's an element, not the list.
08:27:50 <roconnor> Saizan: Oh, wait, is this an existential type?
08:27:53 <MacDada> yeah, im trying to google 'tuple', thanks for your explanations
08:27:59 <Saizan> roconnor: right
08:28:03 <roconnor> god
08:28:13 <Saizan> roconnor: was wondering what was the best way to say that :)
08:28:17 <roconnor> I like winterkoninkje's solution way better
08:28:54 <Twey> MacDada: The thing to realise is that we talk about ‚Äòtuples‚Äô only as a shorthand
08:28:56 <Saizan> yeah, i'd agree too
08:29:11 <Twey> MacDada: ‚ÄòTuple‚Äô is not a type, or even a type constructor like lists
08:29:16 <applicative> roconnor, that's part of was smooth about it.  In my mind I was comparing it with the iteratee types, which are alarming in a different way
08:29:43 <roconnor> applicative: ah, I guess i haven't studied iteratees deeply
08:29:50 <applicative> roconnor, i mean, I haven't studied winterkoninkje's.   
08:29:55 <Twey> MacDada: It's a general name for product types created by combining other types
08:30:04 <int80_h> huh, okay I am going to read RWH some more and see if I can figure out how to write the code correctly
08:30:17 <roconnor> Saizan: I still haven't really found out why the solutions are not isomorphic
08:30:36 <roconnor> Saizan: I agree that the pieces have been wrapped up in different ways
08:31:00 <roconnor> Saizan: but if you unwrap everything don't you end up with the pieces fitting together in exactly the same way?
08:35:13 <applicative> roconnor, oh I started to look at winterk's.  He renames some standard file things "getDirectoryContents" = "direntries"
08:35:18 <Guest9929> how many of you guys are from reddit?
08:35:20 <int80_h> okay I don't understand how to fix the problem. Maybe it's because I don't understand what the problem is
08:35:53 <roconnor> applicative: ya he lists four primitive directory functions at the top for the user to fill in as he likes
08:36:00 <applicative> roconnor,and so on, but then he presupposes a getdirsize
08:36:03 <Saizan> roconnor: yeah, if you normalize everything they boild down to the same code
08:36:12 <roconnor> applicative: direntries needs to do things like filter out . and ..
08:36:32 <applicative> dirsize also is presupposed, but isn't it basically whats being defined?
08:37:03 <roconnor> applicative: dirsize is supposed to be the size of the directory node,  feel free to define it as const 0.
08:37:21 <int80_h> since String is a list, [String] is a list of lists right?
08:37:21 <roconnor> const (return 0)
08:37:48 <dafis> int80_h: [String] is the type of lists of lists of Char
08:38:10 <dafis> int80_h: [string] is a list containing the single value string
08:38:16 <roconnor> There needs to be more talk about hylomorphisms in undergraduate CS classes I think.
08:39:15 <applicative> roconnor, thanks, i can get back to it, then.
08:39:20 <shapr> Good morning #haskell!
08:39:23 <shapr> How's the invasion?
08:39:27 <ski> roconnor : if `data Foo yadda = forall s. U s ( s -> yadda))', then `Foo' is the `Density Identity' comonad, and also the `Coyoneda Identity' functor
08:39:28 <dafis> int80_h: in the snippet you pasted, all you need to do is change [rawlist] to rawlist in the function definition
08:39:32 <danderson> 95% du paquet en headers, reste la place pour √©crire "coin"
08:39:35 <danderson> oops
08:39:38 <dafis> shapr: abated
08:40:04 <int80_h> dafis: thanks, I need to ponder why tha is right to make sure I understand it
08:40:16 <shapr> dafis: so soon?
08:40:18 <byorgey> hey shapr!
08:40:39 <dafis> int80_h: [a,b] matches a list with two elements, does that shed more light?
08:40:49 <byorgey> shapr: has anything reddit-fueled ever lasted for more than 24 hours?
08:40:51 <dafis> shapr: I'm surprised too
08:41:07 <Saizan> roconnor: in some sense annihilate is an hyloM uncurried in a weird way
08:41:10 <applicative> byorgey, reddit has.
08:41:17 <byorgey> hah.
08:41:25 <int80_h> dafis: gotcha! 
08:41:34 <dafis> int80_h: :D
08:41:40 <int80_h> I had this wrong idea in my head I couldn't shake, I think I have it now
08:41:52 <byorgey> well, hopefully 0.5% of the visitors became genuinely interested in Haskell, and are off reading a tutorial at this very moment
08:41:55 <int80_h> I'm stubborn
08:42:03 <Saizan> roconnor: and specialized for how functor and monad, of course
08:42:06 <Axman6> > let [a,b,c] = "xyz" in (a,b,c)
08:42:07 <lambdabot>   ('x','y','z')
08:42:08 <byorgey> wrong ideas are tricksy like that.
08:42:29 <ski> int80_h : in `listMerge [rawlist] = ..rawlist..' since the argument `[rawlist]' has type `[String]' (i.e. list of `String's), then the (single) element `rawlist' of `[rawlist]' must have type `String'
08:42:35 <roconnor> Saizan: I think it is simply that the a parameter to hyloM is paired with (a -> m (f a)) in annihilate
08:42:52 <Axman6> @src last
08:42:52 <lambdabot> last [x]    = x
08:42:52 <lambdabot> last (_:xs) = last xs
08:42:52 <lambdabot> last []     = undefined
08:42:53 <shapr> hiya byorgey!
08:43:06 <Saizan> roconnor: yeah, and b with (f b -> m b)
08:43:13 <shapr> byorgey: No, reddit is good about aging posts off the front page.
08:43:16 <int80_h> holy cow I've got it!
08:43:24 <roconnor> Saizan: I don't think that is the case
08:43:26 <applicative> int80_h, thats why it was so obvious to me... I didn't know you could write [rawfile] as a case of a list in a definition,
08:43:39 * byorgey awards int80_h with a golden lambda
08:43:40 <applicative> people would usually write x:[] for the singleton list
08:43:51 <monochrom> I write [x]
08:43:52 <byorgey> applicative: I wouldn't.
08:44:03 <Axman6> i do too
08:44:11 <applicative> yeah, shoulndt have put it that way
08:44:18 <int80_h> why would you want a list with only one element? you intend to build on it?
08:44:32 <applicative> i meant, i internalized x:[] at some point, to go with x:xs and x:_
08:44:35 <shapr> Yay golden lambdas!
08:44:36 <byorgey> quite often you want a function to do something particular when given a list with only a single element.
08:44:51 <roconnor> Saizan: annihilate has a >> return () tacked on the end for no good reason
08:44:52 <monochrom> I expect it to be user input.  getArgs >>= \[x] -> ...
08:45:03 <roconnor> Saizan: if you remove that annihilate returns IO Integer
08:45:04 <Twey> I always write [x]
08:45:06 <applicative> the constructors being : and [] ... I was pointing out my cluelessness basically 
08:45:19 <Twey> Rhmn
08:45:27 <PeakerWork> I write a lot of (:[])
08:45:27 <monochrom> there is also qsort which has to treat [x] separately
08:45:37 <dafis> monochrom: I tend to use getArgs >>= \(a:_) -> for that
08:45:46 * byorgey goes back to revising his paper
08:45:57 <monochrom> @src qsort
08:45:57 <lambdabot> Source not found.
08:46:00 <applicative> PeakerWork, me too, maybe that's the source of my blindness to [x] 
08:46:12 <Jagdwurst> hi, may i ask a question about callCC,
08:46:13 <Jagdwurst> callCC :: (MonadCont m) => ((a -> m b) -> m a) -> m a
08:46:14 <Twey> I prefer ‚Äòfmap head getArgs‚Äô
08:46:37 * roconnor tries to understand Monad (Unfold n)
08:46:45 <applicative> head <$> getArgs
08:46:51 <Jagdwurst> the  a in ' m a '   and the first argument a, is not the same type, right?
08:46:55 <Saizan> roconnor: no, these are weak existentials, you get a type error if you remove return ()
08:46:57 <ski> monochrom : like `foo . (:[]) = ...' ? ;)
08:47:07 <monochrom> Jagdwurst: the same type
08:47:13 <roconnor> Saizan: do you know the type of the seed in bind?  It is Either s something
08:47:13 <ski> s/monocrom/PeakerWork/ 
08:47:15 <Twey> :t head <$> getArgs >>= print
08:47:16 <lambdabot> Not in scope: `getArgs'
08:47:20 <Twey> Bah
08:47:24 <dafis> Twey: well, that's not so elegant if you accept two or three args
08:47:44 <monochrom> getArgs is from System.Environment
08:47:45 <Twey> Oh, it does work.
08:47:46 <roconnor> Saizan: really, I don't think so
08:48:04 <applicative> a:b:c:_ <- getArgs
08:48:13 <Saizan> roconnor: check with ghc :)
08:48:23 <Twey> dafis: I tend to do something like getArgs >>= run, then have a pattern-match on ‚Äòrun‚Äô if I'm accepting more than one argument‚Ä¶ until it gets complicated enough to warrant OptParse
08:48:46 <Twey> applicative: [a, b, c] <- take 3 <$> getArgs
08:48:56 <roconnor> Saizan: damn it, why?
08:49:16 <applicative> Twey, stylin'
08:49:26 <roconnor> Saizan: oh, I see
08:49:32 <Twey> Ayup
08:49:42 <roconnor> Saizan: annihilate is polymorphic
08:49:43 <danderson> what fixity do backticked functions take?
08:49:53 <Saizan> because the Fold parameter corresponds to "exists b. f b -> m b"
08:49:56 <applicative> what you assign them
08:49:57 <ski> (btw, i'm not sure it matters, but i'd `return a = U () (\() -> return (Left a))')
08:50:02 <Saizan> so you can't return that 'b'
08:50:12 <Jagdwurst> monochrom: thanks,  i can not understand it immediately , i must think about it ^^
08:50:13 <dafis> danderson: you can give them fixities, they default to infixl 9 iirc
08:50:13 <danderson> ie. how will (EQ ==) `liftM` monadicFu . getter evaluate?
08:50:46 <roconnor> Saizan: okay
08:50:49 <roconnor> data Fold r n a = F (a -> IO r) (n -> [r] -> IO r)
08:50:49 <danderson> ah, 9
08:50:53 <dafis> danderson: ((EQ ==) `liftM` monadicFu) . getter
08:50:54 <danderson> so it won't evaluate :)
08:51:02 <ski> > let foo = (,) in 0 `foo` 1 `foo` 2
08:51:03 <monochrom> "Any operator lacking a fixity declaration is assumed to be infixl 9"
08:51:03 <roconnor> annihilate :: Unfold n a -> Fold r n a -> IO r
08:51:03 <lambdabot>   ((0,1),2)
08:51:05 <roconnor> This complies
08:51:14 <dafis> danderson: unless (.) is infixr
08:51:14 <ski> > let infixr 9 `foo`; foo = (,) in 0 `foo` 1 `foo` 2
08:51:15 <lambdabot>   (0,(1,2))
08:51:15 <roconnor> when you remove the silly existential type for Fold
08:51:17 <roconnor> :)
08:51:20 <Saizan> heh :)
08:51:21 <danderson> (.) is infixr 9, so it'll error out with mixing infix[lr] of same priority
08:51:46 <dafis> danderson: yep
08:51:52 <applicative> roconnor, we don't need the existential type?
08:51:56 <Saizan> roconnor: can you write the Monad instance that way though?
08:52:00 <roconnor> applicative: not in Fold
08:52:02 <roconnor> at least
08:52:17 <roconnor> I'm not touching Unfold here
08:52:29 <Saizan> ah, Fold has no instance
08:52:50 <monochrom> Jagdwurst: perhaps see my http://www.vex.net/~trebla/haskell/cont-monad.xhtml for more information overload
08:53:29 <roconnor> Saizan: so what is the type of the existential in bind?
08:54:04 * ksf files a motion to replace the current hello world with "interact . const $ "Hello,World\n""
08:54:14 <roconnor> Saizan: Either s (n,s)  ?
08:55:11 <Jagdwurst> monochrom: wonderful, that's what i'm looking for.   thanks!
08:55:18 <Saizan> roconnor: no, because of "st (Right (U seed' step'))" it must be "Either s (Unfold ..)"
08:55:23 <monochrom> that will print hello-world 100 times just because I enter 100 characters
08:55:48 <monochrom> if I enter "hello" I get 5 or 6 "hello world"s
08:55:50 <ski> roconnor : .. and `forall r. (a -> IO r) -> (n -> [r] -> IO r) -> IO r' makes more sense than `(exists r. (a -> IO r,n -> [r] -> IO r)) -> IO ()', CPS-wise
08:56:02 <roconnor> ski: yes. 
08:56:11 * applicative agrees, "interact" should be mentioned to beginners at all possible points; it took him forever to find it...
08:56:13 <roconnor> ski: I just have trouble reading haskell data declairations
08:56:20 <roconnor> ski: they are confusing.
08:56:54 <roconnor> ski: oh wait
08:56:59 <roconnor> I don't think I understood your comment
08:57:33 <ski> roconnor : `data Foo = forall x. F (Bar x)' means `forall x. (b :: Bar x) -> (F b :: Foo)' means `forall x. F :: Bar x -> Foo' means `F :: forall x. Bar x -> Foo'
08:58:50 <dafis> monochrom: No, you'll get exactly one "Hello,World", no matter what the input is
08:58:54 <ski> roconnor : the former (`forall r. ..r.. -> IO r') is your `annihilate :: Unfold n a -> Fold r n a -> IO r' case, while the latter (`(exists r. ..r..) -> IO ()') is the `annihilate :: Unfold n a -> Fold n a -> IO ()' case in the paste
08:59:12 <dafis> @type interact
08:59:13 <lambdabot> (String -> String) -> IO ()
08:59:18 <roconnor> ski: why does one way make more sense than the other?
08:59:30 <ski> roconnor : (continuing the other statement) .. means `F :: (exists x. Bar x) -> Foo'
09:00:05 <monochrom> Oh oops!
09:00:47 <applicative> ski, I see, the gadt syntax makes it easier to think about
09:01:06 <applicative> I mean gadt-ish
09:01:08 <ski> roconnor : well, the simple (result-polymorphic) CPS is `forall r. (a -> r) -> r' .. this being isomorphic to `a', if we do `forall r. (a -> IO r) -> IO r' (this then being the `Codensity IO' monad), we can do `IO'-effects on the way, so is isomorphic to `IO a'
09:01:46 <PeakerWork> ski: yeah, like that
09:02:40 <roconnor> Okay, I think I almost understand the Unfold Monad
09:02:42 * applicative thinks doliorules 's module was clearer without mentioning CPS and Codensity...
09:03:09 * applicative starts to get lost as soon as roconnor starts to understand
09:03:18 <jmcarthur> wat. unfold monad?
09:03:26 <ski> roconnor : if we say `forall r. (Maybe (a,IO r) -> IO r) -> IO r', then this is ~iso to `forall r. IO r -> (a -> IO r -> IO r) -> IO r' .. which is the CPS version of a backtracking (i.e. list) monad which can do `IO'
09:03:28 <roconnor> data Fold n a = forall r. F (a -> IO r) (n -> [r] -> IO r)  -- applicative, this screems CPS to me.
09:04:04 <applicative> jmcarthur, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27904
09:04:10 <ski> PeakerWork : well, i haven't got `foo . (:[]) = ...' to be a valid definition (equivalent to `foo [x] = (...) x', for fresh `x') ..
09:04:33 <ski> roconnor : that only encapsulates the two continuations, not the result type
09:04:34 <applicative> roconnor, but it's also like a fold!  ... no surprise
09:05:12 <danderson> is there a way with Cabal to make it build a Library only once, and then build an Executable that depends on that Library without recompiling the lib sources?
09:05:16 <ski> roconnor : typically, we have a computation that takes a number of computations, and returns a result, where the result and the continuations may share some type variables which are universally quantified over the whole shebang
09:05:26 <dcoutts> danderson: yes, make the exe depend on the lib
09:05:33 <ski> roconnor : i.e. `forall r. (a -> m r) -> m r' in the simplest case
09:05:38 <jmcarthur> looks like a stream-fusable rose tree to me
09:05:58 <jmcarthur> aside from the IO part
09:06:00 <ski> roconnor : `exists r. a -> m r' on its own isn't very useful .. it could just as well be `a -> m ()' to begin with
09:06:07 * applicative aiming at maximal concreteness  pasted the ordinary list definitions of fold and unfold under those for types Fold and Unfold, and meditated...
09:06:19 <dcoutts> danderson: and separate the source dirs so that the exe does not pick up the lib modules directly (since normally local modules mask package modules)
09:06:28 <jmcarthur> oh, let me guess. it's from the du thread on reddit?
09:06:44 <applicative> jmcarthur, yes
09:06:58 <roconnor> jmcarthur: We are comparing winterkoninkje's and doliorules's solutions
09:07:26 <ski> roconnor : now `data Fold n a = forall r. F (a -> IO r) (n -> [r] -> IO r)' is more powerful than `data Fold n a = F (a -> IO ()) (n -> [()] -> IO ())', because the `r' occurs in the argument types of the continuations .. still, it feels unnatural to me :)
09:07:44 <applicative> jmcarthur, they are both surprisingly elegant, given that the problem seemed fated to require ugly engineering....
09:08:04 <jmcarthur> relevant http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/
09:08:20 <ski> roconnor : what (where ?) is winterkoninkje's solution ?
09:08:58 <roconnor> [11:39] <ski> roconnor : if `data Foo yadda = forall s. U s ( s -> yadda))', then `Foo' is the `Density Identity' comonad,
09:09:17 <roconnor> ski: but dolio is defining Foo to be a monad, not a comonad
09:09:30 <roconnor> ski: winterkoninkje's solution -> http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/c0uvqqo
09:09:43 <danderson> dcoutts: adding a Build-depends dep on the package makes cabal complain that there is a dependency cycle. Do you have an example of a package that does this kind of linkage?
09:09:54 <applicative> jmcarthur, hm, yes.  I think the surprise was hooking all of this up with IO types.  ... and that it sort of works...
09:10:19 <Saizan> danderson: you need Cabal >= 1.8 iirc
09:11:11 <jmcarthur> applicative: i have written monadic folds and unfolds over fixpoint types before, similar to the style of hyloM in winterkoninkje's post. the only problem with it is that you have to assert an additional property over mapM. i don't remember what that was now
09:11:26 <ski> roconnor : ok, that's interesting, yes (i haven't read all of dolio's paste, yet)
09:11:43 <danderson> Saizan: I do have >=1.8. I'm probably just specifying the dependency incorrectly.
09:12:18 <Saizan> danderson: i've no examples handy, but the dependency must go only inside the build-depend: of the Executable
09:12:28 <jmcarthur> applicative: i haven't seen this done with IO wrapped up in the type before though, so you are right that this is interesting in that respect
09:12:41 <jmcarthur> dolio's version, i mean
09:12:42 <roconnor> ski: but it sure does have a Density Identity feeling to it!
09:13:28 <danderson> Saizan: this is what I have: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27944#a27944
09:13:30 <applicative> jmcarthur, i think we were presupposing these things had been worked out, but might have lacked motivation....
09:13:40 <danderson> and the result remains a "The following packages are involved in a dependency cycle secure-0.1"
09:14:04 <ski> (roconnor : .. and `CoYoneda Identity')
09:15:32 <roconnor> CoYoneda Identity is a monad
09:15:42 <applicative> jmcarthur, I certainly wouldnt have guessed it might have bearing on efficient sensible running around a directory tree...
09:15:50 * roconnor checks the instance
09:16:31 <jmcarthur> applicative: it makes sense to me, but i talk to edwardk too much
09:17:47 <jmcarthur> so i guess ski and roconnor are talking about generalizations of it?
09:17:54 <Saizan> danderson: that configures here with "cabal-install version 0.8.2 using version 1.8.0.6 of the Cabal library", so if it doesn't work with that version it might be a bug
09:17:57 <jmcarthur> how would we compose it from smaller parts?
09:18:03 <djahandarie> That's two times edwardk's name has come up even though he isn't here and this isn't related to him :P
09:18:09 <jmcarthur> heh
09:18:31 <applicative> jmcarthur, I think roconnor, like me, was just trying to figure them out because of the practical problem of dealing with a filesystem and other like things
09:18:34 <roconnor> the CoYonedta Idenitity monad instance appears to be different from the Unfold monad instance
09:18:39 <ski> roconnor : hm, so it is (i forgot that, even though i discovered it myself :)
09:19:37 <roconnor> though I don't know if the difference is signifigant
09:19:50 <ski> jmcarthur : no idea .. just trying to grasp it currently, and making notes on aspects of it (and on roconnor's modification)
09:20:21 --- mode: ChanServ set +o monochrom
09:20:50 --- mode: monochrom set -q *!*@gateway/web/freenode/ip.67.191.127.237
09:20:51 <danderson> Saizan: ah, there we go. It doesn't work with 0.8.0/1.8.0.2.
09:20:56 --- mode: monochrom set -o monochrom
09:21:06 <ski> (right, `CoYoneda' doesn't go around changing the hidden type in `join' ..)
09:21:40 <ski> (monochrom : *that's* why the tryhaskell thing was quiet ?)
09:21:58 <monochrom> no, that is why one troll was defeated
09:22:10 <ski> .. oh, ok
09:22:27 <shapr> After reading through all the comments from the reddit invasion, I have deduced that people do not like to learn things, and in fact dump anger words on you if you get them to try new things.
09:22:44 * ski didn't realize the gateway included the original ip in it
09:22:53 <Saizan> shapr: reddit users /= people
09:23:10 <jmcarthur> reddit users == ??
09:23:19 <mreh> animals
09:23:22 * Phyx- just made his implementation 3x more complex to solve a problem, and then realised the problem was solvable with 3 lines
09:23:27 <shapr> Well, I'm a reddit user. I enjoy drinking from the firehose.
09:23:29 <roconnor> shapr: what did you read?
09:23:38 <jmcarthur> shapr: ow
09:23:45 <shapr> roconnor: http://www.reddit.com/r/programming/comments/cryib/got_5_minutes_try_haskell_now_with_embedded_chat/
09:23:48 <quicksilver> shapr: people who make comments are not representative of people who do not make comments
09:23:53 <quicksilver> shapr: (obviusly)
09:23:58 <mreh> Phyx- premature optimisation?
09:24:00 <shapr> quicksilver: Point
09:24:46 <Phyx-> mreh: no, just an oversight, the new implementation *is* more efficient, but what I was originally trying to solve wasn't solve in the new one, lol
09:24:52 <roconnor> ski: what if we defined return a = U a (return . Left) for Unfold
09:24:55 <roconnor> ski: would that still work?
09:25:14 <monochrom> I have verified "people do not want to learn things" elsewhere in addition to reddit.
09:25:20 <roconnor> heck, what if we defiend return a = U (return (Left a)) id  ?
09:25:41 <Phyx-> mreh: so I would say, it's just a plain old "fail"
09:25:47 <ski> roconnor : i think so (to both)
09:25:50 <roconnor> that would make it start to look more like CoYoneda Indentity
09:25:50 <mreh> *facepalm*
09:26:08 <ski> (not fully sure, but probably so)
09:27:20 <roconnor> ski: return a = U a (return . Left) typechecks
09:27:29 <roconnor> ski: the other yields an infinite recurive type error
09:27:37 <ski> (cf. `return :: Monad m => a -> CoYoneda m a; return a = FMapIncl return a')
09:29:06 <ski> roconnor : hm, i suppose the latter alternative would give a cyclic type ..
09:30:39 <roconnor> ski: I'm going for lunch
09:30:50 <int80_h> read converts a string into a number
09:30:56 <int80_h> what converts a number into a string?
09:31:07 <roconnor> But I still want to figure out where dolio's Unfold monad is hidden inside wingerkoninkje's hylomorphic implementation
09:31:10 <monochrom> show
09:31:14 <ketralnis> int80_h: show
09:31:40 <applicative> > show 17
09:31:41 <lambdabot>   "17"
09:32:09 <monochrom> @quote monochrom going
09:32:09 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
09:32:12 <int80_h> > "entry # " ++ show 1
09:32:13 <lambdabot>   "entry # 1"
09:32:21 <int80_h> thats what I want :)
09:32:46 <int80_h> now I have to figure out if memoization is what I need or if something simpler can be done
09:33:02 <ski> > let (n,d) = (17,5); (q,r) = n `divMod` d in concat ["the quotient of ",show n," and ",show d," is ",show q," and the remainder is ",show r]
09:33:03 <lambdabot>   "the quotient of 17 and 5 is 3 and the remainder is 2"
09:33:04 <mreh> best (worst) names of reddit #23: fapmonad
09:33:04 <dafis> int80_h: for what?
09:33:14 <int80_h> I need to write a function that takes a string and appends an incremented number onto the end
09:33:16 <ski> int80_h : sometimes i find using `concat' like ^ useful
09:33:31 <ski> (one could use `unwords' instead, too ..)
09:33:42 <applicative> int80_h I don't know if show converts a number to a string, it's one of the functions from Int (for example) to  String for
09:33:44 <dafis> int80_h: and you need to remember the last number appended?
09:33:50 <int80_h> so I end up with a list somethig like this ["entry 1", "entry 2"] etc
09:33:59 <dafis> int80_h: sounds like a job for State
09:34:07 <int80_h> dafis: if I can increment without remembering that would be better
09:34:12 <monochrom> > show "xx"
09:34:13 <lambdabot>   "\"xx\""
09:34:20 <ski> > map (("entry " ++) . show) [1,2]
09:34:21 <lambdabot>   ["entry 1","entry 2"]
09:34:23 <monochrom> > show "\"xx\""
09:34:24 <lambdabot>   "\"\\\"xx\\\"\""
09:34:29 <dafis> int80_h: for the above: [string ++ show n | n <- [1 .. ]]
09:34:32 <applicative> > fix show
09:34:33 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
09:34:34 <int80_h> hah!
09:34:49 <int80_h> as soon as I saw [1,2] I realized I could use a lazy list
09:35:42 <zygoloid> i see that a counteroffensive has been launched to scare off the redditors again
09:35:42 <int80_h> thanks guys
09:35:57 <int80_h> you are helping me build a blog :)
09:36:03 <dafis> zygoloid: where did you see that?
09:36:24 <applicative> int80_h, I hope you put it to good use.
09:36:54 <monochrom> redditors can't be scared off
09:37:17 <dafis> monochrom: not even by digging?
09:37:22 <zygoloid> dafis: http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/
09:37:37 <dafis> zygoloid: ah yes, scary :)
09:38:02 <ketralnis> monochrom: oh man you have no idea ;)
09:38:08 <zygoloid> completely seriou=-looking talk of using zygomorphisms as a reasonable approach to implementing du
09:38:19 <int80_h> applicative: I'm not going to all this trouble to track Justin Beiber gossip.
09:38:37 <int80_h> I could use wordpress for that
09:39:26 <mreh> "Lazy IO is a symptom of muddy thinking. It indicates that the programmer is still trying to write procedural code." <- huh?
09:39:46 <zygoloid> yeah, that confuses me. the lazy IO solutions look much more functional and elegant to me.
09:39:48 <int80_h> I want to track my tech interests. Mostly haskell, not exclusively. I'm proting libnova to haskell which seems pretty easy so far but really tedious. Maybe that's a clue I'm doing it wrong.
09:39:51 <applicative> int80_h, hah
09:39:53 <dafis> mreh: who said that?
09:39:59 <zygoloid> they're just... denotationally appalling ;-)
09:40:00 <c_wraith> someone on reddit
09:40:08 <int80_h> porting libnova I mean
09:40:20 <c_wraith> I remember looking at that statement and going "...  I don't think that's true" myself.
09:40:23 <mreh> dafis: http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/c0utyq2
09:40:23 <BMeph> showString s . show
09:40:56 <zygoloid> /strict/ IO for du indicates that you're trying to write procedural code. and /maybe you should be/.
09:41:30 <dafis> zygoloid: agree
09:43:12 <mreh> as opposed to functional code
09:43:17 <mreh> purely functional
09:44:01 <zygoloid> fundamentally du is a procedural problem. you have to think about things like "what happens if someone changes the filesystem while i'm running"
09:44:28 <mreh> why?
09:44:46 <zygoloid> mreh: if you don't care about that, then the lazy IO method is as good as any
09:45:25 <applicative> zygoloid , winterk's and dolio's solutions 'procedural', 'strict', 'lazy'..,?
09:45:44 <applicative> zygoloid, not that they replicate du...
09:47:18 <mreh> most complaints against haskell can be filed in the "but I can do xyz more easily in blub (ignoring all the benefits)"
09:47:21 <zygoloid> suppose later i notice a bug: if a file is renamed while du is running, all of the solutions on that page can miss the size of the file entirely
09:47:44 <zygoloid> this means that users can hide their large files from the sysadmin by running a process which renames them very frequently
09:47:51 <applicative> zygloid, isn't this necessarily a problem?
09:47:54 <zygoloid> the fix is to stat the directory once before and once afterwards
09:48:01 <mreh> clever
09:48:05 <zygoloid> and provide logging if that happens
09:48:13 <zygoloid> so. which of the solutions can that be easily applied to?
09:48:20 <mreh> you'd need to rename them every microsecond
09:48:42 <applicative> zygoloid, don't know, the question is indeed how far their devices can be extended.  
09:49:15 <zygoloid> in all of the 'abstract out the control flow' solutions, it seems like you need a new abstraction
09:49:28 <zygoloid> in the direct non-lazy-IO solution, it's pretty trivial.
09:49:34 * int80_h is his own sys admin.
09:49:47 <applicative> zygloid, what's trivial?
09:50:14 <jmcarthur> props to whoever came up with du as an exercise
09:50:47 <ketralnis> If only there were a way to talk about programming languages without arguing about how much better one is than the other
09:50:54 * applicative is his own sys admin too.  this doesn't stop him from trying to fake out the sys admin
09:51:02 <IPHAIL> hello
09:51:03 <zygoloid> applicative: frud's is the easiest solution to apply the 'bugfix' to.
09:51:24 <zygoloid> because it doesn't try to abstract out the control structure in any way.
09:52:16 <int80_h> How do I use this
09:52:18 <int80_h> [string ++ show n | n <- [1 .. ]]
09:52:21 <int80_h> with this
09:52:31 <int80_h> ripList rlist = Entry "Entry x" "Entry-x" rlist
09:52:49 <jmcarthur> i don't understand the question
09:52:57 <int80_h> "Entry x" and "Entry-x" being strings I want to add an incremented number to
09:53:03 <jmcarthur> ah
09:53:37 <int80_h> am I going to have a seperate function?
09:53:44 <PeakerWork> ski: oops, I meant just (f . (:[])) in general, not as LHS
09:53:54 <IPHAIL> jmcarthur, i will remain on topic
09:53:57 <jmcarthur> int80_h: what is the type that you are looking for?
09:54:12 <jmcarthur> IPHAIL: oh hi! did your ip change or something?
09:54:20 <IPHAIL> no, this is my work computer
09:54:24 <jmcarthur> ah okay
09:54:28 <int80_h> jmcarthur: tyoe is Entry
09:54:32 <int80_h> type!
09:54:45 <IPHAIL> thus proving i am not a troll. if i were a troll, i would've came back on under diff IP
09:55:10 <jmcarthur> IPHAIL: you needn't prove anything. i told you i would unban you today and i meant it
09:55:22 <IPHAIL> lol i dont recall you
09:55:25 <IPHAIL> saying u were going to unban me
09:55:34 <IPHAIL> i assumed u permabanned me
09:55:40 <IPHAIL> and i got depressed
09:56:23 <jmcarthur> "jmcarthur | just catch me tomorrow and remind me to unban you"
09:57:01 <zygoloid> int80_h: what result do you want? ["Entry x1", "Entry-x2"] ?
09:57:17 <IPHAIL> lol but how would i have caught u today
09:57:20 <IPHAIL> if i were banned?
09:57:26 --- mode: ChanServ set +o jmcarthur
09:57:32 <zygoloid> privmsg?
09:57:34 <jmcarthur> IPHAIL: by privmsging me like you did last night
09:57:44 <IPHAIL> i didnt PM u
09:57:52 <IPHAIL> that must've been someone else
09:57:57 <int80_h> zygoloid: yes that's right
09:58:00 <jmcarthur> oh, maybe i'm mixing people up
09:58:15 <IPHAIL> im bored at work, going to python channel
09:58:17 <jmcarthur> did you at some point use the nick butSERIOUSLY?
09:58:22 <int80_h> zygoloid : no wait that's not it
09:58:40 <IPHAIL> i cant figure out how to get in though
09:58:54 --- mode: jmcarthur set -b *!*@gateway/web/freenode/ip.76.199.9.12
09:58:59 --- mode: jmcarthur set -q *!*@gateway/web/freenode/ip.76.199.9.12
09:59:03 --- mode: jmcarthur set -o jmcarthur
09:59:35 <IPHAIL> ..
09:59:48 <jmcarthur> if that's not you then sorry, i had you mixed up with somebody else
09:59:54 <zygoloid> int80_h: should i keep guessing? ;-)
10:00:36 <int80_h> zygoloid : [Entry "Entry x1", "Entry x-1", "Content"], then next list would be [Entry "Entry x2", "Entry x-2", "content"]
10:00:49 <int80_h> I had a bit to type :)
10:00:53 <zygoloid> int80_h: ah, i see! ok
10:01:10 <zygoloid> int80_h: and the "Content" comes from rlist?
10:01:39 <int80_h> zygoloid : yes
10:01:43 <applicative> zygoloid	 well frug's immediately falls into unpleasant recursion from "."   of course.  It will need repair.
10:02:00 <zygoloid> ripList rlist = zipWith3 Entry (numbered "Entry x") (numbered "Entry-x") rlist
10:02:12 <zygoloid> int80_h: ^^ where numbered string = [string ++ show n | n <- [1..]]
10:02:31 <int80_h> zip!
10:02:33 <zygoloid> applicative: sure :)
10:02:39 <ksf> .oO( foldr (.) id )
10:02:40 <zygoloid> int80_h: do you know about zip?
10:02:47 <benmachine> [Entry (num "Entry x") (num "Entry x-") "Content" | num <- map (flip (++) . show) [1 ..]]
10:02:50 <jmcarthur> ah he was right, that wasn't him
10:02:50 <benmachine> <_<
10:03:07 <int80_h> zygoloid : yes I do but there's alot to know and it never occured to me that that is what I wanted. Makes perfect sense htough.
10:03:09 <zygoloid> benmachine: int80_h wanted to build it by composing some existing stuff :)
10:03:39 <benmachine> oh, as you like it
10:03:46 <mwc> I don't understand why instance OtherClass a => SomeClass a overlaps with instance SomeClass Foo when Foo is not an instance of OtherClass
10:03:53 <int80_h> yes what zygoloid did is what I wanted.
10:04:03 <zygoloid> i like the map (flip (++) . show) ;)
10:04:04 <benmachine> mwc: because you can write instance OtherClass Foo somewhere
10:04:08 <ksf> mwc, it _may_.
10:04:26 <benmachine> mwc: better still, you can write these instances all in separate modules and then import them all
10:04:33 <benmachine> or import things that import them
10:04:40 <benmachine> or otherwise break everything horribly
10:04:45 <applicative> and your user will fall into despair
10:04:49 <ksf> overlapping instances are evil.
10:04:56 <ksf> much more so than undecidable ones.
10:04:56 <zygoloid> mwc: "instance OtherClass a => SomeClass a" does /not/ mean 'a is a SomeClass if a is an OtherClass'.
10:05:19 <applicative> it's the 'Satanic Verses' of ghc extensions?
10:05:20 <ski> zygoloid : well, it does ..
10:05:23 --- mode: ChanServ set +o jmcarthur
10:05:33 --- mode: jmcarthur set -q *!*@gateway/web/freenode/ip.76.11.34.162
10:05:33 <mwc> zygoloid: no, I'm providing an implementation of SomeClass valid for all instances of OtherClass
10:05:34 <zygoloid> mwc: rather, it means "a is a SomeClass. but in order to use that fact you need an OtherClass instance"
10:05:35 <ksf> I think that'd be IncoherentInstances
10:05:38 --- mode: jmcarthur set -b *!*@gateway/web/freenode/ip.76.11.34.162
10:05:42 --- mode: jmcarthur set -o jmcarthur
10:05:55 <dibon> Is there a function like !! for tuples? For example: (1,2,3) !! 2 returns 3
10:05:57 <zygoloid> ski: yeah, true, i meant iff ;-)
10:06:05 <ksf> dibon, it's called fst and snd.
10:06:12 <ksf> if you need more, there's Data.Nthable.
10:06:14 <dafis> dibon: no, there isn't
10:06:14 <applicative> dibon, there is one for pairs, fst snd
10:06:22 <dibon> ok, thanks
10:06:22 <ski> zygoloid : but, as you know, GHC will not use `OtherClass a' to resolve the `SomeClass a' part ..
10:06:27 <ksf> but in general, you should just define a data type.
10:06:36 <mwc> Ah, well, any idea of how to implement SomeClass for several types which have identical implementations? There's got to be something better than cut and paste
10:06:44 <ski> zygoloid : heh, `<=>' is a completely different thing, yes
10:07:27 <ksf> mwc, default intstances, deriving via template haskell
10:07:29 <aavogt> didn't overlapping instances for that already come up?
10:07:34 <applicative> dibon, but there cant be one for all cases, absent wild type hackery, since  (a,b) and (a,b,c) and (a,b,c,d) etc can't be brought under one head
10:07:46 <benmachine> mwc: newtype is the usual way
10:08:01 <zygoloid> overlapping instances doesn't look at the context either
10:08:03 <ksf> Data.Nthable isn't "wild type hackery".
10:08:14 <applicative> Is so!
10:08:25 <ksf> HList is.
10:08:32 <zygoloid> nor does incoherent instances, even. :/
10:08:40 <benmachine> newtype WrappedOtherClass = WrappedOtherClass { unWrapOtherClass :: a }; instance (OtherClass a) => SomeClass (WrappedOtherClass a)
10:08:42 <int80_h> zygoloid : I've screwed something up, I'm posting the full context on hpaste
10:08:50 <mwc> ksf: a default instance would require the OtherClass constraint to be moved to the SomeClass declaration, making it a superclass, which is isn't
10:09:03 <ksf> ...even nicer with GeneralisedNewtypeDeriving
10:09:05 <applicative> sorry, yes, Data.Nnthable isn't I was thinking of HList
10:09:23 <ski> zygoloid : it would be nice if it would look at the context .. but i'm not sure of the implications and how to implement it nicely
10:09:25 <mwc> it's more that for all instances of OtherClass, there's a convenient and identical implementatin
10:09:55 <ski> (zygoloid : simply because it would make it more useful as a logic programming language :)
10:09:56 <TITUSANDCONICUS> HELLO!
10:09:58 <TITUSANDCONICUS> I'm the cashman
10:10:04 <TITUSANDCONICUS> I give you money for your gold
10:10:07 <TITUSANDCONICUS> Oh yeah
10:10:09 <TITUSANDCONICUS> ketralnis: 
10:10:22 <TITUSANDCONICUS> So
10:10:27 <TITUSANDCONICUS> what is this place?
10:10:27 <ski> TITUSANDCONICUS : what is your Haskell question ?
10:10:30 <TITUSANDCONICUS> Anyone see Inception yet?
10:10:32 <cydergoth> hi - quick question - when parsing with Parsec, how should I parse an instance of an enum? e.g. G00 where data GCodeCmd = G | M | .... deriving (Show,Read)
10:10:44 <TITUSANDCONICUS> My haskell question is
10:10:46 <zygoloid> ski: well, the trouble is it'd be pretty useless without allowing overlapping instances, and once you do that you need all instances in scope all the time to get the right results, i think.
10:10:56 <krakklez> what is haskell?
10:11:03 <TITUSANDCONICUS> HOW MUCH MONEY DO YOU WANT THAT MUCH MONEY YOU cAN GET BY SENDING ME YOUR OLD GOLD AND USED JEWELRY FOR YOUR CASH
10:11:10 <krakklez> www.listshoes.com
10:11:19 <fryguybob> @where ops
10:11:21 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
10:11:25 <applicative> TITUSANDCONICUS, it's "Titus Andronicus", go away.
10:11:31 <krakklez> he sucks at spelling
10:11:33 --- mode: ChanServ set +o dcoutts
10:11:33 <krakklez> or typing
10:11:35 * ksf joyfully remembers scamming isk scammers on eve
10:11:36 <krakklez> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
10:11:37 --- mode: dcoutts set +b *!*ae72f893@gateway/web/freenode/ip.174.114.248.147
10:11:37 <int80_h> zygoloid : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27949#a27949
10:11:37 --- kick: TITUSANDCONICUS was kicked by dcoutts (TITUSANDCONICUS)
10:11:42 <krakklez> :(
10:11:44 <krakklez> :](
10:11:46 <krakklez> :'(
10:12:21 <krakklez> z y x w v u t
10:12:24 <benmachine> int80_h: Entry is a type *and* a constructor
10:12:34 <krakklez> s r q p o n m
10:12:37 <ksf> erm, no.
10:12:45 <ksf> Entry is a type, whereas Entry is a constructor.
10:12:50 <applicative> Or, "Entry" is a type, Entry is a constru
10:12:52 <krakklez> l k j i h g f e d c b a
10:12:58 <krakklez> HI PLEDIII
10:12:59 <applicative> hah'
10:13:01 <dcoutts> krakklez: behave please
10:13:02 <ski> krakklez : Haskell is a programming language
10:13:02 <krakklez> HOW'S IT GOING
10:13:05 <krakklez> OH
10:13:06 <krakklez> COOL
10:13:15 <ski> krakklez : do you have a Haskell-related question ?
10:13:23 <ski> (and there's no need to yell)
10:13:26 <krakklez> well I wondered what it was
10:13:27 <benmachine> ksf: heh, yes fair enough
10:13:29 <zygoloid> int80_h: try this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27949#a27950
10:13:33 <benmachine> the string "Entry" can refer to either etc.
10:13:38 --- mode: ChanServ set +o shapr
10:13:43 <ski> @where lyah
10:13:43 <lambdabot> http://www.learnyouahaskell.com/
10:13:48 <ski> krakklez : try that ^ ?
10:13:50 <dafis> int80_h: zipWith (\rlist n -> Entry (numbered "Entry x" n) (numbered ".." n) content) rawlist [1 .. ]
10:13:55 <shapr> Hiya IPHAIL, how's code?
10:14:13 <IPHAIL> coding is going great thanks
10:14:32 <IPHAIL> i've almost finished a program which scours the web for top quality pr0nz 
10:14:43 <cydergoth> As it seems to have gotten lost in the spammer noise:  hi - quick question - when parsing with Parsec, how should I parse an instance of an enum? e.g. G00 where data GCodeCmd = G | M | .... deriving (Show,Read)
10:14:59 <ksf> is it tryhaskell, or do we experience the wrath of 4chan?
10:15:03 <benmachine> dafis: assuming the content in the lambda should be rlist?
10:15:24 <dafis> benmachine: yes, it's not correct though
10:15:32 <danderson> ksf: it appears to be more the wrath of reddit, tryhaskell and friends made it high on programming and the front page
10:15:48 <benmachine> cydergoth: are there a lot of elements in the enum?
10:15:55 <ksf> oh noes now they know we are on freenode
10:15:58 <dafis> int80_h: but I think you want zipWith combin rlist [1 .. ]
10:16:02 <cydergoth> @benmachine about 15-20
10:16:02 <lambdabot> Unknown command, try @list
10:16:11 <dafis> int80_h: where combine numbers
10:16:13 <cydergoth> benmachine: about 20
10:16:15 <benmachine> heh
10:16:20 <benmachine> right hmm
10:16:33 <benmachine> it has an instance for Show that behaves sensibly?
10:16:35 <IPHAIL> you can blame reddit for me being here
10:16:44 <int80_h> dafis: I'm trying the code zygloid suggested. It looks right but I must run it and study it.
10:16:44 <cydergoth> benmachine: yes
10:17:10 <cydergoth> benmachine: Each element is a single character if that helps
10:17:13 <ski> @type Text.ParserCombinators.ReadP.readS_to_P
10:17:13 <ski> @type Text.ParserCombinators.ReadPrec.readS_to_Prec
10:17:13 <lambdabot> forall a. ReadS a -> Text.ParserCombinators.ReadP.ReadP a
10:17:14 <lambdabot> forall a. (Int -> ReadS a) -> Text.ParserCombinators.ReadPrec.ReadPrec a
10:17:30 <harro> harro
10:17:33 <krakklez> lol IPHAIL
10:17:37 <krakklez> you phail.
10:17:42 <ski> cydergoth : if you were using one of `ReadP' or `ReadPrec', you could use those ^ .. not sure about `Parsec', though
10:17:45 <krakklez> ksf no we are not 4chan
10:17:49 <krakklez> we are randoms from some other channel
10:17:52 <IPHAIL> harro?
10:17:53 <krakklez> got bored
10:18:01 <cydergoth> ski: Maybe parsec is not the right method then 
10:18:09 <benmachine> parsec's fine
10:18:17 <int80_h> oh I get it, because I'm using zipWith3, I don't need map
10:18:25 <danderson> Reminder: unlike reddit, this channel doesn't just exist to help pass the time. Please keep the signal-to-noise ratio high, or take it to #haskell-blah
10:18:31 <benmachine> cydergoth: firstly, I'd change the deriving to (Enum,Eq,Ord,Show) -- and Read if you need it
10:18:35 <benmachine> hmm
10:18:36 <benmachine> actually
10:18:37 <ski> cydergoth : though, there's always the direct parsing way with `Parsec', matching on `G', &c. manually
10:18:43 <cydergoth> ski, benmachine: gcode looks like this G00 X+3.34 Y-.23 Z1,2
10:18:54 <benmachine> you only need Enum and Show for what I'm going to propose
10:19:02 <benmachine> whatever else is up to you
10:19:20 <benmachine> oh wait actually
10:19:23 <benmachine> can you derive Bounded?
10:19:25 <benmachine> I think you can
10:19:26 <cydergoth> ski,benmachine: G, X, Y, Z are commands in the Enum (it is an Enum btw, just forget to type that)
10:19:34 <benmachine> is it Bounded as well?
10:19:36 <cydergoth> benmachine: Probably
10:19:40 <benmachine> ok
10:19:44 <benmachine> then I would do something like
10:19:56 <cydergoth> benmachine: as in it has a finite and known set of values?
10:19:56 --- mode: ChanServ set -o dcoutts
10:20:12 <ski> @src Bounded
10:20:13 <lambdabot> class  Bounded a  where
10:20:13 <lambdabot>     minBound, maxBound :: a
10:20:15 * roconnor resumes trying to understand the Unfold monad
10:20:22 <benmachine> cydergoth: as in the type class, so I can get minBound
10:20:38 <benmachine> cydergoth: but as long as you have a way of listing every constructor (I was going to use [minBound ..]) that's fine too
10:20:44 <cydergoth> benmachine: .... one sec ...
10:20:52 <benmachine> cydergoth: anyway, then you just use something like
10:20:53 <benmachine> :t choice
10:20:54 <lambdabot> Not in scope: `choice'
10:20:57 <benmachine> hmm
10:21:01 <benmachine> :t Text.Parsec.choice
10:21:02 <lambdabot> forall t s u (m :: * -> *) a. (Text.Parsec.Prim.Stream s m t) => [Text.Parsec.Prim.ParsecT s u m a] -> Text.Parsec.Prim.ParsecT s u m a
10:21:04 <ski> benmachine : might as well make it `[minBound .. maxBound]' ..
10:21:17 <cydergoth> benmachine: Compiler says 'Yes'
10:21:22 <benmachine> ski: might as well, I suppose
10:21:31 <benmachine> ski: although:
10:21:34 <benmachine> > [LT ..]
10:21:35 <lambdabot>   [LT,EQ,GT]
10:21:39 <benmachine> anyway.
10:21:43 <benmachine> um
10:21:50 <ski> (`Integer' is not in `Bounded' .. but, yes)
10:21:52 <int80_h> zygoloid : thanks, this is exactly what I wanted. Now I need to combine this with the actual code I'll be using.
10:22:08 <benmachine> so yeah, the choice function gets a list of parsers, and tries each of them in turn
10:22:09 <ski> (hm, i suppose `Natural' would have been more appropriate)
10:22:15 <zygoloid> int80_h: no problem
10:22:39 <benmachine> you make your list of parsers by taking each constructor in turn, matching against the string found by using "show" on it
10:22:49 <benmachine> and then returning that constructor if the match was successful
10:22:57 <benmachine> so something like
10:23:22 <benmachine> parseThing = choice $ map (\thing -> string (show thing) >> return thing) [minBound ..]
10:23:48 <cydergoth> benmachine: So there isn't a parsec primitive for parsing an Enum?
10:23:55 <benmachine> parseThing = choice [thing <$ string (show thing) | thing <- [minBound ..]]
10:24:14 <benmachine> cydergoth: I don't think so, it's kinda too specific a case to warrant its own primitive
10:24:18 <benmachine> it's a one-liner anyways :)
10:24:45 <benmachine> (the two things I gave are equivalent, to give you an idea of the different ways you can express things)
10:24:59 <ski> (it might be nice to have it somewhere in `Parsec', anyway ..)
10:25:07 <cydergoth> benmachine: I'd have thought most grammers/ASTs would have an Enum in somewhere - +/-/ etc 
10:25:17 <cydergoth> benmachine: in expr parsers for example
10:25:21 <benmachine> cydergoth: yeah, fair point
10:25:41 <benmachine> ddarius: hey, want to add a bounded-enum parser to parsec? :)
10:25:55 <cydergoth> benmachine, ski: Thx y'all very helpful ;-)
10:26:04 <int80_h> can I use where inside a do block?
10:26:18 <Twey> int80_h: No
10:26:19 <zygoloid> in a let binding, yes. otherwise, no.
10:26:20 <dafis> int80_h: no, use let
10:27:11 <ski> int80_h : you can use `foo x = do ..y.. where y = ..x..' of course, but the bindings in the `where' can't see any local `do'-bindings
10:27:42 <benmachine> cydergoth: oh, one thing I forgot to mention
10:28:06 <cydergoth> benmachine: ?
10:28:17 <benmachine> cydergoth: remember that parsec doesn't do backtracking by default
10:28:32 <benmachine> so if your enum contained e.g. XX | XY, then parsing XY would fail
10:28:44 <cydergoth> benmachine: It should be ok, all the commands are single character
10:28:58 <benmachine> because it would consume the X of XX, and then reach the Y and think "this isn't what I wanted" and die
10:29:15 <benmachine> cydergoth: yeah I know, just remember it for later :) it's easy to fix by putting "try" in the right place
10:29:19 <ski> benmachine : i suppose the general definition could left-factor the strings ..
10:29:30 <roconnor> preflex: seen edwardk
10:29:30 <preflex>  edwardk was last seen on #haskell 1 day, 5 hours, 30 minutes and 24 seconds ago, saying: ivanm: well, i was getting ready to do the same thing with masters degrees ;) it is satisfying to those who have an addictive personality ;)
10:29:30 <benmachine> ski: yeah, or just backtrack >_>
10:29:36 <ski> mm
10:30:05 <benmachine> a nice left-factorer might be useful actually
10:30:24 <cydergoth> benmachine: where you say minBound do you mean the literal lowest value or is there a way to get that automatically from the Bounded class?
10:30:38 <benmachine> cydergoth: minBound is a member of Bounded, yes
10:30:49 <benmachine> > [minBound ..] :: [Char]
10:30:50 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
10:31:06 <ski> cydergoth : when you derive `Bounded', the first constructor will be the `minBound'
10:31:17 <cydergoth> benmachine: So what's the syntax to get it from my data type GCodeCmd?
10:31:24 <ski> > [minBound .. maxBound] :: [Ordering]
10:31:25 <lambdabot>   [LT,EQ,GT]
10:31:26 <cydergoth> ski: So I have to explicitly order my enum?
10:31:27 <ski> @src Ordering
10:31:27 <lambdabot> data Ordering = LT | EQ | GT
10:31:58 <ski> cydergoth : no (or, yes, i suppose), it uses the order you've written them in the datatype definition
10:32:00 <cydergoth> ski: not that that is hard as it is alphabetical but I'm asking for the general case
10:32:00 <aristid> > text [minBound .. maxBound] :: [Char]
10:32:01 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:32:01 <lambdabot>         against inferred ty...
10:32:06 <aristid> > text [minBound .. maxBound]
10:32:07 <lambdabot>   !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]...
10:32:28 <ski> cydergoth : so it uses the explicit order you've used, when you listed the constructors ..
10:32:36 <zygoloid> cydergoth: the derived Enum instance will use the order in which you write the constructors in the data definition
10:32:48 <benmachine> cydergoth: in the general case, you need some way of producing a list of all constructors, if you're deriving both Bounded and Enum, then [minBound ..] does exactly that
10:32:52 <cydergoth> benmachine: So the compiler gets the context for minBound from the type inference?
10:32:57 <benmachine> yes
10:33:20 <cydergoth> benmachine: thx, I think I'm starting to understand some Haskell....
10:33:21 <benmachine> although, if you did, say, length [minBound .. maxBound], the compiler might not have sufficient information to work out the correct tyoe
10:33:24 <benmachine> type
10:33:47 * zygoloid ponders whether [..] as a shorthand for [minBound..maxBound] might be interesting ;-)
10:33:48 <benmachine> so you have to be careful that there is enough information available for the type to be inferred
10:33:50 <ski> it depends on whether the context where that appears have that sufficient information or not
10:34:09 <EvanR-work> that aspect of haskell really explodes my head
10:34:22 <ski> why ?
10:34:37 <EvanR-work> not used to stuff meaning different things depending on where in the code i stick it
10:34:52 <cydergoth> benmachine: ok, last question - which import do I need for <$?
10:35:04 <ski> EvanR-work : it's "just" overloading
10:35:11 <aristid> > [..'A']
10:35:12 <lambdabot>   <no location info>: parse error on input `..'
10:35:13 <benmachine> cydergoth: it's in Control.Applicative, or in really recent versions of GHC it's also in Data.Functor
10:35:19 <ski> EvanR-work : just like `show' means different things in `show False' and `show 42'
10:35:23 <EvanR-work> ski: yes
10:35:24 <aristid> zygoloid: yes, it would be cool, if generalised
10:35:33 <EvanR-work> ski: but show gives some context
10:35:45 <cydergoth> benmachine: I have a recent GHC - which is preferable? 
10:35:48 <ski> (EvanR-work : only it's overloaded on the result-type in the above case .. which not as many languages do .. Ada, i think)
10:35:52 <EvanR-work> 42 may not be a Int though
10:36:16 <EvanR-work> fromIntegral may not return an Int
10:36:16 <benmachine> cydergoth: up to you, pretty much, there's no operational difference
10:36:17 <ski> EvanR-work : `map show' on its own may not be sufficient context for `show'
10:36:17 <EvanR-work> etc
10:36:24 <benmachine> so it's just which you prefer stylistically I suppose
10:36:42 <cydergoth> benmachine: presumably Control.Applicative is the more compatible version?
10:36:54 <benmachine> cydergoth: yeah
10:36:56 <zygoloid> is there a nice way of binding three names with different types to the same expression? nicer than  a :: A; b :: B; c :: C; (a,b,c) = (e,e,e) where e = ... ?
10:37:02 <EvanR-work> gotta go to lunch
10:37:19 <cydergoth> benmachine: it compiles, so I'm gonna ship it!
10:37:23 <ski> zygoloid : `[a,b,c] = replicate 3 e' ?
10:37:23 <benmachine> cydergoth: woooo
10:37:35 <zygoloid> ski: they have different types :)
10:37:39 <ski> zygoloid : hrm .. actually you had differing types
10:37:54 <ski> zygoloid : so, what is the common part of the types ?
10:37:58 <benmachine> zygoloid: maybe something evil with existentials, but I don't know of an easy way
10:38:05 <zygoloid> ski: complex and nasty, i'm afraid
10:38:18 * ski insists :)
10:38:29 <benmachine> zygoloid: what's the type of e?
10:40:04 <roconnor> ski: Dolio's Unfold monad is almost not used
10:40:21 <ski> zygoloid : hm .. this might be a case where i'd like to write `a @ b @ c = e', doing specializations of type on the left-hand-side
10:40:37 <roconnor> ski: The monad is only used in sizes, and body of sizes can easily be inserted into find and eliminated.
10:40:57 <roconnor> ski: in particular the monad instance has nothing to do with annihilate
10:41:08 <zygoloid> benmachine, ski: e :: (MonadStruct m, MonadAddressSpace m, MonadSymbol m, HasField (WayOf m) s Field_header, HasField (WayOf m) (Deref (s :~>: Field_header) Field_ptrs), Deref (Deref (s :~>: Field_header) :~>: Field_ptrs) ~ Ptr StgClosure) => m s -> m [Ptr StgClosure]
10:41:24 <zygoloid> (that's not the principle type, but it's an acceptable simplification of it)
10:41:32 <ski> (this would be similar to doing stuff like `foo :: (forall m. Monad m => m Foo) -> ...; foo (Just foo) = ...' i.e. doing type specializations in argument-matchings)
10:41:32 * benmachine explodes
10:42:07 <int80_h> help me fix indentation here please
10:42:08 <int80_h> >                  finallist <- zipWith3 Entry (numbered "Entry ") (numbered "Entry-" entries
10:42:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:42:10 <ski> zygoloid : and `A',`B',`C' ?
10:42:12 <int80_h> >                  let numbered string = [string ++ show n | n <- [1..]]
10:42:13 <lambdabot>   not an expression: `let numbered string = [string ++ show n | n <- [1..]]'
10:42:16 <int80_h> oops
10:42:20 <int80_h> I will hpaste
10:42:42 <benmachine> oh yeah, this reminds me of a question I had, suppose D is a data family, is it possible to pattern match against a D a?
10:42:44 <zygoloid> ski: A :: (Monad... m) => Ptr StgThunk -> m [Ptr StgClosure]
10:42:59 * ski . o O ( `WayOf TheExplodingFist' )
10:43:17 <zygoloid> ski: they differ on the actual type s, which allows most of the context to resolve
10:43:41 <zygoloid> and i want different top-level functions because missing a ptr cast would otherwise cause the code to break
10:43:50 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27952#a27952
10:44:05 <ski> zygoloid : the only way i can think of is to name `e', and use that name in three separate definitions of `a',`b',`c'
10:44:10 <benmachine> int80_h: missing parenthesis
10:44:25 <zygoloid> ski: yeah. i guess that's not really terrible.
10:44:31 <dafis> int80_h: missing ) : (numbered "Entry-" entries
10:44:39 <ski> (which is more or less what you suggested, initially, i note)
10:44:48 <zygoloid> plus i guess i can put it into a where clause so the rest of the module can't see it
10:45:15 * ski sometimes misses `local'-`in', in haskell
10:45:17 <zygoloid> "a, b, c = e" might be a nice parallel to "a, b, c :: T"
10:45:31 <ski> zygoloid : `a @ b @ c = e', as i said :D
10:45:41 <ski> (but, yes)
10:45:54 <ski>   local
10:45:56 <ski>     e = ...
10:45:58 <ski>   in
10:46:00 <ski>     a = e
10:46:00 <zygoloid> int80_h: you're missing a ) on line 5
10:46:02 <ski>     b = e
10:46:04 <ski>     c = e
10:46:17 <ski> would only export the `a',`b',`c' bindings
10:46:22 <ski> (this exists in SML)
10:46:31 <zygoloid> ski: actually, i've wanted (foo -> a)@(bar -> c)@(baz -> c) since we got view patterns
10:46:32 <benmachine> zygoloid: you then have syntax which changes meaning when you insert brackets
10:46:38 <benmachine> but I suppose that's already the case with tuples
10:46:56 <benmachine> zygoloid: parallel :O
10:47:12 <ski> zygoloid : yeah, `(foo -> blah) = ..blah..' is an interesting idiom :)
10:47:22 <aristid> ski: let (a,b,c) = let e = ...; a = ...; b = ...; c = ... in (a,b,c)?
10:47:42 <benmachine> > let (id -> x) = 3 in x
10:47:43 <lambdabot>   3
10:47:54 * benmachine thinks about this
10:47:57 <cydergoth> benmachine, ski: Success ;-)
10:48:04 <benmachine> cydergoth: awesome
10:49:26 <zygoloid> > let xs@(zipWith (+) xs . drop 1 -> ys) = 0:1:ys in xs
10:49:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:49:31 <zygoloid> \o/
10:51:07 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27952#a27953
10:51:10 * benmachine lols
10:51:13 <int80_h> okay problem with return now
10:51:21 <int80_h> or something, not sure return is the problem
10:51:29 <benmachine> view patterns are the best way of encoding recursion ever :P
10:51:58 <benmachine> int80_h: changing indentation with the let
10:52:04 <benmachine> I think is upsetting the parser
10:52:20 <jmreardon> int80_h: unclosed paren on the line previous?
10:52:28 <zygoloid> int80_h: your let is indented too far.
10:52:39 <ski> > let (memo (0,12) -> fib) = \n -> case n of {0 -> 0; 1 -> 1; n -> fib (n - 1) + fib (n - 2)} in fib 12
10:52:40 <lambdabot>   144
10:52:41 <zygoloid> int80_h: also, you may as well move 'numbered' to the top level...
10:52:53 <zygoloid> (or to a where-clause for processEntries maybe)
10:53:01 <ski> benmachine,zygoloid : ^ e.g.
10:53:30 <zygoloid> there's no need to have it let-bound in your do-block since it's not dependent on a name which you bind in that block.
10:53:56 <zygoloid> ski: haha, awesome
10:54:07 <ski> (unfortunately one can't mix this with multiple equations for it, though .. i suspect that that actually works is an unexpected side-effect of making view-patterns work for argument-matching)
10:54:18 <benmachine> :t memo
10:54:18 <lambdabot> forall i e. (Ix i) => (i, i) -> (i -> e) -> i -> e
10:54:32 <ski> benmachine : just going via `Array', here
10:54:36 <ski> @type tabulate
10:54:36 <lambdabot> forall i e. (Ix i) => (i, i) -> (i -> e) -> Array i e
10:54:37 <Tomsik_> :t memo
10:54:38 <lambdabot> forall i e. (Ix i) => (i, i) -> (i -> e) -> i -> e
10:54:43 <benmachine> ic
10:54:46 <zygoloid> > let a :: Int; b :: Double; c :: Ratio Int; (thrice -> (a, b, c)) = e where thrice x = (x,x,x); e = 0 in a
10:54:47 <lambdabot>   Not in scope: `thrice'
10:54:57 <zygoloid> > let a :: Int; b :: Double; c :: Ratio Int; (thrice -> (a, b, c)) = e; thrice x = (x,x,x); e = 0 in a
10:54:58 <lambdabot>   Not in scope: `thrice'
10:54:59 <ski> <ski> @let memo :: Ix i => (i,i) -> (i -> e) -> (i -> e); memo ix f = (tabulate ix f !)
10:55:05 <ski> <ski> @let tabulate :: Ix i => (i, i) -> (i -> e) -> Array i e; tabulate ix f = array ix (map (graph f) (range ix))
10:55:31 <zygoloid> > let thrice x = (x,x,x) in let a :: Int; b :: Double; c :: Ratio Int; (thrice -> (a, b, c)) = 0 in a
10:55:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:55:32 <lambdabot>         against inferred type ...
10:55:40 <benmachine> :t graph
10:55:40 <zygoloid> ^^ so close :(
10:55:40 <lambdabot> forall (arr :: * -> * -> *) a b. (Arrow arr) => arr a b -> arr a (a, b)
10:55:43 <Twey> > let a :: Int; b :: Double; c :: Ratio Int; thrice x = (x, x, x); (thrice -> (a, b, c)) = e; e = 0 in a
10:55:44 <lambdabot>   Not in scope: `thrice'
10:55:47 <Twey> Huh.
10:55:54 <zygoloid> not quite polymorphic enough ;(
10:56:01 <int80_h> zygoloid : moving numbered to the top level means removing let and aligning indentation with do block?
10:56:07 <Twey> View patterns are weird about scope.
10:56:08 <ski> (zygoloid : nice example with fibs, there :)
10:56:17 <ski> Twey : howso ?
10:56:45 <Twey> > let f (g -> x) = x; g = (+ 2) in f 3
10:56:46 <lambdabot>   5
10:56:48 <Twey> Oh
10:56:50 <Twey> Maybe not.
10:56:55 <ski> @type let foo (f -> x) f = x in foo  -- hm ?
10:56:56 <lambdabot>     Illegal view pattern:  (f -> x)
10:56:56 <lambdabot>     Use -XViewPatterns to enable view patterns
10:57:00 <Twey> I'm confused by the error up there.
10:57:07 <int80_h> because I'm getting a parse error on = when I do what I just described above
10:57:12 <ski> > let foo (f -> x) f = x in foo 2 (^3)
10:57:13 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:57:13 <lambdabot>    `SimpleReflect.FromExpr ...
10:57:22 <benmachine> > let (g -> x) = 3; g = (+ 2) in x
10:57:23 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:57:23 <lambdabot>    `SimpleReflect.FromExpr ...
10:57:27 * benmachine melts
10:57:47 <benmachine> it uses the g from the outer scope there
10:57:49 <ski> ok, apparently variables bound in "later" arguments aren't in scope in view-patterns in "earlier" ones
10:58:06 <benmachine> ski: yeah, that annoys me too
10:58:17 <ski> > let foo f (f -> x) = x in foo (^3) 2
10:58:18 <lambdabot>   8
10:58:20 <benmachine> but I suppose were it otherwise it would be quite easy to introduce loops
10:58:29 <zygoloid> > let (gg -> x) = 3; gg = (+2) in x
10:58:30 <lambdabot>   Not in scope: `gg'
10:58:36 <int80_h> not sure what to do with this let statement
10:58:44 <ski> benmachine : one could easily introduce some non-cyclicness check ..
10:58:52 <benmachine> ski: mm, go on then :P
10:59:12 <ski> > let gg = (+2) in let (gg -> x) = 3 in x  -- hm
10:59:13 <lambdabot>   5
10:59:27 <Twey> ski: Yeah, but that's just obvious.
10:59:32 <benmachine> int80_h: moving numbered to the top means putting it somewhere else entirely, defining it as a separate function
10:59:42 <int80_h> I moved the definition of numbered to what I think is the top level, but am getting a parse error "on input '='"
10:59:45 <zygoloid> int80_h: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27952#a27954
10:59:50 <ski> benmachine,zygoloid : i'm surprised `let (g -> x) = 3; g = (+ 2) in x' doesn't work
10:59:58 <int80_h> ooooh
11:00:10 <Twey> > let ((+ 2) -> x) = 3 in x
11:00:11 <lambdabot>   5
11:00:18 <benmachine> ski: how about let (f -> g) = 0; (g -> f) = 0 in g? :P
11:00:27 <benmachine> but I guess that's your acyclic check
11:00:31 <Twey> Hm
11:00:37 <ski> since, imo, it ought to desugar to `let x = g 3; g = (+ 2) in x' ..
11:00:39 <zygoloid> int80_h: incidentally, foo >>= return . bar = bar `liftM` foo
11:00:53 <zygoloid> and in almost all cases you can use `fmap` instead of `liftM` there
11:00:53 <tg_> I was asked the question (by a non-funcproer) "what in Haskell is the closest analogue of an OOP class"?
11:01:04 <tg_> Other than asking him to un-ask the question, what should I say?
11:01:05 <benmachine> ski: mm, yes I suppose so
11:01:16 <ski> benmachine : hm, i was thinking for an acyclic check wrt multiple argument-matching, only
11:01:19 <Twey> tg_: An OO class.
11:01:37 <Tomsik_> Records with function fields, I guess?
11:01:38 <Twey> tg_: It's perfectly possible to build OO on top of Haskell.  We just choose not to.
11:01:40 <benmachine> tg_: I think a record containing functions tends to work ok
11:01:43 <zygoloid> tg_: well, if he's looking for something supporting inheritance i'd say an existential
11:01:46 <ski> benmachine : .. but maybe it'd be more orthogonal to do it in `let (f -> g) = 0; (g -> f) = 0 in g' as well (or not do it in either) ?
11:02:07 <tg_> Twey: ok. I think that's a different direction than he's asking, but I assumed as such.
11:02:08 <zygoloid> tg_: but different OO features correspond to different haskell features so it's hard to give a one-size-fits-all answer
11:02:20 <tg_> ben: that's a pragmatists' response :)
11:02:22 <tg_> which I like
11:02:39 <tg_> zygoloid: yes.
11:02:57 <Tomsik_> though it's kinda like C structs with function fields
11:03:08 <zygoloid> "existential with typeclass constraint" is a pretty faithful translation of "interface", for instance
11:03:14 <Tomsik_> an aberration
11:03:19 <tg_> I found this: http://stackoverflow.com/questions/2685626/explain-type-classes-in-haskell which compares two features of OOP and haskell type-classes
11:03:23 <mauke> tg_: http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf
11:03:40 <Tomsik_> Who the hell believes in OOP anyway.
11:03:55 <zygoloid> Tomsik_: every time you say that a Smalltalk programmer drops dead
11:04:14 <benmachine> tg_: I think it's a bad idea to read too much into the keyword "class" being in both java and haskell
11:04:28 <benmachine> it doesn't necessarily mean the associated concepts are usefully linked :)
11:04:31 <Tomsik_> didn't smalltalk have problems like 2 + 2 * 2
11:05:06 <ski> benmachine,zygoloid : .. so, i guess `let (g -> x) = 3; g = (+ 2) in x' not working as expected could be a further indication that `(foo -> f) = ...' working at all might be an unexpected side-effect of making view-patterns work for argument-matching
11:05:09 <dafis> Tomsik_: interpreting that as (2+2)*2?
11:05:09 <Tomsik_> And honestly, I've never met a person who actually uses smalltalk.
11:05:13 <Tomsik_> dafis: yeah
11:05:22 <dafis> Tomsik_: ooooh
11:05:26 <benmachine> ski: yeah, that sounds reasonable
11:05:39 <ski> Tomsik_ : they could have defined their syntax to make that use precedences .. they chose not to (i'm not sure why)
11:05:51 <mauke> regularity
11:06:23 <benmachine> I'm not entirely sure operator precedences solve more problems than they cause
11:06:35 <benmachine> or at least, complex systems of them
11:06:53 <jessta> tg_: perhaps the person is just looking for a tuple but coming from a language where the only similar thing is a class
11:06:55 <Tomsik_> well, yeah, I can see the train of thought in which "+" can mean anything
11:07:00 <Tomsik_> that doesn't even have to be associative
11:07:45 <zygoloid> > let ((0:) -> xs) = xs in xs
11:07:46 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
11:07:58 <Tomsik_> But use of conventions solves it I guess
11:07:59 <ski> well, when it is associative, then `a + b + c' ought to work (as well as both of `(a + b +)' and `(+ b + c)')
11:08:29 <ski> (the relative precedences of different operators is a different issue)
11:08:32 <benmachine> > let repeat x (repeat x -> xs) = x:xs in repeat 0 repeat
11:08:33 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
11:08:33 <Tomsik_> what's that let (f -> g) = h in i syntax?
11:08:41 <benmachine> Tomsik_: view patterns
11:08:50 <benmachine> oh wait
11:08:59 <benmachine> > let repeat x@(repeat -> xs) = x:xs in repeat 0
11:09:00 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
11:09:17 <zygoloid> > let rep x@(rep x -> xs) = x:xs in repeat 0
11:09:18 <lambdabot>   Couldn't match expected type `a -> [a]' against inferred type `[a]'
11:09:27 <zygoloid> not so fast Mr Machine!
11:09:40 <ski> > let map _ [] = []; map f ((f -> y) : (map f -> ys)) = y : ys in map (^2) [0..9]
11:09:41 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
11:09:52 <tg_> jessta: I don't think he was asking at the implementation level
11:10:11 <zygoloid> ski: i think that's using Prelude.map in the middle.
11:10:36 <ski> > let myMap _ [] = []; myMap f ((f -> y) : (myMap f -> ys)) = y : ys in map (^2) [0..9]  -- satisfied ?
11:10:37 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
11:10:45 <zygoloid> well, almost ;-)
11:10:47 <ski> > let map _ [] = []; g@(map f) ((f -> y) : (g -> ys)) = y : ys in map (^2) [0..9]  -- doesn't work :(
11:10:48 <lambdabot>   <no location info>: Parse error in pattern
11:11:04 <aristid> is that a GHC extension?
11:11:09 <zygoloid> yeah. ViewPattersn.
11:11:23 <zygoloid> > let myMap _ [] = []; myMap f ((f -> y) : (myMap f -> ys)) = y : ys in myMap (^2) [0..9]
11:11:24 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
11:11:30 <zygoloid> /now/ i'm satisfied ;-)
11:11:33 <aristid> i don't quite see the appeal
11:11:49 <ski> heh, changing that last one might be a good idea too, yes :P
11:12:18 * benmachine wonders about fixity of ->
11:12:42 <zygoloid> let mapM f ((f ->> x):(mapM f ->> xs)) = return (x:xs)
11:12:48 <zygoloid> ^^ MonadicViewPatterns anyone? ;-)
11:13:06 <benmachine> > let myMap _ [] = []; myMap f (f -> y : myMap f -> ys) = y:ys in myMap (const "lol") [0 .. 9]
11:13:07 <lambdabot>   <no location info>: parse error on input `->'
11:13:11 <benmachine> hmm
11:13:22 <benmachine> > let myMap _ [] = []; myMap f ((f -> y) : myMap f -> ys) = y:ys in myMap (const "lol") [0 .. 9]
11:13:23 <lambdabot>   Pattern syntax in expression context: f -> y
11:13:32 <zygoloid> benmachine: need moar parens
11:13:42 <benmachine> zygoloid: that is what I was attempting to establish
11:14:11 <zygoloid> i'm not sure they got the precedence of -> in view patterns right
11:14:21 <ski> aristid : `foo :: Seq a -> ..a..; foo (viewL -> a :< as) = ..a..as..'
11:14:48 <Twey> map f r@((f -> y) : (map f -> ys)) = r -- I feel this should work, or that there should be some way of writing something similar
11:14:53 <ski> @type Data.Sequence.viewl
11:14:54 <lambdabot> forall a. Seq.Seq a -> Seq.ViewL a
11:14:54 <ski> @type (Data.Sequence.:<)
11:14:55 <lambdabot> forall a. a -> Seq.Seq a -> Seq.ViewL a
11:15:13 <ski> Twey : that's not semantically right
11:15:33 <zygoloid> > let fap f ((f -> x) : (fap f -> xs)) = x:xs in fap (+1) [1..]
11:15:34 <Twey> Yeah, I know, because @ binds before the pattern match
11:15:34 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
11:15:44 <Tomsik_> > let fac ((==0) -> true) = 1; fac n = n * (fac $ n-1) in fac 5
11:15:45 <lambdabot>   1
11:15:47 <Twey> But I feel there should be something that can take the two results and join them into one
11:16:11 <aristid> ski: these view patterns make the code harder to read (for me), and i don't see what they improve
11:16:31 <zygoloid> > let fap [] = []; fap f r@((f -> x) : (fap f -> xs)) = r ++ (x:xs) in fap (+1) [1..5]
11:16:31 <lambdabot>   Equations for `fap' have different numbers of arguments
11:16:31 <lambdabot>    <interactive>:1:...
11:16:32 <ski> Twey : more like `map f (unCons >>> (f *** map f) >>> uncutty (:) -> r) = r'
11:16:34 <kmc> is the noob tsunami over?
11:16:37 <zygoloid> > let fap _ [] = []; fap f r@((f -> x) : (fap f -> xs)) = r ++ (x:xs) in fap (+1) [1..5]
11:16:38 <lambdabot>   [1,2,3,4,5,2,2,3,4,5,3,3,4,5,4,4,5,5,5,6]
11:16:46 <Twey> Ooh, could be
11:16:53 <Twey> kmc: Noob tsunami?
11:17:01 <Tomsik_> view patters seem confusing to me, overloading (->) even further
11:17:21 <Twey> Oh
11:17:33 <Twey> I see
11:18:01 <ski> aristid : in the `Seq' case, they make it so that you can pattern-match on the first with rest elements of a sequence, or the last with rest elements, on the left-hand-side of `=' (i.e. without using an extra `case' or new local function which matches)
11:18:04 <kmc> Twey, tryhaskell.org made it to the Reddit front page yesterday, with a link to join #haskell in one click
11:18:13 <Twey> Yeah, I saw that
11:18:30 <zygoloid> > case id of (\id -> id -> id) -> id "->"
11:18:30 <ski> aristid : the above `map',&c. examples are just us trying to stretch the uses of view patterns :)
11:18:31 <lambdabot>   "->"
11:18:36 <zygoloid> Tomsik_: ^^ how can that not be clear?
11:18:38 <zygoloid> ;-)
11:19:16 <benmachine> @quote view.pattern
11:19:17 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
11:19:18 <Tomsik_> at first I thought you're getting into function's body
11:19:27 <Tomsik_> when I saw the syntax
11:19:41 <Tomsik_> which was a major "wtf" 
11:20:00 <ski> zygoloid : actually, `->>' is only for `Maybe', afair ..
11:20:17 <Twey> > let map _ [] = []; map f ((head &&& tail) >>> (f *** map f) >>> uncurry (:) -> r) = r in map (+ 2) [1 .. 5]
11:20:18 <lambdabot>   [3,4,5,6,7]
11:20:18 <ski> (but maybe you were suggesting monadic ones .. )
11:20:21 <Twey> \o/
11:20:34 <Twey> Who needs function bodies!  :√æ
11:21:15 <Tomsik_> :t (->>)
11:21:16 <lambdabot> Not in scope: `->>'
11:21:23 <Twey> Oh, the fixity is nice too
11:21:24 <aristid> ski: i don't understand the view example, is the problem
11:21:30 <cydergoth> ok - nuther question: I've got two 'data' structures one containing the other. Currently the outer one is a State Monad and I explicitly pass the inner one to the functions which update it (small fns, many many updates). Should I make the inner one also a State Monad?
11:21:36 <Twey> > let map _ [] = []; map f (head &&& tail >>> f *** map f >>> uncurry (:) -> r) = r in map (+ 2) [1 .. 5]
11:21:37 <lambdabot>   [3,4,5,6,7]
11:21:42 * ski is reminded of the title "The View from the Left"
11:21:55 <cydergoth> this is what an update fn looks like currently: gcodeinsn s0 G "01" = s0 { lerpMode = LERPFeed }
11:22:02 <ski> (paper by Conor McBride and James MacKinna)
11:22:05 <cydergoth> Where s0 is the inner state
11:22:21 <Sizur> what's The Standard for web frameworks today?  Is is happstack still?  Do we have anything production ready yet?
11:22:51 * Sizur hides begind Haskell Consumer banner.
11:23:02 <c_wraith> depends on your definition of production-ready.  Snap is being used in a couple production sites.
11:23:15 <c_wraith> And I'm deep in a dev project using snap for a soon-to-be-production site.
11:23:17 <dolio> Oh, is ->> the syntax for Maybe patterns?
11:23:25 <dolio> I thought they just left it out, because => didn't work.
11:23:49 * ski is not sure
11:23:53 <ski> (`=>' ?)
11:24:06 <Sizur> c_wraith: cool, actually a working web home for a haskell web framework. :)
11:24:53 <cydergoth> Sizur: slightly off topic but I have a sample of a TCP (not HTTP) echo server using OpenSSL if you want it
11:24:53 <dolio> In the original proposal, 'f (g => x) ...' was the same as 'f (g -> Just x) ...'
11:24:57 <c_wraith> Sizur: full disclosure, I'm one of the contributors to Snap, and am using an unreleased version. :)
11:25:04 <zygoloid> > case 6 of (\n -> case n of (\n -> n + 1 -> n + 3) -> n * 9 -> n + 1) -> n + 7
11:25:05 <lambdabot>   42
11:25:24 <roconnor> dolio: where does your Unfold Monad come from? I'm trying to convince myself it is a monad.
11:25:30 <ski> > let ((`lookup` [(0,"0")]) -> Just x) = 0 in x
11:25:31 <lambdabot>   "0"
11:25:31 <ski> > let ((`lookup` [(0,"0")]) ->> x) = 0 in x
11:25:32 <lambdabot>   <no location info>: Parse error in pattern
11:25:43 <ski> dolio : ok
11:26:06 <ski> dolio : istr seeing `->>' somewhere .. maybe it was just a suggestion in a thread, though
11:26:30 <zygoloid> ski, dolio ->> was something i made up earlier
11:26:44 <zygoloid> 18:11 < zygoloid> let mapM f ((f ->> x):(mapM f ->> xs)) = return (x:xs)
11:26:57 <ski> zygoloid : yes, but i vaguely think i may have seen it somewhere else, too :)
11:26:57 <dolio> roconnor: Unfold is a certain sort of tree. return creates a tree with one leaf. Bind pastes new trees in at all the leaves.
11:26:58 <zygoloid> for a hypothetical -XMonadicViewPatterns
11:27:07 <zygoloid> ski: arrow notation maybe
11:27:19 <zygoloid> iirc there's a -<< or something there
11:27:22 <ski> dolio : sounds related to the expression monads ..
11:27:33 <roconnor> dolio: did you make up your monad on the spot?
11:27:45 <ski> (the arrow notation is another thing .. i don't think i'm confusing it with that)
11:28:13 <Sizur> c_wraith: is snap web home written in snap?
11:28:14 <dolio> roconnor: It seemed like I'd need it to do the right kind of mapping. Functor wasn't enough, because the function in question required IO.
11:28:14 <zygoloid> ski: was this as syntax or as an operator?
11:28:21 <ski> syntax
11:28:23 * BMeph reaches for his bright yellow slicker, to better withstand the noob monsoon...
11:28:29 <c_wraith> Sizur, yes, and the source is available.
11:28:50 <dolio> So I couldn't do 'fmap fileSize u' I had to do 'u >>= lift . fileSize'.
11:28:53 <c_wraith> It's in the downloads section
11:29:14 <dolio> Although I could instead make a custom map that absorbed the IO.
11:29:33 <dolio> I wrote another version of find that uses the monad instance a little more.
11:29:38 <zygoloid> ski: looks like the only similar thing implemented in GHC is -<</>>- for arrows.
11:29:41 <dolio> Paste on the page now.
11:29:53 <dolio> Pasted, even.
11:29:55 <BMeph> '>>-' is a LogicT thing.
11:29:57 <cydergoth> BMeph: seening as the Haskell wiki says this is the 'friendly channel for learning Haskell' that seems a little off
11:30:03 <ski> zygoloid : still, i may have seen it only in a thread which invented it on the spot .. or i may be confusing it with `=>', (even though if you asked me i'd say i think i've seen `->>' and not only `=>')
11:30:33 <zygoloid> it's a shame google can't cope with searches for things like that
11:30:43 <BMeph> cydergoth: Which "that" are you meaning? :)
11:31:01 <kmc> yeah, i don't mean to imply that a noob tsunami is a bad thing
11:31:09 <cydergoth> BMeph: "reaches for his bright yellow slicker, to better withstand the noob monsoon..."
11:31:35 <kmc> however a lot of them yesterday were either
11:31:37 <kmc> 1) pure trolls
11:31:41 <ski> cydergoth : i'm not sure, re your `State' question .. i'd have to see code to be able to say something relevant
11:31:49 <dolio> roconnor: I agree that the hylomorphism solution was nicer, though. I was trying to outline how I thought it'd work with iteratees, despite the fact that there's probably no interface for traversing the directory tree with them currently.
11:31:50 <BMeph> 2) ...impure trolls? ;)
11:31:51 <kmc> 2) not interested in learning, but wanted us to convince them otherwise
11:31:53 <roconnor> dolio: Unfold vaguely resembles a left Kan extension, except the function is in the wrong place.
11:32:12 <kmc> "haskell seems no better than C#, please provide an exhaustive list of why it is better"
11:32:23 <dolio> Because so far they only support reading files and stuff, as far as I know.
11:32:26 <cydergoth> Ski: I have a data Simulation { ..... } containing a data Engine { .... }
11:32:43 <cydergoth> Ski: Simulation is very big, engine is small(ish) and gets lots of updates
11:32:54 <ski> cydergoth : paste it ?
11:33:03 <cydergoth> ski: An update looks like : gcodeinsn s0 G "01" = s0 { lerpMode = LERPFeed }
11:33:04 <ski> (or selected parts of it)
11:33:11 <dolio> I'm not sure my solution is really an iteratee, though. That package makes my brain go numb.
11:33:12 <cydergoth> Where s0 is the Engine state
11:33:32 <cydergoth> Ski: So I'm not sure I would gain much from making this a Monad?
11:33:46 <conal> I'm taking a poll on the origins of the meme "everything is a function" (in haskell or pure functional programming).  i'd appreciate input.  especially from people who have this belief or used to have it.
11:33:48 <roconnor> cydergoth: check out Data.Accessor
11:33:53 <zygoloid> dolio: data Files = File (IO (String, Files)) | NoMoreFiles ?
11:34:02 <roconnor> cydergoth: it has specific functions for doing this sort of thing
11:34:17 <ski> cydergoth : what more does the engine contain, than updates like `gcodeinsn' ?
11:34:21 <roconnor> cydergoth: http://hackage.haskell.org/packages/archive/data-accessor/0.2.1.4/doc/html/Data-Accessor-MonadState.html
11:34:30 <zygoloid> dolio: that's what sprung to my mind first as a composable solution
11:34:37 <cydergoth> roconnor: I looked at that but they seem to be just syntactic sugar for the record { field = } syntax
11:34:43 <kmc> conal, that's a funny one.  in Haskell, static types give a pretty sharp objective determination of what is a function and what isn't
11:34:51 <dolio> roconnor: Also, in a way, I think my solution is similar to the hylo solution, just packaged up into types and stuff. Unfold packages up the coalgebra part, and fold packages up the algebra part.
11:34:58 <roconnor> cydergoth: in fact http://hackage.haskell.org/packages/archive/data-accessor/0.2.1.4/doc/html/Data-Accessor.html is even more clear
11:35:01 <cydergoth> ski: Just some small state 
11:35:06 <BMeph> conal: Church did it! ;)
11:35:19 <dolio> And then the monad instance lets you fiddle with what exactly the coalgebra does.
11:35:19 <conal> To be extra clear, I'm not asking for opinions/arguments for/agaist.  More for insight about such a belief forms, spreads and solidifies.
11:35:22 <kmc> conal, perhaps it comes from people thinking that OOP means everything is an object? that's not true either, for most languages used for OOP
11:35:23 <ski> cydergoth : well, it's hard to tell, without seeing code
11:35:38 <cydergoth> roconnor: So if I use the data accessor package should I use the State Monad with it?
11:35:38 <dolio> roconnor: And annihilate is hylo, of course.
11:35:48 <conal> and i'd especially appreciate comments on that reddit thread.
11:35:56 <kmc> which reddit thread?
11:36:04 <conal> kmc: that's been one of my guesses as well.
11:36:08 <ski> cydergoth : also, the point of functional references things like `data-accessor' is to have *composable* accessor things (getter,setter,modify)
11:36:09 <zygoloid> conal: lambda calculus, i guess. or the notion that 'X programming means everything is a X' for X in [object(-oriented), function(al)]
11:36:26 <cydergoth> ski: data EngineState = EngineState {
11:36:28 <cydergoth>      refCurrent :: Point3 Double, -- Current location of machine tool reference point in absolute space .......
11:36:34 <roconnor> dolio: I get the simularities, but your Unfold monad doesn't exist in the hylo solution, granted Unfold's monad is only used for writing sizes in terms of find.
11:36:38 <ski> (cydergoth : in an ideal world, record types would give you accessors automatically ..)
11:36:45 <conal> zygoloid: cool.  been one of my hypotheses as well.
11:36:47 <cydergoth> ski: gcodeinsn s0 X delta = case movement s0 of   
11:36:49 <cydergoth>                           UnknownMovementMode -> error "Movement command before movement mode selected"
11:36:52 <cydergoth>                           Relative -> s0 { cmdEnd = Point3 (x,y,z) }    
11:36:55 <cydergoth>                                        where  x = (xcoord (cmdEnd s0)) + (toNative s0 (read delta))
11:36:57 <cydergoth>                                               y = ycoord (cmdEnd s0)
11:36:59 <cydergoth>                                               z = zcoord (cmdEnd s0)
11:36:59 <jmcarthur> i'm with kmc on this
11:37:01 <cydergoth>                           Absolute -> s0 { cmdEnd = Point3 (x,y,z) }  
11:37:03 <cydergoth>                                        where x = toNative s0 (read delta)
11:37:04 <Twey> Um
11:37:05 <cydergoth>                                              y = ycoord (cmdEnd s0) 
11:37:07 * ski sighs
11:37:07 <cydergoth>                                              z = zcoord (cmdEnd s0)
11:37:10 <Twey> cydergoth: http://www.hpaste.org/
11:37:19 <kmc> cydergoth, please don't paste more than a few lines of text into the channel
11:37:19 <roconnor> cydergoth: sure, Data.Accessor and the State monad work great together
11:37:43 <ski> @where paste
11:37:43 <lambdabot> http://hpaste.org/new
11:37:47 <roconnor> cydergoth: liftT :: Monad m => T r s -> StateT s m a -> StateT r a
11:37:50 <conal> BMeph: the church angle has conceptual substance.  (though we're not doing what church did.)  i like it.
11:38:05 <cydergoth> roconnor: what do I get from using the State monad when I have such trivial update functions?
11:38:20 <cydergoth> @rconnor over just using records?
11:38:20 <lambdabot> Unknown command, try @list
11:38:32 <sshc> I am opposed to the opposition of channel pasting.  People really need non-huge fonts :)
11:38:37 <cydergoth> roconnor: just using records?
11:38:46 <jmcarthur> > 5 "foo" 4.5 ()
11:38:47 <lambdabot>   5
11:38:51 <benmachine> sshc: I like my eyes to be working thx
11:38:53 <jmcarthur> conal: ^^ ;)
11:39:02 <kmc> sshc, it's hard to read code when it's scrolling away
11:39:12 <roconnor> cydergoth: you can easily make any record field into an accessor
11:39:13 <zygoloid> ironically, in haskell "everything is an object" is closer to being true than it is in, say, Java or C#
11:39:13 <dolio> roconnor: I also wrote a version of find which uses the monad instance and a 'branch' combinator to write down find directly, recursively.
11:39:19 <zygoloid> (in that the standard has no unboxed types)
11:39:21 <jmcarthur> i understand that is not what was meant when you said "and similarly with that returned 5, and so on?" on reddit
11:39:25 <roconnor> cydergoth: there is some template haskell to do that if you have a lot to write
11:39:34 <Twey> sshc: My font isn't huge, but it disrupts conversation.
11:39:41 <jmcarthur> because the 5 there is actually being inferred as a 3-ary function
11:39:46 <Twey> zygoloid: How so?
11:39:52 <Twey> Oh
11:39:54 <Twey> Mmm
11:40:03 <Twey> Boxing isn't necessarily the same as being an object
11:40:06 <roconnor> did dolio disappear?
11:40:15 <conal> jmcarthur: right.  cute though :)
11:40:20 <Twey> For me, object-hood requires that everything be a map, preferably reflectable
11:40:26 <cydergoth> roconnor: in this case it seems like there are few advantages to State syntactically, the existing update methods are very small
11:40:34 <benmachine> reflection is for lamers, true fact
11:40:40 <zygoloid> For me, object-hood requires that everything have tassles attached to the handlebars.
11:41:00 <Twey> benmachine: And plugins?  ;)
11:41:11 <conal> jmcarthur: i really do like the function overloading of Num .  but then i'd make my example more specific, to "5 :: Integer" or to True :: Bool.
11:41:12 <cydergoth> roconnor: so would I get any other advantages from State other than hiding the first argument on every update method and having the methods deal with get/put instead? Would it be slower?
11:41:17 <zygoloid> it's an arbitrary distinction. but i think that being able to uniformly operate on all 'objects' is a start at least
11:41:20 <benmachine> Twey: plugins?
11:41:25 <jmcarthur> yeah
11:41:26 <roconnor> cydergoth: you don't have to use data accessor with State, but it is a convienent way to deal with some kinds of OO style programing IMHO.
11:42:13 <cydergoth> roconnor: Sorry, I'm not being clear - this is a performance question - is the extra syntactical sugar of State going to impact the performance of my update methods?
11:42:19 <roconnor> cydergoth: using the state monad makes sure that your state updates are linear and you don't accidently use the wrong state to update.
11:42:24 <Twey> benmachine: Extensible systems are very difficult to do without reflection.
11:42:39 <roconnor> cydergoth: ... well, it's complicated.
11:42:52 <benmachine> Twey: that surprises me, I don't have the experience to refute it though
11:42:57 <roconnor> cydergoth: Worry about performance later when you know where the bottlenecks are
11:43:03 <roconnor> cydergoth: focus on clarity for now.
11:43:10 <jmcarthur> conal: there's also the viewpoint that all values could be represented as a church encoding, but i don't know if that actually works when you start considering things like GADTs and stuff
11:43:21 <cydergoth> roconnor: ok so it provides isolation between the updates and a linear (time) sequence of states is guarenteed?
11:43:35 <kmc> jmcarthur, after type checking and type erasure, sure
11:43:42 <djahandarie> http://www.ccs.neu.edu/home/tov/pubs/alms/ neat
11:43:46 * hackagebot uu-parsinglib 2.4.1 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.4.1 (DoaitseSwierstra)
11:43:48 <jmcarthur> kmc: yeah? i just hadn't thought it through
11:43:54 <conal> jmcarthur: and one might want to distinguish "could be represented as a function" from "is a function"
11:43:59 <roconnor> cydergoth: when you try to chain updates together by hand it is a bit too easy to update from the wrong state if you have several of them floating around in scope.
11:44:07 <kmc> jmcarthur, well you can type-erase a GADT to an ordinary ADT, i think
11:44:14 <jmcarthur> conal: is there a difference?
11:44:20 <cydergoth> roconnor: I know performance is going to be a consideration here, this record gets updates 100,000 times a second for every second of the simulation
11:44:21 <roconnor> dolio: you are back
11:44:26 <dolio> I am.
11:44:33 <kmc> jmcarthur, and code which was type-correct for the original GADT won't go wrong on the ADT
11:44:53 <zygoloid> conal: there's the categorical perspective in which values are arrows from an initial object to some type
11:45:07 <roconnor> cydergoth: worry about it later.  You can always drop in a Codenisty transformation to speed things up if needed.
11:45:11 <cydergoth> @roconnor but if sounds as if the Monad route is the right thing to do anyway from the point of view of state management
11:45:11 <lambdabot> Unknown command, try @list
11:45:30 <cydergoth> roconnor: but if sounds as if the Monad route is the right thing to do anyway from the point of view of state management
11:45:45 <roconnor> cydergoth: in my opinion yes.
11:45:52 <conal> zygoloid: yep.  a first-order perspective.  could be part of the belief formation.  or maybe more a way to hold onto the belief (ie rationalization rather than reason).
11:45:57 <cydergoth> roconnor: So is there every a case to use a record without a State ?
11:46:04 <cydergoth> ^ever
11:46:31 <roconnor> cydergoth: if the records are not being updated (often) or if they are being duplicated.
11:46:46 <cydergoth> roconnor: Thx
11:47:01 <benmachine> if you're just transforming a state repeatedly, maybe you could just compose a chain of functions?
11:47:12 <conal> for instance, one could just as well embed all values into lists or maybes.  but i only hear the claim for the function embedding, in haskell-land.  so i suspect it's a rationalization, not a reason.
11:47:13 <EvanR-work> is relatively rare to update records, relative to how often you might use them
11:47:19 <kmc> records aren't necessarily about state; they may just be a convenient way to access the fields of an algebraic data value
11:47:54 <roconnor> dolio: is unfold n a isomorphic to anything more obviously a monad?
11:47:55 <EvanR-work> you can easily compute an updated record without using state
11:47:59 <jmcarthur> conal: http://pll.cpsc.ucalgary.ca/charity1/www/home.html
11:48:01 <zygoloid> conal: yes, that seems a reasonable suspicion.
11:48:38 <zygoloid> conal: (especially since there /are/ languages where everything is a list, or where everything is a string)
11:49:01 <dolio> roconnor: data Tree n a = Node n (IO [Tree n a]) | Leaf a
11:49:01 <roconnor> dolio: or maybe I should be asking how you came up with Unfold
11:49:05 <dolio> Something like that.
11:49:10 <Trevion> zygoloid: Tcl doesn't count!
11:49:15 <cydergoth> EvanR-work: yes, that's what I'm currently doing, but it sounds like since my record semantically is state that I should make that explicit by wrapping it in a state Monad?
11:49:24 <zygoloid> Trevion: what! it's turing complete! :)
11:49:38 <EvanR-work> cydergoth: only if you want to use imperative style to update it
11:49:46 <jmcarthur> or where everything is a dictionary
11:49:51 <benmachine> lua?
11:49:54 <Trevion> zygoloid: I write all my programs in the C++ template system.
11:50:00 <jmcarthur> i believe lua is commonly characterized that way
11:50:02 <conal> this reason/rationalization distinction gets to the heart of my curiosity in "everything is a function".
11:50:03 <jmcarthur> i was thinking Io
11:50:08 <zygoloid> Trevion: a happy world where everything is a type ;-)
11:50:14 <conal> "Most of our so-called reasoning consists in finding arguments for going on believing as we already do." - James Harvey Robinson
11:50:23 <cydergoth> EvanR-work: so for a tight loop simulation where I have millions of updates, would you recommend that?
11:50:24 <zygoloid> Trevion: umm, apart from the nontype template parameters ;O
11:50:42 <dolio> roconnor: It's the rose tree version of the proper ListT.
11:50:43 <EvanR-work> cydergoth: doesnt have to be that way. no
11:50:48 <dolio> Specialized to IO.
11:51:22 <cydergoth> EvanR-work: even if I need to 'escape' from the simulation after every tick to update a GUI?
11:52:40 <ski> dolio : you saw the change from `annihilate :: Unfold n a -> Fold n a -> IO ()' to `annihilate :: Unfold n a -> Fold n a r -> IO r' (with `data Fold n a r = F (a -> IO r) (n -> [r] -> IO r)') suggested by roconnor ?
11:52:41 <dolio> I suppose Unfold n a might be IO (Tree n a).
11:52:52 <ski> dolio : that `Tree n' looks like a free monad ..
11:53:13 <EvanR-work> cydergoth: IO eh. well for that basic setup you could update an IORef instead
11:53:24 <EvanR-work> just like in C or something
11:53:40 <EvanR-work> of course there are more exotic GUI paradigms you could use in haskell
11:53:55 <cydergoth> EvanR-work: Yeah, the real world is a problem. The GUI will be OpenGL 
11:54:00 <EvanR-work> GUIs can naturally be considered concurrent systems
11:54:37 <roconnor> dolio: something like roseT IO ?
11:54:46 <dolio> ski: I hadn't, but I decided I wasn't going to worry about return types and such, because I didn't need it.
11:54:50 <dolio> roconnor: Yes.
11:55:09 <cydergoth> EvanR-work: So the basic plan is to run the simulation on one thread, expose the 'current state' and then the GUI runs concurrently, grabs a snapshot of the 'current state' and displays it
11:55:16 <roconnor> we need a roseT on hackage
11:55:20 <EvanR-work> alright
11:55:21 * benmachine remembers "the real world is a problem"
11:55:24 <EvanR-work> wait no
11:55:57 <EvanR-work> cydergoth: a different thread for each gui element, and for each event listener
11:56:01 <sageh^> If I want read a bunch of Doubles from a string str, given with n doubles on a line, something like  map ((map read) . words) (lines str) seems to work, but needs a type specifier. How would I do that?
11:56:03 <EvanR-work> for example
11:56:09 <dolio> ski: I'd probably use 'Fold n a c = forall r. F (a -> IO r) (n -> [r] -> IO r) (r -> IO c)' since that seems to be the 'folds-as-functors/monads' style. You fix up at the end.
11:56:29 <cydergoth> EvanR-work: Yes, of course, but that's all behind the GUI facade. The interface to the simulation engine is largely one way - it generates a state, gui displays it
11:56:29 <conal> the OpenGL-ness of a GUI needn't interfere with taking a denotative/functional (non-IO) approach to programming a GUI.
11:56:36 <dolio> If you make the r a parameter, it occurs both positively and negatively.
11:56:45 <Trevion> Anyone have much experience with OpenGl?
11:56:50 <EvanR-work> cydergoth: in that case, simulate :: State -> State ?
11:56:57 <jmcarthur> some
11:57:02 <EvanR-work> showSimulation :: State -> Pixmap ?
11:57:05 <ski> dolio : it already does
11:57:18 <roconnor> dolio: in squinting-at-fusion http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/ Folding uses rank2types rather than existential types
11:57:20 <ski> (inside `Fold')
11:57:22 <conal> any more than the desire to eventually print a number interferes with a denotative/functional approach to programming with numbers.
11:57:30 <dolio> Yes, but it's not a parameter, so it can't be a functor in that parameter anyway.
11:57:31 <cydergoth> EvanR-work: already have that, the question was my data Simulation contains a data 'Engine' which gets lots of updates, and should I make both State or only the outer one
11:58:07 <EvanR-work> cydergoth: updates?
11:58:22 <EvanR-work> does the simulation run on its own or does it take arbitrarily scheduled inputs
11:58:24 <ski> dolio : re the `.. (r -> IO c)', i'd have to think about that, to determine whether it makes sense :)
11:58:46 <cydergoth> EvanR-work : An updated looks like: gcodeinsn s0 G "01" = s0 { lerpMode = LERPFeed }
11:58:47 <ski> (hm ..)
11:58:56 <cydergoth> EvanR-work where s0 is the record
11:59:03 <dolio> ski, roconnor: http://squing.blogspot.com/2008/11/beautiful-folding.html
11:59:14 <cydergoth> EvanR-work: No, once configured the simulation is completely stand-alone
11:59:18 <EvanR-work> ah
11:59:22 <EvanR-work> then State -> State
11:59:35 <ski> dolio : hm .. i suppose you're doing a `CoYoneda' thing, sortof ..
11:59:56 <ski> ty, will check
12:00:00 <cydergoth> EvanR-work: Yes, but do I need the State on the outer object *and* the inner one, or just on the outer one
12:00:54 <cydergoth> EvanR-work: the outer one holds the whole simulated world state, the innerone holds the state of the cutting head within the simulated world
12:01:27 <cydergoth> EvanR-work: Updates occur to both but the inner one gets updated much more frequently
12:01:48 <ski> (is the author of that a regular of #haskell ?)
12:01:59 <EvanR-work> cydergoth: the whole thing is the state
12:02:03 <dolio> I don't know.
12:02:17 <cydergoth> EvanR-work: So I only need the State monad on the outer one?
12:02:27 <EvanR-work> i didnt say anything about state monad so far
12:02:32 <EvanR-work> thats just a regular function
12:03:13 <cydergoth> EvanR-work: So this is the type of my update functions for the inner record: gcodeinsn :: EngineState -> GCodeCmd -> String -> EngineState
12:03:46 <int80_h> okay guys, I believe Bare Bones Blog is nearly finished. But I'm having this strange runtime error
12:03:49 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27956#a27956
12:03:53 <EvanR-work> the next state depends on things other than the previous state?
12:04:00 <cydergoth> EvanR-work: most GCodeCmds trivially set persistent state flags, but there is one which does a linear interpolation move
12:04:39 <roconnor> ski: how is MonadFree related to Monad?
12:04:42 <cydergoth> EvanR-work: this is for a CNC 3-axis mill simulator. Basically a VM which runs a GCode program to driver the motors which cut the workpiece
12:05:21 <EvanR-work> cydergoth: sounds like this thing is doing more than simulating, its emitting IO commands as it runs
12:05:30 <cydergoth> EvanR-work: so the state is current location of the cutting head, and the persistent flags, and the gcode program 
12:05:36 <cydergoth> EvanR-work: No, it is just a simulation
12:06:15 <EvanR-work> alright, so things should be as simple as State -> State and no monad required
12:06:16 <dafis> int80_h: getDirectoryContents doesn't return the full path
12:06:17 <cydergoth> EvanR-work: The actual driving program is a separate program called Mach3 which generates the bitbanging on the parallel port to actually drive the machine
12:06:17 <roconnor> oh I see
12:06:23 <roconnor> (Bifunctor f Hask Hask Hask, PMonad f) => Monad (Fix f)
12:06:27 <ski> int80_h : i think you need to add the path in front of the filenames gives to `readFile' (or change the current directory)
12:06:32 <dafis> int80_h: so it tries to read in the current directory
12:06:56 <cydergoth> EvanR-work: so I shouldn't use state monad at all?
12:06:58 <EvanR-work> cydergoth: well typically machines require command events rather than snapshots of the state, because they dont have a 'assume this state' command
12:07:07 <ski> roconnor : `Fix' is not `FreeMonad'
12:07:13 <dafis> int80_h: also, you should do a filterM doesFileExist so it doesn't try to read directories
12:07:14 <EvanR-work> you could generate the events from the differences between states
12:07:36 <roconnor> but Fix (PFree f) is
12:07:46 <EvanR-work> cydergoth: yes so far you havent said anything that state would help
12:07:51 * ski is not sure what 'PFree' is
12:08:00 <roconnor> type PFree = PAp Either
12:08:03 <cydergoth> EvanR-work: The simulator will just update the final state of the workpiece, and the gui will just show that state during the run as an animation
12:08:21 <roconnor> PAp p = Biff p Identity
12:08:28 <roconnor> ahhh, this is insane!
12:08:46 <cydergoth> EvanR-work: so I will need to be able to escape from the purely functional world to display the state of the workpiece and the internal state of the VM
12:08:48 <roconnor> newtype Biff p f g a b = Biff { runBiff :: p (f a) (g b) } 
12:08:56 <EvanR-work> cydergoth: no
12:09:16 <EvanR-work> cydergoth: youre now talking about things both above and below the State -> State interface
12:09:30 <EvanR-work> if you have that, then you can use it to display the intermediate states with IO
12:09:35 <EvanR-work> it doesnt have to be built in
12:09:39 <roconnor> so Pfree f = Biff Either Identity f  ?
12:09:45 <ski> roconnor : edwardk, for you :D
12:10:03 <EvanR-work> as for the lower level updates to the state, thats inside of State -> State
12:10:16 <cydergoth> EvanR-work: so how does this work with lazyness? At what point do I force computation to get the inner state out to somewhere I can display it?
12:10:18 <roconnor> so Pfree f a b ~ Either a (f b)
12:10:26 <EvanR-work> cydergoth: IO is strict
12:10:26 <ski> .. yeah, i see
12:10:33 <EvanR-work> so its forced every time you draw a new graphic
12:10:44 <roconnor> I think I have a kind error here
12:11:16 <cydergoth> EvanR-work: so I don't need State monad to define state transitions then since IO monad forces the computation?
12:11:51 <EvanR-work> forcing isnt related to using State or not
12:11:58 <benmachine> :t liftA2
12:11:59 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:12:14 <ski> .. actually, it would be nice if one could have "multiple implementations" of `newtype's .. which of course agreed after a definite number of unwrappings
12:12:31 <aristid> @pl \a b f -> f a b
12:12:31 <lambdabot> flip . flip id
12:12:32 <roconnor> Oh, fix operates on bifunctors
12:12:44 <cydergoth> EvanR-work: Ok, so to pass this to OpenGL, I need to get a list of triangles which are completely defined and pass that to OpenGL. The VM can produce the list of triangles in the purely functional world
12:13:02 <EvanR-work> a separate mechanism can compute triangles from the state
12:13:06 <cydergoth> EvanR-work: But I need to realise them in the OpenGL 'real world' as a block of memory with the right data in
12:13:14 <EvanR-work> State -> [Triangle]
12:13:35 <ski> so that one could have `type PAp p = Biff p Identity' as well as `newtype PAp f g a b = PAp {runPAp :: (f a) (g b)}' in scope at the same time !
12:13:38 <EvanR-work> glRender :: [Triangle] -> IO ()
12:13:40 <roconnor> so Fix (Pfree f) a ~ Either a (f (Either a (f (Either a (f ...
12:13:51 <ski> *node*
12:14:12 <cydergoth> EvanR-work: so I can guarantee that before glRender runs it will fully force computation of the [Triangle]?
12:14:16 <conal> i'm surprised i didn't get any defense here today of "everything is a function".  i've heard that belief several times here on #haskell.  i hope folks aren't intimidated.  in any case, thanks for the help.
12:14:38 <EvanR-work> cydergoth: of course, haskell isnt going to crash on you or something
12:14:45 <ski> conal : could be wrong time of day/week ..
12:14:55 <roconnor> If we set f = /\x -> (n, IO [x])
12:15:00 <cydergoth> EvanR-work: I can already make it crash quite easily with interface to native code ;-)
12:15:10 <EvanR-work> well we havent talked about that
12:15:18 <conal> ski: ah, thx!  maybe i'll ask again in 8 hours or so.
12:15:18 <int80_h> conal : try the mailing list haskell-cafe
12:15:18 <EvanR-work> so far its just haskell
12:15:32 <conal> int80_h: oh, yeah!
12:15:33 <roconnor> then Fix (Pfree f) = Either a (n, IO [Fix (Pfree f)])
12:15:37 <cydergoth> EvanR-work: That I understand quite well - I've wrapped the GTS library in Haskell and I can call it and get sensible results back
12:15:45 <EvanR-work> great
12:16:08 <conal> meanwhile, back to blogging with me.
12:16:19 <cydergoth> EvanR-work: It is just trying to understand this interface between the purely functional world and the rest of the state (GTS library is all IO Monad)
12:16:33 <ski> (roconnor : does the above idea sound reasonable, to you ?)
12:16:47 <roconnor> ski: what idea?
12:16:48 <conal> (meaning -- i'm back to blogging.  not a demand that you all blog with me.)
12:16:49 <EvanR-work> cydergoth: GTS does what?
12:16:52 <cydergoth> EvanR-work: So we've discussed why I don't need State Monad, can we discuss where I *should* use it and why?
12:17:01 <ski> roconnor : "multiple implementations" of `newtype's
12:17:10 <cydergoth> EvanR-work: GTS does Constructive Solid Geometry and triangle geometry processing
12:17:18 <ClaudiusMaximus> conal: i made an untyped lambda calculus interpreter once, and church-encoded everything, so it was functions all the way down, but to actually get output you have to know the "shape" of the functions you expect as results - so it's not as convenient as having data in addition to functions
12:17:22 <EvanR-work> it uses IO for IO arrays or something?
12:17:32 <roconnor> ski: I don't think I understand it
12:17:35 <EvanR-work> processing isnt necessarily IO
12:17:55 <cydergoth> EvanR-work: Mostly it is opaque C data types, but it does have some read/write file functions too
12:17:56 <roconnor>  /\x -> (n, IO [x])  is clearly a functor
12:18:05 <conal> ClaudiusMaximus: ah, interesting.  
12:18:12 <jmcarthur> ClaudiusMaximus: it might also be interesting to note that you treated the resulting function as data rather than as a function
12:18:12 <EvanR-work> cydergoth: ah. foreign code, thats why
12:18:32 <cydergoth> EvanR-work: Partly what I intend to do it slowly convert bits of it to Haskell, particularly as I will need a lot of parallel processing on the geometry
12:18:39 <ski> roconnor : i mean so that `PAp' would both expand out to ther `newtype' `Biff', *and* be a `newtype' in its own right (where the two definitions agree, after a definite number of `newtype'-unwrappings)
12:18:40 <jmcarthur> by inspecting its representation
12:18:40 <roconnor> so Free ( /\x -> (n, IO [x])) is a monad
12:18:45 <ClaudiusMaximus> jmcarthur: yes, exactly
12:18:47 <roconnor> but is it the same as dolio's monad?
12:18:51 <EvanR-work> cydergoth: use State monad to write a pure function which uses imperative style to update a internal state
12:19:08 <dolio> Yes.
12:19:12 <cydergoth> EvanR-work: To simulate the workpiece, I need to take an object in 3D space described by triangles and successively remove bits of it using Constructive Solid Geometry (CSG) to show the tool cutting away from it
12:19:13 <ski> roconnor : it's the same as the `Tree' one, yes
12:19:32 <roconnor> ski, dolio: how do you know this?
12:19:47 <cydergoth> EvanR-work: The Gcode VM interprets the g-code program to control the position of the cutting tool
12:20:05 <ski>   data FreeMonad m a = Return a | JoinLift (m (FreeMonad m a))
12:20:06 <roconnor> ski, dolio: what is a free monad?
12:20:11 <ski> roconnor : ^
12:20:12 <int80_h> can one easily append to the front of a string? or do I need to reverse, append, and reverse again?
12:20:13 <EvanR-work> cydergoth: k so State -> [Triangles], [Triangles] -> GTSData, GTSData -> IO GTSResults, glRender GTSResults -> IO ()
12:20:14 <roconnor> :)
12:20:24 <roconnor> ski: what are the requirements of m ?
12:20:26 <EvanR-work> cydergoth: foreign libs which require IO make things tricky
12:20:32 <EvanR-work> just gotta be careful
12:20:40 <dolio> m must be a functor.
12:20:47 <roconnor> dolio: that's all?
12:20:50 <cydergoth> EvanR-work: I was hoping to isolate the simulation state from the GTSdata
12:20:58 <EvanR-work> like above
12:21:05 <dolio> A free monad is the monad freely generated by a functor, similar to how a free group is generated by a set.
12:21:09 <ski> yes
12:21:12 <ski> there's
12:21:19 <EvanR-work> just decide on the two formats and write a translator
12:21:21 <roconnor> dolio: okay, and your tree thing is isomorphic to Unfold?
12:21:28 <dolio> Yes.
12:21:28 <ski>   runFreeMonad :: Monad m => FreeMonad m a -> m a  -- though
12:21:53 <ski> (but i should probably have used `f' instead of `m', above in the definition)
12:21:54 <roconnor> dolio: okay, but your definition of the Unfold monad uses the IO monad; however you just said that all we require is the f be a function.
12:21:59 <cydergoth> EvanR-work: yes, agreed. In the comment above about state Monad, shouldn't I always want to avoid imperative style in Haskell if at all possible?
12:22:02 <roconnor> *be a functor
12:22:25 <EvanR-work> cydergoth: well, IO is necessarily imperative
12:22:42 <cydergoth> EvanR-work: Yes, that's in the IO Monad, what about State Monad?
12:22:50 <EvanR-work> other things may benefit from local imperative style, someone may have an example
12:23:00 <roconnor> dolio: if I replaced IO in your definition of Unfold with some random functor, your monad instance would fail.
12:23:11 <cydergoth> EvanR-work: So List is in the State Monad right? 
12:23:21 <EvanR-work> ehm
12:23:30 <EvanR-work> list is a monad, state is another monad
12:23:31 <roconnor> dolio: but if I replaced IO in Free (/\b -> (n, IO [b])), with some random functor, then the monad instance for Free would still work.
12:23:42 <roconnor> dolio: so something seems wrong here.
12:24:08 <dafis> int80_h: fun  = ("prefix" ++)
12:24:29 <dolio> roconnor: Unfold isn't exactly Tree n a, I think it's IO (Tree n a).
12:24:32 <dafis> int80_h: if you'r prepending single Chars, even better (:)
12:25:07 <cydergoth> EvanR-work: Ok, so if I can do functional updates to my state I copy the state each time replacing one field with the new contents right?
12:25:12 <roconnor> dolio: the composition of monads isn't a monad unless the monads distribute.
12:25:23 <cydergoth> EvanR-work: So if my state is very large, I have lots of copy overhead?
12:25:28 <EvanR-work> cydergoth: well its not a full copy
12:25:35 <EvanR-work> under the hood
12:25:39 <int80_h> dafis : I need to map over a list. I have this as part of a function composition
12:25:48 <int80_h> map (\s e -> "/home/michael/blog/entries" ++ e) 
12:25:50 <EvanR-work> conceptually its just another value, independent from all others
12:25:57 <int80_h> dafis : map (\s e -> "/home/michael/blog/entries" ++ e) 
12:26:07 <cydergoth> EvanR-work: So it I have one small field in a huge record which I update, it doesn't copy the whole record?
12:26:08 <int80_h> of course this breaks, but am I on the right track?
12:26:19 <EvanR-work> no
12:26:47 <cydergoth> EvanR-work: Ah, that makes things a *lot* easier. 'cos the geometry might be *huge*
12:27:00 <EvanR-work> an extreme case is your state is a tree
12:27:05 <EvanR-work> you update a leaf
12:27:12 <EvanR-work> you only copy the nodes leading to that leaf
12:27:35 <cydergoth> EvanR-work: Right. But if my state is a Record, then I copy all the other fields in the Record?
12:27:39 <jmcarthur> cydergoth: you should change all the fields of a record at once rather than than one at a time if you can help it
12:27:41 <ski> dolio : hm .. just wondering if it might be `TreeT n IO a' ..
12:27:55 <dolio> Yes, it's TreeT n IO a. As I said.
12:28:08 <EvanR-work> cydergoth: if the record is not implemented as a tree yes ;)
12:28:10 <dafis> int80_h: you ignore the s, did you mean map ("/home/moichael/blog/entries/" ++) ?
12:28:22 <roconnor> dolio, ski: how do we define a free monad transfomer :D
12:28:24 <dafis> *michael*
12:28:28 * ski didn't see dolio saying that ..
12:28:41 <dolio> Monad transformer isn't even a well-defined categorical concept, as far as I know.
12:28:42 <int80_h> dafis : yes?
12:28:43 <cydergoth> jmcarthur: So as my record is the internal state of a VM being updated by running (simulating) a program, that isn't going to be the case
12:28:45 <EvanR-work> cydergoth: im guessing a single record is implemented as an array of pointers, so you must copy the whole thing
12:29:05 <EvanR-work> cydergoth: and State wont help you
12:29:12 <ski> (dolio : cf. `IO [a]' vs. `ListT IO a')
12:29:13 <jmcarthur> cydergoth: oh, i meant per step. i didn't realize you were talking about multiple simulation steps
12:29:15 <cydergoth> EvanR-work: but if a field in the record points to a huge data structure, it will only copy the pointer?
12:29:24 <dafis> int80_h: System.FilePath.joinPath would also be fine for that
12:29:27 <jmcarthur> that's right
12:29:31 <dolio> "It's the rose tree version of the proper ListT."
12:29:33 <EvanR-work> cydergoth: yes
12:29:52 <int80_h> dafis : ah
12:29:55 <ski> (er .. that should be the interleaved version of `ListT' ..)
12:29:57 <cydergoth> jmcarthur: each step will likely only update one field, the field the op-code (gcode) refers to
12:30:05 <jmcarthur> okay
12:30:17 * ski tries to remember whether the one in the library is interleaved or not
12:30:30 <cydergoth> EvanR-work, jmcarthur, ski, roconnor, benmachine: Thx all, that's been a great help
12:30:39 <jmcarthur> > let x = ("foo", [1..]) in first (++ "bar") x
12:30:40 <lambdabot>   ("foobar",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,2...
12:30:51 <jmcarthur> cydergoth: see there? it didn't *copy* the entire infinite list
12:30:58 <jmcarthur> it just referred to the same one
12:31:09 <pastorn> has the web chat people stopped coming?
12:31:21 <jmcarthur> pastorn: there are still a few, but the influx is mostly over
12:31:39 <pastorn> hehe
12:31:50 <dolio> TreeT n m a = m (Tree n m a), Tree n m a = a | n * [TreeT n m a]
12:32:00 <cydergoth> Gotcha. So I can do the whole lot in functional style and just realise the computation when I want to do IO with it. 
12:32:03 <roconnor> dolio, ski: is there a paper that describes and proves that listT is a monad transfomer?
12:32:13 <ski> dolio : *nod*
12:32:18 <jmcarthur> cydergoth: right
12:32:24 <int80_h> @hoogle System.FilePath.joinPath
12:32:25 <lambdabot> System.FilePath.Posix joinPath :: [FilePath] -> FilePath
12:32:25 <lambdabot> System.FilePath.Windows joinPath :: [FilePath] -> FilePath
12:32:36 <ski> roconnor : iirc, it isn't, unless the given monad is commutative
12:32:52 <roconnor> It isn't obvious to me that TreeT (or ListT) is a monad transfomer.
12:33:06 <roconnor> ski: !
12:33:11 <dafis> int80_h: as long as you run it on only one system, that'd be overkill, but if you want to port to windows, ...
12:33:14 <roconnor> ski: IO is *not* a commutative monad.
12:33:16 <dolio> The correct ListT is a transformer.
12:33:28 <dolio> ListT m a = m [a] is not a transformer.
12:33:33 <dolio> But that's not what this is.
12:33:39 <aristid> which is the correct ListT?
12:33:39 * ski hasn't pondered the interleaved `ListT' case, here
12:33:47 <ski> aristid : the interleaved one
12:33:52 <roconnor> newtype ListT m a =
12:33:54 <roconnor>   ListT { runListT :: m (ListItem (ListT m) a) }
12:33:54 <how> can someone tell me where i can download a virus
12:33:54 <lambdabot> how: You have 1 new message. '/msg lambdabot @messages' to read it.
12:34:14 <dolio> That one is the same as LogicT.
12:34:22 <int80_h> dafis : hmm, well I may as well learn how to use lambda functions then, as I have no intention of running this code on windows. But this function makes things look alot simpler
12:34:22 <roconnor> ListItem l a = Maybe (a , l a)
12:34:26 <aristid> that looks similar to MonadLib's ChoiceT
12:34:42 <dolio> Yes, ChoiceT, too.
12:34:49 <ski> (in the "even", not the "odd" style .. cf. "How to Add Laziness to a Strict Language Without Even Being Odd")
12:34:50 <int80_h> dafis : would you like me to re-post my attempt at using map with a lambda function?
12:34:53 <roconnor> ListT, LogicT and ChoiceT are all the same?
12:34:54 <int80_h> it breaks
12:35:03 <dafis> int80_h: sure, go ahead
12:35:15 <ski> roconnor : `LogicT' is more involved
12:35:16 <dolio> LogicT and ChoiceT are different implementations of the same thing.
12:35:17 <Twey> @index (</>)
12:35:17 <lambdabot> Text.Html
12:35:18 <jmcarthur> how: try this http://www.microsoft.com/windows/internet-explorer/
12:35:25 <Twey> Hm
12:35:29 <dolio> ListT in mtl is broken.
12:35:38 <Twey> That's not what I'm looking for
12:35:38 <int80_h> dafis : this is part of a function composition
12:35:38 <dolio> The good ListT is ChoiceT.
12:35:44 <Twey> What's that operator that joins path components?
12:35:45 <int80_h> dafis: map (\s e -> "/home/michael/blog/entries" ++ e)
12:35:48 <roconnor> dolio: okay, how do you convince me that ListT is a monad transfomer (and persumably TreeT will be similar)
12:36:05 <how> except porn is there any way to download a virus that will delete everything on your computer
12:36:26 <ski> Twey : `joinPath' from above ?
12:36:43 <jmcarthur> yes there is
12:36:48 <dafis> int80_h: you have two args in the lambda, so that's map (const ("/home/..." ++))
12:36:55 <Twey> No, there was an operator :: FilePath -> FilePath -> FilePath
12:37:01 <ski> how : you could write one yourself .. in Haskell
12:37:07 <Twey> I was pretty sure it was called </>
12:37:10 <aristid> MonadLib seems to be quite nice
12:37:10 <dafis> int80_h: map (\e -> "/home/.." ++ e) ?
12:37:14 <Twey> @src joinPath
12:37:14 <lambdabot> Source not found. You speak an infinite deal of nothing
12:37:30 <benmachine> :t (System.FilePath.</>)
12:37:31 <lambdabot> FilePath -> FilePath -> FilePath
12:37:39 <Twey> Ah, that's it!  Thanks
12:37:49 <Twey> Silly @index
12:37:50 <int80_h> dafis: the second one you typed is what I want
12:38:05 <EvanR-work> cool symbol </>
12:38:17 <ski> int80_h : so, use `</>' instead of `++'
12:38:17 <jmcarthur> how: viruses aren't typically so aggressive today. it's more profitable to simply hide on somebody's machine and send out spam
12:38:24 <jmcarthur> how: anyway, you're greatly off topic here
12:38:26 <roconnor> ski, dolio: can we really not build listT out of pieces in category-extras?
12:38:51 <ski> roconnor : probably ..
12:38:51 <int80_h> ski : you are saying my lambda should look like this?
12:38:56 <roconnor> it has a very free feeling to it
12:39:24 <int80_h> ski: map (\e -> "/path/to/dir" </> e)
12:39:31 <int80_h> ski: that makes no sense to me
12:39:45 <ski> roconnor : note that you need to define `ListItem'
12:39:54 <ski> s/define/express/
12:40:21 <dafis> int80_h: prefix </> file = prefix ++ "/" ++ file on unix
12:40:35 <roconnor> ski: I thought ListItem was there just for no good reason ...
12:40:35 <ski> int80_h : `</>' is an operator which handles the OS-specific filepath things for you, iirc
12:40:42 <int80_h> dafis: ahhhh
12:40:45 <dafis> int80_h: prefix ++ "\\" ++ file on windows
12:40:48 <int80_h> ski: thanks
12:40:51 <roconnor> ski: I mean, we could inline the definition
12:40:57 <ski> roconnor : but, yes
12:41:40 <aristid> it seems like _ </> b@('/' : _) = b
12:41:45 <aristid> (on my linux machine)
12:42:05 <int80_h> okay guys, I'm missing a jot or tittle somewhere, I will post context on hpaste
12:42:12 <int80_h> but I think this is just about ready
12:42:56 <dafis> aristid: it seems to handle absolute paths special
12:43:04 <aristid> dafis: yeah
12:45:14 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27957#a27957
12:45:28 <int80_h> there we are
12:46:42 <ski> int80_h : "entries <- mapM readFile entryFileName)"
12:46:46 <dafis> int80_h: stary closing paren
12:46:52 <dafis> stray*
12:47:04 <ski> also, i'd use a `let' in the `do', instead of the insanely long line
12:47:34 <ski> (and s/entryFileName/entryFileNames/)
12:48:06 <int80_h> ski: I will make it pretty after I make it working
12:48:12 <askhader> What's the problem with this type signature? element-at :: [a] -> Int -> a
12:48:14 <int80_h> dafis: where is the stray closing paren?
12:48:31 <aristid> is readFile strict?
12:48:36 <dafis> int80_h: or put a function fixup = map ("/home/.." </>) . filter (`notElem` [".",".."]) in the where clause and fmap fixup getDirectorycontents
12:48:41 <ski> int80_h : look closely at the line i sent above
12:48:49 <int80_h> looking
12:49:06 <dafis> int80_h: line 4, as ski said
12:49:09 <ski> aristid : it uses lazy I/O
12:49:20 <benmachine> BONUS: hey, I was just reading your lyah chapter on applicatives and down where you explain newtype it looks like one of the examples isn't finished - CharList "benny" == CharList "oisters" doesn't have the output shown
12:49:34 <aristid> ski: is there a strict variant, too?
12:49:57 <int80_h> @hoogle </>
12:49:58 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
12:49:58 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
12:49:58 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
12:50:03 <ski> aristid : possibly in some lib on hackage .. but i don't recall for sure
12:50:05 <dafis> ski: however, readFile undefined ?
12:50:42 <ski> dafis : i'm not sure, but possibly it's strict in the file open operation
12:50:48 <EvanR-work> htmltable is a type and class o_O?
12:51:04 <dafis> aristid: http://hackage.haskell.org/package/strict
12:51:08 <benmachine> dafis: lazy I/O is different from other sorts of laziness
12:51:23 <benmachine> aristid: some of the bytestring modules define strict readFile functions
12:51:23 <ski> no, `HtmlTable' is a type and `HTMLTABLE' is a class :)
12:51:28 <EvanR-work> bah
12:51:47 <dafis> ski, benmachine: yes, but in the sense of f _|_ = _|_, it's strict ;)
12:51:50 <ski> @type (==>)
12:51:51 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
12:51:57 <aristid> dafis: cool
12:51:58 <int80_h> okay when I try and import System.Filepath.Posix I get "could not find". What do I need to install to import System.Filepath.Posix?
12:52:02 <ski> EvanR-work : ^ probably similar to that case
12:52:10 <int80_h> better question, how do I find out myself the answer to that question
12:52:36 <benmachine> int80_h: capital P?
12:52:37 <dafis> ski, benmachine: except, it's probably not, _<_ only appears when the IO-action is tried to execute
12:52:39 <aristid> hGetContents h  = IO.hGetContents h >>= \s -> length s `seq` return s
12:52:40 <ski> dafis : well, i'm not sure, but i assume so
12:52:50 <aristid> hmm i'm not sure if i like that implementation
12:52:50 <EvanR-work> ski: k but what else could be in the HTMLTABLE class but HtmlTable ;)
12:53:01 <EvanR-work> whatever argument you use could be use for anything
12:53:12 <benmachine> ghci> readFile undefined >> return ()
12:53:12 <ski> EvanR-work : maybe `(HtmlTable,HtmlTable)' and `[HtmlTable]' or something ? .. not sure
12:53:13 <benmachine> *** Exception: Prelude.undefined
12:53:18 <int80_h> benmachine: hoogle says capital P
12:53:25 * ski isn't sure what `HtmlTable' is to be used for
12:53:27 <benmachine> int80_h: yeah, you didn't though
12:53:38 <benmachine> int80_h: err, as in, FilePath
12:53:39 <EvanR-work> ski: class INT for (Int,Int) and [Int] ;)
12:53:45 <dafis> aristid: I've never used it, I don't kno if it's any good
12:53:47 <EvanR-work> makes sense to be!
12:53:50 <EvanR-work> me
12:54:06 <benmachine> int80_h: it's in the filepath package, which should come with GHC I think
12:54:07 <int80_h> ahhh
12:54:19 <ski>   data SomeInt = forall int. INT int => WrapInt int  -- :)
12:54:34 <dafis> int80_h: benmachine meant FilePath with a capital P
12:54:40 * EvanR-work goes insane
12:55:06 <ski> EvanR-work : as said, i'm not even sure what `HtmlTable' is *for*, so i'm just guessing
12:55:22 <EvanR-work> heh
12:55:39 * dafis should really learn to type faster than two keys per second
12:55:39 <int80_h> gotcha
12:55:51 <EvanR-work> dafis: y   e   s
12:56:30 <dafis> EvanR-work: but how to teach an old cat a new trick?
12:56:43 <EvanR-work> switch to dvorak or something
12:56:55 <EvanR-work> awaken the sleeping brain
12:57:12 <dafis> EvanR-work: it's a finger thing, too
12:57:23 <benmachine> use more fingers
12:57:26 <roconnor> dolio, ski: Is there a function TreeT IO a -> IO (Tree a) ?
12:57:27 <dafis> they're not used to it
12:57:43 <cydergoth> benmachine: voice recognition ;-)
12:57:51 <roconnor> or a function ListT IO a -> IO [a] ?
12:57:58 <dafis> benmachine: I could use four more, but those are pretty useless for anything so far
12:58:09 <ski> roconnor : yes .. just hoist all the `IO' upwards, `join'ing it
12:58:30 <benmachine> dafis: four more per hand, or in total?
12:58:41 <dafis> benmachine: in total
12:58:42 <roconnor> ski: for TreeT it must be less canonical since it is a little bit less ordered.
12:58:44 <ski> roconnor : of course, the tree'd better be finite for that to work out with monads like `IO'
12:58:50 <benmachine> oh
12:58:52 <benmachine> which four?
12:59:06 <dafis> benmachine: I moved from four fingers to six over the last year
12:59:10 <benmachine> oh right
12:59:14 <benmachine> weird
12:59:17 <ski> roconnor : agreed
12:59:31 <benmachine> I think I went from two to ten
12:59:33 <benmachine> can't really remember how though
12:59:37 <benmachine> practice, lots of practice
12:59:39 <benmachine> perhaps.
12:59:40 <BMeph> dafis: MOAR FEEGRRZZZ!
13:00:00 <dafis> BMeph: doesn't seem to help spelling :)
13:00:03 <benmachine> maybe being picky about using the right finger for the right key would slow you down for a bit but then speed you up
13:00:19 <BMeph> dafis: Don't you mean "speeling"? ;P
13:00:43 <dafis> BMeph: then it would have tobe seam
13:00:49 <dafis> to be
13:00:54 <dafis> arrgh
13:01:47 * ski . o O ( <http://www.lisperati.com/casting-spels-emacs/html/casting-spels-emacs-1.html> )
13:02:09 <roconnor> ski: okay, so given winterkoninkje's coalgrebra (FilePath -> IO (f FilePath)) there is some sort of ana-like function that would build a TreeT IO FilePath.
13:03:30 <roconnor> also given a seed FilePath
13:05:16 <BMeph> roconnor: Surely the "seed FilePath" comes from the coalgebra? ;)
13:05:26 <roconnor> nope
13:06:15 <ski> @type unfoldr
13:06:16 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:06:29 <ski> the seed `FilePath' corresponds to the latter `b', there
13:08:32 <ski> roconnor : anyway, i'm starting to get too tired atm .. i'll try to look at this later
13:08:52 <roconnor> ski: thanks, I've understood a lot
13:09:20 <Twey> I was starting to do that with QWERTY when I switched to typing properly with Dvorak
13:09:53 <benmachine> Twey: do what
13:11:31 <g_cross> @hoogle [a -> b] -> [a] -> [b]
13:11:31 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:11:31 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
13:11:31 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:11:59 <g_cross> @hoogle [a -> b] -> a -> [b]
13:11:59 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:11:59 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
13:11:59 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:12:08 <ski> g_cross : also `zipWith ($)', if you want other behaviour
13:12:10 <benmachine> :t flip
13:12:11 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:12:24 <benmachine> <_<
13:12:42 <benmachine> g_cross: what are you looking for?
13:12:47 <dolio> roconnor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27960#a27960
13:12:53 <dolio> There's a sketch of the monad laws for ListT.
13:13:00 <g_cross> I am looking for a function that applies a list of functions to a single value to obtain a list of values
13:13:03 <ski> @type let flip fs a = fmap ($ a) fs in flip
13:13:04 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:13:18 <benmachine> :t map id
13:13:19 <lambdabot> forall a. [a] -> [a]
13:13:20 <g_cross> I can think of several ways to do it, it's just that I figure there should be a particularly elegent way :-)
13:13:21 <benmachine> oh
13:13:23 <benmachine> wait
13:13:40 <benmachine> :t map (flip id)
13:13:41 <ski> g_cross : `flip fs a = fmap ($ a) fs' basically, then
13:13:41 <lambdabot> forall a b. [a] -> [(a -> b) -> b]
13:13:50 <benmachine> okay maybe I should actually think
13:13:59 <Tomsik> :t ($ 3)
13:14:00 <lambdabot> forall a b. (Num a) => (a -> b) -> b
13:14:02 <dolio> I realized at the end that it kind of takes liberties, with things like 'nil `append` xs = xs' not being quite accurate. You have to imagine that the latter xs may have an additional side effect that can be plucked back out later.
13:14:13 <jmcarthur> :t map . id
13:14:13 <roconnor> dolio: thanks
13:14:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:14:18 <jmcarthur> doh
13:14:21 <jmcarthur> :t map . flip id
13:14:22 <lambdabot> forall b a. a -> [a -> b] -> [b]
13:14:32 <ski> (g_cross : as the name `flip' already exists in `Prelude' you'll either have to give it another name, or hide the `Prelude' one)
13:14:50 <ski> (g_cross : .. or, just inline the body of it, of course)
13:15:06 <roconnor> dolio: this ListT / TreeT stuff seem very generic
13:15:07 <g_cross> ski: Oh, okay, I was actually confused for a moment there because I had thought that flip had another definition.  :-)
13:15:10 <g_cross> @src flip
13:15:10 <lambdabot> flip f x y = f y x
13:15:11 <jmcarthur> :t flip $ map . flip id
13:15:12 <lambdabot> forall b a. [a -> b] -> a -> [b]
13:15:34 <benmachine> g_cross: lambdabot has some experimental magics
13:15:38 <benmachine> which aren't magic
13:15:42 <ski> g_cross : `flip fs a = fmap ($ a) fs' is a generalization of both the ordinary `flip', and the one for lists you're after
13:16:05 <ski> @type Prelude.flip
13:16:05 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:16:24 <ski> (and in your case, `fmap' is just `map', since you have lists)
13:16:33 <ski> (s/is just/can be simplified to/)
13:17:20 <jmcarthur> > flip [(+1), (*2)] 5
13:17:20 <lambdabot>   [6,10]
13:17:27 <ski> @type let flip = flip $ fmap . flip id in flip
13:17:28 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
13:17:28 <lambdabot>     Probable cause: `$' is applied to too many arguments
13:17:28 <lambdabot>     In the expression: flip $ fmap . flip id
13:17:31 <ski> hehe
13:17:38 <BMeph> :t (([]++).). flip
13:17:39 <lambdabot> forall a a1. [a1 -> a] -> a1 -> [a]
13:17:56 * BMeph wins Caleskell Golf!
13:18:11 <ski> @type let flip :: Functor f => f (a -> b) -> a -> f b; flip = flip $ fmap . flip id in flip  -- right
13:18:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:18:23 <jmcarthur> :t flip :: [a -> b] -> a -> [b]
13:18:24 <lambdabot> forall a b. [a -> b] -> a -> [b]
13:18:29 <jmcarthur> BMeph: sorry, i win
13:18:34 <ski> (only that probably loops ..)
13:19:16 <BMeph> :t flip.([]++)
13:19:17 <olsner> oh! flip can be and has been caleskelled too?
13:19:17 <lambdabot> forall a b. [a -> b] -> a -> [b]
13:19:25 <ski> @pl ([] ++)
13:19:25 <lambdabot> ([] ++)
13:19:27 <ski> bah
13:19:31 <olsner> :t Prelude.flip
13:19:32 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:19:34 <jmcarthur> yeah flip is caleskelled
13:20:08 <olsner> ski: id?
13:20:08 <dafis> @unpl ([] ++)
13:20:09 <lambdabot> (\ a -> ([]) ++ a)
13:20:13 * BMeph thinks "Caleskell-f*cked" is more like it... ;)
13:20:22 <ski> olsner : yes .. but BMeph wanted otherwise
13:20:29 <djahandarie> I don't think Cale came up with that flip definition though
13:20:36 <djahandarie> Actually, ski, wasn't it you?
13:20:48 <ski> (BMeph,olsner : well, i'm to blame :)
13:20:55 <BMeph> olsner: Pinning the Functor to [], I did.
13:21:02 * jmcarthur tars and feathers ski
13:21:28 <ski> djahandarie : yes, it seemed the kind of thing that would fit in with Caleskell `(.)' :)
13:21:31 * BMeph "J'Accuse"'s
13:21:37 * hackagebot functor-combo 0.0.2 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.0.2 (ConalElliott)
13:21:42 <ski> not that i really condone *using* it, of course
13:21:43 <jmcarthur> :t (++)
13:21:44 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:21:44 <BMeph> ... ski.
13:21:55 <jmcarthur> that's one that i actually like
13:22:02 <jmcarthur> except that it doesn't mirror haskell proper
13:22:07 <jmcarthur> well, base, that is
13:22:21 <ski> (i don't condone *not* using it either .. i thought it might be nice to experiment with .. and, i admit, a bit fun to annoy people with ;)
13:22:31 <olsner> ski: so what does functor-flip actually do?
13:22:43 <ski> olsner : type says it all, really
13:22:45 <BMeph> Yes, GHCi needs more "read my mind, and give me error messages biased to what I thought I was doing" powers... ;√æ
13:22:50 <jmcarthur> next thing you know my whitespace preprocessor will be loaded into lambdabot
13:23:33 * BMeph aves hysterically at jmcarthur to be quiet, then frantically looks for signs of Cale...
13:23:39 <BMeph> *waves
13:23:57 <benc___> BMeph: that's what helium is meant to be
13:24:01 * jmcarthur aves back at BMeph
13:24:08 <ezyang> Stand back everyone! 
13:24:13 * ezyang is about to do something very evil. 
13:24:21 * ski runs for cover
13:24:22 <jmcarthur> i physically rolled back in my chair when you said that
13:24:26 * monochrom is already evil
13:24:29 <zygoloid> sometimes Caleskell disappoints me. id = ask, anyone? ;-)
13:24:34 <ezyang> I have pattern matching with side effects, so I'm splitting up my function a -> b -> c into a -> (b -> c) 
13:24:36 <jmcarthur> o_O
13:24:58 <BMeph> Benc___: As far as Helium has Haskell power, I agree.
13:25:00 <ski> zygoloid : you should suggest that
13:25:04 <ezyang> Mua ha ha ha. 
13:25:11 <ezyang> (I am so going to regret this later) 
13:25:25 <jmcarthur> ezyang: so you're doing nothing to you function?
13:25:29 <jmcarthur> *your
13:25:29 <ski> ezyang : er, `a -> b -> c' is the same as `a -> (b -> c)'
13:25:48 <ski> ezyang : maybe you meant to say that you have serious currying ?
13:26:03 <ski> (in the sense of "serious" vs. "trivial" function arrows)
13:26:03 <BMeph> ezyang: ...unless your function distinguishes this? >;)
13:26:07 <jmcarthur> my indian neighbors have some serious curry
13:26:42 * BMeph has Japanese friends who like wasabi with their curry...
13:26:49 <jmcarthur> interesting
13:27:00 <olsner> when pattern matches have side effects, it would make a difference to define a function matching two arguments in each equation and a function with one-argument equations that return functions
13:27:07 <olsner> ezyang: nicely evil, well done
13:27:13 <jmcarthur> olsner: yeah, but the type is the same
13:27:22 <monochrom> f [] = unsafePerformIO (getLine >>= \l -> return (\x -> l ++ show x)); f s = unsafePerformIO (getLine >>= \l -> return (\x -> show x ++ l))
13:27:32 <ski> (`([] ++) = id; ((a : as) ++) = (a :) . (as ++)' being a "serious"ly curried function defined)
13:28:24 <ski> (olsner : well, it also makes a difference for fall-through ..)
13:28:50 <med_> hi all
13:28:53 <opqdonut> oh please this can't be true
13:28:58 <opqdonut> Data.Vector.Fusion.Stream doesn't even have rules for fusion
13:29:05 <ski> lo med_
13:29:25 <zygoloid> high?
13:29:58 <ski> @type let ([] ++) = id; ((a : as) ++) = (a :) . (as ++) in (++)
13:29:59 <lambdabot> Parse error in pattern
13:30:01 <ski> bah!
13:31:33 <ski> med_ : do you have a question ?
13:32:00 <med_> yes., but I was still searching the library
13:32:17 <askhader> I'm attempting to write a simple test to check if a list is a palindrome but I seem to be getting some kind of error. COuld someone take a look?  http://codepad.org/oFkDnfbl   
13:32:32 <med_> i need to write a program that gets the html code of a wiki page
13:32:42 <med_> and don't know which library to use
13:33:01 <Peaker> askhader, are you using hugs or such? Not GHC?
13:33:07 <askhader> I am using GHC
13:33:20 <ski> @type head
13:33:21 <lambdabot> forall a. [a] -> a
13:33:22 <ski> @type tail
13:33:23 <lambdabot> forall a. [a] -> [a]
13:33:24 <ski> @type last
13:33:25 <lambdabot> forall a. [a] -> a
13:33:29 <askhader> oops
13:33:39 <askhader> Wait, tail is right
13:33:43 <Peaker> askhader, that's a weird type error -- doesn't look like GHC's
13:33:49 <ski> askhader : only one of them
13:34:19 <ski> askhader : also, it'd be nicer, imo, if you used pattern-matching
13:34:30 <ski> askhader : .. but maybe you wanted a certain symmetry ?
13:34:36 <ski> also, the empty list
13:34:39 <Peaker> askhader, What if you are given an even-length'd palindrome?
13:34:56 <Peaker> empty list is what it would reduce to, yeah
13:34:59 <askhader> Peaker: Hmm, I guess I can remove that clause then
13:35:04 <djahandarie> askhader, I'm pretty sure that's hugs if you are using codepad's evaulator
13:35:34 <askhader> i wanted to use pattern matching but was uncertain of how to put conditions into the syntax. Still rather new to haskell.
13:35:35 <Peaker> hugs has nice error msgs if this is how they're like
13:35:56 <ski> djahandarie : looks like Hugs' error, yes
13:35:56 <Peaker> much nicer than "infinite type a = [a] somewhere in your entire function" like GHC
13:36:19 <dafis> Peaker: hugs' messages aren't so good when you make complicated errors
13:36:32 <BMeph> askhader: First off: UR DOIN IT RONG!!!1111!1!!ichi111
13:36:33 <Peaker> today I tried to find an infinite IO a = IO (IO a)  for a whole 5 minutes or so of staring at screen :-(  Used . instead of =<< in one place
13:37:14 <Peaker> People who never do it wrong - never do at all..
13:38:06 <BMeph> Peaker: What a coincidence! 'Cause, people who Always do it wrong...well, you know. ;)
13:38:08 <ski> askhader : instead of `isPalindrome xs | length xs == 1 = ..(head xs)..' do `isPalindrome [x] = ..x..'
13:38:10 <askhader> How would you use syntax matching for this problem?
13:38:35 <BMeph> Answered and asked. ski Wins. :)
13:38:49 <askhader> Hm
13:38:50 * askhader attempts
13:39:01 <ski> askhader : instead of `isPalindrome xs = ..(head xs)..(tail xs)..' use `isPalindrome (x:xs) = ..x..xs..'
13:39:38 <ski> askhader : if you also want to use `xs' otherwise, then : instead of `isPalindrome xs = ..xs..(head xs)..(tail xs)..' use `isPalindrome xs0@(x:xs) = ..xs0..x..xs..'
13:40:06 <ski> (BMeph : .. hm, wins *what* !?)
13:40:18 <monochrom> wins a cookie
13:40:30 <ski> askhader : finally, instead of `isPalindrome xs | null xs = ...' use `isPalindrome [] = ...'
13:40:30 <Peaker> go get yourself a cookie
13:41:01 <ski> askhader : is that clear enough ?
13:41:25 <med_> excuse me, in which library can I found a function that retrieves the html code of a web page? :D
13:41:28 * ski ponders .. hm, no cookies at home, no
13:41:31 <askhader> Well I don't know how to construct the pattern that matches the list whose first element equals its last.
13:42:08 <dafis> askhader: you can't do that with pattern matching
13:42:09 <ski> askhader : for the last element you will still need to call `last' .. so you will need a guard for that
13:42:20 <aristid> :t let isPalindrome = (==) <*> reverse in isPalindrome
13:42:21 <lambdabot> forall a. (Eq a) => [a] -> Bool
13:42:31 <ski> (askhader : well, you could do it with view patterns .. but i think that's too advanced for the moment)
13:42:36 <askhader> I know that solution
13:42:39 <askhader> But I want to do it this way
13:43:31 <ski> askhader : another way, of course is to *not* call `last' (directly or indirectly) at all, but instead walk through the list, and start matching when you walk up the recursion again
13:44:16 <askhader> ah
13:44:20 <Veinor> what's the big-O efficiency of reverse?
13:44:30 <ski> (which will require a worker/wrapper division)
13:44:31 <Saizan> O(n)
13:44:41 <triyo> The lib for manipulating XML documents in Haskell? Would HaXml be the best option? Seem to be the best documented and with most activity.
13:44:43 <g_cross> askhader:  Or you could use Sequence
13:44:45 <Veinor> how's it work in O(n)?
13:44:54 <Veinor> @src reverse
13:44:54 <lambdabot> reverse = foldl (flip (:)) []
13:45:02 <ski> g_cross : *nod* (preferably with view patterns)
13:45:12 <Veinor> isn't that O(n^2)?
13:45:13 <g_cross> ski: My thought exactly
13:45:27 <dafis> Veinor: no, it's O(n)
13:45:31 <med_> triyo: thanks i will try HaXml
13:45:31 <ski> Veinor : the whole list is traversed, once, and each `flip (:)' step is `O(1)'
13:45:36 <Veinor> ah
13:45:43 <Veinor> oh yeah, flip (:) is O(1)
13:45:46 <Veinor> derp
13:45:49 <g_cross> ski:  Oh, actually I misread;  I was actually thinking in terms of pattern guards
13:46:16 <ski> Veinor : using `foldr (\x xs -> xs ++ [x]) []' *would* be `O(n^2)' (when `n' is the length of the input), though, yes
13:46:19 <BMeph> triyo: Is this a popularity question, or a functionality question? ;)
13:46:25 <dafis> Veinor: however, GHC uses a different (more efficient) implementation
13:46:31 <triyo> med_: hehe, I was actually asking the question myself ;-) ... but in my opinion, it seems to be the way to go :)
13:46:32 <ski> g_cross : yeah, pattern guards would do as well
13:46:35 <Saizan> dafis: does it?
13:46:40 <Peaker> triyo, I like Text.XML.Light
13:46:41 <Veinor> more efficient than O(n)?
13:46:51 <Saizan> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=foldl+(flip+(:))+[]+[1,2,3,4,5] <- btw
13:46:57 <dafis> Saizan: #ifdef USE_REPORT_PRELUDE
13:46:57 <dafis> reverse                 =  foldl (flip (:)) []
13:46:57 <dafis> #else
13:46:57 <dafis> reverse l =  rev l []
13:46:57 <dafis>   where
13:46:58 <dafis>     rev []     a = a
13:47:00 <dafis>     rev (x:xs) a = rev xs (x:a)
13:47:02 <dafis> #endif
13:47:11 <Saizan> ah, ok, it just inlines foldl
13:47:13 <dafis> Veinor: no, better constant factor
13:47:14 <triyo> BMeph: popularity of course. Just kidding. Well equivalent to Parsec in its own context.
13:47:17 <Veinor> ah.
13:47:31 <Peaker> Saizan, nice site
13:47:33 <dafis> Saizan: yep
13:47:50 <BMeph> triyo: :)
13:47:51 <Cale> dafis: I really wish that GHC would compile those to the same thing.
13:47:53 <Peaker> why inline foldl? why not a pragma?
13:48:03 <dafis> Cale: who doesn't
13:48:11 <Peaker> over-inlining is also costly
13:48:16 <Cale> I think it misses out some optimisations which it really ought to.
13:48:24 <Cale> er, ought to have
13:48:35 <triyo> Peaker: I'll check out the light lib
13:48:38 <ski> benmachine : nice stepper ! :)
13:48:38 <Peaker> maybe it can try to inline -- see if it's worth it (see what optimizations come up with, whether it takes more or less space, etc)
13:48:45 * BMeph prefers "rev [] = id; rev (x:xs) = rev xs . (x:)" ... ;)
13:49:01 <Cale> BMeph: me too
13:49:07 <ski> (different type)
13:49:07 <Saizan> in general GHC doesn't inline recursive definitions
13:49:13 <ski> (er, misread)
13:49:16 <Peaker> Saizan, why?
13:49:31 <dafis> Peaker: code size
13:49:43 <benmachine> ski: hello, thanks :)
13:49:54 <dafis> and it wouldn't always be good
13:49:57 <benmachine> ski: two failing testcases atm though
13:49:58 <Peaker> why does inlining a recursive definition like foldl into its user take much space?  I understand why not to inline the recursive call itself
13:50:01 <Saizan> i guess because it'd end up looping the inliner?
13:50:02 <dafis> (I've read somewhere)
13:50:20 <ski> (benmachine : i'll possibly take a look at the source, later, when i'm not tired)
13:50:21 <Peaker> Saizan, there's a difference between inlining a call to a recursive function, and inlining the recursive call itself, isn't there?
13:50:34 <Cale> Peaker: Well...
13:50:40 <Saizan> anyhow, here you're really specializing foldl wrt (flip (:)) [] more than inlining.. i think that's what supercompilation does
13:50:56 <Cale> Peaker: Once you've inlined foldl, then running the inliner again will inline it again...
13:51:00 <benmachine> ski: awesome. I keep meaning to ask haskell-cafe for help with it but I haven't got around to it yet. I'm alwayshappy to take on collaborators :)
13:51:56 <dafis> benmachine: what is it about?
13:51:59 <benmachine> (as much as I like this project I'd rather see someone else do it well than do it badly myself)
13:52:20 <Cale> reverse xs = foldr (\x xs -> xs . (x:)) id xs []
13:52:21 <Peaker> Cale, you can inline it to convert the recursive call to foldl to a recursive call to same-func, at least in this case
13:52:26 <benmachine> dafis: we're talking about http://github.com/benmachine/stepeval
13:52:30 <Twey> benmachine: Why does your stepeval evaluate foldl's but not scanl's?
13:52:32 <Peaker> Cale, I guess that's inline+partial evaluation
13:52:49 <aristid> askhader: i have an idea for palindrome checking:
13:52:52 <aristid> > let l = "fofofo"; f = zip [0..] l; z = reverse f in all (\((_,a),(_,b)) -> a == b) $ takeWhile (\((a,_),(b,_)) -> b >= a) $ zip f z
13:52:53 <lambdabot>   False
13:52:53 <dafis> benmachine: thanks, looking at it right now
13:52:59 <aristid> > let l = "foof"; f = zip [0..] l; z = reverse f in all (\((_,a),(_,b)) -> a == b) $ takeWhile (\((a,_),(b,_)) -> b >= a) $ zip f z
13:53:00 <lambdabot>   True
13:53:18 <benmachine> Twey: example?
13:53:37 <benmachine> Twey: oh, the link on the page shows you the Prelude it uses, scanl just isn't in there
13:54:08 <Peaker> stepeval is pretty great.. wish I knew of it, I could use it to explain a lot!
13:54:09 <g_cross> askhader: Alternatively: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27961#a27961
13:54:17 <Twey> benmachine: Oh‚Ä¶ it doesn't use the real prelude?
13:54:22 <benmachine> Peaker: it's a pretty great idea that's pretty not finished :)
13:54:28 <benmachine> Twey: yeah, there's too much stuff it doesn't support yet
13:54:35 <Peaker> benmachine, iterate wasn't there so I wrote it in a "let" and it worked :)
13:54:41 <benmachine> yeah
13:54:44 <benmachine> you can usually do that
13:54:59 <g_cross> askhader: It requires working with Seq instead of lists, but it has the advantage that it lets you express the algorithm entirely in terms of guards, and also makes it easier to compare the first and last elements
13:55:01 <benmachine> it doesn't do functions with guards yet because I'm not sure how you'd show them
13:55:18 <askhader> g_cross: thanks!
13:55:48 <v0|d> fxr: chken >> chips
13:56:42 <ski> (hm .. notes g_cross indents the two closing brackets similarly to how i sometimes do)
13:57:27 <g_cross> Speaking of indentation, is there a standard notion for how to indent guards?
13:57:50 <g_cross> I use different styles depending on which looks best at the time
13:58:15 <g_cross> Usually I indent the guards by two spaces, but then I can't figure out a way to indent the "= ..." part in a consistent matter that looks nice
13:58:16 * ski might have used `putStrLn . \list -> ...' there, though .. hm
13:58:52 <g_cross> Ah, good point
13:59:11 <g_cross> ski: Yes, I actually like that style better
13:59:14 <olsner> g_cross: I think the general rule is to indent so it looks nice :)
13:59:16 <ski> g_cross : often i align the `=' on the same line .. otherwise i suppose i might align the `=' with the `|'
14:00:08 <benmachine> I just don't align them
14:00:13 <benmachine> I don't think they necessarily have to be
14:00:33 <ski> g_cross : assuming there was no `forM_', i'd often for small lists write :  (`mapM_` theList) $ \element -> ..element..'
14:00:43 <Saizan> i align the | within a clause
14:01:18 <Twey> I don't align the | with the =
14:01:19 <ski> (.. the style guide for OCaml suggests not aligning `->'s in `match' and `function')
14:01:37 <roconnor> libraries are stupid
14:01:42 <roconnor> all the good books are taken out
14:01:44 <Twey> I two-indent the | under the head and four-indent any do-blocks &c.
14:01:53 <Twey> roconnor: Reserve it
14:02:17 <monochrom> NoEnoughResourceException
14:02:20 <roconnor> Twey: ya, I'll get it in September
14:02:27 <Peaker> I don't understand why "do" and "\" are ok after infix operators but not after prefix functions
14:02:29 <Twey> roconnor: Wow, they have a long period
14:02:52 <Saizan> (now that i've to test my patched cabal-install no one comes with a double-installation-of-the-same-package problem?)
14:02:54 <Twey> Likewise
14:03:02 <ski> roconnor : yeah .. i've been trying to get a hold of the second volume of "Constructivism in Mathematics - An Introduction" by Troelstra and van Dalen for a while now .. still no luck :(
14:03:17 <roconnor> google has all the books scanned
14:03:24 <roconnor> and could send me them
14:03:26 <ski> (and for some reason the math lib doesn't seem to support reservations)
14:03:27 <roconnor> but noooo
14:03:33 <roconnor> the stupid law says no.
14:03:35 <Peaker> benmachine, can you add some colors? :)
14:03:37 <jmcarthur> i don't suppose there is a way to make is so that i can fork two threads which may each fork other threads themselves but are guaranteed to have roughly equal CPU time devoted to them, that is, including the times given to the child threads?
14:03:47 <benmachine> Peaker: uhm, low priority :)
14:04:07 <jmcarthur> or at least are treated "fairly" for some definition of it
14:04:26 <Peaker> jmcarthur, Hierarchic resource management is missing in all OS's I know of..
14:04:41 <benmachine> Peaker: if you know any simple ways to go AST -> coloured HTML, then I could probably do that
14:04:44 <jmcarthur> Peaker: i just mean in ghc/haskell, of course
14:04:56 <benmachine> but at the cost of *gasp* additional dependencies :O *gasp*
14:05:48 <Peaker> jmcarthur, maybe you can write a scheduler around forkIO to control their run-times
14:05:52 <jmcarthur> i was just thinking about implementations of unamb and it occurred to me that a race is really unfair if one thread ends up forking a ton of other threads and the other doesn't
14:05:55 <benmachine> > scanl f z [a,b,c]
14:05:56 <ski> (jmcarthur : for green threads only, then ?)
14:05:56 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
14:06:25 <dolio> roconnor: By the way, did you see all the Martin-Loef stuff linked to on the dependent-types reddit?
14:06:28 <Peaker> jmcarthur, or if one of them doesn't allocate?
14:06:36 <wli> There's some kind of resource management thing going on at IBM somewhere. I think CKRM. No idea how far along it is (or if some or all is already merged).
14:06:42 <jmcarthur> Peaker: that too, but i'm considering that to be a more rare case
14:06:58 <Peaker> wli, I think Linux is probably mostly a lost cause.. deep kmalloc calls are too prevalent
14:07:12 <ezyang> (sorry all, was away) 
14:07:28 <ezyang> It actually looks like this bit of evilness won't work. *the world has been saved!* 
14:07:34 <wli> Peaker: Sounds like you might have something else in mind.
14:07:36 <ski> dolio : hm, where ?
14:07:59 <jmcarthur> ski: i guess for green threads only. would still be nice to be able to utilize that m haskell threads on n os threads stuff :)
14:08:08 <dolio> ski: http://intuitionistic.wordpress.com/
14:08:28 <benmachine> Twey: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=fix+%24+scanl+(%2B)+0+.+(1+%3A) witness the power of inadequate sharing
14:08:36 <ski> (dolio : and the reddit ?)
14:08:53 <dolio> http://www.reddit.com/r/dependent_types/
14:09:23 <aristid> benmachine: wow that is the worst haskell interpreter i've ever seen :D
14:09:31 <jmcarthur> you mean the best
14:09:40 <ski> (ah, underscore, not hyphen was what foiled me ..)
14:09:59 <benmachine> aristid: oh? how many have you seen, then :P
14:10:12 <IceDane> !hoogle m a -> (a -> b) -> b
14:10:21 <benmachine> (for me that statement would be, "wow, that interpreter is worse than ghci.")
14:10:22 <aristid> benmachine: well, ghci.
14:10:26 <benmachine> :P
14:10:30 <IceDane> (How was I hoogled again?)
14:10:32 <aristid> benmachine: oh, and hugs. via codepad
14:10:34 <IceDane> (with the bot)
14:10:42 <benmachine> @hoogle IceDane
14:10:43 <lambdabot> No results found
14:10:49 <IceDane> benmachine: Sweet
14:10:50 <ski> dolio : ty
14:10:54 <IceDane> @hoogle m a -> (a -> b) -> b
14:10:55 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:10:55 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:10:55 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
14:11:02 <dolio> No prob, Bob.
14:11:02 <wli> Peaker: Could you explain the concern about deep kmalloc calls?
14:11:18 <ice_slice> Does anyone know of any website that goes through different programming languages and lists their strengths and weaknesses out? For instance, if I were trying to figure out what language would be best for a particular application I was designing.
14:11:32 <pchiusano> anyone know of any interesting applications for monadic functions like filterM, foldM ?
14:11:36 <ski> ezyang : possibly serious optimizations at work ! :)
14:11:49 <steveklabnik> ice_slice: the issue is that can be really subjectie
14:11:59 <ice_slice> I suppose.
14:12:04 <Saizan> > filterM (const [False,True]) [1,2,3]
14:12:05 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
14:12:10 <aristid> :t flip fmap
14:12:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
14:12:15 <dafis> > filterM (const [True,False]) [1,2,3]
14:12:16 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
14:12:31 <pchiusano> going to be explaining monads to my coworkers and realized that pretty much everything interesting you can do is one of the lifts, or traverse!
14:12:33 <aristid> :t ((.).(.)) extract (flip fmap)
14:12:34 <lambdabot> forall source a. (Extract source) => (Int, a) -> (a -> Int) -> source -> source
14:12:35 <Twey> benmachine: Haha, nice
14:12:43 <aristid> :t extract
14:12:44 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
14:12:44 <dolio> filterM isDirectory files
14:12:55 <ezyang> ski: In fact, that is precisely the problem :_0 
14:13:01 <aristid> does lambdabot have category-extras?
14:13:03 * ski grins
14:13:15 <jmcarthur> aristid: NO
14:13:17 <jmcarthur> :P
14:13:21 <IceDane> Bah, still rusty. Do I need a lift for basically chaining the result of readFile "something" into (length . unlines) ? don't I need something that's m a -> (a -> b) -> b ?
14:13:26 <ice_slice> Does anyone have an example of where I can see something like a simple ftp server or http server written in Haskell?
14:13:27 <aristid> jmcarthur: NO NEED TO SHOUT!!!!!!!!!
14:13:30 <pchiusano> dolio: good one
14:13:38 <wli> Peaker: Is this something to do with aio or interrupt model programming? Deep kmalloc calls sound like they could be an issue with that.
14:13:52 <dafis> IceDane: fmap/liftM
14:14:00 <aristid> IceDane: there's no general way to get a value out of a monad
14:14:03 <dolio> pchiusano: I'm certain I've used foldM, too, but I couldn't say for what off hand.
14:14:07 <monochrom> liftM (length . unlines) (readFile "something")
14:14:27 <IceDane> monochrom:   Couldn't match expected type `[Char]' against inferred type `Char'
14:14:30 <IceDane> Tried exactly that
14:14:45 <ClaudiusMaximus> :t unlines
14:14:46 <lambdabot> [String] -> String
14:14:46 <monochrom> oh, lines, not unlines
14:14:47 <dolio> length . lines
14:14:49 <pchiusano> the powerset use of filterM is cool, but I couldn't think of many other examples of its use
14:14:51 <IceDane> oooh
14:14:51 <IceDane> duh
14:14:54 <IceDane> fuck, silly me
14:14:59 <aristid> i wonder if it's possible to have a meaningful type that is both a monad and a comonad
14:15:00 <pchiusano> i like the directory filter though
14:15:33 <ski> @type (length . lines) `liftM` readFile "something"
14:15:34 <lambdabot> IO Int
14:16:07 <peaker_> wli, Just an issue I have with messy resource allocations -- I'd like resources to be given as arguments and be allocated very high up. In the kernel context, even allocated in user space and passed as arguments to the kernel
14:16:11 <dolio> pchiusano: Any time you write "foo (x:xs) acc = g x acc >>= foo xs", that's a foldM.
14:16:11 <benmachine> aristid: you mean, apart from Identity? I think infinite streams are
14:16:22 <peaker_> wli, I don't think a kernel should ever just allocate any resource "out of thin air"
14:16:26 <peaker_> (as kmalloc does)
14:16:44 <dolio> pchiusano: It's tail-recursion in a monad, more or less.
14:16:59 <pchiusano> dolio: yeah
14:17:08 <ice_slice> What are some examples of some applications I might have heard of that have been written in Haskell?
14:17:17 <ice_slice> I have never really heard of this Haskell being used in the real world.
14:17:47 <pchiusano> dolio: yeah, actually, lookup in a trie would be a good app for foldM
14:17:52 <pchiusano> monad is Maybe
14:18:03 <pchiusano> input list is the key
14:18:13 <aristid> benmachine: what does return do for infinite streams?
14:18:18 <wli> Peaker: Hmm. Not sure things make a whole lot of sense to hoist above the kernel/user boundary.
14:18:24 <benmachine> aristid: repeat
14:18:54 <peaker_> wli, Just pass resources once -- the kernel can keep them around and re-use them
14:18:58 <aristid> benmachine: and join?
14:19:13 <peaker_> wli, But resources should come from the top and trickle down, not be globally owned by the lowest layers and allocated by anyone at will
14:19:23 <dafis> aristid: head ?
14:19:25 <benmachine> aristid: you take the diagonal, I think
14:19:34 <jmcarthur> peaker_: i'm kind of with you there
14:19:36 <benmachine> :t map head . tails
14:19:37 <lambdabot> forall a. [a] -> [a]
14:19:41 <benmachine> hmm
14:19:46 <jmcarthur> as a general architectural strategy
14:19:59 <benmachine> oh yes silly me
14:20:00 <benmachine> erm
14:20:17 <peaker_> jmcarthur, yeah, then to fork threads you'd have to split your own cpu slice to give it to 2 threads instead of 1
14:20:29 <wli> Peaker: There are accounting issues, sleep/wait/etc. issues, and visibility issues. By and large kernel allocators are fairly involved subsystems in their own right.
14:20:32 <peaker_> jmcarthur, and your own memory allocator would have to be split into two smaller ones
14:20:38 <dafis> :t map head . zipWith drop [0 .. ]
14:20:39 <lambdabot> forall a. [[a]] -> [a]
14:20:50 <peaker_> wli, all the more reason to do it this way :)
14:20:53 <jmcarthur> peaker_: i do think it's not as simple as it sounds, though
14:21:08 <benmachine> dafis: that's more like it
14:21:09 <aristid> hmm
14:21:15 <aristid> interesting
14:21:16 <jmcarthur> peaker_: you would like L4 :)
14:21:23 <aristid> infinite streams are cool :)
14:21:42 <ski> aristid : also `(w ->)' and `(w,), given `Monoid w'
14:21:53 <wli> Peaker: Can't be done. Only the kernel rightly knows physical memory layout etc. to pick an as-of-yet unclaimed chunk of physical memory to hand over.
14:22:00 <aristid> ski: oh
14:22:05 <ski> (and `Reader w' and `Writer w', obviously)
14:22:21 <ezyang> Are implicit parameters isomorphic to the reader monad? 
14:22:39 <ski> aristid : note that `Stream' is basically `(Natural ->)', here
14:22:46 <peaker_> wli, "Can't be done" is a bit hasty
14:22:47 <jmcarthur> "similar" is a word i would probably choose over isomorphic
14:22:49 <aristid> ski: point taken
14:23:04 <Peaker> wli, You don't have to know the layout in order to pass a resource that represents it
14:23:14 <benmachine> ezyang: well, they're kinda isomorphic to explicit parameters, which are isomorphic to the Reader monad
14:23:21 <aristid> extract f = f empty
14:23:28 <Peaker> Passing some argument that represents authorization to allocate/use a resource
14:23:37 <jmcarthur> Peaker: you mean capabilities
14:23:56 <ezyang> benmachine: Fair enough :-) 
14:24:09 <benmachine> ezyang: "kinda" :P
14:24:43 <ezyang> I mean, in some ways, implicit parameters are superior to Reader because they are much more easily composable. 
14:25:05 <ezyang> Reader you end up with stuff like lift . lift . lift $ ask, or tagged transformers 
14:25:19 <jmcarthur> if you have lift.lift.lift you're doing something wrong ;)
14:25:22 <ski> ezyang *nod*
14:25:26 <wli> Resources can't be turned into anything real unless something does.
14:25:54 <benmachine> I always thought implicit parameters were just sort of moving things from the right hand side of => to the left
14:25:56 <aristid> ezyang: the sentiment here seems to _clearly_ favor implicit parameters over Reader
14:26:14 <ski> ezyang : named effects is much better than relying on your monad transformer not to be shadowed by any other in the stack ..
14:26:23 <benmachine> more than one way of writing the same thing = bad
14:26:30 <benmachine> (ish)
14:26:47 <ezyang> Although... I wonder if implicit parameters work ok with typeclasses... goes and checks 
14:26:56 <ski> ezyang : imo, an effect system for keeping track of various monad transformers (and when they commute) would be very good
14:27:03 <Peaker> jmcarthur, yeah
14:27:18 <ski> s/various/various named/
14:27:42 <cydergoth> ok, what's the best way to read one line from a string, and ( line, remainder ) in a lazy way?
14:27:46 <monochrom> asymmetric abuse of "=" ‚äÜ bad
14:27:56 <jmcarthur> Peaker: oh, that was supposed to be phrases as a question, not as a statement. i guess you got the point anyway
14:28:00 <jmcarthur> *phrased
14:28:15 <ski> benmachine : implicit parameters are, iiuc, a sort of (weak) side-effects
14:28:25 <hpc> :t head >>> tail
14:28:25 <lambdabot> forall a. [[a]] -> [a]
14:28:50 <aristid> :t tail . head
14:28:51 <lambdabot> forall a. [[a]] -> [a]
14:28:58 <jmcarthur> > head &&& tail <<< lines $ "foo\nbar\nbaz\n" ++ repeat 'a'
14:28:59 <lambdabot>   ("foo",["bar","baz","aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
14:29:00 <dafis> cydergoth: let (firstline, _:remainder) = break (== '\n') text
14:29:07 <ezyang> Aw, I can't do it with typeclasses :-( 
14:29:12 <cydergoth> dafis: kk thx
14:29:16 <hpc> right, &&& was what i was thinking of
14:29:17 <ezyang> (which makes sense, but is kind of disappointing) 
14:29:24 <hpc> :t (head &&& tail)
14:29:25 <lambdabot> forall c. [c] -> (c, [c])
14:29:44 <ski> > break (== '\n') "foo\nbar\nbaz\n"
14:29:45 <lambdabot>   ("foo","\nbar\nbaz\n")
14:29:47 <jmcarthur> of course if you will end up pattern matching on (,) you might as well just pattern match on (:)
14:30:31 <ski> (jmcarthur : heh, i wrote the same string as you, without having seen you wrote it)
14:31:30 * ski ponders ..
14:34:07 * ski . o O (  splitLine s0 = (s,s1) where s : unlines ('\n':s1) = unlines s0  )
14:36:15 <dafis> ski: your second unlines should be lines, methinks
14:36:37 <ski> (hrm, yes i just realized (i always forget which is which ..))
14:36:43 <ski> > let splitLine s0 = (s,s1) where s : (unlines -> s1) = lines s0 in splitLine "foo\nbar\nbaz\n"
14:36:44 <lambdabot>   ("foo","bar\nbaz\n")
14:36:45 <monochrom> lies
14:36:57 * monochrom unlies
14:37:08 <ski> (i can never remember which is which of `chr' and `ord', either ..)
14:37:25 <BMeph> I vote for more (well, any) use of comonads in code.
14:37:58 <monochrom> in adjunctions I keep forgetting which one is the lower one
14:38:09 <Peaker> I'm trying to parameterize my Transaction type on a "cap" phantom type which I want to use to indicate whether it's a read or write transaction. I want it to accumulate class constraints -- so I can (>>=) between a read and a write transaction.
14:38:11 <aristid> BMeph: then you should vote for comonads in lambdabot :)
14:38:16 <ski> "lower" vs. "upper" is bad naming
14:38:23 <Peaker> So I have my change primitives yield a transaction that requires a CapWrite constraint..
14:38:40 <ski> "left" vs. "right" is slightly better (but really not that much)
14:38:45 * BMeph looks for the Diebold machine...
14:38:48 <Peaker> But then, what's the type of: runReadOnlyTransaction? It can't demand a type-var has NO type-class constraint, I guess?
14:39:05 <monochrom> if not for exam pressure, I would mix up injection and surjection too
14:39:09 <ski> BMeph : Diebold uses comonads !?
14:39:53 * ski misses the aristid intermediate message
14:39:59 <monochrom> fortunately monic and epic are more depictive
14:40:10 <BMeph> ski: Of course! How else can they make sure that folks "vote the right way"? ;√æ
14:40:32 <aristid> ski: huh?
14:40:35 <ski> (is that a unicode smiley ?)
14:40:54 <monochrom> Welsh smiley or something
14:41:05 <aristid> these welsh and their weird smileys
14:41:13 <cydergoth> Can break take a windows CR/LF combo?
14:41:15 <mreh> Isn't that "Thorn"?
14:41:18 <mreh> old english
14:41:26 <BMeph> ski: Twey hooked me on it. (I think it's Norse - thorn, or something...)
14:41:31 <mreh> I win
14:41:36 <ski> also an icelandish letter
14:41:51 <monochrom> break can't take a windows CR/LF combo. however, I doubt that you need it.
14:41:54 <mreh> are you familiar with the viking invasion?
14:41:59 <dafis> :t break
14:42:00 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:42:02 <mreh> they exported it
14:42:05 <dafis> cydergoth: ^^
14:42:22 <cydergoth> dafis: so if I've read that correctly it takes a predicate?
14:42:24 <dafis> cydergoth: break can only break on a property of one char
14:42:35 <dafis> cydergoth: yes
14:42:40 <hpc> :t find
14:42:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:42:49 <cydergoth> Meh, I'll just pre-process to get rid of the stupidity
14:42:52 <dafis> cydergoth: but there's the split package on hackage
14:43:08 <monochrom> you won't see a CR/LF combo.
14:44:18 <dafis> monochrom: you sure?
14:44:55 <monochrom> 99% sure
14:45:09 <ski> cydergoth : if you read text files in text mode (default) any windows "CRLF" should be converted into a  '\n'  character, only
14:45:31 <ski> cydergoth : if you open in binary mode, you will see them, though
14:45:34 <cydergoth> ski: How about if I pull them over HTTP from a web server ;-)
14:45:37 <ski> (similarly with writing)
14:45:47 <hpc> HTTP is a text protocol
14:45:50 <monochrom> indeed from the haskell98 specification: "two characters of input, return and linefeed, may read as a single newline character"  In other words you won't see LF
14:45:59 <hpc> it should be sending \n
14:46:11 <benmachine> monochrom: isn't it CR that you don't see
14:46:19 <ski> benmachine : yes
14:46:27 <monochrom> oops, you won't see CR
14:46:47 <ski> @hoogle Binary
14:46:47 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
14:46:48 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
14:46:48 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
14:47:08 <c_wraith> I *always* get filter backwards.
14:47:21 <cydergoth> readFile is returning \r 
14:47:23 <c_wraith> I always think it should be "filter *out* things that match this predicate"
14:47:27 <mreh> because it is backwards
14:47:30 <int80_h> ski: glad to see you are still here. I've got Bare Bones Blog working and want to take it to next level. I'll formulate my task on hpaste presently.
14:47:33 <mreh> yah
14:47:48 <mreh> it should be "keep"
14:47:51 <dafis> cydergoth: are you on windows or *nix?
14:47:57 <cydergoth> Ubuntu ;-)
14:48:04 <ski> int80_h : heh, i really ought to go sleep, atm :)
14:48:15 <int80_h> you go sleep, we can talk later :)
14:48:23 <dafis> cydergoth: so you have to dos2unix first
14:48:26 <int80_h> this channel is filled with smart folks anyway :)
14:48:44 <ski> (int80_h : yeah, that's the problem .. re me going away :)
14:48:48 <cydergoth> dafis: Need to handle files that hasn't been done on 
14:48:50 <dafis> cydergoth: or filter (== '\r')
14:48:54 <monochrom> haskell98 says "may". GHC says "must" and also exposes an api for you to control it: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#25
14:49:11 <ski> (too much interesting discussion going on .. always when i shoudl sleep)
14:50:23 <cydergoth> dafis: Presumably I can do the filter lazily?
14:50:57 <cydergoth> dafis: if so that works for me ;-)
14:51:01 <dafis> cydergoth: it is automatically done lazily :)
14:51:47 <cydergoth> Neat, I think I have a functional GCode parser
14:52:42 <monochrom> 3 crimes of Microsoft Diskette Operating System: ctrl-z, crlf, \
14:53:06 <benmachine> monochrom: ctrl-z?
14:53:08 <cydergoth> monochrom: int80 too. Appologies to int80_h
14:53:24 <Peaker> chr 26 = eof?
14:53:35 <benmachine> > chr 26
14:53:36 <lambdabot>   '\SUB'
14:53:39 <monochrom> "ends" text files. perpetuates the myth that "there is a special char for end of file"
14:53:40 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27963#a27963
14:53:43 <Peaker> All the low interrupts used despite Intel reserving them for future use
14:53:44 <int80_h> and there we are
14:54:19 <dafis> monochrom: "The default NewlineMode  for a Handle  is nativeNewlineMode, which does no translation on Unix system"
14:54:34 <dafis> on linux, by default, \r isn't stripped
14:54:46 <monochrom> yes, I presumed windows
14:55:05 <monochrom> err, I presumed Microsoft Diskette Operating System
14:55:20 <cydergoth> Can anyone take a look at this : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27964#a27964 and let me know if I've committed any major style errors?
14:55:27 * hackagebot texmath 0.3 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.3 (JohnMacFarlane)
14:55:35 <int80_h> is my task clear?
14:56:03 <Peaker> Quick&Dirty OS renamed to Disk OS
14:56:07 <int80_h> I want to do on-the-fly file reading instead of storing file contents in a big string
14:56:19 <dafis> monochrom: don't always assume the worst possibility
14:56:34 <Peaker> Given that the BIOS did all the hard work, DOS was left to implement a file system and some trivial BIOS wrappers -- and even got those wrong
14:56:35 <Eduard_Munteanu> o/
14:56:39 <monochrom> no, I don't always, I just did it this time
14:57:04 <Trevion> int80_h: I think Haskell does on-the-fly reading by default if you do hGetContents
14:57:27 <Peaker> int80_h, You shouldn't use lazy I/O, it sucks. Use Iteratee or ListT or manually read chunks
14:58:45 <hpc> hGetContents is the way to go
14:59:02 <int80_h> hGetContents, gotcha. I go lok that up
14:59:14 <int80_h> @hoogle hGetContents
14:59:14 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
14:59:15 <lambdabot> System.IO hGetContents :: Handle -> IO String
14:59:15 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
14:59:17 <drhodes> cydergoth: I think you can put "return" in front of "case s of" and take out the two returns in the case block
14:59:23 <Tomsik> > let collatz n = takeWhile (> 1) (iterate (\m -> if m `mod` 2 == 0 then m `div` 2 else 3*m+1) n) in (flip genericIndex) 10^400000 $ map (genericLength . collatz) [1..]
14:59:26 <lambdabot>   163783932790551530886897640484806682703028421635756173781363280861826701194...
14:59:28 <Tomsik> somebody tell me what is going on
14:59:39 <cydergoth> So I did some native bindings with bindings-DSL - is that the preferred option? Lots of stuff on hackage seems to use it
14:59:43 <cydergoth> drhodes: Thx
15:00:04 <Tomsik> taking 10^400000th element I am comfortable with
15:00:11 <Tomsik> because of lazyness
15:00:23 <Tomsik> but that many iterations
15:00:28 <aristid> i made the most unreadable list-in-half-splitter ever:
15:00:32 <aristid> :t unzip . map (snd . fst &&& snd. snd) . takeWhile (uncurry ((<=) `on` fst)) . (zip <*> reverse) . zip [0..]
15:00:32 <Tomsik> in finite time
15:00:33 <lambdabot> forall b. [b] -> ([b], [b])
15:00:48 <cydergoth> drhodes: How would that work when I'm returning a composite in one branch and not the other?
15:00:59 <Trevion> int80_h: readFile uses hGetContents internally.
15:01:05 <monochrom> if you write "(f g) 10^40", I read it as "(f g 10) ^ 40"
15:01:18 <hpc> Tomsik: finite time is expected; you mean before universal heatdeath
15:01:30 <drhodes> cydergoth: I'll have to copy/paste it to  buffer and try it out
15:01:32 <Tomsik> haha, so it's about precedence?
15:01:39 <monochrom> always
15:01:48 <int80_h> Trevion, I want the entire file read. What I don't want is every file read at once and stored in the data record I mentioned in my hpaste
15:02:11 <int80_h> hGetContents will allow me to read records as they are called? I don't see how.
15:02:51 <cydergoth> Is there a quick way to export all the values of an Enum in a module () header?
15:03:20 <int80_h> was my hpaste read? should I re-post?
15:03:27 <monochrom> you have "data K = X|Y|Z"?  module Mine(K(..))
15:03:40 <Peaker> aristid, not that unreadable :)
15:03:41 <cydergoth> monochrom: Thx
15:03:55 <Peaker> aristid, I like reading points-free now
15:04:03 <cydergoth> monochrom: yes, that did it
15:04:07 <dafis> int80_h: readFile will only read stuff when it's demanded, but it's not always easy to control when the files are closed, so you may run out of file handles
15:04:37 <dafis> int80_h: I looked at the paste, but I don't really understand what you want
15:05:13 <aristid> Peaker: i really dislike the (snd . fst &&& snd . snd) part
15:05:33 <aristid> couldn't think of something better :/
15:05:39 * hackagebot texmath 0.3.0.1 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.3.0.1 (JohnMacFarlane)
15:06:24 <dafis> int80_h: entryContent :: IO String; and set entryContent = readFile filename on creation?
15:06:57 <Peaker> aristid, why do you do it this weird way?
15:07:12 <aristid> Peaker: hm?
15:07:16 <int80_h> dafis: right now I end up with a list of type Entry, where the all the blog posts are stored all at once. In C one can put a function inside a struct, and that function can be called when that struct is accesed. Can I make a function definition inside the data type I defined so that that function is called instead of a string being read, as it is now?
15:07:19 <Peaker> aristid, why not use length?
15:07:40 <Peaker> aristid, if it's meant to be unreadable, why do you dislike the &&& part? :)
15:08:01 <hpc> :t (snd . fst &&& snd . snd
15:08:02 <lambdabot> parse error (possibly incorrect indentation)
15:08:02 <int80_h> dafis : I'm not sure what you just asked me
15:08:06 <aristid> Peaker: it's meant to avoid length and be pointfree. unreadability was not really the goal
15:08:07 <hpc> :t (snd . fst &&& snd . snd)
15:08:08 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> (b, b1)
15:08:40 <aristid> Peaker: no real reason to avoid length, i guess.
15:09:00 <Peaker> aristid, I have another idea.. let me write it
15:09:18 <dafis> int80_h: at the moment, the blog entries are only read when they are accessed. If you have many, you'll get into trouble with the file handles.
15:10:13 <dafis> int80_h: make the IO-action that actually reads an entry a component of Entry and when needed, read
15:10:30 <int80_h> dafis : but they are read from a list stored in memory. Could end up being a really big list. Instead, I'd like to store a function in it's place that reads a particular file. This way I've only got one file in memory at once.
15:10:47 <dafis> int80_h: or perhaps Either String (IO String)
15:11:04 <int80_h> dafis : that's it that is what I want. "make the IO-action that actually reads an entry a component of Entry and when needed, read
15:11:16 <dafis> int80_h: laziness means you don't have all the file contents in memory at once
15:11:38 <int80_h> dafis : I want all the file contents. What I don't want is every file's contents.
15:11:49 <int80_h> dafis: just the one I'm interested in.
15:12:06 <benmachine> int80_h: it's not hard to write a strict readFile/hGetContents
15:12:17 <IceDane> Anyone happen to remember which book it was that taught you how to write an algebraic expression simplifier using mostly the haskell type system? Was it RWH? I can't seem to find it
15:12:35 <dafis> int80_h: that's what you get with lazy IO - at the cost of potential file handle leaks
15:12:38 <hpc> i think it was RWH
15:13:07 <int80_h> dafis : are their alternatives?
15:13:21 <Peaker> aristid, came out even worse :)
15:13:23 <Peaker> > map head . takeWhile (not . null) . iterate (drop 2) . (zipWith (const id) <*> concatMap (replicate 2)) $ "hello world"
15:13:24 <lambdabot>   "hello "
15:13:26 <dafis> int80_h: sure
15:13:44 <int80_h> Iteratee or ListT was mentioned?
15:13:50 <Peaker> int80_h, I mentioned
15:13:51 <aristid> Peaker: i want both halves
15:13:54 <int80_h> @hoogle Iteratee
15:13:54 <lambdabot> No results found
15:14:04 <int80_h> @hoogle ListT
15:14:04 <lambdabot> Control.Monad.List newtype ListT m a
15:14:04 <lambdabot> Control.Monad.List ListT :: m [a] -> ListT m a
15:14:04 <lambdabot> Language.Haskell.TH ListT :: Type
15:14:06 <Peaker> aristid, oh
15:14:15 <hpc> :t null
15:14:16 <lambdabot> forall a. [a] -> Bool
15:14:21 <aristid> :t unzip
15:14:22 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
15:14:24 <int80_h> Template Haskell!
15:14:39 <benmachine> yeah TH is not what you want :)
15:14:51 <benmachine> Iteratee does the job you want but it is quite difficult to understand
15:14:59 <benmachine> I recommend defining
15:15:06 <hpc> @quote th
15:15:06 <lambdabot> Tac-Tics says: Haskell makes programming safer by ensuring that the extent of your side effects is  proportional to the amount of work you do to circumvent the language's purity
15:15:16 <Peaker> Iteratee isn't hard to understand if you tell people what the proper names would be
15:15:17 <hpc> @quote template haskell
15:15:17 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
15:15:24 <aristid> >  takeWhile (not . null) . iterate (drop 2) . (zipWith (const id) <*> concatMap (replicate 2)) $ "hello world"
15:15:25 <lambdabot>   ["hheelllloo ","eelllloo ","lllloo ","lloo ","oo "," "]
15:15:30 <newsham> how can this be right?
15:15:32 <newsham> > map (genericLength . collatz) [1..] `genericIndex` 10^40
15:15:33 <lambdabot>   7000376965910699630056503868178506524997451776
15:15:35 <benmachine> hGetContents' h = (:) <$> hGetLine h <*> orNil (hGetContents h) where orNil = handle (\e -> pure [] `const` (e :: IOException))
15:15:44 <newsham> isnt that a pretty large result for genericLength?
15:15:53 <int80_h> benmachine : what do you mean by defining?
15:16:07 <benmachine> int80_h: putting in a file somewhere
15:16:10 <benmachine> oh
15:16:13 <newsham> > genericLength $ collatz 10^40
15:16:14 <lambdabot>   No instance for (GHC.Num.Num [GHC.Integer.Internals.Integer])
15:16:14 <lambdabot>    arising fr...
15:16:17 <dafis> > map (genericLength . collatz) [1..] `genericIndex` 10^4
15:16:18 <lambdabot>   38416
15:16:18 <aristid> :t collatz
15:16:19 <lambdabot> Integer -> [Integer]
15:16:22 <dafis> > map (genericLength . collatz) [1..] `genericIndex` 10
15:16:23 <lambdabot>   14
15:16:25 <aristid> > collatz 1
15:16:25 <benmachine> int80_h: sorry, put a colon after defining
15:16:26 <lambdabot>   []
15:16:27 <dafis> 14^4
15:16:28 <aristid> > collatz 2
15:16:29 <lambdabot>   [2]
15:16:29 <benmachine> then read my other message :)
15:16:32 <aristid> > collatz 3
15:16:33 <lambdabot>   [3,10,5,16,8,4,2]
15:16:35 <dafis> > 14^4
15:16:36 <lambdabot>   38416
15:16:41 <dafis> newsham: ^^
15:16:57 <int80_h> benmachine: putting in a file somewhere?
15:17:13 <int80_h> there's really no way to call a function on the fly?
15:17:19 <newsham> > map (genericLength . collatz) [1..] `genericIndex` (10^40)
15:17:20 <benmachine> int80_h: *blink*
15:17:22 <lambdabot>   mueval-core: Time limit exceeded
15:17:27 <newsham> ohh!!!!
15:17:41 <int80_h> I looked at iteratee, it looks like controls for file reading. Not exactly what I wanted.
15:17:58 <int80_h> I mean, reading one particular file
15:18:06 <benmachine> iteratee is a method of doing what lazy IO does without chewing all of your filehandles up
15:18:32 <int80_h> and lazy IO just reads a part of a file?
15:18:38 <benmachine> but if you're okay with keeping a whole file in memory, see my hGetContents' above (but fix the hGetContents in the recursive call to have a ')
15:18:38 <int80_h> am I correct?
15:18:48 <Tomsik> Prelude> let collatz_step n = if even n then n `div` 2 else 3*n+1
15:18:48 <Tomsik> Prelude> let collatz_steps n = if collatz_step n > 1 then 1 + (collatz_steps $ collatz_step n) else 0
15:18:52 <benmachine> int80_h: yeah, it reads the file as it is demanded
15:18:58 <BMeph> > collatz (-2)
15:18:59 <lambdabot>   []
15:19:09 <aristid> > map collatz [0..5]
15:19:10 <lambdabot>   [[],[],[2],[3,10,5,16,8,4,2],[4,2],[5,16,8,4,2]]
15:19:12 <Tomsik> whoops, not that channel
15:19:12 <int80_h> benmachine: this is where our confusing lies. That is not what I am trying to accomplish
15:19:15 <aristid> > map collatz [0..10]
15:19:16 <lambdabot>   [[],[],[2],[3,10,5,16,8,4,2],[4,2],[5,16,8,4,2],[6,3,10,5,16,8,4,2],[7,22,1...
15:19:29 <newsham>  ?let collatz n = takeWhile (> (1 :: Integer)) (iterate (\m -> if m `mod` 2 == 0 then m `div` 2 else 3*m+1) n)
15:19:47 <newsham> > map (genericLength.collatz) [1..]
15:19:48 <lambdabot>   [0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7,7,15,15,10,23,10,111,18,18...
15:19:54 <Tomsik> > let collatz_step n = if even n then n `div` 2 else 3*n+1 in let collatz_steps n = if collatz_step n > 1 then 1 + (collatz_steps $ collatz_step n) else 0 in collatz_steps (10^400)
15:19:55 <lambdabot>   7488
15:20:21 <dafis> int80_h: make the IO action that reads the file a part of Entry and execute it on demand
15:20:29 <benmachine> int80_h: then either explain again, or ignore me completely
15:20:35 <Tomsik> > genericIndex (10^400) collatz
15:20:36 <lambdabot>   No instance for (GHC.Real.Integral
15:20:36 <lambdabot>                     (GHC.Integer.Interna...
15:20:43 <dafis> int80_h: means of course, more or less everything has to be in IO
15:20:55 <Tomsik> > collatz (10^400)
15:20:56 <lambdabot>   [10000000000000000000000000000000000000000000000000000000000000000000000000...
15:21:10 <Tomsik> > length . collatz (10^400)
15:21:11 <lambdabot>   Couldn't match expected type `[a]'
15:21:11 <lambdabot>         against inferred type `GHC.Integ...
15:21:14 <Tomsik> ugh
15:21:19 <dafis> > collatz (2^400)
15:21:20 <lambdabot>   [25822498780869085896559191720030118743297057928292235128306593565406476220...
15:21:28 <int80_h> dafis : that's where I was leading, but I don't know what that would look like or how to use it
15:21:32 <dafis> > length $ collatz (2^400)
15:21:33 <lambdabot>   400
15:21:35 <newsham> > map (genericLength . collatz) [1..] `genericIndex` (10^8)
15:21:39 <lambdabot>   mueval-core: Time limit exceeded
15:21:42 <newsham> > map (genericLength . collatz) [1..] `genericIndex` (10^7)
15:21:43 <lambdabot>   114
15:21:53 <Tomsik> > let collatz_step n = if even n then n `div` 2 else 3*n+1 in let collatz_steps n = if collatz_step n > 1 then 1 + (collatz_steps $ collatz_step n) else 0 in collatz_steps (10^7)
15:21:54 <lambdabot>   144
15:22:07 <int80_h> dafis : I made an attempt but of course it blew up
15:22:09 <Tomsik> > map (genericLength . collatz) [1..] `genericIndex` (10^400)
15:22:13 <lambdabot>   mueval-core: Time limit exceeded
15:22:15 <Tomsik> ;)
15:22:21 <dafis> int80_h: we could perhaps give more help if we understood better what you actually want to do
15:22:24 <Tomsik> lists suck for that purpose
15:22:35 <int80_h> dafis : I think you have it
15:22:38 <newsham> tomsik: its not really a list if its not really a list
15:22:55 <Tomsik> yeah, but it dies at 10^7
15:22:58 <newsham> > genericLength $ collatz (10^7)
15:22:59 <lambdabot>   145
15:23:01 <newsham> > genericLength $ collatz (10^8)
15:23:02 <lambdabot>   107
15:23:05 <newsham> > genericLength $ collatz (10^9)
15:23:06 <lambdabot>   100
15:23:09 <Tomsik> well, 10^400 anyway
15:23:09 <newsham> > genericLength $ collatz (10^12)
15:23:10 <lambdabot>   146
15:23:15 <newsham> > genericLength $ collatz (10^20)
15:23:16 <lambdabot>   470
15:23:21 <newsham> > genericLength $ collatz (10^40)
15:23:22 <lambdabot>   694
15:23:36 <Tomsik>  > genericLength $ collatz (10^400)
15:23:47 <Tomsik> > genericLength $ collatz (10^400)
15:23:48 <lambdabot>   7489
15:23:51 <Tomsik> or it doesn't
15:24:02 <newsham> tomsik: it just pretends its a list :)
15:24:07 <Tomsik> Why am I always wrong
15:24:10 <int80_h> dafis : so as my hpaste says, I have a list of type Entry whose final record is one big String. I don't want that. I want there to be a function in it's place. Right now the string is accessed. I'd rather have a function accessed. That function would then read a particular file that that record represents.
15:24:15 <Tomsik> newsham: yeah, I know, I just thought it empirically blew up
15:24:22 <Tomsik> (I mean the mueval thing)
15:24:25 <dafis> int80_h: Okay, you have the list [Entry "Entry 1" ".." (readFile blogentry1), ... ], what do you want to do then?
15:25:32 <dafis> int80_h: data Entry = Entry { eTitle, eSlug :: String, eContents :: IO String }
15:26:17 <int80_h> dafis: well, a toy demonstrating how any given (readfile blogentry) might be accessed, and then stroed in a String. I'll figure out how to translate that to conform to the working code I have.
15:26:18 <newsham> tomsik: when mapping it over [1..10^400] it blows up
15:26:23 <newsham> because it has to count to 10^400 first
15:26:32 <Tomsik> yeah
15:26:33 <newsham> but that wasnt really necessary
15:26:46 <dafis> int80_h: data Entry = Entry { eTitle, eSlug :: String, eContents :: Either String (IO String) }
15:26:57 <Tomsik> 10^400 bottles of beer
15:27:17 <Tomsik> on the wall
15:27:19 <mtnviewmark> @hoogle (a -> Either String [b]) -> [a] -> Either String [b]
15:27:20 <lambdabot> No results found
15:27:51 <newsham> mapM?
15:27:58 <mtnviewmark> @hoogle (a -> Either String b) -> [a] -> Either String [b]
15:27:58 <lambdabot> No results found
15:28:00 <benmachine> it doesn't look quite like mapM to me
15:28:13 <benmachine> oh wait
15:28:14 <benmachine> yes it does
15:28:16 * benmachine silly
15:28:23 <benmachine> you need the right monad though
15:28:33 <dafis> int80_h: access entry@(Entry _ _ ec) = case ec of { Left content -> return entry; Right act -> do { content <- act; return (entry{eContents = Left content }) }
15:28:39 <dafis> }
15:28:39 <alex_kidd_> :t mapM
15:28:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:28:53 <newsham> (Either String) mapM and a [] concat
15:29:08 <mtnviewmark> :t  fmap concat $ mapM
15:29:09 <lambdabot>     Couldn't match expected type `[[a]]'
15:29:09 <lambdabot>            against inferred type `[a1] -> m [b]'
15:29:09 <lambdabot>     Probable cause: `mapM' is applied to too few arguments
15:29:13 <mtnviewmark> er 
15:29:16 <int80_h> dafis : thanks that looks more compicated than I am used to so I will need to study it. But I am trying to grow my knowledge so thanks :)
15:29:18 <benmachine> :t fmap concat . mapM
15:29:19 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
15:29:26 <mtnviewmark> right 
15:29:30 <benmachine> :t fmap fmap fmap concat . mapM
15:29:31 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
15:29:47 <mtnviewmark> but now -- sigh... it really have     a -> IO (Either String [b])
15:30:12 <mtnviewmark> and I need to map those over [a] and produce    IO (Either String [[b]])    or    IO (Either String [b])
15:30:13 <benmachine> :t (fmap . fmap . fmap) concat . mapM
15:30:14 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => (a1 -> m [[a]]) -> [a1] -> m [[a]]
15:30:25 <benmachine> oh wait hmm
15:30:54 <benmachine> :t (fmap fmap fmap concat . mapM =<<)
15:30:55 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => ([a1] -> a1 -> m [a]) -> [a1] -> m [a]
15:30:57 <newsham> ?type let jesus build your car = fix your car in jesus
15:30:58 <lambdabot> forall t t1 t2. t -> ((t1 -> t2) -> t1 -> t2) -> t1 -> t2
15:31:03 * benmachine explodes
15:31:16 <Astro> ?type f (a -> b) -> f (b -> c) -> a -> f c
15:31:17 <lambdabot> parse error on input `->'
15:31:30 <Astro> ?pl f (a -> b) -> f (b -> c) -> a -> f c
15:31:31 <lambdabot> (line 1, column 6):
15:31:31 <lambdabot> unexpected ">"
15:31:31 <lambdabot> expecting variable, "(", operator or ")"
15:31:49 <benmachine> Astro: what are you trying to do
15:31:57 <dafis> benmachine: maybe you should throw in a 'sequence' somewhere
15:32:13 <benmachine> dafis: the mapM's supposed to be doing the sequencing I think
15:32:15 <newsham> instead of trying to do complicated thing in single line, whynot do it slow and easy?
15:32:27 <benmachine> newsham: that's not in the #haskell spirit :P
15:32:40 <newsham> you can start slow-and-easy and gunk it up along the way
15:32:40 <Astro> benmachine: find the appropriate functions
15:32:46 <dafis> benmachine: for the outer monad, I think fmap sequence . mapM or something
15:32:54 <dafis> :t fmap sequence . mapM
15:32:55 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [[a]]
15:33:01 <zxvf> what is the right way to parse (min|mins|minute|minutes) with parsec?
15:33:07 <benmachine> Astro: try @hoogle
15:33:15 <Astro> @hoogle f (a -> b) -> f (b -> c) -> a -> f c
15:33:16 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
15:33:16 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
15:33:16 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
15:33:20 <benmachine> :t liftA2 (.)
15:33:21 <Astro> benmachine: thx
15:33:21 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
15:33:27 <dafis> :t liftM sequence . mapM
15:33:28 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [[a]]
15:33:34 <Tomsik> :t . . . . .
15:33:34 <benmachine> Astro: none of those are what you want but never mind :)
15:33:35 <lambdabot> parse error on input `.'
15:33:40 <newsham> zxvf: best would be to match "min" followed by optional "s" or ("ute" followed by optional "s")
15:33:40 <alex_kidd_> :t liftM
15:33:41 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:33:45 <Tomsik> :t (.) (.) (.) (.) (.) 
15:33:46 <BMeph> newsham: "That's what she said"... :)
15:33:46 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
15:33:48 <newsham> zxvf: to avoid too much backtracking
15:33:51 <Astro> benmachine: indeed, let's use hoogle in the browser...
15:34:03 <benmachine> Astro: I doubt there is a single function with that name
15:34:10 <Tomsik> :t (.) (.) (.) (.) (.) 
15:34:11 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
15:34:13 <Tomsik> really
15:34:16 <Tomsik> that
15:34:35 <Tomsik> ah, fmap
15:34:47 <benmachine> :t \f g x -> fmap ($ x) (liftA2 (.) g f)
15:34:48 <lambdabot> forall a b a1 (f :: * -> *). (Applicative f) => f (a -> a1) -> f (a1 -> b) -> a -> f b
15:34:50 <ezyang> Bah, no function for (a -> b -> m c) -> (m a) -> (m b) -> (m c) 
15:35:04 <dafis> :t (fmap sequence .) . mapM
15:35:04 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Functor f, Monad f) => (a1 -> f (m a)) -> [a1] -> f (m [a])
15:35:21 <dafis> benmachine: that the type?
15:35:38 <BMeph> :t (join.). liftM2
15:35:38 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
15:35:38 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
15:35:39 <lambdabot>     In the second argument of `(.)', namely `liftM2'
15:35:43 <benmachine> dafis: err, it wasn't me who was looking
15:35:44 <alex_kidd_> :t (sequence .) . mapM
15:35:45 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [[a]]
15:36:03 <BMeph> :t join. liftM2
15:36:04 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
15:36:05 <alex_kidd_> f should be the identity
15:36:16 <ezyang> :t join 
15:36:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:36:19 <BMeph> :t ((join.).). liftM2
15:36:20 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
15:36:20 <dafis> benmachine: right, 'twas mtnviewmark, wasn't it?
15:36:29 <ezyang> there we go :-) 
15:36:30 <zxvf> newsham: so something like: (string "min" >> optional (string "s")) <|> (string "minute" >> optional (string "s")) ?
15:36:38 <benmachine> dafis: yes
15:36:38 <ezyang> :info join 
15:36:54 <mtnviewmark> yes - now I'm confused -- are we trying to solve two complicated lifting/fmapping problems
15:36:56 <mtnviewmark> or just mine?
15:37:17 <benmachine> mtnviewmark: I was trying to solve yours
15:37:21 <mtnviewmark> got it
15:37:26 <mtnviewmark> okay - 
15:37:29 <ezyang> This is probably the first legit use of join I've seen in actual code :-) 
15:37:31 <dafis> mtnviewmark: which type did you want?
15:37:39 <newsham> string "min" >> (optional (string "s" <|> (string "ute" >> optional (string "s")))  ?
15:37:54 <mtnviewmark> I have a function   a -> IO (Either String [b])
15:38:02 <ezyang> I think join $ f <$> a <*> b is a smidge nicer, maybe. 
15:38:05 <newsham> should match:  "min", "mins", "minute" and "minutes"  if I didnt botch that (reading code left to right)
15:38:09 <mtnviewmark> I want to map that over   [a]   and end up with   IO (Either String [b])
15:38:14 <mtnviewmark> where the [b]'s were concat'd
15:38:18 <zxvf> newsham: alright. so there isn't a nicer way to write that?
15:38:21 <mtnviewmark> and any Left gives Left
15:38:25 <newsham> string "s" can be    char 's' I guess :)
15:38:40 <ezyang> Except... it doesn't look like it goes with phantom types :-( 
15:38:40 <mtnviewmark> (so I need the Monad instance of Either String --- which I can never remember which module it is in)
15:38:40 <newsham> zxvf: if you dont care about efficiency you can just use backtracking
15:38:57 <zxvf> newsham: how would that look?
15:39:04 <newsham> something like     try (string "min") <|> try (string "minute") <|> ...    ?
15:39:04 <dafis> :t  (fmap (fmap concat)) . (fmap sequence .) . mapM
15:39:05 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
15:39:17 <BMeph> mtnviewmark: You mean C.M.Error? ;)
15:39:32 <zxvf> newsham: I see. thanks
15:39:32 <dafis> :t  ((fmap (fmap concat)) . (fmap sequence .)) . mapM
15:39:33 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
15:39:55 <newsham> actually, sorry, I think if you're using "try" you need to do longest to shortest
15:40:07 <zxvf> right
15:40:13 <newsham> try (string "minutes") <|> try (string "minute") <|> try (strint "mins") <|> string "min"
15:40:16 <newsham> something like that
15:40:33 <mtnviewmark> BMeph - yup - that's the one
15:40:36 <newsham> when you use "try" and <|> together, you get true CFG alternation
15:40:43 <newsham> otherwise <|> isnt quite the same as CFG's alternation
15:41:04 <newsham> err.. I botched that again..   that happens only if they are longest to shortest I think
15:41:08 <newsham> but you get the general idea
15:41:16 <ezyang> Oh, nvm, I just messed up. 
15:42:00 <mtnviewmark> so all these solutions seem like they aren't obvious (since I'm not even sure we've come up with one that works - have we?)  -- perhaps I should just write it
15:42:06 <mtnviewmark> special cased...
15:42:10 <zxvf> newsham: thanks.
15:42:15 <newsham> np
15:42:42 <newsham> tar xzvf <...what here?...>
15:43:04 <benmachine> mtnviewmark: I think we got a one-liner that worked eventually
15:43:13 <benmachine> but sure, it's not a big deal
15:43:18 <mtnviewmark> heh
15:43:19 <benmachine> do-notation might make it simpler though
15:44:31 <dafis> :t  (fmap (fmap concat)) . (fmap sequence .) . mapM
15:44:32 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
15:44:37 <dafis> mtnviewmark: that?
15:45:20 <mtnviewmark> only - don't I have a double monad?   generically, my function is     (Monad f, Monad g) => a -> f g [b]
15:45:31 <mtnviewmark> f is IO and g is Either String
15:45:50 <dafis> mtnviewmark: you had IO (Either String [b])
15:45:53 <Axman6> f (g [b])*
15:45:55 <mtnviewmark> right
15:46:03 <Axman6> which is technically three monads
15:46:07 <mtnviewmark> whee!
15:46:18 <mtnviewmark> only I don't need to treat the list as a monad 
15:46:56 <dafis> so there's one more layer of fmap/sequence
15:47:39 <newsham> mntview: triple, IO, (Either String) and []
15:47:46 <dafis> :t  (fmap (fmap (fmap concat))) . fmap (fmap sequence) . (fmap sequence .) . mapM
15:47:47 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [[a]]) -> [a1] -> f [[a]]
15:48:33 <dafis> no
15:49:37 <newsham> a -> IO ((Either String) ([] b))
15:49:46 <newsham> a -> (IO . Either String . []) b
15:49:50 <dafis> :t  (fmap (fmap (fmap concat))) . (fmap sequence) . (sequence .) . mapM
15:49:51 <lambdabot> forall a a1. (a1 -> [[[a]]]) -> [a1] -> [[[a]]]
15:49:57 <dafis> Nooo
15:50:24 <dafis> :t  (fmap sequence) . (sequence .) . mapM
15:50:25 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [[a]]
15:50:52 <dafis> :t  (fmap sequence .) . (sequence .) . mapM
15:50:52 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> [m a]) -> [a1] -> [m [a]]
15:51:32 <dafis> :t  (fmap (fmap sequence) .) . (fmap sequence .) . mapM
15:51:33 <lambdabot> forall (m :: * -> *) a (f :: * -> *) (f1 :: * -> *) a1. (Monad m, Functor f, Functor f1, Monad f, Monad f1) => (a1 -> f1 (f (m a))) -> [a1] -> f1 (f (m [a]))
15:51:51 <mtnviewmark> wheeeeeee!
15:52:08 <benmachine> :t sequence
15:52:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:52:11 <benmachine> :t traverse
15:52:12 <lambdabot> Not in scope: `traverse'
15:52:17 <dafis> :t  (fmap (fmap (fmap concat))) . (fmap (fmap sequence) .) . (fmap sequence .) . mapM
15:52:18 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1. (Functor f, Functor f1, Monad f, Monad f1) => (a1 -> f1 (f [a])) -> [a1] -> f1 (f [a])
15:52:19 <benmachine> :t Data.Traversable.traverse
15:52:20 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:52:32 <benmachine> :t Data.Traversable.sequence
15:52:33 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
15:52:55 <newsham> ?hoogle (a -> m1 m2 a) -> m2 a -> m1 m2 a
15:52:55 <lambdabot> No results found
15:53:26 <dafis> :t  (fmap (fmap (fmap concat))) . (fmap (fmap sequence) .) . (fmap sequence .) . mapM
15:53:27 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1. (Functor f, Functor f1, Monad f, Monad f1) => (a1 -> f1 (f [a])) -> [a1] -> f1 (f [a])
15:53:47 <dafis> mtnviewmark: correct type, but holy shmoly, it's ugly
15:53:52 <Peaker> I described my Haskell design question in http://stackoverflow.com/questions/3314148/transaction-type-safety
15:54:02 <Peaker> It's a bit too long for IRC, but I can't find a nice way to do it :(
15:54:12 <benmachine> :t (fmap . fmap . fmap $ join) . (fmap (fmap sequence) .) . (fmap sequence .) . mapM
15:54:13 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1. (Functor f1, Functor f, Monad f, Monad f1) => (a1 -> f1 (f [a])) -> [a1] -> f1 (f [a])
15:54:13 <mtnviewmark> indeed - that is right, but actually - crazy ugly
15:54:48 * benmachine pokes at it to see if it can be simplified
15:54:54 <mtnviewmark> are their synonyms for fmap . fmap   and fmap . fmap . fmap?
15:55:01 <mtnviewmark> :t fmap . fmap
15:55:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:55:03 <benmachine> mtnviewmark: no but you can make some :)
15:55:17 <aristid> :t fmap fmap fmap
15:55:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:55:25 <mtnviewmark> then it would be something like    (fmap3 concat) . (fmap2 sequence) . (fmap sequence) . mapM
15:55:37 <danderson> As a library builder, should I provide type class instances for things like Serialize and Arbitrary?
15:56:00 <danderson> the upside I see is batteries included and no orphan instance warnings for the user, but as a downside it drags in more dependencies
15:56:10 <ddarius> danderson: If it doesn't require adding inconvenient dependencies, yes.
15:56:23 <benmachine> danderson: well, a possible alternative is making them available via a flag or in a separate package
15:56:31 <benmachine> foo-instances
15:56:32 <newsham> re fmap.fmap.fmap: http://conal.net/blog/posts/semantic-editor-combinators/
15:57:05 <danderson> hmm, I suppose. Thanks for the thoughts.
15:57:16 <conal> newsham: thanks for the plug.  i'm glad people are playing with SECs.
15:58:02 <newsham> :)
15:58:04 <benmachine> mtnviewmark: how's this
15:58:10 <benmachine> :t (fmap . fmap $ fmap (join . sequence) . sequence) . mapM
15:58:10 <lambdabot> forall a (f :: * -> *) a1 (m :: * -> *). (Functor m, Functor f, Monad f, Monad m) => (a1 -> m (f [a])) -> [a1] -> m (f [a])
15:58:22 <benmachine> still not hugely sexy but significantly simpler
15:58:31 <mtnviewmark> well - yes - nicer 
15:58:47 <mtnviewmark> I worry that future code readers will just be head scratching at that
15:58:50 <benmachine> heh
15:58:55 <benmachine> I think you're right
15:58:59 <aristid> :t (liftM . liftM $ liftM (join . sequence) . sequence) . mapM
15:59:00 <lambdabot> forall a (m :: * -> *) a1 (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> m1 (m [a])) -> [a1] -> m1 (m [a])
15:59:10 <benmachine> just mentionoing it as a demonstration that things could be made nicer
15:59:25 <mtnviewmark> so, while I'm enjoying this challenge (hope you are) --- I'm probably going to code a combinator just for this case
15:59:25 <benmachine> maybe they could be made nicer still
15:59:26 <benmachine> not sure
16:00:04 <benmachine> mtnviewmark: to be fair, if you gave the type signature explicitly, someone looking at the code could just go "oh, well it does that"
16:00:06 <dafis> mtnviewmark: I enjoyed it, and I congratulate you on the decision to write a special combinator
16:00:18 <mtnviewmark> heh
16:00:39 <benmachine> mtnviewmark: the code itself is unpleasant but there's really only one function you'd want with that signature, I think
16:00:49 <mtnviewmark> agreed
16:01:10 <mtnviewmark> where is that "given the signature infer the only possible non-trival function" thing?
16:01:25 <benmachine> oh, @djinn, but it doesn't do anything like this
16:01:46 <benmachine> @djinn Either Char Int -> Either Int Char
16:01:46 <dafis> djinn doesn't cope with lists
16:01:46 <lambdabot> Error: Undefined type Char
16:01:51 <benmachine> hmph
16:01:58 <benmachine> @djinn Either a b -> Either b a
16:01:59 <lambdabot> f a =
16:01:59 <lambdabot>     case a of
16:01:59 <lambdabot>     Left b -> Right b
16:01:59 <lambdabot>     Right c -> Left c
16:02:34 <dafis> @djinn [[a]] -> [a]
16:02:34 <lambdabot> Error: Undefined type []
16:02:59 <benmachine> dafis: const []
16:03:01 <benmachine> woooo
16:03:15 <newsham> ?type \g xs x -> do { ys <- g x; return (xs ++ ys) }
16:03:16 <lambdabot> forall t (m :: * -> *) m1. (Monad m, Monoid m1) => (t -> m m1) -> m1 -> t -> m m1
16:03:20 <newsham> is that right?
16:03:23 <dafis> benmachine: just illustrating djinn doesn't know about lists
16:03:32 <benmachine> oh right
16:03:39 <benmachine> yeah, because recursive type
16:03:47 <benmachine> or something.
16:04:03 <dafis> benmachine: yep
16:04:21 <benmachine> @djinn b -> (a -> b) -> Maybe a -> b
16:04:21 <lambdabot> f a b c =
16:04:21 <lambdabot>     case c of
16:04:21 <lambdabot>     Nothing -> a
16:04:21 <lambdabot>     Just d -> b d
16:05:04 <benmachine> @djinn b -> b -> Bool -> b
16:05:05 <lambdabot> f a b c =
16:05:05 <lambdabot>     case c of
16:05:05 <lambdabot>     False -> b
16:05:05 <lambdabot>     True -> a
16:05:13 <benmachine> it's clever!
16:05:45 <benmachine> @djinn Maybe a -> Bool
16:05:45 <lambdabot> f a =
16:05:45 <lambdabot>     case a of
16:05:45 <lambdabot>     Nothing -> False
16:05:46 <lambdabot>     Just _ -> True
16:05:49 <Tomsik> @djinn Either a b -> (a->c) -> (b->c) -> c
16:05:49 <lambdabot> f a b c =
16:05:49 <dafis> @djinn (Monad m1, Monad m2, Monad m3) => (a -> m1 (m2 (m3 b))) -> [a] -> m1 (m2 (m3 b))
16:05:49 <lambdabot>     case a of
16:05:49 <lambdabot>     Left d -> b d
16:05:51 <lambdabot>     Right e -> c e
16:05:53 <lambdabot> Error: Undefined type []
16:06:06 <IceDane> It is not possible to use if, then, else without all parts in haskell? E.g. without else?
16:06:14 <IceDane> I htink I just answered my own question
16:06:15 <benmachine> dafis: I don't think it's good at type classes, either
16:06:15 <IceDane> lol
16:06:18 <IceDane> It has to return something
16:06:22 <dafis> @djinn (Monad m1, Monad m2, Monad m3) => (a -> m1 (m2 (m3 b))) -> m3 a -> m1 (m2 (m3 b))
16:06:22 <lambdabot> -- f cannot be realized.
16:06:29 <benmachine> IceDane: indeed
16:06:37 <newsham> IceDane: for a pure function you need to have the same resutl type for all cases
16:06:52 <roconnor> IceDane: there is when and unless which are kinda like parital if statements
16:06:54 <newsham> for monadic stuff you can have code that runs only in one case or another since it can have side effects
16:06:54 <Saizan> ?type when
16:06:55 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:06:58 <newsham> like "when"
16:07:05 <aristid> ?type unless
16:07:05 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:07:07 <IceDane> Yeah, exactly
16:07:34 <IceDane> I just keep writing haskell in bursts, going back to something like C++, without touching haskell for a while then coming back, so I get rusty
16:07:38 <IceDane> It's annoying
16:07:39 <benmachine> when and unless are only partial because there's a sensible "not very much" you can put in the other branch
16:07:53 <newsham> IceDane: sounds like there's an obvious soln to that
16:08:08 <IceDane> newsham: Become a haskell purist?
16:08:10 <ddarius> newsham: Stop coming back.
16:08:23 <newsham> ok, several solns :)
16:09:04 <IceDane> I'll keep doing my dance. I just need to write something serious in haskell to get past that barrier that still, for some reason, makes me feel like haskell is 'hard'.. It's just lack of familiarity with the paradigm, I presume
16:09:22 <jmcarthur> i code in pretty much nothing but haskell, except at work
16:09:44 <newsham> why not find some program you like and hack on it?
16:10:12 <ddarius> newsham: Sensibility has no place in Haskell.
16:10:25 <newsham> fear does not exist in this dojo!
16:10:30 <Peaker> I am trying to add more type safety to my Haskell design, and it *is* hard
16:10:44 <Peaker> but most things were so much easier in Haskell that I strive for so much more type safety
16:10:48 <IceDane> newsham: Not sure if there's a program I like that's in haskell
16:10:54 <ddarius> Peaker: Switch to Agda and never look back.
16:10:58 <newsham> what kind of programs do you enjoy working with?
16:11:11 <IceDane> (That I've used)
16:11:18 <Peaker> ddarius, I'm pretty sure Haskell can do this...
16:11:21 <IceDane> newsham: I use what I need to use, obviously
16:11:23 <IceDane> At any rate
16:11:29 <eightbitman> hey all! i'm kinda new to programming in general and found this site through reddit.com, it's a pleasure to meet all of you
16:11:30 <IceDane> I have written an irc bot in haskell and I keep adding shit to it
16:11:33 <IceDane> so it's still an exercise
16:11:45 <newsham> what i mean is if you had a choice to write any type of program and get paid for it, what type of program would it be...
16:11:53 <benmachine> Peaker: lambdabot seems to think so, at least
16:12:01 <newsham> ie. network daemon, interactive grpahical thing, some kinda renderer, some kinda symbolic analysis engine, etc.
16:12:06 <Peaker> benmachine, what?
16:12:10 <IceDane> newsham: God. I cannot even find something to work on in my free time, so I'll never be able to answer that question
16:12:15 <IceDane> I jump from projects to projects
16:12:24 <benmachine> @faq can haskell do Peaker's thing?
16:12:24 <lambdabot> The answer is: Yes! Haskell can do that.
16:12:32 <Peaker> hehe
16:12:38 <newsham> then maybe you should just look around at haskell programs until you find one that you think is interesting
16:12:43 <eightbitman> @faq is this a question?
16:12:43 <lambdabot> The answer is: Yes! Haskell can do that.
16:12:44 <newsham> since it sounds like you have wide interests
16:12:51 <Peaker> benmachine, take a look at my Haskell question: http://stackoverflow.com/questions/3314148/transaction-type-safety :)
16:12:55 <IceDane> newsham: I cuold try that
16:13:05 <eightbitman> @faq can haskell teach me to love?
16:13:05 <lambdabot> The answer is: Yes! Haskell can do that.
16:13:09 <IceDane> I'll google some open source haskell programs
16:13:12 <eightbitman> wow. i'm sold
16:13:27 <IceDane> @faq Can haskell replace my fianc√©?
16:13:27 <lambdabot> The answer is: Yes! Haskell can do that.
16:13:32 <IceDane> Sweet.
16:13:35 <IceDane> You can move in on monday.
16:13:50 <newsham> icedane; if you're looking for some interesting problems, try googling for "icfp contest"
16:13:50 <eightbitman> tee hee
16:13:58 <newsham> though you prob wont find much example code
16:14:20 <IceDane> alright
16:14:26 <Peaker> ddarius, Do people use Agda for programming or just mucking around with proofs?
16:15:02 <newsham> icedane: how about this?  http://www.mutantlemon.com/omegagb/
16:15:09 <roconnor> Peaker: what do you mean by read-only?
16:15:28 <IceDane> newsham: Hehe, perhaps
16:15:55 <Peaker> roconnor, My transaction-specific semantics.. the primitive actions you build transactions from are basically lookup/insert/delete, the latter 2 are write and first is read-only
16:16:29 <roconnor> Peaker: it seems you should have class for read-only operations
16:16:33 <newsham> if you want smaller bite-sized project, write a small web server in haskell
16:16:35 <Peaker> roconnor, I have a convenience thing that builds a (Property lookup insert) that I would like to be able to use in both the read-only and writable transactions
16:16:47 <roconnor> Peaker: (ReadOnly m) => Transaction DB m (Widget ...)
16:16:58 <Peaker> roconnor, What about Property though?
16:17:14 <Peaker> roconnor, The existence of "set" in Property would mean it's not usable for the read-only part, even if only "get" is used, no?
16:17:20 <roconnor> I don't see how Property fits into the puzzle
16:17:58 <Peaker> roconnor, I don't really use lookup/insert/delete directly much. Mainly I have a bunch of Property values that I apply get/set to.  My read-only transactions only apply get, the write transactions also apply set (on the same property value)
16:18:11 <Peaker> roconnor, data Property m a = Property { get :: m a, set :: a -> m () }
16:18:24 <Peaker> roconnor, So I can use Property (Transaction t m) a   to build my transactions
16:19:09 <Peaker> roconnor, The nice thing about Property is that I can compose it with fclabel's:  Property a -> (a :-> b) -> Property b
16:19:44 <Peaker> roconnor, Anyway, since Property has "insert" in its "set" field, the "m" is forced to be a writer-transaction, so I cannot use it in a read-only transaction :-(
16:19:55 <roconnor> hmm
16:20:18 <Peaker> I guess maybe I need to have a Property class instead of a type, and then have a read-only property instance, and a writer property instance
16:21:29 <Peaker> roconnor, I'm still not clear about why Property is making it difficult to add a constraint to read only transactions?
16:21:50 <roconnor> I'm having difficulty imagining how you use Property
16:21:59 <Peaker> Above type should be:  Property m a -> (a :-> b) -> Property m b
16:22:09 <Tomsik> :->
16:22:22 <Tomsik> There's nothing like a happy face in your code to keep your moods up
16:22:37 <Tomsik> except maybe the monkeyface
16:22:48 <roconnor> Peaker: are your properties top level constants?
16:23:00 <Peaker> roconnor, something like:  treeRoot = someProperty ; modify (+1) (treeRoot `compose` value) ; makeWidget (treeRoot `compose` guiPart)
16:23:07 <Peaker> roconnor, Some of them
16:23:53 <Peaker> roconnor, If I have a Property (Transaction DB IO) (Ref a)  -- I can convert it to a Property (Transaction DB IO) a    ("Ref a" is basically a key in the DB with a phantom type that says how to deserialize it)
16:24:15 <Peaker> roconnor, so I can "dereference" a property that has a reference to another key in the DB, to get a new property that refers to a different place in the DB
16:24:38 <IceDane> How does one do reverse DNS lookup in haskell? Is it not built in?
16:24:53 <Peaker> IceDane, I think the relevant socket interfaces are all wrapped properly
16:25:31 <roconnor> Peaker: how would you feel about data Property m n a = Property { get :: m a, set :: a -> n () }
16:25:42 <IceDane> Peaker: Not sure what you mean. Implying that I should do it manually by connecting to port 53 on my dns server?
16:26:41 <roconnor> I admit it seems strange
16:27:22 <IceDane> Peaker: Never mind -- found it, thanks
16:27:26 <Peaker> roconnor, thought about it, maybe with a type alias: Prop m a = Property m m a  it would be sane
16:27:48 <roconnor> ya
16:28:04 <lispy> unfoldM_ :: Monad m => m (Maybe a) -> (a -> m b) -> m ()
16:28:04 <lispy> unfoldM_ ma f = ma >>= maybe (return ()) (\r -> f r >> unfoldM_ ma f) -- Does this already exist?
16:28:58 <roconnor> Peaker: anyhow, maybe someone smarter can come up with something
16:29:46 <Peaker> roconnor, Maybe with a GADT: data Transaction.Property m a where Write wcap => Property :: Transaction rcap m a -> Transaction wcap m a -> Transaction.Property m a
16:30:09 <Peaker> roconnor, The problem here seems to be Property indeed.. liberalizing it this way is possible, or making it a class
16:30:34 <Peaker> roconnor, I guess I'll try that tomorrow
16:30:36 <Peaker> Thanks!
16:30:38 <Peaker> night
16:30:50 <benmachine> lispy: a -> m a right?
16:31:16 <benmachine> lispy: the answer is still "not as far as I know" mind
16:31:23 <lispy> benmachine: it does type check, if that's what you mean
16:31:47 <benmachine> lispy: oh right, silly me
16:31:54 <lispy> benmachine:  you can generalize it though
16:31:59 <lispy> unfoldM :: Monad m => m (Maybe a) -> (a -> m b) -> m a
16:31:59 <lispy> unfoldM ma f a = ma >>= maybe (return a) (\f -> f r >>= unfoldM ma f)
16:32:18 <lispy> I'm trying to make it use MonadPlus instead of maybe
16:34:02 <benmachine> lispy: that definitely doesn't typecheck >_>
16:35:57 <lispy> :t fix $ \f g a -> g >>= maybe (return ()) (\r -> a r >> f g a)
16:35:58 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (Maybe a) -> (a -> m a1) -> m ()
16:36:33 <lispy> :t fix $ \u ma f a -> ma >>= maybe (return a) (\r -> f r >>= u ma f)
16:36:34 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => m (Maybe a1) -> (a1 -> m a) -> a -> m a
16:36:46 <lispy> benmachine: maybe I had a typo before
16:37:02 <FunctorSalad> > takeWhile (>0) . fmap length . iterate show ""
16:37:03 <lambdabot>   Couldn't match expected type `[a]'
16:37:03 <lambdabot>         against inferred type `GHC.Types...
16:37:18 <FunctorSalad> > takeWhile (>0) . fmap length . iterate show $ ""
16:37:19 <lambdabot>   []
16:37:26 <FunctorSalad> > takeWhile (>-1) . fmap length . iterate show $ ""
16:37:27 <lambdabot>   Not in scope: `>-'
16:37:34 <FunctorSalad> > takeWhile (>=0) . fmap length . iterate show $ ""
16:37:38 <lambdabot>   mueval-core: Time limit exceeded
16:37:42 <FunctorSalad> :(
16:38:04 <FunctorSalad> thought that's limit it to Int's range
16:38:07 <FunctorSalad> *that'd
16:38:36 <FunctorSalad> but if it's roughly 2^n it may wrap right back into the nonnegatives without touching a negative
16:39:11 <FunctorSalad> hmm wait... it'd still have to generate a 2^63 character string ;)
16:42:14 <FunctorSalad> I'd suggest a rewrite rule for "length . show $ thestring" if there was any non-example use for it ;)
16:42:33 <FunctorSalad> but that wouldn't save us here, it'd just save the allocation of a new string
16:42:48 <FunctorSalad> which doesn't happen anyway due to lazyness... nvm me
16:49:26 <BMeph>  
16:49:37 <BMeph> ...nvm
16:50:23 <Eduard_Munteanu> Mm, does Haskell grok UTF-8?
16:50:55 <Eduard_Munteanu> I'm considering writing Agda-like code.
16:52:48 <benmachine> Eduard_Munteanu: should do, yes
16:53:02 <benmachine> Eduard_Munteanu: see also: the UnicodeSyntax extension
16:53:04 <twanvl> > let (‚àà) = elem in 'x' ‚àà "xyz"
16:53:05 <lambdabot>   True
16:54:04 <lispy> oh, I can't write the type sig I want as a MonadPlus, because the outer monad has to be MonadPlus to support it stopping
16:54:27 <dons> The Haskell Platform 2010.2 is now live: http://hackage.haskell.org.nyud.net/platform/
16:54:37 <dons> upmods http://news.ycombinator.com/item?id=1539938
16:54:46 <Pseudonym> Woo!
16:54:49 <dons> more upmods http://www.reddit.com/r/programming/comments/cso3d/the_haskell_platform_2010200_now_live/
16:54:52 <Pseudonym> I think that's topic-worthy.
16:54:57 <dons> good idea!
16:54:59 --- mode: ChanServ set +o dons
16:55:05 <Eduard_Munteanu> benmachine, twanvl, nice thanks
16:55:14 <listofoptions> dmmit
16:55:23 <Eduard_Munteanu> I was just about to try, but I gotta set vim to use utf8 encryption.
16:55:25 <twanvl> this final design is a bit confusing, the logo looks like a button
16:55:27 <Eduard_Munteanu> Duh
16:55:29 <Eduard_Munteanu> Encoding.
16:55:42 <Pseudonym> twanvl: OTOH, it's usable as an icon.
16:55:52 <listofoptions> dons: i cant get it because of opendns's stupidity
16:56:09 --- topic: set to '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
16:56:17 <dons> listofoptions: try hackage.haskell.org/platform
16:56:19 --- mode: ChanServ set -o dons
16:56:25 <Eduard_Munteanu> I assume the Reddit storm went away by now, pfew.
16:56:38 <listofoptions> dons: it blocks hackage
16:56:44 <dons> bizarre
16:57:16 <listofoptions> dons: it also blocks deviant art
16:57:19 <Saizan> it does look like you're supposed to click on the haskell logo
16:58:34 <listofoptions> ok nvrmind
16:58:41 <listofoptions> it randomly unblocked it
17:01:03 <IceDane> Could I, say, import only the data type "Family" from Network.Socket? 
17:01:24 <zygoloid> it'd be nice if the Haskell Platform for Linux page made it clear which versions are 2010.2 and which are still 2010.1 (or in Gentoo's case, earlier?)
17:02:23 <dons> zygoloid: we'd  need to make the page a wiki, they change so often
17:03:13 <zygoloid> alas. the front page looks beautiful, by the way
17:03:31 <dons> great!
17:04:21 <aristid> i wish the average hackage package had more documentation
17:04:29 <Eduard_Munteanu> Um, is there Platform for Linux? I always emerged the individual stuff on Gentoo.
17:05:17 <FunctorSalad> 'paco cabal install' is fine too ;)
17:05:27 <FunctorSalad> if you just want to keep track of installed files
17:05:55 <FunctorSalad> (though the bulk of them are in predictable locations anyway if you haven't changed your cabal config)
17:08:20 <Phyx-> I got the sudden urge for a taco..
17:10:50 <dons> Eduard_Munteanu: the src installer
17:11:28 <Eduard_Munteanu> Is there any more standard UTF-8 keymap which contains math symbols, like forall etc.? mm_freak sent me his layout, but I'm wondering if I should go with a standard keymap.
17:12:17 <jgrimes> is there anyway to change GHC's RTS to preemptive  instead of cooperative
17:12:21 <Eduard_Munteanu> dons: you mean Gentoo bootstraps GHC from Platform?
17:12:35 <dons> well, gentoo will update soon
17:12:37 <Eduard_Munteanu> I can't tell, otherwise there is a Platform ebuild, but it's keyword masked.
17:12:40 <dons> need more upmods on ycombinator, http://news.ycombinator.com/item?id=1539938
17:15:17 <aristid> dons: obliged!
17:15:57 <dons> graci
17:16:24 <jgrimes> I like the new haskell platform page
17:17:28 <dolio> jgrimes: Are you talking about threading with forkIO? It's already preemptive.
17:18:48 <jgrimes> dolio: yes. really? If I don't specify any number of OS threads, it always waits for the first thread to finish
17:18:52 <Runar> What's the name of this monad: data F a = Left a | Right a
17:18:57 <dons> tell your friends the release is out. :)
17:19:24 <aristid> Runar: Either
17:19:35 <Runar> F a = Either a a
17:19:36 <aristid> oh wait
17:19:36 <IceDane> Does if not work inside a monad? E.g. do if something then etc.. 
17:19:40 <jgrimes> dolio: or if I have like 2 OS threads... the first two worker threads that I create always have to finish before the others run
17:19:40 <aristid> that's symmetric :D
17:19:45 <dolio> jgrimes: What's running? Threads can only be preempted if they do allocation, so if it's a really tight loop, it might just run.
17:19:55 <jgrimes> dolio: ahhh...
17:19:59 <jgrimes> dolio: that might be it then
17:20:09 <jgrimes> dolio: they are pretty tight loops
17:20:11 <aristid> Runar: it's not a monad in itself. you need an instance too, and i'm not sure how that instance would behave
17:20:27 <Runar> oh, functor then
17:20:40 <napping> also, unsafe foreign calls can tie things up
17:20:55 <Twey> Runar: data Either a b = Left a | Right b
17:21:09 <Twey> Runar: data Either a = Left a | Right a is isomorphic to a
17:21:18 <Twey> (well, (Bool, a))
17:21:29 <Runar> Yeah, Bool a
17:21:40 <Runar> Sorry, (Bool, a)
17:21:47 <Runar> So... Writer
17:21:56 <Twey> Runar: It's not necessarily a functor either without the instance ‚Äî it's just a datatype.
17:22:27 * hackagebot pretty-show 1.1.1 - Tools for working with derived Show instances.  http://hackage.haskell.org/package/pretty-show-1.1.1 (IavorDiatchki)
17:22:29 <Twey> (Either does have a functor and also a monad instance in the standard libraries, though)
17:22:37 <aristid> there's no default instance of Monoid for Bool!
17:22:38 <Runar> Twey: Yeah, but I'm assuming that Plato wrote me an instance already
17:22:49 <Tomsik> Isn't (Bool, a) kind of State
17:22:59 <Twey> To this, I respond ‚Äòwhat?‚Äô
17:23:03 <Runar> Bool -> (Bool a) would be State Bool a
17:23:10 <Runar> again with the commas
17:23:20 <Tomsik> oh right
17:23:26 <jgrimes> Is there any general way (like a generic function) that can take two data types and tell you if they are isomorphic?
17:23:30 <Twey> Oh, the idea of a datatype :√æ
17:23:48 <aristid> (Sum Bool, a) is a Writer i think
17:24:10 <hpc> @src (>>=) :: State a b
17:24:10 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:24:10 <Twey> jgrimes: I think not, by the halting problem
17:24:13 <Twey> jgrimes: But I could be wrong
17:24:15 <altmattr> jgrimes: I think yes - one of the generics libraries should do the job
17:24:21 <hpc> @src (>>=) :: b -> State a b
17:24:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:24:36 <Twey> But datatypes can be recursive
17:24:39 <altmattr> oh - types eh
17:24:39 <altmattr> not data elements ;;
17:24:44 <Twey> Yeah
17:24:48 <Twey> Heh
17:24:51 <benmachine> aristid: er, that'd been Any or All I think
17:24:55 <benmachine> *that'd be
17:25:01 <altmattr> then perhaps not
17:25:21 <aristid> benmachine: oh. hmm
17:25:23 <IceDane> How woudl I go about doing something like: do if someCondition then do oneMonad else return () ? Just like that?
17:25:33 <Tomsik> jgrimes: graph isomorphism is in NP I think
17:25:34 <hpc> @src when
17:25:34 <lambdabot> when p s = if p then s else return ()
17:25:49 <IceDane> aaah
17:25:51 <IceDane> beautiful
17:25:54 <jgrimes> Tomsik: ah, yeah. I guess this would be graph isomorphism
17:25:54 <benmachine> Tomsik: not an arbitrary graph though
17:25:57 <hpc> @src unless
17:25:57 <lambdabot> unless p s = if p then return () else s
17:26:01 <benmachine> er, hmm
17:26:08 <altmattr> Twey: but you don't calculate the recursion, expect with type parameters I suppose
17:26:09 <Tomsik> I guess it depends on what exactly is meant by "isomorphism"
17:26:15 <altmattr> but they all need to be in the lhs
17:26:32 <benmachine> Tomsik: whether there exist bijections a -> b and b -> a I think
17:26:37 <benmachine> er
17:26:40 <benmachine> a bijection a -> b
17:26:56 <benmachine> (and therefore one b -> a)
17:27:03 <Tomsik> well, if you get any countably infinite type then
17:27:14 <altmattr> oh - I was just thinking "are these types the same modulo the constructor names?"
17:27:14 <benmachine> then what? :P
17:27:22 <Tomsik> then they're isomorphic, d'oh
17:27:22 <jgrimes> altmattr: that is what I was thinking
17:27:35 <Tomsik> that bijection is too weak to be of any sense
17:27:41 <Tomsik> you need some constraint on that
17:27:53 <benmachine> Tomsik: not really, how many countably infinite types are there?
17:27:54 <Tomsik> otherwise what you're doing is basically to count
17:28:10 <Tomsik> benmachine: anything parametrized with Integer, for example
17:28:25 <benmachine> Tomsik: yes but most interesting types aren't :P
17:28:32 <jgrimes> basically I want to have something that looks at, say, all data types defined on hackage, and then can tell me which ones have matching constructors, modulo constructor names.
17:28:57 <jgrimes> I was thinking this should be possible
17:29:05 <benmachine> Tomsik: the interesting questions are things like, proving Maybe a is isomorphic to Either () a for all a
17:29:09 <benmachine> (which is easy)
17:29:10 <jgrimes> I just wanted to know if perhaps someone had such a function
17:29:27 <alex_kidd_> it would have to map a -> a to b -> b in a functorial way for one
17:29:31 <Tomsik> In this sense, you can check if type has finite number of instances
17:29:41 <Tomsik> count, check if the other has just the same
17:29:48 <Tomsik> or if both are infinite
17:30:03 <benmachine> Tomsik: the parametric bit is the interesting bit
17:30:05 <Tomsik> you need some property to be hold
17:30:20 <Eduard_Munteanu> Well that's easy, they both look the same. You can actually construct the isomorphism between them to show.
17:30:36 <Eduard_Munteanu> Nothing <-> Left ()
17:30:44 <Eduard_Munteanu> Just a <-> Right a
17:30:47 <benmachine> Tomsik: parametric types aren't countable as such, they're more functions
17:30:50 <FunctorSalad> . o O ( bijective => isomorphism in Hask? )
17:31:12 <benmachine> FunctorSalad: I asked this channel that once and got the answer "yes"
17:31:18 <benmachine> but that's second-hand knowledge I guess :)
17:31:25 <Tomsik> benmachine: isomorphism then depends on countability/uncountability of the parameter only :p
17:31:29 <BMeph>     ?  <-> Left _|_
17:31:31 <altmattr> jgrimes:  I don't understand any of this bijection stuff, but it seems to me you want something that is one level _up_ from what generics libraries give you
17:31:37 <FunctorSalad> benmachine: externally, probably, since every type is recursively enumerable I guess
17:31:38 <Tomsik> I don't think that's a right definition for isomorphic
17:31:43 <FunctorSalad> benmachine: internally I don't see any way
17:31:56 <altmattr> which is access to the structure of _data_.  Access to the syructure of _types_ is something I don't know how to do.
17:32:00 <FunctorSalad> Tomsik: isomorphism f :<=> exists g, f. g == id, g . f == id
17:32:12 <FunctorSalad> we need equality though, this isn't Eq
17:32:13 <BMeph>     ?  <-> Right _|_   -- More relevant...
17:32:16 <elzurk> what tool do you use to write haskell in Mac OSX?
17:32:27 <hpc> BMeph: you can't evaluate ()
17:32:28 <FunctorSalad> it's some metalevel observation-based equality
17:32:30 * hackagebot Unixutils 1.27 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.27 (JeremyShaw)
17:32:33 <benmachine> BMeph: well, you have to decide if you care about _|_ <_<
17:32:33 <hpc> laziness :D
17:32:36 <benmachine> hpc: can too
17:32:44 <benmachine> > case undefined of () -> "lol"
17:32:45 <lambdabot>   "*Exception: Prelude.undefined
17:33:04 <Tomsik> FunctorSalad: I don't feel it gives you any considerable amount of information about the two types then
17:33:10 <altmattr> elzurk: textmate and the haskell platform
17:33:11 <Eduard_Munteanu> BMeph: well I suppose you can map _|_ <-> _|_ when dealing with any two types
17:33:12 <Twey> benmachine: That's not evaluating ()
17:33:18 <Twey> It's evaluating _|_
17:33:29 <FunctorSalad> Tomsik: interesting point, many types are isomorphic in that way indeed
17:33:34 <aristid> in which module is the Monad instance for (m, a) again?
17:33:37 <benmachine> Twey: it's demonstrating that case x of () -> "blah" evaluates x
17:33:43 <Twey> aristid: Control.Monad.Instances
17:33:45 <BMeph> hpc: () Is simple. I think you meant _|_. However, thanks to the value tags, you can't evaluate (Right _|_), but you can tell it's supposed to be a Right value.
17:33:45 <aristid> Monoid m => (m, a) i mean
17:33:47 <Tomsik> like in groups, isomorphism has to hold that f(a * b) = f(a) * f(b)
17:33:57 <Eduard_Munteanu> @hoogle (,)
17:33:57 <lambdabot> Prelude undefined :: a
17:33:57 <lambdabot> Test.QuickCheck.Batch bottom :: a
17:33:57 <lambdabot> Data.Function fix :: (a -> a) -> a
17:34:00 <aristid> Twey: doesn't seem to work
17:34:03 <benmachine> Tomsik: yeah, category theory guys have their own idea
17:34:05 <Eduard_Munteanu> Meh.
17:34:24 <Twey> Wait
17:34:32 <Twey> I don't think it's a monad
17:34:34 <FunctorSalad> Tomsik: for isomorphy in the renamed-constructor-type senes, maybe we should require that the isomorphism respects constructors in the way you just said
17:34:35 <elzurk> do you guys use an IDE, vim, emacs, texedit? to write your haskell code in MacOSX?
17:34:38 <hpc> BMeph: i see what benmachine meant; _|_ throws a wrench in everything...
17:34:47 <FunctorSalad> for that to make sense it would have to specify a mapping of constructors
17:34:49 <Twey> elzurk: emacs.  Always emacs.
17:34:58 <FunctorSalad> s/senes/sense/
17:34:58 <aristid> Twey: but it is? it's like Writer without the newtype
17:35:01 * Twey looks vaguely confused.
17:35:04 <benmachine> elzurk: by which Twey means vim, of course
17:35:05 <hpc> you shouldn't ever need to evalutae () would be a better way of saying it
17:35:06 <Eduard_Munteanu> elzurk: I'm a vim-head, but I don't use Mac
17:35:08 <BMeph> "Obviously", though, _|_ <-> _|_ ..."and vice-versa" ;)
17:35:27 <Tomsik> FunctorSalad: it seems reasonable to me, I'm thinking whether it's not too strong though 
17:35:42 * Phyx- thinks implementing features is easy. Getting them rock solidly stable is proving to be harder than expected...
17:35:49 <BMeph> hpc: Yes, (_|_) poops on all of our careful plans... ;)
17:36:08 <Tomsik> All you guys think are bottoms.
17:36:11 <hpc> BMeph: that's why they call it bottom
17:36:13 <Tomsik> about*
17:36:19 <hpc> argh joke ninja
17:36:25 <FunctorSalad> a 'ADT homomorphism' (my term) from T to S would be like: a mapping F of ctors of T to those of S, and a function f such that f (CTOR x1 ... xn) = (F CTOR) (f x1) .... (f xn) -- Tomsik 
17:36:27 <benmachine> heh
17:36:30 <FunctorSalad> yes, it seems pretty strong
17:36:31 <benmachine> bottom puns never get old.
17:36:39 <FunctorSalad> but we wanted that?
17:36:48 <elzurk> Twey I just moved to OSX, which version of emacs do you run?
17:36:53 <FunctorSalad> it'd capture 'merely renamed types' and a bit more
17:36:57 <benmachine> FunctorSalad: what does = mean there?
17:36:59 <Tomsik> Well, it makes sense in case of Maybe a vs Either () a
17:37:12 <Tomsik> bit more?
17:37:15 <FunctorSalad> benmachine: some sort of external equality, not a haskell function
17:37:33 <BMeph> benmachine: Rather, puns about bottom never terminate! :D
17:37:42 <benmachine> BMeph: :P
17:37:44 <altmattr> elzurk: if you are rusted on to vim or emacs - just get them, everyone else I know uses texmate
17:37:44 <Tomsik> I think it kind of dies on types like data X = A | B, data Y = C | D
17:37:45 <FunctorSalad> (e.g. observational equality or how it's called )
17:37:49 <Eduard_Munteanu> FunctorSalad: um that looks like a Cat -> Cat functor that's bijective.
17:38:13 <benmachine> mew
17:38:20 <Tomsik> because there is more than one isomorphism
17:38:21 <ethicszen> dons, poke.
17:38:32 <hpc> benmachine: Œº
17:38:37 <FunctorSalad> Tomsik: it would capture 'embeddings' (e.g. Identity a -> Either a b) too
17:38:40 <FunctorSalad> (@ a bit more)
17:38:41 <benmachine> hpc: :)
17:38:42 <Eduard_Munteanu> You take constructors as functors (arrows in Cat).
17:38:59 <FunctorSalad> and "quotients" like the other direction Either a b -> Identity a
17:39:12 <altmattr> jgrimes: you opened up a can of isomorphic worms there mate :)
17:39:13 <Tomsik> :t Identity
17:39:14 <lambdabot> forall a. a -> Identity a
17:39:22 <jgrimes> altmattr: yeah, haha. 
17:39:22 <hpc> @unmtl Identity a
17:39:22 <lambdabot> a
17:39:24 <Tomsik> How is  that isomorphic to Either a b
17:39:24 <FunctorSalad> Eduard_Munteanu: the cat was supposed to be Hask, maybe you see some analogy I didn't see
17:39:28 <benmachine> FunctorSalad: but the only isomorphisms would be renamings?
17:39:39 <FunctorSalad> Tomsik: it isn't, I was trying to define ADT homomorphisms
17:39:47 <Tomsik> ah, homomorphisms
17:39:51 <Eduard_Munteanu> FunctorSalad: well, yes, Hask here.
17:39:51 <FunctorSalad> isos would be invertible homos as always
17:40:06 <FunctorSalad> benmachine: hmm looks like it
17:40:13 <Veinor> okay, I come into this channel and I see
17:40:15 <Tomsik> invertible homos, that's politically incorrect I guess
17:40:15 <Veinor> 20:39:25     <FunctorSalad> isos would be invertible homos as always
17:40:31 <Eduard_Munteanu> Yeah, I see epis, monos, but no homos.
17:40:48 <hpc> this sounds like the start of a bad joke
17:40:54 <Tomsik> but it's tree isomorphism then isn't it
17:41:05 <Tomsik> err.. homomorphism
17:41:05 <FunctorSalad> I wasn't trying to be funny
17:41:12 <FunctorSalad> 'homo' is the best abbreviation
17:41:29 <FunctorSalad> 'hom' is already used for sets of *all* homos
17:41:30 <Eduard_Munteanu> (except people won't use it)
17:41:43 <BMeph> hpc: No, no. All the bottom stuff was the start of bad jokes. This is the end...wait-a-minute!
17:41:46 <FunctorSalad> 'homom' is awkward to pronounce
17:41:51 <Eduard_Munteanu> Yeah, Hom(Foo, Bar) caught.
17:42:02 <Twey> Haha.
17:42:08 <FunctorSalad> caught?
17:42:19 <IceDane> If dealing with somewhat low level networking functions such as inet_addr and so on to do reverse dns lookup, is the only way to handle the fact that not all IP addresses have host entries to implement exception handling?
17:42:20 <FunctorSalad> and 'ho' is... nvm
17:42:22 <Eduard_Munteanu> I mean people use it very often.
17:42:30 <FunctorSalad> :)
17:42:30 <IceDane> There is no really cool pure way to do this?
17:42:36 <Twey> I see nothing wrong with homo, iso, cata, hylo, &c.
17:43:00 <Pseudonym> I tend to just use "morphism", though.  I reserve "homomorphism" for when I'm _not_ talking about category theory.
17:43:01 <benmachine> :t try
17:43:01 <lambdabot> Not in scope: `try'
17:43:09 <benmachine> :t Control.Exception.try
17:43:10 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
17:43:14 <Twey> IceDane: I think when dealing with low-level networking functions you've drifted well off the path of ‚Äòcool and pure‚Äô anyway :√æ
17:43:14 <Eduard_Munteanu> Well yeah, but when you start mixing homos, bottoms and _|_ it tends to get out of hand.
17:43:18 <BMeph> Twey: Nice to know you're not "homo-phobic"...well, you know.... :)
17:43:21 <IceDane> Twey: Well, true
17:43:26 <benmachine> IceDane: that kind of magically makes an exception-throwing function into a pure-ish one
17:43:30 <IceDane> But I was referring to reverse dns lookup as whole
17:43:32 * Pseudonym is isophobic
17:43:34 <IceDane> benmachine: I see
17:43:36 <IceDane> I'l ltry it out
17:43:37 <IceDane> Thanks
17:43:41 <FunctorSalad> Twey: ah good point, cutting off the 'morphism' suffix is standard
17:43:41 <Twey> Ho ho ho
17:43:59 <IceDane> (By the way, IO is fucking ugly)
17:44:07 <FunctorSalad> so it is 'homo' even when I'm talking with a straight face ;)
17:44:09 <benmachine> IO is delightful
17:44:15 <Twey> It's okay, but I'd rather it were transparent
17:44:18 <IceDane> I like pure haskell :P
17:44:22 <Twey> That would allow so many cool things
17:44:23 <IceDane> that's what I love about it
17:44:24 <BMeph> IceDane: That's why Haskell puts a bag over it! ;√æ
17:44:28 <Pseudonym> IceDane: I agree.  It's just that every other imperative language is even uglier.
17:44:30 <Twey> IceDane: IO is pure ‚Äî that's why it's delightful :√æ
17:44:34 <FunctorSalad> Pseudonym: 'morphism' is hard to abbreviate too
17:44:36 <benmachine> IceDane: oh sure, but that's just like comparing a ¬£20 note with a debit card
17:44:49 <IceDane> Twey: Meh
17:44:54 <IceDane> You guys know more about it than I do
17:44:55 <Pseudonym> "Morph" gives me flashbacks to the Aardman bits on the old Tony Hart shows.
17:44:57 * Pseudonym is old
17:44:58 <FunctorSalad> 'mo' maybe
17:45:12 <FunctorSalad> 'morph' triggers too many other symbols
17:45:16 <Eduard_Munteanu> Mofo?
17:45:22 <FunctorSalad> 'to morph', 'morphine' etc ;)
17:45:22 <IceDane> All I know is that when I have to deal with IO and its .. volatility, haskell gets uglier
17:45:34 <Twey> Haha, now we've got homomofos?
17:45:38 <IceDane> lol.
17:45:42 <benmachine> IceDane: the real world is just messy, unfortunately
17:45:47 <IceDane> benmachine: guess it is
17:45:52 <Twey> IceDane: There are generally neater ways
17:45:58 <hpc> IO isn't so bad; it's referentially transparent, more or less
17:45:59 <Twey> IceDane: We're working on finding them
17:46:15 <Twey> IceDane: See things like Eros, Iteratee
17:46:27 <Twey> The problem is that IO covers an awful lot of problem domains.
17:46:35 <Twey> They need to be abstracted separately.
17:46:37 <BMeph> A big issue with it is that there are too many discernably different actions classified as "IO". The granules are too coarse. :(
17:46:38 <Eduard_Munteanu> Now what was that iso we were talking about?
17:46:41 <IceDane> hpc: Don't try to woo me with your computer science lingo. I understand none of it =(
17:46:43 <FunctorSalad> Pseudonym: btw I'm not using the 'h' word for general categories either, but what I had just defined looks very much like other 'homomorphism's
17:46:44 <Twey> BMeph: ‚Åµ
17:47:02 <benmachine> hpc: more or less.
17:47:16 * BMeph accepts Twey's "high five"...
17:48:07 <Eduard_Munteanu> Hah, that 5's so small.
17:48:24 <BMeph> We need a time-based Monad! :)
17:48:51 <hpc> class FluxCapacitor a where
17:49:06 <hpc> magnitude :: JiggaWatts
17:49:19 <altmattr> DjiggaWatts
17:50:05 <hpc> accelerate a = case a of 88 -> crazy >> paradox; otherwise -> sequel
17:50:28 <aristid> @pl \a b -> fmap a . b
17:50:28 <lambdabot> (.) . fmap
17:50:56 <hpc> (>>) >>= (<<)
17:51:02 <hpc> :t (>>) >>= (<<)
17:51:03 <lambdabot> Not in scope: `<<'
17:51:10 <aristid> wtf
17:51:13 <hpc> :t (>>) >>= (flip (>>))
17:51:14 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
17:51:14 <lambdabot>     Probable cause: `>>' is applied to too few arguments
17:51:14 <lambdabot>     In the first argument of `flip', namely `(>>)'
17:51:18 <aristid> @let (<<) = flip (>>)
17:51:20 <lambdabot>  Defined.
17:51:26 <aristid> hpc: there it is now.
17:51:30 <hpc> :t (>>) >>= (<<)
17:51:31 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
17:51:31 <lambdabot>     Probable cause: `<<' is applied to too many arguments
17:51:31 <lambdabot>     In the second argument of `(>>=)', namely `(<<)'
17:51:32 <aristid> :t (<*)
17:51:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:51:37 <hpc> :t (>>) >>= (>>)
17:51:38 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
17:51:38 <lambdabot>     Probable cause: `>>' is applied to too many arguments
17:51:38 <lambdabot>     In the second argument of `(>>=)', namely `(>>)'
17:51:47 <hpc> :t ((>>) >>=)
17:51:48 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => ((m b -> m b) -> m a -> b1) -> m a -> b1
17:51:52 <hpc> yay
17:52:07 <hpc> what a crazy type
17:52:12 <Tomsik> :t ((>>=) >>=)
17:52:13 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => (((a -> m b) -> m b) -> m a -> b1) -> m a -> b1
17:52:25 <Tomsik> yo dawg I herd you liek bind so i put bind in yo bind
17:52:40 <aristid> :t join join
17:52:40 <lambdabot>     Occurs check: cannot construct the infinite type:
17:52:40 <lambdabot>       m = (->) (m (m a))
17:52:40 <lambdabot>     Probable cause: `join' is applied to too few arguments
17:52:46 <hpc> :t (((>>=) >>=) >>=)
17:52:47 <lambdabot> forall (m :: * -> *) a b b1 b2. (Monad m) => ((m a -> b1) -> (((a -> m b) -> m b) -> m a -> b1) -> b2) -> (((a -> m b) -> m b) -> m a -> b1) -> b2
17:52:51 <aristid> :t join . join
17:52:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
17:53:12 <aristid> :t join . duplicate
17:53:13 <lambdabot> Not in scope: `duplicate'
17:53:24 <hpc> :t fix (. join)
17:53:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
17:53:25 <lambdabot>       Expected type: m a
17:53:25 <lambdabot>       Inferred type: m (m a)
17:53:51 <aristid> :t (. join)
17:53:52 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (m a -> b) -> m (m a) -> b
17:53:58 <Eduard_Munteanu> I suppose you can't @let classes.
17:54:07 <Eduard_Munteanu> for e.g. duplicate
17:54:28 <hpc> :t join . fix
17:54:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m (m a) -> m (m a)) -> m a
17:54:30 <FunctorSalad> Twey / BMeph : is there  a practical alternative?
17:54:56 <Twey> FunctorSalad: For?
17:54:57 <BMeph> FunctorSalad: ...not yet. :)
17:54:58 <Twey> IO?
17:54:59 <FunctorSalad> 'phantom type parameter keeping track of effects would be one approach'
17:55:05 <Twey> Oh
17:55:12 <aristid> Eduard_Munteanu: we need category-extras for duplicate
17:55:14 <FunctorSalad> for decomposing IO
17:55:26 <Eduard_Munteanu> Yeah, I know it's there.
17:55:31 <FunctorSalad> and the single quote there is obviously in the wrong place
17:55:38 <Twey> No, it needs to be broken down
17:56:37 <Twey> There's Disciple too, though I'm not sure if it really decomposes
17:56:51 <FunctorSalad> (you'd program, say, sets, on the type level, and have the phantom param be the set of used side effects, at the easiest level)
17:57:52 <BMeph> FunctorSalad: I think the ACIO efforts are worth more study. I like Plan 9's "everything is a file" for some things, but it seems awkward for graphics.
17:58:06 <Twey> http://trac.haskell.org/ddc/wiki/Language/Overview/EffectSystem
17:58:09 <FunctorSalad> readFile :: Cons FileReading a a' => String -> (String -> IO2 a b) -> IO2 a' b
17:58:13 <FunctorSalad> along those lines
17:58:29 <FunctorSalad> which is just a bind and a lift put together for convenience I guess
17:58:41 <Twey> I guess it does decompose
17:58:48 <Pseudonym> BMeph: I think the QNX "everything is message passing" makes more sense.
17:59:28 <FunctorSalad> BMeph: you mention plan9/files as a zoology of effects to put in the type?
17:59:35 <BMeph> Pseudonym: Then everyone argues about what "is" a message, and how is it passed, and...<sighs>
17:59:42 <FunctorSalad> (the type says which files it uses)
18:00:12 <BMeph> FunctorSalad: Ooh, "File Classes"! :)
18:00:25 <FunctorSalad> that wasn't your point? ;)
18:00:29 <FunctorSalad> (what then?)
18:03:50 <BMeph> FunctorSalad: That seems almost more like "the file says which types it uses" than "the type says which files it uses"...it has an appeal in how certain forms of filetypes have uses on "non-file" values.
18:05:20 <eightbitman> noob question: as a new programmer is this gonna be something I'm gonna have to bang my head against until it just "clicks"? cause I'm not really feeling this language at all
18:05:23 <BMeph> Maybe "we" just need to decide what info does the type system contain, what does it not contain, and what's a good organizational basis for the division.
18:06:33 <IceDane> What is the difference between Control.OldException and Control.Exception (Except that one is old, heh)
18:06:44 <IceDane> Because my code(which is based on something else) uses oldexception already
18:07:13 <aristid> :t [extract,join] -- would work if lambdabot had it
18:07:14 <lambdabot>     Couldn't match expected type `Int' against inferred type `(Int, a)'
18:07:14 <lambdabot>       Expected type: (Int, Int)
18:07:14 <lambdabot>       Inferred type: (Int, (Int, a))
18:07:18 <BMeph> eightbitman: Maybe you haven't found the right spot to bang on yet...we're rather fresh-eyes friendly here, so feel free to ask about particulars about it. :)
18:07:36 <dafis> IceDane: in OldException, Exception was a type, now it's a class
18:07:41 <IceDane> I see
18:08:10 <BMeph> aristid: Had 'extract'? Or...
18:08:23 <aristid> BMeph: category-extras
18:08:53 <aristid>  :t [extract,join]
18:08:53 <aristid> [extract,join] :: (Copointed f, Monad f) => [f (f a) -> f a]
18:09:01 <eightbitman> BMeph: It's something I've been experiencing since I started learning to program a few years ago. I'm learning how to say stuff to the machine, but I feel like there's some deeper understanding that I have not yet figured out how to reach
18:09:14 <etpace> does anyone know of a pretty printer for binary trees?
18:09:29 <Pseudonym> How pretty do you want them?
18:10:10 <etpace> More readable than Br (Br (Br (Br etc :p
18:10:21 <etpace> just so I can see general structure to verify its ok
18:10:24 <BMeph> aristid: Wouldn't you also need (Comonad a) for that? :)
18:10:30 <shachaf> eightbitman: "the machine" is probably a rather different one from what you're used to. :-)
18:10:57 <shachaf> eightbitman: So to some extent it's a matter not just of how to say things but what to say.
18:11:08 <Eduard_Munteanu> Comonad uses Copointed.
18:11:51 <Eduard_Munteanu> There was some difference between how Control.Monad is organised and how Control.Comonad is.
18:11:53 <FunctorSalad> (BMeph: I meant 'the type contains the files' in the sense that a typelevel value '/dev/sda' would mean that it uses that disk... but not such a good idea; usually the exact pseudo-file isn't known statically)
18:12:06 <eightbitman> shachaf: it feels like i'm speaking chinese without having any "feel" for the words, you know?
18:12:11 <BMeph> aristid: Er, Copointed (f `o` f), or however that works.
18:12:24 <shachaf> eightbitman: It'll pass. :-)
18:12:46 <FunctorSalad> (but then, I assume there are more abstract pseudo-files in plan9 too (don't know))
18:12:47 <int80_h> @hoogle getDirectoryContents
18:12:47 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
18:12:56 <eightbitman> shachaf: just soldier on then?
18:13:02 <shachaf> eightbitman: It's probably easier if you don't try to force "programming" as you're used to it into it.
18:13:17 <Pseudonym> http://community.haskell.org/~wren/bytestring-trie/src/Data/Trie/Internal.hs <- etpace, check this out
18:13:20 <FunctorSalad> apropos haskell system functions, getHomeDirectory complains if HOME isn't set :(
18:13:24 <BMeph> eightbitman: Well, there's always something "deeper". Pick a topic, we loves us some esoterica here... :)
18:13:25 <shachaf> E.g. Do X, then do Y. That counts as more advanced in Haskell. :-)
18:13:25 <FunctorSalad> is that a bug or feature?
18:13:30 <Pseudonym> In particular, showTrie.
18:13:42 <Pseudonym> Incidentally, this is a common homework question, because it's an interesting exercise.
18:13:55 <FunctorSalad> hehe I tried showTrie for visualization of directory trees ;)
18:13:56 <Pseudonym> So I'd encourage you to try it yourself if you want to learn something.
18:14:14 <FunctorSalad> just needs some optical decluttering, then it'd be usable
18:14:16 <dafis> FunctorSalad: what OS
18:14:22 <FunctorSalad> dafis: linux
18:14:39 <Phyx-> .quit
18:14:47 <aristid> FunctorSalad: if HOME is not set, then there is no home directory
18:14:49 <dafis> FunctorSalad: $ echo $HOME
18:14:52 <int80_h> dafis: RWH gives me an idea of what I want. I think enough to explain better. hpaste coming soon once I play around a bit
18:14:59 <Eduard_Munteanu> I suppose you can mess with it and unset it manually.
18:15:10 <FunctorSalad> aristid: huh? unset HOME doesn't delete my home dir ;)
18:15:15 <Eduard_Munteanu> But then I'm not sure bash's ~ works anymore.
18:15:26 <FunctorSalad> I think some mode of calling sudo does that
18:15:28 <Eduard_Munteanu> (that's a guesS)
18:15:42 <aristid> FunctorSalad: ok that's assuming that no crazy process unsets HOME
18:15:53 <Eduard_Munteanu> You should probably parse /etc/passwd to be 100% sure.
18:16:23 <dafis> FunctorSalad: if you run sudo as root, it may be that neither your HOME nor root's is available
18:16:30 <FunctorSalad> dafis: that works normally, but in some context (sudo I think) I got the "variable doesn't exist" or so error when calling getHomeD)
18:16:31 <int80_h> @hoogle getDirectoryContents
18:16:31 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
18:17:15 <Eduard_Munteanu> Mmm, if you're using su, then perhaps you need to invoke it as 'su -' to set root's full environment
18:17:24 <danderson> do the Foreign.Marshal.Alloc.* functions zero out memory that they allocate, or do I need to ensure that myself?
18:17:51 <FunctorSalad> unset HOME; ghc -e ':m System.Directory' -e getHomeDirectory
18:17:57 <FunctorSalad> @ dafis
18:18:19 <FunctorSalad> (no sudo required, but I think sudo does this depending on sudoers file and flags)
18:18:44 <FunctorSalad> I think it's kinda bad, but you could consider it a feature
18:19:41 <Eduard_Munteanu> FunctorSalad: hm, if you unset HOME, bash still gets ~ properly. Only if you set it to "" or something bogus it changes.
18:19:49 <Eduard_Munteanu> (just tried it)
18:19:55 <shachaf> Eduard_Munteanu: Yes -- see `man bash`.
18:20:07 <FunctorSalad> (alternative behaviour would be to get it from /etc/passwd (is it just my system or is that file always freely readable by default on debian?))
18:20:09 <aristid> Eduard_Munteanu: i guess bash reads /etc/passwd at start
18:20:09 <ebzzry> Are there companies that employ Haskell programmers?
18:20:23 <FunctorSalad> (the actual pw's are in the shadowfile now after all)
18:20:26 <aristid> ebzzry: yes, but not very many
18:20:27 <FunctorSalad> *their hashes
18:20:36 <dons> ebzzry: yeah.
18:20:40 <Eduard_Munteanu> In that case I suppose getHomeDirectory should work similarly.
18:20:41 <dons> specialist places, mostly
18:20:48 <ebzzry> Who are they and where are they located?
18:20:51 <FunctorSalad> Eduard_Munteanu: how did you try to expand ~?
18:21:06 <Eduard_Munteanu> Google employs Haskell programmers during GSoC, but that's something a bit different.
18:21:08 <FunctorSalad> in my zsh "echo ~" prints just a newline after unset HOME
18:21:23 <Eduard_Munteanu> FunctorSalad: oh, I use bash.
18:21:29 <Eduard_Munteanu> Yeah, echo.
18:21:51 <FunctorSalad> but zsh -c 'echo ~' still works ;)
18:21:57 <Eduard_Munteanu> Also, Microsoft employs guys like SPJ, but that's for research.
18:22:01 <FunctorSalad> so yes, getHomeDirectory might want to do something like that
18:22:14 <aristid> if i set HOME to something other than my real home, bash accepts that
18:22:25 <aristid> but when HOME is deleted, then it seems to use /etc/passwd
18:22:31 <dafis> FunctorSalad: getHomeDirectory queries $HOME
18:22:32 <Eduard_Munteanu> aristid: yeah, that happens here as well.
18:22:38 <ebzzry> (let's set aside research groups for this query, for now)
18:22:39 <aristid> i guess getHomeDirectory could do that too
18:22:45 <FunctorSalad> dafis: yes, hence it crashes if you unset it
18:22:54 <FunctorSalad> the question is whether it should do whatever bash does instead
18:22:56 <ethicszen> dons, the tracker for the HP binaries appears to be offline
18:23:18 <Eduard_Munteanu> ebzzry: um, if you really want to be employed for a bit working on Haskell stuff, you might want to try GSoC. But for that you have to be a student.
18:23:21 <dafis> FunctorSalad: you could try sudo env HOME=/wherever whatever you want to do
18:23:21 <FunctorSalad> (get it from /etc/passwd as aristid just found out)
18:23:23 <aristid> @hoogle getHomeDirectory
18:23:24 <lambdabot> System.Directory getHomeDirectory :: IO FilePath
18:23:25 <dons> ethicszen: danderson is working on it
18:23:27 <dons> thanks for the report
18:23:32 <Eduard_Munteanu> ebzzry: other than day I don't know.
18:23:45 <ebzzry> Eduard_Munteanu: Unfortunately, I'm not a student.
18:23:49 <ethicszen> ah okay.
18:24:08 <ebzzry> Also, I'm looking for a long-term career, if it exists in the Haskell world.
18:24:12 <FunctorSalad> dafis: or 'sudo -i', yes, but still maybe this should be fixed?
18:24:35 <Eduard_Munteanu> ebzzry: there was a Linux distro, I think commercial, that used Haskell scripts.
18:24:43 <Eduard_Munteanu> I don't recall its name.
18:24:45 <aristid> FunctorSalad: i guess that's low-priority, but sure
18:24:47 <ebzzry> Eduard_Munteanu: Linspire
18:24:53 <FunctorSalad> aristid: true
18:24:59 <Eduard_Munteanu> ebzzry: well, you could try there.
18:25:21 <ebzzry> Not a lot then, I fear.
18:25:33 <FunctorSalad> (btw sudo -i is annoying for automated use since it will cd to the new home :|)
18:26:03 <Eduard_Munteanu> ebzzry: I'd suggest you look deeper. I didn't so I'm not that informed. Perhaps there are a few more small companies that want Haskell programmers.
18:26:13 <FunctorSalad> (so you have to sudo -i "ghc --make $(realpath Main.hs)" or whatever)
18:26:23 <FunctorSalad> (not that I regularly invoke ghc with sudo ;))
18:26:26 <ebzzry> Eduard_Munteanu: OK
18:26:28 <jb55> so I had a though if anyone would humor me; after playing with parsec and other combinator libraries I began to think, would it be possible to build some sort of 'swarm intelligence' by combining individuals to perform some group task?
18:26:36 <aristid> ebzzry: http://cufp.org/
18:26:41 <Eduard_Munteanu> I'd check out rentacoder or such to see if they even have such jobs.
18:27:50 <FunctorSalad> sudo -i "ghc --make $(shell-quote -- "$(realpath Main.hs)")" for the extra-careful
18:27:52 <FunctorSalad> ;)
18:31:29 <etpace> I butchered the trie pretty printing by just ignoring arcs and printing the branches, but it's just nonsense -- and I cant really read the printing code
18:31:45 <etpace> @hoogle BinaryTree
18:31:45 <lambdabot> No results found
18:32:44 <FunctorSalad> etpace: hmm? don't the arcs contain the common prefixes?
18:33:14 <etpace> I'm not sure, i've never used a trie -- I just needed to 'pretty print' a binary tree so I can see where my  structure is going wrong
18:33:20 <etpace> structure/creation
18:33:27 <etpace> and i was pointed to the trie pretty printing
18:34:11 <dafis> etpace: perhaps the showTree methods in Data.Set/Map are more like what you need
18:34:22 <FunctorSalad> hmm I've only very briefly looked at Data.Trie but it's quite different from a binary tree
18:34:39 <FunctorSalad> it stores *parts* of the key strings in nodes
18:34:45 <FunctorSalad> (namely, common prefixes)
18:34:52 <etpace> Pseudonym handed over the link
18:35:29 <FunctorSalad> (don't know, maybe this particular trie duplicates the data in the leaves, but why'd one do that?)
18:35:46 <etpace> i'll look at data.sets draw tree
18:35:49 <etpace> it seems to be what im looking for
18:36:37 <FunctorSalad> if you can get it to build a tree that has the same structure as yours, yes
18:36:50 <FunctorSalad> usually Set hides the tree from the user
18:37:24 <dafis> FunctorSalad: I thought more of copying the code
18:37:39 <dafis> mutatis mutandis
18:37:56 <FunctorSalad> of the showSet? ok :)
18:38:01 <FunctorSalad> or showTree
18:38:08 <dafis> right
18:38:27 <etpace> yep, thats the plan
18:38:50 <FunctorSalad> can I somehow get 'cabal info' to do a fulltext search?
18:39:10 <FunctorSalad> maybe I should just zgrep the index.tar instead
18:46:50 <colinhect> Is this a suitable channel to ask a question about a Cabal error?
18:46:59 <hpc> #cabal?
18:47:21 <colinhect> good idea
18:48:37 <int80_h> @hoohle readFile
18:48:37 <lambdabot> Prelude readFile :: FilePath -> IO String
18:48:37 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
18:48:37 <lambdabot> System.IO readFile :: FilePath -> IO String
18:48:45 <int80_h> @hoogle readFile
18:48:45 <lambdabot> Prelude readFile :: FilePath -> IO String
18:48:45 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
18:48:45 <lambdabot> System.IO readFile :: FilePath -> IO String
18:52:05 <dafis> int80_h: getting further with Bare Bones?
18:53:03 <etpace> If I need a self balacning tree, is there one in the standard libraries?
18:53:22 <dafis> etpace: AVLTree on hackage
18:53:32 <dafis> and others, I think
18:53:32 <int80_h> dafis : yes I came up with a new data structure I'd like you to lok at, I'm getting compile errors
18:53:43 <dafis> int80_h: paste?
18:53:43 <etpace> alright cheers
18:53:50 <int80_h> dafis: coming up
18:54:01 <int80_h> dafis : trying to just cut the minimum
18:54:27 <dafis> int80_h: but don't exaggerate, a bit of context might help
18:55:44 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27982#a27982
18:55:49 <monochrom> w00t haskell platform new release! <3
18:55:52 <int80_h> dafis: If you need more context let me know.
18:56:00 <djahandarie> v00t
18:56:39 <int80_h> oh crap I see what it is
18:56:41 <int80_h> I think
18:57:13 <int80_h> that's wierd \x becomes what looks like \ x when I paste it
18:57:55 <djahandarie> dons, wouldn't it make more sense if that text on the bottom of the new platform website was centered?
18:58:06 <int80_h> okay my code says \x but ghci reads it as \ x. Is that something to do with what I did wrong?
18:58:42 <djahandarie> I swear I'll make it to one of these Boston Haskell meetings
18:58:57 <dafis> int80_h: don't think so, TH errors usually mean missing whitespace, not excess
18:59:21 <dafis> int80_h: can you paste a few surrounding lines?
18:59:44 <int80_h> dafis I just have imports. I will paste the whole file
18:59:45 <benmachine> int80_h: \x and \ x are basically the same
19:00:09 <benmachine> int80_h: ah, I know what this is
19:00:16 <benmachine> int80_h: you just have an Entry at the top level?
19:00:34 <benmachine> int80_h: what is that meant to do?
19:00:50 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27982#a27983
19:01:14 <int80_h> benmachine: right now I am just playing around making sure I have my thoughts right.
19:01:44 <dafis> int80_h: what benmachine said, you can't have a naked value at the top level
19:01:44 <benmachine> int80_h: expressions at the top level don't make sense
19:01:54 <int80_h> benmachine: the immediate step is to store a function that will generate a String when called.
19:01:54 <benmachine> write 'thing =' before Entry
19:02:05 <dafis> int80_h: ^^
19:02:44 <benmachine> int80_h: that is a really unhelpful error message but that's basically how to fix it :)
19:03:02 <benmachine> (could possibly report it as a GHC bug that it gives you that even when TH is disabled)
19:03:05 <int80_h> benmachine : yeah when I see error messages like that I figure I screwed somethign really obvious up
19:03:29 <dafis> benmachine: TH is enabled per pragma
19:03:39 <benmachine> dafis: oh, yeah
19:03:41 <Daenyth> Can whitespace significant in haskell? I'm reading learn you a haskell, and I've seen some functions defined where there's two pattern matches like "foo []  =" "foo  [] =" right above each other for a function of [a]->[a]->*. It looks like one was for the blank first param and the other for the second, from the way they lined up vertically
19:03:44 <benmachine> dafis: but it's still true
19:03:50 <Daenyth> er... s/Can/Is/
19:04:24 <benmachine> dafis: it does that even when it isn't
19:04:32 <dafis> Daenyth: actually, there ought to be underscores
19:04:36 <etpace> can anyone explain/give an example how to use COrdering/AVL trees? I don't really have a clue whati its doing
19:04:53 <Daenyth> dafis: oh you know, it may have just been funky highlighting or placement that made it look like that. Makes much more sense
19:05:02 <Daenyth> it seemed quite odd :)
19:05:14 <benmachine> dafis: some whitespace is significant sometimes :P
19:05:18 <benmachine> err, Daenyth 
19:05:43 <benmachine> the LHS of a function equation is not one of those times, though
19:06:12 <Daenyth> benmachine: heya!
19:06:34 <benmachine> Daenyth: hi :)
19:06:38 <Daenyth> how goes
19:06:51 <benmachine> I'm pretty tired
19:06:55 <benmachine> and not getting much done
19:06:58 <benmachine> uh, the usual
19:07:14 <benmachine> you?
19:07:22 <Daenyth> learnin' me a haskell ;)
19:07:29 <benmachine> excellent!
19:07:32 <benmachine> all the cool kids are doing it
19:07:42 <Daenyth> yeah, I've been wanting to learn something functional
19:07:57 <Daenyth> and parens give me indigestion ;)
19:07:58 <benmachine> Cadynum wrote an IRC bot in haskell
19:08:00 <benmachine> heh
19:08:23 <benmachine> mm, they can have that effect
19:08:43 <Daenyth> So for the moment I'll be going back and redoing my euler stuff in haskell
19:08:47 <Daenyth> (and perl6)
19:08:55 <Daenyth> once rakudo * comes out anyway
19:09:07 <benmachine> I never did that much euler
19:09:14 <Daenyth> I find it pretty fun so far
19:09:17 <benmachine> which is kind of embarassing because maths is supposed to be my thing
19:09:31 <benmachine> I got 1-18 and 67
19:09:40 <benmachine> because 18 and 67 were basically the same problem
19:10:01 <Daenyth> http://github.com/Daenyth/Project-Euler/blob/master/haskell/1/euler1.hs <- my current semi-golfed version
19:10:09 <Daenyth> much better than my first attempt
19:10:33 <benmachine> mm
19:10:55 <Daenyth> saw a p6 version of that yesteday
19:10:56 <benmachine> type declarations on main can come in handy, btw
19:11:06 <Daenyth> it was beautiful
19:11:26 <Daenyth> say [+](1..999).grep: * %% (3|5)
19:11:35 * benmachine melts
19:11:54 <Daenyth> [] ~= foldl, %% == my multOf
19:12:03 <Daenyth> and then a junction
19:12:48 <benmachine> but yeah
19:12:53 <benmachine> main = putStrLn <$> getLine
19:12:55 <benmachine> will compile
19:12:56 <Daenyth> looking forward to doing euler in that
19:12:58 <benmachine> and then not do anything
19:13:03 <Daenyth> that looks wrong
19:13:04 <benmachine> :t putStrLn <$> getLine
19:13:05 <lambdabot> IO (IO ())
19:13:18 <benmachine> main = putStrLn =<< getLine is the working version
19:13:24 <benmachine> :t putStrLn =<< getLine
19:13:25 <lambdabot> IO ()
19:13:35 <jmcarthur> :t join $ putStrLn <$> getLine
19:13:36 <lambdabot> IO ()
19:13:36 <benmachine> illustrating why type annotations can sometimes be handy
19:13:44 <benmachine> yes, that also works
19:13:49 <Daenyth> =<< is sort of like <- I assume, but just passes rather than binding?
19:14:07 <jmcarthur> that's the basic idea
19:14:08 <jmcarthur> for IO
19:14:28 <jmcarthur> except that <- is special syntax and =<< is just an operator
19:14:31 <Daenyth> aha
19:14:38 <benmachine> Daenyth: <- is syntactic sugar that gets decoded into >>= (which is flip (=<<))
19:14:41 <Daenyth> I haven't gotten that far in the tutorial yet
19:14:54 <benmachine> so basically <- is implemented in terms of =<<
19:14:55 <benmachine> so yes
19:14:58 <colinhect> Could someone help me figure out why SDL is failing to install using cabal? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27985#a27985
19:15:24 <benmachine> colinhect: avoid cabal upgrade
19:15:28 <benmachine> use cabal install instead
19:15:36 <colinhect> ok
19:15:38 <benmachine> colinhect: cabal upgrade breaks things, as you may have noticed
19:15:42 <benmachine> they may require un-breaking
19:15:47 <benmachine> but I definitely require sleep
19:15:51 <Daenyth> later
19:15:52 <colinhect> I tried install before upgrade
19:15:56 <benmachine> so I'm going to do that instead of helping you, sorry :P
19:16:01 <colinhect> lol
19:16:04 <colinhect> ok thanks anyway
19:16:17 <benmachine> but yeah, never use cabal upgrade
19:16:19 <Daenyth> Anyone have any vim plugin recommendations for haskellery?
19:17:15 <FunctorSalad> the :DocIndex feature of 'the' haskell plugin is pretty good imo
19:18:00 <FunctorSalad> (the docindex is used when you do _? or whatever it was... or :IDoc identifier)
19:18:38 <FunctorSalad> may require you to have cabal installed your packages with haddock turned on
19:18:50 <applicative> colinhect, was the error the same with `cabal install SDL`
19:18:58 <colinhect> yes
19:20:04 <applicative> colinhect, annoying, it isn't one of the obvious ones 
19:20:19 <colinhect> meh
19:20:27 <colinhect> I'm on arch linux if that changes anything
19:21:18 <applicative> dcoutts is the master of these things, if no one else can figure it out, there is always the counsel of relying on him
19:21:41 <solrize> instance Monad m => Functor m where  fmap = liftM     --  reasonable???
19:22:04 <ddarius> No.
19:22:35 <applicative> no just say :   Functor IO where fmap = liftM or whatever
19:23:41 <solrize> yeah i'm just wondering what's wrong with doing it generically like that.  the compiler makes me set some scary flags but then it stops complaining
19:24:18 <applicative> colinhect, i doubt i can help, but to go through the preliminary motions, what does doing "ghc-pkg list" tell you 
19:24:38 <EvanR> everything is a function eh
19:25:11 <applicative> what's your arity?
19:25:48 <Tomsik> proper classes aren't
19:26:18 <applicative> couldn't we speak of so to say, proper functions, proper classes of ordered pairs, so to say
19:27:42 <applicative> colinhect, what I'm wondering is whether you have somehow overwritten "containers" or "Cabal", messing with dependencies.  Or otherwise broken them
19:29:29 <colinhect> it's possible...
19:29:39 <applicative> colinhect, or ghc-pkg check  -- I don't know if you've used these, if not see ghc-pkg --help
19:30:02 <colinhect> ghc-check gives no output
19:30:08 <colinhect> err
19:30:13 <colinhect> ghc-pkg check
19:30:18 <applicative> yeah
19:30:27 <colinhect> and ghc-pkg list gives a lot of packages
19:30:44 <colinhect> which includes containers
19:30:47 <applicative> do they divide into global and local ones?
19:31:00 <colinhect> yeah
19:31:25 <colinhect> the local one have some packages that I installed via cabal
19:31:38 <colinhect> the global one does not
19:31:46 <applicative> there should be a color difference for 1) broken ones and 2) merely hidden ones.  
19:32:09 <colinhect> the ghc packages are highlighted blue
19:32:12 <colinhect> all others are white
19:35:56 <dafis> colinhect: blue means hidden
19:36:02 <colinhect> ok
19:38:06 <applicative> colinhect, sorry crashing here.  it occurs to me there is also arch-haskell, though there's just a few people there.  
19:38:18 <applicative> i dont think lamdabot can help, but she's there....
19:38:27 <applicative> lambdabot
19:38:44 <colinhect> ok I'll try arch-haskell
19:47:11 <deech> Hi all,the GHCI debugger docs mention that there are other debuggers available for GHC. Googling didn't turn up any. Any suggestions?
19:49:12 <monochrom> perhaps it has "buddha" in mind
19:49:49 <deech> Is that still an active project? The last update was in 2006.
19:50:01 <monochrom> then perhaps not active
19:50:58 <deech> There are other debuggers linked from that page called "Hood" and "Hat", neither have seen any releases since 2008.
19:51:13 <mtnviewmark> oy - coding using Either without Control.Monad.Error is a pain
19:51:32 <FunctorSalad> 'either' can save a few characters
19:51:39 <mtnviewmark> yup - using it
19:51:42 <koninkje> jmcarthur: Do you happen to remember the additional property beyond (sequence . fmap) necessary for hyloM? Or an example of how things can go wrong?
19:51:51 <FunctorSalad> and ||| +++ form Control.Arrow maybe
19:52:02 <FunctorSalad> @t (|||)
19:52:02 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:52:03 <mtnviewmark> but had to define sequenceEither, liftEither and concatEithers to make things clear in the code
19:52:07 <FunctorSalad> @ty (|||)
19:52:08 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
19:52:43 <FunctorSalad> oh wait, that's just 'either'
19:53:03 <dafis> FunctorSalad: for the arrow (->)
19:53:09 <mtnviewmark> oh, I don't get those either
19:53:10 <FunctorSalad> yes
19:53:17 <koninkje> jmcarthur: (Other than the fact that there can be multiple different sequence functions and you may want to choose between them)
19:53:26 <mtnviewmark> I'm coding on Haddock - and the packages I can import are severely limited
19:54:01 <FunctorSalad> nvm (|||), it's just 'either' (since you're probably not using any other arrows)
19:54:02 <mtnviewmark> something to do with "boot packages in GHC" ... something to do with the intertwinedness of some aspect of Haddock and GHC which I don't understand
19:54:23 <FunctorSalad> (and the Kleisli wrappers are not the answer to clunkyness ;))
19:55:28 <Hugglesworth> I'm on archlinux, I installed xmonad and ran it without issue
19:55:38 <Hugglesworth> recently I installed cabal
19:56:10 <Hugglesworth> xmonad now gives me a "Could not find module `XMonad.Util.Run'"
19:56:24 <Hugglesworth> it's searching for both Run.hs and Run.lhs, but all cabal's given me are Run.hi
19:56:41 <Hugglesworth> I've got Util.Run, or more to the point, xmonad-contrib installed both globally and user-side, so that's not the issue
19:57:20 <Hugglesworth> so, any ideas about my problem? I'd really like to be able to compile my config file again
20:00:15 <Gracenotes> > 2000 * logBase 2 2000
20:00:16 <lambdabot>   21931.568569324176
20:00:40 <jmcarthur> koninkje: umm, not really at this point, no
20:01:01 <koninkje> jmcarthur: If you ever do recall it, I'd be interested
20:01:34 <koninkje> I haven't run into any issues with that formulation of hyloM, but dealing with monads can be subtle
20:01:56 <jmcarthur> koninkje: actually, i think i remember now. it's not actually applicable here. i was doing deforestation of cata composed with ana to create hylo, which required that mapM f . mapM g = mapM (f <=< g) or something like that
20:02:18 <jmcarthur> well, that's clearly wrong
20:02:27 <koninkje> oh yes, that'll need some extra tricks
20:03:03 <IceDane> "05:00 < jmcarthur> koninkje: actually, i think i remember now. it's not  actually applicable here. i was doing deforestation of cata  composed with ana to create hylo, which required that mapM f  . mapM g = mapM (f <=< g) or something like that
20:03:05 <jmcarthur> mapM f <=< mapM g = mapM (f <=< g)  i think
20:03:08 <IceDane> "
20:03:10 <IceDane> And that is why haskell is not for the average joe.
20:03:15 <jmcarthur> ?
20:03:27 <jmcarthur> IceDane: this is for something that the average joe wouldn't need to do anyway
20:03:33 <IceDane> jmcarthur: I see
20:03:46 <bremner> IceDane: as compared to a simple language like C++?
20:03:55 <jmcarthur> plus, at the time i did that i only had i think 1.5 years of haskell experience, maybe 2
20:05:14 <IceDane> bremner: I see your point, but I'd guesstimate that most people find it easier to deal with OOP/imperative than a purely functional programming language like haskell
20:05:20 <IceDane> (And I know that haskell can be imperative and all that)
20:05:21 <jmcarthur> i don't
20:05:34 <jmcarthur> c++ makes me want to kill something
20:06:04 <cncl> IceDane: i've been using haskell for 9 months and i understood all of that
20:06:11 <IceDane> cncl: Congratulations
20:06:16 <IceDane> I haven't and I didn't
20:06:19 <cncl> sux
20:06:39 <koninkje> IceDane: I think that reaction is more of a kneejerk response to paradigm shift rather than anything intrinsically hard about pure FP
20:06:39 <IceDane> Want a pat on the back? They're free if you do them yourself
20:06:48 <IceDane> koninkje: Yes, I agree
20:06:51 <m3ga> IceDane : OOP/imperative has a lower barrier to entry, but its also far easier to write buggy code.
20:06:56 <IceDane> I'm not saying that the other is better, or something like that
20:07:12 <IceDane> But I find functional programming much harder to get my head around
20:07:19 <IceDane> But I will admit that it gets easier and .. more logical as I go
20:07:35 <IceDane> And I find myself looking at C++ or something similar and thinking "Well, shit. I'd just map this and fold this if I was doing haskell."
20:07:36 <koninkje> An old professor of mine related a tale about when he used to teach "advanced programming" back in the day
20:07:55 <koninkje> they used to teach lisp as the starter language and "advanced programming" mant C
20:08:02 <koninkje> s//meand
20:08:04 <IceDane> But by all means, do not think I'm hatin' on haskell. I fucking love this language. Seriously
20:08:19 <IceDane> I'm like a salesman on cocaine when I advocate haskell
20:08:27 <IceDane> koninkje: Yeah?
20:08:29 <koninkje> The funny part is that now he teaches Maple and Prolog to people who learn on C++
20:08:29 <cncl> hey you're kinda irritating
20:08:38 <cncl> oops gotta go
20:08:45 <IceDane> cncl: Hey, your client has /ignore
20:08:47 <koninkje> And he gets the exact same complaints now as he did then
20:09:06 <jmcarthur> people just don't like to unlearn
20:09:09 <koninkje> paradigm shift is hard; programming is hard' but imperative and functional are just the same
20:09:23 <IceDane> jmcarthur: I think that might be it, yes
20:09:41 <IceDane> Unlike or .. find it hard. Not used to unlearning.
20:11:19 <m3ga> i managed to unlearn python by not using it for a couple of years. it was great.
20:11:49 <koninkje> That happens to me every time I put python down for a few months
20:12:03 <IceDane> I had an argument with a guy a while back where he argued that languages like F# were much better than haskell, because haskell was impractical for use in the real world.
20:12:19 <koninkje> by what measure of practicality?
20:12:49 <IceDane> Later on I wound up talking to him in irc and I inconspicuously drew out piece by piece how much he knew about haskell
20:13:09 <koninkje> How much F# is usable on Mac or *nix?
20:13:11 * koninkje ;)
20:13:17 <IceDane> And when I found out he didn't understand and/or know about the function composition operator, I forgot all his arguments
20:13:45 <IceDane> He was saying how F# was awesome because it had a 'pipe operator' where you piped the result from one computation/function to another
20:13:52 <mm_freak> one of the most appealing things about haskell i find is its simplicity‚Ä¶  i can put it aside for weeks and jump straight back in without having to read a tutorial again
20:13:54 <IceDane> "Yeah man, you should have looked at monads"
20:14:45 <Hugglesworth> ooo, a pipe operator? that's almost as awesome as bash
20:14:50 <mm_freak> actually F# has a limited notion of monads
20:14:57 <IceDane> mm_freak: When I started, I did it for a bit, loved it, but then did some C++ for a while and got back and had no idea what I was doing.. But that time I stayed on and wrote much more complex software than I had before, and now it sticks with me, for the most part
20:15:10 <mm_freak> they call monadic values "computation expressions"
20:15:17 <mm_freak> or even "workflows"
20:15:22 <IceDane> mm_freak: I do know that "computation |> anotherComputation" = "computation >>= anotherComputation" 
20:15:25 <IceDane> basically
20:15:32 <mm_freak> stupid terms, but a lot less scary than "monadic value"
20:15:46 <IceDane> But I do not know anything else
20:15:49 <IceDane> That's just what he told me
20:16:08 <mm_freak> IceDane: the |> operator in F# corresponds to haskell's (.), not (>>=)
20:16:20 <IceDane> mm_freak: Then he explained it incorrectly
20:16:22 <mm_freak> there is no F# operator for (>>=), but a function
20:16:24 <mm_freak> called Bind
20:16:29 <mm_freak> (a class method actually)
20:16:48 <IceDane> Like I said, I'm just going on what he told me. I didn't look into it. I have little interest in going for another microsoft kitchen sink language
20:16:54 <colinhect>  /quit
20:16:59 <mm_freak> i've used F# for a while
20:17:37 <mm_freak> it's not a bad language actually, but it kinda feels like road works
20:17:38 <IceDane> mm_freak: But is computation |> anotherComputation not the same as anotherComputation (computation) ?
20:17:50 <mm_freak> anotherComputation . computation
20:18:00 <IceDane> Ah
20:18:22 <mm_freak> (call them f and g instead, much less to type) =)
20:18:32 <mm_freak> f |> g corresponds to g . f
20:18:34 <IceDane> aye
20:18:55 <mm_freak> and c.Bind(f) corresponds to c >>= f
20:19:01 <mm_freak> uh, no
20:19:09 <mm_freak> it's MonadClass.Bind(c, f)
20:19:12 <IceDane> aah.
20:19:19 <mm_freak> and yes, you guess correctly
20:19:24 <mm_freak> it's not MonadClass.Bind c f
20:19:28 <mm_freak> but MonadClass.Bind(c,f)
20:19:31 <IceDane> I figured
20:19:35 <mm_freak> because the designers of F# are stupid people
20:19:37 <IceDane> That's a bastardized way of doing it
20:20:04 <mm_freak> Bind really must take a tuple, not two arguments, so you can't do currying easily, even though F# supports it
20:20:27 <mm_freak> a lot of standard library functions also take tuples instead of individual arguments
20:20:40 <mm_freak> that proves lack of understanding among the language/library designers of F#
20:20:43 <IceDane> Yeah
20:20:45 <IceDane> sounds like it
20:20:57 <mm_freak> at least the time i used it
20:21:02 <IceDane> but f a b is valid in F#?
20:21:09 <IceDane> Instead of f (a, b)?
20:21:18 <IceDane> Or do you have to do some magic to do currying?
20:21:59 <mm_freak> yes
20:22:49 <mm_freak> 'f a b' applies two arguments to a binary function f, properly using currying
20:23:02 <mm_freak> 'f (a,b)' applies one argument to a unary function
20:23:10 <mm_freak> same in haskell
20:23:13 <IceDane> Alright
20:24:10 <mm_freak> but of course in languages with currying support there are only unary functions =)
20:24:46 <IceDane> true
20:25:07 <Eduard_Munteanu> ‚àÉ a way such that Eduard_Munteanu figured ‚àÄ key, key ‚àà keyboard, how to map it to UTF-8 :)
20:25:25 <Eduard_Munteanu> I was missing the Mode_switch key.
20:26:00 <mm_freak> Eduard_Munteanu: hehe
20:26:00 <IceDane> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27987#a27987 What am I doing wrong here?
20:26:02 <Eduard_Munteanu> Seems there's another key just like Mode_switch which inserts funny chars, but I can't figure what it is.
20:26:19 <mm_freak> i mostly use the arrows and the ellipsis
20:26:35 <IceDane> (fromJust unhexed) is just a string
20:26:48 <lispy> string or _|_
20:26:58 <lispy> fromJust == the devil :)
20:27:16 <IceDane> lispy: It's guaranteed to be Just at that point
20:27:49 <Eduard_Munteanu> Any idea why Alt+v generates √∂ for me? It's just Alt_L and Meta_L.
20:28:11 <dons> djahandarie: if you send me a patch
20:28:32 <Eduard_Munteanu> (now Super_R is Mode_Switch and it generates ‚àÄ in combination with v)
20:28:50 <Eduard_Munteanu> I wish I could change those mappings as well.
20:28:59 <djahandarie> dons, hehe okay :)
20:29:04 <mm_freak> IceDane: error message?
20:29:19 <IceDane> sec
20:29:56 <IceDane> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27987#a27988
20:30:08 <mm_freak> IceDane: btw, if the 'do' keywords stands alone, the next line determines the indentation, so you can write:
20:30:14 <mm_freak> dnsLookup ip = do
20:30:18 <mm_freak>   somethingMore
20:30:24 <IceDane> mm_freak: Aaah
20:30:24 <mm_freak> that's a bit easier to read =)
20:30:27 <IceDane> Yeah
20:30:35 <IceDane> It's bad indentation, most of my code is
20:30:43 <IceDane> I need to read the indentation rules on haskell wiki
20:31:15 <mm_freak> IceDane: and your code is in the IO monad
20:31:22 <mm_freak> so you should return Nothing
20:31:28 <mm_freak> and return (Just something)
20:31:54 <mm_freak> you should write explicit type annotations
20:31:56 <IceDane> aaah.
20:32:02 <mm_freak> it helps a lot and also catches some mistakes =)
20:32:13 <IceDane> Yeah, true
20:32:27 <IceDane> sweet, that fixed it
20:33:12 <mm_freak> IceDane: in this case, however, i'd write a natural transformation
20:33:23 <IceDane> mm_freak: I'm not sure what you mean by that
20:33:27 <mm_freak> eitherToMaybe :: Either e a -> Maybe a
20:33:43 <IceDane> Ah, I see
20:34:02 <mm_freak> and:
20:34:08 <mm_freak> import Control.Exception as E
20:34:09 <mm_freak> E.try
20:34:10 <mm_freak> ;)
20:35:01 <Rotaerk> E.giveUp
20:35:08 <mm_freak> finally:  functors are truly a virtue
20:35:46 <mm_freak> fmap eitherToMaybe $ E.try (inet_addr ‚Ä¶)
20:36:08 <mm_freak> IO is a functor, so you can use fmap to apply a pure function to the "inside" value
20:36:18 <lispy> :t (<$>)
20:36:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:36:30 <mm_freak> fmap :: Functor f => (a -> b) -> (f a -> f b)
20:37:56 <mm_freak> lispy: i use <$>, too, but i prefer to show fmap to beginners
20:38:00 <IceDane> mm_freak: Wow, that's elegant
20:38:50 <IceDane> thanks for that
20:38:58 <mm_freak> you're welcome =)
20:42:29 <lispy> mm_freak: where does your nick come from?
20:42:44 * hackagebot cassandra-thrift 0.0.4 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.0.4 (KirkPeterson)
20:44:16 <mm_freak> lispy: it kinda lost its meaning
20:44:35 <mm_freak> well about ten years ago i used to write little DOS games with a friend
20:44:49 <mm_freak> and we prefixed our nicknames with 'mm' for 'mastermind' =)
20:44:55 <IceDane> Haha.
20:44:56 <lispy> heh
20:45:06 <mm_freak> i was 14/15 back then
20:45:08 <IceDane> You wrote dos games in 2000?
20:45:13 <mm_freak> yeah
20:45:17 <IceDane> Ah.
20:45:43 <mm_freak> in fact i stopped doing that when i switched to linux =)
20:46:03 <mm_freak> because writing DOS games was so much easier than writing windows games, and i was kind of a low level guy back then
20:46:18 <mm_freak> i wrote 2D graphics stuff in x86 assembler
20:47:06 <fxr> me too when I was in high school
20:47:14 <kevinlynx> hello ,i'm a haskell newbie here, and i recently read a haskell book <programming in haskell>, and i got some questions to ask!
20:47:25 <Eduard_Munteanu> kevinlynx: shoot :)
20:47:30 <mm_freak> kevinlynx: hello, just ask =)
20:47:37 <fxr> even I was operating my own bbs
20:47:49 <kevinlynx> here is some codes :
20:48:11 <mm_freak> fxr: i didn't know anything about telephones/networks then
20:48:18 <kevinlynx> sat :: (Char->Bool)->Parser Char   sat p = do x <- item if p x then return x else failure
20:48:54 <mm_freak> kevinlynx: better use a pastebin
20:48:57 <mm_freak> http://hpaste.org/
20:49:09 <kevinlynx> i copy these exactly from the book, but WinHugs show some errors
20:49:13 <mm_freak> easier to read =)
20:49:29 <fxr> mm_freak: good old tsr dayz.
20:49:32 <lispy> kevinlynx: you could get GHC, it's better than hugs
20:49:51 <kevinlynx> yes, the book uses GHC .
20:49:51 <Eduard_Munteanu> kevinlynx: you might need some imports
20:49:53 <lispy> kevinlynx: How old is that book?  The language may have changed a bit
20:49:56 <Eduard_Munteanu> Depending on the exact error.
20:50:23 <mm_freak> kevinlynx: i don't know Parsec too well, but 'failure'?
20:50:47 <kevinlynx> maybe i should post the entire codes ?
20:50:50 <mm_freak> fxr: i've never written a useful TSR
20:50:58 <Eduard_Munteanu> kevinlynx: yes, on a pastebin like mm_freak says
20:51:57 <lispy> mm_freak: I don't think that's parsec.  I don't recall parsec having 'item'
20:52:05 <kevinlynx> actually i donot know what 'pastbin' is, wait a while let me find how to . Thanks anyway.
20:52:15 <mm_freak> kevinlynx: http://hpaste.org/
20:52:34 <mm_freak> click 'new'
20:52:37 <lispy> kevinlynx: you paste the code into a webpage, hit submit, and it gives you a url you can paste here
20:52:38 <Eduard_Munteanu> Post it there, and write the link here.
20:52:38 <mm_freak> and paste =)
20:53:00 <kevinlynx> ok, i got it.
20:53:39 <kevinlynx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27991#a27991
20:53:49 <drbean> Looks like Data.List acquired the 'permutations' function post-6.8.
20:54:57 <mm_freak> kevinlynx: looks fine to me
20:55:10 <mm_freak> maybe you should use a few lambdas less
20:55:24 <mm_freak> item [] = []
20:55:32 <mm_freak> item (x:xs) = [(x,xs)]
20:56:05 <mm_freak> but that may be intentional =)
20:56:31 <kevinlynx> Yes, but i really want to figure out what the error is. I really copy them entirely from the book. 
20:56:50 <mm_freak> well
20:56:50 <kevinlynx> It seems i should try GHC =)
20:56:56 <mm_freak> you're using 'do' notation
20:57:04 <Eduard_Munteanu> kevinlynx: what the error?
20:57:06 <mm_freak> that requires 'Parser' to be a monad
20:57:22 <mm_freak> so you probably get an error related to a missing Monad instance
20:57:57 <kevinlynx> Expression : px  / Term : x / Type : [(Char, [Char])] / Does not match : Char
20:58:48 <mm_freak> get the haskell platform, which contains GHC
20:58:53 <lispy> Hugs error messages are hard to understand..
20:59:12 <mm_freak> kevinlynx: http://hackage.haskell.org/platform/
20:59:18 <kevinlynx> OK, I will get GHC to try the same codes. Thanks a lot guys.
20:59:49 <drbean> kevinlynx probably copied only part of the code instead of all the code.
21:00:16 <mm_freak> well
21:00:31 <mm_freak> using do notation would require a complicated Monad instance for 'Parser'
21:00:47 <mm_freak> a stack of a list monad transformer and a state monad, actually
21:01:01 <mm_freak> StateT String []
21:01:24 <Cale> It's not so hard to write a Monad instance for Parser here if you wrap it with a newtype
21:02:17 <mm_freak> Cale: i know we don't quite agree here, but i'd just use StateT over [] =)
21:02:59 <mm_freak> because that would encode exactly the Parser type
21:03:14 <Cale> I don't disagree with you
21:03:29 <Cale> StateT over list is actually one of the few places I think StateT is a good idea.
21:03:40 <mm_freak> hmm, ok
21:03:50 <mm_freak> i had the impression you don't like monad transformers in general
21:03:59 <Cale> But it's also quite informative to just write this one directly :)
21:04:16 <mm_freak> true, could be useful for a beginner =)
21:04:44 <Cale> newtype Parser a = P { runParser :: String -> [(a,String)] }
21:05:38 <mm_freak> if you don't mind using extensions and probably getting overlapping instances once in a while, you can write in instance for the 'type' Parser
21:05:40 <Cale> p >>= f = P (\s -> [(w,s'') | (v,s') <- runParser p s, (w,s'') <- runParser (f v) s'])
21:09:40 <fxr> parsing jquery takes 0.8s...
21:09:53 <mm_freak> Cale: is it difficult to implement an FRP system?
21:10:09 <mm_freak> or is it just difficult to make it go fast?
21:15:10 <drbean> Is there a function to filter a value from a list? Or is it too easy to do filter (/=x) list
21:16:00 * monochrom finishes building and installing haskell platform 2010.2.0.0!
21:16:47 <Pseudonym> drbean: That is pretty easy.
21:17:06 <Pseudonym> Also list \\ [x] if there's only one x in the list.
21:17:21 <Pseudonym> And don't forget [l | l <- ls, l /= x]
21:17:36 <Pseudonym> Which you may be able to combine with other list comprehension-type stuff.
21:17:49 <mm_freak> usually 'filter' is what you want
21:18:06 <mm_freak> or 'foldr', if you want to use pattern matching instead of (==) or (/=)
21:18:13 <Daenyth> Is there a particular reason that it's /= in haskell vs !=?
21:18:15 <mtnviewmark> monochrom - isn't the point of Haskell Platform that you don't have to build it - just install it?
21:18:35 <mm_freak> Daenyth: because (/=) is closer to the mathematical inequality symbol
21:18:39 <Daenyth> aha
21:18:42 <Daenyth> that makes sense
21:19:11 <mm_freak> actually '!=' is quite arbitrary
21:19:23 <drbean> Didn't see the resemblance either until now.
21:19:29 <Daenyth> yeah, guess I'm just used to it from other languages
21:19:38 * Daenyth shrugs
21:20:14 <monochrom> mtnviewmark: I'm on linux, ubuntu. And I find ubuntu's haskell debs unsatisfactory.
21:20:29 <Daenyth> Should give arch linux a try ;)
21:20:30 <monochrom> OTOH it's a no-brainer to build either.
21:20:32 <mtnviewmark> :-)
21:20:36 <Daenyth> there's a big haskell community there :)
21:20:53 <mm_freak> Daenyth: i'm using arch linux and find myself mostly using cabal-install
21:21:06 <Daenyth> even with so many of them packaged?
21:21:10 <mm_freak> only few packages are in the official arch repository
21:21:14 <Daenyth> the arch-haskell team does a pretty nice job
21:21:16 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
21:21:35 <mm_freak> most of them are in the AUR, so it really doesn't make much of a difference, but cabal-install always installs the newest packages, while you may find some outdated packages in the AUR
21:21:48 <Daenyth> mm
21:21:57 <Daenyth> I think arch-haskell team uses scripts to maintain the packages
21:21:59 <mm_freak> i think, haskell packages are best supported in gentoo
21:22:05 <monochrom> I use ubuntu rather than arch linux because end-user-ness is more important than haskell for me.
21:22:09 <Daenyth> dunno, haven't used it
21:22:25 <monochrom> I use ubuntu because it's poor man's macos x
21:22:47 <mm_freak> monochrom: you can have that with arch, too, quite easily =)
21:22:48 <monochrom> if arch linux is also poor man's macos x, I'll reconsider it
21:23:03 <mm_freak> just do:  pacman -S gnome
21:23:05 <mm_freak> and go ahead
21:23:12 <mm_freak> (though i prefer KDE)#
21:23:43 <Daenyth> I do rather like kde4 
21:23:47 <Daenyth> started using it on my work laptop
21:23:48 <OrangeSky> What's the name of a type that looks like ((->) a) ?
21:24:03 <mm_freak> OrangeSky: it's a type constructor
21:24:09 <OrangeSky> ah ok
21:24:19 <mm_freak> give it another argument and you get a final type
21:24:30 <OrangeSky> hmm
21:24:36 <mm_freak> ((->) a) b = (->) a b = a -> b
21:24:45 <OrangeSky> oho fair enough
21:24:50 <mm_freak> just like:  (Either a) b = Either a b
21:24:58 <OrangeSky> yeah
21:25:02 <OrangeSky> I see it :) thanks
21:25:28 <OrangeSky> Damn Haskell's syntax is too consistent
21:25:35 <OrangeSky> WHERE ARE MY SPECIAL FORMS
21:25:40 <Daenyth> :)
21:25:40 <mm_freak> hehe
21:25:53 <monochrom> you can use Template Haskell to add special forms
21:25:58 <OrangeSky> oh noes
21:26:17 <OrangeSky> [| is that quasi-quotation stuff? |]
21:26:28 <CakeProphet> that's QUASI!!
21:26:36 <OrangeSky> Yipes!
21:26:47 <monochrom> Template Haskell actually has full access to IO. You can use random numbers when expanding macros.
21:26:58 <monochrom> Or even solicit user input.
21:27:07 <mm_freak> so there is a TemplateIO?
21:27:08 <mm_freak> ;)
21:27:31 <mm_freak> or are you going to say that TH is an impure language?
21:27:37 * OrangeSky awards Most Likely To Gain Emergent Intelligence
21:28:32 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/template-haskell-2.4.0.1/Language-Haskell-TH.html#v%3ArunIO
21:29:21 <mtnviewmark_> "Excuse me, but could you tell me the local tea time before I expand these templates?"
21:29:32 <monochrom> yeah! :)
21:29:56 <mm_freak> hehe
21:30:03 <drbean> The example: (xs ++ ys) \\ xs == ys, explaining \\, would be easier to understand if it was written ( ys ++ xs ) \\ ys == xs. Because the explanation above talks about elements of ys being deleted from xs.
21:30:27 <monochrom> my favourite application is "this module will take 2 hours to build. please enjoy this complimentary movie..."
21:30:33 <Daenyth> http://github.com/Daenyth/Project-Euler/blob/master/haskell/1/euler1.hs <- In what ways might I improve this?
21:30:45 <mm_freak> lol
21:30:48 <OrangeSky> also, if I want to write a liftIO equivalent for some monad in my MonadTrans'd stack... that's pretty much going to have to use UndecidableInstances, eh? Since there could be multiple monads in the stack to lift to
21:31:32 <OrangeSky> (If I want to write it in general, that is, rather than just chaining lifts)
21:32:00 <mm_freak> Daenyth: that's fine, but the usual PE problem doesn't require much code or running time
21:32:17 <mm_freak> there's probably a shorter algorithm or a formula to calculate this =)
21:32:27 <mm_freak> (shorter in terms of running time)
21:32:54 <mm_freak> OrangeSky: not if you name the 'other' monads explicitly
21:33:02 <Daenyth> mm_freak: I've seen another one written in haskell that instead populates lists with successive multiples of 3,5 and sums the resulting lists
21:33:21 <Daenyth> but this one is much more intuitive for me
21:33:36 <mm_freak> OrangeSky: for example, MonadLib has BaseM as a generalization of MonadIO, for which it writes separate instances for each particular monad transformer
21:33:47 <Daenyth> mostly just want to work on my haskell skills (that's my first program)
21:34:03 <prsteele> if I have a type with constructors A, B, C, ... how do I define a function that operates on A, B, C, ...
21:34:17 <applicative> Daenyth, it looks great, a good use of list comprehensions ... you'll need something more complicated for a true catastrophe...
21:34:24 <Daenyth> heh
21:34:35 <mm_freak> danderson: sum . nub $ [3,6..999] ++ [5,10..999]
21:34:41 <OrangeSky> mm_freak: ah OK!
21:34:47 <Daenyth> I had it with filter map before but the lambda for my predicate was ugly
21:34:51 <mm_freak> Daenyth: that was for you, sorry
21:35:07 <Daenyth> nub.. I know I saw that in the tutorial...
21:35:24 <mm_freak> i don't know if that's right
21:35:24 <Daenyth> aha
21:35:27 <mm_freak> > sum . nub $ [3,6..999] ++ [5,10..999]
21:35:28 <mm_freak> 233168
21:35:28 <lambdabot>   233168
21:35:32 <Daenyth> that's right
21:35:45 <Daenyth> wow that's much better than the other version I saw
21:35:49 <mm_freak> > nub [1,2,3,2,4,4,1]
21:35:50 <lambdabot>   [1,2,3,4]
21:35:58 <mm_freak> deletes duplicates =)
21:36:00 <Daenyth> it had some funky lambdas to do the enumeration
21:36:05 <Daenyth> yeah just looked it up
21:36:24 <OrangeSky> mm_freak: Looks like a useful library, thanks
21:36:33 <Daenyth> that's one thing I've definitely learned from learning some python; docs are my friend :)
21:37:22 <Daenyth> at any rate it's a fair sight better than my first attempt...
21:37:23 <Daenyth> http://github.com/Daenyth/Project-Euler/blob/52e30e1286149d9ec7721b8b30f93f64db061cc8/haskell/1/euler1.hs
21:37:59 <Daenyth> and the iterations after..
21:38:00 <Daenyth> :P
21:38:59 <mm_freak> @let delEach n = takeWhile (not.null) . map (take $ n - 1) . iterate (drop n)
21:39:00 <lambdabot>  Defined.
21:39:06 <mm_freak> > sum $ delEach 5 [3,6..999] ++ delEach 3 [5,10..999] ++ [15,30..999]
21:39:07 <lambdabot>   No instances for (GHC.Num.Num [t], GHC.Enum.Enum [t])
21:39:07 <lambdabot>    arising from a use...
21:39:18 <mm_freak> @let delEach n = concat . takeWhile (not.null) . map (take $ n - 1) . iterate (drop n)
21:39:18 <lambdabot>  <local>:13:12:
21:39:19 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
21:39:23 <mm_freak> @undefine
21:39:26 <mm_freak> @let delEach n = concat . takeWhile (not.null) . map (take $ n - 1) . iterate (drop n)
21:39:27 <lambdabot>  Defined.
21:39:30 <mm_freak> > sum $ delEach 5 [3,6..999] ++ delEach 3 [5,10..999] ++ [15,30..999]
21:39:31 <Daenyth> nice bot
21:39:31 <lambdabot>   233168
21:39:34 <mm_freak> there you go
21:39:47 <mm_freak> that's the most efficient version, unless you want to find a simple formula
21:40:06 <mm_freak> but because of laziness, the 'nub' version is probably even more efficient =)
21:40:36 <Daenyth> and much more expressive
21:40:56 <OrangeSky> hopefully this new Haskell platform fixes the ticket I submitted yesterday ;)
21:41:25 <mm_freak> concise
21:43:23 <Daenyth> Does haskell have some kind of relative import or something similar to PYTHONPATH? Can I still easily import my things if I make a lib/, N/ dir at the root, or should I just put all Ns at root with lib/?
21:43:55 <mm_freak> Daenyth: module names are only loosely related to the directory structure
21:44:02 <mm_freak> a module name never changes
21:44:25 <mm_freak> if it's installed properly, you can import it
21:44:31 <napping> "well typed programs can't go wrong" is Milner's slogan, isn't it?
21:44:39 <Daenyth> well, the idea would be just to keep it in the repo so I don't have to install anything
21:44:51 <mm_freak> Daenyth: use cabal
21:44:52 <Daenyth> since I'll be constantly adjusting it
21:45:04 <mm_freak> if the library is known to cabal, then you can use it
21:45:12 <prsteele> if I have 'data Foo = Bar | Baz', how would I make a 'class' (OO class, not Haskell) to hold 'Bar' and 'Baz'? Specifically, I want to make this 'class' an instance of Ord, so I can say Bar > Baz, etc
21:45:14 <Daenyth> it would be stuff I'm writing
21:45:23 <Daenyth> to go along with my euler things
21:45:29 <Daenyth> just to reuse code across problems
21:45:33 <napping> prsteele: It's very hard to actually properly simulate algebraic data in OO languages
21:45:49 <mm_freak> prsteele: you can think of your 'Foo' as being a class
21:45:59 <mm_freak> instance Ord Foo where ‚Ä¶
21:46:06 <mm_freak> an OO class, that is
21:46:09 <napping> In particular, to make a few subclasses for the variants while making it impossible to add any more
21:46:47 <napping> If it's just constants, that's what enums are for
21:47:11 <OrangeSky> Is there a way to tell ghc not to search the directories in . and always link to installed libraries instead? (I have a project with both a dynamic library and a standalone executable; right now my solution is to put the standalone in another folder to force it to link to the installed lib)
21:47:56 <napping> prsteele: why are you asking here anyway?
21:48:27 <napping> I wouldn't have a clue how to do in Java if I hadn't recently seen it on a blog. Ugly trick with nested classes and a private constructor
21:48:55 <mm_freak> OrangeSky: you should use cabal, so you can specify which libraries to use
21:49:48 <mm_freak> but if your project contains a library and there is also an installed one with the same version number, i guess there isn't much you can do without using the dirty hacky way of forcing certain paths
21:49:55 <OrangeSky> mm_freak: Oh, that's true. I use cabal for the lib but not the standalone..
21:50:04 <OrangeSky> Hmm true
21:50:11 <napping> OrangeSky: if you want the code for the execuatble to link with the installed version rather than build agaainst the source it's packaged with, you should probably put it in a separate directory anyway
21:50:22 <OrangeSky> Guess so, no biggie anyway.
21:50:56 <napping> probably easiest just to add it as an executable in your cabal file, though
21:51:49 <OrangeSky> So I can have multiple sections for different build targets I'm guessing?
21:55:17 <lispy> ?users
21:55:17 <lambdabot> Unknown command, try @list
21:55:56 <gwern> lispy: isn't list of users in a chan a client thing?
21:57:12 <mm_freak> /names
21:57:31 <mm_freak> or nicklist.pl, if you happen to use irssi =)
21:58:07 <gwern> bah, no self-respecting haskeller would use irssi
21:58:11 <napping> prsteele: you could try a "deriving Ord" clause
21:58:13 <gwern> they'd use something written in haskell
21:59:37 <mm_freak> gwern: and what?
21:59:41 <mm_freak> some netcat clone?
21:59:46 <gwern> naturally
21:59:54 <mm_freak> i see
21:59:58 <mm_freak> sorry for that
21:59:58 <napping> Ah, netcat
22:00:03 <gwern> House has a TCP/IP stack doesn't it?
22:00:13 <napping> if you have netcat you don't need a mail client or a web browser either
22:00:18 <mm_freak> dunno, but there is a TCP/IP stack implemented in haskell
22:00:46 <napping> more seriously there has been a client
22:01:10 <mm_freak> btw, netcat is easy to implement in haskell
22:01:22 <napping> one would hope so
22:01:29 <mm_freak> and in only a tiny fraction of the number of lines used for the original C code
22:01:41 <napping> It ought to be easy to implement in assembly
22:01:55 <mm_freak> no, it's actually not at all easy to implement in assembly
22:03:14 <gwern> nothing is easy to implement in assembly
22:03:42 <ddarius> That's not true at all.
22:04:10 <mm_freak> an infinite loop is easy to implement
22:04:18 <mm_freak> here: JMP here
22:04:18 <EvanR> multiply with carry is easy in assembly
22:04:31 <mm_freak> EvanR: in x86 assembly, yes
22:04:31 <ddarius> mm_freak: Usually, jmp $
22:04:38 <EvanR> whereas C, haskell, ghc, and pretty much everything its not
22:04:42 <napping> ddarius: correct, properly calling exit at the end of the program that does nothing is a bit of difficulty
22:05:21 <EvanR> mm_freak: is that an uncommon operation?
22:05:34 <napping> mm_freak: calling socket, connect, and 2xsendfile will get you pretty far
22:06:01 <napping> surprising it's as handy as it is, for being so simple
22:06:35 <EvanR> napping: theres menuet, OS totally in assembly language, designed for people like you ;)
22:06:48 * gwern admits to finding $ very confusing and wouldn't think about jmping to a label like that
22:06:48 <Daenyth> hm
22:06:54 <EvanR> make gui apps with asm
22:07:25 <FunctorSalad> a DFS was surprisingly so easy in assembly that we did it in a cs course as homework
22:07:39 <FunctorSalad> assuming the thing *being* searched is readily available
22:08:19 <mm_freak> EvanR: what?
22:08:27 <mm_freak> an infinite loop?
22:08:39 <mm_freak> no, it's not uncommon, but that wasn't my point =)
22:08:45 <mm_freak> napping: and managing a buffer
22:08:49 <Daenyth> Where have I gone wrong? http://gist.github.com/487038
22:08:54 <FunctorSalad> iirc you just keep a 'array' of numbers next to each others with index i representing you current choice in the tree at depth i
22:09:04 <FunctorSalad> *your
22:09:09 <napping> mm_freak: that's why you use sendfile
22:09:14 <EvanR> mm_freak: no, multiply with carry
22:09:34 <mm_freak> EvanR: i don't think GUI apps are difficult to do in asm, if you use a GUI lib like GTK+
22:09:44 <FunctorSalad> shift the index pointer to the right/left where you'd recurse/return in a higher-level implementation
22:09:48 <gwern> EvanR: heh. my assembler textbook tells me that it's insanity to want to write a GUI in assemboler, and that I will regret it forever, and that I need a whole book to do that and this isn't it
22:10:08 <mm_freak> EvanR: multiply with carry?  that's not very common i'd say
22:10:26 <Daenyth> :t reverse
22:10:27 <lambdabot> forall a. [a] -> [a]
22:10:49 <EvanR> menuet has supporting code for it yes
22:10:53 <Eduard_Munteanu> splice FTW
22:11:13 <Eduard_Munteanu> Zero-copy rocks.
22:11:23 <Daenyth> hrm
22:11:43 <mm_freak> napping: sendfile is not portable
22:12:28 <Eduard_Munteanu> Unfortunately.
22:13:38 <Daenyth> I wish I could figure out how this is wrong :(
22:13:49 <ddarius> gwern: You need to know how to access the hardware and how to encode various abstractions into assembly and then you are in about the same position as using a high-level language.  Better in some respects, worse in others.
22:13:51 <Eduard_Munteanu> I¬¥m puzzled why no standard API came up with something like splice() / sendfile() by now
22:15:32 <mm_freak> Eduard_Munteanu: i think, that's an issue for languages like C
22:15:44 <mm_freak> higher level languages can provide a portable sendfile()
22:16:10 <Daenyth> Could someone help me out with this compile error? http://gist.github.com/487038
22:16:23 <Samy> Eduard_Munteanu, what are you doing with splice?
22:16:40 <mm_freak> Daenyth: operator priority =)
22:16:50 <Daenyth> hm
22:16:55 <Samy> =USA= Daenyth
22:16:58 * Daenyth tweaks
22:17:02 <Daenyth> Samy: Once upon a time
22:17:06 <Samy> <- men
22:17:12 <Samy> Once upon a time. :-P
22:17:23 <Daenyth> ahhh
22:17:25 <sharat87> Daenyth: hehe, I just wrote a isPalindrome function.. and came to this channel if I could find something better :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27994#a27994
22:17:28 <Daenyth> How times pass :)
22:17:43 <Eduard_Munteanu> Samy: one of the things I used it for was to dump data from the Linux kernel to a file.
22:17:46 <Daenyth> sharat87: clever
22:18:03 <Eduard_Munteanu> But you can use it even to replace sendfile() IIRC
22:18:08 <sharat87> am not sure if it is the most haskell-y way :)
22:18:10 <Daenyth> I like it
22:18:10 <EvanR> > let pal x = x == reverse x in pal "foo"
22:18:11 <lambdabot>   False
22:18:11 <Eduard_Munteanu> (basically anything which uses pipes)
22:18:14 <mm_freak> sharat87: i find Daenyth's version better =)
22:18:15 <EvanR> > let pal x = x == reverse x in pal "foof"
22:18:16 <lambdabot>   True
22:18:27 <Eduard_Munteanu> (and fds)
22:18:27 <Samy> Eduard_Munteanu, right, except some implementations of sendfile don't require a file descriptor. 
22:18:34 <mm_freak> more concise and still the same running time
22:18:36 <Daenyth> EvanR: d'oh
22:18:41 <Daenyth> ah
22:18:46 <Daenyth> but does that work with numbers?
22:19:02 <Daenyth> > let pal x = x == reverse x in pal 101
22:19:03 <Eduard_Munteanu> mm_freak: um, you still need some OS support if it¬¥s gonna be zero-copy.
22:19:03 <lambdabot>   No instance for (GHC.Num.Num [a])
22:19:03 <lambdabot>    arising from the literal `101' at <int...
22:19:07 <EvanR> > let pal x = show x == reverse (show x) in pal 12321
22:19:08 <lambdabot>   True
22:19:09 <Samy> I'm probably going to use vmsplice for some improvements to a project I'm working on soon.
22:19:10 <EvanR> > let pal x = show x == reverse (show x) in pal 12322
22:19:10 <lambdabot>   False
22:19:20 <sharat87> yeah, I don't like the '_:_:_' part in my code :)
22:19:21 <Jonno_FTW> is there anyway to show a number is a palindrome mathematically?
22:19:35 <Daenyth> Jonno_FTW: that's an interesting question
22:19:37 <mm_freak> Eduard_Munteanu: sure, but the base library programmers can deal with that question =)
22:19:39 <EvanR> Jonno_FTW: i guess were talking about base 10
22:19:46 <EvanR> then see above
22:20:06 <lispy> > 11 * 12345
22:20:07 <lambdabot>   135795
22:20:08 <Eduard_Munteanu> Samy: yeah, there¬¥s no standard sendfile()
22:20:20 <Daenyth> EvanR: why does '== reverse (show x)' work but not '== reverse $ show x'? I thought that the $ took the entire RHS and gave it to LHS, roughly?
22:20:32 <Eduard_Munteanu> mm_freak: it really needs kernel support, note you can¬¥t do it in the standard lib only
22:20:41 <Daenyth> (Still very new)
22:20:42 <mm_freak> Daenyth: the LHS is:  show x == reverse
22:20:47 <Daenyth> ahh
22:20:50 <mm_freak> does that make sense to you? ;)
22:20:56 <Daenyth> yeah now it does, completely
22:21:01 <mm_freak> or rather:  is that a function? ;)
22:21:14 <mm_freak> Eduard_Munteanu: yes, but the base library programmer can deal with that
22:21:20 <Daenyth> I figured that == would bind differently
22:21:32 <EvanR> :t (show x == reverse)
22:21:32 <mm_freak> Eduard_Munteanu: portability should be solved in the base library and the compiler, not in the actual program
22:21:33 <lambdabot>     Couldn't match expected type `String'
22:21:33 <lambdabot>            against inferred type `[a] -> [a]'
22:21:33 <lambdabot>     In the second argument of `(==)', namely `reverse'
22:21:41 <Daenyth> ahhhh
22:21:47 <Daenyth> Perfect sense now
22:22:08 <mm_freak> show x == (reverse $ show x)
22:22:28 <Jonno_FTW> > let pal = show . reverse == show in pal "madamimadam"
22:22:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
22:22:29 <lambdabot>         against inferr...
22:22:38 <Jonno_FTW> Rise to vote sir
22:22:39 <lispy> :i ($)
22:22:54 <mm_freak> > uncurry (==) . (id &&& reverse) $ show x
22:22:55 <lambdabot>   True
22:22:59 <mm_freak> > uncurry (==) . (id &&& reverse) $ show "abc"
22:23:00 <lambdabot>   False
22:23:03 <mm_freak> > uncurry (==) . (id &&& reverse) $ show "abba"
22:23:04 <lambdabot>   True
22:23:15 <mm_freak> > uncurry (==) . (id &&& reverse) $ show 12321
22:23:16 <lambdabot>   True
22:24:04 <Eduard_Munteanu> mm_freak: um, just like the Haskell 98 Prelude (or some other base libs) specifies some primitives, so does POSIX wrt splice. If it ain¬¥t there, you still have to bring in your code or use some compat lib.
22:24:06 <Jonno_FTW> was it a car or a cat i saw?
22:24:24 <Eduard_Munteanu> (in fact POSIX doesn¬¥t but you get the point, it concerns other basic functionality)
22:25:12 <Eduard_Munteanu> ISO C99 doesn¬¥t get C too far, yeah.
22:25:28 <Jonno_FTW> :t (&&&)
22:25:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:25:35 <mm_freak> > let str = "abcba" in and $ zipWith (==) str (reverse str)
22:25:36 <lambdabot>   True
22:25:55 <Jonno_FTW> What does &&& do?
22:26:07 <mm_freak> Eduard_Munteanu: you don't understand
22:26:32 <mm_freak> Eduard_Munteanu: the base library of haskell could define a 'sendFile' function, which does whatever is the best method on the current platform
22:26:43 <mm_freak> so the haskell programmer just writes 'sendFile'
22:26:49 <mm_freak> and doesn't bother with low level details
22:27:15 <mm_freak> Jonno_FTW: in the function arrow it does this:
22:27:25 <mm_freak> > (sin &&& cos) 0.4
22:27:26 <lambdabot>   (0.3894183423086505,0.9210609940028851)
22:28:01 <mm_freak> 'sin &&& cos' is a function, which calculates sin and cos and gives a tuple
22:28:47 <mm_freak> > (proc x -> do y <- sin -< x; z <- cos -< x; returnA -< (y,z)) 0.4
22:28:48 <lambdabot>   Pattern syntax in expression context:
22:28:48 <lambdabot>      proc x -> do y <- sin -< x
22:28:48 <lambdabot>      ...
22:28:58 <Jonno_FTW> so like (f1 x, f2 x) ?
22:29:02 <mm_freak> yeah
22:29:14 <Jonno_FTW> nice
22:29:39 <Jonno_FTW> this could come in handy
22:29:52 <Daenyth> d'oh
22:30:23 <Daenyth> so used to dynamic languages
22:30:30 <Daenyth> note: max /= maximum
22:30:35 <Eduard_Munteanu> mm_freak: yeah, that makes sense.
22:30:42 <Jonno_FTW> :t max
22:30:42 <lambdabot> forall a. (Ord a) => a -> a -> a
22:30:47 <Jonno_FTW> :t maximum
22:30:48 <lambdabot> forall a. (Ord a) => [a] -> a
22:30:50 <Eduard_Munteanu> I¬¥m saying C99/POSIX/whatever should do the same.
22:31:18 <EvanR> in dynamic languages you are rewarded by the instant gratification of the program running, followed by an almost instant runtime error punishment
22:31:26 <mm_freak> :t foldl1 max
22:31:26 <lambdabot> forall a. (Ord a) => [a] -> a
22:31:27 <Eduard_Munteanu> (well, actually at least specify sendfile())
22:31:56 <Daenyth> huh odd
22:32:01 <mm_freak> :t \(x:xs) -> foldl max x
22:32:02 <lambdabot> forall a. (Ord a) => [a] -> [a] -> a
22:32:02 <EvanR> in static languages you are rewarded by the instant gratification of showing you the problem before it happens ;)
22:32:07 <mm_freak> uhm
22:32:24 <mm_freak> :t \(x:xs) -> foldl max x xs
22:32:25 <lambdabot> forall a. (Ord a) => [a] -> a
22:32:44 <Daenyth> weird
22:32:53 <Daenyth> oh wait...
22:32:57 <mm_freak> Eduard_Munteanu: they can't do the same easily
22:33:02 <mm_freak> actually POSIX could
22:33:10 <mm_freak> but there is more than POSIX in the world =)
22:33:25 <Eduard_Munteanu> Yeah, POSIX and Windows crap :)
22:33:32 <Eduard_Munteanu> Other than that, there¬¥s little.
22:33:43 <mm_freak> there is a lot
22:33:47 <Daenyth> :/
22:33:48 <mm_freak> unless you define POSIXLY_CORRECT
22:33:51 <Daenyth> why is this running so slow
22:33:57 <mm_freak> Daenyth: what?
22:34:00 <Daenyth> weird...
22:34:01 <Daenyth> sec
22:34:17 <Eduard_Munteanu> mm_freak: well yeah, you¬¥re right on that. Let not discount other (older) stuff, say SVR.
22:35:12 <Daenyth> http://gist.github.com/487064 <- It just hangs at Loading package haskell98...
22:35:26 <Daenyth> The equivalent code in python runs pretty much instantly...
22:36:37 <mm_freak> hmm
22:37:07 <mm_freak> > replicateM 2 [100..999]
22:37:08 <lambdabot>   [[100,100],[100,101],[100,102],[100,103],[100,104],[100,105],[100,106],[100...
22:37:17 <Eduard_Munteanu> There a lot of crunching in there.
22:37:32 <Daenyth> actually I think my python code does even more calculations
22:37:34 <mm_freak> > map (\[x,y] -> x*y) $ replicateM 2 [100..999]
22:37:35 <lambdabot>   [10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11...
22:37:44 <Daenyth> http://github.com/Daenyth/Project-Euler/blob/master/python/euler4.py for ref
22:37:56 <Daenyth> Not sure why I did it quite that way..
22:38:13 <Daenyth> figured I'd improve it in haskell rather than rewriting it :p
22:38:16 <mm_freak> > let isPalindrome = uncurry (==) . (id &&& reverse) . show in filter isPalindrome . map (\[x,y] -> x*y) $ replicateM 2 [100..999]
22:38:17 <lambdabot>   [10201,11211,12221,13231,14241,15251,16261,17271,18281,19291,20402,21412,22...
22:38:25 <mm_freak> > let isPalindrome = uncurry (==) . (id &&& reverse) . show in maximum . filter isPalindrome . map (\[x,y] -> x*y) $ replicateM 2 [100..999]
22:38:27 <lambdabot>   906609
22:38:38 <mm_freak> there you go
22:38:53 <Daenyth> well I already had the answer
22:39:07 <Daenyth> but why did mine hang
22:39:31 <Jonno_FTW> that problem is a simple one-liner
22:39:38 <mm_freak> try without 'nub'
22:40:01 <Daenyth> ah
22:40:05 <Daenyth> yeah that's a fair sight better
22:40:10 <mm_freak> Jonno_FTW: yes, look above =)
22:40:31 <Daenyth> so it was just nub killing it?
22:40:33 <mm_freak> that code should take a couple of milliseconds
22:40:34 <Daenyth> guess that makes sense
22:40:43 <Eduard_Munteanu> nub isn¬¥t that trivial to do.
22:40:50 <Daenyth> lesson learned
22:40:59 <mm_freak> 'nub' is an O(n) space and time operation
22:41:04 <Daenyth> ahh
22:41:06 <mm_freak> so don't do it, unless you really need it
22:41:33 <mm_freak> actually it may well be an O(n^2) time operation without an Ord instance
22:41:45 <mm_freak> and with Ord it should be O(n * log n)
22:41:47 <Daenyth> yeah, for some reason I thought it would be better to weed out the duplicates... I guess when you don't have a mutable structure to store counters in it would get rather expensive
22:42:03 <Daenyth> I'm used to just tossing stuff in a set() or %hash to remove dupes and that's quite fast
22:42:15 <EvanR> myths
22:42:20 <EvanR> haskell has those
22:42:22 <EvanR> they are fast
22:42:24 <Daenyth> well
22:42:26 <mm_freak> don't worry about the duplicates‚Ä¶  remember that haskell is a lazy language
22:42:27 <Daenyth> I haven't learned them yet
22:42:35 <mm_freak> the list you describe doesn't get built in memory at all!
22:42:46 <Daenyth> ah true
22:42:49 <mm_freak> it's translated to a simple loop trying all combinations in O(1) memory
22:42:54 <mm_freak> /unless/ you use 'nub' ;)
22:43:02 <Daenyth> wasn't about memory
22:43:17 <Daenyth> I was thinking cpu-wise
22:43:21 <Daenyth> but apparantly backfired :)
22:43:24 <Daenyth> thanks
22:43:41 <Eduard_Munteanu> @src nub
22:43:41 <lambdabot> nub = nubBy (==)
22:43:52 <Daenyth> ack
22:43:53 <Eduard_Munteanu> Well, that explains it.
22:43:59 <Eduard_Munteanu> @src nubBy
22:43:59 <lambdabot> nubBy eq []             =  []
22:44:00 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
22:44:09 <mm_freak> i'd rather look at the type
22:44:11 <mm_freak> :t nub
22:44:11 <lambdabot> forall a. (Eq a) => [a] -> [a]
22:44:13 <Eduard_Munteanu> O(n¬≤) is big here.
22:44:18 <Daenyth> indeed
22:44:25 <mm_freak> if it used Ord instead of Eq, it could be an O(n * log n) time operation
22:44:26 <Daenyth> no wonder it 'hung'
22:44:35 <Jonno_FTW> Found on article on making palindromes from old ones: http://www.saintmarys.edu/~psmith/palindrome.htm
22:44:37 <mm_freak> it's interesting how the type of a function tells you something about its running time =)
22:44:42 <Daenyth> very
22:44:45 <Eduard_Munteanu> Yeah.
22:45:12 <mm_freak> with an Eq constraint the 'nub' function can't be faster than O(n^2)
22:45:35 <Eduard_Munteanu> It just compares everything with everything.
22:45:48 <mm_freak> no, it builds a list of already seen elements
22:45:50 <Eduard_Munteanu> With Ord you can take advantage of ordering by presorting
22:45:56 <mm_freak> and just walks through
22:46:14 <mm_freak> with an Ord instance on 'a' you could build a binary tree instead of a list
22:46:28 <mxc> mm_freak: why can't you just build a map
22:46:44 <mxc> couldn't you do it in O(n log n)?
22:46:45 <mm_freak> :t M.lookup
22:46:45 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
22:46:53 <mm_freak> mxc: look at the type
22:47:02 <EvanR> alternatively, sort it and walk through and append representatives of the equivalences
22:47:14 <mm_freak> EvanR:
22:47:15 <mxc> oh, oops.. missed the point of what you were saying
22:47:17 <mm_freak> :t sort
22:47:17 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:47:23 <mxc> yeah, wihtout Ord, you're screwed
22:47:24 <EvanR> yes, Ord
22:47:27 <Daenyth> oh
22:47:38 <Daenyth> it also appears that my memory of the python running time was off
22:47:49 <Daenyth> it's about 3 times slower than my haskell version
22:47:54 <Eduard_Munteanu> Ha.
22:47:56 <Daenyth> so yeah, mystery quite solved
22:48:00 <EvanR> 3x is nothing
22:48:03 <mm_freak> Daenyth: i'd be surprised if the python version would be faster ;)
22:48:21 <mm_freak> Daenyth: try to compile the program with -O2 and then compare again
22:48:21 <Daenyth> mm_freak: that's how I felt. Ran them both timed to sanity-check
22:49:01 <Daenyth> ghc --make -O2?
22:49:06 <mm_freak> :t map head . group . sort
22:49:07 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:49:37 <EvanR> nub is a sham!
22:49:48 <mm_freak> Daenyth: yeah
22:49:57 <Daenyth> mm yeah
22:50:08 <Daenyth> reduces realtime by about .1
22:50:13 <Daenyth> on a hot run
22:50:16 <Daenyth> cold is about the same it seems
22:50:36 <mm_freak> Daenyth: use larger numbers
22:50:41 <Daenyth> probably
22:50:55 <mm_freak> it's difficult to compare running times in the range of milliseconds =)
22:50:59 <Eduard_Munteanu> So there¬¥s no standard nub that takes Ord?
22:51:07 <mm_freak> note that both haskell programs and python programs have a certain startup time
22:51:31 <mm_freak> Eduard_Munteanu: standard nub requires Eq
22:51:47 <Eduard_Munteanu> Yeah, I meant a variant of that in Prelude.
22:51:54 <Eduard_Munteanu> @hoogle nub
22:51:54 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
22:51:55 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
22:52:17 <Eduard_Munteanu> Not really helpful.
22:52:26 <mm_freak> don't think so
22:52:43 <mm_freak> EvanR: btw, your sorting method has one major disadvantage over the incremental tree building
22:52:50 <mm_freak> it's strict in the entire list
22:52:55 <mm_freak> 'nub' should be lazy
22:53:01 <mm_freak> > take 10 $ nub [1..]
22:53:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:53:08 <EvanR> ah
22:53:50 <EvanR> so if you give my method an infinite list, it will never give even one of the unique items
22:53:59 <EvanR> but nub will give them one at a time
22:54:05 <mm_freak> > take 10 . map head . group . sort $ [1..]
22:54:12 <lambdabot>   mueval: ExitFailure 1
22:54:33 <mm_freak> nub never hangs
22:54:35 <EvanR> > take 10 . nub $ [1..]
22:54:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:54:47 <EvanR> interesting
22:54:47 <mm_freak> unless there are only duplicates left
22:54:51 <Eduard_Munteanu> You could intersperse sorting somehow.
22:55:10 <Eduard_Munteanu> Each sorting step can bring the element in the final position.
22:55:12 <mm_freak> > take 10 . nub $ [1..10] ++ repeat 1
22:55:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:55:20 <Cale> You can build a set of elements as you go
22:56:34 <mm_freak> > take 11 . nub $ [1..10] ++ replicate 100000 1 ++ [11]
22:56:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
22:57:28 <Cale> > let uniq = uniq' S.empty where uniq' s [] = []; uniq' s (x:xs) | x `S.member` s = uniq' s xs | otherwise = x : uniq' (S.insert x s) xs in uniq [1..]
22:57:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:57:43 <Cale> :t let uniq = uniq' S.empty where uniq' s [] = []; uniq' s (x:xs) | x `S.member` s = uniq' s xs | otherwise = x : uniq' (S.insert x s) xs in uniq
22:57:45 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:58:40 <Eduard_Munteanu> :t S.member
22:58:41 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
22:59:14 <Eduard_Munteanu> Nice way of doing it.
22:59:33 <Eduard_Munteanu> (I suppose it preserves initial ordering too, right?)
22:59:36 <mm_freak> Eduard_Munteanu: the standard Eq-based 'nub' does exactly that, but with a list instead of a Seq =)
22:59:39 <Cale> Yes
22:59:55 <Cale> (As any lazy version of nub should)
23:00:35 <Eduard_Munteanu> Well, in this case S.member is the brains.
23:01:02 <RayNbow> hmm... what's the best approach to upgrade the Haskell platform? Uninstall/install?
23:01:18 <mm_freak> > let uniq' lst [] = []; uniq' lst (x:xs) | x `elem` lst = uniq' lst xs | otherwise = x : uniq' (x:lst) xs; uniq = uniq' [] in uniq [1..]
23:01:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:01:24 <mm_freak> > let uniq' lst [] = []; uniq' lst (x:xs) | x `elem` lst = uniq' lst xs | otherwise = x : uniq' (x:lst) xs; uniq = uniq' [] in uniq [1,2,3,2,1]
23:01:25 <lambdabot>   [1,2,3]
23:01:51 <Cale> The set version will take only O(k log k) time to process the first k elements of the list, rather than O(k^2) time.
23:02:04 <Cale> But it requires Ord rather than simply Eq
23:03:10 <mm_freak> Ord denotes total orders, right?
23:04:16 <Eduard_Munteanu> Well, it can¬¥t otherwise.
23:04:29 <Cale> mm_freak: right
23:04:29 <Eduard_Munteanu> Any two members of that must be comparable.
23:04:39 <mm_freak> yeah, sort would probably go crazy otherwise
23:05:05 <Cale> sort does funny things when the Ord instance is some other relation :)
23:05:17 <mm_freak> Eduard_Munteanu: in a partial order, every pair of elements is comparable
23:05:30 <RayNbow> > compare undefined undefined
23:05:31 <lambdabot>   *Exception: Prelude.undefined
23:05:40 <Eduard_Munteanu> Hm, I got it wrong then.
23:05:45 <Eduard_Munteanu> What was the difference?
23:05:49 <PetRat> I think I need to use liftIO but could someone help with this ---> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27995#a27995
23:06:03 <Axman6> > compare (error "first") (error "second")
23:06:04 <lambdabot>   *Exception: first
23:06:35 <mm_freak> Eduard_Munteanu: in a partial order, this is allowed:  x > y == False, x < y == False
23:06:52 <Eduard_Munteanu> mm_freak: oh, that makes sense now.
23:07:16 <mm_freak> for example, definedness of a haskell values is a partial order =)
23:07:35 <mm_freak> because 1 > 2 is false and 2 < 1 is false, too
23:07:48 <Daenyth> ah, here we go. Made my PE#4.py suck less: http://github.com/Daenyth/Project-Euler/commit/b2de222649c988ce9537080eeb754f4af500424d
23:08:38 <OrangeSky> Gah, OS X dynamic libraries still broken on the new Haskell Platform
23:09:16 <mm_freak> PetRat: first get the cursor using 'get' in the StateT
23:09:32 <mm_freak> then get its value using liftIO . readIORef
23:10:14 <Daenyth> night all
23:10:32 <mm_freak> night Daenyth 
23:10:48 <Daenyth> Thanks for the help :)
23:10:55 <dons> OrangeSky: file a bug on the ghc trac, then file a bug on the platform trac, and cross-link
23:11:03 <PetRat> mm_freak: thanks
23:12:24 <OrangeSky> dons: OK, thanks!
23:16:40 <CakeProphet> -gasp- GHC has bugs?
23:20:52 <dons> CakeProphet: well the installer might not set it up so that dynamically linked libraries are easy, for  example
23:20:59 <dons> and it probably has bugs :)
23:24:52 <PetRat> I'm confused about some more stuff.. don't know what to do where ??? are  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27995#a27996
23:29:12 <OrangeSky> dons: http://trac.haskell.org/haskell-platform/ticket/132 is my ticket, going to try installing GHC from source before posting a GHC Bug
23:29:19 <PetRat> Oh, I think I see one thing. I want to use evalState, not execState, so that it has the type IO
23:34:59 <PetRat> sorry, got kicked off. If someone answered me I didn't see it
23:35:33 <aleator> Oh. phooie. control.concurrent.speculation gives me segfault instead of speedup :(
23:38:29 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27997#a27997   any suggestions how to make this faster?  I notice changing line 29 to just B.words slows it down by 2x instead of speeding it up as one would expect
23:39:58 <solrize> hmm turning of all the profiling makes it 6x faster
23:40:52 <aleator> solrize: It usually does. Tried ghc-gc-tune yet? (Made my program faster so now I just blankly recommend it to everyone else :)
23:41:06 <solrize> haven't
23:41:14 <solrize> googling
23:41:22 <aleator> comes from cabal.
23:42:05 <solrize> cabal updating
23:42:11 <solrize> looking at dons' blog post about it
23:44:12 <solrize> hmm
23:44:13 <solrize> Downloading the latest package list from hackage.haskell.org
23:44:13 <solrize> Note: there is a new version of cabal-install available.
23:44:13 <solrize> To upgrade, run: cabal install cabal-install
23:44:22 <luite> hmm, why does the windows version of the haskell platform still ship mingw gcc 3.4.5? are there problems with later versions? (the latest is gcc-4.5.0-1-mingw32)
23:44:24 <solrize> i installed the new cabal-install but stillget that message
23:44:52 <luite> solrize: make sure that the bin dir where cabal installs its executables comes before the haskell platform dir
23:44:55 <luite> in your PATH
23:45:06 <solrize> hmm
23:45:31 <solrize> doesn't look like there's a haskell platform dir in my path, just a cabal dir
23:46:17 <solrize> i guess haskell platform is where ghc is?
23:46:20 <solrize> that would be /usr/bin
23:46:26 <solrize> so i should put the cabal dir before that?
23:46:26 <solrize> ok
23:47:16 <luite> oh sorry, I thought you were using windows
23:47:24 <solrize> fedora
23:47:31 <solrize> but, that seems to have helped
23:47:33 <luite> just add ~/.cabal/bin before /usr/bin then
23:47:41 <solrize> yeah i did that
23:47:43 <solrize> thanks
23:47:51 <solrize>     unknown flag in  {-# OPTIONS #-} pragma: -fno-warn-unused-do-bin
23:47:55 <solrize> seems to want a new ghc?
23:49:19 <solrize> downloading new ghc, .....
23:50:13 <luite> I usually install new ghc versions in my home dir
23:50:52 <solrize> i guess i could do that... i'm downloading the 100+MB binary which will take a while
23:51:00 <Axman6> aleator: what is ghc-gc-tune?
23:51:09 <solrize> http://donsbot.wordpress.com/2010/07/05/ghc-gc-tune-tuning-haskell-gc-settings-for-fun-and-profit/
23:51:11 <solrize> it looks great
23:51:27 <Axman6> oh, he made a package for that, awesome
23:51:44 <luite> oh fancy 3d plot
23:51:48 <luite> with colors even
23:51:49 <luite> :)
23:52:18 <aleator> Axman6: Its thing that grid-searches gc parameters
23:54:20 <luite> the parameters may be cpu-dependent though, I have the impression that increasing the allocation area often helps, but that it works best if it still fits within the CPU cache
23:55:47 <solrize> anyway, gc isn't that much of a time sink in this code, i think data.map and bytestring.words are the culprits
23:56:27 <solrize> and i can't help thinking there are some fusion opportunities that supercompilation could find ;)
23:56:46 <lispy> solrize: have you benchmarked it?
23:56:57 <lispy> solrize: Actually, I meant to say profiled
23:57:25 <solrize> yes
23:57:41 <solrize> though, profiling slows it down quite a bit
23:58:47 <lispy> warn-unused-do-bind is an insanely annoying warning.  I really wish it was not enabled with -Wall
23:59:20 <solrize> bytestring-trie
23:59:36 <solrize> lispy hmm you mean i don't need to install new platform? i probably should anyway...
23:59:36 <aleator> I wonder if profiling slows down all code evenly, or some pieces code more than others..
