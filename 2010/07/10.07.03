00:00:13 <Cale> ddarius: Not much that made any money, a few small jobs here and there :)
00:00:50 <kmc> i don't think Haskell is the solution to all the world's problems, but i'd like to specialize in those problems to which it is a solution
00:01:05 * ddarius doesn't care about technology used too much.
00:02:39 <napping> catenate: anyway, basic Haskell testing practice is quickcheck, and then organize quickcheck runs and fixed examples with HUnit as needed
00:03:15 <catenate> Probably one of the best things I could do is to contribute to Haskell open-source projects, short of a real job using it.
00:03:37 <catenate> napping: that's a good takeaway, thanks
00:03:51 <napping> fancy practice is program extraction from Coq :)
00:03:58 <Cale> catenate: While there's not a lot of Haskell jobs as of yet, I'd imagine there's also not *too* much competition for them. I didn't have to go searching for either of the Haskell jobs I've had.
00:03:59 <ddarius> catenate: Probably one of the best things you could do is go out into your community and meet people and try to help them.
00:04:39 <ddarius> Cale: On the one hand, there are less applicants, on the other, the median applicant is probably massively more qualified.
00:04:53 <Cale> That's true
00:05:02 <kmc> yeah, i think it's still quite competitive
00:05:05 <catenate> ddarius: well yeah, in general
00:05:15 <Cale> Competitive in that sense, sure :)
00:05:17 <kmc> if you're hiring Haskellers you won't get (or will have a very easy time filtering out) the usual flood of massively unqualified candidates
00:05:28 <kmc> but i think the shortlist is still pretty crowded
00:05:50 <kmc> just less pruning is needed before the shortlist
00:06:35 <catenate> So what is the minimum qualification to be seriously considered?  Worked through RWH?  Contributed to open-source projects?  Wrote a library?  Wrote xmonad?  Wrote a financial app?
00:07:59 <kmc> catenate, there's been a haskell-cafe thread about this recently
00:08:10 <kmc> and i think dcoutts said he'd do a short writeup of their experience hiring Haskellers recently
00:08:12 <catenate> I'll look that up, thanks
00:09:10 <kmc> dons said that it's important to answer questions on haskell-cafe and stack overflow, to be visible
00:09:16 <kmc> and to write libraries and upload them to hackage
00:09:29 <ddarius> catenate: Being more active in the Haskell community, and in particular, producing or maintaining libraries is definitely something to set yourself apart.
00:13:14 <kmc> does helping people on IRC count for anything?
00:13:32 <Cale> Seems to :)
00:13:50 <napping> consulting might be a bit of a different story
00:14:08 * kmc much prefers helping people here versus email or web fora
00:14:12 <Amagineer> Can one write apps for an android device with Haskell?
00:14:14 <napping> If you have to be able to convince the clients that your consultants are experts
00:14:32 <kmc> Amagineer, i'm working on it
00:14:36 <Amagineer> Yay :​D
00:14:45 <napping> kmc: native code called from a wrapper?
00:14:46 <Amagineer> How far along is it?
00:14:50 <kmc> yes
00:15:01 <ddarius> kmc: If you are recognized as being knowledgeable it can't hurt.  Heck, if you are recognizable at all.  But if you are producing libraries the interviewer is likely to think "Well, he just needs to keep doing what he's already doing."
00:15:16 <catenate> Hm, hackage is for released packages, is there a github like community development repository?
00:15:17 <kmc> yeah ddarius, makes sense
00:15:26 <kmc> i was more wondering IRC vs email/SO, not vs. writing libraries
00:15:51 <napping> catenate: github seems reasonably popular
00:16:56 <catenate> I use github currently, just wondering if haskellers use something else generally, since github doesn't use darcs
00:17:07 <ddarius> catenate: You can use something like github or patch-tag, you can also request an account on the community server, though that's much more heavy-weight.
00:17:09 <kmc> Amagineer, basic test programs work, some more complicated stuff segfaults, haven't debugged it yet
00:17:17 <kmc> Amagineer, it's coming along pretty nicely
00:17:36 <napping> kmc: you ported the runtime?
00:17:37 <ddarius> catenate: Also, you can more or less put whatever you want onto Hackage.
00:17:44 <kmc> napping, not much was required but yes
00:17:56 <ddarius> catenate: That's how edwardk has been doing development (albeit the repositories are elsewhere)
00:18:00 <napping> well, that's the only place segfaults ought to come from
00:18:10 <kmc> napping, ought
00:18:14 <napping> rather, ought to be the only place segfaults can come from
00:19:31 <kmc> napping, is there a specific step of porting the runtime i may have overlooked?
00:20:19 <napping> I haven't tried porting it.
00:20:26 <kmc> it's GHC as an unregisterised via-C compiler; we configure for ARM Linux, then take the .hc files and build them with the Android toolchain
00:20:47 <napping> your programs as well?
00:22:07 <kmc> yes
00:22:19 <kmc> there are lots of wrinkles but that's the short of it
00:22:44 <napping> I haven't touched that stuff for a while
00:23:07 <kmc> Amagineer, i'm doing this work for iPwn Studios, RyanT5000's company.  but we expect it'll be open-source when finished, similar to http://projects.haskell.org/ghc-iphone/
00:23:12 <napping> Is there some difficulty seeing where it crashes?
00:23:27 <Amagineer> Awesome
00:24:42 <kmc> napping, as i said, i've spent no time at all debugging the segfault
00:24:45 <kmc> it might be something really obvious
00:24:49 <napping> ah, ok.
00:25:07 <napping> probably best to catch it in gdb or whatever, rather than have me guess
00:25:09 <kmc> there is a little difficulty -- how to hook gdb onto the android process -- but i think this is a solved problem
00:27:49 <catenate> Cale/kmc: how are you dealing with Apple's anti-compiler policy of no-other-lang-than-C/OjectiveC?
00:28:34 <catenate> oh, you just answered that, sorry
00:28:35 <kmc> catenate, i'm not dealing with it personally
00:28:39 <kmc> we did?
00:29:07 <catenate> oh, that was for android
00:29:08 <Jafet> It's up to apple whether via-C is a valid use of C
00:29:18 <kmc> it's up to apple whether they let your app in, period
00:29:24 <kmc> "wrong language" is just another excuse they can use
00:29:30 <Jafet> Well yes; either they kick you off or they don't care
00:29:45 <kmc> they had absolute power before the rule change and they have absolute power now
00:29:59 <kmc> and they are being inconsistent about the new rule -- using it to further their agenda, as you expect
00:30:09 <kmc> so the basic idea is to make a game good enough that apple will want it
00:30:33 <catenate> Freedom from crappy apps like yours must be if they don't let it on, ipso facto
00:30:47 <kmc> freedom is slavery
00:30:58 <catenate> war is peace
00:31:11 <napping> they changed the language a bit recently anyway, to make it a bit more clear that it's about screwing adobe and beating down cross-platform toolkits than a sudden allergy to interesting programming languages
00:32:14 <catenate> ignorance becomes knowledge, light becomes darkness, here at Miskatonic U
00:32:19 <kmc> haha
00:33:15 <napping> catenate: The Lurking Horror?
00:33:57 <catenate> I think so.  I got it from the parking permit sticker on my car, in Latin
00:37:44 <napping> best to avoid parking in Arkham
00:39:28 <catenate> Lot omega is not so bad: the shambling horrors move slow, and ignore the cars since they're not soft and squishy and have no brraaaaaaains
01:45:01 * hackagebot cassandra-thrift 0.0.3 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.0.3 (KirkPeterson)
01:58:57 <augur> is there a name for complement unification like so: unify(a, ~b) iff !unify(a, b)?
02:00:12 <kmc> hmm, that's an interesting notion
02:00:19 <kmc> do you have an example where it'd be useful?
02:00:25 <augur> which would basically just be a sort of compression of unify(a, X) & !unify(X, b)
02:01:17 <augur> well, im building an inference engine that lets you define rules of inference/rewrite operations, which have conditions on their contents, right
02:02:11 <augur> so you might want for some reason an inference rule like, F => (F,J) if F = (J*~a)
02:02:32 <augur> er, (J,~a) sorry
02:02:43 <augur> which is to say that you can replace F with (F,J) just in case F is a pair (J,K) where K is NOT a
02:02:46 <Blkt> good day everyone
02:03:01 <augur> so you can do (a,b) => ((a,b),b) but you cant do (b,a) => ((b,a),a)
02:03:06 <augur> hello Blkt
02:03:35 <Blkt> hello
02:04:02 <augur> kmc: its basically just unification as failure, i guess, but a shorthand notation for a particular kind
02:04:46 <augur> or should i just require that thats explicitely stated? e.g. F => (F,J) if F = (J,K) and K != a
02:04:48 <augur> ?
02:04:59 <kmc> hi Blkt
02:05:07 <Blkt> hi kmc 
02:06:15 <monadic_kid> http://www.reddit.com/r/programming/comments/cl7b1/xensource_since_acquired_by_citrix_and_their/c0tddoi
02:06:52 <monadic_kid> boycott!
02:07:39 <Jafet> girlcott
02:07:50 <kmc> monadic_kid, what are you getting at
02:08:23 <kmc> jdh is a well-known troll
02:09:34 <monadic_kid> for too long
02:09:56 <Blkt> who is jdh?
02:10:07 <kmc> a well-known troll
02:10:25 <dv-> and a communist!
02:10:35 <Blkt> lol
02:10:48 <kmc> "My son Homer is not a communist. He may be a liar, a pig, a communist, but he’s *not* a porn star."
02:12:29 <jkramer_> Ahoy
02:12:31 <kmc> @remember daybreaker Haskell is the Ron Paul of programming languages.
02:12:31 <lambdabot> Done.
02:12:35 <kmc> hi jkramer_
02:13:43 <augur> no opinion, huh kmc? :\
02:13:46 <jkramer_> I'm getting theses warnings when building my lib with cabal: http://pastie.org/1029152
02:14:22 <jkramer_> How can I get rid of them? I don't see any prelude/base specific code in my files, especially not in line 1, which is empty
02:14:31 <dv-> Wouldn't Ron Paul be the D of programming languages?
02:15:22 <kmc> jkramer_, iirc, the solution is to add an explicit "base" requirement to your .cabal file
02:15:31 <kmc> base >= 4 && < 5
02:15:49 <kmc> for ugly backwards-compatibility reasons, the default is 3
02:15:54 <jkramer_> Ah
02:16:25 <jkramer_> Yay, works, thank you :)
02:19:17 <jkramer_> Ok, another question: is there a way to detect non-exhaustive patterns at compile time and abort compilation?
02:19:59 <kmc> -Wall -Werror
02:20:19 <kmc> or more specifically: ghc -fwarn-incomplete-patterns -Werror
02:20:25 <jkramer_> I have a function "makeNonEmptyList (x:xs) = NonEmptyList x xs", and I want ghc to abort compilation when it's called with []
02:20:37 <jkramer_> kmc: Can I specify those in my code?
02:20:54 <kmc> oh, this will cause an error when compiling makeNonEmptyList
02:21:02 <jkramer_> Or is there a better solution for this?
02:21:17 <kmc> you can't in general know at compile time if an argument to that function is []
02:21:59 <jkramer_> Hrm
02:22:10 <jkramer_> Is there another/better approach to enforcing non-empty lists?
02:22:13 <kmc> yes
02:22:22 <kmc> data NonEmptyList a = Nil a | Cons a (NonEmptyList a)
02:22:26 <kmc> probably exists in some library
02:22:56 <kmc> alternatively: data NEList a = NEList a [a]
02:23:05 <kmc> or even: type NEList a = (a, [a])
02:23:14 <kmc> i'd probably go with the second of those three
02:23:15 <jkramer_> That's what I currently have
02:23:30 <jkramer_> data NEL a = NEL (a, [a]) deriving (Eq, Show)
02:23:35 <kmc> ah, and makeNonEmptyList is the function that builds one?
02:23:39 <jkramer_> Yup
02:24:01 <kmc> well... it can't be a total function for obvious reasons
02:24:17 <jkramer_> Well, not exactly, the function was just an example. The real one looks like this: toNEL (x:xs) = NEL (x, xs)
02:24:25 <kmc> you could of course give it the type «a → [a] → NEL a»
02:24:28 <jkramer_> But it's pretty much the same
02:24:41 <kmc> in either of two ways: the first value is the first element, or the first value is a default to be used only if the second value is empty
02:24:52 <kmc> the latter is a bit like fromMaybe
02:25:03 <jkramer_> Yeah, but I think it wouldn't be so nice to use for the API user
02:25:41 <kmc> why do you want the API user to pass in a list?
02:25:46 <kmc> just syntax?
02:26:43 <jkramer_> Well, the functions that take NELs as argument take several other arguments, including other NELs, and writing "(toNEL first rest)" all the time is a bit noisy
02:26:57 <kmc> compared to which alternative?
02:27:02 <jkramer_> Especially when you have a list and you need to split off the first element first manually
02:27:20 <jkramer_> (toNEL xs) :)
02:27:43 <kmc> so you assume the user already has lists they want to pass?
02:27:44 <kmc> why?
02:27:52 <kmc> why not have the user work with NELs from the beginning
02:27:57 <jkramer_> Here's an example: selectSQL :: QuoteStyle -> NEL SQL -> NEL SQL -> Criterion -> String
02:27:57 <kmc> using functions which preserve non-emptiness
02:28:38 <kmc> perhaps you'd have a nicer time with «data NEL a = a :! [a]»
02:28:53 <kmc> this way you can write a NEL as «first :! rest» or «a :! b : c : d : []»
02:28:55 <jkramer_> What's :! ?
02:29:05 <kmc> it's an infix data constructor you're defining there
02:29:05 <Cale> Personally, I find that nonempty lists as a separate type is often pushing it a bit as far as the type safety/convenience line goes.
02:29:10 <jkramer_> Ah
02:29:21 <kmc> symbols starting with : are "uppercase"
02:30:24 <jkramer_> The problem is that the user will have most of the parameters he'll want to use with the functions in lists, so he'd have to take the list, split off the first element and build the NEL manually
02:30:41 <kmc> "the user will have most of the parameters he'll want to use with the functions in lists" ← why?
02:30:47 <Cale> jkramer_: Right, and none of the usual operations on lists will work for NELs
02:31:14 <jkramer_> kmc: Well, it's a lib for building SQL, so you'll have a lot of lists of columns, column/value pairs in list, tables etc
02:31:26 <kmc> why not have an NEL of columns, column/value pairs in NEL, etc.
02:31:56 <kmc> it defeats the purpose totally to have the user make every NEL from a list
02:32:21 <jkramer_> Well the actual problem is not the NEL itself, I just don't want to allow empty list of columns etc. to be passed into my functions because that would generate invalid SQL
02:32:46 <kmc> well you can reject the empty list at runtime easily
02:32:56 <kmc> and throw an exception, or return results in Maybe or (Either MyErrorType) etc
02:33:04 <Cale> Yeah, just do a dynamic check.
02:33:12 <jkramer_> Sure, but I have a dream of having most of the SQL validated at compile time :)
02:33:30 <kmc> then it defeats your purpose entirely to have the user pass in regular lists
02:33:33 <Cale> It's theoretically possible to make this stuff work out at compile time, but probably more trouble than you want.
02:34:02 <kmc> you'd want the user to think entirely in terms of NEL, and to provide a library for NEL operations which is as rich as the standard list librari
02:34:15 <kmc> (there are some such libraries on hackage; i don't know if they're good)
02:34:37 <kmc> basically as soon as you use the conversion «[a] → NEL a» you have lost static checking
02:34:56 <Cale> If you use a -> [a] -> NEL a, then you're fine :)
02:35:05 <jkramer_> http://hackage.haskell.org/packages/archive/NonEmpty/0.1/doc/html/Data-List-NonEmpty.html
02:35:34 <Cale> ouch :)
02:35:56 <jkramer_> http://hackage.haskell.org/packages/archive/NonEmptyList/0.0.8/doc/html/Data-List-NonEmpty.html
02:36:12 <jkramer_> Same namespace, but two packages?
02:36:26 <kmc> jkramer_, another option is «data Z; data S a; data List n a where { Nil :: List Z a; Cons :: a -> List n a -> List (S n) a }
02:36:28 <kmc> »
02:36:31 <kmc> this is more complicated clearly
02:36:46 <jkramer_> Yeah, I don't understand a word :)
02:36:48 <kmc> you encode the exact length of the list into its type
02:37:09 <kmc> there's bound to be a library for that too — i don't remember if HList has it, it might
02:37:24 <Cale> You could also reasonably encode a minimum length into the type.
02:37:48 <Cale> "reasonably"
02:38:14 <Cale> It would be more reasonable with proper support for arithmetic at the type level
02:38:19 <kmc> yeah
02:38:24 <kmc> it'd be more reasonable in she
02:38:25 <kmc> @where she
02:38:25 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
02:39:06 <Jafet> I approve of that name
02:39:30 <kmc> jkramer_, to my knowledge there is no static analysis system for Haskell ∗other than the type system∗ which can prove things like nonemptiness of a list
02:39:43 <kmc> and you've already seen a few ways to encode that in the type system, each with its drawbacks
02:40:19 <jkramer_> Yup, thanks
02:40:37 <jkramer_> I think I'll stick with toNEL [] = error "foo" for now, I need to get things running first :)
02:40:40 <dolio> There are others.
02:40:55 <kmc> if your objections are purely syntactic, there may be a syntactic solution
02:41:10 <jkramer_> Like :! ?
02:41:19 <kmc> a small example yess
02:41:31 <kmc> (or any other infix constructor you like to define)
02:41:36 <kmc> :! is just my example
02:41:46 <jkramer_> Yup
02:41:50 <kmc> most symbols starting with : are acceptable
02:41:52 <kmc> regrettably not ::
02:43:12 <jkramer_> I think if I'd have the user use a syntax like foo :! bar :! ... from the beginning, it might actually be nice and not too noisy
02:43:47 <kmc> jkramer_, if you really want to statically validate SQL-producing programs, i imagine you'll want more than just nonemptiness of lists
02:43:58 <kmc> for example, matching types of a row to a table schema
02:45:04 <kmc> Takusen is a database library co-authored by Oleg Kiselyov, the grandmaster of type hackery
02:45:09 <kmc> i don't know how much validation it does
02:45:15 <jkramer_> kmc: That's the plan for later, but for now I just want to generate SQL in a nice way
02:45:19 <kmc> i think the safety focus is more on resource bracketing
02:45:44 <jkramer_> I don't handle database connections at this time, I just generate SQL statements
02:45:48 <kmc> ok
02:46:06 <kmc> didn't you get the memo, SQL is dying ;)
02:46:17 <jkramer_> The plan is to build something similar to SQL::Abstract on CPAN
02:46:24 <jkramer_> Hehe, yeah
02:47:08 <jkramer_> But I'm still waiting for a NoSQL DB that takes the output of show as record description :)
02:47:16 <jkramer_> Currently most of them us JS
02:47:25 <jkramer_> ie JSON
02:47:49 <kmc> heh
02:48:20 <jkramer_> Wouldn't that be cool, having anything deriving (Show) be a valid storable record? :)
02:48:46 <jkramer_> And retrieve any data structure deriving Read back from the DB
02:48:55 <Darthreborn> guys i have quickcheck v1 and v2 installed...i want to import the v1 file how do i do that?
02:50:31 <kmc> jkramer_, you could make a derivable typeclass for JSONifying / deJSONifying data
02:50:50 <kmc> using a system like http://hackage.haskell.org/package/derive
02:51:13 <kmc> this btw is absolute magic, you just write one instance for one particular example type, and it learns how to derive instances for every type
02:53:42 <McManiaC> is there an easy way to define an Applicative instance with WrappedMonad?
02:54:12 <kmc> what do you mean?
02:54:35 <dolio> Not any easier than just using return and ap.
02:54:44 <kmc> for any Monad M, you can define an Applicative instance for M by pure copy-paste
02:54:58 <kmc> «instance Applicative M where { pure = return; (<*>) = ap }»
02:55:34 <kmc> unfortunately Haskell instance resolution is simple and lacks backtracking so this can't be realized as one general instance
02:55:56 <jkramer_> Oh noes, Omar is dead :(
02:56:04 <Tomsik> Lord Omar?
02:56:10 <jkramer_> Wrong channel :)
02:56:13 <kmc> omar little?
02:56:18 <jkramer_> Yeah
02:56:20 <Tomsik> Ravenhaust?
02:56:36 <kmc> that's a bit old news
02:56:37 <McManiaC> instance (Functor m, Monad m) => Applicative m where { pure  = return; (<*>) = ap } -- why is there no such thing in applicative? :S
02:56:51 <kmc> McManiaC, because Haskell instance resolution is simple and lacks backtracking
02:57:00 <kmc> that instance would overlap with every other
02:57:20 <McManiaC> hmm
02:57:23 <jkramer_> kmc: I'm watching the german synced version, that episode was just aired here :)
02:57:29 <kmc> ah jkramer_
02:58:27 <Heffalump> jkramer_: I've written something fairly similar to SQL::Abstract, but making it type safe proved a little hairy
02:58:36 <jkramer_> I'm stuck a little with my implementation of :!
02:58:47 <jkramer_> Heffalump: Is it on hackage?
02:58:58 <kmc> McManiaC, i can explain further if desired
02:59:51 <jkramer_> So to make :! behave like :, I'd need to have some kind of empty list for my non-empty list for the final part of "foo :! bar :! baz :! EndOfList"
03:00:11 <kmc> jkramer_, i was thinking «data NEL a = a :! [a]»
03:00:15 <jkramer_> But that would allow the user to build empty lists again by simply using the EndOfList constructor :)
03:00:16 <kmc> so you'd have only one :! in a given list
03:00:32 <jkramer_> Oh
03:00:33 <kmc> a :! b : c : d : []
03:00:35 <Heffalump> jkramer_: no, but it is on code.haskell.org
03:00:39 <Heffalump> called squiggle
03:00:39 <jkramer_> So simple :D
03:00:53 <kmc> alternatively: «data NEL a = End a | a :! (NEL a)»
03:02:14 <jkramer_> kmc: Then the syntax would be "foo :! [bar, baz]" ?
03:02:25 <kmc> for which version?
03:02:33 <jkramer_> The first one
03:02:35 <kmc> yes
03:02:47 <jkramer_> I think I'll try the latter first :)
03:02:48 <kmc> or «foo :! bar : baz : []» or «foo :! bar : [baz]»
03:03:06 <Heffalump> I didn't try to do anything with non-empty lists though
03:03:18 <kmc> (assuming you set appropriate precedence for :!)
03:04:00 <jkramer_> And the latter would be: foo :! bar :! baz :! End quux ?
03:04:04 <kmc> yes
03:04:17 <McManiaC> kmc: I understood, thx ;)
03:04:26 <kmc> :)
03:05:20 <kmc> i'm not sure why GHC doesn't have an extension for backtracking typeclass resolution
03:05:28 <kmc> it probably breaks some other desired properties
03:05:32 <kmc> but so do other extensions ;P
03:06:14 <McManiaC> hehe
03:06:43 <kmc> http://research.microsoft.com/en-us/um/people/simonpj/papers/type-class-design-space/ discusses these issues in depth
03:08:17 <kmc> woah, Google bought ITA Software
03:10:32 <McManiaC> hm hm hm
03:20:12 <ezyang> yup 
03:20:32 <ezyang> It's kind of cool, since I interned there last summer. 
03:20:48 <ezyang> though I didn’t touch much of the Lisp culture there. 
03:23:19 <jkramer_> How do I give :! proper precedence?
03:23:56 <ezyang> Do fixity declarations work for type functions? 
03:24:48 <jkramer_> So that in 1 :! 2 : 3 : [], 2 : 3 : [] is evaluated first
03:25:00 <jkramer_> As in 1 :! ( 2 : 3 : [])
03:25:34 <ezyang> jkramer_: I thought identifiers that started with : must be for types. (goes and checks) 
03:25:42 <jkramer_> Yeah
03:25:54 <jkramer_> The definition is data NEL a = a :! [a] deriving (Show, Eq)
03:26:13 <ezyang> ah 
03:26:30 <ezyang> I bet fixity declarations will work. 
03:26:40 <jkramer_> How do I do that? :)
03:26:55 <ezyang> infixl; infixr 
03:26:59 <ezyang> I don't remember which one you want. 
03:27:20 <ezyang> but : appears to be infixr 5 
03:28:22 <jkramer_> Yeah, infixr 5 :! works, thank you :)
03:28:29 <ezyang> cool. 
03:30:21 * ezyang should get off his lazy butt and read some papers. 
03:47:20 <Saizan> jkramer_: it's not a matter of evaluation though
03:47:34 * ManateeLazyCat pasted "SerializedEvent.hsc" at http://paste2.org/get/902012
03:47:35 <ManateeLazyCat> I have above library, i have problem on "Show" "Read" instance for SerializedWindow, because SerializedWindow field (DrawWindow) is pointer, so i want show always with "SerializedWindow Nothing", and always got "SerializedWindow Nothing" in readsPrec. When i run my program, i got error "Prelude.read: no parse", i think my "Read SerializedWindow" is wrong, how to correct it?
03:48:16 <ManateeLazyCat> I want always return "SerializedWindow Nothing" and don't care the value that *reads* return.
03:48:51 * kmc . o O ( data Exists f where { Witness :: f a → Exists f } )
03:49:03 <kmc> how does this compare to true first-class existentials, say in GHC's type system?
03:49:25 <kmc> it's inferior syntactically, but is there a more fundamental difficulty?
03:50:02 <ezyang> ManateeLazyCat: Can you just not use reads, in that case? 
03:50:08 <Saizan> what do you mean by "GHC's type system"? System Fc ?
03:54:03 <ManateeLazyCat> ezyang: I still got same error "Prelude.read no parse" after i remove *reads* code.
03:54:30 <ezyang> hmm, perhaps I forget what the minimal valid instance for Read is. 
03:55:54 <kmc> Saizan, the type system of Haskell as accepted by GHC with all extensions turned on
03:56:07 <kmc> should have said "GHC Haskell's type system"
03:56:37 <Saizan> ah, well, you're using GHC's existentials to define that Exists
03:56:57 <kmc> yeah
03:56:59 <Saizan> maybe you're asking if with that since Exists you can subsume all other uses?
03:57:05 <Saizan> *single
03:57:17 <kmc> well i'm pretty sure you can
03:57:39 <kmc> i'm comparing this Exists with the actual "exists a." quantifier in some other Haskell implementations
03:57:39 <Saizan> how do you quantify over something of kind e.g. * -> * ?
03:58:14 <kmc> and wondering if "exists a." is nicer only syntactically, or if there's a more fundamental difference
03:58:27 <kmc> but you've pointed out another, which is the lack of kind polymorphism
03:59:49 <ManateeLazyCat> ezyang: I'm try seriazlize GTK+ event C struct to Haskell data-type, and some field is DrawWindow pointer, so i build "SerializedWindow (Maybe DrawWindow)" as bogus field, when i serialized C struct, i just fill with "Nothing", after i derseriazlied it, i will pass the *real* DrawWindow Pointer to C struct. So i want it always got "SerializedWindow Nothing" when i *read* it.
04:00:47 <ezyang> Hmm. 
04:01:01 <ezyang> Maybe you should write SerializedWindow Nothing, although I don’t really have a godo handle on what’s going on here. 
04:01:13 <Saizan> ah, i don't know, i guess it depends on how you can open these first-class ones, and Exists probably has an additional bottom/indirection
04:02:20 <ManateeLazyCat> ezyang: But i know how write "Read instance" that ignore the read value.
04:02:21 <ManateeLazyCat> s/i know/i don't know.
04:03:06 <ezyang> Yeah. I suggest rereading the documentation for the Read typeclass. 
04:03:44 <ManateeLazyCat> ezyang: Ok, i'm reading Read documentation...
04:05:17 <ManateeLazyCat> ezyang: BTW, thanks your "bogus value" idea, now i can pass gtk+ C event in local, just haven't success with Read instance, but code at http://paste2.org/get/902012 is works well.
04:05:35 <ezyang> good to hear :^) 
04:06:20 <ezyang> I wrote this simple module: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26831#a26831 and I'm wondering where it should live. 
04:06:33 <ManateeLazyCat> ezyang: After i success with Read instance, then i can pass any Gtk+ event over the network, then it's basic code to build your own Graphics Remote-Control-System... :)
04:08:05 <triyo> I have a simple parser written in parsec that reads through a file and checks each line for an occurrence of my keyword. If it finds it, it must get the rest of that line's content.
04:08:55 <triyo> So, it looks like this: .....skip-all until.... <my-keyword>[consume-the-rest-until-eol]
04:08:58 <ezyang> going with Text.Groom whee 
04:10:05 <triyo> My parser works and here it is..., however as you can see, it very inefficient. http://gist.github.com/462507
04:10:32 * ManateeLazyCat pasted "Simple Read Instance code." at http://paste2.org/get/902030
04:10:32 <ManateeLazyCat> I'm reading Read instance documentation, if any expert know how to correct above code to avoid error "Prelude.read no parse", please let me know. Thanks!
04:10:56 <triyo> part I'm referring to is specifically. (try (string ctype *> notFollowedBy alphaNum))
04:11:20 <triyo> calling code for the parser looks like this: result <- parseFromFile (many (try $ cmdLnsParser ctype)) path
04:12:33 <triyo> is there a more efficient way to write this?
04:16:04 <kmc> this does not really sound like a parsing problem
04:17:18 <pastorn> triyo: try is kind of slow, you if you could write the parser differently it could be more efficient
04:18:46 <triyo> I have a find program that traverses all directories for my files and finds these occurrence in them. If I take of way the 'try' the performance increases ten-fold.
04:19:14 <kmc> i think parsers are not the right tool for string searching
04:19:15 <triyo> " of way " -> take away
04:19:29 <ivanm> triyo: what do you use the try for?
04:19:39 <ivanm> non-readable directory errors, etc.?
04:19:50 <ivanm> do you specialise the exception, or just catch SomeException?
04:19:56 <kmc> err this is Parsec's try, not Exception's try, isn't it?
04:20:10 <ivanm> oh
04:20:19 <ivanm> that's what I get for coming in to the middle of a conversation :p
04:20:36 <triyo> thought so, I have a much more complex parser that actually does some useful work on the lines thereafter....but to get those lines I probably shoulnd use parser
04:21:35 <triyo> ivanm: write to catch the error and not consume any of the attempt
04:21:36 <pastorn> triyo: have you considered using bnfc?
04:21:56 <pastorn> then a fast parser is generated for you :)
04:22:41 <triyo> pastorn: never considered it, yet
04:26:25 <pastorn> @where bnfc
04:26:26 <lambdabot> http://www.cs.chalmers.se/~markus/BNFC/
04:27:01 <tensorpudding> link seems to be dead
04:27:10 <pastorn> triyo: http://www.cse.chalmers.se/research/group/Language-technology/BNFC/
04:28:53 <triyo> thanks pastorn
04:29:46 <pastorn> triyo: do you know how it works?
04:30:00 <pastorn> (how you work it)
04:30:06 <triyo> non-what so ever :)
04:30:25 <triyo> do you have some examples?
04:31:00 <pastorn> you write a grammar file (look at the examples and the guide), then you run $ bnfc MyGrammar.bnf --haskell # or whatever
04:31:17 <pastorn> and it generates code containing a parser for you, then you just import that :)
04:31:21 <triyo> oh cool
04:31:43 <theorbtwo> That does sound cool, especially if it takes a BNF grammar, as the name implies.
04:32:06 <pastorn> triyo: look in LBNF-Report for all the keywords etc.
04:34:52 <Phyx-> are there any alternatives to -prof?
04:35:13 <ivanm> as in an external profiler? don't think so
04:35:28 <Phyx-> was hoping to avoid having to recompile ghc
04:35:32 <ivanm> you have to put hooks in for anything to be able to match up function names to reference counters, etc. at the very least
04:35:35 <kmc> you want to profile ghc itself?
04:35:41 <ivanm> Phyx-: you shouldn't have to, unless you're profiling ghc
04:35:46 <ivanm> unless you want profiling libraries?
04:36:06 <Phyx-> well, the first error it gives me is that no profiling version of base is installed
04:36:15 <Phyx-> and base comes with ghc doesn't it?
04:36:20 <ivanm> ouch
04:37:14 <kmc> Phyx-, how did you install ghc? on debian i can apt-get install ghc6-prof
04:37:15 <roconnor> > sqrt (1000000)
04:37:16 <lambdabot>   1000.0
04:37:24 <roconnor> oh right
04:37:27 <roconnor> :)
04:37:41 <kmc> > iterate sqrt 1000000
04:37:43 <lambdabot>   [1000000.0,1000.0,31.622776601683793,5.623413251903491,2.3713737056616555,1...
04:37:54 <kmc> > iterate sqrt 1000000 !! 50
04:37:55 <lambdabot>   1.0000000000000122
04:37:56 <roconnor> When viewed on a logrithmic scale having $1000 is half way to having $1,000,000.
04:38:06 <ivanm> roconnor: heh
04:38:09 <kmc> hehe
04:38:12 <roconnor> I'm almost retired!
04:38:21 <Phyx-> kmc: i'm working from a 6.13 nightly snapshot, and have modified it slightly. so it'c just compiled using standard configure and make
04:38:23 <dancor> is a always evaluated first in (a && b)
04:38:31 <Jafet> @remember roconnor When viewed on a logarithmic scale having $1000 is half way to having $1,000,000.
04:38:31 <lambdabot> I will remember.
04:38:37 <roconnor> dancor: && is short-circuted, yes
04:38:45 <roconnor> dancor: evaluation order is tricky in Haskell
04:38:47 <kmc> @src (&&)
04:38:47 <lambdabot> True  && x = x
04:38:47 <lambdabot> False && _ = False
04:38:57 <kmc> evaluation *order* is something you're not supposed to think about at all
04:38:58 <Jafet> The force is strong here.
04:39:09 <dancor> if i know neither is _|_, should i think about a && b vs b && a
04:39:12 <dancor> in a perf way
04:39:31 <kmc> dancor, if you care about performance then yes order is sometimes relevant
04:39:33 <ivanm> dancor: whichever is easier to compute goes first
04:39:41 <kmc> and if @src is to be believed, it will probably evaluate a first
04:39:42 <dancor> so ghc will take it as a hint?
04:39:44 <ivanm> hmmm..... looking through the old FGL code, I'm more and more glad that we started from scratch for the new version (whatever it'll be called) as fgl is an atrocious mess
04:39:57 <kmc> Phyx-, oh :/  you've got to recompile then
04:40:06 <roconnor> dancor: in theory no, in practice, put the cheap computation first if you are despartely looking for optimizations
04:40:28 <dancor> hm
04:40:40 <Phyx-> kmc: might you know where to add the flag?
04:40:47 <roconnor> dancor: or perhaps the one more likely to be false should go first
04:40:50 <kmc> if you are desperately looking for optimizations, you can force both in parallel and give up as soon as either produces False
04:40:52 <roconnor> hmm, intersting optimization problem
04:40:54 <kmc> Phyx-, no
04:41:50 <roconnor> ya, conal has a parellel or implimentation.  Though I don't remember if its semantics were sound in the end.
04:42:09 <roconnor> stupid asyncronous exceptions
04:42:11 <kmc> what can go wrong ;P
04:42:23 <kmc> yeah let's not think about those for sure
04:42:36 <ManateeLazyCat> ivanm: Do you know how to fix http://paste2.org/get/902030 that avoid error "Prelude.read no parse"?
04:43:30 <ivanm> ManateeLazyCat: I don't really get how to use ReadS :s
04:43:36 <ivanm> @type readsPrec
04:43:37 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
04:44:02 <ManateeLazyCat> ivanm: I just want *read* return "SerializedWindow Nothing" when it found "SerializedWindow" type. 
04:44:10 <ivanm> ManateeLazyCat: does it matter what val is?
04:44:16 <ivanm> I think that's the problem
04:44:33 <ManateeLazyCat> ivanm: Yes, since i always transfer "SerializedWindow Nothing"
04:44:35 <ivanm> there's too many possible things it can parse maybe...
04:44:40 <ivanm> hmmm....
04:45:09 <ManateeLazyCat> ivanm: SerializedWindow is "bogus value" to fill Nothing to match C pointer field.
04:45:23 <ivanm> ManateeLazyCat: I _think_ you might want to replace "val :: String" with "SeralizedWindow Nothing"
04:45:37 <ManateeLazyCat> ivanm: Complete version at http://paste2.org/get/902012
04:45:48 <ManateeLazyCat> ivanm: Ok, i try....
04:46:11 <ivanm> @type \ def str -> [(def, idStr) | (val :: String, idStr) <- reads str]
04:46:12 <lambdabot> forall t. t -> String -> [(t, String)]
04:47:02 <ivanm> @type (\ str -> [(Nothing, idStr) | (val :: String, idStr) <- reads str]) "hello, goodbye"
04:47:03 <lambdabot> forall a. [(Maybe a, String)]
04:47:07 <ivanm> > (\ str -> [(Nothing, idStr) | (val :: String, idStr) <- reads str]) "hello, goodbye"
04:47:09 <lambdabot>   []
04:47:17 <ivanm> ManateeLazyCat: maybe you're not parsing it a valid value?
04:47:24 <ivanm> is that a type checking error, or a run-time error?
04:47:35 <ivanm> > (\ str -> [(Nothing, idStr) | (val :: String, idStr) <- reads str]) "\"hello,\" goodbye"
04:47:36 <ManateeLazyCat> ivanm: Yes, "Prelude.read no parse".
04:47:36 <lambdabot>   [(Nothing," goodbye")]
04:47:45 <ManateeLazyCat> ivanm: runtime error.
04:47:48 <ivanm> ahhhh
04:47:53 <ivanm> ManateeLazyCat: what kind of input are you passing it?
04:48:02 <ivanm> you might need to explicitly quote your Show instance
04:48:05 <siracusa> ManateeLazyCat: val :: String, doesn't this mean the string has to start with a'\"
04:48:15 <ivanm> siracusa: yeah
04:48:24 <ManateeLazyCat> siracusa: I'm not understand how to write Read instance . :) 
04:48:37 <ivanm> > (\ str -> [(Nothing, idStr) | ("a b", idStr) <- reads str]) "a b"
04:48:38 <lambdabot>   []
04:48:50 <ivanm> > (\ str -> [(Nothing, idStr) | ("\"a b\"", idStr) <- reads str]) "\"a b\""
04:48:51 <lambdabot>   []
04:48:59 <ivanm> bah
04:49:04 <ivanm> > (\ str -> [(Nothing, idStr) | ("a b", idStr) <- reads str]) "\"a b\""
04:49:05 <lambdabot>   [(Nothing,"")]
04:49:10 <ivanm> yay!!!
04:49:15 <Phyx-> "Segmentation fault/access violation in generated code" lol how odd
04:49:34 <ivanm> ManateeLazyCat: the read there will try to parse an actual Haskell string, so it will need to be a quoted String as siracusa says
04:50:00 * Phyx- wonders how his haskell code is segfaulting
04:50:12 <dancor> ok another question i guess haskell doesn't have nested gaurds?  what's the best way to do this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26835#a26835
04:50:21 <kmc> Read is not a nice way to write parser
04:50:42 <ManateeLazyCat> ivanm: I'm a bit confusion....
04:50:45 <ivanm> kmc: definitely
04:50:56 <kmc> you can write a Parsec parser, or a ReadP parser, and invoke it from your Read instance
04:51:06 <ivanm> ManateeLazyCat: I think you want to try using lex or something rather than read
04:51:08 <kmc> ReadP is in the base package and is designed for this
04:51:08 <ivanm> @hoogle lex
04:51:09 <lambdabot> Prelude lex :: ReadS String
04:51:10 <lambdabot> Text.Read lex :: ReadS String
04:51:10 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
04:51:18 <ivanm> dancor: sure you can have nested guards
04:51:27 <ivanm> that looks legit to me
04:51:28 <Heffalump> dancor: given that your nested guards are exhaustive, you could use an auxiliary function
04:51:39 <Heffalump> ivanm: really? Did you try it?
04:51:43 <Phyx-> @src ReadP
04:51:43 <dancor> ivanm: well that doesn't compile for me
04:51:44 <lambdabot> Source not found. My brain just exploded
04:51:51 <ivanm> Heffalump: no, I said _looks_ ;-)
04:52:04 <Phyx-> @src String
04:52:05 <lambdabot> type String = [Char]
04:52:10 <ivanm> (and I think I used nested guards once; maybe not)
04:52:12 <Heffalump> dancor: if they weren't exhaustive, then the only real option is to stick the outer guard into a where and then put it in each of the "nested" ones with &&
04:52:14 <ivanm> @hoogle ReadP
04:52:14 <lambdabot> module Text.ParserCombinators.ReadP
04:52:14 <lambdabot> Text.ParserCombinators.ReadP data ReadP a
04:52:14 <lambdabot> Text.ParserCombinators.ReadPrec readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
04:52:15 <dancor> ivanm can be deceiving
04:52:16 <Phyx-> hmm so it does have type aliases
04:52:56 <Phyx-> @src ReadP Lexeme
04:52:57 <lambdabot> Source not found. Where did you learn to type?
04:53:04 <Phyx-> at school!
04:53:16 <Phyx-> you sure are cheeky today lambdabot 
04:53:34 <dancor> Heffalump: i might do the where anyway since i sort of wanted to the "op ==" test first..
04:53:43 <ivanm> @src Lexeme ReadP
04:53:43 <lambdabot> Source not found. :(
04:53:44 <dancor> which is why i was asking about eval order before
04:53:49 <ivanm> Phyx-: it's type first
04:53:51 <kmc> @vixen you sure are cheeky today
04:53:52 <lambdabot> i thought so
04:53:55 <ivanm> but still, you want a class...
04:53:57 <ivanm> @src Lexeme Read
04:53:57 <lambdabot> Source not found. You speak an infinite deal of nothing
04:55:14 <Phyx-> ivanm: ah ok
04:55:34 <ksf> there shouldn't be a single action of type IO a or MonadIO m => m a
04:55:43 <Phyx-> @src Int Show
04:55:43 <lambdabot> Source not found. stty: unknown mode: doofus
04:55:59 <Phyx-> @src String Show
04:55:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:56:16 <dancor> lol @ bob
04:56:29 <Phyx-> @quote bob
04:56:30 <lambdabot> dave_m says: < Bobstopper> Assuming the universe will eventually die of heat death, counting will cease when that happens. So if you start counting now, you'll probably find the largest number (so
04:56:30 <lambdabot> long as nobody else has found a larger one yet) < Cale> what about faster ways to produce larger numbers? < Bobstopper> not after the heat death you can't :P < dave_m> don't you tell me what I can't
04:56:30 <lambdabot> do after the heat death of the universe
04:56:32 <ksf> otoh, there _should_ be a lot of transformers that implement the whole of the sin bin, separately.
04:57:06 * ManateeLazyCat pasted "Variable instance." at http://paste2.org/get/902071
04:57:07 <ManateeLazyCat> ivanm: I need transfer SerializedEventKey (SerializedWindow is it's field) by DBus, so i need convert SerializedEventKey to Variant like above code.
04:57:45 <ManateeLazyCat> ivanm: Maybe the real problem is at "instance Show SerializedWindow where show _ = "SerializedWindow Nothing""
04:58:35 <ksf> Phyx-, there's no Show instance for string. there's one for char that treats showList specially.
04:58:42 <ivanm> ManateeLazyCat: it's possible
04:59:00 <ivanm> ManateeLazyCat: have a look at the Read instance for Data.Map or something and copy/paste that
04:59:28 <Phyx-> ksf: i expected id
04:59:42 <Phyx-> ksf: ah ok
04:59:42 <ksf> that doesn't give you quotes
04:59:46 <ksf> ...and escaping
04:59:53 <Phyx-> eh, true
05:00:03 <ivanm> ksf: sure there's a Show instance, just not an explicit one ;-)
05:00:28 <ksf> I actually wrote my own showList, exactly one
05:00:32 <ksf> +c
05:00:35 <siracusa> ManateeLazyCat: I haven't tried, but I think you want something like this http://paste2.org/p/902072 
05:00:47 <ManateeLazyCat> ivanm: I was think another idea, since all problem is "Variable instance", why not just ignore SerializedWindow when do toVariant? I just need show other value, then i rebulid SerializedEventKey with "SerializedWindow Nothing" when i do fromVariant
05:01:01 * Phyx- starts ghc recompilation
05:01:20 <ksf> ...to show lists of PctEncoded a = Pct Word8 | Char c as uri-style %-encoded stings
05:01:46 <dancor> submitted for the approval of the midnight society: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26835#a26836
05:02:28 <ManateeLazyCat> siracusa: DrawWindow is ForeginPtr, i even can't show it. 
05:02:38 <ivanm> apparently there used to be an FGL repo on darcs.haskell.org; anyone know where it might have gone to?
05:03:03 <siracusa> ManateeLazyCat: Ok, if ther's always a Nothing, you can replace it with Maybe Int
05:03:40 <ManateeLazyCat> siracusa: Maybe pass SerializedWindow over the network is wrong since i don't matter it's value..
05:05:05 <ManateeLazyCat> siracusa: I was think another solution, pass all field except SerializedWindow, after receive value from network, i use "SerializedWindow Nothing" rebuild SerializedEventKey
05:05:36 <ManateeLazyCat> siracusa: Then haven't Show/Read problem ...
05:06:37 * ManateeLazyCat Thanks all to help me drop my ugly Show/Read solution, dinner time... :)
05:09:25 <Phyx-> hmm i wonder
05:09:34 <Phyx-> why haskell programs seem to hang sometimes in msys
05:09:42 <Phyx-> I can't be the only one to notice this
05:11:26 <dancor> ivanm: don't see it on patch-tag or github either
05:12:11 <dancor> ivanm: maybe related to this?  not that fgl-prime repo seems to exist either   http://www.mail-archive.com/haskell-cafe@haskell.org/msg74870.html
05:12:16 <ivanm> dancor: well, it predates it
05:12:43 <ivanm> there used to be a repo created by malcolmw on darcs.haskell.org; I found one mirror of it but it was a couple of years out of date :s
05:13:04 <ivanm> dancor: ummm.... did you see who wrote that email?
05:13:05 <ivanm> ;-)
05:13:15 <ivanm> I'm looking for the _old_ repo that I just found a mention of in some docs
05:14:46 <dancor> ha well i often forget what i've done..
05:16:22 <ivanm> well, the only reason I care is because if this old repo is out there then I can port that to the new location and thus get all that old history in the repo back
05:16:55 <ivanm> actually, looks like it started with CVS, which CosmicRay then converted to Darcs
05:18:48 <chrisdone> where's the (RegexContext Regex [Char] [String]) instance?
05:20:28 <chrisdone> @hoogle RegexContext Regex String [String]
05:20:28 <lambdabot> Warning: Unknown type RegexContext
05:20:28 <lambdabot> No results found
05:20:47 <chrisdone> grumble
05:21:22 <ivanm> heh
05:21:24 <ivanm> try hayoo
05:21:32 <Phyx-> @hayoo test
05:21:33 <lambdabot> Unknown command, try @list
05:21:33 <ivanm> since it indexed hackage, it might be better at this
05:21:35 <Phyx-> booo
05:21:39 <ivanm> Phyx-: the website...
05:21:47 <Phyx-> hehhehe
05:22:43 <aristid> ivanm: huh? you think parsec is hard to use compared to polyparse? at least for the trivial grammars that i implemented, parsec was easy to use :)
05:23:14 <ivanm> aristid: I look at the docs for parsec and I get confused just by the type sigs ;-)
05:23:18 <chrisdone> it doesn't search instances
05:23:29 <ivanm> and partially that's because I've never had to use parsec
05:23:34 <ivanm> chrisdone: search for regexcontext
05:23:41 <olsner> parsec is confusing with the 'try' stuff, I can never get the right amount of them in the right places
05:23:54 <ivanm> whereas in polyparse you get try _for free_!!!
05:23:55 <Phyx-> uulib ftw :P
05:24:01 <ivanm> (I need to learn where to use commit though)
05:24:04 <ivanm> Phyx-: hush you! :p
05:24:05 <aristid> ivanm: there are type synonyms making the types shorter, and the ParsecT is just a normal monad transformer...
05:24:12 <Phyx-> ivanm: heheh
05:24:33 <aristid> Phyx-: uu-parsinglib is better i suppose
05:25:16 <Phyx-> well, never used parsec so
05:25:39 <chrisdone> bah
05:25:44 <Phyx-> only uu tools, so can't really give a fair comparisn
05:26:06 <chrisdone> :t (=~)
05:26:07 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
05:26:22 <chrisdone> > "foo foo foo" =~~ "foo" :: [String]
05:26:23 <lambdabot>   ["foo"]
05:26:30 <chrisdone> okay where the hell did it get that instance
05:26:46 <ivanm> that's weird... I would have expected three foos
05:26:49 <hpc> :t (=~~)
05:26:50 <lambdabot> forall source1 source (m :: * -> *) target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
05:27:03 <hpc> > "foo foo foo" =~ "foo" :: [String]
05:27:04 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
05:27:04 <lambdabot>                    ...
05:27:09 <hpc> > "foo foo foo" =~ "foo"
05:27:10 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
05:27:11 <lambdabot>                    ...
05:27:16 <hpc> bleh
05:27:17 <chrisdone> > "foo foo foo" =~ "foo" :: [String]
05:27:17 <ivanm> > "foo foo foo" =~~ "foo" :: Int
05:27:18 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
05:27:18 <lambdabot>                    ...
05:27:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:27:18 <lambdabot>         against inferred type ...
05:27:24 <ivanm> > "foo foo foo" =~ "foo" :: Int
05:27:25 <lambdabot>   3
05:27:28 <kmc> Text.Regex makes baby jesus cry
05:27:30 <ivanm> > "foo foo foo" =~ "foo" :: String
05:27:34 <lambdabot>   mueval-core: Time limit exceeded
05:27:54 <ivanm> :o
05:27:55 <ivanm> > "foo foo foo" =~ "foo" :: String
05:27:55 <ksf> that interface is an atrocity.
05:27:56 <lambdabot>   "foo"
05:27:56 <chrisdone> ignore the first one i sent, that uses the list monad
05:27:59 <ivanm> there we are
05:28:08 <chrisdone> the second one is on bryan's blog but nowhere to be found
05:28:12 <ivanm> chrisdone: oh? I thought [String] was meant to return all matches
05:28:21 <ivanm> chrisdone: IIRC, RWH had a chapter on this stuff...
05:28:26 <chrisdone> ivanm (=~) vs (=~~)
05:28:28 <ManateeLazyCat> > "before foodiebar after" =~ pat :: (String,String,String)
05:28:29 <lambdabot>   Not in scope: `pat'
05:28:30 <ivanm> ahhh
05:28:34 <Phyx-> > "foo foo foo" =~ "foo" :: Maybe String
05:28:35 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
05:28:35 <lambdabot>                    ...
05:28:39 <chrisdone> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/   ... says: "foo foo foo" =~~ "foo" :: [String]
05:28:41 <ManateeLazyCat> > "before foodiebar after" =~ "bar" :: (String,String,String)
05:28:42 <lambdabot>   ("before foodie","bar"," after")
05:28:46 <aristid> :t (=~)
05:28:47 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
05:28:52 <chrisdone> :t (=~~)
05:28:53 <lambdabot> forall source1 source (m :: * -> *) target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
05:29:02 <ManateeLazyCat> > "before foodiebar after" =~ "bar" :: (String,String,String,[String])
05:29:03 <ManateeLazyCat>  
05:29:04 <lambdabot>   ("before foodie","bar"," after",[])
05:29:18 <ksf> they should have at least made that an adt instead of a tuple
05:29:21 <ManateeLazyCat> > "foo" =~~ "bar":: Maybe String
05:29:25 <lambdabot>   Nothing
05:29:25 <kmc> class F a where f :: a
05:29:56 <chrisdone> it's not that i hate the class, i like it. it's just the documentation, or way we access information. i can never seem to find what i want when it comes to the generic regexes
05:30:01 <hpc> that type coercing hack is gross
05:30:45 <hpc> it would be nice if Regexes were a monad or something, so we could use $1-$9
05:30:53 <hpc> or even s//
05:31:32 <ivanm> hpc: go forth and implement!
05:31:46 <hpc> busy writing a game engine ;)
05:31:49 <ivanm> chrisdone: well, latest haddock apparently supports instance documentation
05:32:11 <ksf> applicatives are perfectly fine to specify the semantics of a grammar
05:32:26 <ksf> no need to go out and re-invent square wheels.
05:32:34 <chrisdone> ivanm: since when? it lists them, sure... regarding actual documentation of instances...?
05:32:59 <chrisdone> >  [ c | let notVowel = makeRegex "[^aeiou]" :: Regex, c <- ['a'..'z'], matchTest notVowel [c]  ]
05:33:00 <lambdabot>   "bcdfghjklmnpqrstvwxyz"
05:33:08 <ivanm> as in you can document the method instances, etc.
05:33:16 <ivanm> so you can give info on runtime bounds, etc.
05:33:23 <chrisdone> how?
05:33:28 <chrisdone> i've never seen that
05:33:31 <ivanm> dunno ;-)
05:33:37 <ivanm> I've just heard that you can
05:33:43 <ivanm> presumably using -- | as usual
05:33:43 <chrisdone> u herd
05:33:52 <ivanm> well, read
05:33:55 <ivanm> in the changelog
05:33:56 <chrisdone> lol
05:35:53 <chrisdone> splitRegex (mkRegex "[^a-z]") "foo bar" => ["foo","bar"]
05:35:58 <chrisdone> easy, but wordy
05:36:05 <ivanm> chrisdone: http://www.haskell.org/haddock/CHANGES.txt
05:36:07 <ivanm> for 2.7.0
05:36:24 <ivanm> (no idea if it was backported to 2.6.1 though)
05:36:34 <chrisdone> kewl
05:36:38 <chrisdone> i wonder what version hackage uses
05:36:47 <ivanm> good question
05:36:53 <ivanm> GHC still only ships with 2.6.1
05:38:28 <chrisdone> i was gonna do this code golf challenge http://stackoverflow.com/questions/3169051/code-golf-word-frequency-chart
05:38:42 <chrisdone> but if i have write splitRegex (mkRegex i've already lost lol /gives up
05:40:45 <ivanm> well, the word frequency chart thing shouldn't be that hard
05:41:56 <ivanm> map (\ ws -> (head ws, length ws)) . group . sort . filter (not . ignoredWord ) . words . map toLower
05:44:28 <psnively> szeiger: Hi Stefan!
05:44:55 <psnively> szeiger: Whatever is going on with the 2.8.0 RCs and scala-query is more mysterious (to me) than I thought.
05:45:29 <olsner> ivanm: and you also need to format the output and rescale to fit in 80 columns
05:45:42 <ivanm> olsner: right, but that's a display issue ;-)
05:45:51 <ivanm> I'm just trying to work out why chrisdone is using regexes, that's all
05:47:06 <chrisdone> read the problem description
05:47:22 <olsner> regexp => now you have two problems => twice the fun?
05:49:10 <ivanm> chrisdone: still don't see anywhere why you have to use regexes
05:49:27 <ivanm> the description doens't mention regexes at all that I can find
05:49:51 <ivanm> but looks like just using words won't work; maybe do a map and replace everything that isn't a character with a space?
05:49:58 <duairc> Is there anything like type/kind lambdas? I want to write a function :: (MonadTrans s, MonadTrans t, Monad m) :: Foo t m -> Foo s (t m) -> Foo (\n a -> (s (t n) a)) m... that is, I want to compose monad transformers at the type level
05:50:12 <ivanm> or just use the split library
05:50:24 <ivanm> duairc: don't think so
05:50:52 <duairc> What I'm trying to do might be nonsense though, I haven't thought about it very much
05:51:04 <kmc> duairc, you can make a new type (Compose t t') with instance (MonadTrans t, MonadTrans t') => MonadTrans (Compose t t')
05:51:06 <kmc> bbl
05:52:06 <olsner> maybe you can write type Bar s t n a = s (t n) a, and use Foo (Bar s t) m
05:52:28 <duairc> olsner: Yeah, I think that would work
05:52:54 <chrisdone> (=~"[^a-zA-Z]") is the shortest String -> [String] you're gonna get
05:52:59 <osfameron> > let y = let s = sum (map fst y) in map (\i -> (i, fromIntegral i / fromIntegral s)) [1,2,7]
05:53:00 <lambdabot>   not an expression: `let y = let s = sum (map fst y) in map (\i -> (i, fromI...
05:53:07 <osfameron> meh
05:53:11 <chrisdone> er, (=~"[^a-zA-Z]+")
05:53:13 <duairc> Wait, type aliases can't be partially applied, would that affect this?
05:53:17 <osfameron> > y where y = let s = sum (map fst y) in map (\i -> (i, fromIntegral i / fromIntegral s)) [1,2,7]
05:53:18 <lambdabot>   <no location info>: parse error on input `where'
05:53:21 <osfameron> bah
05:53:39 <osfameron> anyway... my question: is that an example of "circular evaluation" ?
05:53:55 <olsner> duairc: I think that might make it impossible, yes... maybe there's an extension you can enable though
05:54:13 <ivanm> chrisdone: hmmmm....
05:54:37 <dafis>  > let y = let s = sum (map fst y) in map (\i -> (i, fromIntegral i / fromIntegral s)) [1,2,7] in y
05:54:48 <dafis> > let y = let s = sum (map fst y) in map (\i -> (i, fromIntegral i / fromIntegral s)) [1,2,7]
05:54:49 <lambdabot>   not an expression: `let y = let s = sum (map fst y) in map (\i -> (i, fromI...
05:55:02 <dafis> > let y = let s = sum (map fst y) in map (\i -> (i, fromIntegral i / fromIntegral s)) [1,2,7] in y
05:55:03 <lambdabot>   [(1,0.1),(2,0.2),(7,0.7)]
05:55:38 <dafis> osfameron: that ^^^ what you wanted?
05:55:49 <osfameron> dafis: well, the expression I had worked in ghci :-)
05:56:02 <osfameron> I just wasn't sure how to get lambadabot to understand it ;-)
05:56:16 <osfameron> but yes, that's the expected value
05:56:30 <dafis> osfameron: in ghci, what you had would be a binding for y
05:56:50 <dafis> you'd then access the value by typing y
05:56:54 <osfameron> yes
05:57:21 <dafis> if you want to bind values in lambdabot, use @let
05:57:52 <dafis> @let y = let s = sum (map fst y) in map (\i -> (i, fromIntegral i / fromIntegral s)) [1,2,7]
05:57:54 <lambdabot>  <local>:1:25:
05:57:54 <lambdabot>      Ambiguous occurrence `y'
05:57:54 <lambdabot>      It could refer to either `L...
05:57:58 <osfameron> ah "in y" at the end is fine
05:58:08 <osfameron> that's what I was trying with the 'where' clause
05:58:16 <dafis> @let osy = let s = sum (map fst osy) in map (\i -> (i, fromIntegral i / fromIntegral s)) [1,2,7]
05:58:17 <lambdabot>  Defined.
05:58:21 <dafis> > osy
05:58:23 <lambdabot>   [(1,0.1),(2,0.2),(7,0.7)]
05:58:26 <osfameron> cool
05:58:33 <osfameron> anyway, is that "circular programming" ?
05:58:56 <osfameron> as the 'snd' part of the tuple is a ratio with the sum of 'fst' ?
05:59:31 <chrisdone> i believe it's called 'corecursion'
05:59:59 <osfameron> I skimmed the paper on functional cyclic graphs, and it mentioned circular programming (which confused the hell out of me the last time I tried to understand it) but actually this seems quite simple... so I wanted to make sure if I'd actually understood it, or just fooled myself :D
06:00:02 <Jafet> http://www.haskell.org/haskellwiki/Tying_the_knot rikehshun
06:01:07 <chrisdone> @let osy = let s = sum (map fst osy) in map (\i -> (i, fromIntegral i / fromIntegral s))
06:01:07 <lambdabot>  <local>:2:0:
06:01:07 <lambdabot>      Multiple declarations of `L.osy'
06:01:08 <lambdabot>      Declared at: <local>...
06:01:13 <chrisdone> @undef osy
06:01:15 <chrisdone> @let osy = let s = sum (map fst osy) in map (\i -> (i, fromIntegral i / fromIntegral s))
06:01:16 <lambdabot>  <local>:1:35:
06:01:16 <lambdabot>      Couldn't match expected type `[(a, b)]'
06:01:16 <lambdabot>             again...
06:01:38 <chrisdone> @let osy xs = let s = sum (map fst osy) in map (\i -> (i, fromIntegral i / fromIntegral s)) xs
06:01:38 <lambdabot>  <local>:1:30:
06:01:38 <lambdabot>      Couldn't match expected type `[(a, b)]'
06:01:39 <lambdabot>             again...
06:01:51 <chrisdone> @let osy xs = let s = sum (map fst (osy xs)) in map (\i -> (i, fromIntegral i / fromIntegral s)) xs
06:01:52 <lambdabot>  Defined.
06:01:52 <kdvh> is it possible to use record syntax for multiple value constructors when creating data types?
06:01:57 <chrisdone> > osy [1..5]
06:01:59 <lambdabot>   [(1,6.666666666666667e-2),(2,0.13333333333333333),(3,0.2),(4,0.266666666666...
06:02:40 <chrisdone> what's a multiple value constructor?
06:03:14 <dafis> kdvh: what do you mean? data Foo a = Foo1 { val :: a, name :: String } | Foo2 { val a, ident :: Int } ?
06:03:16 <b0fh_ua> Hello! Can somebody please advice how to improve the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26837#a26837 ? Also I'm wandering how can I get rid of line 33 and use manyTill on line 36 with ( manyTill parseAll eof >> getState)
06:03:45 <kdvh> dafis: yes
06:05:02 <dafis> kdvh: yes, it works, as long as the fields have the same type, you can use the same field name in multiple constructors
06:05:38 <kdvh> alright, thanks
06:05:39 <hpc> > osy 3
06:05:40 <lambdabot>   No instance for (GHC.Num.Num [a])
06:05:40 <lambdabot>    arising from a use of `e_13' at <inter...
06:05:49 <hpc> > osy [3]
06:05:50 <lambdabot>   [(3,1.0)]
06:07:50 <dafis> b0fh_ua: it would be manyTill eof parseAll
06:08:15 <dafis> b0fh_ua: scrap that
06:08:31 <dafis> alzheimer's is coming
06:08:53 <b0fh_ua> dafis: in fact that doesn't work for some reason
06:09:04 <b0fh_ua> it leaves me with the first property
06:09:11 <b0fh_ua> and won't parse the rest
06:09:52 <dafis> b0fh_ua: so you say (manyTill thing eof) will parse only one thing ??
06:10:08 <b0fh_ua> yup
06:10:48 <b0fh_ua> weird
06:11:30 <duairc> olsner: Yeah, LiberalTypeSynonyms did it :) I never knew about that before!
06:12:17 <chrisdone> LiberalTypeSynonyms!?
06:12:22 <chrisdone> @hoogle ghc manual LiberalTypeSynonyms
06:12:22 <lambdabot> No results found
06:12:27 <b0fh_ua> dafis: oh, my bad
06:12:30 <chrisdone> @google ghc manual LiberalTypeSynonyms
06:12:32 <lambdabot> No Result Found.
06:12:35 <b0fh_ua> it works with manyTill
06:13:40 <dafis> b0fh_ua: One thing, you first do TP.spaces in all line-parsers, it would be good to maove that to parseAll
06:14:32 <dafis> parseAll = TP.spaces >> (parseComment <|> try parseProperty <|> try parseIForgot)
06:15:06 <dafis> oh, EmptyLine, so that wouldn't need a try either
06:16:30 <dafis> parseAll = TP.spaces >> (parseComment <|> newline <|> parseProperty) >> optional newline
06:16:32 <dancor> is there info on writing ghc extensions?  i might try my hand at NestedGuards that has been discussed but never done
06:17:02 <dancor> unrelated, was lisp the first language to have "reduce"?  what was first lang to start calling it "fold"?
06:18:28 <dancor> ML has "fold"..
06:18:43 <dancor> so does scheme
06:19:18 <olsner> duairc: nice :)
06:19:20 <dancor> i guess ML was '73 and scheme was '75
06:20:08 <b0fh_ua> dafis: well, parseComment <|> newline <|> parsePropert won't work due to typecheck issue
06:21:22 <ManateeLazyCat> ivanm: Haha, i success, now i can transfer GTK+ event from one process to another process, excited.....
06:21:34 <ivanm> cool!
06:21:51 <dafis> b0fh_ua: actually, the newline is completely superfluous, parseComment <|> parseProperty is enough
06:23:23 <b0fh_ua> yes, you're right
06:23:26 <ManateeLazyCat> ivanm: Now, just finish Gtk+ keyPress/keyRelease event, i will implement GdkMotion, GdkMouse,... etc. Then i can spend my gtk+ event from andyBox to ivanmBox, then you send your real-time video to me, guess what's it?
06:23:34 <dafis> b0fh_ua: and both, parseComment and parseProperty consume the following newline in manyTill (and then possibly one more in optional newline)
06:23:47 <ivanm> what?
06:23:48 <dafis> and AFAIR, spaces consumes newlines, too
06:23:55 <ManateeLazyCat> ivanm: Remote Control System! :)
06:24:03 <ivanm> hmmm...
06:24:05 <ManateeLazyCat> ivanm: Base Haskell/GTK+
06:24:22 * ivanm writes a note to make sure he never installs any packages that ManateeLazyCat gives him to "test" ...
06:24:22 <ivanm> ;-)
06:24:46 <b0fh_ua> dafis: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26838#a26838
06:24:55 <b0fh_ua> much better )
06:25:10 <ManateeLazyCat> ivanm: If a newbine ask my problem about my project, i will say : "Hey, don't touch your box, let me fix it... " . ;-)
06:25:11 * hackagebot bird 0.0.6 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.6 (MattParker)
06:25:20 <ivanm> heh
06:27:05 <dafis> b0fh_ua: you don't need the try in parseAll
06:27:13 <ivanm> anyone know what the API changes between version 1.1.4 and 1.2 of the time library were?
06:27:25 <ManateeLazyCat> ivanm: darcs diff ?
06:27:28 * ivanm can't seem to find a changelog
06:27:41 <ivanm> ManateeLazyCat: I could do that, but I'm trying to avoid getting the darcs repo of it
06:30:47 <dandelions> http://www.reddit.com/r/reddit.com/comments/clmax/please_boycott_this_author/
06:30:51 <ManateeLazyCat> ivanm: At the begin, transfer gtk+ event is for propagate gtk+ event in webkit child process (http://farm5.static.flickr.com/4115/4747458812_573c04c00e_b.jpg), after i finish binding module, i found i can use to build RCS. :)
06:31:19 <ManateeLazyCat> ivanm: http://farm5.static.flickr.com/4096/4748566880_aefb70879d_b.jpg
06:32:30 <dafis> dandelions, too much honour for him to have an expilicit boycott call
06:33:02 <b0fh_ua> ok
06:33:07 <ManateeLazyCat> ivanm: In http://farm5.static.flickr.com/4096/4748566880_aefb70879d_b.jpg , i got three webpage that play flash movie not synchronous....
06:33:24 <ManateeLazyCat> ivanm: Because WebKit1 engine is not MCV design now.
06:33:40 <ManateeLazyCat> ivanm: Maybe this problem will fix at WebKit2 .....
06:33:51 <ManateeLazyCat> s/MCV/MVC
06:39:48 * ManateeLazyCat Bye all, try to support all gtk+ event, then i can control your box! ... haha ... joking, ;)
06:50:21 <ManateeLazyCat> ezyang: I found a C struct field like this "guint is_modifier : 1;", that's mean i need pick the *first bit* of guint, so how pick bit value in *peek* ?
06:50:56 <Zao> ManateeLazyCat: Note that the positioning of multiple bitfields in a struct is implementation defined.
06:51:21 <ivanm> ManateeLazyCat: I thought you had left...
06:51:23 <Zao> struct { uint x : 1; uint y : 1; }; // quite ID.
06:51:26 * ivanm puts the party food back away...
06:51:27 <ivanm> :p
06:51:59 <ManateeLazyCat> ivanm: I don't know how to pick bit value from C struct, so i'm back, i will off again after i get answer.:)
06:52:08 * Phyx- pulls in ghc patches
06:52:25 <Phyx-> ghc segfaulted again
06:52:26 <Phyx-> sheesh
06:52:36 <ManateeLazyCat> ivanm: Like ghost? :) 
06:52:53 <ivanm> preflex: seen Igloo 
06:52:53 <preflex>  Igloo was last seen on #ghc 22 hours, 25 minutes and 56 seconds ago, saying: http://www.catb.org/~esr/jargon/html/Z/Zawinskis-Law.html
06:53:30 <Jafet> Should that "boycott" bloke be reported to staff? He's starting to annoy other channels
06:53:49 * ManateeLazyCat pasted "GdkEventKey" at http://paste2.org/get/902169
06:53:49 <ManateeLazyCat> Zao: I try to serialized GdkEventKey (above is C struct code) to Haskell data-type. 
06:53:59 <ivanm> Jafet: sure
06:54:16 * ManateeLazyCat pasted "pick code." at http://paste2.org/get/902171
06:54:17 <ManateeLazyCat> Above is my code to pick GdkEventKey
06:54:19 <Phyx-> hmm.. this is odd, compiling ghc with profiling support makes it segfault on ffi
06:54:21 <ivanm> we might all think jdh30 is an idiot; doesn't mean we make a fool of ourselves making a big huge hue and cry over it
06:54:41 <ivanm> especially since IIRC it was on the main reddit, so heaps of people who have no idea what it's all about will be seeing it
06:54:45 <ivanm> Phyx-: :o
06:54:51 <ivanm> which version of ghc?
06:54:53 <ManateeLazyCat> Zao: http://paste2.org/get/902171 , line 104
06:54:56 <kmc> yeah this is how trolling works
06:55:16 <ManateeLazyCat> Zao: I just don't know how to write *peek* code to pick bit value.
06:55:29 <Zao> ManateeLazyCat: I would recommend reading the C standard for the particulars, as I'm unsure of the exact packing semantics you _do_ have a guarantee for.
06:55:30 <Phyx-> ivanm: trying to see if it's reproducable, could just be a bug in my snapshot, need to pull in the latest patches
06:55:48 <Zao> Doesn't gtk2hs or c2hs or any other wrapping tool have functionality for bitfields?
06:55:53 <ManateeLazyCat> Zao: No.
06:55:55 <ivanm> @ask Igloo dcoutts says you might have a backup somewhere of the fgl repo that used to be on darcs.haskell.org; if so, can I get a copy of it so I can use it to start off my maintenance release repo (to get the history right, etc.) ?
06:55:56 <lambdabot> Consider it noted.
06:56:07 <ivanm> Phyx-: *nod*
06:56:09 <Phyx-> well, it's definately consistent, segfaults when compiling Data.Array.Parallel
06:56:10 <ManateeLazyCat> Zao: Because Alex don't like that, so he build EventM. :)
06:56:13 <dcoutts_> Zao: yes, gtk2hs has some utils for that I think
06:56:27 <Zao> ManateeLazyCat: Write a helper function in C that extracts the field for you maybe?
06:56:29 <ManateeLazyCat> dcoutts_: Where? 
06:56:36 <Zao> Or see dcoutts_ :D
06:56:48 <ManateeLazyCat> dcoutts_: I haven't found code to do that.
06:56:49 <Phyx-> question, how does darc's conflict resolution work? I have some local changes, doing a pull would override them no?
06:57:25 <dcoutts_> ManateeLazyCat, Zao: glib/System/Glib/Flags.hs
06:57:38 <ManateeLazyCat> dcoutts_: Ok, reading it...
06:57:41 <ManateeLazyCat> dcoutts_: Thanks!
06:57:41 <dcoutts_> Flags class with to/fromFlags
06:59:02 <ManateeLazyCat> dcoutts_: BTW, i have binding new function gtk_main_do_event with new code at http://paste2.org/get/902171 , now i can pass Gtk+ event from one process to another. :)
06:59:11 <Phyx-> hmm no it shouldn't right. the patches are just applied
06:59:19 <Phyx-> guess i'll find out soon enough
07:18:04 <Baughn> We need a memory debugger called "Valcurry".
07:18:10 <Baughn> With a valkyrie for a logo.
07:18:16 <soupdragon> hehe
07:19:09 <kmc> great now i have the ride stuck in my head
07:21:28 <kmc> alias valcurry='grep -n unsafeCoerce'
07:22:06 <Baughn> Ha. But na.
07:22:30 <Baughn> It could, for example, look for chains of thunks (or code that could build them) that would cause stack overflow on evaluation.
07:22:41 <Baughn> I'm not sure if that reduces to the halting problem or not.. let me think
07:23:12 <Jafet> @quote generalisation
07:23:12 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
07:23:41 <ivanm> kmc: why not just grep for "unsafe" ?
07:23:51 <Jafet> Because that's unsafe
07:23:56 <ivanm> heh
07:24:16 <kmc> ivan, because most uses of unsafe in Haskell programs are not memory-unsafe
07:24:28 <ivanm> Baughn: if you're wanting to have a Haskell program being used for haskellmode, why not consider integrating ghc-mod, etc. into it as well?
07:24:34 <kmc> i suppose you ∗can∗ write unsafeCoerce using unsafePerformIO, but it's rare
07:24:42 <ivanm> fair enough
07:24:48 <kmc> the bigger backdoor is probably Foreign
07:25:01 <kmc> once you have Foreign you lose memory safety, but it's used quite extensively
07:25:03 <ivanm> kmc: oh, you probably want to append "-r ." as well
07:25:10 <kmc> ok
07:26:19 <ivanm> wtf? ghci is suddenly bitching about "unterminated {-", when it _is_ terminated...
07:27:14 <ivanm> wait, this only happens inside emacs...
07:27:35 <ivanm> so itmight be a problem with haskellmode, but it hasn't been updated for a while and this used to work :s
07:28:06 <ivanm> unless there's some weird interaction going on between haskellmode and ghci-6.12.3...
07:28:19 <Baughn> ivanm: I don't see how that can be
07:28:27 <Baughn> Also, haskell-mode was updated yesterday.
07:28:29 <ivanm> neither can I :s
07:28:37 <ivanm> Baughn: well, I haven't updated it here ;-)
07:28:45 <ivanm> Baughn: do you announce it to an emacs mailing list as well?
07:28:49 <Baughn> No
07:28:57 <ivanm> oh...
07:28:59 <ivanm> maybe you should
07:29:10 <ivanm> at least in gentoo, the emacs people deal with haskell-mode, not us gentoo people
07:29:22 <ivanm> (mainly because I have nfi how the emacs stuff works in gentoo :s)
07:30:44 <Baughn> It wouldn't quite make sense. Haskell-mode has little interest to emacs people
07:32:17 <aristid> Baughn: unless of course they are also haskell people
07:32:28 <ivanm> Baughn: they control how elisp files are built, etc. in gentoo
07:32:32 <Baughn> In which case they'd presumably be subscribed to haskell-cafe..
07:32:43 <ivanm> it's all the infrastructure stuff which I don't know about
07:32:57 <Baughn> ivanm: There's also the whole "I intend to have haskell-mode installed via cabal-install" thing
07:33:05 <ivanm> yeah
07:33:10 <ivanm> in which case, I'll take over
07:33:23 <ivanm> and then have to try and muddle my way through the elisp stuff... :s
07:33:49 <ivanm> Baughn: in that case, maybe you should get together with the vim haskellmode maintainer and see if you can use the same backend, if you're going to make it a haskell package
07:33:55 <ivanm> rather than an editor-specific package
07:34:23 <Baughn> Indeed
07:35:51 <ManateeLazyCat> ivanm: What's the cool feature in ghc-mode?
07:36:08 <ivanm> Baughn: anyway, it looks like this part of the comment causes the weird interaction: * Comments (both @\/* ... *\/@ style and @\/\/ ... @ style);
07:36:26 <ivanm> ManateeLazyCat: adds completion
07:36:28 <ivanm> http://hackage.haskell.org/package/ghc-mod
07:36:32 * ivanm hasn't actually used it
07:36:33 <ManateeLazyCat> ivanm: completion what?
07:36:45 <Baughn> ivanm: Are you quite sure it only blows up when loaded from emacs, and not the command line?
07:36:49 <ManateeLazyCat> ivanm: I have try it, just complete keyword.
07:36:52 <ivanm> ManateeLazyCat: haskell symbols
07:36:59 <ivanm> Baughn: yup
07:37:00 <ManateeLazyCat> ivanm: Really?
07:37:06 <ivanm> ManateeLazyCat: so it claims
07:37:17 <Baughn> ivanm: Because, well, haskell-mode does that loading by first calling (save-buffer), then telling GHCi to load the file
07:37:23 <Baughn> ivanm: Could I have a copy of the file, then?
07:37:25 <ivanm> ManateeLazyCat: I'm guessing it completes imported function names, etc.
07:37:40 <ivanm> Baughn: I think it might be trying to do extra escaping or something
07:37:58 <Baughn> ivanm: C-c C-l?
07:38:00 <ivanm> yup
07:38:05 <Baughn> No.
07:38:09 <ivanm> AFAICT, I haven't changed it from this: http://code.haskell.org/graphviz/Data/GraphViz/PreProcessing.hs
07:38:13 <ManateeLazyCat> ivanm: So it's import some module in ghci, then scan ghci result?
07:38:20 <ManateeLazyCat> Baughn: Are you author?
07:38:30 <ManateeLazyCat> Baughn: for ghc-mode?
07:38:33 <Baughn> No
07:38:53 <ivanm> ManateeLazyCat: uses ghc-api I think, rather than just ghci
07:39:22 <ManateeLazyCat> ivanm: I think it's better if ghc-mode integrate with auto-complete.el package.
07:39:37 <ManateeLazyCat> ivanm: Like my haskell completion package : http://www.emacswiki.org/emacs/auto-complete-extension.el
07:39:39 <ivanm> Baughn: nope, the one I'm using here hasn't changed from the one above
07:39:48 <ivanm> ManateeLazyCat: suggest it to the author!
07:40:01 <ManateeLazyCat> ivanm: I'm too lazy....
07:40:10 * ivanm doesn't use any completion stuff in any emacs mode
07:40:18 <ivanm> mainly because I've never bothered to learn how to, etc.
07:40:19 * Baughn groans
07:40:25 <ivanm> Baughn: what?
07:40:28 <ManateeLazyCat> ivanm: In emacs you can do that.
07:40:38 <Baughn> I have an eight-core laptop. So *why* must I wait for GHC to compile hs-graphviz on a single core?
07:40:41 <ivanm> ManateeLazyCat: I know, I have just never bothered to
07:40:54 <ivanm> Baughn: because no-one has taught ghc how to parallelise --make yet
07:40:55 <ivanm> ;-)
07:41:20 <ivanm> Baughn: and why are you compiling "hs-graphviz" ?  that sounds like a binary package name from a distro...
07:41:32 <Baughn> ivanm: I'm not. I'm compiling graphviz.
07:41:45 <Baughn> Hm
07:41:50 <Baughn> hackage!graphviz
07:41:54 <ManateeLazyCat> ivanm: I just don't want waste time on Emacs, i my configuration is stop at 2008-12-25
07:42:03 <ManateeLazyCat> s/configuration/configuration file.
07:42:17 <wli> 8-core laptops must be nice
07:42:41 <aristid> nicely hot
07:43:07 <wli> I mostly need portable power (not that I'm going to get anything I need ever again)
07:43:11 <Baughn> 45 watts at max power, yes..
07:43:22 <Baughn> And it's really 4-core with hyperthreading. At 1.6GHz.
07:43:28 <hpc> wli: they are fantastic; i have an i7 that peaks at 3GHz
07:43:33 <tommd> Why is 8 cores impressive when other architectures have had 64 cores on the market for four years now.
07:43:35 <tommd> ?
07:43:41 <Baughn> tommd: Because it's a laptop. :P
07:43:41 <aristid> tommd: in a laptop?
07:43:42 <hpc> tommd: laptop
07:43:48 <wli> Baughn: Oh, that's 4-core, 8-thread.
07:43:53 <hpc> mine also has a 5870 gpu
07:44:02 <tommd> Well, Tilera power profile could go on a laptop.
07:44:09 <Baughn> ivanm: Also, the file loaded without issues.
07:44:13 <Baughn> ivanm: I think yours is broken.
07:44:37 <Baughn> wli: Hm. I'd agree if it were RISC-like, but since there are eight control units.. the control units are a rather large part of an x86 core.
07:45:12 <ManateeLazyCat> ivanm: ghc api support symbol completion? Link?
07:45:24 <epicbeardman_> I'm having a couple problems with this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26839#a26839
07:45:29 <ivanm> ManateeLazyCat: I already gave you the link to ghc-mod! it's on hackage!
07:45:36 <ivanm> Baughn: my what is broken?
07:45:53 <epicbeardman_> namely, I can't convert the result list to Ints without getting an `ambiguous type variable' error
07:45:54 <Baughn> ivanm: Your copy of haskell-mode, ghci, or the file in question.
07:45:58 <Baughn> ivanm: WorksForMe(tm).
07:46:10 <ManateeLazyCat> ivanm: Oh.
07:46:11 <epicbeardman_> and rounding/precision problems seem to be giving me grief.
07:46:21 <Baughn> ivanm: (And I didn't change anything in haskell-mode that should've affected it since last time)
07:46:22 <ivanm> Baughn: :(
07:46:51 <ivanm> Baughn: any build changes for haskellmode?
07:47:10 <Baughn> Depends on how you're building.
07:47:23 <Baughn> There's one more .el file
07:47:42 <wli> Baughn: It's still 4-core, 8-thread. Intel's got a whole package, die, core, thread breakdown (IIRC dies/package are still all pegged at 1).
07:48:15 <ivanm> OK, that doesn't seem to effect how the ebuild works \o/
07:48:26 <Baughn> wli: Two dies/package on this one, it's just that one is a vector unit
07:48:40 <Baughn> (I.e. gpu)
07:49:04 <wli> Baughn: Doesn't sound right but they may have changed their mind since last I checked since it's been a few years.
07:49:56 <wli> Baughn: (Back when I was still in the loop dies/package was another branching factor for multiple identical dies on a single package etc.)
07:50:00 <ivanm> Baughn: OK, I think I know what the problem is
07:50:11 <epicbeardman_> is there a way to convert RealFrac's to Integers?
07:50:21 <ivanm> for some reason, it's thinking that the "*\" in that line is a comment terminator
07:50:24 <ivanm> (don't ask me why)
07:50:28 <ivanm> epicbeardman_: round?
07:50:35 <wli> epicbeardman_: fst . properFraction ?
07:50:38 <ivanm> @hoogle RealFrac a => a -> Integer
07:50:38 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
07:50:39 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
07:50:39 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
07:50:47 <ivanm> epicbeardman_: ^^
07:50:53 <ivanm> take your pick of what you want to do
07:50:57 <epicbeardman_> wli: that's what I wanted, I think
07:51:25 <wli> epicbeardman_: fst . properFraction should be floor
07:51:28 <ivanm> @hoogle properFraction
07:51:28 <lambdabot> Prelude properFraction :: (RealFrac a, Integral b) => a -> (b, a)
07:51:42 <ivanm> wli: what about negative numbers?
07:51:50 <ivanm> > properFraction (-3.4)
07:51:51 <lambdabot>   (-3,-0.3999999999999999)
07:51:57 <wli> I could be wrong about negatives.
07:52:01 <ivanm> it rounds towards 0
07:52:07 <wli> Looks like not floor but truncate
07:52:09 <ivanm> whatever the technical name of that is
07:52:12 <ivanm> wli: yup
07:52:28 <epicbeardman_> wli: truncate is essentially what I really watn.
07:52:30 <epicbeardman_> want*
07:52:49 <epicbeardman_> @hoogle truncate
07:52:49 <lambdabot> Prelude truncate :: (RealFrac a, Integral b) => a -> b
07:53:14 <ivanm> Baughn: it appears that 2.8.0 fixes this... :s
07:53:24 <ivanm> @hoogle properFraction
07:53:24 <lambdabot> Prelude properFraction :: (RealFrac a, Integral b) => a -> (b, a)
07:53:29 <ivanm> @hoogle RealFrac a => a -> Integer
07:53:29 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
07:53:29 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
07:53:29 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
07:53:30 <ivanm> @more
07:53:37 <Baughn> ivanm: I don't recall fixing it.. oh well
07:53:41 <ivanm> bah, @hoogle doesn't seem to accept @more :s
07:53:52 <ivanm> Baughn: thing is, this didn't _use_ to be a problem :s
07:54:29 <ivanm> I checked it by launching a new emacs instance; the real test will be when I restart my daemon and use my "normal" emacs session
07:54:39 <ivanm> that, however, will have to wait
07:54:40 <ivanm> @time
07:54:41 <lambdabot> Local time for ivanm is Sun Jul  4 00:54:17
07:54:50 <ivanm> dammit, can't I get to bed _once_ before midnight? :s
07:55:24 <ManateeLazyCat> ivanm: Hmm, i have play ghc-mod, i think it's a good backend for haskell-completion. 
07:55:34 <Jafet> ivanm: switch to HST
07:55:47 <ManateeLazyCat> ivanm: ghc.el still can't work, but i think ghc-mod is do right thing.
07:56:40 <ivanm> Jafet: HST ?
07:56:56 <Jafet> Hacker standard time, just subtract 0300
07:57:00 <ivanm> heh
07:57:09 <ivanm> doesn't help when I have to get up in the mornings to get somewhere
07:57:13 <hpc> haha
07:57:52 <ManateeLazyCat> ivanm: I have success, cool.
07:57:58 <ManateeLazyCat> ivanm: ghc-mod in Emacs.
07:58:02 * ivanm -> sleep
07:58:04 <ivanm> g'night all
07:58:14 <hpc> ghc-mod sounds like g-mod
08:01:10 <ManateeLazyCat> hpc: g-mod ? Link?
08:01:17 <hpc> garry's mod
08:06:46 <FunctorSalad> are you ghc-mod's author?
08:07:03 <FunctorSalad> (I wonder if it'd be trivial to dump types along with names)
08:07:19 <FunctorSalad> since it seems to be calling ghc's api anyway
08:08:43 * hackagebot snap-core 0.2.7.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.7.1 (GregoryCollins)
08:30:08 <Athas> Is there any way to perform a select(2) with GHC?
08:30:22 <Zao> Athas: The network package ought to have one or two.
08:33:04 <kmc> the IO manager in GHC already does it for you
08:34:01 <kmc> you should almost always use threads and blocking IO and count on the RTS to do scheduling
08:35:35 <Athas> I can't easily, because Xlib is not threadsafe.
08:35:42 <Athas> So I need a single thread that does all interaction with X.
08:35:57 <mornfall> Doesn't matter as long as you don't run multiple OS threads.
08:36:05 <Zao> Athas: Have you've considered using the existing xlib/xcb bindings?
08:36:06 <mornfall> Hm.
08:36:23 <mornfall> Or maybe it does. Depends. :“
08:36:28 <Athas> Zao: I am using the Xlib binding, and it is not threadsafe.
08:36:46 <kmc> Athas, you can create a single Haskell thread, ensure that it always runs on the same OS thread, and pass IO actions to it from other threads
08:36:54 <kmc> this is how the gtk bindings work
08:38:33 <da-x> do you also sometimes find yourselves replacing hardcoded IO with (MonadIO => m) m in other people's libraries?
08:38:56 <kmc> not especially
08:44:50 <Athas> Alright, I think I can manage that, next question:  is a semi-comprehensive Haskell interface to fcntl available?
08:45:02 <Athas> Or ioctl?
08:52:14 <stepkut> I have code like, \handle -> do { fd <- peekFd handle ; action fd }. But because I am 'done' with the handle after the peekFd, the handle gets garbage collected and the fd gets closed while I am trying to use it in action. What is the proper way to stop the finalizer from running before I am done with the fd ?
08:53:21 <Athas> What if you dup the fd?
08:53:53 <kmc> stepkut, perhaps with an explicit hClose after your action
08:54:48 <stepkut> kmc: no, because in some cases people might be using the handle more after calling that function. (It's only a problem when they don't)
08:55:03 <kmc> where's peekFd from?
08:55:12 <stepkut> right now I am just doing something like, \handle -> do { fd <- peekFd handle ; a <- action fd ; handle `seq` (return a) }
08:55:38 <stepkut> kmc: the sendfile library.
08:55:55 <kmc> it seems that peekFd should be more like "withFd"
08:56:07 <stepkut> kmc: yes, that is what I am changing it to, peekFd :: Handle -> (Fd -> IO a) -> IO a
08:56:08 <kmc> i don't see it, latest version?
08:56:27 <stepkut> kmc: in the currently avaliable sendfile library it is the handleToFd function
08:56:47 <kmc> i don't see that either
08:56:53 <deech> Hi all, I am trying to understand GADT's and the popular use-case seems to be  arithmetic expression evaluation (http://en.wikibooks.org/wiki/Haskell/GADT). I've written a small `eval` function (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26841#a26841) that doesn't use GADT's but still works. So can someone tell me why GADT's are a good idea?
08:56:57 <stepkut> kmc: I am going to add the new, peekFd :: Handle -> (Fd -> IO a) -> IO a, once I figure out how
08:57:14 <stepkut> handleToFd is in Network.Socket.SendFile.Internal and is not exported
08:57:15 <kmc> deech, because then you can write "eval :: Expr a → a"
08:57:27 <FunctorSalad> deech: they're not necessary for single-typed arithmetic
08:57:31 <FunctorSalad> without having read your link
08:57:37 <kmc> deech, GADTs allow you to model your language's type system using Haskell's type system
08:57:43 <stepkut> kmc: one moment
08:58:20 <kmc> deech, try to add Expr constructors "IsZero Expr" and "If Expr Expr Expr"
08:58:25 <kmc> producing and consuming booleans, respectively
08:58:52 <kmc> oh, i see, you already have two types
08:58:53 <stepkut> kmc: http://patch-tag.com/r/mae/sendfile/snapshot/current/content/pretty/src/Network/Socket/SendFile/Internal.hs
08:59:10 <kmc> you're basically abusing Either to be the "Value" type of your interpreter
08:59:26 <stepkut> handleToFd is using withHandle_, so maybe I should just run the user action inside the withHandle_.. that should do it..
08:59:29 <deech> kmc: Ah, I see an explosion of 'case' statements, but then perhaps 'B Bool' doesn't belong in the Expr datatype to begin with.
08:59:46 <kmc> but there's no static type guarantees -- at runtime, you might try to add two bools, and throw an exception, or (as you do) return some arbitrary value
08:59:49 <da-x> if a functions receives a parameter of type 'a -> IO b' and I have a value of type 'MonadIO m => a -> m b ', is it possible to pass this parameter somehow to the function?
09:00:32 <kmc> not easily da-x
09:00:52 <kmc> edwardk was talking about some hack (using type families?) which would sort of manually take apart common mtl transformer stacks
09:01:21 <da-x> okay, I'll look into it..
09:01:32 <kmc> sorry i don't have more info on where to find that
09:01:45 <deech> kmc: So why make 'add' a typeclass pull the boolean into another datatype and only implement 'add' for the integers?
09:02:02 <deech> s/why make/why not make/
09:02:16 <kmc> deech, not sure how type classes help
09:02:21 <FunctorSalad> because you want to do case analysis on a given term
09:02:36 <FunctorSalad> so you need an (G)ADT, not something open-ended
09:02:36 <pikhq> da-x: You don't have a value of type MonadIO m => a -> m b.
09:02:43 <kmc> there is in fact a way to convert GADTs to type classes, see the paper "finally tagless, partially evaluated"
09:02:53 <kmc> but you probably don't want that here
09:03:12 <pikhq> :P
09:03:53 <pikhq> ... Wait.
09:04:00 <pikhq> Imma go back to my coffee.
09:04:32 <da-x> I'm trying to use snap together with berkeleyDB. snap has 'Snap' monad (which implements MonadIO), and berkeleyDB uses IO directly. The problem is that once I do liftIO in order to do the berkeley db stuff I don't have access to the Snap monad.
09:05:22 <da-x> I was trying to convert hardcoded IO stuff in berkeleyDB to 'MonadIO m =>' and then I bumped into 'bracket' which receives IO actions as parameters.
09:07:42 <kmc> yeah, there's no general way to flatten an arbitrary stack over IO onto IO
09:08:09 <kmc> but in many specific cases it's possible, because the IO monad has so much stuff built in
09:08:33 <kmc> (versus, say, flattening a stack over Identity into just Identity, which would be usually impossible and never useful)
09:19:49 <exDM69> is there a way to "join" a haskell thread? like pthread_join?
09:20:09 <exDM69> or should I use an MVar?
09:20:30 <kmc> your options are to use a primitive like MVar, or use a library that uses them for you
09:20:43 <exDM69> alright, thanks
09:20:53 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26842#a26842 here's my little recipe for it
09:21:01 <catenate> Say I have an expression like (2 + 2) or ("2 + 2").  Is there a way I can create (putStrLn ("2 + 2 = " ++ (show (2 + 2)))) from it, so I can have a bunch of calls like do(2 + 2) or do("2 + 2") instead of duplicating the entire putStrLn many times?  This is the kind of thing Lisp can do with its macros, I believe.
09:21:07 <kmc> you needn't expose the MVar to the whole world
09:21:27 <kmc> catenate, you could do it with macros in Haskell too
09:21:40 <kmc> would be a pretty straightforward use of haskell-src-meta quasiquoters, as those go
09:22:35 <kmc> aww, h-s-m is broken on ghc 6.12
09:23:34 <cheater99> isn't berkleydb like ancient?
09:23:34 <soupdragon> catenate, you can do this without macros in haskell
09:23:46 <cheater99> it's getting dropped from all languages
09:24:07 <kmc> soupdragon, how?
09:24:21 <soupdragon> catenate, suppose 2 + 2 ~> 4 :: Integer but 2 + 2 ~> 2 + 2 :: Symbolic
09:24:33 <soupdragon> instantiate the expression using different Num instances
09:24:46 <kmc> that's not a general solution
09:24:50 <soupdragon> yes it is
09:25:04 <cheater99> hi kmc and soupdragon
09:25:06 <soupdragon> you just need to make new typeclasses
09:25:14 <kmc> hi cheater99
09:25:30 <kmc> soupdragon, yes, for every function in your code and every library you use
09:26:37 <catenate> so something like myPrint :: (IntSym a) => a -> String
09:26:40 <catenate> ?
09:27:12 <kmc> it feels rank-2
09:27:22 <kmc> because the arg to myPrint is required to be polymorphic
09:27:29 <kmc> it's required that it can be used both numerically and symbolically
09:27:41 <catenate> I just read something on that
09:27:47 <kmc> for example, myPrint :: (forall a. (Num a) ⇒ a) → String
09:28:00 <catenate> yeah, that rings the bell
09:28:39 <catenate> Are both Integer and Symbolic under Num?
09:28:51 <kmc> i don't know which Symbolic you refer to
09:28:56 <kmc> but if (+) works on it, then yes
09:28:57 <catenate> Or would Num be the new typeclass?
09:29:08 <kmc> unless you've redefined (+) away from the Prelude version
09:29:46 <soupdragon> catenate, I was saying that you could define a new type called Symbolic and give it a Num instnace
09:29:59 <catenate> Ok
09:30:05 <kmc> > let f :: (forall a. (Num a) => a) -> String; f x = show (x :: Expr) ++ " = " ++ show (x :: Integer) in f (2 + 2)
09:30:06 <lambdabot>   "2 + 2 = 4"
09:30:33 <kmc> lambdabot's Expr comes from simple-reflect
09:30:35 <catenate> awesome
09:30:45 <kmc> which is probably the place to start if you want to go this route
09:32:00 <catenate> Is there another route you think would serve better?  How close is this to a general mechanism to interpret expressions in different ways?
09:32:08 <kmc> it is not very close
09:32:18 <kmc> it won't even handle 2 == 3
09:32:43 <kmc> if you want a general mechanism, you'll need something like macros
09:33:03 <soupdragon> > let __ = __ ; e __ = (2 + 2)`asTypeOf`__ in show (e (__ :: Expr)) ++ " = " ++ show (e (__ :: Integer))
09:33:04 <lambdabot>   "2 + 2 = 4"
09:34:03 <kmc> soupdragon, is that to avoid higher-rank types?
09:34:14 <soupdragon> I don't know if it does avoid higher rank types
09:34:25 <soupdragon> I just like __ = __
09:34:35 <kmc> haha
09:34:55 <kmc> :t let __ = __ ; e __ = (2 + 2)`asTypeOf`__ in e
09:34:56 <lambdabot> forall t. (Num t) => t -> t
09:35:48 <alexyk> is cereal binary-compatible with binary?
09:38:36 <alexyk> or, is binary cereal-compatible with cereal?
09:42:20 <kmc> catenate, in this case, C preprocessor macros are good enough: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26843#a26843
09:43:04 <kmc> catenate, whatever GHC uses for -XCPP by default seems not to understand the CPP stringify operator #
09:43:11 <kmc> so i tell GHC to user /usr/bin/cpp explicitly
09:45:13 <catenate> very cool.  Not type-checked or anything, but I don't really need that for a print, and the point is to handle any types.
09:45:44 <kmc> yeah.  here's a case where string-level metaprogramming really beats AST-level metaprogramming, i think
09:46:02 * kmc wonders if anyone preprocesses their Haskell code with M4
09:46:12 <hpc> M4?
09:46:18 <kmc> M4
09:46:54 <monochrom> MI4
09:47:10 <monochrom> but no, I think m4 is too crazy :)
09:48:25 <kmc> catenate, if the thing you pass isn't an instance of show, you should get a /halfway/ decent error message
09:49:28 <catenate> This is just to make pretty output for tests as I work through RWH, so it's no big deal, it's not production code or anything.
09:49:47 <kmc> oh another heavyweight solution would be to use "hint"
09:50:14 <kmc> or shell out to 'ghc -e', or run ghci in a subprocess
09:53:10 <catenate> Usage of hint seems imperative?  example.hs at http://code.haskell.org/hint/devel/examples/ has everything in a do and uses <-
09:53:21 <catenate> is that just style for the example?
09:55:53 <kmc> that's correct, it wants to run in an interpreter monad
09:56:08 <Botje> "Interpreter () is InterpreterT IO ()"
09:56:10 <kmc> which basically exposes a subset of the GHC API
09:56:26 <Itkovian> ByteString, is that C-based code underlying the Haskell code?
09:56:33 <soupdragon> catenate, you could also write a single num instance for a data type which stores the symbolic and numerical content as a pair
09:56:58 <kmc> it's a good question, whether you could consider Haskell evaluation to be a pure function
09:57:12 <soupdragon> e.g.  instance (Num a, Num b) => Num (a,b) where (a,x) + (b,y) = (a+b,x+y) ; etc
09:57:27 <soupdragon> then type Numericosymbolic = (Integer,Expr)
09:57:39 <soupdragon> eval = fst ; display = snd
09:58:25 <kmc> you'd have to pass the context of imports etc. explicitly
09:58:58 <kmc> so what would cause an "eval" function for Haskell to be not referentially transparent?
09:59:19 <kmc> if you eval code which uses unsafePerformIO or similar
09:59:38 <kmc> if you upgrade your Haskell libraries while the interpreter is running
10:01:35 <catenate> Expr is Text.Parsec.Expr?
10:01:40 <kmc> any other case?
10:01:46 <kmc> catenate, which Expr?
10:02:03 <catenate> The one in soupdragon's let
10:02:18 <catenate> sorry, your let
10:02:18 <kmc> lambdabot's Expr is Debug.SimpleReflect.Expr.Expr from simple-reflect
10:02:30 <catenate> Aha!
10:02:46 <catenate> That would explain mhy installing Text.Parsec did not help
10:03:04 <kmc> you don't have Parsec already?
10:03:09 <kmc> it comes with Haskell Platform
10:03:13 <soupdragon> catenate you're meant to implement it yourself
10:03:48 <catenate> Didn't install HP yet, running with a ghc install on Ubuntu
10:04:53 <kmc> ok
10:17:57 <cheater99> hi guys
10:18:32 <Zao> Meep meep.
10:19:05 <cheater99> i want to write a fairly simple script in haskell but have no idea how i would do that. i have a text file in which some lines have strings enclosed in pairs of double quotes
10:19:19 <cheater99> and i would like to extract those strings. how would i do that?
10:19:33 <kmc> cheater99, there's other stuff on those lines?
10:19:43 <kmc> do the strings have escaped characters, especially escaped double quotes?
10:20:00 <cheater99> they do not
10:20:06 <cheater99> there is stuff before and after
10:20:34 <kmc> so if a line contains two " characters, you want to slurp everything between the first and second one?
10:20:39 <cheater99> yes
10:20:47 <kmc> ok
10:20:50 <cheater99> i was thinking of pattern matching somehow
10:20:54 <cheater99> but don't know how :S
10:21:02 <kmc> coding that search is pretty straightforward, either directly or using any of a number of libraries
10:21:06 <kmc> you may find something useful in Data.List
10:21:35 <cheater99> how would i code that directly?
10:21:51 <kmc> with a couple recursive functions
10:21:55 <kmc> which traverse the list one character at a time
10:22:31 <cheater99> ok so i'd first throw away everything before the first " and then everything after the second "
10:22:33 <kmc> i'm guessing also you don't care about efficiency of processing huge files
10:22:35 <kmc> yeah cheater99
10:22:43 <cheater99> ok, sounds good
10:22:47 <cheater99> let me try that
10:22:59 <kmc> i think it would be a useful exercise to code the recursion yourself, and then look at Data.List and see what you can use to make it more concise
10:23:04 <kmc> good luck :)
10:23:20 <cheater99> i think i'll just code it on my own
10:23:30 <catenate> sed -n 's,^[^"]*"\([^"]*\)".*,\1,p' file ;)
10:28:08 <catenate> I downloaded simple-reflect with cabal, just to get started, but it still can't find Expr after I import Debug.SimpleReflect.Expr
10:28:57 <catenate> Tring the XRanxNTypes solution first, then I'll probably go to the cpp solution
10:35:09 <catenate> kmc: cpprint.lhs:4:1: lexical error at character 'd'
10:35:19 <catenate> didn't like the #define
10:36:54 <cheater99> what am i doing wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26844#a26844
10:37:53 <cheater99> Type constructor `Char' used as a class
10:38:12 <catenate> ok, my bad, I was trying to do it in a lhs file without enough >
10:38:24 <epicbeardman_> cheater99: Char is not a class, hence cannot be used as context
10:38:34 <cheater99> ok, so what should i be using there?
10:38:37 <cheater99> i want to process strings.
10:38:44 <monochrom> [Char] -> [Char]
10:38:55 <cheater99> do i need any classes?
10:39:15 <edwardk> catenate import Debug.SimpleReflect
10:39:16 <hpc> a char is just a letter
10:39:20 <edwardk> it imports both Expr and Vars
10:39:32 <edwardk> the Expr module iirc only exports the expression type, and no variables
10:39:46 <monochrom> it's too bad haskell doesn't allow colours or fonts in its syntax. could have used blue for type classes and red for types, then there is no confusion.
10:39:47 <cheater99> hpc: yes
10:39:54 <sepp2k> cheater99: You only need classes when you want to be able to pass in different types of values which have some operations in common.
10:40:00 <hpc> > let processString s = s++" bacon" in map processString ["canadian", "american"]
10:40:01 <lambdabot>   ["canadian bacon","american bacon"]
10:40:06 <cheater99> sepp2k: ok
10:40:14 <hpc> no classes
10:40:22 <epicbeardman_> monochrom: or perhaps if we used more than just uppercase and lowercase.
10:40:35 <epicbeardman_> I suppose making classes ALLUPPER would suck.
10:40:48 <Baughn> Truly.
10:40:52 <monochrom> plain text file has too many restrictions
10:41:07 <catenate> edwardk: taking off the .Expr, ghc complains that Expr not in scope
10:41:11 <cheater99> ok, now..
10:41:21 <cheater99> how do i enter the edge condition for an empty list?
10:41:27 <hpc> []
10:41:39 <cheater99> yeah, but should i use a separate pattern, or can i do it in a guard?
10:42:01 <hpc> pattern is prefered
10:42:11 <cheater99> ok
10:42:14 <hpc> you can do | length s == 0 = something
10:42:18 <cheater99> aha
10:42:20 <seric> how do i test if a string starts with a "x" and ends with a "x"? I tried with: isFoo x:xs:x = x `elem` ["x"] but that seems to be wrong
10:42:24 <hpc> but that dies on infinite lists, if you ever need that
10:42:29 <cheater99> nah, i'll use a pattern - thanks
10:42:31 <cheater99> aha
10:42:36 <monochrom> if you want boolean, null xs
10:42:42 <sepp2k> cheater99: You can't do it in a guard in this case, because guards are only checker if the pattern matches.
10:42:56 <cheater99> ahh
10:42:57 <cheater99> alright
10:43:19 <sepp2k> The pattern (x:xs) does not match the empty list, so any guard that checked whether the list is empty would always be false.
10:43:54 <epicbeardman_> seric: head xs == last xs == 'x' perhaps?
10:44:12 <monochrom> can't chain == like that. use &&
10:44:22 <epicbeardman_> ty monochrom
10:44:28 <seric> trying
10:45:14 <kmc> «length s == 0» is really bad form
10:45:21 <epicbeardman_> null s
10:45:22 <kmc> «not $ null s» is better
10:45:43 <kmc> "head" and "last" are also good to avoid
10:46:16 <kmc> last is harder to avoid though
10:46:19 <seric> so what's best of testing that then?
10:46:21 <kmc> seric, you can't bind the same variable twice
10:46:33 <catenate> kmc: got the cpp working, thanks
10:47:04 <kmc> isFoo xs@('x':_) = last xs == 'x'; isFoo _ = False
10:47:18 <kmc> in this case "last" is safe because you know there's at least one element, by pattern matching
10:47:42 <seric> kmc: great, thanks
10:47:47 <cheater99> hmm ok, how do i match against the last element in a list?
10:48:00 <kmc> cheater99, you reverse the list first
10:48:01 <epicbeardman_> kmc: just looked at the docs for last.. didn't know it threw an error.
10:48:14 <Lycurgus> anybody know of a haskell app server not in this list: happstack, snap, yesod?
10:48:30 <kmc> cheater99, lists are meant to be accessed from one side only
10:48:46 <kmc> cheater99, but take a look at Data.Sequence
10:49:07 <cheater99> ok so i did stripAfterQuote = reverse stripBeforeQuote reverse
10:49:12 <monochrom> f x = not (null x) && head x == 'x' && last x == 'x'
10:49:33 <cheater99> aaand... it doesn't work.
10:49:51 <kmc> cheater99, did you mean to compose those functions instead of applying them?
10:50:29 <cheater99> i guess!
10:50:49 <cheater99> how do you compose?
10:50:55 <kmc> f xs@('x':_) | ('x':_) <- reverse xs = True; f _ = False
10:51:21 <cheater99> is that for me?
10:51:32 <kmc> cheater99, so what you mean is probably «stripAfterQuote x = reverse (stripBeforeQuote (reverse x))» yes?
10:51:39 <cheater99> yes
10:51:44 <cheater99> but i wanted to be nice and pointfree
10:51:50 <kmc> the more concise way to write that is ««stripAfterQuote = reverse . stripBeforeQuote . reverse»
10:51:54 <kmc> @src (.)
10:51:54 <lambdabot> (f . g) x = f (g x)
10:51:55 <lambdabot> NB: In lambdabot,  (.) = fmap
10:52:55 <cheater99> sweet
10:53:01 <cheater99> thank you very much, it works well now
10:53:27 <kmc> :)
10:53:35 <kmc> probably not too efficient on huge lines
10:53:39 <kmc> but it's likely you don't care
10:54:11 <cheater99> why would it not be efficient?
10:54:38 <kmc> because «reverse» has to walk to the end of the list
10:54:42 <cheater99> does it need to traverse the whole list to yield every char?
10:54:48 <kmc> which takes time linear in the length of the list
10:54:57 <cheater99> ok, so it needs to do that just once?
10:55:22 <kmc> well, you're calling reverse twice within stripAfterQuote
10:55:30 <kmc> also you'll copy the string
10:55:39 <kmc> you can drop characters from the beginning of a string without copying, but not from the end
10:56:11 <kmc> basically String is the simplest and laziest string type, which is why it's the default
10:56:16 <kmc> it's not the most efficient
10:56:25 <kmc> and it's asymptotically less efficient than people often expect
10:56:36 <cheater99> yeah i would need a deque of some sort to be able to go on without reversing i guess
10:56:39 <kmc> so there are several libraries providing faster, more complicated alternatives
10:56:57 <cheater99> ok
10:57:06 <kmc> cheater99, ByteString supports fast slicing -- it just stores offset and length, and a pointer into the original buffer
10:57:14 <kmc> of course ByteString is a string of bytes, not a string of characters
10:57:21 <cheater99> ok
10:57:51 <kmc> but there's "text" providing something similar for chars
10:58:20 <cheater99> cool
10:58:22 <cheater99> nah, don't worry
10:58:27 <cheater99> it's just a simple script thing
10:58:31 <kmc> Data.Sequence is a good reasonably efficient general purpose list-like type
11:00:22 <wli> fuck how the hell do you ignore unaffiliated hostmasks?
11:01:05 <epicbeardman_> could someone take a look at this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26839#a26840
11:01:13 <epicbeardman_> I'm having a precision problem.
11:01:36 <cheater99> hmmmm
11:02:01 <epicbeardman_> I'm trying to take a decimal number and convert it to a continued fraction. The algorithm is simple: take the integer part of the number, put it in a list, then take the reciprocal of the decimal part and start again
11:02:46 <soupdragon> epicbeardman_
11:02:58 <soupdragon> why have you written 0.0000000000001
11:03:10 <soupdragon> you should use rational numbers (a/b for a,b Integer) instead
11:03:11 <epicbeardman_> as an ugly hack
11:03:19 <soupdragon> that way it will not have any precision problem
11:03:40 <soupdragon> > 15%3
11:03:41 <lambdabot>   5 % 1
11:03:46 <kmc> "a/b for a,b Integer" will not work
11:03:47 <soupdragon> > numerator $ 15%3
11:03:48 <lambdabot>   5
11:03:56 <soupdragon> > numerator $ (15::Integer)%3
11:03:57 <lambdabot>   5
11:03:58 <soupdragon> it works......
11:04:19 <kmc> > (5 :: Integer) / (3 :: Integer)
11:04:20 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
11:04:20 <lambdabot>    aris...
11:04:22 <kmc> no it doesn't
11:04:24 <soupdragon> but it wont do any rational numbers
11:04:28 <soupdragon> I mean irrational
11:04:30 <soupdragon> kmc okay
11:04:38 <kmc> :t 0.0000000000001
11:04:39 <lambdabot> forall t. (Fractional t) => t
11:04:54 <soupdragon> not really what I was talking about
11:04:56 <kmc> if you look at Fractional
11:05:07 <epicbeardman_> kmc: I'd like to do away with that case altogether
11:05:13 <kmc> you'll see that the way this literal is interpreted is through fromRational
11:05:15 <epicbeardman_> but it's the only thing that (occasionally) stops the computation
11:05:38 <kmc> so you lose no precision by writing a decimal literal
11:05:45 <edwardk> soupdragon: 0.000000000000001 desugars to a rational if needed
11:05:57 <kmc> > 0.000000000000000000000000000000000000000000000000000000000000000000000000000000001 :: Rational
11:05:57 <lambdabot>   1 % 10000000000000000000000000000000000000000000000000000000000000000000000...
11:06:00 <soupdragon> he's using <= 0.000000000000001 
11:06:17 <soupdragon> I think it should be  == 0 
11:06:31 <soupdragon> You don't do == 0 with Float or Double though
11:06:33 <edwardk> yeah
11:06:39 <soupdragon> That is why I am saying to use a fraction of two Integers
11:06:58 <edwardk> who says you have to use a continued fraction with a float or double? and if you do just cut it off after some arbitrary number of terms
11:07:13 <cheater99> is there a lib function to split a string by \n?
11:07:20 <edwardk> @type lines
11:07:22 <lambdabot> String -> [String]
11:07:25 <wli> (specializing denominators to N^+ might make some sense)
11:07:42 <cheater99> what if i want to split by something else, say by ; ?
11:07:44 <epicbeardman_> edwardk: I can cut it off arbitrarily after, but I'm still getting incorrect terms.
11:08:07 <kmc> cheater99, the "split" library
11:08:12 <epicbeardman_> the <= 0.000...1 just filters some of the bad terms out.
11:09:03 <epicbeardman_> at some point, certain calculations are apparently giving me something like 1/.0000000000000000000n, I do'nt know why that is, and it shouldn't be happening.
11:09:10 <edwardk> @ type  \delim = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break (==delim))
11:09:17 <edwardk> @type \delim = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break (==delim))
11:09:18 <lambdabot> parse error on input `='
11:09:26 <edwardk> @type \delim -> takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break (==delim))
11:09:27 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
11:09:31 <edwardk> there ;)
11:09:41 <wli> Something like 1.0e-14 might be notationally easier.
11:09:41 <epicbeardman_> those small fractions end up giving me wrong terms at the end of  the CF
11:09:52 <epicbeardman_> wli: it's still not a solution
11:10:16 <edwardk> epicbeardman_: can you give me an example of a value you are trying to convert and how it goes wrong?
11:10:31 <wli> epicbeardman: It's not a solution. It's just easier to write than 10 zeros or however many it is.
11:11:11 <edwardk> @type \delim -> takeWhile (not . null) . unfoldr (Just . span (/= delim) . dropWhile (== delim))
11:11:12 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
11:11:41 <cheater99> ok, i'm having a problem now. readFile "input.txt" returns the contents of input.txt, and doing lines on a string literal that contains that stuff works too, but doing lines (readFile "input.txt") gives me a type mismatch
11:11:54 <monochrom> I wonder why you use floor when you already use properFraction
11:12:00 <epicbeardman_> edwardk: try doing `take 100 $ toCF' 2.000345'
11:12:24 <epicbeardman_> the 9th term, which is large, is incorrect, and so are all terms after that.
11:12:24 <edwardk> cheater99: that is because readFile returns an IO String and lines takes a String. you need to use something like (>>=) or fmap to get 'into' the IO
11:12:32 <epicbeardman_> the CF should stop at the 8th term.
11:12:38 <cheater99> i'm not sure what that means
11:12:49 <cheater99> what is >>= and why would i have to use it?
11:12:50 <edwardk> cheater99: fmap lines (readFile "input.txt") -- will work
11:12:57 <edwardk> cheater you need to learn monads
11:13:14 <edwardk> the above line will only carry you so far =)
11:13:18 <cheater99> yes
11:13:29 <cheater99> can you explain why this doesn't work then?
11:13:42 <edwardk> unlike what you expect 'readFile "input.txt"' doesn't return a string!
11:13:52 <edwardk> it returns a recipe for how to return the string.
11:13:57 <edwardk> that is an 'IO action'
11:13:59 <kmc> cheater99, http://haskell.org/haskellwiki/Introduction_to_IO
11:14:01 <cheater99> ok
11:14:09 <cheater99> go on edwardk
11:14:10 <kmc> you don't actually need to learn monads yet
11:14:10 <edwardk> we separate out evaluation from execution in Haskell
11:14:20 <cheater99> i understand that part
11:14:27 <kmc> you need to learn this type called "IO", which happens to be a monad, but that fact is irrelevant until you see some *other* monads later
11:14:34 <edwardk> you can make an action that doesn't actually do anything extra with 'return'
11:14:41 <cheater99> ok, so the type "IO String" is a 'recipe how to get a string' yes?
11:14:47 <edwardk> return :: a -> IO a -- just gives you the action that gives you back your argument
11:15:01 <edwardk> so return "Hello" -- is a recipe for how to get Hello.
11:15:06 <kmc> yes cheater99
11:15:09 <cheater99> ok
11:15:16 <edwardk> (>>=) is how we glue together these recipes
11:15:19 <cheater99> how do i actually get that string then?
11:15:24 <edwardk> @type (>>=)
11:15:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:15:31 <edwardk> read 'm' there as IO
11:15:35 <cheater99> does >>= actually 'execute the action' 
11:15:37 <edwardk> IO a -> (a -> IO b) -> IO b
11:15:40 <edwardk> nope
11:15:47 <edwardk> IO makes a bigger action
11:15:51 <kmc> cheater99, it takes an action, and a function which produces another action, and glues them together
11:15:51 <Botje> .oO(is it wrong for me to think that unsafeLaunchMissiles would be a suitable band-aid?)
11:15:58 <kmc> might be useful to understand (>>) first
11:15:59 <edwardk> out of one action that knows how to get the argument for the second action
11:16:07 <kmc> (>>) :: IO a -> IO b -> IO b
11:16:32 <kmc> (x >> y) is a recipe for "do x, then do y, and produce the result from y"
11:16:32 <edwardk> readFile "input.txt" >>= \x -> putStrLn x
11:16:33 <cheater99> @type lines
11:16:34 <lambdabot> String -> [String]
11:16:44 <edwardk> will make a recipe for reading the input from a file and then printing it to the screen
11:16:46 <cheater99> wait wait
11:16:47 <kmc> then (>>=) is like (>>), except you're allowed to use the result of the first action to decide what to do second
11:16:55 <kmc> cheater99, did you see the link i pasted?
11:16:58 <edwardk> i'm going to back off and let kmc explain, since i don't want to flood you =)
11:17:05 <kmc> it might be better for you to read that and then come back with questions
11:17:18 <epicbeardman_> edwardk: any ideas what might be going wrong?
11:17:25 <cheater99> kmc: i'm reading what you guys are writing, i'll look at it after
11:17:29 <kmc> ok
11:17:33 <edwardk> epicbeardman_: sorry have been explaining IO haven't looked yet =)
11:17:40 <epicbeardman_> k :)
11:17:50 <wli> > unfoldr (\x -> guard (x /= 0) >> return (properFraction $ recip x)) . recip $ (22/7 :: Rational)
11:17:51 <lambdabot>   [3,7]
11:17:52 <cheater99> edwardk: i got lost when i asked you about >>= and you answered about IO
11:18:01 <edwardk> cheater99: so now, the next thing is, you don't just 'get out of IO, you move other things in. IO is infectious.
11:18:11 <edwardk> (>>=) describes how to glue together recipes
11:18:18 <cheater99> edwardk: that's too far, you need to back-track.
11:18:28 <hpc> it's easier to explain in terms of Maybe, i think
11:18:33 <soupdragon> epicbeardman_: so for a/b the continued fraction is  x1 + 1/(x2 + 1/(...))  and we want to find the list [x1,x2,..]
11:18:45 <epicbeardman_> soupdragon: correct
11:18:51 <soupdragon> so convert a/b to the form k + p/q where (p/q < 1)
11:18:54 <edwardk> hpc: sure lots of pedagogical directionals to go. but i was trying to directly address his question. ;)
11:19:01 <soupdragon> then take the continued fraction of q/p (recursion)
11:19:06 <edwardk> er directions
11:19:12 <edwardk> cheater99: ok, so you understand return
11:19:28 <cheater99> i understand that a function using it creates an 'action'.
11:19:30 <soupdragon> So you need to implement (1) subroutine to convert fractions into that special form
11:19:39 <soupdragon> (2) recursive function
11:20:05 <edwardk> ok, now, 'main' has type IO () in Haskell. So the main function is an IO action you want your program to run
11:20:23 <edwardk> the compiler evaluates it, and then executes it
11:20:36 <cheater99> ok, but i'm not sure why you're telling me
11:20:40 <edwardk> so you don't 'get out of IO' you glue together a bigger and bigger IO action that is your program
11:20:48 <cheater99> ok
11:20:49 <cheater99> yes
11:20:51 <cheater99> agreed
11:21:00 <edwardk> now, sometimes you don't care about IO
11:21:05 <edwardk> you want to write a pure function
11:21:11 <cheater99> yes
11:21:17 <edwardk> and you need to get that argument to that function using an IO action
11:21:19 <epicbeardman_> soupdragon: I found the algorithm I described before to be easier
11:21:40 <edwardk> fmap :: (a -> b) -> IO a -> IO b -- works in this case (the type signature allows it to be sued over other functors as well)
11:21:48 <epicbeardman_> it's easier than dealing with fractions all over the place, I just seem to be running afoul of precision
11:21:53 <epicbeardman_> and I don't know how.
11:22:02 <edwardk> fmap gives you a recipe for running the first recipe, and then applying your function to its output
11:22:12 <soupdragon> epicbeardman_, where is the descrption?
11:22:22 <edwardk> this is what you need in order to apply lines,
11:22:32 <soupdragon> I think the reason I suggested to use fractions is to aviod the problem >:)
11:22:36 <edwardk> fmap lines (readFile "input.txt") :: IO [String]
11:22:52 <soupdragon> suppose  properFraction :: Rational -> (Integer, Rational)  is the subroutine
11:22:57 <epicbeardman_> soupdragon: http://www.willamette.edu/~mjaneba/help/frac.html
11:22:58 <cheater99> ok ok
11:23:15 <wli> Is there something wrong with unfoldr (\x -> guard (x /= 0) >> return (properFraction $ recip x)) . recip ?
11:23:16 <edwardk> cheater99: as for (>>=) you use it when you want to say 'do this, then do that'
11:23:21 <cheater99> so fmap converts from String -> [String] to IO String -> IO [String] yes?
11:23:26 <edwardk> yep
11:23:46 <cheater99> is fmap only for IO or for other things too?
11:23:49 <soupdragon> then  continuedFraction (properFraction -> (x, 0)) = [x] ; continuedFraction (properFraction -> (x, q)) = x : continuedFraction (1/q) ; 
11:23:55 <edwardk> with readfile and fmap alone you can only ever have one effect though! 
11:23:57 <hpc> fmap is for any instance of Functor
11:24:02 <kmc> :t fmap
11:24:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:24:10 <edwardk> fmap works over any functor, TONS of things are functors in Haskell
11:24:24 <cheater99> so how does it know it should 'convert to IO'?
11:24:25 <epicbeardman_> soupdragon: that's not right.
11:24:29 <cheater99> if i don't tell it explicitly?
11:24:30 <hpc> cheater99: context
11:24:35 <epicbeardman_> you don't just take the numerator
11:24:37 <c_wraith> I think IO is one of the functors I use most often.
11:24:50 <edwardk> because the input (or output) is constrained to be an IO action the type checker figures it out
11:24:54 <soupdragon> I think that what I wrote is correct
11:25:00 <soupdragon> I'll write it out and test it
11:25:07 <edwardk> @instances IO
11:25:08 <lambdabot> Couldn't find class `IO'. Try @instances-importing
11:25:10 <edwardk> er 
11:25:13 <edwardk> @instances Functor
11:25:14 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:25:22 <hpc> that's just a taste
11:25:28 <kmc> cheater99, in «fmap lines (readFile x)», «readFile x :: IO String», which fitting that into the second arg of "fmap" forces m = IO
11:25:29 <cheater99> ok
11:25:32 <edwardk> plus Map, Array, almost every container type, etc.
11:25:43 <hpc> almost?
11:26:01 <kmc> not Set (or Map on its keys) because of Ord constraint
11:26:02 <hpc> which containers aren't functors?
11:26:07 <edwardk> hpc: Set for one
11:26:08 <hpc> oh right
11:26:14 <cheater99> @type fmap
11:26:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:26:15 <c_wraith> yes, almost.  come to think of it, my lrucache should be a functor and isn't.
11:26:28 * c_wraith goes to make an update
11:26:33 <edwardk> c_wraith: *scoff* =)
11:26:46 <cheater99> how is fmap related to >>= ?
11:26:59 <hpc> :t fmap
11:27:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:27:02 <edwardk> you can define fmap with return and (>>=) for a monad (but not every functor is a monad)
11:27:03 <hpc> :t (=<<)
11:27:04 <edwardk> @src liftM
11:27:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:27:05 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:27:09 <edwardk> or rather
11:27:22 <edwardk> liftM f m1 = m1 >>= \x1 -> return (f x1)
11:27:27 <edwardk> fmap = liftM
11:27:29 <kmc> cheater99, «fmap f x» = «x >>= return . f»
11:27:42 <kmc> except that fmap works for types that don't have (>>=) -- those types which are Functors but not Monads
11:28:07 <cheater99> ok so IO is a functor?
11:28:08 <seric> how may I do a simple output to sdtout within a function? is that even possible?
11:28:11 <edwardk> cheater99: yeah
11:28:13 <cheater99> and a monad?
11:28:13 <kmc> yes, it's a functor and a monad
11:28:15 <edwardk> cheater99: yep
11:28:22 <cheater99> what does it mean that it is a functor?
11:28:22 <kmc> we said that (>>=) is used for "do one thing, choose what to do next, then do it"
11:28:31 <kmc> cheater99, means it's an instance of the type class named "Functor"
11:28:42 <edwardk> cheater99: it means that you can use 'fmap' to swap out its contents to any type you desire
11:28:44 <kmc> means that you have fmap :: (a -> b) -> IO a -> IO b
11:29:01 <seric> oh, got it
11:29:02 <cheater99> edwardk: 'contents'?
11:29:03 <edwardk> that in some sense the value type inside of it is unconstrained and could be anything
11:29:10 <kmc> cheater99, so if (>>=) has that role, then fmap is the case where the "second thing" is just "apply this function and return"
11:29:15 <edwardk> well, consider a Set of values
11:29:26 <cheater99> kmc: i didn't get that
11:29:28 <kmc> "read a file, then apply lines and return"
11:29:29 <edwardk> in haskell we implement Set using a constraint on the elements of the Set
11:29:35 <edwardk> that the elements in the Set have to be an instance of Ord
11:29:40 <kmc> cheater99, don't get what?
11:29:54 <cheater99> kmc: you need to stick to one stream of thought
11:30:05 <edwardk> therefore we can't make Set into a Functor, because you can't substitute ANYTHING in there for the existing elements, but instead can only substitute things for which there is an Ord instance.
11:30:17 <soupdragon> epicbeardman_, it gives [0,2,18,2,1,421407500,2,1,1,1,2] for continuedFraction (0.486725663717 :: Rational)
11:30:18 <kmc> we said that (>>=) is used for "do one thing, choose what to do next, then do it"
11:30:21 <kmc> so if (>>=) has that role, then fmap is the case where the "second thing" is just "apply this function and return"
11:30:35 <cheater99> aha
11:30:46 <epicbeardman_> 0, 2, 18, 2, 1, 421344495 
11:30:50 <kmc> sorry for interposing other answers
11:30:53 <edwardk> Functor gives you a lot of power =)
11:30:56 <cheater99> that's ok <3
11:30:58 <edwardk> Monad gives you even more
11:30:59 <kmc> :)
11:31:07 <soupdragon> > take 30 $ continuedFraction pi
11:31:07 <soupdragon> [3,7,15,1,292,1,1,1,2,1,3,1,14,3,3,23,1,1,7,4,35,1,1,1,2,3,3,3,3,1]
11:31:08 <lambdabot>   Not in scope: `continuedFraction'
11:31:29 <soupdragon> that's correct afaict
11:31:30 <epicbeardman_> soupdragon: although the reference calculator I have seems to not be doing that just right.
11:31:42 <soupdragon> continuedFraction (properFraction -> (i, 0)) = i : []
11:31:42 <soupdragon> continuedFraction (properFraction -> (i, q)) = i : continuedFraction (1/q)
11:31:47 <soupdragon> that's the code if you want
11:32:01 <edwardk> there are different kinds of actions that can use these same combinators though. It need not just be IO. for instance you can use fmap, (>>=) and return to glue together 'Maybe's.
11:32:15 <edwardk> consider the data type: data Maybe a = Nothing | Just a 
11:32:40 <cheater99> edwardk: your explanation of what 'contents' means in the context of ' "fmap" swaps out its contents to any type you desire' has confused me
11:32:42 <edwardk> now, the definition for fmap can only really do one thing (well, it could map everything to Nothing, but we have laws that say no)
11:32:53 <cheater99> i'm not sure what it means that fmap has contents
11:32:55 <edwardk> lets try with the Maybe example, i think it'll make it clear
11:33:09 <edwardk> think of the argument to Just as the 'contents' of your 'Maybe a'
11:33:16 <monochrom> @let foldcf (xs) = foldr1 op (map fromIntegral xs) where {op x y = x + 1/y}
11:33:18 <lambdabot>  Defined.
11:33:19 <edwardk> so a Maybe Int would be Just 12     or it would be Nothing
11:33:25 <cheater99> kmc: ok, so fmap is basically a special case of >>= ?
11:33:32 <Cale> cheater99: The structure that fmap is operating on has contents
11:33:42 <monochrom> epicbeardman_: Do you agree that foldcf above is a correct way to convert continued fractions back to numbers?
11:33:48 <edwardk> cheater99: yes, but it is one that can often be present even when >>= doesn't exist for the data structure.
11:34:00 <cheater99> ok
11:34:09 <Cale> cheater99: Do you know what the 'map' function does for lists? The fmap function is just like that, only it works on other structures too.
11:34:12 <epicbeardman_> monochrom: shoud be
11:34:13 <edwardk> defining fmap for Maybe you'd get:
11:34:18 <edwardk> fmap f (Just a) = Just (f a)
11:34:22 <edwardk> fmap f Nothing = Nothing
11:34:34 <cheater99> Cale: not sure i do, can you bring it up?
11:34:42 <edwardk> where you can use your function to 'swap out the contents' of the Maybe functor.
11:34:48 <Cale> Oh, okay, map just applies a function to each of the elements of a list
11:34:53 <edwardk> fmap (+1) (Just 2) ==> Just 3
11:35:01 <Cale> > map (\x -> x^2 + x + 1) [1,2,3,4,5]
11:35:02 <lambdabot>   [3,7,13,21,31]
11:35:11 <monochrom> > let {y = [2,2898,1,1,4,2,2,1,137110]; a = foldcf y; b = foldcf (init y)} in (a, b, a==b)
11:35:12 <lambdabot>   (2.000345,2.000345,True)
11:35:18 <Cale> > words "here are some words"
11:35:20 <lambdabot>   ["here","are","some","words"]
11:35:24 <Cale> > map reverse (words "here are some words")
11:35:25 <monochrom> the 137110 term doesn't matter numerically
11:35:26 <lambdabot>   ["ereh","era","emos","sdrow"]
11:35:48 <Cale> > map (*2) [1..10]
11:35:49 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
11:35:55 <epicbeardman_> soupdragon: try your function on 2.00345
11:36:00 <Cale> > map (map (*2)) [[1,2,3],[4,5],[6,7,8]]
11:36:02 <lambdabot>   [[2,4,6],[8,10],[12,14,16]]
11:36:04 <epicbeardman_> sorry, 2.000345
11:36:18 <Cale> cheater99: Enough examples to get the idea? :)
11:36:26 <monochrom> to a large extend the extra terms are not "wrong"
11:36:33 <edwardk> map is fmap specialized to lists
11:36:52 <edwardk> Cale: none of your maps changed types
11:36:58 <cheater99> Cale: ok, that's what i thought, i wanted to make sure we're using the same definition
11:37:00 <Cale> edwardk: Oh, good point.
11:37:01 <edwardk> > map length (words "here are some words")
11:37:02 <lambdabot>   [4,3,4,5]
11:37:02 <wli> H98 damage
11:37:08 <soupdragon> 2,289,1,5,1,9
11:37:15 <Cale> and... that was the example I was about to do ;)
11:37:19 <Cale> hehe
11:37:26 <soupdragon> > 2 + 1/(289 + 1/(1 + 1/(5 + 1/(1 + 1/9))))
11:37:28 <lambdabot>   2.00345
11:37:30 <Cale> > map (\x -> (x,x^2)) [1..10]
11:37:31 <lambdabot>   [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
11:37:31 <soupdragon> seems to have worked
11:37:56 <soupdragon> 2,2898,1,1,4,2,3
11:38:01 <monochrom> It is hard to programmatically rule out the extra terms if numerically the computer can't tell the difference.
11:38:15 <soupdragon> > 2+1/(2898+1/(1+1/(1+1/(4+1/(2+1/3)))))
11:38:15 <cheater99> ok, how is fmap a generalization of map?
11:38:16 <lambdabot>   2.000345
11:38:18 <soupdragon> this has also worked
11:38:19 <Cale> cheater99: Okay, so fmap is just like that, only it works on a more arbitrary sort of datastructure
11:38:27 <cheater99> explain
11:38:32 <Cale> cheater99: Whereas  map :: (a -> b) -> [a] -> [b]
11:38:33 <monochrom> You can shrink 0.00000000000001 to 0.0001 if you want earlier stop and fewer terms.
11:38:37 <soupdragon> epicbeardman_: maybe we should attempt an inductive correctness proof
11:38:42 <Cale> we have  fmap :: (a -> b) -> f a -> f b
11:38:42 <hpc> cheater99: let's make a tree
11:38:46 <Cale> for certain types f
11:38:51 <Cale> More specifically:
11:38:58 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
11:38:58 <epicbeardman_> soupdragon: I just seem to keep getting more terms, and I'm not sure why
11:39:35 <hpc> the tree is a binary tree, and we want to apply a function to every element of the tree
11:39:58 <hpc> which is what fmap does; it applies a function to the inside of a structure, while keeping the structure the same
11:40:17 <Cale> The Functor typeclass is where fmap is defined, and we make our various container datatypes instances of it by defining fmap.
11:40:36 <epicbeardman_> soupdragon: anyway, thanks for your help
11:40:48 <soupdragon> well it doesn't seem that I have helped you at all
11:41:00 <c_wraith> the Functor instance doesn't actually make that much sense for the use cases one would typically use an lru cache in...  But I'll support it anyway!
11:41:02 <Cale> So, fmap will operate differently for different sorts of containers, but the idea is always the same: apply the function (a -> b) to all the elements of type a within the structure of type f a to get a structure of type f b
11:41:30 <hpc> the structure is the same, but the contents are different
11:41:39 <hpc> so a list will be the same length
11:41:49 <hpc> a Maybe will still be Just or Nothing
11:41:53 <hpc> and a tree will have the same layout
11:42:27 <monochrom> epicbeardman_: 0.00001 helps truncate. this is a magic number. I can't explain why. Oh, maybe I can: 1/137110 is around there. it's hard to set a good threshold.
11:42:41 <epicbeardman_> monochrom: it will fail in other circumstances.
11:42:46 <monochrom> Yes.
11:42:59 <monochrom> > let {y = [2,2898,1,1,4,2,2,1,137110]; a = foldcf y; b = foldcf (init y)} in (a, b, a==b)
11:43:00 <lambdabot>   (2.000345,2.000345,True)
11:43:02 <cheater99> ok so map is fmap where f = list so to speak?
11:43:10 <edwardk> cheater99: exactly!
11:43:13 <epicbeardman_> I had tried changing it to that
11:43:16 <monochrom> 137110 is there because it makes no difference.
11:43:21 <cheater99> that's well explained
11:43:23 <cheater99> thanks guys
11:43:32 <cheater99> i hope i don't forget that too quickly o_0
11:44:21 <cheater99> how do i not forget this?
11:44:27 <edwardk> cheater99: use it a lot =)
11:44:37 <Cale> You probably won't forget it :)
11:44:38 <cheater99> easier said than done
11:44:44 <cheater99> i can't use haskell every day yet
11:45:11 <edwardk> i'd say about half the types i define in Haskell are instances of Functor.
11:47:11 <monochrom> > foldcf [1,1,1,1,1,1]
11:47:12 <lambdabot>   1.625
11:47:16 <monochrom> > foldcf [1,1,1,1,1,1,1,1,1,1,1]
11:47:17 <lambdabot>   1.6179775280898876
11:47:24 <monochrom> > foldcf [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
11:47:26 <lambdabot>   1.618034447821682
11:47:38 <epicbeardman_> monochrom: the joy of continued fractions.
11:47:44 <monochrom> there is no good way to estimate a good threshold.
11:47:52 <epicbeardman_> exactly.
11:47:59 <epicbeardman_> it's different for every number.
11:48:12 <monochrom> (well, apart from actually converting the cf back to a number to see how many terms matter)
11:48:29 <epicbeardman_> sometimes you get a good approximation in 4 terms, sometimes 14 terms.
11:48:36 <cheater99> what other useful stuff can i do with fmap?
11:48:41 <epicbeardman_> and there seems to be no rhyme nor reason to it.
11:48:46 <Cale> cheater99: The original way to look at Functors is that they send types to types in some fashion: that is, each type t becomes some type F t, and at the same time, they send each function (a -> b) to a function (F a -> F b) (and that's what fmap does)
11:49:36 <Cale> Oh, useful stuff? Well, it's sort of a mundane thing which you'd usually like to have for every container type -- apply a function to all its elements,
11:50:01 <Cale> But also types which are usually thought of as being computations with some result will tend to be functors.
11:50:08 <hpc> use it to shorten monadic do blocks
11:50:26 <monochrom> fmap is as useful as sin
11:50:27 <hpc> fmap words getStrLn
11:50:32 <Cale> For example, if (Parser t) is the type of parsers for parsing a value of type t
11:50:44 <tg_zzz> has anyone run lambdabot on 6.12?
11:50:58 <Peaker> I just got bitten by the monomorphism restriction :( Took me 15 minutes staring at weird type errors
11:51:09 <Peaker> Meant to prevent confusion? It causes confusion!
11:51:34 <Cale> Then given such a parser x :: Parser t, and a function f :: t -> s, you could construct the parser fmap f x which parses the same way as x does, but applies f to the result at the end
11:51:42 <monochrom> there is a law of conversation of confusion. if you remove one you add another.
11:51:43 <Cale> and it would have type Parser s
11:52:12 <epicbeardman_> soupdragon: earlier I had properFraction mixed up with something else, which is why I thought the algorithm was wrong. it is correct.
11:52:13 <monochrom> the confusion removed is "I hardcoded x=0 why does it run so slow?"
11:52:21 <epicbeardman_> and P.S., view patterns rock.
11:52:40 <soupdragon> epicbeardman_: I actually defined it myself, then GHC told me it already exists - luckily enough it was the right function
11:52:55 <cheater99> Cale: gotcha
11:53:00 <Cale> Similarly, if you have an IO action x :: IO t, and a function f :: t -> s, then you get fmap f x :: IO s, an IO action with the same effect as x, but whose result has been modified by f
11:53:12 <monochrom> perhaps it is not an important confusion
11:53:20 <cheater99> is 'IO action' part of the declaration?
11:53:29 <Peaker> monochrom, "Why does it run slow?" is a complicated question in Haskell anyway :)
11:53:38 <monochrom> yeah
11:53:46 <cheater99> Cale ^
11:53:46 <Cale> cheater99: Well, there's an instance of Functor for IO specifically.
11:53:54 <Peaker> monochrom, It's funny to add weirdness to the semantics of types/etc just to get simpler operational semantics -- completely opposite of almost every design decision in Haskell
11:53:55 <monochrom> plus newbies run in ghci invariably, can't tell slow from fast.
11:53:56 <Cale> instance Functor IO where
11:53:59 <epicbeardman_> cheater99: I don't know if this will help or not, but a good thing to keep in mind is that working with Monads is like using Unix shell pipelines. >>= is like |
11:54:06 <cheater99> ok so you wanted to say: if you have an IO action defined by 'x :: IO t'     right?
11:54:07 <Cale>   ... this part is implementation dependent ...
11:54:17 <Cale> Well...
11:54:22 <hpc> cheater99: a practical example will help; say you want a file separated by lines
11:54:24 <Peaker> Haskell's spirit: "Screw operational semantics, let's have nice semantics, except the MR"
11:54:29 <hpc> you can do this:
11:54:34 <monochrom> well it was designed by committee. can't let one political stance win all
11:54:35 <Cale> That doesn't quite completely define any particular IO action
11:54:39 <Cale> I just mean any IO action
11:54:45 <hpc> [lines] <- fmap lines (readFile "file.txt")
11:54:46 <Cale> I was just giving it a name :)
11:55:02 <cheater99> hpc: that's what i was doing and why people told me to use fmap
11:55:02 <Peaker> epicbeardman_, Shell pipelines are more like (.) than (>>=)
11:55:16 <Cale> itym:  xs <- fmap lines (readFile "file.txt")
11:55:26 <monochrom> shell pipelines have side effects and are unlike (.)
11:55:29 <hpc> er, right
11:55:30 <ClaudiusMaximus> what would you use to solve simultaneous equations of the form: x_a = x_b * (x_c + x_d + ...)  with x_i > 0 for all i
11:55:41 <Cale> [lines] will only match a one-line file, and will end up shadowing the definition of the lines function, confusingly :)
11:55:49 <hpc> yeah, my bad
11:55:51 <Peaker> monochrom, Control.Category.. :)
11:55:54 <ClaudiusMaximus> i have 40 equations in 27 variables so i don't want to do it by hand
11:55:59 <cheater99> Cale: ha!
11:56:34 <monochrom> merciful god save us from category hell
11:56:40 <Peaker> They're unlike (>>=) because stdin doesn't change which command runs..
11:57:02 <monochrom> @quote monochrom analog
11:57:03 <lambdabot> No quotes match. You speak an infinite deal of nothing
11:57:05 <Peaker> the "effects" are pre-chosen more like a Kleisli IO composition
11:57:31 <monochrom> @quote monochrom analog.*
11:57:32 <lambdabot> No quotes match. Maybe you made a typo?
11:57:41 <Peaker> @quote analogies
11:57:42 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
11:57:42 <Cale> monochrom: Deliver us unto the great topological space in the heavens
11:57:55 <cheater99> ok
11:58:07 <cheater99> so why is IO a 'structure' like a list or a tree?
11:58:29 <cheater99> or is it not, and a structure is just a functor, and IO is a functor, and that's all?
11:58:31 <Cale> cheater99: Well, in this case mainly because it has a sensible fmap :)
11:58:38 <hpc> cheater99: imagine a tuple
11:58:40 <hpc> (a,b)
11:58:45 <cheater99> ok go on
11:58:52 <Cale> I should mention there are a couple laws that any good fmap should satisfy
11:58:59 <Cale> 1) fmap id = id
11:59:00 <hpc> imagine we have a type World, which stores all our information about the world
11:59:09 <Cale> 2) fmap (f . g) = fmap f . fmap g
11:59:15 <hpc> IO a roughly equals (World, a)
11:59:20 <Cale> hpc: nope
11:59:22 <Peaker> No it doesn't
11:59:24 <monochrom> dies irae, dies illa, categoratis et miseriae
11:59:36 <Cale> That's not even the right broken analogy ;)
11:59:43 <hpc> haha
12:00:04 <Cale> Some people like to think of IO a as being like World -> (World, a)
12:00:15 <cheater99> do they?
12:00:16 <cheater99> why?
12:00:26 <Peaker> Without concurrency that model kinda seems to work
12:00:29 <Cale> But that analogy is pretty weak and pretty much breaks down in the face of things like concurrency
12:00:51 <monochrom> Kripke -> (Kripke, a)
12:01:08 <Peaker> Kryptonyte
12:01:31 <Cale> cheater99: Well, intuitively, an action of type IO a, when run, has some effect on the world, producing a new world, along with its result
12:01:54 <Peaker> btw: I thought the monomorphism restriction only applied to things like:  (Restriction a => a)  but it seems to make GHC infer less general types for things like:  Restriction a => Int -> a
12:02:02 <cheater99> isn't the result part of that world though?
12:02:16 <Cale> Peaker: It only applies to pattern bindings, and not function bindings
12:02:29 <Cale> Peaker: Add a parameter to your function definition and the problem goes away :)
12:02:41 <Peaker> Cale, It was a function defined in my "where" clause
12:02:43 <Cale> cheater99: Well, that would be one problem with it :)
12:02:49 <cheater99> :)
12:02:50 <Peaker> Cale, f = .... where func x = ...     
12:03:04 <Peaker> It inferred a less general func with MR enabled
12:03:07 <Saizan> it's applying to the f then?
12:03:11 <cheater99> can i apply fmap to *every* functor?
12:03:12 <Cale> Peaker: I mean change the definition of f there such that it has an explicit parameter
12:03:13 <monochrom> the MR is triggered by syntax. you write "f = \x -> blah" and you trigger it. you write "f x = blah" and you dodge it.
12:03:15 <Cale> f x = ...
12:03:25 <Saizan> syntax+type
12:03:40 <Saizan> if you don't have a typeclass context it won't apply
12:03:42 <Cale> cheater99: Yeah, functors are defined by the presence of fmap :)
12:03:44 <monochrom> > let {f = \x -> x} in (f 'x', f ())
12:03:45 <Peaker> Cale, Saizan: No, my problem was with "func" not with "f" -- "func" used general functions but got a specific type inferred unless I gave an explicit type signature for "func" or disabled MR
12:03:45 <lambdabot>   ('x',())
12:03:58 <monochrom> um lambdabot does not restrict me!
12:04:03 <Cale> Peaker: Not if it had an explicit parameter like that
12:04:17 <Peaker> Cale, oh, right, it was a partially applied general function
12:04:19 * hackagebot lrucache 1.1 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.1 (CarlHowells)
12:04:24 * monochrom doesn't give up yet
12:04:32 <monochrom> @let foldcf = \x -> x
12:04:33 <lambdabot>  <local>:2:0:
12:04:34 <lambdabot>      Equations for `foldcf' have different numbers of arguments...
12:04:38 <c_wraith> there.  It supports fmap now.  Not that I know why you'd want to fmap in an LRU cache
12:04:46 <monochrom> @let mrf = \x -> x
12:04:47 <Peaker> It was:  where func = twoArgGeneralFunc x
12:04:48 <lambdabot>  Defined.
12:05:01 <Saizan> @type mrf
12:05:01 <tg_zzz> lol
12:05:01 <monochrom> > (mrf 'x', mrf True)
12:05:02 <lambdabot> forall t. t -> t
12:05:03 <lambdabot>   ('x',True)
12:05:06 <tg_zzz> nice timing for him
12:05:19 * hackagebot hjpath 3.0.1 - XPath-like syntax for querying JSON  http://hackage.haskell.org/package/hjpath-3.0.1 (JaroslavGridin)
12:05:21 <Peaker> So the "mono" in monomorphism applies to having no syntactically specified arguments
12:05:22 <Peaker> yuck!
12:05:37 <monochrom> no, the "mono" is still about type
12:05:51 <Saizan> @let mrf' = \x -> const x (show x)
12:05:52 <lambdabot>  Defined.
12:05:57 <Saizan> @type mrf'
12:05:58 <lambdabot> forall a. (Show a) => a -> a
12:05:59 <monochrom> something else in the report says about syntactically specified arguments.
12:06:06 <Peaker> monochrom, Well, I had a general:  twoArg :: Restriction a => Blah -> a -> Bleh    and I used:   where func = twoArg blah
12:06:09 <Saizan> i guess we have NoMR here
12:06:14 <Peaker> monochrom, And "func" got a less general type inferred
12:06:20 <tg_zzz> so, anyone hazard a guess if re-writing lambdabot (or, more generally, a new ircbot project) using Intel concurrent collections?
12:06:29 <Saizan> Peaker: you managed to not learn that until now?:)
12:06:42 <Peaker> Saizan, Heh, I only had a vague idea of when the MR kicks in :)
12:06:51 <technogeeky> is {possible, useful}
12:06:52 <technogeeky> sorry
12:06:54 <cheater99> Cale: oh
12:06:58 <cheater99> Cale: ok cool
12:07:01 <monochrom> sigh. the name "monomorphism restriction" does not give full information about when it's triggered.
12:07:25 <monochrom> the word "monomorphism" refers to type only
12:07:27 <Peaker> Saizan, I specify all my top-level signatures, and have usually had it happen for values of a type like  (R a => a)  I either never had or never noticed it applying to a polymorphic function that happens to be bound to a "mono variable"
12:07:40 <Saizan> ah, yeah, "mono" doesn't refer to the syntactical condition.
12:07:44 <Saizan> only to the effect
12:07:52 <Saizan> well, "monomorphism"
12:08:04 <Peaker> Well, it's triggered by the syntactic lack of arguments, even if the type specified it has arguments
12:08:22 <Saizan> yeah, but monomorphism simply means "not polymorphic"
12:08:27 <monochrom> the meaningful_identifier restriction
12:08:33 <Saizan> *monomorphic
12:09:50 <monochrom> also "no arguments" seems to be "zero" or "zilch" or "nil" rather than "mono"
12:09:51 <Peaker> The distinction between "pattern bindings" (x = ...) and "function bindings" (x y = ...) is surprising
12:10:12 <Peaker> monochrom, "One thing before = sign" :)
12:10:19 <monochrom> oh god
12:10:38 <soupdragon> (f x y,z) = (z,x:map (y+) z)
12:10:52 <monochrom> anyway, haskell98 report.
12:11:12 <monochrom> you will never regret having read it.
12:11:36 <Peaker> I've never read any language's report, it's probably boring :)
12:11:55 <monochrom> there is only so much you could gather from suggestive names like "type class" and "error".
12:12:07 <Saizan> read the paragraph on the MR, it's very good
12:12:37 <monochrom> Yes I can almost guarantee you the haskell98 report is also boring.
12:12:52 <Peaker> monochrom, And so much more you can gather from trial&error, ghc error messages, #haskell and some blogs :)
12:13:20 <Saizan> don't guess name meanings from that though, please :)
12:13:39 <monochrom> #haskell is good, it's peer-reviewed, you can't go wrong.
12:13:45 <Saizan> otherwise we'll have another blog post about how mappend is a really complicate way to append an element to a list
12:14:07 <Saizan> *complicated
12:14:23 <monochrom> trial&error is error-prone because you read the wrong message from the trial&error. this is how many superstitutions begin.
12:14:47 <hpc> it even has "error" right in the title
12:14:50 <hpc> ;)
12:14:59 <monochrom> we don't need more superstitions in programming. we have enough.
12:15:23 <hpc> we won't have enough until they combine into the ultimate cargo cult and destroy Java
12:15:47 <Peaker> monochrom, it may be inefficient to learn my interpretation of "monomorphism" was wrong by discussing here, but it's much less boring than reading the report :)
12:15:55 <monochrom> don't hope for Java destroyed. something worse will take its place.
12:16:07 <Peaker> Java made lambdas popular by not having them
12:16:21 <Peaker> Probably C#, which is probably better
12:16:43 <Peaker> Because it is slightly more inspired/affected by MSR :)
12:16:58 <monochrom> #haskell is good, like I said.
12:17:18 <monochrom> To make the best out of #haskell, just believe me all the time.
12:18:47 <cheater99> thanks a lot guys
12:18:51 <cheater99> all that was very helpful
12:19:13 <tolkad> How do I make it so my data type can be printed with putStr?
12:19:15 <catenate> The crowd of Java users who become enlightened about functional programming are likely to go with Clojure since it's a language in a jar.
12:19:20 <tolkad> like putStr 5 works
12:19:28 <hpc> :t putStr
12:19:29 <lambdabot> String -> IO ()
12:19:36 <Wolfspaw> Good Afternoon guys, how can i load a file which is classpath is passed as a parameter in the main function? like that: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26846#a26846 
12:19:48 <hpc> putStr 5 doesn't typecheck
12:19:54 <tolkad> > putStr 5
12:19:55 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
12:19:55 <lambdabot>    arising from the literal `...
12:19:57 <tolkad> oh
12:19:59 <tolkad> huh
12:19:59 <hpc> print 5 typechecks
12:20:01 <hpc> :t print
12:20:02 <lambdabot> forall a. (Show a) => a -> IO ()
12:20:06 <tolkad> oh, I mwan print
12:20:07 <hpc> you make it an instance of Show
12:20:08 <tolkad> meant*
12:20:21 <hpc> which you can do with "deriving"
12:20:45 <tolkad> hmm, now how do I tell it how to convert it to a string
12:20:47 <Wolfspaw> damn, i got confused. I didnt mean classpath, i meaned >filepath<   >.<
12:20:52 <EvanR> they should add more classes to deriving
12:20:58 <tolkad> instead of it doing it automatically in a way I don't like
12:21:05 <EvanR> like, FirstPersonShooter and WebBrowser class
12:21:26 <hpc> how about HaltingOracle?
12:21:31 <tolkad> like, I have data Test = Test Float deriving Show
12:21:49 <hpc> print (Test 5) will output "Test 5.0"
12:21:50 <tolkad> "main = print ((Test 1.5))" prints out "Test 1.5"
12:21:54 <hpc> yeah
12:22:00 <tolkad> yes, I want to make it print something else when I do that
12:22:02 <hpc> or you can do:
12:22:04 <tolkad> How do I do that?
12:22:05 <monochrom> data Gun = Gun deriving (Eq,Show,FirstPersonShooter,WebBrowser,BatteryBunny,HaltingOracle,18,F,LA)
12:22:17 <hpc> instance Show Test where show a = "something"
12:22:24 <hpc> for some definition of show
12:22:48 <tolkad> select * from test where a = "something"
12:23:20 <tolkad> ooh, thanks
12:23:53 <monochrom> instance Show Test where show (Test x) = "my age is " ++ x
12:23:55 <Saizan> Wolfspaw: main doesn't take the CLI parameters as arguments, you need to use System.Environment.getArgs
12:24:54 <monochrom> or "I wrote " ++ x ++ " monad tutorials"
12:25:07 <hpc> haha
12:25:26 <Wolfspaw> Saizan hm, ok thanks! In my friend PC it worked but he is using Hugs , so i was wondering why it wasnt working here (in ghc)
12:25:56 <tolkad> idk if haskell is as good as Java... I would miss writing Javadocs...
12:25:59 <EvanR> monochrom: when can we expect ghc to have this
12:26:09 <hpc> haddock > javadoc
12:26:52 <Saizan> Wolfspaw: btw, what do you specifically by load? just read the file into memory as a String right? that's what readFile does
12:27:32 <tolkad> ok... why doesn't this work? instance Show Test where show (Test (a :: Float)) = show a
12:27:34 <Wolfspaw> Saizan yes, that is my intention. I maded a little snippet of the code to summarize my doubt. 
12:28:04 <hpc> no need for the ":: Float"
12:28:23 <hpc> since that's already in the definition of the constructor
12:28:27 <Saizan> Wolfspaw: k, the initial mention of "classpath" made me think you wanted to interpret it as haskell code, nvm :)
12:30:08 <Saizan> Cale: it's fun how your segment is the one called select in prolog's libs
12:30:56 <cheater99> ok. how do i split by an arbitrary char again?
12:31:27 <Saizan> cheater99: see the split package on hackage
12:31:31 <hpc> :t splitBy
12:31:32 <lambdabot> Not in scope: `splitBy'
12:31:40 <Cale> cabal-install split, import Data.List.Split, and use...
12:31:41 <tolkad> > :t Float
12:31:42 <lambdabot>   <no location info>: parse error on input `:'
12:31:51 <cheater99> Saizan: will do, thanks
12:31:52 <tolkad> :t Float
12:31:53 <lambdabot> Not in scope: data constructor `Float'
12:32:01 <Cale> I think it was splitOn
12:32:02 <hpc> @hoogle a -> [a] -> ([a], [a])
12:32:03 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
12:32:03 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
12:32:03 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
12:32:04 <Cale> But I forget
12:32:05 <deech> Hi all, I am reading "Fun With Type Functions" am unclear about when to use "data" and when to use "type". In Haskell "type" is an alias while "data" creates a distinct type, how does this play into associated types?
12:32:26 <djahandarie> @hoogle [a] -> [a] -> ([a], [a])
12:32:27 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
12:32:27 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
12:32:27 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
12:32:42 <Saizan> deech: well, it's the same there
12:32:46 <Cale> deech: data families generate honestly new datatypes for each instance, which are not identified with any existing type
12:32:46 <djahandarie> @hoogle [a] -> [a] -> [[a]]
12:32:47 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
12:32:47 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
12:32:47 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
12:33:01 <tolkad> ok... well what if I have "data Test = Test Num"
12:33:10 <tolkad> and then I want "instance Show Test where show (Test (a :: Float)) = show a"
12:33:13 <Cale> deech: type families are more like one would expect type functions to be, in that they send one type to another, existing type.
12:33:24 <djahandarie> splitOn :: Eq a => [a] -> [a] -> [[a]]
12:33:29 <Saizan> tolkad: Num is not a type, so you can't use it like that
12:33:44 <djahandarie> I wish hoogle would just index all of hackage
12:33:58 <hpc> how much does it index?
12:34:10 <tolkad> Saizan: what is it then?
12:34:15 <Cale> hpc: A little more than what comes with GHC
12:34:17 <deech> In the paper the paper they seem to use "data" to identify to make the types the same. 
12:34:22 <Cale> hpc: Bt not by much
12:34:26 <Cale> But*
12:34:28 <hpc> that's not a lot at all
12:34:35 <deech> This is done on page 6.
12:34:41 <djahandarie> Or a plugin for hayoo
12:34:45 <Saizan> tolkad: it's a type class
12:34:52 <deech> I would have expected the other way round.
12:34:54 <luite> does anyone know a good simplex algorithm implementation in haskell, that works with types other than Double (Rational in particular)?
12:35:15 <Saizan> tolkad: morally, it's a collection of types that provide some specified interface
12:35:56 <tolkad> Saizan: oh, so it's an interface
12:36:21 <tolkad> Saizan: why can't I treat it like a type... Interfaces can be treated just like types
12:36:50 <Saizan> tolkad: it's not the same as a java(or some other OO lang) interface
12:37:11 <hpc> a typeclass is a group of types with similar properties
12:37:34 <Saizan> tolkad: IOW we don't have subtyping, so that wouldn't make sense
12:37:57 <cheater99> ok so a type class is basically like an interface?
12:38:05 <hpc> sort of
12:38:05 <cheater99> can i think that way?
12:38:06 * Cale can't help but wince at the non-technical use of the word 'group' ;)
12:38:12 <tolkad> so, a type implements an interface
12:38:42 <Saizan> here we say that a type is an instance of a type class
12:38:44 <hpc> it's similar to an interface, an abstract class, and a generic
12:38:59 <cheater99> ok
12:39:05 <Cale> Remember kids, learning mathematics will fuck you up. ;)
12:39:10 <cheater99> why?
12:39:15 <cheater99> helps me immensely every day.
12:39:30 <hpc> ubermaths
12:39:37 <tolkad> anyway, that's obviously not the problem because the compiler doesn't mind that line
12:39:41 <tolkad> data Test = Test Num
12:39:44 <tolkad> instance Show Test where show (Test (a :: Float)) = show a
12:39:49 <tolkad> doesn't work on the SECOND line
12:40:00 <ski> `Num' is not a type
12:40:01 <tolkad> "Illegal signature in pattern: Float"
12:40:12 <tolkad> ski: yeah, people told me it's an interface
12:40:15 <deech> cheater99: so long as the math is still about numbers it's useful in everyday matters.
12:40:28 * cheater99 incinerates deech
12:40:31 <ski> maybe you meant `data Test = forall a. Num a => MkTest a' ?
12:40:33 <Cale> cheater99: I'm just referring to how I can't help but think that someone means the mathematical sort of group whenever they say "group".
12:40:55 <cheater99> i think of group sex
12:41:05 <cheater99> made algebra lectures more fun
12:41:08 <Saizan> ski: i doubt that :)
12:41:12 <Cale> continuous group action
12:41:12 <deech> cheater99: aw come on, when's the last time you used rings and groups to buy cereal?
12:41:16 <ski> then you can write `instance Show Test where show (MkTest x) = show x' (because any type `a' in `Num' must be in `Show')
12:41:32 <ski> Saizan : you doubt what ?
12:41:33 * cheater99 puts deech in Ker (Life)
12:42:01 <tolkad> uh... this doesn't work: data Test = Test (a :: Num => a)
12:42:11 <ski> <ski> maybe you meant `data Test = forall a. Num a => MkTest a' ?
12:42:13 <ski> tolkad : ^
12:42:26 <Cale> deech: Nutritional contents form a vector space at least.
12:42:39 <monochrom> data Test a = Test a. No point restricting to Num here.
12:43:04 <monochrom> but the right answer is "what do you really want"
12:43:12 * ski thought the point was to make a non-parametric type which contained something in `Num' inside
12:43:17 <monochrom> but I'm too lazy to stand behind the right answer
12:43:28 <deech> Cale: But in the end still about numbers  - number of calories, grams of sodium etc.
12:44:36 <Cale> deech: Rings are about "numbers"
12:45:06 <deech> That is true.
12:45:14 <tolkad> well, I know I want data Test = Test Num
12:45:22 <tolkad> Num being an interface
12:45:23 <Saizan> why do you want that?
12:45:40 <Saizan> how are you going to use Test?
12:45:42 <FunctorSalad> *notes that you can form a free vector space from anything ;)*
12:45:43 <deech> In fact, I'll take back a little of what I said, linear algebra is incredibly useful in daily life.
12:45:49 <tolkad> So you can construct a Test with any parameter which is of a type implementing the "Num" interface
12:45:52 <companion_cube> Cale: rings are about anything that has an inversible operator and a neutral element, isn't it ?
12:46:01 <companion_cube> aren't they*
12:46:04 <FunctorSalad> that's groups
12:46:05 <EvanR> has anyone stumbled on this c2.com wiki. it seems like a business oriented profundity of psuedo computer science, incomprehensible to me. am i missing some valuable insight here?
12:46:06 <Cale> companion_cube: Maybe you're thinking of groups
12:46:12 <soupdragon> ring is a type T with (+),(*) :: T -> T -> T
12:46:14 <monochrom> ok ski wins
12:46:16 <soupdragon> and it has to have 0,1 :: T
12:46:21 <companion_cube> wow, my mistake
12:46:22 <Saizan> tolkad: "data Test a = Test a" would work for that too
12:46:27 <dankna> c2.com is the original wiki
12:46:29 <companion_cube> but rings are groups with a second operator
12:46:35 <soupdragon> and satisfy a bunch of axioms like 0+x = x, x+y=y+x, a*(b+c)=a*b+a*c
12:46:35 <companion_cube> and they can apply to other things than numbers
12:46:36 <EvanR> it seems to have nothing on haskell
12:46:39 <dankna> it doesn't have anything hugely irreplaceable
12:46:45 <dankna> if you don't like it, by all means ignore it
12:46:48 <soupdragon> (T,+) is a group
12:46:57 <soupdragon> (T,*) is a monoid
12:47:01 <Cale> Yeah, a ring is an Abelian group under (+), and a monoid under (*), and (*) distributes over (+)
12:47:06 <FunctorSalad> (you need evidence though to show that your free generators don't combine to zero in reality... at least if the generators are foods)
12:47:19 <FunctorSalad> *random* :)
12:47:32 <Cale> Or, it's an Abelian group with a choice of monoid action on it.
12:47:35 <FunctorSalad> *combine to zero nontrivially
12:47:40 <Saizan> tolkad: if you want the actual type to be forgotten you can use ski's suggestion, though you won't be able to recover that information later.
12:47:44 <tolkad> Saizan: but then it could be constructed with non-numbers
12:47:50 <Saizan> tolkad: there's no "instanceof"
12:47:56 <tolkad> Saizan: what?!?
12:48:06 <Cale> FunctorSalad: I suppose it's also just the positive cone of a particular vector space too.
12:48:06 <tolkad> Saizan: I thought that's what pattern matching was
12:48:17 <FunctorSalad> :)
12:48:25 <Saizan> tolkad: pattern matching is for discriminating on constructors, not types
12:49:26 <tolkad> Saizan: but... each constructor is a type... isn't it?
12:49:32 <Saizan> tolkad: no
12:49:44 <hpc> instanceof is a poor substitute for typeclasses
12:49:47 <FunctorSalad> wasn't the military highly active in linear optimization around the start of the cold war? need any more proof of applicability? ;))
12:50:11 <hpc> constructors make values
12:50:16 <hpc> Nothing :: Maybe a
12:50:22 <Saizan> tolkad: e.g. "data Bool = True | False" True and False are two constructors of a single type: Bool
12:50:27 <hpc> Just :: a -> Maybe a
12:50:28 <FunctorSalad> (if essentialness of linear algebra was the topic)
12:50:43 <hpc> or rather, Just a :: Maybe a
12:50:59 <Cale> FunctorSalad: Google
12:51:21 <FunctorSalad> Cale: as an application? (pagerank)
12:51:28 <Cale> The main thing that Google does isn't really search, it's linear algebra ;)
12:51:39 <Cale> yeah
12:51:47 <jlouis> Now Linalg is only part of the algorithm
12:51:50 <FunctorSalad> sure it's just the largest eigenvector of the links-to matrix ;)
12:52:11 <Saizan> tolkad: you can have a datatype like "data StringOrBool = HeyAString String | OhABool Bool", then when you pattern match on the constructors you can access their fields and you'll know which type they are, but you're still not pattern matching on the type there
12:52:14 <FunctorSalad> well, finding eigenvectors is a nonlinear thing, yes
12:52:39 <EvanR> dankna: are you saying its old?
12:52:39 <FunctorSalad> in some vague sense... but it's not doable by rational operations, at least
12:52:45 <tolkad> well... what about type casting?
12:52:50 <Cale> I would consider the finding of eigenvectors in general to be "linear algebra", even so.
12:52:57 <tolkad> doesn't haskell do that like :: TypeNameHere
12:53:00 <FunctorSalad> Cale: for understanding the problem, definitely
12:53:26 <deech> Cale: You're at a McDonald's drive-thru. You have a bunch of kids in the car, some want sandwiches, some just fries, some want both and a soda. What is the optimal order, taking into account value meals, etc? Linear algebra, helping everyone from soccer moms to the military.
12:53:26 <dankna> EvanR: yes, I am
12:53:27 <Cale> They do some pretty clever things to extract the approximation to that eigenvector :)
12:53:38 <EvanR> that would explain things
12:53:47 <Cale> deech: :)
12:54:11 <Cale> But I think that searching with google is a pretty every-day thing nonetheless :)
12:54:14 <Tomsik> what
12:54:19 <Tomsik> eigenvectors not linear?
12:54:22 <deech> In fact that would make a great android app.
12:54:40 <Tomsik> det(A-lambda*I) =0 doesn't give so damn nonlinear equations
12:54:57 <Tomsik> and even if so Av = lambda*v is not cool, but linear
12:54:59 <dpratt71> hi Cale
12:55:03 <FunctorSalad> Tomsik: pardon? it's a degree-n polynomial
12:55:04 <Cale> Tomsik: it's nonlinear as a function of lambda
12:55:10 <FunctorSalad> (and not how you do it in practice AFAIK)
12:55:11 <wli> AIUI some pagerank-like things use SVD's instead of eigenvalues/vectors.
12:55:19 <Saizan> tolkad: that's not casting, as in it doesn't make an expression of some fixed type become of another, it's a type annotation that at best can specialize a polymorphic type
12:55:26 <tolkad> maybe I'll read a bit more instead of jumping to OO inspired conclusions because I'm getting very confused
12:55:31 <FunctorSalad> one common approach is to multiply (and re-normalize) the matrix with itself repeatedly
12:55:39 <FunctorSalad> which emphasizes the largest EV more and more
12:55:50 <Cale> In practice, you look for (an approximation to) an eigenvector first
12:55:50 <Saizan> tolkad: that's for the best, OO inspired conclusions will almost always be wrong :)
12:56:03 <Tomsik> Oh well, practice, right. ;p
12:56:04 <Tomsik> :P
12:56:05 <Cale> and if you want another, you take a projection
12:56:09 <wli> I believe they do QR decompositions and then form RQ or something on that order, with numerous refinements (e.g. implicit shifts etc.).
12:56:11 <EvanR> i have been studying OO, trying to make sense of it
12:56:16 <FunctorSalad> unless you happen to start in an unfortunate eigenspace, from which floating point rounding errors save us, lol
12:56:19 <EvanR> not going well
12:56:25 <FunctorSalad> (sinve they have prob 0... I guess)
12:56:27 <wli> It's either RQ or RQ^*
12:56:40 <Cale> If the two largest eigenvalues are rather close, it can create problems.
12:57:02 <Cale> and I seem to vaguely recall that there's a way to cope with that
12:57:21 <FunctorSalad> Tomsik: not just "in practice"... it's absolutely without any doubt a degree-n polynomial in the unknown
12:57:23 <FunctorSalad> ;)
12:57:53 <Tomsik> Well, it has solutions
12:58:04 <Tomsik> doesn't matter if analitic or not :p
12:58:11 <FunctorSalad> I was jut going to mention, you need the "fundamental theorem of algebra" for that
12:58:12 <aristid> hmm, the recent "haskell hiring" threads on haskell-cafe make it seem like haskell programmers are an underutilised resource (i.e., there are more haskell programmers than haskell employers)
12:58:17 <FunctorSalad> *just
12:58:21 <wli> Dead serious guys. A_k = Q_k R_k is the QR decomposition of the k-th step. Then A_{k+1} = R_k Q_k
12:58:43 <Tomsik> aristid: I thought they only hire C++ and Java programmers
12:58:48 <FunctorSalad> fairly safe to say that that's outside the linear world ;)
12:58:54 <Tomsik> the industry I mean
12:58:55 <wli> The eigenvalue iteration is that dumb.
12:58:55 <catenate> EvanR: take a look at http://c2.com/cgi/wiki?ExtremeProgrammingRoadmap for a list of some of the best practical ideas in how to improve how (small) businesses have people program to come from the agile community
12:59:05 <Cale> wli: hmm...
12:59:18 <Tomsik> FunctorSalad: Darn, again I turn out to be stupid :p
12:59:29 <FunctorSalad> wli: the lecturer mentioned the QR method in the end too, iirc he liked it too ;)
12:59:31 <Cale> wli: It seems like you wouldn't even be able to comtemplate matrix-matrix multiplication at that scale
12:59:49 <ski> tolkad : using `foo :: Blah' as an expression only *constrains* `foo' to have type `Blah' (possibly disambiguating if there was potentially many choices); if `foo' can't have had type `Blah' to begin with, that is a type error
12:59:50 <EvanR> catenate: holy crap what is this 
12:59:51 <aristid> Tomsik: tell dons and dcoutts that they doesn't exist ;)
13:00:04 <FunctorSalad> something about isometries (Q) producing little floating-point errors, isn't it
13:00:19 <catenate> Under "Specific ExtremeProgramming practices"
13:00:26 <wli> Well, it's only conceptually that dumb. Various sophisticated things I don't actually understand are done to avoid ever having to form QR decompositions and to do implicit shifts of eigenvalues.
13:00:26 <EvanR> i dont think im an extreme programmer
13:00:47 <ski> tolkad : e.g. if you define `foo x = (x,x)', then `foo' is inferred as having type `a -> (a,a)' (i.e. having type `Bool -> (Bool,Bool)' as well as `String -> (String,String)' as well as ...)
13:00:48 <EvanR> is this OOP 2.0?
13:01:05 <FunctorSalad> compared to highly sensitive-to-error linear maps like shearings etc
13:01:36 <ski> tolkad : but if you say `foo x = (x :: Bool , x)', then the `:: Bool' constrains the `x' to definitely have type `Bool', so now `foo' is inferred to have type `Bool -> (Bool,Bool)' (only)
13:01:41 <FunctorSalad> wli: Q is calculated as a sequence of reflections IIRC
13:01:44 <catenate> I recently visited a shop that actually does most of these things.  It can really work in practice.  They use Ruby and Rails mostly to do web dev and enterprise software 
13:01:54 <FunctorSalad> I guess you don't need to materialize them
13:02:09 * wli doesn't have access to his copy of Golub & Van Loan.
13:02:18 <EvanR> ruby does not help you write type safe code
13:02:24 <wli> Yeah, if you don't need the eigenvectors you just throw it all away.
13:02:46 <tolkad> ooh, this worked:
13:02:47 <tolkad> lambda x 1 = x
13:02:47 <tolkad> lambda x a = x^(lambda x (a - 1))
13:02:50 <tolkad> that's cool
13:04:19 <FunctorSalad> wli: even if you need the EVs, I guess you just do stream fusion rather than actually calculating all the (conceptual) matrices :)
13:04:26 <Cale> A lot of the things that the Agile and XP people say are just good common sense.
13:05:03 <EvanR> it frightens me
13:05:23 <Cale> But for some reason, the people I've seen who were most excited about Agile and XP often couldn't seem to program their way out of a paper bag.
13:05:30 <EvanR> i think good ideas should be able to be explained simply without using buzz words
13:05:42 <cheater99> ok, how do i use modules? I've found something interesting in the "List" module but i'm not sure how to access the function. i tried doing :l List in ghci, but it errored out.
13:05:43 <catenate> EvanR: it's not all about type safe code, in practice there are business processes that make a much bigger difference to how well teams deliver code in any language
13:06:07 <FunctorSalad> cheater99: :m Data.List
13:06:24 <FunctorSalad> cheater99: (the toplevel things are legacy AFAIK)
13:06:31 <Cale> :m + Data.List
13:06:34 <FunctorSalad> note sure if it's identical to Data.List
13:06:36 <Cale> The + is useful :)
13:06:41 <FunctorSalad> ah, yes
13:06:54 <cheater99> toplevel things?
13:06:56 <FunctorSalad> otherwise you'll forget the present modules, except the prelude
13:07:09 <FunctorSalad> List vs Data.List and so on
13:07:10 <EvanR> catenate: can you explain extreme programming easily, or do you have to sell a book to do it?
13:07:14 <cheater99> ah ok
13:07:20 <cheater99> what's the difference between :l and :m?
13:07:24 <Cale> It means, add Data.List to the current set of modules, rather than replace the current set of modules with Data.List
13:07:27 <Cale> oh
13:07:36 <Cale> :l loads a local .hs file
13:07:42 <FunctorSalad> I can't see what letter that is *g*
13:07:45 <FunctorSalad> ah, :load
13:08:06 <FunctorSalad> cheater99: that's just ghci. in a source file you do 'import Data.List'
13:08:17 <catenate> EvanR: I absolutely agree, and that's the biggest problem I see with the Haskell community.  I adore the language, but how far do you think functions would have got with the business crowd if its adherents in the 60s and 70s didn't stop raving about domains and ranges long enough to say "um, a function just groups some code together so you can forget what it does inside"?
13:08:18 <cheater99> and what's the difference in ghci?
13:08:40 <cheater99> i thought the local .hs files are modules too.
13:08:46 <FunctorSalad> cheater99: you can't enter declarations in ghci
13:08:51 <EvanR> haha
13:08:59 <Cale> catenate: Sorry, what problem with the Haskell community?
13:09:02 <FunctorSalad> (declarations are the things that can stand on the toplevel in a source file)
13:09:16 <FunctorSalad> (like a definition "foo = bar")
13:09:24 <FunctorSalad> and type definitions
13:09:44 <cheater99> FunctorSalad: i don't think you are answering my question.
13:09:51 <Cale> catenate: Personally, I want to keep Haskell straddling the line between things practical for real-world use and things used for research as long as possible :)
13:10:02 <Cale> catenate: That's the ideal for me :)
13:10:28 <Cale> Don't get *too* many users, because lots of users will complain when you change anything then.
13:10:29 <FunctorSalad> cheater99: "import" is a declaration, so you can't use it in ghci, and there's the special ghci command :m isntead
13:10:39 <cheater99> ok
13:10:45 <cheater99> can i import local .hs files too?
13:10:48 <Cale> and just make the language as awesome as possible, a secret weapon that we can keep to ourselves :)
13:11:08 <wli> I'm trying to re-figure-out how the QR algorithm actually works vs. the conceptual QR decomp -> form RQ notion.
13:11:25 <Cale> Obviously this strategy is bound to break down at some point, but so long as it works, it seems to produce good results.
13:11:57 <Cale> At least, that's what the selfish side of me wants :)
13:12:16 <FunctorSalad> wli: one method I know to get Q is householder reflections
13:12:27 <catenate> Cale: you'll never be able to sell haskell to businesses with all the category theory terms, you have to say simple things about how the language reduces maintenance costs and stays up, which reduces fines.  For example, xmonad doesn't go down.  That's a big win, because they can compare that to flying busloads of people out to fix broken deployed software
13:12:27 <tolkad> average a = sum a `div` length a
13:12:27 <tolkad> main = print (average [1.0..10.0])
13:12:29 <tolkad> doesn't work
13:12:34 <tolkad> but this does:
13:12:38 <tolkad> average a = sum a `div` length a
13:12:38 <tolkad> main = print (average [1..10])
13:12:44 <Cale> There's something to be said for the betterment of mankind through the use of more correct and stable software, and for that purpose, sure, I'd like lots of people using the language.
13:12:50 <FunctorSalad> I guess you never need to remember all the reflections, you just apply them to whatever you want to multiply Q with
13:12:51 <tolkad> I think it's a bug
13:13:29 <Cale> catenate: But when it comes down to having a really cool language that I can use myself, and a not-as-cool language that lots of businesses use, screw the businesses, I'll keep the cool language for myself :)
13:13:39 <tolkad> "No instance for (Fractional Int)"
13:14:21 <FunctorSalad> taking averages needs division
13:14:36 <tolkad> yeah...
13:14:36 <Cale> If the businesses don't like using it because it's founded on solid mathematical principles, well, great, they don't have to use it :)
13:14:43 <FunctorSalad> or do you mean the bug is that it ought to default to Double
13:14:47 <tolkad> this doesn't work either:
13:14:48 <tolkad> average a = sum a / length a
13:14:48 <tolkad> main = print (average [1.0..10.0])
13:14:58 <FunctorSalad> > average [1.0..10]
13:14:59 <lambdabot>   Not in scope: `average'
13:15:01 <Cale> I personally really like the fact that category theory is being used to shape our ideas about library design.
13:15:01 <wli> How to accumulate the reflections isn't as hard as figuring out how they avoid actually forming a full QR decomposition anywhere.
13:15:07 <Saizan> tolkad: average a = sum a / fromIntegral (length a)
13:15:09 <Cale> (and lots of other algebra, really)
13:15:20 <catenate> Cale: I'd rather get a job programming Haskell, and use it all day.  You have to convince business users that the language is not some ivory-tower dorkfest, and the difficulty explaining monads, which is key to real-world use, doesn't help, because the programmers business types talk to know just enough to think it's a hack that doesn't handle the real world well.
13:16:02 <tolkad> ah, so Integral is haskell's version of size_t
13:16:04 <Cale> It's funny, somehow even though I have a job programming in Haskell, I still don't *really* consider myself a programmer :)
13:16:08 <FunctorSalad> if it's a non-technical businessperson you obviously won't tell them about monads ;)
13:16:14 <Cale> I'm a mathematician who writes programs ;)
13:16:25 * jmcarthur wants a haskell job
13:16:44 <EvanR> tolkad: how do you mean?
13:16:55 <Peaker> @src Integral
13:16:56 <lambdabot> class  (Real a, Enum a) => Integral a  where
13:16:56 <lambdabot>     quot, rem, div, mod :: a -> a -> a
13:16:56 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
13:16:56 <lambdabot>     toInteger           :: a -> Integer
13:16:59 <tolkad> EvanR: I mean that it's exactly like size_t
13:17:03 <EvanR> no
13:17:06 <Peaker> tolkad, that doesn't sound "exactly like size_t"
13:17:16 <Peaker> tolkad, Anything that implements those operations sensibly is an Integral
13:17:17 <Saizan> tolkad: err, no, Integral is a type class, though length :: [a] -> Int and Int is an instance of Integral
13:17:44 <deech> catenate: convince your employer that Haskell can do CRUD just as well as anyone. Monads are besides the point. 
13:17:56 <Cale> catenate: The companies who adopt better ways of structuring code will just be at a slight disadvantage to those who do, on average. It doesn't really require explanation, evolutionary forces are at work.
13:17:57 <FunctorSalad> rocket scientists aren't expected to explain rocket-scientific details to non-technical management either, are they ;)
13:18:06 <FunctorSalad> the latter just have to take their word at some point
13:18:11 <Cale> er
13:18:15 <Cale> Got that backward :)
13:18:26 <Cale> The companies who *fail* to adopt better ways of structuring code will just be at a slight disadvantage to those who do, on average. It doesn't really require explanation, evolutionary forces are at work.
13:18:44 <Cale> there ;)
13:18:53 <catenate> Cale: I agree with you, which is why agile companies are slowly winning over waterfall companies
13:19:02 <Cale> Of course, the change might be slower than one might want.
13:19:14 <FunctorSalad> Cale: maybe no much due to the heavy network and legacy effects in programming
13:19:17 <Cale> But that's fine. I can write my programs in Haskell, and other companies can do what they want.
13:19:17 <FunctorSalad> *not much
13:19:19 <tolkad> Cale: or the ones who fail will get bailed out by the government
13:19:34 <FunctorSalad> (not much evolution based on a-priori merits)
13:19:38 <Saizan> tsk, as if we were in a really free market and if selection would apply simply on efficiency in one, but that's for -blah
13:20:04 <Cale> Saizan: It doesn't even have to apply really strongly, it just needs to be a tiny advantage.
13:20:19 <Cale> (in the long run)
13:20:32 <FunctorSalad> if it's too tiny it can get swamped by coincidences at the beginning :)
13:20:35 <Cale> Of course, we all know this produces silly results
13:20:43 <Cale> But that's okay, because progress is made anyway
13:20:47 <aristid> FunctorSalad: not if it consistently applies every year
13:20:53 <tolkad> btw does haskell really have a halting oracle function?
13:21:02 <aristid> tolkad: of course.
13:21:02 <FunctorSalad> I don't mean the *really* *really* long run ;)
13:21:08 <deech> In how many software shops does quality and maintainability actually affect their bottom line?
13:21:19 <Cale> It just looks ridiculous, with people in industry getting all excited about objects about 20 years after researchers already mostly decided they weren't such a great idea.
13:21:21 <aristid> FunctorSalad: why? 100 years are a mere blink in the lifetime of even the human species :)
13:21:21 <FunctorSalad> though one could conjure up a system where the constant effect never overpowers the initial coincidence
13:21:43 <edwardk> tolkad: it can detect infinite loops occasionally, when the evaluation of a memothunk depends recursively on itself.
13:21:43 <FunctorSalad> like gravity/escape velocity
13:21:46 <deech> Slick interfaces still rule. 
13:22:08 <FunctorSalad> (but that's a bad example because the initial momentum isn't a quasi-random coincidence)
13:22:58 <aristid> deech: if slick interfaces would rule, a lot of enterprise software would not prevail :)
13:23:11 <Cale> Yeah, on a mathematical timescale, all this stuff is really really new :)
13:23:36 <Cale> Of course it'll take a few hundred years for the right notations for programming to fall out :)
13:23:58 <deech> aristid: It can and does. How many times are we stuck with an enterprise solution that looks good and doesn't work?
13:24:18 <catenate> deech: every time someone has to work on a bugfix instead of a stroy point
13:24:34 <aristid> deech: i often see an enterprise solution that looks ugly AND does not work.
13:25:28 <deech> aristid: true :) 
13:27:28 <FunctorSalad> . o O ( actually the situation where the optimum is never reached by evolution mightn't be so contrived? )
13:27:57 <Peaker> FunctorSalad, tons of examples of it
13:28:02 <aristid> FunctorSalad: of course it is likely that evolution will not reach the global optimum
13:28:23 <aristid> of course there is NO method for reliably reaching the global optimum on limited resources
13:28:36 <FunctorSalad> Peaker: in our time, of course. but even in eternity...
13:29:48 <FunctorSalad> oh and my question doesn't make much sense anyway because 'optimal' depends on the env
13:30:05 <FunctorSalad> (which will go to sh... background radiation too eventually)
13:31:28 <Peaker> FunctorSalad, the env is constantly changing anyway
13:32:46 * hackagebot charset 0.0 - Fast unicode character sets  http://hackage.haskell.org/package/charset-0.0 (EdwardKmett)
13:34:29 <Cale> FunctorSalad: Heh, perhaps UNIX 'select' is the recurrent laryngeal nerve of the software world.
13:35:47 <aristid> Cale: "laryngeal nerve"? what is that?
13:35:55 <aristid> i wish linux had implemented kqueue
13:36:39 <edwardk> now that that is out of the way, i can actually encode the lexer =)
13:38:00 <Cale> aristid: It's a nerve which travels from the brain to the larynx, and loops around the arch of the aorta.
13:38:16 <Cale> aristid: In giraffes, this route is particularly egregious
13:38:32 <edwardk> and is in general much more complicated that it needs to be ;) sounds like select
13:38:38 <Cale> (it really goes all the way down their neck and loops back up around)
13:39:39 <aristid> we CAN get rid of select
13:39:39 <EvanR> someone should submit a bug report at the giraffe genome tracker
13:39:40 <edwardk> no wonder giraffes don't like to talk
13:39:43 <aristid> there are alternatives
13:39:51 <FunctorSalad> Cale: as a suboptimality?
13:40:17 <Cale> It's commonly cited as an example of poor "design" or suboptimality due to the particular course taken by evolution.
13:40:32 <FunctorSalad> btw what about the fact that we still fight with legacy issues from ancient terminals in terminal emulators ;)
13:41:00 * wli fails to find cogent descriptions of how the QR eigenvalue algorithm is done in real life.
13:41:40 <edwardk> wli: isn't it in numerical algorithms?
13:42:53 <wli> edwardk: That title doesn't narrow it down that I know of. I'm also lacking all my books.
13:43:18 <edwardk> wli: that could be a problem. one sec let me dig up a dead tree reference for you
13:44:05 <wli> Well, there should be a description online _somewhere_. I'm trying to figure out how they avoid explicitly forming the whole QR decompositions.
13:44:06 <edwardk> http://books.google.com/books?id=mlOa7wPX6OYC&dq=matrix+computations+golub+van+loan&printsec=frontcover&source=bn&hl=en&ei=3KAvTLrMKcK88gbHisXICw&sa=X&oi=book_result&ct=result&resnum=4&ved=0CCwQ6AEwAw#v=onepage&q&f=false chapter 7.5 of golub and van loan's matrix computations, 1996
13:45:24 <edwardk> that covers the implicit version which is what i presume you're looking for
13:46:46 <wli> edwardk: Sort of. I think implicit's only used to describe shifts. The part where one avoids forming a full QR decomposition is part of everything.
13:55:24 <edwardk> wli: back. hrmm
13:56:11 <edwardk> wli: and by numerical algorithms i meant 'numerical recipes'
13:57:18 <cheater99> ok guys, i have a list of pairs, and i want to sort it by the first element of the tuples. what's the best way to do that?
13:57:31 <cheater99> oh, i think i might have something
13:57:35 <Heffalump> @type sortBy (compare `on` fst)
13:57:36 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
13:57:36 <cheater99> hmm
13:57:48 <Heffalump> though the default sort will sort by the first element anyway, and only use the second element to break ties
13:57:52 <edwardk> @type sortBy (comparing fst)
13:57:53 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
13:58:03 <cheater99> oh
13:58:17 <cheater99> so can i just use 'sort'?
13:58:25 <Heffalump> yes
13:58:28 <edwardk> cheater99: assuming the second element in the tuple is ordered
13:59:20 <edwardk> (i.e. if the second item in the tuple is a function, then this won't work, and you'd need to use one of the sortBy tricks above
14:01:15 <cheater99> i think you meant 'has an order' and not 'is ordered'?
14:01:35 <benmachine> is orderable
14:01:47 <cheater99> this means 'has an order'
14:01:53 <cheater99> ok so..
14:01:55 <benmachine> yes
14:02:07 <cheater99> is there a cool shorthand for x = f x ?
14:02:24 <wli> Givens rotations do it.
14:02:34 <pikhq> @src fix
14:02:34 <lambdabot> fix f = let x = f x in x
14:03:12 <cheater99> i'm not trying to find an x such that x == f x
14:03:29 <cheater99> i'm trying to apply f to x and replace x with the result
14:03:37 <benmachine> replace? :O
14:03:43 <benmachine> sounds like mutation
14:03:44 <pikhq> Waitwaitwait. *Replace*?
14:03:50 <benmachine> we don't do that sort of thing here
14:03:52 <cheater99> i'm not trying to mutate an object
14:03:55 <pikhq> That definitely sounds like that mean nasty mutation.
14:03:57 <cheater99> i'm trying to reassign the name
14:04:00 <pikhq> Yes you are.
14:04:03 <pikhq> That's mutation.
14:04:21 <cheater99> not in most languages i'd used
14:04:36 <monochrom> sorry, you can't reassign a name.
14:04:41 <cheater99> ok
14:04:53 <monochrom> please also complain about laziness
14:04:55 <pikhq> cheater99: Most languages lie about things. It's mutation.
14:05:00 <monochrom> "not in most languages i'd used"
14:05:11 <benmachine> you can shadow a name
14:05:32 <benmachine> and in do notation you can kiiiinda reassign them by shadowing them with themselves
14:05:42 <benmachine> but that's a bit of a hack when you could just come up with a new name
14:05:47 <benmachine> keeping names unique prevents bugs
14:06:25 <dafis> so in a do-block, you could do x <- f x, where the x to the left of <- shadows the one already in scope
14:06:38 <pikhq> Yes.
14:06:41 <dafis> benmachine: Very true
14:06:43 <cheater99> ok
14:06:47 <ski> > [x | x <- [0,1,2] ; x <- [10*x,100*x]]
14:06:48 <lambdabot>   <no location info>: parse error on input `;'
14:06:52 <pikhq> That can produce issues, but yes, that *works*.
14:06:53 <ski> > [x | x <- [0,1,2] , x <- [10*x,100*x]]
14:06:54 <lambdabot>   [0,0,10,100,20,200]
14:07:55 <ski> `let' (and `where', and top-level `module'-)bindings are recursive, `<-'-bindings in `do' and list comprehensions (and pattern guards, i think) are sequential
14:09:08 <ski> > runIdentity $ do x <- return 3; x <- return (x^2); return x
14:09:09 <lambdabot>   9
14:09:51 <benmachine> > do { let x = 4; let y = x; let x = y + 1; x }
14:09:52 <lambdabot>   <no location info>: parse error on input `}'
14:10:15 <benmachine> > do { let { x = 4 }; let { y = x }; let { x = y + 1 }; x }
14:10:17 <lambdabot>   5
14:10:19 <pikhq> Which is of course identical to runIdentity $ return 3 >>= \x -> return (x^2)>>= \x -> return x
14:10:19 <benmachine> whee
14:10:32 <pikhq> benmachine: Fun.
14:10:41 <ski> > let x = 4 in let y = x in let x = y + 1 in x
14:10:42 <lambdabot>   5
14:10:51 <benmachine> can't do x = f x there though without intermediate y
14:11:16 <ski> benmachine : er, hey !? why could you use `x' as the final command, there ?
14:11:22 <ski> @type do { let { x = 4 }; let { y = x }; let { x = y + 1 }; x }
14:11:24 <lambdabot> forall a. (Num a) => a
14:11:36 * ski frowns at GHC
14:11:37 <benmachine> ski: because do-notation only requires a monad if you do any sequencing :P
14:11:40 <benmachine> it's very literal
14:11:51 <ski> > do { let { x = 4 }; return ();let { y = x }; let { x = y + 1 }; x }
14:11:52 <lambdabot>   <no location info>: parse error on input `�'
14:12:02 <benmachine> it does all the translations syntactically and if there's no >>= involved then no problem
14:12:06 <pikhq> lambdabot: That's desugared as let x = 4 in let y = x in let x = y + 1;x
14:12:11 <pikhq> Erm.
14:12:15 <pikhq> ski: That's desugared as let x = 4 in let y = x in let x = y + 1;x
14:12:19 <ski> > do { let { x = 4 }; return (); let { y = x }; let { x = y + 1 }; x }
14:12:21 <lambdabot>   No instance for (GHC.Num.Num (m b))
14:12:21 <lambdabot>    arising from a use of `e_141' at <in...
14:12:28 <ski> *nod*
14:12:37 <monochrom> at least put a "return" there!
14:13:11 <ski> pikhq : i was just suprised that the use of `do' didn't automatically add a `Monad' constraint (before desugaring, i.e.)
14:13:26 <ski> though, now that i think of it, i recall
14:13:28 <ski> @type do ()
14:13:30 <lambdabot> ()
14:13:31 <pikhq> Heh.
14:13:36 <ski> but is this Haskell98 ?
14:13:53 <monochrom> probably open-ended on this
14:14:14 <ski> (monochrom : .. i did put a `return' in there :)
14:14:20 <aristid> @type do { let { x = 4 }; let { y = x }; let { x = y + 1 }; return x }
14:14:20 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a
14:14:24 <EvanR> how do i show that a system is turing complete. implement a universal turing machine?
14:14:48 <ski> EvanR : or implement lambda-calculus, or recursive functions
14:15:00 <ski> (or Post system, or Markov chains ..)
14:15:29 * ski should probably some day figure out what this Markov thing is about
14:15:42 <EvanR> whats the simplest universal turing machine
14:17:12 <tensorpudding> one of those cellular automata I think
14:17:49 <monochrom> the haskell98 report does not say anything about the type of do
14:19:02 <monochrom> implementing an easy programming language is the easiet
14:19:07 <tensorpudding> apparently there is a two state three color Turing machine that is universal, which is the smallest yet known
14:19:29 <soupdragon> I don't understand why that's simpler than lambda calculus
14:19:30 <monochrom> or do some game-of-life thing.
14:19:59 <companion_cube> soupdragon: simpler to implement, maybe ?
14:20:01 <monochrom> game of life is also fun, you will actually play with it long after you have implemented it.
14:20:02 <EvanR> lambda calculus has complex rewrite rules
14:20:47 <Cale> EvanR: You could always go with some combinator calculus :)
14:20:53 <EvanR> ah
14:20:59 <tensorpudding> the combinator calculus only requires one combinator
14:21:01 <tensorpudding> doesn't it?
14:21:03 <ski> soupdragon : it's probably "simpler" in the same sense that a hilbert system is "simpler" than natural deduction or sequent calculus : look, we only need one (or two) inference rules !
14:21:07 <monochrom> how is lambda calculus rewrite rules complex?
14:21:16 <soupdragon> yes you can define a combinator X such that (XX)X = S and X(XX) = K
14:21:35 <soupdragon> (infact you can do better than this, perhadp  (XX) = S ; X(XX) = K
14:22:04 <tensorpudding> That's pretty simple in one respect.
14:22:04 <monochrom> but natural deduction is simpler. we only need one or two axioms!
14:22:45 <soupdragon> the alpha conversion stuff is difficult -- but you can avoid it completely
14:23:10 <EvanR> if you system already does that then i guess its not a big deal
14:23:12 <benmachine> soupdragon: so X basically is a function that turns X into S and S into K?
14:23:28 <benmachine> soupdragon: does it have defined behaviour on K? does it have a "normal" definition?
14:23:37 <catenate> you could make a http://en.wikipedia.org/wiki/One_instruction_set_computer
14:23:37 <soupdragon> the point is that you can recover S and K from X
14:23:43 <soupdragon> so {X} is equivalent to {S,K}
14:24:26 <soupdragon> I didn't define X, just gave a hint to how you might find a single combinator calculus that is complete
14:25:05 <monochrom> oh that's fun
14:25:31 <EvanR> catenate: thought about it, my system does have subtraction
14:35:30 <pastorn> @pl (\x y -> isAlpha x && isAlpha y)
14:35:31 <lambdabot> (. isAlpha) . (&&) . isAlpha
14:36:11 <benmachine> :t on (&&) isAlpha
14:36:12 <lambdabot> Char -> Char -> Bool
14:36:20 <pastorn> :D
14:36:22 <cheater99> hey guys, i've got a problem with my script's logic somewhere
14:36:54 <cheater99> here's the script: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26850#a26850   here's the input data:   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26852#a26852
14:37:31 <soupdragon> and what's it meant to do??
14:37:34 <cheater99> it should process each line, extract the quoted string (or an empty string), and group the pairs by that string
14:37:37 <cheater99> i'm typing
14:38:03 <cheater99> unfortunately it doesn't seem to be doing that: the line with a single quote on it gets grouped separately to the lines without any quotes on them
14:38:13 <cheater99> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26853#a26853
14:38:19 <cheater99> here's the output i'm getting
14:38:56 <stepkut> what ist he best way to get cabal-install on ubuntu karmic ?
14:39:10 <soupdragon> what's it meant to do
14:39:26 <cheater99> soupdragon: are you asking me?
14:39:28 <pastorn> stepkut: download it from hackage and install it?
14:39:42 <stepkut> pastorn: but you also need all the dependencies installed first ?
14:39:53 <pastorn> stepkut: of course :p
14:40:06 <stepkut> pastorn: sounds like a pain :)
14:40:11 <pastorn> no, it's not
14:40:18 <pastorn> i usually first download ghc from
14:40:20 <pastorn> @where ghc
14:40:21 <lambdabot> http://haskell.org/ghc
14:40:40 <pastorn> and then i download "Cabal" from hackage, and then "cabal-install" and install those
14:40:59 <pastorn> you might need to apt-get install one or two packages somewhere in between there
14:41:07 <pastorn> libz-dev or something
14:41:13 <pastorn> i don't remember exactly
14:41:53 <Peaker> they used to have a nice tool (auto-apt) that hooked open calls and when you tried to open a file that belongs to an uninstalled package, it would prompt to install it and the open call would succeed
14:41:56 <stepkut> pastorn: you're not convincing me it's not a pain yet :)
14:42:13 <monochrom> I obtain cabal-install by building haskell platform.
14:42:14 <pastorn> stepkut: well, it gives you the most convenient installation
14:42:25 <Peaker> stepkut, It's much more of a pain than apt-get, but it's better later on, more likely for cabal-install to work
14:42:39 <cheater99> anyone able to spot a problem with my script?
14:42:40 <pastorn> you might do it all with apt-get, but then the installation might be system-wide instead of in ~
14:42:57 <pastorn> stepkut: and it's not that difficult to download and install the packages manually
14:42:58 <monochrom> build haskell platform: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
14:42:59 <cheater99> it's sort of crazy, because those things *seem* like they should work well.
14:43:18 <gwern> ubuntu has this somewhat annoying tool which checks any failed executable call, searching all .debs for one providing an executable by the same name
14:43:30 <gwern> I say annoying because usually it kicks into action for typos for me :)
14:43:36 <stepkut> pastorn: well, when you just want to tell someone to, cabal install happstack, and then then don't even have cabal installed.. 
14:43:41 <dafis> cheater99, you know that groupBy only groups *adjacent* list entries according to a predicate?
14:43:49 <cheater99> dafis: ohh
14:43:54 <cheater99> dafis: i didn't know that. thanks.
14:44:00 <pastorn> stepkut: this is assumed
14:44:16 <dafis> so, maybe you'd want to sort before grouping
14:44:20 <stepkut> pastorn: what is assumed ?
14:44:32 <pastorn> stepkut: that you already had it all installed to begin with
14:44:42 <pastorn> no serious haskler doesn't have cabal
14:44:50 <pastorn> it's how you get libraries etc.
14:45:06 <wli> gwern: It's probably doing linear search when it shouldn't be.
14:45:10 <stepkut> pastorn: sure, but I have actually people who actually want to use happstack and don't have cabal installed
14:45:20 <cheater99> dafis: works perfectly well, thanks!
14:45:22 <pastorn> then install it
14:45:28 <pastorn> stop complaining and just do it :.
14:45:31 <pastorn> :p
14:45:51 <stepkut> pastorn: *I* can't install it, I have to provide instructions for others to follow, hence my desire to find the *easiest* way to get going
14:46:01 <pastorn> ah
14:46:13 <monochrom> instructions are at http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
14:46:36 <gwern> wli: it's not the speed that bothers me, just that usually it's guaranteed to be useless and it distracts me as it is unexpected
14:47:13 <adimit> 'elo, I'm looking for an online source repository for GHC. I'd like to have a look at 1-2 source files, and not download 100MB+ worth of sources. How can I find one?
14:47:30 <gwern> adimit: just browse the darcs repo; it's served over http?
14:48:32 <adimit> gwern; ay thanks. Always the obvious stuff I'm oblivious to... :-|
14:48:56 * gwern has learned over years of #haskell and #xmonading, always ask about the obvious solution
14:49:34 <adimit> Is the cable plugged? That question is more justified than I'd like it to be...
14:50:18 <monochrom> the cable is not plugged. we are wireless.
14:50:25 <max_atreides>  /wc
14:50:49 <pastorn> stepkut: if it's for others it wouldn't be too hard to write a script that does all of the installation
14:50:53 <stepkut> does bytestring have an hPutNonBlocking? I can't find it..
14:50:55 <gwern> man, I hate wireless networking. *so* much to go wrong
14:51:08 <pastorn> which you then distribute
14:51:27 <stepkut> pastorn: I think that is what haskell platform is supposed to do.. but it failed because time was not installed..
14:52:59 <pastorn> stepkut: well, haskell platform is a set of libraries, i was just talking about a script that installed GHC, Cabal and cabal-install
14:53:38 <pastorn> then whatever libraries might be needed could be fetched through cabal
14:54:00 <Saizan> the haskell platform also has an installer
14:54:14 <Saizan> which includes cabal-install in the source form
14:54:26 <Saizan> and GHC too in the binary, iirc
14:54:38 <dafis> Saizan: not on linux, iirc
14:54:50 <Saizan> is there a binary installer for linux?
14:55:01 <dafis> don't think so
14:55:33 <pastorn> stepkut: and this doesn't work? http://davidsiegel.org/haskell-platform-in-karmic-koala/
14:55:41 <dafis> haven't looked at the platform for a long time, when I looked it was *you need a working ghc* on linux
14:55:44 <Twey> http://hackage.haskell.org/platform/linux.html
14:55:53 <Twey> See the distro packages at the top
14:56:15 <stepkut> pastorn: no, getting the error, Configuring cabal-install-0.8.0... Setup: At least the following dependencies are missing: Cabal ==1.8.*
14:56:21 <stepkut> pastorn: but Cabal install is install in the local package database
14:56:49 <dafis> stepkut: which GHC have you?
14:56:53 <stepkut> 6.10
14:57:08 <Saizan> stepkut: how are you running Setup?
14:57:15 <dafis> stepkut: then it's cabal-install-0.6.2 for you
14:57:17 <stepkut> Saizan: just running make
14:57:40 <Saizan> oh, the latest haskell-platform won't work with 6.10
14:57:50 <dafis> stepkut: cabal-install comes with a bootstrap script
14:57:58 <pastorn> which is AWESOME
14:58:01 <Saizan> you can use the latest cabal-install anyhow
14:58:23 <stepkut> Saizan: so for Karmic, what is the best way to get GHC and cabal-install going? Since karmic comes with 6.10
14:58:46 <Saizan> stepkut: download the cabal-install tarball from hackage and run the bootstrap.sh script
14:59:01 <Peaker> stepkut, It doesn't take much time to just download the newest ghc binaries, "configure ; sudo make install" on them, then download Cabal-install, run ./bootstrap.sh
14:59:26 <stepkut> Saizan: cabal unpack cabal-install ; cd cabal-install-* ; ./bootstrap.sh ?
14:59:26 <Peaker> stepkut, I wouldn't use Ubuntu's debian package of any Haskell stuff, it's usually out-dated
14:59:29 <pastorn> stepkut: what peaker said... you can write a simple shell script that you just run with sudo and then it's all done :)
14:59:30 <dafis> stepkut: but pick a cabal-install version matching the Cabal library version of your GHC
14:59:42 <Saizan> stepkut: yeah
14:59:56 <Saizan> stepkut: i hope it'll download the appropriate Cabal too
14:59:59 <Peaker> stepkut, you might need to install a -dev package for cabal-install to install, but this is true of any package you'll ever "cabal install" later
15:00:06 <stepkut> pastorn: bah, I am the happstack maintainer, I shouldn't be in change of making cabal-install work on ubuntu too :(
15:00:09 <Saizan> stepkut: it's perfectly fine to upgrade Cabal
15:00:27 <pastorn> stepkut: i run ubuntu and i never use what's in APT
15:00:57 <pastorn> it's always old and i've had the haskell-db bindings make APT explode in my face numerous times
15:01:09 <pastorn> so i'm staying far away from it
15:01:35 <monochrom> I use ubuntu and I just build haskell platform from source
15:01:48 * pastorn is not as brave as monochrom
15:02:02 <Saizan> monochrom: do you use ubuntu's GHC?
15:02:06 <monochrom> it's a no brainer. do you want my url for the 3rd time?
15:02:15 <pastorn> haha
15:02:16 <pastorn> yes plz
15:02:25 <monochrom> I don't use ubuntu's ghc. I use ghc's generic binary.
15:02:31 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
15:05:54 <monochrom> I should add to it "don't upgrade cabal even though it tells you to"
15:09:20 <Saizan> actually, using the latest cabal-install is usually the best choice
15:14:13 <monochrom> with 20% chance it breaks things.
15:14:37 <monochrom> or at least confusing the hell out of people.
15:15:35 <monochrom> here is how: with 20% chance haskell platform lags ghc by one major version. cabal-install tracks ghc too closely, haskell-platform doesn't. version conflict such as base version.
15:16:02 <Peaker> cabal-install really really needs import/export signature matching to avoid the dependency hells.. and to allow adapter packages such that packages can use either of mtl/transformers as long as a proper adapter gives them the interface they expect
15:16:32 <Peaker> To avoid the problematic splits
15:16:38 <monochrom> for example when ghc 6.12.1 was just out, haskell platform was still at 6.10, lots of people got hurt, and we know because they came here to ask.
15:16:55 <Saizan> monochrom: you can install cabal-install on ghc-6.8, so that's moot
15:17:18 <Saizan> they were hurt by something else, if anything.
15:17:59 <Saizan> sorry, "you can install the last 5 or so versions of cabal-install on ghc-6.8"
15:19:14 <Saizan> 0.6.2 had a problem with how ghc-6.10 was the first ghc with both base-4 and base-3
15:19:29 <Saizan> that was a forward compatibility problem, not backwards.
15:39:57 <Peaker> instance Something where a = a  -- I haven't imported the class's "a", will this be infinite recursion, or will it use my module's "a"?
15:40:03 <Peaker> I suppose the latter, but it's scary :)
15:40:19 <Botje> that's an infinite recursion
15:40:31 <Saizan> it'll use your module's a
15:40:40 <byorgey> FIGHT
15:41:02 <Saizan> Peaker: test it :)
15:41:18 <ski> hm, if you haven't imported the `a' of the class, then you (imo) shouldn't be able to give a definition of it
15:41:26 <ski> (not sure if that is actually the case)
15:42:01 <monochrom> how does "instance Something" make sense if you haven't imported "class Something"?
15:42:06 <Saizan> and report back, otherwise i'll have to test it too, then Botje won't believe me and he'll have to test again, all that contributing to the heat death of the universe needlessly
15:42:26 <Saizan> monochrom: you can import the class without importing the methods
15:42:38 <ski> monochrom : presumably `Something' is imported, but not the `a' method of it
15:43:14 <Peaker> Saizan was right :)
15:43:15 <Saizan> import Foo (Something) vs. import Foo (Something(..))
15:43:44 <Peaker> The namespace you assign into in the instance decl is different from that you read
15:43:51 <ski> Peaker : so .. report this as a bug ?
15:43:59 <ski> s/bug/possible bug/
15:44:51 <Peaker> ski, I guess it would be nicer to use the fully qualified name for the methods in there, but I don't mind that much the way it is, it is OK
15:45:16 <gwern> > 33 * 12 * 30 * 24
15:45:17 <lambdabot>   285120
15:53:51 <monochrom> It is probably not a bug in the spirit of haskell98
15:54:30 <monochrom> but I can only say spirit. the text does not imply it specifically
15:56:38 <monochrom> the spirit is gleaned from 5.5.3. you import a name because you use it directly. if you don't use it directly, you don't have to import, the compiler will figure it out.
15:57:38 <Peaker> I just imported the module that defines the class qualified
15:57:44 <Peaker> and had the same method names in my module (unqualified)
15:58:15 <monochrom> the specific example uses a type T and a value x::T. you only import the value name x. you don't have to import the type name T. the typechecker will still know it's T.
15:58:36 * hackagebot directory 1.0.1.2 - library for directory handling  http://hackage.haskell.org/package/directory-1.0.1.2 (IanLynagh)
16:02:05 <monochrom> so, when you say "instance Something where a=a", and import only "Something": for the LHS "a", you didn't import it, that's cool, the compiler still has to figure out it refers to a method of Something. for the RHS "a", it's a direct use of "a", so it cannot refer to what you didn't import.
16:04:13 <Peaker> monochrom, Yeah, it's reasonable behavior
16:04:25 <Peaker> monochrom, Though I think it may be reasonable to just force the user to properly name the method
16:04:34 <Peaker> (With a fully qualified name if necessary)
16:06:58 <monochrom> it makes sense most of the time (eg the x::T example) but it has strange consequences
16:08:04 <Peaker> in my case, forcing to name would require: ClassModule.method = method
16:08:08 <Peaker> which is more clearly "not a loop"
16:11:15 <Cale> To me, a = a pretty unambiguously looks like a loop :)
16:12:26 <ivanm> same
16:12:59 <ivanm> something like "show = showList" might _appear_ at first glance to be a co-recursive loop, but it uses a different instance
16:13:27 <Saizan> itym mutually recursive?
16:13:57 <ivanm> yeah
16:13:59 <ivanm> but still a loop
16:17:15 <Saizan> i wonder if there's a type T such that "a :: T; a = a" at the toplevel is not a loop
16:18:38 <Peaker> Well, I'm working on a non-textual editor so hopefully eventually the editor will be able to display fully-qualified names when ambiguous while letting you hoogle for short names (The best of both worlds :)
16:24:23 <dolio> Saizan: What constitutes a loop?
16:24:55 <ivanm> @check flip const == const id
16:24:56 <lambdabot>   No instance for (GHC.Classes.Eq (b -> a -> a))
16:24:56 <lambdabot>    arising from a use of `GH...
16:25:01 <ivanm> bah
16:25:11 <ivanm> dolio: GHC printing <<loop>> ? :p
16:25:32 <dolio> For what?
16:27:01 <Saizan> we could say that print (seq a ()) should putStrLn "()" if a is not a loop
16:27:07 <Peaker> @check (liftA2 . liftA2) (==) (flip const) (const id)
16:27:08 <lambdabot>   "OK, passed 500 tests."
16:27:18 <Peaker> @type (liftA2 . liftA2) (==) (flip const) (const id)
16:27:19 <lambdabot> forall b a. (Eq b) => a -> b -> Bool
16:27:26 <dolio> Then no, there is no such T.
16:28:06 <soupdragon> how do you calculuate pi by throwing a string?
16:28:35 <soupdragon> randomly
16:28:51 <benmachine> this sounds like a setup to a joke but I suspect the answer is throw it on some horizontal lines and see how many it intersects
16:29:00 <benmachine> there's then a calculation you can do with the average I think
16:29:03 <soupdragon> I remember http://blog.sigfpe.com/2009/10/buffons-needle-easy-way.html
16:29:21 <soupdragon> you got it exactly right benmachine
16:29:59 <benmachine> I was a bit vague on the details though :P
16:32:23 <danharaj> I thought of that as throwing a String as an exception
16:32:25 <danharaj> I was confised.
16:38:04 <benmachine> heh me too
16:39:41 <gwern> I sometimes wonder if normals are confused by computer use of 'string'
16:40:05 <soupdragon> normals of unit length?
16:40:38 <Cale> soupdragon: That's how I read it at first too. Had to backtrack and re-parse.
16:43:40 <Saizan> did you use exceptions for that backtracking?
16:49:04 <sbpaul> is there some script i can run to just uninstall and reinstall all packages installed by cabal or ghc-pkg or whatever
16:49:13 <sbpaul> i have this big mess
16:51:11 <Peaker> I just noticed type synonyms cannot be forward-referenced
16:51:15 <Peaker> interesting way to prevent cyclic ones?
16:51:44 <Saizan> sbpaul:  you can dump the list with ghc-pkg list --user, and remove them by deleting ~/.ghc
16:52:26 <Saizan> sbpaul: if you only did user-local installations
16:52:42 <sbpaul> there are some in /usr/lib/ghc-6.12-1 or w/e
16:52:45 <sbpaul> in package.conf.d
16:52:49 <sbpaul> you know?
16:52:57 <monochrom> I can forward-reference type synonyms
16:53:14 <monochrom> I have: x::T; x=0; type T=U; type U=Int
16:54:10 <Saizan> sbpaul: if you never installed packages globally, which is not the default for cabal-install, then those are just the ones that come with ghc
16:54:12 <Peaker> monochrom, Try to replace Int with a data type that's declared last?
16:54:30 <Peaker> monochrom, That's more similar to what I have
16:54:33 <Saizan> sbpaul: if you want you can delete those too and reinstall ghc from scratch
16:54:40 <sbpaul> i'm doing that
16:55:59 <monochrom> I have x::T; x=D; type T=D; data D=D deriving Show. still works.
16:56:14 <monochrom> ghc 6.12.3
16:58:27 <Peaker> monochrom, same version here. Not sure why it was disallowed then. Maybe I'll investigate later. Thanks for checking
16:58:37 <Peaker> (in a middle of a big refactoring)
16:59:10 <monochrom> I have only loaded with ghci
16:59:56 <monochrom> ghc -c also works.
17:15:55 <kniu> :t flip
17:15:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:16:12 <kniu> @src flip
17:16:13 <lambdabot> flip f x y = f y x
17:16:24 <aasmith_> @src last
17:16:25 <lambdabot> last [x]    = x
17:16:25 <lambdabot> last (_:xs) = last xs
17:16:25 <lambdabot> last []     = undefined
17:20:05 <aasmith_> @src isDigit
17:20:05 <lambdabot> Source not found. Sorry.
17:33:25 <tolkad> :t map
17:33:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:34:43 <tolkad> :t sum
17:34:44 <lambdabot> forall a. (Num a) => [a] -> a
17:37:13 <tolkad> why doesn't that look like "forall a b. (a -> b), [a] -> [b]"
17:37:29 <kmc> why would it?
17:37:31 <tolkad> I don't understand why it uses -> to seperate argument types
17:37:50 <tolkad> I mean, to seperate the types of different arguments
17:37:52 <Veinor> because map is a single-argument function
17:37:53 <kmc> tolkad, because a two argument function is really a function that takes arg 1, and returns a function which takes arg 2
17:38:08 <kmc> that's why partial application works
17:38:11 <kmc> :t map succ
17:38:12 <lambdabot> forall a. (Enum a) => [a] -> [a]
17:38:23 <tolkad> oh. I see.
17:38:23 <kmc> :t (map succ) [2,3,4]
17:38:24 <lambdabot> forall a. (Enum a, Num a) => [a]
17:38:41 <kmc> «f x y z» is shorthand for «((f x) y) z»
17:38:52 <tolkad> Is it impossible in haskell to have functions with the same name, but different numbers of arguments?
17:38:57 <kmc> yes
17:39:14 <tolkad> oh, I guess Java is better in that respect
17:39:17 <kmc> haha
17:39:21 <tolkad> :P
17:39:40 <kmc> you can essentially do it with type classes in haskell
17:40:53 <kmc> i suppose that counts -- because you said two functions with the same name, and not one function with a flexible arg list
17:41:09 <kmc> the instances of a type class all define different functions with the same names
17:41:11 <kmc> sort of
17:42:10 <aasmith_> @src last
17:42:10 <lambdabot> last [x]    = x
17:42:10 <lambdabot> last (_:xs) = last xs
17:42:10 <lambdabot> last []     = undefined
17:42:20 <kmc> tolkad, the pedantic answer to your question is "yes, it's impossible, because every function has exactly one argument, without exception"
17:42:42 <lispy> oh, I never thought about rewriting sum to have type (a -> b) -> f a -> f b
17:42:52 <lispy> But, that should be possible right?
17:43:05 <kmc> why?
17:43:14 <lispy> er, sorry cancel that
17:43:30 <lispy> I misread the scroll back, I read that sum had the type that map has
17:43:36 <lispy> But, sum wouldn't have that type
17:43:58 <aasmith_> if i define my own version of last, but in the last case define myLast [] = [] myLast then raises an error at runtime when i try lists of ints, such as myLast [1,2,3]. i dont understand why.
17:44:33 <kmc> that would be an error at compile time
17:44:36 <aasmith_> changing it to return undefined of course works as it then matches the implementation of last. :)
17:44:49 <aasmith_> actually, yes. compile time.
17:44:51 <kmc> if the case for [] returns a list, the other cases must return a list too
17:45:00 <kmc> so your type would be [[a]] -> [a]
17:45:03 <aasmith_> ah yes.
17:45:23 <aasmith_> which explains why myLast ["abc","def"] worked.
17:45:28 <kmc> yeah
17:45:37 <kmc> if you wrote a type sig for it, you might get a more useful message
17:45:42 <kmc> or if you asked the type in ghci
17:46:41 <lispy> tolkad: implicit parameters also let you have multiple arity for a single function name
17:46:46 <aasmith_> it was just bad logic on my behalf that i should even be returning an empty list in that case.
17:46:57 <aasmith_> thanks
17:47:36 <lispy> aasmith_: yeah, you probably want your last to be myLast :: [a] -> Maybe a
17:47:56 <lispy> aasmith_: that way, you can handle this case with Nothing instead of error or []
17:48:07 <soupdragon> > 377/120
17:48:08 <lambdabot>   3.1416666666666666
17:48:21 <aasmith_> i see. thanks!
17:48:35 <lispy> :t round
17:48:36 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:49:02 <dafis> > 355/113
17:49:02 <lispy> > round (377/120 * 1000000) / 1000000 -- devil's pie?
17:49:03 <lambdabot>   3.1415929203539825
17:49:03 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:49:03 <lambdabot>    `GHC.Real.Integral b'
17:49:03 <lambdabot>   ...
17:49:18 <lispy> doh!
17:49:49 <lispy> > 377/120 - (6/9000000)
17:49:51 <lambdabot>   3.141666
17:49:54 <lispy> there we go
17:49:56 <dafis> > fromIntegral (round (377/120 * 1000000)) / 1000000
17:49:57 <lambdabot>   3.141667
17:50:29 <lispy> 9ths are a great way to deal with infinite repeating digits like 6666...
17:50:55 <dafis> actually, (10-1)ths
18:03:41 <phenom_> hey, what are peoples thoughts on haskell vs clojure in terms of performance ?
18:05:16 <gwern> well, purely functional programs suffer no worse than a n*log n slowdown compared to mutable state
18:05:25 <gwern> so I'd say clojure can't be all that much faster
18:06:22 <tensorpudding> Clojure might be pretty quick due to its use of the JVM, but who knows.
18:07:39 <aasmith_> @src fst
18:07:39 <lambdabot> fst (x,_) =  x
18:10:38 <kmc> haha gwern
18:11:08 <kmc> hmm, clojure isn't on the shootout
18:19:35 <catenate> tensorpudding: Eight, sir; seven, sir; six, sir; five, sir; four, sir; three, sir; two, sir; one! [beat] Tenser, said the Tensor. Tenser, said the Tensor. Tension, apprehension, and dissension have begun. [beat]
18:22:28 <technogeeky> is it normal if I'm a little turned on right now?
18:22:37 <technogeeky> or do I need to go to #physics
18:31:42 <technogeeky> does lambda search channel history? :o
18:31:56 <Cale> lambdabot? No.
18:36:45 <lispy> Cale: how's it going?
18:40:11 <tolkad> Does haskell let you use inline assembly like C does?
18:40:40 <pikhq> C doesn't allow you to use inline assembly, just certain C compilers.
18:41:10 <pikhq> Haskell doesn't let you use inline assembly, nor do any Haskell compilers. You can, however, link against assembly or C functions using the Haskell FFI.
18:41:47 <pikhq> I think the closest you can get is the LLVM binding, which can let you generate some LLVM code and get a Haskell function from it.
18:42:18 <kmc> and various other code-generation libraries
18:42:22 <tolkad> think that would allow me to use the C implementation of printf?
18:42:42 <kmc> this is a lot more flexible than inline assembly
18:43:01 <kmc> tolkad, why do you want to do that?
18:43:06 <pikhq> tolkad: You don't want C printf.
18:43:20 <kmc> you want inline assembly because you need to make a variadic C call?
18:43:33 <tolkad> yeah
18:43:44 <gwern> kmc: well, I think a n slowdown isn't all that bad an asymptotic slowdown. and you have to admit, it's the best answer to phenom_'s silly question
18:43:46 <Cale> lispy: good
18:43:52 <pikhq> tolkad: You don't want to do that.
18:44:01 <pikhq> You may think you do, but you don't.
18:44:10 <Cale> lispy: Been feeling a bit sick the past couple days, but I think it might be going away
18:44:13 <pikhq> Now, what are you intending to accomplish?
18:44:16 <kmc> gwern, no it's not, it perpetuates a silly and false myth about haskell
18:44:26 <kmc> which is that there's no way to use state or write imperative algorithms
18:44:38 <lispy> Cale: ah!  that's no good
18:44:38 <tolkad> pikhq: Actually, I was just trying to think of the ugliest thing I could possibly do
18:44:44 <kmc> haha tolkad
18:44:45 <gwern> I didn't say it had to be a nlogn slowdown
18:44:54 <gwern> just that that's the worst case
18:44:58 <lispy> Cale: I was going to ask if lambdabot has been more unruly than normal lately with all the spammers
18:45:03 <pikhq> That is in fact the ugliest thing you could possibly do with the FFI, yes.
18:45:11 <Cale> lispy: Its screen went away a couple times
18:45:13 <lispy> Cale: but if you've been sick, you probably don't know
18:45:24 <lispy> Cale: oh, that's weird
18:45:34 <lispy> Cale: I haven't been doing anything on the server
18:45:42 <kmc> gwern, the worst case is exponential, if you use peano naturals
18:45:58 <Cale> lispy: Might have just terminated for some reason
18:45:59 <gwern> does the report specify peano naturals?
18:46:05 <kmc> or even worse if you recompute values of ackermann's function between every step
18:46:16 <kmc> talking about the worst way to code something is not very well defined
18:46:29 <gwern> I don't think either clojure or haskell's implementations or reports specify computing ackermann's function anywhere
18:47:10 <kmc> you're saying "Haskell is log(n) slower if you restrict yourself to not using IO or ST"
18:47:20 <kmc> i agree and offer some further restrictions that make it even slower
18:47:29 <gwern> ST is in the report with complexity guarantees?
18:48:27 <kmc> nope
18:48:36 <kmc> this is a dumb argument though
18:48:54 <pikhq> kmc: Perhaps we should compare against a restriction requiring no stateful computation in an imperative language.
18:49:08 <pikhq> (exempting what state is needed to implement closures correctly)
18:49:27 <tolkad> haskell can't have state?
18:49:48 <monochrom> haskell can't have state.
18:50:06 <tolkad> so... you can't implement, for example, an HTTP server in haskell?
18:50:09 <kmc> if you adhere to a very restrictive definition of "Haskell" -- I don't think IORef is in the Haskell 98 Report's standard libraries
18:50:12 <monochrom> haskell can't type-cast from int to linked list
18:50:29 <kmc> tolkad, otherwise, what i said above is that it's a *myth* that Haskell doesn't have state
18:50:47 <kmc> a common one
18:51:28 <lispy> :t unsafeCoerce 5 :: [Int]
18:51:29 <lambdabot> Not in scope: `unsafeCoerce'
18:51:33 <kmc> also, you can implement stateful computation using only pure functions, by passing state around explicitly
18:51:44 <kmc> the State monad implements syntactic sugar for this
18:51:59 <kmc> it's only when you care about efficiency real in-place updates
18:52:02 <kmc> for which we have IO and ST monads
18:52:32 <kmc> it's only when you care about efficiency that you need real in-place updates*
18:52:57 <tolkad> everyone cares about efficiency to some degree
18:53:09 <kmc> yeah
18:53:23 <kmc> "it's only when you care about a certain level of efficiency"
18:53:24 <kmc> happy?
18:53:36 <Cale> tolkad: Haskell can manage state in lots of ways. When people say that Haskell doesn't have state, what they really mean is that evaluation of Haskell expressions is deterministic and doesn't involve a stateful context.
18:53:41 <tolkad> kmc: sure :P
18:54:00 <kmc> Cale, or they are simply confused
18:54:09 <Cale> Or that, yes :)
18:54:39 <tolkad> I think haskell is pretty cool
18:54:46 <tolkad> they should integrate it into standard C
18:54:47 <monochrom> These questions are pretty counterproductive.
18:54:56 <kmc> haha
18:54:59 <gwern> tolkad: maybe you ought to just go use D
18:55:07 <gwern> that seems kind of like haskell-flavored c
18:55:49 <pikhq> gwern: More like "What 
18:55:54 <monochrom> It's just like a reporter asking lots of questions to make a story. Note that the reporter doesn't care, beyond handing in the story to his/her boss and moving on.
18:55:54 <pikhq> C++ always wanted to be."
18:56:08 <kmc> @protontorpedo
18:56:08 <lambdabot> can u build things fast in haskell?
18:56:11 <kmc> @protontorpedo
18:56:11 <lambdabot> how does haskell compare to c++?
18:56:53 <tolkad> @protontorpedo
18:56:53 <lambdabot> The things I dotn get about relatinal databases is that they take wrok to maintain
18:57:06 <tolkad> this thing is great
18:57:08 <tolkad> @protontorpedo
18:57:08 <lambdabot> are objects kina just subroutines
18:57:22 <Cale> tolkad: What we instead do is to devise values which simply describe I/O effects, building them up from simpler descriptions of actions using a bunch of combining functions. The process of evaluating which action we have is I/O and state-free, but executing the described IO action in the end is not.
18:57:25 <pikhq> Hmm. Who wrote that?
18:57:25 <tolkad> nah, they're more like structs
18:57:57 <gwern> pikhq: a troll by the name of protontorpedo
18:58:07 <Cale> @keal
18:58:07 <lambdabot> 99% of my book has been erased by faulty hdd's
18:58:21 <kmc> tolkad, integrating high-level abstract features into a language which is fundamentally low-level, type-unsafe, and has explicit unsafe memory management is a tricky business
18:58:22 <pikhq> tolkad: More like closures that close over the same environment.
18:58:26 <Cale> @keal
18:58:26 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
18:58:40 <pikhq> gwern: Wait, lambdabot's just putting out random lines from a chat log from this person?
18:58:44 <pikhq> Wows.
18:58:50 <gwern> pikhq: you can always check the source
18:58:59 <kmc> tolkad, i can think of one prominent language design which tried to achieve this and is fairly well acknowledged to be a disaster
18:59:01 <phenom_> @phenom_
18:59:01 <lambdabot> Unknown command, try @list
18:59:02 <Cale> pikhq: They're not exactly random
18:59:04 <kmc> i won't name it
18:59:06 <phenom_> 2LIST
18:59:08 <monochrom> Someone who cares and is rational does not break things down to "can haskell do assembly" "can haskell do states" like that. He/She just asks, has there been web servers written in haskell, has there been irc bots written in haskell, has there been IDEs written in Haskell.
18:59:09 <phenom_> @list
18:59:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:59:10 <Cale> pikhq: They're the best lines :)
18:59:21 <pikhq> Cale: Mmm. :)
18:59:24 <monochrom> And the answer is "yes" to all those 3.
18:59:46 <phenom_> @brain
18:59:47 <lambdabot> It is here that my cheap workforce of trained iguanas will work
18:59:47 <lambdabot> night and day to make our shoes to my exacting specifications!
18:59:54 <kmc> @nixon
18:59:54 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
19:00:06 <monochrom> And then the only two rational choices for the asker are "oh nice I'll try to learn how to do those in haskell" or "I don't have time now, I'll check back later"
19:00:07 <pikhq>  monochrom Or perhaps even just "Would it be feasible to write an X in Haskell".
19:00:10 <tolkad> @Cale
19:00:10 <lambdabot> Unknown command, try @list
19:00:12 <kmc> how delightfully creepy
19:00:32 <monochrom> not "can haskell have state, if not, I conclude haskell can't do irc bot"
19:00:49 <tolkad> haskell can't do irc bots?
19:00:52 <kmc> hahaha
19:01:10 <monochrom> lambdabot is written in haskell. no inline assembly necessary.
19:01:31 <kmc> i thought lambdabot was written in F# ;P
19:01:40 <tolkad> I'm going to get back to "learn you a haskell for great good"
19:01:48 <pikhq> tolkad: Good choice.
19:02:07 <monochrom> I can only conceive reporters or trolls asking these loaded questions, i.e., questions full of prejudice.
19:02:23 <monochrom> And I can't tell the difference between reporters and trolls.
19:02:40 <Cale> @quote Cale
19:02:41 <lambdabot> Cale says: I swear that most of higher-dimensional category theory must have been arrived at by some guys sitting around in a room with a blackboard and saying "What if a drew a diagram like *THIS*!?
19:02:41 <lambdabot> " and drawing some insane scribble up on the blackboard, and then everyone tries to figure out how to turn it into meaningful mathematics.
19:03:02 <kmc> hehehe
19:03:07 <kmc> @quote lambdabot
19:03:07 <lambdabot> lambdabot says: <kmc> @vixen why don't you like me? <lambdabot> because i don't see the need to
19:03:14 <kmc> @quote lambdabot
19:03:14 <lambdabot> lambdabot says: Plugin `quote' failed with: getRandItem: empty list
19:03:16 <kmc> @quote lambdabot
19:03:17 <lambdabot> lambdabot says: i 4M THe cooLES+ bo+ e\/eR
19:03:38 <dafis> @vixen
19:03:38 <lambdabot> cool
19:03:56 <Cale> @vixen a/s/l
19:03:57 <lambdabot> 19/f/California
19:04:34 <kmc> @vixen can you write an irc bot in haskell
19:04:34 <lambdabot> church is my favourite computer scientist.
19:04:37 <kmc> @faq can you write an irc bot in haskell
19:04:37 <lambdabot> The answer is: Yes! Haskell can do that.
19:05:05 <pikhq> @quote pikhq
19:05:05 <lambdabot> pikhq says: <kmc> you use simonSaysPerformIO to make it so <pikhq> Yes, but you should think long and hard before using it if you're not named Simon.
19:05:23 <pikhq> I think that's my only quote in lambdabot. Should've known better.
19:05:28 <dafis> @faq can you write bad code in Haskell
19:05:29 <lambdabot> The answer is: Yes! Haskell can do that.
19:05:47 <dafis> this bot knows all, really
19:06:41 <chessguy> 'ello
19:07:31 <dafis> > reverse "hello"
19:07:32 <lambdabot>   "olleh"
19:07:48 <pikhq> Kxa5#!
19:08:08 <tolkad> @faq Can haskell randomly wipe your HD?
19:08:08 <lambdabot> The answer is: Yes! Haskell can do that.
19:13:42 <aasmith_> @src reverse
19:13:42 <lambdabot> reverse = foldl (flip (:)) []
19:15:17 <bremner> that looks pretty pointless.
19:17:52 <tolkad> let identity x = x
19:17:55 <tolkad> > let identity x = x
19:17:56 <lambdabot>   not an expression: `let identity x = x'
19:18:05 <tolkad> @let identity x = x
19:18:06 <lambdabot>  Defined.
19:18:08 <edwardk> > let identity x = x in identity "hello"
19:18:10 <lambdabot>   "hello"
19:18:28 <tolkad> Yeah, I wanted to define it in lambdabot
19:18:40 <tolkad> > identity identity
19:18:41 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
19:18:42 <lambdabot>    arising from a use of `...
19:18:51 <tolkad> > identity identity identity 0
19:18:52 <lambdabot>   0
19:18:55 <dafis> > identity identity "wow"
19:18:56 <lambdabot>   "wow"
19:19:36 <tolkad> @let buffalo x = x
19:19:38 <lambdabot>  Defined.
19:19:56 <tolkad> @let Buffalo = "Buffalo"
19:19:56 <lambdabot>  <local>:7:0: Not in scope: data constructor `Buffalo'
19:20:37 <tolkad> oh, haskell actually give syntatic meaning to class-like identifiers
19:20:57 <edwardk> terms that start with uppercase letters are constructors
19:21:08 <tolkad> > buffalo buffalo buffalo buffalo buffalo buffalo buffalo "buffalo"
19:21:10 <lambdabot>   "buffalo"
19:21:10 <edwardk> > Just 12
19:21:11 <lambdabot>   Just 12
19:21:27 <edwardk> > let Just a = return "Hello" in a
19:21:28 <lambdabot>   "Hello"
19:21:28 <tolkad> > Num 12
19:21:29 <lambdabot>   Not in scope: data constructor `Num'
19:21:38 <tolkad> oh, right, that's a class
19:21:39 * hackagebot charset 0.1 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.1 (EdwardKmett)
19:21:47 <tolkad> > Float 12
19:21:48 <lambdabot>   Not in scope: data constructor `Float'
19:22:01 <tolkad> > Float 12.0
19:22:02 <lambdabot>   Not in scope: data constructor `Float'
19:22:06 <tolkad> it doesn't like me
19:22:14 <edwardk> the constructor for float is more exotic
19:22:18 <edwardk> and lambdabot doesn't import it
19:22:26 <edwardk> data Float = F# Float#
19:22:45 <edwardk> takes an 'unboxed float' and wraps it in a constructor, but like i said, lambdabot doesn't import it
19:23:45 <edwardk> -- had to give up on my cute charset representation based on arbitrary precision floating points for efficiency. moved to IntSet
19:26:40 <tolkad> does haskell have something like null?
19:26:53 <ClaudiusMaximus> i wrote a simple computer algebra thingy if someone wants to take a look, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26859
19:26:58 <tolkad> as it works in Java
19:27:04 <ClaudiusMaximus> @src Maybe
19:27:04 <lambdabot> data Maybe a = Nothing | Just a
19:28:07 <tolkad> > Nothing
19:28:08 <lambdabot>   Nothing
19:28:48 <tolkad> > f :: Int -> Int; f x = Nothing
19:28:49 <lambdabot>   <no location info>: parse error on input `;'
19:29:00 <tolkad> not sure how to do multiple lines in lambdabot
19:29:34 <ClaudiusMaximus> > let { f :: Int -> Int ; f x = Nothing } in f 66
19:29:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:29:36 <lambdabot>         against inferred type ...
19:29:57 <ClaudiusMaximus> if you have f :: Int -> Int, you know that you'll get an Int out if you put an Int in
19:30:29 <wli> I'm thinking you'd probably want to use Grobner bases or something for all this.
19:30:39 <ClaudiusMaximus> > let { f :: Int -> Maybe Int ; f 0 = Nothing ; f x = Just x } in map f [ -5 .. 5 ]
19:30:40 <lambdabot>   [Just (-5),Just (-4),Just (-3),Just (-2),Just (-1),Nothing,Just 1,Just 2,Ju...
19:32:13 <wli> ClaudiusMaximus: Are you trying to solve systems of equations like x^2+y^2+z^2=1, x^3+y^3+z^3=1/2, x^5+y^5+z^5=1/3?
19:32:42 <kmc> tolkad, Haskell has nothing like null.  the problem with null in Java is that it can masquerade as nearly any type and cause a runtime exception, with the consequence that Java's type system gives you few guarantees that your program won't crash
19:33:09 <wli> ClaudiusMaximus: Or maybe 2*x^2+3*y^2+5*z^2=1, 7*x^3+13*y^3+11*z^3=1/2, 23*x^5+19*y^5+17*z^5=1/3?
19:33:22 <ClaudiusMaximus> wli: i solved my actual system already, hold on i'll add it to the paste
19:33:44 <wli> ClaudiusMaximus: But you're trying to solve more general systems, right?
19:34:25 <edwardk> tolkad: we use Maybe where other languages would use null
19:34:25 <ClaudiusMaximus> wli: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26859#a26860
19:34:57 <tolkad> edwardk: when you forget what you meant to return there?
19:34:59 <ClaudiusMaximus> wli: turns out that alpha=beta=gamma=(sqrt 5 - 1)/2
19:35:24 <wli> ClaudiusMaximus: I can show you how to do Buchberger. Doing it inefficiently (which works for small numbers of variables and small numbers of equations) is very easy.
19:35:32 <kmc> neither does Haskell's type system, really, because you can still call "error" anywhere
19:35:34 <Cale> I think the closest thing we have to null is nontermination/undefined
19:35:37 <edwardk> tolkad: well, since every reference can be null in java, you always have to consider that case. in haskell you don't have that headache
19:35:39 <ClaudiusMaximus> wli: and i got equations for 'a'..'x' in terms of alpha/beta/gamma
19:35:56 <bremner> empty lists are a bit like null if you use head and tail
19:36:02 <kmc> yeah
19:36:04 <edwardk> you can use undefined/error in place of null, but unlike null they really mean what they say, you can't test for them.
19:36:07 <Cale> But since you can't detect that, nobody tends to use it for any case where they wouldn't just mind the whole program dying.
19:36:23 <thoughtpolice> @hackage ChasingBottoms
19:36:23 <lambdabot> http://hackage.haskell.org/package/ChasingBottoms
19:36:27 <thoughtpolice> ;)
19:36:34 <ClaudiusMaximus> wli: maybe some other time, i've solved the immediate problem - moving on to the next phase of the thingy
19:36:39 <edwardk> so the role of null is filled by Maybe (in the hey i can test to see if i have a reference to this thing over there sense) and by undefined in the (zomg i don't have a value to plug in there sense)
19:36:44 <jbapple> wli, ClaudiusMaximus: I think there is an implementation of F5 in coq. It could, I suppose, be extracted to Haskell
19:36:50 <Cale> (Sometimes it's useful to be able to detect some of them for testing, which is what that library is for)
19:38:26 <wli> jbapple: F5 is probably too sophisticated to pass along to beginners (though in all honesty I could use a lecture on it).
19:38:28 <tolkad> huh, well... I'll just use some special value then
19:38:32 <tolkad> What about 0378
19:38:35 <tolkad> -378*
19:40:30 <ClaudiusMaximus> tolkad: Maybe gives you a special value, and testing for it is easy!
19:40:46 <wli> jbapple: Now that I think of it where do I go to learn F5?
19:42:21 <kmc> we really try to avoid sentinel values
19:42:24 <aasmith_> type twice f x = f (f x)
19:42:30 <aasmith_> @type twice f x = f (f x)
19:42:30 <kmc> you really should use Maybe or define your own type
19:42:30 <lambdabot> parse error on input `='
19:42:44 <kmc> @type let twice f x = f (f x) in twice
19:42:44 <lambdabot> forall t. (t -> t) -> t -> t
19:43:00 <aasmith_> thanks. its the type signature i dont understand.
19:43:11 <kmc> how so?
19:43:11 <Cale> > zip [0..] (words "here are some words")
19:43:12 <lambdabot>   [(0,"here"),(1,"are"),(2,"some"),(3,"words")]
19:43:17 <Cale> > lookup 2 (zip [0..] (words "here are some words"))
19:43:18 <lambdabot>   Just "some"
19:43:22 <Cale> > lookup 7 (zip [0..] (words "here are some words"))
19:43:23 <lambdabot>   Nothing
19:43:24 <jbapple> wli: I don't know it myself, yet.
19:43:41 <wli> jbapple: F4, then?
19:43:47 <Cale> > case lookup 7 (zip [0..] (words "here are some words")) of Nothing -> "oops, no word"; Just x -> "found: " ++ x
19:43:48 <lambdabot>   "oops, no word"
19:43:52 <Cale> > case lookup 1 (zip [0..] (words "here are some words")) of Nothing -> "oops, no word"; Just x -> "found: " ++ x
19:43:53 <lambdabot>   "found: are"
19:43:59 <aasmith_> kmc: maybe the parens part. i'm trying to translate it into english and fialing :)
19:44:03 <Cale> tolkad: ^^
19:44:16 <kmc> twice takes two arguments if you like
19:44:22 <kmc> the first is a function of type t -> t
19:44:28 <jbapple> wli: I am no more helpful to you on the subject of learning about these than google is. I just happen to know there's a coq implementation of F5.
19:44:35 <kmc> the second is a value of type t
19:44:58 <kmc> and twice returns another value of type t
19:45:10 <kmc> aasmith_, you can write the same type as (t -> t) -> (t -> t)
19:45:23 <kmc> which makes it more clear that twice takes a function f and returns another function f^2
19:45:30 <aasmith_> yes, i think it does
19:45:31 <aasmith_> thanks
19:45:34 <kmc> because we represent multi-arg functions by currying, these are equivalent descriptions
19:45:37 <kmc> :)
19:45:42 <aasmith_> right
19:46:15 <markmcw> Does this ring a bell for anybody? I finally got the HEAD version running (0621 v) but it complains:
19:46:17 <markmcw> Examples/First.hs:1:1:
19:46:17 <markmcw>     Exception when trying to run compile-time code:
19:46:17 <markmcw>       user error ("Examples/First.hs" (line 69, column 26):
19:46:20 <markmcw> unexpected Failed to parse Haskell pattern: 0
19:46:24 <markmcw> SrcLoc {srcFilename = "", srcLine = 1, srcColumn = 11}
19:46:27 <markmcw> ScopedTypeVariables is not enabled
19:46:30 <markmcw> )
19:46:36 <markmcw> when I have -XScopedTypeVariables on the command line
19:46:47 <markmcw> and i put it into a pragma as well
19:46:50 <markmcw> any ideas?
19:48:02 <markmcw> The rest of the output:
19:48:04 <markmcw>      Code: Language.Haskell.TH.Quote.quoteDec
19:48:04 <markmcw>               pads " StrP1 (x::Pint) = PstringFW(:3:) "
19:48:04 <markmcw> Failed, modules loaded: Language.Pads.Padsc, Language.Pads.Quote, Language.Pads.Source, Language.Pads.Pretty, Text.PrettyPrint.Mainland, Data.Loc, Language.Pads.Syntax, Language.Pads.Errors, Text.Regex.ByteString, Language.Pads.Parser.
19:48:07 <markmcw> *Language.Pads.Pretty> :q
19:48:11 <markmcw> Leaving GHCi.
19:48:11 <kmc> markmcw, please don't spam the channel with paste
19:48:25 <kmc> you can put text on hpaste.org
19:48:34 <kmc> i've no idea what you're trying to do
19:48:37 <kmc> HEAD version of what?
19:48:40 <markmcw> sorry, I didn't know about that; I'll do that next time
19:48:44 <markmcw> HEAD version of ghc
19:48:49 <kmc> ok
19:48:51 <markmcw> has quasiquoting for data
19:49:00 <markmcw> that's needed for this project
19:49:36 <kmc> interesting, do you have a link about this new feature?
19:50:19 <markmcw> No, the project leader for this project has been in communication with the PADS team
19:50:28 <markmcw> excuse me -- the GHC team
19:50:29 <markmcw> about it
19:50:30 <kmc> what is PADS?
19:50:35 <markmcw> I guess it's in the README
19:50:40 <kmc> i feel like i'm missing some context here
19:51:20 <markmcw> PADS is a system for parsing ad-hoc data like log files, etc. without having to write Perl or something else difficult to maintain
19:51:27 <markmcw> see http://www.padsproj.org
19:51:55 <kmc> cool
19:52:06 <wli> argh what the heck does Faugere mean by a critical pair?
19:52:59 <markmcw> There is a Haskell version under development; that's the project I volunteered to work on this summer
19:55:06 * Veinor ponders
19:55:15 <Veinor> is there any kind of Set implementation that doesn't require Ord?
19:56:08 <tensorpudding> the collections in Edison, amybe
19:56:10 <tensorpudding> maybe*
20:04:23 <Veinor> hm
20:04:29 <Veinor> then again I don't think I really need speed for Games
20:04:35 <aasmith_> @src abs
20:04:36 <lambdabot> Source not found. You untyped fool!
20:04:43 <aasmith_> :|
20:05:24 <Veinor> @src Complex Abs
20:05:24 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:05:36 <kmc> aasmith_, it's in the Num typeclass and implemented separately for every type
20:05:44 <kmc> aasmith_, in GHCi type ":i abs"
20:06:04 <Veinor> wait, what does :i do?
20:06:24 <kmc> info
20:06:38 <aasmith_> thanks.
20:07:05 <tolkad> foldln acc n [] = n
20:07:05 <tolkad> foldln acc n (x:xs) = foldln acc (acc n x) xs
20:07:11 <tolkad> I made my own implementation of foldl
20:08:47 <dmwit> > let foldln acc n [] = n; foldln acc n (x:xs) = foldln acc (acc n x) xs in foldln (+) 0 [w, x, y, z]
20:08:48 <lambdabot>   0 + w + x + y + z
20:08:57 <dmwit> > foldl (+) 0 [w, x, y, z]
20:08:58 <lambdabot>   0 + w + x + y + z
20:09:04 <dmwit> looks good
20:09:12 <dmwit> ?src foldl
20:09:12 <lambdabot> foldl f z []     = z
20:09:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:09:20 <dmwit> looks identical =)
20:10:33 <tolkad> > random
20:10:34 <lambdabot>   Overlapping instances for GHC.Show.Show (g -> (a, g))
20:10:34 <lambdabot>    arising from a use...
20:10:42 <tolkad> :t random
20:10:43 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
20:11:42 <Veinor> > randomRIO (1,10)
20:11:43 <lambdabot>   <IO Integer>
20:11:47 <tolkad> how exactly do I use random?
20:12:08 <Veinor> tolkad: using the IO monad, usually
20:14:22 <tolkad> umm... is there a function rather than a monad?
20:14:55 <c_wraith> :t randomR
20:14:57 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
20:15:04 <Veinor> oh, yeah
20:15:13 <Veinor> you either have to drop into the IO monad or pass around a random number generator
20:16:13 <c_wraith> You can also use MonadRandom
20:17:47 <tolkad> uh... how would I do that with lambdabot?
20:18:25 <tolkad> meh
20:25:06 <edwardk> tolkad: you can use mkStdGen purely, of course, that doesn't give you the number to plug in, since that would be a side effect
20:25:42 <FunctorSalad> :t mkStdGen
20:25:43 <lambdabot> Int -> StdGen
20:25:48 <FunctorSalad> :t newStdGen
20:25:48 <lambdabot> IO StdGen
20:25:57 <FunctorSalad> wasn't sure
20:25:58 <edwardk> > random (mkStdGen 12) :: (Int, StdGen)
20:25:59 <lambdabot>   (-541245551600169782,323172441 2103410263)
20:26:21 <edwardk> > randoms (mkStdGen 12) :: [Int]
20:26:22 <lambdabot>   [-541245551600169782,2179162766060333935,394044762321126283,163779289959004...
20:27:01 <stepkut> how do I convert a Double to a Float ?
20:27:14 <FunctorSalad> realToFrac
20:27:16 <Draconx|Laptop> stepkut, with difficulty.
20:27:18 <FunctorSalad> :t realToFrac
20:27:19 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
20:27:28 <FunctorSalad> obviously you'll lose precision
20:27:36 <Draconx|Laptop> sadly, realToFrac fails horribly.
20:27:36 <stepkut> FunctorSalad: yeah, that's fine :)
20:27:41 <edwardk> stepkut: also note that NaN's probably don't carry over, etc.
20:27:47 <Draconx|Laptop> since it does not preserve non-finite values.
20:27:51 <FunctorSalad> if you're lucky there's a rewrite rule that rewrites to bit-fiddling
20:27:53 <edwardk> Draconx: yep
20:27:59 <edwardk> FunctorSalad: nope. not for float and double
20:28:02 <aasmith_> @src signum
20:28:02 <stepkut> k
20:28:02 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:28:07 <FunctorSalad> Draconx|Laptop: why?
20:28:08 <tolkad> Can you use opengl in haskell?
20:28:12 <Draconx|Laptop> FunctorSalad, because it is defined stupidly.
20:28:28 <edwardk> only for Float -> Float, Float <-> CFloat, and Double -> Double and Double <-> CDouble
20:28:29 <FunctorSalad> ah, precisely because it is floatingpoint-agnostic I guess
20:28:41 <FunctorSalad> edwardk: I see
20:28:47 <FunctorSalad> (Float -> Float?)
20:28:49 <Draconx|Laptop> edwardk, for bonus points, those rewrite rules don't preserve semantics.
20:28:59 <edwardk> Draconx: help also well known =)
20:29:01 <edwardk> er yep
20:29:17 <Draconx|Laptop> so you can write code which behaves differently depending on whether the compiler decided to inline or not, yay!
20:29:19 <FunctorSalad> Draconx|Laptop: it does something like fromRat . toRat?
20:29:21 <edwardk> realToFrac is sadly pretty broken
20:29:45 <edwardk> Draconx|Laptop: yeah i wrote a bunch of floating point rounding mode code that cared a lot about inlining as a result ;)
20:29:45 <tolkad> ooh, you can
20:29:46 <Draconx|Laptop> FunctorSalad, yup.
20:29:53 <FunctorSalad> the bit-based conversion doesn't sound like it'd be too hard, just look up the layout on wikipedia =)
20:30:09 <FunctorSalad> you'd truncate the exponent and mantissa seperately, I presume
20:30:16 <Draconx|Laptop> anyway, the better way to convert from Double to Float is to use double2Float# in GHC.Exts (I think)
20:30:24 <FunctorSalad> (and shift to take into account the changed exponent bias)
20:30:34 <FunctorSalad> (shift as in "add")
20:30:38 <edwardk> well, the easy way is to write double f2d (float f) { return (double) f; } -- in c and import it ;)
20:30:47 <FunctorSalad> ah
20:30:52 <Draconx|Laptop> edwardk, sadly, you then have the same problem converting Double to CDouble!
20:30:55 <edwardk> Draconx ah that's the right way
20:30:55 <FunctorSalad> and somewhat more portable probably
20:31:02 <edwardk> Draconx yes but you have rewrite rules there ;)
20:31:08 <Draconx|Laptop> so you need to convert Double to CDouble by unsafeCoerce
20:31:14 <technogeeky> has anyone here done any work involving lots of very, long integers (thousands of digits)?
20:31:18 <edwardk> so you need
20:31:38 <edwardk> doubleToFloat (D# d) = F# (doubleToFloat# d)
20:31:44 <edwardk> technogeeky: yes
20:32:02 <technogeeky> edwardk: what library should I use?
20:32:08 <edwardk> technogeeky: in ghc?
20:32:13 <technogeeky> yes
20:32:23 <edwardk> technogeeky: Integer comes in gmp-integer associated with base ;)
20:32:31 <edwardk> it just works ;)
20:32:38 <technogeeky> no matter how large my integers are? :o
20:32:47 <FunctorSalad> gmp is 'industrial strength'? ;)
20:32:49 <technogeeky> they are the points in a fractal geometry
20:32:55 <edwardk> > 2 ^ 1128 :: Integer
20:32:56 <lambdabot>   364615485029501136970713101143871109540079913994317049087258562868354903436...
20:33:08 <technogeeky> oh i see
20:33:11 <edwardk> FunctorSalad: more so than pretty much any other integer library =P
20:33:49 <FunctorSalad> the ';)' wasn't intended to specify my opinion about the matter, I don't know gmp
20:33:50 <edwardk> technogeeky: ghc's Integer is a thin shim over GMP's integers. it moves them into the garbage collector and optimizes small int sized Integers
20:33:59 <technogeeky> if these points are rational (but not complex!) - that is Integer / Integer - will the picture still look so nice?
20:34:07 <edwardk> @type Rational
20:34:09 <lambdabot> Not in scope: data constructor `Rational'
20:34:12 <edwardk> er
20:34:23 <edwardk> yes
20:34:27 <technogeeky> ok
20:34:37 <edwardk> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Ratio.html
20:34:38 <technogeeky> and once I go into complex, then things will get messy?
20:34:41 <edwardk> uses Ratio Integer
20:34:58 <edwardk> technogeeky: fraid so
20:35:05 <technogeeky> that'll be fine for now
20:35:08 <FunctorSalad> rationals will get larger and larger denominators for similar-magnitude numbers if you add arbitrary data
20:35:11 <edwardk> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Complex.html assumes RealFloat
20:35:24 <FunctorSalad> the exactness has a price :)
20:35:29 <edwardk> which is a fairly asinine historical requirement
20:35:48 <edwardk> there are lots of uses for Complex Int (gaussian integers) or Complex Rational, etc.
20:36:24 <technogeeky> i'm doing work with the apollonian group / fractal (http://arxiv.org/abs/math/0010298)
20:36:37 <edwardk> (understandably so because haskell has a pretty broken notion of abs and signum baked into Num, but still)
20:37:12 <FunctorSalad> (haven't thought it through, but sounds about right if arbitrary = some plausible random distribution)
20:37:14 <wli> There's a Show requirement too in there, no?
20:37:18 <edwardk> technogeeky: i think byorgey might have some diagrams built with that
20:37:22 <Draconx|Laptop> FunctorSalad, re: bit-based conversion, FPUs generally have this manipulation implemented in hardware.  Some care needs to be taken with special values (e.g. simply copying the exponent will not preserve infinities or NaNs).
20:37:32 <FunctorSalad> wli: Nums are show, aren't they
20:37:33 <edwardk> wli: simply via Num
20:37:42 <FunctorSalad> Draconx|Laptop: ah, ok
20:38:00 <FunctorSalad> (and denormalized numbers I suppose)
20:38:08 <edwardk> but the issue with Complex arises because there is a constraint data RealFloat a => Complex a = a :+ a
20:41:20 <wli> Of course via Num; that's where abs and signum come from too.
20:41:58 <technogeeky> :t signum
20:41:59 <lambdabot> forall a. (Num a) => a -> a
20:42:31 <FunctorSalad> Complex won't be fixed?
20:42:55 <wli> H98 will never be fixed, not much of the rest will be either.
20:43:21 <FunctorSalad> you could just copypasta the source file, but that wouldn't work if other people use Complex
20:43:45 <FunctorSalad> wli: hmm GHC'd libs haven't diverged from H98 for Haskell 98 stdlib items?
20:43:54 <Draconx|Laptop> The thing is, I doubt it makes any sense to have "floating point complex" and "non floating point complex" to be the same class.
20:44:05 <Veinor> the numeric prelude sucks, news at 11
20:44:17 <wli> They have, but not in ways that reverse the damage done in the H1.4 -> H98 transition.
20:44:20 <Draconx|Laptop> chances are, if you write a function for "floating point complex", it won't be useful for the other and vice versa.
20:44:27 <Cale> Hmm, are the webchat spambots still a problem?
20:44:40 <wli> monad comprehensions also need ghc patches far too deep for me to comprehend [sic].
20:45:00 <FunctorSalad> Veinor: but deleting a Data constraint would be easier than thinking up a new tower 
20:45:22 <kmc> Veinor, i get all my news from twitter
20:45:55 <FunctorSalad> wli: not sure what they are; if they're like list comprehensions, these are just thin sugar over 'do' notation, aren't they
20:46:04 <catenate> Speaking of Complex, I'd really like for amusement value to show (e ^ (i*τ))
20:46:17 <technogeeky> = 1 + 0?
20:46:26 <catenate> yeah
20:46:41 <Draconx|Laptop> catenate, i*tau?
20:46:43 <c_wraith> > exp $ (0 :+ 1) * pi :: Complex CReal
20:46:44 <lambdabot>   (-1.0) :+ 0.0
20:47:01 <FunctorSalad> show=prove?
20:47:05 <wli> FunctorSalad: I couldn't get up to speed on the ghc internals to build up the values properly.
20:47:11 <technogeeky> [23:41] * Cale_ (63f7aa71@gateway/web/freenode/ip.99.247.170.113) has left #haskell
20:47:11 <technogeeky> [23:41] <FunctorSalad> Complex won't be fixed?
20:47:14 <technogeeky> sorry
20:47:14 <catenate> no, just print it out.  It's pretty.
20:47:31 <technogeeky> exp $ (0 := 1) * 2 *pi ::Compex CReal
20:47:38 <technogeeky> exp $ (0 :+ 1) * 2 *pi ::Compex CReal
20:47:47 <catenate> not pi, pi's a pedagogical disaster ;)
20:47:50 <wli> FunctorSalad: It's not a conceptual issue, just learning ghc internals, API's, etc. well enough to build the expressions/values/etc. properly.
20:48:00 <technogeeky> exp $ (0 :+ 1) * 2 * pi ::Compex CReal
20:48:05 <technogeeky> well
20:48:19 <technogeeky> the best argument is really squaring it as you lift/lower
20:48:22 <FunctorSalad> (the "proof" when using standard definitions is just some argument why you can add the serieses in the naive way, no?)
20:48:30 <technogeeky> squaring the two, that is
20:49:00 <FunctorSalad> (exp => exponential series => sum of sin/cos serieses => use def of pi)
20:49:12 <FunctorSalad> (as a certain zero of the sin series)
20:50:19 <FunctorSalad> wli: hmm can't do it as a -pgmF (haskell preprocessor)?
20:50:33 <kmc> @let π = pi
20:50:34 <lambdabot>  Defined.
20:50:44 <kmc> @let τ = 2*π
20:50:46 <lambdabot>  Defined.
20:50:54 <FunctorSalad> is that standard?
20:51:49 <technogeeky> FunctorSalad: no
20:51:56 <technogeeky> FunctorSalad: http://www.tauday.com
20:52:25 <catenate> not yet ;)
20:52:35 <technogeeky> it will be standard for those who read that
20:52:38 <catenate> it's prettier though
20:52:42 <technogeeky> unless you have a compelling reason not to
20:53:31 <catenate> I always thought it was my fault all the equations around circles didn't seem elegant to me
20:53:33 <wli> FunctorSalad: Preprocessor? What are you talking about?
20:53:42 <FunctorSalad> wastes a precious letter? ;)
20:53:51 <FunctorSalad> (@compelling reason)
20:54:12 <technogeeky> FunctorSalad: well, it could be a keyword. 'tau' as opposed to 'pi'
20:54:13 <tolkad> does haskell have macros like C?
20:54:18 <technogeeky> so you're wasting 1 character that way too
20:54:24 <technogeeky> tolkad: no?
20:54:24 <FunctorSalad> wli:{-# OPTIONS -pgmF bla #-} runs an arbitrary executable as preprocessor
20:54:31 <technogeeky> not like C
20:54:41 <tolkad> why not? that would be cool
20:54:45 <FunctorSalad> wli: or do monad comprehensions need more semantic knowledge?
20:54:48 <wli> FunctorSalad: What are you talking about? Why would that be relevant?
20:54:58 <FunctorSalad> tolkad: yes we do have the mighty CPP
20:55:07 <FunctorSalad> {-# LANGUAGE CPP #-}
20:55:28 <FunctorSalad> wli: I thought you wanted to extend haskell's syntax :(
20:55:28 <wli> FunctorSalad: Monad comprehensions need ghc's list comprehension code to be redone so the types of the internal core expressions are generalized etc.
20:55:53 <wli> FunctorSalad: Preprocessing is a non sequitur.
20:55:54 <FunctorSalad> I meant parsing them yourself and expanding to monad-generic code
20:56:25 <wli> FunctorSalad: The code was there before at some point because monad comprehensions were already there and removed for H98.
20:56:46 <FunctorSalad> wli: why does that make it impossible to do it the way I said with a preproc?
20:56:49 <tolkad> #define PAAMAYIM_NEKUDOTAYIM ::
20:56:50 <tolkad> f PAAMAYIM_NEKUDOTAYIM String -> String
20:57:09 <FunctorSalad> just like you could expand do-notation to >>= and return with a preprocessor
20:57:59 <wli> Preprocessing is the wrong way to do it.
20:58:27 <wli> I vaguely suspect there are problems somewhere.
20:59:09 <FunctorSalad> (btw exp(i*tau) would be one in this case ;))
20:59:10 <edwardk> tolkad: we have a macro system, but it is strongly typed.
20:59:19 <edwardk> tolkad: so 'not like c' but still macros
20:59:36 <technogeeky> FunctorSalad: yes, he also describes it as = 1 + 0
20:59:44 <FunctorSalad> oops, true
20:59:54 <technogeeky> which is more interesting than it seems
21:01:52 <FunctorSalad> it immediately implies e(i*pi) \in {-1,1}, at least
21:02:40 <FunctorSalad> given exp . uncurry (+) = uncurry (*) . (exp***exp) ;)
21:03:49 <kmc> tolkad, people use the C preprocessor with Haskell code sometimes
21:04:12 <kmc> it's common in the standard library, for doing conditional compilation based on compiler version etc.
21:04:26 <FunctorSalad> yeah or when TH is too squeamish
21:04:27 <FunctorSalad> ;)
21:04:33 <kmc> yeah
21:04:39 <FunctorSalad> about splicing in arbitrary syntactic elements
21:04:39 <kmc> some things are far simpler as text macros than as AST macros
21:05:47 <FunctorSalad> (and purity + the type system seems to make CPP a bit less dangerous than in other langs)
21:06:18 <FunctorSalad> (purity making it less likely that you dupe side effects)
21:06:28 <tolkad> #define max(a, b) (a < b ? b : a)
21:07:09 <kmc> tolkad, that macro is weak sauce, i think you should #define פעמייםנקודתיים ::
21:07:30 <shadwick> oh boy, Hebrew in my Haskell
21:07:31 <catenate> tolkad: Where are your parentheses, soldier!
21:09:46 <kmc> Haskell has lots of other forms of abstraction, we don't lean so heavily on metaprogramming as C and Lisp do
21:09:51 <kmc> but it is useful and there are ways to do it
21:10:46 <catenate> Where are Complex and CReal, and why are they still not found when I variously import Data.Complex and Data.Number.CReal?
21:10:59 <FunctorSalad> #define FMAP2(ctor,f) ctor x1 x2 -> ctor (fmap f x1) (fmap f x2)
21:11:27 <FunctorSalad> instance Functor Foo where fmap f x = case x of { FMAP2(Foo1,f) ; FMAP2(Foo2,f) }
21:11:30 <FunctorSalad> :)
21:11:30 <catenate> @hoogle Complex
21:11:31 <lambdabot> module Data.Complex
21:11:31 <lambdabot> Data.Complex data RealFloat a => Complex a
21:11:52 <catenate> @hoogle CReal
21:11:53 <lambdabot> No results found
21:12:54 <FunctorSalad> kmc: or for writing the boilerplate for the other abstractions ;) 
21:13:03 <FunctorSalad> (which are meant to eliminate boilerplate)
21:13:33 <Cale> catenate: I don't know why they wouldn't be found if you were really importing those modules
21:13:44 <catenate> Web hoogle tells me CReal is in numbers-2009.8.9, is that a cabal install?
21:13:54 <Cale> yes
21:13:57 <Cale> cabal install numbers
21:14:04 <catenate> thanks
21:14:15 <tolkad> in PHP you can dynamically include PHP files and treat them as functions, for example, $param = 5;$v = "sqrt.php";$result = include($v); and in sqrt.php: return sqrt($param);
21:14:16 <tolkad> Does haskell have something similar?
21:14:42 <FunctorSalad> did anyone wrap their cabal install in a script that makes a hoogle file and merges it into your default.hoo?
21:14:47 <kmc> tolkad, you can use packages "hint" or "mueval" to interpret Haskell code at runtime
21:14:47 <FunctorSalad> I wanted to do that
21:14:51 <kmc> or call the GHC API directly
21:15:05 <kmc> these things aren't part of standard Haskell, but GHC implements them
21:15:20 <kmc> (and libraries for GHC)
21:15:22 <tolkad> you mean standard haskell doesn't have an eval function?
21:15:32 <kmc> correct
21:15:34 * Cale wonders if it'll be okay to unmute the webchatters
21:15:52 <edwardk> tolkad: there are several packages that provide one, but no, haskell doesn't have eval. neither does c for that matter. ;)
21:15:53 <Cale> Let's give that a try, and see what happens.
21:15:54 <FunctorSalad> first-class function replace the uses of eval as "parameterize behaviour/logic"
21:15:57 --- mode: ChanServ set +o Cale
21:16:10 <kmc> FunctorSalad, sure, but plenty of languages with first class functions come with eval too
21:16:20 <kmc> having first-class functions is the norm, not the exception
21:16:39 <FunctorSalad> there are some cases where you still need eval, sure
21:16:55 <dolio> Are there?
21:17:08 <kmc> in most languages with eval you're advised to use it only when all else fails
21:17:12 <kmc> and GHC Haskell is no exception
21:17:26 <kmc> it is much nicer to compute functions than to compute code
21:17:29 <tolkad> and combined with dynamic function calling by name, it's impossible to compile without including an entire implementation of the language, if either feature is used
21:17:38 <catenate> I have a function that uses Complex and CReal in a module in a file.  In another file, where the module is imported, I also import Data.Complex and Data.Number.CReal.  When ghc compiles the first file, it says :+ and Complex and CReal are not in scope
21:17:53 <FunctorSalad> dolio: recent example: a command-line tool to run sortBy or whatever with an arbitrary haskell function as argument
21:18:01 <FunctorSalad> (on the lines in stdin)
21:18:08 <Cale> er, hmm, is it this one:  *!~55c89673@* ?
21:18:20 <FunctorSalad> (the haskell function to specify the ordering)
21:18:29 <kmc> tolkad, right.  which is why GHC provides its guts as an ordinary Haskell library, which is used by hint and mueval etc.
21:18:36 <FunctorSalad> haven't coded this, but intended to...
21:19:03 <dolio> So, we're essentially talking about a program whose purpose is to call eval?
21:19:15 <kmc> FunctorSalad, sounds like it could be a script which runs ghc -e
21:19:19 <solrize> would be nice to have full fledged staged programming, using the llvm library ;)
21:19:26 <kmc> yes!
21:20:19 <FunctorSalad> (actually the simplest way would be a bash script ghc -e "main = interact (unlines . sortBy ((<=) \`on\` ($*)) . lines)" ;))
21:20:56 <FunctorSalad> kmc: yes
21:21:19 <FunctorSalad> dolio: turns out it is, but the problem wasn't contrived to end up with that specification :)
21:21:44 --- mode: Cale set -b *!~55c89673@*
21:21:45 <FunctorSalad> I guess you'd dump to a tempfile and ghc --make it first for heavier-duty sorting
21:22:29 --- mode: Cale set +b *!~55c89673@*
21:22:41 <Cale> nope, that's not it :)
21:23:06 <FunctorSalad> you'd probably want some expansive list of autoimports for such scripts
21:23:43 <FunctorSalad> (I made a personal one)
21:23:55 <FunctorSalad> but not complete yet :)
21:24:07 * wli doesn't get the critical pairs in F5
21:24:09 <dolio> Not that I'm against hot code loading and such.
21:24:50 <dolio> But 'eval :: String -> IO ()' or whatever isn't my idea of a great implementation, which is about what you get in a lot of languages.
21:24:53 <alexyk> dons: ping
21:25:51 <catenate> It definitely has something to do with the modules: when I move the expression into tho main source code file it works,
21:25:55 <FunctorSalad_> dolio: the alternative solution would be to take some ad-hoc sorting DSL as an argument, forcing the user to learn a new syntax :| 
21:25:58 <FunctorSalad_> (not saying you suggested that)
21:27:39 <Cale> Oh, I see...
21:27:53 --- mode: Cale set -q *!*@gateway/web/freenode/ip.*
21:28:08 <Cale> Let's try that for a while and see if the spammers are still at it
21:28:27 <Cale> I'd generally like to permit webchat if we can help it :)
21:28:33 --- mode: Cale set -o Cale
21:28:43 <Eridius> BONUS: you around?
21:28:53 <ivanm> what does -q do?
21:29:01 <Cale> ivanm: unquiets
21:29:17 <FunctorSalad_> allowing arbitrary logic in a general-purpose lang whereever it makes sense seems to enhance the unix philosophy imho
21:29:21 <Cale> +q makes it impossible for anyone matching that pattern to send text to the channel
21:29:56 <ivanm> preflex: seen BONUS 
21:29:56 <preflex>  BONUS was last seen on #haskell 18 days, 11 hours, 36 minutes and 45 seconds ago, saying: :)
21:30:04 <Cale__> So I should be able to talk from here now...
21:30:05 <FunctorSalad_> (makes the little building blocks even more general, and avoids needing a special flag for everything)
21:30:18 <ivanm> Cale__: what did you say?
21:30:19 <ivanm> :p
21:33:35 <alexyk> I'm reading a map of 5 million ByteString->[(Int,Double}], and lookup one key.  The 3.5 GB map in binary is loaded into 38 GB and takes 8 minutes to lookup with a simple:   bs <- BL.readFile fileName; let g = D.decode . decompress $ bs -- and then ! key.  ???
21:34:16 <ivanm> well, you should be using Map.lookup, not ! ...
21:34:16 <ivanm> :p
21:34:26 <alexyk> sorry, using M.lookup in fact
21:34:40 <Cale> alexyk: How about subsequent lookups?
21:34:42 <ivanm> preflex: seen Baughn 
21:34:43 <preflex>  Baughn was last seen on #haskell 10 hours, 53 minutes and 55 seconds ago, saying: Truly.
21:35:08 <alexyk> Cale: I don't do them, waited for hours in ghci, now do one from a compiled executable.
21:35:27 <Cale> alexyk: Oh! Make sure you use -O2 for anything that big
21:35:34 <alexyk> Cale: is used
21:35:39 <Cale> (or at the bare minimum -O)
21:35:49 <alexyk> and -A5G just for fun
21:36:00 <alexyk> smaller -A doesn't fare better
21:36:09 <Cale> That's a really large map
21:36:20 <Cale> Do you actually have that much memory?
21:36:27 <Cale> Or is it all being swapped out to disk?
21:36:58 <alexyk> it shouldn't load up into 38 GB.  It does fit together with the rest of everything in a proggy which takes 38 GB altogether.  I got 64 GB of RAM.
21:37:00 <Aeacus_> I'm looking through the source code for a package and I see the use $= when assigning a value to something.  What exactly does this operator do?
21:37:02 <Cale> You'd probably be better off doing something more clever with the file here.
21:37:27 <Cale> Like simply building an index from it, and then seeking into it and parsing the bit you're interested in locally.
21:37:29 <alexyk> Cale: I've tried saving a Trie, with similar timing.
21:37:35 <ivanm> @tell Baughn I found my problem; I had -XCPP set as one of ghci's args for haskell-program-name, and it was causing it to read the */ as a closing C comment or something... :s
21:37:36 <lambdabot> Consider it noted.
21:37:48 <Cale> Keeping it all in memory at once seems like too much to ask.
21:38:11 <Cale> Aeacus_: Which package?
21:38:25 <kmc> Aeacus_, probably http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
21:38:26 <Cale> Aeacus_: $= would be something defined semi-locally
21:38:37 <Cale> Aeacus_: yeah, it's probably StateVar's $=
21:38:45 <Aeacus_> Oh okay, thanks.  I'm thinking it may be something to do with Glut, think thats the case?
21:38:48 <kmc> yes
21:38:48 <alexyk> dons says cereal won't help here... why does loading take so long?  I think reading is taking way too much RAM, more than it has to have
21:38:49 <Cale> yeah
21:38:52 <kmc> the OpenGL bindings use StateVar
21:39:01 <Aeacus_> Okay, thanks
21:39:03 <kmc> it's an overloaded update operator which works on IORefs and other similar things, like OpenGL's implicit states
21:39:10 <Cale> So take a look at the doc that kmc linked to. The top explains :)
21:39:18 <Cale> It's basically variable assignment.
21:39:22 <ivanm> alexyk: what are you using for reading? bytestring's strict readFile?
21:39:29 <kmc> well, reference assignment
21:39:45 <alexyk> ivanm: lazy bytestring's 
21:40:22 <ivanm> I wonder if using strict would help...
21:40:26 <alexyk> ivanm: strict ones didn't typecheck with encode/decode
21:40:31 <ivanm> :o
21:40:50 <alexyk> hence I think the whole cereal heresy
21:40:50 <Cale> StateVar values internally contain a way to set something, and a way to get it back again, and $= and get just use those actions
21:41:31 <Aeacus_> Awesome, that makes sense.  Thanks again :D
21:42:13 <Cale> alexyk: What exactly is the file format?
21:42:48 <Cale> alexyk: Could you build a much smaller index of offsets into the file on disk, and then hSeek to them and parse things out as needed?
21:43:13 <alexyk> Cale: Data.Binary... I thought it's fairly fast?
21:43:43 <Cale> alexyk: Well, sure, but the reason for slowness is probably that you don't have enough memory to store the datastructure which is going into the file.
21:43:49 <alexyk> Cale: I wonder how, perhaps.  The whole idea was to check Haskell's standard serialization.  I sure van write back into Tokyo Cabinet and such.
21:44:05 <alexyk> Cale: I did create it in RAM along with 10 other things.
21:44:19 <Cale> So you're probably using virtual memory, unless you have a really big machine.
21:44:21 <alexyk> It takes 3.5 GB uncomressed on disk; 800 M compressed.
21:44:30 <Cale> hmm
21:44:40 <alexyk> Cale: nope, I have 38 GB of actual RAM usage when creating.
21:45:05 <Cale> That's quite a lot of RAM in that machine :)
21:45:33 <alexyk> The IntMap is much faster to lookup; it's only when I disinterned Int back into ByteString key it started to gob RAM upon reading.
21:45:49 <alexyk> Both Map ByteString ... and Trie are slow.
21:45:55 <Cale> alexyk: Oh, I think I can say why.
21:46:01 <alexyk> Map ByteString is a non-starter even.
21:46:03 <dolio> Map is a completely different datastructure from IntMap.
21:46:05 <Cale> Let me check something.
21:46:38 <alexyk> dolio: yeah, so then I tried Trie and it actually finishes in 8 minutes instead of an hour+ ctrl-C'ed... :)
21:47:28 * hackagebot xine 0.0.0.1 - Bindings to xine-lib  http://hackage.haskell.org/package/xine-0.0.0.1 (JoachimFasting)
21:48:24 <Cale> okay, I *think* the problem is that take is O(1) for strict bytestrings, and the lazy bytestring take/splitAt uses the strict one.
21:49:06 <Cale> Why is that a problem? Because it means that those bytestrings you're chopping out of the input are not really copies of bits of the input, but contain references to it.
21:49:39 <Cale> This is just a conjecture, but maybe we can try something to avoid that anyway :)
21:49:43 <alexyk> Cale: Hmm!  So how can this be solved?
21:50:22 <alexyk> I mean I'd perfer to have a self-contaned data structure of searchable (ByteString,someData) pairs.
21:50:57 <Cale> hmm, I seem to remember something which might have been helpful in the .Internal library, but it's no longer documented?!
21:51:02 <alexyk> I currenlty intern ByteStrings into Int and keep a dictionary and disintern upon writing; I may write Int still and always read the dictionary back and disintern, but that's cheating against OCaml.
21:51:25 <Cale> oh, no, it's in the high level interface
21:51:32 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/bytestring-0.9.1.6/Data-ByteString-Lazy.html#24
21:51:37 <Cale> copy :: ByteString  -> ByteString
21:51:50 <alexyk> all languages must end up with a data structure with string, the original Twitter user name, and its numerical features computed.
21:52:07 <Cale> Try sticking that in for each of the bytestrings which you're sticking into your map.
21:52:26 <Cale> (i.e. don't stick in the original parsed bytestring, but copy of it)
21:52:56 <Cale> No guarantees, but it just *might* help :)
21:53:15 <alexyk> Cale: do you mena when creating the map/trie, before writing it to disk?
21:53:31 <alexyk> because I don't stick anything anywhere when reading back
21:53:41 <Cale> eh?
21:54:04 <Cale> I thought you were parsing a file from disk and turning it into a  Map ByteString ...
21:54:32 <Cale> (and this was using much more memory than expected)
21:54:33 <alexyk> Cale: it's either a Map ByteString or a Trie dumped with Data.Binary
21:54:50 <Cale> It's not the writing to disk which is causing problems, is it?
21:55:17 <alexyk> Cale: write is reasonably fast, although Trie's is slower than Map ByteString's by 10 minutes.
21:55:25 <alexyk> It's all damn slow.
21:55:40 <Cale> I'm saying that however you get the keys into the Map, make sure you're putting copies of the keys, not the bits chopped from the input.
21:56:12 <Cale> Because if you do that, it means that the big input file can't be garbage collected
21:56:36 <Cale> (the little bits you're chopping out of it are holding references to it)
21:58:12 <alexyk> Cale: so I have a Trie; now I call Data.Binary.encode on it, and that's written to disk with Lazy.ByteString.writeFile.  Where do I have to inject copy?  when creating the Trie?
21:58:21 <Cale> Trie?
21:58:34 <Cale> I thought we were talking about Map ByteString :)
21:58:35 <alexyk> Cale: yeah.  It's now a Trie. :)
21:58:37 <Cale> okay
21:58:45 <alexyk> Map ByteString was damn slower.
21:58:48 <Cale> Which Trie library?
21:58:52 <alexyk> Data.Trie
21:59:04 <Cale> bytestring-trie?
21:59:07 <alexyk> package bytestring-trie, yes
21:59:31 <ivanm> did you have a look at edwardk's ropes library?
21:59:45 <Cale> okay
21:59:56 <alexyk> ivanm: me?
22:00:00 <ivanm> yes, you
22:00:08 <ivanm> his is ropes, there's also Data-Rope
22:00:13 <Cale> So yes, when you use the strings from the file as keys, adding to your trie, you want to apply copy to them
22:00:39 <alexyk> Cale: the file is a binary dump of a Trie... do I need to apply copy when creating the Trie?
22:00:50 <alexyk> ivanm: are ropes for writing?
22:01:15 <Cale> er, oh, so you're just using the Binary instance?
22:01:25 <ivanm> yeah, they're basically tires on bytestrings IIRC
22:01:57 <dh__> Good evening, when I'm trying to install strict-concurrency, I got the following error message : Could not find module `Control.OldException':
22:01:57 <dh__>       it is a member of the hidden package `base'
22:01:59 <dh__> any help ? 
22:02:02 <alexyk> Cale: here's how the Trie is created: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26862#a26862
22:02:27 <Cale> dh__: hmm, that kind of sounds bad
22:02:50 <dh__> Cale: why ? 
22:03:05 <ivanm> dh__: are you using base-3 or base-4?
22:03:15 <ivanm> it sounds like you want to use base-4 but you're telling it to use base-3
22:03:25 <alexyk> Cale: yep.  I load back a Binary dunmp of Trie with decode . readFile and it takes 8 minutes of CPU, not much IO.
22:03:32 <dh__> no idea on what is base-3 or base-4
22:03:40 <Cale> alexyk: Oh, okay, that's easy then, (though the bang patterns are a bit weird :)
22:03:52 <dh__> I didn't specify base-3 or 4 anywhere.
22:04:08 <alexyk> Cale: dafis banged every statement in my proggy! :)
22:04:16 <ivanm> dh__: 0.2.3 ?
22:04:21 <Cale> alexyk: :P
22:04:27 <Cale> alexyk: They aren't always a good idea.
22:04:39 <alexyk> ivanm: tires on bytestring!  pimp my lay bytestrings! :)
22:04:41 <dh__> strict-concurrency go 0.2.3 by it self. 
22:04:44 <alexyk> lay
22:04:47 <alexyk> lazy
22:04:49 <alexyk> z sticks
22:05:29 <alexyk> will look at ropes... for now wonder what's wrong with bytestring Trie
22:06:05 <alexyk> Cale: I hate the bangs as now I have to think where to add them.  It's almost like I have to write the code twice.
22:06:15 <alexyk> I'd much prefer not to think about it
22:06:28 <ivanm> dh__: which version of GHC?
22:06:34 <ivanm> but it looks like dons stuffed up again...
22:06:40 <Cale> alexyk: Usually you write the code without bangs, and only add one or two when you really need them
22:06:47 * alexyk thinks __ in nicks is a bad idea
22:06:47 <ivanm> since AFAIK, OldException needs ghc-6.10 at least
22:06:54 <dh__> ivanm: ghc 6.10.4
22:07:04 <ivanm> it should wrok...
22:07:07 <Cale> alexyk: GHC is even smart and figures out the most obvious ones on its own
22:07:20 <dh__> ivanm: I work with a mac 
22:07:26 <alexyk> Cale: I want to remove the bangs from my proggy one by one and see what happens
22:07:27 <ivanm> what do you mean, alexyk________ ?
22:07:28 <ivanm> :p
22:07:29 <Cale> alexyk: But whatever, change the 'name' in T.insert name to (copy name)
22:07:39 <ivanm> dh__: AFAIK that's irrelevant
22:07:41 <alexyk> i___van_____________________________m: noth' special
22:07:48 <ivanm> what are you using for this? cabal install?
22:07:58 <Cale> alexyk: and see if that helps at all
22:08:00 <catenate> Yay! Figured out that I'm allowed to put import *after* module, and that this will make names visible to the code in the module.
22:08:12 <dh__> ivanm: yes : cabal install strict-concurrency
22:08:18 <ivanm> catenate: well, you're not allowed to put it _before_ module...
22:08:24 <alexyk> Cale: OK!  we'll see.  It'll take a half hour to run and create it, so will report after the holidays!
22:08:27 <catenate> yes, that makes a new main
22:08:28 <dh__> ivanm: I'm trying to install happstack 
22:08:42 <ivanm> dh__: seems to work here :s
22:08:42 <Cale> alexyk: Sorry I can't give you much more detail than that.
22:08:51 <ivanm> dh__: did it say anywhere what version of base it was trying to use?
22:08:52 <alexyk> Cale: that's something to work with already!
22:08:59 <alexyk> + will look up ropes
22:09:02 <catenate> I thought maybe the including file set up imports for it or something
22:09:12 <alexyk> edwardk seems to have a golden touch -- hope it's fast!
22:09:13 <catenate> but now I understand for great good.
22:09:29 <Cale> alexyk: How many keys are there?
22:09:35 <ivanm> alexyk: Data-Rope seems to have a simpler interface though
22:09:36 <alexyk> Cale: 5 million
22:09:39 <Cale> hmm
22:09:48 <alexyk> a small map eh
22:09:49 <dh__> ivanm: no, 
22:09:53 * wli has developed the reverse Midas touch
22:09:56 <ivanm> preflex: seen Igloo 
22:09:56 <preflex>  Igloo was last seen on #ghc 1 day, 13 hours, 42 minutes and 59 seconds ago, saying: http://www.catb.org/~esr/jargon/html/Z/Zawinskis-Law.html
22:10:05 <alexyk> wli: I know what you mean
22:10:22 <Cale> alexyk: If the IntMap was fast enough, you might consider splitting it into a Map ByteString Int and an IntMap
22:10:28 <dolio> You can animate gold statues?
22:10:39 <Cale> alexyk: Not sure if that would be any better.
22:10:57 <Cale> alexyk: Doesn't seem like it would be, but...
22:11:01 <wli> More like everything touched turning to fecal matter instead of gold.
22:11:44 <edwardk> i do?
22:12:10 <alexyk> edwardk: I want to believe it, since my son is also Edward K. :)
22:12:17 <ivanm> edwardk: you do when you finally get around to releasing your package... ;-)
22:12:21 <ivanm> *packages
22:12:23 <alexyk> (but he's just 2 years old :)
22:12:24 <edwardk> alexyk: heh
22:13:21 <edwardk> still hacking on luthor. i almost have alex's internals cleaned up so they feel like something written in the last 5 years.
22:13:32 <dh__> I solved it by install an older version . thanks guys. 
22:13:52 <ivanm> edwardk: what's luthor?
22:13:58 <edwardk> it is nice what you can do when you scrap backwards compatibility ;)
22:14:06 <ivanm> dh__: maybe send dons a bug report about this
22:14:08 <ivanm> edwardk: heh
22:14:22 <alexyk> Cale: where should I get copy?  Since I use Data.ByteString.Char8, from there?
22:14:23 <edwardk> ivanm: a lex/alex clone implemented as a quasiquoter
22:14:35 <Cale> alexyk: yes
22:14:39 <edwardk> ivanm: so you can scrap the need for an external tool for writing fast lexers
22:14:50 <ivanm> edwardk: I wonder if parsec-3's compatability stuff was one reason it was never as popular (as that's how it was obvious that it was much slower)...
22:15:00 <edwardk> i've been working on adding unicode lexing while i'm at it
22:15:21 <edwardk> ivanm: well, they've since fixed the speed issues
22:15:26 <ivanm> yeah
22:15:37 <edwardk> but it picked up a pretty bad reputation in the meantime
22:15:39 <edwardk> =(
22:15:39 <ivanm> now, if only john macfarlane removed the restriction on parsec from his packages...
22:17:04 <edwardk> all of this is a shame because i'd wanted to use parsec inside of luthor for the quasiquoter. to get rid of the fairly heavy happy/alex dependencies
22:17:14 <Cale> alexyk: Note that most of the time is probably not spent doing the lookup, but creating the map because the lookup was done
22:17:38 <ivanm> edwardk: well, why don't you?
22:17:49 <alexyk>  Cale: yeah, it's reidiculously big in RAM, so it spweing garbage
22:17:54 <FunctorSalad_> edwardk: weren't they merely binary dependencies?
22:17:55 <edwardk> ivanm: well, its tricky parsec 2 locks out half the community parsec 3 locks out the other.
22:18:03 <FunctorSalad_> thought they were harmless compared to build-deps :)
22:18:08 <edwardk> FunctorSalad_: they are, but they also warp the internals quite a bit
22:18:11 <FunctorSalad_> (no version problems)
22:18:14 <ivanm> edwardk: well, you _can_ have both installed...
22:18:19 <alexyk> well I have the copy going, will see after the 4th of July holidays
22:18:32 <Cale> alexyk: It's not unsurprising for things to be a lot bigger in memory than flattened onto disk.
22:18:45 <edwardk> i did split out http://hackage.haskell.org/package/charset/ so if nothing else i'll get a usable character set type out of this excursion ;)
22:18:49 <ivanm> edwardk: I just find it a little strange that because debian doesn't have parsec-3, john macfarlane dictates that pandoc, etc. can't use it despite performance being fixed :s
22:18:58 <Cale> alexyk: There are a *lot* more indirections to take care of here. :)
22:19:49 <alexyk> Cale: but it was smaller when I wrote it, unless the 38 GB was all that -- since the trie is a result of a huge compute; which stayed at 38 GB well before it was supposed to have been created, unless it all worked backward from there; yet I have the bangs everywhere...
22:20:17 <edwardk> er without haddocks on there. perhaps http://github.com/ekmett/charset/blob/master/Data/CharSet.hs is a more useful link
22:23:09 <FunctorSalad_> . o O ( there's also the option of inlining modded versions of packages )
22:23:17 <FunctorSalad_> not sure how bad that is
22:23:45 <edwardk> FunctorSalad_: re happy/alex?
22:23:53 <FunctorSalad_> (darcs might make the divergence problem less of a prob)
22:24:12 <FunctorSalad_> edwardk: it was triggered by ivanm's statement, but might apply to your situation too :)
22:24:40 <ivanm> FunctorSalad_: you mean copying the source files of one project into another?
22:24:42 <ivanm> *shudder*
22:24:49 <edwardk> i wonder if i can just make my parsec dependency broad enough that i can use either 2 or 3 interchangeably
22:25:00 <FunctorSalad_> <4chan hat> Do It
22:25:04 <FunctorSalad_> (ivanm)
22:25:19 <ivanm> @slap FunctorSalad_ 
22:25:19 * lambdabot pulls FunctorSalad_  through the Evil Mangler
22:25:28 <ivanm> edwardk: if you only use parsec-2 features, then sure
22:25:30 <dh__> anybody working in haskell as a full time job here?
22:25:32 <ivanm> no problem with that
22:25:40 <ivanm> dh__: dons, dcoutts_, etc. do
22:25:56 <ivanm> wait, dons does some non-Haskell stuff IIRC...
22:25:57 <FunctorSalad_> but is it so bad really as long as you track your changes in darcs?
22:25:58 <dh__> galois.com?
22:26:07 <FunctorSalad_> and give credit, of course
22:26:46 <ivanm> dh__: yeah, and dcoutts_ is in Well-Typed
22:27:01 <ivanm> edwardk uses some Haskell, as does chrisdone
22:27:11 <ivanm> FunctorSalad_: tracking changes can be a pain
22:27:32 <Cale> dh__: I am (though I have flexible hours), along with blackh, kmc, RyanT5000, pastorn, and some others I don't remember the IRC nicks of :)
22:27:36 <FunctorSalad_> hmm, should be a simple 'darcs pull' as long as they don't overlap
22:27:44 <ivanm> and embedding libraries is a PITA for downstream (see how much trouble distros are having with the various embedded libraries in firefox, etc.)
22:27:51 <FunctorSalad_> (porting changes)
22:27:53 <sshc> Which Haskell shells exist?
22:28:12 <ivanm> FunctorSalad_: well, for starters pandoc uses git... ;-)
22:28:29 <edwardk> dh__: i do some haskell consulting, so do the tupil guys and well-typed and of course there are a number of haskell-based companies: galois, bluespec, and a number of departments in the financial sector that use it
22:28:33 <ivanm> sshc: as in replacements for bash, etc.? there are a few like lambdashell, but none of them are ready for use yet AFAIK
22:29:16 <FunctorSalad_> hashell is unmaintained and incompatible with current ghc, iirc
22:29:19 <FunctorSalad_> @ sshc ivanm
22:29:27 <sshc> A haskell shell would seem very convenient to use
22:29:33 <FunctorSalad_> sshc: I'd be interested in making one too
22:29:38 <Cale> sshc: If you want to write shell scripts in Haskell, maybe try HSH
22:29:48 <FunctorSalad_> (which doesn't mean I have the time for it with good conscience ;))
22:29:48 <ivanm> araujo was working on one (lambdashell I think)
22:29:51 <sshc> Being able to write short an consise filtering options, such as "filter", and so forth
22:30:13 <Cale> Haskell doesn't seem to me to be ideal for user commandline interaction of the sort that bash provides, for example
22:30:15 <sshc> Preferrably a shell that can do both, but specifically I'm asking for interactive shells.
22:30:23 <Cale> But it's pretty good for shell scripting.
22:30:30 <FunctorSalad_> sshc: yeah, bash+a sane lambda is what I find promising too
22:30:30 <sshc> Is there a list?
22:30:54 <ivanm> well, if you just want to write a script, write a one-module program and bang #!/usr/bin/runhaskell on the top
22:30:59 <FunctorSalad_> Cale: I'm considering a preprocessor that makes stuff strings by default
22:31:05 <FunctorSalad_> with haskell escaped
22:31:07 <Cale> The tricky part is in making executable files available as values.
22:31:20 <FunctorSalad_> (maybe a bit of smartness about it, not sure)
22:31:20 <Cale> hmm
22:32:06 <FunctorSalad_> haskell seems like it'd be a step forward even if you 'bash up' the syntax ;))
22:33:52 <Cale> On the front of shellscript-like tasks, I wrote a silly little tool for making sure I have the latest bus schedules, since my city doesn't make them available as a single nice package, and instead has lots of separate PDF download links. Just threw a bit of tagsoup and some curl bindings at it. :)
22:34:00 <sshc> I still think it'd be a lot more convenient, especially for less trivial tasks.  I often find writing short haskell scripts (with runhaskell) faster and more stable than bash scripts, although I still might use some more complex bash on the command line to get the inptu and to  process the output
22:34:59 <sshc> Maybe "unwords . map (foo:) . words", or such
22:35:40 <kmc> i had this crazy idea once
22:35:56 <kmc> where each shell i spawn would be paired with a backgrounded ghci-like process
22:36:18 <kmc> and there would be shell commands to pipe data into and out of Haskell bindings in that interpreter
22:36:27 <Cale> One of the things which I like to do from time to time in bash is to use tools like sed to turn output from one command into a sequence of bash commands (which I can inspect), and then pipe that into bash :)
22:36:48 <kmc> nice technique Cale
22:37:45 <sshc> kmc: That'd sounds very convenient
22:37:50 <Cale> There are also nice tricks you can play with fifos to get fixpoint-like behaviour from pipelines
22:37:54 <sshc> Now, I'm not as familiar with shell scripting as most of you are.
22:38:15 <Cale> Which is something I used when I wrote an IRC bot essentially as one really long bash pipeline
22:38:26 <Cale> (broken into a few scripts)
22:39:06 <solidsnack> Cale: How does the fixpoint stuff work?
22:40:05 <Cale> solidsnack: I just mean you pipe the output of the last command in your chain into a fifo, and have the first command reading from that fifo.
22:40:20 <solidsnack> Oh.
22:40:42 * kmc wonders if you can do that in bash without naming the fifo
22:40:55 <kmc> i wouldn't be surprised if there were an obscure redirection operator for it
22:40:57 <Cale> In my case, I had netcat reading from a fifo (and writing everything it got over the network), and then the output from netcat was being fed to a bunch of processing to determine the output of the bot which was plonked into the fifo at the end
22:41:11 <Draconx|Laptop> kmc, depends on what you consider naming.
22:41:15 * hackagebot hS3 0.5.3 - Interface to Amazon's Simple Storage Service (S3)  http://hackage.haskell.org/package/hS3-0.5.3 (GregHeartsfield)
22:41:24 <solidsnack> I am working with a friend to create shared objects from Haskell. When we try to link it, though, we get the error `undefined symbol: stg_newByteArrayzh', as mentioned in this ticket: http://hackage.haskell.org/trac/ghc/ticket/3807
22:41:25 <Draconx|Laptop> kmc, bash implements most of its fancy redirections by named pipes.
22:41:49 <solidsnack>  Does this mean we should rebuild GHC?
22:41:51 <kmc> Draconx|Laptop, i mean without making a named pipe on a filesystem somewhere.  user-wise; i don't care how bash implements it
22:42:17 <alexyk> Cale: so how can ByteString, unless copy'ed, take references with it to its serialized grave?
22:42:32 <Draconx|Laptop> kmc, the point is that you, as the shell operator, have access to these names.
22:42:36 <alexyk> so they'll mess us up upon decoding?
22:42:43 <Draconx|Laptop> kmc, so you can pass them around.
22:43:10 * alexyk surmises that death is just serialization for subsequent decoding
22:43:20 <alexyk> by the HOFs
22:43:46 <alexyk> "Master Yu was decoded into a seventh level being"
22:43:52 <Cale> alexyk: My only concern is that if you do something like, say, splitAt 5 xs where xs is a ByteString, then the two pieces you get back are *not* two completely new bytestrings
22:43:59 <Draconx|Laptop> kmc, so the line between "named pipe made by the user" and "named pipe made by the shell" doesn't really exist.
22:44:06 <Cale> alexyk: They are references back to the bytestring which you cut up.
22:45:02 <alexyk> Cale: so we do that to the Trie when we create it' but won't any Trie be saved on disk so any refs are gone?
22:45:51 <alexyk> unless the ByteString Binary instance somehow preserves the references...
22:45:53 <Cale> alexyk: Again you told me the problem was when you read the Trie back into memory and tried to index from it
22:46:03 <alexyk> Cale: yep
22:46:13 <Cale> alexyk: My concern is that the big input string is being retained by each key
22:46:18 <gwern> Cale: what I like to do is throw a bunch of file names into emacs, and then turn it into a bigass script using macros
22:46:30 <gwern> I can transform them stepwise quite easily
22:46:31 <alexyk> so the creation is before.  The copy will be employed before encode...
22:46:35 <Peaker> gwern, or use a macro on a dir-ed buffer
22:46:47 <gwern> Peaker: dired and I don't really get along
22:46:59 <Cale> alexyk: Yeah, during parsing of the file on disk
22:47:33 <Peaker> gwern, I like dired
22:47:40 <gwern> I like wdired a lot though
22:47:43 <alexyk> Cale: the Trie creation you've seen is how it's made in RAM; then I call writeFile . encode $ onIt.
22:47:45 <edwardk> gah, parsec 2 needs Applicative ;)
22:47:48 <alexyk> so why do we copy?
22:47:55 <gwern> even though my wdireds seem to be stupid about what happens when filenames collide
22:49:34 <Cale> alexyk: Is the memory problematic on read or on write?
22:49:50 <alexyk> Cale: memory is bad on read
22:50:03 <Cale> alexyk: Right, so ignore the writing.
22:50:25 <alexyk> Cale: meaning copy won't do us any good?
22:50:31 <Cale> ???
22:50:32 <Cale> no
22:50:41 <Cale> copy wouldn't do you any good if you were writing
22:51:15 <Cale> But you're reading the thing in, and this creates a gigantic lazy bytestring at the same time as it's creating the map
22:51:23 <Cale> yeah?
22:51:40 <Cale> You want that lazy bytestring to be garbage collected as it is consumed
22:51:50 <Cale> or else the whole point of it being lazy is wasted
22:52:07 <Peaker> I wonder if our wishes of the GC, which are sometimes critical can be encoded in the code properly
22:52:08 <Cale> and you end up with lots of memory consumption hanging on to it as well as all the structures you're building
22:52:43 <Cale> So you need to ensure that you're not hanging on to references to the beginning of that lazy bytestring
22:52:55 <Cale> only to the part of it you haven't parsed yet
22:53:03 <Cale> so that the GC can come along and collect the beginning
22:53:05 <alexyk> Cale: when reading, I do nothing but decode . readFile
22:53:06 <Cale> make sense?
22:53:15 <Cale> Yeah, that might be the problem
22:53:38 <Cale> Because the instance of decode for Trie doesn't copy the bits of bytestring that it reads
22:53:51 <Cale> It keeps references into the original ByteString that you're parsing.
22:54:05 <Cale> and that *might* be the problem
22:54:07 <alexyk> Cale: ah ok; so I need to hack the Trie read instance?
22:54:34 <Cale> the decode instance, yeah
22:54:36 <alexyk> or, Trie Binary instance's get
22:54:39 <Cale> yeah
22:54:41 <Cale> exactly
22:54:49 <Cale> Just copy the code for it from the library
22:54:55 <Cale> and give it another name :)
22:56:44 <Cale> and then you can apply runGet to that to get an equivalent of decode
22:57:12 <Cale> runGet modifiedGet . readFile
22:58:37 <Cale> oh, oops
22:58:42 <Cale> that may be a problem...
22:59:00 <alexyk> hmm -- I can't see any Instance in bytestring-trie... where does its Binary instance live?
22:59:03 <Cale> since Trie doesn't export its constructors
22:59:05 <dolio> Cale: If the file is 3.5 gigabytes, it doesn't make much sense to me that hanging on to references to the lazy byte string would blow up to 38 gigabytes.
22:59:20 <alexyk> ah found it, nm
22:59:26 <Cale> dolio: Well, okay
22:59:30 <alexyk> Internal.hs
22:59:52 <Cale> dolio: That is true.
23:00:33 <alexyk> Cale: if I write a modified instance Binary a => Binary (Trie a) where... in the end of my program where I need it, will it shadow the original?
23:01:28 <alexyk> dolio: dons said something about me constructing the [(Int,Double)] list in the values; yet it reads back as a simple, well, (Int,Double) list.
23:01:37 <alexyk> with numbers in it, nothing else...
23:02:33 <Saizan> alexyk: no, but you can define your own Get action and use that explictly
23:02:48 <Saizan> and Put correspondingly
23:03:44 <alexyk> Saizan: with runGet as Cale says?
23:03:54 <alexyk> what about constructor not exported?
23:04:09 <alexyk> do I have to end up with MyTrie?
23:04:37 <krainboltgreene> If Haskell had a more simplistic syntax I'd use it.
23:04:42 <wavewave> hi, I have a question. 
23:04:43 <Cale> alexyk: Before it comes to that, you'd just add it to the bytestring-trie code :P
23:05:12 <Cale> krainboltgreene, wavewave: what seems to be the problem?
23:05:26 <alexyk> Cale: and cabalize as some x.y.z.q with bumped q?
23:05:45 <wavewave> is there any generalization of unionWith of Data.Map with Monad?  
23:05:46 <alexyk> krainboltgreene: use Clojure!
23:05:59 <krainboltgreene> alexyk: I am :)
23:06:05 <alexyk> krainboltgreene: me too! :)
23:06:37 <alexyk> krainboltgreene: it's not lazy enough for ya?
23:06:47 <krainboltgreene> alexyk: Which?
23:07:14 <wavewave> I mean unionWithM :: (Ord k, Monad m) => (a->a-> m a) -> Map k a -> Map k a -> m (Map k a)
23:07:31 <alexyk> krainboltgreene: guess!
23:07:41 <krainboltgreene> alexyk: What? :(
23:07:50 <alexyk> (which is lazier?)
23:08:18 <wavewave> my union function is being performed in IO monad
23:08:21 * alexyk wonders if there's anything lazier than Haskell, barring Manatee the Cat
23:08:30 <Cale> wavewave: That's an interesting idea, except that the effects would run in a somewhat unpredictable order according to the hedge union algorithm
23:08:44 <krainboltgreene> Ruby is syntactically lazier, as far as I can tell.
23:08:47 <ivanm> alexyk: IIRC there's an esoteric OS that never does what you tell it to...
23:08:52 <gwern> syntactically lazier?
23:09:04 <alexyk> ivanm: you mean Windows 7?
23:09:05 <wavewave> Cale: hmmm, unpredictable order.... 
23:09:20 <ivanm> alexyk: heh, no
23:09:22 <alexyk> gwern: that's a good riposte
23:09:28 <Cale> wavewave: Well, I don't know how unpredictable...
23:09:40 <kmc> krainboltgreene, really? of all the obstacles to learning and using Haskell, i think syntax is pretty minor
23:09:41 <aasmith_> what function will tell me if a list contains a given value?
23:09:43 <gwern> alexyk: iirc, there's one evaluation strategy for haskell which guarantees that a value will only be evaluated only once. however no one uses it because the memory usage is obscene
23:09:47 <kmc> krainboltgreene, what do and don't you like about the Haskell syntax?
23:09:48 <Cale> wavewave: But union isn't straightforward as it is.
23:09:53 <gwern> aasmith_: elem?
23:10:00 <alexyk> ok, I'm baffled by the slow lookup where ocaml flies and leave it at that for now! :)
23:10:04 <Cale> wavewave: That is, it's not just inserting the keys one at a time from one map into the other.
23:10:09 <aasmith_> gwern, thanks.
23:10:09 <wavewave> Cale: Yeah.. In fact, I was looking at the source code of Data.Map
23:10:21 <alexyk> happy 4th everybody!  do prefer BBQ to bits!
23:10:48 <ivanm> alexyk: huh?
23:10:52 <gwern> 4th of july? pfft, that was yesterday
23:10:54 <gwern> old news
23:11:06 <kmc> happy Independence Day (US), Thank God We Got Rid Of Them Day (UK)
23:11:08 <ivanm> oh, right, this is another case of a yank thinking everyone cares about their specific national holidays/events/news...
23:11:09 <ivanm> ;-)
23:11:12 <ivanm> kmc: lol
23:11:18 <krainboltgreene> kmc: On a very basic level it's simple and understandable by me, but then when things start getting complex it's like a jumble of characters.
23:11:31 <ivanm> kmc: the USA ambassador to Australia said that we were better allies than USA&UK becuase we've never fought each other in a war
23:11:40 <krainboltgreene> I realize a lot of this comes from just general practice/understanding, but I don't remember having the same problem with Clojure/Ruby/Python.
23:11:48 <kmc> yeah
23:11:54 <kmc> Haskell has lots of user-defined operators
23:11:58 <kmc> and lots of operator overloading
23:12:20 <kmc> hehe ivanm
23:13:04 <wavewave> Cale: then, for ordered list, is there something similar?
23:13:07 <krainboltgreene> For instance, the first page of LYAH. Up until the latter half of List Comprehension it all makes awesome sense.
23:13:20 <Cale> krainboltgreene: The syntax is a little different from what you might be used to, and certainly more involved than most lispy things (though common lisp has lots of craziness when you really look)
23:13:41 <Cale> But I find that Haskell's syntax ends up having a certain feeling of simplicity to it
23:13:53 <kmc> to some degree Lisp just passes the buck on syntax -- sure, you have this very regular concrete syntax of S-exprs, but now you have a bunch of special forms to learn
23:14:12 <krainboltgreene> True.
23:14:29 <gwern> let confuses me all the time. I just can't get the parens right
23:14:31 <kmc> i like the Lisp approach to syntax; I can't say as I know enough CL to judge its special forms
23:14:44 <kmc> Clojure's syntax is interesting too
23:14:50 <kmc> as a relatively conservative extension of Lisps'
23:14:57 <krainboltgreene> The building of functions on functions in Haskell makes me flutter with lurv, but even just watching #haskell during the day throws me for a loop.
23:15:16 <kmc> krainboltgreene, i can't find the LYAH section you refer to
23:15:16 <Cale> krainboltgreene: There's a lot of crazy stuff people talk about here which you don't really have to know ;)
23:15:20 <kmc> hehe
23:16:00 <krainboltgreene> kmc: http://learnyouahaskell.com/starting-out#babys-first-functions FIND: let nouns = ["hobo","frog","pope"] 
23:17:21 <Cale> krainboltgreene: yep
23:17:30 <Cale> krainboltgreene: Need help parsing that?
23:17:36 <kmc> yeah, we tend to golf things past readability here, for sport
23:17:45 <Cale> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns] -- this?
23:18:18 <kmc> i suspect that there's a distinct "accent" recognizable in code of people who are regulars here
23:18:22 <Cale> It should be read as: the list of values adjective ++ " " ++ noun where adjective is chosen from the list adjectives, and noun is chosen from the list nouns
23:18:33 <krainboltgreene> Carefully looking at it I get it, but that first glance.
23:18:38 <kmc> if someone says (f .) . g, dollars to donuts they learned it from @pl
23:19:12 <kmc> krainboltgreene, i'm curious if you prefer the "do" version of that:
23:19:26 <kmc> do { adjective <- adjectives; noun <- nouns; return (adjective ++ " " ++ noun) }
23:19:29 <Peaker> I prefer the SEC version of that
23:19:32 <kmc> (though it will look better with layout)
23:19:37 <Peaker> (result . result) f g
23:19:44 <krainboltgreene> Now that makes perfect sense on the first spot.
23:19:48 <Peaker> Apply f to the result of the result of g
23:19:51 <krainboltgreene> Proooooobably due to my use of Ruby/Python.
23:20:05 <kmc> krainboltgreene, that's interesting; Python tends to make a big deal of list comprehensions
23:20:10 <kmc> they're considered "Pythonic"
23:20:23 <Peaker> Generator comprehensions now
23:20:26 <kmc> the concrete syntax is Python is different (more keywords, less punctuation) but the abstract syntax is very close
23:20:28 <kmc> yeah, those too
23:20:34 <kmc> and dict comprehensions in Py3k :)
23:20:40 <krainboltgreene> Although it'd make more literal sense to say: do { adjectives -> adjective; nouns -> noun; return (adjective ++ " " ++ noun) }
23:20:45 <Cale> I forget the difference between python's list comprehension syntax and Haskell's, except that they had keywords for | and <- which I forget :)
23:20:54 <Peaker> kmc, I miss Python's explicit "if" in Haskell's list comps... 
23:21:04 <kmc> Peaker, what do you mean
23:21:12 <Cale> krainboltgreene: That was supported for a while in the GHC parser, but they removed it for some reason :(
23:21:18 <krainboltgreene> D:
23:21:27 <Peaker> In Haskell, [x | x <- [1..10], even x]  In Python: [x for x in xrange(10) if even(x)]
23:21:28 <kmc> krainboltgreene, perhaps.  but people want "do" to also look like standard imperative code, where you write "x = e" to evaluate e and assign to x
23:21:47 <kmc> krainboltgreene, and most imperative languages write assignment in that order -- though not all!
23:21:55 <Peaker> kmc, I find "let" somewhat redundant, especially in "do" blocks myself
23:22:05 <kmc> Peaker, ah.  as a syntactic marker that a conditional follows, you mean
23:22:06 <kmc> makes sense
23:22:07 <Peaker> I guess only in "do" blocks :)
23:22:17 <Cale> Right, for and in :)
23:22:24 <kmc> i use "let" a lot in do blocks
23:22:33 <c_wraith> so do I
23:22:42 <Peaker> kmc, I mean the keyword "let" is redundant to the assignment operator that's right there
23:22:46 <kmc> oh
23:22:49 <Peaker> I'm not saying it's not a useful thing
23:22:52 <Cale> I often find that I'll prefer list comprehensions when they fit on one line, and do-blocks when they don't.
23:23:08 <kmc> you'd rather «do { x = e; ... }» meant «do { let x = e; ... }» ?
23:23:18 <Peaker> kmc, Yeah
23:23:23 <kmc> yeah Cale
23:23:30 <ivanm> Peaker: so automagic let lifting?
23:23:34 <kmc> a problem with a long list comprehension is that it doesn't flow in the right order
23:23:45 <kmc> "do" binds variables one at a time, then uses them in the final result
23:23:49 <Peaker> ivanm, not sure what that means.. Have = in do block statements imply the "let" meaning
23:23:54 <Cale> Peaker: That does make recursive groups a little less clear
23:24:04 <kmc> if you needed recursion, you could write keyword
23:24:08 <krainboltgreene> http://dpaste.com/214401/
23:24:08 <Cale> (though admittedly they are not very common)
23:24:09 <ivanm> Peaker: that's kinda what I meant, yeah
23:24:18 <kmc> or we can use DoRec for it
23:24:24 <Peaker> I admit I haven't thought out all the consequences :)
23:24:25 <ivanm> Peaker: I find that using let helps emphasise that "hey, this bit is pure folks!" ;-)
23:24:34 <Peaker> It just feels a bit redundant to have both "let" and "=" in there
23:24:42 <Peaker> ivanm, "=" vs "<-" :)
23:24:42 <kmc> yeah
23:24:49 <ivanm> not as visually obvious
23:24:51 <ivanm> IMHO
23:24:57 <kmc> perhaps it's redundancy for the sake of uniformity
23:25:04 <Cale> It seems somewhat natural to me that let-without-in translates into let-with-in :)
23:25:05 <kmc> it makes it more like "let .. in .."
23:25:51 <ivanm> kmc: that too
23:26:15 <ivanm> *sigh* don't you hate it when you have some code you have to write but don't really want to?
23:26:41 <ivanm> especially since I"m not quite sure how to do it; should I just do it manually or hack a State monad in...
23:27:15 <aasmith_> i'm currently working through the meijer videos. just done with chapter 4, and i would appreciate any feedback on the correctness of my answers.
23:27:18 <aasmith_> http://github.com/aasmith/haskell-learning/blob/master/ch4.hs
23:27:54 <aasmith_> or really anything in that repo.
23:28:50 <kmc> you didn't write or_c
23:28:56 <kmc> i'm not sure what the "three different ways" would be
23:29:09 <kmc> perhaps one of them is intended to use "case"?
23:29:45 <aasmith_> i havent seen him cover case yet, so im not sure
23:31:14 <aasmith_> oh, | ?
23:32:05 <kmc> ok
23:33:20 <ivanm> when using a State monad, does it remember the state of recursive calls?
23:35:28 <Peaker> ivanm, You mean like:  myStateChange = do  { ... ; myStateChange ; ... } ?
23:35:42 <ivanm> I have a recursive data structure
23:35:56 <dafis> Cale, dolio: the 38GB from alexyk's 3.5GB file absolutely makes sense. The file is GZip-compressed. I just decompressed a 4.5MB file of the same kind and got a 54.5MB file.
23:36:29 <ivanm> if I have the function foo for state stuff, and I call it on a sub-structure (e.g. a sub-tree), does it remember whatever state was modified in the sub-call?
23:36:32 <krainboltgreene> I wonder why Blogs/Weblogs are the "learner" web projects for most languages.
23:36:38 <ivanm> I would assume it does, but in this case would prefer it not to :s
23:36:54 <Saizan> ivanm: maybe you want to use Reader and local then
23:37:06 <Peaker> or just a local runState within the State computation?
23:37:23 <ivanm> I think local lets you define the Read values _before_ you do the recursive call
23:37:25 <ivanm> @hoogle local
23:37:26 <lambdabot> Control.Monad.Reader.Class local :: MonadReader r m => (r -> r) -> m a -> m a
23:37:26 <lambdabot> Trace.Hpc.Mix LocalBox :: [String] -> BoxLabel
23:37:26 <lambdabot> Data.Time.LocalTime localDay :: LocalTime -> Day
23:38:04 <wavewave> Cale: I made my own version of unionWithM for sorted list. :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26863#a26863
23:38:20 <ivanm> OK, looks like I just have to be careful with recursive calls; store a copy of the state that I don't want to change, do the recursive call, then set that backed-up state back in
23:38:36 <ivanm> OK then, should i use mtl or transformers...
23:38:45 <Saizan> ivanm: foo .. = do ..; locat f foo; bar -- bar doesn't see the change introduced by 'f' into the state
23:38:50 <Cale> wavewave: Yeah, something like that is reasonably sensible.
23:39:07 <ivanm> Saizan: yes, but the state change happens _during_ the recursive call
23:39:10 <dafis> Cale, dolio: Hum, actually I just received a mail from alexyk where he says the 3.5GB is the uncompressed file.
23:39:11 <Saizan> ivanm: but you're right, a put works too
23:39:22 <Cale> dafis: right
23:39:27 <Saizan> ivanm: and you want some of that change to propagate back?
23:39:47 <ivanm> Saizan: either propogate back or return the values so I can put them in to the "global" state
23:39:49 <Peaker> ivanm, Generally transformers is supposed to eventually replace mtl to my understanding
23:39:55 <ivanm> Peaker: yeah
23:39:58 <Cale> dafis: But it's still a flat file on disk and not a Trie or Map structure with all the overhead that entails. Still, seems like a loooot of overhead.
23:40:09 <Peaker> ivanm, It's pretty easy to change between the two
23:40:13 <Peaker> ivanm, so don't sweat it :)
23:40:15 <ivanm> State looks unchanged, so I'll go with the flow
23:40:35 <ivanm> Peaker: yeah, it's just that if I use transformers in this package I might as well change my other package to use transformers as well
23:40:45 <ivanm> (and then ghc-pkg hide mtl rather than transformers)
23:40:58 <Peaker> ivanm, Yeah, you'll help bring the end of mtl
23:41:00 <Peaker> that would be nice
23:41:15 <Saizan> and replace it with something almost identical, yay
23:41:24 <Peaker> btw: I don't understand why we have "mtl" and "transformers" packages rather than a "StateT" package, a "MonadIO" package, a "ReaderT", ...
23:41:33 <Peaker> So when they mess up like with ListT, you can just replace one package
23:41:42 <Peaker> Saizan, Well, there's a package split
23:41:47 <Peaker> Saizan, Do you find both of them broken? :)
23:42:01 <Peaker> If we hasten mtl's doom we'll have 1 less package split to worry about
23:42:04 <Saizan> Peaker: yes, they are broken in the exact same ways
23:42:13 <Peaker> Saizan, Transformers has a broken ListT too?
23:42:24 <Peaker> Is there any more breakage beyond that?
23:42:54 <ivanm> or I could go with that weird one that builds up transformer stacks that someone wrote (can't remember the name)... ;-)
23:43:21 <dafis> Cale: Yes, I don't know the Trie's binary instance, but for Map and IntMap, you first read the size, then the list of assocs and then build the Map. So, while that isn't particularly fast, laziness should keep the overhead fairly low.
23:44:27 <Saizan> Cale, dafis: looking at the code, deserializing a Trie will use stack proportional to its height
23:44:39 <Peaker> Why does ghc --make rebuild the same modules over and over when building multiple executables that share a module?
23:46:26 <Saizan> it doesn't if it has access to the intermediate .hi files
23:48:09 <ivanm> OK, in ghci, how can I tell if I'm using mtl or transformers?
23:48:29 * ivanm thought he had hidden one of them, but both seem to be exposed :s
23:48:34 <dafis> ivanm: ghci prints which libraries it loads
23:48:48 <ivanm> dafis: huh?
23:49:12 <dafis> GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help
23:49:12 <dafis> Loading package ghc-prim ... linking ... done.
23:49:12 <dafis> Loading package integer-gmp ... linking ... done.
23:49:12 <dafis> Loading package base ... linking ... done.
23:49:12 <dafis> Loading package ffi-1.0 ... linking ... done.
23:49:14 <ivanm> at the beginning, maybe
23:49:15 <Cale> ivanm: Use something from the package
23:49:25 <ivanm> but not when you've been using it for a while...
23:49:29 <Cale> okay
23:49:32 <Cale> then reload it :)
23:49:44 <ivanm> Cale: AFAIK Control.Monad.State is the same in both of them AFAIK :s
23:49:44 <Saizan> :i State
23:49:55 <Saizan> if it's a type alias it's transformers
23:50:01 <ivanm> yeah, just says Control.Monad.State
23:50:06 <ivanm> Saizan: ahhh, OK
23:50:08 <ivanm> it's using mtl then
23:50:22 <Peaker> Saizan, I have a .cabal file specifying multiple executables that share modules -- and each build re-builds all shared ones for each executable
23:50:53 <ivanm> dammit, why is ghci defaulting to mtl? :s
23:50:54 <dafis> ivanm: Prelude> :m +Control.Monad.State
23:50:54 <dafis> Prelude Control.Monad.State> runState (return True) ()
23:50:54 <dafis> Loading package syb-0.1.0.2 ... linking ... done.
23:50:54 <dafis> Loading package base-3.0.3.2 ... linking ... done.
23:50:54 <dafis> Loading package mtl-1.1.0.2 ... linking ... done.
23:50:55 <dafis> (True,())
23:51:24 <ivanm> OK, yes, it's using mtl
23:51:25 <ivanm> :@
23:52:40 <Saizan> Peaker: cabal is not sharing the build of the shared modules because there's no good way to tell that they would get compiled with the same options for all the exes, though since Cabal-1.8 you can have an exe depend on the lib in the same package
23:52:56 <ivanm> gah! it's because transformers-0.2 doesn't have Control.Monad.State
23:52:58 * ivanm facepalms
23:53:12 <ivanm> it's Control.Monad.Trans.State, presumably to avoid clashing problems :s
23:53:51 <Peaker> Saizan, ah, just specify it's own name in the build depends?
23:54:21 <Saizan> Peaker: yep
23:54:49 <Saizan> Peaker: i think you'll also have to split the source dirs, otherwise ghc --make will ignore the lib
23:55:26 <ivanm> Saizan: except then you can't use haddock
23:55:31 <Peaker> Saizan, thanks
23:55:35 <ivanm> and yes, you have to split the source dirs
23:55:48 <Peaker> It seems any module that happens to use TH gets a huge-ass "loading package" list when TH runs, despite the TH not really depending on any of it
23:56:01 <Peaker> So it's probably best to take all $(mkLabels ..) and stuff to small modules?
23:56:07 <ivanm> Peaker: your package will have to expose a library for that to work though
23:56:19 <Peaker> ivanm, Yeah, I'll probably split to a library anyway
