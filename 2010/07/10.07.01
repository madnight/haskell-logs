00:02:07 <Cale> FunctorSalad: I would say it's not evil at all, in fact, that's basically how you're meant to use lazy IO
00:03:26 <vegai> 2010.1.0.1, which contains GHC-6.12.1-i386.pkg
00:03:26 <vegai> that pkg is somehow uninstallable -- the GUI installers "Install" button stays grayed out
00:05:17 <vegai> ah, is xcode required for ghc package to be installable?
00:08:52 <kmc> > let (⊗) ∷ (Num a) ⇒ a → a → a; (⊗) = (*) in 2 ⊗ 3
00:08:53 <lambdabot>   6
00:15:04 <_2x2l> kmc, that's some of the most aesthetically pleasing unicode ive seen
00:15:17 <kmc> thanks
00:16:31 * kmc would like to take credit ;P
00:16:43 <drbean> :t (*)
00:16:44 <lambdabot> forall a. (Num a) => a -> a -> a
00:16:58 <ddarius> augur: You may want to look at contextual modal type theory.
00:17:22 <kmc> > let (↦) = (,) in M.fromList [2 ↦ 'x', 3 ↦ 'y']
00:17:23 <augur> ey? whys that?
00:17:24 <lambdabot>   fromList [(2,'x'),(3,'y')]
00:18:03 <kmc> > let (⊗) ∷ ∀ a. (Num a) ⇒ a → a → a; (⊗) = (*) in 2 ⊗ 3
00:18:04 <lambdabot>   6
00:18:11 <FunctorSalad> hmm tensor algebras are actually Num's more or less, aren't they....
00:18:16 <kmc> > let (⊗) ∷ ∀ (a ∷ ∗). (Num a) ⇒ a → a → a; (⊗) = (*) in 2 ⊗ 3
00:18:18 <lambdabot>   <no location info>: parse error on input `∗'
00:18:21 <FunctorSalad> (skipping the sgn)
00:18:23 <kmc> that'd be too much to ask ;P
00:18:56 <augur> ey, ddarius?
00:19:10 <FunctorSalad> hmm it seems wiser to have the candy virtually (as in haskell-mode) and leave the sauce ascii
00:19:13 <kmc> > True ∨ False
00:19:14 <lambdabot>   Not in scope: `∨'
00:19:44 <kmc> yeah FunctorSalad
00:19:52 <kmc> lhs2TeX candy is sweeter than Unicode anyway
00:20:09 <FunctorSalad> it's pretty inevitable that your source will pass through some tool without utf8 support eventually :(
00:20:34 <FunctorSalad> or maybe things have changed, dunno
00:20:44 <dolio> darcs, for instance.
00:21:05 <FunctorSalad> thought darcs escapes it deliberately for some odd security reason
00:22:30 <ddarius> augur: The conversation you were having earlier with Cale looks like it may be vaguely related to CMTT.  It may even be an instance of it.
00:22:47 <augur> eh
00:23:44 <dolio> Contextual modal type theory?
00:23:54 <ddarius> @google contextual modal type theory
00:23:55 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.62.5334&rep=rep1&type=pdf
00:23:56 <lambdabot> Title: Contextual Modal Type Theory
00:24:10 <augur> in what way? i was just trying to clarify the notion of substitution of different sorts, and decided that it was better phrased in terms of separating an item into a context and a filler
00:25:22 <augur> its more an issue of the semantics of certain rewriting system operations than anything else, reall
00:25:23 <augur> y
00:26:31 <gwern> man, laptop shipping is hard. so many tradeoffs
00:26:42 <ddarius> I'm pretty sure things like calculi of explicit substitution are examples of contextual modal type theories, which does, to some extent "split things into a context and a filler."
00:27:38 <augur> hm
00:27:42 <augur> ok. ill take a look.
00:28:03 <augur> distantly relatedly, have you ever heard of the calculus of structures?
00:28:53 <ddarius> augur: Yes.  I was looking into it quite a bit last month.
00:29:02 <augur> its quite interesting
00:29:15 <augur> this context-filler thing is obviously enormously important in CoS
00:30:40 <dolio> That was the deep inference stuff, no?
00:30:46 <ddarius> Correct.
00:30:47 <augur> basically, yeah
00:31:11 <augur> tho i think CoS has a lot of preferences for certain symmetries in inference rules
00:31:15 <gwern> anyone remember who runs foldr.com?
00:31:23 <gwern> seems to be broken
00:32:59 <kmc> thus definitively proving that functional programming just isn't useful for the real world
00:33:03 <wli> What's deep inference?
00:34:15 <vegai> > True ≠ True
00:34:16 <lambdabot>   Not in scope: `≠'
00:34:28 <augur> wli: deep inference is logical inference that operates on the insides of formulas
00:35:07 <gwern> bleh. that's completely different from the machine learning stuff, I think
00:35:08 <augur> for example, if you have some formulate a & (b | ~~c) you can rewrite that as a & (b | c) because you know that ~~p = p
00:35:15 <wli> I'm not sure that tells me much of anything. I may be too ignorant/stupid/etc. 
00:35:16 <gwern> overuse of terms is a problem...
00:35:23 <augur> and it doesnt matter how deep into the structure that double negation is
00:35:47 <kmc> Data.Eq.Unicode from base-unicode-symbols has (≠)
00:35:47 <gwern> that sounds like some basic term-rewriting
00:35:48 <vegai> (and yes, it was so that xcode is a dependency for ghc)
00:35:57 <augur> gwern: it many ways it is
00:36:10 <vegai> (might be a good idea to include some sort of a message about this in the next platform release)
00:36:10 <wli> augur: Hmm. Maybe it has something to do with breaking the rewrite rule limitation that nesting would prevent the simplification?
00:36:23 <augur> but many forms of logic, for instance the sequent calculus, don't allow this sort of thing
00:36:32 <augur> you can only perform operations on "topmost" items
00:36:57 <augur> so if you want to eliminate the double negation, you have to somehow pull the double negation out to be a topmost item, in some way
00:37:39 <augur> one way to think of it is that deep inference requires the ability to utilize full recursion, whereas shallow inference is tail recursion
00:37:39 <ddarius> newtype CategoryFromMonoid m a b = CategoryFromMonoid m; instance (Monoid m) => Category (CategoryFromMonoid m) where id = CategoryFromMonoid mempty; CategoryFromMonoid a . CategoryFromMonoid b = CategoryFromMonoid (a `mappend` b)
00:39:05 <ddarius> gwern: Most implementations of deep inference systems (at least for propositional logic) are implemented using term rewriting.
00:39:23 * gwern is not surprised
00:39:45 <ddarius> s/using term rewriting/as term rewriting systems/
00:41:06 <ddarius> Guglielmi's subatomic proof theory is interesting.
00:41:22 <augur> is that the one where he treats atoms as some sort of predicate?
00:41:47 <ddarius> augur: Yes.
00:41:53 <augur> yeah that was kinda nifty indeed
00:42:09 <augur> i dont remember anything other than its niftitude
00:42:10 <augur> :p
00:42:20 <augur> what went on in it again?
00:42:30 <augur> atomic sentences were Bool -> Bool or something?
00:42:53 <augur> p(T) = T, p(F) = F if p is true, and the reverse if p is false, was it?
00:43:54 <ddarius> augur: For an atom a, a<T,F> = a and a<F,T> = not a and then we can use a single switch-like rule for recreating the normal connectives.
00:44:15 <augur> aha right
00:47:10 <augur> so ddarius, howve you been dude
00:48:15 <augur> hm yeah i really want to get the symmetry tho
00:48:16 <augur> damnit
00:49:48 <augur> lets see, before we had   M[x := a] <=> exists x.M, which has a reasonable interpretation in both directions
00:50:30 <augur> M[x := a] as a redux of some rewrite step is trivial, and M[x := a] as a pattern to match against is just some set of all possible ways of "unsubstituting" a for x
00:52:01 <augur> but with the context-filler model, its   M{?a} => exists x.M{x} and exists x.M{!x} => M{a}
00:53:46 <augur> so the symmetry of substitution is lost
00:55:51 <augur> maybe it should be instead that M{x} is only interpreted as filling a single hold of M, not all the open holes
00:55:58 <augur> so really it should be M{!x} on the right
00:56:25 <augur> but then you'd get exists x.M{!x} => M{!a}
00:56:34 <augur> and the symmetry isnt there still
01:14:09 <solrize> anyone aware of problems cabal-installing the base package?
01:15:41 <kmc> yes, you're not supposed to do it
01:15:56 <kmc> base comes with ghc and afaik should not be upgraded otherwise
01:16:38 <solrize> :( spammers have discovered hpaste.org.  bah
01:16:43 <solrize> anyway, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26758
01:16:45 <kmc> not the first time
01:17:17 <kmc> what's your ghc version
01:17:20 <augur> ddarius: so let me get your opinion on this, seriously
01:17:22 <solrize> 6.10.4
01:17:46 <solrize> oh is it saying i should upgrade ghc?
01:17:51 <kmc> yeah
01:17:54 <kmc> or use an older version of atom
01:18:19 <solrize> i'd like to know what the new version does differently, as there are no docs in sight
01:18:39 <augur> ddarius: assuming that M{!x} means M is a context of F, with holes in place of all occurances of x in F, and M{?x} is the same only with holes in place of any number of occurances of x
01:19:06 <augur> what does the inference rule  M{!x} => M{?a}  actually do?
01:19:41 <augur> i mean, should the ? and ! be ignored when filling a context, but used when pulling out a context from a formula?
01:19:46 <solrize> what's the simplest way to upgrade ghc?  do i have to download/install or is it there a way to do it with cabal?
01:20:05 <kmc> can't do it with cabal afaik
01:20:17 <kmc> you can install it through your OS's package manager, or by a direct download
01:20:31 <kmc> http://hackage.haskell.org/platform/ is recommended for most uses
01:20:51 <solrize> i'm looking at that, i think the distro packages are usually way out of date
01:20:55 <Ke> (package manager always recommended, if applicable)
01:21:11 <kmc> debian has the latest haskell platform, in sid at least
01:21:20 <kmc> debian stable is way out of date on everything ;P
01:21:30 <kmc> anyway it has the direct binary and source download links too
01:21:31 <solrize> i'm using fedora on this box
01:21:36 <kmc> it's good to get HP unless you have weird requiremets
01:21:45 <solrize> attempting yum install, seeing what happens
01:22:24 <solrize> silly thing doesn't give any version numbers
01:22:41 <solrize> no mirrors seem to have it, it's trying dozens in sequence
01:23:24 <solrize> ok there it is
01:24:42 <pizza_> debian stable is perfectly up-to-date circa 2007
01:37:35 <mxc> hi
01:37:44 <mxc> anyone here familiar with QQ in TH?
01:38:18 <kmc> just what's in the manual / paper
01:39:24 <mxc> which paper?
01:39:28 <mxc> there isn't much in the manual
01:40:38 <kmc> "Quasi-quotation allows patterns and expressions to be written using programmer-defined concrete syntax; the motivation behind the extension and several examples are documented in "Why It's Nice to be Quoted: Quasiquoting for Haskell" (Proc Haskell Workshop 2007). The example below shows how to write a quasiquoter for a simple expression language."
01:40:57 <kmc> paper is http://www.eecs.harvard.edu/~mainland/publications/mainland07quasiquoting.pdf
01:41:07 <mxc> oh, i was hoping there was a TH one specifically
01:42:12 <kmc> that paper describes the same feature described in the GHC manual under "7.9.5.  Template Haskell Quasi-quotation"
01:42:16 <kmc> there may be minor differences
01:42:22 <kmc> is that what you meant by QQ in TH?
01:42:43 <kmc> this isn't the standard TH quotation; it's a way to define new quotation forms
01:43:01 <wli> I guess I just lost hmatrix but I wasn't using it anyway.
01:44:25 <mxc> well, i have a typeclass with some assoc type synonyms
01:45:34 <sstoday> hello everyone
01:45:55 <kmc> hi sstoday
01:46:15 <sstoday> I keep wondering, do a monad need to have a polymorphic type?
01:46:33 <mxc> and was hoping to do something like this: http://article.gmane.org/gmane.comp.lang.haskell.cafe/76307 but having some trouble
01:46:54 <kmc> sstoday, yes, every monad is a type constructor which takes one type argument
01:47:15 <kmc> oh, mxc that's the regular declaration quoting
01:47:21 <kmc> you can read the original TH paper
01:47:29 <kmc> but there are some differences between that and GHC
01:48:22 <kmc> (the term "quasiquotation" is sometimes used more broadly, hence the confusino)
01:48:31 <kmc> mxc, you could hpaste your code and error message and i could take a look
01:48:39 <mxc> yup, doing that just now
01:50:47 <sstoday> whatAbout :: wraps a b => (a -> b) -> b -> b 
01:51:26 <sstoday> for me it looks much like a monad. If you have a wat to extract an 'a' from a 'b'
01:52:09 <sstoday> I meant "a way"
01:52:19 <mxc> kmc:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26779#a26779
01:53:27 <mxc> i left out most of the functions for clarity, but essentially i want to be able to derive MapCls for any type which is of the form newtype M = M m where m is an instance of MapCls
01:55:02 <kmc> sstoday, what is this class Wraps you're using?
01:55:16 <kmc> and what looks like a monad, and why?
01:55:50 <kmc> mxc, strange.  you get this error when you compile the module containing this declaration quote?
01:55:56 <mxc> yeah
01:56:24 <kmc> typechecking of TH quotes is a bit overly eager and it might be doing the wrong thing here
01:56:47 <kmc> you could construct part or all of it using the AST combinators directly rather than quotation
01:57:00 <mxc> I know, i wanted ot avoid that if possible
01:57:10 <mxc> trying to learn a new way of doing it
01:57:11 <kmc> i'm not sure how to fix this otherwise
01:57:42 <mxc> whats weird, is it seems like it is using newName  (with the types t_a48O etc) instead of just the names in th arguments
01:57:49 <kmc> yeah
01:58:04 <kmc> i think it instantiates splices with dummy new names for the purposes of checking
01:58:09 <mxc> thats why i thought htere might be an easy solution, like i'm referring to the arguments in teh quote wrong
01:58:29 <kmc> you could do your quotation through haskell-src-meta instead
02:00:11 <mxc> never used any of the haskell-src libs..  any tips on how to start since the haddocks aren't really that informative there?
02:00:17 <kmc> no, sorry
02:00:37 <kmc> there are plenty of examples in haskell-src-meta
02:00:45 <kmc> not very documented but the code is there
02:02:13 <kmc> mxc, or you can resort to external code generation
02:03:09 <kmc> i've found it's really hard to do anything substantial in TH with only quotation/splicing
02:03:30 <kmc> i have to use AST combinators quite a bit
02:03:35 <kmc> perhaps there is some cleverness i'm lacking
02:08:01 <AAIBB^> i am just starting my read in automatic sequences by allouche.. why is everyone here so focussed on the zip function?
02:09:14 <Cale> AAIBB^: ?
02:09:15 <mxc> kmc - me too
02:09:50 <mxc> kmc - of course, this could all be solved if they lifted the restriction on generalizednewtypederiving with associated type synonyms
02:09:52 * kmc has not heard of this book
02:10:09 <mxc> (with just assoc type syns, there is no concrete reason it wouldn't work, AFAIK)
02:12:03 <Cale> AAIBB^: Who is focussed on the zip function?
02:12:34 <AAIBB^> oh it was mentioned pretty much yesterday
02:13:00 <AAIBB^> i was just wondering if it was of any special significance to the stuff you guys are working on.
02:13:14 <kmc> AAIBB^, what does that have to do with automatic sequences?
02:13:37 <AAIBB^> well, its an operation on isit not
02:13:56 <AAIBB^> anyhow, if you dont deal with either, im fine with that too
02:13:57 <AAIBB^> thanks anyhow
02:14:19 <kmc> "zip" in Haskell is a fairly basic sort of data-reshaping function
02:14:47 <kmc> it tends to be useful here and there, i don't think it has any deep significance (although people keep surprising me on things like that)
02:15:14 <kmc> not knowing automatic sequences i can't comment on any connection there
02:25:17 <aleator> I've got an long calculation in an ST monad and would like to write it's state to file every now and then to be able to restart in case of machine failure. What would be an elegant way to do this?
02:25:26 <nlogax> hmm, trying to parse CSS with parsec, the specification uses some regex-ish syntax. unicode = "\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?". how can i do the [0-9a-f]{1,6} part? i think i succeeded with the rest of it.. :)
02:26:08 <madhadron> nlogax, What is the {1,6}?  A single character that is 1 or 6?
02:26:32 <Sadache> (>>=) :: wraps a b => (a -> b) -> b -> b
02:26:37 <madhadron> aleator, Write a custom executor?
02:26:55 <Ke> madhadron: from 1 to 6 times
02:27:00 <nlogax> madhadron: it's 1 to 6 of the preceding items
02:27:05 <Sadache> isn't a legal representation of bind?
02:27:08 <madhadron> Ah.
02:27:38 <aleator> madhadron: Custom executor? Like myRunST?
02:27:41 <kmc> Sadache, i don't see the connection
02:27:43 <madhadron> aleator, Right
02:28:03 <aleator> madhadron: Is that even possible?
02:28:10 <Sadache> kmc: this way you dont absolutely need a type constructor
02:28:11 <madhadron> aleator, Why not?  It's just a function.
02:28:27 <kmc> Sadache, you didn't define this type class "Wraps" -- i assume you mean for it to be a type class, but it would need an upper-case name
02:28:40 <Sadache> kmc: the type class makes sure u can extract an a from b
02:28:45 <madhadron> nlogax, The [..] part is easy.  Then I'd just write a recursive combinator upTo :: Int -> (parsec type) -> (parsec type)
02:28:53 <Sadache> kmc: yep, sorry
02:28:56 <kmc> Sadache, btw if you want to play with alternative foundations of monads and such stuff, you can use the GHC extension NoImplicitPrelude
02:29:01 <madhadron> nlogax, Which basically just tries if the first argument is not yet 0
02:29:05 <kmc> then you can define your own (>>=) and the "do" notation will use it
02:29:21 <Sadache> kmc: very interesting
02:29:22 <madhadron> aleator, All it does it define the semantics of ST's basic actions in the IO monad
02:29:37 <madhadron> aleator, So just add a semaphore or something, spawn a parallel thread that occasionally signals the semaphore
02:29:40 <kmc> Sadache, maybe you could give me an example of a simple monad such as Maybe rendered in these new terms
02:29:58 <madhadron> aleator, And before each instruction, check the semaphore.  If it's true, write to disk.
02:30:10 <madhadron> aleator, Or you could do a countdown by number of instructions, or whatever.
02:30:33 <Sadache> I'll try to do that, and will get back to you
02:30:40 <kmc> cool :)
02:32:36 <aleator> madhadron: Sorry for being thick, but st is basically type STRep s a = State# s -> (# State# s, a #). I can't figure out how to make that step.
02:33:20 <madhadron> aleator, Honestly, the easiest thing would be to grab the source code for the ST monad and look how they do it.
02:33:27 <madhadron> aleator, That will give you a better answer than anything I can do.
02:33:47 <aleator> I was basically looking for something like STT or ST transformer.
02:34:31 <kmc> you can't have a proper ST transformer if ST is implemented with in-place destructive updates
02:34:32 <kmc> as it is in GHC
02:34:49 <kmc> someone wrote one anyway, http://hackage.haskell.org/package/STMonadTrans
02:34:58 <kmc> it comes with a big disclaimer :)
02:35:10 <patrykz> aleator: if I were you, i'd just write my own little state monad around IO itself, using IORefs to implement MyStRef, then set up an alarm (System.Posix.Signal.scheduleAlarm) that grabs the state periodically and dumps it to disk.
02:35:36 <kmc> aleator, are you trying to do this in a way that works transparently for every ST action, or is it something of a custom solution?
02:36:26 <aleator> kmc: Not general at all. This is still around mwc-random which works in st. (I do know that it also works in IO, but..)
02:36:55 <kmc> ah
02:37:51 <patrykz> aleator: io's just a special kind of st. You can even convert one to another with "stToIO" :)
02:38:00 <kmc> aleator, well, it may not count as elegant, but you can do your IO with unsafeIOToST
02:38:41 <kmc> when you said you wanted STT, what monad would you layer it on top of?
02:38:54 <patrykz> kmc: he's after a custom solution, I really don't see why he would need to avoid IO in the first place. 
02:39:32 <kmc> yeah
02:39:40 <kmc> if you use runST on an ST action which contains some unsafeIOToST
02:39:46 <aleator> kmc: IO to write stuff on disk. It is not that I'd really need to avoid IO (well, thats what it is), but I was looking for not rewriting a bunch of code.
02:39:52 <kmc> that's in some sense no different from just using IORef and unsafePerformIO
02:40:14 <kmc> aleator, i think your quick hack is unsafeIOToST then, and i think as hacks go it's not *that* bad
02:40:15 <mpiechotka> Hello - how to understand ComonadCoideal?
02:40:26 <patrykz> Plus, if he write your own st, you can put extra constraints on the kind of stuff you permit in the state (which you'll have to do if you want to dump it to disk anyway) 
02:40:55 <kmc> patrykz, sure, but that gets closer to writing a general framework rather than just dumping some specific values at specific points
02:41:23 <patrykz> what's wrong with generality?
02:41:34 <aleator> patrykz: work :)
02:41:37 <patrykz> (assuming it doesn't come at the expense of coding time)
02:42:04 <patrykz> aleator: the whole thing wouldn't take more than, lake, 20-30 lines of code!
02:42:16 <kmc> haha ;)
02:42:31 <patrykz> aleator: and you DID mention "elegant" at the beginning of the discussion :)
02:42:53 <kmc> i think you can make an argument for kindaSafeIOToST :: IO () -> ST s ()
02:42:56 <patrykz> kmc: I've got dinner on the table, when I come back, I'll hack it up for you :)
02:43:10 <kmc> patrykz, i'm interested to see how you do it :)
02:43:53 <kmc> at least this function cannot cause a runST result to have nondeterministic evaluation
02:44:00 <kmc> unless i'm missing something
02:44:33 <madhadron> kmc, And it would be worth it just to have kinda in the standard library
02:45:18 <kmc> yeah
02:45:48 <aleator> I feel bit iffy using unsafe* in something that saves results of 5 days of computation :) 
02:46:13 <madhadron> aleator, unsafe just means you have to make your own guarantees about referential transparency
02:47:10 <kmc> hehe
02:47:24 <kmc> yeah, the meaning of "unsafe" in unsafeCoerce is quite different from unsafePerformIO
02:47:55 <madhadron> we really ought to take that proposal seriously for renaming the scary one to simonCoerce
02:47:55 <aleator> I don't yet have clear picture on how many toes I lose with IOtoST yet..
02:48:31 <madhadron> aleator, As long as you keep your IO effects strictly limited to a fixed set of things where you handle all concurrency problems, none
02:48:58 <madhadron> aleator, So if it has nothing but a shared file and a semaphore, and really touches nothing else
02:49:17 <madhadron> aleator, And you make sure that parallel instances of it can interleave without problem
02:49:33 <madhadron> aleator, then all is well.  If you grab arbitrary IORefs from thin air, you will suffer.
02:49:47 <kmc> perhaps put the file handle in an MVar and only write within withMVar
02:50:08 <madhadron> Yeah, something like that.
02:52:02 <aleator> That sounds like a way to deadlock myself on a bad moon..
02:52:28 <madhadron> aleator, Or you write out a temporary file with a unique name each time and don't touch anything else
02:54:06 <kmc> aleator, withMVar will always replace the value when the enclosed action terminates, whether normally or by exception
02:54:15 <kmc> you could deadlock if the IO blocked indefinitely
02:56:19 <aleator> Question. IO is basically a special case of ST? Also, ST needs to enforce same things like execution order and so on. So if I cram IO inside a newtyped ST, which can only be ran in IO, it should be equivalent to IO?
02:57:00 <Cale> aleator: ST behaves more like a special case of IO
02:57:23 <dafis> aleator: ST can only be run with a forall'd state parameter
02:57:23 <lambdabot> dafis: You have 1 new message. '/msg lambdabot @messages' to read it.
02:57:24 <Cale> aleator: In that, it's IO restricted to memory effects. (STRefs and STArrays in place of IORefs and IOArrays)
02:58:12 <kmc> aleator, in GHC's implementation, ST and IO are nearly the same.  ST has fewer primitives; in return you get runST.  but the actual implementation of runST is basically the same as unsafePerformIO
02:58:30 <kmc> in other words the ST safety checking is all static
02:58:40 <aleator> I'm learning stuff today :)
02:58:42 <zygoloid> indeed, this nearly-the-same-ness is visible in functions like stToIO
02:59:02 <kmc> you could take an ST program which you know typechecks, mechanically replace STRef with IORef, replace runST with unsafePerformIO, and your code would be "just as safe" and would likely compile to something nearly identical
02:59:35 <zygoloid> IO a is isomorphic to ST RealWorld a iirc
03:00:01 <kmc> yeah.  stToIO exhibits one direction of the isomorphism
03:00:32 <aleator> So, if there was some unsafeIOToST in an ST, and runST was evaluated in IO, it would be same as if it had been just IO in the first place? (I think I already forgot why I wanted to do this)
03:00:40 <zygoloid> aleator: there is an unsafeIOToST
03:00:43 <kmc> aleator, yes
03:00:51 <kmc> aleator, subject to the caveat that these are implementation details
03:01:10 <zygoloid> aleator: for a while there was a vulnerability in lambdabot that you could @let unsafePerformIO = runST . unsafeIOToST
03:01:23 <zygoloid> and then perform arbitrary IO operations
03:01:47 <aleator> So, to do this would not really unsafe but only really ungly?
03:01:50 <kmc> i don't know if «ioToST ∷ IO a → ST RealWorld a» is provided anywhere.  seems to me it'd be safe; you get a sort of dubious ST action, but you know it can only be run via stToIO
03:01:58 <kmc> aleator, what does "unsafe" mean?
03:02:15 <dafis> kmc: what it says
03:02:17 <aleator> kmc: Do not use? :)
03:02:34 <zygoloid> kmc: i think there is an ioToST :: IO a -> ST RealWorld a in Control.Monad.ST
03:02:37 <zygoloid> @hoogle ioToST
03:02:38 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
03:02:38 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
03:02:44 <zygoloid> could be wrong though :)
03:02:49 <kmc> aleator, that's not what unsafe means
03:03:09 <aleator> kmc: Hide flammables before using? 
03:03:14 <kmc> ;P
03:03:20 <kmc> aleator, if you use unsafeIOToST within your ST actions, then maybe you make a mistake elsewhere and pass it to runST
03:03:48 <kmc> if you know you won't make that mistake, then unsafeIOToST is not unsafe
03:03:59 <kmc> if you know you won't make any mistakes at all, then C is not unsafe
03:04:09 <zygoloid> kmc: ioToST is in GHC.IOBase
03:04:12 <kmc> cool
03:04:25 <aleator> kmc: I would likely make the typechecker keep eye on my coding at this point.
03:04:55 <dafis> kmc: if you 'know' you won't make any mistakes at all, *you* are unsafe
03:05:08 <aleator> One last question before embarking on this silly thing. How likely is this going to break with ghc of near future?
03:05:29 <kmc> aleator, it sounds like you just want to refactor some ST code to use IO instead
03:06:16 <kmc> and that "unsafe" tricks are just a way to avoid massive code changes
03:06:37 <aleator> kmc: Pretty much yeah.
03:06:48 <roconnor> @pl (\f -> (\x -> f (x x)) (\x -> f (x x)))
03:06:49 <lambdabot> ap (. join id) (. join id)
03:07:04 <kmc> and in that case maybe you can use the non-unsafe ioToST, which forces you to use stToIO instead of runST
03:07:57 <kmc> zygoloid says it's in GHC.IOBase (which i can't find doc of) but anyway you can define it simply as «stToIO :: IO a -> ST RealWorld a; stToIO = unsafeSTToIO»
03:08:23 <kmc> err i meant
03:08:42 <kmc> «ioToST :: IO a -> ST RealWorld a; ioToST = unsafeIOToST»
03:09:53 <dafis> kmc: there are no docs for IOBase &co because it would be unwise to encourage people to use them, but those moudles are available for when you need them
03:10:03 <aleator> Thanks all!
03:10:40 <kmc> aww but we have docs for Unsafe.Coerce and Foreign.Ptr
03:11:02 <dafis> kmc: that's something I don't understand either
03:11:42 <kmc> they have big disclaimers
03:12:00 <kmc> it's pretty clear what you're getting into -- maybe less clear with Foreign
03:12:44 <osfameron> if Foreign isn't clear then just SPEAK LOUDER, they're only /pretending/ not to speak English ;-)
03:13:13 <kmc> i doubt anyway that GHC.IOBase is deliberately hidden for this reason
03:13:25 <kmc> there's plenty of gruesome unsafe stuff documented under GHC.* at http://www.haskell.org/ghc/docs/6.12.2/html/libraries/
03:13:52 <kmc> catchSTM# :: (State# RealWorld -> (#State# RealWorld, a#)) -> (b -> State# RealWorld -> (#State# RealWorld, a#)) -> State# RealWorld -> (#State# RealWorld, a#)
03:14:18 <dafis> kmc: maybe they were just too lazy to write huge disclaimers for all the stuff in IOBase
03:14:59 <kmc> of course there's no comments at all on GHC.PrimopWrappers so that might be one clue it's not for public consumption
03:15:06 <kmc> that and all the hash that's floating about
03:15:51 <dafis> kmc: actually, having looked at the source: module GHC.IOBase {-# DEPRECATED "use GHC.IO instead" #-}
03:15:53 <kmc> haskell is like sausage
03:17:33 <dafis> but both, GHC.IOBase and GHC.IO have {-# OPTIOS_HADDOCK -hide #-}
03:17:41 <dafis> OPTIONS
03:18:13 <flabron> how do i check if the selected element of a list is the last?
03:18:55 <kmc> what does that mean, the selected element?
03:18:59 <dafis> flabron: in what situation?
03:19:24 <Zao> flabron: Check if there's an element following it?
03:19:34 <Zao> It all depends on what you mean by "selected".
03:20:56 <flabron> for example, i want to creat a function that given a list compare the element to the element in the right and creat a list with the ones who are bigger then the right. But when i'm in end of the "cycle" the function try to compare, but since the list is onde the end i got and error of patterns
03:21:36 <kmc> flabron, sounds like you want a few cases in your function
03:21:48 <kmc> a base case which matches the empty list, or matches a one-element list
03:21:54 <kmc> the patterns for those would be [] and [x] respectively
03:22:08 <dafis> flabron: function list = zipWith (==) list (drop 1 list)
03:22:16 <flabron> b [1,9,8,4,16,5,2]
03:22:17 <flabron> got the [] already, miss the [x] xD
03:23:11 <flabron> working, it was the [x] exception. Thanks a lot!
03:23:35 <kmc> flabron, possibly the -Wall flag to ghc would have given you a warning about incomplete patterns
03:26:33 <patrykz> kmc: done
03:26:39 <patrykz> (not tested, but done :)
03:27:00 <patrykz> I was off by 2 lines - it took 32 lines including whitespace and type signatures
03:30:56 <patrykz> aleator: check out http://www.jantar.org/Checkpointer.lhs
03:31:26 <patrykz> I haven't run it or anything so there are probably typos, but it should give you the general idea.
03:34:46 <dafis> patrykz, line 7: m >>= k = ST $ \r -> unst m r >>= \x -> uns (k x) r ; s/uns /unst /
03:35:05 <patrykz> oops :)
03:35:21 <dafis> you said there are probably typos :)
03:36:24 <patrykz> and dump should put another mvar around the file writing to avoid corrupted files.
03:37:27 <patrykz> but otherwise, I really don't see why you'd want to jump through horrendous hoops with monad transformers when you can do it from scratch in 32 lines :)
03:38:11 <dafis> patrykz: if you continue on the same line after 'do', it's 30 :)
03:38:27 <patrykz> I strongly believe that if it takes more "import" lines to reuse a library than to write it from scratch, it doesn't count as code reuse :)
03:38:46 <patrykz> Yeah, I could easily compact it.
03:38:50 <patrykz> let me try :)
03:39:07 <dafis> patrykz: without making it unreadable
03:39:35 <dafis> of course with {;}, you can force it on one line
03:41:07 <patrykz> bah, as you've said - it still should be readable
03:41:22 <patrykz> there, 28 lines
03:41:36 <aleator> patrykz: How do you implement newSTRef over that one?
03:42:01 <aleator> just new ioref?
03:42:09 <patrykz> without resorting to obfuscation
03:42:13 <patrykz> aleator: yep.
03:42:36 <patrykz> type STRef a s = IORef s
03:42:58 <patrykz> that's what they really are, under the hood.
03:43:04 <patrykz> both are just pointers
03:43:20 <patrykz> of course, you won't be able to dump those iorefs, just the state in the mvar.
03:43:40 <patrykz> If you don't like that, make the state into a list of refs.
03:43:45 <patrykz> or something such.
03:43:49 <aleator> Hmm. I wonder if an existing st module could be made to work with this.
03:45:08 <patrykz> aleator: I don't see why not.
03:45:37 <patrykz> but you'll need to use mvars instead of STRef to avoid concurrency issues
03:47:49 <jaspervdj> yairchu: ping
03:48:01 <yairchu> jaspervdj: pong!
03:48:16 <yairchu> :)
03:48:22 <jaspervdj> yairchu: see query
03:58:30 <flabron> how do i generate this sequence [2,-3,4,-5,6,-7,8,-9,10,-11]  in a comprehension list?
03:59:15 <zygoloid> dafis: so i did some calculations with a friend, and it seems there are 174 "correct" answers to the Tuseday Boy problem, fsvo "correct".
03:59:16 <dafis> > [if even n then n else negate n | n <- [2 .. 11]]
03:59:17 <lambdabot>   [2,-3,4,-5,6,-7,8,-9,10,-11]
04:00:09 <dafis> zygoloid, I think one could cook up even more scenarios with even more 'correct' answers
04:00:11 <flabron> dafis, thanks a lot! :)
04:00:17 <yairchu> beat me to it.. :)
04:00:20 <yairchu> > zipWith ($) (cycle [id, negate]) [2..11]
04:00:21 <lambdabot>   [2,-3,4,-5,6,-7,8,-9,10,-11]
04:01:00 <dafis> flabron: but I'd prefer yairchu's, only you asked about a list-comprehension
04:02:11 <dafis> flabron: if you don't mind inefficiency, [(-1)^n * n | n <- [2 .. 11]]
04:03:26 <flabron> dafis, the problem with yairchu code is i don't understand it lol
04:03:55 <dafis> flabron: cycle [id, negate] is clear, isn't it?
04:04:28 <dafis> and zipWith ($) functionList valueList applies the function in place i to the corresponding value
04:04:36 <yairchu> > zip (repeat 7) [1..5]
04:04:37 <lambdabot>   [(7,1),(7,2),(7,3),(7,4),(7,5)]
04:04:50 <yairchu> > zipWith (*) (repeat 7) [1..5]
04:04:50 <lambdabot>   [7,14,21,28,35]
04:05:15 <dafis> zipWith ($) [f1, f2] [v1, v2] = [f1 $ v1, f2 $ v2]
04:06:44 <flabron> thanks everyone, it's helped a lot
04:06:46 <flabron> :)
04:14:09 <Jafet> > map (\x -> round $ x*cos(pi*x)) [2..]
04:14:10 <lambdabot>   [2,-3,4,-5,6,-7,8,-9,10,-11,12,-13,14,-15,16,-17,18,-19,20,-21,22,-23,24,-2...
04:19:29 <zygoloid> dafis: yes. to get to 174 i had to make a lot of assumptions (that the person telling me is truthful and deterministic, and that he was guaranteed to run an algorithm to decide what to say whose output only depended on the genders and days of birth of his children)
04:20:18 <zygoloid> i think there were more hidden assumptions too. then the number of answers is:
04:20:58 <zygoloid> > length . group $ sort [n % d | d <- [1..27], n <- [0..d], n <= 13]
04:21:00 <lambdabot>   174
04:21:18 <zygoloid> hooray, i'm not off-topic :)
04:21:43 <dafis> zygoloid: you can also assume that the person was randomly selected from some group (say the people with at least two children, one of which was born on a Friday)
04:22:04 <dafis> that would give a lot of new possibilities :)
04:26:08 <zygoloid> dafis: yeah. another way of approaching it is, the person tells you "i have two children". you ask "do you have at least one son born on a Tuesday?" and they say "yes".
04:27:04 <zygoloid> then the answer depends on how likely you were to ask that question :)
04:27:46 <dafis> zygoloid: as far as I'm concerned, not very likely
04:29:36 <dafis> or the person decides via dice-roll what additional tidbit of information besides the sex is given (weekday of birth, hair-colour, eye-colour,...)
05:27:14 <Jonno_FTW> [Ctest
05:44:09 <Jonno_FTW> @src succ
05:44:09 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:44:13 <Jonno_FTW> :|
05:45:44 <Jonno_FTW> would it be more efficient to use succ or x=1?
05:45:58 <Jonno_FTW> s/x\=1/x\+1/
05:46:46 <Twey> Jonno_FTW: No
05:46:52 <Jonno_FTW> uhh
05:46:57 <Jonno_FTW> which one do Iuse?
05:47:03 <Twey> Whichever you want
05:47:21 <Twey> ‘succ x’ effectively becomes ‘x + 1’ for values where that's appropriate anyway
05:47:32 <Jonno_FTW> ok
05:47:33 <danharaj> Jonno_FTW: You're thinking like an 80's assembly programmer.
05:47:50 <Jonno_FTW> this is what first year digital electronics will do to you
05:51:56 <ClaudiusMaximus> :t ( succ, (+1) )
05:51:56 <Jonno_FTW> also
05:51:57 <lambdabot> forall a a1. (Enum a, Num a1) => (a -> a, a1 -> a1)
05:52:14 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=298
05:52:29 <ClaudiusMaximus> > (maxBound :: Int) + 1
05:52:30 <lambdabot>   -9223372036854775808
05:52:33 <ClaudiusMaximus> > succ (maxBound :: Int)
05:52:34 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
05:52:39 <Jonno_FTW> would that be brute forceable?
05:54:47 <eevar2> 64 bit? i'd shoot for something longer
05:54:51 <zygoloid> if one were foolish enough to micro-optimize, i'd guess that (x + 1) would be slower than (succ x) in a function polymorphic over the type of x, and identical if the type of x is known
05:55:08 <eevar2> nm, my reading comprehension blows
05:55:21 <Jonno_FTW> The type of x will be Int
05:55:39 <zygoloid> hmm, ClaudiusMaximus makes a good point; succ does extra checking
05:56:11 <Botje> Jonno_FTW: at first glance you have a branching factor of 6
05:56:15 <zygoloid> Jonno_FTW: the correct answer is: unless profiling indicates that this operation really is a bottleneck, you should choose the more readable option
05:56:22 <Botje> > 6^50
05:56:24 <lambdabot>   808281277464764060643139600456536293376
05:57:03 <Jonno_FTW> WHA?
05:57:05 <Jonno_FTW> that's crazy
05:57:26 <otto_s_> > product [6..10] ^2
05:57:27 <lambdabot>   914457600
05:57:28 <Jonno_FTW> I'm just making a few functions to determine the next turn of the game
05:57:56 <Jonno_FTW> I don't see how it would get out of hand
05:58:59 <jmcarthur> succ and (+1) are not necessarily the same
05:59:05 <Botje> that's for an exhaustive search.
05:59:23 <Jonno_FTW> but
05:59:29 <Botje> you can probably get away with simulating a few million games and averaging the scores
05:59:31 <jmcarthur> for Bounded types, succ might even be _|_ (no overflow)
05:59:32 <Jonno_FTW> what if I just make a program that plays the game
06:00:03 <zygoloid> Jonno_FTW: have you tried guessing 0.00000000? :)
06:00:18 <Jonno_FTW> oh right, I need to look up expected value
06:00:46 <Botje> monte carlo ftw
06:00:59 <jmcarthur> that's a lot of precision for monte carlo
06:01:16 <Botje> let's call it a billion games
06:02:26 <Jonno_FTW> oh right
06:02:36 <Jonno_FTW> I didn't read the question properly
06:02:49 <jmcarthur> i don't see how either strategy would be better than the other
06:03:45 <jmcarthur> neither of the variables the players are using seem to have anything to do with which number comes next
06:03:57 <Jonno_FTW> it's random
06:04:04 <jmcarthur> right
06:04:15 <Jonno_FTW> each number has a 1/10 chance of appearing
06:04:20 <jmcarthur> right
06:05:13 <jmcarthur> well, the answer is not 0.00000000, so i guess i'm misunderstanding something
06:06:02 <Jonno_FTW> I was going to make a program to simulate the game, but then I saw it has random next numbers
06:06:10 <Jonno_FTW> now i'm stuck
06:10:08 <Axman6> @tell edwardk Are you planning on some sort of tutorial illustrating the usefulness of your speculative parallelism package? I can't quite see the use of it at face value
06:10:09 <lambdabot> Consider it noted.
06:10:52 <Jafet> Be careful, he might write you a speculative tutorial
06:11:53 <routehubFlaps> !ops | `a mess-age `to you from`` `BIK-CMP: girl you must be ieee-1284 because i can tell that your port is bidirectional
06:13:46 <otto_s_> Jonno_FTW: Simulate all possibles moves at once. Thereby advancing a multiset of (Mem,Mem,ScoreDiff) states to the next.
06:13:53 * hackagebot rallod 0.0.1 - '$' in reverse.  http://hackage.haskell.org/package/rallod-0.0.1 (MattParker)
06:14:16 <Thinglilo_node> !ops | `a mess-age `to you from`` `BIK-CMP: Not following the chat room rules will at the least get you a reprimand or, at the worst, kicked or removed from the chat room. The Operators are here to assist and make sure the chat room is a fun and friendly place to visit. Channel Operators are not guards, but they take their jobs seriously. In the event of unacceptable or disruptive behavior, you will be asked to leave the room
06:15:02 <Jonno_FTW> well
06:15:23 <gitWebsco> !ops | `a mess-age `to you from`` `BIK-CMP: We're the math nerds. Uh huh, that's us. Our glasses are thick; our skin bleeding pus. Chalkboards are out and computers are in... Mathmatica, dude! WTF have you been? We're crunching some primes while chatting on forums; Star Trek and Star wars; the Great Pauly Shore--Um, this math problem's simple to solve, can't you see? You need to brush up on your pi, roots, and e.
06:15:30 <Jonno_FTW> there's 10^50 possible turns her
06:15:32 <Jonno_FTW> e
06:15:55 <Botje> oh right, school holiday has started.
06:16:02 <nullSolaris> !ops | `a mess-age `to you from`` `BIK-CMP: A military-grade GPS transponder is integrated into my brilliant blue HUD which is projected stereoscopically onto the inside of my windshield giving the effect of a gentle, and indeed quite entrancing, box of luminous information about my own decadence floating 10-15 meters in front of my exquisite sedan. Good day.
06:16:14 <Jonno_FTW> mine start at the end of tomorrow's exm
06:16:38 <Botje> Jonno_FTW: well, there's only C(5,10) possible memorized lists
06:17:13 <Jonno_FTW> there's obviously a better way to do this, and I don't know how to arrive at it. Thus I give up
06:17:17 <Botje> that's only 15120 possible lists
06:17:30 <Jonno_FTW> that's doable
06:17:36 <Git_RubyX86> !ops | `a mess-age `to you from`` `BIK-CMP: girl, you must be a basic land card, because i just tapped you and now i got mana burn
06:17:54 <Botje> well, slightly more because you have to take the first four turns into a ccount
06:18:16 <Botje> but then you simply have to apply your function to each of the lists
06:18:18 <Botje> it's doable
06:18:48 <plazmaAtari> !ops | `a mess-age `to you from`` `BIK-CMP: girl u must be grouphug.us because i would make up any ridiculous story just 2 be on u
06:18:59 <Phyx-> wtf
06:19:01 <Jonno_FTW> ^
06:19:50 <PerlUnixCode> !ops | `a mess-age `to you from`` `BIK-CMP: There was this one time when I was so constipated from lack of proper diet and opiate abuse that I strained so hard I passed out and hit my head on the bathtub. I guess my bowels released when I was unconscious because I was awakened by my dog licking a mixture of blood and feces from my swollen and prolapsed rectum. To this day the muscles are so atrophied that I must wear a special ha
06:19:56 <Botje> sigh
06:19:57 --- mode: ChanServ set +o Saizan
06:20:06 <Jonno_FTW> can we get a ban going here?
06:20:10 --- mode: Saizan set +b *!*@gateway/web/freenode/ip.58.56.108.114
06:20:11 <Phyx-> indeed
06:20:34 <Amiga_Xorphp> !ops | `a mess-age `to you from`` `BIK-CMP: i hacked into an airline's computer systems and stole a huge bunch of frequent flyer points then traded them in for merchandise and got a sony playstation 2
06:20:38 --- mode: Saizan set +b *!*@gateway/web/freenode/ip.147.91.1.42
06:20:39 <Botje> Saizan: they're all different IP addresses
06:20:44 <Phyx-> and another one :/
06:20:48 <Saizan> Botje: i've seen some recurring ones
06:20:58 <Jafet> Saizan, leave out the IP and get a staffer now...
06:21:01 <Saizan> i guess i could set +r, or whatever
06:21:04 <Jonno_FTW> ban *gateway/web/freenode/*?
06:21:18 <Sposato_Mquin_de> !ops | `a mess-age `to you from`` `BIK-CMP: My band, although hardcore, and almost scary at times, is comparable to the sound of Limp Bizkit, but our music holds messages of much value. We played the title track off our album, "This Road," which talks about working hard to achieve goals in life.
06:21:22 <Twey> What's the point of this?  o.@
06:21:50 <Jonno_FTW> to annoy people
06:21:55 <Zao> Twey: What's the point to any raid?
06:22:02 <Unix_Neuro> !ops | `a mess-age `to you from`` `BIK-CMP: GET TROOPS OUT OF IRAQ BUCK FUSH CONSERVATIVES ARE GAY NO BLOOD FOR OIL WRONG WAR WRONG PLACE WRONG TIME FRIENDS DONT LET FRIENDS VOTE REPUBLICAN BUSH&DICK: GOOD IN BED BAD IN DA WHITEHOUSE my brother raped me when i was 6
06:22:04 <Jonno_FTW> to troll
06:22:05 <Jafet> To get underwear
06:22:14 <Twey> Haha
06:22:19 <thingRoute> !ops | `a mess-age `to you from`` `BIK-CMP: I don't know about you guys, but knowing that gay marriage exists here now has hurt marriage. Whenever I try and fuck my wife, all I can think about is two sweaty, heaving male bodies joined together in government sanctioned disgusting decadent man sex with large calloused hands grasping and moist gasping lips joined with giant throbbing cocks ohh yeah
06:22:21 <Jafet> However these raiders don't realize that we don't wear any!
06:22:23 <Botje> i'm touched to see #haskell getting hit before #perl
06:22:31 <Botje> we're finally failing at avoiding success!
06:22:38 <javaWorm> !ops | `a mess-age `to you from`` `BIK-CMP: 500 read timeoutn
06:22:46 <Phyx-> if this is success, I want none of it
06:22:53 <ker2x> Botje :) :)
06:22:57 --- mode: Saizan set +b *!*@gateway/web/freenode/*
06:23:16 <Saizan> Jafet: mh, what could staff do?
06:23:27 <Jafet> And set the topic perhaps, for any real gateway users
06:23:42 <Jafet> Dunno, sprinkle magic dust to make everything right
06:23:44 <ker2x> ban on !ops ? :)
06:24:11 <Phyx-> yeah, can't we get lambdabot to instantly ban on use of !ops
06:24:11 <Botje> i guess it's some kind of stupid HTTP form-based attack again
06:26:06 <jmcarthur> could try setting up a script on my end to automatically ban those
06:26:23 <Phyx-> wow, there were that many of those
06:26:43 <Jafet> Well, it might take you longer to write it than for them to give up and leave
06:26:49 <Saizan> Phyx-: that wouldn't reduce the spam so much
06:27:16 <jmcarthur> meh
06:27:39 <Jafet> Don't worry, someday you will be a hero
06:27:54 <Phyx-> Saizan: true, but there's no sure fire way to stop them all
06:28:09 <jmcarthur> i want to set up a channel full of bots that exists solely to DDoS other bots that come in and try to spam it
06:30:42 <Jafet> jmcarthur: that happened to freenode recently, just instead of bots they used operators
06:31:18 <jmcarthur> operators DDoSed bots? i'm confused
06:32:01 <Jafet> The firefox form injection induced operators to ban each other
06:32:24 <jmcarthur> oh suckage
06:34:42 <AAIBB^> I have sequence t = foobar.. so t!!1 gives f, t!!2 gives o ect.. How to do t!![4..6] ?
06:34:51 <Phyx-> is there any profiling too for haskell programs that shows me the slowest part?
06:35:10 <Botje> AAIBB^: check out the drop and take functions
06:35:18 <AAIBB^> ty
06:35:26 <eevar2> Phyx-: assuming you use ghc: http://haskell.org/ghc/docs/6.10.3/html/users_guide/profiling.html
06:36:19 <Phyx-> thanks eevar2 
06:36:32 --- mode: Saizan set -b+b *!*@gateway/web/freenode/* *!*@gateway/web/freenode/*$##overflow
06:37:10 <Phyx-> eevar2: only problem is, it states that all modules would have to be compiled with -prof?
06:37:20 --- mode: Saizan set -b *!*@gateway/web/freenode/ip.58.56.108.114
06:37:29 --- mode: Saizan set -b *!*@gateway/web/freenode/ip.147.91.1.42
06:44:05 <Jonno_FTW> > 80*80
06:44:06 <lambdabot>   6400
06:44:25 <roconnor> in GHC, if I spark a large computation with par that isn't referenced, will the garbage collector kill it?
06:44:52 <jmcarthur> roconnor: i'm pretty sure it would kill it if it's not being evaluated. if it is being evaluated.. i don't know
06:45:11 <roconnor> jmcarthur: wha do you mean by being evaluated?
06:45:25 <jmcarthur> if the spark is being evaluated, that is
06:45:40 <jmcarthur> when you spark a computation, it doesn't encessarily start evaluating right then
06:45:48 <jmcarthur> *necessarily
06:46:22 <jmcarthur> it gets put on a queue, basically
06:49:09 <roconnor> jmcarthur: so if the big computation gets going and then the reference to it is dropped it may still keep going.
06:49:13 <roconnor> I'll ask in #ghc
06:49:38 <zygoloid> Saizan: what does the $##overflow do?
06:50:53 <AAIBB^> i have true false true false true true how do i display it in 0 and 1's 
06:51:05 <Saizan> zygoloid: redirects them there, where a staffer klines
06:51:09 <hpc> > fromEnum True
06:51:10 <Jonno_FTW> if True then 1 else 0
06:51:10 <lambdabot>   1
06:51:11 <Zao> AAIBB^: fromEnum?
06:51:13 <hpc> > fromEnum False
06:51:14 <lambdabot>   0
06:51:20 <Jonno_FTW> wait no
06:51:27 <Zao> @type fromEnum True
06:51:28 <lambdabot> Int
06:51:30 <zygoloid> Saizan: that's brilliant
06:51:39 <Zao> Jonno_FTW: Excellent function.
06:51:47 <Jonno_FTW> (\x ->if x==True then 1 else 0)
06:51:59 <Zao> AAIBB^: Note that True and False have a leading capital letter.
06:52:06 <Zao> Jonno_FTW: if x then
06:52:07 <hpc> (\x -> if x then 1 else 0)
06:52:18 <Jonno_FTW> silly me
06:52:19 <hpc> (x==True) == x
06:52:26 <Zao> if (x == true) return true; else return false;
06:52:29 <zygoloid> @check \b -> (\x -> if x then 1 else 0) b == fromEnum b
06:52:30 <lambdabot>   "OK, passed 500 tests."
06:52:33 <Jafet> > let true = False; false = True in map fromEnum [true, false, true, false, true, true]
06:52:34 <lambdabot>   [0,1,0,1,0,0]
06:52:44 <Phyx-> ave you guys all just hit your head
06:52:55 <Jafet> > map (const 1) [True, False, True, False, True, True]
06:52:55 <lambdabot>   [1,1,1,1,1,1]
06:54:12 <AAIBB^> i guess Jafets first suggestion works
06:54:56 <Zao> AAIBB^: Except it subtly attributes 0 to true and 1 to false.
06:55:06 <AAIBB^> hehe and i think there should be a shorter way
06:55:16 <AAIBB^> its only one command in R. I know this works different and all, but still
06:55:21 <Zao> (map fromEnum)
06:55:46 <Zao> Bool is an enumerable type with two enumerants, the first being False and the second being True.
06:55:57 <AAIBB^> ah you are right, map fromEnum works!!
06:56:38 <Zao> AAIBB^: His sillyness was because you had lowercase ctors (which you can't have).
06:57:39 <AAIBB^> like enum is something that works on a single entry, and map applies to every entry in the array?
06:58:00 <Botje> *list, but yes
07:00:30 <Mathnerd314> > (.) `asTypeOf` ($)
07:00:31 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
07:01:05 <Mathnerd314> Maybe I can use a typeclass?
07:01:19 <hpc> in lambdabot, (.) == fmap
07:01:29 <hpc> and ($) == id specialized to functions
07:01:40 <hpc> you aren't going to be able to get those to be the same
07:01:46 <aavogt> > [(Prelude..), ($)]
07:01:47 <lambdabot>   Not in scope: `Prelude..'
07:02:16 <Mathnerd314> hpc: I want a third character, (?) or something, which I can use in place of both (.) and ($)
07:02:22 <aavogt> > (+1) Prelude.. subtract 1 $ 2
07:02:23 <lambdabot>   Not in scope: `Prelude..'
07:02:36 <aavogt> where has the Prelude gone?
07:02:44 <aavogt> > (+1) $ Prelude.subtract 1 $ 2
07:02:45 <lambdabot>   2
07:02:57 <aavogt> > (+1) Prelude.(.) subtract 1 $ 2
07:02:58 <lambdabot>   Not in scope: data constructor `Prelude'
07:03:19 <aavogt> so it's not the new qualified op extension
07:03:29 <hpc> Mathnerd314: not going to happen; what would (mplus) ? (Just (Just 5)) do?
07:03:59 <Mathnerd314> :t mplus
07:04:00 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
07:04:06 <hpc> or rather, what would (!! 0) [[3, 4, 5]] do?
07:04:20 <hpc> it could return either 3 or [3,4,5]
07:04:33 <Mathnerd314> :t (!! 0)
07:04:34 <lambdabot> forall a. [a] -> a
07:04:36 <zygoloid> s/\) \[/) ? [/
07:04:54 <zygoloid> Mathnerd314: if you want a character which you can use in place of both (.) and ($), use ($).
07:05:25 <zygoloid> (or rather, use ($) if you would otherwise have used a mixture)
07:06:02 <Mathnerd314> hpc: Prelude.., not fmap
07:06:06 <zygoloid> i'd be happier reading code where you used the mixture, but if you want consistency it's not horrendously terrible
07:06:18 <aavogt> > map ((+1) . fromEnum) . map succ $ "works?"
07:06:19 <lambdabot>   [121,113,116,109,117,65]
07:06:26 <aavogt> > map ((+1) $ fromEnum) $ map succ $ "works?"
07:06:27 <lambdabot>   [121,113,116,109,117,65]
07:06:29 <hpc> Mathnerd314: my argument still applies then, albeit with a construed function type
07:06:41 <zygoloid> aavogt: haha, caleskel to the rescue!
07:06:58 <aavogt> @type (+1) $ fromEnum
07:06:59 <lambdabot> forall a. (Enum a) => a -> Int
07:07:11 <Mathnerd314> hpc: I'm pretty certain (.) and ($) shouldn't both work at once on a given type
07:07:16 <zygoloid> aavogt: applicative numbers :)
07:07:19 <hpc> (a -> a) -> a -> a
07:08:11 <Mathnerd314> hpc: that's ($)...
07:08:19 <zygoloid> id $ id  and  id . id  are both well-typed
07:08:28 <zygoloid> i think that was hpc's point.
07:08:29 <aavogt> @type (\p e -> (p $ e, p, e)) (+1) fromEnum
07:08:30 <lambdabot> forall a. (Enum a) => (a -> Int, (a -> Int) -> a -> Int, a -> Int)
07:08:31 <hpc> :t (id $ id)
07:08:31 <lambdabot> forall a. a -> a
07:08:34 <hpc> :t (id . id)
07:08:35 <lambdabot> forall a. a -> a
07:10:24 <hpc> :t ($) $ ($)
07:10:25 <lambdabot> forall a b. (a -> b) -> a -> b
07:10:30 <hpc> :t ($) . ($)
07:10:31 <lambdabot> forall a b. (a -> b) -> a -> b
07:10:58 <hpc> here we go
07:11:09 <hpc> Prelude> :t fmap $ fmap
07:11:11 <hpc> fmap $ fmap
07:11:13 <hpc>   :: (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
07:11:14 <hpc> Prelude> :t fmap . fmap
07:11:16 <hpc> fmap . fmap
07:11:18 <hpc>   :: (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:11:19 <hpc> there's the ambiguity
07:11:26 <hpc> what's the type of (fmap ? fmap)?
07:11:38 <hpc> (sorry for the big paste)
07:12:28 <Mathnerd314> hmmm... maybe it could be inferred?
07:12:41 <aavogt> @type [fmap $ fmap, \x -> fmap (fmap x)]
07:12:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = f1 (f a)
07:12:42 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
07:12:43 <lambdabot>     In the expression: fmap (fmap x)
07:13:13 <zygoloid> Mathnerd314: you're asking for a huge extension to the type system
07:13:50 <hpc> :t (.) . (.)
07:13:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:13:57 <hpc> :t (.) $ (.)
07:13:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
07:16:06 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26785#a26785
07:16:55 <zygoloid> you could go olegian and use something like: class Ap a b c d | c, b -> a, d where (?) :: (a -> b) -> c -> d; instance Ap b c (a -> b) (a -> c) where (?) = (.); instance NotFunction a => Ap a b a b where (?) = ($)
07:18:01 * zygoloid prefers avoiding implementation details of the type checker, though
07:19:25 * hpc thinks using classes to coerce things like that is gross
07:19:34 <Mathnerd314> Saizan: I don't understand what that's doing
07:20:23 <Saizan> Mathnerd314: not much actually, just showing the difference in types between id . id and id $ id
07:20:52 <hpc> id isn't really a good function to use to demonstrate differences, anyway
07:21:33 <hpc> it makes a lot of different functions look the same
07:27:49 <Mathnerd314> so, to construct a counterexample for me, it looks like we need a function of type (a -> a) -> a -> a that simultaneously is of type (a->a)
07:28:36 <zygoloid> Mathnerd314: hpc constructed a counterexample up there ^^, using 'fmap'.
07:30:02 <hpc> you can also construct a more concrete counterexample with (.)
07:30:18 <hpc> :t (Prelude.(.) . (Prelude.(.))
07:30:19 <lambdabot> parse error (possibly incorrect indentation)
07:30:33 <hpc> :t ((Prelude..) . (Prelude..))
07:30:34 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:30:47 <hpc> :t ((Prelude..) $ (Prelude..))
07:30:48 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
07:31:21 <danharaj> Oh god system f with impredicativity is complicated. How is type checking even decidable for that??
07:31:28 <Mathnerd314> hpc: I'm not seeing how that's a counterexample
07:31:46 <jmcarthur> is there a nice way to do something like this? say i have sort of a monad transformer FooT, and a stack (FooT (t (FooT m)) a). can i make it such that i can lift actions from (m a) and from (t (FooT m) a), but not from (FooT m a)? that is, i can lift from any monad except for FooT? i want to allow nested FooTs but not to allow access to any but the outter ones
07:31:57 <hpc> how is it not a counterexample? the types are different
07:32:16 <jmcarthur> it definitely can't implement lift proper
07:32:33 <Mathnerd314> hpc: the types are different, so you can infer by usage whether to use ($) or (.)
07:32:36 <zygoloid> danharaj: i think that's the reason why it's being removed/replaced in 6.14
07:32:42 <jmcarthur> it's kind of a strange transformer i know
07:33:05 <zygoloid> Mathnerd314: you're asking for some kind of implicit union type. that'd be a major type system extension
07:33:26 <zygoloid> unless it can be implemented with typeclasses somehow?
07:33:35 <hpc> Mathnerd314: alright, so what's the type of (?)
07:33:57 <hpc> and how can it have two different return types?
07:34:21 <zygoloid> if it has two return types, i think you're going to find you need to add a lot of type signatures to get things to compile.
07:34:37 <Mathnerd314> hpc: a typeclass, probably. (Stuff a b c) => a -> b -> c
07:35:00 <jmcarthur> my current solution is to provide an unsafeLift rather than a lift and have a precondition that you shouldn't lift from inner FooT unless that action has itself been lifted from deeper within
07:35:08 <hpc> what's the actual type though?
07:35:26 <danharaj> What does (?) do?
07:35:41 <hpc> (?) is Mathnerd314's hypothetical union of (.) and ($)
07:36:16 <danharaj> I don't get it.
07:36:33 <danharaj> could you elaborate?
07:36:37 <hpc> it does either (.) or ($), depending on what its parameters are
07:36:46 <hpc> and we are demonstrating it to be impossible
07:36:49 <zygoloid> Mathnerd314: if it's (Stuff a b c) => a -> b -> c, what are the fundeps of Stuff?
07:37:06 <zygoloid> Mathnerd314: if there are none, then: "id ? 42 :: Int" is ambiguous
07:37:38 <hpc> zygoloid: that wouldn't even typecheck
07:37:39 <jmcarthur> consider if the two arguments to this operator have these types:  ((a -> b) -> c)  and  (c -> d). either ($) or (.) could make sense
07:37:46 <hpc> id is (a -> a)
07:38:01 <hpc> er, wait it would
07:38:12 <jmcarthur> let me clean that up
07:38:34 <hpc> jmcarthur: that was my argument earlier; my example was fmap ? fmap
07:38:37 <jmcarthur> ah
07:38:39 <magicman> c;eara;;
07:38:41 <jmcarthur> nevermind then
07:38:43 <magicman> Blegh, soryr.
07:38:58 <magicman> *sorry (fingerfail this afternoon, apparently...)
07:39:21 <jmcarthur> :t \a b -> (a $ b, a . b)
07:39:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
07:39:23 <lambdabot>       Expected type: f a
07:39:23 <lambdabot>       Inferred type: a
07:39:40 <jmcarthur> bah infinite types
07:41:04 <Jafet> :t \a b -> (a Prelude.$ b, a Prelude.. b)
07:41:04 <lambdabot>     Occurs check: cannot construct the infinite type: a = a1 -> a
07:41:05 <lambdabot>     Probable cause: `b' is applied to too many arguments
07:41:05 <lambdabot>     In the second argument of `(GHC.Base..)', namely `b'
07:41:26 <magicman> And then there's the issue of what "f ? (g ? h)" should mean.
07:42:12 <Mathnerd314> magicman: it should be the same thing as (f ? g) ? h
07:42:28 <jmcarthur> then it can only be (.) for (?)
07:42:36 <jmcarthur> ($) is not associative
07:42:50 <magicman> Ah. Because "(f . g) $ h" and "f $ (g $ h)" mean the same thing.
07:42:55 <jmcarthur> oh
07:42:57 <jmcarthur> bah!
07:43:04 <Jafet> I once tried conceiving of a typed calculus with no parentheses. Each term has a type and an arity, and the compiler performs an exhaustive search to find a legal grouping of expressions
07:43:28 <magicman> (also written "f . g $ h" and "f $ g $ h")
07:43:28 <Mathnerd314> Jafet: how did it end up?
07:43:47 <Jafet> I decided I couldn't be bothered to write the first compiler for it
07:44:13 <hpc> i imagine it would be spectacularly slow for any nontrivial program
07:45:15 <jmcarthur> look ma, no parens! http://esolangs.org/wiki/Jot
07:45:38 <Jafet> All hail catalan
07:45:52 <Mathnerd314> jmcarthur: that doesn't have functions
07:46:02 <jmcarthur> huh?
07:46:06 <Jafet> Jot has nothing but functions.
07:46:06 <magicman> Neat!
07:46:13 <jmcarthur> yeah
07:46:16 <Mathnerd314> jmcarthur: lambdas, I mean
07:46:32 <jmcarthur> Mathnerd314: yeah, it's combinators. it has a very trivial conversion to the lambda calculus though
07:50:29 <Mathnerd314> hmm, maybe I could use rewrite rules
07:51:05 <jmcarthur> rewrite rules are not intended to change semantics
07:51:14 <Jafet> They've already shown you that it's impossible to implement, so I advise not trying to implement it
07:51:51 <Mathnerd314> Jafet: it's not impossible, it's just that GHC doesn
07:51:57 <Mathnerd314> 't infer the types
07:53:42 <Mathnerd314> so using polymorphic functions fails.
07:55:15 <Jafet> Well, unless you want to turn ghc into a compiler for some silly semantics like for the language I described
07:55:51 <Jafet> -XHighlyOptimisticTyping
07:55:52 <jmcarthur> it doesn't infer those types because they are *ambiguous*
07:56:26 <jmcarthur> unless you're basically going to do whole program analysis... and even then i bet there are theoretical problems
07:56:33 <HugoDaniel> is it possible to do cross compilation with haskell ?
07:56:43 <HugoDaniel> i want to produce an .exe of my code in linux
07:58:18 <Mathnerd314> jmcarthur: simple types like f :: Int -> Int; g :: Int -> Int; h = f ? g work
07:58:43 <jmcarthur> Mathnerd314: sure, because that case i unambiguous
07:58:46 <jmcarthur> *is
07:58:55 <ezyang> I'm getting confused between the category of Haskell values with endofunctors as arrows, and the category of endofunctors with natural transformations as arrows. 
07:59:10 <ezyang> Can someone unconfuse me? 
07:59:11 <Twey> As everybody does
07:59:14 <Twey> :þ
07:59:38 <jmcarthur> i can confuse you
07:59:44 <jmcarthur> not unconfuse you
07:59:50 <ezyang> :-( 
08:00:17 * Saizan never seen the first one used
08:00:19 <jmcarthur> it is better to be confused
08:00:48 <jmcarthur> because then you can't be wrong
08:01:12 <ezyang> Saizan: I came up with a plausible explanation that made monads monoids in the former category. 
08:02:20 <Saizan> ezyang: where objects are haskell values and arrows are type constructors? 
08:02:55 <Saizan> an example of such an arrow?
08:02:55 <FunctorSalad> ezyang: the concept(s) of 2-category let you put both together
08:03:07 <ezyang> Saizan: Not quite. 
08:03:27 <ezyang> FunctorSalad: What is a 2-category, anyway? A category with 2 objects? 
08:03:50 <FunctorSalad> (Hask is the single 0-cell we have, the endofunctors are the 1-cells, the NTs 2-cells... I just thought that up, so don't quote me on it :o)
08:04:29 <FunctorSalad> ezyang: a category with morphisms between morphisms, also called "2-cells"
08:04:40 <ezyang> ahh 
08:05:07 <FunctorSalad> (since, if you draw a diagram with 2 functors and an NT between them, the NT kinda fills a 2-d surface in the diagram)
08:05:40 <ezyang> clever. 
08:05:45 <FunctorSalad> one of the main examples is the cat of cats,functors,and natural transformations...
08:06:14 <ezyang> Oh, that's interesting. 
08:06:24 <ezyang> Hask's morphisms are functions 
08:06:30 <ezyang> but those don't form another category, do they 
08:06:34 <FunctorSalad> there are issues regarding which of the new laws are satisfied strictly, and which up to "coherent" isomorphisms, but I won't even try to open my mouth about that
08:07:15 <FunctorSalad> (this gives at least 2 definitions of 2-dimensional category.... "2-category" and "bicategory", "2-category" being the stricter one)
08:07:40 <danharaj> I thought bicategories were stricter?
08:07:40 <Sadache> I wonder what you guys think of this: http://gist.github.com/460064
08:07:58 <ezyang> Sadache: Nice number :-) 
08:07:59 <Sadache> definition on >>=
08:08:33 <Sadache> ezyang: oh! what a coinsedence. The content has a lot of 64s !
08:08:56 <FunctorSalad> "strict" in the higher-cat context has nothing to do with the one from semantics btw (or I haven't noticed it :)) it just means "axioms are satisfied with equality" (as opposed to these coherent isos)
08:09:11 <danharaj> yeah I thought bicategories were the equality ones.
08:09:25 <FunctorSalad> maybe there was something still laxer than bicats...
08:09:35 <FunctorSalad> but I'm pretty sure 2-cat are the completely strict ones
08:09:43 <danharaj> nevermind I just checked, bicategories are the weaker one
08:11:14 <Saizan> Sadache: what's represented with * -> * in the monad class is a functor, not a category
08:12:02 <Saizan> Sadache: btw, there are some monad-like constructions that require even more generality
08:12:21 <Sadache> Saizan: ok, I admit, I am pretty bad in category theory. 
08:12:44 <dpratt71> what does the pipe represent in Sadache's class declaration?
08:12:46 <Sadache> Saizan: but do you have any opinion about this definition?
08:12:57 <ezyang> FunctorSalad: What paranoia was that? 
08:13:00 <Sadache> dpratt71: functional dependency
08:13:09 <FunctorSalad> ezyang: wrong chan ;)
08:13:22 <Saizan> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed.html
08:13:22 <ezyang> whoops 
08:13:29 <dpratt71> Sadache: ok, thanks
08:13:46 <dpratt71> I shall 'Bing' that :)
08:14:03 <ezyang> Anyway, I think I have to say that I don't understand “Monads are monoids in the category of endofunctors.” 
08:14:21 <ezyang> I thought I did, but it looks like Id on't. 
08:16:13 <ezyang> I was imagining an object with many endofunctors of Hask forming arrows to itself, and the monad being able to compose the endofunctors associatively 
08:16:48 <ezyang> but this doesn't seem right now. 
08:16:57 <Saizan> it just means that it's an endofuctor M with two associated natural transformations (M x M) -> M, Id -> M, where (M x M) = /\a -> M (M a) that have to satisfy some monoid-like laws 
08:17:18 <ezyang> yeah, I'll have to think about that. 
08:17:31 <Saizan> (join and return, btw)
08:17:44 <ezyang> oh wait 
08:17:51 <ezyang> M x M -> M is a natural transformation? 
08:18:01 <ezyang> that seems to have too many functors in it. 
08:18:02 <Saizan> yeah, M is a functor there
08:18:03 <kdvh> if i wanted to use function composition and one of my functions took multiple parameters would it be: foo . bar a $ b?
08:18:09 <Saizan> (M x M) -> M
08:18:24 <ezyang> kdvh: if bar was the multiple param function 
08:18:38 <kdvh> yeah it is, thanks
08:18:42 <Saizan> in haskell it'd be "forall a. M (M a) -> M a"
08:18:51 <ezyang> yeah, that's Join. 
08:19:10 <Saizan> one functor is M composed with itself, the other functor is a single M
08:19:14 <ezyang> Hmm, I guess the monoidal join/return intuition was correct. Just the CT plumbing wasn't. 
08:19:29 <FunctorSalad> ezyang: you're aware it's a monoid in the generalized sense based on monoidal categories?
08:19:38 <ezyang> Yeah. 
08:19:45 <FunctorSalad> (pronounciation: not condescending ;))
08:20:17 <FunctorSalad> the confusing thing is mostly that we use functor composition as the monoidal product, not cartesian product as with vanilla monoids, imho
08:20:58 <ezyang> I'm using the definition of monoid as “a category with a single object, with the identity arrow as the unit and arrow composition as the binary operation” 
08:21:22 <ezyang> FunctorSalad: Since Haskell Monad and Monoid aren't the same kind. 
08:21:30 <ezyang> OH! 
08:21:39 <ezyang> Duh, M x M is itself a category 
08:21:48 <FunctorSalad> that one won't do I think; it just encodes ordinary monoids as cats, doesn't it?
08:22:03 <Saizan> yeah, that's the wrong one
08:22:06 <FunctorSalad> a monoidal category is much like that though, just one dimension higher
08:22:15 <ezyang> hmmm 
08:22:25 <Saizan> ezyang: you've to use this one: http://en.wikipedia.org/wiki/Monoid_(category_theory)
08:22:34 <FunctorSalad> (but that's more obscuring than helpful unless you like 2-cats a lot, I suspect)
08:22:58 <ezyang> I thought it was ok to regard monoids as categories with a single object 
08:23:01 <FunctorSalad> (it sweeps all the coherence issues under the rug of the analogous coherence issues for bicategories)
08:23:20 <monochrom> 2-lolcat is watching you unsafePerformMonad
08:23:35 <Saizan> ezyang: a category with a single object is a monoid, but a "monoid object" is not (or limited to) that
08:24:13 <ezyang> well, wouldn't the monoid object be arrows in that category? 
08:24:33 <Saizan> no, those would be elements of the monoid
08:24:36 <ezyang> I think I'm treating element == object which might not be correct. 
08:24:40 <ezyang> ok. 
08:24:50 <FunctorSalad> you need to read about monoidal categories first, the concept of "monoid" totally depends on it
08:25:08 <FunctorSalad> you know, in Set the monoid binop is an arrow M x M -> M...
08:25:20 <Saizan> a "monoid object" is the concept of Monoid from abstract algebra recasted into CT concepts
08:25:24 <FunctorSalad> the "x" is generalized, and further than to categorical products
08:25:37 <FunctorSalad> to so-called 'monoidal products'
08:25:43 <Sadache> so it seems that my gist is useless :)
08:26:48 <Saizan> well, are you using it for something?:)
08:27:01 <Phyx-> > 8
08:27:01 <FunctorSalad> once you have the monoidal category, you just transscibe the definition (in terms of diagrams) of the good old Set-monoid
08:27:01 <lambdabot>   8
08:27:14 <FunctorSalad> (replacing cart. product with the monoidal one)
08:27:41 <Sadache> nope :) I thought it could be a good idea to have more flexibility defining monads on * kinds
08:27:50 <ezyang> FunctorSalad: I,e,. any set-monoid can be turned into a monoidal category? 
08:27:51 <Sadache> never mind :)
08:28:30 <FunctorSalad> ezyang: hmm, the monoidal category in the ordinary case is Set
08:28:44 <FunctorSalad> with x as the monoidal product..
08:29:08 * ezyang is stuck in Set 
08:30:51 <FunctorSalad> (what you said could be done, but I think it'd be a bit misleading... the monoidal category plays the role of Set, not of the monoid)
08:31:54 <FunctorSalad> it's the ambient structure you need to define monoids
08:32:03 <ski> (FunctorSalad : we have not only `Hask' (i.e. `*') but also `* -> *', &c. ..)
08:32:19 <ezyang> erm, ok. 
08:32:36 <FunctorSalad> ski: hmm haven't thought about it :)
08:33:16 <FunctorSalad> Hask is conventionally just *?
08:33:23 <ski> one can easily define `class FunctorFunctor t where tmap :: forall f g. (Functor f,Functor g) => (forall a. f a -> g a) -> (forall a. t f a -> t g a)', e.g.
08:33:49 <FunctorSalad> *nod* done that ;)
08:33:50 <ski> `Hask' is the category of haskell types and functions between those types, afaik
08:34:17 <ski> where, "haskell types" here must mean "types with kind `*'"
08:35:25 <ezyang> Is the bifunctor that monoidal categories are equipped with an endobifunctor? 
08:35:27 <hpc> what's the difference between having "forall a." at the beginning versus in the middle?
08:35:28 <FunctorSalad> of course, it's just convention/names
08:36:04 <FunctorSalad> (you could always staple them together to one category, but I'm not saying this is useful ;))
08:36:20 <EvanCarroll> http://stackoverflow.com/questions/3155469/help-haskell-functors-sink-in 
08:36:24 <EvanCarroll> If anyone has anything else to add
08:36:27 <EvanCarroll> that would be great
08:36:46 <FunctorSalad> hpc: none as long as you only push the forall into a positive position
08:37:05 <FunctorSalad> (and don't make variables leave its scope in the process, obviously)
08:37:32 <FunctorSalad> forall a. X -> Y == X -> forall a. Y if a doesn't occur in X
08:37:37 * ezyang goes ahhhh 
08:37:39 <FunctorSalad> (I hope ;))
08:38:42 <gio12345> ?
08:39:16 <hpc> ah
08:39:24 <FunctorSalad> gio12345: is that @ me? I hope that I'm not making things up ;)
08:39:50 <gio12345> sorry, misprint, i was typeing elswhere
08:39:53 <FunctorSalad> but I was sure enough that I considered a relativization as a waste of bandwidth ;)
08:40:01 * hackagebot hfiar 2.1.1 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-2.1.1 (FernandoBenavides)
08:44:05 <FunctorSalad> hmm I get a lot of "delivery failed" messages from my community.haskell.org account, and I can't look at them because forced anti-virus is a new "feature" of my free mail provider :\
08:44:30 <FunctorSalad> I hope my account isn't compromised and these are just fake "delivery failed" spams?
08:44:30 <ski> ezyang : also note `forall a. (F a -> B)' is equivalent to `(exists a. F a) -> B'
08:45:29 <FunctorSalad> (the mail is redirected from the community.haskell.org address to the forced-anti-virus one)
08:46:17 <sproingie> AV or antispam?
08:46:25 <FunctorSalad> (pretty sure this is a deliberate malfeature to get people to switch to a paid account...)
08:46:41 <sproingie> i dont know of an AV that blocks bounces alone
08:46:59 <FunctorSalad> sproingie: AV, mostly "W32.Mydoom.M"
08:47:07 <hpc> FunctorSalad: it could be someone impersonating that address
08:47:17 <FunctorSalad> (it shows me the header and the alleged virus, but not the body of the msg :|)
08:47:33 <FunctorSalad> hpc: yeah that'd be my worry. Though I suppose someone would have complained by now
08:48:01 <sproingie> your address is probably being forged and you're getting bounces.  but really, mydoom?
08:48:05 <sproingie> that's like five years old
08:48:43 <FunctorSalad> hmm you mean it's forged without the account being compromised? IANAMC (mail cracker)
08:49:05 <Baughn> FunctorSalad: There is no validation of From: lines, you know..
08:49:08 <FunctorSalad> that'd make me not responsible at all, right?
08:49:18 <sproingie> means someone put you as the purported From: address, and a stupid receiver accepted it then bounced it back to you
08:49:30 <Baughn> FunctorSalad: Yep
08:49:31 <sproingie> barracuda boxen are notorious for that
08:49:41 <Baughn> There are also a lot of spammers that /pretend/ to be sending bounces
08:50:11 <sproingie> yeah forged bounces are also another one but those don't usually go mentioning viruses
08:50:15 <sproingie> let alone 5-year-old ones
08:50:41 <FunctorSalad> :)
08:50:54 <FunctorSalad> maybe their AV is misdetecting, who knows
08:50:58 <Baughn> Nuklearni-okurka: Well, glad to have you with us. I hope you'll take a look at RWH later, and don't hesitate to ask if you have installation (or any other) problems.
08:51:08 <sproingie> could be.  'course some viruses never really die out
08:51:25 <sproingie> heck CodeRed is still going around
08:51:34 <hpc> in my experience, no virus completely dies out
08:51:56 <hpc> there's always that one 80 year old who doesn't use antivirus and opens every email
08:52:08 <sproingie> boot sector viruses are probably no more :)
08:52:08 <hpc> and pays for XP antivirus every time that popup comes up, etc
08:52:10 <FunctorSalad> <some 5.25 disk from a dusty drawer> "what about me, you insensitive clod"
08:52:48 <sproingie> it's fossils like that that are the reason for forced AV
08:53:01 <FunctorSalad> (err, it's supposed to contain a virus that's extinct in the wild, if this was too contrived)
08:53:21 <sproingie> i'd be more worried about whether i could even read that floppy
08:53:49 <Baughn> I don't have any floppy disk drives
08:53:51 <Baughn> At all
08:54:06 <FunctorSalad> I don't have a built-in cd/dvd drive :p
08:54:11 <FunctorSalad> and never missed it
08:54:13 <sproingie> i have some 5.25" floppies in a box somewhere deep in my closet.  but no drive to read it on
08:54:17 <ski> (FunctorSalad : is the for a 1541 disk drive .. ?)
08:54:17 <Baughn> How do you do BIOS updates?
08:54:23 <sproingie> i don't even have my 3.5" drive connected
08:54:34 <sproingie> i do bios updates from a burned cd
08:54:45 <sproingie> FunctorSalad: lemme guess your desktop is a laptop?
08:54:46 <FunctorSalad> ski: uh no idea what the drivers were called, but wasn't this simply the standard before 3.5"?
08:55:10 <FunctorSalad> sproingie: yes, and it'd be a total waste of weight and space imho...
08:55:15 <Baughn> Before 3.5", 5.25" was the standard.. surely?
08:55:23 <ski> FunctorSalad : heh, the 1541 was the "standard" (external) disk drive for the Commodore 64 :)
08:55:26 <FunctorSalad> Baughn: hmm connect the usb cd drive?
08:55:28 <Baughn> I do have an old 8" FDD drive somewhere..
08:55:31 <sproingie> i remember my 1541 that was awesome
08:55:43 <FunctorSalad> (I meant "drives" btw, not drivers)
08:55:50 <ski> (which used 5.25" floppy disks .. i have a bunch of such somewhere)
08:56:07 <sproingie> that thing had enough of a computer in it that you could connect two of them together, load a mass duplicator program, then disconnect them from the computer and they would copy by themselves
08:56:18 <FunctorSalad> Baughn: the bios offer booting from various usb devices, if that's the issue
08:56:26 <ski> (sproingie : did you see a program that played music by moving the r/w head at different frequencies ? :)
08:56:31 <sproingie> drive music!
08:56:40 <sproingie> i used to use that to knock the heads BACK into alignment
08:56:58 <FunctorSalad> ski: ah. I only know them from the PC, never had a C64
08:57:03 <hpc> back when cpu clock speeds were lower, you could play music on a nearby radio using jumps and noops
08:57:18 <benmachine> sproingie: they could duplicate mass? I bet that came in handy
08:57:29 <sproingie> benmachine: tea.  earl grey.  hot.
08:57:34 <benmachine> :D
08:57:46 <sproingie> those commodore machines were ahead of their time
08:57:57 <ski> (iirc, the CPU of the 1541 was actually clocked faster than the one for the 64)
08:58:31 <ski> (it was basically the same CPU, except the 64 had an extra I/O port)
08:58:44 <sproingie> yah there were apps to use it as a coprocessor.  not too useful except for batch stuff tho, the bus would have been achingly slow
08:59:36 <flabron> hi. I must use IO () to read a int n from keyboard and then print in the screen the numbers since 1 to n (one by line). How can i do this? i'm a bit lost :/
09:00:02 <sproingie> is this homework?
09:00:28 <Saizan> what have you tried so far?
09:00:29 <flabron> no, school already finish it lol. i'm just studing
09:00:48 <flabron> i tried something like this func n = do putStr(n "\n")
09:00:49 <flabron> 		 func n-1
09:01:26 <monochrom> I want to do someone's homework!
09:01:36 <sproingie> you can do my work work if you want
09:01:40 <monochrom>  ← bored
09:01:44 <sproingie> perl or java, take your pick
09:01:56 <monochrom> func (n-1)
09:01:59 <hpc> that's a cruel dillema
09:02:04 <Saizan> flabron: aside from the use of tabs that's generally discouraged, you want "func (n-1)" otherwise it gets parsed as "(func n) - 1"
09:02:07 <monochrom> java is better
09:02:20 <monochrom> (I mean for me subjectively)
09:02:27 <sproingie> well with java i have some hope of using better languages
09:02:44 <hpc> with java you can link to clojure or something
09:02:54 <sproingie> tho i'm integrating with stuff like drools which does a lot of dynamic compilation so in reality using scala or clojure or whatnot is less likely
09:03:06 <Saizan> flabron: also "putStr (n "\n")" won't typecheck, since (n "\n") is trying to apply a number to a String there, you want "putStr (show n ++ "\n")" instead
09:03:07 <monochrom> (just two things that make java better than perl for me: I am comfortable with eclipse; perl's $#% bugs me)
09:03:18 <flabron> what the not in scope error means?
09:03:22 <hpc> or print n
09:03:24 <hpc> @src print
09:03:24 <lambdabot> print x = putStrLn (show x)
09:03:28 <Saizan> flabron: btw, putStr (show n ++ "\n") = putStrLn (show n) = print n
09:04:11 <aristid> i actually think print = putStrLn . show is more readable than print x = putStrLn (show x)
09:04:12 <sproingie> perl's notion of scalars bugs me as does the awful extra sigil nonsense i'm forced to use if i want to do something as simple as nest lists
09:04:27 <hpc> sigils are bullshit, to be sure
09:04:34 <monochrom> "not in scope" means you use a name but it is not defined.
09:04:38 <monochrom> > 1 + monochrom
09:04:39 <lambdabot>   Not in scope: `monochrom'
09:04:44 <monochrom> like that
09:04:53 <c_wraith> @let monochrom = (-1)
09:04:54 <lambdabot>  Defined.
09:04:58 <monochrom> > 1 + monochrom
09:05:00 <lambdabot>   0
09:05:04 <sproingie> php cuts down on most of the sigils but breaks everything else
09:05:06 <monochrom> now it is accepted
09:05:17 <hpc> perl is definitely better than php
09:05:22 <sproingie> python's all right, can't stand the community tho
09:05:33 <sproingie> well at least a good chunk of it
09:05:34 <hpc> perl hashes are magic
09:05:50 <aristid> sproingie: well perl has its share of ugly, but it's definitely to be rather productive with it
09:05:57 <aristid> +possible
09:06:29 <sproingie> there's an aggressive strain of simultaneous self-righteousness and anti-intellectualism in much of the python community
09:06:54 <Saizan> i wonder where that comes from
09:07:04 <hpc> the idea of there only being one right way to do something is frustrating too
09:07:10 <monochrom> the python community comes from evolution
09:07:15 <sproingie> hpc: even though that's increasingly not so
09:07:29 <sproingie> heck python often gives me options perl doesn't
09:07:48 <sproingie> but yah there's still an attitude that there *should* only be one right way
09:08:09 <FunctorSalad> it depends? ;)
09:08:24 <Saizan> can you mess with the bytecode and variable names in perl as much as in python?
09:08:31 <hpc> the one right way is humorously not always the optimal way either
09:08:51 <sproingie> Saizan: yes, even more so than python, but it is deep and horrible magic
09:09:17 <FunctorSalad> some things seem to benefit from normalization, others from variety... haven't quite put my finger yet on what essential property determines it :)
09:09:47 <Saizan> sproingie: too bad
09:10:10 <monochrom> confluent things benefit from normalization, others from variety. :)
09:10:32 <sproingie> i could do with a normalized record syntax in haskell that didn't suck
09:10:53 <sproingie> (i.e. the built-in one sucks)
09:11:01 <FunctorSalad> monochrom: confluent wrt to which relation? but I think I just thought something similar.... you need normalization to tie-break between many equally-good choices (or nearly equally good)
09:11:23 <FunctorSalad> (a priori equally good, not taking into account existing use)
09:11:36 <monochrom> I am just joking, but "confluent" as in "the lambda calculus is confluent"
09:11:39 <FunctorSalad> oh, you meant church-rosser and stuff I guess
09:11:40 <FunctorSalad> ;)
09:11:52 <monochrom> It's tautological :)
09:12:07 <sproingie> tautology cat is tautological
09:12:14 <monochrom> "normalizable things benefit from normalization" XD
09:12:29 <benmachine> sproingie: perl, deep and horrible magic? what an unusual combination.
09:12:31 <FunctorSalad> (one example would be which of 0 and 1 should represent true and which false)
09:12:41 <FunctorSalad> ;)
09:12:51 <hpc> monochrom: that's not tautological; it translates to "normalization is beneficial"
09:13:20 <FunctorSalad> (or file formats with similar features...)
09:13:31 <monochrom> I am just joking again. tautological as in ha-ha-tautological
09:13:42 <FunctorSalad> whereas normalization is bad where it stifles new things that are *different*
09:13:51 <FunctorSalad> (I guess...)
09:15:36 <hpc> you can't normalize things that are different though, can you?
09:15:53 <sproingie> if you find what they have in common
09:16:00 <sproingie> i guess that's "factoring"
09:16:35 <benmachine> hpc: you can try!
09:16:51 <hpc> or do you mean "normalizing away an alternate approach that might inspire a better solution"?
09:16:52 <sproingie> haskell to me represents a brutal refactoring.  implicit flow control?  pah, we abstracted that out long ago.
09:18:49 <benmachine> hpc: the process probably involves squishing both things into a shape that neither really should be and then emulsifying them somehow
09:19:20 <sproingie> kind of like raspberry aoli
09:19:21 <hpc> @wn emulsify
09:19:22 <lambdabot> *** "emulsify" wn "WordNet (r) 2.0"
09:19:22 <lambdabot> emulsify
09:19:23 <lambdabot>      v 1: cause to become an emulsion; make into an emulsion [ant: {demulsify}]
09:19:23 <lambdabot>      2: form into or become an emulsion; "The solution emulsified"
09:19:23 <lambdabot>         [ant: {demulsify}]
09:19:24 <lambdabot>      [also: {emulsified}]
09:19:30 <hpc> @wn emulsion
09:19:31 <lambdabot> *** "emulsion" wn "WordNet (r) 2.0"
09:19:31 <lambdabot> emulsion
09:19:31 <lambdabot>      n 1: (chemistry) a colloid in which both phases are liquids; "an
09:19:32 <lambdabot>           oil-in-water emulsion"
09:19:34 <lambdabot>      2: a light-sensitive coating on paper or film; consists of fine
09:19:36 <lambdabot>         grains of silver bromide suspended in a gelatin [syn: {photographic
09:19:38 <lambdabot>         emulsion}]
09:19:46 <sproingie> mayonnaise
09:20:50 <hpc> benmachine: so like deforming the algorithms until they have similar pieces
09:21:43 <hpc> like a primality test and a primes list generator; not using a sieve because you want to reuse the primality test
09:21:43 * benmachine shrug
09:21:45 <hpc> sort of
09:21:56 <benmachine> I am largely just being silly but yes maybe
09:22:44 <benmachine> (wrt emulsify: I believe emulsifiers in food are additives used to keep mixtures... mixed, somehow)
09:23:39 <mreh> mayonnaise is oil in egg whites
09:23:57 <mreh> > cake
09:23:58 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
09:24:49 <sproingie> > cake !! 20
09:24:50 <lambdabot>   "Fiberglass surface resins."
09:24:54 <aristid> > sort cake
09:24:55 <lambdabot>   ["Adjustable aluminum head positioner.","Alpha resins.","An entry called 'h...
09:25:20 <c_wraith> > reverse . sort $ cake
09:25:21 <lambdabot>   ["Unsaturated polyester resin.","Two tablespoons rhubarb juice.","Two slash...
09:25:38 <hpc> > reverse cake
09:25:39 <lambdabot>   ["That will deodorize and preserve putrid tissue.","And it contains proven ...
09:26:05 <mreh> is this from the game portal?
09:26:17 <sproingie> yep
09:26:41 <mreh> portal 2 looks mad
09:26:46 <mreh> *ahem*
09:26:48 <mreh> carry on
09:27:34 <ddarius> > length cake
09:27:35 <lambdabot>   42
09:28:13 <c_wraith> of course. :)
09:28:41 <c_wraith> > map head cake
09:28:42 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
09:28:49 <hpc> ASCIICAT
09:28:59 <danharaj> Messages within messages.
09:29:20 <sproingie> apparently people have made the cake from the part that is legit and it really is delicious and moist
09:29:28 <sproingie> and overpoweringly rich
09:29:39 <mreh> and then it sends them insane
09:29:57 <aristid> > map (filter (`notElem` "aeiouAEIOU")) cake
09:29:58 <lambdabot>   ["n 18.25 nc pckg chclt ck mx.","n cn prprd ccnt pcn frstng.","Thr slsh fr ...
09:30:04 <sproingie> it starts with chocolate cake mix then proceeds to add the rest of the ingredients as if the mix were just flour
09:30:25 <mreh> it's not instructions to make a cake is it?
09:30:32 <mreh> just a list of ingredients
09:30:40 <aristid> > text $ concat cake
09:30:41 <lambdabot>   One 18.25 ounce package chocolate cake mix.One can prepared coconut pecan f...
09:30:53 <sproingie> hm i dont think it has cooking instructions.  implementation detail i guess.
09:31:05 <ddarius> Why does python have a module called "shelve"?
09:31:05 <mreh> > intercalate " " cake
09:31:07 <lambdabot>   "One 18.25 ounce package chocolate cake mix. One can prepared coconut pecan...
09:31:08 <hpc> > unwords cake
09:31:08 <sproingie> http://www.recipezaar.com/recipe/Cake-from-Portal-264919
09:31:08 <lambdabot>   "One 18.25 ounce package chocolate cake mix. One can prepared coconut pecan...
09:31:45 <sproingie> ddarius: it's a persistent (as in to storage) dict.  bringing it up in #python produces one of their usual fun fits of apoplexy.
09:32:45 <aristid> sproingie: "apoplexy" means "pain"?
09:32:56 <mreh>  #pythons sounds like a riot
09:33:03 <sproingie> aristid: naw, means "hysterical angry freak out"
09:33:06 <mreh> apoplexy is like a fit
09:33:11 <sproingie> fit yeah
09:33:31 <danharaj> apoplexy is a fun word
09:33:47 <danharaj> ...apoplexomorphism?
09:33:55 <sproingie> it's one of those words that makes you wipe off your monitor when you say it out loud
09:34:50 <ddarius> sproingie: I know what it is, I don't know why it is called that.  It seems like it should be called "shelf".
09:34:59 <aristid> a zygohistomorphic apoplexomorphism
09:35:08 <sproingie> shelve is a verb.  i guess they liked the verb.
09:35:24 <ddarius> sproingie: I know it is a verb, but they liked it just in this case?
09:35:28 <mreh> yo gize, I can program python innit
09:35:34 <sproingie> i think even the class is called a shelve tho.  maybe the author had poor english
09:35:39 <mreh> it's like street corner in that room
09:35:43 <danharaj> How many things in Python have names that make sense?
09:35:57 <danharaj> It seems like every other time I hear about a python library it has a name that is completely non descriptive.
09:35:59 <sproingie> i like pickle.  i think Modula-3 coined that one.
09:37:41 <AAIBB^> guys how do i specify i want a row as input.. its giving me errors when linking a row to the function, but putting [1,2,31,1,1,3,1] does work
09:37:52 <mreh> what happens when Guido or Larry dies?
09:37:58 <mreh> is there a coup?
09:38:17 <Botje> AAIBB^: can you put your code online?
09:38:21 <AAIBB^> yeah
09:38:25 <Botje> mreh: larry is busy implementing perl6
09:38:31 <sproingie> larry is hardly a prolific perl hacker these days anyway
09:38:37 <aristid> mreh: well when guido dies, there will be a revolt, and tail-call optimization will be implemented.
09:39:12 <danharaj> That's assuming Python stays around for that long.
09:39:13 <sproingie> larry isn't implementing perl6, he got busy issuing cryptic epigrams that had to be interpreted for meaning, then he stood back and watched the chaos unfold
09:39:21 <mreh> a python eating it's own tail, how life imitates art
09:39:24 <AAIBB^> now watch out with thuemorse because its an infinite sequence botje 
09:39:26 <AAIBB^> http://pastebin.com/AA7fCnVB
09:40:13 <sproingie> i dunno who'd take over after guido.  my first guess is andrew kuchling
09:40:14 <mreh> I remember when larry was talking about post-modernism and perl, so I stopped reading the article
09:41:01 <AAIBB^> botje try in putting >  continuedfrac (take 50 thuemorse2) it gives errors but when you copy paste the result for take 50 thuemorse into continuedfrac then it works
09:41:23 <benmachine> AAIBB^: I recommend explicit type signatures
09:41:25 <sproingie> first thing i'd do if i took over python would be to decree there would be no more 2.x versions
09:42:06 <benmachine> first thing I'd do if I took over python would be screw it up because I know nothing about programming language design
09:42:08 <sproingie> then i'd actually implement a typechecker that used those completely unused function annotations
09:42:15 <sproingie> benmachine: you could hardly do worse
09:42:21 <benmachine> I could!
09:42:23 <benmachine> I could do PHP
09:42:33 <sproingie> i don't think you've huffed enough paint
09:44:45 <flabron> i got "do n<- getLine n1<-returned((read n)::[Int])" how i make a list like [1..n] now?
09:45:11 <AAIBB^> benmachine: i know how to do those in java but i dont understand how i'd fix it here
09:45:35 <benmachine> AAIBB^: how are you learning haskell?
09:46:02 <AAIBB^> Learn you a haskell for great good!
09:46:07 <benmachine> oh right
09:50:12 <benmachine> AAIBB^: at the ghci prompt, try using the :t command to see the types of stuff
09:50:39 <benmachine> like, :t variablename or :t functionname
09:50:46 <illissius> swap hell = worst ever.
09:51:12 <benmachine> flabron: I don't know what you mean or what you are doing, more context would help
09:51:18 <monochrom> @let swap hell = (snd hell, fst hell)
09:51:20 <lambdabot>  Defined.
09:51:26 <AAIBB^> thanks
09:51:29 <monochrom> > swap (4,True)
09:51:31 <lambdabot>   (True,4)
09:51:46 <monochrom> > swap ("ever", "worst")
09:51:47 <lambdabot>   ("worst","ever")
09:51:56 <monochrom> @undefine
09:52:03 <hpc> :t swap
09:52:04 <lambdabot> Not in scope: `swap'
09:52:17 <hpc> isn't that a standard function already?
09:52:21 <monochrom> I have just erased it.
09:52:24 <monochrom> No.
09:52:37 <AAIBB^> I seem to be trying to put [Integer] into a function (Fractional a) => [a] -> Int -> a
09:52:38 <ski> AAIBB^ : `thuemorse2 :: Num a => [a]'
09:52:39 <hpc> @hoogle (a,b) -> (b,a)
09:52:39 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:52:39 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
09:52:39 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
09:52:41 <flabron> benmachine, basicaly with those lines i got an input number and i want to make a list like [1..n] so i can print one by one
09:53:01 <benmachine> flabron: so do it?
09:53:08 <benmachine> > let n = 7 in [1 .. n]
09:53:09 <lambdabot>   [1,2,3,4,5,6,7]
09:53:17 <jmcarthur> @let swap = snd &&& fst
09:53:18 <lambdabot>  Defined.
09:53:36 <aristid> :t swap
09:53:37 <lambdabot> forall a c. (a, c) -> (c, a)
09:53:49 <hpc> > map (\n -> [1..n]) [1..]
09:53:50 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
09:54:19 <benmachine> > case swap undefined of (a, b) -> ()
09:54:19 <AAIBB^> benmachine: how is it bad to put [Integer] into a function that appears to be eating [a]
09:54:20 <lambdabot>   ()
09:54:30 <ski> AAIBB^ : alternatively, if you're using GHC, add `{-# LANGUAGE NoMonomorphismRestriction #-}' to the top of your file
09:54:47 <AAIBB^> i am using winGHCi
09:54:50 <benmachine> AAIBB^: it isn't, there must be some other problem
09:54:53 <AAIBB^> so that counts as GHC i guess
09:55:01 <hpc> > swap undefined
09:55:02 <lambdabot>   (*Exception: Prelude.undefined
09:55:26 <benmachine> AAIBB^: Integers aren't Fractional
09:55:40 <flabron> benmachine, why 7 on the let ?
09:55:48 <benmachine> flabron: why not
09:56:17 <benmachine> flabron: just an example to show the thing on the right of the .. can be any expression
09:56:19 <monochrom> why start with 1? :)
09:56:20 <AAIBB^> But well.. integers pretty much are a subset of fractionals
09:56:20 <benmachine> (of the right type)
09:56:32 <AAIBB^> OHH ic now
09:56:36 <AAIBB^> sec
09:56:52 <hpc> the thing on the left of the .. can be an expression too, can it not?
09:56:55 <flabron> benmachine, oh i see. thank you! 
09:56:56 <benmachine> yep
09:56:59 <sproingie> > ['a'..'z']
09:57:01 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
09:57:09 <sproingie> > ['False'..'True']
09:57:11 <lambdabot>   <no location info>:
09:57:11 <lambdabot>      lexical error in string/character literal at chara...
09:57:12 <sproingie> darg
09:57:19 <sproingie> > [False..True]
09:57:19 <benmachine> > [False ..]
09:57:20 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
09:57:20 <lambdabot>   [False,True]
09:57:28 <hpc> > map (\n -> [1,n,..]) [2..]
09:57:29 <lambdabot>   <no location info>: parse error on input `..'
09:57:35 <benmachine> sproingie gets screwed by hierarchical module syntax :(
09:57:36 <hpc> > map (\n -> [1,n..]) [2..]
09:57:37 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
09:57:38 <AAIBB^> haskell uses a line in front of the function itself to declare type i guess? the function :: [type] -> something
09:58:01 <benmachine> AAIBB^: it doesn't have to be in front of the function but that's usual
09:58:02 <jmcarthur> a line?
09:58:03 <hpc> > map (\n -> [1,n..5]) [2..]
09:58:04 <lambdabot>   [[1,2,3,4,5],[1,3,5],[1,4],[1,5],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1...
09:58:13 <AAIBB^> cool
09:58:16 <jmcarthur> oh, a type signature
09:58:23 <AAIBB^> once again thanks everyone
09:59:51 <monochrom> map (\n -> [floor (sin (2*pi* fromIntegral n)) .. floor (sin (2*pi* fromIntegral n + pi/2))])  [0,1,2,3,4]
09:59:56 <monochrom> > map (\n -> [floor (sin (2*pi* fromIntegral n)) .. floor (sin (2*pi* fromIntegral n + pi/2))])  [0,1,2,3,4]
09:59:58 <lambdabot>   [[0,1],[-1,0,1],[-1,0,1],[-1,0,1],[-1,0,1]]
10:00:30 <monochrom> you can put the type sig line after.
10:00:47 <monochrom> you can put it 100 lines away.
10:01:37 <monochrom> > let {x = f 0; f y = y+1; x :: Integer; f :: (Num a) => a -> a} in x
10:01:39 <lambdabot>   1
10:02:27 <djahandarie> I didn't know you could use {} for let
10:02:41 <djahandarie> Totally makes sense though
10:02:51 <monochrom> it is indispensible in one-line environments like this
10:02:53 <hpc> {x,y} is sugar for x \n y, where \n is a newline
10:02:56 <c_wraith> you can use {} for anything that takes a block.  even module .. where {}
10:03:01 <djahandarie> Yeah
10:03:05 * djahandarie just realized that pattern
10:03:06 <monochrom> it is not like I can do layouts with lambdabot
10:03:14 <sproingie> that'd be {x;y}
10:03:22 <hpc> er, right
10:03:59 <benmachine> the sugar is kind of the other way around >_>
10:04:07 <benmachine> well I guess each is equally valid
10:04:28 <djahandarie> Everything is sugar!!!
10:05:00 <hpc> djahandarie: Haskell is the american food industry?
10:05:12 <sproingie> syntactic HFCS
10:05:39 <c_wraith> yeah.  american foods don't use *sugar*.  that'd be supporting cuba!
10:05:43 <zygoloid> benmachine: not really equally valid. do { let x = 0; return x } is invalid, but would presumably be OK with the {;}-desugars-to-\n interpretation
10:06:43 <monochrom> > do { let x = 0; return x } :: [Integer]
10:06:44 <lambdabot>   <no location info>: parse error on input `}'
10:07:21 <monochrom> oh haha, yeah
10:07:24 <c_wraith> > do { let {x = 0}; return x } :: [Integer]
10:07:25 <lambdabot>   [0]
10:07:54 <sproingie> so is let slurping up the ; or something?
10:08:01 <c_wraith> yes
10:08:12 <monochrom> it thinks do { let {x=0; return x} }
10:08:47 <sproingie> > { 123 }
10:08:49 <lambdabot>   <no location info>: parse error on input `{'
10:14:35 <benmachine> > do { let x = 0; return x; }
10:14:36 <lambdabot>   <no location info>: parse error on input `;'
10:14:41 <benmachine> ic
10:14:52 <benmachine> > do { let { x = 0 }; return x; }
10:14:53 <lambdabot>   No instance for (GHC.Show.Show (m a))
10:14:54 <lambdabot>    arising from a use of `M3176181922...
10:15:01 <benmachine> same diff
10:15:08 <Twey> > do { let x = 0; x }
10:15:09 <lambdabot>   <no location info>: parse error on input `}'
10:15:16 <Twey> > do { let { x = 0 }; x }
10:15:17 <lambdabot>   0
10:15:26 <benmachine> crafty
10:15:32 <Twey> Look ma, no monads
10:15:50 <ben> So what do you guys do for GUIs these days
10:15:53 <Twey> > do 123
10:15:53 <lambdabot>   123
10:16:01 <Twey> ben: Still Gtk2Hs mostly :-\
10:16:06 <ben> > do do do 123
10:16:07 <lambdabot>   123
10:16:11 <hpc> :t do
10:16:11 <ben> Hahaha
10:16:12 <lambdabot> Empty 'do' construct
10:16:27 <hpc> > do 123 >> 456
10:16:28 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
10:16:28 <lambdabot>    arising from a u...
10:16:46 <hpc> > do '7'
10:16:46 <lambdabot>   '7'
10:16:57 <hpc> freaky
10:17:15 <zygoloid> @type let wop = id in do wop wop wop $ do do wop wop
10:17:16 <lambdabot> forall a. a -> a
10:18:35 <Phyx-> @undef
10:18:39 <Phyx-> > do '7
10:18:40 <lambdabot>   <no location info>:
10:18:40 <lambdabot>      lexical error in string/character literal at end o...
10:18:42 <Phyx-> > do '7'
10:18:43 <lambdabot>   '7'
10:18:49 <Phyx-> what the..
10:19:14 <Twey> Phyx-: ‘do x’ desugars to ‘x’, which doesn't require a monad
10:19:31 <Phyx-> Twey: ah, right
10:19:34 <Twey> do-notation doesn't impose any additional type constraints: it really is just sugar.
10:19:37 <zygoloid> iirc older versions of GHC required that the type of a do-statement to be 'm a', but didn't enforce the Monad constraint
10:19:46 <zygoloid> do-expression, rather :)
10:20:25 <zygoloid> (you could write "do Data.Set.fromList []" but not "do 42 :: Int")
10:21:01 <davekong> Apes: I found you can set :make to compile programs for you in vim using ghc instead of make... see :help makeprg in vim
10:21:07 <jmcarthur> do notation writes in whatever (>>=) and return are in scope
10:21:11 <jmcarthur> oh, and fail
10:21:22 <Twey> Really?  Cool
10:21:25 <jmcarthur> with NoImplicitPrelude you can override them
10:21:46 <benmachine> jmcarthur: I think if you don't use NoImplicitPrelude then they use Prelude.>>= etc.
10:21:52 <jmcarthur> nope
10:21:53 <Twey> > let (>>) = (+) in do { 5; 3 }
10:21:54 <hpc> or with import qualified Prelude
10:21:54 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
10:21:54 <lambdabot>    arising from a u...
10:21:55 <jmcarthur> i'm done it
10:21:57 <jmcarthur> *i've
10:21:59 <Twey> Aww.
10:22:06 <benmachine> hmm
10:22:09 <jmcarthur> Twey: need NoImplicitPrelude
10:22:10 <hpc> huh
10:22:19 <Twey> jmcarthur: Surely not
10:22:22 <Twey> jmcarthur: I shadowed them
10:22:24 <jmcarthur> i think import qualified Prelude won't work
10:22:31 <benmachine> nor import Prelude ()
10:22:40 <jmcarthur> Twey: i think NoImplicitPrelude changes how do notation works
10:22:41 <Twey> Unless it uses Prelude.>>
10:22:44 <Twey> Ah
10:23:19 <benmachine> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#rebindable-syntax
10:23:57 <jmcarthur> so we have that for do notation and OverloadedStrings for string literals and fromIntegral for integer literals, etc... i want to overload list notation next!
10:24:06 <jmcarthur> implicit fromList
10:24:17 <benmachine> heh
10:25:27 <jmcarthur> foo :: IntSet ; foo = [1,2,3,4,5]
10:26:23 <jmcarthur> oh and i have a preprocessor for overloading whitespace, but you have to be careful with it or you can make types very ambiguous
10:28:50 <FunctorSalad> funny out-of-context statement
10:29:07 <FunctorSalad> (overloading whitespace, what could possibly go ambiguous? ;))
10:29:15 <djahandarie> lol
10:29:29 <magicman> Overloaded newlines ftw!
10:29:32 <FunctorSalad> (I mean this is the first message I read in this window)
10:29:59 <FunctorSalad> magicman: significant \r\n vs \n?
10:30:00 <djahandarie> > let (>>) = (++) in do { [10]; [11] }
10:30:01 <lambdabot>   [11]
10:30:04 <magicman> Of course!
10:30:09 <djahandarie> lol :-(
10:30:47 <magicman> It has never been easier to make compile-time errors OS-specific :P
10:30:51 <djahandarie> > let (Prelude.>>) = (++) in do { [10]; [11] }
10:30:51 <djahandarie> Heh
10:30:52 <lambdabot>   <no location info>:
10:30:52 <lambdabot>      Qualified name in function definition: Prelude.>>
10:31:04 <djahandarie> I knew that wouldn't work but felt like trying anyways :P
10:33:14 <magicman> Yeah, I'm staying away from rebinding do-syntax.
10:33:18 <davekong> Anyone have a good vim error format string for ghc?
10:33:33 <FunctorSalad> hmm the default seems to sort-of work
10:33:38 <FunctorSalad> the default with the haskell plugin I mean
10:33:54 <magicman> instance (Read a) => IsString a where {fromString = read} -- works for me >_>
10:36:50 <FunctorSalad> magicman: that's nothing! fromString x = read (unsafePerformIO (readProcessSystem "ghc" ["-e",x] ""))
10:37:05 <FunctorSalad> too bad you don't keep the current context
10:37:24 <magicman> XD You win.
10:37:25 <FunctorSalad> s/ProcessSystem/Process/
10:37:39 <FunctorSalad> (had rawSystem first, but that doesn't return the output iirc)
10:42:23 <magicman> I also didn't know about the -e flag, so that's cool :D
10:43:43 <davekong> hmm I think I like the default more than what the plugin uses... it needs to break lines
10:46:11 <bos> dcoutts_: ping
10:46:18 <dcoutts_> bos: pong
10:46:40 <bos> dcoutts_: how do i set the default value of a flag in a .cabal file based on platform?
10:46:53 <dcoutts_> bos: I don't think that is possible
10:47:07 <bos> dcoutts_: :-(
10:47:28 <bos> dcoutts_: i thought i'd have another crack at the old "you can't build criterion on OS X due to lack of gtk" problem
10:47:45 <bos> dcoutts_: so i guess i could hack with with a configure script
10:48:02 <dcoutts_> bos: how would a configure script help?
10:48:28 <bos> dcoutts: i could do something like "default: @IS_THERE_ANY_SIGN_OF_GTK@"
10:48:48 <dcoutts_> bos: you can't preprocess .cabal files
10:49:05 <bos> dcoutts_: but i could put that in a .buildinfo, no?
10:49:10 <bos> dcoutts_: or will that break too?
10:49:21 <dcoutts_> bos: flags do not appear in .buildinfo files
10:49:27 <bos> arse.
10:50:45 <dcoutts_> bos: I'm just checking if there's a ticket for the default thing
10:50:58 <dcoutts_> bos: the other solution is a better dep planner in cabal-install
10:51:12 <bos> dcoutts_: ah, the nuclear option :-)
10:51:31 <dcoutts_> bos: "is there any sign of gtk" would not be something you could put in a default anyway
10:51:51 <dcoutts_> at least I don't think so
10:51:52 <bos> dcoutts_: i know, but it would be enough to just say "default False on darwin, True elsewhere"
10:52:30 <dcoutts_> bos: do you really need gtk or is it just cairo you need?
10:53:04 <bos> dcoutts_: i don't know for sure. i'm using the chart library.
10:53:20 <bos> dcoutts_: so i need whatever it needs, which i believe is both.
10:53:43 <dcoutts_> aye it seems to use both
10:53:58 <dcoutts_> probably so it can pop up a window rather than just produce a png or something
10:54:07 <dcoutts_> it could probably be factored not to need gtk
10:54:17 <bos> that's right.
10:54:43 <dcoutts_> looks like it's only one convenience function in Graphics.Rendering.Chart.Gtk
10:55:26 <davekong> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg04764.html Is the best I have found so far
10:55:56 <dcoutts_> bos: looks like there's no feature request for expressions in flag defaults
10:56:18 <dcoutts_> bos: I don't think there's any problem in principle with allowing them, I don't think it'd break the configuration model
10:56:27 <bos> dcoutts_: i see.
11:01:38 <Phyx-> anyone know in a data HsBindLR is that the desugared syntax for functions? e.g. multiple defitions are moved to a single one with case expressions?
11:04:02 <Phyx-> the GHC internals is like on big blackbox with not even docs at times to hang yourself with :/
11:04:06 <zygoloid> dcoutts_: edwardk would like admission but he's blocked by the gateway/web/freenode ban
11:04:17 <zygoloid> can it be removed?
11:04:53 <zygoloid> @where ops
11:04:54 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
11:05:25 <dcoutts_> zygoloid: I don't know why it was imposed so I'm reluctant to remove it
11:05:35 <zygoloid> dcoutts_: we were getting spammed a few hours back
11:05:45 <danharaj> the spam still persists?
11:05:50 <Phyx-> add an exemption for edwardk then?
11:06:04 <Phyx-> freenode supports +e doesn't it?
11:06:11 <zygoloid> he's c72ec6e6@gateway/web/freenode/ip.199.46.198.230
11:06:20 <danharaj> unsafeCoerce edwardk
11:08:12 --- mode: ChanServ set +o jmcarthur
11:08:20 <zygoloid> it seems pretty quiet in ##overflow; i suspect the spamming is over
11:08:35 <zygoloid> no, i take that back :)
11:08:52 --- mode: ChanServ set -o jmcarthur
11:09:09 * ksf wants th to be able to lift functions
11:09:37 <ksf> I don't even care about serious restrictions like having to bind them to new definitions or such
11:10:46 * edwardk cheers.
11:11:00 <jmcarthur> woot
11:11:26 <edwardk> jmcarthur: good catch re 'f g' getting collected
11:11:39 <jmcarthur> :)
11:12:43 <allbery_b> as mentioned by KB1JWQ (freenode oper) some hours back, blocking all the web gateway users blocks way too much
11:13:11 <Phyx-> allbery_b: does he propose al alternative?
11:13:31 <edwardk> jmcarthur: docs have been updated (to describe that scenario, to describe the fact that specSTM isn't quite as slick, and to annotate which threads are running which tasks)
11:13:48 <allbery_b> he did; have a real chanop (not a handy body like me) /msg him for details
11:13:54 <jmcarthur> rock
11:13:57 <Phyx-> lol
11:14:27 <edwardk> added speculative hylo, since i can add that one without defining my own Mu
11:14:35 <edwardk> (only speculative on the ana side)
11:14:53 <allbery_b> (I have chanop but mainly because I'm often around at odd times to kickban random trolls; I won't try to set channel policies etc.)
11:14:59 <jmcarthur> ooh
11:15:16 <edwardk> i also added all of Data.Traversable to Data.Traversable.Speculation
11:15:23 <edwardk> so we have speculative traverses, etc.
11:15:52 <jmcarthur> i'll have to look at the docs for that part. i've only paid attention to spec so far
11:15:59 <edwardk> i can provide a speculative 'cata', but its less useful because you need to supply a whole 'f a' for comparison
11:17:14 <edwardk> traverseBy :: (Applicative f, Traversable t) => (a -> a -> Bool) -> (Int -> a) -> (a -> f b) -> t a -> f (t b)
11:17:37 <edwardk> is traverse with an argument for how to compare states and for how to generate states out of whole cloth
11:18:31 <jmcarthur> edwardk: specBy isn't pure, is it?
11:18:52 <edwardk> specBy' is pure. specBy cheats to check if 'a' is tagged
11:19:05 <edwardk> but that is purely an optimization
11:19:28 <jmcarthur> edwardk: i mean if the comparison function does something like e.g. "approximately equals"
11:20:07 <jmcarthur> the result would not be deterministic in that case, would it?
11:21:01 <jmcarthur> specOn should be pure, but i don't specBy is unless you impose a precondition on it
11:21:19 <jmcarthur> *don't think
11:21:19 <edwardk> specBy' would be deterministic. you'd get f g or f a as appropriate based on the result of your test.
11:21:42 <edwardk> specBy would give potentially varying answers based on if a was forced or not
11:21:47 <jmcarthur> oh!
11:21:49 <jmcarthur> okay
11:21:58 <JoelMcCracken> is there a haskell bot in here? if so, is the code available somewhere?
11:22:06 <edwardk> JoelMcCracken: lambdabot, and yes
11:22:24 <edwardk> http://hackage.haskell.org/package/lambdabot
11:22:31 <JoelMcCracken> edwardk, awesome
11:22:35 <JoelMcCracken> thank you
11:22:44 <edwardk> np
11:23:01 <edwardk> i'd better be helpful... or they'll ban me again ;)
11:23:14 <ski> @where lambdabot
11:23:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:23:32 <edwardk> ski: heh that should answer 'cale's basement'
11:23:43 <Phyx-> hmm does ghci do some extra alpha conversions on the types ghc infers? ghc seems to infers much longer types
11:23:45 <ski> edwardk : surely you're always helpful ? :)
11:23:54 <jmcarthur> edwardk: would you say the specBy should be in IO then?
11:24:13 <edwardk> jmcarthur: technically, but i'm not likely to move it there. ;)
11:24:21 <jmcarthur> bah!
11:24:25 <benmachine> JoelMcCracken: the code for lambdabot is quite old and pretty big, so don't be surprised if you find it confusing
11:24:51 <benmachine> JoelMcCracken: you're welcome to ask if you have any questions!
11:24:59 <JoelMcCracken> thanks! I'm sure I will be =)
11:25:03 <edwardk> JoelMcCracken: there are also write-your-own-irc bot tutorials for haskell on the internet.
11:25:16 <JoelMcCracken> i'm actually interested in the safe evaluation properties
11:25:18 <jmcarthur> edwardk: but i can see a use case where i would want its nondeterministic behavior. like if i can guess an approximate value to try while working on the more accurate value
11:25:30 <edwardk> jmcarthur: yeah
11:25:34 <jmcarthur> and if it's close enough just run with it otherwise retry with the accurate one
11:25:36 <edwardk> jmcarthur: thats why i left it exposed
11:25:47 <benmachine> JoelMcCracken: maybe you want mueval, then
11:25:47 * Phyx- wonders if his irc is dropping messages like his other chat clients
11:26:02 <jmcarthur> i'd just feel better if it was in IO :P
11:26:06 <jmcarthur> i guess i could just use return
11:26:07 <edwardk> epsilons, cases where for things like maximumBy i can often not care as long as it doesn't go beyond the maximum i already knew, etc.
11:26:09 <JoelMcCracken> yeah, found that from looking around pretty quickly =)
11:26:19 <jmcarthur> guess so
11:26:32 <edwardk> maximumBy was the reason i wrote all the By functions actually
11:26:32 <jmcarthur> i mean, i could approach it the way i approach float
11:26:51 <edwardk> jmcarthur: with your shield up and a long pointy stick in front of you?
11:27:37 <edwardk> JoelMcCracken: there is a library for that, mueval i think
11:38:54 <Phyx-> @hoogle Type -> Type
11:38:55 <lambdabot> Language.Haskell.TH AppT :: Type -> Type -> Type
11:38:55 --- mode: ChanServ set +o mauke
11:38:55 <lambdabot> Language.Haskell.TH.Syntax AppT :: Type -> Type -> Type
11:38:55 <lambdabot> Prelude id :: a -> a
11:38:55 --- mode: mauke set -b *!*@gateway/web/freenode/*$##overflow
11:39:17 <Phyx-> @hoogle alphaconv
11:39:17 <lambdabot> No results found
11:40:55 --- mode: mauke set -o mauke
11:41:11 <mreh>  #python has so many strange names, dis, pickle, PyFlakes
11:41:54 <mreh> dis is a city in hell
11:42:07 <Phyx-> > alphaTyVar
11:42:08 <lambdabot>   Not in scope: `alphaTyVar'
11:45:56 <huunTabbyKilled> !ops | ``BIKCMP has` a message` for `YOU!: Is it politically correct on this list to trash Microsoft and show destain for money? If so, I must protest. Microsoft is the best thing that ever happened to computer users, ever. It will never, never be replaced by user unfriendly software like linux or TeX. Never.
11:47:01 --- mode: ChanServ set +o mauke
11:47:01 --- mode: mauke set +q *!*@gateway/web/freenode/ip.222.132.133.193
11:47:24 <Tabby_alabama> !ops | ``BIK-CMP has` a m-essage` for `YOU-!: wiggle thatass.pop a tab and smoke a fatty. happy everyday until we crash at your dads. boom tisk in our ears and amphetamines in our blood.giving blowjobs in the stalls to pay for $10 water.this moment will last forever.mom and dad broke up because of me
11:47:56 <danharaj> Why is it called dependent product and sum?
11:48:23 --- mode: mauke set +q *!*@gateway/web/freenode/ip.85.183.249.154
11:48:24 --- kick: Nue_huun was kicked by allbery_b (Nue_huun)
11:48:33 <mauke> oh wow
11:48:35 --- kick: svnukeur was kicked by allbery_b (svnukeur)
11:48:50 <mreh> what's going on?
11:48:56 <mauke> spammening
11:49:01 <allbery_b> major spambot incursion on freenode
11:49:09 <danharaj> This must be the work of #python
11:49:10 --- kick: x86Mons was kicked by allbery_b (x86Mons)
11:49:15 <Cale> Let's just ban gateway/web/freenode for a while maybe
11:49:15 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
11:49:26 <danharaj> they are jealous of our tight semantics and static guarantees.
11:49:30 <allbery_b> Cale: we did, that excludes a bunchof real people
11:49:44 <allbery_b> one of the freenode opers strongly recommended against that ban
11:49:45 --- mode: mauke set +q *!*@gateway/web/freenode/ip.*
11:49:49 <Cale> Those real people can get IRC clients...
11:49:57 <mauke> yeah, but idoru doesn't scale
11:50:01 --- kick: Ron_webcoders was kicked by allbery_b (Ron_webcoders)
11:50:11 <Cale> and we're kicking these people automatically anyway :P
11:50:28 <mreh> damn those pythonites, they shall live out the rest of their days in agony if I have anything to do with it!
11:50:30 <LoRez> idoru doesn't scale?
11:50:37 <allbery_b> not automatc, just got a lot of practice slapping down spambots on twitter the past week :)
11:50:44 <LoRez> irony is idoru's written in python
11:50:50 <allbery_b> (since twitter, unlike freenode, doesn't seme to care)
11:50:54 <mauke> LoRez: in the sense that the spammers still get in and spam
11:51:10 <allbery_b> or even seem
11:51:17 <mreh> can't we filter messages with a spam filter?
11:51:18 <__marius__> allbery_b: they care very much ~ you should report them
11:51:21 <LoRez> that's not a scale issue, that's a not banning until detected issue
11:51:45 <danharaj> When you've banned a few dozen bots, you start becoming an expert at the turing test.
11:51:45 --- mode: mauke set -o mauke
11:52:04 <allbery_b> __marius__: I have.  Multiple times.  And regularly go on block&report sprees.  And yell at them.  And get *no* response
11:52:13 <arcatan> it'd seem like a bad idea for a spambot to explicitly call !ops
11:52:28 <mauke> LoRez: well, if they only had a few source ips, it would work
11:52:29 <mreh> heh
11:52:41 <mauke> I think that's what I meant by "scale"; too many drones
11:52:45 <mreh> maybe it's a trolling, making work for the ops
11:52:59 * hackagebot MonadRandom 0.1.5 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.1.5 (CaleGibbard)
11:53:06 <mreh> Cale: good man
11:53:21 <Cale> mreh: Sorry about not uploading earlier, btw. Apparently I did everything I had to except upload the package :P
11:53:27 --- mode: allbery_b set -o allbery_b
11:53:46 <mreh> Cale, no big deal, I installed my own copy yesterday
11:53:52 <mreh> without using a time machine
11:54:00 * hackagebot WebCont 0.0.0 - Continuation based web programming for Happstack  http://hackage.haskell.org/package/WebCont-0.0.0 (SamAnklesaria)
12:00:56 <jmcarthur> an update to MonadRandom?
12:01:51 <mreh> jmcarthur: added MonadFix
12:02:11 <jmcarthur> ah
12:03:47 <mreh> maybe other things if Cale added them
12:31:20 <Toxaris> Can someone help me with a bug report?
12:31:50 <Toxaris> I'm searching for a polite way to say "please read the bug report before commenting"
12:32:12 <danharaj> Why do you expect people to comment without reading it?
12:32:20 <Phyx-> @hoogle getEnv
12:32:21 <lambdabot> System.Environment getEnv :: String -> IO String
12:32:21 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
12:32:29 <Phyx-> @hoogle getSession
12:32:29 <lambdabot> No results found
12:32:33 <Toxaris> danharaj: http://trac.haskell.org/haskell-platform/ticket/124
12:32:41 <Toxaris> danharaj: it already happened
12:32:42 <ksf> as in some dev failed to follow clear instructions to reproduce stuff?
12:33:31 <ksf> ...I once had to reverse-engineer the mind of some ccp bug squad member to get a bug accepted... that is, infer what he misunderstood and exlpain it in clear, simple words.
12:34:01 <ksf> Toxaris, lesson 1: never say "messes up". 
12:34:09 <ksf> even if it messes up.
12:34:30 <danharaj> It goes without saying that the windows implementation of haskell platform messes up.
12:35:00 <ksf> it goes without saying that digest messes up...
12:35:06 <Toxaris> danharaj: that's not true, it is actually very usable
12:35:29 <danharaj> Toxaris: I have only tried to cabal a few libraries, 2 of them failed because of Haskell Platform issues.
12:35:33 <monochrom> "please read the bug report before commenting" is already pretty polite
12:36:03 <ksf> ...unless, of course, it's not only digest that failes. in that case, just mention it.
12:36:13 <ksf> avoid ad hominem at any cost, that is.
12:36:29 <danharaj> You could say "Perhaps I am not being clear..." and reword yourself.
12:36:35 <dcoutts_> Toxaris: oh, heh, my fault. You're right I didn't read that bit :-)
12:36:43 <Toxaris> dcoutts_: :)
12:36:48 <danharaj> or that :p
12:37:09 <dcoutts_> hmm, what's going on then
12:37:55 <Toxaris> dcoutts_: well, cabal (or Cabal) passes a path to gcc which does not exist
12:38:20 <Toxaris> dcoutts_: because it thinks that header files installed with boot libraries live in some directory, but they live in another one
12:38:38 <Toxaris> dcoutts_: for details, well, see the bug report
12:38:43 <Toxaris> dcoutts_: or ask me
12:39:15 <dcoutts_> Toxaris: lib\extralibs vs just extralibs is it?
12:39:39 <dcoutts_> Toxaris: so looks like the ghc-pkg registration info might be out of sync with the actual files
12:41:52 <Phyx-> what's the propoer url for http://hackage.haskell.org/packages/archive/ghc/6.12.2/doc/html/HscTypes.html#t%3AHscEnv ? the wiki links to it, but as always, 404
12:42:02 <Phyx-> proper*
12:42:14 <dcoutts_> Toxaris: odd, so presumably the installer is putting just the .h files in the wrong place?
12:42:28 <danharaj> anyone know where I should report this bug?
12:42:29 <danharaj> http://jpmoresmau.blogspot.com/2010/05/haskell-sdl-on-windows-check-hacking.html
12:42:39 <Toxaris> dcoutts_: not sure about ghc-pkg registration. How can I check that?
12:42:43 <danharaj> I tried to use the hack the author posted, but it doesn't work for me.
12:43:36 <dcoutts_> Toxaris: ghc-pkg field zlib include-dirs
12:43:47 <Toxaris> dcoutts_: I don't think so. All the files belonging to zlib are together, and most of them are found, but not the .h files.
12:44:05 <dcoutts_> Toxaris: that's even weirder
12:44:15 <Toxaris> dcoutts_: So I guess that the problem is that the .h files are wrongly registered
12:44:29 <dcoutts_> but then that'd always happen, not just with the platform
12:44:46 <dcoutts_> Toxaris: what happens if you do cabal install zlib 
12:45:05 <dcoutts_> perhaps pick a different version so they do not clash
12:45:13 <dcoutts_> I'd expect the registration info to be right
12:48:59 <Toxaris> dcoutts_: all paths in the result of ghc-pkg describe zlib are using $topdir\extralibs\zlib-0.5.2.0\ghc-6.12.1
12:49:30 <dcoutts_> Toxaris: for the one you just installed?
12:50:03 <Toxaris> dcoutts_: but the result of "ghc-pkg field zlib include-dirs" is C:/Haskell/Platform/2010.1.0.0\lib\extralibs\zlib-0.5.2.0\ghc-6.12.1\include
12:50:13 <Toxaris> dcoutts_: so maybe the problem is related to the definition of $topdir?
12:50:51 <Toxaris> dcoutts_: no, for the zlib which came with the Haskell Platform
12:50:56 <dcoutts_> Toxaris: post that info in the ticket
12:51:38 <dcoutts_> I'm not sure what $topdir should be on windows
12:58:31 <Toxaris> dcoutts_: well, ghc-pkg field zlib include-dirs returns the correct path, but that path is not used when running cabal install
12:58:45 <ddarius> @tell shapr Any news on what, when, and where?  I have Fri-Mon inclusive off.
12:58:45 <lambdabot> Consider it noted.
12:59:09 <dcoutts_> Toxaris: I find that very surprising
13:00:07 <Saizan> after a "ghc-pkg dump" $topdir gets expanded by Cabal itself (the GHC module), so the code in Cabal and the one in ghc-pkg might be out of sync.
13:01:33 <dcoutts_> hmm
13:01:42 <dcoutts_> topDir <- ghcLibDir' verbosity ghcProg
13:01:52 <dcoutts_> which calls ghc --print-libdir
13:02:14 <dcoutts_> perhaps ghc did change what interpretation it takes of $topdir
13:04:20 <Phyx-> @hoogle FastString -> CWString
13:04:21 <lambdabot> Warning: Unknown type FastString
13:04:21 <lambdabot> Foreign.Ptr castFunPtrToPtr :: FunPtr a -> Ptr b
13:04:21 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
13:04:25 <Phyx-> hmm
13:04:33 <Phyx-> @srv FastString
13:04:33 <lambdabot> Source not found. You untyped fool!
13:04:41 <dcoutts_> Phyx-: FastString is a ghc thing, you'll not find it in the standard libs
13:04:42 <Phyx-> @srv CWString
13:04:42 <lambdabot> Source not found. Maybe you made a typo?
13:05:26 <Phyx-> dcoutts_: I keep hoping they add those to hoogle..
13:06:02 <Toxaris> dcoutts_: I'm confused.
13:06:23 <dcoutts_> Toxaris: Saizan's point is certainly worth investigating
13:06:27 * hackagebot cryptohash 0.4 - crypto hashes fast and pratical  http://hackage.haskell.org/package/cryptohash-0.4 (VincentHanquez)
13:06:31 <dcoutts_> it'd explain what you're seeing
13:10:04 <Phyx-> @hooge (Integral a, Integral b) => a -> b
13:10:05 <lambdabot> Prelude div :: Integral a => a -> a -> a
13:10:05 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
13:10:05 <lambdabot> Prelude lcm :: Integral a => a -> a -> a
13:10:44 <dcoutts_> Toxaris: what ghc version are you using?
13:11:07 <Toxaris> dcoutts_: the one from the Haskell platform :) The Glorious Glasgow Haskell Compilation System, version 6.12.1
13:11:27 <aristid> ghc has become gghc?
13:11:36 <aristid> or gghcs actually?
13:12:06 <Toxaris> aristid: well, try ghc --version
13:12:20 <aristid> Toxaris: crazy :D
13:12:36 <soupdragon> Is there a proof system for any topos?
13:13:53 <dcoutts_> Toxaris: wait, now I'm confused
13:14:23 <dcoutts_> Toxaris: you said "ghc-pkg field zlib include-dirs" reports the dir as C:/Haskell/Platform/2010.1.0.0\lib\extralibs\.... etc
13:14:54 <dcoutts_> Toxaris: what does ghc --print-libdir say?
13:15:35 <dcoutts_> Toxaris: perhaps you can paste somewhere the output of: 1) ghc --print-libdir  2) ghc-pkg field zlib include-dirs  3) ghc-pkg describe zlib
13:19:56 <soupdragon> has anyone heard of Conways numbers?
13:20:03 <Cale> soupdragon: Surreals?
13:20:07 <soupdragon> yes
13:20:39 <soupdragon> I heard about it an interview Conway gave about Martin Gardner
13:20:43 <Toxaris> dcoutts_: yes; it says .../lib/; see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26789
13:20:48 <Cale> soupdragon: What does a proof system mean, exactly, and what does it mean for it to be for the specific topos? There is a certain kind of proof system I can think of which can be associated with any topos, but it doesn't necessarily characterise the topos.
13:20:50 <soupdragon> I've not read the book yet but I am wondering if it is possible to program them (in haskell)
13:21:17 <Cale> soupdragon: Probably to a limited extent.
13:21:25 <soupdragon> Cale I meant like a program that checks proofs and you could choose classical or intuitionist by varying the topos
13:21:47 <dcoutts_> Toxaris: ok, so that's all consistent then
13:23:12 <Toxaris> ksf: thanks for the lesson (about not messing up when it messes up), I think I see.
13:23:52 <Toxaris> danharaj: I think something like "perhaps I am not being clear" was what I was searching for :) 
13:24:16 <danharaj> heh
13:24:41 <danharaj> I still don't know where to report the bug described in the blog post I linked.
13:24:45 <Phyx-> dcoutts_: dunno if this is relevant, i'm not using the haskell platform and ghc-pkg field and ghc --print-libdir report completely different paths
13:24:53 <dcoutts_> Toxaris: so what I cannot explain is why cabal would be using the wrong dir, from my reading of the code it just use the result of --print-libdir
13:24:54 <danharaj> It is fairly inconvenient that I can't build a library because of it :\
13:25:23 <Cale> soupdragon: I'm not sure what that would mean for topoi like the topos of functors from Top to Set
13:25:40 <soupdragon> okay
13:25:47 <danharaj> Pff why would you want to work in anything other than the effective topos :p
13:25:50 <dcoutts_> Phyx-: you can check with ghc-pkg describe on the same package to see if it's actually using the $topdir variable, or an absolute path
13:25:51 <Cale> But I'm probably not the best person to ask :)
13:26:09 <soupdragon> I think it would be interesting to implement some number systems beyond the reals
13:26:26 <soupdragon> can the p-adic be implemented?
13:26:35 <Cale> soupdragon: yeah
13:26:43 <soupdragon> that should be easier than surreals
13:26:53 <Phyx-> dcoutts_: ah, it's using hardcoded paths :)
13:27:14 <Cale> soupdragon: Ordinals (a subclass of the surreals in a sense) can be implemented to a certain limited extent
13:27:16 <soupdragon> Cale have you seen the constructive logic dx^2 = 0 does not imply that dx = 0?
13:27:34 <soupdragon> it only implies that dx doesn't not equal 0
13:27:40 <Cale> ?
13:27:54 <Cale> I don't know what you're talking about :)
13:27:54 <soupdragon> I just read about it on Andrej
13:28:38 <soupdragon> oh well it seems cool to me but also very strange
13:28:51 <Cale> Perhaps you're thinking of the usual trick of extending a ring with an "infinitesimal" e such that e^2 = 0
13:29:02 <soupdragon> that is a usual trick??
13:29:14 <soupdragon> but Cale if you pick e^2 = 0 can't you prove that e = 0 using ring axioms?
13:29:16 <danharaj> isn't that better described as a 'nilpotent'?
13:29:19 <Cale> No.
13:29:32 <Cale> danharaj: Yes, it's a nilpotent element.
13:29:37 <vitka> > map (pred *** succ) (map (6*) [1..])
13:29:38 <lambdabot>   No instance for (GHC.Enum.Enum (b, b'))
13:29:38 <lambdabot>    arising from a use of `e_161' at...
13:29:39 <Cale> soupdragon: Think about matrices :)
13:29:44 <Cale> 0 1
13:29:44 <Cale> 0 0
13:29:46 <danharaj> Infinitesimal implies some sort of metric to me :p
13:29:47 <soupdragon> oh yes I see
13:29:48 <Cale> square that :)
13:30:08 <soupdragon> wow im so confused
13:30:14 <soupdragon> so what's the point of using constructive logic here
13:30:15 <vitka> > map (*6) [1..]
13:30:16 <lambdabot>   [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138...
13:30:22 <eflister_>  any idea why stuff from 2010 doesn't show up when i google the irc logs?  (site:tunes.org)
13:30:27 <danharaj> soupdragon: Is the thing you read about in the context of synthetic differential geometry?
13:30:30 <dcoutts_> Toxaris: to do more debugging we'll probably need to dig into the Cabal lib code and run modified versions with extra print calls etc
13:30:33 <Cale> danharaj: Well, they're like the algebraic way of doing the stuff you usually do with a metric.
13:30:34 <soupdragon> no
13:30:38 <Saizan> http://math.andrej.com/2008/08/13/intuitionistic-mathematics-for-physics/
13:30:40 <soupdragon> I can't read that sort of stuff yet
13:30:48 <dcoutts_> Distribution/Simple/GHC.hs function getInstalledPackages
13:31:07 <danharaj> Oh god why do we have to expose yet another beautiful mathematical subject to the physicists so they can dick it up with their cowboy reasoning.
13:31:11 <vitka> dragon: Think about matrices :)
13:31:17 <eflister_> is there a name i can google for the pattern where you do something like this:  data Rec = Rec {unRec:: a -> Rec}
13:31:19 <vitka> oops
13:31:28 <soupdragon> it's mathematicians that ruined calculus with the epilonics
13:31:34 <vitka> > map (pred *** succ) (map (6*) [1..])
13:31:35 <lambdabot>   No instance for (GHC.Enum.Enum (b, b'))
13:31:35 <lambdabot>    arising from a use of `e_161' at...
13:31:39 <Toxaris> dcoutts_: as in: run on my machine?
13:31:47 <Cale> soupdragon: what?
13:31:55 <soupdragon> Cale all this dy/dx crap
13:31:55 <dcoutts_> Toxaris: or someone else on windows who can reproduce it
13:31:57 <Toxaris> dcoutts_: you are debugging using extra print calls? 
13:32:06 <ksf> .oO( application-level blackholing )
13:32:07 <Cale> soupdragon: Leibniz notation?
13:32:12 <danharaj> don't be hating on differential operators.
13:32:16 <eflister_> did someone make it so you can't post from http://webchat.freenode.net/ ?
13:32:24 <Cale> That's just notation, I don't use it all that often either.
13:32:31 <soupdragon> I use the notation of Sussman
13:32:32 <Cale> What are epilonics?
13:32:53 <Cale> Sussman should stick to teaching CS ;)
13:33:15 <ksf> eflister, yep, there's a spambot problem.
13:33:17 <danharaj> Don't trust anyone who has an opinion on calculus pedagogy
13:33:32 <soupdragon> Cale - its the joke that we use epsilon-delta as the foundation but write everything out exactly as in the past with the contradictory infintesimals
13:33:50 <Cale> soupdragon: dy and dx needn't be infinitesimal at all
13:33:53 <eflister> ksf: thx :)
13:33:55 <danharaj> We do? I don't. I hand-wave with asymptotic arguments.
13:34:12 <soupdragon> what I mean by "we" is every mathematics class I've ever been in and almost all books
13:34:23 <danharaj> soupdragon: have you ever learned out of Rudin?
13:34:30 <Cale> soupdragon: You should get Michael Spivak, "Calculus"
13:34:48 <bremner> in ghci 6.12.1, :stepover is undefined. Is this a ghc bug or a documentation bug.
13:34:52 <bremner> ?
13:34:55 <danharaj> Cale: I have that, and my biggest complaint is the weird book dimensions. :p
13:35:09 <Cale> It was the textbook we used in 1st year, and from what I've seen, quite different from most introductory Calculus books.
13:35:09 <soupdragon> anyway dx doesn't not equal 0 is a consequcene of trichotomy them
13:35:14 <eflister> i'm trying to google the logs for a time when cale was explaining something to me, but stuff from 2010 doesn't show up, any idea why?  i'm trying to understand that common pattern that goes something like:  data Rec = Rec {unRec:: a -> Rec}
13:35:17 <Toxaris> dcoutts_: sounds fun, and I'm ready to help out with that, but not now. Got a paper deadline on Monday, and my collegues already got somewhat mad at me for helping with counting the votes in the university elections today. So no more community efforts for this week. 
13:35:35 <danharaj> dx and dy aren't elements of a field, so it doesn't make sense to talk about them like that.
13:35:38 * hackagebot free-theorems-webui 0.1 - CGI-based web interface for the free-theorems package.  http://hackage.haskell.org/package/free-theorems-webui-0.1 (MatthiasBartsch)
13:35:47 <danharaj> If you want to reason about them rigorously you should look into differential forms.
13:36:14 <dcoutts_> Toxaris: ok, I'm pretty busy too
13:36:31 <soupdragon> Cale - what use is a ring with e^2 = 0?
13:36:41 <soupdragon> don't you need an ordered field to do anything useful/
13:36:42 <danharaj> Toxaris: Why do your colleauges hate open source so much ;D
13:36:45 <Cale> You could just take dy and dx to be real numbers for which it is true that dy = f'(x) dx
13:37:04 <Cale> (or consider the relation consisting of all such pairs, or triples, if you want it for all x)
13:37:09 <Phyx-> danharaj: mostlikely because it doesn't pay the bills :)
13:37:16 <danharaj> Pff, they have tenure.
13:37:18 <danharaj> (maybe)
13:37:35 <Cale> soupdragon: No, there are lots of useful rings which aren't ordered.
13:37:46 <danharaj> Matrices, again.
13:37:49 <Cale> Take the polynomial ring R[e]
13:38:01 <Cale> and then quotient it out by the ideal generated by e^2
13:38:14 <Toxaris> danharaj: oh one of them is actually a linux kernel hacker kind of guy, we're just busy with work this week.
13:38:33 <Cale> Then the image of e in that quotient has the property that e^2 = 0
13:38:38 <danharaj> Toxaris: Out of curiosity, does he have a neckbeard? :p
13:38:47 <Cale> and yet e will not be 0
13:40:04 <eflister> Cale: don't mean to interrupt - any quick term i could google to read about my question above?  any idea why google can't seem to turn up the help you gave me on tunes.org?  the 'searchable' logs have never worked for me (ircbrowse.com)
13:40:06 <Cale> every element of that ring can be written in the form (a + be), and we have the usual addition, and when we multiply elements, we get (a + be)(c + de) = ac + ade + bce + bde^2 = ac + (ad + bc) e
13:40:28 <Cale> eflister: hmm
13:40:57 <Cale> eflister: I'm not sure, but I'll explain it to you after this if you can't find anything :)
13:41:07 <eflister> Cale: awesome thx!
13:41:16 <Cale> eflister: It's sort of the usual trick for recovering recursion at the value level from recursion at the type level.
13:41:24 <Cale> But I don't know if it has a name.
13:41:29 <eflister> Cale: i've been trying to google it for a while and no luck, so i'll wait patiently
13:42:29 <eflister> Cale: huh, i don't remember noticing that recursion was involved.  is there a simplest example i can look up?
13:43:04 <Cale> eflister: Oh, perhaps I misunderstood what you were looking for...
13:43:23 <Cale> newtype Rec a = In { out :: Rec a -> a }
13:43:24 <Cale> {-# NOINLINE y #-}
13:43:24 <Cale> y :: (a -> a) -> a
13:43:24 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
13:43:28 <Cale> ^^ I'm thinking of this
13:43:44 <Cale> The usual way of giving the y combinator a type
13:43:54 <Cale> Er, well, making it typecheck :)
13:44:14 <eflister> Cale: just that thing where record syntax is often used to define a type Rec, which has a field that is a function called unRec
13:44:25 <Cale> You can see that this is just the usual definition of the Y combinator from the untyped lambda calculus, except that it has these isomorphisms 'In' and 'out' jammed into it :)
13:44:34 <Cale> eflister: Oh, okay
13:44:42 <benmachine> Cale: why the pragma?
13:44:52 <Cale> benmachine: The inliner chokes on the definition
13:44:58 <akamaus> I'm not sure whether a question appropriate here, but could someone explain in a few words the difference between agda and idris, and their relation to haskell?
13:45:02 <Cale> benmachine: It's just to avoid a GHC "bug"
13:45:10 <benmachine> oh right
13:45:11 <Cale> benmachine: One which I don't think they want to remove.
13:45:24 <Cale> (because this is the only case where it seems to occur)
13:45:36 <benmachine> oh yeah
13:45:42 * benmachine vaguely recalls reading about this
13:46:08 <Heffalump> akamaus: agda and idris are both dependently typed languages/theorem provers implemented in Haskell. As far as I know agda has a much bigger developer and user base than idris (relatively; they're both quite small). I don't know anything about the technical differences.
13:46:30 <Cale> eflister: So, that's just a convention. I don't know how much there is to say about it.
13:46:59 <benmachine> Blah and unBlah
13:47:04 <Cale> eflister: It's often convenient for a variety of reasons to create a type with one field which will be treated as a new type by the type system, but which is isomorphic to an existing type.
13:47:32 <eflister> Cale: for some reason it always confuses me when i see it used, but i can't happen to find a case to look at right now.  when and why is it used?
13:47:41 <Cale> and usually the most obvious thing is to give this type a name, and the field extractor function "un" of whatever that name is.
13:48:05 <benmachine> eflister: are the various newtypes in Data.Monoid examples of what you mean?
13:48:07 <Cale> eflister: Suppose you have a financial program in which there are integer quantities of dollars and cents flying around everywhere.
13:48:08 <akamaus> Heffalump, are they both entirely experimental or can be used for some practical tasks?
13:48:10 <eflister> Cale: i seem to always encounter it when i expect to be defining a type "Rec", and then all the sudden we're defining "unRec" instead
13:48:32 <Heffalump> I think agda is usable, though I don't know for sure
13:48:41 <Cale> eflister: If you used Integer for both, there would be a real danger that you mess up and treat a number of cents as a number of dollars, or vice versa.
13:49:00 <Cale> eflister: So it might be better to let the type system ensure that you get things straight:
13:49:38 <Cale> newtype Dollars = Dollars { unDollars :: Integer } deriving (Eq, Ord, Show, Read, Num) -- note that newtype deriving is required for the Num instance
13:49:55 <Cale> newtype Cents = Cents { unCents :: Integer } deriving (Eq, Ord, Show, Read, Num)
13:50:07 <ksf> Saizan, this only reinforces my oppinion that formalists are to blame that I suck at math
13:50:12 <ksf> they just don't make any sense.
13:50:21 <Cale> Now if these types occur in your type signatures, you'll have more checks by the compiler that they're used in a consistent fashion.
13:50:44 <Cale> ksf: What's wrong with formalists? :)
13:51:06 <Cale> and why don't I see any messages from Saizan?
13:51:17 <ksf> they freely mix computable and noncomputable stuff without even making an effort of type discipline
13:51:22 <Cale> Oh, Saizan posted a link earlier.
13:51:23 <ksf> because it's way up
13:51:31 <dafis> map (pred &&& succ) (map (6*) [1..])
13:51:32 <soupdragon> sorry I got disconnecteed
13:51:43 <dafis> > map (pred &&& succ) (map (6*) [1..])
13:51:43 <lambdabot>   [(5,7),(11,13),(17,19),(23,25),(29,31),(35,37),(41,43),(47,49),(53,55),(59,...
13:51:50 <soupdragon> Cale I was wondering why are you not keen on that Sussman?
13:51:56 <eflister> benmachine: yeah, maybe the Data.Monoids are what i'm talking about.  they tend to be get* instead of un*...  same idea?
13:52:05 <Cale> ksf: It rather annoys me when people use the term 'real number' to refer to something not at all equivalent in any sense to the real numbers of ZFC.
13:52:10 <eflister> Cale: isn't prelude's fix already the y combinator?
13:52:13 <ksf> the treatment of cancellation under "smooth infisitesimal analysis is especially telling.
13:52:18 <Cale> Like, when they use it to refer to the computable reals.
13:52:35 <Cale> eflister: yeah
13:52:39 <Cale> Same idea
13:53:01 <Cale> eflister: Well, the usual definition of fix in Haskell makes use of value-level recursion built into the language
13:53:08 <benmachine> eflister: pretty much
13:53:09 <soupdragon> I've caught up
13:53:09 <Cale> fix f = let x = f x in x
13:53:13 <soupdragon> using the logs
13:53:22 <aristid> :t (&&&)
13:53:23 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:54:15 * ksf 's math foo seems to be too small to grok zfc on short notice
13:54:57 <Cale> soupdragon: His arguments about how to teach Calculus involve using a strawman argument against notation which not every Calculus course uses to try to argue that the best notation looks like Scheme :)
13:55:31 <soupdragon> but what do you mean it doesn't look like scheme at all it's more like haskell than scheme
13:55:48 <Cale> Well, perhaps we didn't see the same version of his opinion :)
13:56:06 <soupdragon> well I've been reading a book SICM which is about physics
13:56:16 <ksf> oh, there's a thing that's harder to read that scheme, and that's badly formatted formulae like in saizan's link
13:56:18 <Cale> I think that all *good* Calculus courses are careful about the distinction between a function and the value of a function at a point.
13:56:26 <soupdragon> and it's by Sussman and Wisdom and they write things like (D f)(x) rather than df(x)/dx
13:56:32 <Cale> and treat the derivative as an operator on functions
13:56:46 <Cale> Okay, if that's how he's writing it, it's nothing new.
13:56:47 <soupdragon> yes I have not been lucky with good calculus courses
13:57:01 <Cale> Most mathematicians use notation like that anyway
13:57:03 <ksf> why didn't I learn basic algebra in terms of graph theory?
13:57:19 <soupdragon> Cale: that is not my experience
13:57:21 <ksf> heck just an informal formalism of rewrite rules.
13:57:44 * hackagebot wumpus-core 0.20.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.20.0 (StephenTetley)
13:57:46 <Cale> soupdragon: f'(x) is also not uncommon, and works in simpler cases.
13:57:49 <ddarius> ksf: I blame Weierstrauss
13:57:56 <dafis> soupdragon: my experience agrees with Cale's
13:58:05 <soupdragon> dafis I'm not arguing either way 
13:58:16 <Cale> But in all moderately complicated cases, the derivative becomes D
13:58:17 <dafis> soupdragon, just a data pointz
13:58:17 <soupdragon> I'm just saying it is irritating that I have had such bad luck because I am the sort of person who actually worries about these things
13:58:34 <Twey> Ooh, a German.
13:58:45 * hackagebot wumpus-basic 0.1.1 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.1.1 (StephenTetley)
13:58:56 <Cale> soupdragon: If you read Spivak, he mostly uses ' for the derivative, but discusses the shortfalls (and upsides) of the dy/dx Leibniz notation.
13:58:57 <ksf> otoh, we did start math in first class with sets (union, intersection) and different numerical systems (I think basic base 2, base 5 and base 10) even before introducing addition.
13:58:59 <dafis> Vot? huh iz a German?
13:59:13 <Twey> Hehe
13:59:13 <ksf> still, not even a mention of monoids, even without using that word.
13:59:46 * hackagebot wumpus-microprint 0.1.1 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.1.1 (StephenTetley)
13:59:50 <soupdragon> I think I should maybe move to a different part of the world and study at a different location
13:59:57 <soupdragon> maybe I would be better off 
14:00:05 <ddarius> ksf: Base 5 for the amputees?
14:00:08 <Ke> everything in europe is german, everything is also french
14:00:51 <eflister> Cale: what does the type version of y do differently?  wouldn't unDollars be :: Dollars -> Integer?  how do we construct a Dollars value if there's no Integer-> Dollars function?  i don't get why this is better than a type Dollars = Integer?
14:00:55 <ksf> nope I think it's to give an intuition to what positional numbering means
14:01:00 <Cale> soupdragon: When you move to derivatives of functions over a space anything more complicated than the real numbers alone, you're practically forced to use better notation.
14:01:22 <Cale> eflister: Dollars :: Integers -> Dollars
14:01:28 <soupdragon> Cale, I had to sit through vector calculus and complex analysis classes that just use the same rubbish
14:01:32 <Cale> eflister: That is, the usual data constructor constructs them :)
14:01:47 <Cale> soupdragon: that's too bad...
14:01:55 <soupdragon> yeah it really sucks but I thought it was normal
14:01:57 <ksf> eflister, because you just don't export the constuctor everywhere. only the ATM needs it.
14:02:06 <soupdragon> and using a clean notation which compositional meaning was sort of unusual
14:02:28 <eflister> ksf: ATM?
14:02:57 <ksf> eflister, more importantly, it prevents you from accidentally mixing dollars and other things. imagine another datatype euro and saying 1 euro + 1 dollar.
14:03:25 <Cale> soupdragon: For my course, the derivative for a function f: R^n -> R^m was a mapping Df from points in R^n to linear maps R^n -> R^m (which gave the best linear approximation to the local befaviour of f at the given point)
14:03:25 <Twey> :t (1 :: Euro) + (1 :: Dollar)
14:03:26 <lambdabot> Not in scope: type constructor or class `Euro'
14:03:26 <lambdabot>     Not in scope: type constructor or class `Dollar'
14:03:27 <ksf> eflister, one of those machines which transform plastic cards and a pin into money
14:03:31 <ddarius> unsafePerformIO (1 + 1)
14:03:33 <ksf> (depending on account balance)
14:03:42 <soupdragon> Cale - ah that is the sort of thing I use personally
14:03:46 <ksf> ...I was speaking conceptually.
14:03:47 <ddarius> "Automatic Teller Machine"
14:03:54 <soupdragon> but obviously I have to act like a leibnizian when I answer exam papers
14:03:54 <ksf> ah, that's the abbrev.
14:04:02 <Twey> ksf: Except you don't need a PIN any more.  ;)
14:04:08 <ksf> I do
14:04:22 <Twey> soupdragon: Are your exam papers marked by a computer?
14:04:26 <Cale> PIN should stand for Penn Identity Number
14:04:39 <soupdragon> no
14:04:49 <Twey> ksf: The PIN system banks use was broken quite some time ago.
14:05:00 <ksf> pin/tan != atm pins.
14:05:18 <Cale> 4 digits seems awfully insecure :P
14:05:18 <ddarius> If you define your terms you should be able to use whatever notation you want.
14:05:37 <ksf> a card is locked after three unsuccessfull atempts.
14:05:40 <Twey> Cale: In theory you only get three tries before it eats your card.
14:05:40 <ddarius> Cale: The trick to security isn't the size of the password.
14:05:43 <Cale> But credit cards' security system bothers me more
14:05:55 <ksf> we don't use those things over here
14:06:07 <aristid> ksf: don't overgeneralize :)
14:06:09 <dafis> security systems or credit cards?
14:06:18 <ksf> credit cards. at least in general
14:06:20 <soupdragon> hmmm
14:06:45 <dafis> ksf: well, since the invention of cash, they're not necessary anymore
14:06:45 <Cale> Anyone with the numbers written on your card can make purchases using them, without any additional information.
14:06:49 <ksf> they are accepted in some locations, but not at all everyhere.
14:06:54 <eflister> Cale: i think that's the core of my confusion -- i want to say "Dollars 5", but instead it looks like i have to say Dollars {unDollars = 5} -- and in this case, how would deriving Num know that it should look in unDollars to apply arithmetic functions?
14:07:04 <aristid> ksf: that's not quite the same as "not used"
14:07:06 <Cale> eflister: You can just say Dollars 5
14:07:09 <ksf> and most transactions are either cash or direct debit
14:07:34 <ksf> well noone who has an ec-card and hasn't lost his mind would use a credit card to pay.
14:07:39 <Cale> eflister: The type is, at runtime, isomorphic to Integer, so it can just use the (+) for Integer values.
14:07:41 <soupdragon> wow I have learned a lot actally I'm wonder what shoulld I do now though?
14:07:54 <eflister> Cale: is that just a trick because the newtype means there can only be one field?
14:07:54 <Cale> eflister: The Dollars and unDollars functions don't actually do anything at runtime.
14:07:56 <soupdragon> from this discussion
14:07:57 <aristid> ksf: i do use my credit card for some things, sometimes.
14:08:01 <Cale> eflister: They just help the typechecker.
14:08:04 <Cale> yes
14:08:14 <eflister> Cale: oh wow, that clears it all up
14:08:33 <ksf> ...when your desposition credit is maxed out?
14:08:57 <Cale> eflister: Also, the instance of Num means that you can write 5 in a context where Dollars are required, and things will be okay :)
14:09:02 <aristid> ksf: no. also it's not necessary to get aggressive
14:09:03 <niko> §1°
14:09:08 <ddarius> Cale: If you haven't already read it: http://www.cl.cam.ac.uk/~rja14/Papers/wcf.pdf
14:09:37 <eflister> Cale: so, newtype Dollars = Dollars {unDollars::Integer, otherThing::Something} doesn't work?  how come we aren't just saying newtype Dollars = Integer?
14:10:39 <ksf> well, then you do use them. I don't know any other german who does.
14:10:50 <eflister> ksf: oh ok gotcha, sorry :)  so type synonyms are always exported, and static type checking doesn't check that you used the right synonym?  but newtypes are not exported and do check?
14:11:21 <aristid> ksf: every bank offers credit cards, isn't that indication enough that some people use them?
14:11:50 <ksf> type synonyms are exactly that, synonyms. it doesn't matter whether you say [Char] or String, at all. newtypes introduce a new type, which doesn't unify with the underlying type
14:12:19 <soupdragon> Has anyone read The Analyst?
14:12:25 <ksf> I would have to pay extra to get a credit card
14:12:38 <Cale> eflister: Using type synonyms would defeat the original purpose
14:12:45 <ksf> ...for no apparent benefit, as I can do everything I need without (and I don't tend to order from the US)
14:12:55 <Cale> eflister: Of getting the type system to check that we're not using Dollars where Cents are required
14:13:19 <Cale> eflister: If we had  type Dollars = Integer, type Cents = Integer, then Dollars = Cents, according to the type system
14:13:20 <aristid> ksf: well, i do order some things from the US and from abroad, and i also don't pay for my credit card
14:13:48 <Cale> eflister: When we use newtype, we get a genuine new type. The data constructor serves as a way to construct values of that new type
14:13:51 <ksf> eflister, wrt. exporting, a type synonym has to be exported as a whole, whereas with newtypes you can export the type, but keep constructor and destructor private, guaranteeing encapsulation because noone else can make dollars.
14:14:03 <Cale> eflister: and the field name and/or pattern matching serve as a way to deconstruct them again
14:15:20 <eflister> Cale: gotcha, somehow i was thinking the synonyms were checked.  but still, why isn't the syntax newtype Dollars = Integer better?  because then if we export Dollars, everyone can see inside them?  whereas unDollars can be kept private?  can outsiders not pattern match on Dollars 5 in that case?
14:15:41 <Apocalisp> @bot
14:15:41 <lambdabot> :)
14:15:43 <ksf> eflister, and Dollars != Integers, btw. at least euros are defined to be fixed-point numbers to iirc 4 digits of precision.
14:15:55 <ksf> (4 behind the dot, that is)
14:16:16 <Cale> eflister: You also need a name for the data constructor
14:16:28 <Cale> eflister: Or are you thinking that should always be the same as the name of the type?
14:16:28 <ddarius> ksf: What is the accepted way of rounding?
14:16:30 <soupdragon> does anyone use lambda in mathematics
14:16:40 <ksf> ddarius, do I look like an accountant?
14:16:41 <Cale> eflister: you can write  newtype Dollars = D Integer
14:16:45 <ddarius> soupdragon: Lambda came from mathematics.
14:16:47 <Cale> eflister: and forego the record syntax
14:16:48 <pizza_> > (\x -> x+1) 1
14:16:50 <lambdabot>   2
14:16:51 <ddarius> ksf: You look like some green text actually.
14:16:53 <soupdragon> yeah but I mean use it
14:17:06 <Cale> eflister: It just means that if you want an extractor function, you have to write it separately with pattern matching.
14:17:06 <soupdragon> like instead of writing  ..... h(x) .... where h(x) = ...
14:17:10 <aristid> @pl \x -> x 1
14:17:10 <lambdabot> ($ 1)
14:17:12 <soupdragon> you could do ... (\x -> ...)
14:17:16 <Cale> eflister: We're just using the record syntax to avoid that :)
14:17:27 <soupdragon> it seems like mathematicians go to tremendous lengths to avoid writing lambda
14:17:30 <Cale> > (+1) 1
14:17:31 <lambdabot>   2
14:17:41 <soupdragon> and this theme begins to seep out into haskell programming too
14:17:42 <pizza_> > 2
14:17:42 <ddarius> I usually prefer '... h x ... where h x ... ' in Haskell.
14:17:43 <lambdabot>   2
14:17:48 <Cale> soupdragon: Nah, they just have another symbol which is more common.
14:17:56 <Cale> soupdragon: It looks a bit like |--->
14:18:03 <ddarius> Cale: More common /= common
14:18:11 <Cale> It's pretty damn common :)
14:18:25 <soupdragon> I have seen that I suppose but not to denote a function but to define a function
14:18:30 <Cale> It occurred in almost every single one of my mathematics courses in university
14:18:49 <eflister> Cale: ah, ok.  it seems like any time we expose the constructor, we also allow outsiders to pattern match, so they can see our internals.  is there no way to let them construct values but not see inside?
14:18:55 <ddarius> Cale: It's the most common notation that would be used, but it isn't used nearly as often as it could be, either from stuff like v = v(x) or things like soupdragon says or others.
14:19:08 <Cale> eflister: To export a function which constructs values, but not the data constructor.
14:19:24 <Cale> Just write:  dollars = Dollars
14:19:32 <Cale> and export  dollars, but not Dollars
14:19:36 <Veinor> I like this footnote on the paper on microprints
14:19:40 <Veinor> 1 A black-and-white copy of this paper will be very hard to understand.
14:20:00 <Cale> v = v(x) looks like something a physicist would write
14:20:56 <Cale> Most of the mathematicians I know, apart from those who spend lots of time with physics, are extraordinarily picky about the distinction between a function and its value at a point.
14:21:14 <soupdragon> I'm surprised this sort of thing is attributed to physicists because these (aberrations) are very common in my 'mathematics' classes
14:21:15 <Cale> In fact, even some of the more applied guys are too.
14:21:33 <soupdragon> but I did do computing in the same university and it was such a digusting farce that I quit, maybe the mathematics courses are the same
14:21:51 <Cale> soupdragon: I can imagine that it's because mathematicians used to be less picky, but formalism has straightened things out over the last 100 years.
14:22:10 <soupdragon> and I am just not mature enough to be able to discern that authoratatively
14:22:14 <Cale> and those changes haven't made their way completely into physicists' notation
14:22:30 <soupdragon> Well I keep hearing about how mathematics is very rigorus and such but it never seems to be taught that way
14:22:48 <Cale> It depends a lot on where you go, I think.
14:22:50 <soupdragon> (this is why I barely learned anything from classes and have had to learn it all on my own)
14:23:22 <eflister> Cale: ah sure, right.  thx, i think i get it all now.  what was confusing for me was that Dollars 5 would mean the same thing as Dollars {unDollars = 5}.  the restriction to a single field for a newtype makes it all make sense -- though i suppose you could have: newtype Money = Money {unDollars::Integer, unCents::Integer}, and then a value like Money 1 25, right?
14:23:40 <Cale> eflister: That can't be a newtype
14:23:46 <Cale> eflister: It would have to be data
14:23:51 * ksf wonders whether there's any constructivist publications targeted at not-yet mathematicians.
14:23:57 <Cale> newtypes can only have a single constructor with a single field
14:24:03 <eflister> Cale: oh :( how come?
14:24:05 <ddarius> ksf: To get them while they are young?
14:24:16 <ksf> that.
14:24:19 <ksf> and to get me
14:24:28 <Cale> eflister: Because the point of newtype is to define a type which can be treated identically at runtime to an existing type.
14:24:48 <eflister> Cale: isn't an (Integer,Integer) an existing type?
14:24:49 <Cale> eflister: If you need to pair things up, then there needs to be additional runtime representation to go with that.
14:25:02 <ksf> http://mathforum.org/mathed/constructivism.html hmmm
14:25:08 <Cale> You could:  newtype Money = Money { unMoney :: (Integer, Integer) }
14:25:30 <soupdragon> that's the teachers meaning
14:25:47 <ksf> I think it'd be unnatural for a programmer without any prior major math experience to pick up maths and become a formalist
14:25:50 <Cale> But that's not really any different from  data Money = Money {dollars::Integer, cents::Integer}
14:25:53 <ddarius> ksf: That might be a different "constructivism" ...
14:26:01 <soupdragon> it would be nice if you could just write    newtype Money = (Integer, Integer)
14:26:05 <eflister> Cale: huh. why not allow either to mean the same thing?  isn't the record a way to define the tuple?
14:26:11 <soupdragon> and it would know you mean  Money/unMoney
14:26:32 <Cale> eflister: You have to use them in different ways.
14:26:37 <ksf> ddarius, yes, I just noticed.
14:26:41 <ddarius> ksf: My experience is that computer scientists that are into mathematics are more Formalist than mathematicians.
14:26:48 <ksf> not that I wouldn't agree with that one, too.
14:27:02 <Cale> Maybe I just went to a university where people were pretty formal in general.
14:27:11 <soupdragon> It's only computer scientists that write papers which have been machine checked for correctness
14:27:19 <ddarius> Indeed.
14:27:25 <Cale> There were a *lot* of people doing analysis
14:27:28 <bremner> If I want to load a 200k list [[[Int]]] into ghci, what is my best bet? At the moment I'm to compile it with ghc -O0.
14:27:37 <Cale> and the remainder were mostly algebraists and combinatorialists
14:27:59 <ksf> 200k might be fine. still, that's a bad idea.
14:28:00 <Cale> Not as many differential geometers, or people working on other geometric areas
14:28:11 <Cale> Or things relevant to physicists.
14:28:24 <Cale> There were a handful of mathematical physicists though.
14:28:26 <ddarius> Wouldn't differential geometry fall under analysis?
14:28:41 <Cale> But they were the sort of guys who physicists would call mathematicians, and mathematicians would call physicists :)
14:28:52 <Cale> ddarius: Yeah, but not this sort :)
14:29:16 <Cale> It was more functional analysis, Banach spaces and measure theory, that sort of thing.
14:30:26 <ksf> oh those philosophers and paedagocics are messing up my google results
14:30:52 <soupdragon> is the physics equivalent of formalist: Positivst?
14:31:17 <soupdragon> I was reading Hawkings book about the universe and he keeps saying that nothing means anything it's just equations that give the right answer
14:31:46 <Cale> soupdragon: That's a good way to put it.
14:32:07 <Cale> soupdragon: Physics is a human construction, designed to try to predict our observations.
14:32:09 <ddarius> ksf: You might enjoy this article and ones linked within it: http://plato.stanford.edu/entries/mathematics-constructive/
14:32:12 <ksf> he also said that the universe came into existence because it's laws are so nice it just had to create things that could discover them.
14:32:31 <ksf> ...well, at least conjectured.
14:32:31 <Cale> I think that if you think of it in any other way, then you're likely to drive yourself mad :)
14:32:38 <ddarius> ksf: s/universe/humans ?
14:32:48 <ksf> no he said the universe.
14:33:01 <Cale> ksf: That's pretty awkward :)
14:33:45 <Cale> I think positivism is now just considered "not being an idiot"
14:33:52 <soupdragon> lol
14:34:42 <Cale> However, there's some variation inside it.
14:39:11 * ddarius pokes shapr.
14:43:23 <soupdragon> anyway it's very interesting to consider these things but quite sobering too
14:43:41 <soupdragon> makes me feel like I have made some awful choice or had a very back luck 
14:45:09 <FunctorSalad> ksf: hmm he puts "niceness" on the level of fundamental objectively existing stuff? others would think it's a highly "derived" human concept :)
14:45:24 <FunctorSalad> I don't know, it's all round and round...
14:46:21 <soupdragon> It's round all the way round?
14:46:31 <FunctorSalad> soupdragon: in the sense of no framework being clearly the "most fundamental" one
14:46:48 <ksf> yep. I think he just wanted to get past ontology as fast as possible so he chose a witty and most importantly passionate story.
14:46:49 <FunctorSalad> sorry, can't put it into more lucid terms right now ;)
14:46:58 <Cale> http://cale.yi.org/share/Spivak%20-%20Calculus%20(2ed.).djvu -- here is a sort of crappy scan of an old version of Spivak's book. I would recommend getting either the 3rd or 4th edition as a real book if you want to actually read it
14:47:01 --- mode: ChanServ set +o mauke
14:47:01 --- mode: mauke set -q *!*@gateway/web/freenode/ip.222.132.133.193
14:47:19 <Cale> But have a look at the discussion starting near the bottom of page 140
14:47:23 <Saizan> it could also have been just a joke.
14:47:31 <Cale> (which is page 135 of the document for some reason)
14:47:57 <soupdragon> Cale oh thanks my librarly has Spivak though i am not sure that I really want to read it again anyway
14:48:16 <FunctorSalad> soupdragon: I mean like in this case, we encounter "nice" at the far end of looking at the most fundamental stuff, but then we can explain in comparatively mundane psychology why we'd find something "nice"
14:48:19 <ksf> saizan, all things are true, false, meaningless, true and meaningless, false and meaningless or true and false and meaningless.
14:48:21 <Saizan> ksf: anyhow "pick the system that best suits your calculations" seems something a formalist would do
14:48:23 --- mode: mauke set -q *!*@gateway/web/freenode/ip.85.183.249.154
14:48:31 <ksf> did I miss any?
14:48:34 <FunctorSalad> this psychology, of course, needs all kinds of philosophy again to justify itself
14:48:35 <ksf> wouldn't matter, anyway.
14:49:09 <ksf> Saizan, ontology is just bunk.
14:49:25 <ksf> but you have to adress it in some way or the other when writing a popular science book about physics.
14:50:16 <ksf> ...the question is whether that ontology du jour for a warm, fuzzy feeling is the basis of an argument or not.
14:50:23 --- mode: mauke set -o mauke
14:51:05 <ksf> that'd be bad form for a physicist, but quite acceptable as psychotherapist or theologist.
14:51:16 <Cale> soupdragon: I think that since the book was written, Leibniz notation has become even less popular than it suggests. It's still around, of course, but not as much in newly published mathematics.
14:51:23 <ksf> ...in the latter case it's even the only way to keep your dignity.
14:52:09 <dolio> What do people use these days?
14:52:40 <FunctorSalad> "<soupdragon> It's round all the way round?" <-- hmm kinda like those topological earrings (what was the real name?)
14:52:56 <FunctorSalad> the space that isn't locally simply connected ;)
14:52:58 <ksf> coffeecups. or donuts.
14:53:09 <FunctorSalad> nono, weirder
14:53:11 <Cale> dolio: Usually f' if that works, or Df (or some variant of D applied to f)
14:53:13 <ksf> which are indistinguishable. which explains the coffee stains.
14:53:17 <dolio> Ah.
14:53:39 <dolio> What about integrals?
14:53:42 <Cale> Directional or partial derivatives are indicated by subscripting the D with various things :)
14:53:47 <FunctorSalad> http://en.wikipedia.org/wiki/File:Hawaiian_Earrings.svg
14:53:49 <FunctorSalad> these
14:53:51 <Cale> Integrals still have the usual notation.
14:54:16 <Cale> Though at times it's better to introduce an operator I
14:54:36 <FunctorSalad> hmm bad pic. there's supposed to be infinitely many, and there's still a lot of resolution left in the smallest rendered circle :|
14:54:37 <Cale> I've often seen ∫f to mean the integral of the function f.
14:54:43 <Cale> (another function)
14:54:44 <soupdragon> what about D^-1
14:54:52 <Cale> You could do that as well.
14:55:24 <FunctorSalad> (woha, the fundamental group is "uncountable and not a free group")
14:55:32 <ddarius> D^α, ∀α∈∁
14:55:44 <soupdragon> isn't every group (a quotient of) a free group?
14:55:58 <ddarius> soupdragon: Yes.  And a quotient of a free group is not a free group.
14:56:02 <FunctorSalad> (that's surprising for something that sort-of lives in R^2)
14:56:24 <FunctorSalad> soupdragon: yes, it's the counit of the free group/underlying set adjunction
14:56:29 <Cale> ddarius: Yeah, you can do that with some funny tricks. Strangely, fractional derivatives seem to be showing up in some places in physics, and there's some concern about how units are to be treated :)
14:56:47 <soupdragon> FunctorSalad: this language - I cannot understand
14:57:08 <FunctorSalad> doesn't matter, not essential :) just thought it may be *more* familiar
14:57:30 <FunctorSalad> with the haskell community being a champion of cothings...
14:57:33 <FunctorSalad> o_O
14:58:00 <FunctorSalad> but anyway, I just find it surprising because the sane examples in the plane all have free groups
14:58:12 <FunctorSalad> (like "plane with finitely many holes")
14:58:26 <Cale> What is the fundamental group of R^2 \ Q^2 ? :)
14:58:32 <FunctorSalad> (hmm is this even true?)
14:58:49 <FunctorSalad> that's far from "sane" :o
14:58:51 <FunctorSalad> ;)
14:59:34 <FunctorSalad> I guess I mean "embedding is an open map" by "honest subset of the plane"
14:59:54 <FunctorSalad> at least that's what we required with manifolds, iirc
15:00:19 <FunctorSalad> Cale: but what is it? ;)
15:00:28 <Cale> I don't know
15:00:46 <Cale> Something hairy. Uncountably many generators, probably not free.
15:02:14 <ddarius> Would it even be defined except perhaps as a trivial group at each base point?
15:02:21 <FunctorSalad> have any nonobvious nullhomotopic loop in mind? ;)
15:02:32 <Cale> Sure, lots of them
15:02:48 <Cale> pick any 4 irrational numbers, and you can make a rectangle
15:03:24 <FunctorSalad> that was @ddarius I guess, I meant one that contracts to the null loop
15:03:37 <Cale> oh
15:03:44 <FunctorSalad> for reasons other than "just walks back along itself"
15:03:53 <Cale> right, right
15:04:03 <Cale> I didn't actually read your question carefully :P
15:04:04 <c_wraith> Is there a splice type in TH for names?  There isn't, is there?  I can't just splice in an arbitrary name. :(
15:04:14 <ddarius> Cale: Presumably each such loop would be the only representative of its equivalence class (give or take)p
15:04:23 <c_wraith> (not in an expression context.  Not in a full declaration context, either.)
15:04:34 <FunctorSalad> c_wraith: you could work around it by $(ConE tehname)
15:04:41 <Cale> ddarius: hmm
15:04:46 <FunctorSalad> resp. $(VarE tehname) for vars
15:04:49 <Cale> ddarius: That *might* be true
15:04:55 <Cale> :)
15:05:05 <c_wraith> FunctorSalad, I'm looking specifically at providing a type signature for somthing.
15:05:14 <FunctorSalad> ddarius: up to the trivial detours I mentioned
15:05:38 <Saizan> c_wraith: something with mkName? i'm not sure i understand the question
15:05:39 <c_wraith> I can use a [t| |] quote to create the signature itself, but I can't attach it to a name without using the SigD constructor, can I?
15:05:57 <FunctorSalad> hmm a toplevel sig would be a [d| |]
15:06:07 <ddarius> Cale: Yeah, that was meant to be a question, not a statement.
15:06:17 <c_wraith> I want to somehow do [d| $name :: X |]
15:06:20 <FunctorSalad> ah you mean you can't quasiquote toplevel sig decls?
15:06:23 <c_wraith> I can't see any way to splice in there.
15:06:27 <ddarius> (or a questioning statement...)
15:06:41 <FunctorSalad> $(VarE name) doesn't work?
15:07:13 <Saizan> VarE doesn't have the right type
15:07:44 <FunctorSalad> SigD :: Name -> Type -> Dec
15:07:46 <FunctorSalad> hmm
15:08:11 <FunctorSalad> c_wraith: or just define (:::) :: Name -> Q Type -> Q Dec ;)
15:08:20 <FunctorSalad> (= lift of SigD)
15:08:33 <FunctorSalad> "it looks almost like real haskell! :o"
15:09:02 <cheater99> has anyone here used the Event monad?
15:09:10 <c_wraith> I'm currently just doing this: SigD name `fmap` [t| MyType |]
15:09:13 <FunctorSalad> I wanted to write a TH lib that looks as much as haskell as possible some time
15:09:38 <FunctorSalad> yeah, if the issue is just that it's ugly, why not define (:::)?
15:09:39 <c_wraith> I was wondering if I could manage to get away without using the SigD constructor explicitly
15:09:55 <FunctorSalad> hmm nvm that's not a lowercase name ;)
15:10:02 <FunctorSalad> then use <::> or whatever
15:10:04 <c_wraith> yeah, I was just gonna say that. :)
15:10:15 <FunctorSalad> (or are they illegal in the middle too?)
15:10:23 <magicman> That one's fine :)
15:10:40 <hpc> > let <::> = $ in succ <::> 2
15:10:41 <FunctorSalad> > let (<::>) = (+) in 2 <::> 2
15:10:41 <lambdabot>   <no location info>: parse error on input `<::>'
15:10:41 <lambdabot>   4
15:10:45 <FunctorSalad> :p
15:10:59 <ksf> FunctorSalad, why don't re-write TH instead?
15:11:18 <FunctorSalad> --> is a heck of a lot nicer than `appE` too btw ;)
15:11:28 <FunctorSalad> *appT
15:11:35 * ksf never used appE
15:11:36 <FunctorSalad> err, not that either
15:11:56 <ksf> those monadic versions that don't actually generate symbols don't make any sense.
15:11:59 <FunctorSalad> (\x y -> appT (appT arrowT x) y)
15:12:02 <FunctorSalad> hope that's at last right
15:12:11 <ksf> AppE (VarE 'foo) (VarE 'bar)
15:12:28 <FunctorSalad> they are so you can fit in quasiquotes without too much ugly
15:12:46 <FunctorSalad> names aren't q'ed in the monadic versions
15:13:10 <magicman> Wouldn't it be nice if TH would use the GHC library? Or is TH not GHC-specific?
15:13:20 <c_wraith> yeah.  things like varE exist so you can splice easily.
15:13:29 <ksf> ...I could have written mkName "foo" as that's gotta be local definitions
15:13:42 <FunctorSalad> magicman: at least the implementation is very entangled with GHC I guess
15:13:49 <FunctorSalad> (you can't install another TH version)
15:14:08 <magicman> *nod*
15:14:13 <ksf> what I dislike most is that functions aren't liftable
15:14:24 <c_wraith> ksf: you can quote them.  that's almost as good.
15:14:34 <FunctorSalad> ksf: makes sense, doesn't it?
15:14:46 <FunctorSalad> given haskell's no-reflection-about-functions doctrine
15:14:47 <FunctorSalad> ;)
15:14:48 <ksf> but I can't put a lambda into a data structure and then recurse on that structure to generate code
15:14:54 <ksf> ...that calls said function
15:15:01 <ksf> which would be the natural thing to do.
15:15:04 <FunctorSalad> use explicit binders
15:15:05 * pkrumins eats FunctorSalad {- tasty -}
15:15:14 <ksf> also, if I quote the function, I loose type safety in my structure.
15:15:42 <FunctorSalad> err wait, you can take apart quoted lambda expressions just fine with TH
15:16:07 <FunctorSalad> what you can't do is make up some value of function type, and have TH "serialize" it to source
15:16:19 <FunctorSalad> (which is a better description for "lift" maybe)
15:16:21 <ksf> the solution is tho quote the whole term including the lambdas, but then it's hell to properly resolve, typecheck and partial evaluate all that stuff.
15:16:55 <ksf> ...it doesn't need to be in source form. make it PrimFunction# Name
15:17:07 <FunctorSalad> pkrumins: I iz not cheeseburger :(
15:17:08 <ksf> ...something internal.
15:17:32 <ksf> I don't want to take it apart, just call it. which seems sensible as the generating code can call it.
15:17:41 <FunctorSalad> oldie but... http://www.drisgill.com/files/halp-i-not-cheezburger.jpg
15:18:23 <FunctorSalad> ksf: I guess I'm not quite following your use case
15:18:37 <FunctorSalad> but do you really need *lift*?
15:18:46 <ksf> ...in a sense yes, in most no.
15:18:53 <FunctorSalad> which would require serializing *arbitrary* closures to code
15:19:02 <FunctorSalad> something haskell doesn't have at all currently
15:19:05 <ksf> I just want to call a non-quoted function from generated code
15:19:24 <ksf> the generating code can do that, so it apparently isn't a staging problem.
15:20:06 <ksf> it's supporting passing functions per se, instead of only names.
15:20:21 <ksf> (names aren't type-safe)
15:20:32 <FunctorSalad> sorry, I've been up for a bit more than 24h I guess
15:20:47 <FunctorSalad> with some sekundenschlaf maybe
15:20:48 <FunctorSalad> ;)
15:20:53 <ksf> baldrian
15:21:16 <EvanR-work> meh type safety is over rated
15:21:40 <FunctorSalad> I *could* probably sleep if I just lied the *** down ;) but now I'm in a positive mood again, which makes you want to do lots of stuff at the computer
15:21:47 <ksf> said the **segfault at input.irc
15:22:23 <FunctorSalad> EvanR-work: really?
15:22:41 <EvanR-work> no
15:22:46 <EvanR-work> but no time for a follow up
15:24:03 <Twey> FunctorSalad: Microsleep?
15:25:13 <FunctorSalad> Twey: yep
15:26:02 <FunctorSalad> not operating heavy machinery while microsleeping and hallucinating is overrated        (irony)
15:26:20 <FunctorSalad> (I was at home all the time, don't worry :p)
15:26:32 <Twey> Heh
15:27:11 <FunctorSalad> ln -s /usr/bin/trash /usr/local/bin/rm helps
15:27:12 <FunctorSalad> ;)
15:27:24 <FunctorSalad> assuming /usr/local/bin comes before /bin in your path
15:28:09 * ksf doesn't have /usr/local
15:28:28 <FunctorSalad> *resists lolcat pun*
15:28:30 <ksf> nothing non-portage touches my /usr
15:28:42 <FunctorSalad> gentoo doesn't have this at all?
15:28:55 <FunctorSalad> what about your personal scripts at least? 
15:29:01 <FunctorSalad> (systemwide ones)
15:29:04 <ksf> and I only touched my /opt to move ut2004 to another partition (and link it)
15:29:14 <ksf> there's no systemwide personal stuff.
15:29:21 <ksf> that defies a multi-user os.
15:29:54 <FunctorSalad> uh, everything I might want to use as root belongs there in my book
15:29:59 <ksf> well ok there's a wheel-writeable /mnt/data
15:30:16 <FunctorSalad> using scripts in my user's home as root seems unwise
15:30:18 <ksf> I don't use anything but portage tools and vim as root
15:30:30 <FunctorSalad> (if my desktop was anywhere near security-critical :p)
15:30:40 <ksf> ...and as I don't need any fancy stuff editing config files, it's the defualt config
15:30:56 <FunctorSalad> heh. I have a script for making new scripts ;)
15:31:10 <FunctorSalad> they're free, use them often
15:31:27 <ksf> and even then, scripts for sysadmin use belong into /root/bin
15:31:28 <FunctorSalad> (for everything you typed more than once or twice)
15:31:41 <FunctorSalad> they might be useful to both
15:32:04 <ksf> I'm not root often enough for that to occur
15:32:09 <FunctorSalad> (I use scripts instead of aliases, they're more convenient)
15:32:33 <FunctorSalad> (work through execve as well as shell calls, and you get instant goto-definition through 'which')
15:32:38 <ksf> I didn't even change root's shell to zsh
15:33:00 <FunctorSalad> hmm I meant to learn zsh one day
15:33:21 <soupdragon> this is my ord function
15:33:26 <soupdragon> subtract 1 . fromIntegral . fromJust . findIndex (/= 0) . map (\i -> n `mod` p^i) $ [0..]
15:33:27 <ksf> I never actually learned it, but use it as a better bash
15:33:36 <soupdragon> @let ordI = subtract 1 . fromIntegral . fromJust . findIndex (/= 0) . map (\i -> n `mod` p^i) $ [0..]
15:33:37 <lambdabot>  Defined.
15:33:39 <soupdragon> hm
15:33:44 <soupdragon> @let ordI' p n = subtract 1 . fromIntegral . fromJust . findIndex (/= 0) . map (\i -> n `mod` p^i) $ [0..]
15:33:45 <lambdabot>  Defined.
15:33:47 <soupdragon> see:
15:33:51 <FunctorSalad> eh that doesn't look much like 'ord' ;)
15:34:04 <soupdragon> > map (flip ord (2^3*5^2)) [2,3,5]
15:34:05 <lambdabot>   Couldn't match expected type `a -> b'
15:34:05 <lambdabot>         against inferred type `GHC.Ty...
15:34:11 <ksf> for once, it doesn't return LT EQ GT
15:34:12 <soupdragon> > map (flip ordI' (2^3*5^2)) [2,3,5]
15:34:13 <lambdabot>   [3,0,2]
15:34:19 <ksf> -ce
15:34:23 <ksf> +e
15:34:30 <FunctorSalad> ksf: I'm afraid of wasting yet more time with something halfway better instead of making the haskell shell ;)
15:34:41 <soupdragon> @let factorial n = product [1..n]
15:34:42 <lambdabot>  Defined.
15:35:04 <soupdragon> > ord 7 (factorial (4*7*7 + 3*7 + 6))
15:35:05 <lambdabot>   Couldn't match expected type `t1 -> t'
15:35:05 <lambdabot>         against inferred type `GHC.T...
15:35:12 <soupdragon> > ordI' (factorial (4*7*7 + 3*7 + 6)) 7
15:35:14 <lambdabot>   0
15:35:18 <soupdragon> doh
15:35:53 <soupdragon> I was hoping for one that wasn't 0
15:37:04 <soupdragon> > ordI' 7 (factorial (4*7*7 + 3*7 + 6))
15:37:05 <lambdabot>   35
15:37:29 <soupdragon> > ((4*7*7 + 3*7 + 6) - (4+3+6))/(7 - 1)
15:37:30 <lambdabot>   35.0
15:38:03 <soupdragon> not sure if it works base 10
15:38:21 <soupdragon> but if it did that would tell you how many 0s there are at the end of a factorial I guess
15:40:35 <wli> floor(log n / log 5) ?
15:41:30 <soupdragon> are the integers still a ring if we set 10 = 1?
15:41:39 <soupdragon> (but not 9 = 0)
15:41:49 <soupdragon> no theyre not..
15:42:42 <djahandarie> Hmmm... given a bunch of random points, what would be the fastest way to calculate a quadrilateral that contains all of the points?
15:43:03 <soupdragon> any quad? if so you could just take the min and max x and y coordinates
15:43:09 <soupdragon> that's O(n)
15:43:26 <djahandarie> No, the tightest quad possible
15:44:00 <twanvl> that sounds pretty hard
15:44:15 <djahandarie> Yeah
15:44:24 <Veinor> especially because the vertices aren't guaranteed to be in the set of points
15:44:29 <soupdragon> no idea how to do that. I'd try starting with a convex hull
15:44:34 <Veinor> and in general will not be.
15:44:51 <djahandarie> Blah I hadn't even thought of that Veinor
15:44:53 * djahandarie sighs
15:45:10 <Veinor> wait, they might be
15:45:23 <Veinor> I think they will be, actually
15:45:29 <twanvl> just consider a circle of points, for example
15:45:35 <Veinor> oh yeah
15:45:37 <Veinor> duh
15:45:46 <djahandarie> Right
15:46:08 <Veinor> yeah, this sounds like a rather difficult problem
15:46:09 <hpc> what's the definition of tightest?
15:46:15 <hpc> smallest rectangular area?
15:46:22 <hpc> or width+height?
15:46:32 <djahandarie> Smallest area
15:46:34 <twanvl> do you want a rectangle or a general quad?
15:46:40 <djahandarie> General quad
15:46:43 <twanvl> does it even have to be convex?
15:47:02 <hpc> convex is easier
15:47:11 <hpc> i think
15:47:16 <twanvl> probably
15:47:33 <twanvl> then you can work with half-planes
15:47:39 <danharaj> the quad would contain the convex hull anyway
15:48:05 <twanvl> not necessarly if the quad isn't convex
15:48:43 <danharaj> true, but what application wants a non-convex shape as input?
15:48:55 <djahandarie> It would need to be convex
15:48:56 <hpc> not wants; allows
15:49:03 <soupdragon> ordI' p (n!) = (n - sum of digits of n)/(p-1) in general
15:49:26 <hpc> so convex hull yields an n-gon
15:49:29 <danharaj> are we allowing degenarate quads, like if the input is three points?
15:49:43 <djahandarie> It would always be at least 4 points
15:50:45 <Veinor> math overflow says you can do it in O(n^2)
15:51:09 <djahandarie> That means this is computationally harder than the convex hull
15:51:20 <forrestv> this is my first haskell program - a tictactoe ai. can anyone offer a better way to implement the 'children' function? http://im.forre.st/pb/78631555.txt
15:51:22 <djahandarie> Which has a lower bound of n log n
15:51:40 <hpc> each side of the ngon has a normal, and a length unti it exits the hull
15:51:45 <danharaj> you could probably get much better complexity if you approximate it, but I don't know if that is appropriate for your case.
15:51:45 <soupdragon> forrestv, you can use (>>=) which is concat and map together
15:52:12 <djahandarie> danharaj, it's appropriate, but I'm not sure if it'd be simpler to get a fairly-accurate approximation
15:52:17 <twanvl> or concatMap
15:52:20 <Veinor> http://www.springerlink.com/content/n4p370p487551686/fulltext.pdf
15:52:22 <Cale> forrestv: Perhaps a list comprehension
15:52:26 <Veinor> this is what the math overflow article links
15:52:27 <soupdragon> there is a reason I asid >>= rather than concatMap
15:52:37 <djahandarie> Ugh
15:52:52 <Veinor> I can see if I can pull the PDF
15:53:04 <forrestv> well i meant those nested lambda functions. the 'children' function returns a list of arrays, each with a 0 in the original replaced with 'role'
15:53:07 <djahandarie> Please, since I don't have access to SpringerLink :(
15:53:11 <Veinor> sure
15:53:18 <Veinor> go go gadget X forwarding
15:53:20 <danharaj> Only forest sprites have access to SpringerLink.
15:53:25 <djahandarie> Haha
15:53:25 <alexyk> dons: any new stuff for me to try speedzupz?
15:53:30 <twanvl> forrestv: you should never have to loop over indices in haskell, use map on the list itself rather than [0..length xs-1]
15:54:05 <forrestv> twanvl, but i use the index to replace an element in the list ... if i map over the list i can't replace the item
15:54:06 <Cale> You don't care, after all, what the index actually is, just that you want to replace the value there.
15:54:45 <Cale> So probably what you really want is a way to get all separations of a list into a first part, a value, and a last part
15:55:15 <forrestv> exactly, then filter that to values that equal 0 and replace them with role
15:56:23 <Veinor> djahandarie: success!
15:56:27 <djahandarie> Nice
15:56:28 <Veinor> gimme a sec and I'll download it
15:56:39 <Cale> separations [] = []; separations (x:xs) = ([],x,xs) : [(x:us,v,vs) | (us,v,vs) <- separations xs]
15:58:21 * wli wonders what's breaking hmatrix on gentoo on 6.12.3
15:59:08 <Veinor> oh, beh
15:59:15 <Veinor> it just improves a result via some arcane method
15:59:27 <djahandarie> Huh
15:59:30 <Veinor> it doesn't give an algorithm
15:59:36 <djahandarie> lol
15:59:38 <Veinor> http://www.archive.org/details/minimumareacircu00agga
15:59:48 <Veinor> n^2 log n log k to find a minimum-area circumscribing k-gon
15:59:52 <forrestv> thanks .. going to read about list comprehensions now
16:00:01 <Cale> children role board = [concat [preRows, [concat [pre, [role], post]], postRows] | (preRows, row, postRows) <- separations board, (pre, x, post) <- separations row, x == 0]
16:00:22 <Cale> Might want to write that more nicely across multiple lines :)
16:00:39 <wli> maybeGetPersistBuildConfig is returning Nothing instead of Just something.
16:00:40 <djahandarie> I'd need to calculate the n-gon first also
16:00:44 <wli> Not sure what that does.
16:01:02 * Veinor scans the PDF
16:01:38 <djahandarie> Ugh
16:01:41 <Veinor> oh, yeah
16:01:41 <djahandarie> Getting a headache
16:01:45 <Veinor> you need to find the convex hull first
16:01:48 <djahandarie> Yeah
16:01:54 <twanvl> djahandarie: the n-gon is just the convex hull, right? if you need code for that I have some laying around
16:01:59 <djahandarie> Yes it is
16:02:00 <Veinor> that doesn't change your asymptotics though
16:02:02 <djahandarie> It wouldn't be difficult
16:02:04 <djahandarie> It'd just be longer
16:02:05 <djahandarie> Yeah
16:02:08 <djahandarie> Still slower though
16:02:51 <Veinor> well
16:02:58 <Cale> It's more readable like this:
16:02:59 <Veinor> http://www.amateurtopologist.com/fulltext.pdf
16:02:59 <Cale> children role board =
16:02:59 <Cale>   [concat [preRows, [concat [pre, [role], post]], postRows]
16:03:00 <Cale>   | (preRows, row, postRows) <- separations board,
16:03:00 <Cale>     (pre, x, post) <- separations row,
16:03:00 <Cale>     x == 0]
16:03:02 <danharaj> djahanderie: How big do you think N will be in your use cases?
16:03:05 <Veinor> that's the springerlink article
16:03:13 <wli> Where are the docs for Distribution.Simple.Config?
16:03:29 <danharaj> Veinor: The Springer police will kill you in your sleep now ;)
16:03:31 <Cale> sadly, this separations function isn't in the libraries
16:03:33 <Veinor> oh noes D:
16:03:55 <forrestv> hmm.
16:03:55 <Veinor> it's funny, I tried just wgetting the link and it gave me a 403
16:03:55 <Cale> along with the following function, it's really handy
16:03:58 <Veinor> I had to open it in firefox
16:04:08 <djahandarie> danharaj, ... pretty big, not sure of the exact range though
16:04:18 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
16:06:00 <twanvl> Cale: select is even more useful when it also returns a setter
16:06:10 <Veinor> select xs = map (\x -> (x, delete x xs)) xs
16:06:18 <Cale> Veinor: that's not quite right
16:06:30 * wli tries a newer cabal
16:06:30 <Cale> For two reasons
16:06:41 <Cale> One is that delete requires an Eq instance
16:06:48 <Veinor> true.
16:06:48 <Cale> The other is that it always deletes the first occurrence.
16:06:59 <Veinor> ahh, yeah.
16:07:00 <Veinor> d'oh
16:07:12 <dcoutts_> wli: I presume the docs are on hackage
16:07:23 <aristid> :t select
16:07:23 <lambdabot> Not in scope: `select'
16:07:36 <Cale> select :: [a] -> [(a,[a])]
16:07:40 <wli> I eventually found the doc for the function
16:10:21 <twanvl> > let select' [] = []; select' (x:xs) = (x,\f -> f xs) : [(y,\f -> x:ys f) | (y,ys) <- select' xs]  in [xs (toUpper x:) | (x,xs) <- select' "abc"] -- maybe this is too general to be actually useful?
16:10:22 <lambdabot>   ["Abc","aBc","abC"]
16:11:00 <wli> hdbc and derive are still failing but let's see if hmatrix comes through
16:38:27 <soupdragon> Cale - I just thought of something
16:38:58 <soupdragon> if you have f : |R -> |R and Df : |R -> |R, why is D^2f = D(Df) rather than (Df)(Df)?
16:39:03 <soupdragon> (the derivaitev)
16:39:37 <monochrom> D^2 is just notational convention
16:39:48 <soupdragon> I wonder if (D,+,o) forms a ring
16:39:49 <aristid> :t let select' [] = []; select' (x:xs) = (x,\f -> f xs) : [(y,\f -> x:ys f) | (y,ys) <- select' xs]  in select'
16:39:50 <lambdabot> forall t. [t] -> [(t, ([t] -> [t]) -> [t])]
16:41:18 <djahandarie> Man, it's a little daunting when I'm trying to solve a problem similar to one that Shor solved
16:41:36 <aristid> :t let select' [] = []; select' (x:xs) = (x,\f -> f xs) : [(y,\f -> x:ys f) | (y,ys) <- select' xs] in map (second ($id)) select'
16:41:37 <monochrom> I solved a problem Gauss tried to solve.
16:41:37 <lambdabot>     Couldn't match expected type `[(d, (a -> a) -> b)]'
16:41:37 <lambdabot>            against inferred type `[t] -> [(t, ([t] -> [t]) -> [t])]'
16:41:37 <lambdabot>     In the second argument of `map', namely `select''
16:41:39 <djahandarie> On the bright side at least there is a similar problem that someone has solved ;)
16:41:52 <monochrom> oh wait, I didn't, I was just taught the solution
16:41:58 <sinelaw> what's up with Knuth's upcoming "groundbreaking" announcement?
16:42:07 <sinelaw> ground shaking, whatever
16:42:07 <djahandarie> That he is finally dead
16:42:12 <aristid> :t let select' [] = []; select' (x:xs) = (x,\f -> f xs) : [(y,\f -> x:ys f) | (y,ys) <- select' xs] in map (second ($id)) . select'
16:42:13 <lambdabot> forall d. [d] -> [(d, [d])]
16:42:29 <sinelaw> djahandarie: i doubt he'll announce that
16:42:34 <monochrom> it's a joke announcement of "next generation TeX is called iTeX, it can do animation, 3D printing, stereographical sound"
16:42:36 <ddarius> soupdragon: It does.
16:43:35 <sinelaw> monochrom: really, that was it?
16:43:36 <ddarius> Also, f^2(x) normally means f(f(x)) with the exception of trigonometric functions.
16:43:43 <monochrom> http://science.slashdot.org/story/10/07/01/2153202/  http://twitter.com/christopheradam/status/17453998408  http://twitter.com/search?q=%23TUG2010
16:43:48 <sinelaw> so Knuth is a troll. 
16:44:06 <pizza_> trolling is an art
16:44:29 <l-b> a art
16:44:46 <sinelaw> a troll
16:49:35 <sinelaw> @quote troll
16:49:36 <lambdabot> qwe1234 says: are you really this dense, or just trolling me?
16:50:15 <soupdragon> @quote art
16:50:15 <lambdabot> lambdabot says: why on the earth whould I slap dons with a wet trout
16:50:28 <Cale> soupdragon: D isn't a set, so that's not quite right, but nearly so. :)
16:50:39 <soupdragon> hm
16:51:05 <Cale> soupdragon: It belongs to the algebra of linear transformations on the vector space of infinitely differentiable functions R -> R
16:51:28 <sinelaw> Cale: ooh, what are you discussing?
16:51:38 <Cale> sinelaw: The derivative operator
16:51:39 <sinelaw> analytic functions?
16:51:53 <Cale> Or sure, analytic functions too if you prefer
16:52:05 <soupdragon> is that C_\infty
16:52:39 <sinelaw> Cale: having a power series that locally converges to the function is equivalent to being analytic?
16:52:54 <sinelaw> (i was just pondering this)
16:53:01 <Cale> Yes.
16:53:09 <Cale> Er, "locally"?
16:53:28 <Cale> Having a power series that converges to the function everywhere is the definition of analytic.
16:53:28 <sinelaw> Cale: not neccesarily uniformly in a region
16:54:27 <soupdragon> well D : (|R -> |R) -> (|R -> |R)
16:54:35 <soupdragon> so is the ring ((|R -> |R) -> (|R -> |R),+,o) ?
16:54:44 <Cale> yes
16:54:48 <soupdragon> (P + Q)(f) = P(f) + Q(f)
16:54:55 <soupdragon> (P o Q)(f) = P(Q(f))
16:55:11 <Cale> Actually I was restricting us to linear transformations
16:55:24 <soupdragon> ((|R -> |R) -o (|R -> |R),+,o) ?
16:55:24 <Cale> on the space of infinitely differentiable functions
16:55:37 <Cale> L(C^\infty, C^\infty)
16:55:39 <soupdragon> (C_\infty -o C_\infty,+,o)
16:55:42 <soupdragon> okay
16:55:59 <soupdragon> I think there is a chance this is a field
16:56:02 <Cale> Or sure -o or whatever other notation you'd like for linear maps from one space to another :)
16:56:06 <Cale> It's not a field.
16:56:14 <Cale> It has zero divisors.
16:56:15 <soupdragon> I want to make it a field
16:56:36 <Cale> Also, it's not commutative.
16:56:56 <soupdragon> one thing which sucks is like
16:57:10 <Cale> It is more analogous to a matrix ring, in that it's a ring of linear maps
16:57:20 <soupdragon> say you had (D^2+1)y = k
16:57:23 <Cale> and it's an algebra
16:57:30 <soupdragon> you might want to factor it (D+i)(D-i)y = k
16:57:43 <Cale> In fact, that's common.
16:57:45 <soupdragon> but does that even work
16:57:48 <Cale> yes, it does
16:57:56 <soupdragon> but we used o rather than x for product
16:58:15 <Cale> mhm
16:58:22 <sinelaw> Cale: btw, is the derivative sometimes defined using only the Radon-Nikodym approach? seems more general
16:58:36 <soupdragon> so a constant c is interpreted as (c*)
16:58:42 <soupdragon> and composition is then multiplication
16:59:23 <Cale> sinelaw: hmm
16:59:33 <soupdragon> are there books which treat this sort of stuff
16:59:34 <soupdragon> ?
17:00:05 <Cale> soupdragon: Sure, a good textbook on linear algebra should present things in enough generality that this falls out.
17:00:42 <Cale> This is generally true of the algebra of linear operators on a vector space.
17:01:27 <Cale> sinelaw: I unfortunately don't know as much about Radon-Nikodym derivatives as I probably ought to.
17:01:44 <sinelaw> Cale: nor do I, i just learnt about them a few weeks ago
17:01:49 <sinelaw> Cale: they seem very general
17:01:56 <soupdragon> it's functional analysis?
17:02:17 <Cale> sinelaw: It was something that we missed out on in our measure theory course because our Real Analysis 2 prof had sucked, and our measure theory prof had to pick up the slack. :)
17:03:49 <Cale> (He'd sucked enough that the head of the pure mathematics department personally apologised to us for appointing him to handle that course)
17:05:04 <sinelaw> for every measure u absolutely continuous relative to measure p, there is a measurable function z, that is unique (up to null-measure set) such for every subset A in the sigma-algebra for the measures, the integral on A of z dp is equal to u(A)
17:05:43 <sinelaw> z is the Radon-Nikodym derivative of u relative to p
17:05:51 <sinelaw> notation: z = du/dp
17:06:50 <sinelaw> mind-boggling
17:06:53 <sinelaw> to say the least
17:07:04 <sinelaw> but stated in very general terms
17:08:13 <soupdragon> haha wtf
17:08:23 <Cale> soupdragon: what?
17:08:28 <soupdragon> that sinelaw thing
17:08:54 <soupdragon> I guess you don't make sense of it directly.. but produce instances of it instead
17:09:10 <Cale> All of the terms there are pretty familiar to me, though I might like to refresh my understanding of the definition of absolute continuity of one measure with respect to another.
17:09:25 <Cale> It makes sense. I wouldn't know how to prove it though.
17:09:50 <sinelaw> soupdragon: one instance is the existence of probability density functions for continuous random variables
17:10:03 <Cale> (I have some intuition for what absolute continuity of measures with respect to one another means, but I forget the details)
17:10:15 <soupdragon> I should learn probability but Im really bad at it :[
17:11:59 <sinelaw> Cale: absolute continuity is simple: u is aboslutely continuous relative to p if for all A in the sigma algebra such that p(A) = 0, it is true that u(A) also = 0 .
17:12:49 <Cale> sinelaw: Ah, right, that makes sense.
17:12:58 <sinelaw> Cale: but i fail to see the intuitive interpertation as continuity here
17:14:38 <soupdragon> sinelaw that might be /the/ most abstract definition I've ever seen
17:15:04 <lispy> "Dictionaries at run time reflect context reductions at compile time, in a shining instance of the Curry-Howard correspondence."  <-- what is a context reduction?  How is this an example of  curry-howard?
17:15:37 <soupdragon> you know what a context is
17:15:49 <soupdragon> Gamma |- x : T,   Gamm is the context
17:15:56 <soupdragon> Gamma
17:16:05 <ddarius> lispy: In the context of type classes?
17:16:08 <soupdragon> reduction is just when yuo make it smaller
17:16:26 <lispy> ddarius: yeah, this is in reference to type classes
17:16:30 <Cale> sinelaw: Well, if you take p to be the usual Lebesgue measure, then it implies that u has no "atoms", and so if you look at it as a cumulative distribution function, it's continuous
17:16:54 <lispy> soupdragon: So, it's been a while since I thought about that notation.  Gamma is a set of types?
17:17:09 <Cale> Oh, neat
17:17:09 <soupdragon> yeah maybe an ordered sequence sometimes
17:17:25 <sinelaw> Cale: interesting
17:17:26 <ddarius> soupdragon: Read "Probability Theory: The Logic of Science"
17:17:28 <Cale> Apparently, absolute continuity is a preorder on the space of measures on a space
17:17:41 <soupdragon> ddarius: I do intend to yes
17:17:45 <sinelaw> Cale: it's even denoted that way, u << p
17:17:48 <Cale> Yeah
17:18:03 <Cale> So, that's a category, hmm :)
17:18:09 <sinelaw> hah :)
17:18:15 <sinelaw> i still don't grasp the intuition here
17:18:19 <monochrom> (now you can make it more abstract)
17:18:28 <lispy> soupdragon: so, the dictionary reflects a narrowing of Gamma, but then what is the bit about curry-howard?
17:18:33 <ddarius> lispy: The dictionary passing is evidence for the logical content of type class constraints much like a value is evidence of the logical content of a type(/proposition)
17:20:04 <lispy> ddarius: So, the passing of the dictionary is analogous to passing a value of a type? Implying that a class constraint on a function is like passing a type to the function? (eg. first class type)
17:20:06 <Cale> So here's an open question: Is this category the skeleton of any more interesting category whose objects are measures on the same measurable space?
17:20:58 <sinelaw> Cale: I'm having enough trouble grasping this as it is :)
17:21:00 <Cale> For this to be the case, we would perhaps want some sort of mapping where there would be a mapping μ -> ν if and only if μ << ν
17:21:36 <ddarius> lispy: No.  A class constraint on a function is like is an implication, just like another function.  Indeed, classes constraints get translated into function arguments.
17:21:45 <Cale> Measure contraction mappings?
17:21:54 <ddarius> Eq a => a ~> EqD a -> a
17:22:01 * hackagebot concatenative 1.0.1 - A library for postfix control flow.  http://hackage.haskell.org/package/concatenative-1.0.1 (SamAnklesaria)
17:22:13 <Cale> (Those might have a better name... I forget)
17:22:34 <lispy> ddarius: I think we're actually trying to talk about the same thing
17:22:48 <ddarius> lispy: That's my intent.
17:22:55 <ddarius> There are no "first class types" here.
17:23:17 <lispy> ddarius: Well, a type class is a set of types.
17:23:23 <Cale> Or, no, that's the wrong way around :)
17:23:43 <lispy> ddarius: so if you use the function at a particular instance, you've essentially passed a type to the function, right?
17:23:49 <Cale> Er, no, heh, it's right
17:24:06 <ddarius> lispy: No more than any polymorphic function.  That's the polymorphism, not type classes.
17:24:36 <lispy> ddarius: except, that the function can do things to figure out which instance it has
17:24:49 <lispy> ddarius: if the type class has a member that permits it
17:25:02 * hackagebot WebCont 0.0.1 - Continuation based web programming for Happstack  http://hackage.haskell.org/package/WebCont-0.0.1 (SamAnklesaria)
17:25:17 <ddarius> lispy: A function can do thing to figure out "what type it has" as long as the passed in information permits it.
17:25:20 <lispy> ddarius: whereas with parametric polymorphism I don't think you can do that?
17:26:02 <sinelaw> Cale: conditional expectation has a pretty funky definition too
17:26:30 <sinelaw> that i'm also trying to grasp
17:27:48 <ddarius> lispy: Eq a => a -> Bool is exactly equivalent to (a -> a -> Bool) -> a -> Bool in the dictionary translation.  There is no "magic" in type classes.
17:28:27 <sinelaw> conditional expectation of X given B is a function that has the same integral as X on all subsets of a sub-sigma algebra of what X is defined over
17:28:31 <vin> I want to learn haskell, I know some programming lanuagues but none of them are functional, can you reccommend a book?
17:28:40 <sinelaw> (that sub-sigma algebra is B)
17:28:40 <ddarius> @where rwh
17:28:41 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:28:42 <ddarius> @where lyah
17:28:43 <lambdabot> http://www.learnyouahaskell.com/
17:28:48 <sinelaw> vin ^^^^^
17:28:54 <sinelaw> or the one before
17:29:11 <Cale> Well, let's see, we've got this measurable space (X,Σ), and our objects are all the measures on it, and we'll consider a map μ -> ν in our category to be a measurable function f:X -> X such that for each A in Σ, we have μ(A) <= ν(f(Α)), so that whenever the identity function is a map μ -> ν, then we have μ(A) <= ν(f(A)), and then if ν(A) = 0, then μ(A) = 0
17:29:17 <Cale> But this isn't quite right.
17:29:22 <monochrom> read both
17:29:25 <Cale> Because there will be lots of others.
17:29:34 <monochrom> in fact you should read 3 things
17:29:48 <lispy> ddarius: actually, don't you need another step to look up the (a -> a -> Bool) in the Eq a dictionary tho?
17:30:06 <Cale> But maybe that's an interesting category anyway, and it has a nice functor from the absolute continuity category into it.
17:30:54 <lispy> ddarius: I need to run, but I think my view point is consistent
17:31:24 <lispy> But perhaps a better way to phrase it is that using a type class constraint makes your function type indexed
17:31:34 <lispy> on a finite open set of tyes
17:31:44 <Cale> So I guess I was right that I was wrong. These f's are more like expansion mappings :)
17:31:54 <ddarius> lispy: A type class constraint doesn't limit to a finite set of instantiations.
17:32:04 <ddarius> E.g. there are an infinite number of types that satisfy Eq.
17:32:10 <lispy> okay
17:32:24 <lispy> So, an open set of types :)
17:32:37 <Cale> The measure of the image is larger than the measure of the original.
17:32:44 <dolio> That's a rather different way of looking at type classes.
17:32:52 <dolio> That doesn't involve dictionaries at all.
17:33:06 <dolio> At least, not necessarily.
17:33:25 <ddarius> lispy: Yes, what dolio said.  You can probably make that work out, but then it doesn't have much to do with your original question.
17:33:59 <lispy> ddarius: no?
17:35:15 <lispy> Well, I think my view point is also independent of dictionaries
17:35:46 <dolio> From that perspective, a constraint on your function gives it license to use some variety of typeCase operator, that inspects the type in question.
17:36:02 <duairc> I was wishing for ages that there was an mproduct, analogous to msum, and then I realised that it was sequence <3
17:36:13 <ddarius> Yep.
17:36:14 * lispy leaves
17:36:18 <lispy> thanks guys
17:36:54 <monochrom> haha
17:37:10 <ddarius> duairc: mplus and mzero are (obviously) "additive" and (>=>) and return are "multiplicative."
17:38:46 <duairc> Yeah, I knew that but I just didn't quite fully make the leap
17:40:41 <duairc> How is >=> pronounced?
17:41:12 <dolio> It's a type of composition.
17:42:13 <duairc> I guess what I'm asking is what you would say if you were talking about it in person, or would you just say "Kleisi composition"?
17:42:23 <dolio> Sure.
17:42:28 <dolio> Or "fish".
17:42:43 <duairc> :)
18:00:47 <dons> dafis: sent you some new IntMap
18:02:36 <dafis> dons: thanks, just arrived
18:03:37 <dons> currently, just one instance for IntMap Int, but you get the idea.
18:04:03 <dons> for super simple benchmarks that's about twice as fast as regular IntMap. so will be interesting in alexyk's code.
18:04:34 <dons> we can do a similar thing with [(Int,Float)] -> [Pair Int Float]
18:04:44 <dons> to increase data density
18:06:07 <dafis> dons: looks promising
18:07:43 <dafis> I'm currently finishing the new stringsearch release, shouldn't take long anymore (though I still need to write docs ugh), after that, I'll dive into the new IntMap and do a little benchmarking
18:11:26 <augur> holy moly that was tricky
18:11:35 <augur> ahh! netsplit! D:
18:11:47 * tg_ vomits at the stench of netsplit death
18:26:46 <okapi> Does anyone have experience calling Haskell from C?  This is the only good tutorial I've found: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C  However, is there any way to automate the process?
18:38:37 <jbapple> Am I pwned, or does www.haskell.org have a bizarre and invalid SSL certificate for everyone else, too?
18:39:09 <jbapple> ff tells me "The certificate is not trusted because it is self signed. The certificate is only valid for localhost.localdomain. The certificate expired on 05/25/2005 06:26 AM."
18:48:03 <magee0> that sounds strange
18:50:34 <dolio> jbapple: I see the same thing.
18:52:28 <technogeeky> jbapple: me 3
18:53:04 <technogeeky> hey conal
18:53:27 <conal> technogeeky: hi
18:54:56 <technogeeky> conal: been a while. I'm the same one as on gchat, of course. :) How have you been?
18:55:44 <conal> technogeeky: i'm enjoying the summer weather & outside work.  and my iphone/ipad programming.  you?
18:56:49 <kniu> @hoogle show
18:56:50 <lambdabot> Prelude show :: Show a => a -> String
18:56:50 <lambdabot> Text.Show show :: Show a => a -> String
18:56:50 <lambdabot> module Text.Show
18:57:34 <technogeeky> conal: mostly the same. lots of exercise, some sun, some pool. some work.
18:57:34 <jbapple> To whom should I report the invalid SSL cert on www.haskell.org
18:57:46 <technogeeky> lots of reading.
18:58:07 <technogeeky> i got a little bit of a tan so I don't look like casper the ghost
18:58:09 <jbapple> I can't find a good trac instance to report it on
18:58:49 <technogeeky> jbapple: http://www.whois.net/whois/haskell.org
18:58:59 <conal> technogeeky: :)
18:59:02 <technogeeky> Registrant Email:peterson-john@CS.YALE.EDU
18:59:09 <technogeeky> peterson-john@cs.yale.edu
18:59:18 <technogeeky> and/or morrow.long@YALE.EDU
18:59:54 <technogeeky> conal: is there a public repo for your work?
19:00:34 <conal> technogeeky: in general, or specifically the iphone/ipad stuff?
19:00:58 <technogeeky> conal: the i{phone|pad} stuff
19:01:29 <conal> technogeeky: not yet.  are you interested in iOS programming?
19:03:01 <technogeeky> conal: absolutely. I'm interested in creating a ubiquitious UI that supports {voice command, multitouch, soft keyboard, hard keyboard, touchscreen, etc ..} on {android, iOS}
19:03:18 <technogeeky> and overlays for existing applications
19:03:27 <conal> technogeeky: oh, cool!
19:03:31 <technogeeky> i haven't done any work on iOS yet, but I have on android
19:03:42 <technogeeky> I have access to two iPads and two "old people" who will beta test for me :o
19:03:58 <technogeeky> the voice command is the most difficult/novel part.
19:04:11 <technogeeky> that's what d:rive is supposed to be
19:05:23 <technogeeky> I found another Haskell-er (who was taught by Phil Wadler, it turns out) that is interested in the very same subject
19:05:45 <soupdragon> you are using haskell on the iPad?
19:06:02 <technogeeky> his interest (his angle) is to handle dyxlexia and dysporia? (sp?), whereas mine is for autism
19:06:13 <technogeeky> soupdragon: I am not, but conal is, as far as I know.
19:06:39 <dobblego> does Parsec have a combinator for 0 or many tokens with 1 or more spaces between?
19:07:01 <soupdragon> I think sepBy does that
19:07:24 <dobblego> looks promising thanks
19:07:25 <soupdragon> sepBy token (many1 spaces)
19:07:56 <ddarius> If you are using TokenParser parsers, they already handle whitespace.
19:08:21 <technogeeky> one really pressing interest I have
19:08:39 <technogeeky> in Haskell and visualization, is something to provide a really baseline framework for viewing the Haskell language itself visually
19:08:54 <technogeeky> like type definitions, and alternate representations of code (or code graphs)
19:09:16 <technogeeky> well, I mean Haskell code files, not the language itself per-se.
19:10:12 <conal> technogeeky: do you know whether you're trying to capture syntax or semantics (code or meanings of code)?
19:10:26 <technogeeky> code: both, eventually, but syntax first
19:10:58 <technogeeky> I feel like the best way I could describe it
19:11:46 <technogeeky> is to provide a graphical symbolic shell for viewing Haskell code and files
19:12:00 <conal> ah.
19:12:04 <technogeeky> like LaTeX Haskell
19:12:16 <technogeeky> that'
19:12:20 <technogeeky> that's not quite right.
19:12:31 <technogeeky> let me find a link, because I remember seeing what I wanted to emulate
19:13:41 <alexyk> technogeeky: like Hutton's book?
19:14:00 <technogeeky> so
19:14:03 <technogeeky> I was inspired by this: http://www.pitt.edu/~jdnorton/teaching/HPS_0410/chapters/general_relativity_massive/index.html
19:14:41 <technogeeky> though he has inserted a lot more picture pictures than he had before
19:14:49 <technogeeky> it used to be all hand-drawn diagram kind of pictures
19:15:30 <technogeeky> alexyk: i haven't read it, so I can't say
19:15:41 * conal adds to InstaPaper
19:15:45 <alexyk> technogeeky: it's set with pretty symbols instead of ASCII
19:16:11 <technogeeky> alexyk: then yes, that kind of thing. Instead (or, rather, in addition to) type signatures I wanted simplie little diagrams
19:16:14 <technogeeky> showing dots and arrows
19:16:42 <alexyk> technogeeky: well he just replaces -> with \fancyarrowmyarse and such
19:17:07 <alexyk> physicists have the most fun until they need a job
19:17:23 <technogeeky> alexyk: i'm in that precise position now :)
19:17:25 <alexyk> (then they become quants)
19:17:39 <alexyk> technogeeky: Wall St. is the address
19:17:51 <technogeeky> alexyk: I don't work with thieves.
19:18:10 <alexyk> technogeeky: then a functional programmer! :)
19:18:18 <soupdragon> :t ordI'
19:18:19 <lambdabot> forall a t. (Num t, Integral a) => a -> a -> t
19:18:28 <technogeeky> alexyk: precisely. :)
19:18:35 <soupdragon> > ordI' 5 (2*5*5 + 2*5 + 1)
19:18:36 <lambdabot>   0
19:18:40 <soupdragon> > ordI' 5 (factoral (2*5*5 + 2*5 + 1))
19:18:42 <lambdabot>   Not in scope: `factoral'
19:18:50 <technogeeky> Plus, I actually want to accomplish something new in physics, not just use existing physical mathematics to build bigger bubbles
19:18:51 <soupdragon> @let factorial n = product [1..n]
19:18:52 <lambdabot>  <local>:3:0:
19:18:52 <lambdabot>      Warning: Pattern match(es) are overlapped
19:18:52 <lambdabot>               In...
19:18:53 <soupdragon> > ordI' 5 (factoral (2*5*5 + 2*5 + 1))
19:18:54 <lambdabot>   Not in scope: `factoral'
19:18:57 <soupdragon> @let factorial' n = product [1..n]
19:18:58 <lambdabot>  Defined.
19:19:00 <soupdragon> > ordI' 5 (factorial (2*5*5 + 2*5 + 1))
19:19:01 <lambdabot>   14
19:20:06 <alexyk> so I'm still confused on the following subject.  I have floats which only become such from division of integers.  I specify things as constants: 0, 1; multiply with *, add/subtract, divide with /.  Can I keep everything as Fractional instead of converting some values to Double and still be performant?  clearly the numerators/denominators will exceed machine words at some point
19:20:48 <technogeeky> alexyk: I don't know, but I want to know the answer :)
19:21:00 * technogeeky hangs a hat on alexyk's remark
19:21:11 <alexyk> technogeeky: depends, some people think Wall St. is "the real world" where you can "accomplish" "measureable things"
19:21:28 <alexyk> as opposed to "blah-blah" and "theory"
19:21:38 <technogeeky> alexyk: Sure. But I want to work on theory. And unification physics.
19:21:41 <dons> alexyk: sent you an experimental version of IntMap (in the AdaptMap.hs module)
19:21:47 <alexyk> where the only "measurable" thing is $$$
19:22:03 <technogeeky> All they do is badly misuse mathematics they only partially understand (I don't say this because of my lack of humility; nobody fully understands it)
19:22:05 <alexyk> dons: got it.  Should I just plug it in?
19:22:33 <dons> well, it might be nice to benchmark the bundle i sent you
19:22:47 <dons> since i don't have your big data set, but it should help the most on larger stuff 
19:23:00 <alexyk> technogeeky: well if you're the best-understanding among those partially understanding, and the fastest, you make said $$$ :)  fun for some
19:23:01 <dons> replaces IntMap Int with an optimized representation
19:23:17 <alexyk> dons: cool cool, will try
19:23:22 <soupdragon> im so confused
19:23:34 <technogeeky> alexyk: that's a good point. Maybe if I have some success, I'll shift my goals. But for now, I'm in it for the maths and them alone.
19:23:54 <soupdragon> if I count up like 1,2,3,4,10,11,12,13,14,20,...30,...,40...100,...110,...120,...130,...140...200,..210.
19:24:22 <alexyk> dons: after subtracting disk writes, ocaml and haskell are -- how do you say it about horses running nose to nose?
19:24:28 <soupdragon> and circle the numbers that are divisible by 10: (10),(20),(30),(40),((100)),(110),(120),(130),(140),((200)),(210)
19:24:38 <soupdragon> the number of circles is 13
19:24:42 <soupdragon> but the haskell code prints 14
19:24:55 <technogeeky> alexyk: neck and neck?
19:24:58 <soupdragon> doesn't make sense...
19:25:08 <technogeeky> chomping at the bit?
19:25:55 <pizza_> neigh.
19:26:02 <alexyk> technogeeky: yeah; in Russian there's an idiom "nostril to nostril", impying the hot breath of the pursuit
19:26:20 <technogeeky> alexyk: for some reason, that grosses me out a bit
19:26:44 <alexyk> technogeeky: see, that's why you're in theory!  would a doctor in bloody overalls program in Haskell?
19:26:54 * alexyk wonders
19:27:19 <alexyk> technogeeky: there's a inter-lane distance between said nostrils
19:27:21 <ezyang> Back to thinking monoidal categories and monoid objects. 
19:27:34 <dons> alexyk: let me know how the bundle i sent you works (that's using the intmap branch from a few days ago)
19:27:40 <blackdog> alexyk: in english, it sounds perversely erotic
19:27:53 <technogeeky> blackdog: you said it, not me!
19:27:54 * technogeeky rofls
19:27:55 <ddarius> blackdog: You're weird.
19:28:11 <ezyang> I'm looking at the WP definition, and I'm a little confused how monoid objects can have more than one generating object. 
19:28:20 <blackdog> ddarius: nolo contendere
19:28:34 * technogeeky highlights the part "I'm looking at the WP definition, and I'm a little confused..."
19:28:39 * technogeeky bets the problem is there
19:28:54 <ezyang> since the arrows that the article mentions aree simply M <*> M -> M and I -> M 
19:29:31 <ddarius> I don't know what you mean by "generating object" in this context.
19:30:41 <ezyang> The subset N that generates the monoid, from traditional algebra 
19:31:32 <alexyk> dons: yep; am not rerunning with timings to correct for disk loading/writing; we'll see who's th eking of the hill shortly with and without the new map
19:31:37 <dolio> Monoid objects are just generalizations of the definition of a monoid.
19:31:52 <ezyang> dolio: Yes, but I'm not understanding how the definition shows that 
19:31:58 <dolio> Which says nothing about elements other than the identity and the multiplication operation.
19:32:00 <ddarius> "subset" doesn't make sense for an arbitrary category.  Further, using the typical monoidal structure on Set, that definition just says you have a set M and a function MxM -> M and 1 -> M that satisfy some laws.
19:32:38 <ezyang> ddarius: Hmm, so the “object” in the monoidal category is a Set, not the actual objects being multiplied. 
19:33:03 <soupdragon> either 13 = 14 or I can't count
19:33:23 <ezyang> *that 
19:33:58 <ddarius> ezyang: For Set-like categories, the objects of the categories are going to be sets, i.e. roughly types.
19:34:08 <soupdragon> > 2*(5+1)+2
19:34:09 <lambdabot>   14
19:34:54 <ezyang> ddarius: Oh, right! 
19:35:11 <ezyang> ddarius: What does an object in a non-categorical monoid correspond to? 
19:35:48 <ezyang> (i.e. those categories with one object?) 
19:36:13 <bremner> what is a good choice for binary serialization?
19:36:26 <ezyang> bremner: Try Binary? 
19:36:42 <ddarius> or cereal or a couple of other choices
19:36:42 <pizza_> 0s and 1s
19:38:23 <ddarius> ezyang: For the equivalence between one object categories and monoids, the one object has no significance.  This is why the categories of monoids and of one object categories are only equivalent and not isomorphic; each monoid induces arbitrarily many one object categories, the only difference being the one-object.
19:38:59 <ezyang> ok! That makes lots of sense. 
19:41:09 * ezyang also just realized Piponi’s “laws” are the commuting diagrams 
19:42:22 <jmcarthur> it would be nice if GADTs also supported newtypes
19:42:37 <ddarius> jmcarthur: ?
19:43:01 <jmcarthur> newtype Foo a where Foo :: b -> Foo c
19:43:07 <ezyang> I bet you can't newtype a GADT 
19:43:24 <ezyang> ah, I guess you could 
19:43:25 <jmcarthur> i can't think of a theoretical problem with it
19:43:27 <alexyk> dons: if I manually replace IntMap with yours, do I just import qualified AdaptMap as A, and then replace M.IntMap by A.IntMap everywhere?
19:44:02 <ddarius> jmcarthur: What's such a big deal about: data Foo a where Foo :: !b -> Foo c ?
19:44:11 <dons> alexyk: yes, that should work, except for in sc.hs where I think I use simpler functions
19:44:23 <jmcarthur> well, that's not the same thing, for one
19:44:45 <alexyk> dons: OK.  I'll manually update as such, since I switched to Double
19:44:56 <dons> alexyk: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26792#a26792
19:45:09 <dons> alexyk: so do you still have IntMap Int ?
19:45:10 <ddarius> jmcarthur: The difference between newtype and (strict) data only comes up in an edge case (and w.r.t. the FFI)
19:45:25 <dons> the above hpaste has the places I had to change
19:45:41 <jmcarthur> i don't personally consider whether the value is evaluated on a pattern match to be merely an edge case
19:45:46 <jmcarthur> i realize this is a minority opinion
19:46:06 <ddarius> Okay, "rarely relied upon case"
19:46:32 <dolio> That sort of thing would require some fancy checking.
19:46:40 <dolio> Actually, I'm not sure it would ever work.
19:46:44 <jmcarthur> why not?
19:46:45 <alexyk> dons: yep, as Reps
19:46:52 <dolio> You can't ~ match against existentials, for instance.
19:47:08 <dolio> And it isn't safe to do so for GADTs in general, either.
19:47:33 <dons> alexyk: fyi, this is a form of template specialization, using the type system
19:47:39 <jmcarthur> surely you could simply disallow existentials for the newtype variant, like ExistentialQuantification does
19:47:43 <alexyk> dons: interesting, will study
19:47:50 <alexyk> ...after seeing it runs faster :)
19:48:10 <dolio> For instance, lazy matching against GADTs that are equality proofs can be unsound.
19:48:16 <jmcarthur> oh hmm
19:48:17 <dolio> If it causes refinement, at least.
19:48:32 <jmcarthur> i do remember reading about that
19:48:32 <dons> yeah, i don't know if the IntMap Int is significantly used. 
19:48:43 <jmcarthur> i guess this would suffer from the same problem
19:48:43 <dons> if it isn't, then it won't make much difference. if it is, then should help
19:48:56 <dons> the work would then be to extend the specialization to other types (trivial)
19:49:40 <alexyk> btw this works for extracting from an if, but is it the right style?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26793#a26793
19:50:17 <alexyk> dons: IntMap Int is in the very leaves, but is used at all times 
19:50:21 <ddarius> alexyk: That's fine.
19:50:41 <alexyk> ddarius: kk
19:54:44 <alexyk> ok, before writing to disk with old IntMap: Haskell: 887 seconds, OCaml: 876 seconds
19:55:03 <alexyk> both grab 45 GB of RAM
19:55:35 <alexyk> (but OCaml uses string Hashtbl, while Haskell is interned into IntMap)
19:55:40 <dons> nice
19:55:48 <alexyk> dons: now we'll add your beast
19:56:00 <dons> hope it helps.
19:56:13 <dolio> But the hash tables must be much faster! :)
19:56:37 <dons> if it is close, then tuning inlining might further improve it. i've not looked at that yet.
19:56:52 <dons> also, -threaded and other GC settings might get you there in the end.
19:56:59 <ezyang> !!! (,) is a bifunctor 
19:57:03 <dons> GC settings seem to have a big effect
19:57:07 <jmcarthur> ezyang: yes?
19:57:28 <ezyang> I wasn't understanding how monoid objects generalized monoids, but I think I see it now 
19:57:58 <adu> hey all
19:58:11 <ddarius> ezyang: Yes the ⊗ is usually (,)
19:58:35 <alexyk> dons: yeah, I have not much clue if mine are the best: -A5G -H2G -K1G
19:58:58 <alexyk> to comapre, OCAMLRUNPARAM='h=5G;s=1G'
19:59:06 <alexyk> does the job too
19:59:48 <alexyk> dons: should I just compile with -threaded?
20:00:45 <dons> it might help if the parallel gc gets to play. -A5G -H2G -K1G seems arbitrary :) not sure if there are better values.
20:01:02 <alexyk> dons: it crashed with -A3G! :)
20:01:20 <alexyk> by going into swap
20:01:25 <dons> interesting.
20:01:30 <ezyang> !!! and in monads, µ and η are natural transformations 
20:01:39 <alexyk> ezyang: where are you reading all this?
20:02:10 <dons> would be nice to try different values of -A methodically to see what makes sense.
20:02:11 <ezyang> alexyk: WP articles and Piponi's blog post <http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html> 
20:02:48 * alexyk when hearing specialized, thinks of a mountain bike
20:03:20 <alexyk> ezyang: thanks, interesting bedtime reading
20:03:53 <technogeeky> when I hear specialized, I think LHC
20:03:57 <alexyk> dons: I sort of did -- increased 1, 3, 5; 10 tended to thrash too soon
20:03:57 <technogeeky> http://meltronx.com/lhc1.html
20:04:13 <technogeeky> speaking of which, it's about to double the intensity record - which it set last week
20:04:15 <dons> alexyk: you can also try the compacting garbage collector (+RTS -c )
20:04:23 <dons> its a bit less used though, so might be more problematic.
20:04:28 <dons> but uses half as much space.
20:04:58 <alexyk> dons: interesting when fighting against clojure with compressed oops, fitting into 32 GB JVM
20:05:30 <alexyk> now Haskell, like Germany, will fight with OCaml on speed in the West, and with Clojure on space and speed in the East
20:06:14 <technogeeky> Who do we always have to use WWII analogies for everything.
20:06:14 <alexyk> technogeeky: cute graph
20:06:22 <technogeeky> alexky: it's live
20:06:26 <alexyk> technogeeky: it's a WWI analogy :)
20:06:30 <technogeeky> http://meltronx.com
20:06:39 <dons> bigger -A values seem to help
20:06:44 <alexyk> technogeeky: it's what Bismarck asked Germany not to do :)
20:06:58 <ddarius> @google Barr Wells ESSLLI
20:07:03 <lambdabot> http://www.let.uu.nl/esslli/Courses/barr-wells.html
20:07:03 <lambdabot> Title: Courses: Barr / Wells
20:07:05 <ddarius> Read that ezyang.
20:07:17 <technogeeky> alexyk: I suppose this works too.
20:07:17 <ezyang> Ok. 
20:07:20 <ezyang> What is it? 
20:07:23 <dons> alexyk: so i guess you want the biggest -A value that won't cause thrashing
20:07:24 <ezyang> ohh 
20:08:02 <alexyk> dons: yep, which was about 5G
20:08:16 * alexyk submerges to wire in dons' map
20:09:20 <dons> oh, that uses a lazy spine too. i'll try it with a strict one.
20:09:33 <ddarius> ezyang: Some googling will turn up an equivalent PDF if you prefer PDF to postscript.
20:09:44 <ezyang> ps2pdf ftw 
20:10:02 <technogeeky> one day, all of my best efforts and great strides in learning haskell will enable me to understand 1/3 of what dons says - and I will rejoice.
20:10:43 <ddarius> That's because he's from Australia.
20:11:12 <technogeeky> ddarius: do all of the posionous human-murdering monsters there drive them to do great things?
20:11:37 <dons> alexyk: there is some parallel GC to be had (-threaded, then run with -N2 or more depending on your cores)
20:12:42 <dons> Parallel GC work balance: 1.24
20:12:44 <dons> not too bad.
20:14:24 <ezyang> One last question: when we talk about Set, objects are sets which contain elements. If we talk about the category of endofunctors, the objects are endofunctors: do they “contain” anything? 
20:14:44 <Llyr> Hello #haskell-ites. Is it possible to measure the runtime of a function inside ghci?
20:15:06 <Cale> Llyr: :set +s
20:15:47 <Llyr> Oh perfect. Thanks!
20:15:55 <Cale> Llyr: For that matter, also check out :help
20:16:01 <technogeeky> Llyr: that was easy, huh?
20:16:07 <Pseudonym> I'm from Australia, and I only understand 1/3 of what dons says.
20:16:07 <Cale> It gives a quick listing of useful commands :)
20:16:22 <Pseudonym> Mind you, he also only understands 1/3 of what I say, so it probably evens out.
20:16:34 <dons>  oi.
20:16:35 <technogeeky> Pseudonym: I don't think it works that way.
20:16:43 <Cale> ezyang: Is that a rhetorical question?
20:16:53 * Pseudonym draws a Venn diagram
20:16:59 <Llyr> Cale: I was thinking about it the wrong way - thought I'd have to wrap a function around my other function. I didn't really think that ghci would have nice environmental stuff like that.
20:17:26 <ezyang> Cale: Well, obviously the set notion of containership doesn't work. But I'm wondering if there’s something analogous 
20:17:51 <dolio> ezyang: As far as category theory cares, sets don't contain anything. Only functions between sets matter.
20:18:21 <ezyang> mm, ok. 
20:18:35 <Cale> In general, if you have a terminal object 1, then you can define a sort of "elements of A" as being arrows 1 -> A
20:18:52 <dolio> You can even do set theory that way, taking functions between sets as primitive and defining elements to be functions from a certain set.
20:18:58 <Cale> But that often doesn't turn out to have the properties that make elements a nice thing to discuss with respect to sets
20:19:16 * alexyk finally got dons' prefix-comma thing: it aligns vertically between { and }
20:19:41 <Cale> More generally, you can take a "generalised element of A" to be an arrow T -> A, and think of things like that
20:19:49 <ezyang> Cale: I think that's useful 
20:20:08 <Guest35035> cale, do you know of any, i suppose, pattern matched collection transformers?
20:20:27 <Cale> If you have an arrow A -> B, and a generalised element T -> A, then you can get a generalised element T -> B by composition (which you can think of as function application if you like)
20:20:33 <Pseudonym> technogeeky: Just so you know, the Australian sense of humour is as dry as a pommy's towel.  Don't take it seriously.
20:20:49 <ezyang> to explain what I'm really trying to do 
20:20:52 * alexyk has so much fun aligning commas now, and the comma-less right edges are so nakedly beautiful
20:21:55 <ezyang> suppose I'm in the State monad, and I have a value State (). This monadic value, when run, causes a change in state which might be different from another State (). So it seems to me that the functors are “different” in some way, and that there are many of them in that case. 
20:21:55 * ddarius never liked the align commas and braces style.
20:22:03 <augur> ddarius! :D
20:22:04 <alexyk> ddarius: too late
20:22:05 <augur> <3
20:22:21 <alexyk> mashed comma obscures field of vision
20:22:35 <technogeeky> Pseudonym: I appreciate the pointer. American humor is exported all over the world, so I assume you know it well enough. And I have recently renounced taking things seriously right around the time Sara Palin ran for Vice President of the United States of America.
20:22:52 <alexyk> ddarius: you must be a dissident! :)
20:23:04 <ezyang> erm, s/State/State Int/ 
20:23:07 <alexyk> ddarius: like teh SOlzhenitsyn of Haskell
20:23:43 <ddarius> alexyk: I don't know who SOlzhenitsyn is, so I'll take your word for it.
20:24:00 <technogeeky> Though I suppose one could say Sarah Palin running for VP *is* American humor. That thought makes me sad.
20:24:10 <Llyr> Well, this timing thing has uncovered something interesting.  I wrote a function that gives you a list of divisors of a given number, as well as one that gives you just the proper divisors. Thus, by doing head (filter (\x -> null (properDivisors x)) (properDivisors n)), you can get the biggest prime divisor.
20:24:21 <Cale> ezyang: The functor in question here is State Int itself
20:24:29 <Cale> ezyang: along with the corresponding fmap
20:24:30 <alexyk> ddarius: that Gulag Archipelago guy: http://en.wikipedia.org/wiki/Aleksandr_Solzhenitsyn
20:24:45 <ezyang> Cale: Yeah. So I don't know where the “different state changes” thing fits in 
20:24:46 <Cale> ezyang: That is, it sends the type T to the type State Int T
20:24:51 <Llyr> I was expecting head (filter ... (properDivisors n)) to take much shorter than head (filter ... (divisors n)), but they run in almost exactly the same time.
20:25:05 <alexyk> btw, did Knuth made an earth-shattering announcement today?
20:25:13 <Llyr> Is Haskell being creatively lazy with its evaluation of null?
20:25:14 <Cale> ezyang: and it sends a function f :: A -> B to the function  fmap f :: State Int A -> State Int B
20:25:29 <alexyk> slashdot said he will at a TeX mtg
20:25:46 <Cale> Llyr: You wrote the same thing twice, but yes, Haskell does lazy evaluation, which is outermost-first
20:26:07 <Cale> Llyr: and it'll mean that the filter will only ever run until it produces one element of the list
20:26:15 <Cale> Llyr: and then the head will get at it
20:26:21 <pikhq> alexyk: Yes, it was a joke.
20:26:24 <ezyang> I know fmap can’t be donig anything interesting, since it’s giving A -> B a pure context. 
20:26:28 <Cale> oh, properDivisors vs. divisors?
20:26:31 <Llyr> Cale: Right.
20:26:32 <alexyk> pikhq: sad
20:26:33 <pikhq> Unless you want stereophonic sound in your iTeX.
20:26:51 <Llyr> Cale: That makes perfect sense, though - if I was writing a lazy null, I'd stop as soon as I got the very first thing.
20:26:57 <Cale> Llyr: Well, you're only taking the first one, so as long as divisors doesn't include 1, you'll be fine
20:27:04 <alexyk> pikhq: I wouldn't mind a stereoscopic TeX
20:27:30 <jesusabdullah> I want to hear the THX Deep Noise every time I use tex.
20:27:45 <Llyr> Cale: Okay, thanks. You are the winner.
20:28:03 * ezyang always feels like he is asking the wrong questions when he tries to learn math 
20:28:07 <alexyk> dons: addMaps are the heavy lifters, A should be yummy
20:28:15 <pikhq> jesusabdullah: That sounds like a good feature.
20:29:19 <alexyk> dons: you mentioned adding a cabal file? missing in tgz
20:29:28 <Cale> ezyang: Note that the part of the functor which sends T to State Int T is *not* a function on values
20:29:38 <Cale> ezyang: It's a function on *types*
20:29:56 <ezyang> Cale: *nod* 
20:30:07 * ManateeLazyCat pasted "SerializedEvent.hsc" at http://paste2.org/get/900551
20:30:08 <ManateeLazyCat> I have pick-up field from C struct to Haskell data-type, how to convert Haskell data-type back to C struct ForeginPtr? I have some code like above.
20:30:08 <Cale> That is, don't confuse it with  return :: T -> State Int T
20:30:12 <dons> SpecConstr Function `a_s16oz{v} [lid]' has 7 call patterns, but the limit is 3
20:30:16 * dons makes ghc cry a little
20:30:24 <jesusabdullah> oh, and the vuvuzela sound every time you say "fuck it, openoffice it is!"
20:30:38 <ezyang> Cale: That would be η, i.e. unit 
20:30:42 <Cale> yeah
20:30:49 <Cale> ezyang: Does that help at all?
20:31:36 <alexyk> dons: should I re-save my giant IntMap-ped binaries, or is AdaptMap binary-compatible?
20:31:37 <ezyang> Cale: Maybe. I guess the point being made here is that, in terms of category theory, we don't really care about the side-effects that State Int (). 
20:31:47 <ezyang> s/./may have/ 
20:32:08 <ManateeLazyCat> At http://paste2.org/get/900551 , i use serializedEvent convert C struct (_GdkEventKey) to SerializedEventKey at *server* side, after pass SerializedEventKey over network, i want deserialized SerializedEventKey at *client* side to re-bulid C struct.
20:32:13 <ezyang> much like we don't actually care about the elements of the sets in Set 
20:32:15 <Cale> Well, it'll have a bunch of elements with various structure that we're not looking at very carefully here.
20:32:16 <dons> alexyk: i modified the parser
20:32:25 <dons> so the binary decoder should still work ( i think)
20:32:48 <alexyk> dons: yeah, that SpecConstr I see in the ghc head, is it reportable?  it still works, and shows with -O2
20:32:50 <ezyang> Cale: Oh, so the natural transformations will connect them up in an interesting way. 
20:32:53 <ezyang> OHHH!!! 
20:33:02 <Cale> hmm
20:33:14 <ezyang> well, I think that made sense. 
20:33:17 <Cale> :)
20:33:24 <Cale> Well, it's possibly true...
20:33:36 <Cale> The monad structure is more interesting here.
20:33:46 <Cale> Than just the plain functor structure.
20:33:52 <ManateeLazyCat> ezyang: Can you help me look http://paste2.org/get/900551 ? Thanks!
20:33:55 <Cale> fmap sort of "ignores" the state
20:33:57 <dons> turning up inlining seems to help, too, alexyk 
20:34:14 <alexyk> dons: how?
20:34:16 <Cale> Of course, it doesn't ignore it completely, it passes it on through
20:34:19 <ezyang> Cale: iiuc, the monoid lets us compose things 
20:34:43 <dons> alexyk: still working on the right set of flags. will let you know.
20:34:47 <ezyang> so the plain functor structure isn't interesting because it doesn't let me fiddle with the state changes, but it's still there, no? 
20:34:49 <Cale> fmap f x = State (\s -> let (s',v) = runState x s in (s',f v))
20:34:52 <alexyk> dons: okok
20:34:52 <ezyang> ManateeLazyCat: Looking 
20:35:51 <ManateeLazyCat> ezyang: I want re-build GdkEventKey Pointer after *client* side i receive SerializedEventKey from the network.
20:37:19 <ezyang> ManateeLazyCat: It looks like you should build a Storable instance for SerializedEvent 
20:37:31 <ezyang> And then rebuilding a GdkEventKey struct corresponds to poking it 
20:37:33 * alexyk makes branch "donsmap" compile
20:37:41 <dons> yay. 
20:37:53 <ezyang> Cale: Yup, passing it on. 
20:38:05 <ManateeLazyCat> ezyang: But problem is, i don't need field "GdkWindow *window" and "guint32 time" at *server* side.
20:38:12 <mmagee> Does anyone know how to define a catamorphism over a(n algebraic) data type, but only referring to the functor of which the data type is the least fixed point, and not the data type itself? Or know where I might find such code?
20:38:31 <ManateeLazyCat> ezyang: If i peek "GdkWindow *window" at *server* side, i can't pass the value over the network.
20:38:46 <ezyang> ManateeLazyCat: You could just pass bogus values there? 
20:38:54 <ezyang> I'm not 100% on the semantics you want. 
20:39:22 <ezyang> mmaggee: Mu? 
20:39:24 <ddarius> @where evolution
20:39:24 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
20:39:28 <ddarius> mmagee: See that
20:40:00 <ManateeLazyCat> ezyang: Hmmm, bogus values .... I need think this idea....
20:40:13 <Cale> mmagee: It can be done if you define a fixed point type.
20:40:17 <ezyang> Like, regardless, something is going to have to live in that memory location. 
20:40:32 <ezyang> NULL might be a good value for the pointer. 
20:40:48 <Cale> mmagee: newtype Fix f = In { out :: f (Fix f) }
20:41:18 <Cale> mmagee: and then  cata :: (Functor f) => (f a -> a) -> Fix f -> a
20:41:41 <Cale> cata f = f . fmap (cata f) . out
20:42:27 <jmcarthur> @pl cata f = f . fmap (cata f) . out
20:42:27 <lambdabot> cata = fix (ap (.) . flip flip out . (((.) . fmap) .))
20:42:30 <jmcarthur> ew
20:42:32 <Cale> The (f a -> a) bit is called an f-algebra
20:42:43 <mmagee> thanks all, exactly what I wanted!
20:43:17 <alexyk> dons: am doing a run of the donsmap with just -funbox and -O2
20:43:33 <alexyk> btw the test is on @justinbieber
20:43:52 <alexyk> (his numbers gotta match)
20:44:17 * alexyk marvels how the best minds of FP are working on carefully computin JustinBieber's influence
20:44:38 <dons> heh
20:44:49 <alexyk> dons: not much speedup reading binary
20:44:57 <alexyk> 55 sec vs 57
20:45:10 <ManateeLazyCat> ezyang: I can fill 'Nothing' in data-type when i *peek* pointer field, after pass to network, i can use (Just Foo) *poke* the value that C struct want, right?
20:45:12 <dons> wouldn't expect too much there, just parsing.
20:45:26 <ezyang> Yup! 
20:45:43 <ezyang> And you should be sure to check if it's NULL, since peek won’t do it for you. 
20:46:57 <ManateeLazyCat> ezyang: Thanks for your help, i think your idea will fix my problem. :)
20:47:19 <Cale> ezyang: So, did you get cleared up about what you were confused about?
20:47:47 <ezyang> Cale: I'm drawing a diagram, and I'd love a san-check when I'm done. 
20:47:51 <ezyang> I think the confusion is gone. 
20:48:57 <Cale> It's typically the case in Haskell that functors are structures built on values in such a way that the structural part can be ignored, and a function applied to all the values, and this is sort of the point. :)
20:51:00 <tolkad> Is it true that programming languages which do not allow you to create infinite loops cannot compute all turing computable functions?
20:51:11 <ddarius> tolkad: Yes. 
20:51:27 <sshc> tolkad: Yes.
20:51:33 <AnAdorableNick> tolkad: Yes.
20:51:33 <ddarius> tolkad: The output of a Haskell interpreter is a Turing computable function.
20:51:52 <technogeeky> tolkad: Yes. No. Yes. No. Yes. No. Maybe. .......
20:52:16 <ddarius> Perhaps a better answer would be, Y not?
20:52:32 <Gracenotes> my programming language only lets you write decidable programs
20:52:34 <pikhq> tolkad: The ability to do an infinite loop is essential to being TC.
20:52:58 <pizza_> is it true that computers without infinite storage cannot compute all turing computable functions?
20:52:58 <dolio> And the answer is: Goedel's incompleteness theorem. :)
20:53:09 <Gracenotes> I think I'll be calling it O'Oracle
20:53:11 <ezyang> Cale: That'd be because there isn't really another way to do it, eh? 
20:53:16 <Cale> pizza_: That's also true.
20:53:30 <Cale> pizza_: Technically all we have is great big finite state machines
20:53:59 <ezyang> http://web.mit.edu/~ezyang/Public/maybe-monad.png 
20:54:04 <monochrom> I just wait for moore's law
20:54:34 <ezyang> Thinking about it some more, I think there’s something kind of wrong with that diagram, but I'm not sure what. 
20:54:38 <monochrom> oh god
20:54:45 <Cale> ezyang: Well, the type system helps, but if you look at the functor laws, fmap id = id sort of means that whatever fmap is doing, it can't really be affecting the "structure" built around the values.
20:54:52 <technogeeky> monochrom: those apply first and foremost to transistors. Memristors exist now, too.
20:54:59 <technogeeky> s/those/that//
20:55:00 <tolkad> but, only programs which halt can compute a function
20:55:02 <ddarius> ezyang: Just and Nothing aren't functors.
20:55:11 <ezyang> ddarius: Yeah, that’s problematic :^) 
20:55:15 <tolkad> well, a function for a specific input
20:55:52 <ddarius> monochrom: If Moore's law holds for the rest of eternity, we're golden.
20:56:07 <tolkad> so, if I just define my language as all valid programs in another language which halt for all inputs, then what?
20:56:12 <ezyang> ddarius: I guess Just and Nothing only show up in the natural transformation. 
20:56:27 <dolio> Maybe is the functor.
20:56:34 <Cale> tolkad: Then it might be undecidable whether some programs are in your language or not.
20:56:50 <monochrom> that is a good plan. please put it on hackage!
20:57:01 <dolio> Id => Maybe, Maybe (x) Maybe => Maybe
20:57:23 <Cale> and (x) = .
20:57:43 <tolkad> Cale: yes, but still, it contradicts my previous statement
20:57:52 <ezyang> (in a complaining voice) but that doesn't say anything about how the monad works internally 
20:58:05 <ezyang> looks like the notation is all wrong. 
20:58:21 <technogeeky> tolkad: that's the point of the Incompleteness Thoerem
20:58:25 <ddarius> ezyang: The monad laws by themselves don't say much.
20:58:32 <monochrom> (commuting diagrams seldom say how things work internally)
20:58:35 <ezyang> *nod* 
20:59:05 <Cale> ezyang: In fact, it had better not have anything to do with how the monad works internally, because it's supposed to work for all monads :)
20:59:16 <ezyang> That's true :-) 
20:59:36 <alexyk> dons: is there any locality in GC so parts of a huge Haskell program can be swapped out?
20:59:40 <Cale> ezyang: Have you seen the string diagram notation?
20:59:45 <alexyk> looks like it works for me
20:59:47 <ezyang> looking up 
21:00:03 <ddarius> ezyang: You can characterize η and µ for the Maybe monad (using initial algebras for example, or just axiomatically, or by defining them in a particular category) and then show that they satisfy the monad laws.
21:00:16 <dons> alexyk: can't really control that.
21:00:32 <Cale> ezyang: You might get a bunch of unrelated stuff... you might either read my articles on Analogical Engine, or watch the lectures by The Catsters on YouTube :)
21:00:53 <Cale> http://analogical-engine.com/wordpress/ -- I'll get you a better link in a moment
21:00:54 <alexyk> dons: right, but would be interesting to have swap-friendly allocations
21:01:05 <dons> you guys with your giant programs
21:01:05 <ezyang> found it 
21:01:10 <dons> alexyk: buy more rams
21:01:12 <dons> :)
21:01:23 <Cale> http://cale.yi.org/share/monadlaws.jpg
21:01:31 <Cale> ^^ here's a crude drawing :)
21:01:44 <alexyk> dons: exponentially more expensive beyond 64 GB
21:01:47 <Cale> (with more things labelled than one usually would)
21:01:54 <ezyang> Oh, that is pretty! 
21:02:01 <monochrom> dons: they really think they have turing machines, unlimited download, unlimited airtime... :)
21:02:02 <ezyang> (Remove the Ts?) 
21:02:08 <Cale> yeah
21:02:16 <ezyang> Makes uber-sense. Almost reminds me of logic gates 
21:02:18 <Cale> In fact, you can remove the bubbles with eta and mu as well
21:02:19 <Pseudonym> Unlimited tape.
21:02:37 <Cale> because it's unambiguous when you have a dangling end that it's eta, and when you have a join, it's mu :)
21:02:45 <ezyang> ha, that's true. 
21:02:50 <alexyk> dons: with all the UNPACK and more strict fields and AdaptMap, actually... slower by 50 secs :(
21:03:01 <Cale> But then it's not much to look at :)
21:03:20 <dons> alexyk: wow. -O2 -funbox-strict-fields ?
21:03:25 * alexyk should recheck options
21:03:32 <Cale> http://cale.yi.org/share/arisemonad.jpg -- how a monad arises from an adjunction
21:03:36 <ddarius> Humans are super-Turing because they have small blackholes in their heads that hold the infinite tape and also slow time down to allow for an accelerated Turing machine.
21:03:47 <alexyk> dons: will recheck after it finishes its looong write
21:03:57 <dons> alexyk: the only thing i can think of is that i accidentally sent you one with a lazy spine. you could edit line 186
21:04:13 <dons> | BinInt {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !!1(IntMap Int) !(IntMap Int)
21:04:14 <Pseudonym> Cale, I read that as "arsemonad" first.
21:04:18 <Pseudonym> It confused me/
21:04:24 <alexyk> dons: also I'm not sure getCPUtime is unaffected by the giant java run a colleague started, which lead to some swapping
21:04:27 <Cale> http://cale.yi.org/share/monadassociativity.jpg -- checking the monad associativity law for the monad arising from an adjunction :)
21:04:35 <dons> alexyk: disappointing. its a bit faster here (and definitely should use less space)
21:04:36 <ddarius> Cale: There you go.
21:04:44 <ezyang> Cale: I don't understand adjunctions yet, so those'll have to wait :-) 
21:04:56 <alexyk> dons: space, yes, 41 GB < 45 GB
21:05:04 <dons> interesting.
21:05:08 <monochrom> these look like semiconductor design textbook diagrams
21:05:12 <dons> how much variance is there between runs?
21:05:29 <alexyk> dons: I'll run again after it's over
21:05:42 <alexyk> dons: wanna try some inlining flags?
21:05:48 <ddarius> String diagrams are nice because they make many manipulations mere topological properties.
21:06:15 <alexyk> btw, any of you guys saw ext3 being sooo slow unpon writing large files?
21:06:30 <Pseudonym> How large is large, and how full is your disk?
21:06:31 <Cale> Yeah, things which are true by naturality become "obvious"
21:06:35 <alexyk> I see kjournald spring into action upon large writes 
21:06:58 <Cale> Where normally you'd have to apply naturality squares, and it's not quite so intuitive.
21:06:59 <alexyk> Pseudonym: meager 400 MB files compressed, and the disk is fairly full-ish
21:06:59 <ddarius> monochrom: Baez and Stay's Rosetta stone article is about using string diagrams and monoidal categories to see the commonality between quite disparate branches of math and science.
21:07:04 <dons> alexyk: you could try putting INLINE on everything in AdaptMap then turning up the simplifier iterations (-fmax-simplifier-iterations=10)
21:07:13 <alexyk> say 50 GB free out of a  1 TB
21:07:31 <dons> also, might be fun to try the compacting collector, to see if reducing space has any good effect.
21:07:35 <dons> +RTS -c
21:07:55 <alexyk> dons: that's in addition to all the -A etc flags right
21:07:56 <Cale> monochrom: I wouldn't doubt that there's something to be said about semiconductor design if you follow this higher-dimensional category theory stuff along a bit further. :)
21:08:44 <dons> alexyk: yeah, -c at runtime
21:08:53 <alexyk> dons: INLINE on everything, you mean each function?
21:09:00 <dons> yeah, like so ...
21:09:30 <dons> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26794#a26794
21:10:04 <ezyang> When I have a functor like Maybe, where do the constructors Just and Nothing “live”? 
21:10:04 <dons> this is an interesting problem.
21:10:23 <dons> it puts enough stress on the GC that i can't really tell what things make stuff better. could just be GC effects. very interesting
21:10:45 <ddarius> ezyang: I mentioned three ways of defining them.
21:11:10 <ddarius> ezyang: For the most part, all category theory cares about is how the interact with each other.
21:11:29 <alexyk> dons: ok, the m-effer optimization next :)
21:11:39 <ezyang> ddarius: Sorry. (checks scrollback) 
21:12:20 <Pseudonym> BRB
21:13:08 <ezyang> the axiomatically or initial algebras or category msg? 
21:14:29 <ddarius> Yes.
21:14:59 <ezyang> Blah. I don't think I'm familiar with any of those methods :o) 
21:16:29 <ddarius> ezyang: You are familiar with the last one.  Choosing Set (or Hask) it is just working with the definitions in those categories.
21:16:39 <ezyang> Oh! Ok :-) 
21:17:04 <dolio> Maybe A = 1 + A, so there is a category C in which there is nothing : 1 -> Maybe A and just : A -> Maybe A.
21:17:08 <dolio> The two injections into the sum.
21:17:14 <ezyang> In which case Maybe a is an object. 
21:17:30 <dolio> And Maybe is a functor over C.
21:18:01 <alexyk> dons: inlined started
21:18:03 <ezyang> dolio: IS that the algebra approach? 
21:18:36 <dolio> That has nothing to do with initial algebras, no.
21:18:44 <dons> alexyk: will be interested to know what data structure your ultimately recommend. so i can implement it.
21:19:15 <ezyang> :? 
21:19:24 <ddarius> dolio: It doesn't have -nothing- to do with it, but it isn't (all of) it certainly.
21:19:32 <ddarius> Maybe is a kind of trivial case.
21:19:50 <alexyk> dons: currently, the data structure is primitive.  It's clearly wasteful, taking at least twice teh memory really needed; but is easy to verify and a good GC test! :)
21:20:16 <alexyk> dons: I decided I'll make all 3 language versions correct and post the shootout before really optimizing it further
21:20:29 <dolio> Well, talking about initial algebras would just add more indirection.
21:20:55 <alexyk> dons: I mean the algorithmic design.  But given teh algorithm is settled, a particular lang's Map is key.
21:21:08 <alexyk> It started with Clojure where map is a language feature
21:21:12 <alexyk> and is surprisingly fast
21:21:31 * alexyk celebrates the Java expiry
21:21:44 <ddarius> (It's always a good idea to make built-in features efficient...)
21:23:01 <Pseudonym> Built-in misfeatures are another matter.
21:23:45 <pizza_> the trick is to make them even more efficient so everyone relies on them
21:24:01 <Cale> One thing I am mildly jealous of in clojure is the way that maps and sets can be used as functions directly
21:24:28 <ddarius> pizza_: The trick is to significantly slow down the rest of the language to slightly speed up the misfeature so everyone relies on the misfeature.
21:24:37 * ddarius eyes Tcl.
21:24:57 <pizza_> it's all relative
21:25:08 <alexyk> Cale: did you use clojure much?
21:25:23 <ddarius> Cale has 20+ years of Clojure experience.
21:25:25 <Cale> alexyk: Not really.
21:25:28 <Cale> haha
21:26:14 <dons> built-in things are weird. means the compiler isn't good enough :)
21:26:15 <dons> ah well.
21:26:19 <alexyk> Cale: it feels unsafe to use a dynamic language after MLs/Haskell; Null Pointer Exception i disgusting
21:26:20 <alexyk> is
21:26:30 <alexyk> but fun and easy
21:26:32 <ddarius> alexyk: You could use Java instead...
21:26:43 <dons> yes, looking forward to the shootout. should be a useful benchmark for lots of things
21:26:45 <alexyk> ddarius: not really
21:26:57 <Cale> alexyk: Yeah, there are a lot of things which I am not envious about.
21:27:15 <dons> and no one's really disgraced, afaik. though how's clojure going? (and python... ? :)
21:27:47 <alexyk> ddarius: I hated Java with a passion until Scala appeared; then I surveyed what the effers produced for over 10 years and my intuition was confirmed.  Maven, etc.; but IDEs are nice.  The Java underworld is fascinating, like the environs of Mount Doom.
21:27:48 <ddarius> Wouldn't the python solution be to write the code in C?
21:28:27 <ddarius> alexyk: Visual Studio is better than a lot of Java IDEs out there and C# is hands-down better than Java.
21:28:44 <alexyk> dons: clojure is really behind, more than by 3x; yet it fits into its 32 GB JVM snugly, with compressed oops
21:29:02 <alexyk> ddarius: MSFT is a non-started for a Mac/Linux guy
21:29:22 <alexyk> non-starter; I tried to start F# witha  dual-booted Vista on my Mac, then formatted it over.
21:29:25 <ddarius> As annoying as the language is, the worst thing about Java is the library design the community seems to go for.
21:29:43 <dons> alexyk: their use of the jvm pays off. 
21:30:11 <alexyk> dons: yeah, the wealth of libraries is great.  I think Scala folks are the smartest, penetrating the corporate.
21:30:24 <alexyk> and pretending to bring effectiveness to PHBs
21:30:25 <dons> though we get to customize our rts for the language (tag pointers etc) they have to rely on whatever java needs. so a bit of a double-edge sword
21:30:41 <Cale> ddarius: Java doesn't even have proper first class procedures, how can you hope for them to design appropriate libraries? :)
21:31:17 <ddarius> Cale: They can do a lot better than they do.  C and C++ do a better job oftentimes.  C# does a better job (though still annoying.)
21:31:25 <ddarius> C# does have first class procedures though.
21:31:54 <Cale> Okay, I suppose I can agree with that, to an extent.
21:32:04 <alexyk> dons: inlined doesn't fare much better
21:32:15 <Cale> There are a lot of really terrible APIs in C, though.
21:32:38 <dons> alexyk: ok. very interesting. specializing should always be better. will have to study.
21:32:45 <wli> If I were going to go about fixing C it wouldn't be anything like C++ or C#. Not sure what I'd do about C++ though, which C# is attempting to fix/NIH/etc.
21:32:52 <ddarius> Cale: A lot of times they have some justification (usually performance or the fact that they were designed in the '70s), but I agree.  I'm more a C++ than a C person.
21:32:58 <alexyk> dons: I have to run plain intmap again to verify
21:33:00 <Cale> But at least in C, there's a limitation to how complicated you can make the types. In C++, you can write horrors and even make the types complicated while you're at it. :)
21:33:07 <alexyk> it's getting late on the East Coast :)
21:33:12 <pikhq> C punishes bad APIs a bit more thoroughly than other languages, though. At the very least the C APIs tend not to get very popular.
21:33:18 <dons> yeah, bed time.
21:33:26 <pikhq> (sadly, this is just a tendency, not a universal truth)
21:33:29 <ddarius> wli: C# is Microsoft Java, it isn't Microsoft C++.  (There actually is a "Microsoft C++" namely Managed C++.)
21:33:58 <alexyk> dons: why is inlined eating 48 GB?
21:34:03 <ddarius> Cale: You can do that in Haskell.
21:34:05 <wli> Point, should've been fix/NIH/etc. Java.
21:34:06 <pikhq> (okay, C++ punishes bad API design more than C, but nobody seems to care. :()
21:34:13 <alexyk> vs 41 GB non-inliined?
21:34:44 <alexyk> bizarristan
21:34:47 <Cale> ddarius: True, though it seems like people somehow end up with horrible messes in C++ from honest attempts to create good abstractions.
21:35:05 <ddarius> Cale: Again, the same happens in Haskell.
21:35:13 <alexyk> the shortest programming joke: "C++ abstractions"
21:35:17 <Cale> I'm not sure :)
21:35:17 <ddarius> Haskell just has less details to abstract over in many cases.
21:35:40 <alexyk> buy two C++ abstractions, get 1 free
21:35:53 <Cale> Well, okay, there are things which are not as nice as we'd like.
21:36:43 <RayNbow> brr.... C#... I once tried to write a generic class and tried to constraint the type parameter to support add/sub/mul...
21:36:49 <dons> alexyk: depends on what optimizations got enabled or not.
21:37:09 <Cale> I suppose there are just a whole bunch of more specific things which make it more common in C++
21:37:17 <alexyk> dons: yeah, +7 GB for INLINE is kinda steep
21:37:18 <RayNbow> (which is hard, since C# operators are static methods)
21:38:03 * RayNbow ended up manually plumbing method dictionaries around in C#
21:38:04 <ddarius> RayNbow: Parametric polymorphism is done soo much better in C# than Java, in part because the library has much better uptake of them.
21:38:06 <Cale> The main one, I think, is that the template system in C++ is not a really very good way to do parametric polymorphism, which is what most libraries actually need it for.
21:38:14 <alexyk> RayNbow: but it has "delegates"!  "Delegating" is very OO and enterprisey!
21:38:42 <dons> alexyk: its hit or miss. we might enable a killer optimization, we might prevent one
21:38:50 <dons> and your program is sensitive enough to show tiny changes
21:39:07 <ddarius> Cale: Everyone agrees about that, but the templating system as it is has demonstrated significant value so it isn't going to be cut back into just parametric polymorphism.
21:39:14 <alexyk> dons: yes, it's a very sensitive monster program :)
21:39:29 <alexyk> monsters can be sensitive too
21:39:50 <RayNbow> ddarius: still, there's room for improvement :)
21:40:20 <dons> ddarius: i like haskell's post-hoc templating system: associated dataaaa types
21:40:26 <alexyk> dons: please check that I got AdaptMap correctly, it's in the "donsmap" branch
21:41:22 <alexyk> for now I'll try dafis' IntMap again
21:42:07 <ddarius> RayNbow: I agree.  Better local type inference, TCO, better library design.  Also, things that aren't going to happen, immutable types by default.
21:43:26 <ddarius> dons: We could do similar things pre-associated data types, though without the very nice representation optimizations.
21:43:57 <ddarius> (Technically we could have probably done those too, but it would have been ugly as sin and probably not optimized well by GHC.)
21:44:17 <RayNbow> ddarius: heh, at one point I expected local type inference to work like in Haskell... and it bit me :p
21:44:57 <ddarius> RayNbow: I suspect that C# will get roughly Scala's amount of type inference (but nowhere near Scala's type language complexity) in the not distant future.
21:45:18 <RayNbow> var x = 0; /* snip */; /* some float operations on x here... causing a type error :p *;
21:45:35 <RayNbow> ^ I expected x to be inferred to be float or double
21:45:43 <RayNbow> but it was inferred to be int because of the literal 0
21:46:02 <ddarius> :t 0
21:46:03 <lambdabot> forall t. (Num t) => t
21:46:03 <ddarius> :t 0.0
21:46:04 <lambdabot> forall t. (Fractional t) => t
21:46:24 <dons> ddarius: yeah, FDs get us there as well.
21:46:27 <dons> just a little more roundabout
21:47:34 <alexyk> dons: why is dcaps with adaptmap takes twice as much space on disk than before?
21:48:04 <ddarius> We need to figure some unification of FDs and TFs.  Currently they have massive overlap but there are definite cases where the other is nicer, and, as I understand it, cases that one can handle that the other can't.
21:48:18 <alexyk> now I see why write is so slow
21:48:25 <alexyk> given we compress too
21:49:39 <ezyang> Do I need the full generality of CT monoids to talk about monads as monoids? I feel like I should be able to talk about the set of endofunctors. 
21:49:53 <alexyk> dons: something is very strange; for 100K, the dcaps size coincides for intmap and adaptmap, for the full data, it's twice larger.
21:51:28 <dons> oh. maybe i wrote the instance wrong.
21:52:09 <dons> oh, did we switch from Int32 to Int ?
21:52:32 <alexyk> dons: I always used just Int...
21:52:35 <dons> hmm. no.
21:52:46 <ddarius> ezyang: You need monoid objects in a monoidal category.  The monoid object is the functor itself, not the set of endofunctors.
21:52:51 <dons> i can't see why it would be bigger. the Binary instance looks correct.
21:52:58 <dons> (bottom of sc.hs)
21:53:05 <ezyang> ddarius: Ok. (chews on that statement) 
21:53:56 <alexyk> dons: well it's bigger!  twice as large...  I'll study it tmrw
21:54:09 <ddarius> ezyang: The relevant monoidal (tensor) product [not the monoid multiplication] is composition of functors, not cartesian product as for traditional monodis.
21:54:47 <ezyang> ddarius: Cartesian product seems to imply I can extract the original elements, which doesn't seem to be the case for monoids with inverses. 
21:55:36 <alexyk> dons: I hope it computes correctly, although it's in the bottom and shouldn't create new keys in dcaps
21:55:46 <ezyang> (this was actually the observation that made me think twice about the traditional monoids = cartesian products) 
21:56:16 <dobblego> @pl \p t -> if p then t else return mzero
21:56:16 <lambdabot> flip flip (return mzero) . if'
21:56:19 <dobblego> @type \p t -> if p then t else return mzero
21:56:20 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (MonadPlus m, Monad m1) => Bool -> m1 (m a) -> m1 (m a)
21:57:20 <ddarius> ezyang: The cartesian product in traditional monoids is the x in * : MxM -> M.  Monoids aren't cartesian products, but their definition uses them.  For monads the instead of x we have (.), µ : T . T -> T.  It can't be thought of as a traditional monoid at all.
21:57:46 <ezyang> ah! 
21:57:49 <alexyk> dons: in fact, dcaps is a Map ByteString ..., so it shouldn't be affected at all by the instance when we disintern before writing out, which I do.
21:58:11 <alexyk> I mean dcaps' is that after disinterning
21:58:29 <ezyang> Good sense. And I'm not allowed to sleight of hand convert T . T into T x T to pass to a traditional monoid mult. 
21:59:22 <sophacles> hi all, total n00b here, can someone please tell me why this http://pastie.org/1027685 code raises this: http://pastie.org/1027688
22:00:08 <blackdog> what type does "value x" have?
22:00:25 <sophacles> String
22:00:34 <blackdog> what value does findWords claim to return?
22:01:18 <sophacles> ooohhh
22:01:27 * blackdog is getting all socratic up in here
22:01:34 <sophacles> wow my python inspired bad habits are showing 
22:01:52 <blackdog> and the reason you get a slightly impenetrable error message is that ghc is trying to be helpful and narrowing it down to the smallest case
22:01:59 <blackdog> and String is a list of Chars
22:02:29 <blackdog> so instead of an error about String instead of [String], it burrows in one more level and you get an error about Char rather than [Char]
22:03:01 <sophacles> im not following that
22:03:16 <blackdog> well, you're returning a String, right?
22:03:25 <blackdog> where it expects a [String]
22:03:33 <blackdog> so [Char], where it wants [[Char]]
22:03:41 <sophacles> right, but when does it expect a Char?
22:03:49 <blackdog> it can match the outer list, but then it tries to match a Char against a [Char]
22:03:54 <blackdog> and that's when the wheels fall off
22:04:00 <blackdog> it wouldn't happen if you were using Bytestrings
22:04:15 <blackdog> or if String was newtyped, rather than just a type synonym
22:04:32 <alexyk> dons: did you base AdaptMap on dafis' strictified IntMap or Data.IntMap?
22:04:33 <blackdog> does that make any sense?
22:05:33 <sophacles> a little, much more than before anyway
22:05:49 <sophacles> im suspecting that i may need more than a day to fully understand :)
22:06:16 <blackdog> cool. the first error is actually more or less just what i said first up
22:06:26 <blackdog> uh, i mean the Expected/Inferred bit
22:06:32 <blackdog> it's only the first line which is misleading
22:06:35 <sophacles> ok
22:06:49 <sophacles> yeah, i saw how your questions mapped to the rest of the error
22:07:31 <alexyk> what do I :set so that ByteString doesn't need pack in ghci again?
22:08:20 <sophacles> blackdog: thanks much for the help, off to solve the more practical problem of convincing this silly thing to work :)
22:08:34 <blackdog> alexyk: OverloadedStrings
22:08:49 <blackdog> -XOverloadedStrings, i mean
22:08:56 <alexyk> blackdog: thx
22:08:58 <blackdog> sophacles: np. have fun :)
22:10:41 <alexyk> dons: mea culpa, Float=>Double did I
22:11:00 <alexyk> so got big naturals twice, naturally
22:11:18 <dons> hehe
22:13:15 <alexyk> dons: same result numerically with adaptmap, only 5-7 minutes longer to achieve
22:13:42 <alexyk> and memory-wise, in fact dafis' strictified IntMap does 38 GB.
22:13:49 <alexyk> so dafis wins so far! :)
22:14:35 <alexyk> it looks like dafis beat ocaml at 848 secs in this run.  Must do a few more as they're in hot cache right now.
22:14:56 <dafis> what? my stuff is actually faster than dons'????
22:15:09 <alexyk> dafis: yessir; and eats less memory.
22:15:18 <alexyk> dafis: and 1 file less!
22:15:23 <dons> alexyk: nice. 
22:15:33 <dafis> strange
22:15:41 <dons> interesting that the specialized version didn't help. inlining dictionaries i guess
22:15:46 <dons> will take another look on the weekend
22:16:01 <alexyk> dafis: now there're only two branches left, master with yours, and donsmap with dons'
22:16:05 <alexyk> so you can check
22:16:26 <alexyk> dafis: for now you're Master Dafis! :)
22:16:56 <dafis> alexyk: after I'm done with stringsearch, I thought I'd have that finished hours ago :(
22:17:29 <dafis> but writing docs takes much longer than writing code 
22:17:52 <alexyk> dafis: I know, that's what holding me back on the shootout.  All the docs must be written.
22:18:37 <alexyk> BTW, here's a fun question: I need 3-language comments to be generally the same.  So I won't write full comments in code, creating names and a file instead.  Makes sense?
22:18:51 <alexyk> for documenting my original code at least.
22:19:02 <alexyk> or preprocessing can be done
22:19:13 <alexyk> to splice the same comments into each language
22:19:15 <dons> mmm.
22:19:18 <dons> interesting
22:19:24 <dons> literate multilanguage with includes
22:19:44 <ddarius> Just make a polyglat.
22:19:47 <ddarius> s/glat/glot
22:19:51 <alexyk> dons: exactly.  The algorithms are the same.  I;d document language-specific points fully in each, of course
22:20:17 <alexyk> but if I decide to update the algo comments,, I'd rather not hunt and sync
22:25:26 * ezyang must not confuse type functions and value functions 
22:27:53 <ddarius> ezyang: You could switch to a dependently typed language instead.
22:28:06 <ezyang> hehe 
22:28:23 <alexyk> ddarius: I've already made only polyglot (my son), but you must neat something else
22:28:40 <alexyk> one polyglot I meant
22:28:58 <alexyk> mean
22:29:12 <alexyk> typing suffers exponentially after midnight
22:29:21 <ezyang> Huh, the monad laws are just the monoid laws. 
22:30:18 <gwern> poor ezyang. now he's going to start seeing category theory everywhere
22:30:23 <ddarius> From the perspective of a monoid object in an endofunctor category, that is what "A monad is a monoid in the category of endofunctors" means.
22:30:36 <gwern> 'like the law of fives, I find monoids & monads to be more evident the more I look'
22:31:07 <ddarius> @quote lax.functor
22:31:07 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
22:32:02 <ezyang> ddarius: Sweet! 
22:32:12 <alexyk> that's the most interesting grammatical filling in "fuck that %s shit"
22:33:01 * alexyk laments the shiftong of copumpkin into another time zone
22:33:05 <alexyk> lifting
22:33:48 * hackagebot hmatrix-gsl-stats 0.1.1.4 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.1.4 (VivianMcPhail)
22:34:21 <alexyk> can you time statements in ghci?
22:34:34 <alexyk> (wrap in getCPUtime I guess)
22:36:33 <Saizan> there's :set +t too
22:40:50 * hackagebot hstatistics 0.2.0.5 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.0.5 (VivianMcPhail)
22:42:51 * hackagebot hsignal 0.1.1.1 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.1.1 (VivianMcPhail)
22:44:40 <augur> ddarius: hey
22:45:51 <augur> do you know of any algorithms for eh.. i dont know what to call it, but something where you give the function an object, and then two patterns, and it pulls apart the object based on the first pattern and reconstructs it according to the second?
22:47:30 <ddarius> augur: That sounds like a normal function, so you'll have to say something clearer than that.
22:47:36 <augur> well
22:47:39 <augur> ill give you an example then
22:47:52 <augur> in haskell-ish, but not in haskell
22:48:55 <augur> let pairs = [(1,(a,true)), (1,(b,true)), (2,(a,false))]
22:50:02 <augur> xform pairs [(N,(L,B))] { N => { L => B }} = { 1 => { a => true, b => true }, 2 => { a => false } }
22:54:01 <augur> i mean, its sort of like a comprehension, in some sense, i suppose
22:54:32 <ddarius> Yeah.  map (\(N,(L,B)) -> { N => { L => B } }) pairs
22:55:05 <augur> but see, not quite, right, because you don't get three hashes as a result
22:55:10 <augur> you get a single hash
22:56:12 <ddarius> Then you could do a "unionMap" or something.
22:56:18 <augur> and you might do it in reverse too, right
22:57:57 <ddarius> You might want to look at lenses (aka functional references aka accessors) and possibly the (slightly) related field of semi-structured data.
22:58:43 <augur> what are these lenses now?
22:58:51 <ddarius> @where lenses
22:58:51 <lambdabot> I know nothing about lenses.
22:59:32 <ddarius> http://www.seas.upenn.edu/~harmony/
23:00:40 <augur> lenses might be it
23:00:43 <augur> cool thanks
23:05:06 <alexyk> I'm reading in a binary compressed map and search for a key.  It takes 52 minutes of CPU time already and 30 GB of RAM.  Huh?
23:05:11 <alexyk> in ghci
23:06:53 <Cale> alexyk: and it finishes?
23:07:07 <alexyk> Cale: not yet
23:07:17 <Cale> Maybe the program is incorrect?
23:07:21 <Cale> How big is the map?
23:07:47 <alexyk> Cale: 5 million entries, here's the complete program:
23:07:48 <alexyk> > dc <- BinaryGraph.loadData "dcaps-dons" :: IO (Map ByteString [(Int,Double)])
23:07:48 <alexyk> > dc ! "justinbieber"
23:07:49 <lambdabot>   not an expression: `dc <- BinaryGraph.loadData "dcaps-dons" :: IO (Map Byte...
23:07:49 <lambdabot>   Not in scope: `dc'
23:08:38 <alexyk> it was written with compress.  why on earth is ghci so slow?  
23:08:45 <alexyk> and takes 30 gigs?
23:09:53 * alexyk will write into a Trie next time
23:09:57 <Saizan> does it work fine when compiled?
23:10:21 <Saizan> also, maybe you've to decompress first?
23:11:36 <ddarius> 30GB would use more space than my Linux partition has altogether.
23:12:17 <mmagee> is it in swap
23:13:00 <alexyk> Saizan: yeah, will try decompressing separately.
23:13:10 <alexyk> it's fully in RAM
23:14:45 <dons> are you loading it in bytecode? 
23:14:55 <dons> i.e. the decompresssion routine is being interpreted?
23:19:52 <alexyk> dons: does ghci interpret things?
23:20:53 <alexyk> dons: I have all modules compiled in the local dir.  I wonder how it manages to interpret it, but it's darn slow
23:21:29 <Saizan> ghci will load the compiled code if it finds it, otherwise interprets from bytecode
23:21:59 <alexyk> Saizan: I am supposed to have it all compiled locally; I hope it can find zlib compiled
23:22:25 <Saizan> it's not like it has the source of zlib available
23:23:05 <Saizan> however, anything more complex than a single function call could benefit from compilation, i guess
23:25:03 <alexyk> Saizan: yeah... I prefer to work in a repl if I can.  This slowness bothers me.
23:26:26 <alexyk> dons: why would it interpret if BinaryGraph.o is there?
23:26:28 <dons> any expressions you type will be bytecode, but may call compiled code.
23:26:56 <alexyk> dons: I call BinaryGraph.loadData which is supposed to do decompression and loading from binary
23:27:25 <alexyk> it's unbelievably slow, taking more than an hour already
23:27:51 <alexyk> and 30 GB of RAM
23:27:53 <Saizan> if it interprets a module you get a message like "[5 of 6] Compiling Distribution.Client.Dependency.TopDown.Types ( Distribution/Client/Dependency/TopDown/Types.hs, interpreted )"
23:28:04 <Saizan> see the interpret at the end
23:28:11 <dons> alexyk: do you have *> prompt?
23:28:32 <alexyk> dons: I set my prompt to "> " as module names annoy me
23:28:36 <dons> seems very likely something is being interpreted, rather than compiled. back to the command line.
23:28:46 <dons> oh. but now you can't tell if it is bytecode or not.
23:29:01 <alexyk> dons: how do I get my prompt back?
23:32:14 <alexyk> dons: here's the session: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26795#a26795
23:33:24 <alexyk> I defined dc twice here by mistake, but shouldn't hurt right
23:34:18 <alexyk> btw how do you prevent module names from eating all the line?
23:35:33 <Saizan> iirc, Map ByteString is not recommended because compare is not so fast for ByteString
23:35:53 <alexyk> Saizan: yeah, I'll replace by Trie
23:36:04 <alexyk> but still, this thing is fishy
23:37:30 <Saizan> unless loadData is so lazy that the Map is not even deserialized at that point
23:38:25 <alexyk> Saizan: could very well be!
23:38:41 <mmagee> m2
23:39:00 <alexyk> Saizan: should I strictify it?  here:
23:39:02 <alexyk> loadData fileName = do
23:39:03 <alexyk>   bs <- BL.readFile fileName
23:39:03 <alexyk>   let g = D.decode . decompress $ bs
23:39:03 <alexyk>   return g
23:39:19 <Saizan> D.decode is from binary?
23:39:19 <alexyk> BL is the Lay ByteString
23:39:27 <alexyk> yep
23:39:34 <alexyk> after decompress
23:39:58 <alexyk> let !g --?
23:40:18 <alexyk> or, perhaps I want to preserve lazy read
23:40:26 <Saizan> i'm not that familiar with the Binary instances for Map, but "return $! g" would make sense
23:40:31 <alexyk> so something wanting just a prefix can be happy
23:40:41 <Saizan> Map is spine strict
23:40:49 <Saizan> (or is it?)
23:41:13 <Saizan> yeah, it is
23:42:02 <Saizan> so the whole tree gets built before you can do any lookup, except for the values contained
23:42:28 <alexyk> Saizan: how's "except"?
23:42:46 <alexyk> meaning getting just the values is lazy?
23:43:42 <Saizan> you can do lookups on a Map without forcing the evaluation of the values
23:43:56 <Saizan> the keys and the tree structure will be forced though
23:44:28 <alexyk> okok
23:44:35 <alexyk> later...
