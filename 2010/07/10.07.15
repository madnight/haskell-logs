00:00:03 <pastorn> this is indeed weird
00:00:13 <pastorn> i'll report this to the maintainer of Vty
00:00:46 <arcatan> Vty became Wtf
00:00:53 <pastorn> arcatan: haha
00:00:57 <pastorn> it's a great library :)
00:01:12 <ski> o-_-o : `data' is a way to define new datatypes, while `class' is a way to specify types of (overloaded) operations (methods), that different types can support
00:01:28 <pastorn> o-_-o: ever thought of a pronounceable nick? :p
00:01:29 <o-_-o> ski, ah...ok
00:01:48 <o-_-o> pastorn, ah...*sigh* long story short someone stole my nick
00:01:58 <o-_-o> pastorn, so only thing left is my troll nick
00:02:19 <pastorn> o-_-o: haha... did you ask for it back?
00:02:32 <manju_> pastorn, well actually no
00:02:37 <pastorn> haha
00:02:39 <pastorn> good job!
00:02:48 <ski> s/o-_-o/manju_/ : e.g., there is a very simple `class Eq a where (==) :: a -> a -> Bool' which specifies an equality check operation, while types may elect to implement
00:03:08 <manju_> ski, ah...ok
00:03:13 <manju_> well I have a problem
00:03:25 <manju_> I removed the v and now I get lots errors
00:03:41 <ski> which `v' ?
00:04:30 <manju_> data V v = MkV Float Float deriving Show, the small one
00:04:43 <ski> what are you trying to do ?
00:04:43 <manju_> hang on I haven't understood this correctly
00:05:15 <manju_> ski, I am trying to write a Vector3 class (like a C++ class)
00:05:25 <manju_> ski, only in haskell with data
00:06:03 <ski> are you trying to make a data type whose values each contain three `Float's ?
00:06:12 <ski> or maybe `Double's ?
00:06:12 <manju_> ski yes
00:06:16 <manju_> ski, yes
00:06:25 <ski> which ?
00:06:25 <manju_> and I can do things like
00:06:31 <ski> should both be possible ?
00:06:49 <manju_> ski, that would be good, but currently mine supports only float
00:07:08 <manju_> ski, supported in the past, not I broke it
00:07:20 <manju_> s/not/now
00:08:15 <ski> so, why did you parameterize `V' above ?
00:08:42 <ski> (also, you do know that you only had two `Float's above, yes ?)
00:09:11 <manju_> ski, I don't have an answer
00:09:38 <manju_> ski, ok I parametrized v to make it compile I think
00:10:02 <manju_> I have something like this
00:10:13 <ski> presumably you have used `V' applied to a type argument, in other places
00:10:15 <manju_> data Vec3 = MkVec3 Float Float Float deriving Show
00:10:24 <manju_> I want to do something like this
00:10:30 <manju_> getx::Vec3 -> FLoat
00:10:44 <ski>   getx (MkVec3 x y z) = x
00:10:49 <manju_> when I say let a0 = MkVec3 1.0 2.0 3.0
00:11:05 <manju_> and say getx a0 I get back 1.0
00:11:17 <manju_> ah...I have that
00:11:20 <manju_> hmmm...
00:11:28 <ski> you can also say
00:11:31 <soupdragon> > let a=3 ; b=4 ; c=5 in (c^2, a^2 + sqrt(a^2+(b/2)^2)*b)
00:11:32 <lambdabot>   (25,23.42220510185596)
00:11:52 <ski>   data Vec3 = MkVec3 { getX :: Float , getY :: Float , getZ :: Float } deriving Show
00:12:11 <ski>   data Vec3 = MkVec3 { getX,getY,getZ :: Float } deriving Show  -- maybe it can be shortened to this, i don't recall
00:12:36 <pastorn> anyone experienced using Trac?
00:12:39 <manju_> ski, ah..thanks actually it worked, I had some other problem
00:12:43 <ski> (but that will then `show' values of type `Vec3' using the record syntax .. which sometimes might be clunky)
00:12:51 <pastorn> do you *have* to write the massive, weird URL to make a new ticket?
00:13:00 <pastorn> seems awefully tedious... isn't there a form?
00:14:34 <manju_> ski, cool thanks
00:15:31 <manju_> this is nice
00:17:25 <soupdragon> Does anyone know the fishtank proof of pythagoras???
00:19:29 <gwern> soupdragon: what an odd sounding think
00:19:41 <gwern> soupdragon: are you quite sure it was pythagoras, and not, say, archimedes?
00:19:53 <soupdragon> a^2+b^2=c^2
00:19:54 <tolkad> > x = 5 : x
00:19:55 <lambdabot>   <no location info>: parse error on input `='
00:20:04 <tolkad> > x = 5 : x; x
00:20:06 <lambdabot>   <no location info>: parse error on input `='
00:20:12 <gwern> isn't that the pythagorean theorem?
00:20:14 <tolkad> > let x = 5 : x in x
00:20:15 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
00:20:22 <gwern> which has aught to do with fishtanks, I'll be bound
00:20:33 <soupdragon> Iwant to pove it using a fishtank
00:20:37 <tolkad> > let x = 5 : take 5x in x
00:20:38 <lambdabot>   [5,5,5,5,5,5]
00:20:40 <tolkad> > let x = 5 : take 5 x in x
00:20:41 <lambdabot>   [5,5,5,5,5,5]
00:20:43 <gwern> indeed?
00:20:56 <tolkad> wow... that's pretty cool
00:21:11 <tolkad> it terminated 0_o
00:21:15 <tolkad> o_0
00:21:16 <soupdragon> > let x = 5 : take (head x) in x
00:21:17 <lambdabot>   Couldn't match expected type `[t]'
00:21:17 <lambdabot>         against inferred type `[a] -> [a]'
00:21:20 <soupdragon> > let x = 5 : take (head x) x in x
00:21:21 <gwern> @quote Aztec
00:21:21 <lambdabot>   [5,5,5,5,5,5]
00:21:21 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
00:21:36 <gwern> tolkad: laziness can be pretty odd
00:21:53 <tolkad> [.5,.25..]
00:21:57 <tolkad> > [.5,.25..]
00:21:58 <lambdabot>   <no location info>: parse error on input `..'
00:22:16 <Veinor> :t zip `ap` tail
00:22:18 <lambdabot> forall b. [b] -> [(b, b)]
00:22:32 <gwern> > [0.5, 1.0..]
00:22:33 <lambdabot>   [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5,6.0,6.5,7.0,7.5,8.0,8.5,9.0,9....
00:22:42 <Veinor> > zip `ap` tail $ [1..]
00:22:43 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
00:22:48 <gwern> tolkad: can't write just a leading period
00:22:48 <Veinor> neat
00:23:30 <tolkad> > map (\(x, y) -> x / y) ([1..], [2, 3..])
00:23:31 <lambdabot>   Couldn't match expected type `[(t, t)]'
00:23:31 <lambdabot>         against inferred type `([t1...
00:23:38 <tolkad> wtf
00:23:46 <tolkad> oh
00:23:51 <tolkad> I see why lol
00:24:13 <tolkad> uh... hmm what should I use
00:24:30 <tolkad> > map (\x -> 1 / x) [2, 3..]
00:24:31 <lambdabot>   [0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.14285714285714285,0....
00:24:39 <tolkad> > map (\x -> 1 / x) [2,4..]
00:24:40 <lambdabot>   [0.5,0.25,0.16666666666666666,0.125,0.1,8.333333333333333e-2,7.142857142857...
00:25:16 <tolkad> > map (\x -> 1 / (x ^ 2)) [1,2..]
00:25:16 <lambdabot>   [1.0,0.25,0.1111111111111111,6.25e-2,4.0e-2,2.7777777777777776e-2,2.0408163...
00:25:19 <tolkad> > map (\x -> 1 / (x ^ 2)) [1..]
00:25:20 <lambdabot>   [1.0,0.25,0.1111111111111111,6.25e-2,4.0e-2,2.7777777777777776e-2,2.0408163...
00:25:38 <tolkad> > map (\x -> 1 / (2 ^ x)) [1..]
00:25:38 <lambdabot>   [0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.953125e-3...
00:25:50 <tolkad> > sum (map (\x -> 1 / (2 ^ x)) [1..])
00:25:56 <lambdabot>  Terminated
00:25:57 <tolkad> huh, looks like that's a bug
00:26:05 <tolkad> anyone know when it's going to get fixed?
00:32:12 <drbean> :t ap
00:32:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:32:40 <ski> > (`fix` primes) $ \foo (p:ps@(q:_)) -> (`map` [0..]) $ \i -> if i == 0 then 0 else let (j,r) = i `divMod` p in q * foo ps !! j + r
00:32:42 <lambdabot>   [0,1,3,4,6,7,15,16,18,19,21,22,30,31,33,34,36,37,45,46,48,49,51,52,60,61,63...
00:33:25 <Veinor> @oeis [0,1,3,4,6,7]
00:33:25 <lambdabot>  Sequence not found.
00:33:32 <Veinor> @oeis 0,1,3,4,6,7
00:33:32 <lambdabot>  Numbers that are congruent to 0 or 1 mod 3.
00:33:32 <lambdabot>  [0,1,3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,30,31,33,34,36,37,39,4...
00:33:40 <Veinor> @oeis 0,1,3,4,6,7,15,16,18
00:33:41 <lambdabot>  Sequence not found.
00:33:54 <Veinor> @oeis 3,4,6,7,15,16,18
00:33:54 <lambdabot>  Sequence not found.
00:34:02 <Veinor> :O
00:34:30 <soupdragon> > primes
00:34:32 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
00:35:15 <Veinor> ... 9 and 15 are prime now?
00:35:28 <soupdragon> to high probability
00:35:32 <ski> hrm, oops :)
00:35:58 <c_wraith> 9 and 15 are special primes. :)
00:36:09 <c_wraith> but that really does look more like a list of odd numbers.
00:36:31 <soupdragon> lololol
00:37:05 <ski> > primes
00:37:06 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:37:16 <ski> .. well, looks better
00:37:20 <ski> > fix $ \foo -> (`map` [0..]) $ \i -> if i == 0 then 0 else let (j,r) = i `divMod` 2 in r + 3 * foo !! j
00:37:21 <lambdabot>   [0,1,3,4,9,10,12,13,27,28,30,31,36,37,39,40,81,82,84,85,90,91,93,94,108,109...
00:38:09 <c_wraith> > let p (x:xs) = x : p (filter ((/=0) . (`rem` x)) xs) in 2 : p [3,5..]
00:38:10 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:38:30 <c_wraith> It's not efficient, but it's an easy one-liner.
00:39:00 <shachaf> > nubBy(((>1).).gcd)[2..]
00:39:02 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:39:11 <Veinor> O_o
00:39:34 <Veinor> @unpl ((1>).) . gcd
00:39:35 <lambdabot> (\ e h -> 1 > (gcd e h))
00:40:09 <Veinor> I wonder why e and h
00:41:21 <tensorpudding> eh
00:41:29 <c_wraith> hah
00:41:31 <Veinor> :P
00:41:57 <c_wraith> > 2 : nubBy (((> 1) .) . gcd) [3,5..]
00:41:58 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:42:10 <c_wraith> hah.  I cut a constant factor in half! :0
00:42:14 <c_wraith> err.  :)
00:43:33 <c_wraith> But really, that's even slower than my first version, since gcd requires multiple rem/mod operations.
00:44:14 <c_wraith> sadly, really efficient sieves aren't one-liners. :)
00:45:11 <Veinor> > let primes = 2 : nubBy (((> 1) .) . gcd) [3,5..] in primes !! 1000
00:45:14 <lambdabot>   7927
00:46:42 <NHA_> im trying to implement a pure version of the skip-quadtree data structure, which is something similar to a skip list. One of the major points is that you can resume a search from the same node in one of the lower level trees. I dont see how you can do this in haskell without using mutable variables or indices into another container to simulate pointers between the different trees. i guess the question is what can i replace a skip list with
00:46:42 <NHA_>  that has similar "level of detail" style properties.
00:47:19 <c_wraith> NHA_: The Zipper concept might apply, depending on your use case.
00:47:48 <NHA_> but zippers only work on one tree at a time right?
00:47:56 <NHA_> the cursor needs to move through all the trees at the same time
00:48:06 <c_wraith> each search would be its own zipper
00:48:57 <c_wraith> But since the zipper structure would be persistent, you could keep a stack/queue of them for resuming from various points.  The downside to this approach is massively increased memory requirements.
00:49:31 <c_wraith> Well, actually, there could be good sharing, meaning the increase wouldn't be that massive.
00:50:29 <Ke> > drop 1000 primes
00:50:31 <lambdabot>   [7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081...
00:52:01 <c_wraith> Also, a zipper approach doesn't help at all if you need to alter the quadtree between partial searches.
00:52:04 <malorie> is `factorial :: (Integral a) => a -> a` equivalent to `factorial :: Integral -> Integral`?
00:52:16 <c_wraith> malorie: no, Integral isn't a type.
00:52:26 <c_wraith> @instances Integral
00:52:27 <lambdabot> Int, Integer
00:52:39 <malorie> c_wraith: ah. i see.
00:53:02 <c_wraith> There are more instances than those...  Those are just the ones in the prelude. :)
00:53:31 <malorie> but if it were a type, those notations would be equivalent?
00:53:40 <c_wraith> If it were a type, the first wouldn't be legal.
00:53:59 <c_wraith> Only type class restrictions can be in the context (the part to the left of the =>)
00:54:59 <c_wraith> Really, the best way to think of the context is "restrictions on the types you can use for the type variables"
00:56:39 <malorie> c_wraith: so, `fac :: (Integral a) => a -> a` would be equ. to `fac :: Int -> Int` as well as `fac :: Integer -> Integer`? not sure about `fac :: Int -> Integer`, though
00:57:34 <nlogax> malorie: all three of them are `a` so they must be the same type, afaik
00:57:47 <arcatan> yes, so :: Int -> Integer would be illegal
00:57:52 <c_wraith> indeed, they must be the same type, since it's just one type variable
00:58:00 <malorie> gotcha!
00:58:32 <arcatan> by the way, is id the only function of type a -> a?
00:58:54 <ivanm> arcatan: the only sensible one, yes
00:59:01 <ivanm> otherwise "const undefined" works
00:59:22 <arcatan> obviously, yeah
00:59:36 <quicksilver> ivanm: and so does 'undefined' ;)
00:59:52 <ivanm> quicksilver: yeah ;-)
01:00:00 <c_wraith> :t fromIntegral -- malorie
01:00:01 <lambdabot> forall a b. (Integral a, Num b) => a -> b
01:00:11 <ski> > const undefined `seq` ()
01:00:12 <lambdabot>   ()
01:00:40 <c_wraith> malorie: Note that fromIntegral has two type variables.  That means it can actually convert from any instance of Integral to any instance of Num.  (In fact, that's its purpose)
01:00:47 <Deewiant> ?ty seq () -- another
01:00:48 <lambdabot> forall t. t -> t
01:02:25 <malorie> makes sense now! thx, all.
01:02:35 <c_wraith> Deewiant, at least that one is denotationally equivalent to id, rather than _|_ :)
01:02:42 <quicksilver> Deewiant: is it "another", though?
01:02:45 <quicksilver> really that's id.
01:03:26 <Deewiant> If you're in real-world-land and pass it something other than () it can have observable side effects
01:03:57 <Deewiant> (As opposed to pure-Haskell-land where nothing ever runs out of memory etc)
01:04:00 <quicksilver> tsk. real-world-land be damned.
01:04:03 <quicksilver> This is #haskell.
01:04:03 <Ke> @src nubBy
01:04:04 <lambdabot> nubBy eq []             =  []
01:04:04 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:04:19 <quicksilver> anyhow you didn't pass it anything other than () ;)
01:04:37 <Deewiant> Well, unsafePerformIO isn't in scope ;-P
01:05:24 <c_wraith> If you're allowing unsafePerformIO, you don't need seq for different-behaving implementations of a -> a.
01:05:38 <Deewiant> Yep, true
01:05:46 <Deewiant> ?ty seq (last [1..maxBound :: Int]) -- fine then
01:05:47 <arcatan> i was interested in pure functions, anyway
01:05:47 <lambdabot> forall t. t -> t
01:05:56 <c_wraith> like...  \x -> unsafePerformIO (launchZeMissiles >> return x)
01:06:13 <Deewiant> unsafeCoerce `asTypeOf` id
01:07:26 <arcatan> every Haskell programmer has a missile launch facility in their back yard, i see.
01:08:00 <Deewiant> Given the amount of times launchMissiles shows up around here, it seems to be so
01:08:04 <ivanm> arcatan: I don't... because I dont' have a back-yard :s
01:08:21 <medfly> basement counts too
01:08:24 <c_wraith> is it in your front yard?
01:09:01 * hackagebot uu-parsinglib 2.3.4 - New version of the Utrecht University parser combinator library  http://hackage.haskell.org/package/uu-parsinglib-2.3.4 (DoaitseSwierstra)
01:09:28 <c_wraith> oh, hey.  I wonder if he remembered to include the patch I suggested.
01:10:01 <ivanm> medfly: don't have one of those either
01:10:03 <c_wraith> Oh, right.  No docs for...  Another 5 hours.  I'll check in the morning.
01:10:03 <ivanm> or a front yard
01:10:06 * ivanm lives in an apartment
01:10:19 <c_wraith> secret underground facility at the north pole?
01:10:32 <medfly> ivanm: damn. that must really suck
01:10:49 <ivanm> why? because I can't have any missiles?
01:10:52 <medfly> right
01:10:57 <ivanm> c_wraith: wrong hemisphere
01:11:08 * ivanm has penguins outside his secret lair, not polar bears
01:11:08 <c_wraith> I always run into everyone going to my secret underground facility at the north pole.  It's not much of a secret anymore.
01:12:01 * hackagebot species 0.3.0.2 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.0.2 (BrentYorgey)
01:17:11 <drbean> :t nub
01:17:12 <lambdabot> forall a. (Eq a) => [a] -> [a]
01:17:27 <drbean> @src nub
01:17:27 <lambdabot> nub = nubBy (==)
01:18:57 <drbean> @src nubBy
01:18:58 <lambdabot> nubBy eq []             =  []
01:18:58 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:19:40 <drbean> I thought 'eq' equaled '=='.
01:20:43 <drbean> There is no 'eq'.
01:20:44 <ivanm> nope
01:20:47 <ivanm> it's just a variable there
01:20:55 <ivanm> @type nubBy
01:20:56 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
01:21:21 <ivanm> hmmm..... van you have symbols as variables?
01:21:26 <c_wraith> yes
01:21:31 <quicksilver> drbean: in that source, it's a formal parameter. So you if do 'nubBy (==)' you get nub.
01:21:35 <quicksilver> @src on
01:21:35 <lambdabot> (*) `on` f = \x y -> f x * f y
01:21:36 <quicksilver> ivanm: ^^
01:21:43 <ivanm> c_wraith: oh, right, the whole "2+2=5" thing
01:21:49 <ivanm> quicksilver: yeah
01:24:40 <ski> > let (+) * (/) = (/) - (+) in 2 * 3
01:24:41 <lambdabot>   1
01:25:32 <Itkovian> FYI, http://clash.ewi.utwente.nl/ClaSH/Index.html (hardware descriptions in haskell), not sure if it's been posted someplace on the mailing lists. 
01:26:37 * c_wraith notes that 2 * 3 is 1, and ignores how that result was achieved.
01:27:05 <c_wraith> I have a fun new fact to share tomorrow!
01:27:48 <soupdragon> I'm cool with 2 * 3 = 1
01:27:57 <ivanm> heh
01:28:31 <dolio> > let x * y = (x Prelude.* y) `mod` 5 in 2 * 3
01:28:33 <lambdabot>   1
01:28:34 <mee> *cough*mod5*cough*
01:28:35 <ivanm> Itkovian: don't think I've heard of that one before; however firefox doesn't seem to like it
01:28:52 * ivanm is suspicious of the "Made on a Mac" tag on the bottom
01:28:56 <mornfall> mee: more like defining * to be flip (-)...
01:29:19 <ivanm> preflex: seen jaspervdj 
01:29:20 <preflex>  jaspervdj was last seen on #haskell 17 hours and 44 minutes ago, saying: So... I want to run a Haskell script during `cabal configure`. I have found out how to add the hook, but now I'm looking for the best way to call `runghc` from within a Haskell file.
01:29:36 <c_wraith> > let (*) = subtract in 2 * 3
01:29:37 <lambdabot>   1
01:29:47 <quicksilver> Itkovian: are you involved with it, or just found out about it?
01:40:05 <Itkovian> quicksilver: not involved, just saw a poster about it yesterday.
01:40:28 <quicksilver> Itkovian: looks cool. Someone should get them to submit a mini-writeup to HCAR
01:40:54 <Itkovian> I'll see if I can find the bloke today.
01:41:24 <Itkovian> and what's HCAR again?
01:43:01 <quicksilver> @where hcar
01:43:01 <lambdabot> http://www.haskell.org/communities/
01:44:14 <pastorn> @hoogle withFile
01:44:15 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
01:44:17 <Itkovian> right, thx.
01:54:12 <pastorn> is there a tutorial for haskell-src-exts somewhere?
01:58:17 <tibbe> dcoutts: how difficult is it to rebuild all the haddock docs on hackage?
02:02:19 <etpace> > Just 5 `mappend` Nothing
02:02:20 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:02:20 <lambdabot>    `Data.Monoid.Monoid t'
02:02:20 <lambdabot>  ...
02:02:29 <etpace> > Just 'z' `mappend` Nothing
02:02:31 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
02:02:31 <lambdabot>    arising from a use o...
02:02:39 <etpace> isn't that owrking on the maybe monoid?
02:02:46 <etpace> :t mappend
02:02:47 <lambdabot> forall a. (Monoid a) => a -> a -> a
02:03:07 <medfly> I guess it doesn't know what to do with the char, maybe?
02:03:25 <etpace> hm
02:04:04 <medfly> do not listen to me I don't know Haskell so well :/
02:04:25 <etpace> > Just 5 `mplus` Nothing
02:04:29 <lambdabot>   Just 5
02:04:57 <ski> > Data.Monoid.getSum (Just (Data.Monoid.Sum 5) `mappend` Nothing)
02:04:58 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum a'
02:04:58 <lambdabot>         against inferred t...
02:05:11 <ski> > fmap Data.Monoid.getSum (Just (Data.Monoid.Sum 5) `mappend` Nothing)
02:05:13 <lambdabot>   Just 5
02:05:27 <ski> > Just 5 `mappend` Nothing :: Maybe Int
02:05:28 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
02:05:28 <lambdabot>    arising from a use of...
02:05:57 <ski> > 'a' `mappend` 'a'
02:05:58 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
02:05:58 <lambdabot>    arising from a use o...
02:06:18 <ski> medfly : .. yes ^
02:07:52 <pastorn> @pl (\hs es f -> zipWithM f hs es)
02:07:53 <lambdabot> flip . flip zipWithM
02:12:01 <xkb> hi
02:12:11 <pastorn> hi
02:12:17 <xkb> what haskell webdevelopment platform would you recommend at the moment?
02:12:26 <pastorn> vim + ghci :D
02:12:27 <xkb> Yesod? or something else?
02:12:30 <xkb> hehe :)
02:12:32 <pastorn> oh, web
02:12:57 <pastorn> haha
02:12:57 <pastorn> nice
02:13:04 <pastorn> yes, net development is THAT boring
02:13:14 <xkb> lol
02:14:43 <DarkUnicorn> there aren't many, are there? yesod, snap and happstack
02:14:57 <ivanm> some would argue that that's 2 too many
02:15:11 * ivanm would argue that that's 3 too many, but he doesn't like writing apps that people are expected to use... :p
02:15:31 <pastorn> ivanm: that's the spirit!
02:16:13 <adnap> Don't know how many people are up, but has anyone tried Happstack?
02:16:30 <soupdragon> I have TRIED
02:16:38 <soupdragon> the thing would never install
02:16:39 <adnap> Okay
02:17:25 <adnap> There's just a conceptual blank area in my mind about the whole thing.  So, there's no database involved?
02:17:50 <adnap> I haven
02:18:17 <adnap> I haven't done any web programming since I was like 15.  The only thing I've ever done was a website with PHP and MySQL.
02:19:53 <eevar2> i've just had a quick glance at yesod. don't really like the template haskell stuff
02:20:07 <xkb> I have the same opinion
02:20:15 <xkb> it's not that elegant I think
02:20:44 <xkb> disclaimer: I only wrote "hello world" in it :)
02:21:27 <eevar2> yea, i balked at just looking at someone else's "hello world" example
02:21:51 <xkb> so what else is there?
02:21:57 <xkb> framework-wise
02:24:40 <quicksilver> it's QQ, not TH, isn't it?
02:24:55 <quicksilver> (yes, I know QQ uses TH technology, but morally it's quite different)
02:25:22 <xkb> QQ= QuasiQuotes?
02:26:03 <eevar2> quicksilver: you're probably right
02:26:08 <quicksilver> ye.
02:26:21 <quicksilver> quasiquotes are much less scary and easy to understand.
02:26:41 <quicksilver> It's just a convenient way to give attractive syntax to something you *could* have written in haskell
02:26:50 <quicksilver> but it's only ever a shorthand, and it's "expanded locally"
02:27:04 <quicksilver> it can't have strange side effects or create new definitions like full TH can.
02:29:16 <quicksilver> it's a bit sad that I find the QQ syntax "ugly" but it's a very subjective judgment. I'm not even sure what I mean by it.
02:30:52 <solrize> is qq a replacement for th?
02:31:17 <pastorn> what extenision is this? it's not covered by CPP: #if __GLASGOW_HASKELL__ >= 610
02:31:25 <quicksilver> solrize: no.
02:31:35 <solrize> hm ok
02:31:56 <quicksilver> solrize: QQ is a much simpler language extension which, in point of fact, could be *implemented* in TH.
02:32:05 <quicksilver> and it sort-of is implemented in TH, although there is a bit more sugar than that.
02:34:22 <solrize> bdoes metaocaml do something fundamentally different?
02:34:33 <solrize> i guess th is untyped
02:35:23 <ski> Meta{ML|OCaml} is typed, yes
02:37:50 <solrize> other than that is it different?  i don't really understand what it is.  i did basically understand th when i looked at it though i don't remember much now
02:39:41 * ski hasn't really looked much at TH
02:40:39 <ski> MetaML gives a type system for handling code expressions, together with quotation
02:40:57 <ski> also giving cross-stage persistence
02:41:04 <quicksilver> solrize: TH is not untyped.
02:41:38 <quicksilver> and since TH is run at compile-time, if you do something wrong which is caught at "run-time" it's still compile-time.
02:41:41 <quicksilver> if you see what I mean.
02:41:51 <quicksilver> the bad news is that the error message will make your brain asplode.
02:42:19 <solrize> right
02:42:23 <solrize> ok
02:42:25 <quicksilver> ski: MetaOcaml is genuinely, explicitly multi-stage, right?
02:42:36 <ski> (and by "Meta{ML|OCaml} is typed" i mean that it is impossible to write expanders which will expand to non-well-typed code)
02:42:43 <ski> quicksilver : yes
02:43:01 <quicksilver> TH is not properly staged although you can do some of the things with it which you need staging for in metaocaml.
02:43:51 <quicksilver> Ah. TH can't have that property because it has a turing complete code generator
02:44:00 <ski> if your types include `code', then it's staged once, if it includes `code' inside `code', then it is staged twice, &c.
02:44:04 <quicksilver> so you can't possibly statically check the expander.
02:44:17 <quicksilver> (am I right?)
02:44:42 <ski> i'm not sure
02:45:01 <solrize> l8r
02:45:38 <ski> what Meta{ML|OCaml} does is that instead of having a type `Code' (or whatever), you have types `Code Foo' for every type `Foo'
02:45:47 <ski> so, if you have
02:46:10 <ski>   power :: Num a => Integer -> (a -> a)
02:46:16 <ski> you can easily imagine a
02:46:34 <ski>   staged_power :: Num a => Integer -> Code (a -> a)
02:46:40 <ski> (though maybe
02:46:46 <quicksilver> I think my logic was fallacious.
02:46:48 <ski>   staged_power :: Integer -> Code (forall a. Num a => a -> a)
02:46:57 <ski>  would be more appropriate
02:46:57 <ski> )
02:47:09 <quicksilver> you *could*, in principle, have something like TH which still had the typed expander property.
02:47:25 <quicksilver> the reason you don't is that the TH type for haskell expressions is simply Exp
02:47:27 <quicksilver> not Exp a
02:47:51 <ski> *nod*, it's like `dyncode' (or whatever it was called) in Meta{ML|OCaml}
02:48:04 <quicksilver> so Exp might form code of any type - or, indeed might form code which fails to type-check at all.
02:48:13 <ski> right
02:48:31 <quicksilver> TH basically lets you use haskell to generate fragments of your AST
02:48:36 <quicksilver> in a fairly structured way.
02:48:47 <quicksilver> a fortiori, it actually permits IO
02:48:57 <quicksilver> so you can use anything you want to help you generate chunks of AST.
02:49:24 <ski> in MetaML, one can write
02:49:36 <ski>   fn x => <fn y => (x,y)>
02:50:04 <quicksilver> $(runIO (readProcess "perl" ["makemyprogram.pl"] "")) 
02:50:07 <ski> this corresponds to, more or less, in Scheme
02:50:34 <ski>   (lambda (x) `(lambda (y) (cons ',x y)))
02:50:52 <quicksilver> do the <> mean something?
02:51:12 <ski> .. only that in Scheme, this only works for "self-evaluating" data (like numbers, strings, characters, symbols)
02:51:23 <ski> the `<...>' is (quasi-)quotation
02:52:15 <ski>   fn x => <fn y => (x,y)>  :  'a -> ('b -> 'a * 'b) code
02:52:36 <ski>   fn x => <fn y => (~x,y)>  :  'a code -> ('b -> 'a * 'b) code
02:52:49 <ski> here `~...' is unquote
02:52:54 <ski> see the difference there ?
02:53:11 <quicksilver> Sorry, there is a setting in my brain to cope with ML postfix type constructors
02:53:19 <quicksilver> I have to move a DIP switch and reparse.
02:53:54 <quicksilver> yes, I see.
02:54:00 <ski> the former of these two is an example of "cross-stage persistence", while the latter isn't
02:54:30 <ski> basically, we need to take the value `x', and construct an expression, which when evaluated yields `x'
02:54:40 <ski> and then that expression needs to be spliced into the quotation
02:54:51 <ski> of course, this can't be done, generally
02:55:08 <ski> so, this is not actuayll what cross-stage persistence does
02:55:39 <ski> what it does is merely to insert an expression which is an atomic *variable* which references the value of `x'
02:56:22 <ski> though, in MetaML, they had an experimental
02:56:28 <ski>   reify : 'a -> 'a code
02:56:35 <ski> which attempted to do this conversion
02:56:44 <ski> you could e.g. evaluate
02:57:00 <ski>   reify (fn xs => append [0,1,2] xs)
02:57:04 <ski> and get back
02:57:14 <ski>   <fn xs => 0 :: 1 :: 2 :: xs>
02:57:18 <quicksilver> how is that possible?
02:57:20 <ski> however, if you tried
02:57:26 <ski>   reify (fn xs => append xs [0,1,2])
02:57:30 <ski> it just hanged
02:57:39 <quicksilver> if you call reify polymorphically what can it hope to do?
02:57:49 <quicksilver> was there some adhoc type-based dispatch?
02:58:44 <ski> it used delimited continuations and induction on the type to do (.. hm, tries to recall the term)
02:59:05 <ski> normalization-by-evaluation, i think
02:59:21 <quicksilver> induction over the structure of types, generics-style?
02:59:31 <quicksilver> I didn't know ML had that.
02:59:51 <dolio> ML doesn't, probably.
03:00:13 <dolio> It'd be part of the MetaML extension.
03:00:23 * quicksilver nods
03:00:58 <ski> yes
03:07:01 <ski> "Type-directed partial evaluation" at <http://www.brics.dk/~danvy/tdpe-ln.pdf> by Olivier Danvy, 1996
04:16:11 <zenzike> @pl \x -> p x && q x
04:16:12 <lambdabot> liftM2 (&&) p q
04:17:15 <ski> @type uncurry (&&) . (?p &&& ?q)
04:17:17 <lambdabot> forall (a :: * -> * -> *) b. (?p::a b Bool, ?q::a b Bool, Arrow a, Functor (a b)) => a b Bool
04:17:31 <ski> @type uncurry (&&) Prelude.. (?p &&& ?q)
04:17:33 <lambdabot> forall a. (?q::a -> Bool, ?p::a -> Bool) => a -> Bool
04:17:42 <ski> @botsnack
04:17:42 <lambdabot> :)
04:23:13 <Tomsik> T the difference between Haskell and Scheme is that Scheme is cool, and Haskell was used to made the atomic bomb, funds terrorists and is made by atheists to invent the holocaust myth!
04:23:23 <kamatsu> Axman6: me + my gf are likely to be late for AusHac tomorrow, but we can probably make it to the whole day for other days
04:24:32 <kmc> that's right Tomsik
04:26:06 <Zao> I've got some repetetive boilerplate code. Can I use TH to get rid of the repetition?
04:26:19 <kmc> probably
04:26:25 <kmc> there may be a simpler way
04:26:42 <Zao> http://codepad.org/bC4xDZPz
04:26:45 <kmc> never underestimate the power of the C preprocessor
04:27:00 <Zao> I would like to get rid of some of the uglyness in the GameScreen Screen instance.
04:27:22 <kmc> :t liftIO (putStrLn "default")
04:27:23 <lambdabot> forall (m :: * -> *). (MonadIO m) => m ()
04:27:29 <kmc> why do you need «>> return ()»
04:27:49 <Zao> I've factored out as much as I can into withZ and runZ, but I can't generalize away the match with MkScreen.
04:27:56 <kmc> anyway you can give that a name and just say "key _ = foo; paint = foo; update _ = foo"
04:28:24 <Zao> Note the different tail bits.
04:28:34 <Zao> (key ch), (paint), (update dt)
04:28:49 <kmc> «\x -> case x of MkScreen scr -> ...»   ⇒   «\(MkScreen scr) -> ...»
04:29:02 <Zao> As far as I know, they must be inside the case pattern as they depend on scr.
04:29:59 <Zao> Oh, that kind of pattern worked.
04:30:12 <kmc> you can move the runZ call into withZ too can't you?
04:30:41 <kmc> this is kind of convoluted
04:30:46 <kmc> i wonder if there's a simpler way
04:31:09 <kmc> are you sure you want classes and existentials to model screens, rather than a simple record type?
04:31:11 <Botje> why do you do runZ at all?
04:31:44 <Zao> Botje: I need to run a local state computation with the wrapped screen.
04:31:53 <kmc> also are you sure you want (StateT s IO) rather than using the state that's built into IO?
04:32:13 <Zao> kmc: No idea.
04:32:14 <Botje> Zao: are you sure you don't just want to update the state?
04:32:35 <quicksilver> Botje: he's repackaging the specific "s" (which is some unknown GameScreen instance)
04:32:41 <ski> Zao : is there a reason for having default implementations of the methods, here ?
04:32:48 <quicksilver> Botje: back into an existential after every primop of his monad.
04:33:04 <Botje> ohhh
04:33:08 <quicksilver> I'm not sure it's a good design, btu I don't have a more constructive suggestion.
04:33:10 <Zao> ski: In GameScreen s, yes, for testing purposes.
04:33:39 <quicksilver> it feels wrongly typed because it admits the possiblity that you can switch to a different instance in a single primop
04:33:43 <ski> testing what ?
04:33:47 <quicksilver> (although none of them actually do that, in that fragment)
04:34:30 <Zao> ski: My understanding of typeclasses in general.
04:34:44 <kmc> this does not feel like a good use case for typeclasses
04:34:56 <kmc> seems more like http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
04:35:32 <kmc> if you also use IORefs instead of StateT then it gets real simple
04:35:51 <kmc> data Screen = Screen { key :: Char -> IO (); paint :: IO (); update :: TimeInterval -> IO () }
04:36:07 <hpc> OpenGL already exports an excellent interface to IORefs
04:36:09 <kmc> mkMyScreen :: IO Screen
04:36:30 <kmc> mkMyScreen can create some IORefs, and package them up into the record's fields as free variables
04:36:45 <dolio> I've used a combination existential-universal state monad before, if that's what we're talking about.
04:36:53 <kmc> no type class, no existential, no laborious wrapping/unwrapping
04:37:19 <quicksilver> I agree about skipping the typeclass.
04:37:20 <dolio> M a = forall s. P s -> exists s. (P s, a), or something like that.
04:37:22 <kmc> with StateT:
04:37:26 <quicksilver> I don't think I agree about skipping the state.
04:37:36 <quicksilver> I'd rather not use IO's state - because I'd rather allow some operations to be pure.
04:37:41 <Zao> I guess what I want in the end is something along the lines of   data Screen = Screen { key, paint, update, updatableState }
04:37:46 <dolio> Maybe move the exists inward.
04:37:47 <kmc> data Screen = forall s. Screen { key :: Char -> StateT s IO (), paint :: StateT s IO (), update :: TimeInterval -> StateT s IO () }
04:37:50 <Zao> But I could as well curry an ioref into the functions.
04:37:58 <kmc> now you have an existential, but still no class is necessary
04:38:01 <quicksilver> for example (hypothetically) update :: TimeInterval -> (s -> s)
04:38:08 <quicksilver> no IO involved in updating the model.
04:38:14 <dolio> Of course, that's isomorphic to (exists s. P s) -> (exists s. P s, a) = State (exists s. P s) a
04:39:02 <Zao> As for having to use IO, that's not too horrible as this is rather close to the DLL interface.
04:39:11 <hpc> quicksilver: you end up copying the object though, which may be undesirable
04:39:32 <quicksilver> hpc: there is no more or less copying in (s -> s) than there is if you use IORef s
04:39:35 <kmc> quicksilver, you could have such pure update functions and still call them from IO actions
04:39:58 <quicksilver> hpc: updating an IORef s still involves a new heap object.
04:40:16 <hpc> quicksilver: ah, didn't realize
04:40:30 <kmc> yes, an IORef stores a single pointer into the heap
04:40:36 <quicksilver> the *only* part of an IORef which updates inplace is the magic pointer itself
04:40:48 <quicksilver> the contained data is normal haskell stuff, immutable and shared.
04:42:30 <hpc> depending on the game, you might want objects to be able to perform IO
04:43:34 <quicksilver> that is true.
04:44:03 <quicksilver> I'm making some assumptions of course. But as a general rule a good model for a game is where the game world itself evolves according to rules which make that a pure function.
04:44:14 <ski> .. or they could return instructions in a more restricted interface, which is interpreted
04:44:26 <quicksilver> (possibly including an updated random state)
04:44:45 <quicksilver> a really nice model is one which lets you evaluate it at different time steps and still gives the same result
04:44:52 <quicksilver> so you can interpolate to your actual framerate.
04:45:00 <hpc> oh yes
04:45:23 <hpc> also, the purity lets you run parts of the tick in parallel
04:45:34 <quicksilver> since I don't actually know what Zao is doing I can't really be very useful. But the code smell on that typeclass was wrong :)
04:45:59 <DarkUnicorn> but that won't work if the model needs to interact with other models, right?
04:46:25 <quicksilver> "the model" was supposed to be the entire world
04:46:29 <Zao> quicksilver: That makes two of us that don't know what I'm doing.
04:46:32 <quicksilver> in that sentence.
04:46:34 <DarkUnicorn> oh okay
04:46:36 <quicksilver> Zao++
04:55:46 <ManateeLazyCat> Essential, XMonad/Yi 's hot-swapping still need reboot...
04:55:46 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
05:06:15 <mreh> golfing question, easy way to eliminate the symmetrical elements in the inner product of a list with itself?
05:06:19 <mreh> like with the list monad
05:06:49 <mreh> sorry, "outer product" that should read
05:07:32 <kmc> well, there's filter (not . (uncurry (==)))
05:07:35 <mreh> and when I say eliminate, I mean avoid computing them
05:07:45 <kmc> but that will drop all duplicate pairs, not just the diagonal
05:07:59 <mreh> kmc, maybe you don't understand
05:08:32 <kmc> oh, you want to drop the whole second half?
05:08:33 <mreh> wont that drop the diagonal?
05:08:36 <mreh> yeah
05:10:13 <hpc> :t drop
05:10:14 <lambdabot> forall a. Int -> [a] -> [a]
05:10:35 <hpc> :t fromTail
05:10:36 <lambdabot> Not in scope: `fromTail'
05:10:37 <kmc> > let ps [] = []; ps (x:xs) = [(x,y) | y <- xs] ++ ps xs in ps "abcd"
05:10:38 <lambdabot>   [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
05:10:43 <medfly> @hoogle fromTail
05:10:43 <lambdabot> No results found
05:10:52 <hpc> @hoogle [a] -> [a]
05:10:52 <lambdabot> Prelude cycle :: [a] -> [a]
05:10:52 <lambdabot> Prelude init :: [a] -> [a]
05:10:52 <lambdabot> Prelude reverse :: [a] -> [a]
05:11:11 <ski> > [(a0,a1) | (a0,as) <- select "aba" , a1 <- as]
05:11:12 <lambdabot>   [('a','b'),('a','a'),('b','a'),('b','a'),('a','a'),('a','b')]
05:11:19 <mreh> hoogle has a public http interface
05:11:21 <hpc> @let fromTail f = reverse . f . reverse
05:11:22 <lambdabot>  Defined.
05:11:56 <kmc> indeed it does
05:12:00 <ski> > select "abcd"
05:12:02 <lambdabot>   No instance for (GHC.Show.Show
05:12:02 <lambdabot>                     (m (GHC.Types.Char, [GHC...
05:12:09 <ski> > select "abcd" :: [(Char,String)]
05:12:10 <lambdabot>   [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
05:12:23 <alpounet> hey
05:12:33 <alpounet> is there a function like showHex but for base2 ?
05:13:22 <hpc> :t showHex
05:13:23 <lambdabot> forall a. (Integral a) => a -> String -> String
05:13:26 <ski> > showIntAtBase 2 intToDigit 10 ""
05:13:26 <hpc> :t showBinary
05:13:27 <lambdabot> Not in scope: `showBinary'
05:13:27 <lambdabot>   "1010"
05:13:37 <ivanm> alpounet: see the Numeric module (comes with GHC)
05:13:43 <alpounet> i know
05:13:46 <ivanm> IIRC there's a few functions that let you set the base
05:13:47 <alpounet> showHex comes from there
05:13:50 <alpounet> thanks ski 
05:13:54 <alpounet> that's exactly what i need
05:14:00 <ivanm> @hoogle showIntAtBase
05:14:01 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
05:14:05 <ski> > showIntAtBase 2 intToDigit `flip` "" `map` [0 ..]
05:14:07 <lambdabot>   ["0","1","10","11","100","101","110","111","1000","1001","1010","1011","110...
05:14:11 <ivanm> waddaya know, that was one of the ones I was talking about ;-)
05:14:52 <alpounet> yeah
05:16:22 <ski> mreh : would something like `select' suit you ?
05:16:35 <Phyx-> :t select
05:16:35 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m (a, [a])
05:16:40 <dsssr> I am trying to hide an input to a function from any compiler optimisers for benchmarking purposes.
05:16:41 <Phyx-> hm interesting
05:16:44 <mreh> ski: kmc already showed me a good way
05:16:48 <Phyx-> @hoogle select --info
05:16:49 <lambdabot> Text.Html select :: Html -> Html
05:16:49 <lambdabot>  
05:16:49 <lambdabot> From package html, version 1.0.1.2
05:17:00 <mreh> thanks
05:17:00 <Phyx-> eh
05:17:06 <dsssr> Does anybody know how to hide hard-coded numerical inputs from ghc?
05:17:10 <medfly> I just had the most awesome idea for a Haskell logo
05:17:23 <mreh> rip off the amtrak logo?!
05:17:26 <ivanm> medfly: please don't make us go through another round of voting...
05:17:36 <hpc> > (select [1,2,3]) :: ([(Int, [Int])])
05:17:37 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
05:17:40 <medfly> HASKELL in caps with a lambda for the A, like in half life.
05:17:42 <medfly> hahahaha
05:17:43 <ivanm> dsssr: maybe make it a function?
05:17:51 <ivanm> "foo = const 3" ?
05:18:03 <mreh> @google uncyclopedia haskell
05:18:03 <lambdabot> http://uncyclopedia.wikia.com/wiki/Haskell
05:18:04 <lambdabot> Title: Haskell - Uncyclopedia, the content-free encyclopedia
05:18:05 <ivanm> or else wrap it in {-# NOINLINE foo #-}
05:18:06 <Phyx-> wasn't that in the last round ?
05:18:08 <hpc> http://uncyclopedia.wikia.com/wiki/Haskell
05:18:16 <Phyx-> i've seen it somewhere
05:18:16 <mreh> medfly ^^
05:18:27 <medfly> guess I'm not very original, just remembering uncyclopedia.
05:18:30 <medfly> I found that amusing.
05:18:33 <mreh> :)
05:18:38 <mreh> great minds think alike
05:18:47 <mreh> I reinvented lambda cats
05:18:50 <mreh> X(
05:18:56 <dsssr> ivanm, If it is a function how can I be sure the compiler never looks inside the function?
05:19:07 <ivanm> dsssr: *shrug*
05:19:16 <ivanm> why do you want want to do this though?
05:20:19 <dsssr> ivanm, I want to compare some Haskell code to an implementation in another language and want a fair test
05:20:42 <kmc> it's fair to disable optimizations?
05:20:51 <ivanm> kmc: that's what I was thinking...
05:20:55 <ivanm> STOP READING MY MIND!!!
05:21:05 <dsssr> ivanm, We use a framework to benchmark which makes runtime inputs from environment etc. infeasible
05:21:46 <dsssr> If I disabled optimisations the haskell code would unfairly show up as much slower than it is
05:22:13 <dsssr> I'm comparing some matrix multiplication code to another language
05:22:14 <ivanm> oh, that reminds me: with my fgl naming survey, someone bothered to vote with the comment "Actually don't care, but the form doesn't give me that option!"
05:22:20 <ivanm> if that's the case: why bother voting? :s
05:22:37 <ivanm> dsssr: do you mean stop ghc from optimising away stuff like "foo = sqrt 2" ?
05:22:41 <kmc> ivanm, it's important to be loudly apathetic
05:22:54 <ivanm> heh, fair enough
05:23:01 <aavogt> this is trying to get the compiler to not do any CSE
05:23:16 <ivanm> aavogt: except... I thought GHC didn't do CSE :s
05:23:32 <aavogt> so that your   forever expensiveCalculation   uses cpu
05:23:38 <kmc> this is CSE?
05:23:42 <kmc> sounds like constant folding to me
05:23:53 <aavogt> what's the difference to you?
05:23:55 <ivanm> preflex: seen jaspervdj
05:23:55 <preflex>  jaspervdj was last seen on #haskell 21 hours, 38 minutes and 36 seconds ago, saying: So... I want to run a Haskell script during `cabal configure`. I have found out how to add the hook, but now I'm looking for the best way to call `runghc` from within a Haskell file.
05:24:34 <aavogt> kmc: whether you calculate it at compile time?
05:24:38 <kmc> aavogt, i'm not sure how they're related at all
05:24:39 <dsssr> ivanm, I mean for "res = mmult mat1 mat2" optimise mmult but don't let the optimiser see the values of mat1 and mat2
05:24:43 <kmc> constant folding is compile-time partial evaluation
05:24:44 <ivanm> preflex: seen jaspervdj well, this isn't a new library, it's just a re-write (in the sense that the actual definitions are new, not in what it does; we're still taking a lot of ideas and terminology from the current fgl)
05:24:44 <preflex>  jaspervdj was last seen on #haskell 21 hours, 39 minutes and 25 seconds ago, saying: So... I want to run a Haskell script during `cabal configure`. I have found out how to add the hook, but now I'm looking for the best way to call `runghc` from within a Haskell file.
05:24:59 <ivanm> dsssr: {-# NOINLINE res #-}
05:25:03 <ivanm> ^^ I think that's what you want
05:25:41 <aavogt> kmc: they are related because you take a repeatedly calculated value and make that happen once
05:26:13 <dsssr> ivanm, ok. Thanks. I'll go and RTFM for NOINLINE. Hopefully it'll help
05:26:28 <ivanm> @google ghc noinline pragma
05:26:29 <lambdabot> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/pragmas.html
05:26:30 <lambdabot> Title: 7.13.�Pragmas
05:26:31 <aavogt> so if you don't care about implementation details, they are rather similar
05:26:38 <pozic> How can I uninstall the ghc installed in /usr/local/bin?
05:27:36 <Eduard_Munteanu> pozic: tough luck, use package manager next time if there's no 'make uninstall' :)
05:27:38 <dsssr> cheers
05:28:04 <pozic> Eduard_Munteanu: I am pretty sure I installed it via the generic x86 GHC release.
05:28:27 <pozic> Eduard_Munteanu: if there is no way to undo the damage done by this installer, then the installer sucks. 
05:28:32 <Eduard_Munteanu> pozic: I'm not sure that's a good idea either.
05:28:49 <Jafet> find /usr/local -name "*ghc*" -execdir rm '{}' \;
05:28:50 <Eduard_Munteanu> pozic: what distro is that?
05:29:00 <Jafet> Well, that's how I upgraded.
05:29:03 <Eduard_Munteanu> Won't that miss at least some files?
05:29:06 <ivanm> there's things like stow, etc. for manually instaling stuff in /usr/local
05:29:14 <pozic> Eduard_Munteanu: what you are not sure of is not really interesting. 
05:29:26 <Eduard_Munteanu> Yeah, or checkinstall.
05:29:31 <ivanm> but I've had problems where I have my own GHC install, but if I build a new version then I can't remove the old one when I want to do "make install" for the new one :s
05:29:39 <Eduard_Munteanu> pozic: you know what I meant.
05:30:15 <aavogt> pozic: well did you see if the script you used to copy the files has an option to remove them?
05:30:23 <Eduard_Munteanu> Really now, people, if you don't use proper package management, just install the stuff under a different prefix, like ~/apps/ghc
05:30:31 <pozic> aavogt: I installed this GHC years ago. 
05:30:42 <pozic> aavogt: I don't even know whether I still have it. 
05:31:05 <pozic> Eduard_Munteanu: /usr/local/bin _is_ a different prefix. 
05:31:33 <Eduard_Munteanu> pozic: I mean different prefix than /usr/local. If you're content with deleting /usr/local completely, then go ahead.
05:31:48 <Eduard_Munteanu> pozic: that should work if you didn't install something else there.
05:32:35 <medfly> does Haskell have ok crypto libs? I wonder.
05:32:39 <Eduard_Munteanu> pozic: I usually install such stuff under my home directory in a separate dir for every app or group of apps. That way I can simply rm -rf it.
05:33:15 <ivanm> medfly: define "OK"; IIUC the current emphasis is to split the Crypto package up into separate libraries
05:33:37 <pozic> aavogt: there is no such deinstallation target. 
05:33:55 <pozic> Eduard_Munteanu: ok, that's a way to work around bad installers.
05:34:02 <pozic> (which it seems GHC has)
05:34:03 <medfly> I want to do something, I don't know much about cryptography, friend said it'd be a pain in the ass to debug if something goes wrong using a crypto lib.
05:34:06 <medfly> that is all/
05:34:14 <Eduard_Munteanu> pozic: how was it installed? I'm not really sure about GHC's build system itself, does it work with "make install"?
05:34:28 <Eduard_Munteanu> If so, and it uses autoconf, then "make uninstall" should do.
05:34:53 <pozic> Eduard_Munteanu: I have the impression you don't know a lot about GHC.
05:35:09 <pozic> Eduard_Munteanu: that doesn't matter, but don't communicate as if you do, please.
05:35:12 <Eduard_Munteanu> pozic: that's accurate :)
05:35:35 <ManateeLazyCat> ivanm: You suggest me use hint for my hot-swapping feature, but i don't understand how can hint will help me? Runnint all gtk2hs code in interpreter?
05:35:43 <Eduard_Munteanu> pozic: well I know something about common practices when it comes to package management.
05:35:52 <ivanm> ManateeLazyCat: no, I suggested you use hint if you wanted an interpreter
05:36:08 <pozic> I will just go with a hacky solution, for now and remember that GHC doesn't have an actual working uninstaller in the normal release. 
05:36:16 <ivanm> for hot-swapping, doing the xmonad approach is probably your best bet (compile and serialise state to new version)
05:36:22 <aavogt> does gtk2hs code even work correctly in ghci?
05:36:45 <ManateeLazyCat> aavogt: Now have some GC bug with ghc-6.12.1 or ghc-6.12.3
05:36:51 <ivanm> doesn't for me, but that's because of static linker scripts :@
05:36:53 <ivanm> ManateeLazyCat: :o
05:36:57 <Eduard_Munteanu> pozic: is it a binary, non-distro-specific release?
05:36:58 <msieradzki> is it possible to extend cabal so gtk2hs would download correct libs
05:37:01 <msieradzki> on windows
05:37:07 <ivanm> no
05:37:18 <msieradzki> inconvenient :)
05:37:20 <ivanm> not the C gtk libs, anyway
05:37:35 <ivanm> @google cabal is not a package manager
05:37:35 <lambdabot> No Result Found.
05:37:38 <ivanm> grr...
05:37:41 <ivanm> stop lying!
05:37:42 <msieradzki> :>
05:37:47 <ivanm> msieradzki: http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
05:38:05 <ManateeLazyCat> ivanm: I was re-read "Plug Haskell In" and "Dynamic Application From the Group Up", anyway i don't like re-compile solution.
05:38:12 <msieradzki> tl;dr
05:38:15 <pozic> ivanm: what is the purpose of Cabal?
05:38:19 <ManateeLazyCat> ivanm: It's will lost state after i re-compile plugin.
05:38:28 <Eduard_Munteanu> pozic: because if it is a source release, it's probably okay not to be able to uninstall.
05:39:01 <Eduard_Munteanu> It's actually the cabal command (install) and it doesn't do uninstalls either :)
05:39:06 <pozic> Eduard_Munteanu: I "solved" my problem. Thanks, for trying.
05:39:10 <ivanm> pozic: Cabal is used to build packages, specify deps, etc.
05:39:29 <aavogt> it even grabs dependencies for you
05:39:34 <ivanm> msieradzki: sorry, most things can't be fit into a single twitter message for lazy people like you
05:39:37 <Eduard_Munteanu> aavogt: some
05:39:38 <ivanm> aavogt: no it doesn't
05:39:40 <ManateeLazyCat> msieradzki: What do you mean "download correct libs" ? It can't ?
05:39:42 <ivanm> cabal-install does, Cabal doesn't
05:39:51 <ivanm> ManateeLazyCat: "cabal install gtk" will not get the C libraries
05:39:55 <Eduard_Munteanu> Well I suppose we were talking about cabal install anyway
05:40:00 <msieradzki> you know what I meant
05:40:09 <ManateeLazyCat> ivanm: Oh, I guess he want Window Binary package?
05:40:22 <aavogt> ivanm: you know the two are very closely related... to the point that they have the same name
05:40:25 <ivanm> ManateeLazyCat: yup
05:40:41 <ivanm> aavogt: no they don't; one is called Cabal, the other is called cabal-install
05:40:46 <ivanm> one uses the other
05:40:48 <ManateeLazyCat> msieradzki: Possible, but noone work on it, Unfortunately. :)
05:41:04 <ivanm> what was that new cygwin-like effort based upon msys or something?
05:41:11 <ManateeLazyCat> msieradzki: Currently, you need downlod/install C library before install gtk2hs.
05:41:21 <msieradzki> just whining because I installed libs and it failed
05:41:38 <msieradzki> + when doing cabal isntall gtk2hs it "crashes" on lack of gtk2hs-buildsomething
05:41:42 <msieradzki> just small annoyancve
05:41:45 * Eduard_Munteanu keeps forgetting -dev packages exist, Gentoo has that effect :)
05:41:57 <ivanm> msieradzki: yes, because cabal-install can't get the build-tools for you
05:42:08 <ivanm> because there's no obvious mapping from a build-tool name to the package it's in
05:42:12 <ivanm> Eduard_Munteanu: yeah ;-)
05:42:12 <ManateeLazyCat> msieradzki: You need do "cabal install gtk2hs-buildtools gtk"
05:42:31 <ManateeLazyCat> msieradzki: Because gtk2hs-buildtool is build-tools not library.
05:42:45 <ManateeLazyCat> msieradzki: So cabal-install can't install gtk2hs-buildtool for you.
05:42:49 <msieradzki> how am I supposed to know that
05:42:52 <msieradzki> what is a build-tools?
05:43:01 <Eduard_Munteanu> msieradzki: you're not, use a package manager then
05:43:09 <msieradzki> on Windows?
05:43:18 <Eduard_Munteanu> Tough luck again.
05:43:40 <ManateeLazyCat> msieradzki: build-tools is some tools use in gtk2hs for generate Types/Hierarchy information for GTK+
05:43:42 <Eduard_Munteanu> msieradzki: maybe there's a larger Haskell distribution then.
05:44:21 <Eduard_Munteanu> I'm sorry, but package management isn't something that will automagically go away over time, or on other OSes.
05:44:29 <ManateeLazyCat> msieradzki: First make such C library has installed and "~/.cabal/bin" in your PATH environment variable, then do "cabal install gtk2hs-buildtools gtk"
05:45:04 <ivanm> ManateeLazyCat: he's using windows... ;-)
05:45:22 <ManateeLazyCat> ivanm: I think Windows can use Cabal install package, right?
05:45:32 <ivanm> yes, but doing ~/.cabal/bin won't work ;-)
05:45:33 <msieradzki> usually I use Windows but I'd like to have my package buildable on Windows with Gtk
05:45:39 <Eduard_Munteanu> Heh :)
05:45:44 <ivanm> msieradzki: build-tools is a field in a packages' .cabal file that tells Cabal which extra tools it needs to build the package
05:45:54 <ManateeLazyCat> ivanm: I guess he will know my mean about "~/.cabal/bin" . :)
05:46:11 <Eduard_Munteanu> C:\Program Files ? :)
05:46:29 <msieradzki> it's AppData/Local/.cabal I think
05:46:33 <msieradzki> not that it matters
05:46:34 <ivanm> C:\user\<something>
05:47:05 <ivanm> msieradzki: have a look at TakeoffGW: http://sourceforge.net/apps/mediawiki/takeoffgw/index.php?title=Main_Page
05:47:17 <ManateeLazyCat> msieradzki: When you do "cabal install gtk", it will call gtk2hs-buildtools to generate Type.hs/Signal.hs with hierarchy.list/marshal.list, then it will compile other module with Types.hs/Signal.hs
05:47:18 <Eduard_Munteanu> I wonder if it isn't easier to just install a Cygwin environment or something like that.
05:47:37 <ivanm> Eduard_Munteanu: that's what Takeoff is, but using mingw
05:47:54 <msieradzki> why does cabal-install use 1 compilation thread?
05:47:58 <Eduard_Munteanu> ivanm: ah, that works too. Not sure if it gives you a nice bash console though.
05:48:18 <msieradzki> ivanm any reason not to use full cygwin in such case?
05:48:20 <ivanm> msieradzki: because no-one's bothered to work out how to get GHC to build modules in parallel yet
05:48:36 <msieradzki> but I'm mostly interested how to build it so I can package an installer
05:48:38 <ivanm> msieradzki: most people prefer to use mingw because its smaller and cygwin isn't updated much anymore IIRC
05:48:40 <msieradzki> and give it to someone
05:48:48 <msieradzki> packaging cygwin sucks
05:49:10 * ManateeLazyCat pasted "hint play" at http://paste2.org/get/915612
05:49:10 <ManateeLazyCat> ivanm: I have play hint with some haskell script like above, very cool. But i doubt it will help gtk2hs code, looks running gtk2hs in interpreter will too slow. 
05:49:22 <Eduard_Munteanu> Last time I checked it was lagging a quite a bit behind on package versions.
05:50:12 <msieradzki> I'm not sure if it's ok
05:50:15 <ManateeLazyCat> msieradzki: Maybe you can keep us build Windows package?
05:50:19 <msieradzki> but I have gtk installed and don't have buildtools
05:51:12 <ManateeLazyCat> msieradzki: buildtools under cabal bin directory with three execute file : gtk2hsC2hs gtk2hsHookGenerator gtk2hsTypeGen.
05:51:18 <msieradzki> about distribution's package manager: it usually goes all wrong when new debian package with GHC gets released
05:51:29 <msieradzki> base libs get new hashes and all have to be recompiled or reinstalled
05:52:09 <ManateeLazyCat> msieradzki: Yep, special gtk2hs, once you touch glib, you need re-compile all glib base libraries.
05:53:15 <ManateeLazyCat> ivanm: From currently situation, Hot-Swapping Core is pretty easy, i won't lost any state, but hot-swapping plugin is trick, special with network plugin.
05:56:22 <ManateeLazyCat> ivanm: I found some Erlang guy use "server state process" solution, keep state in standalone process, any action in running in client process, you can re-compile/reboot client process, and continue work with "server state process".
05:59:38 * ManateeLazyCat Okay, i know i'm crazy.... #emacs #haskell #ghc noone answer me... 
05:59:50 <medfly_> I am here.
05:59:52 <medfly_> not crazy!
06:00:50 * ManateeLazyCat I'm looking for a hot-swapping way that not need re-compile....
06:01:02 * ManateeLazyCat Maybe it's wrong, but i need have a try......
06:05:59 <Zeiris> What's big-O complexity of pattern matching functions?
06:06:19 <Zeiris> (IE how dumb is it to have loooong, 130+ case pattern matches?)
06:07:40 <Zeiris> And on a related note, I want to load some data from text files/data base, which is 'pure' since it might change once every year at most, and comes with the program. What's the right way to use unsafePerformIO in this case?
06:08:21 <ski> each match in itself is a constant-time operation .. however the matching may cause the forcing of thunks which may be more expensive
06:08:57 <ski> (btw, when you introduce guards (or pattern guards, or view patterns), this is no longer the case)
06:09:40 <ClaudiusMaximus> cases are defined to execute in a certain order i think, to handle overlaps - some tree-like structure instead of a list might be more efficient if you have a lot
06:09:46 <kmc> Zeiris, it depends on the patterns
06:10:07 <kmc> matching a single layer of an algerbaic data type and dispatching based on which constructor was used should be constant-time
06:10:27 <kmc> GHC will offset into a table of code pointers
06:10:39 <kmc> but if you have more complicated nested patterns, they'd require more steps
06:10:51 <kmc> or if you have overlap, or guards, or view patterns
06:11:05 <ski> still bounded by the size of the patterns, though (barring guards, pattern guards, view patterns)
06:11:17 <Zeiris> Makes sense.
06:11:42 <ski> (well, and matching against numeric literals too, i suppose .. `n+k' ?)
06:11:45 <ClaudiusMaximus> with the unsafeperformio stuff, maybe compile the database to a .o file that you can link with and use foreign import - that way all the unsafeIO stuff is just pointer manipulation instead of real disk IO
06:11:52 <yitz> Zeiris: that would actually be interesting to try, and get some empirical results
06:12:07 <yitz> ski: n+k is dead!
06:12:44 <ski> yitz : yes ?
06:12:58 <yitz> in haskell2010 it's out
06:13:07 <yitz> finally
06:13:08 <ski> (i can't recall how they're implemented)
06:13:42 <flazz> i'm stuck in an infinite loop while debugging in ghci, how can i interrupt it without killing it, ^C does not work
06:13:44 <flazz> ?
06:14:00 <dolio> ski: I think it uses from/toInteger, so it could conceivably be expensive.
06:15:24 <yitz> flazz: ^C usually does work. there are certain operations that delay the response though. and often enough in that case ghci is busy feasting on all of your memory, in which case the entire machine stops responding promptly.
06:16:16 <yitz> flazz: i usually wait for about 30 seconds (checking on memory usage in the meantime), then give up and kill ghci.
06:16:24 <flazz> i'll wait a bit
06:16:37 <yitz> if i find memory going down the drain, i kill ghci quickly.
06:17:11 <flazz> i'm down to 12.5 free
06:17:19 <yitz> oh-oh...
06:17:27 <yitz> 12.5 what?
06:17:40 <flazz> 12.5MB sorry
06:17:51 <yitz> yikes. i'd kill it
06:19:37 <flazz> now i have like 1.5GB free :) this haskell code is so fast you can't even interrupt it
06:19:38 <flazz> :)
06:19:48 <yitz> heh
06:21:41 <ManateeLazyCat> flazz: Normal... :)
06:22:06 <ManateeLazyCat> If you haven't 2GB RAM, don't play ghc. :)
06:23:18 <arw> you could do ulimit -m $something
06:23:40 <arw> that prevents all processes started from that shell to get more resident memory than $something.
06:25:05 <arw> there are also some other handy ulimits. just look at ulimit -a and then adjust to your liking.
06:25:29 <arw> (but most software dies when hitting an ulimit, so be careful and don't do it globally)
06:30:54 <kuribas> If I use a readDocument arrow in HXT, doesn't mean that it will read the file everywhere the arrow is used?
06:32:11 <kuribas> s/doesn't/does it/
06:34:16 <gghink> newbie question:  I just used the Haskell installer package on Mac OS X.  Can someone tell me where it installs, so I can set my path?   
06:34:34 <flazz> i think the path is set by the installer
06:40:41 <kuribas> Can you bind the result of an Arrow to a variable, as in Monads?
06:41:59 <ski> yes, using the arrow `do'-notation
06:42:34 <kuribas> Not in pure haskell?
06:42:48 <kmc> err, what's "pure haskell"?
06:43:00 <ski>   proc x -> do y <- foo -< x; z <- bar -< (x,y); returnA -< (x,z)
06:43:01 <ski> e.g.
06:43:02 <pokoko222> lot of cs guys here, you study software processes subject in college?
06:43:02 <kmc> kuribas, the arrow "do", like the monad "do", is just syntactic sugar for some ordinary operators
06:43:19 <kmc> kuribas, although the translation for arrows is a lot more complex than the translation for monads
06:43:30 <kuribas> kmc: yes
06:44:46 * kmc is not a huge fan of Arrows
06:45:00 <kmc> perhaps it's just that i've never used them much, and i'm missing what makes them powerful
06:45:48 <kuribas> kmc: Me neither :) I have to use them because HXT works that way.
06:46:41 <kmc> mm
06:46:48 <kmc> HXT and some of the FRP libraries are the only users i know of
06:47:10 <kmc> i've often written a type which is *almost* an Arrow, but fails in some way
06:47:15 <kmc> usually that i can't implement arr
06:47:23 * ski . o O ( Swierstra-Duponcheel )
06:47:41 <kmc> deterministic error-correcting combinator parsers?
06:47:50 <ski> possibly
06:48:01 <zygoloid> kmc: yeah, arr shouldn't be in Arrow.
06:48:22 <zygoloid> or at least there should be some middle level without it
06:48:33 <zygoloid> trouble is most of the default members in Arrow use it
06:48:59 <zygoloid> actually proc notation uses it too ;(
06:49:47 * kuribas realises he can use the use state of HXT instead of variable binding :)
06:50:05 <kuribas> user state even
06:51:17 <kjdf> is it possible to wrap functions in ST monad in 'Dynamic'?
06:51:21 <edwardk> kmc: welcome to discovering CCC's that aren't arrows ;)
06:51:23 <kjdf> http://paste.lisp.org/display/112510
06:51:46 <kjdf> to somehow make the commented out "typeOf" work
06:51:50 <edwardk> kmc: feel free to use control.category.cartesian and control.category.cartesian.closed to describe your arrow-like construct =P
06:51:52 <aristid> edwardk: CCCs?
06:52:07 <aristid> oh Control.Category.Category
06:52:13 <kmc> cartesian closed category
06:52:29 <zygoloid> hmm,  thArr :: ExpQ -> ExpQ  might help
06:52:35 <aristid> but Control.Category.Category also can be abbreviated with CCC :P
06:52:36 <kmc> edwardk, nice, unfortunately it doesn't come with proc syntax :/
06:52:50 <aristid> kmc: proc syntax is unreadable anyways :P
06:53:02 <edwardk> proc is overrated ;)
06:53:09 <edwardk> feel free to write me a quasiquoter though ;)
06:54:01 * Warrigal ponders whether there's a continuous function whose derivative is unbounded on every open set.
06:54:06 <kmc> not if you ← write it ⤙ like this
06:54:22 <kmc> ;)
06:54:27 <exDM69> can someone explain quasiquotation for me? I'm familiar with quote an unquote (' and ,) in lisp. quasiquote is ` in many lisps, right? what does it do?
06:54:36 <EvanR-work> ⤙ whats this
06:54:43 <kmc> an arrow tail EvanCarroll 
06:54:44 <kmc> err
06:54:45 <kmc> EvanR, 
06:54:56 <kmc> proc syntax uses "foo <- bar -< baz"
06:55:08 <kmc> which is supposed to look like "foo <---< baz" where the arrow is labeled "bar"
06:55:08 <EvanR-work> ah
06:55:10 <kmc> exDM69, it allows you to "unquote" within a quote
06:55:16 <zygoloid> exDM69: quasiquotation grabs some input as a string and runs it through a supplied function at compile time to generate a TH code fragment
06:55:36 <kmc> `(foo bar ,(2 + 3) baz)  evaluates the same as (quote (foo bar 5 baz))
06:55:37 <Saizan> can't you use lambda calculus for CCCs?
06:55:47 <zygoloid> exDM69: so [$foo|hello world|] is sugar for something very much like $(foo "hello world")
06:55:53 <kmc> exDM69, what quasiquote means in Haskell is a bit different
06:56:00 <kmc> sometimes people mean the ordinary Template Haskell quotations
06:56:07 <kmc> [| 2 + 3 |] :: Q Exp
06:56:14 <kmc> and sometimes they mean the newer QQ feature
06:56:26 <kmc> exDM69, which is described at http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/template-haskell.html#th-quasiquotation
06:56:39 <kmc> and in the paper linked therefrom
06:56:40 <zygoloid> exDM69: (foo is actually a value containing two functions, depending on whether the quasiquotation is used in an expression context or a pattern context)
06:56:54 <ski> kjdf : what are you trying to do ?
06:57:00 <exDM69> kmc: zygoloid: cool, thanks guys. I really don't know template haskell so I don't quite get it but I have an idea what it does
06:57:11 <kmc> exDM69, if you read the paper you'll see some cool use cases at least
06:57:18 <CalJohn_> When I run "someBinary +RTS -hd" I get "someBinary: invalid heap profile option: -hd".  This flag is listed in the manual for my version of ghc.  What am I doing wrong?
06:57:34 <kmc> CalJohn_, did you build with ghc -prof ?
06:57:39 <exDM69> kmc: perhaps I need to take a look at some template haskell basics first?
06:57:44 <kmc> exDM69, could help
06:57:48 <kjdf> ski: I want to wire together functions like this automatically
06:57:52 <kjdf> ski: with genetic programming
06:58:07 <kjdf> ski: in general they may operate on some state, that's why i am trying ST monad
06:58:12 <kmc> kjdf, perhaps you need a (Typeable s) => constraint on bump.  but then you can't pass it to runST
06:58:26 <zygoloid> exDM69: a very high level approximation: write [| ... |] to quote, $( ... ) to unquote
06:58:34 * ski is not sure why `Dynamic' would be wanted at all, here ..
06:59:01 <kmc> kjdf, perhaps you want to write "typeOfST :: (Typeable a) => ST s a -> TypeRep"
06:59:03 <kjdf> the functions may have different types in general, at least varying arity
06:59:04 <illissius-> <kmc> which is supposed to look like "foo <---< baz" where the arrow is labeled "bar" --- oh! that's nice to know... like probably most people i thought it was just "hmm what's an arrow-like operator we can take that's not <-... how about -<"
06:59:29 <CalJohn_> kmc: yes, I have (used cabal's --enable-library-profiling configure flag)
06:59:29 <quicksilver> exDM69: actually you don't need to understand TH to understand haskell QQ>
07:00:02 <quicksilver> exDM69: QQ solves this problem: Suppose you have a complex AST, like data Expr = Num Int | Add Expr Expr | Times Expr Expr
07:00:11 <ski> @type typeOf1
07:00:12 <lambdabot> forall (t :: * -> *) a. (Typeable1 t) => t a -> TypeRep
07:00:24 <kmc> hmm
07:00:37 <quicksilver> exDM69: it becomes quite painful and ugly to write expressions as Add (Add (Times (Num 1) (Num 2)) (Add .....
07:00:37 <kmc> > typeOf1 (return :: ST s ())
07:00:39 <lambdabot>   Couldn't match expected type `GHC.ST.ST s ()'
07:00:39 <lambdabot>         against inferred type...
07:00:44 <kmc> > typeOf1 (return () :: ST s ())
07:00:46 <lambdabot>   Ambiguous type variable `s' in the constraint:
07:00:46 <lambdabot>    `Data.Typeable.Typeable s...
07:00:50 <kmc> > typeOf2 (return () :: ST s ())
07:00:51 <lambdabot>   ST
07:01:32 <quicksilver> exDM69: ... and also to use them to pattern match, e.g. for writing an optimiser. QQ lets you define a custom syntax, which you can use in values as well as in patterns
07:01:39 <quicksilver> exDM69: i.e. on both sides of a definition.
07:02:02 <quicksilver> E.g. [$arith| 1+2*3]
07:03:26 <exDM69> quicksilver: that is very cool, I've had the same exact problem with AST's
07:04:09 <kmc> yeah.  i like the example in the paper of writing compiler back-end optimizations by pattern matching over quasiquoted fragments of assembly code
07:04:40 <hugo> inline assembly for ghc ?
07:04:53 <hugo> assembly + haskell :D the perfect match
07:05:05 <hugo> true low-level + true high-level
07:05:14 <hugo> = nirvana
07:05:34 <kmc> hugo, the LLVM bindings are already nice for this
07:05:41 <exDM69> someone released an inline assembler haskell DSL recently
07:05:52 <exDM69> looked very neat
07:06:00 <fasta> harp is quite old already. 
07:06:04 <kmc> dynamically generating, compiling, and linking code
07:06:18 <exDM69> LLVM can be used to do that trick too
07:06:25 <kmc> yeah that's what i referred to
07:06:38 <exDM69> yeah, I got your point
07:08:26 <exDM69> using the haskell LLVM package seemed to be very nice for doing some DSL stuff but I don't know how would one use that library to make a compiler back end, ie. constructing the SSA at runtime
07:10:33 <astroboy> god, compiling ghc on a netbook was a bad idea, it has been there for 2 hrs now
07:10:48 <astroboy> I mean it's been compiling for two hrs
07:11:18 <MHD0> What kind of weird things is also monads? I mean, we have single value monads Just and IO and Either, List and Logic monads for multiple values, State/Reader/Parser/Cont got function composition going on behind the scenes and Writer has the side tracking value. What else?
07:13:37 <hugo> Monad Me
07:13:41 <quicksilver> I think function composition is selling Cont short, a bit.
07:14:07 <MHD0> quicksilver: Yeah i know, but in general terms, every bind makes a new function
07:14:13 <ski> `Either e' is not "single value"
07:14:16 <quicksilver> Somebody made some statement about all monads directly expressible in haskell being isomorphic to combinations of Cont and State
07:14:34 <quicksilver> I'm not sure what the correct precise statement is though.
07:14:37 <ski> quicksilver : probably Filinski ?
07:14:37 <noteed> MHD0: Strategies for parallel computations is done with a monad
07:14:38 <MHD0> ski: Understand what I am saying, not what I write :P
07:14:49 <MHD0> noteed: Cool
07:15:04 <ski> MHD0 : why don't you write what you mean ?
07:15:13 <quicksilver> "Either e" is 0-or-1 values of the contained type, like Maybe, which I assume is what MHD0 meant.
07:15:14 <MHD0> ski: Lazy :P
07:15:17 <quicksilver> ski: too hard. Much too hard.
07:15:32 <noteed> MHD0: if you're interested: Seq no more: Better Strategies for Parrallel Haskell, Simon Marlow et al.
07:15:40 <kmc> MHD0, some interesting monadic libraries include parsers, code generation (e.g. LLVM), transactional concurrency (STM), quantum computation, logic programming
07:16:21 <noteed> MHD0: xmonad has an ... x monad
07:16:25 <ski> (quicksilver : i know .. but one can at least try)
07:16:41 <MHD0> kmc: I'm familiar with logic in the form of List and Parsers which are just an ErrorT State, but code generation sounds interesting.
07:16:53 <kmc> MHD0, they're not *just* those things
07:17:03 <kmc> parsers are usually nondeterminsitic too
07:17:10 <noteed> MHD0: constraint programming
07:17:22 <MHD0> kmc: You can get pretty decent result like that :P
07:17:31 <kmc> yeah, there's monads for building problems to hand off to a SAT solver
07:17:31 <MHD0> noteed: Oooh, shiny
07:17:34 <kmc> satchmo
07:17:42 <quicksilver> but the monadic parts of the LLVM monad are in fact just combinations of the above
07:17:45 <MHD0> This is soo cool
07:17:53 <quicksilver> at least they can be expressed thus.
07:18:11 <quicksilver> the interesting part of a monad isn't necessarily the monadic part.
07:18:23 <noteed> MHD0: oh a nice one : the GRIN language is monadic
07:18:44 <quicksilver> Or, rather, given an interesting type with interesting combinators, the fact that it happens to have a monad instance may be a very small part of the interest.
07:18:48 <kmc> quicksilver, yeah
07:19:13 <quicksilver> and the monad instance may well reduce in a pretty obvious way to State + Either : but the type as a whole is more than that.
07:19:25 <MHD0> quick silver: I know, monads are but useless in and off themselves 
07:21:12 <noteed> I'm making an expression parser library. It supports infix, prefix, postfix and closed operators, each with possibly multiple internal holes.
07:21:30 <tafryn> I'm trying to get a handle on how getOpt works. Would someone please help me to understand what line 4 of this example, http://dpaste.com/218451/, is doing?
07:21:42 <noteed> I'dont know the rules of precedence/associativity for mixing, say, infix and postfix
07:22:19 <kmc> tafryn, do you know what «foldl (>>=)» does in general?
07:22:27 <aristid> :t foldl (>>=)
07:22:28 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
07:22:34 <noteed> If + is infixl 5 and ! is postfix 5 and associative, what should 1 + 2 ! parse to?
07:22:42 <quicksilver> noteed: parse error
07:22:46 <quicksilver> (in my opinion)
07:22:52 <aristid> :t foldl (>>=) . return
07:22:53 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
07:23:00 <quicksilver> mixture of fixities should only be legal if one binds stronger than the other.
07:23:02 <tafryn> I'd say I have an ok understanding of foldl and an inadequate understanding of (>>=).
07:23:04 <noteed> quicksilver: but ! is associative!
07:23:20 <kmc> tafryn, (x >>= f) is do { y <- x; f y }
07:23:23 <quicksilver> noteed: what do you mean?
07:23:27 <kmc> indeed "do" is syntactic sugar for that
07:23:33 <quicksilver> noteed: (associativity is a property of binary operators, not unary ones)
07:23:46 <kmc> tafryn, (>>=) is the most important part of the API we call "Monad"
07:23:54 <noteed> quicksilver: this page is weird, but doesn't say so... http://en.wikipedia.org/wiki/Common_operator_notation
07:24:48 <quicksilver> noteed: I have no idea what that page means.
07:25:00 <kmc> noteed, you could read some of the papers about parsing Agda
07:25:03 <quicksilver> I ask the question again: what would it mean for a postfix operator to be associative.
07:25:05 <kmc> noteed, it has arbitrary mixfix operators
07:25:20 <kmc> anyway,  «foldl (>>=) (return x) [a,b,c]» is «return x >>= a >>= b >>= c»
07:25:31 <tafryn> kmc: So it extracts y from x and runs f on y. Doesn't f have to return another Monad?
07:25:32 <quicksilver> haskell complains if you mix infixl and infixr with the same precedence, but permits it if one binds tighter than the other.
07:25:41 <quicksilver> I think that's very sensible, personally
07:25:41 <noteed> kmc, yes I saw it, should check it out (I completely forgot)
07:25:49 <quicksilver> (and I'd expand that to prefix + postfix)
07:25:55 <noteed> quicksilver: yes
07:25:58 <kmc> which means it's «do { vx <- return x; va <- a vx; vb <- b va; c vb }»
07:26:11 <aristid> @undo do { vx <- return x; va <- a vx; vb <- b va; c vb }
07:26:11 <lambdabot> return x >>= \ vx -> a vx >>= \ va -> b va >>= \ vb -> c vb
07:26:21 <kmc> tafryn, you don't "return a monad".  monads aren't values.  monads are type constructors.  IO is a monad, so is Maybe.  (Just 3) is not a monad
07:26:46 <noteed> quicksilver: the wikipedia page is weird: they say an prefix or potsfix operator is associative if it can compete with an operator of the same precedence, but doesn't say which one wins
07:26:54 <kmc> tafryn, anyway, yes.  f has to return another monadic value
07:26:59 <kmc> because of the type of (>>=)
07:27:02 <quicksilver> noteed: yes. As far as I know that's non-standard.
07:27:07 <tafryn> kmc: What's the proper term for a thing that has been constructed by a Monad?
07:27:13 <noteed> quicksilver: ok, thanks
07:27:14 <kamatsu> monadic value?
07:27:34 <kmc> tafryn, i would say "x is a monadic value" iff x :: M a, and M is a monad
07:27:41 <kmc> that is, M is an instance of the type class which is named "Monad"
07:28:15 <tafryn> understood
07:28:28 <kmc> (i capitalize Monad to refer to the type class itself, because that's how it's spelled in Haskell.  but i don't capitalize it otherwise)
07:28:29 <noteed> quicksilver: you would thus say that a prefix or postfix operator has no associativity (nor non-associativy) ?
07:28:59 <kmc> tafryn, sometimes people say "pure value" to be the opposite of "monadic value", but i think this is wrong and misleading.  because most ideas of "purity" have to do only with the IO monad, and not other monads
07:29:00 <Saizan> noteed: maybe you could check what prolog does :)
07:29:25 <noteed> Saizan: ok, didn't think of it
07:29:27 <kmc> it's silly to say that 'x' is "pure" but (Just 'x') is impure and "monadic" just because Maybe happens to be an instance of Monad.  you might not even be using that fact.
07:29:43 <quicksilver> noteed: that is what I would say, yes.
07:29:47 <tafryn> kmc: So something could be considered "pure" and still involve Maybe a, etc.
07:29:51 <noteed> quicksilver: ok
07:29:54 <kmc> furthermore IO actions are "pure" too -- they have no special behavior when evaluated
07:30:23 <quicksilver> kmc: somehing of the form (a -> m b) is a pure function from "a" to "m b", but it's impure considered as a function from "a" to "b"
07:30:27 <quicksilver> that's the point, I think.
07:30:47 <kmc> it's impure considered as something it's not ;P
07:30:59 <quicksilver> I disagree.
07:31:09 <quicksilver> It is a perfectly good model
07:31:23 <quicksilver> function a -> m b are, indeed, "impure functions" a -> b in a different model.
07:31:35 <tafryn> So it's the crossing from m b to b or vice versa that triggers the "impure" flag?
07:31:41 <quicksilver> different model - a model which admits impurity, no less - but still a model.
07:32:11 <quicksilver> if you object to function, call it a computation, by all meads.
07:32:21 <quicksilver> a function "a -> m b" is a computation "a ~~> b"
07:32:24 <kjdf> if anyone's interested, I am now convinced it's not possible to do what I wanted, and Typeable2 for ST doesn't make much sense (at least in library api, i don't if it's used for anything wrt. IO)
07:32:27 <kjdf> http://www.mail-archive.com/haskell-cafe@haskell.org/msg55999.html
07:32:38 <zygoloid> a -> IO b is just a function in the Kleisli category for IO (that is, in a haskell-with-side-effects world)
07:32:48 <zygoloid> *a function a -> b
07:33:19 <kmc> kjdf, i'm not clear exactly on what you wanted to do
07:33:40 <kmc> kjdf, you can definitely write «typeOfST :: (Typeable a) => ST s a -> TypeRep»
07:34:34 <quicksilver> zygoloid: yes, that's what I said isn't it?
07:35:12 <quicksilver> of course, to my mind "impure function" is an oxymoron, which is why I granted it scare quotes, but nomenclature is not entirely standard there.
07:35:25 <kjdf> kmc: if I ignore s?
07:35:26 <ski> a pure function from `a' to `m b' corresponds to a (potentially) impure function in the kleisli category of `m'
07:36:03 <ski> (feel free to s/function/morphism/ if you prefer)
07:36:39 <quicksilver> yes.
07:36:41 <tafryn> kmc: Getting back to the example, that fourth line is foldl-ing >>= over the defaultOptions record?
07:36:43 <ski> tafryn : it's also the concrete syntax used
07:38:44 <jmcarthur> i hate how game architecture nowadays is basically to use an OOP language and make a functional design
07:39:02 <tafryn> Oh! I think I see it.
07:39:21 <kmc> kjdf, right, given an "ST s a" value, you can get the TypeRep of a
07:39:50 <ski> tafryn : you could easily make a syntactic translation from an impure language to one that is pure, but employs monadic operations
07:39:59 <kmc> jmcarthur, functional programming just isn't practical for the real world ;P
07:40:11 <kmc> ;)
07:40:45 <kjdf> kmc: but I need the whole type of the function
07:41:18 <kmc> kjdf, well, you could make up some TypeRef for 's'
07:41:33 <aristid> jmcarthur: fortunately c++ is no OOP language, as even alan kay insists.
07:41:39 <kmc> hoho
07:41:41 <kmc> hehe
07:42:02 <jmcarthur> aristid: c++ is a monstrosity
07:42:35 <jmcarthur> that's its paradigm. monstrous programming
07:43:00 <aristid> jmcarthur: it sure is. and it's the best language for game engines (at least the low-level parts)
07:43:13 <jmcarthur> no it's not
07:43:29 <ski> (tafryn : btw, i like to call things like `Just 3',`[1,2,3]',`getLine' "monadic actions")
07:43:32 <jmcarthur> C is fine for game engines, *especially* the low level parts
07:44:28 <aristid> because it's more portable than x86 assembly?
07:44:47 <kmc> C++ is the best language for some niches.  it's still bad at those, though
07:44:48 <jmcarthur> because you don't have to write x86 assembly
07:44:59 <kmc> it's just we have nothing better that's viable
07:45:01 <Jafet> English is unarguably the best language to argue which is the best language.
07:45:37 <aristid> Nein, Deutsch ist die optimale Sprache für diesen Zweck.
07:46:36 <benmachine> has anyone else subscribed to haskell-cafe been emailed (privately) by one Syed Imran? it smells like spam to me but appears to be a genuine company so I don't know what to make of it
07:47:20 <quicksilver> benmachine: not I.
07:47:29 <noteed> benmachine: yes, at the end of june
07:47:34 <pikhq> いいえ、この問題について日本語が最も良い言語だぜ。
07:47:54 <noteed> benmachine: I know at least one other guy who has been contacted too
07:48:12 <aristid> pikhq: Du spinnst wohl.
07:48:17 <noteed> benmachine: it seems legit
07:48:48 <benmachine> noteed: yeah, I can't find anything wrong with it, I just find the idea that anyone would want to contact me based on my haskell-cafe postings a little bizarre :P
07:49:25 <benmachine> quicksilver: you don't post to cafe very much?
07:49:27 <noteed> benmachine: yes maybe, I don't know what head hunters are up to
07:49:53 <benmachine> noteed: I guess it doesn't cost them much to gather CVs
07:50:15 <quicksilver> not so much recently, no, benmachine 
07:50:22 <benmachine> right, ok
07:50:28 <hoooool> I received propositions for sex through haskell-cafe and successfully hooked up with an early thirties female professor
07:51:05 <msieradzki> jmcarthur, some game engines use virtual functions for practically everything
07:51:08 <hoooool> It was better than craigslist where my dick would glow for a while afterwards
07:51:13 * kmc high fives hoooool
07:51:17 <msieradzki> so they don't tweak it to get 100% performance with C++
07:51:21 <msieradzki> even though they could
07:51:28 <kmc> benmachine, is this Imran bloke advertising a Haskell job?
07:51:43 <kmc> er, virtual functions aren't always slower than the feasible alternatives
07:51:47 <jmcarthur> msieradzki: that's what people are moving away from nowadays
07:52:02 <hoooool> while you might get performance wit C++ you will also get mind-rot with that bargain
07:52:02 <msieradzki> vcall is fine for 90% of functions
07:52:14 <hoooool> imho you should never ever use c++
07:52:15 <quicksilver> and the virtual function overhead is fairly low anyway, and if its' not in a tight loop on a critical path it's irrelevant to overall performance.
07:52:21 <aristid> msieradzki: no, it's unnecessary for 90% of functions.
07:52:31 <msieradzki> no one will notice
07:52:36 <kmc> sometimes people think "virtual functions are slow, i'll have a single statically dispatched function which will switch on some tag to decide what to do"
07:52:41 <benmachine> kmc: http://lambda.pastebin.com/giJ0C235 details are vague
07:52:41 <msieradzki> from C++ point of view
07:52:45 <msieradzki> it's nice abstraction
07:52:51 <msieradzki> interfaces with pure vfunctions
07:52:51 <aristid> msieradzki: why write virtual everywhere, when you only need it in a few places.
07:52:59 <kmc> what this is, is an inferior hand-rolled implementation of virtual functions
07:52:59 <msieradzki> because you can use interfaces?
07:53:04 <msieradzki> split code into several dlls
07:53:13 <hoooool> if you are using c++ that is a sign that you are perhaps doing something wrong. Most agree that C++ is considered harmful.
07:53:23 <msieradzki> and has best compilers
07:53:28 <msieradzki> and has most middleware for games
07:53:30 <kmc> hoooool, what language would you use instead for high-frequency stock trading?
07:53:36 <jmcarthur> component systems are gaining traction. they are not really OO-looking at all to me
07:53:51 <hoooool> C++ is perhaps a new programming paradigm that we should call unstructured programming 
07:54:13 <aristid> hoooool: if you have nothing to say, don't say it. :)
07:54:20 <hoooool> while a interesting research language, not really usable for anything but making contrived code
07:54:36 <hoooool> and some games
07:54:41 <msieradzki> that's why games with 30MB code size work perfectly fine hoooool?
07:55:02 <quicksilver> stop feeding the troll msieradzki (and everyone)
07:55:16 <msieradzki> yes, should have
07:55:30 <hoooool> May I suggest something that would improve c++?
07:55:34 <benmachine> #haskell needs to talk about cpp less :P
07:55:43 <aristid> i think one of the things that pushed me towards haskell was actually the ugliness of a C++ game engine that a friend is writing
07:55:46 <quicksilver> well it was interesting and on-topic to start with.
07:55:48 <jmcarthur> hoooool: you may suggest it in #c++
07:56:02 <aristid> he is using the most modern "best practices" very consequently, yet the code is... terrible
07:56:31 <jmcarthur> aristid: see, that's not necessarily the case in C++. it may be a sucky language, but that doesn't mean you have to write sucky code with it
07:56:49 <hoooool> haskell is optimized for trolling and that is why everyone should use it
07:56:57 <quicksilver> hoooool: hush.
07:57:01 <kmc> yes
07:57:10 <kmc> @remember hoooool haskell is optimized for trolling and that is why everyone should use it
07:57:11 <lambdabot> I will remember.
07:57:13 <kmc> @quote _pizza_
07:57:14 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
07:57:22 <aristid> jmcarthur: well what annoys me the most is that they use static_cast<some_type>() around _every_ number and addition/multiplication/...
07:57:24 <jmcarthur> @protontorpedo
07:57:25 <lambdabot> how deos haskell differ from ml or lisp?
07:57:45 <quicksilver> 3
07:57:46 <aristid> jmcarthur: they do it for a reason: so the types are fully predictable, but it makes the code painful to read
07:57:50 <jmcarthur> aristid: they?
07:58:08 <aristid> well it's mostly one guy but he has some other people collaborating
07:58:15 <jmcarthur> aristid: you are talking about a specific group of people. i'm not
07:58:27 <thoughtpolice> probably the worst thing about C++ to me these days is that the type system is so insanely verbose and terrible that I don't really want to go through the pains of making my code use the type system most of the time
07:58:37 <thoughtpolice> because it's a PITA
07:58:39 <jmcarthur> thoughtpolice: i try anyway
07:58:48 <Jafet> @quote id.const
07:58:49 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
07:58:54 <thoughtpolice> so i write in a style that uses templates sparingly but overwhelmingly a C-like style
07:58:57 <kmc> yeah, Java and C++ have put lots of people off static typing entirely
07:59:06 <kmc> because they see it as a ton of effort with little to negative gain
07:59:10 <jmcarthur> the worst that happens is i went through a lot of trouble for type safety. the best that happens is somebody realizes we should use a language with a nicer type system
07:59:26 <thoughtpolice> pretty much yeah
07:59:37 <quicksilver> the main thing I like about C++ (over C) is std::map.
07:59:52 <SubStack> I wish javascript had type inference.
07:59:52 <yottis> i went from java to python and thought a bit like that
07:59:55 * SubStack gets on that.
07:59:56 <aristid> quicksilver: the other containers you don't care about?
08:00:04 <kmc> you see a lot of Rubyists who associate static typing with C++ lunacy or Java's kingdom of nouns, and thus refuse on principle to have any idea what their programs do before they run them
08:00:09 <tafryn> kmc: So if that example is run with -V then it will exit during the execution of that (>>=)?
08:00:18 <kmc> tafryn, i don't follow
08:00:18 <quicksilver> I've seen so many C programs do such idiotic contortions because they dont' have an associative container and don't feel like (a) writing one or (b) getting a library with one.
08:00:29 <yottis> learning haskell was nice cause it made me realize that the thing i hated was the lack of type inferring, not the staticness
08:00:35 <kmc> yeah yottis
08:00:41 <quicksilver> aristid: Sure, the others are useful. But it's *mainly* an associative container which I miss from C.
08:00:42 * noteed reads the agda paper on parsing mixfix operators allows only infix operator to specify an associativity
08:01:08 <osfameron> kmc: heh, that's a nice line ("thus refuse on principle to have any idea what their programs do before they run them"
08:01:15 <hoooool> well the c and c++ family has an "ass backwards" way of defining types as well. Making type definitions mimic use was unarguably a huge mistake. Just look at Go how simple it is and how much better it is to be able to read all your code in one pass left-to-right.
08:01:21 <int-e> yottis: out of curiousity, do you write type signatures for top-level declarations?
08:01:32 <kmc> tafryn, i don't know the GetOpt library specifically
08:01:34 <yottis> in haskell?
08:01:35 <quicksilver> noteed: I'm not entirely sjrprised.
08:01:40 <int-e> yottis: yes, in haskell
08:01:44 <quicksilver> yottis: on inference, yes, definitely.
08:01:49 <tafryn> Ah
08:01:57 <yottis> yeah, mostly i try to, partly as a way to avoid bugs
08:02:00 <noteed> quicksilver: now let's see how prolog does it then
08:02:13 <SubStack> top-level type signatures keep me sane
08:02:22 <quicksilver> yottis: the word thing about using std::map in C++ is having to type std::map< some::long::type, some::other::long::type >::iterator i; before your loop.
08:02:25 <yottis> partly as a way of documenting
08:02:30 <SubStack> also the compiler can give better errors
08:02:35 <quicksilver> (to be fair, they have fixed that one in C++ 1x)
08:02:41 <osfameron> is there something like KiokuDB/AllegroCache for Haskell?  (i.e. a persistent object graph)
08:02:45 <tafryn> kmc: Well I think I've got it sorted now. Thanks for your help.
08:02:49 <kmc> cool tafryn :)
08:02:56 <quicksilver> osfameron: happstack?
08:03:07 <thoughtpolice> quicksilver: auto is amazing
08:03:10 <quicksilver> well nto all of happstack, obviously.
08:03:12 <osfameron> quicksilver: that isn't a web framework ?
08:03:22 <quicksilver> osfameron: yes, but it has a persistent object graph component.
08:03:26 <kmc> quicksilver, you can use a CPP macro to define typedefs for your map, its iterator, and its const_iterator
08:03:32 <int-e> SubStack:  yeah, they tend to keep type errors localized to the code that caused them.
08:03:34 <noteed> osfameron: maybe persistent from the yesod framework
08:03:40 <hoooool> since I am not a haskell guru, are there simd operations available in ghc?
08:03:47 <kmc> here's another case where C++ totally drops the ball on abstraction, and you fall back on the ancient primitive text metaprogramming
08:03:50 <flazz> if both f and g :: a -> Bool, is there a cleaner way to express " (f x) && (g x)"?
08:04:00 <kmc> flazz, liftM2 (&&)
08:04:04 <kmc> :t liftM2 (&&)
08:04:05 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
08:04:11 <yottis> quicksilver: in java i think the problem is/was also that the type system isn't very expressive
08:04:23 <quicksilver> kmc: you certainly can. It's a pain though.
08:04:24 <kmc> flazz, here «m Bool» is specialized to «a -> Bool»
08:04:31 <osfameron> quicksilver: is that the "ram cloud thing they mention on the front-page
08:04:35 <osfameron> noteed: cool, I'll have a look
08:04:37 <yottis> the situation's better nowadays (don't really know), but i really don't miss java at all
08:04:38 <flazz> i'll need a minute
08:05:03 <kmc> hoooool, not really. http://hackage.haskell.org/trac/ghc/ticket/3557
08:05:24 <quicksilver> osfameron: http://hackage.haskell.org/package/happstack-state
08:05:28 <yottis> python is very annoying in that it would be a lot less bug prone with a type system like haskell's, but i don't think the language would be very pythonic after that anymore
08:05:32 <flazz> kmc: functions are monads?
08:05:40 <kmc> flazz, yes.  more specifically, ((->) a) is a monad
08:05:46 <quicksilver> osfameron: warning - it's a bit subtle. Don't expect to grok it in 10 minutes and small latte.
08:06:13 <osfameron> quicksilver: really?  a large paradigm-changing library in Haskell?  that long? ;-P
08:06:31 * osfameron is still (failing to) get to grips with KiokuDB, in a language he knows better...
08:06:31 <kmc> @src (->) return
08:06:32 <lambdabot> return = const
08:06:33 <kmc> @src (->) (>>=)
08:06:34 <lambdabot> f >>= k = \ r -> k (f r) r
08:06:36 <quicksilver> it took me 14 minutes, and I drank two cups of tea. YMMV.
08:06:56 * hackagebot yesod 0.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.4.1 (MichaelSnoyman)
08:07:41 <yottis> it would be nice to try out how haskell works for something more compicated. unfortunately i can't use it professionally and there's not too much time for pet projects, so that's been lingering around for a couple of years now
08:07:54 <kmc> flazz, the (Reader r) monad is just a wrapper on ((->) r)
08:07:59 <kmc> works the same way
08:08:03 <jaspervdj> noteed: fyi, we also have a #ghentfpg channel here on freenode ;-)
08:08:19 <yottis> i really like haskell so far, but i can't say i have an informed opinion on a language before having tried it for something serious
08:08:32 <osfameron> yottis: Perl is doing a fair bit with typing (Moose type constraints) though that's really just for argument validation, not inferencing/etc. yet
08:08:42 <flazz> kmc: thanks for my diversion for today
08:08:46 <osfameron> (in relation to your musing about Python, a similar language)
08:08:59 <noteed> jaspervdj: oh no, not another tab!
08:09:12 <yottis> i've read perl quite a bit, not written much of it, and it makes me mentally ill :>
08:09:23 <jaspervdj> noteed: haha :-)
08:09:44 <kmc> that's a fair assessment
08:09:55 <ski> noteed : .. how Prolog does what ?
08:09:59 <yottis> whereas python is ok, the duck typing just makes my head explode sometimes
08:10:02 <kmc> with great discipline you can write clear, readable, maintainable Perl
08:10:12 <kmc> however it is infinitely easier and more tempting to make a mess
08:10:19 <quicksilver> I don't really think python and perl are any different in any interesting way.
08:10:34 <noteed> ski: how it parses an expression involving infix and prefix or postfix operators
08:10:47 <kmc> quicksilver, their type systems are different.  Python usually won't operate on grossly mismatched args; Perl will attempt a conversion no matter how implausible
08:10:52 <cwb> Basic question: Can I achieve something like: fmap {accessor = "new"} (Just valueWithAccessor)?
08:11:04 <yottis> remembering how far i got in mastering python with the same time as i spent on perl, i must say python was much easier
08:11:06 <kmc> cwb, fmap (\x -> x { accessor = "new" })
08:11:10 <quicksilver> kmc: ok, that's fair. It doesn't seem to me to be soething that affects me very often though.
08:11:15 <aristid> quicksilver: perl has a quite unusual type system, and i think that is a pretty fundamental thing.
08:11:18 <noteed> ski: especially when (if it is possible) an infix and a prefix/postfix have the same precedence
08:11:19 <kmc> cwb, or use a real first-class labels package like fclabels
08:11:38 <yottis> there's a gazillion ways of doing things in perl and always some new caveat somewhere
08:11:47 <ski> noteed : it assigns a precedence number to each sub-term, coming from the main operator used (or `0' if it was atomic)
08:11:58 <cwb> kmc: Ah, of course, thanks! I'll use the former for now and check out the latter.
08:12:14 <quicksilver> aristid: Yeah. Hmm. I'm not sure. I do appreciate that perl + python have different kinds of weak typing, but since they're both so weak I seem to program in a very similar way in either.
08:12:24 <quicksilver> aristid: maybe that says more about me than about the languages.
08:12:29 <osfameron> heh
08:12:37 <quicksilver> But given a problem, I would solve it in essentially the same way in perl or python.
08:12:44 <ski> noteed : if `not' has fixity `fx', then you can't say `not not foo', but if it has fixity `fy', then you can
08:12:58 <Saizan> ski: the question was what happens if you've infixl + and postfix ! with same precendence and you write "x + y !"
08:12:59 <quicksilver> in, say, either of C++ or haskell, I would probably come up with a substantially differnt approach
08:13:02 <ski> noteed : so `/' has fixity `yfx'
08:13:37 <aristid> quicksilver: in perl i fit most things in nested hashes/arrays, whereas in python i'm more likely to make classes for everything (although i could use just dict/list too)
08:13:49 <aristid> quicksilver: but i only use perl for simple tools
08:14:09 <ski> Saizan : with `!' having `xf' or `yf' fixity ?
08:14:36 <jmcarthur> @remember kmc you see a lot of Rubyists who associate static typing with C++ lunacy or Java's kingdom of nouns, and thus refuse on principle to have any idea what their programs do before they run them
08:14:37 <lambdabot> Okay.
08:14:42 <aristid> ski: where does that strange "fixity" syntax come from?
08:14:49 <ski> Prolog :)
08:15:09 <Saizan> ski: mh, that was undefined up to now :)
08:15:31 <ski> there are seven fixites in Prolog : `fx',`fy',`xfy',`xfx',`yfx',`yf',`xf'
08:15:35 <Saizan> (i didn't know/realize there was a choice to make)
08:16:08 <ski> the `f' signifies the position of the operator, so `fx',`fy' are for prefix, `xfy',`xfx',`yfx' are for infix, while `yf',`xf' are for postfix
08:16:19 <aristid> ski: i didn't know prolog supports operator overloading
08:16:39 <noteed> ski: so no associativity involved, only precedence?
08:16:43 <ski> the `x' means that the corresponding argument must have strictly less precedence than the operator itself
08:16:45 <Saizan> operator overloading /= defining your own operators
08:16:53 <Saizan> or not?
08:17:08 <ski> while `y' means that the corresponding argument only need to have less than or equal precedence as the operator itself
08:17:20 <aristid> Saizan: i mean the latter actually
08:17:27 <ski> aristid : whence operator overloading ?
08:17:42 <quicksilver> well that's the C++ term for defining your own operators.
08:17:45 <edwardk> hrmm. http://hackage.haskell.org/packages/archive/string-combinators/0.5/doc/html/Data-String-Combinators.html looks like a very nice way to handle a lot of the pretty printing combinators
08:18:00 <aristid> quicksilver: hard to unlearn terms after so many years :P
08:18:01 <quicksilver> because the only legal operators are builtin, so defining them is necessarily overloading htem.
08:18:06 <ski> (and in Prolog, as opposed to in Haskell, the lesser a precedence is, the tighter does the operator attach)
08:18:30 <aristid> ski: is it possible to define operators in prolog?
08:18:39 <Saizan> ski: ah, so with yf we get "(x + y) !" while with xf we get "x + (y !)"? assuming x and y are atoms
08:18:39 <ski> yes, that's the point of this
08:18:48 <edwardk> aristid: prolog has a very flexible syntax
08:20:10 <noteed> Saizan: but what is the precedence of + here?
08:20:47 <ski> Saizan : if `+' is `yfx', and `!' is `xf', and they have the same precedence, then `x + y !' is simply not allowed
08:21:41 <noteed> ski: thanks!
08:21:41 <Saizan> ski: makes sense
08:21:45 <ski> Saizan : because `!' won't accept `.. + ..' as argument, because the precedence is the same, and `+' won't accept `.. !' as right argument, because the precedence is the same (the `x' in `yfx' makes it demand strict inequality)
08:22:33 <ski> if `!' however is `yf', the `(x + y) !' reading is possibly
08:22:40 <ski> s/possibly/possible/
08:23:13 <noteed> ski: still assuming they have same precedence ?
08:23:17 <ski> yes
08:24:25 <ski> noteed : i've been toying a bit with the idea of allowing infix operators (and more generally mixfix things) to have different precedences on different sides .. i'm not convinced this makes a sane system yet, though
08:25:30 <ski> (.. also i've been wanting to write an operator parser which uses delimited continuations ..)
08:26:02 <noteed> ski: I saw a mail somewhere explaining such a schme
08:26:14 <ski> which ? :)
08:27:14 <ski> (btw, obviously i want abstract precedences with only a partial order on them .. but i assume you've thought of this)
08:28:57 <noteed> ski: can't find it, will look
08:29:05 <noteed> ski: you know about the agda paper?
08:29:12 <ski> no
08:29:18 <edwardk> ski: there is of course the more radical proposal by the agda folks to not even require the partial order
08:29:33 <ski> (i know Agda2 allows mixfix, but i don't know the details of what they do)
08:29:52 <edwardk> ski: http://hackage.haskell.org/packages/archive/string-combinators/0.5/doc/html/Data-String-Combinators.html
08:29:52 <ski> edwardk : yes, i've pondered removing transitivity as well ..
08:30:00 <edwardk> er woops
08:30:08 <edwardk> http://www.cs.nott.ac.uk/~nad/publications/danielsson-norell-mixfix.pdf
08:30:31 <noteed> ski: ^^^
08:30:45 <quicksilver> edwardk: what did you mean about that looking like a nice way to handle pp combinators? what aspect of it?
08:31:26 <edwardk> quicksilver: i just like the use of IsString and Monoid to cover a wide class of various common pretty print needs. <+>, etc.
08:32:06 <edwardk> (mostly because it just works with all my crazy monoids) ;)
08:32:33 * ski wonders how the paper can reference one from 2009 when it itself allegedly is from 2008
08:33:20 <edwardk> ski: clearly the agda folks are from the future. ;)
08:33:30 <quicksilver> edwardk: Is it as clever as it looks though? There is no vertical composition.
08:34:04 <quicksilver> edwardk: (unless you count \x y -> x <> newline <> y, which is perhaps not the same)
08:34:05 <edwardk> quicksilver: possibly not. =) i just tripped over it when i found Text.Repr
08:34:20 <quicksilver> edwardk: and so it hasn't really solved the hard problem of "erm, which monoid?"
08:34:22 <edwardk> (which didn't use vertical composition at all)
08:36:02 <edwardk> they also aren't as smart as the combinators used by real pretty printers. e.g. (<+>) won't elide a space if there is already preceding space, etc)
08:36:20 * quicksilver nods
08:36:23 <edwardk> heya conal
08:36:33 <quicksilver> well, they can't be, without requiring more from their operands than they do.
08:36:48 <manjunaths> If in one of my modules I have a function named + and it takes 2 data's of type something V and returns some float. Does this work ?
08:36:49 <quicksilver> maybe it's supposed to be the monoid's responsibility to do that.
08:37:05 <manjunaths> why does it complain that ambiguous + and conflicts with prelude.+
08:37:17 <manjunaths> can't I have overloaded functions ?
08:37:19 <quicksilver> no.
08:37:20 <edwardk> import Prelude hiding ((+))
08:37:28 <Jafet> :t (+)
08:37:29 <lambdabot> forall a. (Num a) => a -> a -> a
08:37:33 <quicksilver> or rather, the only way to overload functions is to use a typeclass.
08:37:40 <quicksilver> you can't do arbitrary overloading.
08:37:44 <manjunaths> ah...ok
08:37:45 <quicksilver> just hide the one you don't want.
08:37:53 <edwardk> if you call something (+) it implies that you are a Num instance. you'd need to implement all of the functionality of Num
08:38:00 <edwardk> @src Num
08:38:00 <lambdabot> class  (Eq a, Show a) => Num a  where
08:38:00 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:38:00 <lambdabot>     negate, abs, signum     :: a -> a
08:38:00 <lambdabot>     fromInteger             :: Integer -> a
08:38:18 <manjunaths> right now I have a use for typeclass :-)
08:38:20 <manjunaths> this is good
08:38:23 <edwardk> if those aren't all appropriate, then you probably want to call your operator something else (or you need to just hide the existing one)
08:38:40 <manjunaths> I think I need all the above
08:38:52 <deteego> does anyone know if there is a context free grammer specification for haskell
08:38:55 <deteego> lying around
08:39:12 <Eduard_Munteanu> deteego: isn't it in the Haskell '98 report?
08:39:18 <edwardk> note that (+) would 'take two V's and return a V', not a float.
08:39:30 <manjunaths> edwardk, ok...
08:39:32 <Eduard_Munteanu> I'd expect it to be there.
08:39:42 <manjunaths> edwardk, yeah, that is not good
08:39:53 <quicksilver> haskell's grammar isn't context-free
08:39:54 <manjunaths> no actually it is
08:39:57 <edwardk> manjunaths: what is V?
08:39:59 <manjunaths> thanks edwardk 
08:40:03 <edwardk> some kind of vector?
08:40:05 <quicksilver> or, rather, taken as context-free it's ambigious.
08:40:15 <manjunaths> Vec3 which is data Vec3 = Float Float Float
08:40:48 <deteego> Eduard_Munteanu: ah yes, thats what I was looking for
08:40:59 <manjunaths> in my C++ class I have things like operator*(Vec3 v, float f)
08:41:10 <manjunaths> so I can do scaling using the * operator
08:41:11 <Eduard_Munteanu> Well yeah, not a context free grammar, but a grammar spec.
08:41:12 <deteego> however I was wondering if it was already available in a format that could be used for something like Bison
08:41:25 <edwardk> manjunaths: ah, then you're find. (+) can add elementwise. (*) is a little unnatural being elementwise multiplication and not dot product, negate can flip elementwise, fromInteger just builds each of the elements, abs and signum are tricky you want abs to compute abs elementwise and signum to compute sign elementwise so that abs a * signum a = a
08:41:26 <deteego> instead of having to manually go through the report
08:41:30 <manjunaths> but I wonder if this is possible in haskell given the above limitation of num
08:41:41 <edwardk> so abs is not the norm you'd expect
08:41:42 <Eduard_Munteanu> deteego: you might want to look at other Haskell compilers, there was at least one implemented in C.
08:41:48 <ski> > let (x,y,z) *. n = (x * n,y * n,z * n) in (2,3,4) *. 3
08:41:50 <lambdabot>   (6,9,12)
08:41:54 <manjunaths> edwardk, yeah..exactly
08:42:05 <edwardk> manjunaths: there is a 'vector-space' library that provides the scalar-vector multiplication you want
08:42:06 <Tomsik> Control/Concurrent/STM/TVar.hs:22:8:
08:42:06 <Tomsik>     Ambiguous occurrence `readTVarIO'
08:42:06 <Tomsik>     It could refer to either `Control.Concurrent.STM.TVar.readTVarIO', defined at Control/Concurrent/STM/TVar.hs:35:0
08:42:06 <Tomsik>                           or `GHC.Conc.readTVarIO', imported from GHC.Conc at Control/Concurrent/STM/TVar.hs:29:0-14
08:42:19 <Tomsik> ("Building stm-2.1.2.1...")
08:42:21 <manjunaths> edwardk, ah...thanks
08:42:24 <deteego> Eduard_Munteanu: GHC is the only haskell compiler that implemented haskell 2010 correct?
08:42:24 <Tomsik> cabal is giving me that
08:42:26 <edwardk> http://hackage.haskell.org/packages/archive/vector-space/0.7.1/doc/html/Data-VectorSpace.html
08:42:30 <Tomsik> What now? :p
08:42:46 <manjunaths> edwardk, thanks.
08:42:48 * manjunaths looks
08:42:48 <Tomsik> I mean, halp.
08:42:49 <Eduard_Munteanu> deteego: not sure. But GHC has most features, AFAIK.
08:43:00 <edwardk> you can then define instance VectorSpace Vec3 where type Scalar Vec3 = Float; (*^) = ...
08:43:09 * hackagebot stm 2.1.2.2 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.1.2.2 (SimonMarlow)
08:43:10 <Eduard_Munteanu> deteego: even stuff that isn't Haskell 2010 (though some other compilers implemented extensions as well)
08:43:29 <Saizan> Tomsik: heh. maybe try with 2.1.2.2 ? :)
08:43:45 <Eduard_Munteanu> :)
08:43:45 <Tomsik> Okay, let's see if it install by hand then :p
08:43:57 <Saizan> Tomsik: sounds like that stm version is not meant to work with your base version.
08:44:02 <manjunaths> edwardk, ah...but I already wrote my Vec3, maybe I will do this in the next step as a learning experience
08:44:47 <ski> JaffaCake++
08:44:54 <Tomsik> darn
08:45:09 <deteego> Eduard_Munteanu: well to be specific I am actually considering making a haskell plugin for an IDE
08:45:19 <deteego> Eduard_Munteanu: which would obviously require a language parser
08:45:51 <Eduard_Munteanu> ski: that'd be a damn fast bug fix if he saw Tomsik reporting and fixed it :P
08:46:18 <Eduard_Munteanu> deteego: you might want to have a look at Yi, it does that from what I hear.
08:46:35 <JaffaCake> Tomsik: try 2.1.2.2, it should fix your problem
08:46:40 <quicksilver> deteego: and which language woudl the pluging be written in?
08:46:41 <Tomsik> heh
08:46:43 <Tomsik> :)
08:46:59 <Eduard_Munteanu> deteego: I mean it does highlighting and shows what didn't compile etc.
08:47:11 <quicksilver> deteego: (whatever you answer I think you want to look at haskell-src-exts)
08:47:18 <Eduard_Munteanu> deteego: but if you want that plugin to also provide a compiler, perhaps you should bundle GHC or something along.
08:47:27 <deteego> quicksilver: it would be in C/C++
08:48:14 <Tomsik> works now, yeah
08:48:24 <Tomsik> That's the fastest bug-fix I've ever seen
08:48:32 <Eduard_Munteanu> Heh, thumbs up.
08:48:56 <JaffaCake> Tomsik: much as I'd love to leave you believing that, as it happened I was working on it anyway :)
08:48:58 <deteego> Eduard_Munteanu: the plugin isn't going to provide a compiler, it just requires a parser/lexer for things like code completion and highlighting
08:49:25 <deteego> but thanks for your help nonetheless, will need a lot of looking around
08:49:25 <quicksilver> deteego: Then you're probably best of having a stub haskell tool (based on haskell-src-exts) which produces something your C++ can easily analyse.
08:49:28 <Tomsik> JaffaCake: it's a nice coincidence anyway ;)
08:49:38 <quicksilver> deteego: haskell with extensions is quite non-trivial to parse.
08:49:53 * ski . o O ( "it must be syncronicity !" )
08:50:01 <deteego> yeah there isn't anything that would say otherwise
08:50:33 <noteed> ski: I believe my distfix parser could be easily changed to define operators relations in a graph
08:51:38 * ski wants true associative operators ..
08:52:03 * noteed doesn't know what true means
08:52:22 <quicksilver> presumably they actually get passed a list?
08:52:38 <quicksilver> (+) :: [Int] -> Int
08:52:53 <quicksilver> of at least two elements.
08:53:32 <lispy> good morning
08:54:09 * ski is not fully sure what was meant, either
08:54:20 <lispy> noteed: it's a special value used in logics.  It's essentially arbitrary but rules are used to properly construct expression that have it as the value.
08:54:51 <ski> something related to that, if an operator is associative, i shouldn't have to specify "left" vs. "right" associativity
08:54:54 <ski> and
08:54:56 <ski> both
08:55:03 <ski> @type \f g -> (f . g .)
08:55:03 <ski> and
08:55:04 <lambdabot>     The operator `.' [infixr 9] of a section
08:55:04 <lambdabot>         must have lower precedence than that of the operand,
08:55:04 <lambdabot>           namely `.' [infixr 9]
08:55:09 <ski> @type \f g -> (. f . g)
08:55:10 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a1 -> a) -> f a1 -> (a -> b) -> f b
08:55:11 <ski> should work
08:55:13 <noteed> lispy: well thanks, but true _in the context mentioned by ski_ :)
08:55:19 <lispy> ah
08:58:16 <noteed> ski: that looks like a limitation of the section notation
08:58:32 <illissius-> deteego: what IDE?
08:58:59 <ski> in `(. f . g)' it parses similarly to `h . f . g', i.e. as `h . (f . g)'
08:59:43 <ski> while in `(f . g .)' it would have to parse `f . g . h' as `(f . g) . h', which is not allowed because the composition operator is *right* "associative"
08:59:43 <quicksilver> ski: although operationally that may not always be good
09:00:05 <quicksilver> ski: it's quite unusual for both associativity directions to have identical space/time behaviour, even when they match denotationally.
09:00:15 <ski> quicksilver : there could well be a preferred way of leaning it, that would be used
09:00:21 * quicksilver nods
09:00:42 <noteed> ski, quicksilver: yes, parsing is quite naturally left-biased
09:01:10 <ski> noteed : ask edwardk about monoidal parsing :)
09:01:27 <deteego> illissius-: kdevelop
09:01:37 <deteego> anyways im gonna go to bed
09:01:41 <illissius-> deteego: that's what i thought :) i've been thinking about that too
09:01:44 <deteego> adios
09:01:48 <illissius-> kdevelop being so awesome, and haskell being so awesome
09:01:50 <ski> (also, depending on what you mean by "left-biased", i'm not sure i agree)
09:01:52 <deteego> yup
09:01:53 <illissius-> good night
09:02:59 <aristid> ski: monoidal parsing? what is that, in 7 words? oO
09:03:27 <ski> edwardk : ^
09:03:55 <illissius-> monoidal parsing is parsing which uses monoids
09:04:06 <aristid> illissius-: yay 7 words.
09:04:25 <illissius-> i exist to serve
09:04:37 <illissius-> or please
09:04:39 <illissius-> or whatever
09:07:06 <zygoloid> ski: fwiw i like the proposal that (* 3 + 1) be (\n -> n * 3 + 1) etc
09:08:06 <aristid> preflex: seen edwardk
09:08:07 <preflex>  edwardk was last seen on #haskell 25 minutes and 7 seconds ago, saying: you can then define instance VectorSpace Vec3 where type Scalar Vec3 = Float; (*^) = ...
09:08:07 <ski> hm ..
09:08:16 <aristid> ski: so, what is it?:)
09:08:36 <ski> aristid : edwardk can explain better (he more or less invented it)
09:08:51 * ski has only a vague idea of it
09:09:13 <zygoloid> hmm. are there other places than sections where an "infixa" or whatever would be helpful?
09:12:13 <Athas> Whenever I do 'cabal install' in my project directory, cabal builds and reinstalls containers, haskell98 and X11-xft again.
09:12:19 <Athas> Why does it do that every time?
09:12:32 <noteed> zygoloid: a DSL with a 'define' operator, like the = in Haskell?
09:12:49 <Athas> I use Cabal 1.8.0.2 and GHC 6.12.
09:12:49 <Saizan> Athas: "--dry-run -v" should tell
09:13:40 <ski> noteed : are you thinking of something like FunMath's "flexible operators", now ?
09:14:25 <noteed> ski: I don't know about it (more than its name that is)
09:15:53 <Saizan> Athas: also, check in "ghc-pkg list" if you have multiple installations of the same version of the same package, that's often a cause of confusion for Cabal currently
09:16:03 <aristid> ski: i'm reading http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf
09:16:41 <Athas> Saizan: indeed, that is the issue.  I have a system-wide array-3.0.0.0 and a local array-3.0.0.1.
09:16:57 <noteed> ski: I'll explain a bit later, I'm required elsewhere
09:17:01 <ski> noteed : basically, then interpret e.g. `x_0 =< x_1 =< ... =< x_{n-1}' as saying that the function `i |-> x_i' is monotone
09:17:04 <monochrom> if you have multiple instances of the same package same instance, cabal suppresses both, then it wants to install it more times. paradoxical eh?
09:17:10 <rumpelstilzchen> is there a way to start an external program, passing it file handles for stdin, stdout and stderr and NOT CLOSING the handles? 
09:17:19 <monochrom> err, multiple instances of same package same version
09:17:28 <Saizan> Athas: i was referring to a situation like "system-wide array-3.0.0.0 and a local array-3.0.0.0"
09:17:29 <ski> noteed : that `x_0 = x_1 = ... = x_{n-1}' means that `i |-> x_i' is constant
09:17:40 <rumpelstilzchen> i tried runProcess and createProcess already, both always close my handles!
09:18:07 <ski> noteed : and that `x_0 =/= x_1 =/= ... =/= x_{n-1}' means that `i |-> x_i' is injective
09:18:13 <Athas> Saizan: oh.  I don't have that.  They have different versions, but cabal claims that it must recompile containers, haskell98 and X11-xft because array changed version.
09:19:17 <Saizan> Athas: can you paste your ghc-pkg list? anyhow --constraint="array == 3.0.0.0" or even unregistering array-3.0.0.1 might help
09:19:51 <Saizan> Athas: the fact that it keeps recompiling them is weird, unless it thinks the old ones built against array-3.0.0.1 are broken.
09:20:48 <monochrom> --dry-run -v will tell you that both are ignored therefore need yet another install
09:21:08 <noteed> ski: wow, I have no clue of the relationship with what we discussed before :-/
09:22:00 <monochrom> I now feel that cabal-install should just say "you have too many arrays, my head has exploded" rather than try to install more.
09:22:10 <zygoloid> noteed: isn't that infixr?
09:22:31 <monochrom> afterall installing more will solve absolutely nothing
09:22:51 <Saizan> you seem to be misunderstanding Athas's situation
09:22:57 <noteed> zygoloid: in C, yes, but you can't chain multiple = in Haskell
09:23:06 <Athas> This is my ghc-pkst list: http://pastebin.com/Bve9CDS9
09:23:13 <Athas> Also, hpaste.org is down?
09:23:52 <zygoloid> noteed: that's because = isn't an operator...
09:24:24 <noteed> zygoloid: yes, but I was mentionning a DSL... maybe I didn't understand your question correctly
09:24:53 <zygoloid> i was wondering if there were cases where the ability to declare an operator as being infix-associative (rather than infixl or infixr) would be useful
09:25:20 <zygoloid> (other than in sections where ski points out that it'd be nice to allow both (. f . g) and (f . g .))
09:25:24 <monochrom> containers-0.3.0.0 is in both global and user
09:25:24 <Saizan> Athas: ok, you've containers-0.3.0.0 and haskell98-1.0.1.1 both in the global and user package db, you've to get rid of one copy of those
09:25:57 <noteed> zygoloid: oh, I thought you were asking for a non-associative one
09:25:59 <aavogt> probably the user copy
09:26:17 <Saizan> Athas: one installation is probably the one built against the new array, but Cabal can't use it even if installed it
09:26:33 <jmcarthur> i'm guessing a lot of people are getting emails from somebody soliciting based on emails to the mailing list?
09:26:42 <monochrom> so edit my feeling with s/array/container/ and it will be correct
09:27:34 <aavogt> why is it array and not arrays
09:27:51 <aavogt> somebody wasn't consistent
09:28:20 * Saizan wonders why it ended up reinstalling them
09:28:59 <quicksilver> zygoloid: in principle it might be an optimisation hint to a sufficiently smart compiler.
09:29:11 <quicksilver> zygoloid: in practice I'm not sure I can think of interesting examples.
09:29:25 <quicksilver> it makes a little more constant folding possible
09:29:38 <quicksilver> but I"m sure constant-folding is basically a conceit.
09:30:32 <duairc> I'm getting a stack overflow, and I've no idea where in my code it could be. What's the preferred way to debug such things?
09:30:33 <monochrom> aavogt: because applying s/array/container/ to "arrays" will get you "containers", I don't need to edit the "s".
09:31:43 <lispy> duairc: Hmm.  I was going to say heap profiling, but then I realized that may not help :)
09:31:51 <duairc> :)
09:31:57 <lispy> duairc: one thing to look for: do you use foldl instead of foldl' ?
09:32:14 <duairc> I'm not really doing anything with lists in this code
09:32:31 <duairc> Well they're all small lists
09:32:51 <duairc> But no, I didn't use foldl anyway
09:32:58 <lispy> duairc: The main cause of heap overflow I'm familiar with is when you build up a large expression and then during evaluation of it the stack gets used and you need more stack than you get :)
09:33:08 <monochrom> Athas, Saizan: do you know how to get containers-0.3.0.0 in both global and user in the first place?
09:33:32 <ski> noteed : re "zygoloid: a DSL with a 'define' operator, like the = in Haskell?", i was wondering if you maybe wanted to allow things like "foo = bar = baz" (stating that all these are equal)
09:33:50 <lispy> duairc: Mostly haskell doesn't use a stack, but as an optimization in the spineless tagless gmachine stacks can be used in some cases
09:33:50 <duairc> I'm thinking tihs is more of an infinite loop type thing, setting the stack size to something ridiculous doesn't really help at all
09:34:08 <duairc> Hmmm
09:34:31 <lispy> duairc: http://www.haskell.org/haskellwiki/Stack_overflow
09:34:48 <ski> (zygoloid : i think of `=' (and function application, and `::', and `=>') as syntactic operators :)
09:34:49 <noteed> ski: no no, I was thinking he wanted a case where defining non-associative operators would be useful
09:34:54 <Saizan> monochrom: if you already have containers-0.3.0.0 and array-0.3.0.0 in the global, you install array-0.3.0.1, and then "cabal install containers" you'll have it
09:35:09 <monochrom> I see.
09:35:42 <duairc> lispy: I know what kinds of things will cause stack overflows, it's just more a case of I have about 400 lines of code separated across different modules and I've no idea where in that code the cause of the problem is
09:35:43 <aristid> ski: these slides did not really make me understand. *sigh*
09:35:54 <duairc> Is there a way of narrowing it down?
09:36:54 <lispy> duairc: I don't know a good way to narrow it down other than to look for common causes.  BTW, Haskell stack overflows tend to have a different cause than in other languages that use recursion heavily.  I don't know if you're aware of that, so I linked that page.
09:37:30 <lispy> duairc: You could possibly use either HPC or profiling to find out what part of your program was executing when the stack overflow happened
09:37:48 <lispy> duairc: and maybe threadscope too, but I'm not familiar with it
09:41:14 <lispy> duairc: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/src/GHC-IO-Exception.html  <-- you could try to catch the StackOverflow exception and see if it has any information in it about location
09:41:53 <duairc> Hmmm, I might try that
09:42:04 <lispy> duairc: you could try running in gdb and printing the stack when you have the exception.  Then, look at ghc-core and see if you can work backwards from there.
10:09:00 <duairc> lispy: I found the problem, I used Debug.Trace in the end
10:12:04 <lispy> duairc: Interesting.  You didn't find that Debug.Trace didn't change the strictness of your program in such a way that it moved the problem around?
10:12:35 <lispy> (ah double negatives...)
10:12:47 <c_wraith> Whether Debug.Trace changes strictness entirely depends on what you use it to print
10:13:25 <lispy> indeed
10:13:46 <lispy> duairc: I'm curious, what was it?
10:15:07 <c_wraith> I so wish Monad implied Functor. >_>
10:15:18 <c_wraith> I can see why it doesn't...
10:15:32 <c_wraith> Or rather, why the decision was made to not have that requirement.
10:15:42 <c_wraith> But I wish they'd gone the other way on that decision anyway
10:17:26 <Saizan> "but i've to add an extra line for a "derivable" instance!" seems so silly in retrospect, tbh
10:18:51 <kmc> wait, what's the justification?
10:18:58 <kmc> i thought it was merely hysterical raisins
10:19:45 * hackagebot memcached 0.2 - haskell bindings for memcached  http://hackage.haskell.org/package/memcached-0.2 (OlegKatsitadze)
10:19:53 <kmc> would be interesting to have a "show only to WHNF" typeclass
10:19:57 <c_wraith> Hmm.  Actually, maybe there isn't a reason.
10:20:04 <kmc> GHCi debugger can show partially evaluated values, and also non-Show values
10:20:07 <kmc> but it has RTS magic
10:20:28 <kmc> is there a nice way to access that magic by GHC API? closest i can think of is vacuum
10:20:31 <c_wraith> I thought it was to support different functor instances for types where it makes sense, but I'm not sure there are multiple functor instances that make sense.
10:20:42 <c_wraith> yeah, vacuumLazy works.
10:20:47 <c_wraith> I don't know of anything easier
10:21:03 <Saizan> kmc: i'm pretty sure Functor was already there
10:21:08 <Saizan> but icbw
10:21:46 <kmc> c_wraith, i don't follow.  you can't have two instances for the same type
10:21:51 <c_wraith> A previous version of haskell (1.4?) did have Functor as a dependency of Monad
10:21:54 <kmc> regardless of whether monad implies functor
10:21:56 <kmc> oh, really?
10:21:57 <kmc> strange
10:22:34 <c_wraith> kmc: I mean two different ways of implementing it that obey the functor laws.  Like Applicative has two implementations that obey its laws for the [] type.
10:22:57 <c_wraith> But I don't think there is any ambiguity in the Functor typeclass
10:24:43 <aristid> c_wraith: why was Functor dropped?
10:25:01 <c_wraith> I don't know.
10:25:07 <c_wraith> I wasn't around at that point
10:25:20 <aristid> who is oldest here? :D
10:31:10 <ski> c_wraith : for monads, `fmap' should always be `liftM' (maybe it could be somewhat more efficient in some cases, if implemented directly, instead of using the `liftM' implementation, but the sematics should be the same)
10:31:42 <zygoloid> c_wraith: there's at most one 'correct' fmap for any given ADT (even for GADTs i think)
10:32:04 <c_wraith> ski: I understand that.  My question was more regarding whether there are data types that would allow two different definitions of fmap.
10:32:31 <c_wraith> and yeah, I'm forced to agree with zygoloid.  A correct implementation of fmap is purely structural.  There are no decisions to make.
10:33:13 <lispy> c_wraith: (,)
10:33:23 <c_wraith> lispy: wrong kind.
10:33:24 <kmc> that's two types though
10:33:27 <lispy> ?src fmap (,)
10:33:28 <lambdabot> Source not found. Just try something else.
10:33:38 <lispy> > fmap (+1) (1,1)
10:33:40 <lambdabot>   (1,2)
10:33:42 <duairc> lispy: Sorry about that, I was getting food
10:33:44 <ski>   instance Functor (w,)
10:33:51 <kmc> «Λt → (a,t)» and «Λt → (t,a)» each have a single Functor instance
10:33:52 <ezyang> Well, you have to pick which side you fmap on. 
10:33:53 <c_wraith> lispy: to be an instance of Functor, the kind needs to be * -> *
10:34:06 <zygoloid> kmc: i'll release my library Real Soon Now, and you too will be able to implement show-to-WHNF for an arbitrary type :)
10:34:12 <c_wraith> ezyang: without type-level lambdas, the language makes that decision for us
10:34:22 <kmc> zygoloid, by hacking into the memory space of another running Haskell program?
10:34:24 <lispy> c_wraith: but we have those I'm told
10:34:30 <duairc> Basically, I had a monad which was much easier to define in terms of join, so I defined a function join' for my monad and then defined >>= in terms of that
10:34:40 <EvanR-work> functional booleans (\x y -> x) and (\x y -> y) are purely structural, yet it makes decisions ;)
10:34:43 <duairc> And it seems I'm accidentally calling >>= in my definition of join'
10:34:44 <zygoloid> kmc: by hacking into the memory space of yourself :)
10:34:51 <lispy> c_wraith: either as a newtype or using AT (or was it type families?)
10:34:53 <kmc> cool
10:34:53 <zygoloid> much easier that way :)
10:34:57 <ski> duairc : yes, imo `Monad' should have `join' as a method
10:34:57 <kmc> that could be really useful for what i'm doing
10:35:11 <c_wraith> lispy: if you use a newtype it's.... a new type. :)
10:35:21 * kmc wonders if Unicode Haskell should use ↦ instead of →, as in «λ x ↦ x+1»
10:35:38 <c_wraith> newtype FlippedPair a b = FlippedPair (b, a)
10:36:08 <ski>   newtype k (Flip f a b) = MkFlip (k (f b a))
10:36:50 <lispy> duairc: oh, interesting
10:37:01 <jmcarthur> something got mixed up in my unicode support
10:37:22 * ski wonders how bad involutive type constructors would mess up type inference
10:37:30 <jmcarthur> "kmc wonders if Unicode Haskell should use ? instead of ?, as in ?? x ? x+1?" <-- looks like a "yo dawg"
10:37:43 <duairc> lispy: And I just realised the cause of it now and I'm like ;_;
10:37:44 <kmc> hmm
10:37:59 <kmc> jmcarthur, i think i'm sending UTF-8 these days
10:38:04 <duairc> lispy: fmap = liftM, which of course calls bind...
10:38:09 <jmcarthur> you probably are. it's probably my end
10:38:13 <kmc> ok
10:38:16 <duairc> And it would have been so easy just to give it a proper functor instance too
10:38:20 <mreh> > isSpace "\t"
10:38:22 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:38:22 <lambdabot>         against inferred type...
10:38:31 <mreh> > isSpace '\t'
10:38:31 <jmcarthur> i'm running through weechat->screen->ssh->sakura. lots of places it can go wrong
10:38:32 <lispy> duairc: ah
10:38:32 <ski> duairc : ooi, what type is this ?
10:38:32 <lambdabot>   True
10:38:55 <ski> > isSpace '\f'
10:38:56 <lambdabot>   True
10:39:01 <duairc> ski: It's just my own type
10:39:38 <ski> > ['^',chr (ord '@' + ord '\f')]
10:39:39 <lambdabot>   "^L"
10:39:56 <ski> duairc : yes, but how does it look like ? :)
10:40:09 <zygoloid> kmc: what's an involutive type?
10:40:29 <duairc> ski: A mess! :)
10:40:31 <duairc> ski: newtype Runner s = Runner (Bool -> IO (Either s (s, IO (), IO [(ByteString, Maybe ByteString)])))
10:40:37 <ski> zygoloid : a type constructor `F' such that `F (F x)' is the same type as `x'
10:40:42 * kmc does not know
10:40:56 <zygoloid> kmc: sorry, wrong tla :)
10:41:04 <kmc> oh i had another cute use for that symbol though
10:41:25 <kmc> > let (↦) = (,) in M.fromList ['x' ↦ 3, 'y' ↦ 4]
10:41:27 <lambdabot>   fromList [('x',3),('y',4)]
10:41:30 <zygoloid> ski: urk :/
10:41:36 <ski> zygoloid : e.g. `Flip (Flip f) a b' "ought" to be the same type as `f a b' :)
10:42:19 <ski> zygoloid : another use would be `Op (Op Obj)' being `Obj' for some type of objects in a category, and `Op' taking the opposite category
10:43:56 <zygoloid> ski: would something like "type family Flip (f :: * -> * -> *) a b; type instance Flip (,) a b = (b, a)" work ?
10:44:04 <nolrai_portland> Whats the easist way to get something that works like mapM but aplies to Data.Map?
10:44:11 <nschoe> Hi all.
10:44:43 <kmc> nolrai_portland, Data.Traversable.mapM ?
10:44:49 <kmc> hi nschoe :)
10:44:59 <zygoloid> @type \f -> mapM (uncurry f) . M.toList
10:45:00 <nolrai_portland> kmc: thanks!
10:45:01 <lambdabot> forall a b (m :: * -> *) b1. (Monad m) => (a -> b -> m b1) -> M.Map a b -> m [b1]
10:45:09 <zygoloid> nolrai_portland: ^^ i use that sometimes
10:45:23 <ski> zygoloid : well, it's not the same thing as i was considering .. but it might be interesting, as well
10:45:43 <kmc> the Traversable instance for Map only traverses the values, not keys
10:45:45 <nschoe> I've a simple question: I'm trying to find a way to get the current timestamp, have been hanging on haskell.org, on the System.Time section, but can't find anything clear, can I have a clue pleasEe?
10:45:58 <kmc> nschoe, in what format?
10:46:11 <nschoe> kmc: ideally an Integer or something like that.
10:46:14 <Lemmih> nschoe: Data.Time.getCurrentTime
10:46:15 <geheimdienst> @hoogle getZonedTime
10:46:15 <lambdabot> Data.Time.LocalTime getZonedTime :: IO ZonedTime
10:46:17 <kmc> epoch seconds?
10:46:28 <nschoe> kmc: yes.
10:46:31 <kmc> nschoe, System.Time is the old time library; Data.Time is newer
10:47:14 <kmc> if you want the raw epoch time on UNIX, System.Posix.Time.epochTime
10:47:26 <nschoe> kmc: yeah, I saw it on haskell.org, but that doesn't really help me.
10:47:34 <nschoe> Ah System.Posix... I knew I missed something.
10:47:47 <kmc> not portable obviously
10:48:02 <kmc> for that use Data.Time
10:48:05 <nschoe> kmc: yeah I was about toask.
10:48:15 <nschoe> kmc: is Data.Time portable?
10:48:18 <kmc> yes
10:48:30 <kmc> portable to different OS
10:48:45 <nschoe> okay, so, how would you extract the timestamp thanks to Data.Time module?
10:48:55 <kmc> the most portable would be the Haskell 98 "Time" module... portable as in portable to other Haskell implementations
10:49:21 <zygoloid> nschoe: do you want the current time or the timestamp of a file or something else?
10:50:21 <kmc> nschoe, you can get a UTCTime with getCurrentTime
10:50:28 <nschoe> zygoloid: Actually, I will have to manage files, and I will have to decide whether to backup a file or not, by analyzing the last modified time and last backed up time.
10:50:39 <kmc> you can get an Integer from the utctDay component
10:50:40 <nschoe> I thought using timestamp was the easiest method, apparently not.
10:51:30 <nschoe> My "problem" is that 'getCurrentTime' gives too many information: form what I get, can I compare easily two dates and see if I need to backup?
10:51:45 <kmc> nschoe, you can compare two UTCTime directly
10:51:48 <kmc> it implements Ord
10:52:14 <zygoloid> nschoe: for a file timestamp, you want something like this (again not portable): http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-Files.html#5
10:52:46 <msieradzki> how do I write while loop in haskell? :P
10:52:49 <kmc> is there a portable way to get file modification times?
10:52:53 <Lemmih> nschoe: How about using System.Directory.getModificationTime and System.Time.getClockTime?
10:52:57 <nschoe> zygoloid: Yes, I'm on that page already, thanks. But I need something portable, absolutely.
10:53:00 <kmc> msieradzki, how do i write PHP in Haskell
10:53:05 <c_wraith> msieradzki, with a zygohistomorphic prepromorphism
10:53:08 <Lemmih> nschoe: ClockTime is an instance of Ord.
10:53:10 <nschoe> msieradzki: recursivity? helper function? fold?
10:53:11 <kmc> msieradzki, describe what you want to do, not how you think you'd do it in another language
10:53:20 <msieradzki> searching for forever analog
10:53:25 <kmc> :t forever
10:53:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:53:37 <kmc> forever (putStrLn "Hello, world!")
10:53:44 <nschoe> Lemmih: yes okay, so I thing it is the means that suits me the best.
10:53:46 <msieradzki> great I know all of that already
10:53:56 <kmc> great
10:53:59 <zygoloid> > let while loop = while loop in while True
10:54:01 <kmc> why don't you tell us what you want to do
10:54:03 <ski> > iterate (2*) 1
10:54:03 <lambdabot>   mueval-core: Time limit exceeded
10:54:04 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
10:54:09 <djahandarie> lol zygoloid 
10:54:11 <nschoe> kmc: me?
10:54:15 <kmc> no msieradzki
10:54:27 <nschoe> kmc: ok, sorry.
10:54:29 <kmc> :)
10:54:43 <nschoe> Well, thanks for your hlep guy, I think I'll consider using UTCTime or so.
10:54:50 <nschoe> Have a good night/day!
10:54:53 <monochrom> while loop: fix (\loop -> do { s <- getLine; if s=="quit" then return () else loop)
10:55:03 <monochrom> fix is from Data.Function
10:55:03 <nolrai_portland> is there some library function that does what 'maybe (return Nothing)' does?
10:55:13 <nolrai_portland> @ty maybe (return Nothing)
10:55:14 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
10:55:17 <kmc> i don't think you can get file mod time portably
10:55:39 <nschoe> kmc: really?
10:56:22 <kmc> well i don't know how, and failed to find it just now
10:56:48 <kmc> in the standard lib anyway
10:56:52 <nschoe> kmc: ok, well I won't bother you anymore, I'll try to find by my own, didn't try it yet.
10:57:04 <kmc> i'm curious what you find if anything
10:57:25 <nschoe> kmc: in the worst case, I'll analyze the contents of the files (this way I won't need the dates anymore :/)
10:57:58 <nschoe> Well, really gotta go right now, I may come back if I have other problems, see you.
10:57:58 <noteed> ski: interested in my expression parser?
10:58:35 <ski> noteed : i could take a look :)
10:59:42 <noteed> ski, ok; basically it is the shunting-yard algorithm, modified to support distfix operators
11:00:06 <ski> noteed : i'd have to look that up :)
11:00:08 <noteed> ski, the modifications are not difficult but is makes much more cases
11:00:24 <noteed> ski: http://en.wikipedia.org/wiki/Shunting-yard_algorithm
11:00:58 <noteed> ski: basically it is a state machine that receives tokens
11:01:21 <sm> kmc, what makes you say http://hackage.haskell.org/packages/archive/directory/1.0.0.3/doc/html/System-Directory.html#v:getModificationTime isn't portable ?
11:02:03 <noteed> ski: when it is an operator token, it is pushed on a stack or pushed to the output, depending on the presence of another operator on the stack, and depending of the precedence/associativity
11:02:27 <kmc> sm, ah, i missed that.  thanks!
11:02:36 <sm> np
11:02:37 <noteed> ski: the result is a postfix notation in the wikipedia page but it can be a tree
11:03:18 <BMeph> :t (=<<) . return
11:03:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m b -> m a -> m b
11:04:09 <monochrom> what is distfix?
11:05:40 <BMeph> monochrom: I'd guess dist(ributed) fix(ity).
11:05:54 <noteed> monochrom: distfix or mixfix, it is operators that can have internal holes, be infix, prefix, postfix or closed
11:05:54 <ski> noteed : ok (more or less)
11:06:07 <monochrom> I see, thanks.
11:06:30 <noteed> monochrom: e.g. if _ then _ else _ can be viewed as of prefix operator with 2 internal holes
11:06:39 * ski thinks delimited continuations could be useful for something like this ..
11:07:09 <noteed> ski: did you looked at the example with the stack that grows and shrinks ?
11:07:27 <ski> (noteed : btw, have you tried writing a simple expression parser in Prolog, with a few operators with different fixities and precedences ?)
11:07:33 <tone1234> hey
11:07:45 <noteed> ski: nope
11:07:49 <rumpelstilzchen> meh, anyone ideas how to run a process with filehandles so that the handles are not closed?
11:07:55 <tone1234> can someone give a name, of a opensource project written tin haskell? without Xmonad?
11:08:21 <ski> noteed : i've implemented that algorithm once (explicitly, using a stack datastructure)
11:08:26 <zygoloid> tone1234: darcs
11:08:47 <noteed> ski: perfect :) well my parser is the same thing but with more rules
11:08:54 <zygoloid> tone1234: i believe the Linspire people use haskell pretty extensively
11:08:55 <lispy> tone1234: pugs
11:09:09 <lispy> tone1234: lambdabot
11:09:09 <sm> tone1234: hledger
11:09:20 <tone1234> Haskell is used for what?
11:09:23 <lispy> ALL OF HACKAGE!!  (sry, caps)
11:09:36 <lispy> tone1234: Haskell is used for win
11:09:41 <ski> noteed : well, the interesting part is really how you must rewrite left-associative rules like `E0 --> E0,"-",E1' to not use left-recursion
11:09:55 <mreh> is Parsec.many like a kleene star?
11:10:18 <noteed> ski: and it works, the central mechanism is the operator table and the way the next token is looked up in it, so it is probably possible to replace the table by a graph and define operator precedence with the edges of the graph
11:10:19 <zygoloid> mreh: perhaps if combined with try?
11:10:20 <tone1234> Haskell is not very used in OpenSource
11:10:42 <zygoloid> tone1234: (how could we forget?) ghc itself
11:10:50 <lispy> tone1234: except that it is, BSD3
11:11:01 <noteed> ski: there are no grammar, just an operator table
11:11:12 <mreh> opun surce gud
11:11:17 <noteed> ski: like the buildExpressionParser of Parsec
11:11:20 <monochrom> haskell is used for http://haskell.org/communities/ http://www.haskell.org/haskellwiki/Haskell_in_industry etc.  These are all just from http://www.haskell.org/haskellwiki/Haskell you could easily browse and read.
11:11:51 <lispy> tone1234: Haskell.org tends to get funded projects every year by GSoC
11:12:05 * hackagebot diffcabal 0.1 - Diff two .cabal files syntactically  http://hackage.haskell.org/package/diffcabal-0.1 (DonaldStewart)
11:12:14 <lispy> So, lots of Open Source Haskell stuff.  Tons of it
11:12:22 <Heffalump> ooh, excellent
11:12:38 <Heffalump> (diffcabal)
11:12:40 <sm> neat dons.. is syntactically the right word ?
11:13:49 <ski> noteed : yes .. but assuming you want to parse, say `e0 --> e0,"-",e1. e1 --> e1,"/",e2. e2 --> number | "(",e0,")".' (you could easily describe this with operators with precedences and fixities)
11:14:56 <ski> noteed : well, to make this more interesting, let's remove `e1 --> e1,"/",e2.' and instead add `e1 --> e2,"*",e1.'
11:15:11 * ski tries to recall how this approach went ..
11:16:35 <soupdragon> > let integral f = sum . map f $ [-10000,-10000+0.1..10000] in integral (\x -> cos x / (x^2 + 1))
11:16:37 <lambdabot>   11.557273427311857
11:16:42 <soupdragon> > pi / exp 1
11:16:43 <lambdabot>   1.1557273497909217
11:16:51 <Philonous> Can hayoo search for instances? 
11:17:10 <geheimdienst> @instances Eq
11:17:11 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:17:41 <Philonous> @instances Control.Monad.Error.Class.MonadError
11:17:42 <lambdabot> Couldn't find class `Control.Monad.Error.Class.MonadError'. Try @instances-importing
11:17:46 <djahandarie> I don't think so Philonous 
11:17:48 <noteed> ski: well, there is no restriction on what can appear in each hole, any expression is admitted
11:18:22 <Philonous> How would I go about finding conflicting orphan instances?
11:18:50 <zygoloid> Philonous: import all modules into the same module? :)
11:19:07 <zygoloid> (use "import Foo ()" to avoid name clashes)
11:19:10 <Philonous> Coming to think of it, they are not even really oprhan, just conflicting fun deps
11:19:49 <geheimdienst> philonous, let me guess: ghc yells at you about monads-tf conflicting with mtl, right?
11:20:34 <Philonous> geheimdienst: No, I've purged my ghc from the transformers scourge
11:24:12 * hackagebot diffcabal 0.1.1 - Diff two .cabal files syntactically  http://hackage.haskell.org/package/diffcabal-0.1.1 (DonaldStewart)
11:25:26 <djahandarie> Already found bugs apparently
11:25:35 <zygoloid> Philonous: no no the transformers are the heroes of the piece.
11:26:47 <geheimdienst> zygoloid, no, megan fox is the true hero
11:27:17 <tg_zzz> I thought michael Bay was the hero
11:28:37 <Philonous> zygoloid: Any remotely sane packe seems to use mtl, though. Andway, I've always preferred the bad guys 
11:30:23 <ski> @instances MonadError
11:30:24 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
11:31:14 <aristid> hmm, some people have a strange obsession with OOP. "no, i don't like that 'functional' code because it doesn't describe everything with messages"
11:31:50 <kmc> yeah, and then when they learn Haskell they use type classes and existential data types and new types everywhere, instead of values
11:32:06 <ski> (naturally describing things with messages is only half the picture .. you need *both* algebraic and coalgebraic types !)
11:34:39 <aristid> haha things like addition and multiplication are "unfortunately ugly utility functions", because they don't fit in the message framework
11:35:20 <kmc> yeah, functions with more than one argument suck
11:35:52 <kmc> of course plenty of object systems have multimethods, but that's lost on those who think OO == Java
11:36:06 <ski> (aristid : whence come this nonsense ?)
11:43:31 <Philonous> zygoloid: Btw. why do you think mtl is the culprid rathen then transformers? I've not looked into either, really
11:47:41 <luite> is there some clever way to quickly produce a list of numbers [n..m] with at least l and at most h bits set?
11:51:12 <Philonous> Strangely it turns out that it was just a missing parenthesis. Sometimes ghc's error messages are not really helpful
11:53:41 <zygoloid> Philonous: transformers/monads-fd/monads-tf is "new" ;-)
11:54:23 <Philonous> zygoloid: And what does it do what mtl doesn't? 
11:55:07 <Philonous> Except messing up code that somehow (even indirectly) imports mtl ;)
11:55:18 <edwardk> zygoloid/philonous: cuprit with regards to what?
11:55:24 <edwardk> er culprit
11:55:25 <kmc> luite, i would look in the book "hacker's delight"
11:55:35 <Saizan> Philonous: it's splitted in more packages/modules, that's all :)
11:56:00 <Saizan> though we might get a sane Monad (Either e) instance because of this..
11:56:06 <kmc> luite, what are some example values for (n,m,l,h)? and how fast?
11:56:06 <edwardk> transformers + monads-fd is basically mtl split into a haskell 98 and a non-98 component
11:56:07 <geheimdienst> philonous: the primary use of transformers/monads-fd/monads-tf is to confuse the hell out of geheimdienst because things that built fine just last month now produce weird conflicts in modules geheimdienst had never heard of before
11:56:51 <edwardk> i kind of wish that monads-fd and transformers weren't released until the plan for how to get folks to migrate whole hog from mtl to them was announced
11:57:06 <edwardk> because as they exist now all they do is splinter the community into incompatible fragments
11:57:45 <luite> kmc: n ~ 1-10,  m ~ 2^16, l ~ 2-12, h ~ 5-16
11:58:32 <edwardk> geheimdienst: heh i thought their main purpose was to make sure the entire community knew how to use ghc-pkg --hide ;)
11:58:39 <luite> kmc: not very large numbers, but i need to do it a lot with different values
11:58:41 <aristid> ski: you sure love the word "whence"?
11:58:59 <Saizan> edwardk: which apparently didn't work, since it's "ghc-pkg hide" :)
11:59:03 <Philonous> edwardk: --hide doesn't help when you import a library that is explicitly build against it, does it?
11:59:04 <ski> aristid : it's a useful word, at times, yes :)
11:59:07 <edwardk> Saizan: =)
11:59:24 <edwardk> Saizan: ... or to make sure that they use cabal for everything. you can guess which camp i'm in ;)
11:59:31 <geheimdienst> edwardk :) to force people to use cabal for building, because then you only put mtl in the .cabal file and the problem is solved
11:59:41 <geheimdienst> > let numOfBitsSet x = length $ filter (testBit x) [0..bitSize x] in filter (\n -> (numOfBitsSet n) `elem` [3..4]) ([42..87] :: [Int])
11:59:42 <lambdabot>   [42,43,44,45,46,49,50,51,52,53,54,56,57,58,60,67,69,70,71,73,74,75,76,77,78...
11:59:46 <ski> edwardk : noteed wanted you to tell her/him all about monodial parsing
11:59:47 <geheimdienst> > let numOfBitsSet x = length $ filter (testBit x) [0..bitSize x] in filter (\n -> (numOfBitsSet n) `elem` [3..3]) ([42..87] :: [Int])
11:59:48 <lambdabot>   [42,44,49,50,52,56,67,69,70,73,74,76,81,82,84]
11:59:56 * geheimdienst is so proud now
11:59:57 <edwardk> preflex: xseen noteed
11:59:57 <preflex>  noteed was last seen on freenode/#haskell 42 minutes and 9 seconds ago, saying: ski: well, there is no restriction on what can appear in each hole, any expression is admitted
12:00:05 <luite> kmc: oh and I'm porting the code from haskell to C for speed, so the actual performance in haskell doesn't matter that much, but it would be nice if the method is usable in C :)
12:00:10 <edwardk> ski: duly noteed
12:00:14 <aristid> ski: if you can read german, the nonsense comes from here: http://www.c-plusplus.de/forum/viewtopic-var-t-is-270643.html
12:00:26 <kmc> luite, yeah, i was thinking about low-level ways to do it in a C array with mutation
12:01:07 <kmc> luite, so let's first consider how to build an array containing all the n-bit numbers with exactly k bits set
12:01:11 <kmc> this is a useful subprob right?
12:01:13 <luite> I might port it back to haskell when I'm done, but the C library that I need (nauty) uses lots of low level bit manipulation, so it may take some effort to get it fast in haskell
12:01:19 <kmc> i'd bet hacker's delight says something about it
12:01:27 <kmc> lemme check
12:01:41 <edwardk> luite: funny, i've been finding myself porting old c code to haskell for the same reason ;)
12:01:42 <CakeProphet> so I think I'm going to use cflabels, but I don't really like the underscore and TH stuff. Is it possible to manually construct the labels?
12:01:53 * ski recalls learning "I will mit mein Kopf arbeiten. Am liebsten mchtest Ich schlafen." by heart in german class
12:01:58 <edwardk> CakeProphet: yes, they just take two functions
12:02:16 <kmc> CakeProphet, why don't you like it?
12:02:25 <aristid> ski: lol what a useful phrase
12:02:37 <geheimdienst> edwardk ports from c to haskell, luite ports from haskell to c. luite and edwardk are like matter and antimatter
12:02:54 <CakeProphet> kmc:  the template Haskell is fine. For some reason the underscores just look nasty to me. :P  I guess it doesn't really matter. I might as well use the TH Haskell since it does the work for me.
12:02:57 <geheimdienst> ski, GermanLanguageParseException
12:03:11 <Saizan> you could chain them together and have perpetual coding!
12:03:25 <geheimdienst> saizan, or a crude warp drive
12:03:48 <CakeProphet> very crude. only warps at O(n!)
12:04:05 <luite> geheimdienst: actually I implemented non-isomorphic unlabelled graph generation algorithm in haskell (geng.c in nauty) to understand the algorithmm
12:04:55 <geheimdienst> luite, i'm just being silly :-) just kidding
12:05:14 <ski> (geheimdienst : i actually expected that .. it's been a while)
12:05:32 <CakeProphet> are there any definite plans to change records in the future? or is it all unconsidered proposals at this point.
12:06:23 <kmc> lots of consideration
12:06:24 <kmc> no consensus
12:06:36 <mreh> lots of solutions on hackage
12:06:59 <mreh> can't you use TH?
12:07:52 <luite> kmc: this looks interesting, Hacker's delight: Fig. 2-1. Next higher number with same number of 1-bits. 
12:09:18 <kmc> aha!
12:09:23 <luite> view-source:http://www.hackersdelight.org/HDcode/snoob.c
12:09:35 <luite> thanks :)
12:09:49 <kmc> yes, i tried to understand this function once :)
12:09:57 <luite> oh that url may not work in non-chrome browsers :)
12:10:02 <CakeProphet> the basic idea behind cflabels seems like the best solution in my mind. Some of the composition stuff could use modification as it's a bit confusing.
12:10:39 <ski> noteed : hm something like `parseE0 = do {e0 <- parseE0; returnE0 e0}; returnE0 e0 = do {tokenMinus; e1 <- parseE1; returnE0 (Sub e0 e1)} `mplus` do {return e0}'
12:13:38 <geheimdienst> anyone have any critique on my solution?
12:13:46 <geheimdienst> > let numOfBitsSet x = length $ filter (testBit x) [0..bitSize x] in filter (\n -> (numOfBitsSet n) `elem` [3..3]) ([42..87] :: [Int])
12:13:46 <lambdabot>   [42,44,49,50,52,56,67,69,70,73,74,76,81,82,84]
12:14:40 <ski> noteed : and then `parseE1 = do {e2 <- parseE2; tokenTimes; e1 <- parseE1; return (Mult e2 e1)} `mplus` do {e2 <- parseE2; return e2}', &c. (probably left-factoring here)
12:15:31 <ski> noteed : the interesting point being `returnE0' above .. which behaves a bit like a delimited continuation, imo
12:18:08 <edwardk> Saizan: nah, i think you overlook that there is a conservation law in there about how it uses up the programmers. ;)
12:19:57 <edwardk> CakeProphet: i like fclabels, but it irks me that it depends on monads-fd needlessly
12:22:07 <kmc> @hoogle iterateM
12:22:08 <lambdabot> No results found
12:24:32 <kmc> :t scanl (>>=)
12:24:33 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> [m b]
12:24:50 <kmc> :t (sequence .) . scanl (>>=)
12:24:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> [a -> m a] -> m [a]
12:25:16 <kmc> :t \x f -> sequence $ scanl (>>=) (return x) (repeat f)
12:25:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> (a -> m a) -> m [a]
12:27:43 <adnap> Hey, has anyone used happstack before?  Can someone explain to me the concept of writing a web application without a database?  How do you permanently store information?  I'm a bit naive.
12:31:00 <noteed> edwardk: hello
12:31:28 <edwardk> heya noteed. you had some questions?
12:31:36 <noteed> edwardk: actually it wasn't me who wanted to know everything, but still it interests me
12:31:54 <edwardk> ah. looking through logs. was it aristid?
12:32:07 <EvanR-work> adnap: does it just use regular values which you can query / alter, and are automatically backed by disk?
12:32:14 <noteed> edwardk: yes, it is possible
12:32:37 <aristid> edwardk: well i wanted to know what monoidal parsers are. but i read two of your slide sets now, and one of them helped
12:32:47 <aristid> edwardk: but not completely
12:33:11 <aristid> this one helped: http://comonad.com/reader/wp-content/uploads/2009/08/IntroductionToMonoids.pdf
12:33:19 <edwardk> aristid: well i have two slide sets up there on monoids and one on 'iteratee parsec and monoids' which is about a dirty hack, not the monoidal parsing machinery i'd been using up to that point
12:33:23 <edwardk> ah
12:33:28 <noteed> edwardk: because we were talking about parsers being somewhat left-biased, and ski said you invented monoidal parsing
12:34:20 <edwardk> noteed: yeah, the trick is finding grammars (like tree adjoining grammars) for which it is suitable, and defining parser combinators that can parse that way =)
12:35:08 <edwardk> aristid: so given those slides you can at least see how some common parsing problems can be broken up on arbitrary boundaries and parsed fragmentwise before stitching the answers together
12:35:50 <edwardk> and how you can use monoids to factor out some 'ancillary parsing concerns' like file position, dealing with line directives, utf-8, etc.
12:36:43 <edwardk> from there, it is enlightening to note that you can parse regular expressions easily with a monoid
12:37:54 <aristid> edwardk: why does monoids not install?
12:38:19 <edwardk> just compile the regex down to a DFA and have the monoid be a mapping of input states to output states. the unit of the monoid maps all states to themselves, you 'reduce' a char by turning it into the mapping of what that char does to each input state. you compose them by just composing the mappings
12:38:22 <adnap> EvanR-work: So, if I were to build a site, it would need to store information like posts.  How are these saved on disk and read out by the web application?
12:38:28 <edwardk> aristid: good question. i haven't installed it in a while
12:38:31 <edwardk> try 0.1.36
12:39:11 <edwardk> looks like it wants an old version of array
12:39:20 <edwardk> i just need to relax that dependency
12:39:45 <adnap> EvanCarroll: It seems like most of the code in the happstack examples I've seen deal with http requests and then spit something back out.
12:40:06 <aristid> edwardk: reducing a char is unit ch?
12:40:17 <edwardk> aristid: yeah
12:40:33 <aristid> so that's the "unit automaton" basically?
12:40:53 <aristid> oh no
12:41:15 <edwardk> so mempty = the identity map, unit c = maps each state to the state it will be taken to by the character c, mappend composes the transition tables
12:41:48 <aristid> edwardk: that requires a newtype for each regex?
12:41:52 <edwardk> so you can quickly recognize a regular expression with a cheap monoid. this is enough to be able to build a monoidal lexer
12:42:08 <edwardk> aristid: naively, yes, but you can use 'reflection' to make each regex into a distinct type
12:42:19 <aristid> reflection? oO
12:42:32 <edwardk> @hackage reflection
12:42:32 <lambdabot> http://hackage.haskell.org/package/reflection
12:42:44 <edwardk> makes arbitrary terms into types that you can reflect back down
12:43:09 <edwardk> effectively, you can encode an arbitrary integer into a type right?
12:43:36 <edwardk> and a stableptr is just an integer...
12:44:57 <aristid> edwardk: that doesn't give me the Warm Fuzzy Feeling
12:45:14 <soupdragon> the inertia 'tensor' looks like a matrix to me
12:45:15 <edwardk> then once you can lex, you can get out a stream of tokens... but you'll finish recognizing tokens all out of order, so you get them... monoidally, and feed them to a monoidal reducer that knows how to deal with tokens
12:45:49 <edwardk> aristid: it is all perfectly safe. ;) the package takes care of the scary bits
12:46:41 <edwardk> you can do things like balancing parentheses, matching up layout rules, etc. by using another monoid of 'bitonic sequences'
12:46:45 <aristid> edwardk: isn't there are more direct and nice way?
12:46:55 <edwardk> aristid: no. or i wouldn't be using this one ;)
12:47:04 <EvanR-work> soupdragon: no! stop pointing out the emperors no clothes
12:47:10 <soupdragon> he
12:47:21 <aristid> edwardk: well maybe you need another typeclass which is not a Monoid but still captures this essence
12:47:24 <edwardk> well, there is, but it has fewer type safety guarantees and you can't use the existing monoid class, etc.
12:47:35 <Guest57992> @pointful (\x -> \y -> \z -> x (y z) z )
12:47:36 <lambdabot> (\ x y z -> x (y z) z)
12:47:41 <edwardk> i find that the reflection machinery is less scary than it sounds
12:48:30 <Guest57992> @pointful .
12:48:30 <lambdabot> (\ a b c -> a (b c))
12:49:00 <edwardk> it can be quite useful actually, for instance i have a fixed precision number library that uses it (optionally) to pass a runtime specified precision value and to exploit unification to make sure it is consistent, etc.
12:50:31 <aristid> edwardk: i don't understand it, which makes it more scary
12:50:50 <edwardk> aristid: there is a very nice paper
12:51:04 <edwardk>  We shut down all our Apache servers and the bad traffic was still coming.  We pulled the plug on the DNS server and the traffic kept coming.  And then we realized: the traffic was coming from inside the building! (scream)
12:51:07 <edwardk> er woops
12:51:13 <edwardk> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
12:52:35 <edwardk> anyways, i wind up reifying much more complicated things than just DFAs ;0
12:53:49 <aristid> edwardk: is it basically a simulation of DT?
12:53:53 <edwardk> you can do the same thing with a compiled applicative grammar, since it isn't a huge step from DFAs to context-free grammars, and an applicative can be used to handle context-free attribute grammars (technically they admit infinite cfgs though)
12:53:56 <edwardk> DT?
12:54:20 <edwardk> dependent types?
12:55:09 <edwardk> it gives you access to a very limited form of dependent types. you wind up with a universal quantification constraint that witnesses the equality of a term and gives you access to it
12:56:41 <edwardk> you could define it on a more ad hoc basis type by type, but the 'temporary stable ptr' version works across all types.
12:57:24 <edwardk> reify x reflect = x
12:57:24 * jmcarthur thinks that saying something is a limited form of dependent types isn't saying much
12:57:46 <edwardk> jmcarthur: larger than a GADT, smaller than a breadbox ;)
12:57:53 <jmcarthur> heh
12:58:02 * geheimdienst thinks haskell is a limited form of a General Problem Solver
12:58:49 <dolio> It is basically mimicking something that would be natural with dependent types.
12:59:16 <aristid> "you wind up with a universal quantification constraint that witnesses the equality of a term and gives you access to it"
12:59:17 <aristid> of course
12:59:23 <aristid> why did i not immediately see that
12:59:30 <edwardk> aristid: in any event, regardless of the machinery, if you build up a specific type for each particular grammar you want to recognize or if you use reflection to absract it away, the model doesn't change
13:00:12 <edwardk> aristid: you just get: reify  :: a -> (forall s. Reifies  s a => Tagged  s w) -> w -- and reflect  :: Reifies s a -> Tagged  s a
13:00:19 <aristid> edwardk: does reflect allow grammars to be values?
13:00:22 <edwardk> where you can use Tagged s as an Applicative, Monad, etc.
13:00:25 <edwardk> yes
13:00:42 <edwardk> any type a could be the value you reified and then reflected back down
13:00:52 <edwardk> er rather the value could have any type a
13:01:11 <edwardk> reify (+) reflect :: Num a => a -> a -> a
13:02:09 <edwardk> reify (+) (do f <- reflect; return (f 1 2)) = 3 :: Num a => a
13:02:15 <dolio> You want to have a type constructor Foo :: T -> *, where T is whatever 'static' data you want to keep track of. So instead you reconstruct T at the type level, and have a function T -> (exists t. Foo t). Or something like that.
13:03:18 <edwardk> reifyIntegral/reflectNum are less scary, they just use a few types like Zero, Double a, Pred a and a typeclass on that
13:04:07 <Apocalisp> @type (>>=)
13:04:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:05:05 <dolio> The only difference is that in a suitable dependently typed language, the 'static' data wouldn't really be static, per se. But then, it isn't really in Haskell, either.
13:06:02 <aristid> edwardk: so reify X reflect == X?
13:06:17 <edwardk> aristid: yeah
13:06:42 <edwardk> except you can reflect multiple times and always get the same answer and write an arbitrary expression in the 'Tagged' monad on the right instead of just reflect =)
13:06:46 <aristid> what can i do with reify X other than apply with reflect?
13:07:08 <Trevion> Anyone know of some fairly simple, complete examples of using OpenGL VBOs in Haskell?  There's an example in the GLUT/examples/Misc directory, but it's a bit more complex and doesn't run on current WGL environments...
13:07:35 <monochrom> I start ghci, use a value from a package, causing it to be linked; then I edit the package and reinstall, same version number. I haven't quit ghci yet. Is there a way to tell the running ghci to link the edited package?
13:08:22 <aristid> edwardk: like reify (+) (do x <- reflect; y <- reflect; return (x, y))?
13:09:03 <edwardk> yeah
13:09:28 <aristid> but what does that buy me?
13:11:14 <edwardk> it buys you the fact that you can define data SomethingInteresting s a = SomethingInteresting ... -- and exploit the fact that all SomethingInteresting's with the same s, where Reifies s b -- will share the same value for the value of type b that they can reflect
13:11:26 <edwardk> i.e. a common modulus for modular arithmetic
13:11:29 <edwardk> er e.g.
13:13:30 <sbpaul> BONUS needs to finish LYAH
13:15:17 * djahandarie readies the whip
13:15:17 <edwardk> so you can define newtype Match s = Match (Array Int Int); instance (s `Reifies` DFA) => Monoid (Match s) where ...
13:15:29 <edwardk> (or UArray, etc)
13:16:21 <CakeProphet> what's the easiest way to install libraries (in particular, fclabels) on a machine that I don't have root access to? 
13:16:37 <CakeProphet> for use in my application.
13:16:41 <edwardk> mempty = do { x <- reflect; return (listArray (0, size x - 1) [0..]); }; mappend = ...
13:16:46 <edwardk> er 
13:16:56 <sioraiocht> anyone have any clue what this error is about when running lhs2TeX
13:16:58 <sioraiocht> lhs2TeX: Enum.toEnum{Word8}: tag (8743) is outside of bounds (0,255) 
13:17:15 <sioraiocht> it happens after reading in a file that is simply a series of formattive directives
13:17:24 <edwardk> er actually there is a _little_ more plumbing because that returns a Tagged s (Array Int Int) -- not a Monoid s but you get the idea
13:17:30 <aristid> edwardk: so you monadically build the Monoid and then apply it to the reified value to move it in there?
13:17:31 <edwardk> er s/Monoid/Match/
13:18:26 <edwardk> effectively. usually i exploit the applicative instance because i more or less by construction never need the full power of the monad.
13:19:19 <wlangstroth> CakeProphet: is cabal not working? Pretty sure cabal doesn't need/use root access
13:20:00 <Philonous> CakeProphet: use cabal-install or cabal configure --user 
13:20:21 <CakeProphet> wlangstroth:  well, it's a future problem at the moment so I haven't actually tried anything yet. I didn't know root access wasn't required. I assume cabal needs write access to the standard import path, correct?
13:20:27 <CakeProphet> I may or may not have that, I'm not sure.
13:20:35 <CakeProphet> it depends on what kind of hosting I get.
13:21:27 <Guest86621> @pointfree (\x -> \y -> \z ->  x ( y  (z x)) )
13:21:27 <lambdabot> Unknown command, try @list
13:21:36 <CakeProphet> Guest86621:  try @pl
13:21:36 <Guest86621> @pointless dsafdsfa
13:21:36 <lambdabot> dsafdsfa
13:21:37 <edwardk> aristid: so now that you can recognize tokens, the next step is recognizing matched pairs, and then parsing between them. i use a monoid of 'bitonic sequences'
13:22:15 <Guest86621> @pointless (\x -> \y -> \z -> x (y ( z x)))
13:22:15 <lambdabot> liftM2 (.) (.) (flip (.) . flip id)
13:22:16 <edwardk> basically what i have is a monoid that has a set of 'unfinished closing contexts', a fully parsed payload, and a set of 'unfinished opening contexts'.
13:22:26 * geheimdienst uses a monoid of gintonic sequences
13:22:35 <edwardk> for example, in the simplest parser i can think of: ))))((
13:22:53 <edwardk> then ))))(( + )((( = ))))((((
13:23:04 <ski> (gehmehgeh : not "bitonic", then ?)
13:23:42 <aristid> edwardk: i'm not sure how reify+reflect differs from the Reader monad?
13:23:49 * ski realizes edwardk already said that ..
13:24:41 <edwardk> aristid: a fairly keen observation.
13:25:06 <CakeProphet> in the fclabels package description, it says that type signatures are not generated for the label values. Are they /needed/? I don't see why they would be.
13:25:19 <edwardk> aristid: consider sharing
13:25:56 <edwardk> newtype Match s = Match (UArray Int Int) -- vs. newtype Match s = Match (s -> UArray Int Int)
13:26:06 <edwardk> er
13:26:18 <edwardk> newtype Match = Match (DFA -> UArray Int Int)
13:26:43 <edwardk> the latter can be made into an monoid as well
13:26:52 <sbpaul> > takeWhile (/='121') (map (**2) [1..])
13:26:53 <lambdabot>   <no location info>:
13:26:53 <lambdabot>      lexical error in string/character literal at chara...
13:27:11 <sbpaul> !more
13:27:14 <sbpaul> crap
13:27:21 <edwardk> but it builds up a accumulation of what to do and runs it all at once at the end, rather than being able to compute 'online'
13:27:36 <dolio> '121' is not a valid character literal.
13:27:48 <sbpaul> > takeWhile (/=121) (map (^2) [1..])
13:27:49 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
13:27:49 <sbpaul> no joke
13:28:06 <geheimdienst> > '\121'
13:28:07 <lambdabot>   'y'
13:28:12 <geheimdienst> woah
13:28:23 <illissius-> it's a good thing difficulty understanding things doesn't give me headaches, like allegedly it does for some people
13:28:26 <aristid> edwardk: and Reader has the same problem?
13:28:27 <illissius-> else I'd be having a major one
13:28:41 <CakeProphet> if I specify that a symbol be hidden on import, can I still access it qualified?
13:29:05 <geheimdienst> > '\2603'
13:29:06 <lambdabot>   '\2603'
13:29:12 <edwardk> aristid: Reader is just (->) hidden behind a crappy newtype ;) so yes
13:29:13 <monochrom> yes, add another import statement for it
13:29:48 <geheimdienst> > '\9731'
13:29:49 <lambdabot>   '\9731'
13:30:05 <CakeProphet> monochrom:  import M hiding (example); import qualified M   --like that?
13:30:35 <aristid> edwardk: whereas reify has more or less the same semantics but more online-ness?
13:30:37 <CakeProphet> monochrom:  no, that seems redundant.
13:30:45 <sbpaul> > map chr $ map (\x->x-2) [121,106,123,34,112,107,106,107,110,107,117,118,46,34,121,106,123]
13:30:46 <lambdabot>   "why nihilist, why"
13:30:49 <edwardk> aristid: yeah
13:30:54 <sbpaul> > map chr $ map (\x->x-2) [106,107,34,69,99,109,103,82,116,113,114,106,103,118]
13:30:55 <lambdabot>   "hi CakeProphet"
13:31:00 <monochrom> not redundant. it's fine and useful
13:31:08 * sbpaul whistles
13:31:16 <sbpaul> > map chr $ map (\x->x-2) $ filter (<100) [106,107,34,69,99,109,103,82,116,113,114,106,103,118]
13:31:18 <djahandarie> For a second I thought it was the same list of numbers with a differen toffset
13:31:18 <lambdabot>   " CaP"
13:31:19 <CakeProphet> monochrom:  I thought an unqualified import also included a qualified import?
13:31:20 <dolio> reify is a version of reader where you're passing around a type class dictionary instead of a value. :)
13:31:24 <edwardk> aristid: if you think of reify as a sort of magical version of runReader you've got more or less the right intuition.
13:31:25 <sbpaul> > map chr $ map (\x->x-2) $ filter (>100) [106,107,34,69,99,109,103,82,116,113,114,106,103,118]
13:31:26 <lambdabot>   "hikerophet"
13:31:54 <monochrom> but the unqualified import omits example
13:32:03 <djahandarie> Note that map f . map g is map (f . g)
13:32:09 <CakeProphet> monochrom: even when I do M.example?
13:32:23 <sbpaul> djahandarie: yes..<_<
13:32:25 <edwardk> (that and you are not allowed to (ab)use 'local')
13:32:26 <sbpaul> >_>
13:32:28 <monochrom> yes.
13:32:51 <CakeProphet> hmmm, okay.
13:33:23 <CakeProphet> I always thought hiding only affected the top-level namespace, and qualified namespaces were unaffected.
13:34:05 <CakeProphet> since a qualified namespace is generally unambiguous, there would be no need to hide symbols in it.
13:34:20 <monochrom> this is why learning from a O(1) number of sources is not enough.
13:34:22 <Saizan> edwardk: though "Reify s a => Tagged s b" and "Reader a b" have more-or-less the same underlying implementation, no?
13:34:25 <edwardk> aristid: so basically what i have are a set of combinators for dealing with tokenizing monoidally, matching bitonic sequences out of the tokenstream, and then parsing those delimited fragments independently. i also have machinery for building up parsers using applicative combinators
13:35:34 <Saizan> maybe GHC is more clever when comibining two of the former though..
13:35:39 <edwardk> Saizan: yes, but the compiler has a lot more freedom when it comes to ditching dictionaries when it doesn't need them.
13:35:50 <bos> preflex: seen dons
13:35:50 <preflex>  dons was last seen on #ghc 2 hours, 9 minutes and 3 seconds ago, saying: dcoutts: i think extensible-exceptions-0.1.1.1 has snuck into the platform.
13:35:57 <edwardk> plus if you look at it, the resulting types differ quite a bit
13:36:23 <edwardk> newtype Match s = Match (Array Int Int) -- is very different than newtype Match = Match (DFA -> Array Int Int)
13:36:33 <edwardk> the former can't be reused over and over on different DFAs
13:36:39 <edwardk> the other builds up a reusable computation
13:37:04 <edwardk> so a monoid on the former has a very different operational interpretation than a monoid on the latter.
13:37:27 <elzurk1> If I add an extra value constructor to a type that is being used by other people, does that break their functions?
13:38:36 <edwardk> you could build a 'class MonoidWithEnv a e where memptyEnv :: e -> a; mappendEnv :: a -> a -> e -> a' -- or even 'class Monad m => MonoidM a m where memptyM :: m a; mappendM :: a -> a -> m a' -- and use that with the reader monad
13:38:55 <edwardk> and with THAT you could recover the implementation that the monoid for dfa tabulation has
13:39:06 <edwardk> but it wouldn't be a Monoid
13:40:10 <edwardk> fitting the shape of a monoid distributes the lambda over the newtype wrapper, meaning it happens too late, and you wind up building up a massive intermediate computation
13:40:21 <CakeProphet> What does hackage use to generate docs?
13:40:28 <Zao> Haddock?
13:40:38 <CakeProphet> ...dunno why I asked. :P
13:41:02 <CakeProphet> well, no. I know why I asked, but I don't know why I didn't already know the answer by intuition. 
13:41:12 <edwardk> Saizan: er did that make sense?
13:41:18 <illissius-> edwardk: does the gain from ditching dictionaries outweigh having to do stableptr stuff in the implementation?
13:41:35 <edwardk> illissius-: well, one completes in my lifetime, the other does not, so yes ;)
13:41:41 <aristid> edwardk: would reify look much differently if you were to use AT instead of fundeps?
13:41:45 <illissius-> i see :)
13:41:56 <edwardk> aristid: turns out the AT stuff isn't mature enough to work there =(
13:42:09 <edwardk> if you redefine it using ATs you can't typecheck reify
13:42:27 <Saizan> edwardk: yeah i think so :), i get the general issue of being able to share/partial evaluate only when the lambdas are in the right places, i'd probably have to look at the produced core to fully grasp the difference though :)
13:42:32 <aristid> edwardk: is that a conceptual problem of ATs, or a matter of implementation?
13:42:40 <edwardk> aristid: i think just implementation
13:42:46 <edwardk> i've tried it off and on since 6.10
13:42:54 <edwardk> (it would be prettier with an AT)
13:43:03 <jmcarthur> CakeProphet: you can give qualified namespaces the same name, e.g.  import qualified Foo as A; import qualified Bar as A
13:43:11 <jmcarthur> CakeProphet: so you can still introduce ambiguities
13:45:13 <cap11235> I've been reading through "Tackling The Awkward Squad", and I was wonder what the advantage of using a Stream over a list is. Is the only difference that a Stream must be infinite?
13:45:29 <CakeProphet> jmcarthur:  oh, interesting. Do you know  any practical examples where a namespace "union" like that is useful?
13:45:41 <edwardk> illissius-: plus there is the fact that the internals of reflection haven't changed at all -- though i;ve changed the public api a couple of times --  they are remarkably stable, and while they use a couple of dirty-seeming tricks, they are sound under a number of variations on haskell's semantics.
13:45:57 <dolio> The advantage is sometimes you might want streams, and lists are the wrong datatype.
13:46:05 <edwardk> illissius-: so i'm rather content to treat it like a black box and just exploit the dependent type-like functionality it grants me
13:46:05 <jmcarthur> CakeProphet: getting a few functions for different submodules of the same module, for example
13:46:28 <jmcarthur> CakeProphet: import qualified Graphics.Rendering.OpenGL.Foo as GL; import qualified Graphics.Rendering.OpenGL.Bar as GL
13:46:48 <cap11235> dolio: So then the only difference in implementation is that you can have finite lists?
13:46:52 <jmcarthur> CakeProphet: *modules with a common prefix, i mean
13:46:57 <illissius-> edwardk: if i want to understand all of this, in what order do you recommend i stare at the 'implicit configurations' paper, your 'clearer reflections' blog post, the reflection api docs, the discussion just now, and/or other things?
13:47:00 <dolio> Yes.
13:47:01 <CakeProphet> jmcarthur:  ah okay. So a "partial" import of OpenGL, in a way.
13:47:15 <cap11235> Ok, thanks.
13:47:21 <jmcarthur> well, if you look at the opengl bindings there's a lot of modules there
13:47:39 <jmcarthur> they don't really have clashing identifiers in them though
13:48:03 <edwardk> illissius-: the comments here are pretty straightforward, the paper is a little 'Oleggy' but i think quite readable, the reflection api docs show how i get away from the use of 'undefined' everywhere by using data.tagged.
13:48:31 <Saizan> edwardk: or is it simply because the environment in the reader monad comes as the last parameter while dictionary is the first?
13:48:38 <CakeProphet> jmcarthur:  does GHC allow qualified namespaces to have the same ambiguities as top-level? Obviously it will fail to compile if you reference an ambiguous name, but I'm talking about the case where you don't.
13:49:13 <dolio> It should.
13:49:26 <CakeProphet> dolio:  indeed it should. :)
13:49:28 <jmcarthur> CakeProphet: i don't think i understand, but i'm guessing you mean will A.map be ambiguous if you do import Data.List as A; import Data.Vector as A?
13:49:36 <CakeProphet> correct.
13:49:40 <CakeProphet> well, no
13:49:41 <jmcarthur> and the answer is yes, that would be ambiguous
13:50:04 <CakeProphet> that's what I mean, but not the question. I'm asking if that's /allow/, as long as you don't reference the ambiguous names. Much like top-level.
13:50:10 <CakeProphet> *allowed
13:50:10 <jmcarthur> yes
13:50:19 <edwardk> Saizan: nah, its that mappend effectively handles the dictionary argument with reflection, where as it is the resulting monoidal value that handles it with reader.
13:50:27 <illissius-> edwardk: I think I'll look at the paper and then reread this conversation again.. :)
13:50:34 <jmcarthur> you are still allowed to do:  import Data.List as A; import Data.Vector as A
13:50:50 <jmcarthur> just like you're allowed to do it without the "as A" parts
13:50:51 <monochrom> omg it is allowed
13:51:20 <aristid> edwardk: do           pure <$> deRefStablePtr p <* freeStablePtr p
13:51:23 <edwardk> illissius-: i made a few posts to the mailing list describing how to do similar things with it, under the older api
13:51:28 <aristid> edwardk: isn't the "do" unnecessary there?:)
13:51:41 <edwardk> aristid: yes =)
13:53:40 <CakeProphet> jmcarthur:  okay. But hiding /does/ omit symbols from the qualified namespace as well as top-level?
13:55:37 <edwardk> aristid: redundant 'do' removed in head
13:55:41 <monochrom> omg omg it even works.  import Control.Monad as A (forever); import Control.Concurrent as A (threadDelay); then A.forever and A.threadDelay work.
13:57:02 <edwardk> monochrom: yeah kind of annoying that you can't say import Control.Foo as A hiding (foo) import Control.Bar as A (foo) -- though =/
13:57:07 <monochrom> and the haskell98 report doesn't seem to forbid it. fun.
13:57:12 <edwardk> er import qualified Control.Foo as A hiding (foo)
13:57:23 <Cale_> Of course it works. It's even useful.
13:58:22 <Cale_> If you're importing a bunch of modules from the same package which have been annoyingly split up into pieces that are too fine, it's nice to be able to qualify them all the same way.
14:00:06 <monochrom> I might yet apply that to the GHC API. :)
14:00:24 <CakeProphet> I think any kind of "limitation" on the import mechanism is to alleviate a syntax nightmare.
14:00:25 <edwardk> i may blog that 'why use reflection rather than reader' answer
14:01:58 <CakeProphet> though a simpler import syntax for large lists of modules would be convenient:  import Control.Monad, Data.List, ...   but I think I understand why one module per line is preferred, since the import mechanism is rather complex.
14:02:55 <aristid> edwardk: is there a case where Reader is better than reify+reflect?
14:03:04 * geheimdienst says import *.*
14:03:22 <CakeProphet> ...eh. But that gives me Java flashbacks.
14:03:45 <CakeProphet> An ideal programming language should try to lessen the number of Java flashbacks a given programmer might have when working with the language.
14:04:01 <aristid> geheimdienst: import DWIM
14:04:29 <monochrom> An ideal programming language does not even use plain text. You will not see the word "import" appearing a million times.
14:04:42 <geheimdienst> -XForAnyUnknownNameUseHayooAndImport,DownloadingFromHackageIfNecessary
14:05:10 <CakeProphet> -XBreakAllSemblanceOfPortability
14:05:17 <hpc> -XDoAsIMeanNotAsISay
14:05:17 <CakeProphet> I think that will include the above option.
14:05:26 <aristid> monochrom: i think plain text is a very good choice, because it is so universal
14:05:56 <aristid> it doesn't require a special editor, it allows usage of standard tools like git, sed, ...
14:05:59 <geheimdienst> monochrom, in some languages (cough lisp cough) "import" would be a function so you could say "map import [A, B, C]" or similar
14:06:25 <CakeProphet> the main advantage of plain text is that it is simple to edit, and portable to edit. No GUI tools are strictly necessary to program. 
14:06:36 <CakeProphet> only a text editor of some kind.
14:06:43 <aristid> or a typewriter
14:06:52 <CakeProphet> well, depends on the encoding, but yes.
14:06:55 <Eridius> or a hex editor
14:07:04 <monochrom> @quote 1970s.terminal
14:07:04 <aristid> *imagines programming with an old mechanic typewriter*
14:07:05 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
14:07:08 <CakeProphet> or a terminal command.
14:07:35 <hpc> or a telegraph machine jurry-rigged to a hard drive
14:07:46 <CakeProphet> However, I see no reason not to support other source code formats.
14:08:00 <aristid> hpc: or M-x butterfly
14:08:32 <FunctorSalad_> haha lambdabot
14:08:33 <bos> tibbe: evening
14:09:01 <FunctorSalad_> maybe because there isn't a better terminal notion yet and they're still better than many guis...
14:09:23 <CakeProphet> hmmm, so how does .lhs work exactly? I know every line with a > is a Haskell source line, but I've seen literate Haskell used in webpages, complete with syntax highlighting. How does that work?
14:10:15 <ClaudiusMaximus> CakeProphet: hscolour tool
14:10:20 <monochrom> some other program does the colouring
14:10:47 <hpc> it's javascript, so you can still copy the base text
14:10:59 <geheimdienst> cakeprophet, coloring is not a literate haskell thing. either you have a tool that reads haskell and produces html with all the colors, or you do it client-side, i.e. some javascript with colorizes
14:11:14 <geheimdienst> *which
14:11:35 <int80_h> has anyone here used yesod in production?
14:11:52 <ClaudiusMaximus> hpc: ah, that sounds like a nice solution
14:12:21 <edwardk> aristid: well, yes, sometimes you really do want to build up a computation that you can run with multiple inputs
14:12:42 <aristid> edwardk: flip reify?
14:12:49 <geheimdienst> i think you can copy-paste no matter if there's html colors
14:12:56 <edwardk> aristid: ?
14:13:12 <edwardk> aristid: finding the arg order unnatural?
14:13:29 <hpc> geheimdienst: i think it depends; on windows, you can copy to notepad as plaintext, or to word as richtext
14:13:40 <aristid> edwardk: no, but flip reify Comp allows you to apply multiple inputs
14:13:56 <hpc> :t reify
14:13:57 <edwardk> aristid: i kept the arg order the same as the original paper 
14:13:58 <lambdabot> Not in scope: `reify'
14:14:11 <edwardk> ah
14:14:11 <aristid> edwardk: i don't want to say the arg order is bad
14:14:30 <edwardk> you can probably make reify do everything you can do with reader honestly
14:14:41 <geheimdienst> yeah, but considering it's code, you probably paste it into a terminal with ghci or into an editor, not into ms word :)
14:14:47 <edwardk> the only overhead is the brief lifespan of the stableptr, but it only exists until first use
14:14:53 <edwardk> bbiab
14:15:04 <aristid> when you apply many inputs maybe the overhead becomes significant
14:42:22 <CakeProphet> What's the asymptotic memory consumption of Data.Map?
14:43:37 * hackagebot graph-rewriting-gl 0.5.1 - OpenGL interface for interactive hypergraph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.5.1 (JanRochel)
14:45:57 <monochrom> proportional to number of things you store
14:46:25 <monochrom> if you store x things, it becomes a binary tree of x nodes
14:47:12 <kmc> yeah.   the map itself doesn't add much -- just a size value (possibly unboxed) at each node
14:47:53 <kmc> this question is very uninteresting if you're asking about asymptotic space consumption only
14:48:04 <kmc> but asking what the constant factors are at various sizes is perhaps interesting
14:53:20 * BMeph wonders if it would be easier to write a graph rewriting program in a language based on graph rewriting, sort-of like writing a Brainfuck interpreter in C...
14:57:40 <soupdragon> BMeph I think so
14:58:32 <dolio> I don't, really, but it might depend what you mean.
15:00:56 <RyanT5000> is there a way to find all the dead code in a package?
15:01:15 <RyanT5000> not as an optimization; as a hint to the programmer of what code might be ripe for deletion
15:01:26 <msieradzki> the hard way is hpc
15:01:30 <CakeProphet> GHC in verbose mode might mention it upon compilation.
15:01:31 <kmc> -Wall finds unused exports
15:01:41 <ClaudiusMaximus> RyanT5000: explicit export lists
15:01:44 <hpc> msieradzki: also expensive; i don't work for free
15:01:55 <monochrom> hahaha
15:02:23 <RyanT5000> ClaudiusMaximus: ah, good point; not as easy as i had hoped, but probably good enough
15:02:28 <olsner> hpc: I guess the hard part is making you do it for free anyway :P
15:02:35 <hpc> :D
15:02:48 <ClaudiusMaximus> RyanT5000: i do it iteratively, export nothing, see what breaks
15:02:54 <RyanT5000> right
15:02:57 <RyanT5000> that makes sense
15:03:19 <hpc> that's smart
15:03:51 <ClaudiusMaximus> it's about O(N^2) i think, where N is number of modules
15:04:03 <ClaudiusMaximus> so not terribly smart
15:04:20 <RyanT5000> well, at least the constant factors are small :)
15:04:30 <hpc> how is it N^2?
15:04:36 <RyanT5000> which, in a human task like this, is important
15:04:41 <RyanT5000> humans don't obey Moore's law :)
15:04:54 <hpc> i can imagine it being N*M, where M is the average exports per file
15:04:57 <ClaudiusMaximus> hpc: unless there's a flag for ghc to carry on to the next module if one fails
15:04:59 <olsner> sounds rather like O(N) invokations of ghc, N = the total number of exported functions
15:05:16 <CakeProphet> What does the ''Word syntax mean in TH?
15:05:17 <ClaudiusMaximus> my O() was of invocations of ghc
15:05:50 <ClaudiusMaximus> olsner: could be, asymptotic bounds are headmessing for me
15:05:51 <c_wraith> CakeProphet, it's the Name of a type
15:05:53 <olsner> hmm, functions may not necessarily become unused until other unused functions are removed
15:06:06 <c_wraith> CakeProphet, as opposed to 'Word, which is the Name of a value
15:06:20 <ClaudiusMaximus> olsner: hmm, good point
15:06:26 <olsner> so naively, O(N^2) indeed... perhaps you want ghc -fgc-exports or something
15:06:43 <ClaudiusMaximus> maybe some nice graph visualisation would help pruning
15:07:20 <kmc> ghc has -ddump-minimal-imports
15:07:22 <kmc> might be useful
15:07:54 <RyanT5000> that would be great in an IDE
15:08:21 <RyanT5000> have it show a little annotation after each import statement with what you're actually using from it
15:08:25 <RyanT5000> or show it on mouse-over
15:09:18 <olsner> RyanT5000: and the other way, for each exported function, where it's actually being used (and if it's reachable from main)
15:10:22 <ClaudiusMaximus> reminds me of a project idea - when building a linux liveCD from a list of packages, sometimes adding something seemingly small will pull in the whole of KDE or something daft, so visualizing package dependencies with size representing how much space you'd save if you removed each package would be nice
15:10:26 <olsner> and if you're building a library it should consult the cabal file for the set of exported modules and their exported functions (and use those as roots for the function GC)
15:10:30 <CakeProphet> kmc:  hmmm, what are the constant factors then?
15:10:38 <CakeProphet> for space consumption of Data.Map
15:10:48 <BMeph> Doesn't HaRe do DCE?
15:11:15 <BMeph> (Where DCE is "Dead Code Elimination", in this instance.)
15:12:55 <olsner> I'm thinking of making an Applicative functor with state, kind of like the state monad but, not a monad... is there anything like applicative-transformers?
15:13:02 <kmc> CakeProphet, well, it's a balanced binary tree.  each node is an empty leaf (1 word) or an interior node with unboxed Int size; key; value; and two submaps (6 words)
15:13:38 <kmc> that's on top of whatever space your data uses, which is presumably at least one word for each key and value
15:13:46 <kmc> since you can't instantiate the polymorphic map at an unboxed type
15:13:57 <ezyang> I have some FFI code that is mostly pure, except that it has one field in its struct that a function assigns a pointer to in order to return extra information. I’m trying to figure out if this merits controlling access to the field completely with MVar (ForeignPtr a), or if I can get away with a traditional lock for just some operations (ForeignPtr a, MVar ()), or if there's another way around this. 
15:14:08 <CakeProphet> kmc:  what does each node represent? I'm familiar with how a balanced binary tree is used to implement a map.
15:14:12 <CakeProphet> *not familiar
15:14:23 <ezyang> Or maybe I should patch the C code to not do that. 
15:14:36 <kmc> CakeProphet, each node has a (key,value) pair, and subtrees of the stuff with lesser and greater keys respectively
15:14:51 <kmc> so you compare your search key against the root; if it doesn't match,you go left or right and recurse
15:15:02 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/src/Data-Map.html
15:15:09 <kmc> look at e.g. "lookup"
15:15:14 <kmc> it's actually pretty readable code
15:15:23 <ezyang> I kind of like the patching the C code idea. 
15:19:47 <CakeProphet> what's the quickest way to see what a typeclass implements? 
15:20:07 <CakeProphet> er, well, informal terminology there. To see the methods a typeclass defines.
15:20:22 <Philonous> CakeProphet: in ghci: :i <typeclass>
15:20:36 <CakeProphet> okay. thanks. I always forget about :i
15:20:39 <Philonous> Of course it has to be in scope
15:20:44 * CakeProphet nods
15:22:11 <ddarius> BMeph: Eliminating definitions that aren't exported or used?
15:22:13 <CakeProphet> What's the benefit of including functions that can be defined in terms of a minimally complete typeclass? organizational?
15:22:35 <soupdragon> CakeProphet, efficiency
15:22:41 <CakeProphet> ah.
15:23:12 <olsner> and convenience - depending on taste and the underlying data type some of the alternatives may be easier to implement than others
15:25:33 <BMeph> ddarius: Either one. Of course, I'm reading Chris Brown's thesis paper, not the actual HaRe API, so YMMV.
15:26:31 <mm_freak> isn't it possible to write state monads with destructive update?  for example:  data MState v a = forall s. MState (STRef s v -> ST s a)
15:26:34 <mm_freak> or something like that
15:26:55 <ddarius> BMeph: That "or" was more like a conjuctive "or."  Definitions that are exported can't be removed (with whole program analysis) and definitions that are used can't be removed.  However, I meant just that or also things like dead case branches?
15:28:10 <kmc> an ST value existential in s is not going to be runST'able
15:29:38 <ddarius> State s a = forall s'. ReaderT (STRef s' s) (ST s' a)   (more or less as you've written)
15:30:14 <mm_freak> hmm
15:30:41 <mm_freak> a transformer variant of that one would be great
15:30:55 <mm_freak> but of course there is no STT
15:31:38 <dolio> STT isn't safe in general.
15:32:10 <mm_freak> hmm
15:32:15 <mm_freak> there is a different way
15:32:54 <mm_freak> forall s'. BaseM m (ST s') => ReaderT (STRef s' s) (m a)
15:32:57 <mm_freak> something like that
15:33:46 <kmc> there's a STT on Hackage, but yes, it's not safe
15:33:56 <kmc> remember, runST is just a nice name for unsafePerformIO ;)
15:34:17 <mm_freak> yeah…  but if you ensure that ST is the base monad, then it should be fine
15:34:20 <mm_freak> like above
15:35:09 <mm_freak> then the single monad version of the transformer would use ST s instead of Id
15:36:01 <Benny_> Has anyone had any luck getting wxHaskell to install on Windows lately?
15:36:39 <Benny_> It just fails at "no wx-config found" here, even if I put wx-config.exe in the same directory
15:36:42 <BMeph> ddarius: Have you read: http://www.cs.kent.ac.uk/projects/refactor-fp/publications/tool-support-for-rfp.pdf ?
15:37:12 <mm_freak> i wonder whether an STRef-based state monad would be faster than a pure one anyway
15:37:12 <Benny_> And the only binary packages I can find are for 6.10.x
15:37:29 <Benny_> (GHC 6.10.x, that is)
15:38:44 <jmcarthur> yay for monadLib!
15:39:07 <ddarius> BMeph: Probably but it has been many years.  It was new when I read it (if I read it.)
15:39:48 <mm_freak> jmcarthur: =)
15:41:23 <Benny_> Every Haskell GUI toolkit I can find that advertises Windows support doesn't actually
15:41:30 <Benny_> * + have it
15:41:46 <ezyang> Benny_: Really? 
15:42:02 <hpc> windows support is dismal across the board, from what i have found
15:43:03 <Benny_> There's basically wxHaskell and HTk
15:43:11 <ezyang> I’m pretty sure gtk2hs is known to work on Windows. 
15:43:27 * ddarius highly suspects he'd find Windows support much better now than he did when he started, and he didn't find it that bad when he started.
15:43:30 <Benny_> I'm trying to make an application I can give to people and not feel embarassed :P
15:43:38 <ddarius> I've used Gtk2hs on Windows.
15:43:43 <Benny_> * embarrassed
15:44:27 <Benny_> And my experience with gtk2hs on Linux has been terrifying so far
15:46:16 <Benny_> wxHaskell is basically ideal, since it looks native on all three major platforms
15:46:22 <edwardk> preflex: xseen jaffacake
15:46:22 <preflex>  jaffacake was last seen on freenode/#ghc 6 hours, 56 minutes and 44 seconds ago, saying: tibbe: let's hope they're all due to the same thing :)
15:47:08 <Benny_> I hear nothing but endless complaining from Windows users who get subjected to Gtk applications
15:47:38 <Philonous> Can I prevent hint from completely bailing out on an error? wrapping interpret in catch apparently doesn't do the trick. 
15:47:39 <Benny_> I don't even want to imagine what the Mac users will do to me.
15:47:54 <hpc> Qt is okay, but is still quite smelly
15:48:10 <hpc> GTK is like having an ubuntu VM
15:48:34 <Saizan> Philonous: by "on an error" you mean if the interpreted code uses error?
15:48:42 <edwardk> preflex: xseen nominolo
15:48:42 <preflex>  nominolo was last seen on freenode/#ghc 30 minutes and 19 seconds ago, saying: Igloo: ah, I think I should be able to override the default path
15:48:49 <Philonous> Saizan: I mean parse error / type error
15:49:10 <mm_freak> Benny_: only people, who are annoyed, give feedback about the UI
15:49:11 <Benny_> gtk2hs advertises easy Windows installation, then fails saying it can't find pkg-config
15:49:32 <Saizan> Philonous: which catch are you using?
15:49:42 <mm_freak> there are also people, who find GTK+ much better than native windows GUIs, but those are the people, who don't give feedback
15:50:40 <FauxFaux> mm_freak: Only for fear of me hunting them down and inserting a maglite into their behind.
15:51:00 <Philonous> Saizan: Control.Monad.CatchIO.catch The one that haddock links to
15:51:01 <mm_freak> hehe
15:51:15 <mm_freak> i think GTK+ is ok since version 2
15:51:18 <FauxFaux> 6 d-cells is the penalty for the gtk open dialog, I believe.
15:51:30 <tensorpudding> Does wxWidgets follow the Apple HIG?
15:51:35 <Benny_> Oh, good Lord
15:51:42 <Axman6> ha
15:51:51 <Benny_> Half of what this program does is asking for directories
15:52:03 <Axman6> no non-native GUI libraries do imo
15:52:06 <mm_freak> but for the record, i haven't got gtk2hs to work under windows, too
15:52:09 <Benny_> I still get confused by GTK's open dialogs
15:52:17 <Axman6> Java apps get ther closest though
15:52:18 <Benny_> These are users I'm writing this for
15:52:35 <tensorpudding> It's not really worth using a cross-platform toolkit if your GUI isn't going to look decent on the platforms you port it to.
15:52:43 <FauxFaux> Swt is pretty good on Windows, gtk on linux (where they don't care about gui guidelines, as evidenced by gtk and qt existing), and at least tries on osx.
15:53:08 <Benny_> haha, Windows, GUI guidelines
15:53:19 <Benny_> I'm not sure it really matters too much though
15:53:31 <Benny_> I'm talking about people who have to deal with LabView daily here
15:53:47 <FauxFaux> So long as you get the open dialog right, you probably won't get too much complaining from Windows users.
15:54:02 <ezyang> I know a dev team that optimistically thought they were going to do it the right way and use native UI toolkits on each OS. 
15:54:15 <ezyang> They ended up turing their app into a we application and putting it on Facebook. 
15:54:16 <Axman6> it can be done
15:54:19 <ezyang> *web 
15:54:39 <Benny_> My GUI essentially consists of one window where a directory and some checkboxes are selected, with a message area at the bottom.
15:54:41 <Axman6> i believe that's what Transmission does
15:55:07 <bos> dcoutts: ping
15:57:07 <McManiaC> hmmm
16:03:28 <Philonous> Saizan: Digging into the hint source reveals that it's not exceptions I'm dealing with at all. 
16:03:37 <augur> kmc: you wake?
16:03:47 <kmc> i am
16:04:15 <augur> know of any awesome haskel stuff you could blow my mind with? :D
16:04:53 <augur> btw, what is this => thing in types? ive never understood its use
16:05:04 <hpc> it's a class constraint
16:05:18 <Saizan> Philonous: maybe you've to use catchError?
16:05:44 <Zao> f :: forall a b. Show a, Read b, Pie b => a -> b -> b -> ()
16:05:49 <hpc> (Foo a, Monad m => m a) means a is an instance of Foo and m is an instance of Monad, and the type is m a
16:05:50 <kmc> augur, that's awfully general.  what are you interested in, and what do you know?
16:06:00 <Zao> Ternary function taking an a and two bs, where a must be a Show and b a Read and Pie.
16:06:08 <kmc> type classes will be covered pretty early in any haskell tutorial
16:06:10 <augur> class constraint, like, a restriction on type-classes instead of types?
16:06:11 <Saizan> Philonous: "Monad m => MonadError InterpreterError (InterpreterT m)" <- sounds like that
16:06:19 <hpc> yes
16:06:30 <Philonous> Saizan: Indeed
16:06:41 <Philonous> Saizan: Just found it out myself :)
16:06:42 <kmc> augur, no.  a restriction on some of the variables appearing in a type
16:06:53 <Philonous> Saizan: Thanks!
16:07:02 <kmc> saying that the types which we fill in for those variables must be instances of some class
16:07:16 <Saizan> Philonous: i wasn't much help but cheers :)
16:07:23 <kmc> e.g. «(Eq a) => a -> Char»; we require that whatever type 'a' is used must be an instance of Eq
16:07:47 <hpc> you may have a typeclass like: class Eq a where (==) :: a -> a -> Bool
16:07:56 <hpc> when you check the type
16:07:58 <augur> right
16:07:59 <hpc> :t (==)
16:08:00 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:08:09 <augur> right
16:08:15 <lispy> right
16:08:20 <lispy> No wait, left!
16:08:22 <augur> but so in this case a is not going to be bound to a PARTICULAR type
16:08:30 <hpc> indeed
16:08:34 <augur> as it would be in, say,   forall a. a -> a
16:08:39 <hpc> it's how you restrain polymorphism
16:08:47 <augur> instead, its bound to any type that is an instance of Eq
16:09:06 <kmc> augur, it will eventually be a particular type
16:09:14 <augur> but it cant just be one tho
16:09:15 <augur> i mean
16:09:15 <kmc> «(Eq a) => a» is a more restrictive version of «a»
16:09:18 <kmc> augur, it can be just one
16:09:22 <augur> well, it can
16:09:26 * lispy thinks he will start answering questions with forall b a. b -> Either a b and forall b a. a -> Either a b instead of Right and Left :)
16:09:28 <augur> but it can also be two
16:09:29 <kmc> if i write a function «(Eq a) => a -> Char», i can call it with a = Int
16:09:32 <kmc> it can't be two at once
16:09:34 <augur> 1 == "2"
16:09:38 <kmc> it can be one in one situation, and another in another
16:09:49 <augur> presumably this isnt a type mismatch
16:09:50 <hpc> so if you had something like: data Blah = One | Two
16:09:51 <kmc> just like (a -> b)
16:09:54 <kmc> augur, of course it is
16:09:56 <kmc> > 1 == "2"
16:09:57 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
16:09:57 <lambdabot>    arising from the literal ...
16:10:06 <kmc> unless you have that strange Num instance it suggests
16:10:07 <Benny_> Oh, God damn it
16:10:12 <kmc> and that's because numerical literals are overloaded
16:10:12 <augur> whaa
16:10:15 <hpc> you can do: instance Eq Blah where One == One = True; Two == Two = True
16:10:16 <Benny_> Haskell Platform has its own MinGW
16:10:16 <kmc> > 'x' == True
16:10:16 <augur> thats..
16:10:18 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:10:18 <lambdabot>         against inferred type...
16:10:23 <augur> oh well i guess it doesnt matter in haskell
16:10:24 <kmc> :t (==)
16:10:25 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:10:28 <kmc> «a -> a -> Bool»
16:10:29 <augur> because variables are all type checked anyway
16:10:31 <kmc> a has to be the same as a
16:10:34 <Benny_> And Cabal ignores any binaries not in its /bin
16:10:41 <kmc> the constraint doesn't change that, it just imposes an additional requirement
16:10:49 <Benny_> wxHaskell is now compiling
16:11:06 <augur> and youll never end up with a situation where you'll be doing 1 == "1" since you'll already know what the types of both sides are a priori
16:12:13 <hpc> indeed; you compare two things of the same type to each other for equality, but only if they are things that can be equal to each other
16:13:04 <kmc> yeah.  you can't compare two different types for equality, with the standard Eq type class
16:13:11 <kmc> you can (with certain extensions) write
16:13:17 <augur> so what happens with a function like
16:13:19 <kmc> class Eq' a b where (===) :: a -> b -> Bool
16:13:41 <augur> foo x y = x == y :: forall a b. a -> b -> Bool
16:13:45 <kmc> instance Eq' Int Int where (===) = (==); instance Eq' Int Char where _ === _ = False
16:13:57 <kmc> :t let foo x y = x == y in foo
16:13:59 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:14:01 <augur> will this fail type check because the quantifier allows a ~= b maybe?
16:14:08 <kmc> yes
16:14:13 <hpc> yes, it will fail
16:14:17 <kmc> you've given an incorrect signature for foo, an overly-general one
16:14:30 <augur> kmc: but i WANT that one! :P
16:14:36 <kmc> you're missing the Eq constraint, plus you're not forcing the two variables to have the same type.  two distinct problems
16:14:42 <kmc> augur, why do you want it?
16:14:48 <augur> i dont, im just messing.
16:14:50 <kmc> ok
16:14:55 <kmc> sometimes you legitimately might
16:15:07 <augur> i was just curious about how the quantifier interacts with the type restrictions
16:15:10 <kmc> sometimes we want Haskell to be dynamically typed
16:15:15 <kmc> fortunately there are various ways to achieve this
16:15:23 <augur> like moving over to miranda?
16:15:25 <hpc> they are scary ways, though
16:15:42 <hpc> and involve forall madness
16:16:06 <edwardk> hpc: Dynamic isn't THAT scary
16:16:28 <kmc> hpc, the simplest thing that looks like dynamic types is just a sum type
16:16:29 <augur> kmc: so explain monads to me. why are they magical
16:16:34 <kmc> augur, they're not magical
16:16:38 <hpc> oh
16:16:40 <Benny_> They're in the Magic typeclass
16:16:47 <kmc> the IO monad is magical; most of the others aren't
16:16:48 <augur> see? Benny_ knows what i mean
16:16:50 <Benny_> With the proper instance functions
16:17:07 <hpc> monads are awesome, and many people end up writing them themselves before they understand the generalization
16:17:13 <kmc> "Monad" is an ordinary Haskell type class; return and (>>=) are ordinary Haskell functions overloaded in that class.  "do" is special built-in sugar, but it's only sugar
16:17:18 <ddarius> edwardk: GHC's implementation of Dynamic uses unsafeCoerce.
16:17:30 <kmc> augur, what have you read about monads so far?
16:17:38 <djahandarie> abrakadabra = ???
16:17:39 <edwardk> ddarius: still isn't that scary ;)
16:17:50 <keseldude> Anyone know any exercises like the ones from the 20 intermediate haskell exercises blog post? I just did those today
16:17:51 <BMeph> augur: You are in violation of IP Regulations. That's Miranda™, you should know. ;þ
16:17:59 <augur> BMeph: D:
16:17:59 <edwardk> just so long as everyone on the planet gets their Typeable instances right ;)
16:18:04 <ddarius> edwardk: Are you trying to justify your speculation code?  How is that going by the way?
16:18:06 <augur> kmc: oh god, i've read so much, and i get that its all bind and return and whatnot
16:18:19 <augur> i mean, i get the monadic functions
16:18:40 <hpc> you need someone to make you grok it
16:18:40 <fxr> what do you use to create TAGS files for emacs?
16:18:42 <edwardk> ddarius: quite well actually. i'm rather happy with it. though i've been somewhat side-tracked from benchmarking it
16:18:42 <augur> i cant tell you how many times i've half re-implemented the List monad in Ruby
16:18:44 <Saizan> edwardk: did you parallelize STM's actions in the end?
16:18:49 <augur> i just dont get the biggggg picture
16:18:51 <Saizan> fxr: hasktags
16:18:58 <ddarius> augur: Miranda wasn't dynamically typed.
16:19:16 <augur> ddarius: oh ok. well, whatever is Miranda-ish but dynamically typed.
16:19:21 <augur> ML? whatever. who knows.
16:19:26 <BMeph> ddarius: You are in violation of IP Regulations. Blah-blah-blah...
16:19:29 <edwardk> Saizan: i have an open ticket to add a numSparks# to ghc, since sadly, i can't access the capability or spark queue through public headers in my own custom primitive =(
16:19:40 <kmc> augur, but the point of "Monad" is the single generic interface to all these different monads.  when you implemented the list monad in ruby, did you write some flexible control-flow operators that would also work for exception handling, IO, or parsing?
16:19:56 <kmc> augur, if you're working in only one monad, the abstraction behind all monads is irrelevant
16:20:00 <edwardk> Saizan: that will let the STM version check the current process's spark queue and if it has grown large enough it can avoid speculating
16:20:07 <fxr> Saizan: it recurses or not?
16:20:12 <edwardk> Saizan: but it needs a primop to be added to ghc =(
16:20:16 <kmc> it's there for code reuse, so that functions like "sequence" can be written once rather than rewritten for parsing, transactional memory, logic programming, etc.
16:20:29 <hpc> more specifically, you use monads to build computations
16:20:43 <hpc> similarly to how you would with applicative, only you get many more cool toys from monads
16:20:48 <augur> kmc: no no, it was all just bind-related stuff really. i mean, it works for parsing algorithms in some ways, and for unification algos, too
16:21:00 <kmc> augur, you'll note that most languages have a special-purpose exception-handling construct, a special-purpose IO construct, a special-purpose parsing construct (often an external code generator), etc.
16:21:02 <Saizan> fxr: iirc you've to do the recursion with find
16:21:09 <kmc> and that they just glue on more of these when some missing feature is discovered
16:21:09 <fxr> ok thanks
16:21:14 <fxr> I lost my memory
16:21:19 <fxr> sorry for asking it twice
16:21:45 <augur> kmc: how are monads useful in parsing constructs as you see it?
16:21:52 <Benny_> 19:20 < kmc> augur, you'll note that most languages have a special-purpose  exception-handling construct
16:21:55 <Benny_> *cough*
16:22:14 <Philippa> augur: without backtracking they correspond to LL(1) context-sensitive parsing very, very easily indeed
16:22:15 <Benny_> I'm not sure that exceptions should be mentioned when one is trying to make haskell look good :P
16:22:23 <Philippa> it's also easy to give backtracking in them
16:22:26 <kmc> augur, most parser combinator libraries for Haskell provide a monadic interface
16:22:30 <kmc> Benny_, why not?
16:22:41 <Philippa> you wrap the input in a statelike monad, add an operation to consume a character, add monadplus for choice...
16:22:56 <augur> Philippa: hm. i suppose i'd need an example.
16:22:58 <augur> meh.
16:23:01 <Philippa> augur: Parsec
16:23:03 <Benny_> kmc: Because they're not handled consistently, and the way they work suddenly changed between .10 and .12
16:23:04 <kmc> Benny_, it's not one of the strong selling points of Haskell, but I think it handles standard imperative exceptions as well as any other imperative language
16:23:08 <augur> Philippa: you and your parsec :|
16:23:13 <Philippa> or the Hutton&Meijer monadic parsing paper
16:23:23 <augur> damnit, woman, what ever happened to lightyears, huh? HUH?
16:23:24 <kmc> Benny_, ok.  the way Python exceptions work also changed recently
16:23:29 <Benny_> Um
16:23:41 <Benny_> Python is *why* I hate imperative exceptions in general
16:23:45 <kmc> ok :)
16:23:49 <Benny_> That's an awful example if you're trying to win me over :P
16:24:00 <Philippa> monads are nice in particular because they give you a good way to get at 'strong' parsing methods when you need them without forcing you to do anything too ugly - how you parse the next thing can depend on how you parsed everything before, because bind works like that
16:24:02 <kmc> i'm not, particularly
16:24:18 <hpc> Benny_: python nearly made me hate /lambdas/
16:24:30 <hpc> don't take it to be a defect of exceptions
16:24:33 <msieradzki> I wanted to write map something in python
16:24:36 <msieradzki> I almost died
16:24:36 <kmc> augur, there is a nice correspondence where, for parsers, the Applicative typeclass gives you context-free grammars, and the Monad typeclass gives you context-sensitive grammars
16:24:38 <Benny_> My biggest problem with exceptions is that they're *never documented*
16:24:52 <olsner> hpc: don't let python hate spill over into other languages, that's not fair
16:24:53 <Benny_> And I hate doing a HURR CATCH EVERYTHING block
16:24:56 <augur> kmc: interesting
16:25:02 <ddarius> Benny_: Go to Java.
16:25:02 <kmc> msieradzki, try it in C++ with std::algorithm.  i wrote about 20 lines of code to "use" that "library" for an effect identical to «filter (< 7)»
16:25:08 <Benny_> ddarius: ... haha, no
16:25:20 <hpc> java documents everything, and by doing so, documents nothing
16:25:22 <Benny_> I'm fine with not caring about exceptions at all for small programs
16:25:23 <kmc> Benny_, there's a library for documenting exceptions in types in Haskell
16:25:26 <Philippa> kmc: I suspect it actually gives you turing complete ones? If not, adding backtracking definitely ought to
16:25:28 <augur> kmc: any typeclass for the mildly context sensitive grammars? :P
16:25:33 <msieradzki> like java beans, C++ functors and so on, boilerplate that has fancy names as an excuse
16:25:37 <kmc> Philippa, yeah, probably
16:25:41 <ddarius> (Actually, using exception monads in Haskell is theoretically very similar to Java's checked exceptions.)
16:25:45 <hpc> you get all the type signatures you could ask for, but zero context and a billion pages of scrolling to find the one useful function
16:25:47 <Benny_> see, what I like about Haskell is stuff like Maybe and Left/Right combined with pattern matching
16:25:59 <Philippa> algebraic datatypes are nice, yeah
16:26:17 <hpc> Maybe and Either have my favorite monad instances
16:26:21 <olsner> augur: you can probably take a monadic parser and wrap it up in a applicative shell with added exposed primities for only the specific kind of context sensitivity you need
16:26:21 <pikhq> Philippa: Parsec backtracks.
16:26:22 <kmc> nooo
16:26:24 <pikhq> :)
16:26:25 <kmc> the Either monad instance sucks
16:26:25 <Benny_> So exceptions don't start exploding everywhere if you just want to grab something from a dictionary (*coughcough*oldPythonversions*cough*)
16:26:32 <Philippa> pikhq: I know it does! But not within the monad signature
16:26:39 <pikhq> Right, right.
16:26:45 <Axman6> kmc: why?
16:26:47 <augur> olsner: perhaps. but that feels like a hack
16:26:56 <Philippa> nor does the monad signature require backtracking, whereas it does require context sensitivity
16:27:23 <kmc> Axman6, (Error e) constraint
16:27:26 <Benny_> Being able to express all possible outcomes in values and having to explicitly handle each case is a significantly better way of handling problems than blowing up the entire program
16:27:34 <Philippa> you can write the parser mostly using the applicative functions, then a good implementation can exploit that
16:27:46 <hpc> :t (Left f) >>= (Right g)
16:27:47 <lambdabot>     Couldn't match expected type `a1 -> Either a b'
16:27:48 <lambdabot>            against inferred type `Either a2 a3'
16:27:48 <lambdabot>     In the second argument of `(>>=)', namely `(Right g)'
16:27:56 <hpc> :t (Left f) >>= (Right 4)
16:27:56 <kmc> Either should be a totally symmetric sum type.  if you want something for errors, that's a more specific type that should have its own name
16:27:57 <lambdabot>     Couldn't match expected type `a1 -> Either a b'
16:27:57 <lambdabot>            against inferred type `Either a2 t'
16:27:57 <lambdabot>     In the second argument of `(>>=)', namely `(Right 4)'
16:28:07 <Benny_> I've never been able to write a program in any scripting language that doesn't run into some obscure undocumented exception at some point in its execution, they're all jokes for anything that needs to run more than ten minutes straight
16:28:12 <hpc> :t ((Left f) >>=)
16:28:13 * kmc petitions to rename Either to :⊕
16:28:14 <lambdabot> forall a a1 b. (SimpleReflect.FromExpr a, Error a) => (a1 -> Either a b) -> Either a b
16:28:16 <ddarius> Benny_: Agreed.  I wish use of asynchronous exceptions/IOError was much diminished in Haskell code.
16:28:18 <olsner> augur: well you can always go for the full context-sensitive parser monad and just not use all the power
16:28:26 <olsner> augur: (also, what Philippa said)
16:28:50 * ddarius petitions to rename Left/Right to Sinister/Dexter.
16:28:54 <Benny_> Oh hey, wxHaskell for Windows just finished
16:28:57 <Philippa> if you need 'global' context-sensitivity anyway then you've pretty much swallowed the poison
16:29:20 <augur> olsner: yeah but i never like using something more than i need. i feel like it doesnt make it easy to truly understand the thing that way.
16:29:24 <Philippa> if it's strictly local to a given production, you can limit it
16:29:47 <hpc> Benny_: i absolutely hate how read isn't :: String -> Maybe a
16:29:51 <Philippa> augur: that's fine, just don't actually use it. Less >>=, more >>
16:30:03 <augur> Philippa: :P
16:30:08 <Philippa> or more <$> and <*> for results
16:30:09 <augur> you dont get the spirit of what im aiming for :P
16:30:31 <Philippa> I do, it's just that context-sensitivity is one of those things that necessarily 'taints'
16:30:42 <kmc> hpc, and that's not even in the std lib under another name
16:31:12 <augur> Philippa: no i know, but theres a nice well defined subset of CS grammars that have nice properties
16:31:25 <augur> but bigger than CF
16:31:27 <Benny_> "cannot find -lstdc++"
16:31:30 <Benny_> How did you compile I don't even
16:31:39 <augur> relatively cheap parsing, apparent adequacy for natural languages
16:32:07 <Benny_> 19:29 < hpc> Benny_: i absolutely hate how read isn't :: String -> Maybe a
16:32:18 <Benny_> I've probably written readSafe about five times now
16:32:30 <Benny_> Or maybeRead, or however I've called it
16:32:38 <olsner> find the type-class that goes between applicative and monad precisely matching the power required by this subset of CS grammars, and make a parser library implementing it :)
16:33:13 <hpc> Benny_: from hoogle: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Text-Read.html#read
16:33:29 <Benny_> hehe
16:34:15 <hpc> readEither is handy
16:34:47 <hpc> @hoogle Either a b -> Maybe b
16:34:48 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
16:34:48 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
16:34:48 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
16:34:50 <monochrom> wrap "try" around everything
16:34:59 <Philippa> augur: the LL(1) context-sensitive class is pretty cheap, and it's parsec's default
16:35:33 <Philippa> the thing is, you're not actually parsing a traditional 'context-sensitive' grammar - it's context sensitive in the sense that parse results can dictate future parses
16:35:42 <augur> Philippa: im not sure what an LL(1) CS class is. is it mentioned in Parsing Techniques?
16:36:06 <Philippa> augur: it's LL(1) + getting to examine the result of parsing thus far
16:36:14 <augur> hm.
16:36:22 <augur> is it actually greater than CF?
16:36:27 <augur> what non-CF language can it handle?
16:36:37 <Axman6> @djinn Either a b -> Maybe b
16:36:37 <lambdabot> f a =
16:36:37 <lambdabot>     case a of
16:36:37 <lambdabot>     Left _ -> Nothing
16:36:37 <lambdabot>     Right b -> Just b
16:36:48 <Philippa> the one where you have an LL(1) encoding of a future grammar to use, for one
16:37:05 <augur> Philippa: well that tells me nothing xP
16:37:16 <Philippa> well, it tells you it's stronger than CF, doesn't it? :-)
16:37:34 <augur> no!
16:37:37 <Philippa> or at least, can parse things CF doesn't
16:37:37 <augur> it doesnt :(
16:37:58 <Philippa> (strictly speaking I suspect you can encode backtracking the long'n'fugly way using it too, but I wouldn't want to)
16:38:08 <jkingkong> i was wondering how I should go about making Vectors an instance of NFData
16:38:21 <jkingkong> NFdata from the deepseq package
16:38:28 <augur> Philippa: can you at least give me a non-cf language over {a,b} that's LL(1) CS? :P
16:38:39 <Benny_> God damn it, Text.Regex
16:38:44 <g_cross> jkingkong:  Are the vectors unboxed?
16:38:55 <jkingkong> g_cross: yes
16:39:05 <jkingkong> g_cross: well, i'd like to be able to do it for both
16:39:07 <Benny_> I know there's an empty expression, that works fine on Linux, why are you doing this to me
16:39:13 <Benny_> (wxWidgets works, though :D)
16:39:29 <g_cross> jkingkong: If the vector is unboxed, then you should only need to force it to WHNF, so I think that the default instance should work.
16:39:52 <Benny_> Luckily, I don't need that empty subexpression anymore
16:39:52 <g_cross> jkingkong: Which vector package are you using?
16:40:03 <Benny_> *first time changing requirements have been good for him ever*
16:40:07 <jkingkong> g_cross: data.vector, 0.6.0.2
16:40:42 <Philippa> augur: not right now, no. I haven't prepared a pile of counterexamples and it's been a long night and I haven't kicked around the formalisms in a while. Someone else who's got a strong enough intuition for what'll neatly violate CFness can take a shot
16:41:02 <augur> bah. who DOESNT kick around in formalisms all the time? :|
16:41:06 <jkingkong> g_cross: also, doesn't the default instance of NFData do nothing? or am I misunderstanding it
16:41:26 <augur> well, Philippa, can LL(1) CS parse { a^n b^n c^n }?
16:41:27 <Philippa> there's a trivial example for one that's not LL(1) though, which is the one where the validity of a later parse depends on which namespace an identifier was put in
16:41:36 <Philippa> it can, yes
16:41:52 <Philippa> once it's finished parsing the as, it knows how big n is and can use it
16:42:02 <augur> ok interesting
16:42:50 <Philippa> do as <- many $ char 'a'; repeat (length as) (char 'b'); repeat (length as) (char 'c)
16:42:58 <Benny_> I always get the feeling when people start talking about parsers and grammars that my college is a bit, uh, sub-standard at CS
16:43:03 <Philippa> (repeat's probably not the right name, but you know the func I want, right?)
16:43:11 <Philippa> oh, it's probably replicate
16:43:16 <Philippa> or replicateM
16:43:20 <g_cross> jkingkong:  The default instance of NFData evaluates the argument to weak head normal form --- i.e., it evaluates up to figuring out what the constructor is and evaluating the strict arguments of the constructor, but does not necessarily evaluate the lazy arguments of the constructor.
16:43:21 <Benny_> Not that I've learned anything here yet, but that's not even in my future
16:43:39 <Benny_> Or is that not something one learns in a Bachelor's program?
16:43:48 <Philippa> I was thinking along similar lines but couldn't remember the right property to violate to avoid CFness :-)
16:43:54 <g_cross> jkingkong: So if your data is unboxed, then there is no laziness inside of it and so the default instance should work fine.
16:44:06 <jkingkong> g_cross: so you're saying something like instance NFData Vector should suffice
16:44:11 <Philippa> it's "LL(1)" in the sense that it never needs to backtrack/look ahead more than 1
16:44:16 <Philippa> concept make sense now?
16:44:20 <g_cross> jkingkong: For unboxed data, yes.
16:44:36 <g_cross> jkingkong: For boxed data, you need something more like the following...
16:44:36 <jkingkong> g_cross: ok now for boxed data, how can i force each element of the vector?
16:44:44 <augur> Philippa: ok, but, you're using a whole bunch of stuff well beyond just parsing. i mean, you have length functions and repeat and so forth
16:44:46 <jkingkong> g_cross: ah continue sorry for interrupting
16:44:47 <Philippa> I suspect the monad signature coupled with a turing complete host language means it's actually got turing complete parsing power, but the useful thing is /you don't have to use it/
16:45:15 <augur> Philippa: i know you dont have to use the full TC power even if its there
16:45:15 <Philippa> augur: sure, it's not context sensitive in the sense of that level in the chomsky hierarchy. It is in a more literal sense
16:45:27 <augur> im just not interested in things that have the option of going beyond some certain power
16:45:52 <Philippa> right. So long as you're not doing anything that smells like smuggling parsing machinery into your results, you're fine
16:46:06 <augur> i'm a theoretical linguist in progress, mind you
16:46:19 <Philippa> or maybe you want to - I have a two-stage parser that does operator resolving separately where the outer stage returns a parsing problem
16:46:38 <augur> so my interest is primarily in how to best understand the kinds of grammars that are limited in a particular way
16:47:10 <g_cross> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27598#a27598
16:47:17 <Philippa> sure. You can probably go a fair way with LL(1) "CS" plus some limit on what the CS computation's allowed to do - limiting to linear or to polynomial complexity strikes me as useful, for example
16:47:21 <g_cross> jkingkong:  I think that should work
16:47:39 <g_cross> It basically iterates over the array and forces each element
16:47:40 <Philippa> obviously you're effectively working with definition by automata again at that point
16:47:55 <Philippa> which isn't necessarily much fun from a linguist's POV
16:48:02 <Philippa> it's nice and powerful from a programmer's one though
16:48:06 <augur> Philippa: yeah, but, i dont know. it doesnt feel like an inherent constraint, it feels like you've taken a turing machine and said "just dont do it like this"
16:48:16 <g_cross> jkingkong: Note that you need to use the strict version of fold to make sure that it forces the evaluation of (rnf x) for every x in the array.
16:48:24 <augur> as opposed to cutting off part of it and made it literally impossible to do otherwise
16:48:28 <Philippa> that's because you don't know how to formalise a smaller machine in other terms :-)
16:48:41 <augur> ey?
16:48:45 <Philippa> but yes, the type system won't force you to not do something stupid
16:49:06 <Philippa> eh, if you're talking about the monad formalism then yeah, fair enough
16:49:11 <jkingkong> g_cross: looking at it now
16:49:25 <augur> i mean, we can talk about CFGs as turing machines with such and such a behavior
16:49:30 <Philippa> it's fairly rare someone does something hairier than building a symbol table with the CS aspect though
16:49:36 <augur> but then you're not enlightened as to why they form a special class
16:49:41 <jkingkong> i suppose it's rnf v = foldl' (const rnf) () v right?
16:49:57 <g_cross> Yes.
16:50:00 <CakeProphet> hmmm... doesn't >>= in the case of IO break referential transparency?
16:50:19 <jkingkong> @type const
16:50:20 <lambdabot> forall a b. a -> b -> a
16:50:33 <Philippa> sure, and the stack machine is useful in that regard. The LL(1) CS property can be defined with similar limits on the CS side of things that do have a correspondance though. For example, "all you have is a map"...
16:50:56 <g_cross> jkingkong:  So, more explicitly:  rnf v = foldl' (\_ x -> rnf x) ()
16:50:57 <augur> hm.
16:50:59 <c_wraith> CakeProphet, Not really.  "getChar >>= putChar" is always the same operation.
16:51:13 <jkingkong> g_cross: yea I had never used const before
16:51:15 <ezyang> only main breaks referential transparency ;-) 
16:51:34 <jkingkong> g_cross: ok great that must be it
16:51:40 <jkingkong> g_cross: thanks
16:51:40 <g_cross> CakeProphet:  Or put another way, the monadic value is pure, but the value contained inside the mondic value is impure.
16:51:45 <g_cross> jkingkong: n/p!
16:51:51 <augur> its not evaluation that breaks referential transparency, its execution!
16:51:57 <Philippa> now, the map effectively gives you a mutable state machine, but it /doesn't/ give you a stack, assuming we're not allowing things like the size operation on it
16:51:59 <c_wraith> CakeProphet, you should think of IO actions not as "a mysterious value hidden inside IO", but instead as "instructions to calculate a value".
16:52:04 <g_cross> (Assuming that I am finally getting the terminology correct.  :-) )
16:52:12 <augur> Philippa: perhaps perhaps. i dont know much about the more hardcore programmatic parsing techniques, honestly
16:52:40 <Lemon> Real World Haskell, dead tree form, found in a Borders.
16:52:43 <augur> CakeProphet: to understand IO, ask kmc. he's got it all figured out.
16:52:47 <Philippa> *nod* - I don't know much about the well-understood subsets of context-sensitive grammars, I got all the CFG and CFG+symbol table stuff
16:52:49 <augur> the mans a magic worker, seriously.
16:52:56 <CakeProphet> c_wraith:  I know exactly how I should think of IO actions. ;) There is nothing mysterious at all. What I'm saying is that getChar does not always produce the same action.
16:53:09 <g_cross> CakeProphet:  So the purity comes from the fact deciding which action to take next is a pure function of the input.
16:53:13 <augur> CakeProphet: evaluating getChar does
16:53:17 <augur> executing the result doesnt :D
16:53:21 <c_wraith> CakeProphet, yes it does!  it's *always* the action "get a character from input"
16:53:27 <Benny_> Okay, not to start a flame war or anything
16:53:31 <CakeProphet> hmmm...
16:53:32 <Benny_> But I didn't like Real World Haskell?
16:53:34 <g_cross> (Puts on flame retardent)
16:53:47 <augur> Benny_: to answer your question, yes, you did like real world haskell.
16:53:47 <c_wraith> CakeProphet, the character it gets is not part of the action.  it's the result of executing the action.
16:53:54 <Benny_> augur: oh, okay
16:53:59 <augur> :)
16:54:10 <Benny_> I think I was looking for a less Real World approach, though
16:54:12 <Philippa> augur: got a nice reference I can take a look at on the CS side?
16:54:13 <CakeProphet> c_wraith:  I suppose I see how that makes sense. I'm not asking to "understand IO" or anything. I was simply considering referential transparency in the context of IO actions.
16:54:25 <Philonous> CakeProphet: Yes, and when you finally able to believe that IO is funtionally pure you will be a good #haskell citizen. Mind you, we've always been at war with Eastasia
16:54:30 <Philippa> (just to check, are you familiar with LL(1) grammars?)
16:54:39 <augur> CakeProphet: according to kmc, when you do something like getChar, all you're doing is creating an instruction to read a char from the terminal
16:54:40 <Philonous> +are
16:54:45 <Benny_> I don't really need to see how to implement X or Y in Haskell, I'm more interested in learning the language, since I know how to make X and Y already and that has nothing to do with Haskell
16:54:59 <c_wraith> CakeProphet, yeah.  how IO *actually* works underneath *is* as a dirty impure hack, at least in GHC.  But it's wrapped in a viewpoint that allows you to see it as referentially transparent.
16:55:05 <augur> the runtime does something with that instruction, but thats not the same thing as evaluating the function
16:55:24 <Philippa> getChar isn't a function, of course
16:55:24 <augur> Philippa: im not especially familiar with how they work, no
16:55:25 <g_cross> Benny_:  I find that keeping an eye on the new packages on Hackage has helped me learn a lot about Haskell.
16:56:00 <augur> Philippa: is it not a function? i thought everything was a function in haskell. :p
16:56:01 <Philippa> augur: ah. Basically they're what parsec-with-trivial-return (say, if it could only return ()) could parse
16:56:07 <CakeProphet> c_wraith:  but then the issue still remains, doesn't >>= still break RT? getChar >>= f does not always produce the same action.
16:56:11 <Philippa> augur: if it's not got a -> at top level, it's not a function
16:56:19 <Benny_> g_cross: I learned a lot hoogling stuff and viewing the source
16:56:22 <Philippa> (it might /wrap/ one, but it isn't actually one)
16:56:32 <Philonous> CakeProphet: Of course it does. Only the value the action will produce when executed changes
16:56:41 <augur> oh, you mean in terms of how its defined in the language its not a function?
16:56:46 <c_wraith> CakeProphet: it always produces the same action if you define action as "a set of IO operations to perform" rather than "the result of the RTS executing those IO operations"
16:56:48 <augur> ok, fair enough
16:56:50 <Benny_> "Hah! I bet they must have had to resort to some horrible hack to get this to work in Haske-oh"
16:56:50 <Philippa> right, it's a value
16:56:53 <Philonous> CakeProphet: and the side effects
16:56:59 <g_cross> lol
16:57:00 <augur> theres no getChar = \flibble -> blobble
16:57:06 <CakeProphet> Philonous:  but what if the changing value determines the action that is returned? 
16:57:40 <g_cross> CakeProphet:  That is contained inside the action
16:57:41 <Philippa> it's (pure) lambda calculus where everything truly is a function, in Haskell we don't actually have to define everything as its own eliminator though
16:58:03 <g_cross> CakeProphet: "getChar >>= f" is  the action consisting of reading a character and then feeding it into f to decide what to do next
16:58:13 <jkingkong> the flipping arrows in coburger land post is fantastic
16:58:14 <g_cross> CakeProphet:  The constuction of this action is completely pure
16:58:25 <jkingkong> (off topic)
16:58:26 <g_cross> CakeProphet:  However, it doesn't do anything until you feed the action into something that can run it
16:58:54 <g_cross> CakeProphet:  So put another way, the construction of the value of main, which is IO (), is completely pure
16:58:59 <CakeProphet> g_cross: hmmm, I guess. That only makes sense because a value of type IO is such a vague notion (it is an abstract type).
16:59:06 <Philonous> CakeProphet: "getChar >>= \x -> case x of "y" -> launcheMissiles; _ -> return () " is still one action that just changes it's behaviour according to what you enter
16:59:16 <g_cross> CakeProphet:  However, once the program is started, it does something impure with the value of main
16:59:45 <g_cross> CakeProphet:  So the result of executing the program is impure, even though the value of main is pure.
17:00:15 <g_cross> CakeProphet:  So think of >>= as being a composition operator that allows you to purely build up a program value, that is then used in an impure way.
17:00:55 <g_cross> CakeProphet:  Where by "program" value I mean roughly the list of instructions that is actually executed
17:01:18 <Philippa> augur: oops, when I said parsec-with-trivial-return, that's also without try :-) The lack of backtracking/lookahead is what the (1) specifies
17:02:20 <CakeProphet> I've already learned about monads, btw. So there's no need to explain >>= as a composition operator to me. I was simply considering the philosophical notion of referential transparency, I guess.
17:02:25 <CakeProphet> in relation to IO
17:02:48 <g_cross> CakeProphet:  So for example, if you have some function "f" of type "a -> IO ()" that computes the action to perform as a function of a, then you could actually apply f in parallel to a list of values of type "a", and then execute all of the actions in sequence
17:02:49 <Philonous> CakeProphet: The magic trick is to decouple the runtime system from haskell. If we where honest we'd have to admit that haskell is utterly useless because it doesn't permit any interaction with the real world. It's only when we add the runtime system that we get something usefull out of it. So we create this state of cognitive dissonance where the RTS is sometimes part of haskell and sometimes not. 
17:02:51 <Philippa> it's simple: execution's impure as hell, but that doesn't mean you can't use RT when you build your impure program
17:03:07 <g_cross> CakeProphet:  So you can use the referential transparency to actually use deterministic parallelism to compute IO actions.
17:03:17 <g_cross> CakeProphet:  Which comes from the fact that everything is pure
17:03:17 <Philippa> haskell becomes a metalanguage around your impure code, essentially
17:03:34 <Pseudonym> As far as your CPU is concerned, a word is a word and a byte is a byte.
17:03:52 <Pseudonym> It could be an integer, a bit vector, a small string or whatever.  Your CPU doesn't care.
17:04:06 <CakeProphet> Pseudonym: technically, I would say your CPU has absolutely no concerns. :P
17:04:14 <Pseudonym> Right.  Point is, it's the same thing.
17:04:19 <Pseudonym> Execution is, more or less, typeless.
17:04:22 <Pseudonym> At the hardware level.
17:04:26 <CakeProphet> yes.
17:05:03 <Philippa> CakeProphet: the CPU knows words from bytes, it just doesn't type the address space
17:05:37 <Philippa> AH != AL or AH, for example
17:05:42 <Philippa> er, AX != ...
17:05:48 <Philippa> (x86 example)
17:06:32 <CakeProphet> saying a CPU is concerned with type is like saying a saw is concerned with physics.
17:06:39 <Pseudonym> But it doesn't know the difference between a 64 bit word and a 64 element bit vector, say.
17:06:41 <g_cross> CakeProphet:  So for example, if you have a bunch of threads and you only want one IO action executing at a time but you still want parallelism, you can actually spark having each thread compute which IO action it wants to perform next in parallel due to referential transparency, and then run the resulting list of IO actions in serial.
17:07:08 <g_cross> CakeProphet: (I actually used this scheme once myself.)
17:07:10 <Benny_> 20:06 < Pseudonym> But it doesn't know the difference between a 64 bit word and  a 64 element bit vector, say.
17:07:13 <Benny_> bzzzzzzrt
17:07:20 <Benny_> Sorry
17:07:27 <p_l> CakeProphet: actually, the correct thing to say is that the CPU that GHC is available on don't do types... there were CPUs that had typed execution model
17:07:32 <Benny_> That's just, from my perspective, not even English :P
17:07:43 <Benny_> In the sense that a CPU knows what a bit vector is
17:07:43 <Philippa> CakeProphet: yes, but bytes and words are still different entities
17:07:54 <Pseudonym> The IA64 does.
17:08:10 <Pseudonym> But I thought we'd ignore that case for the moment.
17:08:12 <Benny_> It's like saying your bits have a color
17:08:28 <CakeProphet> p_l: My statement is still relevant. I'm saying a CPU doesn't "concern" about things. 
17:08:33 <Pseudonym> Benny, my point is that "types" are a high-level concept.
17:08:38 <Benny_> There is no further data in a set of bits than those bits themselves
17:08:40 <p_l> Pseudonym: hell, Ivory, L-Machine, K-Machineand others had quite a lot of typing support :)
17:09:03 <Benny_> yes, and my point is that I live in the low-level world, and you're saying sandwiches have personalities :P
17:09:12 <CakeProphet> haha.
17:09:18 <int80_h> hmm
17:09:23 <int80_h> I missed some context
17:09:27 <Benny_> haha
17:09:28 <Pseudonym> Benny, Haskellers have a bit of a fondness for type theory.
17:09:42 <Pseudonym> But type theory is a high-level concept.  That's all I'm saying.
17:09:49 <int80_h> anyone here using yesod in production?
17:09:49 <Benny_> Yeah, I'm mostly joking
17:09:52 <Benny_> I know what you mean :P
17:10:04 <Pseudonym> :-)
17:10:04 <Philippa> eh, I don't know that it's high-level. It's just not part of current hardware
17:10:17 <Benny_> But at first glance from the perspective I come from, you were speaking Chinese :P
17:10:33 <Pseudonym> When you send octets across a wire, the only reason why the source machine and destination machine agree on what those bytes mean is because a document somewhere says so.
17:10:33 <Philippa> (haskell is mostly fairly low-level on a mathematical base, it's just that it includes sufficient abstraction mechanisms for a number of purposes)
17:10:43 <Benny_> 20:09 < Philippa> eh, I don't know that it's high-level. It's just not part of  current hardware
17:10:51 <Benny_> The type of a value is a piece of information
17:11:12 <g_cross> I don't know about you all, but my x86 instructions are execute by a room full of Chinese.
17:11:12 <Philippa> yeah, but consider what's "low-level" on the JVM, for example
17:11:17 <Benny_> You can't color your bits, so you need more bits to store what type it is if you want to be able to, say, pull a typed value out of memory :P
17:11:17 <g_cross> Much cheaper that way.
17:11:42 <EvanR> somehow i thought you were invoking the chinese room thought experiment
17:11:43 <Philippa> Benny_: in other words, you can encode it. It's still not a hardware-level concept
17:11:46 <int80_h> g_cross : how in the heck do you manage to keep your bits from being tainted by lead?
17:11:48 <Pseudonym> g_cross: I hope they've licensed the relevant patents.
17:11:50 <Philippa> (on most current hardware)
17:12:12 <Benny_> Yes, but hardware can't pass a general list around
17:12:20 <Benny_> Well, it could, painfully
17:12:37 <g_cross> EvanR:  I was, with a twist :-)
17:12:43 <Benny_> You could say TAKE THE LIST AT X AND CONCATENATE IT TO THE ONE AT Y AND STORE IT AT Z
17:12:51 <Benny_> *caps*
17:13:06 <EvanR> hardware, software whats the difference
17:13:07 <Benny_> But that's not storing the list, that's pointing to the list using an address
17:13:08 <Philippa> sure, I'm not saying hardware should be different. I'm just pointing out that there are other viable concepts of "low-level" than typical hardware implementations
17:13:19 <Philippa> to put it another way: naive set theory is low-level too
17:13:20 <EvanR> > concat [[1,2],[3,4]]
17:13:21 <lambdabot>   [1,2,3,4]
17:13:26 <Pseudonym> Benny, take your COBOL elsewhere
17:13:29 <Benny_> haha
17:14:01 <Benny_> > let wat = wat in wat
17:14:06 <lambdabot>   mueval-core: Time limit exceeded
17:14:06 <p_l> Benny_: talking in caps is hard :)
17:14:06 <Philippa> (and so is scribbling on paper, that's how the turing machine came about)
17:15:34 <Benny_> Now, of course, a CPU that understood lists in the sense of caching them when list instructions are used at an address could be useful
17:16:02 <Benny_> For, say, eliminating the awful performance penalties of simple linked lists
17:16:44 <p_l> Benny_: been done to death
17:16:50 <Benny_> But then you'd still run into RAM being faster when read sequentially
17:17:05 <Pseudonym> Contents of Address Register, Contents of Decrement Register
17:17:10 <Philippa> yeah, but with a little luck you get a degree of locality in your consing too
17:17:10 <Benny_> Yeah
17:19:02 <p_l> Benny_: personally, I think equipping the CPU with tools to allow fast operation on tagged data would be enough. We had seen rise and fall of a specialized cpus that even included some typing support inside already :>
17:20:09 <Pseudonym> The problem is that every time tagged data has been tried, it's turned out to give no performance improvement.
17:20:36 <Philippa> yeah, but that seems to've happened because nobody was using algebraic datatypes
17:20:42 <p_l> Pseudonym: possible. Haven't really looked into it
17:20:57 <Pseudonym> Modern superscalar CPUs are pretty fast.
17:21:00 <Ran__> Hi! Complete beginner here. I have the function    getPrimes n = take n [ i | i <- [2..], isPrime i ]      but I don't really understand how I'm supposed to write the typeclass-thing. I tried   getPrimes :: (Integral a) => a -> [a]  but that didn't work, something with Int and Integer not complying?
17:21:02 <Philippa> it doesn't net you much if you're only tagging for the GC
17:21:19 <Benny_> Ran__: take takes an Int, I believe
17:21:28 <p_l> I have no idea whether the FORTH-oriented CPUs need any extra knowledge of types or anything like that, the Java-oriented cpus seem to have some
17:21:32 <Philippa> but GHC-style tagging on pointers is an improvement
17:21:33 <soupdragon> Ran__, easy way out is to not bother writing that crap
17:21:41 <soupdragon> Ran__, compiler infers it automatically
17:21:52 <Ran__> soupdragon, I guess so, but still.
17:21:53 <Benny_> yes, it takes an Int
17:21:57 <soupdragon> still ..?
17:22:02 <Benny_> (for purposes of optimization)
17:22:03 <Philippa> Ran__: and then :t getPrimes in ghci
17:22:14 <Pseudonym> If we had the ear of CPU designers (and we did last year!) what we'd really prefer is things like transactional caches, trapping arithmetic and a branch prediction unit which optimises bytecode instruction dispatch better.
17:22:30 <Pseudonym> That last one is not so crucial for Haskellers.
17:22:37 <Benny_> Ran__: You can use Data.List's genericTake if you need to be able to use any Integral t
17:22:47 <Philippa> yeah, although JIT inlining would be cute for haskell still
17:23:15 <Ran__> Ah, now I get it, it's   getPrimes :: (Integral a) => Int -> [a]
17:23:19 <p_l> If I had ear of cpu designers I would shove tagged TLB down their throats :/
17:23:20 <Philippa> it'd really tear things up on monadic code that's "mostly applicative" but wasn't written that way, for example
17:23:49 <p_l> (so that it gets widely implemented)
17:24:10 <Ran__> Anyway, soupdragon, aren't there situations when you need to add that code? I guess I should just learn to look out for those cases instead of always writing them on my own.
17:24:14 <Pseudonym> p_l: It is widely implemented!  There's really only one ISA that doesn't support it.
17:24:24 <Pseudonym> Unfortunately, it's the one we all use.
17:24:43 <p_l> Pseudonym: you mean x86? Last time I checked, only AMD64 had tagged TLB on later cpus, and only one  bit...
17:24:57 <p_l> (only as in "only in the PC world")
17:25:14 <p_l> EV68 had a nice, simple and fast TLB switching
17:25:15 <Pseudonym> It's presumably not in EM64T.
17:25:42 <p_l> Pseudonym: it was part of AMD virtualization extension - if the bit was set, the TLB entry belonged to hypervisor
17:25:46 <Pseudonym> Right.
17:26:13 <Pseudonym> But IIRC, Sparc has it, PPC has it, ARM... maybe.
17:26:50 <Pseudonym> MIPS has it, of course.
17:26:51 <p_l> haven't seen details for SPARC and POWER/PPC, Alpha certainly had it since EV6 (or EV68, don't remember)
17:27:10 * monochrom 's ghc-api-fu increases further, now can load a haskell module that ffi-imports from a C *.o too. (just call ObjLink.loadObj to fetch the C *.o first)
17:27:25 <Pseudonym> Yeah.
17:27:40 <Pseudonym> ARM is tricky, because like MIPS, it's completely software controlled.
17:27:45 <Pseudonym> A TLB miss traps to the OS.
17:28:46 <p_l> I really liked Alpha's. Context switch? save context, purge pipelines, change an eight bit number in a MSR, load context
17:29:11 <p_l> (assuming TLB data for both contexts is already loaded
17:29:11 <p_l> )(
17:29:14 <p_l> )
17:29:19 <Benny_> haha
17:29:28 <Benny_> )
17:29:35 <Pseudonym> Wasn't a context switch handled in the PAL?
17:29:36 <Benny_> That's right, I went there
17:30:04 <Pseudonym> The Alpha was, sadly, before its time.
17:30:25 <p_l> Pseudonym: yes, partially because the TLB architecture wasn't really fixed, iirc.
17:30:42 <Pseudonym> But it did have one big influence on CPU design: it showed that hand-designed circuits beat Verilog.
17:31:29 <Benny_> That was under question? :P
17:31:38 <p_l> Pseudonym: though I suspect brute-forcing automatic layout might beat hand-designed
17:31:47 <p_l> it already has shown promise in aerospace
17:31:56 <Pseudonym> Sure.  Because it was never certain that hand-designed circuits scale.
17:32:02 <Benny_> Ah
17:32:18 <EvanR> time circuits on
17:32:49 <p_l> I have a small project I need to check one day... build a frankenalpha - EV6 on Athlon (K7) board :>
17:33:36 <Pseudonym> I have a bunch of scrawled circuit diagrams sitting around for when I get the time and space to build a CPU.
17:34:00 <Pseudonym> I'm going to do a PDP7 first.  Then something based on the counterflow pipeline.
17:34:16 <tensorpudding> x86 killed everything
17:34:21 <Pseudonym> At least that's the plan.  It may change tomorrow
17:34:25 * p_l is looking into MMIX on FPGA
17:34:26 <Benny_> I have bunches of Verilog I still need to synthesize for the FPGA
17:34:47 <Benny_> But I dread having to reboot to Windows and use the Xilinx suite
17:35:19 <Benny_> Mainly the latter
17:35:25 <kmc> tensorpudding, that's the same PC-centric view that thinks Windows won, too
17:35:31 <EvanR> dont worry, its called Xilinx, you can pretend its Linux
17:35:39 <kmc> embedded devices don't use x86
17:35:40 <kmc> GPUs don't
17:35:47 <kmc> game consoles don't -- Microsoft switched away from it
17:35:48 <tensorpudding> I was being provocative.
17:35:58 <Pseudonym> More PICs, AVRs and ARMs are sold than x86s, I'd wager.
17:36:04 <kmc> way more
17:36:10 <kmc> an AVR costs a fucking dollar
17:36:11 <Benny_> "I see you're trying to assign a pin, would you like to spend fifteen minutes finding it in the dropdown?"
17:36:14 <Pseudonym> Yeah.
17:36:16 <kmc> and is a whole computer
17:36:17 <kmc> it's amazing
17:36:21 <tensorpudding> x86 killed everything else for desktop and workstation though
17:36:35 <Pseudonym> For a digital camera, you'd want an ARM or better, I suspect
17:36:35 <kmc> tensorpudding, for the time being yes
17:36:43 <kmc> tensorpudding, also servers, mostly
17:36:47 <kmc> not HPC though
17:36:54 <tensorpudding> maybe ARM or other RISC could push upwards from embedded to steal share.
17:36:59 <Benny_> I want an AVR to play with
17:37:10 <Benny_> But I don't want to buy a programmer for it
17:37:12 <tensorpudding> Sun still makes sparc workstations right?
17:37:14 <Pseudonym> I used to get paid to write AVR.
17:37:15 <kmc> Benny_, buy an Arduino
17:37:19 <Benny_> * an AVR or ten
17:37:21 <EvanR> Sun still exists?
17:37:23 <tensorpudding> Rather, Oracle.
17:37:27 <Pseudonym> ATmega128
17:37:34 <tensorpudding> I'll continue to call it Sun forever, dammit.
17:37:35 <Pseudonym> Which was a really beautiful chip.
17:37:36 <p_l> tensorpudding: no workstation, not anymore
17:37:37 <EvanR> Oracle Sparc Workstations
17:37:42 <EvanR> like Adobe Flash
17:37:42 <int80_h> was?
17:37:44 <kmc> i expect to see some netbook share taken by ARM smartphone guts in netbook form factor
17:37:44 <Benny_> A lot of the things I've looked at don't work on the Arduino, sadly
17:37:53 <kmc> Benny_, why don't you want to buy a programmer?
17:37:54 <Pseudonym> Though newer Atmels have a really neat feature: built-in FPGA.
17:38:00 <kmc> there are cheap ones, or you can build one
17:38:11 <Pseudonym> Make your own bus.
17:38:11 <p_l> as for embedded space, anything from Broadcom uses MIPS
17:38:12 <tensorpudding> Oracle Solaris doesn't have much of a ring
17:38:24 <kmc> http://www.pjrc.com/hub_isp/ is a hilarious cheeky way of building an AVR programmer
17:38:28 <Pseudonym> Yeah, I think that MIPS is probably the core used in most ASICs.
17:38:38 <kmc> perhaps usable, if only for programming the chip for your real programmer
17:38:42 <Pseudonym> Your wireless interface probably runs on a MIPS core.
17:38:44 <p_l> Pseudonym: my old laptop had more MIPS cores than AMD64 :)
17:38:49 <Pseudonym> Yeah.
17:39:22 <Benny_> Yeah, my biggest problem with building my own is that you need a programmer to program the uc that controls the programmer
17:39:28 <p_l> broadcom's 43xx wireless chips have at *least* 3 MIPS32 cores, I think mine had 4 and there were models with 5
17:39:50 <p_l> there was also a really nice startup doing MIPS64 supercomputers
17:40:01 <p_l> 0.9W per core :)
17:40:02 <kmc> Benny_, maybe you have a friend with an arduino?
17:40:09 <kmc> or someone you can sucker into buying one? ;)
17:40:12 <Benny_> Nope :(
17:40:15 <tensorpudding> I think I have a 43xx in this laptop
17:40:18 <kmc> anyway i just bought the AVRispmkII
17:41:18 <Benny_> How much was that?
17:41:23 <kmc> $30 or so?
17:41:26 <Benny_> Well hell
17:41:28 <kmc> there's cheaper ones
17:41:30 <Benny_> That's fine for me
17:41:40 <Benny_> I just kept running into $50+ ones
17:41:46 <int80_h> AVR butterfly was 25 dollars last I checked
17:41:49 <Pseudonym> http://cgi.ebay.com.au/AVRISP-Atmel-STK500-AVR-ISP-programmer-USB-/320372505646
17:41:58 <Benny_> I can justify $30 during the summer while I have work
17:42:02 <kmc> mouser has AVRISP2 for $34
17:42:17 <kmc> USBtinyISP is popular, it's $22
17:42:22 <Pseudonym> $27.90 for a USB STK500
17:42:25 <Benny_> I saw that one, kmc
17:42:31 <int80_h> anyone here use gumstix?
17:42:37 <Benny_> But I couldn't find somewhere to buy it in the US assembled
17:42:40 <kmc> oh
17:42:47 <Benny_> I don't exactly have a soldering iron, sadly
17:42:50 <kmc> oh :/
17:43:20 <drhodes> reading the grammar, it says it's possible to put guards inside (case _ of) blocks.  after the  ... pattern ->,  should I use a let, where or something else?
17:43:34 <Benny_> I have to move every six months, so I really have to avoid getting anything that takes space
17:43:44 <Pseudonym> drhodes: Sorry, could you give an example?
17:43:49 <kmc> > case () of _ | 2 == 2 -> "foo"
17:43:50 <lambdabot>   "foo"
17:44:08 <ezyang> drhodes: wheres should be created in the outermost scope possible. 
17:44:17 <Pseudonym> > case 1+3 of v | v > 2 -> "it's " ++ show v
17:44:18 <lambdabot>   "it's 4"
17:44:24 <kmc> drhodes, you can't attach a "where" to a case arm, if that's the question
17:44:36 <Benny_> Now why does Jameco not carry the AVRISP2
17:44:48 <Benny_> I have a coupon for free shipping, you see
17:44:52 * p_l wants a radiation-tolerant FPGA... compared to where he wants to put, it will be cheap :D
17:44:52 <drhodes> hmm I thought I tried those,  But you guys have answered my question, thanks!
17:44:53 <Pseudonym> Perhaps we should move the microcontroller discussion to #haskell-blah.
17:45:46 <kmc> p_l, seems tricky, given how FPGAs are basically made of RAM
17:45:51 <kmc> but maybe SRAM is rad-tolerant
17:46:28 <Benny_> Oh, hey
17:46:33 <Benny_> I actually had a haskell question
17:46:39 <Pseudonym> Excellent.
17:47:35 <p_l> kmc: there are such FPGAs, just expensive and iirc have lower density. Still, enough to put a rad-tolerant SPARC64 in orbit :>
17:47:41 <kmc> :D
17:47:59 <Benny_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27606#a27606
17:48:40 <kmc> Benny_
17:48:42 <kmc> :t isJust
17:48:43 <lambdabot> forall a. Maybe a -> Bool
17:48:47 <kmc> :t isJust . snd
17:48:49 <lambdabot> forall a a1. (a1, Maybe a) -> Bool
17:48:49 <Pseudonym> Benny_: [ item | item@(_, Just _) <- subjcontents' ]
17:49:19 <Benny_> heh, I figured there was a builtin
17:49:26 <Benny_> and/or a clever list comprehension :|
17:49:28 <kmc> well, it's just a library function
17:49:32 <kmc> in Data.Maybe iirc
17:49:37 <Pseudonym> @hoogle isJust
17:49:37 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
17:49:40 <Pseudonym> Right.
17:50:12 <Benny_> Anyway, my main question was how to get something like that to parse by layout
17:51:16 <Benny_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27607#a27607 <- What I was trying
17:51:28 <Benny_> It just said I was making an error at line 1
17:51:47 <kmc> Benny_, last line needs to be indented further than "subjcontents"
17:51:55 <Benny_> ohhhhhhhhh
17:52:02 <kmc> otherwise it's another binding in the "let"
17:52:09 <Benny_> Thanks
17:52:13 <kmc> (or closes it entirely, if it's less indented)
17:52:31 <Benny_> My heuristic was that it needed to be aligned further than the starting line
17:52:40 <Benny_> Makes sense
17:52:59 <illissius_> hmm
17:53:15 <kmc> Benny_, http://www.haskell.org/onlinereport/lexemes.html#sect2.7
17:53:22 <illissius_> what's the difference between ST and State? or is only the former 'unsafe' or both?
17:53:29 <kmc> illissius_, they are totally different
17:53:31 <illissius_> minus an or
17:53:33 <kmc> neither is 'unsafe'
17:53:50 <illissius_> well STT supposedly is, but there's a StateT
17:53:56 <kmc> they provide different interfaces, and different strategy of implementation
17:54:24 <kmc> ST has real in-place mutable reference cells
17:54:38 <kmc> and so can't be a transformer -- the underlying monad might backtrack or something
17:54:57 <kmc> State is just sugar for passing a state around by a function parameter
17:55:04 <kmc> simple pure code, easily made a transformer
17:55:17 <dolio> The purpose of ST is to enforce linear usage of an implicitly passed heap, which allows you to optimize it to use actual mutability.
17:55:20 <illissius_> hmm, I see. thanks
17:55:29 <kmc> in GHC, ST has a magic implementation, like IO, and runST is just a nice name for unsafePerformIO.  but it has a type which enforces safety, unlike uPIO
17:55:46 <kmc> at runtime ST and IO are nearly identical
17:56:14 <Philippa> kmc: it could backtrack by parameterising things on a 'clock' as well and keeping history
17:56:22 <kmc> yeah
17:56:30 <kmc> you can make a backtracking monad which uses ST too
17:56:32 <Philippa> well, really for the general case you need to split as well as backtrack, but yeah
17:56:45 <kmc> but you can't make a ST transformer which deals uniformly with whatever underlying monad
17:56:48 <kmc> at least not easily
17:57:16 <ksf> Hmmm I can't think of a better way to make (ab|xy)*ab into a stream to construct the semantics than translating abab into "enter kleene, yield abab, leave kleene 2chars before now"
17:57:38 <Philippa> well, that's what the 'clock' gets you
17:58:01 <ksf> ...as I can't say ab(ab|xy)* as that's not the same, and other transformations would mean that I have to backtrack or worse
17:58:04 <kmc> hmm, maybe you can
17:58:07 <Philippa> you make the underlying monad hang on to how many times you've been through a given continuation and which one you're on, effectively
17:58:25 <kmc> you can write a (O(log n) slower) pure haskell ST
17:58:35 <kmc> and i guess you could make it a transformer
17:58:48 <Philippa> yeah, that too
17:59:09 <Philippa> the reason the clock has to split is that you can re-track too :-(
17:59:10 <Saizan> StateT (IntMap Dynamic)
17:59:18 <kmc> yeah
17:59:35 <kmc> but what if i want more than 2^64 STRefs?!?!?!?
17:59:41 <Philippa> but if you turn each ST cell into a tree-structured cell-history...
17:59:50 <Philippa> then you buy a bigger computer, duh :-)
18:00:12 <Philippa> hmm, the hard bit is GCing it
18:00:22 * monochrom buys a smaller computer. it means bigger ram and faster processing. paradoxical, eh?
18:00:36 <Philippa> you've got to know when a given historical state is definitely, finally dead
18:00:46 <ksf> well the other possibility is to give my matcher a stack
18:01:04 <c_wraith> doesn't that turn it into a pushdown automata?
18:01:06 <kmc> Philippa, yeah, you have to write your own GC with the "pure ST" implementaiton too
18:01:07 <kmc> i think
18:01:20 <Philippa> well, you don't have to, you just /really/ want to
18:01:44 <Philippa> hmm. We should get JaffaCake drunk and challenge him to implement STT sometime, anyway
18:01:56 <kmc> how do you know if one of the refs you handed out is still reachable?
18:01:58 <ksf> dunno. it might. at least pushs and pops are clearly nested.
18:02:02 <kmc> do you need RTS support for finalizers?
18:02:04 <ksf> ...for some values of clear.
18:02:55 <ksf> but it might stay a deterministic transducer.
18:03:25 <ksf> ...I don't think I need an infinitely deep stack.
18:04:19 <Philippa> kmc: the real problem's reachability of history-points. That's much crazier for the GC
18:04:46 <Philippa> that, and you sure as hell don't use a 32 bit number for them
18:05:16 <Philippa> (history point ~= write count + a branching mechanism)
18:06:02 <Philippa> and you have to trace which history points are still live
18:06:11 <Philippa> where history point ~= continuation
18:07:04 <Philippa> (anyone thinking that it's a /really/ stupid idea to keep lots of continuations for a large heap: yep!)
18:07:31 <illissius_> next question... :) what are things which GADTs are useful for, other than typed expression trees?
18:07:54 <Philippa> just about everything
18:07:54 <Saizan> everything is a typed expression tree if you squint hard enough :)
18:07:58 <kmc> isn't everything a typed expression tree?
18:08:04 <kmc> hehe Saizan
18:08:15 <illissius_> yeah i figured i'd get that answer :)
18:08:18 <dolio> Sized vectors.
18:08:25 <Philippa> Saizan: which doesn't have to be very hard, because it /has/ to be represented as at least a typed expression graph
18:08:41 <illissius_> how about things-which-aren't-obviously-typed-expression-trees
18:08:47 <kmc> they're good for passing type equality evidence:  data Eq a b where Refl :: Eq a a
18:08:48 <illissius_> where you at least have to squint
18:08:59 <Philippa> basically, if it's a thing and you want to enforce things on it via the type system, there's good odds on GADTs being one way to represent it
18:09:08 <illissius_> kmc: oh right, and that. was go to mention "and other than that" but forgot
18:09:14 <illissius_> *going
18:09:19 <kmc> illissius_, have you seen MonadPrompt?
18:09:24 <illissius_> I haven't
18:09:40 <kmc> uses a GADT to define the "effects" of a monad separately from the monadic structure
18:09:52 <illissius_> hmm
18:10:28 <kmc> multirec uses GADTs to do generic programming for families of recursive datatypes
18:10:31 <dolio> You can use it to track information about expression trees that isn't just the type, as well.
18:10:44 <Philippa> well, if it's static info about a value, it /is/ a type
18:10:50 <Philippa> or at least should be
18:11:35 <dolio> I assume by type he means like 'Lam :: (Term a -> Term b) -> Term (a -> b)'.
18:11:49 <kmc> illissius_, i also like the GADT syntax even for standard ADTs
18:11:53 <kmc> depending
18:12:02 <kmc> in particular it's a nicer way to define existentials
18:12:14 <kmc> and it gets you /useful/ class constraints on constructors
18:12:15 <illissius_> yeah, same here
18:12:36 <dolio> As opposed to 'TLam :: (b -> Term T b) -> Term T b ; VLam :: (Term V b -> Term V b) -> Term V b'
18:12:56 <Philippa> the real trick is to not think of GADTs as special, just of pattern-matching that uses GADTness
18:13:12 <illissius_> GADTs are one of those things where i mostly understand it, just amn't sure I'd always recognize "this is a problem I could use GADTs to solve" where their use would be indicated
18:13:17 <dolio> Where we have two different representations of lambda expressions, depending on whether we're dealing with syntactic terms or semantic values.
18:13:29 <dolio> Instead of breaking that into two separate types.
18:14:08 <Saizan> aren't those definitions switched?
18:14:35 <Saizan> ah, wait, 'b' is just the phoas thing?
18:14:50 <dolio> Yes. Two different PHOAS encodings.
18:15:00 * hackagebot gray-code 0.1 - Gray code encoder/decoder.  http://hackage.haskell.org/package/gray-code-0.1 (SergeyAstanin)
18:15:01 <dolio> The second one is nicer for normalization.
18:15:47 <Philippa> kmc: I'd quite like ADT syntax with :: MyADT Foo on the end and free type variables generalised for me, too
18:16:02 <Philippa> sometimes the explicit sum structure is... nice to see
18:16:25 <Saizan> yeah, it doesn't exclude exotic terms anymore but i guess that's less of a problem for the output of normalization
18:16:55 <Saizan> (or s/normalization/evaluation/ ?)
18:18:31 <dolio> Yeah. The paper I got the idea from excluded exotic terms by hiding constructors, I think.
18:19:05 <dolio> Although quantifying over the parameter eliminated certain bad terms.
18:19:49 <dolio> Because you can't use 'Place :: b -> Term V b'.
18:20:37 <dolio> Which should only be used to allow folding.
18:20:56 <dolio> It should never appear in a standard term.
18:21:18 <Saizan> how do you write id then?
18:21:28 <dolio> VLam (\x -> x)
18:22:21 <Saizan> ah, ok, and you've "Var :: b -> Term T b" though
18:22:33 <dolio> Yes. For the Chlipala-style PHOAS.
18:23:24 <etpace> Hmm, if I have a string containing a number like "123456.1" and I want it to have a minimum total length and a minimum after the dp, so "123.45" with total len 10, dp len 3 would be: "00123.45000", what do you think would be the best way of doing it?
18:23:30 <Saizan> which paper is this?
18:27:31 <ksf> I should be using notation that matches what I'm trying to do...
18:28:00 <ksf> the first step is transforming (a|x)*ab into (a*ab)|(x*ab)
18:29:05 <ksf> ...what I actually need to do is to have a peek at the continuation when compiling stars.
18:29:56 <ksf> ...so that I can further transform the thing to (aa*b)|(x*ab)
18:31:42 <etpace> How can I catch an 'Exception: Prelude.read' without the IO monad?
18:32:02 <Benny_> You don't catch it :3
18:32:02 <ksf> you can't, not in haskell98 or haskell2010, and that's good.
18:32:07 <ksf> you want to use reads
18:32:51 <g_cross> etpace: look at Text.Read
18:32:52 <kmc> :t \x -> case reads x of [(v,"")] -> Just v; _ -> Nothing
18:32:53 <lambdabot> forall a. (Read a) => String -> Maybe a
18:33:06 <aavogt> @type readIO
18:33:07 <lambdabot> forall a. (Read a) => String -> IO a
18:35:01 <Quaffe> @hoogle Ordering -> Ordering
18:35:02 <lambdabot> Prelude pred :: Enum a => a -> a
18:35:02 <lambdabot> Prelude succ :: Enum a => a -> a
18:35:02 <lambdabot> Prelude id :: a -> a
18:35:59 <aavogt> there aren't too many functions with that type
18:36:13 <kmc> Quaffe, which function do you want?
18:36:42 <kmc> :t (`compare` EQ)
18:36:43 <lambdabot> Ordering -> Ordering
18:36:45 <kmc> > (`compare` EQ)
18:36:46 <Quaffe> just wanted to reverse comparing without using revere
18:36:47 <lambdabot>   Overlapping instances for GHC.Show.Show
18:36:47 <lambdabot>                              (GHC.O...
18:36:58 <kmc> > map (`compare` EQ) [LT..GT]
18:36:59 <lambdabot>   A section must be enclosed in parentheses thus: (`LT..` GT)Not in scope: `L...
18:37:14 <freedrull> cabal keeps asking to update cabal-install everytime i run "cabal update" :\
18:37:27 <aavogt> syntax for qualified things is awful
18:38:22 <Saizan> freedrull: `which cabal` ?
18:38:47 <Quaffe> I guess I want >  case o of { LT->GT; EQ->EQ; GT->LT}
18:38:55 <Saizan> err, without the `s
18:39:53 <aavogt> > map (`compare` EQ) [LT ..GT]
18:39:54 <lambdabot>   [LT,EQ,GT]
18:40:08 <aavogt> > map (compare EQ) [LT ..GT]
18:40:09 <lambdabot>   [GT,EQ,LT]
18:40:10 <freedrull> Saizan: cabal-install version 0.8.0
18:40:20 <dolio> Saizan: I'm not sure where I put it...
18:40:48 <aavogt> or you could just flip the compare you used to get those OrderingS
18:41:16 <Saizan> freedrull: i mean, what's the path of the cabal executable you're using? cabal install cabal-install probably installed it under ~/.cabal/bin, so your 0.8.0 might be in /usr/local/bin masking the new one
18:41:32 <freedrull> Saizan: oh good point
18:41:56 <freedrull> Saizan: yes i am using /usr/bin/cabal, so i will try to use .cabal/bin/cabal
18:43:37 <freedrull> thank you
18:43:41 <Quaffe> @aavogt thanks.  I'm using 'comparing', not 'compare' though
18:43:42 <lambdabot> Unknown command, try @list
18:43:56 <aavogt> @type comparing
18:43:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
18:43:57 <Saizan> np
18:44:31 <Quaffe> @type comparing id
18:44:32 <aavogt> Quaffe: same thing, except you'd write it like     flip (comparing f)
18:44:33 <lambdabot> forall b. (Ord b) => b -> b -> Ordering
18:44:49 <Quaffe> aavogt: ahh, much nicer
18:48:41 <dolio> Saizan: Did that get through?
18:49:43 <Saizan> dolio: last thing was "Saizan: I'm not sure where I put it..."
18:49:54 <dolio> Saizan: Boxes Go Bananas: Encoding Higher-Order Abstract Syntax with Parametric Polymorphism.
18:50:21 <Saizan> thanks :)
18:51:19 <davekong> Is there a function for determining whether a String is a valid Double?
18:51:59 <soupdragon> no
18:52:04 <soupdragon> just have to use reads and see
18:52:11 <Saizan> > (reads :: ReadS Double) "foo"
18:52:12 <lambdabot>   []
18:52:16 <Saizan> > (reads :: ReadS Double) "12.2"
18:52:17 <lambdabot>   [(12.2,"")]
18:52:54 <davekong> cool, thanks
18:53:15 <Benny_> Well
18:53:17 <kmc> :t \x -> case reads x of [(v,"")] -> True; _ -> False
18:53:18 <lambdabot>     Ambiguous type variable `a' in the constraint:
18:53:18 <lambdabot>       `Read a' arising from a use of `reads' at <interactive>:1:11-17
18:53:18 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
18:53:29 <kmc> :t \x -> case reads x :: [(Double,String)] of [(v,"")] -> True; _ -> False
18:53:30 <Benny_> > (reads :: ReadS Double) "12.2wat"
18:53:31 <lambdabot> String -> Bool
18:53:31 <lambdabot>   [(12.2,"wat")]
18:53:50 <Benny_> So be careful if you need to be sure the entire string represents a Double :3
18:57:17 <lispy> hey
18:57:22 <soupdragon> hi
18:57:50 <lispy> I was having trouble thinking of how to represent something in SQL so I switched to Haskell ADTs :)
18:58:04 <lispy> So easy and natural now :)
18:58:20 <lispy> I'll worry about how to represent it in SQL later when I know what I want to represent I guess
18:58:47 <kmc> serialize it into a blob ;P
18:58:53 <lispy> heh
18:59:26 <lispy> So, did you guys notice dons uploaded like 3 things to hackage in the last week?
18:59:33 <lispy> He's a Haskell machine!
18:59:52 * lispy can't even think of libraries to write that quickly
19:00:35 <geheimdienst> dons' brain has 4 cores
19:01:57 <davekong> > (reads :: ReadS Double) "12.4foo13bar"
19:01:59 <lambdabot>   [(12.4,"foo13bar")]
19:02:22 <lispy> > read "12.4foo13bar" :: Double
19:02:23 <lambdabot>   *Exception: Prelude.read: no parse
19:02:35 <lispy> Probably better off that one and catching exceptions
19:03:42 <lispy> > (Just read "12.4foo13bar" :: Double) `catch` _ -> Nothing
19:03:43 <lambdabot>   <no location info>: parse error on input `->'
19:04:02 <Benny_> Or just match against [(_, "")] and _
19:04:31 <Benny_> I can't live without pattern matching these days ;_;
19:04:51 <Benny_> Lisp and others are absolutely byzantine to me
19:05:06 <Benny_> Functional programming is perfectly complemented by pattern matching
19:06:51 <Cale_> Catching exceptions thrown by pure code is never something you should volunteer to do.
19:07:20 <Cale_> The ability to do it is provided for those cases where it's necessary, but it's better to just pattern match if you can.
19:09:07 <ksf> ...grouping is not regular due to the pumping lemma
19:10:21 <ksf> ...and the stack necessary to disambiguate a*a semantically is exactly the length of a, which may be infinite, as it may contain a star itself.
19:11:55 <ksf> still, I don't think it's a real problem as I can inject the stack when compiling the minimized dfa to code. lazyness does the rest (ie. throwing away stuff that isn't queried)
19:16:02 <davekong> Is it a good idea to accept stuff like "123foo" as meaning "123" or I should I assume something is going wrong with where the input is coming from and report an error?
19:16:37 <ksf> you might want to allow whitespace after it
19:16:40 <ksf> (and before)
19:17:13 <ksf> ...but I think you're being prematurely correct.
19:18:00 * ksf conjectures "premature correctness is the source of all confusion"
19:18:36 <davekong> ksf: can you explain what you mean by "Being prematurely correct"?
19:19:32 <ksf> it's working, don't fix it until you're polishing your code.
19:19:58 <ksf> ...you might, after all, re-write the section anyway, in which case doing it now would be wasted effort.
19:20:41 <ksf> just leave a comment that you can grep for.
19:20:41 <davekong> I see, good point
19:26:08 * ksf decides to watch some aduni lectures to fix the idiocities he learned about dfa's in school
19:28:51 <tensorpudding> hmm, i just had a mental blip where I read idiocities like geocities
19:29:03 <monochrom> haha
19:29:38 <davekong> well idiocities is not a word :/
19:29:57 <monochrom> let's create a website with that name :)
19:30:44 <davekong> it's catchy, it sounds like it _could_ be a word
19:31:09 <ksf> "idiocity" is.
19:31:20 <tensorpudding> IdioCities
19:31:29 <ksf> @wn idiocity
19:31:31 <lambdabot> No match for "idiocity".
19:31:32 <tensorpudding> it's like the trashy alternative to Geocities
19:31:44 <ksf> hmmmm
19:31:52 <ksf> there's definitely german "idiotie"
19:32:15 <ksf> maybe english dares again not to be isomorphic.
19:34:00 <ksf> @wn idiocy
19:34:00 <lambdabot> *** "idiocy" wn "WordNet (r) 2.0"
19:34:01 <lambdabot> idiocy
19:34:01 <lambdabot>      n : extreme mental retardation [syn: {amentia}]
19:34:07 <ksf> @wn idiocies
19:34:08 <lambdabot> No match for "idiocies".
19:34:18 <ksf> well that solves the mystery.
19:34:29 <amadan> hi; newbie here. can anyone help with some basic stuff?
19:35:07 <djahandarie> amadan, just go ahead and ask, if someone can help they will. :)
19:35:35 <amadan> I have a predicate which is IO Bool. I need to repeat it k times and see if all of them are true.
19:35:51 <dibblego> @type replicateM
19:35:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
19:36:03 <djahandarie> @src replicateM
19:36:03 <ksf> :t all
19:36:03 <lambdabot> replicateM n x = sequence (replicate n x)
19:36:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:36:18 <amadan> ah, thanks!
19:36:29 <ksf> all <$> replicateM n action
19:36:39 <dibblego> all id
19:36:55 <ksf> oh, yes.
19:37:04 <soupdragon> @src and
19:37:05 <lambdabot> and   =  foldr (&&) True
19:37:15 <soupdragon> @src all
19:37:15 <lambdabot> all p =  and . map p
19:37:41 <djahandarie> I forget if map id can be optimized away or not
19:37:53 <soupdragon> map id = id
19:38:30 <djahandarie> How about for a newtype
19:38:47 <kmc> the spine of «map id xs» will not share with the spine of xs
19:38:51 <kmc> but that shouldn't be observable
19:39:01 <kmc> so the implementation is free to optimize it out
19:39:24 <kmc> in certain esoteric cases this might be a useful property of «map id»
19:39:42 <djahandarie> spine?
19:39:48 <kmc> yeah, the (:) cells making up the list
19:39:52 <kmc> as opposed to their contents
19:39:57 <djahandarie> Ah okay
19:40:06 <djahandarie> How would that matter ever?
19:43:45 <ivanm> AusHac 2010 has started!!! \o/
19:43:51 <djahandarie> \o/
19:44:22 <djahandarie> > "\o/"
19:44:23 <lambdabot>   <no location info>:
19:44:23 <lambdabot>      lexical error in string/character literal at chara...
19:44:28 <djahandarie> Sigh
19:44:30 <djahandarie> > "\\o/"
19:44:31 <lambdabot>   "\\o/"
19:44:36 <djahandarie> > text "\\o/"
19:44:37 <lambdabot>   \o/
19:44:42 <djahandarie> -_-
19:44:52 <Veinor> :info text
19:44:57 <Veinor> ...?
19:44:59 <Veinor> @info text
19:44:59 <lambdabot> text
19:45:16 <djahandarie> It's just the Show instance of some random thing llambdabot has imported
19:45:20 <djahandarie> @type text
19:45:22 <lambdabot> String -> Doc
19:46:13 <djahandarie> @package pretty
19:46:13 <lambdabot> http://hackage.haskell.org/package/pretty
19:46:28 <djahandarie> > Text.PrettyPrint.HughesPJ.text "test"
19:46:29 <lambdabot>   test
19:46:33 <djahandarie> Yeah, that one
19:57:51 <kmc> djahandarie, well, it would be observable with vacuum, or the typesafe observable sharing stuff
19:58:11 <kmc> it would use more heap
19:58:22 <kmc> it might affect when finalizers are run, or which weak pointers are still valid
19:58:31 <jmillikin> Is there a way to make GHC find a package which has been built, but not installed? I've tried -i and -L, but those don't seem to work. Something like <<ghc --make main.hs --FLAG-HERE trunk/dist/build>>, where main.hs requires a module which has been built
19:59:05 <aavogt> there's no guarantee about when those things happen in the first place
19:59:22 <kmc> jmillikin, you can write a package-conf file and use -package-conf
19:59:36 <kmc> right, there's no guarantee
20:00:03 <kmc> but it will change the behavior you see in practice
20:00:06 <jmillikin> kmc: thanks, that works great!
20:00:19 <kmc> for, say, a particular GHC version
20:01:35 <amadan> one more question: "test n = (length [1..n]) / n" gives No instance for (Fractional Int) - I am not sure what I need to do. (I do not want `div`, I want the real division)
20:02:25 <Veinor> > let test n = toInteger (length [1..n]) / n
20:02:26 <lambdabot>   not an expression: `let test n = toInteger (length [1..n]) / n'
20:02:29 <Veinor> > let test n = toInteger (length [1..n]) / n in test 8
20:02:30 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
20:02:30 <lambdabot>    aris...
20:02:35 <Veinor> >:/
20:02:51 <jmillikin> use the "div" function for integer division
20:03:01 <jmillikin> let test n = toInteger (length [1..n]) `div` n
20:03:03 <amadan> i do not want integer division
20:03:15 <jmillikin> Then why are you using toInteger?
20:03:21 <amadan> i am not
20:03:32 <jmillikin> oh, durrr, wrong scrollback
20:03:35 <kmc> amadan, if you use genericLength it will allow the result to be any Num type, including Double or Rational
20:03:38 <amadan> :)
20:03:45 <kmc> otherwise, use fromIntegral to convert
20:04:05 <kmc> :t let test n = fromIntegral (length [1..n]) / n
20:04:07 <lambdabot> <no location info>:
20:04:07 <lambdabot>     not an expression: `let test n = fromIntegral (length [1..n]) / n'
20:04:09 <kmc> :t let test n = fromIntegral (length [1..n]) / n in test
20:04:10 <lambdabot> forall b. (Enum b, Fractional b) => b -> b
20:04:23 <Veinor> > let test = toEnum (length [1..n]) / n in test 8
20:04:23 <lambdabot>   Couldn't match expected type `t1 -> t'
20:04:24 <lambdabot>         against inferred type `Simpl...
20:04:30 <amadan> thanks, fromIntegral worked.
20:09:09 <soupdragon> if I want to make an open gl program in haskell that steals the mouse , how would you do that?
20:09:56 <djahandarie> How do I create a virus in Haskell?
20:10:07 <johnw> call it a Monad
20:11:14 <ivanm> djahandarie: how do you create a virus in other languages?
20:11:25 <ivanm> especially in a platform-agnostic one
20:12:30 <soupdragon> how can I do 3d graphics in haskel
20:12:42 <djahandarie> ivanm, I don't
20:13:08 <ivanm> you just want a functional virus then?
20:13:08 <ivanm> soupdragon: OpenGL?
20:13:18 <ivanm> gloss has some high-level wrapper stuff...
20:13:43 <soupdragon> gloss is 2d
20:14:09 <djahandarie> I'd like a subset of IO that only allows for malicious operations
20:15:07 <djahandarie> On a semi-related note, if IO was fully denotational, wouldn't that make stuff like detecting security holes amazingly easy?
20:16:35 <soupdragon> nehe-tuts-0.1.1 doesn't complei :/
20:17:24 <jbapple> Is there a notion of exceptions that makes sense in the ST monad?
20:17:53 <kmc> the one we already have allows you to throw in ST and catch in IO
20:18:02 <Gracenotes> besides ErrorT?
20:18:27 <kmc> soupdragon, probably GLUT or SDL.  it's not OpenGL's job to handle mouse input
20:18:34 <jbapple> kmc: I thought you could throw in anything. Also, I'd like to throw and catch in ST
20:18:45 <jbapple> Gracenotes: I'll look at ErrorT
20:18:49 <jbapple> @hoogle ErrorT
20:18:49 <lambdabot> Control.Monad.Error newtype ErrorT e m a
20:18:49 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
20:18:49 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
20:18:49 <kmc> jbapple, yes, you can throw in anything, particularly in ST
20:18:59 <kmc> although ,i'm not sure how to make an ST action which throws on execution
20:19:02 <kmc> we have throwIO for that
20:19:04 <kmc> @hoogle throwST
20:19:04 <lambdabot> No results found
20:19:07 <kmc> :/
20:19:23 <aavogt> @hoogle land
20:19:23 <lambdabot> Data.Graph.Inductive.Graphviz Landscape :: Orient
20:19:25 <Gracenotes> ST doesn't provide you much besides mutable references. to give up on a computation, I think the type system might be better than the runtime system for that
20:19:41 <jbapple> Gracenotes: What do you mean?
20:19:45 <kmc> @unmtl ErrorT e ST a
20:19:45 <lambdabot> ST (Either e a)
20:20:11 <aavogt> that's different from an exception
20:20:28 <Axman6> shouldn't that be (ST s)?
20:20:45 <aavogt> :k ST
20:20:46 <kmc> err yes
20:20:46 <lambdabot> * -> * -> *
20:20:49 <kmc> @unmtl ErrorT e (ST s) a
20:20:49 <lambdabot> ST s (Either e a)
20:21:05 <jbapple> I think that might be exactly what I want
20:21:17 <kmc> won't it keep executing past the error?
20:21:28 <jbapple> I dunno
20:21:47 <jbapple> Wouldn't that depend on how the instance was written
20:22:06 <jbapple> If so, and if the instance is written in a way I don't like, I can just write my own
20:22:10 <aavogt> > runErrorT (do return 1; throwError "lol"; return 2) :: Maybe (Either String Int)
20:22:11 <lambdabot>   Just (Left "lol")
20:22:18 <jbapple> I was having some trouble getting my mind around what I really wanted
20:22:36 <jbapple> Haskell is sometimes good for making me understand what I was doing in imperative languages in the first place
20:22:42 <aavogt> > runErrorT (do return 1; throwError "lol"; Nothing) :: Maybe (Either String Int)
20:22:43 <kmc> yeah
20:22:43 <lambdabot>   Couldn't match expected type `Control.Monad.Error.ErrorT
20:22:43 <lambdabot>                   ...
20:22:46 <Gracenotes> with ErrorT -- at every step of the way, it checks the result
20:22:49 <jbapple> It's like embedding classical logic in constructive logic
20:22:57 <aavogt> > runErrorT (do return 1; throwError "lol"; guard False) :: Maybe (Either String Int)
20:22:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:22:58 <lambdabot>         against inferred type ...
20:23:11 <aavogt> > runErrorT (do return 1; throwError "lol"; guard False; return 2) :: Maybe (Either String Int)
20:23:11 <lambdabot>   Just (Left "lol")
20:23:36 <aavogt> it should stop the ST effects if it's anything like maybe there
20:23:48 <Gracenotes> though performance might take an ever-so-small linear hit, if you're translating a tight loop from C into ErrorT ST, might not go that well
20:24:17 <jbapple> I saw a funny ST performance problem in vector yesterday
20:24:31 <jbapple> That might be the PrimMonad thing bos posted about
20:24:49 <Axman6> jbapple: well, If you'd like to see it fixed, Roman is here working on Vector
20:24:58 <jbapple> aavogt: Yes, I think your example shows that ErrorT doesn't do exactly as I would like.
20:25:26 <jbapple> Axman6: I think SPJ indicated it was not a Vector problem
20:25:46 <jbapple> aavogt: I wonder if that is a fundamental limitation, or if MyOwnErrorT could get around it
20:27:44 <jbapple> Axman6: although I did post an enhancement request I would love to poke Roman about. newWith is very slow compared to using memset
20:28:01 <jbapple> It sets the elements one at a time
20:28:28 <jbapple> but for Storables, memsetting 0 for the whole array seems sensible
20:28:36 <Axman6> fair enough
20:29:17 <jbapple> I ended up actually using this trick: http://research.swtch.com/2008/03/using-uninitialized-memory-for-fun-and.html and just using new
20:29:30 <jbapple> It's a neat trick, but it eats too much memory
20:31:20 <jbapple> @hoogle throwError
20:31:20 <lambdabot> Control.Monad.Error.Class throwError :: MonadError e m => e -> m a
21:00:29 <jbapple> cabal install vector complains: cabal: cannot configure vector-0.6.0.2. It requires ghc >=6.9
21:00:36 <jbapple> Yet I have ghc 6.12.2 installed
21:01:27 <ksf> use -v and have a look at why 6.12.2 is thrown out.
21:01:33 <jbapple> ksf: ok
21:02:26 <jbapple> ksf: cabal -v outputs lines including "/usr/local/bin/ghc-pkg --version".
21:02:34 <jbapple> When I call that by hand, it says 6.12.2
21:03:39 <jbapple> I had some trouble this afternoon with cabal
21:03:44 <jbapple> or, llvm
21:03:52 <jbapple> I tried installing basic, which tried to install llvm
21:04:02 <jbapple> but that said my cabal wasn't up to date
21:04:08 <jbapple> I didn't investigate
21:04:23 <ksf> ...cabal install vector -v /me means
21:04:40 <ksf> it should output all the descisions cabal makes wrt. dependencies
21:04:57 <jbapple> ksf: I'll hpaste the output for you
21:05:02 <jbapple> (BTW, thanks for the help)
21:05:53 <jbapple> ksf: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27619#a27619
21:06:56 <jbapple> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27619#a27620
21:06:58 <ksf> er. uh.
21:07:09 <jbapple> ok, it finds ghc 6.12.2, but thinks it's less than 6.9
21:07:19 <ksf> what does ghc-pkg list ghc say?
21:08:06 <jbapple> 6.12.2, but it warns me of broken packages and says to run ghc-pkg check
21:08:09 <mvid> why am i getting "not in scope" errors for "delete"
21:08:10 <jbapple> I'll do that now
21:08:16 <mvid> isnt that a basic list function?
21:08:27 <ksf> ...which will most likely tell you to recache.
21:08:46 <ksf> you will most likely have to do that as root as the system database is concerned.
21:08:49 <jbapple> it looks like my containers is broken
21:09:06 <jbapple> There are problems in package criterion-0.5.0.0: dependency "containers-0.3.0.0-9249acfef8057539050eb2e7cf79c57f" doesn't exist
21:09:26 <jbapple> and template-haskell and binary
21:09:32 <ksf> ghc doesn't depend on anything
21:09:35 <jbapple> it does not suggest a fix
21:09:39 <ksf> ...the packag ghc, that is.
21:10:02 <jbapple> There are problems in package ghc-6.12.2:  dependency "containers-0.3.0.0-9249acfef8057539050eb2e7cf79c57f" doesn't exist
21:10:30 <ksf> try a recache
21:10:41 <ksf> maybe it's there but ghc forgot about it
21:10:54 <ksf> if that doesn't work, I guess you will have to reinstall ghc
21:11:00 <jbapple> ok, although I already started cabal reinstalling containers
21:11:01 <jbapple> oh god
21:11:03 <jbapple> WTF
21:11:34 <ksf> re-installing containers won't help, as packages depend upon specific builds, not just versions.
21:11:41 <jbapple> how do I "recache"?
21:11:46 <ksf> ....that's the long hex thing after the version.
21:11:51 <ksf> ghc-pkg recache
21:12:12 <ksf> ...as root, and with --global.
21:12:38 <ksf> er no global is the default.
21:12:56 <jbapple>  $ sudo ghc-pkg recache --global
21:12:57 <jbapple> ghc-pkg: command-line syntax error
21:13:45 <jbapple> oh, that was the wrong ghc-pkg
21:13:52 <ksf> hmmm it works here with 6.12.3...
21:13:52 <jbapple> (/usr/bin)
21:14:04 <mvid> what am i doing wrong that neither "delete" nor (\\) are in scope
21:14:06 <ksf> cabal is going to search your path
21:14:07 <jbapple> now it just doesn't output anything. rechecking
21:14:12 <ksf> ...so the one you want to use should be first.
21:14:40 <jbapple> yeah, everything is still broken
21:15:06 <jbapple> I haven't done anything but install some packages 
21:15:21 <jbapple> cabal install seems to somehow have broken my whole GHC :-(
21:16:28 <ksf> do you have a containers directory in /usr/lib64/ghc-6,12.2?
21:17:06 <ksf> it comes with ghc, you'd have to go to length to break that
21:17:12 <ksf> ...like unregistering it or something.
21:17:16 <jbapple> I don't even have a /usr/lib64/ghc*
21:17:20 <jbapple> let me check local
21:17:22 <ksf> /usr/lib?
21:17:46 <ksf> ghc-pkg list shows the directories
21:18:02 <jbapple> ok, I have one in /usr/local/lib/ghc-6.12.2
21:18:40 <ksf> ...does ghc-pkg list containers find it?
21:18:58 <jbapple> yes
21:19:05 <ksf> ...better use -v there, to see the build identifier.
21:19:49 <jbapple> by which you mean the hex?
21:19:53 <ksf> yep
21:19:57 <jbapple> 5e5316afb979d62081115c0576cc0513
21:20:04 <cap11235> I had similar issues a week ago, while I was runnign Arch. It turns out that I mixed cabal install'ed packages with ones from the distro's package manager. I just deleted all the ghc folder, ~/.cabal, and ~/.gtk, and reinstalled them.
21:20:12 <ksf> yeah that's different from the one ghc depends on.
21:20:15 <jbapple> but the dependencies are all on 9249acfef8057539050eb2e7cf79c57f
21:20:16 <jbapple> yeah
21:20:38 <jbapple> cap11235: which ghc folder? did you have to reinstall ghc?
21:20:50 <ksf> what I don't get is how the 9249 one could have dissapeared.
21:21:06 <cap11235> Yeah, I uninstalled ghc and cabal-install using the package manager, then I deleted everything that "locate ghc" found.
21:21:07 <jbapple> cap11235: I always try to cabal install global, so I might try deleting ~/.cabal
21:21:19 <jbapple> I really don't want to reinstall ghc
21:21:28 <cap11235> What distro do you run?
21:21:30 <ksf> installing containers again, even the same version, shouldn't delete it.
21:21:45 <jbapple> ksf: I think cabal install TH may have  . . . oh
21:22:02 <ksf> er you don't cabal install th. it comes with ghc.
21:22:15 <jbapple> cap11235: fedora, 10. Fedora makes upgrading hell, but they realease a new version like every 4 hours
21:22:22 <ksf> does it?
21:22:25 <jbapple> cap11235: I think fedora 10's still on ghc 6.10
21:22:55 <cap11235> I've never used Fedora, so I can't help you on the specifics. Just be wary of mixing...
21:22:55 <jbapple> ksf: I dunno. I normally don't think about these things too much, since cabal normally either works or fails. Rarely does it break my GHC
21:23:05 <ksf> cap11235, you could've just looked at /usr/bin/ghc for the paths...
21:23:06 <jbapple> cap11235: mixing what?
21:23:14 <cap11235> Distro packages with cabal packages.
21:23:24 <jbapple> cap11235: I never use distro packages
21:23:38 <mtnviewmark> @quote train
21:23:39 <lambdabot> Meehl says: [The null hypothesis significance test is] a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring
21:23:40 <ksf> gentoo at least has the common curtesy of using ghc-pkg properly...
21:23:50 <mtnviewmark> @quote jello
21:23:51 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
21:24:04 <mtnviewmark> @quote jello
21:24:05 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
21:24:13 <cap11235> NOW IT ALL MAKES SENSE
21:24:25 * ksf suggests installing ghc to $HOME if your distro sucks
21:24:34 <jbapple> really?!?
21:24:36 <ksf> (which seems to be every single one but gentoo and arch)
21:24:38 <jbapple> seems like a pain
21:24:45 <kmc> debian is fine now
21:24:49 <kmc> apt-get install haskell-platform
21:24:49 <jbapple> then I have to add /home/bin to all my paths
21:24:54 <kmc> then you can still use cabal install locally
21:25:24 <ksf> % echo $PATH
21:25:24 <ksf> /home/ksf/.nix-profile/bin:/home/ksf/.cabal/bin:/home/ksf/ghc/bin:/usr/local/bin:/usr/bin:/bin:/opt/bin:/usr/x86_64-pc-linux-gnu/gcc-bin/4.2.4:/opt/blackdown-jdk-1.4.2.03/bin:/opt/blackdown-jdk-1.4.2.03/jre/bin:/usr/lib/plan9/bin:/opt/android-sdk-update-manager-3/tools:/opt/android-sdk-update-manager-3/platforms/android-3/tools:/usr/games/bin:/usr/kde/4.2/bin:/home/ksf/bin:/home/ksf/usr/bin
21:25:25 <jbapple> I'm so frustrated about this. Cabal should not break ghc!
21:25:35 <jbapple> There should be a monad that doesn't allow it!
21:25:35 <gwern> jbapple: is it that hard to modify your $PATH?
21:25:49 <gwern> jbapple: just install into $HOME... it's so nice...
21:26:13 <jbapple> gwern: it's not awful, but I always have 50 terminals open, so that's 50 src ~/.profiles
21:26:22 <jbapple> and god knows what else it will break
21:26:48 <jbapple> like linking, for instance
21:26:51 <jbapple> or man
21:26:57 <jbapple> of whereis
21:27:00 <gwern> so? after the first 1, it's cached
21:27:02 <jbapple> I mean, I just don't know
21:27:07 <gwern> and man operates off a different $PATH
21:27:16 <jbapple> gwern: cached where? what?
21:27:36 <jbapple> a different path? so that means I have to find out where that shell variable is and fix it
21:27:40 <gwern> or... hm. I thought man used $MANPATH but I can't seem to find it
21:27:45 <jbapple> or install the docs globally and the program locally?
21:27:51 <gwern> jbapple: anyway, hardly any haskell programs come with man pages, so...
21:27:57 <jbapple> See, this is what I mean by "a pain"
21:28:00 <cap11235> I think he is saying that is it cached on the harddrive's cache, if you read it several times.
21:28:05 <jbapple> ghc comes with a man page
21:28:08 <gwern> xmonad, I think, has a man page. which is only installed by distros
21:28:08 <jbapple> and I think cabal does
21:28:27 <ksf> install ghc to ~/usr or ~/ghc , the rest goes to ~/.cabal, anyway.
21:28:37 <jbapple> cap11235: Ok, but I don't care about that, I care about typing "source ~/.profile" 50 times
21:28:43 <gwern> jbapple: oh, ghc's man page! oh, that's so useful</sarcasm>
21:28:47 <ksf> you might miss out on ghc's man page, but heck it's not interesting anyways.
21:28:53 <cap11235> Could could just highlight it and middle click 50 times.
21:28:53 <jbapple> thanks for the help gwern
21:28:57 <ksf> jbapple, do you really need to use ghc in all the terms?
21:29:13 <gwern> jbapple: why are you *ever* typing source ~/.profile?
21:29:13 <jbapple> ksf: yes
21:29:29 <jbapple> to reset the path
21:29:40 <jbapple> which I set in .profile or .bashrc or something
21:29:41 <cap11235> Why do you have that many terminals, anyway? Do you have one for each file?
21:29:55 <jbapple> I am choosing to longer engage in this discussion about where I install my GHC
21:30:09 <jbapple> I have them because I do. It's a pain because it is
21:30:33 <jbapple> ksf: I appreciate all your help diagnosing my problem. You were invaluable
21:30:34 <cap11235> I think he's using them to download large amount of porn. That's the only time I ever have that many open.
21:30:45 <jbapple> BECAUSE I WRITE A LOT OF FUCKING CODE
21:30:49 <jbapple> GOD FUCKING DAMMIT
21:31:00 * gwern is starting to think jbapple's problems are bigger than just ghc and cabal not playing nice with packaging systems
21:31:58 * cap11235 thinks that jbapple needs to learn to use buffers
21:32:13 <jbapple> cap11235: I was just trying to get GHC help. Please don't speculate on my personal or sexual life, and I won't speculate on yours. Deal?
21:32:25 <cap11235> No, you are free to speculate on mine.
21:32:31 <kmc> haha
21:32:33 <jbapple> I appreciate your advice on distro packaging
21:32:45 <ezyang> wtf is going on 
21:32:47 * gwern speculates: cap11235 enjoys german porn, of midgets and seniors
21:32:49 * ezyang just came back 
21:33:07 <cap11235> Nothing past 60 years old. Midgets are awesome, though.
21:33:28 <ManateeLazyCat> gwern: Do you know any other paper about hot-swap?
21:33:30 <gwern> I like when they grin
21:33:38 <gwern> ManateeLazyCat: well, there are the old ones
21:34:03 <gwern> ManateeLazyCat: such as the one explaining lambdabot's old hotswapping method using linking
21:34:11 <ManateeLazyCat> gwern: I have read two papers "Plugging Haskell In" and "Dynamic Application From the Group Up"
21:34:16 <gwern> think it covered yi and lambdabot
21:34:35 <gwern> ManateeLazyCat: offhand, I don't know of any others. I think there was a paper or two on xmonad, did you cover that?
21:34:36 <ivanm> this is weird: I have NoImplicitPrelude enabled and "import Prelude()", but ":browse Prelude" will still list the entire Prelude... :s
21:35:02 <Gracenotes> :browse shows everything in the module, even if you don't have it loaded
21:35:15 <ManateeLazyCat> gwern: I think Yi/Xmonad/Lambdat use same technology, just detail is different.
21:35:20 <Gracenotes> or the manner in which you have it loaded. afaik.
21:35:42 <gwern> ManateeLazyCat: right now, yi and xmonad use the same tech; lambdabot shells out to mueval, which uses hint, which wraps the GHC API
21:35:45 <ivanm> Gracenotes: aha
21:36:01 <ivanm> yeah, ":browse! Prelude" has a lot of "GHC.foo" in its output
21:36:04 <gwern> ManateeLazyCat: however, historically neither of the 3 used the techniques they do now :)
21:36:08 <gwern> ManateeLazyCat: confusing, I know
21:36:20 <ivanm> is there any way of finding out what you have in scope?
21:36:21 <ManateeLazyCat> gwern: Yes, hint can work, but it's just for *little* haskell script, it's too slow for big code, such as gtk2hs.
21:36:30 <gwern> ManateeLazyCat: too slow?
21:36:42 <gwern> well, I've never used it 'for big code', so I guess I wouldn't know
21:37:42 <ManateeLazyCat> gwern: In emacs solution is "Static C Core ++ Elisp Interpreter", keep core won't change, then all hot-swapping feature is base on "elisp interpreter".
21:38:28 <jbapple> I have heard that the best way to uninstall ghc is by just searching through /usr and deleting ghc*. Thoughts?
21:38:32 <gwern> ManateeLazyCat: that's kind of like xmonad. it's hard to impossible to rewrite core xmonad modules from inside an xmonad.hs, on the fly
21:39:09 <ManateeLazyCat> gwern: You said dons is research "hot-swap" with his phD, it's joking?
21:39:13 <gwern> ManateeLazyCat: or so dons argued to me, although I didn't quite understand why one couldn't import from X11 and rewrite from there
21:39:23 <gwern> ManateeLazyCat: no, he supposedly is working on the thesis right now
21:39:48 <ManateeLazyCat> gwern: Just start or close to finish? I really want read it... :)
21:40:16 <gwern> ManateeLazyCat: heard that UNSW gave him and a bunch of other (former) grad students a deadline for next month or something
21:40:38 <ManateeLazyCat> gwern: http://www.flickr.com/photos/48809572@N02/
21:41:01 <ManateeLazyCat> gwern: My gtk2hs multi-processes framework, similar with Google Chrome's framework.
21:41:17 <gwern> so you've written a WM in gtk?
21:41:25 <ManateeLazyCat> gwern: Any tab/sub-module is running in separate process for crash-free.
21:41:33 <ManateeLazyCat> gwern: No, it's a gtk+ program.
21:41:47 <ManateeLazyCat> gwern: A gtk+ program hide a desktop environment in it. :)
21:41:50 <gwern> looks like a wm. it tiles the graphical output of multiple independent GUIs
21:42:20 <cap11235> If you added an XEmbed widget, you could have a wm.
21:42:42 <ManateeLazyCat> gwern: It's multi-processes framework, you can embedded any gtk+/qt/x11 program in it.
21:42:47 <applicative> ManateeLazyCat, wow.
21:42:55 <ManateeLazyCat> gwern: My core is running in daemon process
21:42:56 <gwern> I can put any gtk/qt/x11 based program into my xmonad too
21:43:11 <cap11235> Yeah, if it tiles other programs, I'd say its a wm.
21:43:30 <ManateeLazyCat> gwern: In my program, it's MVC design, that's mean you can running it at backend and don't need display it.
21:43:40 <ManateeLazyCat> gwern: My plugin in running in child process.
21:43:56 <gwern> what's the point of tiling GUI programs if there is no X running?
21:43:58 <ManateeLazyCat> gwern: So my problem is i want use it developing plugin in runtime.
21:44:19 <ManateeLazyCat> gwern: Wait, i give you new screenshot to provide it's not WM.
21:45:26 <cap11235> But if you can embed arbitrary programs, that is enough to make it a wm. All your plugins are just plugins. Or is it that the programs can only be embedded statically?
21:46:07 <ManateeLazyCat> cap11235: MVC design,
21:46:29 <ManateeLazyCat> cap11235: A really WM won't limit MVC design, but my gtk+ program limit that.
21:47:01 <ManateeLazyCat> cap11235: If you want embedded gtk+ program in it, your gtk+ program must design with MVC (Model-View-Controller).
21:47:46 <ManateeLazyCat> gwern: http://www.flickr.com/photos/48809572@N02/4797844247/
21:47:51 <ManateeLazyCat> gwern: It's not WM. :)
21:47:56 <kmc> http://en.wikipedia.org/wiki/Inner-platform_effect
21:48:25 <ManateeLazyCat> cap11235: MVC mean you can split two window to view different part of same buffer.
21:48:33 <gwern> ManateeLazyCat: I fail to see what's not WMy about that
21:49:04 <kmc> "The inner-platform effect is the tendency of software architects to create a system so customizable as to become a replica, and often a poor replica, of the software development platform they are using. This is generally inefficient and such systems are often considered be examples of an anti-pattern."
21:49:31 <ManateeLazyCat> gwern: I want build a *style* for it. Use keyboard operation everything with uniform behaviour.
21:49:55 <ivanm> @src partition
21:49:55 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
21:49:55 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
21:49:55 <lambdabot>                               | otherwise = (ts, x:fs)
21:49:58 <gwern> ManateeLazyCat: maybe you would prefer to use one of the emacs-based WMs
21:50:07 <ivanm> ^^ what's the point of passing the predicate around in there?
21:50:09 <applicative> gwern, his purpose must be more than a window manager, if he's writing the programs that fill the windows too.  Or am I wrong?
21:50:33 <gwern> applicative: but he's not. he's got a PDF viewer he didn't write, emacs, firefox, etc
21:50:35 <ManateeLazyCat> gwern: In a WM or desktop environment, not those limit, you can build any program with you style, result is, you need switch many different program, and use different behaviour to operate those program, how painful?
21:50:40 <cap11235> Well, it would still be a superset of a WM.
21:50:46 <kmc> ivan, it means select has no free variables.  that might be significant for the code produced?
21:50:49 <ManateeLazyCat> applicative: No.
21:50:49 <kmc> ivanm, *
21:51:05 <ManateeLazyCat> applicative: It's not WM, just have mini WM feature for manage window/tab.
21:51:06 <ivanm> kmc: hmmm...
21:51:13 <applicative> hm, so why isn't it a window manager
21:51:23 <gwern> so it's a crappy WM?
21:51:53 <ManateeLazyCat> gwern: It's super Emacs, but not just for Text.
21:51:57 <ManateeLazyCat> gwern: See? :)
21:51:58 <cap11235> "A window manager is system software that controls the placement and appearance of windows within a windowing system in a graphical user interface." It sure looks like it does that.
21:52:12 <kmc> ManateeLazyCat, how is "super Emacs, but not just for Text" not the same thing as a window manager
21:52:20 <gwern> ManateeLazyCat: no, I don't!
21:52:41 <ManateeLazyCat> kmc: It's not design for WM. :)
21:53:20 * gwern stands by the 'crappy' comment, then.
21:53:27 <applicative> it seems well that ManateeLazyCat explain what he's doing, but what's the point of this hostility?  
21:53:44 * ksf wonders why yi doesn't use xmonad as wm
21:53:53 * cap11235 thinks gwern needs a hug, or at least to step away from the computer for a little bit
21:54:07 <ksf> ...or, rather, why xmonad isn't abstracted away from x
21:54:10 <gwern> applicative: because he's aggressively insisting that it isn't a wm, and it sounds like a big timesink for a decent programmer
21:54:38 * applicative thinks this is rather un-#haskelly
21:54:39 <gwern> ksf: that would be pretty cool. I think the tiling paradigm maps well onto other backends, but no one has disentangled it from the X calls
21:54:40 <kmc> i repeat, http://en.wikipedia.org/wiki/Inner-platform_effect
21:54:52 <cap11235> gwern, I don't think we are disagreeing with you, it's just the manner you go about saying it.
21:55:10 <gwern> cap11235: I only pulled out the 'crappy' comment after quite a bit of discussion
21:55:24 <kmc> anyway i think ManateeLazyCat's project is cool just for advancing the state of Gtk2Hs, providing a cool sample program
21:55:28 <applicative> gwern, i think he's been helping update the gtk2hs business, so there 
21:55:35 <kmc> and working out numerous API issues i'm sure
21:55:38 <applicative> right, like kmc said
21:55:40 <gwern> applicative: has he? that'd be useful
21:55:54 <Gracenotes> kmc: they have another term for reinventing the wheel?
21:55:55 <ManateeLazyCat> kmc: Yes, improve gtk2hs is one of aim 
21:56:08 <kmc> Gracenotes, ironic eh?
21:56:13 <kmc> Gracenotes, inner-platform is more specific though, if that's what you mean
21:56:15 <ManateeLazyCat> kmc: But it's not toy
21:57:01 <gwern> I thought 'reinventing the wheel' was 'NIH' in software engineering terms
21:57:02 <kmc> there are people who use emacs as their OS, or use IRC as their OS, or the Web, etc.
21:57:21 <kmc> this project could be another option there
21:57:36 <Gracenotes> well, why choose between a bazaar and a cathedral when you can have a baazar inside of a cathedral
21:57:49 <kmc> Gracenotes, money changers in the temple?!?
21:58:09 <cap11235> HERE COMES JESUS
21:58:10 <gwern> well, usually those come with some advantage. the Web as OS has advantages as far as distributed backup & accessibility, everything-in-emacs has advantages of lisp scripting and shared context, IRC has real-time social stuff as advantages, and so on
21:58:14 <gwern> what does this offer?
21:58:27 <kmc> Haskell scripting and shared context
21:58:32 <Gracenotes> cue andrew lloyd webber rock solo
21:58:33 <ivanm> Gracenotes: or you could have a cathedral as part of your bazaar... ;-)
21:58:36 <gwern> cap11235: you know, in the entire new testament, a whip is the only thing actually made by jesus the carpenter
21:58:42 <kmc> kinky
21:58:46 * applicative wonders whether haskell is re-inventing the wheel, maybe i could learn algol
21:58:52 <cap11235> That'll go well with my midgets.
21:58:55 <ManateeLazyCat> gwern: Only differ my project with Emacs, i use Haskell, emacs use elisp, and i use multi-processes framework. taht's all..
21:58:56 <ivanm> gwern: huh? I don't recall him making a whip at all...
21:59:02 <ManateeLazyCat> gwern: One more, base on GTK+
21:59:06 <ezyang> Help me out: I'm thinking of a paper which describes a scheme for writing one set of code that both parses and prints--does anyone know what paper that is? 
21:59:22 <ivanm> ezyang: parses and prints what?
21:59:27 <applicative> ivanm, to drive the moneychangers from the Temple
21:59:41 <ezyang> ivanm: Data structures, I guess. 
21:59:46 * ivanm doesn't recall him making a whip to do so...
21:59:51 <Gracenotes> convert string <-> data structure then
21:59:56 <gwern> ezyang: is this the recent one based on games?
22:00:03 <kmc> ezyang, hmm, some attribute grammars can do that i think
22:00:10 * applicative doesn't remember that part either, but he had unusual powers...
22:00:12 <ManateeLazyCat> Well, i try to use existing project, example, i use WebKit engine for browser, and not re-inventing it.
22:00:13 <cap11235> Yeah, he did make it.
22:00:25 <ezyang> gwern: games -> ? 
22:00:34 <ezyang> it was accepted to some conference somewhere. 
22:00:35 <cap11235> ivanm: http://www.biblestudysite.com/answers5.htm
22:00:39 <gwern> ezyang: ok, so I guess you weren't thinking about that functional pearl then
22:00:42 <ezyang> I thought it was ICFP, but I don't see it on the list 
22:00:48 <gwern> cap11235: or better yet http://en.wikipedia.org/wiki/Cleansing_of_the_Temple ?
22:01:18 <cap11235> Even better. I just pulled the first google result.
22:01:28 <gwern> "And making a whip of cords, he drove them all out of the temple, with the sheep and oxen. "
22:01:34 <applicative> ezyang, there are printerparsers in oleg on e.g. printf
22:01:37 <gwern> http://www.biblegateway.com/passage/?search=Jn%202:13-16;&version=ESV;
22:02:02 <ivanm> cap11235: oh, right, I was thinking of a more normal horse whip or something
22:02:09 * cap11235 thinks #haskell is a great place for bible study
22:02:43 * applicative would like to point out that there are many devout haskellers, so typical irc blasphemy may not be the way to go
22:02:58 <ManateeLazyCat> My program's aim is let more people use gtk2hs and improve it, and any haskeller hacker can write a gtk2hs program in 5 minutes.....
22:03:03 <ManateeLazyCat> That's all.
22:04:42 <cap11235> So, when would you use Template Haskell as opposed to just using closures?
22:05:23 <pikhq> cap11235: Any time you want compile-time code generation, as opposed to executing the same code closing over variables in the surrounding environment.
22:06:07 <cap11235> Yes, but what I'm asking is when you would want to generate the code at compile time.
22:06:16 <ManateeLazyCat> Haskell is cool, but we should not just use it for advanced console program. We should build many friendly GUI program to attract people to learn Haskell. Then Haskell community will become stronger....
22:06:29 <pikhq> Metaprogramming is a very, very, very common thing.
22:06:58 <pikhq> cap11235: If the code is tedious and mechanical in production, you want to just generate it.
22:07:19 <gwern> cap11235: well, suppose you can't simply derive Read/Show? your type is too complex. but you can write TH to take your type and write the complex instance you need
22:07:21 <pikhq> Say, creating a bunch of accessors for a data type that's not using record syntax.
22:07:43 <cap11235> Oh, OK.
22:08:04 <cap11235> So would TH be flexible enough to implement language extensions, like 'do' or 'proc' notation, as well?
22:08:08 <pikhq> (in fact, if TH existed when Haskell 98 was being written, I'd imagine record syntax wouldn't exist at all. That there is something that could profitably be done using just a TH macro.)
22:08:11 <pikhq> cap11235: Yes.
22:08:16 <kmc> cap11235, you can't extend the concrete syntax of the language, except using the quasiquote feature
22:08:29 <pikhq> cap11235: Though with a few limitations. For instance, it'd need to be in a quasiquote block.
22:08:31 <kmc> TH is cumbersome and painful to write, so we often try to accomplish abstraction another way
22:08:38 <kmc> and there are lots of other options
22:08:44 <kmc> but sometimes TH is the only suitable one
22:08:54 <pikhq> Yeah; all this flexibility comes at the cost of *dealing* with the flexibility.
22:09:05 <kmc> but never underestimate the power of a little C preprocessor...
22:09:42 <pikhq> Indeed. The C preprocessor can be quite powerful in the right hands, in spite of how little it does.
22:09:59 <pikhq> (mmm, C lambdas.)
22:10:33 <ksf> erm it's turing-complete.
22:10:39 <ksf> it's a bleeding macro language...
22:10:48 <ksf> they were popular, in the middle ages.
22:10:55 <ksf> dark ages, that is.
22:11:00 <kmc> M4
22:11:00 <cap11235> I don't think it is, since there is no way to loop, I beleive.
22:11:07 <kmc> cap11235, recursive #include
22:11:08 <applicative> i dont know, latex is still popular....
22:11:09 <pikhq> ksf: C preprocessor is not Turing-complete without a wrapper script that finds the fixed point of the output.
22:11:13 <kmc> anyone preprocess Haskell with m4?
22:11:28 <ksf> well let's say there's a complete object system for C implemented in it.
22:11:39 <ksf> ...which does a hell a lot of computation
22:12:06 <ksf> applicative, yes.
22:12:07 <ksf> but
22:12:18 <ksf> they're replacing the language with lua
22:12:41 <ksf> ...mostly so the latex authors can stay sane.
22:12:45 <pikhq> applicative: TeX is still the single best thing there is for typesetting...
22:12:50 <applicative> the gruesomeness of latex macros is not something to be replicated.
22:12:51 <kmc> because of its output
22:12:57 <kmc> every other aspect of the system sucks
22:13:01 <kmc> but the output is beautiful
22:13:17 <kmc> and more than being objectively beautiful, it's now the standard for how math is supposed to look
22:13:20 <pikhq> I dunno, WEB is kinda nice, if old.
22:13:24 <applicative> pikhq, of course it is, but it's nightmare. run latex, three times, then all the macros will unpack...
22:13:33 <applicative> whats WEB
22:13:42 <pikhq> The language TeX is written in.
22:13:50 <ksf> term rewriting seems to be a better match as a preprocessor for raw layout commands than string rewriting...
22:13:59 <ksf> ASTs were invented for a reason.
22:14:05 <kmc> WEB is literate pascal?
22:14:14 <pikhq> Which is essentially a literate version of a subset of Pascal.
22:14:19 <applicative> is was going to say, I thought it was pascal or something
22:14:25 <ivanm> kmc: yeah
22:14:27 <pikhq> (said subset chosen for being easy to implement)
22:14:31 <kmc> Knuth invented literate programming, supposedly
22:14:48 <pikhq> Yes, and he called it WEB.
22:15:02 <ksf> that's because he invented writing papers containing all necessary code...
22:15:10 <pikhq> Heheheh.
22:15:15 <ksf> people still aren't implementing his innovation widely.
22:15:54 <applicative> can't web be used with different programming languages?
22:16:13 <pikhq> No.
22:16:19 <cap11235> Well, web is the programming language.
22:16:39 <cap11235> You can use literate programming with other languages, though.
22:16:42 <wli> I thought WEB was for Pascal or something (CWEB for C).
22:16:49 <pikhq> wli: Yes.
22:16:51 <applicative> CWEB, ok
22:17:34 <pikhq> Anyways. It really amazes me that hardly *anything* even seems to try to achieve the same beauty of output of TeX.
22:18:17 <applicative> pikhq, it's the demand for so called wysiwyg.   you don't typeset then.
22:18:35 <cap11235> You could always use Lyx.
22:18:40 <pikhq> Also, lord help you if you want to use a non-Western language. The only way to get truly beautiful output there involves getting out some metal slugs, or perhaps make some cuttings in wood.
22:18:50 <ksf> lyx is wysiwym
22:18:59 <cap11235> It's close enough for most people, though.
22:19:09 <ksf> ...and of course wygiwym
22:19:10 <mtnviewmark> speaking of beautiful output - anyone want an early peek at my new haddock output?
22:19:30 <ksf> ...haddock with markdown?
22:19:35 <cap11235> A standard person find it much easier to select "paragraph" from a combo box than to type Latex.
22:19:46 <cap11235> Sure, let's see it.
22:19:54 <applicative> it is strange that things like Word don't incorporate proper typesetting as an optional form of output.  This would make word a bit more like lyx or something
22:20:01 <wli> I think ideogrammatic languages have the issue. Otherwise the (La)TeX source itself is uglier but I think it does okay.
22:20:20 <pikhq> I have basically not found anything that can do vertical text rendering well for CJK, for instance. Or ruby text. Or handle glyph variants well. Or do line breaking right.
22:20:23 <pikhq> And so on.
22:20:27 <mtnviewmark> http://www.ozonehouse.com/mark/snap-xhtml/snap-core/Snap-Types.html
22:20:35 <mtnviewmark> just using the Snap module as the example
22:20:43 <mtnviewmark> notice the Style menu in the upper right
22:20:50 <pikhq> wli: It's not the glyphs that cause the problem.
22:21:06 <mtnviewmark> The key is that it is now all legal XHTML, with (mostly) rational semantic markup
22:21:07 <pikhq> That's actually very well supported by most things, in fact.
22:21:16 <mtnviewmark> which means that it can be styled by CSS reasonably
22:21:54 <mtnviewmark> hmmm... even Text Edit, the included little text editor in Mac OS X, supports glyph variants
22:22:07 <amadan> one more newbie problem. I have "ss_prime :: (Integral a, Random a) => a -> IO Bool", and a function "faulty = do r <- filterM ss_prime integerList; return r. I get ambiguous type variable and monomorphism restriction errors against ss_prime. How do I get rid of it? (I can use ss_prime directly, with no errors.)
22:22:41 <mtnviewmark> ksf - no, I didn't change the markup language of haddock, just the web page backend
22:22:53 <pikhq> mtnviewmark: It's more a font issue. It's a royal *pain* to find something that handles the distinctions between mainland China, Hong Kong, Taiwan, Japan, and Korean glyph variants of CJK characters.
22:23:13 <pikhq> Though minor, it really *is* something that is needed for proper CJK support.
22:23:35 <ManateeLazyCat> pikhq: I'm a Chinese.
22:23:54 <ManateeLazyCat> pikhq: China land use Simple Chinese.
22:23:58 <applicative> amadan, isn't "do r <- filterM ss_prime integerList; return r"  the same as   "filterM ss_prime integerList"
22:24:02 <mtnviewmark> has any font house really created a single CJK font with all those glyph variants in the one font?
22:24:03 <pikhq> (minor, because the glyph *variants* as opposed to actual simplifications are generally noticable)
22:24:15 <ManateeLazyCat> pikhq: HongKong Taiwan use Traditional Chinese.
22:24:21 <pikhq> (erm, recognisable)
22:24:28 <mtnviewmark> applicative - yes
22:24:32 <amadan> applicative: i'm building it up to a more complex function - i isolated minimal fragment with an error
22:24:33 <ManateeLazyCat> pikhq: Japan and Korean use some Chinese font, but not all.
22:24:53 <pikhq> ManateeLazyCat: Yes, but they each have their own standards for how the characters should be displayed, even when it is essentially the same characters.
22:24:58 <kmc> amadan, can you hpaste the actual code and error? ss_prime shouldn't give you MMR, it has a type signature
22:25:34 <ManateeLazyCat> pikhq: You can install wqy-microhei font, it's support CJK font.
22:25:50 <ManateeLazyCat> pikhq: In Debian with command "sudo aptitude install ttf-wqy-microhei -y" to install.
22:25:51 <applicative> @type filterM
22:25:52 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:26:00 <pikhq> Yeah; I've installed that font.
22:26:10 <ManateeLazyCat> pikhq: It's provide a uniform width for CJK font.
22:26:36 <ManateeLazyCat> pikhq: It's the most completely *free* font that support CJK.
22:27:03 <mtnviewmark> okay - so four of you looked at that web page -- did it render well?
22:27:07 <pikhq> ManateeLazyCat: Doesn't support the various glyph variants, but it does actually support all the CJK glyphs in Unicode, yeah.
22:27:28 <cap11235> mtnviewmark: Looked fine to me.
22:27:30 <amadan> kmc: all right, here goes... http://paste.org/pastebin/view/20593
22:27:37 <pikhq> (and is the *first font I've found that does that*)
22:27:39 <mtnviewmark> cool - did you try the different styles?
22:27:52 <ManateeLazyCat> pikhq: Do you mean mix various character-set?
22:28:02 <ManateeLazyCat> pikhq: Best way is you Unicode.
22:28:07 <ManateeLazyCat> s/you/use
22:28:15 <pikhq> ManateeLazyCat: No, I mean mixing the different ways of displaying the *same* character.
22:28:34 <cap11235> amadan: Try adding an explicit type to ss_prime
22:28:38 <kmc> amadan, "Possible cause: the monomorphism restriction applied to the following: prime_exponent_mersenne_numbers... Probable fix: give these definition(s) an explicit type signature"
22:28:41 <kmc> amadan, did you try it?
22:29:06 <kmc> amadan, you really ought to have type signatures on all your top-level bindings.  not only does it avoid MMR, it gives better error messages generally?
22:29:08 <kmc> generally*
22:29:27 <pikhq> ManateeLazyCat: For instance, how 草 is displayed depends on the language and the country in question.
22:29:33 <amadan> kmc: ah, i see. newbie here, so... the error messages are still a bit opaque to me... :(
22:29:38 <ManateeLazyCat> pikhq: Unfortunately, CJK have many *same* character, sometimes it's same mean, just different enunciated 
22:30:14 <ManateeLazyCat> pikhq: 草 mean "grass" in Chinese.
22:30:18 <kmc> amadan, so i think your problem will either go away or become more obvious if you add type signatures to the top-level bindings
22:30:30 <amadan> trying it now
22:30:42 <pikhq> ManateeLazyCat: Yes. That specific character is written in a few different ways depending on the language.
22:30:43 <mtnviewmark> pikhq, to a lesser extent the same is true even with Latin characters, and certainly numerals
22:30:43 <kmc> re "grass", http://www.dkuug.dk/jtc1/sc2/wg2/docs/n2326.pdf
22:31:13 <pikhq> ManateeLazyCat: In Hong Kong, the top radical is 4 strokes, in mainland China it's 3, in Singapore it's 3, in Japan it's 3, in Korea I don't even know.
22:31:32 <pikhq> Oh, it's also 4 strokes in Taiwan.
22:31:56 <pikhq> kmc: Oh, the different forms of that radical.
22:31:59 <ManateeLazyCat> pikhq: HongKong and Taiwan use Traditional Chinese. Mainland China use Simple Chinese.
22:32:45 <ManateeLazyCat> pikhq: Example, Simple Chinese "中国", Traditional Chinese "中國"
22:32:46 <cap11235> Doesn't Japan use the traditional characters too, though?
22:32:54 <ManateeLazyCat> cap11235: I don't know the detail.
22:33:01 <pikhq> cap11235: Shinjitai. Mostly traditional, with some simplifications.
22:33:01 <ManateeLazyCat> cap11235: AFAIK, yes.
22:33:05 <pikhq> ManateeLazyCat: I'm very well aware.
22:33:29 <pikhq> ManateeLazyCat: 日本語で話せるんだ。
22:33:32 <mtnviewmark> "Filling the BMP with characters like these will force industry to implement surrogates in order to access less imaginary characters in the SIP."
22:33:34 <mtnviewmark> HEH!
22:33:46 <ManateeLazyCat> pikhq: Are you Japanese? ;-)
22:34:00 <pikhq> ManateeLazyCat: No. I just take language learning seriously.
22:34:15 <pikhq> ManateeLazyCat: Also, I am a tiny bit obsessed with good typesetting.
22:34:40 <pikhq> And am very very annoyed by how I can't even get the right darned glyph variants to show.
22:34:52 <cap11235> I love the feeling of turning in physics or math homework that is properly typeset, on top of the pile of other people's lined paper.
22:35:09 <amadan> cap11235: living in japan. some japanese are traditional chinese, some are simplified, some do not exist in china, afaik.
22:35:20 <pikhq> (why should the Japanese way of writing a character be the only thing I can see, just because it's what I most *often* want to see?!?)
22:35:22 <ManateeLazyCat> amadan: Yes.
22:35:26 <cap11235> I spent last year in Saitama.
22:35:29 <amadan> cap11235: http://www.d.umn.edu/~jbelote/japanmade.html is nice to see.
22:35:41 <ManateeLazyCat> amadan: "some do not exist in china" ... :)
22:35:57 <amadan> haha, i meant, in chinese writing
22:36:21 <cap11235> amadan, where do you live?
22:36:24 <amadan> tokyo
22:36:28 <cap11235> Which part?
22:36:40 <ManateeLazyCat> cap11235 : tokyo ?
22:36:43 <amadan> 平和台
22:36:45 <pikhq> ManateeLazyCat: Yeah, 国字. ;)
22:37:01 <ManateeLazyCat> pikhq: If i talk Chinese, you can understand?
22:37:29 <applicative> amadan, just adding powers_of_two::[Integer] seems to do resolve the problem
22:37:37 <pikhq> ManateeLazyCat: *Maybe*. I know some 2000 Chinese characters, but have hardly any actual studying of Chinese.
22:37:38 <etpace> has anyone here used progression?
22:37:51 <cap11235> amadan, I was in 浦和区
22:38:06 <cap11235> pikhq, I find that hilarious.
22:38:10 <etpace> hey, i just moved to toky ofor the summer 
22:39:00 <pikhq> cap11235: Is true! About the only thing I could directly read would be "nihao" and "beijing". And I'd screw up the pitch!
22:39:01 <ManateeLazyCat> pikhq:  2000 Chinese character is not enough, AFAIK, there have 54678 character in China, even more.
22:39:06 <amadan> cap11235, a lil bit to the north :) not there any more?
22:39:27 <pikhq> ManateeLazyCat: Yeah; that's just what's commonly used in Japanese.
22:39:27 <cap11235> No, I came back in November. Now I'm in California.
22:39:46 <amadan> ManateeLazyCat: everyone in Japan has to know ~2000 characters at the end of high school
22:39:56 <ManateeLazyCat> amadan: Hehe :)
22:39:59 <cap11235> Or they are supposed to...
22:40:02 <gwern> when I read about the complexities of asian scripts, I sometimes wonder what it would take to turn pedantically correct writing into a turing-complete system
22:40:28 <amadan> ManateeLazyCat, it's enough for most purposes, due to huge number of readings each character has.
22:40:39 <ManateeLazyCat> pikhq: If you understand Chinese, you can use Google search how to fix your problem, many Chinese team research this.
22:40:43 <cap11235> sqern: I'm not really sure what you mean by that. They aren't really doing any computation using the characters.
22:40:50 <cap11235> *gwern
22:41:06 <pikhq> Anyways, all my complaints about glyph variants are a bit tangential. Because gosh darnit, you can't even get monolingual text to render right!
22:41:10 <gwern> cap11235: I mean, isn't there computation going on in the proper formatting, alignment, which vriant to choose, and so on?
22:41:24 <cap11235> Oh, I thought you were speaking of the semantics of the characters.
22:41:27 <pikhq> Nothing even does line breaking right!
22:41:38 <amadan> applicative: it does not for me... I get rigid type variable kind of error on that.
22:41:42 <gwern> cap11235: no, if you allow semantics turing-completeness is too easy
22:41:44 <ManateeLazyCat> gwern: This even have Chinese-Programming-Language. :)
22:41:50 <pikhq> And the government of Japan *even published the correct algorithm for it.*
22:42:58 <ManateeLazyCat> gwern: http://www.dywt.com.cn/
22:43:05 <pikhq> In summary: if you want decent typesetting in CJK, you're still going to want to get out your inkstone and brush.
22:43:25 <pikhq> And convince someone to carve a negative of it into wood.
22:43:31 <pikhq> So you can press it into sheets of paper.
22:43:34 <gwern> pikhq: hm, so there's 2d graphicical algorithms involved... ever closer to being TC! :)
22:43:53 <pikhq> gwern: No, no. It's even simpler.
22:44:07 <pikhq> "The following kana should not start a line."
22:44:18 <gwern> ManateeLazyCat: I can't read your crazy moon runes!
22:44:23 <pikhq> (kana being the phonetic script used alongside Chinese characters)
22:44:29 <ManateeLazyCat> gwern: :)
22:45:11 <pikhq> gwern: 月字読め無いか。こりゃ駄目ね。……
22:45:20 <gwern> oh noes, I am probably being insulted!
22:45:25 * gwern probably takes offense
22:45:38 <Pseudonym> Stop trying to hack my terminal!
22:45:57 <pikhq> "You can't read moon runes? That's bad..."
22:46:22 <amadan> lol
22:46:23 <cap11235> ターミナルは死ぬだろう。
22:46:34 <ManateeLazyCat> pikhq: Maybe we need create #haskell-cjk :)
22:46:53 <pikhq> ターミナルを殺そう！一生に！
22:46:56 <pikhq> ManateeLazyCat: Heheh.
22:47:23 <ManateeLazyCat> cap11235: pikhq 终端还是有用的. :)
22:48:18 <ManateeLazyCat> pikhq: https://encrypted.google.com/search?hl=zh-CN&q=cjk+%E6%8E%92%E7%89%88
22:48:20 <BMeph> cap11235: ...so, where in California are you? :)
22:48:25 <cap11235> Santa Barbara.
22:48:37 <ManateeLazyCat> pikhq: If you understand Chinese, have many Chinese resource to fix your problem.
22:48:41 <pikhq> ManateeLazyCat: Oh, so that's how you write "terminal". Hahah.
22:48:47 <amadan> ..."Terminal should die"? ;)
22:48:48 <BMeph> cap11235: Mmm, nice town.
22:48:59 <ManateeLazyCat> pikhq: amadan  Terminal ==> 终端
22:49:08 <pikhq> ManateeLazyCat: Yeah.
22:49:13 <amadan> understandable...
22:49:29 <cap11235> BMeph: Yeah, but I'm rather sick of it, anyway. I'll probably head off to Eastern Europe or something after I finish my BS.
22:49:35 <applicative> amadan, hm, I'm baffled, it compiles fine.  ghci is clearly having trouble calculating "prime_exponent_mersenne_numbers >>= print . head"
22:49:37 <pikhq> And "useful" is of *course* 是有用的. That's just nice and simple.
22:49:49 <pikhq> Erm.
22:49:54 <pikhq> 有用的
22:49:55 <ManateeLazyCat> pikhq: amadan 他们都不懂中文， 哈哈 
22:49:56 <amadan> applicative: (Integral a) = [a] seemed to help.
22:50:06 <gwern> I keep getting confused. 'Andy Stewart' is ManateeLazyCat? but ManateeLazyCat is chinese I thought
22:50:20 <applicative> Andy Stewart is Chinese
22:50:26 <p00ya> hi, i'm trying to use cabal on OS X but it can't install packages because it can't find ranlib
22:50:26 <ManateeLazyCat> gwern: Both are Chinese, but not my Chinese name.
22:50:38 <pikhq> ManateeLazyCat: 日本語も、ハハ
22:50:55 <amadan> ManateeLazyCat: wo3 dong3 yi4dianr3, dan4shi4 cha4buduo1 dou1 wang4le.
22:50:57 <gwern> ManateeLazyCat: isn't that a bit dishonest? it looks like a real name, not a pseudonym
22:50:57 <p00ya> is there a configuration setting to tell it to build libraries the OS X way?
22:51:06 <pikhq> gwern: A common practice for Chinese people is to take up a Western-style name for use outside of China.
22:51:18 <pikhq> By "common" I mean "this is the norm".
22:51:29 <ManateeLazyCat> gwern: If I use my Chinese name, you even can't type it, see?
22:51:32 <gwern> pikhq: hm. it may be common, but I'm not sure I approve
22:51:36 <applicative> gwern, It's totally common.  
22:51:40 <ManateeLazyCat> gwern: That's why i give an Enligh name.
22:51:41 <gwern> ManateeLazyCat: what's wrong with a romanization?
22:51:45 <amadan> ManateeLazyCat: (no chinese kbd tho)
22:51:53 <pikhq> Yeah, it's pretty weird, but it's pretty normal.
22:52:02 <ksf> it'd be impossible to pronounce for non-chinese
22:52:11 <ManateeLazyCat> gwern: Because most people haven't install Chiense input-method, you can't understand it and can't type it for communication.
22:52:25 <gwern> romanization <-> actual chinese may not be a perfect isomorphism, but it's a heck of a lot better than random-western-name <-> actual chinese
22:52:29 <pikhq> ManateeLazyCat: Pinyin-minus-tones?
22:52:37 <ManateeLazyCat> pikhq: PinYin is not correct.
22:52:43 <gwern> ManateeLazyCat: can't type romanization? what
22:52:47 <fhobia> how do you putStrLn floats always with say two digits to the right of the decimal point?
22:52:48 <pikhq> No, I know; it's just an approximation.
22:52:59 <pikhq> Incidentally, what *is* your name in Chinese, anyways? Just curious.
22:53:04 <ManateeLazyCat> gwern: Becuase same romanization have different mean in Chinese.
22:53:23 <gwern> ManateeLazyCat: still better than picking random western names, as I already said
22:53:29 <amadan> ManateeLazyCat, what do you mean pinyin is not correct?
22:53:44 <amadan> (damn i should start learning haskell more, this place is too fun...)
22:53:46 <ManateeLazyCat> gwern: Anyway, it's my Enligh name. 
22:53:53 <ksf> gwern, when pronouncing with the wrong tones, some chinese name may mean something like "likes to fuck his mother" or worse.
22:53:57 <applicative> gwern, are you against  'type Blah = Integer" too?
22:54:06 <ksf> ...I don't think it's a thing to go for.
22:54:11 <pikhq> amadan: Pinyin without tones omits basically 1 out of every 2-4 phonemes.
22:54:24 <amadan> i know - i meant pinyin with tones, obviously...
22:54:34 <gwern> applicative: yes! and against type FilePath = String. not that I think that's analogous to making up a pseudonym-which-looks-real for western use
22:54:44 <pikhq> Also, pinyin *with* tones is only useful to speakers of Mandarin.
22:54:50 <amadan> that is true.
22:54:54 <BMeph> fhobia: Use "printf". :)
22:55:02 <applicative> it's not a pseudonym, it's his English name.  
22:55:02 <fhobia> BMeph: ok
22:55:06 <pikhq> There's more Chinese languages than just Mandarin, even if they *do* happen to have roughly the same written form. :)
22:55:31 <ManateeLazyCat> gwern: I'm a honest man, don't care whether use English name.
22:55:33 <amadan> pikhq: i just found it a bit strange to say "pinyin is not correct" - i was under impression that for an average beijingren, it is (aside from all the rhotacism)
22:55:40 <applicative> you don't use a pseudonym at the bank
22:55:57 <amadan> pikhq; and you can write even that, if you wish.
22:56:10 <gwern> I don't mind pseudonyms - gwern is a pseudonym, after all. I mind unobvious ones.
22:56:34 <mtnviewmark> unobviousness is in the eye of the beholder
22:56:38 <pikhq> ManateeLazyCat: 中国語之名前、何？ Just wondering.
22:56:45 <ManateeLazyCat> pikhq: 保密
22:56:47 <ManateeLazyCat> :)
22:56:50 * cap11235 thinks gwern is an argumentative person
22:56:58 <pikhq> Mmmm.
22:57:05 <pikhq> Why I do in fact know those glyphs.
22:57:06 <pikhq> :)
22:57:12 <gwern> mtnviewmark: given that gwern is a fictional character and even the welsh don't actually name anyone that, it's clear enough to anyone who googles
22:57:25 <gwern> even if not as clear as, say, ManateeLazyCat or pikhq 
22:57:47 <mtnviewmark> that's kind of ridiculous to assume that anyone would surmise that about your irc handle
22:57:53 <BMeph> gwern: Or "Black Mephistopheles, BMeph for short"? ;)
22:58:02 <pikhq> ManateeLazyCat: Would be a pretty cool name to have. Pity that the meaning makes it obviously not your name. :P
22:58:15 <mtnviewmark> and it's rather presumptuous of you to argue with the set of names a man chooses to call himself by
22:58:25 <gwern> BMeph: eh. I dunno, that could be an actual name. B is the initial, and Meph sounds like a real surname
22:58:35 <Pseudonym> Pseudonym isn't my real name.
22:58:42 <Pseudonym> I don't know how more obvious I could make that.
22:58:45 <Gracenotes> someone who uses two names in their handle would be suspected of using their real name
22:58:46 <cap11235> cap11235 is my real name.
22:58:46 <gwern> Pseudonym: what? I don't know what to believe now!
22:58:52 <pikhq> "pikhq" isn't mine, though it's pretty easy to link to mine.
22:58:56 <ManateeLazyCat> pikhq: Well, i use English name for handy to communication with non-
22:58:59 <mtnviewmark> for all we knew gwern was just short for Ginny Wern, as a real name
22:59:01 <ManateeLazyCat> CJK people
22:59:23 <pikhq> ManateeLazyCat: *nods*
22:59:56 <mtnviewmark> I'm compelled to reference http://xkcd.com/327/
23:00:11 <ManateeLazyCat> pikhq: My point, "Not real name does not mean dishonest, especially in this unsafe world."
23:00:25 <mtnviewmark> I agree with you MLC
23:00:34 <Pseudonym> mtnviewmark: "Gwern" is Welsh for "swamp" or "meadow".
23:00:38 <pikhq> ManateeLazyCat: I was just being curious is all.
23:00:39 <amadan> mtnviewmark: that one became a legend. bobby-tables.com
23:00:41 <c_wraith> swamp or meadow?
23:00:47 <Pseudonym> Or grove.
23:00:51 <c_wraith> my ancestors came from interesting terrain :)
23:00:53 <gwern> c_wraith: if you squint right, they're all the same really
23:01:19 <mtnviewmark>  /nick Robert');DROP_TABLE_Students;--
23:01:33 <mtnviewmark> didn't work :-(
23:01:36 * c_wraith raises a direct male-line descent of some long-forgotten dead king of wales
23:01:55 * pikhq mutters about being named after a city.
23:02:06 <pikhq> "Worcester". What sort of person takes that as a last name?
23:02:10 * Pseudonym folds his bastard branch ancestry of minor English nobility
23:02:30 <pikhq> Aside from knights. Freaking knights.
23:02:35 * mtnviewmark notes that we need to get Haskell on that site...
23:02:45 <gwern> nothing wrong with being named after a city
23:02:59 <Pseudonym> pikhq: Could be worse.  My surname is named after a village.
23:03:02 <gwern> it's better than my own surname, which roughly translates as 'naked-born'
23:03:11 <gwern> dunno about you, but I'd rather a city than that
23:03:21 <cap11235> gwern: That is an accurate surname.
23:03:34 <cap11235> I have a first name as my surname.
23:03:35 <ksf> could be worse. I'm not a taylor, by every meaningful definition.
23:03:38 <pikhq> I'm freaking "God-supports Alder-wood-city", if you actually de-etymologise my name.
23:03:40 <mtnviewmark> Mines after a shtetl !
23:03:43 <gwern> I know, it's redundant! everyone is born kicking and screaming naked
23:03:45 <Pseudonym> gwern, I thought "bran" was "crow".
23:03:56 <cap11235> People always think my last name is my first name.
23:03:56 <gwern> Pseudonym: I already said, this is a pseudonym
23:04:03 <pikhq> With 3 or 4 languages involved.
23:04:03 <Pseudonym> Ah, right.
23:04:06 <Pseudonym> Gotcha.
23:04:08 <pikhq> in 2 names.
23:04:11 * gwern is talking about my True Name
23:04:27 <Pseudonym> Your effable, effable, deep and inscrutable name?
23:04:29 <gwern> pikhq: that's an interesting etymology
23:04:34 * cap11235 is talking about the One Name to Rule Them All
23:04:39 <pikhq> gwern: Indeed.
23:04:58 <pikhq> gwern: "Josiah Worcester". Less weird when put that way.
23:05:15 <fhobia> BMeph: thanks, didn't realize it was part of base :3
23:05:24 <gwern> oh, the 'god-supports' is from the Josiah (and hebrew)?
23:05:30 <pikhq> Yes.
23:05:35 <Pseudonym> branwen == smiling crow
23:05:36 <gwern> ok, that makes more sense. I thought the whole thing was in the surname
23:05:39 <Pseudonym> In case you cared.
23:05:42 <pikhq> No.
23:05:46 <gwern> Pseudonym: see, that's a decent surname!
23:05:50 <gwern> and it's short too
23:05:55 <Pseudonym> Or possibly "beautiful crow".
23:06:00 <pikhq> The surname is just an unholy amalgam of Celtic and Latin shoved through English.
23:06:11 <Pseudonym> Gwener is the Welsh mythological equivalent of Venus.
23:06:50 * hackagebot highlighting-kate 0.2.7 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.2.7 (JohnMacFarlane)
23:07:09 <cap11235> So, anyone here familiar with the SDL bindings? My program and XMonad are not playing nicely together.
23:07:10 <etpace> there is welsh mythology?
23:07:44 <Pseudonym> Of course.
23:07:46 <pikhq> Yes.
23:07:51 <etpace> never heard of it
23:07:53 <Pseudonym> Welsh < Celt
23:08:05 <Pseudonym> "<" is the "is-a" relation.
23:08:11 <etpace> oh right
23:08:23 <dons> ManateeLazyCat: so we're not related? :)
23:08:24 <gwern> etpace: look up the Mabinogion
23:08:28 <etpace> it's still not taught at all, never heard of it
23:08:48 <etpace> only thing i guess is the eisteddfod
23:09:08 <pikhq> etpace: Yeah, but you're dealing with *nerds* here.
23:09:17 <ManateeLazyCat> dons: I'm want ask some question about hot-swapping, looks you're so busy that I do not want to bother you.
23:09:23 <etpace> yeah but you know more about my niche country than me :(
23:09:27 <Pseudonym> If you're going to have a national stereotype, close harmony singing is a pretty good one.
23:09:32 <pikhq> People who wish, say, they could feasibly get each script in Unicode in a single document.
23:09:48 <dons> ManateeLazyCat: i saw your question. the full story for hot swapping in haskell is in my phd thesis (on my website)
23:10:06 <Pseudonym> etpace: Wyt i'n gallu siarad Cymraeg?
23:10:07 <dons> ManateeLazyCat: the only library designed for hot swapping is plugins, which as you know isn't building at  the moment.
23:10:24 <dons> ManateeLazyCat: but i hope to get it building again soon.
23:10:30 <ManateeLazyCat> dons: It's hard to fix it? I really want to use it.
23:10:43 <dons> yes, it is a bit hard. it was built before cabal or the new package formats
23:10:43 <ManateeLazyCat> dons: I want integrate it with my project : http://www.flickr.com/photos/48809572@N02/
23:10:53 <etpace> ddym in bach
23:10:56 <etpace> or however you spell it :p
23:11:06 <dons> ManateeLazyCat: the yi and xmonad approach is easier, for now
23:11:12 <etpace> cardiff, so only from school
23:11:14 <ManateeLazyCat> dons: Oh, thank you very much! I'm waiting..
23:11:18 <dons> ManateeLazyCat: but the challenge is the state, as you mentioned, stored by the system outside.
23:11:24 <dons> so streams and sockets and so on
23:11:30 <Pseudonym> ddim yn bach
23:11:37 <ManateeLazyCat> dons: Yes, reboot is big problem, is state.
23:11:56 <ManateeLazyCat> dons: It's hard to keep state between re-launch, speical for "stream state"
23:11:56 <dons> right. so it has to be module hot swapping i think. like in the "Dynamic Applications from the ground up" paper
23:12:08 <dons> where you keep some code running to hold onto the state
23:12:08 <etpace> i'm buying the first person i meet here a drink if they can tell me where wales is on the map, a girl actually thought it was a province of ireland
23:12:11 <etpace> i was not pleased
23:12:40 <dons> ManateeLazyCat: is this an IDE?
23:12:46 <dibblego> wales is where the Japanese do their hunting, just south of Australia
23:12:48 <c_wraith> it's underwater to a large degree now.  but it was eastern britain
23:12:51 <dons> based on Webkit?
23:12:58 <ManateeLazyCat> dons: It's multi-processes Haskell/GTK+ framework
23:13:00 <dons> it looks very cool.
23:13:08 <ManateeLazyCat> dons: Similar with Google Chrome's framework
23:13:10 <pikhq> etpace: Just to the west of England, on Great Britain? Y'know, that bit that kinda juts out down on the south?
23:13:18 <Pseudonym> Dw i'n gobod man mae Gymru yn lleoliad!
23:13:19 <dons> ManateeLazyCat: that is nice!
23:13:21 <ManateeLazyCat> dons: Every tab is running in separate process for crash-free.
23:13:29 <wli> New South Wales is Australia, Wales is in Britain.
23:13:42 <dons> ManateeLazyCat: and you want  to restart each process via hot swapping?
23:13:45 <ManateeLazyCat> dons: You can build any GTK+ in it since it's a framework, it don't care how to implement it.
23:14:19 <Pseudonym> Actually, sorry, got that wrong.  You don't soften "Cymru" there.
23:14:20 <ManateeLazyCat> dons: Currently, i have implement hot-swapping core and don't stop plugin's state, but i no idea how to how-swapping plugin process.
23:14:22 <pikhq> (why the hell do I *remember* UK geography at all anyways? I'm American! I can get away with not even knowing Canada's to the north!)
23:14:35 <ManateeLazyCat> dons: I will lost state after i re-launch plugin process.
23:14:51 * Pseudonym has never been to the UK, but for some reasons knows a bit of Welsh
23:14:56 <dons> ManateeLazyCat: maybe you want to look at the very core of plugins, and try to start from there. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27621#a27621
23:15:10 <ManateeLazyCat> dons: As you know, re-execute some command to restore state is un-acceptable sometimes.
23:15:15 <dons> right
23:16:00 <ManateeLazyCat> dons: You can think it's a normal gtk+ program hide a completely desktop environment in it. since it's multi-processes framework.
23:16:00 <dons> have a look at my phd thesis. it shows how to write a hot swapping system based on dynamic linking. http://donsbot.wordpress.com/papers/  -- you could take the same code above and use that to reload modules
23:16:25 <ManateeLazyCat> dons: Thank, i will look it.
23:16:28 <dons> that might be faster than waiting for me to fix all of plugins.
23:16:36 <dons> just use System.Plugins.Load on its own
23:16:55 <ManateeLazyCat> dons: So all your papers is at http://donsbot.wordpress.com/papers/ ?
23:16:57 <amadan> i added the annotations, but i'm still having problems... can anyone please take one more peek? http://paste.org/pastebin/view/20596
23:17:01 <dons> ManateeLazyCat: yeah
23:17:26 <ManateeLazyCat> dons: Ok, thanks for you help. I know you're very busy, i will explore those problem myself.
23:17:40 <dons> i'll answer your email tomorrow in full.
23:17:46 <dons> but you have the basic idea now.
23:17:46 <ManateeLazyCat> dons: Thanks. :)
23:18:10 <gwern> dons: how's the thesis going?
23:18:30 <dilinger>  tP
23:18:35 * BMeph is confused: Wales it in Britain, but Breton is in France?!? Strange... ;)
23:18:46 <BMeph> *is in
23:18:49 <gwern> BMeph: remember where england's rulers came from
23:19:02 <Pseudonym> gwern: Germany.
23:19:08 <BMeph> gwern: Sweden? ;
23:19:10 <gwern> I mean the ones before that
23:19:14 <Pseudonym> Except for the one from Greece.
23:19:21 <amadan> rome?
23:19:24 <Pseudonym> Netherlands.
23:19:25 <gwern> (england has had a fair number of royal families, hasn't it)
23:19:35 <Pseudonym> Or did you mean before that?
23:19:41 <dons> gwern: done a few weeks ago. under review now
23:19:42 <etpace> yeah pikhq, and east britain c_wraith?
23:19:45 <BMeph> gwern: Fair and foul! ;)
23:20:01 <wli> Glorious Revoluion of 1688 heh
23:20:13 <gwern> BMeph: har har. I don't involve myself in bygone politics so don't try to trap me with your tory or whiggish views of history!
23:20:16 <wli> They're probably trying to point to William of Normandy.
23:20:22 <Pseudonym> Actually, more correct to call it "Dutch Republic".
23:20:24 <cap11235> So is anyone here familiar with SDL?
23:20:33 <gwern> dons: cool. any idea when it'll be public? it's right up ManateeLazyCat's alley, I'd thikn
23:20:36 <c_wraith> east/west.  I have trouble with directions that aren't north/south.  just like I have trouble with left/right, but no trouble with up/down. :)
23:20:46 <dons> gwern: its on my website now. 
23:20:59 <dons> gwern: though that's obv. not the final version, after review.
23:21:13 <gwern> ah, so it is
23:21:21 * gwern assumed you'd blog about it
23:21:28 <dons> well, after it is accepted.
23:21:34 <amadan> c_wraith: me too: trick: visualise (eurocentic) map, then see where Old West was, and where Far East is.
23:21:40 <ManateeLazyCat> dons: The source code of my project is at https://patch-tag.com/r/AndyStewart , all repositories that beginning with manatee-*
23:21:50 <pikhq> wli: The Duke of Normandy is a real title.
23:21:58 <ManateeLazyCat> dons: Hot-swapping core still in my local repository.
23:22:37 <Pseudonym> The Breton people are also Celtic.  Apologies if there are any French people present, but it's something of a sore point.
23:22:38 <BMeph> pikhq: So's the Duke of Orange! ;)
23:23:07 <amadan> i wish someone was Earl of Banana...
23:23:32 <pikhq> BMeph: Active role. Her Majesty, in the Channel Islands, is the Duke of Normandy.
23:23:44 <pikhq> UK monarchy gives me headaches.
23:23:55 <pikhq> Actually, the whole legal structure is headache-inducing.
23:23:59 <Pseudonym> Breton is not an official language in Breizh.
23:24:14 <pikhq> It's a freaking group of nations that's been made a single one by each one passing a law uniting them with the others!
23:24:18 <ManateeLazyCat> dons: For build it, you need source code of https://patch-tag.com/r/AndyStewart/gio-branch/home, otherwise dependent can install by cabal.
23:24:30 <Pseudonym> And, in fact, calling it "Breizh" rather than "Bretagne" is considered by some to be a political statement.
23:24:33 <pikhq> And have the same monarch by coincidence!
23:25:13 * Pseudonym will never understand European politics
23:26:00 <manjunaths> hello
23:26:06 <manjunaths> how do I debug haskell code ?
23:26:21 <amadan> So, can anyone tell me about my "Ambiguous type variable" thing? I stuck a type signature at pretty much everything...
23:26:23 <Pseudonym> Don't.  Prove your code correct.
23:26:38 <Pseudonym> Just kidding.  First, you test.
23:26:47 <manjunaths> *phew*
23:26:53 <lispy> manjunaths: ghci debugger exists
23:27:06 <pikhq> Pseudonym: Most of it's at least got a rational basis.
23:27:13 <manjunaths> ok I have pure function in which a value is reaching NaN and I want to know why
23:27:23 <pikhq> UK, though? No. Its basis is a several-hundred-year-old feudal monarchy.
23:27:35 <lispy> > 0 / 0 :: Double
23:27:36 <lambdabot>   NaN
23:27:40 <pikhq> Sorry, a *set of* such monarchies.
23:28:08 <lispy> > isNaN (0 / 0)
23:28:09 <lambdabot>   True
23:28:22 <Pseudonym> pikhq: I think it's more correct to say that most people agreed to forget the irrationality in European politics.
23:29:34 <lispy> > 0 ** 0
23:29:35 <lambdabot>   1.0
23:29:56 <lispy> > (1 / 0) / (1 / 0)
23:29:57 <lambdabot>   NaN
23:30:04 <pikhq> Pseudonym: No, no, I don't think you understand.
23:30:11 <lispy> manjunaths: maybe those examples help
23:30:17 <pikhq> All the other European nations have *defined political systems*.
23:30:35 <Pseudonym> Where "defined" may mean "imposed by fiat".
23:30:37 <manjunaths> lispy, yes thanks
23:30:58 <manjunaths> weird my internet is not working
23:31:10 <pikhq> De jure, the UK is based around the word of Her Majesty Queen Elizabeth, by the Grace of God Queen being.
23:31:12 <manjunaths> wait a min, how am I chatting on here then
23:31:21 <lispy> manjunaths: Debug.Trace is your friend too
23:31:21 <manjunaths> damnit wrong browser sorry
23:31:25 <pikhq> Erm. Being law.
23:31:27 <manjunaths> Liskni_si, thanks
23:31:35 <manjunaths> lispy, thanks
23:31:47 <pikhq> Except as regulated by certain things previous monarchs have signed restricting their power.
23:32:08 <pikhq> De facto this has resulted in Parliament having actual power.
23:32:12 <lispy> politics to #haskell-blah please :)
23:32:21 <pikhq> But only because the monarchy willed it.
23:35:38 <BMeph> My Queen is Elizabeth III (ivanm, you know what I mean...) 
23:35:54 <ivanm> BMeph: heh
23:36:02 <Pseudonym> God Save Liz 10.
23:36:14 * ivanm gets that one as well
23:36:31 <ivanm> I want to see Erewhon-style "democracy"...
23:40:37 <ivanm> dons: you still around?
23:41:00 <altmattr> what options are there for getting something like parameterised modules?
23:41:17 <ivanm> you mean like what ocaml has?
23:41:31 <altmattr> I only need a lightweight thing
23:41:46 <altmattr> but yes, like that
23:42:10 <ivanm> don't think it's possible in Haskell
23:42:15 <ivanm> not a formalised version, anyway
23:42:24 <lispy> altmattr: would type families (or one of the related extensions) do it?
23:42:39 <ivanm> Bytestring just duplicates the API in the strict and lazy modules
23:42:49 <altmattr> lispy: not sure, never used them
23:42:54 <ivanm> otherwise, use a type class or something
23:43:07 <lispy> Well, IIRC they let you create a function on types
23:43:10 <altmattr> what I need is just some "global" (to the module) state
23:43:23 <altmattr> or flag
23:43:29 <ivanm> altmattr: so, why aren't you here with us hacking at AusHac? ;p
23:43:38 <lispy> such that if one type is requested the type used in the implementation can depend on it
23:43:39 <altmattr> yeah, sorry about that
23:43:53 <altmattr> family stuff appeared, I am still hoping to make some appearance
23:44:13 <ivanm> \o/
23:44:24 * ivanm was actually being facetious...
23:44:32 <lispy> again??
23:44:34 <lispy> ;)
23:44:56 <ivanm> well, "as usual" might be a better classification ;-)
23:46:15 <altmattr> well, I am actually pretty pissed about missing it - I don't get many chances to code haskell with anyone else
23:46:40 <altmattr> even my previous local haskell experts have moved to scala ?!
23:47:14 <ivanm> wtf?
23:49:18 <altmattr> yeah, well, these things happen
23:49:27 <altmattr> I should have been more vigilant I guess
23:49:38 <dibblego> give them my sympathies
23:49:48 <altmattr> every day
23:49:52 <ivanm> yeah, how could you let them do that to themselves?!?!?!?!?
23:50:45 <altmattr> ivanm: how is aushack going?
23:50:52 <ivanm> pretty good
23:51:02 <altmattr> what are the popular projects?
23:51:03 <ivanm> we've got quite a few people working on different projects atm
23:51:03 * hackagebot event-driven 0.0.2 - library for event driven programming  http://hackage.haskell.org/package/event-driven-0.0.2 (YoshikuniJujo)
23:54:02 <ivanm> jaspervdj: in case lambdabot didn't pass my message onto you, the new version of fgl isn't a completely new library
23:54:07 <gnut> hi all
23:54:09 <ivanm> it's just a rewrite from scratch
23:54:17 * ivanm waves idly in gnut's general direction
23:54:51 <jaspervdj> ivanm: Ah, okay
23:55:06 <jaspervdj> No, I didn't get the message :-/
23:55:44 <jaspervdj> ivanm: BTW, if you see kamatsu (Liam O'Connor) at AusHac, say hi for me?
23:57:05 <int80_h> 1;2c1;2c1;2c1;2cq
23:57:06 <int80_h> q
23:59:34 <ivanm> jaspervdj: yeah, he's not here today
