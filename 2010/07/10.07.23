00:00:11 <solrize> aleator, i think profiling messes stuff up because cost centers break up fusion
00:00:14 <lispy> solrize: No, I'm just complaining about that feature.  Who ever is passing -fno-warn.. is right to do so
00:01:02 <napping> is it suppressed by using _ names?
00:01:31 <lispy> I think so
00:02:18 <aleator> Right.. I've got ghc indeed making segfaulting programs when using speculation. Now I'd need to find out if this is ghc bug, speculation bug, or os x bug.
00:05:59 <drbean> If I let mkc f nex = next (f x), then the type of mkc is (a -> b) -> a <b -> r) -> r
00:06:07 <drbean> Wait.
00:06:23 <drbean> If I let mkc f nex = next (f x), then the type of mkc is (a -> b) -> a -> (b -> r) -> r
00:07:08 <drbean> Why is the type of what is returned 'r', rather than 'c'?
00:07:19 <drbean> Why did they choose 'r'?
00:08:22 <opqdonut> (->r) is the usual name for the continuation type
00:08:25 <drbean> let mkc f x next = next (f x)
00:09:17 <drbean> :t mkc returns '(a -> b) -> a -> (b -> r) -> r
00:09:18 <lambdabot>     lexical error in string/character literal at character 'a'
00:10:23 <drbean> > let mkc f x next = next (f x)
00:10:24 <lambdabot>   not an expression: `let mkc f x next = next (f x)'
00:13:35 <drbean> OK. Continuations.
00:14:39 <solrize> data.trie doesn't have insertwith' and leaks memory and is slower than data.map...:(
00:27:42 * hackagebot uu-parsinglib 2.4.2 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.4.2 (DoaitseSwierstra)
00:56:34 <aleator> Hey, this speculation thing actually works, when you use it right. 29s down to 23s.
00:58:35 <c_wraith> aleator: edwardk's library?
01:01:13 <aleator> c_wraith: Yeah. But I get worrying segfaults as well, that I can't seem to really reproduce
01:01:48 * aleator needs more cores
01:07:22 <aleator> or a parallel mwc..
01:11:30 <solrize> edwards blog is called comonad reader.  is that equivalent to monad coreader?
01:13:43 <dolio> What does equivalent mean?
01:16:14 <solrize> dolio, i guess it means the diagram commutes
01:16:49 <dolio> What diagram?
01:16:55 <napping> but how do you define a blogomorphism?
01:17:47 <solrize> i'm wondering if there's a coreader morphism which is like reader with the arrow reversed
01:17:49 <benc___> i have this memory of in ghc if you turn on -prof and -O at the same time, one gets turned off automatically
01:17:53 <benc___> i.e. they're exclusive
01:17:58 <benc___> but i can't find it documented
01:18:01 <solrize> hmm
01:18:02 <benc___> so is it true or is it a dream?
01:18:12 <dolio> The reader comonad is (,) r.
01:18:28 <napping> I think -prof and -O should get alond
01:18:32 <napping> -ddump-simpl should tell you
01:19:04 <solrize> hmm, ghc 6.12.1 configure script fails
01:19:12 <dolio> And you get morphisms w a -> b = (r, a) -> b which is isomorphic to a -> r -> b = a -> m b, for m = (->) r.
01:19:16 <solrize> 6.12.3
01:19:31 <dolio> So they are similar in that sense.
01:24:03 <solrize> hmm ok
01:33:52 <aaaaa> ну че
01:33:56 <aaaaa> хуесосы
01:33:58 <aaaaa> хуесосы
01:33:59 <aaaaa> хуесосы
01:33:59 <aaaaa> хуесосы
01:33:59 <aaaaa> хуесосы
01:33:59 <aaaaa> хуесосы
01:34:00 <aaaaa> хуесосы
01:34:00 <aaaaa> хуесосы
01:34:00 <aaaaa> хуесосы
01:34:00 <aaaaa> хуесосы
01:34:00 <aaaaa> хуесосы
01:34:01 <aaaaa> хуесосы
01:34:01 <aaaaa> хуесосы
01:34:02 <aaaaa> хуесосы
01:34:02 <aaaaa> хуесосы
01:34:03 <aaaaa> хуесосы
01:34:03 <aaaaa> хуесосы
01:34:51 <solrize> stop
01:44:37 <quicksilver> hmm he did that in #jquery too
01:46:58 <c_wraith> if he got k-lined, he was annoying a LOT of people.
01:58:10 <drbean> The type signatures  returned by ghci respect the names for the type variables chosen by the programmer.
01:59:29 <drbean> In the type signature declaration.
02:05:00 <quicksilver> if possible, yes.
02:23:40 <drbean> Need to pay more attention to the order in the sectioning of infix operators. (+3) is the same as (3+), but (2^) isn't the same as (^2).
02:30:25 <amit> hi
02:30:40 <amit> what can i do with this haskell
02:32:02 <Ke> @faq can haskell answer that question
02:32:02 <lambdabot> The answer is: Yes! Haskell can do that.
02:46:13 <solrize> ghc 6,12,3 seems to have a slight performance regression with that example compared with 6.10.4
02:47:36 <ivanm> which example?
02:48:33 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27997#a27997  
02:50:32 <ivanm> ugh, what code isn't exactly easy to read
02:50:51 <ivanm> and the function passed to filter could be improved: (`notMember` stopWords)
02:50:53 <ivanm> etc.
02:51:13 <solrize> hmm ok
02:51:49 <ivanm> as for performance degredations... I wonder if its due to a bytestring regression or ghc itself
02:52:48 <solrize> the SCC's don't help the readability but i put those there for profiling, trying to figure out why it's so slow
02:53:02 <jbhatta> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28002#a28002
02:53:06 <ivanm> yeah, I guessed that bit ;-)
02:53:07 <jbhatta> whyyyyyyyyy???
02:53:18 <jbhatta> (sqrt.fromIntegral) issues
02:53:20 <ivanm> jbhatta: you're doing a/b on Ints probably
02:53:32 <jbhatta> no division that i can see
02:53:34 <solrize> jbhatta,  looks like monomorphism restriction?
02:53:36 <ivanm> oh, right
02:53:39 <ivanm> solrize: agreed
02:54:06 <jbhatta> hmmmm
02:54:08 <jbhatta> i don't know what that is
02:54:22 <jbhatta> a morphism is monic if it's...
02:54:35 * jbhatta dies of jargon
02:55:08 <solrize> it means if you use fromIntegral  (or some other function)   in two places with no type annotations, the compiler assumes they are both the same type
02:55:16 <solrize> you can either add type annotations
02:55:33 <ivanm> damn defaulting rules...
02:55:34 <solrize> or put {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file
02:55:45 <jbhatta> ok, let me try
02:55:48 <napping> the monomorphism is only on functions defined at the top level
02:55:50 <napping> with no arguments
02:55:52 <ivanm> solrize: though I've done similar stuff to that before without the MMR arising :s
02:55:58 <solrize> hmm
02:56:02 <ivanm> jbhatta: actually code would help
02:56:14 <napping> like, if you write myfun = map blah . filter pred
02:56:15 <jbhatta> it's teeny, so i'll just paste
02:56:16 <ivanm> napping: yeah, so it's a bit strange...
02:56:46 <napping> jbhatta: but, a morphism being monic is a different thing altogether
02:56:55 <napping> that's math that we don't have to worry about
02:57:45 <jbhatta> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28002#a28003
02:57:53 <jbhatta> napping: i'm relieved
02:58:14 <ivanm> aha!
02:58:15 <solrize> take s ???
02:58:19 <solrize> take wants an int
02:58:19 <ivanm> jbhatta: you're using s as an Int
02:58:25 <ivanm> but it's a Floating from the sqrt
02:58:28 <napping> monomorphic is not being polymorphic
02:58:28 <jbhatta> ohhhhhhhhh
02:58:39 <ivanm> you need to do a round, trunc, ceil or floor on it
02:58:48 <jbhatta> wow
02:58:52 <jbhatta> duh
02:58:53 <ivanm> jbhatta: you are aware of the various sudoku solutions on the wiki, aren't you?
02:59:18 <jbhatta> oh, yeah.  i'm just messing around.  trying to get a handle on haskell with some easy stuff
03:01:14 <jbhatta> so, obviously i'm new to this, so here's a really basic question:
03:01:30 <jbhatta> what is the "haskell way" to do assertions on a function's input?
03:01:39 <jbhatta> typed input and a maybe monad?
03:01:56 <jbhatta> i want to make sure i'm passing "squarify" a list with square length
03:02:38 <ivanm> jbhatta: no real way of doing that
03:02:53 <ivanm> (at least not easily/elegantly, but there is a cool paper about square matrices, etc.)
03:03:34 <ivanm> jbhatta: so your options are to assume its valid, or to check the length and bitch (e.g. error or Nothing) if it isn't square
03:03:40 <ivanm> alternatively, stop using lists
03:03:57 <jbhatta> ivanm: the alternative would be what?
03:04:18 <jbhatta> fixed-length tuples or something?
03:04:27 <ivanm> arrays, Maps, etc.
03:04:36 <jbhatta> oooooooo what's a Map?
03:04:39 <jbhatta> googling
03:04:42 <ClaudiusMaximus> even some functions in the standard library have preconditions that aren't checked (Data.Map.fromAscList is one, iirc) and sometimes undefined behaviour (that isn't immediate program abort) results
03:05:13 <jbhatta> ClaudiusMaximus: at least that makes me feel less bad
03:05:42 <ivanm> jbhatta: Data.Map
03:05:54 <ivanm> one alternative name would be a Dictionary
03:06:11 <ivanm> so you can have a mapping from an (Int,Int) co-ordinate to the value at that co-ordinate
03:06:19 <ivanm> if there's no value, then you can assume it isn't set, etc.
03:06:23 <ivanm> however you want to do it
03:07:31 <jbhatta> ivanm: ah, i see
03:07:40 <jbhatta> is that the canonical way to do 2-d data structures?
03:07:52 <ivanm> that or arrays/vectors/etc
03:07:52 <jbhatta> rather than nested lists?
03:07:57 <ivanm> depends if you want sparse or not
03:08:11 <ivanm> jbhatta: yes; nested lists have no size guarantees and are expensive to update
03:08:30 <ivanm> lists are good if you do an all-in-one pass over everything
03:08:43 <arcatan> and nested lists are arduous to use
03:09:11 <jbhatta> i have to admit, they're pretty annoying.  i was getting used to them from lisp, but ultimately they do kinda suck
03:09:48 <zachk1> is there a way to memoize data map ? 
03:10:14 <zachk> like i know scanl will memoize a list for me 
03:11:03 <solrize> memoize?
03:11:11 <jbhatta> thanks guys.  off to bed for moi.  night
03:11:23 <ClaudiusMaximus> been working on my fractal thing, added a new gallery with today's "neon" experiments at http://claudiusmaximus.goto10.org/g/mandulia/ , expect mandulia-0.5 on hackage some time in the next few days..
03:11:25 <ivanm> zachk: why do you want to?
03:11:32 <quicksilver> scanl doesn't memoize a list
03:11:33 <quicksilver> a list is a list.
03:11:44 <ivanm> especially since memoisation is often implemented using Data.Map...
03:11:48 <quicksilver> scanl is a way of building a list whose later members depend on the earler ones
03:11:50 <dschoepe> zachk: You could write an instance of HasTrie for Data.Map and use memotrie: http://hackage.haskell.org/packages/archive/MemoTrie/latest/doc/html/Data-MemoTrie.html
03:11:57 <quicksilver> which may, indeed, be a way to memoize a function.
03:13:59 <somnium> how do you extract column and line data within a parser in Parsec?
03:14:05 <ClaudiusMaximus> i have a leak somewhere though :( after 30mins it overflows the 1GB heap :(
03:14:34 <ivanm> somnium: I believe you don't/can't
03:14:45 <ivanm> one approach is to use happy and then use parsec to parse the results
03:14:53 <ivanm> (instead of alex)
03:15:00 <ivanm> ClaudiusMaximus: :(
03:15:37 <ClaudiusMaximus> ivanm: i never noticed it until today, normally i've only been running it for 10mins at a time...
03:17:02 <ClaudiusMaximus> and i have no clue about how to track down such a leak, seeing as it's so small..
03:17:55 <ivanm> profile it?
03:18:08 <quicksilver> ivanm, somnium: you call 'getPosition' to get column and line data from within a parser in parsec.
03:18:18 <ivanm> randomly start putting strictness annotations everywhere?
03:18:23 <ivanm> quicksilver: oh, didn't know that
03:19:31 <quicksilver> evidently not :P
03:20:09 <ClaudiusMaximus> ivanm: i already profiled heavily and added random strictness annotations - but my focus was speed; i guess i should try memory profiling now - but if it takes 30mins to consume 1GB, i better get my profiling options correct or it'll take until next week..
03:20:55 <ClaudiusMaximus> s/consume/exhaust/
03:21:17 <quicksilver> ClaudiusMaximus: heap profiling is continous
03:21:23 <quicksilver> you don't need to wait for the application to terminate.
03:21:34 <quicksilver> and you can normally get useful data over only a few minutes
03:23:10 <ClaudiusMaximus> quicksilver: mm, i'll investigate then - which is the best combination of flags for that stuff?  is there a flag i can pass to cabal-install to build executables for profiling too?
03:24:38 <ClaudiusMaximus> ah, cabal install --enable-executable-profiling
03:25:17 <gwern> ClaudiusMaximus: maybe you ought to edit .cabal/config to turn on lib and app profiling by default
03:26:01 <ivanm> gwern: I beg to differ
03:26:05 <somnium> quicksilver: great, thanks! works 
03:26:12 <ivanm> for apps, it slows down all apps built with cabal-install
03:26:13 <gwern> ivanm: you may
03:26:19 <ivanm> why thank you kind sir
03:26:30 * gwern is nothing if not magnamimous
03:26:54 <ivanm> but build profiling libraries by default, yes; if you intend to actually use programs built with cabal-install you shouldn't enable executable profiling by default IMHO
03:27:07 <ToRA> ClaudiusMaximus: while waiting for it to all rebuild, you can just run it (normal build) with +RTS -hT -RTS to get some profiling information out for free
03:27:13 <quicksilver> ClaudiusMaximus: -hT is the secret one you can use even without compiled for profiling.
03:27:18 <gwern> ivanm: it may slow down, but if you do very much profiling, you'll save time later by not running into a load of compile errors
03:27:19 <ksf> are there trees optimised for multi-lookup? ideally splayed ones...
03:27:36 <ksf> with multi-lookup I mean looking up multiple values and getting multiple results
03:27:57 <ClaudiusMaximus> i already build profiling libs by default (first thing i do after bootstrapping cabal-install)
03:28:02 <ivanm> gwern: if I want to profile an executable, I'd prefer to have to do so explicitly rather than having all executables built with profiling by default
03:28:29 <urgonia> hallokes
03:28:45 * ivanm waves idly in urgonia's general direction
03:28:57 <ClaudiusMaximus> secret rts codes?!?
03:29:03 <ksf> hmmm fromList . intersectionWith const id . toList?
03:29:17 <gwern> ClaudiusMaximus: so much for 'all bugs are shallow'!
03:29:22 <ToRA> to be fair it's not /that/ secret: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html#rts-profiling
03:29:33 <ToRA> it's just not mentioned in the big chapter called Profiling
03:29:41 <ClaudiusMaximus> :)
03:30:11 <gwern> ToRA: that'd be awful useful for GHC API users, except their problem usually isn't heap usage...
03:30:37 <ToRA> gwern: tell me about it ;)
03:31:04 <ksf> O( n + m ) looks slower than O( n log m )
03:31:08 <ToRA> (although my use for it was to diagnose a space leak)
03:31:38 <ksf> where n can be anything from 1 to m
03:31:52 <ivanm> ToRA: did you respond to my fgl naming survey with a lot of capital letters?
03:32:03 <ToRA> ivanm: maybe
03:32:11 <ToRA> ivanm: I hope you don't mind
03:32:13 <ivanm> well, I have a response there signed only with "tora"
03:32:16 <ivanm> ToRA: not at all
03:32:18 <ivanm> ;-)
03:32:34 <ivanm> but I agree with you; it's just that people like dons bitched when we said we were going to change the API
03:32:40 <ivanm> and they made a big hue and cry over it
03:33:38 <gwern> oh that crazy dons
03:33:39 <ksf> it's virtually impossible to change the fgl api and make it worse
03:33:53 <ksf> and I'm still voting for boxes-n-arrows
03:35:24 <ivanm> ksf: why boxes-n-arrows? that has absolutely nothing to do with graphs....
03:35:37 <ivanm> it sounds more like statistics, what with the box-and-whisker plot
03:35:56 <byorgey> one might argue that "fgl" also has little to do with graphs, unless you know what it stands for =)
03:36:06 <ivanm> byorgey: true, but it's already there
03:36:23 <byorgey> I know, I'm mostly joking
03:36:34 <ivanm> I agree that fgl is a horrible name
03:36:39 <ksf> hmmm yes you're right. I actually draw my graphs with circles, not boxes.
03:36:46 <ivanm> ksf: exactly!
03:36:49 <byorgey> it even looks and sounds ugly
03:36:54 <byorgey> fgl fgl fgl fgl fgl
03:36:56 <ksf> so let's make that circles-n-arrows
03:37:13 <ketil> fugly?
03:37:18 <byorgey> exactly
03:37:22 <ksf> fudge.
03:37:26 <ivanm> byorgey: and apart from making it sound like datatypes in other languages, I don't get why dons et. al. renamed packedstrings to bytestrings
03:37:33 <ksf> there's a g in that, make a recronym.
03:37:46 <ivanm> ksf: except that it has nothing to do with the inductive nature of fgl
03:37:57 <ivanm> and since I'm going to at some point write a new library that fgl depends on...
03:38:08 <ketil> ivanm, perhaps because packedstrings came with different sizes, but bytestrings are limited to octets?
03:38:25 <ivanm> oh
03:39:16 <ketil> just guessing :-)  But I think there were packedstrings supporting 16-bit, uh, packs.
03:39:43 <andersonorui> [42,13,22]
03:40:21 <byorgey> I'm guessing they meant to type that at the tryhaskell prompt instead of the irc prompt ;)
03:40:39 <ivanm> heh
03:40:48 <ivanm> byorgey: btw, I had reason to try out "cabal init" the other day; is there an option to make the output less noisy?
03:40:58 <byorgey> ivanm: yes, several
03:41:07 <byorgey> ivanm: did you try cabal init --help ?
03:41:08 <ivanm> oh good, I must have  missed it then
03:41:56 <byorgey> I forget what the options are called but they should be listed in the help
03:42:35 <ivanm> cabal init --no-comments ?
03:43:08 <ivanm> also, you should probably emphasise that non-empty descriptions are frowned upon
03:43:44 <ksf> ivanm, fig? 
03:43:45 <byorgey> there's --no-comments and also --minimal or something like that
03:44:12 <ivanm> ksf: hmmm?
03:44:15 <byorgey> ivanm: yeah, probably should
03:44:37 <ksf> http://en.wikipedia.org/wiki/Common_fig
03:44:48 <ksf> also, "functional inductive graphs"
03:44:54 <ivanm> *groan*
03:45:06 <ivanm> ksf: what's wrong with inductive-graphs if I have to change the name?
03:45:31 <ksf> well linux isn't called runs-programs, is it?
03:45:37 <ivanm> heh
03:45:55 * hackagebot histogram-fill 0.2.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.2.0 (AlexeyKhudyakov)
03:46:05 <ivanm> ksf: I'm going to have an underlying graph-classes library that specifies all non-inductive stuff
03:46:15 <ivanm> fgl/whatever will just add the notion of inductiveness onto it
03:46:39 <ksf> that'd be fudge, then, functinal uniductive graph klugde.
03:47:11 <ivanm> ksf: we already have a library called fudge IIRC
03:47:13 <ksf> I think that's called an approxonym.
03:47:32 <ClaudiusMaximus> here's some heap profiling output, guess i'll have to wait longer to see what happens when the heap gets closer to its limit... http://claudiusmaximus.goto10.org/g/tech/mandulia-profile-1000s.png
03:47:37 <ksf> nope.
03:47:41 <ksf> we have fudgets.
03:47:46 <ivanm> ahhh
03:48:38 <ksf> fig fudge doesn't sound too bad, either.
03:49:29 <ClaudiusMaximus> why not call it FGL and confuse everyone with case-agnostic filesystems
03:50:01 <ivanm> ClaudiusMaximus: lol
03:51:58 <ClaudiusMaximus> "fingr" perhaps?
03:52:26 <ivanm> *groan*
03:52:39 <ivanm> we're either going to keep the name "fgl" or go with "inductive-graphs"
03:52:41 <ksf> hmmm aren't there any sweets starting with "e"?
03:53:14 <ivanm> eclaires?
03:53:30 <ClaudiusMaximus> m'n'ms
03:53:45 <ksf> functional uninductive graph eclaires.
03:54:05 <ksf> now we need a recronym for eclaires.
03:54:19 <ivanm> @slap ksf 
03:54:19 * lambdabot clobbers ksf  with an untyped language
03:54:54 <juhp_> fungl(:
03:55:04 <juhp_> oops
03:55:22 <juhp_> I like inductive-graphs
03:55:53 <juhp_> I always have to think before remembering what fgl is
03:56:10 <ksf> the problem with "inductive-graphs" is that it's too fuzzy. do you mean "you could do that with inductive graphs" or "you could do that with inductive-graphs"?
03:56:20 <ksf> and fgl is too unpronounceable.
03:56:24 <ivanm> I agree, as a name fgl sucks
03:56:38 <ivanm> ksf: well, it's going to be the library that _defines_ inductive graphs
03:56:43 <ksf> also, "gl" stands for graphics library iirc.
03:56:57 <juhp_> right
03:56:57 <benc___> that was my first impression
03:56:58 <ivanm> and I haven't heard a better _serious_ alternate name
03:57:02 <benc___> that it was opengl-like
03:57:04 <ksf> will it be the only one ever, in all languages?
03:57:09 <ksf> why not fig?
03:57:10 <ivanm> only because you guys have been brainwashed!!!
03:57:18 <ksf> it's pronounceable and has the exact right letters.
03:57:22 <ivanm> ksf: because it has the same acronym problems that people bitch about fgl
03:57:45 <ketil> ksf: the irony!  Fig is a precursor to OpenGL  (whell, I guess it was actually Phigs or somthing)
03:57:46 <ksf> it's a recronym, no acronym.
03:58:15 <ksf> figs are tasty. that should be the main message of our marketing endeavour.
03:58:50 <ketil> We're trying to make FGL a necronym.
04:02:49 <dibblego> from Monday I am employed to write Haskell, yay!
04:02:55 <ClaudiusMaximus> another heap profile output: http://claudiusmaximus.goto10.org/g/tech/mandulia-profile-2000s.png
04:03:37 <ClaudiusMaximus> bit confusing, i'm not sure what the shape implies
04:03:45 <ivanm> dibblego: yahoo!!!
04:03:47 <ivanm> whom for?
04:03:58 <ivanm> or have you convinced your java overlords to let you use a better language?
04:03:59 <dibblego> a company in West End
04:04:02 <dibblego> yes
04:04:02 <ivanm> cool
04:04:06 <ivanm> ahhh
04:04:10 <dibblego> I run a weekly haskell course at work
04:04:17 <ivanm> nice!
04:04:26 <dibblego> today we wrote: sequenceParser :: [Parser a] -> Parser [a]
04:04:31 <ivanm> dibblego: duplicating what you did at workingmouse? :p
04:04:38 <dibblego> somewhat
04:09:05 <ivanm> preflex: seen m3ga
04:09:05 <preflex>  m3ga was last seen on #haskell 7 hours, 57 minutes and 46 seconds ago, saying: i managed to unlearn python by not using it for a couple of years. it was great.
04:11:46 <ivanm> any haskell maintainers for debian around atm?
04:13:05 <ClaudiusMaximus> mm, i think i now realize why my program exhausts heap after a (long) while - but i don't know how to fix it
04:13:32 <ivanm> why?
04:14:44 <ClaudiusMaximus> will take some time to explain fully, but i have a lazy infinite tree, and it gets explored by the program...
04:14:57 <ClaudiusMaximus> ...so naturally all visited parts stay in memory
04:15:05 <ivanm> ugh, and you keep parts of the tree hanging around?
04:15:18 <ClaudiusMaximus> seems so
04:15:55 <ClaudiusMaximus> i'm not sure exactly why, because i have a multi-level structure with only the "visible" parts kept in each level
04:16:32 <ClaudiusMaximus> i guess the inner levels share the outer levels' tree, so when the inner level grows the outer levels grow too
04:19:13 <pozic> Is there a trivial Haskell program somewhere that simply prints hello world in a million threads or so?
04:19:53 <ivanm> not that I know of
04:20:05 <ivanm> you could probably do it with parMap or something easily enough
04:20:07 <ClaudiusMaximus> :t let main = replicateM 1000000 (forkIO $ putStrLn "hello world!") in main
04:20:08 <lambdabot>     Ambiguous occurrence `replicateM'
04:20:08 <ivanm> or is that pure?
04:20:08 <lambdabot>     It could refer to either `L.replicateM', defined at <local>:2:0
04:20:08 <lambdabot>                           or `Control.Monad.Logic.replicateM', imported from Control.Monad.Logic
04:20:12 <ivanm> if not, a lot of forkIOs
04:20:15 <ivanm> @hoogle parMap
04:20:15 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
04:20:24 <ivanm> @instances Strategy
04:20:24 <lambdabot> Couldn't find class `Strategy'. Try @instances-importing
04:20:35 <ivanm> @instances-importing Control.Parallel.Strategies Strategy
04:20:36 <lambdabot> Couldn't find class `Strategy'. Try @instances-importing
04:20:38 <ivanm> bah
04:20:50 <ivanm> @hoogle replicateM
04:20:50 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
04:20:50 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
04:20:58 <ivanm> ClaudiusMaximus: replicateM_ is probably better
04:21:02 <ClaudiusMaximus> ivanm: true
04:21:22 <ivanm> @type replicateM_ 1000000 (forkIO $ putStrLn "Hello World")
04:21:23 <lambdabot> Not in scope: `forkIO'
04:21:26 <ivanm> bah
04:21:32 <ivanm> @hoogle forkIO
04:21:32 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
04:21:42 <ivanm> actually, you'd need to do a >> return () as well
04:21:48 <ivanm> no, I lie
04:23:19 <ClaudiusMaximus> i use replicateM ... (forkIO $ ... ) in my current project, as it happens (I keep the ThreadId's so i can kill them later)
04:23:41 <ivanm> ClaudiusMaximus: yeah, but in this case is there any point? :p
04:23:46 <pozic> That seems to be terribly slow. I compiled with -threaded and run with N4
04:24:37 <ClaudiusMaximus> 10MB of output takes a while i guess, how long does it take without the forkIO in there?
04:24:48 <pozic> I implemented the same thing in OpenMP (user0m0.064s) and GHC(user0m34.302s). 
04:25:05 <pozic> That's about 200 times slower in GHC. 
04:25:32 <pozic> 535.9375 to be exact
04:25:57 <ClaudiusMaximus> probably OpenMP doesn't create 1M threads, but instead creates 4 threads that run 250k jobs in sequence
04:26:24 <mxc> isn't that kidn of what forkIO with +RTS -n4 does?
04:26:42 <pozic> mxc: AFAIK, yes. 
04:27:04 <pozic> forkIO creates Haskell threads that run on N OS threads.
04:27:12 <mxc> exactly
04:27:24 <pozic> If I use N1 it is about 9 times faster.
04:27:42 <mxc> than N4?
04:27:44 <mxc> thats odd
04:27:44 <pozic> But still 50 times slower than OpenMP.
04:27:47 <pozic> mxc: yes
04:28:05 <mxc> i wonder if you're getting a lot of GC calls for some reason
04:28:06 <pozic> mxc: well, N4 was a bit silly, since I only have an IntelCore2Duo
04:28:11 <mxc> oh
04:28:11 <mxc> yeah
04:28:22 <pozic> mxc: but with N2 it was although better, still slow.
04:28:34 <pozic> I understand the RTS has to start, etc. 
04:28:44 <ClaudiusMaximus> 1M threads running 1 job each on 4 OS threads is completely different from 4 threads running 250k jobs each on 4 OS threads
04:28:46 <mxc> there's some option for the RTS to beep on every GC
04:28:47 <pozic> But even then it is terrible. 
04:28:49 <mxc> its actually quite helpful
04:29:36 <ozamosi|netbook> Haskell is the only language I've ever seen, where I sometimes actually wish there was more boilerplate involved :(
04:30:12 <pozic> mxc: that is a good way to get an epileptic attack. 
04:30:21 <pozic> mxc: I have a visual beep.
04:30:25 <mxc> :)
04:30:44 <ClaudiusMaximus> ozamosi|netbook: write documentation when you would be writing the boilerplate that lets your mind take a break from exploding
04:31:08 <ozamosi|netbook> ClaudiusMaximus: oh, that's clever! :)
04:31:14 <pozic> IMHO, the GC should not ever run in this case. 
04:32:02 <pozic> Is there another implementation of forkIO that does whole program optimization?
04:32:12 <pozic> s/of/with
04:32:39 <gwern> pozic: you might try googling the 'last core slowdown'
04:32:39 <ClaudiusMaximus> pozic: how about: main = replicateM_ 4 (forkIO $ replicateM_ 250000 (putStrLn "Hellooooo world!"))
04:32:56 <gwern> pozic: that might explain you N1-is-best result on 2 cores
04:33:14 <Saizan> gwern: N2 was best there
04:33:39 <gwern> Saizan: thought he said N2 was better than N4 but 'still slow'
04:33:43 <pozic> Ok, I might have been comparing apples to oranges.
04:34:02 <pozic> What exactly is in the real line of time?
04:34:12 <pozic> libc time too? 
04:34:35 <pozic> Uhm, never mind. 
04:35:03 <pozic> The real time was 2.274, user 0m0.064s and then some little sys time. 
04:35:20 <pozic> Those measurements only don't really make sense to me.
04:35:24 <dafis> pozic: run again
04:35:25 <mxc> a little off topic - is anyone here familiar with the iteratee library?
04:35:49 <tibbe> mxc: a bit
04:35:50 <pozic> dafis: a similar result
04:36:50 <dafis> pozic: hmmm
04:37:05 <dafis> pozic: busy machine?
04:37:30 <pozic> dafis: no
04:38:12 <dafis> strange, usually, user+system should more or less add up to real
04:38:15 <pozic> dafis: less than 5% is used by things like Firefox, terminals, etc. 
04:38:18 <pozic> dafis: right
04:38:27 <mxc> tibbe: so basically there are two things I want to do
04:38:35 <Saizan> pozic: this is with -N2 too?
04:38:40 <Silvah> @hoogle forkIO
04:38:40 <mxc> first is just get an enumerator to run an iteratee on each line of a text file
04:38:40 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
04:38:45 <pozic> Saizan: this is referring to the OpenMP output.
04:38:57 <Saizan> ah
04:39:11 <pozic> Saizan: the Haskell time output makes sense.
04:39:37 <mxc> but when I do this:    fileDriver (enumLines  (IterateeG step)) "/tmp/test.txt" -- enumLines runs the iteratee once on a list of strings (essentially lines . getContents) instead of running the iteratee on each line
04:39:59 <mxc> step just outputs each chunk to stdout
04:40:47 <dafis> pozic: redirect the output to a file, if you print it to the terminal, that takes time too
04:41:04 <pozic> dafis: ah, of course. 
04:41:08 <tibbe> mxc: Unfortunately I can't be of much help. I have a good theoretical knowledge of iteratees (I worked on the together with Oleg and the library creator). I don't remember the library weill enough
04:41:25 <mxc> the second goal is to be able to enumerate over a list of files and have the enumerator pass one line at a time to the iteratee based on some ordering
04:41:32 <mxc> oh well, thanks anyway
04:41:46 <mxc> does oleg ever come into #haskell?
04:41:57 <pozic> dafis: yes, that solves it. 
04:42:35 <m3ga> ivanm: i'm here
04:42:39 <dafis> pozic: so OpenMP takes ~0.1s for that?
04:43:35 <pozic> dafis: 0.620 real, 0.044 user, 0.328 sys
04:43:35 <Saizan> what's the haskell code?
04:43:54 <pozic> import Control.Monad
04:43:54 <pozic> import GHC.Conc
04:43:55 <pozic> main = replicateM 25000 (forkIO $ putStrLn "hello world!")
04:44:25 <pozic> On my machine that takes about 3.6 seconds with N2 which is optimal. 
04:44:40 <dafis> pozic: replicateM_
04:44:54 <dafis> should be somewhat faster
04:45:26 <Saizan> should be plenty faster
04:46:06 <pozic> I compile with -threaded and it seems to be slower.
04:46:20 <pozic> It now takes 5 seconds something.
04:46:34 <pozic> (yes, I know that doesn't make sense.)
04:46:40 <pozic> real	0m5.357s
04:46:41 <pozic> user	0m5.480s
04:46:41 <pozic> sys	0m0.172s
04:49:07 <Saizan> with -N2 replicateM_ is on par with replicateM here
04:49:35 <Saizan> hugely slower than without -threaded though..
04:50:12 <gwern> mxc: I've never seen oleg in here
04:50:20 <mxc> ty
04:50:49 <Saizan> it gets 2x better with -fno-state-hack
04:51:05 <Saizan> there's something very fishy going on :)
04:51:56 <ClaudiusMaximus> another heap profile: http://claudiusmaximus.goto10.org/g/tech/mandulia-profile-4600s.png  (how do i prune a lazy infinite Data.Tree.Tree ?)
04:52:58 <ClaudiusMaximus> or should i accept that indefinite running time is not an option, and save the last visited position regularly, and restart the process at that position?
04:53:50 <Saizan> well, do you let go of the root of the tree when you go deep into it?
04:53:56 <ClaudiusMaximus> never
04:54:46 <Saizan> heh, then you can't expect the memory use to not grow as you go deeper :)
04:55:55 <ClaudiusMaximus> sure, i only go a certain maximum depth, and return to the top - but the sharing means it keeps all the bits where i've gone deeper before
04:56:53 <ClaudiusMaximus> even if i'm currently in another branch and don't care about that branch any more
04:57:40 <ClaudiusMaximus> i'd rather discard everything below when i go up, but to implement that feels hairy
04:58:37 <ClaudiusMaximus> and if it involves IORef at each node, then i might as well switch to using C and avoid the annoying little pauses at GC time
04:58:39 <Saizan> well, if the top appears to be a function then it won't get shared
04:59:08 <ClaudiusMaximus> hmm, but then it'll be recomputed each time, which might be insane
04:59:54 <Saizan> well, you'll control within which context it gets shared
05:00:22 <Saizan> e.g. top :: () -> Tree; .... singleRun (top ()) ..
05:00:29 <Saizan> within singleRun it'll be shared
05:01:13 <dibblego> who might I bother about getting leksah running on linux?
05:01:38 <Saizan> though GHC optimizations might defeat the purpouse of the extra argument to top, you need some care there (maybe just a NOINLINE pragma?)
05:02:01 <hpc> dibblego: i was under the impression it was a simple cabal install
05:02:16 <dibblego> hpc, when I try that I get missing dependencies
05:02:21 <dibblego> hpc, I shall try again
05:02:33 * hackagebot syntactical 0.1 - Distfix expression parsing library  http://hackage.haskell.org/package/syntactical-0.1 (VoMinhThu)
05:02:54 <ClaudiusMaximus> Saizan: btw, this project under discussion is on hackage if you want to see what it does: cabal install mandulia   (add -f-SSE4 if your cpu doesn't support SSE4, i'm going to upload a new version this weekend with minor aesthetic tweaks and this tree pruning thing if i figure it out)
05:02:58 <hpc> the best i can say is to use google, or install the dependencies yourself
05:03:01 <proppy> Hi, is there a better way to write http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28005#a28005 ?
05:03:16 <proppy> I'm learning my way to haskell, so feel free to educate me :)
05:03:28 <ClaudiusMaximus> Saizan: thanks for the ideas, i have to go out now
05:03:36 * ClaudiusMaximus bbl
05:05:07 <dcoutts> proppy: your recursion pattern is kind of screwy
05:05:26 <dcoutts> proppy: you want to do very little in the base case, which should be [], not [_]
05:05:29 <proppy> I was wondering if there is an way to adapt binary function to an unary that take a tuple as argument
05:05:40 <dcoutts> proppy: and do the interesting thing in the (x:xs) case
05:05:41 <Twey> proppy: uncurry
05:05:45 <Twey> :t uncurry
05:05:46 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:05:50 <dcoutts> proppy: for testRegexp1 I mean
05:05:51 <proppy> like adapt f (a,b) = f a b
05:06:22 <dibblego> proppy, f = uncurry
05:06:44 <Twey> dibblego: adapt = uncurry
05:07:09 <dibblego> sorry right
05:07:17 <proppy> does it work with an operator like =~ ?
05:07:44 <proppy> dcoutts: ok, I will try to rewrite it, like you advised w8
05:07:47 <dibblego> sure, uncurry (=~)
05:08:14 <Saizan> you could also try regex-compat for a sane regex API
05:09:33 <pozic> Saizan: with -fno-state-hack it goes slower here ;)
05:09:33 <proppy> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28005#a28006 better ?
05:09:55 <proppy> for testRegExp1 I mean
05:10:15 <pozic> Saizan: I think the easiest thing to say is that the implementation is simply broken/slow. 
05:10:27 <pozic> Saizan: e.g. what is the stack size of the Haskell threads?
05:10:29 <dcoutts> proppy: right
05:10:50 <dcoutts> pozic: it's variable
05:10:53 <proppy> *Main> uncurry (==) ("a", "b")
05:10:54 <pozic> Saizan: if many are actually being created, that probably causes the problem. The OpenMP stack size I use 16K.
05:10:55 <proppy> False
05:10:57 <proppy> nice !
05:11:09 <pozic> dcoutts: where does it start?
05:11:22 <dcoutts> pozic: 0 :-)
05:11:31 <pozic> dcoutts: ok, so, then that's probably not it.
05:11:49 <dcoutts> pozic: you can make 100,000 threads
05:12:00 <proppy> saiam: regexp-compat homesite seems down
05:12:03 <proppy> http://regex-tdfa.sourceforge.net/
05:12:13 <pozic> dcoutts: you probably have not been following it, but a straightforward OpenMP program to print hello world in 25000 threads is about 6 times faster than GHC.
05:12:23 <dcoutts> pozic: but if each one is evaluating a function that uses lots of stack space then of course you'll have problems.
05:12:29 <pozic> dcoutts: when you also count output it goes to about 500 times.
05:12:45 <pozic> dcoutts: the OpenMP program also reports a thread number per thread.
05:13:00 <dcoutts> pozic: on a single CPU or multiple?
05:13:09 <pozic> dcoutts: IntelCore2Duo
05:13:14 <pozic> dcoutts: N2
05:13:29 <proppy> Twey: dibblego: so testRegexp2 xs = map (uncurry (=~)) xs should works ?
05:13:29 <pozic> dcoutts: compiled with -threaded
05:13:58 <dcoutts> pozic: well that's an interesting benchmark, we should make sure it's saved somewhere so people can analyse it
05:16:06 <proppy> Twey: dibblego : it work is I declare adapt = uncurry =~ and map adapt xs
05:16:10 <proppy> but doesn't if I inline it
05:16:41 <Saizan> proppy: does adapt have a type signature?
05:16:52 <proppy> no
05:16:59 <proppy> I'm trying to figure it out
05:17:05 <proppy> (the type signature
05:17:24 <Saizan> you can also ask ghci, :t adapt
05:18:15 <proppy> ([Char], [Char]) -> Bool
05:19:43 <pozic> dcoutts: http://paste.debian.net/81223/ will be deleted after 72 hours. 
05:20:06 <pozic> dcoutts: all the information required to add it to some benchmark is there. 
05:20:32 <dibblego> cabal install glib # results in a compile error
05:21:06 <proppy> here is what I came up with testRegexp2 xs = map adapt xs where adapt = uncurry (=~)
05:21:07 <pozic> dibblego: contact the maintainer?
05:21:12 <proppy> is there a "better" way to write it ?
05:22:15 <dafis> proppy: map (uncurry (=~))
05:22:37 <dafis> proppy: no need for a where clause if the function is that simple
05:22:54 <proppy> dafis: oh you're right, it is working now, I wonder why it was not before :)
05:23:10 <proppy> dafis: thanks
05:23:15 <dafis> proppy: probably forgot a set of parentheses
05:23:17 <Saizan> dibblego: what error? and, Cabal version?
05:23:28 <proppy> yes propably
05:24:05 <dafis> dibblego: iirc, you need to cabal install the build-tools first
05:24:30 <dibblego> dafis, if you mean the gtk2hs build tools, I did that
05:24:34 <dibblego> Saizan, http://paste.pocoo.org/show/240789/
05:25:12 <dcoutts> pozic: do I need a special gcc version to handle OpenMP ?
05:25:13 <dafis> dibblego: yes, I meant that, okay, so it's something else :(
05:25:15 <Saizan> dibblego: ghc-pkg list Cabal ?
05:25:38 <Saizan> dibblego: i think the solution is --cabal-lib-version="1.8.0.6" anyhow
05:25:51 <pozic> dcoutts: 4.3.4 is what I used. 
05:26:02 <pozic> dcoutts: I will give you the command line to compile, which is standard.
05:26:05 <dcoutts> pozic: hmm, same here, it cannot find omp.h
05:26:06 <dibblego> Saizan, http://paste.pocoo.org/show/240790/
05:26:29 <pozic> dcoutts: gcc openmptest.c -fopenmp
05:26:53 <dcoutts> pozic: it still cannot find omp.h
05:27:09 <pozic> dcoutts: libgomp installed?
05:27:24 <pozic> dcoutts: I didn't install it separately, AFAIK.
05:27:33 <dibblego> Saizan, http://paste.pocoo.org/show/240791/
05:27:36 <pozic> dcoutts: but I assume it comes from there.
05:28:19 * dcoutts looks for a suitable lib
05:29:01 <Saizan> dibblego: add -DCABAL_VERSION_MINOR=8
05:29:57 <dcoutts> pozic: ah, I'll need to rebuild gcc from source
05:29:59 <dibblego> unrecognized option `-DCABAL_VERSION_MINOR=8'
05:30:12 <pozic> dcoutts: I just use a standard Ubuntu gcc.
05:30:29 <dcoutts> pozic: on gentoo openmp support is a compile time option for gcc
05:30:35 <Saizan> dibblego: yeah, sorry, like it says in the warning, you've to do it via --ghc-option=
05:30:48 <dibblego> ah sorry I'd read that too
05:30:51 <pozic> dcoutts: ah, everything is always a USE flag ;)
05:30:57 <dcoutts> aye
05:30:59 <pozic> dcoutts: and you always choose the wrong ones.
05:31:03 <dcoutts> :-)
05:31:18 <pozic> (at least that was my experience "no, I will never need THAT."). Fun times.
05:31:32 <dibblego> Saizan, woot! thanks, moving on...
05:33:08 <old_sound> Hi, I've installed the new haskell platform and now I get errors like:
05:33:20 <old_sound> You are using the old package `base' version 3.x.  Future GHC versions will not support base version 3.x. You              should update your code to use the new base version 4.x.
05:33:33 <Saizan> that Gtk2hsSetup hacky way to guess the Cabal version is worrying..
05:33:48 <Saizan> old_sound: that's just a warning
05:34:01 <Ke> ie. a thing you should fix
05:34:05 <dcoutts> old_sound: but it's good advice
05:34:19 <old_sound> but I get that from other libraries, not from my code :)
05:34:53 * Saizan ignores warning on other libraries
05:34:56 <old_sound> my question is, does that means that what comes with the platform is outdated or that other stuff that I have there is outdated?
05:34:58 <Saizan> *warnings
05:35:03 <old_sound> Saizan: oh ok
05:35:05 <old_sound> thanks
05:35:09 <povman> Hello fellow dudes. I am currently sick at home and feel like writing a client for something, any requests?
05:35:12 <Twey> old_sound: It means the library in question hasn't been updated to use the new libraries.
05:35:36 <Ke> old_sound: base-3 will not work on ghc-6.14 I hear
05:35:56 <Saizan> old_sound: it might mean that the lib is still using the base-3 API, but it might also mean that it simply accepts both base-3 and base-4 but it's not explicit about it
05:36:04 <Saizan> old_sound: which lib is this, in particular?
05:36:06 <old_sound> but what comes with the platform should be considered OK, right?
05:36:13 <Saizan> yeah
05:36:32 <old_sound> cool
05:37:18 <dafis__> Saizan: I remember seeing that for many libraries (not which, though)
05:37:38 <Saizan> dafis__: in the platform?
05:37:49 <old_sound> I'm playing with snapframework and some of its dependencies are throwing those warnings
05:38:01 <dafis__> Saizan: no, not there, I've never used the platform :)
05:38:18 <askhader> What is the predicate to check if something is a list?
05:38:21 <Twey> old_sound: Try recompiling all the complaining libraries with --preference="base >= 4"
05:38:31 <Twey> askhader: There is no such predicate
05:38:37 <askhader> Ah interesting. Thank you/
05:38:47 <old_sound> will try adding that
05:38:48 <Twey> askhader: If it's not a list, it can't be passed to a function that requires a list
05:38:57 <Twey> askhader: That's the point of strong typing :Гѕ
05:38:59 <dafis__> Saizan: but I'm not sure whether old_sound got that warning for a platform lib or for something he installed additionally
05:39:55 <old_sound> btw --preference="base >= 4" is for GHC or for cabal?
05:40:01 <Saizan> cabal
05:40:07 <dafis__> old_sound: cabal
05:40:07 <Twey> old_sound: To cabal
05:40:15 <old_sound> got it :)
05:40:20 <dafis__> thrice
05:40:43 <Twey> old_sound: That will make the ones that can use base-4 use base-4.  Personally I believe this should be the default, but hey-ho.
05:40:49 <Saizan> dafis__: yeah, but i'd be mildly surprised if it happens for a package in the platform
05:41:20 <Twey> old_sound: You can add it to your ~/.cabal/config to make it the default in future.
05:41:40 <dcoutts> Twey: I'm not sure that's a good idea
05:41:46 <Twey> dcoutts: No?
05:41:46 <dcoutts> that may simply break lots of old libs
05:41:54 <dafis__> Saizan: yeah, but only mildly
05:41:55 <Twey> I've only encountered one lib that it breaks
05:42:05 <Twey> And you can always override it in those cases
05:42:09 <dcoutts> Twey: old libs that do not specify an upper bound on base
05:42:19 <dcoutts> Twey: ie that claim to work with base 4, but really were never tested
05:42:19 <Twey> dcoutts: Yeah
05:42:35 <Twey> Well, it'll produce some fairly obvious compile errors
05:42:47 <dcoutts> Twey: there's less of them about now I guess, we needed that hack initially or half of hackage would have broken.
05:42:54 <Twey> Yeah.
05:43:09 <dcoutts> it'd be interesting to see how many are still affected
05:43:48 <old_sound> I'm seeing that the --preference="base >= 4" is there in the .cabal file generated by snap
05:44:18 <dafis__> dcoutts: btw, is it planned to lift the preferred version < 3 restriction on parsec?
05:44:38 <dcoutts> dafis__: if/when version 3 is declared the stable/recommended version
05:44:43 <mm_freak> i've set up a very simple particle system of 10000 moving particles using Elerea
05:44:57 <dafis__> dcoutts: by the parsec maintainer(s)?
05:44:57 <dcoutts> dafis__: e.g. if version 3 is proposed for the platform
05:45:01 <dcoutts> dafis__: right
05:45:03 <mm_freak> while it handles 1000 particles without problems, 10000 particles already start to lag
05:45:22 <mm_freak> is this a general problem of FRP, or is it just a nonoptimal implementation i'm using?
05:45:39 <Saizan> old_sound: you mean that it has "base >= 4" in the build-depend field? that's another thing
05:45:54 <old_sound> yes, there
05:46:08 <old_sound> ah, Ic, is saying that base should be >= 4
05:46:09 <old_sound> ok
05:46:09 <Saizan> old_sound: since that applies only on that particular package, not on the dependencies
05:46:47 <mm_freak> and with 100000 particles a frame almost takes a second
05:47:27 <sbahra> mm_freak = mmorrow?
05:47:36 <mm_freak> sbahra: no
05:48:49 * hackagebot AC-Vector 2.0.0 - Efficient geometric vectors and transformations.  http://hackage.haskell.org/package/AC-Vector-2.0.0 (AndrewCoppin)
05:54:17 <quicksilver> mm_freak: I'm sure it's not specifically a problem with FRP.
05:54:44 <quicksilver> mm_freak: haskell's numerics isn't very fast without carefully programming - 100K particles per sec is not absurdly slow.
05:54:53 <quicksilver> you'll just have to work out where it's spending the time and how you can do better.
05:55:24 <mm_freak> i'd be surprised, if the numerics were the problem
05:55:30 <pozic> mm_freak: There is no such thing as "FRP". Just a bunch of people which name things "FRP". Figure out the exact language you want to execute fast, think about the complexity and then you know whether or not it is fundamental or not.
05:55:35 <mm_freak> but wait, i'll try something
05:55:43 <mm_freak> maybe it's not related to the particle system or FRP at all
05:56:16 <quicksilver> mm_freak: why would you be surprised in numerics was the problem?
05:56:30 <quicksilver> 100K particles I assume they all have position + velocity, that's 6 floating point numbers
05:56:43 <quicksilver> perhaps they also have colour? acceleration?
05:56:44 <mm_freak> ok, seems like most of the time is spent /drawing/ the particles
05:57:00 <mm_freak> they only have a position
05:57:15 <quicksilver> how are you drawing them?
05:57:22 <mm_freak> the velocity depends completely on the current state of a certain other particle
05:57:39 <mm_freak> i'm drawing them into an SDL window using SDL.Primitives
05:57:54 <Eduard_Munteanu> I could see how rendering something like that can bog it down.
05:58:35 <quicksilver> is SDL Primitives hardware accelerated? I suspect not.
05:58:58 <mm_freak> no, not the way i use it
05:59:07 <quicksilver> ah, well.
05:59:09 <quicksilver> no surprised there then.
05:59:23 <quicksilver> to draw 100K particles per frame, I recommend a hardware accelerated path :)
05:59:55 * quicksilver would use opengl, but that's only because I know it.
05:59:55 <mm_freak> but still, even when i don't draw anything, i can only do like four frames a second with 100k particles
06:00:07 <Eduard_Munteanu> Are the particles simple 2D points or something else?
06:00:09 <mm_freak> yes, this is just a test project
06:00:11 <quicksilver> so, processing 400K particles/second
06:00:21 <mm_freak> using software mode to draw points is simpler =)
06:00:24 <quicksilver> is it GC time or MUT time?
06:00:50 <mm_freak> Eduard_Munteanu: 2D points
06:01:27 <mm_freak> quicksilver: i don't think that any GC can happen here at all
06:01:35 <mm_freak> there is no state to GC
06:05:34 <kowey> hi all, how do I go about answering a question like "when was GHC.Handle deprecated"?
06:05:55 <kowey> check GHC release notes? download darcs repository?
06:06:48 <dafis> kowey: I have no better idea (except first asking if somebody remembers)
06:07:07 <mm_freak> quicksilver: often i've found that my way of constructing monadic values is the bottleneck
06:07:28 <mm_freak> in this case i'm using a forM_ with a large list
06:07:50 <mm_freak> and i've written a custom sequenceA, which generalizes sequence to Applicative
06:10:40 <ddarius> :t sequenceA
06:10:41 <lambdabot> Not in scope: `sequenceA'
06:10:45 <ddarius> @hoogle sequenceA
06:10:45 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
06:10:45 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
06:11:04 <stulli> I got this error: main.hs: Prelude.init: empty list 
06:11:06 <stulli> Is there a way to find out on which line the error is?
06:11:54 <stulli> (apart from inspecting the code manually)
06:12:24 <mm_freak> ddarius: sequenceA :: Applicative f => [f a] -> f [a]
06:12:37 <mm_freak> just Applicative instead of Monad
06:13:30 <mm_freak> but yes, the two seem to do what i want
06:16:20 <kowey> thanks, dafis, I went with the darcs option (darcs changes -i GHC/Handle.hs --match 'hunk DEPRECATED')
06:23:46 <quicksilver> mm_freak: don't really understand what you mean by "no GC"
06:23:53 <quicksilver> mm_freak: haskell is full of GC everywhere
06:24:04 <quicksilver> all your temporary variables, your intermediate lists, etc.
06:24:24 <quicksilver> a useful first step in understanding haskell performance is to take if GC is taking too much of your time
06:24:28 <gio1232> is there anybody who works about termination problem?
06:24:33 <quicksilver> (-RTS -sstderr)
06:24:52 <Tomsik> termination problem of what sort?
06:25:00 <Zao> gio1232: I don't think anyone of them are finished yet :D
06:25:15 <gio1232> :)
06:25:21 <Zao> Solving the halt problem for some restricted cases, I assume.
06:25:33 <gio1232> Zao: yes
06:25:47 <gio1232> I meant in term rewriting
06:25:56 <gio1232> to prove termination
06:30:52 <Axman6> well Agda programs have to be able to prove termination
06:34:08 <mm_freak> quicksilver: when i switched from Double to Float, it made a significant improvement
06:34:32 <mm_freak> but i guess, this is not portable
06:34:57 <nominolo> preflex: seen waern
06:34:57 <preflex>  waern was last seen on #haskell 65 days, 16 hours, 10 minutes and 13 seconds ago, saying: I guess we have to actually have download and run it! ;-)
06:47:51 <quicksilver> mm_freak: Interesting. Float is slower than Double
06:48:01 <quicksilver> mm_freak: so the improvement must be down to the memory savings.
06:48:09 <dafis> quicksilver: that
06:48:36 <mm_freak> quicksilver: i think, "Float is slower than Double" is not portable
06:49:14 <dafis> mm_freak: nowadays, it's a fair bet that Float will be promoted to Double for calculations, I thnik
06:49:18 <dafis> thunk*
06:49:23 <dafis> think**
06:49:36 <IPHAIL> can someone please answer my question in haskell-blah?
06:49:47 <IPHAIL> i am trying to change my IP/use anonymous IP but don't know how
06:50:10 <quicksilver> mm_freak: portability is a lie. We're all using basically the same architectures :)
06:50:29 <quicksilver> mm_freak: and as far as I know, Float is slower than double for all of them.
06:51:25 <Eduard_Munteanu> Maybe very strict IEEE behavior is asked from Doubles in this case?
06:53:51 <Eduard_Munteanu> Does GHC still use GCC? It would be interesting to pass -ffast-math or something to test.
06:54:32 <Ke> wasn't it -f-via-c oslt
06:54:34 <dafis> Eduard_Munteanu: if compiling via C, -fexcess-precision is the thing
06:55:16 <dafis> Eduard_Munteanu: I've never found -ffast-math do anything above that
06:55:37 <quicksilver> dafis: well, only on x86
06:55:58 <quicksilver> dafis: on x86_64 it'll generate MMX code which is 64 bit doubles
06:56:02 <dafis> quicksilver: true, then I've never used anything else in the last years
06:56:34 <quicksilver> (conceivably a REALLY GOOD code generate could make Floats faster than Doubles with SSE2/3/4 but in practive that is not so likely)
06:56:55 <quicksilver> auto-vectorising is hard, let's go shopping.
06:57:14 <Eduard_Munteanu> Yeah, there was a change in GCC 4.4 recently wrt IEEE strictness, if I recall correctly.
06:57:26 <dafis> quicksilver: in my limited experience, the truncating of doubles to 64 bits after each step is a huge slowdown
07:00:39 <quicksilver> dafis: as I said, not on x86_64
07:00:53 <quicksilver> dafis: x86_64 doesn't have a x87 with 80 bit registers.
07:01:06 <dafis> oh
07:01:16 <quicksilver> x86_64 uses MMX as its only FPU mechanism.
07:01:23 <quicksilver> (MMX/SSE/and friends)
07:01:34 <Eduard_Munteanu> MMX? That's integer.
07:01:45 <quicksilver> and the registers there are 32/64/128 bit
07:01:54 <quicksilver> (256 perhaps on some of the most recent?)
07:02:09 <quicksilver> divided up into chunks which you can choose to treat as IEEE floating or integer
07:02:14 <quicksilver> depending what your'e trying to do.
07:03:11 <Eduard_Munteanu> It uses SSE regs (xmm*) mainly on x86-64.
07:03:38 <Eduard_Munteanu> And the ABI is specified in terms of that.
07:03:58 <Eduard_Munteanu> (non-vectorised)
07:04:50 <jmcarthur> yeah, it's SSE
07:05:07 <jmcarthur> and i think GHC HEAD actually uses it somewhat properly now?
07:05:56 <quicksilver> properly as opposed to what?
07:06:03 <quicksilver> GHC has always used it on x86_64
07:06:03 <jmcarthur> i don't remember at all :)
07:06:06 <jmcarthur> improperly :P
07:06:06 <Eduard_Munteanu> The trouble with MMX is that you can only hold integers and _convert_ them to float, i.e. 2 -> 2.
07:06:27 <jmcarthur> it was somewhat recent news. maybe i can find it
07:07:31 <jmcarthur> http://www.haskell.org/pipermail/cvs-ghc/2010-February/052474.html
07:07:33 <jmcarthur> SSE2
07:07:36 <Jagdwurst> hi, a question about this page:  http://www.haskell.org/all_about_monads/html/xformeranatomy.html
07:07:42 <Jagdwurst> in the first brown box:  (StateT x') <- return $ f v 
07:07:49 <sbahra> You don't want to use MMX in GHC, anyways.
07:08:25 <sbahra> You'll end up spending a good amount of cycles restoring the FP stack state if you're doing double/real in programs.
07:08:41 <Jagdwurst> is this the same thing with :      let (StateT x') = f v      ?
07:08:42 <jmcarthur> Jagdwurst: yes?
07:08:48 <jmcarthur> no
07:09:01 <jmcarthur> oh
07:09:03 <jmcarthur> yes
07:09:07 <jmcarthur> err
07:09:19 <Jagdwurst> jmcarthur: xD   no or yes?
07:09:24 <Philonous> Jagdwurst: As a matter of fact this equality is guaranteed by the monad laws
07:09:29 <jmcarthur> x <- return  is normally the same as  let x =
07:09:32 <jmcarthur> so yes
07:09:38 <jmcarthur> i was completely misreading it
07:10:18 <Philonous> Jagdwurst: So unless someone wrote an illegal monad instance you can assume it is true
07:10:21 <dafis> Jagdwurst: in short: yes
07:10:32 <Eduard_Munteanu> sbahra: I think you mean x87
07:10:44 <Eduard_Munteanu> not MMX.
07:11:18 * hackagebot AC-Angle 1.0 - Angles in degrees and radians.  http://hackage.haskell.org/package/AC-Angle-1.0 (AndrewCoppin)
07:11:28 <sbahra> Eduard_Munteanu, no, I am referring to MMX.
07:11:29 <Jagdwurst> but i read in В«Real World HaskellВ»,    it says, it's better to use  `let`  than with this `<- return`
07:12:01 <Jagdwurst> did i understand rightly?
07:12:09 <Eduard_Munteanu> Hm, you need to save FP state just like in x87 for MMX?
07:12:11 <dafis> Jagdwurst: a question of style
07:12:36 <sbahra> Eduard_Munteanu, sorry, I meant, you have to clear MMX state if you want to use x87.
07:12:37 <dafis> Jagdwurst: x <- return $ f y looks ungood
07:12:38 <jmcarthur> i would use let because it's cleaner and because return in some monads might not be as cheap as you'd think (but i don't know of any monads for which it's expensive off the top of my head)
07:12:45 <sbahra> Eduard_Munteanu, emms instruction.
07:12:53 <tafryn> dafis: Doesn't the let avoid wrapping the result of f v only to then unwrap it?
07:12:57 <Eduard_Munteanu> sbahra: oh, they were aliased or something IIRC.
07:13:13 <dafis> tafryn: should be optimised out anyway :)
07:13:15 <jmcarthur> tafryn: i don't know *for sure* about that in do notation, but i would hope so
07:13:39 <jmcarthur> dafis: only if GHC has some sort of rewrite rule to optimize out returns
07:13:50 <jmcarthur> i'm not saying it doesn't, but i don't know for sure
07:14:35 <jmcarthur> either way, i'd still use let just because it's cleaner
07:14:48 <Eduard_Munteanu> Rewrite rule? Isn't there some sort of neat algorithm that just deals with this stuff away? Like optimizations on SSA form etc.
07:14:49 <Philonous> Jagdwurst: Modulo some semantic subtleties. For example you can write a recusrive definition with let, but not with bind and failing pattern matches will generate exceptions with let, but bind will use the monadic fail (which can be different)
07:14:56 <Philippa> you can use a let to create a recursive binding without using mdo
07:14:59 <Phyx-> :t getInfo
07:15:00 <lambdabot> Not in scope: `getInfo'
07:15:07 <Phyx-> :t GHC.getInfo
07:15:08 <lambdabot> Couldn't find qualified module.
07:15:35 <jmcarthur> Eduard_Munteanu: rewrite rules are often used for things like deforestation, which i don't think most SSA optimizations could work around
07:15:47 <jmcarthur> Eduard_Munteanu: btw, haskell terms are pretty much in SSA form already ;)
07:16:24 <Eduard_Munteanu> jmcarthur: hm yeah. Though I'm still puzzled by how GHC works, especially when I hear stuff like "we don't really do CSE"
07:16:32 <jmcarthur> Eduard_Munteanu: so a more accurate way of saying what i just did is that rewrite rules *are* SSA optimizations ;)
07:16:42 <jmcarthur> Eduard_Munteanu: CSE would destroy sharing too often
07:16:49 <Philonous> Jagdwurst: For example 'let (Just foo) = Nothing' will give an exception in the List monad, but "Just foo <- return Nothing" will give you [] 
07:16:56 <jmcarthur> err
07:16:58 <jmcarthur> introduce
07:17:14 <Philippa> yeah, it can introduce space leaks
07:17:16 <jmcarthur> Eduard_Munteanu: too much CSE could cause space leaks
07:17:17 <Jagdwurst> oh
07:17:34 <Philippa> it drives me nuts when I have two terms that are representation-equivalent but I have to manually construct the second because it has a different type, though
07:18:10 <jmcarthur> isn't let supposed to allow you to write polymorphic terms?
07:18:22 <Philippa> sometimes I'm pattern-matching the first one :-)
07:18:36 <Philippa> so different use case
07:18:39 <jmcarthur> ah
07:19:17 <Philippa> the usual offender is wanting an Left-based Either Err Foo to be an Either Err Bar
07:19:23 <Jagdwurst> good to know :D
07:19:28 <jmcarthur> ah, yeah, i hate that too
07:19:46 <jmcarthur> but of course you could just use fmap ;)
07:19:50 <jmcarthur> in that particular case
07:20:01 <Philippa> yeah, but that's going to reconstruct too
07:20:02 <jmcarthur> oh but you matched it
07:20:04 <jmcarthur> yeah
07:20:33 <Philippa> of course the 'real' answer in my usual use case is to use a continuation-based implementation instead, but the Either-based version's easier to get right if you need a proof of concept
07:20:45 <jmcarthur> unsafeCoerce is clearly the right answer
07:21:24 <jmcarthur> actually, would it be safe for Functor (Either a) to use unsafeCoerce to avoid reconstructing the Left?
07:21:28 <Philippa> heh. A more general type for each constructor might be, I wonder if that's viable now?
07:21:30 <jmcarthur> seems like it *should*
07:21:53 <Philippa> if I were one of the Simons I'd be wary of people doing that because it pins down the implementation, but hey
07:21:54 <Eduard_Munteanu> Is there any GC-less Haskell implementation? I don't care if it's missing some features.
07:22:06 <Philippa> I think older JHC implementations were
07:22:15 <Eduard_Munteanu> Philippa: thanks. Is it sound?
07:22:20 <jmcarthur> Eduard_Munteanu: kind of hard to be GC-less
07:22:31 <jmcarthur> older JHC implementations still had limited region inference
07:22:33 <Eduard_Munteanu> I mean, or is it "hope we don't exhaust all memory"
07:22:50 <Philippa> it's "hope we don't exhaust all memory"
07:22:55 <jmcarthur> it's just a cross-your-fingers situation
07:22:55 <Philippa> region inference for a lazy language is a bitch
07:22:56 <Eduard_Munteanu> Ah :(.
07:23:00 <jmcarthur> yeah :(
07:23:09 <sbahra> Eduard_Munteanu, yes.
07:23:30 <sbahra> Eduard_Munteanu, we're pretty much required to do this, even if it isn't true to this day, at least for backwards compatibility (it is valid for states to be shared).
07:23:39 <Eduard_Munteanu> Because it occurred to me it'd be great to have that for stuff like House. Bonus if you can define the RTS in your code and rebind it at runtime :)
07:23:41 <sbahra> Eduard_Munteanu, of course, we don't have this problem if we're using XMM registers.
07:23:58 <Eduard_Munteanu> sbahra: I see.
07:24:11 <jmcarthur> haskell without gc is just not practical, IMO
07:25:00 <Eduard_Munteanu> Yeah, I cringe at House, it's just a hack of GHC's RTS :(
07:26:10 <Eduard_Munteanu> Oh well, GC in kernel isn't my cup of tea.
07:26:38 <jmcarthur> i personally don't think a GC at the kernel level would be such a bad idea if it was good enough and if it was powerful enough to extend to userspace and if it was able to avoid stupidity like paging to disk right before needing to scan it for the GC
07:26:50 <Philonous> parsec 2 seems to be preferred to parsec 3, why is that, again? 
07:27:08 <jmcarthur> Philonous: initially i think 3 was slow, but that's been fixed
07:27:09 <Saizan> Philonous: maintainer's choice
07:27:26 <dafis> Philonous: if memory serves correctly, in part because parsec-3 was initially slow
07:27:35 <Saizan> i guess my answer doesn't really explain much :)
07:27:42 <Philonous> Initially, but not any more?
07:27:50 <Eduard_Munteanu> jmcarthur: yeah. A totally different, realtime, GC would be in order.
07:27:53 <benmachine> parsec 3 has been speeded up
07:28:05 <dafis> Philonous: it's been reported to be close in performance now
07:28:09 <BMeph> *sped
07:28:23 <jmcarthur> speededededed
07:28:25 <BMeph> benmachine: ;)
07:28:28 <benmachine> no u
07:28:37 * benmachine sticks with speeded
07:28:44 <benmachine> it's my language I'll abuse it how I want to :P
07:29:04 <Eduard_Munteanu> 'Sped' sounds better to me as well, not being a native.
07:29:14 * BMeph recommends some corn strach to benmachine to take care of that sticking..."problem"...
07:29:23 <jmcarthur> corn strach?
07:29:28 <benmachine> heh
07:29:28 <Philonous> But parsec 2 still is the canonical choice? 
07:29:39 <benmachine> Philonous: I'd say no, go with parsec 3
07:29:45 <BMeph> *starch
07:29:49 <benmachine> but I'm low on practicality
07:29:52 <jmcarthur> Philonous: cabal-install will use it by default if you don't specify 3, i think
07:29:59 <benmachine> also sped is probably correct yes but the syllable flow is a bit awkward
07:29:59 <proppy> will map (f, a) xs will return [(f(x), a), ...] ? 
07:30:00 <jmcarthur> but i would use 3, myself
07:30:11 <proppy> s/will// :)
07:30:20 <benmachine> Philonous: there are some things that parsec 3 is just better at, as well
07:30:24 <jmcarthur> proppy: that doesn't type check
07:30:35 <Philonous> Oh, 3 it is, than. 2 is documented rather poorly.
07:30:48 <benmachine> 2 is documented better than 3 I thought :o
07:30:48 <Philonous> then*
07:31:13 <dafis> proppy: map (flip (,) a . f) :D
07:31:13 <benmachine> I thought parsec wasa supposed to be "one of the good ones" doc-wise
07:31:21 <jmcarthur> :o
07:31:28 <proppy> what does "." means ?
07:31:35 <benmachine> @src (.)
07:31:35 <lambdabot> (f . g) x = f (g x)
07:31:35 <lambdabot> NB: In lambdabot,  (.) = fmap
07:31:36 <Eduard_Munteanu> proppy: you want map (\x -> (f x, a)) xs
07:31:41 <proppy> oh ok
07:31:48 <dafis> proppy: function composition
07:31:48 <jmcarthur> @unpl flip (,) a . f
07:31:49 <lambdabot> (\ h -> (,) (f h) a)
07:31:49 <benmachine> proppy: it's basically a way of chaining functions together
07:32:05 <benmachine> so the one on the left gets as input the output of the one on the right
07:32:34 <Eduard_Munteanu> I really wonder why math people chose to define composition so backwards.
07:32:47 <Eduard_Munteanu> Sometimes I wish they used flip (.)
07:32:50 <Philonous> benmachine: Well, at least version 2.1.0.1 is virtually undocumented. Parsec 3's docs are ok, though
07:32:54 <jmcarthur> i'm fine with (.)
07:32:59 <dafis> Eduard_Munteanu: because they chose to write f(x) and not x f
07:33:06 <proppy> benmachine: like f(g(h) but less netsy
07:33:09 <proppy> nesty
07:33:14 <Eduard_Munteanu> dafis: sure, but chasing arrows in diagrams is better with flip (.) :)
07:33:17 <jmcarthur> Eduard_Munteanu: (f . g) x  matches  f(g(x))
07:33:22 <Eduard_Munteanu> Yeah.
07:33:30 <proppy> @unpl flip
07:33:30 <lambdabot> (\ a b c -> a c b)
07:33:41 <dafis> Eduard_Munteanu: sure, but diagrams only got widespread use long after
07:34:05 <jmcarthur> i'm also not sure that flipping it would necessarily be any better
07:34:11 <Eduard_Munteanu> BTW, any standard/common flip (.) operator in Haskell?
07:34:15 <benmachine> >>>
07:34:19 <jmcarthur> Eduard_Munteanu: just use Factor if you like the other direction ;)
07:34:21 <benmachine> :t (>>>)
07:34:22 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
07:34:24 <jmcarthur> yeah >>>
07:34:30 <dafis> @hoogle (>>>)
07:34:30 <Eduard_Munteanu> Nice.
07:34:30 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
07:34:31 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
07:34:59 <Eduard_Munteanu> Unfortunately it's an instance of Category it seems, not very general.
07:35:11 <Eduard_Munteanu> *defined in an instance
07:35:26 <dafis> Eduard_Munteanu: (->) is an instance of Category
07:35:35 <Eduard_Munteanu> Oh, it's good then.
07:35:40 <Eduard_Munteanu> > id >>> id
07:35:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:35:40 <lambdabot>    arising from a use of `...
07:35:48 <Eduard_Munteanu> > (id >>> id) a
07:35:48 <lambdabot>   a
07:35:57 <Twey> Also an instance of Arrow
07:36:21 <proppy> what is f so f (a, b) c == (a,b,c) ?
07:36:52 <dafis> :t uncurry (,,)
07:36:53 <lambdabot> forall a b c. (a, b) -> c -> (a, b, c)
07:37:01 <dafis> proppy: ^^
07:38:12 <proppy> woo, mystic
07:38:37 <Philonous> @pl \g (x,y,z) -> g x y z
07:38:37 <lambdabot> (line 1, column 8):
07:38:37 <lambdabot> unexpected ","
07:38:37 <lambdabot> expecting letter or digit, operator or ")"
07:38:37 <lambdabot> ambiguous use of a non associative operator
07:38:39 <gio123> is there anybody who works about termination problem?
07:38:45 <Philonous> Huh, that's the cheap way out
07:38:53 <pozic> gio123: do you?
07:39:01 <gio123> no
07:39:04 <gio123> do u?
07:39:13 <dafis> @pl \ g (x,y,z) -> g x y z
07:39:13 <lambdabot> (line 1, column 9):
07:39:14 <lambdabot> unexpected ","
07:39:14 <lambdabot> expecting letter or digit, operator or ")"
07:39:14 <lambdabot> ambiguous use of a non associative operator
07:39:20 <pozic> gio123: why are you asking?
07:39:33 <gio123> i had some question...
07:39:38 <dafis> @pl \ g (x,y) -> g x y
07:39:38 <lambdabot> (`ap` snd) . (. fst)
07:39:43 <zygoloid> @@ @pl @djinn (a, b) -> c -> (a, b, c)
07:39:44 <lambdabot>  f = uncurry (,,)
07:39:47 <pozic> gio123: so, ask.
07:39:58 <gio123> it is not realted with haskel
07:40:34 <dafis> can anybody confirm that pl doesn't know about triples?
07:41:36 <Twey> @pl \a b c -> (a, b, c)
07:41:36 <lambdabot> (,,)
07:41:38 <jmcarthur> i don't see how it would, unless it had special functions for them
07:41:41 <zygoloid> dafis: well, it seemed to do the right thing when i tried
07:41:46 <Twey> Looks like it doesвЂ¦
07:41:47 <jmcarthur> @pl \(a, b, c) -> a b c
07:41:47 <lambdabot> (line 1, column 7):
07:41:48 <lambdabot> unexpected ","
07:41:48 <lambdabot> expecting letter or digit, operator or ")"
07:41:48 <lambdabot> ambiguous use of a non associative operator
07:42:01 <benmachine> it thinks , is non-associative I reckon
07:42:10 <jmcarthur> and it's right
07:42:15 <dafis> zygoloid: yes, but the, why did it barf on @pl \ g (x,y,z) -> g x y z ?
07:42:20 <Twey> Ah
07:42:21 <zygoloid> dafis: perhaps the problem is that it's not possible to make that code points-free?
07:42:22 <benmachine> ok, but it's wrong that it's an operator :P
07:42:37 <zygoloid> (so it's not been implemented)
07:42:42 <benmachine> @djinn (a, b) -> c -> (a, b, c)
07:42:43 <lambdabot> f (a, b) c = (a, b, c)
07:42:49 <jmcarthur> dafis: there is no function defined that gets the first, second, or third elements of a 3-tuple
07:43:07 <dafis> zygoloid: but then it should still be able to parse it
07:43:18 <jmcarthur> true there
07:43:20 <benmachine> dafis: what's the point? :P
07:43:25 <jmcarthur> if it knew tuples properly
07:43:27 * hackagebot AC-Vector-Fancy 2.0.0 - Fancy type system stuff for AC-Vector  http://hackage.haskell.org/package/AC-Vector-Fancy-2.0.0 (AndrewCoppin)
07:43:27 <benmachine> it should probably use HSE or something
07:43:33 <Saizan> dafis: it'd be nice if someone converted @pl to use haskell-src-exts instead of an hand-rolled parser :)
07:43:35 <Philonous> Selective parse errors to avoid admitting the embarassing lack of functions for triples
07:43:42 <fryguybob> @pl \ g ((x,y),z) -> g x y z
07:43:43 <lambdabot> (`ap` snd) . (. fst) . (`ap` snd) . (. fst)
07:43:51 <Twey> Hahaha
07:44:04 <jmcarthur> there's actually some sort of elegance in that
07:44:09 <jmcarthur> maybe after extracting a couple functions
07:44:19 <jmcarthur> :t (<*> snd)
07:44:20 <lambdabot> forall a b a1. ((a1, a) -> a -> b) -> (a1, a) -> b
07:44:28 <Twey> join (flip ap snd . flip fmap fst)
07:44:35 <Twey> Oh, no
07:44:41 <benmachine> join (.)
07:44:49 <benmachine> even that'd probably be insufficiently polymorphic
07:44:50 <dafis> benmachine: the point is, Philonous tried @pl \g (x,y,z) -> g x y z, and lambdabot responded with "unexpected ","", I just wonder what causes this
07:44:51 <zygoloid> @@ @djinn @type \ g ((x,y),z) -> g x y z
07:44:52 <lambdabot>  f a ((b, c), d) = a b c d
07:44:54 <Tomsik> @pl \x y z -> x y (y z)
07:44:54 <lambdabot> ((.) =<<)
07:44:56 <jmcarthur> :t join (.)
07:44:57 <lambdabot> forall a. (a -> a) -> a -> a
07:45:06 <Tomsik> so
07:45:15 <Tomsik> K is just (.) =<<
07:45:22 <benmachine> K is <*>
07:45:28 <benmachine> isn't it?
07:45:30 <roconnor> what's the flag to get all ghc extenstions?
07:45:32 <jmcarthur> yeah
07:45:40 <benmachine> > f <*> g $ x
07:45:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:45:41 <lambdabot>    `SimpleReflect.FromExpr ...
07:45:41 <Twey> Something like -langs
07:45:45 <benmachine> > f <*> g $ x :: Expr
07:45:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:45:46 <lambdabot>    `SimpleReflect.FromExpr ...
07:45:47 <zygoloid> S is <*>, K is pure.
07:45:51 <benmachine> --supported-languaged
07:45:53 <benmachine> *s
07:45:55 <benmachine> --supported-languages
07:46:03 <benmachine> roconnor: that I think
07:46:11 <dafis> benmachine: yes
07:46:18 <roconnor> I thought it was something like -ghcextras
07:46:18 <jmcarthur> -fglasgow-exts? ;)
07:46:21 <roconnor> yes
07:46:29 <benmachine> ooh, you mean enable them
07:46:35 <zygoloid> ghc --supported-languages | head -n 1
07:46:37 <zygoloid> CPP
07:46:43 <roconnor> benmachine: sorry, I was unclear
07:46:49 <Twey> Ah, that's the one
07:47:00 <benmachine> glasgow-exts doesn't enable *everything* though, I think
07:47:07 <jmcarthur> probably doesn't
07:47:19 <jmcarthur> IMO it should be deprecated, if it isn't already
07:47:26 <jmcarthur> i think it is though?
07:47:49 <benmachine> soo, ghc --supported-languages | sed 's/^/-X/' | xargs ghci
07:47:57 <benmachine> aw
07:48:01 <benmachine> doesn't work
07:48:07 * benmachine fiddles
07:48:26 <benmachine> ghci `ghc --supported-languages | sed 's/^/-X/'`
07:48:31 <benmachine> 'sbetter
07:48:55 <proppy> what if I would like [(1,True), (2,False), (3, False)] for [1,2,3] -> map (,) . (==) [1,2,3] ?
07:49:04 <proppy> oups (==) 1
07:49:07 <danderson> using c2hs, how do I reference a #defined value from a C header?
07:49:20 <danderson> hsc2hs has (#const BLAH), but I don't see any c2hs equivalent
07:49:32 <benmachine> :t (id &&& (== 1))
07:49:33 <lambdabot> forall b. (Num b) => b -> (b, Bool)
07:49:37 <jmcarthur> > (id &&& (==1)) <$> [1..3]
07:49:38 <lambdabot>   [(1,True),(2,False),(3,False)]
07:49:48 <benmachine> proppy: Control.Arrow for (&&&)
07:50:08 <jmcarthur> proppy: (<$>) is just map when you are using lists like thart
07:50:10 <jmcarthur> *that
07:50:56 <proppy> id &&& (==1)) <$> [1..3] is equivalent to map (id &&& (==1)) [1..3] then ?
07:51:09 <jmcarthur> yes
07:51:20 <delusion42> Could someone take a peek at my boilerplate "forwarding" instances for a simple sum type and help me figure out how I'm getting an infinite loop? :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28011
07:51:32 <zygoloid> > map ((,) . (==1)) [1,2,3]
07:51:33 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (GHC.Bool.Bool, b))
07:51:33 <lambdabot>    arisin...
07:51:36 <danderson> aha, enum define appears to be implemented!
07:51:43 <zygoloid> > map ((,) `ap` (==1)) [1,2,3]
07:51:44 <lambdabot>   [(1,True),(2,False),(3,False)]
07:52:04 <Isaiahs> Sendme a pic of ur dic 214916 0073
07:52:08 <proppy> `ap` ?
07:52:15 <proppy> @t `ap`
07:52:15 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:52:23 <jmcarthur> delusion42: which function loops?
07:52:26 <fryguybob> :t ap
07:52:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:52:40 <delusion42> jmcarthur: seems to be the fromInteger impl at the bottom
07:52:43 <delusion42> in the Num instance
07:52:52 <delusion42> at least, that's the only place i'm getting trace output
07:53:33 <delusion42> there's a sample invocation at the top of the file that demonstrates the looping, via signExtend
07:53:41 <jmcarthur> delusion42: i don't know about a loop, but your guards seems a bit weird
07:54:13 <jmcarthur> oh, nevermind
07:54:19 <delusion42> well, even if the guards went away, and i put everything into a BLong-constructed value, I should be looping
07:54:21 <jmcarthur> i read "maxBound" where it said "minBound"
07:54:32 <delusion42> ah
07:54:33 <benmachine> delusion42: fromIntegral = fromInteger . toInteger, btw
07:55:11 <benmachine> just wondering about your fromIntegral calls there if they're not calling the same fromInteger again
07:55:12 <delusion42> benmachine: yeah, i peeked at that and thought it was the problem, but i still think I should be getting the Int32/64 instance, not my own
07:55:47 <delusion42> hmm
07:55:47 <jmcarthur> delusion42: in your guards, the fromIntegral will be using whatever instance corresponds to the type of x
07:56:16 <delusion42> oh, duh
07:56:18 <delusion42> okay, that might be it
07:56:22 <benmachine> x should be an integer shouldn't it?
07:56:34 <roconnor> @type (<<<)
07:56:34 <dafis> jmcarthur: since it's in the definition of fromInteger, it's okay
07:56:34 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
07:56:35 <benmachine> I'd start by using toInteger and fromInteger explicitly and seeing if that helps
07:56:39 <jmcarthur> right
07:56:46 <jav_irc> Hi there! I have a Cabal question: If my program includes a system-wide configuration file how do I tell that cabal? .. Preferably I would like it to end up in /etc upon system-wide installation but it seems my only option is classifying it as 'data-files', is that correct?
07:56:47 <jmcarthur> i was just clarifying because that was the current target of study
07:56:52 <benmachine> it doesn't look like it would but it might do
07:56:57 <delusion42> alrighty, let me try something quickly
07:57:06 <jmcarthur> i don't think it's the problem
07:57:14 <proppy> what is the prelude for foo :: [[Char]] -> [Char] so foo [x:xs] = x ?
07:57:17 <proppy> first ?
07:57:24 <benmachine> head
07:57:31 <proppy> ok :)
07:57:32 <benmachine> erm
07:57:33 <benmachine> wait
07:57:39 <benmachine> no
07:57:45 <benmachine> maybe?
07:57:46 <benmachine> :t map head
07:57:47 <lambdabot> forall a. [[a]] -> [a]
07:57:50 <dafis> proppy: but it should be (x:xs) and not [x:xs]
07:57:55 <jmcarthur> :t \[x:xs] -> x
07:57:55 <proppy> yes :)
07:57:56 <lambdabot> forall t. [[t]] -> t
07:58:09 <benmachine> proppy: give a bigger example, with a multi-element list
07:58:27 <proppy> benmachine: it is for =~ :: [[String]]
07:58:34 <benmachine> I think you either mean 'head' or 'map head' (but both functions can lead to nasty run-time errors, so you might want to do something else)
07:58:34 <proppy> I'm only interested in the first group
07:58:39 <proppy> so head sounds nice
07:58:40 <delusion42> jmcarthur: me, neither, since the otherwise clause is the one that's being chosen
07:58:47 <benmachine> proppy: I'd just use case
07:59:26 <benmachine> case foo =~ bar of [interesting:_] -> do stuff; other -> whine
07:59:48 <delusion42> benmachine: yeah, just to remove any confusion, i /only/ have the otherwise clause now, and i'm still looping
08:00:47 <delusion42> and replaced the Blah-value construction with (BInt (fromInteger x)) and am still looping. this is pretty weird.
08:01:13 <benmachine> delusion42: hmm
08:01:17 <benmachine> delusion42: how about this:
08:01:18 <jmcarthur> delusion42: what are the types you are using with signExtend?
08:01:27 <benmachine> case fromInteger 0 of BInt _ -> True; _ -> False
08:01:31 <proppy> benmachine: something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28012#a28012
08:01:32 <jmcarthur> oh nevermind, you say in the paste
08:01:34 <delusion42> signExtend 64 (-5 :: Int32) :: Blah hangs
08:01:41 <proppy> but I'm string trying to get the type signature right
08:01:41 <jav_irc> Cabals hook system is a little bit weird, too, me thinks
08:01:41 <delusion42> signExtend 64 (-5 :: Int32) :: Int64 does not
08:01:53 <roconnor> @hoogle (a ~> b) -> (f a ~> f b)
08:01:53 <lambdabot> Warning: Unknown type ~>
08:01:53 <lambdabot> No results found
08:02:03 <dafis> delusion42: in signExtend, there's no way to determine which constructor to use for Blah values
08:02:11 <roconnor> @hoogle (x a b) -> (x (f a) (f b))
08:02:11 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
08:02:11 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
08:02:46 <delusion42> dafis: i was hoping that it'd be whatever constructor was chosen by my fromIntegral...
08:02:48 <proppy> String == [Char] ?
08:02:53 <BMeph> [x:xs] is valid Clean...
08:03:04 <delusion42> since I inspect the Integer value and pick the appropriate constructor
08:03:20 <benmachine> proppy: I'd do this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28012#a28013 in case the pattern didn't match
08:03:38 <djahandarie> @hoogle (cat a b) -> (cat (f a) (f b))
08:03:38 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
08:03:39 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
08:04:23 <delusion42> Well, maybe I don't have to understand it, maybe I just specialize a signExtend64
08:04:30 <delusion42> signExtend64 c = let m = (1 `shiftL` 63) in BLong $ (fromIntegral c `xor` m) - m
08:04:42 <benmachine> delusion42: understand everything!
08:04:50 <delusion42> benmachine: i know, that's why i'm pushing on this ;P
08:04:56 <proppy> benmachine: nice, I didn't know about the case thing
08:05:17 <proppy> benmachine: I guess I could do the same with another function ?
08:05:24 <proppy> like
08:05:50 <proppy> maybe (result:_) = result maybe _ = False
08:05:52 <delusion42> dafis: do you think I need to make the decision about the constructor in the signExtend implementation itself? I was hoping the function could remain generic.
08:06:15 <proppy> benmachine: just for the sake of understand 'case' 
08:06:32 <benmachine> proppy: 'case' is a way to pattern-match without defining a new function
08:07:24 <benmachine> proppy: I don't know what you meant with that maybe thing
08:07:28 <benmachine> it didn't look valid though
08:07:51 <benmachine> what my case expression is doing there is going
08:08:02 <proppy> benmachine: so it wil be equivalent to http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28012#a28014 ?
08:08:11 <benmachine> oh
08:08:13 <benmachine> right, yes
08:08:19 <benmachine> sorry, you meant to have a newline in the middle
08:08:37 <proppy> benmachine: yes sorry I was afraid of flooding
08:08:40 <benmachine> :)
08:08:59 <benmachine> usually we use semicolons to mean newlines in chat
08:09:08 <benmachine> (you can actually use them in code too but it's ugly)
08:09:17 <benmachine> case thing of foo -> bar; baz -> bloop
08:09:41 <proppy> in fact I need head head, I will try to pattern match on (x:(x:xs))
08:10:04 <benmachine> hmm
08:10:21 <benmachine> no you want (x:xs):ys I think
08:10:50 <benmachine> x:(y:ys) (notice you can't have two variables with the same name) would match the first two elements of the list to x and y, and ys to the rest
08:11:07 <benmachine> (x:xs):ys matches the first element with (x:xs) and the rest with ys
08:11:18 <proppy> ok yes you're right
08:11:26 <proppy> (x:xs) is the first y of ys
08:11:30 <benmachine> mmhm
08:11:58 <proppy> maybeMatch a ((x:xs):ys) = a == x
08:12:05 <proppy> nice thanks you :)
08:12:24 <benmachine> proppy: btw, you can use _ in a pattern for any variable you don't end up using
08:12:40 <benmachine> maybeMatch a ((x:_):_) = a == x
08:12:44 <proppy> I can use it multiple times ?
08:12:49 <benmachine> yes
08:12:53 <benmachine> because it doesn't make any bindings
08:13:00 <benmachine> the thing that matched is just ignored
08:13:03 <benmachine> _ is a special case
08:13:57 <danderson> in a function with a type parameter in the signature (eg. Ptr a), can I refer to that type parameter in the function body (eg. undefined :: a, to pass to Foreign.Storable.sizeof) ?
08:14:33 <benmachine> danderson: there are two ways to do that
08:14:58 <benmachine> danderson: if you use the ScopedTypeVariables extension, then type variables mentioned in a 'forall' scope over the rest of that declaration
08:15:19 <benmachine> danderson: if you don't want to use that extension, it's usually possible to make a function that will do the same thing
08:15:24 <benmachine> for example, do
08:15:39 <benmachine> sizeOf ((undefined :: Ptr a -> a) ptr)
08:15:56 <danderson> ooh, crafty.
08:16:00 <benmachine> :)
08:16:25 <proppy> I'm not sure how to pattern match the second element of a list
08:16:35 <proppy> x:xs will gimme the remaining of the list as xs
08:16:39 <danderson> (_:x:xs) ?
08:16:40 <Zao> (_:x:xs)
08:16:47 <proppy> and it maybe  empty
08:16:52 <danderson> assuming your list has at least 2 elements of course, or the pattern match will fail
08:16:55 <Zao> Or (_:x:_) if you don't care about the tail.
08:17:11 <proppy> if the list has only 2 element
08:17:14 <proppy> xs will be [] ?
08:17:34 <benmachine> proppy: you do something like, case list of [] -> blah; [x] -> bleh; x:y:ys -> whee
08:17:50 <benmachine> then you're catering for when xs is [] and when it is y:ys
08:18:44 <delusion42> benmachine: okay, this is strange.  if I use fromIntegral over the whole expression instead of just the innermost term, I get the behavior that I want.  What I can't figure out is why the behavior was so strange, though :(
08:18:57 <proppy> maybeMatch a ((_:x:_):_) = a == x
08:19:00 <proppy> nice !
08:19:02 <proppy> :)
08:19:20 <askhader> So why is this illegal? Sorry, new to haskell =|  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28015#a28015
08:19:45 <benmachine> delusion42: in (fromIntegral c `xor` m) - m, you are forcing fromIntegral c and m to have the same type
08:19:56 <benmachine> wait
08:20:00 <benmachine> I can't remember why this is important
08:20:02 <askhader> Okay so line 2 is redundant
08:20:07 <delusion42> hehe
08:20:17 <delusion42> so i now have .e., signExtend n c = fromIntegral $ (c `xor` m) - m where m = 1 `shiftL` (n-1) which works
08:20:27 <delusion42> before i have (fromIntegral c `xor` m) ...
08:20:32 <delusion42> and got the hang
08:20:32 <benmachine> askhader: function application always binds tightest
08:20:45 <benmachine> askhader: that is to say, f x:xs means (f x):xs
08:20:51 <dafis> delusion42: I've found it!
08:20:56 <delusion42> dafis: oh!?
08:21:23 <dafis> delusion42: you forgot to implement (-) or negate in your Num instance :)
08:21:39 <askhader> benmachine: Alright I understand this, but what then is my error? How have I neglected this?
08:21:45 <delusion42> dafis: ...
08:21:53 <delusion42> seirously?
08:22:03 <benmachine> delusion42: and negate too :(
08:22:20 <delusion42> ah, you're right!
08:22:37 <benmachine> askhader: actually, I don't know if I've got this right
08:22:51 <benmachine> askhader: I don't have enough information about your function to work out exactly what you're doing
08:22:58 <delusion42> the docos say: "Minimal complete definition: all except negate or (-)" -- I guess I parsed that wrong ;P
08:23:01 <askhader> Well i've changed it, if you refresh the page
08:23:15 <benmachine> yeah that doesn't help exactly :P
08:23:18 <benmachine> a type annotation would be nice
08:23:19 <benmachine> but
08:23:29 <benmachine> even without that, I can tell you that you're not giving a function to filter
08:23:30 <benmachine> :t filter
08:23:31 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:23:47 <benmachine> ^ the first argument's supposed to be a function, you've just given it a Bool
08:23:51 <askhader> But essentially I want a function that consumes a list that may have duplicate elements in consecutive order, and removes them. "haskell" -> "haskel"
08:23:58 <benmachine> ah
08:24:02 <askhader> Oh I see.
08:24:16 <Taejo> map head . group
08:24:23 <askhader> Then compress must take one argument, the entire list.
08:24:24 <benmachine> heh
08:24:43 <benmachine> askhader: yes
08:24:53 <benmachine> that's reasonable
08:25:05 <askhader> splendid, thanks
08:25:09 <benmachine> erm
08:25:15 <benmachine> I don't think we've fixed it yet :P
08:25:21 <benmachine> but if you like!
08:25:26 <askhader> Er, I'm working on it.
08:25:33 <benmachine> okay
08:25:33 <askhader> Changed my comparison to a lambda expression.
08:25:43 <benmachine> yes, that's a good start
08:25:53 <benmachine> thing with filter though
08:25:55 <benmachine> if you do
08:26:03 <benmachine> filter (\y -> x /= y) xs
08:26:12 <proppy> benmachine: got my regexp expression checker in shape http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28018#a28018
08:26:12 <benmachine> you're going to remove *all* x from xs
08:26:27 <askhader> What I'm going to do is
08:26:36 <askhader> (\x -> if (head x == ... 
08:26:44 <delusion42> thanks for the help folks, the missing (-)/negate was indeed the issue.
08:26:45 <benmachine> proppy: nice
08:26:57 <delusion42> dafis: how did you find that out?
08:27:10 <roconnor> OMG, a traversable functor is a functor on Kleisli categories!
08:27:15 <proppy> I guess it is a bit verbose, but this way I understand all of it :)
08:27:19 <BMeph> askhader: What would "tomato" result in (on your function)?
08:27:23 * benmachine hugs roconnor 
08:27:34 <askhader> BMeph: "tomato"
08:27:53 <roconnor> preflex: seen edwardk 
08:27:53 <preflex>  edwardk was last seen on #haskell 2 days, 3 hours, 28 minutes and 48 seconds ago, saying: ivanm: well, i was getting ready to do the same thing with masters degrees ;) it is satisfying to those who have an addictive personality ;)
08:28:11 <dafis> delusion42: a bit more tracing in signExtend, it computed evreything up to the subtraction - then looking at the Num instance wasn't too hard to come up with
08:28:16 <BMeph> askhader: Okay, then Taejo's function will do you: "map head . group"
08:28:36 <delusion42> dafis: gotcha, makes sense.  thanks for taking the time to peek at it!
08:28:36 <askhader> BMeph: I'm not sure what . group does exactly.
08:28:38 <benmachine> BMeph: it'll do you without you understanding how it works perhaps :P
08:28:47 <dafis> delusion42: you're welcome
08:28:52 <askhader> But this is more an excersice in list comprehension on my part.
08:28:59 <dafis> delusion42: I love puzzles
08:29:04 <BMeph> benmachine: Well, get explaining, already! ;)
08:29:05 <mikebling> OK I'm "Trying Haskell" and I just did fst('g','eВ­',"test"В­) and got Couldn't match expected type `(a, b)' against inferred type `(GHC.Types.Char, GHC.Types.Char, [GHC.Types.Char])'
08:29:16 <delusion42> dafis: i do too, despite the fact that i'm generally terrible at them ;P
08:29:25 <roconnor> @ask edwardk what do you think about adding Instance (Traversable f) => CFunctor f Klesli Klesli where cmap = mapM ?
08:29:26 <lambdabot> Consider it noted.
08:29:29 <mikebling> that's running fst on a tuple isn't it?
08:29:32 <benmachine> mikebling: fst only works on pairs
08:29:40 <benmachine> mikebling: try :t fst
08:29:42 <BMeph> askhader: "." does function composition; "(f . g) x" means "f (g (x))".
08:29:52 <mikebling> thanks
08:30:13 <askhader> Oh
08:30:15 <askhader> Interesting
08:30:17 <benmachine> mikebling: it's not all that common that you'll need to work with bigger tuples, when you do there are other ways to get stuff out of them
08:30:46 <benmachine> askhader: p.s. even if you do understand map head . group I am personally of the opinion it might be educational to work out how to do it the "long way"
08:31:02 <askhader> Well I am attempting to learn haskell, which is why I am doing it 'the long way`
08:31:09 <benmachine> yes
08:31:13 <askhader> Also, if you could take another look at my solution, it doesn't seem to be solving anything =P
08:31:39 <benmachine> askhader: hmm
08:31:46 <benmachine> okay, this isn't quite relevant to your problem but
08:31:53 <benmachine> tell me what if b then True else False does :)
08:31:54 <delusion42> askhader: for clarity you might want to use different variable names
08:32:20 <benmachine> oh yeah, you're using x for both the lambda variable and the list, that's not quite going to work
08:32:34 <askhader> Ah.
08:32:42 <askhader> I think it's obvious what if B then True else False does =/
08:32:45 <delusion42> call the lambda x (\x -> ...) y instead
08:32:49 <BMeph> askhader: So "map head . group" first 1) groups the list by matching elements, into a list of lists, then 2) replaces each inside list with its first element. Ta-da! :)
08:33:13 <benmachine> askhader: well, if B then True else False is an expression that is True if B is True and is False if B is False, right?
08:33:20 <delusion42> B!
08:33:24 <askhader> Correct.
08:33:28 <benmachine> askhader: there's another, smaller expression, which satisfies that property :)
08:34:02 <BMeph> benmachine: Hey! You're gonna ruin it for all the funsters... ;)
08:34:26 <askhader> so can I do something like 'y where y = head x /= head (tail x)  ?
08:34:29 <askhader> '
08:34:57 <benmachine> askhader: you can only use where in a few specific contexts
08:35:07 <benmachine> like, attached to case branches or function equations
08:35:11 <benmachine> you can always use let though
08:35:11 <askhader> I mean I want to use the simplest form, which is the direct comparison, but this didn't work
08:35:25 <BMeph> askhader: What benmachine is trying to get you to think about is: "if B then True else False" means the same thing as "B" does, so why not just use "B"? :)
08:35:41 <benmachine> yes, that was my general gist :P
08:35:45 <askhader> I tried this.
08:35:46 <benmachine> sorry for doing so in a rather obscure way
08:35:48 <askhader> Oh you mean in the lambda.
08:35:51 <benmachine> yes
08:36:39 <askhader> Is there no way for me to create a curried function that checks if the current element of the list is equal to the next? I guess that doesn't make much sense.
08:36:43 <BMeph> benmachine: Hey, at least it wasn't "if (B == True) then True else False"... :D
08:36:50 <benmachine> BMeph: :P
08:37:24 <benmachine> askhader: erm, it sort of makes sense but it's a bit vague on the details
08:37:45 <BMeph> askhader: What do you mean by "a curried function"? What would an uncurried function to do it look like? :)
08:37:46 <benmachine> askhader: I think you were actually doing quite well with your first equation, with two base cases
08:38:01 <benmachine> but the third case wasn't quite right
08:38:36 <delusion42> BMeph: or if (B /= False && B == True) ... you know, just to be sure.
08:38:42 <askhader> I thought the single element list [a] == a:[]  so in that case a /= []  and thus the third case is satisfied?
08:38:58 <askhader> What I have now is compress x = filter (\y -> (head y) /= head (tail y)) x
08:39:00 <BMeph> delusion42: Nice! :D
08:39:04 <delusion42> ;P
08:39:32 <benmachine> askhader: well, a is an element of the list, I think you mean that xs /= []
08:39:33 <askhader> Oh I guess that doesm't cover the single element list
08:39:42 <benmachine> er
08:39:43 <benmachine> wait
08:39:47 <benmachine> um
08:39:50 <benmachine> ok so
08:39:55 <benmachine> you have the [] pattern
08:40:08 <benmachine> you have the [x] pattern which as you rightly said is equivalent to x:[]
08:40:08 <askhader> Yes.
08:40:33 <benmachine> and then you have x:xs - but in fact you already know something about xs in this case, namely that it didn't match []
08:40:40 <benmachine> so you know what it *will* match, right?
08:40:52 <askhader> Right.
08:41:18 <benmachine> ...so your third case is?
08:41:29 <askhader> (x:xs) ?
08:41:51 <benmachine> well it could be, but you can get more information about xs because you know it's not empty
08:42:01 <benmachine> you can do (x:y:ys)
08:42:03 <askhader> What more information do I need?
08:42:09 <askhader> oh
08:42:34 <askhader> Good point.
08:43:02 <benmachine> now you've got two elements of the list
08:43:17 <askhader> but the function that filter takes accepts one argument at a time, or can I refer to all of them?
08:43:36 <benmachine> so don't use filter :P
08:43:47 <askhader> heh
08:43:49 <benmachine> there are actually two ways of doing this
08:43:50 <askhader> I could fold or map
08:43:56 <delusion42> askhader: you can name a pattern match with the @ syntax if that's what you mean
08:44:00 <benmachine> I'm guiding you towards the direct-recursive way
08:44:07 <askhader> I want to avoid explicit recursion.
08:44:12 <benmachine> aah
08:44:13 <BMeph> askhader: Hint: Don't use filter...yeah, benm said that.
08:44:14 <askhader> I /know/ how to explicitly recurse.
08:44:15 <benmachine> you should have said :P
08:44:32 <benmachine> in which case you only need two patterns >_>
08:44:32 <delusion42> heh
08:44:56 <benmachine> and filter isn't quite what you want, still, but it's fairly close
08:45:16 <benmachine> you want a [] pattern and a (x:xs) pattern, I think
08:45:42 <benmachine> hmm
08:45:48 <benmachine> this is going to end up being recursive again
08:45:53 <benmachine> but in a slightly cleverer way
08:46:09 <askhader> heh alright.
08:46:10 <roconnor> anyone used CoTraversable functors?
08:46:19 <benmachine> completely non-recursive would require something like what BMeph originally said (map head . group) or possibly a slightly weird fold
08:46:19 <delusion42> askhader: what were you trying to do? remove duplicates?
08:46:26 <askhader> Consecutive duplicates.
08:46:30 <benmachine> mmhm
08:46:34 <Phyx-> what are you guys doing?
08:46:36 <delusion42> askhader: ahh
08:46:54 <benmachine> askhader: the problem with filter is it doesn't know about consecutiveness
08:47:00 <askhader> Right
08:47:01 <benmachine> it affects the whole rest of the list regardless
08:47:05 <delusion42> i usually do that kind of thing with a funky fold
08:47:07 <benmachine> you probably want dropWhile instead
08:47:10 <askhader> Okay so I guess I have to solve this the explciit way.
08:47:12 <benmachine> funky folds are good yes
08:47:17 <benmachine> you don't
08:47:22 <benmachine> you can do but
08:47:24 <delusion42> carrying down the previous element as part of the "accumulated" state
08:47:25 * Phyx- can't seem to follow anything here anymore
08:47:32 <benmachine> dropWhile should help you be slightly-less explicit
08:47:35 <byorgey> and what's wrong with  map head . group ?
08:47:46 * askhader hasn't met dropwhile
08:47:47 <benmachine> byorgey: it's only one possible solution, we want all of them :P
08:47:51 <askhader> haha
08:47:52 <benmachine> ah okay
08:48:03 <askhader> Okay so I can solve this with guards rather straightforwardly, I think
08:48:07 <benmachine> askhader: dropWhile is simple, I bet you can guess what it does
08:48:08 <askhader> or pattern matching, rather
08:48:10 <benmachine> :t dropWhile
08:48:10 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:48:16 <askhader> Ah
08:48:30 <benmachine> askhader: maybe it'd be good to do that first, especially if it's easy, and then you can compare it to other solutions
08:48:44 <askhader> Yes, of course. I'd love to see the variety of solutions available.
08:48:50 <byorgey> benmachine: ok. have you done the one yet where you write a game of life interpreter, encode a universal turing machine in it, and then run a turing machine compiled from the lambda calculus expression corresponding to map head . group ?#
08:49:11 <benmachine> byorgey: >_>
08:49:14 <benmachine> <_<
08:49:24 <delusion42> askhader: be careful asking for all the possible ways of doing the same in haskell, though. see http://www.willamette.edu/~fruehr/haskell/evolution.html =)
08:49:29 <benmachine> are you disagreeing with my teaching methods??
08:49:29 <byorgey> everyone always misses that one
08:49:35 <benmachine> if so you are probably right :(
08:49:36 * benmachine cries
08:49:42 <byorgey> no, just being silly =)
08:49:49 <benmachine> yay :)
08:50:04 <proppy> when I use (True, b, b) in a pattern match
08:50:11 <proppy> does it means that b should be the sames ?
08:50:17 <byorgey> proppy: no, you can't do that
08:50:19 <benmachine> proppy: you're not allowed to do that
08:50:25 <benmachine> proppy: you can use a guard, though
08:50:28 <delusion42> you can use a guard though
08:50:29 <delusion42> bah
08:50:33 <benmachine> (True, b, c) | b == c
08:50:36 <byorgey> proppy: use  foo (True, a, b) | a == b  = ...
08:50:42 <benmachine> I AM FASTER THAN ALL OF YOU
08:50:43 <proppy> ok
08:50:47 <delusion42> LOL
08:50:49 <pozic> byorgey: it sounded like a good teaching plan. Especially if you say "figure it out yourself".
08:50:54 <Saizan> if you prove map head . group terminating you don't need to implement a whole turing machine
08:51:06 <proppy> thanks
08:51:26 <benmachine> Saizan: is it actually easier to implement half-a-turing-machine?
08:51:48 <benmachine> sounds like a headache to me >_>
08:51:52 <Saizan> benmachine: in the game of life? no idea :)
08:51:55 <benmachine> heheh
08:51:59 <benmachine> mm fair point
08:52:14 <benmachine> ee I think I need to go have a shower before my mum notices I've been wearing a dressing gown all day
08:52:17 <benmachine> brb
08:52:43 <pozic> benmachine: in the basement? ;)
08:53:39 <askhader> So I've revised my solution slightly. I'm still entering into an infinite type (that error is starting to get tingly =] )
08:54:28 <pozic> askhader: are we getting to guess the letters one by one?
08:54:42 <askhader> Sorry I posted a link earlier
08:54:43 <askhader> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28015#a28020
08:54:44 * pozic loves that game
08:54:56 <BMeph> roconnor: What's a CoTraversable functor? :)
08:55:42 <roconnor> BMeph: it has mapW :: (w a -> b) -> (w (t a) -> t b)
08:55:42 <pozic> askhader: (compress y:ys)
08:55:57 <pozic> askhader: that is wrong. You are free to figure out why.
08:56:24 <roconnor> BMeph: and some sort of cotraverse I guess
08:56:55 <roconnor> with the same signature but w a coapplicative functor?
08:57:03 <BMeph> roconnor: "coTraverse", maybe? ;)
08:57:03 <proppy> how do I print a list of string ?
08:57:18 <BMeph> proppy: print string... ;)
08:57:18 <proppy> I added human readable message to the regexp checking code I was playing with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28021#a28021
08:57:19 <applicative> roconnor there you are. I was wondering if you had managed to get a working version of the category-extras / winterk_ version of the 'du' business
08:57:24 <pozic> proppy: print ["OMG"]
08:57:46 <proppy> I mean with a \n between each element of the list
08:57:47 <roconnor> applicative: oh, I haven't tried running the code.
08:57:49 <BMeph> proppy Oops, a list of strings...throw a "mapM_" in front ot that. :)
08:57:49 <applicative> roconnor , so far, if I get it compile, it stays pure and warms the CPU
08:57:52 <applicative> i see.
08:57:56 <roconnor> applicative: why would I run the code :D
08:57:58 <proppy> I'm confused how to loop / recurse in a do statement
08:58:15 <roconnor> applicative: that's distrubing
08:58:40 <applicative> roconnor, funny, i didn't think so about the other...
08:58:42 <pozic> proppy: a = do a
08:58:52 <pozic> proppy: a nice infinite loop
08:59:04 <applicative> roconnor, maybe you're right, probably contributed to my excess of enthusiasm
08:59:22 <BMeph> roconnor: What, are you trying to be edwardk's Padawan? ;Гѕ
08:59:32 <proppy> for example map putStrLn list ?
08:59:54 <pozic> proppy: that simply builds a list of actions.
09:00:07 <pozic> proppy: don't guess what you are doing.
09:00:15 <roconnor> BMeph: I'm really excited by koninkje's soluiton to the du problem.  It seems like a nice concrete application of category-extras to a practical problem.
09:00:47 <proppy> so I could execute these actions with do ?
09:00:50 <proppy> once builded ?
09:00:59 <pozic> proppy: no, with sequence_
09:01:07 <pozic> proppy: but you can also just do mapM_
09:01:20 <pozic> proppy: mapM_ putStrLn list
09:01:32 <pozic> proppy: browse the libraries to see what is possible.
09:01:34 <askhader> pozic: I don't understand y:ys is a list and compress consumes a list.
09:01:56 <roconnor> applicative: I'm trying to build a running version now
09:01:59 <proppy> pozic: which library do you suggest I should browse ?
09:02:07 <BMeph> pozic: Just being nitpicky, but "do" doesn't run anything. ;)
09:02:19 <roconnor> applicative: did you do the appropriate modifications to make it print the directories?
09:02:21 <pozic> BMeph: when did I say that?
09:02:50 <pozic> proppy: everything related to reading and opening files at a minimum.
09:03:04 <pozic> proppy: then you get an idea of how things work.
09:03:10 <proppy> pozic: got an hyperlinks ?
09:03:16 <pozic> proppy: Control.Monad is also vital.
09:03:33 <applicative> roconnor, no, I considered doing that just to get news that something was happening, but it wouldn't work even on a 2 file directory ... 
09:03:36 <pickles> i have a parsec question, if anyone has a minute
09:03:43 <pozic> proppy: google will do just fine.
09:03:49 <proppy> pozic: thanks
09:03:50 <pozic> @google ghc docs
09:03:51 <lambdabot> http://haskell.org/ghc/docs/6.12.2/html/libraries/
09:03:51 <lambdabot> Title: Haskell Hierarchical Libraries
09:03:56 <roconnor> applicative: very importantly, did you filter out the "." and ".." directories.
09:03:57 <pozic> proppy: ^^
09:05:05 <proppy> pozic: thanks this is very usefull, now I understand that _ is for 'ignoring' the result
09:05:28 <pozic> proppy: but _ has no meaning in the actual semantics of the language.
09:05:34 <pozic> proppy: it is just for humans.
09:05:44 <proppy> pozic: yes, I guess more like a convention
09:05:53 <proppy> like _ means ignoring in a pattern matching context
09:05:59 <pozic> proppy: yes. The M means there is a monad involved.
09:06:03 <dafis> pickles: yes?
09:06:03 <pozic> pickles: the A an arrow.
09:06:23 <pickles> i'm trying to parse a header
09:06:33 <pickles> want to be able to do optional comments before a header line
09:06:42 <pickles> but require the header line before going into the body
09:07:10 <pickles> i'd like the header comments and the header line to be able to have white space at the beginning
09:07:36 <pickles> currently i have: endBy headerComment eol
09:07:50 <pickles> (where eol is the same as defined in the RWH parsec chapter)
09:08:16 <pickles> but this messes parsec up when it gets to he header, because it thinks it's still in the comment portion
09:08:20 <askhader> pozic: I'm really uncertain about what is not correct in that statement.
09:08:28 <applicative> roconnor, haha, i just went back to add "putStrLn path >> "    into select places, and the obvious emerged ....
09:08:34 <pickles> was wondering if anyone might point me to a different way of going about it
09:08:52 <applicative> roconnor, typically dim, since some of the other examples people posted of course did that. 
09:08:53 <pozic> askhader: well, there are no statements in Haskell. 
09:09:07 <askhader> Right.
09:09:13 <dafis> pickles: if lines can start with whitespace, a try might be needed
09:09:22 <Saizan> askhader: foo x:xs is parsed as (foo x):xs
09:09:26 <pozic> askhader: replace parts by undefined until it works.
09:09:35 <askhader> undefined? sorry?
09:09:36 <pickles> dafis: yeah, i figured that would be, but am unsure how to combine that with the endBy
09:09:49 <pozic> askhader: undefined is a term which will always compile. 
09:09:58 <askhader> Ah
09:10:03 <pozic> askhader: then you add the types you believe those terms should have.
09:10:14 <pozic> askhader: So, (undefined::[Int]) for example
09:10:26 <dafis> pickles: wouldn't just many headerComment before parsing the actual header work?
09:10:30 <pozic> askhader: then you later fill in terms with that type. 
09:10:34 <propAWAY> which model do you recommends to connect to mysql ?
09:10:37 <fxr> pickles: are you implementing a specific RFC? or a custom protocol?
09:11:00 <pickles> dafis: hm.. hadn't thought of that, let me try it
09:11:15 <pickles> fxr: custom
09:11:51 <propAWAY> hsql sounds nice
09:12:47 <pickles> dafis: nope, didn't like it
09:13:12 <askhader> Saizan: So my grouping is the issue?
09:13:44 <dafis> pickles: a bit more info about the format, comments start with a comment marker (after optional whitespace) and extend to the end of the line?
09:14:04 <pickles> dafis: correct
09:14:20 <dafis> pickles: many (try headerComment) ?
09:14:24 <pickles> that optional whitespace isn't part of the comment though
09:14:30 <pickles> maybe it should be...
09:14:38 <pickles> hm, ill try that variation too
09:14:40 <dafis> pickles: gotta go cooking now
09:15:15 <Saizan> askhader: yeah, you don't want to pass x as an argument to compress
09:15:29 <Saizan> askhader: you want to pass it (x:ys)
09:15:38 <Saizan> askhader: same with (y:ys) above
09:15:52 <askhader> Yes I figured it
09:15:54 <askhader> Thanks sir =]
09:16:19 <pozic> askhader: did my advice help? 
09:16:28 <pozic> askhader: or was it too advanced? 
09:16:32 <Saizan> prefix application always takes precedence over infix, except for unary minus
09:16:41 <pickles> dafis: yeah, many (try headerCommentLine) worked, thanks!
09:16:49 <pickles> dafis: enjoy your meail :)
09:17:21 <roconnor> applicative: okay, I seem to have a working version now
09:19:26 <roconnor> applicative: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28023#a28023
09:21:17 <applicative> roconnor, mine is sort of working -- but is breaking on some of these hiddn osx system files.  just a sec. 
09:23:37 <roconnor> BMeph: coapplicative functors do exist! -- http://comonad.com/haskell/categories/dist/doc/html/categories/Control-Category-Functor-Applicative.html
09:28:50 <propAWAY> Hi, I got *** Exception: malloc: resource exhausted (out of memory) when doing a select inside ghci, I guess I should switch to lazy reading ?
09:29:28 <propAWAY> it is wierd because I got out of memory even if I put limit 1 at the end of the query
09:32:50 <zygoloid> propAWAY: you're doing SQL queries in ghci? which library are you using?
09:33:03 <propAWAY>  Database.HDBC Database.HDBC.MySQL
09:34:21 <zygoloid> i'm guessing it's an HDBC bug of some sort. looks like that's CosmicRay's package
09:35:29 <proppy> zygoloid: should I report it somewhere ?
09:37:15 <zygoloid> probably, no idea where though. you could @tell CosmicRay
09:38:24 <proppy> CosmicRay: ping
09:41:32 <Taejo> Axman6: you say "A co-routine (called a вЂgeneratorвЂ™ in Python) is where you create two interleaved flows of control on a single thread." -- but isn't a Python generator just a lazy list?
09:42:22 <c_wraith> yes.  but lazy execution is "every control flow is interleaved on demand"
09:43:28 <Taejo> c_wraith: I'm trying to understand why one needs to implement coroutines in Haskell. I don't think I understand what a coroutine is, but if it's a Python generator, then Haskell already has them
09:44:08 <c_wraith> coroutines are just a more limited form of lazy evaluation.
09:45:44 <Taejo> ah, well his example shows one thing that makes it different to python (unless Python has this feature and I didn't know it) -- yield returns something\
09:45:59 <c_wraith> that's how generators work in python, yes
09:46:14 <Taejo> no, I mean you can say "x = yield y"
09:46:28 <c_wraith> oh, on that end.
09:46:34 <c_wraith> Yes, I think they do work that way.
09:46:53 <c_wraith> And when you stretch coroutines that direction, you basically have continuations.
09:47:21 <ozamosi|netbook> This whole haskell thingy is making me mad. Reading "yield returns something" makes me think "hm, what properties does the Something type have? вЂ¦wait, there isn't one."
09:47:27 <Taejo> ah, yes, they are in http://www.python.org/dev/peps/pep-0342/
09:49:01 <conal> i remember reading an article about the unix philosophy, saying that doug mcilroy (invented pipes) knew that pipes coroutines & lazy evaluation were interchangeable.
09:55:26 <applicative> roconnor, indeed. It's looking like it compiles down to the same as dolio's du, unsurprisingly.   I fixed my winterk.hs -- I also wasn't taking account of (</>)
10:04:24 <Philonous> Suspiciously my code type checks suddenly. How do I find the error?
10:10:50 <benmachine> Taejo: perhaps a difference between laziness and coroutines is that the latter can be impure - maybe they're more like iteratees?
10:11:18 <lll> any1 here?
10:11:35 <Taejo> benmachine: that seems to be it. I was just thrown out by the Python reference -- but that was a hole in my Python
10:12:25 <benmachine> I hope lll enjoyed their 29-second stay in #haskell
10:15:31 <Philonous> @type any1
10:15:32 <lambdabot> Not in scope: `any1'
10:16:26 <roconnor> applicative: how do you test to see if it compiles down to dolio's code?
10:26:43 <justin_> How can make a function that dynamically instantiates a record based upon a [(String,String)] map?
10:26:53 <mauke> manually
10:27:07 <justin_> no other way?
10:27:29 <danderson> maybe some template haskell magic, but otherwise no
10:27:42 <justin_> that's pretty awful :(
10:27:44 <danderson> but that's still at compile time, not runtime
10:28:04 <justin_> how does read do it then?
10:28:09 <mauke> manually
10:28:20 <danderson> each type has an instance of the Read type class
10:28:25 <danderson> which constructs the appropriate object
10:29:19 <justin_> that makes for some pretty awful api's
10:29:36 <danderson> you could build your own type class
10:29:44 <danderson> which takes a [(String, String)] and constructs types
10:29:54 <danderson> ie. do what read does
10:29:58 <justin_> i'd like it to be generic
10:30:06 <danderson> it will be generic.
10:30:30 <danderson> a single function will decode all types which are instances of this type class
10:30:57 <danderson> that won't magically make all objects instances of your type class, but since no all types have record definitions, that seems to make sense
10:32:02 <justin_> ok so I could make a data Person = Person { firstName::String; lastName :: String } deriving (MyClass)
10:32:07 <mauke> no
10:32:12 <danderson> no
10:32:21 <c_wraith> If you're willing to abandon the "haskell record" part, you could dynamically construct Label (from the fclabels package) instances for association lists or maps.
10:32:32 <danderson> deriving (MyClass) assumes that the compiler knows how to create an instance of the type class
10:32:43 <danderson> which it does for things like Eq, Ord, Show, Read... in the simple cases
10:32:56 <c_wraith> Oh, you're talking about types, not values.  nevermind
10:33:16 <portnov> class SomeClass a 
10:33:16 <portnov> data SomeData m a = SomeData m a
10:33:16 <portnov> data I m = (SomeClass a) => I (SomeData m a)
10:33:22 <v0|d> fxr: re
10:33:22 <portnov> what is the error?
10:33:34 <danderson> you'd have to do something like Person = Person { firstName :: String; lastName :: String}; instance MyClass Person where construct = ...
10:33:38 <portnov> ExistentialQuantification is on.
10:33:45 <justin_> i'm looking for a way to instantiate records like the above without having to manually write it out
10:34:02 <danderson> you may be able to macro it away in Template Haskell, if you're willing to use that.
10:34:26 <justin_> my ideal api would be a bit like read
10:34:32 <portnov> it complains "Not in scope: type variable `a'" :/
10:34:33 <danderson> TH will get the AST defining your type, so it can introspect on the field names and such, and generate the instance code for you
10:34:53 <mauke> portnov: data I m = forall a. (SomeClass a) => I (SomeData m a)
10:35:03 <portnov> ahh, forgot forall!
10:35:09 <portnov> mauke: thanks :)
10:35:13 <danderson> so you'd have to write just the one function, a TH macro that takes a type and auto-implements the type class instance.
10:35:36 <justin_> yeah, sounds like what I'm looking for
10:36:09 <danderson> then you should head over to http://www.haskell.org/haskellwiki/Template_Haskell
10:36:41 <danderson> do note that TH is an extension to Haskell98, which I believe limits your choice of compiler to GHC
10:36:50 <danderson> usually not too much of an issue, but just in case.
10:37:02 <justin_> it shouldn't be for me
10:37:10 <justin_> though in the future will haskell be moving to llvm?
10:37:19 <dafis> pickles: Great that it worked. And I enjoyed my meal. :D
10:37:22 <danderson> justin_: GHC will
10:37:49 <justin_> danderson: that won't pose any problems for things like template haskell will it?
10:37:53 <danderson> nope
10:38:08 <danderson> LLVM is an implementation detail of the compiler.
10:38:15 <justin_> danderson: not an issue for me then, thanks for the help
10:38:26 <justin_> danderson: hopefully I can figure out template haskell
10:38:30 <danderson> GHC with LLVM support first compiles your source (with all fancy extensions etc.) into a low level internal representation
10:38:38 <danderson> and then translates that to LLVM to let LLVM optimize the crap out of it.
10:39:14 <justin_> i wasn't really sure what ghc compiled down to in the first place
10:39:24 <justin_> thought it might be c or something
10:39:26 <danderson> depends
10:39:44 <Taejo> currently it can compile via C
10:39:48 * OCboy 1is away
10:39:51 <Taejo> though that might go out of the window
10:40:26 <danderson> the common part of the pipeline is: Haskell gets translated to Core, then to STG and then Cmm
10:40:41 <danderson> each intermediate language is lower level than the previous one, and optimization passes are applied at each level
10:41:21 <danderson> then one of 3 backends turns the Cmm into machine code (either an object file or an executable)
10:41:28 <c_wraith> currently, there's a final pass that's either Cmm to C, or Cmm to native code.  The LLVM patches add Cmm to LLVM.
10:41:33 <danderson> the historical backend translates Cmm to C, and uses gcc to compile that
10:42:06 <danderson> then there's one that translates Cmm directly to native code, essentially implementing a very small subset of gcc internally
10:42:36 <danderson> and now, there's also the LLVM backend, which translates Cmm to LLVM bitcode, and uses LLVM to optimize that and output native code
10:43:02 <justin_> turtles all the way down it sounds like :)
10:43:14 <danderson> but getting back to the original question: you're programming in Haskell, which is 4 or 5 levels removed from the LLVM work
10:44:03 <danderson> yeah, in a sense. The many layers exist to make each layer simple, rather than have one huge monolithic Haskell -> Cmm mess
10:44:30 <danderson> in the same way that gcc translates from C to GIMPLE to assembler to machine code
10:44:35 <danderson> rather than go straight from C to machine code
10:44:43 <conal> is there a fairly easy way to know when new comments show in on a reddit thread?  (ie new since I last visited the page).
10:45:50 <conal> the "everything is a function" conversation continues at http://www.reddit.com/r/haskell/comments/cs3gw/so_im_eating_breakfast_this_morning_posting_about/c0uu70s .  
10:47:56 <roconnor> aren't constats morphisims from the *initial* object ?
10:48:09 <roconnor> constants
10:48:40 <danderson> So, a bit of a brain teaser (at least for me, probably people here will figure it out immediately) : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28028#a28028
10:49:57 <dafis> danderson: with mapM, you get [ByteString] -> IO [a]
10:50:29 <dafis> danderson: to get from that to [BS] -> IO a is tricky (hint, what about [])
10:51:45 <dafis> gah, mucked up the types :(
10:51:46 <zygoloid> roconnor: yeah, if i had a reddit account i'd have mentioned that ;-)
10:52:00 <McManiaC> http://npaste.de/dn/ the most complicated 2+3 ever
10:52:00 <McManiaC> :D
10:52:02 <zygoloid> though technically you could view them as either
10:52:21 <roconnor> zygoloid: huh?
10:53:17 <danderson> dafis: I don't see it. Given the signature of useAsCStringLen, I need to stack the functions atop one another
10:53:24 <danderson> which makes me think of a fold
10:53:39 <danderson> I just need to figure out the initial value and accumulation function
10:53:42 <dafis> danderson: yes, got the types wrong
10:53:44 * roconnor kinda things dandersons problem has no natural solution.
10:53:55 <roconnor> thinks
10:54:39 <zygoloid> roconnor: morphisms to the terminal object are isomorphic to values, as are morphisms from the intiial object. iirc the blog post said morphisms /from/ the terminal object (which there's only one of, id)
10:55:22 <roconnor> "morphisms to the terminal object are isomorphic to values"    really?
10:55:44 <roconnor> I don't believe that.
10:56:16 <roconnor> given a set X and a function from X -> {}, you say this picks an element of the set X?
10:56:26 <Parkotron> I have a list of values and a predicate function that will return true or false for each value. What's the cleanest way to get the number of values for which the function returns true? "length . filter"?
10:56:57 <Tomsik> roconnor: X -> {} is not a function in cantor's sense
10:57:12 <Tomsik> I mean, X x {} is empty
10:57:21 <roconnor> Tomsik: not if X is empty
10:57:23 <askhader> This function is meant to transverse a list and place consecutive duplicate elements into a nested list. For example.  pack [2,3,3,5,3,3,3,6] -> [[2], [3,3], [5], [3,3], [6]]  but I seem to have something wrong. Could someone take a look? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28029#a28029
10:57:41 <roconnor> Tomsik: but yes, there may be no arrows from X to {}
10:57:44 <Tomsik> roconnor: "given a set X", is equivalent to "forall X ." :p
10:57:46 <roconnor> which is my point.
10:58:29 <roconnor> oh crap
10:58:29 <zygoloid> roconnor: hmm. i think maybe i'm muddling values and objects
10:58:33 <roconnor> zygoloid: my bad
10:58:37 <roconnor> I'm screwed up
10:58:42 <roconnor> {} is the initial object
10:58:48 <roconnor> {*} is the terminal object (in set
10:59:08 <roconnor> so Thrawcheld was right
10:59:25 <roconnor> values are morphisms from the terminal object to X.
10:59:52 <zygoloid> roconnor: huh! :)
11:00:30 <dafis> danderson: if you don't mind getting dirty, bsToCSL :: ByteString -> IO CStringLen is pretty easy to implement, then mapM bsToCSL bss >>= (f :: [CStringLen -> IO a)
11:01:20 <dafis> danderson: and it's not very dirty, you just have to use ByteString's constructor
11:04:07 <danderson> useManyAsCStringLen strs act = let combine f b csls = useAsCStringLen b (f . (:csls)) in foldl combine act strs []
11:04:12 <danderson> I think that does what I want.
11:06:03 <danderson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28028#a28030
11:06:11 <danderson> nicer version, with more comments and type signatures.
11:06:39 <danderson> I can't quite figure out if the list of CStringLens is going to end up reversed or not
11:06:50 <danderson> I can never keep my foldl/r straight
11:07:23 <dafis> askhader: first, you want the type [a] -> [[a]], thus you can't have f (x:xs) = [x] ++ f xs as in the otherwise branch
11:07:39 <dafis> danderson: foldl will reverse the list
11:08:27 <dafis> askhader: and in the case of (x:y:zs) | x == y, you want to have x and y in the same group
11:08:41 <danderson> ah, so, foldr it is.
11:09:38 <danderson> dafis: that said, just using Data.ByteString.Internal and hacking up the CStringLens by hand will probably have better performance.
11:09:50 <zygoloid> roconnor: of course, morphisms from the initial object are isomorphic to objects in the category, not to values within those objects :)
11:09:58 <dafis> askhader: so, you want to do something to the first group in f (y:zs) then
11:10:16 <dafis> danderson: probably
11:11:23 <danderson> hmm, and actually, I don't need nul-terminated C strings, just ptr+len buffers
11:11:26 <askhader> dafis: Interesting, thanks
11:11:38 <danderson> so using the constructor will also save a memcpy per string
11:13:24 <danderson> ah, but I end up with the same need to fold functions, because ForeignPtr -> Ptr uses the same wrapped action API
11:19:07 <Philonous> Is it possible that ghc doesn't derive the most general type (No Rank2Types or other funny stuff involved) ?
11:20:32 <chrisdone> howdy
11:21:02 <conal> chrisdone: hi
11:21:07 <dafis> askhader: I've given a hint on your paste
11:21:16 <chrisdone> conal: how's tricks?
11:21:43 <askhader> dafis: Ahah.
11:21:58 <conal> chrisdone: great.  having fun with a series of blog posts.  how are you?
11:23:02 <chrisdone> conal: good good. working on a conference proceedings peer review web service for work, have a nice monad input validator. what blog posts are you having fun with?
11:23:22 <rajeshsr_> hi all
11:23:25 <EDEROO> hello
11:23:32 <chrisdone> hi ederoo
11:23:57 <rajeshsr_> Although this may be irrelevant i think the people here can help me out
11:24:08 <EDEROO> what is your question?
11:24:20 <EDEROO> hi SirJinLee
11:24:29 <SirJinLee> what channel is this
11:24:30 <SirJinLee> lol
11:24:41 <EDEROO> this is a channel for haskell, a programming language
11:25:01 <danderson> dafis: if you're interested, this is what it ends up looking like: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28028#a28032
11:25:14 <conal> chrisdone: nifty project!  the series is on using functor combinators for trie-based memoization and a new (i think) angle on zippers.  also nonstrict memoization. inspired by an ipad project with infinite, topless quad-trees.
11:25:16 <jedai> SirJinLee : How did you come to this channel ?
11:25:18 <rajeshsr_> http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/ that link uses a regex to test primality. Does it prove a Finite Automaton will test primality. In particular I wonder if "+?" is implementable with automaton..
11:25:30 <danderson> slightly longer because there's less fancy combination going on, but it works out okay.
11:25:38 <conal> chrisdone: a collection of ideas i'm teasing apart into bite-sized chunks.
11:26:45 <chrisdone> conal: looking forward to it, the trie-based memoization sounds neat. i should subscribe to your blog, actually
11:27:08 <dafis> danderson: that looks good
11:27:10 <rajeshsr_> anyone?
11:27:11 <conal> chrisdone: check it out.  three installments so far in this series.
11:27:16 <conal> http://conal.net/blog
11:27:33 <chrisdone> ahh, thanks
11:28:37 <conal> chrisdone: for what company (or whatever) do you work?  and in haskell?
11:29:32 * edwardk waves hello
11:29:32 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:30:27 <edwardk> @tell roconnor its conflict ridden, it says that the only endofunctors you have on a klielsi category are traversable, which isn't the case.
11:30:27 <lambdabot> Consider it noted.
11:30:39 <edwardk> @tell roconnor er Kleisli ;)
11:30:40 <lambdabot> Consider it noted.
11:30:53 <dafis> rajeshsr_: I think you need a cellular automaton (that the correct term?) for that
11:30:55 <flazz> http://hackage.haskell.org.nyud.net/platform/mac.html claims that 64 bit is included but ghc seems to be 32 bit what am i missing?
11:31:28 <jedai> rajeshsr_: no
11:31:33 <rajeshsr_> dafis: am not really sure what cellular automaton has to to do here!
11:32:00 <rajeshsr_> jedai: you mean +? isn't definable with finite automaton?
11:32:01 <jedai> rajeshsr_:  Your regexp contains a backreference and as such is not really a regular expression
11:32:13 <rajeshsr_> ha!! i missed it!!
11:32:23 <dafis> rajeshsr_: count the repetitions, but I'm more or less guessing, trying to recollect what I once new about automata
11:32:42 <dafis> knew*
11:32:59 <rajeshsr_> jedai: so possibly a push down automaton? or is it even deeper?
11:33:37 <chrisdone> conal: CREATE-NET, an italian non-profit research center in Trento, mostly specialising in networking. i'm in the "innovation" department
11:34:16 <askhader> dafis: You use 'pack (y:ys)' as your pattern ?
11:34:29 <dafis> rajeshsr_: I think I meant push-down automaton, now that I see that term
11:34:57 <conal> chrisdone: neat!
11:34:59 <rajeshsr_> dafis: ha, ok! :)
11:36:31 <dafis> askhader: no, I use the result of the recursive call; pack (x:y:ys) = something with x and (pack (y:ys)) if x == y
11:37:16 <dafis> rajeshsr_: it's "Kellerautomat" in German
11:37:26 <dons> edwardk: what was the name of your specializing sets implementatoin?
11:37:29 <dons> i can't find the package name on hackage
11:37:41 <edwardk> unboxed-containers IIRC
11:38:10 <edwardk> dons: started hacking up a newer generalized tries implementation the other day using a simpler concept
11:38:17 <chrisdone> conal: yes =) we need to hire another Haskeller with web dev. experience. we'll be posting an ad in -cafe at some point. the bool memo is neat, fun to see where this goes
11:38:22 <conal> chrisdone: i like the sound of an "innovation department".
11:39:03 <conal> chrisdone: :)  
11:39:26 <BMeph> So, does anyone know what pumpkin is up to?
11:39:45 <chrisdone> conal: me too, hehe. we'll be releasing the peer review software as open source, and a bunch of other things. haskell was partly picked because of its big (and academic) community
11:40:07 <dafis> askhader: you've got a working thing there - now try using takeWhile
11:40:11 <edwardk> dons: as in, just letting you say something like: deriveMap ''MyMap [t| [Either Int b] |] -- to build an optimized map for a given key type
11:40:35 <askhader> dafis: Working? Hardly yet
11:41:06 <edwardk> dons: and taking into consideration the missing functionality needed from Data.Map and Data.IntMap in order to make efficient tries over them
11:41:19 <dafis> askhader: oh, you changed what to do for x /= y, didn't see that
11:41:36 <askhader> I changed nothing o.o;;
11:41:55 <edwardk> BMeph: he was dropping out of a grad program at last check, which likely has involved major life disruption and moving
11:42:05 <dons> unboxed-containers, right
11:42:07 <dafis> askhader: though, that's not the problem, your problem is the [x] case
11:42:23 <askhader> oh?
11:42:24 <dafis> askhader: pack [x] = [[x]]
11:42:40 <edwardk> dons: IIRC i think the way i added the unit tests broke the cabal installation of it
11:42:42 <chrisdone> conal: is your blog fractal? :-)
11:42:52 <askhader> dafis: Oh that breaks stuff
11:42:53 <askhader> Right
11:43:13 <edwardk> i should go pull the current package and re-upload it with a fixed cabal file
11:43:38 <Saizan> BMeph: he went on a vacation across europe
11:43:56 <edwardk> Saizan: must be nice ;)
11:43:57 <dafis> askhader: BMeph posted a (nearly, [x] problem) working version
11:45:32 <BMeph> dafis: Aw, man, now you're giving away my "secrets"... ;)
11:46:07 <dafis> BMeph: you should've told me it's a secret
11:46:20 <conal> chrisdone: i don't know.  is it?  as in the same themes keep arising, the deeper one looks?
11:46:45 <BMeph> dafis: I couldn't do that - it was a SEKRIT!! :D
11:47:00 <dafis> BMeph: PM
11:47:30 <edwardk> dons: one thing i like about the simpler 'deriveMap ''MyMapType [t| key type |] api is that it is always safe. the end user isn't defining instances for types they don't own if you missed one
11:48:14 <edwardk> and it is way less magical than the crazier stuff i was doing with the unreleased versions of unboxed-containers to deal with swizzling values into boxes, etc.
11:49:33 <proppy> it seems that \r is not matched by .*
11:49:35 <chrisdone> conal: more that the more one looks, the more detail there is to find :-) I need to read Associated Types with Class. -- I spent too much time writing Haskell, not enough time reading new papers about it
11:49:44 <proppy> (using Text.Regex.Posix)
11:49:47 <chrisdone> s/spent/spend
11:50:11 <proppy> even thought I used mkRegexWithOpts _ False True
11:50:41 <dafis> proppy: that means . matches '\n', right?
11:50:57 <proppy> yes
11:51:02 <proppy> oups
11:51:06 <proppy> it works
11:51:08 <proppy> *Main Text.Regex Text.Regex.Posix> matchRegex (mkRegexWithOpts "foo(.*)foo" False True) "fooabc\r\nfoo"
11:51:10 <proppy> Just ["abc\r\n"]
11:51:17 <conal> does anyone know where in the haskell report is the explanation of how "f p q r = ..." desugars?  i'd like to reply to a claim that if "f x = x" desugars into "f = \ x -> x", then "f = y" desugars into "f = \ -> y".  http://www.reddit.com/r/haskell/comments/cs3gw/so_im_eating_breakfast_this_morning_posting_about/c0v00bv
11:51:48 <roconnor> > \ -> 5
11:51:49 <lambdabot>   <no location info>: parse error on input `->'
11:51:49 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:52:02 <proppy> oh ok, it is not becauses of \r but because of \2xx characters 
11:52:21 <proppy> are [Char] ascii ?
11:52:28 <chrisdone> conal: what would you call ``\ -> x''?
11:52:47 <conal> chrisdone: a syntax error.
11:53:09 <aavogt> and itself desugars into    f = \ -> \ -> y
11:53:09 <roconnor> edwardk: Because of the fun deps?
11:53:12 <aavogt> and so on
11:53:38 <dafis> proppy: Char is a unicode codepoint
11:53:40 <conal> aavogt: that's what i keep thinking, with these claims that non-functions are constant functions.
11:53:58 <conal> may work out for first-order disciplines but probably not for higher-order
11:54:29 <dafis> conal: I think section 3 is the place to look, but I didn't yet find anything authoritative
11:54:32 <aavogt> that's how you do lazy evaluation in strict languages
11:54:36 <proppy> dafis: but when reading something from a dabatabse I get \233 instead of accented characters, and they don't match '.' in a Regexp
11:54:41 <proppy> did I miss a conversion step ?
11:55:04 <conal> dafis: thx.  or maybe section 4.  i haven't found it yet either.
11:55:08 <aavogt> (if you think ()  is the same as 0 arguments)
11:55:10 <proppy> I used fromSql :: [[String]] in order to get a String for an SqlValue
11:55:11 <dafis> proppy: the Show instance for Char escapes all characters above '\127'
11:55:57 <dafis> proppy: so if it's shown as \233 that's okay, it is the accented letter
11:56:51 <jmcarthur> conal: that actually isn't just sugar
11:56:53 <proppy> dafis: do you know if ".*" should match > \127 characters too ?
11:57:15 <jmcarthur> conal: at least in ghc, it will treat f = \x -> y as a CAF, but not f x = y
11:57:20 <dafis> proppy: if they don't match ., that's probably due to the regex lib using ByteStrings (as CStrings), so you should utf-8 encode the strings to ByteStrings if the lib doesn't
11:57:50 <conal> jmcarthur: really??  i'm skeptical.
11:57:52 <dafis> proppy: methinks . should match any character (except possibly newlines)
11:58:09 <proppy>  matchRegex (mkRegexWithOpts "foo(.*)foo" False True) "foo\233abc\r\nfoo"
11:58:10 <jmcarthur> conal: it doesn't affect haskell semantics, i don't think
11:58:11 <proppy> Nothing
11:58:13 <conal> jmcarthur: i mean i'm skeptical about there being any operation difference in ghc.
11:58:21 <proppy> but
11:58:24 <proppy> matchRegex (mkRegexWithOpts "foo(.*)foo" False True) "fooabc\r\nfoo"
11:58:26 <proppy> Just ["abc\r\n"]
11:58:35 <proppy> dafis: thanks I will try to figure out how
11:58:53 <dafis> proppy: package utf8-string
11:59:05 <chrisdone> I tend to think of non-functions as terms, and all top-level definitions are О»-abstractions in which the free-variables are ОІ-reduced using the appropriate top-level definitions as terms. this probably makes no sense
11:59:20 <dafis> proppy: but let me check the regex lib first, which are you using?
11:59:39 <proppy> import Text.Regex
11:59:40 <roconnor> conal: you mean no difference beyond type inference and the stupid monomorphism restriction?
11:59:41 <proppy> import Text.Regex.Posix
11:59:46 <proppy> dafis: ^
12:00:05 <dafis> proppy: k, hang on a minute
12:00:06 <conal> roconnor: no.  i completely forgot about the monomorphism restriction here.
12:00:27 <proppy> it seems there is
12:00:30 <proppy> * regex-tdfa-utf8
12:00:32 <proppy>     Synopsis: This combines regex-tdfa with utf8-string to allow searching over
12:00:34 <proppy>               UTF8 encoded lazy bytestrings.
12:00:51 <fryguybob> conal: maybe at the end of 4.4.3.1?
12:01:24 <Taejo> am I right in guessing that most functions Integer->Integer grow faster than the ackermann function?
12:01:37 <Taejo> would try to prove it, but I'm in a rush
12:01:48 <Taejo> and trying to make a snappy reddit comment
12:02:23 <chrisdone> Reddit Ruins Livesв„ў
12:02:31 <Taejo> yep
12:02:55 <conal> frguybob: thx.  that's as close as i've seen.  i'm not seeing where the number of parameter patterns must be >= 1.
12:03:01 <roconnor> conal: ya, the monomorphism restriction will certainly make type inference behave differently between the two examples
12:04:21 <conal> hm.  looks like the report is mistaken here, in not saying >=1 parameter patterns.  
12:04:42 <fryguybob> idecl	в†’	(funlhs | var) rhs ?
12:05:00 <conal> worse yet, the report's mistake (if so) agrees with winterkoninkje's remark at http://www.reddit.com/r/haskell/comments/cs3gw/so_im_eating_breakfast_this_morning_posting_about/c0v00bv
12:06:55 <BMeph> Interesting - so is "whole number" the new "positive integer" now?
12:07:33 <BMeph> (In ref: http://www.reddit.com/r/haskell/comments/cs3gw/so_im_eating_breakfast_this_morning_posting_about/c0uwvt7# )
12:08:00 <roconnor> BMeph: that's the opposite of what I learned in high school.
12:08:08 <roconnor> ... not that high school counts for much.
12:08:37 <BMeph> Sorry, ref should be: http://www.reddit.com/r/haskell/comments/cs3gw/so_im_eating_breakfast_this_morning_posting_about/c0uxj8s
12:08:45 <dafis> proppy: the String interface uses Foreign.C.String.withCAString, which, afaict, truncates characters to 8 bits; that shouldn't meddle with \233, thought, only with characters > \255
12:09:25 <conal> okay.  i added a reply (see my previous link).
12:10:11 <aavogt> maybe you're just angry that people seem to be directly translating "everything is an object"
12:10:15 <djahandarie> I just say nonnegative integers and positive integers, lol
12:10:15 <proppy> dafis: thanks for the confirmation
12:10:26 <proppy> dafis: I'm trying to use import Text.Regex.TDFA.UTF8
12:10:38 <dafis> proppy: good luck
12:10:41 <conal> it is a bit of an odd inconsistency that we cannot say "\ -> 3" to mean simply "3".  at least not in ghci.
12:10:45 <Taejo> the correct translation of "everything is an object" into Haskell is "everything is a value"
12:10:53 <aavogt> that statement doesn't mean much either though
12:11:05 <proppy> but I get http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28036#a28036 when importing it in addition of Text.Regexp
12:11:10 <conal> Taejo: amen!
12:11:13 <Taejo> aavogt: and nor does Python's everything is an object
12:11:22 <Taejo> because it doesn't define thing
12:11:23 <chrisdone> Taejo: what's the difference between an object and a value?
12:11:25 <jmcarthur> i think Taejo is on to something
12:11:36 <conal> which is why i prefer "value-oriented programming" over "functional programming".
12:11:54 <aavogt> type classes and modules aren't first-class values
12:11:58 <conal> though my strong favorite is peter landin's recommended replacement: "denotative programming".
12:12:12 <aavogt> so I dunno how useful they are as 'values' to you
12:12:25 <jmcarthur> "in haskell, everything is a value, even functions" rather than "in haskell, everything is a function, even values"
12:12:40 <conal> jmcarthur: exactly!
12:12:47 <aavogt> odd functions are not values
12:12:48 <aperson4> is anyone here good with java? i need to convert a short to a hex string
12:13:01 <jmcarthur> odd functions?
12:13:05 <dafis> proppy: import qualified
12:13:06 <mauke> aperson4: do you have a Haskell question?
12:13:12 <mauke> aperson4: then why did you join #haskell?
12:13:26 <aperson4> my bad
12:13:29 <aperson4> wrong room
12:13:33 <Taejo> aavogt: true; in Python one can at least say "everything with a name is an object"
12:13:55 <aavogt> jmcarthur: a pun
12:14:07 <aavogt> it's not true either
12:14:31 <jmcarthur> you're right about type class and modules... *unfortunately*
12:14:35 <conal> and yet this "everything is a function in haskell" is a persistent myth.  i suspect it's a good example of the difference between reason & rationalization, i.e., between means for arriving at a belief and means for hanging onto one.
12:14:39 <roconnor> chrisdone: I use objects and values as synonyms.  Lately I've been trying to stick with values because OOP makes people think that objects are things with state.
12:15:06 <roconnor> chrisdone: though I still use "objects" in the term "proof objects"
12:15:19 <roconnor> I can't yet bring myself to say proof values
12:15:24 <jmcarthur> and types, while we're at it. i suppose you could view types as values that are only valid at the type level rather than the term level though
12:15:27 <conal> maybe one might say "a value is an immutable object".  at least when talking to OOPers.
12:15:55 <jmcarthur> conal: i'd be careful about telling an OOPer that anything is an object. there are so many definitions
12:15:56 <conal> although only hard-core OOPers would include bits & numbers & functions in their notion of "object"
12:15:58 <roconnor> ... things with state and identity
12:16:20 <jmcarthur> some focus on message passing, some focus on encapsulation, some focus on data and functions being together, etc.
12:16:27 <conal> jmcarthur: yeah.  probably begging for misunderstanding
12:16:44 <roconnor> I guess in OOP two immutable object with the same value can have distinct identities
12:17:07 <jmcarthur> roconnor: we could have chosen to do the same in haskell, but thankfully we didn't
12:17:26 <BMeph> roconnor: Hmm, I think I may have just parsed the sentences wrong...re-reading...
12:17:26 <aavogt> ghc can do the same no?
12:17:32 <roconnor> jmcarthur: thank goodness
12:17:51 <jmcarthur> aavogt: i suppose so, but it's consider unsafe, or at least stuck in IO
12:17:54 <chrisdone> roconnor: I came to the conclusion that values are immutible objects
12:17:55 <jmcarthur> *considered
12:18:00 <conal> hm.  so "everything is a value" (in haskell) has some serious faults: including that it doesn't define "thing" or "value".  
12:18:09 <aavogt> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Mem-StableName.html
12:18:16 <roconnor> chrisdone: it's close, but there is this issue with identity.
12:18:16 <chrisdone> roconnor: actually I didn't conclude that, I just decided. what do you think?
12:18:24 <jmcarthur> conal: every term-level identifier is a value?
12:18:32 <jmcarthur> or represents a value
12:18:40 <jmcarthur> whatever "value" is
12:18:42 <chrisdone> roconnor: well, an object is something with identity. a value is an immutible one. no?
12:18:44 <conal> jmcarthur: yeah -- *denotes* a value.
12:18:47 <jmcarthur> yes
12:18:54 <roconnor> chrisdone: in haskell values don't have identity
12:18:58 <jmcarthur> heh, "every term is a term"
12:19:01 <roconnor> identities
12:19:05 <BMeph> conal: I notice that in your discussions that you not only love to operate (heh-heh) from a denotational semantics view, but it catches you by surprise when others' semantic views are operational instead. :)
12:19:25 <conal> BMeph: yes.  i have to get reminded over & over.  
12:19:33 <chrisdone> roconnor: hmm. how are you defining ``identity''?
12:20:35 <roconnor> chrisdone: I don't know, it is some basic operation in OOP, typically decided by the = function.
12:20:41 * fryguybob I know x is a function because it makes my computer hotter...
12:20:42 <conal> i don't know how to confidently say we don't have "identity".  since i think of equality as our identity.  and that it must correspond with denotational equality, or we've created an abstraction leak.
12:21:31 <BMeph> So "Identity" == "Universal Equality"?
12:22:03 <jmcarthur> our terms have value equality and not reference equality
12:22:23 <jmcarthur> eh
12:22:24 <roconnor> in a some sort of abstract OOP language you could write a := new 5, b := new 5, and a and b would be two different imutable objects of the same value.
12:22:36 <conal> jmcarthur: maybe because we don't have reference
12:22:45 <BMeph> (universal in the sense  that any thing may be tested to any other thing)
12:22:50 <jmcarthur> conal: aside from IORef, of course, which does have an Eq instance ;)
12:23:04 <BMeph> Er, tested *with
12:24:21 <conal> jmcarthur: i don't know if we can make any well-behavedness/rigor claims for IO.  i don't think it's part of denotative programming.
12:24:25 <chrisdone> roconnor: does identity have to be expressible within the language? i mean, you can give something identity by simply naming it, right? then it is an object
12:24:31 <conal> jmcarthur: the current haskell notion of IO, that is.
12:25:14 <jmcarthur> conal: the value of an IORef is really its identity, which makes sense in our framework. the only unusual thing is that the IORef originates from IO
12:26:04 <roconnor> chrisdone: yes, but if you added a name tag in haskell you'd have some sort of record structure and the two records would have different values.
12:26:08 <chrisdone> roconnor: i.e. let x = 1; y = 2; -- x and y are distinct objects. they're objects because they are identified
12:26:12 <conal> jmcarthur: do you have a denotational model in mind for IORef?  i don't.
12:26:31 <chrisdone> roconnor: hmm. maybe i don't know what i'm talking about. nevermind
12:26:45 <jmcarthur> conal: i don't for the IO functions
12:27:20 <chrisdone> roconnor: (I meant to write let x = 1; y = 1;, fwiw)
12:27:40 <jmcarthur> from a pure standpoint, it's just a "name" i guess
12:27:54 <jmcarthur> not really a model
12:27:57 <conal> jmcarthur: ah.  and those functions would have to be explainable in the (hypothetical) denotational models of IORef and IO. 
12:28:06 <jmcarthur> yes
12:28:45 <conal> jmcarthur: (in a denotative setting)
12:28:48 <roconnor> chrisdone: in that case x and y are the same value.
12:29:55 <conal> i'm really appreciating Landin's replacement of "functional" with "denotative".  it makes a qualitative distinction between the "pure" parts of Haskell vs things like IO and STM.
12:30:06 <jmcarthur> conal: we wouldn't need a model for IO. we could just say we only care about the IORef subset of IO
12:30:13 <jmcarthur> and ignore concurrency... :(
12:30:14 <applicative> if an IORef didn't have identity , how could we  do something like: do {ref <-newIORef x  ; ... ref ....; ... ref ...  ; ... ref...  }
12:30:20 <chrisdone> roconnor: well, there I'm not even considering what ``value'' means. just what ``object'' means, i.e., something with identity. it's distinct from something else. e.g. 1 and 1 are not distinct, but x and y. is this mumbo jumbo or do you know what I mean?
12:30:36 <bvck> Hi folks, quick question on Monoid (a -> b) declaration for function mappend.
12:30:53 <bvck> This is what I see mappend f g x = f x `mappend` g x
12:31:01 <applicative> it is the re-use of pronouns that contains it.  
12:31:06 <jmcarthur> my proposal would of course require a new monad just for IORef
12:31:10 <conal> jmcarthur: you'd still have to reconcile the IORef subset of IO with a fuller subset if you want to explain the meanings of typical imperative haskell programs.
12:31:19 <bvck> But the type declaration for mappend is mappend :: a -> a -> a
12:31:21 <roconnor> chrisdone:  let x = 1; y = 2 -- did you intend for this to be haskell-like?
12:31:28 <aavogt> jmcarthur: ST
12:31:29 <bvck> That is it is taking two parameters.
12:31:40 <jmcarthur> aavogt: yeah
12:31:43 <chrisdone> bvck: surely mappend f g = g . f?
12:31:48 <mauke> chrisdone: no
12:31:55 <aavogt> bvck: put (x -> y)  where a is
12:31:55 <chrisdone> uh, no
12:31:57 <mauke> chrisdone: that's a type error
12:31:57 <bvck> That is what I would have thought, chrisdone.
12:32:08 <aavogt>   mappend :: (x -> y) -> (x -> y) -> (x -> y)
12:32:17 <chrisdone> yes
12:32:33 <mauke> bvck: mappend f g = \x -> f x `mappend` g x  -- better?
12:32:47 <bvck> mauke, got it. Thanks.
12:32:53 <jmcarthur> conal: i meant by imposing limitations on IORef that aren't there already like ST does, which makes it no longer IORef in the first place of course
12:33:43 <conal> jmcarthur: yeah.
12:34:10 <conal> we can define a toy subset of haskell imperative programming and give a precise denotation to that toy subset.
12:34:17 <jmcarthur> right
12:34:21 <jmcarthur> that's exactly what i meant
12:34:31 <conal> and still haskell IO programming will not be denotative.
12:34:33 <jmcarthur> IO is a killer
12:35:06 <chrisdone> roconnor: sorry, in the general; whatever language, or forgetting languages all together. 1 has identity distinct from 2. let x be 1 and y be 1, x and y are distinct objects. no?
12:36:09 <roconnor> chrisdone: I think that statement has significatnly different meanings between Haskell and typical languages
12:36:28 <chrisdone> (forgetting languages all together...)
12:36:43 <applicative> conal, When was the type IORef introduced?  Are there papers from that time about the subject? 
12:37:10 <nolrai_portland> @hoogle lift
12:37:10 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
12:37:10 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
12:37:10 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
12:37:21 <bvck> Second question folks, how do I achieve something like this..pseudo-code at http://codepad.org/9edZvPLA
12:37:24 <dafis> chrisdone: x and y are different names for the same object?
12:37:26 <conal> applicative: i don't recall.  i imagine it came in with IO.
12:37:49 <nolrai_portland> @hoogle mzero
12:37:49 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
12:39:20 <askhader> Yet again I fail to see the issue here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28040#a28040
12:39:26 <chrisdone> roconnor: well, I suppose you should come up with a definition of what identity means and object means and identitying where they appear in languages is easier, rather than working the other way round
12:40:45 <chrisdone> dafis: so what's an object?
12:41:29 <dafis> askhader: the case pack [x] = [x] and pack (x:xs) .. | otherwise = [x] ++ pack ... don't match the type of pack (x:xs) = [x] : pack ...
12:41:41 <dafis> chrisdone: I don't know
12:41:45 <lispy> Why is it so hard to get things to build with the version of base that you ask for
12:42:20 <applicative> conal, that we can't name any value of type IORef is a bit strange,  but it's just that we can't do it in a module.  The application might involve naming  during the execution.
12:42:39 * lispy gets frustrated at cabal
12:43:12 <dafis> askhader: give type signatures to your functions, then perhaps the error messages clear some things up
12:43:27 <travisbrady> Is there some way to create a Data.Map with a custom ordering function ala Ocaml's Map.Make?  I'd like a Map sorted in descending order
12:43:47 <roconnor> chrisdone: I guess it is true that identity is a little less useful for immutable objects, which is partly why haskell values have no identity
12:43:49 <lispy> travisbrady: one way is to use a newtype wrapper
12:44:05 <roconnor> chrisdone: normally identity is used to know which object is update when the state is changed
12:44:31 <dafis> lispy: what's your frustratin with cabal? does it insist on base-3?
12:44:31 <roconnor> chrisdone: but even with immutable objects you can still compare object identites and branch on them in a typical OOP language
12:44:34 <travisbrady> lispy: would you paste a small example?  I'm not sure how that would be done.
12:44:42 <lispy> dafis: yes
12:44:49 <cydergoth> Hi all, thx for the help yesterday. I have another (hopefully) quick question. If I have a 'where' clause, then the order of execution of statements in the where clause is undefined right? Is this still true if there is an implicit dependency on a binding in one statement which depends on the binding in another statement?
12:44:59 <lispy> travisbrady: have you used newtype before?
12:45:04 <nolrai_portland> Is there a short hand for (>> return ())
12:45:05 <askhader> dafis: Why should  pack [x] = [[x]] - if x is going to be appended to the result, then that means it was identical to the element before it, in which case it should be [x], and if it will be cons-ed with the result, that means it was not identical and it should be a list containing the element 'x'
12:45:10 <dafis> lispy: no upper bounds on base in the .cabal, I presume?
12:45:22 <roconnor> cydergoth: all binding in a where clause are mutually recursive
12:45:27 <askhader> Oh I see, the problem.
12:45:27 <travisbrady> lispy: I have, but I'm not certain how using newtype would change the default ordering of Data.Map
12:45:28 <Philonous> nolrai_portland: None that I know of, I tend to name it ignore
12:45:33 <askhader> It does not conform to the signature
12:45:36 <lispy> dafis: yes.  Although, on my mac (at home) this package is built against base 4 an here on this machine it insists on base3
12:45:36 <conal> applicative: the nameability issue isn't important to me.
12:45:47 <cydergoth> roconnor: so the binding order is automatically resolved?
12:45:52 <dafis> lispy: which package?
12:45:55 <conal> and i suspect it's a red herring w.r.t. notions of identity.
12:45:56 <roconnor> > let x = a where {a = 1:b ; b = 1 : a} in x
12:45:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:46:00 <roconnor> > let x = a where {a = 1:b ; b = 2 : a} in x
12:46:01 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
12:46:14 <lispy> travisbrady: When you create a newtype you have to provide instances for things.  You could jsut invert the underlying type's Ord instance
12:46:15 <roconnor> cydergoth: no, they are mutually recursive
12:46:24 <Philonous> nolrai_portland: I've heard others who said they use ignoreM. It really should be in some standard library, though, but it isn't, I'm afraif
12:46:26 <lispy> dafis: attoparsec-0.8.0.2
12:46:32 <travisbrady> lispy: d'oh! yes, thank you
12:46:56 <cydergoth> rconnor: in my case there is a single directed dependency, so the correct value will be substituted in the binding? 
12:48:10 <roconnor> cydergoth: sure, that will effectively happen
12:48:10 <chrisdone> cydergoth: so in ``x = .. where y = 1; z = 2'', ``..'' is evaluated first. if it references y at some point that needs to evaluated, it will evaluate y. same for z
12:48:11 <cydergoth> roconnor: Hmmm, referential transparency should mean it doesn't matter right? The statement will evaluate to the same, no matter when it is invoked
12:48:20 <roconnor> cydergoth: correct
12:48:35 <roconnor> cydergoth: put evaluation order out of you mind
12:48:45 <roconnor> in haskell it (mostly) doesn't matter
12:48:49 <cydergoth> roconnor: This obviously doesn't hold in do statements with ordering in e.g. IO Monad right?
12:49:11 <roconnor> binding in do statements are ordered
12:49:16 <Philonous> cydergoth: It does, evaluation != execution
12:49:17 <shachaf> cydergoth: That's not evaluation order so much as execution order.
12:49:29 <roconnor> including let staments in do statements
12:49:36 <dcoutts_> lispy: if cabal on different machines is using base 3 or 4 then you must be running different major versions
12:49:49 <cydergoth> Ok, I think I understand 
12:49:49 <roconnor> cydergoth: ah yes, but again the order of evaluation doesn't matter in the IO monad
12:49:51 <chrisdone> > let x = snd a where a = (error "oh no",2) in x
12:49:52 <lambdabot>   2
12:49:59 <chrisdone> > let x = fst a where a = (error "oh no",2) in x
12:49:59 <lispy> dcoutts_: how do you define major versions?
12:49:59 <lambdabot>   *Exception: oh no
12:50:01 <dcoutts_> lispy: that heuristic got added at some point so that we did not break all old packages
12:50:12 <cydergoth> chrisdone: Nice example
12:50:23 <lispy> dcoutts_: I'm using ghc 6.12.x on both machines (I think both are .1)
12:50:30 <lispy> dcoutts_: one is a mac and one is linux
12:50:34 <chrisdone> :-)
12:50:37 <roconnor> cydergoth: main = do x <- undefined; putStrLn "look ma, no evaluation" 
12:50:51 <dcoutts_> lispy: oh then I expect the behaviour to be the same, you must be using cabal-install-0.8.x which has the new behaviour
12:50:57 <askhader> dafis: Can you explain to me how I am violating the type of those clauses?
12:51:00 <chrisdone> О»> do x <- undefined; putStrLn "look ma, no evaluation" 
12:51:00 <chrisdone> *** Exception: Prelude.undefined
12:51:04 <cydergoth> Style question then: is it ok to mix Data.Accessor with the record update  r { f = v } type clauses?
12:51:12 <dcoutts_> lispy: it got introduced in the cabal-install.0.6.x series
12:51:13 * chrisdone likes to show off his GHCi prompt
12:51:14 <lispy> dcoutts_: I _just_ upgraded both cabal and cabal-install on this machine, to see if it would help and the other machine should have something fairly recent too
12:51:29 <Philonous> roconnor: lazy IO? I hope not?
12:51:34 <roconnor> ah crap
12:51:41 <roconnor> cydergoth: main = do x <- return undefined; putStrLn "look ma, no evaluation" 
12:51:45 <lispy> dcoutts_: at least as recent as March
12:51:51 <dcoutts_> lispy: and I assume you're not overriding the base version preference in your ~/.cabal/config
12:52:03 <lispy> dcoutts_: I can do that??
12:52:42 <dcoutts_> lispy: if you're seeing it pick base 3 on one box and base 4 on another when using modern cabal-install versions then I'd be interested to know the details.
12:52:46 <roconnor> cydergoth: I don't have too much experience with Data.Accessor, but I see no immediate problem with mixing it with record updates
12:52:56 <chrisdone> roconnor: ++ "(fo' sho this time)"
12:53:01 <dcoutts_> lispy: for the same package that is
12:53:01 <cydergoth> So let me just reiterate to understand: In do clauses, evaluation order is undefined, but execution order of the resulting IO actions is?
12:53:17 <lispy> dcoutts_: I don't have the mac handy at the moment, but I'll provide whatever info you ask for
12:53:54 <roconnor> cydergoth: do clauses build a type IO foo, and the value of this type contains the data of an ordered series of system calls (actually it is a tree).
12:54:04 <dcoutts_> lispy: the output of cabal --version; cabal configure -v on the same package
12:54:12 <lispy> okay
12:54:19 <roconnor> cydergoth: the runtime system then invokes the system calls in the order dictated by that value.
12:54:36 <cydergoth> roconnor: but the parameters to those system calls are evaluated on demand when the system call runs?
12:54:37 <dafis> dcoutts_: I just tried with --constraint="base == 4.2.0.2", it insisted on using base-3.0.3.2
12:54:48 <askhader> So I'm trying to create a function that consumes a list and produces a list of lists where all consecutive identical elements in the initial lists are all concatenated into one list. For example  f [1,2,2,3,2,2,4] -> [[1], [2,2] [3], [2,2], [4]] - why does this code not do the trick? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28040#a28041
12:55:18 <dcoutts_> dafis: there's a bug in the constraint handling for base
12:55:31 <roconnor> cydergoth: the parameters of the system calls are based on the results of previous system calls.  This is why it is really a tree.  At each node there is a branch for each results of the system call.
12:55:33 <chrisdone> be very aware that functions don't evaluate the arguments
12:55:40 <dcoutts_> dafis: packages like base that depend on different versions of themselves have to be handled specially
12:56:15 <dcoutts_> dafis: as it happens preference will work though
12:56:16 <roconnor> cydergoth: or the parameter is fixed at compile time, which has to be the case for the first system call.
12:56:37 <cydergoth> chrisdone: right, so that is true in the general case but can be forced with the strict evaluation directive?
12:56:48 <dafis> dcoutts_: okay, but it's certainly unexpected behaviour
12:57:04 <bvck> Sorry guys. Have to ask again. Can someone please take a look a the pseudo code at http://codepad.org/9edZvPLA and give me a hint on how I can do this?
12:57:10 <lispy> dcoutts_: another oddity is that when I 'ghc-pkg describe' on this package (attoparsec-0.8.0.2), it lists base-3, bytestring, and contrainers.  When I describe bytestring and containers those claim to use base4.
12:57:19 <dafis> dcoutts_: I'd rather expect it to fail than overriding a command line constraint
12:57:22 <roconnor> data IO a = Done a
12:57:22 <dcoutts_> dafis: the tricky thing you see is that if you depend on base 3 then you also depend on base 4, so it is impossible to have a constraint like base == 3.x
12:57:23 <roconnor>           | PutChar Char (IO a)
12:57:24 <roconnor>           | GetChar (Char -> IO a)
12:57:41 <dcoutts_> dafis: and the way we implement it is to always select both of such paired packages
12:58:19 <monochrom> base 3 depends on base 4, that's a lot of fun :)
12:58:34 <dcoutts_> monochrom: yeah, it gave me nightmares :-)
12:58:41 <conal> cydergoth: the binary operation of action sequencing (justaposition in C) is not commutative.  just like subtraction on numbers isn't.
12:58:43 <lispy> dcoutts_: shouldn't it be a bug for cabal to build against things that need base4 and base3 in the same library?
12:58:46 * monochrom tries to mimick that
12:58:47 <dcoutts_> had to hack the cabal-install resolver quite severely
12:58:57 <dcoutts_> lispy: oh each individual package only uses one version
12:59:10 <cydergoth> conal: ah, ok
12:59:52 <dafis> dcoutts_: the constraint is base == 4.*, if that's in a .cabal file, base-3 is left alone (or so it seems), on the command line [with build-dep base >= 3], I get You are using the old package `base' version 3.x
12:59:56 <dcoutts_> lispy: but it's ok for a bunch of packages to have different deps on base 3 or 4, they are compatible, but only because base 3 depends on base 4.
13:00:02 <roconnor> > (a:) . (b:) $ []
13:00:03 <lambdabot>   [a,b]
13:00:07 <roconnor> > (b:) . (a:) $ []
13:00:08 <lambdabot>   [b,a]
13:00:20 <dcoutts_> dafis: yes it could be handled better, there's a ticket for it
13:00:30 <Ulfalizer> askhader: i think you're on the right track, but need to work on the details. for one thing, pack [x] = [x] means that e.g. pack [1] = [1], when you should have pack [1] = [[1]]. similarly, your otherwise case is screwed up (will add x, which isn't (necessarily) a list, to the beginning of the result list, when each element in it should be a list)
13:01:00 <lispy> dcoutts_: selecting base-3.0.3.2 (installed) and 4.2.0.0 (installed) and discarding
13:01:03 <lispy> syb-0.1.0.0, 0.1.0.1, 0.1.0.2, 0.1.0.3, 0.2 and 0.2.1  <-- do you think the problem is the version of syb it wants to use?  Note: that the package I want to install doesn't use syb
13:01:06 <Ulfalizer> also, (head xs) : (tail xs) is just xs :)
13:01:26 <dcoutts_> lispy: what problem?
13:01:33 <dcoutts_> lispy: base 3 depends on syb
13:01:35 <lispy> Hmmphf.  The version of syb depends on base4
13:02:03 <[bjoern]> I have some autogenerated code, it's just a list (well with pairs and function applications and more lists inside) and whether I generate it as one line or many I get "parse error (possibly incorrect indentation)". How would I go about debugging that? (Perhaps there is a comma missing somewhere, for instance)
13:02:04 <lispy> I have zero idea why cabal insists on base3 here.
13:02:12 <lispy> verbose doesn't add anything useful :(
13:02:14 <dcoutts_> lispy: yes syb depends on base 4, but so does base 3
13:02:31 <dcoutts_> lispy: what is the constraint on base in the .cabal file?
13:02:47 <chrisdone> cydergoth: in Scheme, with (define (mult x y) (* x y)) the substitution process for (mult (/ 6 2) (* 2 5)) is: (mult 3 10) => (* 3 (* 2 5)) => (* 3 10) => 30
13:02:47 <chrisdone> cydergoth: in Haskell, with mult x y = x * y, the substitution process for mult (/ 6 2) (* 2 5) is: (/ 6 2) * (* 2 5) => 3 * 10
13:02:48 <fryguybob> bvck: not sure what you are trying to do, can you explain more?
13:02:51 <lispy> dcoutts_: http://hackage.haskell.org/packages/archive/attoparsec/0.8.0.2/attoparsec.cabal
13:03:14 <[bjoern]> (It's a 25 000 character line, I hope there is not some GHC limit wrt to line length that is causing this)
13:03:53 <Twey> A *what*?!
13:03:57 <dafis> dcoutts_: attoparsec.cabal says base >= 3; the problem is that the preferred version of base can't be overridden on the command line
13:03:58 <dcoutts_> lispy: right, so because that package uses base >= 3, with no upper bound then we assume this is an old package that never got tested against base 4, so we select base 3.
13:04:14 <dcoutts_> dafis: are you sure? I thought --preference would work
13:04:16 <dafis> dcoutts_: it ought to work with base-4, not using base-3
13:04:16 <Twey> I have no idea how you'd go about debugging such a thing.  Perhaps try generating a smaller list.
13:04:27 <bvck> fryguybob, trying to learn limits of pattern matching.
13:04:29 <lispy> dcoutts_: So why does it get base4 on a different machine?
13:04:38 <dcoutts_> lispy: it should not
13:04:43 <[bjoern]> Well I did take just the first few elements, that worked fine.
13:04:51 <cydergoth> chrisdone: that's the lazyness right? the (/ 6 2) isn't evaluated until the whole expression is realized?
13:04:55 <bvck> Can it for example go inside to the next level to match?
13:05:00 <dcoutts_> lispy: not if it's using a recent cabal-install version
13:05:01 <chrisdone> cydergoth: that's right
13:05:29 <dafis> dcoutts_: yes, --preference works, but not --constraint
13:05:41 <lispy> dcoutts_: I can double check the version when I get home, but it should be recent.  I tend to upgrade cabal-install pretty often
13:05:45 <dcoutts_> dafis: right, the --constraint thing is just a bug
13:05:59 <lispy> What is --preference?
13:06:01 <dafis> dcoutts_: bug in what sense?
13:06:27 <[bjoern]> Are there restrictions on what can go inside double quotes, other than double quotes and newlines?
13:06:28 <cydergoth> One of the things which gave me the most grief coming from a C/C++/Java/Scheme background was the way in which haskellers casually change from infix to prefix notation and sometimes just leave out bits of syntax like (). This didn't seem to be explained at the top of any of the tutorials
13:06:37 <fryguybob> > let (a, [b, c]) = (1, ["blah", "more blah"]) in (a, b, c) -- bvck
13:06:38 <lambdabot>   (1,"blah","more blah")
13:06:57 <chrisdone> cydergoth: you mean how it's used for tuples and other times just for grouping?
13:07:18 <cydergoth> chrisdone: yes, and the way you can do $ instead or sometimes just leave it out
13:07:30 <dafis> chrisdone: I think (++) xs ys vs. xs ++ ys
13:07:35 <chrisdone> cydergoth: oh, sure. haskellers are lazy in many way
13:07:35 <lispy> oh, cool, with --preference it's now built against base4
13:07:38 <lispy> That's reallynice!
13:07:55 <lispy> dcoutts: so how would I put --preference in my ~/.cabal/config?
13:08:16 <chrisdone> dafis: cydergoth: ahh. yes, that's a tricky one. also: (*5) -- ``sections''
13:08:39 <cydergoth> chrisdone: if someone could update the tutorials to just point that out, it would be helpful I think
13:08:50 <chrisdone> cydergoth: which tutorials?
13:09:08 <chrisdone> I think at least tryhaskell points that out
13:09:30 <dcoutts_> dafis: http://hackage.haskell.org/trac/hackage/ticket/538#comment:1
13:09:31 <askhader> oh
13:09:37 <askhader> I need [[x]] ++
13:09:39 <cydergoth> chrisdone: all of them ;-) I couldn't see any which did point that out. Gentle introduction seemed to be like being hit over the head with a baseball bat even being familiar with functional programming
13:10:08 <pickles> hm, this is interesting
13:10:10 <dcoutts_> lispy: I would not recommend it, that feature is there for a reason, to not break lots of old packages.
13:10:24 <dcoutts_> lispy: it's not actually a problem if you've got packages building against base 3
13:10:24 <pickles> i've run into a situation where ghci doesn't have the wherewithall to print the error
13:10:28 <pickles> (i think)
13:10:36 <monochrom> If you say "cabal install attoparsec", it uses base 3. If you say "cabal unpack attoparsec" then use Setup.lhs, it uses base 4. This generalizes to most build-type:Simple and liberal build-depends:base
13:10:41 <cydergoth> That and understanding that haskell type signatures are (roughtly) equivalent to a set of currys (which made more sense once I realised Haskell invented currying)
13:10:53 <lispy> monochrom: interesting
13:11:11 <OscarZ> cydergoth: what was the thing you'd like to add in the tutorials.. i missed it :)
13:11:21 <lispy> So I should cabal unpack things before installing them?
13:11:26 <dcoutts_> monochrom, lispy: that is because Setup.lhs uses the naive algorithm to pick dependencies
13:11:30 <kmc> haskell type signatures are equivalent to a set of currys?
13:11:34 <dafis> pickles: details, please
13:11:35 <cydergoth> One of the things which gave me the most grief coming from a C/C++/Java/Scheme background was the way in which haskellers casually change from infix to prefix notation and sometimes just leave out bits of syntax like (). This didn't seem to be explained at the top of any of the tutorials
13:11:40 <chrisdone> let f x y = (mult x 5,mult y 6) in snd (f (+ 2 (foo 4)) (* 8 9))
13:11:40 <chrisdone> (1) take the body of the function: (mult x 5,mult y 6)
13:11:40 <chrisdone> (2) substitute: snd (mult (+ 2 (foo 4)) 5,mult (* 8 9) 6)
13:11:40 <chrisdone> (3) take the body of the snd function (\(_,a) = a): a
13:11:44 <chrisdone> (4) substitute: mult (* 8 9) 6 => (* 8 9) * 6 => 432
13:11:55 <dcoutts_> lispy: why is it actually a problem that you build attoparsec against base 3?
13:12:06 <iammisc> Are there any dataflow programming libraries for haskell?
13:12:07 <monochrom> conscience problems :)
13:12:21 <lispy> dcoutts_: How can I check that things work with base4 if I can't actually build things with it?
13:12:27 <chrisdone> (actually the snd/f functions would be evaluated in the other order. I made a mistake because I added the snd as an afterthought)
13:13:17 <cydergoth> kmc: I mean as you move left to right down a type signature you're taking a parameter off the parameter list and substituting a curry'ed version of the original function with one shorter parameter list
13:13:27 <pickles> what's the hpaste url? (i forget)
13:13:28 <dcoutts_> lispy: if you're editing the package (e.g. to send patches to the maintainer) then just edit the .cabal file and use: base >= 3 && < 5. Then cabal will pick base 4.
13:13:49 <OscarZ> yeah i guess infix/prefix might cause some confusion.. i think my problems are coming from the fact that i dont really understand the typing system yet 
13:13:52 <monochrom> I recommend cabal install --preference='base>=4' attoparsec
13:13:53 <chrisdone> cydergoth: I think you get the idea of the evaluation anyway. pattern matching is pivotal in evaluation, and also ignoring unused things
13:13:57 <OscarZ> the flexibility of it, coming from java 
13:14:05 <dafis> pickles: http//hpaste.org/new
13:14:09 <dcoutts_> lispy: if on the other hand you're just using the package then don't worry about it, wait for the maintainer
13:14:11 <lispy> dcoutts_: Similarly, getting different results when using "cabal install foo" vs. "cabal unpack foo; cd foo; cabal install" seems like a big problem for testing for releases.
13:14:12 <Philonous> OscarZ: Wait till you see agdas mixfix.
13:14:15 <pickles> dafis: thx
13:14:28 <[bjoern]> Okay figured it out. It didn't like having the ] of the outermost list at the beginning of the line.
13:14:29 <dcoutts_> lispy: you will not get different results in that case
13:15:05 <dcoutts_> lispy: Setup.hs configure vs cabal configure are different, cabal unpack foo; cabal install is the same as cabal install foo
13:15:21 <lispy> dcoutts_: ideally, I could get cabal to treat base like other packages and then _fix_ the old packages that don't specify things correctly
13:15:23 <dcoutts_> lispy: note also that this problem will just go away as new versions are uploaded, new uploads are required to have an upper bound on the version of base.
13:15:30 <chrisdone> OscarZ: the typing system takes a bit of patience -- just enough time to put the book of what a type system is from Java onto a shelf so that you can read the book of Haskell's types without being distracted :-)
13:15:58 <chrisdone> (in your mind)
13:16:03 <dcoutts_> lispy: you can easily see which packages are using base 3, you get all the warnings :-)
13:16:03 <cydergoth> OscarZ: the other thing which I find hard for a modern language is that there are many libraries which implement similar functionality with different APIs; whereas in java you tend to have a relatively uniform SPI or a much more limited choice of library to pick from
13:16:12 <dcoutts_> lispy: or do a ghc-pkg dump and grep for base 3
13:16:19 <lispy> dcoutts_: having cabal silently ignore constraints has actually caused me to waste a lot of time
13:16:22 <OscarZ> chrisdone: are there any specific thing that you could point out between haskell typing vs java typing that you'd thing would cause some problems? 
13:16:45 <dcoutts_> lispy: sorry about that, add your email address to the cc list on the bug then: http://hackage.haskell.org/trac/hackage/ticket/538
13:16:57 <cydergoth> OscarZ: The GeomAlgLib library has a great example of using type classes to parameterise a Point class ;-)
13:17:27 <kmc> iammisc, i'm not sure what you mean by dataflow programming.  there is a thing in Haskell called "functional reactive programming" that might be related
13:17:34 <lispy> dcoutts_: I don't think I can unless I create an account on the wiki
13:17:38 <OscarZ> chrisdone: or cause confusion and misunderstandings.. 
13:17:49 <dcoutts_> lispy: you can log in using the guest account
13:18:14 <dcoutts_> lispy: if you want to always prefer base 4 rather than getting the magic behaviour then I think it'd work to add a preference on base >= 4 in your ~/.cabal/config
13:18:21 <roconnor> can Traversable.sequence be defined using Traversable.sequenceA?
13:18:31 <dcoutts_> lispy: and be prepared for lots of older packages to break
13:18:38 <chrisdone> OscarZ: (un-)fortunately I don't know Java. I know it has generics, which were influenced by parameterized types. e.g. ``List<A>'' vs ``[a]''. other than that, I don't know. perhaps functions are confusing
13:18:39 <pickles> dafis: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28042#a28042
13:18:55 <roconnor> ah, by default it is
13:19:16 <monochrom> dcoutts_: why we are at it, what does .cabal/config "constraint:" do?
13:19:24 <lispy> dcoutts_: When I login as guest, I still can't add myself to CC.  What is the syntax for adding that?
13:19:31 <dcoutts_> monochrom: like --constraint= on the command line
13:19:54 <dcoutts_> lispy: I think it's just a space delimited list of email addresses
13:20:14 <lispy> dcoutts_: it's read-only with a checkbox for me
13:20:24 <kmc> the big difference between Java and Haskell types might not be technical, but rather the philosophy of using them.  in Haskell types aren't for specifying representation; they're for specifying correctness properties of your program
13:20:24 <dcoutts_> lispy: oh, hmm
13:20:34 <chrisdone> OscarZ: how new to Haskell are you?
13:21:41 <OscarZ> my main problem is that when i start to write a method in java.. i have some inputs and i want something out.. the way i usually do it is by iterations, building new lists, etc.. and in haskell i feel i have to define it right away "top-down" in one line or something like that 
13:21:42 <cydergoth> kmc, OscarZ: so the closest to a java type in Haskell is a Record (data foo = foo { a :: Int, b ::String } ) as far as I understand it. Is that right?
13:22:01 <kmc> cydergoth, i don't think that's a useful comparison
13:22:27 <kmc> Java has classes, primitive types, functions, arrays, etc.
13:22:29 <cydergoth> OscarZ: I find using 'where' clauses helps a lot with that. You can define a top level expression in terms of sub-expressions in the where clauses
13:22:38 <OscarZ> chrisdone: ive had some plunges at haskell before.. i know the basics.. im very interested in it and i understand the benefits 
13:22:43 <cydergoth> kmc: I meant in terms of an ADT
13:23:09 <dafis> pickles: parsec, I presume? What are reader, Constant, Info ?
13:23:16 <kmc> OscarZ, cydergoth, "where" is useful; "let" also
13:23:20 <OscarZ> haskell makes it seem that imperative languages are somehow "ad-hoc" 
13:23:27 <kmc> f x = let y = ...; z = ... y ...; in z
13:23:43 <cydergoth> kmc: I seem to prefer where as it is closer to the way I would write math
13:23:48 <kmc> mm
13:24:01 <OscarZ> too close to how the processor works and somehow we all got sucked into that world :P 
13:24:08 <kmc> OscarZ, Haskell *is* an imperative language, and its treatment of imperative programming is significantly less ad-hoc
13:24:09 <chrisdone> OscarZ: I write all my Haskell code like this: write what you want the top-level part to be f = x . y, then write where x = undefined; y = undefined, etc. compile it, define x. compile it, define y. compile it. run it
13:24:12 <pickles> dafis: gah, yes, parsec (sorry, should have given more complete, i was thinking that code was more isolated than it its)
13:24:43 <pickles> dafis: reader is just a variable for the function (which function to turn the string into a number -- e.g. readHex, which are in the Numeric lib)
13:24:56 <kmc> chrisdone, with type sigs on x and y?
13:25:00 <chrisdone> OscarZ: because `undefined' has type `a', which will type check. so it's great for leaving some things unimplemented until you feel like doing it
13:25:12 <chrisdone> kmc: usually with a type-sig on f
13:25:21 <dafis> pickles: ah, right, overlooked that 
13:25:30 <pickles> dafis: Constant is unimportant, the line could just be: return n
13:25:34 <chrisdone> f :: Integer -> Integer
13:25:34 <chrisdone> f = x . y where
13:25:34 <chrisdone>  x = undefined
13:25:34 <chrisdone>  y = undefined
13:25:45 <pickles> dafis: although there is a Show derived for Constant, so I don't think that's the issue
13:25:46 <chrisdone> then implement x, then y
13:26:00 <monochrom> this is why the name is chosen "undefined" :)
13:26:04 <chrisdone> :-)
13:26:17 <dcoutts_> lispy: mm that seems to be a "helpful" new feature of trac, I'll ask Igloo what they do on the ghc trac. Getting an account isn't so bad though. :-)
13:26:31 <monochrom> you can also define your own "to_do", "do_me", "look_here"
13:26:32 <dafis> pickles: just trying to find out where (Int -> Int -> Info) comes from
13:26:42 <pickles> dafis: me too!
13:26:50 <chrisdone> also, x = error "TODO: implement me", sometimes. but I don't just leave them lying around, they're replaced with real code within 15 minutes
13:27:05 <dafis> pickles: so, what's the type of Constant ?
13:27:05 <chrisdone> monochrom: that's a nice one. to_do = error "TODO"
13:27:20 <chrisdone> monochrom: or to_do = error . (++"TODO: ")
13:27:24 <pickles> dafis: *facepalm*
13:27:44 <dafis> pickles: explain?
13:28:03 <chrisdone> OscarZ: did I address the same problem as the one you're having, or did I miss the point?
13:28:06 <pickles> dafis: Constant is part of the Info type that i defined, and am using that Constant as a curried constructor which i return and fill the rest of in later
13:28:12 <monochrom> too bad function names can't be in capital letters like TODO
13:28:25 <lispy> tODO!
13:28:31 <dafis> pickles: mystery solved :D
13:28:53 <pickles> dafis: thx, i think i need a break ;)
13:28:57 <kmc> error __LINE__
13:28:57 <pickles> mind's goin
13:29:24 <chrisdone> kmc: I didn't know __LINE__ was defined in GHC. that's useful. I use that in C a lot
13:29:32 <kmc> chrisdone, it is iff you have -XCPP, i think
13:29:37 <chrisdone> nice one
13:29:51 <pickles> dafis: while i have your attention, is that the correct way to specify a (possibly optional) prefix character to be passed as an argument?
13:29:59 <c_wraith> Well..  If you don't have CPP on, the macro wouldn't be expanded anyway....
13:30:00 <pickles> it doesn't seem like it to me
13:30:03 <lispy> dcoutts_: you might not want to port the solution from the ghc trac.  I have 3 accounts on that wik and I can't login with any of them or get my password sent to me
13:30:52 <dcoutts_> lispy: sigh
13:31:15 <dcoutts_> lispy: you can ask Igloo to reset one
13:31:16 <dafis> pickles: it is *a* correct way, but I would move hex before dec, to have mandatory prefix chars before optional
13:32:03 <lispy> dcoutts_: yeah, last time I needed to update something on ghc-trac I had heinlein help me
13:32:16 <pickles> dafis: yeah, i was thinkin about doing that
13:32:17 <OscarZ> chrisdone: yeah i guess thats a good start.. i've usually been working with application doing with persistent state and user interfaces, events etc.. i'm not really sure how these are handled in a functional language
13:32:36 <lispy> dcoutts_: hopefully the infinite redirects that prevented me from logging in have been fixed :)
13:32:46 <dcoutts_> :-)
13:33:35 <dafis> lispy: forgot your password once?
13:33:37 <monochrom> > let _TODO = error "TODO" in not _TODO
13:33:37 <lambdabot>   *Exception: TODO
13:33:41 <pickles> dafis: it's weird tho, it's complaining about print, which i do nowhere in the file
13:33:44 <monochrom> I'm a genius
13:33:54 <pickles> dafis: *complaining about print in that error
13:33:56 <chrisdone> monochrom: :-D
13:33:59 <dafis> lispy: that's what sent me into infinite redirects
13:34:49 <dafis> pickles: in ghci, expression is interpreted as do { let { it = expression }; print it }
13:35:02 <pickles> aah
13:35:24 <pickles> did not know that
13:35:55 <pickles> totally makes more sense now
13:35:58 <pickles> thx dafis!
13:36:10 <dafis> pickles: welcome
13:36:30 <monochrom> infinite redirection sounds like a very haskelly thing to do :)
13:37:47 <lispy> dafis: yeah, on websites that I don't use often, I rely on the "reset password" instead of recording my password or remembering it
13:37:53 <kmc> yeah, ghci has an implicit print for any expression which is not of IO action type
13:37:55 <chrisdone> OscarZ: the same way; when you need to talk to something stateful or perform an algorithm that's only fast when impure, etc. you use impure code. the point is mostly to reduce the amount that you use. it's easier to understand, modify, test pure code simply because there are less implications to your actions.
13:38:10 <kmc> and an explicit print for the result of any IO action whose result type is not ()
13:38:19 <kmc> or maybe only those with Show, i forget
13:38:46 <dafis> lispy: me too, normally my browser remembers them - that doesn't survive a new computer, however
13:38:52 <chrisdone> OscarZ: instead of ``f xs = return $ map (*2) xs'', write ``f xs = map (*2) xs'' because the problem of doubling a list is pure. this is a trivial example, but you'll see it in your real code. you're doing pure problems in an impure computation for no reason; you should separate it. eventually you already have a clear image of what's pure and impure in your head before you begin writing
13:39:08 <dcoutts_> dafis, lispy: hmm, I don't think I can easily fix the problem where --constraint=base is ignored. Problem is that we treat all constraints as global applying to all packages. But for constraints on paired packages that cannot be the case or we could never depend just on base 3.
13:39:19 <OscarZ> chrisdone: i understand the horrors of state, i've seen things.. oh boy.. you dont want to hear about those things.. let them stay in the abyss! 
13:39:19 * kmc is mostly opposed to this "pure vs impure" terminology
13:40:00 <dcoutts_> dafis, lispy: so basically we have to ignore it or you could never have packages depending on base 3.
13:40:26 <dcoutts_> dafis, lispy: we'd need a rather different approach to allow constraints to scope over only certain packages rather than globally.
13:40:46 <dafis> dcoutts_: failing with an informative error message if the constraint can't be satisfied ?
13:40:58 <lispy> dcoutts_: I'll do the preference thing for now.  At least now I shouldn't run into the problem where a package builds against base 3 and breaks a later build where something can't have a base3 dependency
13:41:02 <dcoutts_> dafis: but it has to be satisfied, that's the thing
13:41:06 <chrisdone> OscarZ: after that you have options like only allowing some types of effects to occur, a la the STM or ST monads, or talking to a database, working with X (a la XMonad), a CGI monad that only really needs to be defined by something that reads text inputs and output some string
13:41:16 <zepard> hello
13:41:21 <dcoutts_> dafis: when a package has a constraint: build-depends: base < 4, then we cannot fail.
13:41:22 <kmc> to be fair, the X monad allows all IO too
13:41:25 <kmc> hi zepard
13:41:46 <dcoutts_> dafis: we must pick base 3, which itself depends on base 4, so we must not have excluded base 4.
13:41:56 <OscarZ> chrisdone: very interesting..
13:42:25 <chrisdone> that's really the bee's knees
13:42:38 <chrisdone> Clojure has this problem with STM that you can do any IO in a transaction
13:42:46 <chrisdone> which kind of contradicts the point of a transaction
13:42:57 <dafis> dcoutts_: I don't understand; pack depends on base >= 3; I try cabal install --constraint="base > 3" pack; why not -use base 4 if possible or -fail with "constraint can't be satisfied"
13:43:07 <kmc> in Haskell you can do IO in a transaction too
13:43:10 <aristid> chrisdone: can't that be solved by "just don't do it please"? :D
13:43:17 <kmc> but there are big warning flags in the code when you do
13:43:22 <roconnor> @hoogle Cosnt
13:43:22 <lambdabot> No results found
13:43:28 <roconnor> @hoogle Const
13:43:28 <lambdabot> Control.Applicative newtype Const a b
13:43:28 <lambdabot> Control.Applicative Const :: a -> Const a b
13:43:28 <lambdabot> Prelude const :: a -> b -> a
13:43:52 <chrisdone> kmc: sure -- the state monad's get can be as difficult to understand as getLine, in this way, it's not about purity but statefulness
13:44:01 <chrisdone> aristid: well, it works for the lisp folk
13:44:05 <dcoutts_> dafis: we cannot apply constraints that select one of base 3,4 and not the other, they come as a pair.
13:44:08 <chrisdone> personally I think of it like having sex
13:44:29 <chrisdone> it's good manners to take precautions and a nice idea to assume everyone else does, but I wouldn't want to take the risk
13:44:37 <OscarZ> chrisdone: how is that? i know STM is "software transactional memory" which is some kind of way to deal with state in a functional language.. can you explain it a bit, how it works? (to a imperative programmer)
13:44:40 <kmc> the difference between an "impure" language and a "pure" language with unsafePerformIO is one of library defaults, conventions and community norms
13:44:42 <dafis> dcoutts_: so base 4 depends on base 3 too?
13:44:51 <dcoutts_> dafis: no, only 3 on 4.
13:44:59 <kmc> OscarZ, http://book.realworldhaskell.org/read/software-transactional-memory.html
13:45:21 <kmc> OscarZ, it's not about state in a functional language.  it's about a better way to do concurrent state, in an imperative language
13:45:23 <dafis> dcoutts_: so what's the problem with not using base 3 if that's requested (and possible)?
13:45:27 <monochrom> do you mean you think of STM as having organized group sex??!!!
13:45:28 <kmc> (in this case, the imperative language is Haskell)
13:45:33 <chrisdone> OscarZ: for the full word you can checkout Beautiful Concurrency by Simon Peyton-Jones which is actually aimed at non-Haskellers and is a really good paper explaining it
13:45:37 <chrisdone> @google Beautiful Concurrency
13:45:38 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf
13:45:38 <lambdabot> Title: Beautiful concurrency
13:45:44 <proppy> is there an haskell module for doing dos2unix String conversion ?
13:46:22 <OscarZ> thanks guys
13:46:25 <dcoutts_> dafis: because it would make it impossible to use any dependencies that need base 3.
13:46:32 <dafis> proppy: not that I know, but filter (/= '\r') should do the trick
13:46:39 <OscarZ> ill bookmark these
13:46:42 <proppy> @t filter
13:46:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:46:46 <proppy> :t filter
13:46:47 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:46:53 <dcoutts_> dafis: even if those dependencies were already installed.
13:47:05 <chrisdone> OscarZ: the jist of it is that it behaves like IO. but the only effectual things you can do is writeTVar and readTVar. reading and writing to some transactional variables. you can't read to a file or print to the screen within this computation. this means the transaction can be rolled back or retried, is isolated, etc. (all the ACID properties)
13:47:17 <monochrom> > filter ('x' /=) "helloxIxxyou"
13:47:18 <lambdabot>   "helloIyou"
13:47:22 <dafis> dcoutts_: so then fail telling the user the constraint can't be met and to retry without the constraint
13:47:59 <proppy> dafis: thanks dos2unix a = filter (/= '\r') a
13:48:20 <dcoutts_> dafis: mm, that'd need top level constraints to be handled differently to constraints we get from packages. It's not impossible but it's not an easy fix.
13:48:39 <dafis> proppy: there might also be an issue with DOS' eof character
13:48:46 <proppy> dafis: and tested ! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28045#a28045
13:48:49 <proppy> :)
13:49:23 <dafis> dcoutts_: being too complicated to bother is a valid reason not to do it :)
13:49:36 <OscarZ> in the java world, stuff is usually persisted to a database backend.. then you use some kind of object relational mapping (Hibernate etc.) library to map the Java objects to database.. and back. Library "tries" to take care of the concurrency issues... 
13:49:47 <dcoutts_> dafis: the problem should go away when we next rewrite the solver
13:49:54 <OscarZ> usually it works pretty well
13:50:25 <dcoutts_> dafis: global constraints are too restrictive, the hack to allow base 3 and 4 is pushing it near to breaking point.
13:50:32 <proppy> dafis: do you know if there is something equivalent do b
13:50:37 <dafis> dcoutts_: and base-3 will go away in 6.14, I think, so don't bother
13:50:55 <dcoutts_> dafis: oh but we'll have the same technique being used in future
13:51:01 <proppy> what I do with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28045#a28045 (checkEqual/repotMessage/test) ?
13:51:02 <monochrom> this is a ripe time to say "all your base are belong to..."
13:51:11 <dcoutts_> monochrom: 4?
13:51:14 <dafis> dcoutts_: ewww
13:51:14 <dcoutts_> :-)
13:51:27 <proppy> that test a a binary unary function with a list (input, expected) ?
13:51:35 <chrisdone> (as a side note: I have cake, and, er, well, you don't.)
13:51:37 <pickles> dafis: *moar facepalm* (i just figured out why i was getting an error -- i am such a n00b)
13:51:37 <dcoutts_> dafis: it's a rather clever way of providing an upgrade path for important libs
13:51:51 <cydergoth> chrisdone: I'll see you cake and rise you beer ;-)
13:52:03 <dcoutts_> dafis: when we went from base 2 to 3, everyone screamed that we needed a better solution than just breaking.
13:52:08 <monochrom> by year 2020, carbon dioxide emmision will fall to so-and-so, and base-10 will depend on base-12 :)
13:52:12 <chrisdone> cydergoth: cider perchance?
13:52:25 <dafis> proppy: I don't understand your goal
13:52:34 <dafis> pickles: ?
13:52:42 <proppy> dafis: I want to validate that a function is working
13:52:52 <monochrom> what is a "binary unary function"? :)
13:53:11 <chrisdone> monochrom: a transarite
13:53:15 <proppy> monochrom oups sorry :)
13:53:22 <chrisdone> hi Peaker
13:53:26 <proppy> s/binary//
13:53:33 <monochrom> HUnit, SmallCheck, QuickCheck
13:53:48 <dafis> dcoutts_: yeah, just breaking is bad, but having a package depend on another version of the same and incorporating that in the constraint solver is ewww
13:53:54 <monochrom> perhaps HUnit first, close to JUnit
13:53:58 <pickles> dafis: i was having trouble understanding why it was wanting a Show instance, but then realized that it was trying to print the result -- the error (which I thought was in my code) was because it was trying to print the result of the call (isntead)
13:54:02 <monochrom> but the other blows your mind
13:54:16 <monochrom> err, the others blow your mind
13:54:36 <chrisdone> I started reading the smallcheck paper but didn't finish it. I suck :-(
13:54:50 <Peaker> chrisdone, hey
13:54:55 <dafis> pickles: yeah, the error said you tried to print something for which no Show instance was available
13:54:57 <dcoutts_> dafis: the reason it's a good idea is it means base 3 exports the same Int as base 4 does, if they were different types then we'd still be screwed because you would have to move all packages from base 3 to 4 in one go, defeating the point.
13:55:08 <chrisdone> Peaker: can I see your editor thingie?
13:55:18 <chrisdone> Peaker: semantic editor?
13:55:22 <proppy> monochrom: I made a few test using quickCheck but it is more usefull to test against random input http://gist.github.com/394513
13:55:29 <pickles> dafis: yeah, that should have clued me in, but apparently im dense today
13:55:30 <cydergoth> chrisone: I wish, can't get good cider in the USA
13:55:30 <proppy> monochrom will take a look at smallcheck
13:55:32 <OscarZ> out of curiosity, are there any features you miss from imperative languages? 
13:55:53 <chrisdone> cydergoth: ahh, that's why you're a goth. 'cause you're sad :-D
13:55:55 <dafis> dcoutts_: yes, all I'm saying is it's not a nice situation
13:55:56 <pickles> curious now: anyone know how to make a Show instance for a function (or is it not possible) ?
13:56:08 <Peaker> chrisdone, sure, it's an abstract syntax editor (structural) rather than a concrete syntax editor. the current (Haskell incarnation) is still a dumb tree editor as I'm focusing on structured revision control atm
13:56:09 <sioraiocht> OscarZ: There are some algorithms I find easier to implement in imperative styles
13:56:13 <sioraiocht> depends on what I'm doing
13:56:14 <Peaker> chrisdone, http://github.com/peaker/datastore and http://github.com/peaker/vtywidgets
13:56:15 <dcoutts_> dafis: I think we just need a more flexible solver.
13:56:21 <cydergoth> chrisdone: given the state of the world it is the only sane response 
13:56:26 <dafis> pickles: Text.Show.Function
13:56:28 <Peaker> chrisdone, vtywidgets is a widget set around vty with a purely-functional interface
13:56:29 <OscarZ> sioraiocht: what kind of stuff is that? 
13:56:40 <proppy> are there is doccheck :)
13:56:43 <proppy> http://haskell.org/haskellwiki/DocTest
13:56:48 <pickles> dafis: thx!
13:56:55 <Peaker> chrisdone, datastore is a dumb tree editor with fully persistent state (even gui state), persistent infinite undo/redo, edits a berkeley db backend store
13:56:56 <dcoutts_> dafis: more generally it's ok to have multiple versions of the same package in a dependency tree as long as we can be sure they do not conflict, e.g. QuickCheck 1 and 2
13:57:06 <dafis> pickles: but all it prints is <<function>>
13:57:08 <Peaker> chrisdone, It's all pretty tiny (~3K LOC so far altogether)
13:57:20 <chrisdone> hm, ok
13:57:22 <pickles> lol
13:57:40 <OscarZ> what about you chrisdone, you miss anything? :) 
13:57:46 <sioraiocht> OscarZ: For example, I did some work using viterbi searches a few years back, and definitely preferred using Lua
13:57:49 <Peaker> Did anyone see my parallel quicksort debacle with jdh about F# vs Haskell?
13:57:56 <dafis> dcoutts_: yes, but neither of them depends on the other
13:58:01 <kmc> OscarZ, Haskell is an imperative language, and I find it better for most kinds of imperative programming than the other languages I know
13:58:21 <Peaker> I want to fix the parallel quicksort to use the heap instead of the stack - so it can scale to large arrays. I think F# probably has a growing stack
13:58:27 <dcoutts_> dafis: no, but it's ok to have both as indirect deps of one package, and that's the point. The current solver cannot handle that.
13:58:38 <sioraiocht> OscarZ: most of the time, if I find haskell slows me down, it's because I don't want to convince the type system
13:58:49 <sioraiocht> even though it's better to do so, and usually worth the effort
13:58:49 <kmc> OscarZ, there are of course specific features from specific other languages that I miss in Haskell, but they're not about being "imperative" in particular
13:58:52 <OscarZ> kmc: why is Haskell then usually categorized as "functional language", i guess you can elaborate this a bit? 
13:58:53 <Peaker> sioraiocht, unsafeCoerce? :)
13:58:56 <kmc> OscarZ, it is both
13:58:58 <dcoutts_> dafis: in fact the point of the solver was to pick a single version, it's just that now we find that having multiple versions in some cases is actually a good idea.
13:59:17 <chrisdone> OscarZ: the only thing that annoys me in haskell is having to convert between numbers. and that's an annoyance. it's good to properly distinguish between types of numbers
13:59:22 <sioraiocht> Peaker: Gives me a false sense of security with something in haskell compiles using unsafeCoerce =p
13:59:30 <McManiaC> is "foo :: forall a. Num a => a -> a" the same as "foo :: Num a => a -> a" ?
13:59:33 <chrisdone> s/that's an /that's an unjustified/
13:59:34 <sioraiocht> chrisdone: I agree with both statements
13:59:47 <kmc> OscarZ, functional programs use functions to compute various sorts of values -- numbers, lists, trees, etc.  another sort of value you can compute is "sequence of actions to perform"
13:59:55 <kmc> in other words, we write functional programs which compute imperative programs
14:00:00 <lispy> McManiaC: yes.  Forall is optional, except when it isn't :)
14:00:05 <McManiaC> hehe
14:00:10 <kmc> OscarZ, and this is how you build an imperative language that isn't an ad-hoc mess
14:00:19 <OscarZ> interesting.. 
14:00:34 <Peaker> chrisdone, you aren't annoyed by the boilerplate of Binary instances, or of ADT getters, or of monad transformer stacks, or newtype unwrapping, etc?
14:00:36 <cydergoth> Can I get a value out of a monadic value in a where statement or does it have to be in a do?
14:00:36 <chrisdone> OscarZ: regarding impure stuff I haven't had problems yet
14:00:40 <McManiaC> lispy: but for "toplevel function types" it is?
14:00:45 <kmc> cydergoth, depends on the monad
14:00:52 <OscarZ> that doesnt sound too bad to me :)
14:00:56 <kmc> cydergoth, most monads have a "run" function e.g. runState, runError, etc.
14:00:56 <chrisdone> Peaker: well, we were talking in the context of "missing impure languages"
14:01:05 <cydergoth> kmc: Parsec monad
14:01:19 <Peaker> cydergoth, "do" doesn't take values out of monads, it just chains functions that handle results with the monad to yield computation sequences wrapped in a monad.. you can chain these together in "where" and you can also have "do" blocks in a where
14:01:45 <chrisdone> Peaker: not terribly annoyed by monad transformer stacks... what's your bad experience case?
14:01:46 <kmc> cydergoth, look at runParserT etc
14:02:00 <monochrom> do not think "how to take things out". think "how to pass things on to the next stage". then it's just >>= or the do-notation
14:02:07 <lispy> McManiaC: So, in Haskell98 and Haskell 2010, you can't use 'forall' in the type signature.  But several extensions allow you to use it and it allows you to be precise about polymorphism.  Really, all type variables have a forall somewhere, even when you're not using the extensions.
14:02:13 <Peaker> chrisdone, Well, every monad transformer stack I have has right next to it:  liftNameOfFirstLayer = MyWrapper ; liftNameOfSecondLayer = MyWrapper . lift ; ....
14:02:16 <cydergoth> Peaker : so in this where statement : block = parse wholeBlock (filter (not . isSpace) (stringToUpper firstline)) I want to turn the result of the parse in to the raw value not the Monadic value
14:02:52 <Peaker> cydergoth, You can't take values out of a monadic wrapper, but you can have something like:  block = do { x <- parse ... ; .. use x .. }
14:03:11 <McManiaC> lispy: okay :)
14:03:31 <kmc> you definitely can take values out of a monadic wrappers
14:03:35 <kmc> for some monads
14:03:45 <monochrom> imperative programming creates a generation of control freaks who think "I must get the input into my very own hand first, just so I can hand it back for further processing". Here in #haskell we are not control freaks.
14:03:50 <chrisdone> Peaker: the only lift function I use is liftIO. where are you using these lift functions?
14:03:50 <lispy> McManiaC: does that make sense?  If you use Rank2Types or RankNTypes you need it to express the level of polymorphism you want (the rank).  If you use lexically scoped type variables you need to use the 'forall' to say when you want the lexically scoped type vars
14:03:50 <kmc> just not IO, which is the one where most people want to do this first
14:04:07 <Peaker> chrisdone, how do you access the monad transformers?
14:04:10 <kmc> there is no *general* way to unwrap a monadic value, i.e. something that's part of the Monad type class
14:04:13 <Peaker> chrisdone, do you manually "lift . lift" in code?
14:04:15 <cydergoth> Peaker: so block = do { x <- parse .... ; return x } ? [Actually X is an Either Monad so I need to do the Just/Nothing case as well right?]
14:04:21 <McManiaC> lispy: yeh, I think
14:04:22 <chrisdone> Peaker: no, I define an instance of the class
14:04:37 <Peaker> chrisdone, You mean like "MonadState"?
14:04:47 <lispy> McManiaC: oh, I think existential types is another extension that requires it
14:04:50 <chrisdone> Peaker: sure, for example.  or MonadCGI
14:04:52 <Peaker> chrisdone, With GeneralizedNewtypeDeriving?
14:05:00 <Peaker> chrisdone, Well, I hate that class, it's a combinatorial explosion
14:05:20 <Peaker> cydergoth, Either doesn't have Just/Nothing, that's Maybe.  Either has Left/Right
14:05:40 <chrisdone> usually State is a transformer over instances of monads I've defined, I suppose
14:05:40 <cydergoth> Peaker: ooops, but you get my drift
14:05:40 <Peaker> cydergoth, Well, if you just do:  do { x <- blah ; return x }  then it is exactly equivalent to simply "blah"
14:05:44 <McManiaC> @pl \a b -> [a,b]
14:05:45 <lambdabot> (. return) . (:)
14:06:05 <Peaker> chrisdone, I prefer this explicit boilerplate than the MonadState/etc classes.. That way I get to give explicit names to my layers
14:06:31 <Peaker> chrisdone, http://github.com/Peaker/datastore/blob/master/src/Data/Transaction.hs
14:06:32 * kmc chants "monad zipper monad zipper"
14:06:33 <chrisdone> Peaker: why do you need to do that?
14:06:54 <Peaker> chrisdone, line 56
14:07:04 <Peaker> chrisdone, I might have two layers with "MonadState" in them
14:07:18 <Peaker> chrisdone, I might use nested monad transformers that happen to have a MonadState somewhere hidden within them
14:07:31 <Peaker> chrisdone, I guess the latter is solved by not exporting that instance
14:07:50 <lispy> McManiaC: if I had a time machine, I would go back to the Haskell 98 committee and let them know that 'forall' should be optional in Haskell98 :)
14:07:50 <Peaker> chrisdone, But I also dislike having O(N^2) class instances (N=number of transformers)
14:08:02 <Peaker> chrisdone, I think this solution scales better, just O(N) payment
14:08:10 <kmc> no it should only be written в€Ђ
14:08:34 <cydergoth> kmc: what's the difference between parse and runParser and runParserT then?
14:08:38 <lispy> kmc: I wish we could use Agda syntax :)
14:08:45 <lispy> But, Haskell syntax is good enough
14:08:46 <kmc> lispy, you can use в€Ђ with -XUnicodeSyntax
14:09:11 <chrisdone> Peaker: I dunno, I like being able to write getInput "a" instead of liftCGI $ getInput "a"
14:09:19 <kmc> cydergoth, i think the docs explain it pretty well
14:09:21 <Peaker> kmc, It's a bit annoying to have no obvious way of finding out how to write the things that are on-screen.. I'm going to have to make sure my abstract syntax editor makes it clear how to form any presented thing
14:09:24 <lispy> kmc: Ah.  I wanted that to allow \ to be replaced with a greek lambda, but I guess that is just too hard
14:09:36 <Peaker> chrisdone, Well, I am a fanatic, I guess :)
14:09:43 <Peaker> chrisdone, I don't mind the extra lifting
14:09:44 <kmc> lispy, yeah, О» is a lower-case letter and thus starts an identifier
14:10:06 <kmc> it'd be awfully rude to Greek Haskellers to tell them they can't start names with 'l'
14:10:06 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28047#a28047
14:10:16 <lispy> kmc: :)
14:11:04 <kmc> > let О»О¬ОјОІОґО± = () in О»О¬ОјОІОґО±
14:11:05 <lambdabot>   ()
14:11:32 <aristid> > let О»О¬ОјОІОґО± = "О»О¬ОјОІОґО±" in О»О¬ОјОІОґО±
14:11:33 <lambdabot>   "\955\940\956\946\948\945"
14:11:37 <Tomsik_> > () ()
14:11:38 <lambdabot>   Couldn't match expected type `() -> t' against inferred type `()'
14:11:42 <aristid> > let О»О¬ОјОІОґО± = "О»О¬ОјОІОґО±" in text О»О¬ОјОІОґО±
14:11:42 <lambdabot>   О»О¬ОјОІОґО±
14:11:46 <OscarZ> is there any haskell math channel btw? 
14:11:47 <chrisdone> Peaker: but I think our approach differs in that in this case of mine, I want to treat this monad as one flat monad, not layers. I don't really think of it as a stack once I've defined the instances and hidden it in a module somewhere
14:12:20 <Peaker> chrisdone, Ah, I expose an API where it is just a monad externally, but the stuff I expose is built using the knowledge that it is a stack
14:12:25 <chrisdone> (and if speed was a concern I'd stop transforming and just define one monad)
14:12:28 <kmc> OscarZ, there is #haskell-in-depth but it's often dead
14:12:33 <chrisdone> Peaker: sure
14:12:36 <kmc> OscarZ, we talk about maths in general here a lot, and in #haskell-blah
14:12:40 <Peaker> chrisdone, of course I do not expose the "stack-ness" beyond that single module that defines it
14:13:22 * kmc likes the design which Peaker and chrisdone are talking about
14:13:26 <OscarZ> yeah "general math" or "meta math" i was looking for, thanks.. 
14:13:39 <chrisdone> hmm, sure
14:13:59 <kmc> you can even expose your stack of transformers as a single transformer
14:14:08 <kmc> in case the user wants to glue on some more bells & whistles
14:14:25 <chrisdone> yeah, that's nice
14:16:02 <chrisdone> actually that's what peaker is doing, no?
14:16:16 <chrisdone> Transaction is a transformer
14:16:25 <Peaker> chrisdone, it's not MonadTrans
14:17:00 <cydergoth> I still don't get this :  I want the type signature of my method to be parseGCode :: String -> ([(GCodeCmd,String)],String) but I'm getting a type mismatch on the result of the parse which is saying the result of the parse is String -> [(GCodeCmd,String)] when I expect it to be [(GcodeCmd,String)]. So I'm getting a function back when I expect a list
14:17:06 <chrisdone> Peaker: ahh,  run it in a monad
14:17:11 <Peaker> chrisdone, the "m" there just allows runTransaction to go "Transaction m a -> m a" -- I don't want arbitrary monadic actions to be interlaced between my transaction primitives - it might break the transaction model
14:17:15 <chrisdone> sure
14:17:27 <ezyang> cydergoth: Did you pass enough arguments to the fucntion? 
14:17:38 <cydergoth> ezyang: I think so
14:17:54 <ezyang> Well go and check! 
14:17:56 <chrisdone> Peaker: I like your coding style. explicit imports for the readable win
14:17:58 <Peaker> chrisdone, maybe it's fragile as it is (monadic actions around the transaction can be a problem too) but it's fragile in one less possible way :)
14:18:05 <chrisdone> Peaker: do you use Emacs?
14:18:08 <Peaker> chrisdone, yeah
14:18:14 <Peaker> chrisdone, I *hate* open unqualified imports
14:18:22 <Peaker> chrisdone, they should not even be allowed, let alone be the default
14:18:57 <chrisdone> Peaker: I whipped up a little script to align the imports to be a bit more (for me at least) legible for scanning http://gist.github.com/453933
14:19:03 <monochrom> this is why you need IDEs rather than "any plain text editor"
14:19:05 <cydergoth> ezyang: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28048#a28048
14:19:38 <cydergoth> ezyang: so I think I am passing all the arguments
14:19:39 <Peaker> chrisdone, awesome, I'll try it out :)
14:19:40 <chrisdone> monochrom: elaborate?
14:20:16 <Peaker> chrisdone, I saw this style in snap
14:20:20 <monochrom> open unqualified imports are fine if you have IDEs reminding you which identifier comes from where
14:20:28 <Peaker> chrisdone, I'm not sure if I like the huge holes though :)
14:20:31 <chrisdone> Peaker: before you tell me -- I discovered a bug, or an un-handled case: import qualified X as Foo (a) -- it doesn't handle this case in the regex. I didn't realise it was possible until I used it in some code the other day, heh
14:20:34 <ezyang> What's your error? 
14:20:44 <chrisdone> Peaker: it's generally good at sticking within 80 columns at least
14:20:45 <Peaker> chrisdone, "qualified" should have been the default, or maybe unqualified closed import if () and no open unqualified
14:20:45 <kmc> eek code marching off the side of the screen
14:21:01 <Peaker> chrisdone, heh, not sure why it's allowed ya
14:21:16 <chrisdone> monochrom: sure -- but in this case I'm reading code on github, I'd have to paste into my editor to benefit, no?
14:21:22 <cydergoth> ezyang: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28049#a28049
14:21:50 <dafis> cydergoth: parsec's parse needs a sourc name :)
14:21:55 <dafis> source*
14:22:14 <ezyang> cydergoth: block is in a do block. I suspect that's not what you want. 
14:22:24 <dafis> cydergoth:                                   b <- parse wholeBlock "" (filter (not . isSpace) (stringToUpper firstline))
14:22:59 <monochrom> perhaps we also need the IDE to have a browser plugin
14:23:26 <cydergoth> daffis,ezyang: that change fixed it
14:23:33 <dcoutts_> monochrom: a documentation browser you mean? I agree
14:23:46 <monochrom> no, program browser
14:23:56 <dcoutts_> monochrom: top two things I want from an IDE are jump to definition and jump to documentation
14:24:26 <chrisdone> I'll add "give me the type of this local symbol" to that list
14:24:32 <monochrom> I am not sure I want jump. I am also not sure I want to see implementation all the time.
14:24:43 <Peaker> chrisdone, pretty cool script, thanks :) Why no (provide '...) on bottom so you can "require" it?
14:25:16 <chrisdone> Peaker: honestly I don't know how to do that. I suppose I'm lazy with elisp :-(
14:25:29 <dcoutts_> when I used VisualStudio back in the dark ages, one feature I liked is that you can just ctl-click an identifier (or some combo like that) to jump to def, then another easy way of jumping back, it maintains a stack so you can drill down and return.
14:25:33 <monochrom> at any rate, the github people are die-hard fans of "any text editor, any 1970s terminals" and can't be reasoned with. best to just wait for them to die.
14:25:50 <chrisdone> Peaker: I think it might end up in the next haskell-mode release unless the maintainer has already ported haskell-mode to using haskell-src-exts by then
14:26:09 <cydergoth> monochrom: everyone knows the one true line length is 132 anyway. All my old TTYs had that
14:26:39 <chrisdone> dcoutts_: that's definitely useful. I also like to have definitions quickly available
14:26:39 <proppy> thanks a lot for all your help today
14:26:43 <proppy> gnight,
14:27:02 <Peaker> chrisdone, add this "(provide 'haskell-align-imports)" to the bottom of your file. Then in your init.el, you can: "(require 'haskell-align-imports)" if it is in the import paths
14:27:19 <chrisdone> Peaker: oh, that's all! nice! :-)
14:27:25 * chrisdone updates the gist
14:27:55 <ezyang> Hot damn! 
14:28:02 <ezyang> n = fromIntegral n 
14:28:06 <ezyang> no wonder I'm infinite looping 
14:28:13 <monochrom> haha
14:28:14 * chrisdone tut-tut-tuts
14:29:02 <Peaker> I thought "let rec" in OCaml was crap. But then I had accidental recursions
14:29:04 <Peaker> and now I'd like to have it
14:30:00 <aristid> Peaker: there was some blog post on using monads or nested let to avoid it.
14:30:07 <aristid> i forgot where :/
14:30:26 <aristid> the way to do it with the Identity monad should be obvious though.
14:30:44 <monochrom> yeah
14:30:59 <Peaker> aristid, I don't intend to convert all my code to use nested lets just to avoid accidental recursion :)
14:31:05 <monochrom> also there is 99% chance you can easily reinvent things said of blogs. they're so trivial.
14:31:06 <chrisdone> I realised recently why the -Wall warnings about shadowing are useful other than for reading purposes. stopping you from doing let x = thingIWantToMultiply in .. let x = someThing * x in x
14:31:24 <monochrom> s/said of blogs/said on blogs/
14:31:33 <Peaker> monochrom, There's much insight in some blogs (augustuss, conal, sigfpe, ..)
14:31:48 <ionfish> ezyang: how do you find the time to write all the articles on your blog?
14:32:02 <monochrom> yeah that's the remaining 1%. and it's already a very generous estimate. maybe 0.1%.
14:32:05 <chrisdone> ionfish: waiting for infinite loops to finish
14:32:06 <aristid> monochrom: sometimes trivial insight is valuable too.
14:32:10 <ionfish> :)
14:32:22 <aristid> i mean, many things you COULD reinvent if you would think of them
14:32:55 <monochrom> perhaps it's 1% if you just count special-topic blogs, 0.1% if you count all blogs
14:33:11 <aristid> i thought we were talking about haskell blogs
14:33:59 <nolrai_portland> > Nothing `max` Just 2
14:33:59 <lambdabot>   Just 2
14:34:07 <aristid> :t max
14:34:07 <lambdabot> forall a. (Ord a) => a -> a -> a
14:34:13 <nolrai_portland> > Just 3 `max` Just 2
14:34:14 <lambdabot>   Just 3
14:34:20 <nolrai_portland> good
14:34:26 <aristid> > Nothing `max` Just ()
14:34:27 <lambdabot>   Just ()
14:34:44 <chrisdone> nolrai_portland: ka'e lojbo xu tavla
14:35:01 <cydergoth> ok, thx all made a lot of progress today
14:35:32 <chrisdone> jan247: there are a lot of jans on freenode, huh?
14:35:53 <monochrom> there are 100 times more guests than jans :)
14:36:43 <nolrai_portland> nolrai: unfortunatly not. I know how to say "Come here!" and "I love you" and thats about it.
14:36:52 <nolrai_portland> chrisdone: unfortunatly not. I know how to say "Come here!" and "I love you" and thats about it.
14:37:08 <chrisdone> <_< he's crazy
14:37:35 <chrisdone> nolrai_portland: nalnolrai pei
14:38:12 <aristid> chrisdone: what kind of language is that.
14:38:26 <monochrom> intelligently designed language
14:38:33 <chrisdone> nolrai_portland: to be fair "I love you" and "Come here!" are trivial :p "iu" and "ju'i"
14:38:56 <lispy> nolrai_portland: you live in Portlad
14:38:58 <chrisdone> aristid: lojban
14:38:59 <aristid> monochrom: do we understand natural languages well enough to construct a superior one?
14:38:59 <lispy> er, Portland?
14:39:00 <nolrai_portland> Well I know how to say the non emotive versions.
14:39:05 <nolrai_portland> yes
14:39:08 <nolrai_portland> Why?
14:39:21 <lispy> I'm in pdx too
14:39:24 <aristid> chrisdone: i see, thanks
14:39:41 <monochrom> aristid: perhaps we shouldn't understand natural languages and let them corrupt our design.
14:40:16 <chrisdone> that's a position I might side with
14:40:19 <aristid> monochrom: it depends on what your goal is
14:40:26 <monochrom> no one told the two Simons "do you understand c++ well enough to design haskell"
14:40:31 <aristid> if you want to construct a new natural language, you better understand the principles.
14:41:10 <chrisdone> monochrom: don't give the internet more credit than it's due. some idiot did
14:41:14 <kmc> hehe
14:41:40 <monochrom> ok, someone did, but intelligent people dismiss the idea
14:42:26 <aristid> the people who designed haskell understood the principles and research in the area of language design AFAIK
14:42:38 <aristid> compare this to, say, Go
14:42:46 <monochrom> anyway I will never want to create natural languages which to me are evolved monsters.
14:42:59 <chrisdone> agreed
14:43:09 <kmc> i heard that nobody will adopt a new programming language unless it has C-like syntax
14:43:16 <kmc> because syntax is the hard part of every language
14:43:17 <kmc> [/troll]
14:43:23 <aristid> i don't understand this negative sentiment against natural languages.
14:43:25 <chrisdone> aristid: well, the people who designed Lojban were linguists and logicians
14:43:26 <monochrom> understand the principles of languages, yes; understand the principles of natural languages, thanks but no thanks.
14:43:36 <pikhq> kmc: But what about C++?
14:43:43 <pikhq> How did that get popular?
14:43:44 <pikhq> :P
14:43:47 <Peaker> kmc, It is one of the "hard parts" - in that people usually rule out "ugly syntax", and for almost all of us, "foreign syntax" is "ugly syntax"
14:44:03 <Peaker> kmc, It's hard to keep at learning about a syntax that your immediate instinct is "ugly"
14:44:12 <Peaker> (or about anything behind it)
14:44:15 <lispy> pikhq: AT&T.  Lots of companies went, "Oh, shiny, AT&T is awesome.  Let's by like them."
14:44:17 <kmc> pikhq, it has C like syntax.  look at them curly braces!
14:44:54 <aristid> chrisdone: interesting
14:45:00 * pikhq prefers parsable languages
14:45:19 <chrisdone> Peaker: backing you up with amusing evidence: I pasted a Haskell one liner for a simple problem to a Lisper. he said it was unreadable. this coming from soneone who just wrote #'cddr to me as part of his solution. foreign = ugly, indeed
14:45:26 <aristid> chrisdone: my intuition is that we understand programming languages much better than natural languages because they are simpler
14:46:20 <chrisdone> aristid: it turns out you can get by pretty well in designing a language with what understanding we have now. there's a complete translation of Alice in Wonderland in Lojban
14:46:49 <chrisdone> there are difficulties, of course
14:47:02 * fryguybob thinks fruit flies like a banana.
14:47:18 <Peaker> chrisdone, Yes. It took me 2-3 weeks to get over the "yuck Haskell syntax is ugly" stage. And during those weeks I thought it would be a good idea for Haskell to just adopt some C like syntax as if the difference is just silly and unjustified. (Of course I was wrong and learned that later.)
14:47:19 <chrisdone> "ko" is an imperative word, "mo" is a question word. the sentence "ko mo" is therefore open to interpretation
14:47:21 <lispy> time flies like an arrow; fruit flies like a banana
14:47:27 * ddarius thinks fruit flies like time.
14:47:29 <ezyang> :6) 
14:47:33 <Peaker> chrisdone, Now I love Haskell syntax and don't see how everyone else messed syntax up so bad :)
14:47:51 <monochrom> @quote monochrom arrow
14:47:52 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
14:48:04 <monochrom> @quote monochrom arrow.*monad
14:48:04 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
14:48:06 <chrisdone> Peaker: I came from Scheme to Haskell, I found it ugly too. it looked like line noise in comparison. it still does, it just bothers me less
14:48:10 <monochrom> haha that one!
14:48:18 <chrisdone> monochrom: haha
14:48:41 <aristid> coming from c++, the haskell syntax was certainly NOT what bothered me at first.
14:48:56 <ddarius> aristid: Of course.  Programming languages are -much- smaller, -much- more regular, don't evolve, and are unambiguous; what the parser accepts is right and what it doesn't accept is wrong.
14:49:54 <aristid> i was positively surprised by google's voice search feature
14:49:58 <chrisdone> (there is a (context-sensitive) parser for Lojban, but yeah, the sentence above, for example, is ambiguous. it is one of few exceptions, though)
14:50:41 <kmc> people who come from C, C++, or Java tend to think Haskell syntax is beautiful right away
14:50:47 <kmc> i can see why others would have the opposite impression
14:51:13 <Peaker> kmc, I came from Python
14:51:16 <aristid> chrisdone: if you have learned lojban... is it expressive?
14:51:27 <lispy> I came from common lisp and i kept wondering why operators were allowed
14:51:28 <chrisdone> Peaker: ah, I remember. you actually really don't like Lisp at all. as a long time user of it, you come to really appreciate it's homogenicity (homogenousness? homogeneity? sameness?)
14:51:29 <kmc> Python has 'pretty' syntax but it's crippled in various ways
14:51:31 <aristid> Peaker: both use indentation as syntax :P
14:51:31 <[bjoern]> I am looking for a module that helps me to hold character classes (sets that contain unicode code points, that is, integer values from 0 to 0x10FFFF). I need to do things like compute the intersection of two character classes or their complement.
14:51:32 <lispy> infix was weird
14:51:38 <fryguybob> It seems like in most languages you have to be more verbose to be more general, Haskell it is usually the other way around.
14:51:46 <kmc> like, whitespace dependence without an equivalent freeform syntax... what were they thinking?
14:51:47 <Peaker> chrisdone, Yeah, I think Lisp's "power" is based on a fallacy :)
14:51:49 <tolkad> Can you pattern match for function application?
14:51:59 <kmc> tolkad, what do you mean?
14:52:05 <conal> Bertrand Russell said "Everything is vague to a degree you do not realize till you have tried to make it precise."  We had to try making programming languages precise, since we wanted automatic execution.  We haven't had this same requirement for natural languages.  (Though Leibniz & Russell were inspired to.)
14:52:13 <tolkad> like f (Type (function arg)) = arg
14:52:14 <Peaker> chrisdone, The fallacy that "Making AST's trivial to generate" necessarily means "Adding any language feature from anywhere becomes trivial"
14:52:18 <kmc> tolkad, no
14:52:26 <chrisdone> aristid: what do you mean by ``expressive''? what kind of answer do you want?
14:52:58 <conal> Peaker: maybe because Lisp solves syntax but not semantics.
14:53:13 <tolkad> How would you construct a type which matches any function with some result, regardless of how many arguments it has?
14:53:22 <aristid> chrisdone: is it hard to express thoughts, feelings and discussion in lojban?
14:53:27 <tolkad> with a result of some type*
14:53:29 <kmc> tolkad, don't know what you mean?
14:53:32 <Peaker> conal, Yeah, making syntax easier to work with does not mean Lisp becomes a superset of all existing languages, in terms of power
14:53:37 <conal> tolkad: a -> b
14:53:44 <Peaker> conal, But lots of Lispers argue that it does
14:53:46 <conal> tolkad: since b may be function type (and so on)
14:53:46 <tolkad> conal: but that doesn't match c -> a -> b
14:53:48 <AnAdorableNick> aristid: It's not difficult.
14:53:53 <chrisdone> Peaker: that is a fallacy, yes. unrelated to the *appearance*, though. which really can be very nice. I know, though; I often hear "that's just syntactic sugar" of a feature in Haskell. it's not, it's a complex type system feature that would take you a long time to implement and test, to get people to use and understand, etc.
14:54:09 <kmc> tolkad, the type (a -> b) unifies with any function type whatsoever
14:54:18 <ddarius> Peaker: I have pretty long debates against the over-hyping of CL-style macros on LtU.
14:54:21 <kmc> when it unifies with (c -> d -> e) you get a = c and b = (d -> e)
14:54:25 <tolkad> kmc: oh, I see
14:54:25 <kmc> which is probably not what you want here
14:54:31 <conal> kmc: thx
14:54:32 <Peaker> chrisdone, Moreover, implementing language features as macros doesn't mean they can actually compose into a single language
14:54:40 <kmc> tolkad, perhaps you need to build a type class or a type family
14:54:43 <Peaker> ddarius, can you link?
14:54:52 <kmc> tolkad, perhaps we could use more detail about what you're actually doing
14:54:58 <AnAdorableNick> aristid: What do you mean "expressing discussion" in Lojban?
14:55:21 <Peaker> chrisdone, I wonder how "Qi" compares to Haskell's type system, for example
14:55:24 <AnAdorableNick> aristid: Metalinguistic expression is also possible in Lojban.
14:55:26 <aristid> AnAdorableNick: if you have learned it well, can you fluently discuss in it?
14:55:26 <chrisdone> aristid: feelings are trivial. thoughts are also expressive. discussion has a bunch of interjections, like "excuse me", "I understand", "go ahead", "I'm not sure I understand", etc. I think you'll have to be more specific to get a useful answer
14:55:30 <Peaker> It definitely has limitations on what it can do even if because it is optional
14:55:44 <tolkad> kmc: I want to be create a data constructor for type T which is passed a function with range T with any number of arguments of type T and a list of those arguments
14:55:49 <chrisdone> Peaker: indeed
14:55:53 <AnAdorableNick> aristid: Yup.
14:55:57 <tolkad> s/to be create/to create/
14:56:00 <kmc> tolkad, why?
14:56:11 <tolkad> kmc: because it's cool
14:56:19 <kmc> ok
14:56:21 <tolkad> so can I?
14:56:27 <kmc> it's cool, but not very haskelly
14:56:30 <kmc> but there is probably a way yes
14:56:47 <kmc> well the cop-out answer is that a function taking an indeterminate number of T and returning T should have type [T] -> T 
14:57:06 <aristid> chrisdone: well, let me ask a different question: how well do you master lojban?
14:57:11 <ddarius> Peaker: http://lambda-the-ultimate.org/node/569#comment-4594  this thread
14:57:19 <tolkad> kmc: no, that wont work
14:57:21 <chrisdone> aristid: I was fluent modulo not knowing enough vocabulary
14:57:23 <kmc> tolkad, why not?
14:57:52 <Peaker> ddarius, thanks
14:57:57 <tolkad> kmc: because the whole reason I'm doing this is because I want to pattern match for function application
14:58:07 <aristid> chrisdone: do you think that it is possible to become completely fluent?
14:58:12 <kmc> ah, i thought you said you were doing it "because it's cool"
14:58:15 <chrisdone> aristid: I can express time, numbers, distance, qualities, events, logic, sets, masses, individuals, questions, conversation, greetings, emotions
14:58:19 <tolkad> kmc: yeah that too
14:58:32 <monochrom> sorry, you can't pattern-match for function application.
14:58:55 <tolkad> but I want too... otherwise I need to create a constructor for every function...
14:59:39 <chrisdone> aristid: I think it's possible if you properly revise like you would a real language and actually talk to people in it, i.e. proper immersive learning. you can't become fluent learning French just by sitting reading some tutorials, a dictionary and flashcards, which is what a lot of Lojbanists do. you need to be immersed and forced to use it, which is what no Lojbanists I know of have done, unless you count chatting on IRC, but I don't
14:59:43 <aristid> chrisdone: a list of what can be done does not help me, because i don't know which "features" a complete language needs. so i'm asking how it "feels"
15:00:11 <tolkad> maybe I could just create a constructor for every function with a specific number of arguments...
15:00:23 <kmc> tolkad, maybe you want to use Data.Dynamic instead
15:00:31 <lispy> chrisdone: So, start blogging in lojban
15:00:36 <tolkad> maybe I should show my code
15:00:51 <chrisdone> lispy: I did. I don't think blogging is enough
15:00:56 <aristid> lispy: i think something with more immediate feedback is better for immersion
15:00:59 <lispy> ah
15:01:01 <winxordie> people still talk in lojban?
15:01:15 <lispy> chrisdone: spawn offspring and only teach them lojban :)
15:01:22 <kmc> haha
15:01:32 <aristid> lispy: and isolate them from society?
15:01:36 <duairc> winxordie: Is Lojban perceived to be dead?
15:01:36 <kmc> one generation of native lojban speakers would be enough to totally destroy the logical purity of the language
15:01:39 <monochrom> (at least lojban is not esperanto)
15:01:42 <AnAdorableNick> winxordie: Of course.  Do people still speak English? :)
15:01:43 <lispy> aristid: Teaching them only lojban will do that, yes
15:01:49 <kmc> and replace it with something organic and fantastically interesting
15:01:51 <chrisdone> aristid: well, you start to think in it. the discursives are shorter and more consistent. making up words is easy. you can take simple words and make a new word out of them. it started to affect my english vocabulary, I'd forget words which my brain didn't consider composite or fundamental
15:02:18 <aristid> lispy: if you don't also isolate them physically from society they will probably learn <language of the surrounding society>
15:02:23 <winxordie> duairc: well, the linguists *I* talk to claim it is.
15:02:53 <duairc> Peope are speaking it in #lojban right now :)
15:02:57 <aristid> winxordie: do they think it is poorly designed?
15:03:32 <chrisdone> kmc: the "logical" part only refers to the fact and/if/or/iff/not have a proper truth table, so {na ja} (NOT OR) is used for implication, etc. it doesn't mean "reasonably defined", a lot of it is just what the linguists thought would be interesting or a good idea
15:03:33 <winxordie> aristid: that's the argument, yea. as to how, I didn't gather that much.
15:03:45 <kmc> chrisdone, i also mean the very regular syntax, etc
15:03:51 <chrisdone> sure
15:04:20 <aristid> from what i understand, things like rhythm shape a language as well
15:04:24 <winxordie> AnAdorableNick: that's not a fair comparison. "Do people speak minor-language-X?" "Well sure, do people speak lingua-franca?"
15:04:46 <chrisdone> there's a problem that happens, as it does in any language, even programming languages, called "folk functionalism", where someone says "wouldn't it be nice if we could say X?" and people start to use it immediately because it sort-of makes sense, but hasn't been properly thought-through
15:04:47 <monochrom> "do people program in haskell?" XD
15:05:06 <aristid> monochrom: no, only mathematicians.
15:05:20 <aristid> (i love the absurdity of that statement :P)
15:05:34 <Peaker> how can I know if I get tail-call optimizations? Will that be visible in GHC "Core"?
15:05:50 <monochrom> yes you can see it in core
15:07:11 <monochrom> err, you won't see a "goto" in core. but you will see which calls are tail calls in core, and you can trust they become gotos in assembly
15:07:54 <sm> making sure to export LANG=en_US.UTF-8 for every haskell app you run is a bit of a drag, isn't it ?
15:08:06 <sm> since ghc 6.12
15:08:20 <chrisdone> aristid: we can continue this in #haskell-blah if you like
15:08:20 <monochrom> yeah, all non-unicode platforms should be killed
15:08:32 <duairc> Some of use locales other than en_US :(
15:08:35 <AnAdorableNick> winxordie: Yep.  Why would people suddenly stop speaking in Lojban?
15:08:51 <sm> s/en.*?8/LOCALE_OF_YOUR_CHOICE/
15:09:01 <AnAdorableNick> winxordie: It's a wonderful language.
15:09:24 <tolkad> nevermind, this was a bad idea
15:09:34 <tolkad> actually a terrible one
15:09:35 <winxordie> AnAdorableNick: No, that's not what I was claiming. It was more along the line of substituting anything for X in "Do people speak minor-language-X?" "Well sure, do people speak lingua-franca?"
15:09:35 <Peaker> ddarius, good comments there
15:09:40 <c_wraith> sm: is that a pain?  It's my experience that just setting the encoding right system-wide does what I want.
15:09:43 <kmc> tolkad, probably :) but i have some code for you anyway
15:09:45 <monochrom> well if you're in mainland china you can use LANG=zh_CN.UTF-8 which is still fine
15:10:05 <tolkad> kmc: really?
15:10:23 <winxordie> AnAdorableNick: I'm sure it's a lovely language. I have no experience to claim one way or the other.
15:10:26 <kmc> tolkad, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28052#a28052
15:10:54 <kmc> tolkad, the type of toListF is effectively (a -> a -> ... -> a -> Result a) -> ([a] -> a)
15:10:58 <tolkad> kmc: thanks
15:11:03 <sm> c_wraith: I'm finding that it is, because I don't just work on one system, and also I'm trying to document a build system to be used by non-haskellers which happens to use some haskell tools (hakyll)
15:11:11 <kmc> tolkad, i agree though that this is a bad idea, and Data.Dynamic may be a better idea
15:11:26 <sm> and the "export LANG=... so haskell tools don't break" instruction looks pretty lame :)
15:11:48 <sioraiocht> Arnar: ping?
15:12:06 <c_wraith> sm: but really, *any* tools that treat text as text, rather than bytes, should need those same environment variables set.
15:12:31 <monochrom> even if it's LANG=zh_CN.GB18030 it's fine, it may even induce the haskell program to do the right thing.
15:13:02 <monochrom> at any rate I have no sympathy for people or platforms that do not set LANG properly
15:15:16 <dolio> Oh man, new Catsters!
15:15:37 <monochrom> if your program will work with files you are sure are in UTF-8, you can use hSetEncoding.
15:16:01 <dolio> More than 2 years in the making.
15:16:26 <monochrom> if the files are in user's encoding, you should trust LANG
15:17:24 <monochrom> what is the topic of the latest catster lecture?
15:17:37 <dolio> It's part 3 of metric spaces and enriched categories.
15:22:45 <ddarius> aristid: Mathematicians are a different species?
15:23:01 <ddarius> dolio: !!!!
15:23:07 <sm> what's the best way to render .txt files with hakyll ?
15:23:24 <fryguybob> Have a lovely weekend #haskell.
15:23:31 <Peaker> This causes a stack overflow:  arr <- newListArray (0, n-1) =<< replicateM n randomIO ; print =<< readArray arr (n-1)
15:23:44 <Peaker> How can I get newListArray to make a strict array?
15:23:56 <aristid> ddarius: that's what you would read if you would try to read something logically consistent into it
15:25:37 <sm> ah, static "file.txt" works well
15:25:51 <hpc> :t static
15:25:52 <lambdabot> Not in scope: `static'
15:25:55 <monochrom> sm: perhaps put text inside <pre></pre>, and design a very nice css style for it
15:26:23 <monochrom> oh you mean as a user of hakyll
15:26:53 <sm> yup. But thanks :)
15:27:11 <kmc> arrays are overrated
15:28:48 <cydergoth> kmc: I disagree, there are some areas where arrays are very essential
15:28:57 <cydergoth> kmc: graphics is one
15:29:06 <kmc> cydergoth, right, overrated != useless
15:29:10 <monochrom> that is why "overrated" rather than "100% useless"
15:29:22 <monochrom> "overrated" means most people abuse it
15:29:39 <monochrom> another example: blogs are overrated
15:29:39 <cydergoth> monochrom: most people abuse everything
15:29:58 <monochrom> oh, we don't have enough people abusing haskell just yet :)
15:30:07 <monochrom> (also they can't abuse me yet)
15:30:07 <kmc> cydergoth, what i mean, specifically, is that IntMap is nearly as fast as arrays for many purposes, plus has nice sharing between versions
15:30:20 <kmc> sometimes you do really need an array
15:30:29 <kmc> and if you're not doing updates, it's not too bad in Haskell
15:31:03 <kmc> Peaker, any reason you're not using an unboxed array?
15:31:07 <cydergoth> kmc: really? Intmap is fast enough? Wow
15:31:25 <cydergoth> kmc: Someone must have put a lot in to make that happen
15:32:13 <kmc> cydergoth, http://research.microsoft.com/en-us/um/people/simonpj/papers/containers/containers.pdf
15:32:30 <monochrom> anyway, switching from array to intmap (or any container) will not make anything stricter in the "replicateM n randomIO" application.
15:32:37 <Peaker> kmc, Why is that array necessarily boxed?
15:32:56 <kmc> Peaker, well, you asked for a strict array.  if it's unboxed then it's strict by definition
15:33:01 <cydergoth> kmc: reading.....
15:33:03 <Peaker> kmc, ah, heh
15:33:04 <CakeProphet> @hoogle IO a
15:33:04 <lambdabot> Did you mean: :: IO a /count=20
15:33:04 <lambdabot> module Data.Graph.Inductive.Monad.IOArray
15:33:04 <lambdabot> Text.Html action :: String -> HtmlAttr
15:33:08 <CakeProphet> @hoogle IO ()
15:33:08 <lambdabot> Network.BSD endHostEntry :: IO ()
15:33:09 <lambdabot> Network.BSD endNetworkEntry :: IO ()
15:33:09 <lambdabot> Network.BSD endProtocolEntry :: IO ()
15:33:40 <kmc> cydergoth, IntMap is much faster than (Map Int), because it uses the internal structure of the Int rather than only doing comparisons
15:34:24 <cydergoth> kmc: yes, rdbms indices in our core product do the same
15:34:24 <kmc> the hashmap library provides modules that use IntMap to implement a hash trie
15:36:15 <monochrom> @type evaluate
15:36:16 <lambdabot> Not in scope: `evaluate'
15:36:21 <kmc> i worked somewhere where we had various disasters relating to concurrent use of a hash table
15:36:50 <Peaker> kmc, I wish GHC just chose IntMap whenever Map Int was used
15:37:03 <kmc> and i wonder if most of this could be avoided using a persistent hash trie + atomic compare-and-swap to set the latest version
15:37:40 <monochrom> newListArray (0, n-1) =<< replicateM n (randomIO >>= evaluate)
15:37:48 <Peaker> strictify = (>>= \x -> x `seq` return x)
15:37:55 <monochrom> evaluate is from Control.Exception
15:37:56 <Peaker> oh, >>= evaluate is good :)
15:38:10 <kmc> but we also couldn't afford garbage collection so meh
15:38:14 <Peaker> I guess evaluate = \x -> x `seq` return x ?
15:38:27 <monochrom> it's a bit sad that System.Random is pretty nonstrict in generator state
15:38:28 <Peaker> monochrom, I was just now using strictify randomIO that way
15:38:31 <sshc> \la
15:38:37 <ddarius> Peaker: No.
15:38:52 <ddarius> The evaluate only forces it's argument when it is actually executed.
15:38:55 <monochrom> yeah perhaps relying on a Control.Exception provision is ugly :)
15:38:57 <Peaker> ah
15:39:26 <nolrai_portland> @pl \a b -> (combine a b, ())
15:39:27 <lambdabot> flip flip () . ((,) .) . combine
15:39:33 <cydergoth> kmc: so are the optimisations in that paper already in GHC 6.12.x?
15:39:39 <kmc> cydergoth, don't know
15:39:53 <nolrai_portland> @ty flip flip
15:39:54 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
15:40:31 <nolrai_portland> @ty flip
15:40:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:40:42 <ddarius> monochrom: Yeah, there's probably no benefit to it.  We -really- need a strict pair type in the Prelude (and the libraries to use it).  A head strict list would also be very nice.
15:41:07 <kmc> Peaker, i think it'd be bad to make the existing Data.Map nonparametric, but it'd be great to have a new Data.FancyMap which is a type family
15:41:14 <kmc> there's various work on adaptive containers already
15:41:28 <ddarius> @hackage adaptive
15:41:28 <lambdabot> http://hackage.haskell.org/package/adaptive
15:41:30 <Peaker> kmc, Well, why expose any but the adaptive containers?
15:42:02 <ddarius> @hackage adaptive-containers
15:42:02 <lambdabot> http://hackage.haskell.org/package/adaptive-containers
15:42:17 <kmc> Peaker, (Map Int) beats IntMap in some pathological cases
15:43:22 <kmc> S.fromList $ map (2^) [0..63]
15:44:22 <jbapple> There is a fix for that kind of pathology for the case of string tries
15:44:41 <jbapple> But for int tries, where full-element comparisons are pretty fast, I don't know of one
15:45:29 <kmc> what's the fix jbapple?
15:46:17 <jbapple> kmc: you use a balanced tree, but keep track of your letter comparisons so that you don't repeat too many, the way you would if you used balanced trees
15:46:21 <jbapple> let me find you a link
15:46:28 <jbapple> I think they're called string b-tries
15:46:30 <monochrom> "A correct definition is  evaluate x = (return $! x) >>= return"  maybe you could steal that for strictify :)
15:47:26 <jbapple> kmc: string b-tree: http://scholar.google.com/scholar?cluster=8403065314983295610
15:47:34 <kmc> thanks jbapple
15:48:17 <jbapple> I think they could be written in Haskell, and might make some things must faster
15:48:59 <jbapple> In my limited experiments, bytestring-tries were slower than Data.Set/Map
15:49:18 <Philonous> monochrom: How is that different from "evaluate x = (return $! x)" ?
15:49:30 <Peaker> monochrom, why is the ">>= return" needed?
15:49:36 <jbapple> And, in general, I think tries with higher-ary nodes might speed up haskell tries
15:49:47 <ddarius> Philonous: (return $! undefined) `seq` () = undefined, evalute undefined `seq` () = ()
15:49:50 <kmc> yeah, binary trees kind of suck
15:49:54 <kmc> especially for cache locality
15:49:57 <jbapple> I wanted to make a patch for IntSet, but I haven't gotten around to it
15:49:59 <Peaker> ah
15:50:02 <kmc> i wonder if pure judy arrays are possible, or anything close
15:50:05 <monochrom> Ah! It is written so as to ensure evaluate "x `seq` y  ==>  y". Whereas (return $! x) `seq` y ==> forces x first
15:50:38 <jbapple> I would be concerned that judy trees had a fanout that was too large
15:50:43 <Peaker> But it depends on the implementation of (>>=), doesn't it? if it doesn't wrap the result in a lazy wrapper..
15:50:51 <monochrom> OTOH "evaluate x >>= f      ==>  (return $! x) >>= f" implies that for many applications you can just use (return $! x)
15:50:58 <Peaker> (>>= return) doesn't necessarily make a bottom non-bottom
15:51:25 <Peaker> Well, evaluate is specific to IO :)
15:51:33 <Peaker> so I guess that there it does..
15:51:33 <monochrom> Yeah let's assume IO's >>=
15:51:35 <Philonous> Peaker: I wonder if this doesn't actually break the monad laws
15:51:45 <ddarius> Philonous: It blatantly states that a monad law fails.
15:52:03 <jbapple> kmc: One thing I have been thinking about is trees with higher fanout near the root, but maintaining no pointers to the root, only to the left- and right-most leaves
15:52:16 <ddarius> It is saying (return $! x) >>= return /= return $! x
15:52:26 <jbapple> (the pointer locations are similar to H&P's finger trees in that way)
15:52:39 <Philonous> ddarius: Ah, great, so the problem we introduced monads for in the first place doesn't even apply...
15:53:03 <jbapple> Then the root node is expensive to modify (since it involves a copy of a high-fanout node), but rarely needs to be modified
15:53:35 <ddarius> jbapple: Doesn't the root node need to be modified in every update/insert?
15:53:50 <ddarius> (Unless you are talking about mutable trees.)
15:53:55 <jbapple> ddarius: not if you don't keep a finger/pointer to the root node
15:54:09 <jbapple> maintain the tree with pointers only to the left and right-most edges
15:54:17 <jbapple> to get to the root, you traverse up the tree
15:54:26 <ddarius> jbapple: Okay.
15:54:35 <jbapple> just liek in a regular tree, to get to the root you traverse down the spine
15:54:50 <jbapple> I wrote a long post about that on SO the other day
15:55:24 <jbapple> reversing the spines is an essential ingredient in 7 or 8 functional data structures
15:55:27 * ddarius considers "doing" CTM in Haskell.
15:55:43 <ddarius> @google recycling continuations
15:55:45 <lambdabot> http://www.cs.indiana.edu/~jsobel/Recycling/recycling.html
15:55:45 <lambdabot> Title: Recycling Continuations
15:55:58 <jbapple> I think I like it because the answer to any data structure problem can be "oh, you're just looking at it upside down" :-)
15:56:31 <ddarius> jbapple lives in a world where trees grow up.
15:57:02 <jbapple> crazy, right? :-) Leaves at the top of the page! It's communist, I tell you!
15:57:08 <kmc> what about a tool that runs your code over and over with differently-shaped trees?
15:58:07 <jbapple> kmc: What about it?
15:58:09 <ddarius> kmc: Which shape is best is very likely data dependent.
15:58:25 <ddarius> There are tree libraries that dynamically change algorithm.
15:58:44 <kmc> ddarius, sure.  i'm assuming you have some benchmark suite which is representative of the problems you expect to encounter in actual use
15:58:51 <kmc> profile-directed optimization
15:59:06 <kmc> anyway i'm sure this has been studied
16:03:06 <fxr> http://gist.github.com/488191 why am I getting infinite type?
16:08:37 <lispy> fxr: Well, it says your definition of return is wrong, but I don't see the problem yet
16:09:57 <ddarius> fxr: a is not a tuple
16:11:07 <lispy> oh, that type synonym i sneaky, I didn't even see it
16:11:23 * hackagebot bluetile 0.5 - full-featured tiling for the GNOME desktop environment  http://hackage.haskell.org/package/bluetile-0.5 (JanVornberger)
16:12:44 <lispy> fxr: I don't understand how you'll implement that
16:12:57 <lispy> fxr: Does stream have an empty constructor?
16:23:54 <bos> @src showString
16:23:55 <lambdabot> Source not found. Where did you learn to type?
16:24:35 <Cads> I've got a data type Vector = Uarray Int Double, and I was wondering if I could make it an instance of Num so that I can use the + and - operators
16:24:52 <lispy> Cads: yes, that should be possible
16:25:02 <lispy> Cads: the weirdness is that you need to define signum and abs too
16:25:13 <dons> Cads: you could use the instances defined in the hinze-streams package
16:25:25 <dons> there's a well-defined instance of Num for infinite numeric sequences
16:25:35 <dons> and port    them to Vector
16:25:40 <Cads> nice
16:25:51 <Cads> I'll look it up
16:26:59 <kmc> Cads, it might be better if you wrap it in newtype, rather than adding an orphan instance for UArray
16:30:50 <CakeProphet> @hoogle MonadPlus
16:30:51 <lambdabot> Control.Monad class Monad m => MonadPlus m
16:31:36 <CakeProphet> @hoogle (MonadPlus m) => Bool -> a -> m a -> m a 
16:31:36 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
16:31:36 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
16:31:36 <lambdabot> Data.Sequence update :: Int -> a -> Seq a -> Seq a
16:32:13 <CakeProphet> @hoogle (MonadPlus m) => Bool -> m a -> m a 
16:32:13 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
16:32:13 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
16:32:13 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
16:33:00 <CakeProphet> is there f t m = if t then m else mzero  ? 
16:33:04 <CakeProphet> somewhere standard?
16:33:12 <Peaker> @src guard
16:33:13 <lambdabot> guard True  =  return ()
16:33:13 <lambdabot> guard False =  mzero
16:33:25 <CakeProphet> ah... almost.
16:33:29 <ddarius> So that would be guard t >> m
16:33:35 <Peaker> f t m = guard t >> m
16:33:38 <fxr> a is not a tuple, thansk
16:33:48 <CakeProphet> hmmm... wait
16:34:01 <CakeProphet> how does guard t affect m in that expression?
16:34:06 <CakeProphet> wouldn't it simply be ignored?
16:34:20 <ddarius> mzero >> m = mzero
16:34:32 <CakeProphet> oh. a law?
16:34:44 <ddarius> Yes.
16:34:53 <CakeProphet> is [a] a MonadPlus?
16:35:04 <CakeProphet> > [] >> "hello"
16:35:05 <lambdabot>   ""
16:35:08 <CakeProphet> hmmm...
16:35:15 <benmachine> > mzero :: [a]
16:35:16 <lambdabot>   []
16:35:18 <CakeProphet> ah, duh. :P
16:35:33 <CakeProphet> guard is in Control.Monad correct?
16:35:37 <benmachine> yes
16:35:57 <fxr> lispy: http://gist.github.com/488191 includes the definition of Stream el
16:36:55 <fxr> I cannot see the problem with return.
16:36:57 <CakeProphet> hmmm... that's much more pretty than what I was doing before. :)
16:37:03 <lispy> fxr: Well, the problem is that you need to apply k to (a, {- something -})
16:37:19 <lispy> fxr: return a = Cont $ \k -> k (a, EOF)
16:37:25 <lispy> That should type check, even if it's wrong
16:37:39 <fxr> but it's wrong
16:37:42 <lispy> er, EOF Nothing, I suppose
16:37:49 <lispy> Chunk [], then
16:37:51 <fxr> return get's an internediate and returns M a
16:37:56 <fxr> a is a tuple here.
16:38:03 <lispy> No
16:38:07 <lispy> a is arbitrary
16:38:13 <EvanR> "lisper-first-look-at-haskell" is pretty interesting
16:38:27 <fxr> hmm sure
16:38:29 <EvanR> http://bit.ly/cUC8NR
16:38:35 <lispy> Because you could do: return 1 :: ContM r el Int
16:39:02 <fxr> hence it cannot be an instance of Monad...
16:39:05 <lispy> that would be, return 1 = Cont $ \k -> k 1
16:39:41 <fxr> yeah I gut it
16:39:41 <lispy> but, k :: (a, Stream el) -> r
16:39:45 <fxr> got it, thanks
16:39:46 <lispy> cool
16:40:46 <fxr> that's where I start Rank2Types, where I'll represent them as functions not data types...
16:41:17 <CakeProphet> @hoogle Bool -> m a -> m a -> ma
16:41:17 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
16:41:17 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
16:41:17 <lambdabot> Test.QuickCheck.Batch TestOptions :: Int -> Int -> Bool -> TestOptions
16:41:25 <CakeProphet> @hoogle Bool -> m a -> m a -> m a
16:41:25 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
16:41:25 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
16:41:25 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
16:41:32 <CakeProphet> @hoogle (Monad m) => Bool -> m a -> m a -> m a
16:41:33 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:41:33 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
16:41:33 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
16:41:45 <fxr> hmm will be a bit complicated
16:41:58 <CakeProphet> @hoogle (Monad m) => m Bool -> m a -> m a -> m a
16:41:58 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:41:58 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
16:41:58 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
16:42:07 <kmc> yeah static typing sucks, it takes away my freedom to write incorrect programs
16:42:09 <CakeProphet> ...er, sorry for the spam. :P
16:42:21 <Peaker> kmc, hehe, yep
16:42:46 <CakeProphet> kmc:  static typing only really sucks when it has to be explicit. I enjoy that I don't have to write out type signatures when prototyping in Haskell.
16:42:50 <fxr> it does the job which I'll do by bug hunting
16:42:54 <kmc> also i don't really want to read seven paragraphs of pretentious bullshit about japanese martial arts first
16:43:00 <Peaker> CakeProphet, I usually write the types first, makes it easier
16:43:10 <Peaker> kmc, Yes, that's a good sign the article is crap
16:43:11 <CakeProphet> depends on what I'm doing. Sometimes I just know what to do.
16:43:42 <kmc> Peaker, i'd start with the first sentence: "I started learning Haskell a week ago and after few days I already wrote a lengthy essay about Haskell"
16:43:53 <Peaker> kmc, heh yeah
16:43:58 <kmc> there's a whole cottage industry of these of course
16:44:02 <kmc> just like monad tutorials
16:44:09 <Peaker> kmc, I hope his blog doesn't have many innocent/gullible readers
16:44:24 <EvanR> kmc: lol
16:44:42 <CakeProphet> so if monads are spacesuits
16:44:48 <listofoptions> lmao
16:44:52 <benmachine> gullible people on the internet? nah.
16:44:53 <CakeProphet> what typeclass should I use if I want SPACESHIPS
16:44:54 <EvanR> "it is probabaly useless to anyone but lispers"
16:44:59 <EvanR> i wonder how true this is
16:45:09 <EvanR> (the article, that is)
16:45:54 <kmc> a whole cottage industry of people debunking the Haskell hype after three days of using it
16:46:04 <monochrom> give up hope. there are too many gullible people
16:46:23 <EvanR> one of the coolest features of lisp is apparently the ability to put any value whatsoever into it
16:46:45 <kmc> the cool thing about Lisp is that it lets me write a malfunctioning program no matter how confused i am
16:47:00 <Peaker> EvanR, one of the sad things is that this dude certainly haven't heard of existential types, and he already rules out homogenous containers
16:47:01 <monochrom> presumably someone can also say something about self-modifying programs being cool
16:47:07 <EvanR> i cant say ive ever need to do this besides statically sized tuples
16:47:53 <monochrom> anyway why waste your time on silly bloggers
16:48:02 <EvanR> guys. lisp is from a heavenly inspired dream
16:48:06 <Peaker> monochrom, they're wrong.. on the internet!
16:48:07 <EvanR> you cant deny
16:48:22 <Peaker> monochrom, It's annoying when later people I talk with cite these kinds of things
16:49:11 <ddarius> We need to get the Haskell community back to a pleasant number.
16:49:16 * ddarius takes up serial killing.
16:49:39 <Rotaerk> we need 14 more people in here
16:50:05 <monochrom> I would tell those people "I never read it, I'm too busy producing real code"
16:50:23 <monochrom> "why do programmers write blogs rather than code anyway?"
16:50:30 <EvanR> "Programming in Haskell is like proving a mathematical theorem. There is no screwing around."
16:50:42 <EvanR> complement or criticism?
16:50:50 <monochrom> "I can understand artsy majors writing reams of blogs"
16:50:59 <ddarius> Misunderstanding.  Programming in any language -is- proving a mathematical theorem.
16:51:23 <chrisdone> ddarius: a very vaguely understood mathematical theorem?
16:51:41 <Rotaerk> how is programming proving a mathematical theorem?
16:51:59 <listofoptions> idk if that's true in weakly typed langs ddarius
16:52:07 <dschoepe> Rotaerk: http://en.wikipedia.org/wiki/CurryвЂ“Howard_correspondence
16:52:13 <listofoptions> curry howard isomorphism
16:52:23 <CakeProphet> ddarius:  I think that is rather like saying riding a bicycle is teaching physics.
16:52:35 <listofoptions> pretty much
16:52:47 <EvanR> in the comments theres a plug for Clean. "Would you like a haskell-like language without monads kludge?" ;)
16:53:02 <Warrigal> It's like saying riding a bicycle is proving that a bicycle exists.  :P
16:53:10 <Warrigal> I think coroutines are trivial to implement using the Continuation monad, aye?
16:53:24 <monochrom> yes
16:53:24 <Saizan> CakeProphet: can you translate the motion on the pedals into an explanantion of physics?
16:53:42 <Peaker> EvanR, That's so weird -- the Clean guys probably know what monads are, it's difficult to imagine them being ignorant enough to think monads are a kludge around IO/purity
16:53:54 <EvanR> must be a clean fanboy 
16:54:04 <monochrom> perhaps delimited continuation gives you coroutines much easier
16:54:20 <CakeProphet> ...little did he know when he made that comment that Haskell fanboys on some IRC channel would eat him alive.
16:55:09 <dibblego> that was the biggest load of bullshit; sometimes I wish I had looked away, thanks guys!
16:55:35 <monochrom> just don't click on any urls, then you'll be fine
16:56:14 <monochrom> or train yourself to recognize whose urls are bad. it's pretty obvious actually.
16:56:28 <CakeProphet> clicking a URL = unsafePerformIO
16:56:35 <EvanR> lol
16:57:36 <dibblego> would be a great browser plugin if "someone who has credibility according to you, thinks the URL you are about to open a URL that is a complete load of bollocks"
16:58:07 <Cads> can anyone suggest a tutorial that'll explain newtype so that I can make my unboxed array based number type?
16:58:13 <kmc> Cads, you know "data"?
16:58:25 <Cads> kmc, yeah
16:58:31 <kmc> Cads, "newtype" is like "data" except for three things
16:58:34 <kmc> 1) better performance
16:58:39 <kmc> 2) you're restricted to one constructor with one field
16:58:43 <kmc> 3) that field is strict
16:59:15 <Saizan> 4) all the patterns are lazy
16:59:17 <kmc> (3) meaning, if you force the newtype'd value to weak head-normal form (whnf), the value inside gets forced too
16:59:30 <kmc> yeah, good point Saizan
16:59:44 <joyfulgirl> dibblego: I think something like that exists for firefox, actually
17:00:08 <dibblego> joyfulgirl, got any google terms?
17:00:19 <kmc> Cads, a way to think about it is, at typechecking time "newtype" is like "data", introducing a new type which can't be used interchangably with the thing inside.  but at runtime it's like "type", introducing a synonym with no overhead
17:00:26 <joyfulgirl> dibblego: I'm afraid not...I just found something by accident a while back
17:00:54 <Cads> right now I have     type Vector = UArray Int Double     should I do newtype Vector = Num (UArray Int Double)    ?
17:01:00 <dibblego> joyfulgirl, ok I'll keep an eye out, thanks
17:01:30 <joyfulgirl> np
17:01:55 <EvanR> dont use Num as a constructor eh?
17:01:55 <g_cross> Why does newtype exist, rather than being an optimization for data with one constructor?  It seems like to a sufficiently smart compiler there should be no difference.
17:02:05 <g_cross> And Haskell has smart compilers.
17:02:10 <kmc> g_cross, only if the compiler can prove strictness in every case
17:02:13 <EvanR> well theres semantic difference. lazy vs strict
17:03:04 <EvanR> you could use a strict constructor
17:03:11 <monochrom> some people intend data with one constructor to be exactly that.
17:03:15 <Peaker> g_cross, "newtype" wrappers are "unlifted". That means that a case expression on them does not force anything, they introduce no new "bottom" element
17:03:45 <Saizan> EvanR: data Foo = Foo !Bar doesn't behave exactly like newtype Foo = Foo Bar
17:03:49 <Peaker> g_cross, http://www.haskell.org/haskellwiki/Newtype
17:03:51 <kmc> btw that blog article is 2 years old
17:03:53 <g_cross> So newtype is equivalent to data with a single constructor and a strictness annotation on the contained type, then?
17:04:00 <kmc> g_cross, yeah, think so
17:04:06 <Peaker> nope
17:04:17 <benmachine> almost but nope
17:04:17 <Peaker> the above link to the wiki explains the semantic differences
17:04:29 <Peaker> See Foo2 vs Foo3
17:04:38 <kmc> oh, because patterns also become lazy
17:04:39 <benmachine> strictness annotations affect application, but not pattern-matching
17:05:06 <g_cross> Oh, crazy, so (roughly speaking) for a new type T we have that "undefined == T undefined)
17:05:18 <g_cross> wait, let me restate that
17:05:21 <Peaker> case Newtype undefined of Newtype _ -> x = x   whereas same with StrictData is undefined
17:05:33 <monochrom> ah x2 and x3 show the difference
17:05:41 * hackagebot colorize-haskell 1.0.1 - Highligt Haskell source  http://hackage.haskell.org/package/colorize-haskell-1.0.1 (IavorDiatchki)
17:05:46 <g_cross> No, I am sticking with my original claim:  "undefined == T undefined"
17:05:53 <Peaker> monochrom, and y2/y3 are different too
17:06:07 <EvanR> > undefined == undefined
17:06:08 <lambdabot>   *Exception: Prelude.undefined
17:06:18 <benmachine> g_cross: I think the two are indistinguishable
17:06:19 <kmc> g_cross, for both newtype and data-with-!, undefined is indistinguishable from (T undefined)
17:06:21 <Peaker> @type (undefined==)
17:06:22 <lambdabot> forall a. (Eq a) => a -> Bool
17:06:43 <kmc> g_cross, but for newtype, there's the additional wrinkle that pattern-matching the ctor does not force the value
17:06:54 <benmachine> kmc: I think for data-with-! you can't construct T undefined
17:07:02 <Taejo> > upto 10
17:07:03 <lambdabot>   Not in scope: `upto'
17:07:03 <CakeProphet> > undefined == undefined
17:07:04 <lambdabot>   *Exception: Prelude.undefined
17:07:05 <g_cross> kmc:  But they aren't, that's the point right?  for data "undefined" is not equivalent to "T undefined"
17:07:06 <CakeProphet> :)
17:07:06 <kmc> in other words, translating to data-with-!, you also add a ~ to every occurrence of T as a pattern
17:07:09 <benmachine> kmc: because application is strict, writing T undefined just gets you undefined
17:07:15 <benmachine> or hmm
17:07:22 <benmachine> maybe the distinction is irrelevant
17:07:24 <Saizan> g_cross: with a strict field it is
17:07:25 <kmc> g_cross, for data it's not equivalent.  for data-with-! it is
17:07:44 <kmc> benmachine, right you can't "construct" it.  but the expression (T undefined) is still valid
17:07:54 <g_cross> but the whole point is that case undefined of (T _ -> x) gets you x if T is a newtype and undefined otherwise
17:08:09 <g_cross> so T undefined is equivalent to undefined for newtypes but not for data
17:08:09 <kmc> g_cross, that's a true statement
17:08:21 <kmc> g_cross, there's no (T undefined) in that example
17:08:29 <burp> hm, anyone using hdbc? how can I use list/array like types for "SELECT … WHERE xy IN [1,2,3]"?
17:08:43 <Saizan> g_cross: basically if you have data Foo = Foo !Bar and all case expressions over a Foo look like "case x of ~(Foo y) -> .." then you've the same as newtype
17:08:56 <burp> all haskell database frontends are lacking some important things
17:09:00 <Saizan> g_cross: note the ~
17:09:01 <g_cross> kmc:  but "let T x = undefined in x" gets you undefined, right?  so x is undefined
17:09:23 <kmc> g_cross, that's true no matter how T is declared, yes
17:09:26 <benmachine> Saizan: I guess unsafeCoerce being safe doesn't count?
17:09:26 <kmc> or hmm
17:09:29 <kmc> no it's not true for newtype
17:09:54 <EvanR> burp: i have some experience with them
17:10:05 <g_cross> So it looks to me like "case undefined of T x -> x" is like moving the undefined inside the constructor
17:10:11 <g_cross> semantically, that is
17:10:26 <Saizan> yeah, because operationally that constructor is not there.
17:10:33 <Saizan> so you can't pattern match on it
17:10:34 <g_cross> Saizan:  Okay, I see your point;  case normally forces its argument to WHNF, but not for newtypes
17:10:45 <g_cross> Saizan:  Yes, exactly.
17:10:51 <EvanR> burp: you can type the IN yourself, or generate the query yourself, but the low level drivers do not support lists in prepared statements
17:11:05 <burp> EvanR: I see :(
17:11:20 <g_cross> Interesting;  thanks for the clarification everyone!
17:11:43 <Saizan> benmachine: heh, i'm pretty sure that's not guaranteed by the standard, but ok :)
17:12:04 <EvanR> burp: you might want to redesign your database though if you want to do that efficiently
17:12:07 <benmachine> unsafeCoerce isn't in the standard I don't think
17:13:12 <kmc> indeed
17:13:30 <EvanR> :t unsafeCoerce
17:13:31 <lambdabot> Not in scope: `unsafeCoerce'
17:13:37 <kmc> @hoogle a -> b
17:13:37 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:13:37 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:13:37 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:13:46 <kmc> unsafeCoerce is the hoogle comedy answer
17:13:56 <kmc> because its type unifies with any function type
17:14:05 <kmc> @hoogle Maybe () -> Either Char Bool
17:14:05 <lambdabot> No results found
17:14:07 <kmc> awwww
17:14:18 <EvanR> what does it do, operationally speaking
17:14:23 <kmc> EvanR, unsafe pointer cast
17:14:24 <Peaker> undefined too
17:14:31 <EvanR> so it effectively changes the type
17:14:31 <Saizan> nothing :)
17:14:33 <kmc> EvanR, totally implementation-dependent behavior
17:14:40 <EvanR> and thats it
17:14:45 <kmc> yeah, operationally it's a no-op
17:14:49 <kmc> just tells the type checker to shut up
17:14:56 <kmc> GHC guarantees a few safe uses
17:14:59 <EvanR> why didnt i use this sooner! ;)
17:15:03 <kmc> - casting between a newtype and the thing it wraps
17:15:09 <kmc> - casting any type to Any, and back to the same type
17:15:19 <kmc> it's a useful primitive for implementing things like Data.Dynamic
17:15:23 <CakeProphet> > Unsafe.Coerce.unsafeCoerce 'c' :: Word8
17:15:23 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
17:15:26 <EvanR> what about ffi pointers
17:15:31 <kmc> EvanR, what about them?
17:15:39 <EvanR> is it useful for that?
17:15:43 <kmc> FFI already has unsafe pointer casts
17:15:45 <EvanR> oh
17:15:46 <Saizan> those have castPtr already
17:15:46 <kmc> Ptr a -> Ptr b
17:15:48 <kmc> which is preferable
17:15:54 <EvanR> its also unsafe?
17:15:57 <kmc> yes
17:16:03 <kmc> FFI is unsafe
17:16:14 <kmc> you can write any part of your process's memory space with any value you like
17:16:14 <EvanR> gotta live dangerously
17:16:18 <kmc> trivially
17:16:31 <kmc> you can segfault in one line if you import Foreign first
17:16:44 <kmc> or you can code GHC Russian Roulette in a few more lines
17:17:17 <EvanR> is it possible to replace any foreign lib with haskell only code and stdlib i/o?
17:17:40 <kmc> i can't think of an interesting answer to that question
17:18:04 <EvanR> all of the network libs could concievably use Socket
17:18:08 <c_wraith> Well, no.  There's always going to be some crazy hardware that requires some strange method of access.
17:18:31 <kmc> :t randomIO >>= (peek . intPtrToPtr . fromIntegral)
17:18:32 <lambdabot> Not in scope: `peek'
17:18:32 <lambdabot> Not in scope: `intPtrToPtr'
17:37:12 <askhader> Can I not place guards within a let statement?
17:37:39 <askhader> like f (x:xs) = let first = x in | x == 4 ...
17:38:20 <EvanR> try case
17:38:55 <hpc> askhader: there's also where
17:39:13 <monochrom> you can use guards in let
17:39:14 <askhader> Thanks
17:39:19 <askhader> monochrom: With what syntax?
17:39:33 <monochrom> with the usual syntax. I'll paste one.
17:39:36 <kmc> a guard is attached to a binding
17:40:04 <askhader> monochrom: Thanks
17:41:47 <monochrom> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28063#a28063
17:43:30 <askhader> Not quite what I meant, I wanted the guards in the 'in' bit
17:43:34 <askhader> But that's okay, I will use 'where'
17:44:03 <ddarius> listofoptions: To answer your question: sure it is, it's just that in those languages the "theorem" is really, really boring.
17:45:59 <monochrom> if you are thinking of "guarding the use-site of first rather than the definition-site of first", you're doomed. if you use "where", it is still definite-site not use-site.
17:46:07 <askhader> I see.
17:46:29 <askhader> If someone could take a peak at problem 1 on this page, the return for 'Example in Haskell' is a list of triples and pairs - is this legal?
17:46:49 <EvanR> intruiging
17:46:50 <monochrom> "you can't escape, bwhahahahaha..."
17:47:01 <Peaker> ddarius, example of such a boring theorem?
17:47:16 <EvanR> askhader: how about list of Either (a,b,c) (d,e) ?
17:47:30 <ddarius> Peaker: It's always the same theorem.  In Haskell-ese, it would look like, "Dynamic is inhabited."
17:47:41 <askhader> EvanR: Oh. I wasn't aware this was legal =]
17:47:42 <Peaker> ddarius, heh
17:47:54 <EvanR> its precisely what you asked for
17:48:02 <EvanR> no more no less ;0
17:48:03 <EvanR> ;)
17:48:06 <Peaker> Is it possible randomRIO >>= \x -> use x multiple times in this context -- get different results?!?!
17:48:26 <Peaker> Probably not, but I'm getting some very weird behavior here
17:48:27 <monochrom> Not possible.
17:48:44 <monochrom> randomRIO >>= \x -> print [x,x,x,x,x]
17:49:59 <askhader> EvanR: also of what type is Multiple  ?
17:50:15 <EvanR> @src Multiple
17:50:15 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:50:37 <EvanR> Multiple might be a type, a class, or a constructor. i dont recognize it
17:51:07 <benmachine> ddarius: isn't it fairly boring in haskell too, because every type is inhabited?
17:52:02 <monochrom> programming is fairly boring :)
17:54:23 <CakeProphet> Peaker:  paste?
17:54:41 <Peaker> CakeProphet, It's just one conjecture of many possible, still testing ideas..
17:56:09 <CakeProphet> forever = "repeatM"  right?
17:56:12 <CakeProphet> :t repeat
17:56:13 <lambdabot> forall a. a -> [a]
17:56:21 <CakeProphet> :t forever
17:56:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:56:37 <CakeProphet> ah, not quite.
17:56:54 <CakeProphet> :t repeatM
17:56:55 <lambdabot> Not in scope: `repeatM'
17:57:03 <Peaker> @type sequence . repeat
17:57:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
17:57:30 <Peaker> though this is different
17:58:13 <benmachine> different, eh?
17:58:58 <jbapple> Is there fast way to reinterpret a Word32 as an Int32? I'd rather not peek & poke.
17:59:03 <CakeProphet> :t sequenc
17:59:04 <lambdabot> Not in scope: `sequenc'
17:59:04 <CakeProphet> :t sequence
17:59:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:59:09 <CakeProphet> :t join
17:59:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:59:21 <CakeProphet> o_o magic?
17:59:30 <CakeProphet> @src join
17:59:30 <lambdabot> join x =  x >>= id
17:59:34 <CakeProphet> oh... maybe not. :)
17:59:48 <Peaker> jbapple, fromIntegral?
18:00:01 <jbapple> Peaker: isn't that pretty slow?
18:00:17 <jbapple> also, I'm not sure it's what I want -- lemme check
18:00:24 <CakeProphet> > join [[1,2,3],[4,5,6],[7,8,9]]
18:00:24 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:00:33 <CakeProphet> monadic "flatten" :)
18:00:35 <jbapple> > fromIntegral ((2^31)::Word32)
18:00:36 <lambdabot>   2147483648
18:00:54 <CakeProphet> > join Nothing
18:00:54 <lambdabot>   Nothing
18:00:56 <EvanR> > concat [[1,2,3],[4,5,6],[7,8,9]]
18:00:57 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:01:04 <jbapple> > (fromIntegral ((2^31)::Word32)) :: Int32
18:01:05 <lambdabot>   -2147483648
18:01:15 <CakeProphet> > join Just Nothing
18:01:15 <lambdabot>   Couldn't match expected type `a -> a'
18:01:16 <lambdabot>         against inferred type `Data.M...
18:01:19 <CakeProphet> > join $ Just Nothing
18:01:20 <lambdabot>   Nothing
18:01:21 <jbapple> > (fromIntegral (10+(2^31)::Word32)) :: Int32
18:01:21 <lambdabot>   -2147483638
18:01:29 <jbapple> ok, maybe that's exactly what I want
18:01:32 <EvanR> jbapple: tricky business
18:01:33 <Peaker> jbapple, I wouldn't expect it to be.. it's probably a no-op in runtime?
18:01:42 <jbapple> Peaker: I hope so
18:02:09 <CakeProphet> @djinn m (m a) -> m a
18:02:09 <lambdabot> -- f cannot be realized.
18:02:32 <jbapple> @djinn Monad m => m (m a) -> m a
18:02:32 <lambdabot> -- f cannot be realized.
18:02:37 <kmc> \(W8# n) -> I# (unsafeCoerce# n)
18:02:43 <kmc> jbapple, ^^^^
18:02:51 <benmachine> kmc: what could possibly go wrong
18:02:53 <kmc> fastest you can hope for
18:02:55 <kmc> benmachine, hehe
18:03:03 <jbapple> kmc: ok, fast + safe, I should say
18:03:06 <kmc> it's pretty safe as unsafeCoerce goes
18:03:15 <kmc> terribly implementation-dependent, yes
18:03:22 <kmc> but should not go wrong
18:03:36 <EvanR> unlike Int64 !
18:03:49 <kmc> err, I# above should be I8#
18:04:03 <jbapple> I4#?
18:04:05 <kmc> or, say, W32# and I32#
18:04:10 <jbapple> oh
18:04:24 <benmachine> do you need MagicHash for that?
18:04:28 <kmc> yeah
18:04:40 <kmc> it's a purely syntactic extension; you need it to use # in identifiers
18:06:00 <CakeProphet> hahaha. "MagicHash"
18:06:31 <benmachine> CakeProphet: no comment <_<
18:06:48 <kmc> :)
18:07:15 <EvanR> thats where haskell gives its groovyness
18:07:19 <EvanR> gets*
18:07:34 <EvanR> implemented with Magic Hash
18:10:16 <CakeProphet> what exactly is the "pun" in RecordPuns? 
18:12:18 <askhader> can I pattern match tuples?
18:12:20 <kmc> field name = local binding
18:12:22 <kmc> askhader, yes
18:12:27 <askhader> THanks
18:12:29 <kmc> > case (2,3) of (x,y) -> x+y
18:12:30 <lambdabot>   5
18:12:48 <tommd> > 5 -- simpler this way
18:12:48 <lambdabot>   5
18:12:57 <CakeProphet> askhader:  more generally, you can pattern match the constructor for any data type. (:) for example, is the constructor for lists.
18:14:04 <askhader> CakeProphet: Thank you
18:15:38 <askhader> How could one use pattern matching in a map?
18:15:46 <askhader> like in the lambda proc of the map
18:16:03 <kmc> > map (\(Just x) -> x+1) [Just 2, Just 7]
18:16:04 <lambdabot>   [3,8]
18:16:12 <kmc> askhader, but a lambda binding can't have more than one pattern-match case
18:16:19 <askhader> I see
18:16:20 <CakeProphet> well, if you had a list of type [(a,b)].  map (\(a,b) -> ...) list
18:16:32 <kmc> > map (\v -> case v of Just x -> x+1; Nothing -> 0) [Just 2, Just 7, Nothing]
18:16:33 <lambdabot>   [3,8,0]
18:16:52 <askhader> Awesome
18:17:49 <kmc> > let f (Just x) = x+1; f Nothing = 0 in map f [Just 2, Just 7, Nothing]
18:17:50 <lambdabot>   [3,8,0]
18:17:52 <benmachine> > map (maybe 0 (+ 1)) [Just 2, Just 7, Nothing] -- just sayin'
18:17:53 <lambdabot>   [3,8,0]
18:18:30 <kmc> yeah, you can often avoid explicit arguments and patterns entirely
18:18:46 <CakeProphet> > [3,8,0]   --technically, this is what you want. But does it demonstrate anything? no.
18:18:47 <lambdabot>   [3,8,0]
18:18:56 <benmachine> CakeProphet: :P
18:19:03 <ddarius> benmachine: No.  The theorems in Haskell are interesting.  The logic as a whole is boring, as a logic, because there is a trivial proof to any theorem, but we are usually interested in non-trivial proofs.
18:19:14 <benmachine> ddarius: ah, okay
18:19:23 <ddarius> (Well, actually the theorems are still pretty boring, but they are more interesting.)
18:19:26 <benmachine> heh
18:19:27 <benmachine> right
18:19:49 <benmachine> we *can* write total functions in haskell, we're just not required to?
18:20:44 <ddarius> benmachine: Totality isn't even necessary for a proof to be interesting, but, yes, some proofs are better than others, at least that's what the customers say.
18:20:55 <benmachine> okay
18:21:01 <CakeProphet> what does theory have to say about a segfault? :)
18:21:20 <benmachine> CakeProphet: theory says "if you use unsafeCoerce you are a bad person"
18:21:39 <EvanR> if you use foreign c libs you are a bad person
18:21:46 <ddarius> CakeProphet: To evoke a segfault you'd have to perform undefined behavior which can be formalized as you doing something that proves falsity.
18:22:14 <Peaker> can anyone test if they get a stack overflow on a parallel quicksort I wrote?
18:22:20 <CakeProphet> EvanR:  therefore, all primtives in Haskell are evil. :)
18:22:21 <Zeiris> How can I wrap a monadLib monad like "(StateM m Int, WriteM m String) => m a" in a newtype? Do I need to figure out what sequence of WriteT and StateT form the actual concrete type?
18:22:45 <EvanR> CakeProphet: ive heard this idea expressed seriously
18:22:48 <benmachine> Peaker: sounds straightforward enough, where is it?
18:22:57 <Peaker> benmachine, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28065#a28065
18:23:00 <Olathe> @hoogle (Ord a) => a -> a -> b -> b -> b -> b
18:23:00 <lambdabot> Text.Parsec.Error showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
18:23:00 <lambdabot> Text.ParserCombinators.Parsec.Error showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
18:23:00 <lambdabot> Control.Monad liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
18:23:01 <EvanR> graph reduction is imperative and impure! and such
18:23:03 <CakeProphet> EvanR:  what about sanely? o_o
18:23:19 <Peaker> benmachine, and also try with s/IOArray/IOUArray if you can :)
18:23:36 <hpc> what on earth would need that many parameters?
18:24:07 <benmachine> Peaker: that's basically just adding .Unboxed to the import right?
18:24:15 <Peaker> benmachine, no need to change imports
18:24:24 <Peaker> benmachine, both are imported from Data.Array.IO iirc
18:24:38 <ddarius> The foundation is evil.  What is one to do?
18:24:47 <benmachine> hpc: I assume it's, case compare a b of LT -> c; EQ -> d; GT -> e
18:25:03 <benmachine> Peaker: Now starting sort
18:25:07 * benmachine twiddles thumbs
18:25:15 <CakeProphet> :t (,,,,,,,,,,,,,,,,,,) --hpc
18:25:15 <lambdabot> forall a b c d e f g h i j k l m n o p q r s. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
18:25:18 <Peaker> benmachine, the main stack overflow issue is actually from the random generation
18:25:20 * benmachine watches GHC chew on his memory
18:25:27 <EvanR> ddarius: run haskell code abstractly, devoid of all physical sins
18:25:29 <hpc> good god
18:25:35 <Peaker> benmachine, Heffalump tried the same code and got stack overflows at that point despite using the exact same package versions, compiler version, compilation flags, etc
18:25:42 <CakeProphet> hpc:  I believe it goes up to 64 arguments or something?
18:25:51 <Peaker> benmachine, the sort takes more than 10 secs?
18:25:54 <benmachine> Peaker: I'm running in ghci (6.12.1)
18:25:57 <Peaker> benmachine, oh
18:25:58 <benmachine> err, it's ongoing
18:26:00 <Peaker> benmachine, run it with -O2
18:26:02 <benmachine> oh right
18:26:05 <benmachine> ok one sec
18:26:05 <hpc> i know the standard prelude goes to 7
18:26:05 <Peaker> benmachine, if you want to keep your sanity :)
18:26:27 <sophacles> hi all: my code at http://haskell.pastebin.com/u6uxfgHR is getting an error of "Occurs check: cannot construct the infinite type: a = Maybe a" when i try to compile it. can anyone help set me straight?
18:26:37 <benmachine> Peaker: okay, running it again
18:26:37 <CakeProphet> hpc:  Data.Tuple is where it goes up to 64 I believe. They actually could not include any more data declarations in a single file or it would crash on compilation.
18:26:46 <hpc> awesome
18:26:47 <ddarius> EvanR: Pencil and paper all the way, or not even that.  Just reduce in your head.
18:26:50 <benmachine> Peaker: starting sort
18:27:03 <benmachine> sophacles: what line/column?
18:27:09 <Peaker> benmachine, Then no stack overflow. I'm trying to understand how the random generation part stack overflows at some setups, but not at others
18:27:10 <benmachine> Peaker: sort tok 8.93sec
18:27:18 <Peaker> benmachine, with IOUArray it will probably take a lot less
18:27:32 <EvanR> ddarius: is the brain suitable pure!
18:27:35 <EvanR> suitably
18:27:51 <EvanR> ignore compute errors ;)
18:27:59 <sophacles> benmachine: both 14:0 an 25:8
18:28:40 <CakeProphet> ddarius:  what happens when you get to the primitives? :P
18:28:48 <benmachine> Peaker: mm, 1.55sec
18:28:55 <benmachine> no stack upset in either case
18:29:02 <benmachine> Peaker: you want versions of anything?
18:29:42 <sophacles> benmachine: sorry, i mean 14:0 and 31:8, the definitions for getLeaf and insert both
18:29:57 <benmachine> sophacles: you're looking up p, which according to the type signature of getLeaf is :: a, in a map containing Maybe a
18:30:05 <benmachine> try looking up Just p
18:30:28 <benmachine> (also the third case of getLeaf is unreachable)
18:30:47 <Peaker> benmachine, Nope.. I'm wondering why System.Random seems randomly screwed up regardless of setup
18:30:49 <benmachine> sophacles: I think insert has the same problem
18:30:56 <Peaker> maybe more people can try?
18:30:59 <Peaker> benmachine, ghc 6.12.3?
18:31:04 <benmachine> nope, 6.12.1
18:31:56 <CakeProphet> ddarius:  sweet. I'm convinced. I'm going to go evaluate a web server in my head now. See you when it halts.
18:33:15 <benmachine> CakeProphet: can't really do monadic IO without eating a network cable
18:33:44 <EvanR> CakeProphet: you halt when you have to get the first IO action in weak head normal form ;)
18:33:52 <EvanR> when you get
18:34:19 <EvanR> insane
18:35:03 <EvanR> wget CakeProphet/index.html
18:35:40 <benmachine> I actually almost know enough HTTP to give the right response for that :P
18:35:48 <EvanR> heh
18:36:46 <Peaker> can some more people tell me if they get a stack overflow when running: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28065#a28065
18:37:00 <benmachine> something like, HTTP/1.1 200 OK\r\nContent-Type: text/plain; charset=UTF-8\r\nConnection: close\r\nContent-length: 4\r\n\r\nno u
18:37:14 <EvanR> lol
18:37:15 <Peaker> actually this is probably enough: "newListArray (0, n-1) =<< replicateM n (randomRIO (0, 1000000) >>= evaluate)"
18:37:24 <Colours> hello! is there a way to use tabs in my cabal file?
18:37:29 <burp> > text "\150"
18:37:58 <aavogt> Colours: cabal doesn't let you
18:38:17 <Colours> I am aware of this but is there any way to make it let you use tabs anyway
18:38:36 <benmachine> Colours: tell your editor to expand them into spaces?
18:38:53 <Colours> that is not the same thing :(
18:39:11 <benmachine> why do you want to use tabs?
18:39:15 <tommd> Peaker: I don't get an overflow (GHC 6.12.1, compiled with -O2)
18:39:16 <benmachine> they have a tendency to upset things
18:39:22 <benmachine> including GHC
18:39:24 <Colours> because I feel like it also I am just wondering if it's possible
18:39:56 <Colours> because the fact that somebody made it such that cabal won't accept .cabal files with tabs in them is a little insane to me
18:39:56 <benmachine> GHC is prone to getting distressed at unbecoming whitespace
18:40:15 <kmc> is there a way i can write Python code and have GHC accept it and compile it?
18:40:24 <benmachine> kmc: :P
18:40:27 <aavogt> kmc: use a quasiquoter
18:40:30 <kmc> ;P
18:40:32 <benmachine> Colours: it's not a big deal is it?
18:40:46 <Colours> not really but gosh it just really bugs me that somebody would do that
18:40:48 <EvanR> is there a way to indent haskell code and not have basically every other haskell programmer boil you alive
18:40:48 <benmachine> haskell's style just doesn't suit tabs very well
18:41:00 <EvanR> maybe in haskell2.0
18:41:05 <sophacles> benmachine: thanks, now i have a new error to puzzle over for a while :)
18:41:05 <Colours> benmachine what on earth are you talking about
18:41:09 <kmc> Colours, the Haskell community is pretty anti-tabs
18:41:10 <aavogt> there's a (part of?) python implementation on hackage, kmc
18:41:17 <kmc> and now we're going to have a big flamewar about it
18:41:21 <EvanR> lol
18:41:22 <kmc> aavogt, i know
18:41:28 <benmachine> Colours: languages that require lots of indentation run you off the right edge of the screen :P
18:41:32 <kmc> it was a joke at Colours's expense
18:41:33 <Colours> well I'm not going to say one is better than the other
18:41:35 <aavogt> so you can address your desire
18:41:52 <Colours> just that it's really dumb to write a program that won't even let you use one
18:42:00 <gweber> how do I run a cabal test suite ?
18:42:14 <aavogt> Colours: tabs cause lots of problems unless you're rather careful abut them
18:42:20 <gweber> the .cabal file has executable runtests
18:42:34 <aavogt> it's probably less pain overall to just disallow them
18:42:43 <Colours> I've never had any problems with them :(
18:42:52 <Colours> also I did not know that apparently everyone hates them
18:42:53 <Cale> I actually think that tab characters should be treated as lexical errors in Haskell programs as well.
18:42:56 <Zeiris> Do .cabal files use indentation to denote structure?
18:43:01 <Colours> yes
18:43:09 <Colours> well a bit
18:43:20 <benmachine> you can use explicit { and } and ; to a certain degree
18:43:30 <benmachine> but if you do everyone looks at you funny
18:43:36 <wli> I like tabs.
18:43:44 <Colours> me too :3
18:43:44 <monochrom> I am funny
18:43:49 <Zeiris> (Actually, what does Haskell assume as tab width? And could you write malicious programs that look secure under tabwidth=8, but actually have holes when GHC interprets them with tabwidth=whatever?)
18:44:04 <Colours> why would a language have to assume a tab width
18:44:06 <Cale> Colours: In any case, it's not really a problem -- essentially any decent text editor will have an option you can turn on to convert tabs to spaces automatically (and treat multiple spaces like a teb w.r.t. backspace)
18:44:09 <Cale> tab*
18:44:17 <benmachine> Colours: because indentation is significant in haskell
18:44:34 <Cale> And not just indentation, but alignment
18:44:35 <Colours> I guess if you were mixing tabs and spaces
18:44:38 <Zeiris> Colours, if the language uses indentation to denote structure. Take Python for example.
18:44:39 * ddarius only occassionally finds monochrom funny.
18:44:44 <Cale> Colours: Consider:
18:44:48 <Colours> but if you're just using one or the other then it doesn't matter how many spaces to a tab
18:45:02 <Cale> foo = do x <- getLine
18:45:17 <Cale> Colours: The next line, in order to be part of the do-block, has to line up with the x
18:45:19 <aavogt> you don't have to do that though
18:45:23 <ddarius> Colours: True, but the compiler has to give meaning to those that mix tabs and spaces.  
18:45:35 <monochrom> I use {;} occasionally. So I am ocassionally funny.
18:45:40 <Cale> Colours: That is, it must be indented by exactly 9 spaces
18:45:42 <ddarius> Colours: That compiler assumes a specific meaning shouldn't matter to you if you aren't mixing tabs and spaces.
18:45:58 <ddarius> Cale: That's why you don't do that.
18:46:10 <ddarius> do\n... or do ... ; ..., no other.
18:46:15 <gweber> hi, can anyone tell me how to run cabal tests? where the cabal file has: executable             runtests
18:46:16 <gweber>     if flag(buildtests)
18:46:21 <aavogt> ddarius: even with let too?
18:46:22 <Cale> ddarius: I actually prefer something like:
18:46:22 <benmachine> ddarius: there is no try?
18:46:23 <wli> I believe ghc uses 8-column tabstops by default (wow, there's seriously cringeworthy misinterpretation of tabbing going on).
18:46:27 <Cale> foo x y z =
18:46:31 <Cale>   do ...
18:46:37 <Cale>      ...
18:46:39 <Zeiris> Is it possible to write a Haskell program that mixes tabs and spaces, but does different things when interpreted under "8 space tabs" and "4 space tabs"?
18:46:43 <ddarius> Cale: Blech.
18:46:46 <Colours> I put the do next to the equals sign and put everything else on the next line
18:46:48 <Colours> but that's just me
18:46:56 <sophacles> I have no idea how to decipher the error (at the bottom, code above it) at http://haskell.pastebin.com/gRSNHwRd 
18:46:56 <Colours> Zeiris probably
18:47:13 <Cale> For the most part I prefer to hang blocks off of the keywords which introduce them.
18:47:21 <monochrom> Zeiris: No, the Haskell98 Report completely specifies how tabs are interpreted.
18:47:22 <Cale> An exception to this in most cases is 'of'
18:47:22 <tommd> Bah, all this anti-tab rhetoric.  I used tabs all over, including my IRC program it it works fiрђђЂрђђёб¬«кҐџ
18:47:28 <ddarius> I do, actually usually write where foo x = ...\n ... for where blocks, not for modules or classes or anywhere else (GADTs)
18:47:43 <monochrom> Roughly speaking, so called "tab width" is 8.
18:48:04 <Zeiris> monochrom, okay, how about two cases :) A: interpreting the program B: a human examining it in a misconfigured text editor!
18:48:07 <ddarius> I think I do the same with let, but I almost never use let.
18:48:11 <wli> I guess I could go on about how "8-space tabs" and "4-space tabs" are rather clear indicators of not understanding things but probably better to just give up on explaining what tabstops are and ignore or shut up or something.
18:48:20 <monochrom> Then the human is easily fooled.
18:48:31 <ddarius> monochrom: Humans are easily fooled.
18:48:48 <Cale> I think tab characters should just be disallowed in source files altogether.
18:48:54 <Cale> and that would solve the problem :)
18:49:02 <EvanR> no!!! disallow spacez?!
18:49:08 <aavogt> wli: that's how things are in haskell though
18:49:17 <benmachine> disallow code that doesn't work
18:49:18 <wli> Cale: And create the problem of having to repetitively backspace etc.
18:49:27 <monochrom> plain text files should be disallowed altogether
18:49:29 <benmachine> wli: that's a problem your editor should fix :)
18:49:34 <tommd> I've heard of worse suggestions - making the letter 'o' (Oh) an infix operator.
18:49:35 <Cale> wli: Just configure your editor to treat multiple spaces as a tab
18:49:46 <ddarius> monochrom: Allow plain text files, what did they ever do?  Disallow humans.
18:49:49 <Cale> wli: (with respect to backspace)
18:49:50 <EvanR> well, multiple spaces at the start of a line
18:50:02 <benmachine> oh man who cares about whitespace really
18:50:06 <ddarius> tommd: What, you mean like ML?
18:50:10 <wli> Cale: That rapidly collides with reality in unpleasant ways but anyway.
18:50:14 <EvanR> benmachine: whitespace programmers?
18:50:16 <tommd> ddarius: It came up in Haskell'
18:50:21 <ddarius> benmachine: It's the logical extension of Wadler's rule.
18:50:28 <tommd> ddarius: Did ML use 'o' for composition?
18:50:28 <benmachine> ddarius: :)
18:50:52 <benmachine> sophacles: hmm, basically the problem is that your type signatures in the 'where' clauses mention a and b, but they're not necessarily the same a and b as used elsewhere
18:51:01 <benmachine> sophacles: what happens if you don't use those type signatures?
18:51:18 <benmachine> the types should be inferred anyway
18:51:20 <sophacles> benmachine: ill try real quick
18:52:37 <sophacles> benmachine: that compiled :) thanks.
18:52:37 <ddarius> tommd: http://homepages.inf.ed.ac.uk/stg/NOTES/node34.html
18:53:42 <Cale> wli: Collides with reality? The reality is that there are no tabs in your file, and so you know that when you press backspace and it eats a bunch of spaces at once, it didn't really backspace over a tab.
18:53:55 <monochrom> You have to experience haskell-mode for emacs to see what Cales mean, and you will never look back. You hit backspace once, and several spaces are deleted according to indentation in previous lines. Best thing since emacs.
18:54:07 <sophacles> benmachine: (or anyone really...) why would removing the type signature fix that, also, if i need a and b in the where clause for a different type signature, how would I do that?
18:54:09 <Cale> and conversely when you press tab, you always get an appropriate bunch of spaces
18:54:27 <ddarius> There is no difficulty in having editors backspace to tab stops as if you were using tabs, while still using spaces.
18:54:56 <benmachine> sophacles: removing the type signature allows GHC to work out what types are used
18:55:11 <EvanR> you know this would all be solved if we go back to typewriters and whitespace was not there at all ;)
18:55:20 <benmachine> sophacles: giving the correct type signature would work just as well, except that that is difficult
18:55:40 <benmachine> sophacles: there is a GHC extension that allows you to use the a and b in the where clause for a different type signature
18:55:49 <benmachine> sophacles: however in practice you can usually find that you don't need to
18:55:51 <kmc> i think the bike shed should be purple
18:55:58 <Cale> EvanR: Well, ordinary spaces pretty much make it like that. There's only one kind of empty space, not two (or three!)
18:56:10 <EvanR> yeah
18:56:37 <EvanR> tabs are cruft from the days of needing to save space in text files
18:57:00 <EvanR> as if text files were midi files or something
18:57:13 <EvanR> travelling over a cable of 130Hz bandwidth
18:58:00 * kmc modem noises
18:58:01 <sophacles> benmachine: thanks for the explanation. i've read that I should provide type signatures when possible, is that only for top level functions or are there guidelines...?
18:58:07 <kmc> kshhhhh eeeeererereeeeeer
18:58:11 <EvanR> hahaha
18:58:25 <benmachine> sophacles: I think the problem with your type signature is you're saying insert' should be polymorphic, should accept *any* list-of-a as the first argument, but your use of 'skipchild' requires that a to be the same as the other
18:58:27 <monochrom> @quote monochrom modem
18:58:27 <lambdabot> No quotes match. Take a stress pill and think things over.
18:58:35 <monochrom> preflex: quote monochrom modem
18:58:36 <preflex>  no quotes found for monochrom modem
18:58:47 <benmachine> @quote modem
18:58:47 <lambdabot> No quotes match. I feel much better now.
18:58:55 <monochrom> strange
18:59:06 <benmachine> sophacles: mostly, providing them just for the top-level is fine
18:59:34 <benmachine> sophacles: the top level functions are the ones that are going to be used elsewhere - with a where clause you can easily see everywhere it's used, so being explicit about the type isn't so important
19:00:02 <benmachine> sophacles: if you really want to give insert' a signature though, you can use a GHC extension
19:00:36 <benmachine> you put {-# LANGUAGE ScopedTypeVariables #-} at the top of your source file, and then you do
19:00:57 <benmachine> insert :: forall a b. (Eq a) => [a] -> b -> Trie a b -> Trie a b
19:01:12 <benmachine> then a and b will mean the same a and b for all type signatures inside that function
19:01:20 <benmachine> because they were introduced with forall
19:01:26 <sophacles> oh cool!
19:01:39 <smorg> wow lol... Bash has {1..5} syntax for [1..5]. Never noticed (and the first other language I've seen with that construct)
19:01:47 <benmachine> imo that's usually not necessary, and just leaving out the type signature is fine
19:01:53 <benmachine> but that's how you'd do it if you wanted to
19:02:21 <benmachine> bash upsets me
19:02:29 <benmachine> but probably only because I am not very good at it
19:02:31 <sophacles> benmachine: ok, awesme ill file that away under "if really needed only" ;)
19:03:20 <benmachine> sophacles: well, you can file it under whatever you like :P it's a stylistic thing really
19:03:27 <benmachine> I think most other people like it more than I do
19:03:43 <benmachine> it's very rarely necessary, but sometimes it might look nicer or easier to understand
19:03:47 <benmachine> it's up to you!
19:05:58 <sophacles> benmachine: cool. right now im just trying to learn haskell. so far ive managed to write the module you've been helping me debug, so optional stuff is a bit scary atm :)
19:06:09 <benmachine> sophacles: yeah, I can understand that
19:06:23 <benmachine> might as well keep it simple for now
19:14:39 <kmc> > fix error
19:14:40 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:15:06 <EvanR> that doesnt fix the error at all... it makes it worse!
19:15:17 <EvanR> haskell sucks
19:15:21 <kmc> yeah
19:15:33 <kmc> i don't see how this is better than scheme
19:15:40 <kmc> ;P
19:15:42 <benmachine> it's not even a martial art
19:15:49 <benmachine> or something.
19:15:52 <dolio> Does scheme let you construct infinite errors?
19:16:25 <EvanR> only in infinite error can you achieve perfect success
19:16:30 <ddarius> dolio: Probably.
19:16:34 <kmc> EvanR, deeeeep
19:16:49 <EvanR> lol
19:17:16 <kmc> as an upper middle class white american, i am impressed by anything confusing said by an asian person
19:18:55 <Philonous> It's so obviously false it has to be true. 
19:21:47 <CakeProphet> is it acceptable practice to use newtype to implement different instances of a typeclass from the original type?
19:21:55 <tolkad> How do I export all functions that are part of a class instance?
19:22:06 <Philonous> CakeProphet: That's common practice, yes
19:22:06 <CakeProphet> Class(..) I believe?
19:24:46 <Philonous> CakeProphet: Btw you can let ghc lift all the instances you want to keep with -XGeneralizedNewtypeDeriving
19:25:19 <CakeProphet> so compiler optimization + lazy evaluation is why unsafePerformIO is bad right (other than the purely ethical reasons)
19:25:34 <CakeProphet> Philonous:  so I'd use deriving to keep those instances? deriving (Whateverclass)?
19:25:46 <Philonous> Exactly
19:26:37 <ddarius> CakeProphet: That we want referential transparency (and related things) is what make unsafePerformIO bad.
19:26:59 <ddarius> Nothing (but sanity) stops someone from making an impure lazy language.
19:27:17 <ddarius> Look at TeX, Velocity, and a few other languages.
19:27:18 <dolio> There already are some.
19:27:23 <dolio> Jaskell.
19:27:29 <dolio> CAL, I think.
19:27:47 <conal> and algol was call-by-name
19:28:06 <dolio> Even OCaml has some laziness constructs.
19:28:11 <CakeProphet> ddarius:  right, and we want referential transparency for compiler optimizations and lazy evaluation, yes? Or are there other reasons?
19:28:54 <dibblego> so that our programs are easier to manage
19:28:54 <conal> CakeProphet: for the same reasons as we want it in math.  to support rigorous reasoning.
19:29:15 <conal> speaking for myself, anyway.
19:30:16 <CakeProphet> conal:  ...yeah. I personally don't care about formal reasoning. Only the practical benefits it gives me.
19:30:16 <ddarius> CakeProphet: Equational reasoning.
19:30:25 <ddarius> Compiler optimization falls under equational reasoning.
19:30:53 <ddarius> CakeProphet: It doesn't have to be formal reasoning.
19:31:31 <monochrom> just plain sanity
19:31:43 <Philonous> CakeProphet: But you want to reason about your programs, even if not formaly. 
19:31:54 <prsteele> could anyone tell me what definitions need to be placed in a *.hs-boot file? Is it just 'data' definitions, or functions, too?
19:32:16 <ddarius> prsteele: Whatever things are needed to break the cycle of dependency.
19:33:41 <conal> I don't know how to persuade someone that rigor leads to practical benefits.  There's a lot of evidence, but I don't know how to organize it into a neat compelling package for someone else.
19:34:12 <lispy> conal: I find what you just said ironic :)
19:34:15 <monochrom> formal vs informal is an irrelevant dichotomy. the relevant dichotomy is scientific vs make-believe
19:34:22 <conal> math -> science -> engineering
19:34:26 <conal> lispy: yeah?
19:34:28 <prsteele> ddarius: so... all the definitions that are being exported?
19:34:49 <CakeProphet> conal:  you could link them to the Haskell Platform.
19:35:03 <lispy> conal: yeah.  Think of rigor like a combination of organization, precision, and discipline and read it again :)
19:35:27 <conal> lispy: :)
19:35:28 <ddarius> prsteele: Not likely.  Just the ones in the module that depend, more or less directly, on the ones from the other module.
19:35:44 <monochrom> oh, it's "rigor for my programs" vs "rigor for arguing for rigor for my programs"
19:35:46 <prsteele> ddarius: thanks!
19:37:23 <conal> it's so hard for me *not* to see that math/rigor matters practically, that i'm flumoxed at where to even start with someone who doesn't see it.
19:37:32 <monochrom> you can just point at Dijkstra. he wrote concurrent code and proved it correct before most of you were born.
19:37:59 <ddarius> conal: There are quite a few cases where being more rigorous leads to you being able to tell where your code is ugly or not.  For example, the xmonad talk talks about this with regards to specifying QuickCheck properties v. unit tests.
19:38:32 <conal> all of these remarks are meaningful to me.  but i doubt they are to Joe Java.
19:38:49 <dolio> Proving your code correct is an effective way to find the bugs, at least.
19:38:56 <conal> and i don't need convincing.
19:39:09 <ddarius> conal: This is the wrong forum to ask to get a consensus view of what "Joe Java" finds compelling.
19:39:24 <conal> ddarius: indeed
19:39:39 <conal> however, we have CakeProphet 
19:39:42 <monochrom> he wrote that code and his collegue built the hardware for it to run. they agreed on a contract between them, then pretty much worked separately. when they were done, the combination just worked. it also didn't take long.
19:39:43 <conal> who's asking the question.
19:39:50 <ddarius> conal: I'm pointing to the XMonad talk as one example you can draw on or riff from that is reasonably (or can be made reasonably) compelling.
19:40:25 <tolkad> @source gcd
19:40:25 <lambdabot> gcd not available
19:40:33 <tolkad> @source Prelude
19:40:33 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
19:40:36 <conal> ddarius: worth a shot, i suppose.
19:40:56 <BrianHV> hey, thanks.  just came in to ask about the source of the haskell stdlib.
19:41:29 <hamishmack> dibblego: Did you get Leksah installed ok in the end?
19:41:31 <Philonous> BrianHV: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
19:41:49 <BrianHV> Philonous: even better.  thanks!
19:41:58 <dibblego> hamishmack, I did yes thanks
19:42:14 <dibblego> hamishmack, just having minor issues
19:42:26 <BrianHV> ok, now for the stupid newbie questions...
19:42:49 <BrianHV> I keep seeing that Maybe is a monad.  doesn't that mean it should implement the Monad typeclass?  doesn't that mean it should define >>=?
19:43:02 <interferon> BrianHV: it does
19:43:03 <Philonous> BrianHV: And indeed it does.
19:43:11 <hamishmack> dibblego: Let me know if there is anything I can help with
19:43:18 <Cale> (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
19:43:19 <interferon> BrianHV: open ghci, type ":info Maybe"
19:43:19 <Philonous> @src Maybe (>>=)
19:43:20 <lambdabot> (Just x) >>= k      = k x
19:43:20 <lambdabot> Nothing  >>= _      = Nothing
19:43:35 <conal> i guess i got discouraged after years of trying to inspire & persuade professional programmers (at Sun and Microsoft).  let alone places like reddit. now i like to offer some notes of inspiration to whoever is ready & eager.  and leave the rest to darwin.
19:43:40 <Cale> BrianHV: Even without looking at the implementation, you should be able to guess what it does from the type
19:43:45 <monochrom> > return 4 >> Nothing
19:43:46 <lambdabot>   Nothing
19:43:47 <dibblego> hamishmack, I cannot seem to start leksah with dmenu; when I do I get "leksah: internal IDE error: createProcessGroup: permission denied (Operation not permitted)"
19:43:48 <monochrom> works
19:44:18 <ddarius> conal: Fighting against ignorance on the internet is a great way to get discouraged.
19:44:29 <interferon> so i want to create a monad with a "getUser" function.  if i do "user <- getUser" and someone is logged in, the code should continue; otherwise it should stop executing any following monadic code.  do i want to use an ErrorT in my transformer chain?
19:44:30 <conal> ddarius: sigh.  yeah.
19:44:43 <conal> "There is nothing worse than aggressive stupidity." - Goethe
19:44:50 <BrianHV> ok... thanks again all.  going to play with ghci and try to gain enlightenment. :)
19:44:52 <phasmo> How the heck did I end up here?
19:44:53 <CakeProphet> interferon:  I think you want Maybe perhaps.
19:45:20 <dibblego> interferon, yes if you want an error message as well, otherwise just use Maybe
19:45:28 <interferon> MaybeT, right?
19:45:36 <hamishmack> dibblego: That is probably related to the way we used to handle signalling child processes (ghc).
19:45:45 <dibblego> interferon, the T suffix is a transformer, you probably just want Either
19:45:49 <interferon> so ErrorT is the transformer version of Either?  why isn't it EitherT?
19:45:58 <interferon> dibblego: this would be part of a transformer chain
19:46:35 <CakeProphet> @src Either (>>=)
19:46:36 <lambdabot> Left  l >>= _ = Left l
19:46:36 <lambdabot> Right r >>= k = k r
19:46:37 <hamishmack> dibblego: it may help if you can get dmenu to launch it in a terminal window
19:46:41 <dibblego> hamishmack, ok, is there anything I can do to address it? leksah runs fine from the command line (and when I get into it, I'll likely have more questions)
19:47:19 <CakeProphet> interferon:  it might be simpler to simply use a case statement on a function that returns a Maybe value.
19:47:30 <CakeProphet> interferon:  there is a MaybeT, however, but I don't think it's in the standard libraries.
19:48:00 <ddarius> interferon: Because Error is conceptually a better name, but, for good reasons, Either is called Either.
19:48:14 <hamishmack> dibblego: I am going to take the call to createProcessGroup out.  I don't think we need it any more as the patched process lib creates them for child processes now.
19:48:39 <dibblego> hamishmack, ok great, how about a #leksah channel?
19:49:18 <Philonous> BrianHV: Sorry for nitpicking , but just a minor point: Maybe doesn't "implement the Monad type class", that terminoligy sounds horribly OO, it's an instance. As in: "Maybe is a monad". It doesn't have to be made one. We only point out in code how it already is one. 
19:49:55 <conal> anyway, sorry for bringing some gloom here.  by all means, please keep preaching to those in darkness.
19:50:04 <dibblego> conal, we will!
19:50:17 <conal> thanks!
19:50:34 <BrianHV> Philonous: nitpicking noted.  I'll attempt to adjust my nomenclature.
19:50:51 <hamishmack> dibblego: Is there anything I need to do to set it up?  I clicked on #leksah and I seem to be in there now (I don't use IRC much)
19:51:37 <BrianHV> in ghci, if I'm trying to experiment with do blocks, is  do { foo; bar; } equivalent to   do\nfoo\bar\n in real code?
19:51:54 <ddarius> BrianHV: Yes.
19:52:00 <ddarius> You can even omit the braces if you want
19:52:06 <BrianHV> aaah, thanks
19:52:16 <ddarius> (and the last semicolon)
19:52:22 <ddarius> > do [];;;;;;;[]
19:52:22 <lambdabot>   []
19:52:29 <conal> dibblego: btw, i love your http://projects.tmorris.net/public/what-does-monad-mean/ .  refreshing sense & clarity.
19:52:58 <dibblego> conal, yeah it was a very successful talk -- much more than I thought it would be. Many people thanked me after that and I was showered with beers at the pub
19:53:13 <conal> dibblego: yay!
19:53:28 <conal> dibblego: especially this bit: "It is correct to say that we can reverse a list of bananas, but it is incorrect  to say that the reverse function is in some way related to bananas. Reversing a list of bananas is merely a single instance of an infinite possibility. For precisely this reason, it is also incorrect to say that monads are in some way related to I/O. "
19:54:22 <conal> maybe with enough of us speaking sense in enough different styles, light can indeed enter the darkness.
19:54:26 <dibblego> yeah I try to emphasise that point without sounding like I intend to be obtuse
19:54:35 <danderson> dibblego: got a link to a compiled copy of the thing?
19:54:36 <dibblego> yeah it does work, it's just a tough slog
19:54:59 <dibblego> danderson, stand by
19:55:03 <CakeProphet> dibblego:  but aren't bananas more efficiently group into bunches? This is how they're found naturally after all.  
19:55:12 <conal> "You do not really understand something unless you can explain it to your grandmother." - Albert Einstein
19:55:21 <conal> Hard work describing this simply!
19:55:22 <dibblego> danderson, http://files.meetup.com/1443989/what-does-monad-mean.tar.gz
19:56:45 <dibblego> there is also video
19:57:08 <dibblego> danderson, http://vimeo.com/channels/bfg#13558699
19:58:10 <danderson> dibblego: cheers
20:01:33 <monochrom> conal: I want to suggest to you how Hoare positions rigour: http://cacm.acm.org/magazines/2009/10/42360-retrospective-an-axiomatic-basis-for-computer-programming/fulltext  in summary, position and demonstrate it to reduce cost
20:01:43 <conal> maybe we could give a go at this one for practice: "CakeProphet: conal:  ...yeah. I personally don't care about formal reasoning. Only the practical benefits it gives me."
20:01:57 <ddarius> conal: The effectiveness of explaining doesn't rest solely on the sender, nor is understanding something to a great extent imply you have good didactic skills as well.
20:02:02 <conal> monochrom: thanks you.  i like hoare.  will read.
20:02:17 <conal> ddarius: yep.
20:02:57 <CakeProphet> conal:  I hope that statement wasn't misunderstood. I don't mean that formal rigor is useless.
20:03:34 <conal> CakeProphet: i understood you to mean that you don't know how rigor translates into practical benefits.
20:03:40 <CakeProphet> only that I personally do not care for purity for purity's sake.
20:03:45 <CakeProphet> conal:  no, not even that. I understand that as well.
20:04:05 <dibblego> conal, gl :)
20:04:09 <roconnor> We need to stop calling IO a monad for side-effects.
20:04:19 <roconnor> Haskell's effects are not side effects
20:04:19 <dibblego> succ roconnor
20:04:34 <CakeProphet> conal:  at least, I see how Haskell's rigor helps in verifying the correctness of my programs.
20:04:43 <conal> CakeProphet: ah, so i don't know what piece is missing for you, e.g., to motivate referentially transparency
20:05:11 <conal> dibblego: thx :).  i'm only trying in the hopes that others here will help and i'll learn something about what's effective.
20:05:15 <CakeProphet> conal:  nothing is missing really. I was simply asserting that I'm a pragmatist when it comes to mathematics and programming alike.
20:05:19 <jmcarthur> CakeProphet: how exclusively do you use haskell, may i ask?
20:05:36 <roconnor> dibblego: succ?  
20:05:38 <CakeProphet> jmcarthur:  exclusively? lately, completely exclusively.
20:05:43 <dibblego> roconnor, roconnor++
20:05:49 <conal> CakeProphet: and that you don't know how RT links to pragmatics?
20:05:51 <roconnor> ah
20:06:01 <BrianHV> note to self: 5 minutes in ghci is worth 5 hours of reading. :P
20:06:02 <jmcarthur> i did not truly understand the benefits of purity until i had used haskell nearly exclusively for quite some time
20:06:20 <roconnor> dibblego: I've been programming in Haskell for 9 or 10 years, and I only realized a few weeks ago that Haskell has no side-effects. :)
20:06:26 <CakeProphet> conal:  ....no. I understand that. I was actually asking a question about what makes unsafePerformIO bad.
20:06:29 <dibblego> I use haskell exclusively from Monday!! I know I've already said that
20:06:41 <jmcarthur> now when i sit down to write C i find myself *constantly* searching for the origin of the "current" value of some variable
20:07:23 <dibblego> roconnor, heh, yeah I know what you mean
20:07:39 <CakeProphet> conal:  I didn't mean to imply that I don't see the point of referential transparency. I was trying to envision what Haskell would have to be like in order for unsafePerformIO to not be an issue.
20:07:41 <jmcarthur> unsafePerformIO breaks RT, for one
20:07:45 <danderson> dibblego: wow, you've just clearly explained to me what '* -> *' means
20:07:49 <danderson> finally!
20:07:50 <danderson> thanks :)
20:07:56 <dibblego> danderson, np
20:08:00 <dibblego> @kind []
20:08:01 <lambdabot> * -> *
20:08:03 <dibblego> @kind [Int]
20:08:04 <lambdabot> *
20:08:07 <dibblego> @kind [] Int
20:08:08 <lambdabot> *
20:08:10 <conal> CakeProphet: ah, i guess i misunderstood.
20:08:33 <jmcarthur> i'd love to speak about this longer, but i'm about to go booze it up with some friends
20:08:43 <CakeProphet> jmcarthur:  excellent. :)
20:08:48 <jmcarthur> (in all truth i've never been drunk and probably never will be)
20:08:50 <v0|d> any ideas why hexpath-0.16 fails to cabal install?
20:08:52 <ddarius> jmcarthur: Yeah, imperative languages are hectic and frustrating after Haskell.
20:08:56 <conal> then back to nonstrict higher-order memoization with me!
20:09:18 <CakeProphet> ddarius:  I am hoping I haven't killed my enjoyment of becoming an employed programmer in the future by learning Haskell. :P
20:09:20 <conal> jmcarthur: have fun!
20:09:27 <jmcarthur> ddarius: i now tend to write a lot of my C code in SSA form ;)
20:09:30 <ddarius> CakeProphet: It depends.
20:09:31 <CakeProphet> I don't think I have. I'm sure if I started programming in an imperitive language for a while I would adapt.
20:09:38 <ddarius> Do what jmcarthur said.
20:09:47 <roconnor> dibblego: I was talking with someone about the new dependently type language Trellys.
20:09:54 <jmcarthur> bye!
20:09:59 <roconnor> It will have strict evaluation
20:10:06 <roconnor> I asked if it would have side-effects
20:10:12 <roconnor> or monadic-effects
20:10:21 <roconnor> they said it would have side-effects
20:10:27 <ddarius> CakeProphet: Once you get a bit into Haskell you will write -much- more pure code in any other language and it will usually be nicer than what you would have written before.
20:10:36 <ddarius> CakeProphet: Unfortunately, everyone else's code....
20:10:37 <CakeProphet> conal:  I guess I see how you could misunderstand, by connecting all of the things I've said together. But they were partially directed at different topics.
20:10:43 <roconnor> I figure that would make reasoning about the effects more difficult since they won't be part of the value of the result type.
20:10:53 <roconnor> that is when it hit me.
20:11:01 <roconnor> Haskell doesn't have side effects
20:11:11 <dibblego> everyone else's code is fixed by teaching them haskell too!
20:11:12 <roconnor> the effects are in the result of the function
20:11:13 <conal> CakeProphet: ah.  thx.  easy to happen in the irc stream.
20:11:24 <CakeProphet> roconnor:  I would say Haskell has magic boxes more than it has real side-effects.
20:11:30 <roconnor> not on the side of evaluation
20:11:37 <ddarius> dibblego: So get on teaching the people who write the Java standard libraries.
20:11:38 <monochrom> @remember dibblego everyone else's code is fixed by teaching them haskell too!
20:11:39 <lambdabot> I will never forget.
20:11:45 <dibblego> roconnor, that's exactly how I think of it
20:11:50 <prsteele> I'm used to languages where circular imports are relatively easy to handle, such as Python (automatic) or C++ (header guards). If it looks like I'm going to need to need to spend a lot of time maintaining my *.hs-boot files, do I just need to get better at it or is this an indication that I'm structuring my files incorrectly?
20:12:05 <roconnor> ya, I mean I knew this for a long time on some level.
20:12:17 <dibblego> ddarius, one chooses to engage efficiently
20:12:29 <dolio> roconnor: Isn't it going to have an effect system? Or am I misremembering that?
20:12:32 <ddarius> prsteele: Recursive modules are not something that you should have crop up too often regardless of the language.
20:12:44 <CakeProphet> preflex:  I've encountered a similar problem. It can me either, depending on the kind of program. Usually you can structure the files in a different way to fix the dependencies. But yes, I also find it annoying that I can't have circular imports.
20:12:49 <roconnor> but I kept calling the effects in the IO monad "side-effect" since that appears to be the name for this class of effects in other langauges, but it isn't really.
20:13:06 <roconnor> dolio: I don't know much about it's effect system
20:13:11 <Gracenotes> prsteele: it's best to separate off shared types and functions into their own module
20:13:18 <ddarius> The Report explicitly allows cyclic imports, GHC just implements it in a cumbersome way.
20:13:19 <monochrom> prsteele: in some cases you shouldn't use circular imports. in some cases you should, and haskell promises to support it, except ghc doesn't do it nicely yet, seems hard.
20:13:32 <roconnor> side-effect isn't supposed to be a name of a class of effects like printing and mutating variable.
20:13:33 <Gracenotes> so instead of two modules depending on each other, both depend on a third
20:13:42 <Gracenotes> but that's not always possible..
20:13:52 <roconnor> side-effect is short for "side effect of evalutation"
20:14:01 <dibblego> well I taught the Java guys at work a bit of haskell (we do 2 hours weekly + Erik's videos) and now I am writing a whole system from scratch using Haskell
20:14:14 <ddarius> Another possibility is to do what programmers have always done in such situations, target an interface rather than a concrete implementation.
20:14:20 <prsteele> ya my situation is a bit of A <-> B <-> C <-> ... I just put each a different file for clarity, but I guess they really should be together
20:14:22 <prsteele> thanks all
20:14:55 <roconnor> IO effects are not a "side effect of evaluation".  In fact this is important and missed by many beginners at haskell who incorrectly think that IO effects happen as a side effect of evauation of do blocks
20:14:59 <Gracenotes> ah. if you can split shared functionality off, that can't hurt, it would just involve structuring it a different way..
20:15:09 <CakeProphet> preflex:  also, you can define modules that only export particular sets of a larger file, if you'd still like to organize your modules in a more segmented way.
20:15:21 <ddarius> prsteele: Mutually recursive modules are usually rather tightly coupled suggesting that they should either be decoupled, e.g. through using interfaces or parameterization, or they should be together.
20:15:28 <roconnor> reddit has banned me from their servers
20:15:31 <roconnor> it is probably for the best
20:15:47 <ddarius> roconnor: What did you do?  And it is for the best.
20:15:48 <monochrom> congratulations
20:16:00 <prsteele> CakeProphet: I like that, thanks
20:16:01 <Olathe> I think I have a bug-free binary search on Integral-indexed arrays: http://codepad.org/d5aHq0Uk
20:16:01 * ddarius doesn't want to install xmonad-contrib.
20:16:14 <ddarius> Olathe: Prove it.
20:16:16 <roconnor> ddarius: I don't know.  It works if I switch to a different firefox profile but not on my main profile
20:16:23 <dolio> roconnor: For instance, Disciple doesn't do monads (as far as I know), but it has a system that tracks effects.
20:16:26 <roconnor> I've tried clearing cookies history everything
20:16:26 <tommd> roconnor: That's good, I've considered banning all non-reddit-banned IPs
20:16:35 <prsteele> ddarius: I agree, but I have a tendency to jump pretty far into a project before I really think about how it will end up being structured
20:16:37 <dolio> So, it still keeps track of them, just not in the type system.
20:16:41 <ddarius> roconnor: It's the divine hand of God leading onto the righteous path.
20:17:08 <roconnor> ddarius: but that thread on writing Du in haskell was really really good
20:17:12 <dolio> (Depending on how encompassing you consider 'type system' to be.)
20:17:14 <roconnor> by far the best thing I've read on reddit
20:17:21 <ddarius> What the heck is Du?
20:17:24 <CakeProphet> prsteele:  What I did in my case was put my data type definitions in one file together, since that is where the circular dependency lay.... and then I put the functions for each data type in seperate modules, and then exported the data type in question from those modules.  (not sure if that explanation made sense)
20:17:31 <dolio> Disk usage.
20:17:41 <monochrom> think of "du" in unix
20:17:42 <roconnor> ddarius: it recursively finds and totals the size of files and directories
20:18:10 <ddarius> roconnor: Oh, I know what that is.  I just didn't connect what you said with that and I'm not used to seeing "Du" v. "du."
20:18:23 <roconnor> dolio: what does it mean for the type system to track effects?
20:18:30 <ddarius> I thought it was some crazy language or something.
20:18:39 <roconnor> ddarius: ah sorry.  Haskell module names must begin with a capital
20:18:40 <prsteele> CakeProphet: I think I follow
20:19:49 <roconnor> dibblego: what kind of system?
20:20:28 <dolio> roconnor: In Haskell, one writes embedded languages that can describe various sorts of effects. And programs that use those effects end up with a different type, like 'IO a' instead of 'a'. So you use type to track what effects a piece of code has.
20:20:31 <dibblego> dependency management
20:20:47 <dibblego> but for the general case, including the existing Java programs
20:20:57 <roconnor> dibblego: like nix?
20:21:40 <dolio> roconnor: In Disciple, part of the type of every function is what effects it may have, but that is not done by constructing a new type representing a language with the relevant effects.
20:21:45 <dibblego> roconnor, kind of
20:21:47 <roconnor> dolio: ya, but IO a isn't really "marking" effects, it only looks like that.  "IO a" is a data type whose value describe effects trees.
20:22:00 <CakeProphet> dolio:  unfortunately IO is a rather big set of effects. It would be nice if you could specify that you only want a subset of IO.
20:22:20 <CakeProphet> ST is an example of a "subset" of IO
20:22:26 <CakeProphet> in regard to effects.
20:22:53 <roconnor> dolio: how does that work with currying?
20:23:22 <roconnor> dolio: should I think of the effect annotations as attached to the arrows?
20:24:06 <dolio> roconnor: So, I suppose the difference is between having built-in support for tracking effects (which is usually called an effect system) and turning the effect tracking problem into one of checking types, by constructing the expression trees as a type in the language.
20:24:36 <dolio> roconnor: I think they're attached to the arrows, yes. I've only glanced at Disciple.
20:25:04 <dolio> There's also a region tracking system.
20:25:13 <dolio> Unless I'm mistaken.
20:25:43 <roconnor> dolio: if the effects are attached to arrows, it seems like it would make sense to think of those as Klesli arrows
20:26:01 <dolio> Possibly.
20:27:02 <ddarius> CakeProphet: It is very easy to newtype wrap IO and then limit what operations your newtype allows thus "subsetting" IO.
20:27:32 <ddarius> roconnor: That probably is the case.
20:28:19 <dolio> roconnor: I don't see anything about an effect system for Trellys, though, having looked now. So maybe I was imagining that.
20:28:39 <roconnor> I wonder if these arrow annotations could also denote comonadic effects
20:29:02 <dolio> Presumably.
20:29:15 <CakeProphet> ddarius:  how do you do the limiting?
20:29:51 <roconnor> dolio: how does bind work?
20:29:55 <roconnor> semi-colon?
20:29:58 <dolio> For what?
20:30:21 <roconnor> in dcc or whatever it is we are talking about
20:30:29 <roconnor> Disciple
20:31:10 <dolio> Oh. I think there are do expressions that aren't linked in any way to monads. That may be it.
20:31:55 <dolio> Presumably 'f x y z = do x ; y ; z' is equivalent to 'f x y z = z' if there are no effects.
20:32:05 <dolio> Identity monad and whatnot.
20:33:59 <Cads_> for a given n I have to evaluate  grav(x_i, x_j) where i /= j, and i, j are integers in [1, n].
20:35:47 <Cads_> Then I have to compute a sequence of vectors y_k = sum_{i = 1 -> n} grav(x_k, x_i).
20:36:26 <Cads_> that is, for each x_k we have a y_k which adds up the gravity forces acting on x from each of the other particles
20:37:33 <Cads_> so this problem is O(n^2)
20:38:33 <Cads_> but grav(x_i, x_j) = - grav(x_j, x_i), which should save about half of all the computation
20:39:01 <Cads_> but I don't know how to do this as a recursion
20:39:09 <Cads_> it's not a fold, for example
20:39:23 <prsteele> why doesn't '(EQ ==) . compare' have a type 'a -> a -> Bool'? compare has type '(Ord a) => a -> a -> Ordering, and '(EQ ==)' has type 'Ordering -> Bool', so it looks to me like their composition should work...
20:40:36 <OrangeSky> prsteele: it's because compare takes two args
20:40:52 <roconnor> @type ((EQ ==) .) . compare
20:40:52 <lambdabot> forall a. (Ord a) => a -> a -> Bool
20:41:31 <prsteele> so no composition with more than one argument?
20:41:34 <prsteele> I need to curry first?
20:41:58 <roconnor> (f .) . g composes with a binary g
20:42:03 <prsteele> roconnor: ah
20:42:11 <roconnor> ((f .) .) . g composes with a trinary g
20:42:17 <roconnor> etc.
20:42:26 <prsteele> roconnor: exactly what I needed, thank you
20:43:05 <CakeProphet> @hoogle MonadFix
20:43:05 <lambdabot> Control.Monad.Fix class Monad m => MonadFix m
20:43:13 <CakeProphet> @instances MonadFix
20:43:13 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:43:32 <CakeProphet> @src [] mfix
20:43:32 <lambdabot> mfix f = case fix (f . head) of
20:43:32 <lambdabot>            []    -> []
20:43:32 <lambdabot>            (x:_) -> x : mfix (tail . f)
20:43:59 <roconnor> woah
20:45:43 <SevenInchBread> :t mfix
20:45:44 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
20:46:28 <CakeProphet> hmmm... so......
20:47:01 <roconnor> > mfix (\a -> 1:[a])
20:47:05 <lambdabot>   mueval-core: Time limit exceeded
20:47:27 <roconnor> I still find mfix hard to understand
20:47:31 <CakeProphet> ...for some reason I can't wrap my head around that implementation 
20:48:13 <roconnor> I find it hard to figure out what mfix should do
20:48:13 <CakeProphet> > fix(f.head)
20:48:14 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
20:48:14 <lambdabot>    arising from a use of `e_1'...
20:48:56 <CakeProphet> @src Maybe mfix
20:48:57 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
20:49:29 <CakeProphet> ...I have a feeling I'm going to get a crazy function regardless of which mfix I look at.
20:50:39 <CakeProphet> > mfix (const Nothing)
20:50:40 <lambdabot>   Nothing
20:50:42 <roconnor> @type unJust
20:50:43 <lambdabot> Not in scope: `unJust'
20:50:53 <CakeProphet> roconnor:  unJust is defined in the function body.
20:50:53 <roconnor> @hoogle unJust
20:50:53 <lambdabot> No results found
20:51:02 <roconnor> oh
20:51:34 <roconnor> > mfix (\a -> Just (1:a))
20:51:34 <lambdabot>   Just [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:52:07 <CakeProphet> ...ah
20:52:24 <CakeProphet> that reminds me of sequence?
20:52:49 <CakeProphet> > mfix (\a -> Just a)
20:52:52 <lambdabot>   mueval-core: Time limit exceeded
20:52:54 <roconnor> > mfix (\a -> [1:a])
20:52:55 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:53:14 <roconnor> > mfix (\a -> [1:a,2:a])
20:53:14 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:53:20 <roconnor> > tail $ mfix (\a -> [1:a,2:a])
20:53:21 <lambdabot>   [[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
20:53:27 <roconnor> > tail . tail $ mfix (\a -> [1:a,2:a])
20:53:28 <lambdabot>   []
20:53:54 <roconnor> intresting
20:54:04 <CakeProphet> tail . head . tail $ mfix (\a -> [1:a,2:a])
20:54:10 <CakeProphet> > tail . head . tail $ mfix (\a -> [1:a,2:a])
20:54:11 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
20:54:22 <CakeProphet> :)
20:54:32 <CakeProphet> hey gaiz! I figured out linked lists!
20:54:39 <keseldude> Cads_: if you still need it, this is how I would go about it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28067#a28067
20:55:19 <CakeProphet> is there a function [Int] -> Int  that will halt for infinite lists?
20:55:29 <roconnor> CakeProphet: const 0
20:55:32 <CakeProphet> er...
20:55:36 <CakeProphet> well, something like sum
20:55:48 <Zeiris> I'm playing around with monadLib and built up a monad via its transformers: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28066 I would now like to export it as an abstract monad via a newtype - but what's the concrete type signature of test?
20:56:01 <keseldude> there's no way to tell if a list is infinite afaik
20:56:01 <roconnor> CakeProphet: fold (&&)
20:56:09 <roconnor> er
20:56:19 <roconnor> CakeProphet: short-circut products
20:56:28 <CakeProphet> ah
20:56:41 <CakeProphet> > foldl (*) [1..]
20:56:42 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
20:56:42 <lambdabot>    arising from a us...
20:56:47 <CakeProphet> > foldl1 (*) [1..]
20:56:48 <roconnor> > foldr (\a b -> if a = 0 then 0 else a*b) 1 [0..]
20:56:54 <lambdabot>   mueval: ExitFailure 1
20:56:54 <lambdabot>   <no location info>: parse error on input `='
20:56:59 <roconnor> oh crap
20:57:07 <roconnor> you have to be smarter than that?
20:57:36 <roconnor> oh 
20:57:37 <roconnor> oops
20:57:37 <keseldude> you did = when you meant ==
20:57:41 <roconnor> > foldr (\a b -> if a == 0 then 0 else a*b) 1 [0..]
20:57:43 <lambdabot>   0
20:57:47 <roconnor> ta da
20:58:23 <CakeProphet> > [2,3,4] ++ [1..]
20:58:27 <lambdabot>   [2,3,4,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26...
20:58:32 <CakeProphet> ...
20:59:14 <CakeProphet> > foldl1 (*) 0 (repeat 1)
20:59:15 <lambdabot>   No instance for (GHC.Num.Num [[t] -> a])
20:59:15 <lambdabot>    arising from a use of `e_1101' ...
20:59:26 <CakeProphet> > foldl (*) 0 (repeat 1)
20:59:32 <lambdabot>   mueval: ExitFailure 1
20:59:42 <CakeProphet> puny computer. I know the answer to that one. :)
21:01:37 <CakeProphet> I'm actually surprised (*) is not short-circuiting when an argument is 0.
21:01:55 <dolio> I'm not.
21:02:14 <dolio> For Int and Integer, at least.
21:02:39 <Cale> CakeProphet: That could be done, but it means doing an additional test and branch for every multiplication.
21:03:00 <CakeProphet> > let (**) 0 _ = 0; (**) x y = x*y in foldl (**) 0 [1..]
21:03:06 <lambdabot>   mueval: ExitFailure 1
21:03:12 <CakeProphet> ah, Int/Integer is strict.
21:03:16 <Cale> > let (**) 0 _ = 0; (**) x y = x*y in foldr (**) 0 [1..]
21:03:18 <lambdabot>   *Exception: stack overflow
21:03:29 <Cale> > let (**) 0 _ = 0; (**) x y = x*y in foldr (**) 1 [0..]
21:03:30 <lambdabot>   0
21:03:38 <roconnor> > 0 * undefined :: CReal
21:03:39 <lambdabot>   *Exception: Prelude.undefined
21:03:41 <roconnor> aww
21:03:50 <Cale> CakeProphet: foldl will never terminate on an infinite list.
21:04:12 <CakeProphet> Cale:  but foldr might?
21:04:17 <Cale> CakeProphet: right
21:04:20 <Cale> @src foldl
21:04:21 <lambdabot> foldl f z []     = z
21:04:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:04:30 <CakeProphet> @src foldr
21:04:30 <lambdabot> foldr f z []     = z
21:04:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:04:35 <Cale> ^^ you can see here in the case of a nonempty list, foldl just calls itself
21:04:52 <Cale> So foldl will do nothing but call itself until it reaches the end of a list
21:04:55 <lispy> hey party people!  Let's break out the lambdas
21:05:03 <Cale> foldr on the other hand immediately passes control to f
21:05:14 <CakeProphet> > repeat '\\'
21:05:15 <lambdabot>   "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
21:05:21 <Cale> and f gets to decide whether to use its second parameter or not
21:05:30 <CakeProphet> Cale:  ah okay. I gotcha.
21:05:50 <lispy> has anyone done things with folds that alterate?
21:05:53 <lispy> alternate*
21:06:05 <CakeProphet> hmmm
21:06:45 <CakeProphet> > let alternate x y = x:y:alternate x y in alternate 0 1
21:06:46 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
21:06:55 <Cale> > cycle [0,1]
21:06:56 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
21:07:33 <Cale> > let a x y = x : a y x in a 0 1
21:07:34 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
21:07:56 <CakeProphet> cycle (repeat Nothing)
21:08:07 <CakeProphet> > cycle (repeat Nothing)
21:08:08 <lambdabot>   [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,No...
21:08:14 <CakeProphet> Cale:  ...fancy. :)
21:09:32 <Cale> > iterate (1-) 0
21:09:34 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
21:09:34 <ddarius> cycle (repeat x) = repeat x
21:09:41 <lispy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28068#a28068  <-- that's what I meant by alternating
21:09:46 <CakeProphet> ddarius:  I know. :P
21:10:08 <ddarius> Good ole ordinal arithmetic.
21:10:11 <lispy> It seems that foldr and foldl are both depth first on a tree
21:10:19 <lispy> But there are lots of other strategies
21:11:00 <Cale> lispy: Yeah, if you want other folds, you're probably better off writing the fold for a tree type of some sort.
21:11:47 <CakeProphet> > iterate swap (/) <*> [1,2,3]
21:11:48 <lambdabot>   Not in scope: `swap'
21:11:54 <CakeProphet> > iterate flip (/) <*> [1,2,3]
21:11:55 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:11:55 <lambdabot>    arising from a use of `...
21:12:35 <CakeProphet> ah
21:12:51 <CakeProphet> > iterate flip (/) <*> [1,2,3] <*> [3,2,1]
21:12:53 <lambdabot>   [0.3333333333333333,0.5,1.0,0.6666666666666666,1.0,2.0,1.0,1.5,3.0,3.0,2.0,...
21:17:03 <CakeProphet> I like Applicative. :)
21:17:34 <CakeProphet> > const (const 3) 2
21:17:35 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
21:17:35 <lambdabot>    arising from a use of `...
21:17:37 <CakeProphet> > const (const 3) 2 4
21:17:38 <lambdabot>   3
21:18:04 <CakeProphet> :t iterate const 3
21:18:07 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
21:18:07 <lambdabot>     Probable cause: `const' is applied to too few arguments
21:18:07 <lambdabot>     In the first argument of `iterate', namely `const'
21:18:42 <flazz> in a module i have a type definition, can those be exported?
21:18:46 <CakeProphet> yes.
21:19:08 <flazz> how? i'm getting "Not in scope: data constructor Vector"
21:19:20 <CakeProphet> do you have an explicit export list?
21:19:25 <flazz> yep
21:19:31 <CakeProphet> flazz:  does it include the name Vector?
21:19:36 <flazz> yep
21:19:41 <CakeProphet> ......er
21:19:47 <CakeProphet> are you importing the module? :P
21:19:53 <flazz> yep
21:20:07 <flazz> its "type Vector = Vector3 Float"
21:20:25 <CakeProphet> oh.
21:20:27 <CakeProphet> data constructor
21:20:35 <CakeProphet> are you trying to use vector as a data constructor?
21:20:38 <CakeProphet> Vector is only a type name.
21:20:48 <flazz> i get it
21:21:30 <flazz> newtype should work here right?
21:21:44 <CakeProphet> it will work, but it might not do what you want.
21:21:55 <CakeProphet> newtype Vector = Vector Vector3
21:22:07 <flazz> right
21:22:12 <CakeProphet> if you just want a constructor for Vector3 Float
21:22:25 <CakeProphet> ...just use Vector3.
21:22:57 <Zeiris> Why does "newtype SuperT a = WriterT String (StateT Int (ReaderT Int Id)) a" have a kind mismatch? The kind of everything prior to " a" is * -> *, shouldn't adding a turn it to * and everything's good?
21:25:29 <CakeProphet> Zeiris:  one of your monads needs to not be a transformer.
21:25:46 <CakeProphet> er wait... is Id = Identity?
21:25:48 <Zeiris> That's what ID is for, ain't it?
21:25:53 <Zeiris> Yeah, "data Id a"
21:26:26 <Olathe> Zeiris: Is WriterT the constructor for SuperT a?
21:27:20 <Zeiris> Oh dear, new types need a type constructor?
21:27:26 <Zeiris> That would explain it.
21:27:39 <CakeProphet> Zeiris:  correct. If you simply use "type" then the above should work.
21:27:47 <CakeProphet> but there will not be a new constructor defined
21:28:00 <CakeProphet> only a type synonym.
21:29:04 <Gracenotes> Olathe: newtype has this function to remind you that it's just a wrapper
21:29:11 <Gracenotes> Zeiris rather
21:29:39 <Gracenotes> so more like newtype SuperT a = SuperT (WriterT String blahblah a)
21:31:04 <roconnor> Zeiris: are you aware of RWST ?
21:31:33 * ddarius doesn't understand RWS(T)
21:31:35 <Zeiris> roconnor, never heard of it
21:31:43 <roconnor> @hoogle RWST
21:31:43 <lambdabot> Control.Monad.RWS.Lazy newtype RWST r w s m a
21:31:43 <lambdabot> Control.Monad.RWS.Lazy RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
21:31:43 <lambdabot> Control.Monad.RWS.Strict newtype RWST r w s m a
21:31:49 <ddarius> Zeiris: It's just a predefined composition of Reader Writer and State.
21:32:08 <roconnor> ddarius: I thought you didn't understand RWS(T)
21:32:11 <Zeiris> Ah, well, my current goals aren't really related to this.
21:32:20 <ddarius> roconnor: I understand the what, not the why.
21:32:28 <Zeiris> All I'm trying to do is learn to use MonadLib to define arbitrary new monads + transformers based on existing ones.
21:32:40 <roconnor> ddarius: why one would want a RWS monad?
21:33:04 <ivanm> roconnor: because you want a Reader, Writer and State monad all in one?
21:33:06 <ddarius> roconnor: Why the library predefines some arbitrary combination.
21:33:19 <ivanm> ddarius: you mean mtl?
21:33:26 <ddarius> Yes.
21:33:27 <roconnor> ddarius: RWS are common and commute
21:33:32 <ivanm> apparently the RWS is more efficient than using a stack
21:33:46 <ddarius> I've never wanted to use RWS.
21:34:03 <roconnor> I think the fact that they commute is an important reason why they are bundled and not other combinations
21:35:38 <Gracenotes> @unmtl Reader r (StateT s (WriterT w m) a)
21:35:38 <lambdabot> r -> s -> m (a, s, w)
21:35:47 <roconnor> newtype AssemblyCodeMonad a = 
21:35:48 <roconnor>   AssemblyCodeMonad
21:35:50 <roconnor>      (RWS [(Label,Location)]
21:35:51 <roconnor>           [Either (Instruction Register) (Label,Location)]
21:35:53 <roconnor>           (Location, Integer)
21:35:54 <roconnor>           a)
21:35:56 <Gracenotes> hm.. that can't be entirely true
21:36:03 <roconnor> from TMR issue 6
21:36:26 <Gracenotes> why do you lie to me, lambdabot
21:36:31 <roconnor> ... granted this was the version that doesn't use mfix
21:36:46 <ddarius> Gracenotes: Why do you think it is a lie?
21:37:14 <Gracenotes> well, it is more or less isomorphic to the actual unfolding, I guess
21:37:59 <roconnor> ivanm: ^^
21:38:26 <ddarius> Other than flattening the tuple, it looks to be identical to what it would be unfolded.
21:38:32 <ivanm> roconnor: which bit?
21:38:38 <roconnor> reader - used to look up address of labels
21:38:54 <Gracenotes> I suppose if someone objects to the strenuous cost of handling nested tuples, RWS is for them
21:38:58 <roconnor> writer - used to output assembly code and locations of labels
21:39:23 <roconnor> state - stores the current instruction location and a counter for fresh names.
21:39:37 <roconnor> ivanm: an example when you want to use RWS all together
21:39:46 <ivanm> right
21:39:50 <tg_> yikes
21:39:54 <tg_> two big earthquakes
21:40:00 <tg_> 7.6 7.4 back to back
21:40:17 <roconnor> where?
21:40:18 <tg_> http://earthquake.usgs.gov/earthquakes/recenteqsww/Quakes/us2010zbca.php
21:40:28 <tg_> Philipines
21:40:55 <tg_> actually 3
21:40:58 <tg_> also a 7.3
21:43:32 <tg_> 400 miles down, though
21:43:40 <CakeProphet> @hoogle (MonadIO m) => STM a -> m a
21:43:41 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> a -> m a
21:43:41 <lambdabot> Prelude return :: Monad m => a -> m a
21:43:41 <lambdabot> Control.Monad return :: Monad m => a -> m a
21:44:25 <CakeProphet> a trivial function to implement, I suppose. I wonder what I should call it.
21:44:38 <CakeProphet> atomicIO?
21:45:02 <tg_> transactional io
21:45:41 <CakeProphet> it would be nice if suddenly every IO a was changed to (MonadIO m) => m a
21:45:46 <CakeProphet> in every module ever.
21:46:01 <tg_> i could use a job, too
21:46:05 <tg_> if we're just wishing for things
21:46:06 <tg_> hehe
21:46:48 <CakeProphet> ...then again, explicitly using liftIO really isn't a big deal.
21:47:11 <CakeProphet> @src IO liftIO
21:47:11 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:51:02 <CakeProphet> liftIO . atomically $ ...
21:51:05 <CakeProphet> isn't much different from
21:51:09 <CakeProphet> atomicIO $ ...
21:53:38 <CakeProphet> @hoogle liftIO
21:53:38 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
21:53:48 <CakeProphet> @hoogle MonadIO
21:53:49 <lambdabot> Control.Monad.Trans class Monad m => MonadIO m
22:00:43 <CakeProphet> as often cited as Showable is
22:00:47 <CakeProphet> I'm kind of amazed it's not standard.
22:01:59 <CakeProphet> ah, well I suppose it requires extensions.
22:02:26 <Cale> CakeProphet: It's fairly useless.
22:02:59 <Cale> CakeProphet: If all you know about a value is that you can turn it into a String, then you might as well just use a String instead.
22:03:38 <CakeProphet> This is a good point.
22:04:46 <CakeProphet> couldn't you derive typeclasses for existentials?
22:05:12 * ivanm would really like to be able to define a class like Showable which returns  a "Maybe String" that would work on all types...
22:05:24 <ivanm> but if oleg couldn't do it, what hope do I have? :(
22:05:48 <CakeProphet> Maybe [a] types don't make sense to me. Why not use [] for the case of no value?
22:06:28 <Cale> CakeProphet: What if Just [] and Nothing mean two different things?
22:06:35 <ivanm> exactly
22:06:37 <ivanm> I've had that before
22:06:48 <JoeyA> CakeProphet: Do you happen to be the author of PHP?
22:06:57 <Cale> CakeProphet: For example, imagine doing a lookup in some finite map structure, like Map String [Integer]
22:07:20 <CakeProphet> well, right. That's a different scenario
22:07:26 <CakeProphet> but what about the case of show?
22:07:29 <CakeProphet> why have Maybe String?
22:07:29 <Cale> The result would be a Maybe [Integer], and Nothing would mean that the key you looked up wasn't in the Map, while Just [] would mean that it was in the map, and associated with an empty list.
22:07:41 <ivanm> CakeProphet: "tryShow succ = Nothing"
22:08:11 <JoeyA> echo '<?php if (array() == null) echo "ugh\n"; ?>' | php
22:10:23 <CakeProphet> ivanm:  so it's Nothing on bottom or something?
22:10:40 <ivanm> CakeProphet: Nothing on types that don't have a Show instance
22:11:06 <ivanm> unfortunately, the only way to define such a class is to explicitly make types instances of it
22:11:51 <ivanm> even with overlapping instances, it's not possible to do: "instance (Show a) => MaybeShowable a where tryShow = Just . show" as well as "instance MaybeShowable a where tryShow = const Nothing"
22:11:56 * ivanm tried :(
22:11:58 <mtnviewmark> CakeProphet - the reason to use Maybe x and Nothing vs. some distinguished value from the type x is that it lets you, as a programmer, express your intent that the function takes/returns either a value of x, or no value at all
22:12:09 <mtnviewmark> using a distinguished value for this purpose leads to programming errors
22:12:37 <mtnviewmark> think of how many errors in history have been caused because things like substring() in various languages return -1 if the string wasn't found....
22:12:43 <CakeProphet> mtnviewmark:  yes, I understand the general use case of Maybe. That's not what I'm discussing.
22:12:55 <mtnviewmark> sorry- did walk in the middle here
22:12:56 <mtnviewmark> :-)
22:13:20 <mtnviewmark> and it is the case, that many months ago - this realization about Maybe and Nothing was my "aha" moment about the power of Haskell
22:13:45 <CakeProphet> ivanm:  ah okay. That's interesting. I bet you could generalize such behavior to all typeclasses.
22:13:54 <mtnviewmark> back to my horrible CSS hacks....
22:14:04 <CakeProphet> tryAsClass x  --returns Just x or Nothing
22:14:05 <ivanm> CakeProphet: yeah, but as I said it isn't possible
22:14:36 <CakeProphet> ivanm:  I had an idea for a structural typing system in Haskell. I have a feeling it's undecidable though.
22:16:23 <v0|d> CakeProphet: you should definetly read a denotaional semantics book
22:16:37 <CakeProphet> so you could basically have a type that matches any value with a certain number of fields of a certain type.
22:17:08 <CakeProphet> v0|d: Because I would be interested in the topic or because I'm commiting an error of ignorance?
22:17:29 <v0|d> CakeProphet: http://people.cis.ksu.edu/~schmidt/text/densem.html
22:17:33 <v0|d> CakeProphet: here it is.
22:17:36 <v0|d> CakeProphet: just read it.
22:20:45 <CakeProphet> okay... I've already explained how this works in the past, but I didn't really get much feedback on the idea. I'll restate in case someone who wasn't present at the time is interested.
22:21:28 <CakeProphet> essentially a type {a,b} is a type constraint similar to a typeclass. It constraints the type to one that has two fields, one of type a and one of type b.
22:21:36 <CakeProphet> *constrains
22:22:02 <CakeProphet> er, constructor with two fields, not type.
22:22:27 <CakeProphet> you could pattern match like such  {a,b} = c
22:23:20 <CakeProphet> v0|d:  thanks for the link. I'll check it out later when I'm not procrastinating something important.
22:24:47 <v0|d> CakeProphet: only death can not be postponed.
22:27:12 <CakeProphet> I think the tricky part of this type system is that you now have two different, but related, notions of type.
22:28:32 <CakeProphet> one where you are only concerned with types of constructor fields, and one where you're concerned with a named type, composed of the sum of one or more constructors (excluding the case of abstract data types)
22:29:30 <CakeProphet> ADTs would have the special struct-type {} -- a constructor with no fields.
22:29:51 <CakeProphet> er... no. that's not true.
22:30:12 <CakeProphet> {} would be for actual constructors with no fields. the structural type for ADT would need to be something else.
22:32:31 <CakeProphet> I'll call it ADT. Though, it's not a very useful type. You might as well use a, since you have the same amount of knowledge about what the type is.
22:34:11 <int80_h> Please take a look at this data type that is proving challenging to me.
22:34:14 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28069#a28069
22:35:16 <CakeProphet> int80_h:  what's the problem?
22:35:18 <CakeProphet> oh...
22:35:20 <CakeProphet> didn't see the bottom text.
22:35:39 <int80_h> heh
22:35:51 <int80_h> yeah if you could help me out I would appreciate it
22:36:09 <CakeProphet> hmmm... your description of what you want and the type you have seem harmonious.
22:36:23 <CakeProphet> *seems
22:36:53 <CakeProphet> though. if you only ever want to read the file
22:36:53 <int80_h> oh, could you show me how to use that lambda?
22:36:59 <CakeProphet> you might as well only have entryContent :: FilePath
22:37:04 <CakeProphet> and then use readFile
22:37:27 <int80_h> oooh!
22:37:29 <CakeProphet> entryContent e filePath
22:37:37 <CakeProphet> where e is type Entry
22:37:57 <CakeProphet> int80_h:  also, you can simply do entryContent = readFile
22:37:58 <int80_h> no no I weant to keep it like this so I can keep existing code
22:38:07 <CakeProphet> instead of using the lambda.
22:38:21 <CakeProphet> (\x -> f x)  == f 
22:38:39 <int80_h> would you mind if I showed you the whole program, so I could suss out whether or not to change the lambda? 
22:39:01 <int80_h> I have it like this because I want to make as little changes to the original code 
22:39:04 <CakeProphet> int80_h:  sure. but what I just suggested is equivalent to your current code, so absolutely nothing would change.
22:39:12 <int80_h> but maybe, as you say, it would be better.
22:39:18 <int80_h> let me post it 
22:39:30 <int80_h> oh wait
22:39:31 <ddarius> CakeProphet: Almost, but it's extremely unlikely that int80_h is relying on the difference.
22:40:01 <CakeProphet> ddarius:  is there an efficiency difference or something in (\x -> f x) and f?
22:40:14 <int80_h> I'm lost
22:40:24 <interferon> ddarius: ?
22:40:30 <ddarius> In general, they are semantically different, though in this particular case, they aren't.
22:40:40 <zooko> Folks: I just installed the Haskell Platform, and it put an executable named "ghc" in my /usr/bin, but not an executable named "cabal". Am I supposed to install cabal separately if I want it?
22:40:43 <CakeProphet> could you explain? I'm curious.
22:40:44 <int80_h> could you repeat your suggestion, again?
22:40:52 <CakeProphet> int80_h:  well, there were two.
22:41:09 <int80_h> let me review
22:41:15 <CakeProphet> I was saying if you only ever intend to read the contents of a file. Then you can change the data structure to only hold a FilePath instead of FilePath -> IO String
22:41:16 <ddarius> > ((\x -> undefined x) `seq` "Good", undefined `seq` "Bad")
22:41:17 <lambdabot>   ("Good","*Exception: Prelude.undefined
22:41:30 <CakeProphet> the second suggestion was that you replace (\x -> readFile x) with readFile
22:41:35 <CakeProphet> as, in this case, the two are equivalent.
22:41:53 <CakeProphet> ddarius:  ah
22:42:09 <ddarius> CakeProphet: Also, in general, there can be performance differences and differences in sharing.
22:42:29 <int80_h> CakePropher : I like the second suggestion
22:42:31 <ddarius> Though those are implementation specific.
22:43:20 <CakeProphet> int80_h:  the first suggestion is a good one, unless you intend on using a function different from readFile that also has that type signature.
22:44:27 <int80_h> CakeProphet: no, I am only going to use readFile
22:44:31 <CakeProphet> int80_h:  but if you find that all of your Entries end up containing readFile, you might want to simply hold a FilePath instead.
22:45:03 <CakeProphet> or omit the field entirely, if the field isn't intended to actually store the FilePath
22:45:16 <int80_h> origionally, that data type was a string and the readfile happened outside of it and put the string inside it. I don't want a list of potentially big strings in memory
22:45:22 <ddarius> CakeProphet: The entry doesn't actually hold the FilePath as is, it holds a function, that when given a FilePath, reads it.  It could read multiple functions.
22:45:33 <CakeProphet> ddarius:  yeah, I was just considering that.
22:45:49 <CakeProphet> int80_h:  if you only ever use readFile, then I don't see a purpose for that particular field.
22:45:56 <ddarius> CakeProphet: As written, if all int80_h ever wants to use is readFile then that field should just be removed.  However, he probably meant something different.
22:46:03 <ddarius> More along the lines you are suggesting.
22:46:33 <int80_h> what I want, is to hold a function that, when given a FilePath, reads that file
22:46:47 <ddarius> The field should probably be just IO String
22:47:00 <int80_h> then it will just hold a stirng right?
22:47:12 <CakeProphet> int80_h: no it will hold an action that retrieves a string.
22:47:14 <ddarius> int80_h: No, and why do you want to hold that function.
22:47:20 <ddarius> ?
22:47:21 * interferon wonders how much easier life would be if not for the obsessive-compulsive desire to map OOP to databases
22:47:46 <int80_h> I want to hold the function, because the way it is now the field holds a string. I don't want to have a list of potentially big strings.
22:48:14 <CakeProphet> int80_h:  how do you intend to never allocate these strings, if you need to pass them into the function?
22:48:47 * ddarius watches Catsters and leaves this to CakeProphet.
22:48:52 <int80_h> I'm passing a FilePath into a function, the function will return a string which will then be dealt with 
22:48:52 <CakeProphet> int80_h:  also, lazy evaluation will only allocate strings as they're used. The premature optimization may be unnecessary.
22:49:17 <applicative> zooko, what OS are you using 
22:49:26 <zooko> applicative: Mac OS X
22:49:26 <int80_h> the way the code is now, I generate a list of these data structures and they all have strings in the third field.
22:49:31 <CakeProphet> int80_h:  but your function is always readFile, yes? Why not simply use readFile?
22:49:47 <xenoblitz> hi ppl any one know of a site with papers on haskell games? I found Haskell in Space by Christoph Luth and Yampa Arcade by Courtney et al.
22:50:06 <applicative> zooko, oh, good, my ghc is in /usr/bin cabal is in /usr/local/bin
22:50:24 <CakeProphet> int80_h:  if you're worried about memory usage, removing a field that always contains a "pointer" to the same function will save memory.
22:50:47 <int80_h> well my thinking was I didn't want readFile called until the fiekd was (how do you put this right?) invoked?
22:51:09 <CakeProphet> int80_h:  readFile will only get called when you use it...
22:51:31 <applicative> zooko, i guess /usr/local/could hardly fail to be in PATH  -- is e.g. >  cabal --version   giving you nothing
22:51:36 <CakeProphet> int80_h:  readFile someString 
22:51:41 <int80_h> right, the way the code is now, it populates the list with strings. I don't want it to do this
22:51:43 <CakeProphet> entryContent e someString
22:52:01 <mrd> interferon: if you figure out an OOP-rdb mapping that doesn't suck, let me know
22:52:49 <int80_h> can I show you the current code so as to have a comparison to what is, compared to what I want?
22:52:53 <CakeProphet> int80_h:  but you say entryContent always equals readFile... there is no reason at all to have that field.
22:52:54 <interferon> mrd: I think the whole enterprise is silly
22:53:04 <CakeProphet> int80_h:  sure.
22:53:20 <int80_h> excellent. maybe, as I suspected earlier , my thinking is faulty.
22:53:24 <mrd> interferon: me too
22:53:25 <int80_h> I'll post it now
22:53:54 <zooko> applicative: there is no "cabal" in /usr/local/bin either
22:54:02 <CakeProphet> int80_h:  okay, so you want Entry to hold an action that retrieves its contents from a file, right?
22:54:19 <CakeProphet> rather than holding the string in memory, correct?
22:54:27 <zooko> I'm guessing that installing The Haskell Platform didn't install a "cabal" executable, because if it did I guess it would have installed it in the same dir as the ghc executable.
22:55:26 <applicative> zooko, i was saying that wasn't true in my case, though it occurs to me, you will have installed the one that came out yesterday or whenever...
22:56:16 <CakeProphet> int80_h:  I think I already know what you want to do. There are two ways to do it.
22:56:16 <mrd> interferon: i was interested in that kind of thing about 5 years ago or so... but I came to the conclusion that it could never work because OO is just too limiting.  however I never really formalized that thought.
22:57:37 <CakeProphet> int80_h:  I will wait for you return, and I'll take a look at your code, before I explain my suggestion.
22:57:41 <CakeProphet> +to
22:57:46 <zooko> But this page says that cabal is part of the Haskell Platform: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
22:58:29 <CakeProphet> > "testing my connection"
22:58:29 <lambdabot>   "testing my connection"
22:58:37 <CakeProphet> good. I'm still alive.
22:58:50 <applicative> zooko, yes, i agree the installer should have installed 'cabal install'  
22:58:56 <zooko> Oh, I'll bet I'm getting confused between "cabal" the package and "cabal-install" the tool which installs an executable named "cabal" ;-)
22:59:03 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28069#a28070
22:59:13 <zooko> find /Library/Frameworks/GHC.framework/ -iname '*cabal*'
22:59:24 <int80_h> CakeProphet : I'm back, and thanks for your help :)
22:59:26 <zooko> doesn't turn it up. I'll go ahead and try to install cabal-install manually.
23:01:51 <applicative> zooko, do you see a hidden .cabal file and .ghc file if you do  ls -la in your ~/ directory?
23:01:59 <int80_h> "testing my connection"
23:02:07 <int80_h> > "testing my connection"
23:02:08 <lambdabot>   "testing my connection"
23:02:29 <Heffalump> zooko: IMO the platform should contain cabal-install, and that means it should provide an exe named 'cabal'
23:02:36 <Heffalump> So I don't know why it didn't.
23:02:47 <Heffalump> and it might be worth asking on the haskell-platform list
23:02:52 <zooko> applicative: aha
23:02:57 <applicative> Heffalump, it should be there, yes
23:03:01 <zooko> yes, it did apparently install the "cabal" executable into ~/.cabal/bin/
23:03:02 <zooko> Thanks!
23:03:14 <zooko> I wonder if the docs could be updated, such as this page that I looked at:
23:03:22 <zooko> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
23:03:44 <zooko> And/or this one: http://haskell.org/cabal/download.html
23:03:47 <applicative> zooko, so you have to add ~/.cabal/bin/ to $PATH in .profile or whatever.  Well, you have to do that anyway
23:04:04 <zooko> Oh, uh sorry
23:04:04 <int80_h> I'll be the doc update bitch
23:04:08 <zooko> no I just installed that myself 
23:04:20 <zooko> by running ./bootstrap.sh in the "cabal-install" source tree that I checked out.
23:04:28 <zooko> So as far as I can tell the Haskell Platform did *not* install the "cabal" executable.
23:04:41 <zooko> Which is, yeah, kind of a big thing to leave out!
23:04:49 <Heffalump> zooko: indeed
23:04:57 <int80_h> I will do whatever grunt work needs to be done.
23:05:06 <int80_h> I can update docs :)
23:05:21 <applicative> zooko, it is strange, but in principle okay.   It is a bit worrisome, about the new Platform version. But there is the question, do you have the Platform libs?  
23:05:22 <int80_h> where is CakeProphet?
23:06:03 <zooko> applicative: I just clicked on this great big shiny button that said "Mac": http://hackage.haskell.org/platform/
23:06:04 <applicative> if you do  ghc-pkg list see if you find them listed 
23:06:05 <CakeProphet> int80_h:  yeah, okay. my two possible suggestions still hold.
23:06:08 <CakeProphet> let me restate
23:06:18 <CakeProphet> int80_h:  was away for a moment.
23:06:41 <CakeProphet> int80_h:  you could either have entryContent :: FilePath  or entryContent :: IO String
23:07:02 <zooko> applicative: yes
23:07:29 <CakeProphet> so if you have a FilePath named f. You would do entry {entryContent = f} or entry {entryContent = readFile f}
23:07:56 <CakeProphet> int80_h:  note that IO String is NOT a String.
23:08:07 <CakeProphet> and so won't occupy as much memory.
23:08:10 <int80_h> I'm taking in what you rsaid here.
23:08:30 <applicative> well then you're okay, you can do 'cabal update' and then you'll be ready to use hackage, e.g.  'cabal install pandoc'  ...
23:08:58 <CakeProphet> int80_h:  at the point in time where you want to actually get the string. in the first case, where you have a FilePath, you would:   do { string <- readFile (entryContent e); ...}
23:09:19 <CakeProphet> int80_h:  in the second case, where you have a IO String, you would:  do {string <- entryContent e
23:09:23 <CakeProphet> ; ... }
23:09:53 <int80_h> CakeProphet, I would like to alter the original code as little as possible. I included it so you could see where the string is read.
23:10:28 <int80_h> maybe I have no choice in the matter. This code was intended to be an example, I'm turning it into a working blog.
23:10:56 <CakeProphet> int80_h:  hmmm... then you might want IO String
23:11:11 <int80_h> aggreed
23:11:18 <CakeProphet> so instead of: entries <- mapM readFile entryFileName
23:11:26 <CakeProphet> you would do:  let entries = map readFile entryFileName
23:11:45 <int80_h> really?
23:11:54 <int80_h> would that not store a string?
23:11:56 <CakeProphet> and then whenever you want to access the string later on:   do { string <- entryContent e; ...}
23:12:00 <CakeProphet> int80_h:  it would not
23:12:05 <int80_h> wow!
23:12:12 <CakeProphet> int80_h:  it would store an action that, when applied to >>=, would produce a string
23:12:21 <int80_h> nice, that's what I want
23:12:53 <int80_h> ahhh..okay let's see if I can implement your advice
23:12:58 <CakeProphet> int80_h:  that is what an IO String represents. The string isn't retrieved  until you use >>= on it... in main
23:13:03 <int80_h> I imagine the pain and sugffering of screwing up the types
23:13:45 <int80_h> brb, hope you aren't going anywhere. I don't expect top get this right on the first try
23:14:29 <int80_h> given the field is defined like entryContent :: IO String
23:14:40 <int80_h> how would I replace entryContent = (\x -> (readFile x))
23:14:52 <CakeProphet> entryContent = readFile x
23:15:15 <CakeProphet> you will need the x ahead of time. And it looks like you do just that.
23:15:35 <CakeProphet> in loadEntries you get a list of x's :)
23:15:51 <CakeProphet> thus
23:16:02 <CakeProphet> let entries = map readFile entryFileName
23:16:06 <CakeProphet> gives you [IO String]
23:16:06 <int80_h> yes but the data structure is expecting a String right now, instead of an IO string. I need to examine what I need to change
23:16:10 <int80_h> ah!
23:16:34 <CakeProphet> zipWith3 Entry (...) (...) entries
23:16:37 <CakeProphet> see how that works?
23:16:46 <int80_h> I think so
23:17:30 <CakeProphet> int80_h:  you basically only need to change that bind into a let... and mapM to map
23:17:42 <CakeProphet> might be a few other things I'm forgetting.
23:18:20 <CakeProphet> int80_h:  I assume you didn't want to change the original code much because you have some trouble understanding it? :D 
23:18:38 <int80_h> yes. I have lots of trouble understaning it. I'm trying to take it in chunks
23:18:53 <int80_h> I'm understanding more by making these changes
23:18:54 <CakeProphet> if a part confuses you, I can likely explain.
23:19:11 <int80_h> brb
23:19:38 <CakeProphet> the line:   entryFileName <- getDirectoryContents ...
23:19:52 <CakeProphet> is in desperate need of re-organization. It's a messy one-liner
23:20:08 <CakeProphet> entryFileName <- getDirectoryContents "/home/michael/blog/entries/" >>= return . map (\e -> "/home/michael/blog/entries" </> e) .filter (`notElem` [".",".."])
23:21:10 <CakeProphet> probably could be clarified with the lifeM* family of functions.
23:21:15 <CakeProphet> *liftM
23:21:16 <ddarius> m >>= return . f = liftM f m = fmap f m = f <$> m
23:21:20 <CakeProphet> yes.
23:21:38 <CakeProphet> or Applicative, which looks even nicer.
23:23:09 <CakeProphet> ddarius:  I bet you could make a tool that finds such substitions to make and then changes them on user acceptance.
23:24:36 <CakeProphet> int80_h:  when you get back I have a recommendation for how to make that line look nicer.
23:24:50 <CakeProphet> requiring that you only copy paste my code in. :)
23:24:58 <CakeProphet> @hoogle <$>
23:24:58 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:26:05 <CakeProphet> int80_h:  actually, I'll just modify the pastebin when you're done.
23:26:16 <applicative>  map ("/home/michael/blog/entries" </>) .filter (`notElem` [".",".."]) <$> getDirectoryContents "/home/michael/blog/entries/"
23:26:44 <CakeProphet> I believe your arguments for <$> are swapped.
23:26:51 <CakeProphet> er... no
23:26:52 <CakeProphet> nevermind
23:26:55 <CakeProphet> I had them swapped.
23:27:15 <CakeProphet> applicative: I was also going to suggest creating a binding for that filename, which would take multiple lines.
23:28:21 <CakeProphet> applicative:  er, what am I saying... it wouldn't take multiple lines with a let. :P
23:28:45 <applicative> maybe put the pure function on the next line, so it's 
23:29:22 <applicative> entries <- mapM readFile entryFileName  . map ("/home/michael/blog/entries" </>) .filter (`notElem` [".",".."]) 
23:29:28 <applicative> woops
23:29:51 <applicative> entries <- mapM readFile  . map ("/home/michael/blog/entries" </>) .filter (`notElem` [".",".."]) $ entryFileName -- or something
23:30:06 <CakeProphet> it could actually benefit in clarity from /several/ bidings.
23:30:21 <CakeProphet> though I think what you have is "clear enough".
23:31:19 <Eduard_Munteanu> Hi.
23:32:14 <CakeProphet> Eduard_Munteanu:  hello there.
23:37:31 <CakeProphet> so how would I go about having a thread record an error message to a log file in the event that it crashes?
23:37:45 <CakeProphet> essentially: how to make exception handlers?
23:38:08 <dibblego> hamishmack, you there?
23:38:09 <c_wraith> look at Control.Exception
23:38:21 <CakeProphet> I'm familiar with writing to logs, I'm familiar with threads... so the only part missing is how to catch exceptions. I have never done this in Haskell.
23:38:33 <CakeProphet> c_wraith:  alright.
23:38:40 <c_wraith> look at the catch function in Control.Exception, and the SomeException type
23:38:54 <c_wraith> note that catch in Control.Exception is *not* the same as Prelude's catch
23:39:28 <CakeProphet> @hoogle catch
23:39:28 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
23:39:29 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
23:39:29 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
23:39:55 <CakeProphet> @instance Exception
23:39:55 <lambdabot> Maybe you meant: instances instances-importing
23:40:01 <CakeProphet> @instances Exception
23:40:02 <lambdabot> Couldn't find class `Exception'. Try @instances-importing
23:40:10 <CakeProphet> @instances-import Control.Exception Exception
23:40:11 <lambdabot> ArithException, ArrayException, AssertionFailed, AsyncException, BlockedIndefinitely, BlockedOnDeadMVar, Deadlock, ErrorCall, IOException, NestedAtomically, NoMethodError, NonTermination, PatternMatch
23:40:11 <lambdabot> Fail, RecConError, RecSelError, RecUpdError, SomeException
23:40:25 <CakeProphet> so IOError is not an Exception?
23:40:41 <c_wraith> It is part of the IOException case
23:40:49 <CakeProphet> ah.
23:40:56 <c_wraith> SomeException is a wrapper for catching all of them
23:41:00 <c_wraith> which is useful for logging
23:41:15 <CakeProphet> case e of SomeException e -> ... ?
23:41:56 <c_wraith> No.. More like "let handler :: SomeException -> IO () ; handler = blah"
23:42:12 <CakeProphet> ah
23:44:41 <CakeProphet> c_wraith:  hmmmm... so what if I did want to catch a specific error? How do you do that?
23:45:09 <c_wraith> CakeProphet: by using a handler function that only takes the specific error as an argument
23:47:28 <CakeProphet> c_wraith:  that's possible? the handler function has to accept any (Exception e) => e
23:47:53 <CakeProphet> hmmm... I bet you use a case statement
23:48:16 <c_wraith> CakeProphet, no, that syntax means the caller gets to choose which particular e to use, so long as it's an instance of Exception
23:48:32 <c_wraith> You're thinking of a rank-2 type, which would have a "forall e." in there
23:48:47 <int80_h> CakeProphet : you there?
23:48:54 <c_wraith> look at the examples in the Control.Exception module
23:48:55 <CakeProphet> int80_h:  indeed so
23:48:56 <int80_h> my power supply is flaky
23:48:59 <c_wraith> They're pretty good
23:49:02 <int80_h> and it is late
23:49:09 <CakeProphet> c_wraith:  alright. I'll check it out. Thanks for the help.
23:49:17 <CakeProphet> int80_h:  how'd it go?
23:49:20 <int80_h> would you mind putting the code we talked about on my hpaste?
23:49:35 <CakeProphet> hmmm? oh, want me to just show you how to change it?
23:49:39 <CakeProphet> by modifying it?
23:49:41 <int80_h> well I haven't tried anything yet, power supply is flaky. Getting late
23:49:53 <int80_h> sure, hpaste?
23:50:20 <int80_h> it's importent for me to understand the why's not just the how's but that is for another day.
23:50:36 <Zeiris> Can monadlib auto-derive monad transformer instances of my newtyped monad?
23:54:50 <CakeProphet> @hoogle Handler
23:54:50 <lambdabot> Control.Exception data Handler a
23:54:50 <lambdabot> Control.Exception Handler :: (e -> IO a) -> Handler a
23:54:50 <lambdabot> System.Console.Editline.Readline callbackHandlerInstall :: String -> (String -> IO ()) -> IO (IO ())
23:55:01 <CakeProphet> @hoogle Yesod.Handler
23:55:01 <lambdabot> No results found
