00:04:29 * hackagebot stringsearch 0.3.0 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.0 (DanielFischer)
00:11:27 <dafis> Is there a way to tell cabal/hackage to shut up about -O2, like "yes, I've checked, it does make a difference"?
00:12:38 <EvanCarroll> you know, I'm still up in the air if I can ever /learn/ this language.
00:13:03 <EvanCarroll> but for Cale, and BONUS, I think I'm nearing a satisifying defintion of Functor.
00:13:24 <EvanCarroll> http://stackoverflow.com/questions/3155469/help-haskell-functors-sink-in/3160085#3160085
00:13:37 <EvanCarroll> I find that to be the best text on Functor I've seen thus far.
00:15:44 <Cale> EvanCarroll: As far as you're concerned in Haskell, a Functor is a function on types (a type constructor), say F,
00:15:54 <Cale> So it sends each type a to another type F a
00:16:03 <Cale> Together with a definition of a function:
00:16:10 <Cale> fmap :: (a -> b) -> F a -> F b
00:16:26 <Cale> Which satisfies the laws:
00:16:29 <Cale> fmap id = id
00:16:37 <Cale> fmap (f . g) = fmap f . fmap g
00:16:54 <dskippy> Is there a simple way to figure out if some floating point number is an integer? I can't find anything like isInteger in the libraries.
00:17:55 <Cale> dskippy: Not a particularly simple way.
00:18:08 <Jafet> dskippy, is double-precision 1 * 2^100 an integer?
00:18:32 <tab> does hackage generate documentation by itself, or docs need to be included in the cabal sdist ?
00:18:39 <Cale> There is properFraction
00:18:43 <Cale> :t properFraction
00:18:44 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
00:18:54 <Cale> > properFraction pi
00:18:55 <lambdabot>   (3,0.14159265358979312)
00:19:13 <Cale> So you could use (== 0) . snd . properFraction
00:19:31 <dskippy> Cale: Or x=truc(x)
00:19:41 <Jafet> @pl \x -> x == round x
00:19:41 <lambdabot> ap (==) round
00:19:46 <Cale> Or, probably better, (< epsilon) . abs . snd . properFraction
00:20:05 <Cale> Hmm, did snd . properFraction have a name?
00:20:25 <Cale> Apparently not
00:20:28 <dolio> I don't think so.
00:20:59 <Cale> dskippy: You'll need an additional type conversion if you wanted to use x == truncate x
00:21:13 <Cale> x == fromIntegral (truncate x)
00:23:37 <Saizan> tab: the former
00:23:50 <tab> Saizan: thanks
00:25:43 <pizza_> > let epsilonApprox = (last . takeWhile (/= 1) . map (+1) . iterate (/2) $ 1) - 1 in epsilonApprox
00:25:44 <lambdabot>   2.220446049250313e-16
00:26:36 * hackagebot cryptohash 0.4.1 - crypto hashes fast and practical  http://hackage.haskell.org/package/cryptohash-0.4.1 (VincentHanquez)
00:48:16 <fatadelastana> Hi
00:50:27 <Axman6> 'lo
01:03:22 <ClaudiusMaximus> graphicsy algorithm that don't know the keywords to search: i want an aperiodic point set of uniform density, such that when i zoom in the apparent density stays roughly constant (new points appear in the gaps as the existing ones drift apart) - any ideas?
01:04:35 <ClaudiusMaximus> so far i've tried a periodic version (square grid, new points appear at the centers to form a diamond grid, new points appear at the centers to form another square grid) but the regularity is distracting
01:06:26 <Jafet> What are you doing that can be distracted from by periodic regularity?
01:06:34 <ClaudiusMaximus> Jafet: http://claudiusmaximus.goto10.org/v/misc/mandeljulia_b.ogv
01:06:55 <ClaudiusMaximus> Jafet: looks inorganic...
01:07:21 <Jafet> Bah, aesthetics was never one of my high points
01:07:58 <Jafet> Even aperiodic tilings generally appear regular
01:10:46 <ClaudiusMaximus> well the regularity isn't so much the problem, it's the strobing effect, if the new points appeared staggered over time instead of all at once then it would both look nicer and be more computationally friendly for realtime interaction
01:11:13 <bcw> is there any way to get haddock to show documentation for an instance of a typeclass I didn't create?  "-- | This doesn't work. [newline] instance Monad Foo where [indent] [newline] -- | Neither does this. [newline] return x = Foo x"
01:12:46 <Jafet> Suppose you can try any substitution tiling, or space-filling L system
01:13:32 <gwern> bcw: what does the haddock manual say?
01:13:47 <bcw> i can't find any information in the haddock manual about this
01:14:04 <gwern> how ironic
01:14:42 <gwern> if it's not in the manual, what makes you think it can be done?
01:15:19 <Cale> I don't think it can be...
01:15:31 <Cale> Haddock will list the instances along with the type
01:15:41 <Cale> But it doesn't really document them properly
01:15:49 <gwern> maybe the -- ^ syntax?
01:15:53 <Saizan> bcw: it is listed below Foo though, right?
01:16:05 <bcw> well, i'd be happy if it would just show that Foo was a Monad instance
01:16:18 <Cale> bcw: That it should do
01:16:29 <bcw> but it's not
01:17:28 <ClaudiusMaximus> Jafet: thanks, will go search on those keywords  :)
01:17:30 <Saizan> mh, maybe you lack or you didn't provide to haddock the haddock interface for base?
01:18:02 <bcw> how do i do that?
01:18:22 <gwern> depends on how you installed ghjc
01:18:36 <gwern>  hint: don't 'cabal install base --enable-documentation'
01:18:45 <bcw> i installed it with my package manager
01:19:04 <bcw> i'm on debian gnu/linux
01:19:24 <Saizan> bcw: there might be a separate -doc package
01:19:25 <gwern> ghc6-doc?
01:19:58 <bcw> ok, that package is already installed. now what?
01:20:01 <Saizan> there seems to be a "libghc6-base-doc"
01:20:30 <Saizan> how are you running haddock?
01:20:38 <bcw> directly
01:21:02 <gwern> odd. no base-dic here on ubuntu
01:21:23 <Saizan> then pass --read-interface=/path/to/base.haddock
01:21:49 <bcw> ok. lemme try that
01:23:09 <Saizan> "ghc-pkg field base haddock-interfaces" to find it
01:24:13 <bcw> ok, thanks, i was wondering how to do that too
01:25:21 <Saizan> http://hackage.haskell.org/packages/archive/MaybeT/0.1.2/doc/html/Control-Monad-Maybe.html#t%3AMaybeT <- then you should get the Monad one in the "Instances" section like here
01:28:27 <bcw> it's not happening
01:34:13 <bcw> is it easier to run hscolour + haddock from a cabal package?
01:34:31 <bcw> (it's been a while since i messed with cabal)
01:34:54 <gwern> think so
01:35:14 <bcw> is there a nice tutorial for creating cabal packages?
01:40:56 <bcw> i should have tried googling before i asked that
01:42:02 <bcw> so i'm gonna play around with the wikibook chapter on packaging for a while. later all
01:43:03 <Blkt> good day everyone
01:47:29 <gwern> Blkt: good day? some of us exist only to suffer, you insensitive clod!
01:54:59 <DarkUnicorn> gwern: you mean the java developers?
01:55:09 <gwern> @quote liberator
01:55:09 <lambdabot> gwern says: The Java programmers will welcome us as liberators! I estimate that we will need 50,000 haskellers at most and will be able to wind up the occupation quickly
02:00:25 <Blkt> gwern: I joined only #lisp, #haskell, #emacs and #scheme, so most of the people I hail do not suffer like java developers (at least I hope...)
02:00:35 <gwern> @quote java
02:00:35 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
02:00:43 <ClaudiusMaximus> Jafet: thanks again - substitution tilings seems to be the way to go; particularly this one looks promising: http://tilings.math.uni-bielefeld.de/substitution_rules/ammann_a3
02:01:04 <Blkt> ?
02:01:09 <Blkt> why?
02:10:36 <kmc> hi Blkt
02:11:29 <Blkt> hi kmc 
02:18:49 <gwern> it kind of blows my mind that jpeg was formalized in 1992 and hasn't changed much since
02:19:01 <gwern> while video codecs are *still* constantly permuting and evolving
02:19:15 <Jafet> JPEG was revised in 2000.
02:20:28 <gwern> 10 years ago is still huge :) and jpeg2000 isn't very popular compared to jpeg
02:20:37 <gwern> I don't see very many .jp2s around
02:20:48 <koala_man> yes, it's hold up extremely well
02:20:59 <Jafet> As for video codecs -- that happens to any IP-encumbered field
02:21:03 <arcatan> gwern: I guess pictures are so small nowadays, but videos are still big
02:21:09 <gwern> image formats seem to pretty much be a solved problem. while videos...
02:21:20 <kmc> it's because computers got fast and storage got big enough that people stopped giving a shit
02:21:21 <gwern> Jafet: images were encumbered! look at gif
02:21:22 <Jafet> It's easier to reinvent your own solution than to buy a license to someone else's.
02:21:30 <Jafet> Indeed -- hence PNG.
02:21:39 <gwern> heck, image formats are so old that they're actually out of *patent*
02:22:10 <gwern> (that feels so weird. almost like saying it's not an issue that ZFS was under the CDDL and thus GPL incompatible because now it's fallen into the public domain)
02:22:21 <Jafet> Also, I've noticed that many games are now using Vorbis for their audio data
02:22:45 <Ke> gwern: in public domain?
02:22:49 <gwern> Jafet: really? console stuff?
02:22:59 <Ke> spotify uses vorbis
02:23:06 <gwern> Ke: well, it'll be public domain in something like 80 years or something
02:23:13 <Ke> !
02:23:38 <gwern> Ke: my point being that IP expiring is so rare and unusual because the timespans involved are so large; yet, here's GIF with its IP expiring...
02:23:43 <Ke> it'll be succeded by btrfs by then
02:23:58 <koala_man> copyrights last a lot longer than patents
02:24:03 <Jafet> It's conceivable that contemporary copyrights will never expire, at least in certain jurisdictions
02:24:13 <Jafet> (If copyright durations are extended faster than they would expire.)
02:24:20 <gwern> koala_man: sure, but patents aren't trivial either
02:24:33 <koala_man> definitely not
02:29:16 * hackagebot feldspar-language 0.3 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.3 (EmilAxelsson)
02:30:17 * hackagebot feldspar-compiler 0.3 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.3 (EmilAxelsson)
02:31:12 <augur> anyone know if theres a calculus of sorts that looks at eh.. multi-value abstraction? like, if you've got a tuple (a,b) and a has 2 values and b has 2 values, then what you really have is 4 tuples?
02:31:41 <Jafet> augur, the non-deterministic turing machine?
02:32:22 <augur> well its related i suppose to non-determinism, but im not so much looking for a model of computation as a calculus that describes these types of structures
02:32:30 <Jafet> > replicateM 5 [1,2,3]
02:32:31 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,1],[1,1,1,2,2],[1,1,1,2,3],[1...
03:13:58 <Saizan> "data P a = KeepAll | ExcludeAll | Split a a" <- what name would you use rather than P?
03:14:34 <Saizan> the point is to have some "constructive" predicates of type (a -> P a)
03:18:46 <ivanm> not sure what it's doing there
03:18:58 <ivanm> give us an example type sig of when it would be used
03:22:17 <gwern> :( reddit's caching makes me unhappy. how can my comment swing 3 points in 1 second?
03:23:18 <roconnor> I should stop leaving comments on reddit
03:23:29 <ivanm> gwern: apparently there's some random factor as well
03:23:32 <ivanm> *shrug*
03:24:20 <gwern> I see comments on reddit as best done to either: a) correct stupidity/disinformation/ignorance or b) develop a seed of thought which one might turn into a blog posting or something
03:24:59 <dv-> I thought the swing was an antispam mechanism
03:25:07 <ivanm> well, someone on hacker news posted a link to an old (as in 2002) lambda the ultimate discussion where harrop admitted that Haskell was used in industry...
03:25:27 <dv-> reddit randomizes scores a bit so people who run bots can't tell if their programs are working
03:26:01 <gwern> that's wird. randomization just adds some noise
03:26:05 <roconnor> ivanm: where?
03:26:10 <gwern> the botrunners just need to get a larger sample then
03:26:10 <roconnor> oh
03:26:13 <roconnor> hacker news
03:28:05 <ivanm> http://lambda-the-ultimate.org/node/2491#comment-37446
03:29:00 <gwern> eh. easy to argue that one away. 'I was just going on the haskell hype and hadn't actually looked into users'
03:29:04 <gwern> he gives haskell one line
03:30:06 <gwern> did anyone really take up haskell just because of jones' paper?
03:31:43 <ivanm> *shrug*
03:32:04 <Zao> gwern: I picked it up after SPJ's Beautiful Concurrency chapter.
03:36:51 <kmc> Zao, that's what convinced you to learn haskell?
03:37:16 <Zao> Yeah, it just clicked with me.
03:38:02 <Zao> I had used some mosml as a freshman, but nothing more serious beforehand.
03:38:13 <Zao> Now I eat histomorphisms for breakfast.
03:42:37 <Baughn> The haskellmode-emacs trac (bug list) is taking minutes to show up.
03:42:39 <Baughn> Now I'm worried.
03:43:05 <Baughn> ..oh dear lord the spam
03:48:56 <ivanm> Baughn: heh
03:49:25 <Baughn> ivanm: Well, I fixed the cause of the spam..
03:49:31 <Baughn> But removing it all... um.
03:49:43 * Baughn goes off to experiment with ssh
03:49:52 <mpiechotka> @pl (\x y -> pure (f x y))
03:49:53 <ivanm> "oops, I accidentally deleted the trac for haskellmode-emacs! oh noes!"
03:49:53 <lambdabot> (pure .) . f
03:49:54 <ivanm> :p
03:57:00 <Baughn> ivanm: "delete from ticket where id > 20;"
03:57:08 <ivanm> aha
03:57:10 <Baughn> ...at least it wasn't mixed with usable tickets.
03:57:12 <Baughn> I hope.
03:57:14 <ivanm> heh
03:57:19 <Baughn> But there's no way I'm trawling 18,000 spam tickets.
03:59:01 <Zao> M-x trac-spam-cleanup-mode?
03:59:31 <ivanm> heh
03:59:57 <ivanm> @remember Zao [on the haskellmode-emacs trac being full of spam] M-x trac-spam-cleanup-mode?
03:59:57 <lambdabot> Nice!
04:00:56 * hackagebot ghc-events 0.2.0.1 - Library and tool for parsing .eventlog files from GHC  http://hackage.haskell.org/package/ghc-events-0.2.0.1 (SimonMarlow)
04:07:44 <dafis> Is anybody here familiar with the innards of Data.Text and ByteString?
04:09:29 <kmc> it's usually worth it to just ask your question
04:12:21 <dafis> Okay, I read a file with Data.Text.Lazy.IO, then I want to encodeUtf8 it to a lazy ByteString - segfault. Funnily enough, that happens only on some files, I suspect on large enough files.
04:13:02 <dafis> GHC-6.12.3 with text-0.7.1.0 says: sstextWTF: mallocPlainForeignPtrBytes: size must be >= 0
04:13:13 <dafis> 6.12.2 says the same
04:14:05 <ivanm> dafis: I have the sneaking suspicion that it wants another byte or so to finish encoding a character but there isn't one there
04:14:22 <dafis> 6.12.1 (text-0.7.1.0) and 6.8.3 with text-0.7.0.1 say: ssWTF121: internal error: getMBlock: mmap: Invalid argument
04:14:22 <dafis>     (GHC version 6.12.1 for i386_unknown_linux)
04:14:22 <dafis>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
04:14:46 <ivanm> *shrug* did you report the bug? :p
04:14:52 <dafis> ivanm: that may be, but the entire file is ASCII
04:15:03 <ivanm> oh.... interesting...
04:15:09 <ivanm> dafis: what is your system's locale?
04:15:20 <dafis> ivanm: not yet, I wanted to see whether I find out more here before reporting
04:15:49 <ivanm> also, what does the `file' command say about your file?
04:16:37 <dafis>  ASCII English text, with very long lines
04:16:55 <dafis> ivanm: which command do I use again to get the locale?
04:16:56 <ivanm> OK, so there shouldn't be any encoding problems
04:17:01 <ivanm> dafis: locale :p
04:17:08 <ivanm> dafis: paste the code you were using up?
04:17:34 <dafis> LANG=de_DE.UTF-8
04:17:43 <ivanm> OK, so it's UTF-8
04:19:10 <dafis> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26798#a26798
04:21:31 <ivanm> dafis: sure it's not bitching about the spat and ssub bits?
04:22:49 <dafis> ivanm: removed them, the same 
04:23:14 <ivanm> OK, it's not them
04:23:36 <ivanm> dafis: try removing your utxt and ttxt bit to track down where the problem is
04:23:48 <dafis> ivanm: it prints out "written original" fine
04:24:16 <ivanm> OK, so it looks like it's the encodeUTF8 bit that's playing up
04:24:21 <ivanm> interesting
04:24:23 <ivanm> preflex: seen bos
04:24:23 <preflex>  bos was last seen on #haskell 17 hours, 27 minutes and 57 seconds ago, saying: dcoutts_: i see.
04:24:29 <dafis> ivanm: so I'm pretty sure the problem is the conversion
04:24:36 <ivanm> yup
04:24:55 <ivanm> what's the type of encodeUtf8? L.Text -> L.ByteString ?
04:25:05 <dafis> and that seems rather a library problem than a compiler bug on the face of it
04:25:14 <dafis> ivanm: yesp
04:25:19 <dafis> yep
04:25:42 <ivanm> and if you remove the utxt stuff, does the ttxt stuff work OK?
04:25:51 <dafis> wait a sec
04:26:41 <dafis> umm, the ttxt is the result of decoding utxt, so I can't have that without utxt
04:26:55 <ivanm> oh, right
04:27:01 * ivanm facepalms
04:27:31 <dafis> If I remove both, all's well
04:28:10 <dafis> ivanm: wait, I'll see whether it works with strict Text/BS
04:29:53 <dafis> ivanm: Strict works
04:30:09 <ivanm> interesting
04:30:18 <ivanm> send an email to bos, asking if he knows wtf is going on
04:30:26 <ivanm> sure sounds like a Text bug to me
04:30:45 <dafis> ivanm: I agree
04:46:00 <aristid> why is user-state integrated in the Parsec monad? couldn't that be done with a normal monad transformer?
04:48:41 <Twey> Exposing transformers is usually not considered good style
04:49:05 <ksf> and using parsec with user state neither
04:49:43 <aristid> ksf: using the user state facility is discouraged? what should one use instead?
04:49:51 <ksf> no state
04:50:07 <ksf> use multiple passes if you have to, but state quickly leads to pain
04:51:03 <aristid> ah, i see
04:51:39 <ksf> if you really need to do a stateful computation, do a normal recursion on one of the intermediate results.
04:52:27 <aristid> ksf: what about using a Reader?
04:52:56 <ksf> when parsing layout, for example, I first tokenized into a structure which included EOL Int (where Int is the number of leading whitespace on the next line), transformed that to something easily parsable, and then ran the actual parser
04:53:11 <ksf> reader is ok
04:53:14 <ksf> writer, too.
04:53:44 <ksf> can't do anything wrong with thet former, and the only thing that could go wrong with the later is that you don't get the output you want.
04:54:03 <aristid> ParsecT ... Reader or ReaderT r Parsec ...? *slightly confused*
04:54:21 <ksf> doesnt' matter in that case
04:54:31 <ivanm> well, you generally want to add reader support to parsec rather than parsing support to reader
04:54:39 <ksf> but i'd do ReaderT Parsec
04:55:27 <aristid> ivanm: not because it wouldn't work, but because it would be weird?
04:56:08 <aristid> i wonder what to use ParsecT for then... does ParsecT IO make sense in some situations maybe? :D
05:00:01 <benmachine> ParsecT IO makes some sense, yes
05:00:20 <kmc> yeah
05:00:28 <benmachine> I used it to define a Stream instance that did from-file parsing without using lazy IO
05:00:29 <kmc> but like ContT IO, it won't undo your IO actions when it backtracks :)
05:00:46 <benmachine> but that's largely because I'm silly and still haven't learnt iteratees yet
05:04:27 <aristid> benmachine: Parsec is compatible with Iteratees?
05:04:44 <ksf> iteratees are compatible with virtually everything
05:05:02 <ksf> ...but you'd have to add a caching layer.
05:05:34 <ksf> backtracking parsers that don't tell you when they want to backtrack aren't being good citizens, and parsec is one of the iirc
05:06:07 <ksf> the usual way to do things is to use attoparsec
05:11:00 <aristid> ksf: ah, interesting, "While Attoparsec can consume input incrementally"
05:11:35 <aristid> so Parsec is really just for when you have relatively small amounts of data but want nice errors and convenience
05:11:51 <aristid> which is probably the majority of cases :D
05:12:56 <ksf> if you want real errors, you usually write a parser that accepts non-parsable things and puts them into the ast
05:13:37 <ksf> ...the important thing is positional information, and virtually all parsers support that.
05:15:34 <aristid> ksf: well when i wrote my last parser (for the icfpc circuit format), i added no error handling at all, and Parsec took care of it, and it was satisfying
05:15:56 <ksf> yep
05:16:05 <ksf> you might want to have a look at uulib
05:16:13 <ksf> which can do error correction
05:16:38 <soupdragon> hi
05:16:47 <ksf> ...that is, it can give you a list of deltas that would lead to valid input sorted by edit distance.
05:16:57 <ksf> *list of list of deltas
05:17:23 <soupdragon> how would you write a function that ord p n = m that gives the biggest m s.t. n = 0 (mod p)?
05:17:58 <ksf> it's also elegant as it can be, and has an abysmally cryptic outer interface.
05:20:03 <Phyx-> > #4
05:20:04 <lambdabot>   not an expression: `#4'
05:20:09 <Phyx-> > 4#
05:20:10 <lambdabot>   Couldn't match kind `#' against `*'
05:20:22 <benmachine> > I# 4#
05:20:23 <lambdabot>   Not in scope: data constructor `I#'
05:20:25 <benmachine> :(
05:20:34 <ksf> ooooooooooooh
05:20:41 <Phyx-> doesn't know unboxed anything seems like
05:21:00 <benmachine> soupdragon: er, where does the m come into it?
05:21:04 <ksf> If I split the interpreting part of yoctoparsec into two parts all my problems dissapear
05:21:14 <ksf> ...and it becomes apparent that there won't ever be a monad interface
05:21:59 <ksf> the trick is to turn the matching part into the usual dfa, outputting input to a nwa that does the applicative stuff.
05:22:18 <ksf> ...or possibly tree automata are powerful enough by themselves.
05:23:18 <ksf> specifically, have nesting when entering/leaving a kleene star.
05:26:14 <soupdragon> ord p (2^3 * 5^2 * ... * p^q * ...) = q
05:27:18 <aristid> ksf: error recovery means that i can report to the user "Did you mean: [list of valid inputs]"?
05:27:36 <int-e> > let ord p = length . takeWhile ((== 0) . (`mod` p)) . iterate (`div` p) in ord 5 3000
05:27:37 <lambdabot>   3
05:28:00 <ksf> aristid, yep
05:28:22 <aristid> ksf: that's pretty cool :)
05:28:33 <soupdragon> cool that is a lot neater than my version
05:29:10 <ksf> if you write a compiler that has type inferrence, you can even infer types for every of the possible parses and filter only the valid ones.
05:29:14 <int-e> > let ord p = length . takeWhile ((== 0) . (`mod` p)) . iterate (`div` p) in ord 5 0 -- oops.
05:29:19 <lambdabot>   mueval-core: Time limit exceeded
05:29:25 <aristid> :t let ord p = length . takeWhile ((== 0) . (`mod` p)) . iterate (`div` p) in ord
05:29:26 <lambdabot> forall a. (Integral a) => a -> a -> Int
05:29:40 <aristid> :t let ord p = genericLength . takeWhile ((== 0) . (`mod` p)) . iterate (`div` p) in ord
05:29:41 <lambdabot> forall b i. (Integral b, Num i) => b -> b -> i
05:29:44 <ksf> I think it's part of a bigger utrecht strategy for seriously helpful error messages.
05:30:25 <ksf> edit distance on identifiers would be easy to do even without parser support, though. I think there's work being done doing that for ghc
05:31:01 <ksf> otoh, error correction can quickly be very computationally expensive.
05:31:04 <aristid> ksf: seriously helpful error messages would be a big leap forward when i consider how much time i have spent on learning how to decipher c++ compiler error messages :D
05:31:50 <int-e> > let ord p = length . takeWhile (==0) . unfoldr (return . uncurry (flip (,)) . (`quotRem` p)) in ord 5 3000
05:31:52 <lambdabot>   3
05:37:30 <Baughn> haskell-mode 2.8.0 is out, now featuring syntax highlighting for (and quick access to) GHC core
05:37:40 <Baughn> And a couple other things
05:38:13 <tibbe> Baughn: yay!
05:42:49 <Baughn> tibbe: Next up: Rewriting the indenter in haskell.
05:43:50 <tibbe> Baughn: that would be nice
05:43:55 <tibbe> Baughn: working with a proper grammar
05:44:34 <tibbe> Baughn: I'd like to add the option to configure the ghc -c -ddump-simpl -O2 command so I can conveniently test with e.g. -O3
05:44:53 <Baughn> tibbe: Understandable. I'll see what I can do. :)
05:45:30 <tibbe> Baughn: thanks :)
05:45:40 * tibbe wishes he had more of a clue when it comes to elisp
05:46:08 <aristid> @pl \a b -> [a,b]
05:46:09 <lambdabot> (. return) . (:)
05:46:12 * danharaj wishes we didn't live in a world where honest hard working human beings have to work with elisp.
05:46:34 <aristid> danharaj: just thank god that it's at least not php :P
05:46:39 <Baughn> danharaj: There are /far/ worse things than elisp.
05:46:49 <Baughn> Actually, I kind of enjoy working with it
05:46:54 <Baughn> I just don't want to write a huge parser in it.
05:46:55 <danharaj> There are also far worse things than dysentery :[
05:47:01 <Jafet> I'd rather have my modes written by honest, hard working human beings!
05:47:15 * Baughn actually sells cars to make a living
05:47:18 <Baughn> Used cars
05:47:37 <danharaj> Oh god.
05:47:43 <danharaj> That's brutal.
05:57:47 <soupdragon> > 2/(1-5*((1)/(2))^3 + 9*((1*3)/(2*4))^3 - 13*((1*3*5)/(2*4*6))^3)
05:57:48 <lambdabot>   4.416172506738545
05:58:18 <soupdragon> > 2/(1-5*((1)/(2))^3 + 9*((1*3)/(2*4))^3 - 13*((1*3*5)/(2*4*6) + 17*((1*3*5*7)/(2*4*6*8)))^3)
05:58:19 <lambdabot>   -1.2607469023579899e-3
05:58:25 <soupdragon> doesn't seem to be giving pi
06:00:33 <Jafet> > pi
06:00:35 <lambdabot>   3.141592653589793
06:00:51 <Jafet> > showCReal 100 pi
06:00:53 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
06:01:10 <zygoloid> > last $ showCReal 10000 pi
06:01:14 <lambdabot>   mueval-core: Time limit exceeded
06:02:27 <soupdragon> > 2/(1-5*((1)/(2))^3 + 9*((1*3)/(2*4))^3 - 13*((1*3*5)/(2*4*6) - 17*((1*3*5*7)/(2*4*6*8)))^3)
06:02:28 <lambdabot>   1.8857736216822908e-3
06:02:35 <soupdragon> > 2/(1-5*((1)/(2))^3 + 9*((1*3)/(2*4))^3 - 13*((1*3*5)/(2*4*6)^3 - 17*((1*3*5*7)/(2*4*6*8)))^3)
06:02:36 <lambdabot>   1.5308095404685247e-3
06:02:48 <soupdragon> > 2/(1-5*((1)/(2))^3 + 9*((1*3)/(2*4))^3 - 13*((1*3*5)/(2*4*6))^3 - 17*((1*3*5*7)/(2*4*6*8))^3)
06:02:49 <lambdabot>   18.98863209362338
06:02:55 <soupdragon> very odd
06:03:02 <Jafet> You're no ramanujan
06:03:57 <technogeeky> Jafet: lol
06:04:08 <soupdragon> > 2/(1-5*((1)/(2))^3 + 9*((1*3)/(2*4))^3 - 13*((1*3*5)/(2*4*6))^3 + 17*((1*3*5*7)/(2*4*6*8))^3)
06:04:09 <lambdabot>   2.498639668540213
06:04:25 <technogeeky> Jafet: He was such a fascinating case of savantism.
06:04:31 <zygoloid> > 2 / (1 - 5 * (1/2)^3 + 9 * (1*3/2/4)^3 - 13 * (1*3*5/2/4/6)^3 + 17 * (1*3*5*7/2/4/6/8)^3 - 21 * (1*3*5*7*9/2/4/6/8/10)^3)
06:04:32 <lambdabot>   4.102965324556715
06:04:58 <soupdragon> [1,3..] [2,4,..
06:05:05 <zygoloid> > 2 / (1 - 5 * (1/2)^3 + 9 * (1*3/2/4)^3 - 13 * (1*3*5/2/4/6)^3 + 17 * (1*3*5*7/2/4/6/8)^3 - 21 * (1*3*5*7*9/2/4/6/8/10)^3 + 25 * (1*3*5*7*9*11/2/4/6/8/10/12)^3)
06:05:06 <lambdabot>   2.5824829452880547
06:05:13 <zygoloid> i thought this was supposed to converge quickly :(
06:05:27 <soupdragon> > 2/sum . map (\i -> (4*i+1)*(take i [1,3..] / take i [2,4,..])^3) [1..20]
06:05:27 <lambdabot>   <no location info>: parse error on input `..'
06:05:29 <zygoloid> > 2 / (1 - 5 * (1/2)^3 + 9 * (1*3/2/4)^3 - 13 * (1*3*5/2/4/6)^3 + 17 * (1*3*5*7/2/4/6/8)^3 - 21 * (1*3*5*7*9/2/4/6/8/10)^3 + 25 * (1*3*5*7*9*11/2/4/6/8/10/12)^3 / 2)
06:05:30 <soupdragon> > 2/sum . map (\i -> (4*i+1)*(take i [1,3..] / take i [2,4,..])^3) $ [1..20]
06:05:30 <lambdabot>   3.169821244020189
06:05:31 <lambdabot>   <no location info>: parse error on input `..'
06:05:33 <zygoloid> ah, that's a bit better
06:05:35 <soupdragon> > 2/(sum . map (\i -> (4*i+1)*(take i [1,3..] / take i [2,4,..])^3) $ [1..20])
06:05:36 <lambdabot>   <no location info>: parse error on input `..'
06:06:08 <Jafet> Idoru got jealous.
06:06:17 <marienz> ban's already unset, does that bot auto-reconnect?
06:06:31 <technogeeky> marienz: we'll find out
06:06:53 <soupdragon> marienz sorry am I being excessive
06:06:57 <kmc> that's new isn't it?
06:07:01 <marienz> it is
06:07:22 <marienz> kmc: someone (might've been me, to be honest I forgot and would have to check my logs) joined idoru here to remove those webchat spambots that were hitting this channel earlier
06:07:43 <marienz> kmc: unfortunately idoru is a little oversensitive and also removes friendly bots or users (which is why she's not in even more channels)
06:07:50 <kmc> i see
06:07:57 <technogeeky> i'm surprised, given the ~ 700 people in here, that there isn't a separate channel for lambdabot
06:08:05 <benmachine> you can PM her
06:08:30 <soupdragon> technogeeky most haskell I learned is seeing other peopel play with the bot
06:08:35 <soupdragon> probably about half
06:08:50 <technogeeky> soupdragon: I don't know what to say.
06:09:07 <kmc> when #haskell gets really full sometimes people go to #haskell-overflow
06:10:49 <arcatan> what happens, when #haskell-overflow gets really full?
06:11:00 <exDM69> #haskell-overflow'
06:11:00 <technogeeky> arcatan: netsplit
06:11:10 <kmc> we draw straws and whoever loses has to become a PHP user
06:11:29 <technogeeky> of course, we're so dogmatic, they usually end up committing sepuku
06:11:55 <bremner> if you think that is an important distinction.
06:11:56 <soupdragon> that's never happened
06:12:44 <kmc> there's also #haskell-in-depth aka #haskell-idling
06:12:49 <technogeeky> http://meltronx.com/lhccoord.html
06:12:58 <technogeeky> the LHC is playing in Holland v. Brazil
06:13:20 <technogeeky> after 7 on 7 physics. I guess that's their warm up
06:13:30 <aristid> uulib has a lot of functions that are also in Applicative, but it seems to never use Applicative. does it maybe predate Applicative?
06:13:40 <soupdragon> have the LHC produced any results yet???
06:13:45 <technogeeky> soup: yes
06:13:50 <technogeeky> The first presentation is July 27
06:14:05 <technogeeky> i've been following it daily
06:14:06 <kmc> in my brief time here we've also had #haskell-markov, #haskell-stoners, and #haskelgbt
06:14:07 <soupdragon> what have they found
06:14:14 <exDM69> at least they have a mongodbful of data to crunch
06:14:22 <technogeeky> W+ and Z bosons
06:14:24 <technogeeky> pions
06:14:30 <technogeeky> all recreating existing particles
06:14:36 <technogeeky> (which is how they calibrate the machine)
06:14:45 <technogeeky> exDM69: Yes. A few petabytes so far.
06:14:47 <soupdragon> I see
06:15:10 <kmc> pions are so last century
06:15:34 <technogeeky> I haven't seen any pictures that are at all Higgs-like
06:15:42 <technogeeky> but not all of the renderings are released
06:15:45 <kmc> the technical term is "higgsy"
06:15:52 <technogeeky> higgsino
06:16:04 <soupdragon> higgs doesn't exist
06:16:05 <technogeeky> they are doubling luminosity today
06:16:15 <technogeeky> soupdragon: I agree
06:16:21 <technogeeky> fortunately it doesn't matter what we think
06:16:39 <technogeeky> As R. Feynman says, if the experiment disagrees with you, you're wrong!
06:16:48 <exDM69> when was exception handling introduced to haskell? I recall hearing SPJ saying that exceptions cannot be caught easily in the "a taste of haskell" video some years ago
06:17:21 <kmc> exDM69, see the three citations at the top of http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html
06:17:37 <davidc_> I think Feynman forgot to finish this sentence. "If the experiment disagrees with you, you're wrong until the experiment agrees with you"
06:17:40 <kmc> 1999 / 2001 / 2006
06:18:07 <kmc> not sure when they were first implemented
06:18:13 <technogeeky> davidc_: http://www.youtube.com/watch?v=b240PGCMwV0
06:18:17 <kmc> but "imprecise exceptions" already covers throwing exceptions from pure code
06:18:30 <kmc> by which i mean, throwing exceptions as a result of evaluation, not only execution
06:18:43 * ksf wonders why tuple sections need an extension and then realizes he'd better not know
06:18:44 <technogeeky> "Guess -> Compute Consequences -> Compare Results to Experiment"
06:18:48 <davidc_> technogeeky: yeah I've seen pretty much all videos of Feynman :)
06:18:56 <technogeeky> davidc_: i have the audio lecture series
06:18:58 <technogeeky> if you'd like
06:19:01 <davidc_> http://research.microsoft.com/apps/tools/tuva/ 
06:19:02 <soupdragon> I'm watching the ones on Tuva
06:19:04 <soupdragon> yes
06:19:07 <Jafet> ksf, I thought the only extension it needs is -XTupleSections
06:19:09 <soupdragon> he is such a good speaker
06:19:11 <technogeeky> yes, those are 7 of about 100 lectures
06:19:15 <davidc_> He is :)
06:19:21 <soupdragon> 100?
06:19:22 <technogeeky> If you want to learn modern physics
06:19:26 <technogeeky> soupdragon: maybe more
06:19:27 <ksf> Jafet, exactly
06:19:31 <soupdragon> but you mean like
06:19:32 <technogeeky> there are 3 semesters worth
06:19:34 <soupdragon> ones that you can watch
06:19:40 <technogeeky> soupdragon: ones you can listen to
06:19:59 <technogeeky> http://en.wikipedia.org/wiki/The_Feynman_Lectures_on_Physics
06:20:12 <soupdragon> I thought that was a book
06:20:13 <technogeeky> if you want to learn modern physics, the best place I've seen so far is Leonard Susskind's lecture series
06:20:14 <exDM69> kmc: neat, thanks
06:20:32 <soupdragon> I watched Leonard Susskins thing on quantum .......   did not make any sense lol
06:20:37 <davidc_> Physicists with their weird minds... I'd rather stay in maths.
06:20:49 <technogeeky> http://newpackettech.com/Resources/Susskind/
06:20:49 <davidc_> My little bubble of mathematics :)
06:21:04 <technogeeky> soupdragon: it's a pretty challenging subject
06:21:31 <soupdragon> I think I have to learn classical mechanics and electrodynamics and probably a few other things before even trying to get into quantum
06:22:01 <davidc_> soupdragon: nonetheless he's a good speaker to listen to :)
06:22:06 <soupdragon> who?
06:22:18 <davidc_> Oh sorry I was back on RF, not Susskind
06:22:32 <soupdragon> yeah I love to watch the feynman talks they
06:22:52 <arw_> soupdragon: electrodynamics is not totally necessary, but the vector maths you will learn will help to understand quantum mechanics.
06:23:15 <arw_> soupdragon: feynman is nice as an overview.
06:23:29 <DevHC> RIP, lambdabot
06:23:48 <soupdragon> arw_, yes it has become clear to me that almost all the mathematics I have learned (in mathematics classes) are completely stupid and useless (except for the number theory) -- it was all rubbish attempts at teaching the mathematics of physics with the physics part castrated
06:23:48 <kmc> at Caltech, "RF" is also a verb meaning to freeze a dead rat in liquid nitrogen and throw it through someone's window 
06:23:52 <benmachine> lambdabot's just having a nap
06:23:57 <kmc> i wonder if there is any connection
06:24:02 <benmachine> she'll be around
06:24:09 <soupdragon> arw_, so I have a lot of work to do -_-
06:24:12 <DevHC> she?
06:24:12 <DevHC> lol
06:24:31 <Axman6> yes she
06:24:37 <kmc> lambdabot is female
06:24:40 <DevHC> officially?
06:24:48 <kmc> if you ask her name through @vixen she says "My name is Emily"
06:24:57 <DevHC> @vixen
06:25:03 <DevHC> WAKE UP
06:25:27 <theorbtwo> @vixen What is your name?
06:27:12 <technogeeky> I actually chose to learn Haskell because of physics
06:27:23 <soupdragon> really???
06:27:25 <technogeeky> because I wanted to study fractal geometries
06:27:29 <technogeeky> yep
06:27:38 <Twey> I can see how laziness might be useful there
06:27:38 <soupdragon> oh like how do fractals vibrate and stuff?
06:28:45 <jmcarthur> wow, potential is going to make me hate C
06:28:46 <technogeeky> Twey: precisely. The fractal i'm interested has an infinite and recursive definition
06:29:10 <jmcarthur> and that's saying a lot considering that it's low level assembler
06:29:15 <ksf> there's no infinite definitions. just infinite terms.
06:29:17 <technogeeky> soupdragon: yes. At this point, I'm strictly interested in the rotation properties
06:29:34 <soupdragon> I heard there are people who do calculus on fractals
06:29:40 <soupdragon> as if calculus on manifolds wasn't hard enough...
06:29:48 <ksf> except when a term is a definition, of course, in which case you have a problem.
06:29:57 <soupdragon> solve the heat equation on the mandelbrot
06:30:00 <technogeeky> ksf: hmm? I guess so. It's infinite in two directions
06:30:13 <ivanm> Baughn: any particular reason for making the release twice?
06:30:18 <ivanm> (or did gmail just stuff up?)
06:30:23 <Jafet> ksf: wait till you go into model theory
06:30:31 <technogeeky> soupdragon: Luckily, I don't have any desire to attempt to see if I can implement a calculus of variations over a fractal
06:30:58 <davidc_> Jafet: model theory is great
06:30:59 <Baughn> ivanm: I sent the first one from the wrong email address, and so it was rejected from haskell-cafe.
06:31:26 <Jafet> The infinitely infinite ones are the best
06:31:28 <technogeeky> Plus, modern physics *is* a study of group theory, so I figured where better to start
06:31:48 <ivanm> Baughn: oh, but the haskellmode mailing list accepted it?
06:31:53 <davidc_> I use some concepts of model theory in game theory and it turns out to be some quite promising results :)
06:31:54 <soupdragon> but when you say group theory
06:32:00 <technogeeky> gauge theory
06:32:01 <Baughn> ivanm: Because I'm the administrator, yeah..
06:32:02 <soupdragon> does it really mean groups or just lie groups?
06:32:02 <technogeeky> more specifically
06:32:06 <technogeeky> both
06:32:14 <soupdragon> btw
06:32:31 <soupdragon> hmm
06:32:34 * ksf would be willing to get into maths if there would be introductionary material using intuitionistic type theory
06:32:48 * technogeeky looks up intuitionistic
06:32:58 * technogeeky uses intuitionistic reasoning instead
06:33:12 <ivanm> @wn intuitionistic
06:33:14 * Baughn is very much a formalist
06:33:23 <ivanm> where's lambdabot?
06:33:28 <Baughn> Vacation
06:33:33 <kmc> passed out in a gutter
06:33:33 <technogeeky> we sacrafacied him
06:33:34 <ksf> my mind tilted at integrals exactly because stuff just didn't make any sense, anymore.
06:34:06 <ksf> not that anything did before, at least after I read bucky.
06:34:13 <soupdragon> bucky??
06:34:22 <ksf> buckminster fully
06:34:28 <ksf> like in buckyball
06:34:34 <ksf> or buckminster-fullerenes
06:34:35 <technogeeky> http://en.wikipedia.org/wiki/Buckminster_Fuller
06:34:52 <ivanm> ksf: no hyphen
06:35:08 <kmc> âŠ¢ âŠ¥
06:35:13 <soupdragon> it says Fuller published more than 30 books,
06:35:32 <McManiaC> is there any way to use a "MonadIO m => m ()" function with "forkIO :: IO a -> IO ThreadId" ?
06:35:54 <technogeeky> McManiaC: I have no idea, so I guess: yes.
06:35:58 <ivanm> McManiaC: that looks like a value, not a function...
06:35:59 <kmc> McManiaC, yes, IO is an instance of MonadIO so that should work straight out
06:36:01 <ivanm> @instances MonadIO
06:36:07 <ivanm> dammit, no bot :@
06:36:08 <kmc> also that's not a function
06:36:20 <adnap> Can ghc compile c code?
06:36:43 <kmc> adnap, if you pass it a .c file on the command line, it will invoke the c compiler for you
06:36:51 <kmc> it doesn't itself know how to compile c
06:36:56 <McManiaC> > let f :: MonadIO m => m (); f = return () in forkIO f
06:37:04 <adnap> kmc: Oh, okay.  Does it do the same with C++ code?
06:37:07 <ksf> soupdragon, featuring wonderful near-crackpot sentences like "Universe is the comprehensive, historically synchronous, integral-aggregate system embracing all the separate integral-aggregate systems of all men’s consciously apprehended and communicated (to self or others) nonsimultaneous, nonidentical, but always complementary and only partially overlapping, macro-micro, always-and- everywhere, omnitransforming, physical and metaphysical, weighable and unw
06:37:07 <ksf> eighable event sequences. Universe is a dynamically synchronous scenario that is unitarily nonconceptual as of any one moment, yet as an aggregate of finites is sum-totally finite."
06:37:10 <kmc> adnap, don't know
06:37:39 <DevHC> > { f ~str@(x:xs) = str ; f "" } <-- yields an error. is that how it should be? 
06:38:00 <Baughn> ksf: Are you quite sure that's just /near/-crackpot?
06:38:00 <McManiaC> kmc: well, IO is *one* instance for MonadIO, but m can be more generell
06:38:01 <Jafet> ksf: that seems well within the crackpot radius
06:38:18 <ksf> hell yes. his whole maths is non-standard
06:38:32 <ksf> but his domes still stand stable as ever
06:38:49 <kmc> McManiaC, a value of type Â«(MonadIO m) â‡’ m ()Â» is guaranteed to work for âˆ—anyâˆ— instance
06:39:08 <ksf> it's one of those people you can't file under crackpot because he did a lot of utterly useful real-world applications
06:39:46 <soupdragon> "his whole maths is non-standard" - for example?
06:41:16 <ksf> i don't think I'm mathematician enough to answer that satisfactory
06:41:32 <soupdragon> huh
06:41:51 <kmc> ksf, fitting then that one of the prominent uses of geodesic domes today is as temporary structures for people living in the desert blasted out of their minds on psychedelic drugs
06:41:52 <ksf> ...but suffice to say that fullerenes got their name because physicists figured out that the only viable maths to describe them is bucky's.
06:42:02 <ksf> it's all deeply geometrical
06:42:11 <danharaj> who's a crackpot?
06:43:02 <kmc> http://www.desertdomes.com/domecalc.html
06:43:04 <ksf> soupdragon, http://www.rwgrayprojects.com/synergetics/toc/toc.html 
06:43:42 <danharaj> ok definitely a crackpot
06:43:51 <danharaj> has a website that looks like it was designed in the early nineties
06:43:58 <ksf> also, more accessible: http://www.angelfire.com/mt/marksomers/40.html
06:44:11 <ksf> (that is, you don't have to learn his language)
06:44:22 <technogeeky> angelfire
06:44:22 <technogeeky> lol
06:44:27 <technogeeky> watch out for internet herpes
06:44:33 <benmachine> did anyone else get something like 'The message "[Haskell] Delivery reports about your e-mail" from jon.fairbairn@email.address  contained a virus or a suspicious attachment.'
06:44:39 <kmc> you can build a huge (30+ feet diameter) geodesic dome which collapses to fit in the trunk of a car and reassembles in an hour (if you have enough people to hold it up)
06:44:41 <kmc> pretty cool
06:44:45 <benmachine> from gmail
06:44:52 <ivanm> benmachine: no, but I used to get a lot from some blackberry address for a while
06:45:05 <ivanm> as in "this message could not be delivered" messages
06:45:18 <ivanm> this was apparently in response to some messages I sent to -cafe
06:45:36 <ksf> danharaj, bucy itself definitely has no website
06:46:06 <ksf> and think of angelfire as you might, that's just the online edition of an actual, printed book.
06:46:24 <soupdragon> wow that's so funny he sounds like a total crank
06:46:39 <soupdragon> http://www.angelfire.com/mt/marksomers/65.html - the pi thing
06:46:39 <McManiaC> kmc: can you tell me what's wrong here? http://npaste.de/aX/
06:47:38 <kmc> McManiaC, what error message do you get?
06:47:45 <McManiaC> kmc: just added it, reload
06:48:05 <ksf> soupdragon, why, you tell me nature splits up atoms to satisfy a mathematicians's "intuition" of the value of pi?
06:48:50 <kmc> McManiaC, the problem is that forkIO gives you an IO action specifically, not an action in any desired MonadIO
06:48:58 <kmc> try Â«liftIO . forkIO $ ...Â»
06:49:06 <soupdragon> " Everything I Know" 42 hours of Buckminster Fuller - this is gonna be fun
06:49:11 <aristid> ksf: oh you're back. why doesn't uulib use Applicative and redefine <**> and so on?
06:49:26 <McManiaC> kmc: hmmm I have a "liftIO $ do ..." on the beginning of that function
06:49:26 <marienz> ugh. Your bot was only just now unklined (PEBKAC on my part)
06:49:37 <kmc> hmm true McManiaC
06:49:37 <ksf> aristid, performance considerations
06:49:48 <marienz> if someone can tell it to reconnect you might want to do so
06:49:50 <ksf> they can give more efficient implementations of the combinators that way
06:50:00 <kmc> McManiaC, but you're also lifting the RHS of (>>) separately
06:50:17 <aristid> ksf: but couldn't they at least give me instances of Applicative and so on, too?
06:50:40 <McManiaC> kmc: since "runMState m s" is of type "m a"
06:50:53 <McManiaC> "m ()" actually
06:51:13 <ksf> I'd think so, but it might not be a good idea
06:51:13 * kmc forgot whether ($) or (>>) has higher precedence
06:51:19 <McManiaC> $
06:51:21 <ivanm> preflex: seen Cale 
06:51:21 <preflex>  Cale was last seen on #haskell 5 hours, 35 minutes and 3 seconds ago, saying: bcw: That it should do
06:52:15 <McManiaC> http://npaste.de/aY/ works just fine, kmc :S
06:53:33 <ivanm> edwardk: it appears that you wouldn't hire me according to your criteria :(
06:54:40 <soupdragon> http://video.google.com/videoplay?docid=8657478341392737091&pr=goog-sl#
06:54:52 <adnap> Can anyone who has used the FFI tell me how I might best call my Haskell functions from C code?  I'm following this guide: http://www.haskell.org/ghc/docs/6.10.3/html/users_guide/ffi-ghc.html I'm not sure whether to deploy my functions as a library or if I'm to compile it all together.
06:54:58 <ivanm> anyone know why edwardk can't talk here?
06:55:10 <kmc> adnap, did you read the RWH chapter on FFI?
06:55:20 <ivanm> adnap: you can just bundle the C files with your Haskell code
06:55:23 <kmc> not sure if it covers this actually
06:55:39 <adnap> kmc: What is RWH?
06:55:44 <kmc> @where RWH
06:55:44 <ivanm> @where rwh
06:55:47 <kmc> grr
06:55:48 <ivanm> dammit, no bot :@
06:55:52 <ivanm> realworldhaskell.org
06:55:55 <ivanm> adnap: ^^
06:56:00 <kmc> http://book.realworldhaskell.org/read/
06:56:04 <ivanm> @where ops
06:56:05 <adnap> No, I didn't read that chapter.
06:56:09 <ivanm> dammit
06:56:58 <JaffaCake> why is there no "hello world" package on Hackage?
06:57:00 <adnap> See, if ghc does not compile C programs directly, don't I just want to make a library of Haskell functions and then use gcc like I normally would for my C programs?
06:57:11 <ivanm> JaffaCake: why should there be?
06:57:33 <JaffaCake> it would be a useful way to see how to put together a Cabal package
06:57:44 <kdvh> ivanm: is that a better tut than learn you a haskell?
06:57:46 <JaffaCake> I thought we had one, but I must be wrong
06:57:57 <ivanm> kdvh: you want a book or online?
06:57:57 <adnap> JaffaCake: http://github.com/git/hello-world/blob/master/haskell.hs
06:58:04 <ivanm> JaffaCake: oh, the wiki has something like that
06:58:10 <kdvh> ivanm: either
06:58:11 <ivanm> and dons had a blog post
06:58:13 <kmc> kdvh, LYAH and RWH are both popular.  they're very different
06:58:30 <JaffaCake> adnap: yes, I do know how to write hello world :)
06:58:32 <ivanm> kdvh: for books, I recommend Craft of Functional Programming by Simon Thompson or Haskell School of Expression
06:58:34 <kdvh> im using lyah now but it isnt complete
06:58:37 <kmc> McManiaC, consider the expression Â«\m -> MState $ \s@(t,c) -> liftIO $ do { w <- newEmptyMVar; runMState m s }Â»
06:58:40 <ivanm> Graham's newish books isn't meant to be too bad either
06:58:51 <kmc> McManiaC, if i understand correctly you'd like this to have type Â«(MonadIO m) => MState t m a -> MState t m aÂ»
06:58:58 <ivanm> otherwise, there's Yet Another Haskell Tutorial (YAHT), which is being integrated into the Haskell wikibook
06:59:06 <kmc> but GHCi says it has type Â«(MonadIO m) => MState t IO a -> MState t m aÂ»
06:59:23 <kdvh> ivanm: ill look those books up, thanks
06:59:23 <McManiaC> yeh
06:59:42 <ivanm> kdvh: np
07:01:22 <kmc> McManiaC, because if Â«m :: MState t m aÂ» then Â«runMState m s :: m aÂ»
07:02:19 <kmc> and so in Â«newEmptyMVar >> runMState m sÂ»
07:02:57 <dpratt71> I was thinking about automated testing of Haskell programs recently...
07:03:23 <kmc> the left-hand argument to (>>) has type Â«IO (MVar t)Â», so the right hand side has type Â«IO aÂ» for some a
07:03:35 <kmc> thus inferring m = IO
07:03:38 <dpratt71> ...and I was thinking how cool it would be if there could be a "simulated IO" environment in which to test IO actions
07:03:45 --- mode: ChanServ set +o Saizan
07:04:25 <kmc> McManiaC, what i'm trying to work out now is why it still doesn't work even if you use Â«liftIO newEmptyMVarÂ»
07:04:26 <Jafet> dpratt: there's expect
07:04:30 <McManiaC> kmc: well well well -- I dont use "IO" and "m" in the same do-block
07:04:34 <adnap> Where is HsFFI.h?
07:04:39 <McManiaC> I use IO and then forkIO that "m" action
07:04:47 <Zao> kmc: Your use of Â«Â» as quotes look scary when talking about (>>).
07:04:48 <dpratt71> Jafet: what's that?
07:04:52 <kmc> yeah Zao
07:04:59 <McManiaC> hehe
07:05:14 <kmc> McManiaC, what's your point?
07:05:16 <JaffaCake> adnap: in your GHC installation
07:05:32 <Jafet> dpratt, a tool to control other programs (through stdin/stdout)
07:05:34 <adnap> JaffaCake: Do I have to manually specifiy where it is when I compile my code?
07:05:49 <ivanm> you shouldn't have to
07:05:54 <ivanm> since GHC should know where it is
07:05:56 <JaffaCake> adnap: usually not.  what are you trying to do?
07:05:56 <McManiaC> forkIO $ (runMState m s :: MonadIO m => m a) >> return () -- should work, but it doesntâ€¦
07:06:29 <dpratt71> Jafet: Linux tool? Can it intercept file read/write?
07:06:33 <jkramer_> Hi
07:06:35 <Jafet> dpratt71: or are you thinking about turning IO into some deterministic ST-like thing?
07:06:38 <kmc> McManiaC, well, do we agree on why Â«\m -> MState $ \s@(t,c) -> liftIO $ do { newEmptyMVar; runMState m s } :: (MonadIO m) => MState t IO a -> MState t m aÂ»
07:06:47 <adnap> JaffaCake: I'm trying to compile the example on this page: http://www.haskell.org/ghc/docs/6.10.3/html/users_guide/ffi-ghc.html
07:07:01 <Jafet> dpratt71: on linux, most "IO" involves syscalls, so you can intercept them with ptrace
07:07:02 <McManiaC> kmc: sure, but that isnt my problem ^^
07:07:06 <kmc> ok
07:07:06 <Jafet> None of this is haskell-specific, mind you
07:07:08 <jkramer_> Is there a way to do this in a more "clever" way? http://pastie.org/1028126
07:07:10 <kmc> it's a subpart of your problem
07:07:14 <adnap> JaffaCake: Under, "Using your own main()"
07:07:39 <jkramer_> I think it's to verbose, the only think that changes is the string for pattern matching and the accessor function for the record
07:07:48 <JaffaCake> adnap:  compile the C file using ghc, not gcc
07:07:58 <adnap> JaffaCake: I am.
07:08:10 <ivanm> jkramer_: a map?
07:08:14 <JaffaCake> hmm, then it should work
07:08:26 <kmc> jkramer_, unfortunately field labels are not first-class so there will still be a bit of boilerplate
07:08:34 <kmc> jkramer_, look for one at the "fclabels" package
07:08:40 <ivanm> jkramer_: maybe it'd be possible to make it even nicer using fc-labels or some other record extension library
07:08:57 <JaffaCake> adnap: works here
07:09:04 <ivanm> actually, that's a fold, not a map
07:09:13 <dpratt71> Jafet: basically, I think it would be nice if I could intercept GHC's handling of IO actions to simulate IO (for testing purposes)
07:09:24 <DevHC> { f ~str@(x:xs) = str ; f "" } <-- yields an exception. anyone wanna say wether this is intentional and why?
07:09:25 <jkramer_> ivanm: You mean something like [("blocktype", blockType")] ?
07:09:32 <kmc> jkramer_, why don't you match Â«parseBlock' b (Pair x text : xs)Â»
07:09:32 <adnap> JaffaCake: Okay, so first, how did you compile "foo.hs?"  I did: ghc -XForeignFunctionInterface foo.hs
07:09:41 <ivanm> jkramer_: no, I mean the whole list thing
07:09:48 <kmc> jkramer_, and then do separate matches or Data.Map lookups on x
07:10:17 <JaffaCake> adnap: add -c
07:10:21 <ivanm> use foldr and write a function to do that Pair matching for you
07:10:25 <ivanm> rather than manually recursing
07:10:57 <jkramer_> Right
07:11:00 <kmc> McManiaC, what's the point of ">> return ()" in your example?
07:11:06 <Jafet> dpratt71: isn't there some way to convert IO to ST? Then you can programmatically supply inputs
07:11:11 <jkramer_> But I was more looking for a solution for all the repetitions
07:11:15 <Jafet> @hoogle... oh, crud
07:11:23 <ivanm> Jafet: unsafeIOtoST or something IIRC
07:11:26 <jkramer_> I think I'll try the map [(String, (Block -> String))]
07:11:27 <ivanm> Jafet: heh
07:11:36 <McManiaC> kmc: none actuallyâ€¦
07:11:42 <McManiaC> kmc: neither of those work: http://npaste.de/aZ/
07:11:49 <ivanm> jkramer_: and then define parseBlock' in terms of a fold
07:11:58 <jkramer_> Yup
07:11:59 <adnap> JaffaCake: Then, ghc main.c foo_stub.h -o test
07:12:01 <kmc> jkramer_, looks like you're doing updates too, in which case the plain field label is not sufficient
07:12:09 <kmc> that's where fclabels would be handy
07:12:14 <dpratt71> Jafet: that sounds promising
07:12:22 <dpratt71> wasn't aware of that
07:12:52 <JaffaCake> adnap: ghc --make main.c foo.hs -o test
07:12:57 <kmc> how does unsafeIOtoST help here?
07:13:20 <kmc> the resulting ST action will do the same thing as the original IO action
07:13:33 <adnap> JaffaCake: Then I get: Warning: output was redirected with -o, but no output will be generated
07:13:33 <kmc> and if you pass it to runST, it will be as if that runST call were unsafePerformIO
07:13:35 <adnap> because there is no Main module.
07:13:44 <Jafet> Yeah, not much of a rewrite
07:13:45 <kmc> so i don't see what is gained
07:14:09 <adnap> JaffaCake: Why does there have to be a Main module if I'm using a main function in C?
07:14:19 <dpratt71> kmc: really? I was momentarily hopeful...*sad trombone*
07:14:29 <kmc> adnap, did you try ghc -no-hs-main ?
07:14:32 <JaffaCake> adnap: oh, try -no-hs-main
07:15:15 <kmc> dpratt71, GHC's implementation of IO and ST are nearly the same
07:15:28 <kmc> and the implementation of runST and unsafePerformIO are nearly the same
07:15:53 <adnap> JaffaCake: http://pastebin.com/fBigX3SN
07:16:27 <kmc> ST has fancier types which impose static checking, and in return you get to drop the word "unsafe" from the name of "runST", but that's a statement about types and about conventions we follow
07:16:29 <JaffaCake> adnap: remove foo_stub.h from the command
07:16:35 <edwardk> testing
07:16:37 <kmc> at runtime there is almost no difference
07:16:40 <kmc> hi edwardk
07:16:42 <Jafet> IO actions don't have nearly enough information to be translated -- it's probably impossible short of changing ghc or its standard library
07:16:42 <edwardk> hey. i can speak
07:17:05 <kmc> right, you can reimplement the IO monad
07:17:13 <kmc> and recompile your code to use it
07:17:23 <dpratt71> kmc: true
07:17:28 <Saizan> edwardk: my +e $a:edwardk worked then :)
07:17:33 <edwardk> Saizan: you rock
07:17:48 <kmc> for example there's the GADT IO
07:17:55 <edwardk> Saizan: paid for a cloak, so that should help me avoid these blanket bans in the future.
07:18:08 <McManiaC> kmc: I guess that just not possible :(
07:18:13 <ivanm> edwardk: \o/
07:18:23 <adnap> JaffaCake: Then it complains about the Foo symbol: http://pastebin.com/ePz6FfTf
07:18:26 <dpratt71> kmc: what's that? (GADT IO)
07:18:34 <kmc> data IO a where { IOReturn :: a â†’ IO a; IOBind :: IO a â†’ (a â†’ IO b) â†’ IO b; PutStr :: String â†’ IO (); GetChar :: IO Char; ... }
07:18:57 <edwardk> kmc: ah free monad io?
07:19:05 <kmc> yeah it would be
07:19:14 <edwardk> well, almost
07:19:21 <Phyx-> adnap: what platform are you on?
07:19:30 <dpratt71> kmc: are there docs on this somewhere?
07:19:41 <kmc> on the type IO i just defined?
07:19:45 <dpratt71> oh
07:19:46 <kmc> i'm not aware of any; maybe others are
07:19:46 <adnap> Phyx-: I don't know what you mean.  Linux?  GHC 6?
07:20:00 <kmc> dpratt71, the implementation of the IO monad used by GHC is nothing like that
07:20:03 <Phyx-> adnap: i meants os. 
07:20:04 <edwardk> dpratt71: yeah. data types a la carte
07:20:08 <JaffaCake> adnap: you haven't added your Haskell file
07:20:19 <kmc> McManiaC, i'm looking now at the expression Â«\m -> MState $ \s@(t,c) -> liftIO (forkIO $ runMState m s)Â»
07:20:20 <edwardk> dpratt71: paper by wouter talks about something along those lines as an example
07:20:22 <JaffaCake> adnap: ghc --make -no-hs-main main.c foo.hs -o test
07:20:24 <dpratt71> kmc: I was under the impression that was in a package or library somewhere
07:20:29 <adnap> JaffaCake: Why should I have to?  It already generated the C stubs.
07:20:36 <kmc> McManiaC, which has the type Â«(MonadIO m) => MState t IO () -> MState t m ThreadIdÂ»
07:20:42 <kmc> that's one of the examples from your file
07:20:42 <dpratt71> just an idea, though, yes?
07:20:54 <JaffaCake> adnap: if you already compiled it, then you need to add the .o file
07:21:04 <JaffaCake> and don't use --make
07:21:08 <kmc> McManiaC, and i understand why it has this type
07:21:45 <McManiaC> kmc: forkIO is "IO () -> IO ThreadId" so it isnt possible
07:21:54 <kmc> right
07:22:25 <kmc> you'd need Â«lowerIO :: (MonadIO m) â‡’ m a â†’ IO aÂ»
07:22:29 <McManiaC> yep
07:22:35 <kmc> i've convinced myself it's impossible ;)
07:22:55 <edwardk> kmc: there is such a library floating around, using IORefs, but it requires another typeclass
07:22:57 <McManiaC> I guess theres no such class? :>
07:23:16 <edwardk> McManiaC: there is, not sure if it made it to hackage or just the cafe
07:23:17 <kmc> library for what edwardk?
07:23:26 <edwardk> kmc: lowering various monad transformers to io
07:23:34 <kmc> ok
07:23:50 <Saizan> InterleavableIO
07:26:13 <adnap> JaffaCake: Okay, cool!  So when I add the "hs" file it compiles, but how do I link the object file manually?
07:26:25 <aristid> kmc: there's a HasFork class somewhere
07:26:51 <JaffaCake> adnap: ghc main.c foo.o -no-hs-main -o test
07:30:25 <adnap> JaffaCake: It's strange, because then it complains that it doesn't know where "foo" is: main.c:(.text+0x2f): undefined reference to `foo'
07:31:26 <kmc> foo you're exporting?
07:31:27 <JaffaCake> oh, you have to add foo_stub.o
07:31:49 <JaffaCake> ghc does that automatically when you give it the hs file, but not when you only give it the .o
07:32:02 <adnap> JaffaCake: Ah, okay.  I had tried foo_stub.h.
07:32:03 * hackagebot hello 1.0 - Hello World, an example package  http://hackage.haskell.org/package/hello-1.0 (SimonMarlow)
07:32:56 <burp> o0
07:33:32 <adnap> JaffaCake: Thanks for the help. :P
07:34:03 <JaffaCake> adnap: np, glad to help
07:34:36 <JaffaCake> http://hackage.haskell.org/package/hello
07:35:39 <technogeeky> how about that
07:35:56 <adnap> Is it common to use -no-hs-main for other purposes?
07:35:58 <technogeeky> http://www.haskell.org/hello/ -> 404
07:36:14 <JaffaCake> technogeeky: well, I haven't created that yet, give me a mo
07:36:14 <kmc> other than what adnap?
07:36:23 <technogeeky> JaffaCake: I figured, just passing along.
07:36:30 <JaffaCake> cheers ;)
07:38:08 <adnap> kmc: What I was doing.  Calling Haskell functions from a C program that already has main.
07:38:26 <technogeeky> If anyone is interested, some person I totally don't know at all whatsoever is uploading an (audio + lecture notes) version of the Feynman Lectures on Physics to usenet, in alt.binaries.audiobooks. Seeing as I don't know this person and don't condone copyright violations, I suggest you do not go off and download it as fast as you can.
07:39:00 <Phyx-> they're also on microsoft research
07:39:01 <soupdragon> I have no idea how to access alt.binaries.audiobooks
07:39:09 <technogeeky> phyx: that's 7 out of over 100
07:39:11 <hpc> the feynman lectures are copyrighted?
07:39:15 <technogeeky> hpc: yes
07:39:31 <soupdragon> technogeeky, without the video is it still quite possible to follow them?
07:39:39 <technogeeky> soupdragon: http://just4today.net/ as the server
07:39:40 <hpc> because iTunes had it for free last i checked
07:39:42 <Phyx-> technogeeky: they're video and they keep adding more
07:39:45 <technogeeky> soupdragon: yes, very much
07:39:53 <soupdragon> okay cool
07:39:57 <technogeeky> Phyx: oh. how many do they have now?
07:40:04 <kmc> adnap, i'm not aware of another use, except that you can substitute "C" for other languages
07:40:07 * Phyx- looks
07:40:10 <Jafet> Copyright violators have been known to falsify works. Who knows, those videos might be of some Feynman impersonator on a soundstage
07:40:22 <kmc> right now i'm writing Java JNI libraries in Haskell, but i'm not using -no-hs-main because i do linking myself
07:40:23 <technogeeky> Jefet: indeed.
07:40:42 <technogeeky> They might even use subconcious signals to corrupt your innocent minds.
07:41:17 <technogeeky> Sorry, silverlight for your browser is not ...
07:41:24 <Phyx-> gawd, the internet is slow
07:41:53 <Jafet> techno: ooh, that's a sublimal one
07:42:05 * hackagebot hamlet 0.3.1.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.3.1.1 (MichaelSnoyman)
07:42:24 <technogeeky> And, for those that are interested in such downloads, somehow I have extrapolated that the upload will take about ~ 5.1 hours withoit being involved.
07:43:14 <Phyx-> technogeeky: still only 7. odd, thought i read that they were aiming to add more
07:43:30 <technogeeky> Phyx: I should hope so.
07:43:40 <technogeeky> He is such an energetic lecturer.
07:43:46 <kmc> methinks perhaps all the oh so clever not talking about piracy should go to another channel
07:43:55 <technogeeky> kmc: i'm done
07:44:05 * hackagebot hello 1.0.0.1 - Hello World, an example package  http://hackage.haskell.org/package/hello-1.0.0.1 (SimonMarlow)
07:44:12 <Phyx-> kmc: well.. i wasn't talking about piracy
07:44:17 <Phyx-> but mkay
07:44:25 <kmc> whatever you don't have to listen to me ;P
07:44:46 <technogeeky> kmc: I recognize that. I just don't have anything else to say. My cleverness knows bounds.
07:45:22 * soupdragon wonders if you need a program to acess newsgroup
07:45:27 <technogeeky> you do
07:45:30 <technogeeky> there are lots of free ones
07:45:42 <mreh> try a web app
07:45:47 <kmc> soupdragon, no program needed.  you do it by pulling out the ethernet cable from your computer and whistling into it
07:45:47 <soupdragon> nothing on hackage :p
07:45:55 <technogeeky> http://en.wikipedia.org/wiki/Category:Free_Usenet_clients
07:46:03 <kmc> that's why only the most elite of haxors are found there
07:46:12 <technogeeky> true story
07:46:17 <Jafet> kmc: can you still do it with capn crunch?
07:46:31 <technogeeky> http://en.wikipedia.org/wiki/GrabIt
07:46:31 <kmc> http://www.youtube.com/watch?v=O2rGTXHvPCQ
07:48:24 <zygoloid> you could always write a usenet client. in haskell. i'm sure it's a one-liner.
07:48:38 <soupdragon> really??
07:48:43 <mreh> of course
07:48:49 <mreh> stuff it onto a single line
07:48:52 <zygoloid> well. plus imports.
07:49:09 <technogeeky> you should try doing it using ONLY imports
07:49:22 <zygoloid> the old "module Main where import UsenetClient (main)" ?
07:49:23 <technogeeky> wait, no.
07:49:30 <soupdragon> @hackage NNTP
07:50:01 <soupdragon> http://hackage.haskell.org/package/nntp
07:50:14 <McManiaC> http://n-sch.de/hdocs/mstate/ - what do you guys think of this lib? :)
07:50:18 <soupdragon> fetchArticle but what about fetching a binary 
07:50:44 * soupdragon starts to write a news client
07:50:57 <technogeeky> binaries are articles
07:50:58 <mornfall> It's in the message body.
07:51:05 * technogeeky head esplodes
07:51:09 <mornfall> Well, a bit of it.
07:51:14 <mornfall> :)
07:51:21 <zygoloid> does that lib do the unbase64ing for you?
07:51:22 <technogeeky> also see par2 repair
07:51:23 <soupdragon> im racing technogeekys upload speed
07:51:26 <technogeeky> and unbase64
07:51:30 <technogeeky> soupdragon: you rock do it 
07:51:37 <technogeeky> write NewsLeecher in haskell
07:53:02 <Jafet> kmc: uncanny
07:53:49 <Raevel> okay, what?
07:53:50 <Raevel> cabal: dependencies conflict: ghc-6.12.1 requires directory ==1.0.1.1 however
07:53:50 <technogeeky> Numb3rs is designed to create little crackpots
07:53:50 <Raevel> directory-1.0.1.1 was excluded because ghc-6.12.1 requires directory ==1.0.1.0
07:54:06 <dcoutts> Raevel: see the Cabal FAQ
07:54:11 <Raevel> okay :-)
07:57:01 <soupdragon> @hoogle liftIO
07:57:28 <McManiaC> http://npaste.de/aa/ :)
08:06:16 * hackagebot hello 1.0.0.2 - Hello World, an example package  http://hackage.haskell.org/package/hello-1.0.0.2 (SimonMarlow)
08:08:22 <soupdragon> "This is an implementation of the classic Hello World program in Haskell" wtf
08:08:41 <danderson> it's an example package
08:08:45 <danderson> ie. the code is unimportant
08:08:58 <danderson> the package definition file and structure of the package source is, however
08:09:13 <exDM69> yeah, more like an example on using Cabal rather than Haskell
08:09:25 <Jafet> Well, sometimes you have better things to do than spend all day reimplementing hello world programs
08:09:39 * technogeeky rofls at Jafet again
08:09:54 <kmc> i thought you needed 9 PhDs in advanced category theory to write Hello World in Haskell
08:10:40 <byorgey> kmc: don't be silly.  five or six should surely suffice.
08:11:07 <technogeeky> kmc: s/World/"Real World"/
08:11:22 <technogeeky> you can write it without a degree, but if you want to use it in the real world...
08:11:39 <dcoutts_> JaffaCake: I thought nhop was a hello-world demo package
08:11:58 <dcoutts_> though perhaps it bit rotted :-)
08:13:06 <technogeeky> anyone know john macfarlane's handle here?
08:18:06 <rbe> hi all
08:19:39 <byorgey> hi there rbe
08:20:18 <rbe> hi
08:23:25 <ClaudiusMaximus> hm, the exponential explosion when i unfoldTree is a bit much, would unfoldTreeM with Maybe be the way to go to prune it?  (i never used Data.Tree before today..)
08:23:32 <technogeeky> ezyang: here?
08:31:30 <dafis> Hmm, I'm using Data.Text.Lazy.Encode.encodeUtf8 to convert lazy Text to a lazy ByteString. The data is read from a plain ASCII file. Whenever I try to let it convert more than 36824 characters, I get a segfault.
08:31:57 <dafis> The 36824-th character is an 'm', the 36825-th a '!'
08:32:16 <technogeeky> dafis: you made the compiler crap it's pants!
08:32:27 <technogeeky> s/!// for safety
08:32:35 <technogeeky> hey conal
08:32:39 <dafis> When I insert any letter before and ask for exactly 36825 characters, I get an 'Invalid opcode'
08:32:59 <dafis> (so then the 36825-th character is the 'm')
08:33:45 <dafis> So I guess that means somebody's writing in the program-segment or whatever it's called
08:34:15 <technogeeky> LHC just went stable for the first time at 1 (ub.s)^-1.
08:34:21 <technogeeky> http://meltronx.com/lhc3.html
08:38:26 * hackagebot speculation 0.8.2.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.8.2.0 (EdwardKmett)
08:41:33 <dafis> technogeeky: brilliant idea, sort of. So I deleted the '!'. Asked for 36825 characters, plain old boring segfault. Asked for 36826 characters: 
08:41:35 <dafis> wotCt: out of memory (requested 2147483648 bytes)
08:41:42 <dafis> Bada-boom
08:42:29 <edwardk> technogeeky: my first thought when you said that was that lemmih had made progress and that that was a very strange version number ;)
08:42:31 <technogeeky> Hey, I'm an unintentional help.
08:43:37 <alexyk> JaffaCake: did you run my monster program with -A5G -H2G -K1G?
08:47:33 <soupdragon> @let numbers filter = [2..] >>- \a ->  [2..] >>- \b -> return (filter a b)
08:48:30 <hpc> :t (>>-)
08:48:39 <soupdragon> (>>-) :: (MonadLogic m) => m a -> (a -> m b) -> m b
08:48:52 <hpc> gotcha
08:49:54 <portnov> @hoogle (Monad m) => m a -> m b -> m a
08:51:19 <pikhq> portnov: (>>=)
08:51:50 <JaffaCake> alexyk: yes, those were the options I used
08:52:01 <JaffaCake> alexyk: the -H2G is probably redundant
08:52:52 <JaffaCake> and if you need -K1g, that could indicate a problem (some function is not tai-recursive)
08:54:06 <ezyang> technogeeky: yo. 
08:54:26 <hpc> pikhq: no, that type would be (<<)
08:55:19 <c_wraith> :t (<<)
08:55:31 <c_wraith> oh, right, no \bot
08:55:52 <pikhq> hpc: XD
08:55:57 <companion_cube> where is (<<) defined ?
08:55:58 <pikhq> Didn't even read it right.
08:56:07 <c_wraith> anyway...  there are two things "(Monad m) => m a -> m b -> m a" could do
08:56:07 <hpc> (<<) = flip (>>), but it isn't in Prelude
08:56:11 <companion_cube> ah ok
08:56:19 <c_wraith> and that's the bad definition
08:57:05 <c_wraith> well, I guess it might not be exactly bad, with that name, but it's not the useful definition 
08:57:15 <benmachine> it can be useful
08:57:27 <soupdragon> my search
08:57:28 <soupdragon> [2..] >>- \a ->  [2..] >>- \b -> do guard ((a^2+b^2)`mod`(a*b+1) == 0) ; return ((a^2+b^2)`div`(a*b+1))
08:57:28 <c_wraith> I guess it's just as useful as =<<'s definition
08:57:33 <benmachine> but I guess you're thinking of (<*)?
08:57:37 <soupdragon> I cant find any numbers bigger than 9 with it
08:57:41 <c_wraith> but I much prefer how *> and <* are defined
08:57:46 <benmachine> :t liftM2 (flip id)
08:57:50 <benmachine> oya
08:58:05 <hpc> it's tough not having lambdabot
08:58:07 <soupdragon> I suppose I should cut it down by half using the symmetry (a,b) |-> (b,a)
08:58:17 <benmachine> oh whoops I was wrong
08:58:18 <soupdragon> liftM2 (flip id) :: (Monad m) => m a1 -> m (a1 -> c) -> m c
08:58:21 <benmachine> I meant, const id
08:58:25 <benmachine> or just const maybe
08:58:33 <c_wraith> yeah, const
08:58:34 <benmachine> yes const
08:58:37 <companion_cube> liftM2 const
08:58:53 <benmachine> liftM2 (flip id) is basically monadic (<**>)
08:59:18 <c_wraith> a <* b = const <$> a <*> b
09:00:39 <c_wraith> a *> b = flip const <$> a <*> b
09:00:53 <c_wraith> ...  is there a better way to say "flip const"?
09:01:12 <hpc> const id?
09:01:13 <Twey> const id
09:01:13 <Twey> :-D
09:01:34 <Twey> It's two letters shorter!  Much better.
09:01:43 <c_wraith> :)
09:01:52 <hpc> isn't there a GHC bug that causes those two to not reduce to the same compiled code?
09:02:54 <Twey> Is there?
09:03:03 <hpc> i thought there was
09:03:03 <benmachine> I've never heard of such a thing, but maybe?
09:03:07 <benmachine> @let tsnoc = flip const
09:03:12 <alexyk> JaffaCake: probably not, but I kind of settled on those
09:03:13 <c_wraith> I'm not completely sure they are the same, in the presence of seq.
09:03:13 <benmachine> oh
09:03:14 <benmachine> yeah
09:03:17 <hpc> i remember a while back someone talking about using one over the other due to performance
09:03:17 * benmachine facepalm
09:03:51 <benmachine> c_wraith: flip const and const id? I don't think seq can tell them apart
09:04:01 <Twey> Haha
09:04:03 * hpc does a crude benchmark
09:05:12 <benmachine> flip const undefined = \x -> const x undefined = \x -> x, const id undefined = \x -> x
09:12:09 <soupdragon> what\s the product of the first 20 primes?
09:12:59 <danharaj> 557940830126698960967415390
09:13:12 <kmc> 8
09:14:04 <pizza_> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in product $ take 20 $ sieve [2..]
09:14:39 <mauke> preflex: seen Cale
09:14:39 <preflex>  Cale was last seen on #haskell 7 hours, 58 minutes and 21 seconds ago, saying: bcw: That it should do
09:15:17 <danharaj> preflex: seen preflex
09:15:17 <preflex>  what
09:16:02 <aristid> preflex: nothing
09:16:03 <soupdragon> preflex: what
09:23:16 <Phyx-> boooo
09:27:00 <hpc> pizza_: no bot
09:27:16 <pizza_> i thought maybe it was just reeeeeeally slow
09:28:26 <Phyx-> lambdabot commited senpuku again?
09:28:39 <kmc> she got klined by another bot
09:28:41 <kmc> and didn't come back
09:28:46 <technogeeky> it got tired of us spamming
09:28:49 <Phyx-> oh, it's a she?
09:29:15 <kmc> that's right ladies and gentlemen, battling robots right here in #haskell
09:29:23 <kmc> yeah, lambdabot is female
09:29:26 <kmc> her name is Emily
09:29:31 <kmc> you can ask her when she gets back
09:29:41 <monochrom> what am I going to do without lambdabot? she's my sun moon star.
09:29:46 <Phyx-> lol
09:29:58 <Phyx-> suddenly everyone gets all poetic
09:30:05 <kmc> we could write love poetry and put it on the wiki
09:30:23 --- mode: ChanServ set +o mauke
09:30:23 --- kick: idoru was kicked by mauke (idoru)
09:30:30 <Phyx-> that would be something to see
09:30:31 <Phyx-> lol
09:30:37 <pizza_> > let (â™¥) = (++) in "lambda" â™¥ "bot"
09:30:43 <McManiaC> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/76748 :)
09:31:03 <kmc> <Multi_key> <less> <3>  :  â™¥
09:31:38 <kmc> <Multi_key> <C> <C> <C> <P>  :  â˜­
09:31:49 <benmachine> haha
09:31:50 <benmachine> nice
09:31:55 <Phyx-> why did brazil lose :(
09:32:05 <mauke> <Multi_key> <equal> <parenright>  :  ãƒ„
09:32:07 <McManiaC> phail
09:32:08 <Jafet> Because it wanted to get to the other side.
09:32:08 <kmc> because you touch yourself at night
09:32:21 <kmc> mauke, i don't have that one :/
09:32:23 --- mode: mauke set -o mauke
09:32:25 <Phyx-> kmc: i thought that only killed kittens...
09:33:52 <monochrom> kmc: how did you find out all those combinations?
09:34:10 <McManiaC> kmc: "keysym Menu = Multi_key" into ~/.xmodmaprc
09:35:08 <mauke> probably by reading the source
09:35:24 <kmc> monochrom, less /usr/share/X11/locale/en_US.UTF-8/Compose
09:35:39 <kmc> you can put your own combos in ~/.XCompose
09:35:56 <kmc> and the line Â«include "%L"Â» will include the system default one
09:36:50 <kmc> McManiaC, i use the "Fn" key on my thinkpad.  because it generates only a key code on release, not on press, this is about all that X can use it for
09:37:27 <McManiaC> hmhm
09:37:28 <McManiaC> ^^
09:37:41 <soupdragon> if a is a multiple of b then what do a and b look like mod m?
09:37:42 <soupdragon> is there any patter
09:37:47 <kmc> Â¬(Ï† âˆ§ Ïˆ) â‡” Â¬Ï† âˆ¨ Â¬Ïˆ  â–¡
09:38:02 <soupdragon> isn't that assumeng LEM
09:38:12 <kmc> Î“ âŠ¢ Ï† : Ï„
09:38:15 <soupdragon> no I guess not
09:38:23 <bremner> truth tables ftw
09:38:29 <soupdragon> truth tables assume LEM
09:38:50 <monochrom> LEM assumes truth table
09:39:49 <soupdragon> how to prove  Â¬(Ï† âˆ§ Ïˆ) -> Â¬Ï† âˆ¨ Â¬Ïˆ  ?
09:40:33 <soupdragon> \ !ab -> inl (\!a -> ...?...)
09:40:52 <soupdragon> there doesn't seem to be any way
09:41:07 <soupdragon> so it is a classical tautology?
09:41:59 <Jafet> How did unicode fun turn to classical logic
09:41:59 <mauke> @djinn Not (a, b) -> Either (Not a) (Not b)
09:42:10 <Jafet> lambdabot cannot be realized.
09:42:34 <monochrom> multikey : ) â˜º
09:42:43 <pikhq> Argh. Why oh why isn't my compose key not working right?
09:43:05 <Jafet> Maybe it's deaf
09:44:25 <soupdragon> I have a question mostly we use + and * and their inverses, as well as basic constructions from them e.g. exponents
09:44:38 <soupdragon> why aren't there other arithmetics?
09:44:55 <soupdragon> or maybe that's what logic is
09:45:02 <soupdragon> (to name one)
09:45:05 <Jafet> Because this one seems relevant to real life
09:45:20 <Jafet> There are, of course, other formal systems
09:45:28 <monochrom> on ubuntu you can try System -> Preferences -> Keyboard -> Layouts -> Options... -> Compose Key Position
09:45:32 <kmc> what do you mean by "an arithmetic"
09:45:47 <Jafet> See model theory for the fun bits
09:46:35 <danharaj> Arithmetic is the algebra of counting.
09:47:11 <danharaj> There are other algebraic structures for other concepts. Such as groups corresponding to the symmetries of an object.
09:47:15 <kmc> yeah i'm stuck at ((Ï† :âˆ§ Ïˆ) â†’ Void) â†’ ((Ï† â†’ Void) :âˆ¨ (Ïˆ â†’ Void))
09:47:21 <kmc> seems to want continuations pretty badly
09:47:40 <monochrom> asking "what do you mean, what is your definition" to an inquiry mind is counterproductive.
09:47:42 <danharaj> kmc: I don't think that's intuitionistically valid.
09:47:51 <monochrom> inquiry minds want to troll
09:48:17 <soupdragon> how can we refute intuitionistically -- the easy way would be to prove it implies LEM but there should be a different approach too
09:48:28 <pikhq> It's almost like my X11 has decided that the Multi_key has no semantics.
09:48:31 <monochrom> the inquiry mind invariably answers along the line of "I don't know, I'm asking, I'm committing lateral thinking"
09:49:00 <kmc> monochrom, and asking for clarification of definitions is the counterpart in that dialogue
09:49:13 <kmc> i say vague things, people ask me to clarify, i think more about what i mean
09:49:27 <danharaj> Cosocratic method
09:49:33 <monochrom> but you are not a trolling inquiring mind
09:49:35 * Baughn has now gained the wonderful task of rewriting haskell-src-exts to support failure recovery. Oh boy, is this gonna be fun.
09:49:54 <Phyx-> Baughn: have at it :)
09:50:01 <danharaj> Baughn: If it wasn't fun you wouldn't be doing it. ;p
09:50:35 <Baughn> danharaj: Hm. I suppose it is, in a way, but I'm doing it more in order to /use/ it.
09:50:41 <kmc> failure âˆ—recoveryâˆ—?
09:50:44 <soupdragon> I don't thin you can CONTINUE without using LEM 
09:50:51 <Phyx-> god damnit my interwebs sucks
09:51:10 <Baughn> soupdragon: Um, the lunar excursion module?
09:51:23 <Baughn> kmc: Right, since I intend to wire it into haskell-mode.
09:51:25 <soupdragon> lunar exclusion
09:51:27 <Jafet> Phyx-: I hear usenet is lighter on internets
09:51:30 <kmc> Baughn, wow
09:51:31 <soupdragon> among other things
09:51:51 <Baughn> kmc: 3.0 has quite a laundry list of features. Basically, I mean to make it competitive with SLIME. :P
09:51:54 <kmc> Baughn, i'd have taken a much simpler more hackish approach -- like chopping up the file ad-hoc and feeding it through bit by bit
09:51:58 <kmc> that's good :)
09:52:09 <Baughn> kmc: I could do that, yes.
09:52:23 <Baughn> It's just that I'd rather be doing that /in haskell-src-exts/.
09:52:39 <Baughn> And also, it should be possible to recover from parse errors /inside functions/.
09:52:43 <Baughn> Some of the time.
09:52:46 <Baughn> I can certainly try.
09:52:53 <danharaj> When is Yi going to not suck.
09:52:54 <danharaj> ;)
09:53:10 * Baughn shrugs
09:53:22 <Baughn> ..I think maybe they made the wrong decision in trying to write an editor from scratch.
09:54:26 <soupdragon> is lambadbot back
09:54:31 <Jafet> That sounds more like a long decision
09:54:47 <technogeeky> > 2 + 2
09:54:52 <danharaj> 4
09:54:53 <Jafet> 5
09:54:58 <technogeeky> NINETEEN
09:54:59 <Baughn> Jafet: Yeah, one that involves rewriting emacs. -_-;
09:55:14 <Baughn> A good IDE is hard enough without getting bogged down in chatting with X.
09:55:16 <danharaj> Trying to be like emacs was probably an error.
09:55:23 <Baughn> Don't say that. ;_;
09:55:32 <technogeeky> as a loyal vimmer, I agree with you!
09:55:37 <technogeeky> It won't happen again, though!
09:55:39 <Jafet> emacs is only version 24. Plenty of time to catch up.
09:55:39 <technogeeky> lol
09:55:42 <danharaj> Baughn, I don't have a neckbeard made of cheeto stains and programmer cred.
09:55:45 <danharaj> :[
09:55:58 <Baughn> danharaj: Emacs isn't that hard to learn. Geez.
09:56:18 <danharaj> It is when I can use notepad++ right now to do what I want right now.
09:56:23 <danharaj> I only tried to learn emacs so I can use agda.
09:56:33 <danharaj> But agda hasn't shown me enough skin to warrant the effort.
09:57:04 <Baughn> Oy. You shouldn't judge programming languages by their OS-tans.
09:57:21 <monochrom> Proof General is an extension of emacs that brings you nice frontends to Coq etc.
09:57:22 <Baughn> http://brage.info/~svein/haskell.png <- Besides, remember this one?
09:57:23 <danharaj> ... rule 34 on haskell?
09:57:23 <soupdragon> by the way emacs is easy to learn
09:57:28 <Jafet> You want to see skin? You'd better have a heart-to-heart talk with the doctor
09:57:39 <soupdragon> you just type into the box and there's a few commands you need to know for saving a file and stuff
09:57:42 <soupdragon> you should all learn it it's trivial
09:57:58 <danharaj> what's the command for saving?
09:58:07 <Baughn> C-x C-s..
09:58:16 <monochrom> the "save" button on the toolbar
09:58:16 <Baughn> But I just rebound it to A-s.
09:58:22 <Baughn> ..wait, S-s?
09:58:22 <Phyx-> need some opinions about something http://i48.tinypic.com/2cr3xiu.png see like 18, when no type is given the IDE shows the infered type, and thinking of adding when you have a typerror, that IDE would retry typechecking \without the typesig and then if it succeeds it recomments you the type it infered. WOuld these be helpful or annoying?
09:58:31 <Baughn> ...toolbar? You didn't turn that off? :P
09:58:32 <soupdragon> ideally there would be a better program than emacs for custom progrmaming language interaction
09:58:43 <soupdragon> but afaict there isn't a platform like that and nobody can be bothered to do it
09:58:48 <monochrom> the toolbar is very useful
09:58:50 <Baughn> Phyx-: Yep, that's the plan for H-M 3
09:58:50 <soupdragon> (it's a lot more fun talking about it than actually implementing it)
09:59:01 <Phyx-> H-M 3?
09:59:08 <Baughn> Haskell-mode 3.0
09:59:11 <danharaj> Baughn: What if emacs used haskell as an extension language. How would that make you feel?
09:59:14 <Phyx-> right
09:59:38 <Baughn> danharaj: Sounds cute
09:59:59 <Baughn> danharaj: ..it's basically what I'm doing, just via network comint. ^^;
10:00:04 <Baughn> s/network//
10:00:09 <pikhq> danharaj: Sounds slightly less flexible.
10:00:12 <danharaj> The things a man will go through for love.
10:00:33 <Phyx-> Baughn: so you think it would be useful then. don't wanna spend the time implementing it if not, lol
10:00:36 <danharaj> pikhq: How so?
10:00:47 <Baughn> Phyx-: Well, of course it'd be useful
10:00:50 <pikhq> As you know, Emacs isn't merely using Lisp as an extension language. The whole thing is runtime-modifiable Lisp.
10:01:00 <monochrom> Phyx-: I think it's helpful to suggest a correct type, when there is one.
10:01:06 <Jafet> danharaj, depends if I get ?-let
10:01:06 <pikhq> The only not-Lisp in it is the Lisp interpreter.
10:01:10 <dafis> bos: ping
10:01:28 <kmc> (Â¬Ï† v Â¬Ïˆ) â†’ Â¬(Ï† âˆ§ Ïˆ) is constructively valid
10:01:34 <kmc> the other direction seems not to be
10:01:43 <Phyx-> monochrom, Baughn ok, guess i'm gonna dive into the code then now :)
10:02:00 <monochrom> I don't understand all the hatred against GUI elements like toolbars. But I guess...
10:02:05 <monochrom> @quote 1970s.terminals
10:02:12 <Baughn> Phyx-: I would advise against diving into haskell-mode right now.
10:02:14 <monochrom> Oh lambdabot is on leave.
10:02:19 <Baughn> Phyx-: It's all going to change soon anyway.
10:02:37 <Phyx-> Baughn: i'm not using haskell-mode
10:03:31 <Baughn> Phyx-: In that case, knock yourself out.
10:03:41 <danharaj> kmc: you have 01Â¬(Ï† âˆ§ Ïˆ) â†’ Â¬Â¬(Â¬Ï† v Â¬Ïˆ) according to wikipedia
10:03:54 <kmc> ok i'm down with that
10:04:26 <Phyx-> Baughn: isn't that for Emacs/vim anyway? the screenshot showed visual studio :P
10:04:31 <danharaj> I think if either 01Ï† or Ïˆ has a proof you can also use the classical law.
10:04:51 <Baughn> Phyx-: I think there was some package to embed emacs in VS somewhere..
10:04:53 <danharaj> The trouble, I think, is when you don't have a proof for either of them.
10:05:04 <ddarius> kmc: I always find it pleasant to express the type and proof as Haskell.
10:05:12 <McManiaC> what criterias do you have to satisfy to call a library "portable"?
10:05:14 <monochrom> There is a Kripke structure to show why Â¬(Ï† âˆ§ Ïˆ) doesn't imply Â¬Ï† âˆ¨ Â¬Ïˆ
10:05:23 <ddarius> @djinn Either (Not a) (Not b) -> Not (a, b)
10:05:26 <kmc> yeah ddarius
10:05:33 <kmc> probably more pleasant in Agda
10:05:41 <monochrom> lambdabot is on leave
10:06:08 <kmc> like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26805#a26805
10:06:21 <danharaj> I like the concision of mathematical notation, unless it starts getting bogged down with accents on every freaking free variable.
10:06:32 <McManiaC> bah, I hate unicode sourcecode
10:06:57 <ddarius> \eab (a, b) -> case eab of Left na -> void (na a); Right nb -> void (nb b)
10:07:19 <danharaj> It would be nice if a language like Agda or Haskell reserved identifiers starting with '\' so we can write \all, for example, and have it be valid math latex as well :p
10:07:46 <kmc> that's how you type in agda-mode
10:07:47 <ddarius> danharaj: I like that you can use overbars and hats and subscripts and overdots in mathematics.
10:08:03 <danharaj> ddarius: My favorite has to be hats
10:08:13 <aristid> danharaj: there are no identifiers starting with \ in haskell AFAIK, given that \ is a token in itself
10:08:16 <danharaj> I dislike primes.
10:08:55 <dafis> aristid: Data.List.\\
10:09:00 <danharaj> kmc: I spent all of 5 minutes in agda-mode, my unicode fonts are apparently fucked up and the links on how to fix them on the agda wiki were down when I was trying to absorb it.
10:09:28 <Jafet> danharaj, haskell-latex polyglots?
10:09:31 <aristid> dafis: why does that work?
10:09:38 <Jafet> danharaj, best idea ever
10:09:40 <danharaj> Jafet: huh what wah?
10:09:44 <danharaj> oh yeah.
10:09:48 <aristid> dafis: i figure i don't quite understand haskell tokenization
10:10:06 <dafis> aristid: because \ is a perfectly valid symbol that may appear in operators
10:10:25 <danharaj> Latex takes hardly any effort to learn, you just ask someone more experienced than you for their style sheet and use all their shortcuts.
10:10:36 <danharaj> I imagine lineages of style sheets descended from the first ams latex users.
10:10:38 <dafis> aristid: just a \ all by itself is a reserved symbol, like :: or ..
10:10:46 <aristid> dafis: i was thinking that after the \, the scanner says "next token"
10:10:56 <hpc> (\) is to (\\) as (=) is to (==)
10:11:29 <dafis> aristid: no, that's why one needs a space after the \ for lazy (~) or strict (!) patterns
10:12:00 <dafis> aristid: never tripped over map (\~(x:xs) -> ...)?
10:12:04 <aristid> dafis: is there a short summary of these rules somewhere?
10:12:17 <aristid> dafis: no, but i really haven't done so much with haskell yet
10:12:18 <dafis> aristid: maximal munch
10:12:30 <aristid> no i mean, why is \a not a symbol
10:12:34 <aristid> but \\ is
10:13:10 <dafis> aristid: a is a letter, \ is a symbol, so no token can contain both
10:13:18 <kmc> now i'm stuck trying to prove Â¬(Ï† âˆ§ Ïˆ) â†’ Â¬Â¬(Â¬Ï† v Â¬Ïˆ)
10:13:24 <danharaj> By the way, whoever posted that screenshot of haskell in visual studio, I will love you long time if you get that to a usable stable state.
10:15:04 <kmc> f : (Ï† âˆ§ Ïˆ) â†’ Void  ;  g : ((Ï† â†’ Void) âˆ¨ (Ïˆ â†’ Void)) â†’ Void   âŠ¢  Void
10:15:27 <Phyx-> danharaj: working on it :)
10:15:28 <kmc> i can't use either assumption as i have no (Ï† âˆ§ Ïˆ) nor (Ï† â†’ Void) nor (Ïˆ â†’ Void)
10:15:43 <aristid> dafis: is that all there is to tokenization?
10:15:45 <McManiaC> is there a nice webfrontend for darcs?
10:16:32 <Hunner> http://blitiri.com.ar/p/darcsweb/ ?
10:17:24 <dafis> aristid: basically, yes.
10:20:07 <McManiaC> Hunner: thx, looks cool
10:20:12 <soupdragon> 121^2=11*1331
10:21:23 <monochrom> Kripke structure satisfying Â¬(Ï† âˆ§ Ïˆ) but not Â¬Ï† âˆ¨ Â¬Ïˆ: root state has nothing, state 1 extends root has Ï†, state 2 extends root has Ïˆ.
10:21:34 <soupdragon> monochrom oh nice!
10:22:18 <soupdragon> that is very simple infact
10:22:25 <Hunner> but 12321^2 /= 1111*135531, but they are close
10:23:01 <FunctorSalad> I just came in, what's the background?
10:23:04 <ddarius> 121=11^2, 1331=11^3, (11^2)^2 = 11^4
10:23:09 <FunctorSalad> (for this numerology ;))
10:23:19 <soupdragon> Hunter :p only a million off 
10:23:41 <aristid> dafis: hmm i suppose ( ) are special symbols
10:23:44 <ddarius> Also, the digits of 11^n is the nth row of Pascal's triangle.
10:24:04 <FunctorSalad> (10+1)^n ;)
10:24:12 <technogeeky> ddarius: cool
10:24:16 <technogeeky> :o
10:24:40 <ddarius> Multiplication = convolution of the digits
10:24:43 <soupdragon> ddarius in base 10?
10:24:48 <ddarius> soupdragon: Yes.
10:24:50 <hpc> in any base
10:25:02 <soupdragon> but 11^5 = 161051
10:25:06 <dafis> aristid: they're not symbols, they're special characters http://haskell.org/onlinereport/lexemes.html#sect2
10:25:07 <technogeeky> hp: you sure about that?
10:25:16 <FunctorSalad> sum_i (n i) 10^i
10:25:18 <technogeeky> hpc: ...
10:25:18 <hpc> i think...
10:25:30 <FunctorSalad> not quite unless all coeffs are single-digit
10:25:36 <soupdragon> I think we need to look at it in a bigger base for each row
10:25:38 <dafis> special 	 -> 	 ( | ) | , | ; | [ | ] | `| { | } 
10:25:59 <FunctorSalad> ddarius: it'd work with the formal polynomial (x+1) ;)
10:26:12 <soupdragon> FunctorSalad, hey isn't that a theorem from somewhere :p
10:26:26 <FunctorSalad> my sum? binomial theorem
10:26:31 <pikhq> ddarius: o.O
10:26:38 <ddarius> soupdragon: Ah, yes, it stops being true when the "digits" exceed 10.
10:26:50 <dafis> aristid: parentheses, brackets, braces, comma, semicolon, backtick can't appear in either an identifier or an operator
10:27:06 <FunctorSalad> the let's-take-polynomials-and-extract-the-results-from-coefficients, I seem to remember that from counting symmetries, if that's your question
10:27:11 <soupdragon> here's a fun puzzle: prove that there's an odd number of odd entries of each row of pascals triangle
10:27:38 <ddarius> 1 1 is an even number of odd entries.
10:27:46 <technogeeky> yeah
10:27:48 <soupdragon> well prove something
10:27:52 <soupdragon> not that exactly
10:28:25 <soupdragon> an even number of odd entries
10:28:31 <aristid> dafis: yeah i have read that
10:29:07 <hpc> you can't prove either
10:29:16 <hpc> the top row is one 1
10:29:20 <hpc> the next row is two 1s
10:29:22 <kmc> here's a fun puzzle, prove âŠ¥
10:29:50 <aristid> ezyang: you're on the homepage of hackernews oO
10:29:56 <Jafet> kmc, done: âŠ¥
10:29:58 <technogeeky> âŠ¥
10:30:08 <technogeeky> i need a better IRC client :/
10:30:11 <soupdragon> damn I can't remember it 
10:30:16 <soupdragon> mabye ignoring the first row
10:30:20 <ddarius> There's always either 1, 2, or 4 odd numbers, with one only occurring in the 1 row case.
10:30:53 <soupdragon> oh yeah
10:30:55 <technogeeky> ddarius: per line?
10:31:07 <technogeeky> no
10:31:12 <technogeeky> soupdragon: so what?
10:31:13 <soupdragon> on odd rows there are an odd number of odd entries or something
10:31:38 <wli> There aren't odd numbers of odd entries except for [1]
10:31:39 <soupdragon> ah
10:31:44 <hpc> soupdragon: what an odd hypothesis :P
10:31:45 <soupdragon> Here is the ACTUAL problem:
10:31:56 <soupdragon>   The number of odd integers in any row is a power of 2
10:32:07 <technogeeky> well
10:32:09 <technogeeky> it's always even
10:32:12 <technogeeky> and you always provide two 1s
10:32:12 <soupdragon> I remembered it wron :(
10:32:25 <technogeeky> keeping it even, and a factor of 2
10:34:01 <soupdragon> *nod*
10:34:11 <technogeeky> yes?
10:34:37 <soupdragon> what you said makes sense and is true
10:34:42 <technogeeky> hooray
10:35:29 <technogeeky> i assume there's a crossover of xmonad people. Anyone have experience running 2 NVIDIA video cards (4 monitors) propery with Xm?
10:38:16 <kmc> technogeeky, there is #xmonad also
10:38:45 <technogeeky> yes
10:43:01 <lispy> good morning, ya'll!
10:43:06 <lispy>  How's code?
10:43:59 <c_wraith> getting written, as always.
10:44:12 <soupdragon> well my code was wrong
10:44:16 <soupdragon> but I rewrote it
10:44:20 <lispy> yay!
10:44:29 <lispy> Correctness, FTW
10:44:31 <technogeeky> soupdragon: did you finish your NNTP client?
10:44:39 <soupdragon> technogeeky no I gave up :[
10:44:40 <technogeeky> because if not, you lost.
10:44:42 <technogeeky> HUZZAH!
10:44:45 <soupdragon> the stupid lib didnt work haha
10:44:49 * lispy gasps
10:44:51 * technogeeky won something!
10:45:10 <lispy> Which one is NNTP again?  is that the network time protocol?
10:45:22 <c_wraith> no, nntp is newsgroups
10:45:23 <tensorpudding> isn't that newsgroups?
10:45:24 <c_wraith> ntp is time
10:45:28 <lispy> ah
10:45:34 <tensorpudding> do people still use nntp?
10:45:37 <soupdragon> I need a news thing idk what I am doing grrr why isn't there a comand line thing
10:45:38 <lispy> I still suffer from PCMCIA
10:45:44 <technogeeky> tensorpudding: Uh yes.
10:45:48 <FunctorSalad> 'sed' working on its stdin would be a good candidate for unsafePerformIO, no? at least if the user promises not to do s/.*/unsafeLaunchMissiles/e
10:45:53 <c_wraith> oh dear.  pcmcia is a horrible affliction
10:45:53 <FunctorSalad> (e=execute result)
10:46:21 <lispy> pcmcia = people can't memorize computer industry acronyms :)
10:46:41 <lispy> FunctorSalad: say what?
10:46:41 <technogeeky> lispy: that's rather Godelian
10:46:50 <technogeeky> someone hit me up with some umlats
10:46:58 <FunctorSalad> lispy: what?
10:47:02 <c_wraith> Ã¶ those?
10:47:02 <lispy> FunctorSalad: interact?
10:47:19 <FunctorSalad> lispy: ?
10:47:20 <lispy> Goedelian then is how you would spell it in english
10:47:20 <c_wraith> actually, is my input method mangling umlauts?  I think macs do that by default
10:47:28 <FunctorSalad> 'interact' rather than invoking 'sed'? confused
10:47:29 <lispy> Ã¶ = oe
10:47:29 <FunctorSalad> *
10:47:43 <lispy> FunctorSalad: unsafePerformIO why?
10:47:55 <FunctorSalad> because you have to launch a process? ;)
10:47:57 <lispy> :t interact
10:48:04 <FunctorSalad> @ty rawSystem
10:48:09 <c_wraith> still no \bot
10:48:17 <ski> ddarius : `\eab (a, b) -> case eab of Left na -> na a; Right nb -> nb b' -- no `void' required
10:48:27 <technogeeky> I don't know. But he provided an easy-to-remember acronym which porputed to demonstrate the impossibility of such a task.
10:48:27 <davekong> For someone who has taken a first course in discrete mathematics would "The Haskell Road to Logic, Maths and Programming" be appropriate?
10:48:29 <ski> (since it is provable in minimal logic)
10:48:33 <ddarius> ski: I like making it explicit.
10:48:46 <technogeeky> davekong: Yes.
10:48:48 <lispy> FunctorSalad: I declare that I need more details.  I'm confused about what you are doing
10:48:52 * ski thinks there's nothing to make explicit
10:49:01 <technogeeky> davekong: at least in my case
10:49:03 <FunctorSalad> + ghc -e ':t System.Process.rawSystem'
10:49:03 <FunctorSalad> System.Process.rawSystem
10:49:03 <FunctorSalad>   :: String -> [String] -> IO GHC.IO.Exception.ExitCode
10:49:04 <lispy> FunctorSalad: If you want to process some stdin purely, use interact
10:49:08 <ddarius> Also, I like an abstract type for Not a versuse a -> forall b.b
10:49:22 <FunctorSalad> lispy: no, I want to invoke sed
10:49:41 <ski> the result type already is `Void', no need to convert to it
10:49:57 <lispy> FunctorSalad:  Okay.  But you must want to avoid IO or else you wouldn't mention unsafePerformIO?
10:50:13 <ski> in djinn, `Not a' is `a -> Void', not `a -> forall b. b'
10:50:39 <ddarius> tensorpudding: Do people still use IRC?
10:50:43 <FunctorSalad> lispy: I had the random idea of making a sed quasiquoter into a package ;) *I* don't have to avoid IO in what I intend to do, but in a library it'd be more convenient
10:50:47 <lispy> ddarius: NO
10:51:07 <FunctorSalad> lispy: and 'sed' without the e flag to the s command seems pure
10:51:09 <ddarius> Yeah, I guess my use of void was gratuitous.  It'll just be id.
10:51:15 <FunctorSalad> as long as it works on stdin, of course
10:51:17 <lispy> FunctorSalad: ah.  In that case, I'll step muddying the waters.  I've never used the quasiquoter
10:51:20 <FunctorSalad> rather than reading a file
10:51:29 <FunctorSalad> lispy: doesn't matter to the IO issue :)
10:51:39 <FunctorSalad> the only advantage would be less escaping here ;)
10:51:41 <lispy> FunctorSalad: But you could have exceptions?  Missing file, missing sed, bad syntax, etc?
10:51:55 <FunctorSalad> hmm but those are pure exceptions
10:51:58 <ski> kmc : proving `Not (a,b) -> Not (Not (Either (Not a) (Not b)))' ?
10:52:08 <FunctorSalad> I mean, they should be caught in the unsafe IO block and purified
10:52:11 <lispy> FunctorSalad: asynchronous exception like that are teh suck
10:52:57 <FunctorSalad> hmm async? can't think of any way sed can fail after it has started munching input
10:53:11 <FunctorSalad> except trying to /e an invalid command ;)
10:53:19 <FunctorSalad> (execute)
10:53:30 <FunctorSalad> hmm, and there are write/read file commands, admittedly
10:53:33 <lispy> FunctorSalad: basically, it can't fail once it starts except that it can :)
10:54:03 <kmc> ski, i was
10:54:13 <kmc> got stuck, gave up
10:54:15 <ski> you got it, then ?
10:54:17 <ski> oh
10:54:18 <kmc> f : (Ï† âˆ§ Ïˆ) â†’ Void  ;  g : ((Ï† â†’ Void) âˆ¨ (Ïˆ â†’ Void)) â†’ Void   âŠ¢  Void
10:54:23 <kmc> don't know what to do from here
10:54:52 <ski> i would start with applying `g'
10:55:14 * ddarius needs to get a tapestry needle.
10:55:36 <kmc> f : (Ï† âˆ§ Ïˆ) â†’ Void  âŠ¢  (Ï† â†’ Void) âˆ¨ (Ïˆ â†’ Void)
10:56:09 <benmachine> if I say "what for" will you say "needling tapestry" or something
10:56:19 <ddarius> benmachine: For weaving in ends.
10:56:33 <ddarius> I don't actually know what tapestry needles are supposed to be used for.
10:56:45 <benmachine> oh ok
10:56:52 <benmachine> sounds like fun
10:57:48 <kmc> so i'm stuck, i don't have either of those types and i can't case on f because it's a function
10:58:40 <ski> kmc : if `f :: (a,b) -> Void', and `g :: (Either (a -> Void) (b -> Void) -> Void) -> Void', and we want to prove `Void'
10:58:59 <ski> we could try applying either `f' or `g' to get a return value of type `Void'
10:59:00 <FunctorSalad> what language is that?
10:59:08 <ski> Haskell
10:59:15 <ddarius> kmc: void :: Void -> a
10:59:47 <ski> if we try to apply `f' to get `Void', we must now construct an argument of type `(a,b)' .. which seems hopeless
10:59:52 <FunctorSalad> in coq I'd do 'apply g'
11:00:00 <FunctorSalad> making the goal the antecedent of g
11:00:13 <ski> trying `g' instead, we have to construct an argument of type `Either (a -> Void) (b -> Void) -> Void'
11:00:15 <FunctorSalad> hmm then you do seem stuck a bit
11:00:23 <FunctorSalad> so maybe apply f....
11:00:52 <FunctorSalad> ('apply', the tactic)
11:00:52 <kmc> i can't apply f, it doesn't match
11:01:10 <ski> kmc : doesn't match what ?
11:01:11 <kmc> but perhaps i started with the wrong thing?
11:01:19 <ddarius> \f g -> g (\eab -> case eab of Left na -> ...; Right nb -> ...)
11:01:24 <FunctorSalad> (takes a hyp "A -> B" and the goal "B" and replace the goal with "A")
11:01:25 <kmc> the thing on the right of the turnstile
11:01:28 <kmc> yes
11:01:38 <ski> hm, so making a lambda expression, we get an argument of type `Either (a -> Void) (b -> Void)', and want to return `Void'
11:01:47 <FunctorSalad> (backwards-reasoning modes ponens or something)
11:02:22 <ski> we still can't apply `f' since we have no `a' and `b', so trying a case on the input, we get either `a -> Void' or `b -> Void'
11:03:01 <zygoloid> proof f g = g (Left (\a -> g (Right (\b -> f (a, b)))))
11:03:20 <benmachine> *gasp* spoilers
11:03:25 <FunctorSalad> apply'ing f seems like it should be safe (can't make the problem unsolvable)
11:03:33 <ski> .. oh, now i see, i've made a mistake
11:03:33 <zygoloid> oh, was that homework or sth? sorry!
11:03:36 <FunctorSalad> since phi /\ psi is no worse a goal than Void
11:03:43 <kmc> where i started was:  âŠ¢ Â¬(Ï† âˆ§ Ïˆ) â†’ Â¬Â¬(Â¬Ï† âˆ¨ Â¬Ïˆ)
11:04:02 <ski> i don't want to *use* `g :: (Either (a -> Void) (b -> Void) -> Void) -> Void', i want to *prove* that
11:04:17 <ski> i.e. i want to use `Either (a -> Void) (b -> Void) -> Void', proving `Void'
11:04:37 <kmc> intro:  f : (Ï† âˆ§ Ïˆ) â†’ Void  âŠ¢  Â¬Â¬(Â¬Ï† âˆ¨ Â¬Ïˆ)
11:04:56 <ski> kmc : so, sorry : we want to use `f :: (a,b) -> Void', and `g :: Either (a -> Void) (b -> Void) -> Void' and prove `Void'
11:05:09 <kmc> eh fuck it
11:05:11 * kmc books up Coq
11:05:16 <kmc> boots*
11:05:18 <ski> this seems simpler
11:05:28 <zygoloid> we need to get both an a and a b out of g, in order to apply f and prove the result.
11:05:30 <FunctorSalad> "proof by video game" =)
11:06:00 <ski> we apply `g', and have to construct `Either (a -> Void) (b -> Void)' .. arbitrarily deciding to prove the left part, i.e. `a -> Void', we get an input `a', and must prove `Void'
11:06:01 <zygoloid> the 'a' and the 'b' can't leave the function which is in the argument to g
11:06:12 <FunctorSalad> tactics are cool, just don't expect them to be *read*able
11:06:37 <ski> now, we have an `a', but not a `b', so we can't use `f' to prove `Void'
11:06:38 <FunctorSalad> hmm and Saizan mentioned that they can give tunnel vision, that's true admittedly
11:06:43 <ski> so we try `g' *again*
11:07:02 <ski> it proves `Void', given that we prove `Either (a -> Void) (b -> Void)' (*again*)
11:07:12 <dolio> The proof for this using tactics is probably "auto" or something.
11:07:13 <FunctorSalad> (focussing on micromanipulations without trying to understand the bigger picture...)
11:07:31 <ski> this time, we can try proving the right part, `b -> Void', meaning we get an input `b' and must prove `Void'
11:08:01 <soupdragon> ski do you like number theory
11:08:07 <ski> so, now we have both an `a' and a `b' .. we could try using `g' again to prove `Void', but that's not needed as we can finally use `f' on `(a,b)'
11:08:10 <soupdragon> I mean square numbers and suchlike
11:08:11 <ski> QEF
11:08:27 <hpc> QEF?
11:08:35 <soupdragon> quotum ed falsum
11:08:36 <ski> (Quod Erat Faciendum)
11:08:48 <ski> (Which was to be Constructed)
11:08:54 <FunctorSalad> ed? the standard editor?
11:08:57 <soupdragon> mine is for "that was wrong"
11:09:00 <FunctorSalad> :p
11:09:05 <kmc> hmm in coq i get stuck the same place
11:09:19 <hpc> so QEF is roughly the same as QED then
11:09:30 <kmc> â†¯
11:09:36 <danharaj> Well, QED doesn't necessarily mean the proof is constructive.
11:09:37 <ski> soupdragon : when i was a kid, i played around some with perfect numbers, amicable numbers, congruences, and such ..
11:09:57 <soupdragon> ski, when (a^2+b^2)/(ab+1) is a whole number it is a square
11:10:47 <FunctorSalad> catapultem habeo (don't remember the rest)
11:11:05 <FunctorSalad> (engl "if you don't give me all your money, I'll send a giant boulder towards your head")
11:11:17 <kmc> anyway, i'm not sure i believe that Â¬(Ï† âˆ§ Ïˆ) â†’ Â¬Â¬(Â¬Ï† âˆ¨ Â¬Ïˆ)
11:11:21 <kmc> constructively
11:11:33 <ski> why not ?
11:11:51 <FunctorSalad> was that the original goal?
11:11:56 <dolio> You don't believe it? The non-double-negated version is a (famous) classical theorem.
11:11:57 <aristid> ski: kid as in 8 years old?
11:12:03 <kmc> because i'm stuck proving it, and it seems like a very small set of things one could try
11:12:06 <ski> aristid : something like that, yes
11:12:09 <kmc> dolio, sure, it holds classically
11:12:33 <FunctorSalad> it doesn't look quite double-negated
11:12:41 <kmc> i proved it clasically here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26805#a26805
11:12:41 <FunctorSalad> it's the counterpositive of the classical demorgan
11:12:49 <ski> kmc : which part of `\f g -> g (Left (\a -> g (Right (\b -> f (a,b)))))' don't you believe ?
11:12:50 <FunctorSalad> (one of the directions)
11:12:59 <aristid> ski: then you win in that regard :D
11:13:05 <kmc> ski, i missed that
11:13:18 <ski> aristid : i wasn't aware there was a competition ?
11:13:31 <kmc> ok that's a lot like what i had for the classical version, but with the callcc removed
11:13:33 <dolio> FunctorSalad: Double negating the whole thing lets you go from Not Not (P -> Q) to Not Not P -> Not Not Q. And since P is a negative statement, you can eliminated two Nots.
11:13:55 <dolio> Eliminate, even.
11:13:56 <aristid> ski: it's easy to invent competitions on the spot.
11:14:05 <ski> (.. i suppose)
11:14:13 <ski> soupdragon : pondering that ..
11:14:26 <monochrom> intuitionistic propositional logic isn't that hard. as soon as lambdabot is gone, everyone seems to be completely unable to prove simple things
11:14:38 <monochrom> this calculator generation...
11:14:47 <lispy> > 1 + 1
11:14:59 <lispy> Oh wait, 2
11:15:08 <aristid> lispy: how did you figure that out?
11:15:12 <aristid> did you type it in ghci?
11:15:12 <monochrom> haha
11:15:27 <soupdragon> ski for xample
11:15:28 <lispy> aristid: I forgot my phone had a calculator
11:15:29 <soupdragon> example
11:15:36 <hpc> aristid: that's too slow; compiling yields improved performance
11:15:43 <aristid> lispy: :D
11:15:44 <soupdragon> (10^2+1000^2)/(10*1000+1) = 100
11:15:51 <ski>   \kkf a kb -> kkf (\f -> kb (f a)) :: Not (Not (a -> b)) -> (a -> Not (Not b))
11:16:10 <aristid> > 2^2^2^2^2^2
11:16:11 <ski>   ? :: (a -> Not (Not b)) -> Not (Not (a -> b))
11:16:16 <FunctorSalad> dolio: hmm, ok
11:16:29 <ski> kmc : want to try proving that ?
11:16:56 <kmc> which?
11:17:00 <ski> the `?' one
11:17:06 <dolio> Yeah, you don't even need Not Not Not P -> Not P, really, because it's in the negative position.
11:17:06 <kmc> btw i believe your proof of the constructive demorgan now ;)
11:17:12 <ski> (i already proved the other direction)
11:17:47 <kmc> before, i was overlooking the option to do more intros
11:18:01 <kmc> thanks for showing me
11:19:00 <FunctorSalad> repeat intro
11:19:00 <FunctorSalad> ;)
11:19:22 <FunctorSalad> (slightly more aggressive than 'intros' iirc... unfolds some things)
11:19:30 <kmc> yeah
11:20:13 <ski> > let (a,b) = (2,2) in (a^2 + b^2) / (a*b + 1)
11:20:17 <ski> 1.6
11:21:02 <soupdragon> let (a,b) = (1560,5822) in (a^2 + b^2) / (a*b + 1)
11:21:33 * ski 's in-head arithemtic is weak
11:21:35 <dafis> bos: I mailed you about a mean bug in Text
11:21:59 <soupdragon> let (a,b) = (18,5832) in (a^2 + b^2) / (a*b + 1)
11:23:05 <ski> (soupdragon : btw, i assume `a' and `b' are to be naturals, or at least integers)
11:23:13 <soupdragon> yes
11:26:03 <EvanCarroll> man, I've gotten some *really* good attempts at explaining Functors on stackoverflow.
11:26:29 <soupdragon> functor as in haskell or as in category theory
11:26:33 <EvanCarroll> It actually makes me want to un-accept my other answers so I can get some more top notch explainations.
11:26:36 <EvanCarroll> as in haskell
11:31:59 <ski> EvanCarroll : i assume you've seen <http://catonmat.net/blog/on-functors> by pkrumins ?
11:33:22 <EvanCarroll> yea
11:33:27 <EvanCarroll> i'm stupid i need something 100 times that.
11:33:37 <EvanCarroll> http://stackoverflow.com/questions/3155469/help-haskell-functors-sink-in 
11:37:31 <kmc> that is a whole lot of words
11:38:27 <ams72> question...in SML we have a function called mapPartial
11:38:35 <ams72> its haskell type would be, I think:
11:38:45 <ams72> (a -> Maybe b) -> [a] -> [b]
11:38:55 <ams72> the result list includes the values of the Justs, and no Nothings
11:38:56 <kmc> :t \f -> catMaybes . map f
11:39:08 <dafis> mapMaybe, iirc
11:39:19 <kmc> ah, there it is.  in Data.Maybe
11:39:21 <soupdragon> mapM
11:39:23 <tlax> lolcatMaybes
11:39:28 <EvanCarroll> I think the biggest source of my confusion was reading that a Functor was a typeclass for iterating from one type to another type, and thinking it was the only way to do it.
11:39:31 <kmc> it's not mapM
11:39:33 <soupdragon> (a -> m b) -> [a] -> m [a]
11:39:39 <soupdragon> [b]
11:39:54 <soupdragon> catMaybes . map f
11:40:19 <ams72> soup: thanks, that makes sense...I was just wondering if it already exists and has a name
11:40:44 <EvanCarroll> A Functor is aparently just an arbitrary typeclass in the prelude that assumes you want to map from (a)'s to (b)'s, but it is fairly normal to want to achive a task with the same definition and you won't be able to do it Functor
11:40:47 <Saizan> EvanCarroll: you should learn the type system first
11:40:51 <kmc> it does, its name is mapMaybe and it lives in Data.Maybe
11:40:52 <ams72> found it...Maybe.mapMaybe
11:41:00 <ams72> thanks all for the superquick responses
11:41:07 <EvanCarroll> I think the newest answer is the best one
11:41:12 <kmc> EvanCarroll, "a functor is a typeclass"?  no,  "Functor" is one specific type class
11:41:31 <kmc> what we mean when we say "a functor" is "a type constructor which is an instance of Functor"
11:41:35 <FunctorSalad> EvanCarroll: Functor isn't magic indeed
11:41:41 <EvanCarroll> right, but that distinction isn't clear in any reading materials i've read.
11:41:43 <FunctorSalad> (in the sense of special treatment by the lang)
11:41:56 <kmc> err, the distinction between classes and instances?
11:42:13 <EvanCarroll> kmc: is the stuff in Control.Bifunctor also a "functor" by that definition?
11:42:18 <FunctorSalad> the recently added (deriving Functor) nonwithstanding ;)
11:42:23 <kmc> EvanCarroll, no
11:42:36 <FunctorSalad> they're functors in the mathematical sense
11:42:38 <kmc> EvanCarroll, but you might say it's a functor in the mathematical sense
11:42:45 <FunctorSalad> but unrelated to the typeclass Prelude.Functor :)
11:43:00 <EvanCarroll> right, well... that's not to clear in LYAH, or RWH.
11:43:00 <kmc> without qualification "a functor" in Haskell is an instance of Prelude.Functor
11:43:04 <EvanCarroll> at least it wasn't for me.
11:43:05 <FunctorSalad> (in the mathematical sense they're functors defined on the product category)
11:43:09 <monochrom> This disproves the claim that programmers don't like to write. Oh boy they surely can go on and on about one single scheme of type (a->b)->(t a -> t b)
11:43:31 <kmc> EvanCarroll, well i'm not sure where you got the idea that functors are type classes
11:43:47 <EvanCarroll> I wanted a mathmatical functor over the Left of Either, and I was deterimined to write it with the tools I knew of, even though instantiating it under Functor made the job impossible
11:44:04 <ski> (.. which product category ?)
11:44:21 <FunctorSalad> ski: I noticed my questionable abbreviation ;)
11:44:22 <kmc> oh
11:44:37 <EvanCarroll> kmc: how are they not?
11:44:44 <FunctorSalad> ski: but... "the product category" makes sense when we're in a Reader monad containing a bifunctor ;)
11:44:47 <ski> EvanCarroll : the problem is that you wanted `\a -> Either a b' to be a functor, but that type can't be expressed (directly) in Haskell's type system
11:44:50 <kmc> EvanCarroll, i'd say that's a more specific question than "explain how functors work in Haskell"
11:44:56 <FunctorSalad> (Reader on the metalevel of course)
11:45:06 <kmc> EvanCarroll, functors are not type classes.  functors are instances of one particular typeclass, which is named "Functor"
11:45:09 <FunctorSalad> (the product of the two domains of the Bifunctor)
11:45:21 <ski> EvanCarroll : if it could be used, then `instance Functor (\a -> Either a b) where fmap f (Left a) = Left (f a); fmap f (Right b) = Right b' would work indeed
11:45:26 <FunctorSalad> kmc: uh, "is" can mean "instance of" :)
11:45:31 <EvanCarroll> kmc: kmc right, ok. well that's a verbiage thing, tht's what I mean to say.
11:45:37 <kmc> ok
11:45:39 <FunctorSalad> as I unrelatedly noted in #-blah a second ago
11:45:41 <EvanCarroll> 13:44 < kmc> EvanCarroll, well i'm not sure where you got the idea that functors are type classes
11:45:46 <FunctorSalad> "dogs are mammals"
11:45:55 <EvanCarroll> "functors are instances of one particular typeclass, which is named "Functor""
11:46:01 <kmc> yeah
11:46:02 <kmc> that's correct
11:46:16 <EvanCarroll> I thought a Functor was the only typeclass to iterate over a type and return a different type.
11:46:35 <ski> FunctorSalad : hum .. i'm not sure what you're talking about
11:46:35 <EvanCarroll> It was iterating over trees, lists, and the Right side of either...
11:46:44 <monochrom> newtype Therei a b = Therei (Either b a)  may help
11:47:07 <ski> (".. can't be expressed (*directly*) ..")
11:47:10 <FunctorSalad> ski: we had been talking about how bifunctors are functors mathematically... in that context saying "the product category" was fair maybe
11:47:35 <ski> oh .. i guess i have missed that part
11:48:11 <FunctorSalad> the stuff about Readers was just tongue-in-cheek (the conversation was in a Reader monad, with the environment containing the bifunctor issue :))
11:48:38 <FunctorSalad> ('the product category' wouldn't make sense on the toplevel, indeed)
11:49:33 * ski . o O ( `k * (a * b + 1) = a * a + b * b' )
11:50:58 <FunctorSalad> related?
11:54:39 <soupdragon> ski, oh so it is probable that ab^3 = a^2
11:54:59 <soupdragon> although I don't see any reason to assume that is always the case
11:55:31 <soupdragon> no I found counter-examples actually
11:58:32 <ski> FunctorSalad : sorry, nonrelated .. this was re soupdragon's proposition `forall a,b :: Nat.  a * b + 1 | a^2 + b^2  =>  exists n :: Nat.  a^2 + b^2  = (a * b + 1) * n^2'
11:59:04 <c_wraith> preflex seen gwern
11:59:04 <preflex>  gwern was last seen on #xmonad 8 hours, 15 minutes and 19 seconds ago, saying: ~-~
12:06:32 <soupdragon>     Abstract: The periods, introduced by Kontsevich and Zagier, form a class of complex numbers which contains all algebraic numbers and several transcendental quantities. Little has been known about qualitative properties of periods. In this paper, we compare the periods with hierarchy of real numbers induced from computational complexities. In particular we prove that periods can be effectively approximated by elementary rational Cauchy sequences. 
12:06:32 <soupdragon> application, we exhibit a computable real number which is not a period. 
12:08:13 <c_wraith> Hmm.  I've just installed lambdabot from cabal.  I can't seem to figure out how to make it connect to an irc server though.  (Don't worry, I don't intend for it to be this server)
12:09:33 <danharaj> name it mubot and tell it to join #haskell when lambdabot is on leave
12:09:42 <Saizan> c_wraith: you call it like "lambdabot -e 'rc online.rc'"
12:10:01 <c_wraith> hmm.  and what's the syntax of that file look like?
12:10:16 <Saizan> c_wraith: you'll find the online.rc #haskell's lambdabot in the tarball, or in the topdir of the repo
12:10:24 <Saizan> +uses
12:10:39 <c_wraith> ok.  I can cabal unpack, I guess.
12:13:38 <c_wraith> ah, I see.  syntax change since the results google was finding was written
12:18:13 <c_wraith> heh.  lambdabot depends on brainfuck, but not mueval. :)
12:21:58 <c_wraith> ok..  Now, what does it take to get mueval work properly?
12:22:48 <c_wraith> Oh, mueval's working right.
12:23:03 <c_wraith> It must be how it's being called.
12:26:33 <Saizan> maybe you lack some lib that's getting imported
12:26:44 <c_wraith> Yes, I do.
12:26:46 <c_wraith> I found L.hs
12:26:50 <c_wraith> and it all makes sense now
12:27:03 <c_wraith> But I have no clue what lib I'm missing.  Hayoo was no help
12:27:52 <c_wraith> ah, it appears to be arrows
12:28:20 <soupdragon> wow look at this mad equation http://upload.wikimedia.org/math/c/3/1/c31a7965d831081f929463b6deb42ed8.png
12:32:27 <c_wraith> ok, got it working.  thanks for your help, Saizan 
12:32:33 <b0fh_ua> Hello! I created several parsers using Parsec, and now I want to use them over ByteString instead of String. However I have no idea for now about how to use functions from Text.Parsec.Char like noneOf with ByteString
12:32:37 <aristid> soupdragon: what is that function?
12:32:39 <b0fh_ua> can somebody please advice?
12:32:45 <soupdragon> knonecker limit
12:34:12 <soupdragon> ski I gave up it's too hard
12:34:14 <soupdragon> for me at least
12:34:32 <ddarius> b0fh_ua: Parsec 2 doesn't work with ByteStrings
12:34:45 <aristid> soupdragon: ok reading the wikipedia page i know that i have no clue what it is about. what do you need it for?
12:34:55 <b0fh_ua> ddarius: I'm using 3.1
12:34:56 <soupdragon> aristid I don't use it for anything
12:35:48 <aristid> soupdragon: did you stumble upon it entirely randomly?
12:35:53 <soupdragon> yes
12:36:00 <ddarius> b0fh_ua: Ah, yeah, I didn't notice the Text.Parsec in your first statement.
12:36:02 <soupdragon> I was searching for a book by someone who improved on that equation
12:37:45 <ddarius> b0fh_ua: It should more or less just work when you import Text.Parsec.ByteString(.Lazy) instead of Text.Parsec.String.
12:38:39 <b0fh_ua> ddarius: I imported just Text.Parsec
12:39:22 <ddarius> b0fh_ua: Just run your parser passing in a ByteString instead of a String.  It should just work.  If it doesn't what error are you getting?
12:43:32 <Phyx-> > fun
12:44:47 <soupdragon> ski I gave up and read the solution :(
12:44:49 <b0fh_ua> ddarius: http://github.com/jdevelop/hslj/raw/parsec-experiments-response/LiveJournal/ResponseParser.hs - this is the original code. And http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26815#a26815 is slightly modified one with error report
12:45:56 <ski> hm
12:46:25 * ski wonders where the proposition came from
12:46:49 <soupdragon> just a list of problems this guy gave out during lectures
12:50:34 <ddarius> b0fh_ua: read doesn't work on ByteStrings.
12:54:01 <ddarius> b0fh_ua: None of those errors have anything to do with Parsec functions so you are probably assuming/requiring String elsewhere.  I would recommend putting type annotations on your top-level functions as it significantly helps pin-point such issues.
12:55:49 <FunctorSalad> is there a simple way to parse lists of strings with parsec? say, parsing getArgs
12:56:28 <FunctorSalad> you'd presumably want to have both ordinary Char-parsers, and a parser with Strings as tokens invoking it?
12:56:43 <b0fh_ua> okay, thanks for the hint
12:57:04 <FunctorSalad> e.g. "manyTill (string "--") anyToken" to parse all args until --
12:57:46 <FunctorSalad> "manyTill (string "--" >> eof) anyToken" , I guess. And it isn't really manyTill since the token type changes
12:57:57 <FunctorSalad> (String on the outer level, Char on the inner)
12:59:46 <epicbeardman> hello, can anyone straighten out the differences between Go interfaces and Haskell type classes for me?
13:00:12 <epicbeardman> I contend that Haskell type classes are more powerful, but I just want to double check my reasoning with people who are smarter than me
13:00:15 <danderson> I probably can't describe all of them, but I can get you started
13:00:32 <FunctorSalad> are they different than java/C# ifaces?
13:00:32 <danderson> haskell type classes are more descriptive from a category theory perspective
13:00:57 <ddarius> danderson: I don't even know what you mean by that.
13:00:58 <danderson> Go interfaces are implicitly implemented by any type which implements the appropriate methods
13:01:12 <danderson> Haskell type class instances must be explicitly specified
13:01:12 <epicbeardman> danderson: from my perspective, it seems that Go interfaces are monomorphic, while type classes are polymorphic, and higher-order polymorphic.
13:01:22 <danderson> which of these is an advantage is up to personal taste
13:02:50 <danderson> epicbeardman: that sounds about right, I think. My terminology is rusty.
13:03:33 <danderson> Go interfaces and Haskell type classes feel quite similar in regular use, in my humble experience
13:03:48 <danderson> type classes can be pushed further, at the cost of getting rather confusing on the reader
13:03:50 <epicbeardman> my question about that is does that make Go interfaces a subset of Haskell type classes? IOW, are there things that type classes can express that would be hard/not possible/baroque to do with interfaces?
13:04:29 <ddarius> I think your question would/should be are there things Go interfaces can express that would be impossible with Haskell type classes.
13:05:05 <FunctorSalad> are the Go ifaces statically checked?
13:05:07 <danderson> I think the answer to ddarius' formulation is no, unless you count implicit implementation
13:05:25 <lispy> epicbeardman: I get hung up on this too.  It seems like simple parameter type classes can do everything a java interface can do.  Going the other direction I'm less sure
13:05:32 <bos> dafis: saw your mail, nice writeup
13:05:44 <epicbeardman> lispy: it is confusing for me.
13:05:47 <lispy> s/simple/single/
13:05:59 <ddarius> lispy: Type classes (alone) can't do what Java interfaces can.
13:06:13 <lispy> ddarius: Ah, what is missing?
13:06:21 <FunctorSalad> can't stuff them into a list? existentials will help
13:06:22 <ddarius> lispy: Existential types.
13:06:30 <lispy> ddarius: Example?
13:06:46 <FunctorSalad> (late dispatch OTOH happens with typeclasses already, I thought)
13:06:54 <FunctorSalad> when not statically known
13:06:59 <ddarius> FunctorSalad's example works.  List<Drawable> makes sense, Drawable a => [a] also does but doesn't mean the same thing.
13:07:09 <danderson> epicbeardman: as for something that type classes can represent but go interfaces cannot, the first thing I come up with is the Monad type class
13:07:10 <lispy> okay
13:08:00 <lispy> ddarius: is this why so many Haskell newbies from other languages want to use existentials + type classes when there are better alternatives?
13:08:10 <FunctorSalad> or methods with sigs where the type occurs more than once, or where it occurs in a positive position...
13:08:16 <ddarius> lispy: Probably.
13:08:25 <danderson> unfortunately, my theory-fu is insufficient to qualify the two concepts properly, I can only tell you how they feel different when used :)
13:08:31 <FunctorSalad> (if these ifaces are like I think they are)
13:08:32 <ddarius> lispy: Also, List<Drawable> is a pretty good solution.  OOP has some good stuff.
13:08:35 <epicbeardman> FunctorSalad: that is another point I noticed
13:08:55 <FunctorSalad> epicbeardman: wrote a stackoverflow post once, but on doing these things in C#, not Go
13:09:02 <dafis> bos: I'm surprised it went unnoticed for so long
13:09:05 <FunctorSalad> explicit dictionary didn't seem like a bad idea...
13:09:15 <FunctorSalad> (with C#'s parametric polym. you can make that typesafe)
13:10:00 <bos> dafis: there are a few lurking bugs like that, where quickcheck doesn't root them out.
13:10:24 <bos> dafis: my challenge is going to be to write a regression test for that one :-)
13:10:37 <dafis> bos: sure, but I'd have expected it to show up in practice sooner
13:10:52 <FunctorSalad> (example for more than once: Eq/(==), for positive position: Read)
13:11:08 <bos> dafis: another similar bug did
13:11:17 <FunctorSalad> Eq requires a slightly contrived use of parametric polymorphism to do properly in OO languages ;)
13:12:10 <FunctorSalad> (not a property of OO per se)
13:12:40 <epicbeardman> FunctorSalad: the other thing, as danderson mentioned, is constructor classes, e.g. Maybe
13:12:59 <lispy> FunctorSalad: just use double dispatch with a visitor pattern ;)
13:13:26 <ddarius> lispy: So you can get the worst of both worlds of OO and FP.
13:13:35 <FunctorSalad> lispy: "double dispatch"? the language feature of multiple dispatch?
13:13:44 <FunctorSalad> or is this a pattern
13:14:03 <ddarius> It's a horrible, but clever, trick.
13:14:12 <lispy> FunctorSalad: in single dispatch languages you can get the overall effect of multiple dispatch using what's known as "double dispatch-"
13:14:40 <mauke> or triple dispatch, or quadruple dispatch, ...
13:14:43 <thaostra> clever things in programming should be avoided
13:14:45 <ddarius> All it requires is writing out all n^2 alternatives spread over all the classes.
13:14:50 <kniu> :info <|>
13:14:51 <lispy> inductive dispatch?
13:15:01 <kniu> @hoogle <|>
13:15:24 <ddarius> It's part of the Alternative class in Control.Applicative
13:15:26 <Cale> thaostra: Depends on what exactly is meant by "clever" I think :)
13:15:36 <ddarius> kniu: Or in Parsec.
13:15:47 <FunctorSalad> sounds harder than IEquatable<T> with the convention that T will be the instantiating type
13:15:48 <ddarius> (and no doubt some other libraries)
13:16:09 <ddarius> FunctorSalad: Double dispatch doesn't require parametric polymorphism.
13:16:14 <FunctorSalad> (which isn't really problematic but screams that you really want typeclasses ;))
13:16:25 <FunctorSalad> ah. I suspected that you're describing a workaround for that :)
13:16:33 <thaostra> when i mean "clever", i just mean code that is difficult to understand and change without giving "interesting" results. 
13:16:58 <kniu> ddarius, thanks
13:17:05 <thaostra> perl programmers would understand what i'm talking about ;)
13:17:29 <bos> dafis: just to confirm, are you using 0.7.1.0?
13:17:59 <dafis> bos yes (well, after debugging, I'm at 0.7.1.0.11 :)
13:18:01 <FunctorSalad> thaostra: hmm depends on whether the 'cleverness' yields a big objective benefit....
13:18:20 <FunctorSalad> I'd agree that it's not good for its own sake (in code that people are supposed to read eventually)
13:18:29 <thaostra> most of the time..it doesn't 
13:18:29 <bos> dafis: hmm, i think i fixed this bug a few months ago but didn't do a release :-(
13:18:49 <dafis> bos: big oops
13:18:56 <FunctorSalad> thaostra: but e.g. pointlessness seems to be a case that seems obscurant at first, but makes you faster if you're fluent in it
13:19:07 <FunctorSalad> (within reason)
13:19:11 <soupdragon> Cale do you do number theory? :)
13:19:14 <FunctorSalad> no flip ((.) .) 
13:19:20 <Cale> soupdragon: Not *really*
13:19:41 <Cale> soupdragon: I've taken a course in algebraic number theory, but... I've probably forgotten a lot of it.
13:19:45 <thaostra> i hate to say this, but i'm sure google chose to use python for these reasons
13:20:11 <Phyx-> they were drunk
13:20:22 <thaostra> hm?
13:20:24 <soupdragon> oh really I think algebraic number theory has connections with zeta function
13:20:37 <Cale> thaostra: Well, cleverness without wisdom tends to make messes. There are things which are both clever and wise as well. :)
13:20:56 <Feuerbach> How declarations with multiple alternative guards are parsed? In http://haskell.org/onlinereport/syntax-iso.html I see that guard belongs to rhs and there may be only one rhs attached to a funlhs
13:20:58 <ddarius> soupdragon: Try this http://www.garretstar.com/secciones/publications/docs/monthly336-346.pdf
13:21:01 <Cale> soupdragon: Well... that's moreso with analytic number theory.
13:21:10 <soupdragon> ddarius can you read German?
13:21:15 <ddarius> soupdragon: Riemann's Zeta function comes from analytic number theory.
13:21:19 <ddarius> soupdragon: Barely.
13:21:28 <soupdragon> there's a number theory book in german I want to read :(
13:21:33 <soupdragon> but I don'tknow any other language than english
13:21:38 <thaostra> perhaps, Cale
13:21:45 <dafis> soupdragon: which?
13:21:51 <lispy> soupdragon: reading german shouldn't be too bad
13:21:51 <dafis> book
13:21:59 <soupdragon> dafis, Zetafunktionen und quadratische Koerper
13:22:02 <lispy> soupdragon: google translate would actually get you fairly far I would hope
13:22:09 <ddarius> (Incidentally, if you have a passing background in some basic complex analysis, Riemann's paper is actually rather readable.)
13:22:11 <dafis> soubdragon: author?
13:22:17 <soupdragon> Don Zagier
13:22:35 <dafis> soupdragon: defenitely worth a *lot* of effort
13:22:36 <soupdragon> yes I want to learn the mellin transform so I can read Reimanns paper but it is very difficult
13:22:47 <thaostra> I wish google would use superior languages for large scale projects, as I'm sure their developers are quite talented
13:23:05 <thaostra> there's Ruby, but I have only seen that for sketch up
13:24:16 <FunctorSalad> in the defense of cleverness, it's not always out of smugness/elitism. often you inappropriately use a fancy feature simply to get familiar with it
13:24:24 <FunctorSalad> (for the cases where it is approporiate)
13:24:28 <pizza_> what is ruby superior to?
13:24:31 <soupdragon> oh that's an interesting idea.. I had to find x,y for (a,b) = g ==> ax + by = g
13:24:42 <Cale> thaostra: Like, I think our proclivity for stealing ideas from mathematics tends to produce code which is nicely maintainable and general (so long as you come to an understanding of those ideas) at the same time as being quite clever.
13:24:43 <soupdragon> but this Missing Spectral Basis is talking about ax + by + cz + ..
13:24:58 <epicbeardman> pizza_: I always thought it was kind of kludgy, personally.
13:25:07 <thaostra> stealing ideas?
13:25:14 * hackagebot text 0.7.2.1 - An efficient packed Unicode text type  http://hackage.haskell.org/package/text-0.7.2.1 (BryanOSullivan)
13:25:17 <bos> dafis: text 0.7.2.1 on hackage now
13:25:25 <dafis> bos: thanks
13:25:30 <Cale> soupdragon: It sounds like you just want the extended Euclidean algorithm.
13:25:56 <McManiaC> can someone tell me, why these haddocks of run/eval/execMState get messed up? the source looks fine to me? http://n-sch.de/hdocs/mstate/Control-Concurrent-MState.html
13:26:01 <bos> dafis: let me know if it doesn't fix your problem, please
13:26:19 <Cale> thaostra: For example all the ideas we're borrowing from category theory these days :)
13:26:23 <dafis> bos: give me at least the time to build it :)
13:26:39 <thaostra> you seem to only talk about them, rather than explain them
13:26:40 <Cale> Functors, monads, comonads, etc.
13:26:53 <Cale> thaostra: I can explain some to you if you'd like.
13:26:54 <thaostra> where do you learn about category theory?
13:27:16 <Cale> thaostra: Well, my favourite intro book on category theory is Awodey's.
13:27:21 <Cale> One sec, I'll get you a link.
13:27:30 <thaostra> amazon would be prefered
13:27:35 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
13:27:41 <Cale> Oh, all right :)
13:27:52 <thaostra> oh, that could work :D
13:28:09 <thaostra> however, it says i am missing a plugin
13:28:26 <thaostra> hm do i need to enable a pdf reader in chrome?
13:28:33 <soupdragon> save it as  a file
13:28:36 <Cale> I would just save the file
13:28:37 <ddarius> thaostra: Download it.
13:28:48 <soupdragon> oh are you in that chrome os thing
13:29:05 <thaostra> it just gives me a blank page saying "missing plug-in"
13:29:17 <thaostra> and no, i'm using chrome dev on linux
13:29:19 <soupdragon> what OS are you on
13:29:28 <asdfwef> openBSD
13:29:30 <soupdragon> okay you can use   wget <url>   to save the file
13:29:51 <Twey> Can't you right-click/save?
13:30:13 <Cale> http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0198568614 -- I like that the "Also Bought" section now includes TaPL :)
13:30:14 <Feuerbach> How declarations with multiple alternative guards are parsed? In http://haskell.org/onlinereport/syntax-iso.html I see that guard belongs to rhs and there may be only one rhs attached to a funlhs
13:30:35 <thaostra> hold on..using wget
13:30:48 <dburke_> Any advice for tracking down why System.Posix.Files.fileSize gives garbage on my OS-X 10.6 laptop (e.g. a 4013 byte file is reported to have a size of 17592186044416!). I'm guessing 32/64 bit issues? Ta
13:30:53 <dolio> Only $124, eh?
13:31:42 <thaostra> i'm curious, what is the OO equivalent to monads in langs like ruby? 
13:31:50 <soupdragon> there isn't one
13:31:55 <dolio> Monads.
13:31:55 <thaostra> i have read about duck typing, but i can't be sure
13:32:16 <Cale> Feuerbach: I think the loop is in gdrhs
13:32:21 <dafis> bos: seems to work, at least what died with 0.7.1.0 goes now through
13:32:32 <bos> dafis: yay!
13:32:37 <Cale> Feuerbach:  gdrhs -> gd = exp [gdrhs]
13:32:57 <Feuerbach> Cale: oh, indeed, I missed that loop. Thanks.
13:33:09 <thaostra> http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html
13:33:19 <thaostra> is that similar to monads in haskell?
13:33:38 <technogeeky> thaostra: monads is monads. Haskell does them right.
13:33:43 <Cale> thaostra: I believe that one is based on a misunderstanding about how exactly monads are an abstraction
13:33:56 <dafis> bos: the fix looks vaguely familiar :)
13:34:32 <thaostra> i found that link on lambda the ultimate *shrugs*
13:34:37 <Cale> thaostra: A lot of people seem to get this wrong when they try to translate the monad abstraction into another language, and it results in not being able to write any code which will work in more than one monad -- which makes the whole exercise pointless.
13:35:09 <soupdragon> thaostra, a cool one is monads in SCHEME
13:35:18 <thaostra> but it's scheme!
13:35:20 <soupdragon> do you know this language
13:35:23 <technogeeky> It's akin to doing some ahrd work to assemble a car only to find you can't drive it on the roads.
13:35:23 <thaostra> D:
13:35:28 <technogeeky> s/ahrd/hard/
13:35:33 <soupdragon> okay you're not interested
13:35:44 <bos> dafis: funny that ;-)
13:35:45 <thaostra> ayep
13:36:10 <technogeeky> I, unfortunately, was taught scheme by a very uninteresting teacher.
13:36:14 <bos> Cale: i liked your select and separate proposals yesterday
13:36:33 * edwardk waves hello.
13:36:36 * soupdragon try to teach myself the important things before anyone can ruin it for me
13:36:37 <soupdragon> hi
13:36:38 <dafis> bos: great minds, you know ;)
13:36:46 <ddarius> "My English teacher was boring, so I only speak Japanese."
13:36:54 <bos> Cale: there's already a separate-like function in Data.Text, but i'm going to fix up the type to be more similar to your proposal
13:36:55 * edwardk is kicking around the idea of an alex style lexer as a quasiquoter
13:37:01 <thaostra> engo ga wakari masu ka
13:37:08 <Feuerbach> dburke_: weird indeed. Can you post a test case somewhere?
13:37:17 <thaostra> ehh my japanese-ness is kicking in. thanks ruby!
13:37:22 <Feuerbach> with its output
13:37:23 <edwardk> foo = [$lexer| $digits = ... |] -- building up the usual parse trees at compile time, using antiquotation for the actions, etc.
13:38:02 * ddarius is wondering if that was the question thaostra wanted to ask.
13:38:04 <edwardk> i've had the 'hood off' of alex for a few hours, trying to figure out how best to attach the speculation machinery to its innards
13:38:05 <Cale> bos: Cool, perhaps you should +1 it :)
13:38:14 <technogeeky> Well, I don't consider it ruined. I just proclaim myself igorant of the subject (of Scheme and Smalltalk) and I'll learn it one day.
13:38:18 <thaostra> did you understand it, ddarius?
13:38:24 <Twey> thaostra: Engo?  Protective covering?  :Ã¾
13:38:24 <ddarius> edwardk: Your solution is searching for a problem?
13:38:33 <edwardk> ddarius: very much so =)
13:38:48 <edwardk> ddarius: besides this way the side-project might yield another useful community tool ;)
13:38:52 <thaostra> i might have spelled the word "english" incorrectly
13:38:59 <ddarius> Eigo
13:39:02 <Twey> I think you meant è‹±èªž (eigo)
13:39:22 <thaostra> i meant that
13:39:34 <thaostra> using kanji?
13:39:34 <Twey> thaostra: It's a real monadâ€¦ but it doesn't allow you to abstract over monads, which defeats most of the point.
13:39:49 <edwardk> ddarius: besides it is well known that some of the most efficient searches work both forward and backwards, so what is wrong with searching backwards from the solution? =)
13:40:13 <ddarius> edwardk: I've never heard someone put it that way before.
13:40:23 <edwardk> after all: the alt text here applies: http://xkcd.com/759/
13:40:28 <Cale> thaostra: Okay, here's how you'd do it in a language without typeclasses...
13:40:53 <Cale> thaostra: You make return and bind (the ones which you expect people to use) take an extra parameter each
13:41:13 <Cale> thaostra: which will be a dictionary consisting of the actual implementations of return and bind
13:41:18 <Cale> (for the given monad)
13:41:25 <edwardk> ddarius: well, once you know that the solution is working backwards from the solution, if you work backwards from that and forwards from your statement it is obvious. ;) er...
13:41:43 <edwardk> this gets metacircular fast
13:41:53 <thaostra> i have made a monad, but the example is so trivial that it could be done more simply in other languages D:
13:42:22 <Cale> thaostra: That way, code can be written which will operate using an arbitrary monad. However, this is rather cumbersome, because you have to pass along which monad you're using at every step.
13:42:58 <Cale> So, it works out best in languages where you have something of a macro system to help you pass these additional parameters. You essentially end up emulating an implementation of typeclasses.
13:43:22 <Cale> But even without that, it'll let you write all the useful functions which operate in any monad.
13:43:40 <edwardk> gah
13:43:42 <edwardk> one problem
13:43:45 <Cale> (and achieve the whole point of talking about monads in the first place, which is to avoid writing those functions over and over again)
13:44:01 <edwardk> the "string literal prim"# is missing from template haskell
13:44:25 <ddarius> edwardk: Hack the compiler.  That's what I did eight years ago.
13:44:46 <Cale> thaostra: Functions like almost everything in Control.Monad, and things like Data.Traversable
13:44:53 <Cale> (though that has moar abstraction)
13:45:02 <edwardk> ddarius: well, i can always do something dreadful like allocate a cptr in unsafePerformIO and scribble it, but its annoying
13:45:26 <ddarius> (Back then TH didn't support records.  Of course, TH wasn't even in a released version of GHC at the time.)
13:45:58 <edwardk> ddarius: besides i already want like 3 small hacks into ghc ;) this is a slippery slope
13:46:18 <ddarius> edwardk: That might distract you from answer StackOverflow questions?
13:46:21 * hackagebot mstate 0.1 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.1 (NilsSchweinsberg)
13:46:31 <edwardk> ddarius: exactly
13:46:51 <thaostra> i hope ruby supports more than just closures, anonymous functions, and recursion in the next release, because i really enjoy programming in a functional style
13:47:05 <thaostra> there are others, but you get the idea
13:47:05 <ddarius> thaostra: What more do you want it to support?
13:47:10 <edwardk> ddarius: someone has to keep dons punctual. i mean if i wasn't there nipping at his tails or pedantically pointing out some irrelevant detail who would be? oh wait, there are quite a few others.
13:47:43 <Cale> Ruby should fix its "blocks" to make them first class values.
13:47:49 <thaostra> well, monads seem to be the big thing which is often associated with haskell, so it does seem like a nice feature to have
13:48:01 <ddarius> Monads aren't a feature.
13:48:14 <thaostra> oh, silly me
13:48:20 <Cale> Monads are something a bit like a design pattern (which is neatly encoded as a library)
13:48:47 <Cale> Monadic IO is a feature though.
13:49:19 <Cale> Probably shoehorning that into Ruby at this point would fail though.
13:49:41 <thaostra> maybe
13:50:02 <Cale> Well, at the very least, it would break absolutely every Ruby program that was ever written to this point.
13:50:13 <Cale> So, I don't think it'll happen ;)
13:50:20 <thaostra> curses 
13:50:23 <aristid> damn conservative rubyists
13:50:30 <thaostra> well, i guess it can't have everything ;)
13:50:31 <sepp2k1> Do-notation is a feature too. And having a monad typeclass in the standard library. Also having a typesystem expressive enough to be able to define such a typeclass in the first place.
13:50:34 <edwardk> thaostra: monads are hard to add to a language post hoc.
13:50:49 <dolio> Except if it's Haskell.
13:50:54 <Cale> Hehe :)
13:51:01 <ddarius> Haskell would not be very worse off if do-notation was removed.
13:51:02 <edwardk> dolio: yeah i was going to say, we got lucky that they nicely fit our type system
13:51:14 <aristid> don't they benefit from the laziness too?
13:51:22 <Cale> Yeah, if we didn't have the IO monad, but instead had some other sufficiently expressive system for doing IO, we could get the IO monad back.
13:51:28 <ddarius> aristid: Slightly.
13:51:42 <aristid> hmm i guess you don't strictly need laziness to use them
13:51:42 <edwardk> aristid: yes, it lets us eta-reduce more programs, and yields nicer EDSLs
13:51:59 <ddarius> aristid: Someone was complaining that monads were stupid because code like forever m = m >> forever m didn't work in O'Caml.
13:52:15 <Cale> aristid: They benefit more from the unwillingness to evaluate underneath unapplied lambdas.
13:52:16 <ski>   parseFoo = ... `mplus` do ...; x <- parseFoo; ...  -- and this
13:52:19 <edwardk> fewer extraneous ()'s being passed to force deferred execution
13:52:22 <Cale> (which is pretty standard)
13:52:27 <ddarius> When I used monads in JavaScript, the lack of laziness was also annoying.
13:52:42 <thaostra> eh javascript
13:52:52 <Cale> The list monad benefits greatly from laziness.
13:52:59 <edwardk> ddarius: clearly you needed to build your own system of laziness built on evaluable closures
13:53:04 <dolio> Obiously (>>) should be a macro.
13:53:07 <Cale> But you could do a different nondeterminism monad which didn't require it.
13:53:15 <ddarius> dolio: Indeed.
13:53:15 <aristid> ddarius: is it completely impossible to define forever in ocaml on at least some monads?
13:53:24 <aristid> dolio: a macro?
13:53:32 <ddarius> aristid: No, you just write: forever m = m >>= \_ -> forever m
13:53:57 <dolio> aristid: m >> forever m needs to expand to 'm >>= \_ -> forever m' without evaluating the 'forever m'.
13:54:06 <Cale> aristid: I don't even know of a practical programming language which supports lambda but does evaluation underneath unapplied lambdas.
13:54:21 <aristid> Cale: i think that would be pretty weird.
13:54:27 <ski> Cale : MetaML ?
13:54:45 <edwardk> dolio: (define-syntax do   (syntax-rules ()     ((do m comp-body) comp-body)     ((do m ((x0 comp0)) comp-body) (bind m (lambda (x0) comp-body) comp0))     ((do m ((x0 comp0) (x comp) ...) comp-body)      (bind m (lambda (x0) (do m ((x comp) ...) comp-body)) comp0))))
13:54:48 <Cale> You can't evaluate the recursive call to forever there too early because the lambda which contains it hasn't been applied yet.
13:54:50 <edwardk> dolio: done ;)
13:54:53 <ski> (granted, it only does evaluation inside unquotes inside quoted lambdas)
13:55:14 <dolio> edwardk: Yes, now i can see why Lisp is the pinnacle of languages.
13:55:21 <edwardk> dolio: hahaha
13:55:24 <soupdragon> edwardk, weird way to do it
13:55:51 <Cale> edwardk: Reminds me of implementing list comprehensions in Mathematica.
13:56:01 <soupdragon> why not use SHIFT/REST for direct style monadic programming
13:56:06 <soupdragon> RESET*
13:56:10 <edwardk> soupdragon: i've since replaced it. now i curry the monad dictionary in as a final argumnt
13:56:16 <edwardk> but that needs a lot more machinery =)
13:56:17 <ddarius> edwardk: You need the dictionary passing too.
13:56:20 <ski> edwardk : why `((do m comp-body) comp-body)' ?
13:56:31 <edwardk> ddarius: that is m
13:56:33 <soupdragon> Like what Oleg uses in Ocaml
13:56:43 <Cale> SetAttributes[Comprehend, HoldAll]
13:56:43 <Cale> Comprehend[expr_] := {expr}
13:56:43 <Cale> Comprehend[expr_, {var_, l_}, rest___] := 
13:56:43 <Cale>  FlatMap[Function[var, Comprehend[expr, rest]], l]
13:56:43 <Cale> Comprehend[expr_, cond_, rest___] := 
13:56:44 <soupdragon> for probability distributions
13:56:45 <Cale>  If[cond, Comprehend[expr, rest], {}]
13:57:04 <edwardk> ski: this version is possibly wrong in the base case. i just grabbed it coz it was a convenient self contained monadic do ;)
13:57:41 <edwardk> er do syntax-rules macro
13:58:28 <alexyk> how do you effect -XOverloadedStrings in compiled source?
13:58:35 <ski> ddarius : do you know a workaround for `parseFoo = ... `mplus` do ...; x <- parseFoo; ...' in OCaml ?
13:58:53 <aristid> alexyk: {-# LANGUAGE OverloadedStrings #-} ?
13:58:55 <Cale> At the same time as it's completely insane, mathematica's evaluation model can be quite convenient for this sort of thing.
13:59:00 <alexyk> aristid: ok
14:00:01 <ddarius> ski: I don't program in O'Caml, but you should just be able to make a lazier mplus.  I might even have done such a thing for my JavaScript monads.
14:00:46 <ski> ddarius : the problem being that `parseFoo' is not (visibly) a function, but should still be recursive
14:00:57 <ddarius> (That JavaScript program also drove home how even the slightest, most "harmless" looking mutable state can wreak havoc.)
14:01:09 <ddarius> ski: Just eta expand.
14:01:30 <ski> and i don't think the recursive value bindings which let you say `let rec ones = 1 :: ones' works in this case
14:01:38 <ski> ddarius : that breaks the parser abstraction
14:02:02 <ddarius> ski: You can do it without that or, more simply, just add a () argument.
14:02:20 <thaostra> i'm wondering, is there a decent 2d graphics library for haskell?
14:03:03 <ski> heh, adding a dummy `()' delays the construction (which might be costly)
14:03:26 <technogeeky> The best player on Uruguay's team: the goalpost.
14:03:39 <Cale> thaostra: There are a number of them, but what counts as "decent"? :)
14:03:42 * ski supposes it can work in many cases, though ..
14:04:15 <thaostra> ones which have garnered the attention of more than a couple of commiters and isn't deprecated?
14:04:49 <Cale> thaostra: There's a fairly complete binding to GTK 2, there's an SDL binding, OpenGL, along with a few nice interfaces for using OpenGL in 2D :)
14:04:50 <thaostra> there's gosu for ruby, but i want to try an equivalent in haskell
14:05:00 <Cale> http://hackage.haskell.org/package/graphics-drawingcombinators
14:05:08 <thaostra> okay, how about something more abstract?
14:05:08 <Cale> Oh, I don't know what gosu is all about
14:05:11 <monochrom> technogeeky: totally :)
14:05:13 <soupdragon> > 1+1
14:05:23 <Cale> http://hackage.haskell.org/package/gloss
14:05:40 <aristid> ddarius: i don't know who wrote it, but somebody wrote that he expects that in the future, people will compile from languages to javascript to make it run in the browser. at the time i laughed about that, because i thought "yeah i'd just write the javascript, it's not such a bad language actually". but now i'm not so sure anymore
14:05:42 <thaostra> gimme a sec for a link
14:06:05 <thaostra> http://www.ohloh.net/p/gosu
14:06:07 <ddarius> aristid: People already do that.
14:06:21 <aristid> yeah, even from java
14:06:34 <edwardk> ski: using the () argument gets you the desired time behavior for your DSL, though the space behavior can be somewhat lacking.
14:06:45 <ddarius> aristid: The benefit isn't to avoid having to write JavaScript, but to avoid having to spread your code over different languages.
14:08:15 <ski> edwardk : hm, elaborate ?
14:08:22 <aristid> ddarius: at some point i thought that the best way to solve THAT would be to write everything in javascript...
14:08:45 <ddarius> aristid: Well that's just crazy.
14:09:23 <edwardk> ski: modelling call-by-name vs. call-by-need
14:09:27 <aristid> ddarius: compared to PHP...
14:09:32 <edwardk> (though that can affect time as well)
14:10:29 <edwardk> straw poll time: name for a haskell lexer that isn't alex. the best one i have come up with so far is dyslex ;)
14:10:41 <edwardk> ideas?
14:11:37 <aristid> edwardk: hlex
14:11:39 <hpc> http://hackage.haskell.org/package/haskell-lexer-1.0?
14:12:12 <edwardk> hpc: sorry i meant a lex/flex/alex clone written in haskell, not for haskell =)
14:12:22 <edwardk> targeting template haskell
14:12:26 <hpc> ah
14:14:01 <edwardk> i guess reflex also isn't bad
14:15:00 * ddarius suggests "speculum"
14:15:11 <edwardk> i suppose with me involved it may be accused of being 'complex' or of being designed to 'perplex'
14:15:19 <edwardk> ddarius: ouch.
14:16:50 <edwardk> ddarius: well, it isn't particularly tied to speculation. =) in fact i had started trying out speculation tricks just using alex without a wrapper, but now that i sound that out, after the speculum comment, even that sounds dirty.
14:18:03 <ksf> grep lex$ /usr/share/dict/words
14:18:10 <edwardk> ksf: started there ;)
14:18:22 <Philippa> edwardk: toke, because the result is token?
14:18:46 <edwardk> Philippa: given my career, i try to avoid drug references =/
14:19:00 <Philippa> *nod* fair enough
14:19:05 <lispy> edwardk: mexlex?
14:19:29 <Philippa> reflex sounds good if it's not taken
14:19:29 <edwardk> circumflex could be a cute name for a flex clone that handles utf-8...
14:19:44 <monochrom> haha
14:19:45 <edwardk> reflex looks open, of course so is 'lex' as a package name
14:20:02 <Philippa> deflex, on account of all the trouble no longer coming your way?
14:20:06 <ksf> deflex would be a good name for something superiour to flex
14:20:13 <Philippa> snap!
14:20:26 <edwardk> ksf: =)
14:20:48 <edwardk> sounds like more of a tool for converting to parsec or something though
14:20:48 <Apocalisp> kornflex
14:20:57 <edwardk> Apocalisp: *groan*
14:20:59 <thaostra> Cale, i know this is a little late, but where do you find the code metrics for these libraries?
14:21:28 <ddarius> speckles
14:22:35 * ski . o O ( simplex )
14:22:50 <edwardk> i also like simplex for the ease of use aspect, but the mathematician in me cringes and wants to have the name available in scope ;)
14:22:51 <Philippa> duplex?
14:23:23 <dolio> googolplex
14:23:32 <Philippa> has anyone written a lex clone called luthor yet?
14:23:32 <edwardk> dolio: hahaha
14:23:40 <edwardk> Philippa: oooh
14:23:43 <ski> ("orthoplex" ? "inflex" ? "lexical" ?)
14:23:57 <Apocalisp> Luthor is pimp
14:24:07 <monochrom> hahaha
14:24:10 <edwardk> I could definitely see Language.Luthor
14:24:22 <ddarius> Language.Lex.Luthor
14:24:29 <edwardk> ddarius: true =)
14:24:33 <Phyx-> Lex Luthor?
14:24:36 <Phyx-> which one?
14:24:38 <edwardk> ddarius want to make sure others can drop lexers in the namespace
14:24:51 <ksf> dyslexia?
14:24:59 <Philippa> though arguably Text.Lex.*
14:25:05 <ski> apoplexia
14:25:10 <edwardk> ksf: my starting point was 'dyslex'
14:25:15 <ksf> @wn catalexis
14:25:17 <monochrom> Lex.Or
14:25:22 <ksf> @bot
14:25:27 <ski> :)
14:25:56 <edwardk> ksf: the connotation of incompleteness there disturbs me ;)
14:26:03 * ddarius writes a parser for Icon so he can have lex-icon
14:26:09 <ksf> n. pl. cat·a·lex·es (-sz)
14:26:09 <ksf> The absence of one or more syllables in a line of verse, esp
14:26:19 <ksf> yeah ana- would be better.
14:26:31 <ddarius> edwardk: Alexis
14:27:01 <ksf> alexia
14:27:06 <ddarius> Presumably you want to have drop-in replacement for Alex.
14:27:08 <ski> alexandria
14:27:25 <edwardk> ddarius: well, i was shooting to just implement it as a template haskell quasiquoter, using basically the syntax of alex in the qq
14:27:37 <edwardk> that way i could get away from all the ugly wrapper machinery
14:28:10 <edwardk> and probably using my bitsets instead of the naive function rep used for charsets in alex, so that i could get away with implementing utf-8 parsing without too much pain
14:28:14 <ksf> exlex, which means lawless
14:28:37 <thaostra> hackage doesn't have anything for code metrics?
14:28:41 * ski . o O ( lawless sequences )
14:29:16 <ddarius> thaostra: Not the current version.  The new version should.
14:29:20 <acowley> I'm having a brain bubble... what's a HOF that'll let me do \x -> f3 x . f2 x . f3 x
14:29:29 <acowley> err
14:29:30 <thaostra> and where would that be?
14:29:35 <acowley> \x -> f3 x . f2 x . f1 x
14:29:36 <ddarius> It does have some basic "compiles with this version of GHC" stats.
14:29:38 <ksf> Im´plex
14:29:38 <ksf> a.	1.	Intricate; entangled; complicated; complex.
14:29:38 <ksf> The fable of every poem is . . . simple or implex. it is called simple when there is no change of fortune in it; implex, when the fortune of the chief actor changes from bad to good, or from good to bad.
14:29:40 <thaostra> eh forget it
14:29:59 <edwardk> i'll probably go with luthor, its simple, a first order pun, and gives a nice namespace
14:30:08 <thaostra> looks like i'm sticking to a more reliable source, namely ohloh
14:30:14 <edwardk> and you don't have to be an english major to get the reference ;)
14:30:27 <edwardk> or have a classics background =)
14:30:51 <monochrom> yeah you just have to be a superman major
14:31:07 <acowley> I think a minor would be sufficient to get the reference
14:31:36 <monochrom> all cultural references come with barriers to entrance
14:31:40 <edwardk> acowley: i'd hope you could get by with just having taken an elective at a community college for that one ;)
14:31:41 <acowley> minoring in superman could also be a soft requirement for haskell expertise
14:31:56 <ddarius> edwardk: You should just generate a UUID for it and call it a day.
14:32:12 <edwardk> ddarius: hrmm i wonder if hackage would take something that long
14:32:16 <technogeeky> ddarius: that's how company names are assigned in the year 3000
14:32:24 <acowley> oh god, please don't do that ed
14:32:29 <edwardk> cabal install supercalifragilisticexpialadocious
14:32:41 <acowley> I had to have a meeting to convince people that "hackage" was a reasonable dependency for a project
14:32:49 <edwardk> cabal install antidisestablishmentarianism
14:32:51 <technogeeky> cabal install how-many-characters-can-I-use-in-naming-my-package-12345...
14:33:19 <thaostra> well, what makes hackage a reasonable dependency?
14:33:29 <acowley> Their objection was just the name
14:33:37 <monochrom> ghc already assigns uuid to your packages
14:33:40 <edwardk> cabal install lopadoÂ­temachoÂ­selachoÂ­galeoÂ­kranioÂ­leipsanoÂ­drimÂ­hypoÂ­trimmatoÂ­silphioÂ­paraoÂ­melitoÂ­katakechyÂ­menoÂ­kichlÂ­epiÂ­kossyphoÂ­phattoÂ­peristerÂ­alektryonÂ­opteÂ­kephallioÂ­kigkloÂ­peleioÂ­lagoioÂ­siraioÂ­bapheÂ­traganoÂ­pterygon
14:33:47 <Phyx-> ...
14:34:01 <acowley> They thought it was a hacker tool of some kind
14:34:09 <thaostra> uhm okay. how did you try to convince them otherwise
14:34:22 <edwardk> acowley: i just tell them to use 'cabal' and not mention 'hackage'
14:34:37 <monochrom> base-4.2.0.2-5fc3ebcb886ceae9a06b0bab7e8d4680.conf or something in your ghc directory
14:34:42 <acowley> I just went over the variety of libraries available there and it was clear that it was a legitimate thing
14:34:52 <thaostra> in that case, why should one even bother using cabal or hackage?
14:34:56 <monochrom> may as well just go "5fc3ebcb886ceae9a06b0bab7e8d4680"
14:35:13 <technogeeky> well, cabal is defined as:
14:35:17 <technogeeky> a clique (often secret) that seeks power usually through intrigue
14:35:22 <technogeeky> conspire: engage in plotting or enter into a conspiracy, swear together; "They conspired to overthrow the government"
14:35:23 <acowley> edwardk: it came up because I had written in a README to download cabal-install from hackage (I included the URL) before installing our software on new machines
14:35:24 <lispy> BMeph: Just saw your email on -cafe
14:35:33 <lispy> BMeph: So you're silent?
14:35:54 <edwardk> acowley: ah
14:36:10 <thaostra> i'm sure that's why it's named for that reason, but hey, i read the article ;)
14:36:17 <lispy> Does anyone know why webchat users have no voice?
14:36:25 <ksf> of course hackage is a hacker tool
14:36:27 <edwardk> lispy: bot spam attack
14:36:32 <thaostra> seriously, why use cabal
14:36:35 <acowley> It was a brief, unfortunate episode that was soon resolved, but now you have me scared I'm going to listing dependencies on a list of UUIDs hosted at a place called hackage
14:36:40 <edwardk> lispy: i was caught in the dragnet earlier myself
14:36:42 <lispy> edwardk: even for identified users?
14:36:51 <monochrom> hahaha
14:36:58 <acowley> thaostra: the word or the software?
14:37:12 <edwardk> acowley: hah
14:37:16 <thaostra> the software of course. it would be silly to judge something by the name
14:37:36 <thaostra> unless you meant something else
14:37:38 <acowley> cabal-install makes installation of our software on new machines a snap
14:37:50 <thaostra> well, any package manager can do that
14:37:51 <acowley> so it's part of the installation instructions I include in the repository
14:38:08 <edwardk> acowley: clearly the instructions should be 'download the haskell platform' 'cabal install cabal-install' 'install my app' ;)
14:38:09 <acowley> edwardk: does the function I asked about earlier look familiar to you in any way?
14:38:18 <edwardk> acowley: i missed it, scrolling back
14:38:43 <ksf> acowley, you could also say "download from haskell.org" and then link to "hackage.haskell.org"
14:39:04 <soupdragon> is infinity a p-adic number?
14:39:19 <acowley> I will word it more carefully in the future :)
14:39:23 <soupdragon> what's ord_p infinity for various primes
14:39:39 <soupdragon> I have  ord 2 (7/40 :: Rational) = -3
14:39:43 <edwardk> @pl \f1 f2 f3 x = f1 x . f2 x . f3 x
14:39:46 <edwardk> er
14:39:52 <soupdragon> but I could use  Maybe Rational  with  Nothing denoting infinity
14:39:54 <edwardk> @pl \f1 f2 f3 x -> f1 x . f2 x . f3 x
14:40:09 <edwardk> oh yeah botspammers, lambdabots down
14:40:26 <thaostra> how does cabal hold up to other application-level package managers like rubygems, cpan or easy install?
14:40:41 <monochrom> too bad lambdabot is down. "it would be silly to judge something by the name" great quote.
14:41:02 <acowley> It's close to an applicative but it's something like undefined <$> f1 <*> f2 <*> f3
14:41:11 <edwardk> thaostra: i prefer cpan in some ways, but its pretty powerful. the difference for me is i start virtually every project with a cabal file, while with cpan i package as an afterthought
14:41:15 <soupdragon> liftM3 (((.) . (.)) (.))
14:41:20 <ksf> it holds up very, very well wrt. dependency resolution, and fails abysmally at managing (no uninstall, no automatic upgrade)
14:41:22 <soupdragon> no that's wrong
14:41:42 <edwardk> thaostra: it is also pretty good at dealing with multiple simultaneously installed versions of different libraries
14:41:58 <acowley> thaostra: I've been really happy with cabal for large projects
14:43:02 <ksf> it should definitely be extended to track installed files itself, incl. sandboxing
14:43:10 <acowley> thaostra: I'm less sure about build-hooks as I've only recently started something that will need to do something more complicated at compile time, and the off-the-main-road parts of cabal seem to be less well documented
14:43:26 <ksf> oh, and be able to track executables
14:43:49 <asdfwef> what are some large working haskell apps?
14:44:07 <thaostra> xmonad, ghci, darcs.
14:44:17 <thaostra> *ghc/ghci
14:44:18 <ksf> basically, convince the next guy who wants to do a distro to use haskell.
14:44:42 <thaostra> eh distros are the last thing we need
14:44:48 <edwardk> acowley: build hooks are fine even if the import requirements are insane
14:44:50 <asdfwef> haskell OS!
14:45:00 <ksf> asdfwef, it's called house.
14:45:07 <thaostra> i have tried house. it leaves much to be desired
14:45:28 <edwardk> asdfwef: my understanding is that some of the galois guys have haskell running on bare metal, plus there is at least one verified microkernel modeled in haskell
14:45:53 <thaostra> although these are just research ventures to be sure. 
14:45:53 <asdfwef> what is galois?
14:46:09 <edwardk> http://www.galois.com/ 
14:47:31 <thaostra> anyone else have a bad experience with house?
14:47:53 <edwardk> thaostra well, if you get foreclosed, you can always try car
14:47:55 <technogeeky> he's my favorite TV doctor
14:47:57 <acowley> edwardk: I couldn't find simple examples of custom Setup.hs files. I may have just failed to look in the right places, but pages like http://hackage.haskell.org/packages/archive/Cabal/1.8.0.6/doc/html/Distribution-Simple.html are pretty daunting
14:48:09 <thaostra> haha bad joke is bad
14:48:09 <edwardk> acowley: well, let me show you one of mine
14:48:17 <Phyx-> > id 
14:48:23 <Phyx-> still dead
14:48:41 <edwardk> acowley: http://github.com/ekmett/speculation/blob/master/Setup.lhs
14:48:42 <burp> @botsnack
14:48:54 <soupdragon> does anyone here know how to prove fermats last theorem for n=3 using elliptic curves?? (becaue #math is ignoring me)
14:49:11 <thaostra> but seriously, anyone try using house (the os)?
14:49:18 <asdfwef> openbsd here
14:49:28 <thaostra> why do you keep saying that..
14:49:30 <soupdragon> openbsd isn't house
14:49:33 <soupdragon> FYI
14:49:41 <acowley> edwardk: thank you, that's a very helpful example
14:50:05 <acowley> I've been putting together a real version of the code that Gershom came up with for me at HacPhi
14:50:09 <asdfwef> with house can you surf the web?
14:50:12 <johnw> Has anyone gotten MissingH to build with 6.12.3?  I get conflicting dependencies for random
14:50:14 <edwardk> thaostra: "Cubum autem in duos cubos, aut quadratoquadratum in duos quadratoquadratos, et generaliter nullam in infinitum ultra quadratum potestatem in duos eiusdem nominis fas est dividere cuius rei demonstrationem mirabilem sane detexi. Hanc dialog box exiguitas non caperet."
14:50:17 <acowley> and the build system for it will require some environment poking
14:50:20 <johnw> (with cabal install MissingH)
14:50:35 <edwardk> er sorry that was for soupdragon
14:50:41 <thaostra> lern 2 english =P
14:50:42 <Phyx-> @where gtk2js
14:50:44 <edwardk> i hope it didn't get cut off
14:50:45 <soupdragon> lol
14:50:59 <soupdragon> dialog box??
14:51:06 <edwardk> (i'm using web chat) =)
14:51:27 <thaostra> i don't think house has a browser, but there is some sort of network stack on there. don't ask me exactly how D:
14:51:41 <Phyx-> meh, no windows build for gtk2hs
14:51:44 <edwardk> soupdragon: is not exactly a margin ;)
14:52:13 <thaostra> i can't even figure out how to _close_ windows in house
14:52:42 <ksf> that's not what house is about
14:52:49 <monochrom> hahaha
14:53:04 <Phyx-> thaostra: have a link to it?
14:53:05 <thaostra> so it's supposed to be all one big bad pun?
14:53:14 <ksf> nope, not at all.
14:53:16 <ksf> read the paper
14:53:16 <thaostra> just google house os..
14:53:24 <Phyx-> gee thanks
14:53:39 <thaostra> i have at one point, but i don't remember the details
14:53:40 <ksf> it's about how to build an os in haskell, not about windowing systems
14:53:55 <ksf> kernel, driver interface, memory safety, etc.
14:54:06 <thaostra> of course, it's not meant to be usable. thanks research guys -_-
14:54:12 <ksf> also, most importantly, running foreign binaries safely, which no functional os did before.
14:54:23 <ksf> thaostra, use the source.
14:54:41 <ksf> you've got a framebuffer and haskell, what do you need more?
14:55:06 <drhodes> is it possible to *not define functions*, but only their signatures, and just run the type checker for consistency?
14:55:06 <thaostra> a terrible one, to be sure
14:55:09 <monochrom> there is no point making house usable. even BeOS was made more than usable --- royally efficient in media playing etc --- and still no one use it now.
14:55:23 <soupdragon> drhodes write f :: type here ; f = f
14:55:31 <ksf> practically speaking, posix and foreign driver support would be important
14:55:35 * ddarius would recommend f = undefined rather than f = f.
14:55:43 <drhodes> soupdragon: great, super, thanks!
14:55:49 <monochrom> so the remaining goal worth anyone's time is to demonstrate how to write code so the popular OSes may adopt the same method.
14:55:50 <soupdragon> drhodes and if you just want to check if a type is well kinded you can use :k
14:56:01 <ksf> that is, source-level compability to linux and *bsd drivers or something.
14:56:13 <drhodes> neat, thanks soupdragon 
14:56:17 <ksf> monochrom, there's haiku
14:56:20 <hpc> i like that f=undefined trick
14:56:22 <soupdragon> ddarius why ?
14:56:26 <ksf> ...doing that was no small feat.
14:56:37 <wli> Um, Linux isn't source-compatible with itself across versions.
14:56:38 <thaostra> there's also hobby oses like react and kolibri
14:56:49 <ddarius> soupdragon: Because if you do forget to implement it you get an exception rather than an infinite loop.
14:57:25 <ksf> wli, what about running a full linux as a process linux that has device access?
14:57:31 <asdfwef> if I could get openssh and a web browser I would switch to haskell os
14:57:43 <ksf> ...what I want to say is that I'd want to use nuveau.
14:58:03 <asdfwef> I wish unix was more declarative
14:58:15 <ksf> I've sat long enough in front of an ultrasparc 1 to know how painful a slow framebuffer is.
14:58:23 <dolio> f = f will become an exception, most likely.
14:58:26 <asdfwef> like I want x and y and z and then restart some master process and bam
14:58:31 <wli> ksf: Might work.
14:58:33 <thaostra> if we had superior kernel architectures i would gladly use oses with them
14:58:33 <ddarius> dolio: Depends on the flags.
14:58:36 <asdfwef> could haskell rest on top of linux? and do such?
14:58:41 <ddarius> dolio: undefined will become an exception certainly
14:58:46 <bos> Cale: this is where your separate function sent me: http://www.serpentine.com/blog/2010/07/02/whats-in-a-find-function/
14:58:52 <asdfwef> like abstract over linux?
14:59:11 <sproingie> you can go one level further, there are operating systems written in haskell
14:59:12 <hpc> running "let f=f in f" in ghci leads to an infinite loop
14:59:18 <ksf> another idea would be to just use linux and run the rts directly on top of it.
14:59:27 <ksf> that is, get the userspace working.
14:59:28 <dolio> error is probably a better choice, with a string that will tell you where the exception is coming from.
14:59:28 <asdfwef> ya i think they dont have web browser adn openssh
14:59:29 <sproingie> a haskell OS using linux "as the bios" would be a nice effort
14:59:36 <sproingie> but no one's found it interesting enough to do
14:59:40 <asdfwef> hm
14:59:50 <asdfwef> if it made netowrking and services much easier
14:59:54 <asdfwef> i would take over
14:59:56 <ksf> it shouldn't be that hard to port the rts to bare system calls
15:00:03 <sproingie> haskell doesn't exactly make things easier ;)
15:00:09 <thaostra> how does one create a bootloader in haskell? it seems impossible to do low level stuff like that
15:00:14 <sproingie> ksf: sure, but it'd probably end up slower
15:00:18 <Twey> thaostra: Why?
15:00:41 <thaostra> because then we wouldn't be relying on imperative langs to load into our precious haskell oses
15:00:43 <c_wraith> Hmm.  my lambdabot isn't cleaning up after itself properly when it kills a long-running request.  What am I missing?
15:01:01 <ksf> I heard that basically all the rts uses (by itself) is malloc and possibly pthread_*
15:01:01 <ddarius> Cale, bos: separate is "toZippers" ?
15:01:03 <lispy> c_wraith: nothing
15:01:04 <sproingie> thaostra: the haskell RTS is unlikely to fit in a bootloader.  you'd write haskell that produced assembly for the bootloader
15:01:17 <lispy> c_wraith: gwern/Cale were talking about that deficiency just recently
15:01:19 <bos> ddarius: yeah
15:01:22 <ksf> write, read, open, close for basic IO
15:01:32 <c_wraith> lispy: good to know it's not me, I guess?
15:01:45 <lispy> c_wraith: submit patches :)
15:01:51 <sproingie> you're going to be stuck with a lot of C no matter what, because proprietary drivers require all kinds of C infrastructure
15:01:54 <thaostra> but there are space constraints with the bootloader, no?
15:01:57 <bos> sproingie: at least galois has ghc running on xen
15:02:10 <Twey> thaostra: That's just a matter of efficient compilation
15:02:36 <Twey> thaostra: It all winds up as machine code in the end
15:02:37 <monochrom> if you don't try to write a new OS at 20, you have no heart. if you try to write a new OS at 40, you have no brain.
15:02:41 <Cale> c_wraith: I think gwern patched mueval so it does a better job of cleanup
15:02:50 <thaostra> okay, how efficient are they then?
15:02:53 <pizza_> heh
15:02:54 <Cale> c_wraith: Maybe check that you have the latest version.
15:02:58 <Twey> There's not much difference between machine code generated from C and machine-code generated from Haskell
15:02:58 <sproingie> @remember monochrom if you don't try to write a new OS at 20, you have no heart. if you try to write a new OS at 40, you have no brain.
15:03:00 <c_wraith> Cale: I just grabbed it today...
15:03:02 <Twey> (necessarily)
15:03:11 <sproingie> ENOLAMBDABOT
15:03:12 <Twey> thaostra: GHC is pretty efficient.
15:03:16 <monochrom> too bad no bot is here to remember
15:03:17 <Cale> c_wraith: all right, I have no idea :)
15:03:25 <thaostra> eh okay
15:04:01 <Cale> sproingie: Not just FFI? :)
15:04:11 <monochrom> anyway that is my answer to the braindead accusation against house researchers
15:04:22 <Cale> oh
15:04:31 <ddarius> monochrom: Gwern will go crazy later anyway
15:04:47 <Cale> I will bring lambdabot back :)
15:05:00 <monochrom> or researchers in general
15:05:02 <sproingie> thankfully C chose a nicer convention as stack cleanup went
15:05:05 <Cale> looks like its screen died again... not sure why
15:05:07 <thaostra> what are you talking about monochrom
15:05:09 <sproingie> you can defer popping as long as you like
15:05:19 <Eiler> usually there are multi stage bootloaders and it is only the first real bootloader that got a limit in size, not the second stage
15:05:22 <ddarius> If you want to make an operating system to compete with Linux, Windows, etc. if you start at 20 you'll still be at it and failing at 40.
15:05:31 <Twey> Heheh.
15:05:47 <ksf> at the age of 20, I slurped and grokked "modern operating systems" and then failed the exam because I could'nt give those exact braindead definitions the lecturer required.
15:06:05 <ksf> I think that somehow put me off OSs...
15:06:10 <sproingie> but drivers like nvidia and ATI still require monstrosities like X, and i'm not sure how much you can really fake it
15:06:26 <ksf> anyway, tannenbaum has written a new minix version, with focus on realiability.
15:06:37 <monochrom> Yes, I was tired of the name game too, but the course also had cool algorithms and data structures.
15:06:38 <sproingie> yay we can ignore that one too
15:07:08 <Twey> ksf: I want an Inferno/NixOS cross.  â˜¹
15:07:13 <pizza_> OSes are old hat, how about a nice Haskell botnet :-P
15:07:17 <soupdragon> wow
15:07:17 <Twey> NixOS-style package management on an Inferno core.
15:07:20 <edwardk> ksf: wake me when he gets to installability ;) http://wiki.minix3.org/en/UsersGuide/DoingInstallation
15:07:26 <soupdragon> it takes 4 queens to cover a chessboard
15:07:32 <soupdragon> i mean 5
15:07:33 <ksf> Twey, there's even more stuff that should be more declerative in unix
15:07:35 <soupdragon> but there's on 2 queens on chess??
15:07:36 <ksf> like runlevels
15:07:49 <sproingie> has he added fancy dancy features, like oh, virtual memory to minix3 yet?
15:08:06 <thaostra> monolithic and microkernels are so 20th century
15:08:12 <mauke> soupdragon: with an option to upgrade to 18
15:08:21 <ksf> edwardk, the important part is "running on qemu"
15:08:29 <Twey> ksf: Doesn't NixOS make those declarative?
15:08:45 <ksf> dunno
15:08:46 <Twey> I think it's all part of the big system Nix expression.
15:08:56 <edwardk> ksf: yeah
15:09:22 <ksf> we already have a tcp implementation, though, that surprised me.
15:09:31 <ddarius> Exokernels ho!
15:09:44 <thaostra> they are good, but there just isn't much knowledge on them
15:10:00 <thaostra> i hope something like cheetah will become big though
15:10:41 <thaostra> and this is where you research guys come in..so get to it
15:10:46 <edwardk> Twey: the inferno/plan9 culture seems to have this bizarre dismissive 'hah well we thought of that in the 70s' mentality in the culture that really seems counterproductive. i'll stick to nixos on linux. ;)
15:11:18 <Twey> edwardk: I'm confused by this statement â€” they *did* think of it in the '70s :Ã¾
15:11:49 <edwardk> Twey: the problem is that it causes them to fail to see any nuances in any idea that has progressed or evolved further since then
15:11:50 <ddarius> Twey: Just because it's true doesn't mean it's useful.
15:11:55 <bos> why anybody cares about kernels at all any more is profoundly beyond me.
15:12:06 <Twey> edwardk: Ah, I see
15:12:11 <Twey> edwardk: In Inferno too?
15:12:24 <Twey> bos: Because all these fancy new-fangled systems need to run on something :Ã¾
15:12:26 <thaostra> because like people have said, monolithic and microkernels are SO 20th century. so change would be nice
15:12:28 <bos> they get far more attention than they deserve, for such an immensely boring solved problem.
15:12:32 <edwardk> Twey: in my experience at least, but i may have a biased sample
15:12:48 <Twey> bos: It's not really a solved problem, since kernels still crash
15:13:00 <ddarius> bos: You should read Dawson Engler's PhD thesis on Xok.
15:13:02 <bos> Twey: it's solved enough.
15:13:36 * bos has spent enough time in the kernel hacking salt mines, thanks
15:13:37 <dafis> Cale: if I had a dollar for every time I've implemented select, I could feast on pizza for at least two days :)
15:13:39 <thaostra> there's no such thing as enough..kernels will still crash
15:13:49 <monochrom> yeah yeah yeah, types are so 20th century
15:13:52 <ddarius> bos: Have you read Engler's PhD thesis?
15:13:52 <Ke> bos: i guess everything else is solved enough as well
15:14:12 <Twey> No program is truly â€˜solvedâ€™ until it never crashes and runs in zero space and zero time.  ;)
15:14:13 <edwardk> i'm off. going to go home and hack on luthor
15:14:36 <bos> ddarius: yes
15:14:43 <lispy> Twey: So, I would think that by your reasoning it's drivers that are not yet solved
15:14:57 <ddarius> bos: A lot of the ideas in it are generally applicable.
15:15:25 <bos> ddarius: true
15:15:52 <Twey> lispy: Because the kernel of the kernel (haha) is rock-solid and infinitely small and fast?
15:16:12 <Twey> lispy: Surely if that were the case it would be able to reboot a broken driver or two, instead of panicking.
15:16:15 <monochrom> I'm happy enough with O(1)
15:16:35 <Twey> monochrom: Depends on your constant
15:16:47 <thaostra> not running drivers in kernel space?
15:16:55 <c_wraith> my constant is the lifespan of the universe.
15:16:57 <monochrom> I'm happy with all constants.
15:17:13 <lispy> Twey: My point is just that kernels (windows, linux in particular) are dramatically more robust than their collection of driver
15:18:05 <Twey> lispy: But still not a solved problem
15:18:22 <Twey> monochrom: Even if it resulted in being unable to run it on contemporary hardware?
15:18:51 <monochrom> yes
15:18:54 <lispy> Twey: the L4 kernel doesn't "go wrong" FSOV of wrong, right?
15:19:12 <lispy> FSVO*
15:19:38 <Twey> AIUI
15:20:05 <ksf> wait the H monad _is_ an exokernel.
15:20:12 * hackagebot gd 3000.5.0 - A Haskell binding to a subset of the GD graphics library  http://hackage.haskell.org/package/gd-3000.5.0 (ChrisDone)
15:21:37 <Twey> Ick.  Half the links on the haskellwiki are broken.
15:21:38 <chrisdone> BMeph: did you get your voice back?
15:21:51 <chrisdone> Twey: fixers gonna fix?
15:22:06 <Twey> Needs some doc redirects pe'i
15:22:57 <chrisdone> BMeph posted about an hour ago on the mailing list that he doesn't have voice in here
15:23:11 <chrisdone> i can't remember how to view the status of people in irc
15:23:15 <soupdragon> edwardk didn't have voice
15:23:28 <soupdragon> but that got fixed
15:23:30 <soupdragon> @ops
15:23:30 <lambdabot> Maybe you meant: docs oeis pl
15:23:30 --- mode: ChanServ set +o mauke
15:23:31 <chrisdone> are we in +m atm?
15:23:45 <soupdragon> +mauke
15:24:27 <chrisdone> mauke: can you voice BMeph?
15:24:34 <mauke> I thought I just did
15:24:59 <chrisdone> oh, i didn't get a notification or anything
15:25:00 <chrisdone> cool
15:25:21 <mauke> BMeph: CAN YOU HEAR ME?
15:25:32 <BMeph> mauke: Yes, I can
15:25:40 <mauke> operation successful
15:25:48 <BMeph> ...and now, you can see my response - Thank you! :)
15:26:19 <mauke> all webchat connections are silenced by default because of spambots
15:26:28 <mauke> specific accounts can be whitelisted
15:27:39 <BMeph> Nice timing - I'm about to leave for the (3-day) weekend, now. At least, I can tell the folks that they're "DOIN IT RONG!" on Tuesday. Thanks again... :)
15:28:34 --- mode: mauke set -o mauke
15:28:52 --- mode: ChanServ set +o mauke
15:28:58 <mauke> ah, much better
15:29:52 <soupdragon> mauke http://i.imgur.com/6mlIV.jpg
15:30:07 <chrisdone> hahaha
15:30:37 <mauke> :3
15:30:52 --- mode: mauke set -o mauke
15:42:12 <thaostra> well it was fun talking to you guys
15:42:21 <MasseR> On http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html there's a "simple microbenchmark" using string io. I then implemented a similar test with bytestrings which is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26818#a26818 what I'm concerned is the 'extract' function. Is there another way (preferred) to extract the Int, or is using readInt "the wrong way"?
15:42:42 <thaostra> i shall go now
15:42:46 <soupdragon> byn
15:49:26 <dpratt71> hmm
15:49:46 <dpratt71> uncharictaristically quiet around here
15:50:17 <Veinor> I know!
15:50:29 * pizza_ bumps into a huge pile of stacked champagne glasses
15:50:33 <Zao> Maybe we've managed to avoid success after all?
15:50:55 <dpratt71> anyone around willing to be critical? http://www.danielgpratt.com/2010/07/monads-as-i-have-known-them.html
15:50:59 <Veinor> MasseR: extract = fst . fromJust ?
15:51:50 <Veinor> yeah, I think that's right
15:51:56 <Veinor> @pl \(Just (a,_)) -> a
15:51:56 <lambdabot> (line 1, column 8):
15:51:56 <lambdabot> unexpected "("
15:51:56 <lambdabot> expecting operator or ")"
15:52:24 * ddarius is always willing to be critical, but he needs to get his laundry right now.
15:52:31 <Veinor> :(
15:54:45 <Iago> dpratt71, are you trying to explain what is a monad from your understanding ?
15:55:38 <ivanm> in case anyone missed it, you can apparently pre-order LYAH as an ebook for half price: http://nostarch.com/lyah.htm
15:55:42 <dpratt71> Iago: I wouldn't say I was trying to be so ambitious as to explain monads, just offer a bit of insight
15:56:06 <augur> hello all
15:56:10 <augur> hows life in haskell land
15:56:14 <c_wraith> I've learned how to explain monads.  "Ignore the strange word.  Learn to use the API you need."
15:56:25 <Iago> IMHO Cale Gibbard get it, http://www.haskell.org/haskellwiki/Monads_as_computation
15:57:29 <Iago> when I have to explain someone what a monad is, I just redirect her/him to Cale's explanation
15:57:38 <ivanm> @google monad burrito
15:57:38 <monochrom> haha
15:57:39 <lambdabot> No Result Found.
15:58:02 <ivanm> Iago: IMHO, byorgey gets it: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
15:58:12 <wli> YAHT's monad transformer stack affair did it for me
15:58:12 <augur> there may not be monad burrito, but is there a burrito monad?
15:58:16 <augur> @google burrito monad
15:58:19 <lambdabot> No Result Found.
15:58:28 <wli> What, no monad tutorial writing combinators?
15:58:28 <augur> now that's a shame
15:58:29 <Iago> dpratt71, I think your attempt is more confused
15:58:43 <monochrom> IMHO no one gets it. http://no.one.gets.it/
15:58:47 <Iago> but it is just my opinion
15:58:49 <tensorpudding> @pl \is (t:ts) -> (is,t,ts)
15:58:50 <lambdabot> (`ap` tail) . (. head) . (,,)
15:58:53 <wli> (presumably monadic ones at that)
15:59:33 <ivanm> wli: well, dibblego had a parser tutorial where you wrote your own parser monad...
15:59:37 <soupdragon> Forbidden
15:59:38 <soupdragon> You don't have permission to access / on this server.
15:59:39 <dpratt71> Iago: I appreciate your opinion, but I would also appreciate some more specific feedback, if you had any
15:59:55 <acowley> @pl \f1 f2 f3 x -> f1 x . f2 x . f3 x
15:59:55 <lambdabot> (. liftM2 (.)) . (.) . liftM2 (.)
15:59:58 <acowley> ugh
16:00:04 <Iago> dpratt71, for example, "There is a way to take an ordinary, non-monadic value and promote it or contain it as a monadic value."
16:00:18 <Iago> from Cale's explanation, Monad = computation with effects
16:00:34 <wli> ivanm: Not sure what kind of randomized natural language processing/generation is needed to randomly generate monad tutorials.
16:00:55 <Iago> you say "you can inject a pure value inside the computation"
16:01:01 <ivanm> there's an idea; maybe we could specialise one of those random paper generating apps...
16:01:25 <seric> dancor: are you here? I need your help ;)
16:01:26 <Iago> well I dunno, it could depends on who is the reader
16:02:22 <dpratt71> ivanm, et al: just to be clear, I'm not trying to write a tutorial, just talk about Monads (hopefully with some accuracy) :)
16:02:41 <ivanm> heh, fair enough
16:03:24 <chrisdone> okay just join all the channels i was in before nickserv logs me in
16:04:32 <metaliving> do monads abstract computations necessarily?
16:05:01 <dpratt71> Iago: I've read Cale's Monad tutorials along with many others and they are very good, but...also a little inaccessible, I think, for someone with my background
16:05:40 <monochrom> I don't think monads abstract computations necessarily.
16:05:41 <ivanm> huh, simon marlow's new "hello" package on Hackage has a non-existent home page
16:06:06 <metaliving> yeah, that's what i thought
16:06:29 <monochrom> I don't like the word "computation" either.
16:06:36 <MasseR> Veinor: THanks
16:06:43 <monochrom> @quote monochrom computation.*synerg
16:06:44 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
16:07:19 <metaliving> yeah, i wanted to argue against the use of the word computation in describing a monad ("computation with effects")
16:07:53 <bos> dcoutts_: does my find modification match your recollection?
16:08:08 <monochrom> but it's ok if you say "these several specific computations are monads".
16:08:11 <bos> "burrito with effects"
16:08:24 <aristid> what is wrong with "iPod is about coolness"?
16:08:25 <metaliving> dunno, i come from math rather than programming, but it doesn't feel that monads are so arcane and difficult as people make them to be
16:08:30 <aristid> except for its outdatedness
16:08:49 <bos> programmers are completely unused to abstraction, is all.
16:09:14 <metaliving> i mean, there is oop
16:09:36 <monochrom> I suspect programmers barely get by in oop too :)
16:09:39 <bos> oop is barely abstraction at all.
16:09:40 <metaliving> which is some kind of sick (in a bad sense) way of abstracting, but whatever
16:09:42 <ivanm> bos: did dafis end up emailing you about a possible bug in text?
16:09:43 <benmachine> guys what is your favourite subset of the reals
16:09:52 <monochrom> the empty subset
16:09:53 <benmachine> proper, nonempty
16:09:57 <monochrom> none
16:09:58 <benmachine> smartarse :x
16:09:58 <bos> ivanm: yeah, i'd fixed it before he reported it
16:10:02 <ivanm> good-o
16:10:05 <benmachine> :P
16:11:26 <dpratt71> monochrom: yeah, I found it quite amusing that a recent .NET UG meeting I attented turned out to be a presentation on the nature of 'virtual' methods
16:11:33 <mauke> I LIEK PI
16:11:54 <ivanm> mauke: I take it you haven't joined the new tau movement then?
16:12:09 <mauke> > 0.5 + sqrt 1.25
16:12:10 <lambdabot>   1.618033988749895
16:12:20 <dafis> ivanm: yes, and it turned out, he had fixed that one a while ago, just hadn't made a new release (did today)
16:12:34 <ivanm> dafis: heh
16:13:19 <Iago> ivanm, well, if I have to explain someone what is a monad in FP, and I have to choose between a) category theory book b) Cale's explanation c) suggest him to play with monads 1 week
16:13:25 <Iago> I think b) is the best option
16:14:04 <Iago> b) gives you a particular "view", but a particular "view" that is very general I think
16:14:05 <Iago> :P
16:14:07 <ivanm> I think d) give him a tutorial on how to use IO and forget about monads to start with
16:14:21 <ivanm> and then you introduce monads to them as the actual type class
16:14:26 <ivanm> forget the CT, etc.
16:15:15 <benmachine> e) all of the above
16:17:07 <metaliving> but introduce IO monads in a way that would make the reason behind using them clear
16:17:18 <metaliving> or somewhat clear
16:18:12 <McManiaC> anyone with gtk2hs experience available? I cant figure out how to show a list in a treeview :S
16:18:51 <ski> (mauke : <http://tauday.com/> :)
16:19:46 <aristid> how about showing the IO monad, and showing other monad-like things, and then later introducing how to morph that all into monadic code?
16:21:22 <ski> @remember monochrom if you don't try to write a new OS at 20, you have no heart. if you try to write a new OS at 40, you have no brain.
16:21:23 <lambdabot> I will never forget.
16:22:19 <metaliving> or showing how lists and the IO can be brought together under a common abstraction
16:22:22 <kniu> why have `map' if there's `fmap'?
16:22:56 <kniu> Coincidentally, I'm 20 and will be taking Operating Systems next semester.
16:22:56 <ivanm> kniu: map predated fmap
16:23:01 <benmachine> can make your intention a little more obvious
16:23:04 <dafis> kniu: history or not confusing beginners with the Functor class
16:23:20 <benmachine> you read "map" in the code, you know immediately the second argument's a list
16:23:27 <Cale> Iago: Which of my explanations? :)
16:23:28 <ski> benmachine : the reals whose square is zero
16:23:31 <ivanm> dafis: which is why I dno't like Caleskell, etc. defaulting map = fmap (and (.) = fmap)
16:23:33 <benmachine> ski: :O
16:23:35 <aristid> map can also help the type inference in some cases, by telling the compiler it's a list and not an unknown functor:)
16:23:43 <ddarius> Mathematicians just don't appreciate coalgebra.
16:23:49 <benmachine> ski: sneaky
16:23:54 <tensorpudding> @type flip
16:23:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:23:59 <aristid> :t (+1) . [1,2,3]
16:24:00 <lambdabot> forall a. (Num a) => [a]
16:24:01 <dafis> ivanm: yeah, (.) = fmap is pretty awkward
16:24:04 <aristid> > (+1) . [1,2,3]
16:24:05 <lambdabot>   [2,3,4]
16:24:09 <tensorpudding> I dislike what was done to flip
16:24:11 <ski> (benmachine : see Synthetic Differential Geometry for details)
16:24:16 <aristid> :t flip
16:24:16 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:24:28 <ski> tensorpudding : i'm to blame
16:24:28 <ivanm> tensorpudding: that one too
16:24:32 <Iago> Cale, the monads as computation one
16:24:35 <Cale> dafis: You think so?
16:24:37 <ivanm> ski: grrrrr.....
16:24:38 <soupdragon> wats wrong with flpi
16:24:47 <kniu> :t (.)
16:24:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:24:49 <kniu> :t fmap
16:24:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:24:59 <dafis> Cale: yes, I do
16:25:12 <Cale> dafis: Could you elaborate on why?
16:25:15 <ski> ivanm : i take you're not a fan ?
16:25:20 <soupdragon> ski dx^2 = 0 -> ~~dx = 0
16:25:28 <ddarius> ski: SDG doesn't use the reals though.
16:25:39 <soupdragon> not the "real reals
16:25:39 <ski> it uses "reals"
16:25:41 <soupdragon> lol
16:25:42 <ivanm> ski: nope
16:25:48 <benmachine> ""
16:25:50 <dafis> Cale: for example because it's not how GHC sees it
16:25:56 <Cale> I think that (.) makes a great name for fmap, especially as it's so common.
16:26:08 <Cale> and fmap is a proper generalisation of composition
16:26:25 <Cale> and the associativity of (.) is essentially the functor composition law
16:26:52 <ivanm> Cale: except it makes type signatures a whole lot harder to comprehend
16:26:53 <benmachine> fmap is *a* proper generalisation of composition
16:26:56 <dafis> Cale: true, but some consistency isn't necessarily a bad thing
16:26:58 <benmachine> 'snot the only one :P
16:27:02 <Cale> That is, in order to be a functor, we need  fmap (f . g) x = fmap f (fmap g x)
16:27:16 <ivanm> Cale: that's like saying why should we define sum when it's just a specialisation of a fold, etc.
16:27:21 <ivanm> OK, not _quite_ the same, but still
16:27:22 <Cale> which if you write it in terms of (.) entirely, is simply (f . g) . x = f . (g . x)
16:27:38 <soupdragon> that's really neat
16:27:48 <Cale> benmachine: But there's no other one which is really well-understood.
16:27:59 <McManiaC> > let (.) = fmap in Just . (return 5 :: Maybe Int)
16:28:00 <lambdabot>   Just (Just 5)
16:28:02 <benmachine> Cale: not a fan of Control.Category?
16:28:08 <Iago> the containers one is worse :P
16:28:14 <Cale> It's not that I altogether dislike Control.Category
16:28:25 <Cale> I just wish I knew what the heck it was, theoretically.
16:28:27 <aristid> :t (<<<)
16:28:27 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
16:28:28 <benmachine> heh
16:28:34 <McManiaC> > Just . (retun 5 :: Maybe Int)
16:28:35 <lambdabot>   Not in scope: `retun'
16:28:39 <McManiaC> > Just . (return 5 :: Maybe Int)
16:28:39 <benmachine> I guess it'd be pretty har dto argue that it's half as useful as fmap
16:28:40 <lambdabot>   Just (Just 5)
16:28:46 <kniu> which module is this `(.) = fmap' in?
16:28:53 <benmachine> but then, we do kinda already have names for fmap
16:28:55 <dafis> Cale: also, it's awkward when you want to show a type to a beginner and then an unmotivated (at that stage) Functor constraint shows up
16:29:00 <benmachine> :t (<$>)
16:29:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:29:02 <benmachine> etc.
16:29:04 <ivanm> Cale: edwardk is splitting it up
16:29:11 <ivanm> because he's realised it's too big and unweildy
16:29:15 <benmachine> kniu: in lambdabotland
16:29:21 <ddarius> ivanm: Control.Category /= category-extras
16:29:26 <ivanm> oh, whoops
16:29:29 <ivanm> my mistake
16:29:37 <kniu> benmachine, seriously?
16:29:43 * BMeph frequently redefines sum/product in terms of foldl'. Just saying...
16:29:47 <Cale> Control.Category defines a class that looks something like the definition of a category
16:29:50 <benmachine> kniu: it's something that only lambdabot has, unless you define it yourself
16:29:53 <aristid> BMeph: why?
16:30:02 <Cale> class Category (~>) where
16:30:08 <Cale>   id :: a ~> a
16:30:24 <Cale>   (.) :: (b ~> c) -> (a ~> b) -> (a ~> c)
16:30:24 <ddarius> Category is a reasonable rendition of a category into Haskell.  It's certainly does not allow the most general notions of category.  It's at least vaguely like a concrete category.
16:30:29 <BMeph> aristid: 3) ??? ("fun") 4) ...
16:30:56 <aristid> BMeph: ?
16:30:58 <elliottt> does anyone here have much familiarity with the new ghc build system?
16:31:02 <Cale> The thing which gets me is that this means that the definitions of (.) and id are required to be natural transformations in a peculiar way
16:31:02 <ski> (ivanm : btw, note that i agree mostly with the critisism of Caleskell `(.)',`flip' re newbies .. i just mentioned `flip' to Cale as a companion to `(.)' .. sortof to stir the waters, i suppose you could say)
16:31:09 <Cale> that I don't really understand the implications of
16:31:33 <ivanm> ski: so your attempt backfired?
16:31:36 <ski> ddarius : concrete over Hask ?
16:31:40 <BMeph> aristid: "Why (do I redefine sum/product)?" -- > For fun and PROFIT!
16:31:44 <ddarius> ski: Yes.
16:31:47 <ski> ivanm : backfired, how ?
16:32:07 <wli> I say do the right thing and the newbies will just have to deal with it.
16:32:11 <ski> ddarius : how is the underlying functor expressed ?
16:32:11 <kniu> I'm liking this.
16:32:19 <Cale> I thought ski's flip would be worth experimenting with, at least in lambdabot :)
16:32:23 <ivanm> well, you dislike Caleskell, but because of something you said the invidious spread of Caleskell took over more of Haskell-land!
16:32:23 <benmachine> wli: there's no Right Thing, it's an aesthetic choice
16:32:24 <kniu> using (.) as fmap is saving me a lot of parentheses.
16:32:43 <benmachine> kniu: Control.Applicative has <$> for the same thing, more characters though
16:32:56 <aristid> BMeph: yay PROFIT
16:33:01 <ddarius> ski: Essentially identity on objects and an injection on arrows.  I haven't really thought it all through yet.
16:33:32 <Cale> I think Control.Applicative's <$> should stay there, for use alongside <*>, and with low precedence like it currently has.
16:33:43 <McManiaC> wtf is Caleskell?
16:34:01 <Cale> McManiaC: It's people's crazy name for the few little local definitions that are present in lambdabot
16:34:03 <dafis> McManiaC, mother tongue of lambdabot
16:34:08 <ski> ivanm : i like the idea of playing with generalization .. that said, i don't particularly like Caleskell `(.)' .. still, thinking my `flip' suggestion was in the same vain, i thought it should be considered next to `(.)', even if i happen not to personally like it
16:34:15 <tensorpudding> lambdabot has some functions given special definitions
16:34:18 <Cale> I'm not sure why they want to call it as if it's a different language altogether :P
16:34:44 <McManiaC> hm hm
16:34:54 <tensorpudding> cabbageskel
16:35:09 <ski> ddarius : i'm just not seeing `(a ~> b) -> (a -> b)' ..
16:35:50 <kniu> what's (~>)?
16:35:52 <ivanm> Cale: because it's a convenient label to explain to people why things like flip, etc. have a completely different meaning than what they'd expect in here
16:36:00 <ski> kniu : a type variable
16:36:06 <benmachine> kniu: there's a GHC extension that allows infix type variables
16:36:12 <kniu> oh
16:36:14 <Cale> ivanm: How about just calling it lambdabot :)
16:36:18 <kniu> :t flip
16:36:19 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:36:25 <kniu> wow.
16:36:35 <Cale> (e ->) is a functor
16:36:43 <benmachine> ooi, has anyone done anything clever with functor-flip?
16:36:52 <ivanm> Cale: sure, blame poor ol' defenceless lambdabot...
16:36:53 <Cale> So the usual type of flip is recovered by replacing f with e ->
16:36:58 <ski> @instances Functor
16:36:59 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:37:12 <ski> `(w,)' is also a functor
16:37:18 <kniu> This is trippy.
16:37:24 <benmachine> > flip (Just id) 5
16:37:25 <lambdabot>   Just 5
16:37:37 <benmachine> it's like ap but weedier
16:37:48 <McManiaC> wtf
16:37:52 <ski> .. there might be similar generalizations as replacing `(r ->)' with any functor `f', for `(w,)'
16:38:09 <Cale> I'm not sure I like the generalisation of flip or not
16:38:15 * ski grins
16:38:18 <Cale> But I figured I'd put it in and let people experiment with it
16:38:38 <Cale> and hopefully someone would find something cool which would justify it further :)
16:38:42 <McManiaC> :t flip
16:38:43 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:38:43 <chrisdon`> i wonder what percentage of haskell newbies come asking for how to do printfs (and get shown Debug.Trace)
16:39:01 <ddarius> ski: Bah, let's just say it's an internal category in Set.
16:39:07 <ddarius> or s/Set/Hask
16:39:10 <Twey> chrisdon`: 0
16:39:17 <lispy> We don't have an iCalendar parser in Haskell do we?
16:39:19 <ski> ddarius : i could go with that :)
16:39:23 <Cale> I think that learning about functors is an essential part of being a beginner Haskell programmer, and I don't think we should mind exposing them.
16:39:24 <chrisdon`> (where `printfs' = debugging by inserting print statements)
16:39:35 <Twey> printf-seekers are usually recommended Text.Printf or Text.Printf.TH
16:39:40 <Twey> Ah
16:39:40 <McManiaC> > flip (+) 5 3
16:39:41 <lambdabot>   8
16:39:52 <Cale> > flip (-) 5 3
16:39:53 <lambdabot>   -2
16:39:54 <monochrom> chrisdon`: it has happened but very rare. I guess once a year.
16:40:08 <Twey> > subtract 5 3
16:40:09 <lambdabot>   -2
16:40:14 <ddarius> :t curry
16:40:15 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:40:19 <McManiaC> :t (+)
16:40:19 <lambdabot> forall a. (Num a) => a -> a -> a
16:40:33 <McManiaC> how is "a -> a -> a" similiar to "f (a -> b)"?
16:40:49 <Cale> There's a tinge of irony that 'subtract' has exactly as many characters as 'flip (-)'
16:40:51 <chrisdon`> i've seen it loads of times, enough that i think of it as a predictable newbie trend
16:40:51 <ski> > [sin,cos,tan] `flip` (pi / 2)
16:40:53 <lambdabot>   [1.0,6.123233995736766e-17,1.633123935319537e16]
16:41:14 <ski> McManiaC : replace `f' with `(a ->)'
16:41:27 <dafis> McManiaC, as Cale said before, (e -> ) is a functor
16:41:40 <McManiaC> (a ->) (a -> a) == a -> a -> a ?
16:41:41 <chrisdon`> xb
16:41:45 <McManiaC> wtf
16:41:46 <McManiaC> ok
16:41:47 <McManiaC> :>
16:42:02 <Twey> Is â€˜flip subtractâ€™ always â€˜negate . subtractâ€™?
16:42:06 <Cale> McManiaC: Think of a function from a fixed type e as being like a sort of container, indexed by values of type e
16:42:12 <soupdragon> can you generalize  id ?
16:42:16 <ddarius> negate . subtract is a type error
16:42:20 <ddarius> :t negate . subtract
16:42:21 <lambdabot> forall a. (Num a) => a -> a -> a
16:42:24 <soupdragon> :t flip id
16:42:25 <lambdabot> forall a b. a -> (a -> b) -> b
16:42:31 <Cale> That is, functions of type e -> a are containers indexed by values of type e, containing values of type a
16:42:33 <Twey> ddarius: Is it?
16:42:48 <Cale> function composition then just applies a function to each "element" of such a container
16:42:48 <ski> @type runCont . return
16:42:50 <lambdabot> forall r a. a -> (a -> r) -> r
16:42:50 <Twey> :t (flip subtract, negate . subtract)
16:42:51 <lambdabot> forall a a1. (Num a, Num a1) => (a -> a -> a, a1 -> a1 -> a1)
16:43:14 <ddarius> Twey: There's a Num (a -> a) instance in lambdabot.
16:43:25 <ddarius>  :t negate . subtract in GHCi
16:43:26 <Cale> and flip turns a container of functions into a function of containers :)
16:43:39 <Twey> ddarius: Ah, okay
16:43:55 <Twey> Well, fmap negate . subtract, then â˜º
16:44:03 <McManiaC> wtf
16:44:27 <Cale> (by turning it into the function which, given a value, applies each function in the container to that value)
16:44:37 <Twey> 00:40:25 < Cale> There's a tinge of irony that 'subtract' has exactly as many characters as 'flip (-)'
16:44:53 <kniu> :t (tail .) . break (== ',')
16:44:55 <lambdabot> [Char] -> ([Char], [Char])
16:45:00 <Twey> Cale: Not reallyâ€¦ it's not about brevity, it's about steering well clear of the hideous trainwreck that is Haskell (-)
16:45:04 <ddarius> Until you have to add parens.
16:45:13 <Cale> > flip [id, (+2), (*2), (^2), (2^)] 5
16:45:15 <lambdabot>   [5,7,10,25,32]
16:45:17 <kniu> > (tail .) . break (== ',') $ "a, b"
16:45:18 <lambdabot>   ("a"," b")
16:45:26 <kniu> hm
16:45:38 <Twey> That's a nice bonus, too.
16:45:41 <ddarius> > (length "zipWith (flip (-))", length "zipWith subtract")
16:45:42 <lambdabot>   (18,16)
16:45:44 <Cale> In this specific case, we make flip look a lot like sequence
16:45:53 <kniu> > (tail .) . break (== ',') $ "x"
16:45:55 <lambdabot>   ("x","*Exception: Prelude.tail: empty list
16:46:04 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
16:46:05 <lambdabot>   [5,7,10,25,32]
16:46:13 <Cale> But that's another story really :)
16:46:23 <ddarius> @let c = flip
16:46:24 <lambdabot>  Defined.
16:46:25 <Twey> Hm
16:46:33 <ddarius> :t zipWith (c (-))
16:46:34 <lambdabot>     Ambiguous occurrence `c'
16:46:34 <lambdabot>     It could refer to either `L.c', defined at <local>:5:0
16:46:34 <lambdabot>                           or `SimpleReflect.c', imported from SimpleReflect at State/L.hs:73:0-32
16:46:36 <Twey> sequence is not a special case of generalised flip?
16:46:40 <ddarius> @undefine
16:46:48 <ski> @type SimpleReflect.c
16:46:49 <lambdabot> Expr
16:46:53 <wli> Hideous trainwreck? Anti-H98?
16:46:56 <Cale> Twey: Not in general
16:47:17 <Cale> I think the handling of subtraction and negation in Haskell 98 is perfect
16:47:30 <Twey> (and dammit, why do you people always have to start having interesting conversations at midnight when my brain thinks I should be asleep?  :Ã¾)
16:47:46 <Cale> I really like being able to write -x to indicate the negation of x
16:47:49 <ski> SML uses `~' for number negation
16:47:50 <Twey> So perfect it requires brackets around negative terms and we have no negation sections?
16:47:54 <ddarius> Twey: Usually 1-5am is when your brain thinks you should be asleep modulo day light.
16:48:04 <soupdragon> > drop 5935 $ iterate sqrt 325361
16:48:04 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
16:48:12 <wli> I mostly think of the H98 polymorphic scare as the biggest thing that went wrong, apart from maybe the module system being too weak.
16:48:14 <soupdragon> > drop 5935 $ iterate sqrt 0.0000000325361
16:48:14 <Twey> ddarius: It nearly is one
16:48:14 <lambdabot>   [0.9999999999999999,0.9999999999999999,0.9999999999999999,0.999999999999999...
16:48:21 <Cale> Twey: yes, but there's no unambiguous way to have all the possible meanings for things we could possibly want at once
16:48:32 <Cale> Twey: and I think the current compromise is optimal
16:48:48 <Twey> Cale: There is â€” whitespace-sensitivity and a lexical rule for negation
16:48:59 <BMeph> So, sequence == flip... in a weird way, that makes sense.
16:49:30 <Cale> wli: hear hear
16:49:44 <Twey> I'd even rather write â€˜negate xâ€™ than â€˜(-x)â€™â€¦ the latter should be a subtraction section by parallel with â€˜(+x)â€™ &c.
16:49:47 <Cale> Haskell 1.4 was a lot cooler than Haskell 98 in a lot of ways
16:50:10 <BMeph> Well, sequenceA, anyway. :)
16:50:13 <Cale> Also, Haskell 98 is a silly name. It should have been Haskell 1.5 :P
16:50:30 <McManiaC> Twey: (+ (-x))
16:50:30 <McManiaC> :D
16:50:35 <chrisdon`> microsoft and their years
16:50:35 <Cale> (Or perhaps it shouldn't have been at all ;)
16:50:36 * Twey shudders.
16:50:54 <wli> I should cook up a pet language or something.
16:51:00 <Cale> Since almost everything about it went in the wrong direction from 1.4
16:51:35 <Cale> Haskell 2010 is basically 1.5.1
16:51:41 <chrisdon`> i liked the renaming syntax for module imports
16:52:09 <wli> I still miss higher-order modules from SML/ocaml/etc.
16:52:11 <ski> @type uncurry (fmap . (,))
16:52:13 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
16:52:22 <aristid> wli: like?
16:52:37 <monochrom> oh! you could import Prelude(tail but call it mail)?
16:52:38 <chrisdon`> wli: funnily f# is ocaml but without the best thing, the parameterized modules
16:52:47 <chrisdon`> monochrom: yeh
16:53:06 <wli> aristid: Not sure what your question is.
16:53:07 <ddarius> aristid: Look at Parsec's TokenParser for an annoying work around for lacking (ML-style) functors.
16:53:34 <aristid> wli: oh, i read "higher-order functions" nevermind
16:53:38 * chrisdon` looks at ByteString
16:54:49 <ski> @type Data.Traversable.sequenceA
16:54:50 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
16:54:53 <acowley> wli: Don't forget PLT Racket's Units
16:55:15 <wli> acowley: How can I forget? I've never seen or heard of them.
16:55:21 <acowley> wli: :/
16:55:24 <Cale> McManiaC: Anyway, did that explanation about flip help?
16:55:36 <acowley> wli: They provide similar magic
16:55:55 <Cale> McManiaC: The generalised flip sort of says something about how function structure can be interchanged with the structure of any appropriate container type.
16:55:59 <Cale> (any functor)
16:56:28 <Cale> and in the special case of functions, that just means swapping parameter order :)
16:57:00 <aristid> ddarius: TokenParser looks extremely ugly, but i don't understand functors well enough (read: at all) to know how it is an ugly work-around
16:57:04 <McManiaC> Cale: I think I got the ideaâ€¦ tho I'm too tired to completly understand it :)
16:57:07 * ddarius whispers "distributive law" ...
16:57:22 <Cale> By contrast, sequence says something about how list structure can be interchanged with the structure of any monad (a more refined sort of container type)
16:57:34 <ddarius> aristid: TokenParser is an ad-hoc implementation of first class modules.
16:57:37 <aristid> :t flip
16:57:38 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:57:59 <Cale> and they turn out to be the same thing when you choose the list functor and function monad :)
16:58:16 <Cale> :t flip :: [a -> b] -> a -> [b]
16:58:17 <lambdabot> forall a b. [a -> b] -> a -> [b]
16:58:20 <BMeph> m = (a ->), vs. f = [ ]... :)
16:58:21 <Cale> :t sequence :: [a -> b] -> a -> [b]
16:58:22 <lambdabot> forall a b. [a -> b] -> a -> [b]
16:58:25 <ski> @type Data.Traversable.sequenceA
16:58:26 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
16:58:27 <aristid> ddarius: with records instead of modules?
16:58:34 <ddarius> aristid: Yes.
16:59:09 <Cale> So, I guess I kind of do like the generalised flip ;)
16:59:18 <wli> aristid: Aha. Modules in SML/ocaml can be module-valued functions of various things (terms, types, other modules).
16:59:21 <McManiaC> Cale: hmmm I see
16:59:22 <ddarius> (Though, a language that actually had first class modules would likely at least partially unify records and modules.)
16:59:44 <Cale> I'm not sure exactly how useful it is, but I think it has something nice to say about datastructures and functions which is worth saying somewhere.
17:00:13 <dolio> Generalized flip is eta expansion.
17:00:38 <dolio> f |-> \a -> f <*> pure a
17:00:40 <ddarius> aristid: What Daan (or someone) wanted was: module TokenParser using module L where ..., and then you'd do import TokenParser using HaskellLanguage
17:01:13 <BMeph> Would first-class classes be like modules, or just one more crippled limp towards it?
17:01:44 <ddarius> BMeph: We can already mimick much of O'Caml's and SML's module language using current classes and extensions.
17:01:51 <aristid> ddarius: isn't the solution in Parsec slightly more flexible?
17:01:51 <dolio> That's exactly what eta expansion does to implicit effects in languages that don't track them, like, say, OCaml.
17:01:54 <ddarius> The encoding isn't even that bad...
17:02:10 <ddarius> aristid: It's quite a bit more flexible, but the flexibility isn't really necessary.
17:02:20 <ddarius> aristid: And it's much more annoying to use.
17:02:49 <wli> Well, it's writing machine translation end-product by hand.
17:03:00 <aristid> ddarius: but i dislike TokenParser because it feels ungeneral and very hard-wired
17:03:27 <ddarius> aristid: That's just a matter of the hooks provided and not provided.
17:03:27 <aristid> (looking at the docs)
17:03:35 <ski> (.. iirc Scheme48 has something similar to ML modules)
17:04:40 <wli> Tough to imagine ML modules without types or sharing constraints.
17:05:35 <ddarius> aristid: Or you're expecting TokenParser to be something it's not.  It was meant to capture some rather common kinds of lexical structure to allow RAD for similar styles of syntax.  It isn't met to be a general this-is-how-you-parse-tokens interface.
17:05:53 <aristid> ddarius: i suppose that's the actual problem.
17:06:07 <aristid> ddarius: why isn't it a this-is-how-you-parse-tokens interface?
17:06:43 <ddarius> aristid: Why should it be?  Parsec allows you to use anything to tokenize as long as you produce a stream of tokens.
17:08:03 <aristid> ddarius: is tokenizing by hand so easy?
17:08:18 <ddarius> aristid: It's not hard, but you can, for example, use Alex to tokenize.
17:08:40 <dolio> I never use lexers with parsec, at least.
17:09:05 <ddarius> Me neither, but I'm usually happy with TokenParser.
17:10:52 <davekong> Once I get a random number how do I use it like it's not IO?
17:11:26 <davekong> Can someone point me to a nice tutorial on writing programs that use random numbers
17:11:27 <ddarius> You don't have a random number if all you have is an IO action.
17:12:18 <davekong> I am trying to write a function that takes a list and returns the list with all the elements in random order
17:12:30 <soupdragon> I know how to do that
17:13:19 <ddarius> @hackage random-shuffle
17:13:19 <lambdabot> http://hackage.haskell.org/package/random-shuffle
17:13:44 <davekong> thanks
17:15:47 <davekong> looks complex
17:16:47 <ddarius> do gen <- getStdGen; let shuffledList = shuffle' myList gen (length myList)
17:17:06 <hpc> @check (not x) || y == not (x || not y)
17:17:07 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:17:44 <monochrom> need more parentheses
17:18:17 <monochrom> understandably, because people write "x==1 || x==2" all the time, it is read as (x==1)||(x==2)
17:18:43 <aristid> @check (not x || y) == not (x || not y)
17:18:44 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:18:58 <monochrom> and then you need a few more lambdas
17:19:13 <monochrom> @check \x -> (x&&x)==x
17:19:14 <lambdabot>   "OK, passed 500 tests."
17:19:28 <aristid> ah, @check can't magically functionify that
17:19:30 <FunctorSalad> is that O(n) like the mutating algo?
17:19:47 <aristid> @check \x y -> (not x || y) == not (x || not y)
17:19:48 <lambdabot>   "Falsifiable, after 1 tests:\nFalse\nFalse\n"
17:19:54 <ddarius> FunctorSalad: No.
17:20:04 <soupdragon> my book says infinity is a prime number
17:20:07 <soupdragon> is this true?
17:20:10 <aristid> monochrom: note that it's not MORE parentheses, just different ones :P
17:20:22 <monochrom> I can't count.
17:20:23 <Rotaerk> soupdragon, infinity isn't a number
17:20:23 <soupdragon> is infinity the product of all primes plus one??
17:20:28 <davekong> infinite is normally not a number
17:20:37 <monochrom> @check \x y -> (not x || y) == (x <= y)
17:20:39 <lambdabot>   "OK, passed 500 tests."
17:20:48 <aristid> :t (<=)
17:20:49 <lambdabot> forall a. (Ord a) => a -> a -> Bool
17:20:51 <soupdragon> "Prove that the product over /all/ primes /including/ infinity of ... equals ..."
17:20:54 <soupdragon> that's what it says
17:20:55 <ddarius> Let a = Bool
17:21:10 <aristid> oh, lol i thought <= was reverse implication
17:21:11 <FunctorSalad> in the context of divisibility, the greatest element is 0 ;)
17:21:24 <ddarius> aristid: It's unfortunate that it is not.
17:21:35 <monochrom> because False<=True and "False implies True"
17:21:39 <FunctorSalad> soupdragon: can't be the standard context
17:21:47 <aristid> ddarius: less-or-equal should have a different symbol?
17:21:50 <ddarius> aristid: => is reverse implication
17:21:52 <soupdragon> it's p-adic
17:21:53 <FunctorSalad> p-adic numbers?
17:21:55 <soupdragon> yyes!
17:21:56 <FunctorSalad> ah
17:22:00 <ddarius> aristid: No, it's just the way things work out.
17:22:00 <soupdragon> is infinity a p-adic number
17:22:14 <FunctorSalad> product of all the prime integers in a fixed p-adic field?
17:22:28 <soupdragon> well we haven't built the p-adic field yet
17:22:36 <soupdragon> so I'll have to read the next section to do that product
17:22:40 <FunctorSalad> the ring of p-adic ints will do for this
17:22:44 <aristid> :t (=>)
17:22:44 <lambdabot> parse error on input `=>'
17:22:50 <FunctorSalad> who knows, maybe it converges ;)
17:22:51 <ddarius> Er, >=
17:22:56 <FunctorSalad> haven't thought about it
17:23:18 <soupdragon> but if it's the product of all the numbers then it's not prime
17:23:56 <FunctorSalad> hmm, the numbers will all have magnitude 1 (if that's what numbers indivisible by p have as magnitude in your convention)
17:24:26 <aristid> ddarius: so <= is implication and >= is reverse implication, when forced into Bool -> Bool -> Bool?
17:24:30 <FunctorSalad> 'prime' simply in the sense of prime-integer-cast-to-p-adic? or prime in the p-adic integer ring?
17:24:32 <monochrom> yes
17:24:42 <FunctorSalad> (no clue about the latter)
17:24:46 <wli> Algebraic completions of Q_p and F_p are interesting in various respects as well.
17:25:20 <soupdragon> wli yeah that is mentioned in a very poetic way
17:25:22 <soupdragon> but it's much later on
17:25:42 <FunctorSalad> (my obervation says nothing about whether the sequence of partial products converges, though... for that the differences matter, not the magnitude)
17:25:51 <soupdragon> FunctorSalad, oh yeah that's a good point I hadn't considered there is a difference
17:27:17 <FunctorSalad> partial_product(n+1) - partial_product(n) = ({n+1-th prime number} - 1) * partial_product(n), right?
17:27:33 <FunctorSalad> do we know whether a prime minus 1 is divisible by p?
17:27:52 <FunctorSalad> ISTR that you can't say anything about it in general
17:28:22 <ivanm> that sounds right
17:28:44 <ivanm> by "divisible by p", you mean that it isn't a prime?
17:28:45 <wli> I think there's a name for sequences of primes where p_n | (p_{n+1}-1)
17:28:55 <soupdragon> > 999**(1/999(
17:28:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:28:56 <soupdragon> > 999**(1/999)
17:28:57 <lambdabot>   1.0069376230256448
17:29:26 <FunctorSalad> ivanm: no, the fixed 'p' that specifies which p-adic integers we're in
17:29:46 <ivanm> oh
17:29:53 <FunctorSalad> but it's never a prime since it's 1 or even, even I can see that ;)
17:29:56 <ivanm> wait, I missed the beginning of this discussion
17:30:12 <ivanm> FunctorSalad: well, 3-1 is prime... ;-)
17:30:22 <FunctorSalad> ivanm: product of all primes, in a ring of p-adic integers for some p
17:30:45 <FunctorSalad> we're not sure if 'prime' means the prime integers from the copy of Z in Z_p
17:30:47 <ivanm> ahhh
17:30:55 <FunctorSalad> (or primes in the ring theory sense in Z_p)
17:31:13 <FunctorSalad> ivanm: doh! you win
17:34:52 <aristid> oh, lol, there's a more modern version of uulib in uu-parsinglib
17:35:15 <aristid> hmm is it possible that uulib actually started the whole Applicative thing?
17:53:43 * edwardk1 waves hello.
18:06:44 <soupdragon> hi edwardk
18:07:36 * BMeph waves to edwardk
18:11:27 <edwardk> wow my ping times must be awful =)
18:12:04 * edwardk goes to check the relays
18:21:03 <ivanm> hi edwardk 
18:21:32 <arcatan> lo edwardk
18:24:52 * edwardk notes that simon followed through on his 'hello world' example
18:29:00 <soupdragon> FunctorSalad?
18:29:06 <FunctorSalad> aye
18:29:43 <soupdragon> I just noticed that say (2^n) is divergent with the 2-adic metric
18:30:22 <soupdragon> but it says any sequence of integers has a cauchy subsequence
18:31:16 <FunctorSalad> huh? 2^n converges to zero
18:31:19 <FunctorSalad> in 2-adic
18:31:50 <soupdragon> omg I was looking at the order not the norm damn lol thanks
18:31:57 <soupdragon> why am I making such stupid mistakes
18:32:16 <edwardk> why the sudden interest in p-adic numbers?
18:32:23 <FunctorSalad> because it's kinda non-intuitive? ;)
18:32:33 <FunctorSalad> (@soup)
18:32:41 <soupdragon> I think im just dum :p
18:33:26 <soupdragon> edwardk,  I think they are important for the zeta function
18:33:40 <soupdragon> but they seem quite interesting anyway
18:34:11 <edwardk> have a num instance yet? =)
18:34:23 <soupdragon> no I am heading toward that though
18:35:01 <FunctorSalad> sounds easy at first
18:35:21 <FunctorSalad> (simply arbitrary-precision modular arithmetic in Z/p^nZ ;))
18:35:26 <edwardk> then you of course need to encode the p
18:35:33 <soupdragon> I can't prove this theorem without axiom of choice
18:35:35 <FunctorSalad> a list would work, no?
18:35:38 <edwardk> sure
18:35:43 <soupdragon> I guess because I'm finding a subsequence of an infinite sequence that choice is not a sin
18:35:43 <edwardk> lots of ways
18:36:05 <FunctorSalad> static p would be another matter (general type-programming)
18:36:15 <edwardk> i was thinking reflection but sure
18:36:36 <soupdragon> so there is a use for type level primality checking
18:36:39 <FunctorSalad> yes I remember the example of modular arith for reflection
18:37:07 <edwardk> the framework is even on hackage
18:37:29 <FunctorSalad> soupdragon: "every sequence in a compact set has a convergent subsequence"?
18:37:41 <FunctorSalad> don't remember if Z_p was compact
18:37:44 <soupdragon> well |Z the integers
18:37:56 <FunctorSalad> it'd metrically bounded, but that's not enough
18:38:23 <EvanR> that theorem is so awesome
18:38:23 <FunctorSalad> though it also appears to be totally bounded (which is enough)
18:38:43 <EvanR> analysis is awesome
18:38:45 <FunctorSalad> many reverse deps yes
18:38:47 <soupdragon> hehe
18:38:47 * edwardk doesn't remember much about Z_p. I had a professor who had done a lot of work with p-adic arithmetic (fourier analysis in p-adic spaces, etc.) and I grokked it at the time, but sadly that is one area of math I've largely forgotten
18:38:54 <soupdragon> im not very good at analysis
18:39:01 <FunctorSalad> "Bolzano-Weierstrass", to say it's name btw
18:39:02 <FunctorSalad> iirc
18:39:25 <FunctorSalad> totally bounded = for every epsilon, it can be covered by finitely many epsilon-balls
18:39:25 <EvanR> it scares me that i forgot it :(
18:39:39 <soupdragon> hm so the integers are compact wrt |-|_p ?
18:39:43 <soupdragon> the p-adic norm
18:39:50 <FunctorSalad> an epsilon ball is easily pictured as a digit-wildcard that leaves the last n digits unspecified
18:39:57 <FunctorSalad> (epsilon = 2^-n)
18:39:59 <soupdragon> is that compactness theorem an IFF thing? I'd guess not
18:40:01 <ddarius> EvanR: You're getting old.  Soon you won't remember your coworkers names.
18:40:07 <EvanR> good
18:40:08 <FunctorSalad> err, wait
18:40:13 <FunctorSalad> it *fixes* the last n digits
18:40:23 <FunctorSalad> the rest are free
18:40:34 <FunctorSalad> and clearly you only need finitely many such balls
18:40:40 <FunctorSalad> (of fixed n/epsilon)
18:40:54 <FunctorSalad> (just enumerate all the possible last-n-digits)
18:42:02 <FunctorSalad> edwardk: CT to the rescue! it's 'simply' ;) the limit (in Ring or something) of n |-> Z/(p^n Z)
18:42:15 <soupdragon> that's a cool definition
18:42:16 <edwardk> =)
18:42:29 <soupdragon> do you think that can be used in a program?
18:42:31 <FunctorSalad> with the projections given by "digit truncation" as part of the diagram
18:42:37 <soupdragon> like if you implemented categories and stuff
18:42:38 <edwardk> the rest is just deriving all the consequences of that ;)
18:42:49 <edwardk> soupdragon: probably not ;)
18:42:52 <FunctorSalad> (if you write an element of Z/p^n Z as an n-digit base-p number)
18:42:57 <ddarius> Not if you make a generic (co)limit library!
18:43:16 <edwardk> ddarius: yeah, you'd probably need a bit more than mine ;)
18:43:54 <ddarius> Nur ein bisschen
18:44:16 <edwardk> =)
18:44:52 <FunctorSalad> soupdragon: it kinda justifies that you can implement it as "Z/p^n Z, with n on demand"
18:45:02 <FunctorSalad> I didn't actually ever implement it but seems like that
18:45:28 <FunctorSalad> (if the user wants n digits as output, you can do all your ring calculations in Z/p^nZ)
18:45:44 <dolio> I'm not sure constructing arbitrary omega (co)limits in Ring would be easier than just programming the p-adic numbers directly.
18:45:45 <soupdragon> oh of course
18:45:51 <soupdragon> because some numbers have infinitely many digits
18:46:06 <soupdragon> so are there more p-adic integers than normal integers? :D
18:46:17 <FunctorSalad> sure, they're uncountable
18:46:23 <soupdragon> wow that's weird
18:46:33 <FunctorSalad> isn't it obvious from the digit representation?
18:46:36 <edwardk> hrmm would it be sacrilege to implement the lexer for my lexer in parsec? =)
18:46:45 <soupdragon> well it's obvious enough that I realized it just now
18:46:53 <FunctorSalad> {0,1,...,p-1}^Nat ;)
18:46:53 <soupdragon> (and not before)
18:46:59 <FunctorSalad> :)
18:47:12 <dolio> edwardk: So it'd be a quasiquoter that produced parsec parsers?
18:47:22 <FunctorSalad> why do you need to lex your lexer yourself
18:47:32 <FunctorSalad> shouldn't ghc do that for you ;)
18:47:42 <dolio> Or do you mean parse the grammar for your lexer?
18:47:44 <edwardk> dolio: nah it'd be a quasiquoter that produced an alex style lexer, but internally to parse the quasiquotation at compile time used parsec
18:48:02 <FunctorSalad> ("when I was young, we still had to hand-crank the lexer whenever we wanted to compile a ...")
18:48:07 <FunctorSalad> sorry
18:48:22 <edwardk> letting the result be driven by parsec is also not a bad idea
18:48:42 <dolio> Well, why not? It's better than reinventing parser combinators.
18:48:43 <soupdragon> lol
18:49:13 <edwardk> dolio: heh, was thinking from a bootstrapping perspective, but yeah. the only argument is the parsec 2 vs 3 noise.
18:49:17 <dolio> I guess you could also use something simple, like ReadP, to avoid the dependency.
18:49:25 <edwardk> dolio: which is almost enough to drive me to polyparse or readP
18:49:26 <edwardk> yep
18:50:59 <FunctorSalad> edwardk: interesting idea to rehash alex as a QQ
18:51:06 <FunctorSalad> would it be viable for happy too?
18:51:10 <edwardk> FunctorSalad: yeah
18:51:17 <edwardk> that is likely the next part of this project
18:51:38 <FunctorSalad> (the extra build step can be a bit of the PITA... like when you want to load the source tree in ghci)
18:51:43 <edwardk> yep
18:51:56 <edwardk> that was what prompted this =)
18:51:59 <dolio> Well, if you're going to use parsec, use 3. If people keep writing new stuff in 2, the conflict will never go away.
18:52:00 <FunctorSalad> (since cabal will just put the .hs in dist)
18:52:29 <edwardk> dolio: well the problem is that it'd make the use of luthor incompatible with http, etc.
18:52:40 <edwardk> dolio: hence why i'm looking at something outside of parsec.
18:52:44 <soupdragon> > (10^2)**(1/10^2)
18:52:45 <lambdabot>   1.0471285480508996
18:52:47 <soupdragon> > (10)**(1/10)
18:52:47 <lambdabot>   1.2589254117941673
18:53:34 <FunctorSalad> hmm, $(runIO (system "happy Foo.y") >> return [d| |])
18:53:44 <FunctorSalad> self-re-happying source file :D
18:53:52 <edwardk> FunctorSalad: =)
18:53:56 <FunctorSalad> (that'd be a toplevel decl splice)
18:54:11 <edwardk> then you can even drop the $ ;)
18:54:41 <FunctorSalad> it should probably throw an error if running happy was necessary, so you can rerun ghc on the new file
18:54:50 <FunctorSalad> ah, right, never got to use that
18:57:34 <FunctorSalad> hmm why isn't hasktags included in "exuberant-ctags"?
18:58:04 <CummieSock> I am sick of putting up with affirmative action negroes that writes sloppy code.
18:58:08 <CummieSock> What about you?
18:58:18 <FunctorSalad> (seems to support the kitchen sink, but not haskell, out of the box)
18:58:20 <CummieSock> If you feel the same way, boy do we have a site for you!
18:58:26 <soupdragon> CummieSock: that's not politically correct
18:58:28 <tensorpudding> @ops
18:58:28 <lambdabot> Maybe you meant: docs oeis pl
18:58:42 <CummieSock> Chimpout Forum is not racist or white supremacist.
18:58:46 <CummieSock> We only hate niggers!
18:59:08 <CummieSock> We welcome with open arms asians, jews, hispanics, whites, indians, arabs, gays, native americans, and more!
18:59:10 <applicative> go away, moron.
18:59:10 <EvanR> of all the channels to act this way in, why here
18:59:12 <soupdragon> CummieSock: PR advice: Don't spam nobody will go to your site if you spam.. no matter how great it is
18:59:19 <CummieSock> Join the humanistic alliance against the feral negro beast!
18:59:27 <CummieSock> http://www.chimpout.com/forum
18:59:36 <dolio> @where ops
18:59:37 --- mode: ChanServ set +o mauke
18:59:37 --- kick: CummieSock was kicked by mauke (CummieSock)
18:59:37 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
18:59:37 --- mode: mauke set +b *!*@189.214.151.190.cable.dyn.cableonline.com.mx
18:59:44 <dolio> Whoops.
19:01:37 --- mode: mauke set -o mauke
19:02:25 <FunctorSalad> EvanR: appears to be a large-scale meme forcing
19:02:26 * hackagebot mstate 0.1.1 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.1.1 (NilsSchweinsberg)
19:02:35 <FunctorSalad> at least I've seen it on 4chan once
19:03:26 <EvanR> i have a +9 saving throw against memes
19:05:46 <ivanm> if I have a list of [(a,b)] and I want to turn it into a Map a [b], what would be the best way?
19:06:07 <ivanm> Map.fromListWIth (++) . map (second (:[])) ?
19:07:28 * hackagebot mstate 0.1.2 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.1.2 (NilsSchweinsberg)
19:07:40 <FunctorSalad> ivanm: looks good
19:07:49 <ivanm> good-o
19:07:59 <FunctorSalad> the *with and *withKey functions are handy
19:08:28 <FunctorSalad> "best" as in performance or code golf?
19:08:33 <ivanm> performance
19:08:48 * ivanm is making Data.Graph.Inductive.PatriciaTree allow multiple edges
19:09:03 <FunctorSalad> no idea, yours seems to have the right asymptotics at least ;)
19:09:15 <FunctorSalad> fromAscListWith is better if the list is Asc obviously
19:09:34 <ivanm> yeah, I can't guarantee that
19:09:42 <ivanm> I'd prefer to be able to use (:), but the types don't allow it :s
19:09:51 <ivanm> the other option would be to do some kind of group . sort
19:10:03 <FunctorSalad> foldr (\x m -> insertWith (++) [x] m) mempty would work too
19:10:09 <FunctorSalad> no idea if it compiles to the same
19:10:25 <FunctorSalad> (modulo right argument order for insertWith :E)
19:10:38 <ivanm> yeah, it appears that left-hand elements go first
19:10:50 <ivanm> I don't really care about the order, though
19:11:09 <FunctorSalad> left-hand?
19:11:24 <FunctorSalad> @ty insertWith
19:11:25 <lambdabot> Not in scope: `insertWith'
19:11:29 <FunctorSalad> @ty M.insertWith
19:11:29 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
19:11:42 <FunctorSalad> ok, I guessed right
19:11:44 <ivanm> gah, s/left-hand elements/elements on the left/
19:11:53 <FunctorSalad> (enabling eta-contraction, yay)
19:12:29 <FunctorSalad> foldr (insertWith . (([]):)) mempty if you want to overdo it ;)
19:12:55 <FunctorSalad> maybe foldl' is better still
19:13:13 <FunctorSalad> @ty lookup
19:13:14 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:13:19 <FunctorSalad> @ty M.lookup
19:13:20 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
19:13:39 <FunctorSalad> hmm, thought there was some odd-one-out function where the map goes left
19:16:48 <ivanm> preflex: seen Baughn 
19:16:48 <preflex>  Baughn was last seen on #haskell 9 hours, 11 minutes and 57 seconds ago, saying: Phyx-: I think there was some package to embed emacs in VS somewhere..
19:18:01 <optimality> so, is there a better string library than Data.ByteString.Lazy?  My program is spending half its time (literally, I've profiled it) in Data.ByteString.Lazy.Char8.drop
19:18:25 <ivanm> optimality: maybe because you're dropping a lot of stuff?
19:18:38 <optimality> ivanm: yeah, I know I'm dropping a lot of stuff :)
19:18:41 <ivanm> optimality: there's text, but it sometimes has worse performance than String
19:18:53 <ivanm> edwardk had a ropes library, don't know if it got anywhere...
19:19:00 <ivanm> optimality: but have you tried plain ol' String?
19:19:10 <optimality> ivanm: that would be ideal - I'm actually doing the icfp07 contest :)
19:19:22 <FunctorSalad> how's drop for BSs implemented?
19:19:28 <ivanm> optimality: you do realise you're at least 3 years behind... ;-)
19:19:37 <ivanm> FunctorSalad: I'm guessing shrinking the array, which probably doesn't help
19:19:39 * technogeeky adds 07 + 03 
19:19:42 <optimality> ivanm: yeah :) it's one of my favorite things to do when learning a new language, though
19:19:42 <FunctorSalad> I expect that it just advances the "start of payload data" index
19:19:47 <FunctorSalad> which seems hard to beat
19:19:55 <ivanm> but if you do a lot of dropping, String might be a better choice
19:20:01 <optimality> hmm
19:20:05 <FunctorSalad> are you sure the time used by BS is an inefficiency?
19:20:12 <optimality> FunctorSalad: no
19:20:14 <ivanm> FunctorSalad: and that's the other thing
19:20:16 <optimality> I'm not sure there's a faster way to do it
19:20:19 <FunctorSalad> rather than the irreducible cost of what you're doing
19:20:22 <optimality> just wondering if there was :)
19:20:22 <ivanm> it could be that you can't beat it using your current algorithms
19:20:27 <optimality> yep
19:20:27 <ddarius> optimality: If you can use strict ByteStrings, drop is practically free for them.
19:20:53 <ddarius> FunctorSalad: Lazy ByteStrings are list of strict ByteString chunks.
19:20:53 <FunctorSalad> rechunking every somethousand chars with lazy BS shouldn't be a problem either
19:21:07 * optimality switches to strict ones and tests
19:21:09 <FunctorSalad> yeah, but chunks of 4k? 65k? not sure
19:21:25 <FunctorSalad> should hardly be a problem in my uninformed opinion
19:21:31 <ddarius> optimality: Strict ByteStrings will require the entire input to be in memory at the same time
19:21:38 <optimality> ddarius: yep, np
19:21:40 <optimality> it's a lot faster
19:21:46 <optimality> just tried it
19:22:43 <FunctorSalad> hmm, why would that be
19:23:13 <FunctorSalad> what's the magnitude of the argument to drop?
19:23:15 <optimality> FunctorSalad: the time for drops went to 0
19:23:26 <FunctorSalad> and total time?
19:23:41 <optimality> FunctorSalad: umm, up to a few hundred thousand on a string in the millions
19:23:44 <FunctorSalad> maybe drop for strict BS isn't profiled ;)
19:23:50 <FunctorSalad> (eliminated somehow)
19:24:52 <optimality> FunctorSalad: 2s for the strict version
19:24:58 <FunctorSalad> optimality: ah, my "shouldn't matter" was expecting you drop 5 or so at a time ;)
19:25:06 <optimality> FunctorSalad: yeah... :)
19:25:16 <FunctorSalad> since then it'd be mostly just the strict-BS-drop for the head chunk...
19:25:20 <ivanm> no, I'm guessing that it's because he was a really long file which performs better with lazy bytestrings
19:25:27 <optimality> 2.14s for the lazy version
19:25:33 <optimality> so, not that much difference, aktually
19:26:01 <FunctorSalad> ok then it's probably as I said, strict's drop just isn't profilable
19:26:03 <ivanm> so it's faster with the strict version?
19:26:13 <FunctorSalad> you could put an SCC around the critical expression
19:26:21 <FunctorSalad> {-# SCC "ohHai" #-}
19:26:23 <ivanm> preflex: seen tomberek
19:26:24 <preflex>  tomberek was last seen on #haskell 26 days, 16 hours, 5 minutes and 52 seconds ago, saying: copumpkin.. what about coq?
19:26:28 <ivanm> grrr...
19:26:33 <optimality> it's *slightly" faster
19:26:38 <optimality> I've got an SCC on the drop
19:26:52 <FunctorSalad> (the pragma acts as an expression and has scope similar to a lambda, AFAIK)
19:26:57 <optimality> about 10% faster
19:27:05 <FunctorSalad> ah
19:27:23 <optimality> the difference is that the drops are basically free, but I do a lot of 1-character appends
19:27:28 <optimality> which are suddenly really expensive :)
19:27:36 <FunctorSalad> for the strict one?
19:27:37 <optimality> oh, and I have to reverse it
19:27:39 <optimality> yeah
19:27:45 <optimality> the strict reverse is super expensive
19:27:47 <FunctorSalad> doesn't it have spare capacity at the end?
19:27:55 <optimality> sorry
19:27:57 <optimality> I mean append
19:27:59 <optimality> not reverse :)
19:28:05 <optimality> FunctorSalad: I dunno?
19:28:23 <optimality> lazy = fast appends, slow drops; strict = fast drops, slow appends
19:28:23 <FunctorSalad> it's be crazy to grow the array for every 1-char append
19:28:26 <FunctorSalad> it'd
19:29:02 <optimality> I don't see an ensureCapacity or anything
19:29:03 <EvanR> premature optimization!
19:29:11 <optimality> EvanR: what is? :)
19:29:12 <EvanR> memory is cheap these days
19:29:17 <optimality> yeah
19:29:27 <EvanR> im joking
19:29:29 <optimality> I wish I could see a way to say "Just make it effing huge, and fill it in"
19:29:37 <FunctorSalad> + xargs echo
19:29:38 <FunctorSalad> + head -5
19:29:38 <FunctorSalad> + ghc -e ':i Data.ByteString.ByteString'
19:29:38 <FunctorSalad> data Data.ByteString.Internal.ByteString = Data.ByteString.Internal.PS !(GHC.ForeignPtr.ForeignPtr GHC.Word.Word8) !Int !Int
19:29:50 <FunctorSalad> those ints are start and end of valid data, aren't they?
19:30:04 <optimality> FunctorSalad: I'm a newb, that's out of my depth :)
19:30:24 <FunctorSalad> sorry, the + spam is just the commandline I used
19:31:49 <optimality> looks like Meunier's ropes library is at version 0.2 :)
19:31:52 <optimality> wonder how it works
19:32:36 <optimality> oops, doesn't install
19:32:37 <optimality> oh well
19:33:26 <FunctorSalad> depending on what you're doing, you might just use an array and move the indices yourself
19:33:46 <FunctorSalad> instead of dropping/appending
19:34:36 <ivanm> FunctorSalad: with my Map stuff, even better: define a function such that appending a singleton element just puts it on the front (since I don't care about order); this way I don't have to worry about which order Map puts them in!
19:34:36 <optimality> FunctorSalad: yah, that's an option
19:35:34 <alexyk> dons: what's the word on binary vs binary-strict?  the latter says the team didn't make up its mind?
19:35:55 <ivanm> alexyk: I think binary-strict is deprecated
19:36:09 <ivanm> alexyk: there's now also cereal which is a fork of binary, and binary is taking some of its changes back
19:36:28 <alexyk> ivanm: interesting; what's the key difference of cereal?
19:36:34 <ivanm> binary is also stricter than it used to be to make GHC devs happy (it speeds someting in GHC up), which annoys ketil malde
19:36:58 <ivanm> alexyk: it uses strict rather than lazy bytestrings
19:37:04 <ivanm> see its description
19:37:33 <alexyk> for large data, I want strictness by default.  all this lazyness may or may not speed things up, and I wonder whether lazyness can be told to get to work once the volume of thunks exceeds some threshold
19:37:46 <ivanm> not easily :(
19:37:59 <ivanm> lazyness usually helps for really large amounts of data though
19:38:07 <FunctorSalad> ivanm: didn't realize we were talking about the order of the element lists at all
19:38:09 <ivanm> IIRC, Axman6 had a blog post about cereal
19:38:16 <FunctorSalad> s/element/value/
19:38:16 <ivanm> FunctorSalad: oh, sorry, didn't I make that clear?
19:38:26 <alexyk> I mean, gigabytes of graphs in memory is enough before thunks eat them
19:38:31 <FunctorSalad> so you want to avoid the left-nested (++) prob?
19:38:38 <ivanm> FunctorSalad: I'm basically treating [a] as a set (since Set needs Ord)
19:38:52 <ivanm> FunctorSalad: well, I don't know what order it uses
19:38:55 <FunctorSalad> the order I had been talking about was argument order of the Data.Map funs
19:39:04 <EvanR> is gigabytes of graphs in memory good?
19:39:18 <ivanm> since I also use it for Map.adjustWith, Map.insertWith, etc.
19:39:26 <FunctorSalad> I accidentally 93GB of graph. Is this bad?
19:39:38 <ivanm> EvanR: only if you have gigabytes of memory and want gigabytes of graphs in memory
19:39:39 <ivanm> ;-)
19:39:52 <FunctorSalad> sorry your q was just too close to the source of the accidentally meme to resist
19:39:56 <technogeeky> FunctorSalad: terrible, but I accidentally your DRAM with memristors.
19:39:57 <ivanm> FunctorSalad: very; you should have made it 92GB
19:40:20 <dons> alexyk: oh, use cereal if you want to only load strict bytestrings
19:40:22 * FunctorSalad doesn't know what memristors are :(
19:40:23 <alexyk> is there a way to type-hint on the LHS:   dc <- loadAnyData dcName :: IO DCs -- ?
19:40:30 <dons> but probably unlikely to be any faster
19:40:31 <EvanR> stop with the of verbs dammit
19:40:52 <technogeeky> FunctorSalad: http://www.youtube.com/watch?v=bKGhvKyjgLY
19:40:57 <dons> you almost certainly want lazy bytestrings for serialization
19:41:03 <technogeeky> watch that at the first available moment
19:41:10 <ivanm> dons: I assume you have no arguments to me uploading a bug-fix release of current FGL? :p
19:41:14 <alexyk> dons: what's the difference of cereal vs !'ing result of loading binary?
19:41:42 <alexyk> ivanm: hmm, how large a graph can you feed to FGL?
19:41:45 <Rotaerk> I accidentally over 9000 GB of your base
19:41:50 <FunctorSalad> dons: was my speculation that the ints in the Bytestring are start and end index of valid data correct?
19:42:03 <ivanm> alexyk: no idea tbh, though some people have told me that it's not that great for around > 300 vertices
19:42:14 <FunctorSalad> (then appending a single element seems like it'd be very cheap)
19:42:15 <alexyk> ivanm: whopping
19:42:27 <ivanm> alexyk: but in the only app I currently use it for, its performance is neglibible compared to other stuff that's running, so *shrug*
19:42:38 <FunctorSalad> hmm or maybe start and length
19:42:39 <ivanm> talk to fasta about this
19:42:40 <alexyk> my functional graph is an IntMap of 5 million nodes easily
19:42:41 <ddarius> FunctorSalad: How would it be cheap?
19:42:51 <FunctorSalad> (sorry, I could just have RTF haddock)
19:43:18 <FunctorSalad> ddarius: buffer[end] = new_char; end++ ?
19:43:21 <ivanm> alexyk: it depends upon what you're doing; PatriciaTree in FGL uses IntMaps behind the hood
19:43:27 <FunctorSalad> unless the buffer is full of course
19:43:50 <alexyk> my IntMap is dafis' hand-made one!
19:43:53 <ddarius> FunctorSalad: Yes, the "of course" is the issue.  Also, if it is a slice, you can't modify it in place.
19:44:04 <ivanm> it's actually a newtype version of: type Gr a b = IntMap (IntMap b, a, IntMap b)
19:44:21 <ivanm> and what I've done just now is turn those "IntMap b"s into "IntMap [b]"
19:44:21 <dons> FunctorSalad: offset and length
19:44:31 <ivanm> so you can have multiple edges between nodes
19:44:36 <alexyk> dons: btw timings vary, so I wonder if some unquashed lazyness pulls on things somehow, given disk performance fluctuates
19:44:39 <dons> alexyk: they're very different. cereal loads data as a single large byte array.
19:44:48 <FunctorSalad> ddarius: hmm the "of course" isn't so bad; snoc remains O(1) on average if you grow exponentially upon hitting capacity
19:44:50 <dons> binary loads it as cache-sized chunks of byte arrays
19:44:54 <alexyk> dons: then probably that's just fine
19:45:04 <ivanm> dons: I assume you have no arguments to me uploading a bug-fix release of current FGL? :p
19:45:13 <alexyk> since I need the whole thing in memory anyways
19:45:15 <ddarius> Where "cache-sized" means "arbitrary number"
19:45:23 <dons> ivanm: well, you have maintainership. i'm just reminding you to consider stability, is all
19:45:26 <FunctorSalad> (if you choose 2 as growth factor, every element will be written only twice on average, unless I'm missing something)
19:45:31 <dons> ivanm: follow the PVP
19:45:38 <dons> and all is good
19:45:39 <FunctorSalad> if you insert n chars into an empty BS
19:45:49 <alexyk> Portland Valued Professional?
19:45:51 <FunctorSalad> (each invididually)
19:45:51 <ivanm> dons: I was going to, and you were still complaining about major changes! (for the current experimental version we're working on)
19:46:08 <ivanm> dons: but all I'm doing here is letting PatriciaTree have multiple edges; there's no API change
19:46:12 <ddarius> FunctorSalad: Again, you can't modify a ByteString in place, even to append, in general.
19:46:12 <dons> well, i'm not sure it makes sense to use fgl as the name, is my position
19:46:17 <ivanm> @where PVP
19:46:18 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
19:46:20 <ivanm> alexyk: ^^
19:46:20 <dons> when you may as well just pick a different name
19:46:24 <alexyk> :)
19:46:34 <dons> i think your use of the old name to gain users is likely to unnec. break things, so not worth the benefit.
19:46:42 <dons> when just benchmarking and advocacy will achieve the same result
19:46:43 <FunctorSalad> ddarius: hmm, purity is a problem I admit
19:46:45 <ddarius> dons: Should packages always choose a different name when they bump the major version number?
19:46:45 <ivanm> dons: if you can think of a better name + module hierarchy names, I'm more than willing to listen ;-)
19:46:58 <alexyk> (Pacific Virgins' Party)
19:47:03 <dons> ddarius: no. only in these odd cases for "classic" libs that are say, > 10 years old
19:47:13 <dons> fgl is a bad name anyway
19:47:19 <ivanm> dons: oh, agreed
19:47:21 <dons> vector, binary, graphs.
19:47:33 <absentia> n/win shrink 3
19:47:33 <kmc> it should be fghijkl
19:47:35 <ivanm> I'm more than wiling to change it to inductive-graphs or something, but the module name clashes will still occur
19:47:37 <dons> just take the canonical Data.Graph and call the package "graph" or "graphs"
19:47:50 <ivanm> dons: I can't do that; it will clash with containers then
19:47:50 <dons> module clashes are fine
19:47:56 <dons> oh, oops. yes.
19:48:00 <ivanm> besides, I'm going to use something like that name for another library ;-)
19:48:13 <alexyk> kmc: t should be eyafjalaotkudl
19:48:13 <dons> sorry, fgl is Data.Graph.Inductive?
19:48:16 <ivanm> yup
19:48:23 <dons> just don't take 'fgl' as the package name. its too classic a design.
19:48:32 <ivanm> my grand plan is to have FGL introduce _only_ inductive graphs
19:48:37 <dons> instead, fix it. a la vector vs array, or text vs packedstring.
19:48:49 <ivanm> and have a graph library to introduce a more basic grpah hierarchy
19:48:56 <dons> sounds good
19:49:02 <ivanm> dons: except they used different module names
19:49:12 <dons> demonstrable benchmarks for inductive graphs would be great, vs. e.g. boost
19:49:12 <FunctorSalad> ddarius: I don't understand what "can't modify" has to do with "if you slice" though
19:49:16 <ivanm> so even if I change the package name, we'll have the mtl vs transformers issue
19:49:32 <dons> 'sok. people rarely combine graph libraries, i bet
19:49:40 <ivanm> dons: well, according to fasta there's no chance it'll be that good due to the design of inductive graphs :s
19:49:42 <FunctorSalad> it seems to be simply that modifying in place would break referential transparency, assuming the current interface
19:49:47 <dons> hehe. 
19:49:52 <ivanm> dons: s/combine/use/ :p
19:49:56 <dons> hheh
19:50:03 <alexyk> so -- no prettier way to type Binary load than: x <- load ... :: IO MyThing ?
19:50:15 <dons> that's a decent way
19:50:22 <ivanm> well, I'll talk to tomberek about it as soon as he emerges from whatever depths he's in
19:50:25 <dons> or some other type information (x :: Foo) <- load
19:50:41 <dons> ivanm: i'm glad you're considering not taking the 'fgl' name. 
19:50:43 <FunctorSalad> alexyk: or but the annotation at the point where x is used, avoiding having to type IO
19:50:50 <alexyk> dons: yeah, that's good
19:50:54 <ivanm> dons: I've always considered usign a different name
19:50:54 <dons> what we could do instead is deprecate fgl from the platform, and import e.g. 'graphs' if it is faster and nicer
19:50:55 <FunctorSalad> x <- load; print (x::MyThing)
19:51:00 <FunctorSalad> s/but/put/
19:51:28 <ivanm> dons: well, importing it into the platform will realistically require importing a _lot_ of packages at this stage for comparative behaviour
19:51:31 * dons is back to full time haskell, now i'm entering in post-doc land, so HP release coming, and some new libs
19:51:32 <ivanm> since we're splitting fgl up
19:51:33 <ddarius> FunctorSalad: If you knew that 1) you weren't a slice, and 2) you had valid unallocated memory beyond the end marker you could allocate it and mutate and simply return a new ptr/start/end triple (of course, this would make the old bytestring now a slice).
19:52:05 <alexyk> dons: you are a post-doc?
19:52:09 <ivanm> I'll have the base graphs library, graphs-algorithms (maybe), fgl (or whatever), fgl-algorithms, fgl-<extra instances>, and then graphviz for visualisation
19:52:16 <ivanm> alexyk: as in he submitted his PhD finally
19:52:23 <ivanm> dons: any idea if dcoutts finally submitted his? :p
19:52:41 <alexyk> yay!  where?  OSU?
19:52:42 <FunctorSalad> ddarius: hmm true, I somehow thought we'd change the end marker in place too ;)
19:52:43 <dons> ivanm: he sure is.
19:52:56 <ivanm> alexyk: UNSW
19:53:03 <alexyk> cool
19:53:17 <technogeeky> ivanm: what are you working on/discussing here?
19:53:18 <dons> ivanm: well, i took a year off with RWH and hacking, and a year off at Galois. then done. so not too bad in the end, but could have been done a couple of years ago.
19:53:18 <ivanm> dons: of course, if you come down to AusHac in two weeks time we could discuss this more in-depth and in person... :p
19:53:24 <ivanm> technogeeky: graph libraries
19:53:25 <FunctorSalad> (the int in the BS constructor, but obviously we could just construct new BS and just reuse the array)
19:53:30 <ddarius> dons: Do you have to box your thesis up and mail it around the world?
19:53:36 <FunctorSalad> (in the situation you mention)
19:53:39 <dons> ddarius: yep
19:53:54 <dons> ddarius: though initial vers. is .pdf
19:53:59 <alexyk> dons: PhD is a pleasure to savor as long as possible :)
19:54:02 <dons> hehe
19:54:11 * technogeeky congradulates dons
19:54:28 <ivanm> alexyk: ugh, I'm currently about 4 months in to mine; still doing the lit review :s
19:54:32 <dons> i'm certainly enjoying waking up in the morning and not typing "cd thesis" , instead typing "cd $new_hacking_project"
19:54:40 <ivanm> there are too many papers that have tangential dealings with graph generation :s
19:54:51 <ivanm> dons: you do a new hacking project every day? :p
19:54:54 <dons> ivanm: keep a paragraph or two of notes per paper
19:54:56 <alexyk> taking years off to do real things and books is key; uninterrupted BS=>PhD is half-useless
19:54:59 <dons> it will save you weeks at write up time.
19:55:11 <dons> ivanm: i had my annotated bibliography from 2004-6, which was a massive timesaver
19:55:22 <ivanm> dons: oh, I am; we're going to be writing a survey paper on this
19:55:30 <ivanm> which is why we're looking for _everything_
19:55:35 <dons> nice
19:55:44 <ivanm> (esp. since my topic isn't that determined yet)
19:55:51 <alexyk> dons: is your thesis online? :)
19:55:59 <dons> well, i'll be back later in the year, and will drop by to see everyone
19:56:04 <dons> alexyk: yeah, on my pubs. page 
19:56:12 <alexyk> fun fun
19:56:35 <ivanm> dons: make sure you let us know when, esp. if you're going to talk at fp-syd or something so that Axman6 and I can book transport + accom
19:56:52 <tolkad> > [1,2..]++[2,4..]
19:56:53 <dons> ivanm: yeah, i'll do fp-syd
19:56:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:57:05 <tolkad> wait what?
19:57:07 * ivanm grumbles about finding out that fp-syd is the night before AusHac after he's booked transport + accom
19:57:10 <tolkad> how is that valid...
19:57:18 <ivanm> tolkad: because infinte lists are valid...
19:57:25 <ivanm> so it never gets to the end of the first one
19:57:33 <soupdragon> what
19:57:44 <ivanm> oh, the syntax?
19:57:49 <alexyk> where is printf?
19:57:54 <ivanm> > [1,11,..]
19:57:55 <lambdabot>   <no location info>: parse error on input `..'
19:57:55 <dons> Text.Printf
19:57:59 <soupdragon> (++) :: [a] -> [a] -> [a] that's why
19:58:00 <ivanm> @hoogle printf
19:58:00 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
19:58:00 <lambdabot> module Text.Printf
19:58:00 <lambdabot> Text.Printf class PrintfArg a
19:58:01 <alexyk> kk
19:58:03 <dons> > printf "%d" (7 :: Int)
19:58:04 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:58:04 <lambdabot>    `GHC.Show.Show a'
19:58:04 <lambdabot>      a...
19:58:07 <dons> > printf "%d" (7 :: Int) :: String
19:58:09 <lambdabot>   "7"
19:58:14 <dons> (polymorphic return)
19:58:19 <tolkad> hmm, does haskell have a function to check if a list contains a number?
19:58:23 <ivanm> printf is _weird_
19:58:25 <ivanm> tolkad: elem
19:58:30 <ivanm> > 5 `elem` [1..]
19:58:31 <lambdabot>   True
19:58:35 <sshc> Who validates Hackage packages?
19:58:39 <pizza_> > length [0..]
19:58:41 <ivanm> sshc: "validates" ?
19:58:44 <lambdabot>   mueval-core: Time limit exceeded
19:58:44 <ddarius> sshc: No one.  No one at all.
19:58:56 <tolkad> > 1 `elem` [2,3..]++[1]
19:58:58 <ivanm> sshc: hence some uploading problems ;-)
19:59:00 <lambdabot>   mueval-core: Time limit exceeded
19:59:09 <ivanm> tolkad: infinte list; it'll never get to the 1
19:59:25 <dons> sshc: validates in what sense?
19:59:41 <ivanm> there are some pre-done checks as part of the upload scripts, that's about it
20:00:12 <sshc> dons: Who or what checks for malicious or broken packages?
20:00:20 <dons> sshc: the Haskell Platform validates a small subset of Hackage: http://trac.haskell.org/haskell-platform/wiki/AddingPackages
20:00:21 <pizza_> ivanm: so what? valid programs can contain infinite loops
20:00:41 <technogeeky> I think this idea has been expressed before in other terms, but in my own: the volume, density, and clarity of information transfer between experts and non-experts is higher in this channel than any other I've ever seen (for any language or software irc).
20:00:42 <ddarius> sshc: Not just anyone can upload, but no particular person does.
20:00:47 <tolkad> ivanm: yeah, I was wondering if it would do some crazy compile-time checking that would allow it to realize it was in the second list
20:00:49 <dons> sshc: some are borken. if they're obviously malicious, they're removed. only registered users are allowed, and we vet the identities
20:01:03 <dons> technogeeky: we try
20:01:15 <technogeeky> It's pretty amazing.
20:01:26 <sshc> dons: Has any malicious package ever been removed before?
20:01:38 <dons> someone accidentally uploaded a package with the wrong name
20:01:39 <technogeeky> I wonder if one could do a case study to see why. Certainly more toward the humanities or social sciences.
20:01:44 <dons> clobbering a more famous package. that's the worst.
20:01:59 <dons> technogeeky: we've had very strict rules about friendliness since 2002
20:02:03 <ddarius> dons: We take the "firehose" approach. (re response to technogeeky)
20:02:32 <dons> technogeeky: http://haskell.org/haskellwiki/IRC_channel#Principles
20:02:40 <sshc> ddarius: What is the "firehose" approach?
20:02:51 <alexyk> does setting no monomorphism restriction degrade performance at all?
20:02:58 <dons> alexyk: not really.
20:03:04 <dolio> It's the opposite of the wheel of fish approach.
20:03:11 <dons> alexyk: but its better to give explicit type signatures
20:03:12 <ddarius> sshc: Uploading a malicious package would have little payoff.  It would be recognized very quickly.
20:03:31 <alexyk> dons: I'm wrapping Binary's load/save 
20:03:38 <alexyk> so I dunno types
20:03:51 <dons> encode/decode?
20:03:58 <alexyk> yep
20:03:59 <sshc> dons: So, anybody registered users can upload any package, which are not enqueued, and anybody can register and start uploading immediately, right?
20:04:13 <kmc> technogeeky, i particularly like that there's no sharp line between experts and non-experts.  everyone can learn and everyone can teach
20:04:14 <dons> sshc: not quite. they have to register via email
20:04:18 <dons> sshc: which gets vetted offline
20:04:38 <kmc> it's extremely gratifying to see a total beginner join, show them a few things, and then see them start answering questions from others
20:04:41 <dons> the new hackage 2.0 has tighter security mechanisms, and will debut soon.
20:05:41 <sshc> There *really* needs to be an equilavnt package binary of the binary packge that sanitizes or validates input.
20:05:47 <kmc> i'm not totally sure why, but an abnormally high proportion of people who join to ask a quick question end up sticking around as lurkers
20:06:02 <dons> sshc: there's one that wraps them in typeOf
20:06:12 <dons> so it does a form of dynamic typing on the wire values
20:06:24 <sshc> dons: What wraps what?
20:06:35 <dons> the Binary values are wrapped in Dynamic
20:06:53 <dons> so they're serialized with a reified type
20:06:56 <tolkad> > succ pi
20:06:58 <lambdabot>   4.141592653589793
20:07:12 <tolkad> umm, that's wrong
20:07:17 <pizza_> @src succ
20:07:17 <dons> > pi
20:07:18 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:07:18 <lambdabot>   3.141592653589793
20:07:23 <dons> > pi + 1
20:07:24 <lambdabot>   4.141592653589793
20:07:51 <Rotaerk> > pi / 0
20:07:52 <lambdabot>   Infinity
20:08:18 <sshc> dons: Will I need a separate package?
20:08:45 <dons> sshc: yes, but i forget the name.
20:08:56 <sshc> dons: Will it handle input that is too short?
20:09:01 <sshc> Perhaps empty?
20:09:07 <dons> sshc: you're worried the type will be wrong? or the input is corrupted?
20:09:37 <sshc> dons: I'm worried that the input could be corrupted.
20:10:01 <dons> the type thing won't help then ,since the type could also be corrupted.
20:10:13 <sshc> Primarily input that is too short.
20:10:19 <dons> i don't know a general way to prevent corrupted data. but you might consider writing a custom parser based on Data.Binary
20:10:24 <tolkad> is there a way to specify precision?
20:10:27 <dons> that checks the lengths, with checksums etc.
20:10:33 <ddarius> Specifically the Get monad.
20:10:59 <ezyang> TCP/IP protections not enough? ;-) 
20:11:20 <sshc> I only need to worry about input that is too short.
20:11:52 <sshc> Does the functionality exist, or will I need to write it myself?
20:11:52 <dons> ezyang: have you read http://xmonad.wordpress.com/2009/09/09/the-design-and-implementation-of-xmonad/ 
20:11:59 <dons> ezyang: strong inspiration from MVC
20:12:36 <ddarius> A variant of MVC is pretty common in Haskell programs.
20:12:55 <dons> yeaah, not sure when we first noticed it. but its pretty common
20:13:56 <sshc> dons: Does the functionality for checking the length of input exist, or will I need to write it myself?
20:15:01 <dons> no, it is part of Data.Binary
20:15:04 <dons> and Data.ByteString
20:15:08 <technogeeky> I had some disagreements with ezyang's article
20:15:10 <kmc> tolkad, precision of what?
20:15:18 <technogeeky> but it is a useful starting point.
20:15:20 <dons> sshc: cereal has very good support
20:15:31 <dons> sshc: you might use it. it can enforce that only a certain number of bytes are read
20:15:36 <dons> and if they're not, you get a Left error
20:15:38 <technogeeky> > 2pi
20:15:39 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:15:39 <lambdabot>    `GHC.Float.Floating a'
20:15:39 <lambdabot>   ...
20:15:41 <technogeeky> >2 * pi
20:15:55 <technogeeky> > 2 * pi
20:15:56 <lambdabot>   6.283185307179586
20:16:45 <tolkad> kmc: number of digits
20:16:49 <kmc> tolkad, of what?
20:17:19 <tolkad> kmc: anything, for example "sqrt 7" or "pi"
20:17:25 <ivanm> dons: I suppose that if you're going to do a new platform release soon and I want this bug-fixed version of fgl in I should join the libraries mailing list?
20:17:33 <kmc> tolkad, lambdabot is defaulting those to the type Double
20:17:36 <dons> tolkad: you want fixed precision in output, or in the computation itself?
20:17:39 <sshc> dons: No to what?  What's the antecedent of "it"?  I'm a bit tired; sorry for the confusion.
20:17:40 <kmc> > pi :: Float
20:17:41 <lambdabot>   3.1415927
20:17:44 <tolkad> dons: output
20:17:49 <dons> oh, Text.Printf
20:18:03 <dons> > printf "%2f" (pi :: Double) :: String
20:18:04 <lambdabot>   "3.141592653589793"
20:18:08 <dons> > printf "%.2f" (pi :: Double) :: String
20:18:10 <lambdabot>   "3.14"
20:18:12 <technogeeky> re: kmc: i particularly like that there's no sharp - yes, in this regard I misspoke. I meant those with the relevant answers and those seeking relevance at all
20:18:28 <kmc> technogeeky, i didn't mean to correct you
20:18:30 <dons> sshc: cereal has good functions for checking input.
20:18:34 <kmc> i agree with what you said :)
20:18:35 <technogeeky> kmc: I did
20:18:37 <technogeeky> :)
20:18:38 <kmc> :)
20:18:58 <technogeeky> I do think the lambdabot is probably a key component of it
20:19:03 <technogeeky> Just having been in this chatroom 3 or 4 days
20:19:04 <tolkad> I heard haskell has arbitrary size integers so I assume it has arbitrary size rational numbers
20:19:15 <dolio> > pi :: CReal
20:19:16 <lambdabot>   3.1415926535897932384626433832795028841972
20:19:25 <kmc> tolkad, it does.  the Data.Ratio module provides them
20:19:37 <sshc> dons: cereal seems sufficient for my use.  Thanks!
20:19:40 <dolio> pi isn't rational, though.
20:19:47 <technogeeky> dons: do you recall me asking you in one medium or another about apollonian fractals?
20:19:47 <ivanm> tolkad: rational, yes
20:19:51 <ddarius> @src Rational
20:19:51 <lambdabot> type Rational = Ratio Integer
20:19:53 <ivanm> > 1%100000000000000000000000000000
20:19:54 <lambdabot>   1 % 100000000000000000000000000000
20:19:57 <kmc> tolkad, there are also libraries like HERA for representing arbitrary computable real numbers
20:20:03 <kmc> which has other caveats
20:20:13 <ivanm> > pi :: Rational
20:20:14 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
20:20:14 <lambdabot>    arising from a us...
20:20:16 <ivanm> awwww
20:20:17 <dons> sshc: the 'isolate' function, in particular, http://hackage.haskell.org/packages/archive/cereal/0.2/doc/html/Data-Serialize-Get.html#v%3Aisolate
20:20:27 <dons> sshc: ensure only exactly the right amount of data is consumed
20:20:40 <kmc> in this world there's a tremendous amount of thought and effort put towards figuring out how to do collaborative, distributed, technology-mediated education
20:20:42 <ivanm> > toRational pi :: Rational
20:20:43 <lambdabot>   884279719003555 % 281474976710656
20:20:45 <dons> technogeeky: nope.
20:20:53 <kmc> and i think #haskell is a good example of a fairly minimal system that works very well
20:21:24 <ivanm> dons: did you have a chance to look through my pro-fgl arguments on the wiki by any chance?
20:21:46 * ddarius points kmc at http://alistair.cockburn.us/Characterizing+people+as+non-linear,+first-order+components+in+software+development (probably not the first time he's read it)
20:21:54 <monochrom> lambdabot is crucial to this channel. just look at what happened earlier today: lambdabot was away for a few hours and most people immediately failed in very basic logic.
20:22:02 <kmc> ddarius, it's not -- great article
20:22:07 <dons> ivanm: yeah, i read them.
20:22:07 <tolkad> > 2 `pow` (pi * i)
20:22:08 <lambdabot>   Not in scope: `pow'
20:22:10 <kmc> hahaha monochrom
20:22:10 <sshc> What happened?  13:08:57 -!- lambdabot [~lambdabot@li85-105.members.linode.com] has quit [Killed (idoru (Spam is off topic on freenode.))
20:22:11 <dons> ivanm: weeks ago...
20:22:13 <ivanm> heh
20:22:15 <tolkad> > 2 ^ (pi * i)
20:22:22 <lambdabot>  Terminated
20:22:27 <tolkad> Who?
20:22:32 <ivanm> dons: because every time I asked for your opinions on them you said you were busy ;-)
20:22:36 <technogeeky> kmc: well, it's a strong indicator, in my mind, that interactivity and the mentorship relationship are still very effective means of communicating complex ideas.
20:22:40 <tolkad> > 2 ^ (pi * i)
20:22:41 <kmc> yes
20:22:46 <lambdabot>   mueval: ExitFailure 1
20:22:49 <kmc> i like that the technology here is really lightweight
20:22:52 <tolkad> > 2 ^ (pi * i)
20:22:58 <lambdabot>   mueval: ExitFailure 1
20:23:00 <ivanm> tolkad: that doens't even type check
20:23:08 <ivanm> > exp (pi * 0:+1)
20:23:09 <kmc> i mean we're using a 22-year-old protocol
20:23:10 <lambdabot>   0.5403023058681398 :+ 0.8414709848078965
20:23:15 <kmc> the most primitive text chat you can find
20:23:24 <ivanm> > exp (pi * (0:+1))
20:23:25 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
20:23:30 <ivanm> that's better
20:23:37 <dolio> > exp (0 :+ pi)
20:23:38 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
20:23:42 <ivanm> > exp (pi * (0:+1)) :: Complex CReal
20:23:42 <lambdabot>   (-1.0) :+ 0.0
20:23:45 <ivanm> \o/
20:23:49 <pizza_> man talk
20:23:58 <kmc> haha pizza_
20:24:18 <kmc> re this MVC connection, i think there are probably tons of connections between common FP practice and common "mainstream programming" practice, which are somewhat obscured by differing terminology
20:24:39 <tolkad> irc: http://www.youtube.com/watch?v=O2rGTXHvPCQ
20:24:55 <ddarius> kmc: Look at dependency injection
20:25:18 <kmc> and that's part of why i get annoyed when people try to build a large wall between the two domains
20:25:18 <joed> Heh
20:25:21 <dolio> Don't forget to create a GUI interface using Visual Basic.
20:25:52 <joed> kmc: Why would the result differ?
20:26:19 <kmc> result of what?
20:26:25 <joed> IOC and DC are 60's concepts.
20:26:57 <technogeeky> what?
20:27:13 <technogeeky> IOC? DC? 60's?
20:27:36 <joed> Inversion of conrol and Dependency Injection
20:28:05 <dolio> injeCtion?
20:28:27 <joed> Call it callbacks.
20:28:29 <monochrom> what is dependency injection? (should I just google?)
20:28:47 <ddarius> monochrom: It's parameterization, but definitely google as well.
20:29:10 <monochrom> wikipedia begins with "This article may be too technical for most readers to understand" haha
20:29:13 <technogeeky> either way; those are terms used to describe the structure of the MVC amongst itself, no? Those terms aren't necessarily the correct ones to compare "pure/impure" vs "modelview/controller"
20:29:19 <technogeeky> as ezyang's article did
20:29:49 <joed> MVC is also stupid in as it evolved.
20:30:17 <technogeeky> i didn't grok that perfectly, but many implemntations of MVC are terribly briandead.
20:30:22 <ivanm> monochrom: quick, get the editors in to randomly delete chunks until it's understandable!
20:30:34 <technogeeky> And it's really only used because it's deceptively familiar.
20:30:50 <ddarius> monochrom: Go to simple.wikipedia.org
20:30:52 <technogeeky> anyway, I had a problem with ezyang's article
20:30:58 <technogeeky> but I can't quite put my finger on it yet.
20:31:07 <joed> technogeeky: Huh?
20:32:06 <technogeeky> joed: I don't think it's an obvious fact that, using his analogy, that views should be pure functions.
20:33:33 <joed> technogeeky: I;d be the last person to answer that question but also the first to say that you are fitting a ocean liner into the square hole?
20:33:52 <joed> an*
20:33:52 <technogeeky> No, he was.
20:33:59 <joed> Heh
20:34:30 <technogeeky> I am choosing to haphazardly continue with an analogy which is.. stretched.
20:34:31 <technogeeky> ;)
20:34:52 <augur> if types are equivalent to propositions, and members of the type are equivalent to proofs of the relevant proposition, then what proposition is Int such that 1 is a proof of Int? :|
20:35:14 <dolio> Int is a true proposition.
20:35:24 <augur>  /any/ true proposition?
20:35:26 <dolio> With 2^32 (or 64, or ...) proofs.
20:35:48 * technogeeky feels suddenly uneasy
20:35:53 <augur> how do you go in the other direction, taking propositions to types?
20:35:56 <augur> or does it not matter?
20:36:36 <ddarius> monochrom: I "recommend" http://martinfowler.com/articles/injection.html
20:36:57 <augur> ddarius! :D
20:36:59 <augur> hello.
20:37:09 <dolio> The other direction probably makes more sense than asking what proposition thing like Int are.
20:37:25 <dolio> Because all simple types like that are just variations on true.
20:37:37 <augur> ok
20:37:56 <dolio> But, the function space is implication, for instance.
20:37:59 <ddarius> There's actually a slight difference, for most logics, that makes CH a correspondence (an embed-project pair to be formal) and not a strict isomorphism, namely proof irrelevance.
20:38:02 <augur> right
20:38:31 <augur> im just curious what it would mean to encode a normal sort of proposition into a type, and how that would actually work out to be useful
20:38:32 <dolio> Something like () would be the regular true. An empty type would be false...
20:38:50 <dolio> Conjunction is product, disjunction is sum.
20:39:00 <ddarius> There are two ways of proving A and A implies A.  For the purposes of logic, we don't care which proof is used, only that some proof exists.  For programming we do care very much which proof is used.
20:39:52 <joed> Heh
20:41:12 <augur> hmm
20:41:45 <tolkad> Does haskell have named arguments?
20:42:26 <monochrom> no
20:43:06 <tolkad> How do you make a view a "pure function" then?
20:43:07 <edwardk> tolkad: not directly, but you can cheat
20:43:31 <tolkad> using haskell's version of dict/hashtable/whatever it's called?
20:43:44 <edwardk> you can make a function that takes a record if you want the sort of ad hoc named arguments you're used to
20:43:54 <edwardk> Data.Map is one common one
20:44:24 <edwardk> tolkad: example of record based options: http://stackoverflow.com/questions/2819652/how-would-you-write-this-clojure-snippet-in-ruby-and-or-haskell/2820283#2820283
20:45:32 <ddarius> http://web.archive.org/web/20061011094943/http://haskell.org/hawiki/UsingRecords
20:45:51 <tolkad> > let b = [b]
20:45:53 <lambdabot>   not an expression: `let b = [b]'
20:46:41 <philosopher> what is the recommended haskell editor on linux ?
20:47:04 <edwardk> philosopher: vi *cough* or if you want ide-like things, leksah
20:47:17 <dolio> augur: Also, the sort of quantifiers you see with rank-n types correspond to quantifiers in the logic, but they're second-order and higher (quantifying over types). Dependent types correspond to first-order quantification and predicates.
20:47:29 <philosopher> any of those does type inference ?
20:47:40 <philosopher> like textMate on MacOs ?
20:47:43 <edwardk> philosopher: iirc, leksah does
20:48:12 <edwardk> i've used it for type-ahead/intellisense-like stuff when helping someone else, but i don't know how well it handles types
20:48:12 <augur> hmm
20:49:02 <Veinor> MasseR: hey #haskell, how bad is it considered if I declare a type to be an instance of Ord but make compare behave  badly?
20:49:25 <edwardk> Veinor: typically pretty bad. trying to get min and max?
20:49:35 <edwardk> compare is the canonical thing folks reach for in Ord
20:49:53 <philosopher> and what is the recommended lib for graph manipulation 
20:49:55 <philosopher> if any
20:49:56 <edwardk> Veinor: (or have a partial order?)
20:50:03 <edwardk> philosopher: fgl
20:50:20 <edwardk> philosopher: if you only need a few things there is Data.Graph in containers as well
20:50:37 <Veinor> aw :(
20:50:56 <Veinor> I want to do games, which can have four relations: <, ==, >, or ||
20:51:00 <mjk> how not to show :10^^10=1.0e10
20:51:02 <Veinor> so Ord won't really work for that.
20:51:13 <edwardk> Veinor: then make up a partial ordering class
20:51:19 <mjk> to show 10000000000
20:51:23 <edwardk> Veinor: sadly haskell doesn't provide one =/
20:51:32 <philosopher> i tought fgl was no longer maintain 
20:51:48 <edwardk> philosopher: ivanm picked it up it has an active maintainer and is in the haskell platform
20:51:53 <edwardk> so it isn't going away any time soon
20:51:55 <Veinor> aw :/
20:52:10 <Veinor> so I'm going to have to come up with my own symbols for comparison
20:52:38 <Veinor> lt and gt?
20:52:52 <edwardk> Veinor: or steal the normal ones, and instantiate your partial order class for all the types you care about
20:53:04 <edwardk> i tend to use <=? ==?, etc
20:53:23 <edwardk> have have whatever the compare-like function is return Maybe Ordering
20:53:27 <Veinor> hm
20:53:47 <Veinor> well, 'fuzzy' is an ordering in that it means something specific :D
20:54:07 * Veinor ponders
20:54:24 <edwardk> and then you'd like || for incomparable, but Boolean gets in the way. ;)
20:54:29 <Veinor> |||
20:54:40 <Veinor> yes, I know that's in use too
20:54:47 <Veinor> I could just do <? and such
20:54:51 <edwardk> but less commonly so and probably not in your code
20:54:52 <ddarius> You could use <>
20:55:12 <edwardk> ddarius: until you go to import the next major release of Data.Monoid ;)
20:55:34 <ddarius> edwardk: It's not going to shadow (++) ?
20:55:45 <Veinor> yeah, I'm not going to be using ||| in my code
20:56:02 <edwardk> ddarius nah the libraries@ guys settled on <>. ++ is ambiguous in terms of how to generalize: to Monoid or MonadPlus.
20:56:09 <edwardk> and it was MonadPlus before 98.
20:56:26 <edwardk> so it would have gone through 3 contradictory meanings in short order ;)
20:56:55 <ddarius> Perhaps I'm still young, but 12+ years doesn't seem like "short order."
20:56:59 <edwardk> =)
20:57:02 <Veinor> I could have compare return EQ if they're equal or Fuzzy
20:57:22 <Veinor> since 'fuzzy' means 'is very close to' :P
20:57:43 <edwardk> Veinor: let me dig up what i use
20:57:56 <Veinor> cool
20:58:12 <Veinor> I want to be able to use < and > with Games, but I guess I could settle for <? and >?
20:58:29 <edwardk> Veinor: see 'certainly' and 'possibly' for ideas http://github.com/ekmett/intervals/blob/master/Numeric/Interval.hs
20:58:31 * ddarius realized just now that Category could be used for type-level pre-order.
20:58:45 <edwardk> ddarius: yep
20:59:12 <Veinor> neat
20:59:19 <kmc> you could use âˆ¥ for "incomparable"
20:59:23 <edwardk> the discrete category in 'categories' uses it to provide equality constraints
20:59:32 <Veinor> right, right
20:59:38 <Veinor> but that would be confusing
20:59:45 <Veinor> so I think I'll go with |||
20:59:52 <Veinor> or... ||?
21:00:07 <edwardk> ||? fits if you're using the ?'s elsewhere
21:00:08 <ddarius> #
21:00:14 <Veinor> also, <||?, ||>?, <>?
21:00:19 <ddarius> The apart relation is often written using #.
21:00:32 <edwardk> ddarius: # is pretty scary if you import GHC.Prim though
21:00:52 <ddarius> Why would you be importing GHC.Prim?
21:01:00 <edwardk> why wouldn't you? =)
21:01:12 <edwardk> Int# is your friend
21:01:22 <Veinor> I like #
21:01:31 <alteregoa> how long does it take for a mexican woman to put out the garbage?
21:01:46 <Veinor> minute or so, depending on how far she has to walk
21:01:51 <alteregoa> 9 months
21:01:55 <ddarius> I think this person can be kicked immediately.
21:01:58 <kmc> zing!
21:02:14 <edwardk> alteregoa: not exactly the right forum for that
21:02:30 <Veinor> anyway... I think it's good that I'm not going to be declaring an Ord instance
21:03:32 <Veinor> although I could have compare x y | x == y || x # y == EQ so I can sort
21:04:07 <alteregoa> !seen Rodney_munch
21:04:15 <Veinor> but that seems vaguely.... bad
21:04:40 <Veinor> because it breaks the contract that compare x y == EQ implies x == y
21:04:57 <ddarius> Veinor: If you stick your things into a Map or Set, bad things are likely to happen.
21:05:02 <edwardk> Veinor: use sortBy
21:05:07 <ddarius> (Well, use as keys to the Map)
21:05:12 <Veinor> yeah.
21:05:30 <Veinor> damn partial orderings >:/
21:05:42 * ddarius likes partial orderings.
21:05:48 <augur> hrmph
21:05:52 * ddarius wishes we had a standard partial ordering class.
21:05:57 <Veinor> I should write one!
21:05:57 <augur> i dont think i properly grasph the summation type
21:06:01 * edwardk is annoyed haskell doesn't have a partial ordering class between eq and ord
21:06:35 <Veinor> the only difference would be that compare could return INcomparable, right?
21:07:12 <Veinor> alternately, that it returns a Maybe Ordering
21:07:55 <ddarius> I'd probably use Maybe Ordering for ease of mixing total and partial orders.
21:08:25 <Veinor> and you could obviously derive (Ord a) => (PartialOrd a)
21:08:51 <ddarius> Also I imagine incomparable elements would often be an "off" case anyhow.
21:08:51 <edwardk> Veinor: yeah but you can't make that instance directly you need to make everyone define it themselves or you descend into incoherent overlapping instance hell
21:09:14 <Veinor> edwardk: ?
21:09:18 <ddarius> Incoherent, overlapping instance hell is where edwardk keeps his winter home.
21:09:28 <Veinor> you can't say 'everything in this typeclass is in that typeclass'?
21:09:36 <ddarius> No, you can't.
21:09:50 <edwardk> you can define pcompareDefault :: Ord a => a -> a -> MaybeOrdering -- and then say things like instance POrd Int where pcompare = pcompareDefault, etc.
21:10:00 <ddarius> You'd have: class PartialOrd a => Ord a where ...  (note the => is misleading here)
21:10:44 <Veinor> blah
21:10:53 <edwardk> but if you say instance Ord a => POrd a -- you are saying that all partial orders are orders (!) and this is the only way they get derived (because you've consumed the entire 'pattern' for the instance head). the implications are handled in reverse by pattern matching from what you need to what you need to get that
21:11:05 <edwardk> that probably got clipped
21:11:16 <Veinor> 'need to get that'
21:11:33 <ddarius> edwardk: Why don't you set your client to break lines for you again?
21:12:23 <edwardk> ah then it made it. the usual idiom is to define the prelude instances of your class, and define some kind of newtype WrappedOrd a = WrapOrd { unwrapOrd :: a }; instance Ord a => POrd (WrappedOrd a) where ...
21:12:23 <Veinor> I don't get how saying instance Ord a => POrd a is saying that all partial orders are orders?
21:12:27 <Veinor> isn't it the other way around?
21:12:35 <edwardk> yes and no
21:13:11 <edwardk> the problem is the pattern matching happens on the right. the compiler sees that you need a POrd, so it looks through the rolodex of instance it has, treating the right hand side of the instances like a case statment
21:13:14 <edwardk> pattern
21:13:46 <edwardk> so if you have instances Foo (Bar a) and Foo (Baz a) -- and you need an instance for (Bar Quux) -- it pattern matches and uses the Foo (Bar a) instance for it
21:13:59 <edwardk> it then goes and looks at the left side of the =>
21:14:02 <edwardk> AND NEVER BACKTRACKS
21:14:10 <edwardk> that is the key issue
21:14:43 <edwardk> when you say instance Foo a => Bar a -- the 'a' pattern is the most general pattern, there isn't any other pattern you can give that doesn't overlap it
21:15:09 <edwardk> so when you go looking for an instance for Bar, the compiler looks through its rolodex, finds one entry 'a' and dispatches to that
21:15:38 <edwardk> (overlapping instances muddle this a bit and try to apply a bit of a partial ordering to the terms, but they are fragile and easily break when you import modules into scope that add them)
21:16:11 <edwardk> it is counter-intuitive as all hell, but thats the way it works. it makes sense if you think of it from a compiler design rather than a logical implication perspective
21:16:32 <Veinor> I... did not understand that :(
21:16:45 <edwardk> (for that matter the notation of classes is backwards from an implication perspective class Foo a <= Bar a  would be more correct
21:17:27 <edwardk> lets say you are looking for an instance for Ord [[[Char]]]
21:17:42 <Veinor> okay
21:17:44 <edwardk> the compiler has a bunch of instances heads lying around. it has one for Char, one for Int, etc.
21:17:52 <edwardk> and it has one funny instance for instance Ord a => Ord [a]
21:18:11 <Veinor> right.
21:18:11 <edwardk> it pattern matches [[[Char]]] against those instance heads
21:18:17 <edwardk> and chooses the Ord [a] one
21:18:22 <augur> yeah im really not grasping these product and sum types all that well
21:18:32 <Veinor> cause it's the only one that matches, right?
21:18:34 <edwardk> so now a = [[Char]], and then it goes and tries to find an instance of Ord [[Char]]
21:18:38 <augur> oh well.
21:18:42 <edwardk> correct
21:19:03 <edwardk> for which it pattern matches with a = [Char], and then it does it again with a = Char, finding the instance Ord Char dictionary that time
21:19:19 <Veinor> gah, be right back
21:20:21 <edwardk> but it can't backtrack during this process, so if you have multiple overlapping instances, where the LHS of the instance head may or may not be present for all of them, you can get screwed and get inconsistent results, fail to find the more specific instance, etc. ;)
21:20:33 <edwardk> k
21:21:26 <edwardk> anyways, Ord instances are already a bit busted in Haskell 98:
21:21:28 <edwardk> > let n = 0/0 :: Double in (n `compare` n, n < n, n == n, n > n)
21:21:30 <lambdabot>   (GT,False,False,False)
21:22:08 <edwardk> so the incomparable elements just return GT for Double and Float
21:22:17 * Veinor returns
21:22:17 <edwardk> if you're looking for an unfortunate model to try to emulate
21:22:25 <dolio> That's due to the default definition, I think.
21:22:32 <edwardk> dolio: yeah
21:22:36 <Veinor> anyway
21:22:47 <edwardk> just threw it out there as a devil's advocate position after all the above ;)
21:23:15 <Veinor> the other thing I realized is that if you allow (Foo a) => (Bar a)
21:23:19 * hackagebot extcore 0.9.1 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-0.9.1 (TimChevalier)
21:23:20 <Veinor> then you can also do (Bar a) => (Foo a)
21:23:25 <edwardk> Veinor: so now consider your proposed instance Ord a => POrd a -- when you also have some instance POrd Foo
21:23:34 <Veinor> anyway
21:23:35 <Veinor> yeah
21:23:53 <edwardk> a subsumes Foo, so you need overlapping instances to define anything new
21:24:17 <edwardk> but if you go to get a dictionary for Foo in a context where the dictionary for Foo isn't in scope, you won't just not find it, you'll find a _different_ dictionary.
21:24:21 <Veinor> ahh, so as long as Foo is Ord, then I'll need overlapping instances to define my own custom POrd Foo?
21:24:38 <edwardk> no, regardless of if Foo is Ord
21:24:56 <edwardk> the check for POrd a doesn't backtrack if 'a' isnt an instance of Ord!
21:25:01 <edwardk> it just craps out and complains
21:25:07 <Veinor> ahh!
21:25:11 <dolio> The constraint has no effect on the instances declared.
21:25:39 <edwardk> the compiler just looks at the instance heads with no regards to the bodies when choosing which one to dispatch each site to
21:25:49 <dolio> It's the same as 'instance POrd a ...', except it blows up when there's no Ord a instance.
21:25:54 <edwardk> otherwise you'd need some pretty hairy global reasoning
21:26:05 <dolio> And as a consequence you get to use Ord methods in the definition of the POrd.
21:27:35 <edwardk> the non-backtracking behavior is in general more sound, and easier to reason about, exponentially faster, and allows separate compilation, where the alternative requires global reasoning and backtracking
21:27:39 <Veinor> man, the type system can be a real pain sometimes ;)
21:27:54 <edwardk> Veinor: well, the alternative is to go over to ML where you just have to do all the plumbing yourself
21:28:16 <Veinor> yeah, I'm just joking
21:28:23 <Veinor> the type system is really cool except when it bites you
21:28:25 <edwardk> after a while doing that you come back on your knees begging the compiler to take you back ;)
21:28:48 <Veinor> are you sure you don't have battered coder syndrome?
21:28:56 <Veinor> "i'm sure the compiler loves me, he really does!"
21:28:56 <edwardk> Please GHC, take me back! I'm a changed man! It'll be different this time, I swear!
21:29:59 <edwardk> Lets just say that I love Haskell and all her faults. I just try not to be blind to them. ;)
21:30:08 <dolio> You could move to Coq, where you get to program the checker somehow, I think.
21:30:21 <Veinor> oh yeah, haskell is a girl
21:30:25 <ddarius> edwardk: Wouldn't you be happier blind to them?
21:30:42 <edwardk> ddarius: ignorance is not bliss ;)
21:30:44 <ddarius> "Ignorance is bliss"
21:30:59 <ddarius> edwardk: My solution to that is always that you simply need more ignorance.
21:31:23 <edwardk> this is a vicious spiral that tends to wind up with you face down drunk in a ditch somewhere ;)
21:31:43 <Veinor> oh, shit
21:32:06 * ddarius doesn't think Mr. Curry would appreciate being called a girl.
21:32:23 <Veinor> I just realized, the natural definition of a game is Game = Zero | Game (Set Game) (Set Game)
21:32:34 <edwardk> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
21:32:47 <Veinor> and... you need Ord to do much of anything with a Set :/
21:32:47 <ddarius> Veinor: Just find a Surreal number module.
21:32:55 <Veinor> ddarius: that's what I'm trying to write! :P
21:33:09 <Veinor> well, for Games
21:33:27 * Veinor ponders this dilemma.
21:33:31 <ddarius> edwardk: I was thinking about linking that earlier but decided against it.
21:33:33 <edwardk> Veinor:  you can build a set type that uses set for the comparable things and lists of disjointed sets since you can compare elementwise, as long as you have transitivity
21:33:43 <Veinor> is there a way to... not export the Ord instance for Game?
21:33:54 <edwardk> Veinor: no instances are infectious
21:34:01 <tolkad> Does haskell have a powerset function?
21:34:11 <Veinor> 'incomparableness' is not transitive though
21:34:18 <edwardk> "local instances" could cause inconsistencies
21:34:25 <Veinor> 0 is incomparable with * and ^*, but ^* > *
21:35:14 <edwardk> Veinor: yes, but the remaining operators are so if you have a list of sets of mutually comparable 'a's. then you can walk down the list checking them all for membership
21:35:22 <Veinor> hm
21:35:29 <Veinor> this would require me to write my own Set implementation
21:35:37 <edwardk> the location in the list of sets will be variable, but the presence or absence can still be tested
21:35:38 <edwardk> yes
21:35:59 <Veinor> this is not going to be pleasant.
21:36:24 <dolio> If you're talking about Data.Set, those are finite sets.
21:36:31 <tolkad> I want to see how "length (powerSet [1,2..])" represents |R|
21:36:35 <edwardk> Veinor: depending on your needs you can turn to something like: http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
21:36:37 <Veinor> I don't care about infinite sets right now
21:36:55 <tolkad> so, what's haskell's powerset function?
21:37:44 <ddarius> length (powerSet [1,2..]) is an infinite loop for any reasonable definition of 'powerSet'
21:37:57 <tolkad> uh... no
21:38:19 <Veinor> > let powerset (x:xs) = powerset xs ++ map (x:) (powerset xs) in powerset [1,2,3,4]
21:38:21 <lambdabot>   *Exception: <interactive>:1:149-203: Non-exhaustive patterns in function po...
21:38:30 <tolkad> the cardinality of the power set of the natural numbers is |R|
21:38:37 <edwardk> > filterM (const [True, False]) [1,2,3,4]
21:38:38 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
21:38:42 <ddarius> tolkad: Which has nothing to do with Haskell.
21:38:53 <Veinor> edwardk: oh, if you want to be all fancy monadic about it!
21:39:02 <tolkad> ddarius: Isn't the haskell compiler smarter enough to figure such things out?
21:39:25 <ddarius> tolkad: The real numbers are uncountable.  There is no way to represent the totality of them with a computer.
21:39:25 <edwardk> > filterM (const [minBound,maxBound]) [1..4]
21:39:26 <lambdabot>   [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,...
21:39:44 <edwardk> -- if you want to be even less obvious about it ;)
21:39:48 <tolkad> ddarius: yes, but it doesn't need to do that to answer what I asked of it
21:40:15 <ddarius> tolkad: I'm going to go read a book now, feel free to continue without me.
21:40:23 <edwardk> tolkad: sadly, it does.
21:40:45 <edwardk> tolkad: the reals aren't computable you'll never finish computing the set in question
21:40:47 <Veinor> tolkad: if I give you a list that's not guaranteed to terminate, how can you tell if it does?
21:40:51 <tolkad> edwardk: Only if it tries to iterate to calculate the length
21:41:03 <Veinor> @src length
21:41:03 <lambdabot> Source not found. You untyped fool!
21:41:07 <tolkad> It knows what the list contains because it put it there
21:41:24 <dolio> No, you know what the list contains.
21:41:28 * edwardk heads off to hack on luthor
21:41:33 <tolkad> the haskell comiler does too
21:41:43 <tolkad> compiler*
21:42:10 <edwardk> i now have an 'integer floating point' based character set put together, and dictionaries to look up posix and unicode character classes.
21:43:26 <Veinor> tolkad: okay, suppose that it couldn't know that in advance
21:44:07 <Veinor> I mean, the definition of length is length [] = 0; length (_:xs) = 1 + length xs
21:44:18 <Veinor> okay, that's not true, because of tail recursion optimization and stuff. but it's close enough!
21:45:53 <tolkad> how do I map a function with two arguments?
21:46:04 <edwardk> @type zipWith
21:46:07 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:46:08 <edwardk> like that?
21:46:27 <edwardk> @type map . uncurry 
21:46:28 <lambdabot> forall b a b1. (a -> b1 -> b) -> [(a, b1)] -> [b]
21:46:35 <edwardk> or like that?
21:47:05 <tolkad> uh... like "map `div` [1,2] [2,2]" is "[0.5,1.0]"
21:47:16 <tolkad> err
21:47:21 <Veinor> > zipWith `div` [1,2] [2,2]
21:47:21 <edwardk> > zipWith div [1,2] [2,2]
21:47:21 <tolkad> well you get the point
21:47:22 <lambdabot>   Couldn't match expected type `t
21:47:22 <lambdabot>                                -> (a -> b -...
21:47:22 <lambdabot>   [0,1]
21:47:35 <tolkad> > zipWith div [1,2] [2,2]
21:47:36 <lambdabot>   [0,1]
21:47:38 <edwardk> > zipWith div [1,2] [2,2]
21:47:40 <lambdabot>   [0,1]
21:47:45 <tolkad> > zipWith div [1,2] [2.0,2]
21:47:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:47:46 <lambdabot>    `GHC.Real.Fractional a'
21:47:46 <lambdabot> ...
21:47:56 <tolkad> > zipWith div [1.0,2.0] [2.0,2.0]
21:47:57 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:47:58 <lambdabot>    `GHC.Real.Fractional a'
21:47:58 <lambdabot> ...
21:48:06 <edwardk> > zipWith div [1,2] [2.0 :: Double,2]
21:48:07 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
21:48:07 <lambdabot>    arising from a use ...
21:48:11 <Veinor> > zipWith (/) [1.0, 2.0], [1.0, 2.0]
21:48:12 <lambdabot>   <no location info>: parse error on input `,'
21:48:18 <Veinor> > zipWith (/) [1.0, 2.0] [1.0, 2.0]
21:48:19 <lambdabot>   [1.0,1.0]
21:48:21 <edwardk> ah div isn't available for anything fractional
21:48:23 <edwardk> you want (/)
21:48:33 <tolkad> > zipWith (/) [1.0, 2.0] [2.0, 2.0]
21:48:34 <lambdabot>   [0.5,1.0]
21:48:38 <tolkad> oh, thanks
21:48:46 <edwardk> you need not specify them with the .0
21:48:56 <edwardk> > zipWith (/) [1, 2] [2, 2]
21:48:57 <lambdabot>   [0.5,1.0]
21:49:40 <davekong> Is there a way to make "Î»" synonymous with "\"?
21:49:43 <edwardk> 1 just means it gets constructed via an Integer through the fromInteger method internally, 1.0 uses a Rational and fromRational
21:49:58 <edwardk> davekong {-# LANGUAGE UnicodeSyntax #-}
21:51:22 <davekong> edwardk: that is cool, thanks
21:51:35 <dolio> I don't think unicode lambda is a valid substitute for \ even with UnicodeSyntax.
21:51:49 <tolkad> haskell can't even do limits!
21:51:50 <tolkad> > sum (zipWith (/) [1,1..] (zipWith (^) [2,2..] [1,2..]))
21:51:54 <edwardk> dolio: i can't remember it waffled back and forth no
21:51:55 <lambdabot>   mueval-core: Time limit exceeded
21:52:04 <tolkad> see? it should be able to do that
21:52:07 <edwardk> tolkad: why?
21:52:22 <tolkad> edwardk: because it's possible, and it would be better
21:52:24 <edwardk> tolkad: not all of them are computable.
21:52:38 <Veinor> you need some pretty decent symbolic manipulation software to do that
21:53:08 <edwardk> tolkad: haskell isn't Mathematica. if you want symbolic manipulation use a computer algebra system, or write one in haskell.
21:53:41 <wli> The Risch algorithm is hard.
21:54:26 <edwardk> and then richardson's theorem screws the pooch for even that, since you probably want absolute values some days ;)
21:55:31 <Veinor> Specifically, the class of expressions for which the theorem holds is that generated by rational numbers, the number Ï€, the number log 2, the variable x, the operations of addition, subtraction, multiplication, composition, and the sin, exp, and abs functions.
21:55:40 <Veinor> OH COME ON, why is everything at least vaguelt interesting undecidable?
21:56:06 <tolkad> Veinor: only for turing machines
21:56:22 <edwardk> tolkad: go knock yourself out trying to build something else ;)
21:56:38 <edwardk> we'll wait
21:59:40 --- mode: ChanServ set +o mauke
21:59:40 --- mode: mauke set -b *!*@189.214.151.190.cable.dyn.cableonline.com.mx
22:01:40 --- mode: mauke set -o mauke
22:12:35 <philosopher> how to find 2 value in a single list without going trought the all list twice ?
22:14:04 <Axman6> philosopher: i'm not quite sure what you're after
22:14:14 <edwardk> find2 x y ((z,v):zs) | x == z = (v,find1 y zs) | y == z = (find1 x zs, v)
22:14:27 <edwardk> | otherwise = find2 x y zs
22:14:36 <edwardk> i leave it to you to write find1 ;)
22:15:10 <BMeph> edwardk: Ah - "luthor" is your lex, eh? Nice ref... ;)
22:15:16 <philosopher> edwardk: the is is not a list of couple
22:15:22 <edwardk> BMeph: Philippa's idea
22:15:31 <edwardk> then remove the (v,) noise.
22:15:33 <catenate> salve
22:15:38 <Axman6> philosopher: you'll have to be more clear about what you're after
22:15:52 <edwardk> philosopher: when you find them what do you want to do to them?
22:16:19 <catenate> So there's no verboseCheck in QuickCheck 2?  You're probably tired of answering this...
22:16:41 <philosopher> let say i have a list of integer...  f x y list_int = true if booth x and y are in list_int
22:17:24 <Axman6> > let del x 
22:17:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:17:27 <edwardk> what if x == y, does one element satisfy?
22:17:27 <Axman6> whoops
22:17:38 <philosopher> yep
22:18:11 <philosopher> how to do that without going trough the list twice ... and in a beautifull haskell way
22:18:30 <edwardk> f x y (z:zs) = (x == z && y == z) || (x == z && g y zs) || (y == z && g x zs) || f x y zs
22:18:43 * hackagebot snap-core 0.2.7 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.7 (GregoryCollins)
22:18:50 <edwardk> f _ _ [] = False
22:19:01 <catenate> will sample then return what verboseCheck would, about the data used for test?
22:19:16 <philosopher> and g is the natural find ?
22:19:16 <edwardk> g = any . (==)
22:19:35 <Axman6> > let del x (y:ys) | x == y = xs |otherwise = y : del x ys; f x y xs = null (foldl (\ls z -> if z `elem` ls then del z ls else ls) [x,y] xs) in f 1 2 [1,2,3]
22:19:37 <lambdabot>   Not in scope: `xs'
22:19:39 <edwardk> @type any . (==)
22:19:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
22:19:43 * hackagebot snap-server 0.2.7 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.7 (GregoryCollins)
22:19:57 <Axman6> > let del x (y:ys) | x == y = ys |otherwise = y : del x ys; f x y xs = null (foldl (\ls z -> if z `elem` ls then del z ls else ls) [x,y] xs) in f 1 2 [1,2,3]
22:19:58 <lambdabot>   True
22:20:07 <Axman6> > let del x (y:ys) | x == y = ys |otherwise = y : del x ys; f x y xs = null (foldl (\ls z -> if z `elem` ls then del z ls else ls) [x,y] xs) in f 1 2 [14,5,6,1,3]
22:20:09 <lambdabot>   False
22:20:13 <Axman6> > let del x (y:ys) | x == y = ys |otherwise = y : del x ys; f x y xs = null (foldl (\ls z -> if z `elem` ls then del z ls else ls) [x,y] xs) in f 1 2 [14,5,6,1,3,2]
22:20:14 <lambdabot>   True
22:20:20 <Axman6> heh, that works :)
22:20:34 <Axman6> > let del x (y:ys) | x == y = ys |otherwise = y : del x ys; f x y xs = null (foldl (\ls z -> if z `elem` ls then del z ls else ls) [x,y] xs) in f 1 2 [14]
22:20:35 <lambdabot>   False
22:20:38 <Axman6> > let del x (y:ys) | x == y = ys |otherwise = y : del x ys; f x y xs = null (foldl (\ls z -> if z `elem` ls then del z ls else ls) [x,y] xs) in f 1 2 [1]
22:20:40 <lambdabot>   False
22:20:42 <Axman6> > let del x (y:ys) | x == y = ys |otherwise = y : del x ys; f x y xs = null (foldl (\ls z -> if z `elem` ls then del z ls else ls) [x,y] xs) in f 1 2 [2]
22:20:43 <lambdabot>   False
22:20:45 <davekong> flooding is fun?
22:20:46 <Axman6> > let del x (y:ys) | x == y = ys |otherwise = y : del x ys; f x y xs = null (foldl (\ls z -> if z `elem` ls then del z ls else ls) [x,y] xs) in f 1 2 [2,1]
22:20:47 <lambdabot>   True
22:20:50 <Axman6> yes
22:20:59 <philosopher> Axman i dont undertand your solution
22:21:00 <Axman6> especially when you don't have ghc installed
22:22:35 <Axman6> philosopher: you'll have to figure that out then won't you :)
22:22:59 <edwardk> Axman6: yours involves multiple traversals due to the elem check though violating the terms ;)
22:23:23 <edwardk> oh
22:23:24 <edwardk> wait
22:23:25 <Axman6> edwardk: not multiple traversals of the argument list though ;)
22:23:27 <edwardk> elem is [x,y]
22:23:36 <edwardk> *nods*
22:23:37 <catenate> StackOverflow recommends Debug.Trace, which does print data, but which isn't pure, if that matters
22:24:20 <Axman6> edwardk: working on any more details about your speculative package? it looks really interesting, but i can't for the life of me see how it's be useful :P
22:24:42 <edwardk> Axman6: i started putting together a speculative lexer with it as a demonstration
22:24:48 <edwardk> i'm not quite ready with it yet though
22:25:24 <edwardk> in general speculation is a win when you have a good guess at what the input to a function will be, but aren't sure.
22:25:46 <edwardk> when lexing, you may be able to compute based on just the last few chars what the next lexeme is for instance
22:25:55 <Axman6> assuming the function is cheap to execute, and evaluating the argument isn't?
22:26:06 <edwardk> thereby allowing a seemingly serial task to be decomposed into a speculative fold that can enlist a lot of cores
22:26:21 <edwardk> or that they are remotely comparable in cost
22:26:51 <edwardk> if the function is expensive and the argument is as well, then with GHC head you get an interesting result. the garbage collector will collect your speculation!
22:27:00 <edwardk> if you prove not to use it
22:27:08 <catenate> I guess traceShow in the property is more revealing of actual test data than sample
22:27:56 <Axman6> edwardk: what is the speculation? f g? or a?
22:28:01 <edwardk> f g
22:28:19 <philosopher> edwardk: your solution involve multiple traversal
22:28:22 <Axman6> ok
22:28:39 <edwardk> philosopher: no it doesn't, the smaller one is a continuation of the current traversal
22:28:49 <edwardk> and the boolean evaluation shortcircuits on the left
22:28:57 <Axman6> philosopher: edwardk's solution is one traversal split into two parts
22:29:29 <edwardk> phase 1 is where it finds either x or y, phase 2 is where it finds the remaining one, but it continues from where the first iteration left off
22:29:42 <edwardk> technically a three part version would be slightly faster
22:29:48 <edwardk> which checked if x == y once.
22:30:28 <edwardk> Axman6: say you have a lexer, the state of your lexer depends on the entire input stream to this point
22:30:50 <edwardk> but you can get a pretty decent guess with most lexers just using the last 16 chars or so, say. that might be right 80% or 99% of the time
22:30:52 <Axman6> i'm not terribly familliar with lexers :(
22:31:03 <edwardk> String -> [Token]
22:31:19 <Axman6> ok
22:31:30 <edwardk> if instead of a string you had an array
22:31:59 <Axman6> i understand what they do in general, but i've not spent much time with them. more time just parsing things directly
22:32:12 <edwardk> *nods* a common trait among haskellers ;)
22:32:50 <edwardk> or say you wanted to do huffman decoding with a fixed tree, the alignment of the bit string from a given arbitrary point is unknown, but you can guess
22:33:10 <edwardk> based on the last few bytes worth of data
22:33:12 <catenate> Are properties sufficient to do test-driven development in Haskell or is HUnit (more) often necessary?
22:33:21 <edwardk> that guess is a lot cheaper than iterating all the way to that point
22:33:30 <edwardk> you may be right you may not. say you're right 80% of the time
22:34:01 <c_wraith> edwardk, does this speculative system require multiple cores to result in a gain?
22:34:04 <edwardk> if you have 4 cores you can get up to a (4-1) * 80% speed up
22:34:06 <edwardk> c_wraith: yes
22:34:23 <c_wraith> ok, then I see how it works.  from a very high-level perspective
22:34:48 <edwardk> c_wraith: the whole logic is that you have a seemingly serial task, and you want to exploit a bit of parallelism in it
22:35:15 <edwardk> trying to get above what would be seen as the naive implementation's ceiling by Amdahl's law.
22:36:41 <philosopher> any . (==) = elem ?
22:36:55 <edwardk> @src elem
22:36:55 <lambdabot> elem x    =  any (== x)
22:36:59 <edwardk> yes =)
22:37:17 <philosopher> nice
22:39:46 <Peaker> what's nice?
22:39:56 <Axman6> ffs, my keyboard just stopped working for 5 minutes
22:40:08 <Peaker> Axman6, Apple hardware?
22:40:21 <Axman6> IBM thinkpad
22:40:23 <Axman6> i blame KDE
22:40:58 <Axman6> why aren't there any nice free desktop OS's?
22:41:00 <Peaker> Axman6, you can always Ctrl+Alt+F1 or SysRq to see if Linux itself is still responding to kb and it's KDE's fault
22:41:10 <Peaker> xmonad is pretty nice :)
22:41:25 <Peaker> with Ubuntu, which is pretty nice
22:41:41 <Axman6> a nice desktop OS requires no setup to make it not annoying
22:41:50 <Peaker> I haven't used KDE in many years, but I liked it way back then
22:41:54 <Axman6> ubuntu fails that test, because it's always annoying ;)
22:42:10 <Peaker> The default look&behavior of Ubuntu 10.4 is pretty nice, IMO
22:42:15 <catenate> I think rio has no setup, but I don't think ghc runs on Plan 9
22:42:27 <Axman6> my problem with KDE and gnome is that they're designed by idiots who think that good interface design is treating everyone like they're 2
22:42:37 <Peaker> Axman6, defaults are important, but the actual setup you'll be using is probably even more important
22:42:45 <dv-> ratpoison is the best
22:42:54 <Peaker> KDE is the opposite of Gnome in this regard
22:43:13 <davekong> Axman6: kind of hard to have a DE that takes no setup when everyone wants something a little different
22:43:36 * Raynes loves his GNOME
22:43:37 <Axman6> don't give them the choice, and we can all have macs ;)
22:43:50 <Peaker> Axman6, Where you can't bind keys to maximize the window? No thanks :)
22:44:11 * edwardk used to be a power user. I have since gotten sick of tweaking my defaults on every machine I touch. ;)
22:44:12 <Peaker> OS X requires a lot of setup not to be annoying, and that setup isn't just configuring stuff, it's buying silly applications :(
22:45:06 <tensorpudding> at least it provides a decent shell environment, unlike Windows.
22:45:18 <Peaker> Ubuntu gives you all that, plus freedom
22:45:28 <tensorpudding> just discovered a moment ago that PowerShell chokes on executables that begin with a number
22:45:52 <Raynes> Really? Haha.
22:46:04 <tensorpudding> 7z.exe to be precise
22:46:05 * edwardk runs ubuntu in a vm with a terminal window maximized. the window manager doesn't get much use =)
22:46:23 <Peaker> edwardk, Overlapping windows is a stupid model, yeah
22:46:26 <edwardk> occasionally I am daring and open a second window
22:46:44 <Peaker> If I don't have xmonad, I just have 1 maximized window per desktop
22:47:17 <edwardk> Peaker: i like tiling wms, but i tend to just use the ability to snap windows left/right, etc in windows 7 on the desktop, and throw enough monitors at it that i never have to overlap =)
22:47:24 <tensorpudding> I've been going without xmonad after having used it for a year or two
22:47:39 <catenate> peaker: I usually use acme like that, maximized
22:47:44 <tensorpudding> The snap windows in 7 is one thing that I really like
22:47:44 <Peaker> tensorpudding, why?
22:47:49 <Axman6> fucking KDE
22:48:00 <Peaker> tensorpudding, I think KDE invented that feature long ago
22:48:08 <Axman6> i'm now using a tty for irc, because i can't type anything in the GUI
22:48:11 <tensorpudding> Yeah, but then I'd have to use KDE
22:48:16 <edwardk> Peaker: it isn't original, its just present on my outermost desktop for once ;)
22:48:21 <edwardk> tensorpudding: haha
22:48:34 <tensorpudding> in any event my laptop runs Windows and I'm getting used to it
22:48:39 <Peaker> Axman6, What OS are you using?
22:49:08 <davekong> (Guessing Linux)
22:49:09 <Axman6> PC-BSD at the moment
22:49:16 <davekong> and I am wrong
22:49:18 <Peaker> I don't understand how people use Windows at all..
22:49:20 <tensorpudding> I tried PC-BSD
22:49:31 <Peaker> An archaic OS that reminds me of the 90's :)
22:49:32 <edwardk> hrmm any thoughts on the best way to specify an Addr# literal pointing to a raw, immobile c array in template haskell?
22:49:59 <tensorpudding> The package thing is kinda polished all things considered, but KDE 4 reminds me so much about Windows Vista/XP I can't stand it
22:50:00 * Axman6 finds windows a hell of a lot more intuitive and useful than linux distro he's used
22:50:08 <edwardk> in ghc i can write: Addr# "Foo"# and get the char array i want
22:50:19 <edwardk> but i can't tell TH that
22:50:43 <Peaker> Axman6, "Intuitive" is a misnomer.. In this context it really means "familiar"
22:51:06 <tensorpudding> Why aren't either GNOME or KDE adopting the Mac panel design?
22:51:24 <Peaker> Axman6, I find it hard to see how a system without proper package management and with barely any development libraries available for easy download&use (as in apt-get install ..-dev) is "useful" :)
22:51:32 <Axman6> Peaker: somewhat, yes, but i didn't grow up on windows. it's about as familliar to me as linux
22:51:51 <Axman6> actually, until the last 2-3 years, i'd used linux a hell of a lot more than i used windows
22:52:00 <Peaker> Axman6, What was 'unintuitive' about it?
22:52:10 <tensorpudding> I sometimes contemplate making my laptop into a hackintosh
22:52:31 <Axman6> nothing's where it should be, there's no consistency between apps
22:52:35 <tensorpudding> but it just seems to be too painful
22:52:37 <Peaker> tensorpudding, What's good about the Mac panel design?
22:52:48 <davekong> In Linux I can often just guess commands and they work cause the programs often have the same interface
22:53:01 <Peaker> Axman6, Ubuntu/Gnome and Kubuntu/KDE have a lot more consistency than Windows applications
22:53:13 <Peaker> (as long as you install "supported applications")
22:53:23 <Peaker> from the software center
22:53:42 <tensorpudding> It combines a quick-launch and a taskbar, and is elegant, and so much better than having a start-menu
22:53:48 <Peaker> Windows is inconsistent too if you start installing Gtk+ apps on it :)
22:54:00 <Jafet> GNU has produced the most consistent packages of any large project
22:54:18 <Peaker> tensorpudding, All Linux panels let you remove the start menu and have quicklaunchers.. they're pretty flexible
22:54:29 <tensorpudding> Not a default design.
22:54:41 <codolio> Windows is inconsistent if you just have Microsoft software.
22:54:47 <Peaker> tensorpudding, If changing it takes less than 20 seconds, it's as good as a default :)
22:54:52 <tensorpudding> Also at best they do not look half as good as the Windows 7 panel, let alone the OSX one
22:55:08 <Peaker> tensorpudding, Subjective :)
22:55:23 <tensorpudding> I tried several panels back in the day, they were all pretty mungy
22:55:29 <Peaker> form follows function
22:55:57 <Peaker> tensorpudding, I think pretty much all Linux panels I've used seemed to be more flexible than the OS X one
22:56:07 <Peaker> Though I didn't have to "box" them :)
22:56:14 <Jafet> If only the other parts of linux systems followed bauhaus design principles.
22:56:15 <tensorpudding> Flexibility is less important than sane defaults to me.
22:56:37 <tensorpudding> I especially hate flexibility if the configuration UI is inane
22:56:52 <davekong> awesome has some pretty sane defaults and does not take much out of the box to make it the way you want it
22:56:56 <napping> configuration UI?
22:57:06 <catenate> Is quickCheck good enough at finding corner cases to make up for not specifying the test data yourself?
22:57:11 <Peaker> tensorpudding, you can copy around your homedir/configs
22:57:25 <napping> catenate: It tends to test smallish things
22:57:25 <tensorpudding> That still requires an initial setup
22:57:32 <Jafet> tensorpudding: youreditor .layout_config_file
22:57:39 <Jafet> (And hope they don't use XML for everything)
22:57:44 <Peaker> tensorpudding, O(1) cost, O(N) savings :)
22:58:16 <codolio> This all has nothing to do with Haskell.
22:58:31 <Jafet> catenate: quickcheck doesn't test, it guesses
22:58:38 <Peaker> tensorpudding, I see why anyone using computers for a few minutes per day would never touch the defaults.. but if you use computers even 1 hour a day, spending an hour once to configure your defaults that you can copy everywhere is worth it
22:58:53 <tensorpudding> I care about configuration for some things
22:59:01 <tensorpudding> My emacs configuration, for instance
23:00:03 <Axman6> catenate: quickcheck + hpc
23:00:33 <napping> Or, something like HUnit.
23:00:52 <catenate> axman6: yeah, set that up while reading through RWH ch. 11
23:01:16 <napping> It's worth using some of the instrumentation stuff once to make sure you are getting a reasonable distribution
23:01:16 <catenate> napping: exactly my question, whether to also use HUnit
23:02:10 <napping> well, once you have defined your property, it's easy to add calls at fixed parameters to an HUnit suite if you have particular cases you worry about
23:03:50 <catenate> napping: makes sense.  I find that now my code is all instrumented with calls to test functions, whereas Ruby shoves them all into different files.  I don't mind having properties with my source, but how should I turn on and off calls to the test runners?
23:04:12 <napping> I never figured that out very well
23:04:46 <napping> How to split a public and private interface to a module, that is
23:05:24 <napping> there's a little script that greps out everything named prop_* and checks it
23:05:53 <catenate> I could hack around with files, have two different mains that both call my functions and properties in a third file
23:05:56 * hackagebot snap-server 0.2.7.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.7.1 (GregoryCollins)
23:06:56 <napping> Oh, if you just have one file then it doesn't really matter so much
23:07:14 <napping> putting the quickcheck calls into an HUnit suite is pretty reasonable
23:07:24 <catenate> Hm.  I'm pretty handy with the shell, so I could construct a test runner by parsing my source code and constructing a new main
23:07:55 <napping> I'm pretty something shipped with a script like that
23:08:07 <napping> loaded up the file in ghci, I think
23:08:57 <napping> If you know of edge cases, it might be worth writing a generator to target them
23:10:00 <catenate> A Gen generator, or my own?
23:10:23 <napping> Gen, for running a property with
23:10:59 <catenate> Oh, that's a great idea, then I can control the distribution of test data
23:11:16 <napping> for a small thing I usually just run quickcheck from ghci
23:11:25 <napping> or have a function that runs a few tests, maybe
23:11:47 <napping> for a larger project, you can export the props and have another module that groups it all together in a test runner
23:12:10 <catenate> I'm thinking of doing TDD, and keeping the tests around and automated, to keep the code sharp
23:12:31 <codolio> Yes, type-driven design sounds like a good idea.
23:12:52 <catenate> actually test-driven...
23:14:58 <napping> If you are worried about edge cases, use collect or label or something to see what the distribution looks like
23:15:12 <napping> (It's more important if your test has more difficult preconditions
23:15:42 <napping> e.g, if you try to check \ls -> sorted ls ==> ..., you'll probably get one or two element lists
23:18:19 <catenate> why's that?
23:18:27 <napping> you don't use ==>?
23:18:44 <catenate> Why would it generate multiple lists
23:18:47 <catenate> ?
23:18:54 <napping> um, check usually tries to generate 100.
23:19:19 <napping> when you put a precondition on a test with ==> it generates values and throws out ones that don't meet the precondition
23:19:57 <catenate> Oh, you mean that I'll only get one or two actual tests
23:20:02 <napping> a randomly generated list is much more likely to be sorted if it's only one or two elements long
23:20:32 <napping> nah, it keeps trying until it hits 100 acceptable inputs (or a failure), or gives up after some huge number of attempts (10000 or so?)
23:20:48 <napping> if you see a warning about only actually running N tests, it's because it couldn't invent enough
23:21:17 <napping> the problem is that thoes 100 tests will come from a horribly skewed distribution.
23:21:53 <dolio> For something like sorted lists, writing a generator that explicitly constructs the right sort of values is probably a better idea.
23:21:57 <napping> anyway, it's easy to use collect and label and stuff to check if it's actually being a problem
23:22:07 <napping> (for sorted lists, it's easy enough just to sort the given list)
23:22:27 <napping> (guess that would mess up the counterexample reporting - fmap sort arbitrary is probably the way to go)
23:22:41 <dolio> @check \n -> n > 500000 ==> n == 0
23:22:43 <lambdabot>   No instance for (Test.QuickCheck.Testable
23:22:43 <lambdabot>                     (Test.QuickCh...
23:23:26 <napping> ... *** Gave up! Passed only 0 tests.
23:24:22 <napping> anyway, with quickcheck the properties are primary
23:24:40 <napping> you want to check that your function is idempotent or whatever, not just that a few cases pass
23:25:01 <napping> I've never understood how the basic test driven thing is supposed to work
23:25:04 <Jafet> agda-driven design
23:25:45 <napping> I guess in theory there are some finite sets of tests which can ensure your program works, given bounds on it's size, but finding them would be undecidable
23:26:08 <BMeph> Is there a lub for types?
23:26:27 <catenate> Well. in OO programs, you have so much state that you need lots of little test functions to set up state in certain wals to make sure your state-aware methods respond sanely
23:26:41 <napping> well, leaving aside trivial cases where your inputs are all from finite domains
23:26:55 <napping> catenate: sure, but how do you ever know it's not going to do something crazy on some uncovered case?
23:27:23 <ddarius> BMeph: In some type systems, yes.
23:27:38 <napping> BMeph: pairs of types?
23:27:52 <catenate> You only write code when you have a failing case, the code makes the test pass, then you refactor and check that the tests still pass
23:28:28 <Jafet> Test-driven design -- a consequence of the modern education system
23:28:43 <napping> and you know that you've exhausted failing cases when?
23:29:41 <napping> on the other hand, if you know what properties the rest of the code depends on, you can aim straight for that
23:30:56 <catenate> Well, your tests come from your user stories.  Your suite of tests together do everything the user wants to do in the story, so it's that kind of problem-domain-to-test mapping that's up to your skill as a programmer.  You know at least that the tests you wrote produced code that works.  Properties seem much more powerful, when your test data covers all corner cases.
23:31:38 <napping> hmm, so I guess the assumption is something along the lines of a Solomonoff-Levin extrapolation from random user stories is the function you want?
23:32:09 <catenate> Could you dumb that down? ;)
23:32:16 <napping> hmm, Occam's razor
23:32:51 <napping> if you assume there's some function that does "the right thing", and figure out by intuition what the "right" answer is for some random cases
23:33:09 <napping> then the assumption is, that if you write some "simple" program that gets those cases, then it probably is "right" on the rest
23:33:23 <catenate> Well, TDD is viewed more as a better means to figure out the minimal set of code that has to be written, and then make sure that code always works, then as any kind of a proof mechanism
23:34:14 <napping> well, "minimality" is uncomputable, and a finite set of examples sure doesn't absolutely show "always works", so I'm glad it's not sold as a proof technique :)
23:34:31 <Jafet> Unfortunately, no one's written "The Unreasonable Effectiveness of Mathematics in Reducing Software Defects"
23:34:54 <napping> Yeah, I've done it, I just still don't quite trust that it ought to work
23:35:32 <napping> and indeed, I've been satisfied with test suites and then realized quite a bit later (when the bugs pop up) that I missed some corner case
23:36:12 <napping> quickcheck is a bit better - if you assume that your real inputs come from a distribution reasonably similar to the test distribution then you can reasonably get some probablistic confidence
23:36:38 <napping> I guess "random" is much better behaved than "arbitrary"
23:37:46 <napping> getting back to the resolutely practical, quickcheck means you don't need to invent your own examples
23:37:55 <Jafet> <napping> "minimality" is uncomputable   -- but people manage to write proofs
23:38:13 <napping> Ah, but never proofs that the've written the shortest program for a tast
23:38:15 <napping> task
23:38:53 <Jafet> I'm sure that sort of thing is also provable, but I'm not a golfer
23:38:57 <catenate> It's also about the discipline to forever after keep running those tests, to make sure the code does not rust.  When you're in a high-state environment, it's not enough to prove it once, unless you really did cover every possible odd state.
23:39:03 <napping> nah, it's uncomputable after a while
23:39:30 <napping> catenate: well, if you are talking proofs, that's why you go for machine checkable proofs run against the actual code
23:39:36 <Jafet> Ok, we're nearing five pages of offtopic
23:39:46 <napping> nah, we are quite close to on topic
23:40:05 <catenate> By minimal, I don't mean in any mathematical sense, but in the way that you don't have any code you don't need to solve the problem at hand.
23:40:06 <napping> the uses of type systems, how to test haskell programs, and all
23:40:07 <Jafet> Bob Jenkins has written a tool called jenny, if you want ideas for the next offtopic session here
23:40:46 <napping> Hmm, that's more of a process thing
23:41:56 <napping> and to be cute, what about all that test code?
23:41:59 <catenate> Oh, very much so, the practical world of people who code for a paycheck, and how to not do too much and not have to redo it and be able to move on to the next task without a testing/QA team
23:42:40 <catenate> What about it?
23:42:47 <napping> specifically, writing out canned examples
23:42:57 * napping <3 randomized tests
23:43:50 <catenate> yes, the randomized tests are great, but how do you randomly create a bunch of state for a function to run in?  It's not as simle as pure functions
23:44:12 <dolio> Don't use state.
23:44:33 <napping> or, write a little bit of code to set up the state from a description
23:44:49 <catenate> Indeed.  But how many programming jobs advertise for programmers who know how to work without state?
23:45:11 <dolio> Probably not many.
23:45:27 <napping> Well, they can write tests for their own code
23:45:37 <Jafet> Isn't that a good thing?
23:45:39 <catenate> Jane Street is the only outfit Ive seen recently
23:46:14 <napping> you can minimize state in most languages
23:47:16 <napping> reentrant functions matter in C, even
23:47:32 <catenate> Yes, except even new languages like Go work against you by removing expression forms and making them statements instead
23:47:49 <catenate> Though they do add closures to C, essentially
23:49:32 <catenate> A bigger problem is that functional programmers are not as replaceable and outsourceable as imperative, so big companies don't want to go near them
23:50:32 <catenate> 600 people here and how bany actually have a job writing Haskell?
23:50:36 <Cale> I do.
23:50:38 <catenate> er, many
23:50:43 <catenate> Cale, you rock
23:50:58 <catenate> Got any openings ;)
23:51:17 <napping> Um, isn't good practice even in Java to avoid implicit dependencies and use value objects when reasonable?
23:51:18 <Cale> Not sure. You'd have to talk to RyanT5000.
23:51:51 <Cale> We're working on a game for the iPhone and various other mobile devices
23:52:03 <catenate> What do you think, when they have a design pattern called Dependency Injection?
23:52:32 <napping> isn't that entirely the point of it - to let your system be wired up pretty automatically, while still writing individual components to explicitly accept the dependencies
23:52:53 <napping> so you can provide testing versions rather than having to mutate the One True System-Wide Foo to set up a test
23:54:14 <catenate> Cale: where are you all?
23:55:06 <Cale> catenate: All over the world. The main company is in Boston, I'm in Ontario, there are some guys in Europe, and the lead programmer is in New Zealand.
23:55:35 <catenate> Well, the one-true-swf might be a database, which is all state, and the function you're testing might be a join of three tables.
23:56:45 <Cale> Any state is just a value.
23:56:47 <ddarius> Cale: The business picnics must be interesting.
23:56:56 <Cale> ddarius: :)
23:56:56 <catenate> Cale: Oh, that's really neat.  They pay like a real salary with benefits and all?  I have a family.
23:57:12 <Cale> catenate: Well, I'm working as a contractor.
23:57:15 <kmc> likewise
23:57:17 <kmc> (same company)
23:57:22 <kmc> it's a startup
23:57:42 <napping> ddarius: maybe they just synchronize their watches and hit their respective local parks
23:58:02 <kmc> catenate, i don't think functional vs. imperative has much to do with replaceability
23:58:19 <kmc> imperative isn't the opposite of functional, anyway.  haskell is an imperative language and i frequently write imperative code in haskell
23:58:19 <catenate> Is there enough piecemeal and contract work out there, or do you supplement another income with the haskell work?
23:58:45 <kmc> catenate, i'm not sure yet. :)  i have savings from working a while in finance (not doing Haskell)
23:59:16 * hackagebot snap-server 0.2.7.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.7.2 (GregoryCollins)
23:59:23 <kmc> i think that quite separate from any properties of Haskell itself, the kinds of jobs where you're allowed to use Haskell are likely to be good in other ways
23:59:38 <ddarius> Cale: If you don't mind me asking, what were you doing before?
23:59:57 <kmc> terminology aside, you're quite right that companies hiring people for Haskell work won't have an assembly-line shovelware approach to managing programmers
