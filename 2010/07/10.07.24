00:11:27 <Zeiris> Will making a Monad an instance of MonadT in monadLib, sufficient to make it a monad transformer?
00:12:58 <CakeProphet> Zeiris:  dunno anything about monadLib, but MonadTrans in Control.Monad.Trans is the normal way to do that.
00:13:41 <CakeProphet> :t lift
00:13:42 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
00:17:38 <CakeProphet> Zeiris:  so I'd say making it an instance of MonadTrans is the best way to make it a monad transformer.
00:18:56 <CakeProphet> @info
00:18:57 <lambdabot> ()
00:19:01 <CakeProphet> @info MonadT
00:19:01 <lambdabot> MonadT
00:19:07 <CakeProphet> @hoogle MonadT
00:19:07 <lambdabot> Control.Monad.Trans class MonadTrans t
00:19:24 <CakeProphet> ah, hoogle doesn't search hackage I assume.
00:19:34 <CakeProphet> or MonadLib is not in hackage.
00:20:50 <Zeiris> It's on hackage - http://hackage.haskell.org/packages/archive/monadLib/3.6.1/doc/html/MonadLib.html#t%3AMonadT 
00:26:13 <CakeProphet> how would ListT work?
00:26:59 <Zeiris> hpaste.org/fastcgi/hpaste.fcgi/view?id=28082 The problem I'm running into is a kind mismatch in the MonadT instance. I think I've figured out why: SuperT is a (very poorly named) monad, and MonadT needs a transformer. But derive_lift derives from a monad. So I guess I need a new newtype, for the transformer for SuperT.
00:27:03 <CakeProphet> Zeiris:  MonadT looks entirely equivalent to MonadTrans
00:28:20 <Eduard_Munteanu> There was a nice article on Wikibooks on monad transformers.
00:28:42 <CakeProphet> Zeiris:  there's an extension that lets you derive typeclasses for newtypes.
00:28:57 <CakeProphet> don't recall the name off-hand. I just learned about it today.
00:29:14 <CakeProphet> GeneralizedNewTypeDeriving maybe?
00:29:34 <CakeProphet> newtype SuperT a = ... deriving (MonadT, MonadTrans, ...)
00:29:47 <CakeProphet> provided the wrapped type is an instance of the derived typeclasses
00:32:07 <CakeProphet> but you could just as easily do it yourself. lift for your type is just lift on the wrapped type
00:32:20 <triyo> Good morning. Anyone know of some example code I could look at that demonstrates use of the Text.XML.Light library?
00:32:29 <CakeProphet> lift m = SuperT (lift m)
00:32:30 <CakeProphet> like that.
00:34:02 <CakeProphet> Zeiris:  ^^^
00:34:48 <drbean> This one: http://en.wikibooks.org/wiki/Haskell/Monad_transformers ?
00:35:54 <CakeProphet> Zeiris:  and yes, your monad is a transformer stack, not a transformer itself. It had no m parameter.
00:35:59 <Zeiris> CakeProphet, that raises a kind mis-match, afaik because SuperT is a monad not a transformer.
00:36:24 <CakeProphet> Zeiris:  a kind mismatch? shouldn't... as far as I can tell the types match up.
00:36:32 <CakeProphet> well... hmmm
00:36:33 <Zeiris> It should be convertable to a transformer if I get rid of the Id, though.
00:36:42 <CakeProphet> yes.
00:37:02 <CakeProphet> that's what's missing. I see now
00:37:05 <CakeProphet> the kind mismatch is in lift
00:37:09 <CakeProphet> :t lift
00:37:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
00:37:18 <CakeProphet> t = SuperT in this case
00:37:37 <CakeProphet> but t :: 3-*
00:37:42 <CakeProphet> and SuperT :: 2-*
00:39:28 <Zeiris> Can I define SuperT by removing Id, then define Super from it by stacking SuperT with Id, then use Super to auto-derive Monad and Functor via MonadLib's iso stuff?
00:39:41 * ski . o O ( "3-*","2-*" ? )
00:39:55 <CakeProphet> Zeiris:  not sure, but I give a tentative yes.
00:40:12 <CakeProphet> type Super a = SuperT Id a
00:40:40 <CakeProphet> Zeiris:  I'm not really sure I see a point in this monad lib stuff...
00:40:41 <Zeiris> I guess so, since the Monad/Functor instance would be for Super which is based on Id. And what worried me was "what if I want to use something else than Id for base" but that's only related to SuperT, ain't it.
00:41:15 <ski>   newtype SuperT m a = MkSuperT {runSuperT :: WriterT String (StateT Int (ReaderT Config m)) a}
00:41:17 <CakeProphet> Zeiris:  well yes, if you want to use something other than Id for base you should use SuperT m a
00:41:23 <Zeiris> CakeProphet, I like how it gets rid of lift $ lift $ lift via the StateM/WriterM/etc classes.
00:41:36 <CakeProphet> are they similar to MonadIO?
00:41:55 <ski>   instance Monad m => Monad (SuperT m)  -- similarly for `Functor'
00:41:56 <CakeProphet> generally I just "get rid" of multiple lifts by making helper functions
00:42:03 <ski>   instance MonadTrans SuperT
00:42:10 <CakeProphet> liftState = lift.lift; liftReader = lift
00:42:11 <CakeProphet> or whatever
00:42:53 <ski> (where you can actually derive those using `GeneralizedNewTypeDeriving')
00:43:27 <Zeiris> Yeah. I just like the idea of piling a bunch of monads all together, and pretending you're writing C or something. The "test" function, with the "(...) => m Int" signature is a really good example of that.
00:44:14 <CakeProphet> transformer stacks are actually quite useful... for purposes other than writing C code. :)
00:44:37 <Zeiris> It's like C code, except with only the side effects you allow! Yeah, I'm pretty excited about this.
00:44:44 <Zeiris> Wouldn't be doing it at 12AM on a friday otherwise.
00:45:01 <ski> `sets_' ?
00:45:08 <CakeProphet> well, it's really not like C at all. It's more like imperitive code in general.
00:45:25 <CakeProphet> theoretically sound imperitive code.
00:45:47 <CakeProphet> ...that is purely functional.
00:46:36 <Zeiris> ski, modifies state with a function: (StateM m s) => (s->s) -> m () 
00:46:46 <ski> @type modify
00:46:47 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
00:47:16 <CakeProphet> @src Identity (>>=)
00:47:16 <lambdabot> m >>= k  = k (runIdentity m)
00:47:17 <Zeiris> Heh, interesting. I just saw it as a utility function in MonadLib and used it.
00:47:34 <CakeProphet> @src Identity
00:47:34 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
00:47:44 <ski> @hoogle (s -> (s,a)) -> m a
00:47:44 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
00:47:44 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
00:48:34 <ski> Zeiris : i presume `sets :: StateM m s => (s -> (s,a)) -> m a' ?
00:50:45 <CakeProphet> data SuperMonad a = SuperMonad { bind :: (a -> SuperMonad b) -> SuperMonad b; run :: a}  
00:51:22 <ski> CakeProphet : error : variable not in scope : `b'
00:51:58 <CakeProphet> would a forall b fix that?
00:52:33 <ski> yeah .. but depending on where you put it, it would mean different things
00:52:49 <CakeProphet> inside the type for bind is probably the best place I'd imagine.
00:53:07 <ski> ok, so you're making `bind' polymorphic, then
00:53:17 <CakeProphet> pretty much
00:53:41 <CakeProphet> though I have no clue what return would be for this monad... perhaps it too should be polymorphic??
00:53:43 <ski> so, .. can you make an `instance Monad SuperMonad' ?
00:54:27 <CakeProphet> m >>= f = bind m f
00:54:30 <CakeProphet> return = ???
00:55:13 <CakeProphet> return can't be polymorphic.
00:55:14 <ski>   return a = SuperMonday {bind = \k -> k a; run = a}
00:55:25 <CakeProphet> that works.
00:55:53 <CakeProphet> so that's it? I've made one monad to rule them all?
00:56:05 <ski> you need to check the monad laws
00:56:18 <CakeProphet> well...
00:56:24 <CakeProphet> they are constructor dependent.
00:56:25 <ski> (and i don't know about the "rule them all" part ..)
00:56:43 <CakeProphet> so... give your SuperMonads law-abiding functions!  -shakes stick-
00:56:57 <CakeProphet> there, monad laws fulfilled.
00:57:21 <ski> we want `ma >>= return = ma' in the first place
00:58:22 <ski> hm, maybe the left unit law is simpler .. `return a >>= amb = amb a'
00:58:28 <CakeProphet> ski:  that would still depend on bind
00:58:42 <CakeProphet> so basically... -shake stick-
00:58:58 <ski>   return a >>= amb  =  bind (return a) amb  =  amb a
00:59:47 <ski> well, if you can't guarantee the laws will be abided in general, then you need to make this into an ADT, and make sure only law-abiding elements can be constructed
01:00:53 <CakeProphet> ski:  that, or I could just leave it open and mention in (purely hypothetical) documentation. Essentially the burden of law conformance is transitive to the user of the monad
01:00:55 <ski> (and, btw, for the "rule them all", i think possibly `data InitialMonad a = IM (forall m. Monad m => m a)' would fit that bill)
01:01:16 <CakeProphet> ah. yes.
01:01:35 <ski> CakeProphet : but that's not nice on the users to have to check that all the time
01:01:52 <CakeProphet> ski:  SuperMonad is for SUPER USERS.
01:02:32 <CakeProphet> but how could we ensure only law-aviding binds?
01:02:44 <ski> oh, you mean users having type `forall a. a' ?
01:03:07 <CakeProphet> ....was that I joke? I don't believe I got it.....
01:03:27 <ski> CakeProphet : dunno .. think hard about the problem, write thesis about it ?
01:04:03 <CakeProphet> ...I'd rather just leave it up to the implementor of bind
01:04:15 <CakeProphet> in much the same way that the Monad typeclass itself leaves that bit up to the instance declaration
01:04:18 <ski> (yes, a joke, `forall a. a' would correspond to a user which could handle any task .. and there is no such thing (apart from `_|_'))
01:05:09 <ski> CakeProphet : well, a type class instance is written once, for each type, but constructing values in the type can be done many times
01:06:00 <CakeProphet> conceptually it's the same... each bind function is written only once, just as each >>= is written only once.
01:06:13 <ski> it's easier to associate the burder of proof with the instance, that with whoever constructs values (partly because constructing values usually doesn't have to think as much of ensuring this kind of property)
01:06:55 <CakeProphet> but SuperMonad IS the Monad typeclass in data constructor form... more or less.
01:07:01 <ski> for this situation, i would probably rename the data constructor `SuperMonday' to `PromiseSuperMonday' to remind the user of the proof obligation
01:07:41 <CakeProphet> unsafePromiseSuperMonadDangerDanger
01:08:12 <ski> CakeProphet : actually, i think `data MonadDict m = PromiseMonadDict {ret :: forall a. a -> m a; bind :: forall a b. m a -> (a -> m b) -> m b}' is the `Monad' type class in data type form
01:08:50 <CakeProphet> ski:  aha... that's how you could do return. I was originally going to do that, but for some reason thought it wouldn't make sense.
01:09:01 <ski> (note how this is now nicely abstracted away from any specific "current monadic action", on which to operate .. as opposed to your `SuperMonad')
01:09:29 <CakeProphet> yes... that's basically what I meant to do. I was just thinking of the constructor functions as being the monad operators themselves
01:09:33 <CakeProphet> rather than containing them.
01:09:34 <ski> CakeProphet : note my `bind' takes an additional argument, comparing to your .. and that it is ppolymorpic in both `a' and `b'
01:09:38 <CakeProphet> -nod-
01:09:40 <CakeProphet> I see that.
01:09:52 <ski> (.. and it takes an `m' parameter)
01:09:56 <Zeiris> Jesus, I think it works. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28086 Monad transformer with an abstract implementation, and Monad/Functor instances when stacked onto -any- monad.
01:10:13 <Zeiris> I'm still not entirely sure what I can do with it, but no doubt it's awesome.
01:10:44 * ski idly wonders why it appears no one can be bothered to put their name/nick on their pastes, nowadays ..
01:10:50 <CakeProphet> ski:  hmmm, why m' and not a like before?
01:11:17 * zygoloid wonders if it'd be meant to point out that you could use GeneralizedNewtypeDeriving for that monad transformer
01:11:27 <Zeiris> There doesn't seem any point attaching your name to something as anonymous and freeform as a paste.
01:11:31 <ski> CakeProphet : why `a' and not `b' ? (or maybe both ?)
01:12:01 <CakeProphet> ski:  well.. I would like my super-monad-type to be an instance of Monad.
01:12:07 <CakeProphet> as that would be all kinds of fun.
01:13:09 <ski> (iirc, once upon a time, hpaste announced pastes in-channel .. i suppose names makes even more sense, in such case)
01:14:58 <Eduard_Munteanu> wgetpaste could use hpaste support, if it isn't in plans already
01:16:04 <tehgeekmeister> there *has* to be a standard function that will apply a function to either the first or second element of a 2-tuple.  what is it?
01:16:30 <mrd> there is in Data.Arrow
01:16:33 <Eduard_Munteanu> :t first
01:16:34 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
01:16:36 <ski> CakeProphet : `newtype DictyMonad m a = MkDM {runDM :: MonadDict m -> m a}; instance Monad DictyMonad where return a = MkDM (\m -> ret m a); ma >>= amb = MkDM (\m -> bind m (runDM ma m) (\a -> runDM (amb a) m))'
01:16:51 <Eduard_Munteanu> Or something like that.
01:17:28 <mrd> Control.Arrow or whatever
01:17:42 <zygoloid> tehgeekmeister: what type would it have? Bool -> (a -> a) -> (a, a) -> (a, a)?
01:18:14 <Eduard_Munteanu> I think he meant one of them, without deciding which.
01:18:15 <ski>   Either (a0 -> a1) (b0 -> b1) -> ((a0,b0) -> (a1,b1))
01:18:24 <zygoloid> @type \b -> if b then first else second
01:18:25 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => Bool -> a b b -> a (b, b) (b, b)
01:18:41 <tehgeekmeister> zygoloid: (a -> b) -> (a, c) -> (b,c)
01:18:44 <ski> hm, that'd not work, actually
01:19:03 <zygoloid> tehgeekmeister: that's first, in Control.Arrow
01:19:20 <ski> @type \f p -> first f p
01:19:21 <lambdabot> forall b c d. (b -> c) -> (b, d) -> (c, d)
01:21:45 <ski> Zeiris> :t derive_lift
01:22:32 <Zeiris> ski, (MonadT t, Monad m) => Iso (t m) n -> m a -> n a    ( http://hackage.haskell.org/packages/archive/monadLib/3.6.1/doc/html/MonadLib-Derive.html )
01:26:18 <ttt--> is there a function for applying a function n times?
01:26:53 <Zeiris> :t repeat
01:26:54 <lambdabot> forall a. a -> [a]
01:27:19 <mauke> :t \n f -> (!! n) . iterate f
01:27:25 <lambdabot> forall a. Int -> (a -> a) -> a -> a
01:27:31 <CakeProphet> mauke:  beat me to it. :P
01:27:43 <zygoloid> @type \n -> appEndo . mconcat . replicate n . Endo
01:27:44 <lambdabot> forall a. Int -> (a -> a) -> a -> a
01:27:49 <ttt--> :t iterate
01:27:50 <lambdabot> forall a. (a -> a) -> a -> [a]
01:28:08 <ski> @type genericIndex
01:28:08 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
01:28:30 <ttt--> :t (iterate 4 (+ 1)) 1
01:28:31 <lambdabot>     Couldn't match expected type `t1 -> t'
01:28:31 <lambdabot>            against inferred type `[a -> a]'
01:28:31 <lambdabot>     In the expression: (iterate 4 (+ 1)) 1
01:28:54 <zygoloid> > iterate (+1) 4 !! 9
01:28:54 <lambdabot>   13
01:29:02 <ttt--> oh thanks
01:29:05 <mauke> > iterate f x
01:29:06 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
01:29:19 <mauke> > iterate f x !! 3
01:29:20 <lambdabot>   f (f (f x))
01:29:57 <CakeProphet> > iterate (fix f) x
01:29:57 <lambdabot>   Overlapping instances for GHC.Show.Show
01:29:57 <lambdabot>                              (Simpl...
01:30:01 <CakeProphet> :)
01:30:16 <CakeProphet> :t fix
01:30:17 <lambdabot> forall a. (a -> a) -> a
01:30:19 <CakeProphet> ah.
01:34:36 <tehgeekmeister> is it okay to do something like "forM_ do ...."?
01:34:49 <tehgeekmeister> errr
01:34:55 <tehgeekmeister> forM_ xs do
01:35:05 <CakeProphet> :t forM_
01:35:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
01:35:18 <CakeProphet> yes. but you need a $
01:35:20 <CakeProphet> or ()'s
01:35:23 <tehgeekmeister> okay
01:35:23 <CakeProphet> around the do
01:35:36 <CakeProphet> it's a common idiom for control statements.
01:35:44 <CakeProphet> for example, forever $ do {..}
01:36:10 <CakeProphet> tehgeekmeister:  oh... and you need a lambda for mapM_
01:36:28 <CakeProphet> mapM_ xs (\a -> do ... )
01:36:29 <zygoloid> forM_ xs $ \x -> do ...
01:36:38 <tehgeekmeister> eh?  oh
01:36:39 <tehgeekmeister> yeah
01:36:44 <tehgeekmeister> that makes sense
01:37:53 <CakeProphet> Haskell feels more like imperitive programming than imperitive programming. It's like... the way it should work. :)
01:38:12 <mizai> what's imperitive programming?
01:38:53 <CakeProphet> mizai:  similar to imperative programming. :P
01:38:56 <ttt--> :t f
01:38:57 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
01:38:59 <CakeProphet> but with fewer a's
01:39:09 <mizai> CakeProphet, gotchya
01:39:11 <ttt--> :t x
01:39:12 <lambdabot> Expr
01:39:44 <CakeProphet> > fix f
01:39:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:39:45 <lambdabot>    `GHC.Show.Show a'
01:39:45 <lambdabot>      a...
01:39:52 <CakeProphet> > fix f :: Expr
01:39:52 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
01:41:17 <CakeProphet> lambdabot never tires. Even when we ask it to evaluate the same expressions over and over again, every day
01:42:16 <mizai> > fix my :: Car
01:42:17 <lambdabot>   Not in scope: type constructor or class `Car'Not in scope: `my'
01:42:20 <mizai> goddamnit
01:42:34 <mauke> > fix error
01:42:35 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
01:43:10 <CakeProphet> > lete car = head in fix car 
01:43:11 <lambdabot>   <no location info>: parse error on input `='
01:43:17 <CakeProphet> > let car = head in fix car 
01:43:18 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
01:43:21 <mizai> lose
01:43:51 <mizai> functional programming is for sissies
01:45:50 <CakeProphet> > fix (return . unsafePerformIO)
01:45:51 <lambdabot>   Not in scope: `unsafePerformIO'
01:48:33 <Jonno_FTW> :t fix
01:48:34 <lambdabot> forall a. (a -> a) -> a
02:47:14 <monadic_kid> hey, is it possible to build ghc's rts with C compiler (gcc port to a platform that is not posix compatible) and then translate haskell to c and build it with this port, without the need to make an unregistered port of ghc?
02:49:43 <quesada__> I have installed cabal from distro's package manager, but no executable is in the path, nor on usr/bin. Is this normal?
02:51:06 <Taejo> quesada__: did you install cabal the library or cabal the program?
02:51:08 <Eduard_Munteanu> quesada__: yes
02:51:21 <Eduard_Munteanu> Cabal is one thing, cabal install is another
02:51:34 <quesada__> aha
02:52:02 * Taejo thinks it's unhelpful that the executable "cabal" is called the "cabal-install" program
02:52:06 <monadic_kid> quesada___: no package for haskell platform? that's a "batteries included" package
02:52:34 <quesada__> Taejo: me too
02:52:55 <Eduard_Munteanu> Well, why would you need Haskell Platform anyway?
02:53:10 <Eduard_Munteanu> I thought that's stuff intended more for Windows users.
02:53:22 <monadic_kid> Eduard_Munteanu: no it's not
02:53:27 <Eduard_Munteanu> (or when proper packages aren't available)
02:53:51 <quesada__> I'm trying to use cabal to install xmonad-contrib
02:54:06 <quesada__> My distro's packages it, but it shows an error: "xmonad-contrib-0.9: dependency utf8-string-0.3.5 doesn't exist (ignoring)       "
02:54:15 <quesada__> so it doesn't work from packages
02:54:38 <Taejo> Eduard_Munteanu: the haskell platform is a blessed set of haskell packages, with consistent versions -- this is useful whatever the operating system.
02:54:56 <Taejo> though the packaging differs between OSes
02:55:03 <monadic_kid> quesada__: you're better off installing the haskell platform if it's available  in as package on your distribution, http://hackage.haskell.org/platform/
02:55:31 <Taejo> in debian haskell-platform is an empty package which depends on the correct version of the platform packages
02:55:34 <Eduard_Munteanu> Taejo: admittedly, choosing a consistent set of packages is a distro's job too.
02:55:49 <Eduard_Munteanu> Taejo: ah, that sounds like it, meta package.
02:56:18 <Taejo> it is a distro's job, typically -- but it's nice to have cross-distro consistency
02:56:19 <Eduard_Munteanu> quesada__: what distro is that?
02:56:32 <Taejo> and not duplicate work for each distro
02:57:16 <monadic_kid> Eduard_Munteanu: why are you arguing against it and when did anyone ever say you shouldn't use it for any os? even ghc's main webpage recommends you don't install the latest version of ghc and install the platform
02:59:22 <monadic_kid> on fedora the haskell platform is avaible as package through fedora's offical repositories.
02:59:26 <Eduard_Munteanu> monadic_kid: I'm not sure how this fares with Linux distros. You might have a point, but my Gentoo still has that keyword masked and probably specifies dependencies in terms of individual packages.
02:59:37 <quesada__> nope. hs-platform not available
03:00:04 <quesada__> I tried using cabal to install the missing dep. utf8-string-0.3.5, then install xmonad-contrib from packages, but that didn't work
03:00:07 * Eduard_Munteanu is using Gentoo here.
03:00:20 <quesada__> I'm using sabayon
03:00:24 <Eduard_Munteanu> quesada__: well of course it doesn't, cabal install doesn't install it system wide.
03:00:39 <Eduard_Munteanu> quesada__: so it won't mix well with emerge.
03:01:00 <Eduard_Munteanu> quesada__: did you try emerging dev-haskell/utf8-string ?
03:01:03 <quesada__> Eduard_Munteanu: thanks
03:01:28 <quesada__> Eduard_Munteanu: I did the equivalent, using equo install utf8-string
03:01:42 <Eduard_Munteanu> Ah, that's okay I suppose.
03:01:59 <Eduard_Munteanu> (I know Sabayon is a binary spinoff of Gentoo)
03:02:57 <monadic_kid> do they use the same package manager?
03:02:57 <quesada__> It still says: xmonad-contrib-0.9: dependency utf8-string-0.3.5 doesn't exist (ignoring)  
03:02:58 <Eduard_Munteanu> BTW, I think you should read ivanm's stuff about cabal-install before using it... http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
03:03:26 <Eduard_Munteanu> quesada__: did it install 0.3.5 (or newer)?
03:03:34 <quesada__> so I have a broken xmonad. without contrib, it's not very useful
03:04:08 <quesada__> Eduard_Munteanu: dev-haskell/utf8-string-0.3.6
03:04:10 <Eduard_Munteanu> monadic_kid: not sure if 'emerge' works in Sabayon.
03:04:21 <jedai> you could use cabal-install in global mode to install xmonad-contrib
03:04:32 <quesada__> Eduard_Munteanu: it does, but it's recommended to stick to either emerge or equo (bin)
03:04:37 <Eduard_Munteanu> quesada__: hm... do you have a newer version of xmonad you can unmask and install?
03:04:39 <quesada__> and not mix
03:04:45 <Eduard_Munteanu> I see.
03:05:01 <quesada__> nope, it's .9
03:05:25 <Eduard_Munteanu> Ah. Here 0.9 is keyword-masked by default and 0.8.1 is stable.
03:05:30 <Eduard_Munteanu> (I use 0.9)
03:05:34 <quesada__> me too
03:05:46 <quesada__> .9 comes from packages on sabayon
03:05:55 <quesada__> it's on bleeding, not stable, I guess
03:06:26 <Eduard_Munteanu> quesada__: well, does xmonad-contrib build if it ignores that dependency?
03:06:34 <quesada__> it does, 
03:06:53 <Eduard_Munteanu> quesada__: then I suppose you're okay
03:06:59 <quesada__> but then, when using any of the contrib packages, xmonad complains that it's not there
03:07:05 <Eduard_Munteanu> Oh.
03:07:11 <quesada__> so I guess it failed to install
03:07:15 <quesada__> brb
03:07:23 <Eduard_Munteanu> quesada__: complains about what, xmonad-contrib or utf8-string?
03:07:32 <Eduard_Munteanu> quesada__: maybe now that you actually installed it, it works.
03:12:48 <quesada__> Eduard_Munteanu: this is what I still get: http://www.sabayon.org/pastie/4465
03:14:46 <quesada__>  equo query list installed|grep utf
03:14:47 <quesada__> >>   # 14996 dev-haskell/utf8-string
03:16:00 <quesada__> I filled a sabayon bug 
03:19:32 <quesada__> but this was weeks ago. Not many xmonad users there I guess
03:21:46 <Ke> sabayon mostly only packages gentoo ebuilds
03:21:48 <Ke> afaik
03:22:00 <Ke> did it use binaries?
03:22:14 <quesada__> since there's no haskell-platform package, maybe the way to go is to use cabal install xmonad-contrib
03:22:19 <quesada__> Ke: yes, binaries
03:23:16 <quesada__> or wait for them to package haskell-platform. I'll fill a request
03:23:26 <proppy> Hi, from tryhaskell.com :)
03:23:51 <Ke> quesada__: there is no need for the platform package, gentoo doesn't have one
03:24:20 <Ke> hmm actually does
03:24:25 <Ke> but still not needed
03:25:03 <quesada__> ok
03:25:50 <quesada__> Ke: so #cabal install xmonad-contrib?
03:26:25 <Ke> quesada__: well I for one consider local use of cabal install an abomination, but you may do as you wish
03:26:36 <quesada__> heh
03:26:42 <Ke> wonder if that thing is also a gentoo bug
03:26:52 <quesada__> good point
03:27:10 <quesada__> anyone running gentoo can confirm?
03:28:16 <quesada__> Ke: so I'll wait for packages then
03:28:50 <tehgeekmeister> anyone here know what it means when √© gets represented as √É¬© when converting iso 8859-1 to utf8
03:28:50 <tehgeekmeister> ?
03:29:02 <Ke> quesada__: I'm running xmonad contrib on gentoo
03:29:14 <Ke> quesada__: no such problems
03:32:39 <quesada__> Ke: k
03:37:10 <proppy> I guess I just understood something about expression typing in haskell, given f :: Stringfunction typing  -> String -> String, f "a" "b" will yield a String, f "a" will yield a String -> String (that is an expression that wait for a String an return a String)
03:37:44 <proppy> s/function typing//
03:37:46 <proppy> right ?
03:38:24 <ski> yes
03:39:28 <ski> @type take
03:39:29 <lambdabot> forall a. Int -> [a] -> [a]
03:39:29 <quesada__> Ke: I have read http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/ and I see the probelms of cabal-install. However, I cannot switch disto, and gentoo/sabayon sound like ones with good support
03:39:34 <ski> @type take 3
03:39:35 <lambdabot> forall a. [a] -> [a]
03:39:48 <ski> @type take 3 [0,1,1,2,3,5,8,13]
03:39:49 <lambdabot> forall t. (Num t) => [t]
03:39:53 <ski> > take 3 [0,1,1,2,3,5,8,13]
03:39:54 <lambdabot>   [0,1,1]
03:40:22 <proppy> so if I compose 2x f together like this (f "a"  . f "b" ) it will be String -> String
03:40:33 <ski> yes
03:40:38 <proppy> :) 
03:40:50 <proppy> ski: thanks :)
03:41:09 <quesada__> but the sabayon bug could stay open a long time if none of the packagers use xmonad. If I use cabal-install now, and later the bug is fixed, will this take care of the problem AND overwrite the cabal-install files?
03:41:33 <ski> > (intersperse '_' . intersperse '^') "(:)"
03:41:34 <lambdabot>   "(_^_:_^_)"
03:43:19 <tehgeekmeister> is there an analog of toLower for strings, or should i just use map?
03:44:21 <proppy> @t toLower
03:44:21 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:44:24 <proppy> :t toLower
03:44:28 <lambdabot> Char -> Char
03:44:44 <proppy> :t toLowers
03:44:46 <lambdabot> Not in scope: `toLowers'
03:45:03 <proppy> > let toLowers = map toLower
03:45:04 <lambdabot>   not an expression: `let toLowers = map toLower'
03:45:15 <ski> @let toLowers = map toLower
03:45:17 <lambdabot>  Defined.
03:45:19 <ski> @type toLowers
03:45:20 <lambdabot> [Char] -> [Char]
03:45:26 <proppy> ski :)
03:45:48 <proppy> @type == :t ?
03:45:49 <lambdabot> parse error on input `=='
03:46:08 <proppy> :t toLowers
03:46:09 <lambdabot> [Char] -> [Char]
03:46:27 <dibblego> @type let k f g a b = let o = f a b in if o == EQ then g a b else o in k
03:46:28 <lambdabot> forall t t1. (t -> t1 -> Ordering) -> (t -> t1 -> Ordering) -> t -> t1 -> Ordering
03:46:36 <proppy> > let toLowers = map toLower in toLowers "FOO"
03:46:37 <lambdabot>   "foo"
03:47:10 <ski> > toUpper 'ﬂ'
03:47:11 <lambdabot>   '\65533'
03:47:53 <proppy> > toLower '„Åµ'
03:47:54 <lambdabot>   '\12405'
03:48:13 <proppy> > toUpper toLower '„Åµ'
03:48:14 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
03:48:14 <lambdabot>         against inferred type...
03:48:25 <proppy> > (toUpper . toLower) '„Åµ'
03:48:26 <lambdabot>   '\12405'
03:48:46 <proppy> > (toLower . toUpper) '„Åµ'
03:48:47 <lambdabot>   '\12405'
03:49:01 <ski> dibblego : isn't that  \f g -> f `mappend` g  ?
03:49:13 <c_wraith> > text "„Åµ"
03:49:14 <lambdabot>   „Åµ
03:49:26 <Eduard_Munteanu> > fromEnum '„Åµ'
03:49:26 <lambdabot>   12405
03:49:55 <ski> > ord 'ﬂ'
03:49:56 <lambdabot>   65533
03:50:13 <proppy> > ord  '„Åµ'
03:50:14 <lambdabot>   12405
03:50:22 <dibblego> ski, yes
03:50:27 <ski> > (isLower &&& isUpper) 'ﬂ'
03:50:28 <lambdabot>   (False,False)
03:50:32 <proppy> > fromEnum == ord
03:50:33 <lambdabot>   *Exception: (==): No overloading for function
03:50:51 <ski> @check \c -> fromEnum c == ord c
03:50:52 <lambdabot>   "OK, passed 500 tests."
03:50:58 <proppy> :t fromEnum
03:50:59 <lambdabot> forall a. (Enum a) => a -> Int
03:51:02 <proppy> :t ord
03:51:03 <Eduard_Munteanu> :t ord
03:51:03 <lambdabot> Char -> Int
03:51:04 <lambdabot> Char -> Int
03:51:16 <ski> @type ch
03:51:16 <lambdabot> Not in scope: `ch'
03:51:17 <ski> @type chr
03:51:17 <lambdabot> Int -> Char
03:51:25 <proppy> @check 
03:51:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:51:34 <ski> @check False
03:51:34 <lambdabot>   "Falsifiable, after 0 tests:\n"
03:51:35 <Eduard_Munteanu> > chr 2200
03:51:35 <lambdabot>   '\2200'
03:51:40 <Eduard_Munteanu> > text $ chr 2200
03:51:41 <lambdabot>   Couldn't match expected type `GHC.Base.String'
03:51:41 <lambdabot>         against inferred typ...
03:51:53 <proppy> @check \c -> (chrr . ord) c == c
03:51:54 <lambdabot>   Not in scope: `chrr'
03:51:58 <proppy> @check \c -> (chr . ord) c == c
03:51:59 <lambdabot>   "OK, passed 500 tests."
03:52:00 <ski> @scheck \xs -> xs == reverse xs
03:52:01 <lambdabot>   "OK, passed 500 tests."
03:52:04 <Eduard_Munteanu> > text (chr 2200 : [])
03:52:05 <lambdabot>   ‡¢ò
03:52:09 <ski> @scheck \xs -> xs == reverse (xs :: [Int])
03:52:10 <lambdabot>   "Falsifiable, after 2 tests:\n[2,0,-3]\n"
03:52:47 <proppy> @scheck -> False == True
03:52:47 <lambdabot>   Parse error at "->" (column 1)
03:52:57 <proppy> @type scheck
03:52:58 <lambdabot> Not in scope: `scheck'
03:53:05 <ski> @check False == True
03:53:06 <lambdabot>   "Falsifiable, after 0 tests:\n"
03:53:13 <proppy> what does scheck means ?
03:53:20 <proppy> !check ?
03:53:24 <ski> @check \x y -> x == (y :: Bool)
03:53:25 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\nFalse\n"
03:53:48 <ski> `scheck' is a variant of the `check' command .. but apparently `scheck' doesn't exist in lambdabot, atm
03:53:52 <ski> @help check
03:53:52 <lambdabot> check <expr>
03:53:52 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
03:54:02 <proppy> @help scheck
03:54:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:54:14 <proppy> but you just used it before ?
03:54:23 <proppy> [12:51] <ski> @scheck \xs -> xs == reverse (xs :: [Int]) [12:51] <lambdabot>   "Falsifiable, after 2 tests:\n[2,0,-3]\n"
03:54:42 <ski> ("scheck" standing for "SmallCheck", the variant of QuickCheck than tries to minimize failing testcases, to better exibit the relevant information)
03:54:53 <proppy> how ok
03:54:57 <proppy> oh ok
03:54:58 <ski> proppy : lambdabot spell-corrected it into `check'
03:55:11 <proppy> @check \xs -> xs == reverse xs
03:55:12 <lambdabot>   "OK, passed 500 tests."
03:55:18 <proppy> @check \xs -> xs == xs
03:55:19 <lambdabot>   "OK, passed 500 tests."
03:55:26 <proppy> > reverse [1,2,3]
03:55:27 <lambdabot>   [3,2,1]
03:55:47 <proppy> > let a = [1,2,3] in reverse a == a
03:55:47 <lambdabot>   False
03:55:52 * proppy confused
03:56:09 <proppy> how comes @check passed
03:56:10 <Peaker> proppy, Stupid type defaulting makes your test run with the [()] type
03:56:29 <Peaker> @check \xs -> (xs::[Int]) == reverse xs
03:56:29 <lambdabot>   "Falsifiable, after 5 tests:\n[3,4,2]\n"
03:56:44 <Peaker> @check \xs -> (xs::[()]) == reverse xs
03:56:45 <lambdabot>   "OK, passed 500 tests."
03:56:59 <proppy> @check \xs -> xs == reverse (xs::[Int])
03:57:00 <lambdabot>   "Falsifiable, after 4 tests:\n[3,0,-5]\n"
03:57:17 <proppy> @scheck \xs -> xs == reverse (xs :: [Int]
03:57:17 <lambdabot>  Unbalanced parentheses
03:57:22 <McManiaC> @check \(xs :: [Int]) -> xs == reverse xs
03:57:22 <lambdabot>   Parse error in pattern at "->" (column 16)
03:57:24 <proppy> @scheck \xs -> xs == reverse (xs :: [Int])
03:57:25 <lambdabot>   "Falsifiable, after 3 tests:\n[0,1,0,4]\n"
03:57:26 <McManiaC> :D
03:57:33 <McManiaC> no scoped thingy :(
03:57:46 <proppy> ski: I'm pretty sure it returned passed 500 tests for you before :)
03:58:15 <ski> @czech "Slovak Republic" /= "Czech Republic"
03:58:16 <proppy> oh ok, because you missed the type signature
03:58:16 <lambdabot>   "OK, passed 500 tests."
03:58:18 <proppy> I got it
03:58:29 <McManiaC> <lambdabot>   "Falsifiable, after 5 tests:\n[3,4,2]\n" <- I wonder what the first 5 tests were :>
03:58:39 <Peaker> McManiaC, pallindromes!
03:58:59 <Peaker> empty lists and singleton lists probably
03:58:59 <ski> proppy : with no type signature, it defaulted to checking `(\xs -> xs == reverse xs) :: [()] -> Bool'
03:59:19 <proppy> yes, that what Peaker said :)
03:59:21 <Peaker> Type defaulting should be turned off
03:59:27 <Peaker> It's a dumb feature
03:59:27 <ski> s/type signature/type ascription/
03:59:34 <Peaker> Almost always not what you want
03:59:49 <Peaker> Except for "Integer" defaulting for Integral and such, maybe :)
04:00:02 <ski> it could be turned on by the "-XNewbie" flag ..
04:00:15 <McManiaC> hehe
04:00:41 <ski> (but i'd like to see empirical studies showing that it helps newbies)
04:01:20 <proppy> @let a = _ where (x:_) = "ab"
04:01:20 <lambdabot>   Parse error in expression: WildCard
04:01:27 <proppy> @let a = z where (x:z) = "ab"
04:01:28 <lambdabot>  Defined.
04:01:33 <proppy> :t a
04:01:34 <lambdabot>     Ambiguous occurrence `a'
04:01:34 <lambdabot>     It could refer to either `L.a', defined at <local>:4:0
04:01:34 <lambdabot>                           or `SimpleReflect.a', imported from SimpleReflect at State/L.hs:73:0-32
04:01:37 <ski> @type L.a
04:01:38 <lambdabot> [Char]
04:01:42 <ski> > L.a
04:01:43 <lambdabot>   "b"
04:01:46 <proppy> L.a ?
04:01:53 <proppy> local
04:01:54 <ski> > SimpleReflect.a + b
04:01:55 <lambdabot>   a + b
04:02:12 <ski> > foldr f z [SimpleReflect.a,b,c]
04:02:12 <lambdabot>   f a (f b (f c z))
04:02:16 <ski> > foldl f z [SimpleReflect.a,b,c]
04:02:17 <lambdabot>   f (f (f z a) b) c
04:02:34 <proppy> :t SimpleReflect.a
04:02:35 <lambdabot> Expr
04:02:37 <ski> `L' is the module in which lambdabot's `let' bindings enter
04:02:48 <proppy> :t SimpleReflect
04:02:49 <lambdabot> Not in scope: data constructor `SimpleReflect'
04:03:00 <ski> `SimpleReflect' is a module
04:05:51 <proppy> > SimpleRelfect.head [1,2,3]
04:05:52 <lambdabot>   Not in scope: `SimpleRelfect.head'
04:05:56 <proppy> > SimpleReflect.head [1,2,3]
04:05:57 <lambdabot>   Not in scope: `SimpleReflect.head'
04:06:02 <proppy> > SimpleReflect.a head [1,2,3]
04:06:03 <lambdabot>   Couldn't match expected type `([a] -> a) -> [t1] -> t'
04:06:03 <lambdabot>         against infe...
04:06:43 <ski> what are you trying to coerce poor lambdabot into ?
04:07:05 <ski> > head [0,1,2]
04:07:06 <lambdabot>   0
04:07:17 <dibblego> @type let p a b c d = let y = compare a b in if y == EQ then compare c d else y in p
04:07:18 <lambdabot> forall a a1. (Ord a1, Ord a) => a -> a -> a1 -> a1 -> Ordering
04:07:31 <proppy> I'm trying to figure out how to use SimpleReflect :)
04:07:41 <proppy> > sum [1..5] :: Expr
04:07:42 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
04:07:53 <proppy> > head [0,1,2] :: Expr
04:07:53 <lambdabot>   0
04:08:15 <dibblego> ski, that's what I really wanted
04:08:18 <proppy> > map (+1) [1..5] :: Expr
04:08:19 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:08:19 <lambdabot>         against inferred ...
04:08:26 <ski> > (head . tail . tail . iterate (^ 2)) 1
04:08:27 <proppy> > map (+1) [1..5]
04:08:27 <lambdabot>   1
04:08:28 <lambdabot>   [2,3,4,5,6]
04:08:41 <ski> > (head . tail . tail . iterate (^ 2)) 2
04:08:42 <lambdabot>   16
04:08:48 <ski> > (head . tail . tail . iterate (^ 2)) 2 :: Expr
04:08:49 <lambdabot>   2 * 2 * (2 * 2)
04:09:11 <ski> > (head . tail . tail . tail . iterate (^ 2)) 3 :: Expr
04:09:12 <lambdabot>   3 * 3 * (3 * 3) * (3 * 3 * (3 * 3))
04:09:18 <proppy> > (map (+1) [1..5]) :: Expr
04:09:19 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:09:19 <lambdabot>         against inferred ...
04:09:24 <proppy> :(
04:09:31 <ski> > map (+ 1) [0 .. 4] :: [Expr]
04:09:32 <lambdabot>   [0 + 1,1 + 1,2 + 1,3 + 1,4 + 1]
04:09:48 <proppy> ski you're lucky
04:10:01 <ski> dibblego : so, more or less `compare' on pairs ..
04:10:02 <proppy> > (map (+ 1) [1 .. 5]) :: Expr
04:10:03 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:10:03 <lambdabot>         against inferred ...
04:10:17 <ski> proppy : `Expr' is not `[Expr]'
04:10:18 <proppy> > map (+ 1) [1 .. 5] :: [Expr]
04:10:18 <lambdabot>   [1 + 1,2 + 1,3 + 1,4 + 1,5 + 1]
04:10:22 <proppy> oh ok :)
04:10:52 <ski> > fix (1 +) :: Expr
04:10:53 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
04:11:09 <dibblego> ski, yes, except also (compare, compare) is an argument
04:11:30 <ski> dibblego : is an argument of what ?
04:11:50 <dibblego> @type let p (f, g) a b c d = let y = f a b in if y == EQ then g c d else y in p
04:11:51 <lambdabot> forall t t1 t2 t3. (t -> t1 -> Ordering, t2 -> t3 -> Ordering) -> t -> t1 -> t2 -> t3 -> Ordering
04:12:34 <ski> ok .. an `compareBy', so to speak
04:12:41 <dibblego> yes
04:12:59 <ski> hmm
04:16:48 <ski> @type \(compareA,compareB) -> curry (uncurry mappend . (uncurry compareA *** uncurry compareB) . ((fst *** fst) &&& (snd *** snd)))
04:16:49 <lambdabot> forall c a b a1 b1. (Monoid c) => (a -> a1 -> c, b -> b1 -> c) -> (a, b) -> (a1, b1) -> c
04:16:50 <Peaker> @src sum
04:16:50 <lambdabot> sum = foldl (+) 0
04:16:51 <ski> @type \(compareA,compareB) -> curry (uncurry mappend . ((uncurry compareA . (fst *** fst)) &&& (uncurry compareB . (snd *** snd))))
04:16:52 <lambdabot> forall a b a1 b1 c. (Monoid c) => (a -> a1 -> c, b -> b1 -> c) -> (a, b) -> (a1, b1) -> c
04:16:59 <Peaker> foldl? really?
04:17:28 <ski> (it ought to be `foldr', imo)
04:19:02 <Peaker> Well, I am trying to check some stack-blowing things, and "sum" blew up, but sum = foldl' (+) 0  didn't
04:19:11 <ski> @type curry . (uncurry mappend .) . (. ((fst *** fst) &&& (snd *** snd))) . uncurry (***) . (uncurry *** uncurry)
04:19:12 <lambdabot> forall c' a b a1 b1. (Monoid c') => (a -> b -> c', a1 -> b1 -> c') -> (a, a1) -> (b, b1) -> c'
04:19:14 <dolio> Are optimizations on?
04:19:45 <c_wraith> > fix (+ 1) :: Expr
04:19:51 <Peaker> dolio, ghci, by default no, I guess
04:19:52 <lambdabot>   mueval: ExitFailure 1
04:20:06 <dolio> There are rewrite rules for Int and Integer to use foldl'.
04:20:12 <dolio> Others will probably blow up.
04:20:20 <Peaker> ah
04:20:23 <dolio> And rewrite rules only work with optimizations.
04:20:59 <dolio> > sum [1.0...100000]
04:21:02 <lambdabot>   Not in scope: `...'
04:21:07 <dolio> > sum [1.0..100000]
04:21:08 <lambdabot>   5.00005e9
04:21:19 <dolio> > sum [1.0..1000000]
04:21:21 <lambdabot>   *Exception: stack overflow
04:21:31 <dolio> In particular, Float/Double blows up.
04:21:43 <dolio> They aren't special cased.
04:22:20 <proppy> > let p@(x,y,z) = (1,2,3) in (p,z,y,x)
04:22:21 <lambdabot>   ((1,2,3),3,2,1)
04:22:22 <ski> dibblego : anyway .. `\(compareA,compareB) (a0,b0) (a1,b1) -> (a0 `compareA` a1) `mappend` (b0 `compareB` b1)'
04:23:02 <ski> @src scanr
04:23:02 <lambdabot> scanr _ q0 []     =  [q0]
04:23:02 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
04:23:02 <lambdabot>     where qs@(q:_) = scanr f q0 xs
04:24:36 * hackagebot ansi-terminal 0.5.3 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.5.3 (MaxBolingbroke)
04:26:44 <Peaker> ghci -O2 should turn optimizations on, right?
04:26:57 <dolio> I suspect not.
04:27:05 <aavogt> you could compile the code before loading into ghci
04:27:17 <dolio> Yes, that would probably work.
04:28:11 <aavogt> but less names are in scope when you do that. So if you want to combine some functions they have to be exported or something.
04:32:04 <McManiaC> ghci -O2 O.o
04:32:21 <aavogt> besides the stack overflows, you can see that a module is interpreted if your prompt looks like   *ModuleName>
04:41:00 * ManateeLazyCat When your heart is empty, close your eyes, quietly listening to these songs: http://www.xiami.com/song/play?ids=/song/playlist/id/368796/type/3
05:07:19 <burp> hm, bytestring lazy to strict one and reverse with packing/unpacking it?
05:07:49 <Peaker> strictifyBS = SBS.concat . LBS.toChunks
05:07:53 <Peaker> lazifyBS = LBS.fromChunks . return
05:08:01 <Peaker> with the above imports being:
05:08:01 <Peaker> import qualified Data.ByteString as SBS
05:08:02 <Peaker> import qualified Data.ByteString.Lazy as LBS
05:08:23 <Peaker> Would be nice if they weren't both called "ByteString", and one really isn't
05:15:48 <Gracenotes> I like our primitive namespacing. so long as you're aware of the conventions.
05:19:53 <Peaker> Gracenotes, I like the namespacing too
05:20:01 <Peaker> Gracenotes, I dislike the name "ByteString" for lazy bytestrings
05:20:53 <ivanm> Gracenotes: we have conventions?
05:20:55 <ivanm> since when?
05:20:56 <ivanm> :p
05:33:31 <kamatsu> this guy writes haskell off as a dead language:
05:33:33 <kamatsu> http://www.focus.com/briefs/software-development/12-coding-languages/
05:34:03 <mwotton_> kamatsu: yeah, i was bitching about it in here the other day
05:34:17 <mwotton_> hard to take seriously when he includes brainfuck, though
05:34:21 <kamatsu> yeah
05:37:50 <ivanm> I thought coldfusion was relatively popular
05:37:58 <ivanm> mwotton_: same goes with intercal
05:38:45 <Ke> "functional language alternatives available (such as MATLAB)"
05:38:47 <Ke> !
05:38:56 <ivanm> I love how he says "there are a number of problems with functional programming languages and with lazy evaluation", without saying what...
05:39:12 <poli1ce> <!--ADULTSONLY-->
05:39:12 <poli1ce> <meta http-equiv="pics-label" content='(pics-1.1 "http://www.icra.org/ratingsv02.html" l gen true for "http://asstr.org" r (cz 1 la 1 lb 1 lc 1 na 1 nb 1 nc 1 nd 1 ne 1 nf 1 ng 1 nh 1 ni 1 oa 1 ob 1 oc 1 of 1 og 1 oh 1 va 1 vb 1 vc 1 vd 1 ve 1 vf 1 vg 1 vh 1 vi 1 vj 1 vk 1) "http://www.rsac.org/ratingsv01.html" l gen true for "http://asstr.org" r (n 4 s 4 v 4 l 4))' />
05:39:17 <poli1ce> <SCRIPT LANGUAGE=JavaScript SRC=http://www.asstr.org/scripts/common.js></script>
05:39:21 <poli1ce> <SCRIPT LANGUAGE=JavaScript SRC=http://www.asstr.org/scripts/scroller2.js></script>
05:39:24 <poli1ce> <SCRIPT Language="Javascript">
05:39:27 <poli1ce> <!--
05:39:29 <poli1ce> runScroller();
05:39:32 <poli1ce> //-->
05:39:34 <poli1ce> </SCRIPT>
05:39:37 <poli1ce> <pre>
05:39:39 <poli1ce> <br><br>
05:39:42 <poli1ce> <font color=blue>
05:39:44 <poli1ce> Note: This story was dynamically reformatted for online reading convenience.
05:39:46 <ivanm> @where ops
05:39:46 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
05:39:47 <poli1ce> </font>
05:39:49 <poli1ce> BIG FEATURE AT ST CAT'S
05:39:52 <poli1ce>    by Some Sort of Dog
05:39:54 <poli1ce>    WARNING: This warning is slightly different every time, but it always
05:39:54 --- mode: ChanServ set +o mauke
05:39:55 --- kick: poli1ce was kicked by mauke (poli1ce)
05:39:59 <ivanm> mauke++
05:40:06 <mauke> what's this then
05:40:50 <ivanm> was that a joke based off the spammers nick?
05:41:05 <ivanm> I found it interesting that they pasted the _source_ for the web page they were spamming from...
05:41:29 <kamatsu> it's an erotic  stories site
05:41:38 <Ke> people sometimes paste things by accident
05:41:53 <mauke> that's why I just kicked him
05:41:54 <Ke> though it typically does not happen right after joining the channel
05:41:55 --- mode: mauke set -o mauke
05:42:01 <ivanm> Ke: heh, a pretty embarrasing one to paste accidentally...
05:42:04 <mauke> looks like he quit
05:42:06 <Peaker> I wish all recursive definitions in the stdlib were tail-recursive
05:42:08 <Ke> true
05:42:20 <ivanm> Peaker: even though GHC doesn't have TCO for the most part?
05:42:21 <mauke> Peaker: why? you like stack overflows?
05:42:34 <Peaker> ivanm, it does when forcing the value
05:42:43 <ivanm> hmmm...
05:42:43 <Peaker> mauke, It's because I don't like them...
05:42:54 <mauke> tail recursion causes stack overflows
05:42:56 * ivanm tries to remember how to use a spreadsheet to arrange and manipulate the data
05:43:11 <Peaker> ivanm, For example, I'm getting stack overflows when using: xs <- replicateM 10000000 (return 1) -- because sequence isn't tail-recursive
05:43:21 <Saizan> Peaker: you can't just say "all recursive definitions" e.g. map is not tail recursive and shouldn't be.
05:43:43 <ivanm> Peaker: does it make sense for sequence to be tail recursive?
05:43:54 <Peaker> Saizan, I guess I have to specify some predicate on strictness
05:44:10 <Peaker> ivanm, For strict monads, I think so
05:44:19 <Peaker> Saizan, I'm not exactly sure what though
05:44:25 <ivanm> do we have some kind of indication if something is strict?
05:44:25 <ski> Peaker : e.g. `map' shouldn't be tail-recursive
05:44:39 <Peaker> ski, Yeah, it has a lazy result
05:45:11 <Peaker> Maybe the predicate I'm looking for is when the result is strict
05:45:24 <Peaker> mauke, tail-recursion avoids stack overflows
05:45:34 <Peaker> mauke, Can you give an example of the opposite?
05:46:30 <mauke> map!
05:47:04 <Ke> ivanm: typical problem with functional programming is the lack of easy to use rand
05:47:18 <ski> Peaker : which monad did you use `replicateM' in ?
05:47:23 <Ke> ivanm: and non-trivial space leak is a problem with laziness
05:47:24 <Peaker> ski, IO
05:47:41 <Ke> ivanm: why do you even need to ask
05:47:49 <Peaker> mauke, Well, there are counter-examples too as I mentioned above
05:47:50 <ivanm> Ke: the first is a problem with _pure_ FP
05:48:30 <Peaker> Ke, Rand is easy-to-use, even if you have to escape to a State monad or even IO
05:48:37 <Peaker> Ke, the space leaks are a problem indeed
05:48:41 <ivanm> Ke: would I be correct in assuming you had the lowest form of wit in mind when crafting your response?
05:49:50 <ninegrid> i've been trying to cabal install vacuum-cairo,  it fails on the strict-concurrency dependency complaining that the type constructor or class NFData is not in scope,  Control/Concurrent/MVar/Strict.hs 
05:51:02 <Saizan> ninegrid: retry with --constraint="parallel < 3"
05:51:13 <ivanm> dammit, Saizan beat me to it
05:51:50 <Saizan> don't ever trust a build-depend in a package by dons :)
05:52:46 <ManateeLazyCat> Saizan: True. :)
05:53:40 <Saizan> ninegrid: you should mail the maintainer of strict-concurrency about this, btw
05:55:02 <Ke> ivanm: I am not sure ;o)
05:55:51 <ninegrid> Saizan: I will do that.  That seems to have worked too, but now I have an issue in which G.eventKeyName is ambiguous between Graphics.UI.Gtk and Graphics.UI.Gtk.Gkd.Events for vaccum-cairo
05:56:26 <Peaker> Is there a known way to automatically transform some non-tail recursive definitions to be tail-recursive? It sounds like it should be possible for cases like sequence
05:56:37 <ManateeLazyCat> ninegrid: Don's still not fix that?
05:56:45 <ninegrid> s/Gkd/Gdk
05:56:56 <ManateeLazyCat> ninegrid: I remember i have send patch to dons to fix gtk event.
05:57:08 <ninegrid> I'm a haskell noob for sure, but here I was thinking dons was a hero
05:57:25 <ski> (the CPS-transform yields code where every call is a tail call ..)
05:57:49 <Saizan> Peaker: with monads you can use ContT :)
05:58:00 <ninegrid> He seems to have contributed quite a bit as I've seen his name on many things...
05:58:09 <ski> Peaker : btw, i'm not exactly sure what code you'd prefer for `replicateM'
05:58:22 <ninegrid> ManateeLazyCat: what should I do to fix the ambiguity?
05:58:24 <Peaker> ski, Anything that doesn't stack-overflow :)
05:58:27 * ManateeLazyCat pasted "vacuum-cairo patch" at http://paste2.org/get/925950
05:58:28 <ManateeLazyCat> ninegrid: Above patch fix vacuum-cairo.
05:58:31 <ski> such as ? :)
05:58:40 <Peaker> Saizan, something like: runContT . sequence . map lift ?
05:58:51 * ski isn't yet sure why the current code stack overflows
05:59:55 <ManateeLazyCat> @tell dons I don't know why "darcs send" can't send patch to you, you filter my email to spam? Anyway, http://paste2.org/get/925950 is patch to fix vacuum-cairo works with gtk2hs-0.11.0
05:59:56 <lambdabot> Consider it noted.
05:59:57 <Saizan> ninegrid: he is surely an active and prolific member of the community, he appears too busy to be a proper maintainer at times, though :)
06:00:25 <Peaker> ski, I think it's because sequence in the strict IO monad isn't tail-recursive and is forced arbitrarily deep
06:00:47 <ManateeLazyCat> ninegrid: You just change "import qualified Graphics.UI.Gtk as G" to "import qualified Graphics.UI.Gtk as G hiding (eventKeyName)", problem will fix.
06:01:00 <Peaker> @src sequence
06:01:00 <lambdabot> sequence []     = return []
06:01:00 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:01:00 <lambdabot> --OR
06:01:00 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
06:01:06 <Saizan> ninegrid: use cabal unpack vacuum-cairo to get the source
06:01:43 <ManateeLazyCat> Saizan: dons@galois.com is don's email, why "darcs send" can't send patch to dons?
06:02:33 * ManateeLazyCat I suppose i have send patch to dons, but looks don haven't receive it somehow.
06:02:48 <Saizan> ManateeLazyCat: no idea
06:03:01 <ManateeLazyCat> ninegrid: Download vacuum-cairo package, and change with my suggest, i think problem will fix.
06:04:25 <Saizan> Peaker: yes, "runContT . sequence . map lift", never tested this idea though :)
06:04:25 <ski> Peaker : hm .. oh, right, the recursive call is not the last call inside the `do'-block
06:04:53 <Peaker> Saizan, Well, I don't get constant-space for the replicateM, I get heap blowup instead of stack blowup
06:05:18 <Saizan> Peaker: it can't be constant-space, it has to accumulate a list somewhere
06:05:19 <Peaker> Saizan, runContT (replicateM 10000000 (return 1) :: ContT Int IO [Int]) (return . last)  -- I expected this to run in constant space
06:05:32 <Peaker> Saizan, well, I'm not keeping the list
06:05:37 <Saizan> you are
06:05:45 <Peaker> where?
06:05:48 <ManateeLazyCat> ninegrid: Fix now?
06:06:02 <ski> hm, i suppose in "strict" monads, `sequence mas' will never get to the `return's if `mas' is an infinite list .. so rewriting it to accumulator-style should be ok, i think
06:06:34 <Saizan> Peaker: that will run in constant space only in sufficiently lazy monads, IO isn't one of those, and afaiu ContT makes even a lazy monad quite stricter
06:07:04 <Peaker> Saizan, ah, is there a way to make the existing functions run in constant space?
06:07:09 <ski> Peaker : you're not using `replicateM_', so semantically, the list is constructed (and maybe discarded after that)
06:07:09 <Peaker> Or do I have to roll my own accumulator-style ones?
06:07:14 <Saizan> Peaker: the fact is that "replicateM 10000000 (return 1)" there won't give (return . last) any access to the list until it built it all
06:07:23 <Peaker> ski, Sure, but I was hoping nobody is keeping a reference to the list's beginning
06:07:34 <Peaker> Saizan, ah
06:07:39 <ski> Peaker : i'm talking about the output list, not the input list
06:07:50 <Peaker> I guess my problem is with IO [..]
06:07:59 <Saizan> yeah
06:08:09 <Peaker> I could have a ListT IO  instead
06:08:21 <Saizan> right, a ListTDoneRight though
06:08:26 <Peaker> Yeah
06:08:41 <ninegrid> ManateeLazyCat: I am going to begin the process now.  I've got a 6 day old son so I was helping his mom for a minute...
06:08:41 <Peaker> yairchu has the list package
06:11:56 <ManateeLazyCat> ninegrid: Ok, i give you detail step to fix this problem: 1) Download http://hackage.haskell.org/packages/archive/vacuum-cairo/0.4.1/vacuum-cairo-0.4.1.tar.gz and extract package. 2) Open System.Vacuum.Cairo.hs file, jump line 21 "import qualified Graphics.UI.Gtk as G", add " hiding (eventKeyName)" at line end. 3) Use "cabal install" install vacuum-cairo package.
06:12:42 <Saizan> ManateeLazyCat: btw, step 1 can be replaced with "cabal unpack vacuum-cairo"
06:13:05 <ManateeLazyCat> Saizan:  :)
06:17:09 <Saizan> ListT IO would work best with the explicit sharing machinery i guess, or with a substructural type system, so you can decide that the effects must not be duplicated
06:18:28 <ninegrid> i just went to .cabal/packages/hackage.../vacuum-cairo/
06:18:40 <ninegrid> unpacked the tarball, made the change and tar gz'd it back up
06:18:43 <ninegrid> one sec
06:19:27 <ninegrid> ok it worked
06:19:37 <ManateeLazyCat> ninegrid: Great.
06:20:51 <stulli> How do i uninstall a haskell-package that is installed with cabal? I want to get rid of monads-tf
06:21:06 <Phyx-> ghc-pkg unregister monads-tf
06:21:09 <ManateeLazyCat> stulli: ghc-pkg unregister
06:21:13 <stulli> thx!
06:21:35 <ManateeLazyCat> stulli: Infact, it's not uninstall, just unregister from ghc database.
06:21:39 <Phyx-> that won't actually delete the object files, just tell ghc to not use them though
06:21:55 * Phyx- pokes ManateeLazyCat :P
06:22:01 <ManateeLazyCat> Phyx-: :P
06:22:30 <stulli> Ok, is monads-tf somehow a replacement for mtl? 
06:23:24 <stulli> I'm a little confused because those two packages gave me a conflict
06:23:59 <Saizan> ninegrid: heh, that's quite hacky actually, but not so horrible if you don't touch the .cabal file, i guess
06:24:00 <Phyx-> they mostlikely share some functionality, but you don't have to uninstall to solve, just either use cabal or hide one of them
06:24:33 * Phyx- has been waiting 5mins already for a 1kb file to be checked into version control
06:25:00 <dafis> Phyx-: use darcs
06:25:33 <Phyx-> dafis: nah, I think it's my internet connection
06:25:55 <dafis> Phyx-: irc seems to work fine
06:26:01 <Phyx-> I'll use darcs for the haskell stuff and TFS for the C# stuff
06:26:20 <Phyx-> dafis: my internet connection is weird.. it sometimes just won't allow new connections
06:26:21 <gwern> Team Fortress Source?
06:26:25 <gwern> sweet
06:26:33 <Phyx-> Team Foundation Server
06:26:37 <gwern> reminds me of the Quake interface to ps
06:27:00 <Phyx-> doing an initial checkin, 148 files :P
06:27:32 * gwern advises rocket-jumping and then nailing the files en masse
06:28:07 <Phyx-> is that a darcs command?
06:28:16 <Phyx-> darcs push -with-rocket ?
06:28:35 <ManateeLazyCat> Phyx-: Darcs is pretty fast. 
06:29:18 <Phyx-> Yeah... But i'm still more of a fan of centralized source control
06:29:19 * Phyx- hides
06:30:46 <gwern> centralized is just premature optimization of DVCS...
06:31:16 <danderson> given a Word32 that's supposed to be a signed int, how do I cast it back to account for the sign?
06:31:25 <danderson> Should I just do my own two's complement arithmetic?
06:31:32 <Phyx-> but the reason i choose TFS is that it integrates with VS, but also syncs to the bug tracker, So i don't really have to leave the IDE
06:31:53 <dafis> danderson: fromIntegral
06:33:03 <dafis> Prelude Data.Word> fromIntegral (2^31+5 :: Word) :: Int
06:33:03 <dafis> -2147483643
06:33:09 <danderson> dafis: huh, well damn. Thanks :)
06:33:20 <danderson> the simple answers are the ones that elude me most, it seems
06:33:54 <dafis> danderson: however, I'm not sure it's guaranteed behaviour
06:34:25 <dafis> danderson: you could also use unsafeCoerce :)
06:35:54 <v0|d> $ man ghc
06:35:54 <v0|d> No manual entry for ghc
06:35:59 <v0|d> shame on you #haskell.
06:36:18 <dafis> v0|d: works here
06:36:29 <Botje> GHC(1)                     Glasgow Haskell Compiler                     GHC(1)
06:36:33 <Botje> works here.
06:36:47 <dafis> v0|d: how did you install ghc?
06:37:43 <v0|d> dafis: hmm
06:37:52 <v0|d> dafis: arch package prob.
06:38:12 <Saizan> arch strips the manpages in general, no?
06:38:13 <dafis> v0|d: complain to the packager
06:39:04 <v0|d> dafis: complaining is my profession:P
06:39:17 <dafis> v0|d: is it well paid?
06:39:49 <Phyx-> one would think so, isn't that basically what managers do?
06:40:02 <gwern> Saizan: arch strips the man pages? that sounds nuts
06:40:07 <Philonous> complain in #arch-haskell , bring some life to the channel
06:40:14 <gwern> who has the man pages memorized for everything?
06:40:32 <v0|d> gwern: i cant i dont have a phd to memoize!
06:40:38 <Peaker> Saizan, but the type of newListArray doesn't let me use ListT IO..  The "list" package has a List class which allows using lists and ListT interchangably.. if this was prevalent, I could use it here
06:41:00 <Philonous> gwern: It certainly doesn't. 
06:41:03 <v0|d> (referring to the latest thread on reddit..)
06:41:03 <Peaker> Saizan, It appears if I want to make a large unboxed polymorphic array, I have to use a "default value" and then loop over writing it
06:41:07 <gwern> v0|d: don't you know? theses are the memoizations of phds
06:41:23 <dibblego> is there a unicode char for <$> ?
06:41:27 <Peaker> Saizan, newListArray does not allow an input generated by IO, unless I use lazy I/O hacks
06:41:32 <gwern> once the thesis is generated, you can shortcut the evaluation of phd?
06:41:37 <v0|d> which language pragma to employ for recursive data?
06:42:18 <Saizan> Peaker: right, or you force it all up front
06:43:05 <Saizan> v0|d: recursive datatypes don't require any extension
06:43:19 <Peaker> Saizan, yeah, but then I overflow the heap
06:43:27 <Peaker> Saizan, I barely have space for the array :)
06:43:29 <Phyx-> asadda
06:43:32 <Phyx-> that's odd
06:43:36 <Phyx-> why can I type here
06:44:07 <v0|d> Saizan: hmm okk
06:45:45 <Saizan> Peaker: you're making me want to design a language with call-by-need support for any monad, not just the partiality one like in haskell :)
06:46:31 <Peaker> Saizan, you mean pure code is the partiality monad?
06:46:38 <Saizan> Peaker: yeah
06:46:50 <Peaker> Saizan, how would it work?
06:47:36 <Peaker> Saizan, ListT IO is sort of a lazy-list in IO
06:48:03 <Saizan> Peaker: heh, i don't know, for a start it should be easy to insert a monad in the knot of a recursive datatype, then one would probably need some primitive like in explicit-sharing
06:49:25 <Saizan> Peaker: yeah, but working with ListT IO is not as nice as with [], because if you want to share the result of evaluating the tail you've to do that by hand
06:50:08 <Saizan> (aside from having to use (=<<) instead of ($))
06:50:17 <Gracenotes> I'm not that familiar with TH... is there a reason why a data structure that should be defined by a TH splice is out of scope, but only when it's in the same module as its use?
06:51:00 <Saizan> Gracenotes: the use needs to go below the the splice
06:51:51 <Peaker> Saizan, An IO-memoized ListT can take care of the tail-sharing, maybe?
06:52:00 <Gracenotes> oh. that entered my mind briefly, but I thought that surely the most powerful marco system ever wouldn't be affected by such trivialities
06:52:06 <Gracenotes> todo then.
06:53:06 <Saizan> Peaker: call-by-need is call-by-name + memoization :)
06:53:16 <Saizan> (some limited form of memoization)
06:53:32 <v0|d> thunks are very expensive.
06:53:33 <Peaker> Saizan, my question is what new language features would you need that Haskell does not have?
06:54:44 <v0|d> Peaker: maybe compiler can supercompile my code to finite state automata.
06:54:47 <v0|d> what would be awesome.
06:54:47 <ski> Peaker : yeah, we need more `tabulate' ..
06:54:51 <ski> @type tabulate
06:54:52 <lambdabot> forall i e. (Ix i) => (i, i) -> (i -> e) -> Array i e
06:55:10 <Peaker> ski, Not sure I understand
06:55:11 <ski> (for `IOUArray' in your case, i suppose)
06:55:23 <Saizan> Peaker: oh, i'm pretty sure you can do this in haskell, but not as nicely as i'd like, and there's probably some safety to be gained too
06:55:28 <Gracenotes> oh great now something else is out of scope. screw this, different module it is
06:55:33 <Peaker> ski, I'd need  tabulate :: (i, i) -> (i -> IO e) -> ...
06:55:55 <ski> Peaker : you complained about having to "use a \"default value\" and then loop over writing it"
06:55:59 <ski> Peaker : *nod*
06:56:10 <Gracenotes> it says it's out of scope but it's clearly a top-level non-tH declaration :/
06:56:27 <Saizan> Gracenotes: hpaste time?
06:56:28 <ski> Peaker : both the `IArray' and the `UArray' version of `tabulate' is missing :/
06:58:05 <ski> (er, s/UArray/MArray/)
06:58:15 <Peaker> ski, not sure why a mutable/impure-access array wants its inputs completely purely
06:58:27 <Peaker> I guess for newListArray it's because the "list" package is not standardized
06:58:39 <Peaker> (With a List class that allows either a normal list or a ListT)
06:58:42 <ski> @type Data.Array.MArray.newListArray
06:58:43 <lambdabot> forall i e (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
06:58:52 <ski> (that one ?)
06:58:54 <Peaker> yeah
06:59:22 <Peaker> The type could be: (Data.Array.Base.MArray a e m, List l, MItem l ~ m, Ix i) => (i, i) -> l e -> m (a i e)
06:59:44 <Peaker> or that could be newListArrayM
06:59:44 <ski> that `newListArray' is just an operation that does one effect : allocate a new array, filling it with given values
07:00:01 <Peaker> ski, Yeah, but it doesn't let you build the values monadically on-the-fly
07:00:08 <Peaker> You have to accumulate a copy of the array as a list first
07:00:10 <ski> it leaves to you to say how those values should be computed (e.g. from `IO'-actions, in which order, &c.)
07:00:13 <Peaker> (if you have effects generating the values)
07:00:24 <Peaker> or you could use unsafeInterleaveIO, but that sucks :)
07:01:09 <Gracenotes> Saizan: working on newer hackage, trying to get download counts working sanely, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28131#a28131
07:01:39 <Gracenotes> Distribution/Server/Features/DownloadCount.hs:64:17: Not in scope: `totalDownloadCount'. Distribution/Server/Features/DownloadCount.hs:65:31: Not in scope: `sortedPackages'.
07:01:46 <ski> (well, i'm not really as happy with `newListArray' as with `newArray', since the latter depends on a linearized order on the indices)
07:02:00 <ski> (also, `tabulate' doesn't depend on such ordering)
07:02:17 <ski> @type Data.Array.MArray.newArray
07:02:18 <lambdabot> forall i e (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
07:02:28 <Peaker> ski, often you can only efficiently generate the array values in-order though
07:02:34 <Peaker> ski, and not via random-access
07:02:43 <ski> (imo `tabulate' is usually more useful than `newArray', though)
07:02:55 <Gracenotes> Saizan: sorry that it's not a minimal example. I'll try prodding it, at any rate
07:02:56 <gio123> ski
07:03:15 <Peaker> ski, newArray is forcing me to use a silly initializer value
07:03:20 <ski> Peaker : yeah .. but sometimes the index order is not the order in which you'd want to generate the elements ..
07:03:39 <dafis> Peaker: newArray_ ?
07:05:12 <ski> @type Data.Array.IArray.accum
07:05:12 <lambdabot> forall e e' (a :: * -> * -> *) i. (Data.Array.Base.IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
07:05:13 <ski> @type Data.Array.IArray.accumArray
07:05:14 <lambdabot> forall e e' i (a :: * -> * -> *). (Data.Array.Base.IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
07:05:20 <ski> @type Data.Array.MArray.newAccum
07:05:21 <lambdabot> Not in scope: `Data.Array.MArray.newAccum'
07:05:21 <ski> @type Data.Array.MArray.newAccumArray
07:05:22 <lambdabot> Not in scope: `Data.Array.MArray.newAccumArray'
07:05:24 <Saizan> Gracenotes: ah, you've to put initDownloadFeature after the splice too
07:05:27 <Peaker> What class are all unboxed types instances of?
07:06:17 <Saizan> Gracenotes: and so on transitively
07:07:20 <Gracenotes> Saizan: you mean ($ with any whitespace is a splice?
07:07:32 <dafis> Gracenotes: without
07:07:50 <dafis> Gracenotes: misparsed
07:07:58 <Saizan> Gracenotes: err, no?
07:08:18 <Gracenotes> er. well, I had map ( $ blah blah ) [item, item] and that seemed to be a problem
07:08:22 <ski> hm .. why is there no `accum'- or `accumArray'- analogue for `MArray' ?
07:08:52 <proc> how can I access the second element of a 2d vector?
07:08:55 <Saizan> Gracenotes: i mean that when in a file you've a declaration-level splice, all that comes before it doesn't have in scope anything that comes from the splice or after the splice
07:08:56 <Gracenotes> ugh, what a kludge it is sometimes
07:08:58 <dafis> ski: 'cause accum[Array] uses mutable arrays internally
07:09:03 <proc> or dupel if you want so
07:09:19 <ski> dafis : .. and ?
07:09:25 <dafis> proc: 2d vector as in (x,y) ? snd
07:09:31 <proc> exactly
07:09:38 <proc> so snd, thanks
07:09:53 <Gracenotes> Saizan: is there a reason for this restriction?
07:10:11 <dafis> ski: so if you want an MArray, just unsafeThaw it afterwards
07:10:58 <Saizan> Gracenotes: i guess that the what-refers-to-what analysis would have been harder to implement otherwise :) and that needs to be done before typechecking
07:11:03 <Gracenotes> I'm not opposed to preprocessing the entire file several times if that's the issue... :/ 
07:11:31 <ski> hm .. i suppose; but it would still be nice, imo, if `accum' and `accumArray' (and `tabulate' !) was provided directly
07:11:49 <dafis> ski: nice, definitely
07:12:42 <Saizan> Gracenotes: it is quite annoying, but i don't know enough of the details to realize if it could be improved
07:15:55 <Phyx-> > l
07:15:57 <lambdabot>   l
07:16:14 <Phyx-> > o
07:16:14 <lambdabot>   o
07:16:16 <deech> Hi all, I'm having a brain cramp and failing to understand why ((++) . id) a b == (id a) ++ b. 
07:16:17 <Phyx-> > l
07:16:18 <lambdabot>   l
07:16:54 <dafis> deech: ((++) . id) a ~> (++) (id a) ~> ((id a) ++)
07:17:26 * ski learns  fix $ \a -> array ix [f `graph` i | i <- indices a]  is not a good idea
07:17:40 <Phyx-> ski: why no5?
07:17:59 <ski> > fix $ \a -> array (0,3) [(^ 2) `graph` i | i <- indices a]
07:18:03 <lambdabot>   mueval-core: Time limit exceeded
07:18:05 <Saizan> dafis: inline (.)
07:18:18 <deech> dafis: Thanks for getting rid of that Charlie Horse. It hurt!
07:18:20 <dafis> Saizan: ?
07:18:31 <Saizan> ah, sorry, that was for deech :)
07:18:36 <ski> Phyx- : apparently `indices' can't get the indices before the array elements has been initialized
07:19:03 <Phyx-> ski: ah, 
07:19:04 <deech> Saizan: I actually didn't understand that.
07:19:45 <Saizan> ((++) . id) a b = (\x -> (++) (id x)) a b = ((++) (id a)) b = (++) (id a) b = id a ++ b
07:20:06 <Peaker> deech, more generally, (x . id) = x
07:20:22 <Saizan> the last three steps are just messing with syntax
07:20:32 <Saizan> err, 2
07:20:44 <dafis> Saizan: who counts?
07:20:51 <Saizan> i do!
07:20:58 <deech>  Gottit thanks!
07:20:58 <deech>  
07:22:51 <deech> I actually came across this in the standard libs and it threw me for a loop. For more advanced Haskellers is inlining (.) more readable?
07:23:27 <Phyx-> the process to add more features: 1. add new lines. 2. change 20 files. 3. debug debug debug
07:25:21 <Phyx-> did I get it wrong? :P
07:25:26 <deech> Phyx-: Or in a dynamic language 1. add new lines 2. ship it 3. go home 4. debug it at 4am when an angry user calls.
07:25:53 <Phyx-> lol
07:26:40 <Saizan> deech: inlining and doing the reductions is what you do at the start or when you get swamped for some reason, after a while you grow intuition for higher level equalities like (f . id) = f
07:27:12 <Phyx-> great, only 2 errors left
07:27:31 <dafis> Phyx-: out of how many?
07:27:37 <Taejo> :t liftM2
07:27:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:27:40 <Saizan> other times the type is the most clear description of what the function is doing :)
07:27:56 <Phyx-> dafis: ~40
07:28:01 <Phyx-> it was a change in a base class
07:28:15 <Phyx-> the original was a hack, so now I did it "Proper"
07:28:15 <dafis> Phyx-: almost done, then :D
07:28:44 <ivanm> @tell edwardk http://ivanmiljenovic.wordpress.com/2010/07/25/results-of-fgl-naming-survey/
07:28:44 <lambdabot> Consider it noted.
07:28:51 <deech> Saizan: Cool. Thanks for explaining. It was a idiom hadn't seen before.
07:28:59 <Phyx-> dafis: well, then comes the part to see it it would actually work :P
07:29:14 <dafis> Phyx-: if it compiles, ship it
07:29:33 <Phyx-> lol
07:29:43 <Phyx-> I'm so behind schedule it's not even funny :P
07:30:42 <ivanm> OK, is anyone actually seeing anything I send to the channel?
07:30:43 * ivanm 's net is playing up...
07:30:50 <dankna> ivanm: no, I don't copy that
07:30:55 <deech> ivanm: yup.
07:30:56 <Phyx-> ivanm: nope, try again
07:31:04 <dankna> Phyx: I got there first :D
07:31:11 <dafis> ivan: me too
07:31:26 <Phyx-> ivanm: though, first thing I did see is that link
07:31:33 <Phyx-> dankna: :P
07:31:37 <dankna> yeah, the link was interesting
07:31:47 * Phyx- hopes it doesn't segfault and presses F5
07:31:55 <Phyx-> nope, segfault :D
07:32:21 <dafis> Phyx-: any suspects?
07:32:38 <Phyx-> yeah, GHC is mad at me :P
07:33:15 <Phyx-> dafis: seems I just forgot some mallocs
07:33:32 <dafis> Phyx-: oops
07:33:37 <Phyx-> take #2
07:33:44 * dafis hopes
07:35:02 <Phyx-> fail. :P
07:36:49 <Phyx-> hmmm now that it's quiet again I should enable PART, QUIT AND JOIN messages again
07:36:53 <Phyx-> it's too quiet here without them
07:36:55 <Phyx-> kinda creepy
07:36:57 <Phyx-> :P
07:39:04 * Phyx- stares around
07:40:09 <dafis> "one person indicated that they didnít care, another made an unrelated comment regarding immature equines." OMG ponies!!!
07:42:39 <Phyx-> cabal install pony
07:42:39 <Phyx-> :P
07:42:54 <Saizan> and you get an unicorn!
07:43:08 <Saizan> haskell is made of lies.
07:43:48 <jarrro> \part #haskell.cz
07:44:29 <Phyx-> lol
07:44:41 <Phyx-> Saizan: isn't a unicorn a class of pony?
07:44:58 <Jafet> You mean instance?
07:45:18 <Jafet> I didn't know cabal featured type unification.
07:45:40 <Saizan> Phyx-: no, there might be pony unicorns but they are not standardized
07:46:12 <Phyx-> well, there's your problem right there, hasn't haskell 2010 standardised pony unicorns yet?
07:46:27 <Phyx-> Jafet: yeah, i meant instance, lol
07:50:07 <monochrom> horny uniporns
07:50:47 <Phyx-> that sounds unpleasant
07:51:11 <Phyx-> weee it works!
07:51:26 <dafis> Phyx-: :D :D :D
07:54:11 * Phyx- thinks that actually doesn't look half bad
07:54:58 <deech> Is there an interface between JHC and GHC? 
07:55:26 <aavogt> have you looked at  LHC?
07:56:31 <deech> aavogt: perhaps I'm missing something. I don't see any mention of JHC on their web page.
07:57:16 <aavogt> hmm "LHC was previously a derivative of John Meacham???s JHC project (circa late 2008/mid 2009.) That code has since been retired in its entirety."
07:57:28 <deech> aavogt: I just saw that. Oops.
07:58:08 <aavogt> so I guess it's not really based on JHC anymore
07:59:13 <deech> I've heard rumours that JHC is much faster for some things that GHC, so I was wondering if I could just drop into JHC for performance-sensitive things.
08:01:27 * hackagebot Docs 1.0.0 - Documentation types library.  http://hackage.haskell.org/package/Docs-1.0.0 (DanielDiaz)
08:01:50 <dafis> deech: if you don't use many extensions and libraries, your programmes might compile with JHC
08:01:58 <dafis> could be worth a try
08:05:05 <med_> Hi, I'd like to ask something. Which is the simple method to retrieve the html source of a web page?
08:05:12 <Phyx-> I thought he wanted to compile parts of it in JHC and the rest in GHC
08:05:16 <Phyx-> that would be hard
08:05:31 <dafis> Phyx-: very hard, I think
08:05:41 <deech> med_: The HTTP library, or the CURL bindings.
08:05:44 <Phyx-> med_: have you looked at httpd-shed?
08:06:02 <med_> :Phyx: no.. where can i found some info?
08:06:38 <deech> med_: http://hackage.haskell.org/package/HTTP-4000.0.9 or http://hackage.haskell.org/package/curl
08:07:16 <Taejo> deech: I'm trying to say that it's *necessarily* true (except in monads where return x = return y) that liftM2 f a b /= liftM2 f b a
08:07:18 <Phyx-> actually that's a server, brainfart, look at what deech said
08:07:30 <Taejo> re: "heavy lift-ing"
08:07:38 <med_> :deech: thanks
08:09:57 <Taejo> deech: liftM2 f (return x) (return y) = return (f x y), and liftM2 f (return y) (return x) = return (f y x); so if they are equal in some monad, then that monad's return doesn't use its argument
08:10:00 <deech> Taejo: How about in the case where f = (+) or (*)? With lists the liftM2 (+) a b == liftM2 (+) b a
08:10:19 <Taejo> deech: that's a property of (+) and (*), not the monad
08:10:45 <aavogt> @free return
08:10:45 <lambdabot> Expected variable or '.'
08:10:51 <aavogt> @free return :: a -> m a
08:10:51 <lambdabot> Extra stuff at end of line
08:11:12 <deech> Taejo: Yes that's correct.
08:11:22 <dafis> Taejo: liftM2 (const (const result)); I think you meant to say in general, not *necessarily*
08:11:33 <aavogt> Taejo: return can't do much to it's argument other than force it (which I'm not sure is allowed by some laws)
08:11:51 <dafis> Taejo: or rather, it's necessarily the case that in general ...
08:11:58 <aavogt> @docs Control.Monad
08:11:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
08:13:30 <Taejo> aavogt: that's not what I mean... return in [] does something with its argument -- it makes a singleton list. return in () *doesn't* do anything with its argument by () monad, I mean return x = (), a >>= b = ()
08:13:42 <dafis> aavogt: if return forces its argument, return undefined >>= \_ -> [True] doesn't obey the monad laws
08:13:44 <Phyx-> > id
08:13:45 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:13:45 <lambdabot>    arising from a use of `...
08:13:54 <Phyx-> that's still not fixed?
08:13:55 <aavogt> where is () a monad?
08:13:59 <aavogt> :k ()
08:14:00 <lambdabot> *
08:14:05 <Taejo> ack
08:14:21 <Taejo> well Const (), as it were
08:14:30 <Taejo> the terminal monad
08:15:25 <Taejo> I think it might be the case that that's the only monad where return x = return y for all x, y of the same type
08:16:56 <aavogt> Reader r (Const ())
08:17:01 <aavogt> ReaderT
08:23:35 <monadic_kid> with jhc, can you use environment variables in target.ini files?
08:26:19 <chris_____> hi
08:27:01 <dafis> ho
08:38:32 <proc> *** Type           : (String,Int)
08:38:33 <proc> *** Does not match : [a]
08:38:40 <proc> what does "[a]" mean?
08:39:06 <dafis> proc: list of a
08:39:09 <jmcarthur> [a] means "list of a"
08:39:11 <proc> and a is what?
08:39:14 <jmcarthur> any type
08:39:14 <Zao> Anything.
08:39:16 <proc> ah
08:39:17 <dafis> proc any type
08:39:18 <proc> nice
08:39:34 <jmcarthur> any *particular* type (the list must be homogeneous)
08:39:48 <proc> yeah, it is of course
08:39:50 <Zao> f :: a -> b -> a  -- "function" from something of one type to something of another type (possibly the same) to something of the first type.
08:40:03 <proc> I see
08:49:26 <proc> how could it be that x has a different type than xs? I have a list [(String, Int)]
08:49:40 <proc> my function works for xs but not for x due type mismatch
08:49:48 <Zao> Show code on a paste site?
08:49:52 <proc> k
08:50:58 <proc> http://mathbin.net/50169
08:51:54 <dafis> proc: what's the error
08:52:28 <proc> http://mathbin.net/50170
08:52:35 <proc> when I do x
08:52:41 <proc> works well with xs
08:53:15 <dafis> proc: in (x:xs), x has type a, xs is a list and has type [a]
08:53:26 <proc> ah
08:53:39 <dafis> (x:xs) is the list with head x and tail xs
08:53:46 <proc> so x is (String, Int) and xs is [(String, Int)]
08:53:48 <proc> makes sense to me
08:53:54 <dafis> right
08:54:10 <proc> should've known that ;)
08:54:14 <sphynx> hello! is it a right place to ask about haskell-cairo problems in ghci? :)
08:54:36 <dafis> sphynx: worth a try
08:55:37 <sphynx> well, I've downloaded the code example of how to try cairo in ghci from here as described here: http://haskell.org/gtk2hs/archives/2005/11/10/getting-started-with-cairo/
08:56:14 <sphynx> but when I try to run some cairo drawing code from GHCI, it hust hangs on "Loading package: cairo-0.11" 
08:56:25 <sphynx> "ghc --make" runs just fine
08:56:34 <sphynx> on the same code
08:57:49 <interferon> i want to write the following snap action: "getTables conn >>= writeBS . pack . show" but getTables is IO [String]
08:57:56 <interferon> how do i lift an IO action into the snap monad?
08:58:45 <dafis> interferon: has the snap monad a MonadIO instance?
08:59:08 <dafis> sphynx: sorry, no clue :(
08:59:16 <interferon> dafis: hmm i guess not
08:59:22 <interferon> assumed that it did
08:59:49 <sphynx> maybe some ideas why ghci can hang on "loading package"?
09:00:24 <sphynx> I've tried "ghc-pkg describe cairo", nothing special there which might be able to cause an error, all the dependencies seem to be correct
09:00:49 <dafis> interferon: instance MonadIO Snap, so liftIO (getTables conn) should work
09:01:01 <interferon> right, i'm just catching up to that :)
09:02:00 <dafis> sphynx: iirc, there are some issues with ghci locating C libraries if they're not in the standard places
09:02:25 <interferon> dafis: thanks for the help
09:02:44 <dafis> sphynx: but I can't help you here, sorry
09:03:09 <sphynx> dafis: ok, I'll try to use -L or -l options t ospecify paths explicitly
09:03:22 <dafis> sphynx: good luck
09:03:27 <sphynx> thanks :)
09:09:16 <ManateeL`> sphynx: Is x86-64?
09:09:45 <sphynx> it's windows x86
09:09:51 <ManateeL`> sphynx: It's have a bug ghc/ghci on x86-64
09:09:57 <proc> Hugs> map foo (fst ("abc", 1)) where foo n = "foo"
09:09:57 <proc> ["foo","foo","foo"]
09:09:58 <ManateeL`> sphynx: is 64?
09:09:59 <sphynx> actually simple test to try is "ghci -package cairo"
09:10:00 <proc> why three times?!
09:10:13 <ManateeL`> sphynx: Is 64bit?
09:10:14 <proc> I expected a ["foo"]
09:10:19 <sphynx> 32 bit
09:11:05 <Phyx-> proc: well, you get "abc" from the tuple
09:11:13 <ManateeL`> sphynx: Wait, i test .
09:11:18 <proc> ah
09:11:20 <proc> yeah
09:11:22 <Phyx-> proc: and you map foo over "abc" which is map foo ['a', 'b', 'c']
09:11:24 <sphynx> so when I run "ghci -package cairo" or "ghci -package pango" or even "ghci -package gtk" - it loads packages until mtl and then just fails
09:11:24 <Phyx-> hence the three
09:11:33 <interferon> are there any frameworks other than yesod which try to make urls and form parameters typesafe?
09:11:52 <proc> I see
09:12:28 <ManateeL`> sphynx: Can you paste error information of "ghci -package cairo" ?
09:13:16 <sphynx> ManateeL`: yes, 1 second
09:13:21 <ManateeL`> sphynx: Ok
09:13:36 <burp> hm, did anyone have profiling problems recently? my profiling file shows "time = 0" for everything; total time  =        0.00 secs   (0 ticks @ 20 ms)
09:14:02 <dons> ivan: i'm concerned too much time has been spent on naming, and not enough on coding.
09:14:02 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:14:38 <Resurge> How can i do something like   f x = f x []     to create a function with something of an optional argument?
09:15:17 <burp> Resurge: do optional arguments with Maybe
09:15:23 <sphynx> ManateeL`: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28147#a28147
09:15:27 <jmcarthur> there are tricks you can use, but most of the time you either want two functions taking different arguments or one function taking a Maybe
09:15:54 <Resurge> I'll look into that, thanks
09:16:11 <jmcarthur> a third alternative is to factor out the part of the function using the optional argument into its own function and then simply compose the two functions when you need that additional functionality
09:16:18 <sphynx> ManateeL`: actually there are no errors, even with -v flag, ghci just didn't start
09:16:24 <jmcarthur> that sometimes isn't possible or pratical though
09:16:50 <ManateeL`> sphynx: Any error from "ghc-pkg check" ?
09:17:01 <jmcarthur> also note that i'm using a somewhat more general meaning of "compose" than just (.)
09:17:23 <Phyx-> :t Just (.)
09:17:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => Maybe ((a -> b) -> f a -> f b)
09:17:48 <Kaidelong> does anyone know of a good library for dealing with integers of custom sizes with overflow checking and operations like modular power?
09:18:07 <Kaidelong> writing one myself could be an interesting exercise, if the answer is no
09:18:16 <sphynx> ManateeL`: nope
09:18:22 <Kaidelong> but I would prefer to re-use something that exists
09:18:36 <sphynx> and here is the result of "ghc-pkg describe cairo" : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28148#a28148
09:18:55 <ManateeL`> dons: I send a patch to fix vacuum-cairo with gtk2hs-0.11.0, but i don't know why you haven't recive my mail someshow. Patch at http://paste2.org/get/925950 , cheer. :)
09:20:49 <ManateeL`> sphynx: So when you do "ghci -package cairo", ghci will hang at loading mtl?
09:21:37 <sphynx> ManateeL`: it waits for a couple of seconds (maybe 5-7 seconds) and then just exits
09:22:01 <sphynx> and it hangs when I try to run something related to cairo in ghci
09:22:53 <sphynx> for example, I run "ghci CairoGhci.hs" and then some code which should draw something in canvas, like "run (drawSquare 10 10)", then ghci starts loading packages and hangs on "loading package cairo-0.11..."
09:23:27 <sphynx> then I have to press Ctrl-C for exit
09:23:53 <sphynx> but it exits automatically on "ghci -package cairo" :) hope I'm clear enough
09:24:45 <ManateeL`> sphynx: Sorry, i haven't Windows install on my box. I have test your problem on Linux, works fine. Maybe it's a bug of gtk2hs or ghc on Windows Platform.
09:24:55 <ManateeL`> sphynx: Can you report this problem to gtk2hs list?
09:25:08 <ski> @hoogle f (f (a -> f a) -> a) -> a
09:25:08 <lambdabot> No results found
09:25:12 <ManateeL`> sphynx: Axel have Windows machine, he can help you test it.
09:25:48 <sphynx> ManateeL`: ok, thanks, I'll try
09:26:10 <ManateeL`> sphynx: BTW, Axel have fix a bug between x86_64 with ghci
09:26:22 <ManateeL`> sphynx: Maybe you can test darcs before report this problem.
09:26:58 <ManateeL`> sphynx: IIRC, you must use Cabal-1.8 on Windows, otherwise ghci can't work.
09:28:16 <ManateeL`> sphynx: "darcs get http://code.haskell.org/gtk2hs" can get darcs version.
09:28:17 <ManateeL`>  
09:28:52 <sphynx> well, it seems that it requires too much work to fix, so I'd better just compile the code with ghc
09:29:42 <ManateeL`> sphynx: If you don't want test darcs version, just report to gtk2hs list, Axel will help you test it.
09:29:56 <sphynx> I fear that my installation might become messy after the installation of yet another version of gtk :)
09:29:58 <jmcarthur> Kaidelong: i think it's basically just modular arithmetic, but this could be a start http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Fixed.html
09:30:15 <jmcarthur> Kaidelong: actually.... i am having a severe case of deja vu right now. have you asked this before?
09:30:27 <Kaidelong> jmcarthur: no, I haven't, but this looks about right, thanks
09:30:32 <sphynx> how can I access gtk2hs list?
09:30:45 <sphynx> in the most easiest way :)
09:30:50 <Kaidelong> wait, jmcarthur, is this for floating point?
09:30:58 <Kaidelong> err
09:31:09 <Kaidelong> well, not flaoting point literally, but non-integer
09:31:20 <Kaidelong> ah yes it is
09:31:25 <ManateeL`> sphynx: Just send mail to gtk2hs-users@lists.sourceforge.net
09:31:44 <sphynx> do I have to register there first?
09:31:50 <Kaidelong> so this is like how I did numbers in chemistry
09:32:01 <ManateeL`> sphynx: Don't
09:32:12 <Kaidelong> not quite what I was looking for. I guess I'll see if there is a way to turn Integers into arrays of bytes and back again
09:33:06 <ManateeL`> sphynx: You will receive mail when developer reply you. :)
09:33:40 <sphynx> ok, that's great
09:34:50 * ManateeL` Lucky, i haven't Windows.
09:34:53 <ManateeL`> :)
09:35:19 <jmcarthur> Kaidelong: ah yeah, it's not what you need after all. sorry
09:35:32 <Kaidelong> thanks
09:41:02 <Kaidelong> interesting
09:41:13 <Kaidelong> does not look like any mechanism to do this is in the haskell standard libraries
09:41:49 <Kaidelong> you'd think that if you have arbitrary precision integers, custom fixed-size integers should be straightforward, oh well
09:49:46 <chrisdone> hi
09:50:52 <sphynx> ManateeL`: well, I sent the message to list, hope someone will help fix this problem :)
09:51:27 <sphynx> "Your message has been discarded since you are not subscribed to the mailing list." :(
09:52:04 <Phyx-> hmm once you learn keyboard shortcuts you never go back
09:53:14 <ManateeL`> sphynx: Looks need subscribed, at here : https://lists.sourceforge.net/lists/listinfo/gtk2hs-users
09:53:49 <ManateeL`> sphynx: Just add your email, and send again. 
09:54:18 <sphynx> ok
09:55:10 <interferon> in a .cabal file, how do i specify that the executable should be built with "-threaded
09:55:35 <ManateeL`> interferon: ghc-options: -threaded
09:55:51 <interferon> thanks
09:56:15 <jmcarthur> i'm trying to decide whether i should just suck it up and expose things that can vary from architecture to architecture but are immutable in each run of a program as pure values like base seems to do
09:56:45 <jmcarthur> i disagree with base doing it, but it would be more consistent for me to do it as well considering that base already does it
09:57:03 <sphynx> ManateeL`: ready :) http://permalink.gmane.org/gmane.comp.lang.haskell.gtk2hs/2441
09:57:18 <Phyx-> jmcarthur: in what?
09:57:29 <ManateeL`> sphynx: We have receive your mail. :)
09:57:29 <jmcarthur> Phyx-: asking about base or about what i'm doing?
09:57:37 <Phyx-> jmcarthur: the latter :)
09:58:00 <jmcarthur> Phyx-: opengl-related things. what extensions are available, for example
09:58:12 <jmcarthur> or how many texture units are available
09:58:32 <Phyx-> jmcarthur: I would say that's perfectly fine, don't most people writing things in openGL already have alot of platform specific code anyway?
09:59:11 <jmcarthur> i suppose so, but that doesn't mean i would say it doesn't really belong in IO ideally
10:00:17 <Phyx-> well, I get what you're saying, but on the other hand, like you said they're immutable per run, so it's not really impure either
10:00:33 <jmcarthur> it depends on what you take referentially transparent to mean
10:01:08 <jmcarthur> in my mind, RT has a broader scope than only a single run of a program, just like it has a broader scope than a single evaluation of a function
10:01:13 <monadic_kid> anyone used jhc targets.ini before?
10:01:21 <benmachine> jmcarthur: what about, say, (</>) doing different things on different platforms?
10:01:46 <jmcarthur> benmachine: what is (</>)?
10:01:51 <Zao> Path append.
10:01:53 <benmachine> from System.FilePath
10:01:56 <jmcarthur> oh
10:02:15 <jmcarthur> if the result were opaque then it would be okay
10:02:16 <Phyx-> jmcarthur: wouldn't the interactions with opengl be in some kind of monadIO anyway? so what's the problem in making them in IO then?
10:02:24 <benmachine> or more generally the existence of System.FilePath.Posix and System.FilePath.Windows
10:02:46 <benmachine> jmcarthur: what do you gain by enforcing your kind of RT?
10:03:13 <jmcarthur> benmachine: for one, it would be a lot easier to implement persistence and distributed computing
10:03:41 <ManateeL`> sphynx: Looks it's issue on Windows platform, I have test CairoGhci on Linux, works fine, either ghci or ghc.
10:03:42 <jmcarthur> but other benefits include things like forcing you to write more generic code, etc.
10:04:01 <jmcarthur> Phyx-: i'm making a pure-ish interface to opengl, so am trying to make as many things pure as possible
10:04:30 <ManateeL`> sphynx: BTW, thanks for your report, we forgot "import Graphics.UI.Gtk.Gdk.Events" in CairoGhci.hs
10:04:39 <benmachine> jmcarthur: hmm
10:05:15 <jmcarthur> Phyx-: for example, static buffer objects are pure values constructed from a Vector. immutable textures are pure values too. so are programs. all this despite that they are actually loaded onto the GPU transparently
10:05:23 <sphynx> ManateeL`: yeah, it seems so, I haven't tested it on my linux box but I thought it should work flawlessly :)
10:05:50 <jmcarthur> Phyx-: err, what i mean by "pure values" is that they are constructed with functions with pure interfaces
10:05:59 <Kaidelong> so there is no way to get an array or little-endian list representation of an Integer?
10:06:07 <sphynx> ManateeL`: you are welcome, I think this import is missed because the package hierarchy has changed somehow and earlier this line was not needed
10:06:23 <jmcarthur> Kaidelong: the implementation of Integer is a ByteArray# i think
10:06:27 <jmcarthur> in ghc
10:06:41 <Kaidelong> I can't find a method for Integer to turn it into a byte array though
10:06:54 <Kaidelong> unless you recommend I go and do stuff really GHC specific
10:07:03 <jmcarthur> Kaidelong: oh it's more complicated than that actually. it's something like this:  data Integer = Foo Int# | Bar Int# ByteArray#, or something like that
10:07:06 <jmcarthur> yeah, ghc-specific
10:07:32 <jmcarthur> i don't think there is a general way to do what you want unless you just do a lot of divModding
10:07:34 <allbery_b> I# nd J#IIRC, but you shouldn't b looking at the internals
10:07:35 <ManateeL`> sphynx: It's my duty, Graphics.UI.Gtk.Gdk.Events is departed, use Graphics.UI.Gtk.Gdk.EventM instead.
10:09:04 <Phyx-> jmcarthur: I would say you would have alot more to gain by making them pure, if you don't and the rest are pure, people will mostlikely just wrap unsafePerformIO around it and use it
10:09:46 <Kaidelong> jmcarthur: I suppose I could re-invent the integer or something
10:09:46 <jmcarthur> Phyx-: well, not everything is entirely pure in this anyway, just the things that are appropriate to be pure
10:09:59 <Phyx-> aha
10:10:04 <jmcarthur> Phyx-: for example, texture units are being treated something like IORefs
10:10:12 <beutdeuce> I would like to remove all the packages i have installed through cabal that are in ~/.ghc. How can i do so?
10:10:36 <jmcarthur> Phyx-: but there should be a fixed number of texture units available during the execution of the program. does that mean i can just expose a pure constant the gives you a list of available texture units?
10:10:41 <jmcarthur> *that
10:11:16 <benmachine> jmcarthur: you could try putting it in IO for now and seeing how inconvenient it turns out to be in practice
10:11:36 <jmcarthur> probably not very
10:11:49 <jmcarthur> the issue is that i would just like to have a rigorous policy on this sort of thing
10:12:11 <jmcarthur> and i can't seem to define one that i like that is consistent with base
10:12:22 <jmcarthur> i guess because i don't like base's ;)
10:12:24 <jmcarthur> oh well
10:12:35 <benmachine> having cake, eating it, ec.
10:12:37 <benmachine> *etc.
10:12:46 <jmcarthur> the cake is a lie
10:12:50 <benmachine> obv
10:12:58 <Phyx-> jmcarthur: I would, since they don't change while executing, but actually even if you don't I don't see it as a big inconvenience though
10:13:13 <Phyx-> jmcarthur: hehehe, portal ftw :)
10:13:25 <jmcarthur> not a big inconvenience, right
10:13:30 <benmachine> I have a 146-line function
10:13:43 <benmachine> I like how that's hideous in haskell but routine in C >_>
10:13:49 <Phyx-> lol
10:13:55 <Phyx-> i have one bigger 
10:13:56 <jmcarthur> then again, i don't think many of base's architecture-dependent pure values would be much more inconvenient in pure form either
10:13:59 <Phyx-> but that's not my fault!
10:13:59 <jmcarthur> *in IO form
10:14:09 <benmachine> jmcarthur: no, so base is wrong and you're right
10:14:14 <benmachine> stand up for your beliefs :P
10:14:18 <Phyx-> ghc should define Typeable and Data instances for it's core structures
10:14:19 <jmcarthur> benmachine: i had a 2300 line module until a couple weeks ago
10:14:22 <Phyx-> consistenly
10:14:28 <Phyx-> one here, one there is rather annoying
10:15:05 <benmachine> ok 146 lines is more interesting when I realise the entire module is 595, so that's basically a quarter of my codebase
10:15:12 <benmachine> I need to split stuff up
10:15:13 <jmcarthur> i have now split that module up into many smaller modules, and my documentation and compile-times are both a lot nicer
10:15:31 <jmcarthur> *partial compile times, that is
10:15:31 <benmachine> but, working with HSE just means lots and lots of cases :P
10:15:53 <jmcarthur> i hate myself when i have a module that is longer than like 150 lines
10:15:58 <benmachine> heh
10:16:01 <benmachine> yeah
10:16:06 <Phyx-> bleh, i broke it :| optimizatuions making things slower ftl
10:16:08 <jmcarthur> sometimes it's hard to get around though
10:16:54 <Phyx-> hmm
10:17:03 <Phyx-> I don't think i have any modules with less than 150 lines
10:17:11 <Phyx-> I should be ashamed of myself :(
10:18:15 <Phyx-> the smallest haskell module i have is 712 lines
10:18:43 <benmachine> ooh, 21-line import statement
10:18:54 <benmachine> maybe I should just give up and make it explicit
10:18:56 <jmcarthur> :o
10:18:57 <benmachine> er, implicit
10:19:00 <monochrom> I have a 70-line module. It has 10 lines of code. The rest is haddock. :)
10:19:04 <jmcarthur> or qualified
10:19:04 <benmachine> heh
10:19:11 <benmachine> jmcarthur: augh no that would be hideous
10:19:25 <jmcarthur> ;)
10:19:28 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html :)
10:19:51 <jmcarthur> monochrom: awesome
10:20:04 * Phyx- would like to point out that the GHC parser is 7762 lines long :P
10:20:26 <Phyx-> and uses Tabs :P
10:20:32 <monochrom> thanks to lazy evaluation, it's short code and memory-efficient.
10:21:11 <benmachine> Phyx-: tabs :O
10:22:30 * hackagebot pandoc 1.6 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.6 (JohnMacFarlane)
10:22:45 <monochrom> I know of a forward-constraint-propagation tutorial that uses SML. Exactly same code but evaluated eagerly. It said "it only takes 120 seconds for 8 queens" and I lolled. Lazy evaluation takes no time to spit out the first solution because we don't bother to compute all possible solutions before spitting out the first.
10:23:30 <proc> what's the difference between [Char] and String?
10:23:40 <benmachine> proc: name only
10:23:41 <jmcarthur> proc: none
10:23:48 <benmachine> proc: they are the same type and can be used interchangeably
10:23:49 <Zao> @src String
10:23:50 <lambdabot> type String = [Char]
10:23:54 <proc> I see
10:23:57 <proc> thanks
10:24:05 <jmcarthur> i'm not sure i agree with the decision to go that way, but that's what we have
10:24:19 <jmcarthur> very rarely do i actually want my strings to be linked lists
10:24:37 <benmachine> but they're nice and easy to play with
10:25:43 <jmcarthur> at least ghc has OverloadedStrings
10:26:30 <proc> how would I use an if within a map? I'm not sure about the syntax
10:26:55 <monochrom> how do you mean?
10:27:00 <proc> in fact I've got a String and want to change it
10:27:14 <proc> for example "every n should become an m"
10:27:46 <monochrom> map (\x -> if x==5 then 6 else x) ?
10:27:59 <proc> ah, that looks good
10:28:01 <jmcarthur> michael rice has been on the mailing list for a looooong time and he still asks very basic questions. this has been happening long enough that i am actually a bit confused about how this is happening
10:28:01 <proc> let's see
10:28:18 <c_wraith> perhaps michael rice is a shared alias.
10:28:44 <benmachine> perhaps he dips in and out of haskell every now and then
10:28:50 <benmachine> and is forgetful
10:28:51 <jmcarthur> i didn't think about that, but it's still been very consistent
10:29:18 <jmcarthur> it seems that he asks a question that i notice every week or so
10:29:42 <monochrom> weekend haskell learner :)
10:30:29 <proc> monochrom, what does that \ mean?
10:30:50 <monochrom> if you know python, "\x -> blah" is like "lambda x: blah"
10:31:00 <pikhq> proc: It's an anonymous function.
10:31:02 <proc> nope, I don't
10:31:31 <dafis> proc: \x -> foo = the function that maps x to foo
10:31:36 <ski> proc : `\x -> ..x..' means "the function that when given any argument, call it `x', returns `..x..')
10:31:39 <pikhq> That is precisely the same (disregarding the existence of a new name) as let f x = if x==5 then 6 else x in map f
10:31:48 <ski> proc : e.g. `\x -> x^2' is the squaring function
10:31:55 <proc> function in the mathematical sense?
10:31:57 <ski> > map (\x -> x^2) [0,1,2,3]
10:31:58 <lambdabot>   [0,1,4,9]
10:31:59 <monochrom> you can define "f x = blah" somewhere else, then use it in "map f"; or you can write "map (\x -> blah)" and skip defining f.
10:32:05 <proc> I see
10:32:06 <proc> nice
10:32:12 <ski> proc : sure .. or in the Haskell sense :)
10:32:19 <pikhq> proc: Yes, that is the only sense that exists in Haskell. :)
10:32:25 <proc> heh
10:32:28 <proc> alright then
10:32:35 <ski> > let square x = x^2  in  map square [0,1,2,3]
10:32:36 <lambdabot>   [0,1,4,9]
10:33:07 <ski> proc : if you only are going to use a certain function in one place, it is sometimes nicer to not give it a name, but instead just write it and use it in-place
10:33:08 <pikhq> And of course, going back to that \x->x^2 example...
10:33:13 <pikhq> > map (^2) [0,1,2,3]
10:33:14 <lambdabot>   [0,1,4,9]
10:33:28 <sphynx> are there any convenient methods for documentation browsing? for example I need to browse gtk2hs docs now, and I use ":info" in ghci to detect where the needed function is specified and then open doc from gtk2hs website, but I think there is more optimal way of doing this
10:33:42 <proc> ski, yeah, makes sense to me
10:34:02 <dafis> proc: but if the function is complicated, give it a name
10:34:09 <jmcarthur> @where hayoo
10:34:10 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:34:12 <pikhq> proc: And congrats, you know the magic that is Lambda.
10:34:14 <jmcarthur> sphynx: ^^ ?
10:34:17 <ski> proc : after all, you don't name every subexpression in `foo a b = sqrt (a^2 + b^2)' as `foo a b = sqrt c2 where a2 = a^2; b2 = b^2; c2 = a2 + b2', usually ;)
10:34:21 <pikhq> :)
10:34:25 <ski> dafis : depends :)
10:34:34 <proc> pikhq, oh I do? ;)
10:34:50 <ski> dafis : you don't usually name every loop body in imperative programming, either :)
10:35:03 <sphynx> jmcarthur: yeah, this seems to be much better :) thanks
10:35:06 <jmcarthur> sphynx: you can also enable building documentation by default in your cabal config file and then you will have docs for whatever you install automagically, which can be nice, but doesn't give you a nice search functionality
10:35:20 <jmcarthur> could at least save you from having to go to the web though
10:35:25 <dafis> ski: I find it easier to read if complicated functions are named as in map f xs where f = long and complicated
10:35:27 <pikhq> proc: An anonymous function is also called a "lambda". \ is used to denote one in Haskell because it kinda-sorta looks like the Greek letter.
10:35:44 <proc> heh
10:35:46 <monochrom> compare \ and Œª
10:35:49 <dafis> ski: if you use forM[_], that's something different :)
10:35:50 <ski> dafis : i.e. one can say `forM_ thingies $ \thing -> do ..thing..' instead of `mapM_ processThingie thingies' where `processThingies thing = do ..thing..'
10:35:53 <proc> yes
10:36:01 <monochrom> isn't haskell exciting?
10:36:05 <proc> oh it is indeed
10:36:36 <proc> quite new when all you ever did was c, but I like it's similarit to maths
10:36:37 <ski> dafis : i sometimes write  (`map` fos) $ \foo -> ..foo..  :)
10:36:53 <ski> s/fos/foos/
10:36:58 <c_wraith> proc, there are other commonly-used ways of making anonymous functions than lambdas.  Operator sections and currying, for instance.  An operator section is like in: map (+5) [1..10]
10:37:31 <dafis> ski: okay, that works too, but if you have f . g . h with complicate f, g, h, no longer
10:37:51 <c_wraith> and currying would be like: map (subtract 10) [11..20]
10:37:59 <proc> oh currying
10:38:07 <proc> named after that guy?
10:38:14 * dafis wants peppering
10:38:20 <benmachine> the fixity of : can't be re-defined, right?
10:38:20 <pikhq> Yes, named after Haskell Curry.
10:38:23 <dafis> proc: aye
10:38:30 <proc> nice
10:38:41 <dafis> benmachine: perhaps with NoImplicitPrelude
10:38:48 <dafis> I don't know
10:39:01 <proc> whoops
10:39:03 <proc> time to go
10:39:04 <Phyx-> dafis: but then you wouldn't have [] either
10:39:10 <proc> see you guys
10:39:41 <monochrom> : is hardwired syntax, not even introduced in Prelude
10:39:41 <dafis> Phyx-: it isn't perfect :)
10:41:38 <Kaidelong> what's the motivation for hardcoding (:), couldn't you define it in a relatively straightforward way?
10:41:39 <Phyx-> lol
10:41:47 <Kaidelong> less sure about the [,..] stuff
10:42:14 <monochrom> I don't know.
10:42:18 <pikhq> Kaidelong: I'm pretty sure that you need some GHC extensions to have infix type constructors.
10:42:39 <Kaidelong> : is a constructor?
10:42:44 <Kaidelong> hmm
10:42:48 <benmachine> it's not a type constructor
10:43:05 <Kaidelong> :t (:)
10:43:06 <lambdabot> forall a. a -> [a] -> [a]
10:43:07 <benmachine> Kaidelong: you can't define lists with the [] syntax in a straightforward way
10:43:18 <jedai> Kaidelong: it's an infix data constructor
10:43:25 <pikhq> Erm, sorry. Thinko.
10:43:27 <benmachine> it would be weird to have one of the constructors builtin and one not :P
10:43:28 <pikhq> s/type/data/
10:43:50 <benmachine> pikhq: you don't need an extension for infix data constructors (although you do for types, I think)
10:43:52 <monochrom> ah, [] is the culprit
10:43:54 <dafis> pikhq: infix data constructors are H98, the [] is the problem
10:44:03 <beutdeuce_> zsh: /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.3/ghc-asm: bad interpreter: /opt/local/bin/perl: no such file or directory
10:44:07 <jedai> Kaidelong: you can define your own like : "data Tree a = Leaf | a :> [a]
10:44:08 <pikhq> benmachine: Mmmkay.
10:44:17 <beutdeuce_> that directory doesnt exist, yet ghc-asm is looking there, how can i fix that?
10:44:23 <benmachine> cf.
10:44:25 <benmachine> > 1 :+ 1
10:44:26 <lambdabot>   1.0 :+ 1.0
10:44:27 <pikhq> dafis: Yeah. [] is not really addable even with GHC extensions.
10:44:46 <dafis> right
10:44:55 <pikhq> (except Template Haskell, which is cheating and not quite the same besides
10:44:58 <pikhq> )
10:44:58 <aavogt> jedai: can you?
10:45:03 <jedai> Kaidelong: the infix data constructor must start with a : and then use operator chars (like the data constructor must start with a capital
10:45:06 <ski> well, one could ask whether one can define another `:' data constructor, if one hides the usual one
10:45:40 <benmachine> one would receive the answer, "no" :P
10:46:19 <jedai> aavogt: I mean you can define infix data contructors, ":" should in theory just be defined in the prelude but isn't in reality as far as I know
10:46:41 <Kaidelong> that's basically what I was wondering about
10:46:41 <aavogt> oh, the [a] is a normal list
10:46:55 <Kaidelong> (:) doesn't look like it is undefinable, just the [] notation for lists
10:47:11 <jedai> aavogt: Of course the main problem may be with [] and [a] syntax (circumfix isn't normal syntax)
10:47:29 <aavogt> I got confused by the Tree not being a Tree unless you like to encode the size in the type
10:47:34 <benmachine> either way, the upshot is lists have special syntax
10:48:00 <jedai> aavogt: oops... a :> [Tree a] would be better
10:48:15 <aavogt> benmachine: it's a downside because it makes people overuse lists
10:48:20 <ski> jedai : one might still define `data [] a = ...' if the `[]' itself there got accepted
10:48:35 <benmachine> aavogt: arguable. lists are pretty handy, and pretty integral to haskell code
10:49:01 <Phyx-> i don't think it's arguable
10:49:02 <Phyx-> they are
10:49:03 <Phyx-> lol
10:49:14 <jedai> ski: true but [] isn't acceptable operator char is it, even in the extension that allows type operator ?
10:49:18 <wli> If only people would overuse R trees.
10:49:22 <Kaidelong> well a list in haskell has more in common with delayed functions from Icon, right?
10:49:26 <ski>   data BalTree a = a :> BalTree [a]
10:49:40 <Kaidelong> err, suspended
10:50:03 <ski> jedai : right .. but if `[]' was an exception for a type constructor name, then one could possibly define `data [] a = ...'
10:50:15 <ski> wli : `R tree's being ?
10:50:20 <Kaidelong> so couldn't you see the special syntax for lists as being analogous to special syntax for "return" in other languages?
10:50:26 <Kaidelong> or "yield"
10:50:28 <Kaidelong> or "suspend"
10:50:32 <ManateeL`> sphynx: Still there?
10:50:41 <sphynx> yes
10:50:44 <wli> Multidimensional search trees like KDB trees.
10:50:49 <ski> Kaidelong : i'd say the special syntax for lists is just special syntax for lists :)
10:50:54 <benmachine> Kaidelong: yes except we aren't other languages :P
10:51:03 <ManateeL`> sphynx: Did you receive Axel mail?
10:51:07 <ski> wli : not sure about `KDB tree's either ..
10:51:27 <ski> wli : .. are you talking about something that can represent a relation, with multiple indices into it ?
10:51:51 <jedai> ski: Well I would really like it if Haskell syntax allowed to define the list in the Prelude, it would be a little bit less magic in a language that's already much less magic than most
10:51:52 <wli> ski: They're more typically used for spatial indexing but they're also useful for that.
10:51:55 <sphynx> ManateeL`: yes, I'm getting gtk2hs from darcs now
10:52:14 <ManateeL`> sphynx: Great, that's will be help. :)
10:52:20 <sphynx> ManateeL`: and trying to figure out how to use this EventM
10:52:37 <sphynx> ManateeL`: almost all the examples are with old Events API
10:52:39 <ManateeL`> sphynx: You have know how to use Events, right?
10:53:15 <sphynx> ManateeL`: well, I'm newbie in gtk2hs and gtk :) but I've seen some code examples
10:53:18 <ski> jedai : in SML, we have  datatype 'a list = :: of 'a * 'a list | nil  and then `[]' (and more) is provided as syntax-sugar, on top of this
10:53:35 * ManateeL` pasted "CairoGhci.hs with EventM" at http://paste2.org/get/926222
10:53:36 <ManateeL`> sphynx: Above is EventM of CairoGhci.hs, i have re-implement it. :)
10:53:45 <ski> wli : special indexing like ?
10:54:22 <Kaidelong> ski: as far as I'm aware, you could see haskell's list syntax as sugaring if you wanted to since something is either a cons cell or an empty list
10:54:22 <ManateeL`> sphynx: BTW, Axel just send mail said "my lazy fix is bad solution, let me re-implement it with EventM. " :)
10:54:23 <sphynx> ManateeL`: great, thanks :)
10:54:47 <ManateeL`> sphynx: Infact, EventM is use runReaderT monad wrap GdkEvent pointer.
10:55:03 <sphynx> ManateeL`: I'm trying to implement with EventM such a simple expression like "window `onDestroy` mainQuit"
10:55:08 <ManateeL`> sphynx: And EventM just implement *most important" feature that gtk2hs user need use.
10:55:17 <ski> Kaidelong : yeah, but the sugar in question would here be that `[]' (the data constructor) would be sugar for some valid constructor identifier
10:55:18 <sphynx> I tried "window `on` destroyEvent $ liftIO mainQuit" but it doesn't work :)
10:55:29 <wli> ski: Queries are like "what is contained in this box?" where boxes are like a_k < x_k < b_k for 0 < k < n + 1 when you have n-dimensional keys.
10:55:30 <ski> (Kaidelong : like it is in SML)
10:55:54 <wli> ski: I mostly want SML's module system.
10:56:29 <ski> wli : yeah .. it's a shame they didn't go for something like that in Haskell (.. though there were reasons for not considering it at the time)
10:57:08 <ManateeL`> sphynx: Because GTK+ C code always change GdkEvent structure, so Axel change to EventM, gtk2hs code won't change when GTK+ change GdkEvent structure.
10:57:25 <Kaidelong> isn't a new haskell standard due soon?
10:57:32 <ski> wli : hm, so the key here is an `n'-tuple ?
10:57:35 <Kaidelong> 2010, I believe
10:57:36 <ManateeL`> sphynx: You can think every EventM function is like *field* of data-type.
10:57:48 <wli> ski: With n > 1.
10:58:04 <dafis> Kaidelong: 2010 is out, 2011 next
10:58:04 <ozamosi|netbook> Kaidelong: the topic says "Haskell 2010 is out" :)
10:58:08 <sphynx> ManateeL`: yeah, I've got it, just a function to retrieve some fields associated with events
10:58:14 <ManateeL`> sphynx: Then key of EventM is : "widget `on` eventName $ tryEvent $ EventMFunction"
10:58:21 <ManateeL`> sphynx: Yep.
10:58:31 <ski> wli : i'm not sure i grasp the relation schema ..
10:58:32 <sphynx> what is "tryEvent" ?
10:58:39 <ManateeL`> sphynx: And you don't need transfer GDkEvent everywhere.
10:59:00 * ski idly wonders whether this `EventM' is related to Concurrent ML
10:59:13 <sphynx> ah, I remember from doc -- it tries to see whether this handler handles this type of event indeed or not
10:59:22 <Kaidelong> wow 2010 looks... minor
10:59:23 <ManateeL`> sphynx: tryEvent is handle wrap "tryEvent :: EventM any () -> EventM any Bool"
10:59:25 <wli> ski: It's not involved enough to be a schema. It just supports multiple inequalities on each of the n indices.
10:59:45 <ManateeL`> sphynx: When you use old Events, you need return Bool explicitly.
11:00:08 <dafis> Kaidelong: yes, they found Haskell' in one go would be too big, so they decided to take smaller steps
11:00:12 <wli> ski: (Say, let a_k be -\infty or b_k be +\infty to have one-sided things only, or both to let one of the coordinates be free.)
11:00:59 <ski> wli : so, the relation contains information about objects that occupy locations (maybe with a constraint database ?) ?
11:01:09 <ManateeL`> sphynx: tryEvent can wrap any EventM function, if you finish EventM function, tryEvent will return True automatically.
11:01:27 <wli> ski: It's used to implement those things. The thing itself is just a search tree.
11:01:33 <ManateeL`> sphynx: Of course, you can use stopEvent stop event in any place of EventM function.
11:01:44 <sphynx> aha, I see, so my example with mainQuit translates like this: window `onDestroy` mainQuit   -->  window `on` destroyEvent $ tryEvent $ liftIO mainQuit 
11:01:51 <ski> wli : yeah, i got that :)
11:02:01 <ManateeL`> sphynx: Yeap.
11:02:36 * ski is not sure how such a tree would be structured, though ..
11:02:51 <sphynx> ManateeL`: ok, thanks, I will try to rewrite another couple of "onEvents" to the new style now :)
11:03:59 <sphynx> Manateel`: btw, I've got head of gtk2hs code from darcs, what is the safest way to install it, try this trick with cairo and then return back to 0.11?
11:04:18 <ManateeL`> sphynx: Another advantage of EventM is: example, you want get keyName in "EventM any ()", so you need "keyName <- eventKeyName". tryEvent will throw exception, and your event handle function will stop automatically, so handy.
11:05:05 <ski> ManateeL` : whence `EventM' ?
11:05:17 <ManateeL`> sphynx: Have you seen bootstrap.sh under gtk2hs directory?
11:05:40 <ManateeL`> sphynx: Infact, you just need re-install gtk package.
11:05:57 <ManateeL`> ski: Graphics.UI.Gtk.Gdk.EventM
11:06:16 <sphynx> yeah, I know how to install packages, but I'm not sure how to uninstall it in proper way then :)
11:06:32 <ski> wli : hm, naÔvely, for one dimension, i suppose one could keep a sequence of all the relevant positions where things "happen" .. /me 's not sure how to continue
11:07:28 <ManateeL`> sphynx: Switch gtk2hs/gtk, and do "cabal install"
11:07:33 <ManateeL`> sphynx: That's all.
11:07:47 <ManateeL`> sphynx: Thread code in gtk package.
11:07:55 <sphynx> and how to revert back to 0.11?
11:08:07 <ManateeL`> sphynx: Darcs version is 0.11.0 version.
11:08:36 <ManateeL`> sphynx: I suggest, do a clean install "sudo chmod +x ./bootstrap.sh && ./bootstrap.sh"
11:08:42 <sphynx> ok, I'm installing :)
11:08:56 <solrize> has anyone looked at "write a scheme in 48 hours"?  it's a good article but it's not obvious to me how the scheme handles tail recursion
11:08:58 <sphynx> gtk only
11:09:03 <ManateeL`> sphynx: Because darcs repository still tag with 0.11.0, so nothing need revert. :)
11:09:11 <ski> ManateeL` : ok .. not related to CML, then
11:09:41 <ski> solrize : link to the relevant part ?
11:10:17 <ski> (solrize : istr hearing that it doesn't implement Scheme correctly, but i'm not sure in what the complaint lie)
11:10:34 <solrize> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours    
11:10:42 * hackagebot gitit 0.7.3.7 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.7 (JohnMacFarlane)
11:10:42 <solrize> well it's hard to find the relevant part
11:11:02 <Kaidelong> has there been any talk about first class patterns in Haskell?
11:11:11 <sphynx> ManateeL`: it seems it's impossible to update gtk only
11:11:20 <ManateeL`> sphynx: Why?
11:11:35 <sphynx> ManateeL`: gtk2hsC2hs.exe: Graphics/Rendering/Pango/Cairo.chi not found in:
11:11:50 <sphynx> and I can't find it either :)
11:12:16 <sphynx> it seems it's a new file in Pango which has been added after 0.11 official release
11:13:00 <ManateeL`> sphynx: Oh, i remember Axel add new patch move Pango/Cairo function to pango package.
11:13:16 <ManateeL`> sphynx: "cabal clean" in gtk package, then do "sudo chmod +x ./bootstrap.sh && ./bootstrap.sh"
11:13:21 <sphynx> yeah, July 21st is the date
11:14:02 <ManateeL`> sphynx: Don't worried, all sub-packages in darcs version is 0.11.0.
11:15:23 <ManateeL`> sphynx: You're Windows, ./bootstrap.sh can't work.
11:15:56 <ManateeL`> sphynx: Just do "cabal install" with sequence : glib, gio, cairo, pango, gtk
11:16:04 <sphynx> I have Msys installed :)
11:16:15 <sphynx> so shell scripts are fine for me :)
11:16:27 <sphynx> I am linux guy, just temporary on window, so I have my tools even here :)
11:16:47 <ManateeL`> sphynx: Ok, please tell me if still have problem after install darcs version.
11:17:03 <sphynx> funny enough "cabal clean" doesn't work in gtk
11:17:09 <sphynx> Error while removing dist/: DeleteFile "dist\\setup\\setup.exe": permission denied (Access is denied.)
11:17:34 <Saizan> sphynx: did you run cabal with sudo?
11:17:39 <sphynx> although I can delete it (and all "dist" directory) by hand without any problems
11:17:51 <sphynx> Saizan: nope, I'm on windows, don't have sudo :)
11:18:05 <monochrom> who needs sudo on dos
11:18:08 <ManateeL`> sphynx: Just delete ./dist directory under gtk
11:18:16 <ManateeL`> sphynx: Then do "cabal install"
11:18:17 <sphynx> ok :)
11:18:47 <Saizan> mh, weird, "cabal clean" shouldn't call dist\\setup\\setup.exe iirc
11:19:01 <ManateeL`> sphynx: Poor Axel, need test from GTK+ 2.8 to GTK+ 2.20....
11:19:28 <ski> solrize : in <http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Defining_Scheme_Functions>, the new clause `apply (Func params varargs body closure) args = ...' contains `>>= evalBody' as the last part in the monadic chain .. i think this gives you tail-calls
11:19:44 <Saizan> oh, it does :)
11:19:44 * hackagebot yst 0.2.3.2 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.2.3.2 (JohnMacFarlane)
11:20:45 <ski> wli : do you have any reference, or book suggestion for `R' or `KDB' trees ?
11:20:56 <sphynx> Saizan: is this ok or wrong?
11:22:26 <Saizan> sphynx: the error you get from cabal clean? i'd consider it a bug of cabal-install on windows
11:23:48 <Saizan> but there's nothing worrying, it's just that with a custom build-system like gtk has, cabal-install will demand the cleaning of dist to dist\\setup\\setup.exe, which will get that error when it tries to delete itself
11:24:30 <ManateeL`> sphynx: Just delete ./dist directory. 
11:25:15 <Saizan> yeah, that's the bottom line :)
11:26:13 <monochrom> interesting
11:26:21 <sphynx> :) ok
11:26:22 <bauchus> hi! my happstack server told me: "commitAndReleaseBuffer: hardware fault". Does it come from ghc? (I also use a berekeley DB).
11:26:35 <sphynx> well, now I've got compilation error in gtk :(
11:26:54 <sphynx> all the previous packages compiled fine (gio, cairo, pango, etc., in correct sequence)
11:27:29 <ManateeL`> sphynx: Paste error?
11:27:40 <sphynx> http://paste.lisp.org/display/112788
11:27:59 <bauchus> shynx: did you install gtk2hs-buildtools first?
11:28:41 <ManateeL`> sphynx: Hmm, looks my fault,
11:28:57 <ManateeL`> sphynx: I add gdk_x11_drawable_get_xid in darcs version.
11:28:59 <sphynx> bauchus: yes, I have them installed
11:29:20 <ManateeL`> bauchus: No bother gtk2hs-buildtools
11:29:26 <sphynx> ManateeL`: yeah, that's why I wanted to know how to reveert back safely :)
11:29:35 <ManateeL`> sphynx: Wait, i can fix.
11:29:36 <sphynx> to stable version :)
11:29:40 <ManateeL`> sphynx: Just second.
11:29:48 <sphynx> ok, thanks :)
11:30:31 <solrize> ski, thanks, looking
11:31:14 <monadic_kid> anyone used jhc cross compiling?
11:31:43 <bauchus> so, nobody knows the "commitAndReleaseBuffer" error?
11:32:43 <int80_h> hey-ooo
11:33:20 <ski> solrize : together with that the `eval env (List (function : args)) = ...' clause has `apply func argVals' as last thing in the `do'-block, of course
11:33:21 <ddarius> monadic_kid: I'm pretty sure some have.  It should cross-compile almost trivially.
11:33:53 <monadic_kid> ddarius: not trivially
11:34:22 <Heffalump> bauchus: it doesn't sound like GHC
11:34:43 <dafis> hi int80_h 
11:35:01 <ManateeL`> sphynx: Please jump to 610 line, replace "#if !defined(WIN32) || GTK_CHECK_VERSION(2,8,0)" with "#if !defined(WIN32)"
11:35:14 <monadic_kid> ddarius: i'm having issues
11:35:17 <Heffalump> bauchus: actually, google finds several results that suggest that the function might be in GHC
11:35:31 <ManateeL`> sphynx: Then do "cabal install" again.
11:35:37 <ManateeL`> sphynx: Just gtk
11:35:43 <ski> @ghc
11:35:43 <lambdabot> ghc says: GHCi's bytecode generation machinery can't handle 64-bit code properly yet.
11:35:49 <bauchus> but there are comments in trac about commitAndReleaseBuffer: http://hackage.haskell.org/trac/ghc/ticket/2699
11:36:06 * ManateeL` I guess will got error at 613
11:36:58 <bauchus> sorry i'm too slow
11:37:22 <sphynx> ManateeL`: 610 line of which file?
11:37:39 <monadic_kid> this is the problem i'm having with jhc: http://article.gmane.org/gmane.comp.lang.haskell.cafe/77872
11:37:52 <ManateeL`> sphynx: Wait, i give you file.....
11:40:45 <interferon> is there a haskell library function that escapes SQL
11:41:57 <ski> you don't need a library for that; just don't use SQL !
11:42:02 * ski ducks
11:43:48 * ManateeL` Damn, paste2.org shutdown
11:45:14 <ManateeL`> sphynx: sphynx: Found file "gtk2hs/gtk/Graphics/UI/Gtk/General/Structs.hsc", then use http://pastebin.com/2wKWZH3t replace it.
11:46:01 <interferon> ski: ?
11:46:07 <shapr> Is there a conference collector website? I'd like to know when/if there are any PLT conferences in my area.
11:46:18 <monochrom> > (\ (+-) -> True +- False) (&&)
11:46:19 <lambdabot>   False
11:46:21 <monochrom> heh
11:46:50 <monochrom> do { (+-) <- return (&&); [True +- False] }
11:46:55 <monochrom> > do { (+-) <- return (&&); [True +- False] }
11:46:56 <lambdabot>   [False]
11:47:12 <monochrom> In fact...
11:47:45 <sphynx> ManateeL`: ok
11:47:51 <Phyx-> In fact you predicted I would be back now?
11:47:55 <monochrom> > do { (‚äó) <- return (&&); [True ‚äó False] }
11:47:55 <lambdabot>   [False]
11:47:59 <ManateeL`> sphynx: So you still use X11 on Windows?
11:48:11 <sphynx> no
11:48:23 <ManateeL`> sphynx: Ok, just replace it. 
11:49:12 <ManateeL`> sphynx: drawableGetID is tweak gtk2hs function add in darcs for provide a function get GdkWindow Id on Linux and Windows.
11:49:28 <ski> interferon : sorry, bad joke
11:49:37 <ski> (i don't know about your actual question)
11:50:32 <dafis> @hoogle escape
11:50:33 <lambdabot> Network.URI escapeString :: String -> (Char -> Bool) -> String
11:50:33 <lambdabot> Network.URI escapeURIChar :: (Char -> Bool) -> Char -> String
11:50:33 <lambdabot> Network.URI escapeURIString :: (Char -> Bool) -> String -> String
11:50:45 <sphynx> doesn't build now :(
11:50:48 <ski> shapr : heh, for some reason, i read that "PLT" as in "PLT Scheme" (now known as "(PLT) Racket")
11:50:56 <ManateeL`> sphynx: New error?
11:51:33 <sphynx> it seems it doesn't like # in line 54
11:51:38 <sphynx> http://pastebin.com/raw.php?i=2wKWZH3t
11:53:04 <sphynx> Graphics\UI\Gtk\General\Structs.chs:50:2: parse error on input `#'
11:53:17 <ManateeL`> sphynx: Ok, i will remove drawableGetID function make you can buid gtk and test your problem, then i let Axel help me test drawableGetID on Windows.
11:53:58 <sphynx> are you able to build this pasted file on your machine?
12:00:07 <ManateeL`> sphynx: Please use http://pastebin.com/aSWZVu5G replace again, thanks!
12:03:42 <ManateeL`> sphynx: Compile pass?
12:04:19 <sphynx> ManateeL`: still in progress, I've cleaned gtk dist folder
12:05:13 <ManateeL`> sphynx: If this time can't compile, i will comment function drawableGetID make you can compile pass.
12:06:01 <monochrom> @pl \body -> get >>= wrap body
12:06:01 <lambdabot> (get >>=) . wrap
12:06:04 <monochrom> heh
12:06:11 <sphynx> Graphics\UI\Gtk\General\Structs.chs:116:13:   parse error on input `#'
12:06:32 <monochrom> (it is: getSessionDynFlags >>= defaultCleanupHandler body)
12:07:20 <ManateeL`> sphynx: Weird.
12:08:53 <sphynx> well, meanwhile I will create a clone of gtk2hs repository up to revision with "0.11" tag :)
12:09:43 <monochrom> :t (getLine >>=)
12:09:44 <lambdabot> forall b. (String -> IO b) -> IO b
12:10:29 <ManateeL`> sphynx: Yeap, most bugs has fix.
12:10:59 <ManateeL`> sphynx: Just those tickets at http://hackage.haskell.org/trac/gtk2hs/report/1
12:11:10 <ManateeL`> sphynx: Wait, i check again.
12:11:14 <sphynx> hmhm
12:11:21 <monochrom> shoot, I need flip
12:11:22 <sphynx> it seems now I had to revert it somehow
12:11:33 <sphynx> back to the version which I can compile
12:11:54 <sphynx> because now I don't have gtk at all, old version has been uninstalled and new version hasn't compiled :)
12:12:13 <ManateeL`> sphynx: No worried, i will help you. :)
12:12:24 <sphynx> yeah, but it just require lots of time :)
12:12:40 <ManateeL`> sphynx: Strange is i can compile on Linux
12:13:18 <sphynx> perhaps it's caused by preprocessor and these #ifdef WIN32 flags
12:13:33 <ManateeL`> sphynx: Better solution, comment drawableGetID (60 line, 605 ~ 615)
12:13:52 <ManateeL`> sphynx: Yes, i haven't Windows to test this function.
12:14:01 <ski> @type ContT (getLine >>=)
12:14:02 <lambdabot> forall r. ContT r IO String
12:14:28 <ManateeL`> sphynx: For save time, i give you Struct.hsc that not include drawableGetID, then you can compile pass.
12:14:54 <ski> @type ContT . Foreign.Marshal.Utils.with
12:14:55 <lambdabot> forall r a. (Foreign.Storable.Storable a) => a -> ContT r IO (GHC.Ptr.Ptr a)
12:14:59 * hackagebot gitit 0.7.3.8 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.8 (JohnMacFarlane)
12:14:59 <sphynx> ok, let's try, but do you think these "#"-related problems will be fixed then?
12:15:22 <ManateeL`> sphynx: Yeap.
12:16:59 <ManateeL`> sphynx: Again, http://pastebin.com/fZMsyNd8 , you don't need do "cabal clean".
12:17:08 <ManateeL`> sphynx: "cabal clean" will waste much time.
12:18:41 <sphynx> the same error :(
12:19:00 <sphynx> Graphics\UI\Gtk\General\Structs.chs:116:13: parse error on input `#'
12:19:17 <ManateeL`> sphynx: Looks something wrong on Windows.
12:21:37 <ManateeL`> sphynx: Now you can do "cabal install gtk" install gtk from package, then you can use your gtk code continue.
12:21:50 <ManateeL`> sphynx: We will notify you after we finish Struct.hsc problem.
12:22:52 <ManateeL`> sphynx: Sorry for inconvenience. :)
12:23:19 <sphynx> no problems. Also I have to install cairo, pango, etc. from hackage
12:23:19 <dafis> sphynx: is the parse error from the preprocessor or from GHC?
12:23:24 <sphynx> from GHC
12:23:30 <ManateeL`> sphynx: No,
12:23:36 <ManateeL`> sphynx: Just install gtk from hackage.
12:23:55 <sphynx> I tried, but it gives me a lot of warnings
12:24:05 <ManateeL`> sphynx: perhaps you need re-install pango and gtk
12:24:09 <sphynx> because I have these pango libraries moved to another package, etc.
12:24:13 <ManateeL`> Since Axel change pango package.
12:24:20 <sphynx> yes, that's what I'm talking about :)
12:24:23 <dafis> sphynx: if you run the preoprocessor manually, you could look at the output, maybe that would clear things up
12:24:29 <sphynx> I have to revert manually all these packages :)
12:24:38 <sphynx> dafis: how could I run it manually?
12:26:11 <dafis> sphynx: cabal install very verbosely and look at the command line; it's not a quickie, you might not care
12:26:30 <dafis> sphynx: just if you really want to find out
12:27:30 <ManateeL`> sphynx: Install package from hackage until Axel fix it.
12:27:38 <ManateeL`> sphynx: I haven't Windows, i can't did a test.
12:28:30 <ski> @djinn Identity (Identity (a -> Identity a) -> a) -> a
12:28:30 <lambdabot> f a =
12:28:30 <lambdabot>     case a of
12:28:30 <lambdabot>     I b -> b (I I)
12:28:45 <ski> @djinn Pair (Pair (a -> Pair a) -> a) -> a
12:28:46 <lambdabot> f a =
12:28:46 <lambdabot>     case a of
12:28:46 <lambdabot>     P b c -> b (P (\ d -> P d d) (\ e ->
12:28:46 <lambdabot>                                   P e (c (P (\ f -> P f f) (\ g ->
12:28:46 <lambdabot>                                                             P (c (P (\ h -> P h h) (\ _ ->
12:28:48 <lambdabot>                                                                                     P g g))) (c (P (\ i ->
12:28:50 <lambdabot>                                                                                                     P i i) (\ _ ->
12:28:52 <lambdabot>                                                                                                             P g g))))))))
12:29:09 * ski stares hard at that
12:29:51 <pikhq> I feel that this must be some greater wisdom which has been passed down through the ages.
12:30:20 <ddarius> The identity one is cute.
12:30:25 <ski> it's Grzegorczyk
12:30:44 * ski is trying to make head or tails out of it
12:31:01 <sphynx> cabal install --verbose=3 looks pretty interesting :)
12:31:12 <ski> (it might be that the `Stream' version would be more illuminative .. but djinn can't derive such a one for me ..)
12:31:36 <sphynx> well, I think I'll rather leave this task for gtk2hs developers :)
12:32:11 <ManateeL`> sphynx: If i have Windows, i will figure out where the problem. :)
12:32:30 <ManateeL`> sphynx: Thanks for your testing, we will notify you after fix this problem on Windows.
12:33:16 <sphynx> you are welcome :)
12:33:17 <ManateeL`> sphynx: I'm sure WIN32 flag make preprocess failed.
12:33:29 <Kaidelong> why not use wine in the meantime?
12:33:38 <Kaidelong> for testing, I mean
12:33:46 <ManateeL`> Kaidelong: wine is buggy.
12:33:56 <sphynx> windows is buggy too :)
12:33:59 <Kaidelong> but if something works on wine, it should work on windows, right?
12:34:14 <pikhq> Kaidelong: Not necessarily.
12:34:18 <ddarius> @djinn (l a -> Int) -> (l a -> Maybe (a, l a)) -> l a -> Int
12:34:18 <lambdabot> Error: Undefined type Int
12:34:21 <ManateeL`> Kaidelong: I'm afraid some trick problem can't test on wine.
12:34:35 <pikhq> A program on WINE could, just to screw with people, directly call Linux system calls.
12:34:46 <ski> @type \(f,g) -> (f `asTypeOf` g) (\a -> (a,a),\a -> (a,a))
12:34:47 <lambdabot> forall t t1 t2. ((t1 -> (t1, t1), t2 -> (t2, t2)) -> t, (t1 -> (t1, t1), t2 -> (t2, t2)) -> t) -> t
12:34:51 <pikhq> (just for example)
12:35:33 * ManateeL` Looks Struct.hsc everything is fine.
12:35:53 <ddarius> @djinn (l a -> int) -> (l a -> Maybe (a, l a)) -> int -> (int -> int) -> l a -> int
12:35:53 <lambdabot> f a b c d e =
12:35:53 <lambdabot>     case b e of
12:35:53 <lambdabot>     Nothing -> a e
12:35:53 <lambdabot>     Just _ -> d c
12:35:56 * ManateeL` Linux compile successful...
12:36:37 <ski> @type \(f0,f1) -> let a0 = f0 (\a -> (a,a1),\_ -> (a0,a1)); a1 = f1 (\_ -> (a0,a1),\a -> (a0,a)) in a0
12:36:38 <lambdabot> forall t t1 t2 t3 t4 t5. ((t -> (t, t1), t2 -> (t3, t1)) -> t3, (t4 -> (t3, t1), t5 -> (t3, t5)) -> t1) -> t3
12:36:41 <prsteele>  how would I pattern match against the numerator and denominator of a Rational? I use '%' to construct Rational objects, but it seems that '%' is a function, not a constructor...
12:36:48 <ski> @type \(f0,f1) -> let a0 = f0 (\a -> (a,a1),\_ -> (a0,a1)); a1 = (f1 `asTypeOf` f0) (\_ -> (a0,a1),\a -> (a0,a)) in a0
12:36:49 <lambdabot> forall t. ((t -> (t, t), t -> (t, t)) -> t, (t -> (t, t), t -> (t, t)) -> t) -> t
12:36:55 <ddarius> @djinn (l a -> int) -> (l a -> Maybe (l a, a)) -> int -> (int -> int) -> l a -> int
12:36:55 <lambdabot> f a b c d e =
12:36:55 <lambdabot>     case b e of
12:36:55 <lambdabot>     Nothing -> a e
12:36:55 <lambdabot>     Just _ -> d c
12:37:06 <ManateeL`> sphynx: Can you paste your -v3 error to me?
12:37:15 <dafis> prsteele: yes, the constructor is not exported, use numerator and denominator
12:37:38 <prsteele> dafis: thanks
12:38:23 <dafis> prsteele: you can pattern match on literals, though
12:38:43 <prsteele> dafis: as in 'f (3 % 4) == ...'?
12:39:02 <prsteele> dafis: =, not ==...
12:39:35 <dafis> prsteele: no, as in f 2.345 = ...
12:39:43 <Philonous> prsteele: No, (3 % 4) is an expression. 
12:40:06 <ddarius> @djinn ((a -> b -> b) -> b -> l a -> b) -> (l a -> Maybe (a, l a)) -> (a -> b -> b) -> b -> l a -> b
12:40:07 <lambdabot> f a b c d e =
12:40:07 <lambdabot>     case b e of
12:40:07 <lambdabot>     Nothing -> d
12:40:07 <lambdabot>     Just (f, g) -> a (\ _ h -> h) (c f d) g
12:40:29 <sphynx> ManateeL`: all these pretty long messages?
12:40:42 <ManateeL`> sphynx: yes.
12:41:26 <ManateeL`> sphynx: I won't let you test again, (waste too much time). Just want see error information, maybe i can fix it on Linux.
12:41:40 <ddarius> @djinn ((l a -> Maybe (a, l a)) -> (a -> b -> b) -> b -> l a -> b) -> (l a -> Maybe (a, l a)) -> (a -> b -> b) -> b -> l a -> b
12:41:40 <lambdabot> f a = a
12:41:43 <ski> @type \fs -> head . fix $ \as -> (`map` (fs `zip` [0..])) $ \(f,i) -> f $ (`map` (as `zip` [0..])) $ \(a,j) a' -> if i == j then a else a'
12:41:44 <lambdabot> forall b. [[b -> b] -> b] -> b
12:42:22 <ski> @let grzegorczyk0 fs = head . fix $ \as -> (`map` (fs `zip` [0..])) $ \(f,i) -> f $ (`map` (as `zip` [0..])) $ \(a,j) a' -> if i == j then a else a'
12:42:23 <lambdabot>  Defined.
12:43:28 <sphynx> ManateeL`: mm, sorry, I've already installed old pango, cairo, etc.
12:43:43 <sphynx> so now I am not able to reproduce that error again
12:43:43 <ManateeL`> sphynx: Never mind, i let Axel help me.
12:44:03 <yitz> ddarius, ski: just joined the channel. are you two feeling ok today?
12:44:54 <Philonous> prsteele: with -XViewPatterns you could do something like "unRatio x = (numerator x, denominator x)" and then "f(unRatio -> (x,y) ) = ..."
12:45:28 <int80_h> > <$>
12:45:29 <lambdabot>   <no location info>: parse error on input `<$>'
12:45:35 <ski> ddarius : hm .. it implemented something like `last' ?
12:45:38 <int80_h> @hoogle <$>
12:45:39 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:46:09 <yitz> int80_h: (<$>) = fmap
12:46:46 <ski> yitz : yeah, just (me) trying to get some grips on Grzegorczyk ..
12:47:11 <yitz> ski: gesundheit
12:47:20 <ski> indeed !
12:47:39 * ski is trying to come up with some interesting use of `grzegorczyk0'
12:48:00 * Phyx- wonders is ski is just typing random words
12:50:40 <ski> Phyx- : see the Grzegorczyk `[] ([] (A -> [] A) -> A) -> A' axiom under <http://en.wikipedia.org/wiki/Modal_companion#Modal_companions>
12:51:54 <ski> Phyx- : cf. with Lˆb's `[] ([] A -> A) -> [] A' theorem, at <http://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem>
12:52:10 * yitz started with http://en.wikipedia.org/wiki/Grzegorczyk_hierarchy
12:52:17 <int80_h> hi guys, I have the following problem with my Bare Bones Blog
12:52:21 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28167#a28167
12:53:10 <ski> @type let loeb :: Functor f => f (f a -> a) -> f a; loeb ff = fix $ \fa -> fmap (\f -> f fa) ff in loeb
12:53:11 <lambdabot> forall (f :: * -> *) a. (Functor f) => f (f a -> a) -> f a
12:53:20 <yitz> int80_h: IO String, not String IO, perhaps
12:53:21 <int80_h> hi ski :)
12:53:26 <int80_h> oooh!
12:53:42 <ski> that `loeb', is, sortof, a version of Loeb's Theorem
12:53:50 <ski> (it is an inconsistent version, though ..)
12:53:51 <IceDane> How does one do the identity for a list with a left fold? I can do it with a right fold, but I can't grok the left x.x
12:54:03 <ManateeL`> sphynx: On x86_64 we need -fPIC flags to compile hsgthread.c to make sure ghci can work correctly, but i don't know whether x86_32/Windows have same problem.
12:54:14 <ski> int80_h : lo, there
12:54:35 <ski> IceDane : you can't do it for any list, only finite ones
12:54:35 <sphynx> ManateeL`: me neither :)
12:54:42 <IceDane> ski: Yeah, I realize
12:54:49 <ski> @type foldr
12:54:49 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:54:50 <ski> @type foldl
12:54:50 <int80_h> ski: I'm making great progress. I feel if my household leaves me alone for a few hours I can get this dang thing presentable
12:54:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:54:59 <ManateeL`> sphynx: I have push new patch, Axel will help you test it on Windows.
12:55:12 <ski> IceDane : ponder the difference in typing of the first argument of `foldr' vs. `foldl'
12:55:25 <ManateeL`> sphynx: If it's new bug on Windows, Axel will investigate it.
12:55:36 <ski> (and maybe switch `a' and `b' in one of the type signatures, for greater clarity)
12:55:39 <solinent> Hi all, I am new to haskell and was wondering if there's a way to make a type synonym that has a different instance of show
12:56:12 <yitz> solinent: it would have to be a newtype
12:56:12 <solinent> so if the old type was int, it'd behave just like an Int except that when you tried to show it it would use my definition of show
12:56:42 <yitz> solinent: type synonyms are just textual name substitution
12:57:03 <solinent> So there's no way to do what I'm suggesting?
12:57:23 <solinent> I'm not reallly refering to a specific haskell thing when I say type synonym
12:58:17 <yitz> solinent: newtype does what you want, except that you would have to wrap and unwrap any use of that kind of "Int".
12:59:06 <yitz> solinent: another aproach is to define a function which is a different version of show.
12:59:07 <solinent> Yeah, I was trying to avoid the wrapping stuff
12:59:28 <solinent> I considered that but I thought haskell would have some neat thing that solved it for me
12:59:34 <solinent> I'll just do it that way, thanks!
13:00:39 <yitz> solinent: Haskell is intentionally pedantic about that kind of thing, in order to preserve the type system. that's what gives the type system its power. it's worth the extra bit of trouble occasionally.
13:01:18 * ManateeL` Maybe i need buy new CPU to install KVM ....
13:01:30 <IceDane> Alright, I'm really not getting how I can take a list, without reversing it or anything before hand, replicate the identity function with foldl
13:01:35 <IceDane> I can reverse the list
13:01:41 <IceDane> but I cannot do the identity :/
13:01:50 <IceDane> Anyone want to throw me a bone?
13:02:14 <yitz> > const id foldl [1,2,3]
13:02:15 <lambdabot>   [1,2,3]
13:02:46 <IceDane> I have no idea how that works
13:02:52 <IceDane> And is not possible with just the foldl?
13:03:11 <yitz> IceDane: it was a joke. it says, "ignore foldl and just use the identity function"
13:03:14 <sepp2k> IceDane: const id foldl  is the same as  id
13:03:25 <ski> int80_h : ok (took a short while finding your old pastes), `String IO' should probably be `IO String'
13:03:27 <IceDane> ah, duh
13:03:32 <garbagepillow> maybe something like foldl (\x y -> x ++ [y]) [] [1..10]
13:03:58 <IceDane> garbagepillow: Thank you very much
13:04:12 <garbagepillow> ehh, np
13:04:41 <ski> solinent : note that `Show' is really for displaying values as valid haskell expressions (which when evaluated will yield the original value)
13:05:00 <yitz> kind of like repr in Python
13:05:06 <ski> solinent : if you don't want that, i suggest using another function (maybe another type class)
13:05:22 <Kaidelong> what about "foldr (:) []"
13:05:22 <dafis> > foldl (\f x -> f . (x:)) id [1,2,3] []
13:05:23 <lambdabot>   [1,2,3]
13:05:48 <yitz> dafis: you used id
13:05:50 <Kaidelong> err
13:05:54 <Kaidelong> hmm
13:06:02 <Kaidelong> @src foldr
13:06:02 <lambdabot> foldr f z []     = z
13:06:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:06:13 <yitz> Kaidelong: yeah it's much more natural with foldr than with foldl
13:06:24 <ski> Kaidelong : .. using `foldl'
13:06:25 <IceDane> yeah
13:06:30 <Kaidelong> > foldr (:) [] [1..10]
13:06:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:06:34 <Kaidelong> hmm okay
13:06:52 <yitz> the foldr version even works with infinite lists
13:06:54 <dafis> yitz: which law forbids using id as the starting value in a foldl ?
13:07:13 <yitz> dafis: i think it's a homework assignment or something
13:07:58 <IceDane> Nah, not homework
13:08:02 <dafis> yitz: in that case, oops
13:08:03 <Kaidelong> well the only difference with foldl would be using append instead of cons, right?
13:08:04 <IceDane> I'm just rusty on them folds
13:08:11 <IceDane> I wish I was learning haskell in school
13:08:13 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28171#a28171
13:08:22 <Kaidelong> err
13:08:24 <ski> > foldr (\x c -> c . (x:) . c) id [3,2,1,0] []
13:08:25 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
13:08:25 <Kaidelong> well append and wrap
13:08:29 <yitz> IceDane: ok, self-inflicted homework
13:08:35 <int80_h> type mis-matching problem here. 
13:08:39 <IceDane> yitz: works for mee
13:08:40 <IceDane> -e
13:09:18 <Kaidelong> > let wrap x = [x] in foldl (++) [] . map wrap $ [1..10]
13:09:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:09:35 <dafis> int80_h: you have to use IO to get the contents
13:09:50 <dafis> int80_h: what sort of monad is Handler?
13:10:37 <ski> int80_h> :t templateContent
13:11:04 <int80_h> how do I get this to compile so I can check the type?
13:12:12 <ski> int80_h : comment out the code of `getEntryR' (maybe replacing the body with `undefined', if `getEntryR' is called anywhere) ?
13:12:20 <dafis> int80_h: has Handler a MonadIO instance ?
13:12:42 <ski> (one could also just selectively comment out the offending `string $ entryContent entry' sub-expression, replacing it with `undefined')
13:13:08 <dafis> or string "dummy"
13:13:46 * ski has no idea what argument type `string' has
13:13:58 <dafis> ski: String
13:14:14 <int80_h> Should I post the whole program? It's already on hpaste
13:14:31 <int80_h> oooh the old version is, I've made these changes that breaks the code now
13:14:55 <monoidal> given module name like Data.Binary, how to get package name (binary)?
13:15:05 <dafis> int80_h: where does Handler come from, has it a MonadIO instance ?
13:15:07 <monoidal> ghc-pkg seems to be missing that option
13:15:23 <lispy> how's it going?
13:15:44 <int80_h> dafis: I am working on compiling this so I can check types first. I will try to find the answer to that question in a minute
13:15:58 <dafis> monoidal: ghc-pkg find-module
13:16:30 <monoidal> dafis: thanks
13:16:37 <dafis> @hoogle Handler
13:16:37 <lambdabot> Control.Exception data Handler a
13:16:37 <lambdabot> Control.Exception Handler :: (e -> IO a) -> Handler a
13:16:37 <lambdabot> System.Console.Editline.Readline callbackHandlerInstall :: String -> (String -> IO ()) -> IO (IO ())
13:17:34 <dafis> no, not those
13:17:38 <int80_h> oh great, templateContent is not in scope
13:18:35 <dafis> int80_h: which package does Handler come from ? yesod, snap,... ?
13:18:50 <int80_h> dafis: Handler comes from Yesod
13:18:52 <ski> int80_h : which modules do you import ? .. `:m + TheModules ..'
13:19:04 <ski> (and then try again)
13:19:08 <int80_h> I'll post the whole program :)
13:19:26 <int80_h> I am going to remove the "undefined" line I just made
13:20:09 <dafis> int80_h: okay, MonadIO instance for GHandler [type Handler yesod = GHandler yesod yesod]
13:20:18 <ManateeL`> Bye all, night. :)
13:20:45 <dafis> int80_h: I'm going to revise your paste
13:21:24 <ski> dafis : so, you should be able to `liftIO (entryContent entry)' in the `do'-block then, i think
13:21:32 <ski> er
13:21:34 <ski> int80_h : ^
13:21:41 <dafis> ski: exactly
13:22:52 <dafis> int80_h: try http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28171#a28172
13:23:06 <ski> int80_h : a note, you don't really need to say `let foo = ...' and then directly `let bar = ...' in a `do'-block; the latter could just be `bar = ...' with `bar' aligned under `foo', just like with normal `let'
13:23:20 <McManiaC> case .. of Foo _s _t ->  -- what is that _s _t ? some kind of "named _"?
13:23:40 <hpc> a named _ would be s or t
13:23:48 <mheld> hey y'all
13:23:56 <mheld> I've asked this in a few other rooms, but anybody have any cool papers that I should read?
13:24:11 <McManiaC> hpc: so _s is just some variable name?
13:24:11 <dafis> McManiaC: an indication to the compiler that you don't want to use them, so it doesn't warn
13:24:20 <hpc> i think so
13:24:26 <hpc> or that
13:24:32 <monoidal> McManiaC: it's a normal pattern, just indication that it won't be used
13:24:34 <ski> McManiaC : (probably) ignored variables, but still giving some hint (given context) of what they denote
13:25:06 <askhader> I want to match the tuple that contains the number '1' as it's first element, and an arbitrary character as its second, what does this look like? Could? (1,a) work ?
13:25:07 <monoidal> but it can be used: f _x =  _x is legal
13:25:24 <hpc> askhader: yes, it should
13:25:25 <monoidal> askhader: yes, or (1,_) if you want to explicitly ignore
13:25:34 <askhader> Thanks
13:25:38 <askhader> Yeah, I don't want to ignore this time.
13:25:41 <hpc> > let f (1, a) = "yay" in (1, 2)
13:25:42 <lambdabot>   (1,2)
13:25:44 <ski> monoidal : yeah .. but maybe we ought to get a warning, then ? :)
13:25:47 <hpc> > let f (1, a) = "yay" in f (1, 2)
13:25:48 <lambdabot>   "yay"
13:25:52 <hpc> > let f (1, a) = "yay" in f (2, 2)
13:25:52 <lambdabot>   "*Exception: <interactive>:1:145-160: Non-exhaustive patterns in function f
13:26:10 <jystic> hi all, i'm trying to get cabal to compile my .hsc files but it seems to be ignoring them, can someone point me in the right direction?
13:26:26 <chrisdone> jystic: direction from where?
13:26:39 <hpc> ski: so when you have functions with oodles of parameters, and only some are used, you don't have to count the underscores to know that this parameter is the list, so the next is the string
13:26:48 <hpc> or something like that
13:26:59 <McManiaC> > let f = \ _s _t -> _s + 1 in f 5 2
13:27:00 <lambdabot>   6
13:27:06 <McManiaC> hmkay
13:27:14 <ski> hpc : yes, i know
13:27:25 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28171#a28176
13:27:28 <jystic> chrisdone: i've found some stuff online that suggests that cabal can automatically call hsc2hs for me, but i can't find out how to do it
13:27:33 <chrisdone> > let ({-fst-}_,snd) = (1,2) in snd
13:27:33 <lambdabot>   2
13:27:35 <monoidal> with -Wall, f x = 0 gives a warning, f _x = 0 and f _x = _x doesn't
13:27:58 <chrisdone> monoidal: _x doesn't give warnings if they are unused?
13:27:58 <int80_h> ski and dafis, there's the current code
13:28:08 <monoidal> chrisdone: yes
13:28:10 <McManiaC> thx all :)
13:28:22 <chrisdone> monoidal: nice! just what I've always wanted
13:28:22 <ClaudiusMaximus> jystic: add hsc2hs to build tools, add the module name (without extension) to the modules list - works for me...
13:28:35 <ski> int80_h : did the `enCont <- liftIO (entryContent entry)' resolve that type error ?
13:28:41 <dafis> int80_h: try the modification in #a28712
13:29:05 <ClaudiusMaximus> jystic: btw, "cabal init" did that automatically for me
13:29:22 <int80_h> dafis: gotcha, I just noticed it
13:29:34 <jystic> ClaudiusMaximus: i think build-tools might be the missing piece of the puzzle
13:29:38 <jystic> just going to try it
13:30:42 <int80_h> dafis: I see. Okay I am trying that. But if it works I will need to discuss why
13:30:48 <ski> (dafis : oh, i got confused .. i thought you made a new paste, and that the first annotation on int80_h's paste was his/her annotation, not yours)
13:31:00 <lispy> jystic: I think it calls it automatically when the file is one that cabal knows of
13:31:15 <chrisdone> I don't think special handling for .hsc is needed
13:32:05 <jystic> ok, it seems to have worked by adding 'build-tools: hsc2hs' and 'other-modules: My.Module.Name' to the cabal file
13:32:10 <ski> (strange of hpaste to allow direct linking to a paste annotation, with no specific mention that it indeed is an annotation of another paste)
13:32:13 <jystic> thanks guys
13:32:34 <jystic> chrisdone: do you think that there's a better way than this?
13:32:54 <chrisdone> http://stackoverflow.com/questions/1102730/haskell-cabalhsc2hs
13:33:20 <jystic> chrisdone: that's the post i found suggesting it should be possible
13:33:21 <chrisdone> jystic: in the Graphics.GD project, the filename is just Foo.hsc, Cabal handles it automatically
13:34:01 <jystic> hmm, i'm not sure why it won't handle it for me, got a link to the Graphics.GD source handy?
13:34:10 <chrisdone> @google graphics.gd hackage
13:34:11 <lambdabot> No Result Found.
13:34:16 <ski> int80_h : i see you have more `let foo = ...' directly followed by `let bar = ...' in `do'-blocks .. you can merge those as well
13:34:19 <chrisdone> waste of space, lambdabot
13:34:23 <jystic> haha
13:34:29 <jystic> it's ok i'll find it
13:34:35 <chrisdone> http://hackage.haskell.org/package/gd
13:35:09 <int80_h>     Ambiguous occurrence `liftIO'
13:35:09 <int80_h>     It could refer to either `Yesod.liftIO', imported from Yesod at blog.lhs:11:2-13
13:35:12 <int80_h>                           or `Control.Monad.Trans.liftIO', imported from Control.Monad.Trans at blog.lhs:13:2-27
13:35:25 <chrisdone> int80_h: this is why we write explicit import lists
13:35:26 <int80_h> dafis: which liftIO do you want me to use?
13:35:36 <int80_h> ah
13:35:43 <dafis> int80_h: try Yesod.liftIO first
13:36:17 <int80_h> chrisdone: I have learned more about the Haskell Way in the last week than I did the year prior
13:36:24 <int80_h> just by doing this exercise
13:36:38 <jystic> chrisdone: in the cabal file it explicitly lists 'exposed-modules' and 'other-modules', i think that's how cabal is picking it up. i don't seem to have to do that for regular haskell files
13:36:59 <int80_h> by making all these mistakes
13:37:15 <danderson> jystic: regular haskell files that are depended upon by exposed modules don't need to be explicitly specified
13:37:23 <chrisdone> my ability to click some things has disappeared. long sigh
13:37:47 <danderson> files which are processed to create haskell files (eg. hsc, chs) do, as do modules that aren't in the dependency graph for exposed modules (but then why are they in the package in the first place?)
13:37:47 <tommd> Data.Time doesn't seem to define/parse any three-letter time zone names.  Is there a pre-existing package that does this already?
13:37:59 <chrisdone> restarting xmonad did the trick
13:38:10 <jystic> danderson: cool, that makes sense
13:38:17 <int80_h> daris: we have compile!
13:38:25 <int80_h> dafis: I mean ^^^^
13:38:35 <ClaudiusMaximus> danderson: doesn't not including explicitly break "cabal sdist" ?
13:38:36 <ski> int80_h : also, no type ascription needed in `run application :: IO()' .. that was just part of my explaining, side-by-side, how to derive types for expressions
13:38:37 <dafis> int80_h: :D
13:38:43 <int80_h> okay I want to see my blog work, then discuss liftIO. I htink I know what it does and want to verify
13:38:45 <jystic> the 'build-tools: hsc2hs' seems to be redundant
13:38:48 <ClaudiusMaximus> danderson: or is cabal clever enough to know
13:38:49 <danderson> ClaudiusMaximus: ah, I don't know. Maybe.
13:39:06 <danderson> my current use of cabal is limited to configure/build/clean/install
13:39:17 <ski> dafis : presumably `Yesod' reexports `liftIO' ..
13:39:23 <chrisdone> jystic: in GD the exposed module is Graphics.GD, which is a .hsc file
13:39:30 <dafis> ski: yes, from transformers
13:39:40 <int80_h> ski: I would like to go over all your commentary. It's gotten lost in the scrolling. But first I need to see my blog work okay
13:39:44 <ski> (if that is the case, then /me thinks GHC ought not to complain about ambiguity, above)
13:39:50 <jystic> chrisdone: yeah, just using an exposed module is working for me, cheers
13:40:38 <int80_h> w00t!
13:40:49 <int80_h> I have a better blog!
13:41:00 <dafis> ski: why not? it must determine whether to throw an error (presumably GHandler a b is not an instance of mtl.MonadIO) or compile :)
13:41:03 <int80_h> okay so liftIO lifts the string into an IO action, right?
13:41:16 <chrisdone> better, or Better‚Ñ¢?
13:41:26 <ski> int80_h : btw, are you sure you need to import `Control.Monad.Trans' ? .. try removing it
13:41:43 <dafis> int80_h: no, liftIO lifts an IO-action to an action in a monad which has a MonadIO instance
13:41:48 <chrisdone> int80_h: liftIO lifts an IO action into the monad running ontop of it
13:42:07 <int80_h> chrisdone: ah, okay
13:42:09 * dafis rejoices, faster once
13:42:14 <ski> dafis : if it can determine the two actually are the same binding, only exported different ways, then it oughtn't complain about ambiguity, imho
13:42:33 <ski> (unless there's yet another `liftIO' in scope which isn't in reality the same binding)
13:42:37 <dafis> ski: methinks Control.Monad.Trans is from mtl
13:43:03 <monadic_kid> i've managed to get jhc - wii
13:43:16 <ski> dafis : and the `liftIO' in `Yesod' doesn't come from that, you mean ?
13:43:20 <wli> monadic_kid: What? 
13:43:26 <int80_h> ski: removing that allows a compile. I will make the changes permanent
13:43:33 <monadic_kid> with some works to the generated C code
13:43:37 <monadic_kid> *workarounds
13:43:38 <dafis> ski: that comes from Control.Monad.IO in transformers
13:44:03 <ski> int80_h : so, you could then rereplace `Yesod.liftIO' with `liftIO'
13:44:12 <monadic_kid> haskell hello world on the wii (homebrew)
13:44:16 <int80_h> ski: okay could you tell me what you had said earlier about let (and whatever else you mentioned). I was focusing on somethign else at the time, but now can pay attention.
13:44:18 <ski> dafis : ok (/me doesn't know `Yesod' at all)
13:44:29 <int80_h> ski: hah! I can indeed. okay.
13:44:42 <dafis> ski: nor do I, just looked at the sources on hackage
13:45:17 <ski> int80_h : don't forget to remove the extraneous type asciption, as well as merging adjacent `let'-commands in `do'-blocks
13:45:32 <int80_h> okay aside from my poorly styled let statements, I need to figure out how to incorporate css
13:45:40 <dafis> ski: import "transformers" Control.Monad.IO.Class (liftIO)
13:45:40 <ski> (.. well, do the latter if you think it's clearer .. ymmv)
13:46:24 <int80_h> ski: okay I am going to post the first set of lets in a doo block, please show me what merging them looks like
13:47:03 <dafis> int80_h: just remove all adjacent lets except the first and align the bindings
13:47:52 <int80_h> dafis: oh that was easy.okay
13:48:10 <ski> int80_h : the one case in which you shouldn't do this is in case later `let'-commands bind variables used in earlier ones ..
13:48:52 <dafis> int80_h: like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28171#a28177
13:48:53 <ski> int80_h : but, imo, it's better to mark this situation by not having merged `let's, and having them merged whenever else possible
13:49:13 <int80_h> gotcha
13:49:32 <int80_h> ski and daifs, okay that has been done
13:49:58 <ski> int80_h : extraneous type ascription removed, as well ? 
13:50:04 <int80_h> ski : yes :)
13:50:27 <int80_h> now, I must figure out how to get css working. my css needs are quite modest. But I have to have a little something
13:50:28 <McManiaC> aavogt: ping
13:50:37 <ski> btw, the branch `(entry:_) -> do ...' could be written as `entry:_ -> do ...'
13:51:56 <aavogt> McManiaC: hey
13:52:35 <McManiaC> ah nevermind
13:52:37 <McManiaC> sorry :D
13:52:58 * ski wonders what type `readFile' has on line 37
13:53:22 <ski> (oh .. right, `Entry' contains `IO'-actions)
13:53:36 <dafis> ski: readFile :: FilePath -> IO String, I think
13:53:43 <lambdor> what is the keyboard shortcut for "get last command" in GHCi?
13:53:45 <ski> yea
13:54:00 <dafis> lambdabot: up arrow
13:54:15 <dafis> lambdor: 
13:54:23 <ski> int80_h : maybe you'd want to actually read the files in `loadEntries', rather than in `getEntryR' ? (not sure, just asking)
13:54:25 <lambdor> i'm using EclipseFP, where it only moves the cursor up
13:54:46 <dafis> lambdor: oh, then I don't know
13:55:14 <prsteele> lambdor: ctrl+p ?
13:55:17 * ski wonders who calls `getEntryR'
13:55:29 <prsteele> lambdor: works in bash...
13:55:29 <lambdor> nope
13:56:29 <aavogt> you'd have to add those bindings to your ~/.ghci
13:56:44 <aavogt> no, ~/.haskeline
13:56:52 <aavogt> bind: ctrl-p up
13:56:54 <aavogt> bind: ctrl-n down
13:57:36 <aavogt> lambdor: but I don't know how eclipsefp integrates ghci
13:58:18 <ski> (int80_h : leaving for rest ..)
14:00:52 <dom96> Does anyone get this error when trying to install ghc in ubuntu 'ghc-pkg: /home/dominik/.ghc/i386-linux-6.12.1/package.conf.d/binary-shared-0.8-4f69b96682333c17a8bed7f0c8706a22.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)' ?
14:01:06 <prsteele> Is there an identify function, or should I just use \x -> x ?
14:01:11 <monoidal> id
14:01:21 <monoidal> > id 3
14:01:21 <lambdabot>   3
14:01:27 <prsteele> dom96: I installed ghc using apt-get about 2 weeks ago and was fine
14:01:41 <aavogt> > 0 3 :: Int
14:01:42 <lambdabot>   0
14:02:09 <lambdor> where can i find all valid bindings for GHCi?
14:03:14 <dom96> prsteele: This is what happens when i try it, http://pastebin.com/rNR1kKVL
14:03:18 <int80_h> ski: I diecided not to do that, because I would then end up with a list of Entry records with the entryContent field having potentially big strings. This way, as far as I can tell, the string is never stored permenently
14:04:29 <dafis> dom96: what's your locale ? is it utf-8?
14:06:01 <dom96> dafis: not sure
14:06:09 <monochrom> ubuntu uses a UTF-8 locale
14:06:13 <dafis> dom96: $ locale
14:06:18 <monoidal> try removing ~/.ghc
14:06:39 <dom96> yes, it is utf8
14:07:00 <monoidal> dom96: is it fresh install?
14:07:14 <stulli> I just built my first cabal file, but i get an error when building: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28181#a28181
14:07:14 <dom96> No
14:08:09 <ski> int80_h : yes .. also, this way, if `getEntryR' can called several times, if the files change in-between, the later calls will see the contents of the files at that point in time, not just the original contents, at the time of the call to `loadEntries'
14:08:44 <dafis> stulli: ghc-pkg field QuickCheck id
14:08:51 <ski> (int80_h : of course, maybe a call to the latter is always directly followed by a call to the former .. i don't know how `Yesod' works)
14:09:06 <dom96> monoidal: same thing happens when i remove ~/.ghc
14:09:14 <dafis> stulli: to see whether the correct QuickCheck is available
14:09:49 <ClaudiusMaximus> Saizan: thanks for the "share -vs- recompute" tips yesterday on my infinite lazy tree issue; the changes involved only 8 lines; heap profiles: http://claudiusmaximus.goto10.org/g/tech/mandulia-profile-1000s.png -vs- http://claudiusmaximus.goto10.org/g/tech/mandulia-profile-2010-07-24.png
14:10:47 <dafis> ClaudiusMaximus: looks much better
14:10:51 <ClaudiusMaximus> anyone have some code knocking around for smoothing the data that +RTS -h generates?  my hp2ps graphs are a mess of vertical lines :)
14:10:55 <Saizan> ClaudiusMaximus: heh, nice :) (after noticing the scale)
14:10:57 <ClaudiusMaximus> dafis: yes, yes it does
14:10:59 <monoidal> dom96: it seems it is a bug - http://hackage.haskell.org/trac/ghc/ticket/4158
14:11:02 <ClaudiusMaximus> Saizan: exactly..
14:11:11 <monoidal> dom96: maybe use haskell platform instead?
14:11:37 <dom96> monoidal: ok, i'll try that. Thanks
14:11:38 <dafis> ClaudiusMaximus: hp2ps -d ?
14:11:52 <ClaudiusMaximus> dafis: that just sorts, i meant temporal filtering
14:13:06 <stulli> dafis: I get two ids for quickcheck 1.2 and 2.1 and the latter has the same id as in my error message
14:13:53 <stulli> i added the build-depends part of my .cabal file to the hpaste if that helps
14:14:04 <dafis> stulli: ghc-pkg check, if it's not missing it seems to be unusable
14:15:00 <dafis> stulli: as a matter of principle, always give bounds on your dependencies
14:16:23 <stulli> ghc-pkg only lists an error with monads-tf which i unregistered previously
14:17:04 <dafis> stulli: cabal configure -v3 and paste the output
14:18:44 <Saizan> stulli: paste your whole "ghc-pkg list"
14:19:58 <dom96> monoidal: same problem with the haskell-platform
14:20:00 <McManiaC> aavogt: do see anything wrong here? http://npaste.de/du/
14:20:13 <int80_h> ski : I'm not sure how Yesod works either. I'm making alot of guesses.
14:20:47 <stulli> dafis, Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28181#a28183
14:21:18 <lambdor> how do you write a Show instance definition for "type Surface = ForeignPtr SurfaceStruct" and where SurfaceStruct is just "data SurfaceStruct"
14:21:20 <lambdor> ?
14:23:38 <Saizan> stulli: you've "directory-1.0.1.0" installed both in the global and the user package db, the current version of Cabal/cabal-install can't handle that situation so it gives bad instructions to ghc
14:23:50 <monoidal> dom96: is it 6.12.1 or 6.12.3?
14:23:54 <monadic_kid> lambdor: you can't really do it, empty data declaration is abit of trick for defining opaque types, the way the get functions work with Storage instance that peeks/pokes a pointer with byte offsets into the structure
14:24:22 <dafis_> stulli: that looks bad, ghc-6.12.1 depends on filepath-1.1.0.3 and on directory-1.0.1.0 which depends on filepath-1.1.0.4
14:24:24 <monadic_kid> lambdor: you can look at the source code in the haddocs to see what i mean
14:24:45 <dom96> monoidal:  6.12.1 
14:24:57 <dom96> perhaps i added the PPA incorrectly
14:25:21 <monoidal> dom96: try http://darcs.haskell.org/download/download_ghc_6_12_3.html#x86linux, or the 64-bit version
14:25:23 <monadic_kid> lambdor: last time I used sdl binding there was some access functions missing that I added in my self
14:25:33 <monadic_kid> *accessor
14:25:37 <monoidal> dom96: then, you can install the platform separately
14:25:53 <dom96> monoidal: ok, thanks.
14:26:02 <monoidal> the bug was fixed in 6.12.2 I believe
14:26:05 <lambdor> monadic_kid: i just need to output "SURFACE" or something, in order to print a list using surface, which will otherwise complain about no show instance being defined for Surface
14:26:06 <Saizan> stulli: that probably happened because you upgraded filepath to filepath-1.1.0.4
14:26:12 <aavogt> McManiaC: -XScopedTypeVariables
14:26:21 <Saizan> stulli: you should probably start by getting rid of that version
14:26:45 <McManiaC> aavogt: oooh awesome
14:26:46 <McManiaC> thx
14:27:05 <monadic_kid> i'm not sure if you can define a class instance with empty data declarations?
14:27:10 <Saizan> stulli: or, you could try my experimental patches for Cabal/cabal-install :)
14:27:13 <monoidal> monadic_kid: yes
14:27:19 <aavogt> McManiaC: and when you write  deriveQA, it's probably better to use   'reify   rather than   mkName "reify"
14:27:27 <McManiaC> ok
14:27:30 <lambdor> monadic_kid: instance Show Surface where show = "Surface", or something like that
14:27:37 <monoidal> monadic_kid: class A. you don't need "where" then, it's optional
14:27:46 <aavogt> in that case, the correct reify will be used if the correct one was in scope where you define deriveQA
14:28:00 <McManiaC> yeh
14:28:19 <McManiaC> I have to remember that TH just generates some code and I still have to import everything to make it work... :)
14:28:41 <ClaudiusMaximus> lambdor: -XTypeSynonymInstances and/or -XFlexibleInstances might help?
14:28:48 <stulli> Saizan: Thanks, i really don't want to install experimental features of a program i don't understand at all :) Any hints on how to get rid of a specific version of a package?
14:29:25 <stulli> just unregister?
14:29:43 <monadic_kid> I've managed (with a bit of tweaking) to get the output from JHC to build with devkitPPC, and got a hello world running on the Wii
14:29:44 <aavogt> monadic_kid: sure you can... it's just that the result of   show  won't meaningfully depend on the argument
14:29:56 <Saizan> stulli: yes
14:30:13 <ski> McManiaC : also `((a1,a2))' can be simplified to `(a1,a2)'
14:30:16 <lambdor> aavogt: i wouldn't need an argument
14:30:28 <McManiaC> ski: how?
14:30:37 <aavogt>  instance Show Surface where show _ = "Surface"
14:31:11 <ski> McManiaC : just by replacing the former with the latter ?
14:31:20 <lambdor> avvogt: just something to make "putStrLn $ show myListOfSurface" work
14:31:24 <McManiaC> ski: ehm, thats code generated by template haskell
14:31:27 <lambdor> avvogt: Illegal instance declaration for `Show Surface'
14:31:28 <monadic_kid> but Surface is a type alias for a foreign ptr, it's SurfaceStruct that is the opaue type
14:31:57 <dafis> stulli: I got disconnected, have you made progress?
14:32:02 <monadic_kid> SurfaceStruct is the one with the empty data declaration
14:32:19 <aavogt> lambdor: so you need some of the extensions ClaudiusMaximus mentioned
14:32:20 <monadic_kid> type Surface = ForeignPtr SurfaceStruct
14:32:40 <Saizan> dafis: we found that stulli has 2 installations of the same version of directory, so Cabal goes mad
14:32:44 <ski> McManiaC : .. oh
14:33:02 <stulli> dafis, Saizan: Thanks, i unregistered filepath and it gave me the same error with directory. I unregistered directory and everything works now, cabal build succeeded!
14:33:05 <McManiaC> ski: ;)
14:33:13 * ski thought it was part of code that would be fed through TH
14:33:18 <dafis> stulli: great
14:33:19 <lambdor> aavogt, ClaudiusMaximus: will have a look at it
14:33:39 <McManiaC> ski: that's why I put the ghci-prompt above
14:33:50 <lambdor> aavogt: is there any way maybe to print every type that has no instance for Show to print a default character like _
14:34:07 <ski> McManiaC : you should have commented out the answer, too :)
14:34:23 <ClaudiusMaximus> lambdor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28185#a28185
14:34:37 * aavogt is annoyed when the proof of concept type hackery works, but something is different when I actually apply it
14:34:47 <McManiaC> ski: ok ;) next time
14:36:14 <ski> lambdor : (assuming you `newtype' `Surface'), the Right Thing to do, assuming `Surface' is immutable, would be to access the fields of `SurfaceStruct' through the FFI, and generate a string representing a call to a function that would allocate an equal `Surface'
14:36:55 <dom96> monoidal: That worked, thanks again.
14:37:19 <monoidal> dom96: now, does "cabal" command work?
14:37:23 <ski> > listArray (0,4) [i^2 | i <- range (0,4)]  -- somewhat similar to this, for the abstract `Array' type
14:37:24 <lambdabot>   array (0,4) [(0,0),(1,1),(2,4),(3,9),(4,16)]
14:37:50 <dom96> monoidal: haven't installed the haskell-platform yet
14:38:56 <monoidal> dom96: it's on http://hackage.haskell.org/platform/2010.2.0.0/cabal/haskell-platform-2010.2.0.0.tar.gz
14:39:21 <monoidal> "cabal install" should work
14:41:07 <lambdor> ClaudiusMaximus: thx. I get "No instance for (Show (IO Surface))" though... which I don't understand because with the instance of Surface, IO Surface should also work?
14:41:44 <aavogt> specifically I'm having trouble here: http://npaste.de/dv/  (see comments in the first file)
14:42:11 <dafis> lambdor: IO a has never a Show instance
14:42:26 <ClaudiusMaximus> > print
14:42:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.IOBase.IO ())
14:42:27 <lambdabot>    arising ...
14:42:56 <monoidal> you can fmap show to get IO String
14:43:01 <lambdor> ski: I don't understand. I only would need ANY working instance of show Surface anyway... so I can see what the list output of my function really is
14:43:02 <sepp2k> dafis: instance Show (IO a) where show x = "<IO>" -- :p
14:43:10 <ClaudiusMaximus> > return :: Int -> IO Int
14:43:10 <lambdabot>   Overlapping instances for GHC.Show.Show
14:43:10 <lambdabot>                              (GHC.T...
14:43:27 <dafis> sepp2k: yes, you can define it, but it's not provided
14:43:36 <ClaudiusMaximus> oh well, lambdabot has a Show instance for IO, but it's wrong and should be stopped
14:44:00 <dafis> > return 2 :: IO Int
14:44:01 <lambdabot>   <IO Int>
14:44:19 <dafis> @botsnack
14:44:20 <lambdabot> :)
14:44:46 <ClaudiusMaximus> > let f = negate :: Int -> Int in show f
14:44:47 <lambdabot>   Overlapping instances for GHC.Show.Show
14:44:47 <lambdabot>                              (GHC.T...
14:44:54 <dom96> monoidal: well, cabal works, but i got this 'haskell-platform-2010.2.0.0 depends on stm-2.1.2.1 which failed to install.'
14:45:30 <monoidal> dom96: there should be information above
14:45:41 <monoidal> I don't have any idea how to fix that though.
14:45:55 <prsteele> I know that I can pattern match against constructors in the arguments of a function, but how would I do it in the body of a function? Would I need to create helper functions to do the matching?
14:46:07 <ClaudiusMaximus> prsteele: 'case'
14:46:30 <Saizan> > case Just 1 of Nothing -> "nothing"; Just x -> show x
14:46:31 <lambdabot>   "1"
14:46:46 <dom96> monoidal: ehh, maybe i don't need the haskell platform.
14:47:16 <monoidal> dom96: if you do ghc-pkg list, is "stm" package on the list?
14:47:47 <monoidal> dom96: if yes, then I think you don't need to worry that much
14:48:10 <prsteele> ClaudiusMaximus: thanks
14:48:35 <Phyx-> @Hackage Cabal
14:48:35 <lambdabot> http://hackage.haskell.org/package/Cabal
14:48:41 <lambdor> dafis, ClaudiusMaximus, Ski, Monadic_kid, aavogt: thx for your help!
14:48:45 <Phyx-> @url Cabal Src
14:48:45 <lambdabot> http://www.haskell.org/cabal
14:48:51 <Phyx-> laaamee
14:48:55 <lambdor> using now: instance Show (IO Surface) where     show _ = "_"
14:49:11 <Saizan> Phyx-: darcs get http://darcs.haskell.org/cabal
14:49:12 <dom96> monoidal: it's not there :(
14:49:31 <Phyx-> Saizan: ty :)
14:49:33 <lambdor> with FlexibleInstances
14:49:58 <dafis> dom96: try cabal install -v stm
14:49:59 <monoidal> dom96: could you paste (using hpaste.org) the output when you try to install the platform?
14:50:07 <Phyx-> out of curiosity, does cabal provide an API like hook for building etc?
14:50:13 <Saizan> dom96: that version of stm works only with the latest ghc i believe, you want 2.1.2.2 instead
14:50:33 <monoidal> dom96: oh, sorry
14:50:43 <dom96> who shall i listen to lol?
14:50:54 <dom96> What is stm ?
14:51:02 * Phyx- thinks he needs to look at the cabal-install src aswell
14:51:04 <chrisdone> software transactional memory
14:51:16 <dom96> oh
14:51:32 <dom96> Should i just do what dafis suggests ?
14:51:40 <Saizan> dom96: i guess you could just not care about the platform and pull packages with cabal-install as you need them
14:52:04 <monoidal> dom96: do what dafis said, and paste the output
14:52:05 <dafis> dom96: I agree with Saizan
14:52:29 <monoidal> you won't need stm unless you'll write parallel or concurrent programs
14:52:48 <dom96> oh, ok then
14:53:54 <Saizan> Phyx-: cabal-install has a SetupWrapper module to deal with Setup's commands
14:53:54 <dom96> I think doing cabal install -v stm worked
14:54:20 <Saizan> yeah, that pulled in the most recent version :)
14:54:37 <Phyx-> Saizan: oh sweet, that'll save me alot of time
14:54:54 <Phyx-> now I just need to find commands to read and write values in a .cabal file
14:55:17 <dom96> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28187#a28187
14:55:20 <dom96> That's the output
14:55:33 <monoidal> yes, it is correct
14:55:54 <Saizan> Phyx-: except that currently cabal-install doesn't expose a library :)
14:56:17 <dafis> dom96: so now you're the proud owner of a brand-new stm :)
14:56:26 <Phyx-> Saizan: that's ok, any function I mark my tool will fully create marshalling code for, doesn't need to be a library
14:56:28 <McManiaC>     Warning: orphan instance:
14:56:30 <dom96> heh, yes i am :)
14:56:32 <McManiaC> what does that warning mean?
14:56:42 <Phyx-> it'll just most likely compile the whole of cabal-install in :P
14:56:50 <dom96> dafis: now i can resume reading haskell :)
14:56:53 <dafis> McManiaC: an instance not in the same module as the class or the type
14:56:58 <dom96> Thanks a lot for the help everyone.
14:57:55 * Phyx- records a new video
14:58:23 <dom96> *reading real world haskell
14:58:52 <McManiaC> dafis: k
14:58:57 <prsteele> Is there a way to pass patterns as arguments?
14:59:05 <Saizan> no
14:59:36 <Saizan> you can pass functions of type A -> Maybe B tough
15:01:17 <ddarius> @google first class patterns
15:01:18 <lambdabot> No Result Found.
15:01:44 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.7006
15:01:47 <listofoptions> that would be term rewriting ddarius
15:02:47 <listofoptions> ddarius, http://www.google.com/search?aq=0&oq=term+re&sourceid=chrome&ie=UTF-8&q=term+rewriting
15:02:58 <ddarius> listofoptions: I know what term rewriting is.
15:03:04 <listofoptions> oh okies
15:03:06 <ddarius> listofoptions: You may want to look at the pattern calculus.
15:03:08 <listofoptions> mybad
15:03:17 <Saizan> who knew you could write a paper out of this..
15:03:18 <listofoptions> rho-calc?
15:03:31 <ddarius> @google "pattern calculus"
15:03:31 <lambdabot> No Result Found.
15:03:39 * ddarius should fix the 'bot.
15:03:53 <ddarius> @google bondi
15:03:55 <lambdabot> http://bondi.omtp.org/
15:04:14 <ddarius> Hmm, not what I wanted.
15:04:33 <ddarius> http://www-staff.it.uts.edu.au/~cbj/patterns/
15:04:46 <prsteele> ddarius: Looks promising, but I can't find a link to the document itself that isn't broken
15:05:44 <ddarius> prsteele: Just click on the little PDF (or PS) icon under cached on the page I linked.
15:06:07 <Phyx-> hmmm are you guys busy? If not, I would appreciate some comments on this video (2mins long) namely the UI and what you would like to see changed http://screencast.com/t/ZTBhMmUxNz
15:06:14 <Phyx-> pardon the background noise... i'm in alot of wind
15:06:22 <McManiaC> aavogt: http://npaste.de/dw/ :)
15:06:58 <ddarius> listofoptions: Incidentally, term rewriting doesn't really correspond to "first class patterns."  Term rewriting systems rarely allow rules to create new rules, though you can encode that to some extent.
15:07:21 <prsteele> ddarius: turns out the issue was firefox, chrome worked; thanks
15:08:21 <listofoptions> ddarius, thanks i honestly thought that's what you meant ;p
15:09:27 <dafis> Phyx-: horrible sound, nice GUI, but it should be Inferred type, double-r
15:09:55 <Phyx-> dafis: yeah, It's hot! the fan is directly in the mic :P
15:10:10 <Phyx-> yeah, let me changed that
15:10:32 <monadic_kid> ddarius: I managed to hack around those problems i had with jhc to get Haskell program running on the Wii.
15:11:04 <Phyx-> dafis: ok, fixed, anything else?
15:11:44 <dafis> Phyx-: nothing obvious, but then, I'm an obstinate kate-user :)
15:12:01 <Phyx-> :)
15:12:08 <Saizan> the background music is intentional?:)
15:12:22 <Phyx-> that's the tv I suppose, or do you mean the roosters? :P
15:13:25 <Saizan> probably the tv :)
15:13:51 <Saizan> are you using scion or the ghc-api directly?
15:13:58 <Saizan> or a mix? 
15:14:00 <Phyx-> using the ghc-api directly
15:14:00 <ClaudiusMaximus> hm, i think i'm leaking memory in  modifyMVar_  , is there a strict version?
15:15:54 <Phyx-> Saizan: I suppose I should eventually switch to scion and just extend it with what I need, but the approach nominolo uses differs alot from what I use now
15:15:54 <chrisdone> I thought it was strict
15:16:23 <ClaudiusMaximus> chrisdone: hm
15:16:31 <Saizan> Phyx-: do you have a command to show the types of the variables in the lexical scope? that's quite handy in Agda, combined with what's essentially a way to tell the inferred type of the undefined you place in your code
15:16:57 <ClaudiusMaximus> chrisdone: 'm logging timing statistics to a Map String Stat stored in an MVar, but currently i'm doing nothing with the results, i guess an easy way to check would be to force it periodically by printing it
15:17:03 <aavogt> McManiaC: so it works now?
15:17:09 <McManiaC> jup
15:17:25 <Phyx-> Saizan: you can just hover over any word and it'll show you what it knows about it, including the type and where it's defined and hoogle documentation, I didn't show that in the video because I haven't quite figured out yet how to obtain all that information from GHC
15:17:59 <Saizan> Phyx-: if it doesn't make sense to integrate it with scion it would still be nice to have the non-VS-specific parts as a library
15:18:18 <chrisdone> ClaudiusMaximus: maybe force evaluation of the map?
15:18:27 <Saizan> Phyx-: ah ok :)
15:18:59 <Phyx-> Saizan: I already do, any interaction with GHC is done via a compiled DLL, which is compiled via normal haskell files. So any program can use them. I also provide the C types
15:19:20 <ClaudiusMaximus> chrisdone: yep, going to try that now, and if it fixes it then woohoo
15:19:22 <Saizan> Phyx-: cool :)
15:19:54 <AJohnson_> hi everybody, i have a problem with a program I wrote trying to use HTTP library: it says me it doesn't find the library, but I just installed it with Cabal
15:20:10 <Phyx-> Saizan: currently though, marshalling speed is an issue, I've been trying to track down the bottle neck, but I can't get my ghc to compile with profiling.
15:20:15 <AJohnson_> where have I to put the files?
15:20:23 <chrisdone> AJohnson_: in GHCi?
15:20:29 <Saizan> Phyx-: i found http://github.com/sebastiaanvisser/ghc-goals in the past that does the thing i mentioned about undefined, maybe you'll find some idea
15:20:37 <Phyx-> Saizan: because I'm using marshalling and some internal types of ghc are abstract, I'm forced to modify ghc
15:20:38 <AJohnson_> no i'm usin runhaskell
15:20:50 * Phyx- looks
15:21:07 <dafis> AJohnson_: have you more than one version of GHC?
15:21:08 <chrisdone> AJohnson_: where is the error regarding the library?
15:21:20 <Saizan> AJohnson_: "ghc-pkg list HTTP" ?
15:21:30 <AJohnson_> no.. I have only last version
15:22:35 <AJohnson_> :Saizan ghc-pkg reports 2 files: one in var/lib/ghc... and the other in my home
15:23:01 <Saizan> AJohnson_: but no line saying something like "HTTP-4000.x.y" ?
15:23:17 <AJohnson_> yes.. HTTP 4000.0.0.9
15:23:29 <Saizan> ok, so it's installed
15:23:31 <Phyx-> Saizan: ah, yeah, It'll do that, Say you have a function foo and you don't yet know the type, you can just do foo = undefined and once it typechecks put your cursor over foo and it'll say display the type. I currently do not allow types other than top-level functions to be displayed inline in text in the ide or be inserted, because I figured it would become to busy, but I could make a smart action that does it
15:23:51 <Saizan> AJohnson_: can you paste the exact error you get from runhaskell ?
15:23:58 <AJohnson_> :Saizan sure
15:24:58 <AJohnson_> Saizan: prova3.hs:1:7:     Could not find module `HTTP':       Use -v to see a list of the files searched for.
15:25:20 <chrisdone> Network.HTTP?
15:25:35 <Saizan> AJohnson_: ah, you can't "import HTTP", since HTTP is only the name of the package
15:26:18 <Saizan> AJohnson_: you want to import Network.HTTP, or one of the other modules listed here http://hackage.haskell.org/package/HTTP under Modules with a link to their doc
15:26:28 <AJohnson_> Saizan: I just swapped it in import Network.HTTP
15:26:35 <AJohnson_> Saizan: and it does
15:26:44 <AJohnson_> Saizan: Thanks :)
15:27:11 <Saizan> Phyx-: well, i'm not a windows user anyhow, but it's a quite cool feature when the types get more complicated :)
15:27:39 <Saizan> Phyx-: and patching GHC to make it more usable in an IDE sounds like a good deed to me :)
15:28:32 <Saizan> AJohnson_: np
15:30:20 <Phyx-> Saizan: Yeah, i figured the majority of people here aren't :). But I think those who are have mostlikely used visual studio and would like Haskell in it if possible. Also even though it uses visual studio you will still be able to get it for free
15:30:28 <Phyx-> licensing changes ftw!
15:32:44 <ClaudiusMaximus> chrisdone: yes, printing the contents of the MVar each frame makes that part run in constant space instead of linear space...  though i've still got a leak elsewhere..
15:33:04 <chrisdone> @hoogle ($!)
15:33:04 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
15:33:28 <chrisdone> it's dangerous to go alone, use this!
15:34:16 <Phyx-> anyone else have anything they would like to see regarding the UI of http://screencast.com/t/ZTBhMmUxNz ? small changes I can incorporate rigth away, bigger ones I'll add to the queue
15:34:41 <Phyx-> I'll have to go soon
15:35:15 <hpc> does it sort imports?
15:35:51 <Phyx-> ah yes, I just don't have the command for that ready :)
15:35:58 <Phyx-> i'm terrible at making keyboard shortcuts
15:35:59 <Phyx-> hehehe
15:36:34 <hpc> i was thinking automatically
15:36:40 <Saizan> even better, does it autoimport?
15:36:53 <hpc> autoimport would be trickier
15:36:58 <hpc> due to namespace collisions
15:37:09 <Phyx-> hpc: ah, hmm, that would be an option, I could make that a setting
15:37:16 <Saizan> well, you can present a menu with alternatives
15:37:23 <Saizan> like eclipse does
15:37:25 <Phyx-> Saizan: I *should* be able to do that, aslong as the package is specified in your cabal file
15:37:26 <chrisdone> Saizan: one cheeky way to get the type of a local value in
15:37:26 <chrisdone> foo :: Integer -> Bool
15:37:26 <chrisdone> foo n = f n where f = ...
15:37:28 <hpc> a global "import qualified as" might work though
15:37:29 <chrisdone> could be to transform to:
15:37:32 <chrisdone> foo' :: typeof_f -> Integer -> Bool
15:37:35 <chrisdone> foo' typeof_f n = typeof_f n where f = ...
15:37:39 <chrisdone> and then observe the type error, or if there is none, assume 'a'
15:37:46 <hpc> you could say, add Data.Map as Map
15:37:57 <Phyx-> Saizan: as it uses the cabal file as guidance, to trim the lookup space, especially for intellisense
15:38:00 <hpc> then when you type Map.fromList, it will detect it and add the import
15:38:45 <hpc> also, a "condense imports" thing, which would remove unused imports and make existing imports only include functions currently being used
15:38:45 <Saizan> Phyx-: i see, another way would be to have a more-or-less user provided hoogle index or similar
15:38:50 <Phyx-> hpc: I don't know of you've ever use VS before, but i'm thinking of doing it inline with how it does it, if you type Map.fromList you'll get a type error not in scope, but also a smart action, so you can insert the import with one additional click
15:39:10 <hpc> ive used visual c++
15:39:14 <hpc> it kinda sucks
15:39:28 <Phyx-> lol, i meant in one of the .NET languages
15:39:29 <chrisdone> hpc: we covered that
15:39:40 <Phyx-> the IDE behaves differently in them
15:39:53 <hpc> ah, i was afk
15:40:04 <Phyx-> Saizan: That's kinda what I do, I modify cabal to write out a sort of intellisense cache everytime you install a package
15:40:11 <hpc> but yeah, smart actions sounds better
15:40:46 <chrisdone> Saizan: I do have my import short-cut now. importTAB gives an ido-mode completion of all installed modules
15:41:15 <Phyx-> Saizan: I also need that to write out visual studio compatible help files for every module, fo that F1 is useful
15:41:23 <hpc> some sort of intellisense for type specialization would be cool
15:41:37 <Phyx-> hpc: hmm, how do you mean?
15:41:43 <Cale> What an odd design decision. This web application for browsing TV listings internally represents the date and time to list from in milliseconds.
15:42:02 <hpc> er, nvm, you have type inference, which would let you specialize on your own
15:42:29 <hpc> like ($) = (id :: (a -> b) -> a -> b)
15:42:38 <hpc> except not one line
15:43:31 <Phyx-> hmm,
15:43:53 <hpc> a way to make a function pointless might be nice
15:43:55 <Phyx-> I've been thinking of having the IDE correct your errors aswell
15:44:28 <Phyx-> hpc: ah well, I want to support the full of HaRe, don't know if it suppports that
15:44:40 <Phyx-> i could call pointfree i suppose
15:45:17 <hpc> hmm, for error correction you could have it take a list of all functions in scope and filter by type
15:45:21 <hpc> then sort by nearest spelling
15:45:26 <Saizan> sounds dangerous for the haskell community to have @pl in such an easy to use position :)
15:45:35 <hpc> haha
15:45:35 <chrisdone> man I'm going to bed, my head's exploding. if I have a stroke in my sleep, my final words will be: blargh i am ded
15:45:58 <ClaudiusMaximus> aaargh i'm being bitten by the "modifyIORef isn't strict" bug.. http://claudiusmaximus.goto10.org/g/tech/mandulia-profile-2010-07-24b.png (the dark blue wedge...)
15:46:11 <Saizan> chrisdone: 'night
15:46:14 <Phyx-> hpc: well, i was thinking in terms of, if yout module doens't typecheck with a type mismatch error, i'll silently remove your explicit type, retry, if it succeeds, i'll suggest that type to you, much like the "inferred type" in the screenshot
15:46:21 <Phyx-> Saizan: lol
15:46:47 <Saizan> ClaudiusMaximus: use $!, quick!
15:46:47 <hpc> :t modifyIORef
15:46:48 <lambdabot> Not in scope: `modifyIORef'
15:46:57 <jmcarthur> ClaudiusMaximus: hehe
15:47:00 <jmcarthur> easy to fix at least
15:47:13 <jmcarthur> :t Data.IORef.modifyIORef
15:47:14 <lambdabot> forall a. GHC.IOBase.IORef a -> (a -> a) -> IO ()
15:47:15 <hpc> going strict -> lazy is more annoying
15:47:36 <Saizan> well, here you've to rewrite modifyIORef from scratch
15:47:37 <dafis> ClaudiusMaximus: readIORef ref >>= \val -> (writeIORef ref $! modify val) ?
15:47:49 <Phyx-> hpc: what you meantioned, is what I plan on doing for intellisense :)
15:48:05 <jmcarthur> at least it's not atomicModifyIORef
15:48:16 <Phyx-> I originally wanted to have a version out this month, but think i'm gonna miss that, it's alot more work than i expected :/
15:48:25 <Saizan> that can be made strict from the outside, iirc
15:48:30 <jmcarthur> really?
15:48:41 <hpc> what language is the ide plugin in?
15:48:44 <Phyx-> hmm, crap, I forgot to lookup how to bowl....
15:48:47 <Phyx-> hpc: C#
15:48:50 <Saizan> ?type Data.IORef.atomicallyModifyIORef
15:48:51 <lambdabot> Not in scope: `Data.IORef.atomicallyModifyIORef'
15:48:55 <Saizan> ?type Data.IORef.atomicModifyIORef
15:48:56 <lambdabot> forall a b. GHC.IOBase.IORef a -> (a -> (a, b)) -> IO b
15:48:59 <hpc> eugh, so much for me offering to help ;)
15:49:16 <Phyx-> hpc: more maintainable than If I were to write it in C++ since the COM interfaces are almost deprecated
15:49:17 <Saizan> jmcarthur: the resulting tuple gets pattern matched, so yes
15:49:34 <jmcarthur> oh i guess if forcing the tuple forces the first element of it then it works
15:49:38 <Saizan> jmcarthur: or you can use the 'b' part anyway
15:50:04 <ClaudiusMaximus> dafis: right, i'll try that
15:50:15 <ClaudiusMaximus> Saizan: unless you know of a reason why that won't work either?
15:50:42 <Saizan> ClaudiusMaximus: no, dafis' code is the standard solution :)
15:51:18 <dafis> ClaudiusMaximus: what sort of data is in the IORef? whnf might not be enough
15:51:47 <jmcarthur> i wonder if this problem might be a sign that you might want to look at something like foldM or something
15:52:13 <jmcarthur> not necessarily, but sometimes
15:52:15 <hpc> :t foldM
15:52:16 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:52:46 <jmcarthur> the idea being that if you are using the IORef to accumulate something maybe you just want to abstract that out
15:53:02 <ClaudiusMaximus> dafis: it's a record, so if that still doesn't work i'll make the fields strict
15:53:02 <jmcarthur> but i guess if you're using an IORef then the control flow is already too complicated for that
15:54:36 <dibblego> @pl \f -> first f . second f
15:54:37 <lambdabot> liftM2 (.) first second
15:55:11 <hpc> :t first
15:55:12 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:55:24 <Phyx-> bye bye
15:55:38 <hpc> :t \f -> f &&& f
15:55:39 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
15:57:15 <hpc> :t liftM2 (.) first second
15:57:16 <lambdabot> forall c d. (d -> c) -> (d, d) -> (c, c)
16:02:58 * hackagebot CSPM-Frontend 0.4.1.0 - A CSP-M parser compatible with FDR-2.83  http://hackage.haskell.org/package/CSPM-Frontend-0.4.1.0 (MarcFontaine)
16:03:29 <prsteele> anyone know a good testing framework for Haskell applications?
16:05:35 <Saizan> QuickCheck or HUnit, test-framework integraters both iirc
16:06:12 <prsteele> Saizan: thanks
16:06:44 <ClaudiusMaximus> woohoo constant space usage finally >> http://claudiusmaximus.goto10.org/g/tech/mandulia-profile-2010-07-24c.png
16:07:12 <ClaudiusMaximus> Saizan++ # advising on sharing vs recomputation
16:07:26 <ClaudiusMaximus> dafis++ # advising on strict modifyIORef
16:08:00 <dafis> ClaudiusMaximus: yappa-dappa-doo
16:08:14 <Saizan> cool :)
16:08:41 <dafis> @karma Saizan
16:08:41 <lambdabot> Saizan has a karma of 12
16:08:49 <dafis> re-spect
16:10:20 <aavogt> @karma dafis
16:10:20 <lambdabot> dafis has a karma of 2
16:11:16 <prsteele> Oh, neat; I guess this is owed, then
16:11:21 <prsteele> Saizan++
16:12:43 <aristid>  @karma lambdabot
16:12:43 <Saizan> so much karma :O
16:12:50 <dafis> Saizan: are you triskadekaphobious?
16:12:58 <aristid> @karma lambdabot
16:12:59 <lambdabot> lambdabot has a karma of 2
16:13:06 <aristid> lambdabot--
16:13:12 <aristid> @karma lambdabot
16:13:12 <lambdabot> lambdabot has a karma of 1
16:13:34 <Saizan> dafis: cool word, but no :)
16:15:44 <askhader> Is there such a thing as type conversion  in haskell?
16:15:53 <askhader> What is the easiest way to get a number into a string?
16:15:59 <kmc> > show 3.0
16:16:00 <lambdabot>   "3.0"
16:16:09 <dafis> askhader: not as such, but there are plenty of conversion functions
16:16:19 <dafis> askhader: read
16:16:23 <askhader> ah okay
16:16:24 <kmc> askhader, when people ask "how do I convert A to B" they are asking "what is some function of type A -> B"
16:16:31 <askhader> kmc: agreed.
16:16:31 <dafis> > read "12" :: Integer
16:16:32 <lambdabot>   12
16:16:47 <aristid> > read "12" :: CReal
16:16:48 <lambdabot>   12.0
16:16:57 <dafis> > read "12" :: Rational
16:16:58 <kmc> Haskell doesn't have an opinion on which function of type A -> B is "the" conversion
16:16:58 <lambdabot>   *Exception: Prelude.read: no parse
16:17:09 <askhader> That's not quite what I want aristid 
16:17:16 <aristid> > show (12 :: Rational)
16:17:16 <lambdabot>   "12 % 1"
16:17:16 <askhader> I want the other way, a number to a string
16:17:20 <askhader> Ahhh
16:17:22 <kmc> > show 7.5
16:17:22 <askhader> Brilliant
16:17:23 <lambdabot>   "7.5"
16:17:30 <dafis> > read "12.0" :: Rational
16:17:31 <lambdabot>   *Exception: Prelude.read: no parse
16:17:33 <aavogt> @hoogle Int -> String
16:17:33 <lambdabot> Prelude show :: Show a => a -> String
16:17:33 <lambdabot> Text.Show show :: Show a => a -> String
16:17:33 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
16:17:37 <aristid> > read "12 % 1" :: Rational
16:17:38 <lambdabot>   12 % 1
16:17:43 <aristid> dafis: :P
16:17:52 <aavogt> askhader: hoogle is a great tool for problems like these
16:18:31 * dafis wonders about Rational's Read instance
16:19:11 <dafis> > read "12" :: Double
16:19:14 <lambdabot>   12.0
16:19:23 <Saizan> it fits as an inverse of the Show one, but it's in fact weird.
16:20:16 <dafis> Saizan: yes, every other standard Num type reads integer literals, methinks
16:20:33 <dafis> > read "12" :: Complex Double
16:20:34 <lambdabot>   *Exception: Prelude.read: no parse
16:20:45 <dafis> 'kay, not that
16:21:02 <aristid> > show (12 :: Complex Double)
16:21:02 <lambdabot>   "12.0 :+ 0.0"
16:21:20 <dafis> > read "12 :+ 0" :: Complex Double
16:21:21 <lambdabot>   12.0 :+ 0.0
16:21:28 <ddarius> I like this paragraph from CTM: The structure view.  In this view, inheritance is just another programming tool that is used to structure programs.  This view is /strongly discouraged/ because classes no longer satisfy the substitution property.  The structure view is an almost unending source of bugs and bad designs.  Major commercial projects, which shall here remain anonymous, have failed for this reason.  A few object-oriented languages, notably Eiffe
16:21:28 <ddarius> l, are designed from the start to allow both the type and structure views.
16:21:29 <aristid> dafis: i think the read instances are probably kept deliberately simple
16:22:05 <aristid> ddarius: "substitution property"?
16:22:11 <aristid> ddarius: a quote out of context..
16:23:06 <dafis> > read "12e3" :: Double
16:23:08 <lambdabot>   12000.0
16:23:31 <Philonous> aristid: http://en.wikipedia.org/wiki/Liskov_substitution_principle
16:23:33 <dancor> > read "12E3" :: Double
16:23:33 <lambdabot>   12000.0
16:23:37 <dancor> > read "12x3" :: Double
16:23:38 <lambdabot>   *Exception: Prelude.read: no parse
16:23:38 <askhader> Does anyone understand why this simple code refuses to compile? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28197#a28197 
16:24:03 <askhader> added conslist to it
16:24:40 <dafis> askhader: for two putStrLns, you need a do
16:24:46 <askhader> right you are
16:24:46 <askhader> THanks
16:24:55 <aristid> Philonous++
16:24:57 <Saizan> ddarius: "structure view" is another name for "structural subtyping"?
16:25:15 <dafis> askhader: but better, remove the 'in' and align the putStrLns with the let
16:25:19 <wli> Eiffel was pretty strange.
16:26:21 <askhader> dafis: the 'in' is optional?
16:26:39 <kmc> there is a variant form of "let" for use within "do"
16:26:48 <dafis> askhader: in do-blocks
16:26:50 <kmc> where you omit "in" and instead it scopes over the rest of the do block
16:27:13 <dafis> askhader: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28197#a28199
16:27:13 * wli actually has Bertrand Meyer's Eiffel book somewhere.
16:27:17 <kmc> in other words, "let ... in ..." is an expression, but "let ..." is a statement
16:28:12 <ddarius> There is no preceding (or succeding) definition/description of the "structure view," though it is pretty clearly -not- refering to structural subtyping.  That paragraph is all the description that is given.
16:29:58 <ddarius> The preceding paragraph on the type view (which is basically, subclasses are subtypes) gives a brief definition of the "substitution property" which is more or less the Liskov one.
16:32:27 <Saizan> hah, so it's like "if you use inheritance only because it fits your code reuse needs you're doomed to fail" :)
16:33:30 <HugoDaniel2> hi
16:33:40 <HugoDaniel2> where can i read about C code generation from haskell ?
16:36:02 <msieradzki> stuff about circle-ellipse tends to be from C++ POV and not really talking about how to solve the problem :)
16:36:06 <msieradzki> maybe I missed soemthign
16:45:16 <aavogt> is there some way to encode in fundeps, if a = A types depend in this manner, otherwise it's something else?
16:46:50 <aavogt> it's actually more specific:  class Mode action field e x y | action field e x -> y, action field x y -> e where
16:47:08 <aavogt> but for some field, there can be only one `e'
16:47:19 <aavogt> so I guess ~ could work here
16:47:31 <aavogt> (in the specific instances)
16:47:53 <aavogt> hmm, but the unsafeCoerce??
16:48:06 <Saizan> which unsafeCoerce?
16:48:39 <aavogt> so that I can leave 'e' polymorphic (constrained later by the type equality), and still be allowed to implement my methods
16:49:22 <Saizan> put the type equality in the instance context and you'll need no unsafeCoerce
16:49:33 <aavogt> oh, that's nice :)
16:50:49 <olsner> hmm, in the state transformer you have s -> m (a,s), but in the applicative transformer I'm trying to build I'm having real trouble finding an implementation where m is merely an applicative functor ...
16:51:12 <olsner> for now, I chose (s -> (f a, s)) as the internal type of my applicative functor, but I wonder if there's something I'm losing by moving f inside the (_,s)
16:52:06 <aavogt> Saizan: there's no ~ in TH though?
16:52:23 <olsner> specifically, I seem to need join or >>= to implement <*> for the (s -> f (a,s)) version
16:53:24 <Saizan> for any two applicative functors f and g, their composition is also an applivative functor, which is what (s -> (f a, s)) is, though the effects are not interleaved like with monad transformers
16:53:28 * aavogt found EqualP
16:54:10 * Saizan too
16:54:24 <dolio> olsner: I'm pretty sure we decided a week or two ago that StateT s f is not applicative when f is merely applicative.
16:56:05 <beutdeuce> what languages can pandoc syntax highlight if compiled with -fhighlighting ?
16:56:41 <olsner> Saizan: right, applicative is closed under composition, I'm not making proper use of that I think... maybe I should actually rather be looking for a StateF s a, just using it with a = (f b) for some applicative functor f?
16:56:55 <aavogt> beutdeuce: it uses the same highlighing as the editor kate I think
16:57:39 <beutdeuce> aavogt: is it possible to add a syntax highlighter for a language that it doesn't include?
16:57:49 <dolio> olsner: (f <*> x) s = f s `op` x, where op :: f (a -> b, s) -> (s -> f (a, s)) -> f (b, s), which looks suspiciously like bind's type.
16:58:11 <aavogt> beutdeuce: no idea. There are probably quite a few ways to accomplish that
16:59:03 <olsner> dolio: hmm, about the "StateT s f is not applicative": I think there's at least one interpretation of stateful applicative that makes sense... what I'm going for is something where x <*> y does x's state transformations before y's
16:59:46 <aavogt> Saizan: using EqualP doesn't make ghc explicit about those other 'e's being wrong
17:00:08 <dolio> olsner: You mean, run x with state s, giving state s', then run y with state s'?
17:00:15 <aavogt> would there be something better than the standard overlapping instance with unsatisfiable head?
17:00:22 <olsner> dolio: indeed
17:00:23 <aavogt> (ex. a Fail class)
17:00:32 <olsner> (run x with state s, giving state s
17:00:47 <dolio> olsner: That has the problem I mentioned above with op that has a type like (>>=).
17:01:16 <olsner> (I didn't complete that sentence, but I don't think I had anything to add there, in hindsight)
17:01:47 <olsner> indeed... so is it impossible? and do I lose something by moving the functor inside the pair?
17:01:58 <Saizan> aavogt: true, it'll just say that it doesn't match the given type, without referring to the class..
17:02:13 <dolio> olsner: I don't have a proof that it's impossible. But I strongly suspect it is.
17:02:30 <dolio> And, the composition is different, but I don't really know in what ways, as I've not used it.
17:02:52 <olsner> it does seem like the (s -> (f a, s)) implementation allows a sensible implementation and "probably" has the expected semantics I want from the state applicative
17:03:25 <aavogt> Saizan: ghc accepts contexts like: Mode Modify Field Char a b, while Field should only be good with say Int
17:03:28 <olsner> I should probably try extending that version of the applicative to a monad and make it work the same as State or StateT
17:03:47 <dolio> If you see edwardk, you could ask him, because he was who this conversation was with last time.
17:04:01 <olsner> @seem edwardl
17:04:01 <lambdabot> Unknown command, try @list
17:04:03 <dolio> And he decided on s -> (f a, s), I think.
17:04:04 <olsner> @seem edwardk
17:04:04 <lambdabot> Unknown command, try @list
17:04:16 <Saizan> aavogt: really? have you tried without TH in the middle?
17:04:24 <aavogt> I can't add that fundep to Mode because there are some cases where that's not the case
17:05:27 <olsner> dolio: ok, that makes me at most as wrong as edwardk then :)
17:06:06 <olsner> but it's still interesting to see if that makes it different from what the monad transformer can do
17:06:24 <aavogt> Saizan: ddump-splices: http://npaste.de/dz/Haskell
17:08:36 <aavogt> the behavior is as expected
17:08:52 <Saizan> aavogt: i guess i see what you mean, with fundeps it more eagerly rejects unsatisfiable constraints
17:09:22 <Saizan> because with the ~ trick you could actually make another instance for Mode Modify Field Char a b with OverlappingInstance
17:10:41 <cads> Hey I've got to write an integrator for some discrete nonlinear dynamics. Really it's just a function f :: Int -> [Vector] -> [Vector], representing integration of the system by a certain integral number of steps. But actually it's a complicated scheme creating a sequence x_n of vector lists, where for any x_j, you need the preceding 4 x_k's to calculate.
17:11:11 <cads> Heh, I just got the funny idea that I could probably write this all as a recursive list comprehension
17:13:01 <ddarius> zip4 vs (tail vs) (tail (tail vs)) (tail (tail (tail vs)))
17:13:34 <cads> seq = [f a | a <- zip4 seq (tail seq) (drop 2 seq) (drop 3 seq)]
17:13:54 <cads> that's pretty elegant, but would that be efficient?
17:14:20 <ddarius> cads: About as efficient as you are going to get with lists.
17:14:49 <ddarius> I'd also recommend not shadowing seq.
17:15:21 <cads> ah, that was my other question.. should I just use a really high rank vector as my state?
17:15:56 <dafis> cads: and you need the first few values, as above, it will loop
17:16:25 <cads> true enough :)
17:17:01 <cads> I wonder how complicated the logic is for predictor corrector schemes
17:17:19 <cads> for that I'd probably want to use something more heavy duty, anyways
17:17:40 <cads> I was thinking that the best place to do something like this might be in some state monad or so
17:18:10 <dafis> list = let (a:b:c:d:_) = tails list in v1:v2:v3:v4:[f a | a <- zip4 a b c d]
17:18:11 <dibblego> is there a Data.Map.insertWithKeyM?
17:18:30 <dolio> olsner: I don't think the composition is a monad, even if f is a monad.
17:18:35 <dafis> dibblego: nope
17:18:46 <aavogt> @type M.insertWithKey
17:18:47 <lambdabot> forall k a. (Ord k) => (k -> a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
17:18:51 <cads> but the vector library I'm using seems to be mostly for pure vectors
17:18:52 <dafis> dibblego: what for?
17:19:04 <dibblego> so I don't have to write it I suppose
17:19:25 <dibblego> (Ord k) => (k -> a -> a -> m a) -> k -> a -> M.Map k a -> m (M.Map k a)
17:21:57 <olsner> dolio: hmm? monads aren't closed under composition afaik (assuming I would've heard about such a thing), but the State monad exists regardless
17:22:12 <olsner> (and I would assume that a "good" implementation of a state applicative would be one that ends up equivalent to State with a "natural" Monad instance)
17:22:41 <dolio> olsner: State is a monad regardless, but 'State o f' is not.
17:23:12 <ddarius> @google monad distributive law
17:23:13 <lambdabot> http://en.wikipedia.org/wiki/Distributive_law_between_monads
17:23:13 <lambdabot> Title: Distributive law between monads - Wikipedia, the free encyclopedia
17:24:18 <olsner> yeah, but I'm thinking more like ... if I write instance Monad f => Monad (StateF s f) where [...], would that StateF monad have the same semantics as State?
17:24:40 <dolio> StateF s f a = s -> (f a, s)?
17:24:48 <Krimpet> Hello folks, I'm trying to install a package with cabal (xmonad-extras), but I'm getting the error "cabal: cannot configure hint-0.3.2.3. It requires ghc >6.6". I have ghc 6.12.1, though. Any idea what could be going wrong?
17:24:48 <olsner> yep
17:24:59 * aavogt is surprised I didn't have -XOverlappingInstances there already
17:25:00 <dolio> olsner: Then I mean that StateF s f is not a monad for arbitrary monads f.
17:25:22 <olsner> "is not" or "can't be"? or is that the same thing?
17:25:32 <dolio> You cannot write the instance.
17:25:46 <dolio> At least, a sensible one.
17:26:00 <dafis> dibblego: you have to write it yourself, but if it must be performant, you need to roll your own module
17:26:04 <olsner> mmkay, that sucks since it seems to be the opposite way for applicative
17:26:10 <Saizan> Krimpet: it's talking about the "ghc" library
17:26:29 <dolio> StateT s f is applicative when f is a monad. Just not when it's merely applicative.
17:26:33 <Saizan> Krimpet: if you got your ghc via a distro repository maybe the library is in a separate package
17:26:48 <Saizan> Krimpet: you can check if you have it installed with "ghc-pkg list ghc"
17:27:23 <aavogt> it's only a constant factor you pay by writing it in terms of multiple lookups
17:27:32 <olsner> oh, not even applicative when f is applicative?
17:27:50 <olsner> oh wait, StateT != StateF
17:27:51 <dolio> No. That's where this conversation started. :)
17:28:00 <Krimpet> Saizan, hmm, looks like I don't have it installed.
17:28:22 <dafis> aavogt: a constant factor of 15 is baad if it must be performant
17:28:41 <aavogt> Saizan: seems to work like this: http://npaste.de/e0/Haskell
17:29:00 <olsner> so StateT requires monad to implement applicative, and StateF only requires applicative but in effect can't be a monad?
17:29:06 <aavogt> dafis: it would only be 2 or 3x worse here, no?
17:29:10 <Krimpet> Oh, I see. Fedora has a "ghc-ghc" package, maybe that's it.
17:29:23 <dolio> olsner: At least, not without additional assumptions on f.
17:29:37 <aavogt> hmm, there's a mistake in those instances :(
17:29:39 <dafis> aavogt: depends on the size of the map, I'd think
17:29:56 <dafis> and 2x or 3x may be bad too
17:30:06 <dolio> olsner: If you have 'f (a, s) -> (f a, s)', then you can write the monad instance, I think.
17:30:56 <dafis> aavogt: thinko, but still 2x may or may not be sufficient
17:31:07 <Saizan> aavogt: ah, k, let me know if you later find weird side-effects :)
17:42:09 <tommd> why is there no instance Read DiffTime?
17:43:15 <olsner> but what happens if you change the monad transformer to use (s -> (m a, s))? does that mean it can't implement the current behaviour?
17:45:00 <hpc> @unmtl Writer e a
17:45:00 <lambdabot> (a, e)
17:45:07 <hpc> @unmtl Reader e a
17:45:07 <lambdabot> e -> a
17:45:57 <olsner> @unmtl State s a
17:45:57 <lambdabot> s -> (a, s)
17:46:31 <hpc> yeah, just getting a hang of how they piece together
17:46:45 <olsner> hmm, unmtl doesn't specify where the monad constructor goes
17:46:47 <ddarius> @unmtl ReaderT s (Writer s) a
17:46:47 <lambdabot> s -> (a, s)
17:47:12 <olsner> @unmtl StateT s m a
17:47:12 <lambdabot> s -> m (a, s)
17:47:16 <hpc> i remember there being another standard monad that can be unmtl'd
17:47:21 <aavogt> does somebody know of a paper describing how to quickcheck (or similar) for values with side effects?
17:47:22 <hpc> that isn't a transformer
17:47:29 <hpc> @unmtl Error e a
17:47:30 <lambdabot> Error e a
17:47:30 <ddarius> @unmtl Cont r a
17:47:30 <lambdabot> (a -> r) -> r
17:47:33 <hpc> oh yes
17:48:27 <aavogt> it's QC2 that lets you say some things about which monadic actions commute and don't interfere with eachother?
17:49:12 <ddarius> aavogt: There are a few papers.  Probably the best thing to do is to make a model data structure for some representative actions so that you can generate random values of it and then interpret them as monadic actions.
17:51:01 <Krimpet> Hmm, now "cabal install xmonad-extras" is giving me an error about libmpd: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28209#a28209
17:51:55 <aavogt> Krimpet: I think if you darcs get  the repo on code.haskell.org, it has been fixed
17:52:11 <Krimpet> Ah, thanks aavogt, I'll try that.
17:52:26 <ddarius> aavogt: I recommend the techniques used here: http://www.cse.chalmers.se/~wouter/repos/IOSpec/index.html
17:59:12 <solinent> I'm trying to find the MS1B (most significant 1 bit) as well as the LS1B (least significant 1 bit) in haskell.
17:59:21 <solinent> So basically bsr / bsf
17:59:28 <solinent> which are intructions in x86
17:59:37 <dibblego> dafis, I'd write it myself but the Map constructors are not exported
17:59:40 <solinent> so is there something that can allow me to use these instructions?
18:00:07 <ddarius> solinent: Nothing that would be particularly worthwhile/sane.
18:01:17 <ddarius> You could, for example, make a small C function that uses inline assembly or something but the overhead of the foreign call would probably defeat the purpose.
18:02:31 <dafis> dibblego: insertLookupWithKey fun key val map = case Map.lookup key map of { Nothing -> return (Map.insert key val map); Just old -> do { new <- fun key val old; return (Map.insert key new map) } }
18:03:01 <hpc> does anyone see any obvious problems with transforming Control.Parallel.Eval with StateT? will i lose parallelism?
18:03:14 <dafis> dibblego: if that's too slow, you need to steal the sources
18:03:37 <dibblego> dafis, right, I'll have to do something like that and deal with the performance, cheers
18:07:21 <solinent> ddarious: Alright, thanks.  I'm still interested in implementing in it C, do you have any reference on why a foreign call would be so slow?
18:08:19 <solinent> ddarious: I'm not THAT worried about speed though, this is just a learning project. What I make should be decently fast though.  I guess I'll try to do it using Data.Bits.
18:08:20 <davean> dibblego: can't you just use standard math to do that?
18:08:24 <davean> dibblego: like ~x & (x+1)?
18:08:31 * hackagebot texmath 0.3.0.2 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.3.0.2 (JohnMacFarlane)
18:08:37 <davean> er, solinent 
18:08:47 <davean> both of you
18:09:33 <solinent> davean: I had no idea, would that be the MS1B or the LS1B?
18:09:53 <solinent> davean: most things I see online are really complicated C functions using constant array lookups and such
18:09:54 <dafis> solinent: neither ~1 & 2 = 2
18:10:05 <davean> x | (x-1) isolates the right most 1 bit
18:10:07 <davean> its basic logic
18:10:14 <solinent> oh, right of course
18:11:06 <davean> erg, I keep getting them wrong
18:11:13 <davean> but you get the point (sorry, I don't really do this any more)
18:11:19 <solinent> yup, thanks
18:11:32 <davean> x & (-x)
18:11:36 <davean> I tihnk they are called bit hacks
18:11:49 <solinent> This doesn't really help me as much though, as I need the position
18:11:50 <davean> if you don't want to work them out yourself
18:12:03 <solinent> I guess I could just make a constant lookup table for the position
18:12:04 <davean> well, isolating it *gives* you the poossition
18:12:14 <solinent> gives you the position^2
18:12:17 <davean> and, you can convert it to a number with a little more math
18:13:20 <davean> I mean, how large are these?
18:14:05 <davean> jsut seems easier then dealing with foriegn functions, etc
18:15:57 <solinent> this is all just bitboard for chess, so they're all Word64s
18:16:31 <Cads> solinent: you're coding a chess?
18:16:46 <solinent> Cads: yup, an AI, as I'm trying to learn haskell
18:16:53 <Cads> cool
18:17:05 <lucca> keep it simple and concrete.
18:17:44 <Cads> KISAC.
18:18:01 <solinent> yeah, so far I have all the code for generating the piece's moves (minus the pawn, castling and all of that stuff), and so far haskell has really proved to be quite wonderful
18:18:40 <davean> it sounds like you are trying to copy how it was done somewhere else to me then
18:19:00 <solinent> yup, I'm just re-implementing it for the sake of learning haskell
18:19:05 <stulli> Hm, how do i install the "profiling libraries" for a package (i need them for download-curl)?
18:19:12 <solinent> chessprogramming.com is a great reference
18:21:36 <aavogt> stulli: cabal install -p
18:21:49 <BMeph> Mmm... Bit Twiddling Hacks! :)
18:22:24 <dafis> stulli: set documentation: True in your ~/.cabal/config
18:22:35 <aavogt> cabal install doesn't automate rebuilding all dependencies though... so it may be quickest to remove everything, then install your download-curl with -p
18:22:41 <dafis> then you needn't worry in future
18:22:55 <aavogt> dafis: profiling isn't documentation :P
18:23:25 <dafis> aavogt: yes, I mean library-profiling, of course, it's late
18:24:08 <dafis> however, documentation: True is useful too
18:24:53 <stulli> aavogt, dafis: That was easy, thanks. Slowly i get along with all these Haskell tools
18:25:31 <aavogt> dafis: saddly there's no option of getting pretty sources linked to those docs there
18:25:48 <dafis> aavogt: indeed
18:26:12 * dafis hacks Cabal on every new GHC to get it :)
18:31:39 <stulli> aavogt: I hunted the dependencies manually. Fortunately it wasn't that much work.
18:31:43 <ddarius> > let x = 0xC800 in showHex (x .&. complement (x - 1)) ""
18:31:44 <lambdabot>   "800"
18:32:49 <hpc> :t (.&.)
18:32:50 <lambdabot>     Ambiguous occurrence `.&.'
18:32:50 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
18:32:50 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
18:33:07 <hpc> :t (Data.Bits..&.)
18:33:08 <lambdabot> forall a. (Bits a) => a -> a -> a
18:33:44 <benmachine> :t (Test.QuickCheck..&.)
18:33:45 <lambdabot> forall prop1 prop2. (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
18:34:11 <dibblego> @pl Œªps ‚Üí liftM join (mapM f ps)
18:34:11 <lambdabot> (line 1, column 2):
18:34:11 <lambdabot> unexpected "\187"
18:34:11 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
18:34:22 <dibblego> @pl \ps -> liftM join (mapM f ps)
18:34:22 <lambdabot> fmap join . mapM f
19:00:42 <danderson> is there some way to shut up specific ghc warnings for a single file through pragmas?
19:01:01 <lispy> danderson: yes
19:01:11 <danderson> doh, just found the docs.
19:01:21 <danderson> as usual, 5 seconds after asking, the answer shows up
19:01:21 <lispy> danderson: IIRC, put {#- GHC_OPTIONS -fno-warn-blah #-} at the top of the file
19:01:43 <lispy> {-#, actually
19:01:49 <danderson> lispy: right, cheers.
19:29:03 <Colours> hello is there a package somewhere for converting base 10 into base 16 numbers?
19:29:51 <ClaudiusMaximus> @hoogle showIntAtBase
19:29:52 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
19:30:05 <dolio> @hoogle showHex
19:30:05 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
19:30:22 <Colours> oh excellent thanks :3
19:30:41 <BMeph> Colours: "Yes." ;)
19:31:42 <Colours> hm I can't imagine why it needs that string argument at the end when all it does is concatenate it to the result
19:31:49 <Colours> but awesome all the same :3
19:31:58 <dolio> It's for more efficient printing.
19:32:13 <dolio> Repeatedly appending to the end of something is bad.
19:32:21 <Colours> oh I see
19:32:27 <dolio> So instead you write functions that prepend to strings, and compose them.
19:37:33 <Colours> cool thanks :3
19:38:57 <dibblego> what properties of a monad is required to allow (A ‚Üí m B) ‚Üí  m (A ‚Üí  B) ?
19:40:22 <ddarius> The existence of a distributive law for the Reader monad.  (Or rather, that is exactly what that function would be.
19:40:54 <dolio> I don't think that's very common.
19:41:59 <dibblego> I had a 'm' buried in a monad transformer stack but I took it out thinking I could move it to the outside, but now I cannot
19:42:29 <ddarius> Which m is it?
19:42:31 <dibblego> I can think of a few values for m where that function is possible, but not the general case
19:42:34 <dibblego> IO
19:42:44 <ddarius> Oh, then you're fucked.
19:43:06 <dibblego> it was forall m. it's when it comes to implementations that it is IO
19:43:21 <dolio> m being reader itself is the only one that comes to mind.
19:43:28 <dibblego> Identity
19:43:35 <dolio> Ah, yes, of course.
19:43:44 <Cads> hey ddarius, are the temperatures of various points in a heat conductive body a linear system?
19:44:05 <dibblego> ddarius, by fucked do you mean I might put forall m. back in to the stack?
19:44:11 <ddarius> dibblego: Consider \n -> replicateM n (print "Hello") :: Int -> IO ().  You can't make that into IO (Int -> ()). 
19:44:49 <dibblego> ddarius, right, this problem wasn't so clear to me at the time when I decided for/against it
19:48:06 <dibblego> I suppose the (A ‚Üí) needs to be Traversable, and this specific case is not
19:48:47 <ddarius> Cads: The heat equation is a parabolic second order partial differential equation.
19:50:08 <ddarius> Data.Traversable.sequence == distributive law
19:50:29 <dibblego> yes thanks for the tip
19:51:32 <Cads> ddarius: does that mean that the heat of discrete points in the volume will be determined by solutions to linear systems of second order linear differential equations?
19:53:00 <Cads> Can you automatically 'project' the partial differential solution down onto the discrete suspace as a set of linear equations, or do you have to compute the whole body?
19:56:32 <ddarius> Cads: You can apply something like the finite element method to the partial differential equation to approximate it.
19:56:45 <ddarius> Admittedly, FEM is for approximating the solution over the whole surface.
19:57:32 <aavogt> ghci infers types that it can't accept
19:57:56 <ddarius> Occassionally.
19:59:19 <ddarius> Cads: Depending on your problem, moving to the frequency domain might simplify things.
20:01:29 <interferon> suppose i have the following:  "result <- (,) <$> Just 4 <*> Just 5; case result of ..."
20:01:53 <interferon> can i write this without binding the value of the expression to a dummy value?
20:02:05 <interferon> assuming i'm inside the IO monad
20:02:10 <dolio> What do the cases do?
20:02:35 <interferon> you know what, let me post the actual code :)
20:02:39 <Cale> interferon: No, you can't write that in the IO monad at all.
20:02:42 <cncl> what's everyone's favorite unix argument handling library
20:02:45 <Cale> interferon: Because it's clearly in Maybe
20:02:50 <kmc> :t (,) <$> Just 4 <*> Just 5
20:02:51 <lambdabot> forall a a1. (Num a, Num a1) => Maybe (a, a1)
20:02:55 <interferon> Cale: right
20:02:58 <cncl> getopt kind of annoyed me when i tried it, it felt like i had to do more by hand than i really needed to
20:03:08 <interferon> i was trying to simplify my actual example and i failed miserably
20:03:14 <kmc> interferon, maybe you want ¬´let result = (,) <$> Just 4 <*> Just 5¬ª
20:03:20 <kmc> within an IO "do"-block
20:03:25 <FunctorSalad_> cncl: hehe that was my first impression too
20:03:26 <Cale> interferon: You can write things analogous to that in the IO monad, such as  (u,v) <- (,) <$> getLine <$> getLine
20:03:27 <interferon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28211#a28211
20:03:34 <Cale> er, <*> for the second one, of course
20:04:03 <Cale> interferon: If you don't bind the result, why bother? :)
20:04:06 <interferon> so i'm getting a Maybe value inside the Snap monad
20:04:16 <FunctorSalad_> maybe one could just parse them into a Map Opt OptArg
20:04:29 <interferon> Cale: i don't understand
20:04:33 <Cale> interferon: The code you have is what I'd use.
20:04:43 <Cads> hey ddarius, I want to define a NxN matrix Dij where Dij = -Dji. Can I get this matrix by only computing Dij, for 1 <= j <= i <= n and incurring a negation cost whenever Dij, j > i were accesed?
20:04:53 <FunctorSalad_> though that'd amount to heterogenous maps if you want different types in the arg
20:05:02 <interferon> apologize for trying to pare down my code and wasting everyone's time :)
20:05:05 <Cads> hmm, I could easily implement that as a function
20:05:22 <Cale> interferon: I think I see what you want. There's no way to eliminate the name 'result' here
20:05:47 <dolio> Is Snap a MonadPlus?
20:05:53 <interferon> Cale: yep, that's what i'm asking
20:05:55 <interferon> dolio: yes
20:05:56 <FunctorSalad_> Cads: probably no cost at all since you'll just fuse the minus into whatever you do with the components
20:05:58 <interferon> Cale: thank
20:06:20 <Cale> interferon: However, some people have suggested that the syntax   (case of ...)  expand to  (\x -> case x of ...)  where x is a fresh variable.
20:06:58 <msieradzki> "'cpp' is not recognized as an internal or external command," what does that mean?
20:07:04 <FunctorSalad_> btw you only need the strict upper diagonal even, since Dii=-Dii implies Dii=0...... (characteristic 2 nonwithstanding :p)
20:07:05 <Cale> interferon: If we had that syntactic extension, you'd be able to write  ((,) <$> getParam "echoparam" <*> getParam "shmarm") >>= case of ...
20:07:12 <dolio> echoHandler = (do (Just parm, Just p2) <- (,) ... ; writeBS $ BS.append parm p2) `mplus` writeBS "must specify ..."
20:07:21 <cncl> cmdargs looks good
20:07:26 <interferon> Cale: oooh that would be nice
20:07:39 <msieradzki> cabal writes that after line like "preprocessing cairo" and there's cpphs.exe in cabal directory, why would it look for cpp(.exe)?
20:08:08 * hackagebot mandulia 0.5 - A zooming visualisation of the Mandelbrot Set as many Julia Sets.  http://hackage.haskell.org/package/mandulia-0.5 (ClaudeHeilandAllen)
20:09:58 <dolio> interferon: The one caveat with mplus is that it will probably catch errors other than the pattern match, though.
20:10:07 <dolio> Also it's not really less ugly.
20:10:17 <FunctorSalad_> (I don't know how current CPUs work, but a negation should have ignorable cost anyway; it's just a single bit flip for IEEE floating point numbers)
20:10:42 <interferon> Cale: thanks for the help
20:10:57 <FunctorSalad_> (and flip-all-the-bits for integers... for two-complement)
20:12:26 <dolio> Negation is presumably a single machine op for machine integers.
20:12:56 <dolio> And for GMP integers, it's probably a bit flip like the IEEE case.
20:13:24 <FunctorSalad_> and a cheaper one than addition even, AIUI
20:13:46 <FunctorSalad_> (since addition has dependencies of higher digits on lower digits)
20:15:46 <dolio> I also don't really know modern CPUs, but it'd be a little surprising to me if they didn't have hard-wired logic to make addition as efficient as negation.
20:18:20 <dolio> Twos complement negation is flip all bits and add one, too.
20:18:34 <FunctorSalad_> (however this may be, you probably won't have to do unary negation anyway, it'll just be a subtraction instead of addition somewhere)
20:18:59 <FunctorSalad_> right, I knew I'd confuse the two :(
20:19:25 <FunctorSalad_> (I mean in the antisymmetric-matrices case)
20:20:10 <FunctorSalad_> you just partially evaluate your algorithm by hand, taking into account the Dij = -Dji
20:21:22 <FunctorSalad_> or 'skew-symmetric' was it I think...
20:22:53 <ddarius> Cads: You may want to look at the papers behind repa (and there are many older papers with similar approaches...)
20:23:03 <ddarius> (e.g. some of the work of Timothy Budd.)
20:43:33 <wagang> hello
20:45:10 <wagang> anyone ?
20:46:41 <kmc> hi
20:46:53 <wagang> hello kmc
20:47:38 <wagang> I have a question on the terminator of haskell
20:47:38 * ddarius wonders if any Forth interpreters store the words in reverse, set esp to the beginning of a sequence of words defining a word, and simply use ret to go to the next instruction.
20:48:12 <kmc> terminator?
20:48:23 <wagang> yes  a base form
20:48:40 <wagang> prtfact [] = 
20:48:41 <wagang> prtfact (x:xs) = do
20:48:41 <kmc> what's your question?
20:48:43 <wagang>   putStrLn (show x ++ " factorial is " ++ show (fact x))
20:48:44 <wagang>   prtfact xs
20:48:53 <kmc> wagang, please put code on hpaste.org; don't paste it here
20:49:00 <Cale> wagang: Ah, you'll probably want return () as the base case there
20:49:08 <wagang> ok thanks
20:49:22 <Cale> wagang: If v is any value, then return v is an action which does nothing, and returns that value.
20:49:24 <kmc> but we already have a function for this recursion pattern
20:49:42 <kmc> prtfact xs = mapM_ f xs where f x = putStrLn (show x ++ " factorial is " ++ show (fact x))
20:49:44 <wagang> which one please ?
20:49:51 <kmc> :t mapM_
20:49:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:50:32 <wagang> kmc and Cale, thank you so much
20:50:38 <Cale> mapM_ takes a loop body (which is a function from a value, the loop index, to an action to perform), and a list of values to iterate over, and produces an action which performs the loop
20:51:02 <Cale> and it discards the results of each iteration, which is what the _ convention signifies
20:51:16 <Cale> There is also mapM which collects the results of each iteration into a list
20:52:18 * ddarius would not use the terminology "loop index"
20:52:29 <wagang> I tried it, It works, Thanks!
21:24:15 <IceDane> I have a question: How do you guys indent your "where"s? I know it's got little relevance asl ong as it compiles, but I'm a pendatic man and it drives me nuts when I feel I don't have a coherent rule to my indentation
21:25:04 <dolio> One space.
21:25:47 <IceDane> With respect to the line above? e.g. something like
21:25:50 <IceDane> let a = b
21:25:53 <IceDane>  where a = 3
21:25:55 <IceDane>  ?
21:25:55 <IceDane> etc
21:26:15 <FunctorSalad_> one when autoindent isn't currently set up correctly for haskell, at least ;)
21:26:41 <IceDane> I see
21:27:43 <dolio> foo = ...
21:27:48 <dolio>  where
21:27:52 <dolio>  bar = ...
21:28:04 <IceDane> I see, thanks
21:28:06 <dolio> Or perhaps put the bar on the same line as the where. It depends how I'm feeling.
21:28:20 <FunctorSalad_> I usually put block-starters into their own line
21:28:53 <FunctorSalad_> maybe leftover from when I had a proportional font in emacs
21:29:10 <FunctorSalad_> (then you have to do it like that or it won't line up at all)
21:30:24 <dolio> My layout style (in general) would be terrible without monospace.
21:31:23 <IceDane> I would never even consider not using a fixed-width font in programming
21:31:52 <dibblego> I use leksah with dejavu sans mono book
21:33:20 <kmc> IceDane, sometimes i put "where" on the last line of the thing
21:33:25 <kmc> f x = y where
21:33:26 <kmc>   y = 3
21:34:26 <IceDane> aah
21:34:29 <IceDane> Hmm
21:36:48 <kmc> i found i didn't have a good handle on the layout rules until i read the section in the Report
21:36:57 <kmc> it's actually a lot more flexible than one would assume
21:37:24 <IceDane> kmc: http://www.haskell.org/onlinereport/lexemes.html#sect2.7 ?
21:38:38 <kmc> yes
21:39:08 <IceDane> I see
21:39:11 <IceDane> I did read it
21:39:23 <IceDane> But I was rather looking for 
21:39:39 <IceDane> common 'indenation style'*
21:40:08 <kmc> yeah
21:40:11 <kmc> my comment was tangential
21:45:18 <prsteele> Is q:qs faster than qs ++ [q] ?
21:45:51 <prsteele> alternatively, whats the internal representation of a Haskell list?
21:46:46 <mgsloan> ?src []
21:46:46 <lambdabot> data [] a = [] | a : [a]
21:47:15 <dibblego> prsteele, they are different values
21:48:14 <ClaudiusMaximus> prsteele: a:b is O(1), a ++ b is O(length(a)) (assuming you consume that much..)
21:48:48 <prsteele> dibblego: sure, just trying to determine the cost of fifo, lifo queues
21:49:04 <dibblego> prsteele, [] is a single linked list
21:49:10 <prsteele> ClaudiusMaximus: so presumably last qs is O(length(qs))?
21:49:19 <ClaudiusMaximus> prsteele: yep
21:49:46 <ClaudiusMaximus> so if you need access at both ends, use a different data structure
21:50:08 <prsteele> ClaudiusMaximus: is there a standard library doubly-linked list structure?
21:50:23 <dibblego> there is DList
21:51:15 <ClaudiusMaximus> doubly-linked is tricky in a pure/immutable functional setting as far as i understand it, because touching any part requires relinking the whole thing
21:51:26 <RyanT5000> is there a decent CommutativeMonoid class?
21:51:56 <jmcarthur> prsteele: if you want constant time access to both ends, try Data.Sequence
21:51:57 <RyanT5000> (i.e.: something that helps you create and enforce type-level commutativity guarantees)
21:52:18 <mjk> how to do 2^^30=1.073741824e9, I wang to show 10737418240000000000?
21:52:20 <ClaudiusMaximus> a list zipper works if you need a focus somewhere in the middle of a list
21:52:42 <mjk> wang/want
21:52:45 <ClaudiusMaximus> > 2^30
21:52:46 <lambdabot>   1073741824
21:53:53 <prsteele> "Data.Sequence is faster for every other (non-stack) access pattern, such as queue and random access"
21:54:10 <prsteele> jmcarthur: thanks
21:54:13 <jmcarthur> prsteele: alternatively, you could write your own data type:  data Queue a = Queue [a] [a]  ... enqueue by consing to one list, dequeue by taking the head of the other list. when you try to dequeue and the list is empty, perform \(Queue xs _) -> Queue [] (reverse xs)
21:54:34 <mjk> lambdabot: I want to not show scientific notation
21:54:38 <codolio> > showFFloat Nothing (2^^30) ""
21:54:39 <lambdabot>   "1073741824.0"
21:54:48 <jmcarthur> what i just described would be amortized constant time enqueue and dequeue
21:54:55 <jmcarthur> but you might as well just use Data.Sequence
21:55:27 <ClaudiusMaximus> > showFFloat (Just 0) (2^^30) ""
21:55:28 <lambdabot>   "1073741824"
21:55:47 <mjk> codolio: which module is showFFloat 
21:55:54 <codolio> Numeric
21:56:17 <prsteele> jmcarthur: thanks. Makes me realize I need to actually take a data structure class sometime...
21:56:40 <jmcarthur> i bet they don't bother teaching you either of the structures i just described ;)
21:56:56 <mjk> thanks
21:57:14 <jmcarthur> Data.Sequence is a finger tree. the Queue i just showed you would probably not be used in an impure language
21:57:35 <ClaudiusMaximus> i implemented binary search on sorted arrays in C the other day, was hard to get right (lots of potential for off-by-one errors)
21:57:51 <prsteele> jmcarthur: Because it doubles the memory? I'm guessing a textbook doubly-linked list would behave similarly without the extra space...
21:58:19 <ClaudiusMaximus> you don't need a doubly linked list, just another pointer to the end
21:58:24 <jmcarthur> prsteele: an impure version could just maintain a pointer to either end and push/pull with constant time mutation
21:58:41 <prsteele> true
21:58:48 <jmcarthur> prsteele: it wouldn't need that reverse application
21:58:55 <ClaudiusMaximus> ah, unless you need to pop from both ends
21:59:24 <jmcarthur> well, if you pop from both ends then you need doubly linked, yeah
21:59:32 <prsteele> ClaudiusMaximus: nope, just a simple fifo
21:59:34 <jmcarthur> but i'm just talking about normal queues
21:59:37 <jmcarthur> yeah, fifo
22:00:03 <jmcarthur> prsteele: and just for the record in case you didn't catch it already, normal lists are great for lifo
22:00:10 <jmcarthur> not so much for fifo
22:01:07 <prsteele> jmcarthur: ya, I was using that originally, but then I realized it led to (approximately) a depth first search, which wouldn't guarantee termination in my case
22:01:39 <jmcarthur> ooh, search is always fun
22:01:47 <ClaudiusMaximus> :t Data.Tree.levels
22:01:48 <lambdabot> forall a. Tree a -> [[a]]
22:02:57 <prsteele> jmcarthur: indeed. Graphs are fine, but I'm searching the positive integers, so following the wrong branch depth first ruins everything
22:03:33 <jmcarthur> there's always "fair" searching with the likes of LogicT
22:04:03 <jmcarthur> bedtime methinks
22:04:14 <prsteele> jmcarthur: thanks again
22:04:49 <ClaudiusMaximus> is there any "best" factor for the "if the array isn't big enough, resize it by factor" idiom?
22:05:07 <prsteele> ClaudiusMaximus: double it
22:05:29 <prsteele> ClaudiusMaximus: reach the desired size log time, never use more than 2x memory
22:06:28 <prsteele> Claudius: O(log(n)) resizes, O(n) memory, n = new size
22:06:28 <ClaudiusMaximus> prsteele: sure, but any K > 1 would reach the desired size log time, and never use more than K x memory
22:07:07 <cozachk> is there a strict version of hGetContents? 
22:07:30 <dolio> There's a package somewhere with it, I think.
22:07:52 <cozachk> is all IO lazy in haskell? 
22:07:57 <dolio> No.
22:08:10 <prsteele> ClaudiusMaximus: I suppose then its your desire for speed v. memory usage
22:09:04 <ClaudiusMaximus> prsteele: fair point, i guess it would be problem-specific
22:09:17 <prsteele> ClaudiusMaximus: although I wouldn't be surprised if the answer were 'e' or pi, the universe is weird like that
22:09:21 <cozachk> so one work around would be opening /dev/null and dumping to it 
22:09:23 <Mathnerd314> is there a data structure where its length can be determined without computing the contents?
22:09:27 <ClaudiusMaximus> prsteele: i had phi in mind
22:09:41 <prsteele> ClaudiusMaximus: haha
22:09:44 <cozachk> Mathnerd314: i believe regular length will work fine as long as the list is finite in length 
22:10:19 <prsteele> Mathnerd314: Make datatype that binds a list and an int, override how it updates
22:10:40 * Mathnerd314 thinks things over
22:10:42 <prsteele> Mathnerd314: list is still lazy, but you have the length
22:11:13 <Mathnerd314> I really want a data structure where filtering is less than O(n)
22:11:47 <Mathnerd314> and predicates consist of comparing bits
22:11:48 <prsteele> Mathnerd314: Is that even possible? To filter, you need to look at each element. Unless there's some special structure to your list, i.e., ordered
22:11:58 <ClaudiusMaximus> @hoogle Map k v -> (Map k v, k, Map k v)
22:11:58 <lambdabot> No results found
22:13:23 <prsteele> Mathnerd314: I don't think which predicate you use matters, unless O(<predicate>) > O(n). I still think you're going to need to make assumptions about the contents and structure of your list to beat O(n), though
22:13:36 <Mathnerd314> O(predicate) is 1
22:13:43 <Mathnerd314> for a given element
22:14:09 <prsteele> Mathnerd314: So you're fine there. But unless you can call of the filter before reaching the end of the list, you're O(n)
22:14:26 <ClaudiusMaximus> > takeWhile (< 10) [1..]  -- compare with filter (< 10)
22:14:26 <lambdabot>   [1,2,3,4,5,6,7,8,9]
22:14:37 <Mathnerd314> I don't think a list is the right structure, is the thing
22:14:37 <prsteele> Mathnerd314: i.e., set it up so that the first failure (or success) indicates that every element after it will fail (or succeed)
22:15:09 <ClaudiusMaximus> sure, if not a list then a tree or something, but the pruning might be possible if you set it up right
22:16:37 <Mathnerd314> ah, I need a function of type X a -> (a -> Bool) -> Integer for some type X
22:17:07 <ClaudiusMaximus> eg, i have some spatial tree code for a substitution tiling, whose pruning i speed up by keeping track of ones are totally inside the bounds (which implies their children will be inside too) and those that overlap the bounds (which implies children might be inside, outside or overlap)
22:20:52 <ClaudiusMaximus> Mathnerd314: without a constraint on 'a' to give more info, you can't do better than O(n) (i have no proof, but it feels obvious..)
22:21:59 <cozachk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28215#a28215
22:22:10 <cozachk> singlue user wiki mud in < 80 loc  
22:23:34 <prsteele> ClaudiusMaximus: I agree. If there is no relationship between the elements, you need to evaluate the predicate on each element, yielding O(n)
22:25:01 <ClaudiusMaximus> cozachk: cute
22:25:20 <cozachk> thank you, that was what i was attempting for ;) 
22:26:20 <Mathnerd314> well, the elements are tuples of distinct integers between 1 and some n, and the predicates are of the form (fst == 2) `and` (snd == 1)
22:26:55 <Mathnerd314> *tuples of length n
22:27:27 <ClaudiusMaximus> cozachk: where does the multi-user part of MUD come into it though? (or am i missing something?)
22:27:42 <cozachk> hehe i need to add that :-/ 
22:27:44 <ClaudiusMaximus> oh, i see
22:27:46 <ClaudiusMaximus> :)
22:28:04 <cozachk> its alot cleaner then my previous attempt
22:28:14 <cozachk> which was like over 200 lines long and looked like spaghetti 
22:28:23 <prsteele> Mathnerd314: Sort the elements. Assume ascending order; once your predicate fails after succeeding, all further elements will fails
22:28:57 <dolio> Using one of those sub-linear time sorts?
22:29:04 <Mathnerd314> that's still O(n)
22:29:12 <Mathnerd314> dolio: order doesn't matter
22:29:49 <prsteele> Mathnerd314: It is an improvement, but you're correct.
22:30:18 <prsteele> Mathnerd314: If you made a tree, branching on each successive element in the tuple...
22:30:33 <Mathnerd314> hmm... maybe my problem is reducible to SAT, so I can only get exponential perf.
22:30:59 <prsteele> Mathnerd314: You could cut out (assuming uniform distribution) approximately 1/10 of all elements remaining in the search at each level
22:31:05 <prsteele> Mathnerd314: SAT?
22:31:25 <Mathnerd314> http://en.wikipedia.org/wiki/Boolean_satisfiability_problem
22:31:49 <ClaudiusMaximus> cozachk: i made something vaguely similar, except it uses a hyperbolic tiling instead of a euclidean tiling, and each room can only store one bit; and then i implemented a variant of brainfuck on top of it..
22:32:15 <cozachk> sick... whats hyperbolic tiling? 
22:33:33 <ClaudiusMaximus> cozachk: http://en.wikipedia.org/wiki/File:Escher_Circle_Limit_III.jpg
22:33:50 <ClaudiusMaximus> cozachk: probably the most famous example
22:34:40 <cozachk> did you use Int(ger)s or doubles for the coordinate scalars? 
22:35:17 <wagang> data Pair a a =   Pair a a -- wonder "Conflicting definitions for `a'" ?
22:35:46 <dibblego> data Pair a = Pair a a
22:35:51 <ClaudiusMaximus> cozachk: i didn't use coordinates, but kept a   Map Integer Room  with   data Room = Room{ n,e,w,se,sw :: Maybe Integer, contents :: Bool }
22:36:28 <wagang> dibblego thanks for your help
22:36:29 <cozachk> sounds very intresting 
22:36:37 <dibblego> wagang, np
22:37:31 <ClaudiusMaximus> cozachk: more info at http://claudiusmaximus.goto10.org/cm/2010-06-15_king_james_hyperfuck.html
22:39:52 <prsteele> ClaudiusMaximus: what brought you to that problem?
22:40:11 <ClaudiusMaximus> prsteele: which problem?
22:40:31 <prsteele> ClaudiusMaximus: your link, the hyperbolic tiling
22:41:41 <ClaudiusMaximus> prsteele: i like to keep myself occupied, so i think of things and implement them - been quite interested in maths/art stuff since forever, so that's what i do..
22:42:28 <prsteele> ClaudiusMaximus: cool cool. I've restricted myself to 2D fractals, haven't worked up to higher dimensions.
22:42:39 <prsteele> ClaudiusMaximus: or different geometries
22:43:14 <prsteele> head (3 <| empty)
22:43:18 <prsteele> whoops
22:43:22 <prsteele> wrong emacs
22:43:26 <ClaudiusMaximus> :)
22:48:55 * hackagebot mastermind 2010.7.25 - console mastermind decrypter  http://hackage.haskell.org/package/mastermind-2010.7.25 (PaoloVeronelli)
23:06:00 * hackagebot mastermind 2010.7.25.1 - console mastermind decypher  http://hackage.haskell.org/package/mastermind-2010.7.25.1 (PaoloVeronelli)
23:34:07 * hackagebot hlint 1.7.3 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.7.3 (NeilMitchell)
23:44:03 <Colours> hey is there a function that will take a list and a number and break the list into segments the size of the number
23:44:21 <dibblego> Colours, there is in Data.List.Split
23:44:43 <Colours> split?
23:44:50 <Colours> oh wait that is a submodule
23:45:12 <dibblego> @hackage split
23:45:12 <lambdabot> http://hackage.haskell.org/package/split
23:45:55 <Colours> hm it seems kind of silly to add in a whole other dependency just to do one simple thing
23:46:22 <Colours> (I just need to break a giant string into 20-byte pieces)
23:46:39 <dibblego> you could write it yourself 
23:46:57 <Colours> I guess I will do that I was looking for something in data.list
23:47:07 <lispy> ?pl split y  = liftM Just $ readSplit y
23:47:07 <lambdabot> split = fmap Just . readSplit
23:49:30 <datwinkdaddy> So, I was reading through Haskell 2010 and I noticed the Random library was dropped. :(
23:50:03 <datwinkdaddy> Is that coming back?  What were the motivations for dropping it?  Is there a replacement in haskell-platform?
23:51:53 <tommd> datwinkdaddy: I don't know about the drop or HP but you can use random and monadrandom from hackage just fine.  No reason for concern there.
23:52:01 <ClaudiusMaximus> i'm no expert, but i think it'll still be available, and i imagine the motivations were that in practice most people needing random numbers were using something else, either for speed, or for quality of randomness
23:52:45 <datwinkdaddy> Cool.  I found it in the haskell platform, so I guess I'll just change Random.$foo to System.Random.$foo.
23:52:50 <datwinkdaddy> Thanks.
23:53:15 <ClaudiusMaximus> oh, that must be some old pre-heirarchical-modules code you have there then
23:53:20 <ClaudiusMaximus> ?
23:53:47 <datwinkdaddy> Haskell 98 had the flat namespace; I try and write to the standard when possible, although I'm always using GHC.
23:54:14 <datwinkdaddy> I'm still a newb in many ways.
23:54:53 <ClaudiusMaximus> fair enough, though Haskell98 + FFI + heirarchical modules is probably slightly less awkward; and anyway haskell98 will still be around forever-ish :)
23:55:09 <Colours> this is probably a dump question but how do I flip the elements in a 2-tuple :(
23:55:10 <datwinkdaddy> Speaking of, I was wondering what Alternative.some is for.  I thought I understood it, but each time I try and call it from GHCI it fails to terminate.
23:55:20 <Colours> like flip (3, 4) would yield (4, 3)
23:55:30 <datwinkdaddy> \(x,y) -> (y,x)
23:55:32 <ivanm> Colours: uncurry (flip (,))
23:55:42 <ivanm> @pl \ (x,y) -> (y,x)
23:55:42 <lambdabot> uncurry (flip (,))
23:55:50 <ivanm> datwinkdaddy's solution is probably better though ;-)
23:55:53 <ClaudiusMaximus> Colours: i've written the chunk function you were after earlier and the swap function you are after now, quite a few times in various projects :)
23:56:24 <Colours> haha
23:56:27 <Colours> also ivanm thanks :3
23:56:32 <datwinkdaddy> @help @pl
23:56:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:56:36 <datwinkdaddy> @help pl
23:56:36 <lambdabot> pointless <expr>. Play with pointfree code.
23:56:56 <ivanm> @where pointfree
23:56:56 <lambdabot> I know nothing about pointfree.
23:57:01 <ClaudiusMaximus> swap (x,y) = (y,x) is what i would use, but some argue  swap ~(x,y) = (y,x)  is better in some cases (as far as i understand it)
23:57:02 <ivanm> @google haskell pointfree
23:57:03 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
23:57:03 <lambdabot> Title: Pointfree - HaskellWiki
23:57:07 <ivanm> datwinkdaddy: ^^
23:57:19 <ivanm> ClaudiusMaximus: yeah, extra laziness
23:57:31 <datwinkdaddy> Oh, I understood "pointfree".  I'm just not familiar with the lb commands.
23:57:38 <ivanm> aha
23:57:54 <ivanm> the @pl command just runs the pointfree package on hackage
23:58:04 <ivanm> (well, actually the package is a port of the @pl command, but still...)
23:58:36 <datwinkdaddy> Q: I see (flip const) more often written as (const id), any reason?
23:58:42 <Colours> (I wou/win 2
23:58:47 <Colours> whoops mistype~
23:59:10 <ivanm> @type flip const
23:59:11 <lambdabot> forall b a. a -> b -> b
23:59:12 <ivanm> @type const id
23:59:13 <lambdabot> forall a b. b -> a -> a
23:59:28 <ivanm> datwinkdaddy: I think it's because hlint doesn't like flip... *shrug*
23:59:51 <ivanm> a bit of personal preference as well
