00:18:24 <Zeiris_> Could an hslogger logger be considered pure, since its side effects shouldn't affect program logic in any way shape or form?
00:18:47 <Zeiris_> (ie can I unsafePerformIO it, like Debug.Trace on steroids?)
00:21:58 <Zeiris_> Although I guess it's reasonable to only log actual side effects. So restricting a logger to IO may not be all that bad.
00:29:06 <Kaidelong> Zeiris_: isn't the fundamental problem with debugging in haskell that you want a way to provide intermediate state of pure functions?
00:29:19 <Kaidelong> so I imagine you'd need to put debugging stuff outside of just IO
00:29:54 <Zeiris_> Yeah, keeping it to IO is an annoying restriction. But unsafePerformIO is uncharted territory for me, and I'm scared of dragons.
00:30:30 <Kaidelong> If you are only exporting information out of the function without changing its behavior i imagine using unsafePerformIO won't really hurt purity too badly
00:31:34 <Kaidelong> although I suppose you do want to make is so that the debugging related side effects only happen when they are asked for, in which case that'd be decidedly impure. Just not in a very important way, I guess?
00:47:06 <monadic_kid> there is a strange bug in jhc when you have a nesting of withForeignPtr, the pointers always have the same address when they should be different for each nesting (when the foreignptr args are not the same of-course)
00:47:25 <darq> hello.i just started to write some program and was stopped by haskells way of generating random numbers.. i need an function which returns an float between -1 and 1 ... here is the code.. the problem is IO Float to Float - http://pastie.org/1068267
00:49:04 <monadic_kid> darq: hey, you can't escape an IO monad (others you can) without forcing a backdoor method
00:49:27 <monadic_kid> darq: are you using that function in an IO action?
00:52:11 <monadic_kid> darq: are you using randomFloat inside an IO action? if so then you only need to do varibleName <- randomFloat in a do-syntax and randomFloat >>= or =<< randomFloat normally
00:55:32 <monadic_kid> darq: understand?
01:15:48 <hewei> help
01:16:41 <hewei> window_next
01:17:33 <hewei> :quit
01:20:51 <dolio> rm -rf /
01:21:25 <monadic_kid> dolio: you trying to erase me!
01:38:08 <jystic> hi all, can anyone explain to me when and why i would want to use {-# UNPACK #-} ? how much data do i need before it's a bad thing, etc
01:42:41 <jystic> i'm looking at creating a data type for an IPv6 address and i found this representation of a MAC address (http://hackage.haskell.org/packages/archive/maccatcher/1.0.0/doc/html/src/Data-MAC.html#MAC), should i similarly unpack and strictify my IPv6 address?
01:42:42 <copumpkin> jystic: if you have a strict monomorphic field in a data type, it just asks the compiler to store it without indirection
01:43:24 <dolio> Not just that. It needs to be a single product, too.
01:43:25 <copumpkin> normally it'll store a pointer to a closure
01:43:26 <copumpkin> it won't make a big difference most of the time, unless you're in a tight inner loop operating on lots of addresses in bulk
01:43:35 <copumpkin> oh yeah
01:43:53 <dolio> GHC won't unpack sums.
01:44:10 <copumpkin> JHC will as of just recently, apparently!
01:44:14 <copumpkin> in some cases, anyway
01:44:19 <dolio> Yes. JHC is cool.
01:44:56 <jystic> so for my specific question, would you say that i should bother unpacking my ipv6 fields? or will it be more useful to others if they're unpacked?
01:45:07 <jystic> s/should/shouldn't/
01:45:47 <jystic> for me it doesn't really matter, i'm not doing a lot of operations on addresses
01:46:34 <jystic> but i am going to steal that representation of a MAC address for my library, so it made me think twice about how i represent other kinds of addresses
01:47:21 <copumpkin> only downside is that you lose sharing, but I don't think that's a big problem here :)
01:47:34 <copumpkin> I'd say do it
01:47:47 <lucca> seems like premature optimization, but probably won't hurt.
01:47:54 <copumpkin> especially if you're representing it as a bunch of Word8s
01:48:04 <jystic> well, it will be four Word32s
01:48:14 <copumpkin> ah
01:48:21 <jystic> i would have liked to re-use the network packages HostAddress6
01:48:45 <jystic> but it's just defined as a type synonym, so it's not that good for making instances of Show and Storable
01:49:22 <lucca> making separate functions to read and store the :: stuff?
01:49:22 <jystic> same for IPv4 addresses (type HostAddress = Word32)
01:50:14 <jystic> lucca: i'm not sure i know what you mean?
01:50:26 <kmc> unpacking a sum results in an explosion of ctors right?
01:50:43 <kmc> if i have «data Foo = Foo (Maybe Char) (Maybe Char)» and i unpack those two fields, Foo effectively has 4 ctors yes/
01:50:57 <jystic> consider an IPv4 address, i want to store it as a Word32, but the show instance should convert it to "172.23.21.1" etc
01:52:57 <humasect> @src flip
01:52:57 <lambdabot> flip f x y = f y x
01:53:10 <humasect> location.. +)
01:54:28 <jystic> ok, how about unpacking a data type with only one field, does this make sense: data IPv4 = IPv4 {-# UNPACK #-} !Word32
01:54:38 <copumpkin> sure
01:54:57 <jystic> does that mean it's effectively the same as a regular Word32?
01:54:59 <c_wraith> Not sure why you wouldn't just newtype it in that case...
01:55:33 <jystic> c_wraith: so it's the same as: newtype IPv4 = Word32 ?
01:55:42 <copumpkin> you need a constructor
01:55:48 <jystic> yep ok
01:55:52 <c_wraith> newtype IPv4 = IPv4 Word32
01:55:55 <copumpkin> but it probably would be the same
01:56:19 <jystic> so what's the difference between newtype and data?
01:56:23 <c_wraith> If it's strict, they're semantically the same.  the newtype might be better-optimized
01:56:32 <c_wraith> newtypes are compile-time only
01:56:44 <c_wraith> at runtime, they are the same type as they wrap.
01:56:45 <copumpkin> newtype guarantees you get the same runtime representation as the underlying type
01:57:03 <jystic> ok cool, that's probably what i want anyway
01:57:04 <copumpkin> and thus you must only have one underlying type and one constructor in it
01:57:28 <copumpkin> newtype Z = Z Z
01:57:47 <jystic> and i assume i can have my own instances of Storable and Show for newtypes
01:58:03 <c_wraith> yes, the main advantage of newtypes is that you can create different instances for them
01:58:27 <c_wraith> (plus, using GeneralizedNewtypeDeriving, you can selectively expose the underlying implementation's instances)
01:58:28 <copumpkin> you can ask it to derive newtype instances for you automatically, from the underlying type
01:58:28 <copumpkin> but that isn't always what you want
01:58:43 <jystic> hmm, it's probably what i want for Storable
01:58:56 <jystic> just now for Show
01:59:00 <jystic> s/now/not
01:59:20 <copumpkin> keep in mind that Show is unofficially for "valid haskell" syntax
01:59:34 <jystic> oh ok, i didn't know that
01:59:36 <copumpkin> not that I think anyone will murder you for not doing that
01:59:43 <copumpkin> and stdgen isn't good either
01:59:55 <c_wraith> too many libraries don't do that for people to care about another one
02:00:38 <jystic> i think it's useful to be able to parse and format an ip address without much overhead
02:01:20 <jystic> syntatic overhead i mean
02:02:24 <jystic> would there be a way i can use newtype for my IPv6 definition? it needs to be 128-bits
02:02:46 <copumpkin> nope, except trivially
02:03:01 <jystic> or does it not make sense for that situation, because it doesn't really match an existing type
02:03:54 <copumpkin> well, you could newtype to a tuple of four Word32s, but then you'd lose any advantage
02:03:54 <copumpkin> so I'd just unpack a regular data type
02:05:43 <jystic> great, thanks for the advice guys, i think i'm set
02:05:45 <c_wraith> Does GHC tag single-constructor data types?
02:05:54 <kmc> Word128# ;P
02:06:11 <c_wraith> magichash detected. :P
02:06:12 <kmc> c_wraith, what do you mean?
02:06:15 <copumpkin> omg kmc is still awake
02:06:24 <copumpkin> mmm, magic hash
02:06:25 <kmc> omg copumpkin is still awake
02:06:36 <copumpkin> kmc: nah, I just woke up :P
02:06:45 <c_wraith> for data types with multiple constructors, ghc tags the type with the constructor used.  Does it just skip that entirely if there's only one constructor?
02:06:57 <c_wraith> err, tags the *value* with the constructor used.
02:07:25 <kmc> do you mean that it tags the pointer to the boxed value?
02:07:32 <kmc> that's still valuable with only one ctor
02:08:20 <kmc> because it tells you that the referent is evaluated to whnf, and so you can get at its fields with simple offsetting
02:08:36 <c_wraith> ah, good point.
02:08:48 <kmc> rather than entering the closure
02:08:53 <c_wraith> yeah
02:09:08 <kmc> edwardk abuses this to great effect in his speculation library
02:09:25 <kmc> tagless G-machine my arse ;)
02:09:30 <copumpkin> edwardk never abuses anything!
02:09:36 <copumpkin> he is a very good man
02:09:42 <kmc> and thorough
02:09:47 <c_wraith> that speculation library is mind-bending.  I mean...  I see how it works...  But oww.
02:09:50 <c_wraith> my poor head. :)
02:10:14 <copumpkin> I haven't seen it
02:10:27 <copumpkin> @hackage speculation
02:10:27 <lambdabot> http://hackage.haskell.org/package/speculation
02:10:36 <copumpkin> oho
02:10:38 <c_wraith> It's speculative folds, for parallelizing linear processes
02:11:08 <c_wraith> ..  Assuming you have a decent ability to guess what a calculation is going to result in much faster than performing the calculation
02:16:45 <c_wraith> I remember being told the "tagless" in STG meant something else :)
02:25:39 <kmc> yeah
02:26:00 <dolio> Tagless has to do with distriguishing integers from pointers via tag bits, as I recall.
02:26:04 <kmc> they don't rely on tags to distinguish pointers from non-pointers
02:26:08 <c_wraith> Not that I know what it actually means.  Nor do I know what the spineless means in that context, either.
02:26:32 <c_wraith> In fact, I really should just read the book about implementiong lazy functional languages.
02:26:44 <c_wraith> As it explains the STG in quite a lot of detail
02:26:47 <c_wraith> and I'm sure I'd learn a lot
02:27:05 <kmc> except the eval/apply paper talks about tagging those too, in certain contexts
02:29:21 <kmc> but not the way it's usually meant
02:29:44 <dolio> I think spine has something to do with function application.
02:29:48 <dolio> But I can't really recall.
02:30:33 <SimonJohansson> TEstk
02:30:37 <SimonJohansson> Test 1,2
02:40:55 <obfuscated> Hello, is this  "ask s = do putStr s\n            readLn"  supposed to work in ghc 6.12.3?
02:41:26 <c_wraith> assuming the number of spaces is right, it looks fine
02:42:19 <c_wraith> with that formatting, the start of "putStr" needs to line up with the start of "readLn"
02:42:53 <c_wraith> But if it's not working, what error message is the compiler giving you?
02:43:07 <obfuscated> *Main> ask "test"
02:43:07 <obfuscated> <interactive>:1:0:
02:43:07 <obfuscated>     Ambiguous type variable `b' in the constraint:
02:43:07 <obfuscated>       `Read b' arising from a use of `ask' at <interactive>:1:0-9
02:43:07 <obfuscated>     Probable fix: add a type signature that fixes these type variable(s)
02:44:25 <c_wraith> Ah.
02:44:48 <c_wraith> :t readLn
02:44:48 <lambdabot> forall a. (Read a) => IO a
02:45:08 <c_wraith> it means the compiler can't figure out what type you mean for a, there.
02:45:34 <c_wraith> Which is because it doesn't have sufficient context to infer it.  So try specifying it directly.
02:45:48 <obfuscated> yes, but I've copied this example from http://haskell.org/haskellwiki/IO_inside
02:45:50 <vanadium> is this the monomorphism restriction
02:46:22 <c_wraith> No, it's not the monomorphism restriction, as that definiition has an explicit parameter
02:46:37 <vanadium> right
02:47:51 <humasect> @src liftM
02:47:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:48:30 <darq> hello. can someone tell me how to get an Float from IO Float.. i try to generate an random float ... http://pastie.org/1068267
02:49:25 <Twey> liftM f m = m >>= return . f
02:49:39 <c_wraith> obfuscated: that example where it defines ask really is wrong..  It needs to do *something* to allow the compiler to figure out what the types of a and b are, and it doesn't.
02:50:22 <Twey> darq: You don't ‘extract’ the float, you add new steps to the ‘recipe’ you're building up to decide what to do with the float once you've got it
02:51:01 <obfuscated> c_wraith: so the IO_inside site/tutorial is broken?
02:51:30 <c_wraith> I think that's meant as an illustration, not a complete example.  The code there isn't wrong, it's just incomplete.
02:53:06 <humasect> Twey: thx
02:53:11 <ivanm> preflex: seen mounty
02:53:11 <preflex>  Sorry, I haven't seen mounty
02:55:37 <obfuscated> OK, I've added "ask :: String -> IO String" above the "ask s  =" line and now it compiles but when I execute the 'ask "enter something: " ' and I enter some random string, I get "*** Exception: user error (Prelude.readIO: no parse)"
02:56:33 <ivanm> obfuscated: are you using read to get the String in?
02:56:40 <ivanm> oh, wait, readIO
02:56:49 <ivanm> obfuscated: if you just want a String, use GetLine or something
02:56:51 <c_wraith> That's because the value you're entering doesn't parse as a haskell string
02:57:02 <ivanm> > read "\"This is a String\"" :: String
02:57:02 <c_wraith> readLn is kind of annoying like that. :)
02:57:03 <lambdabot>   "This is a String"
02:57:09 <ivanm> ^^ obfuscated 
02:57:49 <obfuscated> uf, now it works
03:13:16 <humasect> @src atomicModifyIORef
03:13:16 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:14:18 <Cale> humasect: That's primitive.
03:14:28 <humasect> ahh..
03:14:34 * humasect bungles about GHC.IORef
03:14:55 <Cale> Well...
03:15:14 <humasect> i wanted to pass in some kind of (a -> IO b)
03:15:16 <Cale> atomicModifyIORef :: IORef a -> (a -> (a,b)) -> IO b
03:15:17 <Cale> atomicModifyIORef (IORef (STRef r#)) f = IO $ \s -> atomicModifyMutVar# r# f s
03:15:27 <humasect> yea, there the second arg
03:16:12 <humasect> it does not look easy to unwrap between read/writeIORef for the same ability
03:16:30 <Cale> Well, it won't be atomic if you do it that way.
03:16:36 <Cale> But of course you can write:
03:16:40 <humasect> or maybe it doesnt matter in this case..
03:17:04 <Cale> modifyIORef f r = do v <- readIORef r; w <- f v; writeIORef r w
03:18:04 <Cale> If you need atomicity with respect to other threads, along with the possibility of more complicated memory effects, then you should probably try STM
03:18:07 <humasect> yeah~
03:18:36 <humasect> hm=) i only wish to use the IORef as a "ghci variable" 
03:19:19 <humasect> 'f' in this case is a -> IO a rather than a->a
03:21:30 <Cale> Well, hmm. Maybe it would be good to know what you're trying to compute :)
03:21:37 <ivanm> humasect: "ghci variable" ?
03:22:05 <humasect> ahh=) well, a server to start and stop in ghci, with the socket and thread held in an IORef 
03:22:38 <humasect> so i have a convenient Console.hs which provides such things like 'start' and 'stop' and 'listClients' for convenience and dev aids for later
03:24:59 <Cale> okay
03:25:22 <Cale> So, yeah, an IORef seems reasonably sensible for that.
03:25:55 <humasect> yeah~ and i move them into this other file because i realise that unsafePerformIO is executed on ghci code reload=)
03:26:15 <humasect> (so the file will not change much at all because of that)
03:26:38 <humasect> i think it is okay using your method (readIORef r >>= change >>= writeIORef r) and worry about atomicity
03:26:54 <humasect> (the clients are TVars)
03:49:50 <cncl> question: i frequently wrap numeric types like double and int in a newtype, to help enforce logical distinctions in my programs. i also use GeneralizedNewtypeDeriving to avoid having to add a bunch of instances each time i do it. but i still have to add a big 'ol deriving (...) clause, with a ton of numeric typeclasses in it
03:50:27 <cncl> is there some way around that, or do i just live with copy/pasting around the deriving clause
03:50:57 <Cale> Heh, you could use a CPP macro :P
03:51:25 <cncl> i guess that's better than requiring template haskell, hyuk
03:51:50 <Cale> I suppose TH is another option, sort of.
03:51:51 <ivanm> Cale: how would such a macro do it automatically for you?
03:52:01 <ivanm> cncl: what's so hard putting a deriving clause in?
03:52:09 <ivanm> that way, when you read the code you know what it's deriving...
03:52:18 <cncl> ivanm, it's just ugly if i declare like 10 numeric newtypes at the top of a file
03:52:19 <Cale> ivanm: I'm assuming there's a fixed list of classes you want to derive
03:52:27 <cncl> and each one has the same classes
03:52:36 <cncl> yeah
03:53:09 <cncl> (it only bugged me right now because this one file has a bunch, normally it's only a couple at a time)
03:53:10 <Cale> TH actually might not be so bad, if you do this a lot.
03:53:20 <cncl> does TH work in GHCi ok?
03:53:25 <Cale> yeah
03:53:42 <cncl> hmm, maybe i will take a look at it. i read the paper introducing it a while ago, though i never tried using it in practice
04:02:02 <McManiaC> while we're at TH
04:02:19 <McManiaC> I want to write some $(derive... [d| .. |]) function
04:02:31 <McManiaC> where .. is some record definition
04:03:15 <McManiaC> can I make sure the record only uses types with instances of some "TA" class?
04:12:39 <b0fh_ua> Hello! Can somebody please advice, what am I doing wrong: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28434#a28434 .
04:13:16 <b0fh_ua> looks like I missed something about creation of correct instance of EitherT
04:14:18 <b0fh_ua> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28434#a28435 - added error message
04:14:35 <Cale> You're passing two parameters to return
04:14:46 <Cale> Which means that return must be producing a function
04:15:02 <b0fh_ua> fail...
04:15:13 <b0fh_ua> you're right, and I was blind
04:15:25 <Cale> So,  return :: a -> m a  gets specialised to  return :: a -> (e -> a)  :)
04:15:32 <b0fh_ua> yeah )
04:15:52 <b0fh_ua> Cale: is it possible to get rid of "return"?
04:17:51 <Cale> no?
04:17:55 <Cale> I'm not sure what you mean
04:18:37 <b0fh_ua> Cale: Result . EitherT . Left . SimpleError
04:18:39 <b0fh_ua> something like this
04:19:30 <Cale> I don't think that typechecks, does it?
04:19:31 <b0fh_ua> or I have to do it as Result . EitherT . return . Left . SimpleError?
04:19:46 <b0fh_ua> Cale: it does not, it can't infer IO monad there
04:22:48 <McManiaC> you need return
04:23:51 <Cale> Yeah, you need something which makes it the right type. You could use another m-action there instead, but the parameter to EitherT has to have type m (Either e a)
04:24:46 <b0fh_ua> yup
04:24:57 <b0fh_ua> so do $ return is fine there
04:25:08 <McManiaC> you dont need do :)
04:25:30 <b0fh_ua> I can replace $ do with . return of course
04:25:31 <Cale> do is for gluing together multiple actions. You only need it when there's more than one
04:25:38 <McManiaC> makeErrorStr = Result . EitherT . return . Left . SimpleError
04:26:44 <b0fh_ua> McManiaC: I still have return here :)
04:26:46 <Cale> For any action x, you have do x = x
04:27:18 <McManiaC> makeErrorStr = Result . EitherT . simpleError where simpleError = return . Left . SimpleError
04:27:21 <McManiaC> ;P
04:28:57 <McManiaC> b0fh_ua: why do you want to avoid return so much? ^^
04:31:16 <dobblego> is it usual for a transformer version of a data type to implement all the same type-classes but lifting into the monad (fmap?)?
04:31:27 <b0fh_ua> McManiaC: just to make code cleaner a bit :)
04:33:08 <Cale> dobblego: If I understand the question, then I think yes.
04:34:01 <Nibble> Hi, I need help with xmonad. I have problems getting xmobar to work
04:34:31 <leino> are there any text editors that are particularly well suited for haskell?
04:34:36 <dobblego> newtype IdentityT m a = IdentityT (m a); ... instance all the classes instanced by Identity by lifting m
04:34:41 <Nibble> leino: there is emacs with haskell mode
04:34:45 <dobblego> Cale, that's what I mean ^^
04:34:51 <Nibble> leino: and one written in haskell
04:34:56 <Nibble> lekash or something like that
04:35:04 <dobblego> I use leksah
04:35:07 <Nibble> leksah*
04:35:18 <leino> Nibble: ok thanks... no addons for vim?
04:35:30 <Nibble> leino: there is one
04:35:31 <McManiaC> I use vim
04:35:50 <McManiaC> without any big addons
04:35:50 <McManiaC> :)
04:35:56 <Nibble> McManiaC: I use nano
04:36:01 <wto> I also use vim, but the Haskell mode is way better in emacs
04:36:11 <wto> maybe I should switch...
04:36:12 <leino> MCManiaC: I find the special indentation rules for haskell kind of confusing
04:36:45 <McManiaC> thats why I prefer doing it by hand :>
04:36:48 <Nibble> gtk2hs-buildtools and alex doesnt seems to work when installing from cabal
04:36:59 <Nibble> says that it cant find them, strange
04:37:07 <McManiaC> cabal update?
04:37:23 <Nibble> McManiaC: I did that yesterday
04:37:25 <Nibble> but sure
04:37:31 <McManiaC> hm
04:38:02 <cncl> what platform are you on
04:38:09 <Nibble> cncl: me_
04:38:12 <cncl> yeah, sorry
04:38:24 <Nibble> arch linux
04:38:32 <cncl> 64 or 32?
04:38:36 <Nibble> 64bit
04:38:41 <cncl> i have the same setup as you
04:38:53 <McManiaC> could you paste the install log?
04:38:55 <cncl> do you have parts of the haskell platform installed via pacman/arch's system?
04:39:27 <Nibble> ghc and cabal
04:39:55 <cncl> hmm, no clue :[
04:40:00 <cncl> install log would help
04:40:24 <Nibble> cncl: lets take this later, I am trying to get xmobar to work with xmonad
04:40:32 <Nibble> but it is not even showing up. hum
04:40:50 <Nibble> oh, I ran it manually and it showed up
04:40:55 <McManiaC> theres #xmonad :)
04:41:02 <Nibble> how do I set tiling mode?
04:41:17 <Nibble> McManiaC: ok, just this question, then I go to #xmonad
04:41:45 <McManiaC> no idea :)
04:41:52 <Nibble> my xmobar is constantly displaying Updating...
04:42:01 <McManiaC> I prefer dzen :>
04:42:43 <Nibble> sure you do
04:43:42 <augur> anyone interested in graph theoretic properties of rock-paper-scissors-type games?
04:43:43 <augur> 8D
04:44:07 <msieradzki> atm I'm more interested how to get auto indentation for haskell inv im
04:44:28 <augur> ;p
04:48:24 <msieradzki> I might even switch to emacs
04:50:50 <cncl> add "filetype plugin indent on" to your .vimrc
04:53:24 * McManiaC just cant get used to emacs :S
04:53:56 <cncl> that's what viper mode + vimpulse is for :)
04:54:44 <msieradzki> talking about vim 7.2, default stuff I don't have haskell.vim in indent/
04:55:47 <McManiaC> cncl: theres still a lot missing
04:55:56 <cncl> like what
04:57:12 <McManiaC> cant tell you tbh :)
04:57:18 <cncl> haha
04:57:26 <cncl> vimpulse does visual block mode, even
04:57:31 <McManiaC> its been a while since a tried it (~ 3/4 year maybe)
04:57:39 <cncl> and also recently added da), di), etc
04:57:48 <cncl> and ctrl-o (very important)
04:58:28 <McManiaC> hm I dont know vimpulse
04:58:29 <McManiaC> ^^
04:59:55 <cncl> it's an addon for viper mode, gotta download/install separately
05:00:06 <cncl> adds visual block mode and other stuff that was missing from viper
05:07:47 <McManiaC> cncl: is there an arch package for it?
05:08:15 <cncl> hm i don't think so
05:08:22 <cncl> it's just a single file, vimpulse.el
05:08:49 <cncl> i think there's a git repo for it somewhere. honestly i just check it out like once a year and put it into my dotfiles repository directly, as a file
05:09:49 <McManiaC> okay
05:10:13 <msieradzki> cncl, did you install separate indent vim file?
05:10:15 <msieradzki> if so where from
05:10:54 <cncl> no just haskell.vim right now
05:11:14 <cncl> i don't think the haskell vim mode does real/semi-real parsing like the emacs mode
05:11:29 <cncl> so it can't do as good prediction of what the indentation should be when you press return
05:11:38 <cncl> (yi beats both of them)
05:11:39 <msieradzki> well atm it's pretty much useless
05:11:46 <msieradzki> solid tab that does 2/4/8 spaces
05:12:03 <arw> just use braces and cindent :)
05:12:09 <cncl> haha bleaahh
05:12:26 <cncl> i think real parsing in vim is too slow for haskell
05:12:34 <cncl> or most other languages
05:12:51 <cncl> since i believe (not sure) that vim's language is much slower than elisp
05:14:00 <arw> cncl: no, you are right. vimscript is more of a mutated configuration language than something one would write "programs" in.
05:14:34 <cncl> elisp isn't a speed demon but it's definitely a usable language
05:15:39 <arw> cncl: also, more of emacs is written in elisp than vim in vimscript. so speed is more of a focus in elisp.
05:15:50 <arw> i guess at least
05:16:18 <cncl> yeah
05:17:23 <humasect> does vim interact with ghci like emacs ?
05:17:49 <cncl> you can make it, i've tried it
05:17:59 <cncl> though it's not really any more convenient than running ghci in a separate terminal
05:18:12 <humasect> like "evaluate region in ghci buffer"
05:18:27 <cncl> hm maybe, i can't remember
05:19:36 <McManiaC> cncl: what is my loadpath?
05:20:42 <cncl> no clue?
05:21:43 <McManiaC> well, where do I have to save vimpulse.el?
05:22:22 <cncl> somewhere that emacs can find it
05:22:40 <cncl> like ~/.elisp, and then add that to your load-path in your .emacs file
05:23:17 <monadic_kid> new version of jhc released with wii target support: http://www.haskell.org/pipermail/jhc/2010-July/000775.html
05:24:26 <humasect> monadic_kid: cool, i just saw the email about it=)
05:25:15 <monadic_kid> indeed i'm straight on it later on!
05:25:17 <cncl> that is pretty cool
05:27:38 <monadic_kid> yeah hopefully i'll release my modified version of SDL bindings to work with them
05:27:38 <jystic> hi all, is there something like 'map' that will consume two values from a list and pass them to a function that takes two arguments? kind of like zipWith but using only one list
05:28:25 <monadic_kid> i mean hopefully this weekend
05:30:01 <humasect> zip with one list? map? =)
05:30:30 <humasect> @type zip . filter
05:30:31 <lambdabot>     Couldn't match expected type `[a]'
05:30:32 <lambdabot>            against inferred type `[a1] -> [a1]'
05:30:32 <lambdabot>     Probable cause: `filter' is applied to too few arguments
05:30:43 <jystic> the type signature would be: (a -> a -> b) -> [a] -> [b]
05:30:47 <mauke> jystic: I'd use something from Data.List.Split
05:31:10 <humasect> @hoogle http://www.haskell.org/hoogle/?hoogle=+%28a+-%3E+a+-%3E+b%29+-%3E+%5Ba%5D+-%3E+%5Bb%5D
05:31:10 <jystic> mauke: thanks i'll take a look
05:31:10 <lambdabot> Parse error:
05:31:11 <lambdabot>   --count=20 http://www.haskell.org/hoogle/?hoogle=+%28a+-%3E+a+-%3E+b%29+-%3E+%5Ba%5D+-%3E+%5Bb%5D
05:31:11 <lambdabot>                        ^
05:31:14 <humasect> oops, sorry
05:31:26 <cncl> he means like, f (x : y : ys) = f x y : recur ys
05:31:39 <jystic> yeah
05:31:45 <humasect> looks like foldl1 
05:31:54 <humasect> @hoogle (a -> a -> b) -> [a] -> [b]
05:31:54 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
05:31:55 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
05:31:55 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
05:31:56 <cncl> no, foldl1 is just foldl but with a list that has at least one arg
05:32:04 <cncl> jystic: you can just write the function like that
05:32:21 <jystic> cool, just wanted to make sure i'm not missing something :)
05:32:35 <cncl> twozip f (x : y : zs) = f x y : twozip f zs
05:32:44 <cncl> twozip _ [] = []
05:32:48 <byorgey> better yet, 8 = -1 because 8 == -1 (mod 9)
05:32:52 <mauke> map (\[x, y] -> f x y) . chunk 2
05:32:54 <byorgey> sorry, wrong chan
05:32:59 <humasect> hehe=)
05:33:04 <mauke> this will fail if the list has an odd length
05:33:08 <cncl> oops, maybe make that second definition twozip _ _ = []
05:33:11 <cncl> otherwise it could fail
05:33:12 <jystic> yeah that's ok
05:33:21 <jystic> it will always have a multiple of two
05:33:27 <cncl> famous last words :)
05:33:31 <jystic> haha
05:33:48 <jystic> actually it will always have exactly 16 elements
05:33:50 <humasect> =)
05:34:45 <jystic> the alternative would be a function which is like intersperse but only inserts the separator every second element
06:02:00 <tau> does this algorithm already exist ?
06:02:04 <tau> http://codepad.org/CNFGK7MZ
06:02:08 <tau> what is its name ?
06:05:59 <copumpkin> tau: that's a massive chunk of code :P
06:06:31 <copumpkin> can you give some overview about what it does or what parts of that code you're asking about?
06:06:49 <tau> copumpkin:  yes, i can.
06:06:52 <tau> wait a moment.
06:07:34 <tau> http://codepad.org/rANCGx5U
06:07:38 <tau> copumpkin:  that works so.
06:07:49 <tau> copumpkin: it isn't so much explained but i think it is going to help.
06:08:30 <copumpkin> so it's some sort of an expression parser?
06:08:33 <copumpkin> and evaluator
06:08:46 <pastorn> tau: ehm... could you write that as INPUT: lol; OUTPUT: lulz?
06:08:58 <pastorn> it's hard to see what's going on...
06:09:08 <tau> pastorn: sure.
06:09:13 <mauke> what's that -> < -> < stuff
06:09:14 <tau> copumpkin: yes, it is.
06:09:21 <tau> mauke: -> output
06:09:29 * hackagebot type-level-numbers 0.1 - Type level numbers implemented using type families.  http://hackage.haskell.org/package/type-level-numbers-0.1 (AlexeyKhudyakov)
06:09:44 <tau> let me explain better.
06:09:53 <mauke> then why is * < + ?
06:10:00 <tau> mauke: testing precedence.
06:10:09 <tau> * > + has higher precedence than +.
06:10:22 <tau> so, * > + is true, and * < + is false.
06:10:30 <pastorn> tau: that sounds like parsing stuff...
06:10:46 <tau> pastorn: yes, that is a parsing, but i want to know whether that algorithm already exists
06:10:50 <tau> and what is its name.
06:11:11 <pastorn> tau: chain exists... it's a function in the Parsec library
06:11:17 <tau> i have written that yesterday, but i don't know what is its common name, i simply 'invented'..
06:11:19 <pastorn> it deals with precedence stuff
06:11:26 <mauke> pastorn: you're missing the question
06:11:32 <pastorn> maybe i am
06:11:37 <tau> pastorn: but, there is a special thing on how that works.
06:11:40 <mauke> tau: why are you asking here?
06:11:52 <tau> mauke: because i didn't think any better place to ask.
06:12:12 <mauke> so you have some algorithm you made up and the C code you wrote for it
06:12:22 <pastorn> tau: could you rewrite that irc log as IN/OUT declarations with some comments?
06:12:24 <mauke> I don't see how this leads to #haskell
06:12:32 <tau> pastorn:  sure, i will.
06:13:36 <mauke> strchr(" ", *p) what?
06:15:01 <tau> mauke: that is just a draft.
06:15:14 <tau> i am going to rewrite that, so i didn't care on some points.
06:19:04 <tau> pastorn: i will rewrite it in soon, i gotta go now.
06:23:56 <minimalis> Can anyone recommend any part-time courses in the UK that have a good coverage of functional programming, preferably including some Haskell?
06:30:50 <benmachine> @remember JohnMeacham I was just thinking I needed type level naturals last night at the pub.
06:30:50 <lambdabot> I will never forget.
06:34:47 <ivanm> benmachine: as you do
06:36:18 <Phyx-> benmachine: you went to the pub... and thought about haskell?
06:36:50 <Kaidelong> hey haskell is relaxing to think about
06:37:24 <benmachine> Phyx-: if I ever went to the pub that's probably what I'd do >_>
06:37:38 <Phyx-> Kaidelong: not in my experience -.-
06:37:53 <Kaidelong> what'd you rather be thinking about then?
06:37:55 <Phyx-> lol
06:38:02 <Phyx-> benmachine: I kill braincells when in pubs
06:38:15 <Phyx-> Kaidelong: preferably, nothing
06:38:38 <ivanm> Phyx-: not even your next pint?
06:39:09 <Phyx-> ivanm: no, I give the bartended instructions before hand
06:39:14 <Phyx-> bartender*
06:39:35 * Phyx- is sad that he's killed relatively few braincells this holiday
06:42:42 <Phyx-> did everyone just run off to a pub? :P
06:45:06 <Kaidelong> afraid not
06:45:18 <ivanm> nah, the pubs are closing here atm
06:45:25 <ivanm> or turning into more night-club like places
06:45:27 <ivanm> @time
06:45:28 <lambdabot> Local time for ivanm is Sat Jul 31 23:45:04
06:45:33 <ivanm> I should be running off to bed...
06:45:37 <Phyx-> @time
06:45:40 <lambdabot> Local time for Phyx- is Sat Jul 31 15:45:07 2010
06:45:53 <Phyx-> oops, didn't change my time
06:46:07 <Phyx-> it's actuallly 09:45
06:46:15 <ivanm> huh
06:46:36 <Phyx-> i'm on vacation, but didn't change my laptop's time
06:46:55 <ivanm> aha
06:47:07 <ivanm> what, on vacation from the UK to America or something?
06:47:20 <ivanm> no, wait, not UK; western europe though?
06:47:39 <Phyx-> nah, from The Netherlands to Netherlands Antilles :P
06:48:21 <ivanm> aha
06:48:38 <Phyx-> at my parent's place
06:48:39 <ivanm> so what, this way you don't need a visa? :p
06:48:45 <Phyx-> but i'm bored :/
06:48:55 <Peaker> @type foldl' (:) []
06:48:56 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
06:48:57 <lambdabot>       Expected type: a
06:48:57 <lambdabot>       Inferred type: [a]
06:49:05 <ivanm> oooh, the netherlands antilles is only going to be around for another couple of months according to wikipedia...
06:49:06 <Phyx-> ivanm: considering I was born there no :P
06:49:12 <Phyx-> yeah
06:49:13 <Cale> :t foldl' (flip (:)) []
06:49:14 <lambdabot> forall b. [b] -> [b]
06:49:29 <Cale> > foldl (flip (:)) [] [1,2,3]
06:49:30 <lambdabot>   [3,2,1]
06:49:41 <ivanm> Phyx-: well, you could have given up your citizenship... ;-)
06:49:43 <Phyx-> then the corrupt politicians can drive the place to bankrupcy, wooo
06:49:46 <Peaker> Cale, I want to deep-force the list
06:50:06 <Phyx-> ivanm: we get dutch nationalities, so nothing really to give up :P
06:50:28 <ivanm> Phyx-: which was kind of my point
06:50:29 <Cale> > foldr seq () [1,error "hello",3]
06:50:30 <lambdabot>   *Exception: hello
06:50:46 <Peaker> Cale, foldr causes stack overflows if you use it to force large lists :(
06:50:55 <ivanm> it's not like you're going to some other caribean island
06:51:15 <Cale> Are you using it like that?
06:51:18 <Phyx-> ivanm: not this year no, the plans fell apart.
06:51:32 <Phyx-> ivanm: we *we're* going to LA & Vegas but..
06:51:40 <Peaker> btw: jdh eventually admitted my transliteration of his optimized F# parallel quicksort to GHC 6.10.3. without any profiling/optimization, ran 50% slower (and not 20x slower as he originally claimed)
06:51:43 <Cale> (Because I'm pretty sure that won't stack overflow)
06:51:43 <Peaker> Cale, Yeah
06:51:51 <Peaker> Cale, let me test again
06:52:00 <Cale> Unless evaluating one of the elements of your list is a stack overflow anyway
06:52:19 <ivanm> Peaker: wow!
06:53:04 <Heffalump> apparently getElems on a 10 million length array also stack overflows, which is pretty crap
06:53:34 <ivanm> as in that statement is crap or the fact that it happens is crap?
06:53:53 <Peaker> Cale, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28437#a28437
06:54:11 * Kaidelong tries to imagine where you'd use a 10 million element array...
06:54:12 <Peaker> I'm trying to build a Map String (Set String)   mapping all substrings of /usr/share/dict/words to their words
06:54:35 <Heffalump> ivanm: the fact that it happens is crap (it does, I checked)
06:54:43 <ivanm> *nod*
06:54:46 <Heffalump> this is on an IOUArray (at least)
06:54:54 <Peaker> Many of the sets repeat, so I use "memo id :: Set k -> Set k" to re-use existing sets
06:55:48 <Peaker> Heffalump, I don't recall it did
06:55:52 <Peaker> Heffalump, I'll check now
06:56:07 <Peaker> Heffalump, But there's no way to make an IO array with IO actions, just pure functions, which sucks
06:56:15 <Heffalump> huh?
06:56:16 <Cale> Peaker: that looks like a blatant type error, btw
06:56:28 <Peaker> Cale, where?
06:56:28 <Cale> Peaker: Err...
06:56:37 <Cale> Peaker: Oh, no, it's just silly :)
06:56:40 <Cale> force
06:56:48 <Cale> force xs = foldr seq () `seq` xs
06:56:54 <Peaker> oh oops
06:56:55 <Peaker> :)
06:57:17 <Cale> and then:
06:57:18 <benmachine> evaluate "foldr seq ()" to whnf, and then return xs
06:57:26 <aristid> :t \xs -> foldr seq () `seq` xs
06:57:27 <Cale> let t = force . build $ ws
06:57:28 <lambdabot> forall t. t -> t
06:57:42 <Cale> If force was meant to operate on lists, then that would be a type error
06:57:46 <copumpkin> aristid: very useful :P
06:57:47 <benmachine> hmm I wonder
06:57:52 <aristid> copumpkin: very much so
06:58:01 <Cale> because build produces a Map
06:58:02 <copumpkin> I love forcing my partially applied functions
06:58:10 <Peaker> Cale, yeah, that's reversed :)
06:58:11 <aristid> copumpkin: me too.
06:58:11 <Cale> But force does nothing :P
06:58:12 <benmachine> @check (seq :: Int -> Double -> Double) == flip const
06:58:12 <lambdabot>   No instance for (GHC.Classes.Eq
06:58:13 <lambdabot>                     (GHC.Types.Int -> GHC.T...
06:58:13 <Peaker> Cale, It was silly
06:58:29 <Peaker> Heffalump, There's array-from-pure-list, but no array-from-listT-IO or array-from-IO-actions
06:58:33 <benmachine> er
06:58:46 <copumpkin> @check liftA2 (==) (seq :: Int -> Double -> Double) (flip const)
06:58:47 <lambdabot>   No instance for (GHC.Classes.Eq
06:58:47 <lambdabot>                     (GHC.Types.Double -> GH...
06:58:50 <Peaker> Heffalump, You can have IO [a] -- but that means you have to do the entire effect and build the entire list and only then give it to the IO array building
06:58:50 <Cale> Peaker: Is there a good reason to be strict here?
06:58:54 <benmachine> @check (\x y -> seq (x :: Int) (y :: Double) == x
06:58:55 <lambdabot>  Unbalanced parentheses
06:59:02 <benmachine> @check (\x y -> seq (x :: Int) (y :: Double) == x
06:59:02 <lambdabot>  Unbalanced parentheses
06:59:04 <benmachine> ugh
06:59:07 <benmachine> @check \x y -> seq (x :: Int) (y :: Double) == x
06:59:08 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
06:59:11 <Peaker> Cale, well, I want to see how many words can fit in my laptop's memory
06:59:13 <copumpkin> benmachine: should be y
06:59:15 <benmachine> @check \x y -> seq (x :: Int) (y :: Double) == y
06:59:16 <lambdabot>   "OK, passed 500 tests."
06:59:29 <Heffalump> Peaker: ah, right. Or use unsafeInterleaveIO
06:59:34 <Cale> Peaker: The first time you do a lookup, you're going to evaluate the Map, which is going to force the entire thing to be built anyway
06:59:42 <Peaker> Heffalump, that sucks
06:59:49 <Peaker> Heffalump, I hate unsafeInterleaveIO :)
06:59:50 <aristid> benmachine: that function isn't extremely useful either
07:00:00 <Heffalump> *shrug*
07:00:01 <Peaker> Cale, Not the sets though
07:00:04 <Heffalump> I like it.
07:00:11 <Cale> Yeah.
07:00:37 <Peaker> Heffalump, unsafeInterleaveIO is unusable in its strict sense ("effects can happen any time") and horrible when used in practice ("driven by evaluation")
07:00:54 <benmachine> aristid: wat
07:00:55 <Peaker> most use it in the horrible way, not the unusable way
07:01:39 <aristid> :t seq :: Int -> Double -> Double
07:01:40 <lambdabot> Int -> Double -> Double
07:01:49 <aristid> benmachine: you don't need a lambda for that ;)
07:01:54 <Jafet> Well, you can't use something that is unusable
07:02:14 <benmachine> aristid: makes the type annotations easier
07:02:21 <Cale> The point of unsafeInterleaveIO is to de able to have IO which is driven by evaluation of course.
07:02:32 <aristid> Jafet: of course you can use c++ *bad joke*
07:02:34 <Cale> In fact, that's a pretty good description of what it does.
07:02:36 <burp> @hoogle endsWith
07:02:36 <lambdabot> No results found
07:02:44 <aristid> benmachine: wat? ;)
07:03:08 <benmachine> aristid: wat wat.
07:03:10 <Jafet> C++ isn't unusable, it's horrible.
07:03:17 <benmachine> heh
07:03:22 <Peaker> Cale, Then why have purity in the first place, if evaluation driving IO is a good thing?
07:03:46 * hackagebot bird 0.0.11 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.11 (MattParker)
07:04:03 <Cale> Peaker: There are cases where it's useful to extend what evaluation can do.
07:04:09 <Peaker> Cale, It breaks referential transparency unless you assume effects are just happening non-deterministically
07:04:11 <jmcarthur> evaluation driving IO needn't be impure in all cases, hence the existence of unsafeInterleavIO
07:04:19 <Jafet> It's a good thing in the sense that jumping off a cliff when there are zombies running after you is a good thing.
07:04:24 <jmcarthur> *unsafeInterleaveIO
07:04:31 <Peaker> jmcarthur, That existence is purely a bad thing, IMO
07:04:50 <benmachine> purely, heh heh
07:04:55 <jmcarthur> Peaker: think of it as a way to create new language features, just like unsafePerformIO
07:04:57 <Peaker> If Haskell gave in to impurity -- the utility of Monads in this setting would not have been discovered, and the benefits of first-class actions too
07:05:01 <jmcarthur> it's not meant to be used every day
07:05:17 <Cale> Peaker: There are cases where you'd otherwise have to modify GHC, and this just helps you not have to do that.
07:05:21 <Peaker> jmcarthur, unsafePerformIO is just meant to say "This composition of impure actions is pure"
07:05:27 <Cale> Peaker: I wouldn't recommend using it lightly.
07:05:32 <benmachine> lazy readFile is useful in a lot of cases where your entire application reads exactly one file and then processes it
07:05:44 <jmcarthur> Peaker: that's what it tells the compiler. that's not a description of when it's best used
07:05:48 <Peaker> Cale, I think it's "cheating" -- rather than going the "hard way" to the discovery of the "Right" way to do it (e.g: Something like Iteratee)
07:06:06 <Cale> But it's useful to have it, along with unsafePerformIO, because there are cases where you want to be able to add new primitives to the language.
07:06:12 <Cale> For example, ByteString
07:06:18 <Peaker> Cale, and I think it postpones or even diminishes the chance that the right way to do these things will be discovered
07:06:26 <benmachine> iteratee is a headache to understand >_>
07:06:30 <Jafet> .oO( iteratees are not horrible, but I find them unusable )
07:06:41 <Peaker> benmachine, I disagree -- I found it simple, as soon as I got over the horrible names :)
07:06:48 <jmcarthur> Peaker: so you would propose that we never write pure wrappers around imperative interfaces?
07:06:54 <Peaker> "Iteratee" -> "Consumer", "Enumerator" -> "Producer"
07:07:00 <benmachine> Peaker: did you have a source other than the hoogle docs?
07:07:08 <Cale> I don't think iteratee is really the right way to do anything, but it's a matter of taste.
07:07:10 <Peaker> jmcarthur, No, unsafePerformIO in this case is fine, unsafeInterleaveIO is explicitly giving up purity
07:07:18 <Peaker> benmachine, I read some slides I think
07:07:25 <Peaker> Cale, Why not?
07:07:28 <benmachine> conceptually they're simple, sorta, but I can never find the right function to do something
07:07:43 <jmcarthur> Peaker: just like unsafePerformIO, one should only use unsafeInterleaveIO when you are certifying that it's a pure usage
07:07:44 <copumpkin> omg blasphemy from Cale, quick, pillory time!
07:07:51 <Peaker> benmachine, I think they're hairy and not quite the "right thing" yet, but they're closer than unsafeInterleaveIO
07:07:53 <Cale> Iteratee is too much of a mess to be the right thing.
07:08:00 <Peaker> jmcarthur, I have never seen a pure usage of unsafeInterleaveIO
07:08:04 <roconnor> how is unsafeinterleaveIO more unsafe than forkIO?
07:08:06 <jmcarthur> Peaker: i disagree with how the standard libraries use unsafeInterleaveIO, like getContents
07:08:27 <benmachine> the thing that *really* gets me is that the standard libraries don't provide reasonable alternatives to lazy IO
07:08:27 <Peaker> roconnor, People don't use it to get non-determinism, they use it to get visible side-effects driven by evaluation
07:08:45 <Heffalump> visible side-effects like what? Reading a file?
07:08:45 <Peaker> roconnor, if they treated it as "non-determinism" there would be no problem, but it would be completely unusable for most cases, so they wouldn't use it
07:08:48 <zygoloid> roconnor: it's more unsafe because people /rely/ on the IO being deferred until some pure value is forced
07:08:48 <Peaker> Heffalump, Yes
07:08:52 <benmachine> roconnor: you still can't make pure computation have IO effects with forkIO
07:08:55 <Peaker> Heffalump, Reading a file depends on the handle state
07:09:20 <Cale> I like getContents, to be honest.
07:09:20 <Peaker> jmcarthur, getContents isn't pure
07:09:22 <roconnor> benmachine: can you with unsafeInterleaveIO?
07:09:35 <Peaker> jmcarthur, If it were, you could refactor pure code in equational ways -- but getContents breaks that
07:09:39 <Heffalump> Peaker: doing computation depends on available memory
07:09:40 <zygoloid> roconnor: (unsafeInterleaveIO == forkIO + waitForPureValueToBeForced)
07:09:46 <Cale> hGetContents has limited application, but things like readFile are often fine.
07:09:47 <Peaker> jmcarthur, Things that ought to be equal become unequal when mixed with getContents
07:09:52 <jmcarthur> Peaker: i just said i disagree with getContents
07:09:55 <roconnor> I think of lazyIO as a form of non-determinism
07:09:56 <benmachine> roconnor: unsafeInterleaveIO can make the strictness properties of pure code affect whether or not IO takes place, yes
07:09:58 <Peaker> jmcarthur, ah, misunderstood you
07:09:59 <zygoloid> (ok, only /approximately/ ;-)
07:10:06 <Peaker> jmcarthur, sorry
07:10:18 <jmcarthur> Peaker: bad use of unsafeInterleaveIO does not make unsafeInterleaveIO bad to have
07:10:22 <roconnor> benmachine: I don't see what this is more unsafe.
07:10:31 <Peaker> jmcarthur, What uses of unsafeInterleaveIO aren't bad?
07:10:38 <Heffalump> Peaker: "Things that ought to be equal". Are you thinking of Oleg's examples here?
07:10:42 <jmcarthur> Peaker: i have an alternative to unsafePerformIO here http://hackage.haskell.org/packages/archive/procrastinating-structure/1.0.1/doc/html/Data-PVar-Structure.html
07:11:12 <Peaker> Heffalump, No, I actually had bugs in my own code, due to innocent refactorings that ought not to affect the program
07:11:22 <jmcarthur> Peaker: the queue interface i include in the same package could have been written with unsafeInterleaveIO as well, and it would have been just as pure
07:11:27 <Heffalump> I think you might have been assuming a bit too much about the semantics of IO here.
07:11:27 <benmachine> Peaker: what about mfix on IO?
07:11:31 <Peaker> Heffalump, The "fun" of Haskell, where I can move things around with a *guarantee* the code will have the same semantics, break
07:11:40 <benmachine> although admittedly I don't really know what that is for
07:11:51 <Peaker> benmachine, I don't know, I've never used it/seen it used
07:12:03 <Peaker> Heffalump, I refactored only pure code
07:12:23 <jmcarthur> well, admittedly, the unsafeInterleaveIO version would have been a lot harder to write, too
07:12:24 <Peaker> Heffalump, This is the part that you should be able to do without worrying about any IO in the program
07:13:16 <jmcarthur> Peaker: if unsafeInterleaveIO is being used correctly, you should still be able to do those refactorings
07:13:25 <Peaker> Heffalump, You could say the code was broken in the first place -- assuming things about when the effects of "unsafeInterleaveIO" actually happen -- but virtually all code that uses unsafeInterleaveIO is broken in this way
07:13:58 <jmcarthur> Peaker: earlier i meant to say i have an alternative to unsafeInterleaveIO, not unsafePerformIO
07:14:01 <Peaker> I had an argument about it with dcoutts, where he said you mustn't assume when it happens, and then on Reddit, he gave some newbie advice about how to use unsafeInterleaveIO in exactly this way :(
07:14:38 <Peaker> jmcarthur, What's the procrastination package? :)
07:15:48 <jmcarthur> Peaker: let's you create pure values that are not defined until you set them later in IO. if you evaluate them before they are set, they are _|_ (and will be forever), otherwise they are the value you assigned them. the structures package takes that concept and allows you to create arbitrary structures incrementally
07:16:45 <Peaker> jmcarthur, when do you use this?
07:16:49 <roconnor> benmachine: I think of fixIO as a primitive.  GHC happens to implement it using unsafeInterleaveIO, but that's okay, because GHC knows how it's own internal system works.
07:17:03 <zygoloid> why does ivar-simple use unsafePerformIO rather than unsafeInterleaveIO?
07:17:18 <jmcarthur> Peaker: i've used it in some FRP research
07:17:52 <Peaker> except for unsafePerformIO for pure compositions of impure actions, I'm not sure why I'd want simple-semantic pure-values to hide behind them IO semantics (potential failures, etc)
07:18:24 <jmcarthur> are you speaking of my package or are you back on unsafeInterleaveIO?
07:18:35 <Peaker> Cale, btw: It would make more sense for readFile to have type:  [Either IOError String] or such to be less problematic (even then it has a file handle leakage problem)
07:19:32 <Peaker> jmcarthur, I mean anything that allows breaking RT (except the one use I understand the utility of)
07:20:00 <roconnor> IMHO readFile doesn't break RT any more than forkIO does
07:20:08 <jmcarthur> Peaker: here is the main use i have had for it: say i want a pure value that represents something that changes over time (say, something like a list where time is monotonically increasing as you move toward the tail). the idea is pure, but the implementation necessarily is not
07:20:09 <roconnor> which is not at all
07:20:18 <Heffalump> Peaker: asynchronous exceptions (e.g. signals, throwTo from another thread) can affect pure code from IO in just the same way.
07:20:27 <dolio> readFile definitely doesn't break referential transparency.
07:20:40 <Peaker> roconnor, It doesn't, except for the visibility of file handle usage. But it hides the error semantics of the underlying layer
07:20:40 <jmcarthur> Peaker: well, i mean, where its value comes from the real world (as opposed to from a generating function)
07:21:03 <Cale> Peaker: readFile is meant for cases where the file isn't going to stop existing or change as long as the program runs.
07:21:34 <Peaker> jmcarthur, Does reading the list drive effects, or would the list be the same no matter what evaluation goes on?
07:21:39 <Cale> Peaker: Sure, there are lots of stupid things which *might* happen to a file, but it's often the case that you really don't care.
07:21:46 <jmcarthur> Peaker: the latter
07:22:00 <Peaker> Heffalump, Not in the same way -- it's not driven by evaluation, so it doesn't expose evaluation order
07:22:22 <Peaker> Cale, You always care enough to be able to at least say what the error that happened was
07:22:27 <Cale> Nope.
07:22:30 <Peaker> Cale, and not mistake an error for an EOF
07:22:34 <benmachine> Heffalump: it's not so much IO affecting pure code as the other way around that is the problem
07:22:51 <jmcarthur> Peaker: the simple rule is that if you read farther down the list then has been defined then it's just _|_, which is a perfectly pure result
07:22:57 <jmcarthur> *than has been defined
07:22:59 <Peaker> Cale, I personally would prefer Haskell to be associated with high-quality programs :) Not ones that ignore errors or mistake errors for EOF
07:23:04 <Cale> I disagree. There are a lot of programs where if the file isn't there, I don't care what the behaviour of the program is.
07:23:26 <Peaker> Cale, Can you give some examples of such programs?
07:23:29 <Cale> (Because I'm going to make sure that it's there)
07:23:31 <jmcarthur> personally, i'm with peaker on file IO
07:24:05 <benmachine> Cale: how many of these examples wouldn't be served by a strict readFile?
07:24:08 <jmcarthur> i have used unsafeInterleaveIO to cheat on one-shot scripts and stuff, but i would not feel very good releasing code that uses it for file i/o
07:24:39 <Cale> One-shot scripts are useful!
07:24:44 <Peaker> I think Iteratee seems nearly as usable as unsafeInterleaveIO, and with just a little more work on integration/libs/usability -- it would become just as easy, but with much nicer semantics
07:24:45 <jmcarthur> i agree
07:24:52 <thingie`> even in my quick scripts i avoid partial functions like head and fromJust
07:25:15 <jmcarthur> thingie`: i only avoid them when i haven't certified that the value is not empty
07:25:39 <Peaker> I think lots of other languages hit the side-effect difficulty -- allowed it to be driven by evaluation with all sorts of excuses -- and thus managed to avoid discovery of Haskell's interesting IO system
07:25:47 <Peaker> And now Haskell is doing the same thing with "lazy I/O"
07:25:58 <Peaker> Instead of discovering nicer ways to do it
07:26:21 <Cale> Peaker: I'll be happy to use something better if someone invents it :)
07:26:31 <Cale> Iteratee is really ugly though.
07:26:37 <Peaker> Cale, I agree it's a little ugly
07:26:39 <benmachine> Cale: do you just mean APIwise?
07:26:40 <jmcarthur> it truly is
07:26:48 <Peaker> but I don't think it's inherently ugly
07:27:03 <Peaker> continuation-based stream I/O handling sounds like it could be pulled off elegantly
07:27:12 <thingie`> jmcarthur: i try to engineer so that i don't have to certify it. e.g. catMaybes vs map fromJust . filter isJust
07:27:17 <Cale> I haven't seen an implementation of Iteratee which had any amount of "universality" to it.
07:27:39 <benmachine> universality?
07:28:00 <jmcarthur> thingie`: sure. but something you just know that a list isn't empty without having to go through extra steps like in your example
07:28:02 <Cale> This is not to say that unsafeInterleaveIO is anything you'd find in a mathematics textbook, but unsafeInterleaveIO is obviously meant to be a bit of a hack :)
07:28:05 <jmcarthur> *sometimes
07:28:19 <thingie`> > map ((*5) . fromJust) . filter isJust $ [Just 2,Just 5]
07:28:19 <thingie`> > catMaybes . map (>>=(*5)) $ [Just 2,Just 5]
07:28:20 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
07:28:20 <lambdabot>    arising from a use of...
07:28:21 <lambdabot>   [10,25]
07:28:33 <thingie`> ehh fmap
07:29:29 <jmcarthur> thingie`: i meant the "worse" version of your code was longer than necessary in order to make sure you didn't use fromJust on Nothing. sometimes you just know already that none of the elements are Nothing
07:29:48 <thingie`> jmcarthur: sure that's true
07:30:04 <thingie`> jmcarthur: but that makes your code less general, no?
07:30:20 <jmcarthur> thingie`: if you know it then you know it
07:30:21 <thingie`> jmcarthur: suppose you later use that function on what you think is a checked list of Justs, and kaboom?
07:30:39 <jmcarthur> thingie`: if this is a very top level function then yeah
07:30:44 <benmachine> a good place to use fromJust: lookup on an infinite list?
07:30:48 <Peaker> I've got a fully-forced Map String (Set String) -- and looking it up and printing the content of a key seems to take a noticeable amount of time
07:30:55 <jmcarthur> thingie`: but if it's just a where clause and the list comes from elsewhere in the function...
07:31:05 <benmachine> of course you could write your own lookup function but you know whatever
07:31:37 <Peaker> There's just 82000 keys in the map
07:31:51 <benmachine> Peaker: what are the keys like?
07:32:00 <Peaker> benmachine, substrings of words from /usr/share/dict/words
07:32:01 <aristid> @hoogle readM
07:32:01 <lambdabot> Trace.Hpc.Mix readMix :: [String] -> Either String TixModule -> IO Mix
07:32:02 <lambdabot> System.IO ReadMode :: IOMode
07:32:02 <lambdabot> Control.Concurrent.MVar readMVar :: MVar a -> IO a
07:32:06 <jmcarthur> Peaker: sounds like a job for a trie?
07:32:14 <Peaker> jmcarthur, I tried a Trie, it was too big for my heap
07:32:20 <jmcarthur> ew
07:32:32 <jmcarthur> wait... how does that happen?
07:32:41 <jmcarthur> Trie too big but Map String not?
07:33:16 <thingie`> good question
07:33:49 <thingie`> Peaker: can we see the trie implementation?
07:34:30 <jmcarthur> could always go for a hash table. they are working well nowadays if you don't mind ST or IO
07:34:34 <jmcarthur> :)
07:34:47 <Cale> I think part of what I don't like about Iteratee is the explicit chunking. That seems to me like something which should be hidden by a module boundary, and not exposed to the users of the library, but it's pretty fundamental to the way that existing Iteratees work.
07:34:48 <thingie`> Data.Map is strict in its type constructor
07:34:49 <Peaker> thingie`, Yeah, just a sec
07:34:57 <thingie`> did you make your tree strict in this way?
07:35:00 <thingie`> trie
07:35:38 <thingie`> (imagines layers of flabby laziness rippling all over your heap)
07:35:39 <benmachine> Cale: I think there are some cases for which explicit chunking is obviously necessary, and for those cases where it isn't you can often get by not using it
07:36:11 <Heffalump> Peaker: so what kind of refactor did you do that went wrong?
07:36:27 <Peaker> For:  newtype Trie v = Trie { unTrie :: (v, IntMap (Trie v)) }    this should be right: instance NFData v => NFData (Trie v) where rnf (Trie (v, m)) = rnf v `seq` rnf m `seq` ()   right?
07:36:29 <roconnor> I pretend that readFile is simply a nondeterministic read, and that would be the formal semantics I would give it.
07:36:39 <Peaker> Heffalump, Moved something which caused it to be evaluate after the close of a file rather than before
07:36:49 <benmachine> Cale: I'd imagine most iteratees would be made by composing "primitive" iteratees
07:36:56 <benmachine> and only the primitives need to know about that sort of thing
07:37:00 <Peaker> roconnor, my problem with it is: A) leaking file handles B) bad error handling semantics
07:37:14 <Heffalump> why was the file being explicitly closed?
07:37:48 <roconnor> Peaker: forkIO has the same issues?
07:38:05 <Peaker> roconnor, why?
07:38:22 <Peaker> thingie`, I didn't make my Trie strict, here it is: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28438#a28438  -- the problem now (as I truncate the size of the words list) is that I can't get deepseq to force it all the way through
07:38:35 <Peaker> thingie`, only when lookup is used, it tries to "read n", which shows it didn't really deepseq it at all
07:38:43 <roconnor> Peaker: if I do forkIO closeHandle, who knows when and if that will ever get executed.
07:38:49 <thingie`> hmm
07:39:11 <Peaker> roconnor, but that won't expose the evaluation order of your program
07:39:34 <Peaker> roconnor, Also, forkIO can be used to cause A, but it doesn't inherently cause A
07:39:45 <Peaker> roconnor, I don't see how it causes B at all?
07:40:52 <roconnor> Peaker: Focusing on A for the moment, If I wrote a blocking readFile where the file data is handled by a Chan, how would I ensure that the file handle gets close after the EOF?
07:40:54 <Peaker> Heffalump, I don't recall why -- I think maybe it was reading/writing to the same file in-place
07:41:12 <darq> hello. can somebody tell me how to get this working. http://pastie.org/1068531  I generate random numbers and try to use them in a function but the IO Float - Float part doesnt work
07:41:13 <roconnor> Peaker: it could be that just before I close the handle my thread gets suspended for 10000 years
07:41:27 <Peaker> roconnor, you could assume it was closed only after the last read returned to indicate it was
07:42:12 <Peaker> darq, you can use createInfo ((x, y):xs) = ... instead of fst/snd there.
07:42:18 <Peaker> darq, or uncurry
07:42:42 <Peaker> darq, randomFloat is an IO action that makes a float, not a float, Info wants a Float as third argument
07:42:47 <Cale> darq: Your problem is that randomFloat is not a Float. It's an IO action which when executed will produce a Float.
07:42:56 <roconnor> Peaker: I see.  But if you interface on the main thread just was a chan of Maybe chars, then there would be no way to know.
07:43:01 <benmachine> darq: what type do you want createInfo to have?
07:43:08 <roconnor> Peaker: so the problem with readFile is it has a bad interface
07:43:14 <Peaker> roconnor, What does Nothing indicate?
07:43:24 <Cale> darq: So, you could have createInfo produce an IO action which will run randomFloat
07:43:36 <roconnor> Peaker: same thing as [] indicates with readFile.
07:43:56 <Peaker> roconnor, Another problem is that it exposes evaluation order
07:44:15 <Heffalump> Peaker: if you're doing that, then IMO unsafeInterleaveIO really is inappropriate.
07:44:45 <benmachine> Cale: btw, example of using iteratees while being ignorant of chunking: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28439#a28439 (if anyone would like to explain to me why this is slow, that'd be great)
07:45:02 <Cale> darq: There is the criticism that  createInfo :: [Int] -> IO InfoData  is a bit more general a type than you might want -- even though we know all it does is use some random numbers, it looks like it could do any IO at all then.
07:45:20 <roconnor> Peaker: If you specify the semantics of readFile as a nondeterministic read, then there is no exposure given by the semantics.
07:45:37 <Peaker> roconnor, Then it also becomes kind of useless :)
07:45:46 <roconnor> Peaker: I don't think so
07:45:47 <Peaker> roconnor, Why would you want a non-deterministic read when you can have a deterministic one?
07:46:04 <roconnor> Peaker: because it is very simple to use
07:46:12 <Cale> darq: So possibly a better option would be  createInfo :: StdGen -> [Int] -> InfoData
07:46:20 <roconnor> I only use it in cases where I'd find a nondeterministic read acceptable
07:46:31 <dolio> Because you don't care about the differences between the various cases it's nondeterministically choosing from.
07:46:33 <Peaker> roconnor, It is "simpler" also because it hides the non-nominal cases you would want to handle, hides error cases, etc
07:47:07 <Peaker> roconnor, dolio: If I ran a program that hid errors it encountered under the hood, I'd be angry and probably avoid programs from the same author
07:47:09 <roconnor> Peaker: so I admit I'm ignorant about the error semantics of readFile.
07:47:53 <darq> Cale: could you write this IO action please.. im new to monads :(
07:47:57 <roconnor> I assume it sticks a bottom in the string at the appropriate point
07:48:00 <Cale> darq: Sure
07:48:21 <zygoloid> createInfo xs = zipWith (uncurry Info) xs . randomRs (-1, 1)
07:48:23 <zygoloid> ;-)
07:48:24 <Peaker> I like Haskell for real-world engineering because it encourages high-quality software... I think non-determinism (where it isn't necessary) and bad error semantics encourage low-quality software
07:48:35 <Peaker> roconnor, I'm pretty sure it sticks a []
07:48:39 <roconnor> gah!
07:48:47 <roconnor> okay, that is terrible
07:48:50 <roconnor> ish
07:49:02 <Cale> darq: So first let's write createInfo :: (Int,Int) -> IO InfoData
07:49:45 <Cale> createInfo (x,y) = do v <- randomRIO (-1,1); return (Info x y v)
07:50:11 <Cale> and now,  mapM createInfo :: [(Int,Int)] -> IO [InfoData]
07:50:19 <Cale> which is probably what you're actually after
07:51:12 <Peaker> Does this seem right? "rnf (Trie (v, m)) = rnf v `seq` rnf m `seq` ()"
07:51:30 <dolio> Yes.
07:51:39 <benmachine> Peaker: rnf v `seq` rnf m would be fine too wouldn't it?
07:51:50 <Peaker> benmachine, the type has to be  "a->()"
07:51:55 <benmachine> yep
07:51:56 <Peaker> oh, right :)
07:51:57 <benmachine> and?
07:51:59 <benmachine> :)
07:52:14 <benmachine> come to think of it, what about rnf (Trie x) = rnf x
07:52:34 <Peaker> benmachine, yeah, should work
07:52:43 <Peaker> but it seems like deepseq isn't deep-seq'ing at all
07:52:51 <roconnor> Peaker: I see nothing in the Haskell 98 report requiring readFile to return [] on error
07:53:06 <roconnor> Peaker: sounds like it is a bad design choice of GHC
07:53:30 <Peaker> roconnor, An imprecise exception isn't very nice either :)
07:53:37 <Peaker> Though it is saner indeed
07:53:57 <Peaker> A precise exception is the best option.. At least put the potential error in the type somewhere
07:54:27 <roconnor> Peaker: In theory I would only use readFile in little scripts.
07:54:48 <benmachine> roconnor: http://www.haskell.org/onlinereport/haskell2010/haskellch41.html#x49-33700041.5
07:55:05 <benmachine> "Any I/O errors encountered while a handle is semi-closed are simply discarded. "
07:55:22 <roconnor> oh great
07:55:30 <roconnor> where is the retarded trac that specified that?
07:55:37 <benmachine> heh
07:56:34 <benmachine> interestingly it seems System.IO.Unsafe isn't in haskell2010 libs
07:56:44 <benmachine> so lazy IO is effectively primitive
07:56:55 <benmachine> (unless it's somewhere else, dunno)
07:57:11 <Peaker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28440#a28440
07:57:19 <Peaker> Can anyone help me see why deepseq isn't doing anything?
07:57:44 <roconnor> benmachine: god damn it, I don't see a trac ticket
07:57:51 <roconnor> they just changed it for the hell of it?
07:58:18 <Peaker> roconnor, Maybe you can see the commit msg that changed this?
07:58:25 <benmachine> roconnor: it was changed?
07:58:45 <roconnor> oh
07:58:55 <Cale> roconnor: Well, it's what GHC does, and I think hugs as well. Isn't the job of the standard to document what the implementations do? ;)
07:58:55 <roconnor> maybe I was looking in the wrong place in the 98 report
07:58:57 <Peaker> oh, I think I found my bug
07:59:06 <benmachine> roconnor: yeah, looks like it was there in h98
07:59:08 <benmachine> http://haskell.org/onlinereport/io.html
07:59:23 <benmachine> (semi-closed handles)
07:59:30 <roconnor> ah
07:59:31 <roconnor> oh good
07:59:39 <roconnor> so let's change it for Haskell 2011 :P
08:00:31 <darq> thx Cale.  but now my InfoData is IO InfoData :) Is there a way to get rid of IO ?
08:00:57 <Cale> darq: Well, the IO InfoData is an IO action which when run will construct you an InfoData value.
08:01:07 <Cale> darq: You can only run it from inside another IO action.
08:01:11 <Cale> (by design)
08:01:50 <darq> hmm.. is there any way of pure randomness?
08:01:58 <darq> i mean without IO
08:01:58 <Cale> darq: Of course, it's not an InfoData value itself, because the intention is that it produces a different InfoData value every time.
08:02:08 <Cale> darq: You can use StdGen values.
08:02:25 <Cale> darq: A value of type StdGen represents the state of a random number generator
08:03:04 <arjanb> -+
08:03:05 <Cale> You could have  createInfo :: StdGen -> [(Int,Int)] -> [InfoData]
08:03:32 <Cale> But of course, this will mean that you need to get a StdGen from somewhere to use it
08:03:59 <Peaker> darq, not pure randomness (because purity dictates determinism, and randomness is non-determinism), but you can have pure pseudo-randomness. Or pure randomness if you can feed the pure computation some random input
08:04:06 <Cale> mkStdGen can be used with a fixed seed, but of course, that'll result in the same "random" data every time
08:04:33 <Cale> newStdGen :: IO StdGen is the usual way to get one
08:04:56 <Cale> You get a StdGen using newStdGen at the top-level of your program, and pass it down to where it's needed.
08:06:59 <Peaker> System.Random is way too lazy :(
08:07:42 <darq> This is a litle complicated :)  i just wanted a pseudo random float :D
08:11:04 * roconnor wants a random CReal
08:11:55 * vanadium wants a fruit cereal
08:11:58 <dolio> Yeah, how do you do those? Call split and keep a random generator for yourself?
08:13:18 <Gracenotes> roconnor: I can give you one in the range [0, 1]. that's good enough, right
08:14:21 <roconnor> Gracenotes: sure, I can just take the arc hyperbolic tangent of something like that.
08:14:59 <Gracenotes> that would create an interesting distribution
08:16:00 <Gracenotes> I would describe it in more detail, but it'd just be monotonous
08:17:56 <Peaker> darq, Then use pure pseudo-random generation
08:18:03 <Peaker> @hoogle randoms
08:18:04 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
08:18:42 <Peaker> darq, You can use "randoms" to make the random numbers, then use (map (InfoData x y)) on the result list
08:19:13 <Peaker> darq, the only need for "IO" is if you want real-random as opposed to pseudo-random
08:19:55 <darq> Peaker: could you write this line or two .pls
08:22:45 <Peaker> darq, createInfo pseudoRandomGenerator xs = zipWith ($) (map (uncurry Info) xs) (randoms pseudoRandomGenerator)
08:22:59 <Peaker> darq, is this for homework? :)
08:26:26 <Peaker> @type map . uncurry
08:26:27 <lambdabot> forall b a b1. (a -> b1 -> b) -> [(a, b1)] -> [b]
08:27:12 <Peaker> left-associative $ would be nice for map . uncurry $ x $ y
08:28:07 <hpc> :t (<$)
08:28:08 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:31:33 <aristid> :t \x y -> ((map . uncurry) x) y
08:31:34 <lambdabot> forall a b c. (a -> b -> c) -> [(a, b)] -> [c]
08:31:48 <aristid> :t \x y -> (map . uncurry) x y
08:31:49 <lambdabot> forall a b c. (a -> b -> c) -> [(a, b)] -> [c]
08:32:06 <aristid> Peaker: in this case at least i think parens are fine :)
08:32:38 <Peaker> aristid, I like paren-genocide :)
08:33:48 <darq> Peaker: no its not.. i started haskell on my own
08:34:09 <aristid> Peaker: too many parens are ugly, but when you need more operators than you would need parens ... ;)
08:36:06 <Peaker> darq, do you understand partial application?
08:36:56 <Peaker> darq, let's analyze the solution i pasted bit by bit?
08:37:35 <darq> Peaker: no i get it.. i saw that Test.QuickCheck got some random generator.. is this without moands?
08:38:33 <Peaker> darq, Without IO.. "monads" are not really relevant to any of this :)
08:38:53 <Peaker> darq, The question is whether the solution involves IO (to get a real random generator) or not (in which case it is just pseudo random)
08:39:20 <hpc> darq: how long have you been using haskell? it's a common fallacy of new users to think of monads as magic, or at least more special than they really are
08:39:22 <darq> pseudo random ok.. 
08:39:41 <hpc> and in this case, monads really aren't relevant
08:39:41 <darq> about 3 months :)
08:40:32 <hpc> yeah, learn functor and applicative first; monads will be quite straightforward then
08:41:16 <Phyx-> monads aren't magic?
08:41:25 <Phyx-> what are you saying...
08:41:28 <darq> :D
08:41:51 <aristid> hpc: maybe they would be easier to learn, if... join was a class method
08:42:40 <hpc> aristid: i thought it was...
08:42:45 <hewei> Please recommend some links to functor/applicative, thanks! 
08:42:56 <darq> can someone give an example of using QuickCheck .. to generate a float between -1 and 1
08:43:14 <hpc> @where lyah
08:43:14 <lambdabot> http://www.learnyouahaskell.com/
08:43:18 <hpc> hewei: ^
08:43:31 <hewei> Thanks! 
08:43:38 <benmachine> typeclassopedia?
08:44:10 <hpc> typeclassopedia isn't as penetrable as lyah, imo
08:44:17 <benmachine> oh, sure
08:44:22 <benmachine> but it's more detailed
08:44:24 <aristid> hpc: join is definitely not a class method
08:44:29 <aristid> @src join
08:44:29 <lambdabot> join x =  x >>= id
08:44:37 <aristid> hpc: it's defined in terms of >>=
08:44:40 <aristid> @src liftM
08:44:41 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:44:46 <hpc> @src (==)
08:44:46 <lambdabot> x == y = not (x /= y)
08:44:52 <benmachine> heh
08:44:53 <hpc> aristid: ^ :P
08:45:08 <benmachine> in general @src is not an authority
08:45:18 <aristid> hpc: well, join is really not a class method. try :info Monad
08:45:37 <aristid> in your ghci
08:45:44 <aristid> which IS an authority :P
08:45:46 <Peaker> join and (>>=) could both be implemented in terms of each other (>>= also needs fmap though)
08:46:13 <hpc> :t fmap
08:46:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:46:15 <hpc> :t liftM
08:46:16 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:46:34 <aristid> Peaker: yeah. i think it would be best to have both as class methods, and then it would be possible to explain Monads in terms of join without hand-waving
08:46:43 <hpc> yeah
08:47:14 <benmachine> I wonder if there are interesting things with which you can implement <*>
08:47:34 <hpc> :t (<*>)
08:47:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:47:43 <Peaker> aristid, I think (>>=) is fundamentally as complex as fmap+join, and that join is really simpler, so join should just be the method
08:47:58 <benmachine> (that are currently implemented in Applicative terms, I mean)
08:48:09 <benmachine> Peaker: >>= is more useful though, arguably
08:48:11 <Peaker> benmachine, liftA2 ($)
08:48:12 <hpc> :t ((return f) >>=)
08:48:12 <lambdabot> forall a (m :: * -> *) b. (SimpleReflect.FromExpr a, Monad m) => (a -> m b) -> m b
08:48:14 <aristid> Peaker: well, for performance reasons it might be better to have a direct >>=
08:48:21 <benmachine> :t liftA2 id
08:48:22 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
08:48:25 <Peaker> benmachine, well, (>>=) would still exist
08:48:31 <b0fh_ua> Hello again! How can I fix the problem with the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28442#a28442 ?
08:48:34 <Peaker> aristid, I would hope that doesn't really matter
08:48:38 <hpc> :t \f g -> ((return f) >>=) (return . g)
08:48:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => a -> (a -> b) -> m b
08:48:40 <b0fh_ua> I;m not sure what is wrong there with types
08:48:42 <benmachine> Peaker: yes but the point is it is more useful so it should be more efficient
08:48:46 <Peaker> aristid, a compiler should be able to just inline (>>=) to get the direct impl.
08:49:00 <benmachine> hpc: implementing <*> with monad things is boring
08:49:12 <benmachine> @src ap
08:49:12 <lambdabot> ap = liftM2 id
08:49:13 <Peaker> benmachine, Typically (>>=) implemented directly would just involve manually inlining fmap into join :)
08:49:13 <dolio> Turning join . fmap f into (>>= f) is deforestation.
08:49:24 <benmachine> Peaker: typically.
08:49:25 <Peaker> benmachine, surely the compiler can also inline
08:49:32 <Phyx-> @hoogle 0x80004005 
08:49:32 <lambdabot> Parse error:
08:49:32 <lambdabot>   --count=20 "0x80004005 "
08:49:32 <lambdabot>              ^
08:49:35 <benmachine> it can, but does it?
08:49:38 <Phyx-> @google 0x80004005 
08:49:39 <lambdabot> No Result Found.
08:49:45 <Phyx-> @google 0x80004005 E_FAIL
08:49:45 <lambdabot> No Result Found.
08:49:47 <Phyx-> boo
08:49:49 <Peaker> benmachine, I wouldn't want implementation concerns to pollute my type-classes
08:50:08 <Peaker> benmachine, surely many things can have specialized efficient implementations.. that's what compilers/rewrite rules are for
08:50:11 <hpc> :t ap
08:50:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:51:01 <benmachine> Peaker: I think with e.g. State, >>= can be easier to write than join, as well
08:51:04 <dolio> So writing a RULE for every monad you write is better than defining (>>=)?
08:51:08 <benmachine> it's a more natural idea
08:51:08 <Peaker> base 4 and GHC-6.12 already broke a bunch of stuff. how hard would it really be to make Monad be a subclass of Applicative with either join or (>>=) being implementable?
08:52:03 <hpc> applicative monads would be nice
08:52:14 <hpc> it would completely sidestep the liftM/A crap
08:52:28 <Peaker> hpc, >> would be applicative too
08:52:28 <benmachine> b0fh_ua: just a thought, are you aware that <$> associates to the left? it's unusual to use it twice in the same expression, I think
08:52:38 <benmachine> :t (*>)
08:52:38 <hpc> :t (>>)
08:52:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:52:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:52:45 <hpc> that it would
08:53:01 <Gracenotes> I think you'll find the main obstacle to haskell's mass adoption is the lack of idiom brackets
08:53:03 <hpc> :t ($>)
08:53:03 <lambdabot> Not in scope: `$>'
08:53:05 <dolio> (>>=) is a conceptually fundamental operation, too. It's substitution for the conceptual syntax tree.
08:53:16 <hpc> :t (<$)
08:53:17 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:53:17 <dolio> You substitute expressions for variables.
08:53:19 <Peaker> without wrap/unwrap: State >>=:  act >>= f = \s -> let (s', r) = act s in f r s      and State join:   join act = \s -> let (s', r) = act s in r s'
08:53:32 <Peaker> benmachine, it seems join is easier with State too
08:53:39 <benmachine> Gracenotes: you can get idiom-bracket quasiquoters
08:53:40 <hpc> @src (<$)
08:53:40 <lambdabot> (<$) = (<$>) . const
08:53:44 <benmachine> they look a bit ugly though
08:53:46 <hpc> bleh
08:53:47 <Gracenotes> :t (<*)
08:53:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:53:51 <dolio> And join is the special case where your 'variables' are themselves expressions.
08:54:43 <Peaker> @pl act >>= f = \s -> let (s', r) = act s in f r s 
08:54:43 <lambdabot> (line 1, column 11):
08:54:44 <lambdabot> unexpected "="
08:54:44 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
08:54:55 <benmachine> Gracenotes: but it's easier to understand what State s a -> (a -> State s b) -> State s b is doing as opposed to State s (State s a) -> State s a
08:55:02 <Peaker> @pl bind act f s = let (s', r) = act s in f r s'
08:55:02 <lambdabot> (line 1, column 14):
08:55:02 <lambdabot> unexpected "="
08:55:02 <lambdabot> expecting variable, "(", operator or end of input
08:55:03 <benmachine> so I claim anyway
08:55:20 <hpc> @pl \act f -> \s -> let (s', r) = act s in f r s 
08:55:20 <lambdabot> (line 1, column 21):
08:55:20 <lambdabot> unexpected "("
08:55:20 <lambdabot> expecting "()", natural, identifier or "in"
08:55:30 <Peaker> no "let" in @pl apparently
08:55:36 <hpc> @pl \act f s -> let (s', r) = act s in f r s 
08:55:37 <lambdabot> (line 1, column 17):
08:55:37 <lambdabot> unexpected "("
08:55:37 <lambdabot> expecting "()", natural, identifier or "in"
08:56:09 <benmachine> @ pl \act f s -> uncurry (flip f) (act s)
08:56:13 <benmachine> er
08:56:15 <Gracenotes> benmachine: yes. monads for me are very much connected to the notion of enhanced computations
08:56:27 <Gracenotes> join doesn't make that much else in most common uses of them
08:56:35 <Gracenotes> *sense
08:56:37 <benmachine> @pl \act f s -> uncurry (flip f) (act s)
08:56:38 <lambdabot> flip ((.) . uncurry . flip)
08:56:48 <hpc> the only use of join i experience with any frequency is [[a]]
08:57:10 <Gracenotes> I never call it join
08:57:56 <benmachine> I tend to only use join when I screwed up somewhere else and used fmap instead of (=<<) >_>
08:58:02 <Peaker> Gracenotes, I think it's better to let go of the "idea of a monad" you have (computational or container) and just embrace the mathematical structure that it is
08:58:12 <Peaker> Gracenotes, in the mathematical structure, "join" makes sense
08:59:02 <Peaker> also, I guess "join" makes sense in the computational context too (execute a computation that yields a computation, then execute that too
08:59:14 <Peaker> Without the intermediate "a" and "a -> next computation" step
08:59:20 <byorgey> Peaker: you have to be able to shift between both, while constantly updating your "idea".  otherwise you will never get anything done.
08:59:45 <Gracenotes> the application programming way of thinking isn't that different, regardless of what programming language you're in: you have to explore your problem space.
08:59:46 <Peaker> byorgey, Or you transcend behind the grasp of an idea to playing with abstract notions or just symbols :)
09:00:03 <hpc> :t (f >>= f)
09:00:04 <lambdabot> forall (m :: * -> *) a b. (SimpleReflect.FromExpr (m a), Show a, SimpleReflect.FromExpr (m b), Monad m) => m b
09:00:13 <Gracenotes> as for the abstract math way of thinking, that's a different kind of space
09:00:13 <Peaker> :t join (>>=)
09:00:14 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
09:00:14 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
09:00:14 <lambdabot>     In the first argument of `join', namely `(>>=)'
09:00:23 <Gracenotes> but haskell brings a lot of overlap between them
09:00:28 <hpc> o.O
09:00:38 <hpc> :t \f -> (f >>= f)
09:00:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
09:00:39 <lambdabot>     Probable cause: `f' is applied to too many arguments
09:00:39 <lambdabot>     In the second argument of `(>>=)', namely `f'
09:00:48 <Peaker> hpc, that's join (>>=)
09:00:58 <hpc> so how did my first one work?
09:01:03 <Gracenotes> f is polymorphic
09:01:11 <hpc> ah
09:01:14 <byorgey> hpc: f is specially defined in lambdabot
09:01:19 <byorgey> :t f
09:01:20 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:01:22 <Gracenotes> it's a very open-ended typeclass
09:01:26 <hewei> :t f
09:01:27 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:01:40 <Gracenotes> :t f f f f f f f f f f f f f f 
09:01:41 <lambdabot>     Ambiguous type variable `a' in the constraints:
09:01:41 <lambdabot>       `SimpleReflect.FromExpr a'
09:01:41 <lambdabot>         arising from a use of `f' at <interactive>:1:2
09:02:00 <Gracenotes> hm I don't exactly feel like adding annotations
09:02:39 <hewei> @where lyah
09:02:40 <lambdabot> http://www.learnyouahaskell.com/
09:03:14 <Gracenotes> anyway, thinking of monads as computations is my way of using them to solve problems. a computation that can fail? maybe. fail with a value? either. enhanced with global state? reader. etc.
09:03:44 <Gracenotes> this is probably particular to the kinds of programs I'm writing
09:04:54 <b0fh_ua> benmachine: well, it was working well until I started to redesign types :)
09:05:38 <benmachine> b0fh_ua: heh, it happens
09:05:54 <benmachine> but as far as I can tell f <$> g <$> x = (f <$> g) <$> x = f . g <$> x
09:06:10 <b0fh_ua> however I don't see any problem in the code, except ghc considers it to use different types
09:06:51 <b0fh_ua> benmachine: okay, but replacing first <$> with . doesn't solve the problem :(
09:07:20 <benmachine> b0fh_ua: no but it makes it more legible, I think
09:07:27 <b0fh_ua> okay :)
09:07:51 <hewei> Gracenotes: When I want it to maintain some states, I would consider StateT, but different parts of the program do not have the same type of state. 
09:07:55 <benmachine> it was just seeing two <$> threw me off about what was supposed to be fmapping onto what
09:07:58 <b0fh_ua> about the problem - what may cause such error when type parameters do not match?
09:08:06 <hewei> Forcing me to design something that represents the global state
09:08:26 <benmachine> b0fh_ua: well, in general just because a type variable is called b and another one is also called b they don't have to be the same, of course
09:09:05 <b0fh_ua> sure, but how to fix this?
09:09:07 <Gracenotes> hewei: ah right. you might use StateT or ReaderT depending on whether it's a mutating thing or more of an environment.
09:09:09 <benmachine> b0fh_ua: what's IOResult?
09:09:34 <b0fh_ua> type IOResult a = Result IO a
09:09:45 <b0fh_ua> type Result m a = Control.Monad.Error.ErrorT LJError m a
09:09:51 <benmachine> right
09:09:56 <benmachine> hmm
09:10:24 <benmachine> try changing the <$> into a =<<
09:10:25 <hewei> Gracenotes: it is mutable, but my problem is that each part of the program only deals with part of the Global State, and depending on how I compose those parts, the global state may look different. 
09:10:40 <benmachine> or wait
09:10:43 <benmachine> that's not right
09:10:48 <benmachine> oh it might be
09:10:48 <b0fh_ua> wow
09:10:50 <benmachine> try it anyway
09:10:53 <b0fh_ua> that worked
09:10:57 <benmachine> cool :)
09:10:57 <b0fh_ua> but why?
09:11:07 <hewei> Gracenotes: I tried Arrows, and use liftSt, runSt, it seems to work for some cases, but not all. 
09:11:08 <benmachine> well
09:11:16 <benmachine> if you have a function a -> m b, and an m a
09:11:21 <Peaker> hewei, what are you trying to do?
09:11:22 <benmachine> there are two ways you can apply it
09:11:28 <b0fh_ua> ah, okay
09:11:30 <b0fh_ua> got it now
09:11:33 <benmachine> one is, using =<<
09:11:37 <benmachine> and get an m b
09:11:42 <Gracenotes> hewei: I was with you until 'depending on how I compose those parts'. must be complicated, no
09:11:43 <b0fh_ua> i'm in the ErrorT monad
09:11:44 <benmachine> one is fmap and get m (m b)
09:11:56 <b0fh_ua> and I can't use fmap there because those types are wrong
09:11:58 <Gracenotes> oh and where ST is involved.. eesh
09:12:10 <benmachine> you did the latter, and then ghc couldn't work out that (m b) was in your typeclass, so it whined
09:12:19 <benmachine> that's broadly speaking what happened
09:12:27 <benmachine> glossing over details a bit
09:12:53 <hewei> Peaker: I am writing a decoder for some protocol. And the format of the payload is defined by an xml. 
09:13:18 <Peaker> hewei, Ok, and why do you need mutable state?
09:13:26 <benmachine> the problem is that you *can* use fmap, if there's an instance of the right thing in the right place
09:13:35 <benmachine> so it can't just give a type error for using fmap straight away
09:13:50 <benmachine> it has to give you a more obscure error because that instance doesn't (and shouldn't) exist
09:13:55 <benmachine> ...I think so anyway
09:14:24 <hewei> Peaker: becaue the protocol is stateful, meaning what appeared in the past affects the values you see from the upcoming stream. 
09:15:28 <Peaker> hewei, So your protocol decoder is a (State ProtocolState) computation?  What other state do you have?
09:16:16 <hewei> Peaker: Exactly, mainly ProtocolState, but this type is not defined until the format definition is read. 
09:17:03 <Peaker> hewei, The type could be a type sum
09:17:18 <hewei> Peaker: what I did now is pragmatic, before I compile the whole program, I need to preprocess the XML and generate a haskell data type
09:17:47 <Peaker> hewei, There's probably a static type sum that can handle all possible XML definitions?
09:18:51 <hewei> Peaker: The XML defines a bunch of structure-like things, similar to what "data" provides, fields with names and types. 
09:19:17 <Peaker> hewei, Still sounds like it can handled that way :)
09:19:55 <hewei> Peaker: Could you explain a bit about static sum of types please? 
09:20:32 <Peaker> hewei, data TypeDesc = Structure [(String, TypeDesc)] | ...
09:20:54 <Gracenotes> a tagged union
09:21:23 <luite> Cale: what latex plugin did you use for your weblog?
09:21:35 <hewei> Peaker: ADT? 
09:22:10 <Peaker> hewei, That's for the "description" bit. The data/state it's populated with would be:  data TypeData = StructureData [(String, TypeData)] | ...
09:33:25 <Peaker> is there an easy way to know how much heap is used by a GHC executable at some given moment?
09:33:39 <Peaker> Profiling is a bit heavy if I need just a single number -- maybe there's an IO action to get it?
09:39:07 <bd_> Peaker: run with +RTS -S
09:39:10 <bd_> or +RTS -Sfile
09:39:45 <Peaker> bd_, thanks!
09:39:57 <bd_> that'll dump heap stats every GC, note
09:40:08 <bd_> as well as at termination
09:40:33 * hackagebot vect 0.4.6 - A low-dimensional linear algebra library, tailored to computer graphics.  http://hackage.haskell.org/package/vect-0.4.6 (BalazsKomuves)
09:41:34 * hackagebot vect-opengl 0.4.6 - OpenGL support for the `vect' low-dimensional linear algebra library.  http://hackage.haskell.org/package/vect-opengl-0.4.6 (BalazsKomuves)
09:44:43 <ClaudiusMaximus> i don't know whether to be annoyed or relieved that heap doesn't include foreign memory (malloc etc) - makes profiling more complicated sometimes, but generally the managed heap is more interesting anyway
09:45:15 <Peaker> Stats say "438,789,664 bytes maximum residency (16 sample(s))"
09:45:24 <Peaker> but when I use +RTS -M500M   it hits the limit :(
09:45:32 <Peaker> even with 600M
09:45:50 <zygoloid> ghc: panic! (the 'impossible' happened)
09:45:52 <zygoloid> ;(
09:46:53 <ClaudiusMaximus> perhaps there's a large overhead because it needs to make copies during GC (I guess)
09:51:21 <Axman6> @quote ghc
09:51:22 <lambdabot> ghc says: Generic method type is too complex
09:51:26 <Axman6> @quote ghc
09:51:27 <lambdabot> ghc says: Malformed context in type or class declaration
09:51:51 <zygoloid> @ghc
09:51:51 <lambdabot> ghc says: Illegal overloaded type signature(s)
09:52:10 <benmachine> @quote ghc brain
09:52:10 <lambdabot> ghc says: My brain just exploded.
09:55:53 <Axman6> sometimes GHC makes you forget its written by humans
09:57:06 <benmachine> soon GHC will start writing itself
09:57:11 <benmachine> ...only badly
09:57:22 <benmachine> huh, never thought about that before
09:57:31 <benmachine> immediately before the technological singularity
09:57:38 <mietek> What would be a good example of a high-performance and high-availability server written in Haskell?
09:57:47 <benmachine> we'll have AI that is capable of self-modification but not self-improvement because it's not very good at it
10:00:19 <Axman6> mietek: snap's web server
10:00:34 <Axman6> @google haskell snap framework
10:00:35 <lambdabot> http://snapframework.com/
10:00:35 <lambdabot> Title: Snap: A Haskell Web Framework: Home
10:00:44 <mietek> Thanks
10:01:17 <Axman6> http://snapframework.com/benchmarks
10:01:45 <cuba> can anyone explain me the unfold function :/?
10:01:59 <mietek> I'd like to see a comparison with YAWS
10:02:27 <Axman6> YAWS isn't particularly high performance is it?
10:03:06 <mietek> I haven't benchmarked it myself
10:03:11 <mietek> http://www.sics.se/~joe/apachevsyaws.html
10:03:24 <mietek> This is probably out of date
10:05:38 <monadic_kid> http://www.reddit.com/r/programming/comments/cvvck/jhc076_released_now_comes_with_wii_homebrew_target/
10:06:32 <cuba> i dont get what this (t x) is doing on the end of the recurisve call
10:06:59 <cuba> p is an boolean expression/condition whatever h is a function x is the starting value but whats t?
10:08:12 <Botje> @src unfoldr
10:08:13 <lambdabot> unfoldr f b  = case f b of
10:08:13 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
10:08:13 <lambdabot>    Nothing        -> []
10:08:18 <Botje> which unfold function?
10:08:23 <Botje> that one?
10:09:30 <cuba> http://pastebin.com/AVtkc5gk
10:09:33 <cuba> ah sorry thought i pasted it
10:10:30 <copumpkin> preflex: seen jmeacham
10:10:31 <preflex>  Sorry, I haven't seen jmeacham
10:10:45 <Botje> it looks like t is used to transform the input for the next time
10:10:51 <monochrom> at the same level of "h is a function", t is a function.
10:11:35 <Botje> cuba: for example, unfold (not . null) head tail list === list
10:12:03 <Botje> and you can get map (2*) list with unfold (not . null) ((2*) . head) tail list
10:13:13 <cuba> ah i guess i got it
10:13:17 <cuba> this channel rux :)
10:13:22 <cuba> <3
10:16:46 * hackagebot bluetile 0.5.2 - full-featured tiling for the GNOME desktop environment  http://hackage.haskell.org/package/bluetile-0.5.2 (JanVornberger)
10:18:28 <mietek> Axman6: http://lionet.livejournal.com/42016.html -- this is very interesting
10:21:13 <mietek> Axman6: have you seen Snap compared with Tornado?
10:21:29 <Axman6> nope
10:28:22 <byorgey> Can anyone think of Haskell-related words that begin with the letter 'O'?
10:29:06 <c_wraith> are you doing a crossword?
10:29:21 <Ke> Ord
10:29:43 <byorgey> Ord is the only one I could think of, are there any others?
10:30:13 <byorgey> c_wraith: my purpose shall remain a mystery for the nonce =)
10:30:32 <benmachine> Ordering?
10:30:43 <benmachine> press O in ghci and then tab tab
10:30:43 <byorgey> oh, good one
10:30:48 <Heffalump> OverlappingInstances
10:30:59 <benmachine> OverloadedStrings
10:31:05 <benmachine> tab-completion is goldmine for this :P
10:31:08 <benmachine> also, ord
10:31:15 <benmachine> or
10:31:16 <benmachine> otherwise
10:31:23 <Heffalump> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/doc-index-O.html but it's full of useless results too
10:31:24 <byorgey> oh, these are all excellent =)
10:31:48 <byorgey> yeah, dunno why I didn't think of tab completion or documentation indices
10:31:56 <byorgey> anyway, thanks, this should be sufficient =)
10:32:50 <c_wraith> are you still editing TMR?  Your preface seems a likely spot for this to land. :)
10:36:11 <byorgey> c_wraith: I am still editing TMR.  That's a very good guess, but this isn't actually for the TMR editorial.
10:36:31 <c_wraith> Ok, I'm done guessing. Good luck with whatever you're doing. :)
10:39:06 <Peaker> To make a Trie of mine for all substrings of all words in /usr/share/dict/words takes 700 megs of heap allocations :-P
10:39:06 <byorgey> thanks =)
10:40:12 <c_wraith> peaker: using what data types?
10:40:52 <Peaker> c_wraith, newtype Trie v = Trie { unTrie :: (v, IntMap (Trie v)) }  (I use IntMap with ord of chars)
10:41:15 <Peaker> I could use EnumMap for the same effect more elegantly
10:41:17 <c_wraith> So...  a Trie of tries? :P
10:41:37 <Peaker> c_wraith, A trie is always a recursive structure, isn't it?
10:42:10 <c_wraith> Yes, but it's usually uniform, rather than nested tries. :)
10:42:21 <c_wraith> My main point is that IntMap is a trie internally. :)
10:42:25 <Peaker> oh
10:42:31 <Peaker> I don't mind about that :-)
10:42:43 <Peaker> Not sure how a normal Map would be here
10:42:53 <Peaker> Is IntMap generally bigger/smaller than Map?
10:43:14 <c_wraith> Depends on how much sharing between keys, I believe.
10:43:43 <c_wraith> If your keys are the ord of the chars in /usr/share/dict/words, the sharing is probably pretty good.
10:45:06 <c_wraith> I just wonder if you'd do better reading everything as bytestrings, and making a Word8 trie.
10:45:17 <c_wraith> Which is supposedly what the bytestring-trie package does.
10:46:34 <conal> Peaker: i see how your Trie v corresponds to what I think of as Trie [Int] v
10:46:56 <Peaker> conal, Yeah, I specialized the type so I could use IntMap, when at first I suspected Map was too memory-hungry
10:47:03 <conal> since [Int] =~ () + (Int , [Int])
10:47:26 <conal> Peaker: what library would have used Map?
10:47:27 <mietek> byorgey: I love MR16 editorial.  The thought processes seem familiar.
10:47:51 <Peaker> conal, no no, I meant, it started out as: newtype Trie k v = Trie (v, Map k (Trie v))
10:48:23 <Peaker> conal, Are you referring to your library: memotrie?
10:48:27 <conal> Peaker: ah.  and how about using a standard/general trie library?  could amount to the same representation.
10:48:51 <conal> Peaker: memotrie, functor-combo, and others
10:48:57 <conal> Peaker: data-memocombinators
10:49:02 <monochrom> byorgey: haskell-related word starting with O: OMahHeadExplodes
10:49:09 <conal> though the latter is more roll-your-own
10:49:31 <ClaudiusMaximus> i keep meaning to write something for TMR at some point, i just find i'm not sufficiently expert in any particular subfield of Haskell
10:49:33 <monochrom> more serious attempt: object (think category theory!)
10:50:14 <Peaker> conal, I would like to use a standard trie. though in order to make a trie of all substrings, I unify all of the trie nodes with the "root" node (makin it a trie of all suffixes) and mappend the "v" of all path continuations in the trie to each node (making it a prefix trie), to yield a substring trie
10:50:38 <Peaker> conal, I thought "memotrie" was more about the "memo" than about the "trie" :)
10:51:26 <c_wraith> Is there a particular reason that you don't want to use bytestring-trie?
10:51:59 <conal> Peaker: the central type in memotrie is the Trie.  memo is one application of that type.  i also use it to represent linear maps in vector-space.  and in functor-combo, i use it to represent functions, for higher-order memoization.
10:52:26 <Peaker> conal, btw: did you see the:  class Newtype n where type Unwrapped n ; wrap :: Unwrapped n -> n ; unwrap :: n -> Unwrapped n     which then lets you define: inNewtype, inNewtype2, etc. instead of repeating this boilerplate for each wrapped type?
10:52:31 <Peaker> conal, s/Newtype/Wrapped
10:52:40 * conal re-reads Peaker's "would like to use a standard ..."
10:53:21 <conal> Peaker: no i didn't.  is Newtype useful?
10:53:31 <conal> s/Newtype/Wrapped/
10:53:47 <Peaker> conal, The main problem with it is it might sometime require more type annotations
10:54:03 <Peaker> conal, but otherwise, it should save the writing of "inSomething ; inSomething2 ; inSomething3 ; ... " boilerplate
10:54:05 <mietek> Does anyone know if CUFP talks/tutorials are going to be recorded and published?  They say "There will be no published proceedings, as the meeting is intended to be more a discussion forum than a technical interchange."
10:54:06 <conal> for instance, i use newtype to work around haskell not supporting recursive type synonyms.
10:54:29 <mietek> Which makes me sad, as I'd love to hear http://cufp.org/conference/sessions/2010/high-performance-haskell-johan-tibell but I probably can't afford to come to the US
10:54:47 <conal> Peaker: yeah -- that part i get (eliminate boilerplate).  i'm wondering how it's useful otherwise.  whether it really takes the place of newtype.
10:55:05 <Peaker> conal, oh, it's not meant to replace newtype, it's meant to replace the boilerplates around each newtype
10:55:19 * conal doesn't get it
10:55:49 <Peaker> conal, When you define: newtype MyType a = MyType ...   you typically follow it with definitions of: inMyType, inMyType2, ..., right?
10:56:27 <conal> Peaker: yes.  as you pointed out, boilerplate :(
10:56:35 <Peaker> conal, so the idea is to save this boilerplate
10:56:54 <conal> Peaker: while retaining the benefits of the custom newtype?
10:56:57 <Peaker> conal, Yeah
10:57:08 <conal> ie what motivated me to use a newtype.
10:57:12 <conal> that's the part i'
10:57:31 <Peaker> conal, You can use shorter boilerplate: instance Wrapped (MyType a) where type Unwrapped = ... ; wrap = MyType ; unwrap = unMyType -- and get the "in" functions and various others for free
10:57:35 <conal> that's the part i'm missing.  how you retain the benefits of the newtype.  ie what motivated me to use a newtype.
10:57:58 <Peaker> conal, you still have the newtype -- you just get the "in*" functions to work on it by making it an instance of "Wrapped"
10:58:08 <conal> oh!!
10:58:28 <conal> Peaker: thanks for hitting me on the head repeatedly until i heard what you were saying
10:58:32 <ck42> is it appropriate to run a short compile error on this channel?  (Bytestring-0.9.1.4)
10:58:33 <Peaker> hehe :)
10:58:40 <Peaker> ck42, Sure, if it
10:58:45 <Peaker> it's a big paste, use hpaste
10:58:55 <conal> hm.  reminds me of something in TypeCompose. ...
10:59:00 <ck42> nope...just 2 lines I think are of interest
10:59:12 <lispy> on code.haskell.org, what is the path to a repository that shows up as http://code.haskell.org/foo
10:59:13 <Peaker> ck42, Sure, paste
10:59:30 <ck42> Data/ByteString/Internal.hs:88:41:
10:59:34 <lispy> I looked in /srv/projects/foo but it's empty
10:59:34 <ck42> Module `GHC.IOBase' does not export `RawBuffer'
10:59:48 <lispy> and I know it's not empty because I can browse there on http
10:59:55 <Peaker> ck42, Sounds like you're trying to compile a bytestring package on an old/incompatible GHC?
11:00:05 <ck42> just updated ghc
11:00:20 <lispy> oh, I found it
11:00:24 <ck42> 6.12.3
11:00:38 <Peaker> ck42, how are you installing Bytestring?
11:00:50 <Peaker> conal, What thing in TypeCompose?
11:00:52 <conal> Peaker: i like it.
11:01:15 <ck42> Peaker: what do you mean 'how'?
11:01:22 <Peaker> ck42, "cabal install bytestring" ?
11:01:27 <Peaker> ck42, or manually?
11:01:34 <ck42> manually...gentoo system
11:01:38 <conal> Peaker: hm.  not finding it.
11:01:45 <ck42> rebuilt cabal for grins
11:02:34 <byorgey> mietek: thanks =)
11:02:40 <conal> Peaker: i'm going to try out Wrapped.  thx.  :)
11:03:00 <Peaker> conal, You're likely to encounter lots of ambiguous types -- if you find a nice solution to that let us know on your blog :)
11:03:23 <conal> Peaker: thx for the warning.  will do!
11:03:26 <aristid> is this code readable? drop <$> subtract n . length <*> id
11:03:36 <aristid> or is reverse . take n . reverse better?
11:04:13 <copumpkin> there are nicer ways to do it than either of those
11:04:22 <Peaker> aristid, latter much nicer IMO
11:04:27 <freedrull> anyone know of any bots written with fastirc?
11:04:30 * copumpkin is trying to remember the elegant way
11:04:34 <ck42> ahh...there's a cabal-install
11:04:36 <aristid> copumpkin: i'm curious
11:04:46 <aristid> Peaker: hmmm
11:04:58 * hackagebot Takusen 0.8.6 - Database library with left-fold interface, for PostgreSQL, Oracle, SQLite, ODBC.  http://hackage.haskell.org/package/Takusen-0.8.6 (JasonDagit)
11:04:59 <conal> aristid: you can factor the latter.  inReverse = reverse ~> reverse
11:05:08 <ck42> I'll build that real quick and try install bytestring that way too
11:05:19 <hpc> :t fromTail
11:05:20 <lambdabot> Not in scope: `fromTail'
11:05:21 <conal> aristid: then inReverse (take n)
11:05:42 <aristid> conal: which module do i need to import for that?
11:06:00 <conal> aristid: Control.Compose from TypeCompose
11:06:01 <aristid> @hoogle ~>
11:06:02 <lambdabot> No results found
11:06:18 <conal> aristid: or define ~> yourself. 
11:06:35 <aristid> conal: on the other hand, it doesn't really change that much
11:06:53 <Peaker> @let infixr 2 ~> ; (arg ~> res) f = res . f . arg
11:06:54 <lambdabot>  Defined.
11:06:58 <Peaker> @type (~>)
11:06:59 <lambdabot> forall (f :: * -> *) a1 a b. (Functor f) => f a1 -> (a -> b) -> (a1 -> a) -> f b
11:07:15 <Peaker> @type reverse ~> reverse
11:07:16 <lambdabot> forall a a1. ([a] -> [a1]) -> [a] -> [a1]
11:07:46 <hpc> @pl \func -> f . func . g
11:07:46 <lambdabot> (f .) . (. g)
11:07:50 <aristid> @type reverse ~> reverse $ tail
11:07:51 <lambdabot> forall a. [a] -> [a]
11:08:08 <conal> aristid: it refactors.  inReverse is useful and meaningful in itself.
11:08:21 <aristid> conal: that is true
11:08:33 <Peaker> conal, you have: -- (f ~> h) g = h . g . f   and then   f ~> h = result h . argument f     why do you prefer the latter over the former?
11:09:02 <conal> Peaker: it hinds at a much more general ~>
11:09:12 <conal> since result & argument can be generalized considerably.
11:09:19 <conal> Peaker: SECs are not just for functions.
11:09:20 <Peaker> conal, But (.) can be too?
11:09:42 <conal> Peaker: ah.  a different generalization.
11:10:02 <conal> Peaker: i'm going for the SEC/DeepArrow generalization
11:11:02 <aristid> conal: your generalization of (.) is neither Control.Category.. nor fmap, right?
11:11:14 <hpc> @src (.)
11:11:14 <lambdabot> (f . g) x = f (g x)
11:11:14 <lambdabot> NB: In lambdabot,  (.) = fmap
11:11:15 <conal> aristid: right!
11:11:25 <aristid> (.) can be generalized in so many ways :D
11:11:48 <conal> aristid: if you look at the types of first and second, you may guess what i'm going for in result & argument
11:12:37 <conal> first, second, result, and argument are editor (arrow) *combinators*.
11:13:01 <conal> @wiki DeepArrow
11:13:02 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
11:13:32 <aristid> conal: oh i have read your paper, i just didn't fully understand it
11:14:09 <conal> aristid: it's a very dense paper!
11:14:45 <aristid> and i'm not computer scientist.
11:15:24 <hpc> :t second
11:15:25 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
11:17:02 <greap> Hi all. I'm having some cabal trouble.
11:18:45 <applicative> hey greap, what are  your symptoms? 
11:20:10 <applicative> greap confllicting packages or what?
11:21:19 <monochrom> and how to reproduce it
11:22:32 <hpc> :t (|$)
11:22:33 <lambdabot> Not in scope: `|$'
11:22:38 <hpc> :t ($|)
11:22:39 <lambdabot> forall a b. (a -> b) -> Strategy a -> a -> b
11:22:56 <ck42> Ok...so maybe getting cabal-install wasn't such a great idea :)  apparently 'time' and 'random' are having issues too.  ghc-pkg check is giving 'interesting' results too. ;)
11:24:38 <ck42> 'time' actually built, no issues.  But I don't actually find a 'random' pkg to compile.
11:24:42 <Peaker> cabal-install doesn't work very smoothly. we need import/export signatures
11:25:22 <ck42> ok...I'll abandon that idea then.
11:25:47 <monochrom> there are two great ideas. consistently use haskell libs from your distro and never cabal-install your own. consistently cabal-install everything and never use your distro.
11:26:05 * Twey prefers the latter.
11:26:12 <monochrom> if you mix them, there is a way to make it work: order matters
11:26:43 <greap> applicative: Unable to read a cabal file
11:27:01 <applicative> greap is it a Hackage cabal file?  What package?
11:27:04 <ck42> monochrom: certainly makes sense.  That same strategy applies to nearly all package mngmnt systems too.  Stick with them or do all your own pkg maintenance (for the most part)
11:27:29 <greap> applicative: Yep, after a cabal update "cabal: Couldn't read cabal file "./HaTeX/1.0.1/HaTeX.cabal""
11:27:38 <applicative> hmm
11:27:58 <greap> I updated my version of cabal and cabal install too which usually fixes this issue
11:27:59 <applicative> yipe, cabal update.  I think the experts oppose that
11:28:23 <greap> applicative: really? how are you meant to update the package list?
11:28:37 <monochrom> c libs are more robust because different versions have the same ABI, the linker doesn't care.
11:28:46 <applicative> sorry,nonsense, I was imagining something
11:29:01 <applicative> i'm getting the same error for HaTeX
11:29:08 <benmachine> cabal upgrade is the bad one
11:29:30 <benmachine> and I've had problems with HaTeX I think
11:29:32 <greap> applicative: I'm not sure what I'm meant to do in this scenario besides removing the package and retaring the cache
11:29:42 <greap> (clearly not maintainable)
11:30:38 <monochrom> "cabal update" simply means download the hackage table of contents again
11:32:28 <greap> monochrom: yes
11:34:06 <applicative> monochrom, I was thinking of cabal upgrade, cabal update springs from my fingers so much I forgot it....
11:34:43 <monochrom> perhaps both "update" and "upgrade" are poorly chosen names
11:35:05 * hackagebot sstable 1.0 - SSTables in Haskell  http://hackage.haskell.org/package/sstable-1.0 (MariusEriksen)
11:35:29 <monochrom> "update" is ambiguous because of "windows update" and "apt-get update"
11:36:21 <Saizan> greap: is your locale utf8?
11:36:39 <greap> yes
11:36:43 <Peaker> I have an ADT, and I want to annotate each of the data constructors with more fields. If I pattern-match the annotated data-type, I'm going to have a potential mis-match between the annotated data constructor and the original. Any idea how to elegantly avoid this?
11:37:01 <greap> en_AU.UTF-8
11:37:14 <Peaker> I could use an open type sum (type-class) maybe, and then the annotations would be products o the various types
11:37:22 <benmachine> "refresh" might be better than "update"
11:37:22 <Saizan> mh, i bump into the same error if i try e.g. "cabal info hatex"
11:38:09 <Saizan> greap: http://hackage.haskell.org/trac/hackage/ticket/714
11:38:14 <greap> It's stopping me from running 'cabal list' too, as it breaks once it hits hatex
11:38:24 <greap> Saizan: awesome.
11:42:07 * hackagebot species 0.3.2 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.2 (BrentYorgey)
11:46:26 <applicative> Oh, I see, I found that it has windows line endings. 
11:50:40 <Peaker> My application is a GUI that edits an ADT.  I'd like to separate the ADT itself from the GUI state around it.  I'd like to "annotated" each of the ADT's data-cons with more GUI state. If I do this "outside" the ADT - by making an equivalent ADT with the same data-cons's, there's no way to guarantee they match up
11:51:03 <Peaker> Has anyone ever had the need to "annotate" an ADT in a different module than the one it was defined in (for modularity's sake)
11:51:51 <Peaker> I could have:  case (dat, annotation) of (Dat1 x y, Annotation1 z) -> .. ; (Dat2 a b, Annotation2 c d) -> .. ; _ -> error "Annotation mismatches the data"
11:51:57 <Peaker> but I'd like to be able to avoid the partiality
11:55:13 <greap> Hmm, snap doesn't depend on heist, but projects created with snap-init do. Should there be a way to indicate an indirect dependency like this in cabal?
11:55:58 <Saizan> won't heist be installed when you install one of those projects?
11:56:42 <Saizan> "cabal install" in a source tree with a .cabal file will install the missing deps automatically
11:56:54 <applicative> greap, did you figure it out?  After all that I tried cabal update, cabal unpack HaTeX  then cabal install --user and it worked.  
11:57:29 <greap> applicative: Yep. It just worked after an update. I guess it was updated today.
11:58:04 <Saizan> Peaker: do you need the annotations to be in a completely distinct value for runtime purpouses too or is that just how you managed to keep it modular?
11:58:25 <Peaker> Saizan, I've not actually started working on it yet, but I hope I don't have to mix my GUI state declarations with the data itself
11:58:47 <ClaudiusMaximus> perhaps you could make your ADT have an additional parameter for each of the constructors?  like data ADT a1 a2 a3 = Dat1 a1 | Dat2 (ADT a1 a2 a3) a2 | Dat3 (ADT a1 a2 a3) (ADT a1 a2 a3) a3 ?
11:59:20 <Saizan> Peaker: you just need to parametrize the datatype declaration over "additional info"
11:59:42 <Peaker> ClaudiusMaximus, interesting, though that kind of breaks modularity still (for having to modify the base ADT)
12:01:14 <ClaudiusMaximus> i'd hate to have to implement that for more than 3 constructors though...
12:01:42 <Peaker> I could have a GADT type tag
12:01:44 <Peaker> for each constructor
12:01:58 <ssbr_> Peaker: Ahoy!
12:02:27 <Peaker> ssbr_, ahoy? :)
12:02:30 <dolio> jhc is really cranking out releases.
12:02:38 <copumpkin> yeah!
12:02:41 <ssbr_> Peaker: It's pirate for "hello". I started learning Haskell
12:02:51 <dolio> Did John have a bunch of unreleased code saved on his machine or something?
12:03:19 <Peaker> ssbr_, hi, welcome to the wonderful addictive world of Haskell :)
12:03:40 <dolio> @arr
12:03:40 <lambdabot> Aye Aye Cap'n
12:04:25 <ssbr_> Peaker: Worked on your editor yet?
12:05:24 <Peaker> ssbr_, Working on it still :)
12:05:41 <ssbr_> I think that is more than what I remember you doing before
12:06:19 <ssbr_> (or maybe working is thinking? either way)
12:06:21 <Peaker> ssbr_, I'm sorry, I don't remember nicks very well
12:06:28 <ssbr_> Peaker: Aha, I knew it!
12:06:37 <ssbr_> Peaker: It's OK. You are just more memorable than me.
12:06:41 <applicative> Peaker, you're writing an editor? 
12:06:54 <Peaker> applicative, Yeah, structural editor and structural revision control
12:06:58 <ssbr_> Peaker: We met in #python and have occasionally bumped together since
12:07:10 <mietek> Nudge, nudge
12:07:10 <Peaker> ssbr_, ah, cool, I haven't been in #python in ages :)
12:07:17 <ssbr_> Yes. I had a different nick then.
12:07:26 <ssbr_> Actually... maybe I changed my nick after I last met you? scorchsaber
12:07:34 <Peaker> ssbr_, ah, scorchsaber I remember :)
12:08:02 <ssbr> Peaker: ah well. Now I'll remember to say "I'm scorchsaber" next time you act confused :p
12:08:40 <applicative> Peaker, this means you have to write a version control system too?
12:09:12 <Peaker> applicative, Yeah, I've got the branching part prototype kinda done. Now need to get merge/conflict stuff done :)
12:09:32 <Peaker> applicative, I think structural revision control can avoid most of the conflicts textual revision control has unnecessarily
12:09:48 <thoughtpolice> what's "structural revision control"
12:09:51 <thoughtpolice> ?
12:10:10 <ssbr> thoughtpolice: version control that diffs on the level of the syntax tree, IIRC
12:10:14 <Peaker> thoughtpolice, instead of heuristically trying to guess what changed between blah_before.hs and blah_after.hs -- the structural editor keeps an undo-log of operations, which becomes the revision change list
12:10:28 <ssbr> Or I could *totally* misremember
12:10:33 <ssbr> That was part of the editor, then
12:10:55 <Peaker> thoughtpolice, so you get a "real" diff list of what the user actually did, instead of a heuristic guess that can't tell apart moving code around from deletions and insertions of similar code, for example
12:11:24 <Peaker> thoughtpolice, Also, the structure would allow storing "names" of variables in just one place, so when you rename, it's just one structural change and doesn't conflict against changes of the name elsewhere
12:11:24 <thoughtpolice> hm
12:11:30 <gustav_> Hi! I have finnished the book "Programming in Haskell". The book is wonderful but I've realized that there is so much more haskell to learn, so where to go next? Is there any more anvanced haskell book or something?
12:12:21 <applicative> gustav_, there are several.  It might depend on your purpose. 
12:14:34 <applicative> Real World Haskell and say, Bird's Introduction to Functional Programming with Haskell are both more advanced, but quite different.
12:14:55 <applicative> the latter is more theoretical, it's unfortunately a bit old 
12:15:20 <flippo> I liked RWH very much.
12:15:24 <applicative> @where RWH
12:15:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:15:24 <Peaker> How do people typically write Binary instances of type sums?
12:15:43 <benmachine> Peaker: write a Word8 for which constructor it is, I think
12:15:46 <benmachine> and then the contents
12:15:54 <Peaker> benmachine, That's quite a bummer
12:15:58 <benmachine> how so?
12:16:09 <Peaker> benmachine, Manually keep my own table of which cons. it is
12:16:19 <Peaker> Mapping ints to constructors
12:16:27 <gustav_> well, I don't have any big purpose, just learn to solve problem in a cool haskell way ;) , thx for the suggestions, I'll check
12:16:28 <benmachine> well
12:16:39 <benmachine> you can do it with generics, or derive it
12:16:44 <applicative> @where typeclassopedia
12:16:44 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:16:59 <benmachine> but it's not that unpleasant unless your datatype is huge, in which case it's going to be horrible anyway :)
12:17:03 <Peaker> benmachine, how do I derive it?
12:17:13 <applicative> gustav_ ^^^ is well worth a study, too
12:17:16 <benmachine> er, there's a package somewhere
12:17:23 <benmachine> I think?
12:17:31 <benmachine> or is it DRiFT or whatever it's called
12:17:37 <benmachine> it wouldn't be that hard to do with TH
12:18:01 <greap> Saizan: Ah, I didn't know that.
12:18:15 <benmachine> hmm I wrote a generics binary thing once but I think I lost it
12:18:18 <benmachine> or it didn't work, or something
12:18:36 <dolio> derive has support for Binary, it seems.
12:18:49 <Peaker> how do you use derive?
12:18:52 <thoughtpolice> derive is totally awesome
12:19:09 <dolio> http://hackage.haskell.org/packages/archive/derive/2.3.0.2/doc/html/Data-DeriveTH.html
12:19:39 <Peaker> ah, "{-! Eq, Binary !-}"
12:19:55 <transient> How do you declare class instances to functions?  Eg, instance Eq ([Int] -> ([Int], Bool)) where ...?
12:19:57 <thoughtpolice> Peaker: include e.g. Data.Derive.Binary and Data.DeriveTH, then you can just do "$(derive makeBinary ''Type)"
12:20:11 <thoughtpolice> i like using TH more than the executable myself
12:20:12 <thoughtpolice> ymmv
12:20:41 <benmachine> transient: you may need the FlexibleInstances GHC extension
12:20:44 <Peaker> oh, right, it wants a preprocessor, I'll use the TH
12:20:55 <transient> hmm i'll look at it
12:21:34 <benmachine> transient: without it you can still declare instances for (a -> b)
12:21:42 <benmachine> just not (Int -> Char) or whatever
12:21:43 <applicative> transient, you have e.g. square :: Num a => a -> a
12:22:37 <Peaker> ssbr, I already have named branches you can jump between, save-less editing (all editing operations perform a persistent transaction to a key/value store), and a simple UI for tree editing
12:23:16 <ssbr> Peaker: yes, that is a lot further than I remember last
12:23:19 <Peaker> ssbr, so I have a console GUI toolkit I wrote for this purpose
12:23:42 <applicative> transient, hmm, maybe I'm not following.  Is there some problematic module you can paste on hpaste.org or whatever?
12:23:45 <ssbr> Peaker: you're not using an existing library? What language is this written in?
12:23:53 <Peaker> ssbr, Haskell, of course :)
12:24:04 <applicative> @faq
12:24:04 <lambdabot> The answer is: Yes! Haskell can do that.
12:24:17 <Peaker> ssbr, I'm using "vty" for console input/output. "vtywidgets" is the GUI toolkit around it
12:24:49 <transient> applicative, i have a data type which takes a function for an argument, and i'm trying to make these data types equatable (without just ignoring the function)
12:25:38 <Peaker> transient, How do you want the function comparison to work?
12:26:14 <ssbr> Peaker: do you have the source up somewhere or no?
12:26:43 <Peaker> ssbr, http://github.com/Peaker/vtywidgets/ and http://github.com/Peaker/datastore
12:27:35 <transient> Peaker, i'm not very experience in this department, so the only method of comparison i can think of is not comparing them.  it seems like another way to do it is to apply an argument to both functions, and see if the results are equal
12:27:38 <ssbr> Peaker: I'll need some code to read as I learn. Is yours idiomatic?
12:27:47 <Peaker> transient, then they are equal for that argument only
12:28:09 <Peaker> ssbr, I don't know :)  I use a lot of "advanced idioms" I learned from various places (mainly conal's code/blogs)
12:28:15 <applicative> transient, so it is like, e.g. Fixy a = Fixy ((a->a) -> a) then you want instance Eq (Fixy a) ?
12:28:22 <ssbr> Peaker: That sounds dangerous for me
12:28:37 <ssbr> Peaker: Do you know of anything simpler but idiomatic, perhaps?
12:29:24 <transient> well, I have it set up like this: data Foo = Foo ([Int] -> ([Int], Bool)), and I want instance Eq Foo
12:29:52 <Peaker> ssbr, almost any package you click on in Hackage, probably
12:30:12 <ssbr> OK. Thanks.
12:30:16 <Peaker> ssbr, You could try to read my code there, and I could help with any idioms
12:30:44 <ssbr> Then maybe I will! They're bookmarked for when I know more than basic Haskell (I have a few things I have to do before continuing to learn)
12:30:47 <applicative> transient, right.  The trouble is how you actually propose to compare them.  there's always, instance Eq Foo where _ == _ = True
12:31:06 <transient> applicative, yea, but that's not very useful :/
12:31:13 <applicative> transient, yeah
12:31:24 <Peaker> ssbr, did you read LYAH?
12:31:34 <transient> applicative, what I wanted to do was compare them by function application, and am clueless on how to do that
12:31:51 <ssbr> Peaker: I was recommended Real World Haskell
12:32:14 <Peaker> ssbr, Ah, I have received mixed responses about RWH.. LYAH responses were mostly "awesome" :)
12:32:25 <ssbr> It's very slow. Is LYAH faster?
12:32:31 <tensorpudding> LYAH doesn't cover all that RWH covers
12:32:43 <ssbr> (by which I mean it's too slow and covers too much that I already know)
12:33:16 <Peaker> ssbr, I don't know -- it's a bit of a problem, each individual has a different background so in each tutorial you're likely to be explained things you already know
12:33:29 <Ke> I'd recommend reading LYAH and using RWH as needed to supplement that
12:33:30 <Peaker> ssbr, Some people told me LYAH is slow too
12:33:42 <applicative> transient, yes, you won't be able to get the ordinary meaning of equality of "functions from lists of integers to lists of integers" without e.g. solving the Halting Problem.
12:33:56 <chrisdone> RWH is a great Haskell book. and compared to previous Haskell books it's epic
12:33:57 <Peaker> ssbr, Maybe you can just try to start solving problems, and ask #haskell for feedback about the code
12:34:07 <ssbr> Peaker: I almost feel like I'd like to read a reference and a guide to constructing software in Haskell, rather than a tutorial that tries to introduce concepts and patterns in layers
12:34:17 <applicative> transient, if you had data Foo = Foo (Bool -> (Bool,Bool)) it would be different of course.  But maybe I'm not understanding
12:34:46 <applicative> chrisdone, i
12:34:55 <chrisdone> O_O
12:34:56 <Peaker> ssbr, Well, start solving project euler, maybe, or start writing something you wanted to write.. that's the fastest way, maybe :)
12:35:04 <transient> applicative, why would it be different?  i should mention these lists are not infinite :P
12:35:05 <applicative> m trying to do the math does that mean that all previous haskell books were unusually lame?
12:35:24 <ssbr> Peaker: I am interested in seeing how well my Python code translates to Haskell, given that some of it is quite functional
12:36:06 <ssbr> But, Euler may be better. It's just that I can't use what I don't know yet. I figured Euler would heklp me solidify existing knowledge, not get new knowledge.
12:36:22 <applicative> transient, you mean, the lists are below some fixed length, and the Ints used are some definite collection?
12:36:37 <Peaker> ssbr, maybe you can try to convert, and ask for feedback, or even paste python and ask for conversions
12:37:11 <ssbr> Peaker: I have too much pride for the lattermost thing. :)
12:37:12 <Peaker> ssbr, sure, but then people in #haskell can tell you how to do things in more idiomatic ways
12:37:23 <ssbr> Peaker: OK, that is a good idea.
12:37:45 <Peaker> ssbr, the first thing I wrote in Haskell was text jumping around the screen corners, like the old Windows screen saver. conal gave me feedback about how to make it more functional, and that was nice :)
12:37:55 <Peaker> (taught me a lot)
12:38:34 <ssbr> Peaker: I'd give you an idea about how I'd do it, except I haven't learned anything about I/O yet. :(
12:38:39 <transient> applicative, the lists will never grow above an arbritatry number, and I'm not completely sure what you mean by definite collection.  If this helps clarify, here is an example of an argument: [1,1,3,2,5,2] (just more things like these, of varying length)
12:38:51 <ssbr> but I want to say I'd generate a sequence of text positions and work from there.
12:40:04 <Peaker> ssbr, Good job, I used some mutable positions at first :)
12:40:31 <applicative> transient, maybe it would make things clearer if you had lists like [A,A,C,B,E,B]  following data Index = A | B | C | D | E deriving Eq Show Ord 
12:41:56 <applicative> transient, the natural ordering of the lists themselves will be lexical.  But I still worry it won't take much to make a combinatorial nightmare
12:42:04 <transient> applicative, ah, i think i understand what you mean by definite collection.  :/  But yes, let's work with that -- the system I actually have set up resembles that more closely.
12:44:14 <ssbr> Eck, flaky ISP.
12:47:58 <applicative> if Index has 5 members , Index -> Index has 5 ^ 5 = 3125 values to search, Index -> (Index,Bool) has 9765625 but you want [Index] -> ([Index],Bool)
12:48:05 <applicative> transient, ^^^
12:48:22 <copumpkin> enumerable can make you all those functions, too
12:48:26 <copumpkin> @hackage enumerable
12:48:26 <lambdabot> http://hackage.haskell.org/package/enumerable
12:48:28 <copumpkin> :P
12:49:05 * applicative was going to say, I am only looking at the matter from a naive combinatorial perspective, but with more cleverness...
12:49:31 <copumpkin> yeah, that package isn't very clever
12:49:31 <applicative> transient, the answer is "import Data.Enumerable.ControversialFunctionEquality"
12:49:34 <kmc> ssbr, RWH chapters are pretty self-contained, skipping ahead might be a reasonable idea
12:49:36 <copumpkin> lol
12:49:45 <transient> applicative, ah
12:49:51 <copumpkin> applicative: that only gives you semidecidable equality if you have infinite types
12:49:51 <applicative> copumpkin, I was assuming it was clever....
12:49:53 <kmc> i was pretty experienced in Haskell when i found RWH, and i got a lot out of reading some of the later chapters
12:50:10 <copumpkin> applicative: only as clever as it can be :P I was going to add bottom enumeration too, but got bored
12:50:11 <aristid> kmc: they do build on each other, at least for a noob like when i read it
12:50:51 <copumpkin> anyway, with finite types, function equality should work fine
12:51:17 <applicative> copumkin isn't enumerating list types...
12:51:41 <copumpkin> ?
12:52:15 <kmc> i think learning Haskell will always feel slow, no matter what book you use
12:52:34 <copumpkin> unless you're haskelllove
12:53:05 <applicative> copumpkin, transient wants Eq for ([Int] -> ([Int],Bool))
12:53:21 <copumpkin> oh lists are infinite
12:53:36 <copumpkin> it's still demidecidable
12:53:43 <copumpkin> it'll return False, at least ;)
12:53:46 <ssbr> kmc: reasonably, maybe, but I share aristid's experience
12:53:55 <ssbr> that said, I could skip ahead and go back to catch up on stuff that confuses me
12:54:21 <applicative> copumpkins, but it sounds like he can fix the lengths to < n and also not all Ints. I was just worrying about calculating this
12:54:36 <copumpkin> ah ok
12:54:44 <transient> applicative, yea, the lists are going to be pretty short and will be a definite collection
12:55:31 <sophacles> hi all -- is there a reccomended way of treating an x bit int as an array (or list) of single bit values? specifically i have a datatype that holds [a] as a value, but in this case a is a long string of bool that comes off the wire as a 32 bit int
12:55:44 <transient> applicative, compumpkin: thank's for the help -- i'm installing cabal / enumerable atm and hopefully this will work
12:56:10 <sophacles> i was wanting to just work on the int itself as head, tail etc...
12:56:39 <applicative> so it's like data Index = A | B | C | D  and then data Foo = One Index | Two Index Index | Three Index Index Index ... calls for type families?
12:57:27 <copumpkin> you want Vectors
12:57:38 <copumpkin> data Z = Z
12:57:42 <copumpkin> data S n = S n
12:58:01 <transient> applicative, it's data Index = A | B | C | D... and data Foo = One ([Index] -> ([Index], Foo)) | NoFoo
12:58:08 <copumpkin> data Vec where Nil :: Vec Z; Cons :: a -> Vec n -> Vec (S n)
12:58:44 <applicative> transient, I was using One Index | Two Index Index | Three Index Index Index in place of [Index] to restrict length
12:59:55 <copumpkin> the vectors I defined are vectors of a fixed length though
13:00:07 <copumpkin> you can probably pull a trick to get vectors of less than a fixed length
13:00:35 <transient> applicative, alright, so then it would be data Index = A | B | C | D..., data IndexList = One Index | Two Index Index | ... and data Foo = Foo (IndexList -> (IndexList, Foo)) | NoFoo
13:01:15 <copumpkin> ack, that function inside foo has a recursive type?
13:01:18 <applicative> so call it  data IndexSeries = = One Index | Two Index Index | Three Index Index Index ...  up to 17. :) -- I was writing
13:02:02 <applicative> hmm, before it was like data Foo = Foo (IndexList -> (IndexList, Bool) | NoFoo
13:02:55 <Peaker> Data.Derive.Binary depends on manual importing of Data.Binary.Get and Data.Binary.Put?
13:03:05 <Peaker> It doesn't re-export the symbols it's generated TH code depends on?
13:04:50 <transient> copumpkin, mind quickly explaining how to use Data.Enumerable.ControversialFunctionEquality?  I can't find much on the internet
13:05:09 <copumpkin> don't use the Controversial one :P
13:05:32 <copumpkin> just define an Enumerable instance for your type, and make a Finite instance for it too (to convince haskell that it's finite :P)
13:05:38 <copumpkin> and then you can just call == on functions
13:05:41 <copumpkin> it'll be slow though ;)
13:05:46 <transient> alright thanks
13:05:48 <transient> easy enough
13:05:58 <kmc> function equality, oh noes
13:06:34 <kmc> (==) `on` (unsafeCoerce# :: a -> Word#)
13:06:37 <kmc> ;)
13:07:09 <copumpkin> :P
13:18:25 <ClaudiusMaximus> @hoogle GC
13:18:26 <lambdabot> Data.Typeable gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
13:18:26 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
13:18:26 <lambdabot> Data.Typeable gcast2 :: (Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b))
13:19:04 <ClaudiusMaximus> :t System.Mem.performGC
13:19:05 <lambdabot> IO ()
13:19:58 <McManiaC>     Contexts differ in length
13:19:59 <McManiaC>       (Use -XRelaxedPolyRec to allow this)
13:19:59 <McManiaC>     When matching the contexts of the signatures for
13:20:02 <McManiaC> what error message is that??
13:21:28 <kmc> a deep dark corner of the haskell spec
13:21:33 <benmachine> McManiaC: it's an oddity of the haskell98 rules regarding recursive functions
13:21:47 <benmachine> McManiaC: I think RelaxedPolyRec is "safe"
13:22:11 <ClaudiusMaximus> would it make sense to call System.Mem.performGC immediately after each Graphics.UI.GLUT.swapBuffers in an attempt to reduce jitter?
13:22:37 <kmc> ClaudiusMaximus, iirc performGC does a major / gen-2 GC, which may be more than you want every frame
13:22:42 <kmc> that said, try it and find out
13:22:46 <McManiaC> I cant see where the recursion is tho...
13:22:56 <McManiaC> there *is* no recursion
13:22:57 <ClaudiusMaximus> kmc: mm, i'll give it a go
13:23:10 <ClaudiusMaximus> McManiaC: try -Wall and see which variables are shadowed
13:23:15 <ClaudiusMaximus> (guessing there)
13:23:23 <kmc> McManiaC, the spec requires breaking binding groups into minimal mutually-recursive sets, and if more than one binding in a set has an explicit sig, the contexts must match
13:23:24 <McManiaC> no shadowed variables
13:23:30 <kmc> McManiaC, can you hpaste the fragment?
13:23:39 <McManiaC> kmc: its pretty big
13:24:40 <ClaudiusMaximus> kmc: it is a major gc in GHC, foreign import ccall {-safe-} "performMajorGC" performGC :: IO ()
13:25:52 <McManiaC> well actually it isnt..
13:26:06 <McManiaC> oh I see
13:26:47 <McManiaC> I got two functions:
13:27:45 <McManiaC> foo :: [a] -> TypeQ; foo [] = $impossible; bar :: [(a,b)] -> DecQ; bar [] = $impossible
13:27:57 <McManiaC> so $impossible has two different types...
13:28:32 <benmachine> I wouldn't have thought that would matter for a splice
13:28:40 <McManiaC> yeh...
13:28:41 <kmc> oh dear, TH
13:28:56 <McManiaC> hehe
13:29:18 <kmc> but this is, like, meta-TH... you have a splice which produces an expression of type DecQ?
13:29:43 <McManiaC> jup
13:29:55 <kmc> nuts
13:30:12 <McManiaC> $impossible is just some "this cant happen here but show me if it does" error message
13:30:23 <kmc> i find TH macros take about 20 times as long to write as 'ordinary' haskell
13:30:30 <kmc> and so i assume your meta-TH takes 400 times as long to write ;P
13:30:56 <McManiaC> lol
13:31:02 <zachk1> maybe you should just perl (nom nom nom) 
13:31:08 <McManiaC> nah, its not that bad
13:31:10 <Peaker> TH requires data declarations to have bottom-up order?
13:31:14 <Peaker> no forward references?
13:31:19 <Peaker> or is it just fc labels?
13:32:15 <McManiaC> fc?
13:32:55 <Peaker> fclabels package
13:33:08 <McManiaC> :w
13:33:08 <Peaker> It seems that TH doesn't support mutually recursive declarations
13:33:09 <McManiaC> ups
13:33:11 <McManiaC> :D
13:33:40 <McManiaC> Peaker: never had any problems with that
13:34:03 <McManiaC> otoh, I have written "only" about 500 lines of TH code
13:34:04 <McManiaC> :D
13:35:44 <Peaker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28446#a28446
13:36:34 <Peaker> This doesn't compile -- as TH seems to be incapable of working with mutually recursive types, at least not when you try to derive code for both of the recursive types
13:38:51 <Saizan> Peaker: put $(derive makeBinary ''Filter) after CommentData's declaration
13:39:35 <Peaker> Saizan, thanks!
13:39:40 <Peaker> Saizan, why does this happen?
13:39:54 <kmc> @seen blackh
13:39:54 <lambdabot> Unknown command, try @list
13:39:55 <preflex>  blackh was last seen on #haskell 9 days, 20 hours, 50 minutes and 10 seconds ago, saying: ivanm: I don't mind.
13:40:39 <Saizan> Peaker: fsvo why, it's because toplevel splices make order matter.
13:41:02 <benmachine> I think "because TH" is a valid reason for quite a lot of perversity
13:41:11 <McManiaC> *** Exception: user error (Sqlite3 backend does not support describeTable)
13:41:12 <McManiaC> :(
13:41:15 <McManiaC> but the TH part works
13:41:16 <McManiaC> lol
13:41:18 <Saizan> a module is no longer a big generalized let rec
13:41:20 <orlandu63> @src on
13:41:21 <lambdabot> (*) `on` f = \x y -> f x * f y
13:41:36 <orlandu63> is this function definition possible? (*) is already defined
13:41:47 <benmachine> orlandu63: it's shadowed
13:41:47 <Peaker> Saizan, splices?
13:41:52 <benmachine> like,
13:41:58 <benmachine> > let x = 3 in let x = 4 in x
13:41:59 <lambdabot>   4
13:42:00 <Saizan> Peaker: $(..) things
13:42:07 <benmachine> ^ the inner binding replaces the outer one
13:42:19 <benmachine> > let x = 3 in (let x = 4 in x, x)
13:42:20 <lambdabot>   (4,3)
13:43:25 <Saizan> so (*) is just a pattern made of a single variable, it looks weird because that variable is syntactically an operator
13:43:40 <Saizan> (in that definition of on, i mean)
13:44:02 <orlandu63> i see
13:44:26 <McManiaC> > (let x = 3 in (let x = 4 in x), x)
13:44:27 <lambdabot>   (4,x)
13:44:27 <McManiaC> :D
13:44:36 <McManiaC> oh that works
13:44:37 <McManiaC> okay
13:44:38 <McManiaC> :>
13:44:52 <benmachine> well x is a toplevel binding in lambdabot
13:44:57 <benmachine> > x
13:44:58 <lambdabot>   x
13:45:10 <c_wraith> :t x
13:45:11 <lambdabot> Expr
13:45:26 <orlandu63> > (let b = 3 in (let b = 4 in b), b)
13:45:27 <lambdabot>   (4,b)
13:45:27 <poincare101> hello everyone. why won't this work? (i'm just beginning in IO): http://pastebin.com/VvLFFcQ4
13:45:48 <mauke> useless use of '== True'
13:45:51 <poincare101> it chokes up on some integral and fractional thing...
13:46:03 <mauke> 'if X then True else False' better written as 'X'
13:46:11 <McManiaC> useless use of "if .. then True else False" ;)
13:46:11 <kmc> hehe
13:46:27 <copumpkin> the opposite isn't much better
13:46:36 <mauke> 'x `mod` 2 == 0' better written as 'even x'
13:46:45 <benmachine> all bool-valued ifs are a bit suspect
13:47:05 <mauke> poincare101: change x/2 to x `div` 2
13:48:14 <kmc> all ifs are a bit suspect in Haskell
13:48:28 <benmachine> heh
13:48:36 <kmc> often some combination of pattern matching and guards is preferable
13:48:57 <kmc> not to say i never use it, but beginners often overuse it
13:50:59 <McManiaC> hmpf
13:51:11 <McManiaC> now I need to get postgresql running just to do some "tests"
13:51:14 <McManiaC> see if it works :S
13:51:45 <McManiaC> stupid IO
13:51:45 <McManiaC> :>
13:57:34 <poincare101> mauke: I'm still having problems...
13:58:33 <McManiaC> poincare101: we cant solve them like that :)
14:00:36 <ClaudiusMaximus> count   mean seconds/frame   standard deviation   action
14:00:36 <ClaudiusMaximus> 1383    0.04328888647867     0.011722638887193    return ()
14:00:36 <ClaudiusMaximus> 1385    0.043231279422383    0.0091618701780128   performGC
14:00:55 <ClaudiusMaximus> so it seems performGC after each frame does reduce jitter, but it's still rather high
14:01:40 <ClaudiusMaximus> maybe i shouldn't be using GLUT if i need a rock-solid frame rate..
14:02:08 <kmc> GLUT is kinda crap iirc
14:02:15 <ClaudiusMaximus> indeed
14:02:26 <kmc> but realtime stuff in Haskell is tricky, anyway
14:02:31 <ClaudiusMaximus> i know
14:02:32 <kmc> did you tweak RTS settings to reduce GC frequency?
14:02:43 <ClaudiusMaximus> not yet
14:05:50 <ClaudiusMaximus> kmc: any particular flags i should look at?
14:06:14 <kmc> -A
14:06:37 <kmc> http://stackoverflow.com/questions/3171922/ghcs-rts-options-for-garbage-collection
14:06:43 <kmc> and http://hackage.haskell.org/package/ghc-gc-tune
14:07:02 <kmc> or you can just compile with -fvia-stack-overflow
14:07:06 <ClaudiusMaximus> :)
14:07:21 <kmc> ;)
14:09:36 <bl> hi all
14:09:57 <bl> running through learn you a haskell - can someone explain folds to me? thanks!
14:10:15 <ClaudiusMaximus> ghc-gc-tune isn't quite what i want, but i could maybe hack it to do what i want (ie, graph frame jitter instead of running time)
14:10:45 <ClaudiusMaximus> > foldr f e [a, b, c, d]
14:10:46 <lambdabot>   f a (f b (f c (f d e)))
14:11:01 <ClaudiusMaximus> > foldl f e [a, b, c, d]
14:11:02 <lambdabot>   f (f (f (f e a) b) c) d
14:11:11 <bl> ah
14:11:19 <wioux> if you know ruby or smalltalk or some such, fold is basically inject
14:11:20 <bl> thanks!
14:11:41 <bl> there was like 3 paragraphs explaining what that was, which confused me more
14:11:46 <bl> thanks guys
14:12:48 <kmc> ruby calls it inject?
14:12:50 <kmc> weird
14:13:01 <kmc> in most languages i know it's either "reduce" or "fold"
14:13:50 <wioux> think its from smalltalk
14:13:53 <wioux> where its inject:into:
14:13:57 <mauke> I think there are other *ject functions
14:14:32 <wioux> e.g. #(0 1 2 3) inject: 0 into: [:x :y | x + y]
14:14:40 <kmc> is that smalltalk syntax?
14:14:50 <wioux> yeah
14:15:27 <wioux> which in haskell is foldl (+) 0 [0..3]
14:15:53 <obfuscated> hello, can someone explain this type: "Fcgi.getInput :: (Fcgi.MonadCGI m) => String -> m (Maybe String)" or point to a reference explaining it. The part I don't understand is why the result has two monads in it and how to pass a value returned from this function to another function?
14:16:45 <mauke> obfuscated: did you mean: three monads
14:17:22 <Oejet> obfuscated: It does not seem to return two monads, only one namely 'm'.
14:17:36 <mauke> Oejet: Maybe and [] are monads too
14:17:41 <kmc> obfuscated, does it matter that Maybe is a monad here?
14:18:24 <kmc> obfuscated, do { x <- getInput "foo"; case x of { Nothing -> putStrLn "bleh"; Just y -> f y } }
14:18:49 <Oejet> mauke: Heh, you are of course right.
14:18:51 <Eelis> if i have f::Int->a and want to build an O(1)-indexable array of the values f 0 ... f n, what is the most efficient way to construct such an array? all the constructors in Data.Array seem to take association lists as input, and building a temporary list feels wasteful here
14:19:22 <kmc> obfuscated, of course you might use some of the Data.Maybe functions to make that nicer
14:19:24 <Eelis> ok, listArray doesn't take an _association_ list, but it /does/ take a list
14:19:25 <kmc> e.g. fromMaybe, maybe
14:19:40 <ClaudiusMaximus> Eelis: lists are loops, if you only use it once it won't take up any memory
14:19:50 <kmc> Eelis, ideally the production of your list will fuse with the consumption by listArray
14:20:08 <Eelis> ClaudiusMaximus / kmc: ah, that makes sense. i will just hope for the best then :)
14:20:11 <kmc> lists are part control-flow and part data-structure; they're a way to compose producers and consumers into co-routines
14:20:40 <wioux> f itself could act as the "array" maybe?
14:20:55 <Eelis> wioux: i want to build the array for memoization purposes
14:20:59 <kmc> Eelis, i believe this optimization would be evident in ghc's Core output, if you want to confirm that it's taking place
14:21:01 <wioux> if it can be computed in constant time
14:21:02 <wioux> ah
14:21:37 <kmc> btw the regular Array type will be lazy, your memoized values will be computed on-demand
14:21:42 <kmc> which is usually what you want for memoization
14:21:48 <Eelis> yes, it is
14:21:52 <Oejet> obfuscated: Another way to use the value inside the monad 'm' is like this (equivalent to kmc's suggestion): getInput "foo" >>= \x -> case x of { Nothing -> ... }.
14:21:57 <kmc> data-memocombinators has an interesting different approach to memoization, using laziness to build memo tries
14:22:39 <orlandu63> Oejet: i don't think that would work
14:22:52 <orlandu63> wait nevermind
14:22:53 <orlandu63> yes it would
14:22:57 <orlandu63> disregard
14:23:04 <obfuscated> kmc Oejet: is the case required and can I move it in a function?
14:24:02 <kmc> you can move it into a function yes
14:24:26 <kmc> basically the point is that there's no special interaction between the fact that m is a Monad and the fact that Maybe is a monad (and the fact that [] in String = [Char] is a monad)
14:24:53 <kmc> if «x :: m (Maybe a)», then you can say «do { y <- x; ... }» and work with «y :: Maybe a» as you would any other Maybe value
14:25:16 <kmc> composing monads like «M1 (M2 (M3 a))» does not combine their "effects"; for that we use monad transformers
14:26:34 <Oejet> obfuscated: If you know the result will not be Nothing, you can use: getInput "foo" >>= (f . fromJust), where f is a function taking a String.
14:27:51 <obfuscated> OK, thank you all, now I'll have to test your suggestions :)
14:30:01 <kmc> fromJust considered harmful
14:30:31 <kmc> if your assumption (not Nothing) is wrong, you'll get a very unhelpful runtime error message and program crash
14:30:39 * monochrom considered harmful
14:30:40 <benmachine> "considered harmful" considered harmful
14:30:42 <Oejet> kmc: Especially when it comes from user input!
14:31:15 <monochrom> well-proved programs can't go wrong
14:31:19 <Eelis> fix (++ " considered harmful")
14:31:22 <applicative> > fromJust Nothing
14:31:23 <lambdabot>   *Exception: Maybe.fromJust: Nothing
14:31:30 <kmc> «fromMaybe (error "my more helpful message")» is a bit better
14:31:33 <applicative> works great!
14:32:00 <benmachine> kmc speaks the truth
14:32:14 <applicative> > head []
14:32:15 <lambdabot>   *Exception: Prelude.head: empty list
14:32:19 <kmc> thanks benmachine
14:32:21 <applicative> Couldnt live without it!
14:32:47 <kmc> i'd reserve fromJust for cases where you have an obvious local reason that it can't be Nothing
14:33:08 <ljungk> why can't I do x <- [1,2,3,4] at the ghci prompt? I have no idea what it would do, but [] is a monad right?
14:33:09 <kmc> and in those situations, you can usually (but not always) explain why it's obvious to the type checker, and thus avoid runtime-checked operations entirely
14:33:19 <kmc> ljungk, the GHCi prompt is in the IO monad specifically
14:33:37 <kmc> but you can write «do x <- [1,2,3,4]; return (3+x)»
14:33:43 <kmc> which is just an expression and so evaluates like any other
14:33:45 <ljungk> kmc ah
14:34:36 <orlandu63> > fmap (+) [1,2,3,4]
14:34:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:34:37 <lambdabot>    arising from a use of `...
14:34:41 <orlandu63> > fmap (+3) [1,2,3,4]
14:34:42 <lambdabot>   [4,5,6,7]
14:34:59 <heatsink> let {f Nothing Nothing = 0; f x y = fromJust $ x `mplus` y}
14:35:19 * heatsink considers that a legitimate use of fromJust
14:36:14 <Shikaga> I saw wondering, how can you do square numbers using fmap?
14:36:26 <heatsink> what's a square number?
14:36:42 <aristid> > fmap (^2) [1..]
14:36:43 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
14:36:48 <aristid> Shikaga: like this?
14:36:50 <Shikaga> thanks
14:36:53 <orlandu63> or just map
14:36:58 <aristid> orlandu63: he asked for fmap
14:37:02 <aristid> *shrug*
14:37:49 <Shikaga> Sorry, I started haskell about 4mins ago, don't know the dif. between fmap and map
14:38:31 <tensorpudding> Shikaga: map is the same as fmap, except fmap is more general
14:38:43 <benmachine> fmap can do everything that map can do
14:38:45 <benmachine> and more!!
14:38:53 <Shikaga> I see
14:38:56 <tensorpudding> map works only for lists, whereas fmap works for arbitrary kinds of "collections"
14:39:11 <Shikaga> Got it
14:39:22 <copumpkin> > fmap fmap fmap succ [Just 5, Nothing, Just 3]
14:39:23 <lambdabot>   [Just 6,Nothing,Just 4]
14:39:25 <tensorpudding> there's a technical term, Functor, that describes what a collection is, which essentially that you can define fmap for it
14:39:31 <tensorpudding> and fmap is defined for lists to be map
14:39:45 <copumpkin> > fmap fmap fmap fmap fmap succ [Just [5, 3], Nothing, Just [2, 3, 7]]
14:39:46 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
14:39:55 <copumpkin> damn, I failed
14:40:01 <tensorpudding> fmap means, "take this function and apply it to every element in the collection, without changing the shape of the collection"
14:40:07 <copumpkin> :t fmap fmap fmap fmap fmap
14:40:07 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
14:40:14 <aristid> copumpkin: you will lose your co-
14:40:15 <copumpkin> oh noes
14:40:24 <obfuscated> so I've come to this:
14:40:25 <obfuscated> """"greet3 :: m Html
14:40:25 <obfuscated> greet3 = do mUsername <- Fcgi.getInput "username"
14:40:25 <obfuscated>             return (case mUsername of
14:40:25 <obfuscated>                 Nothing -> (h1 << "no username")
14:40:25 <obfuscated>                 Just mUsername -> (h1 << mUsername))"""
14:40:26 <obfuscated> What should be the value for m? Also If I don't provide a type declaration I get a monomorphism error
14:40:29 <ClaudiusMaximus> so i've hacked a version of dons' gc tuner that should (if i got it right) use a metric output by the program itself rather than runtime - chances are i got it wrong and will need to retry..
14:40:38 <copumpkin> obfuscated: please don't paste in here
14:40:41 <copumpkin> @where hpaste
14:40:41 <lambdabot> http://hpaste.org/
14:41:13 <obfuscated> copumpkin: sorry, won't happen again
14:41:15 <copumpkin> obfuscated: why are you putting it all in a do block?
14:41:22 <copumpkin> obfuscated: no problem!
14:42:01 <obfuscated> I will have two getInput calls at some point
14:42:09 <copumpkin> ah
14:42:13 <copumpkin> what's the type of getInput?
14:42:16 <BMeph> obfuscated: hatswih the """ - are you trytiyn ou Haskl? ;0
14:42:16 <copumpkin> IO I assume?
14:42:25 <BMeph> *What's with
14:42:30 <copumpkin> BMeph: wow, I'm impressed
14:42:31 <BMeph> ...
14:42:44 <copumpkin> that was pretty mangled :P
14:42:55 <wioux> whats happening when you line up the fmaps like that? i've never seen it
14:43:08 <obfuscated> BMeph: """ are markings for the start/end of the code segment :)
14:43:09 <copumpkin> wioux: fmap has an instance for functions
14:43:11 <mauke> DON'T CROSS THE FMAPS
14:43:22 <copumpkin> wioux: and fmap on functions is just function composition (it has to be)
14:43:35 <copumpkin> onoes
14:43:51 <obfuscated> copumpkin: this is the type "Fcgi.getInput :: (Fcgi.MonadCGI m) => String -> m (Maybe String)"
14:44:01 <copumpkin> omg a MonadCGI
14:44:15 <BMeph> Checking the batteries (the downside to a wireless keyboard)...
14:44:22 <copumpkin> obfuscated: might as well leave it polymorphic though
14:44:28 <copumpkin> m needs to be an instance of MonadCGI though
14:44:48 <orlandu63> is there a way for ghc to make sure a function contains pattern matchings for all possible values of its arguments's type?
14:44:51 <Ytinasni> "greet3 :: (Fcgi.MonadCGI m) => m Html"
14:44:53 <copumpkin> it looks like CGIT m is the only instance
14:45:02 <copumpkin> a transformer, that is
14:45:12 <copumpkin> orlandu63: just ask for warnings
14:45:18 <copumpkin> it'll give you a warning for incomplete pattern matches
14:45:27 <heatsink> orlandu63: -fwarn-incomplete-patterns
14:45:39 <orlandu63> why isn't ghc strict about that?
14:45:43 <copumpkin> there's also -Wall
14:46:16 <heatsink> Partial programs are useful
14:46:56 <wioux> but how can you give it more than 2 arguments? is there some kind of unseen association going on? (e.g. fmap is 2-ary, so how can you fmap fmap fmap fmap)
14:47:12 <aristid> :t fmap . fmap
14:47:13 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:47:18 <aristid> :t fmap `fmap` fmap
14:47:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:47:26 <heatsink> It's easier to demonstrate with flip
14:47:28 <heatsink> :t flip
14:47:29 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:47:35 <copumpkin> :t fmap fmap fmap
14:47:35 <ski> obfuscated : you saw Ytinasni's suggestion above ?
14:47:35 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:47:36 <aristid> heatsink: very funny
14:47:44 <copumpkin> :t fmap fmap fmap -- same as fmap . fmap
14:47:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:48:09 <aristid> heatsink: when i use . between to fmap, caleskell does not kick in, i think
14:48:15 <wioux> :t fmap fmap fmap fmap
14:48:15 <copumpkin> :t fmap fmap fmap fmap -- now the fourth fmap takes the places of the (a -> b), affecting the other things appropriately
14:48:16 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
14:48:16 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
14:48:18 <obfuscated> ski: yes it works:) 
14:48:19 <aristid> :t fmap Prelude.. fmap
14:48:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:48:25 <aristid> yeah, it doesn't
14:48:47 <copumpkin> aristid: there's only one option there, it can't
14:48:49 <ski> (obfuscated : i would omit the brackets around the class constraint in this case, though .. just a style issue)
14:49:19 <aristid> copumpkin: that's what i thought, but i constantly make mistakes, so i wanted to go sure
14:49:51 <ski> @type \f g a -> (.) f g a
14:49:52 <lambdabot> forall t a b. (Functor ((->) t)) => (a -> b) -> (t -> a) -> t -> b
14:50:07 <yitz> before i try this and trash my system - how do i *upgrade* HP on the Mac? instructions on the site are for installation.
14:50:17 <McManiaC> :t repeat fmap
14:50:18 <McManiaC> ;)
14:50:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
14:50:22 <ski> @type (\f g a -> (.) f g a) :: (a -> b) -> (t -> a) -> t -> b
14:50:23 <lambdabot> forall a b t. (a -> b) -> (t -> a) -> t -> b
14:50:37 <wioux> maybe.. can you parenthesize it so its clear what the argument(s) to the first fmap are in fmap fmap fmap fmap?
14:50:56 <ski> @type (ap . repeat) fmap
14:50:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => [a -> b] -> [f a -> f b]
14:51:18 <ski> @type (zipWith ($) . repeat) fmap
14:51:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => [a -> b] -> [f a -> f b]
14:51:34 <dancor> :t iterate . fmap
14:51:35 <lambdabot> forall b (f :: * -> *). (Functor f) => (b -> b) -> f b -> [f b]
14:52:28 <ski> @type map fmap
14:52:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => [a -> b] -> [f a -> f b]
14:53:54 <heatsink> yitz: Is your current GHC the same version as the new Haskell Platform 
14:54:06 <wioux> fmap fmap fmap = (fmap . fmap)?
14:54:14 <ski> yes
14:54:23 <yitz> heatsink: installed it using the mac HP installer
14:54:27 <yitz> including ghc
14:54:45 <yitz> previous version. of course
14:55:05 <kmc> in Caleskell, fmap = (.)
14:55:14 <wioux> fmap fmap fmap fmap = (fmap . fmap . fmap)?
14:55:17 <kmc> (.) is fmap specialized to the ((->) r) functor
14:55:19 <kmc> i guess
14:55:23 <wioux> sorry, have never heard of Caleskell
14:55:53 <chrisdone> agh it's like buffalo
14:55:54 <dobblego> @type fmap
14:55:54 <ski> kmc : doesn't matter for `fmap fmap fmap = fmap . fmap'
14:55:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:56:13 <yitz> @type fmap fmap fmap fmap
14:56:14 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
14:56:23 <yitz> @type fmap . fmap . fmap
14:56:23 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:56:29 <dobblego> wioux, in the type "(a -> b) -> f a -> f b" then replace every f with t -> and put in appropriate parentheses
14:56:34 <yitz> nope
14:57:47 <dancor> @pl fmap fmap fmap
14:57:47 <lambdabot> fmap fmap fmap
14:58:04 <chrisdone> @type buffalo buffalo buffalo buffalo
14:58:05 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
14:59:29 <kmc> wioux, Caleskell is our cheeky name for lambdabot's default environment, which hides some Prelude functions and replaces them with more general equivalents
14:59:30 <kmc> e.g.
14:59:31 <kmc> :t (.)
14:59:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:59:44 <kmc> :t map
14:59:45 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:59:48 <kmc> hmm not that one
15:00:01 <wioux> ah
15:00:14 <yitz> wioux: these identities are not trivial - for example, note that (.)(.)(.)(.)(.)(.) == (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
15:00:47 <drhodes> f x >> f y >> f z ... there's a shortcut for this, right? 
15:00:50 <chrisdone> in the words of Keanu Reeves, woah
15:01:06 <heatsink> drhodes: mapM_ f [x,y,z]
15:01:13 <drhodes> heatsink: thanks!
15:01:36 <chrisdone> that assumes f z :: Monad m => m ()
15:01:54 <heatsink> yitz: I dunno.  Looks like it will overwrite some of your executables and shared data files.
15:02:00 <kmc> it also assumes that they have the same type
15:02:08 <kmc> that x,y,z do
15:02:29 <yitz> heatsink: it's the "some of" part that I'm worried about. if it overwrote either none or all that would be ok.
15:02:42 <arjanb> is it possible to have a list with existential typed elements, without defining a wrapper data type for the elements?
15:02:59 <chrisdone> the wrapper data type is the existential type
15:03:31 <wioux> yitz: will it ever be practical for me to viscerally understand such an identity, as opposed to taking your word on it? :)
15:03:46 <wioux> has anyone ever used fmap fmap ...?
15:03:55 <yitz> wioux: heh. i found it using @type on lambdabot. :)
15:04:03 <benmachine> wioux: I've used fmap . fmap before I think
15:04:16 <benmachine> e.g. with IO (Maybe x)
15:04:32 <kmc> it's a good exercise in type inference to work out the type of (fmap fmap fmap) by hand
15:04:34 <arjanb> i can write down [forall a. Foo a] but that gives type errors when used
15:04:34 <heatsink> yitz: Libraries go in compiler-specific subdirectories.  Libraries for a new compiler version don't overwrite the old.
15:04:44 <kmc> arjanb, not in GHC.  in some other compilers yes
15:04:53 <kmc> [forall a. Foo a] is a different type from [exists a. Foo a]
15:05:07 <kmc> but GHC does not support the "exists" quantifier directly, which is why you need the wrapper
15:05:12 <kmc> in UHC you can just write it thus
15:05:15 <chrisdone> i think the former has an extension but its deprecated until we have somethig better
15:05:29 <benmachine> isn't [forall a. a] impredicative or something
15:05:32 <kmc> yes
15:05:32 <chrisdone> yeah
15:05:33 <yitz> heatsink: ok, so if it replaces all of the executables, that's fine. though i need the disk space, i need to figure out how to get rid of the old HP without leaving a mess.
15:05:34 <chrisdone> that's the one
15:05:38 <copumpkin> benmachine: yeah
15:05:41 <chrisdone> what does impredicative mean?
15:05:42 <kmc> it's a polymorphic type applied to another polymorphic type
15:05:44 <copumpkin> that's still different though
15:06:01 <yitz> heatsink: if it replaces only *some* of the executables, that could be a real problem.
15:06:15 <copumpkin> [forall a. a] can only contain undefined
15:06:19 <kmc> if Q is an "impredicative" quantifier, it means it's used as «Q x. e» where x ranges over the same sort of thing as e
15:06:20 <copumpkin> it's basically isomorphic to nat
15:06:38 <kmc> or rather, the same sort of thing as the whole «Q x. e»
15:06:45 <kmc> ordinarily you can only instantiate a type variable at a monotype
15:06:57 <kmc> and so polytypes have quantifiers ranging over monotypes, and so are predicative
15:08:02 <heatsink> yitz: I don't think any programs have been removed from the platform, so they'll all be replaced
15:08:19 <arjanb> thanks for clearing up my confusion, now i would like 'exists' in next haskell standard
15:08:39 <copumpkin> :)
15:08:52 <copumpkin> existentials are overrated anyway
15:09:09 <heatsink> yitz: As for how to delete the old stuff, uh... maybe find and delete all the files that are older than your upgrade?
15:09:47 <yitz> heatsink: yeah. or just rip out anything in folders marked with the old ghc version number. yuck.
15:09:48 <kmc> arjanb, Haskell 2010 was far more conservative than that, but perhaps for 2011 they'll consider it
15:10:06 <kmc> btw i do find impredicative types to be useful, but the solution to them going away is easy enough: as with existentials, declare a wrapper type
15:10:48 <kmc> UHC, JHC, Hugs all have some useful extensions that GHC is missing
15:10:52 <copumpkin> you can encode an existential in a function
15:11:02 <yitz> kmc: to get exists into a haskell standard, first convince the ghc team to implement it.
15:11:04 <benmachine> UHC has the exists keyword?
15:11:07 <kmc> yes
15:11:14 <kmc> but it doesn't support type class constraints in existentials
15:11:19 <benmachine> hmm, maybe haskell-src-exts should have it
15:11:47 <yitz> benmachine: isn't haskell-src-exts based on ghc extensions only?
15:12:11 <benmachine> yitz: nah, it has a fair few non-GHC things
15:12:19 <yitz> intersting.
15:12:21 <benmachine> it has kind variables :O
15:12:29 <benmachine> which just make no sense but whatever :P
15:12:36 <heatsink> benmachine: Can you do that?
15:12:45 <heatsink> I mean
15:12:57 <heatsink> Maybe if you don't use kinds to distinguish boxed from unboxed types
15:13:18 <kmc> is there a serious downside to CPS-transforming existentials into rank-2 types?
15:13:24 <kmc> do you lose sharing or something?
15:13:33 <kmm> @pl (\c -> c == '0' || c == '1')
15:13:33 <lambdabot> liftM2 (||) ('0' ==) ('1' ==)
15:14:00 <benmachine> heatsink: I don't know what kind variables are for at all
15:14:00 <kmc> kind polymorphism is useful: http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html
15:14:04 <benmachine> but HSE parses them
15:14:27 <benmachine> oh right
15:14:29 <benmachine> interesting!
15:17:19 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28450#a28450
15:17:27 <copumpkin> existentials!
15:20:35 <copumpkin> well that shut people up
15:21:32 <benmachine>  we're all in awe
15:21:47 <copumpkin> wouldn't it be nice if seq had an associated typeclass constraint that you couldn't write instances of, but everything was automatically an instance of it?
15:21:57 <copumpkin> it'd just be nice to have some indication of its use in the type
15:22:11 <benmachine> and then we'd get parametricity magic back?
15:22:41 <copumpkin> it'd be less voodooish, it seems
15:22:47 <kmm> >1+1
15:22:51 <kmm> > 1+1
15:22:53 <lambdabot>   2
15:23:00 <kmm> > let 1+1=3
15:23:01 <lambdabot>   not an expression: `let 1+1=3'
15:23:10 <benmachine> you couldn't write instances of it wouldn't have to be encoded in the language as such, because every instance would be overlapping :P
15:23:21 <benmachine> and as everyone knows, there are no extensions that enable overlapping instances.
15:23:45 <kmc> > let 1+1=3 in 1+1
15:23:46 <lambdabot>   3
15:23:51 <copumpkin> :)
15:24:13 <kmc> copumpkin, iirc it was so in a pre-98 version of Haskell
15:25:14 <kmc> if you have a «instance Seq a where ...» then it will get reduced out of contexts
15:25:23 <benmachine> I've heard there used to be a typeclass, but it got removed because it made refactoring a pain in the
15:25:26 <benmachine> thing
15:25:32 <kmc> you need to hide the existence of this instance until after context reduction, i think
15:25:51 <aristid> kmc: why does let 1+1 = 3 in ... work?
15:26:01 <yitz> heatsink: cool! the new HP installer knows how to uninstall the old ghc as one of its installation steps!
15:26:10 <benmachine> aristid: re-defining + with numeric patterns
15:26:16 <ClaudiusMaximus> > let 1 + 1 = 3 in 2 + 2
15:26:17 <benmachine> > let 1 + 1 = 3 in 2 + 1
15:26:17 <lambdabot>   *Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
15:26:18 <lambdabot>   *Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
15:26:43 <aristid> benmachine: numeric patterns allow every part of the pattern to be numeric?!
15:26:55 <aristid> oh, wait
15:26:58 <aristid> it does make sense
15:27:10 <aristid> sorry for being stupid :(
15:28:08 <benmachine> :P
15:28:12 <benmachine> happens to us all
15:28:15 <benmachine> except me of course!!
15:28:44 <dancor> what a stupid joke
15:30:04 <heatsink> yitz: Awesome.
15:30:51 <heatsink> Them's some pretty graphics on the Haskell Platform page.
15:30:55 <kmc> > let ()+() = "foo" in ()+()
15:30:57 <lambdabot>   "foo"
15:31:03 <kmc> > let _+_ = "foo" in 2+7
15:31:04 <lambdabot>   "foo"
15:31:31 <heatsink> Anyone know who made it?
15:32:09 <benmachine> heatsink: it turned up on haskell-cafe, let's see if I can find it
15:32:10 <dancor> it's ubuntu-tastic
15:34:06 <benmachine> heatsink: chrisdone, I think
15:34:08 <benmachine> who... isn't here
15:34:30 <DarkMalloc> copumpkin: did you say haskell was supported on iOS?
15:34:35 <DarkMalloc> like, jailbroken ofc.
15:35:31 <yitz> chrisdone was here a few minutes ago. must have just left.
15:35:38 <yitz> preflex: seen chrisdone
15:35:39 <preflex>  chrisdone was last seen on #haskell-blah 27 minutes and 55 seconds ago, saying: man i walked 6 miles most of which was up hill in the roasting sun. now i'm really tired. it would've been alright but i didn't drinke nough water
15:36:34 <benmachine> 23:07:22 -!- chrisdone [~user@unaffiliated/chrisdone] has quit [Quit: bed]
15:37:29 <ski> kmc : (re kind polymorphism) great fun !
15:37:51 <copumpkin> DarkMalloc: there's hugs on it, but nothing else for now. JHC can generate C that can be compiled anywhere though
15:38:12 <DarkMalloc> oh that's pretty cool.
15:38:20 <DarkMalloc> copumpkin: how hard do you think it would be to get GHC running?
15:38:33 <copumpkin> pretty hard
15:38:40 <DarkMalloc> hmm
15:39:14 <ski> copumpkin : nice. when i saw `Exists', i expected `data Exists f = forall x. Wrap (f x)', though ..
15:39:50 <copumpkin> ski: that would've been nicer, you're right
15:40:21 <copumpkin> working on arity polymorphism now!
15:40:55 <ski> (i'll have to remember that this `ftw' is an example of rank-`n' types, with `n' greater or equal to `3')
15:41:31 <ski> copumpkin : how do you mean ?
15:41:52 <copumpkin> it's in agda but I did this (less sophisticated) in haskell a while ago too
15:42:00 <copumpkin> things like zipWithN
15:42:05 <copumpkin> but for a more complicated function
15:42:11 <copumpkin> with a fairly regular type structure
15:42:37 <copumpkin> (I love dependent functions)
15:42:58 <monochrom> they are lovely
15:43:56 <copumpkin> take http://snapplr.com/mh93
15:44:05 <copumpkin> I'm building those programmatically
15:47:05 <ski> how does that work ?
15:47:49 <copumpkin> the function?
15:48:14 * hackagebot data-category 0.2.0 - Restricted categories  http://hackage.haskell.org/package/data-category-0.2.0 (SjoerdVisscher)
15:48:20 <ski> i assume `(sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> (sh4 -> d) -> (sh5 -> e)' defines each `e' element at `sh5' position(?), given functions that index the four input arrays at any given positions
15:48:40 <copumpkin> yeah
15:48:54 <copumpkin> I leave out the (sh1 -> sh2 -> sh3 -> sh4 -> sh5) function
15:49:03 <copumpkin> it's an artifact of the lack of dependent types
15:49:28 <ski> i'm not sure what `sh1 -> sh2 -> sh3 -> sh4 -> sh5' is for, though .. somehow computing dimensions of output array from dimensions from input array ?
15:49:40 <ski> hm
15:50:03 <copumpkin> yeah, they have type-level "shapes" (a type-level list), value-level extents, which specify the dimensions of the array, then value-level indices
15:50:10 <copumpkin> (this is from repa)
15:50:38 <copumpkin> so a shape is Z :. Int :. Int :. Int indicating three dimensions, an extent might be Z :. 3 :. 4 :. 6
15:50:47 <copumpkin> and an index is indistinguishable from an extent
15:50:54 <kmc> DarkMalloc, did you see http://projects.haskell.org/ghc-iphone/
15:51:20 <kmc> you can't run GHC on your iOS device, but you can build code for it using GHC on a computer
15:51:30 <DarkMalloc> no I didn't, thanks kmc :D
15:51:41 <kmc> and no jailbreaking required, as long as Apple doesn't decide to enforce their stupid rules against your Haskell-using app
15:51:59 <copumpkin> he wanted it on the device I think
15:52:24 <kmc> perhaps you could use ghc-iphone to build jhc
15:52:41 <kmc> is there a hosted c compiler for (jailbroken) iphone?
15:52:47 <copumpkin> yeah
15:53:06 <kmc> it boggles the mind that people want to buy a platform where they have to jump through these hoops
15:53:08 <ski> (also, my sense of aesthetics suggests to me that i'd prefer `forall sh0 sh1 sh2 sh3 sh4 e0 e1 e2 e3 e4. (Shape sh0,Shape sh1,Shape sh2,Shape sh3,Shape sh4,Elt e0,Elt e1,Elt e2,Elt e3,Elt e4) => (sh0 -> sh1 -> sh2 -> sh3 -> sh4) -> ((sh0 -> e0) -> (sh1 -> e1) -> (sh2 -> e2) -> (sh3 -> e3) -> (sh4 -> e4)) -> (Array sh0 e0 -> Array sh1 e1 -> Array sh2 e2 -> Array sh3 e3 -> Array sh4 e4)'
15:53:10 <kmc> i understand that most users are not programmers
15:53:18 <copumpkin> kmc: yeah :P
15:53:20 <ski> copumpkin : `repa' ?
15:53:24 <kmc> but i'm amazed how many of the programmers i know have iPhones
15:53:40 <copumpkin> ski: regular parallel arrays, the dph side-project
15:53:58 <anair_84> @yow
15:53:59 <lambdabot> Couldn't find fortune file
15:54:03 <anair_84> @yow
15:54:04 <lambdabot> Couldn't find fortune file
15:54:08 <copumpkin> kmc: those of us who don't like it figure out ways to break the restrictions :P
15:54:45 <benmachine> I want to get an android phone
15:54:48 <copumpkin> ski: good point about the order there
15:54:53 <benmachine> but I can never be bothered to work out which ones are good
15:55:00 <copumpkin> ski: I might adopt your ordering
15:57:09 <ski> copumpkin : .. hm, i wonder if one could do something `ap'-like there
15:57:51 <copumpkin> this is my rendition of the type for one array, traverse : ∀ {sh sh' A B} → Array sh A → ((Index sh → A) → Index sh' → B) → Array sh' B
15:57:59 <kmc> copumpkin, sure, you're still giving loads of money to companies which think they can own what they sell to you
15:58:16 <copumpkin> kmc: that's fine, I like the device :P
15:58:34 <kmc> you're directly funding their efforts to make the next version even harder to hack
15:58:39 <copumpkin> I knew what I was getting into
15:58:56 <copumpkin> yeah, I've also contributed to that in other ways :P
15:59:17 <kmc> you're also funding the proliferation of devices which are anti-learning, such that fewer and fewer children will receive a programmable device as a hand-me-down
15:59:27 <kmc> anyway we've had this argument before
15:59:34 <copumpkin> am I clubbing baby seals too?
15:59:39 <kmc> and perhaps should move it to #haskell-blah
15:59:40 * copumpkin pulls out his club
16:00:39 <DarkMalloc> copumpkin: looks like I'm definitely going to AngloHaskell :)
16:00:46 <copumpkin> DarkMalloc: yay
16:00:49 <copumpkin> I won't be there though
16:00:50 <DarkMalloc> :)
16:00:52 <DarkMalloc> :(
16:00:53 <DarkMalloc> :P
16:00:56 <copumpkin> I'm anglo at heart
16:00:59 <copumpkin> well, not really
16:01:04 <copumpkin> but I'm anglo at passport
16:01:05 <DarkMalloc> copumpkin: you suck for not being there -.-
16:01:05 <DarkMalloc> ;)
16:01:08 <copumpkin> anyway, #haskell-blah :P
16:01:09 <kmc> ☭
16:01:11 <DarkMalloc> joking ofc ;)
16:01:14 <copumpkin> lol
16:01:20 <DarkMalloc> copumpkin: so you're from England?
16:01:52 <copumpkin> #haskell-blah and all your questions shall be answered!
16:02:13 <DarkMalloc> um, ok? :P
16:02:33 <copumpkin> join it :P
16:02:38 <DarkMalloc> I am
16:02:39 <DarkMalloc> :P
16:02:42 <copumpkin> that stuff is off-topic in here
16:02:46 <ski> copumpkin : ok (but i'd still think it preferable to have more consistency in the naming .. either (say) `s',`t',`u',&c. and `a',`b',`c',&c. .. or `sh0',`sh1',`sh2',&c. and `e0',`e1',`e2',&c. -- that way the correspondence between the shape types and the element types are more manifestly obvious)
16:04:13 <ski> (btw, are you extracting Haskell code ?)
16:04:22 <kmc> s'pose i want to open a window, draw some colored rectangles, and take keyboard input with a minimum of hassle
16:04:31 <kmc> what's a good library for this? Graphics.DrawingCombinators	?
16:04:46 <copumpkin> ski: eventually possibly :P 
16:04:58 <copumpkin> ski: doubt it actually, but it's almost haskell anyway
16:05:03 <copumpkin> it's just a "thought experiment"
16:05:43 <dobblego> speaking of outrage, the iphone is costing me my Sunday
16:08:41 <copumpkin> okay, I've sacrificed homogeneity to satisfy the universe level gods
16:09:10 <monochrom> but not type level gods? :)
16:09:33 <copumpkin> I'm already their buddy
16:09:44 <ski> ("homogeneity" ?)
16:09:47 <copumpkin> but the universe level ones were bugging me about my type being in the wrong universe
16:10:10 <copumpkin> ugh, I messed up
16:10:27 <Saizan> so you went forward in time till the next?
16:11:04 <nus> erhm, are there any issue tracking/project management systems written in Haskell?
16:11:07 <copumpkin> I just generated the type: Array _1400 _1403 → Array _1401 _1404 → Array _1402 _1405 → {sh : Shape} {s : Set} → ((Index sh → s) → (Index _1400 → _1403) → (Index _1401 → _1404) → Index _1402 → _1405) → Array sh s
16:11:19 <copumpkin> not only fugly, but wrong
16:11:58 <Saizan> nus: i don't think so
16:13:20 <copumpkin> aargh
16:13:33 <copumpkin> this is remarkably hard
16:14:08 * nus ponders what's this 'iba CG' on the Haskell_in_industry page products really do: "...contract management, assert management, booking and budgeting software"
16:14:12 <copumpkin> it has so many non-local dependencies in the type
16:14:21 <ski> what is hard ?
16:14:30 <copumpkin> making that arity-polymorphic type :P
16:14:42 <ski> constructing it programatically ?
16:14:46 <copumpkin> yeah
16:14:53 <copumpkin> and once I generate the type, I need to actually write the function
16:14:55 <ski> in Agda2 ?
16:15:01 <copumpkin> yeah
16:15:20 <ski> using your or mine argument order ?
16:15:47 <copumpkin> I can change the argument order without much difficulty, but the main issue is bringing in the implicit shape and sets and getting them right
16:26:17 <copumpkin> ski: okay, fixed it, and it's in your order now
16:26:46 * ski is trying to write a function that generates the type in Agda2
16:27:23 <copumpkin> I can show you my code if you want
16:27:27 <copumpkin> it has lots of helper functions :)
16:27:55 * ski wants to try the generation, first
16:28:58 * mjrosenb fails at finding tutorials he read years ago
16:29:14 <ski> (which ?)
16:29:15 <mjrosenb> anyone happen to remember a haskell tutorial for oop like code
16:29:25 <mjrosenb> it was an arcade game
16:29:31 <mjrosenb> possibly asteroids like
16:29:39 * ski doesn't recall seeing that
16:29:52 <mjrosenb> and the idea was that rather than holding the state of the world in the datatypes
16:30:04 <mjrosenb> you held functions that modified the state of the world
16:31:11 <nphg|laptop> @yhjulwwiefzojcbxybbruweejw
16:31:11 <lambdabot> "\"#$%&'()*+,\""
16:31:32 <liyang> (My code. Let me show you it.)
16:31:47 <nphg|laptop> okp, and what does that mean? it has a some meaning, right?
16:33:21 <copumpkin> now, harder is to write the function itself
16:33:28 <luite> is there a way to wait for an MVar, but with some timeout?
16:37:42 <ClaudiusMaximus> mjrosenb: http://www.cse.chalmers.se/~wouter/Teaching/Asteroids.zip  perhaps (grepping my logs for asteroids)
16:40:00 <ClaudiusMaximus> maybe not
16:40:39 <copumpkin> ski: it's really hard writing the function itself :P
16:44:02 <mjrosenb> ClaudiusMaximus: yeah, that looks more like the standard functions are always on the outside thing
16:46:18 <ClaudiusMaximus> i'm sure i've seen/done something like that, but i can't remember where/what
16:47:23 <mjrosenb> ClaudiusMaximus: i'm in the same boat
16:50:01 <copumpkin> ski: now I'm back where I started :P http://snapplr.com/8wcs
16:51:24 <copumpkin> okay, I might have it
16:52:13 <Saizan> ?hoogle timeout
16:52:14 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
16:52:14 <lambdabot> module System.Timeout
16:52:14 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
16:52:33 <Saizan> luite: ^^^
16:53:13 <luite> ah thanks
16:55:56 <mjrosenb> copumpkin: you wouldn't happen to remember the paper/tutorial i'm thinking of, would you?
16:56:07 <copumpkin> nope, sorry :/
16:58:37 <mjrosenb> there should be a page on haskell.org with links to *every* haskell tutorial ever written :(
17:00:41 <copumpkin> you should make a project of it!
17:03:27 <mjrosenb> that sounds... time consuming
17:07:31 <nus> mjrosenb, http://cale.yi.org/index.php/A_look_at_OO_from_Haskell -- this one?
17:13:45 <mjrosenb> nus: YES!
17:14:27 <nus> good
17:14:39 <mjrosenb> copumpkin, cale, close enough
17:17:48 <ClaudiusMaximus> mm, ghc-gc-tune sure likes to run the program many times
17:18:57 <Saizan> how did you think it constructed the data, otherwise?:)
17:19:03 <ClaudiusMaximus> :)
17:19:15 <ClaudiusMaximus> i'm just fed up with waiting for it to finish
17:19:50 <ClaudiusMaximus> 1min per run; as i'm measuring frame jitter in an opengl app
17:20:51 <ClaudiusMaximus> it needs a curses UI with 2D progress bar
17:26:40 <ClaudiusMaximus> perhaps i could reduce jitter by adding more latency somewhere
17:29:10 <ClaudiusMaximus> render a couple of frames in advance and just blit a texture exactly on time...
17:30:47 <stragerLN> Hello; I'm going through Real World Haskell (http://book.realworldhaskell.org/read/functional-programming.html) and I'm re-implementing various Prelude functions as practice.  I've gotten all so far except 'words'.  I'm really stumped on this one.  Can someone guide me through it?
17:31:21 <ClaudiusMaximus> have you implemented 'break' yet?
17:31:25 <ClaudiusMaximus> :t break
17:31:26 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:31:47 <stragerLN> yes ClaudiusMaximus 
17:31:53 <stragerLN> hmm
17:32:01 <ClaudiusMaximus> :t dropWhile
17:32:01 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:32:08 <stragerLN> Yeah I think I got it now
17:32:14 <stragerLN> Thanks; lemme play around a bit
17:32:36 <ClaudiusMaximus> cool
17:32:45 <benmachine> copumpkin: hey, random thought, if you had a seq-with-typeclass-that-everything-is-in, would you then be able to differentiate between undefined and const undefined still?
17:32:58 <benmachine> I think it's that which breaks stuff most often
17:33:12 <benmachine> (I'd be quite happy with a seq that worked on everything except functions)
17:33:24 <sohum> quick question: does anyone /use/ leksah or vim for haskell editin?
17:33:32 <benmachine> I use vim
17:33:43 <benmachine> but I don't use any magic clevers
17:33:48 <benmachine> I just, write text?
17:33:50 <benmachine> and then compile it
17:34:00 <benmachine> I am basically a text-editor dinosaur
17:34:01 <sohum> corollary: is there a good smart indentation thing for said ide?
17:34:03 <benmachine> vim is nice though
17:34:11 <benmachine> I don't use smart indentation things
17:34:14 <benmachine> I use spacebar :P
17:34:19 * stragerLN too
17:34:43 <sohum> heh
17:34:45 <ClaudiusMaximus> i use geany, the only thing that annoys me about it with haskell is that it likes to aline indents to multiples of tab stops (which in my case is '2 spaces')
17:35:33 <ClaudiusMaximus> and sometimes the most natural layout is in between:  like 'do ...\n   ...' has 3 spaces
17:35:37 <sohum> I hadn't heard of geany before; would you say that it's a good haskell editor?
17:35:53 <tensorpudding> benmachine: you should try regressing to ed, it's only a few steps away
17:35:58 <liyang> ClaudiusMaximus: write do\n\t…\n\t...
17:36:02 <benmachine> tensorpudding: lol u
17:36:17 <tensorpudding> I've been trying ed for short scripts lately
17:36:19 <prsteele> hey all; I'm not quite sure how Haskell treats references to the same object, so bear with me... does "seq a a" return an evaluated "a"?
17:36:24 <benmachine> heh
17:36:25 <benmachine> how is it
17:36:36 <benmachine> prsteele: seq a a is identical to a
17:36:44 <ClaudiusMaximus> it's a simple editor with some syntax highlighting problems (eg M.map is highlighted as a DataConstructor) at least in the version i use
17:36:45 <tensorpudding> it might be redundant to say that the most difficult thing to get used to using a line editor is that you can only see one line at a time
17:36:49 <nus> prsteele, a is not an object
17:37:02 <ClaudiusMaximus> but it has extensive search/replace and gotoline etc
17:37:05 <benmachine> prsteele: "seq a b" means "evaluate a when you evaluate b"
17:37:09 <prsteele> benmachine: then how would I use "seq" to force the evaluation of "a"?
17:37:23 <copumpkin> rnf a `seq` a
17:37:24 <prsteele> so... "seq a (id a)"
17:37:25 <copumpkin> :P
17:37:26 <benmachine> prsteele: you can't force the evaluation of anything just arbitrarily
17:37:35 <copumpkin> prsteele: same thing
17:37:43 <copumpkin> prsteele: seq only forces to whnf
17:37:51 <benmachine> if you're doing, say, length [f x], then f can't possibly make x evaluated
17:37:51 <stragerLN> ClaudiusMaximus: Many thanks!  It works!  http://paste2.org/p/934673
17:37:52 <copumpkin> which you get anyway
17:37:55 <benmachine> because f isn't even executed
17:38:18 <benmachine> prsteele: the way I think of it is
17:38:30 <benmachine> you could implement seqInt with
17:38:32 <nus> prsteele, what would you use to force the evaluation of 'seq'?
17:38:37 <benmachine> seq a b = if a == 0 then b else b
17:39:11 <ClaudiusMaximus> stragerLN: close, but not quite the same as the report's specification
17:39:13 <copumpkin> or seqInt 0 b = b; seqInt n b = b
17:39:14 <benmachine> so it basically returns a value that, if you want to evaluate it, requires evaluating a first
17:39:20 <benmachine> copumpkin: yeah
17:39:44 <stragerLN> ClaudiusMaximus: Wait.  I was writing 'words' instead of 'mwords' in the console.  D'oh.
17:39:44 <prsteele> hm
17:39:50 <ClaudiusMaximus> stragerLN: and actually, does it terminate ?
17:39:57 <stragerLN> Nope.  =D
17:40:02 <copumpkin> prsteele: do you understand what whnf is?
17:40:20 <prsteele> copumpkin: no, I meant to ask
17:40:27 <ClaudiusMaximus> > words "    foo   bar   etc    "
17:40:28 <lambdabot>   ["foo","bar","etc"]
17:40:34 <copumpkin> weak head normal form, basically means reducing something down to the outermost constructor
17:40:52 <copumpkin> so [1,2,3] would get reduced to ? : ?
17:40:56 <benmachine> so evaluating a Maybe value evaluates it enough to tell whether it's Just or Nothing
17:40:59 <copumpkin> where ? and ? are unevaluated
17:41:01 <benmachine> but not enough to tell what's in the Just
17:41:23 <prsteele> copumpkin: what is ?
17:41:26 <benmachine> (er, evaluating it to whnf)
17:41:33 <ClaudiusMaximus> @hoogle space
17:41:33 <lambdabot> Text.Parsec.Char space :: Stream s m Char => ParsecT s u m Char
17:41:34 <lambdabot> Text.PrettyPrint.HughesPJ space :: Doc
17:41:34 <lambdabot> Language.Haskell.TH.PprLib space :: Doc
17:41:38 <benmachine> prsteele: it's not haskell syntax, it just meant "unevaluated things"
17:41:50 <ClaudiusMaximus> @hoogle isSpace
17:41:50 <lambdabot> Data.Char isSpace :: Char -> Bool
17:41:50 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
17:41:50 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
17:42:08 <prsteele> copumpkin: okay, that makes sense
17:42:16 <burp> what's that haskell evaluation library named? (like lambdabots)
17:42:28 <copumpkin> prsteele: the weak has to do with what it does with functions, but that's just a subtlety
17:42:34 <ClaudiusMaximus> burp: mueval?
17:42:35 <stragerLN> ClaudiusMaximus: I haven't learned isSpace yet, and I'd rather stick to what has been taught so far =]
17:42:38 <copumpkin> burp: mueval or luna
17:42:39 <benmachine> burp: mueval, which uses hint
17:42:54 <benmachine> which uses ghc-as-a-library
17:42:54 <copumpkin> might not even be able to find luna anymore :/
17:42:56 <benmachine> I think
17:43:01 <benmachine> was luna mmorrow's?
17:43:04 <copumpkin> yeah
17:43:10 <benmachine> dang
17:43:12 <copumpkin> and his hosting is down now and his code lived there
17:43:13 <prsteele> so a more general question, then... I'm only using tail recursion, but I'm running out of stack space, which makes me think I'm accumulating too many thunks... might this be correct?
17:43:13 <benmachine> dude left a hole in haskell
17:43:26 <burp> ah yes, mueval thanks
17:43:32 <copumpkin> prsteele: yeah, tail recursion isn't nearly as useful in haskell as elsewhere
17:44:15 <copumpkin> prsteele: but yeah, the only way you can run out of stack space in haskell is when evaluating deeply nested thunks
17:44:30 <benmachine> I thought thunks went on the heap
17:44:32 <benmachine> or something
17:44:35 <copumpkin> they do
17:45:00 <copumpkin> but the process of evaluating them uses stack
17:45:21 <benmachine> oh, right
17:45:48 <prsteele> this is frustrating, this code would run in a second in a non-lazy language
17:45:49 <stragerLN> ClaudiusMaximus: okay; I think I (really) got it, but it's kinda messy.  Suggestions?  http://paste2.org/p/934680
17:45:58 <benmachine> prsteele: what is it?
17:46:14 <copumpkin> prsteele: usually replacing foldl with foldl' will solve your problem
17:46:17 <copumpkin> foldl is "tail-recursive"
17:46:42 <prsteele> benmachine: think of counting, where you continually increment the least-significant digit until you hit the max, then increment the next... replace regular digits with primes
17:46:59 <prsteele> benmachine: I think its trying to keep a bajillion copies of my list of primes around
17:47:10 <benmachine> prsteele: can we see it?
17:47:16 <mjrosenb> stragerLN: in general you should not need to use fst and snd.
17:47:23 <mjrosenb> stragerLN: this cas is no exception.
17:47:44 * hackagebot redis 0.7.2 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.7.2 (AlexanderBogdanov)
17:47:44 <stragerLN> mjrosenb: alright, so what should I do?
17:48:06 <mjrosenb> pattern match!
17:48:13 <benmachine> pattern matching <3
17:48:16 <stragerLN> Heh; I was thinking that much, but
17:48:21 <ClaudiusMaximus> stragerLN: span p xs = (takeWhile p xs, dropWhile p xs) so snd (span ...) can be simplified, and indeed pattern matching
17:48:24 <stragerLN> Can I pattern match on an evaluated func ?
17:48:26 <prsteele> benmachine: http://pastebin.com/xMb4W7ke
17:48:29 <mjrosenb> (left, right) = ...
17:48:36 <stragerLN> mjrosenb: ah
17:48:43 <stragerLN> ClaudiusMaximus: mm true
17:48:56 <mjrosenb> stragerLN: any time you have something on the lhs of an =, it is a pattern.
17:49:13 <mjrosenb> stragerLN: as well as an argument in a lambda or function declaration
17:49:16 <stragerLN> okay
17:49:25 <mjrosenb> stragerLN: and in the branches in a case statement
17:49:31 <benmachine> stragerLN: also, I'd write misWhitespace as misWhitespace x = elem x " \r\n\t"
17:49:33 <stragerLN> So I simplified that.  What about that nasty if case?
17:49:44 <benmachine> stragerLN: I'd use case for that
17:49:57 <stragerLN> case sounds nasty too =]
17:50:01 <benmachine> case is lovely
17:50:06 <benmachine> I want to hug it
17:50:08 <ClaudiusMaximus> the "if null ..." test could be done just once, perhaps
17:50:17 <mjrosenb> also, the word ++ is kinda nasty
17:50:43 <ClaudiusMaximus> because you either start with whitespace or you don't, and after that you should know where you are
17:50:54 <stragerLN> true
17:51:06 * mjrosenb likes the paradigm of foo -> (\x -> x) | bar -> (first:)
17:51:12 <stragerLN> well
17:51:18 <mjrosenb> for conditionally adding something to the head of a list
17:51:24 <stragerLN> can I mwords (isWhitespace ???):xs or something?
17:51:36 <stragerLN> mwords (isWhitespace ???):xs = ..., I mean
17:52:07 <mjrosenb> stragerLN: what would you want that to do?
17:52:20 <stragerLN> To handle whitespace cases first
17:52:23 <stragerLN> mm wait
17:52:26 <stragerLN> I can use guards right
17:52:28 * stragerLN tries
17:52:37 <mjrosenb> ja.
17:52:51 * mjrosenb always forgets about guards, since i learned sml first
17:53:10 <aristid> :t guard
17:53:11 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:53:16 <aristid> i know you don't mean those
17:53:31 <benmachine> stragerLN: http://paste2.org/p/934689 one way of doing it
17:54:58 <benmachine> http://pastebin.com/bQ9s1fSB whose was this I've forgotten
17:54:59 <stragerLN> http://paste2.org/p/934692 here'
17:55:06 <benmachine> prsteele: http://pastebin.com/bQ9s1fSB
17:55:06 <stragerLN> here's what I ended up at
17:55:22 <benmachine> oh right
17:55:23 <stragerLN> (Is my whitespacing correct btw ?)
17:55:34 <benmachine> it'll compile
17:55:39 <benmachine> everything apart from that is opinion :P
17:55:43 <stragerLN> heh
17:55:50 <stragerLN> Well, really, I find it too horizontal
17:55:56 <stragerLN> I'm used to vertical languages ;D
17:56:02 <benmachine> personally I always put guards on the next line
17:56:11 <benmachine> unless they're so short the whole thing fits on one line
17:56:18 <ClaudiusMaximus> 2h21m53s to generate, and my jitter profile looks like an over caffeinated bird's nest http://claudiusmaximus.goto10.org/g/misc/mess.png :/
17:56:19 <prsteele> benmachine: Okay, so that change 'forces' the evaluation of... what, the first 3 arguments?
17:56:23 <monochrom> yeah I understand vertical languages or style.
17:56:47 <benmachine> prsteele: no, just the count + 1
17:57:02 <benmachine> prsteele: I'm not even entirely sure it does that, I've never really worried much about strictness :P
17:57:09 <benmachine> but I think it should help
17:57:32 <benmachine> it says, evaluate count + 1 before making the recursive call
17:57:45 <monochrom> tmp1 = x+y; tmp2 = tmp1 * 2; tmp3 = tmp2 / z; z = tmp3 + 1.  Splitted on 4 lines.  As opposed to simply z = (x+y)* 2 / z + 1.
17:57:56 <stragerLN> Thanks a lot for your help, guys.  I'm going to sleep.  \o
17:57:57 <prsteele> benmachine: wow, it did. Perfectly, actually
17:58:00 <copumpkin> ClaudiusMaximus: what's that?
17:58:03 <benmachine> awesome :)
17:58:05 <prsteele> benmachine: hint on how you got there?
17:58:20 <benmachine> prsteele: I looked through your recursive calls to see what might be building up a thunk
17:58:22 <ClaudiusMaximus> copumpkin: standard deviation in seconds of elapsed real time between frames
17:58:25 <prsteele> benmachine: so it was the 'count' thunks that were accumulating, not the "prs"
17:58:31 <mjrosenb> monochrom: any relation to http://www.monochrom.at/english/?
17:58:34 <monochrom> another example at http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
17:58:35 <ClaudiusMaximus> copumpkin: is the custom unit
17:58:42 <monochrom> no relation
17:58:46 <benmachine> I noticed that 'count' was the only thing that changed, and there was no reason to force it until the end
17:58:48 <prsteele> benmachine: oh, you're right... it ends up being 1139575, so that's a lot of thunks
17:58:55 <benmachine> so I guessed that evaluating it strictly would help
17:59:25 <prsteele> benmachine: thank you so much, laziness makes a bit more sense now
17:59:46 <benmachine> np :)
18:00:11 <ski> prsteele : hm, that looks like it's trying to be three nested loops ..
18:00:54 <copumpkin> @ask edwardk in your github clone of hmpfr you mention that you're tracking down errors relating to GHC's custom GMP allocator. Have any details on that?
18:00:54 <lambdabot> Consider it noted.
18:01:43 <prsteele> ski: ya, I agree. Esp. since there's no particular reason this can't be extended to any number of 'registers'
18:02:22 <ski> prsteele : what happens in the base cases (when any of the input lists are empty) ? .. or should that never happen ?
18:03:33 <prsteele> ski: it shouldn't happen; they're fed through primes, and I make sure that each register is reset before the list runs out.
18:13:03 <ski> prsteele : hm, and `a',`b',`c' are all initialized from `prs' ?
18:16:01 <ski> (and `count' from `0', presumably ..)
18:16:17 <davekong> Is there some way to run happstack with quickcheck 2.1?
18:17:30 <prsteele> ski: yes and yes
18:23:22 <ski> prsteele : assuming exactly one of `num > stop' and `num <= stop' holds (and that `succ' is as fine as `(+ 1)')..
18:23:26 <ski> > let problem prs stop = loopA prs 0 where loopA (ap:aps) = loopB prs where loopB (bp:bps) = loopC prs where loopC (cp:cps) | num <= stop = loopC cps . succ | cp /= 2 = loopB bps | bp /= 2 = loopA aps | otherwise = id where num = ap^4 + bp^3 + cp^2  in  problem [2,3,5,7,11,13] 100
18:23:27 <lambdabot>   10
18:23:59 <ski> (no idea whether those would be typical inputs in your case .. i think it gives the same results as your version, though)
18:24:36 <ski> (btw, you probably need to indent that properly to get a better grip of it)
18:26:18 * ski suspects there's probably a more compositional way of writing this, to make it easier to write for any number of lists
18:27:14 <prsteele> ski: it does indeed produce the same results
18:27:34 <ski> well, how do you like it ? :)
18:28:15 <ski> (btw, it might be that you'd need to do some strictness annotations or something here as well, for larger input sets .. i'm not sure)
18:29:04 * ski only tried to optimize it for readability
18:29:15 <prsteele> ski: slick
18:29:23 <prsteele> ski: no, it worked with stop == 50000000
18:29:30 <ski> ok, fine then :)
18:30:25 <ski> note the idiom of nested `where's inside `where's giving you nested loops that can abort to earlier levels whenever they want to
18:31:12 <ski> (and where each loop has access to the current element of the outer loops, of course)
18:32:04 <prsteele> ski: ya, useful
18:32:30 <ski> generally, when you have a recursive loop, and some arguments never change from one call to recursive call(s), it's often a good idea to instead make a local function that doesn't pass those arguments around all the time
18:32:40 <ski> e.g.
18:32:41 <ski> @src foldr
18:32:42 <lambdabot> foldr f z []     = z
18:32:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:32:48 <ski> would then be written as
18:32:55 <ski>   foldr f z = loop
18:32:57 <ski>     where
18:33:05 <ski>     loop [    ] = z
18:33:15 <ski>     loop (x:xs) = f x (loop xs)
18:33:50 <prsteele> ski: huh
18:35:16 <ClaudiusMaximus> hm, trivial glut application has 0.6ms jitter with 40ms frame period - i guess i'm doing something wrong in my main app
18:35:40 <ski> also, i'm not sure whether you originally defined a wrapper function around your `problem' function .. generally, it's tedious (and breaks abstraction) to have to remember to feed the accumulator parameters their initial values all the time, ..
18:36:38 <ski> .. so usually one renames the function to `problemAux' or `loop' or `work' (if no better name suggests itself), and then defines `problem' to just call `problemAux' with the required parameters initialized (and any final clean-up done that might be needed sometimes), with `problemAux' defined in a `where' inside `problem'
18:36:43 <prsteele> ski: ya, I did
18:36:51 <ski> prsteele : maybe you've not seen `foldr' before ?
18:37:11 <prsteele> ski: no, I have; what am I missing?
18:38:24 <ski> well, what `foldr' actually does isn't relevant to the point i was making .. i just wanted to show how to mechanically translate from a recursive definition which has parameters which never change, into one that uses a local definition which doesn't carry around those parameters
18:38:32 <ski> prsteele : have you seen `map' ?
18:38:36 <ski> @src map
18:38:36 <lambdabot> map _ []     = []
18:38:36 <lambdabot> map f (x:xs) = f x : map f xs
18:39:10 <ski> > map even [0,1,3,6,10,15,21,28]
18:39:11 <lambdabot>   [True,False,False,True,True,False,False,True]
18:39:19 <ski> > map (^2) [0,1,3,6,10,15,21,28]
18:39:20 <lambdabot>   [0,1,9,36,100,225,441,784]
18:39:20 <prsteele> ski: ya, I know map, fold{l,r,l'}
18:39:23 <ski> ok
18:39:33 <ski> so, `map' above could have been written like
18:39:37 <ski>   map f = loop
18:39:39 <ski>     where
18:39:59 <ski>     loop [    ] = [           ]
18:40:07 <ski>     loop (x:xs) = f x : loop xs
18:40:33 <prsteele> ski: so the goal is to move patterns inside the function definition?
18:40:44 <ski> that way we don't have to carry around the un-changing `f' parameter in each recursive call in `map' (changed into `loop' here)
18:40:52 <prsteele> ski: ah
18:41:09 <ski> the goal is just not to repeat things that doesn't have to be repeated
18:41:28 <ski> in the simple case of `map' and `foldr', it possibly isn't that much of a nuisance
18:42:04 <ski> but in larger examples, it can be tedious to have to name parameters all the time that are only fixed once (at the top initial call) and never (or seldom) changed
18:42:12 <prsteele> ski: no, that all makes sense.
18:42:13 <roconnor> ah, the free indexed monad.
18:42:15 <prsteele> ski: thanks
18:43:46 <ski> e.g. in the `problem' above, it would be tedious if all the `loopA',`loopB',`loopC' (or your original `loop') calls would have to mention the `prs' and `stop' parameters .. because they never change, inside one initial top call
18:44:30 <ski> you'll also notice that i managed to avoid naming `count' in `loopA',`loopB',`loopC', *even* though it changes sometimes :)
18:44:55 <prsteele> ski: ya, the use of succ was slick
18:45:08 <ski> (s/or your original `loop'/or your original `problem'/)
18:45:11 <prsteele> ski: never thought I'd use peano arithmetic after Maht 214...
18:45:40 <ski> well, starting from `0' and then using `+ 1' several times *is* Peano Arithmetic :)
18:46:03 <prsteele> ski: haha right
18:48:08 <ski> (.. back, X crashed)
18:49:17 <ski> you might, for documentation/readabiliy purposes want to name `count' at least once, though (so the reader gets some idea of what that accumulator is meant to represent)
18:49:53 <prsteele> ski: ya, this is mostly a toy problem, but I agree
18:50:05 <ski> so, instead of `loopC cps . succ' you could say `\count -> loopC cps (count + 1)' and instead of `id' you could say `\count -> count'
18:52:42 <ski> then you have to bind `count' twice in abstractions `\count -> ', though .. that might (or might not) read nicer if one changes `loopC (cp:cps) = ...' into `loopC (cp:cps) count = ...' .. then `count' and omit the `\count -> ' parts -- however, then `count' will have to be added to the calls to `loopA' and `loopB', as well
18:53:01 <ski> just mentioning some possibilities
18:53:40 <ski> prsteele : yeah, i'm just using the problem as a vehicle for discussing various idioms and choices one can make
18:54:25 <ski> (s/then `count' //)
18:54:46 <prsteele> ski: sure thing. Thanks again for the help, Haskell has a wonky learning curve...
18:55:17 <ski> where are you coming from (istr your nick from somewhere, i think) ?
18:55:19 <prsteele> ski: I find some things *much* easier in Haskell than other languages, but I'm downright afraid of trying other things in it
18:55:32 <roconnor> what do people know about pattern functors?
18:55:43 <ski> roconnor : what is that ?
18:55:56 <ski> (also, what about the free indexed monad ?)
18:56:11 <prsteele> ski: me? I'm from the northeast US, go to school in Virginia
18:56:31 <ski> prsteele : sorry. i meant which programming languages you were coming from :)
18:57:05 <prsteele> ski: Mainly Python, but further back C/C++, Java
18:57:06 <ski> (i evidently should have been clearer)
18:57:22 <ski> ok
18:58:12 <roconnor> ski: a free indexed monad is a free monad in the category of indexed functors
18:58:16 <prsteele> ski: for example, yesterday I wrote (in Python) all the code necessary to parse a text file into a network and solve the shortest paths problem using Dijkstra's in maybe 30 minutes, but I wouldn't even know where to begin in Haskell
18:58:22 <roconnor> ski: I don't know what a pattern functor is
18:58:30 * ski neither :)
19:00:03 <ski> prsteele : i would probably try parsing with a parsing combinator library (such as `Parsec') (or maybe using the `yacc'/`bison'-like `happy', or possibly use a manual parser, if the syntax is very simple)
19:00:10 <lispy> yo
19:01:02 <ski> prsteele : i would need some way of representing the graphs .. either some graph-library like `fgl', or possibly adjacency-lists ot something similar
19:01:03 <lispy> simple grammar is when I would use parsec
19:01:36 <lispy> although, if efficiency is important I would use parsimony or attoparsec
19:01:46 <prsteele> ski: right, but it how would I even represent a node-adjacency matrix in Haskell? That basically requires random access...
19:02:07 <ski> lispy : by "very simple" i mean things like : "each line consists two parts separated by a horizontal tab, the former being the source node, the latter being the target node, representing an edge"
19:02:17 <lispy> prsteele: see vector on hackage
19:02:20 <ski> prsteele: well, an array e.g.
19:02:44 <kmc> if you need updates, immutable arrays are slow
19:02:48 <kmc> but IntMap is a good choice
19:03:01 <prsteele> thanks, all
19:03:29 <ski> roconnor : so, who mentioned the term "pattern functor" ?
19:03:39 <roconnor> ski: the gentle art of levitation
19:04:07 <roconnor> Is diskatra's algorithm one of the instances of that generic algorithm on A*-algebras?
19:04:11 <ski> roconnor : hm .. i wonder how a free indexed monad (over `Hask') could look like in haskell
19:04:29 <ski> roconnor : is that a book or paper ?
19:04:35 <roconnor> paper
19:04:54 <lispy> ski: I don't know, but I bet edwardk has an implementation somewhere if it's possible :)
19:05:07 <prsteele> roconnor: Not sure what an A*-algebra is, but Dijkstra's is similar to a breadth-first search except that instead of maining a fifo-queue, you maintain a min-priority queue based on best estimates of node distances
19:05:49 <roconnor> I recall that gaussina elimitation and a bunch of graph algorithms are all the same thing at a suitable level of abstraction
19:05:59 <roconnor> which suggests a matrix approach to the problem
19:06:45 <prsteele> roconnor: huh, I can imagine that. You can certainly represent a network as a matrix
19:07:06 <roconnor> I was thinking I should impliment this in Haskell
19:07:33 <prsteele> roconnor: undirected networks are symmetric...
19:07:58 <ski> "The Gentle Art of Levitation" at <http://personal.cis.strath.ac.uk/~dagand/index.html#levitation> by James Chapman,Pierre-variste Dagand,Conor McBride,Peter Morris in 2010
19:08:58 <lispy> preflex: seen FunctorSalad
19:08:59 <preflex>  FunctorSalad was last seen on #haskell-blah 2 days, 4 hours, 45 minutes and 37 seconds ago, saying: (btw has it become *that* icy in germany or is it just me? ;))
19:10:08 <prsteele> well, dinnertime. Thanks for all the help
19:10:29 <roconnor> oh maybe it was a star-semiring
19:10:48 <ski> lispy : well, iirc `class IndexedMonad m where ireturn :: a -> m i i a; ijoin :: m i j (m j k a) -> m i k a; ibind :: m i j a -> (a -> m j k b) -> m i k b' .. hm
19:11:11 <lispy> ski: That looks really familiar
19:11:27 <ski> so .. how to free this ?
19:11:31 <lispy> ski: I think I coded that up in the darcs source at one point for the type witnesses
19:12:26 <ski> recall that `data FreeMonad f a = Return a | JoinLift (f (FreeMonad f a))'
19:12:34 <lispy> ski: see RIO: http://darcs.net/src/Darcs/Repository/Internal.hs
19:13:11 <lispy> ski: I think something isomorphic to it exists in category-extras as well
19:14:08 <ski> yes, known applications of indexed monads in Haskell include state with changing type as well as composable continuations
19:17:14 <lispy> ski: yeah, the application we had for it in Darcs is a mixer of those two applications
19:17:36 <lispy> ski: in particular, tracking the state of the repository after applying sequences of patches
19:18:11 <lispy> ski: but...given that it's an IO monad you can still do crazy things so...it's not very good proof.  So we have been reluctant to apply it in the source code
19:18:13 <ski>   data FreeIndexedMonad (f :: * -> * -> * -> *) :: * -> * -> * -> *
19:18:17 <ski>     where
19:18:33 <ski>     IReturn   :: forall i     a.                               a  -> FreeIndexedMonad f i i a
19:18:42 <ski>     IJoinLift :: forall i j k a. f i j (FreeIndexedMonad f j k a) -> FreeIndexedMonad f i k a
19:18:46 <ski> i think
19:19:52 <ski> lispy : hm, you use composable continuations ?
19:20:03 <lispy> ski: Well, patches are
19:20:17 <ski> (also, i don't see how `IO' is relevant, here)
19:20:44 <lispy> ski: Yeah, IO isn't relevant for you.  It was for us
19:21:12 <ski> no, i mean how is it relevant to whether using an indexed monad is ok or not, in your case ?
19:21:58 <lispy> ski: Well, the indexed types would be used as a proof
19:22:09 <ski> a type-level proof ?
19:22:45 <lispy> ski: A proof that the repository transformation (the implementation of your code) does what it claims to do at the level of repository states
19:23:23 <lispy> ski: but, in IO you could, in theory, do wild ass things and completely lie.  more than just unsafeCoerce/unsafePerformIO
19:23:57 <lispy> ski: So, the the proof there would depend on 1) that it type checks, 2) there is nothing suspicious in the implementations
19:24:05 <lispy> Instead of simply #1
19:25:02 <lispy> Granted, we have the same issues in your pure code, but there #2 is easier to check
19:25:39 <ski> hm
19:25:43 <ski> which pure code ?
19:25:52 <ski> the version not using indexed monads ?
19:26:13 <lispy> And no one, save for Igloo, Heffalump, myself, and droundy, seem to understand our type witnesses, there isn't a lot of motivation to make even more code obfuscated  :)
19:26:54 <lispy> ski: Well, we use type threaded lists to hold sequences of patches.  You might called those indexed lists
19:27:04 <roconnor> http://geomete.com/abdali/papers/TCviaElim.pdf
19:27:07 <lispy> And there is a lot of pure code that works with those
19:27:28 <lispy> That pure code can be really difficult to work with.  Filtering is not easy, for instance
19:27:57 <roconnor> This one algorithm computs shortest-path, largest-capacity paths, most reliable paths, transitive closures, and solutions of linear equations
19:28:16 <lispy> roconnor: But, does it make good coffee??
19:28:20 <roconnor> yes
19:28:26 * lispy is in awe
19:28:48 <ski> lispy : (re "type threaded lists") aka `data Thirst (f :: * -> * -> *) :: * -> * -> * where Nil :: forall a. Thirst f a a; Cons :: forall a b c. f a b -> Thirst f b c -> Thirst f a c' ?
19:29:26 <lispy> ski: Aye.  We call that a forward list, or FL.  We also have reverse lists.
19:29:32 * ski suspects the `TC' in the title doesn't stand for `Tail-Call', in this case ..
19:30:46 <roconnor> TC is transitive closure
19:31:02 <ClaudiusMaximus> hmm, how do i make my GHC-compiled program use only one core of my dual-core CPU?   with +RTS -N1 -RTS i get real 5m1.360s user 6m59.780s (the same as +RTS -N2 -RTS)
19:31:49 <jmcarthur> ClaudiusMaximus: don't build with -threaded?
19:32:27 <ski> lispy : well, does using indexed monads change much in the code (as opposed to the types) apart from using the indexed monad operations instead ?
19:32:28 <lispy> ClaudiusMaximus: Do you want CPU pinning?
19:32:54 <lispy> ski: that's a really good question.  It would appear that we can't use do-notation :(
19:33:25 <ski> lispy : yeah, that's a shame (i've noticed that when playing with composable continuations, myself) :(
19:33:30 <lispy> ski: Otherwise, I'm not really sure.  It would certainly be a worthwhile experiment to try changing over more code to use the index monad.
19:33:49 <lispy> But, it's a hard sell...
19:33:50 <ClaudiusMaximus> lispy: hm, yes in fact - i have another program (in C) that makes heavy GPU usage which sped up greatly when i pinned Xorg and my app to the same core...
19:33:55 <lispy> Not a lot of people want it in the code base
19:34:09 <ClaudiusMaximus> lispy: ..would be interesting to see if i can do the same here
19:34:10 <ski> lispy : btw, did you mean that patches uses composable continuations ?
19:34:17 <lispy> ClaudiusMaximus: Ah.  I wish dons was here.  he'd know if there is a way to do that
19:34:23 <ski> lispy : are there that many developers ?
19:34:38 <ClaudiusMaximus> @hoogle CPU
19:34:39 <lambdabot> module System.CPUTime
19:34:39 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
19:34:39 <lambdabot> System.CPUTime getCPUTime :: IO Integer
19:34:41 <lispy> ski: Nope, they are composable continuations
19:34:57 <lispy> ski: There are quite a few contributors to darcs these days
19:35:23 <ski> lispy : are composable continuations, or are actions in a composable continuations (indexed ?) monad ?
19:35:23 <lispy> ski: http://blog.codersbase.com/search/label/continuations
19:35:49 <roconnor> let' see, the asteration of x is a value x* such that x* = xx* + 1.
19:36:14 <lispy> ski: patches themselves are an implementation strategy for achieving continuations.  Git on the other hand, choose a zipper representation, but as Oleg would point out they are isomorphic.
19:36:43 <roconnor> for minimum path finding we use a tropical semiring
19:37:00 <roconnor> so what is "matrix" multiplication in over a tropical semiring
19:37:31 <roconnor> it is a matrix of "dot products" where a dot product is the minium of the pointwise sums
19:37:50 <lispy> ski: http://okmij.org/ftp/Computation/Continuations.html#zipper
19:38:35 <roconnor> when the matrix represents the length it takes to get from node A to node B
19:38:53 <lispy> ski: I've been slowly trying to find a framework (probably in delimited continuations) where different vcs can be expressed 'equally'.
19:39:45 <lispy> I announced a new version of takusen today.  Are people here using that library?  We use it at Galois.
19:40:19 <roconnor> then tropical matrix multiplication says how long it takes to get from node A to node B by the sortest path going via C taking a first step accourding to the first matrix and a second step acording to the second matrix.
19:40:49 <lispy> ski: I think it's really fascinating that git and darcs take such different approaches but endup corresponding to delimited continuations and zippers, which have in turn been shown to be equivalent.  I think it's actually a bit deeper than people realize.
19:41:51 <ski> lispy : interesting
19:41:53 <lispy> ski: and since darcs and git have shown the different representations have different strengths and weaknesses, maybe we can combine them both (into one system that has all the weakness and none of the strengths...er wait, maybe I have that backwards)
19:42:05 <ClaudiusMaximus> i think i understand zippers; but i have no idea what delimited continuations are
19:42:20 <ski> (would this mean that, theoretically, git could be changed to allow patch commutation as well ?)
19:42:20 <lispy> ClaudiusMaximus: they are like regular continuations but more general
19:42:39 <roconnor> x* = 1 + x + x^2 + x^3 ...
19:42:39 <lispy> ski: Perhaps something like it, yes
19:42:47 <roconnor> so if x is a matrix of edge weights
19:43:02 <lispy> ski: the patch theory itself is just an implementation strategy to get continuations (I'm pretty sure of this now)
19:43:16 <roconnor> the asteration of x is a matix of minimal path length from nodes A to nodes B.
19:44:10 <wli> x^* = 1/(1-x) if there were division or subtraction.
19:44:28 <ski> (yes, `x^*' is basically `List x' :)
19:44:54 <roconnor> wli: 
19:45:02 <ski> ClaudiusMaximus : how about regular continuations, and Continuation-Passing Style (CPS) ?
19:45:04 <roconnor> we use gausian elimitation to solve for x*
19:45:11 <roconnor> and this gives us the shortest path
19:46:05 <lispy> ClaudiusMaximus: can you read scheme?
19:46:22 <roconnor> I wonder how lasy gaussian elemination is if you only want the shortest distance from some particular A to B.
19:46:27 <lispy> ClaudiusMaximus: I know of a good article about them on a scheme wiki.  The scheme code is not that hard to understand
19:46:30 <ski> lispy : well, afaiu it, the important things is to be able to candypick parts of commits, and to backport (did i forgot any ?)
19:46:56 <lispy> ski: That is a really nice side-effect of darcs's representation
19:46:57 <ski> roconnor : how does `x^*' fit into the matrices ?
19:47:06 <Saizan> ski: cherrypick :)
19:47:15 <ski> Saizan : ty :)
19:48:15 <ski> (lispy : you're thinking of <http://community.schemewiki.org/?composable-continuations-tutorial> or anything else ?)
19:48:30 <roconnor> ski: matrices over a star-semiring form a star-semiring
19:48:46 <lispy> ski: yeah.  That's the one
19:48:54 <lispy> I love that they give the semantic translation
19:49:01 <lispy> Without that, I never could grok them
19:49:02 <ski> roconnor : oh .. missed your "the asteration of x is a ..." comment
19:49:46 <ski> (aiui, Riastradh wrote most or all of that page)
19:51:29 <roconnor> to solve linear systems, we use the ususal star-semiring.  If we want to solve AX + B = X, then the solution is A* B.  I guess trying to solve A*X = B can be reduced to this problem.
19:52:32 <ski> roconnor : hm, so `+' here is `min' of the lengths, i take it
19:52:56 <roconnor> ski: ya for shorest path, we use the tropical semiring
19:53:12 <roconnor> and x* is always 0.
19:54:38 <lispy> ski: when you said composable continuation you mean the same thing as I mean when I say delimited continuations, right?
19:55:43 <ski> lispy : yeah, composable/delimited/sub- continuations
19:55:53 <ski> (maybe i've forgot one or two synonyms ..)
19:56:09 <lispy> just wanted to check :)
19:56:40 <lispy> ski: you see how vcs and composable continuations correspond right?  Does it make sense?  I'm not missing some obvious problem with it?
19:56:48 * lispy is NOT a continuation expert
19:57:01 * ski is not a vcs expert
19:57:23 <lispy> fair enough
19:58:13 <ski> (but i've been striving towards being a not not continuations expert for some while ;)
19:58:33 <roconnor> ski: the identiy matrix for this tropical semi ring has 0's on the diagonal and infinities everywhere else
19:58:45 <roconnor> this is exaclty the starting state of dijkstra's algorithms
20:02:42 <ski> (and i haven't actually read the blog posts there, yet .. is the blovinator a regular here, btw ?)
20:03:14 <roconnor> what's a blovinator?
20:04:01 <ski> a colloquialism for "blogger"
20:06:47 <lispy> ski: which, which blog posts?
20:07:06 <lispy> ski: the ones I linked?  Those are from my blog.
20:07:50 <ski> ok
20:08:44 <lispy> I've been meaning to explore delimited continuations more and develop an intuition about them.  and at the same time, blog about it so that others have some tutorials to reference
20:08:54 <lispy> But, I'm too lazy for that!
20:09:45 <ski> so, you've been doing the latter, while being too lazy to do the former ? :)
20:10:25 <lispy> hehe.  well, I wouldn't consider what I have to be a good exploration.  I'd like to have something with examples
20:11:00 <lispy> I was trying to figure out how to invert control for foldr and then blog about it.
20:11:14 <lispy> But, so far what I've come up with is not what I had envisioned
20:12:30 <ski> hm, invert how ?
20:12:56 <lispy> ?src foldr
20:12:56 <lambdabot> foldr f z []     = z
20:12:56 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:13:03 <ski> writing it in CPS, also the `cons' (and possibly `nil') arguments being in CPS ?
20:13:27 <lispy> ski: notice that in the second equation, f immediately gets control.  It would be nice if f could return the accumulator so far, and a continuation to resume the foldr
20:14:03 <lispy> > foldr const undefined [1..] -- this demonstrates that returning the accumlator is at least possible
20:14:04 <lambdabot>   1
20:14:15 <ski> well, in a lazy language, `f' gets control first, yes
20:14:44 <ski> monadifying a piece of code strictifies it, though (up-to how strict the monad in question is)
20:15:38 <ski> (hm, what do you mean by "the accumulator" above ?)
20:16:10 <lispy> ski: err, good point.  It's actually not the accumulator that gets returned
20:16:36 <lispy> ski: but, I think of folds as having the current value from the list and an accumulator.  f combines those
20:16:50 <ski> anyway, the "traditional" CPS variant of `foldr' is
20:17:14 <ski>   foldrCPS cons nil [    ] k = nil k
20:17:43 <ski>   foldrCPS cons nil (a:as) k = foldrCPS cons nil as (\r -> cons a r k)
20:17:59 <ski> with type signature
20:18:43 <ski>   foldrCPS :: (a -> r -> Cont o r) -> Cont o r -> [a] -> Cont o r
20:18:52 <ski>   type Cont o r = (r -> o) -> o
20:19:55 <ski> lispy : hm, `f' combines the current value, and a computation which represents the result of the fold on the rest of the list (which may be discarded)
20:20:20 <ski> so, hm
20:20:54 <ski> i suppose in e.g. ML, one could define a `foldr' which would be more like what you're thinking of like
20:21:20 <ski>   val foldr : ('a -> (unit -> 'r) -> 'r) -> (unit -> 'r) -> 'a list -> 'r
20:21:31 <ski>   (* implementation elided *)
20:21:35 <lispy> ski: ah, you mean behaves like a lazy implemenation?
20:21:47 <lispy> ski: Yeah, continuations allow some cool lazy stuff
20:23:00 <ski> so, since SML is strict, we need to add `unit -> ' here to delay the calling of the "result of the rest of the list" in `cons' (and, optionally, also for the "lowest" `nil' call (which might sometimes throw an exception, say, which we want `cons' to capture, so we can't compute `nil' beforehand)
20:23:05 <ClaudiusMaximus> ski: i vaguely understand CPS
20:23:21 <ClaudiusMaximus> lispy: i can read scheme if it isn't too mutation-heavy
20:23:37 <ski> anyway, the corresponding in Haskell would be to say (translating into a monad `m', which represents the "strictness")
20:23:38 <lispy> ClaudiusMaximus: that link ski sent about continuations helped me a lot
20:23:55 <lispy> ClaudiusMaximus: this one http://community.schemewiki.org/?composable-continuations-tutorial
20:23:57 <ClaudiusMaximus> lispy: ok, i'll check it
20:24:00 <ski>   foldr :: (a -> m r -> m r) -> m r -> [a] -> m r
20:24:29 <ClaudiusMaximus> (sorry for delay, was doing more benchmarking - if i do swapBuffers as the first thing in my display callback i get 2.4ms jitter with 1 worker thread and 9.4ms jitter with 2 worker threads)
20:24:30 <ski> (we need no `() -> 's in Haskell, but we need `m' on every effectful (serious) result type, instead)
20:25:12 <lispy> ski: interesting
20:25:17 <lispy> ski: I never thought about it like that
20:25:30 <ski> ClaudiusMaximus : btw, you might (i'm not sure which is easiest) want to get a grip on "ordinary" continuations and CPS before trying out nqCPS (not-quite Continuation-Passing Style) and composable continuations
20:25:47 <ski> lispy : so, in the `Cont o' monad we get
20:26:05 <ski>   foldr :: (a -> Cont o r -> Cont o r) -> Cont o r -> [a] -> Cont o r
20:26:34 <ClaudiusMaximus> (so until GHC gets fully pre-emptive (including of foreign calls) threading with user-settable priorities, i think i need to estimate how long each job will take, and if the job will push me past the time that the display callback needs to run just sleep until then)
20:26:40 <ski> so, now the `cons' argument can choose when (and if) it wants to call the computation that will give the recursive result of the rest of the list
20:27:11 <ski> and it can also execute it several times (and the result will not be shared, as with laziness)
20:27:27 <lispy> ClaudiusMaximus: are there any tools like unix's nice that let you pin a process and all of it's subprocesses?
20:28:05 <lispy> ski: So, you're saying, if I use the CPS style foldr, the inversion of control will be easier to achieve?
20:28:18 <ski> i'm not sure
20:28:35 <ski> (i've actually not fully grasped what "inversion of control" means)
20:29:14 <lispy> ski: In this case, it's a lot like scanr
20:29:21 <ski> (it might be just that the "callee" calls the "caller", when calling the continuations .. or maybe it means something about inverting loops or something ..)
20:29:29 <ski> @type scanr
20:29:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
20:29:40 <lispy> > scanr (+) 0 [1..5]
20:29:41 <lambdabot>   [15,14,12,9,5,0]
20:29:56 <lispy> ski: it's like foldr but you get a list of all the intermediate results
20:30:21 <ski> well, the `cons' argument to `scanr' doesn't get to choose if/when/how many times the "recursive result computation" should be called
20:30:34 <ski> hm ..
20:31:09 <ClaudiusMaximus> lispy: there are tools like that
20:31:42 <lispy> ski: what I really mean by inversion of control is that the caller of the foldr gets something back that include an intermediate result and a way to get the next intermediate result
20:32:05 <lispy> ClaudiusMaximus: maybe that's the way to get the pinning you need
20:32:09 * ski wonders whether one can think of this in terms of `Cont2 [o] o' ..
20:32:29 <ski> lispy : ok
20:32:48 <ski> it's not quite the same with `scanr', though ..
20:33:07 <ski> though .. maybe it can be made an instance of it, by writing `scanr' in terms of `foldr' ?
20:33:20 <lispy> ?src scanr
20:33:20 <lambdabot> scanr _ q0 []     =  [q0]
20:33:20 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
20:33:20 <lambdabot>     where qs@(q:_) = scanr f q0 xs
20:33:21 <ski> (or maybe a monadic `foldr' variant)
20:35:08 <ski>   scanr cons nil = foldr (\a rs@(r:_) -> cons a r : rs) [nil]  -- i think
20:35:09 <ClaudiusMaximus> lispy: well, i'm not sure i need it in this case; it's more the structure of my program with part of it in C (the numeric-heavy bits) that takes a while and cannot be interrupted; and the desire to use both cores effectively
20:35:50 * ski tries to squint and see composable continuations lurking in there ..
20:36:24 <ClaudiusMaximus> lispy: if i have +RTS -N2  and 1 worker thread calling into C leaving the main thread free for OpenGL stuff, i get 2.4ms jitter which is more than fine; but it leaves half a core idle
20:36:55 <ClaudiusMaximus> (on a laptop with cpu-frequency-scaling, so in reality the core may be more than half idle)
20:37:41 <ClaudiusMaximus> btw, i'll be reading that link at some other date, as 04:37 isn't the best time for learning new things
20:38:30 <lispy> yeah
20:38:41 <Saizan> lispy, ski: what you seem to want to do looks way more suitable to foldl than foldr
20:39:02 <ski> Saizan : no, it should work on infinite lists, as well
20:39:13 <lispy> ?tell dons is there anyway to pin GHC (or GHC threads) to specific cores?  ClaudiusMaximus was looking for something like that
20:39:13 <lambdabot> Consider it noted.
20:39:37 <lispy> Saizan: why is that?
20:39:40 <lispy> ?src foldl
20:39:40 <lambdabot> foldl f z []     = z
20:39:40 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:40:00 <lispy> Saizan: just judging by those naive implementations, foldr gives control to f right away, but foldl keeps control
20:40:05 <ski> `foldl' is tail-recursive, which means that it is spine-strict in the list
20:40:23 <Saizan> because foldl is the one about reducing to an accumulator as you go along the list
20:40:40 <ski> Saizan : imo "accumulator" is the wrong word here
20:40:49 <ski> (maybe "coaccumulator" would fit better ?)
20:40:57 <Saizan> it's the wrong word for foldr, because it's not what it's doing :)
20:41:20 <ski> yeah, but we're thinking about lazy `foldr' variants, not `foldl' things :)
20:41:58 <Saizan> heh, i guess i took the other half of the discussion as normative :)
20:42:20 <ski> (Saizan : and i meant that it was unfortunate of lispy to use that word, precisely since it brings wrong connotations, as you just evidenced ;)
20:42:23 <lispy> Saizan: returning an accumulator isn't as important (to me) as returning some meaningful value + something that represents the rest of the foldr.
20:43:01 <lispy> I guess, the 'f' here could be the escape function of a callCC
20:43:05 <Saizan> only foldl always has a meaningful value as it goes down the list
20:43:36 <ski> stop thinking about accumulators ! :)
20:44:05 <Saizan> anyhow, this really reminds me of edwark's Mealy and Moore automatons, but i can't find the code online :)
20:44:22 <ski> lispy : actually, i realize the `foldr :: (a -> Cont o r -> Cont o r) -> Cont o r -> [a] -> Cont o r' i had in mind above is *just* the usual `foldr', with specialized type :)
20:44:50 <lispy> ski: I thought that was intentional :)
20:45:12 <ezyang> Does String get special-cased w.r.t. boxing in GHC? 
20:45:26 <ezyang> I can't imagine it is, but it would be nice to make sure. 
20:45:28 <ClaudiusMaximus> ?ask dons would you accept a patch to ghc-gc-tune for more general purpose tuning? i hacked it to use a number from the tunee's stdout as the score rather than time or memory
20:45:28 <lambdabot> Consider it noted.
20:46:02 <ski> lispy : no, i just derived that type signature from the corresponding SML type signature just above (which used `unit -> 's), and didn't think of the implementation details atm :)
20:50:04 <ski> Saizan : <http://comonad.com/haskell/Origami.hs> (single-pass traversal, composable folds) ?
20:50:28 <ski> (<http://comonad.com/reader/2009/incremental-folds/> might be relevant as well, i'm not sure)
20:50:59 <Saizan> yup, that's it
20:52:50 <ski> lispy : so, does that suffice as "inverting control for `foldr'", or did you want something more ?
20:53:44 <lispy> ski: I can't look now, I have to run
20:53:48 <ski> ok
20:53:49 <lispy> ski: But, thanks for the link I'll check it out
20:54:41 <ezyang> The Data category has too many modules >.> 
20:59:10 <Saizan> i guess it makes sense to return the continuation of right-nested-f-applied-to-elements-of-the-list, and result-of-foldr-on-the-rest-of-the-list, so that at every point if you apply the former to the latter you get the result of the foldr
20:59:53 <Saizan> but i'm not sure what'd you use it for
21:00:26 <ski> (hm .. modules out of preadditive categories ..)
21:02:22 <ski> Saizan : aiui, lispy was interested in CPS versions of `foldr' that allowed one to discard the computation that yields the recursive result, at each step
21:02:23 <Saizan> speculation would be one use case
21:05:40 <ski>   foldrCPS2 :: (a -> r -> Cont2 o o r) -> Cont2 p o r -> [a] -> Cont2 p o r  -- i suppose
21:06:26 <ski>   type Cont2 p o a = (a -> o) -> p  -- so `IndexedMonad Cont2', modulo the `type' instead of `newtype'
21:06:32 * monochrom moves Data.List to Control.List :)
21:10:08 * ski suggests moving `Data.String' to `Type.String' :)
21:11:50 * Phyx- suggests 'Base.String'
21:12:12 <ski> (oh, but `base' is not a keyword ..)
21:12:45 <Phyx-> well, I didn't know the rules of this game :)
21:13:04 <ski> well, invent some ? :)
21:13:11 <Phyx-> lol
21:25:03 <tolkad> Are there any good haskell HTTP server libraries?
21:30:08 <ski> @type CoKleisli (MkContext (uncurry (flip unfoldr)))
21:30:09 <lambdabot> Not in scope: data constructor `CoKleisli'
21:30:09 <lambdabot> Not in scope: data constructor `MkContext'
21:37:39 <dancor> is yhc or another haskell-to-js project alive?
21:41:12 <ski>   scanl :: (r -> a -> r) -> r -> [a] -> FreeMonad (Context r) r
21:41:26 <ski>   scanl snoc = loop
21:41:34 <ski>     where
21:41:47 <ski>     loop nil [    ] = Return nil
21:41:54 <ski>     loop nil (a:as) = JoinLift (MkContext nil (\nil -> loop (snoc nil a) as))
21:42:15 * ski ponders that ..
21:44:07 <dobblego> is it possible to flip type constructors around to instance them?
21:44:15 * ski wonders whether there's any significance to that `FreeMonad f' is a monad when `f' is, here. (`Context r' is a comonad, btw)
21:44:49 <ski> dobblego : if you define `newtype Flip f b a = MkFlip {unFlip :: f a b}', sure
21:44:58 <dobblego> that's what I thought thanks
21:45:48 <Mathnerd314> q: how many type-level functions are needed to express any type?
21:46:27 <ski> (note that since there's no kind polymorphism, that's monomorphic (though i hear UHC has it <http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html>)
21:47:23 <ski> Mathnerd314 : if by "any type" you mean `exists a. a', then i'd say one, namely `\a -> a'
21:47:34 <ski> )
21:47:36 <Mathnerd314> any abstract data type
21:47:50 <ski> it depends on the type, i suppose
21:49:35 <ski> dobblego : note that unfortunately `f' is not the same type as `Flip (Flip f)'
21:49:49 <dobblego> right which is a pain -- thanks for the tip
21:50:28 * ski wonders whether one can make an `Equal f (Flip (Flip f))' instance ..
21:50:53 <ski> (well, using `unsafeCoerce#' i'm sure one can cheat .. but excepting that ..)
21:51:31 <Mathnerd314> ski: typeclass with two instances?
21:51:35 <ski> (`class Equal a b where subst :: forall k. k a -> k b')
21:52:07 <shdwfeather> Hey guys, I'm a haskell newbie, and I had a question about foldl and foldr. The book I'm using to learn Haskell says that we should always use foldl' because it doesn't construct thunks. But what about foldr? It also constructs thunks, doesn't it?
21:52:41 <ski> i suppose one could go for `newtype Equal a b = Leibniz {subst :: forall k. k a -> k b}', instead
21:53:01 <poljp> @pl \p f e = mf . p f . uf <$> f e
21:53:01 <lambdabot> (line 1, column 8):
21:53:02 <lambdabot> unexpected "="
21:53:02 <lambdabot> expecting pattern or "->"
21:53:10 <poljp> @pl \p f e -> mf . p f . uf <$> f e
21:53:11 <lambdabot> join . (((.) . (<$>) . (mf .)) .) . flip flip uf . ((.) .)
21:53:17 <poljp> ugh
21:53:33 <tolkad> > let {f "x" = "a"; f "y" = "b"} in f "x"
21:53:34 <lambdabot>   "a"
21:53:47 <pastorn> shdwfeather: i don't know about that, but you should be careful when choosing function, depending on in which order you want things to be applied... Consider insertion in a BST for example. If you get two elements with the same key and a replacement should be done, which should be kept?
21:53:58 <tolkad> > let x = "x" in let {f "x" = "a"; f "y" = "b"} in f x
21:53:59 <lambdabot>   "a"
21:54:16 <dobblego> shdwfeather, which book, page number?
21:54:19 <pastorn> > foldr f [a,b,c,d] :: [Expr]
21:54:20 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
21:54:20 <lambdabot>         against inferre...
21:54:27 <pastorn> > foldr f [a,b,c,d] :: Expr
21:54:29 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
21:54:29 <lambdabot>         against inferred ...
21:54:40 <pastorn> > foldr f z [a,b,c,d] :: Expr
21:54:41 <lambdabot>   f a (f b (f c (f d z)))
21:54:46 <pastorn> > foldl f z [a,b,c,d] :: Expr
21:54:47 <lambdabot>   f (f (f (f z a) b) c) d
21:54:50 <shdwfeather> Real World Haskell, Chapter 4 in section Left folds, laziness, and space leaks
21:54:58 <tolkad> > let x = "x" in let {f x = "a"; f "y" = "b"} in f x
21:54:59 <shdwfeather> http://book.realworldhaskell.org/read/functional-programming.html
21:55:00 <lambdabot>   "a"
21:55:12 <tolkad> > let x = "x" in let {f x = "a"; f "y" = "b"} in f "y"
21:55:13 <lambdabot>   "a"
21:55:15 <tolkad> : (
21:55:21 <tolkad> is there any way to do that?
21:55:28 <tolkad> turn a variable into a constructor?
21:55:35 <shdwfeather> I understand the arguments the book presents, but I do not understand why there isn't a foldr' similar to foldl' defined in Data.List
21:55:54 <lispy> tolkad: typeable or data.dynamic probably has a way
21:56:05 <lispy> tolkad: I'm not familiar with them though
21:56:20 <dobblego> shdwfeather, it says to always use foldl' rather than foldl, but not necessarily foldr
21:56:35 <tolkad> lispy: would that way be extremely evil?
21:56:38 <dobblego> how would a foldr' look to you?
21:57:05 <ski> shdwfeather : the problem with  foldl  is that while it is tail-recursive / spine-strict, so that it always walks through the list before returning control, it doesn't (navely) force its accumulator before the very end, which can be inefficent as that it becomes a "bulky" rather than an incremental operation .. and this can blow a stack, in case the stack has artificial low bounds
21:57:14 <lispy> strict foldr would probably be a bad idea
21:57:35 <lispy> tolkad: I don't think so.  They're just standard libraries
21:58:22 <ski> shdwfeather :  foldr  otoh isn't tail-recursive / spine-strict, it can return control back to you before having walked through the whole list, in case the function argument doesn't immediately look at its second argument (representing the result of the recursive call)
21:58:32 * BMeph is really annoyed at how clunky it is to insert values into a Map when one wants to use "keep the first entry" rules...
21:58:55 <ski> shdwfeather : so  foldr  doesn't have this problem (usually)
21:59:06 <shdwfeather> ski: ah, thank you, that makes a lot of sense
21:59:28 <lispy> > foldr const undefined [1..]
21:59:29 <lambdabot>   1
21:59:40 <lispy> > foldl (flip const) undefined [1..]
21:59:48 <lambdabot>   mueval: ExitFailure 1
21:59:58 <ski> shdwfeather : also, i'm not fully sure whether one should always prefer  foldl'  to  foldl, in any case one should do it in case the function argument is strict in its first argument (representing the current accumulator value)
22:00:48 <ski> shdwfeather : also, remember that  foldr  can work on infinite lists, while  foldl  and  foldl'  never can (as lispy showed an example of just above)
22:01:20 <dobblego> shdwfeather, I run a haskell course at work, here is a good exercise we did to come to understand list folds http://code.google.com/p/haskell-course/source/browse/ListExercises/ListExercises.hs 
22:01:35 <shdwfeather> ski: I saw lispy's example; how is that foldr works on infinite lists?
22:02:00 <ski> (shdwfeather : btw, the reason for "usually" in "so  foldr  doesn't have this problem (usually)", is that you can simulate  foldl  using  foldr  , and then you reproduce the same problem)
22:02:09 <ski> @src foldr
22:02:10 <lambdabot> foldr f z []     = z
22:02:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:02:26 <ski>      foldr const undefined [1..]
22:02:44 <ski>   =  foldr const undefined (1:[2..])  -- by unfolding of the list enumeration
22:03:09 <ski>   =  const 1 (foldr const undefined [2..])  -- by unfolding of the `foldr' call, by the second defining equation above
22:03:22 <ski>   =  1  -- by unfolding of the `const' call
22:03:25 <ski> @src const
22:03:25 <lambdabot> const x _ = x
22:03:43 <shdwfeather> oh
22:03:52 <shdwfeather> I see, interesting
22:04:00 <shdwfeather> that was really helpful, thank you
22:04:25 <ski> note that as Haskell is non-strict, it doesn't need to evaluate arguments to functions unless the function demands it (by pattern-matching)
22:05:03 <kmc> shdwfeather, did you see http://upload.wikimedia.org/wikipedia/en/thumb/3/3f/Fold-diagrams.svg/424px-Fold-diagrams.svg.png
22:05:34 <Lemon> Are there media players in Haskell?
22:05:34 <kmc> shdwfeather, «foldr f z» just replaces each (:) with f and each [] with z
22:05:59 <ski> > foldr f z (a : b : c : [])
22:06:03 <lambdabot>   f a (f b (f c z))
22:06:07 <ski> > foldl f z (a : b : c : [])
22:06:08 <lambdabot>   f (f (f z a) b) c
22:06:17 <kmc> > foldr (+) 0 (a : b : c : [])
22:06:18 <lambdabot>   a + (b + (c + 0))
22:06:18 <EvanR> that lajla person was banned? why?
22:06:42 <dobblego> EvanR, that was discussed in #haskell-ops
22:06:59 <kmc> EvanR, if you search logs you will see why i believe
22:07:13 <EvanR> k
22:12:57 <Lemon> hm
22:13:17 <Lemon> can't find instances of this "lajla" speaking in the past few days of the logs.
22:13:30 <Lemon> Curious is all.
22:13:53 <Lemon> Then again, it's probably something mundane, like spam.
22:15:10 <ski> dobblego : hm, one can do `forall f a b k. Functor k => k (f a b) -> k (Flip (Flip f) a b)' (and the other direction), but i can't see a way to do it, except possibly with some GHC magic (like e.g. the one used in <http://www.haskell.org/pipermail/haskell-cafe/2010-March/074305.html>, or using <http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes>)
22:16:23 <ezyang> What's an easy way to `seq` all the elements of a list? 
22:16:41 <ski> (Lemon : banned on July 12, it seems)
22:17:18 <kmc> ezyang, Control.Parallel.Strategies
22:17:30 <ski> ezyang : `foldr (\a as -> (: as) $! a) []' could be it
22:17:39 <ezyang> cool, thanks 
22:18:01 <ski> hm .. though on second thought, it's probably excessive to make a new list
22:18:41 <ski> so `foldr (\a () -> () $! a) ()', i suppose
22:18:45 <ezyang> rwhnf should force a Char or Word8 to be evaluated, no? 
22:19:06 <ski> er, replace  () $! a  with  a `seq` ()
22:19:37 <ski> ezyang : i'd expect so ..
22:20:03 <ezyang> :t rwhnf 
22:20:05 <dobblego> ski, yeah I think I'll give up on it -- it's either a newtype or nothing
22:20:06 <lambdabot> forall a. a -> Done
22:20:14 <ezyang> > rwhnf (undefined ::Char) 
22:20:16 <lambdabot>   *Exception: Prelude.undefined
22:20:18 <ezyang> huzzah 
22:20:31 <kmc> Strategies changed recently btw
22:20:46 <ezyang> Actually, I dunno if that's accurate 
22:20:50 <ezyang> kmc: Oh? 
22:21:25 <kmc> yeah
22:21:26 <kmc> there was a paper
22:21:42 <kmc> www.haskell.org/~simonmar/papers/strategies.pdf
22:21:56 <tolkad> how do you do that search for types?
22:22:02 <ezyang> > const 'a' $! using (undefined :: Char) rwhnf 
22:22:03 <lambdabot>   *Exception: Prelude.undefined
22:22:05 <kmc> @hoogle (a -> b) -> [a] -> [b]
22:22:05 <ezyang> tolkad: Hoogle 
22:22:06 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
22:22:06 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
22:22:06 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
22:22:14 <kmc> tolkad, there's also a website
22:22:18 <kmc> and hayoo, another website
22:22:23 <kmc> and you can private-message lambdabot too
22:22:24 <tolkad> @hoogle String -> [Word8]
22:22:24 <lambdabot> Prelude fail :: Monad m => String -> m a
22:22:25 <lambdabot> Control.Monad fail :: Monad m => String -> m a
22:22:25 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
22:22:41 <tolkad> uh that's not what I wanted 0_o
22:22:43 <ezyang> Excellent. I'm glad they're thinking about this stuff. 
22:22:50 <kmc> what do you want tolkad
22:23:01 <tolkad> I want to make a bytestring from a string
22:23:09 <Lemon> tolkad, you want
22:23:18 <Lemon> Data.ByteString.Char8.pack
22:23:24 <Lemon> and Data.ByteString.Char8.unpack
22:23:52 <tolkad> oh ok
22:24:06 <Lemon> I usually just do a "import qualified Data.ByteString.Char8 as B" and use "B.pack" and "B.unpack" where necessary.
22:24:39 <tolkad> > Data.ByteString.Char8.pack "x" :: data.ByteString.ByteString
22:24:39 <lambdabot>   <no location info>: parse error on input `data'
22:24:48 <tolkad> > Data.ByteString.Char8.pack "x" :: Data.ByteString.ByteString
22:24:49 <lambdabot>   Not in scope:
22:24:49 <lambdabot>    type constructor or class `Data.ByteString.ByteString'Not ...
22:24:55 <ski> @where hoogle
22:24:55 <lambdabot> http://haskell.org/hoogle
22:25:03 <Lemon> Lambdabot doesn't have that module loaded.
22:25:06 <ski> @where hayoo
22:25:06 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:25:12 <Lemon> Try it in your ghci instead.
22:25:13 <tolkad> @load Data.ByteString
22:25:14 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
22:25:18 <tolkad> @load Data.ByteString
22:25:18 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
22:25:19 <tolkad> @load Data.ByteString
22:25:19 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
22:25:19 <tolkad> @load Data.ByteString
22:25:20 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
22:25:30 <tolkad> @load Data.ByteString.Char8
22:25:31 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
22:25:33 <tolkad> @load Data.ByteString
22:25:34 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
22:25:37 <tolkad> it's not working
22:25:40 <Lemon> dude, chill.
22:25:41 <ski> tolkad : also, there's a `hoogle+' command in lambdabot to get the next three solutions
22:26:00 <Lemon> first, open a private convo with lambdabot if you're going to do that,
22:26:13 <tolkad> @hoogle String -> ByteString
22:26:13 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
22:26:13 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
22:26:13 <lambdabot> Prelude read :: Read a => String -> a
22:26:23 <Lemon> and second, the mark of insanity is trying the exact same thing multiple times and expecting different results.
22:27:13 <ski> tolkad : it looks like `load' got spell-checked to `read', for some reason ..
22:27:29 <jdavis> Is there a way to attach to a running process and see at least what part of the IO monad is being executed? (I'm just learning)
22:27:40 <tolkad> ski: ah, makes perfect sense
22:28:18 <ezyang> jdavis: You can use strace to attach to a running process on Linux. 
22:28:36 <ezyang> This will tell you what syscalls are being made, which is in many ways a good way of seeing what "IO" a process is doing. 
22:28:45 <ezyang> however, nothing directly related to Haskell. 
22:28:54 <ski> jdavis : alas, no SLIME for Haskell .. maybe try profiling or using `trace' ?
22:29:09 <jdavis> ezyang: yeah, it would be nice to see something slightly closer to the source code though.
22:29:28 <jdavis> ski: I'll try that.
22:29:56 * ski idly wonders whether Buddha still works
22:30:39 <jdavis> it seems like there should be a way to see that "evaluating a bunch of stuff due to a putStrLn call on line 17 of foo.c"
22:30:58 <ezyang> Haskell... doesn't really hold onto that info... 
22:31:45 <jdavis> I don't care as much about the "stuff", and I understand why that would be hard to present in a lazy language. However, the second part "...due to a putStrLn call on line 17 of foo.c" seems more doable.
22:32:41 <kmc> there's a thingy where you can use the profiling system
22:32:49 <kmc> to get stack traces on exceptions
22:33:08 <jdavis> kmc: hmm, ok
22:34:08 <jdavis> Perhaps one of you can classify my request as "reasonable, but not supported" or "unreasonable because it's a lazy language"
22:34:18 <avenge> Hey, does anyone know if there is good documentation for ReadP parsers?  I'm having a hard time figuring out the high-level idea from the minimal haddock documentation...
22:35:20 <ski> @where Buddha
22:35:20 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
22:37:17 <prsteele> `trace` lets me print something to the screen and return a value; how would I print to a file and return a value?
22:38:13 <dobblego> prsteele, putTraceMsg
22:39:05 <dobblego> prsteele, scrap that
22:39:06 <kmc> jdavis, it's definitely reasonable to wish for better debugging tools
22:39:12 <kmc> Buddha is cool
22:39:24 <kmc> prsteele, look at the source for trace
22:39:28 <kmc> it's quite short, uses unsafePerformIO
22:39:35 <kmc> but it's probably easiest to redirect stdout
22:39:58 <prsteele> @src trace
22:39:58 <lambdabot> trace string expr = unsafePerformIO $ do
22:39:58 <lambdabot>     hPutStrLn stderr string
22:39:58 <lambdabot>     return expr
22:41:04 <jdavis> kmc: looking at buddha now. Thank you.
22:41:34 <prsteele> kmc: thanks. I was thinking about just using trace and then piping the output, but this is better
22:43:36 * ski eats a JaffaCake, while pondering comonads ..
22:44:18 <ClaudiusMaximus> @undo do { a <- b ; a }
22:44:18 <lambdabot> b >>= \ a -> a
22:44:39 <ClaudiusMaximus> @pl b >>= \a -> a
22:44:39 <lambdabot> join b
22:45:22 <ski> @do mma >>= \ma -> ma
22:45:22 <lambdabot> do { ma <- mma; ma}
22:45:49 <ClaudiusMaximus> @pl \x -> f $ g x
22:45:49 <lambdabot> f . g
22:46:14 <ski> @. pl undo do { ma <- mma; ma }
22:46:14 <lambdabot> join mma
22:46:47 <ClaudiusMaximus> :t forever . join
22:46:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (m a) -> m b
22:49:01 <ski> @hoogle (m a -> m (m b)) -> (a -> m b)
22:49:01 <lambdabot> Data.Generics.Aliases ext1M :: (Monad m, Data d, Typeable1 t) => (e -> m e) -> (t f -> m (t f)) -> d -> m d
22:50:05 <ski> @djinn (a -> m a,m (m b) -> m b) -> (m a -> m (m b)) -> (a -> m b)
22:50:05 <lambdabot> f (a, b) c d = b (c (a d))
22:55:06 <kmc> ski, you have jaffa cakes for reals?
22:55:08 <kmc> those are mad tasty
22:55:45 <kmc> they're hard to find in the states :/
22:58:37 <ski> (kmc : "Jaffa Cakes  Sondey  Made in Germany", it says. flat round cakes with orange flavored filling and dark chocolate on one side ?)
23:00:31 <poljp> try getting jaffa cakes in japan!
23:00:50 <prsteele> Can anyone show me the code to emulate `echo`? The sample code at http://www.haskell.org/haskellwiki/IO_inside doesn't compile for me...
23:02:43 <ClaudiusMaximus> :t putStrLn . unwords =<< System.Environment.getArgs
23:02:43 <lambdabot> IO ()
23:03:58 <prsteele> ClaudiusMaximus: thanks
23:04:41 <prsteele> think you explain to me why `main = do
23:04:42 <prsteele>   a <- readLn
23:04:42 <prsteele>   print a` fails?
23:05:00 <Lemon> :t print
23:05:01 <lambdabot> forall a. (Show a) => a -> IO ()
23:05:07 <Lemon> :t readLn
23:05:08 <lambdabot> forall a. (Read a) => IO a
23:05:28 <ClaudiusMaximus> :t show . read
23:05:29 <Lemon> prsteele, are you getting a runtime or a compile-time error?
23:05:29 <lambdabot> String -> String
23:05:37 <prsteele> Lemon: compile time
23:05:53 <Lemon> I think you might need a type signature.
23:05:58 <ClaudiusMaximus> >  show . read $ "yes"
23:06:00 <lambdabot>   "*Exception: Prelude.read: no parse
23:06:01 <kmc> ski, that's a jaffa cake all right.  i think they're mostly british, 24 for 60p at sainsbury's
23:06:38 <Lemon> prsteele, try "do { (a :: String) <- readLn; print a}"
23:06:48 <ClaudiusMaximus> >  show . (id :: Int -> Int) . read $ "42"
23:06:49 <lambdabot>   "42"
23:06:57 <prsteele> Lemon: so adding Main :: IO String seems to help with readLn, but fails on print...
23:07:09 <ski> @type readLn
23:07:09 <lambdabot> forall a. (Read a) => IO a
23:07:16 <Lemon> prsteele, keep main :: IO ()
23:07:18 <ClaudiusMaximus> :t getLn
23:07:19 <lambdabot> Not in scope: `getLn'
23:07:25 <ClaudiusMaximus> :t getLine
23:07:26 <lambdabot> IO String
23:07:27 <Lemon> the problem is that the compiler needs to know what specific type to read.
23:07:43 <Lemon> just telling it that a comes from readLn doesn't provide enough info.
23:07:46 <prsteele> Lemon: Ah; I didn't know I could specify types like that (in-line)
23:08:13 <poljp> :t putStrLn
23:08:14 <lambdabot> String -> IO ()
23:08:26 <Lemon> you need to give -XScopedTypeVariables for it to work.
23:08:29 <poljp> putStrLn instead of print would force a :: String.
23:08:45 <ski> e.g. in `print (a :: Bool)' the type ascription ` :: Bool', forces `a' to be compatible with the type `Bool'
23:08:46 <Lemon> Or, you can just annotate elsewhere: "print (a :: String)"
23:08:51 <prsteele> Lemon: I was about to ask... are there downsides to that option? It seems a bit strange to need that...
23:09:12 <ClaudiusMaximus> > do { (a :: String) <- return "mayhaps" ; Just a }
23:09:13 <Lemon> prsteele, downside is that you're using a non-haskell98 extension.
23:09:14 <lambdabot>   Just "mayhaps"
23:09:21 <Lemon> There's really no others, I don't think.
23:09:21 <ski> Lemon's solution is probably nicer in most cases, but requires the `ScopedTypeVariables' extension (formerly `PatternSignatures')
23:09:44 <ClaudiusMaximus> > do { let a :: String ; a <- return "mayhaps" ; Just a }
23:09:45 <lambdabot>   <no location info>: parse error on input `<-'
23:09:48 <ski> you can also say
23:09:49 <ski>   print (a `asTypeOf` "foo")
23:10:04 <prsteele> so here's a question: why does `(a :: String) <- readLn` need -XScoped... but `a <- readLn; print (a :: String)` not?
23:10:37 <ski> prsteele : because in the former case, the type ascription is put on a pattern, and that wasn't standardized in H98
23:10:48 <ClaudiusMaximus> on the left of <- , a is a pattern, on the right, a is a variable
23:11:00 <ClaudiusMaximus> s/variable/value
23:11:07 <Lemon> prsteele, because in the former, you can do something like "(a :: t) <- getSomethingOrOther"
23:11:29 <Lemon> which would bind the type to "t", hence "Scoped"
23:11:49 <prsteele> okay
23:11:53 <Lemon> well, it's not binding.
23:12:24 <Lemon> more like t gets inferred to be whatever type it happens to be, and is used as a name for that point in the unification.
23:12:31 <ski> Lemon : imo, `PatternSignatures' is really a separate feature from `ScopedTypeVariables' .. though closely related, i admit
23:13:24 <ski> Lemon : i think one could say it is a binding, (in case `t' is not already in scope) .. hm
23:14:08 <ClaudiusMaximus> > do { let { a :: String } ; a <- return undefined ; Just a } -- if this works i'll be surprised :)
23:14:09 <lambdabot>   The type signature for `a' lacks an accompanying binding
23:14:09 <lambdabot>    (You cannot giv...
23:16:04 <Lemon> > do {(a :: String) <- return undefined; Just a}
23:16:05 <lambdabot>   Just "*Exception: Prelude.undefined
23:16:08 <Lemon> Works fine.
23:18:07 <ski> > do s :: String <- return mempty; Just (length `graph` s)
23:18:09 <lambdabot>   Just ("",0)
23:18:27 <ski> (you don't need brackets around the type ascribed pattern, here)
23:18:59 <ski> > do ns :: [Int] <- return mempty; Just (length `graph` ns)
23:19:00 <lambdabot>   Just ([],0)
23:19:44 <ClaudiusMaximus> @vixen which extensions do you have enabled?
23:19:46 <lambdabot> yes i do
23:21:38 <ljungk> I'm interested in how ghc actually manages to actually compile haskell considering all the laziness etc. I tried reading a .hc file but it was just to much. Where do I start if I want to learn how ghc works?
23:24:53 <EvanR> i read a book called implementation of functional programming languages and the end of the book talks about something called a G machine
23:25:03 <EvanR> if im not mistaken ghc is a refinement of this G machine idea
23:25:45 <ClaudiusMaximus> perhaps http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution might be a good place to start?
23:27:27 <ljungk> okay thanks
23:35:21 <prsteele> ski: hey ski, you helped me out with some code earlier... just solved the problem in Python in <10 minutes, still can't get the Haskell version to run :)
23:35:40 <tolkad> Someone told me earlier how to write a type signature so that a function can return any type which is an instance of the class, rather than having to be able to return all of them but I forgot. Does anyone know how to do that?
23:36:55 <dark> > (*3) `fmap` (+100) $ 1
23:36:56 <lambdabot>   303
23:37:14 <dark> here ghci says No instance for (Functor ((->) a))
23:37:22 <dark> Possible fix: add an instance declaration for (Functor ((->) a))
23:37:34 <dark> The Glorious Glasgow Haskell Compilation System, version 6.8.2
23:37:46 <ski> prsteele : hm .. which problem might that be ?
23:37:48 <dark> any ideas? i'm at http://learnyouahaskell.com/functors-applicative-functors-and-monoids
23:38:07 <dark> this works:
23:38:07 <dark> Prelude> (*3) . (+100) $ 1
23:38:08 <dark> 303
23:38:09 <ski> dark : import `Control.Monad.Reader' or `Control.Monad.Instances' or something like that
23:38:17 <dark> ah
23:38:45 * ski can't remember where `instance Functor (r ->)' is kept, nowadays
23:38:52 <dark> yes, .Instancesworks
23:38:54 <dark> nice=)
23:39:17 <prsteele> <ski> > let problem prs stop = loopA prs 0 where loopA (ap:aps) = loopB prs
23:39:18 <prsteele> 	  where loopB (bp:bps) = loopC prs where loopC (cp:cps) | num <= stop =
23:39:18 <prsteele> 	  loopC cps . succ | cp /= 2 = loopB bps | bp /= 2 = loopA aps | otherwise
23:39:18 <prsteele> 	  = id where num = ap^4 + bp^3 + cp^2  in  problem [2,3,5,7,11,13] 100
23:39:33 <dark> ps: i'm astonished at the simplicity of "interact"
23:39:52 <ClaudiusMaximus> ---- :m + Control.Monad.Instances \n :info Functor
23:40:46 <ski> prsteele : .. and ?
23:41:08 <tolkad> hmm, I guess I'll have to search my logs
23:41:38 <prsteele> ski: nothing in particular. You helped me make the code more compact, but when I changed it to keep track of the results it had I kept failing on stack space. Just thought it was funny that I was able to solve it so simply in another language.
23:41:42 <poljp> tolkad: do you mean something like f :: (TheClass t) => a -> t ?
23:41:47 <poljp> (probably doesnt compile)
23:41:58 <prsteele> ski: I have a long way to go :)
23:42:03 <ski> tolkad : hm, are you talking about writing like `elem :: Eq a => a -> [a] -> Bool' ?
23:42:35 <poljp> oh btw, why doe ghc sometimes use t and sometimes use a for types in :t expressions ?
23:42:45 <poljp> or a1 etc for that matter.
23:43:41 <ski> poljp : it tries to be helpful, and reuse the same type variables that are used in signatures of operations used in the expression
23:43:43 <ClaudiusMaximus> ski: as far as i understand it the caller gets to choose 'a' there, tolkad might mean existentials?
23:44:07 <poljp> ski: thanks
23:44:30 <ski> ClaudiusMaximus : oh .. i suppose i was interpreting "any" in "a function can return any type which .." in the opposite sense
23:44:37 <tolkad> I mean like, in an OOP language I can make an interface which has a function which returns something of type Number, and an implementation could return Integer. In haskell the implementation would have to return the kind of thing fromIntegral returns, that can be automatically converted into any Number.
23:44:54 <ski> ok, sounds like existentials, yes
23:45:10 <ski>   foo :: Barf -> SomeNum
23:45:14 <poljp> :t fromIntegral
23:45:15 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:45:25 <ski>   data SomeNum = forall n. Num n => WrapNum n
23:45:51 <tolkad> oh, it requires an extension...
23:45:59 <tolkad> I think I should probably stick to standard haskell
23:46:04 <ClaudiusMaximus> > let fi = fromIntegral in (fi 42, fi 42) :: (Int, Double)
23:46:05 <lambdabot>   (42,42.0)
23:46:18 <tolkad> thanks
23:46:34 <ski> tolkad : if you want the callee, not the caller, to decide what type to use, then yes it requires (a commonly supported) extension
23:46:53 * ski wonders whether there's any haskell implementation that doesn't support existentials
23:47:13 <ski> (.. possibly Helium, i suppose .. how about YHC or NHC ?)
23:47:20 <ClaudiusMaximus> > let { fi = fromIntegral ; both f (a,b) = (f a, f b) } in both fi (42, 42) :: (Int, Double)
23:47:20 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:47:20 <lambdabot>         against inferred type ...
23:48:17 <ski> ClaudiusMaximus : `Rank2Types'
23:49:22 <dobblego> @type mfix
23:49:23 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:49:34 <tolkad> well, it's mostly that when you use extensions you have to remember to type them every time you compile
23:49:41 <kmc> tolkad, no, you put it in the file
23:50:10 <ski> tolkad : well, add `{-# LANGUAGE ExistentialQuantification #-}' at the top of the module
23:50:13 <kmc> {-# LANGUAGE RankNTypes, IgnoreTypechecking #-}
23:50:15 <kmc> at the top
23:50:48 <tolkad> O_O
23:50:58 <tolkad> IgnoreTypechecking? that sounds very bad
23:51:02 <ClaudiusMaximus>   {-# LANGUAGE HaskellButNotAsWeKnowIt #-}
23:51:12 <ski> kmc : that is fabricatino, `IgnoreTypechecking' doesn't exist !
23:51:18 <kmc> {-# LANGUAGE HaskellAsSheIsSpoke #-}
23:51:57 * ski traps kmc inside an existential quantification
23:52:03 * kmc unsafeCoerces his way out
23:52:58 <ski> ha !, "Not in scope: `unsafeCoerce'"
23:53:18 <kmc> back in my day we just built with -fglasgow-exts
23:53:24 <kmc> and had exciting surprises
23:53:50 <ski> back in *my* day, we used `-98' .. and we *liked* it !
23:54:05 <kmc> haha
23:54:08 * kmc hugs ski
23:56:02 <ketil> But we were happy in those days, even though we had only non-standard extensions....
23:56:19 <kmc> we didn't have type families :/
23:57:37 <ski> but we did have restricted type synonyms ..
23:57:50 <ski> and Trex !
23:58:32 <tolkad> is [ a function?
23:58:36 <ski> no
23:58:44 <ski> it is syntax
23:58:57 <ski> `[]' is a data constructor
23:58:58 <tolkad> I saw something weird in GHC source...
23:59:17 <ski> and `[x,y,z]' is syntactic sugar for `x : (y : (z : []))'
23:59:20 <poljp> there be dragons.
23:59:44 <ski> also, there's list enumerations, and list comprehensions
