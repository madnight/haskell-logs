00:00:54 <theorbtwo> Sadly, I'm not terribly sure that "is cited" is a terribly good thing to make decisions on.  After a while, you'll just get spam that goes "get herbal callis [[here]]<ref>[[anotherspamlink]]</ref>".
00:01:57 <gwern> theorbtwo: most vandals aren't very good
00:02:03 <theorbtwo> Yeah.
00:02:25 <theorbtwo> That is, in a way, the sad downside of things like nofollow.
00:02:27 <gwern> and at that point, how can a machine or a person know it's vandalism without actually going out and checking the citation?
00:02:44 <gwern> assuming your example doesn't get nailed for having a common spam keywird
00:02:53 <theorbtwo> Exactly.
00:03:11 <theorbtwo> OTOH, that's actually a pretty common failing in classifiers, I think.
00:03:42 <theorbtwo> Spam assassian uses the bayes classifier as one test amongst many... which means that it cannot learn if it's other tests are useful.
00:03:47 <ezyang> btw, if anyone has a good introduction to SVMs I'm all ears 
00:07:14 <theorbtwo> If they considered "mail has lots of html" as a specal token, then they'd dynamicly learn if it was useful for that user or not.
00:08:49 <ddarius> @tell shapr The web thing I was remembering was Halipeto by Andrew Cooke.
00:08:49 <lambdabot> Consider it noted.
00:09:23 * ddarius doesn't understand why these propositions need to be reduced to "tokens."
00:10:45 <napping> theorbtwo: you can train the classifier against all messages if you want
00:10:45 <gwern> you need to break down your input. imagine every wikipedia page came with a timestamp - that is, each bitstream was unique'
00:11:17 <gwern> how could your program learn if it can't peer into the structure?
00:12:14 <theorbtwo> ddarius: Because, by defintion, a token is what you train a bayes classifier against.
00:12:54 <gwern> come to think of it, even emails are binary-unique - a resend of an email will have different timestamps in the headers based on when it passed through the servers
00:12:57 <napping> ddarius: a bayes classifier is based on a models that give a probability for any given message to be produced by that model
00:13:10 <napping> you compute P(message | spam model), P(message | not-spam model)
00:13:14 <ddarius> By definition, probabilities operate on propositions.
00:13:39 <napping> so, the trick is to come up with models that produce nonzero probabilities for any input (otherwise you get nasty divide by zeros and stuff), and are also trainable
00:13:56 <wli> I thought they were subsets of the event space or something.
00:14:02 <napping> just about the dumbest way is to chop the messages up into tokens and make a conditional independence assumption
00:15:22 <ddarius> napping: I don't know why you are telling me this.
00:15:45 <theorbtwo> ddarius: What part do you not understand about why these propisitions are called tokens?
00:15:48 <napping> ddarius: you were asking why you reduce propositions to tokens in classifiers
00:17:05 <ddarius> My point is the -tokens- represent propositions which are fed to the Bayes classifier.  You can have arbitrary propositions, such as, as you said, "contains a lot of HTML."  There's no reason to turn this into some kind of "token" and then turn it back into a proposition.
00:18:22 <ezyang> Constructing these propositions ends up being kind of hard though 
00:18:26 <ezyang> in my experience, at least. 
00:20:18 <ddarius> The terminology is like: I have a vector graphics engine but I only use squares, so vector engines are only fed squares and to represent a circle I use a special square.
00:38:50 <tibbe> dcoutts_: ping
00:41:18 <gwern> tibbe: is dcoutts_ up at this hour?
00:43:07 <tibbe> gwern: isn't he in the UK?
00:43:18 <gwern> dunno
00:43:31 <gwern> but I see him a lot during more normal EST hours than GMT
00:46:41 * hackagebot wai-extra 0.1.3.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.1.3.1 (MichaelSnoyman)
01:01:23 <emilmeln> Does anyone here have a solid understanding how STM implemented in GHC?
01:01:24 <lambdabot> emilmeln: You have 1 new message. '/msg lambdabot @messages' to read it.
01:03:57 <emilmeln> Please look at this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27202 . It seems to work, but I think there is an error.
01:06:36 <Cale> emilmeln: You know about TArray, right?
01:07:13 <emilmeln> Cale: Of course a do. But I need somthing like an MArray within one TVar.
01:07:20 <Cale> Though I guess it just uses a single Array of TVars rather than this sort of thing.
01:07:56 <Cale> TArray is an instance of MArray
01:08:55 <emilmeln> I need a whole array in tvar rather than an array of tvars.
01:09:12 <emilmeln> A mutable array of course.
01:09:19 <Cale> Is that semantically different?
01:09:29 <Cale> hmm...
01:09:56 <emilmeln> Write to any array element would affect all threads that retry.
01:10:41 <Cale> I suppose you could just use a TVar (TArray i e)
01:10:53 <Cale> er, hmm
01:11:21 <Cale> Except that you wouldn't necessarily be writing to the TVar much then.
01:12:58 <emilmeln> Cale: What about arrays with 30-50k elements?
01:13:22 <Cale> I have no idea about the constant factors involved here.
01:13:33 <Cale> Do TArrays normally not work at that size?
01:13:43 <Cale> I wouldn't expect them to fail.
01:13:54 <Cale> Though they are boxed arrays.
01:14:26 <emilmeln> Hmm, I will do some benchmarking right now.
01:15:23 <Cale> They might be a good deal larger than you want them to be, but I wouldn't expect them to be so much larger that it would be a problem for a few such arrays.
01:15:56 <Cale> anyway, should sleep :)
01:16:14 <ivanm> Cale: sleep? what's that?
01:16:15 <ivanm> :p
01:39:52 <MasseR> I have stumbled on the term 'combinator'. After a bit of googling, I've seen connections to pointfree. What _is_ the connection to pointfree if there is any? If not, what are combinators
01:43:11 <emilmeln> I've made a simple benchmark. Results: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27202#a27204
01:44:11 <emilmeln> But I'm unsure about it's correctness
01:44:43 <eevar2> MasseR: http://stackoverflow.com/questions/97637/good-explanation-of-combinators-for-non-mathematicians
01:47:16 <MasseR> eevar2: Thank you
01:49:21 <dolio> Combinators are functions defined using application and their arguments, and possibly other combinators.
01:49:40 <dolio> s f g x = f x (g x), k x y = x, i x = x...
01:50:17 <dolio> Although people use the term more loosely, too.
01:50:17 <Saizan> though the term "combinator" is often used in a broader and fuzzier sense
01:54:32 <Jonno_FTW> when will the wiki be back to the newer style?
01:55:14 <arcatan> why the wiki looks like what it looks like, by the way?
01:55:54 <Axman6> they lost the CSS file
01:56:35 <arcatan> oh. why the HTTP library has funny version numbers?
01:56:52 <Saizan> for fun
01:57:30 <emilmeln> pool/main/h/haskell-http/libghc6-http-dev_40000009-2_i386.deb
01:57:44 <Saizan> HTTP used the release data as the version, before hackage 
01:58:16 <Saizan> so then it had to use those funny numbers to keep it increasing
01:58:17 <arcatan> then it jumped to the next millenia
02:36:25 <CakeProphet> question
02:36:36 <CakeProphet> if I define record accessor functions
02:36:54 <CakeProphet> that happen to be the same name as a typeclass method, and I want to make an instance of the type
02:37:15 <CakeProphet> will Haskell complain if I just leave those declarations out because they're already defined by an accessor?
02:40:40 <arcatan> CakeProphet: I don't think that will work out
02:40:53 <CakeProphet> ah
02:41:07 <CakeProphet> but I can certainly give them different names but plug them in if they're the same type right?
02:42:17 <arcatan> CakeProphet: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27205#a27205 you could do it like this
02:42:47 <arcatan> and yes that would work too
02:44:02 <apfelmus> Hi. :)
02:44:03 <lambdabot> apfelmus: You have 1 new message. '/msg lambdabot @messages' to read it.
02:45:06 <PetRat> Hii apfelmus, this Michael Mossey.
02:45:22 <apfelmus> Ah, hello Michael. :)
02:45:27 <PetRat> I read your post about memoization. 
02:45:49 <PetRat> I didn't quite follow the difference between   f n =     and f = \n ->   
02:46:20 <apfelmus> Ah, that's a bit subtle, but straightforward, actually.
02:46:25 <CakeProphet> PetRat:  there isn't one
02:46:50 <apfelmus> If you write both as lambda expressions, you get
02:46:56 <apfelmus> f = \n -> let memo = .. in ...
02:46:57 <apfelmus> vs
02:47:07 <apfelmus> f = let memo = ... in \n -> ...
02:47:45 <PetRat> I think I see. In the latter, memo is part of the closure of the lambda expression?
02:47:59 <apfelmus> Yes.
02:48:02 <apfelmus> In the first case, it allocates a new memo table for each argument n that is supplied.
02:48:17 <apfelmus> In the latter, the memo table is allocated once and then re-used for every n.
02:49:12 <PetRat> Is the use of Array critical to the use of memoization? Would it work to create a list without converting to an array, ... just suffer in lookup time?
02:49:21 <quicksilver> incidentally this isn't technically specified
02:49:26 <quicksilver> apfelmus is describing GHC's behaviour
02:49:30 <apfelmus> Sure, works just as well.
02:49:36 <quicksilver> which is quite sane, and shared by most other implementations.
02:49:58 <quicksilver> the two things apfelmus wrote are permitted to compile to the same code - and it would be a permitted optimisation to transform one to the other
02:50:16 <quicksilver> in practice GHC does compile them different, and it doesn't often make that optimisation.
02:50:33 <PetRat> quicksilver: is there a way to force the desired behavior?:
02:50:39 <apfelmus> Yup, it's not in the Haskell standard because the standard doesn't specify semantics concerning evaluation order or space & time usage.
02:50:52 <quicksilver> PetRat: not a standard way, not.
02:53:08 <apfelmus> The optimization (replace the former code with the latter) is called "let floating", but GHC usually refrains from doing it because it can change space usage drastically.
02:53:19 <PetRat> What is the parenthesized list in an import called?  import SomeModule(Thing1,Thing2)
02:53:36 <apfelmus> I.e. if  memo  is large, it might make sense to recalculate it every time.
02:53:54 <quicksilver> PetRat: import list.
02:54:03 <PetRat> Are data constructors allowed in the import list?
02:54:15 <quicksilver> yes, but not at the top level
02:54:27 <quicksilver> import SomeModule(function1,function2,Type1(Cons1,Cons2))
02:54:40 <quicksilver> or just import SomeModule(function1,function2,Type1(..)) to get all constructors.
02:54:58 <PetRat> quicksilver: I see
02:56:04 <quicksilver> GHC does do let-floating but not often and I don't understand when. There is a paper on it although I don't know if it's out of date.
02:56:12 <PetRat> Could you potentially have different qualifications on data constructors, e.g.   import qualified Module(Type1(Con1)) as Crazy        import qualified Module(Type1(Con2)) as Scheme
02:56:30 <quicksilver> can't see why not.
02:57:45 <PetRat> I noticed that the docs for Map suggest:     import Map(Map)    import qualifed Map as M
02:57:56 <CakeProphet> is it possible to refer to something like Monad.(>>)
02:58:03 <CakeProphet> for the original definition of (>>) before overload?
02:58:35 <PetRat> The name clash with Prelude suggests the M. I guess import Map(Map) is aesthetically pleasing so you can call it Map and not M.Map
02:58:49 <quicksilver> CakeProphet: if you are talking about a default method definition which you gave an explicit definition, then the answer is no.
02:58:58 <quicksilver> I wouldn't use the word 'overload' for that.
02:59:32 <quicksilver> unless the module authors gave it a name as a function not a method - like defaultBind.
02:59:39 <quicksilver> which they haven't, although that is sometimes good practice.
03:03:34 <quicksilver> not like >>= \_ -> is hard to type though
03:10:27 <apfelmus> So, I made this slideshow/video thing recently http://apfelmus.nfshost.com/blog/2010/07/02-fixed-points-video.html
03:10:35 <apfelmus> But I'm kinda unsure where to go from here.
03:13:46 <apfelmus> Some people prefer videos, some prefer text, and I'm trying to combine them to make everyone happy.
03:15:13 <apfelmus> I still don't know whether the combination slideshow/video actually helps with that, though. What does #haskell think?
03:15:46 <apfelmus> There were lots of technical issue.
03:15:56 <apfelmus> *issues
03:16:37 <apfelmus> Like the video not playing on FF on Linux. is there a way I could debug that?
03:27:25 <PetRat> apfelmu: I'm watching the video. 
03:27:32 <PetRat> apfelmus: rather
03:27:46 <PetRat> Seems like no one else in one #haskell
03:28:09 <Tomsik> BOO!
03:28:31 <ivanm> eeek!!!
03:28:39 <apfelmus> :)
03:30:23 <PetRat> I'm in the Pacific Time Zone so I probably won't be up much longer.
03:31:13 <ivanm> PetRat: last I checked, the pacific was a big ocean...
03:31:14 <ivanm> ;-)
03:31:31 <apfelmus> PetRat: You're happy with the video by itself, and don't care much about the slide?
03:31:34 <apfelmus> *slides
03:31:41 <mreh> ever heard of the azores?
03:31:50 <mreh> not so clever now
03:31:57 <PetRat> Most of the Pacific is dark right now anyway
03:32:06 <PetRat> Well, dusk
03:33:13 <PetRat> apfelmus: I'm happy with the video on first watching. I am a beginner, and I find that good lectures convey something beyond the words. It's HOW someone says the words that gives insight into their thought process.
03:33:38 <PetRat> So even if I know where you are going, I still want to hear how you say it.
03:35:52 <apfelmus> PetRat: Yep, video is great at showing the thought process; quite impossible to do that in text.
03:37:16 <apfelmus> PetRat: Your second remark is interesting. Can I interpret that as: even if you read the text next to slides, you still want to hear me say it?
03:38:28 <Blkt> > zipWith (+) [1,2,3] [10,20,30]
03:38:29 <lambdabot>   [11,22,33]
03:39:34 <Blkt> good day everyone
03:41:23 <PetRat> apfelmus: I want to hear you say it because you actually say many more words than are written, which adds insight. Good written text is compact; a good lecture is very different... 
03:42:39 <PetRat> When you transcribe a lecture it looks strange because there is so much repetition and non-grammatical comments. But I notice you repeat the term combinator many times even when it is not in the visual text, which helps to reinforce the use of that term in my brain.
03:43:29 <ClaudiusMaximus> morning!  i'm still struggling to understand my profiling report: a record field accessor is supposedly consuming 7%/8% of my time/allocs
03:44:21 <apfelmus> PetRat: True that. So, the text on the right hand side is no substitute for my words. What about subtitles, would you find that useful?
03:44:33 <PetRat> I noticed something a while ago. TV meterologists need to have an advanced degree to get the job, but seem to do little beyond stand in front of a green screen and say "Thunderstorms are predicted for tomorrow." But....
03:44:33 <ivanm> ClaudiusMaximus: that indicates that getting/setting that field takes 7-8% of your runtime/allocs
03:45:15 <verdelyi> can someone help me out about what the second and third where clauses in http://fpaste.org/Ad0e/ mean?
03:45:31 <PetRat> One time the meteorologist was sick and the regular announcer read the forecast. You could tell right away that she ---> didn't really understand the concepts in depth <----
03:45:44 <ClaudiusMaximus> ivanm: hm, ok - any way to separate the getting and setting?
03:45:49 <ivanm> verdelyi: the second is a where clause local to storableData; the third is a where clause local to storableType
03:46:11 <ivanm> ClaudiusMaximus: not too sure
03:46:14 <PetRat> apfelmus: subtitles as in a transcription of your spoken words?
03:46:23 <ivanm> ClaudiusMaximus: check below where it gets used and see what you're doing with it in those functions?
03:46:33 <ivanm> ClaudiusMaximus: however, I have the sneaking suspicion that it's _all_ just for setting
03:46:47 <ClaudiusMaximus> ivanm: yes, that would make sense
03:46:49 <verdelyi> ivanm: and what does it mean if you define "PrimitiveData r " in a where clause? I'm only used to defining normal functions, not data constructors
03:46:51 <apfelmus> PetRat: Yes, every one of my spoken words.
03:47:07 <ivanm> verdelyi: in that sense, it's evaluating the RHS, and pattern matching on it to extract the `r' value out
03:47:20 <ivanm> you're not actually defining the constructor there
03:47:48 <verdelyi> ivanm: so actually r and i are defined there?
03:48:03 <ivanm> yup
03:48:16 <PetRat> apfelmus: I might have to experience it to have a real comment, but my first thought is that there is a point to listening to a lecture (i.e. processing it with your auditory cortex) because that is a particular learning mode that is often critical....
03:48:23 <verdelyi> ivanm: and the PrimitiveData stripped, it's substituted into the above line?
03:48:56 <ivanm> yeah
03:49:00 <PetRat> not the only learning mode... multiple modes are probably needed... but for people who learn well by listening, reading the text wouldn't really substitute
03:49:05 <verdelyi> ivanm: ok I think I get it now, thanks
03:49:29 <ivanm> verdelyi: it's like how you can do this:
03:49:36 <ivanm> > let myHead xs = let Just x = listToMaybe xs in x in myHead [1..10]
03:49:37 <lambdabot>   1
03:50:03 <verdelyi> hmm
03:50:47 <apfelmus> PetRat: Yep. I don't plan on replacing my spoken words, just wondering whether adding subtitles would make an additional learning mode available or whether it would distract. This is best answered with an experiment. ;)
03:51:36 <ivanm> verdelyi: note that something like this is very unsafe to do unless you can guarantee that it will only use that constructor (i.e. it's the only constructor)
03:51:44 <PetRat> I know a book about piano playing. The author was not a conventional writer---she wrote down words very much like she would lecture. Most people complained the book was impossible to read. But one teacher I knew said the key was you had to read very fast.
03:52:23 <apfelmus> PetRat: Ooh, nice. What's the title?
03:53:12 <PetRat> "Mastering the Chopin Etudes and Other Lectures" by Abby Whiteside
03:53:15 <verdelyi> ivanm: ok, I think in my case it's guaranteed
03:53:33 <ivanm> right, probably because it's the only constructor
03:53:44 <apfelmus> PetRat: Thanks!
03:54:08 <PetRat> s/Lectures/Essays
03:54:29 <verdelyi> ivanm: actually, we're planning on getting rid of that constructor as well :)
03:54:40 <ivanm> heh
03:54:43 <apfelmus> PetRat: I have to leave. Any last subject request for my next video? :)
03:54:58 <PetRat> hmm....
03:55:30 <PetRat> I'm trying to think what interests me right now...
03:56:01 <PetRat> I really am interested in anything.  See you later.
03:56:35 <apfelmus> PetRat: Hehe. :) See you, and thanks for your comments!
03:57:22 <verdelyi> ivanm: oops, that's not the only constructor
03:57:27 <ivanm> heh
03:59:28 <danr> I am trying to use SDL-ttf and OpenGL to render text, did anyone manage to do this? I found a bunch of C++ tutorials but I cannot manage to translate them.
03:59:49 <kmc> danr, what problem are you running into?
03:59:56 <kmc> i could help you translate c++ probably
04:00:12 <danr> kmc: let's see
04:00:17 <verdelyi> ivanm: but looking at the storableData implementations, they're all returning the right one
04:00:26 <Ke> aren't sdl and opengl apis pure C
04:01:29 <danr> kmc: so far I have got is to render solid text, and then created a new sqare surface and then I'm trying to blit the text surface to this new surface
04:01:51 <danr> kmc: here i get a segfault, so I haven't actually started to use the opengl commands
04:02:24 <benmachine> SDL segfaults for me on exit sometimes
04:02:34 <benmachine> or maybe that was an old version
04:03:25 <kmc> danr, if you're using SDL for OpenGL then you won't be using its blitting i think
04:04:30 <danr> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27206#a27206
04:05:01 <danr> kmc: how would you suggest doing it?
04:06:20 <kmc> hmm, i see
04:06:41 <kmc> the surface you create with "new" should not be an OpenGL surface
04:07:00 <kmc> that blit is just for color space conversion i think
04:07:16 <kmc> to make sure you have an RGB24 surface before you call glTexImage2D
04:07:41 <kmc> that's slightly fishy, it'd be better if you could make renderTextSolid produce the right sort of surface to begin with, or make OpenGL accept whatever sort it produces
04:07:56 <kmc> anyway you can't afaik draw to an OpenGL surface using blit or by writing pixels
04:08:01 <kmc> you draw to it by doing OpenGL stuff
04:08:14 <kmc> also, are you sure you want to use unsafeForeignPtrToPtr
04:08:43 <danr> kmc: no I am not sure of that. in the c++ code they just use myNewSurface->pixles
04:08:57 <danr> kmc: a little too much spray and pray programming from my sife
04:09:33 <danr> kmc: but it seems in the c++ examples that they use glTexImage2D to get the data from an SDL surface to OpenGL
04:09:41 <kmc> yes
04:09:59 <benmachine> danr: surfaceGetPixels, I think?
04:10:12 <kmc> surfaceGetPixels :: Surface -> IO Pixels
04:10:23 <benmachine> right, and Pixels is a Ptr of some kind iirc
04:10:42 <danr> benmachine: kmc: seems to be a much more appropriate function thansk
04:10:55 <kmc> type Pixels = Ptr PixelsData
04:11:18 <kmc> PixelsData is an uninhabited type; you'd cast to whatever type has the Storable instance you actually want
04:11:22 <kmc> e.g. (Word8,Word8,Word8)
04:11:25 <benmachine> hrrrm, ghci's :info refuses to tell me that
04:11:28 <kmc> so Ptr (Word8,Word8,Word8)
04:11:33 <benmachine> but yeah, I've castPtr'd it before
04:11:34 <kmc> benmachine, yeah, i had to dig into source
04:12:17 <danr> kmc: do you suggest SWSurface instead of OpenGLL
04:12:39 <kmc> danr, not being an SDL expert i'm not sure
04:13:07 <benmachine> I suggest experimentation :P
04:13:24 <danr> okay, i'll experiment a bit more
04:13:59 <kmc> i think SWSurface
04:14:02 <danr> do you know how texImage2D works? the CubeMapTarget, Proxy and Level parameters for instance
04:14:18 <kmc> yes, i do
04:14:23 <kmc> sec
04:15:48 <kmc> "Use the GL_PROXY_TEXTURE_2D target to try out a resolution and the implementation will update and recompute its best match for the requested storage resolution"
04:15:55 <kmc> i.e. not for loading actual textures
04:16:01 <kmc> CubeMapTarget is for cube mapping
04:16:06 <kmc> which i assume you're not doing
04:16:13 <danr> kmc: indeed not
04:16:19 <kmc> level is for level-of-detail (mipmapping)
04:16:24 <kmc> i.e. smaller textures that get used when further away
04:16:26 <danr> kmc: but ofcourse!
04:16:28 <kmc> also probably not a concern
04:16:49 <danr> kmc: so if I'm not mipmapping, I just put 0?
04:16:54 <kmc> basically OpenGL has loads of knobs, dials, and levers... most of which should be ignored and set to 0 or some other sensible default
04:16:55 <kmc> yeah
04:17:07 <danr> kmc: and the Border?
04:17:24 <kmc> 0
04:17:25 <Zao> danr: Did you read the Fine Man Page for it?
04:17:34 <Zao> Or heck, the OpenGL Standard.
04:17:39 <kmc> http://www.opengl.org/sdk/docs/man/xhtml/glTexImage2D.xml
04:17:50 <danr> Zao: some years ago maybe :)
04:17:56 <danr> Zao: but thanks, yes
04:18:31 <danr> Zao: it's just that the hopengl texImage2D has different parameters than glTexImage2D
04:18:51 <kmc> yeah
04:18:52 <Zao> danr: So dig into the source and see how they map :)
04:18:58 <kmc> you have to figure out the mapping, or read it
04:19:00 <kmc> in the source
04:19:04 <kmc> still, it's usually pretty direct
04:19:26 <kmc> and you need to know what the API will do, in addition to knowing how to get arguments to it
04:20:28 <Zao> Like say, knowing what a texture border is and when you want one :)
04:20:45 <Zao> Something I believe the Standard covers in some detail.
04:35:59 <augur> whoever told me to look at combinatorial species, you're insane. this crap is way over my head
04:36:30 <danr> I managed to write the text, posting the link: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27206#a27207
04:36:45 <danr> thanks kmc benmachine and well, Zao :)
04:38:24 <kmc> danr, congrats
04:38:35 <kmc> danr, btw this is useful to me too, i've been looking for a better way to do text in opengl
04:39:46 <danr> kmc: all well then :) I'm going to clean up the code
04:41:06 <quicksilver> danr: Nice.
04:41:17 <quicksilver> I have done the same thing with WX.
04:42:17 <kmc> danr, the stuff in renderPrimitive looks like it could be a mapM_ over a small list of vertices
04:43:37 <danr> kmc: yes i am aware of it :)
04:44:17 <quicksilver> also you don't need all those 'tod' around literal numbers
04:44:23 <quicksilver> literal numbers are already polymorphic
04:50:12 <Ke> AAAA, darcs is slow++
04:51:13 <kmc> yeah
04:51:15 <kmc> @karma slown
04:51:15 <lambdabot> slown has a karma of 0
04:51:16 <kmc> @karma slow
04:51:16 <lambdabot> slow has a karma of 1
04:51:45 <verdelyi> @karma karma
04:51:45 <lambdabot> karma has a karma of 1
05:21:42 <illissius> @karma objective-c
05:21:42 <lambdabot> objective-c has a karma of 19
05:21:58 <illissius> :}
05:22:40 <ivanm> :o
05:25:07 <Starfire> Is there any trick to section (-) without resorting to stuff like (\x -> x - c) or flip (-) c ?
05:25:16 <magicman> @karma chameleon
05:25:16 <lambdabot> chameleon has a karma of 4
05:25:26 <ivanm> Starfire: subtract
05:25:35 <ivanm> > map (subtract 3) [1..10]
05:25:36 <lambdabot>   [-2,-1,0,1,2,3,4,5,6,7]
05:25:41 <Starfire> Ahh, thanks.
05:25:51 <ivanm> note that subtract = flip (-)
05:25:54 <ivanm> @src subtract
05:25:54 <lambdabot> subtract x y = y - x
05:29:11 <chrisdone>  @src (-)
05:29:11 <chrisdone> a - b = subtract b a
05:29:18 <chrisdone> jaspervdj: hey how's blaze going?
05:29:47 <arch1> hello to all ; i've a question for BONUS regard the online manual 'learyouhaskell'
05:29:51 <jaspervdj> chrisdone: Hey! Pretty good, altough slightly slower lately
05:30:02 <chrisdone> jaspervdj: why so?
05:30:02 <jaspervdj> arch1: don't ask to ask, just ask :-)
05:30:11 <zygoloid> preflex: seen BONUS
05:30:12 <preflex>  BONUS was last seen on #haskell 23 days, 19 hours, 37 minutes and 1 second ago, saying: :)
05:30:25 <jaspervdj> chrisdone: University stuff that needed finishing :-/
05:30:27 <zygoloid> arch1: someone else here might be able to help. what's the question?
05:30:45 <zygoloid> arch1: if not, you can leave BONUS a message with lambdabot
05:32:16 <chrisdone> jaspervdj: ah well. i'm using blaze in production code :p only for one tiny function and not really for speed, but I like the convenient API as a feature in itself
05:32:51 <jaspervdj> chrisdone: ah, what function?
05:33:23 <chrisdone> postMessage :: (JSON j) => FormId -> j -> ByteString
05:33:23 <chrisdone> postMessage fid j = H.renderHtml $ do
05:33:23 <chrisdone>   H.html $ H.head $ H.script $
05:33:23 <chrisdone>     H.preEscapedString $ "window.parent.postMessage(" ++ string j ++ ",\"*\");"
05:33:27 <chrisdone> :p
05:33:32 * chrisdone wasn't lying about the 'tiny'
05:34:36 <jaspervdj> Cool that you found a Haskell job
05:34:46 * chrisdone high fives
05:34:51 <jaspervdj> I remember you weren't very happy with your job when you were at zurihac :-)
05:34:59 <chrisdone> indeed :-)
05:36:49 <arch1> okay : in manual 'learningyouhaskell.com' in cap for MODULES the examples at end of page html say the name in sub Geometry with initial name in lower case : sphere.hs, cuboid.hs, etc  but this give an error in import module;  if i give the name of file as Sphere.hs , for example , no problem ;  is possible an error in manual ?
05:37:28 <chrisdone> jaspervdj: did you see Chris Eidhof's home page? really neat concept: http://eidhof.nl/
05:37:45 <arch1> no  : can help me
05:37:47 <arch1> ?
05:37:53 <jaspervdj> chrisdone: yes, love it
05:38:20 <jaspervdj> arch1: It should be called Sphere.hs on unix-based systems afaik
05:38:46 <arch1> thanks and please a stupid question 
05:39:30 <zygoloid> arch1: i suspect that BONUS tested on a windows-based system where the file system is sorta case insensitive
05:39:50 <benmachine> sorta, huh
05:40:14 <zygoloid> well, it's case-preserving, and it's /possible/ that GHC takes case into account as a result, but that would seem strange
05:40:26 <zygoloid> plus it's filesystem-specific behaviour :(
05:40:53 <zygoloid> (iirc the LFN extension isn't applied to FAT16 filesystems, so they're not even case-preserving)
05:41:20 <zygoloid> also there's a setting somewhere in the registry which allows you to turn on case sensitivity :o
05:41:57 <benmachine> that's weeeeird
05:42:26 <chrisdone> zygoloid: i can't think of a situation in which that would be a good idea or useful
05:42:32 <zygoloid> @tell BONUS at the end of the 'Modules' section in LYAH you give the filenames cube.hs, cuboid.hs and sphere.hs. these need to start with captial letters!
05:42:33 <lambdabot> Consider it noted.
05:45:46 <chrisdone> anyone wanna rewrite this with parsec and/or finish it off i.e. the hard bit :)? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27160
05:46:52 <chrisdone> Bored? Learning Haskell? Why not write my software for me? This is a great opportunity!
05:47:31 <ivanm> heh
05:47:36 <ivanm> chrisdone: what is it meant to be for?
05:48:10 <chrisdone> tip; the javascript parser on hackage will be helpful
05:48:29 <arch1> thanks for help  : ciao alla prossima
05:48:29 <chrisdone> ivanm: compressing javascript. what else? :D
05:48:39 <chrisdone> arch1: hey you're italian?
05:48:47 <arch1> si 
05:48:54 * ivanm goes back to trying to deal with Graphviz's oddities
05:49:05 <arch1> perche'
05:49:33 <arch1> is not evident for my bad english ?
05:49:43 <twanvl> chrisdone: why do you need the fixed point here, isn't one iteration enough?
05:50:25 <chrisdone> arch1: vivo in italia :-)
05:50:45 <chrisdone> twanvl: no because i don't reduce n spaces to one space i.e. s/[ ]+/ /g
05:50:56 <arch1> bene : spero ti trovi , soprettutto per il mangiare ....!
05:51:20 <twanvl> chrisdone: but you do eliminate '\n', which seems wrong
05:51:28 <zygoloid> chrisdone: go s@Normal    (' ':' ':xs)         = go s (' ':xs)
05:51:33 <zygoloid> ^^ i fixed your fixpoint
05:51:48 <chrisdone> arch1: uhh mangiare pizza tutti i giorni lol
05:52:06 <zygoloid> (you want the same change for the "; " rule too i think
05:52:16 <chrisdone> twanvl: why's eliminating newlines wrong?
05:52:19 <zygoloid> uh-oh, syntax error)
05:52:28 <twanvl> chrisdone: because \n is also whitespace
05:52:40 <chrisdone> twanvl: so?
05:52:44 <twanvl> so "var\nx;" is valid javascript
05:52:48 <zygoloid> chrisdone: because newlines can be syntactically important in javascript
05:52:58 <zygoloid> (due to that automatic semicolon insertion stuff)
05:53:02 <twanvl> as is "var/**/x;" iirc
05:53:12 <chrisdone> hm crap i missed that case
05:53:22 <soupdragon> "Note that all equations that deal with G and h simultaneously remain theoretical and unverified."
05:53:22 <twanvl> you should just use isSpace
05:53:24 <chrisdone> What a chance, to contribute to a Haskell project! Fix my code!
05:53:32 <soupdragon> gravity and quantum cant exist in the same universe
05:53:54 <chrisdone> zygoloid: i don't care about that case specifically. all my js code contains semi colons 
05:53:58 <zygoloid> soupdragon: which universe are you in? the gravity one or the quantum one? :)
05:54:40 <soupdragon> I was never abel to do  an experimetn which distinguishes
05:54:55 <twanvl> chrisdone: another case which you do forgot is "\\"
05:54:58 <kmc> easy to do an experiment at home which confirms gravity exists
05:55:09 <kmc> but not too hard to do an experiment which confirms qm either
05:55:11 <arch1> i must return to job : ciao Chris , i hope to learn haskell , but the begin is not simple ..
05:55:21 <soupdragon> do you need a laser for the quantum one?
05:55:38 <kmc> soupdragon, no, the double slit experiment predates lasers significantly
05:55:49 <ddarius> Simply making a laser supports quantum theory.  And you can make a laser at home.
05:55:58 <soupdragon> I want to make a laser ddarius
05:56:03 <kmc> you also have lots of lasers at home already
05:56:05 <soupdragon> I reallly do
05:56:19 <chrisdone> twanvl: just to be clear; i don't need telling what's wrong with it. i'm asking if anyone wants to finish it. the reason is i don't have time. otherwise don't tell me this stuff
05:56:36 <twanvl> okay
05:57:06 <ddarius> kmc: While it would be hard, you could get out of having a laser at home.
05:57:20 <chrisdone> twanvl: (i don't really need it, just thought a haskell one woul dbe neat)
05:59:45 <ddarius> Of course semiconductors support quantum theory and it is near impossible to have a home and not have any semiconductors in it, especially while being on IRC.
06:00:05 * ddarius builds an IRC client out of relays.
06:00:10 <Taejo> I use IRC over Pigeon Carrier
06:00:30 <soupdragon> I don't understand semiconductors
06:00:46 <zygoloid> so hey, i have a GADT, data Foo m where A :: (FooOf m ~ A) => Foo m; B :: (FooOf m ~ B) => Foo m; etc.  I have a type family FooOf m, and a class WithFoo m where fooOf :: Foo m. I want to write a function :: Foo m -> (forall m'. (Monad m, WithFoo m) => m a) -> a
06:00:48 <soupdragon> or anything to do with electronics
06:01:15 <danderson> I'm confused by Control.Exception behavior here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27209#a27209
06:01:24 <zygoloid> can i do that without writing out an instance of WithFoo for each constructor of the GADT and a corresponding case expression?
06:01:25 <ddarius> soupdragon: Have you attempted to learn about them?
06:01:27 <Phyx-> I am convinced that GHC is playing with me....
06:01:34 <danderson> AIUI, that should catch any calls to 'error' that happen during the call to decode
06:01:40 <soupdragon> not really
06:01:42 <ddarius> Phyx-: Drill "The compiler is always right." into your head.
06:01:46 <soupdragon> everyone in school seemed to understand them except me
06:01:49 <Phyx-> utterly convinced that it developed some kind of AI and it messing with me :/
06:01:51 <danderson> but in practice, it doesn't catch the exception, and it crashes the whole program.
06:01:57 <danderson> what am I doing wrong?
06:02:04 <ddarius> soupdragon: I doubt the vast majority of them understood much.
06:02:09 <kmc> danderson, you're not evaluating within try
06:02:25 <Phyx-> ddarius: well, I call a pure function with the same two arguments and get two different results depending on where i call it
06:02:28 <kmc> because of laziness
06:02:33 <kmc> danderson, use Control.Exception.evaluate
06:02:38 <danderson> oh gah
06:02:38 <kmc> which forces to whnf
06:02:40 <danderson> kmc: thanks.
06:02:51 <ddarius> Phyx-: Again, drill "The compiler is always right." into your head.
06:03:13 <Phyx-> lol
06:03:42 <danderson> kmc: excellent, it works, cheers
06:03:47 <kmc> the compiler is always right.... http://is.gd/dlueo
06:04:06 <zygoloid> Phyx-: tried -fforce-recomp?
06:04:39 <Phyx-> zygoloid: well, the source is autogenerated before every compile, so there's no file cached
06:05:22 <zygoloid> is it possible you have two functions with the same name in different modules?
06:06:15 <Phyx-> doubt it, the function returns the correct results
06:06:21 <Phyx-> just one with qualified types
06:06:24 <ivanm> zygoloid: as long as you don't import one into the other, yes
06:06:26 <Phyx-> and the other with unqualified types
06:06:49 <ivanm> but if you import both unqualified into another module, then you won't be able to use either one
06:06:59 <Phyx-> this *used* to work find before i pulled in some new patches, lol
06:07:06 <zygoloid> ivanm: that's not what i meant at all. i was asking if Phyx- might be calling two different functions and thinking they're the same.
06:07:24 <ivanm> oh, sorry, I didn't realise you were checking if Phyx- was doing it ;-)
06:08:12 <zygoloid> Phyx-: well i'd suggest at least trying a -fforce-recomp and/or removing any .hi files, just in case
06:08:31 <zygoloid> it does sound a bit like ghc has been a bit "too clever" with some of its caching
06:09:03 <Phyx-> alright
06:09:04 <Taejo> I have a program which runs at a respectable rate using a monad stack, but adding a strict Writer (Sum Int) at the bottom makes it almost twice as slow: from 4.01s MUT + 0.40s GC to 3.64s MUT + 4.37s GC
06:09:20 * Phyx- does rm -f *.hi
06:09:27 <Taejo> Is this to be expected, or am I doing something wrong?
06:10:07 <zygoloid> Taejo: i'm guessing... strict writer but lazy Sum is the problem.
06:10:19 <zygoloid> (ie you're building up a big Int thunk inside the Sum
06:10:21 <Taejo> Sum is lazy?
06:10:26 <zygoloid> @src Sum
06:10:26 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:10:34 <Taejo> that would explain it
06:11:10 <Taejo> I assumed "newtype Sum a = Sum { getSum :: a }"
06:11:17 <ToRA> Taejo: it is a newtype
06:11:22 <Taejo> yeah
06:11:33 <zygoloid> Taejo: yeah, it is. so not that then :(
06:11:53 <quicksilver> I doubt mappend for Sum is strict
06:11:59 <ToRA> Taejo: your performance difference is that between strict / non-strict or strict-writer / no-writer ?
06:12:06 <triyo> Hi all. I am looking for parsec-like parseFromFile that can produce additional meta-info such as "line number" of parsed items in file. Any Ideas?
06:12:15 <zygoloid> quicksilver: Taejo is using strict writer
06:12:21 <quicksilver> hmm.
06:12:24 <Taejo> ToRA: I haven't tested non-strict writer
06:12:51 <quicksilver> well there is a space cost to pushing all those (a,w) tuples around
06:12:59 <quicksilver> and space cost implies GC cost
06:13:02 <kmc> well Sum may not be lazier, but Int is still lazy
06:13:03 <quicksilver> that does seem like a lot, though.
06:13:26 <quicksilver> kmc: shouldn't be with Strict Writer
06:13:35 <quicksilver> strict writer should seq the mappend before storing it.
06:13:39 <kmc> yeah ok
06:13:47 <Taejo> quicksilver: it goes from 34,888 bytes maximum residency to 138,302,396 bytes maximum residency
06:14:10 <Taejo> I'd expect it should less than double (since other stuff being passed around is much bigger than an Int
06:14:13 <quicksilver> no, I'm quite wrong.
06:14:22 <quicksilver> Strict writer is only strict in the tuple.
06:14:29 <quicksilver> (in my defence zygoloid was wrong too and he mislead me!)
06:14:38 <Taejo> ooh
06:14:42 <quicksilver> Strict Writer makes no attempt to seq the mappend.
06:14:57 <triyo> is there a way to do this?
06:15:00 <quicksilver> m >>= k  = Writer $ case runWriter m of (a, w) -> case runWriter (k a) of (b, w') -> (b, w `mappend` w')
06:15:15 <zygoloid> quicksilver: hah, i had no idea :) good catch
06:15:33 <quicksilver> you want m >>= k  = Writer $ case runWriter m of (a, w) -> case runWriter (k a) of (b, w') -> let w'' = w `mappend` w' in w'' `seq` (b,w'')
06:15:46 <benmachine> ReallyStrictWriter
06:15:51 <kmc> quicksilver, ah, and thenlazy Writer is just that with «~(a,w)»?
06:16:03 <Taejo> quicksilver: yes... I assumed that's what it was because I can't think of a use for ReallyLazyWriter
06:16:18 <quicksilver> kmc: it's written as using two lets, not two cases
06:16:22 <kmc> ok
06:16:23 <quicksilver> kmc: but, basically, yes.
06:16:24 <kmc> makes more sense
06:16:54 <quicksilver> the point of really lazy writer is that if you never inspect the log, it doesn't actually happen
06:17:15 <quicksilver> really strict writer makes the log definitely happen - but doesn't try to stop the log itself being a thunk.
06:17:35 <quicksilver> s/really//
06:17:51 <quicksilver> interestingly there is nothing you can do in the Monoid instance to alleviate this.
06:18:01 <quicksilver> (mappend w w') is always a thunk.
06:18:19 <Taejo> yes
06:18:24 <quicksilver> unless the compiler notices it is strictly used, which seems very unlikely through all those layers of indirection.
06:18:35 <kmc> yeah
06:18:48 <kmc> would be easy enough to write a special-purpose "Counter" monad
06:18:54 <quicksilver> strictness analysis-- # fragile, not compositional.
06:18:56 <kmc> with a strictly-threaded Int state
06:18:59 <zygoloid> ok, so the difference is that for left-associated (>>), lazy writer doesn't necessarily force the LHS computation at all.
06:19:11 <zygoloid> seems like for right-associated (>>) they're equivalent though?
06:19:18 <kmc> quicksilver, yeah... that's a problem with fusion too
06:19:22 <Taejo> this makes me sad: I was really pleased to get a well-performing N Queens program with a nice modular monad stack
06:19:36 <quicksilver> Taejo: write your own Writer monad at the bottom
06:19:48 <quicksilver> Taejo: defining >>= to apply mappend strictly as I outlined above.
06:19:55 <quicksilver> I will be interested to see if that makes a difference.
06:19:57 <Taejo> yeah, I shall have to
06:20:03 <kmc> or even a special case which just does Int
06:20:28 <quicksilver> kmc: well it's not hard to copy paste a few lines from http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Writer-Strict.html with a new name :)
06:20:34 <kmc> heh true
06:21:05 <ddarius> quicksilver: Which is why you shouldn't rely on strictness analysis.
06:21:11 <quicksilver> zygoloid: well, with the lazy one, if you inspect only the result, or only the log, you may force different amounts of computation.
06:21:52 <quicksilver> ddarius: but that argument suggests you shouldn't rely on fusion either
06:22:07 <quicksilver> ...and perhaps we shouldn't, but if we didn't, bytestring would be slower than String...
06:23:16 <Taejo> I still don't see how the "strict" writer does anything more than make sure that the *pair* constructor is there -- which it must be if we constructed the writer with return, >>= and tell
06:23:20 <zygoloid> quicksilver: hmm, yeah, the lazy one builds the log more lazily for something like Dual [String].
06:23:21 <ddarius> quicksilver: The difference is 1) how reliable fusion is and 2) lack of strictness easily leads to unbounded use of stack and program failure, not just slower execution.
06:23:59 <zygoloid> Taejo: in the strict one the pair is always built. in the lazy one, the pair need not be built if it's not needed for the amount of the result/log which is forced
06:24:47 <Taejo> zygoloid: I don't see when the pair is not needed... oh, I guess evalWriter (a >> b)
06:24:55 <quicksilver> ddarius: good answers
06:24:58 <Taejo> which ignores the logs of both, and the value of a
06:25:58 <quicksilver> ddarius: in fact I'm most interested in strictness analysis not when it removes a space leak (which as you say, you shouldn't rely on) but when it is a preface to unboxing
06:26:07 <quicksilver> ddarius: ...and thus register use.
06:27:04 <zygoloid> fst . runWriter $ do tell []; undefined; return 0
06:27:20 <zygoloid> ^^ Taejo: that bottoms out for strict writer but works for lazy writer
06:27:35 <Taejo> right
06:28:10 <Taejo> zygoloid: that's what I meant by "constructed from tell, >>= and return" -- undefined isn't
06:28:56 <Taejo> I'm sure the current versions are not useless, but I do think really strict writer is useful
06:29:12 <zygoloid> snd $ runWriter (fix (tell "e" >>) >> return 0)
06:29:18 <zygoloid> Taejo: ^^ does that meet your criteria?
06:29:40 <Taejo> zygoloid: nice
06:30:09 <zygoloid> damn, i meant to change the return 0 to tell "k" ;-)
06:31:58 <Taejo> :t listen
06:31:59 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
06:33:55 <quicksilver> Taejo: I think really strict writer is almost always what you want.
06:34:05 * quicksilver thinks about it.
06:34:08 <quicksilver> OK, not always always.
06:34:19 <quicksilver> perhaps if you're constructing a tree in the log which you will only ever partially inspect, or something.
06:34:29 <quicksilver> (but even then, seq would probably only force one branch so it would be harmless)
06:38:46 <zygoloid> ezyang's latest blog post confuses me. are 'unsafe' calls /really/ faster if they block all running threads? and why do they need to block all running threads, if we know the c function is safe enough to be marked unsafe?
06:39:08 <triyo> Hmm parsec SourcePos was staring me in the face all along :)
06:39:53 <kmc> zygoloid, because there's a cost to not blocking those threads
06:40:08 <kmc> the cost of moving the call to a dedicated FFI worker OS-thread, i believe
06:40:27 <zygoloid> why do the threads need to be blocked at all?
06:40:36 <zygoloid> i'm guessing it's something to do with garbage collection...
06:40:55 <kmc> if you make the call from the current Haskell worker OS-thread, then it prevents that worker thread from doing any more evaluation work until the FFI call returns
06:41:02 <kmc> it's not that you're deliberately blocking it
06:41:17 <zygoloid> kmc: it's not just that thread that's blocked, it's /all/ threads.
06:41:22 <zygoloid> that's what i don't understand.
06:41:30 <kmc> ok
06:41:38 <kmc> well they will all block once one of them wants to GC
06:41:48 <kmc> i'm not sure why they'd block before
06:42:01 <zygoloid> perhaps that's what ezyang's example is showing
06:42:47 <zygoloid> (maybe with a bigger heap size he'd not see that behaviour?)
06:43:48 <kmc> yeah
06:43:55 <kmc> and i'm not sure forkOS is guaranteed to have different behavior
06:44:12 <kmc> i think the only guarantee on forkOS is consistency of which thread an FFI call comes from
06:44:20 <kmc> not whether or not that thread has other duties that get blocked
06:44:47 <kmc> i.e. an implementation with only one OS thread and forkOS = forkIO would be consistent with the semantics in the "Concurrent Haskell" paper
06:50:15 <Taejo> sadly, switching to really strict writer seems not to have helped :(
06:50:24 <zygoloid> kmc: it's not GC, and it still happens when running with +RTS -N4
06:50:42 <zygoloid> Taejo: can you hpaste the code?
06:52:08 <Taejo> zygoloid: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27211#a27211
06:52:37 <Taejo> d'oh
06:52:49 <Taejo> I left out the seq in the most important place
06:52:55 <zygoloid> yep
06:53:27 <Taejo> that does it
06:54:11 <zygoloid> @type (lift =<<)
06:54:13 <lambdabot> forall (m :: * -> *) b (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m, Monad (t m)) => t m (m b) -> t m b
06:55:03 <Taejo> zygoloid: I'd love to make that line clearer
06:56:09 <triyo> In Parsec sourceLine on SourcePos returns a line number thats always off by one. (+1 every time). Is this how it is suppose to be?
06:57:15 <dancor> what is meant by "qualifiable identifiers"
06:57:24 <zygoloid> Taejo: do rowSet <- gets rows; row <- lift $ IS.toList rowSet; maybe?
06:58:08 <Taejo> zygoloid: it's more the ListT . return that is non-obvious to me
06:59:07 <zygoloid> that's just [a] -> ListT m a
06:59:45 <Taejo> yeah
07:00:00 <zygoloid> it seems like a slightly unusual route to get there, is all. i'd definitely write it as two lines.
07:00:57 <Taejo> zygoloid: I feel (gets rows) is far too trivial to deserve a name
07:01:35 <zygoloid> Taejo: then: lift . IS.toList =<< gets rows ?
07:01:48 <illissius> zygoloid: i was googling earlier to try to figure out what the exact difference between safe and unsafe is... i read somewhere that unsafe calls don't block *all* threads, they block all lightweight-haskell-threads mapped to the OS-level thread which makes the call
07:01:52 <illissius> which would make sense
07:02:25 <Taejo> zygoloid: I think I need the ListT . return
07:02:52 <Taejo> but maybe this is better: row <- lift . ListT . return =<< gets (IS.toList . rows)
07:02:58 <zygoloid> illissius: hmm, that would imply that the thread running 'main' and the two forkOS'd threads all running in the same OS thread
07:03:12 <zygoloid> Taejo: i'd give a name to ListT . return. listToListT maybe?
07:03:25 <Taejo> good idea
07:03:36 <zygoloid> or possibly even add the IS.toList to it, as intSetToListT ?
07:03:56 <illissius> zygoloid: I haven't read ezyang's post yet though if that's what you were referencing just now
07:04:11 <zygoloid> yeah
07:04:32 <Taejo> is msum = ListT, for ListT m a?
07:04:54 <aristid> :t ListT
07:04:55 <lambdabot> Not in scope: data constructor `ListT'
07:05:32 <Taejo> ListT :: m [a] -> ListT m a
07:05:34 <Taejo> right?
07:05:53 <aristid>     m `mplus` n = ListT $ do
07:05:53 <aristid>         a <- runListT m
07:05:53 <aristid>         b <- runListT n
07:05:53 <aristid>         return (a ++ b)
07:06:18 <Taejo> :t msum
07:06:18 <aristid> @undo     m `mplus` n = ListT $ do         a <- runListT m ;         b <- runListT n ;         return (a ++ b)
07:06:18 <lambdabot> mplus m n = ListT $ runListT m >>= \ a -> runListT n >>= \ b -> return (a ++ b)
07:06:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
07:06:45 <aristid> @src msum
07:06:45 <lambdabot> msum =  foldr mplus mzero
07:07:05 <aristid> @pl mplus m n = ListT $ runListT m >>= \ a -> runListT n >>= \ b -> return (a ++ b)
07:07:06 <lambdabot> mplus = (ListT .) . (. (flip (fmap . (++)) . runListT)) . (>>=) . runListT
07:07:22 <aristid> lambdabot: i think you could do that better!
07:09:51 <Taejo> zygoloid: I went for | row <- choose =<< gets (IS.toList . rows) |, with choose :: [a] -> StatefulSearch s a
07:12:51 <triyo> If I have something like this pattern matched ... (MyDataType a b c) where c matches a list, is there a way to split the c into 'init' and 'last' of the list? Something like (MyDataType a b (xs:x))
07:13:39 <jmcarthur> with a view pattern maybe
07:14:06 <jmcarthur> but it's not a mere pattern match. it's a function application and pattern match
07:14:40 <orlandu63> you can work with the list reversed until it's necessary to unreverse it
07:15:12 <jmcarthur> that would better if possible
07:15:58 <triyo> orlandu63: oh right, I see what you mean, thought that would require the calling code to provide a reversed list
07:17:17 <orlandu63> :t reverse
07:17:18 <lambdabot> forall a. [a] -> [a]
07:21:56 <jmcarthur> > let foo (reverse -> (x:y:zs)) = (y, x) in foo [1..5]
07:21:57 <lambdabot>   (4,5)
07:22:29 <jmcarthur> ^^ best when you don't actually need the list reversed anywhere except for right there
07:26:03 <ClaudiusMaximus> hm, how does profiling interact with long FFI calls?
07:27:20 <ClaudiusMaximus> i think my main problem is that my profile is very flat, so i don't know where to concentrate my optimization efforts...
07:27:25 <jmcarthur> i assume it treats them like slow primitives
07:27:40 <jmcarthur> how's your GC time?
07:27:44 <ClaudiusMaximus> 10%
07:27:47 <jmcarthur> ah not bad
07:28:07 <jmcarthur> so i guess you don't have any minor space leaks either
07:28:26 <jmcarthur> with a flat profile i don't know what to suggest i guess :)
07:28:32 <ClaudiusMaximus> the other thing is that profiling only works with -N1, and the program is designed for -N2
07:28:40 <jmcarthur> ah stinky
07:28:44 <jmcarthur> tried threadscope?
07:28:56 <jmcarthur> see if you can increase parallelism?
07:28:56 <ClaudiusMaximus> nope
07:29:02 <ClaudiusMaximus> @where threadscope
07:29:02 <lambdabot> I know nothing about threadscope.
07:29:16 <jmcarthur> http://research.microsoft.com/en-us/projects/threadscope/
07:29:53 <ClaudiusMaximus> yeah just found it
07:29:54 <jmcarthur> you also could try GHC HEAD and see if that speeds you up
07:30:06 <duairc> Does anybody know if there's a way to make Pandoc not syntax highlight a document even if it's been compiled with syntax highlighting support
07:30:08 <jmcarthur> supposed to have some nice improvements for parallelism i think
07:30:15 <ClaudiusMaximus> @where+ threadscope http://research.microsoft.com/en-us/projects/threadscope/
07:30:15 <lambdabot> Okay.
07:31:16 <jmcarthur> i have yet to try threadscope myself. i haven't done any parallel code in a while i guess
07:33:52 <Phyx-> awww guess it was too much to ask for this to work on first try :P seems to have an infinite recursion somewhere
07:35:52 <mreh_> I have one of those
07:36:14 <Phyx-> I can't see, to find mine though :/
07:36:19 <duairc> win 3
07:36:27 <mreh_> Phyx- tried tracing?
07:36:44 <Phyx-> mreh_: yeah, i'm adding some trace messages now
07:37:05 <mreh_> beats debugging
07:37:35 <timcowlishaw> hey all, I'm getting a weird type error when I try and use the .&. (Bitwise AND) function from Data.Bits - eg calling 255 .&. 254 results in "Ambiguous type variable 't' in the consttraint: 'Bits t' arising from a use of '.&.'". I can't see what's wrong - '.&.' has the type 'Bits a => a -> a -> a' and Int is an instance of Bits, after all. any idea what might be causing this?
07:38:48 <orlandu63> > 255 .&. 254
07:38:49 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:38:49 <lambdabot>    `Data.Bits.Bits a'
07:38:49 <lambdabot>      a...
07:39:10 <tromp_> > 255 .&. 254 :: Word
07:39:11 <lambdabot>   254
07:39:17 <timcowlishaw> hmm weird
07:39:24 <jmcarthur> dang, snap is getting 22k req/s
07:39:26 <tromp_> > 255 .&. 254 :: Int
07:39:27 <lambdabot>   254
07:39:42 <jmcarthur> on the pong benchmark, that is
07:40:28 <kmc> triyo, you could also use a data type like Seq which supports efficient views from both sides
07:40:46 <timcowlishaw> Prelude Data.Bits> :t (255 .&. 254)
07:40:47 <timcowlishaw> (255 .&. 254) :: (Bits t) => t
07:40:54 <jmcarthur> Seq++
07:41:05 <timcowlishaw> Prelude Data.Bits> 255 .&. 254
07:41:05 <timcowlishaw> <interactive>:1:0:
07:41:06 <timcowlishaw>     Ambiguous type variable `t' in the constraint:
07:41:06 <timcowlishaw>       `Bits t' arising from a use of `.&.' at <interactive>:1:0-10
07:41:06 <timcowlishaw>     Probable fix: add a type signature that fixes these type variable(s)
07:41:09 <jmcarthur> fingertree++
07:41:18 <kmc> timcowlishaw, don't paste in the channel, use hpaste.org
07:41:18 <triyo> kmc: right, as list is good for getting this from the front right?
07:41:25 <timcowlishaw> aah sorry kmc
07:41:27 <triyo> *this=things
07:41:28 <kmc> triyo, correct, from the front only
07:41:44 <triyo> got it, thanks
07:41:50 <timcowlishaw> this is GHC v 6.12.2
07:41:52 <jmcarthur> lists are stack-like, Seq is deque-like :)
07:42:04 <kmc> timcowlishaw, you say " Int is an instance of Bits", but where does the Int in your program come from?
07:42:12 <timcowlishaw> the prelude
07:42:15 <timcowlishaw> afaik
07:42:21 <timcowlishaw> this is just a ghci session]
07:42:34 <kmc> the literal 255 doesn't have type Int
07:42:36 <jmcarthur> of course, "stack-like" in the presence of lazy evaluation means different things than with only strict evaluation
07:42:36 <timcowlishaw> import Data.Bits and then type the expression
07:42:37 <kmc> it has type (Num a) => a
07:42:39 <timcowlishaw> aah
07:42:40 <Phyx-> well, that's odd
07:42:47 <Phyx-> why is that looping
07:42:48 <kmc> that's why it's ambiguous
07:43:05 <jmcarthur> since simply "unwinding the stack" can do really cool things with lazy evaluation :)
07:43:07 <timcowlishaw> oh, i see - it's just a member of typeclass Num
07:43:57 <kmc> > length [0..5] .&. 254
07:43:58 <lambdabot>   6
07:44:03 <kmc> works because "length" returns Int specifically
07:44:09 <timcowlishaw> aaaah i see!
07:44:49 <Phyx-> oh what a sucky bug
07:44:53 <Phyx-> n00b++
07:45:13 <timcowlishaw> thanks all
07:45:54 <kmc> :)
07:47:25 <zygoloid> Taejo: that's really nice :)
07:47:42 <Taejo> zygoloid: ?
07:47:52 <zygoloid> choose =<< gets (...)
07:48:01 <Taejo> oh, right
07:48:43 <chrisdone> :t choose
07:48:44 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
07:49:26 <ClaudiusMaximus> hm, threadscope segfaults when i load my event log
07:49:37 <zygoloid> chrisdone: in this case, choose :: [a] -> TaejosMonad a
07:56:17 <jmcarthur> ClaudiusMaximus: that's no good...
07:56:41 <msieradzki> how do I keep 2 versions of GHC installed for instance darcs one and 6.12?
07:57:41 <McManiaC> hmmm do you still need #include with hsc2hs? because if I remove it I get "undefined reference" error on the hsc2hs call, if I keep it I get "-#include is deprecated" by ghc
07:57:54 <zygoloid> McManiaC: iirc that warning is bogus
07:58:15 <jmcarthur> McManiaC: i think you're supposed to do {-# INCLUDE ... #-} now or something like that
07:58:23 <jmcarthur> i don't remember for sure
07:58:31 <kmc> msieradzki, i'd install the darcs version to a prefix of your choice using ./configure --prefix=/home/me/wherever
07:58:44 <kmc> msieradzki, you can also run ghc out of the build directory without installing as inplace/bin/ghc-stage2
07:58:48 <McManiaC> jmcarthur: undefined reference again
07:59:12 <msieradzki> let's say that I even want to install packages in "new" version
07:59:19 <msieradzki> cabal --with-ghc=... should do it?
07:59:27 <kmc> don't know
08:03:14 <ClaudiusMaximus> "threadscope --test ch8" also segfaults :(
08:05:31 <ClaudiusMaximus> McManiaC: i think hsc2hs output is out of sync with what ghc expects as input; so i just ignore that warning (even though it tells me every compile, even if the file doesn't need to be rebuilt)
08:05:52 <McManiaC> ClaudiusMaximus: kk :)
08:06:02 <McManiaC> I guess theres no ghc flag to ignore that warning?
08:08:08 <ClaudiusMaximus> hm, threadscope web page says it needs gtk2hs-0.10, but "cabal install threadscope" pulls in gtk2hs-0.11 - could that cause it to crash?
08:08:49 * hackagebot continued-fractions 0.9.0.1 - Continued fractions.  http://hackage.haskell.org/package/continued-fractions-0.9.0.1 (JamesCook)
08:10:19 <jmcarthur> ClaudiusMaximus: i don't think that should be the case
08:10:54 <jmcarthur> probably the web page just isn't specifying that it can use more recent versions of gtk2hs as well
08:20:11 <dhan> how can handle the whitespace "C:\Program Files\GnuWin32\include" so that i can use it as path for include-dirs in cabal? i've tried wrapping the whole path with quotation marks, but it's not working.
08:20:44 <dhan> Warning: 'extra-lib-dirs: "C:\Program' directory does not exist.
08:20:45 <dhan> Warning: 'extra-lib-dirs: Files\GnuWin32\lib"' directory does not exist.
08:20:49 <dhan> this is what i get.
08:29:19 <om-foxy> is there a principled reason that instance (Storable a, Storable b, ...) => Storable (a,b,...) is not standard?
08:29:49 <Zao> What would the default be?
08:30:03 <om-foxy> dhan: how about C:\Program\ Files\... 
08:30:35 <om-foxy> Zao: well if the elements are storable then sizeof = sizeof a + sizeof b etc...
08:30:45 <Zao> om-foxy: You're forgetting alignment.
08:31:04 <Zao> And what would the right order be?
08:31:05 <Zao> etc.
08:31:22 <Zao> I'm sure that you could cook up a module that would produce a suitable orphan instance for you.
08:31:32 <McManiaC> whats the most popular/powerfull xml library?
08:31:50 <om-foxy> yeah, I'm using (a,a) instances, I was just wondering...
08:32:03 <dhan> om-foxy: obviously no. that would mean a directory named " Files" under "Program". (nonetheless I've just tried, and failed.)
08:32:17 <benmachine> @remember SeanLeather One of the "nice" things about English is that there is often never an "always."
08:32:18 <lambdabot> It is stored.
08:32:22 <om-foxy> dhan, bummer, works on unix
08:33:36 <dhan> om-foxy: and you wouldn't need to use backslash for path in the first place if you were on unix... (sigh)
08:34:27 <dhan> it's well known that windows sucks, but i need it for now
08:35:06 <om-foxy> dhan: Gtk2hs works on windows with spaces in path names, maybe you could have a look at that project's cabal file
08:35:27 <Zao> dhan: It's well known that most software shits itself hard on other platforms with spaces in paths too.
08:35:47 <Zao> dhan: It's just that the Windows ecosystem has them all over the place, to flush out poorly written software.
08:36:09 <dhan> i'm starting to wonder
08:36:23 <dhan> a quick googling tells me that wrapping with quotation marks should work.
08:36:52 <dhan> they even mention giving multiple paths to include-dir by wrapping each path and separating them by comma.
08:36:59 * hackagebot clientsession 0.4.0.2 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.4.0.2 (MichaelSnoyman)
08:37:20 <arw> you can try to use forward slashes in windows instead of backslashes. some APIs will also work with forward slashes, but not all of them.
08:37:20 <quicksilver> om-foxy: because Storable is designed, mostly, to interoperate with other languages.
08:37:42 <quicksilver> om-foxy: and there isn't an obviously canonical in-memory layout for a tuple which other languages would expect/respect.
08:37:55 <quicksilver> (other languages => mostly C, really)
08:39:09 <akosch> is there some version of takeWhile that takes the first element that does not pass the test too?
08:40:08 <dhan> akosch: a quick and dirty version would be takeWhile' n (x:xs) = x ++ (takeWhile (n-1) xs)
08:40:19 <dhan> wait
08:40:27 <dhan> never mind, i confused take and takeWhile
08:40:57 <benmachine> akosch: construct one on the basis of span and/or break
08:40:59 <dhan> akosch: i guess takeWhile' b (x:xs) = x ++ (takeWhile b xs)
08:40:59 <benmachine> er, or
08:41:14 <geheimdienst> > span (<2) [1..]
08:41:14 <lambdabot>   ([1],[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
08:41:33 <dhan> oh.
08:41:33 <benmachine> case break p xs of (stuff, []) -> stuff; (stuff, more:_) -> stuff ++ [more]
08:41:35 <benmachine> something like that
08:41:39 <dhan> i've totally misunderstood the question
08:41:41 <geheimdienst> > let (a,b) = span (<4) [1..] in a ++ take 1 b
08:41:42 <lambdabot>   [1,2,3,4]
08:42:00 <dhan> geheimdienst: or "head b" instead of "take 1 b"
08:42:01 <benmachine> er, *span
08:42:09 <akosch> geheimdienst: thx
08:42:23 <benmachine> dhan: that's a. non-total and b. not a list
08:42:37 <timcowlishaw> sorry guys, one more question - I have the following method, which shouid take any integal and returns a string of its base-2 representation:  https://gist.github.com/db17c1d05af0dfc3cd15
08:42:44 <geheimdienst> > uncurry ((++) . take 1) $ span (<4) [1..]
08:42:45 <lambdabot>   [1,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
08:43:12 <geheimdienst> > uncurry ((take 1) . (++)) $ span (<4) [1..]
08:43:13 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
08:43:15 <timcowlishaw> but i get this error "No instance for (Floating Char)" from my definition of the function 'places'
08:43:32 <quicksilver> logBase only works on floating types
08:43:37 <quicksilver> trying converting it first:
08:43:43 <timcowlishaw> despite it working fine if i define it with 'let places = ceiling . logBase 2' in ghci
08:43:44 <quicksilver> logBase 2 . fromIntegral
08:43:48 <timcowlishaw> aha!
08:43:50 <geheimdienst> > uncurry (((++) .) . (take 1)) $ span (<4) [1..]
08:43:50 <lambdabot>   Couldn't match expected type `b -> a' against inferred type `[a1]'
08:43:50 <benmachine> hmm
08:43:51 <timcowlishaw> thanks
08:43:54 <benmachine> I don't think it's that simple
08:44:02 <quicksilver> although you are then restriciting to the range of Double
08:44:04 <geheimdienst> > uncurry ((++) . (. (take 1))) $ span (<4) [1..]
08:44:04 <timcowlishaw> oh, so it's the same problem as i had before
08:44:05 <lambdabot>   Couldn't match expected type `[a] -> b'
08:44:05 <lambdabot>         against inferred type `[a1]'
08:44:07 <quicksilver> it's not the only bug in that code though.
08:44:09 <benmachine> timcowlishaw: is bitInPosition supposed to produce a char?
08:44:23 <geheimdienst> @pl let (a,b) = span (<4) [1..] in a ++ take 1 b
08:44:23 <lambdabot> (line 1, column 5):
08:44:23 <lambdabot> unexpected "("
08:44:23 <lambdabot> expecting "()", natural, identifier or "in"
08:44:24 <benmachine> timcowlishaw: it is according to the type signature for the function, but it doesn't
08:44:35 <timcowlishaw> aah good spot benmachine
08:44:37 <benmachine> (also, flip div $ n = flip div n)
08:44:48 <timcowlishaw> i need to add chr to the beginning
08:45:04 <timcowlishaw> aaah regarding that
08:45:05 * geheimdienst uses the approach of randomly inserting (.) and parens for points-free programming ... *sigh*
08:45:18 <timcowlishaw> which binds closer - '$' or <space>
08:45:26 <timcowlishaw> it's a bitch to google for
08:45:31 <timcowlishaw> obvcviously :-)
08:45:35 <benmachine> $ binds the most loosely
08:45:36 <timcowlishaw> s/cv/v/
08:45:41 <timcowlishaw> aaah ok
08:45:41 <benmachine> space binds tightest
08:45:48 <timcowlishaw> yep that makes perfect sense
08:45:50 <timcowlishaw> thanks!
08:46:07 <dhan> benmachine: indeed it has to be [head b], and depending on the situation you're using the function, i guess it could be slightly faster than take 1 b (although it may just cause exception and die as well)
08:46:08 <benmachine> (there are other operators that bind as loosely as $, but nothing binds as tightly as space)
08:46:19 <benmachine> dhan: how could it be slightly faster?
08:46:40 <dhan> benmachine: because take has a comparison operation?
08:47:38 <benmachine> dhan: hmm
08:47:54 <benmachine> I suppose so
08:48:18 <benmachine> but the difference is going to be laughably small, surely :P
08:48:41 <geheimdienst> > let (a,b) = span (<4) [1..] in a ++ take 1 b
08:48:42 <lambdabot>   [1,2,3,4]
08:49:33 <geheimdienst> ^^ could a luminary provide a points-free version of this? i can't figure it out. the question was: takeWhile a predicate and then take the first of the non-matching elems
08:50:02 <benmachine> it's going to be a pain because of pattern matching
08:50:22 <benmachine> @pl \p xs -> (a,b) = span (<4) [1..] in a ++ take 1 b -- woo cheating
08:50:22 <lambdabot> (line 1, column 16):
08:50:22 <lambdabot> unexpected "="
08:50:22 <lambdabot> expecting variable, "(", operator or end of input
08:50:29 <benmachine> oh, touché
08:50:37 <jmcarthur> > span (<4) [1..]
08:50:38 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
08:50:48 <benmachine> @pl \p xs -> let (a,b) = span p xs in a ++ take 1 b
08:50:48 <lambdabot> (line 1, column 14):
08:50:48 <lambdabot> unexpected "("
08:50:48 <lambdabot> expecting "()", natural, identifier or "in"
08:51:01 <geheimdienst> how does pattern matching interfere? i thought it would come out as something like "uncurry flip (++) . (take 1)"
08:51:23 <benmachine> oh, possibly
08:51:33 <akosch> this is getting interesting :)
08:51:40 <Saizan> uncurry (++) . fmap (take 1) . span p
08:51:44 <benmachine> ok so
08:51:52 <jmcarthur> bah, beaten right before i hit enter
08:51:56 <geheimdienst> > uncurry (++) . fmap (take 1) . span (<4) [1..]
08:51:57 <lambdabot>   Couldn't match expected type `([a], [a])'
08:51:57 <lambdabot>         against inferred type `[a...
08:52:05 <Saizan> > uncurry (++) . fmap (take 1) . span (<4) $ [1..]
08:52:06 <lambdabot>   [1,2,3,4]
08:52:15 <Deewiant> @pl \p xs -> (\(a,b) -> a ++ take 1 b) (span p xs)
08:52:15 <lambdabot> (uncurry ((. take 1) . (++)) .) . span
08:52:16 <geheimdienst> duuude
08:52:19 <geheimdienst> :-o
08:52:21 <benmachine> you need the fmap for tuples for that though
08:52:24 <aristid> :t span
08:52:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:52:53 <jmcarthur> could just use second
08:52:54 <Mathnerd314> @pl \p ->  uncurry (++) . fmap (take 1) . span p
08:52:55 <lambdabot> ((uncurry (++) . fmap (take 1)) .) . span
08:52:56 <jmcarthur> no fmap needed then
08:53:00 <Taejo> am I correct in thinking (f =<< gets (g . h)) = (f . g =<< gets h)?
08:53:01 <benmachine> mm
08:53:12 <benmachine> Taejo: yes I think so
08:53:27 <benmachine> gets f = fmap f get
08:53:35 <geheimdienst> jmcarthur, but what lambdabot came up with is very complicated. bordering on indecipherable, if you ask me
08:53:48 <benmachine> gets (g . h) = fmap (g . h) get = fmap g . fmap h $ get
08:53:55 * tg_ pets lambdabot... don't listen to him... you did just fine
08:54:03 <Saizan> @pl \xs -> (\(a,b) -> a ++ take 1 b) (span p xs)
08:54:03 <lambdabot> uncurry ((. take 1) . (++)) . span p
08:54:05 <Taejo> benmachine: yeah, thanks
08:54:35 * Saizan still prefers fmap/sencond
08:55:02 <geheimdienst> saizan, you're right, the fmap version is better
08:55:20 <jmcarthur> :t (fmap.fmap) (uncurry (++) . second (take 1)) span
08:55:22 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:55:37 <zygoloid> @type let foo p xs | (as, bs) <- span p xs = as ++ take 1 bs in foo
08:55:39 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:56:03 <benmachine> :t (fmap fmap fmap) (fmap (uncurry (++)) (second (take 1)) span
08:56:04 <lambdabot> parse error (possibly incorrect indentation)
08:56:07 <jmcarthur> @let fmap2 = fmap . fmap
08:56:08 <lambdabot>  Defined.
08:56:10 <benmachine> oh, pf
08:56:23 <jmcarthur> :t (uncurry (++) . second (take 1)) `fmap2` span
08:56:24 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:56:46 <geheimdienst> @hoogle second
08:56:46 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
08:56:47 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
08:56:47 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
08:57:06 <geheimdienst> :t second
08:57:08 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
08:57:15 <jmcarthur> @let fmap3 = fmap . fmap2
08:57:17 <lambdabot>  Defined.
08:57:30 <geheimdienst> > second (take 2) ([3..], [42..])
08:57:30 <lambdabot>   ([3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
08:57:45 <geheimdienst> > second (take 2) ([3..7], [42..])
08:57:46 <lambdabot>   ([3,4,5,6,7],[42,43])
08:57:56 <geheimdienst> > fmap (take 2) ([3..7], [42..])
08:57:57 <lambdabot>   ([3,4,5,6,7],[42,43])
08:58:10 <geheimdienst> so, this "second" function is exactly like fmap it seems
08:58:14 <benmachine> yes
08:58:16 <benmachine> fmap = second
08:58:18 <jmcarthur> almost
08:58:18 <benmachine> on tuples
08:58:29 <benmachine> they're different generalisations
08:58:38 <Saizan> they coincide for the functor ((,) a) and arrow (->)
08:58:40 <tommd> > fmap (+1) (Just 5)
08:58:41 <lambdabot>   Just 6
08:58:47 <jmcarthur> > fmap (+1) (undefined :: (Int, Int))
08:58:48 <tommd> > fmap (+1) Nothing
08:58:49 <lambdabot>   Nothing
08:58:49 <lambdabot>   *Exception: Prelude.undefined
08:58:53 <jmcarthur> > second (+1) (undefined :: (Int, Int))
08:58:54 <lambdabot>   (*Exception: Prelude.undefined
08:58:58 <jmcarthur> ^^ different
08:59:13 <benmachine> interesting
08:59:26 <quicksilver> the arrow combinators were designed to be lazy for loop-tying
08:59:50 <jmcarthur> the functor laws force fmap to be strict that way
08:59:54 <benmachine> we need fmap to be strict for fmap id = id?
08:59:57 <jmcarthur> right
09:00:27 <jmcarthur> fmap f (a, b) = (a, f b), but second f ~(a, b) = (a, f b)
09:00:52 <geheimdienst> @instances second
09:00:52 <lambdabot> Couldn't find class `second'. Try @instances-importing
09:00:59 <jmcarthur> @instances Arrow
09:01:00 <lambdabot> (->), Kleisli m
09:01:23 <ClaudiusMaximus> anyone got threadscope working on ubuntu lucid 64bit?  here i have ghc-6.12.2 and cabal install threadscope, but threadscope segfaults :(
09:01:45 <jmcarthur> ClaudiusMaximus: does it segfault on launch or only when you load a file?
09:01:49 <tommd> ClaudiusMaximus: You shouldn't be using 6.12.2
09:01:50 <geheimdienst> :t second
09:01:51 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
09:01:55 <tommd> It's buggy
09:02:09 <tommd> ClaudiusMaximus: Use 6.12.3 or downgrade to 6.12.1 - whatever is easiest for you.
09:02:21 <geheimdienst> i have no idea what that sig means, but my guess is: a = (,) and b = Int and c = Int
09:02:27 <jmcarthur> yes
09:02:28 <geheimdienst> what's d then?
09:02:49 <zygoloid> a is (->)
09:02:55 <jmcarthur> oh right
09:02:59 <jmcarthur> i misread
09:03:08 <ClaudiusMaximus> jmcarthur: on load
09:03:14 <quicksilver> geheimdienst: d could be anything
09:03:15 <ClaudiusMaximus> tommd: oh
09:03:21 <geheimdienst> > second (take 2) ([3..7], [42..])
09:03:22 <lambdabot>   ([3,4,5,6,7],[42,43])
09:03:24 <ClaudiusMaximus> tommd: guess i'll get 6.12.3
09:03:26 <quicksilver> geheimdienst: although it was Int in jmcarthur's example
09:03:27 <jmcarthur> ClaudiusMaximus: ah. it works for me here on arch, so i can't help you. i'd do what tommd says
09:03:29 <geheimdienst> ^^ yeah but in this case i mean
09:03:33 <quicksilver> > second (+1) ("foo",3)
09:03:34 <lambdabot>   ("foo",4)
09:03:42 <quicksilver> geheimdienst: in mine, d is String
09:03:50 <quicksilver> the d doesn't get touched
09:03:52 <jmcarthur> geheimdienst: second :: (b -> c) -> (d, b) -> (d, c)
09:03:54 <geheimdienst> why is a parameterized with two tuples and and then somehow what comes out is an (Int, Int)
09:03:58 <quicksilver> so it's an abitrary type.
09:04:10 <quicksilver> geheimdienst: (Int,Int) doesn't come out
09:04:17 <geheimdienst> > second (take 2) ([3..7], [42..])
09:04:17 <quicksilver> geheimdienst: (Int,Int) -> (Int,Int) comes out
09:04:18 <lambdabot>   ([3,4,5,6,7],[42,43])
09:04:21 <Deewiant> geheimdienst: (->) (d,b) (d,c)
09:04:29 <quicksilver> geheimdienst: a = ->, d=Int, b=Int, c=Int
09:05:02 <zygoloid> @type second :: ((->) ~ a) => a b c -> a (d, b) (d, c)
09:05:04 <lambdabot>     Kind mis-match
09:05:04 <lambdabot>     Expected kind `?? -> ? -> *', but `a' has kind `k'
09:05:04 <lambdabot>     In the type `((->) ~ a) => a b c -> a (d, b) (d, c)'
09:05:08 <zygoloid> ;(
09:05:23 <jmcarthur> aw
09:05:51 <jmcarthur> @type undefined :: ((->) ~ a) => a b c -> a (d, b) (d, c)
09:05:52 <lambdabot>     Kind mis-match
09:05:52 <lambdabot>     Expected kind `?? -> ? -> *', but `a' has kind `k'
09:05:52 <lambdabot>     In the type `((->) ~ a) => a b c -> a (d, b) (d, c)'
09:06:08 <zygoloid> it'd be nice if that worked.
09:07:17 <benmachine> kind `k'? weird
09:07:35 * geheimdienst thinks his puny brain is slowly getting used to second
09:07:36 <zygoloid> why can't it match k against ?? -> ? -> *?
09:08:17 <quicksilver> zygoloid: I don't know, but I guess it only ever matches unknown kinds against ones in the (*,->) universe
09:08:28 <quicksilver> zygoloid: the other kinds are special and never unified
09:10:31 <geheimdienst> :t second (show, 42) 
09:10:32 <lambdabot>     No instance for (Arrow (,))
09:10:32 <lambdabot>       arising from a use of `second' at <interactive>:1:0-16
09:10:32 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
09:10:48 <geheimdienst> :t second (take 3)
09:10:49 <lambdabot> forall a d. (d, [a]) -> (d, [a])
09:10:55 <benmachine> @type undefined :: (Kleisli IO ~ a) => a b c -> a (d, b) (d, c)
09:10:56 <lambdabot> forall b c d. Kleisli IO b c -> Kleisli IO (d, b) (d, c)
09:11:01 <geheimdienst> @instances Arrow
09:11:01 <lambdabot> (->), Kleisli m
09:11:02 <benmachine> hm
09:11:06 <zygoloid> quicksilver: hmm. it's still disappointing it didn't unify both to (* -> * -> *)...
09:11:07 <geheimdienst> @instances Kleisli
09:11:08 <lambdabot> Couldn't find class `Kleisli'. Try @instances-importing
09:11:12 <geheimdienst> @instances Kleisli m
09:11:13 <lambdabot> Couldn't find class `Kleisli m'. Try @instances-importing
09:11:21 <geheimdienst> wtf is a kleisli
09:11:30 <zygoloid> it can clearly unify (?? -> ? -> *) with (* -> * -> *) since the instance Arrow (->) works
09:11:45 <benmachine> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
09:11:56 <benmachine> it's the only other standard instance of Arrow
09:14:20 <geheimdienst> so, is this correct? Arrow is fully abstract, but the only concrete thing you can do with it is (->) and some stuff i don't understand. so practically, i can just think of Arrow's "a" argument as always being (->)
09:14:38 <quicksilver> zygoloid: ?? -> ? -> * is more specific than * -> * -> *
09:14:45 <kmc> geheimdienst, unless you use some of the stuff you don't understand
09:14:51 <quicksilver> so it matches it, but you can't go the other way.
09:14:56 <pikhq> geheimdienst: It's a bit more clear if you think of the argument as (~>).
09:14:57 <kmc> geheimdienst, it's true that by far most uses of the arrow combinators are for (->)
09:15:05 <quicksilver> in this channel.
09:15:09 <quicksilver> in general I don't know if that's true.
09:15:15 <pikhq> Making it clear that Arrow is for things that are *like* functions. :)
09:15:18 <geheimdienst> @hoogle ~>
09:15:18 <lambdabot> No results found
09:15:23 <kmc> geheimdienst, basically they were invented for this very general thing, but they turn out to also be practical for the specific case of (->)
09:15:23 <quicksilver> the arrow combinators are, in a very boring way, some combinators for messing with tuples
09:15:30 <geheimdienst> pikhq, could you elaborate? what is ~> ?
09:15:40 <kmc> geheimdienst, (~>) is just a type variable written infix
09:15:41 <mauke> geheimdienst: a variable
09:15:57 <kmc> arr :: (Arrow (~>)) => (a -> b) -> (a ~> b)
09:16:13 <kmc> arr :: (Arrow r) => (a -> b) -> (r a b)
09:16:16 <pikhq> I find that that makes it a bit more clear how Arrow works.
09:16:20 <kmc> equivalent, the former is clearer to read
09:16:56 <kmc> geheimdienst, as to "wtf is a kleisli", it's the construction by which every monad is an arrow
09:17:22 <kmc> every monad has an associated category called the "kleisli category" of that monad
09:17:30 <kmc> and arrows are categories with some additional structure
09:17:37 <kmc> and it turns out that the kleisli category always has that structure
09:17:48 <Taejo> "The myth that any given programming language is machine independent is easily exploded by computing the sum of powers of 2."
09:17:55 <Taejo> > iterate (*2) 1
09:17:56 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:18:14 <kmc> > scanl (+) 0 $ iterate (*2) 1
09:18:15 <lambdabot>   [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,...
09:18:22 <Taejo> oh, it does continue "...If you run out of memory, you are on a string or Bignum system."
09:18:25 <kmc> > map pred $ iterate (*2) 1
09:18:29 <geheimdienst> okay, thanks for the explanations guys
09:18:31 <lambdabot>   [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,...
09:18:52 <pikhq> Taejo: Yeah, but it takes freaking forever to run out of memory on Haskell. :)
09:19:01 <kmc> sadly, no
09:19:05 <jmcarthur> no it doesn't
09:19:14 <pikhq> jmcarthur: For this?
09:19:16 <pikhq> 2GB number.
09:19:18 <kmc> have forkbombed my system with haskell programs numerous times
09:19:22 <pikhq> That takes a while.
09:19:22 <Taejo> anyway, it was said in 1971ish
09:19:23 <Deewiant> > sum (iterate (*2) 1)
09:19:26 <jmcarthur> well i am out of context
09:19:28 <lambdabot>   mueval-core: Time limit exceeded
09:19:30 <geheimdienst> > drop 9999 $ iterate (*2) 1
09:19:34 <lambdabot>   [99753155844037919244187108134179254191174841594309622742600447492647194151...
09:19:42 <pikhq> Ohwait.
09:19:44 <pikhq> Powers of 2l.
09:19:47 <pikhq> 2.
09:19:48 <kmc> > iterate (*2) 1 !! 9999
09:19:49 <lambdabot>   997531558440379192441871081341792541911748415943096227426004474926471941511...
09:19:52 <pikhq> No, it takes a handful of iterations.
09:19:54 <kmc> > log (iterate (*2) 1 !! 9999)
09:19:55 <lambdabot>   Infinity
09:19:59 <kmc> hehe
09:20:06 <kmc> > length . show (iterate (*2) 1 !! 9999)
09:20:07 <lambdabot>   Couldn't match expected type `[a]'
09:20:07 <lambdabot>         against inferred type `GHC.Types...
09:20:15 <kmc> > length . show (iterate (*2) 1 !! 9999 :: Integer)
09:20:16 <lambdabot>   Couldn't match expected type `[a]'
09:20:17 <lambdabot>         against inferred type `GHC.Types...
09:20:21 <kmc> > length $ show (iterate (*2) 1 !! 9999 :: Integer)
09:20:22 <lambdabot>   3010
09:20:29 <kmc> > length $ show (iterate (*2) 1 !! 99999 :: Integer)
09:20:32 <lambdabot>   30103
09:20:49 <djahandarie> That was nifty
09:20:54 <jmcarthur> ...
09:21:21 <aristid> > log (fromIntegral (iterate (*2) 1 !! 9999))
09:21:22 <lambdabot>   Infinity
09:21:26 <aristid> :t log
09:21:28 <lambdabot> forall a. (Floating a) => a -> a
09:21:29 <jmcarthur> oh, *2. for some reason i was thinking ^2 and i was wondering why the number was so big
09:21:59 <djahandarie> > map (\n -> length $ show (iterate (*2) 1 !! n :: Integer)) [9, 99, 999, 9999, 99999]
09:22:02 <aristid> > log (iterate (*2) 1 !! 9999) :: CReal
09:22:03 <lambdabot>   [3,30,301,3010,30103]
09:22:05 <lambdabot>   mueval-core: Time limit exceeded
09:22:56 <jmcarthur> @oeis 3,30,301,3010
09:22:57 <lambdabot>  Sequence not found.
09:23:33 <geheimdienst> > iterate (10*) 1
09:23:34 <lambdabot>   [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,100000000...
09:23:43 <geheimdienst> > map (\n -> length $ show (iterate (*2) 1 !! n :: Integer)) $ map (-1) $ iterate (10*) 1
09:23:44 <lambdabot>   [*Exception: Prelude.(!!): negative index
09:23:50 <geheimdienst> > map (\n -> length $ show (iterate (*2) 1 !! n :: Integer)) $ map (-1) $ iterate (10*) 10
09:23:51 <lambdabot>   [*Exception: Prelude.(!!): negative index
09:24:03 <geheimdienst> > map (\n -> length $ show (iterate (*2) 1 !! n :: Integer)) $ map pred $ iterate (10*) 10
09:24:06 <lambdabot>   [3,30,301,3010,30103,*Exception: stack overflow
09:24:08 <Deewiant> ?ty map (-1)
09:24:09 <lambdabot> forall a b. (Num b) => [a] -> [b]
09:24:24 <geheimdienst> oh, with 30103 we were just one thing shy of a stack overflow
09:24:53 <aristid> > iterate (*2) 1 !! 9999
09:24:55 <lambdabot>   997531558440379192441871081341792541911748415943096227426004474926471941511...
09:25:06 <geheimdienst> > iterate (*2) 1 !! 999999
09:25:07 <lambdabot>   *Exception: stack overflow
09:25:15 <geheimdienst> > iterate (*2) 1 !! 555555
09:25:17 <lambdabot>   *Exception: stack overflow
09:25:19 <aristid> > iterate (*2) 1
09:25:20 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:25:21 <geheimdienst> > iterate (*2) 1 !! 222222
09:25:25 <lambdabot>   mueval-core: Time limit exceeded
09:25:29 <geheimdienst> > iterate (*2) 1 !! 111111
09:25:31 <aristid> > 2^9999
09:25:32 <lambdabot>   997531558440379192441871081341792541911748415943096227426004474926471941511...
09:25:33 <lambdabot>   mueval-core: Time limit exceeded
09:25:43 <tommd> > iterate (*2) 1 !! (iterate (*2) 1 !! 999)
09:25:44 <lambdabot>   1
09:25:56 <aristid> > 9999*log(10)/log(2)
09:25:57 <lambdabot>   33215.95902077874
09:25:58 <geheimdienst> > iterate (*2) 1 !! 100100
09:26:01 <lambdabot>   126638560283894197990858470253194970212547092881355288099820661684060795867...
09:26:05 <geheimdienst> > iterate (*2) 1 !! 100500
09:26:08 <lambdabot>   327012406854187416797131473704316872200604924117698406400609982061243430336...
09:26:12 <geheimdienst> > iterate (*2) 1 !! 100900
09:26:15 <lambdabot>   844427747732132007893212962996836702372579241346880073192343512119441418816...
09:26:21 <geheimdienst> > iterate (*2) 1 !! 105000
09:26:25 <lambdabot>   141105752142110252186156350912142334411881087465508514511972116921962531586...
09:26:30 <geheimdienst> > iterate (*2) 1 !! 109000
09:26:34 <lambdabot>   186006180080381802359665579884857598644398871902694078447940722708497371732...
09:26:38 <aristid> > 9999*log(2)/log(10)
09:26:39 <lambdabot>   3009.9989266441476
09:26:46 <geheimdienst> > iterate (*2) 1 !! 110000
09:26:49 <lambdabot>   199307222945967925917977601858775212000331018428598992365878240255492527159...
09:26:52 <geheimdienst> > iterate (*2) 1 !! 111000
09:26:56 <lambdabot>   mueval-core: Time limit exceeded
09:27:01 <geheimdienst> > iterate (*2) 1 !! 110500
09:27:04 <lambdabot>   652410391677193824701115142299266464343500498388962048605590232127711952668...
09:27:08 <aristid> > length $ show (2 ^ 9999)
09:27:09 <lambdabot>   3010
09:28:14 <aristid> > ceiling (9999 * (log 2) / (log 10))
09:28:15 <lambdabot>   3010
09:28:28 <aristid> > ceiling (99999 * (log 2) / (log 10))
09:28:29 <lambdabot>   30103
09:28:32 <aristid> > ceiling (9999999 * (log 2) / (log 10))
09:28:34 <lambdabot>   3010300
09:28:37 <aristid> yay.
09:29:11 <aristid> > length $ show (2 ^ 9999999)
09:29:16 <lambdabot>   mueval-core: Time limit exceeded
09:29:27 <abhaya> Hello.
09:31:09 <geheimdienst> hi
09:31:29 <thaostra> hello, everyone
09:32:34 <aristid> @pl \n -> head $ show (2 ^ n)
09:32:35 <lambdabot> head . show . (2 ^)
09:35:55 <kdvh> what is the recommended text editor for Haskell?
09:36:08 <lispy> emacs and vim are widely used
09:36:15 <lispy> leksah, yi, and eclipse are also possible
09:36:26 <lispy> (and probably others I don't know about)
09:36:34 <kdvh> alright, i use vim so ill stick with that
09:37:19 <abhaya> kdvh: Use emacs :)
09:37:37 <thaostra> worth noting that the above text editors work well with most languages, not just haskell
09:38:18 <abhaya> kdvh: I use it for everything including IRC, it has haskell/ghc specific bindings that you might find useful, and you can ask me if you need any configuration/plugins, etc.
09:38:26 <abhaya> That's if you choose it :)
09:38:40 <abhaya> http://www.haskell.org/haskell-mode/
09:38:56 <om-foxy> @instance RealFrac
09:38:56 <lambdabot> Maybe you meant: instances instances-importing
09:39:09 <om-foxy> @instances RealFrac
09:39:10 <lambdabot> Double, Float
09:43:13 <kdvh> abhaya: thanks, ill give it a try to see if i prefer it to vim i guess
09:43:42 <abhaya> kdvh: See query.
09:53:01 <ClaudiusMaximus> tommd, jmcarthur: threadscope appears to work fine with ghc-6.12.3 :)
09:54:06 <jmcarthur> good!
09:54:32 <tommd> :-)
09:54:44 <om-foxy> @instances Enum
09:54:45 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
09:54:58 <zygoloid> is 6.12.2 broken then?
09:55:18 <ClaudiusMaximus> zygoloid: seems so
09:55:19 <tommd> yes
09:55:34 <tommd> Particularly if you use gtk2hs
09:55:43 <ClaudiusMaximus> the release notes for 6.12.3 mention a crash with haskell->c->haskell callbacks
09:55:54 <ClaudiusMaximus> *a fix for
09:56:16 <tommd> It was that bug that kept HP from moving to 6.12.2.  They delayed (for a long while) waiting for 6.12.3
10:05:33 <om-foxy> I have some actions in an IO monad and want to be able perform actions on each element in an arbitrary monad, e.b. Render a.  Is there a standard solution?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27216#a27216
10:06:38 <sproingie> mapM?
10:07:22 <om-foxy> sproingie I'm using Vectors, not lists
10:08:30 <CakeProphet> hmm
10:08:45 <ddarius> That code will only work if f :: a -> IO a.
10:08:46 <CakeProphet> is there a way to specify a default "blank" handle?
10:08:55 <CakeProphet> without using Maybe?
10:09:53 <CakeProphet> @instances Handle
10:09:54 <lambdabot> Couldn't find class `Handle'. Try @instances-importing
10:09:57 <CakeProphet> @instances System.IO.Handle
10:09:59 <lambdabot> Couldn't find class `System.IO.Handle'. Try @instances-importing
10:10:08 <CakeProphet> @instances-importing System.IO Handle
10:10:09 <lambdabot> Couldn't find class `Handle'. Try @instances-importing
10:10:15 <CakeProphet> @instances-importing System.IO Num
10:10:16 <lambdabot> Double, Float, Int, Integer
10:10:16 <CakeProphet> bah
10:10:20 <om-foxy> ddarius: typo from cut and paste, that line should just be f x
10:10:21 <ddarius> om-foxy: You also can't run an arbitrary monad in IO.  For example, if it was a state monad where would the initial state come from or a continuation monad, the initial continuation, and so forth.
10:10:22 <sproingie> hard to get a handle on Handle
10:10:38 <CakeProphet> hmmm...
10:10:46 <ClaudiusMaximus> hm, threadscope doesn't include cpu usage from FFI calls in its activity-level graph
10:10:56 <om-foxy> but can I run IO in other monads, is that MonadIO?
10:10:57 <ddarius> om-foxy: Probably the most sensible thing to do is to lift that function up to your monad (assuming your monad is (internally) some kind of transformer over IO.)
10:11:11 <CakeProphet> I guess I could do Maybe Handle... but there's not really a situation where I have a "blank" handle. I'd just like for convenience for a particular thing I want to do.
10:11:14 <CakeProphet> @class
10:11:15 <lambdabot> Unknown command, try @list
10:11:24 <om-foxy> ddarius, unfortunately, it's not my monad, it's Cairo's
10:12:00 <ddarius> om-foxy: That's not a problem.  The question is whether it implements lift/liftIO or has some way of embedding IO code into it which it probably does.
10:12:11 <om-foxy> okay
10:12:46 <CakeProphet> wasn't there some record syntax extension that made things like handle=handle easier?
10:12:48 <zygoloid> om-foxy: to answer your earlier question, yes, MonadIO means you can run IO actions within that monad
10:12:52 <ddarius> There is another solution that works with some monads by essentially reflecting the effects into IO effects (e.g. storing the state into an IORef) but that's not the way to go.
10:13:05 <CakeProphet> or will something like handle=handle work? The first handle is a record accessor the second is a function parameter.
10:13:12 <zygoloid> CakeProphet: yes, RecordPuns. just say 'handle'
10:13:37 <zygoloid> i'm not sure it works when constructing a record or just when pattern matching one though
10:13:44 <CakeProphet> RecordPuns is the name of extension right? Portable? (bah, I don't care. I'm using TChan already, that's GHC only!)
10:13:51 <om-foxy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27216#a27217
10:13:59 <zygoloid> CakeProphet: portable between a few versions of GHC :)
10:14:20 <CakeProphet> zygoloid:  what about handle=handle? Is that invalid? Does it understand the "scope" of each name?
10:14:27 <zygoloid> yes, that should be fine.
10:14:43 <zygoloid> at worst you'd need DisambiguateRecordFields
10:15:41 <CakeProphet> zygoloid:  wait, I just got a revolutionary idea. I'll just change the function paramter name.
10:17:25 <ManateeLazyCat> I'm research hot-swap with Haskell, i have know yi/xmonad how to implement hot-swap, but i want do a better! Any suggestion and documentation are welcome! :)
10:17:37 <zygoloid> CakeProphet: whoa!
10:19:13 * geheimdienst waits for CakeProphet's paper to appear in a peer-reviewed journal soon. "Lazy Compiler-Supported Manual Disambiguation of Function Names"
10:19:19 <birkenfeld> hmm, what do I do wrong when linking a largish executable (yi in my case) is killed because of it runs OOM?
10:20:04 <aristid> birkenfeld: how much RAM do you have?
10:20:17 <zygoloid> CakeProphet: you should do it
10:21:15 <geheimdienst> > reverse "OOM"
10:21:16 <lambdabot>   "MOO"
10:22:49 <mreh_> > reverse "tuna"
10:22:51 <lambdabot>   "anut"
10:22:56 <flazz> in A.B.C.X.Y.Z what makes any of these segments a module or not?
10:23:06 <birkenfeld> aristid: about 500 MB free
10:23:50 <birkenfeld> and a gigabyte of swap
10:24:54 <aristid> birkenfeld: and total?
10:25:01 <geheimdienst> birkenfeld, i vaguely recall somebody talking about certain ghc versions eating huge amounts of memory when linking, and that this has something to do with dynamic linking being turned on
10:25:24 <birkenfeld> hmm, it's 800 MB total.  I'm using 6.12.3, and "cabal install yi"
10:25:43 <birkenfeld> how do I see if dynamic linking is on?
10:25:45 <ManateeLazyCat> birkenfeld: You need at least 1 GB. :)
10:26:00 <birkenfeld> that is unfortunate :)
10:26:31 <mreh_> how do I start learning to use Yi?
10:26:43 <mreh_> I'm tired of gedit, too much mousy pushy
10:26:50 <birkenfeld> hah, start by successfully compiling it :)
10:27:12 <mreh_> birkenfeld: I had to set constraints on the packages, but I got there in the end!
10:27:21 <mreh_> s/packages/dependencies/
10:28:00 <CakeProphet> hmmmmm
10:28:04 <birkenfeld> well, I'll try again when I'm back at work, and then I can check if buying a new notebook because of Yi is worth it :)
10:28:22 <CakeProphet> I could conceivably use something like stdout as my "default" handle... to specify that there is no socket connected to this data structure.
10:28:35 <mreh_> yi isn't worth a new notebook
10:28:58 * geheimdienst has always been happy with vi
10:29:08 <birkenfeld> then maybe I'll buy it because the old one is five years old
10:29:18 <birkenfeld> and get Yi for free!
10:29:55 <akosch> what opinions do you haskell people have of scala?
10:30:10 <mreh_> no opinion, never used it :|
10:30:21 <soupdragon> Scala is cool 
10:30:33 <soupdragon> it's like this mad frankenstien thing
10:30:58 <birkenfeld> does it scale?
10:31:06 <akosch> :)
10:31:08 <akosch> i would like it because it runs in the jvm
10:31:15 <soupdragon> of course! That's why it's called scal(e)a
10:31:26 <akosch> huge advantage in the enterprise environment
10:31:47 <geheimdienst> if that is a criterion, check out clojure as well
10:32:04 <ManateeLazyCat> dons: Can you fix "plugins" package?
10:32:16 <akosch> i've used groovy to code some unit tests recently
10:32:33 <akosch> at least it supports closures :)
10:32:55 <CakeProphet> now what's the pattern matching syntax for records?
10:33:05 * ManateeLazyCat plugins support dynamic linking for C object, maybe i can build hot-swapping gtk+ program.
10:33:17 * ManateeLazyCat Unfortunately, plugins can't work with ghc-6.12.3
10:36:37 <sshc> Why isn't there a class for strings (String and ByteString)?
10:37:27 <ManateeLazyCat> sshc: Because String is different with ByteString.
10:37:29 <sproingie> no consensus on common operations that they all *must* implement?
10:37:35 <BMeph> sshc: ...because there is one? :)
10:37:44 <Ke> that's just silly
10:37:49 <sshc> BMeph: There is one?
10:38:01 <BMeph> sshc: :set -XOverloadedStrings
10:38:18 <sshc> BMeph: Also, the existence of one isn't a reason for the non-existence of one.
10:38:33 <BMeph> sshc: Then, you can use the "IsString" class (which also includes Data.Text, BTW.)
10:39:41 <zygoloid> the trouble with a class for strings is the name.
10:39:49 <BMeph> sshc: I prefer to say, "the existence of one is a refutation of the assertion of the non-existence of one"... ;)
10:39:55 <zygoloid> IsString is not great, but String is taken...
10:40:17 <sshc> zygoloid: What took the String class?
10:40:28 <zygoloid> umm. String. :)
10:40:36 <gcross> Types and classes can't have the same name
10:40:41 <sshc> It's a type, not a class.
10:40:45 <aristid> .oO(-XOverloadedLists)
10:40:46 <sshc> Oh, I see.
10:40:47 <zygoloid> it's the same namespace
10:40:47 <gcross> The namespace between them is shared
10:40:58 <jmcarthur> is there a good reason they share the same namespace?
10:41:22 <zygoloid> to allow for future extensions i guess
10:41:23 <Zao> jmcarthur: Prevents ambigiousness in types, maybe?
10:41:32 <jmcarthur> i can't think of any ambiguity
10:41:50 <zygoloid> type equality constraints almost add ambiguity
10:41:55 <zygoloid> but not quite :)
10:42:04 <dayz> hi
10:42:53 <dayz> does anyone know why proving NP = coNP involves proving P = NP? is it because P is a subset of both NP and coNP? why is P a subset of coNP?
10:45:06 <sshc> BMeph: Yes, but whatever the intended meaning was, the true meaning of "because ..." ddisn't metalinguistic negation, but it claims a reason. :)
10:46:13 <sshc> The string class only seems to have fromString, which only converts a String to the string type
10:46:25 <sshc> Doesn't seem too helpful, but at least it exists
10:46:29 <danderson> I've just had an epiphany. I was wondering how to deal with a corner case in a function, and I realized that the type system was constraining me to a single implementation
10:46:34 <Zao> sshc: It's used to interpret literals as that type, I believe.
10:46:40 <danderson> which happens to be the one with the most elegant semantics
10:46:42 <Zao> So you can say ("omg" :: B.ByteString)
10:46:55 <sshc> Oh, I see.  That's convenient.
10:47:04 <Zao> sshc: The whole point of overloadedstrings :D
10:47:12 <Zao> Works in matching too, I believe.
10:47:16 <sshc> Don't you need fromString?
10:47:32 * zygoloid is using type families + gadts quite aggressively to get some funky typechecking, and is getting some great results (i'm not even /allowed/ to pattern match against impossible GADT constructors) \o/
10:47:34 <Zao> sshc: With the extension, it's magically invoked for you.
10:47:35 <sshc> Why was it decided to hide it behind an extension?
10:47:44 <sshc> The class.
10:48:35 <gcross> The class isn't hidden, but the extension will use the class to automatically convert literals for you.
10:51:28 <gcross> So, for example, if for efficiency you want all of your code to use ByteStrings instead of Strings, then this extension will help you out by saving you the trouble of having to put an "pack" in front of every string literal in your code.
10:54:41 <zygoloid> the extension will magically use the class even if the module containing it isn't imported
10:55:08 <bauchus> I need help. I wrote a binding to GDBM. I seems to work on x86, but segfaults on my amd64 system. No idea why.
10:55:46 <bauchus> the binding isn't finished. But here: darcs get http://www.communitystory.de/~fridolin/perstable
10:57:40 <bauchus> run cabal install. there is a test program pttest. it write "hello" -> "world" in a DB and reads it back.
10:58:37 <tommd> bauchus: Perhaps you are assuming a machine word is 32 bits somewhere?  Guessing you already brainstormed such issues but fixing is another matter.
10:59:06 <bauchus> no, I'm uses hsc2hs #{peek ...} stuff
10:59:51 <tommd> grrr, death t ohsc2hs, life to c2hs
10:59:59 <davekong> Is there an easy to make a type that is exactly the same as Char only does not include 'i'?
11:00:25 <micahjohnston> how would one make a nice inductively defined directed graph?
11:00:31 <micahjohnston> does anyone have ideas?
11:00:55 <micahjohnston> by inductively defined I mean not the way it's usually done in imperative languages
11:01:07 <davekong> recursively?
11:01:20 <gcross> Have you looked in FGL?
11:01:42 <micahjohnston> a little bit
11:01:57 <micahjohnston> didn't really get it much, and it seemed weird with the way you had to build up graphs
11:02:08 <micahjohnston> it might be good though
11:02:25 <gcross> I haven't used it, but it looked to me like it was based on inductive algorithm on immutable graphs.
11:03:05 <micahjohnston> you could write inductive algorithms, but that was because instead of having each node store everything it pointed to, each edge was stored only once
11:12:05 <CakeProphet> is there any kind of monadic lifter for conditions?
11:12:23 <CakeProphet> instead of doing do { t <- condition; if t then ... else ...}
11:13:16 <illissius> zygoloid: yeah, the part when i added the extra pattern match thinking "eh, well, this is impossible, but ghc will complain otherwise..." and instead it gave an error saying it was impossible was pretty impressive :)
11:13:24 <illissius> are you using stable or development ghc, btw?
11:15:11 <illissius> (I'm not even sure if it's been merged yet, but 6.14 is supposed to have the new constraint solver to make GADTs and type families play better together -- which sort of implies they don't play so well together as-is? haven't tried using them together...)
11:15:29 <FunctorSalad> neat
11:17:11 <CakeProphet> :t (5)
11:17:12 <lambdabot> forall t. (Num t) => t
11:17:14 <CakeProphet> :t (%)
11:17:15 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
11:18:02 <FunctorSalad> dayz: P \subseteq co-NP because a nondeterministic TM is at least as good as a deterministic one... same reason as P \subseteq NP really
11:19:11 <FunctorSalad> just that with NP we interpret the machine as saying 'yes' if any branch accepts, with coNP 'no' if any branch accepts 
11:19:47 <FunctorSalad> (not equivalent since I didn't also negate the 'any' to 'none' =))
11:20:25 <om-foxy> :t when
11:20:26 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:21:03 <soupdragon> you know that 16-puzzle where you permute a square
11:21:03 <soupdragon> ?
11:21:09 <soupdragon> and you have pairty
11:21:16 <soupdragon> is there parity for any nxn grid?
11:22:19 <FunctorSalad> soupdragon: wasn't that the signum of the permutation defined by the grid or so?
11:22:42 <FunctorSalad> there is something to prove in defining the signum in the first place though
11:23:41 <FunctorSalad> (that any decomposition of a permutation into transpositions will give the same signum... or if you use the definition by cycle decomposition, you have to prove that it does in fact flip if you add another transposition ;))
11:25:57 <sm> is there a standard function for converting a string to/from windows line endings ?
11:26:42 <sm> I have a string containing \r\n's, I'm on unix, I want to write it as \n and handle newline modes don't help here
11:27:15 <sm> hm, I could read from the string perhaps
11:27:32 <om-foxy> @ filter (/= '\r') "Help\r\n"
11:27:43 <om-foxy> > filter (/= '\r') "Help\r\n"
11:27:44 <lambdabot>   "Help\n"
11:28:21 <sm> that looks good, and safeish.. thanks om-foxy 
11:29:13 <sm> I guess you can't open a string like a file
11:30:19 <om-foxy> but to replace \r\n with \m you might need a little more thought
11:30:36 <CakeProphet> hmmm... question
11:30:44 <CakeProphet> how could I use the type system to enforce that something is an encrypted string?
11:31:11 <FunctorSalad> sm: readProcess "dos2unix" [] foo
11:31:13 <FunctorSalad> ;)
11:31:25 * sm keeps that in mind :)
11:31:31 <CakeProphet> I have password data that goes into a record. Is there anyway I can guarantee that the password has been encrypted?
11:32:28 <om-foxy> does your encryption module have an encrypted String type?
11:32:45 <om-foxy> @hoogle SHA
11:32:46 <lambdabot> Text.Html shape :: String -> HtmlAttr
11:32:46 <lambdabot> Text.XHtml.Frameset shape :: String -> HtmlAttr
11:32:46 <lambdabot> Text.XHtml.Strict shape :: String -> HtmlAttr
11:32:54 <djahandarie> @hoogle md5
11:32:54 <lambdabot> Network.Browser AlgMD5 :: Algorithm
11:32:54 <lambdabot> Network.Browser AlgMD5sess :: Algorithm
11:32:54 <lambdabot> Network.HTTP.Headers HdrContentMD5 :: HeaderName
11:33:01 <tommd>  om-foxy: The "SHA" and "SHA2" packages have SHA in them.
11:33:23 <tommd> djahandare, om-foxy: Also, the "cryptohash" package has c bindings for SHAs and MD5
11:33:37 <tommd> Also, my pureMD5 package has a Haskell MD5 implementation.
11:33:52 <djahandarie> There is also a binding to openssl I believe
11:33:53 <om-foxy> CakeProphet: Data Foo = Foo { username :: String, password :: MD5 }
11:34:01 <illissius> CakeProphet: not sure if this is the level you were asking on, but make a new type which wraps a string, don't export the constructor, do export a function which encrypts a string and returns it wrapped in the new type?
11:34:05 <tommd> Also, I'm working on a unified API for crypto operations so all these packages will be slightly more friendly to switch between.
11:34:45 <tommd> djahanarie: I've heard people being unhappy with those, but if they work for you then good.  also, there are mini-bindings such as nano-md5, which binds to just the md5 of openssl.
11:34:57 <tommd> djahandarie: ^^
11:35:23 <tommd> CakeProphet: Didn't see your originating question.  Don't use a flat hash - that isn't safe.
11:35:38 <tommd> CakeProphet: Be sure to use a salt.
11:36:07 <tommd> @hoogle PBKDF2
11:36:07 <lambdabot> No results found
11:36:07 <tommd> CakeProphet: Or use that ^^^
11:36:13 <djahandarie> tommd, I think I very recently saw benchmarks somewhere when the openssl bindings did well
11:36:20 <tommd> http://hackage.haskell.org/package/PBKDF2
11:36:36 <FunctorSalad> just curious, is the pure md5 the fastest choice? even if it isn't fastest standalone, it would seem to offer inlining opportunities
11:36:48 <tommd> djahandarie: Not saying they aren't fast, just sometimes frustrating, sometimes incomplete, and obviously require your user to have openssl or you to ship openssl.
11:37:25 <tommd> FunctorSalad: No, pureMD5 is about 6x slower than C.
11:38:15 <djahandarie> tommd, http://tab.snarc.org/blog/post/2010/7/6/haskell_cryptohash/
11:38:16 <tommd> FunctorSalad: I've said many times before: using hashes as a good benchmark for Haskell compilation isn't a bad idea - there are obviously lots of unnecessary costs that a compiler should be able to eliminate.
11:38:38 <tommd> djahandarie: Yes, that is why I earlier suggested cryptohash.
11:39:03 <FunctorSalad> tommd: 6x is standalone I assume? but what about 'as part of a haskell program'?
11:39:20 <tommd> FunctorSalad: Not sure what you mean by that question.
11:39:26 <tommd> What is your distinction and how would it matter?
11:40:40 <FunctorSalad> tommd: as I understand it, ghc keeps inlinable functions in the global package database, so the haskell md5 might allow further optimizations at the particular point it is invoked, while the foreign call is opaque?
11:40:46 <FunctorSalad> wishful thinking I guess ._.
11:40:59 <tommd> Yeah, rather wishful.
11:41:08 <FunctorSalad> but makes sense in general?
11:41:14 <tommd> Half the cost of pureMD5 is reading Word32 from bytestrings.
11:41:22 <FunctorSalad> ah
11:41:36 <tommd> It does single byte reads (darn alignment issues on non-x86 architectures!)
11:42:11 <tommd> It used to do an unsafePerformIO hackery I cooked up, which is why I know how much faster it could be, but the unsafePerformIO broke any time you had unaligned data.
11:42:19 <tommd> on Sparc/ARM/etc.
11:42:36 <bauchus> i guess my GDBM problem is also a alignment problem
11:42:41 <FunctorSalad> dumb example: library function "f x = x + 5", point of use: "print (f foo - 5)", inline, rewrite rule, profit ;)
11:42:54 <bauchus> i found a workaround, which I don't understand...
11:43:07 <aristid> tommd: can't you check whether it is aligned and if so, use the fast stuff?
11:43:08 <tommd> It's rather silly, really.  I could write a routine to take a bytestring and index Word32s in just a few ASM instructions on ARM, and that would use Word reads. 
11:43:22 <tommd> aristid: Can, but it turned out to be rather ugly so I just dropped it.
11:43:39 <tommd> Not sure if cryptohash does it right or breaks on unaligned data - I (or the author) should check.
11:43:42 <aristid> tommd: or better yet, write a generic library for that
11:44:34 <tommd> arstid: Yeah, there has been some discussion on exactly that - the concept that Haskell is missing a type of aligned unboxed arrays + easy coercing to/from ByteString.
11:44:42 <FunctorSalad> surely there's some CPP variable that tells you if you're on x86?
11:45:04 <tommd> Almost certainly, yes.
11:45:17 <tommd> Feel free to write up a patch and submit.
11:45:59 <tommd> The darcs repo is public (community.haskell.org:./public_html/pureMD5)
11:46:06 <tommd> The darcs repo is public (community.haskell.org/public_html/pureMD5)
11:47:14 <FunctorSalad> hehe, I wasn't complaining at all. Just what came to mind @ architecture problems
11:47:45 <tommd> All good thoughts and have been considered - its just a matter of time and focus.
11:47:56 <tommd> My free-time hacking is all about crypto-api right now, not pureMDZ5
11:48:09 <msieradzki> clickable links pls :P
11:48:14 <tommd> pureMD5 was my project 2 years ago and I'm a bit done with it ;-)
11:48:44 <tommd> msieradzki: That wasn't ment to be clicked - just "darcs get" ed
11:49:24 <FunctorSalad> I really didn't mean to complain, it worked flawlessly for me :) and it's not like I'm ever generating more than a handful of md5s myself
11:49:40 <FunctorSalad> just random musings
11:49:41 <tommd> oh, but it couldn't even be that.  sorry.
11:49:41 <tommd> darcs get community.haskell.org/TomMD/pureMD5
11:49:42 <tommd> There!
11:49:43 <ClaudiusMaximus> hm, threadscope shows 18k threads created in 1minute - where are they all coming from :-/
11:50:43 <tommd> FunctorSalad: yes yes, I understand and am not taking offense.  Glad it works well for your uses.  I'm just sharing the information that your ideas were considered and I consider them good too but you shouldn't expect them to become reality any time soon.
11:51:12 <tommd> ClaudiusMaximus: From you or a library calling forkIO?
11:52:04 <ClaudiusMaximus> tommd: i call forkIO once, must be the library then (GLUT)
11:52:13 <tommd> grep forkIO!
11:52:54 <tommd> Humm, my grepping shows no forkIO in GLUT.
11:52:57 <tommd> What other packages?
11:54:04 <ClaudiusMaximus> tommd: that's all, afaik
11:54:18 <ClaudiusMaximus> tommd: apart from what GLUT depends on, which is OpenGL etc
11:54:45 <tommd> No, OpenGL, Tensor, StateVar don't use forkIO
11:54:54 <tommd> Perhaps one of their deps, but that seems unlikely
11:55:22 <tommd> Does threadscope not identify forks in any manner? I only installed it for a look, didn't use it.
11:55:41 * hackagebot hlibev 0.2.6 - FFI interface to libev  http://hackage.haskell.org/package/hlibev-0.2.6 (AycanIrican)
11:56:03 <ClaudiusMaximus> no, it just says things like "thread 17572 created ; is runnable ; starting ; finished"
11:56:25 <tommd> Oh, so they are short lived threads... most/all of them?
11:56:30 <tommd> That's expensive.
11:56:40 <tommd> (somewhat)
11:57:30 <ddarius> Are you sparking any threads?
11:57:43 * hackagebot hlibev 0.2.7 - FFI interface to libev  http://hackage.haskell.org/package/hlibev-0.2.7 (AycanIrican)
11:58:21 <ClaudiusMaximus> ddarius: no, i have one forkIO thread that does long FFI calls and passes the results to the main thread, which does the opengl stuff
11:59:43 <ddarius> Stephanie Weirich was on the Haskell 2010 committee?
11:59:55 <sm> would anyone have code or a library reference for saving auto-numbered backups of a file ?
12:00:20 <ddarius> Sparking is "par" stuff just to be clear.
12:00:43 <ddarius> I wonder if parallel GC counts at all.  I would think it wouldn't.
12:01:21 <zygoloid> S`par`king
12:05:25 <sshc> After I've written the source and .cabal file, how do I create the package?
12:05:31 <sshc> Is it a tarball?
12:06:10 <tommd> yes
12:06:38 <tommd> "cabal sdist" in your package directory
12:06:48 <tommd> it will create a .tar.gz for upload to hackage.haskell.org
12:06:54 <tommd> or you can just "cabal upload"
12:07:23 * ddarius would recommend uploading by hand the first time (at least)
12:07:42 <tommd> yes, and use the "check" feature on hackage.
12:07:46 <ClaudiusMaximus> it's about 2 threads per frame - maybe each haskell->C->haskell callback runs in its own new thread?
12:08:23 <ClaudiusMaximus> one for the timer callback and one for the display callback
12:09:32 <soupdragon> What I really need is haskell to open up a window that renders HTML
12:09:56 <soupdragon> may be best to use a web browser directly but then I need a haskell web server
12:10:34 <djahandarie> So you want a Haskell web browser?
12:11:09 <djahandarie> Or at least a web browser engine
12:11:11 <ddarius> I believe there's a control in Gtk that will render HTML (or maybe wxWindows or something.)
12:11:45 <djahandarie> You can use webkit
12:11:54 <ddarius> There are also plenty of web servers and its really easy to write a simple one of your own.
12:11:55 <djahandarie> @package webkit
12:11:55 <lambdabot> http://hackage.haskell.org/package/webkit
12:12:06 <soupdragon> well um
12:12:27 <soupdragon> okay forget about web browsers for a second I should say what I want to do: Maybe there is a very good way to do it in haskell that I don't know
12:12:52 <djahandarie> Really depends on what you mean by "in Haskell"
12:13:09 <soupdragon> yeah forget about haskell too it doesn't matter
12:13:13 <djahandarie> The package I linked to binds to webkit which can render HTML via GTK
12:13:19 <soupdragon> my program is haskell but I can connect it to a GUI through whatever means
12:14:03 <aristid> hmm... ghci never seems to release memory back to the operating system
12:14:09 <tommd> Correct.
12:14:42 <ddarius> My understanding is that all GHC compiled executables do that.
12:14:43 <tommd> nursery shrinking is something GHC is not so friendly about doing.
12:15:29 <aristid> so once ghc has memory, it keeps it forever?
12:15:34 <ddarius> Yes.
12:15:34 <aristid> or its RTS
12:15:38 <tommd> No, the computer fails eventually
12:16:03 <zygoloid> once GHC has virtual memory, it keeps it as long as it can
12:18:16 <pikhq> This is kinda how GCs work generally.
12:18:49 <zygoloid> doesn't mean it doesn't suck though
12:19:31 <jmcarthur> ClaudiusMaximus: interesting. maybe ask in #ghc?
12:22:34 <ManateeLazyCat> ddarius: Webkit package can do that.
12:23:08 <monochrom> a compacting GC could empty out some pages and give them back to the OS, but probably not everyone implements it.
12:23:16 <ManateeLazyCat> ddarius: I have use Webkit implement a true browser, like this : http://farm5.static.flickr.com/4134/4762834054_6fd804f32e_b.jpg
12:23:40 <ManateeLazyCat> ddarius: Damn fast. :)
12:24:08 <ManateeLazyCat> ddarius: http://farm5.static.flickr.com/4096/4748566880_aefb70879d_b.jpg webkit browser with Flash TV.
12:24:14 <tromp_>  will come by tomorrow betweem 10&11
12:24:19 <monochrom> OTOH there is an RTS option saying "never use more than ___ memory"
12:24:22 <tromp_> argh. ignore
12:26:07 <ManateeLazyCat> soupdragon: The answer is you can.
12:26:37 <zygoloid> tromp_: we'll all be waiting for you :)
12:27:40 * ManateeLazyCat BTW, WebKit binding bug report can send to me ... :)
12:30:33 <nominolo> @hoogle concatMapM
12:30:33 <lambdabot> No results found
12:31:01 <nominolo> :t \f xs -> concat <$> mapM f xs
12:31:02 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
12:34:35 <ManateeLazyCat> soupdragon: http://farm5.static.flickr.com/4136/4777499127_e30e90ba04_b.jpg webkit-engine browser like Google Chrome.
12:34:38 <CakeProphet> huh, weird.
12:34:43 <CakeProphet> I can't find the documentation for Dynamic anywhere
12:34:56 <CakeProphet> ...nevermind. found it
12:35:07 <soupdragon> ManateeLazyCat: this is perfect ;D
12:35:29 <CakeProphet> so I basically want a "dictionary" of string names to arbitrary types. Should I use Dynamic or invent some kind of existential type scheme?
12:35:38 <soupdragon> Does it need Cairo?
12:35:42 <CakeProphet> would GADTs help? I really don't know what they're used for.
12:36:08 <ManateeLazyCat> soupdragon: It's use WebKit binding for WebKitGtk+, i think WebKitGtk+ use Cairo render graphics.
12:37:01 * ManateeLazyCat pasted "browser view code." at http://paste2.org/get/909398
12:37:01 <ManateeLazyCat> soupdragon: Above is browser code in my framework, you will found how easy to write it.
12:37:20 <CakeProphet> :t cast
12:37:21 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
12:37:42 <soupdragon> ManateeLazyCat: my problem now is finding a way to install ubuntu (cairo wont work in the VM)
12:37:45 <ManateeLazyCat> soupdragon: If you don't want multi-processes framework like Google Chrome, you can pull WebKit demo from repository.
12:37:52 <CakeProphet> :t cast (10 :: Int) :: Integer
12:37:53 <lambdabot>     Couldn't match expected type `Integer'
12:37:54 <lambdabot>            against inferred type `Maybe b'
12:37:54 <lambdabot>     In the expression: cast (10 :: Int) :: Integer
12:38:00 <CakeProphet> :t cast (10 :: Int) :: Maybe Integer
12:38:01 <lambdabot> Maybe Integer
12:38:06 <CakeProphet> :t cast (10 :: Int) :: Maybe Float
12:38:07 <lambdabot> Maybe Float
12:38:14 <CakeProphet> > cast (10 :: Int) :: Maybe Float
12:38:15 <lambdabot>   Nothing
12:38:17 <ManateeLazyCat> soupdragon: What's your host OS?
12:38:19 <CakeProphet> ah.
12:38:27 <CakeProphet> > cast (10 :: Int) :: Maybe Integer
12:38:28 <soupdragon> mac
12:38:29 <lambdabot>   Nothing
12:39:04 <ManateeLazyCat> soupdragon: Now i'm mix my hot-swapping core in my framework, after then i will release my project, then you can use it -- Haskell WebKit browser . :)
12:39:25 <soupdragon> cool!
12:39:29 <CakeProphet> > cast (10) :: Maybe Integer
12:39:30 <lambdabot>   Just 10
12:39:33 <c_wraith> :t Data.Traversable.sequence . fmap
12:39:34 <lambdabot> forall (m :: * -> *) a a1. (Data.Traversable.Traversable ((->) (m a1)), Monad m, Functor m) => (a1 -> a) -> m (m a1 -> a)
12:39:42 <c_wraith> oh
12:39:42 <pikhq> ManateeLazyCat: Ah, multi-process is easy. Just some Xembed and fork. Doesn't get you all of what Chrome does, but it's 99% of it for about 3 lines of code.
12:39:50 <c_wraith> :t Data.Traversable.sequence . fmap (+1)
12:39:51 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m, Num (m a)) => t (m a) -> m (t a)
12:39:51 <CakeProphet> hmmmm
12:40:03 <ManateeLazyCat> pikhq: Yes, i have finish.
12:40:19 <ManateeLazyCat> pikhq: I can do all Google Chrome can do.
12:40:23 <ManateeLazyCat> pikhq: And more powerful.
12:40:25 <CakeProphet> so... is Dynamic worth it? Or is there generally a "better" way to do it?
12:40:27 <pikhq> Also: not bad on the Webkit frontend.
12:40:47 <CakeProphet> I guess I could just do  data Data = StringData String | IntData Int | ...
12:40:56 <ManateeLazyCat> pikhq: Google Chrome don't handle MVC.
12:41:15 <ClaudiusMaximus> ouch "(the thread running Main.main) is always a bound thread, so for good concurrency performance you should ensure that the main thread is not doing repeated communication with other threads in the system"
12:41:52 <ManateeLazyCat> pikhq: Yes, principle is easy, but it's have some trick block you in Xembed.
12:41:52 <CakeProphet> > [toDyn 1, toDyn "Hello", toDyn 0.32]
12:41:53 <lambdabot>   [<<Integer>>,<<[Char]>>,<<Double>>]
12:41:57 <monochrom> Yes, at most waiting on a few MVar's to be notified "quit now"
12:42:18 <CakeProphet> ....I don't understand how Dynamic can guarantee type safety.
12:42:23 <ClaudiusMaximus> monochrom: but then how do i use OpenGL with threads efficiently?
12:42:24 <monochrom> well, "repeated" communication that really happens every 5 minutes is fine too.
12:42:30 <ManateeLazyCat> pikhq: MVC mean you can running your sub-module in backend and don't need render it.
12:42:44 <CakeProphet> oh wait... yes I do. nevermind
12:42:50 <CakeProphet> because of the default value for fromDyn
12:42:54 <ManateeLazyCat> pikhq: It's need mix xembeded, gtk2hs, and DBus by Haskell.
12:43:01 <CakeProphet> and using Maybe a in fromDynamic
12:43:19 <CakeProphet> well then, I'm using Dynamic. :)
12:43:29 <monochrom> but OpenGL on a bound thread like main is fair game
12:44:11 <g_cross> CakeProphet:  What kinds of types will you be storing in the map?
12:45:06 <ManateeLazyCat> pikhq: Fortunately, i have finish those work, i will release my code that explain those trick... :)
12:45:21 <CakeProphet> g_cross:  any type would be preferable. I'd like to be able to extend it trivially to my needs. I guess I could do that with any implementation...
12:45:35 <CakeProphet> g_cross:  but basic data types. strings, ints, floats, bools.
12:46:10 <g_cross> CakeProphet:  Hmm, what's the application?
12:46:25 <ManateeLazyCat> soupdragon: In my framework, you don't just got one browser, you also got many sub-module like this http://farm5.static.flickr.com/4098/4771492256_e1f3a318ef_b.jpg 
12:46:52 <ManateeLazyCat> soupdragon: Now i'm research hot-swapping integrate with gtk2hs.......
12:47:00 <CakeProphet> g_cross:  MUD server. I'm using it as for collections of arbitrary data. For adminstrators to add stats and such to players. I might also end up using it as a config table that can be changed via MUD commands.
12:47:03 <soupdragon> ManateeLazyCat: what is this which displays .hs?
12:47:08 <soupdragon> in the bottom left
12:47:42 <ManateeLazyCat> soupdragon: In http://farm5.static.flickr.com/4098/4771492256_e1f3a318ef_b.jpg , include WebKit-Browser, File-manager, pdf-viewer, editor.
12:47:49 <ManateeLazyCat> soupdragon: Bottom left is gtk editor.
12:47:57 <g_cross> CakeProphet:  Hmm, I have a module I've been working on that might fit your purpose.
12:48:00 <ClaudiusMaximus> monochrom: you see my problem.  i need a bound thread for OpenGL and a background calculation thread ; these two threads need to be in repeated communication
12:48:08 <soupdragon> cool
12:48:17 <monochrom> how often is the communication?
12:48:22 <ManateeLazyCat> soupdragon: Multi-Processes/MVC framework for crash-free, but not just for browser.
12:48:27 <ClaudiusMaximus> once per frame in each direction
12:48:30 <g_cross> CakeProphet:  It acts like a map, but it maps objects of type "Field a" to a.
12:48:52 <jmcarthur> ClaudiusMaximus: if your main thread needs to communicate with other threads often, you should just fork another thread from it to be your "main" thread instead
12:48:59 <jmcarthur> oh, OpenGL
12:49:06 <ManateeLazyCat> soupdragon: I'm doing is make it don't need restart when add new code like Yi/XMonad do, but i want more powerful than that.... :)
12:49:11 <monochrom> I think you should tolerate it.
12:49:18 <jmcarthur> i dunno that i'd worry too much about once per frame
12:49:19 <soupdragon> ManateeLazyCat: ahh neat
12:49:25 <CakeProphet> g_cross:  hmmm. Well the keys for my map are strings.
12:49:59 <ManateeLazyCat> soupdragon: But for fully hot-swapping like elisp for Emacs, it's still need long time to research. 
12:50:03 <g_cross> In my scheme, when you want to define a key you create a new value of type Field corresponding to that key
12:50:10 <CakeProphet> g_cross:  and I want the collection to be hetereogenous. Either with an existential or through multiple type constructors (or through Dynamic, which I'm currently going to use as my implementation until I come up with a better idea)
12:50:12 <g_cross> The field has a descriptive name and is identified by a UUID
12:50:15 <monochrom> 2 MVar's per frame sounds like 60 MVar's per second. I would guess it's tolerable as a first instinct
12:50:17 <jmcarthur> ClaudiusMaximus: why a calculation thread? why not par or something?
12:50:28 <g_cross> The collection is heterogeneous
12:50:29 <ManateeLazyCat> soupdragon: Maybe i need embedded haskell-interpreter in it for fully hot-swapping.
12:50:29 <jmcarthur> or is there more to it?
12:50:45 <CakeProphet> g_cross:  how does one obtain a UUID for a key name?
12:50:55 <ClaudiusMaximus> jmcarthur: it does long FFI calls (a C function that renders Julia Sets)
12:51:11 <monochrom> oh what fun :)
12:51:53 <monochrom> oh what fun it is to compute on a one-core open box...
12:51:58 <om-foxy> CakeProphet: you might want to check out  liboleg and typed polymorphic lists
12:52:23 <om-foxy> @google HList
12:52:25 <lambdabot> http://homepages.cwi.nl/~ralf/HList/
12:52:25 <lambdabot> Title: Strongly typed heterogeneous collections
12:52:43 <jmcarthur> ClaudiusMaximus: i'm still not sure that sounds so bad for par unless it's doing IO
12:52:44 <g_cross> So it looks like this:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27219#a27219
12:52:56 <g_cross> You generate the UUID randomly
12:53:11 <ManateeLazyCat> CakeProphet: Use nested-list for polymorphism match. :)
12:53:15 <g_cross> The theory is that this way you don't have to worry about conflicting names, since every field has a unique identifier.
12:53:39 <CakeProphet> hmmm, I'm actually not worried about conflicting names. I specifically want a unique name for each field.
12:54:16 <jmcarthur> either way, par vs. forkIO i think wouldn't have much effect on your performance in this case
12:54:16 <CakeProphet> I just want hetereogenousness that's easy to deal with. But I think I've figured out a nice scheme using Dynamic. There's really no reason not to use Dynamic for my purposes, I think.
12:54:25 <g_cross> Yeah, it sound like it.
12:55:07 <ManateeLazyCat> CakeProphet: Why you need unique name? What's your really want to solve?
12:55:24 <g_cross> The only downside is that you don't have a way of enforcing that a string key has a given type;  it has to be understood.
12:55:26 <ManateeLazyCat> s/unique name/unique name identifier
12:55:44 <CakeProphet> ManateeLazyCat:  the unique name is because the table is accessed via user input. The user refers to each field by a name. If there were multiple fields with the same name it would be ambiguous which field they're referring to.
12:56:29 <g_cross> CakeProphet:  So you're effectively writing a dynamically typed DSL in Haskell?
12:56:51 <CakeProphet> CakeProphet:  yes, actually. That's a future goal. right now I'm just making the dynamic model for such a language.
12:57:03 <g_cross> Gotchya
12:57:11 <CakeProphet> ... ha. I referred to myself.
12:57:17 <g_cross> lol :-)
12:57:41 <jmcarthur> <infinite loop>
12:57:48 <CakeProphet> data PlayerData = PlayerData {value :: Dynamic, description :: String}
12:57:57 <jmcarthur> actually, i think the error is supposed to be just <loop>
12:58:03 <jmcarthur> don't remember
12:58:06 <CakeProphet> and then there's a record field on a Player structure of type Map String PlayerData
12:58:22 <jmcarthur> Trie!
12:58:43 <jmcarthur> ByteString!
12:58:45 <jmcarthur> fast!
12:58:46 <g_cross> CakeProphet:  Oh, I see.  And yeah, having a PlayerData object around is a good idea because it will let you attach additional meta-information about the type to the value.
12:59:13 <CakeProphet> g_cross:  yeah. I was actually just considering if I wanted to carry around type information. I don't see why not I suppose.
12:59:36 <g_cross> So, in a sense you already are, since the Dynamic contains information about the type.
12:59:44 <jmcarthur> wait, so you are using Dynamic *and* a tag?
12:59:50 <jmcarthur> why not just use an ADT? :P
12:59:53 <CakeProphet> ah. yeah. I can just use typeOf right? or what is the function?
13:00:06 <CakeProphet> well, no not a tag.
13:00:06 <ManateeLazyCat> Please give me link if anyone know a good book for Hot-Swapping. I'm searching....
13:00:40 <CakeProphet> what's the command to search packages by type signature?
13:00:49 <ManateeLazyCat> CakeProphet: If you use Dynamic, you perhaps not need Tag.
13:00:52 <g_cross> dynTypeRep
13:00:55 <CakeProphet> ah.
13:00:57 <g_cross> @hayoo dynTypeRep
13:00:57 <lambdabot> Unknown command, try @list
13:00:59 <jmcarthur> as soon as you type "typeOf" you might as well be doing pattern matching, except possibly in extreme circumstances that i can't think of
13:01:04 <g_cross> @hoogle dynTypeRep
13:01:04 <lambdabot> Data.Dynamic dynTypeRep :: Dynamic -> TypeRep
13:01:16 <CakeProphet> yeah with Dynamic there's no need to have a tag then
13:01:19 <g_cross> So that will fetch the type of the value, however I don't know how useful that will be to you.
13:01:21 <CakeProphet> but the description will be nice. :)
13:01:22 <g_cross> On the othe rhand
13:01:25 <CakeProphet> for help information.
13:01:37 <g_cross> For your dynamically typed language, you might want to explicitly support a subset of types.
13:01:51 <g_cross> Then you could create a class that lets you tag those types with additional meta-information that is useful to you.
13:02:08 <CakeProphet> yeah. I'm not worried about language design at the moment. Right now I'm a) getting familiar with Haskell  b) making a skeleton for a MUD server.
13:02:12 <jmcarthur> what's the point of using Dynamic if you're just multiplexing on the type?
13:02:15 <CakeProphet> anything fancy will come later.
13:02:15 <g_cross> Fair enough.
13:02:49 <g_cross> jmcarthur: Presumably he wants an "open" system so that anyone can add types to the map.
13:02:58 <CakeProphet> correct.
13:03:12 <jmcarthur> that sounds "typeless" rather than "dynamically typed" to me
13:03:26 <CakeProphet> no it's dynamically typed.
13:03:30 <jmcarthur> might as well just have a (String, String) representation
13:03:31 <CakeProphet> same way Ruby or Python is.
13:03:33 <g_cross> CakeProphet:  Another option that you have is to use existential types.
13:03:37 <jmcarthur> if types can be added at runtime
13:03:46 <CakeProphet> g_cross:  considered it. But there's not really a typeclass unifying all of the different types I intend to use.
13:03:48 <jmcarthur> oh, my mind filled in "at runtime" itself
13:04:09 <g_cross> CakeProphet:  data PlayerData = forall a. Typeable a => PlayerData {value :: a, description :: String}
13:04:22 <ddarius> CakeProphet: You don't need to use a single type class or any type classes with existential types.
13:04:28 <CakeProphet> g_cross:  ha. interesting. That would almost be the same as Dynamic wouldn't it?
13:04:43 <CakeProphet> ddarius:  I do if I want to use anything other than bottom right?
13:04:44 <ManateeLazyCat> CakeProphet: Are you developing Player? Or PlayerData just example? :) 
13:04:44 <g_cross> CakeProphet: Then you can use typeOf to learn about the value and  cast to convert it to the type th
13:04:50 <ddarius> CakeProphet: No.
13:04:55 <CakeProphet> ManateeLazyCat:  both?
13:04:56 <jmcarthur> CakeProphet: you can also include a dictionary along with the value
13:05:12 <CakeProphet> g_cross:  hmmm, what would be the advantage over Dynamic? It almost sounds the same.
13:05:26 <ddarius> CakeProphet: That is pretty much the same.
13:05:34 <ManateeLazyCat> CakeProphet: Dynamic haven't magic. :)
13:05:37 <g_cross> ddarius:  I think that CakeProphet was responding to my earlier comment that he could create a class that captures a subset of types that he is interested in.
13:05:43 <ddarius> CakeProphet: However, you should be thinking: "What do I need to know about the type to do what I need to do?"
13:06:01 <CakeProphet> ddarius:  I need to know its type. :) so Typeable.
13:06:04 <CakeProphet> or Dynamic.
13:06:10 <ddarius> CakeProphet: What are you going to do with the type?
13:06:12 <ManateeLazyCat> CakeProphet: I always use Typeable integrate with type-class.
13:06:19 <CakeProphet> Dynamic seems to be an existential over Typeable, more or less.
13:06:25 <ddarius> CakeProphet: It is more or less.
13:06:48 <CakeProphet> ddarius: check it in a condition, do something if it's the right type. Or use fromDyn and use a default value if the type is wrong.
13:06:57 <jmcarthur> its type is an implementation detail. ddarius is suggesting that you *abstract* that away and decide what you actually need from it. *why* do you need the type?
13:07:10 <CakeProphet> ah... well
13:07:11 <ddarius> In fact, you shouldn't care about the type.  Think OO, all you care about is whether it supports the interface you need.
13:07:21 <CakeProphet> I suppose I could make specific structures for specific typeclasses throughout my program.
13:07:22 <jmcarthur> exactly
13:07:27 <jmcarthur> well
13:07:29 <ddarius> CakeProphet: That would limit you to a fixed finite set of types at which point you could use an sum type.
13:07:32 <ManateeLazyCat> ddarius: Yeah, you got it. :)
13:07:43 <CakeProphet> I could do that I suppose.
13:08:00 <g_cross> However
13:08:11 <ddarius> It's extremely rare for Dynamic to be the right answer.
13:08:21 <g_cross> It sounds to me like what CakeProphet is trying to do (and correct me if I am wrong) is to use a single place where different sections of code can contribute information to the player type.
13:08:31 <g_cross> To keep it all in one place.
13:08:38 <jmcarthur> g_cross: i don't see how our suggestions conflict with that whatsoever
13:08:40 <g_cross> In such a way that the player type can be extended by external code.
13:08:40 <CakeProphet> there are different use cases. A configuration table would essentially need type-checking capability and extraction. There are other situations where only Show is needed, and others where Num or Integral are needed. But I need it all to be in the same collection
13:08:45 <CakeProphet> so for example
13:08:54 <g_cross> Because your suggestions assume that he knows structure of the types he is storing in advance.
13:09:08 <g_cross> But in the case I just mentioned, he actually doesn't have knowledge of the structure in advance.
13:09:09 <CakeProphet> I have one table where everything would instantiate Show, but only some would instantiate Integral and Num, and I would need to do a typecheck for that subset.
13:09:37 <ManateeLazyCat> CakeProphet: So use "class Typeable a => Player a where" use type-class build *common* methods, use Tyepable.cast for *special* method.
13:09:43 <g_cross> Okay, so if that is the case then I am wrong and it sounds like you do have additional structure that you are imposing on the values.
13:10:02 <ManateeLazyCat> CakeProphet: Best paste your code.
13:10:06 <CakeProphet> g_cross:  only Show really.
13:10:16 <ManateeLazyCat> CakeProphet: Otherwise we can't give your best solution. :)
13:10:19 <g_cross> Hmm, so does every value need to be an instance of Show, then?
13:10:28 <CakeProphet> ManateeLazyCat:  none of the code actually uses the table yet. I'm planning for that.
13:10:30 <g_cross> Because that is actually an advantage of th existential type, then.
13:10:38 <CakeProphet> g_cross:  more or less yes. I will need to display all of it at some point.
13:10:41 <ManateeLazyCat> CakeProphet: Ah. :)
13:10:49 <g_cross> data PlayerData = forall a. (Typeable a, Show a) => PlayerData { value :: a, description :: String }
13:10:53 <jmcarthur> CakeProphet: what distinguishes elements in the collection that need to instantiate Integral from those that don't? how are they used differently? how does the program retrieve them in the first place?
13:10:57 <g_cross> This way you can show the data without having to cast it first.
13:10:58 <ddarius> CakeProphet: You can use a sum type of existential packages.  E.g. data Stuff = Configuration ... | Describable Showable | Numeric Numable
13:11:02 <cizra> Can I use pattern matching inside lambda expessions? I want to find a specific item from a list that contains custom data types
13:11:32 <CakeProphet> jmcarthur:  alright well. The table in question is a "score sheet". It's a write up for a character sheet. Dunno if you've ever played tabletop. But you'll have some entries that are strings and others that are numbers and such.
13:11:38 <ManateeLazyCat> cizra: \list -> find list... ?
13:12:16 <jmcarthur> CakeProphet: if you may end up adding arbitrary types, how does your `typeOf' code know that this arbitrary value instantiates the relevant type class?
13:12:21 <cizra> ManateeLazyCat: find (
13:12:22 <ddarius> cizra: You can only have one branch of pattern matching.  Use case or a local function.
13:12:28 <CakeProphet> jmcarthur:  so /some/ of the values I can use in a dice roller, for instance. A dice roller needs an Integral of some kind. But the strings are merely for display.
13:12:41 <CakeProphet> brb a moment.
13:12:44 <cizra> ddarius: Having one branch would suffice
13:12:47 <jmcarthur> CakeProphet: how does the dice roller know which values to use and which not to?
13:12:49 <jmcarthur> by name?
13:12:58 <ddarius> > (\(x:xs) -> x) "foo"
13:12:59 <lambdabot>   'f'
13:13:08 <cizra> ddarius: aha!
13:13:31 * ManateeLazyCat Oh my, 04:13 am, g'night all. :)
13:14:27 <CakeProphet> jmcarthur:  user input. Someone types in the name of the stat. "roll strength melee"
13:14:37 <CakeProphet> so perhaps I need to seperate the data structures?
13:14:44 <CakeProphet> one for the integers and one for strings?
13:15:08 <g_cross> CakeProphet:  Here is an example of a typeclass that lets you tag types with a subset of optionally supported operations:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27220
13:15:16 <ddarius> CakeProphet: If you have a fixed set of types (or even classes of types) just use an ADT.
13:15:28 <ddarius> data Stat = IntegerStat Integer | StringStat String
13:15:31 <jmcarthur> CakeProphet: it's sounding lke ADT territory to me
13:15:33 <jmcarthur> *like
13:15:46 <CakeProphet> jmcarthur:  perhaps.
13:16:00 <CakeProphet> I don't know what I will need in the future.
13:16:17 <jmcarthur> i wouldn't worry about it until then
13:16:49 <vili> at
13:17:11 <g_cross> Of course, one option is that you could always write your MUD in a dynamically typed language instead.  :-)
13:17:15 <ddarius> CakeProphet: Dynamic doesn't really help you much there.  It may even hurt you.  If you are writing code like case typeOf foo of StringType -> ...; IntegerType -> ..., you'll still need to go back and extend all of those.  With an ADT the compiler can warn about non-exhaustive pattern matches.
13:17:28 <ddarius> g_cross: So you can have the same problem -everywhere-.
13:18:04 <CakeProphet> ddarius:  usually it'll be TypeInQuestion -> ...  all_other_types -> ...
13:18:08 <CakeProphet> I think.
13:18:25 <CakeProphet> I was considering Dynamic for the flexibility it will offer. I think I'll still use it for other data structures.
13:18:37 <ddarius> CakeProphet: Then just have an OtherTypes alternative to the ADT.
13:18:58 <CakeProphet> ddarius:  ? Well, no the ADT needs to represent each possible type.
13:19:00 <jmcarthur> rather, just have a _ -> blah blah pattern
13:19:05 <CakeProphet> all_other_types is just an exhaustive match
13:19:09 <CakeProphet> right
13:19:12 <ddarius> CakeProphet: No it doesn't.
13:19:12 <CakeProphet> probably use _ -> ...
13:20:54 <CakeProphet> I think I'll probably use an existential.
13:20:59 <ddarius> 1) You -can- stick Dynamic in that OtherTypes branch if all you are going to do is give it back to some kind of user plug-in (which will know what type it is because it made it) and you at least separate your wired-in processing from your extensible processing.
13:21:23 <CakeProphet> my use case depends on the function being called. The data type merely needs to represent any of them.,
13:21:34 <ddarius> But it would be better then to not even separate the two.  Just stick the whole "processor" in your data structure (if even that is necessary)
13:22:05 <CakeProphet> g_cross:  I think the Typeable+Show existential is the best option from what I can tell.
13:22:07 <ddarius> CakeProphet: It sounds like you are conflating things for no apparent reason.
13:22:24 <CakeProphet> ddarius:  this is probably also true. :P  I tend to overthink.
13:23:11 <jmcarthur> it's not a problem until it's a problem, and i don't think you'd have a problem with an ADT in the first place
13:24:04 <g_cross> So jmcarthur, what exactly is the advantage of having the case be over the ADT, rather than over whether the type casts or not?
13:24:09 <ddarius> Overthinking would lead to distinguishing things for no apparent reason.  At any rate, just leave the type a stub.  Write the code that you want to write and then -look- at what you are actually doing to the type.  Then capture those operations into a small collection of classes and an ADT that switches amoung them (assuming you still want to put them all in the same box)
13:24:24 <g_cross> Because either way you are going to have something of the form
13:24:35 <g_cross> case x of { right_thing -> ...  otherwise -> .... }
13:24:39 <ddarius> g_cross: I mentioned one benefit above.  Another is that it is much prettier.
13:24:44 <ddarius> (and more efficient)
13:25:03 <aristid> @pl \m n -> max (m+1) n
13:25:03 <lambdabot> max . (1 +)
13:25:21 <jmcarthur> g_cross: because at least this way the constructor tells you what you can do with the value. with Dynamic, i can't just take an arbitrary type that instantiates Num and use it unless i "guess" the concrete type
13:25:37 <CakeProphet> ddarius:  I think this is exactly what I'm going to do. I will leave it as is for now. 
13:25:44 <jmcarthur> and if all my guesses are wrong, i fail
13:26:34 <ddarius> OO practice does this better than (current) Haskell practice.  You really don't want to pick out concrete types.  You just want to aim at interfaces.
13:26:44 <jmcarthur> exactly
13:26:47 <g_cross> jmcarthur:  True, though that is an advantage only if your GADT type constructor is an existential over Num rather than a specific integer type
13:27:10 <ddarius> g_cross: Which is something you can do with an ADT and not something you can do with Dynamic.
13:27:10 <jmcarthur> so *if* you are going to go for this approach, you want existentials, not Dynamic
13:27:16 <CakeProphet> I want Integral basically. for a dice roller, there are no fractional dice amounts.
13:27:18 <ddarius> g_cross: Indeed that is one of the options I suggested earlier.
13:27:18 <jmcarthur> g_cross: sure. try that with Dynamic though ;)
13:27:35 <jmcarthur> CakeProphet: why not just use a concrete type?
13:28:34 <CakeProphet> well... I don't really know. But I believe an existential will offer more flexibility /and/ allow me to encapsulate any interfaces that I realize exist.
13:28:38 <CakeProphet> later on.
13:28:48 <g_cross> jmcarthur:  Oh, okay, good point;  when I said Dynamic I really meant existential types
13:29:18 <g_cross> jmcarthur:  What I was really contrasting was having one constructor for each type case versus encapsulating all of them in a single existential constructor with Typeable
13:29:26 <CakeProphet> Dynamic implies that I want any kind of value. But that's not what I want. For the moment, I know I want values that I can display and values whose type I can check.
13:29:48 <g_cross> Yes, I apologize, I was using the wrong terminology to describe what I was thinking
13:29:52 <jmcarthur> g_cross: and in that case, CakeProphet *still* wants an ADT so that the constructor can identify which instances are available
13:30:04 <ddarius> CakeProphet: Sometimes it can work out that you don't gain anything (or at least not much) by using an existential.  E.g. there is little reason to use data Showable = forall a. Show a => Showable a.  (Pretty much) All you can do is apply Show to that and get a String.  You might as well just store the String in that case.
13:30:29 * edwardk waves hello.
13:30:29 <ddarius> CakeProphet: I still don't understand why you care what the type is.
13:30:34 <CakeProphet> ddarius:  but with typical can't I check type and then return the correct type?
13:30:49 <CakeProphet> *typeable :P
13:30:58 <jmcarthur> CakeProphet: also be careful with things like forall a . Num a => Foo a, because you still can't do Foo 5 + Foo 6
13:31:10 <CakeProphet> jmcarthur:  ah, well of course. :)
13:31:15 <g_cross> jmcarthur:  But imagine if you had one of, say, three type classes that a stored value could either support or not support;  then you would need nine constructors in your ADT to handle all of the possibilities.
13:31:24 <jmcarthur> i just don't know how the dice rolling is intended to work, is why i point that out
13:31:33 <CakeProphet> ah... well
13:31:43 <CakeProphet> the thing is, I intend to implement multiple dice rollers. For different tabletop systems
13:31:46 <g_cross> jmcarthur:  So what you'd still want is an interface that lets you probe whether a value supports an interface, rather than using ADTs
13:31:54 <jmcarthur> g_cross: or just have different collections altogether
13:31:59 <ddarius> CakeProphet: You can try to guess, but again, if you only have a finite set of types then an ADT captures that explicit and Dynamic/Typeable does not.  And again, what do you -care- what type it is?  All you should care about is that you can do the things you need to do to it.
13:32:02 <jmcarthur> which makes more sense to me
13:32:03 <g_cross> jmcarthur:  Such as?
13:32:09 <CakeProphet> an example dice roller is for the WoD system. It rolls a number of ten-sided dice. So if your stat is 3 you roll 3 ten-sided dice
13:32:43 <jmcarthur> g_cross: well, i said that without thinking actually. if you need some combination of instances then my suggestion is fail anyway. doesn't solve the problem you brought up
13:33:01 <CakeProphet> haha. 
13:33:16 <CakeProphet> well it's not a pressing issue right now. Just brought it up because I was thinking about it.
13:33:26 <jmcarthur> g_cross: honestly though, if you have a giant collection of random objects and you have no idea what you will do with it, i think there's a design problem
13:33:29 <CakeProphet> I can always use a stub for now.
13:33:52 <g_cross> jmcarthur:  Fair point.
13:34:00 <g_cross> jmcarthur
13:34:05 <jmcarthur> o_O
13:34:09 <g_cross> (oops, typo there  :-) )
13:34:15 <jmcarthur> heh
13:34:15 <CakeProphet> jmcarthur:  well, I know exactly what I'm going to do with them. but the interface is not unified. Only some operations work on some values in the collection. I just want to check the type and do something based on it.
13:34:32 <g_cross> (I was starting to say something and then realized I didn't really have a point after all --- curse you enter key being right next to the shift key!)
13:34:49 <jmcarthur> "checking the type" still sounds like an implementation detail that shouldn't be necessary to me
13:34:59 <CakeProphet> jmcarthur:  but there is benefit to having them in a collection together. Because they are used in other places that are unified.
13:35:05 <ddarius> g_cross: There are ways to handle the case you brought up as well.
13:35:14 <jmcarthur> CakeProphet: anyway, a stub is nice, do that :)
13:35:41 <g_cross> ddarius:  Such as?  I did mention one example, which was to create a typeclass that probed for the desired functionality and then to implement an existential based on that.
13:35:50 <CakeProphet> one of the things I like about Haskell is its stubbableness. My program has remained typesafe throughout development.
13:35:50 <g_cross> ddarius:  Something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27220
13:35:56 <g_cross> ddarius:  Do you have a better alternative in mind?
13:36:11 <jmcarthur> i only have this additional thing to say. haskell is not an OO language, and using it like an OO language is hard enough. using it like a dynamically typed OO language is even harder
13:36:19 <ddarius> As a totally different way of handling the problem (and by "totally different" I mean just encoding the ADT approach in a coalgebraic manner) you could simply have a dictionary/class with a collection of "supportsFoo" methods that would return a Maybe FooInterface.
13:36:43 <g_cross> ddarius:  Oh; fair enough
13:37:02 <CakeProphet> jmcarthur:  I'm not using it like an OO language at all. :)
13:37:19 <CakeProphet> I'm using the facilities it has for typechecking... in a problem that can be solved well by typechecking.
13:37:32 <ddarius> g_cross: Your approach is similar to what I just described only it looks a bit more (overly?) fine-grained (and is roughly dual to the ADT approach).
13:38:18 <CakeProphet> haha. this is a great discussion. If you want a group of Haskellers to get absolutely nowhere in a discussion, bring up Dynamic typing. :)
13:38:36 <g_cross> ddarius:  Yeah, my approach was overly fine-grained just because I was throwing together an example of what could be done.  :-)  I agree that our approaches are roughly equivalent.
13:38:45 <ddarius> CakeProphet: The goal wasn't to get us somewhere.  It was to get you somewhere.
13:38:56 <g_cross> ddarius:  Although an advantage of my approach is that you don't have to fill in the fields manually --- the type system take care of that for you.
13:39:06 <CakeProphet> ddarius:  ah, yes. Well I think I'm somewhere now. :D
13:39:18 <g_cross> ddarius:  Well, given that you've written the instances yourself  :-)
13:39:43 <BMeph> Is there a list/forum/channel/medium where folks discuss what they'd like Haskell's record types to be like?
13:39:50 <CakeProphet> I'll come back in a few days with Python invented. It'll be revolutionary.
13:40:02 <BMeph> Or do folks just save it up for rants at random? ;)
13:40:14 <CakeProphet> BMeph:  random rants, I'd say.
13:40:20 <ddarius> g_cross: I don't think that would be any more or less necessary for my approach.  My approach is basically instead of doing individual operations sticking the whole interface (e.g. all of Num) into the result (this will minimize the checking for Maybes).  You could do that with a record or using an existential package.
13:40:23 <CakeProphet> no specific place. Maybe somewhere not on IRC.
13:40:34 * jmcarthur considers registering #haskell-record-complaints
13:40:45 <CakeProphet> here's what Haskell's data types should look like
13:40:57 <CakeProphet> struct { Int a; [Char] b;}
13:40:59 <CakeProphet> ...seriously guys.
13:41:04 <ddarius> data Python = Scope (Either BaseType (Map String Python))
13:41:18 <g_cross> ddarius:  Oh, I see, I misunderstood;  so you'd create the dictionary once, tag it to types with something like a class, and then include it as an extra field.
13:41:45 <dobblego> @remember ddarius data Python = Scope (Either BaseType (Map String Python))
13:41:45 <lambdabot> Done.
13:41:47 <g_cross> ddarius:  And that does have the advantage of being more flexible because it lets you change the implementation of the supported interfaces
13:42:11 <jmcarthur> i'm tired of flexibility
13:42:18 <jmcarthur> it's not that useful
13:42:29 <benmachine> BMeph: I'd go looking on the wiki personally
13:42:49 <CakeProphet> do I need a language extension to use existentials?
13:42:55 <g_cross> CakeProphet:  yes
13:42:56 <jmcarthur> ExistentialQuantification
13:43:07 <jmcarthur> it's a mouthful
13:43:24 <benmachine> hmm, GHCForeignImportPrim
13:43:30 <benmachine> is a --supported-language
13:43:32 <benmachine> I wonder what it does
13:44:47 <g_cross> CakeProphet:  Actually, the real problem that i see with your design it is that it is not nearly enterprisey enough
13:44:59 <g_cross> CakeProphet:  You might want to scale it up, after all.
13:45:03 <BMeph> benmachine: Good plan! Thanks for the reminder.
13:45:15 <g_cross> CakeProphet:  So if I were you, I'd use an SQL database to store the player object
13:45:24 <g_cross> CakeProphet:  And SQL select statements to get the fields that you want.
13:45:43 <g_cross> CakeProphet:  Then you can create additional tables with joins that allow you to figure out what type of value you are getting out.
13:45:54 <g_cross> It really is the most elegent solution to your problem!
13:46:14 <CakeProphet> g_cross:  rofl. That's a great idea.
13:46:46 <CakeProphet> I think the reason this problem is interesting... is that it is essentially an environment for a very domain specific language
13:46:52 <CakeProphet> in which users input commands into a concurrent environment.
13:47:02 * BMeph sometimes worries that Simon Marlow will give in to the silliness and put an extension in GHC for '-XZygohistomorphicPreprommorphisms'
13:47:12 <ddarius> g_cross: Here's one, somewhat clever, approach to it.  Using explicit records would definitely be more flexible (and in many ways preferable) but would have a bit of tedium because you'd have to initialize the records whereas the instances are already written.  The approach in this avoids that (at a loss of flexibility): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27221
13:47:22 <CakeProphet> eventually I'd like to extend the command system to include actual control structures. Using arbitrary parsers and such.
13:47:29 <CakeProphet> like a bash scripting language.
13:47:38 <CakeProphet> *bash-like
13:47:43 <g_cross> CakeProphet:  Then why don't you just pick up an existing scripting language?  :-)
13:47:51 <g_cross> CakeProphet:  Sounds like that would be less work to me than inventing your own.
13:47:56 <CakeProphet> g_cross:  well, because that's boring. :P
13:48:07 <g_cross> CakeProphet:  Fair enough.  :-)
13:48:17 <ddarius> edwardk: You might like the approach in this too: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27221  (could extend to Iso a b instead of just one way)  I haven't tested it, but it should work more or less.
13:48:24 <g_cross> CakeProphet:  Actually, the way you described what you are trying to do sounds a lot like a possible application of Google Wave
13:48:35 <ddarius> BMeph: That does what?
13:48:37 <BMeph> CakeProphet: Better yet: instead of the SQL database, use the 'hmumps' package and put it in a MUMPS database! >;)
13:49:07 <BMeph> ddarius: Absolutely Nothing! (Thus the "silliness" remark.)
13:49:30 <ddarius> BMeph: -You- could hack GHC to add it...
13:49:49 <CakeProphet> g_cross:  it does actually. a roleplaying game could be done with some Wave extensions I think.
13:50:09 <CakeProphet> g_cross:  I'm using the text-based environment because I like the old-school feel. :)
13:50:19 <CakeProphet> none of this Web 2.0 nonsense.
13:51:37 <ddarius> g_cross: The intent is that the value in NumProof will usually be id but we need some way of proving that the existentially quantified type and the external type are the same.  This gives one half of that proof.  Occasionally the other half will be needed as well.
13:51:41 <g_cross> ddarius:  Yeah, your snippet is definitely a much cleaner way of getting the functionality.
13:52:29 <ddarius> (When you make a NumProof value, -you- know that b = a, but the user doesn't know this.)
13:52:30 <BMeph> ddarius: Could, yes. Sounds like something that could lose me my semi-official Procrastinators' Club card. Well, if they ever get around to mailing it to me... ;)
13:54:15 <ddarius> There are other more stringent tricks, most notably using the EQ GADT, data EQ a b where refl :: EQ a a, then data NumProof a = forall b. Num b => NumProof (EQ a b).
13:56:04 <ddarius> This (the EQ) approach has the benefit that it should allow you to immediately use Num operations without having to inject/project the values.
13:56:58 * ddarius needs to try this now.
14:01:59 <CakeProphet> is it possible to make existential types via the type keyword?
14:02:03 <mreh> wat, I've installed yi from hackage, but it hasn't come with the GTK frontend
14:02:08 <mreh> am I missing something?
14:02:10 <CakeProphet> so you'd have one parametric type
14:02:19 <CakeProphet> and then you'd use type to make an existential form of it.
14:02:39 <CakeProphet> data MudData a = a String
14:03:14 <CakeProphet> type PlayerData = forall a. (Show a, Typeable a, Read a) => MudData a
14:05:10 <CakeProphet> er MudData a = MudData a String
14:06:55 <CakeProphet> guess I can find out. :)
14:07:17 <ddarius> CakeProphet: That would be a universal type.
14:07:41 <bos> is there a fast way to round a floating point number? fromIntegral . round is kind of awful
14:07:42 <ddarius> CakeProphet: The answer is no by the way.
14:07:58 <CakeProphet>  Illegal polymorphic or qualified type:
14:08:01 <ddarius> bos: Why?
14:08:05 <mreh> T_T
14:08:11 <CakeProphet> Perhaps you intended to use -XRankNTypes or -XRank2Types
14:08:12 <CakeProphet> did I?
14:08:15 <ddarius> (or at least name it round' = fromIntegral . round)
14:08:20 <bos> ddarius: i'm computing a floating point approximation to an integer-valued function
14:08:22 <ddarius> CakeProphet: No.
14:08:27 <ddarius> CakeProphet: Yes and No.
14:08:32 <bos> ddarius: so if i have a fractional result, i need to round it
14:08:38 <ddarius> bos: I was asking why it is awful.
14:08:44 <bos> ddarius: it's slow.
14:08:44 <CakeProphet> ddarius:  I don't really know what rank N types are.
14:09:04 <ddarius> bos: Are you using Float or Double?
14:09:21 <bos> ddarius: double
14:09:25 <CakeProphet> or newtype instead of type?
14:09:29 <ddarius> CakeProphet: Nested universals.  You'd need it to write the type you are suggesting, but that's not the type you want.
14:09:34 <ddarius> CakeProphet: newtype would work.
14:09:46 <CakeProphet> ddarius:  but... I guess there's no point really.
14:10:03 <ddarius> bos: There might be something in the GHC.* namespaces
14:10:06 <ddarius> It shouldn't be slow though.
14:10:53 <ddarius> God damn defaulting.
14:12:50 <ddarius> g_cross: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27223
14:13:21 <Phyx-> is there really no way to not export instances outside a module?
14:13:46 <ddarius> Phyx-: Not if you want to be able to use them, no.
14:14:52 <Phyx-> ddarius: i have added a library to the GHC which is intended only to be used to compile GHC itself and nothing else. it's a crippled version of the full one
14:15:04 <Phyx-> but now i'm ofcourse getting overlapping instances problem
14:15:13 <Phyx-> since Base now export these instances
14:15:14 <zygoloid> Phyx-: if there were a way, the compiler couldn't check overlaps :)
14:15:47 <ddarius> Phyx-: The usual answer is a newtype wrapper of one sort or another.
14:16:23 <c_wraith> agh.  non-commutative monad transformers.
14:16:30 * c_wraith learns a new direction to stretch his brain
14:16:57 <ddarius> Hmm... this type will be crazy.  Let's see if it works.
14:17:11 <mreh> can I inspect cabal file flags without downloading all of the source?
14:17:17 <Phyx-> ddarius: I never really *got* that solution, you wrap your types in a newtype, great, but then you have to wrap and unwrap everytime you use it
14:18:31 <ddarius> g_cross: Slight simplification: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27224
14:19:32 <ddarius> Phyx-: Yes, but that is only locally.  Your newtype presumably won't be exported.  It sucks to be you but doesn't bother anyone else and it's the only choice you have if you want to reuse things that require instances to be implemented, e.g. Data.Set.
14:20:11 <ddarius> If you don't need to do that, then just don't use an instance.  Write, locally, (+.) = ..., rather than instance Num MyFoo where ... 
14:21:19 <Phyx-> ddarius: how do the newtypes not need to be exported? the instances are defined on that newtype aren't they?
14:22:09 <g_cross> ddarius:  Whoa, that's cool!
14:23:04 <ddarius> Phyx-: Yeah, so?  Your interface is in terms of the wrapped type.  You continue using that interface, you just wrap and unwrap internally.
14:26:14 <Phyx-> ddarius: do you have an example? If i say define a class that defines a function foo. i then create an instance for Foo (Wrapped Int) every time I want to use that instance I need wrap and unwrap Int. that's not just locally. That's only sufficient if locally is the only place I use this new instance.
14:26:38 <Phyx-> guess I could wrap the once I use in GHC but then I wouldn't be able to generate them using the same tool
14:26:46 <Phyx-> sucks to be me again i suppose :/
14:27:44 <ddarius> Phyx-: I'm not sure if your problem is that you have multiple modules and you want to share this instance over them but not with anyone else, or that you somehow want this instance to be in the interface and not in the interface somehow.
14:28:20 <CakeProphet> :t fmap
14:28:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:28:29 <ddarius> Phyx-: If its the former, then yes, you have to export the newtype so the other modules can wrap/unwrap but that's only minor namespace pollution to the final end-user at worst.
14:30:24 <Phyx-> ddarius: the problem is basically this: I have a library which a version of is used internally in GHC when compiled. This version is a cripled version of the full one because I didn't actually want it to ship as part of GHC, just to be used when compiling it. Unfortunately Base now rexports these instances
14:30:41 <Phyx-> which are pretty general, like (Foo a, Foo b) => Foo (a, b)
14:31:04 <Phyx-> I guess one solution would be to just make it a part of ghc
14:31:14 <mreh> how does "fix f = f (fix f)" have type :: a ?
14:31:23 <mreh> where f :: a -> a
14:31:31 <ddarius> How does it not?
14:31:35 <lispy> mreh: Because f is applied to something of type a :)
14:31:55 <mreh> i understand the fixpoint is type a
14:32:03 <lispy> mreh: if it makes you feel any better, the definition you gave doesn't type check in haskell
14:32:03 <mreh> oh right
14:32:09 <mreh> no?
14:32:12 <lispy> > let fix f = f (fix f)
14:32:13 <lambdabot>   not an expression: `let fix f = f (fix f)'
14:32:22 <lispy> > let fix f = f (fix f) in 1
14:32:23 <lambdabot>   1
14:32:27 <lispy> hmm
14:32:27 <mreh> that makes me feel a bit better
14:32:47 <lispy> Maybe it does type check with let
14:32:55 <Lajla> lispy, traitor to The Cause
14:32:56 <mreh> @src fix
14:32:56 <lambdabot> fix f = let x = f x in x
14:33:00 <lispy> I know there is at least one way to express it that doesn't type check
14:33:18 <ddarius> lispy: His definition is using the built-in recursion of Haskell.  If he tried to do a combinator version that didn't use recursion, it wouldn't type check.
14:33:27 * Phyx- mumbles "what a pain" and heads to recompile GHC
14:33:50 <soupdragon> is there an equivalent of taylor series for haskell functions?
14:34:07 <Lajla> ddarius, is it provable actually that it's impossible to define a combinator that diverges in Haskell without using the fact that let is actually let rec?
14:34:09 <lispy> :t fix $ \fix f -> f (fix f)
14:34:11 <lambdabot> forall t. (t -> t) -> t
14:34:11 <mreh> yes! the taylor series
14:34:25 <ddarius> Not really.  There arguably aren't even for all real to real functions.
14:34:52 <ddarius> Lajla: No, because there are other forms of built-in recursion such as using a type level recursion.
14:35:17 <Phyx-> GHC will always pick the newest version of a libary right?
14:35:18 * illissius still doesn't get how the let x = f x in x thing works :\
14:35:28 <mreh> it's a circular definition
14:35:34 <ddarius> soupdragon: I'm not really sure what you are expecting though.
14:35:54 <Lajla> ddarius, how does that work?
14:36:04 <lispy> mreh: this is what I was thinking of: http://r6.ca/blog/20060919T084800Z.html
14:36:07 <Lajla> I want my destinction between let and let rec.
14:36:16 <mreh> x = f x => f (f x) => f (f (f x)) etc..
14:36:18 <ddarius> illissius: Do you understand how let x () = \() -> f (x ()) in x works ?
14:36:20 <zygoloid> illissius: imagine we draw a box on a piece of paper and label it x. inside that box we write its value, the function f applied to an arrow pointing at that box.
14:36:29 <Lajla> It happens quite often that I do (let ((xs (cdr xs))) ...) in Scheme
14:36:47 <ddarius> Lajla: See what lispy just posted.
14:37:08 <ddarius> Lajla: You can use lambda or abuse do-notation to get that.
14:37:25 <ddarius> However, shadowing variable names is usually just a bad idea.
14:37:37 <ddarius> It definitely decreases maintainability.
14:38:01 <Lajla> ddarius, ahhh
14:38:35 <Lajla> ddarius, I beg to differ, it is a very good idea often, that is why we create local bindings.
14:39:07 <illissius> ddarius: where does f come from in that example?
14:39:46 <ddarius> illissius: It's an arbitrary function (of appropriate type) or a parameter (add a \f -> to the front).
14:40:00 <illissius> ok
14:40:15 <zygoloid> illissius: also pretend the "\() -> " isn't there.
14:41:03 <ddarius> Having shadowing -available- is a good idea.  Intentionally (ab)using it is not.  It means the reader can easily mix up the bindings.
14:41:34 <lispy> yeah, and the example you gave is just a pattern match in Haskell
14:41:37 <Lajla> ddarius, what's abuse about that?
14:41:46 <lispy> (_:xs)
14:42:11 <mreh> so in terms of types, fix is a bit of magic?
14:42:18 <lispy> mreh: nope
14:42:20 <zygoloid> mreh: how so?
14:42:34 <mreh> oh I get it
14:42:48 <mreh> fix f :: a, so fix f :: a, so fix f :: a etc...
14:42:52 <zygoloid> in terms of curry-howard, it's unsound, but *shrug*
14:42:52 <ddarius> > let boundTo v f = f v in 3 `boundTo` \x -> (x+1) `boundTo` \x -> x+1
14:42:53 <lambdabot>   5
14:43:17 <ddarius> zygoloid: Not unsound, inconsistent.
14:43:19 <lispy> mreh: The Y combinator can't be typed by H-M as it is expressed.  It's in the class of valid programs that gets rejected
14:43:29 <zygoloid> ddarius: yeah, i thought that sounded like the wrong word
14:43:42 <lispy> mreh: but there are equivalent programs that can be accepted
14:43:45 <Tomsik_> You want system F :p
14:43:57 <ddarius> mreh: Not magic per se, just an axiom that (usually) immediately creates inconsistency (because a -> a is almost always an theorem as well).
14:44:11 <lispy> Tomsik_: ah, should I have said System F instead of H-M?
14:44:27 <Tomsik_> No, I mean that you can type Y in system F
14:44:45 <Tomsik_> and as far as I know, haskell is getting closer and closer to it
14:44:46 <ddarius> fix :: (a -> a) -> a, "Given that if A were provable we could prove A then A is provable."
14:45:11 <ddarius> lispy: Type systems were invented specifically to bar such examples.
14:45:29 <ddarius> Tomsik_: Haskell is beyond System F in several ways.
14:45:29 <lispy> (a -> a) == "if A were provable we could prove A"
14:45:30 <mreh> exciting
14:45:42 <mreh> I'm going to get Haskell road
14:46:05 <Tomsik_> ddarius: like haskell can point to general type of a term? :p
14:46:20 <Tomsik_> which is as far as I remember undecideable in system F
14:46:37 <ddarius> (Admittedly, I'm using "Haskell" as GHC Haskell here.)
14:46:49 <mreh> mathoverflow is great fun, it's like "my eleven year old was saying today that he corrected his math teacher today... blah blah blah"
14:47:05 <mreh> what they don't say is that their eleven year old is socially maladjusted
14:47:40 <ddarius> mreh: Assuming that were true, what makes you think the parents would be able to tell.
14:48:13 <Heffalump> mreh: is that a deduction you made from that statement, or something based on external knowledge?
14:48:22 <lispy> mreh: What I like about the type of fix is that it says general recursion is absurdity :)
14:48:38 <ddarius> lispy: Not by itself.
14:48:43 <mreh> lispy: yeah, it's pretty absurd to me so far
14:49:06 <soupdragon> math overflow is not like that
14:49:12 <mreh> Heffalump: anecdotal experience
14:49:29 <mreh> evidence *
14:49:39 <monochrom> @type fix (id :: eleven_year_olds_socially_maladjusted -> eleven_year_olds_socially_maladjusted)
14:49:40 <lambdabot> forall a. a
14:49:45 <monochrom> darn
14:49:50 <Tomsik_> If you don't like recursion, go back to Turing machines :p
14:49:51 <ddarius> Admittedly, a logic not that does not prove A -> A would be quite a strange (and potentially interesting) logic to work with.
14:50:14 <lispy> ddarius: And there are specific cases where general recursion is perfectly fine even in the presence of things that allow you to derive inconsistencies
14:50:22 <soupdragon> and you seem to be conflating 'eats whatever bullshit is spoonfed to them' with 'socially maladjusted'
14:50:57 <ddarius> At any rate, discussions of what MathOverflow is or is not are probably better held on #haskell-blah.
14:50:58 * lispy yawns and casually points towards #haskell-blah ;)
14:51:03 <mreh> oops
14:51:23 <mreh> I did it again
14:51:41 <lispy> It happens.  We're human.  The trick is to notice and move the conversation
14:52:14 <Tomsik_> ddarius: then you can't have rule A |- B ---> |- A -> B, which is rather weird
14:52:14 <mreh> what normally happens is the conversation continues regardless, or fizzles out because people have lost interest
14:52:15 <Heffalump> mreh: I was correcting Maths teachers at <11 and I claim not to be socially maladjusted :-)
14:52:21 <Heffalump> (then or now)
14:52:27 <augur> mreh: you are not brittany spears :|
14:52:40 * Heffalump notes the redirection and follows it
14:52:55 <soupdragon> Tomsik_: I think htat's called deduction theorem, and proving it is nontrivial
14:52:56 * lispy has never met Heffalump face-to-face but would assume he is NOT socially maladjusted from internet conversations
14:53:27 <illissius> hmm, so let x = f x in x basically makes a thunk which, when the evaluator goes to evaluate it, keeps generating new thunks rather than collapsing to a value? (in the case where f is something like (1:) and not const etc.)
14:53:55 <Heffalump> illissius: in the case where f is (1:) it'll make a thunk that produces a "useful" value, i.e. a cons cell
14:53:58 <zygoloid> illissius: no. it makes a thunk which contains a pointer to that same thunk.
14:54:29 <mreh> hey, did I say people can't change?
14:54:57 <zygoloid> illissius: fix (1:) is operationally: let <thunk> = 1 : <thunk> in <thunk>
14:55:14 <zygoloid> that is, the tail of the cons of the list is a pointer back to that same list
14:55:30 <Heffalump> mreh: "then or now"
14:56:09 <tommd1> Can cabal run derive or DriFT automatically?
14:57:45 <augur> anyone have any references for how Clean's evaluations work? wiki says its based on graph rewriting and im curious how this happens
14:58:43 <illissius> zygoloid: so whenever it wants to get the value of the thunk, it follows the pointer and arrives back at the same thunk?
14:59:16 <zygoloid> illissius: yes. but in this case the thunk is already evaluated (since you found it at the tail of itself!)
15:00:07 <illissius> hmm, ok. I think I sorta-halfway understand it now. thanks :)
15:00:42 <g_cross> > fac = fix (\f n -> if n == 0 then 1 else f (n-1) * n)
15:00:43 <lambdabot>   <no location info>: parse error on input `='
15:00:48 <g_cross> > let fac = fix (\f n -> if n == 0 then 1 else f (n-1) * n)
15:00:48 <lambdabot>   not an expression: `let fac = fix (\f n -> if n == 0 then 1 else f (n-1) * ...
15:01:00 <g_cross> > fix (\f n -> if n == 0 then 1 else f (n-1) * n) 4
15:01:00 <lambdabot>   24
15:01:20 <g_cross> illissius:  If it helps, you can think of fix as a way of giving your functions the power to recurse
15:01:42 <g_cross> illissius: the snippet I just types defines the factorial function via. fix
15:02:57 <g_cross> illissius:  by feeding the function into itself as the first parameter, fix makes the function call itself recursively
15:03:01 <illissius> g_cross: yeah, I've seen that before... understanding fix itself is a separate question from understanding what the heck 'let x = f x in x' does :) (both are still in progress.)
15:03:29 <g_cross> illissius:  Fair enough.  :-)
15:05:06 <ClaudiusMaximus> i think my JobQueue module using nested MVars has too much overhead - the mean time for 'getNextJob' is 10% of the time for 'computeJob'
15:08:21 <danderson> is there a way to set environment variables as well as read it?
15:08:29 <danderson> System.Environment seems to be read-only
15:11:26 <ClaudiusMaximus> i think (portably) you can only set environment variables when creating child processes, at least that's what osmosed into me from here
15:12:11 <ddarius> @hoogle withArgs
15:12:11 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
15:12:22 <danderson> ah, hmm
15:12:34 <danderson> I wonder if that does what I need. I'll investigate. Thanks for the reference!
15:12:43 <benmachine> you can set env vars on posix systems at least
15:12:43 <ddarius> That function is not the same as setting them, but may suffice for your purposes.
15:13:09 <benmachine> :t System.Posix.setEnv
15:13:10 <lambdabot> String -> String -> Bool -> IO ()
15:14:11 <ddarius> What's the Bool for?
15:14:25 <benmachine> it's to make people go and look at the docs
15:14:34 <danderson> ddarius: well, I also need them to be set for child processes (as well as for the current process's getArgs)
15:14:45 <danderson> aah, System.Posix
15:14:46 <danderson> excellent
15:15:03 <danderson> ddarius: the bool is probably the override parameter to the setenv libc call
15:15:05 <ddarius> I'm not sure if withArgs will do that, but at least it could conceivably do that structurally.
15:15:12 <danderson> looks like it's a straight binding from the posix APIs
15:16:01 <benmachine> you pass args to child processes directly when you start them, don't you?
15:16:15 <benmachine> danderson: be aware that System.Posix is not available on windows
15:16:31 <ddarius> @hoogle runInteractiveProcess
15:16:32 <lambdabot> No results found
15:16:33 <danderson> benmachine: that's cool, it's for my xmonad config.
15:16:42 <benmachine> oh right
15:16:50 <danderson> and I run no windows systems other than vanilla VMs for dev testing
15:17:26 <benmachine> if we're talking about running subprocesses, you can probably control the environment for them directly
15:18:12 <danderson> the specific use case I have is that I'm trying to integrate xmonad and gnome for my laptop (because gnome does pretty well with power and network management)
15:18:51 <danderson> my .xsession script I use for my desktop exports PATH and various other things, so that my custom installs are available via xmonad's keybindings
15:19:43 <danderson> if I integrate with gnome using the fancy integration described on the xmonad wiki, I don't have a script where I can export this stuff
15:19:55 <danderson> so I need to figure out how to do it from xmonad.hs directly
15:19:59 <benmachine> ah
15:20:05 <c_wraith> gah.  I got my non-commutative monad stack backwards before. :(
15:20:07 <danderson> but System.Posix.setEnv sounds like what I need
15:20:37 <ddarius> c_wraith: I usually mentally unwrap it and consider how the effects will interact.
15:21:31 <c_wraith> @unmtl ListT IO Int
15:21:31 <lambdabot> IO [Int]
15:21:37 <benmachine> ListT is broken anyway
15:21:47 <benmachine> sooort of
15:21:47 <c_wraith> well, I'm not using ListT
15:21:56 <c_wraith> It just demonstrates it..
15:22:09 <benmachine> @unmtl StateT s Maybe a
15:22:10 <lambdabot> s -> Maybe (a, s)
15:22:44 <benmachine> @unmtl MaybeT (State s) a
15:22:44 <lambdabot> s -> (Maybe a, s)
15:22:48 <illissius> @unmtl ReaderT Int (StateT String Identity) Char
15:22:48 <lambdabot> Int -> String -> (Char, String)
15:22:50 <zygoloid> benmachine: well, it depends /which/ ListT :)
15:23:02 <benmachine> zygoloid: true
15:23:10 <benmachine> mtl and transformers both have broken ones I believe
15:23:47 <c_wraith> ddarius, it's just that I unwrapped it backwards.  I figured the outer transformer would be the outer data type, and it wasn't.
15:25:14 <c_wraith> Also, MaybeT would be appropriate here.  Hmm.
15:26:11 <c_wraith> Why isn't MaybeT in mtl or transformers?
15:26:48 <benmachine> it's in transformers isn't it?
15:26:54 <benmachine> or so I thought
15:26:55 <benmachine> well anyway
15:26:58 <benmachine> @hackage MaybeT
15:26:58 <lambdabot> http://hackage.haskell.org/package/MaybeT
15:27:31 <c_wraith> I'm using transformers already, so it'd be MaybeT-transformers
15:27:36 <benmachine> oh
15:27:40 <benmachine> right ok
15:27:50 <c_wraith> It's not that I can't find it.. I just wonder why it's not in the package
15:29:13 * illissius brings http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/#comment-655 to the attention of people who were wondering about it.
15:30:46 <Kaidelong> is there any reason why people who are introducing co-recursion tend to point to "fibs = 1 : 1 : zipWith fibs (tail fibs)" as opposed to "fibs = 1 : scanl 1 fibs"
15:30:55 <Kaidelong> err
15:31:04 <Kaidelong> "fibs = 1 : scanl (+) fibs"
15:31:08 <Kaidelong> forgot it with the zipWith too
15:31:41 <mauke> because scanl is hard
15:31:46 <sproingie> i think the zipWith is more obvious to the uninitiated
15:31:52 <aavogt> @type scanl (+) [1..]
15:31:53 <lambdabot> forall t. (Num [t], Num t, Enum t) => [[t]] -> [[t]]
15:31:58 * Kaidelong always found it the opposite, oh well
15:32:02 <aavogt> you're missing an argument
15:32:28 <Kaidelong> yes I am
15:32:29 <Kaidelong> again
15:32:35 <mauke> because scanl is hard
15:32:48 <Kaidelong> > fibs = 1 : scanl (+) 1 fibs
15:32:49 <lambdabot>   <no location info>: parse error on input `='
15:32:51 <Kaidelong> oh right
15:33:04 <Kaidelong> > let fibs = 1 : scanl (+) 1 fibs in fibs
15:33:06 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
15:34:10 <Kaidelong> hmm
15:34:11 <illissius> Kaidelong: btw, i suspect the main reason people point to the zipWith version is that that's the one they were pointed to themselves back in the day
15:34:18 <mauke> > iterate (round . ((0.5 + sqrt 1.25) *) . fromInteger) 1
15:34:20 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
15:34:35 <aristid> @src scanl
15:34:35 <lambdabot> scanl f q ls = q : case ls of
15:34:35 <lambdabot>     []   -> []
15:34:35 <lambdabot>     x:xs -> scanl f (f q x) xs
15:35:38 <Kaidelong> I suppose if you're just starting out haskell zipWith is a more useful function than scanl in terms of how often you use it?
15:35:47 <aristid> > scanl (+) 1 [1..]
15:35:47 <Kaidelong> I was already familiar with scanl through Seq.scan
15:35:47 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,...
15:35:57 <Kaidelong> but F# has nothing like zipWith
15:36:02 <zygoloid> > map fst $ iterate (\(a,b) -> (b,(a+b))) (0,1)
15:36:03 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:36:07 <mauke> zipWith is just multimap?
15:36:12 <mauke> s/\?//
15:36:20 <aavogt> it's likely to have zipWith called map
15:36:32 <Kaidelong> like, map2?
15:36:38 <Kaidelong> but then you have to zip first, right?
15:36:46 <mauke> what
15:36:47 <Kaidelong> wasn't there a slight loss of efficiency?
15:36:54 <illissius> i think zipWith and scanl are about even in terms of 'difficulty of understanding' for me fwiw
15:37:13 <aristid> illissius: zipWith is easier for me
15:37:14 <illissius> if zip and foldl are both 'level 1', then zipWith and scanl are both 'level 2'
15:37:37 <mauke> I wouldn't put zip and foldl on the same level
15:37:37 <Kaidelong> oh okay
15:37:45 <Kaidelong> Seq.map2 is identical to zipWith
15:37:48 <aristid> :t \f -> map (uncurry f) . zip
15:37:49 <lambdabot>     Couldn't match expected type `[(a, b)]'
15:37:49 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
15:37:49 <lambdabot>     Probable cause: `zip' is applied to too few arguments
15:37:51 <Kaidelong> thank you aavogt
15:37:54 <zygoloid> zipWith f xs ys is just map (uncurry f) (zip xs ys)
15:39:30 <Kaidelong> hmm, someone in this channel told me (when I was making code that did a zip and then a map) to use zipWith instead because it was "more efficient"
15:39:44 <Kaidelong> I guess that was wrong then
15:39:57 <micahjohnston> well with fusions in the compiler, woudln't it be the same?
15:40:02 <micahjohnston> or am I completely spewing nosense :P
15:40:16 <monochrom> but perhaps someone is using hugs
15:40:18 <aristid> :t \f -> ((.).(.)) (map (uncurry f)) zip
15:40:19 <lambdabot> forall c a b. (a -> b -> c) -> [a] -> [b] -> [c]
15:40:24 <aristid> :t zipWith
15:40:25 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:40:42 <aristid> illissius: see how easily you can create zipWith from zip? :D
15:41:44 <aavogt> why should foldl and scanl be on different levels, aristid?
15:42:04 <aristid> aavogt: i didn't say that. i just said that scanl is confusing for me
15:42:53 <aavogt> I can't read. That was for illissius
15:43:05 <Twey> scanl confuses me more than foldl does, too
15:43:16 <Twey> Probably just because I see and use folds more
15:43:18 <aristid> aavogt: foldl for me is just \f i xs -> foldr (flip f) i (reverse xs)
15:43:25 <FunctorSalad> hehe never took the time to parse scanl's type
15:43:28 <FunctorSalad> @ty scanl
15:43:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
15:43:42 <FunctorSalad> oh, not the one I thought
15:43:52 <mauke> :t mapAccumL
15:43:53 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:43:56 <FunctorSalad> that one
15:43:57 <FunctorSalad> ;)
15:44:10 <Twey> scanl is just foldl, but you keep all the intermediate results as well as using them in the next calculation
15:44:13 <Twey> I guess
15:44:18 <FunctorSalad> but maybe it's what I needed all these times I did recursion with accumulator
15:44:27 <FunctorSalad> ah
15:44:36 <Twey> :t scanl
15:44:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
15:44:38 <Twey> :t foldl
15:44:39 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:44:41 <FunctorSalad> > scanl (:) [] "abcde"
15:44:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:44:43 <aristid> > foldl (+) 1 [1,2,3]
15:44:44 <lambdabot>   7
15:44:46 <Twey> It's just -> [a] instead of -> a
15:44:52 <mauke> > scanl f z [1,2,3] :: [Expr]
15:44:52 <aristid> > scanl (+) 1 [1,2,3]
15:44:53 <lambdabot>   [1,2,4,7]
15:44:53 <lambdabot>   [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3]
15:45:22 <aristid> mauke: yay Expr
15:45:34 <FunctorSalad> yay free things
15:45:50 <benmachine> :t \f -> scanl (f . fst)
15:45:52 <lambdabot> forall b a b1. (a -> b -> (a, b1)) -> (a, b1) -> [b] -> [(a, b1)]
15:46:10 <FunctorSalad> (I wonder how far you can take evaluation of haskell at a 'free' type or bunch of types)
15:46:11 <aristid> @pl \f -> scanl (f . fst)
15:46:11 <lambdabot> scanl . (. fst)
15:46:18 <slade118> :i Expr
15:46:20 <slade118> bah
15:46:26 <slade118> is it some extension?
15:46:31 <benmachine> no
15:46:32 <mauke> no, a type
15:46:43 <benmachine> @hackage show
15:46:43 <slade118> where does it live?
15:46:43 <lambdabot> http://hackage.haskell.org/package/show
15:46:46 <lispy> slade118: it's just a library that lambdabot uses
15:46:54 <monochrom> some lib. simple-reflect
15:46:56 <om-foxy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27226#a27226
15:47:03 <benmachine> or
15:47:05 <benmachine> http://hackage.haskell.org/package/simple-reflect
15:47:07 <illissius> aavogt: no real well-thought-out justification, just a feeling. zipWith and scan are slightly-more-complicated versions of zip and fold, respectively. (as for fold, as 'combine a list of values' i think it's fairly intuitive as long as you don't get into left folds vs. right folds...)
15:47:15 <slade118> cool, thanks
15:47:40 <FunctorSalad> Expr as it is probably wouldn't properly support equality
15:47:50 <FunctorSalad> which would have to be formal-proposition-valued, not bool
15:48:07 <FunctorSalad> and other typeclasses, like ord
15:48:17 <lispy> FunctorSalad: well, we usually mean just structural equality, right?
15:48:21 <Kaidelong> so if foldr is a catamorphism, what is scanl?
15:48:30 <zygoloid> om-foxy: you're going to need to write some code to do file type sniffing. why not have that code return the right instances?
15:48:33 <FunctorSalad> (still thinking about the problem of evaluating polymorphic functions in full generality)
15:48:53 <FunctorSalad> lispy: that works for basic expressions, but not once you abstract out variables
15:49:11 <FunctorSalad> \x -> x + x vs \y -> y + y
15:49:14 <FunctorSalad> should be equal
15:49:19 <om-foxy> zygoloid: more information, please :) (How to /return right instance/?)
15:49:30 <lispy> FunctorSalad: well, those are alpha equivalent :)
15:49:50 <FunctorSalad> lispy: exactly, but how'd you check it given just two functions (Expr -> Expr)?
15:49:52 <Kaidelong> I suppose scanl is actually defined co-recursively so a recursive form doesn't really help?
15:50:00 <benmachine> FunctorSalad: pass them both x
15:50:02 <lispy> I should probably be more precise and say something like, "structurally equal under alpha conversion"
15:50:04 <aristid> :t \x :: Expr -> x + x
15:50:06 <lambdabot>     Illegal result type signature `Expr'
15:50:06 <lambdabot>       Result signatures are no longer supported in pattern matches
15:50:06 <lambdabot>     In a lambda abstraction: \ x :: Expr -> x + x
15:50:06 <benmachine> you get x + x in both cases
15:50:08 <FunctorSalad> hmm though admittedly functions aren't Eq in normal haskell either ;)
15:50:17 <FunctorSalad> benmachine: infinitely many inputs though
15:50:35 <benmachine> FunctorSalad: depends how picky you are
15:50:38 <FunctorSalad> can't rule out that one is \x -> if x==999 then x+x else x-x
15:50:43 <monochrom> you're talking about Eq for Expr, right? you are not talking about Eq for (Expr->Expr), right?
15:51:08 <FunctorSalad> monochrom: the latter, but for some reason I think one would need the latter at some point?
15:51:37 <FunctorSalad> (the original problem being evaluation of polymorphic functions in full generality; you get to choose the type)
15:51:39 <zygoloid> om-foxy: well, a GADT is often a reasonable way of passing instances around at runtime.
15:52:05 <FunctorSalad> like mauke did with the scanl
15:52:41 <zygoloid> om-foxy: data Image where Image :: (Renderable i, Binary i) => i -> Image
15:52:42 <soupdragon> hmmm
15:53:00 <benmachine> FunctorSalad: you could assume that exprs aren't inspected, because pretty much the only way of doing so is to check their show, right?
15:53:01 <FunctorSalad> full generality = can reconstruct the definition, I suppose
15:53:04 <benmachine> which is sneaky
15:53:08 <benmachine> and therefore doesn't happen
15:53:17 <zygoloid> om-foxy: now if you write: case myImage of Image i -> doStuff, then in doStuff you can use the Renderable and Binary instances.
15:53:19 <mauke> > x == var "x"
15:53:21 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:53:21 <lambdabot>         against inferred ...
15:53:29 <benmachine> :t var
15:53:30 <lambdabot> forall a. String -> Sym a
15:53:33 <benmachine> hrm
15:53:38 <FunctorSalad> benmachine: you're allowed to make up your own Expr type for what I had in mind
15:53:43 <benmachine> :t fun
15:53:45 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
15:53:53 <benmachine> x == expr (fun "x")
15:53:57 <benmachine> > x == expr (fun "x")
15:53:58 <FunctorSalad> as long as variables aren't abstracted over, you could just do structural comparison, indeed
15:53:59 <lambdabot>   True
15:55:33 <zygoloid> om-foxy: when you detect an image format you can produce (Image (undefined :: Image1 Foo)), or you could integrate the image decoding into the sniffing and produce (Image yourImage)
15:55:48 <zygoloid> either way, the Renderable instance will be grabbed at that point and passed on for your rendering code to use
15:56:07 <FunctorSalad> say the polymorphic function to be probed is f :: Eq a => [a] -> [a] -> Int
15:56:50 <FunctorSalad> won't we run into the problem that our expressions are forced to have equality evaluating to *Bool*, rather than to a formal expression type that keeps the full generality?
15:57:15 <zygoloid> FunctorSalad: yes, we will.
15:57:32 <zygoloid> > x^x
15:57:38 <lambdabot>  Terminated
15:57:38 <FunctorSalad> (like: (==) a b = (:==:) a b)
15:57:44 <zygoloid> ^ this doesn't halt because x is never 0
15:57:54 <om-foxy> zygoloid:  Don't GADT's have to know all the image types at compilation?  I would like pluggable modules so that the main program, already running, can dynamically load the appropriate renderer.
15:57:55 <FunctorSalad> for a hypothetical Eq that allows arbitrary return type, not bool
15:58:02 <soupdragon> is there any way to make 3 read as 1 + (1 + (1 + 0)) ?
15:58:20 <zygoloid> om-foxy: no. you only need the instances at the point when you create the Image value. if that happens in a plugin then you're fine.
15:58:23 <FunctorSalad> sure, make your own instance? soupdragon 
15:58:45 <soupdragon> data N a where Z :: N TZ ; S :: N a -> N (TS a)
15:58:49 <soupdragon> can we have a num instance for this?
15:58:50 <FunctorSalad> though it seems to be a Show issue
15:59:00 <soupdragon> so that 3 :: N (TS (TS (TS TZ))) works
15:59:27 <zygoloid> om-foxy: it's not really a GADT, it's just an existential, but GADT syntax is so much nicer... :)
16:00:00 <FunctorSalad> soupdragon: hmm, for the existential
16:00:18 <FunctorSalad> any single type isn't closed under.. pretty much anything ;)
16:00:34 <FunctorSalad> but "AnyN = forall a. N a => AnyN a" should work
16:00:57 <soupdragon> oh I'll give that a shot
16:01:07 <om-foxy> zygoloid, I'm not sure I'm following yet.  In the toy example, Image1 a could be Image1 Float or Image1 Double, as determined while reading the file.  Maybe even some esoteric Image1 24BitFloat that gets written while the main program is already running...
16:01:17 <FunctorSalad> I'm assuming you want (+) to be the usual addition, soupdragon 
16:01:39 <FunctorSalad> then (+) :: TS TZ  -> TS TZ -> TS (TS TZ)
16:01:46 <FunctorSalad> not homogenous as required by Num
16:02:36 <om-foxy> zygoloid, in the toy example, in ghc, I can't have a method that in some cases returns a Float and others a Double?
16:02:51 <zygoloid> om-foxy: the idea is that your application calls a plugin, which packages up a type and some instances inside an existential and returns them. the application can then pull the existential apart and use the instances inside.
16:03:17 <zygoloid> the application doesn't need to know which type is going to be inside the existential in advance.
16:03:46 <om-foxy> okay, but can I dynamically load a class method?
16:04:00 <zygoloid> how do you mean? change a class at runtime?
16:04:11 <FunctorSalad> classes don't exist at runtime in the first place :)
16:04:27 <FunctorSalad> you could load functions though
16:04:39 <FunctorSalad> (dictionaries exist though)
16:04:44 <om-foxy> FunctorSalad: that's the point of this exercise, to make methods runtime loadable.
16:05:33 <FunctorSalad> a new method as if the class declaration had an extra method?
16:06:16 <FunctorSalad> as I understand ghc internals, some uses of typeclasses will leave absolutely no trace at runtime
16:06:35 <FunctorSalad> (if it's known at compile time what the instance is, it just gets baked in)
16:07:00 <monochrom> don't try to load a type class. do try to load a new module wtih a new value that implements the type class methods differently.
16:08:01 <FunctorSalad> (it=the implementation)
16:08:02 <monochrom> type class is not java class
16:08:29 <FunctorSalad> yeah, it's as-early-dispatch-as-possible
16:08:44 <FunctorSalad> someone better at ghc internals correct me if I'm wrong...
16:09:11 <FunctorSalad> to get more dynamic behaviour, you'd use an existential wrapper
16:11:12 <monochrom> it helps to learn a foreign natural language before learning a foreign programming language. to kill the presumption that there exists 1-1 onto mappings at all.
16:12:39 <om-foxy> The typechecker does dictionary lookup at compile time to determine which instance method to use.  What if the correct instance is not known at compile time (I'm thinking here about dynamically loading modules, and dynamically loading functions such as (Binary a, Renderable a) => a -> IO ().  Which is the other end of the pathological Binary a => FilePath -> IO a.   (e.g. functions render...
16:12:41 <om-foxy> ...and decodeFile).
16:13:24 <ezyang> I’m a little annoyed by the fact that if I’m in some arbitrary MonadIO m, and then I use withForeignPtr, there’s no easy way to be “in m” inside the foreign pointer block. 
16:13:28 <ezyang> Any convenient ways around this? 
16:14:14 <bos> ezyang: nope
16:14:20 <ezyang> Maybe I can do IO (m a) ? 
16:14:31 <ezyang> bos: :-( 
16:14:52 <ezyang> (IO (m a) is not correct, btw) 
16:15:21 <zygoloid> om-foxy: the typechecker does dictionary lookups at compile time to determine which dictionary to pass around, but the passing around of dictionaries often happens at runtime
16:15:54 <om-foxy> exyang: do { x <- liftIO $ withForeignPtr p f ; y <- g x ; liftIO $ withForeignPtr p (h y) } 
16:16:08 <om-foxy> zygoloid, I thought the dictionary got compiled away?
16:16:16 <zygoloid> om-foxy: no, not in general.
16:16:38 <om-foxy> zygoloid, oh.
16:16:46 <zygoloid> if it's statically known which dictionary will be used, the method will usually get called directly
16:17:19 <om-foxy> but all types (normally) are known at compile time.  Haskell is a statically checked language.
16:17:31 <ezyang> om-foxy: That doesn’t... seem quite right... 
16:18:00 <zygoloid> yes, but knowing types isn't enough to know which dictionary to use. in 'sort :: (Ord a) => [a] -> [a]', we know the argument is of type [a] but that doesn't tell us which dictionary to use.
16:18:24 <monochrom> ezyang: just two days go I found http://hackage.haskell.org/package/MonadCatchIO-mtl-foreign and very happy. there is also http://hackage.haskell.org/package/MonadCatchIO-transformers-foreign
16:18:25 <om-foxy> I disagree.
16:18:46 <zygoloid> om-foxy: there /is/ no "Ord a" dictionary.
16:19:19 <om-foxy> zygoloid, in any given program, I will have a finite set of types, checked, and then linked to the appropriate method.
16:19:41 <zygoloid> om-foxy: false. a program can use an unbounded number of types.
16:19:41 <ezyang> monochrom: Fancy! 
16:19:52 <dnquark> ...can anyone here help me install the dbus package?...
16:19:52 <ezyang> Oh, they use touch* to get around it. That... works! 
16:20:00 <om-foxy> "in any given program" 
16:20:24 <dnquark> i'm having a hell of a time getting xmonad to deal with import DBus.Message...
16:20:37 <om-foxy> hm...
16:21:05 <dschoepe> Is it possible to solve Einstein's logic puzzle at the type level? I tried to encode all the relations as type classes+fundeps and the given information as instance declarations, but that way I end up with conflicting functional dependencies.
16:21:19 <zygoloid> > let f :: Show a => Integer -> a -> String; f 0 a = show a; f n a = f (n - 1) [a] in f 4 'x'
16:21:20 <lambdabot>   "[[[\"x\"]]]"
16:21:40 <om-foxy> > sort [1,76,4,7,8,10]
16:21:41 <lambdabot>   [1,4,7,8,10,76]
16:21:43 <zygoloid> ^^ suppose i hook that up to a main which reads an Integer from the user and then calls f on it. how many types does my program use? how many Show instances?
16:22:14 <ezyang> Here’s a cute way of doing it alternatively, monochrom: 
16:22:28 <zygoloid> om-foxy: there are programs which at runtime use an unbounded number of distinct types and instances.
16:22:30 <ezyang> return^ :: Monad m => a -> IO (m a) 
16:22:34 <om-foxy> well the use of f gets specialised to use instances for Integers.  You determine what types the user can input at compile time.
16:22:36 <ezyang> return^ = return . return 
16:22:56 <zygoloid> om-foxy: read the code more closely. a could be Char or [Char] or [[Char]] or [[[Char]]] or ...
16:22:56 <ezyang> (>>=^) :: IO (m a) -> (a -> IO (m b)) -> IO (m b) 
16:23:05 <ezyang> x >>=& f = x >>= (>>= f) 
16:23:06 <ezyang> :-) 
16:23:12 <ezyang> *>>=^ 
16:23:17 <Kaidelong> looking at some of my old code, I'm starting to think that function definitions should generally be less than 6 lines
16:23:31 <om-foxy> zygoloid:  But that type _must_ be fixed by the missing type annotation.
16:23:36 <Kaidelong> otherwise you're probably working at the wrong level of abstraction and inviting bugs and painful debugging
16:23:38 <zygoloid> om-foxy: no, it's not.
16:23:50 <zygoloid> om-foxy: seriously, i just ran it. look at the output.
16:24:00 <om-foxy> zygoloid, which code?  ;)
16:24:07 <zygoloid> > let f :: Show a => Integer -> a -> String; f 0 a = show a; f n a = f (n - 1) [a] in f 20 'x'
16:24:09 <lambdabot>   "[[[[[[[[[[[[[[[[[[[\"x\"]]]]]]]]]]]]]]]]]]]"
16:24:19 <zygoloid> om-foxy: ^^ that code
16:24:52 <om-foxy> :t f 0 a = show a; f n a = f (n-1) [a]
16:24:54 <lambdabot> parse error on input `='
16:25:05 <aavogt> the type is given
16:25:16 <om-foxy> zygoloid: you fixed the type when you entered '20'
16:25:23 <zygoloid> om-foxy: that value can change at runtime
16:25:39 <zygoloid> as i said, suppose it were entered by the user in response to a readLn or similar
16:26:09 * zygoloid out
16:26:19 <om-foxy> zygoloid: interesting, but...  ;P
16:26:46 <zygoloid> but you don't believe facts witnessed by your own eyes? ok, fair enough, i can't help you :)
16:27:06 <om-foxy> :t f let f 0 a = show a; f n a = f (n-1) [a]
16:27:07 <lambdabot> parse error on input `let'
16:28:15 <om-foxy> I'm not convinced, because Show and String are cheeky
16:28:26 <chrisdone> cheeky?!
16:29:00 <Twey> :t let f 0 = show; f n = f (n - 1) . (: []) in f
16:29:01 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
16:29:01 <lambdabot>       Expected type: [a] -> String
16:29:01 <lambdabot>       Inferred type: a -> String
16:29:13 <om-foxy> ;P
16:29:26 <om-foxy> try compiling it
16:29:43 <mauke> did
16:29:45 <mauke> now what?
16:30:11 <om-foxy> does it run?
16:30:16 <Kaidelong> perhaps you need an existential type?
16:30:22 <mauke> yes
16:30:37 <Kaidelong> for all a of type show
16:30:42 <mauke> why wouldn't it?
16:30:59 <mauke> Kaidelong: "for all" is like the opposite of an existential
16:31:59 <Kaide> yes, but that's what I've seen in the docs explaining existential types?
16:32:24 <om-foxy> mauke:  It's different from predicate logic
16:33:59 <benmachine> woo, I made an iteratee that wasn't a horrible mess
16:34:07 * benmachine is irrationally pleased with self
16:35:45 <orlandu63> i'm reading the pdf spec and i came across this (sorry for the buffer flood):
16:35:46 <orlandu63> The data values of strings and streams objects may be written either entirely using the ASCII character set 
16:35:48 <orlandu63> or entirely in binary data. In actual practice, data  that is naturally binary, such as sampled images, is 
16:35:50 <orlandu63> usually represented in binary for compactness and efficiency.
16:36:02 <orlandu63> how does one convert binary data to ascii data?
16:36:34 <benmachine> erm, you could encode it, but why would you want to?
16:36:51 <dons> ?yow
16:36:51 <lambdabot> Couldn't find fortune file
16:37:00 <benmachine> (uuencode, for e.g.)
16:37:31 <orlandu63> benmachine: i want to create a script that extracts the text from a pdf, for easy console reading
16:37:35 <benmachine> ah
16:37:55 <benmachine> you need to know the format of the binary data
16:38:03 <benmachine> if indeed the text is in binary form and not just ASCII
16:38:31 <benmachine> the spec implies that in practice stuff that is naturally binary is in binary and stuff that naturally isn't is in plain ASCII
16:38:37 <benmachine> buuut I dunno
16:38:48 <orlandu63> well in the pdfs i viewed, everything is binary
16:38:51 <benmachine> hmm
16:38:55 <orlandu63> even the text objects
16:38:55 <benmachine> maybe they're compressed?
16:39:04 <orlandu63> hmm maybe
16:39:07 <benmachine> gzipped, or something
16:39:12 <benmachine> you'd need to find that out
16:39:46 <benmachine> I can't think of any reason other than compression why text would be in binary rather than ascii
16:39:58 <benmachine> but there are lots of things I can't think of
16:40:00 <benmachine> so who knows
16:40:55 <om-foxy> > show ['x']
16:40:56 <lambdabot>   "\"x\""
16:41:01 <om-foxy> > show ['x']
16:41:03 <orlandu63> yep, looks like most stuff is compressed via deflate
16:41:03 <lambdabot>   "\"x\""
16:41:15 <om-foxy> show [['x']]
16:41:24 <om-foxy> > show [['x']]
16:41:26 <lambdabot>   "[\"x\"]"
16:41:47 <benmachine> > [['x']]
16:41:48 <lambdabot>   ["x"]
16:41:50 <om-foxy> :t show ['x']
16:41:51 <lambdabot> String
16:42:02 <om-foxy> :t show [["x"]]
16:42:03 <lambdabot> String
16:42:22 <om-foxy> :t [[[[[[[[[["x"]]]]]]]]]]
16:42:23 <lambdabot> [[[[[[[[[[[Char]]]]]]]]]]]
16:42:34 <benmachine> om-foxy: you know String = [Char] right?
16:42:37 <om-foxy> :t show [[[[[[[[[['x']]]]]]]]]]
16:42:38 <lambdabot> String
16:42:42 <om-foxy> yeah
16:42:45 <benmachine> and show always returns a string
16:42:51 <om-foxy> yeah
16:42:53 <tg_> :k String
16:42:54 <lambdabot> *
16:43:03 <tg_> :k Maybe String
16:43:04 <lambdabot> *
16:43:13 <benmachine> people are confusing sometimes.
16:43:21 <om-foxy> return 'x'
16:43:26 <ivanm> *sigh* so why is c.h.o down this time?
16:43:26 <om-foxy> > return 'x'
16:43:28 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
16:43:28 <lambdabot>    arising from a use of...
16:43:38 <om-foxy> :t return 'x'
16:43:38 <tg_> benmachine: I am confusing often. I haven't calmed down yet, so I can't think :o
16:43:39 <lambdabot> forall (m :: * -> *). (Monad m) => m Char
16:43:57 <dschoepe> ivanm: as usual, it's just the httpd
16:43:59 <om-foxy> > return 'x' :: String
16:44:00 <lambdabot>   "x"
16:44:13 <benmachine> om-foxy: you know, you can /msg lambdabot stuff
16:44:23 <tg_> has anyone here used both yesod and snap?
16:44:23 <om-foxy> > return 'x' :: [a] 
16:44:24 <lambdabot>   Couldn't match expected type `a'
16:44:25 <lambdabot>         against inferred type `GHC.Types.C...
16:44:26 <om-foxy> yeah
16:44:40 <tg_> thoughts?
16:44:49 <ivanm> dschoepe: ah, OK; pulling via ssh seems to be working
16:44:50 <tg_> oh, wrong perso.
16:44:53 <om-foxy> tg_: sorry, different question
16:46:27 <orlandu63> oh crap
16:47:10 <orlandu63> i thought this was haskell-blah
16:48:21 <monochrom> haha he doesn't like #haskell :)
16:48:47 <sshc> > [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[["x"]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
16:48:48 <lambdabot>   Context reduction stack overflow; size = 20
16:48:49 <lambdabot>  Use -fcontext-stack=N to incre...
16:48:57 <sshc> :t [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[["x"]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
16:48:58 <lambdabot> [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[Char]]]]]]]]
16:48:58 <lambdabot> ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
16:49:17 <ezyang> MonadCatchIO doesn't make sense for short circuiting monads, does it? 
16:49:23 <tg_> oh boy
16:50:02 <monochrom> what is short circuiting monads?
16:50:38 <ezyang> Maybe, Cont 
16:50:43 <soupdragon> how do you find inverses mod m?
16:50:45 <ezyang> Either 
16:51:38 <soupdragon> @let inv m b = head [ b' | b' <- [1..m-1], (b * b')`mod`m == 1 ]
16:51:40 <lambdabot>  Defined.
16:51:40 <monochrom> I haven't thought it through. Probably.
16:51:43 <soupdragon> > inv 7 2
16:51:46 <lambdabot>   4
16:51:52 <soupdragon> > (2*4)`mod`7
16:51:53 <lambdabot>   1
16:51:55 <soupdragon> is there a better way ?
16:52:27 <tg_> check out the dumpo
16:52:29 <tg_> err
16:52:36 <tg_> that's LHC talk
16:54:22 <Cale> soupdragon: The extended euclidean algorithm
16:55:21 <soupdragon> > let e p = foldr (\a x -> a + p*x) 0 ; d = zipWith (*) [2..] . tail ; f = [-6,0,1] ; x = 4 in x - inv p (e x $ d f)
16:55:22 <lambdabot>   4 - *Exception: not a number
16:55:47 <Cale> Suppose that gcd(x,m) = 1. Then there exists a and b such that ax + bm = 1, which is another way of saying that there exists a such that ax = 1 (mod m)
16:56:16 <soupdragon> ah! thats cool thanks Cale
16:56:32 <Cale> The extended Euclidean algorithm finds the a and b at the same time as computing gcd(x,m)
16:56:39 * mjrosenb usually builds up a list of all inverses
16:56:54 <mjrosenb> then again, i usually have to do that with integers less than 1,000,000
16:56:56 <ezyang> Oh, I guess it does work. 
16:57:05 <ezyang> I wonder why MonadCatchIO doesn't define anything for Maybe. 
16:57:08 <Cale> The inverse is unique.
16:57:16 <monochrom> ObHaskell: http://www.vex.net/~trebla/haskell/calculator/Calculator.hs
16:58:05 <benmachine> preflex: seen maciej
16:58:06 <preflex>  maciej was last seen on #haskell 1 year, 208 days, 5 hours, 42 minutes and 35 seconds ago, saying: Ok, I see.
16:58:11 <benmachine> :O
16:58:15 <tg_> he's as good as dead.
16:58:27 <tg_> though I'd prefer he weren't
16:58:28 * benmachine experiments
16:58:35 <benmachine> preflex: seen Benmachine
16:58:35 <preflex>  Benmachine was last seen on #haskell 7 seconds ago, saying: * Benmachine experiments
16:58:40 <benmachine> intriguing
16:59:02 <monochrom> also MonadCatchIO comes with an instance for lazy StateT but not strict StateT. it's probably just an omission.
16:59:08 <benmachine> I'm sure I've seen Maciej on haskell-cafe
16:59:10 * benmachine pokes around
16:59:20 <mjrosenb> guess it processes teh request befroe it records the statement
16:59:50 <soupdragon> "which of the following numbers have square roots ....." -_-
16:59:55 <soupdragon> boring prolbems
17:00:02 <benmachine> yeah, last posted on haskell-cafe Jun 19
17:00:11 <benmachine> wonder why they're not around here anymore
17:00:58 <soupdragon> I've got a question would an alien civilation use p-adic numbers?
17:01:07 <soupdragon> just like we use real numbers everywhere
17:01:13 <mle> p-adic?
17:01:25 <soupdragon> they're like base p numbers written backwards
17:01:38 <mle> hm, maybe.  Or negative-radix
17:01:55 <soupdragon> I wonder if they have got i and -i switched around
17:01:57 <mle> or complex-radix, heh heh heh.
17:02:24 <mle> I think knuth had an article somewhere about using 2i as a radix
17:02:32 <soupdragon> that's a clever trick
17:02:37 <soupdragon> I've seen that
17:02:48 <soupdragon> it's like binary but it hits all the complex numbers too I think
17:02:51 <mle> It'd potentially be useful to have pos/neg/complex all in hardware
17:02:56 <mle> yep.
17:03:04 <monochrom> any haskell?
17:03:07 <mle> i've mostly been playing with balanced ternary
17:03:12 <soupdragon> oh and you can get negatives without compliment
17:03:17 <mle> exactly.
17:03:39 <Kaidelong> wasn't the rationale behind two's complement the ability to efficiently do arithmetic with it?
17:03:45 <Twey> mle: YES
17:03:46 <Kaidelong> integer arithmetic, anyway
17:04:03 <soupdragon> what''s balanced ternary for?
17:04:08 <mle> Kaidelong: there's nothing slow about these other systems or that prevents direct electrical implementation
17:04:14 <Kaidelong> balanced ternary is where you have 1, 0, and -1
17:04:18 <Kaidelong> the soviets used it for a while
17:04:24 <mle> setun, etc, yeah
17:04:26 <Kaidelong> I think it made engineering the stuff really hard
17:04:36 <mle> only because it's different
17:04:39 <mle> it's more efficient, really
17:04:50 <mle> but the base-2 nature of internet sorta kills the idea today
17:04:51 <soupdragon> "There were a few experimental Russian computers, Setun, in the early days of computing that were built with balanced ternary instead of binary" omg! that is so cool!
17:04:56 <Kaidelong> in terms of how expensive the hardware is, or in terms of how many computations you need?
17:04:59 <soupdragon> mle so are you emulating it or something
17:05:16 <mjrosenb> balanced ternary is useful for using scales.
17:05:30 <mle> soupdragon: was playing around with gate simulation and stuff yes; what a ternary ALU looks like, etc.
17:05:38 <soupdragon> awesome
17:06:00 <mle> and there's a variety of papers out on how to set up cmos for ternary voltage levels instead of just on/off
17:06:12 <Kaidelong> I seem to recall that the problem was that balanced ternary computers simply were more expensive than binary ones due to the need to use ternary binning on analog values
17:06:13 <mle> it's just so Different that most people don't get into it
17:06:13 <Kaidelong> yes
17:06:36 <mle> Kaidelong: Needs fewer gates and computations, potentially, but can't reuse much of the modern infrastructure
17:06:41 <mjrosenb> mle: cmos being complementary metal oxide..., not the fubar x86 bios garbage, right?
17:06:50 <mjrosenb> substrate?
17:06:50 <mle> mjrosenb: right
17:07:18 <mle> you could implement gates using discrete transistors-- or vacuum tubes (valves) if you like that kind of pain.
17:07:19 * mjrosenb would be *very* scared if the x86 bios let you select ternary voltages
17:07:51 <monochrom> 3.0, 3.3, 5.0
17:07:53 <mle> anyway.  Ternary might rear its head again as we start looking at optical computers, or some of the quantum stuff.
17:08:13 <mle> monochrom: well this would be a -4, 0, 4V system in many cases.
17:08:24 <Kaidelong> well quantum computers don't use discrete values to begin with do they?
17:08:29 <mle> but it's easy to play with it in haskell in any case.
17:08:37 <Kaidelong> I thought the big breakthrough was that you could work with probabilities in between
17:08:38 <mle> Kaidelong: whole other can of worms, really
17:09:36 <ddarius> Balanced ternary makes sense if you have a high rail and a low rail.
17:09:40 <Kaidelong> I suppose you could use polarization of light to encode information?
17:09:50 <mle> wikipedia had some interesting mention of josephson effects being used for ternary ram
17:10:14 <ClaudiusMaximus> aarg, is there any neat trick to avoid the space leak in something like  > let ones = 1 : ones in map (+1) ones
17:10:19 <Kaidelong> mle: are you familiar with NEMSET?
17:10:45 <mle> no?
17:11:02 <ddarius> ClaudiusMaximus: There shouldn't be a space leak.
17:11:03 <Twey> ClaudiusMaximus: What space leak?
17:11:03 <Kaidelong> while alternative architectures are up, that one is interesting
17:11:18 <mle> hmm, the nanomechanical one?  Interesting.
17:11:20 <monochrom> ClaudiusMaximus: when you consume that list, seq each number in order
17:11:23 <Kaidelong> it seems to be where you use electricity to make mechanical parts vibrate
17:11:27 <Kaidelong> and they can affect each other
17:11:33 <ClaudiusMaximus> in context: i have something like a quad-tree, that i want to clip to bounds
17:11:35 <Twey> ClaudiusMaximus: Unless you're saving all those values, all but the relevant one(s) will be GC'd.
17:11:36 <mle> yeah this ternary stuff just came up because I got distracted during the icfpc, heh heh heh
17:12:07 <ddarius> There is only one cell in ones (in most implementations)
17:12:10 <monochrom> ClaudiusMaximus: oh nevermind, I misread.
17:12:36 <ClaudiusMaximus> and at the moment i'm expanding the tree, clipping each level as i go, but the number of quads to clip rises exponentially with the depth
17:13:37 <ClaudiusMaximus> which is really dumb of me, i need a ternary partition of inside/overlapping/outside
17:14:01 <monochrom> everyone wants tenary tonight
17:14:03 <Kaidelong> mle: apparently one of the big things NEMSET would allow is bases higher than two without a great increase in complexity
17:15:05 <ClaudiusMaximus> but the initial question arose as i was trying to have a list of parent bounds in each node and check them in order, but that didn't work out entirely as planned (mammoth space leak when clipping, when initially most of the lists were shared)
17:15:11 <dkc> Hi ... I want to define a type like data Foo a b = Foo String (a || b)
17:15:30 <dkc> Is it possible to OR types like that?
17:15:36 <ClaudiusMaximus> @src Either
17:15:36 <lambdabot> Source not found. You speak an infinite deal of nothing
17:15:38 <ddarius> :k Either
17:15:39 <lambdabot> * -> * -> *
17:17:16 <ClaudiusMaximus> dkc: probably something like > type Foo a b = (String, Either a b)  -- or > data Foo a b = FooA String a | FooB String b  -- depending on what kind of bottoms your problem requires
17:17:37 <ddarius> Problems don't usually require bottoms.
17:17:43 <dkc> hmm....
17:17:45 <ezyang> Is there something like a “Default” typeclass, that is, a typeclass for types with a single distinguished element but no other required properties? 
17:18:17 <ddarius> People have made such classes before, but there is no standard one (for what should be obvious reasons)
17:18:43 <ezyang> oh poo :-) 
17:19:16 <dkc> OK .. can I describe the problem a bit more accurately? What I really want to do is define a datatype like this: data Msg = Msg1 | Msg2 | Msg3 etc.
17:19:32 <dkc> and then say data Thing1 = [ Msg1 || Msg2 ]
17:19:43 <dkc> data Thing2 = [ Msg2 || Msg3 || Msg7 ]
17:19:56 <ddarius> You can't do that... directly
17:20:09 <dkc> so a Thing1 is an array of some subset of the possible Msg types
17:20:22 <soupdragon> there is || in haskell
17:20:31 <soupdragon> you could define  data a :|| b = ...
17:20:34 <tensorpudding> (||) is something totally different
17:21:04 <dkc> I found a sort of dodgy way to do it using type classes and existential quantifiers, but it's not pretty, so I'm wondering if there's a more idiomatic way
17:21:17 <monochrom> if you produce exponentially many tree nodes, mostly different nodes, and you want to keep them all in memory, you can't quite call it a memory leak...
17:21:22 <ddarius> dkc: Incidentally, [X] is the type of lists of Xes, not arrays.
17:21:34 <dkc> ddarius: apologies, you're right .. i want a list
17:23:14 <ddarius> If you don't need any kind of "subtyping" then you can make Msg1..MsgN each their own type and have Thing1 = [Either Msg1 Msg2], Thing2 = [Either Msg1 (Either Msg2 Msg3)].  
17:24:02 <dkc> is Either the thing with Left and Right?
17:24:08 <ddarius> Yes.
17:24:38 <dkc> So I'd have to do foo a:as = Left a to get Msg1 out?
17:25:33 <dkc> what do you mean by "subtyping"?
17:25:34 <ddarius> You'd have to write f (Left a:as) = ... to check if the first element of the list was a Msg1 
17:25:47 <dkc> "Subtyping" sounds like what I want, maybe
17:26:35 <dkc> I was initially doing  data Thing1 = Thing1 [Thing1Msg] .. data Thing1Msg = Msg1 | Msg2 | ...   data Msg1 = Msg1 ImportantMsg1Data etc.
17:26:50 <dkc> But then I realized that this isn't OOP with inheritance :)
17:27:26 <dancor> which ffi preprocessor reduces the most boilerplate?
17:28:13 <ddarius> None of the FFI support tools completely subsumes any of the others.
17:29:19 <dancor> http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
17:30:41 <dancor> that seems to indicate that greencard removes the most boilerplate
17:31:10 <ddarius> Only if the output of Greencard is what you want.  Otherwise it just moves the problem.
17:31:34 <dkc> I wish there were a haskell SWIG backend...
17:31:34 <danharaj> It's preprocessors all the way down.
17:31:38 <dancor> idk i feel like you could be less careful and more practically helpful if you wanted to be ;)
17:31:51 <danharaj> dkc: Yes. I would totally contribute to such a project but I have no idea how to develop a swig backend.
17:32:34 <dkc> danharaj: apparently there are a lot of us ... every full moon or so, haskell-cafe gets another request for swig by someone who doesn't know how to implement it
17:32:48 <ddarius> dancor: I -am- being helpful.  Just because Greencard is "push button" doesn't mean it will "remove the most boilerplate."  You haven't explained your problem enough to give any advice.  You could even want to use all three of the major tools.
17:33:03 <ddarius> Or maybe using any tool is not worth your trouble.  I usually just use the FFI directly.
17:33:21 <dancor> mm
17:33:25 <dkc> dancor: none of them will help you much with C++ if that's what you're asking...
17:34:04 <dancor> don't need c++ right now but that's interesting as well
17:34:15 <dancor> surely wrapping some of the stl stuff could be useful?
17:34:25 <ddarius> I don't really see how.
17:34:55 <ddarius> What STL thing do you think would be useful?
17:35:32 <danharaj> std::vector maybe?
17:35:44 <mtnviewmark> Really? Can't imagine anything in STL that isn't already in sone native Haskell package
17:36:04 <dkc> ddarius: is there a simple way to define a type to be one of several others?  like if i have data A = A String, data B = B string, is there any way to have data C = A | B ?
17:36:05 <danharaj> Most of the stuff in the STL that isn't containers is a bad implementation of functional ideas :p
17:36:29 <danharaj> type C = Either A B is probably idiomatic
17:36:32 <danharaj> don't quote me on that.
17:36:34 <monochrom> perhaps data C = C1 A | C2 B
17:36:40 <mtnviewmark> Also - wrapping templated C++ only works if you know the types you need in advance
17:36:40 <ddarius> dkc: Not without adding data constructors to distinguish the cases.
17:36:53 <dkc> ok but that only works for one or two values?
17:37:01 <dkc> i've got about 40 different options
17:37:06 <monochrom> If you never use A alone and B alone, perhaps just have C.
17:37:25 <dkc> i do use them alone
17:37:27 <danharaj> mtnviewmark: ghc has access to gcc, so it should be able to instantiate templates, but that would be absolute hell to implement.
17:37:35 <dkc> or i use different subsets of them
17:37:43 <dkc> so i might have data D = A | C
17:37:51 <dkc> sorry .. data D = A | C | B | Z
17:37:53 <dkc> or something
17:38:13 <mtnviewmark> Exactly - I don't think any C++ wrapping tool, for any language implements such a thing
17:38:15 <monochrom> perhaps re-structure everything so you don't have a huge hierachy of data types
17:38:25 <dkc> monochrom: lol 
17:38:56 <dkc> i have exactly 2 layers, but it's true ... i have one layer of basic "fields", and then a second layer of "messages", each of which contains different subsets of the "fields"
17:39:27 <dkc> i would like to encode these relationships into the type system so that it's impossible for me to create a message with the wrong fields in it
17:39:57 <danharaj> C++ has to die.
17:39:59 <dancor> ddarius: what about this http://www.cplusplus.com/reference/stl/multimap/
17:40:18 <dkc> also, some messages can have variable numbers of the fields (i.e. a few mandatory and then any number of some other subset)
17:40:19 <danharaj> Because the worst part about it is how painful it is to work with from other languages. It lost that appealing aspect of C.
17:40:20 <dancor> srush was asking for this structure a while back i believe
17:40:35 <ddarius> dancor: Why would we not just implement it in Haskell itself?
17:40:43 <dancor> ddarius: time
17:40:56 <monochrom> multimap and multiset are much wanted. but yes just extend map and set.
17:40:57 <mtnviewmark> Are they fields or alternatives - like does MessageC have a FieldA and a FieldB , or can a MessageC be either a FieldA or a FieldB?
17:41:12 <dkc> fields
17:41:35 <dkc> so MessageA maybe *has* to have FieldA and FieldB, and then can have any number of fields P through W or something
17:41:44 <monochrom> binding to c++ multimap is probably more work than extending data.map to data.multimap
17:41:51 <dancor> ddarius: maybe someone could work on the ghci debugger with the time saved not rewriting another library
17:42:06 <zygoloid> i have a function f :: WorkItem -> (a, [WorkItem]), and want to write: let work = baseWork ++ concat extraWork; (results, extraWork) = unzip $ map f work in results, but i'm getting <<loop>>. how can i make extraWork end in [] not _|_?
17:42:12 <ddarius> dancor: I'm pretty sure it would take longer to make a remotely satisfying binding to that than it would to write it directly.
17:42:15 <dkc> dancor: isn't multimap just like [([Keys],Value)]
17:42:26 <dkc> dancor: plus a function to access it?
17:42:27 <dancor> probably..
17:42:45 <dancor> but i still don't believe that it's reasonable that there is no case for c++ bindings
17:42:51 <ddarius> dancor: Also, a immutable version seems to be Map Key [Value] hich doesn't seem hard.
17:42:56 <dkc> dancor: there *is* a case for c++ bindings, just not for stl
17:43:06 <ddarius> dancor: What dkc said.
17:43:37 <zygoloid> it'd be better to reimplement STL. you could probably get something pretty close with lots of {-# INLINE #-}
17:43:49 <mtnviewmark> data MessageA = MessageA FieldA FieldB [ OptionalMessageAFields ]
17:43:49 <zygoloid> (in terms of compile-time code generation)
17:43:51 <dancor> zygoloid: you mean close in performance?
17:44:05 <monochrom> close in executable code bloat :)
17:44:08 <zygoloid> yeah
17:44:30 <mtnviewmark> But then your still going to have 
17:44:33 <ddarius> The thing is we don't -want- STL.  STL doesn't fit Haskell very well, and by the time you got it to fit you'd have written more code than it would have taken to implement the algorithms and data structures directly.
17:44:37 <dancor> it just seems like haskell ppl go out of their way to maintain a war with c++
17:44:56 <ddarius> dancor: No, C++ goes out of its way to maintain a war with everyone as far as binding is concerned.
17:45:04 <dkc> mtnviewmark: yeah :) that's what i started with
17:45:13 <dkc> but then you need a type OptionalMessageAFields
17:45:28 <mtnviewmark> yup and it'll be ugly
17:45:40 <dancor> "he started it"
17:45:43 <monochrom> I don't maintain a war with c++. Teach me how to call c++ template code from haskell.
17:45:52 <ksf> .oO( forgetfulness-annotations )
17:45:56 <dkc> mtnviewmark: i got into doing  class OptionalMessageAClass
17:46:20 <dkc> and then OptionalMessageAFields = forall a. OptionalMessageAClass a => AField a
17:46:28 <mtnviewmark> But, if the message system is then non-regular, the representation isn't going to be pretty
17:46:31 <ksf> I think it'd be cool to be able to say "forget what this thunk evaluated to when under memory pressure"
17:46:54 <zygoloid> can anyone help me with my fixed point issue?
17:46:54 <dkc> and then anythin that can be used in message becomes an instance of MessageAClass
17:47:06 <dkc> indeed, it's non regular
17:47:07 <ddarius> dancor: Getting C++ to talk to -C++- is a nightmare.  It's hardly surprising that almost no languages in existence have decent (or any) C++ FFI.
17:47:18 <dkc> you have to use the message A deconstructor for message A fields, etc.
17:47:23 <pikhq> monochrom: extern "C" type namespace_class_function_type (void *c, type x) { return ((namespace::class *)c)->function<type>(x); }
17:47:25 <mtnviewmark> Well, the class doesn't really let you the see into which fieldsare in an actual value
17:47:51 <monochrom> void* !!!111!!!111
17:47:59 <ddarius> I like C++ quite a bit, but it is probably the hardest language in existence to bind to and if you are doing it for "speed" you better be doing -very- coarse chunks or all the gains will be lost to marshalling.
17:48:00 <dkc> No but it allows you to say MessageA can an unspecified number of fields of this class
17:48:07 <davekong> I want to print a two dimensional array with each row on a newline how should I do that?
17:48:10 <mtnviewmark> The "extra" constrictors that a simple OptionalMessageAFields would have let you decompose it
17:48:17 <pikhq> ddarius: There's... Java as compiled by gcj. That has a C++ interface. Which cheats by compiling C++ with the same ABI as Java. :P
17:48:24 <ddarius> pikhq: Unfortunately, that's not Haskell.
17:48:28 <pikhq> Yeah.
17:48:29 <mtnviewmark> Via  pattern matching
17:48:37 <dkc> yep
17:48:42 <dkc> probably couldn't do pattern matching
17:48:42 <ddarius> (that was re your remark to monochrom)
17:48:45 <pikhq> Can't really do that with any language that's not similar in typesystem to C++.
17:48:58 <mtnviewmark> davekong: mapM_ print
17:49:11 <pikhq> ddarius: Oh, that? That's not Haskell, but it's a C function that you can call from Haskell. :P
17:49:12 <dkc> I may just do giant record types with Maybe
17:49:44 <pikhq> To link anything with C++, you need a C binding first. Ugh.
17:49:50 <monochrom> well, extern "C" wrapping is a stepping stone. I know how to call the extern "C" version from haskell.
17:49:51 <ksf> would it be possible to auto-gen those C stubs?
17:50:11 <mtnviewmark> dkc: Well, can the optional fields appear multiple times?
17:50:16 <monochrom> to call c++, you must first call c++
17:50:37 <dkc> mtnviewmark: i don't think so (i hope to god they don't >.<)
17:50:37 <ksf> there's a qt for haskell project, how did they do it?
17:50:41 <mtnviewmark> Oh dinner has arrived- off to eat
17:50:47 <dkc> cheers
17:50:49 <monochrom> anyway I'm just scared by void* :)
17:51:03 <daydream> hi
17:51:29 <Kaidelong> void* is just a pointer to anything, isn't it?
17:51:35 <monochrom> yes
17:51:37 <Kaidelong> is that allowed in C++?
17:51:42 <monochrom> yes
17:51:45 <Kaidelong> ah ok
17:51:53 <Kaidelong> well it's never terribly bothered me in C
17:52:04 <danharaj> there is no implicit conversion from void* to other pointer types, though.
17:52:05 <Kaidelong> I can see how it'd be scary in a C++ context
17:52:11 <ddarius> pikhq: Unfortunately I want to do: cppFunction :: a -> STL_vector a, not cppFunctionInt :: Int -> STL_vector_int and so forth.
17:52:19 <monochrom> actually I'm just spoiled by good type systems. I used to be braver.
17:52:55 <daydream> i have a question about functor typeclass
17:53:01 <dancor> what has a good type system and manual dynamic memory management
17:53:06 <ddarius> When I started a binding to Kyra, I used SWIG to generate a C binding and then started binding that, but I don't think Kyra used templates.
17:53:22 <monochrom> "ooohhh qsort working with const void * ? that's too easy!"
17:53:29 <daydream> i think i know what functor typeclass is
17:53:38 <ddarius> dancor: Quite a few languages nowadays at varying levels of maturity and with varying values of "good"
17:53:46 <pikhq> ddarius: You'd need a Haskell-side typeclass around C++ instantiations of the templates.
17:53:52 <daydream> and what functor means in category theory
17:53:52 <pikhq> Possible, but *God* what a pain.
17:54:31 <dancor> ddarius: what is closest to haskell type system that you know
17:54:33 <ksf> daydream, class Functor represents covariant endofunctors in hask
17:55:19 <dancor> D has optional manual memory management?
17:55:30 <ddarius> dancor: http://www.bitc-lang.org/
17:55:47 <dancor> i heard bitc was being developed again
17:55:47 <soupdragon> is there anything I could search on arXiv and find a paper that I can actually undesrtand?
17:55:59 <pikhq> dancor: It's (conservative) GC by default with manual memory management as an option, yes.
17:56:07 <ksf> soupdragon, I just recently posted two to the proggit.
17:56:07 <dancor> ok
17:56:14 <daydream> yep and fmap lifts functions into the category right?
17:56:59 <ksf> nope, it makes an ordinary function into a functor
17:57:07 <ksf> ...both live in hask
17:57:18 <ksf> everything in Haskell lives in Hask, at least if it's total.
17:57:50 <danharaj> Does the description of Hask deal with bottom being everywhere or does it pretend everything is total?
17:57:58 <ksf> the latter.
17:58:04 <danharaj> good. :p
17:58:13 <ksf> fast and loose reasoning is morally correct.
17:58:32 <ddarius> It depends on how you define it.
17:58:39 <ddarius> There is no standard definition of Hask.
17:58:43 <ddarius> The naive one doesn't work.
17:59:16 <ddarius> Restricting to total functions is just the easiest thing to do that works and also has the benefit of being fairly nice.  Unfortunately it is no longer very Haskell-like.
17:59:35 <ksf> but very like actually working haskell programs
18:00:01 <daydream> um, doesn't map lifts morphisms in the Hask category to List category?
18:00:20 <daydream> well List is a subcategory of Hask
18:00:33 <ksf> ...rather into a List category expressed in Hask
18:02:36 <ksf> Hask has all Haskell types as objects and all total functions as morphisms and ordinary (.) as compositon
18:03:17 <daydream> yes i understand that
18:03:58 <apples> hey, i was wondering where i could find the type signature of (!!) ?
18:04:07 <ksf> ...and you can use it to express e.g. Set, or Cat, in the same way that you can use Set to define categories.
18:04:10 <soupdragon> :t (!!)
18:04:11 <lambdabot> forall a. [a] -> Int -> a
18:04:16 <apples> aha, thanks.
18:04:26 <EvanR> what is static analysis, in the context of haskell and ghc?
18:04:38 <ksf> afaiu CT isn't afraid of metacircularity as long as it isn't infinite.
18:05:02 <soupdragon> yeah I got dizzy when I read about category theory
18:05:07 <soupdragon> because you learn about, say, functors
18:05:08 <ksf> EvanR, everything ghc does at compile-time to the program?
18:05:19 <soupdragon> then you find functors between functors between functors between .....
18:05:39 <soupdragon> or if you look at a natrual tranform you notice that natural transforms are natural transforms of natural transforms. 
18:05:44 <soupdragon> and categories form a category
18:05:54 <ksf> ...and most types aren't categories, so functor in ct /= (functor in haskell = endofunctor in hask)
18:06:06 <EvanR> ksf: i am wondering about optimizations
18:06:28 <ksf> EvanR, yep, exactly such stuff.
18:07:40 <ksf> one of the easiest things done by analysing is e.g. dead code elimination
18:08:04 <daydream> so map maps morphisms of Hask to morphisms of List, is this correct?
18:08:07 <ksf> strictness analysing.
18:08:20 <soupdragon> daydream don't think so
18:08:23 <ksf> ...of List expressed in Hask
18:08:46 <soupdragon> maps just a function (a -> b) -> ([a] -> [b])
18:09:13 <Kaidelong> @type map
18:09:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:09:21 <Kaidelong> @type mapf
18:09:23 <lambdabot> Not in scope: `mapf'
18:09:26 <Kaidelong> fmap
18:09:36 <soupdragon> List(-) is a functor
18:09:54 <Kaidelong> @type fmap
18:09:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:10:04 <soupdragon> read Graham Huttons notes
18:10:50 <soupdragon> http://www.cs.nott.ac.uk/~gmh/cat.html
18:11:11 <ksf> list has two applicative functors, which would mean that there's more than one category of them.
18:11:22 <ksf> ...both have the same functor, though.
18:12:00 <ddarius> http://felix-lang.org/  This is a language I was looking for before.  It's the only serious, stand-alone language I know of that targets C++ interopability directly.
18:13:18 <ksf> wait is that the language I was wishing for while reading the stroustrup?
18:13:37 <ksf> sane template syntax and stuff?
18:13:51 <ddarius> Not all static analyses are related to optimizations.
18:13:54 <ksf> ...although sane syntax and ml-descendent are antonyms.
18:14:46 <Kaidelong> you don't like ML syntax?
18:15:02 <soupdragon> just scrolled through about 10 pages of papers not one of which makes ANY sense at all
18:15:07 <soupdragon> very dishearteninga
18:15:09 <Kaidelong> is ALGOL or LISP better in that department?
18:15:11 <soupdragon> -a
18:15:46 <ksf> haskell is better in that department
18:16:01 <Kaidelong> Well Haskell's syntax is descended from ML
18:16:08 <Kaidelong> is it sane?
18:16:48 <ksf> it's readable, even for beginners
18:17:08 <ksf> I struggle to understand ml even now that I know haskell
18:17:13 <ddarius> Haskell and its direct ancestors tend to have syntax closer to ISWIM than any ML.
18:17:20 <ksf> it's just /untidy/
18:17:37 * hackagebot gsasl 0.3.2 - Bindings for GNU SASL  http://hackage.haskell.org/package/gsasl-0.3.2 (JohnMillikin)
18:17:57 <geheimdienst> i thought haskell was in the ml tradition as far as the type system and type inference is concerned
18:17:58 <Lajla> ddarius, which is a mistake.
18:18:07 <Lajla> Mathematical textbook notation should be illegal.
18:18:12 <ksf> haskell : ml == c : c++
18:18:14 <Lajla> I will make SHaskel as a front end.
18:18:29 <soupdragon> ksf other way around :P
18:18:38 <JoeyA> What's Shaskel?
18:18:47 <Lajla> ((map square) '(1 2 3 4 5))
18:18:49 <ksf> there's liskell
18:18:52 <Lajla> JoeyA, haskel in lists.
18:18:55 <Lajla> ksf, seriously?
18:18:58 <ksf> yep
18:19:00 <Kaidelong> hmm so ML and Haskell have common ancestry in terms of syntax, but Haskell isn't "descended" from ML?
18:19:17 <Lajla> Kaidelong, let's that say that Haskell would not have existed without ML.
18:19:23 <soupdragon> Kaidelong: they're in the same family
18:19:25 <Lajla> At least not in its current form.
18:19:31 <ksf> I would be the first one to condone defining haskell in terms of sexprs and then syntax-defining the current syntax.
18:19:35 <Lajla> ksf, give me an example.
18:19:50 <Lajla> ksf, I agree.
18:19:57 <ksf> Lajla, http://www.liskell.org/
18:19:58 <tensorpudding> Haskell is part of the ML family, you could say.
18:19:59 <Lajla> I also like to think of programming languges irrespective of their syntax.
18:20:07 <ddarius> (Of course Haskell wouldn't have existed without ML.  The first Haskell implementation was written in LML.)
18:20:08 <Kaidelong> ksf: I don't know if I like the LISP style that much
18:20:10 <Lajla> ksf, I love you more than that I love to eat the faeces of my girlfriend.
18:20:18 <Kaidelong> infix operators are nice for thinking about data flow
18:20:25 <Kaidelong> particularly $
18:20:26 <Lajla> Kaidelong, no they are not.
18:20:29 <Lajla> They are horrible.
18:20:37 <Lajla> People just accept them due to being used to them.
18:20:43 <EvanR> $ has the data flow going backward ;)
18:20:44 <ksf> Kaidelong, it's not about using the syntax, but the _primitive_ syntax.
18:20:56 <ddarius> ksf: I'm pretty sure you cannot "syntax-define" the current syntax.
18:21:02 <Lajla> Polish and reverse-polish is like the metric system, infix is like the imperial.
18:21:10 <danharaj> what?
18:21:17 <ksf> heck the first thing I did to make the TH AST analysable was to get rid of infix expressions.
18:21:24 <Kaidelong> ksf: sure, I'd like to see the syntax defined as being equivalent terms in a "lisp-like" haskell, but we can already sort of do that can't we?
18:21:36 <Lajla> ksf, amazing
18:21:38 <Lajla> What I don't get thouygh
18:21:44 <Lajla> Like, in Haskell, functions are always curried right?
18:21:49 <Lajla> All functions are in principe one argument?
18:21:53 <ksf> yep
18:21:54 <tensorpudding> Infix operators are very useful and readable.
18:22:00 <aavogt> @type uncurry
18:22:01 <ksf> a -> ( b -> c )
18:22:01 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:22:07 <Kaidelong> Lajla: blame Backus
18:22:21 <ddarius> Kaidelong: Backus wouldn't like Haskell.
18:22:22 <aavogt> @hoogle range
18:22:23 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
18:22:23 <lambdabot> Language.Haskell.TH data Range
18:22:23 <lambdabot> Language.Haskell.TH.Syntax data Range
18:22:29 <Lajla> ksf, but why isn't it (((f x) y) z) then?
18:22:37 <ksf> it is.
18:22:37 <Lajla> And (f x y z)
18:22:39 <Lajla> Ahhh
18:22:47 <Lajla> (* n (fact (- n 1)))))
18:22:50 <Kaidelong> ddarius: but isn't he the reason why all functions in the MLs take one argument?
18:22:52 <Lajla> That contradicts your idea.
18:22:56 <ksf> " " binds tightest, and to the right.
18:23:03 <ksf> er left.
18:23:04 <ddarius> Kaidelong: I don't even see why he'd be connected with it.
18:23:07 <Lajla> It would be ((* n) (fact  ((- n) 1))) then
18:23:12 <tensorpudding> I think you might be confusing Backus with Curry
18:23:26 <Lajla> Curry didn't even invent currying.
18:23:40 * hackagebot gnuidn 0.1.1 - Bindings for GNU IDN  http://hackage.haskell.org/package/gnuidn-0.1.1 (JohnMillikin)
18:23:41 <Lajla> But in lisp, you can say that al functions take one argument, which just happens to be a list.
18:23:55 <Kaidelong> I read a paper, I think it was on Backus, on how functions taking any arbitrary amount of parameters could be seem as being functions that take just one parameter
18:23:58 <soupdragon> why would you say that
18:24:00 <Lajla> If you could encode all functions as lists, that would be cool.
18:24:07 <Lajla> Oh wait, you can
18:24:07 <Kaidelong> of course, haskell practically does not really allow for that
18:24:30 <Kaidelong> but I thought that was the motivation for types that look like "a -> b -> c"
18:24:31 <Lajla> Kaidelong, it does, doesn't it?
18:24:35 <ksf> you can desugar pattern matching to cond over a tuple
18:24:39 <Lajla> Kaidelong, it is.
18:24:40 <EvanR> s/lists/tree/ s/tree/nested pairs/
18:24:50 <EvanR> s///// lambda calculus
18:24:54 <Kaidelong> by Backus*
18:24:57 <Lajla> a function of that type just takes an argument of type a and returns a function of type b -> c
18:25:03 <Kaidelong> yes
18:25:08 <Kaidelong> wasn't that Backus' idea?
18:25:09 <soupdragon> you're confusing the implementation with the reality 
18:25:11 <ksf> currying will be even cooler when we get evaluation under binders
18:25:15 <ddarius> Kaidelong: No.
18:25:15 <Lajla> Kaidelong, no idea.
18:25:39 <Lajla> Any way, ksf we must accept that we are better than these poor misguided souls who appreciate the mutilated horror of infix notation.
18:25:39 <PetRat> question regarding Parsec... I have haskell platform 6.12. It says it can't find Text.Parsec. According to cabal, Parsec is already installed.
18:25:46 <Lajla> We must enslave them, and guide them for their own good.
18:25:53 <ddarius> PetRat: You have Parsec 2, Text.Parsec is Parsec 3.
18:25:57 <ksf> infix notation can be very, very useful.
18:26:42 <PetRat> Is there a cabal command to force re installation of the new version?
18:26:44 <Lajla> ksf, I see I must guide you too.
18:27:00 <Kaidelong> (\predictors values -> sqrt . sum . map(^2) . zipWith(-) values $ predictors)
18:27:07 <Lajla> ksf, anyway, I'm working on my own lisp where (- 5 10) evaluates to -15 but (5 - 10) to -5.
18:27:08 <ddarius> PetRat: You just need to specify a more specific version: cabal install parsec-3.*
18:27:34 <Lajla> Both are praefix notation, in the first example the operator is whatever the symbol '-' evaluates to, in the second it is the number 5.
18:27:44 <Lajla> Of course - evaluates to the subtraction operator from context here.
18:27:55 <soupdragon> I thought you were against infix ops
18:28:02 <geheimdienst> why on earth would (- 5 10) evaluate to -15 ?
18:28:02 <PetRat> ddarius: thanks, that is working
18:28:08 <ksf> 0 - 5 - 10
18:28:15 <Lajla> ksf, bingo.
18:28:18 <soupdragon> mad
18:28:26 <ddarius> geheimdienst: Perfectly intuitive, see?
18:28:27 <ksf> in the same way as (+ 1 2 3) = 0 + 1 + 2 + 3
18:28:32 <Kaidelong> is (lambda (predictors values) (sqrt (sum (map (lambda (x) ((^) x 2)))...
18:28:36 <Lajla> I always thought that this (- 5) is -5, but (- 5 2) is 3 business was ugly and illogical.
18:28:37 <geheimdienst> yeah i can see that, but that would be more like doing a map of an unary negation over the list
18:28:38 <Kaidelong> really better than just using infix operators?
18:28:39 <Lajla> ksf, exactly.
18:28:44 <geheimdienst> how on earth is that intuitive?
18:28:48 <soupdragon> lol
18:28:51 <soupdragon> language design
18:29:04 <ksf> how do you intend to make numbers functions?
18:29:05 <geheimdienst> > map (-) [1,2]
18:29:06 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:29:06 <lambdabot>    arising from a use of `...
18:29:10 <Lajla> geheimdienst, well, (-) evaluates to 0, (- 5) to -5, (- 5 3) to -8
18:29:16 <Lajla> It satisfies the obvious pattern.
18:29:35 <ddarius> geheimdienst: It is completely intuitive if you understand that I'm being facetious.
18:29:37 <Lajla> Having (- 5) evaluate to -5 but (- 5 3) to 2 instead of -8 is just no pattern at all.
18:29:45 <EvanR> making numbers functions sounds hilarious like making numbers objects in say smalltalk
18:29:51 <EvanR> hilariously*
18:29:56 <ksf> ruby?
18:29:58 <danharaj> numbers are functions
18:29:59 <ksf> 5.times
18:30:00 <aavogt> > 1 2 3 :: Int
18:30:01 <lambdabot>   1
18:30:02 <Lajla> evanR, it is.
18:30:03 <danharaj> 5 :: () -> Integer
18:30:05 <EvanR> yes
18:30:10 <Lajla> It is message passing.
18:30:24 <PetRat> Now it complains that the type Parser doesn't exist. Did this get changed in version 3?
18:30:25 <EvanR> numbers are numbers, not functions or objects, get over it
18:30:30 <Lajla> THere is no difference between function application and message pasing, all data are both objects and messages.
18:30:32 <danharaj> everything is a function.
18:30:42 <EvanR> everything is a *
18:30:44 * hackagebot capri 0.1 - A simple wrapper over cabal-install to operate in project-private mode.  http://hackage.haskell.org/package/capri-0.1 (DmitryGolubovsky)
18:30:53 <ksf> usually a number is a function of no parameters evaluating to itself, though.
18:31:02 <geheimdienst> lajla, i will think of your lisp implementation as an elaborate act of trolling, until somebody convinces me that having (-) evaluate to 0 is in any way a good idea
18:31:05 <aavogt> Lajla: that notation is different from how people are taught those operations work
18:31:07 <Kaidelong> @type (\_->5)
18:31:08 <lambdabot> forall t t1. (Num t1) => t -> t1
18:31:08 <dancor> i have midi_init(snd_seq_t **seq) and midi_noteon(snd_seq_t *seq, int note).  in C i would do {snd_seq_t *seq; midi_init(&seq); midi_noteon(seq, 60); ..} and in haskell FFI i want to wrap midi_init() and midi_noteon() separately.  i don't want to use a global seq in C, and i need to support infinite midi streams so i want the functions separate.  am i going to have to switch to dynamic allocation (malloc) for seq?
18:31:10 <EvanR> what is a function of no parameters
18:31:11 <ddarius> PetRat: You need to import Text.Parsec.String (or .ByteString or .ByteString.Lazy) to get that type synonym.
18:31:17 <Kaidelong> @type 5
18:31:18 <lambdabot> forall t. (Num t) => t
18:31:20 <danharaj> EvanR: () -> Foo
18:31:21 <Lajla> Like ("Print me as %d" :format 6) is just passing two arguments, one of which is a symbol to a string.
18:31:23 <ksf> EvanR, aka value.
18:31:24 <Lajla> OR sending two messages.
18:31:36 <Lajla> geheimdienst, it is a good idea for recursion obviously.
18:31:47 <EvanR> i have been study object oriented for last month or two and it has driven me mad
18:31:54 <danharaj> Well, yeah.
18:31:54 <Lajla> You will find that in recursive functions it simplifies a lot.
18:31:58 <danharaj> oop is nonsense.
18:32:00 <ddarius> dancor: Essentially.  There's an "alloca" function in the FFI, but it is just malloc underneath.
18:32:18 <geheimdienst> could you elaborate how having (-) evaluate to 0 is beneficial to recursion?
18:32:27 <ddarius> dancor: I don't see why that's a big deal.  Haskell is constantly allocating anyway.
18:32:49 <Lajla> geheimdienst, well,  for one, a recursive definition of that very subtraction operator
18:32:55 <Lajla> Is a lot simpler in that way.
18:32:57 <danharaj> Shouldn't the RTS reserve some heap for the program instead of calling malloc a whole lot?
18:33:03 <Lajla> Let's say we have a binary subtractor already called bin-sub
18:33:07 <danharaj> To amortize allocation overhead.
18:33:12 <dancor> ddarius: alloca won't keep seq allocated tho right?
18:33:16 <Kaidelong> Lajla: what's wrong with just using an explicit foldr to do this?
18:33:21 <ddarius> dancor: Correct.
18:33:25 <PetRat> I see it's a synonym for Parsec String (). What do the two type parameters to Parsec mean? Clear the first one means it takes String's as input.
18:33:33 <Kaidelong> foldr (-) 0
18:33:33 <dancor> it looks like i need to switch the C stuff so that midi_init() does a malloc() for seq
18:33:47 <Kaidelong> or catamorphism I suppose
18:33:51 <Lajla> {def (- . xs) (if (null? xs) 0 (bin-sub (car xs) (apply - cdr xs))}
18:33:54 <Kaidelong> if you prefer that term
18:33:59 <ddarius> PetRat: I think the second one for that is user state type.  Parsec is also a type synonym.
18:34:07 <dancor> but i'm not sure if there are alternatives that are better than that
18:34:27 <Lajla> Kaidelong, more expensive and more complex because you already have - as a primitive.
18:34:36 <Lajla> Also, I just don't like how - works in standard lisp.
18:34:36 <ddarius> dancor: You should be able to bind to C code without really having to write any C.  You should be able to do all the marshalling and setup in Haskell.
18:34:44 <Lajla> I feel much saver and more comfortable using it like this.
18:34:52 <Lajla> safer*
18:35:07 <geheimdienst> @remember Lajla	Also, I just don't like how - works in standard lisp.
18:35:07 <lambdabot> I will remember.
18:35:17 <ddarius> dancor: There's no trouble passing a pointer into midi_init.
18:35:24 <Lajla> It is the natural definition of course and functions become simpler, especiallyl recursive one's when using this one.
18:35:27 <Lajla> geheimdienst, why not?
18:35:45 <dancor> i'm just not sure how to allocate seq.  perhaps using mallocBytes
18:35:53 * ddarius doesn't know what "standard lisp" is.  Common Lisp? 
18:35:57 <Kaidelong> I'm completely lost as to why this makes anything easier
18:36:02 <geheimdienst> lajla, i was just telling lambdabot to remember your quote, because i think it's great and funny
18:36:05 <dancor> oh wait i can use malloc
18:36:25 <dancor> Foreign.Marshal.Alloc.malloc
18:36:27 <Lajla> In my version (exp) >> e, (exp x) >> e^x, (exp x y) x^(e^y) et cetera.
18:36:32 <augur> anyone know of any papers on or references for unification of partially specified structures?
18:36:35 <ddarius> dancor: Yep.
18:36:40 <Lajla> Ahhh
18:36:44 <Lajla> geheimdienst, why?
18:36:49 <Lajla> Is it that strange?
18:36:49 <ddarius> dancor: If you haven't already, I recommend you read the FFI spec.  It is reasonably short and rather readable.
18:36:58 <Lajla> I mean, you can't relaly generalize it.
18:36:59 <dancor> ok
18:37:04 <Lajla> Which goes against the spirit of lisp for some.
18:37:05 <geheimdienst> about your definition, i still think you're just sticking an implementation of map into the definition of (-)
18:37:20 <Lajla> That could be true, but + does the same.
18:37:28 <ddarius> geheimdienst: More like fold.
18:37:28 <Lajla> It's an analogy, and this version can be generalized better.
18:37:43 <augur> guess not :(
18:37:47 <Lajla> There's a reaosn that R5RS doesn't demand - and / for more than two arguments.
18:37:57 <Lajla> Because it's not a generealization at all, one and two arguments are two unrelated cases.
18:38:05 <Lajla> In my version, it's a recursive generealization
18:38:09 <geheimdienst> i'd express the semantics (- 5 10) = -15 as something like: sum . map (unary-minus) xs
18:38:33 <Kaidelong> geheimdienst: why not just foldr (-) 0?
18:38:39 <Lajla> geheimdienst, well, you're also invertng it (5 - 10) would be more common in the end.
18:38:45 <ddarius> geheimdienst: sum = foldr (+) 0, foldr f z . map g = foldr (f . g) z
18:39:09 <Lajla> Also (x < a b c d e  f) asks if x is smaller than all of the others, not that the rest is in some order too.
18:39:13 <Cale> What is this discussion about?
18:39:17 <Lajla> (< a b c d  ...) demands that they are in ascending order.
18:39:29 <Lajla> Cale, lisp interpretation.
18:39:34 <soupdragon> Cale language design hobbiest
18:39:38 <augur> Cale? do you know? :D
18:39:42 <dolio> It's about off-topic stuff.
18:39:58 <Kaidelong> Lajla: this doesn't sound easier at all
18:40:06 <ddarius> I agree with dolio.
18:40:11 <soupdragon> I usually like off-topic just this isn't my thing
18:40:27 <geheimdienst> cale, lajla is talking about a weird-ass subtraction operator which makes (- 5 10) = -15. this is supposed to have "benefits to recursion". i suspect it is an elaborate and very funny troll
18:40:40 <Kaidelong> why would (< a b) mean something different to (a < b)
18:40:44 <Cale> geheimdienst: It makes sense why you might want that
18:40:46 <soupdragon> geheimdienst: nah he's just enthusiastic about lisp
18:40:48 <Kaidelong> I mean
18:40:51 <Kaidelong> why would that be useful
18:40:55 <Cale> geheimdienst: In lispy settings :)
18:41:01 <Lajla> Kaidelong, that means the same.
18:41:05 <Lajla> Coincidentally.
18:41:06 <Cale> Though...
18:41:07 <ddarius> Cale: Which is why no lisp does it.
18:41:08 <EvanR> (- 5 15) is a hoax!
18:41:11 <Kaidelong> Concidentally.
18:41:14 <Lajla> But (< a b c) is different than (a < b c)
18:41:19 <Kaidelong> why
18:41:23 <ddarius> Anyway, what dolio said + #haskell-blah.
18:41:24 <Kaidelong> what do you gain from it
18:41:25 <Lajla> (x < y ...) asks if x is smaller than all y ...
18:41:40 <Lajla> As in (2 < 3 7 4 6 3 4) >> true
18:41:52 <Lajla> But (< 2 3 4 5 6 7 8)  >> true
18:41:53 <Lajla> You get.
18:41:56 <pikhq> Lajla: (x < y ...) passes < as an argument to x in Lispland. :)
18:41:57 <geheimdienst> what does (< 2 3 4 5) mean then?
18:42:01 <Cale> I actually am in the camp which says "screw this variadic stuff, let's just define the binary ones and use map/fold"
18:42:03 <Kaidelong> all (2 <)
18:42:04 <Lajla> pikhq, it does so here too.
18:42:06 <augur> Cale: unification of partial structures? :x
18:42:24 <pikhq> Cale: Makes Lisp syntax significantly simpler.
18:42:25 <Lajla> ोततAll objects except symbols really can be applied tos ome other objects.
18:42:31 <Kaidelong> > all (2 <) [3,4,5,6,7]
18:42:32 <lambdabot>   True
18:42:34 <augur> pikhq: pure lisp!
18:42:37 <Kaidelong> > all (2 <) [3,4,5,6,1]
18:42:38 <lambdabot>   False
18:42:39 <Lajla> Kaidelong, that is true of course.
18:42:49 <pikhq> Magically, you've just got tokens.
18:42:54 <EvanR> pure, typed, lisp!
18:42:54 <turiya> hi
18:42:56 <Lajla> (2 <) evaluates to true
18:42:59 <Lajla> (< 2) does too.
18:43:01 <Lajla> (<) too
18:43:04 <Cale> also, currying tends to be more useful, but I think negation is sufficiently important that the irregularity with regard to operator sections is worth it.
18:43:16 <EvanR> i hate considering random shit as a boolean value
18:43:23 <geheimdienst> lajla, what does (< 2 3 4 5) yield?
18:43:26 <Lajla> true
18:43:26 <EvanR> i like maintainability and compile time error checks
18:43:29 <Cale> I like how in Haskell (2 <) is a function.
18:43:41 <danharaj> Agda trumps everything.
18:43:43 <Cale> That's way more useful than evaluating to True
18:43:43 <danharaj> Mixfix
18:43:47 <Lajla> The point is that aksing if x is smaller than all members of some list is a common problem.
18:43:51 <soupdragon> Mixfix is /awful/
18:43:53 <turiya> there doesnt seem to be a data constructor for GHC.Ptr.Ptr, how to make a Ptr then?
18:43:54 <danharaj> which sounds like a sort of quickly prepared meal brand.
18:43:58 <stoltene2> Cale: Me too.
18:43:58 <Lajla> And rather than having to hand code a loop for this, now (apply x < lst) works
18:44:01 <ddarius> danharaj: There are languages that allow crazier things that Agda.
18:44:07 <ddarius> Syntactically.
18:44:08 <Lajla> Where lst can be (3 5 2 5 6 6 3 5) for instance
18:44:08 <danharaj> ddarius: I am afraid.
18:44:17 <Cale> Lajla: Then what you can do is to define a function which asks if some predicate is true of all elements of a list :)
18:44:22 <Kaidelong> Lajla: I actualyl had the same idea a while ago of default returns for 0 arguments but I remember going through some elaborate syntax to try to use it and coming to the conclusion that it wasn't worth the effort
18:44:32 <ddarius> turiya: You allocate one.
18:44:33 <EvanR> :t all
18:44:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:44:36 <Lajla> Cale, which will both be more expensive and not as easy.
18:44:36 <stoltene2> Woulnd't (- 1 2 3 4 5) be misleading anyway?
18:44:42 <Cale> Lajla: ?
18:44:49 <ddarius> Or rather you allocate some memory and get a Ptr to that memory.
18:44:50 <dancor> ddarius: i can't tell from the spec, is it possible for me to deal with snd_seq_t *seq without actually writing marshalling code for snd_seq_t?  I just need it be allocated and exist for the C funtions to use.
18:44:57 <Lajla> stoltene2, not if you're sued to it.
18:45:00 <Lajla> used*
18:45:17 <Cale> Lajla: In Haskell, we write  all (2 <) xs
18:45:21 <Lajla> I wouldn't come up with this if I didn't find it easier to work with, naturally I designed this to deal with some things which I find uneasy about lisp.
18:45:21 <Kaidelong> IE + 2 4 - 5 6
18:45:26 <Kaidelong> what does that mean?
18:45:29 <ddarius> dancor: If all you are doing is passing it to the C functions, then yes.  You can use a completely opaque (and meaningless) type.
18:45:36 <turiya> ddarius: how do i allocate memory?
18:45:38 <dancor> ok
18:45:49 <ddarius> turiya: Read the FFI spec.  Seriously.
18:45:51 <Lajla> Cale, I could write (apply all (curry < x) xs)
18:45:59 <Cale> I think most if not all Lisps fail to gain as much advantage from currying as they could.
18:46:12 <Lajla> Cale, well, they can't curry because functions are variadic.
18:46:17 <Lajla> But you have explicit curry operators
18:46:26 <soupdragon> partial application*
18:46:27 <Cale> Right, which is why I say drop the variadic stuff :)
18:46:45 <Lajla> Cale, well, you might as well stop list from being homo-iconic.
18:46:50 <Cale> Oh?
18:46:57 <Lajla> The whole reason it's variadic is because a function technically takes one argument, which is a list.
18:46:59 <Cale> Will that somehow damage homoiconicity?
18:47:01 * Kaidelong wonders what is wrong with just using iterators
18:47:08 <Cale> hmm
18:47:09 <Lajla> Well, it follows from it.
18:47:09 <aavogt> @type printf
18:47:10 <lambdabot> forall r. (PrintfType r) => String -> r
18:47:15 <soupdragon> a function doesn't take a list, you are confusing the implementation with the reality
18:47:16 <Lajla> Like, if you do (lambda xs body)
18:47:19 <Kaidelong> pass your arguments as an iterator, query the iterator for the next one until it runs out
18:47:22 <Lajla> Then xs is bound to the list of all your arguments
18:47:24 <Kaidelong> like, what we do in haskell right now
18:47:26 <aavogt> > printf "" 'a' 'b' 'c' 'd' :: String
18:47:26 <Kaidelong> seems sane to me
18:47:27 <lambdabot>   "*Exception: Printf.printf: formatting string ended prematurely
18:47:38 * ddarius hates the term "homoiconicity."
18:47:41 <Lajla> soupdragon, I beg to differ, you can access that list by using (define (f . xs) body)
18:47:49 <Lajla> You have xs bound to that list.
18:47:51 <Cale> ddarius: Why?
18:48:16 <Cale> Lajla: Well, that would change a bit.
18:48:21 * EvanR likes the word iconoclasm
18:48:25 <ddarius> Cale: It's meaningless.
18:48:38 <Cale> Lajla: Instead of a list, take the Haskell approach, and every function has exactly one argument which is an arbitrary value.
18:48:42 * Kaidelong wonders why haskell tends to specifically ask for lists rather than anything that can be iterated over, IE foldable
18:48:45 <Lajla> Cale, well, when people say that Scheme is functional, I disagree, the main differentiating quality of lisps is the interchangeability of code and data.
18:49:02 <EvanR> Kaidelong: or traversable
18:49:08 <Lajla> Cale, well, you could do that, every function taking an arbitrary value, which can also be a list.
18:49:08 <aavogt> Lajla: you can do curried variadic functions, provided there's some cue to know when the last argument is there (say a type annotation, if nothing else lets it be inferred)
18:49:09 <Cale> I'm pretty sure this doesn't harm that.
18:49:10 <Kaidelong> traversable is what I meant EvanR, thank you
18:49:11 <Lajla> Like (f . 3)
18:49:12 <pikhq> Lajla: Indeed, Lisps are metaprogramming languages.
18:49:14 <Cale> Lajla: right.
18:49:16 <EvanR> @src Traversible
18:49:16 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:49:22 <danharaj> functional is not a good descriptive word for languages.
18:49:27 <EvanR> Kaidelong: theres a Traversible class
18:49:29 <Lajla> aavogt, I rather do that explicitly than having to look up which functions curry.
18:49:32 <danharaj> Imperative vs. declarative is better, I think.
18:49:40 <Lajla> Besides, the point is that lisp also curries variadically.
18:49:41 <Kaidelong> EvanR: I know, doesn't Foldable imply it?
18:49:44 <Cale> Lajla: It's just we're going to make (f x y z) mean the same thing now as what (((f . x) . y) . z) presently does
18:49:47 <EvanR> Kaidelong: not sure
18:50:03 <Kaidelong> or was it the other way around?
18:50:08 <Lajla> Like (define (curry f . xs) (lambda ys (apply f (append xs ys))))
18:50:10 <ddarius> Cale: Why bother with parentheses then?
18:50:14 <Cale> Lajla: and so if you want a variadic function, you pass a list
18:50:15 <Kaidelong> I guess it obviously is, anything that you can traverse, you can fold
18:50:16 <pikhq> danharaj: And yet people use "structured" as a term still.
18:50:32 <Kaidelong> does it work the other way?
18:50:34 <ddarius> Er, nevermind.
18:50:36 <Lajla> If I do (curry + 1 2 3) I can apply that function like (f 1 2 3 4) to get 16
18:50:46 <pikhq> Even though you'd be hard-pressed to find a modern language without control structures.
18:50:57 <soupdragon> partial-apply*
18:51:11 <Lajla> Cale, well, that won't be the same actually.
18:51:21 <Lajla> It will be the same as (f . (x y z))
18:51:21 <Kaidelong> perhaps you can say that there are things that can be folded for which there is no unique correct way to traverse it?
18:51:27 <Lajla> Which incidentally is also what it already does.
18:51:38 <Lajla> (f x y z) is f applied to the list (x y z).
18:51:38 <Cale> Lajla: It'll be equivalent in terms of expressivity
18:51:49 <Lajla> Ahh, in that way.
18:51:50 <Cale> Lajla: But it'll make some things easier than others in an important way :)
18:51:58 <Lajla> Yeah, but you no longer then pass as a single argument a list.
18:52:18 <ddarius> Kaidelong: To answer your first question, it's just a bad cultural aspect of Haskell that will, hopefully, pass in the not distant future.
18:52:27 <Lajla> If (f . x) is passing f the single argument x, then  (f x y z) will not be passing f the single argument (x y z) under your model.
18:52:37 <Kaidelong> alrighty ddarius
18:52:46 <EvanR> if you really want across the board vector operations, use an array processing language, otherwise in lisp and haskell you are also using list juggling operations explicitly
18:52:56 <Cale> Kaidelong: What was your first question?
18:53:05 <EvanR> s/also/instead/
18:53:10 <Kaidelong> I asked why we do stuff on lists rather than traversibles
18:53:18 <Kaidelong> since you could easily get away with the latter
18:53:22 <Cale> Lajla: Right, it'll be passing x to f, and then passing y to the result of that (which will be a function), and then passing z to the result of that
18:53:40 <Cale> Lajla: Exactly like how we do things in Haskell :)
18:53:48 <Lajla> Cale, yes, I understand that, but it will then be a different thing than passing the list (x y z) to f.
18:53:54 <Cale> Of course, yes.
18:54:06 <Cale> and *then*
18:54:08 <geheimdienst> kaidelong, clojure has some ideas in that area. they use the "seq" interface for lists and anything else that can be iterated over
18:54:10 <geheimdienst> iirc
18:54:10 <Cale> after all this nonsense
18:54:14 <Lajla> Also, in lisp you don't need currying all that much by the way, because many functions are variadic they sort of do this on themselves.
18:54:26 <Cale> That I don't buy.
18:54:30 <Kaidelong> geheimdienst: that's because that's how Java does it. F# is the same way.
18:54:36 <Lajla> And just using (curry f ...) is not that much hazzle.
18:54:36 <Cale> You do need currying, you just don't know it ;)
18:54:48 <Lajla> Well, you can dos o explicitly, and many functiosn do it themselves.
18:54:51 <Cale> and writing (curry f ...) *is* too much hassle :)
18:55:06 <Cale> because you're competing with lambda
18:55:07 <Kaidelong> in F# you can use Seq.map etc on anything that is an instance of System.Collections.IEnumerable<T>
18:55:09 <EvanR> Kaidelong: its a library thing, youll find many more elaborate data structures export a traversible interface
18:55:11 <ddarius> geheimdienst: Most OO languages handle this better than Haskell does.
18:55:25 <Cale> The point of currying is to be more concise than lambda for partial application
18:55:25 <Lajla> In lambda it would be (lambda ys (f (append xs ys)))
18:55:32 <EvanR> Kaidelong: youll also see in haskell some list operations use Int rather than a generic Integral, there are generic alternatives there as well
18:55:36 <EvanR> :t genericLength
18:55:37 <lambdabot> forall b i. (Num i) => [b] -> i
18:55:39 <Kaidelong> EvanR: yeah, which is why I was wondering why we haven't written everything to work on that stuff already
18:55:41 <ddarius> geheimdienst: There's no real technical barrier.  Haskell programmers just don't program to interfaces as much as they could.
18:55:45 <Cale> (Well, one point)
18:55:47 <Lajla> Cale, yes, but you lose variadic functions which you then have to use a list for.
18:55:55 <danharaj> oh no.
18:55:57 <Kaidelong> but I need to leave
18:55:57 <Lajla> And variadic functions are faaar more common in lisp style coding than curying.
18:56:01 <EvanR> Kaidelong: backwards compatability, i guess, no one sees a significant need?
18:56:02 <Cale> Kaidelong: In my view the reason is that lists are essentially loops
18:56:06 <Lajla> I had to do (f (list x y z))
18:56:12 <Lajla> Or (+ (list x y z))
18:56:15 <Lajla> For just (+ x y z)
18:56:25 <Cale> Kaidelong: The answer to why lists are popular in Haskell programs is the same as the answer to why loops are popular in imperative programs.
18:56:29 <Kaidelong> Cale: but any function that works on a traversible can work on a list anyway, right?
18:56:33 <ddarius> EvanR: Traversable (not spelling) is also rather new.
18:56:34 <danharaj> Variadic functions are semantically shoddy.
18:56:36 <Kaidelong> so it doesn't really matter
18:56:41 <Cale> Kaidelong: But not the other way.
18:56:46 <Lajla> Cale, right on.
18:56:48 <geheimdienst> lajla, what does that have to do with currying?
18:56:50 <EvanR> ddarius: i figured
18:56:59 <Lajla> So many people use tail recursion to imitate loops from a procedural style when they should use map.
18:57:04 <ddarius> s/not/note
18:57:14 <EvanR> loops for computation are dumb
18:57:14 <Lajla> geheimdienst, you can't have currying and variadic functions at the same time.
18:57:33 <EvanR> we aint using assembly language
18:57:34 <Lajla> So you have to replace variadic functions by supplying them in a list.
18:57:41 <danharaj> Why is that a bad thing?
18:57:48 <Lajla> Also, + would have to recognise if its first argument is a list or a number.
18:57:49 <geheimdienst> yes, you need some syntax to distinguish those
18:57:50 <Kaidelong> Lajla: I found a paper I liked regarding the writing of loops... "Programming haskell with bananas, barbed wire, and boxes" or something
18:57:52 <danharaj> Supplying a list of arguments makes sense. It makes explicit the semantics of the function.
18:57:53 <Kaidelong> forgot the exact name
18:57:58 <Lajla> As in (+ 1) curries, (+ (list 1 2 3)) returns 6.
18:58:02 <Twey> Kaidelong: Envelopes
18:58:07 <Kaidelong> brb
18:58:10 <Twey> It's very famous.  :þ
18:58:19 <Lajla> And variadic functions are faaar more commonly used in lisp style than currying.
18:58:20 <Twey> Also, lenses, I think
18:58:26 <ddarius> Kaidelong: There is a sense that lazy lists are almost exactly equivalent to IEnumarable and that partially explains and justifies their ubiquity.  But there are plenty of other examples where Haskell programmers program to concrete types rather than interfaces.
18:58:30 <EvanR> Lajla: i hate using the same name for different things
18:58:31 <Twey> http://wwwhome.cs.utwente.nl/~fokkinga/mmf91m.ps
18:58:32 <Cale> Lajla: Well, you could write sum so easily then, that the variadic thing is almost not necessary :)
18:58:33 <ddarius> (for no good reason)
18:58:44 <Lajla> Cale, how?
18:58:55 <Lajla> (+ (list 1 2 3 4))?
18:58:57 <Cale> (define sum (foldr (+) 0))
18:59:13 <Lajla> You still had to destinguish between sum and +
18:59:16 <Cale> sure
18:59:23 <Cale> I prefer that to overloading (+)
18:59:24 <Lajla> The idea of variadic functions is that that is usually known at runtime only.
18:59:31 <Lajla> How many you ŕe going to have.
18:59:35 <Lajla> 2 or 3
18:59:38 <Lajla> or 1
18:59:48 <tensorpudding> you don't get free partial application in Lisp do you?
18:59:57 <Lajla> So effectively, in your model, you have no real need for + anymore above sum except for currying
19:00:06 <Lajla> And you can just define a new function that curries +
19:00:09 <Lajla> Like c+
19:00:11 <Cale> Well, for adding pairs of numbers
19:00:17 <Lajla> Which is just a makeadder
19:00:20 <geheimdienst> tensorpudding, if free = without typing, then generally not
19:00:26 <Lajla> Cale, but you don't know at runtime how many numbers you're goig to add.
19:00:29 <Lajla> AT compile time*
19:00:36 <Lajla> You only know at runtime.
19:00:36 <Cale> Lajla: Then you'd use foldr
19:00:38 <EvanR> most of the time i add two numbers
19:00:38 <Lajla> It's variadic.
19:00:44 <Lajla> Cale, then what use does + still have?
19:00:50 <Lajla> If you end up using foldr the entire time?
19:00:54 <Cale> Lajla: adding pairs of numbers
19:00:56 <Lajla> Which is also a lot more expensive.
19:01:04 <Lajla> Cale, but you never know if it's going to be a pair!
19:01:07 <Cale> huh?
19:01:10 <Cale> Sure
19:01:16 <Cale> Look at all the places in Haskell where we use (+)
19:01:21 <Cale> rather than sum
19:01:22 <Lajla> Cale, that's a different style.
19:01:31 <Lajla> You almost never see (+ x y) in lisp coming by.
19:01:32 <Cale> Right, I'm suggesting a different style.
19:01:35 <ddarius> Cale: Can you and Lajla take this to #haskell-overflow or something.
19:01:40 <Cale> sure.
19:02:15 <tensorpudding> what I essentially meant was that you could treat something like (cons x) as a function
19:02:48 <EvanR> it would be strictly evaluated and error out, right
19:03:21 <EvanR> not enough parameters to built in function
19:07:24 <EvanR> tensorpudding: could wrap it in a lambda ;)
19:07:45 <tensorpudding> You could painstakingly write it in a curried form
19:07:54 <tensorpudding> lambdas that return lambdas
19:08:11 <tensorpudding> but if you wanted to call it with all the arguments, you'd have to make a mess of parentheses
19:08:16 <ddarius> (define (flip f) (lambda (x) (lambda (y) (f y x))))
19:08:23 <dancor> ddarius: snd_seq_t is a C "incomplete type" so i don't think i can ever do the allocation correctly in haskell
19:08:38 <turiya> ddarius: i am not sure if the FFI will help me..
19:08:55 <ddarius> turiya: All the malloc stuff is in the FFI.
19:08:59 <EvanR> tensorpudding: exactly how church envisioned it ;)
19:09:21 <turiya> i was trying to construct a PixelData
19:09:38 <EvanR> unfortunately we dont have lambda character on the keyboard
19:09:44 <tensorpudding> I don't have a scheme installed.
19:10:37 <ddarius> dancor: I think c2hs could handle it right, but it's probably easiest to write a function that malloc's it for you and bind to that.
19:10:45 <Entroacceptor> äasä
19:11:01 <dancor> ddarius: actually i'm not sure how to malloc in C either, sizeof fails on it
19:11:29 <OrangeSky> Does Haskell have any support for process isolation?
19:11:34 <ddarius> dancor: You don't need a pointer to it for midi_init though.  You need a pointer to a -pointer-.
19:11:42 <dancor> mm
19:11:45 <dancor> i see
19:12:49 <ddarius> data SndSeqT;  foreign import midi_init :: Ptr (Ptr SndSeqT) -> IO (); foo = do p <- malloc; midi_init p;
19:13:00 <ddarius> Pseudoish code.
19:13:41 <ksf> OrangeSky, "process isolation"?
19:13:43 <ddarius> p will have type Ptr (Ptr SndSeqT) use peek from Storable to get the Ptr SndSeqT.
19:13:52 <monochrom> foreign import ccall safe {- or unsafe, your call -} "midi_init" midi_init :: ...
19:14:43 <ksf> OrangeSky, House can run arbitrary binaries and protect them via memory mapping, so, in a sense, yes.
19:14:50 <OrangeSky> House eh
19:14:51 <monochrom> (because I was reading and writing about ffi just a few hours ago)
19:15:21 <ksf> but usually no, 'cos that's the responsibility of the operating system...
19:16:04 <ksf> that is, you can, of course, exec some process and then ipc as you wish.
19:16:09 <ddarius> "He got mad 'cos she left him 'sin he cheated."
19:16:34 <OrangeSky> ksf: Yeah, something more like that... just wondering if there are some nice interfaces for that or if I'll have to roll my own...
19:17:01 <OrangeSky> haskell-ipc eh
19:17:45 <ksf> there's some serialisation libraries that are both fast and binary and largely boilerplate-free
19:18:13 <ksf> the need isn't big in haskell, though, as haskell programs usually don't crash
19:19:39 <EvanR> hahahaa ;)
19:20:00 <monochrom> ⊢a∧b⇒a cos a∧b⊢a cos a,b⊢a cos a⊢a
19:20:22 <dons> ?yow
19:20:23 <lambdabot> Couldn't find fortune file
19:20:33 <monochrom> "sequent cosculus"
19:20:45 <ksf> @quote crash
19:20:45 <lambdabot> gwern says: actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
19:20:46 <soupdragon> secant calculus
19:20:50 <soupdragon> :D
19:20:52 <Veinor> ddarius: you know how sarah palin wouldn't let her kid abort trig? bristol has to pay her sin cos secant use birth control?
19:20:55 <Veinor> :D
19:20:58 <ksf> @quote crash
19:20:58 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
19:21:04 <ksf> @quote crash
19:21:05 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
19:21:07 <ksf> @quote crash
19:21:07 <lambdabot> shapr says: there's an important niche market for OSes that don't crash.
19:21:17 * geheimdienst thinks every fortune file, somewhere in the middle, should include the line "ENOTFOUND: Could not find fortune file"
19:22:16 <monochrom> haha
19:25:22 <OrangeSky> Hmm alright then, if I use direct-plugins, is there any way to reload the package? 
19:25:54 <monochrom> unfortunately no
19:26:02 <OrangeSky> hmm
19:26:02 <OrangeSky> what if I bumped the version number or something
19:26:17 <monochrom> then yes you can load the new version
19:26:32 <OrangeSky> would that GC the old version/
19:26:36 <monochrom> no
19:26:46 <OrangeSky> oof
19:27:03 <OrangeSky> guess I'll go for processes then
19:27:04 <monochrom> otoh it doesn't look like ghci reload frees any memory either
19:28:18 <monochrom> there was an incomplete ticket reporting that ghci keeps growing memory use unbounded if you reload too much, but it remains incomplete for lack of reproduction procedure
19:29:57 <monochrom> presumably this is the doing of ghc-api. when I tried hs-plugins (I had ghc 6.8 and 6.10) I observed the memory growth too with repeated unload and load.
19:30:04 <Kaidelong> deriving (Functor, Monad, MonadTrans, MonadIO)
19:30:13 <Kaidelong> I thought deriving only worked on certain fixed types?
19:30:38 <aavogt> there's an extension for newtypes
19:31:10 <Kaidelong> aavogt: GeneralizedNewtypeDeriving?
19:31:17 <aavogt> yes
19:31:45 <Kaidelong> cool
19:32:08 <monochrom> I am out of touch with ghc api. I would write some code to directly call ghc api to repeatedly load and unload to prove the point.
19:32:09 <Kaidelong> I just wish the people writing this would document what deriving ends up doing in their case
19:32:16 <Kaidelong> or well, document the code at all
19:32:44 <monochrom> perhaps if you people wait for another year I may get around to doing it :)
19:34:42 <aavogt> Kaidelong: compile with: -ddump-deriv ?
19:35:02 <aavogt> (I have no idea whether that does anything useful with -XGeneralizedNewtypeDeriving)
19:35:03 <Dashkal> Kaidelong: deriving that way simply brings the implementation on whatever the newtype is wrapping forward.  It does whatever it did on the wrapped object
19:35:51 <Kaidelong> Dashkal: exactly, you're calling something defined elsewhere, and it may not be obvious what you are doing
19:35:53 <turiya> how to create Ptr out of an existing list in Haskell?
19:36:24 <Kaidelong> although there aren't really comments anywhere else
19:36:24 <tg_afk> :t Ptr
19:36:25 <lambdabot> Not in scope: data constructor `Ptr'
19:36:35 <Dashkal> Kaidelong: Well, the type you're wrapping is obvious at the newtype declaration.  One hop from there to find out what it does.  Otherwise you just end up copy-pasta documentation on the instances.
19:36:36 <tg_afk> no such luck, i guess
19:37:30 <Axman6> turiya: i'm not sure that question makes much sense. do you want an array with the elements of the list in it?
19:37:37 <Dashkal> And also, when using typeclasses such as Functor, that it does (so long as it was implemented correctly in the first place) is obvious anyway.
19:37:50 <monochrom> Foreign.Marshal.Array.newArray :: Storable  a => [a] -> IO  (Ptr  a)
19:38:00 <Dashkal> s/that/what
19:38:04 <turiya> Axman6: yes, as some opengl functions accept only Ptr's
19:38:08 <Axman6> monochrom++
19:38:20 <Axman6> turiya: pointers to what though?
19:38:57 <monochrom> there is also the safer withArray :: Storable  a => [a] -> (Ptr  a -> IO  b) -> IO  b.  safer means proper deallocation in case of exception
19:39:00 <turiya> byte pointers
19:39:02 <aavogt> Kaidelong: haddock does documentation for instances now... maybe it could (or does)  forward the docs from the underlying instance
19:39:33 <aavogt> if it doesn't do that, maybe that could be a sensible thing to request
19:39:51 <turiya> monochrom: thats looks like it will do the job..
19:42:12 <dkc> hi: i'm getting a ghc error i don't understand: `OptClass' is applied to too many type arguments
19:42:12 <dkc>     In the definition of data constructor `OptField'
19:42:48 <Axman6> we'll need to see the code to be able to help you
19:43:01 <turiya> monochrom: thanks
19:43:11 <dkc> sure ... will paste
19:45:14 <dkc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27229
19:45:38 <dkc> do you think it literally means that my class has too many instances? like there's some arbitrary maximum?
19:45:44 <Axman6> uh wow
19:45:49 <dkc> haha sorry
19:45:54 <dkc> just search for OptClass
19:46:37 <Axman6> what's the point of having empty classes?
19:46:41 <monochrom> shouldn't you at least say "class OptClass a"?
19:46:52 <monochrom> similar for all other type classes.
19:46:52 <Axman6> yeah, good point
19:46:53 <dkc> yes that might be it
19:47:05 <Axman6> they should all be class X a
19:47:38 <dkc> yep that solved it
19:47:45 <dkc> thanks!
19:48:05 <dkc> the reason for having it, btw, is to allow me to have a list with some arbitrary mix of types in it
19:48:44 <Axman6> why not just make them all the same datatype?
19:49:07 <dkc> each class is basically used as a set, with 'instance' meaning set membership
19:49:23 <dkc> because i want different types to be allowed to use different subsets
19:49:50 <dkc> for example: level1 messages and option messages are almost the same, but option messages can't have a 'last exchange' element
19:55:16 <dkc> what about this error: Inferred type is less polymorphic than expected
19:55:37 <dkc> it happens when I define a function 'unOpt (OptField a) = a'
19:56:03 <ksf> it means that you're using compiler extensions you don't understand
19:56:27 <ksf> ...either ExistentialQuantification or GADTs
19:56:46 <ksf> and what you're trying to do doesn't work without Data.Dynamic
19:57:41 <dkc> uh-oh
19:58:22 <dkc> it's existentialquantification, and you're right, i don't
19:58:57 <om-foxy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27226#a27226
19:59:07 <ksf> so you have data Opt = OptField forall a . a | Foo ...
19:59:11 <monochrom> with existential type, you can't do "unOpt (OptField a) = a", it is forbidden. it would amount to downcasting.
19:59:44 <ksf> the problem is that what allows you to write "a" there also limits the scope of the a. you can't move it out.
19:59:59 <monochrom> what you can do: add methods to type class OptClass, then just call those methods.
20:00:27 <dkc> aha
20:00:38 <monochrom> example: class OptClass a where mymethod :: a->Integer
20:00:53 <monochrom> myoperation (OptField a) = mymethod a
20:00:58 <monochrom> Then it is allowed.
20:01:03 <ksf> or say data Opt a = OptField a | Foo
20:01:52 <ksf> but that would most likely amount to fundeps
20:01:52 <dkc> so for every instance of OptClass, i'll need to write a an unOpt?
20:02:02 <ksf> ...at which time I would rather do it with type families.
20:02:22 <aavogt> you don't know anything about which type you have inside your OptField
20:02:28 <monochrom> write methods that make sense for every instance of OptClass
20:03:07 <aavogt> there's no restriction on those functions being typeclass methods
20:04:10 <dkc> ok
20:04:15 <dkc> ...
20:04:23 <dkc> there really has to be a more elegant way to do this
20:04:34 <dkc> i'm coding largely via regexp at this point
20:04:47 <monochrom> oh but it's specifically data OptField = forall a. OptClass a => OptField a
20:04:49 <tolkad> what's the type signature of a function with it's argument being a mutable vector (Data.Vector.Generic.Mutable.MVector) that does some write operations on the vector?
20:05:53 <dkc> monochrom: yes
20:06:42 <dkc> should i just completely give up on trying to encode all this via the type system, and do it in maps or something instead?
20:07:41 <tolkad> Uh what about (Data.Vector.Generic.Mutable.MVector x a => x -> IO ())?
20:08:46 <Axman6> not x a -> IO ()?
20:08:50 <aavogt> how does it know how to index the vector?
20:09:23 <aavogt> :k Monad
20:09:24 <lambdabot> Class `Monad' used as a type
20:09:53 <aavogt> unfortunate that it doesn't "know what I mean" there
20:10:53 <dobblego> (* -> *) -> *
20:13:11 <om-foxy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27226#a27231
20:24:22 <om-foxy> Dependent types: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27226#a27232
20:36:19 * ksf is still waiting for that lucid oleg-post which will prove that haskell had dependent types all along, we just didn't notice.
20:36:34 <gogonkt> kk
20:36:55 <davekong> is there some way to make ghci print newlines rather than \n when showing a String?
20:37:21 <ksf> putStr?
20:39:06 <davekong> ksf: yea that works, thanks
20:40:27 <Cale> (or putStrLn if you still want the newline at the end)
20:40:31 * hackagebot gnome-keyring 0.2.2 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.2.2 (JohnMillikin)
20:41:32 * hackagebot gnome-keyring 0.2.2.1 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.2.2.1 (JohnMillikin)
20:50:53 <ivanm> *sigh* I hate trying to work out what the best API to export would be
20:52:48 <monochrom> what do you use personally? export those. then let the community ask for more.
21:03:11 <kniu> @hoogle forkIO
21:03:12 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
21:03:34 <ivanm> is there any way of writing a function which does different things by testing dynamically if a value is part of a class?
21:04:07 <ivanm> e.g. a `maybeShow' function, which for () will return Nothing, if the value is an instance of Show will do Just (show x) and otherwise return Nothing
21:07:19 <ddarius> ivanm: Earlier I made a little class that would allow something akin to that, but not quite so transparent.
21:08:16 <ddarius> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27220#a27224
21:08:30 <ivanm> well, my thing with trying to use a class to do that is that saying something like "instance Foo a where foo = const Nothing" means that you can't add anything else to that class, doesn't it?
21:10:07 <davekong> I have a function in a where statement with an argument which is not used but if I delete it the larger function fails
21:10:10 <davekong> how does that make sense?
21:10:34 <soupdragon> probably something to do with the types
21:10:36 <ksf> ivanm, does overlapping work?
21:10:54 <ivanm> ksf: haven't tried yet
21:11:05 <ddarius> davekong: Your statement is ambiguous.  Nevertheless, in either interpretation I can think of multiple ways that that "makes sense."
21:11:15 <ksf> if not, wait for byorgey's kind magic.
21:11:16 <davekong> let me paste it
21:11:42 <ddarius> White Wizard Yorgey
21:12:28 <davekong> http://codepad.org/jP6TlOz6
21:12:49 <ivanm> ddarius: what's that class of yours meant to be doing there?
21:12:56 <ksf> I've got the feeling that the TypeFam vs. FunDep issue has been resolved in favour of TypeFams
21:13:26 <ivanm> ksf: there are a few cases where fundeps are currently nicer
21:13:39 <ivanm> e.g. generalizednewtypederiving fails with TFs :(
21:13:50 <davekong> so what is happening with z?
21:13:53 <ivanm> davekong: which do you try to remove?
21:14:13 <davekong> ivanm: z
21:14:16 <ksf> davekong, nothing.
21:14:17 <ivanm> davekong: oh, because you're using row as a function
21:14:22 <ksf> nothing at all
21:14:29 <ivanm> davekong: you have "row i" in your list comprehension
21:14:35 <ivanm> if you remove that i there, then you can remove the z
21:15:17 <ksf> or you can replace j with z.
21:15:20 <davekong> so row i is mathcing row z?
21:15:29 <ivanm> yeah
21:15:32 <ksf> ...and forget about the j <- [1..n]
21:15:38 <ddarius> ivanm: The question that prompted it was how to dynamically check for support of any combination of multiple classes.  A naive ADT solution would have 2^n branches for supporting n different classes.  This way requires only n methods of the kind demonstrated in the paste.
21:15:49 <ivanm> ksf: he still needs to take a value in, since it's being used as a function
21:16:16 <ivanm> ddarius: hmmm...
21:16:20 <ivanm> and what's NumProof?
21:16:29 <ddarius> ivanm: Also, that particular solution does so in a way that allows using the Num instance pretty trivially (as opposed to say passing a dictionary or the earlier solution not using type equality).
21:16:50 <ddarius> ivanm: A proof that a in NumProof a is an instance of Num.
21:17:13 <ddarius> It locally brings in the Num instance so that it can be used branches that match on NumProof.
21:17:55 <ivanm> hmmm....
21:18:17 <ivanm> and the type equality bit is just to say that yes, there is a numeric type that is the same as this?
21:18:20 <ddarius> The last code doesn't really demonstrate combinations, but it is easy to see what would need to be added.
21:19:05 <davekong> ksf: that j with z thing made it not work right
21:19:43 <ksf> you'd have to delete the j <- [1..n] , too, or you get too many invocations
21:19:55 <davekong> but the other suggestion works
21:20:10 <ivanm> ddarius: but foo still needs to state the type class?
21:20:18 <ddarius> ivanm: The type equality constraint is to say that yes the type parameter is the same as the hidden type.  Really it is "only" necessary because I can't just directly stick the Num dictionary in there.
21:20:26 <ivanm> *nod*
21:20:29 <davekong> ksf: that is what I did.. then it just prints one coloumn and now the rest of them
21:21:15 <ksf> well yes you're only indexing row 1
21:21:20 <ddarius> foo doesn't say anything about Num, but yes, it does have to be given a "capability" to query for support of various interfaces.
21:21:20 <ksf> ... (1, z)
21:21:31 <ivanm> *sigh*
21:22:09 <ksf> gragh I hate list comprehensions
21:22:31 <davekong> ksf: this prints a matrix as is rows and coloumns NxN
21:22:33 <ivanm> and I can't find anything in Data.Dynamic or Data.Typeable that suggests a way to determine if something is in a class that way...
21:23:01 <ivanm> and it's not possible to say "instance (Num a) => Supports a where ..." as well as "instance Supports a where ..." :s
21:23:28 <ddarius> There are tricks that allow things sort of like that, but they'd probably end up moving the problem elsewhere.
21:23:49 <ivanm> yeah :(
21:24:14 <ksf> closed type families could do that
21:24:36 <ivanm> is it possible to do something like this with a generics library or something?
21:24:42 <ivanm> ksf: care to provide an example?
21:25:04 <ksf> well, actually there are sane ways to do it with oupen families or classes, too, but I don't know how that would work on the implementation side
21:25:27 <ddarius> ivanm: http://okmij.org/ftp/Haskell/types.html#class-based-overloading
21:25:32 <ksf> ivanm, the idea is that if families are closed, you can do fall-through matching as in usual functions
21:25:45 <ddarius> I'll have to reread that to see if it is useful.
21:26:24 * ivanm has a look at http://okmij.org/ftp/Haskell/class-based-dispatch.lhs
21:26:34 <ivanm> ksf: hmmm....
21:27:01 <ivanm> hi bos 
21:28:03 <bos> morning
21:28:45 <ivanm> bos: would I be able to impose on you to do another patch on criterion? this one is only one line...
21:28:59 <ivanm> http://code.haskell.org/gentoo/gentoo-haskell/dev-haskell/criterion/files/criterion-0.5.0.0-wide-character.patch
21:30:24 <bos> ivanm: it's already fixed
21:30:27 <ivanm> ddarius: hmmm, the static approach you linked to seems to work (the dynamic approach seems to require explicit instances)
21:30:30 <ivanm> bos: oh? cool
21:30:41 <ivanm> didn't seem to have been fixed in the latest version, that's all
21:31:18 <ddarius> The static approach described still requires you to enumerate the instances.  As expected, the bump in the rug just moves elsewhere.
21:31:52 <ivanm> oh, damn, do you need to do explicit instances for ShowPred? :@
21:31:54 <bos> ivanm: yeah, i didn't release a new version with the changes yet
21:31:59 <ivanm> bos: good-o
21:32:15 <ddarius> ivanm: If the static approach had worked you'd be able to combine it with my approach in the paste to get a nice overall approach.
21:32:19 <nettok> > take 10 fib
21:32:21 <lambdabot>   [1,2,3,5,8,13,21,34,55,89]
21:32:22 <ivanm> yeah
21:32:42 <ivanm> nettok: that doesn't look like fibonacci to me... you're missing the first one!
21:33:01 <nettok> you're right
21:33:10 <ivanm> did you @let fib?
21:33:41 <ivanm> ksf: still not sure what you mean, sorry :s
21:33:51 <nettok> yep
21:34:08 <nettok> how do i @let it again? it says is already defined
21:34:20 <ddarius> @undefine
21:34:20 <ivanm> @undefine
21:34:32 <ivanm> nettok: also, is there any need for you to @let such a trivial definition?
21:34:48 <ivanm> if you want to experiment with lambdabot, why not just use "> let fibs = ... in ..." ?
21:34:59 <ivanm> ddarius: this also seems to require explicit instances IIUC: http://okmij.org/ftp/Haskell/is-of-class.hs :(
21:36:01 <nettok> ivanm: i'll try that, thanks
21:38:51 <ddarius> Bah the type equality isn't even necessary in NumProof.  That's what I get for not using GADTs much.
21:38:56 <ivanm> lol
21:40:13 <ksf> ivanm, bluntly put, if Num a => Foo a would be written before Foo a , then it would work, if you'd write it the other way round, not.
21:40:31 <ksf> ...just like with ordinary pattern matching, but extended with typeclass constraints.
21:41:09 <ivanm> care to provide an example?
21:41:18 <ivanm> I've never done much with TFs, just ATs
21:41:19 <ksf> we don't have closed type families.
21:41:22 * ddarius still needs to finish the OutsideIn(X) paper.
21:41:23 <ivanm> ahhhh
21:41:31 <ivanm> so this isn't possible :(
21:41:35 <ddarius> He as teasing you all along.
21:41:41 <ivanm> grrrr.....
21:41:51 * ivanm stares grumpily at ksf 
21:41:58 <ksf> <ksf> closed type families /could/ do that
21:41:58 <ivanm> ddarius: what paper is that?
21:42:05 <ksf> IFF we had them.
21:42:26 <ivanm> well, I took that as being "they could do that if you implemented the ability to do that"
21:42:30 <ddarius> ivanm: http://www.haskell.org/haskellwiki/Simonpj/Talk:OutsideIn
21:42:36 <ksf> yes!
21:42:40 <kniu> @hoogle bracket
21:42:40 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:42:40 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:42:40 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:42:42 <ksf> exactly. report at once in #ghc.
21:44:04 <ivanm> ksf: not implement closed type families, implement a function/class to do this
21:46:38 <ivanm> *sigh* another problem I've come across: I want to provide a default implementation of a class method, but that requires constraining some of the types of the class, which might not be needed in some cases
21:47:22 <ClaudiusMaximus> wow, it's actually cheaper (in both time and memory) for me to convert my list of (Foo,Double) to an Array of Foo and a list of (Int,Double), FFI to C's qsort to sort that list then lookup the Foo's from the Array again...
21:47:25 <ksf> associated types?
21:47:36 <ksf> hmmm. dunno if you can have defaults, there.
21:47:43 <ksf> but I guess it's worth a try.
21:47:54 <ksf> you should get to terms with typefams, anyway.
21:48:03 <ivanm> I use ATs in classes
21:48:12 <ivanm> but I don't think they'd help with this
21:48:23 <ksf> ivanm, try this: http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
21:48:49 <ivanm> e.g. "class Equivalent a where eq :: a -> a -> Bool"; a nice default would be just (==), but that means that if you want to test for equality on hashing or something then you're instantly constrained
21:48:57 <ivanm> ksf: read that
21:49:05 <ksf> if you can default the types, you can use type family invocations in the default function
21:49:29 <ivanm> can't default the types really though...
21:49:33 <ksf> :t (==)
21:49:34 <lambdabot> forall a. (Eq a) => a -> a -> Bool
21:49:47 <ksf> in which way do Equivalent and Eq differ?
21:50:07 <ksf> *what
21:50:33 <ksf> argh damn idioms. /me goes on and redefines english.
21:54:10 <ivanm> ksf: say I test if two values are equal using "(==) `on` hash" rather than testing their equality directly
21:54:29 <ivanm> or, in terms of graphs, I might want to do equality testing on isomorphisms
21:54:40 <ivanm> this is admittedly a rather bad example, but it's the simplest one I could think of
21:56:00 <kniu> @hoogle assert
21:56:01 <lambdabot> Control.Exception assert :: Bool -> a -> a
21:56:01 <lambdabot> Control.OldException assert :: Bool -> a -> a
21:56:01 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
21:59:19 <kniu> @hoogle m ()
21:59:20 <lambdabot> Network.BSD endHostEntry :: IO ()
21:59:20 <lambdabot> Network.BSD endNetworkEntry :: IO ()
21:59:20 <lambdabot> Network.BSD endProtocolEntry :: IO ()
21:59:48 <kniu> @hoogle (m ())
21:59:48 <lambdabot> Network.BSD endHostEntry :: IO ()
21:59:48 <lambdabot> Network.BSD endNetworkEntry :: IO ()
21:59:48 <lambdabot> Network.BSD endProtocolEntry :: IO ()
22:01:55 <ClaudiusMaximus> hmm...  newtype EqEq a = EqEq{ deqeq :: a } ; instance Eq a => Equivalent (EqEq a) where eq = (==) `on` deqeq
22:02:13 <ivanm> ClaudiusMaximus: I did say it was a stupid example
22:02:21 <ivanm> (not to mention contrived)
22:02:28 <ivanm> OK, you want a better example?
22:02:38 <ClaudiusMaximus> i'm not too bothered :)
22:02:47 <ivanm> "class Graph g where ... isDirected :: g a b -> Bool"
22:03:26 <ivanm> I have a default definition for isDirected that requires b to be in Ord; however, some graph types might have the directivity (what's a better word for that?) built-in as part of the graph definition
22:03:32 <ivanm> and as such wouldn't require that Ord constraint
22:03:53 <ClaudiusMaximus> hm
22:04:03 * hackagebot bloomfilter 1.2.6.5 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-1.2.6.5 (BryanOSullivan)
22:04:06 <ClaudiusMaximus> that does make more sense
22:04:36 <nettok> fib stop =
22:04:36 <nettok>     let fib' stop a b = a : if b < stop
22:04:36 <nettok>                                 then fib' stop b (a + b)
22:04:36 <nettok>                                 else []
22:04:36 <nettok>     in 1 : fib' stop 1 2
22:04:51 <nettok> what do you think about my fib implementation?
22:05:11 <nettok> sorry about the big paste, next time i'll use pastebin :S
22:05:22 <ivanm> nettok: better off to ignore the whole "stop" thing
22:05:25 <ivanm> and just use a takewhile
22:05:28 <ivanm> *takeWhile
22:06:18 <ivanm> > let fibs = let fib' a b = a : fib' b (a + b) in fib' 1 1 in takeWhile (< 10) fibs
22:06:19 <lambdabot>   [1,1,2,3,5,8]
22:06:23 <ivanm> nettok: ^^
22:06:24 <ClaudiusMaximus> ivanm: can you just put your ordIsDirected in the same place for instances to use if they want/can?
22:06:28 <ivanm> or, even better:
22:06:39 <Kaidelong> > fibs = 1 : scanl (+) 1 fibs in takeWhile (< n) fibs
22:06:40 <lambdabot>   <no location info>: parse error on input `='
22:06:42 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (< 10)  fibs
22:06:43 <lambdabot>   [1,1,2,3,5,8]
22:06:44 <Kaidelong> > fibs = 1 : scanl (+) 1 fibs in takeWhile (< 10) fibs
22:06:45 <lambdabot>   <no location info>: parse error on input `='
22:06:57 <Kaidelong> > let fibs = 1 : scanl (+) 1 fibs in takeWhile (< 10) fibs
22:06:58 <lambdabot>   [1,1,2,3,5,8]
22:07:24 <nettok> ivanm: i also thought about that, but it made sense to add stop to solve project euler's problem #2
22:08:05 <ivanm> ClaudiusMaximus: sure, but even then I have the dillema: does that mean the whole graph needs to have that constant constraint (so it can't be used with function labels or something), or should I enforce that constraint on the function (which is useless for graph types that know about directivity) ?
22:08:22 <ivanm> nettok: oh, this is for PE? bah!
22:08:49 <ivanm> preflex: seen Cale 
22:08:49 <preflex>  Cale was last seen on #haskell 1 hour, 28 minutes and 22 seconds ago, saying: (or putStrLn if you still want the newline at the end)
22:09:06 <nettok> ivanm: I am learning haskell solving the problems
22:09:20 <ivanm> nettok: I highly suggest you learn haskell by going through tutorials
22:09:26 <nettok> or thats the idea...
22:09:29 * ivanm has flashbacks to Haskelllove...
22:09:35 <Kaidelong> :t even
22:09:36 <lambdabot> forall a. (Integral a) => a -> Bool
22:09:54 <Kaidelong> > let fibs = 1 : scanl (+) 1 fibs in sum . filter even . takeWhile (< 1000000) $ fibs 
22:09:56 <lambdabot>   1089154
22:10:46 <nettok> I'll am also reading "learn you a haskell" :)
22:11:18 <ddarius> will i am
22:11:22 <ivanm> as long as you're also doing tutorials
22:11:39 <ivanm> ddarius: I thought you were called "Derek" (or at least that's what /whois says...)
22:11:42 <ivanm> not "Will"
22:12:20 <ManateeLazyCat> Wow, i found http://hackage.haskell.org/package/hint , a runtime haskell interpreter!
22:12:36 <ivanm> ManateeLazyCat: before or after I emailed you about it? :p
22:12:47 <ivanm> hint is a wrapper around the GHC API
22:13:53 <ManateeLazyCat> ivanm: I want implement *fully* hot-swapping feature for my project, not just re-compile/re-load module in runtime, and i want it evaluation expression in runtime. Before hint, *plugins* package is i want, but it's broken.
22:14:14 <ivanm> as I said, it appears it just needs its deps fixed
22:14:18 <ManateeLazyCat> ivanm: I think is *after*. :)
22:14:35 <Kaidelong> anyone know where I can actually see some examples of co-induction being used?
22:14:47 <Kaidelong> I have seen mentions of it but no examples on what people use it for
22:15:09 * ManateeLazyCat pasted "compile error." at http://paste2.org/get/909844
22:15:09 <ManateeLazyCat> ivanm: Above is compile error for *plugins*. 
22:16:01 <ManateeLazyCat> ivanm: I have modified plugins.cabal with upper of base, "base >= 4 && < 5", but still can't work..
22:16:02 <ivanm> no idea what those errors are at the end
22:16:11 <ManateeLazyCat> ivanm: I don't know how to fix it.
22:16:32 <ManateeLazyCat> ivanm: Looks source code broken and not just deps broken.
22:16:45 <tensorpudding> oh cute, an ordinal library
22:17:03 <ivanm> oh, looks like it's using an old version of cabal
22:17:21 <ManateeLazyCat> ivanm: Do you know how to fix it? :)
22:17:28 <ivanm> ManateeLazyCat: use Cabal-1.6
22:17:36 <ivanm> or else upgrade the source to use Cabal 1.8
22:17:40 <ivanm> @slap dons
22:17:41 * lambdabot clobbers dons with an untyped language
22:17:44 <ivanm> stupid no upper bounds...
22:17:58 <ManateeLazyCat> ivanm: I have touch dons, looks he too busy.... :-(
22:19:12 <ivanm> @ask Cale do you know if there's an overall term for whether a graph is directed or undirected?
22:19:13 <lambdabot> Consider it noted.
22:19:23 <ManateeLazyCat> ivanm: I found three packages : plugins, hint, direct-plugins
22:19:44 <ivanm> yeah, direct-plugins explicitly says it won't work with 6.12
22:19:54 <ivanm> AFAICT, plugins will once you tell it to use base-4 and cabal-1.6
22:20:08 <ManateeLazyCat> ivanm: But direct-plugins looks *too* simple
22:23:33 * ManateeLazyCat Research hint.... just know it today....
22:24:10 * hackagebot mwc-random 0.5.1.1 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.5.1.1 (BryanOSullivan)
22:24:54 * ManateeLazyCat But why i have installed it? Someone told me use hint before? ivanm is you?
22:25:22 <ivanm> ManateeLazyCat: maybe something else you have uses it?
22:25:35 <ManateeLazyCat> ivanm: I don't know.
22:25:39 <ivanm> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/hint-0.3.2.3#direct
22:26:01 <ManateeLazyCat> ivanm: I guess is yi.
22:27:38 <ManateeLazyCat> ivanm: BTW, i don't know how to handle split window for movie, maybe i need popup a window when i watch movie?
22:28:40 <ivanm> *shrug*
22:29:35 <Eduard_Munteanu> Hi.
22:29:51 <Cale> ivanm: directedness
22:29:51 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
22:29:54 <ManateeLazyCat> ivanm: I plan to add multimedia player before i release, but i haven't idea how to handle multiple window for movie render. Like this in webkit/flash : http://farm5.static.flickr.com/4096/4748566880_aefb70879d_b.jpg
22:30:11 <ivanm> Cale: hmmmm...
22:30:15 <ivanm> seems rather obvious ;-)
22:30:51 * Cale fights with wireless networking on a Windows machine. :P
22:31:37 <Cale> It says the network is in range until I try to connect to it at which point it "isn't", which has got to be a lie, since the signal strength is quite good.
22:33:06 <ivanm> heh
22:40:09 <Eduard_Munteanu> mmaruseacph2: hi, may I pm you? I see you're from UPB (I'm a student there as well).
22:40:22 <mmaruseacph2> of course
22:45:37 <BMeph> Cale: So, you're saying that network setup should be a piece of cake, but..."you know"... ;)
22:48:17 * hackagebot mwc-random 0.5.1.2 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.5.1.2 (BryanOSullivan)
22:48:46 <Zeiris> Is there an elegant way to hide useful names like 'and' and 'or' from Prelude, to use in my own libraries?
22:49:02 <ivanm> Zeiris: "import Prelude hiding (and, or)"
22:49:16 <ivanm> Zeiris: however, unless you're writing a prelude replacement I highly recommend you don't
22:49:16 <Zeiris> Is that a standard thing to do for non-toy code, though?
22:49:20 <ivanm> no
22:49:27 <om-foxy> NoImplicitPrelude?
22:49:50 <ivanm> unless you're writing a data structure or class with similar names (e.g. map in Data.Set), then yoiu shouldn't hide things from the Prelude
22:50:12 <dobblego> I hide Prelude all the time; many of those functions are a pain in the arse
22:50:58 <Zeiris> Yeah, I want to define some kind of Logic typeclass to describe common or/and/not behaviours, but prelude is all up in my grill :(
22:51:22 <dobblego> and/or should be (Foldable f) => f Bool -> Bool
22:52:21 <Zeiris> && and || should be (BooleanLogic a) => a -> a -> a
22:52:41 <dobblego> (Semigroup a) => a -> a -> a
22:53:05 <Zeiris> dobblego, thanks for naming the proper term :)
22:53:10 <dobblego> np
22:53:20 <ivanm> Zeiris: if you're defining such a type class, that's one thing
22:53:32 <ivanm> but in general, you shouldn't arbitrarily "override" the default names IMHO
22:53:36 <ivanm> since it reduces readability
22:53:47 <aavogt> @hoogle and
22:53:47 <lambdabot> Prelude and :: [Bool] -> Bool
22:53:48 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
22:53:48 <lambdabot> Data.List and :: [Bool] -> Bool
22:53:50 <Zeiris> Yeah, it could definitely start getting used for evil quick. :(
22:53:52 <Eduard_Munteanu> Isn't it actually a monoid?
22:54:10 <dobblego> it's also a monoid
22:54:34 <dobblego> and :: (Monoid a, Foldable f) => f a -> a
22:54:42 <aavogt> but there's only one class and two possible instances (probably more)
22:54:51 <dobblego> yes that's a problem
22:55:12 <aavogt> > True `mappend` False
22:55:13 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
22:55:13 <lambdabot>    arising from a use of...
22:55:27 <dobblego> @type Conjunction
22:55:28 <lambdabot> Not in scope: data constructor `Conjunction'
22:55:30 <dobblego> @type And
22:55:30 <lambdabot> Not in scope: data constructor `And'
22:56:42 <aavogt> I think there's very little point in having newtypes to get those instances for Bool
22:58:40 <Eduard_Munteanu> I wonder if there's any point in making it a lattice and reusing that type class for other stuff.
22:59:05 <Eduard_Munteanu> @hoogle lattice
22:59:05 <lambdabot> No results found
23:08:39 <ivanm> *sigh* I know what I want to write, I'm just not sure which of several options I should use to write it...
23:10:14 <aavogt> write them all!
23:10:56 <Eduard_Munteanu> And post it as a spinoff on the factorial-done-in-as-many-ways-as-possible page. :D
23:11:50 <ivanm> heh
23:11:55 <ivanm> nah, it's the internals
23:12:04 <ivanm> mainly I don't know which to use because I'm not sure which would work
23:24:35 <Guest13870> How to install ghc on gentoo, I use emerge ghc, but build fail
23:25:34 <Eduard_Munteanu> Guest13870: can you pastebin the error?
23:25:44 <Eduard_Munteanu> Also, what version are you trying to emerge?
23:28:01 <Guest13870> Eduard_Munteanu: it seems like build error, I have lost error message, I will try it later.
23:28:02 <Guest13870> it is make error
23:28:19 <Guest138`> I am newbie haskell and gentoo, so i can't locate it.
23:29:41 <tensorpudding> If the emerge process returned with error, it was most probably related to building.
23:32:21 <Eduard_Munteanu> Guest138`, Guest13870: you should also try asking on Gentoo or looking up on Gentoo's bugzilla.
23:32:22 <ivanm> Guest138`: /join #gentoo-haskell
23:32:35 <Eduard_Munteanu> s/Gentoo/#gentoo
23:32:38 <Eduard_Munteanu> or as ivanm says.
23:32:49 <ivanm> well, yes, seeing as how we're the ones responsible
23:32:58 <ivanm> (well, only me atm, since the others aren't online...)
23:32:59 <Eduard_Munteanu> :)
23:34:14 <ivanm> gah! graphviz and its stupid error messages :@
23:38:28 <ivanm> (even better: the only result google returns for that error message is from the _last_ time it bit me and I was asking here if anyone knew about it...)
23:47:05 <Eduard_Munteanu> Heh.
23:47:32 <Eduard_Munteanu> Though I guess it can't be worse than -ENOERR, or simply perror()-ing it to the screen.
23:48:13 <Eduard_Munteanu> ivanm: you might tree to grep the source for it. With luck it might be very specific.
23:48:25 <ivanm> yeah, I tried that last time IIRC
23:48:32 <ivanm> the graphviz source is undocumented, etc.
23:56:13 <davekong> Zeiris: you could do and' or' not' something like that
23:56:49 <Zeiris> That looks twisted though. ' strongly implies that it's just a slightly modified non-' function.
23:58:37 <davekong> Zeiris: if you like the operators you could use new ones such as ||| or &&& etc
23:59:01 <Zeiris> Yeah.
23:59:38 <ddarius> Those are taken.
