00:00:01 <ClaudiusMaximus> > let { chunk n [] = [] ; chunk n xs = let (ys, zs) = splitAt n xs in ys : chunk n zs } in chunk 3 ['a'..]
00:00:01 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz{","|}~","\DEL\128\129"...
00:00:03 <ivanm> I generally prefer "flip const" as its more obvious what it does IMHO
00:00:50 <Colours> hm it's actually shorter to just do \(a, b) -> (b, a)
00:01:04 <Colours> I wonder why that's not in the standard library
00:01:25 <ClaudiusMaximus> because people couldn't agree how lazy it should be, probably
00:01:54 * datwinkdaddy is for maximum lazyness.
00:01:57 <ivanm> there was a discussion on it a few months ago
00:02:09 <ivanm> and yeah, I think it was because people couldn't agree how it should be defined
00:02:27 <ivanm> it's also one of those functions that are re-defined often, but simple enough to define yourself if you want it
00:03:26 <datwinkdaddy> @google haskell Alternative some
00:03:27 <lambdabot> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/Control-Applicative.html
00:03:27 <lambdabot> Title: Control.Applicative
00:04:00 <ClaudiusMaximus> @hoogle some
00:04:01 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
00:04:01 <lambdabot> Control.Exception data SomeException
00:04:01 <lambdabot> Control.Exception SomeException :: e -> SomeException
00:05:44 <datwinkdaddy> :( Documentation is lacking, I suppose I'll just ignore it for now.
00:05:49 <ClaudiusMaximus> you can view the source
00:06:00 <ClaudiusMaximus> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/Control-Applicative.html#some
00:06:45 <datwinkdaddy> Yeah, I looked at that, but since I just learned about Applicative and Alternative yesterday it is still too dense for me.
00:07:23 <ClaudiusMaximus> where i see the instance for [] has (<|>) = (++) and pure = repeat, so you end up with an infinite list?
00:07:42 <ClaudiusMaximus> > take 5 . some "abc"
00:07:44 <ClaudiusMaximus> oops
00:07:46 <lambdabot>   mueval-core: Time limit exceeded
00:07:52 <ClaudiusMaximus> > take 5 (some "abc")
00:07:56 <lambdabot>   mueval-core: Time limit exceeded
00:08:01 <ClaudiusMaximus> hm
00:08:27 <datwinkdaddy> I was trying it on the Maybe instance hoping that Nothing would stop the list.
00:10:03 <datwinkdaddy> some ((\x -> do { n <- x; if n > 0 then return $ n - 1 else Nothing }) Just 3)
00:10:42 <datwinkdaddy> Something like that.  (Ugly, I know.)  ... I still seemed to get an infinite list. :(
00:11:24 <datwinkdaddy> Alternative does the same sequencing as Monad, so running the result though take still runs long. :(
00:12:44 <datwinkdaddy> > take 5 <$> some "abc"
00:12:48 <lambdabot>   mueval-core: Time limit exceeded
00:13:38 <ddarius> > pure 3 :: [Int]
00:13:39 <lambdabot>   [3]
00:17:06 <ddarius> some and many both repeatedly execute the passed in applicative functor value until it fails.  Without something like state so that the runs have some way of returning different results with each execution you get an infinite loop or immediate failure.
00:17:38 <prsteele> I'm getting the error "Non-exhaustive patterns in function foo", but my final pattern in foo is otherwise... any thoughts?
00:17:58 <lispy> prsteele: your indentation might be wrong
00:17:59 <c_wraith> otherwise is a guard, not a pattern
00:18:00 <datwinkdaddy> otherwise isn't the same as _
00:18:07 <datwinkdaddy> otherwise is the same as True.
00:18:21 <prsteele> c_wraith: sorry, yes
00:18:41 <c_wraith> So you probably have a *pattern* that isn't being matched
00:18:46 <ddarius> otherwise is just a value, namely True, as datwinkdaddy said.
00:18:58 <prsteele> no, no patterns then, just used the wrong term, they are guards
00:19:08 <ddarius> Also, as a pattern, otherwise and _ would actually behave the same, the only difference being that one would bind (and shadow) otherwise.
00:19:25 <c_wraith> then you probably have a *pattern* that isn't being matched, prsteele.  You're probably using a pattern match.
00:19:29 <datwinkdaddy> ddarius: Isn't "Nothing" failure in the Maybe instance for Alternative?
00:19:38 <ddarius> datwinkdaddy: Yes.
00:19:57 <prsteele> c_wraith: I don't believe I have any patterns.
00:20:09 <c_wraith> prsteele: in order to have a guard, you *must* have a pattern.
00:20:39 <datwinkdaddy> prsteele: pattern | guard -> expr
00:20:55 <datwinkdaddy> prsteele: _ | otherwise -> undefined, e.g.
00:21:10 <prsteele> datwinkdaddy: ah. Thank you.
00:21:30 <ClaudiusMaximus> @src [] ap
00:21:30 <lambdabot> Source not found. Sorry.
00:21:43 <ddarius> @src ap
00:21:43 <lambdabot> ap = liftM2 id
00:21:44 <prsteele> I had 'foo queue@(el:els) | null queue = ... | ...', which wouldn't match queue == []
00:22:12 <prsteele> c_wraith: so you were correct.
00:22:25 <c_wraith> prsteele: sorry I wasn't communicating as well as I should have been.
00:22:28 <datwinkdaddy> prsteele: That pattern with that guard will never be chosen.
00:22:44 <datwinkdaddy> Since when queue matches that pattern (null queue) is False.
00:23:30 <prsteele> c_wraith: No, in retrospect, you were quite precise. I'm just not up on the terminology.
00:23:57 <datwinkdaddy> ddarius: So, with my function above, wouldn't I get just like a 4 element list [Just 2, Just 1, Just 0, Nothing]?
00:24:00 <c_wraith> yes, but I was busy being precise, rather than helpful.  I'm usually better than that.  chalk it up to a crazy night IRL. :)
00:24:34 <prsteele> c_wraith: no hard feelings :)
00:24:48 <datwinkdaddy> ddarius: Or, do I simply get [Just 2, Just 2, ... ]?
00:25:03 <ddarius> datwinkdaddy: As I said, if you don't have something like state, you will always get an infinite loop or failure.  The action always returns the same result which means you always loop or, if it fails, you immediately fail.
00:25:49 <dibblego> @hoogle Either a b -> Bool
00:25:50 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
00:25:50 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
00:25:50 <lambdabot> Data.Graph.Inductive.Basic isSimple :: Graph gr => gr a b -> Bool
00:25:55 <dibblego> @hoogle isLeft
00:25:55 <lambdabot> No results found
00:26:41 <ddarius> datwinkdaddy: (\x -> do n <- x; if n > 0 then return (n-1) else Nothing) (Just 3) is just a round about way of writing Just 2.
00:27:09 <datwinkdaddy> ddarius: Okay, I though the result was fed into the next invocation.
00:27:32 <datwinkdaddy> ddarius: I guess that can't be done without "join" and Alternatives don't have join.
00:27:50 <ddarius> datwinkdaddy: Invokation of what?  You are giving some the value Just 2.
00:28:32 <datwinkdaddy> dibblego isLeft x = case x of { Left _ -> True; _ -> False; } 
00:29:13 <RyanT5000> there should really be a pointless version of "case"
00:29:43 <olsner> RyanT5000: many types have one... 'either' for Either, for example
00:29:45 <datwinkdaddy> Ryan: agreed, though I don't know how you'd really implement it.
00:29:54 <RyanT5000> olsner: yes, but those don't desugar more complicated patterns
00:30:14 <RyanT5000> datwinkdaddy: well, it seems easy to implement
00:30:21 <RyanT5000> it just turns into a lambda
00:30:28 <ClaudiusMaximus> ddarius++ # explanation of why some+many loop for certain Alternative instances - i think i got it now too
00:30:38 <RyanT5000> however, finding syntax that doesn't conflict with anything else could be annoying
00:31:13 <ddarius> ClaudiusMaximus: The main uses of some/many are for parsers which have a state like component.
00:31:33 <datwinkdaddy> ddarius: Hrm, I was thinking of the "f a" value as a function application.  I think that comes from thinking all Monads behave like State and IO.  Must purge that from my brain somehow.
00:31:42 <dibblego> datwinkdaddy, yes thanks
00:31:43 <ddarius> People have suggested having case of ... expanding to \x -> case x of ...
00:32:04 <ddarius> dibblego: either (const True) (const False)
00:32:13 <dibblego> right
00:32:17 <RyanT5000> ddarius: that seems like a reasonable approach
00:32:28 * ddarius almost always uses maybe or either rather than cases on those types.
00:32:30 <datwinkdaddy> @pl either (const True) (const False)
00:32:31 <lambdabot> either (const True) (const False)
00:32:35 <ClaudiusMaximus> @hoogle lefts
00:32:35 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
00:32:35 <lambdabot> Language.Haskell.Lexer LeftSquare :: Token
00:32:35 <lambdabot> Language.Haskell.Syntax HsLeftSection :: HsExp -> HsQOp -> HsExp
00:32:46 <RyanT5000> ddarius: cases are nicer when the person reading your code won't know the datatype intimately
00:33:03 * ddarius also thinks isJust/isNothing/isLeft/isRight are not usually desirable functions.
00:33:05 <RyanT5000> and when you want more complicated patterns
00:33:17 <RyanT5000> ddarius: they're better than fromJust et al :)
00:33:51 <ddarius> RyanT5000: isJust usually just leads to fromJust.  Once isJust returns True what's the point in case analyzing the value again?
00:33:55 <datwinkdaddy> I almost forget about those (isJust et. al.), I tend to lean on the case construct.
00:34:16 <RyanT5000> ddarius: occasionally you just want to know whether something has contents, rather than actually inspecting them
00:34:44 <RyanT5000> though i agree it's rare
00:34:46 <dibblego> it is no different to null
00:34:53 <datwinkdaddy> ddarius: Really? Why?  If you don't want to act on the contents why do you care if they are there?
00:35:20 <datwinkdaddy> er, that was ment for Ryan.
00:35:32 <simplechat> ?
00:35:32 <olsner> if you only want to know whether you have data - why did you end up with Maybe a instead of just Bool in the first place? :)
00:35:38 <ddarius> dibblego: Which I also don't use much.
00:35:49 <dibblego> ddarius, me neither, nor any "isLeft"
00:36:02 <RyanT5000> olsner, datwinkdaddy: sometimes you need to implement a function to an interface you didn't write :)
00:36:11 <RyanT5000> and sometimes that interface provides information you don't happen to currently need
00:36:19 <ClaudiusMaximus> @hoogle Maybe a -> Bool
00:36:19 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
00:36:19 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
00:36:19 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
00:36:47 <RyanT5000> this doesn't tend to happen with very tight algorithmic code
00:36:53 <datwinkdaddy> Is there a "safe" version of fromJust? ;)
00:37:00 <ddarius> datwinkdaddy: id
00:37:24 <RyanT5000> but suppose you have a datastructure SpaceShip with a field isDamaged :: Maybe KindOfDamage
00:37:29 <dibblego> fromMaybe
00:37:32 <ClaudiusMaximus> :t maybeToList
00:37:33 <lambdabot> forall a. Maybe a -> [a]
00:37:50 <RyanT5000> now, if you're writing something that only cares *whether* the ship is damaged, not *how*, then you could use isJust :)
00:38:19 <RyanT5000> however, i do think that it'll still be pretty rare
00:38:45 <ClaudiusMaximus> yeah, a SpaceShip needs isDamaged :: [KindOfDamage]
00:39:16 <RyanT5000> ClaudiusMaximus: then you just need to use "null", which is the same thing (not using all your data)
00:39:23 <ClaudiusMaximus> :)
00:40:02 <ddarius> :t maybe mzero return
00:40:03 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
00:40:04 <prsteele> ?src null
00:40:04 <lambdabot> null []     = True
00:40:04 <lambdabot> null (_:_)  = False
00:40:31 <olsner> either case you can write isDamaged = isJust . damage or not null . damage, and add that to the interface of the spaceship module - ugliness hidden :)
00:41:00 <datwinkdaddy> @src isJust
00:41:01 <lambdabot> isJust Nothing = False
00:41:01 <lambdabot> isJust _       = True
00:42:04 <RyanT5000> hm, so i need to enforce a constraint that something is a commutative monoid
00:42:07 <RyanT5000> ideas?
00:42:17 <dolio> Impossible in Haskell.
00:42:22 <RyanT5000> obviously it won't be verified by the compiler
00:42:48 <RyanT5000> i mean a nice way of certifying to the compiler (possibly with an instance) that you trust a given function to be commutative
00:42:56 <datwinkdaddy> {- arg must be a commutative monoid -}
00:43:01 <RyanT5000> i guess i could just have an empty subclass
00:43:06 <RyanT5000> datwinkdaddy: yeah, i thought about that
00:43:06 <prsteele> is there a built in function to check if any of a list of predicates is true without checking them all? like 'foldl (||) False theList', but one that will return after the first True?
00:43:15 <dolio> You could make a 'class Monoid m => CommutativeMonoid m' then.
00:43:26 <ClaudiusMaximus> :t any
00:43:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:43:28 <RyanT5000> dolio: yeah, i suppose that would do
00:43:38 <ClaudiusMaximus> :t or
00:43:39 <RyanT5000> if you have an Ord constraint, then you can always sort the input to mappend
00:43:39 <lambdabot> [Bool] -> Bool
00:44:03 <RyanT5000> that would force it to be commutative, right?
00:44:14 <prsteele> ClaudiusMaximus: thanks
00:44:21 <prsteele> ?src any
00:44:21 <lambdabot> any p =  or . map p
00:44:27 <prsteele> ?src or
00:44:27 <lambdabot> or    =  foldr (||) False
00:44:30 <ClaudiusMaximus> > or [False, True, error "no shortcircuiting today for you"]
00:44:31 <lambdabot>   True
00:44:33 <prsteele> haha
00:45:58 <prsteele> wait, looking at this, why does 'or' use 'foldr'? Does that force it to read the whole list?
00:46:10 <dolio> No.
00:46:11 <olsner> > or ([False,True]++repeat False)
00:46:12 <lambdabot>   True
00:46:25 <olsner> or an infinite list in constant time! :)
00:46:48 <datwinkdaddy> \preds x -> or [pred x | pred <- [preds]]?
00:47:29 <datwinkdaddy> @src foldr
00:47:29 <lambdabot> foldr f z []     = z
00:47:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:47:32 <datwinkdaddy> @src foldl
00:47:32 <lambdabot> foldl f z []     = z
00:47:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:48:19 <ddarius> RyanT5000: If Haskell had an unordered pair type, you could have (*) :: {a,a} -> a and it would necessarily be commutative.
00:48:47 <RyanT5000> ddarius: any ideas for a reasonable interface for unordered pairs?
00:48:48 <dolio> Let's get quotient types in Haskell 2011.
00:49:22 <datwinkdaddy> dolio: You mean Haskell 2022?
00:49:35 <datwinkdaddy> > [1998, 2010, ... ] !! 3
00:49:36 <lambdabot>   <no location info>: parse error on input `]'
00:49:41 <prsteele> so 'foldr' makes a series of thunks ||'d together, and || is smart enough to not care whats left after it finds a True?
00:49:45 <dolio> I don't think I mean that.
00:49:59 <dolio> Unless I traveled through a time warp.
00:50:32 <dolio> or working like it does is just plain old lazy evaluation.
00:50:37 <dolio> Both for foldr and (||).
00:51:24 <olsner> if you were time warping, you might as well aim for getting it into Haskell98
00:51:51 <dolio> Well, if it were 2022, I would have warped forward, so that'd be even less of a possibility.
00:52:06 <datwinkdaddy> > [1998, 2010 .. ] !! 2
00:52:06 <lambdabot>   2022
00:52:07 <olsner> a bit of a paradox though - if gets into haskell98 you will have no reason for going back in time to put it in :)
00:52:20 <datwinkdaddy> my point ^^
00:52:42 <prsteele> > 10 < foldr (+) 0 [1..]
00:52:43 <lambdabot>   *Exception: stack overflow
00:53:03 <prsteele> > 10 < foldl (+) 0 [1..]
00:53:03 <dolio> Yes, but you're extrapolating from one (two) point.
00:53:07 <lambdabot>   mueval-core: Time limit exceeded
00:53:14 <ddarius> RyanT5000: There's nothing reasonable that you could do that would be helpful.
00:53:17 <dolio> Back before 98, Haskell reports came out a lot more regularly.
00:53:23 <dolio> And hopefully, they will again.
00:53:24 <ddarius> (wrt unordered pairs in Haskell)
00:53:59 <RyanT5000> ddarius: well, you could have a function sort :: Ord a => UnorderedPair a -> (a, a)
00:54:10 <datwinkdaddy> dolio: Still, I don't think there will be a Haskell 2011.  Maybe 2012.
00:54:27 <dolio> The world is ending in 2012, so that will be pointless. :)
00:54:44 <datwinkdaddy> dolio: The standard will be published before December. :P
00:55:12 <dibblego> didn't you hear? Haskell 2012 will save the world
00:56:38 <ddarius> RyanT5000: That's kind of silly though if that is the only way to observe values of the unordered pair.  Rather, you would have unorderedPair :: a -> a -> UnorderedPair; observe :: UnorderedPair a -> (a, a) such that there was no guarantee about the order of the result of observe . uncurry unorderedPair 
00:56:40 <datwinkdaddy> import System.IO (save)
00:56:53 <datwinkdaddy> save :: IO a -> ()
00:57:31 <RyanT5000> ddarius: well, i have kind of the opposite concerns: i want to make sure that the user doesn't depend on the order
00:58:07 <RyanT5000> ddarius: i'm writing some code that essentially combines a bunch of asynchronous events of type 'a'
00:58:17 <ddarius> RyanT5000: Yes, the lack of guarantee about the result of observe would make it a user error to rely on the ordering, but that isn't too helpful in practice.
00:58:20 <RyanT5000> so if i want the code to be deterministic, the combining function had better be commutative
00:58:45 <dolio> Use unsafePerformIO to randomly switch the values in the unordered pairs upon creation. :)
00:58:52 <RyanT5000> haha
00:59:01 <datwinkdaddy> dolio: ha
00:59:23 <RyanT5000> dolio: well, i thought about having a debug mode that tries the function both ways and throws an error if the outputs aren't equal :)
00:59:41 <RyanT5000> i'm not a huge fan of doubling the computation everywhere, though :P
00:59:45 <dolio> I'm not sure how you'd do that for arbitrary monoids.
00:59:50 <ddarius> The real way to eliminate an unordered pair is to, indeed, have a function: eliminate :: UnorderedPair a -> (a -> a -> b) -> b where the passed in function is required to be commutative which of course just gets you back to your problem.  Note, though, the fact that this is the eliminator is why a function on unordered pairs is necessarily commutative.
01:00:31 <dolio> The only things you know about them are e and *, which isn't enough to observe failure of commutativity.
01:00:37 <datwinkdaddy> unorderedPair x y = unsafePerformIO (do { b <- random; return if b then (y, x) else (x, y); }) ?
01:01:52 <RyanT5000> dolio: that's a good point; i don't especially want to add Eq constraints everywhere
01:02:12 <ddarius> Anyway, the empty subclass is the most pragmatic answer.
01:02:22 <RyanT5000> ddarius: yeah, i think that'll be the way to go
01:02:33 <dolio> Even if you have Eq, you only have one element, because e * e = e.
01:03:38 <RyanT5000> dolio: i mean that if i had a function that claimed to be commutative, i could run it, commute the input, and run it again; wouldn't that work?
01:03:48 <RyanT5000> (assuming i had an Eq constraint on the output type)
01:03:55 <dolio> If you had elements that are guaranteed to be different.
01:04:17 <RyanT5000> well if they're the same then every function's commutative, isn't it?
01:04:27 <dolio> And even then, it might fool you if the operation happens to be commutative for those two particular elements.
01:04:35 <RyanT5000> oh, i'm not saying as a general test
01:04:39 <RyanT5000> i'm talking about a runtime check
01:04:54 <RyanT5000> when in "debug mode", just make sure that *every single time* you invoke the function, it acts commutatively
01:05:08 <ddarius> eliminate :: Eq b => UnorderedPair a -> (a -> a -> b) -> Maybe b
01:05:25 <ddarius> Unfortunately, equality is often very expensive.
01:05:39 <RyanT5000> ddarius: yeah; and so is checking
01:05:56 <RyanT5000> i think i'll just go with the empty typeclass
01:06:20 <RyanT5000> if people start adding instances willy-nilly, i'll just smack them down :P
01:06:51 <RyanT5000> it's like the {- must be commutative -} solution, but much easier to grep for violations :)
01:07:18 <ddarius> grep can solve the halting problem?
01:07:46 <RyanT5000> ddarius: "grep | human" is about as close as we can get :)
01:08:07 <ddarius> apt-get human
01:08:31 <datwinkdaddy> ddarius: grep will at least tell you where the human lied in their assertion that the function was commutative.
01:08:46 <RyanT5000> well, what really solves the halting problem is deadlines
01:08:59 <RyanT5000> "if you can't prove this function's commutative in 5 minutes, your instance isn't going in" :P
01:09:18 <ddarius> RyanT5000: Perhaps you can require a Coq proof with each patch.
01:09:43 <RyanT5000> ddarius: haha yeah, it'll replace QA! :)
01:10:01 <RyanT5000> now, i just need to write a predicate for "this program is a fun game"
01:10:05 <dolio> Just write the code in Coq in the first place. :)
01:10:33 <ddarius> RyanT5000: With our ever advancing results in cognitive science, you may have it soon enough.
01:10:52 <RyanT5000> ddarius: not soon enough for me to pay my bills :)
01:11:16 <RyanT5000> it will be cool when we come up with rigorous theories of "fun" and such
01:11:19 <ddarius> RyanT5000: Then you should become a cognitive scientist in the meantime, since you'll have a job.
01:11:27 <RyanT5000> haha
01:11:29 <lispy> ddarius: yes, I'd like to work on something akin to "a Coq proof with each patch"
01:11:43 <lispy> ddarius: I'm currently waiting on a specific PhD dissertation to get published
01:11:55 <ddarius> lispy: Have you looked at Sparkle?
01:12:01 <lispy> Never heard of it
01:12:15 <lispy> Isabella with HOLCF is what I've been interested in
01:12:20 <RyanT5000> lispy, ddarius: proof-with-patch is a lot like Test Driven Development, except... rigorous :)
01:12:43 <RyanT5000> lispy: one easy(ish) thing to do might be to have a "refactoring-only" patch
01:13:04 <ddarius> lispy: http://www.cs.ru.nl/Sparkle/
01:13:09 <RyanT5000> where you can prove that the code has only been moved around and/or renamed, but with no changes in meaning
01:13:17 <lispy> RyanT5000: Yes, that's actually first on my list :)
01:13:39 <RyanT5000> actually, even easier than that would be "only formatting and comments have changed"
01:13:43 <RyanT5000> but that's not even a Coq thing
01:13:49 <RyanT5000> nevertheless, it would be useful
01:13:57 <lispy> ddarius: ah interesting
01:14:11 <lispy> ddarius: I wonder if it's more complete than Haskabelle
01:14:40 <simplechat> Hey guys, i have what is probably a really stupid question, but i can't seem to figure it out. if isprime' is Integer->Bool and divisors is Integer->Bool why would isprime' x or not divisors x fail?
01:14:50 <ddarius> It's older than Haskabelle, but almost certainly younger than Isabelle.
01:14:52 <simplechat> Its saying that the expected type is not the inferred type
01:15:04 <lispy> ddarius: judging by the website it hasn't been updated from 1997 (not really, but the style is of that era)
01:15:26 <ddarius> lispy: The Clean community is not as lively as the Haskell one.
01:15:49 <ClaudiusMaximus> simplechat: ... `or` not (...)
01:15:58 <datwinkdaddy> simplechat: I think you are getting bit by "function applications extend as far to the right as possible"
01:16:00 <ddarius> :t or
01:16:05 <lambdabot> [Bool] -> Bool
01:16:10 <ClaudiusMaximus> and that...
01:16:21 <lispy> :t (||)
01:16:22 <lambdabot> Bool -> Bool -> Bool
01:16:47 <datwinkdaddy> simplechat: isprime' x || not $ divisors x, maybe?
01:16:57 <ddarius> datwinkdaddy: Wrong precedence.
01:17:04 <simplechat> i just tried that, and it failed
01:17:18 <lispy> http://hpaste.org
01:17:34 <lispy> wtf, hpaste is down?
01:17:47 <RyanT5000> the database is locked
01:17:51 <RyanT5000> for safekeeping, i presume :)
01:17:53 <datwinkdaddy> let d = divisors x in isprime' x || not d, then?
01:17:55 <simplechat>  24 isprime x = isprime' x || not $ divisors x fails with Couldn't match expected type `Bool'
01:17:55 <simplechat>            against inferred type `Bool -> Bool'
01:18:21 <ddarius> datwinkdaddy: Or just use parentheses.
01:18:34 <lispy> RyanT5000: but yeah, proof carrying patches is something I would definitely like to work on.  Also, code review carrying patches.
01:18:36 <ddarius> (What is wrong with kids these days?)
01:18:49 <ivanm> ddarius: good question
01:18:58 <RyanT5000> lispy: well, as far as i can tell, nobody's made a good workflow system for code (or, really, anything else)
01:19:01 <simplechat> lol
01:19:16 <lispy> RyanT5000: a good workflow system?
01:19:23 <datwinkdaddy> Hrm, my code look less haskell-y when I use parens outside of type declarations.  To me, at least.
01:19:30 <RyanT5000> lispy: a system that coordinates all the humans involved in the software engineering process
01:19:30 <lispy> RyanT5000: have you missed the whole distributed version control revolution?? :)
01:19:32 <ddarius> RyanT5000: Once we have a Coq predicate for "good workflow system" we'll be set.
01:19:44 <RyanT5000> lispy: haha i'm using darcs *right now*
01:19:54 <datwinkdaddy> Ryan: I think repo from Google is a pretty good workflow manager.
01:19:58 * lispy is benchmarking some changes to darcs  *right now* :)
01:20:19 * ddarius is doing nothing productive *right now*
01:20:21 <RyanT5000> lispy: my point is just that i'm well aware of distributed revision control; i just don't think it solves a very large percentage of the problem
01:20:32 <datwinkdaddy> Ryan: Automated testing rejects, un-clean merge rejects, distributed development, email notices, etc.
01:20:59 <lispy> datwinkdaddy: what is an un-clean merge?
01:21:07 <lispy> datwinkdaddy: one that results in conflicts?
01:21:25 <RyanT5000> datwinkdaddy: yeah, that's all pretty necessary stuff; however, there are still some serious integration opportunities
01:21:30 <datwinkdaddy> lispy: Yeah.  And yes, I know that doesn't completely solve the problem.
01:21:46 <RyanT5000> datwinkdaddy: for example, new "todo" comments" could be entered into a task tracking system
01:21:47 <datwinkdaddy> lispy: But, with the addition of a unit test suite you get much better.
01:21:56 <RyanT5000> datwinkdaddy: and deleted ones could close the associated issues
01:22:18 <RyanT5000> i suspect that Team Foundation Server is supposed to do a lot of this stuff
01:22:31 <RyanT5000> but then you have to write in a Microsoft-approved language :)
01:22:36 <ivanm> preflex: seen dons 
01:22:36 <preflex>  dons was last seen on #ghc 12 hours, 16 minutes and 36 seconds ago, saying: currently they're not Showable.
01:22:47 <datwinkdaddy> Ryan: debian-parse-changelog and trac already have ways for the commit messages to close issues.
01:22:50 <lispy> RyanT5000: you might like some of the automated workflows that the darcs team uses.  patch names like, "Resolve issueNNN: ...." actually tell the bug tracker to close the ticket when they are pushed to the main repo
01:23:00 <RyanT5000> ah, that's cool
01:23:03 <datwinkdaddy> Ryan: I'm pretty sure trac will let you open issues that way to, if you like.
01:23:37 <RyanT5000> well i guess it sounds like i'm just not well-enough informed :)
01:24:07 <lispy> RyanT5000: To be fair, it's a pain to get these features because it's always done downstream for each project
01:24:14 <datwinkdaddy> Trac can run on top of git, as does repo, so there is only a little bit of integration missing there.
01:24:53 <RyanT5000> oh, lispy, here's another proof i'd really like
01:25:11 <RyanT5000> "this patch doesn't break my serialization routines"
01:25:40 <RyanT5000> that would require some serious work, though, i suspect
01:25:44 <lispy> RyanT5000: Hmmpf.  That one sounds hard.
01:26:07 <lispy> That one is hard to do period, even with current theorem proovers
01:26:29 <RyanT5000> lispy: i think the easiest way to do that would be to have a limited language for specifying serializable datatypes and the load/save algorithms on them
01:26:30 <lispy> T'would be cool though
01:26:38 <datwinkdaddy> Ryan: I think some iterations on fuzz-testing in your unit tests might get you there.
01:27:02 <lispy> Do we have fuzz testers for Haskell parsers?
01:27:15 <lispy> quickcheck yes, but is that it?
01:27:29 <ivanm> "fuzz testers"?
01:27:31 <RyanT5000> lispy: then, you could probably build a set of primitive patches that would guarantee preservation of the ability to load old save files (e.g.: if you add a field, you're required to provide a default value)
01:27:54 <lispy> ivanm: libraries or tools that I can just grab and start testing my parser
01:28:09 <ivanm> lispy: well, wouldn't that depend upon what you're parsing?
01:28:29 <datwinkdaddy> "fuzz testing": take random slight variations of good data (or randomly-created data) and run unit tests against them.
01:28:32 <datwinkdaddy> Er, kinda.
01:28:41 <datwinkdaddy> That's how I think about it.
01:28:52 <lispy> ivanm: I asked for the moon dammit.  I don't care if it's 250,000 miles from here.
01:29:05 <ivanm> heh
01:29:22 <ivanm> lispy: well, for graphviz I use QC to check that what gets printed gets prsed
01:29:32 <lispy> cool
01:29:35 <ivanm> and I wrote a script to find all .dot files on a computer and try to parse them
01:29:36 <datwinkdaddy> It's also useful when reverse enginerring something like Samba, take good input, "fuzz" it a little bit, feed it to both your impl. and the canonical impl. and compare.
01:29:44 <ivanm> that's what I use to test my parser
01:30:11 <lispy> I've been retooling the darcs parser a bunch lately, and when I have bugs with my retoolings I have tests that find them but the tests run the binary so it's _really_ hard to figure out what I actually broke because I don't even know what input failed or how
01:31:34 <lispy> So I find myself working from both ends.  One end is the unmodified code and the other uses a different parser.  I tweak from both ends trying to get them to be similar enough that I can see where the bugs are.
01:31:35 <datwinkdaddy> Hrm, that's very black-box testing.  Perhaps write a few tests that are closer to the code would help.
01:32:20 <lispy> datwinkdaddy: I was having trouble with that because I didn't write the original parser.
01:32:41 <lispy> datwinkdaddy: and it seems like I'm now passing the average cases
01:32:56 <prsteele> ... its one thing when you're too tired to get a problem right. Its another when you spend 2 hours debugging code that is producing the result you don't know you want.
01:32:57 <datwinkdaddy> When I wrote JUnit and NUnit tests, the suite rarely ran the whole executable.  Instead I'd write tests that used exported (public or private) API.
01:33:09 <lispy> prsteele: hehe
01:33:30 <lispy> datwinkdaddy: I agree that unit testing is far superior to what I'm doing now.
01:33:46 <datwinkdaddy> prsteele: I think I did that a work once.  Spend half an afternoon trying to figure out why the program was rejecting certain input.
01:33:53 <RyanT5000> is there anything that produces nice visualizations of module dependencies
01:33:54 <datwinkdaddy> prsteele: Turned out the input was bad. :(
01:33:55 <lispy> It's hard to rationalize my currently lackluster approach to debugging it.
01:34:04 <lispy> RyanT5000: yeah, ask ivanm 
01:34:21 <lispy> SourceGraph? Is that the name?
01:34:21 <ivanm> heh
01:34:35 <ivanm> RyanT5000: SourceGraph does; graphmod also does it but it isn't as fancy :p
01:34:49 <prsteele> datwinkdaddy: ouch
01:34:56 <ivanm> IIRC, dons also did his own custom hack-job rather than seeing was else was around...
01:35:14 <lispy> ivanm: I bet it was fast though ;)
01:35:18 <ivanm> heh
01:35:19 <RyanT5000> haha yeah
01:35:31 <ivanm> lispy: both in terms of development time and in runtime! :p
01:35:44 <lispy> ivanm: I was teasing him that his dissertation topic was all wrong (he wrote about hs-plugins) but his real thesis is that Haskell is fast :)
01:35:55 <ivanm> heh
01:36:46 <datwinkdaddy> Is the "haskell using shared libraries" feature exposed to the programmer at all?
01:36:57 * hackagebot Graphalyze 0.10.0.1 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.10.0.1 (IvanMiljenovic)
01:36:59 * hackagebot HSGEP 0.1.2 - Gene Expression Programming evolutionary algorithm in Haskell  http://hackage.haskell.org/package/HSGEP-0.1.2 (MatthewSottile)
01:37:01 <datwinkdaddy> Like, can my haskell program load a directory of .so files as plugins?
01:37:04 <lispy> datwinkdaddy: I'm not familiar with that topic
01:37:43 <lispy> datwinkdaddy: well, hs-plugins is about dynamicly loading/unloading code in a type safe way.  GHC can load .so files in various ways.
01:38:03 <datwinkdaddy> http://blog.well-typed.com/2009/04/hello-world-now-only-11k-using-ghc-with-shared-libs/
01:38:27 <ivanm> datwinkdaddy: I doubt it
01:38:27 <lispy> datwinkdaddy: you could for example, use the FFI to load a .so.  And I think ghc has had support on and off for doing it a more Haskell friendly way
01:38:33 <ivanm> lispy: the package is now called "plugins" btw
01:38:51 <lispy> ivanm: thanks.  Old habits die slow
01:38:54 <ivanm> and ManateeLazyCat was trying to get it to build on 6.12 (since dons seemed to have been ignoring his bug reports)
01:39:23 <datwinkdaddy> It was on the Haskell 2009 Year in Review, but I couldn't make it clear to myself if that was just an internal change in GHC or if it was exposing a new API to programmers as well.
01:39:48 <lispy> datwinkdaddy: likewise
01:40:00 <ivanm> it's just a compile-time option
01:40:08 <datwinkdaddy> Something like C's dlopen, but in a non-IO and type-safe manner.
01:40:10 <lispy> I haven't been bothered by executable size lately so I don't tend to worry about it
01:40:17 <ivanm> so you can build haskell libraries and programs dynamically rather than statically
01:40:52 <lispy> I did compile some Haskell code to a DLL on windows once and I was able to load it into my application but it would do a windows version of segfault if I tried to unload it
01:42:49 <CakeProphet> Hello
01:42:58 <lispy> Wow.  Nice.  My changes have reduced some of the execution times by a fair margin.  7 ms avg down to 4ms
01:43:02 <lispy> CakeProphet: Hello
01:43:13 <CakeProphet> I'm a #haskell regular, using tryhaskell.org as an IRC client.
01:43:28 <lispy> CakeProphet: the freenode webchat is kind of nice, IMO
01:43:31 <gwern> CakeProphet: lies, I'm sure I've seen you here before!
01:43:36 <lispy> I stopped using it when it lost voice here
01:43:39 <lispy> glad to see it's working again
01:44:05 <lispy> (tryhaskell.org uses the freenode webchat near as I can tell)
01:44:27 <ivanm> sure looks like it does
01:44:32 <ivanm> going by CakeProphet's hostmask
01:45:06 <CakeProphet> > flip replicateM ['0'..'9'] >>= [1..]
01:45:07 <lambdabot>   Ambiguous occurrence `replicateM'
01:45:07 <lambdabot>  It could refer to either `L.replicateM',...
01:45:25 <CakeProphet> > flip Control.Monad.replicateM ['0'..'9'] >>= [1..]
01:45:26 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]
01:45:26 <lambdabot>                           ...
01:45:31 <CakeProphet> ...
01:45:50 <ivanm> @hoogle replicateM
01:45:51 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
01:45:51 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
01:46:12 <lispy> > flip Control.Monad.replicateM "0123456789" >>= [1..]
01:46:13 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]
01:46:13 <lambdabot>                           ...
01:46:33 <lispy> > flip Control.Monad.replicateM [0 .. 9] >>= [1..]
01:46:34 <lambdabot>   Couldn't match expected type `[[a]] -> GHC.Types.Int -> b'
01:46:34 <lambdabot>         against ...
01:46:38 * lispy stops
01:46:38 <CakeProphet> ...why [[Char]]?
01:47:05 <lispy> CakeProphet: GHC doesn't always guess correctly between the available type synonyms and the actual type
01:47:07 <ivanm> CakeProphet: because you get a [Char] for each integer
01:47:24 <CakeProphet> :t (>>=)
01:47:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:47:26 <ivanm> CakeProphet: I'm not sure how well replicateM will deal with infinite lists...
01:47:45 <ivanm> > flip Control.Monad.replicateM ['0'..'9'] >>= [1..10]
01:47:46 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]
01:47:46 <lambdabot>                           ...
01:47:53 <ivanm> @more
01:47:56 <ivanm> bah
01:48:29 <CakeProphet> [1..] >>= flip Control.Monad.repliacteM ['0'..'9']
01:48:39 <CakeProphet> > [1..] >>= flip Control.Monad.repliacteM ['0'..'9']
01:48:40 <lambdabot>   Not in scope: `Control.Monad.repliacteM'
01:48:48 <lispy> CakeProphet: What are you trying to do?
01:48:52 <CakeProphet> > [1..] >>= flip Control.Monad.replicateM ['0'..'9']
01:48:53 <lambdabot>   ["0","1","2","3","4","5","6","7","8","9","00","01","02","03","04","05","06"...
01:48:56 <CakeProphet> lispy:  spell
01:48:56 <lispy> ah
01:49:19 <lispy> That's interesting
01:49:29 <CakeProphet> > [1..] >>= flip Control.Monad.replicateM ['1'..'9']
01:49:30 <lambdabot>   ["1","2","3","4","5","6","7","8","9","11","12","13","14","15","16","17","18...
01:49:53 <ivanm> CakeProphet: maybe you should read a dictionary or something if you want to be able to spell...
01:50:06 <CakeProphet> ivanm:  nah, I should just not typo.
01:52:04 <ivanm> or that
01:52:11 <CakeProphet> > drop 30 $ [1..] >>= flip Control.Monad.replicateM ['0'..'9']
01:52:12 <lambdabot>   ["20","21","22","23","24","25","26","27","28","29","30","31","32","33","34"...
01:53:18 <CakeProphet> > [3..] >>= flip Control.Monad.replicateM ['0'..'9']
01:53:19 <lambdabot>   ["000","001","002","003","004","005","006","007","008","009","010","011","0...
01:54:05 <simplechat> Hey guys, can haskell do bitshifts/etc?
01:54:18 <CakeProphet> :t .&.
01:54:19 <lambdabot> parse error on input `.&.'
01:54:25 <CakeProphet> :t (.&.)
01:54:26 <lambdabot>     Ambiguous occurrence `.&.'
01:54:26 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
01:54:26 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
01:54:27 <dolio> @faq Can Haskell do bit shifts?
01:54:27 <lambdabot> The answer is: Yes! Haskell can do that.
01:54:52 <CakeProphet> there are multiple .&.'s?
01:54:58 <RyanT5000> ivanm: when i run SourceGraph, i just get a bunch of "SourceGraph: Ambiguous infix expression"
01:55:19 <CakeProphet> :t Data.Bits.(.&.)
01:55:20 <lambdabot> Couldn't find qualified module.
01:55:27 <simplechat> dolio, i think the question is how do i get it to do bit shifts?
01:55:40 <ivanm> RyanT5000: haskell-src-exts not parsing something properly
01:55:44 <dolio> > 2 `shiftL` 5 :: Int
01:55:45 <lambdabot>   64
01:55:46 <CakeProphet> well. lambdabots namespace hates me.
01:55:53 <ivanm> I can't help it, unless I work out how to do source mangling like hlint does :s
01:56:05 <RyanT5000> ivanm: hm, perhaps because our codebase uses arrow notation constantly
01:56:36 <CakeProphet> I think the namespace just hates me
01:56:37 <ivanm> that's it
01:56:40 <CakeProphet> I'm pretty sure that's it.
01:56:43 <dolio> @hoogle shiftL
01:56:43 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
01:56:57 <simplechat> ok cool :)
01:56:58 <CakeProphet> > 3 .&. 3
01:56:59 <lambdabot>   Ambiguous type variable `a' in the constraint:
01:56:59 <lambdabot>    `Data.Bits.Bits a'
01:56:59 <lambdabot>      a...
01:57:04 <ivanm> RyanT5000: I have something like "a . b &&& c . d"; to make haskell-src-exts happy I had to make it "(a . b) &&& (c . d)"
01:57:12 <CakeProphet> uh...
01:57:16 <CakeProphet> > fix (undefined)
01:57:17 <lambdabot>   *Exception: Prelude.undefined
01:57:19 <simplechat> and just generally, is there a fast modpow library?
01:57:20 <CakeProphet> I give up. :)
01:57:28 <CakeProphet> > fix (const undefined)
01:57:29 <lambdabot>   *Exception: Prelude.undefined
01:57:41 <dolio> No. That's missing.
01:57:45 <lispy> simplechat: hmm...I wrote some code for that once
01:57:51 <simplechat> yeah
01:57:56 <CakeProphet> a -> _|_ ?
01:58:03 <CakeProphet> = const undefined
01:58:04 <simplechat> i'm learning haskell now (in case you guys didn't notice), so i'm coding up some primal action :)
01:58:04 <lispy> simplechat: I don't have quick access to it anymore.  The standard algo is very simple though
01:58:10 <simplechat> yeah
01:58:26 <RyanT5000> ivanm: hm; is there anything i can do to still use it
01:58:27 <RyanT5000> ?
01:58:35 <lispy> simplechat: heh, that's funny.  Coding up strong pseudo primality tests was one of the first things I did in Haskell to
01:58:40 <ivanm> RyanT5000: unfortunately, not as-is :s
01:59:00 <simplechat> its cool :D
01:59:02 <RyanT5000> that's too bad; it seemed cool :)
01:59:13 <ivanm> thanks!
01:59:35 <blackdog> *sigh* benchmarking snap against node showed node was faster on the pong test by about 50%. this makes me sad.
01:59:36 <ivanm> but yeah, ndm first found this bug when doing stuff with hlint; he's put a bug on hsx's bug-tracker
01:59:52 <ivanm> blackdog: once again, you should qualify what "node" is :p
01:59:57 <CakeProphet> > cycle "abc"
01:59:58 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
02:00:00 <blackdog> node.js. blah.
02:00:00 <ivanm> also, IIRC the snap guys have their own IRC channel
02:00:09 <blackdog> yeah, i just wanted to complain somewhere else:)
02:00:30 <blackdog> not enough cycles to work on hubris, which is why i'm benchmarking in the first place. nice easy work.
02:01:22 <blackdog> ivanm: it's weird talking about web stuff in a haskell context. i'm used to the ruby/js guys, they all know about that ecosystem.
02:07:13 <dibblego> what's the general consensus for organising quickcheck tests for module M ?
02:10:22 <ivanm> dibblego: if possible, make building QC tests a build-time option
02:10:39 <ivanm> apart from that, the only QC tests I currently have are for an entire package ;-)
02:11:07 <dibblego> how have you organised it as a build-time option?
02:11:24 <blackdog> dibblego: don't know that there is a consensus yet. at least in ruby, i mirror the structure of the files that each test is testing.
02:11:46 <dibblego> blackdog, haskell has specific issues relating to QC
02:12:26 <blackdog> dibblego: could you elaborate? i've used it a bit, but not enough to hit weird cases.
02:13:14 <dibblego> blackdog, e.g. QC1 and QC2 clash
02:15:07 <RyanT5000> is there a reasonable interactive "dot" viewer? or some trick that makes dotty usable?
02:15:33 <RyanT5000> (not entirely off-topic: i'm trying to use the package 'graphmod')
02:19:08 <simplechat> hey guys, is there any reason why an array of bools wouldn't have type [Bool]?
02:19:36 <Cale> simplechat: Because that's the type of a list of Bools
02:19:46 <simplechat> *list
02:19:46 <Cale> (not the same thing as an array)
02:19:51 <Cale> Okay
02:19:58 <simplechat> atm i'm building a list of bools recursively via :
02:20:03 <Cale> Sure
02:20:05 <simplechat> with [True] and [False] as base cases
02:20:13 <simplechat>     Couldn't match expected type `Bool' against inferred type `[Bool]'
02:20:18 <simplechat> but haskell is pretty damn insistant that its not
02:20:31 <Cale> > True : [True, False, False]
02:20:32 <lambdabot>   [True,True,False,False]
02:20:51 <simplechat> is there a pastebin i can use?
02:20:52 <Cale> Make sure that the thing on the left of the (:) is a Bool, and the thing on the right is a list of Bool.
02:21:08 <simplechat> the thing on the left of : is a [Bool]
02:21:16 <simplechat> because i need to create it from the left
02:21:51 <Cale> simplechat: That doesn't work.
02:21:58 <simplechat> ?
02:22:02 <Cale> :t (:)
02:22:03 <lambdabot> forall a. a -> [a] -> [a]
02:22:08 <simplechat> ah
02:22:12 <Cale> The left parameter of (:) is always an element
02:22:19 <Cale> and the right parameter is a list
02:22:30 <Cale> Lists are linked lists, so this operation is the fast one.
02:22:49 <simplechat> Couldn't match expected type `Bool' against inferred type `[a]'
02:22:50 <simplechat>     In the first argument of `(:)', namely `[False]'
02:22:53 <Cale> If you want to add an element on the other end, you sort of have to rebuild the list. You can use ++ to concatenate
02:23:08 <simplechat> kk then
02:23:10 <simplechat> i'll just restart
02:23:11 <Cale> But if you do that repeatedly, you might want to worry about performance if the lists are long.
02:23:21 <Cale> > [1,2,3] ++ [4]
02:23:22 <lambdabot>   [1,2,3,4]
02:23:38 <Cale> xs ++ ys takes O(length xs) steps to fully evaluate
02:23:53 <blackdog> dibblego: so you want to package tests that you can use with either qc1 or qc2?
02:23:58 <simplechat> hmmmm
02:23:59 <simplechat> ok
02:24:04 <simplechat> but yeah is there a pastebin i can borrow?
02:24:10 <Cale> hpaste.org
02:24:18 <Cale> oh, tsk
02:24:22 <Cale> Why is that down?
02:24:35 <Cale> http://paste.lisp.org/
02:24:36 <dafis> pastebin.com
02:24:46 <simplechat> kk
02:24:50 <simplechat> http://pastebin.ca/1907915
02:25:22 <simplechat> I'm kind of unsure as to why it would break so horribly :(
02:25:26 <dafis> simplechat: just make it True : .. and False : ..
02:25:42 <Cale> Oh, yeah, you don't want the extra brackets there
02:25:45 <simplechat> but true isn't a [Bool]?
02:25:49 <Cale> It looks like you're building a list of lists that way
02:26:01 <Cale> > [True] : [[True, False], [False]]
02:26:02 <lambdabot>   [[True],[True,False],[False]]
02:26:17 <dafis> > True : [False]
02:26:18 <lambdabot>   [True,False]
02:26:22 <dafis> simplechat: ^^
02:26:44 <Cale> Every list is either the empty list [], or it is a nonempty list having a first element x, along with another list xs, written x : xs
02:26:48 <simplechat> brb
02:27:10 <dibblego> blackdog, I just want a way to write tests without unnecessary penalty
02:27:29 <Cale> RyanT5000: I'll have a look and see if I can find anything better.
02:28:01 <RyanT5000> Cale: thanks
02:28:29 <Cale> RyanT5000: Oh, istr there was a nice Mac OS X version of graphviz
02:28:39 <Cale> http://www.pixelglow.com/graphviz/
02:28:59 <RyanT5000> oh right; and i even have a mac!
02:29:13 <RyanT5000> i always forget that i have this thing sitting here
02:29:49 <RyanT5000> i've noticed that the average quality of graph visualization software is remarkably more terrible than any other genre of software i've ever used
02:30:16 <RyanT5000> practically every offering seems to be something some guy decided to write in an afternoon
02:30:26 <RyanT5000> and then decided was too much work :)
02:30:33 <Cale> heh
02:31:12 <Cale> Well, there's Tulip. It looks really impressive, but I've never actually used it.
02:31:42 <RyanT5000> Cale: oh yeah, that does look impressive
02:32:50 <Cale> Mathematica also has some rather neat graph visualisation stuff, but compared to other stuff in Mathematica, I think it could use more work.
02:33:42 <ClaudiusMaximus> javascript infovis toolkit is quite neat (at least the demos are nice, i've not used it in anger)
02:36:54 <ClaudiusMaximus> graphviz is good, but it does annoy me immensely at times (to the extent that i add extra hidden edges to trick it into layouting nodes how i want)
02:52:56 <datwinkdaddy> simplechat: There?
02:53:46 <simplechat> yep
02:53:48 <simplechat> now i am
02:56:33 <datwinkdaddy> simplechat: I think I have a replacement for you bin post.
02:56:43 <simplechat> mmm?
02:56:59 <datwinkdaddy> simplechat: let bitdecompose num = dropWhile not . reverse . map (Data.Bits.testBit num) $ [0..(Data.Bits.bitSize num) - 1]
02:57:54 <simplechat> would you mind telling me how that works? :)
02:58:23 <datwinkdaddy> simplechat: Not at all.
02:58:28 <simplechat> :D
02:59:01 <dafis> simplechat, datwinkdaddy: minor problem
02:59:02 <datwinkdaddy> simplechat: [0..(bitsize n) - 1] is all the bit indexes.  Like [0..7] for an 8-bit value.
02:59:04 <dafis>  bitSize (0 :: Integer)
02:59:04 <dafis> *** Exception: Data.Bits.bitSize(Integer)
02:59:28 <simplechat> ok
02:59:35 <datwinkdaddy> Yeah, it doesn't work for numbers without a bitsize.
03:00:03 <dafis> so it works for Int, Word, ..., but not for Integer
03:00:23 <simplechat> Integer is what i'm going to be using
03:00:29 <datwinkdaddy> map (testBit num) indexes gives the true/false value for each bit.
03:00:38 <simplechat> Pretty much i'm trying to do modular exponentiation
03:00:39 <simplechat> efficiently
03:01:22 <dafis> simplechat: then don't construct the list, test and shift as you multiply
03:01:31 <simplechat> yeah
03:01:39 <simplechat> but i'm not sure of any nice way of doing the entire thing at once
03:01:48 <simplechat> in terms of representing the algorithm recursively
03:01:50 <datwinkdaddy> Well, then you have to do it recursively, like you were doing it.
03:02:13 <simplechat> but thats my problem
03:02:43 <datwinkdaddy> Well, mostly your code is correct.
03:02:59 <datwinkdaddy> Just drop the []'s around [True] and [False].
03:04:25 <Cale> > let xs = True : xs in xs
03:04:26 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
03:05:04 <RyanT5000> is there any way to have a type alias Id that can be used in a points-free style?
03:05:34 <simplechat> hmmm
03:05:37 <Cale> RyanT5000: Not really. You can make a newtype.
03:05:57 <RyanT5000> Cale: i specifically want to avoid having to explicitly wrap and unwrap
03:06:05 <Cale> RyanT5000: type aliases can't be used points-free
03:06:26 <Cale> (they don't really exist as far as the typechecker is concerned)
03:07:53 <datwinkdaddy> simplechat: let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then False else True) : bitdecompose (num `shiftR` 1)
03:08:24 <datwinkdaddy> > (\num -> if num == 0 then [] else (if num .&. 1 == 1 then False else True) : bitdecompose (num `shiftR` 1)) 5
03:08:25 <lambdabot>   Not in scope: `bitdecompose'
03:09:10 <datwinkdaddy> > let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then False else True) : bitdecompose (num `shiftR` 1) in bitdecompose 5
03:09:11 <lambdabot>   Ambiguous type variable `t' in the constraint:
03:09:11 <lambdabot>    `Data.Bits.Bits t'
03:09:11 <lambdabot>      a...
03:09:20 <datwinkdaddy> > let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then False else True) : bitdecompose (num `shiftR` 1) in bitdecompose (5 :: Integer)
03:09:21 <lambdabot>   [False,True,False]
03:09:40 <datwinkdaddy> So, yeah, test and shifting were backwards.
03:09:47 <datwinkdaddy> > let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then False else True) : bitdecompose (num `shiftR` 1) in bitdecompose (10 :: Integer)
03:09:48 <lambdabot>   [True,False,True,False]
03:10:20 <datwinkdaddy> > let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then True else False) : bitdecompose (num `shiftR` 1) in bitdecompose (11 :: Integer)
03:10:20 <lambdabot>   [True,True,False,True]
03:11:21 <dafis> > let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then True else False) : bitdecompose (num `shiftR` 1) in bitdecompose ((2^30247+1) :: Integer)
03:11:21 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
03:12:43 <ivanm> Cale: did you see my blog post regarding the results of the fgl naming survey?
03:12:55 <dafis> > let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then True else False) : bitdecompose (num `shiftR` 1) in (length . filter id) bitdecompose ((2^30247+1) :: Integer)
03:12:55 <lambdabot>   Couldn't match expected type `t1 -> t'
03:12:56 <lambdabot>         against inferred type `GHC.T...
03:13:12 <dafis> > let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then True else False) : bitdecompose (num `shiftR` 1) in (length . filter id) (bitdecompose ((2^30247+1) :: Integer))
03:13:13 <lambdabot>   2
03:13:24 <dafis> > let bitdecompose num = if num == 0 then [] else (if num .&. 1 == 1 then True else False) : bitdecompose (num `shiftR` 1) in (length . filter id) (bitdecompose ((2^30247-1) :: Integer))
03:13:25 <lambdabot>   30247
03:13:59 <ivanm> dafis: do you realise you can privmsg lambdabot?
03:14:29 <dafis> ivanm: in principle, I tend to forget, however :/
03:14:35 <ivanm> heh
03:15:19 <Cale> ivanm: Oh, no I didn't
03:15:37 <ivanm> http://ivanmiljenovic.wordpress.com/2010/07/25/results-of-fgl-naming-survey/
03:15:37 <datwinkdaddy> dafis: Look good?
03:15:51 <ivanm> interested in your opinion of my first compromise at the end
03:16:40 <dafis> datwinkdaddy: what? the algorithm is correct, I'm just not sure about the performance (Bits instance for Integer raises doubts)
03:19:25 <noteed> ivanm: it seems you make the situation even more problematic, w.r.t. what is what, and w.r.t. the question about changing/keeping the name
03:19:56 <ivanm> noteed: with the compromise, or the survey results?
03:20:42 <noteed> ivanm: if you want to provide a superset library, then keep fgl for what it is already (by this, I include your rewrite)
03:20:49 <noteed> ivanm: the compromise
03:20:52 <ivanm> *nod*
03:21:02 <ivanm> well, I'm trying to decrease the bitching ;-)
03:21:08 <ivanm> but I don't want to give up the name "fgl"
03:21:12 <datwinkdaddy> ivanm: I'm not in the community, but I think if you are going to break the API, you might as well switch to a meaningful package name.  If you want to use FGL for something completely different later you can usurp that name then.
03:21:37 <ivanm> datwinkdaddy: except the version specifies the API...
03:22:14 <Cale> ivanm: I'm kind of thinking that inductive-graphs is a better name in the first place
03:22:20 <noteed> ivanm: then keep fgl for the rewrite, but it seems you're asking for even more bitching: you ask again about using fgl for someting else
03:22:21 <datwinkdaddy> dafis: Well, performance on Integer is never stellar.  It's good, but not stellar.
03:22:56 <ivanm> Cale: oh, agreed; I just don't think the name "fgl" should be discarded
03:23:00 <Cale> ivanm: But I don't really care either way, myself.
03:23:10 <ivanm> noteed: true
03:23:30 <ivanm> datwinkdaddy: well, for values that are Ints, Integer is just a wrapper around Int
03:23:32 <ivanm> @src Integer
03:23:33 <lambdabot> data Integer = S# Int#
03:23:33 <lambdabot>              | J# Int# ByteArray#
03:24:13 <noteed> ivanm: the poll (and the previous cafe thread) shows you won't be able to reach a massive consensus (it is close to 50/50), so you can choose whatever you want
03:24:20 <datwinkdaddy> defis: I'm not sure if you are going to come up with a faster implementation that doesn't use Data.Bits; the alternative is using `mod` or `rem` which are both slow-ish.
03:24:45 <ivanm> noteed: yup; this way, however, I can _prove_ that
03:25:16 <datwinkdaddy> ivanm: Good to know.  But I think dafis/simplechat are dealing with numbers like 2^32000.
03:25:18 <RyanT5000> does anyone know how STRef performance compares to IORef performance? are they identical?
03:25:33 <noteed> ivanm: yes, but anyway it was fine to ask beforehand
03:26:08 <noteed> ivanm: but now that is done, I really wondered when reading your post why you proposed somethign else
03:26:28 <ivanm> because I thought of it as writing
03:26:59 <ivanm> and I prefer consensus over autocracy (which is one of the nicer things about Haskell as a language community; we don't have an individual saying "we're going to do such-and-such because I prefer it")
03:27:41 <gwern> ivanm: the lack of a benevolent dictator can be a problem though...
03:27:59 <ivanm> gwern: true
03:28:02 <noteed> ivanm: well clearly *you* have to pick a side :)
03:28:14 <ivanm> noteed: yeah, but as a language overall...
03:28:28 <ivanm> gwern: however, our closest equivalent is SPJ shoving yet another cool feature into ghc ;-)
03:28:29 <noteed> ivanm: precisely because there are two of them
03:28:47 <ivanm> but yes, if we had a benevolent dictator the mtl/transformers mess would have been solved long ago
03:28:48 <datwinkdaddy> dafis: If you are really concerned with performance on Integer, and aren't worried about alternative implementations, you could take advantage of the Integer implementation.
03:29:36 <simplechat> IS there any way to coerse say float to int?
03:29:37 <dafis> datwinkdaddy: that's what I'm thinking about
03:29:40 <simplechat> and do a type conversion?
03:30:03 <dafis> simplechat: dou you want the bit-pattern or the value?
03:30:14 <datwinkdaddy> dafis: Have the function either use the Data.Bits instance for Int (for small Integers) or process the number as a Byte array using the Data.Bits instance for Byte and "shifting" a byte at a time.
03:30:38 <datwinkdaddy> > floor 2.34
03:30:39 <lambdabot>   2
03:30:44 <simplechat> value
03:30:49 <datwinkdaddy> simplechat: ^^
03:31:00 <datwinkdaddy> :t floor (2.34 :: Float)
03:31:01 <lambdabot> forall b. (Integral b) => b
03:31:04 <dafis> datwinkdaddy: I think shifting by 32 bits would be better, afair, shifting Integers is division
03:31:06 <simplechat> ah
03:31:06 <simplechat> floor
03:31:07 <simplechat> thanks :D
03:31:45 <datwinkdaddy> dafis: Well, the @src Integer has large Integers implemented in terms of ByteArray.
03:31:52 <dafis> simplechat: if you need performance, truncate is much faster
03:32:05 <datwinkdaddy> dafis: So, I mean processing individual elements of that ByteArray.
03:32:18 <datwinkdaddy> @src Integer
03:32:18 <lambdabot> data Integer = S# Int#
03:32:18 <lambdabot>              | J# Int# ByteArray#
03:32:24 <simplechat> dafis, truncate?
03:32:30 <datwinkdaddy> :t truncate
03:32:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:32:41 <datwinkdaddy> :t truncate (2.34 :: Float)
03:32:42 <lambdabot> forall b. (Integral b) => b
03:32:50 <datwinkdaddy> > truncate 2.34
03:32:50 <lambdabot>   2
03:33:02 <dafis> datwinkdaddy: yes, but I'd rather not rely on integer-gmp, so if the portable way is fast enough, I'll take that
03:33:06 <simplechat>     No instance for (RealFrac Integer)
03:33:07 <simplechat>       arising from a use of `truncate' at test.hs:21:45-60
03:33:07 <simplechat> ?
03:33:10 <datwinkdaddy> > (truncate (-2.34), floor (-2.34))
03:33:11 <lambdabot>   (-2,-3)
03:33:47 <simplechat> truncate isn't an integer?
03:34:32 <datwinkdaddy> truncate is a function taking any RealFrac instance and returning any Integral instance.
03:34:43 <dibblego> the problem with putting QC tests in another module is that Arbitrary instances become orphan
03:34:57 <simplechat> datwinkdaddy, any way to force it to return integers?
03:35:09 <mauke> simplechat: it already does
03:35:14 <datwinkdaddy> > (truncate 256.78 :: Integer, truncate 256.78 :: Data.Int.Int8)
03:35:15 <lambdabot>   (256,0)
03:35:18 <dafis> simplechat: at the type Float -> Int, with optimisations, truncate gives you a primop
03:35:33 <simplechat> > :t any
03:35:34 <lambdabot>   <no location info>: parse error on input `:'
03:35:39 <ManateeLazyCat> When i use some function in my code, such as "Foo.bar", ghc will infer the "package name", which GHC-API can do that?
03:35:45 <datwinkdaddy> :t any
03:35:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:35:51 <dafis> simplechat: floor needs additional processing
03:35:51 <simplechat> mauke, then why did it error out?
03:36:01 <mauke> simplechat: because you tried to truncate an integer
03:36:02 <datwinkdaddy> simplechat: No ">" for colon-commands.
03:36:06 <simplechat> > [3... truncate sqrt 10]
03:36:07 <lambdabot>   Not in scope: `...'
03:36:08 <mauke> simplechat: integers are already integers
03:36:15 <simplechat> > [3..truncate sqrt 10]
03:36:16 <lambdabot>   No instance for (GHC.Real.RealFrac (a -> a))
03:36:16 <lambdabot>    arising from a use of `GHC....
03:36:26 <mauke> and now you tried to truncate sqrt, a function
03:36:27 <datwinkdaddy> > [3..truncate $ sqrt 10]
03:36:27 <lambdabot>   [3]
03:36:35 <simplechat> ok then
03:36:39 <simplechat> i'm rather stupid
03:36:45 <datwinkdaddy> > [3..ceiling $ sqrt 10]
03:36:45 <lambdabot>   [3,4]
03:37:07 <simplechat> cool
03:38:18 * ManateeLazyCat looks lookupModuleInAllPackages is i need, testing ....
03:38:39 <simplechat> ok 
03:38:51 <simplechat> why is it that haskell always seems to make me look like a complete and utter idiot?
03:39:18 <datwinkdaddy> simplechat: It does to that to me, too.
03:39:27 <simplechat> damn smart programs
03:39:53 <datwinkdaddy> simplechat: Still, I like the way it (my Haskell code) breaks a lot better than when my C code breaks.
03:40:10 <ivanm> simplechat: it does that to _everyone_... ;-)
03:40:33 <ClaudiusMaximus> hey, wouldn't it be great if hp2ps would support the arcane "fix it so it works" command-line for incomplete .hp files natively? how hard would it be to add?  ( ref: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/hp2ps.html#id645789 )
03:41:36 <datwinkdaddy> simplechat: I think too much OOP has made us look at "foo bar baz 6" as "foo->bar->baz(6)" or "foo.bar.baz(6)" instead of the way haskell sees it: "foo(bar, baz, 6)"
03:41:48 <simplechat> yeah
03:42:06 <datwinkdaddy> I still continuously screw up my usage of (.) and ($) when I'm trying to avoid parens.
03:42:16 <simplechat> yeah
03:42:37 <simplechat> this will probably make me seem like an absolute noob, but why does this fail when compiled but not with ghci? http://pastebin.ca/1907942
03:42:41 <dafis> datwinkdaddy: it's ((foo bar) baz) 6
03:42:46 <ivanm> datwinkdaddy: a . b . c . d $ h x
03:42:51 <ivanm> or a . b . c . d . h $ x
03:43:16 <ivanm> simplechat: defaulting
03:43:24 <simplechat> ?
03:43:26 <dafis> :t sqrt
03:43:27 <lambdabot> forall a. (Floating a) => a -> a
03:43:28 <datwinkdaddy> dafis: same thing modulo currying.
03:43:37 <ClaudiusMaximus> well, ((((foo())(bar()))(baz()))(6)) if you must have brackets around arguments to functions
03:43:45 <simplechat> i run the same command in ghci and it gives me a list
03:43:52 <ivanm> no, wait, I may be lying...
03:43:54 <dafis> simplechat: sqrt expects an instance of Floating
03:43:59 <ivanm> @type truncate
03:44:00 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:44:04 <ivanm> wait, yes, it is defaulting
03:44:12 <dafis> simplechat: in ghci, you give a literal number
03:44:13 <ivanm> simplechat: ghci will tell that in the truncate bit it needs a RealFrac and choose Double
03:44:24 <ivanm> oh, wait, what dafis says makes more sense ;-)
03:44:24 <RayNbow> @let isqrt x = truncate . sqrt . fromIntegral $ x
03:44:26 <lambdabot>  Defined.
03:44:31 <ivanm> I thought ghci was interpreting that properly
03:44:37 <dafis> simplechat: truncate $ sqrt (fromInteger x)
03:44:40 <RayNbow> > sqrt (3 :: Integer)
03:44:41 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Internals.Integer)
03:44:42 <lambdabot>    arisi...
03:44:44 <RayNbow> > isqrt (3 :: Integer)
03:44:45 <lambdabot>   1
03:45:00 <simplechat> dafis, frominteger to?
03:45:18 <RayNbow> :t fromIntegral
03:45:19 <lambdabot> forall a b. (Integral a, Num b) => a -> b
03:45:27 <dafis> simplechat: whatever, default is Double
03:45:28 <adu> when was that Tokyo Haskell group meeting?
03:45:46 <simplechat> kk
03:45:52 <dafis> (when sqrt is applied)
03:46:06 <ivanm> the magic of fromInteger!!!
03:46:17 <lispy> I could use some help
03:46:17 <lispy> http://haskell.pastebin.com/DWLbCSZm
03:46:27 <ClaudiusMaximus> @quote who.you.gon
03:46:27 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
03:46:31 <lispy> I'm totally stumped as to why GHC thinks Maybe should have a ParserM instance.  It doesn't.
03:46:41 <ivanm> lispy: _you_ need help? :o
03:46:49 <lispy> ivanm: aye!
03:46:53 <lispy> Needz it
03:47:25 <ivanm> lispy: do you have _any_ instances for ParserM?
03:47:37 <lispy> ivanm: yeah, just a sec
03:47:46 <dafis> lispy: somebody *might* write a ParserM instance
03:48:04 <lispy> dafis: how do I fix this?
03:48:06 <ivanm> dafis: I was thinking that, but wanted to avoid saying so until I bothered to check myself ;-)
03:48:22 <Gracenotes> overlapping instances? *sadface* :(
03:48:22 <dafis> lispy: beats me :(
03:48:30 <ivanm> lispy: that's why the "instance Foo a => Bar a" style of instances is kinda frowned upon
03:48:43 <lispy> ivanm: http://haskell.pastebin.com/BymWSWw2
03:48:59 <lispy> Hmm
03:49:17 <Gracenotes> lispy: how sadomasochistic
03:49:28 <lispy> Gracenotes: haha
03:49:34 <lispy> Gracenotes: it stands for Strict Monad
03:49:38 <lispy> not my invention
03:49:53 <ivanm> Gracenotes: go wash your mind out with soap!
03:49:53 <Gracenotes> actually, other than overlapping instances, best way might be to manually define a functor for every SM instance
03:50:04 <Gracenotes> moar sadface
03:50:24 <lispy> Gracenotes: hmm you mean ParserM instance?
03:50:34 <Gracenotes> er right.
03:50:52 <lispy> Let me explain why I'm doing this
03:51:05 <lispy> I want to be able to use the more conventional parser styles
03:51:11 <lispy> Like applicative and alternative
03:51:16 <lispy> Oh, and mainly MonadPlus
03:51:28 <lispy> But the code uses ParserM m => .... in all the type sigs for parsers
03:51:28 <ivanm> lispy: why not just use liftM btw rather than "return . f" ?
03:51:38 <lispy> So I thought, "Hey, I'll make PaserM support these things..."
03:51:52 <lispy> ivanm: Hm.  Good point.
03:52:40 <lispy> What I really want to do, is make Parsec/Attoparsec/etc instances of ParserM but that can't happen due to alterInput and friends
03:55:02 <lispy> Gracenotes: so that works, except now I have the same exact problem with my MonadPlus instance
03:57:39 <lispy> So, I guess I'll write the instances against SM instead of ParserM
03:58:19 <lispy> It's not really important that I use ParserM instead of SM, but I had hoped I could put all my parsers into one interface, the ParserM one
03:58:46 <Gracenotes> oh. can't really bluff through those. (well, in a non-ad-hoc way). does http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#instance-overlap look manageable?
04:00:41 <lispy> Gracenotes: if I used an extension like that I'd have to defend its use to the other devs.  That may actually be more work :)
04:02:18 <Gracenotes> lispy: ah. another solution: it might not be an insurmountable cost to write (MonadPlus m, ParserM m) => ..., for every public interface type
04:02:39 <Gracenotes> not too bad really
04:02:41 <lispy> Gracenotes: what do you mean?
04:02:57 <lispy> Gracenotes: Oh!
04:03:05 <lispy> Gracenotes: yeah, I think that's what I was planning to do
04:03:37 <ivanm> Gracenotes: if only we had class aliases... :s
04:03:40 <lispy> Gracenotes: just disappointed that I can't stuff the MonadPlus dictionary into the ParserM dictionary
04:04:02 <Gracenotes> that's what happstack does incidentally, http://hackage.haskell.org/packages/archive/happstack-server/0.5.0.2/doc/html/Happstack-Server-SimpleHTTP.html#8
04:04:46 <Gracenotes> but not all of the methods which require ServerMonad also require MonadPlus. only those which might fail, or in which some alternative might fail
04:06:16 <simplechat> Is there any way to transparently memoise in haskell?
04:06:29 <ivanm> there are various memo functions, etc.
04:06:35 <ivanm> but why would you want to do such a thing?
04:06:56 <simplechat> stop massive amounts of recomputation :)
04:07:09 <Gracenotes> there are some good reasons. most of the time, if I know the set of values I want to keep tabs on, I stuff it all in a Data.Map
04:07:11 <ivanm> well, maybe that indicates that you should fix your code so that you're not recomputing stuff
04:07:13 <Gracenotes> and that suffices
04:07:17 <ivanm> rather than trying to get something to do it for you
04:07:30 <simplechat> kk
04:07:31 <ivanm> Gracenotes: exactly; most memo packages just do something like that under the hood for you
04:07:37 <Tarrasch> ivanm, isn't that a common way to make O(x^n) to O(n) :) ?
04:07:55 <Gracenotes> simplechat: the good part of that approach is that you don't have to modify the map; all of the values are lazily there for you
04:08:08 <datwinkdaddy> simplechat: Technically, Haskell is basically allowed to memoize anything that is safe to memoize.
04:08:57 <simplechat> but does it actually memorise things for me?
04:09:07 <simplechat> its pretty much, i'm spitting out a list of primes
04:09:20 <simplechat> now as i'm computing the list of primes, i want to use the part thats already been computed so that i can do trial division
04:09:21 <ivanm> Tarrasch: huh?
04:09:26 <dafis> simplechat: just give a name to the list of primes
04:09:28 <datwinkdaddy> simplechat: I don't know how to explictly do it transparently or inform GHC to force a function to memoized.
04:09:37 <simplechat> datwinkdaddy, kk
04:09:40 <simplechat> dafis, more information?
04:09:48 <ivanm> datwinkdaddy: you can't
04:10:03 <ivanm> unless you're talking about lazy evaluation of thunks for constants
04:10:05 <Tarrasch> ivanm, I wanted to say that memoization can even improve the complexity of your program
04:10:32 <dafis> simplechat: top-level definitions; primes :: [Integer]; primes = 2:3:filter isPrime [5, 7 .. ]
04:10:47 <ivanm> Tarrasch: my point is that if you think memoisation will improve your code complexity, maybe you should work on fixing your code so you don't need a memo package/function to do it for you
04:10:50 <datwinkdaddy> simplechat: give your infinite list of primes a name, so it won't be GC'd and re-use it.
04:10:52 <dafis> isPrime n = trialDivision primes n
04:11:32 <simplechat> datwinkdaddy, so if i give it a name on the top level scope, nothing will explode as i try and make it whilst using it internally?
04:11:38 <dafis> trialDivision (p:ps) n | p*p > n = True; | otherwise = n `rem` p /= 0 && trialDivision ps n
04:11:41 <lispy> Gracenotes: Oh!  I just have to say, class (MonadPlus m, ..., Monad m) => ParserM m where ...
04:11:58 <lispy> Gracenotes: Then I provide the MonadPlus etc instances for the types and I'm good to go
04:12:00 <Gracenotes> lispy: oh yeah, that slipped my mind.
04:12:03 <Tarrasch> ivanm, but isn't it better to reuse code than write it yourself? (I've never used any memo package and I assume they all use unsafePerformIO in some way)
04:12:18 <Gracenotes> lispy: the problem with that is that you can't define MonadPlus in terms of ParserM
04:12:21 <datwinkdaddy> simplechat: lazy evaluation means it won't call isPrime too many times.
04:12:25 <ivanm> Tarrasch: AFAIK, they don't; they do stuff with Data.Map (well, some do at least)
04:12:31 <lispy> Gracenotes: hmm.
04:12:43 <ivanm> Tarrasch: but I'm rather suspicious of "magic" fixes
04:12:59 <ivanm> and prefer explicit fixing of things like that rather than saying "oh, and save that result for me to avoid recomputing it"
04:13:01 <lispy> Gracenotes: it compiles.  Will I hit infinite recursions?
04:13:08 <ivanm> why not just set it up so that you don't recompute it in the first place?
04:13:09 <Gracenotes> lispy: so I assumed that was infeasible in your situation... hm, though maybe if you split off things..
04:13:09 <ClaudiusMaximus> on memoization: i had to change some code recently to make it recompute instead of share; the sharing was bad for space usage (i was exploring an infinite lazy tree..)
04:13:23 <simplechat> hmmm
04:13:26 <dibblego> is there any way to get an Arbitrary String without instance Arbitrary Char for QC 1.2.0.0?
04:13:30 <Tarrasch> isn't a typical type for them;     memo :: (a -> b) -> (a -> b) ? Then they must use unsafePerformIO, no?
04:13:31 <Gracenotes> lispy: hm, I guess it'll be fine so long as everything's in the same module
04:13:39 <dafis> ivanm: there are algorithms where you need to use some values often; memoising them can bring down the complexity by several orders
04:13:39 <lispy> Gracenotes: yeah, all in the same module
04:13:41 <simplechat> just as an odd sort of a question, but is there any reason why haskell isn't automatically multicored and automatically memorised?
04:13:46 <mats_> simplechat: there is a memoization package in hackage that will allow you to use memoization; it is otherwise difficult to implement in Haskell without the use of special hackish things because memorize has pseudo-sideeffects (effectively a cache)
04:13:59 <Gracenotes> which is somewhat fragile, but no matter. after the ParserM doesn't actually use any MonadPlus fuctions, so no infinite recursion I think.. I thnk
04:14:03 <lispy> Gracenotes: My goal is to make my custom parser so similar to conventional parsers that I can just use a different type class instances
04:14:04 <ClaudiusMaximus> simplechat: it's very hard
04:14:06 <simplechat> kk
04:14:07 <Gracenotes> *after all
04:14:13 <simplechat> ClaudiusMaximus, ?
04:14:22 <simplechat> hmmm
04:14:23 <simplechat> ok
04:14:25 <ivanm> dafis: do so explicitly then
04:14:35 <dibblego> Tarrasch, http://research.microsoft.com/en-us/um/people/simonpj/papers/weak.htm
04:14:41 <ivanm> Tarrasch: they return a closure...
04:14:43 <dafis> ivanm: I thought using memo is explicit
04:14:47 <lispy> Gracenotes: I could just be safe and define the functions outside of the type classes
04:14:53 <lispy> Gracenotes: I think I'll do that
04:14:56 <Tarrasch> simplechat, I've always asked myself that same question ...
04:14:58 <ivanm> dibblego: I've written genString functions
04:15:04 <lispy> Gracenotes: then the instances will just read foo = fooM
04:15:07 <Gracenotes> lispy: yes, since you're only using SM
04:15:11 <ivanm> (since I didn't like the output of the default arbitrary instance)
04:15:26 <dibblego> ivanm, QC1 doesn't have Arbitrary Char
04:15:29 <ClaudiusMaximus> simplechat: it's much easier for a programmer to say "oh btw you can evaluate this in parallel, and you can share this value" than for a compiler to guess that "it'll be worth it to evaluate these in parallel, and sharing this value won't take up too much heap space"
04:15:36 <Gracenotes> lispy: this is a lot more work per-instance than what you originally had, but that's not what software engineering is about, right? ... -.-
04:15:40 <ivanm> dibblego: well, you can write one, can you not?
04:15:48 <lispy> hehe
04:15:51 <ivanm> dibblego: also, any particular reason for not using QC2?
04:15:58 <dibblego> ivanm, yes, but it will be orphaned
04:16:04 <dibblego> ivan, I am using test-framework
04:16:27 <Gracenotes> lispy: well haskell can have design patterns too. anyhow..
04:16:36 <ivanm> dibblego: orphan, schmorphan
04:16:46 <ivanm> and IIRC, test-framework has QC2 support as well...
04:17:04 <ivanm> dibblego: test-framework-quickcheck2 ;-)
04:17:09 <lispy> Gracenotes: yeah, I think I'm okay with this now though
04:17:16 <Tarrasch> ClaudiusMaximus, but seriously, seems like quite simple thing to implement that you for your top-level-functions add a property to memoize (given that all arguements are an instance of Order (so you can use Map))
04:17:34 <dibblego> ivanm, yeah I'll fiddle with it tomorrow
04:18:24 <ClaudiusMaximus> Tarrasch: right, but it's not that much more work for a programmer to implement, and it's not always desireable to memoize (imagine if (+1) :: Integer -> Integer was memoized...)
04:18:42 * dafis shudders
04:18:42 <ivanm> dibblego: but orphan instances aren't that big a deal, especially for isolated test suites you're not going to be exporting
04:19:17 <ivanm> Tarrasch: stuff like memo functions prevent you from getting into the habit of writing good code
04:19:39 <dafis> ivanm: huh?
04:19:51 <ivanm> dafis: huh?
04:19:54 <dibblego> ivanm, they are to me, since they piss me off
04:20:01 <dibblego> ivanm, I also have nowhere to put them
04:20:04 <ivanm> dibblego: heh, fair enough
04:20:18 * hackagebot hexpat 0.18.2 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.18.2 (StephenBlackheath)
04:20:28 <dafis> ivanm: why would memo functions prevent you from getting into the habit of writing good code?
04:20:34 <datwinkdaddy> Plus, I think usally a DP approach results in better time than memoization, usually.
04:20:37 <Tarrasch> ClaudiusMaximus, well it's not always desirable, as I said it could be an property the programmer sets for all top-level functions. Also, is it really that easy to implement memoize in functions in haskell? I know it is in other languages, but how can you memoize in a lnaguage without side-effects?
04:21:21 <ivanm> dafis: why write code that requires recomputation?
04:21:37 <ivanm> why not get into the habit of writing your code such that you it doesn't have to do recomputation?
04:22:23 <dafis> ivanm: sometimes you need reuse; then you can recompute or memoise; sometimes one is preferable, sometimes the other
04:22:47 <mats_> ivanm: additionally, knowing which computations are not required ahead of time can lead to much more complicated code
04:23:10 <ivanm> uhhhh.... why are you recomputing _anything_?
04:23:25 <datwinkdaddy> @hoogle memo
04:23:25 <lambdabot> Codec.Compression.GZip data MemoryLevel
04:23:26 <lambdabot> Codec.Compression.GZip MemoryLevel :: Int -> MemoryLevel
04:23:26 <lambdabot> Codec.Compression.Zlib data MemoryLevel
04:23:35 <Tarrasch> ivanm, mind I give you some typical programming-problem that "recomputation" is vital, and you code a haskell-solution to the problem?
04:23:54 <arw> ivanm: because often, it depends on the input data what you will have to compute and what you won't.
04:23:56 <mats_> ivanm: "writing your code such that it doesn't have to do recomputation" is equivalent to saying "perform dynamic programming rather than memoization" which requires potentially doing lots and lots of extra code design for no asymptotic speedup
04:24:00 <Tarrasch> ivanm, will need your attention for a little time, but I think ew both can learn from it
04:24:30 <ivanm> Tarrasch: at the moment, no, I can't
04:24:33 <ivanm> as I've got stuff to do
04:24:35 <Tarrasch> ivan, ah ok
04:24:50 <dafis> Tarrasch: what would it have been?
04:24:53 <Tarrasch> mats_, agreed
04:25:06 <Tarrasch> dafis, You want to hear the problem statement?
04:25:07 <simplechat> Hey dafis with your primes = .... is there any reason why i'd get the error     Couldn't match expected type `a -> [a1]'
04:25:07 <simplechat>            against inferred type `[Integer]'
04:25:15 <dafis> Tarrasch: yes
04:25:20 <ivanm> _however_, I still believe that explicitly using a Map or something to "cache" results is preferable to trying to use an automagic memoisation function
04:26:22 <simplechat> dafis, i've defined primes properly its just not recognising the types
04:26:23 <dafis> simplechat: didn't see any problem, paste?
04:26:24 <mats_> Tarrasch: though it can sometimes (often?) give a space reduction, I think, maybe
04:27:04 <simplechat> dafis,  http://pastebin.ca/1907958
04:27:08 <Tarrasch> dafis, in one second, 
04:27:52 <mats_> memoization can blow the recursion depth if not careful or if the problem is huge, so there can be reasons to do the extra work and make sure not to recompute; not sure if there are other tricks to deal with this though
04:27:54 <simplechat> dafis, actually, don't worry
04:27:56 <simplechat> i was being stupid
04:29:27 <Tarrasch> dafis, let's say you have a lot (infinite) numbers of boards, they are in sizes of 1, 2 and 3. You want to glue these together into a board of size of length n (given input), you want to know in how many ways you can glue together a board like this.
04:30:13 <Tarrasch> dafis, visual solution for n = 4, http://www.csc.kth.se/contest/ioi/plankan.png
04:31:17 <dafis> Tarrasch: Yep.
04:31:56 <Tarrasch> dafis, with arrays you do get a linear time solution (assuming big ints get added in O(1))
04:32:44 <dafis> Tarrasch: yes, without memoising, it's 3^n, I think
04:32:50 <hpc> @src ap
04:32:50 <lambdabot> ap = liftM2 id
04:32:52 <Tarrasch> dafis, correct
04:33:00 <hpc> :t ap
04:33:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:33:18 <Tarrasch> dafis, and you should be able to do it in O(n) too if haskell allowed array-memoization, I still think it's a good idea to have that as a property for functions, we still maintain referential transparency, no? 
04:34:13 <Tarrasch> dafis, I have no idea how hard that would be to implement, but it surely is doable.
04:34:21 <dafis> Tarrasch: the problem is that arrays take O(n) space, so you can array-memoise only small ranges
04:35:02 <Tarrasch> dafis, sure, but thats still no problem, the haskell programmer can just say the range to array-memoize, and maybe even combine it with map-memoize.
04:35:21 <dafis> Tarrasch: in this case, though, a hand-rolled array memoisation would be better than infinite-map memoisation
04:35:46 <Tarrasch> dafis, I mean problem in theory, it may be veeeeeeeeery hard to implement, but I don't know, I've no idea how to implement the language haskell ...
04:36:07 <dafis> Tarrasch: I take it your first name is not Simon?
04:36:15 <Tarrasch> dafis, ;)
04:36:44 <dafis> k, have to leave for a while
04:36:44 <Tarrasch> dafis, is it Simon Peyton Jones and Simon Marlow who do most of the implementation of Haskell or something, never got the Simon-jokes :p
04:37:00 <Tarrasch> dafis, nice talking to you
04:37:05 <dafis> Tarrasch: both, that's the joke
04:37:10 <Tarrasch> ah ok
04:37:13 <dafis> Tarrasch: same
04:39:55 <datwinkdaddy> Tarrasch: Seems like DP is a better solution, lower space complexity.  I think space O(4) and time O(n * time to multiply bug numbers).
04:40:10 <bremner> O(4)?
04:40:24 <datwinkdaddy> O(c), I was just being more specific.
04:40:38 <ivanm> it's called "O(1)"
04:40:58 <bremner> or 4
04:41:50 <datwinkdaddy> ivanm: O(c1 * c2) = O(c).  Therefore O(4) = O(1). 
04:41:56 <Tarrasch> datwinkdaddy, I know what you mean by O(4) and you're thinking right for this problem, and yea, I realize this was a poor example since you don't neeed memoization for this
04:42:38 * hackagebot gnuplot 0.4 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.4 (HenningThielemann)
04:43:21 <simplechat> Fib numbers are crying for some memoisation
04:43:40 <Tarrasch> In fact, it was a good example showing that you shouldn't be tempted to write code that memoizes when you don't need to
04:43:49 <Tarrasch> simplechat, irony?
04:44:43 <simplechat> ?
04:45:03 <simplechat> it drops from o(n!) to o(n) with memoisation :)
04:45:18 <Tarrasch> simplechat, what problem are you thinking of when you say Fib numbers?
04:45:28 <simplechat> creating the set of fibonacci numbers
04:45:32 <simplechat> recursively
04:45:46 <Tarrasch> calculating fib(#n) goes in O(n) time O(1) space I think, 
04:46:02 <simplechat> recursively  its o(n!)
04:46:04 <simplechat> just try it :)
04:46:06 <simplechat> naively
04:46:19 <simplechat> when you add memo it drops to o(n) time
04:46:43 <Tarrasch> simplechat, yea I know, you're right but I wanted to stress the fact that you can do it in a better way without memoization
04:47:23 <bremner> simplechat: recursively it is more like O(2^n), I think. Still not good :).
04:47:54 <Tarrasch> yea, bremner is right, it's not O(n!) :)
04:48:07 <proc> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
04:48:10 <Tarrasch> and not O(2^n) either but closer to that
04:48:14 <proc> there you find some implementations
04:48:41 <simplechat> kk
04:50:48 <c_wraith> eh?  calculating fib(n) recursively is O(fib(n))
04:51:24 <dafis> and fastfib(n) is O(log n)
04:51:27 <c_wraith> think about it.  You're building a tree of pluses, with the roots all being ones.
04:51:40 <dafis> (assuming constant time arithmetics)
04:51:40 <Tarrasch> c_wraith, yea, I realized that now
04:52:00 <Tarrasch> c_wraith, you mean leafs being ones?
04:52:06 <c_wraith> err, yes, I do
04:52:30 <c_wraith> so your tree has fib(n) ones, and fib(n)-1 pluses.
04:52:52 <c_wraith> ...  Of course, that's assuming that arithmetic is constant time.  Not true in the general case, but it complicates things.  :)
04:53:04 <Tarrasch> c_wraith, yea, good reasoning
05:20:42 <ClaudiusMaximus> some work-in-progress of my reimplementation of hp2ps in Haskell   http://pastebin.ca/1907976   (let me know if someone's already doing that job, but the GHC trac task for that seems desolate)
05:21:26 <ClaudiusMaximus> and a question: what's a good library if i want nice vector output (ie: svg, (e)ps, pdf)?
05:22:23 <polanski> re fib(n), you can use the formula :P
05:23:13 <ClaudiusMaximus> > let { phi = (sqrt 5 + 1) / 2 ; fib n = ceiling (phi ^^ n) } in fib 42
05:23:14 <lambdabot>   599074578
05:23:23 <ClaudiusMaximus> polanski: that one?
05:23:37 <ClaudiusMaximus> or maybe i got it wrong..
05:23:42 <polanski> more or less that
05:23:44 <hpc> well, svg uses xml
05:23:57 <dafis> ClaudiusMaximus: one nit: reverse . sortBy (comparing snd) === sortBy (flip $ comparing snd)
05:24:00 <polanski> you need the other sqrt5-1 bit as well as far as i remmeber.
05:24:31 <ClaudiusMaximus> polanski: ah, even though it -> 0 as n->large?
05:24:32 <dafis> polanski: breaks for large indices
05:24:42 <dafis> due to Double limitations
05:25:00 <polanski> mathematically its sound but yes larger indices cause probs
05:25:01 <ClaudiusMaximus> dafis: ah good point, but this is just toying around at the moment :)  thanks
05:25:06 <dafis> it's round (phi^n / sqrt 5)
05:25:49 <ClaudiusMaximus> > let { phi::CReal ;  phi = (sqrt 5 + 1) / 2 ; fib n = round (phi ^^ n / sqrt 5) } in fib 42
05:25:50 <lambdabot>   267914296
05:25:54 <polanski> f(n) = [phi^n - (1-phi^n) ] / sqrt 5
05:26:13 <polanski> * (1-phi)^n
05:26:23 <dafis> ClaudiusMaximus: not that I expect a significant performance difference here
05:27:26 <ClaudiusMaximus> hpc: xml with 11 domain specific languages embedded as strings in attributes
05:27:26 <polanski> > let { phi=(sqrt 5 +1) /2; fib n = (phi^^n - (1-phi)^^n) / sqrt 5 } in fib 42
05:27:27 <lambdabot>   2.6791429599999994e8
05:27:43 <polanski> voila :P
05:27:48 <dafis> > let phi = (1 + sqrt5)/2; fib n = round (phi^n / sqrt 5) in map fib [0 .. 15]
05:27:48 <lambdabot>   Not in scope: `sqrt5'
05:27:56 <dafis> > let phi = (1 + sqrt 5)/2; fib n = round (phi^n / sqrt 5) in map fib [0 .. 15]
05:27:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
05:28:21 <polanski> > let { phi=(sqrt 5 +1) /2; fib n = round ((phi^^n - (1-phi)^^n) / sqrt 5) } in map fib [0 ..15]
05:28:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
05:28:50 <polanski> > let { phi=(sqrt 5 +1) /2; fib n = round ((phi^^n - (1-phi)^^n) / sqrt 5) } in fib 1000
05:28:51 <lambdabot>   434665576869373362581838031072093641655828166009266380758517484743763125194...
05:29:33 <ClaudiusMaximus> > round (1/0)
05:29:34 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
05:29:46 <polanski> let { fib7' t = fix (\rec n n1 n2 -> if (t==n) then n1 else rec (n+1) (n1+n2) n1) 2 1 1} in fib 1000
05:29:56 <polanski> let { fib7' t = fix (\rec n n1 n2 -> if (t==n) then n1 else rec (n+1) (n1+n2) n1) 2 1 1} in fib7' 1000
05:30:15 <polanski> bah :)
05:30:19 <polanski> > let { fib7' t = fix (\rec n n1 n2 -> if (t==n) then n1 else rec (n+1) (n1+n2) n1) 2 1 1} in fib7' 1000
05:30:19 <dafis> polanski: ">"
05:30:20 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
05:30:36 <dafis> > let { phi=(sqrt 5 +1) /2; fib n = round ((phi^^n - (1-phi)^^n) / sqrt 5) } in fib 10000
05:30:37 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
05:30:45 <dafis> oops
05:30:59 <polanski> that seems to = round (1/0)
05:31:04 <dafis> quite
05:31:21 <dafis> phi^10000 is too large
05:32:12 <dafis> > let phi=(sqrt 5 +1) /2 in phi^2000
05:32:13 <lambdabot>   Infinity
05:32:40 <ClaudiusMaximus> actually, XHTML with embedded SVG and CSS might be nice, if that works
05:32:58 <ClaudiusMaximus> because last time i tried doing text in SVG it made me cry
05:33:29 <polanski> i thinl you'd be safe with the integer version.
05:34:37 <ClaudiusMaximus> mm, but i'd still need text in the graph to label the axes..
05:35:05 <Saizan> ClaudiusMaximus: mandulia segfaults here :\
05:35:16 <ClaudiusMaximus> Saizan: segfault or illegal instruction?
05:35:33 <Saizan> Segmentation fault
05:35:45 <ClaudiusMaximus> hm, that's not good
05:36:30 <Saizan> thought so :)
05:36:31 <ClaudiusMaximus> works fine for me on Pentium-M with -f-SSE4, and Core2Duo with -fSSE4 (the default value of that flag)
05:36:46 <ClaudiusMaximus> which GHC version?
05:37:18 <ClaudiusMaximus> i had segfaults with 6.12.2 which were fixed by upgrading to 6.12.3
05:37:40 <Saizan> should be 6.12.3
05:38:07 <Saizan> i could retry with -f-SSE4, but i've a Core2Duo too
05:38:30 <ClaudiusMaximus> i'm using 6.10.4 on Debian Lenny, and 6.12.3 here on Ubuntu Lucid 64bit
05:39:02 <Saizan> 6.12.3 on archlinux
05:39:16 <Saizan> /home/saizan/.cabal/lib/hslua-0.2/ghc-6.12.3/libHShslua-0.2.a(loslib.o): In function `os_tmpname':
05:39:19 <Saizan> loslib.c:(.text+0x15): warning: the use of `tmpnam' is dangerous, better use `mkstemp'
05:39:22 <Saizan> i get that warning at link time
05:39:43 <Saizan> and still segfault..
05:39:59 <ClaudiusMaximus> Saizan: yes, that's because hslua-0.2 is old, i'm in discussion with the maintainer on the best way to upgrade it to current Lua
05:40:00 <Saizan> it might be a problem with my graphics 
05:40:13 <ClaudiusMaximus> does it segfault immediately?
05:40:45 <Saizan> after printing "mandulia (GPLv3+) 2010 Claude Heiland-Allen <claudiusmaximus@goto10.org>"
05:41:03 <ClaudiusMaximus> mm, no window opens?
05:41:09 <Saizan> no
05:41:53 <ClaudiusMaximus> any chance of getting a gdb backtrace?
05:43:03 <Saizan> a "cabal update && cabal install mandulia" later i get a more descriptive error
05:43:37 <Saizan> http://pastebin.com/xNHN7s3Q <-
05:43:49 <Saizan> i guess i lack some lua lib?
05:44:23 <ClaudiusMaximus> Saizan: no
05:44:30 <ClaudiusMaximus> Saizan: "There is one small bug in this release that I noticed too late (and isn't quite big enough to warrant an entirely new upload): the program help text states that configurations 'interactive' and 'random' are included, but they have been combined into one configuration called 'main'"
05:44:44 <simplechat> Hey guys, are there any good tutorials for multithreaded haskell?
05:44:54 <ClaudiusMaximus> Saizan: the README is up to date, i just forgot to update the --help text
05:45:18 <jkramer> Ahoy
05:45:28 <Saizan> ClaudiusMaximus: ah, good "mandulia main" gives me the segfault :)
05:45:36 <jkramer> What's the easiest way to replace an element at a given index in a list?
05:45:44 <Saizan> ClaudiusMaximus: how do i use gdb to get a trace?
05:46:00 <Saizan> jkramer: with splitAt
05:46:07 <polanski> does the pl and unpl still work with lambdabot ?
05:46:18 <Saizan> @pl \x -> x
05:46:18 <lambdabot> id
05:46:31 <Saizan> seems like they do
05:46:35 <ClaudiusMaximus> Saizan: gdb --args mandulia main    then type run at the prompt, then type bt when it crashes
05:47:37 <dafis> @pl \x -> x * x * x
05:47:37 <lambdabot> (*) =<< join (*)
05:47:43 <dafis> yay
05:48:05 <Saizan> ClaudiusMaximus: http://pastebin.com/kH9AHT2N <- 
05:48:42 <polanski> ah need the @. haskellwiki has no @ :) ta!
05:48:59 <ClaudiusMaximus> Saizan: ok, try "info locals", if nothing, then type "up" and repeat
05:50:34 <Saizan> ClaudiusMaximus: no info at any level
05:50:59 <Saizan> ClaudiusMaximus: i've got to go now, bbl :)
05:51:05 <ClaudiusMaximus> Saizan: ok, thanks for trying
05:51:55 <polanski> so my main question for turning up today is, how can i rewrite http://pastebin.com/LALBkqsf to pointfree (ie remove the v argument)
05:52:20 <polanski> before i added the (f +++ id) it was ok
05:52:21 <ClaudiusMaximus> Saizan: if/when you have more time - did you perhaps upgrade the GLUT C libs without reinstalling the GLUT Haskell libs?  i'm totally baffled by this one.  (or maybe it's my cranky optimization options vs more recent GHC/GCC ?)
05:53:24 <dafis> ((f +++ id) .) . fold . evalAlgebra6
05:53:29 <dafis> polanski: ^^
05:53:36 <dafis> should be correct
05:55:03 <dafis> @pl \x -> f . g (h x)
05:55:04 <lambdabot> (f .) . g . h
05:57:31 <polanski> ok indeed seems to work, but not sure what it means :) the @pl is helpful. thanks :)
06:01:08 <ClaudiusMaximus> anyone here used wumpus-core ? looks like it's the sanest option so far for svg/eps output
06:01:14 <dafis> polanski: f . g (h x) ~> f . (g (h x)) ~> (f .) (g (h x)) ~> ((f .) . g) (h x) ~> (((f .) . g) . h) x
06:01:24 <ClaudiusMaximus> i don't really want to depend on cairo/gtk
06:03:26 <proc> howdy guys
06:03:52 <proc> I've got to admit that I love haskell allthough it sometimes drives me crazy ;)
06:04:07 <polanski> @dafis: thanks !
06:04:07 <cozachk> it just gets crazier the deeper you go 
06:04:07 <lambdabot> Unknown command, try @list
06:04:20 <proc> cozachk, nice
06:05:58 <hpc> :t (~>)
06:05:58 <lambdabot> Not in scope: `~>'
06:06:04 <datwinkdaddy> Hrm, @pl is showing me some stuff I don't understand and that lambdabot can't find...
06:06:26 <datwinkdaddy> @pl \f -> let ix = (minBound, maxBound) in (!) (array ix [f i | i <- range ix])
06:06:27 <lambdabot> flip ((!) .) (minBound, maxBound) . ap array . flip flip [] . ((:) .) . (. range) . (<-) . (| i) . ($ i)
06:06:45 <datwinkdaddy> @src (<-)
06:06:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:06:51 <datwinkdaddy> @src (|)
06:06:51 <lambdabot> Source not found. Sorry.
06:06:51 <hpc> :t (<-)
06:06:52 <lambdabot> parse error on input `<-'
06:07:01 <hpc> (<-) isn't a valid token
06:07:04 <Twey> datwinkdaddy: [f i | i <- range ix] = map f (range ix)
06:07:22 <Twey>  @pl doesn't handle list comps
06:07:34 <hpc> @pl \f -> let ix = (minBound, maxBound) in (!) (array ix $ map f (range ix))
06:07:34 <lambdabot> flip ((!) .) (minBound, maxBound) . ap array . (. range) . map
06:07:35 <Twey> (because it's not always possible to make them point-free)
06:08:31 <datwinkdaddy> Twey: Ah, k.  I can write it w/o list comp
06:08:57 <datwinkdaddy> @pl \f -> let ix = (minBound, maxBound) in (!) (array ix $ map (\i -> (i, f i)) (range ix))
06:08:57 <lambdabot> flip ((!) .) (minBound, maxBound) . ap array . (. range) . map . ap (,)
06:10:55 <hpc> can you give an example of a comprehension that can't be made pointless?
06:14:10 <hpc> @hoogle (~>0
06:14:10 <lambdabot> Parse error:
06:14:11 <lambdabot>   --count=20 (~>0
06:14:11 <lambdabot>                 ^
06:14:14 <hpc> @hoogle (~>)
06:14:14 <lambdabot> No results found
06:14:59 <dafis> hpc: what's with ~> ?
06:15:23 <hpc> [09:00:38]	<dafis>	polanski: f . g (h x) ~> f...
06:15:27 <Philonous> Twey: Really? I thought list comps desugar to normal function applications and those can always be made points free
06:15:41 <dafis> hpc: short for "is transformed to"
06:15:42 <hpc> wondering what it is
06:15:46 <hpc> ah
06:17:50 <cuba> to (2*) in an fold do i have to define a function for it? 
06:18:02 <mauke> (2*) is a function
06:18:06 <datwinkdaddy> :t (2*)
06:18:07 <lambdabot> forall t. (Num t) => t -> t
06:18:10 <Zao> @type (2*)
06:18:10 <datwinkdaddy> :t foldl
06:18:11 <lambdabot> forall t. (Num t) => t -> t
06:18:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:18:22 <dafis> @type join (+)
06:18:23 <lambdabot> forall a. (Num a) => a -> a
06:18:35 <dafis> > join (+) 4
06:18:36 <lambdabot>   8
06:18:46 <hpc> (2*) can be mapped
06:19:00 <hpc> (*) can be folded
06:19:02 <datwinkdaddy> > map (2*) [1..4]
06:19:03 <lambdabot>   [2,4,6,8]
06:19:21 <cuba> ive to solve it with fold* :/
06:19:36 <dafis> cuba: what are you trying to do?
06:19:39 <hpc> > foldl (*) [x,y] z
06:19:40 <lambdabot>   Couldn't match expected type `[[SimpleReflect.Expr]]'
06:19:40 <lambdabot>         against infer...
06:19:55 <hpc> > (foldl (*) [x,y] z) :: Expr
06:19:56 <lambdabot>   Couldn't match expected type `[[SimpleReflect.Expr]]'
06:19:56 <lambdabot>         against infer...
06:20:03 <hpc> > (foldl (f) [x,y] z) :: Expr
06:20:04 <lambdabot>   Couldn't match expected type `[b]'
06:20:04 <lambdabot>         against inferred type `SimpleRef...
06:20:07 <dafis> > foldl (*) z [x, y]
06:20:07 <lambdabot>   z * x * y
06:20:10 <hpc> oh dur
06:21:06 <dafis> > foldl ((+) . (*10)) z [x, y]
06:21:08 <lambdabot>   (z * 10 + x) * 10 + y
06:21:43 <cuba> neat
06:22:53 <cuba> i needed to write bin2dec with fold functions
06:22:57 <cuba> foldl ((+) . (*2)) 0 [1,1,0,1]
06:22:59 <cuba> this like
06:23:14 <mauke> > foldl ((+) . (*2)) 0 [1,1,0,1]
06:23:15 <lambdabot>   13
06:23:16 <dafis> Oops
06:23:29 <mauke> yay
06:24:01 * dafis thinks he just violated homework help policy
06:24:15 <dafis> unintentionally
06:25:14 * hpc still can't get used to the idea of haskell being used in a classroom, after many horrible years of CS being all-java
06:25:36 <cuba> its a special class for functional programming
06:25:51 <hpc> nice
06:26:02 <hpc> > foldl f z [x, y]
06:26:03 <lambdabot>   f (f z x) y
06:26:11 <cuba> crazy shit after writing imperative most of the time
06:26:22 <hpc> that's the general shape of foldl
06:26:40 <Zeiris> What's the 'fixity' or whatever it's called, of `func` functions? Where does it fit in the (.) ($) order of things?
06:26:56 <dafis> Zeiris: defaults to infixl 9
06:27:01 <hpc> fixity is order of operations
06:27:13 <hpc> > 5 + 5 * 2
06:27:14 <lambdabot>   15
06:27:28 <dafis> Zeiris: you can have infixl 7 `mod` e.g.
06:27:46 <hpc> the left and right thing is which side gets evaluated first, iirc
06:27:58 <hpc> and you can't mix left and right fixity
06:28:22 <dafis> hpc: left and right is associativity
06:28:29 <hpc> er, right
06:28:54 <dafis> infixl 5 & : a & b & c = (a & b) & c
06:28:55 <hpc> yeah, it definitely isn't evaluation order >.>
06:28:55 <ManateeLazyCat> @src reverse
06:28:56 <lambdabot> reverse = foldl (flip (:)) []
06:29:08 <ManateeLazyCat> @hoogle reverse
06:29:08 <lambdabot> Prelude reverse :: [a] -> [a]
06:29:08 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
06:29:08 <lambdabot> Data.List reverse :: [a] -> [a]
06:30:38 <argonlde> hpc haskell has always been an academic language
06:30:39 <hpc> then there's operations with no associativity, which you can't mix at all
06:31:53 <datwinkdaddy> How can I figure out where @pl is finding instance Monad ((->) a)?
06:32:18 <dafis> datwinkdaddy: it's in Control.Monad.Instances
06:39:37 <ManateeLazyCat> @hoogle reverse
06:39:37 <lambdabot> Prelude reverse :: [a] -> [a]
06:39:37 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
06:39:37 <lambdabot> Data.List reverse :: [a] -> [a]
06:39:49 <ManateeLazyCat> reverse isn't define in Data.List?
06:40:09 <dafis> ManateeLazyCat: last of the three
06:40:23 <dafis> re-exported from Prelude
06:41:10 <ManateeLazyCat> dafis: Why GHC-API (Packages.lookupModuleInAllPackages) return package "base" for module "Data.List"?
06:41:33 <Saizan> because Data.List is in the base package
06:41:56 <ManateeLazyCat> Saizan: Where the reverse ? 
06:42:19 <ManateeLazyCat> Saizan: reverse in Prelude, and Data.List re-exported reverse from Prelude?
06:42:19 <dafis> ManateeLazyCat: GHC.List, then Data.List and Prelude
06:44:14 <ManateeLazyCat> dafis: Ah, GHC.List can work.
06:45:29 <ManateeLazyCat> dafis: Looks GHC.List, Data.List and Prelude all in "base" package....
06:45:35 <datwinkdaddy> > let { arrayMemoize :: (Bounded a, Ix a) => (a -> b) -> (a -> b); arrayMemoize = (!) . ($ range (minBound, maxBound)) . (array (minBound, maxBound) .) . map . ap (,); fib = arrayMemoize (\n -> if n < 0 then fib (n + 2) - fib (n + 1) else if n > 1 then fib (n - 2) + fib (n - 1) else fromIntegral (n :: Int)); } in fib 6
06:45:36 <lambdabot>   *Exception: Error in array index
06:45:37 <dafis> ManateeLazyCat: yes
06:45:48 <ManateeLazyCat> dafis: I need write some function to looking where the symbol define.
06:45:49 <dafis> ManateeLazyCat: is that a problem?
06:46:03 <datwinkdaddy> > let { arrayMemoize :: (Bounded a, Ix a) => (a -> b) -> (a -> b); arrayMemoize = (!) . ($ range (minBound, maxBound)) . (array (minBound, maxBound) .) . map . ap (,); fib = arrayMemoize (\n -> if n < 0 then fib (n + 2) - fib (n + 1) else if n > 1 then fib (n - 2) + fib (n - 1) else fromIntegral (n :: Data.Int.Int16)); } in fib 6
06:46:03 <ManateeLazyCat> dafis: I'm use GHC-API write a dynamic-linking library.
06:46:04 <lambdabot>   8
06:47:04 <ManateeLazyCat> dafis: When i pass "Data.List" let Packages.lookupModuleInAllPackages search package, it return "base", but "Data.List" is re-export "reverse" from "GHC.List", so dynamic-linking can't work.
06:47:12 <dafis> ManateeLazyCat: can you just always link in base?
06:47:13 <datwinkdaddy> Wierd.  My array range goes all crazy when I use Int.
06:47:33 <dafis> datwinkdaddy: overflow?
06:47:36 <ManateeLazyCat> dafis: I need linking special symbol.
06:47:51 <datwinkdaddy> maybe, but other things with that range work.
06:48:06 <datwinkdaddy> > inRange (minBound, maxBound) (0 :: Int)
06:48:06 <lambdabot>   True
06:48:16 <datwinkdaddy> > inRange (minBound, maxBound) (6 :: Int)
06:48:17 <lambdabot>   True
06:48:30 <datwinkdaddy> @src Array
06:48:30 <lambdabot> Source not found. Wrong!  You cheating scum!
06:48:35 <dafis> > rangeSize (minBound :: Int, maxBound)
06:48:36 <lambdabot>   0
06:48:42 <dafis> datwinkdaddy: ^^
06:48:56 <ivanm> ooohhh, a new error message from lambdabot 
06:49:00 <dafis> datwinkdaddy: because maxBound - minBound + 1 == 0
06:49:01 <ivanm> I like it! :D
06:49:31 <datwinkdaddy> dafis: Makes sense.
06:50:00 <dafis> datwinkdaddy: you can only have arrays of size <= maxBound :: Int
06:52:34 <datwinkdaddy> > let { arrayMemoize :: (Bounded a, Ix a) => (a -> b) -> (a -> b); arrayMemoize = let in = (minBound, maxBound) in if rangeSize ix <= 0 then error "Memoization table is too large." else (!) . ($ range (minBound, maxBound)) . (array (minBound, maxBound) .) . map . ap (,); fib = arrayMemoize (\n -> if n < 0 then fib (n + 2) - fib (n + 1) else if n > 1 then fib (n - 2) + fib (n - 1) else fromIntegral (n :: Int)); } in fib 6
06:52:35 <dafis> > maxBound :: Int
06:52:35 <lambdabot>   <no location info>: parse error on input `='
06:52:36 <lambdabot>   9223372036854775807
06:56:45 <hpc> :t log
06:56:46 <lambdabot> forall a. (Floating a) => a -> a
06:57:28 <hpc> > log (fromIntegral $ maxBound :: Int) / log 10
06:57:29 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
06:57:29 <lambdabot>    arising from a use of...
06:57:37 <hpc> > log (fromIntegral $ (maxBound :: Int)) / log 10
06:57:38 <lambdabot>   18.964889726830812
06:57:49 <hpc> > log (fromIntegral $ (maxBound :: Int)) / log 2
06:57:50 <lambdabot>   63.0
06:58:10 <hpc> :D
06:59:29 <dafis> > logBase 2 (fromIntegral (maxBound :: Word))
06:59:30 <lambdabot>   64.0
07:02:05 <hpc> @src logBase
07:02:05 <lambdabot> Source not found. Do you think like you type?
07:02:11 <hpc> @src log
07:02:11 <lambdabot> Source not found. That's something I cannot allow to happen.
07:02:19 <hpc> :(
07:02:42 <dafis> @src Floating
07:02:42 <lambdabot> class  (Fractional a) => Floating a  where
07:02:42 <lambdabot>     pi                                                      :: a
07:02:42 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
07:02:42 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
07:02:42 <lambdabot>     (**), logBase                                           :: a -> a -> a
07:03:27 <hpc> no wonder...
07:04:48 <hpc> i like their logarithmic definition of (**)
07:05:35 <Twey> What logarithmic definition?
07:05:51 <dafis> a ** b = exp (b * log a)
07:05:57 <Twey> Oh, okay
07:07:24 <Twey> hpc: logBase b n = log n / log b
07:07:36 <hpc> yeah, i know ;)
07:07:39 <Twey> Oh, okay
07:08:06 <Twey> logBase = on (/) log
07:08:15 <Twey> I guess
07:08:24 <dafis> Twey: :D
07:08:52 <dafis> but flip
07:09:16 <dafis> > flip (on (/) log) 2 8
07:09:16 <lambdabot>   3.0
07:10:14 <Twey> Ah, right
07:10:17 <Twey> Yes
07:10:26 <Twey> logBase = flip $ on (/) log
07:10:35 <Twey> Doesn't look as pretty ☹  Oh well
07:11:01 <dafis> Twey: recip . on (/) log ?
07:11:13 <adu> hi Twey
07:11:20 <Twey> Nah, when you add another symbol it loses that nice simplicity
07:11:22 <Twey> Hi, adu
07:11:26 <Botje> flip (/) `on` log
07:11:32 <adu> hpc: i like the hyperarithmetic definition of (**)
07:11:42 <Twey> Yeah, that's better, I guess
07:11:57 <dafis> adu: hyperarithmetic definition ?
07:11:58 <Botje> > (flip (/) `on` log) 2 8
07:11:59 <lambdabot>   3.0
07:12:02 <Botje> yay
07:12:54 <Botje> and in factor it'd be something like [ log ] bi2 /
07:13:09 <dafis> pity that \ is reserved, otherwise (\) = flip (/) would be cool
07:13:16 <adu> dafis: In hyperarithmetic, the hyperoperation sequence is defined by (a [n] b) = (a [n-1] (a [n] (b - 1))), defining a**b = a[3]b is sufficient for integer a,b
07:13:33 <dafis> adu: okay, hyper operators
07:13:56 <adu> no, hyperoperations
07:13:59 <adu> http://en.wikipedia.org/wiki/Hyperoperation
07:14:00 <hpc> adu: that looks kinda like up arrows
07:14:17 <adu> hpc: yes, Knuth-arrow notation is frequently used to represent hyperoperations
07:14:28 <dafis> adu: Knuth's arrows
07:14:42 <dafis> that's what I mean
07:15:42 <adu> the reason why I call it Knuth's arrow system is because there is another arrow system used by Bromer and Mueller, which is offset by one
07:16:11 <dafis> zero based vs. one-based array indexing
07:16:16 <adu> basically
07:16:19 <dafis> flamewar, anyone?
07:16:22 <adu> lol
07:16:42 <Ke> they are wrong and we are right, what's there to discuss?
07:16:48 <adu> lolol
07:17:16 <Twey> No point
07:17:24 <Twey> Dijkstra's covered it
07:17:35 <dafis> Twey: link?
07:18:05 <Twey> http://userweb.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
07:18:05 <adu> Bromer and Mueller's arrow system is a little more general, as it uses up/down arrows, and so it allows representing a while binary-tree of operators, not a sequence of operators like Knuth's system
07:18:57 <dafis> Twey: yeah just found it myself
07:19:04 <dafis> tanks anyway
07:19:08 <Twey> Welcome
07:19:09 <dafis> thanks
07:19:22 * dafis was a conscientious objector
07:19:33 * dafis doesn't like tanks
07:20:01 <Twey> Well, send them to me and I'll put them to good use ploughing a field somewhere.
07:21:00 <Twey> In addition to Dijkstra's arguments, of course, for us computer people it has the additional benefit that it matches how arrays are represented in memory
07:21:13 <dafis> Twey: or you could put goldfish in them
07:21:34 <Twey> You're a conscientious objector to aquaria?
07:21:45 <dafis> Twey: that, too
07:21:57 <dafis> free Nemo
07:22:15 <Twey> Well, I think we should free *some* people
07:22:47 <adu> Twey: was that a complete article or was it some kind of excerpt?
07:22:52 <mauke> how about a compromise
07:22:59 <mauke> array indices should start at 0.5
07:23:02 <Twey> It's complete
07:23:06 <adu> mauke: lol
07:23:11 <Twey> I don't know that I'd call it an article
07:23:21 <adu> Twey: it seems like its missing an argument
07:23:34 <Twey> Which one?
07:24:36 <adu> Twey: your recent link, the core argument seems to be "That is ugly"
07:27:05 <Twey> Mm
07:29:50 <dafis> adu: I think the argument is "it's more elegant and less error-prone"
07:30:25 <dafis> I don't know about the latter, but the former, I agree with
07:34:09 <Twey> The latter usually follows from the former
07:34:50 <dafis> usually, but not necessarily, so I'm cautious here
07:35:00 <ClaudiusMaximus> hm, i want a function:  ticks :: Int -> Double -> Double -> [Double]  where length (ticks n a b) is approximately n, let ts = ticks n a b in zipWith (-) ts (tail ts) == replicate (n-1) k, and k is a nice round number (1,2,5,10,20,50,100,200,500,etc)
07:35:10 <ClaudiusMaximus> any ideas?
07:36:48 <dafis> ClaudiusMaximus: let k = (high-low)/fromIntegral n in [low, low + k .. high]
07:37:13 <ClaudiusMaximus> dafis: does that satisfy the last condition?
07:37:23 <dafis> ClaudiusMaximus: forgot about that
07:37:31 <ClaudiusMaximus> that's where i'm stuck!
07:37:53 <dafis> ClaudiusMaximus: let k0 = (high-low)/fromIntegral n; k = nearest k0 in [low, low + k .. high]
07:38:11 <dafis> problem: implement nearest nicely
07:39:18 <ClaudiusMaximus> mm, i suppose if it's for a heap profile time stamps in seconds, 1e-6 <= k <= 1e6
07:39:42 <dafis> ClaudiusMaximus: 1e6?
07:39:45 <ClaudiusMaximus> > (logBase 10 1e6 - logBase 10 1e-6) * 3
07:39:46 <lambdabot>   35.99999999999999
07:39:56 <dafis> really, > 10 days
07:39:57 <ClaudiusMaximus> > 1e6 / 60 / 60
07:39:58 <lambdabot>   277.77777777777777
07:40:02 <ClaudiusMaximus> > 1e6 / 60 / 60 /24
07:40:03 <lambdabot>   11.574074074074074
07:41:04 <ClaudiusMaximus> anyway, i figure if someone wants to generate a graph of heap usage for a program that's been running with profiling for > 10 days, they can wait a little longer for the ticks on the heap graph to generate
07:41:19 <ClaudiusMaximus> and 1e-6 feels like a reasonable minimum
07:41:36 * hackagebot vect 0.4.5.2 - A low-dimensional linear algebra library, tailored to computer graphics.  http://hackage.haskell.org/package/vect-0.4.5.2 (BalazsKomuves)
07:41:37 <dafis> ClaudiusMaximus: I would think so, perhaps even 1e-5
07:42:09 <gwern> anime can be so silly about software names. in _Durarara!_, why does the protagonist boot up 'wbunte' rather than 'ubuntu'? it's not like Canonical is going to sue them
07:43:59 <ClaudiusMaximus> > let { nearest k0 = head . dropWhile (< k0) $ ks ; ks = [ f * k | f <- map (10**) [-6 ..], k <- [1,2,5] ] } in map nearest [42, 180, 666, 9000]
07:44:00 <lambdabot>   [50.0,200.0,1000.0,10000.0]
07:44:12 <ClaudiusMaximus> :)
07:45:23 <gwern> and let's not talk about the anime characters who use wikipedia
07:45:24 <gwern> oy
07:47:09 <dafis> ClaudiusMaximus: nearest x = let { e = floor (logBase 10 x); m = 10^^e } in case round (x/m) of { r | r < 2 ->m; | r < 4 -> 2*m; | r < 8 -> 5*m; | otherwise -> 10*m }
07:48:02 <Philonous> gwern: Could it be a general reluctance to use real-life names and brands? 
07:48:10 <dafis> >let nearest x = let { e = floor (logBase 10 x); m = 10^^e } in case round (x/m) of { r | r < 2 ->m; | r < 4 -> 2*m; | r < 8 -> 5*m; | otherwise -> 10*m } in map nearest [42,180,666,9000]
07:48:32 <gwern> Philonous: there doesn't seem to be similar relutance for regular consumer goods or physical electronics
07:48:37 <gwern> no shortages of sonys or whatever
07:48:41 <ClaudiusMaximus> dafis: maybe needs a space?
07:48:49 <dafis> > let nearest x = let { e = floor (logBase 10 x); m = 10^^e } in case round (x/m) of { r | r < 2 ->m | r < 4 -> 2*m | r < 8 -> 5*m | otherwise -> 10*m } in map nearest [42,180,666,9000]
07:48:50 <lambdabot>   [50.0,200.0,500.0,10000.0]
07:48:59 <dafis> yup
07:49:08 <ClaudiusMaximus> interesting, slightly different
07:49:28 <virtus> how to strlen a string ?
07:49:35 <ClaudiusMaximus> :t length
07:49:36 <lambdabot> forall a. [a] -> Int
07:49:37 <dafis> virtus: length
07:49:44 <ClaudiusMaximus> @src String
07:49:45 <lambdabot> type String = [Char]
07:49:53 <ozamosi|netbook> gwern: japanese are funny about rewriting names to be pronounceable. They can obviously say sony, cause that's japanese, but they can't necessarily pronounce african words.
07:50:09 <gwern> what
07:50:17 <gwern> is more prunicable about wbunte?
07:50:37 <dafis> gwern: perhaps just strange transcription rules
07:50:58 <Philonous> gwern: Sony is japanese. Maybe that has something to do with it :>
07:51:35 <ozamosi|netbook> gwern: I can't tell you, because I'm not Japanese.
07:51:56 <gwern> well, there are so many people learning japanese here that I'm sure one of them can tell us :)
07:52:47 * gwern wonders sometimes why so many haskellers are interested in japanese. and unicycling
07:53:13 <Botje> you have it upside down
07:53:21 <Botje> why are so many unicyclists interested in haskell?
07:53:40 <wli> Japanese Fifth Generation project hangovers?
07:53:52 <gwern> Botje: in what sense is there a rightside up or upside down?
07:54:11 <gwern> wli: but the fifth generation had a hard on for prolog and other logic langs, iirc...
07:54:25 <Botje> gwern: good question
07:54:31 <wli> gwern: Well, I like Mercury. ;)
07:56:59 <virtus> why is this statement returning an error >>   ppTitle = (\x -> "" ++ wrapFg myTitleFgColor x; len <- length x) . wrap "^p(_CENTER)^p(-" ++ (div len 2) ++ ")" "^p()",
07:58:38 <ClaudiusMaximus> because it's wrong, you can't use <- there
07:59:35 <virtus> ClaudiusMaximus: it still returns an error, when i use "="
08:00:20 <Botje> virtus: why not just "wrapFg myTitleFgColor x (length x)" ?
08:00:29 <Botje> length is a pure function, so ..
08:01:16 <ClaudiusMaximus> but len is used later outside the scope, all those brackets are a confusement
08:01:21 <virtus> Botje: i want the half of the title's length to be inserted inside "^p(" and ")"
08:01:37 <ClaudiusMaximus> let ppTitle x = let len = length x in ...  -- might be more sane, if that's what you mean
08:05:41 <Twey> @src (->) ap
08:05:41 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:05:50 <Twey> @src ap
08:05:50 <lambdabot> ap = liftM2 id
08:10:53 <cached> is there a good reason cabal doesn't install dependencies of what you try to install by default?
08:11:25 <mauke> it does
08:11:45 <cached> mauke: doesn't seem to do so for me ...
08:11:54 <dcoutts> cached: if you're talking about build tools like alex, happy etc, then that's just a limitation at the moment, it only considers library dependencies
08:12:12 <cached> dcoutts: ah. okay
08:12:34 <dcoutts> cached: does that explain the behaviour you're seeing?
08:12:42 <mornfall> Anyone can think of a way to write, combine :: a -> a -> a, which acts as ++ for lists and as const for non-lists?
08:12:43 <cached> dcoutts: exactly
08:12:56 <dcoutts> cached: ok, one day it'll do those too :-)
08:13:33 <mauke> mornfall: yeah, with overlapping instances
08:13:52 * mornfall tries
08:14:58 <mornfall> mauke: Well, they seem to be also incoherent, apart from being overlapping. :|
08:15:38 <mornfall> mauke: At least in the a -> a -> a context.
08:16:20 <monoidal> you don't need InherentInstances to compile though
08:16:46 <mornfall> You do, but it's useless.
08:17:02 <mornfall> Once they are incoherent, you can't use them to pick the right behaviour.
08:17:31 <ClaudiusMaximus> @hoogle showHex
08:17:31 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
08:17:44 <ClaudiusMaximus> > showHex 15 ""
08:17:44 <lambdabot>   "f"
08:18:57 <Philonous> mornfall: ghc will pick the most specific one. And a->a->a is considered more general than [a]->[a]->[a] if memory serves me right
08:19:14 <mornfall> Philonous: Right, which doesn't help with the above specification.
08:19:32 <Twey> Of course it is, because a can be [a] (for different a's)
08:20:25 <mornfall> The problem is that GHC will always choose "const" *even* if the actual runtime type happens to be [a].
08:20:48 <fxr> oh, my dreams come true, iteratee is using CPS :)
08:21:08 <mornfall> When I tried to do this with SYB, I always ran into the problem that the list element type is ambiguous.
08:21:16 <Philonous> mornfall: Actually no, beacuse the list case is _more_ specific than the general case, so it will be used when it applies
08:21:19 <mornfall> (When a is [b], the b is ambiguous...)
08:21:35 <mornfall> Philonous: Once the instances are incoherent, that is not true.
08:21:48 <mauke> :t let combine x y = case (cast x, cast y) of (Just xs, Just ys) -> xs ++ ys; _ -> x in combine
08:21:49 <lambdabot> forall a a1. (Monoid a, Typeable a1, Typeable a) => a -> a1 -> a
08:22:00 <cached> i don't want to turn this into a cabal support channel if people wouldn't want it to be, but can anyone give me some insight as to what to do from "setup: The pkg-config package cairo-pdf is required but it could not be found." when trying to install cairo (to install gtk2hs-buildtools (to install leksah))
08:22:18 <mauke> :t let combine x y = case (cast x, cast y) of (Just xs, Just ys) -> xs List.++ ys; _ -> x in combine
08:22:19 <lambdabot> forall a a1. (Typeable a1, Typeable a) => [a] -> a1 -> [a]
08:22:22 <mornfall> mauke: That'll fail due to ambiguity, I think.
08:23:12 <mornfall> Although. Hmm.
08:23:40 <mauke> :t let combine x y = case (cast x, cast y) of (Just xs, Just ys) -> fromJust (cast (xs List.++ ys)); _ -> x in combine
08:23:41 <lambdabot>     Ambiguous type variable `a' in the constraint:
08:23:41 <lambdabot>       `Typeable a' arising from a use of `cast' at <interactive>:1:24-29
08:23:41 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
08:23:43 <Philonous> mornfall: I just tried it, it works
08:23:52 <mornfall> Philonous: You tried what? Implementing combine?
08:24:13 <mornfall> Philonous: Try combine' :: a -> a -> a; combine' = combine then and see how it fails.
08:24:25 <hamishmack> cached: What platform are you on?
08:24:51 <hamishmack> cached: You may be missing a cairo -dev package
08:25:07 <dafis> :t let combine x y = case [cast x, cast y] of (Just xs, Just ys) -> xs List.++ ys; _ -> x in combine
08:25:08 <lambdabot>     Couldn't match expected type `[Maybe b]'
08:25:08 <lambdabot>            against inferred type `(a, b1)'
08:25:08 <lambdabot>     In the pattern: (Just xs, Just ys)
08:25:24 <dafis> :t let combine x y = case [cast x, cast y] of [Just xs, Just ys] -> xs List.++ ys; _ -> x in combine
08:25:25 <lambdabot> forall a a1. (Typeable a1, Typeable a) => [a] -> a1 -> [a]
08:25:37 <cached> hamishmack: ubuntu 64bit
08:26:33 <aavogt> mornfall: like this? http://npaste.de/e1/
08:26:42 <dafis> :t let combine :: Typeable a => a -> a -> a; combine x y = case [cast x, cast y] of [Just xs, Just ys] -> xs List.++ ys; _ -> x in combine
08:26:43 <lambdabot>     Couldn't match expected type `a1' against inferred type `[a]'
08:26:43 <lambdabot>       `a1' is a rigid type variable bound by
08:26:43 <lambdabot>            the type signature for `combine' at <interactive>:1:24
08:26:48 <mornfall> aavogt: It doesn't work.
08:27:07 <cached> hamishmack: install libcairo2-dev. will report back soon =)
08:27:25 <aavogt> mornfall: the output doesn't follow the specification?
08:27:29 <mornfall> aavogt: I don't have a static monotype.
08:27:30 <dafis> :t let combine :: Typeable a => a -> a -> a; combine x y = case cast x of Just xs -> x List.++ y; _ -> x in combine
08:27:31 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a1'
08:27:31 <lambdabot>       `a1' is a rigid type variable bound by
08:27:31 <lambdabot>            the type signature for `combine' at <interactive>:1:24
08:27:38 <hamishmack> cached: There are more tips here... http://rizwanbulbul.blogspot.com/2010/06/installing-leksah-gtk-gtk2hs-and-glade.html
08:27:49 <mornfall> aavogt: It works only if you provide it with concrete types.
08:27:52 <mornfall> aavogt: Statically.
08:27:56 <monoidal> in a compiled haskell program, is there any mention of types, or are they all erased?
08:28:16 <monochrom> erased
08:29:10 <mornfall> aavogt: Try what I said above, with combine' :: a -> a -> a; combine' = combine and then use combine' in ghci
08:29:17 <stulli> On SO i read it is good practice to "enforce key invariants via types". Where can i learn about that?
08:29:54 <aavogt> why is the class context unacceptable?
08:30:11 <mornfall> *Main> combine' "a" "b"
08:30:11 <mornfall> "a"
08:30:23 <mornfall> aavogt: It's not unacceptable. It doesn't matter.
08:30:44 <mornfall> Hm.
08:30:45 <aavogt> you're forcing the instance resolution too early that way
08:30:59 <mornfall> Maybe I could sneak it in somewhere.
08:31:13 <mauke> I'm not sure combine should be able to exist
08:32:11 <monoidal> is there a free theorem that, forgetting about bottom, every a -> a -> a function is either const or const id?
08:32:15 <mornfall> aavogt: The problem is that I can't tell anything about the type.
08:32:20 <Philonous> mornfall: You are right, seems like instance selection isn't delayed long enough
08:32:25 <mauke> @free combine :: a -> a -> a
08:32:25 <lambdabot> f . combine x = combine (f x) . f
08:32:34 <ManateeLazyCat> hamishmack: Do you have Windows?
08:32:50 <hamishmack> ManateeLazyCat: yes
08:33:14 <mauke> f (combine x y) = combine (f x) (f y)
08:33:15 <mornfall> aavogt: It comes from a constructor parameter of a free type...
08:33:24 <ManateeLazyCat> hamishmack: Can you help me test gtk2hs-darcs ? It's a bug that can't compile gtk2hs-darcs on Windows, and Axel on holiday, can't test.
08:33:36 <ManateeLazyCat> hamishmack: We plan to release gtk2hs-0.11.1 next week.
08:34:00 <monoidal> so if f x = [x], say Int -> [Int]  then the free theorem is violated
08:34:26 <hamishmack> I'll give it a quick go now.
08:34:38 <monochrom> no, restrict f to a->a
08:34:50 <monoidal> ah
08:34:55 <ManateeLazyCat> hamishmack: I add new function drawableGetID in Graphics.UI.Gtk.General.Structs, looks something wrong with WIN32 flags that cna't compile.
08:35:01 <ManateeLazyCat> hamishmack: Thanks. :)
08:35:29 <mornfall> mauke: Well, you can almost write it using SYB. It's just the element type ambiguity that breaks it.
08:35:33 <mauke> monochrom: can I restrict it to [a] -> [a]?
08:35:40 <mornfall> mauke: Which shouldn't be fundamental, since nothing ever looks at the elements.
08:35:41 <monochrom> yes too
08:35:56 <ManateeLazyCat> hamishmack: You just need check 'WIN32' flags with gdk_x11_drawable_get_xid, gdk_win32_drawable_get_handle and drawableGetID, other code is same as gtk2hs-0.11.0.
08:35:59 <mauke> f = take 1
08:36:59 <Philonous> mornfall: Actually, it works. You don't need IncoherentInstances
08:37:06 <ManateeLazyCat> hamishmack: I think gdk_win32_drawable_get_handle should " :: (Ptr Drawable) -> IO (Ptr ())" and not ":: (Ptr Drawable) -> IO (Ptr a)"
08:37:09 <mornfall> Philonous: Hmm?
08:37:13 <ManateeLazyCat> hamishmack: But i haven't Windows for test.
08:37:15 <hpc> is there a way to get backspace to behave normally in getLine?
08:37:19 <Philonous> @paste
08:37:19 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:37:31 <mauke> hpc: it already does
08:37:37 <aavogt> mornfall: perhaps syb-with-class is more appropriate?
08:37:42 <monochrom> backspace already behaves normally in getLine
08:37:52 <hpc> i mean, so it actually deletes characters
08:38:01 <mauke> yes
08:38:01 <monochrom> it does. works for me.
08:38:03 <mornfall> aavogt: Is it strictly more powerful?
08:38:15 <mornfall> But you just gave me an idea...
08:38:31 <aavogt> :)
08:38:38 <hpc> *Main> getLine
08:38:39 <hpc> blahblah^?^?^?^?
08:38:57 <mauke> hpc: that's ghci
08:39:04 <monochrom> I see.
08:39:04 <hpc> ah
08:39:08 <cozachk1> man hpaste is down again :( 
08:39:12 <Philonous> mornfall:  http://pastebin.com/spj2y2Kd
08:40:49 <monochrom> ghci always behaves differently from even runghc
08:40:56 <mornfall> Philonous: You lost the type signature on combine', that's why it works.
08:41:08 <hpc> i see, it works now
08:41:35 <monoidal> alternatively, a newtype wrapper: class Semigroup a where combine :: a -> a -> a; newtype First a = First a; instance Semigroup (First a); instance Semigroup [].
08:41:52 <Taejo> :t replicateM
08:41:53 <lambdabot>     Ambiguous occurrence `replicateM'
08:41:53 <lambdabot>     It could refer to either `L.replicateM', defined at <local>:2:0
08:41:53 <lambdabot>                           or `Control.Monad.Logic.replicateM', imported from Control.Monad.Logic
08:41:58 <mauke> @undefine
08:42:01 <aavogt> mornfall: are you able to pass the type variable that needs the Combine context to your arguments or results?
08:42:35 <aavogt> or was your plan something else?
08:43:09 <mauke> :t replicateM
08:43:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:44:43 <mornfall> aavogt: I need to apply combine on the result of:
08:44:44 <mornfall>   readFlag :: Data b => a -> String -> b
08:44:50 <mornfall>   flag_value :: (Typeable a) => flag -> Folded flag -> a
08:44:59 <Taejo> @src replicateM
08:44:59 <lambdabot> replicateM n x = sequence (replicate n x)
08:47:11 <mornfall> aavogt: readFlag is a SYB-based generic read, flag_value extracts a named field from a record using SYB as well (i.e. it calls cast).
08:48:48 <aavogt> somebody had a similar issue: they wanted to do something for all items that belonged to one class in their collection 
08:49:22 <aavogt> I suggested trying a list (about 5) of possible monotypes with syb
08:49:57 <aavogt> maybe dafis suggested syb-with-class which directly lets you do that
08:50:03 <mornfall> aavogt: Well, I *could* write ++ with SYB. It feels dirty though.
08:50:43 <mornfall> Or at least I could try.
08:50:45 <mornfall> :)
08:51:31 <proc> func :: String -> [Int] -> [String], func str (x:xs) = map(\n -> if n == 'n' then x else n) str : (func str xs) - I want to make the function work like: func "foon" [0..2] -> ["foo0", "foo1", "foo2"], should work that way but I've got problems with the types, because I don't know how to convert an Int to a Char
08:51:41 <dafis> aavogt: no, wasn't me
08:53:04 <ManateeLazyCat> proc: Data.Char.chr ?
08:53:14 <ManateeLazyCat> @hoogle Data.Char chr
08:53:14 <lambdabot> No results found
08:53:18 <ManateeLazyCat> @hoogle Data.Char.chr
08:53:19 <lambdabot> Data.Char chr :: Int -> Char
08:53:35 <hpc> > chr 12345
08:53:36 <lambdabot>   '\12345'
08:53:43 <hpc> >chr 152
08:53:47 <proc> ah
08:53:48 <proc> nice
08:53:49 <hpc> > chr 152
08:53:49 <lambdabot>   '\152'
08:53:50 <aavogt> supposedly it's this paste http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27271
08:54:11 <hpc> 500 on that link
08:54:33 <monoidal> proc: do you want "0" as a string?
08:54:34 <dafis> hpaste down
08:54:48 <monoidal> proc: think about func "foon" [0..100]
08:55:04 <monoidal> single chars won't be enough
08:55:09 <ManateeLazyCat> dafis: Use paste2.org
08:55:10 <proc> true
08:55:18 <proc> so I rather need Int to String
08:55:25 <monoidal> > show 45
08:55:26 <lambdabot>   "45"
08:55:31 <dafis> ManateeLazyCat: just explaining hpc's 500
08:55:43 <ManateeLazyCat> dafis: Oh. :)
08:56:08 <ManateeLazyCat> dafis: Do you know any GHC-API can parse re-export problem?
08:56:20 <ManateeLazyCat> s/re-export problem/re-export information
08:56:23 <aavogt> hpc: the paste shows up in a search, but it's not in any cache I can find
08:56:27 <monoidal> proc: you might use concatMap function
08:56:32 <dafis> ManateeLazyCat: sorry, no
08:56:35 * ClaudiusMaximus <3 haskell - as soon as i fixed the compilation errors, my code (work in progress replacement for hp2ps) worked first time (well, still a few glitches, but..) - output: http://claudiusmaximus.goto10.org/g/hp2pretty/hp2pretty_test_001.png
08:56:40 <ManateeLazyCat> dafis: Nevermind, :)
08:56:52 <dafis> ManateeLazyCat: I don't
08:57:37 <proc> monoidal, what's the difference between map and concatMap?
08:57:41 <ManateeLazyCat> dafis: I hope build some function can change to ("GHC.List", "reverse") when i pass ("Data.List", "reverse")
08:57:42 <dafis> ClaudiusMaximus: jagged, but cool
08:58:17 <monoidal> proc: map transforms each element according to a given function. concatMap transforms each element to a list of elements, and flattens the result
08:58:27 <monoidal> > map (\x -> [x+1,x+2]) [0,10,20]
08:58:28 <lambdabot>   [[1,2],[11,12],[21,22]]
08:58:31 <monoidal> > concatMap (\x -> [x+1,x+2]) [0,10,20]
08:58:32 <lambdabot>   [1,2,11,12,21,22]
08:59:46 <burp> hm, has anyone used http://hackage.haskell.org/package/persistent-0.1.0? I'd like to see a small example for using it
08:59:50 <monoidal> proc: in map, you can give any function a -> b. In concatMap, you need a -> [b].
09:00:00 <randomwords> ClaudiusMaximus: I'm trying to compile mandulia (which I believe is yours). But I get the following error (which someone else seemed to get earlier) http://pastebin.com/xNHN7s3Q. Any idea on a fix?
09:00:09 <proc> hmm
09:00:53 <monoidal> concatMap (\x -> if x == 'a' then "100" else x) "bac"
09:00:55 <monoidal> > concatMap (\x -> if x == 'a' then "100" else x) "bac"
09:00:56 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:00:56 <lambdabot>         against inferred ty...
09:01:06 <monoidal> > concatMap (\x -> if x == 'a' then "100" else [x]) "bac"
09:01:07 <lambdabot>   "b100c"
09:01:50 <proc> but I need the "100" be part of a [Int]
09:02:12 <ClaudiusMaximus> dafis: http://claudiusmaximus.goto10.org/g/hp2pretty/hp2pretty_test_002.png another one, still jaggy..
09:02:24 <ClaudiusMaximus> randomwords: yes, it's mine - i'll take a look
09:02:38 <monoidal> proc: first, try to write fun so that it will take only one number
09:02:48 <proc> k
09:02:48 <randomwords> ClaudiusMaximus: I assume I'm missing an ovbvious library, but I'm not familiar with lua
09:03:04 <ClaudiusMaximus> randomwords: that's the classic bug where i didn't update the program help text before making a release *blush*
09:03:20 <ClaudiusMaximus> randomwords: 'mandulia main' is the new command to star
09:03:25 <ClaudiusMaximus> *t
09:03:43 <randomwords> ClaudiusMaximus: Works now
09:03:44 <randomwords> thanks
09:03:48 <ClaudiusMaximus> randomwords: then press 'a' for random attract mode
09:04:26 <ClaudiusMaximus> randomwords: i should probably make a new release to fix this, it's a bit confusing indeed
09:04:36 <randomwords> ClaudiusMaximus: Probably a good idea
09:07:47 <poincare101> Hello everyone. Suppose I have a number x, and I need to find out if any of the numbers in the list y are factors of x, how can I do this in haskell?
09:08:18 <mauke> :t any
09:08:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:08:39 <monoidal> :t mod
09:08:40 <lambdabot> forall a. (Integral a) => a -> a -> a
09:08:43 <randomwords> ClaudiusMaximus: You've inspired me to resume work on my fractal renderer
09:08:48 <mauke> :t any (\y -> ?x `mod` y == 0) ?ys
09:08:49 <lambdabot> forall a. (?x::a, Integral a, ?ys::[a]) => Bool
09:09:01 <ClaudiusMaximus> randomwords: :)
09:09:02 <poincare101> mauke: how can one do it without the function any?
09:09:08 <mauke> @src any
09:09:08 <lambdabot> any p =  or . map p
09:09:17 <mauke> :t or $ map (\y -> ?x `mod` y == 0) ?ys
09:09:18 <lambdabot> forall a. (?x::a, Integral a, ?ys::[a]) => Bool
09:09:19 <Philonous> @type foldr
09:09:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:10:06 <Philonous> @type foldr (&&) False
09:10:07 <lambdabot> [Bool] -> Bool
09:10:26 <Zao> poincare101: Try taking the remainder of each number, see if it's 0 (divides evenly).
09:10:34 <hpc> @src all
09:10:34 <lambdabot> all p =  and . map p
09:10:44 <poincare101> Zao: I understand the logic, I didn't understand how to implement it.
09:10:48 <Zao> And then of course, do all the cute tricks the slackers above are using :)
09:11:04 <poincare101> what does \y mean?
09:11:06 <Zao> poincare101: map lets you apply a function to each element in a list, giving you a list of results.
09:11:14 <mauke> poincare101: oh man
09:11:19 <Zao> \ signifies a lambda function, an anonymous function.
09:11:21 <mauke> poincare101: what source are you learning Haskell from?
09:11:25 <hpc> y is the parameter
09:11:40 <hpc> \y -> y is the same as f y = y
09:11:47 <mauke> hpc: no, it isn't
09:11:48 <Zao> hpc: Except without a name.
09:12:07 <Philonous> hpc: more like let f y = y in f
09:12:08 <hpc> just making an analog
09:12:34 <hpc> actually, the let would be better
09:12:37 <poincare101> mauke: lyah.
09:12:43 <mauke> ah
09:12:50 <monoidal> poincare101: you can use recursion and pattern matching, like f [] = ... and f (x:xs) = ...
09:12:56 <poincare101> ah.
09:12:57 <poincare101> I see.
09:13:04 <poincare101> map and that makes a lot of sense.
09:13:39 <hpc> :t map
09:13:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:14:00 <hpc> :t and
09:14:01 <lambdabot> [Bool] -> Bool
09:14:20 <hpc> that's a strange name for that type signature
09:14:31 <Philonous> @type (&&)
09:14:32 <lambdabot> Bool -> Bool -> Bool
09:16:26 <hpc> why does lambdabot not like :t in private messages?
09:16:34 <Zao> @type maybe
09:16:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:16:47 <Zao> I did not intend that to be correct :)
09:16:56 <poincare101> haskell is very cool!
09:18:41 <cached> So i'm just learning haskell and trying to get a feel for the intuition behind it. Why don't functions memoize by default?
09:19:12 <arw> because that would immediately lead to very serious memory leaks.
09:19:20 <Gracenotes> well, an implementation could memoize by default and still be called 'haskell'.
09:19:24 <Gracenotes> I think.
09:19:37 <cached> ah okay
09:19:41 <Gracenotes> but memory is not something to be wasted
09:19:51 <hpc> memoizing doesn't change semantics
09:20:03 <Gracenotes> most of the time, better time than space...
09:20:03 <hpc> and unused memory is wasted memory
09:20:05 <proc> monoidal, I've still got the problem with the types
09:20:11 <arw> cached: for memoization to be beneficial you need a compiler which is able to discern what should be memoized and what shouldn't. thats not an easy problem.
09:20:43 <monoidal> proc: you can paste the code here, or use http://paste2.org/new-paste if it's longer
09:21:00 <proc> ah
09:21:01 <proc> got it
09:21:03 <arw> hpc: yes, but memory access is very expensive, more expensive than most simple calculations
09:21:04 <sm> morning all
09:21:12 <proc> monoidal, (show a) solved it :)
09:21:19 <proc> forgot the parantheses
09:21:19 <sm> cabal install mandulia on a mac gave me: Missing header file: rjulia.h . Where in the world might this be ?
09:22:37 <poincare101> where can I find a good tutorial on Monads? (math based is welcome)
09:22:46 <Gracenotes> sm: hm.. maybe you need to install it as a system library?
09:23:04 <monoidal> poincare101: if you just learned about anonymous functions, then don't go to monads
09:23:06 <sm> port search julia came up empty..
09:23:44 <monoidal> proc: if you have the one-number variant, then you can use map to take a list of numbers and have func "foon" [2..10] = ["foo2",...,"foo10"]
09:23:58 <monoidal> proc: in other words, this will be a nested map
09:23:59 <proc> yeah, I think I got a big step forward
09:24:05 <proc> but there's one strange thing now:
09:24:15 <proc> Main> func "anb" [0..11]
09:24:15 <proc> ["a0b","a1b","a2b","a3b","a4b","a5b","a6b","a7b","a8b","a9b","a10b","a11b"
09:24:15 <proc> Program error: pattern match failure: func "anb" []
09:24:22 <proc> where comes that empty list from?
09:24:27 <Gracenotes> sm: oh wait. it looks like it should be in the src/ folder
09:24:52 <proc> I added func str [] = [] now, works
09:24:52 <sm> Gracenotes: thanks.. sounds like a mandulia packaging error ?
09:24:53 <proc> still strange
09:25:04 <monoidal> proc: every list is either of the form a:b, or []
09:25:39 <monoidal> proc: try to write func without using pattern matching
09:25:54 <proc> oh
09:26:03 <proc> so my func's crap? ;)
09:26:18 <proc> func str (x:xs) = concatMap(\n -> if n == 'n' then (show x) else [n]) str : (func str xs)
09:26:39 <monoidal> it's good. you don't need parenthesis in (show x)
09:26:52 <proc> oh, ok
09:27:16 <mich2000> Hi! I'm very new to Haskell. could someone tell me how to print out a string of text on the screen? 
09:27:23 <monoidal> putStrLn
09:27:30 <p00ya> @pl \c xs -> takeWhile ((c==) . head) (dropWhile ((c>) . head) xs)
09:27:30 <lambdabot> ap ((.) . takeWhile . (. head) . (==)) (dropWhile . (. head) . (>))
09:27:40 <mich2000> Thanks a lot!!
09:27:49 <ClaudiusMaximus> sm: let me double check, i'm sure it's in there
09:28:02 <drhodes> mich2000: you might find this site: http://tryhaskell.org/ helpful
09:28:03 <proc> mich2000, from newcomer to newcomer: don't waste your time with i/o at the beginning
09:28:12 <ClaudiusMaximus> sm: i'm a bit n00b at cabal, i might have specified it incorrectly
09:28:27 <sm> hi ClaudiusMaximus .. thanks for the package, sounds groovy
09:28:32 * sm will try the next
09:29:04 <Saizan> sm: which version of ghc/cabal ?
09:29:08 <ClaudiusMaximus> sm: well, the files are there, and i do have:    Include-dirs:        src
09:29:08 <ClaudiusMaximus>   Includes:            rjulia.h
09:29:08 <ClaudiusMaximus>                        qsort.h
09:29:29 <ClaudiusMaximus> and the files are in src/
09:30:34 <p00ya> @pl \xs -> takeWhile ((c==) . head) (dropWhile ((c>) . head) xs)
09:30:34 <lambdabot> takeWhile ((c ==) . head) . dropWhile ((c >) . head)
09:30:55 <sm> ClaudiusMaximus: verbose cabal install at http://gist.github.com/489671
09:32:40 <Saizan> sm: hah "cc1: error: invalid option ‘sse4’"
09:32:55 <ClaudiusMaximus> sm: ah, i feared this might happen at some point - your gcc is too old to support the GCC flags i crammed in to make it not slow...
09:32:56 <poincare101> I wrote a simple prime gen in haskell by following your instructions: http://pastebin.com/418072, and it works. Now, I would like to keep track of prime density, and I really don't understand how can do this without setting and resetting a counter.
09:33:20 <proc> are there any neat function to parse mathematical strings or do I have to do dirty string work? ;)
09:33:22 <ClaudiusMaximus> sm: "/usr/bin/gcc is version 4.0.1" which doesn't support -march=native or -msse4
09:33:26 <sm> aha
09:33:30 <sm> this is leopard
09:33:43 <proc> for example foo "1+1" -> 2
09:34:20 <ClaudiusMaximus> hm, fixing this is slightly harder than fixing the help text...
09:34:22 <hpc> parsing math like that is a pain in the ass
09:34:24 <monoidal> proc: just to finish previous thing, instead of func str (x:xs) = ... and func str [] = ... you can write func str = map (\x -> ...)
09:34:32 <Saizan> in theory there's probably a way to require a minimum version of gcc in the .cabal file..
09:34:59 <proc> monoidal, where's the int in the second way?
09:35:08 <monoidal> it's the argument in \x -> ...
09:35:30 <monoidal> the whole function would be func str = map (\x -> concatMap(\n -> if n == 'n' then (show x) else [n]) str)
09:36:52 <ClaudiusMaximus> sm: http://gcc.gnu.org/ml/gcc-help/2007-08/msg00244.html
09:37:18 <proc> monoidal, oh that's nice
09:37:19 <proc> thanks
09:37:34 <proc> no need for recursion then
09:41:49 <cached> is there a good policy as to when to use $ instead of ( .. )
09:42:20 * hackagebot mandulia 0.6 - A zooming visualisation of the Mandelbrot Set as many Julia Sets.  http://hackage.haskell.org/package/mandulia-0.6 (ClaudeHeilandAllen)
09:43:32 <randomwords> ClaudiusMaximus: Is it possible to explore the mandelbrot set proper. I'd love to compare our implementations
09:44:11 <monoidal> proc: try the following: data Expr = Number Int | Add Expr Expr 
09:44:52 <monoidal> now, you can write evaluate :: Expr -> Int and also parse :: String -> Expr, but parsing is hard and quite boring
09:45:04 <monoidal> and add other types of expressions
09:45:11 <ClaudiusMaximus> randomwords: i did think about it, but i figured it would get too confusing having julia sets overlayed on top of the mandelbrot set, and the mandelbrot set probably needs higher precision arithmetic for zooming in deeply than the julia sets which are quite small
09:45:17 <hpc> parsing can be made fun
09:45:43 <hpc> first parse RPN, then use shuntingyard to transform the input string into RPN
09:46:14 <randomwords> ClaudiusMaximus: Yes that's true, and most of the arbitrary precision floating (or fixed point) arithmetic libraries in haskell tend to focus on correctness rather than speed
09:46:35 <ClaudiusMaximus> randomwords: essentially what i had in mind was zooming in by a factor of 2 would create 4 tiles the same size as the previous level, each with 1/4 of the pixels copied from the tile in the layer above
09:46:42 <randomwords> they can be slightly unweildy. It may have changed though, I have looked in months
09:48:36 <ClaudiusMaximus> but then it probably makes sense to copy the other direction for oversampling/smoothing...
09:49:11 <randomwords> That's what I do
09:50:00 <randomwords> You need to think about the averaging function though, you don't want a straight mean, becuase that doesn't account well for point just on the border of the set
09:51:48 <proc> monoidal, sounds really painful
09:52:16 <hpc> one easy but hacky way is to drop the top and bottom 10%, then mean
09:53:34 <ClaudiusMaximus> i have a cheat for speeding up rendering of high (fractal) dimension julia sets (the ones with large solid areas) - see if the rate of escaping points drops too low, then assume all the rest are inside...
09:54:21 <ClaudiusMaximus> it looks bad sometimes, but most of the time it's ok
09:55:21 <hpc> with the right tuning, it wouldn't look too bad
09:55:41 <sm> ClaudiusMaximus: sorry to report 0.6 gives me just the same error
09:56:09 <ClaudiusMaximus> sm: to be expected, sorry - that was just a bugfix for the help text for people who could get it compiled
09:56:16 <sm> ah, no worries
09:56:53 <ClaudiusMaximus> sm: i should add a flag like "-f-crank" that disables the extra options
09:57:11 <hpc> ive seen fractal programs use gif-like scan iterations to make it easier to just zoom through the fractal to the part you want
09:58:01 <ClaudiusMaximus> hpc: like block pixels that gradually get finer (PNG interlacing would be my reference for that i guess)
09:58:08 <hpc> yeah
09:58:33 <monoidal> proc: there are parsing libraries like parsec: http://book.realworldhaskell.org/read/using-parsec.html that allow easy and fast parsing. I don't know if you'll be able to use it. For a very limited reading, you can use built-in function "read" which is opposite of "show"
09:58:49 <monoidal> by adding deriving (Read) after the data declaration
09:59:14 <monoidal> that will parse a string like "Add (Number 6) (Number 4)"
09:59:18 <hpc> > read "4+5"
09:59:19 <lambdabot>   *Exception: Prelude.read: no parse
09:59:37 <hpc> (just making sure)
10:00:34 <mauke> > read "9"
10:00:35 <lambdabot>   *Exception: Prelude.read: no parse
10:02:03 <ClaudiusMaximus> > read "*Exception: Prelude.read: no parse"
10:02:04 <lambdabot>   *Exception: Prelude.read: no parse
10:02:50 <hpc> > read "Just Nothing"
10:02:51 <lambdabot>   *Exception: Prelude.read: no parse
10:03:04 <hpc> hmm
10:03:18 <monoidal> you need ::. it's type defaulting
10:03:59 <hpc> > read "4+5" :: Int
10:04:00 <lambdabot>   *Exception: Prelude.read: no parse
10:04:16 <hpc> > read "Just Nothing" :: Maybe (Maybe a)
10:04:16 <lambdabot>   Could not deduce (GHC.Read.Read a) from the context ()
10:04:17 <lambdabot>    arising from a us...
10:04:50 <monoidal> > read "Just Nothing" :: Maybe (Maybe Int)
10:04:51 <lambdabot>   Just Nothing
10:05:38 <zachk> > reads "15 cat 24 56 dog hat"::[(Integer,String)] 
10:05:38 <notyourmom> >map (+1) [1..10]
10:05:39 <lambdabot>   [(15," cat 24 56 dog hat")]
10:05:52 <notyourmom> > map (+1) [1..10]
10:05:53 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
10:06:20 <notyourmom> > length [1..]
10:06:24 <lambdabot>   mueval-core: Time limit exceeded
10:06:31 <zachk> > reads "1432 32535 324523523 -2342352 -22423425"::[(Integer,String)] 
10:06:31 <lambdabot>   [(1432," 32535 324523523 -2342352 -22423425")]
10:06:40 <edwardk> preflex: xseen conal
10:06:40 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:06:40 <preflex>  conal was last seen on freenode/#ghc 13 hours, 44 minutes and 44 seconds ago, saying: i'll report it.
10:08:58 <listofoptions> ddarius, thanks for the pattern calc, it's turning out to be quite fascinating....
10:15:56 <conal> edwardk: hi
10:16:39 <conal> edwardk: oh -- i see your note.  i don't remember getting the unamb message via lambdabot
10:21:11 <sm> is someone here successfully generating man pages with pandoc ?
10:21:21 <sm> mine seems a bit lacking in whitespace
10:27:38 <ManateeLazyCat> hamishmack: gtk2hs-darcs can compile on Windows?
10:31:48 <interferon> for the life of me, i can't understand how "forall a . a -> a" is any different from "a -> a"
10:32:15 <FauxFaux> I don't believe it is.
10:32:24 <Gracenotes> as a top-level type signature, it isn't
10:32:25 <interferon> so what does it achieve?
10:32:37 <interferon> isn't any algebraic variable "a" always substitutable by any type?
10:32:39 <monoidal> in this context, nothing
10:32:39 <Gracenotes> as a component of another type, it's rather different
10:33:10 <Gracenotes> (and I do think you need an explicit top-level forall with the ScopedTypeVariables extension, but that's an extension, so)
10:33:29 <monoidal> Gracenotes: see rank2/rankN types
10:33:34 <monoidal> * inferon
10:33:47 <monoidal> *interferon
10:34:05 <Gracenotes> isn't that a protein?
10:34:36 <interferon> yeah, part of the immune system
10:36:16 <monadic_kid> how do i get jhc to ffi export and generate the stub headers/source?
10:36:33 <Gracenotes> oh that's your nick. didn't see that.
10:38:34 <interferon> but what is the purpose of an existential type?
10:39:35 <monoidal> for example, it allows to have a heterogeneous list
10:40:17 <edwardk> conal: let me go dig it up via hpaste
10:40:25 <interferon> [(forall a . a)] ?
10:40:30 <conal> thx
10:40:41 <edwardk> hrmm hpaste seems to be dead
10:40:48 <conal> oops :(
10:40:50 <edwardk> meh it wasn't hard to derive
10:41:10 <monoidal> interferon: data T = forall a. Show a => T a; then [T] is a list of things that are showable
10:41:12 <edwardk> you want me to just write a patch for unamb?
10:41:24 <edwardk> is there a public repo for it?
10:41:31 <interferon> monoidal: huh.  and am i required to have some class constraint?
10:41:47 <conal> yeah.  looking
10:41:52 <monoidal> interferon: no, but then you can't do much with that type
10:41:53 <edwardk> found it: http://code.haskell.org/unamb ?
10:42:03 <interferon> monoidal: true
10:42:09 <interferon> well that is cool
10:42:37 <conal> edwardk: that's what i see also in the .cabal.  
10:42:52 <edwardk> conal: want me to just include the logic for the tag bits in the package? link to speculation? or should i factor it out of speculation and into another package to shrink the dependency?
10:43:33 <monoidal> interferon: just like Either is "union" of two types, existentials are parametrized unions which are indexed by all types.
10:43:42 <conal> edwardk: factoring would be nifty.
10:44:10 <edwardk> hrmm now i need a module/package name =)
10:44:15 <monoidal> interferon: with that above declaration, there's a function T :: Show a => a -> T
10:45:13 <conal> edwardk: is your patch a way to avoid the forkIO when an unamb argument is already (partially) evaluated?
10:45:20 <edwardk> yeah
10:45:25 <conal> sweet!
10:45:35 <edwardk> tag-bits, Data.TagBits, unsafeGetTagBits, unsafeIsEvaluated ?
10:45:49 <conal> i wouldn't guess from "tag bits"
10:46:02 <edwardk> dynamic-pointer-tagging is a bit verbose =/
10:46:29 <interferon> monoidal: i.e. the sole constructor for T
10:46:30 <conal> ah -- it's more than just evaluated vs not?
10:46:34 <edwardk> yeah
10:46:40 <monoidal> interferon: yes
10:46:53 <conal> oh, okay.  then disregard my remark.
10:47:02 <conal> all sounds good to me.
10:47:07 <edwardk> you can get the actual tag bits if you want to, which lets you know which constructor it is (if its a constructor between 1-3, or 1-7 on 64 bits)
10:47:11 <edwardk> alright
10:47:29 <edwardk> i'll package up tag-bits, then pull a copy of unamb.
10:47:39 <conal> :) !
10:48:30 <conal> edwardk: oh, and maybe you'll have some ideas for improving other aspects of unamb.  i've never understood the underlying RTS machinery.
10:49:01 <edwardk> i'll take a look, and if nothing else start thinking about it in the background
10:49:13 <conal> edwardk: i'd love to have a solid unamb implementation with a clear explanation.
10:50:04 <jmcarthur> hear hear
10:50:12 <conal> :)
10:50:23 <benmachine> it should be a language feature!
10:50:25 <benmachine> maybe sorta
10:51:11 <jmcarthur> that's basically what it ideally would be
10:51:16 <conal> i expect lub will turn out to be a gold-mine of techniques for modular denotative/functional programming.
10:51:53 <jmcarthur> conal: your client does strange things when you hit backspace (i assume that's what you did)
10:52:09 <jmcarthur> "i ^Dexpec lub will"
10:52:14 <conal> jmcarthur: i've been having that trouble, intermittently lately.  on colloquy.
10:52:27 <conal> don't know what's going on.  a recent problem, i think.
10:52:31 <jmcarthur> seems to happen often
10:52:36 <conal> yeah :(
10:52:40 <benmachine> never got on with colloquy personally
10:52:48 <conal> sometimes i notice, and i move my edit elsewhere.
10:52:58 <conal> anyone have recommendations for other mac os x irc clients?
10:53:16 <jmcarthur> i could recommend a terminal client, but that's all
10:53:22 <edwardk> almost done with the new package
10:53:30 <edwardk> then i'll tackle unamb
10:53:30 <conal> or maybe i'll go back to erc (irc via emacs)
10:53:33 <benmachine> conal: I used to use xchat aqua
10:53:46 <conal> benmachine: did you like it?
10:53:56 <benmachine> *I* did, but I spoke to some people who didn't I think
10:54:10 <benmachine> I preferred it to colloquy, but this was months ago
10:54:33 <benmachine> I think it's worth a try
10:54:49 <conal> benmachine: did you move off of mac
10:54:51 <conal> ?
10:54:52 <benmachine> yes
10:57:59 <conal> hm.  on 6.12.1, Unamb yields "Warning: -XRecursiveDo is deprecated: use -XDoRec or pragma {-# LANGUAGE DoRec #-} instead".  if i switch pragmas, i wonder which ghc versions can no longer compile Unamb
10:58:17 <gwern> 'Illustrative of the customizability of an exokernel system, Tom Pinckney while still an undergraduate was able to implement a new page table
10:58:20 <gwern> structure in a week, while taking his final exams. As a testament to the difficulty of modifying current operating systems, the proposers of this page
10:58:23 <gwern> table structure were only able to simulate it [83].
10:58:40 * hackagebot tag-bits 0.1.0 - Provides access to the dynamic pointer tagging bits used by GHC.  http://hackage.haskell.org/package/tag-bits-0.1.0 (EdwardKmett)
10:59:05 * conal grabs tag-bits
10:59:23 <edwardk> refactoring speculation to use it now
11:00:03 <stulli> In this SO post: "http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell/3077912#3077912 dons mentioned it is good to "Enforce key invariants via types". What does it mean? Has it sthg to do with type arithmetic?
11:00:49 <conal> wow.  i'd forgotten that Unamb.hs is mostly comments
11:01:00 <edwardk> yeah
11:01:05 <Cale> stulli: It just means, to the extent that you can manage, try to use types to enforce properties about your program that you'd like to be true.
11:01:19 <edwardk> on, speculation patched, time for unamb ;)
11:01:22 <edwardk> er ok
11:01:32 <conal> hm.  i wonder why unambs isn't defined using foldr.
11:01:41 * hackagebot speculation 1.0.0.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.0.0.0 (EdwardKmett)
11:02:02 <edwardk> (had to go to version 1.0, just to tease ddarius, who says i never release a 1.0 of anything)
11:02:34 <conal> :)
11:02:56 <stulli> Cale: So if i had a type Kelvin and i didn't want it to go below 0, is this an example?
11:02:59 <conal> edwardk: i see commented-out isEvaluated in amb.  i guess i used to use something similar to what you're doing.  maybe from vacuum.
11:03:23 <edwardk> ah
11:03:27 <stulli> Or am i trying to interpret too much into his statement
11:03:29 <Cale> stulli: It might be, though numeric bounds are somewhat trickier to enforce in Haskell's type system.
11:03:33 <dankna> stulli: well - that particular example works, but if you had a type Celsius and you didn't want it to go beneath -273, you couldn't use type constraints to enforce that
11:04:04 <dankna> you would have to use some other sort of constraint
11:04:08 <Cale> stulli: A better related example would perhaps be using different types for quantities with different physical units.
11:04:31 <dankna> I think what the statement is saying (but I haven't read the context of it) is just, whenever possible, types should be the mechanism by which you enforce these constraints
11:05:05 <edwardk> conal: what i did when i took my first stab at this was just write a wrapper library, which used this one. so i wrote Data.Unamb.Speculation (bad name, but meh) that used the existing Data.Unamb, i didn't muck around in its internals
11:05:05 <dankna> you can always enforce semantic constraints by just putting the relevant bits in a private module and not exporting any constructors or functions that don't obey the constraint
11:05:08 <Cale> dankna: Apart from the obvious way by using an internal representation which can't be negative, and simply subtracting 273 when displaying things
11:05:12 <dankna> but it's more bug-prone
11:05:16 <dankna> Cale: well yes, heh
11:05:33 <Cale> The tricky part is really supporting subtraction in a safe way with a type like that.
11:05:35 <conal> edwardk: oh, sure. that'd be an easy way to go.
11:05:54 <Cale> Because every subtraction might fail, and if you want to enforce that they won't in the type system, that's hard.
11:06:19 <edwardk> should i do the same thing here? i.e. just rename Data.Unamb to Data.Unamb.Raw or something and then make a Data.Unamb that uses it? that would let you have access to either behavior
11:06:23 <Cale> (I won't say it's impossible, but it's probably not worth doing in Haskell)
11:06:33 <dankna> well, because doing so in the type system means guaranteeing /at compile time/ that the user will never do a subtraction that's out of bounds, doesn't it?
11:06:39 <Cale> right
11:07:10 <dankna> what is "speculative parallelism"?  is that like Prolog?
11:07:12 <hpc> i can't imagine a way to do that that wouldn't entirely cripple it in actual use
11:07:18 <stulli> Cale, dankna: Ok, thanks. So it is just using normal types somewhat intelligent. 
11:07:24 <dankna> stulli: yeah
11:07:28 <conal> edwardk: either behavior?
11:07:48 <hpc> speculative parallelism is "we need this and this, but we can definitely do them in separate threads; hey runtime, can we run these at the same time?"
11:07:52 <edwardk> dankna: it means that you can have two stages of computation, where the latter depends on the former, but where you might have a good guess at the argument that will be passed between them, so you can run the second stage with the guess, while you're still computing the first one
11:08:09 <dankna> hmm
11:08:11 <dankna> neat concept
11:08:15 <edwardk> dankna: and if you guessed wrong, you can go and run it with the right argument
11:08:20 * dankna nods
11:08:21 <dankna> I see!
11:08:41 <edwardk> conal: i mean with or without tag bit inspection
11:08:52 <hpc> so on multicore systems, for example
11:08:54 <conal> edwardk: have you read warren burton's related papers from the 1980s?
11:09:19 <hpc> par a b = start evaluating a, and return b
11:09:21 <conal> edwardk: ah.  if tag inspection is simple & dependable, then i'd add it right into Unamb.
11:09:28 <edwardk> I have never to my knowledge ever seen or heard his name in print, you can probably take that as a no. ;)
11:09:29 <hpc> pseq a b = do a, then do b
11:09:41 <hpc> on single core systems, par = const, pseq = seq
11:09:48 <hpc> er, flip const
11:10:06 <edwardk> fair enough, integrating it into the combinators then
11:10:22 <conal> edwardk: for one thing, we'd probably want it in amb.  if you build another layer, i think you'll have to re-implement unamb via your tweaked amb.
11:10:52 <Cale> hpc: actually pseq and seq have a semantic effect on single core systems
11:10:59 <edwardk> well, in my quick hack i tweaked each combinator separately, because there are some subtle opportunities in por and pand that get missed otherwise
11:11:02 <Cale> It's par which is eraseable
11:11:09 <conal> edwardk: not that i use amb other than for unamb.  but others might.
11:11:10 <hpc> oh, right
11:11:36 <conal> edwardk: oh!  i'd love to hear about those missed opportunities.  there's a lot of subtle stuff here!
11:11:45 <hpc> so putStrLn "blah" (`seq` | `pseq`) unsafeLaunchMissiles are different
11:11:48 <hpc> lousy IO
11:11:50 <rossputin> Hi guys, newbie here hoping for some pointers on evaluating math expressions in ghci
11:12:00 <edwardk> mostly just the use of the annihilator/identity element.
11:12:14 <Cale> rossputin: sure :)
11:12:22 <hpc> rossputin: (void*) ;)
11:12:23 <rossputin> hi Cale
11:12:37 <gwern> whoa. so exokernels use deterministic turing machines == pure functions to allow untrusted libraries trusted rw access to the hard drive
11:12:38 <Cale> rossputin: Hi! Is there something in particular you're having trouble with?
11:12:44 <gwern> I think I need to reread that section
11:12:45 <edwardk> por a b | unsafeIsEvaluated a = a || b; | unsafeIsEvaluated b = b || a; otherwise = Naive.por a b
11:12:49 <rossputin> Hah, most things Cale :-)
11:13:02 <edwardk> that way you get the short circuiting behavior, etc.
11:13:04 <rossputin> first up, a simple test my dad wanted me to work through
11:13:25 <rossputin> how would you go about evaluating something like....
11:13:36 <edwardk> it also let me do things like unambs more intelligently by walking the whole list to see if any of them are evaluated
11:13:53 <conal> edwardk: hopefully there's a much more general place to put that logic.  so it'll get more use.
11:13:54 <rossputin> (1000 ^ (-4/3)) * ((100/9) ^ (3/2))  ?
11:14:15 <Cale> ah, you'll want to use ** for exponentiation when the exponent is a fraction like that
11:14:19 <conal> edwardk: at least in parCommute, but hopefully more generally yet.
11:14:19 <rossputin> is that doable without some special library.. ie in ghci ?
11:14:24 <dafis> > (1000 ** (-4/3)) * ((100/9) ** (3/2))
11:14:25 <lambdabot>   3.7037037037037056e-3
11:14:32 <dafis> rossputin: ^^
11:14:34 <gwern> rossputin: so it would seem
11:14:40 <gwern> all glory to the hypno ghci!
11:14:50 <hpc> and you want to wrap unary minus in parenthesis, generally
11:14:51 <conal> edwardk: oh.  tricky.
11:14:51 <dafis> rossputin: Haskell has three exponentiation operators
11:14:56 <rossputin> wow.. blown away by the speed of that response... :-)
11:15:03 <edwardk> sure, i built up similar reasoning in parCommute, parAnnihilator, parIdentity, but to get all the scenarios covered because there is an annihilator, and unit and it commutes, you'd need to be quite wasteful
11:15:17 <Cale> rossputin: There are three exponentiation operations in the Haskell Prelude, corresponding to three particular definitions of exponentiation (which we normally give the same syntax to in mathematics)
11:15:32 <edwardk> the existing por is quite wasteful
11:15:38 <Cale> rossputin: ^ works with non-negative exponents only, but any sort of number as the base
11:15:52 <Cale> rossputin: ^^ works with any integer exponents, but requires a fractional base type
11:15:54 <dafis> rossputin: (^) raises any number to a non-negative integer power
11:16:05 <Cale> rossputin: and ** works with floating point bases and exponents
11:16:09 <rossputin> ok, trying this out
11:16:13 <conal> edwardk: ah yeah.  nice.  room to be much smarter.  hopefully without complicating lots of special-case functions like por & pand.
11:16:26 <rossputin> thankyou all for the advice
11:17:05 <conal> edwardk: though right off i don't see a way to be smart in general.  (||) and (&&) have their particular operational semantics.
11:17:17 <Gracenotes> @type sequence . sequence
11:17:18 <lambdabot> forall a. [[a]] -> [[a]]
11:17:22 <edwardk> por and pand are probably the worst of the bunch just because they would want everything you currently provide
11:17:27 <Gracenotes> frrhhrrm
11:17:30 <Gracenotes> @type fmap sequence . sequence
11:17:31 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f, Monad f) => [f (m a)] -> f (m [a])
11:17:37 <Gracenotes> better
11:17:51 <conal> edwardk: because they commute and have annhihilators?
11:17:54 <conal> and identies.
11:17:57 <edwardk> and identities
11:17:58 <edwardk> yeah
11:18:06 <edwardk> thats an awful lot of threads to spawn
11:18:10 <edwardk> for no real win
11:18:18 <edwardk> to encode it using the combinators you have
11:18:23 <conal> yeah.
11:18:52 <edwardk> hence why (without having seen the code for unambs guts) i assumed you had the special case combinators for them ;)
11:18:53 <conal> okay, so there's a good challenge.  keep the combinator set small & reusable and get optimal results.
11:19:17 <conal> if needed, using some ghc rules.
11:22:46 <edwardk> you could use a parShortCircuit :: (a -> a -> b) -> (a -> a -> b)
11:23:17 <edwardk> or rather parCommuteShortCircuit -- which relies on the fact that the function offers short circuiting behavior in its left argument
11:23:29 <edwardk> and that its left argument is flat
11:23:37 <edwardk> but that becomes so ugly i'd rather not let it leak into the API
11:23:59 <edwardk> hence my hacking of por and pand behind the curtain ;)
11:25:10 <monadic_kid> does it makes sense to foreign export main entry point of a haskell program?
11:25:32 <pikhq> monadic_kid: Not really.
11:26:25 <monadic_kid> pikhq: check the last paragraph: http://www.haskell.org/pipermail/jhc/2010-July/000755.html
11:26:25 <jmcarthur> i've done it
11:26:50 <jmcarthur> i had to do it to get it to work with SDL on OS X
11:27:31 <jmcarthur> SDL has its own main function that is supposed to automatically override your own, but it doesn't play correctly when linked with haskell binaries, so you have to make a C wrapper to call into the haskell main
11:27:45 <pikhq> Urgh.
11:27:46 <jmcarthur> at least, that was the case a couple years ago
11:28:06 <conal> edwardk: perhaps you'll find some improvements to Lub.hs as well.  Especially the treatment of product & sum described in http://conal.net/blog/posts/merging-partial-values/
11:28:22 <monadic_kid> jmcarthur: that hasn't really changed in SDL
11:28:30 <edwardk> conal: will check it out next
11:28:58 <conal> edwardk: would help the performance of non-strict memoization, since everything is built from (), *, and +
11:28:59 <edwardk> tweaked parAnnihilator and parIdentity, and added an (internal) parCommuteShortCircuit
11:29:27 <edwardk> funny you were hacking up the memo-trie stuff, i was just working on a trie lib of my own (though the more traditional lookup kind)
11:29:48 <conal> edwardk: yeah!  we seem to be on similar wavelengths lately.
11:29:48 <edwardk> (and with uglier semantics, because i'm willing to use template haskell to build up a dedicated map type) ;)
11:30:07 <conal> ah.
11:30:50 <conal> i got this non-strict memoization idea quite a while ago.  finally catching up on some blogging.
11:30:55 <edwardk> regarding your pmin and pmax they don't use the identity of the maxBound/minBound respectively. is this deliberate because of the semantics you need for improving time?
11:31:30 <conal> edwardk: more likely an oversight.
11:31:40 <edwardk> likewise pmult doesn't check for unit multiplication as well
11:32:05 <conal> hm.
11:32:49 * hackagebot hamlet 0.4.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.4.1 (MichaelSnoyman)
11:32:50 <edwardk> you can of course use pmult = parAnnihilator (parIdentity (*) 1) 0 -- but that is fairly wasteful
11:33:25 <edwardk> would you be willing to permit a parAnnihilatorIdentity to check both?
11:33:46 <edwardk> cuts the number of threads potentially spawned and tag bit checks in more than half
11:33:48 <conal> eep.  i'm getting worried about uglying up this code for the sake of performance.  i hope we can make it pretty and fast.
11:34:10 <edwardk> i understand, but a lot of why it is "pretty" is that it doesn't do everything it could ;)
11:34:42 <conal> edwardk: yeah.  i don't want to keep it inefficient.  looking for ways to get both.
11:34:44 <edwardk> the AnnihilatorIdentity case handles all of pmin/pmax/pmult
11:34:52 <cozachk> @src product
11:34:52 <lambdabot> product = foldl (*) 1
11:34:59 <conal> edwardk: cool.
11:35:01 <cozachk> @src sum 
11:35:01 <lambdabot> Source not found. That's something I cannot allow to happen.
11:35:45 <conal> edwardk: what i'm trying to say is that i want to maximize or nearly-maximize efficiency and see how elegantly we can get that efficiency.
11:35:54 <edwardk> *nods*
11:36:08 <conal> edwardk: i suspect you have those same values.
11:36:35 <edwardk> i'm almost done kind of going through like a bull in a china shop hacking in the efficiency portion. i leave it in your capable hands to make pretty ;)
11:37:01 <conal> mostly in my work i reject the speed-vs-elegance dichotomy.
11:37:12 <edwardk> i do think that it was more obvious when i had the code for dealing with tag bits in a separate module though
11:37:32 <conal> edwardk: okay.  maybe that's a better approach after all.
11:37:55 <edwardk> yeah. i'm not liking the artifact that is resulting from the current approach
11:37:56 <conal> edwardk: i didn't realize there'd be so many changes.
11:38:11 <edwardk> any preference for the name of the internal module?
11:38:27 <conal> which is internal?
11:38:34 <edwardk> hrmm, well, its just that i need an unamb' to call from the other combinators that doesn't shortcircuit, etc.
11:39:10 <conal> ah -- my present Unamb.hs would be the internal, right?
11:39:17 <edwardk> yeah
11:39:28 <conal> hm...
11:39:39 <edwardk> going to keep evaluating both options in parallel and see which leads to a better api
11:39:51 <conal> oh, then maybe a separate package, not just a separate module.
11:40:13 <conal> which is what you were doing before ...
11:40:25 <edwardk> the problem then is that the end user needs to consciously care to use the improved implementation =/
11:40:34 <conal> yeah :)
11:40:55 <conal> hm.  i just noticed we're crowding the channel.  maybe move to private chat?
11:40:59 <edwardk> hrmm maybe the local-only hacks aren't going to be that bad
11:41:04 <edwardk> sure, #haskell-in-depth?
11:41:08 <cozachk> foldl' to the rescue! no more stack overflow lets see if i run out of ram 
11:41:08 <conal> k
11:56:41 <osfameron> eeeek!  I just read Ian Banks's Transition, and I think I realised that parallel universes are monadic.
11:57:27 <alexbobP> hey, is a Char a single byte or does it include unicode chars?
11:57:36 <ddarius> gwern: If you are reading the Xok thesis now, I highly recommend it.  If you aren't, I highly recommend it.
11:57:40 <dafis> alexbobP: unicode
11:57:45 <hpc> > maxBound :: Char
11:57:46 <lambdabot>   '\1114111'
11:57:49 <alexbobP> ah, okay.
11:58:04 <alexbobP> so if I want to be able to print raw bytes, what would I do?
11:58:05 <hpc> > maxBound :: Byte
11:58:06 <lambdabot>   Not in scope: type constructor or class `Byte'
11:58:18 <hpc> > maxBound :: Word8
11:58:19 <lambdabot>   255
11:58:27 <alexbobP> read and write raw bytes that is
11:58:28 <gwern> ddarius: if I'm already reading it, shouldn't you say something like 'I highly recommend continuing to read it'?
11:58:36 <mauke> alexbobP: I'd use Data.ByteString
11:58:41 <ddarius> alexbobP: Use ByteString or if you must use String, set the encoding to something that will produce (extended) ASCII.
11:58:42 <alexbobP> mauke: okay, thanks
11:58:43 <hpc> ByteStream is basically [Word8], iirc
11:58:44 <dafis> alexbobP: ByteString
11:58:56 <ManateeLazyCat> alexbobP: ByteString
11:59:10 <alexbobP> hpc: ah, good to know
11:59:23 <ddarius> alexbobP: Not implementation-wise though.
11:59:25 <alexbobP> is initializing a Word8 as easy as, say, "33::Word8"?
11:59:39 <alexbobP> er, not initializing... expressing
11:59:42 <dafis> alexbobP: It's much much much more efficient than a vanilla list, though
11:59:47 <ddarius> It's easier than that.
12:00:02 <alexbobP> dafis: ah, okay
12:00:19 <dafis> alexbobP: if the compiler can infer the type, 33 is enough
12:00:54 <alexbobP> dafis: of course, I just wanted to know if 33 was a valid example of a Word8 :P
12:01:03 <mauke> > 33 :: Word8
12:01:04 <lambdabot>   33
12:01:04 <alexbobP> alright, time to try some stuff.
12:01:11 <alexbobP> oh yes the bot
12:01:13 <alexbobP> :D
12:01:33 <AmunRa> Again I've had to reinstall haskell from scratch because "cabal upgrade" messed everything up. What is the safest way to upgrade a package?
12:01:35 <alexbobP> > show ([33::word8, 34, 35, 36])
12:01:36 <lambdabot>   Could not deduce (GHC.Num.Num word8) from the context ()
12:01:36 <lambdabot>    arising from th...
12:01:51 <ddarius> Numeric literals in Haskell get translated to: fromInteger 33.  Any type that is an instance of Num implements fromInteger and thus numeric literals work for all types in Num.
12:01:51 <alexbobP> > show ([33::Word8, 34, 35, 36])
12:01:52 <lambdabot>   "[33,34,35,36]"
12:01:56 <alexbobP> oh lol
12:02:10 <dafis> > 23456 :: Word8
12:02:11 <lambdabot>   160
12:02:12 <alexbobP> ddarius: awesome
12:02:22 <alexbobP> see this is why I love haskell
12:02:23 <hpc> > maxBound :: Char8
12:02:24 <lambdabot>   Not in scope: type constructor or class `Char8'
12:02:54 <alexbobP> it does all the cool stuff of other languages but without jumping on the bandwagon of pushing all the housekeeping work onto the programmer
12:02:55 <ddarius> AmunRa: Don't use cabal upgrade at all.  That should have been removed.  If you want to upgrade, just cabal update to get the newest lists of packages and cabal install the package and it will grab the newest version.
12:03:08 <dafis> hpc: Data.ByteString.Char8 is the same type, just a different interface
12:03:34 <hpc> ah, i wondered; couldn't find the docs
12:03:37 <AmunRa> ddarius, how will I know which package is being used, then?
12:03:45 <ManateeLazyCat> AmunRa: "cabal upgrade" is don't like your expect. :)
12:03:49 <ddarius> AmunRa: What do you mean?
12:04:08 <AmunRa> that will have multiple versions of a package installed side by side, right?
12:04:18 <hpc> one should replace the other
12:04:35 <ManateeLazyCat> AmunRa: You can use multiple version.
12:05:13 <AmunRa> Ideally I just want to keep the latest.. if that's what `install` does.. what's `upgrade` for?
12:05:16 <ManateeLazyCat> AmunRa: If you don't limit in .cabal file, ghc use newest version....
12:05:32 <ddarius> AmunRa: Upgrade was a mistake that, I'm pretty sure, has been removed.
12:05:34 <ManateeLazyCat> AmunRa: "upgrade" will remove
12:05:52 <ManateeLazyCat> AmunRa: Just install new version when you need it.
12:06:14 <AmunRa> thanks for the clarification.. package management is always tricky
12:06:18 <ManateeLazyCat> AmunRa: Upgrade all package, special core package will break manay packages.
12:07:38 <ManateeLazyCat> AmunRa: So just run "cabal update" update package list from hackage, then install your interested package manually 
12:12:02 <ddarius> AmunRa: Yeah, if you run cabal upgrade on a newer version of the cabal-install tool it prints the following message: the 'ugrade' command (when used without any package arguments) has been disabled in this release.  It has been disabled because it has frequently led people to accidentally break their set of installed packages.
12:14:50 <AmunRa> nice, still learning: ByteString question: Is there any way to make working with ByteStrings less tedious? Having to call B.pack on everything looks ugly: (B.pack "Hello ") `B.append` name (B.pack " ..What's up?")
12:15:04 <lispy> AmunRa: yes
12:15:17 <lispy> AmunRa: So, if you're packing lots of little strings that's bad
12:15:27 <lispy> AmunRa: But, there is an OverloadedStrings extension
12:16:48 <AmunRa> lispy, could you be more specific on what you mean by "bad"?  --checking out the extension
12:17:09 <dafis> AmunRa: it's tedious to write
12:17:27 <lispy> AmunRa: You'll potentially waste time or create 'fragementation' in the garbage collector
12:17:51 <dafis> AmunRa: and pack needs a foreign call, so lots of packing short Strings isn't efficient
12:18:02 <ManateeLazyCat> AmunRa: OverloadedStrings
12:18:03 <dafis> and, as lispy said, memory fragmentation
12:18:25 <c_wraith> eh.  ByteString does everything possible to make foreign calls cheap.  Including that wacky inlinePerformIO stuff.
12:18:35 <ManateeLazyCat> AmunRa: Add "{-# LANGUAGE OverloadedStrings #-}" at top of .hs file.
12:18:39 <chrisdone> aw, man. just learned a lesson. wrote a load of javascript code without committing it. hide-region.el somehow managed to interfere such that revert-buffer reverted my code with all the hidden regions deleted. ended up having to search through my firefox cache. /me installs magit
12:18:43 <dafis> AmunRa: on the other hand, packing loong Strings is inefficient too
12:19:00 <dafis> c_wraith: cheap, but not free
12:19:06 <monochrom> why are you packing a lot of little strings? you may be doing it wrong.
12:19:13 <ManateeLazyCat> chrisdone: #emacs ?
12:20:16 <lispy> AmunRa: typically when you work with a bytestring you have loaded it from somewhere, such as B.readFile
12:20:38 <chrisdone> ManateeLazyCat: I was intentionally talking here, but sure, probably more suitable there
12:21:51 <ManateeLazyCat> chrisdone: Switch between Emacs and Firefox? :)
12:22:00 <AmunRa> monochrom, learning really.. I've written a couple of unix utilities just using [Char] Strings.. and the performance was miserable.. ByteString is much better.. although it seems quite silly that for any constants that I want to use in my code I need to create a String in the first place, and then pack it up.
12:22:03 <ManateeLazyCat> chrisdone: Or embedded Emacs in firefox?
12:22:55 <lispy> AmunRa: in that case, the overloaded strings should be perfect for you
12:22:56 <c_wraith> AmunRa, the OverloadedStrings extension packs them at runtime too.  It's just easier to write.
12:23:04 <ddarius> AmunRa: Through trickery, packing literal strings into ByteStrings doesn't require building a String.  It is all done at compile-time in effect.
12:23:50 <mornfall> c_wraith: But the packing can be optimized away, hopefully. :))
12:23:56 <chrisdone> ManateeLazyCat: :-)
12:24:00 <ManateeLazyCat> AmunRa: As many guys suggest, use {-# LANGUAGE OverloadedStrings #-} then you don't need pack
12:24:32 <monoidal> the magic is, "a" becomes then (IsString t) => t instead of String.
12:24:34 <c_wraith> Oh, are there RULEs that fire for packing constants?
12:24:51 <monoidal> and there are instances for String and ByteString
12:25:09 <c_wraith> The bytestring instance is in Data.ByteString.Char8, by the way.
12:25:22 <c_wraith> importing only Data.ByteString is insufficient.
12:27:31 <interferon> is it possible to do IO in a Template Haskell expansion?  for example, i might have a configuration file that my TH function should refer to in order to generate code
12:27:51 <ddarius> c_wraith: Yes, combined with the way GHC handles string literals regardless.
12:27:59 <monoidal> interferon: runIO
12:28:03 <mtnviewmark> cabal whizes: does the data-files section have to mention every file explicitly, or can it name a directory?
12:28:35 <lispy> mtnviewmark: I think it can use shell globs
12:28:53 <mtnviewmark> really? cool!
12:29:35 <interferon> monoidal: thanks
12:30:12 <mtnviewmark> oy - found it - actually, it is a highly limited form of shell glob
12:30:30 <mtnviewmark> stuff/* isn't allowed -- only stuff/*.ext
12:30:40 <mornfall> aavogt: (Btw. I can get combine that works for a fixed set of monotypes. That is fairly easy. I can't get a generic one, though...)
12:31:16 <lispy> mtnviewmark: huh, I wonder what the reason is
12:31:33 <mtnviewmark> "The reason for providing only a very limited form of wildcard is to concisely express the common case of a large number of related files of the same file type without making it too easy to accidentally include unwanted files."
12:31:45 <gwern> that's pretty narrow alright
12:31:58 <mtnviewmark> I'm being protected from myself ... which is probably a good thing....
12:32:09 <gwern> I mean, doesnt' that let in foo/*[A-9] and stuff very similar to *?
12:33:41 <mtnviewmark> no - see the manual http://haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html
12:36:26 <gwern> 'When matching a wildcard plus extension, a file's full extension must match exactly, so *.gz matches foo.gz  but not foo.tar.gz.'
12:36:29 <gwern> huh...
12:36:35 <gwern> and it's just *, no ? or []
12:36:42 <gwern> alright, I can't think of how to abuse that
12:36:52 <mtnviewmark> exactly
12:37:08 <mtnviewmark> s'okay - do I really care that my .cabal file will have a long list of files in it? no, not really
12:39:00 <c_wraith> I've learned to use find to format the list of files I want for easy copy & paste into cabal files.
12:45:59 * ManateeLazyCat Damnit, "Top level : Not in scope: `Data.List.reverse`....
12:46:20 <ManateeLazyCat> Sleep, tomorrow fix.
12:47:00 <monochrom> fix (sleep . tomorrow)
12:47:21 <monochrom> = procrastination :)
12:47:56 <chrisdone> tomorrow :: Freshness -> [Action] -> Day Tiredness
12:47:56 <chrisdone> sleep :: Tiredness -> Sleep Freshness
12:48:04 <ManateeLazyCat> monochrom: I got "Top level : Not in scope: `Data.List.reverse`...." when i do GHC.parseName, i'm sure something is wrong....
12:48:30 <ManateeLazyCat> monochrom: Maybe i need loadModule before GHC.parseName....
12:49:04 <ManateeLazyCat> monochrom: Whatever, need sleep, head is not clear now......
12:49:45 <new2haskell> hello, what is the use of the symbol $? 
12:50:07 <chrisdone> ManateeLazyCat: 睡不好觉，蝴蝶
12:50:14 <AmunRa> it's used to make your code prettier
12:50:26 <ManateeLazyCat> chrisdone:  tomorrow :: FinishMyOwnPluginLibray -> HotSwapGtk2hs. :)
12:50:33 <monoidal> new2haskell, it's function application: f $ x = f x but binds less tightly
12:50:44 <AmunRa> Anything after a $ is as if it's wrapped in parentheses
12:50:45 <chrisdone> new2haskell: two uses: (1) as a replacement for writing '(' and ')', and (2) for: map ($2) [(*2),(+5)] => [4,7]
12:50:53 <Gracenotes> @djinn (x -> Maybe y) -> (x, z) -> Maybe (y, z)
12:50:53 <lambdabot> f a (b, c) =
12:50:53 <lambdabot>     case a b of
12:50:53 <lambdabot>     Nothing -> Nothing
12:50:53 <lambdabot>     Just d -> Just (d, c)
12:50:54 <monoidal> new2haskell: for example sqrt 1 + 3 is 4, and sqrt $ 1 + 3 is 2.
12:51:05 <monochrom> $ is the symbol that makes money in haskell :)
12:51:06 <ManateeLazyCat> chrisdone: Now i'm fix re-export problem when dynamic-linking
12:51:11 <new2haskell> thanks everyone
12:51:19 <ManateeLazyCat> chrisdone: Have any hint?
12:51:24 <AmunRa> f1 $ f2 42            is the same as                   f1 (f2 42)
12:51:33 <chrisdone> ManateeLazyCat: nope, I haven't been following the conversation
12:51:50 <ManateeLazyCat> chrisdone: Okay, i need sleep.
12:51:59 <chrisdone> ManateeLazyCat: 睡不好觉
12:52:23 <monochrom> "hot swap gtk2hs" sounds scary :)
12:52:23 <chrisdone> new2haskell: you on tryhaskell?
12:52:45 <ManateeLazyCat> chrisdone: 睡不好觉 mean "sleep bad"
12:52:49 <new2haskell> chrisdone: yes, i did. it's very useful
12:53:00 <ManateeLazyCat> chrisdone: "Sleep well" mean 晚安
12:53:00 <chrisdone> ManateeLazyCat: :D
12:53:24 <new2haskell> monoidal: what do you mean by "bind less tightly"?
12:53:58 <monoidal> new2haskell: less tightly than normal function application (which is denoted by separating things)
12:53:58 <ManateeLazyCat> monochrom: Pretty easy... well ... i need add AST value type-check feature tomorrow
12:54:28 <monoidal> new2haskell: in an expression like f x + g y z + h 3 5, parentheses are put like: (f x) + (g y z) + (h 3 5)
12:54:49 <monoidal> new2haskell: since function composition binds stronger than any operator
12:55:27 <monoidal> new2haskell: *function application. But if you use ($), then you can do function application without using brackets: sin $ 1 + 2 will be sin $ (1 + 2).
12:55:55 <ManateeLazyCat> monochrom: I can use GHC-API replace hs-plugins code, and much cleaner.....
12:55:57 <monoidal> instead of sin 1 + 2, which is (sin 1) + 2
12:56:28 <monoidal> new2haskell: or, instead of sin (cos (log 5)), you can write sin $ cos $ log 5
12:56:28 <chrisdone> new2haskell: operators have a binding value, 1 to 9. 9 is tight, 0 is loose. ($)'s binding value is 0. (*)'s is 7. so a $ b * c == a $ (b * c). if (#)'s is 3, what is the precedence of this? a # b * c
12:56:29 <ManateeLazyCat> My bed miss me, bye all, night. :)
12:57:15 <ManateeLazyCat> chrisdone: "Good night/Sleep well" ==> 晚安 
12:57:26 <chrisdone> ManateeLazyCat: 晚安 ^_^
12:57:45 <new2haskell> chrisdone: a # (b * c) ?
12:57:57 <chrisdone> new2haskell: that's right. what if it was 8?
12:59:06 <new2haskell> chrisdone: (a#b) *c
12:59:16 <ManateeLazyCat> chrisdone: 哪天有空我教你中文， 当你第一次对我说 “睡不好觉”， 真的把我笑死的. ;) 
12:59:17 <chrisdone> new2haskell: perfect! you get it! :-)
12:59:29 <new2haskell> chrisdone: thanks 
12:59:55 <new2haskell> monoidal: thanks
13:00:06 * ManateeLazyCat 大家晚安! (Good night, guys). :)
13:00:30 <chrisdone> ManateeLazyCat: hehe. you'll never teach me chinese! :-P
13:02:26 <chrisdone> monoidal: socratic questioning++
13:34:49 <notabel> I am about to set up a virtualbox image for doing GHC hacking (ie trying to work on the compiler itself), can anyone recommend a linux distro that plays nice with the GHC build environment?  My main OS is 64-bit OS X, so I'm used to library compatibility nightmares.
13:36:12 <Veinor> I heard ubuntu does.
13:40:48 <ClaudiusMaximus> http://claudiusmaximus.goto10.org/g/hp2pretty/hp2pretty_test_003_hp2pretty.png << my code || hp2ps >> http://claudiusmaximus.goto10.org/g/hp2pretty/hp2pretty_test_003_hp2ps.png
13:41:22 <ClaudiusMaximus> my code is lacking in features so far, though
13:43:11 <Igloo> ClaudiusMaximus: Great stuff! Do you know hp2ps can do colour with -c, BTW?
13:43:39 <ClaudiusMaximus> Igloo: yes, so i suppose it isn't a fair comparison
13:43:57 <ClaudiusMaximus> Igloo: thanks
13:44:10 <Igloo> ClaudiusMaximus: Also, have you seen http://hackage.haskell.org/trac/ghc/ticket/3024 ?
13:44:33 <ClaudiusMaximus> Igloo: i believe i have, if that's the 18month old one about rewriting hp2ps in haskell?
13:44:45 <Igloo> Yup
13:45:05 <ClaudiusMaximus> Igloo: which is what i'm doing :) - but starting from scratch, too lazy to find where the hp2ps source code is
13:45:10 <drhodes> notabel: I built ghc HEAD yesterday without a hitch on ubuntu 10.4, fwiw
13:45:16 <Igloo> Cool
13:45:27 <notabel> drhodes: thanks.  that's enough for me
13:46:33 <ClaudiusMaximus> Igloo: and my code is horrible at the moment, lots of "([a,b,c,d], es) = splitAt 4 . lines" type things, but the main program is better (main = interact $ print . pretty . process . parse )
13:47:52 <McManiaC> how do you compare on *type* equality, rather than just "==" ?
13:48:21 <ClaudiusMaximus> Igloo: i probably should attach a note to the trac ticket when i get around to pushing the code somewhere - it's pure Haskell with no libraries so far (but i'm looking at maybe wumpus-core for output)
13:48:39 <mauke> McManiaC: huh?
13:49:06 <McManiaC> mauke: something like "myEq :: a -> b -> Bool" and if a == b then True else False
13:49:06 <AnAdorableNick> Try to compile it and see whether it type checks
13:49:14 <McManiaC> or no.... hm
13:49:28 <McManiaC> constructors of one type should be equal
13:49:45 <McManiaC> "Just 5 `myEq` Just 10" == True, but "Just 5 `myEq` Nothing" == False
13:49:53 <Daenyth> What's the <<foo>>= notation I see in some places?
13:50:11 <dafis> > Just 5 == Nothing
13:50:12 <lambdabot>   False
13:50:13 <mauke> McManiaC: what about Just 5 `myEq` "5"?
13:50:25 <McManiaC> false
13:50:39 <mauke> ok, I think that requires Data.Data
13:50:42 <ClaudiusMaximus> > let { haveSameType :: a -> a -> () ; haveSameType _ _ = () } in haveSameType (Just 5) (Nothing)
13:50:42 <lambdabot>   ()
13:50:53 <ClaudiusMaximus> > let { haveSameType :: a -> a -> () ; haveSameType _ _ = () } in haveSameType (Just 5) (Just "foo")
13:50:54 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
13:50:54 <lambdabot>    arising from the literal ...
13:51:14 <drhodes> MyEq (Just _) (Just _) = True   ?
13:51:14 <ClaudiusMaximus> :t (>>=)
13:51:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:51:25 <ClaudiusMaximus> :t (<<)
13:51:26 <lambdabot> Not in scope: `<<'
13:52:10 <Veinor> Daenyth: where do you see it?
13:52:29 <ClaudiusMaximus> Daenyth: so part of your question could be answered by >>= ("bind") which is monadic plumbing
13:52:37 <AnAdorableNick> Daenyth: It depends on the context.
13:52:42 <AnAdorableNick> Daenyth: Which modules are being used?
13:52:47 <Daenyth> Veinor: some wikis and stuff with examples
13:52:51 <Veinor> link?
13:52:56 <Daenyth> http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)
13:52:59 <AnAdorableNick> Daenyth: Is (<<) defined in the sourec?
13:53:11 <aristid> @src (<<)
13:53:11 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:53:18 <aristid> hmm
13:53:25 <mauke> Daenyth: that's not part of the source
13:53:30 <Daenyth> ah, just a header?
13:53:34 <Veinor> looks like it yeah
13:53:37 <mauke> ask the wiki
13:53:49 <dafis> Daenyth: wiki markup fail
13:53:50 <Daenyth> I wondered since I've seen >>= before, didn't know if there was something I was missing :P
13:54:08 <aristid> you could use (<*) instead of (<<) :D
13:54:14 <Daenyth> :P
13:54:42 <dafis> Daenyth: probably <<foo>> is a markup, and the should've put a space before the =
13:54:58 <Daenyth> nah, it's like that all over the place 
13:55:02 * Daenyth shrugs
13:55:09 <Daenyth> it's not haskell, that's all I need to know at the moment :P
14:01:09 <interferon> is there a monad that lets you write statically-typed javascript and emits javascript text to be sent to be the browser?
14:01:44 <monadic_kid> http://github.com/snkkid/jhc_wii_template
14:13:10 <Oejet> Hi, I have some colour images in the PNG-format (8-bit/color RGBA), that I would like to read pixels from (e.g. pixel::Image->Coordinate->Colour), but I am having some difficulties.
14:14:12 <obfuscated> Hello, I've done 'import qualified Text.XHtml.Strict as XHtml', but I want to import '<<' in the global namespace, how can I do that?
14:15:30 <mauke> import Text.XHtml.Strict ((<<))
14:15:45 <dafis> obfuscated: also import Text.XHtml.Strict ((<<))
14:16:26 <obfuscated> dafis: thanks, are there some docs about that?
14:16:45 <dafis> Oejet: is there a chance that someone not knowing the PNG format can help you?
14:17:32 <dafis> obfuscated: basically every tutorial or book should cover import syntax at some point
14:18:03 <dafis> obfuscated: the authoritative source is of course the language report
14:18:44 <dafis> obfuscated: http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3
14:19:05 <obfuscated> yes, I knew the 'import blabla (funcName) syntax', but for special characters there are the additional '()'
14:19:41 <dafis> obfuscated: like for type signatures; (&&) :: Bool -> Bool -> Bool
14:19:55 <dafis> (and prefix applications of operators)
14:20:56 <obfuscated> '(&&) a b' is ok? that is new for me, like almost everything in haskell:)
14:21:24 <aristid> > (&&) True False
14:21:25 <lambdabot>   False
14:21:45 <aristid> > (&&)
14:21:46 <lambdabot>   Overlapping instances for GHC.Show.Show
14:21:46 <lambdabot>                              (GHC.B...
14:21:48 <aristid> hmm
14:22:00 <aristid> didn't lambdabot use to have a show instance for functions?
14:22:05 <notabel> > :t (&&)
14:22:05 <lambdabot>   <no location info>: parse error on input `:'
14:22:07 <mauke> still does
14:22:12 <mauke> look at the error message
14:22:28 <aristid> ok it's a bit incomplete
14:22:35 <proc> hm
14:22:35 <aristid> :t (&&)
14:22:36 <lambdabot> Bool -> Bool -> Bool
14:23:39 <Oejet> dafis: Sure, it is just small stumbling blocks: stb-image is a bit confusing, pngload cannot be imported (for some reason), Codec-Image-DevIL gives an error when loading the .so, there are libraries from ppm(write-only), pgm(grey-scale), bmp, but not pnm.
14:24:48 <dafis> Oejet: I can't promise anything, but what's the error message?
14:26:34 <Oejet> 1) Could not find module `Codec.Image.PNG'. 2) Loading package Codec-Image-DevIL-0.2.3 ... can't load .so/.DLL for: pthread (/usr/lib64/libpthread.so: invalid ELF header)
14:27:58 <Oejet> dafis: Oh, and I forgot; GD is almost usable...it just lacks a function for reading in addition to the one for writing pixels.
14:29:36 <mtnviewmark> if I have a cascade of if p1 then s1 else (if p2 then s2 else (....)) I instead use guards on a function
14:29:47 <mtnviewmark> but what if the conditions are all in a Monad?
14:30:16 <Peaker> mtnviewmark, You mean you have a bunch of (m Bool)s ?
14:30:21 <mtnviewmark> I have   do { b1 <- p1; if b1 then s1 else do { b2 <- p2; if b2 then s2 else do { ... }  } }
14:30:25 <dafis> mtnviewmark: write a choice combinator?
14:30:27 <mtnviewmark> right
14:30:45 <mtnviewmark> is there a standard one?
14:30:57 <Peaker> mtnviewmark, [(m Bool, m a)] -> m a ?
14:31:15 <dafis> mtnviewmark: I don't know of one
14:31:24 <Peaker> @type liftM (snd . head) $ filterM fst
14:31:25 <lambdabot>     Couldn't match expected type `(a, b)'
14:31:25 <lambdabot>            against inferred type `[([Bool], b1)]'
14:31:25 <lambdabot>       Expected type: [([Bool], b1)] -> [(a, b)]
14:31:32 <Peaker> @type liftM (snd . head) . filterM fst
14:31:33 <lambdabot> forall b (m :: * -> *). (Monad m) => [(m Bool, b)] -> m b
14:31:35 <mtnviewmark> I did that.     pick :: a -> [(a -> IO Bool, a -> IO b)] -> IO b
14:31:52 <Peaker> mtnviewmark, Why the (a->) everywhere?
14:32:02 <Peaker> mtnviewmark, Just apply the (a->) independently
14:32:17 <mtnviewmark> so I don't have to keep reiterating the thing being tested in each predicate and each result
14:32:34 <Peaker> @type \x -> map (($x)***($x))
14:32:34 <lambdabot> forall a b b1. a -> [(a -> b, a -> b1)] -> [(b, b1)]
14:32:43 <mtnviewmark> oh, you Arrow people!
14:32:49 <mtnviewmark> :-)
14:32:49 <aristid> > (+)
14:32:50 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
14:32:50 <lambdabot>    arising from a use...
14:32:57 <aristid> > id
14:32:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:32:58 <lambdabot>    arising from a use of `...
14:33:23 <Peaker> mtnviewmark, You shouldn't mix the combinator that feeds the (a->) with the combinator that does the choice
14:33:36 <Peaker> mtnviewmark, since they are independently implementable and composable
14:33:47 <mtnviewmark> okay - but I guess the real answer is "no, there isn't an idiomatic way to do this with existing combinators"
14:33:58 <Peaker> mtnviewmark, Maybe not
14:34:07 <mtnviewmark> okay - 
14:34:08 <Peaker> @type liftM (snd . head) . filterM fst
14:34:09 <lambdabot> forall b (m :: * -> *). (Monad m) => [(m Bool, b)] -> m b
14:34:11 <Peaker> I'd use this ^
14:34:26 <Peaker> maybe use listToMaybe instead of head for safety
14:34:29 <mtnviewmark> my code is on the cusp of readability -- three condition/result pairs and a default result
14:34:38 <Peaker> @type liftM (fmap snd . listToMaybe) . filterM fst
14:34:39 <lambdabot> forall b (m :: * -> *). (Monad m) => [(m Bool, b)] -> m (Maybe b)
14:35:03 <Peaker> mtnviewmark, the beauty of Haskell is that even if you find this kind of point-free thing hard, you can just look at the type and it tells the story
14:35:21 <Peaker> I used to find it hard -- but look at how I throw point-free code out freely now :)
14:35:38 <McManiaC> what error is that? http://npaste.de/e2/
14:35:49 <McManiaC> what is a signature context?
14:35:56 <monochrom> People underestimate the necessity of educational level.
14:36:01 <dafis> Oejet: no idea about the can't load .so/.dll thing, sorry. what does ghc-pkg list pngload say?
14:36:27 <mtnviewmark> actually - I'm quite fond of point-free in my code as well
14:36:29 <Peaker> monochrom, you mean about learning how to use points-free?
14:36:38 <mtnviewmark> though the project I'm working on doesn't tend to use it alot
14:36:49 <monochrom> not particularly point-free. generally any upgrade of one's brain.
14:36:55 <mtnviewmark> so I am trying to sort of stay within the style guidelines of the original code...
14:37:11 <Peaker> Brain upgrade complete! Not enough Minerals
14:38:37 <dafis> McManiaC: the context is (as you probably know) the part before the '=>' in a type signature; for some reason, the error message spells out the 'signature' here
14:39:36 <monochrom> there is much contradiction between people's "this is too advanced for me to care" and the very same people's "I'm aspiring to be distinguished from the crowd"
14:40:03 <monochrom> If you don't go way more advanced, you aren't distinguished.
14:40:10 <Peaker> monochrom, Dijkstra said people blame him that his methods will take a lot of education, will make amateurs unable to use it. He said education is his profession so he has no problem with that
14:40:50 <fryguybob> @pl \a b -> f (g a) (g b)
14:40:50 <lambdabot> (. g) . f . g
14:41:21 <monochrom> yeah, "a lot of education" should be good news rather than bad news. presumably this is why everyone craze over going to college or something!
14:41:28 <benmachine> dijkstra was basically a troll though right
14:41:35 <Oejet> dafis: "ghc-pkg list pngload" says "... .ghc/x86_64-linux-6.12.1/package.conf.d     pngload-0.1".
14:41:46 <monochrom> dijkstra was not a troll and will never be
14:42:24 <benmachine> will never be?
14:42:34 <dafis> Oejet: so it's there, but GHC can't find it. did you forget --make ?
14:42:41 <monochrom> because he's dead :)
14:42:57 <monochrom> "hi I come back from my grave to troll you" ? :)
14:43:14 <Oejet> dafis: I build it with "cabal install pngload".
14:43:36 <benmachine> monochrom: I can't think of a better reason!
14:43:42 <benmachine> well, apart from like, all of them.
14:44:07 <dafis> Oejet: I meant the compilation when GHC said can't find Codec.Imag.PNG
14:44:21 <Oejet> dafis: And ":m +Codec.Image.PNG" does not work.
14:44:51 <dafis> Oejet: hrmph; ghc-pkg check
14:45:51 <Oejet> dafis: ghc --make could not find the module either. ghc-pkg check gives no output and returns 0.
14:46:14 <dafis> Oejet: ghc-pkg describe pngload
14:47:47 <Oejet> name: pngload...exposed: True \n exposed-modules: Codec.Image.PNG...
14:49:38 <dafis> Oejet: very strange
14:51:31 <dafis> Oejet: okay, :m +Codec.Image.PNG works here
14:52:33 <dafis> Oejet: so something is borked with your install; I suggest cabal install --reinstall pngload
14:53:39 <Oejet> dafis: This gives the same error for me still.
14:55:00 <dafis> Oejet: I've run out of ideas for the time being
14:57:13 <Oejet> dafis: Me too. Thank you for showing me those diagnostic commands.
14:57:38 <dafis> Oejet: welcome
15:06:29 <cydergoth> Hi all - nother quick question
15:06:43 <Veinor> ?
15:06:54 <cydergoth> In some C code (GTS.h) there are some data structures which are mutually referential
15:07:20 <cydergoth> So Surface points to Face, and Face points to Surface. Any Face can be in zero or more Surfaces, and any Surface can have zero or more Faces
15:07:50 <cydergoth> So if I use a update on Face, how would I update  the (immutable) Haskell bindings graph
15:08:09 <cydergoth> So that all the surfaces which refer to it now refer to the new binding with the additional updates?
15:08:45 <cydergoth> 'cos If I understand correctly, the update to Face will return a new binding to a new Face with the update applied.
15:10:12 <cydergoth> In scheme I'd use the impure set! to modify the state in-situ, but that isn't possible in a pure language correct?
15:12:08 <aristid> the preference would be to avoid it, but there are methods to do mutation
15:12:39 <cydergoth> aristid: So avoid it by using an extra layer of indirection?
15:13:04 <aristid> not sure
15:13:23 <aristid> i don't know your problem well
15:14:03 <stulli> Wouldn't the pure functional approach be to create a new graph with every update? (not a haskell guru here)
15:14:32 <cydergoth> It is basically the 'sea of mutually referential objects' problem which in Scheme or Java you can handle by just updating the state of one node in the graph
15:14:52 <cydergoth> I read the Haskell approach as Stulli says - you have to clone the entire graph
15:16:02 <cydergoth> So the question them becomes how do you ensure all the bindings are consistent and the state moves forward linearly in time
15:16:23 <aristid> stulli: well there's also this: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Monad-ST.html
15:16:29 <ddarius> There are four solutions: 1) copy the whole thing, 2) restructure so you don't have mutual dependence, 3) add an indirection so you only have update a label, 4) use mutation.
15:16:39 <cydergoth> especially as many of the algorithms will involve multiple threads updating the graph)
15:17:41 <cydergoth> ddarius: thx, that's what I thought. Is 1 the approach taken by the FGL?
15:17:54 <ddarius> cydergoth: Heck no.  1 is usually the approach to avoid.
15:18:22 <ddarius> I believe FGL's approach is 2.  Many other graph libraries use approach 3.
15:18:59 <cydergoth> ddarius: So this is where the 'label' part of FGL comes in?
15:19:15 <ddarius> No, this is where the "inductive" part of FGL comes in.
15:19:33 <hpc> ddarius: what's the issue with 1? just memory latency?
15:19:46 <ddarius> hpc: Time, memory, code complexity, probably others.
15:20:07 <hpc> because for my game engine, i am using copying to make multithreading easy
15:20:21 <ddarius> If the thing is small, copying can be fine.
15:20:31 <aristid> or if the alternatives are worse
15:20:48 <ddarius> But you don't want to copy a 1000-node graph just because you changed the color of one of the nodes.
15:21:22 <cydergoth> hpc: I have a similar issue in that I'm doing a graphical simulation of a CNC Mill executing a GCode program
15:21:42 <cydergoth> So the graph can have a very large amount of node/face/surface data in it
15:21:59 <Peaker> The "default" keyword is specific to the Num class??
15:22:15 <hpc> default is a keyword?
15:22:17 <ddarius> Peaker: No, but it is pretty specialized.
15:22:18 <chrisdone> what's the 'default' keyword?
15:22:19 <ddarius> hpc: Yes.
15:22:21 <cydergoth> ddarius: So would FGL be a good choice to delegate the management of my nodes to?
15:22:26 <Peaker> ddarius, I want to make a default instance for a class
15:22:33 <ddarius> cydergoth: Perhaps, perhaps not.
15:22:41 <Peaker> ddarius, to disambiguate it when it's ambiguous. It's a phantom type I don't care if it's ambiguous
15:22:41 <chrisdone> @google haskell 98 report default
15:22:42 <lambdabot> http://www.haskell.org/onlinereport/decls.html
15:22:42 <lambdabot> Title: The Haskell 98 Report: Declarations
15:22:52 <chrisdone> oh, cute
15:22:58 <cydergoth> ddarius: Go not to the elves for advice for they will say both yeah and nay.
15:22:59 <ddarius> Peaker: Just assume default isn't in the language.
15:23:11 <Peaker> ddarius, :-(
15:23:14 <chrisdone> http://www.haskell.org/onlinereport/decls.html#overloading
15:23:24 <Peaker> ddarius, It seems the syntax is "default (Integer, Double)" -- what the hell could that do?
15:23:38 <Peaker> if it isn't specific to Num?
15:24:20 <ddarius> Well, it does require the types to be a subclass of Num.
15:24:45 <ddarius> But it only works with "standard" classes.  It's a mostly pointless feature that should be ignored.
15:24:53 <ddarius> GHC extends it somewhat though.
15:25:29 <pesco> oh god, this place is full.
15:25:33 <pesco> hi, #haskell
15:25:54 <c_wraith> hey pesco :)
15:26:01 <Peaker> @index asTypeOf
15:26:01 <lambdabot> Prelude
15:26:12 <hpc> @src asTypeOf
15:26:12 <lambdabot> asTypeOf = const
15:26:20 <hpc> oh right
15:26:23 <Peaker> ddarius, weird that they didn't have it: "default Class (Types)" or such
15:26:34 <Peaker> ddarius, they had foresight in such difficult cases, and 0 foresight in such an easy one?
15:26:55 <cydergoth> ddarius: So if I look in the FGL docs, the insert node function has this signature : insNode :: DynGraph gr => LNode a -> gr a b -> gr a b
15:27:11 <cydergoth> Which looks like it is returning a new instance of the graph object; but it doesn't do a full copy right?
15:27:34 <benmachine> Peaker: I think default was a one-time hack because polymorphic numeric constants tended to be too polymorphic too often
15:27:51 <cydergoth> It also looks like it uses homogenous nodes? as the graph type matches the node type? (a)?
15:29:39 <Peaker> benmachine, might as well specify the class then?
15:30:13 <benmachine> Peaker: better still, bin the hack :)
15:30:52 <Peaker> benmachine, for my phantom type, being able to specify default instances could be a good thing, I think
15:31:09 <Peaker> Now I need scoped type vars or horrible tricks to avoid ambiguous types :(
15:31:10 <benmachine> Peaker: have you considered a type-constrained id?
15:31:32 <Peaker> benmachine, Ah, that makes a simple trick rather than horrible one :)
15:31:42 <benmachine> :)
15:32:01 <qwebirc53883> @pl \a (b, c) -> a + b - c
15:32:01 <lambdabot> (`ap` snd) . (. fst) . ((-) .) . (+)
15:32:17 <qwebirc53883> Ouch.
15:32:26 <chrisdone> heh
15:32:31 <Peaker> benmachine, no scoped type vars, but a default would still be simpler :)
15:33:05 <benmachine> qwebirc53883: there are some things pl doesn't know about
15:33:41 <hpc> :t curry
15:33:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:33:48 <benmachine> @pl \a (b, c) -> b - c + a
15:33:49 <lambdabot> (`ap` snd) . (. fst) . flip (flip . ((+) .) . (-))
15:33:52 <chrisdone> :t liftM2 subtract fst snd
15:33:53 <lambdabot> forall b. (Num b) => (b, b) -> b
15:33:53 <benmachine> hrm
15:34:10 <dafis_> > (. uncurry (-)) . (+) 4 (9,2)
15:34:10 <hpc> :t uncurry
15:34:11 <lambdabot>   Overlapping instances for GHC.Show.Show ((a, a) -> b)
15:34:11 <lambdabot>    arising from a use...
15:34:11 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:34:31 <dafis_> > ((. uncurry (-)) . (+)) 4 (9,2)
15:34:32 <lambdabot>   11
15:35:44 <dafis_> @pl \a (b, c) -> a + (b - c)
15:35:44 <lambdabot> (`ap` snd) . (. fst) . ((-) .) . (+)
15:37:50 <Veinor> @pl \a b c -> a + (b - c)
15:37:50 <lambdabot> ((-) .) . (+)
15:38:19 <chrisdone> > flip ((+) . uncurry (-)) 4 (9,2)
15:38:20 <lambdabot>   11
15:44:00 <dibblego> is there a list of things included in the Haskell Platform? (and is leksah included?)
15:44:39 <Botje> wow. the front page of the haskell platform is really shiny
15:44:41 <Botje> good job!
15:44:46 <wto> dibblego: http://hackage.haskell.org/platform/contents.html
15:44:51 <wto> it seems leksah is not included
15:45:00 <dibblego> wto, thanks
15:45:41 <randomwords> How to people tend to reconcile using a service such as github and also hackage? Some sort of git2darcs tool?
15:46:00 <chrisdone> > uncurry (flip (,)) (1,2)
15:46:01 <lambdabot>   (2,1)
15:46:18 <chrisdone> randomwords: hackage doesn't require darcs, you know?
15:46:23 <Botje> you can just upload tarballs to hackage
15:46:30 <Botje> which git archive can do nicely
15:46:55 <chrisdone> cabal sdist
15:46:56 <chrisdone> cabal upload dist/mypackage-1.0.tar.gz
15:46:56 <chrisdone> done
15:46:56 <randomwords> chrisdone: No, but it is convenient
15:47:20 <randomwords> chrisdone: Unless I'm being very stupid (quite likely)
15:47:21 <chrisdone> that's how i reconcile git and hackage
15:47:35 <chrisdone> is cabal sdist/cabal upload inconvenient?
15:47:36 <Igloo> hackage has no darcs-specific support at all, AFAIK
15:47:54 <randomwords> Then yes, I am being stupid
15:47:56 <randomwords> wonderful
15:48:33 <randomwords> let me rephrase. If I have an existing darcs repo, is there a convenient way to migrate it to git (hopefully maintaining history etc.)
15:50:49 <c_wraith> There isn't really a good way.
15:51:07 <benmachine> I believe there was a tool once, but I recall it not working for me
15:51:07 <c_wraith> there are some tools like tailor that try, but it's a troublesome process at best
15:52:01 <randomwords> Could just tar up the darcs stuff and start a fresh repo, hope I don't need to refer to it that often
15:52:21 <c_wraith> that's the easiest, by far
15:52:26 <c_wraith> and it usually works out ok
15:53:21 <benmachine> randomwords: google says http://www.ohloh.net/p/darcs-to-git (for example)
15:54:29 <randomwords> Thanks all
15:54:43 <bremner> randomwords: you  #git
15:54:51 <bremner> bloody hell.
15:55:07 <bremner> you might ask in #git, I meant
15:55:29 <randomwords> Haha, I prefer "you #git"
15:56:22 <datwinkdaddy> randomwords: lambdabot says http://www.sanityinc.com/articles/converting-darcs-repositories-to-git
15:57:18 <askhader> If I want to define a data type that has two parameters of the same type, does I do   data Type a a = Type a a   ?
15:58:21 <c_wraith> askhader: data D a = D a a
15:58:35 <c_wraith> askhader, It only has one type variable, it just uses it twice
15:58:49 <askhader> where 'd' is the type?
15:58:51 <datwinkdaddy> askhader: data D a = T (a, a)
15:59:01 <askhader> sor 'D' 
15:59:06 <c_wraith> yes
15:59:06 <datwinkdaddy> D is the type, T is in type constructor.
15:59:09 <hpc> askhader: with better names, data Type a = Constructor a a
15:59:18 <askhader> thank youi
15:59:43 <askhader> I guess if I want them to be the same time I specify (Eq) ?
16:00:32 <datwinkdaddy> askhader: No, just using the variable twice is fine.
16:01:00 <datwinkdaddy> askhader: One type variable can't be unified with more than one type per instantiation.
16:01:09 <datwinkdaddy> :t asTypeOf
16:01:10 <lambdabot> forall a. a -> a -> a
16:01:33 <datwinkdaddy> askhader: There's no Eq a constraint there, but all 3 instances of "a" have to be the same type.
16:01:55 <askhader> Alright then I'm just a 'little' bit confused, what 'Type' do I specify?
16:02:23 <datwinkdaddy> > 'A' `asTypeOf` (0 :: Word)
16:02:24 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:02:24 <lambdabot>         against inferred type...
16:02:30 <hpc> whatever describes your data declaration best
16:02:48 <datwinkdaddy> > (fromIntegral 'A') `asTypeOf` (0 :: Word)
16:02:48 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
16:02:49 <lambdabot>    arising from a use of...
16:03:12 <hpc> > fromEnum 'A'
16:03:13 <lambdabot>   65
16:03:21 <datwinkdaddy> Well, I'm an idiot, but something like that.
16:03:27 <hpc> heh
16:03:33 <askhader> lol
16:04:08 <datwinkdaddy> @src State
16:04:08 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:04:12 <datwinkdaddy> @src ST
16:04:12 <lambdabot> newtype ST s a = ST (STRep s a)
16:04:56 <hpc> newtype State s a = State {runState :: s -> (a, s)}
16:05:17 <datwinkdaddy> @src STRep
16:05:17 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
16:05:19 <hpc> (from memory, but that's the gist of it)
16:05:34 <datwinkdaddy> askhader: That's two uses of the "s" type variable in the defintiion on STRep.
16:05:56 <datwinkdaddy> askhader: "STRep" is the name of the type, so you use it in type signatures etc.
16:06:20 <hpc> that's a bit of an ugly example, why not []?
16:06:22 <hpc> @src []
16:06:23 <lambdabot> data [] a = [] | a : [a]
16:06:34 <askhader> datwinkdaddy: Ah
16:07:04 <datwinkdaddy> askhader: The constructor is what you use in code when creating/"converting" to that type explicitly.
16:07:10 <datwinkdaddy> > Maybe 3
16:07:11 <lambdabot>   Not in scope: data constructor `Maybe'
16:07:13 <datwinkdaddy> > Just 3
16:07:14 <lambdabot>   Just 3
16:07:15 <hpc> the constructor (:) builds a list from a head and a tail, with the head being an element of one type, and the tail being the rest of the list
16:07:23 <askhader> Acknowledged
16:07:25 <hpc> > 1:[2]
16:07:26 <lambdabot>   [1,2]
16:07:35 <Veinor> > 1:2:[]
16:07:35 <lambdabot>   [1,2]
16:07:50 <hpc> > 1:[[x]]
16:07:51 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
16:07:51 <lambdabot>    arising from the lite...
16:08:04 <Veinor> > 1:[[1]]
16:08:05 <lambdabot>   No instance for (GHC.Num.Num [t])
16:08:05 <lambdabot>    arising from a use of `e_111' at <inte...
16:08:23 <hpc> :t (1:2:[]
16:08:24 <lambdabot> parse error (possibly incorrect indentation)
16:08:25 <hpc> :t (1:2:[])
16:08:26 <lambdabot> forall t. (Num t) => [t]
16:09:00 <askhader> And for polymorphic data types?
16:09:23 <hpc> the (Num t) => means that whatever t is, it has to be a number of some kind
16:09:31 <hpc> then [t] is the actual type
16:09:42 <hpc> which is a list of some sort of number
16:09:44 <askhader> I mean, my problem includes essentially polymorphic data types.
16:09:48 <hpc> ah
16:10:10 <hpc> homogeneous?
16:10:21 <askhader> data Quadruple a a b b = Quadruple a a b b
16:10:41 <hpc> data Quadruple a b = Quadruple a a b b
16:10:45 <hpc> *
16:11:04 <askhader> Oh.
16:11:21 <hpc> there's the data constructor, which is the right hand side
16:11:29 <hpc> Quadruple a a b b
16:11:47 <hpc> so Quadruple :: a -> a -> b -> b -> Quadruple a b
16:12:06 <hpc> it takes two a's, two b's, and makes a quadruple out of them
16:12:14 <hpc> the left hand side is the type constructor
16:12:18 <askhader> so the paramaters o nthe left side of the data definition (a and b) just specify hopw many 'types' it can take?
16:12:21 <askhader> Alright I see.
16:12:25 <askhader> I got it now
16:12:27 <hpc> yeah
16:12:32 <askhader> I described it terribly
16:12:49 <askhader> Aw man, Haskell is such a mind blowing language.
16:12:57 <hpc> it gets easier
16:13:02 <hpc> then it gets really hard
16:13:02 <askhader> I didn't mean not-easy.
16:13:15 <hpc> then your entire life will be like the last half hour of 2001
16:13:17 <askhader> I was introduced to functional programming with racket/plt-scheme/lisp
16:13:22 <askhader> hahahahaahah
16:13:50 <hpc> actually, Maybe is a good example
16:13:58 <hpc> data Maybe a = Nothing | Just a
16:14:29 <hpc> a (Maybe Int), for example, can be either Nothing, or Just an Int
16:14:36 <hpc> :t Just 5
16:14:36 <lambdabot> forall t. (Num t) => Maybe t
16:14:42 <hpc> :t Nothing
16:14:42 <lambdabot> forall a. Maybe a
16:15:18 <hpc> so you put a thing inside the box on the right, and the type of the thing goes into the right box
16:15:28 <askhader> I see.
16:15:42 <hpc> put a bunch of text in the box, and it becomes Maybe String
16:16:30 <hpc> it helps to play around with it in a ghci/lambdabot
16:17:02 <datwinkdaddy> Wierd.  I think I actually "got" Applicative last night.  I was writing some code and "<$>" popped into my head in an appropriate place.
16:17:15 <hpc> <3 applicative
16:17:27 <hpc> <$> is my bread and butter
16:17:38 <hpc> (yes i know, functor, etc)
16:17:48 <jmcarthur> i love applicative
16:18:03 <jmcarthur> <*>, <*, and *> are awesome
16:18:13 <jmcarthur> alternative is also pretty cool
16:18:19 <hpc> it's like monad without the awful tutorials
16:18:32 <hpc> i just "got" Arrow this afternoon
16:18:38 <datwinkdaddy> For lambdabot is there a "@"-command that is like ":t"?
16:18:42 <jmcarthur> i just wish we had a functor version of applicative/monadplus instead of an applicative and monad version
16:18:42 <hpc> @type
16:18:43 <lambdabot> <no location info>: not an expression: `'
16:18:49 <datwinkdaddy> It doesn't like :t in privmsgs.
16:18:52 <Saizan> @type ()
16:18:52 <lambdabot> ()
16:19:21 <hpc> the type signatures were throwing me off, but cale's pictures in the wikibook were excellent
16:19:24 <hpc> :t (&&&)
16:19:25 <jmcarthur> the monadplus variant at least has some different laws
16:19:25 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:19:44 <jmcarthur> but i can't think of anything that would need to be different between alternative and a functor equivalent of it
16:20:49 <hpc> also, Eval is the coolest monad ever
16:21:00 <jmcarthur> i am not familiar with that monad
16:21:01 <Saizan> Eval = ?
16:21:03 <chrisdone> applicative's a subset of monad, right?
16:21:04 <hpc> data Eval a = Seq a | Lazy a | Par a
16:21:12 <jmcarthur> chrisdone: a superclass
16:21:14 <shachaf> chrisdone: Superset?
16:21:21 <hpc> it wraps around par and pseq
16:21:26 <jmcarthur> chrisdone: applicative is more general
16:21:36 <new2haskell> hi all, how can I define a [(Int,Int)] as an infinite list? I got this example from class: num n = n : num (n+1); so I thought about: myNum (x,y) = (x,y) : myNum (x+1,y+1) but that's plain wrong.
16:21:39 <jmcarthur> hpc: oh in the new strategies package
16:21:43 <hpc> yeah
16:21:46 <jmcarthur> i've been wanting to try it out
16:21:53 <Saizan> it's funny because there are always to way to interpret "more general"
16:22:04 <Saizan> *two ways
16:22:09 <hpc> im going to give it a go in my game engine
16:22:26 <shachaf> new2haskell: Plain wrong?
16:22:27 <chrisdone> Saizan: that's what's confusing me. the lack of an f a -> f b method makes it seem less flexible
16:22:31 <hpc> my world state is StateT World Eval
16:22:38 <hpc> (did i get that right?)
16:22:44 <hpc> @unmtl StateT
16:22:44 <lambdabot> err: `StateT' is not applied to enough arguments, giving `/\A B C. A -> B (C, A)'
16:22:53 <hpc> yes
16:22:53 <Saizan> chrisdone: it's less expressive, but more things can be an instance of Applicative
16:23:00 <chrisdone> sure
16:23:02 <datwinkdaddy> > repeat (1 :: Int, 2 :: Int)
16:23:02 <lambdabot>   [(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1,2),(1...
16:23:13 <shachaf> new2haskell: Are you trying to make a list of all of them?
16:23:13 <datwinkdaddy> new2haskell ^^
16:23:20 <new2haskell> shachaf: I mean myNum is wrong, it does not cover all combinations
16:23:24 <jmcarthur> chrisdone: less flexible implies that it applies to more types
16:23:25 <chrisdone> Saizan: and a monad can be an applicative instance, so it's a superclass, sure
16:23:40 <new2haskell> shachaf: yes
16:23:40 <chrisdone> jmcarthur: right
16:23:49 <datwinkdaddy> Well, that wouldn't be infinite.  There's a finiate amount of them.
16:23:55 <shachaf> datwinkdaddy: Hm?
16:24:01 <jmcarthur> therefore, the set of types that are monads is a subset of the types that are applicatives
16:24:07 <shachaf> new2haskell: Ah. In that case, try dividing them up by sum?
16:24:09 <chrisdone> yeah
16:24:17 <datwinkdaddy> range (minBound :: (Int,Int), maxBound)
16:24:30 <chrisdone> same with Functor, Category, Splonges, etc
16:24:41 <jmcarthur> monad asserts tighter properties about the type, which means you can do more things with it
16:24:43 <datwinkdaddy> > take 5 $ range (minBound :: (Int,Int), maxBound)
16:24:44 <lambdabot>   [(-9223372036854775808,-9223372036854775808),(-9223372036854775808,-9223372...
16:24:46 <shachaf> datwinkdaddy: This is for Integer, no? Same as iterate (+1).
16:24:56 <hpc> :t range
16:24:57 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
16:25:11 <datwinkdaddy> shachaf: The OP said "Int" not "Integer".
16:25:20 <chrisdone> jmcarthur: indeed
16:25:30 <shachaf> datwinkdaddy: Oh.
16:25:41 <chrisdone> :t Control.Category.(.)
16:25:42 <lambdabot> Couldn't find qualified module.
16:25:46 <shachaf> datwinkdaddy: Well, [Int] is also finite.
16:25:47 <chrisdone> :-(
16:25:55 <shachaf> new2haskell: Did you mean Int or Integer?
16:25:56 <hpc> @hoogle Control.Category
16:25:57 <lambdabot> module Control.Category
16:25:57 <lambdabot> Control.Category class Category cat
16:26:02 <dafis> > concat [[(k-i, i) | i <- [0 .. k]] | k <- [0 .. ]]
16:26:02 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0),(2,1),(1,2),(0,3),(4,0),(3,1),(2...
16:26:12 <hpc> :t (Control.Category..)
16:26:13 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
16:26:21 <chrisdone> ah, wrong syntax
16:26:38 <hpc> strange that it didn't give the right error though
16:26:41 <shachaf> > let f n = map (\x -> (x,n-x)) [0..n] in concat . map f $ [0..]
16:26:42 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
16:26:52 <shachaf> new2haskell: That?
16:27:32 <new2haskell> shachaf: oO-) Integer, I guess
16:27:35 * shachaf believes he forgot about the negative numbers.
16:28:18 <shachaf> But something similar.
16:28:33 <Tezeract> question: what do you think about leksah as a haskell IDE?
16:28:52 <shachaf> Tezeract: Sounds backwards.
16:29:02 <chrisdone> it's got lots of useful stuff
16:29:09 <new2haskell> shachaf: that would be natural number
16:29:23 <chrisdone> i prefer emacs but if i couldn't use emacs i'd be using leksah
16:29:46 <shachaf> new2haskell: Adding the negative integers is left as an exercise. :-)
16:32:07 <magee0> :t flip
16:32:08 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:32:35 <dafis> :t Prelude.flip
16:32:36 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:32:51 <magee0> huh
16:33:06 <dafis> magee0: lambdabot special
16:33:49 <monoidal> > [(x,y) | x <- [1..], y <- [1..x]] --new2haskell
16:33:50 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5...
16:33:53 <dafis> magee0: ((->) e) is a Functor, lambdabot's flip is generalised
16:34:16 <monoidal> it gives only pairs with y<=x
16:35:03 <new2haskell> monoidal: Oh, that's neat
16:36:34 <benmachine> monoidal: no (1,2) in that though
16:36:50 <monoidal> yes, only those with y <= x
16:37:15 * hackagebot darcs-benchmark 0.1.8.3 - Comparative benchmark suite for darcs.  http://hackage.haskell.org/package/darcs-benchmark-0.1.8.3 (EricKow)
16:37:48 <dafis> > [(y,x) | x <- [1 .. ], y <- [1 .. x-1]]
16:37:49 <lambdabot>   [(1,2),(1,3),(2,3),(1,4),(2,4),(3,4),(1,5),(2,5),(3,5),(4,5),(1,6),(2,6),(3...
16:38:03 <dafis> there's the rest, now all you need is (++)
16:38:10 <aristid> > do x <- [1..]; y <- [1..x]; [(x,y),(y,x)]
16:38:11 <monoidal> no, merge
16:38:11 <lambdabot>   [(1,1),(1,1),(2,1),(1,2),(2,2),(2,2),(3,1),(1,3),(3,2),(2,3),(3,3),(3,3),(4...
16:38:17 <new2haskell> dafis:thanks
16:38:19 <monoidal> (++) won't help
16:38:29 <aristid> > do x <- [1..]; y <- [1..x]; nub [(x,y),(y,x)]
16:38:30 <lambdabot>   [(1,1),(2,1),(1,2),(2,2),(3,1),(1,3),(3,2),(2,3),(3,3),(4,1),(1,4),(4,2),(2...
16:38:31 <dafis> new2haskell: that was a joke
16:39:10 <new2haskell> dafis: :( i'm new
16:39:11 <monoidal> > do x <- [1..]; y <- [1..x-1]; [(x,y),(x,x),(y,x)]
16:39:12 <lambdabot>   [(2,1),(2,2),(1,2),(3,1),(3,3),(1,3),(3,2),(3,3),(2,3),(4,1),(4,4),(1,4),(4...
16:39:34 <dafis> new2haskell: if xs is an infinite list, the ys in xs ++ ys will never be reached
16:39:57 <new2haskell> dafis: got it :)
16:40:43 <aristid> > let mix a b = do x <- a; y <- b; [x, y] in mix [(x,y) | x <- [1..], y <- [1..x]] [(y,x) | x <- [1 .. ], y <- [1 .. x-1]]
16:40:44 <lambdabot>   [(1,1),(1,2),(1,1),(1,3),(1,1),(2,3),(1,1),(1,4),(1,1),(2,4),(1,1),(3,4),(1...
16:41:07 <dafis> new2haskell: however, shachaf and I gave working solutions above
16:41:10 <aristid> > let mix a b = do x <- a; y <- b; [x, y] in nub $ mix [(x,y) | x <- [1..], y <- [1..x]] [(y,x) | x <- [1 .. ], y <- [1 .. x-1]]
16:41:11 <lambdabot>   [(1,1),(1,2),(1,3),(2,3),(1,4),(2,4),(3,4),(1,5),(2,5),(3,5),(4,5),(1,6),(2...
16:41:52 <haskell-newbie> I have ghc 6.12.1 installed on ubuntu and I'm trying to install gitit with cabal install, but strict-concurrency fails to build with these errors: http://pastebin.com/UeyHTfgp 
16:42:57 <dafis> haskell-newbie: seems strict-concurrency's .cabal is not quite up to date
16:43:11 <magee0> @source flip
16:43:12 <lambdabot> flip not available
16:43:37 <dafis> haskell-newbie: the NFData class moved from the parallel package to deepseq
16:43:42 <hpc> flip f a b = f b a
16:43:44 <monochrom> flip f x y = f y x
16:43:50 <benmachine> @src flip
16:43:50 <lambdabot> flip f x y = f y x
16:44:12 <dafis> haskell-newbie: parallel re-exported it for a while, but not the latest version
16:44:33 <haskell-newbie> dafis: so what should I do to get this installed?
16:45:33 <dafis> haskell-newbie: you can cabal install --constraint="parallel < 3" strict-concurrency
16:46:41 <haskell-newbie> dafis: I think that worked.  thanks :)
16:47:00 <new2haskell> dafis, lambdabot, aristid: I dont completely understand your solutions but I guess if I want a complete list, then I have to use list comprehension to create "series"and mix the different series together. Right?
16:47:02 <dafis> haskell-newbie: good
16:48:20 <dafis> new2haskell: not necessarily (google Stern-Brocot tree), but that's the simplest approach
16:48:34 <monoidal> Stern-Brocot is for rationals
16:48:48 <etpace> is there a finally that wont return the 
16:48:58 <etpace> computation that will always run, just the intermediate value or something
16:49:17 <dafis> monoidal: right, but you can modify the algo to spit out all pairs of integers (gets ugly, iirc)
16:50:20 <monoidal> new2haskell: you can create all natural pairs with [(n,x-n) | x <- [0..], n <- [0..x]], say
16:50:26 <benmachine> etpace: what do you mean? if a `finally` b returns anything, it's the return value of a
16:50:31 <monoidal> dafis: that will give only pairs (a,b) where gcd a b == 1
16:50:50 <dibblego> @seen dons
16:50:50 <etpace> nevermind, i was just trying to save some characters
16:50:50 <preflex>  dons was last seen on #ghc 1 day, 3 hours, 44 minutes and 50 seconds ago, saying: currently they're not Showable.
16:50:50 <lambdabot> Unknown command, try @list
16:51:22 <dafis> monoidal: that is a trivial modification, adding a third param for the gcd is where it gets ugly
16:51:57 <monoidal> i don't understand. we want all pairs of natural/integer numbers?
16:52:18 <monoidal> stern-brocot gives all pairs (a,b) where a,b coprime and each pair exactly once
16:52:47 <monoidal> to get all pairs of naturals, you'd need to multiply each of the pair by some number, but that brings it to original problem
16:53:20 <dafis> monoidal: yes, but you can map (k,n) to (g, k', n'), where g = gcd k n, k' = k `div` g, n' = n `div` g
16:53:30 <etpace> ok, I previously had "lock" to wait for a number of computations to finish crudely by: mapM_ (\(mvar, x) -> forkIO $ f x `finally` putMvar mvar ()); mapM takeMvar mvars or whatever, but now I want the result from f x, whats the best way to implement this?
16:53:48 <monoidal> dafis: stern-brocot gives only (g,k',n') where g==1 afaik
16:54:11 <dafis> monoidal: or triples (g, k', n') with coprime k', n' to (g*k', g*n')
16:54:56 <dafis> monoidal: then you have to intertwine the Stern-Brocot with g <- [1 .. ] - and that is possible, but not nice
16:55:00 <Saizan> etpace: putMVar the result rather than ()? or if you don't care about order you can use a Chan
16:55:15 <etpace> derp, thats an obvious solution
16:55:17 <etpace> i need a coffee
16:55:21 <monoidal> what do you mean by intertwine? take all combinations?
16:55:30 <etpace> or wait
16:55:37 <etpace> forkIO doesnt return the result thoug
16:55:37 <colinhect> can anyone help me with a Cabal error when installing sdl
16:55:43 <colinhect> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28221#a28221
16:55:45 <benmachine> forkIO gives you a threadid
16:55:51 <etpace> yeah
16:56:01 <benmachine> etpace: what happens if f x throws an exception?
16:56:05 <etpace> so how would I be able to putMvar the result?
16:56:08 <dibblego> is Max Bolingbroke here?
16:56:17 <monoidal> dafis: if "intertwining" means taking all g <- [0..], (k,n') <- [0..] then it's the original problem
16:56:21 <Saizan> etpace: you can still "forkIO $ f x >>= putMVar mvar" modulo exceptions
16:56:29 <monoidal> * g <- [1..], (k',n') <- SBTree
16:56:35 <etpace> itll give me the threadID not the result from f x though Saizan?
16:56:55 <Saizan> etpace: the putMVar is within the fork'ed action
16:57:00 <benmachine> etpace: no, because the >>= is operating on f x, not forkIO f x
16:57:00 <etpace> and it should just fail and putmvar () so it doesnt keep waiting for it to "finish
16:57:03 <etpace> aha
16:57:09 <benmachine> hmm
16:57:19 <monoidal> dafis: if zipping, then it won't give everything
16:57:19 <Saizan> like your putMVar mvar () was.
16:57:27 <etpace> really need the coffee
16:57:45 <benmachine> forkIO $ onException (f x >>= putMVar mvar . Just) (putMVar mvar Nothing)
16:57:50 <benmachine> something like that
16:57:50 <dafis> monoidal: not zipping
16:58:05 <dafis> monoidal: the former
16:58:23 <benmachine> or
16:58:26 <benmachine> or!
16:58:36 <benmachine> forkIO $ try (f x) >>= putMVar mvar
16:58:53 <monoidal> dafis: but that's the task from the beginning - taking all pars from countable set?
16:59:19 <dafis> monoidal: sure, that's what it's about
16:59:21 <monoidal> are you doing recursion here? can't see how it might work :)
17:01:20 <dafis> monoidal: yes, ugly recursion; creating a list with the Stern-Brocot algorithm alone is kinda bad, now intermingling that with a third parameter gets really ugly (I don't remember how ugly exactly)
17:02:20 <monoidal> ah, ok.
17:02:48 <dafis> monoidal: concat [[(i,k-i) | i <- [0 .. k]] | i <- [0 .. ]] is, IMO, (by far ?) the most elegant method here
17:03:15 <monoidal> as far as I remember, stern-brocot starts with (1,1) and goes from (p,q) to (p+q, q) and (p, p+q) or something like that
17:03:34 <shachaf> dafis: Parallel comprehensions?
17:03:39 <monoidal> no, it's a nested list
17:03:41 <dafis> monoidal: right
17:03:47 <shachaf> Oh.
17:03:50 <dafis> shachaf: no, nested
17:04:01 <monoidal> can be written as [(i,k-i) | i <- [0..k], i <- [0..]]
17:04:05 <monoidal> * k
17:04:31 <dafis> duh, it's late here, why didn't I see that?
17:04:38 <monoidal> oh, inversed
17:05:06 <dafis> monoidal: minor hiccoughs
17:05:14 <benmachine> do k <- [0 ..]; i <- [0 .. k]; nub [(i, k-i), (i, i-k), (-i, k-i), (-i, i-k)] -- can anyone do better than this?
17:05:18 <benmachine> > do k <- [0 ..]; i <- [0 .. k]; nub [(i, k-i), (i, i-k), (-i, k-i), (-i, i-k)] -- can anyone do better than this?
17:05:19 <lambdabot>   [(0,0),(0,1),(0,-1),(1,0),(-1,0),(0,2),(0,-2),(1,1),(1,-1),(-1,1),(-1,-1),(...
17:05:46 * benmachine vaguely wonders why it went to (0,2) before (1,1)
17:07:34 <dafis> > (0,0) : do k <- [1 .. ]; i <- [0 .. k-1]; [(i,k-i),(i-k,i),(-i,i-k),(k-i,-i)]
17:07:35 <lambdabot>   [(0,0),(0,1),(-1,0),(0,-1),(1,0),(0,2),(-2,0),(0,-2),(2,0),(1,1),(-1,1),(-1...
17:09:10 <benmachine> answer: yes
17:09:12 <benmachine> (as usual :P)
17:14:29 <dafis> let rot (x,y) = (-y,x) in (0:0) : do k <- [1 .. ]; i <- [0 .. k-1]; take 4 (iterate rot (i,k-i))
17:14:37 <dafis> > let rot (x,y) = (-y,x) in (0:0) : do k <- [1 .. ]; i <- [0 .. k-1]; take 4 (iterate rot (i,k-i))
17:14:38 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(t1, t2)'
17:15:05 <dafis> > let rot (x,y) = (-y,x) in (0;0) : do k <- [1 .. ]; i <- [0 .. k-1]; take 4 (iterate rot (i,k-i))
17:15:06 <lambdabot>   <no location info>: parse error on input `;'
17:15:13 <dafis> > let rot (x,y) = (-y,x) in (0,0) : do k <- [1 .. ]; i <- [0 .. k-1]; take 4 (iterate rot (i,k-i))
17:15:14 <lambdabot>   [(0,0),(0,1),(-1,0),(0,-1),(1,0),(0,2),(-2,0),(0,-2),(2,0),(1,1),(-1,1),(-1...
17:15:19 <dafis> grrrr
17:30:18 <monoidal> > let f x = (-1)^(abs x) * (x`div`2) in take 10 [(f n,f$x-n) | x <- [1..], n <- [1..x-1]]
17:30:19 <lambdabot>   [(0,0),(0,1),(1,0),(0,-1),(1,1),(-1,0),(0,2),(1,-1),(-1,1),(2,0)]
17:49:21 <aristid> > let f x = (-1)^(abs x) * (x`div`2) in take 10 [(f n,f n) | x <- [1..], n <- reverse [1..x-1]]
17:49:22 <lambdabot>   [(0,0),(1,1),(0,0),(-1,-1),(1,1),(0,0),(2,2),(-1,-1),(1,1),(0,0)]
18:03:00 <aavogt> mornfall: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27271#a27275 as an alternative to trying a fixed set of types with syb
18:30:05 <kmc> it's quiet
18:30:07 <kmc> ...too quiet
18:33:34 <old_sound> hi
18:33:37 <colinhect> anyone know why cabal always re-installs packages when they are dependencies for another even if they were already installed
18:33:48 <colinhect> I've watched containers compile about 12 times
18:34:44 <dolio> It shouldn't.
18:35:06 <colinhect> I run it under normal user
18:35:10 <colinhect> should I run it in sudo?
18:35:15 <dolio> I don't.
18:35:20 <colinhect> hmm
18:36:09 <dolio> At most, it should probably compile twice. Once for normal use, and once for profiling.
18:36:30 <dolio> Unless there are various libraries that require multiple different versions or something.
18:36:37 <colinhect> well that isn't the case for me...
18:36:46 <colinhect> not finding anything terrible useful through google either
18:36:56 <dolio> What are you installing?
18:37:14 <colinhect> well it does it for anything I install
18:37:26 <colinhect> but most recently i installed lambdacube-engine
18:38:10 <dolio> You mean it reinstalls containers once for each separate thing you install? Not 12 times for a single install?
18:38:20 <colinhect> right
18:46:53 <tensorpudding> ugh, accursed SML
18:50:39 <BinRoot> hello
18:52:06 <kmc> hi BinRoot
19:02:54 <tensorpudding> anyone know SML and can translate it for me?
19:03:40 <etpace> can you pastebin it?
19:03:45 <kmc> i know a little ocaml
19:03:49 <kmc> 's all
19:03:53 <etpace> iu
19:04:15 <tensorpudding> I'm trying to get my puny brain to understand Okasaki's paper on skew binomial queues
19:04:57 <tensorpudding> it has a line "datatype Tree = Node of Elem.T * Rank * Tree list" and I cannot figure out what it actually means
19:05:10 <tensorpudding> Is the "list" modifying the whole thing?
19:05:11 <kmc> data Tree = Node Elem.T Rank [Tree]
19:05:15 <kmc> i think not
19:05:28 <kmc> i think like Haskell, operators bind more weakly than application, even postfix
19:05:30 <kmc> not sure though
19:05:44 <kmc> actually it's more like data Tree = Node (Elem.T, Rank, [Tree])
19:05:48 <kmc> redundantly
19:06:09 <kmc> iirc constructors aren't functions either, or maybe that's only in ocaml
19:06:16 <kmc> you could ask in a ml channel
19:09:38 <tensorpudding> Now I'm confused by that definition
19:10:20 <tensorpudding> I guess the [Tree] represents subtrees.
19:10:49 <kmc> yeah, a node has an element, a rank, and zero or more children
19:13:32 <koran> Test
19:14:21 <lispy> hi
19:14:40 <lispy> Gracenotes: I was able to finish that refactoring
19:15:03 <lispy> The patches are pending review, but it looks like darcs's parser can be modernized to a parsec-like API
19:15:12 <lispy> Some things seem to have improved performance as a result
19:15:46 * lispy is quite pleased
19:16:30 <lispy> I probably throw away more code that I wrote for darcs than I submit.  I do a of 'experimental refactoring' that I end up throwing away because I had some misunderstanding in my attempt
19:17:23 * ddarius considers designing an interface for Parsec-like parsers and porting Text.Parsec.Combinators to it so that the combining (monadic) parsers problem can be solved once and for all.
19:17:28 <BMeph> Great! :)
19:17:48 <lispy> ddarius: what do you mean?
19:18:10 <lispy> ddarius: what is "the combining (monadic) parsers problem"?
19:19:29 <ddarius> If you have library A that exports a parser using library PA and library B exporting a parser using PB you can't combine those parsers.
19:19:41 <lispy> ah right
19:21:01 <AnAdorableNick> ddarius: That would be wonderful :)
19:23:38 <old_sound> hi guys, have you seen this blog post: http://www.jelovic.com/articles/why_people_arent_using_haskell.htm
19:23:45 <old_sound> I think it is outdated to say the least
19:25:45 <Gracenotes> lispy: good news though
19:26:00 <lispy> old_sound: yeah, I think a lot of those complaints have been addressed now.  But, maybe not the dr. dobbs articles, that seems like a stretch
19:26:03 <AnAdorableNick> "People are willing to learn a new programming language with a different, "weird" syntax." -- Haskell is *much* different from C than than all the languages mentioned on there.
19:26:12 <kmc> syntax is irrelevant
19:26:19 <kmc> "the Haskell community must make a standard distribution of Haskell that contains enough libraries to be useful."
19:26:21 <kmc> we did that
19:26:42 <dolio> How old is that post?
19:27:09 <kmc> there is a lot of finger-waving directed at the "Haskell community" about what we should do to make Haskell as popular as PHP
19:27:25 <Gracenotes> kmc: well once we get everything off that checklist, people will start using haskell! right, right
19:27:31 <kmc> without questioning the assumption that we have this as a goal
19:27:56 <ddarius> lispy: There is plenty of Haskell talk on the Microsoft Development Network.
19:28:43 <aavogt> http://web.archive.org/web/*/http://www.jelovic.com/articles/why_people_arent_using_haskell.htm
19:28:53 <kmc> i don't mean to be the hipster elitist, but i'm perfectly happy without Haskell taking over the world, and perfectly happy to teach those who want to learn
19:29:05 <kmc> without needing to convince everyone in the world to do so
19:29:28 * ddarius somewhat preferred it when this channel was 30 people strong.
19:29:32 <mwotton_> kmc: it'd be nice to have it be big enough to be a credible choice
19:29:33 <kmc> Haskell will never be a good language for writing big boring programs using lots of programmers as replaceable parts
19:29:45 <kmc> anyway, bbl
19:32:49 <dolio> ddarius: Incidentally, would that be similar to the 'combining compatible monads' project? Where you have a class such that (>>=) :: Maybe a -> (a -> [b]) -> [b], among others?
19:33:04 <dolio> I seem to recall that having ambiguity problems.
19:33:20 <ddarius> dolio: No.
19:34:04 <dolio> Or just a common set of combinators that all sufficiently-parsec-like parsers could implement, so you could write code without worrying about what particular implementation you're going to use?
19:34:23 <dolio> Despite all the code having to use the same implementation when you get down to it.
19:34:45 <ddarius> dolio: More the latter, but I would probably aim at also supporting mixing different parsers at run-time.
19:34:57 <old_sound> sorry, I was in meeting, just reading what you commented
19:35:18 <ddarius> But, ideally, the parser writers would simply target this Parsec-like interface and everyone would sing and rejoice.
19:35:39 <dolio> I mean, Data.Vector.Generic (for instance) works with multiple array types. But you can't combine multiple, different array types to make one big array.
19:36:00 <lispy> ddarius: Being able to change your parser library by changing an import would be nice
19:36:00 <ddarius> Already Applicative/Alternative/Monad capture a large chunk of the interface and generic functions.
19:36:26 <lispy> ddarius: That's the direction I'm heading in with this darcs refactoring
19:36:45 <lispy> But, that's not actually my goal
19:37:02 <lispy> I just wanted to modernize the api and be able to use a more featureful parser
19:37:51 <ddarius> I'd probably aim at supporting an Applicative parser interface and a Monadic parser interface and a separation between the generic functions that require the full power of Monad and those that don't.
19:39:00 * ddarius will be back.
19:44:46 <IceDane> Setup: At least the following dependencies are missing:
19:44:46 <IceDane> time ==1.1.*
19:45:15 <IceDane> Using "sudo sh bootstrap.sh" to install cabal
19:45:18 <IceDane> ANy hints?
19:45:44 <IceDane> nvm, brain fart
19:46:03 <IceDane> I thought I had run into this before and actually had time then, but remembered incorrectly
20:00:25 <Guest15782> 
20:02:27 <ezyang> Did Launchbury and co. ever get around to exploring the comonadic foundations of implicit parameters? 
20:04:24 <jmcarthur> i knew nothing about that, but it sounds interesting. what's the gist?
20:05:17 <ezyang> From the paper: “Comonads, [I31 ODERSKY, M., WADLER, P., AND WEHR, M. A second on the other hand, model the structure look at overloading. of en- In Proceedings of the 1995 Confer- vironments, ence on Functional and are thus associated Programming with inputs, or the Languages and Com- left-hand puter Architecture sides of judgements. (San Diego, California, For example, in separated June 1995), (multiplicative, ACM Press. intuitionistic)  linear logic, 
20:05:17 <ezyang>  the intuitionistic  segment of the environ-  ment [l]. In our system, comonads are used to model the  implicit  portion of the environment. ” 
20:05:25 <ezyang> erm, that copypaste didn't work out 
20:06:06 <jmcarthur> heh. i could just get the paper if you tell me which one it is
20:06:20 <ezyang> Sure 
20:06:28 <ezyang> Implicit Parameters, Dynamic Scoping for Types 
20:06:31 <jmcarthur> thanks
20:06:47 <ezyang> I'm currently writing up a comparison blog post for implicit parameters and the reader monad, and I was fascinated to find that tidbit in the conclusion. 
20:08:13 <jmcarthur> perhaps it's the reader comonad?
20:08:25 <jmcarthur> in which case it's the same arrow as the reader monad
20:08:40 <ezyang> possibly. 
20:08:46 <jmcarthur> (r, a) -> b   instead of   a -> r -> b
20:09:24 <jmcarthur> i don't really see how the reader comonad would be a better fit though, so i doubt that's where they were going
20:09:47 <ezyang> The feeling I get is thus: 
20:09:59 <manjunaths> hello
20:10:02 <ezyang> the reader monad is bound statically to a set type for the environment. 
20:10:07 <ezyang> manjunaths: 'allo! 
20:10:19 <manjunaths> did anyone read this ? http://portal.acm.org/citation.cfm?doid=1743546.1743560
20:10:21 <ezyang> It's very annoying adding extra environment variables inside the monad 
20:10:46 <ezyang> But with a comonad, with a more -> less transformation, could somehow manage multiple environments with ease. 
20:11:02 <jmcarthur> how?
20:11:27 <ezyang> I haven't worked it out far enough yet :-) 
20:11:41 <ezyang> The first thing to do is to squint carefully at their lambda formulation and see where the comonad is. 
20:11:53 <manjunaths> On page 32 in the 3rd column he says " In the long run, this will require merging computational memory and filesystems into a single, global virtual memory.". Anybody know what this means ?
20:11:56 <jmcarthur> as i understand it, the reader comonad is basically identical in expressive power to the reader monad
20:12:06 <jmcarthur> but maybe i'm wrong
20:12:22 * jmcarthur looks for their lambda formulation
20:13:40 <ezyang> manjunaths: AFAICT, they want to basically pretend their filesystem is a just a big memory space? 
20:13:49 <ezyang> (haven't looked at the paper, but that sounds like the logical interpretation) 
20:14:03 <ddarius> That's a pretty common thought with large address spaces.
20:14:20 <manjunaths> ezyang, yes that seems to be the literal intrepretation, but what happens then ?
20:14:34 <manjunaths> ezyang, all the files and directories go away ?
20:14:40 <ezyang> manjunaths: If they manage it efficiently, Haskell becomes uber-fast. :-) 
20:14:59 <ezyang> manjunaths: There are several papers on this subject. Lemme find them. 
20:15:37 <ddarius> manjunaths: What is the "this" that will require this merging?
20:16:32 <manjunaths> ddarius, I don't understand the question, it is some article on reddit.com/r/haskell about functional programming languages and multi-processor architectures
20:16:36 <heatsink> Is there some kind of unionWith' :: (Maybe a -> Maybe a -> Maybe a) -> Map k a -> Map k a -> Map k a function?
20:16:45 <manjunaths> ddarius, does that answer your question ?
20:17:01 <ddarius> manjunaths: The sentence begins "In the long run, this will require merging..." what is "this" referring to?
20:17:13 <manjunaths> ddarius, ah...
20:17:39 * ezyang suddenly gets a sense of deja vu 
20:18:18 <manjunaths> ddarius, The full benefits of functional programming and composability cannot be fully realized unless memory management and thread scheduling are freely managed at runtime. In the long run, this will require merging computational memory and file systems into a single, global virtual memory.
20:20:16 <manjunaths> I think more info is needed about memory management and thread scheduling being managed at runtime in Haskell.
20:20:50 <dolio> ezyang: It's hard to see how reader comonad would be a better fit for implicit parameters. For instance '(?f :: r) => b' is easily modeled by 'r -> b'. But with the reader comonad, it seems like you'd have to switch to representing values as () -> b, for '(r, ()) -> b'.
20:21:04 <dolio> Assuming that's what's proposed.
20:21:27 <ezyang> dolio: Well, there's some magic 
20:21:45 <ezyang> Since (?f :: r, ?g :: r2) => fluidly composes with (?f :: r) 
20:25:37 <tolkad> Is there a tool to convert all my code into hungarian notation?
20:27:44 <aavogt> some related tools are ghc-goals and haskell-src-exts
20:28:11 <aavogt> tolkad: but I don't think such a thing has been pieced together from those things
20:28:32 <heatsink> tolkad: What do you want to use Hungarian notation for?
20:28:36 <heatsink> Hungarian notation is generally used as a sort of poor-man's type signature.
20:29:13 <tolkad> heatsink: hungarian notation is best notation
20:29:42 <interferon> so i'm trying to explain the IO monad to someone and i'm stumbling.  so for my example i'm using "getLine >>= \line -> ...."
20:29:51 <interferon> getLine is a function that returns an IO action 
20:29:55 <Veinor> why would you need hungarian notation in a strongly typed language?
20:30:02 <interferon> and when that action is evaluated, it....what?
20:30:09 <interferon> returns an IO monad containing the string read?
20:30:14 <dolio> getLine isn't a function, though. It's just a value.
20:30:22 <ezyang> interferon: nope 
20:30:41 <interferon> dolio: well, it is, right. "IO a" is an alias for some internal function ty[e
20:30:51 <ezyang> interferon: line contains the line read, but it's the only visible inside the lambda 
20:30:52 <tolkad> Veinor: because it's good practice
20:31:00 <ddarius> interferon: No.
20:31:00 <Veinor> why?
20:31:07 <interferon> ezyang: yeah, got that
20:31:09 <tolkad> Veinor: because it keeps your code good
20:31:13 <ddarius> interferon: IO is simply an abstract type.  It doesn't internally need to be a function type.
20:31:19 <dolio> interferon: That's merely one way to implement IO.
20:31:20 <heatsink> interferon: getLine is an IO action.  When the action is evaluated, it returns a String.  The tricky part is getting across the message that >>= doesn't evaluate it.
20:31:39 <Veinor> how does it 'keep your code good'?
20:31:47 * ezyang tries out the chef metaphor 
20:32:01 <tolkad> interferon: getLine returns a string stuck in the IO monad, you have to grab it out
20:32:12 <ddarius> Veinor: I recommend ending this conversation.
20:32:15 <aavogt> or maybe HaRe (haskell refactorer) can accurately get you the types of subexpressions
20:32:17 <tolkad> interferon: the IO monad is basically this type stuff gets stuck in
20:32:22 <Veinor> ddarius: I can't help it!
20:32:26 <tolkad> interferon: and you have to get it back out
20:32:29 <Veinor> like a moth to a flame am I
20:32:51 <ezyang> interferon: So, imagine that readLine is a recipe that results in soup, and the function takes the diner's response to a dish and makes the chef make either duck or lamb. 
20:32:51 <tolkad> Veinor: by keeping it with good standards
20:33:01 <interferon> i understand that the IO type holds the string
20:33:13 <interferon> but i thought that IO values were "actions", i.e. functions
20:33:18 <Veinor> yeah, but you don't need the standards in a strongly typed language
20:33:23 <ddarius> interferon: No, the IO type doesn't "hold" anything.
20:33:24 <tolkad> interferon: imagine the IO monad is this box covered in tar that keeps grabbing stuff and trying to hold onto it and you have to get it out
20:33:46 <ezyang> interferon: If the chef is planning his meals for the evening, and he wants to make a bigger plan that combines the recipe and the diner-response-new-food, he doesn't go and make the soup: he just puts them together. 
20:34:08 <ezyang> that is, in his head. And then when the evening comes and he actually has diners he executes the plan. 
20:34:14 <aavogt> Veinor: it happens anyways to some degree
20:34:33 <tolkad> interferon: some functions like return stick stuff in this box and you have to use return when the function you are in returns IO, basically it's this annoying thing stuff gets stuck in
20:34:36 <interferon> we build up a long chain of IO actions and then return them from main, where the Haskell runtime executes them
20:34:42 <Veinor> aavogt: haskell even has its own hungarian notation
20:34:44 <ezyang> So when you >>= stuff together, you're just formulating more complicated battle plans 
20:34:48 <Veinor> xs
20:34:51 <Veinor> :D
20:34:57 <ezyang> which might involve cooking stuff, but not yet. 
20:35:29 <ezyang> interferon: That's something I thought too, but it's not quite right. 
20:35:37 <ezyang> The IO type doesn't actually say anything, in-and-of-itself 
20:35:45 <lispy> > foldr (+) 0 [1..4] :: Expr
20:35:46 <lambdabot>   1 + (2 + (3 + (4 + 0)))
20:35:48 <ezyang> you give me an IO a, and I don't know if it reads a line, or writes a line, or what. 
20:35:50 <interferon> i think i'm going too deep into the implementation of IO
20:35:54 <interferon> ezyang: ok.
20:36:02 <tolkad> you are forced to make stuff return IO whenever it does useful stuff
20:36:28 <tolkad> and then you have to grab stuff out of the IO because it gets stuck in there
20:36:29 <ezyang> tolkad: Well, go back to the chef. 
20:36:48 <ezyang> A recipe hooked up with another recipe is still just a recipe. 
20:37:05 <ezyang> Even if the second recipe calls for actual food being around and observable. 
20:37:10 <tolkad> yeah, it's a haskell bug I bet they are working on it so we don't have to worry about all this IO sstuff anymore
20:37:47 * ezyang gives the chef analogy 2 out of 10 (needs some work ^_^) 
20:38:18 <interferon> but i'm not right in thinking that the >>= operator is just chaining these things together into a giant action and that the runtime executes it?
20:38:28 <ezyang> interferon: No, you /are/ right! 
20:38:59 <tolkad> haskell is called a functional language because it has more functions than other languages, like C for example. Haskell becomes a bit unwieldy at times because it's internal systems are very complicated as a result of having all these functions. The IO type stuff we have to work around is caused by this.
20:39:15 <interferon> ezyang: oh :)
20:39:35 <dankna> (my favorite monad comparison continues to be "A monad is like a bad metaphor for what monads are.")
20:39:57 <ezyang> interferon: Now, this is kind of made complicated by the fact that Haskell is lazy 
20:39:58 <dankna> (the chef metaphor is not even a distant second.  although it's for something different.)
20:40:08 <tolkad> dankna: how's my explanation?
20:40:24 <dankna> pretty good I'd say, but I'm no expert
20:40:41 <ezyang> interferon: So Haskell may not build up these actions until it has to. 
20:41:13 <ezyang> > unless False (fix id) 
20:41:14 <lambdabot>   No instance for (GHC.Show.Show (m ()))
20:41:14 <lambdabot>    arising from a use of `M263228887...
20:41:21 <ezyang> bah 
20:41:44 <lispy> oh, I know that type.  good ole M263228887...
20:41:51 <hUnitMac> Hello, can anyone show me how to install hUnit on a Mac with GHC? I download it from sourceforge but I don't know how to install it.
20:42:03 <ddarius> ezyang: Laziness has nothing to do with IO.
20:42:14 <interferon> i understand IO and monads well enough to use them but not enough to explain them to others :-D
20:42:15 <ezyang> ddarius: But it has everything to do with combining IO actions! 
20:42:17 <aavogt> > iterate (>> return ()) Nothing
20:42:17 <lambdabot>   [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,No...
20:42:31 <heatsink> hUnitMac: The preferred way is with cabal-install.  Did you download it with cabal-install?
20:42:31 <tolkad> ezyang: it's a result of having too many functions, languages like C have a reasonable amount of functions but haskell has way too many
20:42:33 <ddarius> ezyang: Only in a few cases for very obvious reasons unrelated to monads or IO.
20:42:44 <ezyang> ddarius: Fair enough. 
20:43:01 <ezyang> tolkad: I'll take functions over objects any-day :-) 
20:43:06 <hUnitMac> heatsink: no, I download the tar file from hUnit website
20:43:17 <interferon> ezyang: agreed
20:43:19 <unkanon> how do i turn a char into a string? googling "haskell char to string" returns nothing useful. I found something about showLitChar but I can't get that to work
20:43:22 <tolkad> ezyang: yeah but we have to use IO because all these functions clog up the program and confuse the compiler
20:43:25 <heatsink> I wonder when they'll fix that bug in C that when you assign a variable, the previous value goes away.
20:43:33 <dankna> unkanon: [c]
20:43:37 <ddarius> unkanon: A string is just a list of characters.
20:43:37 <lispy> unkanon: String is [Char]
20:43:45 <hUnitMac> heatsink: how can I get cabal on my Mac?
20:43:48 <tolkad> IO helps the compiler know what's going on so it doesn't get confused by all the functions because there are so many
20:43:51 <lispy> ?hoogle Char -> String
20:43:52 <lambdabot> Network.URI escapeURIChar :: (Char -> Bool) -> Char -> String
20:43:52 <lambdabot> Prelude show :: Show a => a -> String
20:43:52 <lambdabot> Text.Show show :: Show a => a -> String
20:43:56 <tolkad> hUnitMac: just install haskell, it comes with it
20:43:59 <ezyang> tolkad: I'm so befuzzled. :-) 
20:44:05 <tolkad> hUnitMac: there is a package install
20:44:08 <MidoriKid> hUnitMac: The easiest way is to install the Haskell Platform.
20:44:15 <unkanon> right, I know, a string is [Char], that's why I need a function that turns a Char into String, because when I explode a String I want to get its elements as String and not as Char
20:44:19 <interferon> hUnitMac: get the Haskell Platform
20:44:25 <interferon> unkanon: ?
20:44:32 <MidoriKid> http://hackage.haskell.org/platform/mac.html
20:44:35 <lispy> > 'a' : []
20:44:36 <lambdabot>   "a"
20:44:44 <lispy> > ['a']
20:44:45 <lambdabot>   "a"
20:45:09 <tolkad> @faq can haskell functions cause side effects without returning IO?
20:45:09 <lambdabot> The answer is: Yes! Haskell can do that.
20:45:09 <unkanon> I want to be able to do this and have it work: zipWith (++) "abc" "abc"   (I understand exactly why it doesn't work)
20:45:16 <MidoriKid> hUnitMac: Then "cabal install hunit" in the terminal.
20:45:21 <tolkad> huh, that's kind of confusing I thought it couldn't
20:45:24 <hUnitMac> thanks everyone
20:45:25 <tolkad> I guess I was wrong
20:45:32 <interferon> unkanon: work meaning what?
20:45:33 <ezyang> :^) 
20:45:44 <lispy> > zipWith (\a b -> [a] ++ [b]) "abc" "abc"
20:45:45 <lambdabot>   ["aa","bb","cc"]
20:45:48 <lispy> seems to work here
20:45:49 <lispy> :)
20:45:53 <interferon> tolkad: see unsafePerformIo and unsafeInterleaveIo
20:45:56 <hUnitMac> I thought GHC was the Haskell platform
20:46:09 <hUnitMac> but it is not 
20:46:09 <unkanon> lispy: oh i see what you did there
20:46:24 <tolkad> interferon: oh, cool, I guess I can use those and not have to worry about all this IO stuff!
20:46:25 <unkanon> so basically [] is the function that turns 'f' into "f"
20:46:29 <interferon> hUnitMac: GHC is a Haskell compiler and runtime; the Haskell Platform is a package of common libraries, GHC, and Cabal
20:46:30 <tolkad> interferon: nice workaround ; ) thanks
20:46:33 <interferon> tolkad: no!
20:46:39 <heatsink> > zipWith (on (++) return) "abc" "abc"
20:46:40 <lambdabot>   No instance for (Data.Monoid.Monoid (m GHC.Types.Char))
20:46:40 <lambdabot>    arising from a u...
20:46:42 <interferon> tolkad: unclean, unclean!
20:46:46 <lispy> unkanon: ah, putting [] around things makes them a list
20:46:59 <lispy> unkanon: String is just [Char]
20:47:09 <dibblego> how do people get around the absence of instance Show (a -> b) in QuickCheck?
20:47:11 <lispy> unkanon: String is not a type in Haskell, it's a type synonym
20:47:13 <Axman6> > 'a':'b':'c':[]
20:47:14 <lambdabot>   "abc"
20:47:37 <interferon> dibblego: why do you want that?
20:47:37 <unkanon> lispy: gotcha, thanks
20:47:51 <dibblego> interferon, because I quantify on functions in my QC tests
20:47:58 <unkanon> lispy: can i ask a theoretical question?
20:48:00 <tolkad> >'a':'b':'c':['a'..]
20:48:05 <tolkad> > 'a':'b':'c':['a'..]
20:48:06 <lambdabot>   "abcabcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\...
20:48:08 <lispy> unkanon: Yes, we like those here
20:48:10 <ezyang> unkanon: Don't ask to ask. 
20:48:13 <unkanon> haha, ok
20:48:17 <unkanon> oh yeah right, forgot about that
20:48:27 <Axman6> unkanon: first rule of IRC: don't ask to ask, just ask
20:48:35 <tolkad> Can I ask a question?
20:48:43 <lispy> Can I answer a question?
20:48:59 <Axman6> Can I have ops please?
20:49:00 <lispy> ?faq Can Haskell ask a question?
20:49:00 <lambdabot> The answer is: Yes! Haskell can do that.
20:49:06 <m3ga> tolkad: if its your first time in IRC, you have to ask!
20:49:06 <unkanon> zipWith (\a b -> [a] ++ [b]) "abc" (cycle " ")   <--  cycle is cool, but can it *only* work in lazily-evaluated languages? is there anyway for eager languages to have this marvelous function cycle?
20:49:25 <lispy> unkanon: yes there are ways
20:49:27 <ezyang> unkanon: Many languages have laziness primitives 
20:49:35 <lispy> unkanon: python has 'generators'.
20:49:37 <tolkad> > (unsafePerformIo (print 5))
20:49:38 <lambdabot>   Not in scope: `unsafePerformIo'
20:49:48 <tolkad> uh can someone fix that?
20:49:51 <ezyang> (also commonly called suspensions) 
20:49:55 <tolkad> who is incharge of lambdabot?
20:50:00 <ezyang> > print 4 
20:50:01 <lambdabot>   <IO ()>
20:50:01 <lispy> tolkad: Cale is
20:50:08 <interferon> unkanon: it's possible but only in a lazy language will it be so transparent
20:50:08 <ezyang> IO's not allowed :^) 
20:50:15 <unkanon> tolkad: unsafePerformIO
20:50:16 <lispy> tolkad: fix what?
20:50:24 <interferon> unkanon: in strict languages you'll have to specify somehow that the function is not to be evaluated strictly
20:50:25 <tolkad> ezyang: is that supposed to look like a tear?
20:50:35 <lispy> > let that = id in fix that
20:50:36 <ezyang> it's a nose. I HAVE A BIG NOSE 
20:50:38 <lambdabot>   mueval-core: Time limit exceeded
20:50:44 <lispy> > fix error
20:50:45 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
20:50:45 <unkanon>  > (unsafePerformIo (print 5))
20:50:47 <tolkad> ezyang: lol I thought it was crying
20:50:55 <ezyang> that's :_( 
20:50:57 <lispy> > unsafePerformIO (print 5)
20:50:58 <lambdabot>   Not in scope: `unsafePerformIO'
20:51:05 <lispy> The O should be caps
20:51:13 <unkanon> interferon: ok, generators then, I think I can do that in Ruby
20:51:19 <Axman6> > fix (error . ('\n':))
20:51:20 <lambdabot>   "*Exception:
20:51:20 <lambdabot>  *Exception:
20:51:20 <lambdabot>  *Exception:
20:51:20 <lambdabot>  *Exception:
20:51:20 <lambdabot>  *Exception:
20:51:22 <lambdabot>  *Exc...
20:51:22 <unkanon>  > (unsafePerformIO (print 5))
20:51:26 <Axman6> >_>
20:51:28 <interferon> total mayhem in here tonight...
20:51:44 <lispy> Axman6: oh man.  You're evil :)
20:52:10 <tolkad> > error error error error error error error
20:52:11 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:52:11 <lambdabot>         against inferred ty...
20:52:16 <tolkad> > error ""
20:52:17 <lispy> no one is replying to my parser correctness thread
20:52:17 <lambdabot>   *Exception:
20:52:23 <interferon> guys, can you chill out?  start a private message with lambdabot
20:52:27 * lispy waits impatiently
20:52:33 <unkanon> interferon: so the fact that haskell is lazily evaluated is more a benefit to the programmer than to the people that programmed the language?
20:52:44 <dankna> parser correctness thread?  this is relevant to my interests
20:52:52 <interferon> so is it right to describe a monad as a "container type that supports the >>= and return operations" or is container too concrete?
20:53:00 <ezyang> unkanon: It does make the language implementor's job more difficult 
20:53:03 <lispy> unkanon: It's quite beneficial to the programmer.  It makes the language exceptionally composale
20:53:12 <lispy> composable*
20:53:16 <ezyang> interferon: Pshh. “Computational context.” :-) 
20:53:19 <interferon> unkanon: yes, the people who programmed the language have to work harder to make it possible
20:53:27 <interferon> ezyang: so abstract!
20:53:28 <Mathnerd314> how is Single Static Assignment different from pure functional programming?
20:53:32 <ezyang> rereading Okasaki, there's another important benefit to laziness: 
20:53:36 <Axman6> @remember Axman6 fix (error . ('\n':))
20:53:36 <lambdabot> It is forever etched in my memory.
20:53:43 <Axman6> @quote Axman6
20:53:43 <lambdabot> Axman6 says: foldr chosen for its magical evil terminating powers
20:53:46 <unkanon> ezyang: so could the programmers of haskell make it a "fake" lazy evaluation but that still looked like lazy to the programmer? then the people that made the language would have it easier?
20:53:48 <Axman6> @quote Axman6
20:53:48 <lambdabot> Axman6 says: fix (error . ('\n':))
20:53:48 <ezyang> it helps reconcile persistence and amortization 
20:53:49 <tolkad> > readFile "/dev/urandom"
20:53:50 <lambdabot>   <IO [Char]>
20:53:54 <tolkad> 0_o
20:54:00 <ezyang> unkanon: Yes. In fact this is done already. 
20:54:05 <lispy> interferon: it's better to think of it as a wrapper around function and or data composition.  A wrapper that lets you get in and mess with things if you so desire
20:54:18 <lispy> interferon: programmable semicolons
20:54:20 <tolkad> > do readFile "/dev/urandom"
20:54:20 <interferon> but wrapper is basically == to container
20:54:24 <lambdabot>   <IO [Char]>
20:54:31 <m3ga> @remember m3ga shut up Axman6 
20:54:31 <lambdabot> Good to know.
20:54:35 <m3ga> @quote m3ga
20:54:35 <lambdabot> m3ga says: shut up Axman6
20:54:39 <interferon> will i be *wrong* if i refer to a monad as a "container type"?
20:54:40 <interferon> :)
20:54:43 <tolkad> > <- do readFile "/dev/urandom"
20:54:44 <lambdabot>   <no location info>: parse error on input `<-'
20:54:51 <lispy> interferon: A container that has a chance to interact with attempts to add or remove things
20:55:00 <heatsink> If monads are containers, the Cont monad is a klein bottle.
20:55:02 <lispy> interferon: I wouldn't consider a monad a container type
20:55:05 <dankna> lispy: I just went and found your thread.  I would guess that nobody is replying because nobody has done this.
20:55:07 <unkanon> ezyang: how do you mean that it is already done? haskell already does it that way?
20:55:28 <Axman6> tolkad: that isn't even valid haskell
20:55:38 <ezyang> unkanon: GHC attempts to be smart about when laziness isn't required and compile it out. 
20:55:41 <lispy> ?remember heatsink If monads are containers, the Cont monad is a klein bottle.
20:55:41 <lambdabot> It is forever etched in my memory.
20:55:50 <lispy> dankna: hmm...I see
20:56:06 <lispy> dankna: how are people testing their parsers?
20:56:13 <dankna> lispy: I think parsers are not an area that a lot of Haskellers are interested in; hence the prevalance of ad-hoc things such as parsec
20:56:41 <dankna> I'm not sure people are in fact testing their parsers, or at least, not beyond a few corner cases during development
20:56:45 <unkanon> ezyang: would it be required for "cycle" in my example? because that can be turned into a function that always returns ' '.
20:56:57 <ezyang> unkanon: Yes, it would be required 
20:57:01 <lispy> dankna: Hmmpf.  I don't like that answer :)
20:57:07 <dankna> I don't either :)
20:57:09 <lispy> dankna: but, maybe you're right
20:57:40 <dankna> for Darcs obviously you need very high reliability guarantees
20:58:03 <unkanon> ezyang: ok, i'll try and do it in ruby so I can understand something. I appreciate the help :)
20:58:32 <ezyang> unkanon: Bah, go do it in Haskell instead. 
20:58:38 <dankna> perhaps you could write an informal grammar that isn't actually used by the parser, and use that to do the generation half of the round-trip checking?  does that even make sense?  hmm
20:59:06 <unkanon> ezyang: well haskell is already lazy so there's nothing to do (plus it's already done in my example)
20:59:11 <lispy> dankna: hmm...Well, since the parser is for serialization round trip testing will be 'easy' to setup
20:59:17 <ezyang> dankna: There's been papers on that. 
20:59:17 * dankna nods
20:59:19 <lispy> dankna: I have suitable show instances
20:59:26 <dankna> ezyang: references would be fun
20:59:31 <unkanon> ezyang: i want to convert my example to ruby to understand what how the laziness is involved in cycle
20:59:35 <ezyang> unkanon: Oh, you want to write laziness in ruby? 
20:59:45 <ezyang> expect lots of lambdas :-P 
20:59:57 <lispy> unkanon: The most raw way to get laziness is to use functions
21:00:01 <ezyang> dankna: I could have sworn there was a paper in CUFP or a similar conference, but i can't find it. 
21:00:01 <unkanon> ezyang: yes. ruby has a Generator class and has yield, so it shouldn't be hard.
21:00:08 <dankna> oh, hm.  yeah, show instances would work.  hm.
21:00:25 <ezyang> lispy: Do you by any chance remember it? It was mentioned at a MOB meeting 
21:00:26 <unkanon> lispy: oh?
21:00:27 <dankna> ezyang: oh well.  if you come across it let me know.  parsing is a special interest of mine.
21:00:31 <lispy> unkanon: instead of computing [1..] and returning it, return something that can 'go to the next' element in the list
21:00:56 <lispy> ezyang: if it was mentioned at a MOB meeting, then I can guarantee I don't remember :)
21:00:57 <ezyang> I think generators are kind of twisted image of laziness 
21:01:06 <ezyang> aw darn it! ;-) 
21:01:18 <unkanon> lispy: oh ok, yeah ruby can definitely do that
21:01:24 * Mathnerd314 celebrates that nobody answered his question
21:01:41 <jmcarthur> Mathnerd314: i considered answering it, but i don't feel qualified enough
21:01:43 <unkanon> lispy: but then if that's all there is to it, then couldn't haskell, when compiling, turn every lazyfunction into a function like you explained?
21:02:07 <lispy> unkanon: Well, haskell's laziness is baked in
21:02:14 <jmcarthur> unkanon: it kind of works that way already, but more intelligently
21:02:38 <lispy> unkanon: in Haskell, your program is like a big graph and that graph is 'reduced' to an answer using a specific strategy for choosing the next thing to evaluate
21:02:43 <dankna> any Haskell value in memory can instead be a pointer to a function to compute the actual value
21:02:49 <unkanon> lispy: I know, but it does have to turn its magic into assembly at some point. so behind the scenes, is that how it does it? turns every lazy function into a function that returns a function that can get the next element?
21:02:59 <unkanon> jmcarthur: oh ok, that's what i figured
21:03:15 <unkanon> lispy: yeah i 've seen a video in youtube that illustrates that point very well :)
21:03:27 <lispy> cool, do you have the link?
21:03:30 <dankna> if you're really interested in how it works, read the Spineless Tagless G-Machine paper...  I think.  I confess to not having read it myself.
21:03:33 <lispy> Might be fun to watch
21:03:37 <jmcarthur> unkanon: the GHC runtime represents a lazy value (called a "thunk") as a function that evaluates the expression it represents, rewrites itself, then returns the result. the rewrite step transforms the function such that it simple returns the result rather than recomputing it
21:03:47 <dolio> Mathnerd314: I don't think they're very different, if at all.
21:03:50 <jmcarthur> *simply
21:04:20 <dolio> Mathnerd314: Also, there are links between SSA, and conversion to continuation passing, which is how a lot of compilers for functional languages work.
21:04:46 <lispy> dankna: I think round tripping, with a decent value generator is probably sufficient for most parser testing.
21:05:08 <unkanon> jmcarthur: i understand how thunks work, I just have trouble mapping it all down to the metal, i.e. what is a thunk in terms of assembly code? if haskell were never compiled I could understand, but since it compiles, it seems like that's a tough thing to manage (laziness and thunks)
21:05:09 <lispy> dankna: If rejection of bad input is required then it seems fuzzing is a good way to go
21:05:27 <jmcarthur> i have always found it amusing that impure, imperative languages, widely considered to be faster due to being closer to the hardware, are typically optimized in a purely functional form
21:05:32 <lispy> unkanon: I think thunks are actually implemented as structs in C in the run-time
21:05:37 <dankna> lispy: yes, I agree on both counts, but I'm not really an expert on any sort of testing
21:05:48 <jmcarthur> unkanon: in terms of assembly code it is literally what i just described
21:06:01 <dabuckle> .whois jmcarthur
21:06:05 <unkanon> jmcarthur: so the assembly code simply creates more functions on the fly?
21:06:26 <dankna> think of it this way - this is not quite accurate because I don't remember all the details
21:06:29 <jmcarthur> unkanon: it uses some higher level functions (primitives) i'm sure. it's not like JIT
21:06:47 <unkanon> jmcarthur: oh ok, if it were like JIT my jaw would be on the floor
21:07:00 <lispy> unkanon: You really should read some of the older papers about GHC.  You'd like the level of detail to the run-time
21:07:04 <unkanon> jmcarthur: so it's more like a struct with pointers to different functions in a certain order?
21:07:08 <jmcarthur> @where STG
21:07:09 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
21:07:11 <jmcarthur> unkanon: ^^
21:07:14 <dankna> ... actually never mind.  I'm too tired for what I was going to say.
21:07:31 <unkanon> jmcarthur: hmm looks like it's broken?
21:07:33 <jmcarthur> unkanon: papers can explain better than i can :)
21:07:36 <jmcarthur> oh?
21:07:39 <unkanon> lispy: i'll definitely look for those
21:07:42 <jmcarthur> oh phooey
21:07:46 <dankna> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
21:07:51 <unkanon> isn't citeseet paid?
21:07:55 <lispy> unkanon: look at the 'compiler technology' section: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
21:08:21 <jmcarthur> citeseer is free!
21:08:27 <unkanon> lispy: that's a lot of links!
21:08:38 <jmcarthur> unkanon: check out the one dankna linked to
21:08:42 <lispy> unkanon: there are tons of papers, better start reading :)
21:09:00 <jmcarthur> unkanon: that paper is actually a bit dated, but it can give you the idea :)
21:09:03 <lispy> and yes, dankna's link is a classic on this topic
21:10:24 <unkanon> jmcarthur: ok. do you think it'd help me if i looked at the intermediary c-- code that haskell generates?
21:10:32 <jmcarthur> not so much
21:10:40 <unkanon> it wont reveal anything to me?
21:10:47 <jmcarthur> if anything, looking at the core (after reading the STG paper) would help more than the cmm
21:10:56 <dankna> GHC's pipeline actually goes stg > c-- > asm
21:10:58 <jmcarthur> the core output, that is
21:10:59 <dankna> or something like that
21:11:12 <dankna> yes, it has multiple low-level languages inside it
21:11:14 <jmcarthur> core -> stg -> cmm -> asm ?
21:11:21 <jmcarthur> i think that's right
21:11:26 <kakos> In a Record, is there a way to add a field that needs to be a specific typeclass?  I tried "objects :: (Object a) => [a]", but the compiler bitches at me.
21:11:27 <dankna> something like that.
21:11:41 <lispy> hmm..it's always bad when you google for something and your own question to a public mailing list is the top hit...
21:12:02 <jmcarthur> lispy: it's especially bad if you don't remember asking the question!
21:12:10 <lispy> jmcarthur: heeh
21:12:14 <lispy> I'm not quite that bad...yet
21:12:29 <kakos> jmcarthur: It's even worse when you remember asking the question, remember figuring it out on your own, but can't remember the answer.
21:12:40 <jmcarthur> i've googled for things before and found myself asking the same questions *years* ago
21:13:00 <jmcarthur> and of course it was never answered
21:13:07 <ezyang> :-( 
21:13:16 <ezyang> Happens a lot for my friends w/ bug reports 
21:13:26 <dankna> I've had multi-year conversations on Amazon book-commentary pages :D
21:13:36 <dankna> where by chance I happened on the same page again and noticed somebody had responded
21:13:45 <dankna> well, actually it only happened the once.  but it was cool.
21:14:39 <lispy> kakos: you mean like, data Foo = { obects :: Object a => [a] } ?
21:14:47 <kakos> lispy: Yeah
21:14:57 <lispy> kakos: that should be fine
21:15:15 <lispy> er, sans my syntax errors
21:15:19 <jmcarthur> unkanon: to be honest, i answered your question about Cmm from the viewpoint of studying your haskell programs, not from the viewpoint of learning how it works at the machine code level. it may very well be that looking at the Cmm helps (i never have). typically Core is more useful for optimizing and debugging haskell programs
21:15:28 <lispy> data Foo = Foo { objects :: Object a => [a] }, more lke
21:15:41 <dankna> er?  don't you have to explicitly quantify on a?
21:15:43 <kakos> lispy: Illegal polymorphic or qualified type: forall a. (Object a) => [a]
21:16:57 <jmcarthur> data Foo = Foo { objects :: forall a . Object a => [a] }
21:17:09 <dankna> well
21:17:11 <dankna> I was thinking more like
21:17:12 <unkanon> jmcarthur: ok, i will take a look at the generated c-- and see what i think
21:17:18 <heatsink> kakos: I think you can allow it with RankNTypes.  Is that really what you want though?
21:17:22 <jmcarthur> but note that that is still a homogenous list
21:17:23 <dankna> doesn't the quantification have to be at the top
21:17:29 <dankna> except you can't do that
21:17:33 <jmcarthur> dankna: "at the top"?
21:17:46 <dankna> sorry, I mean, doesn't Foo itself have to be an existential type for what he wants to make sense
21:18:01 <heatsink> probably
21:18:05 <dankna> from a practical standpoint, this is where we back off and ask what he's trying to accomplish and suggest a more idiomatic way of doing it
21:18:07 <jmcarthur> dankna: what i just said *is* existential quantification
21:18:09 <kakos> heatsink: Why wouldn't I?
21:18:28 <jmcarthur> dankna: right. what i suggested is probably *not* what is wanted (which i suspect is a heterogenous list)
21:18:30 <etpace> > break (==5) [1..10]
21:18:31 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
21:18:49 <dankna> like data forall a . Object a => Foo a = Foo { objects :: [a] }
21:18:54 <dankna> but I'm not sure that's legal
21:19:01 <hydo> I'm sure someone knows about the ghc project's trac instance being messed up, right?
21:19:15 <lispy> kakos: you might find this helpful: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
21:19:26 <jmcarthur> dankna: you are thinking this:  data Object a => Foo a = Foo { objects :: [a] }
21:19:28 <lispy> hydo: I'd ask in #ghc to be sure
21:19:32 <kakos> Haha
21:19:33 <dankna> thank you, yes I am
21:19:35 <jmcarthur> dankna: which is legal but discouraged
21:19:40 <heatsink> kakos: The type (forall a. Object a => [a]) returns objects of _any_ object type.  Kind of like how 'undefined' returns values of any type.
21:19:41 <hydo> oh, hurp.. thanks lispy
21:20:05 <jmcarthur> dankna: and that is not existential quantification, by the way
21:20:10 <jmcarthur> that is legal haskell 98
21:20:15 <dankna> oh, hm
21:20:27 <dolio> jmcarthur: What you typed is universal quantification.
21:20:30 <dankna> yeah, I guess that's true, it's not
21:20:46 <dolio> Existential would be: data Foo = forall a. Object a => Foo { objects :: [a] }
21:21:02 <jmcarthur> dolio: oh you're right
21:21:12 <mtnviewmark> any whizes with cabal here?
21:21:18 <kakos> heatsink: Right.  I want objects to store a list of any kind of object type.  I fail to see the problem.  ;)
21:21:23 <jmcarthur> universal would be even further from what i suspect is desired
21:21:33 <dankna> any ONE kind of object type, or mixed kinds?
21:21:39 <mtnviewmark> I'm want to rebuild ALL of my haddock documentatino
21:21:40 <jmcarthur> kakos: okay, a list of *any* kind?
21:21:58 <heatsink> kakos: Do you want it to hold _any_ type, or do you want it to hold the type you put in?
21:22:13 <dankna> mtnviewmark: the way I would do it (and it sucks, but...) is to remove my entire cabal directory except for the config file, make sure it's set to build docs, and then reinstall everything
21:22:35 <mtnviewmark> that would hurt, I think
21:22:38 <dankna> yes, it would
21:22:40 <jmcarthur> data Obj = forall a . Object a => Obj a ; data Foo { objects :: [Obj] }  -- kakos :)
21:22:42 <dankna> I don't suggest you do that
21:22:44 <kakos> jmcarthur: A list of *****any******* kind of Object type.
21:22:51 <dankna> but it's the only answer I have for you, I'm not really an expert on cabal
21:23:21 <lispy> kakos: The question is whether the elements of the list are heterogenous or homogenous in type
21:23:23 <kakos> heatsink: It'll be a mixed list of different types of Objects, so yeah, I need it to be _any_ type.
21:23:23 <mtnviewmark> I was thinking something along the lines of: for each package listed in ghc-pkg, ask cabal to unpack that particular package and version, then cd into that dir, cabal configure, cabal haddock, 
21:23:33 <kakos> lispy: Heterogenous
21:23:33 <dolio> This conversation is why quantifiers were invented.
21:23:38 <mtnviewmark> though i think that will put the doc within that location
21:23:48 <lispy> kakos: ah, the usually you would create a wrapper and make a list full of those
21:23:55 <lispy> kakos: But, it's not really a good idea
21:24:16 <jmcarthur> kakos: basically you would do what i said a second ago
21:24:22 <kakos> lispy: That's what I"m still confused about.  Why isn't it?
21:24:27 <kakos> jmcarthur: Okay.  :)  Thanks.
21:24:34 <heatsink> kakos: We generally refer to that as _some_ type, not _any_ type.
21:24:42 <lispy> kakos: Because when you go to examine the elements you don't know what type they are
21:25:12 <lispy> kakos: you can add type class constraints to get around this but it's cumbersome
21:25:14 <kakos> lispy: Well, in this particular case, I don't care what type they are, as long as they have the functionality defined in the Object type class
21:25:15 <dankna> the short answer though is that you should rethink why you want a heterogeneous list and try to design your program to work without one, haha
21:25:54 <jmcarthur> kakos: it's usually, but not always, not useful to do the (data Obj = forall a . Object a => Obj a) pattern
21:25:54 <lispy> kakos: you really want to read the article I linked from Luke Palmer.  He presents an alternative the design you want, one that fits well with the haskell world
21:25:58 <jmcarthur> err
21:26:00 <jmcarthur> *useless
21:26:03 <jmcarthur> not useful
21:26:44 <heatsink> Yeah, the record-of-functions design is a good way to encode OO.
21:26:55 <kakos> lispy: Funnily enough, I was going to ask Luke for help, but he isn't online.  ;)
21:26:59 <lispy> kakos: it's generally a mistake to use type classes the way you would use classes in other languages, FWIW
21:27:45 <jmcarthur> there are times that the existential pattern is not an antipattern, but they are kind of rare in practice
21:28:15 <lispy> jmcarthur: yes.  I suppose the new exception framework is an example
21:28:50 <jmcarthur> lispy: that's kind of a weird example though due to how it uses Typeable, isn't it?
21:29:15 <tmo_> i understand that you can use recursive types to describe data structures like binary trees, but how can you insert/delete data from it?
21:29:23 <lispy> jmcarthur: I have to admit, I'm woefully ignorant to the new exception system other than saying which exception type I want in a handler
21:29:40 <jmcarthur> lispy: i kind of am in the same boat
21:29:42 <lispy> tmo_: you construct a new value
21:30:00 <lispy> tmo_: the run-time will ensure maximum sharing between the original and the new one so it's very cheap
21:30:54 <od_> does anyone know any good sources that talk about boolean set operations over sets of intervals or line segments
21:31:22 <tmo_> btw, how do you learn data structures with haskell?
21:31:33 <lispy> od_: "The Fun of Programming"  <-- a collection of papers about Haskell.  Has a paper about using functions to represent intervals
21:31:52 <od_> sounds cool, thanks
21:32:21 <lispy> tmo_: this is the classic text, I think you can find it for download on the web: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
21:33:33 <allbery_b> haven't seen the book, but his thesis on which the book i sbased is out there
21:37:13 <dolio> The book has (at least) the advantage of having Haskell translations of all the code, if that's all you know.
21:37:40 <dolio> So you won't have to wonder what "Foo * 'a list" means, like someone was here earlier.
21:38:36 <lispy> I'm so grateful that we don't have to use ML syntax
21:38:53 * lispy is a syntax snob
21:40:19 <BMeph> BTW, a gzipped bundle of the programs is : http://www.eecs.usma.edu/webs/people/okasaki/pfds-haskell.tar.gz
21:40:40 <Axman6> tmo_: this is how you might implement a binary tree and insert elements into it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28225#a28225
21:41:31 <lispy> Axman6: how would you do a breadth first traversal?
21:42:07 <Axman6> badly
21:42:19 * lispy noticed his client has an 'conference' mode but has no idea what that means
21:43:34 <heatsink> Is it on?
21:45:18 <lispy> I don't know, I clicked it
21:45:33 <lispy> hmm..yeah it was on...off again
21:45:48 <tmo_> another question
21:45:53 <BMeph> tmo_: The Okasaki thesis is here: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.3080
21:46:31 <Mathnerd314> lispy: it's probably for showing/hiding joins/quits/etc. that are just spam in a large irc channel
21:46:59 <tmo_> i'm scared of developing fragile knowledge of data structures (ie: i'll just see the tree, superficially learn it, but then forget it or take away only a superficial understanding of them)
21:47:18 <lispy> Mathnerd314: I think you're right.  I normally disable those and toggle that mode seems to have made them show up again :(
21:47:39 <tmo_> what would be the best way to gain a deep understanding of data structures?
21:48:31 <heatsink> tmo_: You can test your knowledge by implementing a new data structure that is related to what you've seen before, preferably in the context of an actual project.
21:49:28 <heatsink> Implementing a trie requires you to draw on and go beyond your knowledge of trees.
21:49:40 <ezyang> Does GHC implement the suggested ... context extension for implicit parameters? 
21:51:06 <heatsink> tmo_: Probably, if you can forget all the details about a data structure and still reconstruct an implementation based on high-level principles, you understand it enough.
21:51:45 <applicative> ezyang you mean something other than -XImplicitParams ?
21:51:46 <heatsink> I though GHC removed support for implicit parameters.
21:52:05 <ezyang> applicative: No, I do mean that. 
21:52:22 <ezyang> But the paper suggests that there should be some way to say (?foo : Int, ...) => Int -> Int 
21:52:31 <dcoutts> mtnviewmark: you can enable building of docs but that only affects future builds
21:52:33 <ezyang> where ... can expand to any number of other implicit parameters 
21:52:51 <mtnviewmark> right - I want to regen ALL my docs (using my new haddock!)
21:53:35 <mtnviewmark> I have the docs for all 100+ of my install packages all just working fine --- but now I'd like to regenerate them all with a new (pre-release) haddock
21:54:49 <lispy> mtnviewmark: I think Cabal accepts patches ;)
21:55:00 <mtnviewmark> oy!
21:55:20 <lispy> I know, it's the most annoying answer you can get, but at least it's Open Source so you can do it :)
21:55:22 <mtnviewmark> I'm already deep in one infra. project (haddock), I can't bear another right now!  ;-)
21:55:36 <lispy> oh, you work on haddock?
21:55:39 <lispy> What are you adding?
21:56:12 <mtnviewmark> major overhaul of the output: XHTML, new styling
21:56:14 <applicative> ezyang, Audrey Tang uses "startPage :: (?tPages :: Obj, ?resources :: Obj) => AppConfig -> M Int" 
21:56:17 <dcoutts> mtnviewmark: right we don't have any easy way to install just docs (ie without rebuilding code too), you'd have to do what you suggested about rigging up a script to cabal unpack; cabal configure; cabal haddock
21:56:34 <lispy> mtnviewmark: oh!  I think dons showed me a sneak preview.  I liked 'tibbe' style
21:57:20 <lispy> mtnviewmark: I would have liked Ocean but having a fixed width centered column bugs me
21:57:25 <mtnviewmark> here's the latest: http://www.ozonehouse.com/mark/snap-xhtml/
21:57:40 <mtnviewmark> it isn't fix width, it is maxwidth - 
21:58:09 <dolio> Make sure to fix the weird printing of multi-line signatures while you're in there. :)
21:58:17 <lispy> mtnviewmark: ah.  Is there a way to make a version of it without the max?
21:58:18 <dolio> Multi-line, higher order, that is.
21:59:19 <mtnviewmark> lispy - the new haddock now supports themes - 
21:59:30 <mtnviewmark> you can build all your docs with your own themes if you want!
21:59:41 <dolio> That's pretty snazzy.
22:00:18 <mtnviewmark> if you build it with multiple themes you get a theme switcher at the top 
22:03:17 <lispy> mtnviewmark: I'm happy you're working on it :)
22:03:21 <lispy> mtnviewmark: Will it still have source code links?
22:03:29 <mtnviewmark> yup -- 
22:03:40 <lispy> mtnviewmark: and can you colorize the code snippets that do on the documentation page?
22:04:17 <applicative> wow, swank snap haddocked pages!  Surely the first criterion for haskell web server (etc) projects should be really lame webpage design, though, don't you think?
22:04:54 <lispy> applicative: er?
22:04:55 <dolio> Like, a theme with rotating skull GIFs?
22:05:06 <dolio> And flames.
22:05:33 <lispy> and an animated gif of a stick figure with a shovel?
22:05:38 <dolio> Yes.
22:05:47 <lispy> and a rotating @ sign for emailing the 'web master'
22:06:00 <applicative> lispy, sorry, i was praising "ocean" style as exhibiting unusual design sense.  Too perversely.
22:06:56 <lispy> applicative: hehe
22:07:05 <lispy> Haskell webdesign should be lazy!
22:07:12 <lispy> Must use the CSS monad
22:07:28 <applicative> lazy CSS, that's the ticket
22:08:05 <lispy> mtnviewmark++ -- yay for working on haddock!
22:08:12 <mtnviewmark> thanks
22:08:21 * lispy notes that should be succ foo, not foo++, but ah well
22:08:42 <mtnviewmark> ah - colorizing code snippets in the doc pages would be a new project
22:09:41 <applicative> mtnviewmark there's not a view source option?  
22:09:54 <mtnviewmark> I didn't generate those pages with teh source code 
22:10:10 <mtnviewmark> the source code pages are generated by another tool, not haddock
22:10:15 <mtnviewmark> haddock just has an option to link to them
22:10:25 <mtnviewmark> that will still work with the new styling, should someone do it
22:10:33 <lispy> The source view is, erm paramount, I hope that it still works the same when you're done
22:10:50 <mtnviewmark> identically - only the "souce" link will be styled to match
22:12:27 <applicative> mtnviewmark what highlights the source on hackage?  
22:12:35 <Saizan> hscolour
22:12:43 <applicative> oh of course
22:13:07 <mtnviewmark> and I don't know if hscolour has an API that would allow haddock to easily highlight the <pre> sections
22:13:33 <SailorReality> saizan: im bant from logic, y
22:13:37 <mtnviewmark> it doesn't help that Haddock doesn't know if the documentation writer made a <pre> section because it is haddock code, or a screen session, or ascii art
22:14:02 <mtnviewmark> er, haskell code...
22:14:10 <shachaf> lispy: succ doesn't have a side effect.
22:14:18 <applicative> i only use the terminal version of hscolour, I forgot it has all these options...
22:17:35 <applicative> if you're in the mood for a haskell data-structure drug trip try  pandoc http:/www.whatever.org -r html -w native | hscolour sometime.  
22:17:39 <unkanon> I will ask this here because you guys are more likely to know and I don't know where else to ask: does lambda-the-ultimate have an irc channel?
22:18:46 <gwern> unkanon: I've never heard of one
22:18:56 <gwern> ltu is too varied to really have an irc channel, I'd think
22:19:13 <RyanT5000> anyone have a recommendation on which priority queue implementation to use?
22:19:25 <unkanon> well but there's gotta be a channel where we can talk about language design agnostically
22:19:38 <mtnviewmark> dcoutts - do you know if there is a way to get ghc-pkg to give me the package list in dependency order?
22:20:20 <RyanT5000> mtnviewmark: have you seen 'pkggraph'? i haven't used it, but it attacks that problem
22:20:22 <mtnviewmark> I think I have to build the docs in that order or they won't link correctly
22:20:37 <mtnviewmark> no - I haven't, but I like the idea of it!
22:22:07 <applicative> gwern, there is an ltu channel on freenode.  
22:22:37 <gwern> is it any good?
22:23:02 <unkanon> applicative: what is it?
22:23:24 <applicative> gwern, i'm just going by the evidence of the senses, there are six people, Philippa is one.   Its ltu or #ltu rather
22:23:35 <gwern> so probably not
22:23:54 <unkanon> aww :(
22:24:33 <applicative> gwern, i don't know. unkanon might propose to change that, if it's true. 
22:25:38 <SailorReality> saizan bb
22:29:23 <NetRolller3D> Hello World!
22:30:01 <mauke> greetings
22:30:02 <lambdabot> Hello NetRolller3D!
22:30:06 <NetRolller3D> Tryhaskell.org seems to have gone t*ts-up... it is impossible to type in an opening square bracket.
22:30:43 <shachaf> NetRolller3D: It seems possible over here.
22:31:07 <NetRolller3D> The only way to make lists currently is to go to step3 in lesson 1, and click the lottery numbers.
22:31:28 <mtnviewmark> RyanT5000 - it doesn't actually compute the dependency order - it leaves it to the .dot renderer!  ha ha
22:31:42 <RyanT5000> mtnviewmark: that sounds alright :)
22:32:46 <applicative> NetRolller3D what browser are you using.  
22:32:54 <NetRolller3D> Firefox.
22:33:01 <Axman6> failfox :(
22:33:13 <mauke> where's the webchat on tryhaskell.org?
22:33:26 <NetRolller3D> IE doesn't cut it either...
22:33:31 <NetRolller3D> fails with the same error.
22:33:47 <applicative> NetRolller3D I see, there was such a problem with Opera or IE on the big day a few days ago
22:35:20 <NetRolller3D> Hmm... setting the keyboard to US makes it work. (Normally I use a Hungarian keyboard, where [ is AltGr+F.)
22:35:50 <NetRolller3D> Funnily ] (AltGr+G) remains typeable
22:36:21 <mtnviewmark> score one for JavaScript and not having a complex enough keyboard event model
22:36:29 <applicative> NetRoller3D, I cant reproduce it... I see, maybe it's inadequately internationalized... The Reddit big day might not have revealed that since it was an English site...
22:37:01 <mauke> my AltGr keys work
22:38:16 <NetRolller3D> AltGr+E (Ä) / AltGr+A (ä) is also broken.
22:38:54 <mauke> AltGr+a (ä) sort of works; it says Not in scope: `�'
22:39:03 <mauke> i.e. unicode is broken, but the key itself is fine
22:39:19 <NetRolller3D> mauke: What keyboard layout are you using?
22:39:29 <mauke> a modified en_US layout
22:39:34 <NetRolller3D> AltGr+D and AltGr+F are also broken.
22:39:57 <NetRolller3D> AltGr+C is being used as a linefeed instead of &.
22:40:36 <NetRolller3D> AltGr+B ({) and AltGr+N (}) also suffer.
22:40:51 <mauke> your computer is doing something weird
22:42:47 <NetRolller3D> Apparently JavaScript dislikes Hungarians?
22:42:58 <NetRolller3D> Maybe I should try BaliScript or SumatraScript?
22:44:10 <DANYAL> if any one want free shell join #netcorp
22:46:52 <applicative> NetRolller3D, so the last several errors arose even with the US setting?  
22:47:08 <mtnviewmark> I'll take cowry ...
22:47:19 <applicative> nautilis here
22:48:21 <DANYAL> if any one want free shell join #netcorp
22:50:44 <mauke> DANYAL: stop advertising
22:51:04 * hackagebot usb 0.5 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.5 (BasVanDijk)
22:51:06 * hackagebot usb-enumerator 0.1 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-enumerator-0.1 (BasVanDijk)
22:51:08 * hackagebot usb-safe 0.8 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.8 (BasVanDijk)
22:54:28 <ManateeLazyCat> How to link modules? I just found linkModules, but it's hide in Linker.lhs
22:57:09 <ManateeLazyCat> ghc developer sleep?
23:02:47 <lispy> ManateeLazyCat: yeah, many of them are in the UK
23:02:56 <lispy> ManateeLazyCat: and I think it's not quite morning yet for them
23:04:23 <ManateeLazyCat> lispy: Unfortunately, like c.h.o always down when i awake.
23:05:02 <lispy> ManateeLazyCat: yeah, it really goes down a lot.  They are working to correct this problem with a long term solution
23:05:24 <lispy> ManateeLazyCat: a new sever has been acquired but its not ready yet
23:05:43 <FauxFaux> c.haskell.org?
23:06:12 <ManateeLazyCat> lispy: I'm use GHC-API build my own dynamic-linking library, and some API i want is hide, unfortunately.
23:06:25 <lispy> ManateeLazyCat: hide?
23:06:30 <lispy> ManateeLazyCat: oh, hidden?
23:07:39 <ManateeLazyCat> lispy: Example, I want dynamic-liking some symbol, but some symbol like "Data.List.reverse" is re-export from "GHC.List.reverse", so i need some function to find where the symbol's define location.
23:08:08 <ManateeLazyCat> lispy: Infact, it's feature of ghci's ':info" 
23:08:27 <lispy> ManateeLazyCat: Hmm...You're well beyond my area of expertise.
23:08:37 <lispy> I don't really know the GHC internals
23:08:39 <ezyang> Hmm, implicit parameters are not affected by qualified. This seems problematic. 
23:08:45 <ManateeLazyCat> lispy: I need linkModules to link "Data.List" before i use GHC.parseName parse "Data.List.reverse"
23:08:58 <dibblego> is it usual to write a monadic version of a function then write a non-monadic version by using m=Identity?
23:09:28 <lispy> dibblego: I don't tend to do that, but I guess you could
23:09:40 <lispy> dibblego: Some monads can make sequencing overly emphasized
23:09:49 <lispy> dibblego: Er, sometimes using monads can make ...
23:10:36 <ManateeLazyCat> lispy: hs-plugins use many own code, easy to break in new version GHC, so i need use GHC-API re-implement it. direc-plugins looks great, but can't handle re-export and "perfect type-check". Hint can do above, but use byte-code instead compile-code, too slow.
23:10:57 <lispy> ManateeLazyCat: Right.
23:11:20 * ManateeLazyCat pasted "Manatee.Plugins" at http://paste2.org/get/927996
23:11:25 <lispy> ManateeLazyCat: IMO, I would get GHC to expose the bits that hs-plugins needs so that they share code
23:12:12 <ManateeLazyCat> lispy: Infact, most hs-plugins code has merge in GHC-API
23:12:15 <lispy> ManateeLazyCat: but outside of reading some papers written by dons, I don't really know how it all works
23:12:27 <ManateeLazyCat> lispy: Infact, pretty simple.
23:12:35 <lispy> That's good :)
23:12:49 <lispy> Simple is generally good in these things
23:13:37 <ManateeLazyCat> lispy: When you pass some symbol, such as "Data.List.reverse", it first need GHC-API parse depend graphics first, then link depend, then we can use Linker.getHValue get symbol value.
23:13:55 <ManateeLazyCat> lispy: Then use unsafeCoerce force value to special type.
23:14:18 <ManateeLazyCat> lispy: Of course, I will do a type-check before unsafeCoerce, so unsafeCoerce is perfect-safe.
23:14:24 <lispy> ah
23:14:28 <lispy> I was going to ask :)
23:14:41 <ManateeLazyCat> lispy: Infact, dons' principle is pretty simple, just hs-plugins over head. :)
23:15:05 <ManateeLazyCat> lispy: hs-plugins try implement everything without GHC-API, then make logic looks very complicated.
23:15:35 <ManateeLazyCat> lispy: Then hs-plugins easy to break with new GHC.
23:16:00 <lispy> GHC-API wasn't even thought of yet when hs-plugins was written
23:16:07 <ManateeLazyCat> lispy: Yes.
23:16:36 <ManateeLazyCat> lispy: I guess some dynamic-liking API is copy from hs-plugins. :)
23:18:39 <ManateeLazyCat> lispy: The solution to parse re-export symbol like this : GHC.parseName -> Name -> GHC.getInfo -> TyThing -> GHC.getName -> NewName -> Name.pprNameLoc
23:19:40 <lispy> Yeah, I guess hint has to do a lot with exports and renaming.  I've heard gwern talk about that
23:20:08 <ManateeLazyCat> lispy: Hint infact is wrap ghci.
23:20:34 <ManateeLazyCat> lispy: Of course, ghci will linking module when do ":info"
23:20:47 <ManateeLazyCat> lispy: But i haven't research hint code recently.
23:21:29 <ManateeLazyCat> lispy: IIRC, hint code will convert to "byte-code", then evaluation byte-code, but it's will performance issue with byte-code.
23:21:56 <ManateeLazyCat> lispy: I need some way to recompile source code to native code, then linking native code in runtime.
23:23:09 <lispy> ManateeLazyCat: hmm
23:23:27 * ManateeLazyCat pasted "Manatee.Plugins" at http://paste2.org/get/928003
23:23:27 <ManateeLazyCat> lispy: You can see how to implement with above code, haven't finish. 
23:23:30 <lispy> ManateeLazyCat: This is one of the strengths of hs-plugins of course.  Has dons been able to help you with it?
23:23:47 <ManateeLazyCat> lispy: dons too busy.
23:23:56 <lispy> yeah, I figured
23:24:07 <ManateeLazyCat> lispy: I even can't contact him.
23:24:16 <lispy> He's on vacation right now
23:24:43 <ManateeLazyCat> lispy: Infact, i try to fix hs-plugins myself, last, i found it's wrong way, should use GHC-API.
23:24:51 <lispy> I have more haskell hacking that I want to do than time to do it; so I think I understand his situation
23:25:04 <ManateeLazyCat> lispy: Otherwise, hs-plugins will break again when new GHC release.
23:25:06 <lispy> but ghc-api is bytecode, right?
23:25:26 * ManateeLazyCat pasted "Manatee.Plugins" at http://paste2.org/get/928005
23:25:27 <ManateeLazyCat> lispy: You can use above code test my Plugin.hs 
23:25:31 <lispy> Can you isolate the parts that break on upgrade and link to the GHC code?
23:25:36 <ManateeLazyCat> lispy: Now i haven't implement runtime "type-check".
23:26:55 <Gracenotes> oh my that looks unsafe
23:26:57 <ManateeLazyCat> lispy: What you mean?
23:27:08 <ManateeLazyCat> Gracenotes: Yes, i haven't implement "type-check" part.
23:27:33 <dankna> ManateeLazyCat: Are you aware of my direct-plugins package?  It sounds similar to what you are doing.
23:27:40 <dankna> It might, at the very least, be useful example code to you.
23:27:40 <ManateeLazyCat> Gracenotes: I will implement "runtime type-check" make sure it safe even symbol isn't the type you expect.
23:27:47 <ManateeLazyCat> dankna: Yes.
23:28:00 <lispy> ManateeLazyCat: It just seems that if GHC keeps changing something and breaking hs-plugins, maybe you can link directly to that thing and compile in their version so that it doesn't keep breaking
23:28:16 <ManateeLazyCat> dankna: But direct-plugins is not enough.
23:28:28 <dankna> May I ask for more details of that?  I'd like to improve it if possible.
23:28:30 <ManateeLazyCat> dankna: re-export, runtime type-check.
23:28:33 <dankna> hmmm
23:28:37 <dankna> yes, okay, I see
23:28:47 <ManateeLazyCat> dankna: And you haven't implement package name guess.
23:28:59 <dankna> true - I don't like the fact that I have to guess at it
23:29:06 <ManateeLazyCat> dankna: direct-plugins always need user input complete package name.
23:29:16 <dankna> yeah, I remember that now
23:29:31 <dankna> the "right" way would be to query the ghc-pkg database
23:29:42 <ManateeLazyCat> dankna: Infact, i steal code from your unsafeLoad.
23:29:46 <dankna> oh, good
23:29:52 <ManateeLazyCat> dankna: Don't need ghc-pkg 
23:30:13 <ManateeLazyCat> dankna: http://paste2.org/get/928005 look lookPackageName
23:30:25 <ManateeLazyCat> dankna: Just GHC-API is enough.
23:30:31 <dankna> nice
23:30:47 <ManateeLazyCat> dankna: Now i'm try to fix your re-export problem, unfortunately, some API is hidden.
23:31:02 <dankna> yeah
23:31:06 <ManateeLazyCat> dankna: The solution to fix re-export problem : GHC.parseName -> Name -> GHC.getInfo -> TyThing -> GHC.getName -> NewName -> Name.pprNameLoc
23:31:42 <dankna> ManateeLazyCat: dankna@gmail.com is my email address - when you get this working please let me know so I can work on integrating your code back into mine :)
23:31:43 <ManateeLazyCat> dankna: Example, when you pass "Data.List.revese" to GHC.getInfo, it will get newName by GHC.getName.
23:32:05 <dankna> nice.  good job figuring all that out.
23:32:12 <ManateeLazyCat> dankna: Then you can use Name.pprNameLoc get the *real* define location.
23:32:27 <dankna> gotcha
23:32:50 <ManateeLazyCat> dankna: Then we can convert "Data.List.reverse" to "GHC.List.reverse"
23:32:57 <dankna> right
23:33:03 <ManateeLazyCat> dankna: So we will fix re-export problem.
23:33:16 <dankna> great
23:33:31 <ManateeLazyCat> dankna: I have research your loadDynmic code, IMO, it's limit, not all type can convert to Typeable.
23:34:01 <ManateeLazyCat> dankna: So i try do "runtime type-check" with compiler's AST code, then all type that compiler support can type-check safety.
23:34:26 <ManateeLazyCat> dankna: Then we just *one* safety load function, don't need "unsafeLoad" and "loadDynmic".
23:34:34 <dankna> hmm
23:34:45 <dankna> right, if it works
23:35:25 <ManateeLazyCat> dankna: IMO, you do some reflect that convert from value to type, then comapre type. Why not reverse? Convert type with compiler AST code, then compare those AST code?
23:35:59 <dankna> no - symbolInterfaceType doesn't start with a value
23:36:03 <dankna> it looks in .hi files
23:36:08 <dankna> for the declared type
23:36:15 <ManateeLazyCat> dankna: Yeap, we need .hi files.
23:36:28 <dankna> I see what you're saying
23:36:34 <dankna> it makes sense
23:37:05 <ManateeLazyCat> dankna: Because .hi file have type information, then we can use .hi file for runtime type-check.
23:37:09 <dankna> yes
23:37:09 <ezyang> How do I distinguish between polymorphic and monomorphic recursion? The types don't seem to tell the difference. 
23:37:21 <ManateeLazyCat> dankna: Then not just Typeable, every type that compiler support can check.
23:37:40 <mauke> ezyang: remove the type signature; if it doesn't compile anymore, it was polymorphic
23:38:01 <ezyang> mauke: Do you mean Monomorphism restrictino? 
23:38:05 <dankna> mauke: haha
23:38:06 <mauke> no
23:38:11 <ezyang> ah, hm. 
23:38:15 <ManateeLazyCat> dankna: Do you mind big change of direct-plugins?
23:38:28 <ezyang> I'm looking at “7.8.3.3. Implicit parameters and polymorphic recursion” 
23:38:40 <ManateeLazyCat> dankna: If you don't like, i will build my own package, then share code with you.
23:38:47 <mauke> > let foo 0 x = show x; foo n x = foo (n - 1) (x,x) in  foo 2 'a'
23:38:48 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
23:38:52 <ezyang> I haven't really found a good explanation of polymorphic recursion in haskell... 
23:39:01 <dankna> Manatee: I wrote the code so that others could use it; by all means release your own version.  But please change the name.
23:39:05 <mauke> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (x,x) in  foo 2 'a'
23:39:06 <lambdabot>   "(('a','a'),('a','a'))"
23:39:12 <mauke> spot the difference
23:40:09 <ezyang> And it's possible the two aren't related. 
23:40:19 <ManateeLazyCat> dankna: Ok
23:40:28 <ManateeLazyCat> dankna: Infact, i build my own plugins for my gtk2hs project.
23:40:32 <dankna> *nod*
23:41:04 <ManateeLazyCat> dankna: Thanks for your direct-plugins, save much time.
23:41:09 <dankna> very welcome!
23:43:17 <ManateeLazyCat> dankna: http://paste2.org/get/928005 you can merge my lookupPackageName to your direct-plugins, then user don't need write package name explicitly.
23:43:45 <dankna> yes, I'd love to
23:43:57 <ManateeLazyCat> dankna: I will send mail to you after i finish "re-export" and "fully type check" features.
23:44:03 <dankna> great
23:44:25 <ManateeLazyCat> dankna: Did you try to fix hs-plugins?
23:44:39 <dankna> I tried, but I couldn't understand all the different versions of things that were in it
23:44:45 <dankna> it just felt like there had to be an easier way
23:45:17 <ManateeLazyCat> dankna: Me too, i can make hs-plugins compile with ghc-6.12, but some hs-plugins break with ghc-6.12, that can't link module correctly.
23:45:48 <dankna> yeah
23:46:03 <ManateeLazyCat> dankna: I always got "unknown symbol", i think some depend modules haven't link in memory correctly.
23:46:15 <ManateeLazyCat> dankna: Then i research your direct-plugins, very cool. :)
23:46:49 <dankna> :)
23:47:05 <ManateeLazyCat> dankna: But i 'hate' i need write package name (include version number) when call unsafeLoad.... :)
23:47:33 <dankna> indeed...
23:47:43 <PeakerWork> quicksilver: you there?
23:48:15 <ManateeLazyCat> dankna: lookPackageName step : Packages.lookupModuleInAllPackages flags (Module.mkModuleName moduleName) found package that include moduleName.
23:48:38 <ManateeLazyCat> dankna: If package is [] or hidden module, return Nothing
23:49:21 <ManateeLazyCat> dankna: If found module in multiple package, such as "base", "base-3.3.0.2", then it try return first expose package name.
23:49:36 <dankna> hmm
23:49:44 <ManateeLazyCat> dankna: Packages.lookupModuleInAllPackages is key of lookupPackageName
23:49:49 <dankna> I see
23:50:24 <ManateeLazyCat> dankna: I think you can merge it easily since i steal code from your direct-plugins. :)
23:50:39 <dankna> hope so :)
23:51:12 <kmc> woah, i did not know about this direct-plugins
23:51:28 <kmc> looks nice
23:51:31 <dankna> thanks!
23:51:42 <ManateeLazyCat> kmc: It's use GHC-API re-implication hs-plugins's principle.
23:52:37 <ManateeLazyCat> dankna: Do you know any way to link module? I found linkModules in Linker.lhs, unfortunately, it's hidden in Linker
23:52:53 <ManateeLazyCat> dankna: Do you know any other API can link module?
23:53:37 <dankna> no, I don't know how to do that
23:53:44 <ManateeLazyCat> dankna: Currently, if i use GHC.getInfo to parse re-export problem, i need link module first, otherwise i always got "Top Level: Not is scope "Data.List.reverse". 
23:53:52 <dankna> hmm
23:53:55 <kmc> where's the best place to learn how to use GHC API?
23:54:00 <dankna> the source code
23:54:04 <kmc> :/
23:54:06 <ManateeLazyCat> kmc: Source code
23:54:09 <kmc> fair 'nuff
23:54:28 <ManateeLazyCat> kmc: GHC-API is huge, and poor documentation....
23:54:38 <ManateeLazyCat> kmc: Many function haven't any comment....
23:55:53 * ManateeLazyCat Hmm, looks i need explore those myself, or ask GHC export at #ghc......
23:59:27 <ManateeLazyCat> dankna: Do you have any other GHC-API resource? except source code.....
