00:05:21 <Saizan> there's no way to import a constructor without importing the type, right?
00:05:50 <Cale> Saizan: pretty sure
00:06:20 <ivanm> what's the correct way to pattern match on a particular field of a record type?
00:06:45 <ivanm> I thought it was possible to do "f (foo{bar = baz}) = ...", but ghci doens't like it :s
00:10:04 <ivanm> oh, I have to use foo@(Foo{bar = baz})
00:11:48 <Saizan> foo@Foo{bar=baz} is ok too
00:13:22 <ivanm> oh, doesn't transformers have a State class like mtl did?
00:13:52 <ivanm> I was planning on doing a newtype so that outside the module where I define it people couldn't tell what the internals were (even though in this case "people" == "me")
00:14:53 <Saizan> that's in monads-fd or monads-tf
00:15:43 <ivanm> aha
00:15:48 <Baughn> ivanm: Ah.
00:15:49 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
00:15:55 <Baughn> @clear
00:15:55 <lambdabot> Messages cleared.
00:16:00 <ivanm> Baughn: yeah, a bit of a weird situation
00:16:20 <ivanm> Baughn: btw, is there any chance you could fix multi-line comments so that indentation works properly in them?
00:16:21 <krainboltgreene> @clear
00:16:22 <lambdabot> Messages cleared.
00:16:28 <krainboltgreene> :o
00:17:00 <Baughn> ivanm: Sure, I'm working on a total overhaul of the indenter now.
00:17:04 <ivanm> i.e. if I indent the first line in a paragraph and mod-q, I want the entire paragraph indented (even if I have to do the second line manually as well); currently mod-q keeps un-indenting lines after the first one, even after it's indented
00:17:06 <ivanm> Baughn: cool
00:17:24 * Baughn might call it HIME
00:17:26 <ivanm> krainboltgreene: well, now you'll never know what people told you since you last spoke!
00:17:38 <ivanm> Baughn: in a nod to "Get Smart"?
00:17:52 <Baughn> ivanm: No, in a silly multi-language pun
00:17:52 <Veinor> I need to figure out what Rank 2 types 'mean'
00:18:20 <ivanm> Baughn: what's the pun? http://en.wikipedia.org/wiki/Hime ? :p
00:18:35 <Baughn> Yes
00:18:53 <ivanm> oh... I was joking with that link...
00:19:10 <ivanm> Veinor: the types have a rank of 2, duh
00:19:11 <ivanm> ;-)
00:19:13 <Baughn> "Haskell interaction modes for emacs"
00:19:16 <Baughn> *mode
00:19:23 <Veinor> ivanm: :|
00:19:28 <ivanm> Saizan: which of those two is recommended? I assume monads-tf requires 6.10+ ?
00:19:30 <c_wraith> Veinor, rank-2 means the type polymorphic in the callee, rather than polymorphic for the caller.
00:19:32 <ivanm> Baughn: aha!
00:19:35 <ivanm> as in slime?
00:19:40 <Baughn> Exactly
00:19:45 <Baughn> Very much as in slime.
00:19:52 <ivanm> yeah, shime doesn't roll off the tongue that well... :s
00:19:54 <kmc> ivanm, did you end up doing State with save/run/restore?
00:19:59 <ivanm> kmc: doing it now
00:20:08 <kmc> ivanm, seems like the long way round to me
00:20:22 <ivanm> what's the shorter way then?
00:20:41 <kmc> evalState on your subcall
00:21:08 <kmc> :t \m -> get >>= evalState m
00:21:09 <lambdabot> forall (m :: * -> *) a b. (MonadState a m) => State a (m b) -> m b
00:21:22 <ivanm> kmc: yeah, I was thinking about that as well
00:21:31 <ivanm> @type evalState
00:21:32 <lambdabot> forall s a. State s a -> s -> a
00:21:33 <kmc> :t \m -> get >>= (return . evalState m)
00:21:34 <lambdabot> forall (m :: * -> *) a a1. (MonadState a m) => State a a1 -> m a1
00:21:55 <ivanm> kmc: that way though, I'd have to be careful and only return _new_ parts of the sub-state that I care about
00:21:55 <kmc> that's the one i think
00:22:08 <kmc> well, maybe i don't understand what you want to do
00:22:22 <ivanm> yeah ;-)
00:22:28 <ivanm> do you really want me to go into details?
00:22:49 <kmc> so you want to keep some but not all of the state change?
00:22:53 <ivanm> yes
00:23:07 <kmc> ah
00:23:17 <kmc> do you need the result value too?
00:23:28 <ivanm> nah, it'll probably be just ()
00:23:49 <kmc> ok
00:24:21 <ivanm> if we consider it as a tuple, then I just want the snd value kept
00:24:24 <ivanm> and the first kept as-is
00:24:33 <ivanm> (it's actually a record data structure, not a tuple though)
00:25:56 <kmc> so something like «do { s <- get; s' <- execState act s; put (merge s s')»
00:26:23 <kmc> that feels a bit cumbersome too
00:26:34 <ivanm> yup
00:26:42 <ivanm> maybe use modify....
00:26:46 <Amagineer> Why is the standard list argument name xs?
00:26:48 <kmc> you can give more details if you like / if you think i'll give useful advice
00:26:52 <kmc> Amagineer, it's the plural of x
00:27:03 <ivanm> Amagineer: and x is a common variable name in maths
00:27:06 <ski> (kmc : i learned `(f .) . g' by deriving it ..)
00:27:22 <Amagineer> Wow, I can't believe I never realized that...
00:27:58 <ivanm> kmc: this is for graphviz: http://hackage.haskell.org/packages/archive/graphviz/2999.9.0.0/doc/html/Data-GraphViz-Types.html#t%3ADotGraph
00:28:01 <ski> > let xss = [[0,1,2,3],[4,5,6],[7,8],[9],[]] in concat xss
00:28:02 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
00:28:38 <ivanm> I want to walk through this data structure (and also the generalised one in a different module, so I'm writing this state stuff as a separate module generic enough to be re-used) and build a Node -> Attributes mapping
00:28:48 <ivanm> however, I also want to take the global attributes into account
00:29:07 <kmc> ivanm, btw i love this library :)
00:29:20 <ivanm> so I don't want to keep those around after a recursive call, since they're specific to a subgraph
00:29:22 <ivanm> kmc: :D
00:29:32 <kmc> thanks for working on it :)
00:30:01 <ivanm> kmc: would I dissapoint you terribly if I use a record-based structure for all the FGL -> a functions in Data.GraphViz rather than passing all those functions around?
00:30:39 <kmc> hmm?
00:30:42 <ivanm> (that's been annoying me recently)
00:30:58 <ivanm> atm, graphToDot  :: Graph  gr => Bool  -> gr a b -> [GlobalAttributes] -> (LNode  a -> Attributes) -> (LEdge  b -> Attributes) -> DotGraph  Node
00:31:15 <kmc> i haven't used the fgl interface yet
00:31:31 <ivanm> I want to be able to say something like: graphToDot :: Graph gr => GraphvizParams a b -> gr a b -> DotGraph Node
00:31:34 <ivanm> ahhh, fair enough
00:31:56 <kmc> yeah, i prefer the second interface by a fair bit
00:32:05 <ivanm> this approach should also allow me to combine graphToDot and clusterGraphToDot, etc. (rather than just having graphToDot call clusterGraphToDot under the hood)
00:32:06 <ivanm> good-o
00:32:07 <kmc> especially if there's a sensible default for that record
00:32:14 <kmc> so i can override only the bits i care about
00:32:15 <ivanm> yup
00:32:32 <kmc> also, having a random bool flag floating there is annoying, better for it to be a named field
00:32:40 <ivanm> yeah
00:33:02 <kmc> cool :)
00:33:04 <ivanm> I have to keep the auto-detection ones separate because of the extra "Ord b" constraint though :(
00:33:49 <ivanm> kmc: anyway, that's why I'm trying to do this whole "keep only part of the state" stuff
00:34:04 <ivanm> I've been putting off doing this for a couple of months now, and should sit down and finish it off :s
00:35:10 <ivanm> Peaker: what's the general recommendation regarding monads-fd vs monads-tf?
00:35:56 <Peaker> ivanm, I don't know if there is one, I think TF's are more trendy nowdays :)
00:36:11 <ivanm> but they require 6.10+, right?
00:36:30 <ivanm> I prefer them as well, but up till now I've kept the code 6.8-compatible...
00:40:54 * ivanm -> dinner
00:51:07 <elliottt> anyone here have any experience with the SDL binding?
00:51:12 <Peaker> elliottt, Yeah
00:51:17 <elliottt> great :)
00:51:30 <elliottt> so, i'm trying to use it to load images for open gl textures
00:51:35 <elliottt> but, i can't get at the pixel data
00:52:05 <elliottt> do you know if there are any work arounds for this, or if they're planning to expose the pixel data in the future?
00:53:21 <Peaker> elliottt, Oh, haven't dealt with any of that.. Though it's not hard to add stuff to the FFI bindings
00:53:29 <Peaker> elliottt, Not sure how to expose a C array like that though
00:53:56 <elliottt> yeah.  i didn't want to have to maintain a fork, and i wasn't sure if they wanted to expose the pointer to the user.
00:54:36 <Peaker> elliottt, Lemmih is very responsive to patches :)
00:54:59 <elliottt> cool.  well, i'll pull the darcs version, and see if i can get what i'm interested in working :)
00:55:22 <elliottt> it would be really nice to be able to use SDL_image to load images, instead of doing that separately
00:55:40 <Peaker> How do people load GL textures in general?
00:56:16 <elliottt> you write a loader that gets it into the format that opengl likes
00:56:28 <Baughn> First you need to figure out what format opengl likes
00:56:32 <Baughn> This is secret knowledge.
00:56:35 <elliottt> quite right :)
00:56:54 <Peaker> mipmap fun
00:57:05 <Baughn> For example, DF's fully standard opengl code only works on nvidia cards.
00:57:13 <Peaker> DF?
00:57:32 <Baughn> ..dwarf fortress. It's just the example I'm used to.
00:58:04 <elliottt> Baughn: that is just silly.
00:58:19 <Baughn> elliottt: I agree. Nevertheless..
00:58:40 <elliottt> :)
00:58:49 <elliottt> hssdl darcs repo seems to be broken
01:01:02 <elliottt> gets about halfway through, then fails to get a patch
01:01:16 <Peaker> :-P
01:01:21 <elliottt> :)
01:01:40 <elliottt> oh well, i'll try again tomorrow :)
01:01:53 <augur> hello peoples.
01:02:04 <augur> i need opinions on a matter.
01:02:24 <Peaker> On a matter of opinion?
01:02:33 <Baughn> It surely matters.
01:02:35 <augur> indeed!
01:03:40 <augur> im building an inference engine that employs pattern matching. it will allow you to make inference rules conditioned in various ways
01:05:05 <Mathnerd314> augur: this sounds incredibly interesting! tell us more.
01:05:28 <augur> including logical operations regarding the patterns in question. for instance, in a haskellish mode, you might have a pattern like "f 0 = 3" or whatever
01:05:47 <Amagineer> Can one pattern match based on the records in an object?
01:06:08 <augur> but, in haskell, there's no way, afaik, to have a pattern that is explicitly undefined for only a particular item. if the entire pattern is "f 0 = 3", its undefined for everything but 0
01:06:21 <augur> but there's no way to make it /defined/ for everything but 0
01:06:29 <kmc> Amagineer, there are patterns for records, yes
01:06:32 <kmc> what do you mean by "object"?
01:06:46 <Amagineer> Er, sorry, meant a type
01:06:53 <Baughn> An ADT, presumably..
01:07:05 <kamatsu> augur: sounds interesting
01:07:05 <augur> at least not without guards, i think. f n | n != 0 = 3
01:07:09 <augur> or whatever
01:07:27 <Peaker> augur, just use error
01:07:31 <Baughn> augur: f 0 = undefined
01:07:38 <augur> Baughn: oh you cheater you :P
01:07:39 <Saizan> augur: f 0 = undefined; f _ = 3
01:07:45 <kmc> Peaker, when I did OpenGL in Haskell forever ago, i used this library "milfoh"
01:07:51 <kmc> to load textures
01:07:57 <kmc> it's not on hackage and its website seems to be broken :/
01:08:04 <augur> ok ok fine you can do it in haskell by making the undefinedness explicit
01:08:07 <augur> anyway
01:08:43 <augur> so my question i suppose is, assuming im probably going to have something like the guards _anyway_, at least ones of relatively simple complexity, do you think it would make sense to also have some sort of, value-level operations?
01:09:21 <augur> e.g. instead of    f n | n != 0 = 3,   something like   f (~n) = 3
01:10:16 <Saizan> f (~0) = 3, you mean?
01:10:24 <augur> er, yes, sorry ;)
01:11:08 <Saizan> i don't think i've ever missed that
01:11:30 <Mathnerd314> augur: what about something like f (n : ~0) = n+3
01:11:39 <Saizan> http://portal.acm.org/citation.cfm?id=1016863 <- you made me thing of this though
01:11:40 <Peaker> augur, I think explicit undefinedness is nicer
01:11:45 <ski> you mean "negation patterns" ?
01:12:11 <augur> ski: maybe, but not just. for instance it could be disjunctive patterns. e.g. f (0|1) = 3
01:12:14 <ski> Mathnerd314 : `f (n @ ~0) = n + 3' ?
01:12:21 <augur> or arbitrarily complex combinations of such things
01:12:24 <Saizan> mh, ~ would have been useful in my current module though :)
01:12:33 <Mathnerd314> ski: yeah, like that.
01:12:40 <augur> Saizan: which module is that, ey?
01:13:06 <Saizan> augur: some internal cabal-install thing, the dependency resolver
01:13:12 <augur> ahh
01:13:18 <augur> you and your dependency resolver
01:13:54 <Mathnerd314> ski, augur: and f n@0|1 = 3 is longhand for f 0|1 = 3
01:13:55 <ski> augur : so, are you asking whether to include lots of pattern-specific constructions ?
01:14:24 <ski> Mathnerd314 : the former binds `n' (fixing syntax errors), the latter doesn't
01:15:13 <augur> im just wondering what peoples opinions on of having the ability to reduce big logical expressions to compressed ones
01:15:17 <Mathnerd314> ski: yeah, but that should only be needed if you have more than one variable (otherwise it can be inferred :p)
01:15:57 <Mathnerd314> augur: explain point-free programming
01:16:53 <Saizan> augur: | patterns tend to be asked for regurarly by newcomers here
01:17:07 <ski> Mathnerd314 : what can be inferred ?
01:17:17 <Mathnerd314> ski: the variable name
01:17:27 <augur> Saizan: ok? 
01:17:58 <Saizan> augur: ?
01:18:05 <ski> Mathnerd314 : i hope you're not suggesting something similar to atrocities like conflating `f' and `f(x)' (or `x^2' and `\x -> x^2') ..
01:18:29 <Mathnerd314> ski: well, one deduces that x is not in scope...
01:18:32 <augur> Saizan: well, what does guard patterns being asked for regularly by newcomers have to do with this as such?
01:18:54 <Mathnerd314> ski: or uses a naming convention of single-letter variables always being free
01:18:57 <ski> augur : example of "reduce big logical expressions to compressed ones" ?
01:19:12 <Saizan> augur: | was meant to refer to (0|1) not guards
01:19:12 <Peaker> Mathnerd314, free for which closure?
01:19:23 <augur> Saizan: oh, ok.
01:19:25 <ski> Mathnerd314 : that sounds like something one would not want to have, in a language
01:19:29 <Mathnerd314> Peaker: global
01:19:39 <ski> (where "one" means "sane persons" ;)
01:19:47 <ski> there is no global
01:20:20 <augur> ski: well, i suppose if you have a conjunction of inequalities, x != 1 && x != 3 && x != 5 that could reduce to x != (1|3|5)
01:20:21 <Mathnerd314> ski: ok, anything beyond top-level functions
01:21:10 <Peaker> all (x /=) [1,3,5]
01:21:15 <Mathnerd314> ski: where by "top" I mean file
01:21:24 <Mathnerd314> Peaker: that's longer
01:21:40 <augur> Peaker: yes, well, that would mean adding even *more* to my inference engine in the way of complexities
01:21:46 <ski> Mathnerd314 : say one day we gain an ML-like module system. also say that we can dynamically create modules inside functions (e.g. to pass to a module function, to get another module as result) .. here the "top-level functions" inside the (inner) module isn't really "top-level"
01:21:49 <Peaker> Mathnerd314, No token in there is noise though
01:22:20 <ski> Mathnerd314 : i just don't think we should make that kind of hard distinction between "top-level" or not
01:22:27 <augur> now i wouldnt have just unification rules and convenient shorthands, i'd need quantification in there somehow maybe, and functions or sommat
01:22:53 <Mathnerd314> augur, Peaker: what about some perl thing I recall like x != all(1 3 5)
01:22:57 <ski> augur : hm, now `x != (1|3|5)' is something completely different to disjunction patterns
01:23:18 <ski> augur : `x != (1|3|5)' is more similar to a kind of control (side-)effects
01:23:37 <Peaker> Mathnerd314, I don't know, I like the current Haskell way of doing it
01:23:57 <augur> ski: perhaps this is true. i dont know.
01:24:05 <Mathnerd314> ski: computation in the list monad, folded together under the "and" monoidal operation
01:24:18 <ski> or computations in the `Cont Bool' monad
01:24:39 <ski> (or rather `Cont Any' or `Cont All' .. but ..)
01:24:45 <Mathnerd314> ski: Cont is too complicated :p
01:24:59 <ski> why you say that ? :)
01:25:23 <Mathnerd314> ski: it's too general
01:25:36 <Peaker> general usually implies simple
01:25:48 <augur> "any" is an interesting quantifier in natural language.
01:25:57 <augur> not quite "some", not quite "all"
01:26:20 <Mathnerd314> ski: whatever, find a good syntax for it
01:26:23 <kmc> ♥ Cont
01:26:37 <Mathnerd314> ^ you too, kmc
01:26:42 <augur> ♥ Coq
01:26:51 <kmc> yes
01:26:55 <kmc> i heart coq
01:27:02 <augur> since we're saying things with humorous alternative readings ;P
01:27:25 <Peaker> @type callCC
01:27:26 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
01:28:54 <Mathnerd314> anyways, augur, were your questions answered?
01:29:09 <augur> Mathnerd314: no, but thats ok ;)
01:29:42 <kmc> is there a fundamental obstacle to having disjunctive patterns in Haskell? or to having conjunctive patterns (i.e. extending the syntax from x@p to p@p)
01:31:54 <ski> > evalCont $ do x <- Cont (`any` [2,3,5]); return (x /= 3)
01:31:56 <lambdabot>   True
01:32:08 <ski> > evalCont $ do x <- Cont (`all` [2,3,5]); return (x /= 3)
01:32:10 <lambdabot>   False
01:32:18 <ski> > evalCont $ do x <- Cont (`all` [2,3,5]); return (x /= 4)
01:32:19 <lambdabot>   True
01:33:17 <ski> augur : `any' behaves like `all' in positive context, and like `some` in negative context, iiuc
01:33:34 <augur> ski: yes, indeed it does. modulo focus issues.
01:33:43 <augur> but its not quite negative contexts
01:33:47 <augur> its downward entailing contexts
01:33:58 <ski> Peaker : my use of `Cont' more corresponds to `shift' and `reset', rather than `callCC'
01:34:22 <Peaker> @type shift
01:34:23 <lambdabot> forall a. (Bits a) => a -> Int -> a
01:34:26 <Peaker> @type reset
01:34:27 <lambdabot> Not in scope: `reset'
01:34:36 <Peaker> ski, I don't know those functions. Cont still boggles me a bit :)
01:34:44 <ski> kmc : not that i know .. OCaml has disjunctive patterns, e.g. (and SML/NJ as well, iirc)
01:35:10 <augur> how it is that you get downward entailment to be the thing that matters is anyones guess
01:35:19 <ski> well, i'd really want `Cont2' to express them properly .. too bad lunabot has died
01:35:41 <ski> i suppose we can possibly do with the more restricted `Cont', in this case
01:35:43 * ski tries
01:35:47 <Mathnerd314> ski: hpaste is up
01:36:04 <ski> .. yes ?
01:36:18 <Mathnerd314> just pointing it out :p
01:37:05 <ski> @let resetCont :: Cont o o -> Cont p o; resetCont = return . evalCont
01:37:06 <lambdabot>  Defined.
01:38:48 <Blkt> good day everyone
01:40:15 <Saizan> ski, augur: so, does it make more sense to use Any* or Some* for existential wrappers?:)
01:40:59 <ski> @let shiftCont :: ((a -> o) -> Cont o o) -> Cont o a; shiftCont f = Cont (\k -> evalCont (f k))
01:41:01 <lambdabot>  Defined.
01:41:04 <augur> Saizan: depends on what you mean by "sense" :)
01:42:19 <dolio> What was Cont2? (a -> r) -> o?
01:42:29 <Mathnerd314> Saizan: maybe we could just call them Exists and Forall
01:42:33 <Saizan> dolio: yep
01:42:56 <ski>   newtype Cont2 o p a = MkCont2 {runCont2 :: (a -> o) -> p}  -- yes
01:44:15 <ski>   resetCont2 :: Cont2 o p o -> Cont2 q q p
01:44:29 <ski>   resetCont2 = return2 . evalCont2
01:46:29 <ski>   shiftCont2 :: ((a -> o) -> Cont p q p) -> Cont2 o q a
01:46:35 <ski>   shiftCont2 f = MkCont2 (\k -> evalCont2 (f k))
01:47:01 <ski>   evalCont2 :: Cont2 o p o -> p
01:47:15 <ski>   evalCont2 = (`runCont2` id)
01:47:52 <dolio> Huh, I don't think I've seen shift typed like that.
01:47:56 <dolio> That's nice.
01:48:09 <ski> (sorry s/Cont /Cont2 /)
01:48:29 <ski> we also have
01:48:39 <ski>   return2 :: a -> Cont2 o o a
01:49:51 <Saizan> shiftCont2 :: ((forall p. a -> Cont2 p p o) -> Cont p q p) -> Cont2 o q a -- if you want, which is more like what you'd have with a transfromer version
01:51:03 <dolio> You can probably get an (a -> m o) for the transformer version.
01:51:10 <ski>   (=<<) :: (a -> Cont2 o p b) -> (Cont2 p q a -> Cont2 o q b)
01:52:09 <ski> Saizan : i'm not sure whether `forall p. Cont2 p p o' really buys us anything .. afaics, the only thing we can sensibly do with it is call `evalCont2' on it to get back `o'
01:52:31 <dolio> It's nice because it shows that k has no control effects that escape.
01:52:46 <ski> right .. i.e. `a -> o' shows that :)
01:53:07 <dolio> Presumably you can't give the same type to control.
01:53:40 <dolio> At least, I think that's the one. I have trouble remembering which of the others are which.
01:53:49 * ski never really liked those other variants, anyway :)
01:53:59 <ski> (Felleisen : control & prompt, iirc)
01:54:10 <Saizan> ski: nothing here
01:54:14 <dolio> Yes, but there's also shift0 and control0.
01:54:23 <dolio> Because there's two different things to delimit or not.
01:54:32 <ski> Saizan : sorry ?
01:56:24 <dolio> I guess you can't really give that type when you have multiple prompts, either.
01:56:37 <dolio> Because k could have a shift to an outer prompt.
01:57:34 <ski> > let allCont as = shiftCont $ \c -> return (all c as) in evalCont $ resetCont $ do x <- allCont [2,3,5]; return (x /= 3)
01:57:35 <lambdabot>   False
01:57:37 <ski> > let allCont as = shiftCont $ \c -> return (all c as) in evalCont $ resetCont $ do x <- allCont [2,3,5]; return (x /= 4)
01:57:39 <lambdabot>   True
01:58:42 <Saizan> ski: as i said, it only makes sense in the context of also having a Cont2T, it was a fairly random comment caused by the surprise about shift's type
01:59:11 <Saizan> but yeah, a -> m o might work too
01:59:35 <dolio> I might have to send in a revision of the Category.Monad.Continuation I wrote.
01:59:46 <dolio> For Agda, that is.
01:59:48 * ski remember defining `for :: Monad m => [a] -> ContT2 o [o] m a' for some fun
02:00:37 <ivanm> Baughn: seen this? http://www.reddit.com/r/haskell_proposals/comments/binfn/extend_haskellmode_using_agdamode_as_inspiration/ (don't know how useful it is to you as a feature request...)
02:01:32 <dolio> Although, monads being indexed by values of a set I is kind of a damper on Cont in the first place.
02:01:53 <ski> so, (roughly) `do cell <- forBoard board; liftIO (frob cell)' with `forBoard (Board ass) = do as <- for ass; a <- for as; return a' worked :)
02:02:49 <ski> (i.e. factoring out the "two outer for loops", without factoring out the body, and at the same time generating a new board)
02:03:43 <Saizan> dolio: add some universe polymorphism?
02:04:15 <ski> (in actuality, i used `bindCont2' instead of `do' syntax, because of the indexed monad)
02:04:40 <dolio> That'd get into changing stuff I haven't written myself. Although perhaps people would be more amenable to changing it now that universe polymorphism exists.
02:05:15 <dolio> I think I experimented to see what it'd be like with universe polymorphism, and it had slight problems at least, but I don't recall what they were.
02:05:37 <ski> @hoogle [a] -> (a -> m o) -> m [o]
02:05:38 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
02:05:38 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:05:39 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:06:36 * ski . o O ( `Cxt2 [a] a (m o) -> m [o]' )
02:08:55 <augur> oh no, ski is thinking in monads
02:08:56 <augur> D:
02:10:04 <Saizan> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed-Cont.html <- oh noes, shift's type is broken here
02:10:13 <ski> augur : rather comonads ..
02:10:28 <augur> whats a comon ad? 8D
02:11:16 <kmc> a comonad is a monad on opposite day
02:11:58 <ski> Saizan : .. oh, `forall i. ' in wrong place
02:12:04 <augur> is it a monad on every other day? :o
02:12:17 <augur> monads tomorrow, monads yesterday, but never monads today?
02:12:22 <ski> no, opposite day
02:12:38 <ski> in opposite day, time flies in the opposite direction
02:12:50 <augur> and they certain dont like arrows
02:15:22 <mjsor> Given a Data.Vector v and an index I, what is the best way to create a new vector v' where v(I) has a new value?
02:17:41 <kmc> i would think you can't do better than (//)
02:18:04 <kmc> it will copy the whole vector
02:18:12 <ski> depending on context, you might be able to do better
02:18:51 <ski>   newtype Frob f b = forall a. MkFrob (b -> a) (f a)  -- what should this be called ?
02:18:55 <kmc> hmm: modify :: (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a
02:19:00 <ski> (or maybe it's already in a library somewhere ?)
02:19:04 <kmc> this is a safe modify which only-sometimes copies
02:19:11 <kmc> did not know about it until just now
02:20:29 <mjsor> (//) eh?  I'll try that.  The haddock docs for the library provide no explanation of what it actually does...
02:20:50 <kmc> http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector.html#v%3A%2F%2F
02:20:57 <kmc> "O(m+n) For each pair (i,a) from the list, replace the vector element at position i by a."
02:21:27 <dolio> ski: That looks isomorphic to f ().
02:21:53 <mjsor> Crud.  I just noticed that google for data.vector led me to the v0.5 docs that didn't explain it. 
02:23:13 <mjsor> Thanks for the pointer kmc.
02:24:00 <eflister> is there a way to partition a list of values by their constructors?
02:24:12 <Cale> mjsor: It's probably not necessary to point out, but if you're doing a lot of that such that it ends up being some uniform operation on the whole vector, it's probably worthwhile considering how to write that thing in terms of the other higher order operations
02:24:36 <Cale> eflister: In general? What type do you want the operation to have?
02:25:26 <eflister> partitionByConstructor :: [Type] :: [[Type]]
02:25:29 <Cale> eflister: It's possible to write a function (Data a) => [a] -> [[a]], I suppose.
02:25:40 <Cale> What type is Type?
02:25:44 <kmc> :t toConstr
02:25:45 <lambdabot> forall a. (Data a) => a -> Constr
02:25:53 <kmc> eflister, ^^^^ you can use this to get the "name" of a constructor in a generic way
02:26:18 <Cale> (for instances of the Data class, which is a lot of things, and GHC can derive it for user-defined datatypes)
02:26:38 <eflister> Cale: some type all of whose values have constructors :)
02:26:52 <mjsor> Cale: yeah, I know that for when it applies.  I'm trying to port a C graph algorithm to Haskell that doesn't fit well with higher order operations.  
02:27:34 <Cale> mjsor: Yeah, those things can take a lot of thought to sort out exactly what's really going on.
02:28:13 <kmc> :t let pt xs = M.toList $ M.fromListWith (++) [(toConstr x,[x]) | x <- xs] in pt
02:28:14 <lambdabot>     No instance for (Ord Constr)
02:28:15 <lambdabot>       arising from a use of `M.fromListWith' at <interactive>:1:23-70
02:28:15 <lambdabot>     Possible fix: add an instance declaration for (Ord Constr)
02:28:20 <kmc> oh, super awkward
02:28:28 <eflister> how come haskell.org is always down?
02:28:50 <kmc> because it's not using a web server written in Haskell [/snark]
02:28:59 <Cale> eflister: Lots of different reasons, it seems
02:29:12 <Cale> eflister: But it's not *always* down.
02:29:14 <kmc> :t let pt xs = M.toList $ M.fromListWith (++) [(constrRep $ toConstr x,[x]) | x <- xs] in pt
02:29:15 <lambdabot>     No instance for (Ord ConstrRep)
02:29:15 <lambdabot>       arising from a use of `M.fromListWith' at <interactive>:1:23-82
02:29:16 <lambdabot>     Possible fix: add an instance declaration for (Ord ConstrRep)
02:29:49 <kmc> :t let pt xs = M.toList $ M.fromListWith (++) [(show $ toConstr x,[x]) | x <- xs] in pt
02:29:50 <lambdabot> forall t. (Data t) => [t] -> [(String, [t])]
02:30:05 <kmc> > let pt xs = M.toList $ M.fromListWith (++) [(show $ toConstr x,[x]) | x <- xs] in pt [Nothing, Just 'x', Nothing, Nothing, Just 'z']
02:30:06 <lambdabot>   [("Just",[Just 'z',Just 'x']),("Nothing",[Nothing,Nothing,Nothing])]
02:30:14 <kmc> > let pt xs = M.toList $ M.fromListWith (++) [(show $ toConstr x,[x]) | x <- xs] in pt "abcdefgh"
02:30:15 <lambdabot>   [("a","a"),("b","b"),("c","c"),("d","d"),("e","e"),("f","f"),("g","g"),("h"...
02:30:21 <mjsor> Cale: yep.  This is Brandes's algorithm for computing betweenness-centrality on a graph.  I'm puzzling through the right way to write it in Haskell...
02:30:39 <kmc> > let pt xs = M.toList $ M.fromListWith (++) [(show $ toConstr x,[x]) | x <- xs] in pt [Left Nothing, Right (Just 'z'), Left (Just 7)]
02:30:40 <lambdabot>   [("Left",[Left (Just 7),Left Nothing]),("Right",[Right (Just 'z')])]
02:31:05 <kmc> eflister, ^^^^^^
02:32:28 <eflister> kmc: cool :) i don't know anything about syb -- i was trying to lookup toConstr on hoogle but haskell.org was down, resorted to hayoo...
02:32:50 <McManiaC> can you block an IORef so that only the current one can access it?
02:33:00 <kmc> "current one"?
02:33:09 <kmc> McManiaC, you probably want MVar instead
02:33:09 <McManiaC> the one calling the blcok
02:33:13 <kmc> the one what
02:33:17 <kmc> thread?
02:33:20 <McManiaC> yeh
02:33:27 <ski> dolio : hrm, actually, sorry, i should have said
02:33:39 <ski>   newtype Frob f b = forall a. MkFrob (a -> b) (f a)
02:33:47 <kmc> McManiaC, don't think so.  you'd probably use MVar
02:34:19 <dolio> That's more like it.
02:34:30 <McManiaC> ok
02:34:38 <Cale> If you want only one thread to access the IORef at a time, you could use an MVar IORef :)
02:34:43 <ski> the other one i was going to ask about is
02:34:45 <dolio> That, of course, is isomorphic to f b. :)
02:35:04 <Cale> and have the thread who wants it take the MVar which will make anyone else who wants it block
02:35:04 <dolio> Roughly.
02:35:14 <Cale> (until it's put back)
02:35:14 <McManiaC> yeh, I'll just use MVars
02:35:30 <eflister> kmc: what is M there?
02:35:49 <ski>   newtype Barf f a = MkBarf (forall b. (a -> b) -> f b)  -- what to call this one ?
02:35:52 <kmc> eflister, Data.Map
02:36:09 <dolio> ski: That actually reminds me of state-in-context, but the f and the existential is different.
02:36:10 <ski> dolio : note that we can `instance Functor (Frob f)' (assuming nothing about `f')
02:36:23 <kmc> using "show" is a hack because Constr doesn't have Ord, so you can use it as a Map key
02:36:28 <kmc> there is probably a better hack
02:36:39 <ski> e.g. `Frob IORef' is basically an `IOReadRef', which is an instance of `Functor'
02:36:40 <Cale> ski: Yoneda
02:36:41 <kmc> you could define an orphan instance for ConstrRep
02:36:49 <Cale> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Yoneda.html
02:36:55 <ski> Cale : `Frob' or `Barf' ? :)
02:37:01 <Cale> Barf
02:37:08 <dolio> Frob is probably coyoneda.
02:37:29 <Cale> yes
02:37:32 <Cale> data CoYoneda  f a = forall b . CoYoneda  (b -> a) (f b)
02:37:41 <Cale> newtype Yoneda  f a = Yoneda  { runYoneda :: forall b. (a -> b) -> f b }
02:38:25 <ski> hm, interesting
02:38:31 <dolio> I probably should have recognized those.
02:38:47 <Saizan> which are left/right kan extensions specialized to Id, right?
02:39:11 <ski> why do i see no `instance Functor (CoYoneda f)', there ?
02:39:29 <Cale> Saizan: yeah
02:39:36 <McManiaC> btw, is Network TCP only? or does it support udp aswell?
02:39:48 <Cale> ski: I don't know, because it's there
02:39:57 <dolio> Mental block.
02:41:16 <kmc> McManiaC, it does only stream sockets, not datagram sockets
02:41:24 <kmc> meaning TCP and stream Unix sockets
02:41:34 <kmc> Network.Socket does everything
02:44:18 <ski> Cale : uh .. surely i'm in need of nutrition
02:52:32 <akamaus> hello anyone, I have always been puzzled, why Haskell implementations don't have a repl in style of a lisp or python? Say, why it's not possible to (re)define functions from the repl, only bindings?
02:53:26 <dibblego> akamaus, essentially, because you're inside an IO do-block
02:53:42 <akamaus> dibblego, and why? )
02:53:49 <dolio> GHCi lets you define new functions with let.
02:54:18 <dolio> But not all implementations have a REPL exactly like GHCi. Some let you define new types and stuff.
02:54:19 <kmc> akamaus, what do you mean "not functions, only bindings"?
02:54:26 <ski> dolio : hm .. though actually the first (mistype) of `Frob' is also useful : `data Frob f a = forall b. MkFrob (a -> b) (f b)' builds a contravariant functor out of `f'
02:54:39 <akamaus> kmc, I meant "only let bindings"
02:54:56 <kmc> you can make let bindings which shadow the file you've loaded
02:55:15 <kmc> which is close to redefining a function in the top level of your file
02:55:24 <kmc> you can't really do that, because variables are immutable
02:55:37 <akamaus> personally I always have troubles with ghci resetting my bindings then I reload one of modules
02:56:23 <dolio> ski: I guess. But you can't do anything with it.
02:57:20 <kmc> akamaus, yes, it will do that
02:57:32 <kmc> when you reload you start a new "do" block
02:57:35 <dolio> The a -> b might as well be a -> (), and the f b is like f ().
02:58:17 <dolio> CoYoneda you can get out an f a.
02:58:21 <akamaus> I asked the question because I don't understand whether this behavior is byproduct of the language properties or just an implementation choice
02:58:27 <ski> dolio : sure you can do something with `Frob IORef a'
02:59:07 <ski> you can use `writeIORef' to write an `a' (converted to some internal `b') to the reference cell
02:59:31 <kmc> akamaus, btw it's the same way in python.  if you reload a module in the repl, assignments you've made in that module are lost
02:59:50 <kmc> akamaus, i don't think it's a fundamental limitation; you could at least remember bindings and play them back
02:59:55 <akamaus> well.. maybe list is better example then )
03:00:06 <akamaus> *lisp
03:00:07 <kmc> the topic of improving ghci comes up here often; i don't know if there is active work on it
03:00:30 <dolio> Ah, well, that's true.
03:00:57 <ski> you can also consider other `f's that are actually contravariant ..
03:01:10 <ski> (though then there's less point)
03:01:20 <dolio> Oh, so then you can get an f a out of it. Yeah, that makes sense.
03:01:28 <akamaus> kmc, concerning the replay, what if some of the bindings a results from IO actions? Say I'm developing a web crawler or something..
03:01:38 <ski> dolio : "you can get an f a out of it" -- huh ?
03:02:35 <dolio> If f is a contravariant functor, then \MkFrob g v -> map g v :: Frob f a -> f a.
03:02:52 <ski> .. oh
03:03:02 <dolio> So maybe that's a contravariant coyoneda.
03:03:05 * ski thought you were responding the the earlier stuff
03:03:23 <akamaus> dolio, you said there're different implementations with a richer repl. Which ones?
03:03:34 <dolio> hbc, I've heard.
03:03:43 <dolio> Hugs might, too, but I don't know.
03:04:04 <ski> Hugs can't even `let'-bind stuff
03:04:07 <akamaus> dolio, hugs, at least in 2005, had the same behavior as ghci
03:04:18 <akamaus> iirc
03:04:18 <ski> (last i checked)
03:05:08 * ski wonders what `CoYoneda Endo' might be ..
03:05:41 <kmc> akamaus, that would be a problem, yes
03:05:58 <kmc> but if you don't redo actions, you have a consistency problem
03:06:13 <kmc> what if you've modified the definition of a type which is used in an action's result?
03:06:18 <ski> (oh `exists b. (a -> b) * (b -> b)' .. doesn't look interesting)
03:06:19 <dolio> Well, Endo isn't a functor, so you might have trouble getting it out.
03:06:34 <kmc> you can probably attach version numbers to types
03:06:41 <kmc> it's not an impossible problem, just gets complicated
03:06:55 <ski> kmc : in at least SML/NJ and OCaml, when you modify the type, you generate a new type, and the old function still refers to the old one
03:07:01 <akamaus> kmc,  I guess you shoud receive a warning or something, and this binding would be removed
03:07:01 <kmc> yeah
03:07:22 <ski> (and if you don't rename or something, the new type will shadow the old, in the interactor)
03:07:22 <akamaus> kmc, it's not a frequent situation imho
03:08:02 <ski> dolio : the point was to try to apply it to some non-functors, to see if anything interesting falls out :)
03:08:03 <akamaus> usually you just develop, refactoring comes later
03:08:26 <ski> (if we apply `CoYoneda' to a functor, the result is basically just that functor)
03:08:34 <dolio> Well, IORef isn't a functor, is it? That was kind of interesting.
03:08:40 <ski> exactly
03:09:16 <dolio> I mean, there's a whole class of things like that.
03:09:17 <dolio> Chan.
03:09:26 <ski> i've hand-defined `IOReadRef' and `IOWriteRef', to be able to make them into `Functor' and `ContraFunctor' .. i only later noticed it could be interesting to abstract out `IORef' from it
03:09:32 <dolio> You could make read or write-only Chans that way.
03:10:20 <ski> maybe `Flip Cont a' could be interesting .. hm
03:11:50 <ski> `CoYoneda (Flip Cont x) a' being basically `exists b. ((x -> b) -> b) * (a -> b)'
03:13:46 <ClaudiusMaximus> work in progress output from my latest haskell >> http://img149.imageshack.us/img149/7259/anim5.gif
03:13:52 <ski> (er .. worng)
03:14:07 <ski> `CoYoneda (Flip Cont x) b' being basically `exists a. ((x -> a) -> a) * (a -> b)'
03:14:44 <dolio> Well, I have a harder time believing an ordinary type that isn't functorial in the appropriate way will be interesting.
03:15:15 <dolio> The IORef stuff works because it lets you abstract over something that is known and used elsewhere.
03:15:26 <dolio> So it has an escape hatch.
03:16:06 <dolio> Flip Cont x is in a similar situation to Endo.
03:16:32 <ski> yes .. though `IORef' is also invariant
03:16:50 <ski> (i'm not sure exactly what the different would be)
03:17:57 <ski> (also correcting above, `CoYoneda Endo b' should be `exists a. (a -> a) * (a -> b)')
03:18:09 * ski will try to ponder this for a while
03:24:21 <dolio> I suppose I should say: the effects are what make the IORef example work. You could imagine it being an expfunctor, so (a -> b) -> (b -> a) -> IORef a -> IORef b. The existential lets you make the functionality that requires one of the directions impossible to use.
03:24:51 <ski> augur : btw, a comonad `w' should have operations `extract :: w a -> a' and `(=>>) :: w a -> (w a -> b) -> w b' .. a few examples are `data Stream a = Cons a (Stream a)', `data StreamZipper a = RevAppend [a] (Stream a)', `data Context s a = ApplyContext (s -> a) s'
03:25:11 <augur> ski: i dont care what comonads should or shouldnt have. i wasn't being serious. :P
03:26:01 * ski already assumed that :)
03:27:25 <augur> ski, whats it that you do, btw?
03:27:50 <morgie> Probably a simple question, but i can't figure out a nice function to it.. I have a list of functions with type (MyType -> Bool) and i want a function that returns a Bool that is the or'ed result from running each of the functions  on one MyType. Someone got an idea?
03:28:18 <ski> dolio : i'm not sure what effects something primitive like `IORef' can have, but `\a -> ..a..a..' (with `a' used both in positive and negative position, and not using any "primitive" types like `IORef') can't
03:28:19 <dolio> @type \x -> any ($x)
03:28:20 <lambdabot> forall a. a -> [a -> Bool] -> Bool
03:31:04 <handonson> i have just installed parsec 3 and got this from a parsec code: "No instance for (Stream s mtl-1.1.0.2:Control.Monad.Identity.Identity Char)"
03:31:58 <handonson> seeing that there is "Monad m => Stream ByteString m Char" instance in the parsec library, i don't think this error is supposed to happen
03:32:44 <morgie> thanks dolio, got stuck on "or" and missed that one
03:35:46 <Saizan> handonson: but 's' is not instantiated there
03:36:29 <Saizan> handonson: it's complaining that there's no instance that works for any 's', since you didn't tell it otherwise what you want in place of that 's'
03:36:58 <Saizan> handonson: a common case where this is problematic can be solved by adding {-# LANGUAGE NoMonomorphismRestriction #-}
03:37:19 <Peaker> the awful MR strikes again :)
03:37:47 <kmc> @type \x -> or . map ($x) -- using or morgie
03:37:48 <lambdabot> forall a. a -> [a -> Bool] -> Bool
03:38:14 <handonson> now i understand what everybody was talking about.
03:38:21 <handonson> Saizan: thanks
03:41:37 <Saizan> np
03:42:13 <handonson> Is it possible to combine a parser that processes a ByteString and returns a ByteString (or maybe a list of ByteStrings) with Parsec?
03:42:38 <handonson> For now I'm B.packing the result (which is String) but it doesn't seem like a recommended way of doing this
03:43:12 <Saizan> i'm not sure i understand
03:43:55 <Saizan> the problem is that it's not so easy to get a ByteString out of parsec's combinators?
03:44:20 <Saizan> and that's why you're returning a String rather than a ByteString?
03:47:13 <roconnor> > exp (-10^15)
03:47:14 <lambdabot>   0.0
03:47:22 <roconnor> > exp (-10^15) :: CReal
03:47:27 <lambdabot>   mueval: ExitFailure 1
03:47:43 <handonson> Returning String is the only way I know how to use Parsec. Like { many (char '\n') } having the type { ParsecT s u m [Char] }
03:50:38 <Peaker> What's the type of "char"?
03:51:20 <handonson> err... Char -> ParsecT s u m Char ?
03:52:37 <Saizan> handonson: there's a way around that, but i'm not sure if i can dig up the code
03:52:45 <roconnor> > logBase 10 (exp (-10^15)) :: CReal
03:52:50 <lambdabot>   mueval: ExitFailure 1
03:52:54 <roconnor> @src logBase
03:52:54 <lambdabot> Source not found. Wrong!  You cheating scum!
03:52:55 <Saizan> preflex: seen edwardk 
03:52:55 <preflex>  edwardk was last seen on #haskell 5 hours, 5 minutes and 10 seconds ago, saying: gah, parsec 2 needs Applicative ;)
03:53:00 <roconnor> ugh math
03:55:01 <roconnor> > (-10^15)/log(10)
03:55:02 <lambdabot>   -4.342944819032518e14
03:55:23 <roconnor> > (-10^15)/log(10) :: CReal
03:55:24 <lambdabot>   -434294481903251.8276511289189166050822943970058036665661
04:00:05 <Saizan> handonson: i can't find it, the idea is to make an operator slice :: ParsecT s u m a -> ParsecT s u m s, which returns the part of the stream consumed by the given parser, though that can be done only with a suitable stream type
04:00:34 <Saizan> handonson: edwardk should have the corresponding code hidden somewhere :)
04:01:03 <handonson> Saizan: Thank you very much. I'll look into it.
04:01:14 <roconnor> exp(-10^15) is supposedly the upperbound on the probability of a system spontaniously lowering in entropy by (1 microcalorie / room temperature)
04:02:38 <roconnor> in otherwords the probability of extrancting 1 microcalorie of extra energy in a heat engine operating in an environment at room temperature
04:02:45 <roconnor> extracting
04:05:35 <Saizan> ok, so my plan to build a perpetual motion machine is not completely screwed
04:17:27 <roconnor> nope
04:19:00 <aristid> > toInteger ((-10^15)/log(10))
04:19:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:19:01 <lambdabot>    `GHC.Real.Integral a'
04:19:01 <lambdabot>   ...
04:19:10 <aristid> > toInteger ((-10^15)/log(10) :: CReal)
04:19:11 <lambdabot>   No instance for (GHC.Real.Integral Data.Number.CReal.CReal)
04:19:11 <lambdabot>    arising from...
04:19:29 <bremner> but as a design principle, doesn't that suggest something you already have (a broken cell phone e.g.) would work just as well as a perpetual motion machine?
04:19:52 <aristid> > truncate ((-10^15)/log(10) :: CReal)
04:19:53 <lambdabot>   -434294481903252
04:20:07 <roconnor> to get a extra picocalorie of work, the odds are at most 10^(-400000000)
04:20:15 <roconnor> what comes after pico?
04:20:34 <aristid> femto
04:20:47 <roconnor> Saizan: I recomment operating your perpetual motion machine at below room temperature
04:22:02 <roconnor> ah
04:22:44 <roconnor> You might have upto a 36% change of getting an extra zeptocaloire of work from an engine.
04:22:47 <roconnor> chance
04:23:11 <aristid> woah
04:23:30 <roconnor> at room temperature
04:24:02 <roconnor> Saizan: oops I have that backwards
04:24:11 <roconnor> Saizan: you want to operate at above room temperature
04:24:18 <roconnor> really really far above room temprature
04:24:26 <aristid> how about sun temp?
04:24:58 <roconnor> on the surface of the sun you can expect to have a 94% change of getting an extra zeptocalorie of work
04:25:19 <roconnor> chance
04:25:43 <roconnor> surface temp of the sum I'm taking as 5700 K
04:25:51 <kmc> why is it not symmetric? why do you have a better chance of getting free energy than of getting robbed?
04:25:55 <roconnor> room temperature I was taking as 300 K
04:26:12 <handonson> can i set {-# LANGUAGE NoMonomorphismRestriction #-} on ghci?
04:26:13 <aristid> roconnor: 94%? how can that be?
04:26:32 <aristid> roconnor: i naively would expect it to be at most 50%?
04:26:55 <roconnor> kmc: You can almost always get free energy so long as you ask for very little
04:27:19 <roconnor> aristid: these are upper bounds, but still it is a good question
04:27:22 <roconnor> let me think
04:27:26 <Phyx-> handonson: put it inside the file you're loading or pass -XNoMonomorphismRestriction along to ghci when you load the file
04:27:27 <dibblego> handonson, :set -fno-monomorphism-restriction
04:27:52 <dibblego> make that :set -XNoMonomorphismRestriction
04:28:02 <handonson> thanks
04:32:02 <roconnor> aristid: entropy * temperature = energy
04:32:28 <aristid> roconnor: so it's not really free energy?
04:32:33 <roconnor> so at higher and higher temperatures the same amount of "free" energy requires lower and lower amounts of entropy
04:33:34 <roconnor> so the difference in volumes of phase space between intial and final states is less at higher temperatures (for the same amount of energy)
04:34:06 <aristid> and that can result in almost always getting free energy without the sun losing it?
04:34:10 <roconnor> the chances of getting into the lower volume of phase space from the higher volume of phase space is bounded by the ratio of these volumes
04:34:33 <roconnor> aristid: oh I'm not talking about violating the first law of thermodynamics
04:34:53 <roconnor> aristid: by free energy I mean beyond what is allowed by the second law of thermodynamics
04:35:22 <roconnor> the efficency of our engines are always bounded by 100% :D
04:35:32 <aristid> ah
04:35:51 <aristid> so if you have 96% you still increase entropy on average
04:35:56 <roconnor> I'm talking about getting the changes of getting more energy out of an engine than the second law allows
04:36:49 <roconnor> For heat engines it says the second law says the efficency is bounded by 1 - Tc / Th ( 1 - cold temperature over hot temperature)
04:37:28 <roconnor> but, if you are feeling lucky, you might get an extra zeptocalorie of work than this allows.
04:38:49 * kmc mashes the "I'm feeling lucky" button
04:38:52 <kmc> it's not working!
04:40:17 <roconnor> kmc: didn't you feel that the last mash was a little easier than the last?  Maybe it felt like you used 1 zeptocaloire less work.
04:40:31 <kmc> yeah
04:40:36 <kmc> 's true
04:41:01 <kmc> so when you calculate for 5700K
04:41:09 <kmc> is that the hot side of a heat engine?
04:41:43 <roconnor> aristid: but actually I noticed that my comptution isn't actually placing a bound on how much work I extra work I'm allowed.
04:42:54 <roconnor> aristid: I could ask for a million calories of extra work and I can get it with probability at most 10^(-10^26))
04:43:08 <roconnor> but maybe this is okay.  This is after all, simply an upper bound on the probability
04:43:23 <roconnor> the actually probabilly could be lower ... like 0%
04:43:58 <roconnor> (a million caloires operating at room temperature)
04:44:47 <roconnor> I find it hard to comprehend the probability of 10^(-10^26)
04:45:35 <roconnor> kmc: no the 5700K is the cold side
04:46:08 <roconnor> ah that's a good observation.
04:46:17 <kmc> ok
04:46:47 <kmc> this conversation is making me hungry
04:46:55 <roconnor> the likelyhood of exceeding the effeciency given by the second law is higher for ineffecient engines
04:46:56 <kmc> i could consume those million calories right now
04:47:00 <kmc> (assuming they're gram calories)
04:47:12 <kmc> hehe
04:47:16 <roconnor> I belive they are
04:48:10 <roconnor> the bound is 10^(-10^29) for a million food calories
04:48:44 <roconnor> ie, tack on another thousand zeros in the probability prefix
04:55:03 * hackagebot smt-lib 0.0.0 - Parsing and printing SMT-LIB.  http://hackage.haskell.org/package/smt-lib-0.0.0 (TomHawkins)
05:20:04 <romildo> Hi.
05:20:14 <kmc> hello
05:25:25 <handonson> Is it possible to hide what's being typed when using the I/O get family (getLine, getContents, etc.) ?
05:25:37 <handonson> for example, when prompting for password
05:28:30 <kmc> this is mostly an OS question
05:28:39 <kmc> you can use System.Posix.Terminal on POSIX systems
05:28:44 <kmc> i don't know of a cross-platform way
05:29:07 <kmc> perhaps you can hack it with vty or hscurses
05:29:20 <romildo> I am looking for guidelines on how to achieve in Haskell something similar to signatures and structures in Standard ML.
05:29:21 <Jafet> You'd put the terminal into non-echo mode.
05:29:49 <handonson> aren't all major platforms including Windows, Mac, Linux, and BSD all POSIX-compliant?
05:30:05 <Jafet> Hahahaha
05:30:06 <handonson> In fact, Linux is not.
05:30:06 <kmc> handonson, guess which one isn't ;)
05:30:10 <Zao> handonson: Windows is if you have the SFU subsystem installed.
05:30:12 <Zao> "interix"
05:30:33 <Zao> It's an older POSIX though, so any one writing naive code assuming POSIX 2001 will be quite disappointed.
05:30:37 <Jafet> You hardly need POSIX compliance -- ANSI/VT10x will do.
05:30:49 <Jafet> And anyway, you can get a POSIXy terminal on any system.
05:30:51 <Zao> Jafet: Surely POSIX doesn't say anything about terminals?
05:31:00 <kmc> Jafet, you can disable echo by sending terminal codes?
05:31:41 <handonson> So how exactly can I hide what's being typed?
05:31:56 <kmc> handonson, by disabling echo on the terminal
05:32:28 <kmc> romildo, there's no single direct equivalent to ML's module system in Haskell
05:32:38 <handonson> So you disable it right before the getLine and then enable it back?
05:32:47 <kmc> handonson, thta's up to you
05:33:11 <kmc> depending on the situation, you might use parametric records, type classes / associated types, or something else
05:33:22 <kmc> romildo, do you have a more specific example of what you're trying to do?
05:33:51 <kmc> handonson, technically you should probably save the state, disable echo, read the password, and then restore the old state whatever it was
05:34:24 <Jafet> Or let curses do all that for you
05:34:48 <handonson> System.Posix.Terminal looks very low-level.
05:35:48 <kmc> yup
05:35:59 <handonson> It uses Fd, and if I'm not quite mistaken it should be a type synonym of Handle, but it's CInt instead.
05:37:03 <kmc> why would Fd be a synonym of Handle?
05:37:12 <handonson> isn't it a file descriptor?
05:37:17 <kmc> yeah
05:37:38 <handonson> I thought Prelude.Handles were there for that
05:38:08 <handonson> specifying where you want to output things, like stdout or a file or whatever
05:38:34 <kmc> Handle is the nice portable high-level handle to a file
05:38:34 <pastorn> handonson: you get the Handle-related stuff from System.IO
05:38:49 <kmc> Fd is what Posix expects, no more, no less
05:39:20 <kmc> as you observed, System.Posix is a low-level wrapping of the Posix API.  this is not always what you want, but that's not System.Posix's fault
05:39:41 <kmc> the situation is the same in C
05:39:46 <kmc> with stdio FILE*, as well as fs
05:39:47 <kmc> fds*
05:39:48 <handonson> yeah and many people around the world must be reinventing the wheel by themselves...
05:40:02 <kmc> also the same in C++ and Python and i expect many other languages
05:40:11 <handonson> like a function that converts a Handle into a Fd or vice versa
05:40:18 <kmc> yes that's in the std lib
05:40:26 <handonson> where?
05:40:32 <kmc> don't know, you can look for it
05:40:35 <kmc> @hoogle Handle -> Fd
05:40:35 <pastorn> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/System-IO.html
05:40:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:40:35 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:40:35 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
05:40:46 <kmc> hehe i love the unsafeCoerce comedy option
05:41:01 <Saizan> hoogle doesn't index Posix stuff
05:41:11 <kmc> handonson, if a useful wheel is being reinvented then someone should upload it to hackage
05:41:43 <handonson> That's true.
05:41:48 <kmc> the valid complaint here is "there's no high-level terminal library on Hackage"
05:41:52 <kmc> not "System.Posix is low level"
05:42:03 <kmc> except we do have both vty and hscurses
05:42:09 <romildo> kmc, I have a sml signature like this: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26867#a26867, and I am using a class for the Haskell program: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26868#a26868
05:42:15 <romildo> Is that reasonable?
05:42:19 <kmc> but who knows if they do what you want -- i haven't used either
05:43:12 <handonson> I have this strange feeling that curses won't work pretty well on Windows (not that I'm using Windows now)
05:43:34 <kmc> romildo, the extra Temp args on newFrame are because the original sml function has side effects?
05:43:41 <Zao> There's pdcurses, but that's probably not horribly compatible with Haskell.
05:44:37 <kmc> romildo, it looks ok.  one question is whether you want a functional dependency
05:44:44 <kmc> "class Frame frame access | frame -> access where ..."
05:44:59 <kmc> this will enforce that for any given "frame" type, there's only one possible "access" type
05:46:09 <chrisdone> check this, i generated a complete haskell module list based on Hackage: http://gist.github.com/raw/463423/268b5314fc30963f2aedd97f7dd60a46691c2e02/The%20Haskell%20module%20landscape
05:46:34 <handonson> err... vty doesn't look that high-level. looks like it's in a different area from System.Posix.Terminal, horizontally.
05:46:50 <handonson> it looks like... a console version of SDL.
05:46:54 <Jafet> chrisdone: make a dependency graph!
05:46:56 <kmc> chrisdone, you should prefix each line with "import ", name the file Everything.hs, and upload it to hackage
05:47:03 <chrisdone> kmc: hahahaha
05:47:13 <kmc> i want to "import Everything"
05:47:59 <Jafet> kmc: gGet that in the ghc testsuite
05:48:05 <Jafet> s/G//
05:48:45 <kmc> romildo, here's an encoding as an existentially-quantified record type rather than a type class
05:48:47 <kmc> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26868#a26869
05:48:59 <kmc> this feels more natural to me, but it's hard to say
05:49:14 <roconnor> > exp(10^15)
05:49:15 <lambdabot>   Infinity
05:49:20 <kmc> i'd consider both options in light of what you'll be doing with them
05:54:35 <ivanm> kmc: since you're here and my usual testing post (sinelaw) isn't: I'm re-writing the graphNodes and graphEdges functions to return Maps rather than just a list; when dealing with undirected edges with a key of (node, node), should I duplicate each edge or just have (minNode, maxNode) ?
05:55:08 <ski> romildo : are you going to use any `sharing' constraints with that signature ?
05:56:04 <ski> (romildo : btw, next time, annotate the original paste with related pastes (by using `add revision' or `modify'))
05:56:18 <kmc> ivanm, what's the key of this map?
05:56:33 <ivanm> (node, node) [whatever the node type is]
05:57:07 <kmc> which is the 'n' parameter to DotRepr?
05:57:13 <ivanm> yup
05:57:54 <kmc> hmm do you already have Ord on n?
05:58:20 <ivanm> yup
05:58:31 <kmc> i'd say if you're replacing (rather than extending) the old functions, then it's important to recover the old behavior easily
05:58:52 <kmc> so don't duplicate edges
05:58:55 <ivanm> oh, wait, hold on
05:59:03 <ivanm> that's right, for edges I don't want to combine them
05:59:05 <ivanm> so this is a non-issue
05:59:18 <kmc> i guess you'll need Ord on n anyway, for Map
05:59:24 <kmc> so using it to order the key pairs is not an issue
05:59:36 <ivanm> so I won't even want/need a Map for it, since I won't be touching it
05:59:41 <kmc> ok
06:00:13 <ivanm> hmmm... but for nodes, should I have "Map n Attributes", or just return the resulting combined DotNodes ?
06:02:11 <kmc> i'd return the DotNodes
06:02:15 <ivanm> k
06:02:26 <kmc> so that you get the original behavior just by applying M.values
06:02:36 <kmc> well, it's hard to say
06:02:38 <kmc> hmm
06:03:35 <kmc> yeah i think  that's sensible
06:04:12 <kmc> you have accessors; «map nodeAttributes . M.values» is easier than «map (uncurry DotNode) . M.assocs»
06:06:32 <ivanm> kmc: ugh, I remember why I was going to keep it as a Map; so I could have a Set of attributes
06:06:33 <ivanm> oh well
06:09:43 <roconnor> wow, plank energy is 	1.9561 × 10^9 J
06:10:03 <roconnor> that seems like a very human scale amount of energy
06:10:19 <Jafet> Is that the energy contained in a plank
06:11:16 <roconnor> wow, planck energy is 	1.9561 × 10^9 J
06:11:18 <roconnor> that seems like a very human scale amount of energy
06:11:19 <ivanm> dammit, I want to use a DList but it's only for one small internal thing that it's not worth using another import
06:11:27 * ivanm just goes and uses Seq
06:11:43 <roconnor> ivanm: just use [a] -> [a]
06:11:45 <chrisdone> dude, import Everything
06:11:45 <roconnor> that's what I do
06:12:46 <ivanm> roconnor: hmmm.... reason I want to use a DList is because I'm just going to append single values onto the end of the list all the time
06:12:58 <handonson> How can I get a CInt (a file descriptor) out of a Handle like stdin?
06:12:59 <Jafet> I wonder what the cabal package would look like for Everything
06:13:25 <ivanm> roconnor: you mean [a] -> [a] -> [a] ?
06:13:52 <ivanm> no, wait, I'm being stupid
06:14:12 <ivanm> Jafet: well, it would have almost constant major version bumps
06:14:24 <ivanm> and how would it cope with monads-fd vs monads-tf?
06:14:38 <Jafet> It would provide the ultimate compromise in a package -- base 3 *and* 4
06:15:51 <kmc> handonson, System.Posix.IO.handleToFd
06:16:06 <kmc> "This function has the side effect of closing the Handle and flushing its write buffer, if necessary."
06:16:21 <handonson> ...wow.
06:16:24 <handonson> thanks!
06:17:08 <kmc> :)
06:20:29 <roconnor> ivanm: append (x::[a] -> [a]) (y::[a] -> [a]) = x . y
06:20:35 <roconnor> but really I just use .
06:20:52 <ivanm> well, I just want to snoc, so *shrug*
06:21:14 <roconnor> snoc is x . (y:)
06:21:54 <roconnor> in fact x . (y:) is shorter than as snoc x y
06:22:01 <roconnor> er
06:22:03 <roconnor> as long as
06:23:36 <ivanm> heh
06:23:59 <ivanm> I'm actually wanting it as a -> DList a -> DList a
06:24:08 <ivanm> otherwise I'd just need to flip it
06:26:50 <kmc> if you are building a DList exclusively with snoc
06:27:02 <kmc> would it be equally efficient to cons a regular list and then reverse once?
06:28:59 <ivanm> I don't think so, as that would require two traversals
06:29:32 <ivanm> whereas using a dlist requires at most one (if you only care about the first few, you don't actually end up creating the entire resulting list)
06:30:27 <kmc> why does it require two?
06:30:41 <tcleval> hi, how can I see the intermediate results of a haskell funcion on ghci? I mean, for example, a simple quicksort, how could I see the recursion and the intermediate lists been splited or joined?
06:30:51 <ivanm> not easily
06:31:15 <ivanm> you basically need something that emulates Haskell
06:31:29 <ivanm> or else somethink like the Expr types that lambdabot has to demostrate what's going on
06:31:34 <ivanm> > foldr f a [b,c,d]
06:31:35 <lambdabot>   f b (f c (f d a))
06:32:34 <tcleval> ivanm: I am not sure, are u aswering my question or of other user?
06:33:07 <kmc> tcleval, you can use Debug.Trace to make stuff print out when expressions get evaluated
06:33:19 <kmc> tcleval, and you can place breakpoints and inspect arguments using the GHCi Debugger
06:33:30 <tcleval> kmc: how is that? can you give me a small example?
06:33:38 <kmc> you can find one
06:34:06 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Debug-Trace.html
06:34:09 <tcleval> ok.
06:34:12 <tcleval> thx dude
06:34:16 <kmc> and the ghc manual documents the debugger
06:34:21 <kmc> no prob :)
06:34:32 <ivanm> tcleval: yours
06:34:56 * ivanm didn't think about it from a debugging point of view
06:37:14 <_JFT_> Anybody could tell me where is the global and user package database stored on OS X please? (The ones used by ghc-pkg) I'm trying to reinstall and there appears to be leftover that I'd like to clean up
06:38:10 <ivanm> _JFT_: I dont' use OSX, but I have a suspicion that it depends upon how you installed it (For the global one anyway)
06:38:21 <ivanm> for local, it'd be in ~/.ghc/
06:38:38 <_JFT_> Cool thank you
06:38:40 <kmc> _JFT_, strace will pretty reliably tell you what files a process is reading
06:39:12 <_JFT_> I"m pretty sure the global one was cleaned but not the local one. Dang I was blind I was searching and missed the .ghc dir :/
06:39:24 <_JFT_> kmc: strace?
06:40:50 <kmc> yes
06:41:15 <tcleval> kmc: I was thinking of seeing the intermediate results inside quicksort. I dont see how trace could help me there. where should I add it?
06:41:30 <kmc> tcleval, around the intermediate results
06:41:56 <_JFT_> kmc: no strace in my path, is this a standard tool on OS X? I'm still on 10.5
06:42:09 <kmc> _JFT_, i've no idea if it comes standard on OS X.  it's common on Linux
06:42:32 <_JFT_> maybe it is dtrace on OS X (which I haven't used yet)
06:42:37 <kmc> it may have dtrace instead
06:42:37 <kmc> yeah
06:42:40 <_JFT_> But thanks for the hint I'll check :)
06:48:28 <kmc> tcleval, like so http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26871#a26871
06:48:49 <kmc> tcleval, this is not the "correct" way to do IO in Haskell; Debug.Trace should only be used for, well, debugging and tracing
06:51:07 <ivanm> is there a version of mapM_ that works on Seq?
06:51:50 <ivanm> there's mapM in Traversable, but I don't want to worry about return values
06:52:05 <tcleval> kmc: you kinda saved me now..
06:52:31 <aristid> ivanm: Data.Foldable has mapM_
06:52:43 * hackagebot hmatrix-gsl-stats 0.1.1.5 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.1.5 (VivianMcPhail)
06:52:43 <ivanm> huh? I just looked there!
06:52:57 <ivanm> gah, how'd I miss that? :s
06:53:00 <ivanm> thanks aristid++
06:53:00 <aristid> ivanm: :)
06:57:45 * hackagebot hsignal 0.1.2.1 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.2.1 (VivianMcPhail)
07:01:09 <ivanm> anyone know what the changes were from transformers 0.1.x to 0.2.y ?
07:08:51 <DevHC> > print "hi"
07:08:52 <lambdabot>   <IO ()>
07:09:08 <aristid> > text "hi"
07:09:09 <lambdabot>   hi
07:11:01 <romildo> kmc, sorry for being away for a while.
07:11:11 <romildo> kmc, yes, the sml code has side effects.
07:11:43 <romildo> kmc, yes, I think I want a functional dependency.
07:14:08 <kmc> :)
07:23:36 <hpc> :t text
07:23:37 <lambdabot> String -> Doc
07:23:52 <basky> Are FieldTrip and Reactive still actively developed?
07:23:58 <Tinned_Tuna> :t "text"
07:23:59 <lambdabot> [Char]
07:24:05 <Tinned_Tuna> :t \x -> x
07:24:06 <lambdabot> forall t. t -> t
07:24:11 <Tinned_Tuna> :t (\x -> x)
07:24:12 <lambdabot> forall t. t -> t
07:29:08 <seric> @src ($)
07:29:08 <lambdabot> f $ x = f x
07:32:32 <tcleval> can anyone please tell me why I cant use "show" here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26872#a26872
07:33:50 <sepp2k> tcleval: Because you did not constrain a to Show
07:33:55 <ClaudiusMaximus> :t show
07:33:57 <lambdabot> forall a. (Show a) => a -> String
07:34:07 <sepp2k> i.e. a might very well be a type that does not instantiate Show
07:34:11 <handonson> I can't "import SomeModule (DataConstructor)" ? :o
07:34:36 <ClaudiusMaximus> handonson: you can "import SomeModule (SomeType(SomeConstructor))"
07:34:46 <tcleval> s1 is a list
07:34:48 <handonson> oh, thanks!
07:35:05 <sepp2k> tcleval: Yes, a list of as.
07:35:16 <ClaudiusMaximus> @instances Show
07:35:17 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
07:35:25 <kmc> tcleval, [a] is not an instance of Show unless a is.
07:35:40 <kmc> you only know how to print a list if you know how to print its elements
07:35:41 <sepp2k> tcleval: A list of as can be shown if and only if a can be shown.
07:36:04 <tcleval> kmc ok.. but I cant load it.. the problem is not the kind of list I use
07:36:15 <tcleval> if I remove show s1, it works fine
07:36:43 <kmc> tcleval, if you have a type signature for msort, that signature must include all the type class constraints
07:36:52 <kmc> you use show on the type a, because you use it on the type [a]
07:37:03 <kmc> therefore your signature must say «(Show a) => (a -> a -> Bool) -> [a] -> [a]»
07:37:26 <kmc> if you leave off the signature entirely, ghc will infer that type
07:37:31 <kmc> and you can see it with ":t msort"
07:38:17 <tcleval> kmc: I removed the signature and let ghci find it by itsself, now it load ok
07:38:28 <kmc> tcleval, yes, it's good to have the signatures though
07:38:40 <kmc> for documentation and better error messages
07:38:49 <kmc> they are basically machine-checkable comments; that's too sweet a deal to pass up :)
07:40:36 <tcleval> kmc: thx a lot
07:40:48 <romildo> kmc, it is not clear to me how the Frame data type with existential types would work. How would the frame and access types be used outside of it?
07:42:02 <kmc> romildo, only by passing them into the provided functions
07:42:12 <kmc> they are abstract otherwise
07:42:32 <kmc> but you could de-abstractify one or both, by making it a type parameter of Frame rather than an existentially quantified variable
07:42:37 <kmc> there are lots of points in this design space
07:43:12 <kmc> you might want separate «data Frame foo bar = ...» and «data SomeFrame = forall foo bar. SomeFrame (Frame foo bar)»
08:02:54 <andreo> is there a function in Haskell: fff i = if i == 0 then Nothing else Just i
08:02:55 <andreo> ?
08:03:11 <Jafet> You seem to have written it
08:03:20 <Jafet> (NonZeroInt?)
08:03:40 <andreo> There are many functions in Haskell (i.e. `on` ...)
08:03:50 <kmc> f 0 = Nothing; f v = Just v
08:04:29 <Jafet> Are there any Num not in Eq, hmmm
08:04:50 <kmc> the desugaring of Num literals in patterns uses (==) anyway
08:05:06 <kmc> and no, Eq is a superclass of Num
08:05:10 <kmc> but this is a somewhat regrettable fact
08:05:28 <andreo> @NonZeroInt
08:05:28 <lambdabot> Unknown command, try @list
08:05:35 <andreo> @list
08:05:35 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:05:36 <kmc> equality of computable real numbers is uncomputable :)
08:08:34 <dafis> preflex: seen dons
08:08:34 <preflex>  dons was last seen on #haskell 1 day, 11 hours, 46 minutes and 23 seconds ago, saying: ivanm: weeks ago...
08:09:07 <dafis> well, I guess he deserves a free week-end
08:19:09 <ski> edwardk : SYN
08:20:24 <ski> @tell edwardk in `Control.Monad.Indexed.Cont', shouldn't `shift :: (forall i. (a -> m i i o) -> m r j j) -> m r o a' actually be `shift :: ((forall i. a -> m i i o) -> m r j j) -> m r o a' ?
08:20:25 <lambdabot> Consider it noted.
08:24:53 <ClaudiusMaximus> @tell Jafet thanks for the substitution tiling pointers, got the basics working, just need to smoosh it into the rest of the code; progress so far: http://claudiusmaximus.goto10.org/v/mandulia/ammann_a3_zoom.gif
08:24:53 <lambdabot> Consider it noted.
08:27:35 <akamaus> I have a quick yampa question. This code hangs for some reason: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26873#a26873  how to fix it?
08:32:45 <ski> akamaus : i'm not really familar with yampa, but maybe you should use `loopPre' or `loopIntegral' instead of `loop' ?
08:33:38 <akamaus> ski, thanks, I'll check that. The problem is definitely related to loop
08:34:40 * ski suspects `loop' in `SF' makes a "loop with no time-delta", as opposed to looping around, while increasing time
08:39:57 <akamaus> ski, you're right, it works now with loopPre
08:44:06 <ski> nice
08:46:13 <ski> (one use of `loop' which would work would be `loop (arr (\(a,as) -> (as,a : map succ as)))', i think .. mapping each input `a' to an output `[a ..]')
09:03:33 <akamaus> ski, so for loop to work arrow must be kind of nonstrict on it's second argument?
09:05:13 <ski> i think `loop' probably works just fine with `SF' .. only that it's not what you want here
09:05:32 <ski> you don't want the output state to be the same as the input state
09:05:46 <ski> you want the output state be the *next* input state
09:05:57 <ski> and `loopPre' is doing that, while `loop' is not
09:09:24 <forrest> can someone help this poor idiot figure out why he's getting a compile error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26878#a26878
09:09:25 <lambdabot> forrest: You have 1 new message. '/msg lambdabot @messages' to read it.
09:09:44 <tolkad> Is there an inverse lookup?
09:09:56 <tolkad> like, it finds the second value in the tuple, and returns the first?
09:10:10 <ziman> forrest, i'd say the 'else' should be indented more than the 'if'
09:11:03 <Eduard_Munteanu> Hi.
09:11:09 <akamaus> ziman, should it account as bug in haskell-mode?
09:11:14 <kmc> forrest, the layout syntax of the do desugars as "isEof <- hIsEof inH; if isEof then return (); else do ..."
09:11:22 <forrest> ziman: really? works fine in e.g. writePartChunks
09:11:23 <kmc> forrest, note the semicolon before else
09:11:42 <kmc> in writePartChunks you're not within a layout construct like do
09:11:51 <Eduard_Munteanu> What's your opinion on Basic "Category Theory for Computer Scientists" by bcpierce? Is it worth its 20-ish bucks?
09:12:09 <Eduard_Munteanu> (I'm asking because it seems a rather thin book, 100 pages or so).
09:12:26 <kmc> forrest, http://www.haskell.org/onlinereport/lexemes.html#sect2.7
09:12:38 <Eduard_Munteanu> s/Basic "/"Basic /
09:13:02 <kmc> whitespace isn't relevant all over the place.  it's used to insert implicit semicolons within "let", "where", "do" and "case .. of"
09:13:06 <kmc> and at top level of a file
09:13:13 <Veinor> gah, what. what happened to the awodey pdf D:
09:13:19 <Eduard_Munteanu> Found it here... http://www.amazon.co.uk/Category-Computer-Scientists-Foundations-computing/dp/0262660717/ref=sr_1_3?ie=UTF8&s=books&qid=1278219166&sr=8-3
09:13:27 <ziman> a-ha, nice. I like to indent 'then' and 'else' because that works every time.
09:13:34 <kmc> despite being from the language spec itself, i think that's a decent intro to the layout rule
09:13:41 <Eduard_Munteanu> Veinor: hm, good idea, maybe I can find a printed version of Awodey's
09:13:49 <kmc> (the real formal definition is in §9.3)
09:14:59 <Veinor> it appears to have been taken down
09:16:00 <Eduard_Munteanu> Veinor: awww...
09:16:17 <Veinor> I know :(
09:17:33 <forrest> hmm, i indented the else an extra space and it compiled ... i still don't understand exactly why but i'm working on it
09:17:51 <Eduard_Munteanu> I found it here, and it's cheaper than on .com... http://www.amazon.co.uk/Category-Theory-Oxford-Logic-Guides/dp/0199237182/ref=sr_1_1?ie=UTF8&s=books&qid=1278260046&sr=1-1
09:17:57 <forrest> emacs haskell-mode gave me my original indentation as the sole indentation
09:18:06 <Eduard_Munteanu> I think I'm gonna take it.
09:18:10 <kmc> forrest, the first printing character after "do" sets the column for the whole do block.  every subsequent line starting at that column gets an implicit semicolon prepended
09:18:23 <kmc> forrest, so you wrote "if ... then ... ; else ..."
09:18:42 <kmc> i remember having this trouble with haskell-mode
09:18:56 <kmc> btw in Haskell 2010 the syntax of if then else is extended slightly to allow that semicolon
09:19:42 <Phyx-> kmc: why would you want that semicolon?
09:20:59 <ziman> forrest, if i understand correctly, the "else"-line was interpreted as if it belonged to the do-block; on the other hand, in writePartChunks, there's no surrounding do-block, to which the "else"-line could be wrongly attributed, so it's connected with the if-then.
09:21:30 <ziman> 'interpreted' in the syntactical sense.
09:22:39 <forrest> so it's always correct to indent the else more that the if, whether you're in a do block or not?
09:23:11 * forrest likes consistency
09:23:13 <ziman> that's what I do.
09:23:36 <forrest> ok, that's what I'll do then
09:25:29 <forrest> now that it's compiling, i'm getting overflow errors with Ints -- looks like I'll have to go back to Int64s
09:38:40 <c_wraith> forrest: is performance high-enough priority that you can't afford to use Integer?
09:41:09 <forrest> c_wraith: not really -- i just switched to using Int when I switched from Data.ByteString.Lazy to Data.ByteString, because all the latter's signatures seem to use Ints
09:42:15 <forrest> I think I'll be going back to try Data.ByteString.Lazy again because ddarius left me a message about how to get that to work
09:46:11 <tommd> Wow, NDM has posted some fairly surprising MVar bug reports.
09:47:18 <c_wraith> tommd, recently?
09:47:21 <tommd> They're rather amazing - most recent one is #4154.
09:47:29 <tommd> http://hackage.haskell.org/trac/ghc/ticket/4154
09:48:24 <c_wraith> Oh, that's a Chan bug, not an MVar bug.
09:48:30 <c_wraith> and yes, it's been around for a while
09:48:39 <tommd> yeah, sorry - misspoke.
09:49:04 <tommd> welcome back!
09:49:25 <c_wraith> at a friend's place.  their wireless likes to kill all tcp connections regularly
09:49:38 <tommd> The TCP connection deserved it!
09:53:25 <thoughtpolice> tommd: wow, that's quite a bad one it seems
09:53:36 <thoughtpolice> "Note that if the putStrLn statements are removed then it works, but I think that's because the printing introduces a delay that lets the other thread run."
09:53:40 <thoughtpolice> ^^ !!! :(
10:00:00 <c_wraith> yeah, Chan has some bugs.
10:00:12 <c_wraith> They're pretty well known, I thought
10:03:21 <Saizan> yeah
10:03:29 <Saizan> basically, don't use isEmptyChan :)
10:03:45 <Saizan> which probably means it should get fixed
10:05:24 <verdelyi> is there a way to have two instances like instance (Integral a) => Num (Complex a) and instance (Floating a) => Num (Complex a)? I'd like to have different operations when the 'a' is Int/Integer/Int16... and Float/Double/...
10:05:57 <verdelyi> and I don't want to copy-paste for all types one by one
10:07:00 <c_wraith> Complex requires RealFloat, at least
10:07:08 <c_wraith> :t (1 :+ 1)
10:07:09 <lambdabot> forall t. (RealFloat t) => Complex t
10:07:50 <c_wraith> oh, I see what you're asking
10:07:57 <verdelyi> umm, that's my own complex
10:07:57 <c_wraith> no, there isn't.
10:08:17 <c_wraith> GHC doesn't take typeclass constraints into account when it does instance resolution
10:08:29 <c_wraith> So if you want something like that, you'll need some sort of newtype
10:08:41 <verdelyi> hmm
10:09:08 <verdelyi> I'll try thx
10:13:35 <verdelyi> c_wraith: in fact, we currently have tons of copy-pasted instances like "instance Ordered (Uns|S)igned(8|16|32) where ..."
10:14:06 <c_wraith> yikes.  You could at least use TH to write those?
10:14:44 <Phyx-> hmm so ghc now comes with xhtml
10:15:06 <verdelyi> we're actually plannig to re-implement this thing almost from scratch, so it might be a good idea to use TH in the new one as soon as we're able to understand everything
10:15:12 <verdelyi> *as long as
10:16:19 <c_wraith> instances are easy to write from TH, thanks to [d| instance ... |] quoting. :)
10:17:31 <verdelyi> I'm not fearing TH, rather the code itself, in fact it's an embedded language.
10:17:39 <c_wraith> ah
10:18:04 <verdelyi> so I'm happy if I can understand the code without TH :)
10:46:26 <HugoDaniel> i find myself often doing this: http://www.pastie.org/1030217
10:46:43 <HugoDaniel> ...its a homage to my bad coding skillz :/
10:48:13 * Philippa wonders in how many places the Haskell grammar isn't LL(1), and how many of them are avoidable with a sensible post-process
10:48:47 <Philippa> I think the backtrack for constraints in types can be avoided because types and constraints have a similar structure, for example
10:51:17 <Philippa> (yes, the post-process'll get to throw some errors up, but it's also going to give a better error than without, too)
10:58:54 <Lajla> Any one here any understanding of combinatorics in untyped?
10:59:42 <sm> g'day all
10:59:46 <soupdragon> hi
11:00:47 <verdelyi> ummm... GHC internal error: `Feldspar.Core.Functions.$dmfromIntegerNum' is not in scope during type checking, but it passed the renamer ... can someone enlighten me what this is?
11:04:15 <sm> I built ghc 6.12.3 on a mac, which has libiconv in both /usr/lib and /opt/local/lib, and I am getting problems now with missing iconv symbols when linking some cabal packages. My cabal-install binary is still the one built with 6.10.4 if that matters. I'm wondering what approach to take on my next attempt. 
11:04:39 <sm> should I build ghc to use /usr/lib/* and avoid the macports libs ? This would make my haskell executablesmore portable to other macs I guess
11:06:51 <sm> example of the problem: http://gist.github.com/463627
11:07:12 <aasmith_> is it possible to see the computed types for generators?
11:07:23 <aasmith_> for instance i have concat xss = [x |  xs <- xss,   x <- xs  ]
11:07:41 <soupdragon> what od you want the type of?
11:07:56 <aasmith_> i want to see something like  [a] <- [[a]], a <- [a]
11:08:03 <aasmith_> does that make sense?
11:12:10 <soupdragon> we can extract types from concat xss = [x |  xs <- xss,  x <- xs  ]
11:12:53 <aasmith_> yep, i see the compiler has got [[a]] -> [a] for the type sig
11:13:22 <soupdragon> @type let types = undefined concat ; concat xss = fix $ \result ->  [x |  xs <- xss,  x <- xs, types (x,xs,xss,result)  ] in types
11:13:23 <lambdabot> forall t. (t, [t], [[t]], [t]) -> Bool
11:13:46 <soupdragon> so  x :: t, xs :: [t], xss :: [[t]],  concat xss :: [t]
11:14:19 <soupdragon> Why have I written 'types = undefined concat' rather than 'types = undefined'
11:14:40 <c_wraith> soupdragon, it has the exact same denotational semantics!
11:14:50 <aasmith_> i see
11:20:44 <sm> http://stackoverflow.com/questions/2726248/ghc-6-12-and-macports is exactly my issue. How do I get cabal install to get ghc to look first in /usr/lib, as in http://stackoverflow.com/questions/2726248/ghc-6-12-and-macports/2802550#2802550 ?
11:26:22 <roconnor> http://en.wikipedia.org/wiki/Symplectomorphism
11:27:30 <soupdragon> symplectic manifolds come up in physics
11:27:41 <roconnor> what's the difference between a symplectic manifold and a remannian manifold?
11:28:22 <danharaj> different kind of differential form associated with it
11:29:27 <soupdragon> I don't know much about these except that the symplectic one has a quantity associated which you need to preserve (sort of like how energy is preserved in a physical system). The numerical integration method (like Euler-Cromer) take advantage of that and you get closed orbits (if you were simulating a solar system) where as if you just use the plain Euler (or even Runge-Kutta) integrator you'd get orbits which increase size each loop
11:29:54 <roconnor> soupdragon: I want to simulate a solar system with closed orbits!
11:30:22 <soupdragon> I mean 2 bodies :) if you have 3 or more it is very hard to find good initial condinitions
11:30:30 <roconnor> soupdragon: how do you know this?
11:30:46 <soupdragon> well I write a simulation in haskell of orbits
11:30:59 <soupdragon> and I used this theory to make it work well
11:31:10 <roconnor> soupdragon: how do you know this theory?
11:31:31 <roconnor> no one taught me Euler-Cromer
11:33:23 * roconnor needs to take a course in symplectic something or other
11:38:16 <verdelyi> what happened to ghc trac?
11:38:33 <verdelyi> can anyone login?
11:39:37 <wli> They're not that exciting. Instead of burning degrees of freedom on higher orders of accuracy for the error you constrain them with the invariants.
11:40:16 <wli> I believe the symplectic integrators are Runge-Kutta variants in various cases.
11:42:48 <Phyx-> Cabal is the one with the haddock generation code right, not cabal-install
11:44:09 <roconnor> Verlet integration!
11:45:40 <Phyx-> you guys are always talking about something random lately
11:49:26 <cheater99> hi, i don't know how to express a certain function in pointfree style
11:50:10 <Phyx-> can't help if you don't paste the function :)
11:50:16 <cheater99> i've got a function dropUntil delim list     which drops items from the list until the item == delim.    now I would like to create a 'dropFrom' by using 'reverse' somehow
11:50:19 <cheater99> i was typing :)
11:50:38 <roconnor> soupdragon: even with Euler-Cromer, you still will get energy drift because of quantization error right?
11:50:49 <roconnor> soupdragon: or does the drift then to be unbiased?
11:51:13 <soupdragon> well I think that technically what you get is areas on the phase space are preserved
11:51:27 <roconnor> cheater99: (as an aside you don't want to use reverse in practice)
11:51:46 <cheater99> roconnor: i'll get back to that in a sec
11:51:57 <cheater99> but first.. how do i compose stuff with 'reverse' like that?
11:52:08 <cheater99> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26880#a26880
11:52:35 <cheater99> i'm only trying to apply reverse to the 2nd parameter. not the first.
11:53:09 <roconnor> @pl fun a x -> reverse (foo a (reverse x)
11:53:09 <lambdabot> (line 1, column 9):
11:53:10 <lambdabot> unexpected ">" or "-"
11:53:10 <lambdabot> expecting variable, "(", operator or end of input
11:53:12 <roconnor> @pl fun a x -> reverse (foo a (reverse x))
11:53:12 <lambdabot> (line 1, column 9):
11:53:12 <lambdabot> unexpected ">" or "-"
11:53:12 <lambdabot> expecting variable, "(", operator or end of input
11:53:17 <roconnor> @pl \a x -> reverse (foo a (reverse x))
11:53:17 <lambdabot> (reverse .) . (. reverse) . foo
11:53:29 <roconnor> @pl \x -> reverse (foo a (reverse x))
11:53:30 <lambdabot> reverse . foo a . reverse
11:53:52 <cheater99> yeah it can't be done completely pointfree can it?
11:53:58 <roconnor> @pl \a x -> reverse (foo a (reverse x))
11:53:58 <lambdabot> (reverse .) . (. reverse) . foo
11:54:06 <arcatan> of course it can, it just isn't very beautiful
11:54:12 <cheater99> hahah
11:54:18 <cheater99> what on earth does that syntax mean?
11:54:24 <cheater99> it looks like a woman with three nipples.
11:54:34 <cheater99> and hair on her chest.
11:55:13 <roconnor> @type (reverse .) . (. reverse)
11:55:13 <lambdabot> forall a a1. ([a1] -> [a]) -> [a1] -> [a]
11:56:03 <roconnor> cheater99: (dropUntil a) is a list transfomer
11:56:15 <cheater99> yes go on
11:56:33 <Eduard_Munteanu> Is it possible to define a mathematical group using typeclasses that will require proof of group axioms for instances?
11:56:39 <roconnor> (. reverse) says to reverse the output of a list transfomer
11:56:44 <soupdragon> Eduard_Munteanu: no
11:56:47 <roconnor> er
11:56:55 <roconnor> (. reverse) says to reverse the input of a list transfomer
11:57:04 <roconnor> (reverse .) says to reverse the output of a list transfomer
11:57:34 <cheater99> why does it say that?
11:57:36 <roconnor> so (reverse .) . (. reverse) takes a list transfomer and reverse the inputs and outputs
11:57:49 <roconnor> @unpl (. reverse)
11:57:49 <lambdabot> (\ a d -> a (reverse d))
11:57:52 <Eduard_Munteanu> soupdragon: I see. If I'm to guess why, is it because you'd need to encode group members as types?
11:57:55 <roconnor> hmm
11:58:03 <soupdragon> it's because you can't reflect values into types
11:58:16 <roconnor> cheater99: (. reverse) = \trans -> trans . reverse
11:58:26 <roconnor> where trans is your list transformer
11:58:34 <Eduard_Munteanu> soupdragon: ah, thanks. I wonder if I can use my type-level Peanos to do it for Peanos.
11:58:46 <roconnor> so (. foo) says oh btw, tack on foo to the front of your transfomer
11:59:03 <Eduard_Munteanu> I have a toPeano (takes an int into a Peano), but it's not really nice to use.
11:59:15 <roconnor> similarly (reverse .) = \trans -> reverse . trans
11:59:22 <RayNbow> > (reverse ~> reverse) tail [1,2,3]
11:59:23 <lambdabot>   [1,2]
11:59:42 <roconnor> (foo .) it says oh, btw, tack on foo to the back of your transfomer
12:00:52 <roconnor> so dropFrom a = ((reverse .) . (. reverse)) (dropUntil a)
12:01:21 <roconnor> take the (dropUntil a) transfrom and stick a reverse onto the front and back of it.
12:01:32 <roconnor> (also (. reverse) . (reverse .) would work
12:01:45 * hackagebot mongoDB 0.6.1 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.6.1 (TonyHannan)
12:01:59 <roconnor> RayNbow: what is ~> ?
12:02:11 <RayNbow> roconnor: infixr 2 ~> ; (x ~> y) z = x >>> z >>> y
12:03:04 <roconnor> is that standard?
12:03:11 <RayNbow> no
12:03:20 <RayNbow> I got it from Peaker, who got it from EvilTerran, who got it off http://matt.immute.net/content/pointless-fun :)
12:03:33 * Eduard_Munteanu wonders why we use value-level at all, given type-level is so cool :P
12:03:54 <cheater99> roconnor: but i only need reverse on the first parameter to my list transformer, not to the second one
12:04:09 <Eduard_Munteanu> Just have lotsa types populated only by _|_. :P
12:04:09 <soupdragon> Eduard_Munteanu haha
12:04:12 <arcatan> Eduard_Munteanu: maybe you should take a look at dependently typed programming
12:04:43 <Eduard_Munteanu> arcatan: yeah, I'll give a more serious look at Agda.
12:04:51 <Eduard_Munteanu> I wish we had that in Haskell though.
12:07:03 <roconnor> RayNbow: is ~> really associative?
12:07:13 <cheater99> dependantly typed programming?
12:07:48 <roconnor> cheater99: list transofmers of type [a] -> [a] only have 1 parameter
12:07:49 <Eduard_Munteanu> cheater99: as in a language with dependent types.
12:08:05 <cheater99> roconnor: but my function takes a delimiter parameter.
12:08:11 <cheater99> Eduard_Munteanu: dependent on what?
12:08:22 <Eduard_Munteanu> cheater99: types that are parametrised with values.
12:08:36 <roconnor> cheater99: (dropUntil a) is the list transfomer
12:08:41 <cheater99> doesn't C++ have something like that?
12:08:45 <cheater99> roconnor: ok
12:08:56 <roconnor> cheater99: dropUntil is a function of *1* argument that returns a list transfomer
12:09:12 <cheater99> roconnor: got it
12:09:52 <roconnor> (. reverse) applies to list transfomers, so you can write (. reverse) (dropUntil '7') but not (. reverse) dropUntil
12:10:24 <roconnor> so your dropFrom is defined as
12:10:26 <Eduard_Munteanu> cheater99: here's some examples of how it looks: http://en.wikipedia.org/wiki/Dependent_types
12:10:53 <roconnor> dropFrom a = ((reverse .) . (. reverse)) (dropUntil a)
12:11:00 <roconnor> This isn't point free yet
12:11:03 <cheater99> roconnor: no
12:11:07 <cheater99> roconnor: how do i make it pf?
12:11:15 <roconnor> it's easy
12:11:20 <cheater99> explain
12:11:24 <roconnor> foo a = bar (baz a)
12:11:34 <roconnor> if you can make that point free, you can make dropFrom point free
12:11:35 <cheater99> go on
12:11:49 <cheater99> i know it's this structure, but i don't know how i would make that pf
12:12:07 <roconnor> @pf (\a -> bar (baz a))
12:12:07 <lambdabot> Maybe you meant: bf pl
12:12:13 <roconnor> @pl (\a -> bar (baz a))
12:12:14 <lambdabot> bar . baz
12:12:49 <cheater99> yeah, that was what i was thinking of
12:12:58 <cheater99> hm
12:13:40 <Eduard_Munteanu> Can't TH simulate dependant types somehow? Or does that work only for a compile-time limited number of possible values?
12:14:26 <soupdragon> no
12:14:39 <cheater99> roconnor: let's try it out then
12:14:57 <Eduard_Munteanu> Ah, nvm, I found something by Connor McBride.
12:15:29 <Eduard_Munteanu> "Faking It: Simulating Dependent Types in Haskell (2001)", but by the abstract it seems an ugly hack.
12:15:43 <kau> hello!
12:16:10 <kau> Is there a way, from within  program, to detect that we're under GHCI?
12:16:10 <cheater99> roconnor: doesn't seem to work. try it yourself
12:16:26 <cheater99> let me post the source for you
12:16:29 <kau> some sort of #ifdef GHCI
12:17:12 <cheater99> roconnor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26880#a26881
12:23:41 <roconnor> @pf (\a -> bar (baz a))
12:23:41 <lambdabot> Maybe you meant: bf pl
12:23:45 <roconnor> @pl (\a -> bar (baz a))
12:23:45 <lambdabot> bar . baz
12:24:01 <roconnor> bar = ((reverese .) . (. reverse))
12:24:07 <roconnor> baz = dropUntil
12:24:15 <Athas> How do I create a buffer with type Ptr a?
12:24:21 <Athas> It's for hGetBuf.
12:24:29 <ClaudiusMaximus> so i have an idea for system where there's a large pool of work to be done, but the priority of each job in the pool can change rapidly/dramatically; and once a job is started it cannot be aborted - any ideas for data structures/libraries i should use to implement it?
12:24:49 <cheater99> roconnor: hm
12:24:52 <ClaudiusMaximus> @hoogle withArray
12:24:53 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
12:24:53 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
12:24:53 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
12:25:06 <Athas> Neat, thanks.
12:25:11 <ClaudiusMaximus> @hoogle allocaArray
12:25:12 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
12:25:12 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
12:25:16 <cheater99> roconnor: works well now, thanks =))
12:28:20 <roconnor> cheater99: you don't *have* to make functions pointless
12:28:46 <ClaudiusMaximus> i guess i need my worker threads to request the most worthwhile job when they are ready to start work; instead of sending jobs to a Chan and hope that a worker is ready before the job becomes worthless...
12:29:10 <cheater99> roconnor: but i like to find out how to
12:29:26 <ClaudiusMaximus> pointlessness is painful with -XMonomorphismRestriction
12:30:10 <roconnor> cheater99: It's easy to make functions pointless
12:30:12 <ClaudiusMaximus> at least in GHCi
12:30:26 <roconnor> cheater99: you just type the function into the @pl command for lambdabot
12:31:02 <Eduard_Munteanu> Mmm, isn't the monomorphism restriction default?
12:31:04 <cheater99> roconnor: that's what i'm doing, but sometimes the output is non-obvious. i'm only getting started with haskell, i'm writing my first fp script
12:31:18 <ClaudiusMaximus> Eduard_Munteanu: yes
12:31:18 <roconnor> @pl (\a b c -> (a < b) ==> (b <= c) ==> (a < c)
12:31:18 <lambdabot> (line 1, column 44):
12:31:18 <lambdabot> unexpected end of input
12:31:19 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
12:31:21 <roconnor> @pl (\a b c -> (a < b) ==> (b <= c) ==> (a < c))
12:31:22 <lambdabot> ap (flip . (liftM2 (==>) .) . (`ap` (<=)) . (((.) . (==>)) .) . (<)) (<)
12:31:44 <roconnor> see, isn't that much better :)
12:32:55 <cheater99> nope
12:33:20 <cheater99> but i still get insights into how things work by looking at that stuff
12:33:45 <roconnor> soupdragon: Euler-Cromer seems to preserve energy by alternating between updating the positions and momentums rather than doing them simultaneously
12:34:00 <roconnor> soupdragon: by doing the updates seperately, each update preserves energy.
12:34:13 <cheater99> roconnor: so i shouldn't use 'reverse' because it doesn't work with infinite lists, yes?
12:34:35 <roconnor> cheater99: I was going to say you souldn't use reverse because it is slow, but your answer is much better.
12:34:58 <cheater99> there's no other way i can do what i want, is there?
12:35:07 <Twey> cheater99: Don't rely on @pl.  ;)
12:35:29 <roconnor> cheater99: hmm
12:35:32 <cheater99> roconnor: i mean to drop characters starting a specific one
12:35:34 <Twey> It can show you the way, sometimes, but make sure you work backwards from it and understand it properly before you ever use it in anything resembling real code.
12:35:39 <roconnor> cheater99: you make an intersting point
12:36:30 <roconnor> cheater99: this is then a potential indication that your data structure is wrong.
12:36:39 <Eduard_Munteanu> Now making code pointfree is pointless if taken to extreme.
12:36:41 <roconnor> cheater99: perhaps seq would be better
12:36:49 <hpc> Eduard_Munteanu: pun intended?
12:36:56 <Eduard_Munteanu> Yup :)
12:37:01 <cheater99> roconnor: for my use, the reduced speed of 'reverse' is ok.
12:37:05 <roconnor> Data.Seq I mean
12:37:10 <roconnor> ok
12:37:10 <ClaudiusMaximus> > let { dropFrom k [] = [] ; dropFrom k (x:xs) = if k == x then [] else x : dropFrom k xs } in dropFrom '!' "omg! what have i done??!??"
12:37:12 <lambdabot>   "omg"
12:37:29 <Eduard_Munteanu> But I'm serious, if you do it without regard it only makes code more contrived.
12:37:48 <ClaudiusMaximus> does that meet the specification?
12:37:49 <roconnor> cheater99: I will allow you the use of reverse this time. :)
12:37:57 <kau> Sorry, nobody has a hint for my question?
12:38:22 <Twey> dropUntil = dropWhile . not
12:38:36 <Twey> Oh, wait
12:38:44 <Twey> dropUntil = dropWhile . (/=), sorry
12:39:11 <Twey> dropFrom = takeWhile . (/=)
12:39:31 <Eduard_Munteanu> kau: IMHO that should be done by the build system. Not sure for Haskell though, but on Unix systems autotools and configure scripts handles that.
12:40:11 <verdelyi> why is this invalid? http://fpaste.org/q0g1/
12:40:14 <kau> thank you
12:40:31 <mauke> verdelyi: what's the error message?
12:40:39 <verdelyi> mauke: it's saying duplicate instance
12:40:58 <mauke> then that's the problem
12:41:04 <mauke> you can't have two instances for the same type
12:41:18 <kau> Eduard_Munteanu: my purpose is to have a different behaviour when my game is played under GHCi or not
12:41:22 <verdelyi> mauke: but one of them is a TH quotation!
12:41:50 <verdelyi> mauke: some abstract stuff with an internal representation, it's not an "instance"!, it's a Q [Dec]
12:42:03 <Eduard_Munteanu> kau: ah. Well, don't let the user fire up ghci by himself then.
12:42:52 <Eduard_Munteanu> kau: it's mostly like with C. Don't expect the user to type gcc commands to compile the code.
12:43:03 <kau> Eduard_Munteanu: that's a programmatic game indeed.
12:43:07 <mauke> verdelyi--  # not providing a runnable testcase
12:43:54 <kau> Eduard_Munteanu: the player compose "rules" under GHCI and then passes them to the game engine.
12:44:04 <verdelyi> mauke: you couldn't run it anyway it gives an error.
12:44:19 <mauke> verdelyi: yes, about Q and Dec not being in scope
12:44:29 <Eduard_Munteanu> kau: ah, I see what you mean.
12:44:31 <kau> Eduard_Munteanu: that's why i want GHCI detection..
12:44:41 <mauke> ah, fuck it
12:44:56 <hpc> @hoogle IORef
12:44:56 <lambdabot> module Data.IORef
12:44:56 <lambdabot> Data.IORef data IORef a
12:44:56 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
12:45:53 <Amagineer> How does one pattern match based on records?
12:46:10 <mauke> by position or by name
12:46:27 <Twey> f RecordConstructor { recordField = something, otherRecordField = 5 } = …
12:46:36 <Amagineer> Ah, thanks
12:46:47 <Twey> Unmentioned fields are taken as _
12:47:25 <Eduard_Munteanu> kau: perhaps you shouldn't ask the user to fire up ghci directly. I'm not sure that's the best way, but you could have a bash script that writes a .hs and fires the interpreter accordingly.
12:47:53 <kau> thats a good idea
12:48:00 <verdelyi> mauke:  more runnable: http://fpaste.org/rwDx/
12:48:51 <rasfar> Regex question: I am getting missing instance errors for [String] and [(MatchOffset, MatchLength)] type signatures, although this is documented API (Bryan O'Sullivan).  How do I get a list of matches within a string?
12:48:59 <mauke> verdelyi++  # an excellent dude
12:49:49 * verdelyi didn't know it was necessary to make a point.
12:49:57 <rasfar> I found the trick to use getAllTextMatches for the [String] type, but I'd rather get the [(MatchOffset, MatchLength)] type working...
12:51:01 <Eduard_Munteanu> kau: something like running ./mygame-ghci, that does INTERPRETER="ghci"; echo $INTERPRETER > config.hs; echo $OTHER_BOILERPLATE >> config.hs; $INTERPRETER -Xblah config.hs main.hs
12:51:22 <mauke> verdelyi: this looks like a TH bug to me
12:51:45 <mauke> because if I remove the second instance declaration, ghc says "No instance for (LOL Int)
12:52:03 <Eduard_Munteanu> * echo "interpreter = \"$INTERPRETER\"" > config.hs
12:52:40 <verdelyi> mauke: for me, it works when removing the second instance
12:54:14 <verdelyi> mauke: I'll see what #ghc tells me about it
12:54:26 <rasfar> "abcb" =~ "b" :: [(MatchOffset,MatchLength)] should give [(1,1),(3,1)] but gives a missing instance error.
12:55:14 <mauke> verdelyi: I mean http://codepad.org/rd9mLUvD
12:55:36 <kau> Eduard_Munteanu: what does the -X do?
12:55:48 <rasfar> sigh.  i'll try to unravel the API but I'd rather have a working example of this basic regex functionality.
12:57:12 <verdelyi> mauke: it seems normal, the only instance you have is inside a Q[Dec], so in fact, you have no instance.
12:58:28 <soupdragon> mauke you can read german 
12:58:40 <verdelyi> kau: enables some language extension
12:58:40 <soupdragon> :))))))) why don't you translate a book into english 
12:58:52 <mauke> verdelyi: but then your error makes no sense
12:59:04 <mauke> soupdragon: lol wut
12:59:05 <kau> Eduard_Munteanu: ho, that was a dumb question ;)
12:59:23 <soupdragon> mauke this mathematics book is in German and I can't read it :(
12:59:28 <mauke> hah
12:59:44 <mauke> just learn german :-)
13:00:09 * Twey agrees
13:00:13 <Eduard_Munteanu> kau: just setting various options if you want.
13:00:26 <verdelyi> mauke: umm yes. with your example it's ok, with my example it doesn't make sense. So it may be a bug.
13:00:29 <soupdragon> how do you learn german though
13:00:35 <soupdragon> it's not like learning a programming language
13:00:35 <Botje> from a book.
13:01:07 <soupdragon> the guy who wrote it can speak about 10 different languages 
13:01:24 <Eduard_Munteanu> You'd have to bootstrap it using a language you can already compile :P
13:01:42 <Twey> Or bare machine code
13:01:51 <Twey> (Rosetta Stone likes this approach)
13:02:18 <Twey> It's pretty much just like learning a programming language.
13:02:32 <earthy> you know english. german really isn't all that hard
13:02:32 <Twey> Albeit one far more complicated even than C++.  >.>
13:02:41 <verdelyi> Twey: rosetta exactly reminded me of bootstrapping :)
13:02:52 <earthy> it's not like you're being asked to learn bahasa indonesia, japanese or chinese...
13:02:53 <Athas> I see several ways to access SQLite from Haskell.  Which one is the simplest?
13:03:04 <Twey> Japanese is easier than German
13:03:07 <Twey> By far
13:03:13 <Eduard_Munteanu> Well, yeah, you can't really write a EBNF description of German :)
13:03:15 <Twey> Mandarin too
13:03:32 <Eduard_Munteanu> Twey: possibly, if you mean the spoken language.
13:03:35 <soupdragon> but what if I just want to read this book
13:03:43 <soupdragon> how much german would I need to aquire
13:03:48 <Twey> Eduard_Munteanu: Written too
13:03:54 <Eduard_Munteanu> soupdragon: probably a lot + jargon too
13:04:04 <soupdragon> I think it sounds impossible
13:04:11 <Twey> soupdragon: Probably not much, if you're prepared to pore over the book with a dictionary for the first half
13:04:26 <earthy> twey: japanese is SOV, english SVO. german is mostly SVO as well.
13:04:57 <Twey> earthy: That's a tiny, syntactic difference
13:05:01 <Eduard_Munteanu> There are some things I prefer to read in English even though it's not my native language, because I'm more used to that particular jargon.
13:05:03 <adimit> That's to be debated. The dominant ordering in German is actually SOV
13:05:08 <rasfar> folks, if anyone listening knows what's wrong with Text.Regex (as per above) please comment, otherwise, really I think I must throw in the towel on Haskell.  This is the first thing I've actually tried to do Haskell and apparently documentation is stale after one year, and there's nothing to replace it.
13:05:21 <Zao> The dominant order in German is "insane".
13:05:24 * Twey chuckles.
13:05:32 <rasfar> (first thing tried after a hiatus I mean)
13:05:46 <adimit> bah. German is nothing. Actually, it's pretty rigid in the word orders it allows.
13:05:51 <adimit> Swiss German on the other hand...
13:05:53 <Twey> Subject, Object, Ve— subject, object, verb —rb
13:05:53 <Eduard_Munteanu> Twey: um, aren't Japanese/Chinese a bit difficult to learn to _write_?
13:05:59 <Twey> Eduard_Munteanu: Not really
13:06:17 <soupdragon> it would be good if there was a haskell program that would tell meanings of words
13:06:17 <Twey> Eduard_Munteanu: I mean, yeah, but it's not much different to learning vocabulary for any other language
13:06:38 <Eduard_Munteanu> Twey: yeah. Speaking is always simpler than speaking and writing.
13:06:41 <Twey> Eduard_Munteanu: In some languages you have to learn spelling, in other languages you have to learn gender; in Japanese and Chinese, you have to learn characters
13:06:49 <Eduard_Munteanu> Hm, yeah.
13:06:51 <adimit> soupdragon: what is meaning? (being a computational linguist, I could write you such a program for a variety of different meanings of 'meaning')
13:07:12 <soupdragon> hah
13:07:20 <soupdragon> I don't even know
13:07:27 <Eduard_Munteanu> Though my language (Romanian) has no peculiarities in spelling for instance. There's a 1-to-1 character-phoneme correspondence. :)
13:07:37 <soupdragon> I just mean if I know to associate each word with some sort of meaning then I could probably figure out what the sentence means
13:07:58 <adimit> Commonly, meaning is represented by lambda-abstracted FOPL formulas in linguistics.
13:08:15 <adimit> But those don't usually cover pragmatics and implicatures.
13:08:32 <Twey> Eduard_Munteanu: Oh, you're one of the unlucky souls who had to learn English from the base of a sane, reasonable language.  I'm very sorry.
13:08:46 <Eduard_Munteanu> :)
13:08:54 <adimit> so yeah, there's programs to associate words with meaning. Pretty much just dictionaries for the appropriate lambda terms.
13:09:11 * hackagebot statistics 0.5.1.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.5.1.1 (BryanOSullivan)
13:09:44 <Eduard_Munteanu> Twey: well, mine isn't sane either, considering double negation is a rule. We say something like "I'm not going nowhere.".
13:09:45 <adimit> Eduard_Munteanu: My mother tongue (Bulgarian) claims the same. In both the Romanian and Bulgarian cases, it's only a half truth. There's plenty of spelling/phoneme differences.(though I can't seem to recall any romanian ones)
13:10:21 <Twey> Eduard_Munteanu: Well, relatively speaking.  ;)
13:10:31 <Twey> Eduard_Munteanu: That's pretty common actually.
13:10:54 <Eduard_Munteanu> adimit: hm, I see. Well, I can't really find an example.
13:11:04 <verdelyi> mauke: #ghc confirmed that it's a bug: http://hackage.haskell.org/trac/ghc/ticket/4170
13:11:15 <Eduard_Munteanu> Twey: yeah, even in non-formal English.
13:11:39 <Eduard_Munteanu> rather ghetto English.
13:11:58 <Twey> Eduard_Munteanu: Yeah
13:12:11 <Twey> Eduard_Munteanu: More than that… pretty much all informal English, I think
13:12:12 * hackagebot statistics 0.5.1.2 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.5.1.2 (BryanOSullivan)
13:12:23 <Twey> Eduard_Munteanu: And just about every other Romance language, of course :þ
13:13:50 <adimit> Eduard_Munteanu: Though Romanian can't be said to be sane, by any standards. Your verbal inflectional system is pure insanity. Really awesome complexity there.
13:14:14 <Eduard_Munteanu> adimit: hm, possibly.
13:14:25 <adimit> Eduard_Munteanu: I've tried to grasp it, but failed badly :-(
13:14:44 <adimit> Though Bulgarian isn't really reasonable having all in all about 30 tenses ^^
13:14:49 <Eduard_Munteanu> Wow.
13:15:11 <aristid> adimit: we need a big table comparing the complexity of all languages ;)
13:15:13 * hackagebot statistics 0.6.0.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.6.0.0 (BryanOSullivan)
13:15:19 <soupdragon> im so jelous of you guys that can use multiple languages
13:15:24 <adimit> well, it depends. it's 9 main tenses, plus aspect, plus conjunctive forms, plus etc... 
13:15:37 <Philonous> German has pretty bad spelling/phoneme differences. For example you write "Good afternoon, what can I do for you?" but it is pronounced: "Huh?" 
13:15:51 <adimit> aristid: forget it. We can't even have a clear distinction of what a language and a dialect is.
13:16:20 <Eduard_Munteanu> We have like 5 tenses, and like 10 moods.
13:16:20 <adimit> Philonous: Yeah, spoken German is weird. It's like "Guten Abend" and you only hear "nahmt"
13:16:38 <Twey> Haha
13:16:54 <Eduard_Munteanu> There's no subjunctive though, which seems to be common in other languages.
13:17:00 <aristid> adimit: that's not true, Namd is just colloquial
13:17:11 <Twey> adimit: But they're mostly compound tenses, aren't they?
13:17:14 <adimit> aristid: ah, I thought you were referring to that. :-)
13:17:23 <adimit> Twey: yes. The 'raw' tenses are 9.
13:17:29 <Twey> That's better
13:17:45 <Twey> Especially if they're regular
13:18:11 <adimit> though that basically makes 'progressive' and 'simple' forms equal. So you wouldn't count the difference between 'simple present' and 'present progressive' if you count 9.
13:18:21 <Eduard_Munteanu> Yeah, regularity is a problem in past tenses in English.
13:18:52 <aristid> adimit: honestly i have no idea how complex german is, i mean i learned it as a child, and when i learned grammar in school, i didn't have to use these rules to infer how to make phrases
13:19:03 <adimit> Twey: I wish... I'm a native speaker, but I've lost the practice and now I'm sooooo inept when it comes to the tense system. That's why I've delved into formal languages and L-calculus. Much easier.
13:19:23 <Twey> Hehe.
13:20:01 <adimit> aristid: I think it largely depends on the definition of 'complexity'. German is easy to learn for s/o speaking Dutch, for instance. Also pretty easy if you're Bulgarian. Or even Hindi. But it's hella hard for, say Chinese.
13:20:26 <wli> Either you live in a small country near others where other languages or spoken or you have to get out of your country at great cost (more than those who are not rich can handle).
13:20:29 * earthy nods
13:20:35 <Eduard_Munteanu> I'm really unaware how complex Chinese is as a spoken language.
13:21:15 <earthy> wli: but, really, there's some other issues as well
13:21:16 <Eduard_Munteanu> AFAICT it's a composition of rather small particles. The writing system is really bad for newcomers.
13:21:19 <adimit> wli: entirely correct. Though you can also just learn languages out of curiousity. But either way, if you don't immerse yourself in the culture of the language, it's a lost cause.
13:21:27 <earthy> e.g. dubbing vs subtitling of foreign content
13:21:31 <illissius> the bit i don't like about german is the complex system of rules you have to apply to determine whether a word ends in -e, -en, or -es
13:21:45 <illissius> i mean, who cares?
13:21:49 <wli> adimit: Repeat what I said about money/wealth/travel.
13:21:53 <Eduard_Munteanu> Dubbing sucks :)
13:22:10 <Eduard_Munteanu> Good thing this is rare here.
13:22:16 <illissius> also hungarian > you all.
13:22:25 <adimit> illissius: no one does. It's mostly 'learned.' There are rules, but they're pretty damn irrelevant to anyone who wants to actually speak the damn language.
13:22:52 <adimit> hehe, agglutinating languages are interesting :-) I love their conciseness.
13:23:22 <Eduard_Munteanu> It's interesting how a 2nd language can influence the native one. There were some studies on that.
13:23:27 <wli> Travel of the sort most people can afford (spend days somewhere) is useless, of course. Hence wealth getting to be a big factor very quickly.
13:23:57 <Philonous> adimit: Don't forget Germans. It's hard to learn German when you are German. All those bad habits you acquire by listening to the other Germans who don't know German are hard to come by. 
13:23:59 <Eduard_Munteanu> I find myself doing that when speaking on a subject I've studied for a longer time in English.
13:24:04 <adimit> wli: the way my mother came to Germany (hence dragging me with her) was entirely devoid of any kind of wealth.
13:24:21 <illissius> yeah people talk about various kinds of grammatical forms (usually the past tenses) of english and i'm just like "huh?" because i have no idea, it just comes naturally
13:24:32 <illissius> if i ever want to learn german i'll move to germany
13:24:53 <adimit> Philonous: haha, entirely correct. Though you can say that for English, too. The 'best' English I've heard is usually written by some Dutch person. ^^
13:24:59 <illissius> ...and if you want to learn hungarian you'll just have to be reborn as a hungarian :-)
13:25:03 <Twey> Eduard_Munteanu: It's exceedingly simple.  There's no inflection of any kind — all derivation is done by adding new syllables (though there are a few regular phonetic changes).
13:25:11 <Eduard_Munteanu> Philonous: lol, I have an American friend that once said "Dude, wtf word (panic) is that? You guys know English better than I do."
13:25:22 <Eduard_Munteanu> Twey: I see.
13:25:58 <Twey> Eduard_Munteanu: Japanese is a bit more grammatically complex, but on the other hand has much simpler phonetics and requires less characters to use.
13:26:13 <Twey> Eduard_Munteanu: And it still only have two or three irregular verbs.
13:26:44 <Twey> (and an irregular adjective)
13:26:47 <cheater99> ok guys, i have a list of lists (those inner lists represent filesystem paths) and i want to make a tree out of it. how do i do that?
13:26:49 <adimit> one reason for me to never even touch Chinese with a 10 ft. pole: tones. I can't figure 'em out... just can't.
13:27:08 <Eduard_Munteanu> Twey, I wonder how easy it would be to learn to understand/read transliterated Chinese.
13:27:13 <monoidal> what is difference between fix f = f (fix f) and fix f = let x = f x in x?
13:27:23 <Twey> Eduard_Munteanu: Fairly easy, but pretty pointless.
13:27:26 <monoidal> i've read somewhere it's stack usage, but can't remember
13:27:35 <soupdragon> branch . map branch . (map . map) leaf
13:27:45 <c_wraith> monoidal, work through both variants with the function (0:)
13:27:51 <c_wraith> monoidal, by hand, I mean
13:28:05 <Twey> @src fix
13:28:05 <lambdabot> fix f = let x = f x in x
13:28:06 <Eduard_Munteanu> Twey: I see, but why? Transliteration is rather trivial. And it's probably better to take baby steps.
13:28:13 <roconnor> monoidal: the are denotationally the same, but in GHC, they are operationally different
13:28:16 <monoidal> c_wraith: it will create a cycle in the second one?
13:28:18 <cheater99> soupdragon: is that for me?
13:28:25 <monoidal> but won't detect that in the first one?
13:28:37 <c_wraith> monoidal, just run them both by hand.
13:28:43 <roconnor> perhaps a vacuum example is needed
13:28:52 <Twey> Eduard_Munteanu: It would be like learning Romanian without any genders, then having to go back and learn all the genders at once
13:29:03 <Twey> Eduard_Munteanu: Or English using only phonetic spelling
13:29:27 <Twey> Eduard_Munteanu: If you memorise each word as it comes, it's not too tricky; but if you try to learn all the characters at once, it's a Herculean task
13:29:35 * Rotaerk_ votes we switch to phonetic spelling in everyday english.
13:29:50 <Ke> !
13:29:58 <Eduard_Munteanu> I think fix f = f (fix f) is solvable by lazyness, it need not be expanded.
13:29:59 <Twey> Rotaerk_: I use Quikscript in handwriting.  Shame there's no Unicode block for it yet.
13:30:03 <cheater99> soupdragon: ?
13:30:14 <cheater99> Twey: quikscript - what's that?
13:30:26 <Rotaerk_> cheater99, http://en.wikipedia.org/wiki/File:Quickscript_alphabet_revised_names.png
13:30:28 <Twey> cheater99: A phonemic alphabet for English.
13:30:51 <Eduard_Munteanu> Twey: well I think going to some sort of phonetic alphabet (maybe IPA) is a worthy goal in the long term wrt communication.
13:31:01 <cheater99> looks fairly difficult to remember
13:31:04 <Twey> Eduard_Munteanu: Not necessarily
13:31:08 <Twey> cheater99: Why?
13:31:15 <cheater99> hunch
13:31:33 <Rotaerk_> cheater99, not really
13:31:56 <monoidal> fix' (0:) = 0:(fix' (0:)) = 0:(0:(fix' (0:)) = ... is constantly growing and fix (0:) gives a constant structure let x = 0:x in x
13:31:59 <monoidal> am I right?
13:32:04 <Twey> cheater99: It's pretty simple.  Only fifty-one characters.
13:32:10 <monoidal> s/constant/cyclic
13:32:17 <cheater99> right
13:32:27 <cheater99> that's much worse than i'd bother learning
13:32:38 <cheater99> what are the pro's of using it?
13:33:34 <Eduard_Munteanu> fix const = const (fix f) = const _
13:33:38 <Twey> cheater99: Well, considering the standard English alphabet, ignoring punctuation, diacritics, variants, decorations, digraphs, ligatures, and all the other stuff you need to know to be able to use it fluently, is fifty-two…
13:34:00 <Eduard_Munteanu> otoh, the other variant seems to build an infinite expression, isn't it?
13:34:14 <Twey> cheater99: Much faster to write than Latin, and also perfectly phonemic — no irregular spellings at all
13:34:32 <cheater99> what do you mean no irregular spelling
13:34:41 <Twey> I mean no irregular spelling
13:34:42 <cheater99> if i'm in england and pass a pig stall it changes
13:34:54 <cheater99> so i'm not sure where you got this idea
13:34:58 <Twey> Not in Quikscript — it's phonemic
13:35:02 <cheater99> yes
13:35:06 <monoidal> Eduard_Munteanu: fix const doesn't typecheck
13:35:07 <cheater99> the pronounciation changes.
13:35:09 <cheater99> dramatically.
13:35:13 <soupdragon> Does anyone know elliptic curves?
13:35:18 <monoidal> fix requires endofunction
13:35:30 <Twey> cheater99: You're missing the definition of ‘phonemic’
13:35:33 <cheater99> soupdragon: i do know some things, what about them?
13:35:39 <monoidal> let x = const 0 x in x evaluates to const 0 <thunk> which is 0
13:35:47 <gwern> Twey: maybe 'phonetic' would be a better term for cheater99 
13:35:47 <soupdragon> I am wondering if I should write a program to turn algebraic expressions into elliptic curve form - but I'm not sure if it's too complicated/hard to write
13:35:53 <Twey> cheater99: Particular realisations of phonemes are irrelevant — the script will represent the phoneme identically
13:36:04 <Eduard_Munteanu> > fix (const 0)
13:36:05 <lambdabot>   0
13:36:08 <cheater99> Twey: yes. that changes.
13:36:13 <Twey> gwern: No, that would only confuse them further, because it's not phonetic — that's precisely the confusion we're currently discussing :þ
13:36:14 <soupdragon> finding substitutions and so on to turn them into the form y^2 = x^2 + Ax + B
13:36:28 <Twey> cheater99: No it doesn't.
13:36:36 <cheater99> Twey: have you ever been to great britain?
13:36:42 <Twey> cheater99: I *live* here.
13:36:50 <cheater99> my findings are different than yours then
13:36:57 <Eduard_Munteanu> :t fix . const
13:36:58 <lambdabot> forall a. a -> a
13:37:02 <Twey> cheater99: If the phonemes changed, then it would be a different language.
13:37:07 <Eduard_Munteanu> monoidal: ^
13:37:26 <cheater99> Twey: say that to geordies
13:38:16 <monoidal> fix . const == id
13:38:18 <Twey> cheater99: For example, Northern [dʊk] vs. Southern [dʌk] — the [ʊ] and [ʌ], though the *phones* are different, are both realisations of the same *phoneme*
13:38:26 <Ke> everyone should just learn finnish and be done with spelling problems
13:38:39 <Eduard_Munteanu> monoidal: yes.
13:38:40 <Twey> (i.e. speakers will perceive them as being the same, dialect-induced confusion aside)
13:38:59 <McManiaC> how would you pack a list of "SomeType a" (with different "a"s) into one datatype?
13:39:11 <monoidal> McManiaC: use existential type
13:39:14 <Twey> cheater99: And it's that abstract phoneme that's represented by Quikscript, not the concrete phones used to represent it in a particular dialect
13:39:23 <Eduard_Munteanu> McManiaC: what do you mean by different?
13:39:39 <monoidal> McManiaC: data SomeSomeType = forall a. X (SomeType a)
13:39:56 <McManiaC> ah cool okay
13:39:59 <monoidal> McManiaC: then [SomeSomeType] can be used as a heterogeneous list
13:42:52 <McManiaC> monochrom: this has to be a "data"?
13:42:57 <monoidal> yes
13:43:05 <monochrom> monochrom /= monoidal
13:43:10 <monoidal> also, you need -XExistentialQuantification
13:43:55 <McManiaC> sorry monochrom :)
13:44:06 <monochrom> heh
13:44:07 <Ke> monoidal: so that isn't standard haskell?
13:44:20 <monoidal> it isn't
13:44:34 <Philonous> Ke: Barely anthing is standard haskell nowadays
13:44:38 <monoidal> Ke: any use of "forall" isn't 98
13:44:53 <monochrom> or 2010
13:45:09 <Eduard_Munteanu> Use of 'forall' there rather.
13:45:14 <Twey> They didn't put existentials in 2010?
13:45:14 <tensorpudding> Will existentials make it into Haskell Prime?
13:45:23 <monochrom> hrm, when will there be a "haskell 2010 report"? :)
13:45:34 <Twey> There is one, isn't there?
13:45:39 <Eduard_Munteanu> I think rank-1 forall types are legal.
13:45:51 <tensorpudding> The changes made in 2010 are very conservative
13:45:54 <Twey> http://www.haskell.org/~simonmar/haskell-2010-draft-report-2/haskell.html — oh, it's only a draft
13:46:21 <monoidal> Eduard_Munteanu: you need -XExplicitForAll
13:46:30 <Eduard_Munteanu> monoidal: oh.
13:46:53 <monoidal> or rank{2,n}types
13:47:15 <Eduard_Munteanu> Yeah.
13:47:21 <tensorpudding> They removed n+k patterns, is the only one I remember.
13:47:31 <monoidal> also FFI, hierarchical modules
13:47:31 <monochrom> I guess it will be 2012 when haskell 2010 will be ratified :)
13:47:38 <Eduard_Munteanu> No GADTs either? :(
13:47:44 <soupdragon> breaking code that currently works; Progress!
13:47:48 <monoidal> and empty datatypes
13:47:54 <soupdragon> just idiotic
13:48:03 <tensorpudding> GADTs are my favorite extension, along with Rank2Types
13:48:15 <Philippa> Eduard_Munteanu: given that there are still new papers being published on how GADTs interact with typeclasses, of course not
13:48:18 <Twey> Why is Rank2Types still around?  Isn't it subsumed by RankNTypes?
13:48:30 <Philippa> yeah, but not all implementations are GHC
13:48:31 <monochrom> to give people more choices :)
13:48:33 <Eduard_Munteanu> Philippa: I see.
13:48:47 <Eduard_Munteanu> Twey: you might not want RankNTypes.
13:48:53 <Twey> But there's nothing Rank2Types gives that RankNTypes doesn't :þ
13:48:56 <Eduard_Munteanu> Type inference is kinda decideable in rank 2.
13:49:00 <Twey> Oh
13:49:02 <Twey> Not in RankN?
13:49:11 <Philippa> provably impossible in RankN
13:49:13 <Eduard_Munteanu> Twey: no, starting with Rank3 they're not.
13:49:19 <Twey> Ack
13:49:26 <Twey> Okay
13:49:33 <monochrom> I guess that's a legit reason.
13:49:52 <tensorpudding> Using RankNTypes feels like overkill a lot of the time
13:50:36 <monochrom> I'm just too lazy to count and ensure I'm using just 2. :)
13:50:45 <soupdragon> I have RankNTypes enabled as default
13:50:51 <soupdragon> I don't think about it anything unusual
13:51:54 <Eduard_Munteanu> Well I don't know, does that mean type checking is not doable for rank n, or only that inferring is impossible?
13:52:28 <Eduard_Munteanu> E.g. given a function definition, can you check whether it matches the given type, which is easier than inferring I guess.
13:52:29 <dolio> Inference.
13:52:35 <Eduard_Munteanu> dolio: I see.
13:55:56 <soupdragon> > 1 + 3 + 3^2 + 3^3 + 3^4 - 11^2
13:55:57 <lambdabot>   0
13:56:56 <dolio> I'm not confident that rank-2 is decidable for Haskell, either.
13:56:56 <cheater99> so... how do i make a tree?
13:57:27 <cwraith> rank-2 isn't fully decideable, but it's close.
13:57:28 <Twey> data Tree a = Leaf a | Branch (Tree a) (Tree a) — one binary tree
13:57:33 <ClaudiusMaximus> :t unfoldTree
13:57:34 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
13:57:42 <dolio> The papers on rank-2 inference do it (I think) for a pure lambda calculus, not a language with constructs like polymorphic let.
13:57:51 <Eduard_Munteanu> Also Wikipedia makes a distinction on rank-k types vs rank-n types, where k = const and forall n
13:58:17 <Twey> data RoseTree a = Node a [RoseTree a] — rose tree
13:58:41 <Philippa> dolio: polymorphic recursion's known undecidable even at rank-1
13:59:08 <dolio> Yes, I know.
13:59:20 <ClaudiusMaximus> > map sum . levels . unfoldTree (\i -> (i, [2*i, 2*i + 1])) 0
13:59:22 <lambdabot>   No instance for (GHC.Num.Num (Data.Tree.Tree a))
13:59:22 <lambdabot>    arising from a use of `...
13:59:28 <Philippa> so it's more that you're confident it's not decidable, no? :-)
13:59:35 <ClaudiusMaximus> > map sum . levels . unfoldTree (\i -> (i, [2*i, 2*i + 1])) $ 0
13:59:38 <lambdabot>   [0,1,6,28,120,496,2016,8128,32640,130816,523776,2096128,8386560,33550336,13...
13:59:40 <dolio> I mean 'let id = \x -> x in ...' types id as forall a. a -> a already.
13:59:46 <Eduard_Munteanu> Philippa: does that mean Haskell prevents infinite types?
13:59:58 <Twey> :t \x -> x x
13:59:59 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:59:59 <lambdabot>     Probable cause: `x' is applied to too many arguments
13:59:59 <lambdabot>     In the expression: x x
14:00:12 <dolio> Philippa: I'm content to ignore polymorphic recursion for the purpose of this discussion. :)
14:00:12 <Philippa> Eduard_Munteanu: no - it does, but that's not what shows it
14:01:07 <Eduard_Munteanu> I'm not sure infinite types are a bad thing.
14:01:59 <Philonous> Eduard_Munteanu: How would you unify two infinity types? Sounds pretty undecidable to me. 
14:02:30 <dolio> Philippa: Anyhow, I mean, desugaring polymorphic let into lambda terms requires rank-2 types already. And if terms were allowed to be rank-2, that'd be desugared to rank-3. So, desugaring and then doing inference should be undecidable.
14:02:31 <Eduard_Munteanu> Philonous: well, yes you don't. But it should allow constructing them nevertheless.
14:02:58 <Philonous> Eduard_Munteanu: To do what with them?
14:03:03 <dolio> But I don't know if having let as a separate construct makes inference enough easier to fix that.
14:03:30 <cheater99> Twey: how about something like a nested hash?
14:03:38 <cheater99> Twey: also, i didn't get what that 'data' thing meant at all.
14:03:44 <Eduard_Munteanu> Philonous: well I stumbled upon that when writing a int -> type-level Peano conversion function. Allowing infinite types would make sense there.
14:04:07 <Eduard_Munteanu> It works with existentials but it's a trick.
14:05:48 <Philonous> Eduard_Munteanu: Oh, you only need equi-recursive types for that. That would be decidable. 
14:05:50 <Eduard_Munteanu> At least I don't see any problem in defining my toPeano as toPeano x 0 = Zero; toPeano x n = Succ (toPeano () (n - 1))
14:06:04 <Eduard_Munteanu> Philonous: hm, I'll google that.
14:06:05 <Philippa> dolio: having separate let helps inference pretty significantly, it's a free forall/type lambda
14:06:29 <Eduard_Munteanu> Well that wasn't really legal, but you get the point.
14:07:00 <dolio> I don't think an infinite type for toPeano is what you want.
14:07:09 <Philonous> Eduard_Munteanu: Huh, wait. On second thought I doubt equi-recursive types would be of any help. What's the type of (toPeano 3) gonna be ?
14:07:40 <Eduard_Munteanu> Philonous: Succ (Succ (Succ (Zero ()))) as I chose my datas.
14:08:27 <Eduard_Munteanu> Though I'd rather call that as toPeano (Zero ()) 3, providing the nil element as a base for constructing it.
14:09:47 <Eduard_Munteanu> Currently I'm using existentials, but that means the resulting Peano can't escape the call.
14:10:33 <Eduard_Munteanu> You can 'show' it for example, but not get it back as a peano.
14:11:25 <Philonous> Eduard_Munteanu: And what do you think the type of the function toPeano should be?
14:13:20 <Eduard_Munteanu> Philonous: currently I'm using something this: Int -> (forall a. Peano a => a -> b) -> b. Using infinite types I'd simply write it as toPeano :: Int -> a -> Succ a, or something similar.
14:14:21 <Eduard_Munteanu> But currently that yields an occurs check, because it tries to build a = Succ a.
14:14:47 <Eduard_Munteanu> Though I don't see what's the big deal about it.
14:15:48 <dolio> What is the definition of Succ?
14:16:08 <dolio> The big deal is that a = T a is almost always a bug, and not something you want to do.
14:16:10 <Philonous> I think the problem is different. How is the type checker to know what runtime data you will give to toPeano? So what he sais is "whatever type a I return, it might as well end up being Succ a because you fed me a higher Int". 
14:16:11 <Eduard_Munteanu> dolio: data Succ a = Zero a | Succ a
14:16:35 <McManiaC> hm hm hm
14:16:46 <dolio> Well, all the values of type a = Succ a look like: 'Succ (Succ (Succ (Zero (Succ (Succ (Zero (...'
14:16:55 <Eduard_Munteanu> Philonous: well it should think of it as a 'Succ a'.
14:17:04 <Eduard_Munteanu> It need not resolve it fully if it can't.
14:17:04 <dolio> That is, infinite nestings of the Zero and Succ constructors.
14:17:24 <dolio> There's also stuff with bottom, of course.
14:17:30 <Eduard_Munteanu> dolio: nah, I simply restrict Zero's nesting by toPeano's definition.
14:17:40 <Eduard_Munteanu> That is, I'll only put a () into Zero.
14:18:08 <dolio> I'm just telling you what values of that type look like.
14:18:17 <Philonous> Eduard_Munteanu: So you want to say "For some type a it will be Succ a", that's exactly what existentials are about
14:18:33 <dolio> Following your convention, there's only one well-defined value: Succ (Succ (Succ (Succ ...)))
14:18:55 <McManiaC> how would you combine something like "type GetFunc a = IO a" "type SomeFunc a = Maybe a -> b" and "type TheCombination a = Maybe (GetFunc a) -> SomeFunc a", so that the GetFunc stays optional but "defines" the "Maybe a" of SomeFunc?
14:19:08 <dolio> And that value doesn't correspond to any integer.
14:19:34 <Eduard_Munteanu> Philonous, dolio: I see. But doesn't that mean my Peano's aren't really type-level then?
14:19:39 <Eduard_Munteanu> They're rather data-level.
14:19:46 <Eduard_Munteanu> Even if I use existentials.
14:20:27 <Eduard_Munteanu> Anyway, it's impossible to do real type-level conversion to Peanos without reflection.
14:20:28 <dolio> You get type-level peanos via "data Zero ; data Succ a". Then you can write any Peano numeral at the type level.
14:20:41 <Eduard_Munteanu> dolio: yes, but only at compile-time.
14:20:47 <dolio> Yes.
14:20:47 <Eduard_Munteanu> as in hardcoded.
14:21:01 <Eduard_Munteanu> I think the existentials trick turns that into data-level peanos.
14:21:19 <Philonous> Eduard_Munteanu: Of course not. Haskell is statically types, which means that all types are long gone when you work on data. 
14:21:23 <sepp2k1> Eduard_Munteanu: type-level pretty much implies "at compile-time", doesn't it?
14:21:52 <Eduard_Munteanu> sepp2k1: well yes, though runtime typing is a possibility.
14:21:55 <dolio> The existential trick is for writing data-level terms that refine things in the type system.
14:22:34 <Philonous> sepp2k1: Well, you can have types at runtime in dynamicly typed languages and data at compile time in dependently typed ones
14:23:01 <Eduard_Munteanu> Well, Peanos are trivial with dependent types. :)
14:23:01 <dolio> You create a GADT 'data Peano n where { Zero :: Peano Zero ; Succ :: Peano n -> Peano (Succ n) }', and then Integer is isomorphic to (exists n. Peano n).
14:23:04 <monoidal> are there some nontrivial examples of free monads?
14:23:20 <sepp2k1> Philonous: Sure. I meant in haskell
14:23:49 <Philonous> sepp2k1: Ok, there types and data are - unfortunately - strictly seperated
14:23:54 <mreh> I'm sure I've asked this before, but I've got a <<loop>>
14:24:03 <mreh> what do I do?!
14:24:20 <mreh> trace trace and trace again?
14:25:30 <Eduard_Munteanu> dolio: well that's really equivalent to the existentials trick.
14:25:48 <dolio> That is the existential trick.
14:26:01 <Eduard_Munteanu> Yeah, I wasn't using GADTs.
14:26:14 <dolio> Infinite types are not what you want, though.
14:26:44 <Eduard_Munteanu> dolio: yeah, in fact my vision of infinite types was really existentials.
14:27:51 <Eduard_Munteanu> I could probably write my toPeano in a monad so I can pass the resulting value around.
14:27:55 <dolio> monoidal: The partiality monad 'D a = Now a | Later (D a)' is the free monad for the identity functor.
14:28:08 <monoidal> dolio: thanks
14:28:37 <Eduard_Munteanu> because the value can't escape the context.
14:28:45 <Eduard_Munteanu> (due to the existential)
14:28:58 <dolio> I think Either e is the free monad for the constant e functor.
14:29:13 <dolio> I'm not sure what 'trivial' means.
14:29:29 <monoidal> nonconstant :)
14:29:33 <dolio> Ah.
14:30:21 * Eduard_Munteanu just ordered the latest (2010) Awodey's...
14:30:38 <Eduard_Munteanu> Hopefully it will keep me busy.
14:31:46 <soupdragon> I intend to read that soon but I have so many books it's hard to get started
14:31:54 <dolio> I mean, a few monads in wide use in Haskell can be represented as the free monad over their operations.
14:32:14 <dolio> I think, at least.
14:32:27 <Eduard_Munteanu> I'll also have to order TAPL, but from US, it's expensive on amazon.co.uk
14:36:40 <soupdragon> "Fermat's Theorem is now known to be true for all exponents n <= 125000, ..."
14:36:42 <soupdragon> heh this book is old
14:41:01 <triyo> Is there any haskell library that can easily parse source-file comments (+ inline comments)? Not specifically Haskell comments, but possibly other languages too?
14:41:20 <ezyang> triyo: Maybe check the syntax highlighters? 
14:41:57 <triyo> ezyang: oh right, like vim or emacs ones?
14:42:22 <illissius> hmm
14:42:40 <ezyang> erm, no. 
14:42:43 <gwern> I think highlighting-kate is a btter idea
14:42:54 <gwern> presumably it returns some sort of ast letting you grovel for comments
14:42:58 <gwern> in haskell too
14:43:04 <gwern> a good 50 languages covered iirc
14:43:08 <ezyang> ==gwern 
14:43:10 <Eduard_Munteanu> soupdragon: interestingly, Fermat claimed he had a proof for it.
14:43:26 <soupdragon> yes
14:43:34 <edwardk> Eduard_Munteanu: yes, but most people think he was mistaken
14:43:40 <illissius> it seems to me that you can use GADTs without ever enabling the GADTs language extension by just using ExistentialQuantification and TypeFamilies (for equality constraints)
14:43:41 <Eduard_Munteanu> Yeah.
14:43:42 <soupdragon> I don't think he was mistaken.
14:43:49 <Eduard_Munteanu> edwardk: hi.
14:43:54 <edwardk> heya
14:44:02 <soupdragon> I imagine he just SAID he had a proof even though he didnt' ;P
14:44:10 <gwern> o_o
14:44:11 <illissius> e.g. you can rewrite `data T a where MkT :: forall x y. (x~y,Ord x) => x -> y -> T (x,y)` as `data T a = forall x y. (x~y, Ord x, a~(x,y)) => T x y`
14:44:17 <illissius> is there anywhere that doesn't work?
14:44:26 <edwardk> soupdragon: the standards of proof at the time were quite a bit different. i think any proof you could build using the machinery available at the time would be flawed
14:44:35 <Eduard_Munteanu> Or he might have had a mistaken proof, or part of a proof.
14:44:44 <dolio> illissius: Yes. It's known that existentials and the equality GADT is sufficient for all other GADTs.
14:44:46 <soupdragon> yeah I mean I don't think he even came up with a proof
14:45:12 <dolio> Are sufficient.
14:45:17 <illissius> dolio: oh. okay then. neat :)
14:45:19 <Eduard_Munteanu> Yeah, most of mathematics we know has been reworked only recently.
14:46:01 <wli> The old/original stuff is a lot of times easier to understand.
14:47:10 <dolio> illissius: That's probably how GHC implements GADTs internally, too. The Fc type system just has the equality constraints.
14:47:48 <wli> Eduard_Munteanu: Any particular topics in math you're thinking of? 
14:48:43 <Eduard_Munteanu> wli: not really, but standards were raised around the 19th century AFAIK. Before that, proofs weren't really formal.
14:49:42 <Eduard_Munteanu> And basically they reworked and checked all proofs, I think we owe a lot of that to Hilbert.
14:49:51 <bremner> journals from the 18th century are more like reports of ideas people have been thinking about.
14:50:08 <bremner> (confession, I generalized based on 1 or 2 examples there)
14:50:48 <Guest71818> Hi
14:50:51 <wli> Eduard_Munteanu: Calculations etc. with little/no justification. A hard calculus computation would get published as a paper etc.
14:51:02 <Eduard_Munteanu> Heh.
14:51:07 <Eduard_Munteanu> Guest71818: hi.
14:51:09 <illissius> dolio: yeah i'm looking into adding support for reifying existentials to TH and was trying to figure out where exactly the dividing line is between 'things you can do with GADTs' and 'things you can do with existentials' (GHC does indeed use a separate set of equality constraints for handling GADTs at this level), and turns out there is none.
14:51:56 <illissius> which means that while TH doesn't have support for GADT -syntax- it seems you can get the same functionality without it
14:52:16 <wli> Eduard_Munteanu: I was trying to say that that sort of thing also appeared.
14:53:14 <dolio> illissius: Does it already have support for equality constraints?
14:53:22 <Eduard_Munteanu> wli: nowadays the paper says "it's trivial to see that ..." where "..." takes you a long 15-minutes stare to decipher and understand :)
14:54:13 <illissius> dolio: yep
14:55:08 <dolio> Anyhow, in something like Agda, that encoding is more of a pain to use, but I guess in GHC, equality constraints behave about the same as a genuine indexed type.
14:56:14 <illissius> Eduard_Munteanu: i was under the impression that "it's trivial to see that..." is mathematician-speak for "i don't feel like explaining this atm, but..." :-)
14:56:59 <Saizan> what's a residual? in the context of term rewriting systems
14:57:27 <soupdragon> > 25-2*2*2
14:57:28 <lambdabot>   17
14:57:32 <soupdragon> > 25-3*3*3
14:57:33 <lambdabot>   -2
14:57:51 <Eduard_Munteanu> illissius: that too :)
15:03:09 <edwardk> hrmm so i have some of the basic plumbing for unicode lexing in. added \p{Letter} escapes to let you use the unicode categories directly and i'm adding the grep style \X regexp escape for match \P{Mark}\p{Mark}* to grab entire graphemes
15:04:21 <edwardk> i think i'm going to need to support outputting lexers for multiple input stream types. ascii, latin1, utf-8 and ucs-4 - the ucs-4 ones being used when parsing Strings directly, the other for when you're being fed bytes
15:05:19 <edwardk> so unicode lexing for utf-8 would become just a shim that expands the nfa that expects chars into one that expects its utf-8 expansion
15:05:38 <edwardk> theoretically a ucs-2 version would be nice to handle running automata over Data.Text as well
15:06:07 <mauke> "grep style" :-(
15:06:28 <edwardk> mauke: to be fair 'powerGREP' i think was the one that had \X ;)
15:06:45 <mauke> probably taken from perl
15:06:47 <edwardk> yeah
15:08:51 <edwardk> extended the alex syntax to allow bracing on the \x{1234} identifiers, though sadly i can't do that for \{decimal} ones. added \u{1234} as well
15:10:10 <edwardk> i'm trying to add support for \p{Arabic} and the lie, but can't find good tables yet
15:10:26 <mauke> steal from perl
15:12:29 <ivanm> edwardk: you're wanting to add support for lying to your alex replacement? :o
15:12:33 <ivanm> :p
15:12:40 <edwardk> like =)
15:16:51 <catenate> for utf8 steal from plan9
15:17:05 <edwardk> catenate: ?
15:17:22 <catenate> they put a lot of effort into handling utf8 well
15:17:30 <ahf> they made it :P
15:17:37 <edwardk> found a reference for unicode blocks and the standard \p \P names for them
15:17:38 <catenate> that too ;)
15:18:29 <edwardk> i think i may just bake in fairly 'magic' behavior into the lookup for blocks, which sadly eliminates the ability to enumerate =(
15:18:38 <Eduard_Munteanu> Hm, perhaps somebody knows... Has anybody investigated the possibility of a language to express, in the same form, code that can be assembled both as a microkernel and monolithic kernel?
15:18:49 <wli> Fluke
15:19:03 <wli> No, wait, that wasn't micro/mono that was something else.
15:19:54 <Eduard_Munteanu> I wonder if there could be a way to write code along with specifying boundaries etc. along which to separate that into different services.
15:26:53 <catenate> Google has 279,000 results for "device driver domain specific language"
15:27:28 <catenate> As part of the translation you could probably target different kernel types
15:27:29 <Eduard_Munteanu> catenate: that's an idea.
15:28:35 <Eduard_Munteanu> Though you don't want dumb translation, like processes sending each other "read byte x from y"
15:28:59 <Eduard_Munteanu> That would be a stupid ukernel :)
15:30:08 <monoidal> for monads there's liftM2, which is generalized to applicatives. Is there something similar to comonads?
15:30:32 <wli> There are more interesting things from my POV than micro vs. mono.
15:30:39 <monoidal> i'm attempting to write monads and comonads as one typeclass
15:30:49 <monoidal> and get sequence/parallelW as one function
15:31:13 <soupdragon> dropC2
15:32:06 <Eduard_Munteanu> There was some sort of liftW last time I looked in Control.Comonads
15:32:25 <monoidal> yes, but it's only functor equivalent
15:33:08 <monoidal> sequence is using foldr, and parallelW seems to use unfoldr, but I haven't figured it out precisely
15:36:12 <soupdragon> what does  intimation  mean?
15:38:46 <aasmith_> whats the name for (n+k) in pattern matching?
15:38:56 <soupdragon> n+k pattern
15:38:59 <soupdragon> :t first
15:38:59 <Eduard_Munteanu> :)
15:39:00 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:39:01 <soupdragon> :t last
15:39:01 <lambdabot> forall a. [a] -> a
15:39:14 <aasmith_> wondered if it had a different name also
15:39:34 <Eduard_Munteanu> Why, is it a pain when Googling?
15:39:43 <Eduard_Munteanu> I'd try n-plus-k then.
15:39:54 <aasmith_> indeed
15:40:36 <aasmith_> hah. the first match is a request to remove it from the language. :D
15:40:45 <monoidal> it is removed in h2010
15:53:45 <McManiaC> hey, is it possible to get that instance working? http://npaste.de/ar/
15:55:11 <soupdragon> McManiC, no
15:55:17 <soupdragon> the type is   (ReadFunc a -> MessageFunc' a) -> IO MessageFunc
15:55:26 <soupdragon> but it seems you want  ReadFunc a -> MessageFunc' a -> IO MessageFunc
15:55:31 <McManiaC> yeh
15:55:38 <soupdragon> so you should use the isomorphic type  (ReadFunc a, MessageFunc' a) -> IO MessageFunc
15:55:49 <soupdragon> (isomorphic to what you want, not what's giving the error)
15:58:36 <McManiaC> hm okay
15:58:43 <McManiaC> at least its working now, soupdragon 
15:58:44 <McManiaC> thx :)
16:00:54 <Phyx-> Hmm I have a problem here, I accidently unregistered the wrong directory package
16:01:03 <Phyx-> ghc-pkg unregister seems to ignore the --global flag
16:01:33 <Phyx-> but anyway, i've reinstalled the package but the hashes don't match so it still says it's missing
16:01:54 <Phyx-> so where are the config files for packages stored so i can change the entries?
16:02:53 <Zao> Arent' those the ones mentioned when listing packages?
16:03:10 <McManiaC> :t fmap
16:03:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:03:17 <Phyx-> ah right
16:03:24 <Phyx-> forgot about that, thanks Zao 
16:03:42 <Phyx-> i should probably submit a ticket too, ghc-pkg unregister ignores --global
16:05:10 <Phyx-> yuy
16:05:12 <Phyx-> yay*
16:05:17 <Phyx-> check is back in sync
16:07:18 <Phyx-> ok... i think cabal is drunk
16:07:19 <Phyx-> cabal.exe: dependencies conflict: ghc-6.13.20100521 requires filepath
16:07:19 <Phyx-> ==1.2.0.0 however
16:07:19 <Phyx-> filepath-1.2.0.0 was excluded because ghc-6.13.20100521 requires filepath
16:07:20 <Phyx-> ==1.1.0.4
16:07:42 <zygoloid> it's just toying with you
16:07:53 <mauke> http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
16:08:56 <Phyx-> mauke: thanks!
16:11:06 * hackagebot charset 0.2.0 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.2.0 (EdwardKmett)
16:11:34 <edwardk> (added canonicalized unicode block lookups)
16:13:35 <Phyx-> oooh
16:13:47 <Phyx-> this might explain the segfaults i've been getting
16:16:10 <Phyx-> bleh, 10 broken packages
16:16:31 * Phyx- modifies the entries again
16:28:02 <Phyx-> this is a pain
16:28:46 <Phyx-> check succeeds, there's only 1 version of filepath installed and it fails with the same thing
16:32:03 <Phyx-> ah, the package cache is screwed up
16:32:12 <Phyx-> can i just delete the file and type recache?
16:32:18 <aasmith_> @src zip
16:32:18 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:32:18 <lambdabot> zip _      _      = []
16:35:22 <Phyx-> brb
16:35:27 <Phyx-> i can't fix the ghc package
16:35:41 <Phyx-> recache is building a wrong file, dunno where it's getting the dependency from
16:35:46 <Phyx-> so i'm gonna rebuild ghc
16:35:50 <monochrom> erase and install afresh
16:40:07 <aasmith_> @src drop
16:40:08 <lambdabot> drop n xs     | n <= 0 =  xs
16:40:08 <lambdabot> drop _ []              =  []
16:40:08 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
16:43:15 * hackagebot charset 0.2.1 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.2.1 (EdwardKmett)
16:43:58 <aasmith_> @src (++)
16:43:58 <lambdabot> []     ++ ys = ys
16:43:58 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:43:58 <lambdabot> -- OR
16:43:58 <lambdabot> xs ++ ys = foldr (:) ys xs
16:44:18 <monoidal> just as sequence should be defined for applicatives, not only monads, parallelW should be defined for coapplicatives, not comonads. But every haskell type is coapplicative, so copointed is enough.
16:46:17 <sajkr> monoidal: why is every haskell type coapplicative?
16:46:43 <monoidal> well, I should have said copointed => coapplicative
16:47:04 <monoidal> applicative is pointed + liftA2 (,) :: f a -> f b -> f (a,b)
16:47:23 <monoidal> coapplicative is copointed (extract) + f (a, b) -> (f a, f b) which is fmap fst &&& fmap snd
16:48:14 <Philippa> could've sworn it's ->, not ,
16:48:30 <monoidal> from liftA2 (,) you can define <*> by doing uncurry ($)
16:49:16 <EvanR> does there exists computable functions for which the inverse is not computable
16:49:41 <monoidal> EvanR: you can compute inverse by repeatedly checking f(0), f(1) ...
16:49:59 <monoidal> but you have to do all computations in parallell, since they don't have to finish
16:50:36 <EvanR> i dont think that counts then
16:50:54 <monoidal> EvanR: you can't determine conclusively that something is not in image of recursive function
16:51:08 <monoidal> since there are r.e. sets that are not recursive
16:52:05 <EvanR> hrm...
16:52:45 <monoidal> for example, take f n = run n-th program and return n. the image is halting set
16:53:13 <EvanR> wait a minute
16:53:37 <sajkr> monoidal: i was thinking about (or better "trying to imagine") coapplicatives but couldn't find anything useful on the net.
16:53:57 <dolio> That isn't what I'd call a coapplicative.
16:53:57 <EvanR> monoidal: so f is not computable there if some program does not halt
16:53:58 <sajkr> monoidal: could you give me any pointers?
16:54:27 <dolio> Maybe that's what you need for parallelW, though.
16:54:44 <monoidal> sajkr: i made up the term "coapplicative" as dual to applicative. applicative can be thought of monoidal functor (see original paper about applicatives)
16:55:01 <monoidal> EvanR: it is computable, but not total
16:55:13 <zygoloid> monoidal: you know, naming things after yourself is a sure sign of a crackpot theory ;)
16:55:20 <EvanR> if we restrict it to n where program halts, is it then total
16:55:32 <monoidal> i wonder what zygoloid is :)
16:55:56 * zygoloid is a crackpot theory
16:56:01 <EvanR> a zygoloidal prepromorphism
16:56:46 <EvanR> look, now i fit in in #haskell
16:56:57 <zygoloid> \o/
16:58:32 <sajkr>     |
16:58:40 <sajkr>    / \
16:59:06 <monoidal> sajkr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26887#a26887
16:59:07 <EvanR> petrus strikes!
16:59:22 <monoidal> i'm attempting to join seq1 and seq2 to use the monoidal functor interface
16:59:47 <monoidal> i've already written one function that can serve both as fold and unfold
17:00:04 <monoidal> fold ::(Recursive c, Functor f) => c (f a) a -> c (Mu f) a 
17:00:16 <monoidal> for c = (->) it is fold, and for (Dual (->)) it is unfold
17:01:35 <sajkr> monoidal: thx.
17:02:22 <monoidal> it took me 40 minutes to write one line. I hope I'll do better with sequence :)
17:03:34 <EvanR> better to spend 40 minutes on one line than 40 lines in 1 minute (if the two situations resulted in code of equal worth)
17:26:42 <tolkad> How do I use a haskell type sort of like a C enum? I have a bunch of constructors which are elements of the enum. Each constructor is associated with a unique integral number.
17:27:28 <tolkad> I tried having a function that converts from an integral to one of my constructors, and another that converts back but it means I need to rewrite the entire mapping
17:28:02 <monoidal> you could have data X = A | B | C and then f x = lookup x [(A, 42), (B, 23), (C, 21)]
17:28:24 <monoidal> that lookup table is easy to flip
17:28:26 <EvanR> tolkad: theres a haskell class for this, Enum
17:28:33 <mauke> data X = A | B | C deriving (Eq, Ord, Enum, Bounded, Read, Show)
17:28:41 <tolkad> oh...
17:28:52 <tolkad> so, how do I set the integral each is associated with?
17:28:59 <mauke> ^ like that
17:29:02 <monoidal> it is sequentially numbered from 0 by defult
17:29:06 <EvanR> lets you convert values of the type to and from Int
17:29:16 <EvanR> @src Enum
17:29:17 <lambdabot> class  Enum a   where
17:29:17 <lambdabot>     succ                     :: a -> a
17:29:17 <lambdabot>     pred                     :: a -> a
17:29:17 <lambdabot>     toEnum                   :: Int -> a
17:29:17 <lambdabot>     fromEnum                 :: a -> Int
17:29:17 <tolkad> oh, is there anyway to specify a number for one?
17:29:19 <lambdabot> [3 @more lines]
17:29:30 <Eduard_Munteanu> I wonder how that default numbering works.
17:29:31 <mauke> only if you define the instance manually
17:29:32 <Draconx|Laptop> tolkad, write the Enum instance yourself.
17:29:45 <tolkad> ah, I guess I could also use padding values
17:29:45 <mauke> but why do you need that?
17:29:54 <tolkad> I don't actually, just curious
17:29:59 <tolkad> I have another question
17:30:05 <monoidal> Eduard_Munteanu: Enum works for enumerations only afair (you can't enumerate data X = Y | Z Integer)
17:30:38 <tolkad> if something returns Maybe <something>, I will need to define the default Nothing at some point
17:30:39 <EvanR> you mean deriving wont work
17:30:45 <monoidal> yes
17:31:03 <tolkad> but, it seems after I define the default, wont it override any subsequent function definitions?
17:31:04 <EvanR> :t fromMaybe
17:31:04 <monoidal> oh, obviously one can define custom instance
17:31:05 <lambdabot> forall a. a -> Maybe a -> a
17:31:07 <Eduard_Munteanu> monoidal: yeah, still... I wonder what piece of code could associate data MyEnum = Blah | Foo | Bar | Baz with numbers according to the data definition, in that order :)
17:31:23 <mauke> tolkad: huh?
17:31:27 <Eduard_Munteanu> Perhaps it's not a library stuff.
17:31:33 <monoidal> in template haskell you have access to constructors in order
17:31:40 <mauke> Eduard_Munteanu: the compiler
17:31:48 <Eduard_Munteanu> monoidal, mauke: I see.
17:31:54 <Eduard_Munteanu> That explains it.
17:31:59 <mauke> 'deriving' is built into the language
17:32:14 <Eduard_Munteanu> mauke: yeah, I didn't know it had special semantics for Enum
17:32:42 <mauke> lol wut
17:32:48 <mauke> define "special"
17:33:01 <monoidal> tolkad: if something returns Maybe a, then you can pattern match and check two cases
17:33:02 <mauke> and how Enum is different from Ord and Show in this regard
17:33:04 <EvanR> different from Show, Read, Ord
17:33:06 <Eduard_Munteanu> mauke: obviously when I write data X ... deriving MyClass that won't do anything special.
17:33:16 <mauke> Eduard_Munteanu: well, it will give you an error
17:33:18 <Eduard_Munteanu> mauke: in this context the name-value association is rather special
17:33:22 <tolkad> like, if I have f :: x -> Maybe x;        f 37.2 = Just 3.9;         f x = Nothing;         f "lol" = "loooool" the last one will never be used
17:33:23 <monoidal> toklad: if you are writing a function to return Maybe a, you don't have to return both of them
17:33:35 <mauke> tolkad: that has nothing to do with Maybe
17:33:51 <mauke> tolkad: also, that doesn't typecheck
17:34:06 <tolkad> well, if I want to use Maybe, is there a better way of defining the default case of Nothing so I can still make subsequent definitions?
17:34:06 <Eduard_Munteanu> mauke: oh? I thought 'deriving' worked for any typeclasses, didn't bother to try though.
17:34:09 <monoidal> tolkad: also, this is error (last declaration is [Char] = String)
17:34:10 <tolkad> and yeah, I made an error
17:34:19 <tolkad> I forgot a Just
17:34:33 * Eduard_Munteanu was terribly wrong it seems.
17:34:45 <tolkad> so, anyway, is there a better way of defining the default case?
17:34:46 <mauke> tolkad: no, you tried to pattern match against 37.2 for any type x
17:34:53 <mauke> tolkad: that's a type error in your first equation
17:34:54 <tolkad> oh, that's not allowed?
17:34:56 <tolkad> oh
17:34:57 <EvanR> deriving (FirstPersonShooter, MassivelyMultiplayerOnlineRPG, WebBrowser)
17:35:13 <tolkad> ok, bye
17:35:14 <EvanR> haskell rocks ^
17:35:14 <monoidal> tolkad: you can use lookup function: f x = lookup x [(37.2, 3.9), (2.5,2)]
17:36:06 <Eduard_Munteanu> "You can only use deriving with a limited set of built-in classes."
17:36:13 <Eduard_Munteanu> That explains it.
17:36:56 <Eduard_Munteanu> I always thought deriving Show was a library thingy.
17:37:05 <Eduard_Munteanu> Eq too.
17:39:34 <soupdragon> @let py t = (1-t^2,2t,1+t^2)
17:39:35 <Philonous> b.y.o.i. 
17:39:35 <lambdabot>  Defined.
17:39:42 <Philonous> Bring your own instances. 
17:39:46 <soupdragon> > py . [1..]
17:39:47 <lambdabot>   [(0,2,2),(-3,2,5),(-8,2,10),(-15,2,17),(-24,2,26),(-35,2,37),(-48,2,50),(-6...
17:39:58 <soupdragon> > 8^2 + 2^2 == 10^2
17:39:58 <lambdabot>   False
17:40:04 <soupdragon> >:|
17:40:13 <soupdragon> :t 2t
17:40:14 <lambdabot> forall t. (Num (Expr -> t)) => t
17:40:20 <soupdragon> @undef
17:40:24 <soupdragon> @let py t = (1-t^2,2*t,1+t^2)
17:40:25 <lambdabot>  Defined.
17:40:28 <soupdragon> > py . [1..]
17:40:29 <lambdabot>   [(0,2,2),(-3,4,5),(-8,6,10),(-15,8,17),(-24,10,26),(-35,12,37),(-48,14,50),...
17:40:35 <soupdragon> > 8^2 + 6^2 == 10^2
17:40:36 <lambdabot>   True
17:40:43 <monoidal> it's 4, 3, 5 when reduced
17:40:44 <Eduard_Munteanu> Philonous: well yes, that's what I did. I only did deriving Show et. al and never bothered trying with other stuff because I knew I had to define instances.
17:41:18 <Eduard_Munteanu> I thought it defaulted to some default class methods when doing deriving.
17:41:18 <Philonous> Eduard_Munteanu: Not necessarily. Some libraries provide TH magic. 
17:41:46 <Eduard_Munteanu> Philonous: I see.
17:42:40 <Eduard_Munteanu> For example, I thought 'show' worked by calling some sort of 'typeof', e.g. on constructors... :)
17:43:00 <EvanR> eww
17:46:11 <Eduard_Munteanu> I'm not an expert (or a fan of) on C++, but are templates there analogous to Haskell's polymorphism?
17:46:27 <Eduard_Munteanu> I wonder if the Curry-Howard isomorphism works there.
17:47:02 <EvanR> c++ templates are like data Maybe a = Just a | Nothing
17:47:23 <Veinor> whoa, I think I finally get rank 2 types :O
17:47:27 <EvanR> c++ virtual methods are like type classes
17:47:42 <Eduard_Munteanu> I see.
17:48:00 <Philippa> Eduard_Munteanu: C++ doesn't have parametricity, so Curry-Howard isn't worth much
17:48:05 <Eduard_Munteanu> EvanR: but isn't parametric polymorphism and C++'s type checking sufficient to write theorems?
17:48:14 <Eduard_Munteanu> Philippa: ah.
17:48:31 <EvanR> i heard c++ is turing complete
17:48:36 <EvanR> so probably
17:49:04 <Philippa> EvanR: no, it doesn't work like that
17:49:33 <monoidal> there was a comparision of c++ templates and haskell type classes somewhere
17:49:34 <Eduard_Munteanu> Philippa: by parametricity you mean you can't write functions a -> b -> (a, b) in C++?
17:49:49 <Philippa> Eduard_Munteanu: no, I mean that templates can tell what the parameter is
17:50:03 <Eduard_Munteanu> Philippa: oh.
17:50:04 <augur> hmm
17:50:30 <Eduard_Munteanu> Isn't this what type families do in Haskell?
17:50:44 <augur> whos familiar with the idea of taking an object and extracting a part of it so you have a context with a hole, and a filler for that hole?
17:50:54 <augur> and by familiar, i mean intimately. :P
17:51:02 <EvanR> Philippa: not that i know whats going on, but what?
17:51:25 <mauke> you can specialize templates
17:51:52 <Philippa> EvanR: being a useful logic is about what you can deduce, not about what you can 'do'
17:51:52 <augur> mauke: me?
17:51:54 <mauke> that's what lets you write stuff like is_ptr<T>::value
17:52:25 <EvanR> Philippa: so proofs are not related to computation?
17:52:32 <Philippa> EvanR: C++ corresponds to a logic where the statements are (on their own, at least) pretty meaningless
17:52:39 <Philippa> EvanR: *propositions* aren't
17:52:52 <mauke> EvanR: I can prove anything: fix id
17:53:06 <EvanR> > fix id
17:53:10 <lambdabot>   mueval-core: Time limit exceeded
17:53:24 <Philippa> @type fix id
17:53:25 <lambdabot> forall a. a
17:53:30 <Philippa> that's the important part
17:53:52 <EvanR> :t undefined
17:53:53 <lambdabot> forall a. a
17:54:13 <augur> aha, zippers are the tree versions i was looking for
17:54:21 <augur> ok, anyone intimately familiar with ZIPPERS?
17:54:22 <augur> :P
17:54:38 <Philippa> EvanR: that too, but the point is that you don't need undefined as a magic value
17:54:44 <Eduard_Munteanu> augur: why not ask the question directly?
17:54:53 <Philippa> the point is, all statements in haskell's logic are true. So it's a boring logic
17:55:11 <EvanR> :t let x = x in x
17:55:12 <lambdabot> forall t. t
17:55:15 <Philippa> (of course, those that're true and have terminating proofs are more interesting)
17:55:26 <Philippa> EvanR: the point is, those have any type you want - they prove any proposition you want
17:55:39 <Philippa> C++'s logical interpretation is much, much messier
17:55:53 <Eduard_Munteanu> Philippa: what do you mean by that?
17:56:00 <augur> Eduard_Munteanu: ok, fine, anyone know of any work looking at extending the notion of zippers in a pattern matching context to kleene-star like results?
17:56:10 <EvanR> im going to have to at some pointer understand this stage of things
17:56:24 <EvanR> point*
17:56:52 <Philippa> Eduard_Munteanu: I mean that without making a greater number of assumptions about meaningful proofs/restricting yourself to a 'sane' subset of C++, you can't extract any useful meaning
17:57:46 <Eduard_Munteanu> I see.
17:58:09 <Philippa> of course, if all you do is code up a few logical primitives and work only with those, you'll be fine
17:58:19 <augur> guess not, eh Eduard_Munteanu
17:58:26 <Philippa> but there's not much point, because you'll have to keep doing the metalogic to make sure what you're doing is legit
17:59:01 <Eduard_Munteanu> augur: seems so. Just my 2 cents, I don't think matching a pattern containing the Kleene star is decidable or has a unique solution in general.
17:59:12 <augur> sure it does
17:59:21 <augur> it just depends on the complexity of the patterns
17:59:56 <Eduard_Munteanu> augur: yeah, it works on a lot of useful cases.
18:00:03 <augur> for instance, a* is a pattern match with a kleene star.
18:00:39 <EvanR> '', a, aa, aaa, ... ;)
18:00:40 <Philippa> I believe it's decidable on finite structures, and you don't need to adopt too many additional rules to get unique solutions
18:00:58 <Philippa> anyone writing a*a* as a pattern deserves the kicking they'll get, but it's also easy enough to write a warning for
18:01:56 <augur> what im looking for more is prior art on a way of getting a pattern matched zipper (e.g. K{1} =:= [2,1,3] == (1, [2,@,3])) that allows the context to be self embedded
18:02:35 <Eduard_Munteanu> That sounds like comonads to me.
18:02:48 <Eduard_Munteanu> s/like/like a job for/
18:02:55 <augur> for instance, i might want to match against an object where the context is (@,_), or ((@,_),_), or (((@,_),_),_), or ...
18:03:04 <augur> so its sort of like (@,_)+
18:05:42 <EvanR> @_@
18:05:46 <augur> :p
18:05:52 <Eduard_Munteanu> Hypnotoad!!!
18:07:02 <gwern> @quote hypno
18:07:03 <lambdabot> jfredett says: A monster! HAH! It will not be a monster, but a god! ALL SHALL BOW BEFORE MY SPAWN AND DESPAIR! ALL HAIL THE PROGRAMMER CHILD! ALL HAIL THE HYPNOTOAD!
18:10:52 <dancor> @src isDigit
18:10:52 <lambdabot> Source not found. Just try something else.
18:12:49 <aasmith_> @src Char.isDigit
18:12:49 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:14:08 <monoidal> @src Data.Char.isDigit
18:14:09 <lambdabot> Source not found. You type like i drive.
18:14:22 <dancor> lambdaboo
18:15:19 <monoidal> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Unicode.html
18:17:51 <proq> I'm trying to find yhc-n
18:18:03 <proq> on-javascript, but the links seem to have moved
18:18:22 <proq> does anyone know where a copy of yhc-on-javascript is?
18:22:46 <aasmith_> @src and
18:22:47 <lambdabot> and   =  foldr (&&) True
18:23:40 <deech> Hi all, I've heard Haskell's type system likened to Prolog so is learning Prolog a good way to understand the type system?
18:24:06 <aavogt> why do you want to learn how to program in the type system?
18:24:22 <soupdragon> deech, whover said that.. I think they're wrong
18:24:35 <soupdragon> deech, there are some similarities but it's a verryy weak connection
18:24:54 <soupdragon> deech, typeclasses are a bit closer because they have the search built in but still pretty far off
18:25:27 <deech> aavogt: just trying to understand the type system better. No type-level programming for me ... yet.
18:25:27 <aavogt> closer than what else, soupdragon?
18:25:28 <Philonous> deech: Learning Prolog ist probably a good idea for others reasons (broadening your programming experience always is)
18:25:56 <soupdragon> well than without
18:26:22 <soupdragon> yeah Prolog or Kanren or something, and CHR
18:26:36 <soupdragon> extemely unusual compared to most programming languages
18:27:01 <Eduard_Munteanu> Sure, and Haskell is... :)
18:27:13 <deech> soupdragon: when I hear a Haskell programmer call a language unusual it makes me scared.
18:27:17 <soupdragon> :D
18:28:02 <soupdragon> I think taking ideas from CHR and blending them into the typeclass system would be a tremendous improvement
18:28:07 <Eduard_Munteanu> Well one thing I really think is strange is APL.
18:28:13 <Eduard_Munteanu> But not due to its semantics.
18:28:14 <deech> What's CHR?
18:28:28 <edwardk> constraint handling rules
18:28:36 <deech> ah
18:28:41 <soupdragon> deech, well it's first home is prolog - this language is usally embedded in another host 
18:28:46 * hackagebot charset 0.2.2 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.2.2 (EdwardKmett)
18:28:57 <edwardk> they are a way of handling unification and error messages from the compiler in a graceful way put forth by sulzmann etc.
18:28:58 <Eduard_Munteanu> Agda seems to borrow from APL a bit.
18:29:00 <edwardk> er iirc
18:29:00 <winxordie> ooh! I heard CHR. What's so special about CHR?
18:29:13 <winxordie> My prology friends keep telling me about it.
18:29:20 <soupdragon> deech, if you know a little about the declarativle style of prolog programming - CHR is sort of like going much further with that , and having ridiculously good theoretical properties
18:29:44 <edwardk> soupdragon: now, whether or not those properties play nice with all the system Fc craziness going on in GHC these days remains to be seen ;)
18:29:55 <deech> soupdragon: is this the same as proving properties?
18:29:58 <soupdragon> yeah joining these up wont be easy
18:30:34 <soupdragon> there are slides about CHR <http://www.cs.kuleuven.be/~jon/presentations/ulm09_tutorial.odp>
18:30:44 <Eduard_Munteanu> Hm... Wikipedia says Haskell hosts CHR.
18:30:51 <Eduard_Munteanu> Any implementation of that?
18:30:52 <soupdragon> but it would probably be sensible to practice a bit with prolog first
18:31:11 <soupdragon> Eduard_Munteanu: I have only managed to compile one of them and its efficiency was terrible
18:31:29 <edwardk> Eduard_Munteanu: yes. a couple. google for chameleon and possibly for helium
18:31:43 <Eduard_Munteanu> I see, thanks.
18:31:55 <Eduard_Munteanu> Though Helium is that crippled Haskell, isn't it?
18:32:55 <edwardk> YES
18:32:57 <edwardk> er yes ;)
18:33:13 <soupdragon> (if you get chameleon to compile you're mored dedicated than me :p)
18:33:24 <Eduard_Munteanu> Found a treasure... http://www.haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
18:33:26 <Philonous> deech: And I believe the point behinde the comparison of Haskells type system to prolog is that functional dependencies offer a rather roundabout way of type-level functions as you use them like predicates, not functions. So for instance you don't say z = Add x y;  but Add x y z, as in (Add x y z) => Vec x -> Vec y -> Vec z 
18:33:51 <winxordie> soupdragon: looking through the slides right now - what type of theoretical goodness are you talking about?
18:34:32 <soupdragon> winxordie; mostly the efficiency things - I think it holds some 'world records' in terms of checking the most boxes in the [Good] column
18:34:55 <soupdragon> um probably not the sort of answer you wanted
18:35:10 <winxordie> lol
18:35:13 <soupdragon> (I can't remember the names of any of the things i have in mind)
18:35:25 <winxordie> fair 'nough
18:39:44 <edwardk> gah, does haskell-src-exts have a way to specify the starting source location?
18:40:16 <aavogt> I think you're going to have to post-process the AST
18:40:23 <edwardk> !@#&(*
18:41:17 <djahandarie> God damn computational geometry is confusing
18:41:23 <aavogt> maybe some syb or other generics incrementing src spans and what not my do
18:41:28 <edwardk> djahandarie: hah
18:41:37 <edwardk> aavogt: =(
18:41:49 <aavogt> *may
18:42:17 <soupdragon> I want to make a 2D geometry program in haskell
18:42:38 <aavogt> what will it do?
18:42:41 <soupdragon> to make interactive stuff like elements
18:42:48 <soupdragon> and just play around
18:42:53 <djahandarie> I'm still stuck on that problem of efficiently finding a minimum area k-gon inscribing a set of points in R^2
18:42:57 <soupdragon> animate Archimedes diagrams
18:43:06 <soupdragon> I know there are programs which do it already but I don't know how to use them
18:43:08 <edwardk> djahandarie: convex hull?
18:43:21 <edwardk> no wait you want to fix k
18:43:32 <djahandarie> Yes
18:43:49 <djahandarie> Convex hull would give me a polygon
18:44:22 <djahandarie> And there is an algorithm by Shor and some other folks to find a maximum-area k-gon inscribed in an n-gon
18:44:50 <djahandarie> Not a minimum-area k-gon though.
18:45:50 <aavogt> are n-gons regular polygons?
18:45:59 <djahandarie> My professor said that I may be able to work it out if I try to find a relation via a Mobius transform that exchanges 0 and infinity
18:46:23 <djahandarie> aavogt, no, just a polygon with n sides
18:46:35 <djahandarie> aavogt, but the algorithm is for a convex n-gon only
18:46:37 <soupdragon> djahandarie: kind of like how those tilings.. hm can't remember the name.. correspond to convex hulls
18:47:06 <soupdragon> voroni 
18:52:23 <soupdragon> reading this mathematics book is just making feel like such an idiot for not thinking of these things my self :D
18:53:16 <soupdragon> trigonometry and stuff
18:53:26 * aavogt finds most things fancy enough to wonder how somebody came up with it in the first place
18:53:54 * hackagebot mstate 0.1.3 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.1.3 (NilsSchweinsberg)
18:55:33 <aavogt> the monad library situation is rather unfortunate
19:04:24 <augur> oh friends, i love you all. youve yet again helped me resolve an issue. :D
19:04:48 <augur> i dont actually *need* the magic zipper thing afterall. :D
19:09:08 <Veinor> djahandarie: did that link I sent you not help?
19:11:47 <djahandarie> Veinor, they did help a lot
19:11:55 <Veinor> whoo :D
19:28:31 <soupdragon> > (`mod`3) . [0..2]
19:28:32 <lambdabot>   [0,1,2]
19:28:35 <soupdragon> > (`mod`3) . (^2) . [0..2]
19:28:36 <lambdabot>   [0,1,1]
19:28:51 <Veinor> wait, what?
19:28:52 <Veinor> :t 2
19:28:53 <lambdabot> forall t. (Num t) => t
19:29:00 <soupdragon> just normal 2's
19:29:06 <Veinor> > (+1) . 2
19:29:07 <lambdabot>   No instance for (GHC.Num.Num (f a))
19:29:07 <lambdabot>    arising from a use of `e_112' at <in...
19:29:20 <Veinor> > (`mod` 3) $ 2
19:29:21 <lambdabot>   2
19:29:24 <Veinor> > (`mod` 3) . 2
19:29:25 <lambdabot>   No instance for (GHC.Num.Num (f a))
19:29:25 <lambdabot>    arising from a use of `e_132' at <in...
19:29:28 <soupdragon> Veinor, imagine a list like a function from indices to elements
19:29:39 <Veinor> that's...
19:29:49 <soupdragon> so [0,1,2] is ([0,1,2]!!)
19:29:52 <Veinor> :t (.)
19:29:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:29:58 <Veinor> oh yeah
19:30:03 <Veinor> I was wondering why that was typechecking
19:30:23 <soupdragon> @let toBangBang list = (list!!)
19:30:24 <lambdabot>  Defined.
19:30:40 <soupdragon> @let fromBangBang listBang = listBang [0..]
19:30:41 <lambdabot>  Defined.
19:30:56 <soupdragon> > take 3 $ fromBangBang ((`mod`3) . (^2) . toBangBang [0..2])
19:30:57 <lambdabot>   Couldn't match expected type `[t]'
19:30:57 <lambdabot>         against inferred type `GHC.Types...
19:30:59 <Veinor>  . = fmap, right?
19:31:06 <Cale_> Right
19:31:12 <Veinor> whoo.
19:31:14 <soupdragon> somethingn went wrong :S
19:31:21 <etpace> How can I "split" a string? so split "foo.bar.baz" "." = ["foo","bar","baz"]
19:31:24 <soupdragon> oh I have to map
19:31:37 <soupdragon> > take 3 $ (flip map [0..]) ((`mod`3) . (^2) . toBangBang [0..2])
19:31:38 <lambdabot>   [0,1,1]
19:31:41 <soupdragon> yeah
19:31:44 <Cale_> etpace: The split library on hackage has a lot of useful functions for things like that
19:31:48 <soupdragon> so I see the . as basically doingthat
19:31:51 <soupdragon> automatically
19:32:03 <soupdragon> similarly you can write     x <- f . g . getLine
19:32:05 <etpace> nothing in the base packages Cale_?
19:32:35 <soupdragon> where f and g are pure
19:32:36 <Cale_> etpace: Well, you could repeatedly use break (=='.')
19:33:05 <Cale_> etpace: and for spaces/lines, there are words and lines
19:33:15 <Cale_> > words "here are some words"
19:33:16 <lambdabot>   ["here","are","some","words"]
19:33:28 <aavogt> > unfoldr (\x -> let y = break (=='.') x in if null (fst y) then Nothing else Just y) "foo.bar.baz"
19:33:29 <lambdabot>   ["foo"]
19:33:34 <Cale_> > lines "foo \n  bar \n  baz "
19:33:35 <lambdabot>   ["foo ","  bar ","  baz "]
19:33:47 <aavogt> > unfoldr (\x -> let y = break (=='.') x in if null (fst y) && null (snd y) then Nothing else Just y) "foo.bar.baz"
19:33:48 <lambdabot>   ["foo","","","","","","","","","","","","","","","","","","","","","","",""...
19:34:01 <aavogt> something broke....
19:34:02 <Cale_> have to pattern match away the separator
19:34:03 <soupdragon> Cale someone in #math is looking for yoou btw
19:34:13 <soupdragon> i dont know if it matters
19:34:20 <soupdragon> saccade_
19:35:09 <Cale_> > unfoldr (\x -> let (us,v:vs) = break (=='.') x in if null vs then Nothing else Just us) "foo.bar.baz"
19:35:10 <lambdabot>   Couldn't match expected type `(a, [GHC.Types.Char])'
19:35:10 <lambdabot>         against inferr...
19:35:14 <Cale_> errr
19:35:20 <etpace> > let (x,y) = foldr (\x (word,acc)-> if x == '.' then ([], word:acc) else (x:word,acc)) ([],[]) "foo.bar.baz" in x:y
19:35:21 <lambdabot>   ["foo","bar","baz"]
19:35:26 <Cale_> > unfoldr (\x -> let (us,v:vs) = break (=='.') x in if null vs then Nothing else Just (us,vs)) "foo.bar.baz"
19:35:27 <lambdabot>   ["foo","bar"*Exception: <interactive>:1:152-178: Irrefutable pattern failed...
19:35:34 <Cale_> Ah, right
19:35:43 <Cale_> break sometimes gives an empty list
19:36:03 <Cale_> unfoldr is probably trickier than needs be here
19:36:41 <soupdragon> > do x <- [0..6] ; y <- [0..6] ; guard ((x^2+y^2)`mod`7==0) ; return (x,y)
19:36:42 <lambdabot>   [(0,0)]
19:36:53 <soupdragon> > do x <- [0..10] ; y <- [0..10] ; guard ((x^2+y^2)`mod`11==0) ; return (x,y)
19:36:54 <lambdabot>   [(0,0)]
19:36:57 <soupdragon> dammit
19:37:03 <soupdragon> is this impossible
19:37:20 <aavogt> @type iterate (span (/='.') . drop 1 . snd)
19:37:22 <lambdabot> ([Char], [Char]) -> [([Char], [Char])]
19:37:31 <Cale_> > let splitOn c xs = case break (==c) xs of (us,[]) -> [us]; (us,v:vs) -> us : splitOn c vs in splitOn '.' "foo.bar.baz"
19:37:32 <lambdabot>   ["foo","bar","baz"]
19:37:53 <Cale_> Probably simpler just to recurse normally
19:38:00 <aavogt> > takeWhile (not . null) . map fst . iterate (span (/='.') . drop 1 . snd) $ "foo.bar.baz"
19:38:01 <lambdabot>   Couldn't match expected type `([GHC.Types.Char], [GHC.Types.Char])'
19:38:01 <lambdabot>        ...
19:38:12 <aavogt> > takeWhile (not . null) . map fst . iterate (span (/='.') . drop 1 . snd) $ (undefined,"foo.bar.baz")
19:38:13 <lambdabot>   *Exception: Prelude.undefined
19:38:28 <aavogt> > takeWhile (not . null) . map fst . drop 1 . iterate (span (/='.') . drop 1 . snd) $ (undefined,"foo.bar.baz")
19:38:30 <lambdabot>   ["oo","bar","baz"]
19:38:38 <aavogt> hheh
19:38:54 <Cale_> > iterate (drop 1 . dropWhile (/= '.')) "foo.bar.baz"
19:38:56 <lambdabot>   ["foo.bar.baz","bar.baz","baz","","","","","","","","","","","","","","",""...
19:39:18 <Cale_> > takeWhile (not . null) . iterate (drop 1 . dropWhile (/= '.')) $ "foo.bar.baz"
19:39:18 <lambdabot>   ["foo.bar.baz","bar.baz","baz"]
19:39:27 <Cale_> > map (takeWhile (/= '.')) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= '.')) $ "foo.bar.baz"
19:39:28 <lambdabot>   ["foo","bar","baz"]
19:39:39 <aavogt> that one does more work
19:39:57 <Cale_> Sure, a bit :)
19:44:49 <gwern> 'Lambda: the ultimate syntax-semantics interface'
19:45:00 <gwern> I suppose oleg will either blow my brain or just confuse me with this one
19:45:41 <Eduard_Munteanu> Oleg's web page is lots of fun.
19:45:47 <gwern> 'Day in, day out, the semanticist checks types and simplifies terms. Can the digital computer help with these calculations? In fact, modern programming languages offer exactly the modularity features that make it easy to try fragments out and scale them up. To show how, we express so-called extensible interpreters as functional programs and apply the technique to natural-language semantics. Specifically, we work our way from the simply typed lambda ...
19:45:53 <gwern> ... calculus and a context-free grammar to a dynamic treatment of quantification and anaphora. Striving to be comprehensible and informative to both linguists and programmers, we use the programming language Haskell without assuming specific knowledge of it.'
19:45:57 <gwern> auugh natural language programming
19:46:01 <gwern> better not even bother reading it
19:46:08 <soupdragon> Cale sorry X)
19:46:45 <Jafet> Chomsky meets MSR? Insert Addams Family theme here...
19:46:45 <lambdabot> Jafet: You have 1 new message. '/msg lambdabot @messages' to read it.
19:52:15 <dancor> @src span
19:52:16 <lambdabot> span _ xs@[]                     =  (xs, xs)
19:52:16 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
19:52:16 <lambdabot>                   | otherwise    =  ([],xs)
19:52:53 <mauke> what
19:53:04 <mauke> span _ [] = ([], []) too obvious?
19:53:07 <augur> dancor: whats the gestalt of span?
19:53:37 <augur> gwern: whoa hello, formal language stuff? :D
19:53:43 <augur> syntax-semantics interface stuff? :D
19:53:53 <augur> :D
19:54:19 <augur> the paper you're referring to isnt about natural language programming
19:54:38 <Veinor> mauke: ... wait, what?
19:54:42 <Veinor> why would they bind [] to xs
19:54:54 <aavogt> for consistency with the next equation
19:55:57 <Veinor> I wish I could make a Set of things that don't have a sensible Ord instance.
19:56:26 <aavogt> maybe for some implementations, using  xs@[]  lets you share those []  constructors
19:56:26 <Jafet> You've been taking too much Hash
19:56:38 <Veinor> Jafet: ?
19:57:13 <dancor> augur: gestalt?
19:57:15 <aavogt> @quote Hash
19:57:16 <lambdabot> No quotes match. Wrong!  You cheating scum!
19:57:31 <mauke> aavogt: I thought they were shared anyway
19:57:45 <mauke> I mean, how many versions of [] can you have?
19:57:46 <aavogt> mauke: I don't think that's specified
19:58:03 <augur> dancor: well, the sort of /purpose/ of the function, what it does holistically, outside of that algorithm
19:58:14 <augur> what the mathematical function is
19:58:14 <Veinor> I'd like, like... a Set that took a comparison type thing as  part of its constructor
19:58:28 <aavogt> then you can make a newtype
19:58:35 <aavogt> with an Ord instance
19:58:39 <Veinor> true.
19:58:48 <Veinor> I hadn't even thought of that.
19:59:12 <dancor> > span (== 't') "gestalt"
19:59:13 <lambdabot>   ("","gestalt")
19:59:14 <aavogt> unsafeCoerce is ok to and from newtypes if you're concerned about any runtime stuff
19:59:18 <dancor> > span (/= 't') "gestalt"
19:59:20 <lambdabot>   ("ges","talt")
19:59:30 <Veinor> aavogt: as in 'explicitly defined to be OK'?
19:59:31 <augur> hmm!
19:59:37 <aavogt> yes
19:59:41 <Veinor> cool
19:59:48 <augur> > span (/= 'c') "abcabcabc"
19:59:49 <lambdabot>   ("ab","cabcabc")
20:00:18 <augur> aha, so its "split along the first non-p item"
20:00:18 <dancor> "pulls out prefix satisfying predicate"
20:00:21 <aavogt> so that you don't end up with any   map id, though maybe the optimizer is smart
20:01:12 <dancor> @src break
20:01:13 <lambdabot> break p =  span (not . p)
20:01:32 <augur> and break is span splitting along the first p item!
20:01:37 <augur> interesting :)
20:02:01 <aavogt> perhaps it's nicer to see them as   \p x -> (takeWhile p x , dropWhile p x)
20:02:11 <aavogt> more helpful or whatever
20:02:20 <aavogt> (that one being span
20:02:22 <aavogt> )
20:02:26 <augur> well, now i get the idea
20:03:13 <Veinor> map id?
20:03:55 <augur> [x_0 ... x_i ... x_n] => ([x_0 ... x_i-1], [x_i ... x_n]) where all p(x_j) for 0 <= j < i, and !p(x_j) for i <= j <= n
20:03:58 <aavogt> map id is an expensive way to write id
20:04:07 <Veinor> I was going to say.
20:04:34 <aavogt> I mean that   map NewtypeConstructor  == map id    as far as runtime is concerned
20:05:17 <aavogt> but maybe ghc is smart enough to avoid useless work
20:07:18 <augur> lets see
20:07:23 <Veinor> ah.
20:07:30 <augur> ?faq can haskell refactor to avoid useless work?
20:07:31 <lambdabot> The answer is: Yes! Haskell can do that.
20:07:41 <augur> :D
20:07:45 <Veinor> :D
20:07:55 <Veinor> ?faq can Haskell solve the halting problem?
20:07:55 <lambdabot> The answer is: Yes! Haskell can do that.
20:08:43 <augur> god can you imagine when lambdabot could /actually/ answer questions?
20:09:22 <Jafet> @vixen Can't you already?
20:09:22 <lambdabot> let me answer that later, okay?
20:09:26 <aavogt> @where hare
20:09:26 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
20:10:10 <augur> @where happiness
20:10:11 <lambdabot> I know nothing about happiness.
20:10:13 <augur> :
20:10:14 <augur> :(
20:10:38 <augur> @where true love
20:10:39 <lambdabot> I know nothing about true.
20:10:48 <augur> aha!
20:11:44 <aavogt> @where joy
20:11:44 <lambdabot> I know nothing about joy.
20:11:50 <aavogt> @where anger
20:11:51 <lambdabot> I know nothing about anger.
20:12:11 <augur> lambdabot will destroy us all
20:12:17 <augur> with cold hard logic
20:12:18 <augur> 8|
20:12:54 <Jafet> She's probably too lazy to do that.
20:13:13 <augur> @where laziness
20:13:14 <lambdabot> I know nothing about laziness.
20:13:16 <augur> THERE YOU SEE?!
20:13:21 <augur> WE'RE DOOMED
20:13:55 <cheater99> hi
20:14:02 <cheater99> i have a big problem with ghci under ubuntu
20:14:10 <cheater99> it uses editline
20:14:27 <cheater99> is it normal for all versions of ghci, or is just the ubuntu one broken?
20:14:50 <Jafet> ghc 6.12 uses haskeline or readline, I forget
20:14:53 <cheater99> i cannot work without readline
20:14:58 <Jafet> Anyway, it's just better than editline
20:15:22 <cheater99> the ubuntu one is 6.10
20:15:35 <keseldude> which is when ghci started using editline
20:16:19 <pastorn> cheater99: are you using 6.10.4?
20:16:22 <cheater99> keseldude: did it stop at some point?
20:16:25 <pastorn> or is your version earlier?
20:16:27 <keseldude> idk
20:16:34 <cheater99> pastorn: yes
20:16:39 <cheater99> pastorn: that version
20:16:47 <pastorn> http://haskell.org/ghc/docs/6.10.4/html/users_guide/release-6-10-4.html
20:17:04 <pastorn> 2nd from the bottom
20:17:20 <cheater99> i see it
20:17:23 <cheater99> it doesn't tell me anything
20:17:28 <nniro> is it me or existential quantification are really a pain in the rear end?
20:17:33 <cheater99> what does that mean pastorn?
20:17:49 <cheater99> should haskeline understand ctrl+arrows?
20:17:53 <cheater99> and home/end?
20:18:09 <pastorn> cheater99: it does for me
20:18:16 <keseldude> cheater99: this might be for you http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/ghci-invocation.html
20:18:19 <pastorn> but then i always install ghc from the linux binary blob
20:18:19 <cheater99> it doesn't here
20:18:30 <keseldude> I don't know how readline works, so this might be something totally different
20:18:34 <Jafet> nniro, did you import lube?
20:19:01 <nniro> Jafet: no, I haven't
20:19:02 <cheater99> keseldude: readline is the typical input/buffer functionality that e.g. bash and most terminals have usually
20:19:36 <cheater99> keseldude: that link was unrelated - we're talking about ghci itself, not about loading packages
20:19:46 <Jafet> If you want readline, you can just build ghc with readline
20:19:57 <cheater99> pastorn: any idea what might make ghci think it is not run in a terminal?
20:20:01 <Jafet> It's been a build option since... a while ago
20:20:14 <cheater99> Jafet: i'd rather try actually make it work without
20:20:23 <handonson> "The parser p <|> q first applies p. If it succeeds, the value of p is returned. If p fails WITHOUT consuming any input, parser q is tried." I want a combinator in which p fails WITH consuming some input, q still will be tried.
20:20:25 <pastorn> cheater99: none
20:20:41 <handonson> Is there a combinator for this?
20:20:52 <cheater99> i don't want to go through the trouble of compiling ghc. i've never had to do that and i would rather skip it.
20:20:54 <pastorn> handonson: mplus
20:20:58 <pastorn> i think
20:21:21 <keseldude> http://hackage.haskell.org/trac/ghc/ticket/2606 what a shitty workaround
20:21:32 <handonson> pastorn, I thought "instance MonadPlus (GenParser tok st) where mzero = fail "mzero"; mplus = (<|>)"
20:22:52 <cheater99> keseldude: that looks related, thanks
20:23:30 <edwardk> handonson: try p <|> q
20:23:55 <handonson> edwardk, No. I want p to actually CONSUME something and fail, then try q.
20:24:13 <edwardk> oh, so only if something gets consumed?
20:24:21 <handonson> so when q is tried the input could be already consumed a little.
20:24:26 <edwardk> AHHH
20:24:44 <pickles> > let say x y = x ++ " " ++ y
20:24:45 <lambdabot>   not an expression: `let say x y = x ++ " " ++ y'
20:25:01 <pickles> > let a = 5
20:25:02 <lambdabot>   not an expression: `let a = 5'
20:25:05 <soupdragon> @let a = 5
20:25:06 <lambdabot>  Defined.
20:25:09 <pickles> ah, thx
20:25:30 <pickles> @let say x y = x ++ " " ++ y
20:25:31 <lambdabot>  Defined.
20:25:41 <pickles> @let goodnight = "goodnight"
20:25:42 <lambdabot>  Defined.
20:25:53 <pickles> @let gracy = "gracy"
20:25:54 <lambdabot>  Defined.
20:26:02 <pickles> > say goodnight gracy
20:26:03 <lambdabot>   "goodnight gracy"
20:26:06 <pickles> night all
20:26:15 <keseldude> :\
20:26:17 <handonson> ...
20:26:28 <pastorn> handonson: you might want 'optional'
20:27:01 <Jafet> It's actually not that hard to compile ghc if you already have ghc...
20:27:20 <keseldude> yeah, I always compile ghc on ubuntu
20:27:43 <keseldude> mostly because I like compiling things with ghc
20:28:46 <poseidon> Any suggestions on a good book/resource for learning haskell?
20:29:06 <edwardk> handonson you can put one together by hand if you have to with runParsecT, etc.
20:29:14 <pastorn> poseidon: do you already know any programming languages? and if so, which?
20:29:41 <edwardk> poseidon: real world haskell, and 'learn you a haskell for great good' both are available online or in dead tree form
20:30:08 <edwardk> the former is a good 'industrial' introduction, the latter has a bit more fun with it, but doesn't get as deep
20:30:18 <edwardk> well
20:30:27 <edwardk> actually LYAH isn't yet available in print form
20:30:32 <edwardk> but it will be soon
20:31:22 <keseldude> I still like YAHT
20:31:39 <keseldude> yet another haskell tutorial
20:31:41 <FunctorSalad> experimentation and #haskell
20:31:42 <FunctorSalad> ;)
20:32:22 <FunctorSalad> (after you have the very basics covered so experimenting is possible)
20:38:54 <poseidon> pastorn: Java
20:39:29 <pastorn> poseidon: how long have you been using java? :)
20:40:00 <poseidon> About a 1.5 years
20:41:18 <pastorn> handonson: ok
20:41:29 <pastorn> so you can do this with getPosition and setPosition
20:41:39 <pastorn> if you catch your error properly :)
20:41:41 <poseidon> I also know c++ (not as good).  I mainly know java because it was what I learned in my CS class
20:42:10 <pastorn> poseidon: and what do you want to write in haskell?
20:42:16 <pastorn> anything special?
20:42:55 <handonson> pastorn, edwardk: thanks a lot for your help. well, i've just completely restructured the parser and worked around the problem with the combinators i know.
20:43:06 <pastorn> hehe
20:43:41 <Cale_> poseidon: In addition to the other resources mentioned, I also highly recommend asking questions here whenever you get stuck. :)
20:48:36 <cheater99> keseldude: i'd read that ticket to the end, there's no real fix there
20:49:36 <cheater99> who's bright idea was it to use editline anyways?
20:49:40 <keseldude> I think it was getting at how to live with editline, making it do things that readline does out of the box
20:49:43 <cheater99> it's the worst thing ever
20:50:24 <cheater99> it's just loss of time
20:50:56 <cheater99> dons: please make editline die magically
20:51:06 <cheater99> thanks
20:51:29 <Jafet> Magic sold separately.
20:51:41 <luite> anyone have an idea how to generate (without duplicates) all undirected rooted graphs, where every node is at most distance two from the root, and all nodes have at most the degree of the root
20:52:04 <luite> for a root with a certain fixed degree d
20:52:46 <luite> oh, unlabeled, I should add
20:53:03 <luite> and connected
20:53:14 <luite> but that is implied by the distance two criterion
20:53:51 <keseldude> do you have an idea?
20:54:41 <Jafet> Generate a maximal graph, prune and unduplicate?
20:55:03 <luite> Jafet: the problem is that that's rather inefficient
20:55:38 <Jafet> Ah, you're enumerating trees. So just read Knuth vol 4.3.
20:55:45 <luite> no it's not trees
20:56:05 <luite> it's graphs with a certain max degree and one distinct node
20:56:12 <Jafet> Perhaps it could be reduced to enumerating trees...
20:56:31 <luite> but perhaps.. yes, thanks, I'll think about it
20:57:23 <luite> I don't think it's possible to store them all in memory for higher degrees, so ideally, I'd like to be able to lazily generate them
20:59:40 <luite> keseldude: i started with nodes at distance 1 from the root, and edges between those, but it quickly gets hairy when trying to avoid duplicates
21:00:23 <handonson> Is it possible in GHCi to inspect types of functions defined in "where" or "let" clauses, therefore not in the global scope?
21:00:54 <FunctorSalad> handonson: sadly not
21:01:10 <handonson> Oh.
21:01:28 <handonson> i assume this feature has already been proposed ... ?
21:01:36 <FunctorSalad> 'scion' can do it
21:01:48 <FunctorSalad> (but not sure if it currently works)
21:02:06 <tolkad> Is there anyway to import something, but make it so you still have to Access.It.Like.This?
21:02:17 <FunctorSalad> tolkad: import qualified
21:02:26 <FunctorSalad> can be combined with 'as' too
21:02:54 <FunctorSalad> import qualified Haskell as Haskle
21:02:54 <tolkad> oh, found it, thanks
21:04:20 <handonson> tolkad: see haskell.org/haskellwiki/Import for more detail.
21:04:28 <AnAdorableNick> "import Module as M" is valid as well.
21:04:32 <handonson> i mean, http://haskell.org/haskellwiki/Import
21:05:55 <tolkad> so... as I was saying before... let's say I have:
21:05:56 <tolkad> f :: Int -> Maybe Int
21:05:56 <tolkad> f 42 = Just 9
21:05:56 <tolkad> f 29 = Just 38
21:05:56 <tolkad> f x = Nothing
21:05:56 <tolkad> Now I can't define anymore cases for f... How can I do this differently so I can still define more after the default case?
21:06:08 <soupdragon> what
21:06:18 <soupdragon> you mean like object oriented programming
21:06:20 <soupdragon> ?
21:06:31 <tolkad> Well... I thought it goes through the definitions in order
21:06:42 <soupdragon> you're right
21:06:49 <tolkad> since f x = Nothing is a catch-all, no subsequent functions will be used
21:07:01 <soupdragon> yes
21:07:31 <FunctorSalad> you put the extra cases *above* the default ;)
21:07:47 <FunctorSalad> maybe you're looking for guards?
21:08:10 * BMeph coughs...but it almost sounds like "Data.Map!" -- huh?
21:08:11 <tolkad> FunctorSalad: I wasn't sure if that was bad practice, to make a function unextendable like that
21:08:18 <FunctorSalad> f x | cat x == "monday cat" = Just 3
21:08:28 <Jafet> f 69 = Just 6; f x = Original.f x
21:08:41 <FunctorSalad> f x | (cat x == "monday cat") = Just 3 -- to make precedence clear
21:09:31 <FunctorSalad> tolkad: case analysis is supposed to be "closed world", not open-ended extensible
21:09:47 <tolkad> Jafet: oh! that makes sense I guess
21:10:02 <Jafet> I do? Damn
21:10:03 <FunctorSalad> without the catch-all, your function will simply throw an error in that case
21:10:16 <tolkad> and those re bad?
21:10:19 <tolkad> are*
21:10:33 <BMeph> tolkad: Another option is to use a Data.Map/IntMap with the "lookup" function.
21:11:12 <FunctorSalad> for something more extensible, you might want to have something like an explicit "Matcher" datatype
21:11:16 <FunctorSalad> (random idea)
21:11:20 <Cale_> tolkad: Yeah, errors thrown by pure code are rather bad.
21:11:22 <tolkad> BMeph: but... then I can't make the inverse. I couldn't find an inverse lookup, that searches the second element and returns the first
21:11:38 <FunctorSalad> data Matcher a r = Matcher (a -> Bool) (a -> r) or so
21:11:53 <Cale_> tolkad: It's theoretically possible to catch them from IO, but it's not something you want to try to do as a design policy
21:12:02 <FunctorSalad> (with the second item corresponding to the right-hand side of the case analysis)
21:12:55 <tolkad> Cale_: Speaking of that, I had that happened and was very surprised to see a detailed error message including the file name. Do haskell programs contain all sorts of metadata about the system they are compiled on?
21:13:07 <FunctorSalad> (I'm probably overlooking some existing better abstraction)
21:13:20 <FunctorSalad> for extensible case analysis
21:13:34 <Cale_> tolkad: I think the compiler just generates the fallthrough case at that point in the code as it's compiling.
21:13:49 <Cale_> (and bakes in a string)
21:14:01 <tolkad> Cale_: oh, sounds much more sane
21:14:05 <Jafet> tolkad: if cases do not cover all values, the compiler generates a default
21:14:47 <adu> hi Cale_
21:14:50 <FunctorSalad> tolkad: haskell things have virtually no metadata at all (at runtime) by default
21:14:54 <Cale_> Often you get a much less helpful error message than you'd want, too, if you're using lots of partial functions. head and tail are particularly nasty things to watch out for :)
21:15:04 <Cale_> Hi adu 
21:15:16 <FunctorSalad> (for example, the only thing you can do with a function is apply it to an arg, there's no way to introspect it)
21:15:20 <FunctorSalad> (this is by design)
21:16:08 <FunctorSalad> another example, you can't reflect about the type of an arbitrary value; you have to request that capability through the class Data.Typeable.Typeable
21:18:26 <FunctorSalad> you can get your hands on the source file with template haskell though :)
21:19:38 <BMeph> tolkad: "M.fromList . map swap . M.toList" is ridiculously awkward...but it should do what you want.
21:20:12 <Eduard_Munteanu> @hoogle Typeable
21:20:12 <lambdabot> module Data.Typeable
21:20:12 <lambdabot> Data.Typeable class Typeable a
21:20:13 <lambdabot> Data.Typeable class Typeable1 t
21:20:50 <FunctorSalad> self = $( litE . stringE . loc_filename <$> location )
21:20:53 <FunctorSalad> or something like that :)
21:21:24 <Eduard_Munteanu> I wonder if that's of any use for simulating dependent types.
21:21:51 <FunctorSalad> TH?
21:21:52 <FunctorSalad> or Typeable
21:22:08 <Jafet> Haskell has dependent types!
21:22:27 <tolkad> BMeph: will it be faster at runtime to just write the functions for converting each way?
21:22:34 <Jafet> (Well, dependent naturals...)
21:22:36 <Eduard_Munteanu> Jafet: um?
21:22:40 <Eduard_Munteanu> Where?
21:22:45 <FunctorSalad> (if you want to duplicate everything on the typelevel? :|)
21:22:55 <tolkad> FunctorSalad: that's a bad idea?
21:23:02 <FunctorSalad> (the type level isn't such a great programming language ;))
21:23:19 <Eduard_Munteanu> Nah... Typeable doesn't take polymorphic types.
21:23:28 <FunctorSalad> s/stringE/stringL/
21:23:38 <Eduard_Munteanu> FunctorSalad: well, one can only try
21:26:32 <handonson> Is there a function with which I can easily URL-encode a String (or a ByteString) ?
21:26:52 <c_wraith> handonson, if you're in snap, there is
21:27:00 <Cale_> handonson: yes, one moment
21:27:06 <Jafet> Heh
21:28:15 <FunctorSalad> replace space with %20, blame other special characters on the user o_O
21:28:17 <Cale_> Network.URI.escapeURIString isAllowedInURI
21:28:21 <tolkad> actually, is there a built-in function to convert [(a, b), (c, d), ...] to [(b, a), (d, c), ...]?
21:28:39 <FunctorSalad> (I'd never do that outside a personal shell script of course ;))
21:28:42 <Cale_> tolkad: no, but it's just map (\(x,y) -> (y,x))
21:29:27 <tolkad> Cale_: oh, so there is, thanks
21:30:02 <Veinor> @djinn [(a,b)] -> [(b,a)]
21:30:03 <lambdabot> Error: Undefined type []
21:30:05 <Veinor> >:(
21:30:15 <Cale_> djinn has no knowledge of recursion
21:30:15 <gwern> Cale_: oh noes, but that's not a right escape!
21:30:26 <Cale_> gwern: what?
21:30:34 <gwern> Cale_: there's an old threat on -libraries where I suggest adding that, iirc, and get told it' not right
21:30:39 <Eduard_Munteanu> \( - escape? :P
21:30:41 <gwern> *adding that to Network.Uri
21:30:53 <Cale_> gwern: why?
21:31:01 <gwern> Cale_: heck if I remember
21:31:15 <Cale_> Well, that's odd. I've used it with success.
21:32:44 <FunctorSalad> foldWithKey (\k v m -> insert v k m) empty
21:32:47 <gwern> Cale_: well, that's the thing about insecure code
21:32:51 <gwern> it works until it doesn't
21:32:55 <FunctorSalad> pointless it if you have to ;)
21:33:03 <FunctorSalad> @pl foldWithKey (\k v m -> insert v k m) empty
21:33:03 <lambdabot> foldWithKey (flip insert) empty
21:33:09 <FunctorSalad> ah, not so bad
21:33:16 <FunctorSalad> @t foldWithKey
21:33:16 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:33:19 <FunctorSalad> @ty foldWithKey
21:33:20 <lambdabot> Not in scope: `foldWithKey'
21:33:23 <FunctorSalad> @ty M.foldWithKey
21:33:24 <lambdabot> forall k a b. (k -> a -> b -> b) -> b -> M.Map k a -> b
21:33:34 <Cale_> gwern: I think that if it's a problem, it's either because of a bug in escapeURIString or a bug in isAllowedInURI
21:33:57 <FunctorSalad> @let inverse = foldWithKey (flip (insertWith "not injective, lol"))
21:33:58 <lambdabot>  <local>:9:10: Not in scope: `foldWithKey'
21:33:58 <lambdabot>  
21:33:58 <lambdabot>  <local>:9:29: Not in scope: `in...
21:34:02 <FunctorSalad> @let inverse = M.foldWithKey (flip (insertWith "not injective, lol"))
21:34:02 <lambdabot>  <local>:9:31: Not in scope: `insertWith'
21:34:06 <FunctorSalad> @let inverse = M.foldWithKey (flip (M.insertWith "not injective, lol"))
21:34:07 <lambdabot>  <local>:9:44:
21:34:07 <lambdabot>      Couldn't match expected type `k -> k -> k'
21:34:07 <lambdabot>             ag...
21:34:11 <FunctorSalad> sorry
21:34:21 <FunctorSalad> @ty M.insertWith
21:34:22 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
21:34:35 <tolkad> How do you keep track of all your haskell files you want to link?
21:34:38 <BMeph> tolkad: Just FYI, but most folks refer to "\(x,y) -> (y,x)" as "swap". 
21:34:39 <FunctorSalad> @let inverse = M.foldWithKey (flip (M.insertWith (\_ _ -> error "not injective, lol")))
21:34:40 <lambdabot>  Defined.
21:34:43 <FunctorSalad> yay!
21:34:57 <tolkad> I mean, do you retype them every time you compile?
21:35:15 <Jafet> tolkad, ghc --make
21:35:18 <FunctorSalad> > inverse (M.fromList [(x,x^2) | x <- [3..5] ])
21:35:19 <lambdabot>   Overlapping instances for GHC.Show.Show
21:35:19 <lambdabot>                              (Data....
21:35:28 <gwern> Cale_: iirc, it's just that there are many sets of escapes and some are appropriate in some splaces but not others
21:35:34 <gwern> Cale_: but you could look up the thread
21:35:37 <FunctorSalad> > inverse (M.fromList [(x,x^2) | x <- [3::Int .. 5] ])
21:35:38 <lambdabot>   Overlapping instances for GHC.Show.Show
21:35:38 <lambdabot>                              (Data....
21:35:54 <handonson> Cale_, oh thanks a lot.
21:35:57 <FunctorSalad> @unlet inverse
21:35:57 <lambdabot>   Parse error: SemiColon
21:35:58 <handonson> I just love IRC. (:
21:36:00 <FunctorSalad> @unlet 
21:36:01 <lambdabot>  Defined.
21:36:16 <FunctorSalad> I forgot the 'empty' with inverse :|
21:36:26 <FunctorSalad> @let inverse = M.foldWithKey (flip (M.insertWith (\_ _ -> error "not injective, lol"))) M.empty
21:36:26 <lambdabot>  <local>:11:0:
21:36:26 <lambdabot>      Multiple declarations of `L.inverse'
21:36:26 <lambdabot>      Declared at: <l...
21:36:36 <FunctorSalad> ok I'll stop spamming
21:36:57 <BMeph> FS: Doesn't your 'inverse' function need an M.empty as the thirs argument to the fold?
21:37:00 <gwern> Gracenotes: oh, did you ever see my suggestion for cabal to grab changelogs from a vcs?
21:37:04 <BMeph> *third
21:37:11 <gwern> Gracenotes: I never really bought the argument that the vcs changelog is too fine-grained
21:37:15 <FunctorSalad> BMeph: exactly, but I fail at undefining
21:37:22 <gwern> Gracenotes: very much a 'perfect is the enemy of the best'
21:37:25 <blackdog> gwern: if you're rebasing constantly, it's probably ok
21:37:42 <gwern> blackdog: well, even a finely grained history is better than no changelog, I'd think
21:37:47 <Gracenotes> gwern: the only purpose of changelogs in this context is to provide a concise summary of the things that changed
21:37:59 <Gracenotes> though something is better than nothing
21:38:00 <gwern> it's more concise than a giant diff
21:38:08 <Gracenotes> that is true
21:38:12 <tolkad> Why does this say "Done" but it's not in Data.Tuple? http://hackage.haskell.org/trac/ghc/ticket/3298
21:39:23 <gwern> tolkad: maybe the next release hasn't happened yet
21:39:35 <Gracenotes> otherwise, I guess diffing isn't a bad approach, but it requires introspection of packages
21:39:45 <technogeeky> the next... release... isn't done... yet... mind blown
21:39:59 <gwern> technogeeky: I thought someone here would appreciate my phrasing :)
21:40:16 <technogeeky> ;)
21:40:33 <Gracenotes> "The bug is fixed" "But it isn't fixed for me!"
21:40:57 <technogeeky> Gracenotes: in that person's defense, they *are* the only person who matters.
21:41:40 <gwern> 'simoncat sez: is fixed in teh HEAD'
21:41:49 <gwern> if lambdacats wasn't gone, I could link that one
21:42:04 <Gracenotes> this is true. tolkad, this being FP, feel free to define your own, heck, copy the whole standard list library into your module
21:42:45 <Gracenotes> RIP lambdacats
21:43:04 <technogeeky> Gracenotes: when I was discussing Haskell with my friend, he mentioned something he didn't like in Haskell, to which I responded: then don't use the prelude!
21:43:11 <technogeeky> That idea blew his mind
21:43:16 <FunctorSalad> @commands
21:43:16 <lambdabot> Unknown command, try @list
21:43:32 <FunctorSalad> @list
21:43:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:44:26 <FunctorSalad> @where+ unlet undefine
21:44:26 <lambdabot> It is stored.
21:44:30 <FunctorSalad> @where unlet
21:44:30 <lambdabot> undefine
21:44:42 <FunctorSalad> (wasn't the first time @unlet fooled me)
21:44:47 <FunctorSalad> @undefine inverse
21:44:58 <FunctorSalad> @let inverse = M.foldWithKey (flip (M.insertWith (\_ _ -> error "not injective, lol"))) M.empty
21:44:59 <lambdabot>  Defined.
21:45:11 <FunctorSalad> at last =)
21:45:41 <FunctorSalad> @freshname
21:45:41 <lambdabot> Hacy
21:45:43 <FunctorSalad> @freshname
21:45:43 <lambdabot> Hacz
21:46:02 <FunctorSalad> I doubt this started at 'aaaa' ;)
21:46:12 <Eduard_Munteanu> Haaa!
21:46:14 <technogeeky> ha is probalby haskell
21:46:18 <technogeeky> cz
21:46:23 <catenate> @list is awesome because it's a level of indirection into a set of commands that I wouldn't need to use @list if I knew.
21:46:24 <lambdabot> No module "is awesome because it's a level of indirection into a set of commands that I wouldn't need to use @list if I knew." loaded
21:46:31 <Veinor> haha.
21:46:36 <Jafet> @freshname
21:46:36 <lambdabot> Hada
21:46:49 <Jafet> I doubt it didn't
21:46:56 <technogeeky> ok
21:47:02 <technogeeky> i think I need to pause the chatroom
21:47:11 <technogeeky> so i can figure out what happened. You guys all just.. sit tight for a second.
21:47:32 <technogeeky> oh nevermind.
21:47:36 * technogeeky presses play
21:52:28 <Zeiris> Is there an instance of Monad for Either?
21:56:30 <Veinor> wow, huh.
21:56:42 <Veinor> just earlier today I thought 'when would I ever need rank 2 types'
21:56:49 <Veinor> and yet here I am writing something that requires them
21:57:08 <dolio> But when will you understand rank-3 types?
21:57:14 <Veinor> I dunno :D
21:57:27 <technogeeky> are you sure it's not one of those steering your motorcycle directly in to a tree moments?
21:57:38 <Veinor> but I want a type where one of the... whatever you call them can be any Num
21:58:07 <Veinor> fields?
21:58:25 <Veinor> which requires a (forall a. (Num a) => a) -> Game
21:59:16 <technogeeky> not a field?
21:59:18 <technogeeky> Field, that is
21:59:26 <Veinor> hm?
21:59:30 <dolio> You mean a field?
21:59:32 <Veinor> yes.
21:59:35 <Veinor> that is what I mean.
21:59:37 <technogeeky> j,
21:59:53 <Eduard_Munteanu> Rather 'term'.
22:00:04 <Eduard_Munteanu> Supposing it goes into a function signature.
22:00:06 <technogeeky> are you discussing mathematical fields?
22:00:14 <Veinor> no, not mathematical fields
22:00:15 <Eduard_Munteanu> Heh, no.
22:00:17 <technogeeky> ok
22:00:18 <technogeeky> :(
22:00:22 * technogeeky sits down
22:00:35 <Veinor> well, i think games form a field
22:00:40 <technogeeky> " but I want a type where one of the... whatever you call them can be any Num"
22:00:42 <technogeeky> what did you mean by this?
22:00:59 <Veinor> type Foo = Int Int String
22:01:04 <Veinor> what do you call the thing you have three of?
22:01:11 <Veinor> er, Foo Int Int String :P
22:01:28 <technogeeky> I don't know. term? element?
22:01:37 <BMeph> Legs! Ooops, did I say that out loud? ;
22:01:38 <Eduard_Munteanu> Ah, I'd call that a field too.
22:02:00 <Veinor> yeah.
22:02:08 <technogeeky> hm. more?
22:02:20 <Veinor> anyway. I'm trying to decide whether having them just be (Num a) is a good idea or whether I want to force Floats
22:03:10 <Eduard_Munteanu> Veinor: if a Float or Double makes more sense just go with it, no need to hang on to polymorphism.
22:03:15 <Veinor> true.
22:03:40 <Veinor> a general game can have arbitrary cold real part, so
22:04:09 <Jafet> Num's methods describe a ring
22:04:21 <Jafet> Fractional's describe a field.
22:04:33 <djahandarie> Let's rename them all to make things even more confusing
22:04:35 <Veinor> also true.
22:04:39 <dolio> A ring with some extra junk, really.
22:05:19 <Zeiris> How do I switch between multiple open packages in Leksah?
22:05:40 <Jafet> And RandomGen's methods describe a rng.
22:07:19 <Veinor> a ring with no identity? :P
22:09:05 <technogeeky> my we have some cheeky lads tonight
22:16:31 <gwern> @wn eleemosynary
22:16:33 <lambdabot> *** "eleemosynary" wn "WordNet (r) 2.0"
22:16:33 <lambdabot> eleemosynary
22:16:33 <lambdabot>      adj : generous in assistance to the poor; "a benevolent
22:16:33 <lambdabot>            contributor"; "eleemosynary relief"; "philanthropic
22:16:33 <lambdabot>            contributions" [syn: {beneficent}, {benevolent}, {philanthropic}]
23:07:36 <FunctorSalad> Veinor: "cold"? never got into the details of games (assuming you're still on to surreal numbers)
23:08:01 <FunctorSalad> gwern: how does that split?
23:08:11 <FunctorSalad> etymologically
23:08:36 <gwern> at a guess, I'd split it as eleem-o-syn-ary
23:08:57 <FunctorSalad> 1620, from M.L. eleemosynarius "pertaining to alms," from L.L. eleemosyna "alms," from Gk. eleemosyne "pity" (see alms).
23:09:05 <wli> ele-emo-syn-ary?
23:09:12 <FunctorSalad> doesn't quite resolve it
23:09:13 <gwern> wli: no no, that's just silly
23:09:20 <FunctorSalad> I considered that too
23:09:35 <gwern> b) eleemosyne: charity, alms [ελεημοσύνη] c) eleos: pity, mercy, compassion [έλεος] eleemosyne (ελεημοσύνη) --> eleemosyna --> alemosyna
23:10:19 <FunctorSalad> from Gk. eleemosyne "pity, mercy," in Ecclesiastical Gk. "charity, alms," from eleemon "compassionate," from eleos "pity, mercy," of unknown origin, perhaps imitative of cries for alms.
23:10:45 <FunctorSalad> ok, didn't know the stem "eleemon" :)
23:15:20 <FunctorSalad> hmm cabal isn't quite the right tool for a directoryfull of haskell command-line utilities, is it?
23:15:58 <FunctorSalad> (if you want to have robustness against some of them not building)
23:19:35 <Saizan> in which respect?
23:20:32 <Saizan> (i'm not sure that's the right word there..)
23:27:33 <gwern> FunctorSalad: I don't think cabal should make it easy for you to deliberately keep broken stuff broken :)
23:30:11 <FunctorSalad> Saizan: in that it should build as many executables as possible
23:30:36 <FunctorSalad> I tried guarding every executable with a flag, let's see if this works ;)
23:30:55 <gwern> FunctorSalad: what if the executables depend on each other at runtime?
23:31:39 * ManateeLazyCat Advert : http://farm5.static.flickr.com/4134/4762834054_6fd804f32e_b.jpg
23:31:54 <FunctorSalad> gwern: oh I wasn't suggesting it as a general feature, I know the current nature of my attention leads to questionable coding practices ;)
23:32:15 <gwern> if they are that independent then maybe each ought to be its own dir
23:32:23 <gwern> and keep a shell script to cd into each and cabal install
23:33:06 <FunctorSalad> (work on program, decide you should code some auxilliary thing first, repeat, have lots of half-finished source files ;))
23:33:17 <Saizan> FunctorSalad: with flags you'd have to explicitly turn the broken ones off
23:33:41 <FunctorSalad> Saizan: thought it searches for a working subset?
23:33:54 <FunctorSalad> though the naive algo wouldn't exactly be recommendable
23:33:55 <FunctorSalad> ;)
23:34:59 <FunctorSalad> gwern: yeah, that would have been better
23:35:16 <FunctorSalad> or I could just make my own "build system" that invokes ghc --make on each .hs file ;)
23:35:24 <FunctorSalad> (kiss)
23:37:49 <Saizan> flags get commited to some values based on platform, arch and packages available, during configure
23:37:54 <Saizan> building comes later :)
23:41:14 <aasmith_> @src (!!)
23:41:14 <lambdabot> xs     !! n | n < 0 = undefined
23:41:15 <lambdabot> []     !! _         = undefined
23:41:15 <lambdabot> (x:_)  !! 0         = x
23:41:15 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:44:25 <Twey> cheater99: Read RWH
23:48:08 <pok_> pl 1
23:49:30 <pok_> @pl 1
23:49:30 <lambdabot> 1
23:49:42 <pok_> @pl "asd"
23:49:42 <lambdabot> "asd"
23:49:54 <pok_> @pl (\x -> x + 1)
23:49:54 <lambdabot> (1 +)
23:50:03 <dancor> configuring is a huge waste of time
23:50:14 <pok_> @pl (\x y -> sortBy (flip compare) (fst x) (fst y))
23:50:14 <lambdabot> (. fst) . sortBy (flip compare) . fst
23:50:33 <dancor> it's very important for every package to check anew hundreds of things that never change on my system
23:50:55 <gwern> how can it know?
23:51:04 <dancor> cachign
23:51:05 <dancor> caching
23:51:11 <dancor> isn't it obvious?
23:51:26 <Saizan> then you'd have to validate the cache..
23:51:28 <Veinor> then you have to tell the stuff that can change to update the cache
23:51:31 <Twey> Hm
23:51:32 <Veinor> or mark it as invalid
23:51:41 <dancor> right you would have to interact with the package manager
23:51:56 <dancor> which is too hard for *nixers apparently
23:52:00 <Twey> @pl (\x -> x &$!^ 1)
23:52:00 <lambdabot> (&$!^ 1)
23:52:05 <Twey> Ah, better
23:52:18 <Saizan> it's already quite bad that there's no check for things that get cached into dist/setup-config
23:52:34 <Veinor> dancor: I know, everybody installs things through the package manager
23:52:41 <FunctorSalad> dancor: as in ./configure ing?
23:52:45 <dancor> FunctorSalad: yes
23:52:58 <FunctorSalad> doesn't take long enough to be worth doing something about it as far as I'm concerned :)
23:53:13 <dancor> FunctorSalad: that's the real reason
23:53:15 <FunctorSalad> you don't really have to watch, too ;)
23:53:19 <dancor> it's not that brief tho..
23:53:26 <FunctorSalad> ./configure && make?
23:53:33 <dancor> i think it could matter enough at some point
23:53:37 <Saizan> ./configure in general is quite wasteful because it checks lots of irrelevant things, "cabal configure" also checks irrelevant things but it takes less time ime :)
23:54:00 <dancor> maybe that's the bigger problem, the irrelevant things
23:54:15 <dancor> m4 just seems like a disaster to me
23:54:27 <edwardk> you know you spend too much time playing with theory when half way through writing a lexer you find yourself writing a Bifunctor class
23:55:00 <Saizan> i think the problem there is that noone wants to deal with autoconf much and just copies scripts from somewhere else?
23:55:07 <dancor> ya
23:55:33 <edwardk> Saizan: sadly, even if you write your autoconf scripts from scratch the boilerplate of autoconf causes it to check everything
23:56:01 <edwardk> i've written some 'lean and mean' autoconf over the years, it takes about the same amount of time ;)
23:56:30 <qwebirc39036> @pl (\(a,b) (c,d) -> sortBy (flip compare) a c)
23:56:30 <lambdabot> (`ap` snd) . (. fst) . (const .) . sortBy (flip compare) . fst
23:56:52 <Saizan> edwardk: heh, ok then :)
23:56:57 <dancor> is (sortBy (flip compare)) better than (reverse . sort)
23:57:09 <qwebirc39036> @pl (\e f -> sortBy (flip compare) (fst e) (fst f))
23:57:10 <lambdabot> (. fst) . sortBy (flip compare) . fst
23:57:18 <Saizan> dancor: yeah, lazier
23:57:27 <dancor> mm
23:57:35 <qwebirc39036> Just seems more efficient.
23:57:51 <Saizan> you don't have to have sorted the whole list before you can access the first element
23:58:29 <qwebirc39036> This @pl thing is great, but the answers are rather curious sometimes.
23:58:59 <dancor> i would just do: sortBy (flip compare) `on` fst
23:58:59 <Saizan> yeah, @pl is not optimized for clarity :)
23:59:02 <BMeph> :t sortBy (flip compare) `on` fst
23:59:03 <lambdabot>     Couldn't match expected type `[a] -> c' against inferred type `[a]'
23:59:04 <lambdabot>     In the first argument of `on', namely `sortBy (flip compare)'
23:59:04 <lambdabot>     In the expression: sortBy (flip compare) `on` fst
23:59:48 <BMeph> :t sortBy (flip compare `on` fst)
23:59:48 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
