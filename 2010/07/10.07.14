00:00:31 <Veinor> oh, sorry
00:01:07 <earthy> (or at least warn explicitly...)
00:01:20 <Jafet> :t (.)(.)
00:01:21 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
00:01:22 <RyanT5000> Zao: you may wish to refrain from clicking any links that include the term "4chan" if you expect them to be SFW :)
00:01:49 * earthy grins
00:02:18 <Veinor> this is also true.
00:02:33 <Veinor> :t fmap fmap
00:02:34 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
00:02:36 <Zao> I tend to expect a degree of professionalism from #haskell, for some reason.
00:02:53 <Zao> <cue spanish inquisition quote>
00:02:56 <RyanT5000> it does usually deliver on that :)
00:03:17 <kniu> lol professionalism.
00:03:22 <Veinor> :t fmap fmap [(+1), (*3)]
00:03:23 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => [f a -> f a]
00:03:58 <kniu> you guys do tend to use 4-letter words with less frequency than other channels.
00:03:59 <Veinor> > zipWith ($) ( fmap fmap [(+1), (*3)] ) ([8,8])
00:04:00 <lambdabot>   No instance for (GHC.Num.Num (f a))
00:04:00 <lambdabot>    arising from a use of `e_11388' at <...
00:04:16 <Veinor> > zipWith ($) ( fmap fmap [(+1), (*3)] ) ([[8,3],[1,7]])
00:04:16 <lambdabot>   [[9,4],[3,21]]
00:04:33 <Veinor> > zipWith ($) ( fmap fmap [(+1), (*3)] ) ([Just 7, Nothing])
00:04:34 <lambdabot>   [Just 8,Nothing]
00:05:10 <Jafet> kniu: say forkIO really fast
00:07:06 <Zao> Jafet: "fork i o". Do people really pronounce IO as "you"?
00:08:36 <p_l> forkAioo ;-)
00:08:56 <p_l> or fork-I-O :)
00:10:36 <kniu> wtf/minute
00:10:43 <kniu> low with haskell
00:11:37 <exDM69> I get lots of those positive wtf moments with haskell? "You can do that?! 0.o cool"
00:12:01 <Jafet> In haskell you start each day with a finite supply of olegs
00:12:14 <Veinor> haha
00:13:05 <RyanT5000> most of the bad WTFs come from code written in haskell, i've found, not from the language itself
00:13:16 <RyanT5000> there's some really weird stuff on Hackage :P
00:13:34 <RyanT5000> even the standard libs have a few skeletons in their closet, though
00:16:10 <Veinor> the entire numeric prelude is just... eurgh
00:32:20 <chrisdone> morning
00:32:51 <soupdragon> hi
00:44:41 * hackagebot blaze-html 0.1.2 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.1.2 (JasperVanDerJeugt)
00:46:01 <chrisdone> jaspervdj: i hope that's increased blazingness updates
00:46:47 <Veinor> - blazingness = 100
00:46:50 <Veinor> + blazingness = 200
00:48:06 <jaspervdj> chrisdone: It's only a quick bugfix on the 0.1 branch unfortunately
00:48:15 <jaspervdj> (the awesome stuff is in the 0.2 branch)
00:50:10 <chrisdone> jaspervdj: i don't see it on github; are you working on the master branch?
00:52:01 <jaspervdj> chrisdone: develop branch for 0.2
00:58:50 <Botje> @pl is_coprime a b = (1 == gcd a b)
00:58:51 <lambdabot> is_coprime = ((1 ==) .) . gcd
00:59:43 <soupdragon> coprime = co . prime
01:02:58 <Botje> hah :)
01:04:57 <AshleyS> How do you check if a element is within a list?
01:05:10 <Botje> elem
01:05:13 <dobblego> @type elem
01:05:15 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
01:06:13 <AshleyS> Thanks
01:11:48 * hackagebot uuagc 0.9.29 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.29 (ArieMiddelkoop)
01:18:36 <McManiaC> what directory does cabal uses to install binaries on windows?
01:19:14 <McManiaC> ah, got it
01:21:10 <drbean> > map (\n -> [0..n]) [0..4]
01:21:11 <lambdabot>   [[0],[0,1],[0,1,2],[0,1,2,3],[0,1,2,3,4]]
01:21:44 <drbean> Why does that seem illegal to me, while [[Int]] seems OK?
01:22:23 <drbean> I must be confusing lists and tuples.
01:22:30 <chrisdone> your question is confusing
01:22:32 <chrisdone> could be
01:23:43 <chrisdone> > permutations $ map permutations ["abc","def"]
01:23:44 <lambdabot>   [[["abc","bac","cba","bca","cab","acb"],["def","edf","fed","efd","fde","dfe...
01:24:17 <chrisdone> does anyone else have this in their .ghci and think it's awesome? :set prompt "λ> "
01:24:51 <Botje> haha, thanks for the idea :_
01:25:08 <drbean> :t permutations
01:25:10 <lambdabot> forall a. [a] -> [[a]]
01:25:16 <exDM69> chrisdone: that's cool
01:25:34 <chrisdone> :t foldl1' (<|>) . map (Text.Parsec.try . Text.Parsec.string)
01:25:38 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => [String] -> Text.Parsec.Prim.ParsecT s u m String
01:25:53 <chrisdone> :t foldl1' (<|>) . map (Text.Parsec.try)
01:25:54 <lambdabot> forall a t s u (m :: * -> *). (Text.Parsec.Prim.Stream s m t) => [Text.Parsec.Prim.ParsecT s u m a] -> Text.Parsec.Prim.ParsecT s u m a
01:25:57 <exDM69> however I'd like to see the modules I've loaded. perhaps "<list of modules>\nλ> "
01:26:15 <chrisdone> :show modules -- shows you the modules loaded
01:26:22 <chrisdone> @hoogle [Text.Parsec.Prim.ParsecT s u m a] -> Text.Parsec.Prim.ParsecT s u m a
01:26:22 <lambdabot> Parse error:
01:26:22 <lambdabot>   --count=20 "[Text.Parsec.Prim.ParsecT s u m a] -> Text.Parsec.Prim.ParsecT s u m a"
01:26:22 <lambdabot>                   ^
01:27:01 <chrisdone> @hoogle (Stream s m Char) => [ParsecT s u m a] -> ParsecT s u m a
01:27:01 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
01:27:01 <lambdabot> Text.ParserCombinators.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
01:27:02 <lambdabot> Text.Parsec.Combinator lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
01:27:09 <chrisdone> premium, good sir
01:27:25 <exDM69> :set prompt "%s\nλ> "  does the trick
01:28:24 <chrisdone> exDM69: nice one
01:28:50 <chrisdone> does lambdabot give me a link to the source code of a function that hoogle shows?
01:28:59 <chrisdone> @src Text.Parsec.Combinator.choice
01:28:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:29:07 <chrisdone> no :-(
01:30:14 <chrisdone> d'oh. is there a backtracking `choice'?
01:31:50 <Botje> choice . map try ?
01:31:51 <Deewiant> choice . map try?
01:32:01 * Botje eyes Deewiant 
01:32:08 <Deewiant> O_o
01:32:12 <chrisdone> yes, is there a defined one for that?
01:32:23 <Deewiant> choice' = choice . map try
01:32:25 <Deewiant> There is now
01:34:41 <chrisdone> the #haskell effect in action, hehe
01:34:50 <kmc> glorious stereo
01:35:09 <chrisdone> "is X defined anywhere?" "*provides definition*" "is it *already* defined?" "it is now!" "..."
01:36:24 <kmc> drbean, did your question get answered?
01:37:43 <kmc> AshleyS, searching large lists is slow; if you need faster membership testing, use something like Data.Set
01:38:24 <chrisdone> kmc, the answering robot!
01:38:40 <chrisdone> insert coin, receive answers and bacon
01:38:47 <drbean> I was surprised that [[],[0,1],[0,1,1],[0],[0,1,1,1]] was legal.
01:39:02 <drbean> I think I must have confused lists and tuples.
01:39:24 <drbean> My understanding of types is impoverished.
01:39:25 <Deewiant> [Int] can have arbitrary length, so [[Int]] can contain lists of different lengths.
01:40:27 <alpounet> how can i get all the possibilities for 5 consecutive elements in a list elegantly ?
01:41:29 <Deewiant> > reverse . drop 5 . reverse . map (take 5) . tails $ "foobarbaz"
01:41:30 <lambdabot>   ["fooba","oobar","obarb","barba","arbaz"]
01:41:50 <Deewiant> The reverse/drop 5 stuff is a bit annoying... have to get rid of the short ones at the end
01:43:58 <kmc> drbean, we're here to deimpoverish you :)
01:45:39 <alpounet> yeah, i don't think we can do much better
01:45:40 <alpounet> thanks
01:49:28 <quicksilver> chrisdone: well, there are these:
01:49:32 <quicksilver> @source Text.ParserCombinators.Parsec.Combinator
01:49:33 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec/Combinator.hs
01:49:35 <quicksilver> @docs Text.ParserCombinators.Parsec.Combinator
01:49:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Combinator.html
01:49:48 <quicksilver> but (a) they seem to be broken (b) Text.Parsec doesn't work.
01:50:11 <chrisdone> maybe i'll update lambdabot tonight
01:50:41 <chrisdone> hoogle/yahoo provide up to date links, i think
01:50:50 <quicksilver> > takeWhile ((==5) . length) . map (take 5) . tails $ "foobarbaz"
01:50:52 <lambdabot>   ["fooba","oobar","obarb","barba","arbaz"]
01:51:07 <quicksilver> Deewiant: you may consider the takeWhile more attractive than the double-reverse trick.
01:51:22 <quicksilver> it should be faster, anyway.
01:51:39 <quicksilver> or maybe not. hmm.
01:52:25 <chrisdone> @let conseq = reverse . drop n . reverse . map (take n) . tails
01:52:25 <lambdabot>  <local>:1:24:
01:52:25 <lambdabot>      Couldn't match expected type `Int' against inferred type ...
01:52:33 <chrisdone> @let conseq n = reverse . drop n . reverse . map (take n) . tails
01:52:34 <lambdabot>  Defined.
01:53:09 <chrisdone> @check \n xs -> conseq n xs == (takeWhile ((==n) . length) . map (take n) . tails $ xs)
01:53:09 <lambdabot>   Not in scope: `conseq'
01:53:17 <chrisdone> ... ~_~
01:53:32 <quicksilver> No access to L.hs for @check.
01:53:40 <chrisdone> evidently
01:55:58 <Botje> > -2.04
01:55:59 <lambdabot>   -2.04
01:56:10 <Botje> ^^ that makes my ghci segfault O_o
01:56:31 <quicksilver> neat.
01:58:54 <Botje> i'm on snow leopard running ghc 6.10.4
01:58:58 <Botje> can anyone reproduce that? 
01:59:16 <kmc> does it happen with 6.12.x?
01:59:17 <chrisdone> when did GHC start calling sections sections?
01:59:29 <chrisdone> The section `== '\n'' takes one argument,
01:59:29 <chrisdone> i swear it used to say "the function ..."
01:59:38 <Botje> i haven;t installed 6.12 yet
02:01:11 <nlogax> GHC 6.12.1 on OS X 10.6.4 is fine, FWIW
02:01:54 <Botje> i'm upgrading my haskell platform now
02:04:13 <chrisdone> @hoogle noneOf
02:04:13 <lambdabot> Text.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
02:04:14 <lambdabot> Text.ParserCombinators.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
02:04:20 <chrisdone> excellent
02:05:23 <chrisdone> did anyone write a commandline interface to hayoo?
02:06:03 <chrisdone> google gives me search results for "yahoo" when i search "hayoo". how annoying
02:06:13 <quicksilver> it is isn't
02:06:22 <quicksilver> google knows what you want better than you do
02:06:27 <quicksilver> (+hayoo should work)
02:06:37 <tibbe> Anyone know what happened to dcoutts_?
02:07:08 <aristid> preflex: seen dcoutts_
02:07:08 <preflex>  dcoutts_ was last seen on #haskell 10 days, 19 hours, 9 minutes and 26 seconds ago, saying: Flags class with to/fromFlags
02:07:12 <aristid> preflex: seen dcoutts
02:07:12 <preflex>  dcoutts was last seen on #haskell 6 days, 16 hours, 42 minutes and 38 seconds ago, saying: * dcoutts is disappearing for a week
02:07:23 <aristid> tibbe: he is disappearing for a week.
02:07:32 <theorbtwo> The Time of Return draws neigh!
02:17:07 <Botje> okay
02:17:15 <chrisdone> @hoogle Applicative f => [f a] -> f a
02:17:16 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
02:17:16 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
02:17:16 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
02:17:24 <Botje> ghc 6.12.1 does it correctly
02:28:37 * ManateeLazyCat I open my flickr now... http://www.flickr.com/photos/48809572@N02/
02:28:59 <kau> Hello all!
02:30:50 <Botje> hi1
02:30:54 <Botje> hi!, even
02:34:56 <Deewiant> quicksilver: The takeWhile has the advantage of laziness, so I guess it's basically better
02:35:33 <quicksilver> Deewiant: but running 'length' on every element of the list is very expensive.
02:35:50 <quicksilver> Deewiant: unless it gets fused with the take, which I doubt.
02:36:01 <aristid> chrisdone: with Alternative i think you can do that like msum, but i'm not sure what the semantics for Applicative would be
02:36:25 <sepp2k> That's what I'm gonna say the next time I compare myself to a coworker: "I have the advantage of laziness, so I guess I'm basically better"
02:36:30 <Deewiant> quicksilver: Yes, that's why I went with the double-reverse instinctively
02:36:36 <quicksilver> @hoogle Alternative d => [f a] -> f a
02:36:37 <lambdabot> Did you mean: [f a] -> f a /count=20
02:36:37 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
02:36:37 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
02:36:45 <quicksilver> @hoogle Alternative f => [f a] -> f a
02:36:46 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
02:36:46 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
02:36:46 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
02:36:55 <Deewiant> It may be best to write a custom takeLen :: Int -> [a] -> ([a],Int) or whatever
02:37:00 <quicksilver> asum, there it is.
02:37:03 <Deewiant> I.e. manually fuse it
02:37:17 <quicksilver> or takeExactlyLen :: Int -> [a] -> Maybe [a]
02:37:26 <quicksilver> (returns Nothing if there aren't n items avaliable)
02:37:30 <Deewiant> Right, that'd be even better for this case.
02:37:48 <quicksilver> catMaybes . takeExactlyLen 5 . tails
02:38:15 <Deewiant> Or to remove a level of indirection, you can have it return [] at that point and then use takeWhile null
02:38:19 <Deewiant> Er, not.null
02:43:16 <gwern> I wonder if spammers can feel hate or want revenge
02:43:33 <gwern> I have no other explanation why, after I cleaned up all the spam yesterday, it came back and dumped in twice as much
02:45:11 <soupdragon> I think spammers and call center people should be tortured to death
02:45:14 <Botje> you just cleared up space in your inbox fo more :P
02:45:23 <gwern> Botje: no, I mean on the wiki
02:45:25 <McManiaC> > let _ / _ = 1 in 0/0
02:45:26 <lambdabot>   1
02:45:27 <McManiaC> \o/
02:45:47 <gwern> Botje: see the last ~1500 entries in http://haskell.org/haskellwiki/Special:Recentchanges
02:46:18 <Botje> wow 
02:51:41 <MoALTz> gwern: add a captcha (for registration)?
02:51:51 <gwern> MoALTz: need a MW upgrade first
02:54:37 <gwern> well, I nailed the spammer's IP address with checkuser, so hopefully the spammer only has that one host...
02:56:50 <emilmeln> Does anybody use MonadLib here?
02:58:53 <emilmeln> I can't figure out how it could be used with generalised newtype deriving.
02:59:42 <chrisdone> gwern: i thought users had to request wiki accounts? or was that just Hackage? i seem to recall at some point it was request based
02:59:59 <gwern> we turned that off a while ago because it was reducing users
03:00:02 <ezyang> Bah. Started off writing about duality and ended up writing amonad tutorial \o/ 
03:00:05 <gwern> and was a lot of work
03:00:15 <chrisdone> ah, ok
03:00:47 <chrisdone> gwern: the sign up should have a haskell quiz :p
03:01:24 <ezyang> “State the comonad laws!” 
03:01:43 <chrisdone> implement a function of this type: Integer -> Bool
03:01:50 <chrisdone> "(==3)"
03:02:02 <gwern> chrisdone: probably
03:02:02 <chrisdone> sends a request to tryhaskell.org/haskell.json and checks the type
03:02:05 <chrisdone> badabingbadaboom
03:02:11 <gwern> chrisdone: you know how to add a quiz? I don't
03:02:15 <kmc> "How do I convert an Integer to a Bool"
03:02:20 <fpletz> first law of comonads: don't talk about comonads!
03:02:42 <chrisdone> gwern: if it's possible to add arbitrary JavaScript, i do. otherwise, no
03:03:12 <dolio> (bool)i, obviously.
03:03:25 <chrisdone> i*1
03:03:38 <Peaker> What are the interesting functions built on comonadic structure? It's one thing to find a bunch of instances of the class, but where's the useful lib generic to all comonads?
03:04:05 <chrisdone> Control.Comonad?
03:04:19 <emilmeln> category-extras
03:04:57 <emilmeln> This package is really insane...
03:04:59 <aristid> category-extras also contains very nice instances and corollary classes... which i have no clue what they are, and how they can be used
03:05:48 <ezyang> Peaker: There has not been a Control.Comonad, as far as I can tell. 
03:05:50 <Peaker> chrisdone, it only has sequenceW, liftW, .>>, local and an Arrow adapter
03:05:57 <ezyang> I want to take a look at that at some point. 
03:06:12 <Peaker> a bit more in http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html
03:06:39 <Peaker> funny use of W
03:06:53 <ezyang> Hmm, that one’s pretty fleshed out. 
03:07:07 <quicksilver> it's an upside-down M
03:07:15 <quicksilver> I think that's a bit too cute, myself.
03:07:42 <Peaker> Yeah, that's why I said it's funny
03:07:49 <dolio> It should be an upside-down T.
03:08:23 <emilmeln> Upside-down O ? :)
03:09:31 <quicksilver> JohnMeacham++ # The "middle end"
03:12:56 <benmachine> quicksilver: there's such a thing as too much cute? :(
03:13:43 <quicksilver> I think it woudl be closer to my opinion to say "there's such a thing as the wrong place for cute"
03:14:02 <benmachine> that's probably true
03:16:30 <quicksilver> jokes in API eventually grate, IMO.
03:16:39 <quicksilver> put the jokes in blog posts, keep the APIs rather straight.
03:17:57 <Taejo> quicksilver: are you talking about spoon?
03:18:24 <quicksilver> no, I was talking about the upside-down M in 'sequenceW'
03:18:32 <quicksilver> spoon is so vile I refuse to discuss it at all.
03:18:35 <gwern> @quote nonsense
03:18:35 <lambdabot> Riastradh says: that's bullcrap, stop speaking nonsense!
03:19:14 <Peaker> quicksilver, it is a joke with a bit of usefulness (easy to remember)
03:19:17 <Taejo> yeah, I was going to say it doesn't matter what spoon is called because good programs don't use it
03:19:28 <Peaker> What is spoon?
03:19:35 <quicksilver> there is no spoon.
03:19:43 <Taejo> spoon _|_ = Nothing
03:19:48 <Taejo> spoon x = Just x
03:19:52 <Taejo> except sometimes not
03:20:03 <gwern> @quote spoon
03:20:03 <lambdabot> simonpj says: If you put a spoonful of sewage into a vat of wine, what do you have? A vat of sewage.
03:20:07 <Peaker> It converts pure exceptions to Maybe values?
03:20:13 <Peaker> Makes more sense to convert to Either?
03:20:30 <Jafet> @hoogle spoon
03:20:30 <quicksilver> gwern: awesome. In what context did he say that?
03:20:31 <lambdabot> No results found
03:20:39 <Jafet> I wonder how that's implemented
03:20:40 <kmc> Peaker, there might be cases where the fact that there was an exception is deterministic, but the value of the exception is not
03:20:51 <gwern> quicksilver: wild guess, purity and optimizations
03:20:52 <Taejo> Jafet: unsafePerformIO
03:20:57 <dolio> quicksilver: It was in a video I watched (I forget which one).
03:21:05 <gwern> quicksilver: as in, one possibll impure function contaminates all the others
03:21:07 <kmc> very simple, http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/src/Control-Spoon.html
03:21:21 <gwern> Jafet: it just shells out to the hoogle binary
03:21:35 <dolio> Peaker: spoon targeting Either could violate referential transparency.
03:21:47 <Jafet> No, I mean spoon
03:21:59 <Peaker> dolio, Why?
03:22:03 <Taejo> dolio: it violates referential transparency anyway
03:22:19 <dolio> Peaker: spoon (error "foo" + error "bar")
03:22:43 <dolio> That's free to turn into Left "foo" in one place, and Left "bar" in another.
03:22:54 <dolio> Taejo: I don't think that's true.
03:23:43 <Taejo> dolio: well if you consider undefined to be equal to (let loop = loop in loop)...
03:23:59 <Taejo> which is the case for the usual semantics of Haskell
03:24:33 <dolio> Yes, that's true. It means there is no longer one bottom.
03:24:44 <Peaker> dolio, I see
03:24:47 <quicksilver> it violates monotonicity, which feels worse than violating referential transparency.
03:24:55 <Peaker> quicksilver, what's that?
03:25:17 <quicksilver> monotonicity says that if a is more defined than b then f(a) is more defined than f(b)
03:25:56 <quicksilver> it's rather fundamental to the conventional semantics of recursive functions.
03:31:08 <dolio> Taejo: Anyhow, spoon at least has the property that identical expressions will yield identical results everywhere in the program, I think.
03:31:21 <Taejo> true
03:31:28 <Taejo> at least, seems true
03:31:32 <dolio> Which wouldn't hold for Either.
03:31:51 <dolio> Yeah, I don't know. It's conceivable that something bad could defeat it.
03:32:03 <dolio> Like <<loop>>, maybe.
03:32:17 <dolio> I don't know if it catches those.
03:34:29 <Taejo> no, it catches ArithException, ArrayException, ErrorCall and PatternMatchFail
03:34:48 <dolio> Ah. Okay.
03:35:46 <Tomsik_> umm
03:36:02 <Tomsik_> what's wrong with many bottoms
03:36:12 <Tomsik_> I mean, it has to be least element or minimal element?
03:37:19 <Jafet> Isn't <<loop>> just the default output from a NonTerminationException?
03:37:51 <dolio> Probably. I didn't know what the real name was.
03:40:04 <Jafet> Well, you could argue that non-termination is pure
03:40:20 <dolio> One of the problems is that the bottoms you can detect aren't bottoms anymore.
03:41:01 <benmachine> I think the idea with spoon is to basically reach into a source file and change some function that "should have been Maybe"
03:42:12 <dolio> At least, they're not bottoms in that you can write non-monotone functions (like spoon) if you try to consider them as "less defined" than other values of the type.
03:42:41 <dolio> So they're just additional values of every type.
03:43:16 <dolio> () no longer has two values (() and bottom), it has 3, or infinitely many.
03:43:17 <Tomsik_> Depends on how you define <= I guess
03:43:31 <quicksilver> dolio: I think it's certainly the intention that spoon only catch deterministic bottoms.
03:43:53 <quicksilver> From a certain perspective these deterministic asynchronous exceptions are an 'abuse' of exceptions
03:44:03 <quicksilver> and they should have been signalled in some other way in the first place.
03:44:07 <quicksilver> like benmachine said.
03:44:25 <dolio> Sure.
03:44:38 <aristid> spoon fromJust = id?
03:45:23 <Jafet> aristid: only for non-error values.
03:45:33 <Jafet> You mean fromJust.spoon?
03:46:33 <aristid> Jafet: i thought spoon detects deterministic errors like fromJust generates
03:46:51 <Jafet> Er, spoon.fromJust
03:47:14 <mjrosenb> oh god, asynchronous exceptions, thta just does not sound like fun.
03:47:30 <aristid> Jafet: ah, lol, got me there
03:48:00 <Jafet> aristid: not true for any _|_ :: Maybe a
03:48:28 <Jafet> s/any/all/
03:48:31 <aristid> Jafet: because i actually need to use teaspoon?
03:49:04 <Jafet> I don't think teaspoon changes things
03:49:36 <aristid> :t spoon
03:49:37 <lambdabot> Not in scope: `spoon'
03:49:59 <aristid>  :t spoon
03:49:59 <aristid> spoon :: (Control.DeepSeq.NFData a) => a -> Maybe a
03:50:06 <aristid>  :t teaspoon
03:50:06 <aristid> teaspoon :: a -> Maybe a
03:50:34 <aristid> so (teaspoon.fromJust) (Just undefined) is (Just undefined)
03:50:57 <aristid> whereas for spoon, that would be Nothing i think, which is not what id does
03:51:29 <dolio> teaspoon (fromJust undefined) = Nothing /= undefined
03:51:38 <Jafet> You missed the above discussion? spoon has different behaviour for different kinds of bottom
03:51:59 <aristid> Jafet: i did not miss it, but perhaps i did not fully understand it...
03:52:32 <aristid> dolio: somehow not what i expected, although it makes sense now
03:52:50 <Jafet> spoon turns certain errors into Nothing, and other bottoms remain as bottom
03:53:00 <quicksilver> I remark that you can still hide bottoms from spoon using \() -> 
03:53:23 <dolio> That will just prevent you from calling spoon on it. :)
03:54:14 <quicksilver> yeah.
03:54:23 <kmc> instance (Enum t, Bounded t, NFData a) => NFData (t -> a)
03:54:42 <quicksilver> that instance is likely to do rather a lot of work
03:54:49 <quicksilver> especially on functions of type Word64 -> a
03:55:07 <dolio> A lot of useless work, probably.
03:55:58 <kmc> «rnf [1..2^64]» also does a lot of work
03:56:37 <soupdragon> hah that's neat, exists and forall being left and right adjoints of substitution
03:56:51 <soupdragon> if you look at the inference rules it sort of 'fits'
04:01:14 <Axman6> > length [0..2^64 :: Int]
04:01:15 <lambdabot>   1
04:01:23 <Axman6> > length [0..2^63 :: Int]
04:01:23 <lambdabot>   0
04:01:28 <Axman6> > length [0..2^62 :: Int]
04:01:32 <lambdabot>   mueval-core: Time limit exceeded
04:06:59 <Jonno_FTW> >2^63
04:07:05 <Jonno_FTW> > 2^63
04:07:06 <lambdabot>   9223372036854775808
04:09:02 <Deewiant> > 2^63 :: Int
04:09:03 <lambdabot>   -9223372036854775808
04:09:06 <aristid> > 2^64 :: Int
04:09:07 <lambdabot>   0
04:09:14 <Deewiant> > maxBound :: Int
04:09:15 <lambdabot>   9223372036854775807
04:09:17 <aristid> haha.
04:12:13 <Axman6> jhg
04:12:20 <Axman6> whoops
04:17:08 * hackagebot mwc-random 0.6.0.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.6.0.0 (BryanOSullivan)
04:25:49 <Peaker> I like doing a lot of mechanism symbolic transformations for refactoring, not having to think much. Now GHC is accepting one thing and rejecting something that seems symbolically equivalent. Now it's forcing me to think!
04:25:51 <Peaker> heh
04:29:50 <Peaker> Arg, I'll do it the ugly way to not bring in Rank2Types
04:45:50 <Heffalump> Peaker: what are the things?
04:46:17 * hackagebot mwc-random 0.7.0.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.7.0.0 (BryanOSullivan)
04:49:49 <Peaker> Heffalump, I have a Key-value store transaction monad, and it has a   run :: Store m -> Transaction m a -> m a   operation.  I passed a (Store m) to a function, and that function used Transaction.run on it twice, with differing "a" types, and that worked. When I tried to pass a partially-applied Transaction.run instead of a Store, it didn't work (because then the "a" in the run signature is less polymorphic)
04:52:17 <Phyx-> is there a way to put ghc in like an interactive mode? or a way to delay it so I can attach a debugger?
04:52:56 <kmc> :O
04:53:03 <kmc> you can't run it from the debugger
04:53:04 <Jafet> Of course not!
04:53:23 * hackagebot statistics 0.6.0.2 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.6.0.2 (BryanOSullivan)
04:53:24 <kmc> ?
04:53:31 <kmc> gdb --args ghc --make foo.hs
04:54:14 <Jafet> I guess he doesn't mean ghc --interactive, does he.
04:54:30 <Phyx-> kmc: ah, forgot about that 
04:54:31 <Phyx-> hehhe
04:55:33 <kmc> ghc is segfaultin' or something?
04:55:40 <Phyx-> yup
04:55:43 <kmc> damn
04:56:28 <Phyx-> I figured, if i can provide more information it might get fixed faster :P
04:56:44 <Heffalump> Peaker: ah. An interesting H98 problem :-)
04:57:16 <Peaker> Heffalump, Yeah, I try to stick to H98 when possible
04:57:45 <Peaker> Heffalump, I have one module that uses ST (though it could be converted to H98 with less performance or IO in type), but otherwise I think I'm mostly h98
04:58:11 <kmc> yeah, this would require rank-2 types
04:58:15 <kmc> as does ST
04:58:25 * hackagebot criterion 0.5.0.3 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.3 (BryanOSullivan)
04:58:35 <Peaker> Well, I also use TH, TypeOperators, GeneralizedNewtypeDerivin  -- so I'm H2010 with the latter 2 which are a lot less problematic, IMO
04:58:45 <Peaker> kmc, Yeah, one of my modules has Rank-2 types for ST
04:58:55 <Peaker> kmc, but it's localized and if I want H98 compatibility it won't be much work
04:59:13 <Peaker> kmc, I don't want to use extensions all over the place. The use of ST came to solve a real performance issue
04:59:48 <kmc> i don't know of a standard way to fake rank-2 types in H98.  it seems near impossible
05:00:57 <Saizan> you can use a newtype to pack it though
05:01:16 <Peaker> My ST use is hidden behind a clean interface if that's what you mean?
05:01:37 <Twey> What's the point of conforming to H98 these days?
05:01:40 <kmc> if you want to wrap a polymorphic value with newtype then you need another extension
05:01:48 <kmc> PolymorphicComponents
05:01:52 <Peaker> btw, if you are OK with allowing the "s" parameter to escape all the way out, you can use ST without enabling Rank2Types in your own code
05:02:04 <Heffalump> Twey: not much beyond it being fairly minimal set of stuff on top of HM
05:02:49 <Heffalump> there has been a distinct lack of Haskell 2011 proposals :-(
05:03:05 <kmc> pencil me in for dependent types
05:03:31 <kmc> Peaker, yeah.  i even see some advantage to using ST exclusively with stToIO
05:03:35 <dolio> Not me.
05:03:37 <kmc> versus using IORef
05:04:10 <Heffalump> kmc: is that a finished proposal? :-)
05:04:29 <Peaker> @type runST $ return ()
05:04:30 <lambdabot> ()
05:04:59 <kmc> ;)
05:06:14 <Heffalump> Peaker: when do you ever need to enable Rank2Types in your own code to use ST? (unless you want to wrap runST somehow)
05:06:53 <Peaker> Heffalump, When you don't want to leak the fact you use ST outwards
05:07:26 <Peaker> Heffalump, For example, I have an Image type, whose internal representation is an ST computation that puts pixels.. I don't want my image type to have an "s" type param
05:07:58 <Heffalump> how would you wrap that?
05:08:09 <Heffalump> I remember having precisely that problem a while ago and concluding it couldn't be done.
05:08:32 <Heffalump> oh, you don't want to have STRefs inside Image, just ST?
05:08:43 <Peaker> Heffalump, Yeah
05:08:53 <Heffalump> I think my use case needed STRefs
05:09:18 <Taejo> :T (%)
05:09:23 <Taejo> :t (%)
05:09:24 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
05:09:24 <Peaker> Heffalump, even if you do need STRefs, can't you just make another wrapper?  data Internal s = Internal { stvars and st here } ; data Exposed = Exposed { forall s. Internal s ... } ?
05:09:48 <Heffalump> I don't think so, though I'd have to think about why again.
05:09:57 <Taejo> > length . nub $ [a % b | a <- [0..1000], b <- [1..1000]]
05:10:00 <Heffalump> In your case, what's the difference between forall s . ST s a and just a?
05:10:02 <lambdabot>   mueval: ExitFailure 1
05:10:21 <Peaker> Heffalump, It was more like:  forall s . STArray s ... -> ST s ()
05:10:43 <Heffalump> ah, right
05:10:55 <Peaker> Heffalump, I looked again now and realized I totally changed it -- and now my image type only has a DList of pixels, so only the "runImage" needs ST internally
05:11:09 <Heffalump> Peaker: in your wrapper proposal above, how would you get hold of an Internal s?
05:11:35 <Heffalump> to be concrete, suppose the contained value was a single STRef
05:11:59 <Peaker> Heffalump, I may have misplaced the "forall", or just wrong.. I'll try it at some point :)  Currently I'm finishing up a *huge* refactoring
05:12:11 <Peaker> and if this refactoring works when first run, Haskell is the most awesome language ever :)
05:12:43 <Twey> > 100109 % 300327
05:12:44 <lambdabot>   1 % 3
05:13:08 <Twey> Is there some really fast common-factors algorithm % uses?
05:13:27 <Peaker> Changing my imperative everything-in-IO (in order to access a mutable database and a versioned view of it) to a more functional Transaction monad
05:13:33 <dolio> Probably just gcd.
05:14:06 <Twey> Does it just try everything in order?
05:14:28 <dolio> gcd most likely uses the Euclidean algorithm.
05:15:43 <quicksilver> Heffalump: I think it depends what kinds of combination/operation you need to do.
05:16:11 <dolio> @src gcd
05:16:12 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
05:16:12 <lambdabot> gcd x y = gcd' (abs x) (abs y)
05:16:12 <lambdabot>    where gcd' a 0  =  a
05:16:12 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
05:16:37 <quicksilver> Heffalump: if f :: Image -> X just uses stuff inside one particular Image then an existential box is fine - the existential guarantees the 's' within the box is consistent.
05:16:57 <quicksilver> Heffalump: but for g :: Image -> Image -> Y, you're stuck, because the s's inside the different boxes don't match.
05:17:06 <Heffalump> quicksilver: yeah, I think that was my problem
05:17:08 <quicksilver> Heffalump: you need to expose the 's' for binary operators.
05:19:23 <Saizan> mwc-random's can be packaged up in the same way, letting you forget about ST
05:20:41 <Saizan> well, not same: "newtype Rand a = Rand (forall s. Gen s -> ST s a)"
05:21:55 <Twey> dolio: I see!  Thank you.
05:25:21 <mornfall> Anyone has an idea if I can extract the type(s) of a Constr parameter(s) using Data.Data?
05:26:03 <mornfall> (Or using anything else, but Constr comes from Data.Data IIRC)
05:26:59 <quicksilver> I don't think Constr has that information available.
05:27:16 <quicksilver> haskell doesn't really have reflection, it has some ways to reify some structural things at compile time :)
05:27:23 <quicksilver> what are you trying to do?
05:27:47 <exDM69> quicksilver: what would you call Typeable if not reflection? Runtime type information?
05:28:24 <mornfall> quicksilver: Well, I am trying to convert an ADT into a runtime structure.
05:28:54 <mornfall> quicksilver: Basically I need to distinguish nullary and unary ctors, and unary ctors of the form A (Maybe X).
05:29:05 <kmc> :t gmapQ typeOf
05:29:05 <lambdabot> forall a. (Data a) => a -> [TypeRep]
05:29:14 <kmc> > gmapQ typeOf (Just 'x')
05:29:15 <lambdabot>   [Char]
05:29:24 <kmc> > gmapQ typeOf (Either 3 5.0)
05:29:25 <lambdabot>   Not in scope: data constructor `Either'
05:29:27 <kmc> dur
05:29:35 <kmc> > gmapQ typeOf (Left 3)
05:29:36 <lambdabot>   Ambiguous type variable `b' in the constraint:
05:29:36 <lambdabot>    `Data.Data.Data b'
05:29:36 <lambdabot>      a...
05:29:40 <kmc> > gmapQ typeOf (Left 3 :: Either Int Char)
05:29:41 <lambdabot>   [Int]
05:29:49 <mornfall> Indeed.
05:30:04 <mornfall> kmc: Thanks. :)
05:30:07 <kmc> :)
05:30:13 <aristid> > gmapQ typeOf (Right 'x' :: Either Int Char)
05:30:14 <lambdabot>   [Char]
05:30:19 <quicksilver> exDM69: the thing about Typeable is it's not magic - it requires instances to be written.
05:30:29 <quicksilver> exDM69: and you can write instances which lie, if you choose to do so.
05:30:32 <kmc> > gmapQ typeOf ('x',3,True)
05:30:33 <lambdabot>   [Char,Integer,Bool]
05:30:33 <mornfall> quicksilver: It's magic because they can be derived. :D
05:30:45 <quicksilver> yes, the derived instances are slightly magic.
05:30:50 <mornfall> Well, magic enough for me.
05:30:52 <kmc> indeed, if you don't derive Typeable, you're entering a world of pain
05:30:56 <kmc> unsafeCoerce-style
05:31:00 <quicksilver> but they still break across packages, IIRC.
05:31:06 <dolio> Does that mean Enum is magic, too?
05:31:23 <aristid> dolio: yes
05:31:38 <mornfall> Well, as long as the derivation can be done with TH, it's acceptable magic.
05:31:41 <kmc> Typeable is magic in another way: the implementation of 'cast'
05:31:46 <mornfall> (Not sure it is the case, though.)
05:31:49 <aristid> :t cast
05:31:51 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
05:32:00 <aristid> @src cast
05:32:01 <lambdabot> Source not found. :(
05:32:44 <Ke> Twey: see gmp documentation and algorithms
05:32:46 <kmc> cast x :: forall a b. (Typeable a, Typeable b) => a -> Maybe b
05:32:48 <kmc> err
05:32:51 <kmc> cast :: forall a b. (Typeable a, Typeable b) => a -> Maybe b
05:33:03 <kmc> cast x = if typeOf x == typeOf (undefined :: b) then Just $ unsafeCoerce x else Nothing
05:33:24 <kmc> see, if you write buggy Typeable instances you can totally break the type system
05:34:17 <mornfall> > gmapQ typeOf ((fromConstr $ toConstr (Just 1)) :: Maybe Int)
05:34:17 <lambdabot>   [Int]
05:34:31 <Ke> dolio: sounds a bit silly to use gcd for gmp numbers where gmp available
05:34:35 <aristid> :t gmapQ
05:34:36 <lambdabot> forall u a. (Data a) => (forall d. (Data d) => d -> u) -> a -> [u]
05:34:51 <aristid> :t typeOf
05:34:53 <lambdabot> forall a. (Typeable a) => a -> TypeRep
05:35:52 <dolio> Ke: Ratio doesn't know if it's being used with Integers, so it can't use a special routine when it is.
05:36:12 <dolio> Unless gcd were to be added to a class or something.
05:36:41 <Ke> are you saying that ghc is one 100% kludge free
05:37:02 <Ke> -one
05:39:37 <Ke> though anyways gmp used eucleidian algorithm as well iirc
05:39:41 <Ke> so it might not matter
05:40:43 <dolio> I don't think GHC even has the gmp gcd imported as a primop.
05:41:31 <quicksilver> the gmp euclidean algorithm would be slightly faster than the ghc implementation though
05:41:38 <quicksilver> probably only 400-1000x faster
05:41:54 <quicksilver> GHC has a very poor coverage of the gmp primops, which is quite a shame.
05:42:01 <Ke> http://gmplib.org/manual/Greatest-Common-Divisor-Algorithms.html#Greatest-Common-Divisor-Algorithms
05:42:30 <dolio> copumpkin was working on getting more imported, but he won't be back for a while.
05:42:31 <arch1> hello to all :  has anyone found a wallpaper with the lambda symbol  of haskell ?
05:42:35 <Ke> luckily multiprecision is mostly not performance critical
05:43:02 <zygoloid> arch1: you could look for half-life wallpapers :)
05:43:25 * quicksilver thinks the haskell logo is so ugly it would make a terrible wallpaper
05:43:31 <zygoloid> if you're looking for the >\= logo, i think that's available in SVG somewhere
05:43:39 <quicksilver> if you just want a general lambda wallpaper, googling finds loads
05:44:03 <arch1> thank  to all : grazie a tutti !
05:44:03 <Jafet> import Control.Crowbar
05:44:44 <zygoloid> unsafeTriggerResonanceCascade
05:45:41 * hackagebot hlibev 0.2.8 - FFI interface to libev  http://hackage.haskell.org/package/hlibev-0.2.8 (AycanIrican)
05:46:27 <wto> @pl \i -> (cycle [True,False]) !! i
05:46:28 <lambdabot> (cycle [True, False] !!)
05:55:07 <roconnor> http://stackoverflow.com/questions/3236442/iteration-of-a-randomized-algorithm-in-fixed-space-and-linear-time/3239837#3239837
05:55:19 <roconnor> ^^ I don't understand dons worker wrapper transform here.
05:55:51 <roconnor> it looks to me like the only thing being saved is f is not passed around as much before.
05:56:11 <roconnor> but I assumed that constants are lifted out of loops in GHC already
05:56:15 <roconnor> somewhere along the line
05:56:19 <dolio> Nope.
05:56:23 <roconnor> gah
05:56:35 <dolio> That's the static argument transform, and it's not done in general.
05:56:40 <roconnor> compilers for functional langauges constantly let me down
05:56:40 <dolio> Maybe at all.
05:56:50 <roconnor> will supero do it?
05:56:54 * roconnor hopes
05:56:56 <roconnor> @seen ndm
05:56:57 <preflex>  ndm was last seen on #haskell 1 year, 66 days, 2 hours, 38 minutes and 15 seconds ago, saying: plus with current compiler technology, it would be slower
05:56:57 <lambdabot> Unknown command, try @list
05:57:08 <roconnor> heh
05:57:09 <dolio> I've talked to someone working on getting it in, but apparently it's not always a win, so they were still looking for a good heuristic.
05:57:48 <dolio> It's really important when you need functions taken as arguments to be inlined, though.
05:58:14 <roconnor> does real world haskell talk about this sort of thing?
05:58:27 <dolio> Not sure.
05:58:28 <zygoloid> this haskell supercompilation paper... are we going to get that in ghc any time soon?
06:25:52 <Peaker> Did Haskell2010 get empty data decls?
06:26:19 <zygoloid> Peaker: yes.
06:26:53 <Peaker> cool
06:27:16 <Peaker> otherwise I don't think there's a way to avoid warning about unused data constructor (when it is enabled, of course), in a module that only wants to export the type
06:28:35 <zygoloid> Peaker: http://tinyurl.com/haskell2010
06:29:23 <slade118> I'm writing a small command line app, which (amongst other things) takes commands and does some function based on the word
06:29:34 <slade118> given that the functions have different signatures
06:29:58 <slade118> is there a nice way of looking up a function based on the word without having a huge case of
06:30:29 <zygoloid> slade118: you should be able to ensure that the functions all have the same signature
06:30:38 <zygoloid> slade118: once you've done that, you can use lookup
06:30:40 <zygoloid> @type lookup
06:30:41 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:30:43 <kmc> or Data.Map
06:30:56 <kmc> why are the sigs different?
06:31:28 <byorgey> at the very least you can just have a Map from commands to IO () values
06:31:43 <slade118> well say i have 'add' which also takes a string of values and does something with them
06:31:54 <slade118> but average just prints out the average values held
06:32:11 <zygoloid> slade118: you could put the parsing of arguments into the commands themselves
06:32:38 <zygoloid> or you could make a Command type which holds the function and an argument parser for it, as an existential
06:33:04 <slade118> ok
06:33:34 <slade118> thanks
06:35:17 <byorgey> sounds like you may want some sort of State monad to remember values?
07:04:59 <flazz> is there a better way to brows haskell docs than to have a bunch of tabs in a browser open?
07:05:57 <kmc> that's how i do it
07:06:06 <kmc> i have hotkeys to open various tabs
07:06:10 <medfly> that's the correct way then :-p
07:06:13 <medfly> heh
07:06:15 <Peaker> I wish there was more interactive help like Python's help()
07:06:25 <Peaker> and more documentation at the touch of a key
07:06:29 <Peaker> (in the Editor/IDE)
07:06:36 <Jafet> :t, :i
07:06:43 <kmc> :b
07:06:55 <kmc> er :browse
07:08:35 <Phyx-> Peaker: part of that problem is that there is no standard editor for haskell
07:08:54 <Phyx-> and i don't think there ever will be
07:09:25 <DarkUnicorn> there is a standard editor for text of any kind, named vim ;)
07:09:29 <Ke> standard editor sound like a nightmare
07:09:31 <Peaker> Phyx-, my current project's goal is to be a structural editor for Haskell
07:09:42 <Peaker> Phyx-, I plan it to be the most awesome IDE ever :)
07:09:49 <Peaker> (no text in sight)
07:09:58 <Peaker> Well, lots of text on screen, it's a presentational thing :)
07:10:18 <Peaker> Ke, Why do you think so?
07:10:35 <Ke> because people have preferences
07:11:00 <Ke> any editor I use has to work over ssh
07:11:11 <kmc> most programs work over ssh
07:11:41 <Ke> well I don'y consider -X or -Y an option
07:11:50 <Phyx-> Peaker: for which there are already many afaik
07:12:34 <flazz> DarkUnicorn: in vim do you use something automated to do indenting or do you manually add indents a lot?
07:12:45 <waterlaz|work> hello
07:12:47 <Peaker> Ke, My editor will work over ssh
07:12:52 <Ke> Phyx-: why would we need standard editor, can't we just interface existing editors to haddock documentation
07:12:59 <Peaker> Ke, it's a console GUI and later will have a graphical gui as well
07:13:02 <waterlaz|work> does anybody know how can I convert a ByteString into a CString?
07:13:11 <Peaker> Ke, I want to create a non-textual/structural editor 
07:13:32 <Ke> Peaker: unknown words
07:13:32 <waterlaz|work> useAsCString frees the CString and I don't want that 
07:13:36 <Peaker> Phyx-, I don't know of any good structural editor -- that is good with the keyboard, has integrated structural revision control, edits a code graph and not an AST, ...
07:13:43 <Phyx-> waterlaz|work: useAsCString
07:14:03 <DarkUnicorn> flazz: it indents automatically, but i'm not sure if it does with haskell code
07:14:06 <zygoloid> Peaker: sounds pretty cool. how far have you got?
07:14:08 <Peaker> Ke, they just mean the editor edits not a text representation of code, but an abstract syntax representation, the graph that the code would parse to
07:14:31 <Ke> something like lyx?
07:14:36 <Phyx-> Ke: from a features stand point, not all will support the same set, so you'd just shift the problem
07:14:37 <flazz> DarkUnicorn: yeah for other languages it seems to be spot on, but i find in haskell i'm using the spacebar a lot
07:14:38 <Peaker> zygoloid, I have currently got an editor for dumb trees (the idea is to later make it an editor for smarter trees/graphs which represent code) -- and mainly focusing on the revision control
07:14:46 <DarkUnicorn> flazz: but i think it would be enough for me if it keeps the level of indentation of the last line
07:14:51 <waterlaz|work> Phyx-, well, yes, but it frees the CString, and I need that CString from the C code later 
07:14:52 <Peaker> Ke, Well, there are some similarities, but very different too :)
07:15:11 <Jafet> Peaker: so your editor would emulate ghc?
07:15:13 <flazz> anyone familiar with the current status of Yi? especially Cocoa Yi?
07:15:30 <Peaker> zygoloid, It's already got persistent undo, persistent gui state, it's "saveless" (everything is transactionally saved after every operation), I can make "branches" (save ptrs to the version history that I can browse between)
07:15:30 <waterlaz|work> I would realy like not to make another copy of it 
07:15:40 <Peaker> Jafet, Well I do want type-inference as you edit
07:15:48 <Peaker> Jafet, So either I hook up with GHC api's, or I implement it myself
07:16:26 <Peaker> zygoloid, If you kill the editor at any point, and launch it -- it's exactly at the same state, and you can undo all the way back in history.. Later I need to implement merges/conflict handling
07:16:34 <waterlaz|work> the Data.ByteString doesn't export the underlying structure of ByteString so it seems I can't implement it myself
07:16:40 <Jafet> Haskell isn't one particular language -- gonna do TH?
07:17:09 <Peaker> zygoloid, UI's to show diffs, etc. Then when revision control is complete I can smartify the tree
07:17:11 <DarkUnicorn> flazz: therer is a haskell indent file for vim http://www.vim.org/scripts/script.php?script_id=1968
07:17:20 <zygoloid> Peaker: how do you deal with multiple modules? how do you deal with changes to the presentation of the graph? (are they history items like any other?)
07:17:24 <flazz> DarkUnicorn: you use that one?
07:17:37 <zygoloid> Peaker: in any case, i would like to subscribe to your newsletter ;-)
07:17:51 <DarkUnicorn> flazz: no, didn't try. i'm not coding much in haskell currently
07:18:05 <chrisdone> Peaker: did you already see scion?
07:18:27 <Peaker> chrisdone, The text editor?
07:18:39 <chrisdone> Peaker: http://github.com/nominolo/scion
07:18:55 <Phyx-> waterlaz|work: there's a CString -> IO ByteString but not the other way around afaik, but ByteString is just a package, unpack the source and add it there
07:19:24 <chrisdone> Peaker: in brief, a service for providing services similar to what you speak of, of Haskell, for your IDE/editor
07:20:02 <waterlaz|work> Phyx-, yeah, I know, but I still would like to find a nicer solution
07:20:20 <Peaker> zygoloid, awsome! :-)  I don't deal with those yet, I've just got a dumb tree editor yet.  But I plan to have modules as arbitrary containers just for UI manageability..  What do you mean by changes to the graph presentation?
07:20:48 <Peaker> chrisdone, Ah, sounds cool, though I really want to replace the entire textual toolchain with a structural one
07:21:18 <zygoloid> Peaker: well, i'm imagining you have some kind of graphical two-dimensional layout in mind. would you allow the user to rearrange those graphical doodads, and if so, how do you persist those sorts of changes?
07:21:21 <Peaker> chrisdone, I don't want a merge conflict when I rename a variable and someone else touches a line involving that name, or if someone moves the name elsewhere, for example -- which is trivial with structural revision control
07:21:49 <chrisdone> i haven't read the rest of the conversation, just thought i'd mention scion
07:22:27 <Peaker> zygoloid, Oh, I think editing a textual representation is a bad idea, but that syntax/text is a great way to present on screen.. The idea is that it will look kinda similar to the way it looks now -- what's different is mainly what keyboard bindings do (structural editing, not textual), the many features that become easy with this representation, and the revision control which is structurally aware
07:23:16 <Peaker> zygoloid, I've got a really old Python prototype of this project before I knew Haskell, with a C editing UI.  I've discovered Haskell because in that editor I started designing a GUI DSL in Python that was purely functional, and wondered how people solved the purely functional problem before :)
07:23:46 <Peaker> So the project was delayed for a year or two while I learn Haskell, and now I'm back :)
07:23:54 <Peaker> (reimplementing it in Haskell)
07:24:24 <zygoloid> Peaker: haha, awesome
07:24:45 <chrisdone> Haskell is like a black hole for programmers
07:24:58 <chrisdone> or a honey pot
07:25:01 <Peaker> I'm trying to suck my coworkers into it now
07:25:20 <chrisdone> what's this? five years later, oh, that's interesting, i've never seen that before!
07:25:22 <ManateeLazyCat> Peaker: GUI DSL ?
07:25:59 <aristid> Peaker: are they laughing at you for this? that's my experience at least
07:26:05 <medfly> heh
07:26:10 <medfly> your company will collapse!
07:26:22 <medfly> no one wants to write C++ any more!
07:26:27 <Peaker> aristid, plenty are. But some took it seriously and are learning/learned it. None took it seriously enough to start working with it for real stuff yet
07:26:29 <Phyx-> Peaker: how does your approach differ from editors such as Proxima, which do it for arbitrary documents?
07:26:30 <Peaker> aristid, oh wait, one did :)
07:26:37 <Peaker> aristid, one is re-writing a big infrastructure we have in Haskell
07:26:49 <Peaker> Phyx-, I'll take a look at Proxima
07:26:51 <aristid> Peaker: you must be pretty good at preaching :)
07:27:33 <Peaker> aristid, I performed a Haskell talk -- where I tried to cover basic syntax, some type-class coolness, type system coolness, and monadic coolness
07:27:40 <Peaker> I think some were impressed
07:28:00 <Peaker> showing how "filterM" is so generic and re-usable, for example, that I can use it to ask users about list items to filter them, or generate a powerset
07:28:06 <bnonym> so in general you try to cover coolness => don't forget your sunglasses.
07:29:49 <kmc> Haskell is elegant but it's not practical for the real world.  I know this because some guy on Reddit said so
07:29:50 <aristid> rule number 1 of haskell talks: wear sunglasses while giving them
07:29:51 <kmc> ;P
07:30:16 <kmc> rule number 1 of haskell talks: use Comic Sans MS
07:30:16 <aristid> kmc: i read on stack overflow that there are plenty of reasons to use PHP instead.
07:30:19 <profmakx> what the heck is that real world everyone is talking about?
07:30:50 <aristid> real world is where they use comic sans ms.
07:31:43 <Jafet> @remember kmc Rule number 1 of Haskell talks: use Comic Sans MS.
07:31:43 <lambdabot> Done.
07:32:06 <winxordie1> profmakx: probably FP n00bs in denial
07:32:22 <aristid> kmc: but there are some niche uses for haskell, for example you can formally prove your programs. but that's normally not necessary for normal programs because you can use unit tests instead.
07:32:40 <aristid> @hoogle RealWorld
07:32:41 <lambdabot> No results found
07:32:43 <medfly> I think Haskell is not practical for the real world because in the real world, I am rarely the person deciding a lot of stuff on the project.
07:32:48 <medfly> but that could be just me.
07:32:53 <Jafet> RealWorld#, now with free hash
07:32:57 <drbean> < [i | (i,t) <- zip [0..] "Some array"]
07:33:33 <drbean> > [i | (i,t) <- zip [0..] "Some list"]
07:33:34 <lambdabot>   [0,1,2,3,4,5,6,7,8]
07:33:58 <aristid> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad-ST.html#t%3ARealWorld
07:34:15 <drbean> Is that the right way to convert a list into the indices of the list?
07:34:45 <monochrom> a right way.
07:35:07 <aristid> @pl \xs -> [0 .. length xs]
07:35:07 <lambdabot> enumFromTo 0 . length
07:35:17 <jmcarthur> ugh don't use length
07:35:22 <ManateeLazyCat> kmc: I'm re-think "separate process hot-swapping" idea, I got a complete solution: We have two kind of hot-swapping: core-swapping and plugin-swapping. Because my plugin is running in separate process and with MVC design, so plugin process can keep running when *core restart*, after *core restart*, i just need *redirect* plugin graphics to core process. All status won't lose when "core restart"! 
07:35:25 <jmcarthur> what if it's an infinite list?
07:35:46 <aristid> jmcarthur: true, didn't consider that
07:35:50 <Jafet> Use genericLength!
07:35:51 <jmcarthur> or even just an expensive list to compute
07:36:02 <jmcarthur> genericLength with lazy naturals would be okay
07:36:09 <aristid> :t zipWith const [0..]
07:36:10 <lambdabot> forall a b. (Num a, Enum a) => [b] -> [a]
07:36:10 <kmc> > zipWith const "hello world" [1..]
07:36:11 <lambdabot>   "hello world"
07:36:16 <kmc> > zipWith const [1..] "hello world"
07:36:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
07:36:18 <Jafet> Or not, depending on how enumFromTo is implemented
07:36:20 <medfly> I have to say that after being forced to write some C code, it took me a while to think of the Haskell way to do something. :/
07:36:23 <ManateeLazyCat> kmc: Any better idea?
07:37:04 <Phyx-> weee the internal GHC ASTs now have Data and Typeable instances
07:37:10 <ManateeLazyCat> kmc: Now i can add any advanced core feature, and restart core won't lose plugins' status.
07:37:10 <Phyx-> SYB here i come!
07:38:12 <monochrom> oh! yes they need some folds seriously :)
07:39:03 <medfly> :/
07:39:52 * hackagebot jmacro 0.3.2 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.3.2 (GershomBazerman)
07:40:16 <kmc> :t fromConstr
07:40:17 <lambdabot> forall a. (Data a) => Constr -> a
07:40:52 <aristid> medfly: don't be sad. instead, dream of the future when the smart kids will whine that this terrible low-level language Haskell is dominating, and that a language without DT is just archaic
07:40:52 <Jafet> length xs = case spoon $ max $ zip [1..] xs of Nothing -> 0; Just x -> x -- to jmcarthur with love
07:41:06 <kmc> aristid, we'll be long dead by then
07:41:13 <Jonno_FTW> how do I fix the type error on this: Data.ByteString.Lazy.tail . Data.ByteString.Lazy.dropWhile (/= ':') ?
07:41:18 <medfly> hehe
07:41:23 <aristid> kmc: no reason not to dream :)
07:41:45 <zygoloid> you can already get a pretty convincing simulation of DT with type families and GADTs
07:41:51 <aristid> also with cryonics maybe...
07:41:51 <Peaker> Haskell definitely has practical short-comings (the hackage split, lazy I/O sucks and the alternatives not polished, ..) but I've never stumped on them, at worst, a small obstacle. It is an amazing aid in making large changes
07:42:26 <kmc> aristid, given that first-class functions are just now being considered for future revisions of Java and C++
07:42:29 <kmc> being a feature from 1936
07:42:54 <aristid> kmc: i'm pretty hopeful i will live for 70 years to come
07:42:54 <zygoloid> kmc: i'm pretty sure that mathematics had first-class functions before then
07:42:58 <Jafet> Nope, C++ still uses class wrappers for functions. The lambda syntax is sugar.
07:43:19 <kmc> Jafet, that counts imo
07:43:21 <Peaker> Phyx-, Proxima looks awesome. I'm aiming for something that can edit a large project though, so it cannot fit all in one big RAM value, which seems like what Proxima is doing.. I'm explicitly using a Key/Value store with only Binary instances for this
07:43:22 <monochrom> :t Data.ByteString.Lazy.tail . Data.ByteString.Lazy.dropWhile (/= ':')
07:43:23 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Char'
07:43:23 <lambdabot>     In the second argument of `(/=)', namely ':'
07:43:23 <lambdabot>     In the first argument of `BSL.dropWhile', namely `(/= ':')'
07:43:33 <Jafet> Not, I think, without proper closures (which requires garbage collection)
07:43:43 <Peaker> Phyx-, And it should have lots of UI specific to code editing, smart completions, type inference as you type, ...
07:43:55 <monochrom> :t Data.ByteString.Lazy.dropWhile
07:43:56 <lambdabot> (Word8 -> Bool) -> BSLC.ByteString -> BSLC.ByteString
07:44:03 <kmc> Jafet, i'm not fanatical enough to insist that C++ change the entire memory-management philosophy
07:44:06 <monochrom> need to convert ':' to Word8
07:44:36 <Jonno_FTW> and how do I do that?
07:44:36 <kmc> C++1x's lambdas evaluate to things which are essentially closures.  they are manually managed, like everything else in the language, as are their captured values
07:44:54 <Phyx-> Peaker: ok :)
07:45:02 <zygoloid> kmc: do you find memory management in c++ to be a problem, in practice? i can't really say i do...
07:45:11 <Peaker> Jafet, You can have "improper closures" (with explicit copying to heap/freeing) which give you most of the niceness
07:45:15 <monochrom> > fromIntegral (fromEnum ':') :: Word8
07:45:16 <lambdabot>   58
07:45:19 <jaspervdj> So... I want to run a Haskell script during `cabal configure`. I have found out how to add the hook, but now I'm looking for the best way to call `runghc` from within a Haskell file.
07:45:22 <kmc> zygoloid, what does "problem" mean?
07:45:33 <zygoloid> kmc: something which causes bugs
07:45:40 <kmc> yes i do
07:45:45 <Peaker> zygoloid, Do you use boost::shared_ptr/etc?
07:45:49 <monochrom> :t Data.ByteString.Lazy.tail . Data.ByteString.Lazy.dropWhile (/= fromIntegral (fromEnum ':'))
07:45:50 <lambdabot> BSLC.ByteString -> BSLC.ByteString
07:46:00 <kmc> zygoloid, i've had to debug C++ code written by people who didn't understand they couldn't return pointers to a stack variable
07:46:11 <kmc> because hey, it seems to work, and if it were wrong it'd segfault right?
07:46:19 <Jafet> Languages don't cause bugs, programmers cause bugs!
07:46:25 * Jafet paints that onto a picket
07:46:30 <kmc> right, omnipotent programmers don't need a high level language
07:46:53 <Peaker> kmc, In this context, omniscience = omnipotence?
07:46:54 <monochrom> omnipotent programmers are at a higher level than languages
07:47:01 <kmc> Peaker, the two are formally equivalent
07:47:02 <medfly> heh
07:47:21 <kmc> of course i've myself made lots of memory management errors too
07:47:27 <kmc> it's not impossible to fix them, or to be careful
07:47:34 <kmc> but it's a major obstacle in the way of getting shit done
07:47:40 <wlangstroth> kmc: just annoying
07:47:48 <kmc> in particular because the whole API you expose depends on your memory management decisions
07:47:56 <kmc> this is a major blow to composability
07:48:43 <kmc> that's why automatic memory management is a core feature of HLLs, and not just a miscellaneous nicety
07:49:31 <kmc> C++ provides tools to improve the situation
07:49:36 <kmc> reference-counting smart pointers and the like
07:50:21 <kmc> if these are used correctly and consistently by a team of experts who understand all the implications, it can produce an outcome almost as nice as true automatic storage management
07:50:30 <kmc> and with some advantages (deterministic destruction, etc)
07:51:08 <aristid> on an iPhone, that's definitely worth something
07:51:10 <exDM69> C++ memory management just got a lot better with the addition of rvalue references and move constructors.
07:51:11 <monochrom> mutably assured destruction
07:51:45 <exDM69> it is now possible to store noncopyable objects such as file streams in containers (like std::vector)
07:52:17 <Peaker> exDM69, You mean Microsoft C++?
07:52:23 <Ke> no standard
07:52:30 <Ke> c++1x
07:52:36 <Peaker> Is it a standard?
07:52:38 <exDM69> Peaker: no, the upcoming standard
07:52:40 <Ke> not yet
07:52:54 <exDM69> Peaker: GCC has pretty decent support, so does MSVC++ 2010
07:53:08 <exDM69> neither is complete and they support a somewhat different feature set
07:53:11 <exDM69> but the core stuff is therer
07:53:44 <exDM69> std::function is very nice
07:54:32 <exDM69> now it doesn't have to be such an ugly kludge like boost::function (which uses a macro to replicate the function template for N parameters)
07:54:51 <Peaker> exDM69, Well, I'm turned off by things like std::pair taking hundreds of lines
07:54:55 <winxordie1> woah, I didn't know I was in ##c++
07:55:00 <exDM69> Peaker: not any more
07:55:06 <jmcarthur> ha, so they renamed it to C++1x?
07:55:14 <Peaker> exDM69, can you come to #haskell-blah ?
07:55:17 <kmc> winxordie1, what's amazing is that it's not a flamewar yet
07:55:24 <exDM69> jmcarthur: not really, but it didn't make it in the 1x's
07:55:31 <winxordie1> kmc: I was really hoping for one too. :(
07:55:45 <monochrom> haha
07:55:50 <exDM69> Peaker: sorry, too many channels
07:56:09 <Peaker> exDM69, Ok, so here :) What new stuff allows std::pair to be shorter?
07:56:46 <Peaker> I think if C++ got rid of the class system/virtuals, and left only the template stuff, add concepts, they will get much nicer stuff :)
07:56:48 <exDM69> Peaker: well, there's variadic templates and std::tuple. don't know (or care about) the implementation of pair, but the tuple is decent
07:57:25 <exDM69> yeah, you could get rid of the virtual method-kludge and use haskell-style call-by-type
07:58:42 <Peaker> the virtual stuff is very error-prone (no "override" specified, implementation inheritance sucks, interfaces ought to be concepts, ..)
07:59:48 <quicksilver> exDM69: rvalues and move constructors are very cool in what they permit in terms of 'possibilities', but they make me physically sick because they add yet *another* kind of complexity for programmers to understand.
08:00:33 <kmc> learning C++ is fun
08:00:40 <quicksilver> A,A*,A&,A&&; copy constructor, move constructor, operator=; 
08:00:41 <kmc> because there's so many features and they interact in weird subtle ways
08:00:56 <kmc> it's a masterfully designed esoteric language
08:00:56 <quicksilver> learning C++ is fun in the same way that solving cryptic crosswords is fun.
08:00:58 <exDM69> quicksilver: "C++ is a better C", remember. it just adds another common convention to do something that's notoriously verbose in C
08:01:11 <exDM69> C++ is very very complicated, even overly so
08:01:14 <kmc> C++ is a better C if a rocketship is a better motorcycle
08:01:21 <quicksilver> but when I want to actually solve some real world problem, I don't want to solve cryptic crosswords.
08:01:29 <kmc> C++ is at least 10 times the size of C
08:01:39 <kmc> C is tiny and orthogonal
08:02:22 <aristid> it's funny how "C vs C++" can be such a popular topic in a haskell channel
08:02:28 <estolten> Has anyone read 'Coders at Work?'
08:02:57 <p_l> some more time and I'll know the content without reading...
08:03:01 <Gracenotes> if C's features are normal to each other, C++'s features are at variable and jarring angles
08:03:02 <estolten> They talk about this very discussion with many computer scientists.
08:03:14 <Peaker> aristid, unsurprising, as Haskell fans are most probably interested in many languages, or they'd never hear of Haskell :)
08:04:49 <monochrom> agda is a better modula-3
08:06:14 <thoughtpolice> Peaker: it's widely known that everybody who ever uses haskell, ever is really a snobby academic elitist who just wants to talk shit about C++ because they can't use it :P
08:06:22 <ManateeLazyCat> Peaker: My friend say me, "Just nuts use Haskell...", i don't know how to say .....
08:06:40 <aristid> thoughtpolice: so true.
08:06:48 <thoughtpolice> it's arguable though, how many people actually can use C++
08:07:17 <thoughtpolice> i mean, I knew C, then went to haskell, and now do C++ for my job
08:07:38 <thoughtpolice> so i would say C++ is a hell of a language to learn, just as much as haskell was
08:07:43 <thoughtpolice> only for all the wrong reasons
08:07:49 <jmcarthur> thoughtpolice: it's widely known that nobody ever uses haskell. there are just snobby academic elitists who just want to talk shit about C++ because they can't use it
08:08:03 <jmcarthur> thoughtpolice: that haskell is actually *used* is a niche concept
08:08:13 <Peaker> ManateeLazyCat, Tell him nuts are surprisingly more productive at creating reliable programs :)
08:08:17 <thoughtpolice> jmcarthur: truth
08:08:33 <ManateeLazyCat> Peaker: Last i give up.
08:08:34 <wlangstroth> how much software would have to be written in Haskell before it could be considered "ever used"?
08:08:40 <aristid> also, http://cheezburger.com/View/3749502464
08:08:41 <monochrom> if just nuts use haskell, there are 600 nuts here. use numbers to justify everything.
08:08:49 <jmcarthur> wlangstroth: depends on how broadly you want it to be accepted as such
08:08:59 <ManateeLazyCat> Peaker: I love Haskell, but my i can't persuade he anyway.
08:08:59 <Peaker> wlangstroth, Well, there is really not a lot of high-visibility software in Haskell yet, but there seems to be an exponential popularity explosion in recent years
08:09:32 <Peaker> ManateeLazyCat, I had a very skeptic friend, but once I got him to start learning it, he liked it a lot.. and now is writing some very cool Haskell libraries :)
08:09:45 <Peaker> well, he's still a friend, but no longer skeptic :)
08:10:08 <thoughtpolice> people seem to enjoy making impossible conditions for 'programming language success'
08:10:28 <ManateeLazyCat> Peaker: Today, i paste screenshot my new Haskell project to replace Emacs (http://www.flickr.com/photos/48809572@N02/), result is "You're crazy...."
08:10:32 <shapr> Some other people just use any programming language that gets close to them.
08:10:32 <wlangstroth> thoughtpolice: that's what it seems
08:10:35 <jmcarthur> i don't see what the obsession with "success" is about anyway
08:10:39 <thoughtpolice> you make hard numbers with companies and known users etc, people think you're making it up or that the usage is too small to justify.
08:10:42 <shapr> And stick with the really fun languages.
08:10:44 <ManateeLazyCat> Peaker: Then i escape #emacs
08:10:51 <monochrom> or be creepy: "there is nuts inside everyone, including you --- one day you will use haskell"
08:10:54 <thoughtpolice> you offer personal antecdotes about productivity/safety/awareness, and you're told they don't ever count
08:10:55 <aristid> ManateeLazyCat: well you ARE crazy if you want to replace emacs :)
08:11:15 <ManateeLazyCat> aristid: And not just Emacs, include firefox, irc-client, everything....
08:11:16 <thoughtpolice> jmcarthur: yes, not even success, 'worthy of usage or consideration' is more appropriate perhaps
08:11:17 <wlangstroth> you guys are trying so hard for a flamewar
08:11:26 <jmcarthur> wlangstroth: ?
08:11:39 <aristid> thoughtpolice: also, java has so good refactoring tools, how could any other language compete?
08:11:44 <wlangstroth> jmcarthur: emacs, c++, etc
08:11:45 <jmcarthur> lol
08:12:00 <ManateeLazyCat> aristid: Please don't said me crazy, it's only place to support me. :)
08:12:08 <quicksilver> ManateeLazyCat: well, you are crazy, but that's OK. Don't stop.
08:12:09 <jmcarthur> wlangstroth: we don't really get flamewars about these things here, strangely
08:12:10 <tab> ManateeLazyCat: definitely a worthy goal ! (replace everything)
08:12:12 <aristid> ManateeLazyCat: it's not the haskell that is crazy, it's the ... size of the project :)
08:12:18 <quicksilver> ManateeLazyCat: it's the crazy ones who change stuff, right?
08:12:33 <jkingkong> Can anybody help me understand the Reflection package? I'm trying to sort out the Implicit Configurations paper and am confused by this Tagged business
08:12:36 <monochrom> it's also the crazy ones who destroy stuff
08:12:42 <jmcarthur> wlangstroth: i suspect people in #haskell are more open to people who have differing opinions
08:12:45 <wlangstroth> jmacarthur: it's amazing - and despite hitting every flamewar button
08:12:58 <quicksilver> monochrom: can't make an omelette...
08:12:59 <ManateeLazyCat> aristid: quicksilver : My word to #emacs: I don't care, it's my dream! :)
08:13:02 <kmc> jkingkong, Tagged is just used to specify a type without passing a value of that type
08:13:05 <Peaker> jmcarthur, Well, high visibility of Haskell would help me write Haskell at work, which would be more fun than Python
08:13:11 <monochrom> we are just a self-congratulating bunch
08:13:23 <Peaker> ManateeLazyCat, Are you writing something like yi?
08:13:25 <jmcarthur> Peaker: wouldn't help me much anyway
08:13:30 <Peaker> jmcarthur, why?
08:13:36 <ManateeLazyCat> Peaker: My aim is very big.
08:13:39 <jmcarthur> Peaker: kernel programming
08:13:42 <jkingkong> kmc: ok so how do I turn a reified type to an actual integer
08:13:43 <Peaker> ManateeLazyCat, Writing a text editor?
08:13:47 <kmc> meaning that values of type (Tagged s b) don't have any more runtime information than values of type b
08:13:55 <ManateeLazyCat> Peaker: It's "Haskell/GTK+ Integrated Live Environment".
08:14:02 * hackagebot HStringTemplate 0.6.4 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.4 (SterlingClover)
08:14:05 <kmc> jkingkong, not sure, it should be in the paper
08:14:08 <ManateeLazyCat> Peaker: Aim is include everything. 
08:14:10 <jkingkong> kmc: in the paper, Oleg has a function modulus _ = reflectNum (_|_ :: s)
08:14:31 <jkingkong> where s has type ReflectNum
08:14:39 <Peaker> ManateeLazyCat, In what sense will it be "live"?  I am writing a project with similar goals (but it seems I'm taking a very different path)
08:14:43 <jkingkong> section 4.1
08:14:57 <jkingkong> how would I implement that using the current reflection package?
08:15:14 <kmc> jkingkong, i think that'd become (unTagged (reflectNum :: Tagged s Integer))
08:15:25 <Peaker> kmc, Why would I want to use tagged, and not a phantom type arg directly?
08:15:36 <kmc> Peaker, what do you mean by a phantom type arg?
08:15:39 <thoughtpolice> jkingkong: here's an example that edwardk put up - http://comonad.com/reader/2009/clearer-reflection/
08:15:46 <kmc> «data Proxy a = Proxy» ?
08:15:49 <ManateeLazyCat> Peaker: It's build with multi-processes framework, you can running every sub-project (eidtor, file-manager, browser.etc) in separate process, more like Haskell/GTK+ OS.
08:16:08 <Peaker> kmc, well, I have:  Transaction m a = ...  and just a couple of hours ago I added "t":  Transaction t m a = ...  as a phantom type
08:16:14 <thoughtpolice> jkingkong: if you look at the previous version, the new one is much less scary :)
08:16:15 <aristid> @hoogle (* -> *) -> *
08:16:15 <lambdabot> Parse error:
08:16:16 <lambdabot>   --count=20 "(* -> *) -> *"
08:16:16 <lambdabot>                 ^
08:16:16 <kmc> Peaker, seems fine too
08:16:17 <ManateeLazyCat> Peaker: I said "Live" is not just for developing like IDE, you can build everything in it.
08:16:21 <jkingkong> haha well
08:16:24 <Peaker> ManateeLazyCat, sounds interesting
08:16:26 <jkingkong> there are no undefined values any more
08:16:41 <jkingkong> but these applicative functions are only marginally better to a haskell noob like myself
08:16:47 <Peaker> kmc, If I had used Tagged t (Transaction m a)  it sounds like I'd have a lot more packing/unpacking to do?
08:16:49 <ManateeLazyCat> Peaker: I have open it's code, haven't release, waiting gtk2hs-0.11.1 relase.
08:16:51 <kmc> Peaker, yes
08:17:13 <Peaker> ManateeLazyCat, What can it already do? Did you write the text editor yourself or did you take an existing editor?
08:17:17 <ManateeLazyCat> Peaker: I am writing a project with similar goals ? Can you explain? Have you do long time?
08:17:19 <jkingkong> thoughtpoli: I don't understand is < *> the same as <*>?
08:17:20 <kmc> Peaker, you're defining a new type of which the phantom tag is semantically a part.  makes sense to include it
08:17:40 <ManateeLazyCat> Peaker: editor, file-manager, pdf-viewer, webkit-browser, currently module.
08:18:00 <Peaker> ManateeLazyCat, Well, just last few months  --  I am working on a structural Haskell editor. The idea is that later it will run the Haskell code as you edit it. Then -- later, that you will use it as a desktop environment and not just an editing environment
08:18:01 <ManateeLazyCat> Peaker: Very basic for test core framework.
08:18:05 <thoughtpolice> jkingkong: yes, edwardk's spacing seems messed up
08:18:14 <kmc> Peaker, users of Data.Reflection want to attach tags to existing types that don't otherwise have them, like Integer, so it makes sense to introduce a new type
08:18:27 <Peaker> kmc, I see
08:18:43 <jkingkong> thoughtpoli: ok thank God I thought it was a bunch of comparisons with partially evaluated applicatives
08:18:54 <ManateeLazyCat> Peaker: I'm developing "Haskell Hot-swapping" for my project, make it can developing itself.
08:19:06 <Peaker> ManateeLazyCat, Hot-swapping?
08:19:09 <thoughtpolice> jkingkong: but aside from applicative, you can do it in monadic fashion, too
08:19:12 <thoughtpolice> jkingkong: just a sec,
08:19:15 <Peaker> ManateeLazyCat, are you hacking on ghc itself for this?
08:19:25 <ManateeLazyCat> Peaker: Modified itself in runtime.
08:19:34 <thoughtpolice> jkingkong: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27448#a27448
08:19:39 <ManateeLazyCat> Peaker: I have code finish this, just need more detail.
08:19:46 <thoughtpolice> jkingkong: the two are equivalent, one using applicative and the other a monad
08:19:50 <ManateeLazyCat> Peaker: "Core hot-swapping" and "plugin hot-swapping".
08:20:06 <Peaker> ManateeLazyCat, Like the way XMonad does it?
08:20:13 <ManateeLazyCat> Peaker: You can develop it like Emacs, but more safely.
08:20:19 <ManateeLazyCat> Peaker: Yeap, but more powerful.
08:20:26 <Phyx-> wow this is just getting weirder and weirder...
08:20:36 <Phyx-> my build.mk says not to build documentations
08:20:41 <Phyx-> yet ghc is trying to build them
08:20:54 <ManateeLazyCat> Peaker: Example, you can running webkit and editor, in the same time, modified core. After you restart new core, everything is same before restart..
08:21:29 <ManateeLazyCat> Peaker: https://patch-tag.com/r/AndyStewart
08:21:34 <Peaker> ManateeLazyCat, what does the core do except execute them?
08:21:42 <ManateeLazyCat> Peaker: I have upload my source code, but haven't mix hot-swapping code.
08:22:24 <ManateeLazyCat> Peaker: You can thinking Core is "Graphics render server" that render graphics from another process
08:22:34 <thoughtpolice> jkingkong: so, if you find that style easier, you could try rewriting edwardk's example (namely just the Monoid instance for 'M')
08:22:41 <ManateeLazyCat> Peaker: Core don't render or compute anything .
08:22:43 <jkingkong> ah i see thanks
08:22:46 <Peaker> ManateeLazyCat, sort of an X server?  btw: you use a lot of open-unqualified imports there
08:23:04 <ManateeLazyCat> Peaker: Just "Graphics redirect" and Window/Tab manage.
08:23:18 <ManateeLazyCat> Peaker: Can you see screenshot at http://www.flickr.com/photos/48809572@N02/
08:23:34 <Peaker> ManateeLazyCat, yeah
08:23:43 <ManateeLazyCat> Peaker: No, i use GtkSocket/GtkPlug with XEmbedded protocol.
08:23:51 <jkingkong> thoughtpoli: this is the most difficult haskell thing i've come across yet
08:23:52 <ManateeLazyCat> Peaker: All my code is base on gtk2hs.
08:24:26 <Peaker> ManateeLazyCat, sounds like a cool/impressive project, good luck :)
08:24:28 <jkingkong> if ever i get it completely figured out, i might try my hand at writing a tutorial on it, since it seems incredibly useful
08:24:40 <ManateeLazyCat> Peaker: In http://www.flickr.com/photos/48809572@N02/ , all window/tab in running plugin-process, core-process just redirect graphics to *one* gtk+ program.
08:25:15 * edwardk waves hello.
08:25:23 <ManateeLazyCat> Peaker: More like Google-Chrome's framework, but more general
08:25:43 <ManateeLazyCat> Peaker: I'm interested your project, maybe we can work together to perfort editor?
08:25:52 <ManateeLazyCat> Peaker: Can you more detail about your project?
08:29:28 <ManateeLazyCat> Peaker: Where you code? Can I have a look?
08:39:43 <slade118> sounds a bit like Yi
08:40:30 <Peaker> ManateeLazyCat, Sorry, was away
08:40:37 <jkingkong> if I do something like a <*> b <*> c
08:40:43 <jkingkong> what order does it happen in 
08:40:49 <jkingkong> or is <*> associative
08:41:06 <ManateeLazyCat> Peaker: What's aim of your project? Maybe we can work together. :)
08:41:09 <edwardk> (a <*> b) <*> c
08:41:21 <Peaker> ManateeLazyCat, My project is at http://github.com/peaker/datastore and http://github.com/peaker/vtywidgets
08:41:25 <danderson> jkingkong: in ghci, import Control.Applicative and run ':i (<*>)
08:41:26 <edwardk> <*> is decidedly not associative.
08:41:35 <danderson> that will tell you, among other things:
08:41:36 <danderson> infixl 4 <*>
08:41:42 <aristid> :i (<*>)
08:41:42 <ManateeLazyCat> Peaker: My project is more like Framework, anyone can add there's gtk+ application in it. Like firefox extension....
08:41:43 <danderson> infix operator, left-associative
08:41:47 <edwardk> just like how (a b) c and a (b c) mean different things
08:42:18 <danderson> the 4 is the precedence of that operator relative to others, which doesn't concern you in this specific case
08:42:18 <jkingkong> right
08:42:24 <edwardk> read <*> like whitespace-based application in haskell and you'll get the right intuition for its associativity
08:42:37 <jkingkong> whitespace-based application?
08:42:49 <Peaker> ManateeLazyCat, The aim of step 1 in plan: A) Create a structural editor for dumb trees (e.g: XML) that is B) always-saved, no "save" button C) scalable for very large trees D) has persistent "undo buffer" that is structural too, and is a revision control E) has good keyboard input support (IMO this rules out current implementations of gtk2hs/wx/etc)
08:42:53 <edwardk> a b c     being a <*> b <*> c
08:42:58 <jkingkong> (i'm just trying to learn the applicative package now)
08:43:06 <edwardk> (being like)
08:43:17 <Peaker> ManateeLazyCat, What I already have: Save-less tree editor that I think can scale at the back-end, but the front-end UI doesn't yet have the necessary features for scalability
08:43:18 <edwardk> @type (<*>)
08:43:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:43:20 <jkingkong> so you read left to right and apply as you go
08:43:36 <Peaker> ManateeLazyCat, There's a persistent undo buffer/version control with explicit branching.  But there's no merging/conflict handling yet
08:43:39 <jkingkong> ok i see
08:43:53 <edwardk> yeah, it takes something wrapped around functions, and something wrapped around values and returns something wrapped around the results ;)
08:44:06 <ManateeLazyCat> Peaker: I always make Emacs save file automatic, i haven't press save keystroke long time... :)
08:44:12 <jkingkong> indeed
08:44:24 <jkingkong> can you think of a simple example of where this is useful?
08:44:32 <jkingkong> learning from the hackage documentation is a little difficult
08:44:34 <edwardk> tons
08:44:39 <jkingkong> haha great to hear
08:44:41 <Peaker> ManateeLazyCat, well, with text files, to "save" is expensive. With my editor, it is very cheap, because it takes a small transaction to write on very small keys
08:45:01 <edwardk> applicative is weaker than monad, but that means a LOT more things can be applicative
08:45:26 <jkingkong> so i should think of f as a container of sorts
08:45:30 <jkingkong> and not as a function?
08:45:30 <Peaker> edwardk, I haven't seen a lot of useful examples yet, though there are probably plenty
08:45:41 <Peaker> jkingkong, do you know Functor?
08:45:43 <ManateeLazyCat> Peaker: So you're bulid "editor abstract structure* that support many frontend?
08:46:02 <jkingkong> functor as in the results commute with a lifting of some sort?
08:46:08 <Peaker> ManateeLazyCat, Maybe :) currently I'm using vty later I intend to use OpenGL/SDL to render
08:46:36 <ManateeLazyCat> Peaker: Use Haskell/OpenGL build your desktop environment?
08:46:42 <Peaker> jkingkong, not sure what you mean by that :) I just mean: class Functor f where fmap :: (a -> b) -> f a -> f b  and the associated laws (in Haskell, just one law is needed: id = fmap id)
08:46:45 <edwardk> an example of something that is applicative is the notion of a 'zip list' which is an applicative list-like instnace that uses the infinite list of repetititions of a given value as its 'pure/return' and which applies the function in a given position to the element in the same position as its <*>
08:46:51 <Peaker> ManateeLazyCat, the editor, which will later be the desktop, ya
08:47:04 <edwardk> you can show that there isn't a monad that goes along with that variation
08:47:16 <Peaker> jkingkong, Do you have a good idea of who can be a valid instance of Functor in Haskell?
08:47:40 <ManateeLazyCat> Peaker: Editor is desktop, i can't understand, do you have any screenshot i can take a look?
08:47:41 <Peaker> I think it would be correct to say: All types whose sole type-parameter appears only in "positive" positions in the type can be valid functors
08:47:44 <edwardk> jkingkong: yes the intuition of f being a container is a pretty good one
08:47:57 <Peaker> ManateeLazyCat, It's not a desktop yet, I want it to be a desktop later.. Did you watch conal's Eros tech talk?
08:48:00 <jkingkong> peaker: i guess maps are functors
08:48:11 <ManateeLazyCat> Peaker: No.
08:48:42 <ManateeLazyCat> Peaker: Since my project's aim more like Gnome -- a (desktop) environment.
08:48:56 <ManateeLazyCat> Peaker: But use keyboard control everything.....
08:48:56 <edwardk> Peaker: you can make some pretty powerful applicative parsers, becase without the flexibility of monad, you can say more about what the next match will be
08:49:02 <EvanCarroll> jkingkong: they're one example of a functor
08:49:11 <Peaker> ManateeLazyCat, http://www.youtube.com/watch?v=faJ8N0giqzw -- something like this
08:49:27 <jkingkong> i'll admit my understanding of them is fairly theoretical
08:49:32 <jkingkong> and not very practical at this point
08:49:44 <Peaker> edwardk, Yeah, I want an Applicative parser (Applicative is not enough, need some more combinators) that builds a an automaton
08:49:59 <Peaker> jkingkong, I don't know CT, just the Haskell side of things
08:50:03 <harlekin> How would you line-break a string every n characters?
08:50:15 <Peaker> jkingkong, do you know what it means for a type expression to be "positive" or "negative"?
08:50:25 <jkingkong> no i've never heard that before
08:50:33 <jkingkong> CT?
08:50:39 <jkingkong> category theory
08:50:40 <jkingkong> ah
08:50:49 <noteed> harlekin: have a look at how break is implemented
08:50:50 <edwardk> Peaker: well, the applicative version is strictly more powerful than an nfa/dfa, so you need to be careful about your choice of automaton, you effectively get a 'codata context-free attribte grammar'
08:50:52 <jkingkong> i've done some abstract algebra, so that's where i'm coming from
08:51:06 <slade118> harlekin: take a string, splitAt it at n, add in a new line, repeat on the second part of the tuple
08:51:16 <zygoloid> kmc: (continuing earlier discussion) yeah, i certainly think that haskell protects you from your coworkers writing terrible code better than c++ does
08:51:18 <Peaker> jkingkong, In the type  ((a -> b) -> (c -> d))   we can say that we give an (a->b) so its "negative", and we get (c->d) so it's positive.  The "a" is doubly-negative, so we get an "a". So a+ b- c- d+
08:51:30 <edwardk> i use some tricks to recover sharing info so i can eliminate the 'codata' piece, which lets me recover the underlying context-free grammar with some additional epsilon transitions for managing the annotation
08:51:40 <monochrom> if I write "blahblah->X", X is in a positive position, blahblah is in a negative position.
08:51:46 <Peaker> jkingkong, so func-args are negative, most everything else is positive
08:51:53 <Peaker> jkingkong, but negative inside a negative is a positive again
08:51:53 <harlekin> noteed, slade118: thanks. I thought I could write it shorter. My manual recursion isn't longer than it would be with splitAt I guess.
08:51:54 <jkingkong> peaker oh i see
08:52:17 <edwardk> jkingkong: newtype Fun a = Fun (Int -> a) -- can be made into an instance of Functor
08:52:17 <ManateeLazyCat> Peaker: Youtube broken with GFW, my proxy tool can't work now. unfortunately
08:52:18 <monochrom> more fun is "(X->blahblah)->stuff", blahblah is in a negative position, X is in a positive position.
08:52:22 <Peaker> jkingkong, So what parameterized-types (of kind *->*) can be Functors?   Those who use the parameter only in positive positions
08:52:26 <edwardk> newtype Pred a = Pred (a -> Bool) -- cannot
08:52:43 <jkingkong> peaker: that's very interesting
08:53:01 <Peaker> jkingkong, Those that use it only in negative positions can be CoFunctors (which have cofmap :: (b -> a) -> f a -> f b)
08:53:31 <Peaker> jkingkong, those that have it in both need two functions there (maybe a bijective one?) but those are out of our scope :)
08:53:48 <ManateeLazyCat> Peaker: LIke this ? http://docs.google.com/viewer?a=v&q=cache:inJjz3ITZ2gJ:conal.net/papers/Eros/eros.pdf+&hl=zh-CN&pid=bl&srcid=ADGEESgcp2N8JRk7pqAscUY-Q01394l-NZWsh1jlItTNU_qsBqIV9FMkY7iP0SCRajNLSaMpLSCjYMcPYbi6bUswJkCZZDxIHIjas_2T-rI1uzEOdwXre5RUM2TN598v7mCa2r44rexF&sig=AHIEtbQPZAxC8Ai_IMl68du88-r1LyNmTg
08:53:59 <jkingkong> edwardk: ok I understand your example i think
08:54:09 <edwardk> Peaker: contravariant functor or contrafnctor, please. cofunctor = functor. flipping the arrows: (a -> b) -> (f a -> f b)    yields (b -> a) -> (f b -> f a) which is alpha equivalent to the original!
08:54:11 <Peaker> jkingkong, So (a ->) is a Functor, and (-> a) is a CoFunctor.. see why?
08:54:24 <Peaker> edwardk, Not my fault, I saw the class named CoFunctor :)
08:54:26 <jkingkong> oh gosh i haven't seen contravariance and covariance in forever
08:54:28 <edwardk> er contrafunctor
08:54:32 <jkingkong> i can't believe i'm seeing it here
08:54:39 <jkingkong> my head a splode
08:55:23 <jkingkong> their composition is an identity of sorts?
08:55:40 <Peaker> jkingkong, Try to implement contrafmap and fmap for (a->) and for (->a) and see why positivity matters
08:56:01 <edwardk> Peaker: those (the ones that need two functions) are just functors over a different category, the category of isomorphisms or bijections over hask. see ExpFunctor in category-extras for a practical version
08:56:05 <Peaker> jkingkong, do you know what I mean by (a->) and (->a) ?
08:56:22 <jkingkong> yea i'll admit I'm a litle confused on that point
08:57:10 <edwardk> jkingkong: what he means is you can write an instance Functor ((->) a) where fmap = (.)
08:57:20 <Peaker> jkingkong, (a -> b) in Haskell is the function from "a" to "b". But it is really just sugar for (->) a b.   Just like we have value sections like (/ 5)  (divide by 5) we imagine we have sections for type operators like (->)   so (->a)  means a type constructor that given a type, returns a function from that type to "a"
08:57:33 <Peaker> ((->) a) = (a ->) with nice section syntax
08:57:34 <edwardk> if you read (a -> b) as (->) a b that makes more sense
08:57:35 <harlekin> slade118, actually using splitAt is shorter. (-: Thanks again.
08:58:02 <edwardk> sadly the (a ->) partial application syntax doesn't work at the type level =/
08:58:07 <jkingkong> guys i'mma get some lunch
08:58:13 <jkingkong> with some coworkers
08:58:23 <monochrom> eat them
08:58:25 <Peaker> edwardk, I keep wondering why Haskell designed type-level syntax differently from the value-level, given that they are so similar
08:58:40 <monochrom> to give you less power
08:59:01 <edwardk> well, sectioning at the type level is problematic. you can't use it everywhere. i.e. i can't define instance Foo (-> a) and instance Foo (a ->) -- so this enforces a level of uniformity
08:59:04 <monochrom> oh, but mere sectioning does no harm...
08:59:25 <monochrom> oops
08:59:33 <edwardk> monochrom: well, right sectioning doesn't
09:01:15 <quicksilver> Peaker: I don't think the syntaxes are different.
09:01:20 <quicksilver> and I think that is a virtue of haskell.
09:01:30 <quicksilver> it's simply that lambda is omitted from type-level
09:01:39 <quicksilver> (because it has serious consequences)
09:01:45 <quicksilver> and sections are just sugar for lambda.
09:01:58 <quicksilver> You could allow left sections, but that would seem odd in the circumstances.
09:02:40 <ManateeLazyCat> Peaker: I'm playing your vtywidgets-example...
09:03:26 <zygoloid> Currently you can write: type LeftS a = (->) Int a; type RightS a = (->) a Int. with TypeSynonymInstances you can then give instances for LeftS but not RightS. i don't see how allowing type operator sections would be different, really...
09:04:02 <ManateeLazyCat> Peaker: I implement same features base on GtkTextBuffer.
09:04:33 <quicksilver> zygoloid: it's not just instances, although they are the most obvious place to notice.
09:04:50 <quicksilver> zygoloid: Rights Int won't unify with f a in a signature at all
09:04:57 <quicksilver> even if it's not a class or method
09:05:20 <quicksilver> zygoloid: so in some sense RightS Int isn't a first-class type, since it can't participate in unification.
09:05:32 <quicksilver> it's more like a syntax macro.
09:05:51 <edwardk> zygoloid: type synonyms can't be used in instance and class declarations (in haskell 98)
09:05:57 <zygoloid> quicksilver: that's true (and indeed i think GHC implements it as such)
09:07:01 <quicksilver> edwardk: but, as I just outlined, the class instance thing is a distraction.
09:07:20 <quicksilver> edwardk: the point IMO is more that, not being type constructors, type synonyms can't unify with types like (f a)
09:07:21 <dolio> You cannot declare an instance for just "LeftS".
09:07:28 <dolio> LeftS must be fully applied.
09:07:56 <zygoloid> dolio: yeah, i was just playing with that. apparently GHC doesn't try to eta-reduce
09:08:03 <edwardk> quicksilver: sure. type synonyms are just a form of type-level macro expansion
09:08:10 <dolio> You'd have to declare it "type LeftS = (->) Int".
09:08:25 <quicksilver> edwardk: (it just happens that we hit this most often with with classes because it's in classes Monad and Functor that we most often find higher-kinded unifiers)
09:08:50 <quicksilver> edwardk: higher-kinded unification without a class context hanging around is fairly unusual in practice.
09:09:24 * zygoloid would be pretty happy with (a ->) being treated as a type constructor, equivalent to (->) a, and (-> a) being treated as an indexed type family
09:09:42 <edwardk> basically where i was going with my statement was where dolio took it, by explaining that you need to manally eta-reduce your type synonyms to use them in instances, and it'd be rather difficult to explain why instance Foo (a :-) was ok but instance Foo (:- a) wasn't
09:10:05 <zygoloid> that'd be harmonious with how GHC treats infix operators with -XPostfixOperators
09:10:29 <jmcarthur> conal: nice blog post! i really would like to see a nice amb implementation in the rts some day
09:10:33 <ManateeLazyCat> Peaker: Hmm, looks your build a editor structure on vty code.
09:10:46 <conal> jmcarthur: thx!
09:10:53 <zygoloid> edwardk: i don't think that's any harder than explaining why the inner type has to be the last type parameter for a type constructor to be a monad
09:10:58 <zygoloid> s/inner/rightmost/
09:11:20 <zygoloid> or not :o
09:11:30 <conal> jmcarthur: i'm guessing compelling uses of lub might come first.  motivating a solid & fast rts-based implementation.
09:12:10 <zygoloid> conal: i have some evilness in progress which'd allow you to implement lub without a typeclass constraint :o
09:12:21 <ManateeLazyCat> Peaker: My event library http://patch-tag.com/r/AndyStewart/manatee-core/snapshot/current/content/pretty/Manatee/Toolkit/Gtk/Event.hs , more like your Keymap.hs do, but base on gtk2hs.
09:12:37 <conal> zygoloid: oh?
09:13:00 <Peaker> ManateeLazyCat, Well, it's not very vty-specific
09:13:02 <zygoloid> conal: it's a vacuum-like library for allowing heap introspection
09:13:12 <Peaker> ManateeLazyCat, Later I want to make it agnostic and either run on OpenGL or vty
09:14:06 <edwardk> conal: can you get away from the requirement that the argument type be flat by simply requiring something like an NFData instance for it?
09:14:34 <conal> edwardk: which requirement of flatness?
09:14:54 <edwardk> "    * We know how to strictly memoize over Bool (i.e., what shape to use for the memo table and how to fill it).     * Bool is flat."
09:15:05 <edwardk> "The second condition is terribly restrictive and fails to hold for sums, products and most algebraic types (e.g., Maybe and [])."
09:15:40 <jmcarthur> i wasn't under the impression that that was a requirement
09:15:41 <edwardk> nfdata is probably the wrong vehicle for handling [] but it could likely deal with Maybe 
09:16:13 <jmcarthur> isn't non-flatness the reason we use tries for memoization so often?
09:16:22 <edwardk> ah i just read farther ahead, i think i may have misparsed your point =)
09:16:24 <harlekin> @pl map (\p -> (p, ' ')) ps
09:16:25 <lambdabot> map (flip (,) ' ') ps
09:16:45 <conal> jmcarthur: yes.  nonflatness motivates tries.
09:17:43 <edwardk> conal: heh you could steal my unsafeIsEvaluated check to see if the argument is known to be non-bottom and skip the fork in that case
09:18:06 <conal> edwardk: might be a big help.
09:18:53 <edwardk> then if someone calls your memoized function using $! it'll fall back on fairly conventional behavior
09:19:05 <jmcarthur> if sparks could interrupt a thread then i think we could use the spark queue for an amb primitive, as long as we can keep the spark from being GCed unless the thread evaluates the other value before the spark finishes
09:19:06 <Phyx-> wow... the average income for a programmer/software engineer is quite disappointing
09:19:32 <edwardk> conal: http://hackage.haskell.org/packages/archive/speculation/0.9.0.0/doc/html/src/Control-Concurrent-Speculation.html#unsafeIsEvaluated
09:19:44 <conal> edwardk: thx
09:20:12 <edwardk> conal: keep in mind you may get false negatives, but that is semantically sound for your needs
09:20:14 <jmcarthur> GHC HEAD's GC even kills sparks if they are no longer needed, iirc, so that part would be done already
09:20:50 <ksf> TH has a very big, very fundamental problem that makes it a pita in large projects
09:20:52 <conal> jmcarthur: wow.  maybe the environment for implementing lub/unamb is getting friendlier.
09:21:02 <ksf> ...you can't refactor anything around it automatically
09:21:30 <ksf> a rewrite system would be _way_ more amendable to analysis.
09:21:33 <edwardk> jmcarthur, conal: you need to be careful though, because sparks have no guarantee they'll run at all. under load they just get silently dropped
09:21:39 <jmcarthur> yeah
09:21:50 <jmcarthur> can't use sparks as the only means of evaluation
09:22:12 <Twey> Ew
09:22:33 <Twey> What happens if you attempt to use a value that was to be evaluated by a dropped spark?
09:22:36 <sm> morning all
09:22:46 <edwardk> you might be able to make some crazy unamb that sparked the two computations, and then when forced checked to see if one or the other was done and returned it, otherwise did the heavier fork
09:22:49 <jmcarthur> Twey: well, presumably that wasn't GCed
09:22:55 <conal> i'm waiting for someone who gets these rts issues (which i don't) to be inspired to work on a new unamb implementation.  would be happy to collaborate.
09:23:05 <edwardk> that way you use the spark speclatively, and it degrades gracefully under load
09:23:15 * sm wonders if he missed a yesod 0.4 announcement
09:23:18 <ManateeLazyCat> @tell So you project like a real-time edit/execute editor?
09:23:18 <lambdabot> Consider it noted.
09:23:21 <edwardk> i might hack one up and see if it performs
09:23:28 <ManateeLazyCat> @tell Peaker So you project like a real-time edit/execute editor?
09:23:28 <lambdabot> Consider it noted.
09:23:31 <Twey> jmcarthur: Then why does it matter whether it's evaluated?
09:23:39 <c_wraith> sm: it was announced yesterday
09:23:54 <sm> c_wraith:  on haskell-cafe ?
09:24:12 <c_wraith> sm: oh, no.  just on his blog.  and picked up on reddit.
09:24:19 <sm> aha, thanks
09:24:20 <jmcarthur> Twey: well, what we are talking about *might* require that a spark actually inject a value into a reference somewhere, which is different from normal spark functionality
09:24:30 <sm> I have been good and left my feed reader closed for a day
09:24:40 <sm> see what happens...
09:26:04 <edwardk> jmcarthur: well, you can unsafePerformIO to hack up some mvar, that the reference you're injecting points to
09:26:53 <jmcarthur> edwardk: right, but that's exactly the situation in which we don't want sparks to be dropped
09:29:18 <edwardk> afk a bit
09:39:21 <Phyx-> is it possible to only recompile base?
09:40:37 <ksf> is there a metacircular, typed rewriting system?
09:41:30 <djahandarie> is it possible to save money on my car insurance?
09:41:53 <dschoepe> Could it be that hoogle's --include option is broken? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27450#a27450
09:42:04 <arw> yes, using haskell enables you to claim safer driving bonus.
09:42:07 <Phyx-> by switching to geico?
09:44:01 <djahandarie> I rewrote my car's ECU in Haskell :)
09:47:28 <arw> djahandarie: that would really be a desirable feature. current techniques for ECU design are more along the lines of "build a mathematical model in matlab, generate C, fiddle on that C till it works, add an operating system lib, ship it"
09:48:22 <tg_zzz> conal: how cute - Our use of ? requires the result type to be ?-able.
09:48:24 <arw> djahandarie: replacing the "generate C, fiddle on that C" with "generate side-effect-free haskell, fiddle on that haskell, verify against model" would really be something.
09:48:27 <tg_zzz> lub-abl
09:48:29 <tg_zzz> lub-able
09:50:20 <ksf> arw, there's atom for such things
09:50:26 <ksf> it's not side-effect free, though
09:50:52 <ksf> what were they called synchronous languages or something
09:51:20 <ksf> ...where procedure invocation depends on timecodes
09:52:06 <ksf> ...making it easy to say "do this once every 100ms" and actually have the compiler check that the deadline is hit reliably.
09:52:47 <arw> ksf: yes, that stuff is often used for real-time systems. problem is, in automotive they often use "cheaper" systems where they just count how many cpu-cycles their C-code needs.
09:53:19 <ksf> I did that once in microcontroller class.
09:53:27 <arw> ksf: so that they can load an ECU with as much code as possible while still guaranteeing response times on interrupts.
09:54:04 <ksf> ...measuring signals on an oscilloscope with a ruler and then add or remove a few cycles of the wait loop...
09:54:37 <arw> yep. you wouldn't want to know how many real systems still work that way.
09:55:01 <ksf> in the end, we got a true, hard real-time system that did the awesome job of talking to an ir sensor and generating a square tone based on a table lookup based on the measured distance.
09:55:54 <ksf> ...all that written in an obscure microcontroller assembly that didn't even have _multiplication_
09:56:47 <arw> i know. and 8 bits, and 64 bytes of ram, some flash and a weird memory model...
09:57:30 <ksf> a proper design would have been to multiplex each deadline "wait 1ms then pull that port hi" onto the two or three hardware timers.
09:58:28 <ksf> the problem we were struggling the longest with was that the lecturer didn't think of telling us that you have to set a port to 1 before you can ever read anything but a 0 from it
09:59:20 <ksf> ...by the time he told us our prototol timing was so throughly debugged it worked on first try.
10:01:10 <ksf> oh I think it was capable of adding 16 bits at a time
10:01:19 <arw> ksf: yep. and now imagine that with a buggy and hopelessly outdated 3 page din a4 datasheet from the processor manufacturer and their developers not having a clue.
10:02:08 <kmc> why do embedded systems classes use awful weird poorly documented hardware
10:02:09 <ksf> well it's not like the datasheet of the ir sensor gave the correct values for distances.
10:02:22 <ksf> ...their curve was non-linearly off.
10:02:30 <kmc> everything we did in 10 weeks in assembly on a big custom board with an 80188 and a dozen other chips
10:02:39 <kmc> could be done in about 3 weeks on a single chip AVR board in C
10:02:50 <ksf> such things should be done with beagle boards by now.
10:03:04 <ksf> ...arms are actually quite nice from all I heard
10:03:19 <kmc> AVR are fantastic and quite simple
10:03:24 * djahandarie hasn't taken a class like that yet
10:03:26 <kmc> i'm sure ARM are nice too, if you need the extra power
10:03:40 <ksf> well it's not like they would be expensive.
10:03:49 <ksf> ...the low-end ones.
10:03:51 <arw> AVRs are quite nice, yes, especially since there are some smaller but still usable models.
10:04:03 <arw> ARM is somewhat too big for most stuff..
10:04:04 <djahandarie> I've actually only taken one CS course at my university so far. -_-
10:04:43 <Cale> I only took 2 in my whole undergrad.
10:04:45 <ksf> heck I keep on having the thought of founding a cs school.
10:05:35 <djahandarie> Cale... computer science undergrad?
10:05:38 <djahandarie> How'd you do that?
10:05:43 <Cale> djahandarie: No, pure mathematics :)
10:05:48 <ksf> one could start out with a hacker space and then extend it to give classes
10:05:51 <djahandarie> Ah, figures
10:06:08 <Cale> One was a silly course on OOP in Java designed to appease potential employers of co-op students (which I was not). The other was actually pretty cool.
10:06:27 <ksf> I bet there's a wide audience that would be thankful. like ricers wanting to control their light show.
10:06:48 <djahandarie> Yeah, I took that silly OOP class too. :-(
10:07:13 <sproingie> they probably control their light show with a laptop and x10 controllers
10:07:30 <ksf> our oop course actually made sense, in the sense that I heard it was impossible to pass the exams (and then got an A)
10:07:52 <ksf> ...that's what you get when you tell a functionally-inclined prof to teach java.
10:07:57 <djahandarie> Heh
10:08:27 <djahandarie> Or just someone that has the slightest clue about programming languages
10:08:39 <Cale> It was a bit haphazard, but our second course was primarily about parsing (with lots of good stuff about finite state machines and annotated syntax trees) and compilation (we all wrote a toy compiler which compiled a small imperative language into DLX assembly, which, if you can believe it, is a cut down version of MIPS)
10:09:00 <djahandarie> Neat
10:09:05 <Cale> But then they threw in some stuff at the end about scheme. :)
10:09:13 <heiz> hi! Tell me please why programming languages have reserved words.
10:09:19 <djahandarie> Seems like that course was all over the place
10:09:23 <ksf> the exam was filling out the method bodies of a couple of given classes and answer a few questions
10:09:35 <Cale> and there was an ongoing expectation that everyone learn the basics of unix (which I had no problem with, since I'd been using linux for a while by that point)
10:09:52 <arw> heiz: because parsing them would be much harder without?
10:09:57 <Jafet> heiz: because the people inventing them decided to reserve words in them
10:10:01 <ksf> ...it was an implementation of a linked list, and object dispatch was used for pattern matching.
10:10:31 <ksf> ie. Null.length = return 0; Elem.length = return 1 + tail.length
10:10:58 <Cale> heiz: It's important, when the compiler reads a piece of code, for it to be able to tell clearly where certain constructions begin and end.
10:11:18 <ksf> I seriosuly _don't_ know how one can possibly fail to implement such a thing as it's algorithmically trivial, but then people fail fizzbuzz, too.
10:11:31 <ksf> probably people aren't flexible enough about their code
10:11:57 <djahandarie> It's also hard to write code without a compiler imo
10:11:59 <ksf> thinking that each traversal has to be and absolutely has to be a loop because that's the way they did it before.
10:12:09 <ksf> he wasn't checking syntax
10:12:48 <Cale> heiz: So languages have syntax which uses certain words as markers to identify those various constructions.
10:13:02 <arw> ksf: i know many non-CS undergrads with problems understanding loops, let alone scary stuff like recursion...
10:13:20 <djahandarie> Not understanding loops...?
10:13:55 <edwardk> conal: still about?
10:14:07 <ksf> while (there is beer) { bottle beer = take_beer_from_box; drink beer }
10:14:24 <ksf> how can any undergrad possibly _not_ understand that?
10:14:26 <kmc> ashes to ashes, beer to pee
10:14:30 <arw> djahandarie: stuff like always writing a while(true) and using if(...) break; because they didn't really understand that while has a condition it checks.
10:14:34 <edwardk> @hpaste
10:14:34 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:14:44 <kmc> i interviewed senior software engineers, 20+ years industry experience, who could not implement a function to get the nth fibonacci number in C
10:14:58 <ksf> some people mix up syntax and semantics
10:15:03 <djahandarie> lol...
10:15:12 <alexbobP> I like to funroll my loops.
10:15:12 <kmc> i also interviewed recent graduates from CS undergrad, good schools, good GPAs, who thought a computer was a machine for executing Java source code
10:15:14 <zygoloid> whileM (any =<< beer) { beerBottle <- takeFromBox beer; drink beerBottle }
10:15:15 <djahandarie> Maybe they didn't know the fibonacci sequence?
10:15:24 <djahandarie> Haha zygoloid
10:15:30 <kmc> djahandarie, it was given on the test
10:15:31 <edwardk> @tell conal http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27451#a27451 (though, i'd probably just replace the Data.Unamb with it directly)
10:15:31 <lambdabot> Consider it noted.
10:15:38 <arw> djahandarie: and "if that condition later is true again, why doesn't it reenter the loop?"
10:15:44 <zygoloid> advanced students may prefer to cut out the middle-man: whileM (any =<< beer) (drink =<< takeFromBox beer)
10:16:11 <djahandarie> You forgot do in the first one :P
10:16:19 <djahandarie> Wait
10:16:29 <djahandarie> Can you use {} without do?
10:16:30 <zygoloid> djahandarie: yeah. that was an exercise to the reader ;-)
10:16:32 <djahandarie> Ah lol
10:16:35 <edwardk> @tell conal i'm also perfectly happy to factor unsafeIsEvaluated into a separate more minimal package
10:16:35 <lambdabot> Consider it noted.
10:16:40 <Jafet> Syntax errors are not penalized!
10:16:42 <kamatsu> i thought of a cool idea for an esolang
10:16:53 <ksf> in the very basic programming lecture (which used pascal), the lecturer got to length to forcing us to understand what EBNF is, and how to draw flow diagrams.
10:16:56 <kamatsu> a functional language that isn't lazily or strictly evaluated: it's randomly evaluated.
10:17:05 <djahandarie> Haha
10:17:14 <Jafet> kamatsu: see Whenever
10:17:16 <kamatsu> every second or so it evaluates a random thunk
10:17:17 <ksf> I bet it was meant to get that syntax/semantics difference into our minds.
10:17:18 <edwardk> kamatsu: i've implemented it ;)
10:17:21 <zygoloid> edwardk: might be interesting to make it follow StgInd's too
10:17:51 <kmc> kamatsu, haha
10:17:58 <edwardk> zygoloid: those still yield True, as long as the gc has had time to find them, remember?
10:18:11 <kmc> kamatsu, should be safe to program it assuming strict semantics
10:18:19 <zygoloid> edwardk: you mean, they yield True if they don't exist? ;-)
10:18:19 <kamatsu> yeah
10:18:24 <edwardk> not worth provoking a minor gc for each unamb or the cure is worse than the disease
10:18:36 <kamatsu> although you might get some inexplicable delays while you wait for your particular thunk to be eval'd
10:18:39 <edwardk> no, we went over this last time remember? =)
10:19:11 <zygoloid> edwardk: my recollection must differ from yours. i thought we agreed you'd get false negatives from them.
10:19:32 <zygoloid> (because an StgInd* is not tagged)
10:19:59 <zygoloid> but that GC would remove the StgInd's, leaving a correctly-tagged pointer
10:20:02 * edwardk rolls up his sleeves for the review ;)
10:20:26 <edwardk> yes, but performing a GC here would wipe out any performance win
10:20:38 <zygoloid> edwardk: sure. so instead of doing that, follow StgInd's.
10:20:47 <edwardk> i can't, i'd need to know what they are
10:21:02 <zygoloid> it'd require you looking inside the info table to find out they are ind's, and knowing how they're laid out in memory
10:21:22 <edwardk> yes, all of which is very tempermental, subject to variation based on if profiling is on, etc.
10:22:09 <zygoloid> edwardk: indeed, it's non-trivial. i have some code to parse the right offsets out of the RTS includes :)
10:23:16 <BMeph> So, has anyone ever tried out Anastasia (http://dream.inf.ed.ac.uk/projects/anastasia/ )?
10:23:25 <edwardk> zygoloid: not something i'd want a lot of production code riding on though. and what we concluded was that you'll never get a true result that turns false during gc, merely things that haven't yet been tagged due to the fact that they are a different reference to the known value than the one that you computed.
10:24:06 <zygoloid> edwardk: right. it's just one of many sources of false negative.
10:24:36 <Jafet> <alis> (notice) #learnanycomputerlanguage                            2 :Learn Any Computer Language! But we recommend: Haskell!
10:24:41 <Saizan> BMeph: sounds like what Peaker wants to build
10:25:40 <BMeph> Saizan: Yeah, I was looking over the log, and saw the convo earlier.
10:35:00 <zygoloid> BMeph: wow, they give a 27-step example which constructs a 26-token program ;-)
10:37:26 <BMeph> zygoloid: Now, THAT's dedication! ;)
10:41:38 <hpc> seeing them tell you to run "Haskell.pl" is distracting
10:42:54 <edwardk> zygoloid: hrmm, i do wish i could have a counter that ticks with each minor gc
10:43:05 <noobskell> hi 
10:43:45 <tommd> Does Rochel hang out here?  (graph-rewriting author)
10:44:10 <noobskell> I want to have a map passed as state to some functions, in some of which I need to put some random numbers in the map 
10:44:27 <noobskell> do I need to use monad transformers, or is there an easier way?
10:45:22 <ksf> you could write the monad from scratch
10:45:29 <ksf> or pass the map around manually
10:45:33 <canvon> if you use a pseudo-random number generator as state, it won't need to be wrapped in IO; so no monad transformers needed
10:45:43 <kmc> by "put in" you mean destructive in-place update?
10:45:50 <dolio> zygoloid: That example looks awful. :)
10:45:52 <tommd> If you want random numbers + state then you might want to use StateT + MonadRandom, so yes a transformer would be a reasonable solution but not the only one.
10:45:55 <kmc> noobskell, you can do the whole thing in the IO monad
10:46:12 <ksf> kmc, shhh.
10:46:39 <kmc> you're never required to use monads; you can always do what they do by explicitly passing stuff around
10:47:03 <ksf> noobskell, try this:  http://stackoverflow.com/questions/2110535/sampling-sequences-of-random-numbers-in-haskell 
10:47:06 <kmc> the small exception are magical built-in monads like IO, but even then you can ignore the general "Monad" interface and treat it as a single concrete type
10:47:20 <noobskell> kmc, I know that
10:47:37 <noobskell> but why should I?
10:47:42 <kmc> why should you what
10:47:47 <ksf> wait no that's the wrong one.
10:47:49 <djahandarie> Unforunately the exception is the most frequently used monad
10:47:53 <noobskell> I mean don't they result in a cleaner codE?
10:48:01 <kmc> monads? yes, often
10:48:11 <kmc> i'm just saying that the question "do I need to use monad transformers" is probably the wrong question
10:48:20 <kmc> compared to "will my code be cleaner if I use monad transformers"
10:48:27 <noobskell> so, what I would like to know is how a haskell guru would go about this. learning opportunity if you will
10:48:41 <kmc> noobskell, probably StateT + MonadRandom
10:48:58 <noobskell> ok, now here is my concern about this solution
10:49:05 <conal> djahandarie: i'm guessing [] is more frequently used than IO in haskell
10:49:06 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:49:09 <kmc> "how would a guru do it" is also a different question from "is there an easier way" -- the guru may choose the way that's harder but cleaner, more maintainable, etc
10:49:15 <ksf> erm no there's actually no such post.
10:49:24 <djahandarie> conal, usually not the monad interface to it though
10:49:33 <noobskell> lets assume that the programmer has developed its code without any transformer stack, because at its inception there was no need for the random number stuff
10:49:43 <conal> djahandarie: ah.  via Monad.
10:49:53 <kmc> noobskell, how are you handling state?
10:50:05 <noobskell> Control.State.Monad
10:50:07 <conal> djahandarie: used to be much more common, when comprehension was a monad thing
10:50:07 <noobskell> not StateT
10:50:13 <kmc> ok.  so one monad, but no transformers
10:50:21 <ksf> StateT + MonadRandom is the way to go. if necesarry performance-wise, roll your own monad, which doesn't touch the actual code that uses it.
10:50:25 <noobskell> that's exactly my question
10:50:37 <kmc> State -> StateT refactor should be easy, because most of the interface to State is overloaded in a typeclass that StateT also supports
10:50:40 <noobskell> I am wondering if it is always a good idea to go with StateT rather than just State
10:50:50 <noobskell> because it's very likely that we need to mix some IO stuff too
10:50:58 <kmc> noobskell, there are alternatives to mtl that implement each "base" monad as a transformer over identity
10:51:00 <ksf> noobskell, State _is_ StateT Identity.
10:51:08 <kmc> fsvo "is"
10:51:09 <Cale> noobskell: Other people will disagree with me, but I think StateT over IO is overkill.
10:51:13 <kmc> less so in mtl than in others
10:51:15 <noobskell> oh!
10:51:24 <Cale> noobskell: IO is big enough. Transforming it further is usually silly.
10:51:26 <djahandarie> conal, right. But even with comprehensions I'd say the Monad functions are used most frequently in IO. That's what originally confused me about monads, I thought they were magical ;)
10:51:46 <dolio> kmc: I think monadLib is like that. transformers may be, as well.
10:51:46 <noobskell> Cale, would like to hear your proposal
10:51:49 <Cale> Particularly transforming it with StateT. ContT maybe, if you're really being fancy.
10:51:55 <conal> djahandarie: yeah.  a lot of people think Monad has to do with IO (which *is* magical/non-denotational)
10:52:03 <Cale> But if you're going to use StateT, consider just using an IORef.
10:52:22 <Cale> Or if you're generating random numbers in IO, well, there's nothing to do.
10:52:22 <conal> i think calling IO "the IO monad" compounds this confusion.
10:52:39 <dolio> If you're considering StateT, IORef isn't a lot better.
10:52:41 * djahandarie nods
10:52:42 <Cale> randomRIO is your friend then.
10:52:49 <ksf> noobskell, the trick is to write your type annotations in a generic way, so you can switch the backing monad implementation without touching the code.
10:52:55 <noobskell> most of my code is not being run inside IO, 
10:52:58 <conal> considering that we don't usually say "the list monad" or "the paired monad", etc. 
10:53:03 <Cale> dolio: Well, it does mean that you don't have to awkwardly lift every one of your IO actions :)
10:53:13 <kmc> conal, in my experience people say "the list monad" and "the state monad"
10:53:14 <dolio> Yeah, that's true.
10:53:24 <dolio> But you have to pass around an IORef everywhere.
10:53:32 <kmc> IORef and State are also very different approaches to implementing state, operationally
10:53:34 <ksf> that is, never do foo :: State Bar (), but foo :: MonadState Bar m :: m ()
10:53:36 <conal> kmc: under what conditions do you notice people saying "the list monad"?
10:53:37 <Cale> noobskell: What I'd normally recommend as the usual thing to do if you need a source of random numbers, is just to pass in a StdGen as a parameter to the computation.
10:53:58 <conal> kmc: maybe when they mean nondeterminism.
10:54:10 <noobskell> yes, I understand Cale, actually thought about it
10:54:12 <Cale> noobskell: and keep the thing a pure function
10:54:14 <kmc> conal, yes
10:54:33 <flazz> how can certain functions like fromJust raise an exception? i was under the impression that it was a pure function? what am i missing?
10:54:42 <kmc> > error "foo"
10:54:43 <Cale> flazz: It's a partial function.
10:54:44 <lambdabot>   *Exception: foo
10:54:45 <kmc> :t error "foo"
10:54:47 <lambdabot> forall a. a
10:54:48 <noobskell> but something told me that this will soon be a recurring pattern in my code, not just for randomIO, but for many other things 
10:55:01 <zygoloid> flazz: every value in haskell can be "bottom" or _|_ (an error value)
10:55:03 <kmc> flazz, 'error' gives you values of any type, which throw an exception when evaluated
10:55:16 <ksf> noobskell, it depends on what you are doing.
10:55:27 <Cale> noobskell: It's good to get really conscious of how you're bundling the input to your functions into datatypes.
10:55:47 <flazz> so bottom is a valid value of every type?
10:55:55 <ksf> noobskell, you might want to have a look at xmonad to see it applied.
10:55:58 <c_wraith> Cale: MonadRandom is your library?
10:56:02 <zygoloid> flazz: yes, that is correct.
10:56:03 <Cale> c_wraith: yes
10:56:15 <ksf> ...xmonad is by no means non-monadic, has a quite common transformer stack _and_ a lot of pure stuff
10:56:23 <zygoloid> flazz: for instance, 'let a = a in a' will fail (as an infinite loop) and is of every type.
10:56:33 <Cale> flazz: yes. Because the language is Turing complete, we can't prevent the possibility of nontermination. Asynchronous exceptions are treated as a kind of nontermination.
10:56:52 <zygoloid> flazz: we have various other ways of creating a _|_ value, but in pure haskell you can't tell those apart from non-termination.
10:56:55 <flazz> so throwing is not evaluating?
10:57:26 <zygoloid> flazz: one way of looking at it is that _|_ is a value, like any other, but one you can't pattern-match on
10:57:39 <Cale> flazz: When you produce an error with a call to 'error', semantically, it's like going into an infinite loop, but one which has a practical implementation of stopping your program entirely with an error message.
10:57:55 <ksf> flazz, well, it is. as soon as you evaluate the throw primitive, the whole program evaluates to that exception
10:57:57 <zygoloid> flazz: therefore if you pattern-match a value, you won't handle the _|_ case, which is an error, giving a result with value _|_
10:57:59 <conal> so my point about the harmfulness of "the IO monad" is that people use that term even when there's nothing *generally* monadic going on.  just concretely IO.  and i suspect this habit encourages people to think that IO intrinsically has to do with Monad, rather than Monad simply being a convenient way to structure a minuscule part of the IO interface.
10:57:59 <flazz> whoah you just got really deep
10:58:11 <ksf> ...modulo catch. operationally it's a mess.
10:58:27 <c_wraith> Cale: I'm slightly dissatisfied with the IO instance for MonadRandom.  I think it's because it's such a lame implementation (not your fault, you went with what System.Random provided), and there's no way to replace it with a different implementation without involving newtypes.  I guess newtypes aren't so bad in a transformer stack, but if you're using untransformed IO, it's annoying.
10:58:30 <Cale> flazz: The upshot of this is that you shouldn't use fromJust unless you're *really* sure that the thing is going to be a Just (and you don't mind your program dying unconditionally if it's Nothing)
10:58:38 <zygoloid> ksf: catch isn't so bad if you view _|_ as a value rather than an exception
10:58:55 <ksf> yeah but then you start catching NonTermination and all hell breaks loose
10:59:06 <Cale> c_wraith: All the other random number generators I'm aware of are lame too, for not implementing split.
10:59:10 <flazz> Cale: yeah, i have a bunch of case XXXX of Just x -> x; otherwise -> error ...
10:59:25 <zygoloid> ksf: once we can reliably catch NonTermination it's only a matter of time until the machines take over ;-)
10:59:48 <flazz> could you say that a programmer can't match _|_ but the compiler does and that is an error?
10:59:55 <c_wraith> Cale, well, the complaint is really that it's hard to replace with something more suitable to my application, rather than the exact nature of why the default isn't suitable.
11:00:28 <ksf> the much more useful non-termination like exception is the one thrown on an infinitely blocked mvar
11:00:28 <Cale> flazz: Well, any attempt to pattern match against _|_ will cause the program to somehow not continue running.
11:00:56 <Cale> flazz: Whether that's because it's in an infinite loop, or if it exits abnormally.
11:01:16 <kmc> flazz, a programmer can catch ⊥ like any other exception: within an IO action
11:01:23 <kmc> but can't match it as a matter of evaluation only 
11:01:27 <Cale> kmc: Well... some _|_'s
11:01:33 <ksf> that's not haskell98, though.
11:01:33 <kmc> sure
11:02:11 <flazz> would it hurt to understand the semantics of error like imperative languages throw etc?
11:02:15 <kmc> you can't catch infinite loops, in general
11:02:23 <kmc> flazz, maybe
11:02:23 <flazz> untill i fully grok _|_?
11:02:29 <Cale> flazz: There are proper exceptions in IO which you can also use
11:02:41 <kmc> flazz, you understand how evaluation and execution are separate in Haskell?
11:03:32 <flazz> right now i think of execution as  when the runtime decides to execute an action, and the actions can evaluate things inside via bind
11:03:50 <flazz> evaluation is like beta reductions on pure functions
11:03:55 <kmc> yeah
11:03:58 <kmc> that's about right
11:04:03 <flazz> but i'm running on intuitive fumes
11:04:36 <kmc> so, exceptions in Haskell (as implemented by GHC) are firstly about execution:  IO-action execution can terminate abnormally, and other actions can catch this and do something else
11:04:42 <ksf> ...actions don't exectude stuff
11:04:43 <flazz> things like sequence_ will make sure the runtime executes things in an order, kinda like a pragma
11:04:48 <c_wraith> Cale: On a mostly-unrelated note, how hard would it be to add something like: (MonadRandom m, RandomGen g, Random a) => (g -> (a, g)) -> m a
11:04:51 <ksf> ...they get interpreted.
11:05:03 <kmc> flazz, it's not much like a pragma
11:05:04 <ksf> that's the model that won't clash with monads that don't happen to be IO.
11:05:06 <kmc> i don't see how
11:05:30 <kmc> execution isn't about ordering evaluation.  the whole point is that execution order and evaluation order are *not* tightly coupled
11:06:15 <flazz> i was lumping sequence_ with par and seq, they look like functions but how they interact with the real world is what is important
11:06:16 <ksf> flazz, the thing about sequencing is that you can construct lambda-terms which, essentially, evaluate to lists.
11:06:25 <kmc> flazz, sequence_ is very much not like seq
11:06:36 <ksf> let the elements be tokens standing for things like open, write etc. and then interpret them.
11:06:36 <kmc> seq defines evaluation order, sequence_ defines execution order
11:06:43 <c_wraith> actually, that's more restrictive than I want.  I'd just want: (MonadRandom m, RandomGen g) => (g -> (a, g)) -> m a
11:06:46 <ksf> monads are merely a way to express that pattern.
11:06:50 <kmc> sequence_ *is* a function, not something weird like seq
11:06:54 <kmc> it takes a list of actions and returns a single action
11:07:03 <kmc> a single action, which you may or may not ever execute
11:07:08 <dolio> seq is also a function.
11:07:37 <kmc> it kinda breaks parametricity though
11:07:53 <zygoloid> seq doesn't even define evaluation order, it's merely a strictness annotation
11:08:05 <kmc> anyway it's important not to think of the IO monad as a way to impose evaluation constraints
11:08:10 <c_wraith> pseq defines evaluation order. :)
11:08:14 <zygoloid> pseq defines evaluation order, but it's not standard haskell :)
11:08:15 <kmc> or as a way of making sure side-effect-producing evaluation occurs in the right order
11:08:18 <flazz> so (sequence_ ...) will evaluate to an action which is up to the runtime to execute, and i trust that the runtime will do them in order
11:08:23 <zygoloid> too slow :(
11:08:29 <kmc> it's a way of making sure *effects* occur in the right order, and who cares when they were evaluated
11:08:39 <kmc> because evaluating an action doesn't perform the action
11:08:42 <ksf> flazz, yes, exactly.
11:08:47 <kmc> yeah
11:08:49 <zygoloid> flazz: the runtime is told what order to do them in by the (>>)
11:09:00 <ksf> not every monad defines execution order, and the innards of the IO monad are implementation-specific.
11:09:06 <Cale> flazz: The order in which the execution occurs is encoded by that value that it evaluates to.
11:09:18 <kmc> so anyway, "error" (and other things like nonexhaustive pattern match) allow you to have *evaluation* that raises exceptions
11:09:34 <Cale> I would say that every monad defines an "execution order" of sorts
11:09:48 <zygoloid> Cale: even Identity?
11:09:48 <ksf> ghc happens to pass the real-world around as a state parameter, mutating it in place.
11:09:51 <kmc> but since we still don't want correctness of evaluation to depend on evaluation order, you can only catch these from an IO action
11:10:09 <kmc> this is also called "imprecise exceptions"
11:10:11 <ksf> other implementations might choose to have the real world immutable and mutate by making copies, instead.
11:10:50 <kmc> flazz, the meaning (denotation) of an expression is either a normally-produced value, or a *set* of exceptions
11:11:02 <kmc> e.g. in (error "foo" + error "bar") there is no guarantee about which error you raise
11:11:04 <zygoloid> "imprecise exceptions" means: a given pure computation might produce various different exceptions, depending on the actual evaluation order. semantically, your program behaves as if one is chosen /at random/ from that set of exceptions
11:11:17 <ksf> which would make an implementation of quantum bogosort trivial. just let the gc reclaim the worlds which don't yield the right result.
11:11:40 <kmc> and an IO action catching on the evaluation of that expression would nondeterministically get one or the other
11:11:50 <kmc> but that's okay, IO actions can already inspect lots of nondeterministic properties of the outside world
11:13:01 <zygoloid> also, while it's random, it's not necessarily uniform or fair. the probability of (error "foo" + error "bar") hitting the "foo" exception might be zero.
11:13:22 <flazz> kmc: so any expression can denotationally mean set of exceptions?
11:13:27 <kmc> yes
11:13:30 <flazz> even pure ones?
11:13:33 <zygoloid> yes.
11:13:36 <kmc> flazz, all expressions are pure
11:13:40 <flazz> right
11:13:42 <kmc> or i'm not sure what you mean by "pure"
11:13:52 <flazz> you knew
11:14:16 <kmc> but a value which throws an error when evaluated, and happens to have type «IO ()», is much different from an IO action which evaluates successfully but throws an error on execution
11:14:18 <flazz> like out of memory or something
11:14:31 <kmc> that's why we have both throw and throwIO
11:14:40 <flazz> if i have f x = x + 1 it could fail if there was no memory, hypothetically
11:14:48 <kmc> yeah
11:14:59 <kmc> this is even a third category of exceptions, asynchronous exceptions
11:15:03 <kmc> they're a huge pain in the ass
11:15:16 <zygoloid> best to not think of them as part of the denotational semantics imo
11:15:20 <kmc> another example is that the user can hit ^C at any time
11:15:25 <kmc> or another thread can throw you an exception
11:15:32 <ksf> or there could be a power outage.
11:15:35 <zygoloid> or another process can trample on your memory
11:15:53 <flazz> so getting back to fromJust, fromJust can deterministically raise an error whereas running out of memory won't
11:16:05 <ksf> or an unsafe language could call launchMissiles.
11:16:36 <ksf> for certain definitions of deterministic, yes.
11:16:53 <ksf> > fromJust Nothing
11:16:54 <lambdabot>   *Exception: Maybe.fromJust: Nothing
11:17:17 <kmc> flazz, "deterministically" in practice, but not as something you're allowed to catch by evaluation
11:17:21 <ksf> it might be hard, but is not inconcievable, to engineer a haskell interpreter which would run out of memory reliably, there.
11:17:27 <kmc> only catch by execution
11:17:47 <kmc> .... except we love to break rules and so there's a library for "pure evaluation" catching: http://hackage.haskell.org/package/spoon
11:17:53 <kmc> but people will look at you funny if you use it
11:18:07 <zygoloid> ... partly because it violates the imprecise exceptions rules.
11:18:30 <ksf> (reminds me of a performance bug in java which was caused by the gc kicking in at the exact wrong moment with mind-boggling accuracy)
11:18:36 <kmc> hehe
11:19:07 <zygoloid> it'd be really convenient if one of you two didn't have a three-letter-long name starting with k ;-)
11:19:15 <kmc> we get that a lot
11:19:20 <flazz> so it somewhat boils down to practicality, practically if i run out of memory i'm probably screwed, but i shouldn't be screwed if a file doesn't exist or the user misspells something, or is it things that would interfere with having an unspecified order of evaluation?
11:19:28 <ksf> people were all like "no you have to have an error in your code, some stray thread that you're spawning".
11:19:37 <Saizan> "a -> Maybe a" doesn't really violate the imprecise exceptions semantics, it violates monotonicity though
11:19:50 <canvon> zygoloid: if you're not using nickcolor.pl, you might give it a try ;)  (assuming you're using irssi)
11:19:52 <ksf> I got blank stares when I told them in what way they were spot-on and still completely mistaken.
11:19:55 <kmc> i've heard stories from people who do high-frequency finance in C++, about competing against others using Java, and how they could see just from watching the market data when their competitors' garbage collectors kicked in
11:20:01 <zygoloid> canvon: ta, i'll give that a go
11:20:06 <kmc> and of course you can take a ton of money from them at that moment
11:20:29 <danderson> that sounds believable
11:20:49 <danderson> then again, trading systems are as close to hard realtime systems as you can get without killing people when it goes wrong
11:21:35 <kmc> danderson, mostly they're not hard-realtime
11:21:35 <c_wraith> canvon: my client colors nicks, and chose to give ksf and kmc the same color.  It's not very smart.
11:21:56 <ksf> c_wraith, yeah, we know.
11:21:57 <danderson> kmc: which is scary, if they're treated as such
11:22:01 <zygoloid> danderson: bankers have been known to jump from windows :)
11:22:14 <danderson> zygoloid: yeah, but that kills *bankers*, not people!
11:22:19 <kmc> har har
11:22:28 <kmc> i mean that hard vs. soft is not just a measure of how important latency is
11:22:29 <danderson> yeah, I'll be here all week
11:22:37 * zygoloid wonders how many people here are bankers. probably quite a few.
11:22:40 <kmc> it's a measure of the shape of the curve of delay vs. how bad
11:22:50 <zygoloid> yay, ksf red, kmc blue :)
11:22:51 <kmc> hard realtime means this curve is a cliff, if you miss a deadline you are fucked
11:22:52 <danderson> yup
11:23:00 <kmc> trading is not like that; usually if you're a little faster you make a little more money
11:23:10 <danderson> in hard realtime, failure is catastrophic. In soft realtime it's merely not cool
11:23:26 <danderson> but in trading, missing a deadline can lose you a lot of money
11:23:27 <kmc> though at some point you're on top, and can't make any more because you have to wait for others to do things so you can exploit them
11:23:35 <danderson> which can be considered catastrophic, if it's your money
11:23:51 <kmc> danderson, but i think there are usually no hard deadlines
11:24:00 <kmc> at least from my own experience working on trading systems
11:24:07 <kmc> you want it as fast as possible, and you make more the faster it is
11:24:17 <kmc> and there's a relatively smooth curve in the middle
11:24:35 <danderson> interesting
11:24:46 <kmc> unless you're one of the best few in the market, or you totally suck
11:24:46 <danderson> yeah, that makes sense (and now you can tell I've never worked on trading systems :)
11:25:35 <kmc> perhaps the correct model is: for any individual money-making opportunity there is a deadline, probably unknown, and when you play out millions of these over a day you get a smoother curve
11:28:04 <kmc> one question is, if you are fastest by a wide margin, do you delay yourself intentionally so as to be only slightly faster than the competition?
11:28:23 <kmc> you might make nearly as much, and induce them to play a game of catch-up you will easily win
11:28:55 <Jafet> You'd set up two companies and write programs that collude to mislead others
11:29:16 <Jafet> You can then also try to fall into nicer tax brackets.
11:29:36 <kmc> the former is illegal, i think
11:30:08 <dolio> Certainly sounds illegal.
11:30:17 <Jafet> Well, I never heard of a judge who can read obfuscated code
11:30:19 <kmc> the latter is... really complicated
11:30:37 <kmc> the corporate and tax structures of hedge funds tend to be quite complicated
11:32:59 <kmc> "market manipulation" is illegal, even if it doesn't involve sock puppets
11:33:10 <kmc> (in the US and numerous other jurisdictions)
11:35:37 <poucet> Hi
11:36:14 <conal> poucet: hi.  how's life?
11:36:37 <arw> kmc: yes, but in most cases, such manipulations go undetected or unpunished.
11:37:01 <poucet> conal: GREAT
11:37:06 <poucet> conal: I am in san francisco
11:37:08 <poucet> well mountain view
11:37:19 <poucet> First day I got here, I was pinged already for the BAHUG thing =)
11:37:30 <arw> kmc: more recent trading algorithms are said to recognize each others trading patterns and plant "traps" for the other algorithm and stuff.
11:37:47 * poucet was curious who was attending that
11:38:24 <arw> kmc: like generating patterns, that the other algorithm will base is "buy" decision on and then selling it stuff.
11:38:50 <kmc> hehe
11:39:30 <EvanR-work> @src transpose
11:39:31 <lambdabot> transpose []             = []
11:39:31 <lambdabot> transpose ([]   : xss)   = transpose xss
11:39:31 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
11:39:48 <EvanR-work> >:(
11:40:17 <jkingkong> Hi again #haskell, was wondering if I could write custom events to the eventlog for profiling purposes (e.g. entering exiting specific functions)
11:40:51 <Saizan> you can use {-# SCC ... #-} pragmas
11:41:09 <kmc> jkingkong, probably you can FFI-call whatever bit of the RTS does event logging
11:41:15 <arw> kmc: we recently had somebody giving a talk about the topic of trading. unfortunately most of the interesting stuff were just hints and suggestions, no real information.
11:41:15 <kmc> or import some GHC module to get the primop for it
11:41:44 <jkingkong> yea I would like to see a particular even in threadscope
11:41:50 <jkingkong> event*
11:41:51 <conal> poucet: in mt view for work?
11:42:08 <poucet> conal: indeed
11:42:16 <jkingkong> so a sort of realtime trace of a function
11:42:17 <poucet> I recently switched line of work, so meeting team here
11:42:28 <jkingkong> kmc: is there a package that helps me do this?
11:45:21 <kmc> jkingkong, not that i know of
11:47:14 <poucet> conal: are yo in the bay area?
11:47:46 <conal> poucet: no.  2.5 hour drive east.  san andreas.
11:55:00 <EvanR-work> pretty awesome game
11:56:26 <kmc> hell yes
11:57:28 * c_wraith finally figured out why tibbe's style helper el file wasn't working for him
11:57:42 * c_wraith turns on the correct haskell indentation mode
11:59:06 <poucet> is ivan tarasov on this channel
12:17:09 <malorie> hi all. is http://book.realworldhaskell.org/read/ a good entry point to haskell?
12:18:42 <monochrom> yes
12:19:25 <burp> @lyah
12:19:25 <lambdabot> Unknown command, try @list
12:19:33 <burp> @url lyah
12:19:34 <lambdabot> http://www.learnyouahaskell.com/
12:19:42 <burp> I recommend this one very much
12:19:46 <nlogax> those two complement each other nicely
12:19:50 <burp> yup
12:20:31 <nlogax> LYAH is when mr miyagi is making you paint the fence and shit, and you start to wonder what the point is
12:20:34 <Botje> and avoid the gentle introduction to haskell, it's anything but
12:20:54 <nlogax> and then RWH comes, and you’re like “i know this! hyaahhh!”
12:21:42 <malorie> i see. thanks for the link. will definitely take a look at it. :)
12:21:49 <kmc> the gentle introduction is a good document, but it's not a tutorial in any sense
12:21:58 <kmc> it is gentle, in that it's a gentler version of the Haskell 98 Report
12:22:47 <malorie> to be honest, i prefer stony ways.
12:32:33 <monochrom> the gentle introduction is fine. I learned from it. I also had no "what are monads?" moments because of it.
12:33:40 <EvanR-work> "what are monads, really?" ;)
12:34:09 <ksf> they never scared me. just mystified a bit.
12:34:45 <ksf> but then, I already wasn't scared of continuations, and only mystified wrt. specific applications.
12:35:19 <pikhq> I simply didn't grok continuations until I saw the CPS monad.
12:35:20 <malorie> in lyah monads aren't covered yet, as far as i can see
12:35:25 <kmc> correct
12:35:31 <pikhq> malorie: "Coming soon".
12:35:36 <malorie> yeah
12:35:57 <malorie> so, at some point i have to stick to realworldhaskell, or something the like
12:36:10 <kmc> malorie, one thing to recognize is that "what are monads" and "how do I do IO" are two very separate questions
12:36:11 <danderson> dons: ping?
12:36:14 <monochrom> the gentle introduction is gentle iff you have no wrong prejudice about programming to unlearn.
12:36:31 <kmc> you can learn IO long before learning that the interface you use for IO is useful for other unrelated stuff
12:36:33 <pikhq> After I finished what was done with LYAH was just try writing code.
12:36:50 <pikhq> I feel it was enough to make it so that I could explore Haskell.
12:37:04 <pikhq> Far cry from knowing the language, but still.
12:37:56 <malorie> monochrom: "gentle introduction" == "realworldhaskell", right?
12:38:01 <pikhq> Of course, my experience is probably atypical. I mean, I learned C from man pages, code samples, and a loose idea of the execution model.
12:38:01 <monochrom> no
12:43:55 <vitka> @pl \a b -> a + x * b
12:43:56 <lambdabot> (. (x *)) . (+)
12:44:16 <vitka> @pl \a b -> b + x * a
12:44:17 <lambdabot> (+) . (x *)
12:54:04 <Peaker> What is a conventional way of instantiating Binary for sum types?
12:54:04 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
12:55:09 <Peaker> data MyList a = Nil | MyList a
12:55:18 <Peaker> instance Binary a => Binary (MyList a) where ... ?
12:55:35 <Peaker> | Cons a (MyList a) there above, of course
12:55:39 <Peaker> Convert to Maybe and serialize that?
13:00:06 <MigoMipo> @type flip
13:00:07 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:00:13 <MigoMipo> @type Prelude.flip
13:00:14 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:00:54 <int80_h> I'm having a problem with Control.Monad and COntrol.Monad.Read. I used "cabal list" to try and find what package I needed, or maybe to see if it was already installed. Was this the right way? Also, if I do not have it installed, how do I install it? I looked on hackage, found much information but it was not readily apparent to me how to go about installing this.
13:01:14 <int80_h> ^ that should be Control.Monad.Reader
13:03:59 <Peaker> int80_h, many packages may provide that same module name
13:04:07 <poucet> Anyone going to BAHUG?
13:05:03 <int80_h> Peaker : okay here is the error message I get that prompted me to investigate
13:05:17 <int80_h> Peaker: ghc --make hakyll.hs
13:05:23 <int80_h> then I get
13:05:31 <int80_h> hakyll.hs:10:7: Ambiguous module name `Control.Monad.Reader':
13:05:37 <int80_h> it was found in multiple packages: monads-fd-0.1.0.1 mtl-1.1.0.2
13:05:52 <Peaker> int80_h, well, that one module is provided by two packages
13:06:08 <int80_h> would posting hakyll.hs help?
13:06:55 <Peaker> int80_h, No, you have to decide which of the two you want to use
13:07:02 <Peaker> int80_h, and then just "ghc-pkg hide" on the other
13:07:15 <dons> danderson: pong
13:07:35 <int80_h> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=27452#a27452
13:07:38 <danderson> dons: unping :)
13:07:54 <danderson> I was looking for an svg of the haskell logo on the platform homepage
13:08:00 <danderson> but I found another that was close enough
13:08:03 <int80_h> Peaker, okay let me look at the code further. This is someone else's code I am trying to compile
13:08:17 <dons> unpong.
13:08:31 <dons> there's .svg's floating around, yeah
13:08:40 <danderson> there's also a haskell program on the wiki
13:08:46 <danderson> that generates variants of the logo
13:09:04 <danderson> I used that and added the gradients in inkscape.
13:09:15 <int80_h> Peaker : can I hide the package from within the code?
13:09:31 <Peaker> int80_h, If the package has a "cabal" file, you can just run "cabal install" in it
13:09:33 <int80_h> or specify which package I want to be using?
13:09:44 <Peaker> int80_h, how are you building the package, does it not have a .cabal file?
13:09:53 <int80_h> Peaker: I did do cabal install, this is the code I was given after doing that
13:10:21 <int80_h> I folowed the tutorial cabal install hakyll.
13:11:15 <int80_h> this is the url, you'd have to go to the first tutorial to see the instructions.
13:11:18 <int80_h> http://jaspervdj.be/hakyll/tutorials/part04.html
13:11:37 <Peaker> int80_h, Hmm.. Edit the .cabal file, what do you see in the "Build-Depends:" section?
13:11:52 <int80_h> good good, troubleshooting haskell skill I need :)
13:11:55 <int80_h> checking
13:12:06 <Peaker> int80_h, What is the package download URL?
13:12:57 <int80_h> I don't know. I just did cabal install hakyll and cabal did the rest
13:13:09 <int80_h> where can I find the .cabal file ?
13:13:18 <int80_h> I got lost here
13:13:26 <int80_h> michael@michael:~/.cabal/packages/hackage.haskell.org/hakyll/2.2.1
13:13:32 <int80_h> that's not right
13:14:02 <int80_h> would it be .cabal/config?
13:14:05 <Peaker> int80_h, you say you got the error when you typed "cabal install hakyll"?
13:14:34 <int80_h> no, I got the error when I typed "ghc --make hakyll" which is what the instructions said to do
13:14:49 <Peaker> int80_h, What instructions, where?
13:14:56 <Peaker> int80_h, What does: ghc-pkg list hakyll say?
13:15:02 <int80_h> I posted the url but I will do it again
13:15:06 <dcoutts_> int80_h: is that a sample/demo of hakyll or something?
13:15:07 <lambdabot> dcoutts_: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:15:23 <Peaker> I  have your URL open but it doesn't seem to be there
13:15:48 <int80_h> http://jaspervdj.be/hakyll/tutorials/part01.html
13:16:27 <Peaker> oh, you posted part04
13:16:38 <int80_h> I applied the compile instructions to part04.html, the blog tutorial. The brochure tutorial has it's own problems but I am not too interested in trying to fix that. I'd rather try to fix the blog tutorial
13:17:38 <int80_h> Peaker : I get this when I typed ghc-pkg list hakyll
13:17:46 <int80_h> michael@michael:~/.cabal$ ghc-pkg list hakyll
13:17:46 <int80_h> /usr/local/lib/ghc-6.12.3/package.conf.d
13:17:46 <int80_h> /home/michael/.ghc/x86_64-linux-6.12.3/package.conf.d hakyll-2.2.1
13:17:53 <dcoutts_> int80_h: so the problem is merely that you've got two packages installed that provide the same modules
13:18:04 <int80_h> I still haven't found the .cabal file you suggest I investigate
13:18:06 <dcoutts_> int80_h: ghc --make does not know which to pick
13:18:19 <int80_h> dcoutts, how do I make it pick, from within the code?
13:18:33 <int80_h> or, maybe I can do it on the command line
13:18:44 <int80_h> is there a ghc flag I can use?
13:18:44 <dcoutts_> int80_h: I presume there's no .cabal file because the instructions are for a sample/example module, not instructions for installing a package (which it seems you have got installed fine)
13:19:17 <dcoutts_> int80_h: there are a number of ways of solving the problem of ambiguous modules
13:19:23 <int80_h> yes it seems to have installed fine, I just can't run this sample code.
13:19:28 <dcoutts_> int80_h: the most direct is to explicitly hide one
13:19:46 <dcoutts_> which you can do either permanently or just for one call of ghc
13:20:01 <dcoutts_> for a single call you can use -hide-package blah
13:20:09 <dcoutts_> to make that persistent, use ghc-pkg hide blah
13:20:16 <int80_h> I'm concerned I may hide the module I need
13:20:22 <dcoutts_> it's likely you want mtl, not the other one
13:22:43 <int80_h> dcoutts : in the event I need the other one in the future, would it not make more sense to just hide it during the compile of this particular example?
13:23:09 <Peaker> my computer was stuck all this time, ghc was thrashing memory, arrg.
13:23:30 <int80_h> oh wait, brain fart. I see why persistant hide is okay.
13:23:37 <Peaker> int80_h, there's "expose"
13:24:16 <dcoutts_> int80_h: and note that hiding is only relevant for using ghc --make, when you use a .cabal file then the package deps are explicit
13:24:40 <malorie> just wondering: would one rather use CamelCasing or under_scoring in haskell?
13:25:32 <Peaker> malorie, afaik everyone uses camelCasing (with a few exceptions), so I think camelCase for uniformity
13:25:37 <Peaker> even though I find under_scores more readable
13:25:51 <int80_h> dcoutts : it compiles. thats so much. Now to see what else breaks.
13:25:52 <Lemmih> malorie: CabalCasing is the way to go. Otherwise you might be mistaken for an Ocaml'er.
13:25:55 <malorie> Peaker: some for me. i don't want to violate best-practice, though
13:26:07 <malorie> s/some/same/
13:26:18 <malorie> Lemmih: ic. thx.
13:26:20 <Peaker> Lemmih, so the vty author is an OCaml'er? :)
13:26:26 <Heffalump> dcoutts_: can I just confirm that it's a known problem with Cabal that if you list build-deps for something that's buildable: False, they'll still get used? (To be precise, I think I see them used when checking deps but not when cabal install is deciding what prerequisites to install)?
13:26:41 <int80_h> holy cow, we have working blog software in haskell!
13:27:04 <Lemmih> Peaker: He's an infiltrator, he's gotta be!
13:27:24 <int80_h> Lemmih: hi there
13:28:28 <tibbe_> ping
13:28:29 <gogonkt> PONG, now at #haskell
13:28:38 <Peaker> @hoogle Monad m => m a -> m b -> m a
13:28:38 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
13:28:38 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
13:28:38 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
13:28:53 <Peaker> @type (<*)
13:28:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:28:57 <Lemmih> int80_h: Are you now or have you ever been a subscriber to the ocaml mailing list?
13:28:59 <dcoutts_> Heffalump: yes, they are needed as prerequisites by cabal-install but are needed when selecting a configuration but not at the final configure step.
13:29:04 <Peaker> Is there a name for this for monads?
13:29:15 <Peaker> damn monad not subclassing Applicative
13:29:16 <int80_h> int80_h : hmm might be, should I be? 
13:29:32 <int80_h> bah! I'm a little light headed over this working blog
13:29:43 <int80_h> Lemmih : hmm might be, should I be? 
13:30:11 <dcoutts_> Heffalump: the problem is it's not really clear what dependencies mean when a component is not buildable, especially if it's conditionally not buildable (which usually depends on whether the dependencies can be satisfied or not)
13:30:44 <Lemmih> int80_h: Meh, only if you feel like it.
13:30:49 <dcoutts_> Heffalump: I tried fixing it for cabal-install-0.8.0, but it turned out to be more subtle than I thought and I had to revert it for version 0.8.2
13:31:16 <int80_h> I'm down with OCaml, but I want to master haskell more than I have first.
13:31:28 <int80_h> I get so easily distracted by new bright shiny things
13:32:44 <dcoutts_> Heffalump: the right way to think about buildable False at the moment is to assume it's completely ignored until the very last moment before a package is built, then if the lib is not buildable the whole thing fails and if an exe is not buildable it gets ignored.
13:33:42 <int80_h> is there a particular haskell way of daemonizing a process?
13:33:52 <int80_h> or do I just find the debian way?
13:35:26 <Heffalump> dcoutts_: thanks. Is putting everything under the same condition that determines buildable a reasonable fix/workaround? i.e. if foo then { buildable: true ;  .... } else buildable: false
13:35:45 <tibbe_> dcoutts: where have you been? we missed you
13:35:48 <dcoutts_> Heffalump: only partially
13:36:17 <dcoutts_> tibbe_: in a forest :-)
13:36:36 <tibbe_> dcoutts_: which one?
13:36:55 <frea> Hi, how can I make a data type that represents a Maybe Bool ? data X = X Maybe Bool doesn't compile
13:36:58 <int80_h> dcoutts : now is the time for a tree pun
13:37:07 <dcoutts_> tibbe_: the New Forest in southern England, near Southampton
13:37:19 <int80_h> ooooh swing and a miss
13:37:19 <tibbe_> frea: data X = X (Maybe Bool)
13:37:22 <tibbe_> dcoutts_: ah
13:37:28 <dcoutts_> tibbe_: it was new about 1000 years ago :-)
13:37:39 <tibbe_> dcoutts_: haha
13:37:40 <aristid> tibbe_: why not newtype?
13:37:46 <Heffalump> it's like New College, Oxford (but older)
13:37:49 <frea> tibbe_: thanks
13:37:57 <tibbe_> aristid: sure, I just pointed out the error in the definition frea gave
13:38:02 <tibbe_> frea: np
13:38:05 <aristid> i see
13:38:09 <tibbe_> dcoutts_: ttuegel has been busy
13:38:28 <dcoutts_> Heffalump: iirc, there's a problem there too sometimes, but I can't recall the details ottomh.
13:38:46 <dcoutts_> Heffalump: basically the semantics of buildable and conditions are all messed up
13:38:53 <Heffalump> dcoutts_: but it is at least better, I guess?
13:39:09 <dcoutts_> Heffalump: it works in strictly more circumstances I think
13:39:17 <Heffalump> thanks
13:39:56 <dcoutts_> tibbe_: great
13:40:26 <dcoutts_> tibbe_: I was thinking, we should persuade him to write a presentation on the new feature and give it as the Haskell Implementors Workshop
13:40:37 <tibbe_> dcoutts_: I guess you have a backlog, would you have time to get to some of his patches soon?
13:40:42 <dcoutts_> tibbe_: if he cannot attend, you or I could present it on his behalf
13:40:45 <tibbe_> dcoutts_: that would be cool!
13:40:48 <tibbe_> dcoutts_: sure
13:40:58 <dcoutts_> tibbe_: hopefully at the weekend
13:41:08 <tibbe_> dcoutts_: I could do that even if he doesn't write it (as long as he doesn't attend as he should do it then)
13:41:11 <dcoutts_> tibbe_: what's the main area of progress?
13:41:12 <tibbe_> dcoutts_: ok
13:41:23 <tibbe_> dcoutts_: the library test type
13:41:25 <tibbe_> dcoutts_: logging
13:41:40 <tibbe_> dcoutts_: there are some design issues to resolve
13:41:40 <dcoutts_> great
13:41:49 <tibbe_> dcoutts_: otherwise it runs fine
13:41:58 <tibbe_> dcoutts_: it needs a quickcheck and hunit runner
13:43:28 <tibbe_> dcoutts_: then it's kinda "done", after documentation
13:43:37 <dcoutts_> tibbe_: nice
13:43:51 <dcoutts_> tibbe_: so time for some polish then
13:43:59 <dcoutts_> e.g. some examples
13:44:06 <tibbe_> dcoutts_: yes
13:44:11 <dcoutts_> find a package with significant tests and convert it
13:44:23 <tibbe_> dcoutts_: as I said there are some small design issues (in my mind anyway)
13:44:33 <tibbe_> dcoutts_: yup
13:44:37 <jbapple> How can I get the bits from a Float into an Int? I don't want the Int to be the same semantic value, I just want to view those bits as an Int.
13:44:38 <dcoutts_> or work on uploading test results to the new hackage server
13:44:39 <tibbe_> dcoutts_: xmonad?
13:44:41 * hackagebot uu-parsinglib 2.3.3 - New version of the Utrecht University parser combinator library  http://hackage.haskell.org/package/uu-parsinglib-2.3.3 (DoaitseSwierstra)
13:44:58 <dcoutts_> tibbe_: no idea, I expect you and ttuegel can find a good one
13:45:07 <tibbe_> dcoutts_: yeah, I want to make sure things get really polished so we don't have to revisit testing support any time soon
13:45:08 <dcoutts_> tibbe_: xmonad might be good, it's small and well known
13:45:15 <tibbe_> dcoutts_: we will
13:45:19 <tibbe_> dcoutts_: and it has tests
13:45:22 <tibbe_> lots of em
13:45:32 <dcoutts_> right, mostly QC right?
13:45:55 <tibbe_> dcoutts_: I think so
13:46:29 <tommd> jbapple: Have you considered making an FFI routine to cast the Float?  Ugly but doable.
13:46:31 <tibbe_> dcoutts_: so we still need QC and HU support, I don't know how much work that is
13:46:49 <jbapple> tommd: No, I have not.
13:47:01 <dcoutts_> tibbe_: I would imagine it involves adapting test-framework
13:47:08 <jbapple> I was hoping something like Data.Bits would help
13:47:16 <jbapple> I mean, it has "bits" right in the name :-)
13:47:23 <dcoutts_> tibbe_: how close is the cabal library test type interface to the test-framework interface now?
13:47:28 <jbapple> But it seems to not be related
13:47:30 <kmc> jbapple, there's no guarantee that Float and Int are the same size, or that Float has any particular internal layout
13:47:41 <tommd> jbapple: There was a -cafe thread about exactly this (Bits instance of Float).  Didn't read it myself, but you could take a look.  I'm assuming you didn't start that thread yourself.
13:47:46 <kmc> jbapple, it'd be useful except that there's no Bits instance for Float, and for this reason
13:47:47 <BMeph> jbapple: decodeFloat, perhaps? 
13:47:55 <tibbe_> dcoutts_: yes
13:47:55 <kmc> jbapple, does it have to be fast?
13:47:59 <jbapple> @hoogle decodeFloat
13:48:00 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
13:48:01 <tommd> Is there a float Binary instance?
13:48:02 <tibbe_> dcoutts_: I haven't checked, I should
13:48:03 <jbapple> kmc: yes
13:48:12 <kmc> jbapple, the fastest way will be unsafeCoerce
13:48:16 <kmc> It's Probably Fine [tm]
13:48:19 <jbapple> :-)
13:48:29 <dcoutts_> jbapple: just use the FFI library, poke an Int, peek a Float
13:48:30 <jbapple> What I really want is a hash function for floats
13:48:37 <jbapple> but Data.HashTable doesn't have one
13:48:38 <dons> shapr: around?
13:48:39 <dcoutts_> jbapple: erm, an Int32
13:48:43 <jbapple> This was just a way to do it
13:48:50 <dons> jbapple: hmm. what are you doing with float hashing??
13:48:59 <dons> jbapple: wouldn't a Vector Float be more useful :)
13:49:02 <jbapple> Talking to harrop
13:49:05 <dons> oh sigh.
13:49:06 <kmc> oh god
13:49:09 <dcoutts_> heh heh
13:49:10 <tommd> jbapple: Use Cereal - it seems to have a float instance.
13:49:29 <sproingie> harrop is still grinding his axe?
13:49:31 <kmc> jbapple, Data.Binary.IEEE754 will do it portably
13:49:40 <dons> dafis had a float / int issue with the twitter code for alexyk recently
13:49:41 <sproingie> thing must be a razor by now
13:49:47 <dons> had a very fast serializer for floats
13:49:54 <dons> Data.Binary.IEEE754 is very slow, but standard
13:50:03 <jbapple> In the conversation, he claimed that Haskell was slower at hash tables than any real imperative language
13:50:10 <jbapple> But it's about the same speed as java
13:50:25 <jbapple> faster, actually
13:50:26 <tommd> jbapple:  castFloat flt = Data.Serialize.decode (Data.Serialize.encode flt) :: Either String IntX
13:50:29 <dons> so not worth wasting energy on this guy
13:50:38 <tibbe_> dcoutts_: heading off to bed, gnight
13:50:42 <sproingie> being as fast as java hashtables is nothing to write home about
13:50:45 <dons> jbapple: facts mean nothing to him.
13:50:45 <dcoutts_> tibbe_: g'night
13:50:55 <kmc> jbapple, here's a bunch of ways of skinning this cat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27457#a27457
13:51:03 <jbapple> dons: Ok, bit they may mean something to others
13:51:08 <dons> jbapple: are we talking about inserting 10M consecutive values into a hash...
13:51:20 <dons> you should take apart the stupidity of that as a "hash" benchmark for one.
13:51:21 <jbapple> 5M, I don't have that much RAM
13:51:37 <dons> since enumFromTo 1 N isn't a hash benchmark, in my view.
13:51:46 <Peaker> dons, I think it is productive to at least have one counter-example to point to for each of jdh's absurd claims
13:51:56 <jbapple> dons, why is it a bad benchmark? Presumably a hash function will mix them up enough it's the same as generating random inserts, but cheaper
13:52:13 <jbapple> everyone else, I'm still catching up with all of your helpful suggestions
13:52:15 <sproingie> actually inserting consecutive data is a pretty decent test case
13:52:16 <Peaker> dons, I transliterated his real-quicksort example from C recently so he can no longer claim Haskell can't reasonably express quicksort :)
13:52:26 <dons> jbapple: its not representative of anything but the cost of doubling array sizes for the underlying hash
13:52:29 <jbapple> tommd, thanks, I'll look at Cereal
13:52:32 <dons> it doesn't test a realistic use of hashes
13:52:51 <sproingie> well if it completely falls over then worst-case isn't so good
13:52:56 <dons> Peaker: oh, dolio did a good job last year. but he'll just "forget" what you did and keep on with this stuff
13:52:58 <sproingie> obviously it doesn't
13:53:17 <jbapple> kmc, thanks, I'll look at D.B.IEEE754
13:53:21 <sproingie> actually it's not even worst-case, one hopes you'd get good distribution
13:53:24 <dons> Peaker: www.haskell.org/packages/archive/uvector-algorithms/0.2/doc/html/Data-Array-Vector-Algorithms-Merge.html
13:53:34 <dons> Peaker: inplace fast sort, beats C quicksort last I checked.
13:53:36 <jbapple> Data.HashTable is also the about the same speed as OCaml Hashtbl
13:53:45 <tommd> jbapple: Write it in Coq, extract to Haskell.  I think the fact that efforts from both the OCaml community and Haskell community support such work would make his head hurt.
13:53:54 <dons> heh
13:54:06 <dons> well, he's anti-functional programming anyway.
13:54:11 <tommd> Because obviously those to communities should be killing each other, right?
13:54:15 <jbapple> dons: It may be a waste, but I learn a little bit, and I hope it gets closer to the truth.
13:54:16 <sproingie> i think the screaming purple donkeys in his skull make his head hurt
13:54:21 <Peaker> dons, Well, he was talking about code brevity at the time
13:54:31 <dons> Peaker, jbapple he feeds on your energy. he will only write longer and more things for each thing you provide
13:54:34 <tommd> dons: Really?  I had a misconception and thought he was an [OCa]] ML guy.
13:54:36 <jbapple> One thing that's interesting is how .net treats unboxing
13:54:45 <dons> tommd: he's been flaming Xavier for years now
13:54:46 <sproingie> he's an F# guy
13:54:58 <sproingie> he has some consultancy based on it.  god help his clients.
13:55:02 <dons> tommd: he cares about imperative programming for numerical stuff, afaik. anything else is uninteresting.
13:55:15 <tommd> Huh, rather boring.
13:55:20 <kmc> he used to love OCaml, now that he's no longer making money off it, he trashes it almost as often as Haskell
13:55:26 <aristid> dons: but he _says_ he does functional programming?
13:55:40 <Peaker> Yes, his only measure of a language quality is how fast it implements quicksorts and hash tables :)
13:55:42 <sproingie> imagine how well he treats his former ocaml clients if they came to him for support
13:55:48 <dolio> Isn't he writing his own OCaml compiler/runtime/whatever?
13:55:56 <sproingie> i doubt he could
13:56:02 <dolio> hlvm or something.
13:56:23 <jbapple> C++ templates just copy code. Java boxes everything by default. I am interested to learn about how polymorphism can work (that is, not just be C++-copy-pasta style) while still allowing unboxed types to work -- there are lots of ways to do things. Sometimes, Haskell's classes can get in the way of things like runST, I learned last night
13:56:28 <dolio> On top of llvm.
13:56:41 <dons> Peaker: well, they're not really hashtables. its  (U.enumFromTo 1 (10^7)) ! 100
13:56:53 <shapr> dons: wassup?
13:56:57 <dons> shapr: ah ha
13:57:02 <shapr> dons: What?
13:57:07 <dolio> Yeah, hashtables where all the keys are already integers.
13:57:09 <shapr> What did I say?
13:57:15 <jbapple> kmc: thanks for the hpaste, I'll use it as a reference
13:57:37 <arbitrarylogic> @src flip
13:57:37 <lambdabot> flip f x y = f y x
13:58:09 <aristid> :t flip
13:58:09 <jbapple> dons: I still don't understand -- why is it only representative of doubling? What makes it not real use in your opinion?
13:58:10 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:58:24 <aristid> :t \f x y -> f y x
13:58:25 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
13:58:30 <jbapple> dons: where did dolio do that good job last year. Was it on reddit? Do you have a link?
13:58:44 <dons> jbapple: oh, well, for one, keys == values, which is very atypical for a hashtable
13:58:51 <aristid> oh the arbitraryl-guy has gone away
13:58:54 <dons> secondly, keys and values are Int, so that is designed to benefit .NET's specialization of Int types
13:58:55 <msieradzki> what's wrong with 1.?
13:59:01 <dons> thirdly, all values are consecutive
13:59:06 <dons> fourthly, it tests insertion only
13:59:15 <msieradzki> is the hash of int simply int?
13:59:29 <jbapple> tommd: no, he frowns on OCaml now, too
13:59:32 <dons> an 'id' function is valid in this test.
13:59:34 <msieradzki> all of these are features of microbenchmark
13:59:44 <dons> hence the entire thing reduces to (U.enumFromTo 1 (10^7)) ! 100
14:00:14 <jbapple> dons: It's true, I think he thinks imperative is just preferable for functional. I'm not sure what, if anything, he likes about FP
14:00:18 <dons> now , i'm sure there are standard benchmarks for hashtables
14:00:23 <dons> like dictionaries for spell checking
14:00:37 <dons> that actually involve hashing and random access
14:00:45 <Peaker> spell checkers probably benefit more from tries?
14:00:48 <dons> and a good benchmark there would be useful
14:00:52 <tommd> I thought spell checking was all done via bloom these days.
14:00:52 <Peaker> and aren't really high-performance
14:01:06 <dolio> jbapple: It's slow, allegedly.
14:01:07 <dons> well, i'm just speculating, since that used to be a shootout benchmark
14:01:26 <dons> but inserting consecutive ints into an array is /not/ a good hashtable benchmark. its about the dumbest possible test
14:01:31 <dons> which i think he should be called out for.
14:01:31 <Peaker> jbapple, he likes pattern matching
14:02:02 <dolio> Oh, likes.
14:02:02 <msieradzki> why is haskell slow then
14:02:08 <msieradzki> in sequential adding to HT
14:02:17 <dolio> Yeah, he likes pattern matching, because Lisp doesn't have that.
14:02:17 <tommd> Enough about Harrop - how about Crypto, graph-writing, LLVM backends, and all those other cool things?
14:02:21 <dons> its not really, which is the thing we have shown.
14:02:36 <dons> the difference is that the .NET hash specializes the container for Int to unboxed arrays
14:02:41 <dons> which the GHC generic Hash doesn't do
14:02:44 <jbapple> dons: Well, you have to deal with collisions. For instance, he says open addressing is better than chaining. That does change the benchmark a bit
14:02:50 <msieradzki> dons, any way to achieve it?
14:02:51 <dons> so he chooses the example of Int/Int keys to maximize the specialization
14:03:01 <msieradzki> like rules?
14:03:05 <dons> msieradzki: sure, via associated types.
14:03:12 <dons> we do that for Map k v and other types now
14:03:32 <jbapple> dons: Yeah, you're right, it would be nice to have a benchmark based on a real use case, even if it is a simple one. A wordlist might be a good thing to try.
14:04:04 <jbapple> Peaker: Pattern matching is pretty darn great :-)
14:04:13 <dons> so what this actually tests is how quickly you can allocate 10^7 + load slots in an unboxed int array via doubling
14:04:18 <dons> or whatever growth you want
14:05:01 <jbapple> msieradzki: It's not! It's as fast as other boxed languages like Java and OCaml. If you write an unboxed hash like in C++ or MS.Net in Haskell it's just as fast (on my machine. I used Vector.Unboxed.Mutable)
14:05:22 <aristid> dons: but that's not why you started doing the unboxed specialized containers thing?
14:05:28 <dons> no, that was separate
14:05:29 <msieradzki> another thing is where do I find out
14:05:32 <dons> but its the same technique
14:05:36 <dons> though ghc will do it statically
14:05:39 <msieradzki> what to use: default array libraries, uvector, vector, something else
14:05:51 <Peaker> dons, Can GHC specialize Map Int to IntMap and other such specializations?
14:06:13 <Peaker> Maybe Map can be defined as a type family?
14:06:35 <dons> Peaker: yeah, tibbe and I are writing a paper on it. see the adaptive-containers library
14:06:48 <dons> import Data.Vector
14:06:49 <dons> main = do let hash = enumFromN 1 (10^7) print (hash ! 100)
14:06:53 <dons> is a silly hashtable benchmark :)
14:06:54 <BMeph> dons: Have those algorithm modules been moved over to 'vector' already?
14:06:57 <dons> $ time ./A
14:06:58 <dons> 101
14:06:58 <dons> ./A  0.00s user 0.01s system 80% cpu 0.012 total
14:07:06 <dons> BMeph: yeah, vector-algorithms , I think
14:07:09 <dons> check with dolio 
14:07:10 <dolio> Specializing containers like that was one of the original use cases of associated types.
14:07:14 <dolio> Or functional dependencies.
14:07:22 <dons> dolio: indeed (array of pairs to pair of arrays)
14:07:33 <dolio> Generalized tries and whatnot.
14:07:41 <Peaker> dons, cool, so we will be rid of IntMap soon? :)
14:07:53 <Peaker> type families are a pretty awesome optimization tool then :)
14:07:58 <dolio> BMeph: There's a vector-algorithms.
14:08:10 <dons> dolio: i recall the sort in there was pretty fast
14:08:22 <dolio> Yeah. There are several.
14:08:35 <msieradzki> http://www.spoj.pl/problems/HMRO/ I'll try implementing that in Haskell for fun
14:08:39 <msieradzki> though it's not HT only
14:09:12 <BMeph> dons: Ah, yeah - you "inspired" me to pull up a term and type 'cabal list vect', heh-heh. :)
14:10:27 <dons> a hashtable class that used type specialization to switch between specalized open hashes implemented as Data.Vector.Unboxed and regular Hashtables would be cool
14:10:36 <dons> though not as useful as a Map spec class.
14:10:51 <dons> maybe copying the ocaml ffasthash lib
14:11:36 <aristid> @faq x
14:11:36 <lambdabot> The answer is: Yes! Haskell can do that.
14:12:02 <Peaker> dons, I guess a hash table type can use a type family just like a Map for type specialization, rather than a class?
14:12:23 <dons> yup
14:12:28 <dons> well, class-associated type.
14:12:34 <msieradzki> also main = do let hash... makes no sense because I can write main= do print 100
14:12:59 <dons> class SpecHash k a where data Hash k v :: * -> * -> * 
14:13:07 <dons>     new ; insert  ; delet
14:13:26 <dons> msieradzki: well, yeah, assume [n] <- fmap read getArgs
14:13:35 <Peaker> dons, ah
14:13:53 <dons> that lets you specialize to e.g. an open hash of ints for the k=Int, v=Int case
14:14:07 <dons> which i believe .NET is doing
14:14:24 <dons> while boost et al don't (going by the fact they get   the same numbers as Data.Hashtable)
14:14:36 <Peaker> dons, why is the value type relevant? Why not just the key type?
14:14:39 <msieradzki> I'm only sure that .NET specializes container when it has struct type
14:14:48 <dons> Peaker: value is more important, so we can avoid buckets
14:14:51 <msieradzki> no boxing happens then (kind of obvious)
14:14:55 <dons> right
14:15:18 <Peaker> dons, "open hash" means you re-hash keys on collision?
14:15:20 <dons> keys also help, for open hashing, so you can store the key/val pair next to each other
14:15:31 <dons> or probe, but you don't use buckets is the key
14:15:35 <dons> so not an array of pointers
14:15:49 <Peaker> dons, Wouldn't it work for k=Int v=(Any unboxable value type) ?
14:15:50 <dons> meaning no need for GC help
14:15:53 <dons> Peaker: yup
14:16:20 <Peaker> re-hash is a problem with deletions, isn't it? Need to "clean up" the table from dummy entries every once in a while
14:38:38 <plediii> is work on real world haskell over?
14:38:56 <jmcarthur> plediii: the book?
14:39:00 <plediii> yes
14:39:04 <jmcarthur> plediii: it's been released for a while now
14:39:15 <plediii> i see so many errors well commented on that haven't been corrected in years now
14:39:45 <jmcarthur> the online version is not up to date with the dead tree version
14:40:08 <plediii> ah
14:41:20 <mle> i.e. the dead tree one is handy, but be /sure/ to check the online one; it's got updates and lots of neat commentary that helps.
14:41:21 <plediii> i have been considering to buy it, but seeing so many old mistakes is a little discouraging
14:41:43 <plediii> without the comments some of the examples would be indecipherable 
14:42:34 <plediii> excepting that I just type the code in and figure it out myself
14:42:36 <jmcarthur> mle: the online one is *not* upto date
14:42:38 <jmcarthur> *up to
14:50:57 <mle> s'better.
14:51:04 <mle> or it was
15:20:40 <BMeph> jmcarthur: ping
15:38:24 * hackagebot yesod 0.4.0.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.4.0.3 (MichaelSnoyman)
15:50:33 <jbapple> Thanks for your help, earlier, everyone. I was trying to get the bits out of a Float. I ended up just using decodeFloat. Since I didn't need the Integer mantissa, I just copied & pasted the actual implementation of decodeFloat for Floats, then used the Int# mantissa.
15:57:57 <davekong> Is there a simple way to turn a String into a multi-digit number?
15:58:26 <kmc> is there a simple way to write a function of type String -> Integer
15:58:37 <kmc> yes, f _ = 0
15:59:06 <kmc> do you have any requirements on this function?
15:59:44 <davekong> kmc: well sane numbers are 25 or less
15:59:46 <dobblego> f = read
16:00:02 <kmc> davekong, what?
16:00:40 <davekong> as in if the string would turn into something outside the range [1..25] it is an error
16:00:42 <mtnviewmark> > read "123457890"
16:00:43 <lambdabot>   *Exception: Prelude.read: no parse
16:00:48 <alexyk> I need to invert a nested IntMap, basically reverting each deep path [from day to n] by [to day from n].  The clojure original and Haskell type, as well as Clojure's invert, are here: http://paste.pocoo.org/show/237683/.  Note that Clojure's for is a generator which creates the 4-tuples, which I then stick back into a new structure.  Can Haskell's list generators be used for a siimilar purpose?
16:01:18 <mtnviewmark> > let f = read :: String -> Integer in f "123456789012345678901234567890"
16:01:19 <lambdabot>   123456789012345678901234567890
16:01:26 <mtnviewmark> look ma, 30 digits!
16:01:28 <davekong> ahh
16:01:31 <davekong> that easy
16:01:41 <mtnviewmark> Haskell aims to please
16:01:56 <kmc> ahh
16:02:00 <mtnviewmark> mind you, read is dangerous - it errors if the string isn't a number
16:02:04 <jmcarthur> alexyk: you mean like foo :: Map String Int -> Map Int String?
16:02:10 <mtnviewmark> if you need to recover from that, use reads
16:02:11 <kmc> you wanted to interpret a string of decimal digits as a number?
16:02:20 <davekong> yea
16:02:22 <kmc> "decimal digits" is the key point there
16:02:35 <kmc> there's plenty of other reasonable ways to turn a string into a number
16:02:43 <kmc> which is why i didn't know what you meant
16:02:45 <mtnviewmark> beloved the world over
16:02:46 <davekong> well the first part is a letter but I just take that off then process the tail
16:02:47 <jmcarthur> @let swap = snd &&& fst
16:02:49 <lambdabot>  Defined.
16:02:55 <kmc> and i still don't know where 25 comes in
16:03:05 <jmcarthur> :t M.fromList . map swap . M.toList
16:03:06 <lambdabot> forall k a. (Ord k) => M.Map a k -> M.Map k a
16:03:40 <dons> RC for Haskell Platform is up, testers send me feedback via mail or direct msg. http://www.galois.com/~dons/tmp/hp/haskell-platform-2010.2.0.0.tar.gz
16:03:43 <mtnviewmark> let sane = (<= 25) in map sane [1,3,42]
16:03:48 <davekong> kmc: I see sorry
16:03:52 <kmc> 's okay :)
16:04:00 <kmc> just advice for the next question you want to ask :)
16:04:01 <alexyk> jmcarthur: no, the Graph inverts to a Graph.  Currently, for each userU talking to a user V on a day D via say N tweets, it has an entry in the top IntMap under U of an IntMap under D of an IntMap under V with N.  We need to reassemble those directed edges for each V -- how many times each U talked to it on the day D.
16:04:32 <jmcarthur> err
16:04:40 <jmcarthur> alexyk: what is the type of the function you want? :)
16:04:58 <alexyk> tehere's an example for Clojure -- I want invert :; Graph -> Graph.
16:05:01 <alexyk> ::
16:05:08 <jmcarthur> what is Graph?
16:05:13 <jmcarthur> is it from fgl?
16:05:14 <alexyk> it's listed there
16:05:21 <jmcarthur> oh lemme look again then
16:05:26 <alexyk> it's my own nested IntMap 
16:05:57 <jmcarthur> ah, IntMap (IntMap (IntMap Int))
16:06:30 <alexyk> yep
16:06:52 <jmcarthur> okay, if we expland and generalize that to  Map A (Map B (Map C D)), what should the type of the function be?  :: Map A (Map B (Map C D)) -> <what here>?
16:07:16 <alexyk> jmcarthur: you can't, as the result is the same type
16:07:27 <jmcarthur> i know. i'm talking about generalizing
16:07:34 <jmcarthur> it can help
16:07:49 <jmcarthur> i'm not actually suggesting you switch to a Map representation
16:07:57 <alexyk> jmcarthur: Map C (Map B (Map A D))
16:08:02 <jmcarthur> okay
16:08:08 * jmcarthur thinks
16:08:40 <Saizan> in general, lists should work fine as "generators"
16:08:41 <alexyk> for each A on a day B, we store the number of tweets to each C which A talked to as D.
16:09:15 <alexyk> I call it replies.  Mentions are the opposite of replies.  We now need to create teh mentions graph from the replies, also structured by day.
16:09:40 <alexyk> note how compact Clojure is, btw
16:09:40 <jmcarthur> @djinn (a -> b -> c -> d) -> (c -> b -> a -> d)
16:09:41 <lambdabot> f a b c d = a d c b
16:09:48 <jmcarthur> there! ;)
16:10:03 <Saizan> alexyk: hard to read on a single line like that though :)
16:10:15 <alexyk> jmcarthur: where do I get the f?  :)
16:10:21 <jmcarthur> @. pl djinn (a -> b -> c -> d) -> (c -> b -> a -> d)
16:10:21 <lambdabot> f = flip . (flip .) . flip
16:10:30 <jmcarthur> okay that's not helpful
16:10:45 <jmcarthur> alexyk: the f is what you get if you apply lookup functions to those maps
16:11:09 <jmcarthur> i'm just wrapping my mind around it and kind of playing around
16:11:15 <alexyk> Saizan: http://paste.pocoo.org/show/237692/
16:11:54 <alexyk> same thing a bit delineated.  With sexps, you can just arrow-up in repl and develop a whole program in one line.
16:13:50 <alexyk> Clojure has a sorted-map compatible with {}, which allows me to store days in sorted order, but in Haskell I just use IntMap for now.
16:14:02 <alexyk> If I could have SortedIntMap, I could use that.
16:14:10 <Saizan> ?
16:14:29 <alexyk> Saizan: sorted-map is a thing which always iterates in sorted order
16:14:36 <alexyk> and shows as such
16:14:42 <Saizan> alexyk: sorted wrt values or keys?
16:14:47 <alexyk> Saizan: keys
16:15:04 <alexyk> Oh, I guess Map is already like that?
16:15:06 <Saizan> ?type Data.IntMap.toAscList 
16:15:07 <lambdabot> forall a. IM.IntMap a -> [(IM.Key, a)]
16:15:14 <alexyk> yep
16:15:31 <alexyk> so OK, IntMap is good.
16:15:37 <jmcarthur> @let flipMap = M.fromList . map swap . M.toList
16:15:38 <lambdabot>  Defined.
16:15:40 <jmcarthur> :t flipMap
16:15:42 <lambdabot> forall a k. (Ord k) => M.Map a k -> M.Map k a
16:16:01 <jmcarthur> :t flipMap `fmap` (flipMap `fmap`) `fmap` flipMap
16:16:02 <lambdabot> forall a a1 k. (Ord k, Ord a1, Ord a) => M.Map (M.Map a1 k) a -> M.Map (M.Map k a1) a
16:16:17 <jmcarthur> hmm, wrong
16:16:30 <jmcarthur> oh, duh, flipMap isn't like flip
16:19:25 <Saizan> ?type \g -> [M.singleton c (M.singleton b (M.singleton a d)) | (a,m') <- M.toList g; (b,m'') <- M.toList m'; (c,d) <- M.toList m'' ]
16:19:26 <lambdabot> parse error on input `;'
16:19:36 <Saizan> ?type \g -> [M.singleton c (M.singleton b (M.singleton a d)) | (a,m') <- M.toList g, (b,m'') <- M.toList m', (c,d) <- M.toList m'' ]
16:19:37 <lambdabot> forall k k1 k2 a. M.Map k (M.Map k1 (M.Map k2 a)) -> [M.Map k2 (M.Map k1 (M.Map k a))]
16:19:51 <Saizan> and then some unionWith?
16:19:57 <Saizan> ?type M.unionWith
16:19:58 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
16:20:29 <Saizan> ?type \g -> M.unionWith (M.unionWith M.union) $ [M.singleton c (M.singleton b (M.singleton a d)) | (a,m') <- M.toList g, (b,m'') <- M.toList m', (c,d) <- M.toList m'' ]
16:20:30 <lambdabot>     Couldn't match expected type `M.Map k2 (M.Map k1 (M.Map k a))'
16:20:31 <lambdabot>            against inferred type `[a1]'
16:20:31 <lambdabot>     In the second argument of `($)', namely
16:21:15 <Saizan> ?type \g -> foldl' (M.unionWith (M.unionWith M.union)) M.empty $ [M.singleton c (M.singleton b (M.singleton a d)) | (a,m') <- M.toList g, (b,m'') <- M.toList m', (c,d) <- M.toList m'' ]
16:21:16 <lambdabot> forall k k1 k2 a. (Ord k, Ord k1, Ord k2) => M.Map k (M.Map k1 (M.Map k2 a)) -> M.Map k2 (M.Map k1 (M.Map k a))
16:22:13 <Saizan> ?type \g -> M.unionsWith (M.unionWith M.union)) $ [M.singleton c (M.singleton b (M.singleton a d)) | (a,m') <- M.toList g, (b,m'') <- M.toList m', (c,d) <- M.toList m'' ]
16:22:14 <lambdabot> parse error on input `)'
16:22:22 <Saizan> ?type \g -> M.unionsWith (M.unionWith M.union) $ [M.singleton c (M.singleton b (M.singleton a d)) | (a,m') <- M.toList g, (b,m'') <- M.toList m', (c,d) <- M.toList m'' ]
16:22:23 <lambdabot> forall k k1 k2 a. (Ord k, Ord k1, Ord k2) => M.Map k (M.Map k1 (M.Map k2 a)) -> M.Map k2 (M.Map k1 (M.Map k a))
16:23:02 <Saizan> if someone is willing to test it.. :)
16:23:14 <jmcarthur> honestly it seems like this would be better by simply using a different data structure to begin with. flipping arrows sucks
16:23:48 <alexyk> Saizan: now each map is like 3 GB in RAM,  is that toList OK?
16:23:49 <jmcarthur> RDBMSs do this kind of thing right
16:24:06 <alexyk> jmcarthur: this stuff works already, it fixed the GC :)
16:24:11 <jmcarthur> heh
16:24:40 * mtnviewmark wonders how you get lambdabot to use qualified imports like Data.Map as M, and can type M.fromList...
16:24:56 <Saizan> alexyk: toList is plenty lazy, this is probably not the optimal way though
16:25:03 <jmcarthur> definitely not
16:25:11 <alexyk> mtnviewmark: Saizan has a backdoor apparently :)
16:25:28 <Saizan> mtnviewmark: see Pristine.hs/L.hs
16:26:30 <Saizan> if i knew any clojure we could probably port your code, unless it uses mutation in a substantial way
16:27:39 <alexyk> Saizan: Clojure is immutable, except for transients which tell it to use mutation for efficency but it all looks the same.  You create a transient and add ! to ops, then call persistent! on the result; those can be dropped and you get your immutable code back.
16:27:55 <Zeiris> Has anyone used Thrift with Haskell? Is it bugfree + practically usable?
16:27:56 <alexyk> also, some mutable stuff is in atoms and refs, for concurrency
16:28:11 <Zeiris> Last I downloaded it, they had things like buggy Enum instance derivations :(
16:28:58 <alexyk> Saizan: Clojure is very simple code there: unroll teh nested map of map of map into a sequence of 4-tuples (from,day,to,n) and then reduce that list into the new nested map.
16:29:34 <jmcarthur> aha
16:30:14 <alexyk> so when you create each tuple (from,day,to,n), you simply emit it already reshuffled as (to,day,from,n), and then stick into a nested map, adding n's in teh leaves
16:30:46 <Saizan> the addition part is what doesn't make sense
16:31:37 <Arnar> hi all
16:31:44 <jmcarthur> Saizan: it's like fromListWith (+)
16:31:53 <jmcarthur> iiuc
16:33:04 <alexyk> Saizan: duh.  Probably addition is unnecessary.
16:33:05 <Arnar> does anyone know a way of observing haskells lazyness in the following way: I write an expression depending on several calls to ao function - and whenever that function is invoked I want to log it *and the return value*
16:33:07 <jmcarthur> when you shuffles the keys around, the first key is no longer necessarily unique, nor the second, no the third
16:33:12 <jmcarthur> *nor
16:33:15 <jmcarthur> i think
16:33:23 <Saizan> ah, makes sense
16:33:34 <alexyk> but under the same day, we shouldn't get any different A talking to our B
16:33:34 <Saizan> so i'd need unionWith (+) at the end?
16:33:50 <Saizan> alexyk: (res to (sorted-map)) is like a lookup with a default?
16:34:02 <alexyk> Saizan: exactly
16:34:22 * jmcarthur is not even trying to read the clojure
16:34:42 <alexyk> map, here res, is a function looking up arg to in itself, returning an empty sorted-map if not found
16:34:56 <jmcarthur> ah!
16:35:03 <alexyk> each map is a self-looking-up function (m key)
16:35:22 <alexyk> each keyword looks up itself in a map too, as (:key m)
16:35:56 <alexyk> (m key default) is with the default
16:35:58 <Saizan> ok, i can give a literal translation then, if you like
16:36:13 <jmcarthur> Arnar: Debug.Trace? this is just for debugging i assume
16:36:24 <alexyk> Saizan: sure!  I need to drop the plus though as it's a bug :)
16:36:44 <jmcarthur> just for the record, the nested intmap flipping doesn't seem like it would be very efficient to me
16:37:00 <alexyk> jmcarthur: recorded in the annals
16:38:02 <alexyk> Saizan: I'm specifically curious whether Haskell can unroll into 4-tuples with some pretty syntax sugar similar to Clojure's for generator
16:38:24 <alexyk> or is there only list generating sugar?
16:38:30 <alexyk> well, we need a list anyways
16:38:39 <jmcarthur> sugar?
16:38:48 <jmcarthur> you mean list comprehensions?
16:38:51 <alexyk> jmcarthur: syntax :)
16:38:54 <alexyk> yes
16:39:02 <jmcarthur> ah. i know of nothing similar for tuples
16:39:12 <alexyk> jmcarthur: I mean list of tuples.
16:39:12 <Saizan>  [(c,b,a,d) | (a,m') <- M.toList g, (b,m'') <- M.toList m', (c,d) <- M.toList m'']
16:39:21 <Saizan> that's what i'd think of
16:39:23 <alexyk> yayyay!
16:39:53 <alexyk> Saizan: where's m without any '?
16:40:00 <jmcarthur> g i think
16:40:19 <Saizan> alexyk: heh, forgot it :) the initial Map is g
16:40:19 <Arnar> jmcarthur: mm.. not just for debugging
16:40:30 <jmcarthur> :t \g -> [(c,b,a,d) | (a,m') <- M.toList g, (b,m'') <- M.toList m', (c,d) <- M.toList m'']
16:40:31 <lambdabot> forall k k1 k2 a. M.Map k (M.Map k1 (M.Map k2 a)) -> [(k2, k1, k, a)]
16:40:49 <Arnar> jmcarthur: for dependency tracking (testing some theory, not for production)
16:41:16 <jmcarthur> Arnar: ah, well, as long as it's not for "real" software, you can just use the debugging facilities i'm sure ;)
16:41:29 <Arnar> jmcarthur: but I assume the exact semantics of the call-by-need is hidden from the language on purpose
16:41:33 <Arnar> right :)
16:41:45 <jmcarthur> Arnar: in fact, haskell is not specified as call-by-need
16:41:53 <jmcarthur> it's simply "non-strict"
16:41:55 <Arnar> jmcarthur: I can sort of get what I want with a simple writer monad, except for storing the values of the function
16:42:00 <Arnar> ah.. makes sense
16:42:18 <jmcarthur> using a monad orders the results though
16:42:28 <jmcarthur> so using writer to watch evaluation order is doomed to failure
16:42:34 <Arnar> right
16:42:47 <alexyk> Saizan: cool!  I was thinking of improving Clojure by using its group-by, to first group by first key and merge all, i.e. sort the list of 4-tuples lexicographically by each position.  Wonder if that will speed up recreation time.
16:42:53 <Arnar> perhaps I'm barking up the wrong tree, I sort of care about the order as well
16:43:21 <jmcarthur> i don't think i understand
16:43:23 <alexyk> Saizan: I wonder what can be used in Haskell to speed up a fold which will then reassemble
16:43:48 <Arnar> jmcarthur: say I have a function "ask" .. which takes a query and by some external mechanism looks up an answer
16:43:52 <Saizan> alexyk: maybe my nested unions above sort of do that
16:44:08 <jmcarthur> Arnar: so it's an IO action?
16:44:16 <jmcarthur> or monadic, in any case?
16:44:36 <Arnar> jmcarthur: now I want (on a call by need basis) evaluate an expression with calls to this function.. and in the result I want to record the questions that actually required answers
16:44:49 <Arnar> the answer to a question can later affect what questions are asked, so the order matters
16:45:10 <Arnar> jmcarthur: yes.. perhaps I need to model our little extended lambda calc as an embedded dsl
16:45:25 <jmcarthur> okay, so you don't really care about lazy evaluation at all
16:45:27 <alexyk> Saizan: ah ok.  Well I'll give it a try in an hour or so and will report back :)
16:45:40 <Arnar> jmcarthur: hmm.. yes
16:46:01 <Saizan> alexyk: you could also parellelize this i guess, since unions are monoidal anyhow
16:46:06 <jmcarthur> Arnar: i would just wrap ask with a function in IO or Writer, personally
16:46:17 <Arnar> jmcarthur: in (\x.\y.x) (f q1) (f q2) I don't want the result to coantain q2 in the "log"
16:46:22 <alexyk> Saizan: I know of no parallel syntax yet!
16:46:41 <alexyk> or semantics except STM is the word :)
16:47:03 <alexyk> in Clojur eyou replace a map by pmap and get speedu if the prog is right
16:47:04 <nominolo> preflex: seen chrisdone
16:47:04 <preflex>  chrisdone was last seen on #haskell-blah 16 minutes and 33 seconds ago, saying: i'm gonna by myself an abacus
16:47:05 <jmcarthur> Arnar: if ask is monadic already then you will be forced to invoke it in a well-defined order
16:47:16 <Saizan> alexyk: you wouldn't use STM for this in haskell
16:47:29 <Arnar> jmcarthur: ok.. I did a writer thing. lets put the order aside for the moment..
16:47:29 <jmcarthur> Arnar: so the answers you don't end up needing you shouldn't accidentally ask for anyway
16:47:34 <Veinor> clearly chrisdone is trying to  get his abacus on IRC
16:47:35 <Saizan> alexyk: and yeah, GHC has parMap and friends :)
16:47:55 <alexyk> Saizan: so I need like a different data structure?
16:48:08 <Arnar> jmcarthur: say I have x <- ask q1; y <- ask q2; return q1
16:48:21 <Arnar> jmcarthur: is there any way I can not have q2 end up in the log?
16:48:27 <Saizan> alexyk: no, you'd just need to use a parallelized fold, afaiu
16:48:33 <alexyk> good
16:48:40 <jmcarthur> Arnar: either don't ask it, or handle your logging outside of the implementation of ask
16:49:39 <Arnar> jmcarthur: "outside" being e.g. with debugging facilities or some unsafePerformIO or similar?
16:49:40 <jmcarthur> Arnar: if you must ask even if you don't need the answer then you can only do x <- ask; log q1 x; y <- ask q2; return q1
16:49:53 <jmcarthur> Arnar: "outside" being what i just suggested
16:50:03 <Arnar> (the expression is not necessarily written by me.. I still want to analyze its evaluatino)
16:50:51 <jmcarthur> Arnar: expressions are intentionally opaque once constructed. the only means you have of observing them is with unsafe things, like unsafePerformIO or trace or something
16:51:11 <Arnar> jmcarthur: right.. and I'm happy with that
16:51:22 <Arnar> but the semantics will never be well defined I guess
16:51:28 <jmcarthur> right
16:51:41 <Arnar> ok, cool.. thanks
16:51:50 <Arnar> I might just implement our semantics by hand in hs or agda
16:52:08 <Arnar> was just wondering if we could turn our theory thing in a somewhat usable hs library
16:52:29 * Saizan wonders how faster "M.fromList" vs. "M.unions . map singleton" is
16:53:52 <monochrom> M.unions . map singleton sounds like a lot of work :)
16:54:39 <alexyk> Saizan: what would be thr fromList version in full?  I'll rty both
16:54:42 <alexyk> try
16:55:08 <alexyk> monochrom: let's exercise the runtime :)
16:57:11 <Saizan> \g -> M.fromListWith (M.unionWith M.union) $ [(c , M.singleton b (M.singleton a d)) | (a,m') <- M.toList g, (b,m'') <- M.toList m', (c,d) <- M.toList m''] <- like this
17:00:15 <alexyk> Saizan: ok, here're teh two versions I'll compare: http://paste.pocoo.org/show/237712/ -- correct?
17:00:30 <alexyk> except exporting (invert1.invert2)
17:00:36 <alexyk> ,
17:03:28 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27464#a27464 <- direct translation
17:04:11 <Saizan> mh, maybe it needs some $! for those assoc's ..
17:04:17 <Saizan> alexyk: make sense
17:04:22 <Saizan> *makes
17:04:52 <alexyk> yeah, any strictification is probably good
17:07:30 <alexyk> Saizan: thanks for the direct, very cool
17:08:46 <Saizan> alexyk: i guess we should also use the strict versions of fromListWith and unionsWith
17:10:20 <Saizan> but there aren't..
17:11:22 <alexyk> Saizan: yeah, glaring omissions in light of my big-ass maps :)
17:11:51 <alexyk> bbl
17:14:19 <soupdragon> > (\k->((3+sqrt(8)^(2*k)+(3-sqrt(8)^(2*k)-2)/32) . [1..]
17:14:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:14:24 <soupdragon> > (\k->((3+sqrt(8)^(2*k)+(3-sqrt(8)^(2*k)-2)/32)) . [1..]
17:14:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:14:45 <Saizan> mh, IntMap doesn't even have insertWith'
17:15:09 <ddarius> Perhaps its insertWith is insertWith' ?
17:15:15 <soupdragon> > (\k->((3+sqrt(8)^(2*k))+(3-sqrt(8)^(2*k)-2)/32)) . [1..]
17:15:16 <lambdabot>   [10.781250000000002,65.03125000000003,499.03125000000034,3971.0312500000036...
17:18:16 <ddarius> Why can't "Lisps" settle on a name for the function defining form?
17:19:00 <Saizan> Prelude Data.IntMap> let m = insertWith undefined 1 'c' $ fromList [(1,'a'),(2,'b')]
17:19:04 <Saizan> Prelude Data.IntMap> (m ! 2, m ! 1)
17:19:06 <Saizan> ('b',*** Exception: Prelude.undefined
17:19:12 <Saizan> doesn't seem very strict..
17:19:48 <ddarius> :t M.insertWith
17:19:49 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
17:33:41 <alexyk> Saizan: I use a strictified IntMap anyways
17:33:51 <alexyk> you can assume it's strict enough
17:35:08 <alexyk> ddarius: I guess so that you can distinguish what "lisp" you see right away! :)
17:35:14 <poucet> BAHUG here I come =
17:35:14 <poucet> =)
17:35:35 <alexyk> BA = Boston Area?
17:35:56 <mee> poucet: ah, I wanted to go to that but am stuck at work :-/
17:36:20 <mee> alexyk: Bay Area
17:36:33 <alexyk> eewwww
17:37:06 <alexyk> mee: who are the biggest users?  are there any commercial ones?
17:38:30 <mee> of the BAHUG? It's hosted by Engine Yard. I don't know if there is any direct corporate involvement. If you meant Haskell itself, the intro to RWH documents that as well as I've seen anywhere
17:39:48 <BMeph> I'd go to a SCHUG...but don't ask me how to pronounce it! :)
17:40:25 <poucet> alexyk: I'm visiting the US/SFO for 3 weeks, so I thought it'd be nice to go =)
17:40:53 <alexyk> BMeph: SC is what, South Carolina?
17:41:02 <alexyk> or Source Code?
17:41:11 <alexyk> or Science of Coconuts?
17:41:37 <BMeph> Southern California
17:41:43 <alexyk> BMeph: ewww
17:42:05 <alexyk> retirees and Hollywood
17:42:13 <alexyk> (science of coconuts after all)
17:42:17 <BMeph> (I'm pretty sure the "Bay Area" in question is San Francisco's...)
17:42:34 <mee> BMeph: correct
17:42:45 <alexyk> Bay Area means "trapped in sight of SF, unable to visit really"
17:44:01 <BMeph> alexyk: Yeah..."Napa Valley HUG" would likely get a lot of wine-swilling codeing going on... :D
17:44:12 <BMeph> *coding
17:44:34 <hpc> BMeph: there's always the Balmer Peak...
17:45:09 <BMeph> hpc: Mmm...sounds...Balmy! :D
17:45:13 <mee> poucet: have you been to a BAHUG before? (have there been previous meetings?)
17:45:37 <alexyk> Ballmer peak?
17:46:02 <hpc> silly joke RE: alcohol and coding
17:47:00 <BMeph> poucet: Since you're just visiting, you could be a BAHUG bum! :D
18:04:56 <etpace> hmm, will writing to a Control.Concurrent.Chan far more than it is being read cause a stack overflow?
18:07:39 <kmc> why would it be a stack overflow?
18:07:48 <kmc> it will fill up the heap, yes
18:07:53 <etpace> I'm not sure, i'm trying to find out why I'm getting one
18:08:54 <augur> so what IS the distinction between evaluation and execution
18:09:09 <hpc> evaluation is the reduction of a thunk
18:09:23 <hpc> execution is sliding the instruction pointer over the action, etc
18:10:18 <augur> aha.
18:10:32 <kmc> augur, evaluation is computation.  applying functions to arguments, pattern matching, and so forth
18:10:45 <BMeph> Evaluation is what something means. Exacution is what something does. ;)
18:10:46 <kmc> it's the bit of Haskell which is really nicely modeled by the lambda calculus, with its one evaluation rule (beta reduction)
18:11:00 <BMeph> *Execution
18:11:04 <kmc> execution is taking a description of how to do stuff, and doing it
18:11:28 <kmc> in Haskell a "description of how to do stuff" is for example a value of type (IO a)
18:12:02 <hpc> in other languages like say, C
18:12:09 <kmc> such values have no special property in the world of pattern matching and function application
18:12:11 <hpc> it would be the difference between defining a function and calling it
18:12:25 <augur> ah ok. i see the distinction you're making.
18:12:32 <kmc> they only magically perform effects on the real world when they're handed off to the runtime system's execution thingy
18:12:47 <augur> i think.
18:13:01 <hpc> you could make a C function that takes a function pointer and calls the function three times
18:13:06 <augur> so where in this does a rewriting system that implements the lambda calculus sit?
18:13:24 <hpc> rewriting sits in evaluation
18:13:40 <augur> a rule like   (\x.M) N => M[x:=N]   is a description of how to do beta reduction
18:13:42 <hpc> evaluation can be easily tweaked in ways that do not change meaning
18:14:05 <Scala> I'm just starting to learn haskell, isn't there a command where I can run an interpreter over a source file and get a result without manually compiling and running?
18:14:09 <kmc> augur, it's either an explicit part of the runtime system, or implicit in the generated code
18:14:14 <Eduard_Munteanu> Hi.
18:14:16 <hpc> Scala: ghci
18:14:16 <kmc> Scala, ghci will load files
18:14:22 <soupdragon> runhaskell F.hs
18:14:31 <kmc> «ghci foo.hs» will load all of foo.hs, then give you an interactive prompt in the scope of that file
18:14:47 <Scala> Oh, I think I was looking for runhaskell
18:14:50 <Scala> let me give it a shot
18:14:59 <augur> kmc: ah, so its about explicitness ~ whether the program is a series of instructions to perform vs. a value to determine by (unspecified) instructions
18:15:30 <kmc> kind of, yes
18:15:51 <kmc> augur, running a Haskell program is a two-step process:  first, evaluate main, then execute the result
18:16:09 <kmc> first, compute what to do, then do it
18:16:24 <augur> wait, how can you compute what to do
18:16:27 <augur> when computing is what to do
18:16:52 <kmc> "what to do" is something like "print 'Hello world'" or "ping google.com"
18:16:55 <kmc> actions to take in the real world
18:17:13 <kmc> main has type IO ()
18:17:17 <augur> ah, you mean determine the side effects, ok.
18:17:20 <kmc> which means it evaluates to a description of what to do in the real world
18:17:23 <kmc> yeah
18:17:27 <augur> now i see.
18:17:29 <kmc> though it's questionable whether they're 'side' ;)
18:17:35 <augur> ;P
18:17:46 <kmc> execution has effects and results; evaluation is pure computation on arguments and return values
18:17:51 <augur> i let my computers run without IO!
18:18:02 <augur> i inspect turing machine tape directly!
18:18:13 <kmc> and we don't have a type for impure functions
18:18:28 <kmc> because a pure function can return an action
18:18:42 * BMeph thinks DNA makes excellent TM tape!
18:18:44 <djahandarie> "return values". I think this phrase has to be outlawed in Haskell
18:19:00 <djahandarie> in discussion of Haskell*
18:19:03 <djahandarie> Not in the language itself :P
18:19:40 <Eduard_Munteanu> Yeah, return causes much confusion.
18:19:46 <etpace> Is there a profiling method to detect a stack overflow? find out what function calls/data is causing it?
18:19:55 <Veinor> let xs = "return values"
18:19:57 <Veinor> compile error!
18:20:26 <djahandarie> Or just... let values = "oh no" in return values :: [String]
18:20:27 <djahandarie> lol
18:23:07 <augur> kmc: to me, this distinction between evaluation and execution is somewhat empty, since I don't take computation to require IO
18:23:36 <kmc> augur, computation in Haskell is evaluation only
18:24:51 <kmc> except that something is forcing that evaluation... whether you "print" it in main, or implicitly at the GHCi prompt
18:25:04 <augur> im not really sure how haskell /works/. i mean, i take it that you're saying that haskell proper is all this junk that is up at the abstract level, whereas the stuff below that in the machine itself well thats not haskell?
18:25:12 <kmc> i'm not saying that at all
18:25:16 <kmc> though it's a true statement
18:25:22 <augur> ok then i dont follow at all what you mean
18:25:39 <kmc> by what
18:26:00 <kmc> i'm not trying to say "Haskell is evaluation, execution is implementation details"
18:26:01 <augur> by saying that computation in haskell is evaluation only
18:26:35 <mwotton> anyone know if haskell-src-meta is getting fixed for 6.12? is matt morrow around?
18:26:58 <kmc> augur, when we talk about execution we mean effects, so if your program has no effects, it doesn't do any execution
18:27:17 <kmc> in the specific sense we mean here
18:27:31 <kmc> of course in the more general sense, any time your computer does anything it's "executing"
18:27:39 <EvanR> the only true program is one where the user types the input on the punch cards, and has the single effect of printing the answer to the tape ;)
18:29:02 <augur> ok so can you describe in painfully explicit detail how evaluating   main = putStr "hello, world!"   works?
18:29:13 <EvanR> :t putStr
18:29:14 <lambdabot> String -> IO ()
18:29:26 <EvanR> :t (putStr "hello, world!")
18:29:27 <lambdabot> IO ()
18:29:30 <EvanR> the end
18:29:36 <kmc> augur, the details of that are implementation-dependent, because the values in type (IO ()) are abstract
18:29:42 <kmc> the constructors of the type IO () are not exposed
18:29:58 <EvanR> putStr "foo" is like a constructor
18:30:07 <augur> well, pretend you can give me _some_ kind of detail :P
18:30:38 <kmc> but let's take this implementation of IO:http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27471#a27471
18:30:42 <augur> just something rough, so i get an idea of what it means to evaluate that, versus what it would mean to /execute/ it
18:30:43 <kmc> nice, concrete algebraic type
18:30:45 <mwotton> @seen mmorrow
18:30:45 <preflex>  mmorrow was last seen on #ghc 177 days, 22 hours, 32 minutes and 59 seconds ago, saying: * mmorrow is rtfm'ing
18:30:45 <lambdabot> Unknown command, try @list
18:31:10 <Veinor> hm.
18:31:14 <kmc> (it's a generalized algebraic data type, a GADT, because we encode some properties of how stuff is allowed to glue together into the types of constructors)
18:31:51 <kmc> augur, now consider the expression (PutStr "hello, world!")
18:32:08 <kmc> this is not much different from (Just "hello, world!")
18:32:35 <augur> ok..
18:32:43 <kmc> and we can force its evaluation
18:32:46 <kmc> e.g. using seq
18:32:54 <kmc> and nothing special happens
18:33:02 <augur> seq?
18:33:15 <kmc> seq is a function used to force evaluation where it would not otherwise occur
18:33:20 <kmc> it's probably a distraction to bring it up here
18:33:23 <augur> ok
18:33:26 <kmc> it's *not* related to ordering of execution
18:33:39 <kmc> anyway
18:34:17 <kmc> the value (PutStr "foo") is already evaluated
18:34:30 <kmc> it's in a "normal form"... there's no function to apply, no computation to perform by beta reduction
18:34:37 <augur> right
18:34:41 <kmc> so the story of evaluation is done
18:34:49 <kmc> now you imagine there's a separate part of the runtime system
18:34:54 <augur> ok
18:34:59 <kmc> which can take one of these values, inspect its constructors, and actually do what was described
18:35:15 <kmc> you can't write this part in standard Haskell, without resorting to an existing implementation of the same
18:35:19 <augur> aha
18:35:34 <augur> so take a (PutStr "foo") and print the string "foo"
18:35:37 <kmc> yes
18:35:48 <augur> i see
18:35:57 <kmc> now, consider another possible implementation of the IO type
18:36:15 <augur> i take it this evaluate/execute stuff is interleaved?
18:36:24 <kmc> yeah
18:36:34 <kmc> to execute something, you have to evaluate it, to know what constructor is at the top
18:36:46 <augur> i cant construct a particular example, but where evaluation could leads to an execution that inputs data that could change later evaluation
18:36:49 <kmc> but evaluation never causes execution, unless you're playing various tricks
18:37:02 <kmc> e.g. unsafePerformIO, unsafeInterleaveIO
18:37:13 <augur> could leads, yeah. ok. "could lead" or "leads", either one of those. heh.
18:37:34 <kmc> anyway here's another IO implementation
18:37:54 <kmc> data IO a = IO Language.C.Syntax.AST.CTranslUnit
18:38:11 <augur> O_O
18:38:12 <augur> ok
18:38:14 <kmc> now IO actions are represented by C programs
18:38:48 <kmc> let's make it simpler, C statements represented as plain strings
18:39:17 <kmc> putStr x = IO ("puts(" ++ x ++ ");")
18:39:37 <augur> C? or Ruby? :P
18:39:53 <kmc> (IO x) >> (IO y) = IO (x ++ y)
18:40:08 <kmc> now, you can't stretch this too far
18:40:12 <kmc> without it getting really messy
18:40:15 <augur> aha yes. ok.
18:40:19 <augur> i get the gist of it
18:40:21 <kmc> it's a cute metaphor anyway
18:40:47 <kmc> Haskell is a pure functional language, whose programs produce and then run imperative programs
18:41:02 <augur> the whole of the haskell program is essentially the construction of an instance of an ADT which itself can be interpreted as a collection (sequence?) of instructions to execute
18:41:20 <kmc> yes, followed by the execution of those instructions
18:41:22 <kmc> http://conal.net/blog/posts/the-c-language-is-purely-functional/
18:41:30 <augur> yeah thats where i came from ;)
18:41:50 <augur> talking to you actually explained things
18:41:53 <augur> i feel enlightened!
18:41:53 <kmc> ^^^ if you squint hard enough, C is similar... a pure functional preprocessor language which outputs C programs
18:41:55 <augur> giddy, infact!
18:41:56 <kmc> cool :)
18:42:01 <kmc> yay
18:42:02 <augur> i am smiling uncontrollably!
18:42:30 <djahandarie> Hehe at (IO x) >> (IO y) = IO (x ++ y)
18:42:33 <conal> sadly, imperative programming has become the killer app of functional programming.
18:42:48 <augur> conal: how so?
18:42:53 <djahandarie> Killer app? Is this an iPhone or something?
18:43:04 <conal> augur: what kmc was saying
18:43:11 <augur> which where?
18:43:22 <conal> just above
18:43:26 <augur> the whole program-to-IO-monad transformation thing?
18:43:53 <conal> the success of IO (generating imperative programs)
18:43:59 <conal> s/programs/computations/
18:44:30 <Saizan> we like EDSLs afterall :)
18:44:36 <augur> still not sure i follow, but ok :D
18:46:25 <alexyk> if I say, in main, !x <- blah, I don't get x fully cooked right away.  Why?
18:46:54 <Saizan> ! only forces up to the outermost constructor
18:46:55 <alexyk> does strictness work in let !x = blah
18:47:04 <Saizan> so it depends on what x is.
18:47:08 <alexyk> Saizan: ok
18:47:19 <alexyk> is there a deepStrictify?
18:47:28 <alexyk> go down all constructor and enforce, enforce!
18:47:30 <augur> so kmc, how does this interleaving of execution with evaluation play out?
18:47:38 <Saizan> there's rnf/deepSeq
18:47:43 <alexyk> shootItUntilIt'sLay
18:47:48 <alexyk> Lazy
18:48:23 <alexyk> Saizan: Haskell is soo behind Clojure on invert
18:48:23 <kmc> augur, what do you mean by "play out"?
18:48:34 <Saizan> alexyk: invert?
18:48:44 <alexyk> Saizan: invert1/2
18:48:51 <alexyk> the ones you cooked up a=earlier
18:48:52 <Saizan> alexyk: ah, the function from before
18:48:55 <alexyk> yes
18:48:59 <augur> like, suppose i did something like   main = putStr "type a number" >> getStr >>= \x -> if x == "1" then putStr "one!" else putStr "not one!"
18:49:07 <kmc> ok
18:49:13 <augur> or whatever the closest real program like that is
18:49:24 <augur> i dont even know if thats valid. XD
18:49:29 <kmc> looks ok to me
18:49:38 <augur> man, im a better haskell hacker than i know
18:49:45 <alexyk> Saizan: well actually not that bad
18:50:20 <augur> but like, using the (PutStr "foo") ADT example you had before, instead of the c code version
18:50:32 <kmc> when you evaluate main, you'd get something (in our GADT representation from before) like Bind (putStr "type a number") (\_ -> Bind GetStr (\x -> if x == "1" then putStr "one!" else putStr "not one!"))
18:50:42 <kmc> err "... Bind getStr ..."
18:51:03 <mle> getStr?
18:51:08 <mle> :t getStr
18:51:09 <kmc> in fact the interior Bind should be (>>=) too
18:51:09 <lambdabot> Not in scope: `getStr'
18:51:14 <mle> maybe getLine?
18:51:30 <kmc> augur, point being, the Haskell implementation won't evaluate inside the lambda
18:52:03 <kmc> all the runtime executor will see is Bind (PutStr "type a number") (... an opaque function value ...)
18:52:13 <kmc> and so the place where execution calls into evaluation
18:52:32 <augur> ok, so it constructs an ADT where one part is an "instruction" of sorts, and the other part is the thing to evaluate to get what to do with the value that results from executing the instruction
18:52:52 <kmc> is that after executing the left half of a Bind, you need to apply the result to the function on the right, and evaluate it until you get another constructor
18:53:04 <kmc> in this case, the result is () and when you apply you immediately get another Bind ctor
18:53:08 <augur> right
18:53:12 <augur> ok interesting
18:53:26 <kmc> but there could be an arbitrary amount of computation there
18:53:29 <kmc> before it's decided what to do next
18:53:32 <augur> so you get execution order on IO because of how Bind works
18:53:40 <kmc> right.  Bind defines the order
18:53:47 <ddarius> because of how the RTS interprets Bind
18:53:49 <kmc> and it's not directly linked to evaluation order
18:54:03 <kmc> someone might go in and pre-evaluate some of your IO actions, and that'd be just fine
18:54:07 <augur> but not because Bind itself has some inherent order, but because of how Bind acts as an execution instruction
18:54:11 <kmc> yes
18:54:14 <augur> ok
18:54:18 <augur> eyes -> opened
18:54:33 <augur> mind -> blown
18:54:38 <kmc> :D
18:54:40 <augur> and other things the kinds say these days
18:54:47 <augur> kids
18:54:51 <kmc> now, the way GHC implements the IO monad could not be further from this nice conceptual world
18:54:55 <augur> or kinds, if you're feeling especially germanic
18:54:59 <augur> der kinder
18:55:07 <kmc> in order to get real machine code that looks like efficient imperative programs
18:55:11 <augur> das kindle
18:55:16 <kmc> rather than an interpreter looping over some ADT expressions
18:56:20 <ddarius> The way HBC did/does implement IO is a bit closer to the ADT route and is certainly more pleasant that GHC's implementation and HBC still outperforms GHC in some cases and does reasonably well overall.
18:56:41 <kmc> interesting
18:56:43 <kmc> how does it work?
18:56:49 <augur> and and and
18:56:56 <ddarius> I believe both it and Hugs use a continuation passing implementation.
18:57:56 <ddarius> augur: Polysyndeton
18:58:54 <augur> ddarius: you are not god of the KJV
18:58:55 <augur> :|
18:59:17 <ddarius> The result of the implementation should be similar to the ADT style with the dispatching part of the RTS fused in.
19:01:33 <soupdragon> SUGGESTION:  herd all the haskell category theory beginners into #haskell-math
19:01:43 <soupdragon> then we can ask each other questions about basic stuff
19:01:49 <Phyx-> boy... tabs are evil reincarnated
19:02:11 <soupdragon> like "Who put the funk in functor?"
19:02:38 <g_cross> @hoogle [Maybe a] -> [a]
19:02:39 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
19:02:39 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
19:02:39 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:03:09 <g_cross> COOL!  :-D
19:03:32 <Phyx-> cool hoogle or cool that the function exists?
19:03:39 <g_cross> hoogle  :-)
19:03:50 <monochrom> isn't haskell exciting?
19:04:21 <Phyx-> monochrom: only when tabs aren't used :/ i've been fighting compile errors for the last hour
19:04:52 <monochrom> be sure you know how haskell98 defines tab meaning if you use tab
19:05:18 <Phyx-> i'm not the one who used it
19:05:21 <Saizan> soupdragon: and who will answer?
19:05:21 <monochrom> it is actually the standard tab meaning cf 1970s terminals.
19:05:36 <Phyx-> monochrom: right, 8chars width
19:05:49 <monochrom> as opposed to modern day "you can customize everything" meaning
19:05:53 <soupdragon> Saizan, it would be a community effort and mutually beneficial to come up with answers
19:05:57 <ddarius> Saizan: The blind will lead the blind and the days of Men will end.
19:06:03 <Phyx-> but heck, I vote the ghc sources shoudln't contain tabs :/
19:06:53 * hackagebot HSFFIG 1.1.3 - Generate FFI import declarations from C include files  http://hackage.haskell.org/package/HSFFIG-1.1.3 (DmitryGolubovsky)
19:07:05 <monochrom> just tell your editor not to be smartassish about tabs. then you will get what the ghc developers get.
19:07:10 <BMeph> Phyx-: Sorry, they were all out of Fresca... ;
19:07:45 * ddarius thinks Fresca has been changed over time.
19:07:57 * Phyx- wonders what Fresca is
19:09:14 <shepheb> Phyx-: a delicious citrus flavour diet soda in North America
19:09:25 <ddarius> "diet" ?
19:09:25 <Saizan> with haskell one can always ask ghc in the end.. with CT i find it too easy to get lost between the various ways to look at the same thing and i wouldn't know how to easily do a sanity check 
19:09:27 <tensorpudding> more like disgusting
19:09:31 <shepheb> "sugarfree"
19:09:54 <bremner> carcinogenic :)
19:10:19 <Phyx-> how can "diet" or "sugarfree" be in the same sentence as "delicious"
19:10:58 <shepheb> Phyx-: I was shocked to discover it was sugarfree after trying it (it's rare in Canada). doesn't have that usual nasty aftertaste.
19:11:04 <shepheb> this is pretty wildly off-topic, though
19:11:31 <Phyx-> lol
19:12:07 <ddarius> So it sounds like they broke Fresca in 2005.
19:12:46 <ddarius> Saizan: You do the proofs to do a sanity check.
19:13:24 <Phyx-> this error makes no sense at all
19:13:31 <Phyx-> what's the parser looking ar
19:13:33 <Phyx-> at*
19:14:47 <monochrom> sugarfree salt is delicious
19:15:15 <monochrom> use a theorem prover for sanity check
19:15:36 <Phyx-> touche...
19:16:02 * ddarius occasionally uses sugar to cut the saltiness of food.
19:16:15 <ddarius> s/food/sauce
19:17:03 <monochrom> I do calculational proofs, which is close enough to theorem prover for the purpose of sanity check.
19:18:21 <lispy1> monochrom: calculational proofs = evaluational reasoning + identities?
19:18:38 <lispy1> er, equational reasoning not evaluational
19:20:07 <Saizan> ok, i guess i'm just lazy or waiting for nice support for CT in a theorem prover i know :)
19:21:44 <soupdragon> Saizan I want this too
19:22:03 <LearnYourselfSma> I've got a theoretical question about recursion
19:22:22 <soupdragon> yes
19:22:27 <soupdragon> ?
19:22:39 <LearnYourselfSma> A f() that refers to itself is clearly recursive
19:22:48 <LearnYourselfSma> but I could imagine other similar configurations
19:22:59 <soupdragon> well, lets use haskell notation
19:22:59 <LearnYourselfSma> where, for example, f1 points to f2 and vice-versa
19:23:03 <LearnYourselfSma> in a controlled manner
19:23:06 <Cale> LearnYourselfSma: sure
19:23:09 <kmc> yes, that's called mutual recursion
19:23:16 <LearnYourselfSma> Ok.
19:23:21 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
19:23:22 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
19:23:23 <monochrom> well, sometimes calculation proofs use implications too
19:23:34 <LearnYourselfSma> Well is there a _larger_ category that these examples belong to?
19:23:48 <LearnYourselfSma> Yet more specific than "control flow"
19:23:49 <Cale> hmm
19:24:15 <kmc> LearnYourselfSma, given a set of expressions, you can draw a graph of the "refers to" relation
19:24:22 <kmc> and partition that graph into connected components
19:24:34 <kmc> if a component is cyclic, it represents a group of mutually-recursive bindings
19:24:53 <kmc> Haskell compilers have to do something like this during type inference
19:25:23 <Cale> and when compiling mutually recursive blocks in terms of fix
19:25:28 <kmc> but basically, any pattern of recursive references is possible
19:25:53 <Cale> It's possible to turn any set of mutually recursive definitions into a single recursive definition of, say, a tuple of values.
19:26:10 <soupdragon> You can define a data type and a recursive function mutually, also (not in haskell, but the idea is sound)
19:26:16 <Cale> and then remove the recursion from that definition and use the function 'fix' to handle it.
19:26:22 <Cale> :t fix
19:26:23 <lambdabot> forall a. (a -> a) -> a
19:26:32 <Cale> fix f = x where x = f x
19:26:43 <LearnYourselfSma> kmc, but any pattern of recursive references would be referred to as mutually-recursive bindings?
19:26:44 <Cale> From fix, all other recursion can be built.
19:26:48 <kmc> > fix (\(evens, odds) -> (0 : map (+1) odds, map (+1) evens))
19:26:51 <Phyx-> hoogle setSession
19:26:51 <lambdabot>   mueval-core: Time limit exceeded
19:26:54 <kmc> > fix (\~(evens, odds) -> (0 : map (+1) odds, map (+1) evens))
19:26:55 <lambdabot>   <no location info>: parse error on input `->'
19:26:58 <Phyx-> @hoogle setSession
19:26:58 <lambdabot> No results found
19:27:02 <kmc> > fix (\(~(evens, odds)) -> (0 : map (+1) odds, map (+1) evens))
19:27:03 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
19:27:15 <monochrom> setSession is a method of class GhcMonad
19:27:41 <kmc> > fix (\x -> let (evens, odds) = x in (0 : map (+1) odds, map (+1) evens))
19:27:42 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
19:28:06 <ddarius> soupdragon: There's little point in that without dependent types.
19:28:15 <monochrom> setSession :: GhcMonad m => HscEnv  -> m ()
19:28:57 <Phyx-> monochrom: thanks
19:30:45 <Phyx-> yeah \o/ think it's finally compiling
19:30:49 <LearnYourselfSma> I'm not a computer scientist, but it seems to me that recursion etc. are doing something fundamentally different than other function/expression definiteions
19:31:07 <LearnYourselfSma> in that they let us "get under the hood" of control flow, which we normally cant
19:31:29 <Cale> LearnYourselfSma: well...
19:32:09 <Cale> LearnYourselfSma: In an untyped lambda calculus, we can construct recursion from the ground up.
19:33:05 <LearnYourselfSma> I understand that computationally they are quite similar
19:33:26 <LearnYourselfSma> But in terms of definition, couldn't recursion etc. be classified together?
19:33:31 <Cale> But if we want to have things be well-typed that's hard... unless we start with recursion at the type level.
19:33:34 <LearnYourselfSma> Defined?
19:33:49 <LearnYourselfSma> maybe I'm phrasing this badly
19:34:09 <soupdragon> LearnYourself, just define everything mutually (As haskell does), some things recurse some don't... no big deal
19:34:22 <LearnYourselfSma> Cale, no I'm sorry - i don't mean defined in therms of their type within haskell
19:34:25 <soupdragon> LearnYourself, you should work through SICP up to the second chapter
19:34:36 <LearnYourselfSma> I mean, if I am teaching a person haskell
19:34:55 <LearnYourselfSma> isn't there something I could call of these mutual-recursions?
19:35:14 <LearnYourselfSma> That makes clear the functionality they allow (looping etc.)
19:36:19 <LearnYourselfSma> soupdragon, I will
19:37:31 <int80_h> cabal list says I have yesod-examples installed, but I cannot find it. Where should I look?
19:38:20 <ddarius> int80_h: Applications should be in ~/.cabal/bin
19:38:28 <ddarius> If it was a user install.
19:39:06 <int80_h> I think "yesod-examples" would be a directory of yesod scripts of something
19:40:00 <Saizan> int80_h: when you install it you'll just get the executables built and put in ~/.cabal/bin, to see the sources use "cabal unpack yesod-examples"
19:40:43 <davekong> LearnYourselfSma: "looping" and recursion are not quite the same thing
19:41:18 <Cale> LearnYourselfSma: Well, the important thing is that you can define a value in terms of any other defined thing, regardless of order, and that includes the value itself.
19:41:59 <Cale> LearnYourselfSma: We could go on about nice restricted languages with weaker forms of recursion, but such things are probably not very interesting if you're teaching a beginner.
19:44:51 <QinGW> I write <code>add a b = a + b</code> to add.hs, I  ghci>:load add.hs, it return ok. but I can't use ghci>add 2 3   it report "add" not in scope. It comes from real world haskell book. other examples runs well.
19:46:26 <soupdragon> QinGW: doesn't make sense at all
19:46:32 <soupdragon> QinGW: that should work fine
19:47:04 <monochrom> you mean "I <kbd>ghci>:load add.hs</kbd>"
19:47:49 <Saizan> QinGW: anything else in add.hs?
19:48:00 <monochrom> also it works for me.
19:48:12 <Saizan> ..did you save the file?
19:52:06 <Eduard_Munteanu> Or perhaps he didn't invoke ghci on that file.
19:52:26 <monochrom> obsession with names is unhealthy for educational purposes. following Feynman, the interesting part should be "what if you write code like this, let's find out", not "what is this called, what is that called, now you can score full marks on a rote exam that tests you for reciting names"
19:58:51 <LearnYourselfSma> Cale: The destinction I'm trying to draw out (but maybe it's not worth distinguising) is that recursion and other "forms" of function interrelationships make the programmer able to do things they can't with other function "call" patterns
19:59:36 <LearnYourselfSma> So, if this is true, is there a larger category (in terms of how we talk, not in terms of the compiler) for all interrelationships which allow these possibilities?
20:00:15 <Eduard_Munteanu> LearnYourselfSma: um, just about anything useful is expressed by a Turing machine. But you don't really need actual recursion for that.
20:01:02 <Eduard_Munteanu> Actually recursion is implemented in terms of Turing machine operations.
20:01:22 <Eduard_Munteanu> Therefore in terms of looping constructs.
20:02:10 <Saizan> i'm pretty sure you can find a recursive step in the definition of how a turing machine computes :)
20:03:59 <Eduard_Munteanu> Hm, maybe, but I'm not sure it's _not_ possible to express it as looping.
20:04:22 <LearnYourselfSma> Eduard_Munteanu: Sorry, I don't understand how that helps. I'm talking about how I can define recursion as a category of interrelationship, in English - I'm not proposing redefining haskell to handle recursion differently
20:04:40 <Saizan> ah, well, the distinction between looping and recursion is quite artificial
20:05:18 <LearnYourselfSma> Eduard_Munteanu: Ohhh, I'm sorry - I do understand.
20:05:19 <soupdragon> Eduard_Munteanu: what do you think of my idea
20:05:50 <LearnYourselfSma> Eduard_Munteanu: You're saying that recursion doesn't really allow for any kind of looping that isn't possible with other methods. Correct?
20:06:07 <soupdragon> I said we should get all the category theory beginners (myself included) into one place - e.g. #haskell-math
20:06:37 <djahandarie> What's wrong with just #math
20:06:54 <djahandarie> Unless this is some sort of application in Haskell
20:07:02 <soupdragon> djahandarie: quite a lot lol
20:07:41 <Saizan> LearnYourselfSma: you can encode recursion with while loops and an explicit stack, if that helps
20:09:03 <LearnYourselfSma> Saizan: But we don't have while loops
20:09:17 <Eduard_Munteanu> soupdragon: um, it would be a good idea.
20:09:36 <soupdragon> Eduard, there's a few other people from here but I don't reember hteir nicks
20:09:38 <Eduard_Munteanu> #math isn't the best place for Haskell-applied category theory constructs.
20:10:12 <Eduard_Munteanu> LearnYourselfSma: like Saizan said
20:10:20 <cap11235> Can someone tell me the difference between an MVar and an IORef?
20:10:29 <monochrom> MVar is thread-safe
20:10:34 <Saizan> LearnYourselfSma: ah, in the context of haskell you could transform all the recursive definitions into non-recursive ones and fix, but that was said above
20:11:01 <cap11235> Thanks, monochrom
20:11:06 <ddarius> It also behaves more like IORef (Maybe a) rather than just IORef a.
20:11:12 <Eduard_Munteanu> soupdragon: dunno who you're referring to, but for example there's Edward Kmett who maintains category-extras.
20:11:15 <ddarius> @where beast
20:11:15 <lambdabot> I know nothing about beast.
20:11:31 <LearnYourselfSma> soupdragon: am I being exiled?
20:11:59 <soupdragon> LearnYourselfSma: huh??
20:11:59 <monochrom> MVar is a thread-safe 1-cell buffer
20:12:18 <ddarius> cap11235: Read this: http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
20:12:23 <cap11235> Then what about an IORef's atomicModify?
20:12:55 <soupdragon> LearnYourselfSma: me and some other people on here are learning basics of category theory - thought it would be useful to collect them all, you're welcome to join
20:13:06 <monochrom> there is no IORef's "atomicRead" to go with it
20:13:27 <ddarius> monochrom: readIORef is already (very likely) atomic
20:13:42 <ddarius> The issue is that you can't block on an IORef.
20:13:43 <monochrom> ok, unless someone assures that readIORef is atomic
20:14:04 <cap11235> So MVar's are blocking, then?
20:14:06 <Eduard_Munteanu> soupdragon: the problem is, AFAIK, #haskell-math was intended for people who wanted to use Haskell for Matlab/Octave-like computations.
20:14:18 * soupdragon doesn't have a problem with that
20:14:20 <ddarius> cap11235: Again, read the paper I linked you to.  It is a fun read.
20:14:21 <monochrom> yeah MVar is much easier to use for talking between threads.
20:14:42 <LearnYourselfSma> soupdragon: I'm sorry - I thought I was being banished to #math for my lack of comprehension
20:14:42 <cap11235> ddarius, the link isn't loading, and it isn't in archive.org
20:14:43 <ddarius> Why not #ct-beginners or something like that?
20:14:50 <LearnYourselfSma> soupdragon: :)
20:15:05 <soupdragon> LearnYourselfSma: you're not even in #math ??
20:15:12 <soupdragon> oh well
20:15:14 <monochrom> the link works for me. keep trying. maybe tomorrow
20:15:38 <ddarius> #math sucks
20:15:48 <monochrom> or Real World Haskell has MVar too
20:16:08 <cap11235> Ok, I found a mirror of it. Thanks!
20:16:09 <Eduard_Munteanu> ddarius: interestingly, there's a few people in there who hate Haskell or #haskell as well. Dunno why.
20:16:16 <LearnYourselfSma> soupdragon: I don't understand
20:16:19 <Saizan> cap11235: try with a proxy/different browser, research.microsoft.com is known to be look inaccessible for random reasons
20:16:24 <soupdragon> Eduard_Munteanu: those guys are trolls and idiots
20:16:32 <soupdragon> Eduard_Munteanu: I have them all on /ignore because they're abusive
20:16:39 <etpace> When something blocks indefinitely in an mvar -- whats the cause, trying to read when theres nowhere else to write?
20:16:46 <Eduard_Munteanu> soupdragon: um, AFAICT, they are competent idiots. Doesn't change much though :)
20:16:49 <monochrom> Yes.
20:17:08 <soupdragon> Eduard_Munteanu: still consider them scum
20:17:13 <Eduard_Munteanu> Heh.
20:17:28 <monochrom> do { r <- newEmptyMVar; takeMVar r }  hehe
20:17:38 <etpace> hmm
20:18:28 <drbean> Awodey's category theory book is at http://www.andrew.cmu.edu/course/80-413-713/
20:19:13 <Eduard_Munteanu> ddarius: I guess there's some sort of "they're taking away our beautiful and pure math and defiling it by applying it" frustration.
20:19:46 <ddarius> Eduard_Munteanu: I'm not talking about that at all.  I could care less if there are people in #math that don't like Haskell/#haskell.
20:20:23 <monochrom> if you use isEmptyChan there is a known bug blocking on MVar indefinitely
20:20:30 <Eduard_Munteanu> ddarius: yeah, I've seen there's some stupid elitism over there.
20:20:35 <Eduard_Munteanu> Not only what I mentioned.
20:20:48 <Eduard_Munteanu> drbean: I figure that isn't the 2010 edition.
20:21:02 <soupdragon> drbean, thanks
20:21:07 <soupdragon> the homeworks will be useful
20:21:07 <drbean> It says 2009.
20:21:08 <Eduard_Munteanu> Or is it? I just received it on paper a few days ago.
20:21:22 <soupdragon> wait. REAL PAPER?
20:21:27 <Eduard_Munteanu> soupdragon: yup.
20:21:30 <soupdragon> *jelous*
20:21:38 <drbean> What's different in the 2010 edition? I know he added exercises somewhere.
20:21:39 <Eduard_Munteanu> soupdragon: found it on amazon.co.uk, cheaper than on .com
20:22:26 <Eduard_Munteanu> drbean: hm, dunno, I'll try looking in the preface.
20:22:26 <ddarius> Eduard_Munteanu: I don't even care that much about that.  It just has an implicitly defined gamut of math that it covers, that gamut is pretty boring and low-level, and if you go outside that gamut you get no useful/interesting responses.  #not-math is somewhat better, but still pretty boring and limited.
20:22:59 <Eduard_Munteanu> ddarius: I see your point.
20:23:36 <soupdragon> sometimes there are good questions on AoPS but usually it's bizarre contrived inequalities
20:23:50 <Eduard_Munteanu> soupdragon: AoPS?
20:24:01 <soupdragon> http://www.artofproblemsolving.com/Forum/
20:24:05 <Eduard_Munteanu> soupdragon: thanks.
20:24:58 <Eduard_Munteanu> Well this is probably bound to happen if you lump any pure knowledge together and name it "math".
20:25:58 <monochrom> what we need is a #haskell-blah membership drive
20:26:58 <Eduard_Munteanu> monochrom: heh, what's that about?
20:27:04 <monochrom> #haskell-blah is where friendly learned interested interesting people do math
20:27:17 <cap11235> How interesting!
20:27:18 <Eduard_Munteanu> Oh, nicely put :)
20:27:59 <BMeph> I thought that was what #haskell-in-depth was for... :)
20:28:06 <ddarius> BMeph: Nope.
20:28:24 <ddarius> Also monochrom's description of #haskell-blah is a bit... less than comprehensive...
20:28:47 <monochrom> "hi I'm wondering about noncommutative rings" would not fit in #haskell-in-depth
20:29:06 <BMeph> Since #haskell-blah is has (supposedly) everything but Haskell (which works out to Haskell stuff about 10% of the time). :)
20:29:06 <soupdragon> ummmmm
20:29:09 <soupdragon> people talking about METH
20:29:09 <cap11235> I just joing #haskell-blah, and there was a message about prostitution as the first thing I saw.
20:29:12 <soupdragon> .........
20:29:14 <soupdragon> not MATH
20:29:20 <Cale> I thought that #haskell-blah was mostly about sex
20:29:20 <ddarius> BMeph: Really the impetous for #haskell-in-depth was to move dcoutts and co's long and detailed descriptions of the workings of Cabal and such elsewhere.
20:29:31 <Cale> But I haven't been around there for a long time
20:29:38 <Eduard_Munteanu> LOL, now I see.
20:30:02 <soupdragon> "what we need is #haskell-blah-blah"
20:30:08 <BMeph> Cale: Sorry, Cale, Raynes hasn't been in -blah for months... ;)
20:30:11 <ddarius> Cale: Maybe at one point.  I'm not even sure I'd say sex had a plurality of the talk-time now.
20:30:15 <monochrom> I assure you if you start spewing your math in #haskell-blah, the sex and meth will cease.
20:30:25 <soupdragon> hey conal
20:30:35 <ddarius> monochrom: I assure you they won't cease.  You'll just also have a math conversation going as well.
20:30:39 <conal> soupdragon: hi
20:30:39 <Eduard_Munteanu> I think some topic-oriented math channels would be nice, like #algebra, #topology etc.
20:30:42 <soupdragon> whats neww
20:30:45 <Raynes> BMeph: How did my name get there? :o
20:30:59 * BMeph laughs
20:31:16 <Cale> There used to be an algebraic geometry channel
20:31:32 <Cale> Maybe there still is... I forget what it was called
20:31:39 <monochrom> anyway, math in #haskell-blah is not new, people have done that before, you just need to do more
20:31:39 <soupdragon> there's #model-theory
20:31:47 <ddarius> Cale: Lost in the scheme of things.
20:31:50 <soupdragon> no #modeltheory
20:31:59 <Eduard_Munteanu> Nice.
20:32:04 <soupdragon> but the membership is one person
20:32:05 <BMeph> Eduard_Munteanu: A noble thought, but I doubt we'd have enough traffic for all of those.
20:32:15 <Saizan> ddarius: no, that's what #hackage is for
20:32:36 <Saizan> ddarius: #haskell-in-depth was for edwark's CT :)
20:32:45 <monochrom> I wonder if "lost in the scheme of things" is a pun for algebraic geometry
20:32:47 <Saizan> and recursion schemes..
20:32:51 <ddarius> Saizan: I was there when they made the channel.  I named it.
20:33:09 <Eduard_Munteanu> BMeph: yeah, most would have to get started as ad-hoc discussion channels on topics that spark somewhere else. For example, #category-theory would be something like that.
20:33:25 <BMeph> Anyway, if we could get a logging-bot for the math conversations, I'd appreciate it; I'm quite confident there will be topics covered that I'd love to read over.
20:33:49 <ddarius> Saizan: Admittedly, that is partially another reason for it.  People would complain that the heavy CT talk was intimidating or some such silliness.
20:34:08 <soupdragon> please rename monoid to appendable !!!!!
20:34:26 <monochrom> why not prependable
20:34:37 * BMeph renames it to Prependable, just for SPite! >;)
20:35:00 <BMeph> monochrom: I like the way you think! ;)
20:35:07 <Saizan> ddarius: i thought i was there too, but my memories might be fake
20:35:41 <monochrom> are you sure? the way I think is "how to shoot down all meaningful names as misleading"
20:36:53 <monochrom> you have to denounce "meaningful" identifiers and generally all natural languages if you like the way I think.
20:37:43 <ddarius> Saizan: Anyway, I'm not sure if dcoutts talks about Cabal in #hackage (very likely), but I said Cabal not Hackage.  Also, I'm not sure if #hackage existed then and it wasn't conversations about improving/implementing hackage, but more like how to resolve some nasty dependency issue.
20:38:14 <ddarius> Do as monochrom says and not as he does.
20:38:58 <Saizan> ddarius: i've never seen talks about solving some nasty dependency issue in #haskell-in-depth though, and i do most of those!
20:39:35 <ddarius> do(You, says(monochrom)), not(do(You, do(monochrom, Action))
20:40:24 <ddarius> Saizan: I'm sure the ambit of #haskell-in-depth has long since moved on and dcoutts has fixed many of the things that caused those discussions.
20:40:52 <ddarius> I have no idea what #haskell-in-depth is about nowadays.  I don't think edwardk expounds on recursion schemes there now either.
20:40:54 * BMeph stops partying in the background long enough to type appreciation for monochrom's way of thinking. Then he goes back to partying...
20:42:09 <Saizan> ddarius: mostly silent
20:46:41 <ddarius> Saizan: Yeah.  My impression is that it has out-lived it's original use and might as well die for now to be resurrected when needed again.
20:47:10 <int80_h> is there anyone here who has experience with yesod?
20:47:19 <Eduard_Munteanu> That sounds like a prophecy :P
20:47:36 <int80_h> I am having difficulty integrating lighttpd and yesod
20:47:59 <drbean> > [0..4] ++ [5]
20:48:00 <lambdabot>   [0,1,2,3,4,5]
20:48:16 <drbean> Is there a name for that. The opposite of 'last'?
20:48:37 <shachaf> > init [0..5]
20:48:37 <lambdabot>   [0,1,2,3,4]
20:48:39 <monochrom> no name, not in the libs
20:49:07 <drbean> Adding something to the end of a list.
20:49:09 <shachaf> Oh, you mean something that appends an element to the end?
20:49:14 <shachaf> Nope.
20:49:16 <ddarius> What's wrong with what you wrote?
20:49:19 <monochrom> we rarely do it
20:49:36 <ddarius> And yes, that is rather inefficient.  Not the thing to do with a list.
20:49:52 <ddarius> That operation, on data types where it is appropriate, is usually called snoc, e.g. Data.Sequence.snoc
20:49:55 <ddarius> @hoogle snoc
20:49:56 <lambdabot> Data.ByteString snoc :: ByteString -> Word8 -> ByteString
20:49:56 <lambdabot> Data.ByteString.Char8 snoc :: ByteString -> Char -> ByteString
20:49:56 <lambdabot> Data.ByteString.Lazy snoc :: ByteString -> Word8 -> ByteString
20:50:12 <monochrom> I do it sometimes but definitely not in a tight loop.
20:50:15 <ddarius> (Actually, I think Seq uses |> ...)
21:00:54 <BMeph> ddarius: That's the View[LR] type, and they're :> and :<, I believe.
21:00:57 <halberd> does a relational database constitute an equally expressive type system as Haskell's?
21:01:51 <halberd> e.g. you could represent a binary tree data type by a table with two columns, for left child and right child
21:02:25 <halberd> is there anything haskell has that such a system couldn't represent, or vice versa?
21:02:39 <monochrom> can you do type classes?
21:04:03 <ddarius> :t Data.Sequence.|>
21:04:04 <lambdabot> parse error on input `Data.Sequence.|>'
21:04:07 <halberd> I don't think so
21:04:16 <ddarius> :t (Data.Sequence.|>)
21:04:16 <halberd> how could a relational database be extended so that it could do type classes?
21:04:17 <lambdabot> forall a. Seq.Seq a -> a -> Seq.Seq a
21:04:19 <Eduard_Munteanu> halberd: um, how would polymorphism fit there?
21:04:47 <halberd> what would type classes mean for a relational database?
21:05:05 <monochrom> perhaps it means can't be done
21:05:14 * ddarius thought he had a solid red tie with a maroon-ish sheen...
21:06:04 <halberd> well I'd rather it could be done
21:09:24 <halberd> suppose you could store the name of a table as an entry in a table
21:10:23 <Eduard_Munteanu> halberd: you're talking about an internal representation of a type system rather than the type system itself.
21:10:55 <halberd> well I think that the relational database model is appealing
21:11:00 <halberd> I don't think it's a mere detail
21:11:03 <Eduard_Munteanu> Given that, there might be multiple ways of actually programming a Hindley-Milner type inference system.
21:11:24 <Eduard_Munteanu> or Haskell's type system.
21:11:38 <halberd> like the ability to perform a join
21:12:10 <Eduard_Munteanu> halberd: how would that help with a type system?
21:12:59 <soupdragon> so disappointed with hypertext
21:13:01 <soupdragon> :(
21:13:09 <halberd> I'm not interested in just implementing a type system in a relational database
21:14:08 <halberd> joins are something that a relational database can do that a conventional type system doesn't do
21:14:11 <halberd> except for pointers
21:14:12 <Eduard_Munteanu> halberd: well, saying "relational database" doesn't really define all the semantics.
21:14:42 <halberd> I'm more interested in extending a relational database with attributes of a type system
21:15:02 <halberd> and seeing if the result could be workable or useful in any way
21:17:11 <ddarius> halberd: Your phrases seem to constantly mix various conceptual levels.
21:17:42 <djahandarie> http://www.galois.com/blog/2010/05/27/tech-talk-categories-are-databases/ was a nice watch
21:21:03 <Eduard_Munteanu> Oh, Spivak.
21:22:08 <halberd> relational databases have proved to be very effective ways of storing structured data
21:23:36 <halberd> and executing queries on the data
21:25:10 <halberd> provided the structure isn't very recursive
21:30:01 <halberd> if a table could include another table as an entry, you would need to make the tables in a join be, potentially, variables drawn from a column
21:30:42 <halberd> select * from table1, table1.column2 where table1.age > table1.column2.age
21:31:07 <Eduard_Munteanu> @faq Can Haskell do SQL?
21:31:07 <lambdabot> The answer is: Yes! Haskell can do that.
21:31:11 <Eduard_Munteanu> :P
21:31:22 <Eduard_Munteanu> I'm still reading Spivak's slides.
21:32:31 <halberd> what makes math pretty and code, unfortunately often, ugly?
21:33:25 <djahandarie> halberd, what are you talking about? There are no hierarchical relations in the relational model.
21:34:35 <halberd> don't know what you mean by a "hierarchical relation"
21:35:33 <halberd> you can get a binary tree by having a table with left child and right child columns that point back to the table key
21:36:04 <djahandarie> Relation as in "table" in SQL terms
21:36:12 <djahandarie> It's called a relation in the relational model
21:36:29 <halberd> ok
21:36:36 <djahandarie> Even when you do something like that, or do a self join for example, the relation itself is not hierarchical
21:36:41 <djahandarie> Just the data
21:38:14 <ddarius> halberd: 1) Computers need to be told the "obvious" steps, 2) the problems that computers are applied to are, inherently, much "uglier" than math problems.
21:39:22 <halberd> in math things tend to magically come out neatly in the end
21:39:37 <halberd> and it's surprising how neat they turn out even if the middle was complicated
21:39:55 <halberd> in code the opposite happens... it's surprising how broken the result can turn out to be
21:41:31 <Eduard_Munteanu> Yup, computing something efficiently != constructively proving existence of a solution
21:42:59 <soupdragon> the reason programs are so bad is because people just write shedloads of code without thinking
21:43:14 <soupdragon> if programmers worked more like mathematicians they would produce equally excellent results
21:44:35 <ddarius> soupdragon: They still would not produce as "pretty" code as mathematical proofs for reasons Eduard_Munteanu and I mentioned.  Admittedly, people are more likely to see "pretty" proofs than "ugly" proofs.
21:44:41 <Eduard_Munteanu> soupdragon: I disagree a bit. Mathematicians deal with known complexity, as given by predefined and studied concepts. Programmers work with unknown complexity given by implementation details, which is different in all cases.
21:44:50 <alexyk> does ghci respect +RTS?
21:44:55 * hackagebot yi 0.6.2.4 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.6.2.4 (JeffWheeler)
21:45:14 <ddarius> alexyk: It should, though the options will apply to GHCi itself.
21:45:31 <Eduard_Munteanu> You can learn math once, and that helps you a great deal. But every codebase is different, even though it rests on the same theoretical concepts.
21:45:33 <ddarius> Eduard_Munteanu: I don't quite agree with that.
21:45:42 <Saizan> there's an audience factor though, it's much easier to fed ugly code to a compiler than an ugly proof to a peer reviewed journal
21:45:53 <alexyk> ddarius: so I want to load a big-ass map; my compiled progs use -A5G, what should I do to do it from ghci?
21:46:01 <ddarius> Saizan: There are nevertheless plenty of ugly proofs.
21:46:41 <ezyang> alexyk: Smaller dataset. 
21:46:43 <ddarius> alexyk: You can try it on GHCi, it will just also count GHCi's usage as well, which shouldn't be much of a problem in that case.
21:47:00 <alexyk> ezyang: neva eva!
21:47:06 <Eduard_Munteanu> ddarius: what I meant is, for example, the Linux kernel isn't something earth-shattering judged by the theoretical concepts. But the complexity programmers need to manage is huge.
21:47:10 <alexyk> ezyang: real world is big
21:48:21 <Eduard_Munteanu> In contrast, *most* proofs are rather short and rely on commonly-accepted knowledge.
21:48:42 <ddarius> Eduard_Munteanu: A lot of that is accidental (e.g. from using C).  Most of the "ugliness"/complexity of programs is that they have to conform to rather arbitrary, but unchangeable, human set standards.
21:48:43 <ezyang> alexyk: Well, it depends on what you're using ghci for. 
21:48:44 <wli> Kernels are mostly problems of complexity.
21:49:28 <ddarius> Eduard_Munteanu: Most programs would also be short if you 1) had a set of "commonly-accepted knowledge" which we do, they're libraries, and 2) the compiler could fill in the "obvious" details of combining them, which we don't have.
21:49:37 <Eduard_Munteanu> And that's because there's no reasonable equivalent in programming to "this is a group", because it might not be efficient enough for all purposes.
21:49:43 <ddarius> Actually, programmers tend to do a much better job at modularity than mathematicians in many ways.
21:49:58 <pikhq> ddarius: It's kinda necessary.
21:49:59 <ddarius> Eduard_Munteanu: Programmers just have a harder problem.  Ask Dijkstra.
21:50:07 <ddarius> pikhq: Of course.
21:50:09 <Eduard_Munteanu> ddarius: hm, interesting.
21:50:19 <Eduard_Munteanu> Well it's true, at least for common application you could afford that.
21:50:20 <pikhq> Modularity is pretty much the only way to *deal* with the complexity inherent in many problems.
21:50:37 <Eduard_Munteanu> ddarius: do you have any pointers/links on that?
21:50:45 <ddarius> Eduard_Munteanu: Via CH, a million line program, would correspond to a ridiculously long proof.  Mathematicians don't usually knowingly attack such problems.
21:51:11 <ddarius> Eduard_Munteanu: For which?  Dijkstra or modularity?
21:51:24 <Eduard_Munteanu> ddarius: heh, well, not until recently. There are a few proofs that are like that. Some are computed.
21:51:29 <Eduard_Munteanu> ddarius: Dijkstra.
21:52:07 <Eduard_Munteanu> I think it was the map coloring theorem.
21:52:19 <ddarius> Eduard_Munteanu: I don't have any handy references to something specific.  Another person you could ask is Doron Zeilberger.
21:52:34 <Eduard_Munteanu> I see.
21:52:44 <ddarius> Eduard_Munteanu: The four-color theorem did use some computation to handle a large case analysis (essentially).
21:53:17 <soupdragon> also the hales thing
21:53:19 <soupdragon> about kissing numbers
21:53:31 <Eduard_Munteanu> Yeah, they dislike the proof.
21:53:41 <Eduard_Munteanu> Conceptually, I do too, I wish things were easier to prove.
21:53:53 <Eduard_Munteanu> (human-manageable at least)
21:54:07 <pikhq> I'd say that's quite a bit more acceptable than the Fermat's last theorem proof.
21:54:15 <ddarius> Still, that was like 1700 cases in the first cut (and has been slimmed down since).  Giving a hundred lines of "proof" to handle each case (which is unlikely), that would be 170,000 "lines of code" which still is not impressive.
21:54:37 <Eduard_Munteanu> ddarius: hm, you have a point there.
21:54:38 <ddarius> Eduard_Munteanu: You should definitely read some of the stuff Zeilberger has written.
21:54:48 <Eduard_Munteanu> ddarius: thanks, I'll look it up.
21:56:21 <Eduard_Munteanu> I admit, it's time programmers started being less original.
21:56:29 <soupdragon> other way around
21:56:45 <soupdragon> wait no
21:56:53 <Eduard_Munteanu> soupdragon: I meant resorting to common-knowledge (libraries)
21:57:04 <pikhq> No, no, originality has stopped a lot. Most code is gluing two libraries together. Poorly.
21:57:27 <pikhq> Eduard_Munteanu: That's just NIH syndrome. :)
21:58:01 <Eduard_Munteanu> pikhq: yeah, that's a problem even with experienced programmers. I wish they'd get over it.
21:58:44 <pikhq> Eduard_Munteanu: I blame all the lousy libraries out there convincing people to reinvent the wheel. :P
21:59:23 <Eduard_Munteanu> I think copyrights and even the variety of OSS licenses are part of the problem too.
22:00:01 <Eduard_Munteanu> But still, one too many times this has been done without reason.
22:00:11 <pikhq> Copyright law really doesn't help matters any, yeah.
22:00:17 <pikhq> With, oh, most any issue.
22:02:08 <Eduard_Munteanu> Now I know Stallman et al. want to screw M$ and others, but people should consider public domain an option.
22:03:06 <Eduard_Munteanu> I've been pondering on whether this "let's have opensource screw closed-source vendors" thingy is any good, and by thingy I mean GPL.
22:04:33 <ddarius> Eduard_Munteanu: Here's one relevant Dijkstra quote: "Programming is one of the most difficult branches of applied mathematics; the poorer mathematicians had better remain pure mathematicians."
22:05:19 <Eduard_Munteanu> ddarius: thanks. I'll try looking for the context, maybe there's more.
22:05:24 <ddarius> Eduard_Munteanu: Public domain is not even available in some countries, i.e. it literally isn't an option.
22:05:49 <Eduard_Munteanu> ddarius: yeah, I heard it's mainly a US concept.
22:07:07 <Eduard_Munteanu> Still, I can imagine licensing something as "No warranties implied, you can do whatever you want with it, even claim copyright and change this license". Not sure of the legal implications though, IANAL.
22:07:47 <hotaru2k3> i use this license for most things: http://github.com/hotaru2k3/tinybb3/blob/master/LICENSE
22:07:52 <ddarius> Eduard_Munteanu: If you allowed someone else to "claim copyright" then they could exclude -you- from using your code.
22:08:08 * hackagebot dataenc 0.13.0.3 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.13.0.3 (MagnusTherning)
22:08:12 <Eduard_Munteanu> ddarius: yeah, perhaps claim it non-exclusively.
22:08:20 <etpace> if I get a stack overflow in a thread, how can I find out the misbehaving function/memory allocation?
22:09:35 <Zeiris> Suppose I have a type, "data Packet = ConnRequest Int Int Int". Can I curry "ConnRequest", in order to build it up piece by piece, for binary parsing? And can I somehow auto-derive a function with signature ":: Packet -> (Int, Int, Int)" for binary packing?
22:10:01 <Eduard_Munteanu> hotaru2k3: thanks. Looks mostly similar to the license from Qemu/KVM.
22:10:09 <ddarius> Eduard_Munteanu: There's no reason anyone else needs copyright.  In fact, putting something in the public domain would mean that no one can have copyright to it.
22:10:15 <Draconx|Laptop> Eduard_Munteanu, the whole point of copyright is that it is exclusive.  For one to "claim it non-exclusively" makes little sense.
22:10:30 <Draconx|Laptop> Eduard_Munteanu, but you may be interested in the "do what the fuck you want to public license".
22:10:49 <ezyang> etpace: If you compile without threaded, does it still overflow? 
22:10:50 <Eduard_Munteanu> ddarius: are you sure that's true? AFAICT, public domain allows you to change software and license it however you want.
22:11:44 <etpace> i'm not sure, recompiling will take a bit of time -- but it only overflows on certain data but the threads spawned are static
22:11:46 <ddarius> "Works are in the public domain if they are not covered by intellectual property rights at all, if the intellectual property rights have expired, and/or if the intellectual property rights are forfeited."
22:11:48 <Eduard_Munteanu> Draconx|Laptop: copyright was originally meant to be restrictive, yeah
22:12:05 <Draconx|Laptop> Eduard_Munteanu, it still is.
22:12:07 <ddarius> Copyright is an intellectual property right.
22:13:02 <Eduard_Munteanu> ddarius: so does that mean a work from public domain can't be taken by somebody, non-exclusively, and relicensed?
22:13:10 <ddarius> You can modify and license public domain works, but you can't claim copyright which would then give you the right to exclude others from that public domain work.
22:13:12 <Eduard_Munteanu> Of course, I don't mean "exclusively relicense".
22:13:35 <soupdragon> This 'convolution product' is interesting
22:13:55 <Eduard_Munteanu> ddarius: I see what you mean. By copyright I simply meant "the right to license and relicense, and change terms on the copies you distribute"
22:14:12 <soupdragon> for f,g :: Z -> R,  (f * g) = sum . map (\(x,y) -> f(x) * g(y)) . factors
22:14:18 <Eduard_Munteanu> Not change terms on copies already existing and in possession of thers..
22:14:20 <Draconx|Laptop> Eduard_Munteanu, you appear to be confusing contracts with copyrights.
22:14:21 <Eduard_Munteanu> *others
22:14:29 <soupdragon> where factors 6 = [(1,6),(2,3),(3,2),(6,1)].... I think
22:15:52 <ddarius> soupdragon: Convolution and the convolution theorem are of crucial importance to various areas of applied and theoretical mathematics.
22:15:59 <Eduard_Munteanu> Draconx|Laptop: that may be, but I don't see where. If you're referring to license, by that I simply mean the right to impose conditions on that work and every derivative work that you distribute.
22:16:05 <ezyang> And to the electrical engineers! 
22:16:22 <Draconx|Laptop> Eduard_Munteanu, unless there's a contract, there is no legal basis to enforce such conditions.
22:16:28 <Draconx|Laptop> Eduard_Munteanu, (in the absense of copyright)
22:16:33 <ddarius> ezyang: They are applied mathematicians (at least in cases where they'd use the convolution theorem.)
22:16:46 <Eduard_Munteanu> Draconx|Laptop: heh yeah. If it were up to me, copyrights would go away.
22:17:06 <ddarius> Draconx|Laptop: Exactly, re enforcement.
22:17:43 <Eduard_Munteanu> Intellectual property is in many ways a flawed concept.
22:17:48 <Draconx|Laptop> Eduard_Munteanu, I'm glad it's not up to you, then.
22:18:04 <Eduard_Munteanu> :)
22:20:43 <Zeiris> Are there any libraries to automatically produce the functions "[a,b,c] -> Foo" and "Foo -> [a,b,c]" for some type "data Foo = Foo' a b c"?
22:21:28 <ddarius> Zeiris: See the derive library and application.
22:21:32 <ddarius> @hackage derive (?)
22:21:32 <lambdabot> http://hackage.haskell.org/package/derive (?)
22:21:33 <Eduard_Munteanu> What is [a,b,c]? Unless you meant the actual list and not a type
22:22:24 <Zeiris> I mean an actual list. I'd like to declare the structure of a packet once, and get both parsing and packing from that declaration.
22:22:33 <Zeiris> This seems like a way to do it.
22:22:41 <Eduard_Munteanu> I see.
22:27:07 <Eduard_Munteanu> Is there more than one theorem you can derive from a given type signature? Or are they all isomorphic in some sense?
22:27:21 <Eduard_Munteanu> I'm asking because I'm trying to understand why they call those theorems "free".
22:28:05 <Eduard_Munteanu> Or is are they for "free" in the sense you get only one interpretation of the result?
22:28:53 <ddarius> They are called "free" because you get them "without effort."  You don't even need to know what the function actually is.
22:29:00 <Draconx|Laptop> They are "free" in the sense that the computer spits them out for you, therefore absolving you of any requirement to prove them, I thought.
22:29:30 <Eduard_Munteanu> ddarius, Draconx|Laptop: ah, you mean the proof. But the theorem itself is unique, right?
22:29:43 <ddarius> Eduard_Munteanu: More or less, yes.
22:30:06 <ddarius> Eduard_Munteanu: For those particularly in the usual systems, the "free" theorem is, I believe, "most general" in some suitable sense.
22:30:10 <Eduard_Munteanu> ddarius: well, at least when talking about fully polymorphic types, thanks.
22:30:17 <Pseudonym> Eduard_Munteanu: What the free theorem essentially says is that the "forall" in a type is really a "forall".
22:30:18 <Eduard_Munteanu> I see.
22:30:23 <Pseudonym> :t length
22:30:24 <lambdabot> forall a. [a] -> Int
22:30:33 <Pseudonym> What that's saying is that length really does not care what type a is.
22:30:53 <Pseudonym> i.e. length only inspects the cons cells, not the data that's in the list.
22:30:54 <Eduard_Munteanu> I see.
22:30:57 <ddarius> Yeah, deriving and building the appropriate logical relation is instructive.
22:31:07 <pastorn> how do i run Text.ParserCombinators.Parsec.Language.haskell ?
22:31:09 <Pseudonym> @free length
22:31:11 <lambdabot> length = length . $map f
22:31:20 <pastorn> haskell :: TokenParser  st -- this is a lexer
22:31:20 <ddarius> Note that "logical relation" is a technical term there, it is not the conjunction of the meanings of "logical" and "relation."
22:31:20 <Eduard_Munteanu> :t $map
22:31:21 <lambdabot> parse error on input `$'
22:31:36 <pastorn> type TokenParser  st = GenTokenParser  String  st Identity
22:31:37 <Pseudonym> Eduard_Munteanu: It's $map to denote that it's the built-in map.
22:31:43 <Eduard_Munteanu> Pseudonym: ah, right.
22:31:44 <Pseudonym> Bad notation, I know.
22:31:52 <pastorn> i can't find a run function for this :(
22:32:03 <ddarius> pastorn: It's not a lexer and is not something that is run.  It is a collection of library functions that help lexing/parsing languages with "Haskell-like" syntax.
22:32:12 <Eduard_Munteanu> Another thing that seemed weird is that some online free theorem prover did prove a->b
22:32:13 <ddarius> pastorn: It wouldn't actually be able to lex Haskell.
22:32:16 <Eduard_Munteanu> @free a -> b
22:32:17 <lambdabot> Extra stuff at end of line
22:32:27 <Pseudonym> It's saying that you can apply any function which changes the values in the list in anyway, and as long as you don't change the structure of the list, the length will be the same.
22:32:30 <pastorn> ddarius: no? :(
22:32:31 <Pseudonym> @free f :: a -> b
22:32:32 <lambdabot> h . f = f . g
22:33:05 <Eduard_Munteanu> Heh, supposing h is saving the day.
22:33:09 <Pseudonym> Eduard_Munteanu: If it helps, consider this.
22:33:18 <Pseudonym> @free naturalTransformation :: F a -> G a
22:33:19 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
22:33:36 <Pseudonym> It's assuming that F and G are Functors, so they have map/fmap/whatever it's called.
22:33:49 <Eduard_Munteanu> Ah, I see.
22:33:58 <pastorn> ddarius: what could i use to parse haskell then? i don't care about context (i just want to lex it, actually parsing it is pretty irrelevant here)
22:34:04 <Eduard_Munteanu> Pseudonym: is there any way to get "unprovable" when asking for an a -> b theorem?
22:34:18 <Eduard_Munteanu> I think that's more useful.
22:34:35 <ddarius> @hackage haskell-lexer
22:34:36 <lambdabot> http://hackage.haskell.org/package/haskell-lexer
22:34:38 <Pseudonym> Eduard_Munteanu: Kind of.  What it's really saying is that if you had a function f :: a -> b, then for all h and g, h . f = f . g
22:34:39 <ddarius> @hackage haskell-src-exts
22:34:39 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
22:34:58 <Pseudonym> So, for example:
22:35:02 <ddarius> Eduard_Munteanu: Free theorems aren't trying to show that a type is inhabited.
22:35:12 <Pseudonym> const 42 . f = f . id
22:35:15 <ddarius> Or making any claims about that at all.
22:35:21 <pastorn> ddarius: cool, thanks :)
22:35:27 <Eduard_Munteanu> Pseudonym: ah, I interpreted it otherwise: suppose there exists an h such that h . f = f . g, then f is true.
22:35:39 <Eduard_Munteanu> The statement is true.
22:35:48 <Eduard_Munteanu> But there's no h.
22:35:48 <soupdragon> look at this one
22:35:54 <soupdragon> @free reverse :: [a] -> [a]
22:35:54 <lambdabot> $map f . reverse = reverse . $map f
22:35:58 <soupdragon> this is clear
22:36:13 <Pseudonym> i.e. reverse is a natural transformation from [] to []
22:36:21 <Pseudonym> Which is a pretty result.
22:36:26 <Eduard_Munteanu> ddarius: yeah, I was trying to misuse it to figure which can be proven wrong.
22:36:35 <Eduard_Munteanu> Yeah.
22:36:47 <Pseudonym> @free head :: [a] -> a
22:36:48 <lambdabot> f . head = head . $map f
22:36:48 <Eduard_Munteanu> That is indeed useful.
22:36:51 <Pseudonym> And so on.
22:36:54 <ddarius> Eduard_Munteanu: You can indirectly use it by finding properties that are non-sense.
22:37:15 <Pseudonym> @free undefined :: a
22:37:15 <lambdabot> f undefined = undefined
22:38:03 <Pseudonym> @ft undefined :: a
22:38:04 <lambdabot> Done.
22:38:10 <Pseudonym> Erm.
22:38:32 <Eduard_Munteanu> @free zip
22:38:33 <lambdabot> $map ($map_Pair f g) . zip xs = zip ($map f xs) . $map g
22:38:55 <Pseudonym> Note that @free goes to some trouble to points-free things.
22:39:03 <soupdragon> @free [Either a b] -> ([a],[b])
22:39:04 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
22:39:07 <soupdragon> omg
22:39:16 <soupdragon> @free [(a,b)] -> ([a],[b])
22:39:16 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
22:39:19 <soupdragon> FFFFFFFFF
22:39:20 <Pseudonym> @free split :: [Either a b] -> ([a],[b])
22:39:20 <lambdabot> $map_Pair ($map f) ($map g) . split = split . $map ($map_Either f g)
22:39:40 <p00ya> is there a laziness/strict trick to make (sum [1..]) > 5 finish in a finite time?
22:39:48 <Pseudonym> Not that it's assuming that Pair and Either are bifunctors.
22:40:11 <Eduard_Munteanu> Not familiar with bifunctors.
22:40:12 <pastorn> ddarius: haskell-src-exts looks really great :)
22:40:14 <pastorn> thanks
22:40:25 <Pseudonym> $map_Pair f g (x,y) = (f x, g y)
22:40:40 <ddarius> pastorn: That is definitely the most comprehensive/widely used library for such things.
22:40:44 <Pseudonym> $map_Either f g (Left a) = Left (f a); $map_Either f g (Right b) = Right (g b)
22:41:07 <pastorn> ddarius: for fixities etc., shoul i be making a 2-pass parsing?
22:41:12 <Pseudonym> In the case of zip:
22:41:16 <Pseudonym> $map ($map_Pair f g) . zip xs = zip ($map f xs) . $map g
22:41:18 <pastorn> all i want is to make is a source browser
22:41:24 <ezyang> yum bifunctors covariant in the first arguments and contravariant in the second argument. 
22:41:27 <Eduard_Munteanu> p00ya: I think edwardk's stuff on *-morphisms might help, you basically need to ditch sum and express that as a fold that returns it results while going ahead.
22:41:29 <Pseudonym> $map ($map_Pair f g) (zip xs ys) = zip ($map f xs) ($map g ys)
22:41:32 <Pseudonym> That might make more sense.
22:41:32 <MasseR> Huh. Pretty much unfubared package cache. Note to self it's not good idea to cabal install, remove .cabal, cabal install, remove .cabal, rinse and repeat. Makes for very broken packages >.<
22:41:40 <pastorn> where i can follow references, as long as they're in the source tree
22:41:43 <Pseudonym> Most of the time, points-freeing is the "right thing".
22:41:51 <Pseudonym> But for zip it confuses more than it helps.
22:42:00 <Pseudonym> Similarly:
22:42:03 <Pseudonym> :t sortBy
22:42:05 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
22:42:09 <Pseudonym> @free sortBy
22:42:10 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
22:42:11 <Eduard_Munteanu> Yeah.
22:42:17 <p00ya> Eduard_Munteanu: thanks, do you have a link for that?
22:42:29 <Eduard_Munteanu> I think lambdabot had a plugin to convert pointfree to pointful.
22:42:45 <Pseudonym> (forall x y. g x y = h (f x) (f y)) => $map f . sortBy g = sortBy h . $map f
22:43:14 <Pseudonym> Basically, if f doesn't change the relative ordering of elements, then $map f commutes with sort.
22:43:36 <Eduard_Munteanu> p00ya: you could look here http://hackage.haskell.org/packages/archive/pointless-haskell/0.0.3/doc/html/Generics-Pointless-RecursionPatterns.html
22:43:38 <ddarius> ezyang: I think I already mentioned dinatural transformations to you.
22:43:52 <Eduard_Munteanu> p00ya: or google for paramorphism, I don't remember which did that.
22:44:05 <Eduard_Munteanu> But you'll have to grok those first if you want to write it that way.
22:44:07 <ezyang> ddarius: Yah 
22:44:14 <soupdragon> paramorphisms can bend spoons
22:44:40 <Pseudonym> cryptomorphisms steal into your room at night and hide under the bed.
22:44:52 <Eduard_Munteanu> p00ya: but I'd recommend looking at catamorphisms first and deciding whether you want to go ahead, or simply write something else :)
22:44:53 <p00ya> Eduard_Munteanu: wow, looks like a lot of background reading
22:44:59 <ddarius> Pseudonym: What should sortBy be called if we allow that the passed in argument need not be a total order.
22:45:28 <Eduard_Munteanu> p00ya: well yeah. You can probably write an ad-hoc solution, or use those but you need the background.
22:45:29 <Pseudonym> ddarius: Strict weak order?  Partial order?
22:45:38 <ddarius> Pseudonym: No constraints.
22:45:46 <ski> ezyang : usually called `difunctors' (at least when contravariant in left argument and covariant in right one)
22:45:54 <p00ya> the context is me writing a fold function that needs pruning optimisations
22:45:59 <Eduard_Munteanu> p00ya: catamorphisms are generalized folds, which in turn are generalized sums.
22:46:07 <p00ya> not actually summing anything
22:46:08 <Pseudonym> I don't even know what "sort" means if the comparison function isn't transitive.
22:46:08 <ezyang> ski: Ah, ok. 
22:46:30 <Saizan> p00ya: "sum [1..] > 5" works if you use a lazy natural type, like "data Nat = Zero | Succ Nat", which is not very efficient in general though
22:46:36 <ddarius> Pseudonym: Probably depends wildly on the implementation.
22:46:37 <soupdragon> what if you turned the sun into a computer
22:46:38 <soupdragon> ??
22:46:50 <soupdragon> and accelerated the speed of the earth
22:46:59 <soupdragon> so the time would be very fast and you could do extremely fast computations
22:47:44 <ezyang> I still don’t really understand dinatural transformations, mostly because I can’t manage to load the entire definition into my brain at once. Maybe I’ll think about them more tomorrow. 
22:48:31 <Pseudonym> ddarius: http://www.springerlink.com/content/v218653q61q328g2/
22:48:49 <ddarius> ezyang: Just think of them as the simplest "natural transformation"-ish thing you could have given a difunctor (to use ski's terminology.)
22:48:50 <Pseudonym> You could identify the Smith set.
22:49:05 <Eduard_Munteanu> I think what he needs is a paramorphism, but I'm not an expert on that.
22:49:22 <ezyang> mm, I will hold on to that. 
22:49:39 <ezyang> difunctors aren't really bifunctors, are they... 
22:51:02 <ezyang> oh, they are definitely bifunctors. 
22:51:11 <ddarius> If you diagonalize them, no, the result would not be a functor.  Not diagonalized, they are certainly a bifunctor.
22:51:11 <Pseudonym> ddarius: The problem I think is that you'd need to guarantee that both x < y and y < x can't be true.
22:51:18 <Pseudonym> Or something.
22:51:38 <ezyang> In what since of diagonalization? 
22:51:52 <Pseudonym> Actually, that can be true in a topological ordering.
22:52:04 <Eduard_Munteanu> p00ya: otoh, you could write something like myfold :: (a -> a) -> a -> [a] -> (a -> Bool) -> a
22:52:07 <Eduard_Munteanu> :t fold
22:52:08 <lambdabot> Not in scope: `fold'
22:52:11 <Eduard_Munteanu> :T foldl
22:52:16 <Eduard_Munteanu> :t foldl
22:52:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:52:20 <Pseudonym> @free foldl
22:52:22 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
22:52:31 <Pseudonym> You are not expected to understand this.
22:53:05 <Eduard_Munteanu> p00ya: and use the a -> Bool to end folding when a condition becomes true
22:53:14 <ddarius> ezyang: \X. F X X
22:53:28 <Eduard_Munteanu> (actually the first (a -> a) should read (a -> a -> a))
22:54:25 <p00ya> Eduard_Munteanu: that's kinda what i have. i think my code is just a bit of a mess atm because i have two functions that are mutually recursive
22:54:25 <Eduard_Munteanu> You look at foldl and make the necessary modifications.
22:54:31 <p00ya> was looking for an easy way out
22:54:38 <Eduard_Munteanu> @src foldl
22:54:38 <lambdabot> foldl f z []     = z
22:54:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:55:21 <soupdragon> > (\i -> (i,(i^7)`mod`7)) . [0..7]
22:55:22 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,0)]
22:55:30 <ddarius> The idea behind difunctors and dinatural transformations is we want a "functor" where we can use an argument positively and negatively, but that would fail to be a functor if we just did that, so we explicitly split the positive and negative uses into two arguments, but we still want to view them as the "same thing" more or less.
22:55:34 <soupdragon> > (\i -> (i,(i^11)`mod`11)) . [0..11-1]
22:55:35 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
22:55:41 <p00ya> http://scarff.id.au/file/3243126.hs
22:55:47 <p00ya> in reduce and makeFindBest
22:56:05 <Eduard_Munteanu> p00ya: well, can perhaps you can lazily prune the tree. Dunno, maybe it's possible to write it as a composition of a fold and a prune.
22:56:22 * Eduard_Munteanu *looks*
22:56:31 <soupdragon> > (\i -> ((i^(11-1))`mod`11)) . [0..11-1]
22:56:32 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1]
22:56:35 <p00ya> don't try to compile that, i don't even know if it'll make syntax right now
22:57:11 <soupdragon> > (\i -> ((i^(11^2-1))`mod`(11^2))) . [0..11^2-1]
22:57:12 <lambdabot>   [0,1,56,1,111,78,56,23,45,1,12,0,111,111,78,78,100,34,56,89,67,23,0,100,45,...
22:58:13 <ddarius> ezyang: A dinatural transformation t is a family of function t_a : F a a -> G a a plus the "obvious" coherence condition.
22:58:49 <Pseudonym> @free t :: F a a -> G a a
22:58:50 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
22:58:53 <Pseudonym> Damn.
22:59:11 <ddarius> Doesn't handle multiple argument type constructors?
22:59:25 <Pseudonym> I think it special cases (,) and Either.
22:59:44 <ddarius> @free t :: (a -> a) -> (a -> a)
22:59:45 <lambdabot> f . g = h . f => f . t g = t h . f
22:59:55 <Eduard_Munteanu> p00ya: um, it isn't that bad. Perhaps you can improve it by moving those let-bound functions to top level.
22:59:59 <Pseudonym> http://andrew.bromage.org/darcs/freetheorems/
23:00:12 <Pseudonym> IIRC, the other free theorem generator handles it correctly.
23:00:37 <ddarius> Pseudonym: We need a free-add where we can add functors and their variances.
23:01:44 <Pseudonym> I think my version (i.e. the one not in lambdabot) assumes they're arrows.
23:01:54 <Pseudonym> @free idA :: A a a
23:01:54 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
23:02:03 <Pseudonym> arr f >>> idA = idA >>> arr f
23:02:52 <ddarius> Pseudonym: You need to update to Control.Category.
23:06:00 <soupdragon> > (\i -> (i^(11-1))`mod`(11^2)) . [0..11]
23:06:04 <lambdabot>   mueval-core: Time limit exceeded
23:06:14 <soupdragon> > (\i -> (i^(7-1))`mod`(7^2)) . [0..7]
23:06:16 <lambdabot>   [0,1,15,43,29,43,8,0]
23:06:23 <Pseudonym> @free pierce :: ((a -> b) -> a) -> a
23:06:24 <lambdabot> (forall p q. g . p = q . f             =>              f (h p) = k q) => f (pierce h) = pierce k
23:06:35 <soupdragon> > (\i -> (i^(7^2-7))`mod`(7^2)) . [0..7]
23:06:36 <lambdabot>   [0,1,1,1,1,1,1,0]
23:06:38 <ddarius> Interesting formatting.
23:06:43 <Pseudonym> I'd forgotten that one.
23:06:56 <Pseudonym> Yeah.  It's nicely formatted, and then munged for lambdabot.
23:07:07 <Eduard_Munteanu> Is that a theorem?
23:07:08 <Pseudonym> @free callcc :: ((a -> (forall r. (b -> r) -> r)) -> (forall r. (a -> r) -> r)) -> (forall r. (a -> r) -> r)
23:07:08 <lambdabot> (forall p q. (forall x f1 f2 f3. f1 . f2 = f3 . g                                 =>                                  f1 (p x f2) = q (f x) f3)             =>              (forall f4 f5 f6. f4 . f5 =
23:07:08 <lambdabot>  f6 . f                               =>                                f4 (h p f5) = k q f6)) => f7 . f8 = f9 . f => f7 (callcc h f8) = callcc k f9
23:07:15 <Eduard_Munteanu> Looks rather trivial.
23:07:26 <Eduard_Munteanu> Ah, wait.
23:07:37 <ddarius> Eduard_Munteanu: It's occasionally an axiom.  It can be proven from excluded middle.
23:07:51 <Eduard_Munteanu> Oh.
23:08:01 <ddarius> ezyang: One significant part of getting a handle on category theory is getting a feel for what coherence conditions are necessary/desirable and having an idea why.
23:08:20 <ddarius> @djinn-add class EM a where em :: Either a (Not a)
23:08:46 <ddarius> @djinn EM a => ((a -> b) -> a) -> a
23:08:46 <lambdabot> f a =
23:08:46 <lambdabot>     case em of
23:08:46 <lambdabot>     Left b -> b
23:08:46 <lambdabot>     Right c -> a (\ d -> void (c d))
23:09:27 <Eduard_Munteanu> @free f :: (a -> b) -> ((forall q. b -> q) -> (forall q. a -> q))
23:09:28 <lambdabot> h . k = p . g => (forall q. q . x = y . h) => f1 . f k x = f p y . g
23:09:29 <ddarius> @djinn class DNE a where dne :: Not (Not a) -> a
23:09:29 <lambdabot> Cannot parse command
23:09:34 <ddarius> @djinn-add class DNE a where dne :: Not (Not a) -> a
23:09:42 <ddarius> @djinn DNE a => ((a -> b) -> a) -> a
23:09:43 <lambdabot> f a = dne (\ b -> void (b (a (\ c -> void (b c)))))
23:09:46 <ddarius> Cool
23:09:50 <Eduard_Munteanu> Well that was supposed to be the contrapositive.
23:10:33 <Eduard_Munteanu> @: (a -> b) -> ((forall q. b -> q) -> (forall q. a -> q))
23:10:34 <lambdabot> Maybe you meant: . ? @ v
23:10:37 <Eduard_Munteanu> @djinn (a -> b) -> ((forall q. b -> q) -> (forall q. a -> q))
23:10:38 <lambdabot> -- f cannot be realized.
23:10:49 <Eduard_Munteanu> Meh.
23:10:56 <ddarius> For very good reasons, djinn can't handle rank-2 types.
23:11:10 <Eduard_Munteanu> Let's see a simpler one then...
23:11:24 <Eduard_Munteanu> @djinn (a -> b) -> (b -> c) -> (a -> c)
23:11:24 <lambdabot> f a b c = b (a c)
23:11:50 <Eduard_Munteanu> @djinn ((a -> b), (b -> c)) -> (a -> c)
23:11:51 <lambdabot> f (a, b) c = b (a c)
23:11:59 <Eduard_Munteanu> Looks right.
23:12:16 <ddarius> @djinn (a -> b, b -> c) -> a -> c
23:12:16 <lambdabot> f (a, b) c = b (a c)
23:12:32 <ddarius> @. pl djinn (a -> b, b -> c) -> a -> c
23:12:32 <lambdabot> f = uncurry (flip (.))
23:12:49 <Eduard_Munteanu> Heh, didn't know that worked.
23:12:58 <Eduard_Munteanu> @djinn a -> b
23:12:59 <lambdabot> -- f cannot be realized.
23:13:12 <Eduard_Munteanu> ddarius: great, so I can do with djinn what I inteded with free.
23:13:40 <Eduard_Munteanu> ddarius: but how would I define negation without rank-2 types?
23:13:41 <ddarius> Eduard_Munteanu: For a subset of types that corresponds to propositional logic.
23:14:03 <ddarius> not a = a -> False
23:14:09 <ddarius> @djinn-env
23:14:10 <lambdabot> data () = ()
23:14:10 <lambdabot> data Either a b = Left a | Right b
23:14:10 <lambdabot> data Maybe a = Nothing | Just a
23:14:10 <lambdabot> data Bool = False | True
23:14:10 <lambdabot> data Void
23:14:12 <lambdabot> type Not x = x -> Void
23:14:14 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
23:14:16 <lambdabot> class Eq a where (==) :: a -> a -> Bool
23:14:18 <lambdabot> class DNE a where dne :: Not (Not a) -> a
23:14:20 <lambdabot> class EM a where em :: Either a (Not a)
23:14:32 * hackagebot statechart 0.1.0 - Compiles Rhapsody statecharts to C.  http://hackage.haskell.org/package/statechart-0.1.0 (TomHawkins)
23:14:38 <Eduard_Munteanu> ddarius: oh, so no rank-2 needed.
23:15:21 <Eduard_Munteanu> Though rank-2 is most intuitive from a logic perspective.
23:15:33 <Eduard_Munteanu> It basically states the principle of explosion.
23:15:36 <ddarius> Djinn can't handle recursive types (though those could be added in a few ways) and non-recursive encodings of some such types require rank-2 types.
23:17:36 <Eduard_Munteanu> @djinn (a, b) -> Either a b
23:17:37 <lambdabot> f (a, _) = Left a
23:23:23 <jbapple> I imported Data.ByeString.Lazy with the latest version of bytestring, but I still get:  No instance for (IsString bytestring-0.9.1.6:Data.ByteString.Internal.ByteString) arising from a use of `fromString' 
23:23:58 <jbapple> Also, what is the standard way of converting from a literal character to a Word8?
23:25:12 <cncl> {-# LANGUAGE OverloadedStrings #-}
23:25:22 <cncl> and you want the char version of bytestring, i think
23:25:34 <jbapple> also ghc -foverloaded-strings complains about an unrecognized flag
23:25:37 <cncl> Data.ByteString.Char8
23:25:42 <jbapple> cncl, thanks, I'll try that
23:25:56 <arcatan> -XOverloadedStrings
23:28:56 <jbapple> ok, didn't help. I think I might have a package problem:
23:29:06 <jbapple> Couldn't match expected type `Data.ByteString.Internal.ByteString'           against inferred type `B.ByteString'
23:29:23 <cncl> don't cross up your use of the Char8 and Word8 bytestrings
23:29:36 <cncl> they are two different types
23:29:53 <jbapple> I only imported the Data.ByteString.Lazy.Char8
23:30:04 <cncl> something else you are using might be returning Word8 bytestrings
23:30:14 <jbapple> Although I did use bytestring-trie . . . thanks cncl
23:31:44 <jbapple> ok, since I need to use bytestring-trie, I suppose I need to use whatever byestrings it provides
23:32:03 <jbapple> which brings me back to my original question of the canonical way to get a Word8 from a Char
23:32:11 <jbapple> of course, I'm not sure THAT's what I need either
23:32:18 <jbapple> I guess it's up to bytestring-trie
23:33:47 <jbapple> @hoogle Char -> Word8
23:33:48 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
23:33:48 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:33:48 <lambdabot> Prelude error :: [Char] -> a
23:35:29 <jbapple> @hoogle String -> ByteString
23:35:30 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
23:35:30 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
23:35:30 <lambdabot> Prelude read :: Read a => String -> a
23:36:18 <cncl> oh
23:36:27 <cncl> are you sure it's not that you're accidentally using lazy and non-lazy bytestrings
23:36:36 <cncl> you can't mix them together
23:37:42 <ddarius> There is no "canonical" way to get a Word8 from a Char; a Char is a Unicode codepoint and thus can't be represented in 8 bits.
23:38:14 <arcatan> btw, does hGetChar read in Unicode chars or just single bytes?
23:38:26 <ddarius> It should be the former now.
23:38:47 <ddarius> (Assuming a Unicode using locale setting.)
23:40:50 <arcatan> so I guess hGet handle 1 would be a reasonable way to read in single bytes
23:43:30 <jbapple> I ended up using Data.ByteString.Internal.c2w
23:44:15 <ddarius> arcatan: You could just set the locale to something that would read byte for byte, or use the ByteString library as that is its intent.
23:46:02 <arcatan> ddarius: yeah, I meant hGet from ByteString
23:49:09 <jbapple> The problem I wanted to solve was lines, which I wrote as split '\n'
23:49:53 <jbapple> or, really, split (c2w '\n') where c2w = Data.ByteString.Internal.c2w
23:50:13 <pastorn> anyone else entountered this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27516#a27516
23:50:26 <pastorn> i got it when i tried to evaluate something in GHCi
23:52:16 <pastorn> this occurs when i'm doing getDirectoryContents and doesFileExist
23:52:59 <pastorn> there, annotated the paste
23:53:09 <pastorn> could someone please try this code?
23:53:37 <pastorn> sorry, that also needs System.Directory and System.FilePath
23:53:46 <pastorn> and Extra.List
23:54:15 <pastorn> and Data.List (that' the last, sorry)
23:54:31 <o-_-o> if I have a data V v = MkV Float Float deriving Show
23:54:37 <o-_-o> I want to do something like
23:54:54 <o-_-o> data Q q = V Float deriving Show
23:55:01 <o-_-o> is this possible ?
23:55:06 <o-_-o> data Q q = MkQ V Float deriving Show
23:55:07 <pastorn> o-_-o: what's the 'q'?
23:55:15 <Veinor> pastorn: I'll try it
23:55:19 <pastorn> Veinor: thanks :)
23:55:40 <pastorn> o-_-o: why do you qualify the q and not use it?
23:56:12 <o-_-o> pastorn, well that is how I learnt it, maybe I am wrong...
23:56:31 <pastorn> o-_-o: data Q = MkQ V would be sufficient here
23:56:39 <o-_-o> ah...ok
23:56:46 <pastorn> as well as 'data V = MkV Float Float'
23:56:49 <pastorn> but you could do
23:56:55 <pastorn> 'data V v = MkV v v'
23:57:03 <pastorn> if that's useful for you :)
23:57:15 <o-_-o> pastorn, I originally started of doing that
23:57:26 <o-_-o> pastorn, but it was not useful in my case
23:57:31 <o-_-o> pastorn, thanks
23:57:32 <pastorn> ah, and you just happened to leave the 'v' there :)
23:58:11 <o-_-o> pastorn, I think so :-)
23:58:24 <Veinor> pastorn: where does extra.list live in cabal?
23:58:34 <Veinor> ah, extra
23:58:39 <pastorn> o-_-o: there's something called GADTs where you can have 'data V v = MkV Float Float' (almost) and actually do stuff with the 'v'
23:58:54 <pastorn> Veinor: sorry for not being speedy enough :p
23:59:07 <o-_-o> pastorn, ok
23:59:23 <o-_-o> where do I find the difference between data and class ?
23:59:24 <Veinor> ok, I got it too.
23:59:25 <arcatan> pastorn: tried getFPs ".", got the same error
23:59:34 <o-_-o> I have RWH but I don't know where to look
23:59:36 <Veinor> 6.12.1 OS X 10.6
23:59:40 <Veinor> er, 12.2
23:59:50 <pastorn> i'm running 6.12.
23:59:52 <pastorn> 3
23:59:53 <arcatan> 6.12.3 and OS X 10.6
23:59:53 * ski . o O ( `data V :: * -> * where MkV :: Float -> Float -> V Float' ?)
