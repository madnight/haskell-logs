00:00:23 <dankna> no, that's all I had to work from
00:00:45 <r463> is haskell a good language for a beginner to programming
00:01:08 <ManateeLazyCat> r463: Yes.
00:01:37 <r463> ManateeLazyCat: want to tell me why
00:02:08 <unkanon> r463: if you've never programmed in any other language then I would definitely start out with Haskell
00:02:33 <r463> unkanon: ok
00:02:35 <kmc> r463, Haskell makes you think in a way very different from most languages.  i think it's an extremely useful and beautiful viewpoint, but it may be the long way around if you have some particular practical task in mind
00:02:46 <ManateeLazyCat> r463: Infact, if you know nothing about programming, Haskell is perfect language to start... :)
00:02:50 <r463> unkanon: i know a tinsy bit of c but not enough to say i know c
00:03:01 <r463> about a chapter of k&r :p
00:03:01 <kmc> r463, it's often said that it's easier to learn Haskell if you know nothing than if you know other languages
00:03:04 <unkanon> r463: great, then learn haskell and forget about C
00:03:14 <r463> unkanon: hehe ok
00:03:18 <r463> got a book i can use?
00:03:27 <kmc> r463, i think starting with Haskell is a great idea.  i think starting with Scheme and reading SICP is also a great idea.
00:03:32 <unkanon> r463: start out with learnyouahaskell  (google it)
00:03:39 <ManateeLazyCat> r463: Haskell wikibook or "Real World Haskell"...
00:03:39 <kmc> the latter is somewhat more conventional -- it's how MIT and Caltech teach their CS students
00:03:58 <kmc> (at least, both used to, and Caltech still has it for the CS majors)
00:04:40 <ManateeLazyCat> kmc: Many university teach Haskell in USA? 
00:04:45 <kmc> ManateeLazyCat, few i know of
00:04:51 <r463> unkanon: ok
00:04:58 <r463> kmc: so which one would you recommend
00:05:01 <kmc> at Caltech we had a Haskell class that was pretty popular, but it was an elective
00:05:10 <r463> kmc: scheme or haskell
00:05:12 <kmc> r463, maybe you can tell us more about why you want to learn programming
00:05:23 <r463> kmc: i just want to design elegant programs *shrug*
00:05:28 <r463> be like you guys
00:05:31 <r463> and design things
00:06:02 <kmc> r463, i'd start reading SICP, it's free online: http://mitpress.mit.edu/sicp/full-text/book/book.html
00:06:02 <ManateeLazyCat> r463: Infact, this not best language in this world, just most suitable language for you.
00:06:16 <r463> kmc: oh so scheme instead of haskell then?
00:06:18 <r463> ok thanks.
00:06:24 <kmc> r463, not necessarily
00:06:28 <ManateeLazyCat> r463: You need know what's you want, then choose language.... 
00:06:53 <kmc> r463, if you get bored with Scheme, switch to Haskell
00:06:59 <r463> kmc: heh
00:07:13 <r463> ok thanks
00:07:14 <r463> ill read 
00:07:19 <kmc> Scheme is tiny, beautiful and elegant
00:07:34 <kmc> Haskell is also quite elegant but is a much more complicated language
00:07:56 <kmc> Haskell is a lot better for writing "real" programs, imo
00:08:05 <zark4711> i have kindalike a beginners question. i have written a program that calles the program convert from the image magick tool chain several times (~400). after the 300th time or so i get the error: /opt/local/bin/convert: runProcess: resource exhausted (Resource temporarily unavailable). i am wondering. i am using the following command to call it:     ExitSuccess <- waitForProcess =<< runProcess   pathToConvert [<a lot of options>] Nothing Noth
00:08:05 <kmc> but i say that without having attempted to write a "real program" in scheme
00:08:22 <c_wraith> I really wish haskell was a little simpler.  It could do without "if..then..else" and "default", for instance.
00:08:52 <kmc> r463, at any rate from your stated goals, i'm sure you'll end up learning Haskell eventually
00:09:09 <unkanon> c_wraith: you're saying if-then-else is what makes it complicated?  ;)
00:09:24 <zark4711> so my guess is that waitForProcess actually does wit for the process to terminate. so the problem should not be that too many processes are created on my system. i really have no other clue why this could be happening
00:09:31 <c_wraith> unkanon, yes.  It's the most complicated language construct I've ever encountered. ;)
00:09:34 <kmc> r463, i also highly recommend getting good at C, for a very different perspective
00:10:07 <mauke> zark4711: try strace to see which syscall is failing
00:10:08 <unkanon> zark4711: run the code with 10 seconds between each convert and see if you get the same error.
00:10:16 <kmc> if you know Scheme, C, Haskell, Python, and C#, you'll have covered a large fraction of the programming language concepts out there
00:10:17 <unkanon> c_wraith: please explain
00:10:19 <ManateeLazyCat> zark4711: Yes, when you open to many process, will got that error.
00:11:16 <unkanon> c_wraith: what would you have instead of ifthenelse?
00:11:40 <kmc> :t let if' True x y = x; if' False x y = y in if'
00:11:41 <lambdabot> forall t. Bool -> t -> t -> t
00:11:43 <kmc> it's an ordinary function
00:11:44 <mauke> unkanon: case-of
00:11:48 <kmc> but we give it special syntax for no good reason
00:12:01 <kmc> making it an ordinary function would also drive home the point about laziness quite early on
00:12:17 <kmc> beginners tend to overuse if, head, and length, and underuse pattern matching
00:12:33 <c_wraith> Yeah, I'd be much happier if "if" was a function in the Prelude, rather than a language construct
00:12:49 <unkanon> well i gotta agree with you there
00:12:57 <unkanon> special syntax for if is unwarranted
00:13:05 <zark4711> mauke, unkanon, ManateeLazyCat: i will try strace. i already added a wait between process invocations with 500ms. this did not help. i also invoked the garbage collector after each runProcess. i will try to increase the wait to a few seconds.
00:13:09 <kmc> what we really need is an extension for mixfix operators
00:13:28 <unkanon> zark4711: yes increase the wait to a few seconds, that might just do the trick
00:13:35 <unkanon> that would be the first test i'd run
00:13:47 <unkanon> make yourself a sandwich while it's running :)
00:14:45 <unkanon> kmc, mauke, c_wraith, what we really need is a language that is to Haskell like Ruby is to Smalltalk  :)
00:15:32 <kmc> how is Ruby to Smalltalk?
00:15:36 <kmc> fancier syntax?
00:15:40 <kmc> is that the comparison you mean?
00:17:25 <unkanon> same idea but easier to dive into
00:20:39 <unkanon> ...or not  :P
00:21:37 <kmc> what makes ruby easier to dive into than smalltalk?
00:21:59 <kmc> haskell is pretty hard to dive into, this is true
00:22:11 <kmc> i don't necessarily see this as a huge problem
00:22:40 <kmc> it matters if you want to take over the world
00:22:52 <unkanon> people that are trying to learn and find it difficult are the ones most likely to find it a huge problem
00:23:04 <unkanon> smalltalk is also to big a a paradigm leap because it's purely OO
00:23:13 <unkanon> whereas ruby compromises, therefore it is more accessibler
00:23:17 <unkanon> accessible*
00:25:15 <kmc> the axis i'm talking about is not easy / hard
00:25:22 <kmc> it's instant gratification vs. investment needed
00:26:15 <unkanon> I think Ruby is the epitome of instant gratification, being incredibly easy to dive into and even guess at the names of methods and syntax
00:26:41 <eevar2> what does hello world in smalltalk look like? ruby's is: puts "hellow orld!"
00:26:42 <unkanon> that's why I say we need an equivalent language that does that for Haskell like ruby does to Smalltalk
00:26:53 <kmc> "need" w.r.t. what goal?
00:26:56 <kmc> world domination?
00:27:21 <unkanon> eevar2: Transcript show: 'hello world!'
00:27:34 <unkanon> kmc: to get more people into functional programming
00:27:43 <unkanon> we have enough people doing OO already
00:28:00 <kmc> Haskell is not going to be the wedge introducing FP to the mainstream
00:28:14 <unkanon> kmc: btw just as a tip, the word "re" already means "w.r.t." and it's shorter  ;)
00:28:15 <kmc> remember that most popular languages support FP
00:28:23 <kmc> people do loads of FP in Python, Ruby, C#, etc.
00:28:34 <kmc> and those languages continue to borrow more ideas from Haskell
00:28:48 <kmc> i don't want Haskell to be accessible only to smart people.  but i am okay with it being only accessible to people who care a little bit
00:28:59 <kmc> i don't feel we need to bend over backwards to convince everyone to learn Haskell
00:29:02 <unkanon> I still think there's a gap to be filled, so much so that F# tried/is trying to fill it
00:29:07 <eevar2> kmc: the fp style 'supported' by said languages doesn't really make it come off as great, tho
00:29:11 <kmc> true
00:29:24 <kmc> the extreme of that being FP in C++, which is so painful that it would sour you on the idea entirely
00:29:50 <kmc> i think Python, Ruby, and Javascript code is quite often higher-order, and in a natural way
00:30:03 <kmc> those programmers don't think they're doing anything esoteric, they're just getting the job done
00:30:06 <kmc> and that's the way FP should be seen
00:30:51 <kmc> Haskell probably has more to contribute to awareness of static type systems that don't suck
00:30:56 <kmc> rather than the very basic "what is a lambda" stuff
00:33:31 <unkanon> those languages that borrow ideas from haskell still lack basic stuff that are very helpful, like pattern matching
00:33:46 <kmc> yeah
00:33:53 <kmc> that's more specific than functional programming though
00:34:00 <mm_freak> i wonder which of the following hello worlds is going to be more appealing:
00:34:07 <mm_freak> main = putStrLn "Hello world!"
00:34:15 <mm_freak> main = mapM_ putChar "Hello world!"
00:34:40 <mauke> main = putStr "Hello, world!\n"
00:34:41 <Veinor> appealing to who?
00:34:44 <unkanon> kmc: how specific is it?
00:34:56 <unkanon> yeah use mauke's
00:35:02 <mm_freak> Veinor: someone, who doesn't know haskell
00:35:10 <unkanon> functions ending in Ln are so Pascal  :P
00:35:17 <mm_freak> mauke: any reason why you prefer putStr?
00:35:32 <mauke> yeah, because it's simpler
00:35:40 <unkanon> mm_freak: I know very little haskell so I can help. and I agree with mauke.
00:35:43 <mauke> and so I can immediately see Haskell supports the standard \n stuff
00:35:47 <kmc> unkanon, algebraic data is not found in most functional languages, by most commonly used definitions of what a functional language is
00:35:52 <mauke> fucking lisp
00:36:18 <mm_freak> mauke: good point
00:36:33 <mm_freak> how about:
00:36:37 <unkanon> mm_freak: are you writing a tutorial?
00:36:50 <mm_freak> main = getLine >>= printf "Hello %s!"
00:36:54 <arcatan>  hopefully a monad tutorial?
00:36:55 <mm_freak> + \n
00:37:01 <mm_freak> unkanon: nope
00:37:11 <mm_freak> i was just playing around
00:37:17 <mm_freak> arcatan: i've already written one =P
00:37:28 <kmc> fucking monads, how do they work
00:37:34 <kmc> ;)
00:37:39 <arcatan> oh, you're old enough
00:37:47 <unkanon> i've never seen that question asked here :P
00:38:03 <mm_freak> kmc: they don't
00:38:07 <mm_freak> they just combine =P
00:38:15 <arcatan> maybe people have gotten over monads a bit
00:38:47 <unkanon> if only another language used monads, maybe it'd be simpler to explain
00:38:54 <kmc> you never forget your first monad
00:39:21 <ManateeLazyCat> dankna: My mail is lazycat.manatee@gmail.com, can you send message to me if you find solution?
00:39:25 <dolio> Why would that make it easier to explain?
00:39:38 <kmc> there's the "jquery is a monad" article
00:39:39 <mm_freak> how about showing monads, applicative functors and currying in a single, simple hello program?
00:39:45 <kmc> and loads of implementations of monads in lots of languages
00:39:53 <kmc> they are actually useful too
00:40:04 <unkanon> dolio: because when you see the same thing in two languages you can abstract away the particularities of each and focus on what you're trying to learn
00:40:43 <mm_freak> main = mapM_ putChar <$> (printf "Hello %s!\n" <$> getLine)
00:41:17 <unkanon> kmc: I wouldn
00:41:17 <mm_freak> kmc: actually those "blah is a monad" tutorials often don't make much sense
00:41:30 <unkanon> kmc: I wouldn't say loads, and I wouldn't say useful, but otherwise I agree :)
00:42:22 <mm_freak> a monad is a type of kind * -> * and for a monad 'm' there is this function (>>=) :: m a -> (a -> m b) -> m b, which you can't even express in most other languages
00:42:57 <mauke> (>>=) is easy, return is the problem
00:43:01 <mm_freak> even F# providing syntactic support for monads can't express it
00:43:09 <mm_freak> so you couldn't write mapM in F#
00:43:32 <kmc> unkanon, lots of Java code out there where every other line is "if (x == null) return null;"
00:43:35 <mm_freak> you can write:  parserMapM, listMapM, maybeMapM, stateMapM, ‚Ä¶
00:43:46 <kmc> this is a prime use case for a very simple monad
00:43:47 <unkanon> the problem is few languages have type constructors (although i've been told here that type constructors are not really needed for monads to be able to exist in a language)
00:44:06 <mm_freak> unkanon: they have type constructors and generics
00:44:11 <mm_freak> but they lack generic generics
00:44:21 <unkanon> kmc: is that the maybe monad?
00:44:22 <kmc> there is a difference between "using some particular monads" and "writing a library which is usable with all monads, i.e. Control.Monad"
00:44:23 <kmc> unkanon, yes
00:44:27 <mm_freak> you can pass F<A> or F<B>, but not that F
00:44:40 <mm_freak> unkanon: the Cont monad
00:44:44 <kmc> until you have said library, it's not so useful to assign this one name "monad" to a lot of disparate things
00:44:46 <mm_freak> Maybe is different
00:45:07 <mauke> mm_freak: same effect
00:45:15 <kmc> the reason we have this funny word "monad" is that we wanted a single name for a variety of related code patterns, and a library for working with them
00:45:35 <kmc> if you're just doing IO, or just doing errors, or just doing parsing, or just doing code generation, maybe you don't care about the generality
00:45:50 <unkanon> you guys should help write the Monads in Ruby tutorial, it's been stuck on the 3rd chapter forever
00:45:58 <mm_freak> mauke: in this case, yes, but usually they also return some value
00:46:14 <mm_freak> if (cond) return 15;
00:46:29 <mauke> mm_freak: you can't abstract that part out
00:46:37 <mauke> so monads buy you nothing there
00:47:05 <mm_freak> mauke: i don't understand‚Ä¶  in the Cont monad i have 'when' and 'abort' (or callCC)
00:47:17 <mauke> mm_freak: in java I have if/return
00:47:23 <mauke> so why bother with a monad?
00:47:39 <mm_freak> mauke: because the question was whether that is modelled by the Maybe monad
00:47:46 <mm_freak> 126 094357 <unkanon> kmc: is that the maybe monad?
00:47:54 <unkanon> mauke: is Cont is a true continuation, then you can do a lot more with continuations then with if
00:47:55 <kmc> i refer specifically to the pattern in java code
00:48:03 <kmc> where you call a lot of functions and return 'null' if any of them returns null
00:48:03 <unkanon> mauke: if Cont is...**
00:48:05 <mauke> mm_freak: no, whether you can get rid of that line by using Maybe
00:48:15 <kmc> and otherwise use the earlier results in later calls
00:48:33 <mm_freak> mauke: i don't see, where that question was asked
00:48:45 <kmc> and this is very much what the Maybe monad does in Haskell
00:48:50 <mm_freak> unkanon: Cont is, well, just about anything =)
00:49:20 <unkanon> mm_freak: oh ok, i thought it was a continuation in the Scheme sense of continuation
00:49:27 <mm_freak> it allows all kinds of control flow, from extremely clever to extremely stupid
00:49:34 <mm_freak> you can even model the good old 'goto' using Cont =)
00:49:41 <mm_freak> yes, it is
00:49:50 <unkanon> i can same these same things for a continuation
00:49:55 <unkanon> oh ok :)
00:50:04 <mm_freak> look up what you can do with call/cc in scheme =)
00:50:15 <unkanon> yeah i know continuations, you can make any control flow structure with continuations
00:50:22 <mm_freak> yep
00:50:23 <unkanon> mm_freak: already done that
00:50:25 <mm_freak> :t callCC
00:50:26 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
00:50:29 <mm_freak> ;)
00:57:18 <industrial> Right so I don't understand this (yet); 'let villain = (28, "chris") in fst villain'. I'm doing tryhaskell.org. How can you use villain when you haven't defined it yet? or have you? and if so why first define something a = b and then say but b is not b, b is a selection of b. I don't get it.
00:58:12 <industrial> let villain = fst (28, "chris") looks logical to me, but that doesn't work :P
00:58:13 <FauxFaux> industrial: villain is just a "local variable".  (int a = 5;)
00:58:28 <FauxFaux> let .. in .. is a construct like {} in real languages. ¬¨_¬¨
00:58:40 <mm_freak> industrial: in haskell, the '=' really makes an equation
00:58:53 <mm_freak> you can write:
00:59:02 <mm_freak> > let (x, y) = (123, 456) in x
00:59:02 <lambdabot>   123
00:59:06 <kmc> real languages lol
00:59:10 <unkanon> industrial: let in is so that you don't pollute the namespace
00:59:18 <kmc> yes, it's a local scope
00:59:29 <kmc> you have defined it yet
00:59:40 <kmc> the bindings in the first part scope over the second part
00:59:45 <kmc> if you like:
00:59:57 <kmc> > let { villain = (28, "chris") } in fst villain
00:59:58 <lambdabot>   28
01:00:01 <mm_freak> industrial: but i guess the best answer to your question is:  "it's just an example"
01:00:10 <industrial> heh ^^
01:00:11 <kmc> the braces are implicit from whitespace, usually, but you can always put them in if you like
01:00:29 <mauke> > let { a = 2; b = 3 } in a + b
01:00:30 <lambdabot>   5
01:00:43 <mm_freak> > let 2 + 2 = 5 in 2 + 2
01:00:44 <lambdabot>   5
01:00:48 <kmc> hehe
01:00:52 <kmc> that one's silly
01:01:00 <mm_freak> it is, but it's funny =)
01:01:10 <industrial> hm so the first part is the scope for the part after in?
01:01:30 <mauke> industrial: the first part is bindings, the second part is the body in which those bindings are active
01:01:32 <mm_freak> the first part makes equations, which hold in the second part
01:01:38 <kmc> mhm
01:01:43 <kmc> the equations can even be recursive
01:01:44 <industrial> right, ok
01:02:02 <unkanon> industrial: circleArea = let pi = 3.14 in pi * r ^2
01:02:09 <kmc> > let { xs = 5 : xs } in sum $ take 4 xs
01:02:10 <lambdabot>   20
01:02:34 <unkanon>  > circleArea = let pi = 3.14 in pi * 4 ^2
01:02:39 <mauke> unkanon: fail
01:02:42 <unkanon> :(
01:02:53 <unkanon> > circleArea = let pi = 3.14 in pi * 4 ^2
01:02:54 <lambdabot>   <no location info>: parse error on input `='
01:03:06 <mm_freak> hmm, but lambdabot seems to include it anyway
01:03:07 <mauke> told ya
01:03:11 <mm_freak> > testx = 5
01:03:12 <lambdabot>   <no location info>: parse error on input `='
01:03:16 <mm_freak> ah, no
01:03:21 <unkanon> ?!?!?
01:03:21 <lambdabot> Unknown command, try @list
01:03:29 <mm_freak> lol
01:03:31 <ksf_> unkanon, you're missing an in, there.
01:04:12 <mm_freak> @let circleArea r = let pi = 3.14159 in pi * r^2
01:04:13 <lambdabot>  Defined.
01:04:14 <mauke> > let a = 2 * let b = 3 in b in a
01:04:15 <lambdabot>   6
01:04:23 <unkanon> ksf_: I'm lost. it compiles for me!
01:04:30 <kmc> the thing you pass to lambdabot must be an expression, not a statement or a declaration
01:04:36 <unkanon> ohhhh
01:04:36 <mauke> > let { a = 2 * (let { b = 3 } in b) in a
01:04:37 <kmc> the top level of a file holds declarations
01:04:37 <lambdabot>   <no location info>: parse error on input `in'
01:04:43 <kmc> and the ghci loop takes statements
01:04:43 <mauke> > let { a = 2 * (let { b = 3 } in b) } in a
01:04:44 <mm_freak> unkanon: lambdabot is essentially a GHCi session on IRC
01:04:44 <lambdabot>   6
01:04:52 <kmc> this is the difference
01:04:55 <mm_freak> unkanon: you can't write top level definitions in its evaluator, but you can use @let
01:04:58 <unkanon> > let pi = 3.14 in pi * 4 ^2
01:04:59 <lambdabot>   50.24
01:05:02 <kmc> "let .. in .." is an expression, but "let .." is a statement
01:05:02 <unkanon> finally
01:05:06 <mauke> > pi * 4^2
01:05:07 <lambdabot>   50.26548245743669
01:05:28 <mauke> > pi 4^2
01:05:29 <lambdabot>   9.869604401089358
01:05:30 <kmc> and "f x = x + 3" is a declaration.  which is valid at top level, or in the first part of a let
01:05:35 <kmc> (or in a where, etc.)
01:05:40 <mm_freak> :t pi
01:05:41 <lambdabot> forall a. (Floating a) => a
01:05:44 <unkanon> mm_freak: haven't used ghci much, i usually compile
01:05:48 <mm_freak> is this caleskell?
01:05:58 <mm_freak> :t ($)
01:05:59 <lambdabot> forall a b. (a -> b) -> a -> b
01:06:00 <kmc> unkanon, ah, ghci is super useful, i recommend it much
01:06:03 <ksf_> :t (^)
01:06:04 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
01:06:09 <kmc> especially for learning, debugging, and testing
01:06:10 <ksf_> :t 4
01:06:10 <lambdabot> forall t. (Num t) => t
01:06:11 <mauke> mm_freak: it's instance (Num a) => Num (b -> a)
01:06:17 <mm_freak> ah, ok
01:06:35 <ksf_> > 2 3
01:06:36 <lambdabot>   Ambiguous type variable `t' in the constraint:
01:06:36 <lambdabot>    `GHC.Num.Num t' arising f...
01:06:39 <ksf_> > 2 3 :: Int
01:06:40 <lambdabot>   2
01:06:40 <mm_freak> so it's kinda-caleskell =)
01:06:41 <unkanon> kmc: oh i know it is, it's not like I hate it :) just haven't done much in it
01:06:42 <mauke> > (sqrt + pi) 4
01:06:43 <lambdabot>   5.141592653589793
01:07:03 <ksf_> > 3 2 :: Int
01:07:04 <lambdabot>   3
01:07:09 <mm_freak> > (sin^2 + cos^2) 5
01:07:10 <lambdabot>   0.9999999999999999
01:07:13 <ksf_> shouldn't that be 6?
01:07:14 <mm_freak> hmm, interesting
01:07:23 <mm_freak> i always used arrows for that
01:07:51 <mm_freak> > ((^2) >>> (sin &&& cos)) 5
01:07:52 <lambdabot>   (-0.13235175009777303,0.9912028118634736)
01:07:59 <ksf> :t 3 2
01:08:00 <lambdabot>     Ambiguous type variable `t' in the constraint:
01:08:00 <lambdabot>       `Num t' arising from the literal `2' at <interactive>:1:2
01:08:00 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
01:08:05 <mm_freak> > uncurry (+) $ ((^2) >>> (sin &&& cos)) 5
01:08:05 <lambdabot>   0.8588510617657006
01:08:09 <ksf> :t (3 :: Int) 2
01:08:10 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `Int'
01:08:10 <lambdabot>     In the expression: (3 :: Int) 2
01:08:12 <kmc> hmm can we generalize the instance to ¬´(Monad m, Num a) => Num (m a)¬ª
01:08:13 <mm_freak> d'oh
01:08:19 <ksf> :t 2 (3 :: Int)
01:08:19 <lambdabot> forall t. (Num (Int -> t)) => t
01:08:27 <mauke> kmc: we can generalize to Applicative
01:08:31 <kmc> yay
01:08:32 <unkanon> kmc: are you french?  :)
01:08:33 <kmc> right
01:08:35 <kmc> unkanon, no
01:08:43 <mauke> kmc: http://mauke.ath.cx/stuff/haskell/fun.hs
01:08:46 <mm_freak> > uncurry (+) $ ((sin &&& cos) >>> ((^2) *** (^2))) 5
01:08:47 <lambdabot>   0.9999999999999999
01:08:55 <unkanon> hmm funny, you were using ¬´these¬ª
01:09:21 <kmc> right, because ' and " and () and {} and [] already have meaning within the language
01:09:39 <mm_freak> hmm
01:09:50 <mm_freak> instance Arrow a => Num (a b c) where ‚Ä¶
01:09:55 <mauke> I like „Äåthis kind of quotes„Äç for code
01:10:01 <kmc> eep
01:10:08 * kmc doesn't know how to type those
01:10:11 <unkanon> !!
01:10:16 <mauke> idea stolen from Jeffrey Friedl
01:10:30 <unkanon> how do you type those?
01:10:40 <mauke> with the key between lshift and z
01:10:54 <kmc> i like the brackets that look like a ligature of [| or |]
01:11:00 <kmc> they're called oxford brackets sometimes
01:11:01 <unkanon> mauke: are you on a mac?
01:11:03 <mauke> which is actually the y key, but my keyboard layout makes it a z
01:11:03 <mm_freak> ‚àÇy/‚àÇx ‚àà ‚Ñù¬≤[x]
01:11:06 <kmc> i'm not sure if they're even in unicode
01:11:07 <mauke> unkanon: no
01:11:23 <unkanon> mauke: then i have no idea how to type these still
01:11:26 <mm_freak> and i like real arrows
01:11:29 <mm_freak> a ‚Üí b =)
01:11:35 <kmc> ‚ä¢ (œÉ‚ÇÅ ‚Üí œÑ‚ÇÅ) ‚â§ (œÉ‚ÇÇ ‚Üí œÑ‚ÇÇ)
01:11:35 <unkanon> you show-offs
01:11:40 <aleator> Are there any neat ways of stuffing metadata to functions or values in haskell?
01:11:52 <mauke> aleator: no
01:11:53 <kmc> unkanon, i use X's compose-key feature plus some custom bindings i added
01:11:56 <kmc> i'll be happy to send you the file
01:12:03 <mm_freak> aleator: "meta data"?
01:12:15 <MoALTz> testÀ©
01:12:28 <unkanon> mauke: i've got nothing between lshift and z
01:12:54 <kmc> aleator, do you have an example of something you'd like to do more cleanly?
01:13:02 <mm_freak> unkanon: i have written an xmodmap for special characters
01:13:11 <mm_freak> i type most of them using my Alt Gr key
01:13:15 <unkanon> mm_freak: oh,that explains it
01:13:31 <kmc> compose key is such a great feature
01:13:33 <aleator> Ie. I'm using thing like data Described a = Describe a String, to make sure I know what the stuff in my log file originally was. But this causes a plague of view patterns
01:14:14 <kmc> why?
01:14:28 <kmc> are you exporting the type Described abstractly and trying to use it in another module?
01:14:33 <unkanon> mm_freak: Alt Gr ?? that's an old keyboard
01:14:59 <aleator> kmc: No, just that I've got to unpack/repack the values everytime they get used.
01:15:03 <kmc> oh
01:15:08 <kmc> that's true enough
01:15:09 <mm_freak> unkanon: dunno, it may be called "right alt" in other countries
01:15:11 <kmc> but how do view patterns help?
01:15:13 <mauke> unkanon: http://en.wikipedia.org/wiki/File:KB_Germany.svg
01:15:31 <mauke> my keyboard looks almost like that
01:15:39 <mm_freak> aleator: pack/unpack for ByteString?
01:15:41 <kmc> aleator, it sounds like a record update.  did you look at fclabels or another record-related package?
01:15:43 <unkanon> mauke: hmm very interesting
01:15:44 <ksf> ...the most important part is the additional key right to the left shift, though.
01:15:54 <mm_freak> aleator: or do you rather mean:  extract/rebuild?
01:15:56 <ksf> ...so you can put ~ there and have esc at the proper place.
01:15:58 <mauke> unkanon: I use it with a modified en_US layout, though
01:15:58 <aleator> kmc: I got a more abstract type so, it is views instead of normal patterns.
01:16:03 <kmc> ah
01:16:14 <unkanon> mauke: i can only use the regular US layout
01:16:18 <kmc> why does german need ¬µ?
01:16:23 <kmc> or do i misread that symbol
01:16:26 <ksf> it doesn't.
01:16:27 <mauke> ¬µ
01:16:29 <aleator> mm_freak: Well I mean "use the described value & keep the descriptor"
01:16:35 <ksf> but typewriters always had it.
01:16:35 <unkanon> mauke: i don't like dedicated keys for things like √§
01:16:38 <kmc> ksf, heh
01:16:40 <kmc> why that one?
01:16:44 <mauke> kmc: scientific units?
01:16:49 <mauke> unkanon: me neither
01:16:52 <kmc> heh
01:16:58 <mm_freak> aleator: you could derive most instances like Num for your type
01:17:10 <mm_freak> uhm, not derive, but write
01:17:19 <mauke> the german keyboard layout sucks for programming; look at the placement of {[]}\
01:17:24 <ksf> the paragraph-sign is also virtually unused, unless you're a lawyer.
01:17:31 <mm_freak> mauke: i've got used to it
01:17:40 <mauke> mm_freak: write more perl
01:17:44 <unkanon> mauke: wow that's confusing
01:17:46 <kmc> ¬∂?
01:17:47 <mm_freak> i don't write any perl =)
01:17:56 <mauke> see, that's the problem
01:17:57 <kmc> i rather like ¬ß
01:18:05 <aleator> mm_freak: That does help a bit.
01:18:07 <mauke> perl uses pretty much all of US-ASCII
01:18:18 <mm_freak> aleator: about static information‚Ä¶
01:18:30 <mm_freak> ah, no
01:18:32 <zark4711> mauke, unkanon, ManateeLazyCat: ah, i found out that another line i forgot about caused the problem. the process i create in the following line does not terminate until the whole program terminates
01:18:33 <zark4711> (_,out,_,_) <- runInteractiveProcess imageMagickIdentify [inputDir</>fileName] Nothing Nothing
01:18:33 <zark4711>             hSetBinaryMode out False
01:18:34 <mm_freak> it's not static =)
01:18:34 <zark4711>             c <- hGetContents out
01:18:55 <mm_freak> but using arrows, you could model this:  (a, String) -> (b, String)
01:19:07 <ManateeLazyCat> zark4711:  runInteractiveProcess with hGetContents ?
01:19:08 <zark4711> i tried using print.length%c in order to read the entire input. but still, that does not terminate the process
01:19:10 <aleator> mm_freak: If it was?
01:19:13 <ManateeLazyCat> zark4711: If you do that, it's wrong.
01:19:13 <unkanon> zark4711: but otherwise did spacing out a few seconds help?
01:19:36 <kmc> http://www.kinesis-ergo.com/images/qd-contour-layout.gif  <----- victory
01:19:44 <ManateeLazyCat> zark4711: hGetContents is evil can't works well with runInteractiveProcess, at least have trick you need care.
01:20:09 <mauke> ok, I couldn't parse "at least have trick you need care"
01:20:09 <pumpkin> Omg
01:20:18 <mm_freak> aleator: it's not static in the sense i mean
01:20:29 <ManateeLazyCat> mauke: quicksilver know 
01:20:35 <mauke> U+00B5 (c2 b5): MICRO SIGN [¬µ]; U+03BC (ce bc): GREEK SMALL LETTER MU [Œº]
01:20:43 <mauke> good job, unicode
01:21:11 <unkanon> kmc:  win ---->  http://www.handykey.com/
01:21:14 <mm_freak> aleator: but you can easily do this:  describe :: String -> a :--> a
01:21:24 <unkanon> kmc: i'll be buying one in two weeks
01:21:44 <zark4711> ManateeLazyCat: ok. i will have a look at the documentation. i wonder what goes wrong. since after the length of c is determained all the imput is read an the handle should switch from semi-closed to closed. at least that was what i expected
01:22:02 <mm_freak> aleator: newtype a :--> b = Desc ((a, String) -> (b, String))
01:22:31 <ManateeLazyCat> zark4711: quicksilver know how evil of hGetContents , you can ask him. :)
01:23:05 <mm_freak> aleator: then, in arrow notation:  describedValue <- describe "blah" -< rawValue
01:23:06 <zark4711> unkanon: yes, using a delay of a few seconds rather than 300ms did give me the time to start up "Instruments" try to attach to my process and then finding a a number of 'identify' processes that were not terminated yet
01:23:17 <mauke> „Äñam I lens yet?„Äó
01:23:29 <mm_freak> would make 'describedValue' a variant of 'rawValue', but with the description "blah"
01:23:51 <aleator> Hmm..
01:23:54 <aleator> Interesting.
01:24:02 <unkanon> mauke: did you see this? http://www.handykey.com/
01:24:08 <mauke> kmc: ‚ü¶oxford brackets?‚üß
01:24:21 <zark4711> ManateeLazyCat: hmm. i saw that kind of usage once in the graphviz lib...which caused a problem there too, which length content did fix
01:24:23 <mauke> unkanon: looks crazy
01:25:13 <unkanon> mauke: i've been waiting some 4 years for them to release it again and they just did a week ago or so
01:25:49 <aleator> mm_freak: or how about if I made Described applicative instead? If a Described func gets a Described result result is described result and so on?
01:25:57 <aleator> Pretty much same yes?
01:26:10 <zark4711> quicksilver? tell me more about the evilness of hGetContents. what is the commad for listing the people in a channel by the way? the obvoius list is for all channels....
01:26:11 <ManateeLazyCat> zark4711: hGetContents use unsafeInterleaveIO, unsafeInterleaveIO is evil.....
01:26:27 <mm_freak> aleator: i don't think, you can model this using Applicative/Monad alone
01:26:35 <ManateeLazyCat> zark4711: I guess quicksilver sleeping.
01:27:17 <mm_freak> aleator: note that in a functor/monad you would work with the actual value, so the description information gets lost as soon as you bind
01:27:33 <mm_freak> in an arrow you work with the transformations you apply to those values
01:27:40 <mm_freak> so this information is carried along implicitly
01:28:09 <pumpkin> Embrace the power of The Arrow!
01:28:24 <mm_freak> and there is also implicit multiplexing, if you have multiple such values, if you use arrow syntax
01:28:43 <zark4711> ManateeLazyCat: is there some "strict" version of hGetContents? what is the usual work around?
01:28:48 <mm_freak> those two conveyor belts, you know =)
01:29:02 <ManateeLazyCat> zark4711: AFAIK, no.
01:29:09 <mm_freak> zark4711: use ByteString instead of String
01:29:15 <zark4711> and why did print . length $ theContent not work?
01:29:16 <mm_freak> then you get a strict hGetContents
01:29:24 <aleator> mm_freak: Never tried anything sensible with arrows. Perhaps I should try to sketch something up and see what I get.
01:29:33 <zark4711> mm_freak: ah, thank you
01:29:35 <mm_freak> aleator: just try it out
01:31:04 <aleator> mm_freak: First I try with a functor and then with an arrow
01:31:23 <mm_freak> aleator: functor would work, but it wouldn't solve your actual problem =)
01:31:45 <mm_freak> you would still need to wrap/unwrap and use view patterns or pattern guards =)
01:32:22 <aleator> mm_freak: The alternative is to use arrow syntax?
01:32:34 <mm_freak> aleator: probably
01:32:35 <kmc> aleator, did you look at fclabels?
01:33:11 <mm_freak> aleator: at least you could do normal pattern matches without having to drop the description and put it back in
01:33:40 <aleator> kmc: Yes. Atleast they helped me to figure out that I can lift functions to use described values, which could solve something
01:34:34 <kmc> that seems like precisely what you wanted
01:36:07 <ManateeLazyCat> @tell quicksilver zark4711 want to know how evil of hGetContents... :)
01:36:07 <lambdabot> Consider it noted.
01:36:14 <aleator> kmc: Have to try it out. The problem with these questions is that you can never give enough context for an exact answer.
01:36:43 <pumpkin> I think people other than quicksilver would know of the evil of hGetContentd
01:36:45 <kmc> fair enough
01:37:11 <mauke> > let (‚ü¶) = drop in 2
01:37:12 <lambdabot>   <no location info>: lexical error at character '\10214'
01:37:16 <mauke> aww
01:37:17 <aleator> hmm. ok. Described is not a functor..
01:38:08 <kmc> > ord '‚ü¶'
01:38:09 <lambdabot>   10214
01:38:11 <kmc> > chr 10215
01:38:12 <lambdabot>   '\10215'
01:38:18 <kmc> > text $ pure $ chr 10215
01:38:19 <lambdabot>   ‚üß
01:38:55 <mauke> > text "\10216"
01:38:55 <lambdabot>   ‚ü®
01:39:17 <ManateeLazyCat> > text "\10295"
01:39:18 <lambdabot>   ‚†∑
01:39:23 <ManateeLazyCat> > text "\10296"
01:39:24 <lambdabot>   ‚†∏
01:39:27 <ManateeLazyCat> Funny
01:39:32 <industrial> gotta love UTF8
01:39:38 <unkanon> > text "\2620"
01:39:39 <lambdabot>   ‡®º
01:39:52 <ManateeLazyCat> > text "\50926"
01:39:53 <lambdabot>   ÏõÆ
01:39:54 <unkanon> > text "\U+2620"
01:39:54 <lambdabot>   <no location info>:
01:39:54 <lambdabot>      lexical error in string/character literal at chara...
01:40:06 <mauke> > text "\x2620"
01:40:06 <lambdabot>   ‚ò
01:40:20 <unkanon> > text "\9760"
01:40:21 <lambdabot>   ‚ò
01:40:43 <mauke> huh?
01:40:45 <kmc> > text "\10217"
01:40:46 <lambdabot>   ‚ü©
01:40:58 <unkanon> does it take the UTF32 decimal or what?
01:41:11 <kmc> it's the unicode code point value
01:41:13 <mauke> unkanon: it takes a unicode codepoint
01:41:25 <kmc> encoding is irrelevant
01:41:33 <mauke> I don't understand what's up with your skull, though
01:41:54 <kmc> Compose C C C P:   ‚ò≠
01:42:38 <unkanon> mauke: oh did it come out as a skull?
01:42:46 <MoALTz> > text "\x2308\x230b"
01:42:47 <lambdabot>   ‚åà‚åã
01:42:51 <unkanon> mauke: good then , that's what i was trying,. i don't see it though. something wrong with my firefox
01:43:04 <mauke> unkanon: no, it didn't
01:43:17 <mauke> U+00E2 (c3 a2): LATIN SMALL LETTER A WITH CIRCUMFLEX [√¢]; U+02DC (cb 9c): SMALL TILDE [Àú]
01:43:24 <unkanon> mauke: oh, then yeah, don't know why it doesnt work
01:43:39 <mauke> I don't know where it got the SMALL TILDE
01:44:16 <mauke> > text "\10214\9760"
01:44:16 <lambdabot>   ‚ü¶‚ò
01:44:30 <mauke> > text (take 1 "\10214\9760")
01:44:30 <lambdabot>   ‚ü¶
01:44:39 <mauke> looks like something's broken in text or lambdabot
01:46:31 <unkanon> i think lambdabot has an anti-skull bias
01:46:52 <mauke> > text "\9759"
01:46:53 <lambdabot>   ‚òü
01:46:58 <mauke> > text "\9761"
01:46:59 <lambdabot>   ‚ò°
01:47:04 <mm_freak> aleator: i'm trying to implement it
01:47:06 <kmc> snake!
01:47:08 <unkanon> !!
01:47:13 <pumpkin> Hiss
01:47:19 <unkanon> traitor! it does 9759 and 9761 but not 9760
01:47:43 <pumpkin> Any good Haskell developments in the past month or so?
01:47:49 <mauke> > text "\9765 if you love Isis"
01:47:50 <lambdabot>   ‚ò• if you love Isis
01:47:54 <unkanon> > text "\9762"
01:47:55 <lambdabot>   ‚ò¢
01:50:28 <chrisdone> heh, two years ago I couldn't find an SMTP library for Haskell, now there are four on hackage
01:50:56 <zark4711> thank you all again!
01:51:18 <zark4711> i went to the toilet and everything is so clear now.
01:51:54 <pumpkin> Means you're drinking enough water, that's good
01:52:02 <zark4711> :)
01:54:44 <zark4711> what i am still wondering about is that the ulility top did not list all those created processes.
01:54:55 <zark4711> ps does
01:55:54 <zark4711> hmm. ps has listed those processes as Zombies
01:56:10 <pumpkin> Gragh brainzzz
01:56:33 <unkanon> > text (concat . map (("\\"++) . show) $ [ x | x <- [9730..9780] ])
01:56:34 <lambdabot>   \9730\9731\9732\9733\9734\9735\9736\9737\9738\9739\9740\9741\9742\9743\9744...
01:57:05 <pumpkin> You want to add some quotes around that and read it in again?
01:57:21 <unkanon> hmm let me think :)
01:57:44 <kmc> chrisdone, do they work?
01:57:53 <unkanon> > text $ show (concat . map (("\\"++) . show) $ [ x | x <- [9759..9761] ])
01:57:54 <mauke> > text ['\9730'..'\9780']
01:57:54 <lambdabot>   "\\9759\\9760\\9761"
01:57:55 <lambdabot>   ‚òÇ‚òÉ‚òÑ‚òÖ‚òÜ‚òá‚òà‚òâ‚òä‚òã‚òå‚òç‚òé‚òè‚òê‚òë‚òí‚òì‚òî‚òï‚òñ‚òó‚òò‚òô‚òö...
01:58:16 <unkanon> hmm I see I took the complicated route :D
01:58:31 <unkanon> why doesn't mine work?
01:58:34 <kmc> pumpkin, tryhaskell.org made it to the Reddit front page, and contained a one-click link to join IRC here
01:58:47 <kmc> pumpkin, resulting in an extremely entertaining flood of newbies
01:58:52 <unkanon> > text $ show (concat . map (("\"++) . show) $ [ x | x <- [9759..9761] ])
01:58:53 <lambdabot>   <no location info>:
01:58:53 <lambdabot>      lexical error in string/character literal at end o...
01:58:58 <kmc> and lots of "haskell sucks, how is it better than C#, prove me wrong"
01:58:58 <pumpkin> Ooh, nice :D
01:59:07 <kmc> but this lasted all of a day
01:59:13 <pumpkin> How surprising :P
01:59:31 <kmc> maybe some of them stuck around
01:59:34 <mauke> unkanon: because \ is part of the string syntax, it's not interpreted by 'text'
01:59:49 <unkanon> so i should call somethign else instead of text ?
01:59:56 <unkanon> > show (concat . map (("\\"++) . show) $ [ x | x <- [9759..9761] ])
01:59:57 <lambdabot>   "\"\\\\9759\\\\9760\\\\9761\""
02:00:12 <kmc> i think you want "read"
02:00:16 <mauke> unkanon: [ x | x <- y ] is the same as y
02:00:23 <kmc> > read "\\73" :: String
02:00:24 <lambdabot>   "*Exception: Prelude.read: no parse
02:00:27 <unkanon> > read (concat . map (("\\"++) . show) $ [9759..9761])
02:00:29 <lambdabot>   *Exception: Prelude.read: no parse
02:00:31 <kmc> > read "\"abcd\\73\"" :: String
02:00:31 <lambdabot>   "abcdI"
02:00:48 <kmc> > read (concat . map (("\\"++) . show) $ [9759..9761]) :: String
02:00:49 <lambdabot>   "*Exception: Prelude.read: no parse
02:00:59 <kmc> read is polymorphic and here in lambdabot will default to returning the type ()
02:01:13 <unkanon> :(  lambdabot is no fun 
02:01:14 <unkanon> hehe
02:01:25 <kmc> > read ('"' : (concat . map (("\\"++) . show) $ [9759..9761]) ++ "\"") :: String
02:01:25 <lambdabot>   "\9759\9760\9761"
02:01:30 <kmc> > text $ read ('"' : (concat . map (("\\"++) . show) $ [9759..9761]) ++ "\"") :: String
02:01:31 <lambdabot>   Couldn't match expected type `GHC.Base.String'
02:01:31 <lambdabot>         against inferred typ...
02:01:37 <kmc> > text $ read ('"' : (concat . map (("\\"++) . show) $ [9759..9761]) ++ "\"")
02:01:38 <lambdabot>   ‚òü‚ò†‚ò°
02:01:52 <kmc> > text $ map chr [9759..9761]
02:01:53 <lambdabot>   ‚òü‚ò†‚ò°
02:02:04 <unkanon> okay, now I know, thanks :)
02:02:35 <unkanon> oh and now the skull is there!
02:02:46 <unkanon> mauke: did you see that mauke?
02:02:50 <mauke> yes
02:02:52 <kmc> ‚öõ‚ô•‚ôÄ
02:04:01 <unkanon> > read "text"
02:04:01 <lambdabot>   *Exception: Prelude.read: no parse
02:04:07 <kmc> > read "()"
02:04:08 <unkanon> > show "text"
02:04:08 <lambdabot>   ()
02:04:09 <lambdabot>   "\"text\""
02:04:11 <kmc> > read "3.0" :: Double
02:04:12 <lambdabot>   3.0
02:04:22 <kmc> > read "[2,5,8]" :: [Double]
02:04:23 <lambdabot>   [2.0,5.0,8.0]
02:04:27 <wto> :D
02:04:29 <unkanon> > read "text" :: String
02:04:30 <lambdabot>   "*Exception: Prelude.read: no parse
02:04:36 <kmc> > read "\"text\"" :: String
02:04:37 <lambdabot>   "text"
02:04:48 <mauke> > read "'x'" :: Char
02:04:49 <lambdabot>   'x'
02:04:54 <unkanon> read "\"text\ntext\"" :: String
02:05:02 <unkanon> > read "\"text\ntext\"" :: String
02:05:02 <lambdabot>   "text\ntext"
02:05:10 <unkanon> it doesn't do multiple lines?  :)
02:05:13 <mauke> it does
02:05:19 <mauke> otherwise that would have been a parse error
02:05:28 <mauke> > read "\"text\\ntext\"" :: String
02:05:29 <lambdabot>   "text\ntext"
02:05:30 <kmc> read turns Haskell source code into a value, so long as the source code is just a literal
02:05:42 <mauke> > text "a\nb"
02:05:43 <lambdabot>   a
02:05:43 <lambdabot>  b
02:05:55 <unkanon> what do i have to include to make text work in my ghci?
02:06:05 <unkanon> it says it's not in scope
02:06:06 <mauke> unkanon: nothing, just use putStrLn
02:06:11 <kmc> Text.PrettyPrint
02:06:17 <kmc> @hoogle text
02:06:18 <lambdabot> Text.Html text :: String -> HtmlAttr
02:06:18 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
02:06:18 <lambdabot> Text.XHtml.Transitional text :: String -> HtmlAttr
02:06:22 <kmc> the second one
02:06:47 <unkanon> i get nothing but errors
02:07:33 <mauke> using what?
02:07:52 <unkanon> Text.PrettyPrint and Text.PrettyPrint.HughesPJ
02:08:42 <mauke> be more specific
02:09:52 <unkanon> mauke: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28228#a28228
02:10:52 <mauke> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28228#a28229
02:12:43 <unkanon> oh that's what you meant
02:12:44 <unkanon> thanks
02:12:50 <kmc> unkanon, you probably wanted to do
02:12:53 <kmc> :m + Text.PrettyPrint
02:13:01 <unkanon> i'll do a let text = Text.PrettyPrint.HughesPJ.text just so I don't lose my mind
02:13:01 <kmc> then the unqualified name "text" should work
02:13:11 <unkanon> oh
02:13:15 <kmc> importing the module is probably a better solution
02:13:15 <mauke> unkanon: 'import Text.PrettyPrint.HughesPJ'
02:13:38 <Ferdirand> hello #haskell
02:13:39 <mauke> or ... just use putStrLn
02:13:42 <kmc> hi Ferdirand
02:14:03 <Ferdirand> is there a way to explicitely "fork" an expression and break sharing ?
02:14:09 <kmc> how do you mean?
02:14:10 <trom> 42,13,22
02:14:14 <Ferdirand> say I want to do Floyd's cycle-finding on an infinite list
02:14:36 <Ferdirand> so I want two iterators running trough the evaluation at different speeds
02:14:56 <Ferdirand> and I don't want all the values between my two iderators to remain in memory
02:15:08 <Ferdirand> I want two separate iterations of the list, that get GCed independently
02:15:16 <kmc> you can't use that algorithm on an ordinary Haskell infinite list
02:15:21 <kmc> because you can't do pointer comparison
02:15:45 <Ferdirand> mhh... I don't understand that reasoning
02:15:46 <kmc> as for un-sharing the spine of a list, that's simple; ¬´map id¬ª will do it
02:15:55 <Ferdirand> ah, perfect
02:15:59 <kmc> Ferdirand, unless you know your list only has unique elements
02:16:01 <Ferdirand> I suspected id might be of use
02:16:34 <Ferdirand> unique elements ?
02:16:49 <kmc> as you consume a list's elements one-by-one, you have no way to tell if the element you just reached is "the same" as another element, or merely equal but a distinct value in memory
02:16:50 <Ferdirand> well, I know any element uniquely determines the tail
02:16:55 <kmc> sharing is not supposed to be observable in Haskell
02:17:12 <kmc> and so you can't tell a short infinite list from a really long finite list
02:17:16 <Ferdirand> that's fine
02:17:23 <Ferdirand> it's for Pollard's method
02:17:37 <Ferdirand> if the values are equal, i'm happy
02:17:40 <kmc> ok
02:18:07 <mm_freak> the minimal complete definition of Arrow is 'arr' and 'first', and 'second' can be derived from that‚Ä¶  is this a requirement?  or can there be Arrow instances, for which you /must/ provide 'second' manually for it to make sense?
02:18:13 <Ferdirand> map id... that's nice
02:18:27 <Ferdirand> thanks
02:19:51 <kmc> mm_freak, i think that ¬´second f = arr (\~(a,b) -> (a, f b))¬ª would be an Arrow law
02:19:54 <kmc> or so
02:20:21 <mm_freak> hmm, ok
02:20:46 <kmc> the fact that Arrow has arr is what's made it useless for most of the things i've wanted it for
02:21:17 <DrSyzygy> arr is the thing that makes an arrow out of stuff, right?
02:21:25 <kmc> makes a function into an arrow value
02:21:26 <mm_freak> out of a function, specifically
02:21:27 <kmc> :t arr
02:21:28 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
02:21:44 <kmc> it's a functor from the category Hask to the category a
02:21:44 <mm_freak> if 'stuff' would be more abstract, that would probably be more useful
02:21:53 <DrSyzygy> kmc: So you're problem with Arrow is you don't necessarily want instances to be images of functions?
02:21:57 <kmc> yes
02:22:06 <kmc> i want to do things like wire together graphs of filters
02:22:18 <kmc> where i can't necessarily make a filter out of any arbitrary Haskell function
02:22:32 <kmc> if you're doing any kind of deep embedded DSL, you probably can't
02:22:37 <kmc> because functions are totally opaque
02:22:48 <DrSyzygy> kmc: Can't you state up front that you're making a misbehaved Arrow implementation, and then just map any function anyone gives you to some trivial value?
02:23:09 <kmc> DrSyzygy, then the arrow "proc" syntax becomes useless, and that's most of the point of using Arrow
02:23:16 <kmc> compared to, say, Category, plus some custom combinators
02:23:21 <DrSyzygy> Point.
02:23:25 <DrSyzygy> :t proc
02:23:26 <lambdabot> Not in scope: `proc'
02:23:33 <kmc> it's syntax
02:34:14 <kmc> i dunno, Arrows seem kind of half-baked to me
02:36:13 <mm_freak> kmc: so far i had the impression that anything i could implement with arrows i could also implement with monads/functors
02:36:27 <ManateeLazyCat> dankna: I found a better idea to parse re-export information than GHC.getInfo, i will send code to you after i implement it.
02:36:52 <mm_freak> but aleator's problem may be the first exception
02:42:35 <artelius_> Hello, I've been thinking about objects which can have multiple internal representations - some of which are better for certain operations and others for other operations. For instance, representing complex numbers in rectangular and polar form. It seems like it would be nice to have a type which can automagically vary its choice of internal representation depending on how it's used. Has there been any work like this?
02:43:06 <chrisdone> @hoogle GMapKey
02:43:06 <lambdabot> No results found
02:44:10 <spiry> Hi !
02:47:32 <mm_freak> artelius_: type families
02:47:56 <artelius_> Yeah I'm reading about them now
02:54:50 <artelius_> Man this stuff is awesome
02:57:15 <nibiru_> artelius_: what stuff?
02:58:07 <artelius_> type families
03:54:03 <ski> kmc : only in OCaml, yes
03:54:05 <ski> dolio : "combining compatible monads" ?
03:55:48 <dolio> ski: Where you write a 'class Bind m n o where (>>=) :: m a -> (a -> n b) -> o b', or something like it.
03:56:47 <ski> i was wondering if maybe there was a post or paper or something
03:57:07 <dolio> I don't remember. I think edwardk was experimenting with it a while back.
03:57:22 <dolio> But as I said, it leads to ambiguities such that you have to stick annotations all over the place.
03:57:56 * ski has experimented a little with `class (Monad m,Monad n) => Thin m n where thin :: m a -> n a; joinThin :: m (n a) -> n a; (>>=|) :: m a -> (a -> n b) -> n b' and `class Thin m n => Thick m n where thick :: n a -> m a; joinThick :: n (m a) -> m a; (|>>=) :: n a -> (a -> m b) -> m b'
03:59:07 <ski> the three examples i've played with is basically `[a] -> (a -> Maybe b) -> Maybe b',`State sr a -> (a -> Reader sr b) -> Reader sr b',`Num n => [a] -> (a -> Const n b) -> Const n b'
03:59:36 <ski> .. the two former supporting both `Thin' and `Thick', while the latter only supporting `Thin', iirc
04:00:25 <ski> dolio : ok, ty. i'll try to ask him later
04:00:58 <dolio> Are the methods of both classes supposed to have identical signatures other than all the ms switched with ns and vice versa?
04:01:24 <ski> (the classes comes with a set of laws .. but i don't think i fully worked it all out completely, last time)
04:01:30 <dolio> Oh, I guess since Thick requires Thin, it makes a difference.
04:01:56 <dolio> Thick would go in both directions or something.
04:02:01 <ski> yeah
04:03:05 <ski> (and the `join' vs. `>>=' is only for convenience, oen would suffice)
04:05:04 <dolio> Sure.
04:05:21 <dolio> join should be in Monad, too.
04:05:30 * ski nods
04:06:07 <dolio> Although it's possible it doesn't really matter. Over time I've come to the conclusion that (>>=) might actually be the better primitive.
04:06:48 <dolio> Lots of implementations of join tend to be identical to bind with an id stuck in and reduced a little.
04:07:19 <dolio> Which it might be feasible for the compiler to do today.
04:07:39 <ski> well, in some cases `join' is conceptually simpler than `(>>=)'
04:07:50 <dolio> Whereas fusing an fmap into join is asking more.
04:09:13 <ski> yeah, like substitution in expression monads being inefficient ..
04:09:35 <dolio> Yeah, that's a good example.
04:09:46 * wli thinks join is simpler than (>>=) rather frequently.
04:10:23 <dolio> That's also a case where writing (>>=) directly isn't really any more difficult.
04:11:00 <dolio> 'join (Var e) = e' versus 'Var e >>= f = f e'.
04:11:01 <ski> sometimes it's easier to write the `join' first and then to derive `(>>=)' from that
04:11:17 * ski recalls doing that, dually for comonads, at least
04:16:23 <dolio> Wow, GHC gets some interesting bugs.
04:16:30 <dolio> 'randomRs is too lazy'
04:17:52 <theorbtwo> dolio: "This function always returns the number 23, which I just chose at random."
04:20:18 <dolio> That's not even a compiler issue.
04:20:36 <dolio> Nor is the 'sequence should be rewritten to be tail recursive for some monads' bug.
04:26:12 <deteego> does anyone know how to catch exceptions raised by Read on a custom datatype (for example reading a string into an Enumeration when that string doesn't exist as an Enumeration)?
04:26:27 <quicksilver> deteego: don't.
04:26:27 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
04:26:31 <quicksilver> deteego: use reads instead
04:26:40 <deteego> quicksilver: thanks
04:26:54 <quicksilver> for no parse it returns an empty list
04:27:18 <deteego> :type reads
04:27:22 <deteego> eh woops
04:35:34 <quicksilver> @messages
04:35:34 <lambdabot> ManateeLazyCat said 2h 59m 27s ago: zark4711 want to know how evil of hGetContents... :)
04:54:34 <cizra> @src when
04:54:35 <lambdabot> when p s = if p then s else return ()
04:56:37 <Twey> :t when
04:56:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:56:46 <Twey> @let (y ?? n) p = if p then y else n
04:56:47 <lambdabot>  Defined.
04:56:49 <Twey> :t flip (?? return ())
04:56:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:58:39 <jkramer> Ahoy
04:58:53 <Twey> Avast!
04:59:19 <jkramer> I'm having a weird problem with ghc (6.12.1)
04:59:32 <jkramer> Or cabal, I'm not sure
05:00:06 <jkramer> Sometimes when I build stuff (like the mongodb driver), I'm getting an out of memory error, with a requested amount of memory of ~1.8G
05:00:21 <jkramer> Then, when I run again, everything builds smoothly
05:00:45 <Saizan> does it happen in the linking phase?
05:01:21 <Saizan> ld is the usual culprit for obscene amount of memory used during compilation
05:01:56 <jkramer> Saizan: I don't think it's linking anything, I'm building a lib, not a binary
05:02:05 <jkramer> On the other hand, I have no idea :)
05:03:02 <jkramer> I'm not sure if it's linking anything at or when it does it. In my example it failed after this line:
05:03:05 <jkramer> [7 of 8] Compiling Database.MongoDB.Admin ( Database/MongoDB/Admin.hs, dist/build/Database/MongoDB/Admin.o )
05:04:36 <Saizan> linking happens after the "Linking..." line
05:05:15 <Saizan> at "[7 of 8] ..." there's still ghc compiling
05:16:15 <deteego> is there a function in Haskell which allows you to call a function on a certain element in a list
05:16:58 <quicksilver> which element would that be?
05:17:10 <quicksilver> just compose with !!, or your selection function of choice.
05:17:38 <quicksilver> > (reverse . (!!2)) $ ["The","quick","brown","fox","jumped"]
05:17:39 <lambdabot>   "nworb"
05:18:03 <Twey> Unless you meant an update
05:20:49 <Twey> > (map (uncurry $ (take 1 ?? id) . (== 1)) . zip [1 ..]) $ ["The","quick","brown","fox","jumped"]
05:20:50 <lambdabot>   ["T","quick","brown","fox","jumped"]
05:20:59 <Twey> > (map (uncurry $ (take 1 ?? id) . (== 1)) . zip [0 ..]) $ ["The","quick","brown","fox","jumped"]
05:21:00 <lambdabot>   ["The","q","brown","fox","jumped"]
05:21:36 * hvr would have tried w/ splitAt :-)
05:26:45 <quicksilver> whilst what Twey wrote is - evidently - correct, I'd never do it.
05:26:59 <quicksilver> I'd take it as a hint that list was the wrong structure and switch to Seq or one of the map variants
05:29:36 <Jonno_FTW> ??
05:29:43 <Jonno_FTW> :t (??)
05:29:43 <lambdabot> forall t. t -> t -> Bool -> t
05:31:41 <deteego> quicksilver: a right, forgot about !!, thanks
05:42:56 <Twey> quicksilver: Well, the predicate could be something like ((== 0) . (`mod` 2)) to alter every other element
05:43:12 <Twey> > (map (uncurry $ (take 1 ?? id) . (== 0) . (`mod` 2)) . zip [0 ..]) $ ["The","quick","brown","fox","jumped"]
05:43:14 <lambdabot>   ["T","quick","b","fox","j"]
05:43:21 <Twey> Which I think is an appropriate operation for a list
05:57:11 <MigoMipo> > (getZipList . (ZipList (cycle [\x -> [head x], id]) <*>) . ZipList) $ ["The","quick","brown","fox","jumped"]
05:57:12 <lambdabot>   ["T","quick","b","fox","j"]
06:00:27 <helge> > zipWith ($) (cycle [(:[]) . head, id]) ["The","quick","brown","fox","jumped"]
06:00:28 <lambdabot>   ["T","quick","b","fox","j"]
06:03:20 <ClaudiusMaximus> > zipWith id (cycle [take 1, map toUpper, id]) (words "The quick brown fox jumped")
06:03:21 <lambdabot>   ["T","QUICK","brown","f","JUMPED"]
06:04:14 <quicksilver> Twey: yes
06:05:07 <Phantom_Hoover> How are Haskell's lists implemented?
06:05:20 <ClaudiusMaximus> @src []
06:05:20 <lambdabot> data [] a = [] | a : [a]
06:05:33 <Phantom_Hoover> No, I mean in terms of bytes in memory.
06:05:44 <helge> ClaudiusMaximus: take 1, heh.. Why didn't I think of that :P
06:05:53 <zygoloid> Phantom_Hoover: in GHC, [] is represented by a pointer. (a:as) is represented as three pointers.
06:05:58 <Lemmih> Phantom_Hoover: As a linked list.
06:06:03 <Phantom_Hoover> Right, OK.
06:06:05 <Phantom_Hoover> Thanks.
06:06:13 <quicksilver> Phantom_Hoover: the same way as all other haskell data structures... it's quite uniform.
06:06:17 <quicksilver> (in GHC)
06:06:20 <Zao> Who'd thunk that :D
06:06:51 <zygoloid> Phantom_Hoover: an unevaluated closure is represented as a pointer plus the data that closure needs to compute the resulting list.
06:07:39 <interferon> so the IO monad in GHC is literally an alias for "State RealWorld" ?
06:07:53 <interferon> i thought the RealWorld exercise was just a metaphor for learning
06:08:08 <zygoloid> interferon: it's a newtype for something of that approximate form
06:08:41 <Heffalump> no it's not
06:08:52 <Heffalump> IO and *ST* are related closely
06:09:06 <quicksilver> interferon: it's absolutely not.
06:09:10 <quicksilver> State# is not State.
06:09:25 <interferon> oh, i thought State# was just a strict, unboxed State
06:09:27 <quicksilver> it's got something in common, especially in form.
06:09:43 <interferon> quicksilver, Heffalump: what about http://www.haskell.org/ghc/docs/5.04.2/html/base/GHC.IOBase.html
06:09:46 <interferon> the very first entry
06:09:59 <quicksilver> yes, indeed. I know what the definition says.
06:10:05 <quicksilver> State is not State#
06:10:21 <quicksilver> GHC is implemented in an underlying - impure - language which looks a lot like haskell, but is not haskell.
06:10:33 <quicksilver> in particular, in this language, evaluation can have observable side effects.
06:10:34 <ClaudiusMaximus> that's an old doc page if the link isn't lying
06:10:37 <Heffalump> if you think of it as being isomorphic to a State monad, then the state token itself is State# RealWorld
06:10:50 <quicksilver> it's a bit like ML, with haskell syntax.
06:10:59 <zygoloid> interferon: IO is implemented by something isomorphic to State (State# RealWorld), where State# is magic
06:11:29 <zygoloid> actually, that's not quite true. the "State" uses an unboxed tuple :(
06:11:29 <quicksilver> some of the #-defintions work in this impure language
06:11:45 <quicksilver> as such they're not quite as analagous to haskell as they appear.
06:12:00 <interferon> huh.
06:12:08 <interferon> so it's a State transformer of a State transfomer
06:12:12 <quicksilver> ClaudiusMaximus: it appears to be an old link but this part hasn't changed anyway.
06:12:48 <zygoloid> interferon: no. State# is not a state transformer nor a state monad. it's just a magic type.
06:13:08 <interferon> okay
06:13:17 <zygoloid> interferon: "State# s" is the type of a 'state' (the state of an ST or IO computation)
06:13:38 <zygoloid> but there's not really anything interesting you can do with this knowledge
06:15:19 <Heffalump> State# doesn't really have any representation
06:16:40 <zygoloid> is a forced State# not represented as just an info table pointer, much like Nothing or [] ?
06:17:06 <Heffalump> it's unboxed, so it'll always be forced, and not a pointer (AIUI)
06:17:22 <interferon> i think i'm better off treating it as a black box :)
06:17:41 <interferon> quicksilver: is your "underlying, impure language" Core?
06:17:44 <interferon> or Cmm?
06:17:47 * hackagebot AC-Vector 2.1.0 - Efficient geometric vectors and transformations.  http://hackage.haskell.org/package/AC-Vector-2.1.0 (AndrewCoppin)
06:18:29 <zygoloid> Heffalump: the docs say it's unlifted. is it unboxed too?
06:18:54 <ClaudiusMaximus> hm, hp2ps is really quite memory-efficient, using around 45MB total to process a 37MB .hp file; my implementation uses 3GB :(
06:19:16 <benmachine> interferon: Cmm doesn't look a lot like haskell, methinks
06:19:22 <zygoloid> i guess that'd make sense. then (# State# RealWorld, a #) would have the same representation as a
06:20:57 <quicksilver> interferon: Core and Cmm are both impure, but I'm not talking about either
06:21:15 <quicksilver> interferon: There is a level above that, which is close to the Haskell level, in terms of the compilation sequence.
06:21:26 <quicksilver> as you pointed out "data IO =...." looks like haskell
06:22:08 <tab> ClaudiusMaximus: do you have any idea why ?
06:23:24 <ClaudiusMaximus> tab: i guess because i'm using non-compact data structures so far (essentially [(Double, Map String Double)])
06:24:01 <ClaudiusMaximus> tab: storing multiple copies of each string
06:24:48 <tab> fair enough
06:25:10 <tab> using string for any big data is the usual memory killer indeed
06:26:34 <ClaudiusMaximus> the strings are quite short (10s of chars), and there aren't that many distinct strings (maybe 100s), but there are a lot of samples (1000s) each with their own copy of the strings
06:26:35 <soc> hi
06:26:52 <soc> beginner question: i wonder why "let mydrop 0 list = list; let mydrop 1 list = tail list; let mydrop n list = mydrop (n-1) (tail list)" eats all my memory
06:27:27 <benmachine> soc: used in what context?
06:27:40 <soc> i type it in ghci
06:27:47 <benmachine> soc: yes but on what inputs
06:28:45 <benmachine> soc: in particular, if mydrop is called on a negative argument, it will recurse infinitely
06:29:04 <soc> it is on all inputs
06:29:11 <ClaudiusMaximus> soc: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+mydrop+0+list+%3D+list%0D%0A++++mydrop+1+list+%3D+tail+list%0D%0A++++mydrop+n+list+%3D+mydrop+%28n-1%29+%28tail+list%29%0D%0Ain++mydrop+5+%22what+a+wonderful+stepeval%22%0D%0A
06:30:03 <benmachine> ClaudiusMaximus: that woudl seem to suggest it works fine?
06:30:14 <soc> wait ... does it make a difference if i declare them on one line vs. on 3?
06:30:18 <benmachine> nope
06:30:23 <benmachine> ohhh
06:30:25 <benmachine> wait
06:30:25 <benmachine> yes
06:30:31 <benmachine> silly me
06:30:45 <soc> after i have defined the first two, i get the error Non-exhaustive patterns ...
06:30:47 <benmachine> let x = 4; let x = 3; -- the second one overrides the first
06:30:54 <soc> if i do mydrop 0 [1,2]
06:30:58 <soc> ah ok, thanks
06:31:06 <soc> so i should leave out the let after the ifrst one
06:31:11 <benmachine> I think so
06:31:20 <benmachine> all your equations have got to be defined within the same let
06:31:50 * hackagebot GLFW-b 0.0.2.1 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.0.2.1 (BrianLewis)
06:32:20 <soc> benmachine: is there some way to define them on multiple lines?
06:32:36 <ClaudiusMaximus> let { ... ; .... ; ..... }
06:32:49 <ClaudiusMaximus> or write them in a .hs file and load it
06:32:57 <benmachine> defining in a file is easiest
06:33:14 <soc> ok, thanks ...
06:33:18 <ClaudiusMaximus> yep, :r is useful in ghci ("reload")
06:33:35 <quicksilver> ghci can do multiple lines with :{ and :} IIRC
06:33:38 <soc> had to write some haskell in the exams today ... and i got almost a heart stroke when it didn't work in ghci :-/
06:34:29 <benmachine> quicksilver: I think that only works by squishing them all together at the end
06:34:34 <benmachine> so you still have to use {} and ;
06:34:49 <ClaudiusMaximus> or layout?
06:34:58 <quicksilver> benmachine: ah. Nod.
06:35:00 * ClaudiusMaximus tries
06:35:01 <soc> mhh, is there a way to make Haskell behave a bit more like PHP in general?
06:35:08 * quicksilver laughs at soc
06:35:10 * soc runs for cover
06:35:13 <quicksilver> soc: what kind of "like PHP" would you like?
06:35:14 <soc> :-)
06:35:17 <soc> just joking
06:36:04 <osfameron> being installed on every server in the known universe would be nice
06:36:24 <osfameron> presumably someone is working on a php backend for one of the php compilers ?
06:36:27 <soc> maybe more weak typing?
06:36:55 <soc> :-P
06:37:18 <zygoloid> soc: your space leak is caused by building up a thunk of tail (tail (tail (tail (... (tail list)...)))
06:38:03 <soc> is there a way to define mydrop for negative n too?
06:38:22 <benmachine> soc: what behaviour do you want for that case?
06:38:52 <zygoloid> soc: mydrop n list | n < 0 = error "mydrop: negative n" | otherwise = mydrop (n-1) (tail list)
06:38:58 <soc> just returning the original list
06:39:09 <benmachine> | n < 0 = list
06:39:48 <soc> mhh, pattern matches are overlapped ...
06:40:09 <benmachine> stop overlapping them then :)
06:40:17 <soc> so basically either changing the other n to n | n > 1?
06:40:49 <benmachine> soc: what's your whole definition now?
06:42:26 <soc1> benmachine: this http://paste.pocoo.org/show/241847/
06:42:31 <zygoloid> soc: to fix the 'eats all my memory' issue, you need to make mydrop strict in the list argument.
06:42:55 <soc> zygoloid: in the cae n < 0 ?
06:42:59 <benmachine> zygoloid: kiiinda
06:42:59 <soc> s/cae/case
06:43:09 <benmachine> zygoloid: the original eats-all-memory issue was unrelated
06:43:24 <benmachine> the laziness here will only be a problem for large n
06:44:13 <zygoloid> benmachine: the original issue was building an infinite stack of tail (...) thunks; a strict mydrop wouldn't have had that problem ;-)
06:44:19 <zygoloid> (it still wouldn't have terminated though!) ;-)
06:44:27 <benmachine> heh, I suppose so
06:44:37 <benmachine> soc: you're mixing pattern matching with guards there on the same numeric argument, that's not really a problem but if it was me I'd just use guards for the whole thing
06:45:11 <benmachine> soc: the reason you're getting a warning is because GHC can't tell the difference between the third and fourth equations, even though they have different guards
06:45:12 <zygoloid> soc: mydrop n list | n < 0 = ...; mydrop n list | n > 1 = ...   can be rewritten as   mydrop n list | n < 0 = ... | n > 1 = ...
06:45:13 <soc> damn ... i guess i shouldn't have written in the exam "doesn't terminate if n < 0", but better "eats memory until the kernel kills it"
06:45:32 <benmachine> soc: well, that's not terminating :)
06:45:45 <benmachine> it kinda is
06:45:49 <benmachine> but not in a useful way
06:45:58 <soc> mhh, if it's strict it won't eat all memory i guess
06:45:59 <zygoloid> "terminates if n >= 0; is terminated if n < 0" ;-)
06:46:21 <zygoloid> if yu compile with optimizations, GHC should probably figure out it's strict for itself
06:46:37 <benmachine> soc: anyway, in principle your definition does the right thing (although as zygoloid says it has a space leak; you sould use pattern matching directly on the list to take the tail, rather than the tail function)
06:46:42 <benmachine> *should
06:46:43 <soc> another question was "can you drop 5 from an infinite list?" and i thought c'mon ... we're not that stupid :-)
06:46:56 <soc> benmachine: ok, thanks
06:47:06 <quicksilver> > drop 5 [1..]
06:47:07 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,...
06:48:23 <soc> *argh* why does the repl do strict eval there?
06:48:46 <quicksilver> what do you mean?
06:49:04 <soc> quicksilver: it won't stop printing all the numbers
06:49:15 <quicksilver> yes. It calls 'show' on the list
06:49:24 <quicksilver> and show on an infinite list produces an infinite string
06:49:32 <quicksilver> ghci makes no attempt to trim infinite strings
06:50:59 <deteego> does anyone know if its possible to use multiple conditions (using && or ||) when doing a partition
06:51:27 <benmachine> let mydrop _ [] = []; mydrop n xs | n <= 0 = xs; mydrop n (_:xs) = mydrop (n-1) xs
06:51:33 <benmachine> deteego: partition?
06:51:38 <benmachine> as in,
06:51:40 <benmachine> :t partition
06:51:41 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:51:44 <deteego> yes
06:51:48 <benmachine> yes
06:51:50 <benmachine> it is
06:51:55 <benmachine> easiest way is a lambda
06:52:11 <quicksilver> > partition (\x -> x > 5 && odd x) [1..10]
06:52:12 <lambdabot>   ([7,9],[1,2,3,4,5,6,8,10])
06:52:13 <benmachine> > partition (\x -> x < 3 || x > 5) [1 .. 10]
06:52:14 <lambdabot>   ([1,2,6,7,8,9,10],[3,4,5])
06:52:24 <deteego> benmachine: thanks
06:52:32 <benmachine> there are other ways as well
06:52:50 <benmachine> > partition ((||) <$> (< 3) <*> (> 5)) [1 .. 10]
06:52:51 <lambdabot>   ([1,2,6,7,8,9,10],[3,4,5])
06:52:55 <quicksilver> > partition (liftA2 (&&) (> 5) odd) [1..10]
06:52:56 <lambdabot>   ([7,9],[1,2,3,4,5,6,8,10])
06:52:56 <benmachine> they're hardly better :P
06:53:14 <benmachine> ooh, or how about
06:53:21 <soc> that loooks like APL ... but you are not using enough unicode chars :-)
06:53:24 <zygoloid> deteego: (&&) and (||) are just ordinary operators :: Bool -> Bool -> Bool.
06:53:47 <deteego> zygoloid: yeah I had a mind blank and totally forgot about lambda
06:53:51 <benmachine> > partition (and . sequence [odd, (< 7), (> 2)]) [1 .. 10]
06:53:52 <lambdabot>   ([3,5],[1,2,4,6,7,8,9,10])
06:55:03 <benmachine> (my brain keeps telling me that should be sequence $ ..., but 'tis not so)
06:55:43 <deteego> also while I am here quickly, whats the function to count how many times an object occurs in a list
06:56:08 <benmachine> length . filter (== x), I think
06:56:19 <gcross> @hoogle [a] -> a -> Int
06:56:19 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
06:56:19 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
06:56:19 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
06:56:41 <gcross> or possibly length . elemIndices x
06:57:11 <Twey> I thought there was a Data.List.count
06:57:26 <Twey> Maybe not
06:57:40 <gcross> @src count
06:57:40 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:58:18 <quicksilver> there probably should be a Data.List.count, it's quite natural
06:58:37 <RyanT5000> is there a decent mutable datastructure library?
06:58:45 <RyanT5000> i really need a mutable (IO or ST) priority queue
06:59:37 <RyanT5000> and if i have to implement it, i'd like to contribute it back to somewhere where people can find it
07:00:01 <gcross> RyanT5000 why does the data structure itself have to be mutable?
07:00:33 <RyanT5000> well, i suppose it doesn't *have* to be, but i'm already in a mutable context, and i might as well take advantage of that
07:01:22 <benmachine> http://hackage.haskell.org/packages/archive/priority-queue/0.2/doc/html/Data-PriorityQueue.html this looks mutable-ish
07:01:31 <quicksilver> RyanT5000: I'm not particularly sure it would make sense to combine mutable data structures in a library.
07:01:34 <benmachine> http://hackage.haskell.org/package/pure-priority-queue this, not so much
07:02:04 <RyanT5000> benmachine: oh, indeed; i even looked at that library before, but didn't notice the Monad constraints
07:02:13 <jkramer> I just stumbled upon this code: "avg x@(t:ts) = let ..."
07:02:18 <ClaudiusMaximus> benmachine: i found a bug, around line 44 it goes crazy: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+cycle+xs+%3D+xs+%2B%2B+cycle+xs%0D%0A++++pair+a+b+%3D+%28a%2C+b%29%0D%0A++++zip+%3D+zipWith+pair%0D%0Ain++zipWith+%28%24%29+%28cycle+[fst%2C+snd]%29+%24+%22test%22+%60zip%60+%22TEST%22
07:02:21 <jkramer> What does the @ syntax mean?
07:02:32 <RyanT5000> jkramer: @ aliases the two things
07:02:33 <ClaudiusMaximus> jkramer: defines an alias for the rest of the pattern
07:02:40 <RyanT5000> so x is equal to (t:ts) in that case
07:02:40 <Twey> count p = foldr ((succ ?? id) . p) 0 -- I guess
07:02:44 <jkramer> Ah
07:02:47 <zygoloid> jkramer: as-pattern. it gives a name for a chunk of pattern.
07:02:48 <jkramer> Nice, thank you
07:02:58 <RyanT5000> np
07:03:00 <Twey> Oh, there's an ‚Äòodd‚Äô
07:03:07 <benmachine> ClaudiusMaximus: just the one bug? you're not trying hard enough :)
07:03:13 <benmachine> ClaudiusMaximus: but, thanks
07:03:52 * benmachine has a look
07:03:57 <Twey> @let mapWhenKey p f = map (uncurry $ (f ?? id) . p) . zip [0 ..]
07:03:58 <lambdabot>  Defined.
07:04:49 <Twey> > mapWhenKey odd (take 1) ["The","quick","brown","fox","jumped"]
07:04:50 <lambdabot>   ["The","q","brown","f","jumped"]
07:05:37 <benmachine> it seems to keep thinking the first pattern needs more evaluation
07:05:39 <benmachine> I wonde why
07:05:47 <benmachine> *wonder
07:07:18 <deteego> what does (.) do exactly
07:07:27 <Twey> Function composition
07:07:29 <ClaudiusMaximus> @src (.)
07:07:29 <lambdabot> (f . g) x = f (g x)
07:07:29 <lambdabot> NB: In lambdabot,  (.) = fmap
07:07:36 <benmachine> ooh, tuple bug
07:07:48 <portnov> @hoogle Int -> [a] -> [a]
07:07:49 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:07:49 <lambdabot> Prelude take :: Int -> [a] -> [a]
07:07:49 <lambdabot> Data.List drop :: Int -> [a] -> [a]
07:07:49 <Twey> (f . g) x = f (g x) -- the actual definition is the clearest and most concise explanation :√æ
07:07:50 <deteego> ah thanks
07:12:10 <zygoloid> benmachine: i found a bug, at line 11 it gets the wrong answer: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+cycle+xs+%3D+let+r+%3D+xs+%2B%2B+r+in+r%0D%0A++++pair+a+b+%3D+(a,+b)%0D%0A++++zip+%3D+zipWith+pair%0D%0Ain++zipWith+($)+(cycle+[fst,+snd])+$+"test"+`zip`+"TEST"
07:12:18 <zygoloid> (it's lost the binding of 'r')
07:12:55 <benmachine> zygoloid: yeah I think I know about that one
07:13:08 <benmachine> case/let don't mix properly
07:13:27 <benmachine> er by case I mean pattern matching
07:18:38 <wagang> wonder how to correctly define a lambda without any parameters?  \()->1 ?
07:18:41 <benmachine> siiigh
07:18:48 <benmachine> wagang: no such thing as a lambda without parameters
07:18:58 <benmachine> wagang: lambdas are functions by definition
07:19:18 <benmachine> wagang: question is, what would you even use one for?
07:19:41 <benmachine> (p.s. siiigh was totally unrelated to you)
07:20:21 <benmachine> it's annoying that git detects my reindent as a rewrite
07:20:43 <benmachine> sometimes I think line-based diff tools are just a bit... blah
07:22:38 <wagang> benmachine, Thanks, I can define a function without parameters but why not for a lambda ?
07:23:02 <benmachine> wagang: what does a function without parameters look like?
07:23:19 <wagang> like a constant
07:23:30 <ClaudiusMaximus> benmachine: git diff -b  (or -w)  but i don't know how to make that the default, and it might make you miss layout changes that change semantics...
07:24:27 <benmachine> ClaudiusMaximus: but I'm recording a commit
07:25:09 <quicksilver> wagang: "f = 4" is not a function, it's a value.
07:25:19 <ClaudiusMaximus> benmachine: ah, then you want to commit the whitespace changes i guess - so now i understand the problem :)
07:25:28 <quicksilver> wagang: but if that's what you mean by "function with no parameters" then the lambda form equivalent is "4".
07:25:32 <quicksilver> (the lambda is invisible)
07:25:36 <benmachine> ClaudiusMaximus: basically I'm just wishing for one of two things
07:25:56 <benmachine> either diff tools be more sensible about a large number of lines being changed by a small amount each
07:26:12 <wagang> Thanks :)
07:26:13 <benmachine> *or* VCS tools that record my code in some kind of indentation-independent AST :)
07:26:38 <benmachine> er
07:26:44 <benmachine> I'm not sure it would actually be A
07:26:52 <quicksilver> CST.
07:26:59 <benmachine> right
07:27:11 <quicksilver> benmachine: the problem is there is so much useful + powerful line based toolkit out there
07:27:16 <quicksilver> diff is only part of the symptom
07:27:22 <quicksilver> (although, possibly, the single most important part?)
07:27:35 <benmachine> mm
07:27:38 <quicksilver> it would be great to move away from line-based formats but there is a lot of wheel to re-invent.
07:27:45 <quicksilver> I'm thinking grep, awk, sed, etc.
07:27:57 <benmachine> yeah, I suppose so
07:28:20 <benmachine> so, it's a problem with no easy solution
07:28:28 <benmachine> but that's not going to stop me occasionally grumbling :P
07:29:27 <Saizan> well, the easy solution is to develop a very compelling AST-based tool so that people will start reimplementing the rest?:)
07:29:34 <benmachine> wikipedia's explanation of the abstractness of ASTs is a bit weedy
07:30:08 <benmachine> Saizan: I did at one point try to develop a simple tool for converting haskell source files to some sort of HSE-based syntax tree thing
07:30:09 <arw> there are some specialized tools like xmldiff.
07:30:31 <benmachine> or a Binary representation, even
07:31:15 <benmachine> but... I never got it to a state where the compressed forms were sensibly diffable
07:31:57 <quicksilver> arw: yes, and there is xmlstarlet, which replaces the whole grep/awk/sed thing
07:32:10 <quicksilver> but you can't help feeling it's not as easy to understand/use in practice.
07:32:45 <arw> quicksilver: it isn't, and i guess any AST-based tool won't be easy to handle and understand.
07:33:37 <quicksilver> the modern solution is to build GUI tools instead
07:33:43 <quicksilver> (s/the/a/;)
07:33:53 <quicksilver> but I have never yet found them particularly satisfy
07:33:59 <quicksilver> some of the GUI diff/merge tools are KO.
07:34:02 <quicksilver> OK.
07:34:07 <EvanR-work> knocked out?
07:34:13 <arw> thats no solution, thats just a different set of problems.
07:34:16 <ManateeLazyCat> quicksilver: Like ediff ? :)
07:35:00 <benmachine> I should write down things that I am optimistic about
07:35:05 <benmachine> so I can go back and look at it sometimes
07:35:09 <arw> GUIs might be easier to use for the one single simple operation. but they are usually impossible to automate.
07:35:15 <benmachine> sometimes I forget :P
07:36:04 <deteego> arw: nonsense, just need a monkey
07:36:09 <benmachine> the trouble with text interfaces is they have been around for decades, were designed in a somewhat ad-hoc manner, and no-one wants to "fix" them
07:36:51 <benmachine> this is why every hundred years or so we should just incinerate everything and start again <_<
07:36:59 <arw> the problem isn't that nobody wants to fix them. the problem is, nobody knows what a good "fix" would be.
07:37:10 * hackagebot weighted-regexp 0.1.0.0 - Weighted Regular Expression Matcher  http://hackage.haskell.org/package/weighted-regexp-0.1.0.0 (SebastianFischer)
07:37:10 <arw> and nobody ever agrees on whats broken...
07:37:13 <benmachine> heh
07:37:16 <benmachine> that too.
07:37:23 <quicksilver> ManateeLazyCat: yes, I use ediff occasionally for complex 3-way merging
07:38:51 <ManateeLazyCat> quicksilver: Ediff is perfect for simple merge, some complicated situation,  i still need merge manually.
07:39:48 <ManateeLazyCat> quicksilver: I love ediff's directory feature, i can compare two version of Project.
07:39:58 <ManateeLazyCat> quicksilver: Save much time.
07:40:22 <benmachine>     No instance for (Data Constr)
07:40:24 <benmachine> whaaaat
07:40:28 * benmachine facepalms
07:41:36 <benmachine>     The data constructors of `Constr' are not all in scope
07:41:36 <benmachine>       so you cannot derive an instance for it
07:41:37 * benmachine cries
07:42:26 <benmachine> oh it's probably deliberately opaque, I wonder why
07:50:05 <fryguybob> @botsnack
07:50:05 <lambdabot> :)
07:56:58 <ClaudiusMaximus> hooray, from 3GB -> 2GB memory usage by using    State (Map String String) r   to keep only 1 copy of duplicated strings around
07:57:15 * hackagebot AC-Vector-Fancy 2.1.0 - Fancy type system stuff for AC-Vector  http://hackage.haskell.org/package/AC-Vector-Fancy-2.1.0 (AndrewCoppin)
08:09:12 <mornfall> ClaudiusMaximus: Going from String to ByteString could save another gig, I'd guess. :)
08:11:50 <dcoutts_> ClaudiusMaximus, mornfall: depends how long the strings are
08:13:50 * edwardk waves hello.
08:14:16 <wagang> wonder again in another words, How to enclose a block and pass it in CPS, like lambda with no parameters?
08:15:38 <hpc> @pl \x y -> x + (y / 2)
08:15:38 <lambdabot> (. (/ 2)) . (+)
08:16:05 <hpc> > foldl ((. (/ 2)) . (+)) 1 [1..5]
08:16:06 <lambdabot>   8.5
08:16:18 <hpc> just make it pointfree
08:20:11 <wagang> I want to redefine the functionality of map in Continuous Passing Style, so I stuck on that
08:21:26 <edwardk> wagang: every variable in haskell is 'like a lambda with no parameters' it is only evaluated as needed
08:21:35 <edwardk> so just bind it ;)
08:21:57 <edwardk> > let x = 1 + x in "Hello"
08:21:58 <lambdabot>   "Hello"
08:22:10 <edwardk> > let x = 1 + x in x
08:22:14 <lambdabot>   mueval-core: Time limit exceeded
08:22:49 <wagang> Yes, but It seems cannot pass itself to its controller
08:23:54 <wagang> the controller decides when to evaluate its passing block
08:24:28 <tg_> aye - anyone done OCR work in Haskell?
08:24:43 <edwardk> wagang: what is your ultimate goal here?
08:26:23 <wagang> create a closure and pass it with no parameter
08:27:00 <edwardk> that is just a value, remember everything is a memothunk, so it'll be evaluated if needed then remembered
08:29:03 <edwardk> > let x = sum [1..100000] {- creates a closure -} in x -- uses the closure
08:29:03 <lambdabot>   5000050000
08:30:04 <edwardk> there are no side-effects (outside of IO) so this is indistinguishable from what you seem to want
08:32:04 <pickles> mornin all
08:33:29 <rossputin> Hi guys, another newbie question on math expressions in ghci today
08:34:25 <pickles> rossputin: we're listening
08:34:35 <rossputin> hi
08:34:52 <edwardk> wagang: regarding cps'd map
08:34:54 <int80_h> good day everyone
08:35:06 <rossputin> what library or function should I use to convert something like : 3.7037037037037056e-3 into a fraction ?
08:35:09 <edwardk> something like: mapk :: (forall r. a -> (b -> r) -> r) -> [a] -> ([b] -> s) -> s -- ?
08:35:13 <int80_h> anyone care to take a look at this?
08:35:17 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28238#a28238
08:35:26 <edwardk> that would be approximately
08:35:42 <edwardk> mapk f (x:xs) k = f x $ \y -> mapk f xs $ \ys -> k (y:ys)
08:35:47 <edwardk> mapk _ [] k = k []
08:36:43 <edwardk> wagang: assuming that you take a cps'd function into the map
08:37:05 <edwardk> wagang: in practice, we'd just use 'Cont' though
08:37:31 <edwardk> > toRational 3.7037037037037056e-3
08:37:31 <lambdabot>   1067519911673007 % 288230376151711744
08:37:54 <edwardk> rossputin: like that?
08:38:27 <rossputin> Hi edwardk... I had evaluated an expression by hand to (1/270)
08:38:50 <rossputin> but with default means in ghci I got 3.7037037037037056e-3
08:38:53 <wagang> edwardk, I eventually understand it, Thank a lot for your helps! and sorry for just offline due to my router automatically shutdown at fixed time every day.
08:39:07 <edwardk> > 288230376151711744 `divMod` 1067519911673007
08:39:08 <lambdabot>   (269,1067519911672861)
08:39:08 <pickles> > toRational (1.0/270)
08:39:09 <lambdabot>   2135039823346013 % 576460752303423488
08:39:21 <edwardk> its not quite exactly 1/270 ;)
08:39:26 <edwardk> but very close
08:39:28 <rossputin> :-)
08:39:43 <int80_h> edwardk, would you care to suss out some sample code from the Yesod package?
08:39:54 <edwardk> int80_h: erm, what is yesod?
08:40:06 <rossputin> looks good enough for me
08:40:06 <benmachine> rossputin: my advice is to use Rational everywhere in the code, if possible
08:40:19 <benmachine> then you should be able to get an exact answer
08:40:21 <rossputin> I suppose it is all an approximation after working with decimal points etc
08:40:27 <edwardk> rossputin: yeah fromRational can't spot the continued fraction, etc.
08:40:42 <rossputin> thanks for your help guys, appreciate it
08:40:49 <rossputin> not familiar with the libraries / functions yet
08:41:13 <edwardk> int80_h: now i at least know it is a web framework ;)
08:42:02 <benmachine> *nearly* all the information necessary to implement Binary is in Data
08:42:27 <int80_h> edwardk yes, I posted an hpaste if you care to look at it :)
08:42:27 <benmachine> well, it is in fact possible to implement an instance of Binary using Data
08:42:29 <edwardk> benmachine: when properly implemented =(
08:42:33 <quicksilver> I'm not sure that's the Right WAy to do things, though, benmachine.
08:42:34 <int80_h> ah the benmachine!
08:42:41 <benmachine> :O
08:42:52 <benmachine> quicksilver: hmm?
08:42:53 <quicksilver> benmachine: it means that, for example, re-ordering your constructors later will break your Binary instance
08:42:57 <benmachine> oh
08:42:58 <quicksilver> (or any number of similar problems)
08:43:03 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28238#a28238
08:43:04 <benmachine> well, true
08:43:14 <jmcarthur> > 1%270
08:43:15 <lambdabot>   1 % 270
08:43:16 <benmachine> wait a sec
08:43:22 <benmachine> what do you mean by break?
08:43:26 <quicksilver> if it's intended to represent a file format (say) then you need something a bit more stable.
08:43:43 <quicksilver> or a network protocol.
08:43:47 <benmachine> you can't easily have a file format durable against changes in the underlying data type
08:43:53 <quicksilver> but you must.
08:43:55 <quicksilver> :)
08:43:58 <benmachine> bah.
08:44:20 <benmachine> basically I want to encode a haskell-src-exts Exp in a binary format
08:44:35 <benmachine> writing an actual Binary instance would be
08:44:37 <benmachine> unpleasant.
08:44:50 <benmachine> so I was trying to use the Data interface
08:44:57 <benmachine> but that is, also unpleasant
08:45:03 <edwardk> yeow. hamlet looks kind of like one of those cases where you'd open a document in the 80s targeted for a different computer which had its own ascii variant, and all the glyphs would be all wrong ;)
08:45:04 <quicksilver> yup, I can see why you would look for a shortcut.
08:45:13 <benmachine> because the base cases need to use Binary, but everything else needs to use Data
08:45:17 <quicksilver> benmachine: did you try any of the automatic derivation tools?
08:45:18 <benmachine> and, that, doesn't work.
08:45:24 <EvanR-work> benmachine: what about xml? :)
08:45:29 <benmachine> erm, I had a look at them and found them suspicious
08:45:43 <benmachine> EvanR-work: what's the link with xml
08:45:51 <quicksilver> DriFT / Data.Derive can both make binary instances
08:45:51 <benmachine> I could automatically derive I guess
08:46:00 <EvanR-work> file format supposedly durable etc etc
08:46:02 <quicksilver> and I have a suspicion there is a third.
08:46:09 <edwardk> the problem with data is that a lot of built-in instances for data dont do everything they could to actually be instances of Data.
08:46:14 <benmachine> but it just seemed to me that the information used to make Binary instances is typically information provided by the Data instance
08:46:18 <int80_h> edwardk : I don't think it was a mistake on my part. I just tried to run the sample code as packaged by the author and I'm getting same errors
08:46:29 <quicksilver> agreed, benmachine.
08:46:49 <benmachine> it *also* seems to me that the only data type change you can be durable against is re-ordering: both adding and removing constructors kinda screws you inevitably
08:46:50 <edwardk> i.e. Data.Set.Set could have a much nicer data instance which would export a virtual 'fromList' constructor
08:46:53 <edwardk> er e.g.
08:46:55 * benmachine shrugs
08:46:56 <int80_h> when ghc complains of something being not in scope, I think I need to import something. But in this case I have no idea what.
08:47:13 <edwardk> int80_h: i have absolutely no idea. =/
08:47:38 <benmachine> I'll have another look at those deriving tools
08:47:41 <edwardk> int80_h: i presume the api has drifted over time
08:47:51 <benmachine> iirc none of them used TH
08:48:07 <benmachine> don't know if that's a plus or a minus :)
08:48:33 <edwardk> when the public api tends to hide too much (like haskell-src-exts) it is definitely a plus to use TH ;)
08:48:35 <int80_h> edwardk: hah, that must be it. It's amoving target for sure.
08:48:53 <int80_h> I must impore the author of the package for help
08:49:00 <benmachine> edwardk: HSE doesn't hide too much, it just has constructor lists approximately a billion miles long
08:49:40 <benmachine> ghci> length (constrs :: [Exp])
08:49:40 <benmachine> 45
08:49:45 <edwardk> benmachine: well,  most of what i complain about it hiding is in the front end API, things like the fact that you can't start a haskell parser at a given position in a file
08:49:49 <benmachine> ghci> length (constrs :: [Decl])
08:49:49 <benmachine> 28
08:49:51 <benmachine> etc. etc.
08:49:54 <Gracenotes> benmachine: I find the solution there is to use fonts smaller than 2^32 pt
08:50:11 <edwardk> which would be very useful when using it to parse quasiquotations
08:50:17 <edwardk> or parts of quasiquotations
08:50:30 <benmachine> edwardk: a given position? how would that work?
08:51:08 <edwardk> i mean i want to start a parser, but i want it to report its errors relative to position "Foo.hs":100:23 -- i can specify the file at best.
08:51:15 <benmachine> ah
08:51:30 <benmachine> huh, wouldn't've thought that would be too hard
08:51:44 <edwardk> because i'm using it in a quasiquoter and i know exactly where i am in the source file, i know where i am in my custom quasiquoter
08:51:47 <edwardk> me neither
08:52:00 <edwardk> just a random annoyance that screwed me up the other day with it ;)
08:52:31 <benmachine> did you think about fixing it?
08:52:34 <edwardk> i can possibly tell it the source file, and then hack it by specifying a {-# LINE pragma #-} and manually spacing out the expression i then feed it
08:52:40 <benmachine> I guess you'd just put another field in ParseMode
08:52:41 <edwardk> i thought about it
08:53:01 <edwardk> but haskell-src-exts is a bit messy to trudge around in ;)
08:53:04 <benmachine> heh
08:53:12 <benmachine> maybe I'll have a look
08:53:34 * benmachine pokes code.haskell.org
08:53:39 <edwardk> my alex clone would appreciate it ;)
08:54:06 <edwardk> i could give nicer parsing error messages that way
08:54:19 <ksf> any icfp presenters around?
08:54:33 <ksf> actually, everyone who will ever give a talk that's going to be online.
08:54:36 <ksf> http://www.reddit.com/r/haskell/comments/cttcl/icfp_etc_presenters_please_watch_these_lectures/
08:55:02 <benmachine> "It's not just you! http://code.haskell.org looks down from here."
08:55:06 <benmachine> hmph.
08:56:11 <benmachine> (stepeval is up to 4 failing testcases, woo)
08:56:30 <edwardk> ksf: note that the target audience for icfp presentations and the typical undergrad class are a bit different though.
08:56:48 <ksf> sure, but it doesn't hurt to make things accessible.
08:57:13 <ksf> also, not everyone in the real-world icfp audience is a specialist on the specific field you're presenting in.
08:57:50 <ksf> and the lectures contain many things that are applicable to primary school to very specialised papers.
08:58:47 <ksf> like, saying what you're actually trying to do before giving a page-long equation and then discussing the proof.
08:58:54 <int80_h> how do I ask lambdabot about the last time someone was active int he channel?
08:59:05 <ksf> she doesn't remember that.
08:59:09 <ksf> preflex, seen int80_h 
08:59:09 <preflex>  int80_h was last seen on #haskell 15 seconds ago, saying: how do I ask lambdabot about the last time someone was active int he channel?
08:59:19 <int80_h> preflex, seen ski
08:59:20 <preflex>  ski was last seen on #haskell 4 hours, 48 minutes and 2 seconds ago, saying: * ski recalls doing that, dually for comonads, at least
09:00:19 <Igloo> ksf: I doubt you're going to get many presenters to watch 10-20h of video before presenting
09:00:57 <Gracenotes> ksf: do you have any lectures in particular you recommend?
09:01:06 <Gracenotes> not that I'll be presenting
09:01:09 <ksf> I haven't seen them all myself, yet.
09:01:32 <ksf> but I guess you can skip number 4
09:01:43 <ksf> 9, too.
09:02:01 <ksf> 10, possibly.
09:02:28 <Gracenotes> I need to find that way of speeding up lectures without audibly distorting the pitch
09:02:39 <Gracenotes> in general
09:03:17 <ksf> every decent audio editor can do that.
09:03:48 <aavogt> the problem is you might spend more time figuring that out than you save :)
09:04:53 <Gracenotes> ksf: audio, yeah, and do it with video in a single click?
09:04:54 <ksf> spj once gave a good talk about giving talks (and wrote a paper about writing papers), but iirc it focussed on what _seriously_ bad things not to do, and how to keep up at least a basic amount of dramatic tension.
09:05:12 <edwardk> ksf: the worry is that you have a very limited window in which to talk at a conference, so it is difficult to vary your pitch to cover both the 'top of the room' and the 'bottom of the room' and there is an incentive to make sure that you engage and interest the 'top of the room' since they are likely the reviewers and commitee who will be reviewing your next paper. ;) if you simplify too much, you risk your whole line of research 
09:05:14 <ksf> nothing about how to actually present material in a way people don't become puzzled.
09:05:21 <edwardk> ksf: so in academia there is no incentive to be clear ;)
09:06:54 <edwardk> Gracenotes: http://www.hobbsknowledgebase.co.uk/wiki/How_To_Speed_Up_Video_Without_Changing_Pitch
09:07:23 <ksf> wut? presentations are meant to be recitations of the papers, just even more encrypted?
09:07:44 <edwardk> ksf: or elaborations on further implications ;)
09:07:44 <parek> stejne jako kdyz jsi mi tehda rikl
09:08:08 <frogscaleo> hey
09:08:09 <Gracenotes> edwardk: I've had problems with ffmpeg reducing quality. but I don't know all the arguments..
09:08:10 <ksf> oh if only one dared to say "that's a lie there, the gory details are in the paper and quite boring."
09:08:17 <edwardk> ksf: not saying what they are meant to be, just commenting on what, as an outside observer i have been seeing them devolve into ;)
09:08:47 <frogscaleo> i want to learn Haskell to start with functional programming, and to configure xmonad, i only know C
09:08:53 <frogscaleo> can you recommend me a book?
09:09:04 <ksf> learn you a haskell, and real world haskell.
09:09:07 <ksf> (in that order)
09:09:21 <ksf> except if you can't stand lyah's jouvenile style.
09:09:30 <edwardk> Gracenotes: well, any time you decompress and recompress like that you'll be mucking with the keyframing, etc. and the quality will go to crap especially if you aren't starting from high quality originals
09:09:35 <EvanR-work> read: why's guide
09:10:21 <osfameron> lyah is at least on topic, compared to why' guide
09:10:37 <EvanR-work> never!
09:10:42 <ksf> well, /me thinks that how to give classes should be a highschool topic, anyway.
09:10:51 <ksf> 7th or 8th grade
09:11:01 <EvanR-work> type classes?
09:11:09 <ksf> no, kind schools.
09:11:16 <ksf> and sort faculties.
09:11:23 <noteventime> frogscaleo: Real World Haskell is quite nice, and you can read it online, at least untill you know if you like it
09:11:25 <edwardk> ksf: now, for classes, i completely agree with you and the material presented there that i've skimmed so far
09:11:27 <EvanR-work> ._.
09:11:52 <hvr> btw, is there a 2ed planned for RWH?
09:12:25 <frogscaleo> but lean you haskell first?
09:12:36 <benmachine> @where lyah
09:12:36 <lambdabot> http://www.learnyouahaskell.com/
09:12:51 <edwardk> frogscaleo: my wife found flitting back and forth between the two whenever she got stuck to be beneficial.
09:13:07 <EvanR-work> just start with RWH
09:13:11 <ps-auxw> Gracenotes: If you just want to watch the video faster and use mplayer, you can just do: mplayer -af scaletempo -speed 1.75 foo.avi
09:13:14 <EvanR-work> and get GHC
09:13:14 <ksf> otoh, I think I tricked my big sister into becoming a teacher by being a too good and nice pupil. now she's stuck with all those brats.
09:13:25 <edwardk> of course in her case having a circle of friends who all know haskell probably helped
09:13:41 <Gracenotes> ps-auxw: ah, I'll see if that option works now
09:13:59 <edwardk> ps-auxw: good tip
09:16:02 <ps-auxw> :)
09:20:32 <jystic> Hi all, what would be the best way to go about calling a haskell dll from a c# application? Right now I'm going down the path of using FFI exports / C interface
09:20:50 <ksf> that'd be the way, yes.
09:20:56 <jystic> ok, question two
09:21:16 <jystic> what's the safest / most robust way to return a string from haskell back to the calling application
09:21:22 <Saizan> isn't there some .NET interop layer?
09:21:42 <ksf> you can of course go xml, corba or any of the non-c abis, though.
09:21:49 <FunctorSalad> is it safe to install the head cabal-install and cabal? or is it hardwired like TH etc?
09:21:57 <ksf> jystic, I'd say make it a bytestring.
09:22:05 <Saizan> FunctorSalad: quite safe
09:22:06 <FunctorSalad> (or semihardwired in that you'll get dependency nightmares)
09:22:07 <ksf> utf16 or 8-encoded.
09:22:07 <ddarius> You can use whatever cabal-install you want.
09:22:20 <dcoutts_> FunctorSalad: it's fine
09:22:27 <FunctorSalad> ok :)
09:22:46 <kmc> if you're doing some rpc layer, consider Thrift
09:22:48 <jystic> ksf: cool, so what would my function signature look like
09:23:10 <ksf> ...strict bytestring, that is.
09:23:26 <jystic> say i pass no arguments and return a string
09:23:33 <ksf> basically, anything that has a storable instance. those come with guaranteed binary representations.
09:23:34 <jystic> or i pass a string and return a string
09:23:39 <Saizan> FunctorSalad: if you get a dependency nightmare i'll make you test my patches :)
09:23:59 <ksf> ByteString -> IO ByteString or just IO ByteString
09:24:26 <jystic> ok, so what's the deal with who owns the memory and who has to free it
09:24:40 <ksf> haskell can do both, you've gotta decide.
09:25:03 <jystic> i guess it would be useful to evaluate both then
09:25:13 <ksf> there's a whole lot of stuff in Foreign.Malloc
09:25:16 <zygoloid> @hackage hs-dotnet
09:25:16 <lambdabot> http://hackage.haskell.org/package/hs-dotnet
09:25:27 <zygoloid> jystic: ^^ maybe that would help you?
09:25:36 <jystic> zygoloid: i had a quick look at that
09:25:51 * hackagebot regex-tdfa 1.1.4 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-1.1.4 (ChrisKuklewicz)
09:25:53 <jystic> it seems to be mostly calling .net from a haskell app
09:26:08 <jystic> but i want to call haskell from .net
09:26:09 <zygoloid> yeah. it says it can convert haskell IO () actions into delegates
09:26:13 <poincare101> hello everyone. I have a simple primegen program (ignore the commented code): http://pastebin.org/420500 with a few odd and even distinctions for a little bit of extra speed. Now, one problem with the existing code is that it will only output once the whole function is done running, instead, how can I make it so that it prints every number one by one (is it even possible?)
09:26:51 <FunctorSalad> Saizan: constraint solver ones?
09:27:02 <Saizan> FunctorSalad: yep
09:27:24 <jystic> although i could probably swing it so that haskell owns the exe and it shows the win forms app, but it's seems like it's overcomplicating it
09:27:30 <ksf> :t sequence_
09:27:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
09:27:41 <FunctorSalad> while we're at it, very simple feature idea: 'cabal info' but with fulltext search
09:28:06 <ksf> poincare101, sequence_ (putStrLn <$> primex 0 10000)
09:28:33 <FunctorSalad> (aka 'cabal list but searching all fields' ;))
09:28:39 <ksf> er s/putStrLn/print
09:28:41 <int80_h> anyone care to help me suss out what's wrong with this Yesod example?
09:29:01 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28238#a28238
09:30:05 <jystic> ksf: assuming i wanted to allocate the memory in the caller (non-haskell), how can i get haskell to store a string in the ptr that is passed? i assume the function signature is different then?
09:30:59 <ksf> Ptr Word8 or similar.
09:31:39 <poincare101> ksf: what does that do exactly?
09:31:51 <ksf> there's a function to convert those into bytestrings and back, too.
09:32:12 <jystic> so i can poke a bytestring back in to a Ptr Word8?
09:32:15 <ksf> poincare101, it changes each number in your list to an action that prints that number, and then executes them in sequence.
09:32:21 <ksf> yep.
09:32:25 <jystic> cool
09:32:45 <ksf> ...bytestrings are just a nice interface around plain byte buffers.
09:32:53 <poincare101> ksf: I see... I also see that I need to learn a lot more haskell!
09:33:01 <poincare101> lyah just doesn't cut it...
09:33:04 <ksf> stuff's getting more involved with unicode, of course.
09:33:13 <ksf> @src sequence
09:33:13 <lambdabot> sequence []     = return []
09:33:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:33:13 <lambdabot> --OR
09:33:13 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:33:16 <poincare101> don't get me wrong; lyah is awesome; but not very awesome.
09:33:20 <jystic> yeah, i think .net strings are utf-16
09:33:31 <ksf> jystic, Data.Text does the same.
09:33:35 <jystic> although there are functions on the .net side for marshalling as well
09:34:18 <Saizan> int80_h: you need someone that knows the yesod API, it seems
09:34:30 <ksf> whereas String is [Char] where Char is any ucs codepoint, and that's a seriously inefficient representation.
09:34:39 <zygoloid> int80_h: interesting. GHC says "Not in scope: `style_css'" but your code says "StaticR.style_css". I think the hamlet @@ antiquoter is broken wrt qualified names.
09:34:56 <ksf> I think it was something like 16 bytes per character on 64bit archs or something.
09:35:00 <zygoloid> int80_h: (GHC would say "Not in scope: `StaticR.style_css'" if it were getting it right i think)
09:35:08 <jystic> ksf: wow!
09:35:15 <jystic> that's a lot of baggage
09:35:18 <poincare101> ksf: it tells me: Not in scope: '<$>'
09:35:22 <ksf> poincare101, <$> is just another name for fmap
09:35:28 <int80_h> zygoloid : I was afraid somethign like that was the case. I've sent a message to the beginners mailing list. The author frequents it.
09:35:29 <ksf> it's in Control.Applicative.
09:35:34 <ksf> :t fmap
09:35:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:35:48 <ksf> ...in fact, you can use plain, old map to do that.
09:35:52 <poincare101> ksf: okay, but how would I fix that werror? replace it with fmap?
09:36:03 <ksf> poincare101, yes.
09:36:04 <benmachine> and you can glue sequence and map into mapM if you like
09:36:19 <ksf> *doh*
09:36:21 <zygoloid> int80_h: i suggest you try building with -ddump-splices, see what the [$hamlet| expands into
09:36:22 <int80_h> zygoloid: I htink yesod is in active development, so it's no surprised that code that once worked no longer does.
09:36:29 <ksf> I didn't use forM because I successfully confused myself.
09:36:43 <ClaudiusMaximus> jystic: i use something like:  BSI.create size $ \ptr -> BSI.memcpy ptr source size  (but maybe there's a way to skip the copying - i needed to do it anyway to flip images from OpenGL to PPM coordinates)
09:36:44 <int80_h> good idea!
09:36:44 <int80_h> dea
09:36:47 <ksf> somehow I was assuming that I'd need another list...
09:36:55 <ksf> thinking of zipWith or wores.
09:36:58 <benmachine> mapM_ print (primex 0 10000)
09:37:50 <ksf> :t mapM_
09:37:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:37:58 <ksf> poincare101, grok that type signature?
09:38:41 <poincare101> ksf: huh? (sorry, not familiar with what type signature means )
09:38:47 <ksf> ...you might want to write it as a primitive recursion to understand it.
09:38:48 <ClaudiusMaximus> jystic: where import qualified Data.ByteString.Internal as BSI
09:38:57 <jystic> ClaudiusMaximus: that looks like bring the data in to haskell, i want to get a string out
09:39:09 <jystic> or am i mistaken?
09:39:26 <ClaudiusMaximus> jystic: ah, i see
09:39:47 <ksf> ...given a (function that takes an a to a monadic action) and a (list of as), return a single monadic action.
09:39:52 <ksf> :t mapM
09:39:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:40:10 <ksf> that ones' similar, but doesnt' ignore the individual results.
09:40:51 <jystic> i'm tossing up between having haskell allocate the string and requiring the caller to free it, or having the caller allocate the string and passing a ptr to haskell, but i couldn't see how option 2 would work without a pokeCString, it seems like pokeArray will do it though
09:41:37 <quicksilver> I don't think it's safe for haskell to allocate a string for the caller to free
09:41:51 <quicksilver> that requires haskell to be able to call the caller's malloc()
09:41:56 <quicksilver> don't know if you can rely on being able to do that.
09:42:10 <jystic> quicksilver: i think that i can export haskell free(...) function
09:42:22 <jystic> haskell's*
09:42:32 <ClaudiusMaximus> @hoogle useAsCString
09:42:32 <lambdabot> Data.ByteString useAsCString :: ByteString -> (CString -> IO a) -> IO a
09:42:33 <lambdabot> Data.ByteString.Char8 useAsCString :: ByteString -> (CString -> IO a) -> IO a
09:42:33 <lambdabot> Data.ByteString useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
09:43:38 <benmachine> malloc and free seem to be direct imports of the stdlib.h C functions
09:43:42 <ClaudiusMaximus> iirc there are some weird issues with DLLs on windows, like not being able to close file handles that weren't opened in that DLL
09:44:04 <jystic> benmachine, from what i've read that isn't guaranteed to always be the case forever
09:44:14 <ClaudiusMaximus> not sure if malloc/free is the same
09:44:18 <ksf> @tell edwardk lecture 5 might be _very_ useful for presenters, though. how to get the audience to aknowledge non-intuitive points.
09:44:18 <lambdabot> Consider it noted.
09:44:25 <benmachine> jystic: yeah, I have a vague recollection that it can go wrong
09:44:28 <benmachine> but I don't see how
09:45:12 <jystic> i haven't had a lot of experience designing C APIs, does anyone know the pros/cons of doing it either way? do most C APIs require you to pass the destination ptr rather than allocating on your behalf?
09:45:37 <ksf> there's both.
09:45:54 <ksf> if you can, do it both ways so the user can choose.
09:46:09 <ClaudiusMaximus> generally i think for variable length data they tend to allocate for you and provide a free function that you have to call
09:46:15 <ksf> in some cases you want to allocate yourself because the length isn't known beforehand.
09:46:28 <jystic> yeah that makes sense
09:46:40 <ksf> ...or write to a buffer and then expect you to call them again.
09:47:31 <ClaudiusMaximus> some have nice features like opaque context handles that let you deallocate everything all at once if you don't feel like keeping track yourself
09:47:56 <ClaudiusMaximus> @hoogle Pooled
09:47:56 <lambdabot> Foreign.Marshal.Pool pooledMalloc :: Storable a => Pool -> IO (Ptr a)
09:47:56 <lambdabot> Foreign.Marshal.Pool pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
09:47:56 <lambdabot> Foreign.Marshal.Pool pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)
09:48:06 <ClaudiusMaximus> that kind of stuff
09:48:06 <jystic> that's pretty neat
09:48:56 <jystic> given i'm calling from .net i can probably get away with allocating in haskell, then freeing immediately once i've attached a copy of the string to the .net garbage collector
09:49:56 <jystic> that seems like the most painless approach
09:50:00 <ksf> others, like freetype, allocate only big stuff (like the library or individual fonts) and let you free them explicitely while for small things, like a glyph, just give you a pointer to the data which you have to copy before calling another glyph render function.
09:50:49 <jystic> ksf: i don't like that kind of stuff because it makes multithreading a bit painful, and that's important to me
09:51:04 <ksf> oh, freetype is only semi-threadsafe.
09:51:22 <ksf> ...you can have an instance of the library for each thread, that is.
09:51:31 <jystic> ahh ok, that's not too bad then
09:51:46 <jystic> i was expecting the worst :)
09:51:58 <ksf> it works fine with a concurrent-object approach
09:52:07 <ddarius> ksf: Lecture 5 of what? (/me is curious)
09:52:34 <ksf> http://ocw.mit.edu/courses/chemistry/5-95j-teaching-college-level-science-and-engineering-spring-2009/
09:53:02 <ksf> oh, and that's lecture 3.
09:53:12 <ksf> @tell edwardk oops, make that lecture 3
09:53:12 <lambdabot> Consider it noted.
09:53:37 <jystic> cool, well, time to crank out some code, thanks for all the help guys, this channel is really an asset to the community!
09:56:36 <int80_h> I would go as far as to say the community would be severely crippled without this channel.
09:57:28 <ksf> I would even go as far as saying that this channel would be severly crippled without my confused ramblings.
09:57:54 <hpc> this channel, and probably about 30% haddock
10:01:14 <happydawn> hello
10:01:29 <benmachine> hello
10:01:46 <happydawn> I'm having a problem with an algorithm
10:01:58 <happydawn> I'm a beginner and I'm writing a tetris clone
10:02:01 <Taejo> on windows, is there a windowed version of ghci? (like winhugs)
10:02:31 <ddarius> Taejo: Leksah might let you do something close enough to what you want,.
10:03:01 <jystic> kmc, could you explain more about using thift for ffi type stuff? (i'm interested in the case that things get more complex)
10:03:08 <happydawn> I have list of coordinates for the squares in a tetris piece and a boolean grid (a list) representing taken positions in the game grid
10:03:38 <happydawn> I'm having trouble with updating the grid when the tetris piece has fallen
10:04:25 <zygoloid> happydawn: so, your piece is a list of (x,y), and the grid is a list of (x,y)?
10:04:50 <happydawn> zygoloid, this is what my program looks like so far: http://omploader.org/vNTF3NA
10:06:06 <zygoloid> happydawn: ok, i see. well, i can give you a few clues. do you know about the 'zip' function?
10:06:56 <benmachine> happydawn: maybe you want to use an Array instead of nested lists?
10:07:11 <happydawn> from what I understand zip "merges" two lists like a physical zip
10:07:27 <zygoloid> happydawn: right. you can use zip to number a list:
10:07:38 <zygoloid> > zip ["Hello","world"] [0..]
10:07:39 <lambdabot>   [("Hello",0),("world",1)]
10:08:34 <zygoloid> happydawn: one possible approach you could use would be to number the rows and columns of your [[Bool]] grid, then set the value to True if it was True in the old grid or if the (x,y) position is in the piece
10:09:53 <zygoloid> as benmachine suggests, it might be better in general to use an Array for this problem, but lists are very important in haskell programming so it's a good exercise to do it with lists :)
10:10:08 <happydawn> that's what I thought
10:10:59 <benmachine> zygoloid: weeeell, it's good to understand what lists are for and what they aren't for, I think
10:11:14 <interferon> i have a reporting application in Haskell that broke down this morning when the input format changed.  all i got as output was "fromJust: Nothing" and i had to track down where my errant fromJust was and figure out why it was failing
10:11:21 <benmachine> and indexing is one of the things they aren't really for
10:11:27 <interferon> is there anything i can do to make this kind of debugging easier?
10:11:38 <benmachine> and they don't provide static guarantees each row is the same size
10:11:39 <interferon> i know laziness kind of precludes backtraces
10:11:43 <benmachine> which is really nice to have
10:11:45 <zygoloid> absolutely. use of (!!) at all indicates you're probably using the wrong type
10:12:17 <benmachine> interferon: instead of using fromJust, use fromMaybe (error "specific error message")
10:12:24 <Taejo> why does leksah have neither "Built on" not "Build failure" on hackage? it was uploaded ages ago?
10:12:38 <benmachine> that should at least let you find out where the fromJust is very quickly
10:12:39 <ksf> interferon, yes, certainly.
10:12:52 <happydawn> zygoloid: so something like numbering the old grid and creating a new grid by putting the result of OR between the old value at current position and whether position corresponds to an element in the coords list ?
10:12:55 <ksf> grep for all occurences of fromJust, head and tail, and get rid of all of them, terminally.
10:13:07 <interferon> ksf: :) i guess that's true
10:13:08 <zygoloid> happydawn: yeah, that would work.
10:13:10 <interferon> fromJust is partial
10:13:21 <benmachine> or, equally, using partial pattern matching rather than partial functions gets you a source location in the error message
10:13:38 <ksf> if you really, really have a situation where fromJust is justified, use (maybe (error "heh") id)
10:13:41 <zygoloid> happydawn: if you like, we can talk you through using an Array too
10:13:50 <benmachine> happydawn: you don't use zipWith in this case to number
10:13:55 <hpc> ksf: "just"ified?
10:13:56 <ski> @type fromMaybe
10:13:56 <interferon> ksf: you recommend fromMaybe instead of fromJust?
10:13:57 <lambdabot> forall a. a -> Maybe a -> a
10:14:06 <ski> @type maybe
10:14:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:14:21 <ddarius> Taejo: Possibly because it doesn't build for reasons unrelated to Leksah.
10:14:21 <ksf> hpc, thanks for the pun, yes, it would've been intended ;)
10:14:23 <interferon> i wish there was some compiler flag that would warn me about all partial function uses
10:14:50 <benmachine> interferon: it's called agda? :P
10:14:51 <Taejo> ddarius: so if its dependencies don't build, that's how it will appear?
10:15:01 <interferon> benmachine: haha
10:15:05 <ddarius> Taejo: Possibly.  I'm guessing; I don't really know.
10:15:11 <ksf> interferon, there's a program that can prove whether your usages of head etc. are safe.
10:15:12 <hpc> @src fromJust
10:15:13 <lambdabot> fromJust Nothing  = undefined
10:15:13 <lambdabot> fromJust (Just x) = x
10:15:24 <ksf> don't remember the name, though.
10:15:29 <benmachine> but yeah I'd quite like it if haskell had the ability to say "this function is definitely total"
10:15:29 <ddarius> catch
10:15:32 <zygoloid> happydawn: you could use something like: [ ... | (x, col) <- zip [0..] grid, (y, b) <- zip [0..] col ]
10:15:41 <happydawn> zygoloid: I'll see what I can do with lists, come back for help and then maybe look at the Array documentation
10:15:45 <zygoloid> ok
10:15:46 <happydawn> zygoloid: thaks
10:15:51 <interferon> ksf: so what would you use instead of fromJust?
10:15:51 <zygoloid> good luck
10:16:00 <ksf> interferon, maybe.
10:16:01 <ksf> :t maybe
10:16:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:16:20 <ksf> if you don't have a default value to stick in there, use a telling error message.
10:16:51 <benmachine> of course if you're super cool you just lift all your functions into Maybe >_>
10:17:01 <interferon> benmachine: how's that?
10:17:01 <benmachine> and no error at all!
10:17:20 <benmachine> interferon: well, you have a Maybe a and you want to apply (a -> b)
10:17:27 <ddarius> Just -> Just . Just
10:17:39 <benmachine> instead of going Maybe a -> a and then a -> b, you go (a -> b) -> Maybe a -> Maybe b, and then Maybe a -> Maybe b
10:17:39 <ski> interferon : `-fwarn-incomplete-patterns' ?
10:17:48 <benmachine> i.e. just fmap everything everywhere
10:18:00 <interferon> ski: true, but that doesn't warn against my using standard partial functions like head and tail
10:18:02 <benmachine> warning: scaling this approach may result in eek
10:18:14 <ski> *nod*
10:18:20 <benmachine> interferon: you pretty much just have to... not use those functions :)
10:18:26 <ksf> import Prelude hiding (head,tail)
10:18:28 <hpc> -Wall will catch it
10:18:31 <interferon> ksf: nice
10:18:41 <interferon> @type fromMaybe
10:18:42 <lambdabot> forall a. a -> Maybe a -> a
10:18:50 <ddarius> The hard part is 3rd party, non-standard functions that use partial functions or are otherwise partial.
10:18:56 <interferon> so fromMaybe takes a default as its first parameter?
10:19:01 <interferon> ddarius: right
10:19:16 <ksf> ddarius, like (/)?
10:19:48 <benmachine> damn division, always ruins things
10:20:04 <ksf> oh, subtraction is enough to ruin things.
10:20:21 <benmachine> subtraction is total on Integer at least isn't it?
10:20:35 <c_wraith> ignoring implementation limits of Integer, sure.
10:20:38 <ksf> naturals aren't closed under subtraciton
10:20:59 <benmachine> neither are Chars
10:21:04 <ksf> and integers just don't make any sense.
10:21:06 <benmachine> so we don't define subtraction on them either :P
10:21:13 <ksf> did you ever see a planet with a negative number of moons?
10:21:34 <c_wraith> Theoretically, all functions on Integer could be partial, as they can crash if you have enough memory to handle exceeding the internal representation's limit.
10:21:49 <zygoloid> i thought there was an argument that natural subtraction should give 0 if the subtractand is larger?
10:21:53 <benmachine> ksf: well, no, but I've only seen like... six planets
10:21:54 <sproingie> i can count them on negative fingers
10:22:00 <benmachine> ksf: maybe we just haven't found one yet!
10:22:02 <zygoloid> (probably based on the way ordinal subtraction works)
10:22:23 <ksf> zygoloid, that messes up a lot of algebra, but works, sometimes.
10:22:24 <zachk> maybe negative moons orbit inside a hollow planet 
10:22:34 <FunctorSalad> just don't call it 'minus' maybe ;)
10:22:37 <benmachine> c_wraith: that's not exactly a partial function, it's like a stack overflow exception
10:22:48 <benmachine> c_wraith: it's a total function that your machine is not able to calculate
10:22:48 <zygoloid> benmachine: i'm tempted to make a joke about you never having seen uranus...
10:22:54 <benmachine> zygoloid: :)
10:23:02 <zachk> you just did -_- 
10:23:18 <zygoloid> i didn't say i was resisting the temptation ;-)
10:23:25 <FunctorSalad> zygoloid: it's the solution to the optimization problem min_x | input + x | ?
10:23:39 <FunctorSalad> deep trivialities ;)
10:23:58 <Taejo> dons: shouldn't http://hackage.haskell.org/platform/linux.html at least warn that the Karmic and Jaunty links give instructions for installing an outdated platform?
10:24:10 <FunctorSalad> ah wait, minus has two inputs, but anyway you know what I mean
10:24:44 <zachk> sqrt adds tons of garbage to math 
10:24:57 <ksf> minus and division are inverse monoids, that's all the problem.
10:25:09 <benmachine> zachk: don't blame sqrt, blame geometry
10:25:17 <zachk> how so or why 
10:25:30 <zachk> because we know those things surely exist since we can measure them? 
10:25:34 <ksf> ...and I don't care how mathematicians call it, I coined the term "inverse something like that structure" in second class, myself.
10:25:49 <zachk> whats second class? 
10:25:49 <FunctorSalad> ksf: group? :P
10:25:58 <benmachine> zachk: well, I just sort of think we wouldn't really need sqrt so much except that right triangles with sides of 1 and 1 have a third side
10:26:04 <FunctorSalad> assuming we're in Z respectively Q
10:26:26 <zygoloid> benmachine: let's all live in R1. that'll fix everything.
10:26:49 <benmachine> yes.
10:26:51 <ksf> FunctorSalad, well, on the naturals, - and / are the inverses of + and *. that's what I realised then and mean now.
10:26:56 <alex_kidd> grothendieck group
10:27:05 <benmachine> but we'd have to become really good friends with whoever was immediately next to us
10:27:10 <ksf> ...as in you can't evenly divide what you haven't multiplied, first.
10:27:21 <askhader> ksf: just watch me
10:27:32 <FunctorSalad> ksf: only on one side... (subtract n) . (+ n) == id
10:27:37 <FunctorSalad> not the other way, in N
10:27:40 <zachk> > product.repeat$2 -- is the hypotneus to a right triangle where a=b 
10:27:44 <lambdabot>   mueval-core: Time limit exceeded
10:27:54 <ksf> FunctorSalad, yes, sure, that's the point.
10:27:57 <zachk> damn it i just need more time im sure the computation will work out 
10:28:05 <benmachine> heh
10:28:06 <jmcarthur> looks like i'm on a job hunt. anybody know of any haskelly openings?
10:28:10 <FunctorSalad> ksf: but luckily the left-inverses can be invented :) (right inverses can't)
10:28:15 <FunctorSalad> other way around
10:28:39 <FunctorSalad> you can fix lack of surjectivity of (+ n) but not lack of injectivity
10:28:47 <FunctorSalad> (unless you take a quotient)
10:28:59 <zygoloid> benmachine: that's why i put myself at the end of the /names list ;-)
10:29:43 <benmachine> jmcarthur: is your current job mistreating you, then?
10:29:54 <jmcarthur> benmachine: layoffs
10:30:06 <benmachine> :(
10:30:12 * benmachine hugs
10:30:17 <jmcarthur> not getting enough contracts to sustain the number of employees we have
10:30:21 <jmcarthur> aw
10:30:36 <jmcarthur> sucks, because i liked the people and work environment
10:30:59 <jmcarthur> the job itself was fun sometimes too, although i can't say i *really* like kernel programming
10:31:11 <benmachine> heh
10:34:56 <happydawn> zygoloid, thanks for the nifty one-liner
10:35:33 <happydawn> I figured out how to use (and still have to make sense of how it works exactly)
10:35:40 <happydawn> use it*
10:39:45 <chrisdone> hi
10:58:25 <zachk> @pl (\x->x^2+x) 
10:58:25 <lambdabot> (+) =<< (^ 2)
10:58:37 <zong_sharo> can anyone tell me when new i/o manager will be in ghc?
10:58:40 <zachk> @src =<< 
10:58:40 <lambdabot> Source not found.
10:59:34 <hpc> (=<<) = flip (>>=)
10:59:56 <ksf> gosh dammit those didactics lectures make me want to learn all that stuff I hated.
11:00:07 <tommd> zachk: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Control-Monad.html#%3D%3C%3C
11:00:08 <zachk> have a link ksf? 
11:00:16 <ksf> http://ocw.mit.edu/courses/chemistry/5-95j-teaching-college-level-science-and-engineering-spring-2009/
11:00:25 <ksf> HELL I SHOULD PUT IT INTO THE TOPIC
11:00:30 <ksf> sorry for shouting
11:00:58 <chrisdone> ksf: we'll get through your anger issues one step at a time
11:01:11 <wlangstroth> ksf: I liked "the evils of PowerPoint" in that course description
11:01:26 <hpc> turning off the billy mayes key is the first step to anger management
11:01:27 <tommd> Isn't it easier to just banish the angry people from society?
11:01:59 <chrisdone> tommd: what if they formed their own angry society?
11:02:08 <pikhq> tommd: A final solution, I presume?
11:02:19 <ksf> actually, I found switching my internal searching routine to a* (where the heuristic is tunable on the fly, and the default state is pure breadth-first) has the side-effect of annihilating any reasons for anger
11:02:24 <tommd> chrisdone: We must banish them to separate physical locations so that isn't an option.
11:02:47 <wlangstroth> tommd: is that for anyone who is temporarily angry as well?
11:02:54 <tommd> HELL NO
11:02:58 <ksf> the APPD is actually advocating that.
11:03:11 <chrisdone> tommd: the logistics of which would make me angry. oh no- wait- i'm not an angr-*swoop*
11:03:12 <wlangstroth> consider the telecommunications customer
11:03:59 <chrisdone> you have been charged with incitement to anger
11:04:20 <ksf> the balkanisation of germany. a pogo zone where you can party, a babbit zone for those who want to work, and an violence-adventure zone where all the boneheads and criminals can beat each other up.
11:04:21 * BMeph plays an online game with a character named "CapSloQ"
11:04:56 * BMeph is _Always_ "ready to Unleash the Fury"...
11:05:22 <chrisdone> ksf: i wonder if the inbreeding of the voilencec-adventure zone over time would favour heads with an actually prominent bone, making "bone heads" descriptive and derogatory
11:05:46 <ksf> I think the hope is that they just kill themselves off.
11:06:16 <chrisdone> is it genocide to allow a whole race to kill themselves off?
11:06:18 <ksf> and, wait, bonehead already is descriptive and derogatory.
11:06:22 <BMeph> tommd: If they refused to stay banished, though...would that make you angry? ;)
11:06:38 <ClaudiusMaximus> what's the expected overhead for +RTS -h -RTS ? without it my program terminates in 2m20s, with -h it's still going after 14mins
11:08:16 <mdmkolbe> OT: In academic papers is it better to cite the conference version of a paper (year 2002) or the journal version (2004)?
11:08:40 <ClaudiusMaximus> how does -h work? i know it periodically dumps heap statistics, but i'm wondering what happens if/when the time taken to dump those statistics exceeds the period...
11:08:42 <chrisdone> good question
11:09:46 <ClaudiusMaximus> mdmkolbe: i'd cite the one i'd read, in case they differ - but i'm no academic
11:10:17 <BMeph> mdmkolbe: Depends on your audience. My former main teacher would always want the latest reference, if only because extra research may be included in later papers.
11:10:46 <ksf> mdmkolbe, ask the author.
11:11:11 <ksf> ...well, see if you can get an authorotive bibtex from somewhere, first.
11:11:32 <copumpkin> cite the one you read
11:11:38 <tommd> Depends - did your coin come up heads?
11:12:00 <mdmkolbe> copumpkin: assume I've read both
11:12:03 <chrisdone> BMeph: that's a good point
11:12:05 <ksf> (I always love it when papers cite stuff that was published after their publishing date, presumably due to recompilation of the tex + updated bibtexen)
11:12:33 <hpc> ksf: even better if it's anything like the paper on closed timelike loops
11:13:09 * BMeph woots - we have a copumpkin sighting!
11:13:15 <copumpkin> :)
11:13:21 <ksf> well, or the original citation was a (near final) draft
11:13:27 <BMeph> copumpkin: Welcome back! :D
11:13:34 <copumpkin> thanks!
11:14:00 <mdmkolbe> ksf: Heh, I'm about to generate one of those loops.  There is a 2008(?) paper by another author that cites my 2007 draft, but now my 2010 version has to cite his 2008 paper in related work.
11:14:47 <ksf> 3 years!
11:15:02 <ksf> no wonder nobody in cs gives a damn about journals and conference proceedings.
11:15:49 <Twey> mdmkolbe: Haha, argh!
11:15:59 <ksf> and I still think we should start a haskell journal, btw.
11:16:27 <ksf> CRHP? cabal of reviewing haskell peers?
11:16:59 <ksf> hmmm crhp of reviewing haskell peers would be better still.
11:17:02 <mdmkolbe> ksf: I think that's already called JFP ;-)
11:18:23 <ksf> hmmm I was thinking of something that would entice non-acedemics to write papers, too.
11:18:35 <ClaudiusMaximus> i can't wait 25mins (and counting) to get a heap profile of a program that terminates in 2m20s without profiling.  what could be going wrong?
11:18:48 <ClaudiusMaximus> ksf: like Monad.Reader ?
11:18:56 <ksf> yes, more like that
11:19:20 <tommd> "Cabal of Reviewed Academic Papers"?
11:19:50 <hpc> The Haskell Currier?
11:19:53 <ksf> ...but in a format that has individual papers available individually, also non-accepted ones listed, allows community voting on quality and on-topicness, etc.
11:20:06 <tommd> So.... reddit?
11:21:44 <ksf> I don't think reddit has polishing blog-posts by peer review as one of its goals.
11:22:46 <ksf> hmmm. maybe, most importantly, a stock of academics that would readily write a proof or the other for something someone has coded up.
11:23:09 <monochrom> cabal install first-proof-of-P-equals-NP
11:23:31 <monochrom> cabal install first-proof-of-P-equals-NP-2.1.0.4 :)
11:24:11 <ksf> P = NP is trivially true.
11:24:16 <ksf> if n == 1, that is.
11:24:35 <hpc> and if P==0
11:24:37 <ksf> otherwise, I don't see much of a chance.
11:24:58 <ksf> so what's this fuzz all about? ;)
11:25:16 <BMeph> tommd: "HAcademic", surely? ;)
11:25:43 <shachaf> P = fix N
11:25:44 <tommd> People would get confused "HA" surely must stand for "High Assurance", but what is "cademic"?
11:26:06 <tommd> :-)
11:26:19 <ksf> do we have an academic with enough guts to publish a paper which elaborates beyond comprehension on that N = NP on april 1st?
11:26:38 <ksf> P = 
11:27:16 <mdmkolbe> Also not to be confused with "Hack"ademic
11:27:35 <ksf> Hackademy would actually be cromulent.
11:27:44 <ksf> we have hackaton, hackage, ...
11:27:56 <hpc> haddock
11:28:06 <ksf> that's a fish.
11:28:14 <tommd> We need another PDX Hackathon - I've been tricked twice now by people who didn't come through.
11:28:14 <tommd> /me is angry about false hackathons
11:28:15 <ksf> though I bet some people hack fishing.
11:29:03 <crutcher> Hi, I'm trying to create a relocatable haskell platform install; does anyone know of any references on this subject?
11:29:33 <tommd> crutcher: As in, relocatable to each users home directory or to other computer systems?
11:29:40 <tommd> I assume you're using windows?
11:30:00 <crutcher> as in: I have a build system with versioned releases of toolchains installed in parallel
11:30:26 <crutcher> and I'd like to be able to drop a release of the haskell platform in a location that can be used for builds that use that release
11:30:33 <ksf> crutcher, there's the PATH issue, and possibly the paths that are softcoded in the ghc/ghc-pkg etc. warppers.
11:30:36 <tommd> That's common - normal behavior on Fedora.
11:30:56 <crutcher> there's also the "how do I make cabal do the right thing" issue
11:31:13 <tommd> I've not had any issues with simple shell aliases that change ghci, ghc-pkg and ghc to point to the version I want at that time.
11:31:15 <ksf> i.e. cabal-install uses PATH to locate ghc and ghc-pkg, which use the paths in their wrapper scripts to find the rest.
11:31:31 <ksf> yeah, that should work fine.
11:31:32 <monochrom> ghc package database uses absolute paths. take a look at "ghc-pkg describe containers" for example
11:31:43 <crutcher> I can't use cabal-install; I'm just talking about cabal update to build the package conf
11:31:45 <tommd> crutcher: If you don't like changing the softlinks then just use cabal-install arguments to point it to the specific binary.
11:31:48 <ksf> also, have a look at /usr/bin/ghc.
11:32:05 <crutcher> what I'd like would be this situation:
11:32:14 <ksf> you can completely re-work the wrappers to your liking.
11:32:20 <tommd> yep
11:32:30 <crutcher> a haskell platform release installed under a common prefix; relocatable at runtime to an arbitrary path
11:32:42 <ClaudiusMaximus> hm, ./Main +RTS -h -i10 takes 2m40s, -i1 takes 7m25s, -i (default 0.1) takes longer than 25mins (i didn't wait), while ./Main takes 2m20s
11:33:04 <crutcher> is there an effective means to do this with commandline flags, rather than re-writing the wrappers?
11:33:29 <crutcher> it's hard to track down docs on this, "--help" for most of these tools doesn't document all their flags
11:33:30 <ksf> crutcher, I guess you'd have to make the ghc wrappers figure out the directory they're in, then, and have them work out the lib dirs etc. relitively from that.
11:33:52 <crutcher> i'm perfectly willing to just tell them explicitly
11:33:52 <ksf> just look at the wrappers, it's one or two paths, that's all.
11:35:18 <ksf> also, they're not in any way as scary as say the mozilla wrappers. five lines, no conditionals.
11:35:59 <zachk> > (+)=<<(^2) $ 5 
11:36:01 <lambdabot>   30
11:36:28 <hpc> > (+) =<< (^2) $ x
11:36:29 <lambdabot>   x * x + x
11:36:38 <zachk> now how the heck does that work 
11:36:42 <hpc> huh
11:36:47 <zachk> the pointfree code
11:36:55 <zachk> i dont get how + and is a monad D: 
11:37:03 <hpc> functions are monads
11:37:05 <ksf> that's monad (-> a)
11:37:14 * zachk minds blowsup 
11:37:23 <ksf> and yes, using it is evil. 
11:37:25 <hpc> > (f >>= g) x
11:37:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:37:26 <lambdabot>    `GHC.Show.Show a'
11:37:26 <lambdabot>      a...
11:37:33 <hpc> > (f >>= g) x :: Expr
11:37:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:37:33 <lambdabot>    `GHC.Show.Show a'
11:37:33 <lambdabot>      a...
11:37:44 <zachk> is there another way to do pointfree polynomials? 
11:37:49 <hpc> :t (f >>= g)
11:37:51 <lambdabot> forall (m :: * -> *) a b. (SimpleReflect.FromExpr (m a), Show a, SimpleReflect.FromExpr (m b), Monad m) => m b
11:38:53 <crutcher> ksf: thanks, I guess I'll keep beating my head against this.
11:38:59 <hpc> > (+) << (^2) $ x
11:39:00 <lambdabot>   Not in scope: `<<'
11:39:15 <hpc> > let (<<) = flip (>>) in (+) << (^2) $ x
11:39:16 <lambdabot>   Overlapping instances for GHC.Show.Show
11:39:17 <lambdabot>                              (Simpl...
11:40:13 <ClaudiusMaximus> something fishy about heap profiling:  http://claudiusmaximus.goto10.org/g/hp2pretty/rts-h/i10.png http://claudiusmaximus.goto10.org/g/hp2pretty/rts-h/i1.png (same program, same input file)  anyone can explain why the shape with -i1 differs so much from the shape with -i10 ?
11:40:29 <ianh> can you use "if" inside of a do block?
11:40:33 <ianh> I am unable to figure out the syntax
11:40:55 <monochrom> yes. but each branch should start its own do block
11:40:59 <Taejo> ianh: yes, there is no special syntax
11:41:08 <hpc> it's still ugly though
11:41:12 <hpc> @src when
11:41:12 <lambdabot> when p s = if p then s else return ()
11:41:12 <ClaudiusMaximus> ianh: you can, but you probably need to add 'do' in each branch (unless they're single lines)
11:41:13 <monochrom> do {x<-y; if x then do { ...} else do {...} }
11:41:16 <hpc> @src unless
11:41:16 <lambdabot> unless p s = if p then return () else s
11:41:23 <ianh> hmm
11:41:26 <BMeph> Behold the Power of the Endofunctor! :)
11:41:43 <ianh> i have "if theresInput then hGetChar hin >>= hPutChar hout"
11:41:45 <ianh> on its own line
11:42:01 <ianh> and I'm getting parse errors :/
11:42:06 <hpc> do you have an else?
11:42:13 <ianh> hpc: doh, of course
11:42:31 <ianh> thanks :)
11:42:36 <hpc> if your else is going to be "do nothing", go with "when theresInput (blah)
11:42:41 <monochrom> I almost typed "else is your where?" :)
11:43:18 <zachk> how do i use where in lambdabot? 
11:43:30 <monochrom> > x+x where x=0
11:43:30 <lambdabot>   <no location info>: parse error on input `where'
11:43:37 <monochrom> I guess can't.
11:43:46 <ClaudiusMaximus> > let foo = bar where bar = 42 in foo
11:43:47 <lambdabot>   42
11:43:54 <monochrom> > let { x=y where y=0 } in x
11:43:54 <hpc> lambdabot is a pseudo-ghci
11:43:54 <lambdabot>   0
11:44:12 <hpc> huh, that's a strange trick
11:44:19 <ClaudiusMaximus> 'where' attaches to definitions, not expressions
11:44:28 <ClaudiusMaximus> is how i understand it, anyway
11:44:30 <monochrom> don't be too worked up fitting full haskell syntax into a repl
11:44:49 <monochrom> you can't even "module X(x) where" at repl
11:46:53 <zachk> @pl (\x->x+2==x*5) 
11:46:54 <lambdabot> liftM2 (==) (2 +) (5 *)
11:47:07 <zachk> -.-
11:48:09 <zachk> @type liftM2
11:48:10 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:48:17 <hpc> @src liftM2
11:48:17 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:48:23 <hpc> @src on
11:48:24 <lambdabot> (*) `on` f = \x y -> f x * f y
11:48:28 <BMeph> zachk: Still waiting for it to "click"? :)
11:48:50 <hpc> on looks like a specialization of liftM2
11:48:53 <zachk> ive been waiting for that for over 2 years now :-D i just live with it 
11:49:16 <BMeph> hpc: liftM2 + Cont, natch.... ;)
11:49:38 <hpc> :t on
11:49:39 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:50:00 <McManiaC> hey, is it possible (via TemplateHaskell?) if a type has an instance for a class?
11:50:05 <McManiaC> *to check
11:50:09 <hpc> almost a specialization, never mind
11:50:38 <zachk> im at a community college (first 2 years) and i can even talk cs to the good cs proffesor, and most of my math questions go over the math professor heads 
11:50:53 <hpc> community college is torture
11:51:06 <zachk> i flunked out of university years ago 
11:51:12 <monochrom> McManiaC: probably not.
11:51:15 <hpc> it's like high school with ashtrays, no matter how much anyone says otherwise
11:51:35 <zachk> but all the jobs that are even midly in my skill field require a 4 year degree + experience 
11:52:05 <hpc> small businesses are more lenient about who they hire
11:52:18 <hpc> look for small computer companies
11:52:22 <monochrom> large businesses (like google) too.
11:52:28 <hpc> that's what i did and it is working out great
11:52:42 <zachk> im sick of fixing pc problems 
11:53:02 <hpc> it doesn't have to be a repair shop or help desk
11:53:08 <hpc> i do web programming
11:53:26 <zachk> i need to bow down and learn some web stuff ;) 
11:53:47 <hpc> as much hate as i give perl, it's probably the best language to learn web with
11:53:49 <monochrom> javascript is easy and fairly pleasant.
11:53:59 <hpc> in terms of server-side stuff
11:54:11 <zachk> ive found perl pretty bad ass when i had a job as a sysadmin for a small isp 
11:54:38 <hpc> it makes a wonderful scripting language, especially thanks to it's string manipulation
11:54:43 <monochrom> I can't see why perl is a must. could choose python.
11:54:58 <wli> library codebase is everything
11:55:07 <hpc> perl is infinitely more lax than python, syntax-wise, too
11:55:15 <ksf> zachk, what's wrong with haskell for web stuff?
11:55:21 <hpc> and perl libs are pretty epic
11:55:35 * ksf did his inet-seminar in perl
11:55:45 <zachk> i dont grok happstack or whatever it is called or monads in a general case 
11:55:49 <hpc> there's one that validates email addresses by exchange records
11:55:51 <ksf> wasn't very webby, though, basically only the interface (single-user)
11:56:48 <ksf> the actual problem was solving timetable constraints, very presumably because the tutor was the one working out the timetables and wanted some inspiration
11:57:23 <ksf> (should I mention that mine was the fastest, or would that be boasting?)
11:57:31 <McManiaC> boasting
11:57:32 <McManiaC> :P
11:57:33 <hpc> no, but boasting is fine
11:57:42 <McManiaC> :D
11:58:11 <hpc> the real question is, was it correct or was it "main = return ()"?
11:58:14 <hpc> :P
11:58:38 <JoeyA> Where can I find current documentation on Parsec?
11:58:39 <monochrom> return() is unlikely to solve anything :)
11:58:50 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28245#a28245
11:58:52 <ksf> there it is.
11:59:05 <monochrom> parsec 3 haddock is current doc
12:00:28 <monochrom> I wonder if I should help shoot down the web-forum idea
12:00:55 <McManiaC> haha
12:01:32 <ksf> that code is te h sux
12:01:34 <monochrom> the upside is I know how to do it humorously
12:01:58 <shachaf> Why did the word "forum" become synonymous in some contexts to "phpBB-style forum"?
12:02:07 <monochrom> the downside is if people want retarded phpBB software, let them
12:02:23 <shachaf> That UI is awful. I have no idea why it's so popular.
12:02:46 <zachk> free++php==Win 
12:02:52 <monochrom> because there is little other choice. if you are chinese, you can also choose discuz, same piece of crap though
12:03:20 <ksf> the main error in the assignment was that we weren't supposed to generate _sensible_ time tables. like e.g. not showing everything into monday when possible, and leaving some time for people to visit the mensa.
12:03:26 <monochrom> all existing forum UIs are retarded.
12:03:26 <JoeyA> In ParsecT s u m Char, what are the s u m types for?
12:03:31 <lucca> I had to install one recently.  There really aren't many better options, as terrible as it is.
12:03:31 <JoeyA> What ever happened to just Parser Char ?
12:04:22 <lucca> JoeyA: Parser Char is a shortcut to that
12:04:27 <shachaf> monochrom: The reddit/news.yc/etc. tree style is somewhat nicer.
12:04:32 <ksf> state is the state type, which you shouldn't use if you have to ask, and m is the underlying monad, from which you can get your Chars.
12:04:35 <lucca> they allow for more general types of streams, such as ByteString
12:04:38 <monochrom> the only way you could consider "forum has more features than mailing list" is if you used 1970s email software for mailing list.
12:05:01 <ksf> basically all we need is a slightly more elaborate gmane.
12:05:02 * shachaf isn't a fan of mailing lists either, to be fair.
12:05:15 <JoeyA> lucca: Where is it defined, though?  When I say simple :: Parser Char; simple = letter , it says Not in scope: type constructor or class `Parser'
12:05:20 <ksf> use an nntp server as backend (possibly write one), and require markdown syntax.
12:05:44 * hackagebot darcs-beta 2.4.98.2 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.4.98.2 (ReinierLamers)
12:06:21 <ksf> if you have control of the nntp server, or rather network, it's even easy to move or amend posts.
12:06:40 <lucca> JoeyA: Text.Parsec.String, if you're using parsec-3
12:06:56 <lucca> type Parser = Parsec String ()
12:07:02 <ksf> ...like retroactively injecting a follow-up and crosspost to the right group actually having the news server ignore any attempt to reply to the original post.
12:07:36 <ksf> nntp is vastly undervalued.
12:08:32 <napping> What's the story on representing data types as fixpoints?
12:08:44 <napping> or otherwise opening types so you can add cases?
12:08:50 <JoeyA> lucca: thanks
12:09:09 <napping> (I'm trying to make a type of patterns Pat extending expressions Exp with some extra cases)
12:09:18 <lucca> JoeyA: it's done that way so you can make parsers of things other than chars
12:09:23 <napping> (except it's really like 5 mutually recursive types)
12:09:33 <koninkje> @search data types a la carte
12:09:34 <lambdabot> Unknown command, try @list
12:09:46 <lucca> JoeyA: e.g. I have one that deals in Word8's coming out of a ByteString for structured parsing of JPEG data
12:09:49 <koninkje> @google data types a la carte
12:09:50 <lambdabot> No Result Found.
12:09:51 <napping> I see fixpoints on hackage
12:09:54 <koninkje> feh
12:09:56 <JoeyA> ah
12:10:32 <lucca> that can be as easy to define (for stateful and stateless parsers) as
12:10:36 <lucca> instance (Monad m) => Stream ByteString m Word8 where
12:10:36 <lucca>     uncons = return . ByteString.uncons
12:10:36 <lucca> type Parser = Parsec ByteString ()
12:10:36 <lucca> type GenParser t st = Parsec ByteString st
12:10:47 <napping> I guess I'm mostly asking about lexical conveniences. I wrote my first data Fix f = In (f (Fix f)) years ago :)
12:10:58 * ksf recently posted a paper to the haskit that outlines how to solve the last problem associated with the expression problem
12:11:08 <koninkje> napping: Try looking for the DTalC paper
12:11:16 <koninkje> I don't think there's a library for it per se
12:11:53 <ksf> napping, http://arxiv.org/abs/1005.1213
12:12:11 <lucca> of course you still need to add new stream manipulation primitives for things like that; byte, byteMatch, satisfy, etc.  But it's nice and straightforward.
12:12:33 <napping> koninkje: seen it, got it open again, IIRC it defines pretty semantics but still has a bit of baggage
12:12:53 <napping> like, pattern synonyms and implicit coercions ala Coq would help a lot
12:13:11 <napping> ksf: did you help write that paper?
12:13:19 <JoeyA> Are Chars in Haskell Unicode characters?
12:13:26 <napping> Yes
12:13:29 <ksf> nope, I merely sifted it out of the arxiv.org new submissions list.
12:13:39 <JoeyA> How does it know what charset to use?  Does it just use UTF-8?
12:13:47 <napping> But, the SystemIO stuff only loads them with ASCII values
12:13:48 <koninkje> napping: it does have an unfortunate amount of baggage, though most of it is write-once-and-forget
12:14:14 <ksf> there's definitely still work to be done there.
12:14:34 <koninkje> napping: You may alos want to check out Tim Sheard's Two-level parameterized types, for a lighter weight solution to a lighter weight version of the problem
12:14:48 <ksf> but the general idea seems to be good, one really does need at least two views of the same program to be able to extend+modify as one pleases.
12:14:55 <napping> oh, it's been a while since I've looked at any of Sheard's stuff. Omega?
12:15:03 <JoeyA> > putStrLn [chr 9835]
12:15:04 <lambdabot>   <IO ()>
12:15:16 <JoeyA> > [chr 9835]
12:15:17 <koninkje> http://web.cecs.pdx.edu/~sheard/papers/JfpPearl.ps
12:15:17 <lambdabot>   "\9835"
12:15:26 <koninkje> http://web.cecs.pdx.edu/~sheard/papers/generic.ps
12:15:30 <shachaf> > text [chr 9835]
12:15:31 <lambdabot>   ‚ô´
12:15:49 <koninkje> The former is an extension of the latter; the latter is a use-case for unification
12:16:22 <JoeyA> Is text a special lambdabot function?
12:16:43 <JoeyA> When I say putStrLn [chr 9835], I get:  k
12:16:45 <askhader> is lambdabot's source available?
12:16:56 <shachaf> @whereis lambdabot
12:16:56 <lambdabot> Maybe you meant: where where+
12:16:59 <shachaf> @where lambdabot
12:16:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:17:03 <askhader> thanks
12:17:09 <shachaf> That might be outdated, though.
12:17:15 <askhader> Better than nothing =]
12:17:30 <JoeyA> Specifically, putStrLn [chr 0x266B] prints the same as putStrLn [chr 0x6B]
12:17:48 <JoeyA> and so does putStrLn "‚ô´"
12:18:01 <napping> JoeyA: I expect unicode handling will be improved eventually
12:18:24 <napping> but last I know, a Char has room for a full unicode code point, but the System.IO functions only read and write the low 8 bits
12:18:45 <hgolden> dons: is there any show-stopping reason why hs-plugins couldn't be updated to run under ghc-6.12? if not, i'll try.
12:18:45 <lambdabot> hgolden: You have 1 new message. '/msg lambdabot @messages' to read it.
12:19:10 <napping> so, one finds libraries on Hackage for unicode-aware IO or explicit charset conversion
12:19:32 <JoeyA> okay, thanks
12:19:56 <napping> JoeyA: in particular, if you don't need the full generality a Char is pretty fat
12:20:23 <napping> koninkje: those seem to have the same titles
12:20:36 <ksf> napping, change your locale charset, then.
12:20:37 <koninkje> hmm...
12:21:08 <napping> wait, the latter says "Generic Unification"
12:21:23 <ksf> to output utf, you need to have a unicode-aware locale...
12:21:31 <ksf> otherwise, all hell (could) break loose.
12:21:36 <koninkje> The latter should be "Generic Unification via..." whereas the former is "Two-level types and parameterized modules"
12:21:42 <napping> yes, you are right
12:21:57 <ksf> JoeyA, try setting LC_CTYPE to en_GB.utf8
12:22:18 * ksf wishes there'd be POSIX.utf8
12:22:19 <napping> oh, generic unification as in unification over generic data? That would be exactly the kind of extensibility I'm looking for
12:22:25 <ksf> ...or C.utf8
12:22:40 <napping> Of course, the alternative is copy and paste existing defintions and add the pattern cases
12:23:06 <koninkje> the algorithm presented is unification over a pluggable datatype, rather than baking Exp into unification
12:23:07 <JoeyA> LC_CTYPE=en_GB.utf8 ghci -> no beans
12:23:15 <JoeyA> putStrLn "‚ô´" still yields k
12:23:35 <napping> JoeyA: isn't k the low 8 bits of that?
12:23:40 <JoeyA> yes
12:23:48 <ksf> did you export that?
12:24:15 <ksf> it works, here.
12:24:18 <hpc> :t hPrint
12:24:19 <lambdabot> Not in scope: `hPrint'
12:24:28 <ksf> 6.12.3, with konsole.
12:24:40 <ksf> are you sure your terminal groks unicode?
12:24:47 <JoeyA> I'm on Ubuntu with GHC 6.10.4
12:24:53 <napping> hmm, it does seem to work here as well. GHC may be smarter than I remember
12:24:56 <JoeyA> Yes it does
12:25:01 <ksf> well, that's two mistakes, then...
12:25:07 <JoeyA> Maybe it got fixed it a later version.
12:25:10 <napping> ah, you need a newer GHC
12:25:28 <JoeyA> I don't really care that much at the moment, I was just wondering.
12:25:37 <JoeyA> Thanks, though
12:25:49 <napping> I think that stuff was improved in ^.12
12:25:51 <napping> 6.12
12:26:08 <napping> It's actually pretty easy to keep a copy of GHC in your home directory, if you like
12:26:20 * JoeyA wishes a major standards body would decree that UTF-8 is the only valid Unicode encoding for a byte string.
12:29:15 <JoeyA> Is it possible to make a Haskell module automatically load others (rather than requiring the user to do so)?
12:29:33 <JoeyA> (imports, that is)
12:29:38 <napping> well, imported symbols can be reexported
12:29:40 <ksf> ...just import them.
12:29:58 <napping> like, module Foo where import A, if you import Foo it seems to contain all the symbols from A as well
12:30:40 <napping> For the shell I usually make a Test.hs that imports the modules I want to work with, and never compile it
12:31:25 <koninkje> with explicit exports that's: module Foo (module A,...) where import A
12:31:45 <napping> hmm, all these fancy open recursion things do not seem to work so nicely with mutually recursive types
12:32:00 <napping> and I really don't want to smoosh them together into one GADT
12:32:04 <koninkje> Yeah, that's a problem
12:33:19 <napping> I'm reminded of Scala's object/module inheritance stuff
12:33:29 <koninkje> The problem is we don't really have a good way to have a fixpoint return pairs at the type level
12:33:41 <koninkje> ...though now that I think of it, type families should fix that
12:34:54 <miniBill|study> I've started yesterday to learn haskell :)
12:35:05 <JoeyA> Goodie, I figured it out:  http://codepad.org/jy7nzIee.  With the stuff in parens after MyParsec, I can just say import MyParsec and start playing around with it.
12:35:46 <napping> libraries usually come with a top-level module that just provides a convenient set of re-exports
12:36:09 <miniBill|study> I'm writing this program that calls some computational-heavy functions. how do I ask the results of these functions to be "cached"?
12:36:15 <napping> another option is just to load your MyParsec.hs in ghci (and make sure you don't have a .o available)
12:36:50 <napping> then ghci should end up with a prompt like MyParsec*>, and you'll have everything from the top level of MyParsec.hs in scope
12:37:23 <napping> miniBill|study: simplest solution is just to write the expensive call once, and use a let or something to share the result
12:37:33 <JoeyA> miniBill|study : That's called memoization.  Haskell doesn't exactly do that automatically, but there are some elegant ways to do it.
12:38:09 <miniBill|study> JoeyA: exactly, I'm looking for memoization. do you have some hints for me?
12:38:15 <PetRat> Does the library declare an instance of Monad ((->) a) somewhere? I don't mean wrapped in a newtype.
12:38:28 <JoeyA> You can import Data.Array , then build an array that calls your function.
12:38:40 <JoeyA> Then, instead of calling your function, subscript your array.
12:38:46 * JoeyA puts together an example
12:38:55 * miniBill|study thanks JoeyA :)
12:38:55 <copumpkin> PetRat: Control.Monad.Instances
12:39:26 <PetRat> copumpkin: works! thanks!
12:40:41 <JoeyA> Consider the following:
12:40:43 <JoeyA> fibonacci 0 = 0
12:40:43 <JoeyA> fibonacci 1 = 1
12:40:43 <JoeyA> fibonacci n = fibonacci (n-2) + fibonacci (n-1)
12:41:09 <miniBill|study> a.k.a. the Classical Example of Memoization and What is it Good For :)
12:41:10 <JoeyA> It takes exponential time to run because it's a poor algorithm.
12:41:12 <JoeyA> Yup
12:41:21 <miniBill|study> I know how to do memoization in C
12:41:30 <napping> koninkje: it seems to have worked reasonably to define a type Pat s = Wild | Named String s | Match s, and then made a copy of my AST with Pat wrapped around various recursive mentions of types in the definitions
12:41:32 <miniBill|study> how about Haskel?
12:41:49 <JoeyA> Lazy evaluation lets you do that.
12:41:51 <napping> well, you can do it precisely as in C
12:41:52 <JoeyA> Now, suppose we import Data.Array, and we do this:
12:42:34 <JoeyA> fibs = array (0,1000) [(i, fibonacci i) | i <- [0..1000]]
12:42:35 <napping> I don't know how to make just one definition and use an Id wrapper for the unlabeled case, without gumming things up with extra constructors
12:42:49 <miniBill|study> JoeyA: ok
12:43:04 <JoeyA> Now, instead of saying fibonacci n = fibonacci (n-2) + fibonacci (n-1)
12:43:19 <miniBill|study> except I would need [0,1..], but thats a detail
12:43:19 <JoeyA> we say fibonacci n = (fibs ! (n-2)) + (fibs ! (n-1))
12:43:27 <miniBill|study> ok
12:43:29 <miniBill|study> oh
12:43:32 <miniBill|study> I see you point
12:43:41 <miniBill|study> thank you!!!
12:43:41 <JoeyA> Well, it's an important one, since Haskell doesn't have infinite arrays.  You could use a Map instead for that.
12:43:55 <napping> you could use an infinite list if you like, but then it's O(n) lookup
12:43:55 <miniBill|study> it is?
12:44:17 <PetRat> I got used to many things about monads via do-notation. I noticed that liftM2, sequence and other functions can be compared to do-notation, which helped me. Perhaps this is not the best way to think of it, but the idea is here:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28246#a28246
12:44:51 <miniBill|study> napping: whereas with a finite one I have a O(1) lookup?
12:44:59 <napping> pretty much
12:45:23 <miniBill|study> mh... I think I'll go with the infinite. I really can't put an upper bound beforehand
12:45:25 <napping> also, infinite top level definitions can take up too much memory if they get unfolded too far
12:45:37 <miniBill|study> napping: what do you mean by that?
12:45:47 <napping> well, suppose you call it for a very big value once
12:46:07 <napping> then the list will get evaluated far enough to give you the result for 1 million or something
12:46:13 <miniBill|study> ok
12:46:14 <JoeyA> miniBill|study:  http://codepad.org/QgtTtWuP
12:46:28 <napping> and now all those 1 million list entries will hang around
12:46:38 <napping> even if you never need anything nearly that big again
12:46:42 <JoeyA> There's the Data.Array technique for a finite number of values packed together.
12:47:08 <napping> if it's just lookup time that worries you, you can define an infinite list of arrays of doubling sizes to get log time lookup
12:47:42 <miniBill|study> napping: I see. I dont think that the values hanging around are a problem in my case. Thanks for the info anyway
12:47:53 <ksf> erm, you practically can't have infinite maps. at least not really practically.
12:47:58 <miniBill|study> JoeyA: how does the array function work?
12:48:14 <ksf> as soon as you look for an element that isn't in the list you're going to loop eternally looking for it.
12:48:16 <miniBill|study> ksf: why?
12:48:27 <napping> Data.Map is spine-strict, yes
12:48:40 <miniBill|study> spine-strict? you're losing me guys :)
12:48:41 <JoeyA> miniBill|study : It takes a list of ordered pairs and builds an immutable Array out of it
12:48:46 <ksf> oh, that, too.
12:48:53 <napping> miniBill|study: you always know how big a Map is - it's balanced by size
12:48:59 <napping> so you can't have an infinite Map
12:49:02 <ksf> that's even worse and makes it completely unuseable.
12:49:05 <miniBill|study> ok
12:49:05 <JoeyA> The cool thing is, although Array is immutable, you can still memoize with it thanks to lazy evaluation.
12:49:06 <napping> (though the values can be lazily evaluated)
12:49:19 <napping> dunno who was talking about Map for an infinite memo table anyway
12:49:28 <JoeyA> Is it possible?
12:49:30 <miniBill|study> the point is that I don't know in avance the upper bound
12:49:38 <napping> another option is to define a memo table just for use durring the call
12:49:38 <JoeyA> e.g. if you could say:
12:49:43 <JoeyA> fibs :: Map Int Integer
12:49:50 <napping> if the local memoization / dynamic programming is enough of a speedup
12:49:51 <JoeyA> fibs ! x = fibonacci x
12:49:51 <ksf> oh, and finite lists don't have O(1) lookup. it's always O(n)
12:50:15 <ksf> JoeyA, nope, it isn't.
12:50:29 <napping> ksf: finite arrays promise O(1), though we might want to quibble about the computation model and logarithmic address sizes
12:50:36 <ksf> the map implementation would try to get to the end of the infinite list before even starting to lookup.
12:50:44 <miniBill|study> can't I just use a list like fibs = [ (i,fibonacci i) | i <- [0,1..] ] ?
12:50:48 <ksf> napping, arrays aren't lists
12:50:57 <ksf> (I guess we're talking different things, there)
12:50:58 <napping> ksf: JoeyA described arrays
12:51:27 <JoeyA> miniBill|study : Yes, you could, and it would be faster.
12:51:35 <JoeyA> But fibs !! n would be O(n
12:51:35 <JoeyA> )
12:51:38 <napping> you don't really need the label i though
12:51:47 <miniBill|study> why with two bangs?
12:51:54 <napping> that's for indexing lists
12:51:54 <JoeyA> !! means list subscript
12:51:57 <miniBill|study> and the array with only one bang?
12:51:59 <JoeyA> ! means Array subscript
12:52:00 <ksf> !! is array, ! is list lookup.
12:52:04 <ksf> :t (!)
12:52:05 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
12:52:09 <ksf> oh, yeah.
12:52:13 * benmachine giggles
12:52:18 <napping> various other data structures also define a !
12:52:47 <ksf> anyway, _any_ fib lookup is going to be O(n) minimum.
12:52:56 <ksf> ...you need that to calculate the value.
12:53:02 <napping> ksf: to compute from scratch the first time
12:53:11 <napping> arrays will give O(1) in practice for subsequence lookups
12:53:21 <ksf> if you want a really, really efficient implementation in a sane amount of space, do a skip list.
12:53:23 <napping> (and you could use fancy matrix multiplication tricks to cut the O(n))
12:53:30 <miniBill|study> whatevur, O(n) is waaay better that what I have now :)
12:53:50 <napping> ksf: a list of arrays of increasing size will also give you log(n)
12:53:53 <ksf> miniBill|study, how often do you need to call fib, and with what values?
12:54:14 <PetRat> Is there a use for typing something like "g `fmap` m1 `ap` m2" or would it normally be written "liftM2 g m1 m2"
12:54:37 <napping> PetRat: well, that generalizes to more argumen ts
12:54:46 <ksf> napping, I was thinking of memoizing every 10000th and 10000+1th element or such
12:55:07 <ksf> ...and then calculate every time anew from there.
12:55:15 <miniBill|study> I dont really need fib
12:55:16 <PetRat> napping: I tried g <$> m1 `ap` m2 but got an error---I think the precedence of <$> is wrong.
12:55:22 <miniBill|study> wait, I'll pastebin my code
12:55:32 <napping> PetRat: yeah, I don't think `ap` has a declared precedence
12:55:34 <applicative> Petrat, you can use <*> with <$>
12:55:43 <PetRat> applicative: in a monad?
12:55:44 <ksf> `foo` always binds tightest.
12:55:49 <napping> applicative: quite appropriate
12:55:54 <ksf> well, second tightest. only whitespace binds tighter.
12:56:20 <miniBill|study> http://codepad.org/prLUFUY0
12:56:34 <ClaudiusMaximus> can you use fixity declarations with `foo` syntax?
12:57:04 <miniBill|study> this is my current code. after ~300 minutes it still had no output :(
12:58:10 <miniBill|study> ksf: if you look at the definition of g and solution you'll see why I can't have a finite list
12:58:52 <miniBill|study> I was thinking about memoizing sf
12:59:04 <napping> I think you can improve it by hand
12:59:10 <miniBill|study> napping: how? :)
12:59:13 <applicative> Petrat, every monad is an applicative too.  The standard monads are instanced, I think.  In any case, it's just boilerplate
12:59:43 <roconnor> @src find
12:59:43 <lambdabot> find p          = listToMaybe . filter p
13:00:06 <ksf_> miniBill|study,  fac acc n = fac (acc * n) (n -1)
13:00:08 <ksf_> you're not being tail recursive, there.
13:00:15 <napping> tail recursion?
13:00:25 <copumpkin> !acc
13:00:28 <napping> umm.
13:00:28 <PetRat> applicative: ah, would it be right to say that whether the compiler uses the applicative or monad definitions of <$> and <*> it generates the same code in either case?
13:00:29 <applicative> PetRat, you type instance Functor MyMonad where fmap = mapM   instance Applicative MyMonad where pure = return ; <*> = ap
13:00:31 <miniBill|study> ksf_: ?
13:00:32 <napping> factorial n = product [1..n]
13:00:48 <napping> anyway, I don't quite see what you are doing with this digit folding stuff
13:00:50 <PetRat> (because the definitions are the same)
13:00:59 <monochrom> fmap = mapM is wrong. fmap = liftM is right
13:01:00 <miniBill|study> is it better with product or with tail recursion?
13:01:08 <ksf_> you're building up expressions like this: fac 3 = 3 * 2 * 1 * 1 
13:01:11 <napping> but I be some of the modular arithmetic can be pushed into things so you don't need to generate large intigers directly
13:01:18 <kmc> ClaudiusMaximus, yes
13:01:32 <ksf_> ...and if 3 is 1000 you're building 1000 terms before starting to evaluate.
13:01:53 <miniBill|study> napping: think of digit fold as of a fold over (the digits viewed as a list)
13:01:55 <ksf_> @src product
13:01:56 <lambdabot> product = foldl (*) 1
13:02:00 <ksf_> ugh.
13:02:04 <ksf_> shouldn't that be foldl'?
13:02:11 <monochrom> yes
13:02:12 <applicative> PetRat, I'm not sure what happens; the compiler's wit is beyond me.  I know it is sometimes  that if you can get away with only the Applicative instance, things might be faster.  
13:02:15 <napping> it actually seems to be a sum of the result of mapping g over the digits
13:02:31 <monochrom>  @src is for beginners only
13:02:38 <applicative> PetRat, It is sometimes "said" that ....
13:02:41 <CalJohn_> What is the right way to print an Int into a bytestring?  Hoogling for "Int -> ByteString" didn't turn up anything
13:02:47 <miniBill|study> napping: exaclty
13:02:56 <kmc> CalJohn_, ¬´B.pack . show¬ª ?
13:02:58 <ksf_> well, then the answer is: "product" or "foldl' (*) 1" is the best way.
13:02:58 <napping> that's not quite a fold
13:03:10 <miniBill|study> napping: no, you're right :)
13:03:13 <JoeyA> Here's memoizing fibonacci with Data.Map statefully in IO:  http://codepad.org/SESpEaeO
13:03:27 <CalJohn_> kmc: yeah, i was thinking aside from that, because i thought that would be fairly slow
13:03:34 <PetRat> applicative: okay, thanks
13:03:35 <ksf> wtf.
13:03:39 <JoeyA> (It's a bit complicated, but it came out nicer than I expected it to)
13:03:43 <ksf> whats' wrong with zipWith or scan?
13:03:59 <miniBill|study> JoeyA: I totally cant follow that code
13:04:04 <dancor> best factorial is libgmp..
13:04:05 <JoeyA> Nothing.  This is just demonstrating another memoization technique.
13:04:06 <napping> what the heck is digitfold factorial for?
13:04:18 <JoeyA> miniBill|study: It's the type of memoization you're familiar with.
13:04:20 <napping> dancor: gmp defines a factorial?
13:04:29 <kmc> CalJohn_, did you profile it?
13:04:32 <JoeyA> similar to using a std::map<Int, BigInteger> in C++, basically.
13:04:38 <ksf> zipWith the whole thing, throw away most of it but two consecutive elements at strategic places, then write a wrapper around that list.
13:04:41 <miniBill|study> napping: it applies the factorial to every digit, and sums the ruslts
13:05:00 <kmc> > length $ show $ (maxBound :: Int)
13:05:00 <napping> that is a very odd thing to be doing
13:05:01 <lambdabot>   19
13:05:14 <kmc> miniBill|study, JoeyA you already covered pure memoization?
13:05:14 <miniBill|study> ksf: ?
13:05:27 <miniBill|study> pure memoization?
13:05:39 <miniBill|study> napping: yes, but that's the problem request :)
13:05:50 <ksf> miniBill|study, kmc and me aren't the same.
13:05:55 <kmc> something like http://hackage.haskell.org/package/data-memocombinators
13:06:01 <ksf> but don't let that bother you, you aren't the first to confuse us.
13:06:13 <miniBill|study> :O whops :D
13:06:19 <JoeyA> miniBill|study: IO is an action type.
13:06:25 <kpt> just to confuse things some more
13:06:49 * miniBill|study is VERY confused now
13:07:04 <JoeyA> In Haskell, in order to do something stateful, rather than a "function" consisting of statements that are executed (like in imperative languages), you bind action values together.
13:07:06 * miniBill|study doesnt know what an action type is
13:07:17 <JoeyA> Take, for example, print
13:07:22 <kmc> miniBill|study, a value of type (IO T) is a "recipe" which, if executed, would produce a value of type T
13:07:26 <JoeyA> err, putStrLn (simpler)
13:07:30 <miniBill|study> ok
13:07:31 <JoeyA> putStrLn :: String -> IO ()
13:07:39 <kmc> miniBill|study, but the recipe is not the result, and merely building or evaluating the recipe does not execute it
13:07:46 <miniBill|study> ok
13:08:00 <kmc> getChar is a recipe, putStrLn is a function returning recipes, etc.
13:08:07 <JoeyA> It's like saying void putStrLn(String x); in an imperative language.
13:08:14 <JoeyA> However, you don't actually get to "call" putStrLn
13:08:15 <kmc> then we have this function (>>=) :: IO a -> (a -> IO b) -> IO b
13:08:18 <JoeyA> You just bind it to actions that call it.
13:08:19 <kmc> which glues two recipes together
13:08:20 <ksf> > [putStr "Hello, ", putStrLn "World!"]
13:08:21 <lambdabot>   [<IO ()>,<IO ()>]
13:08:36 <ksf> :t putStr "Hello, " >> putStrLn "World!"
13:08:36 <kmc> and we have this "do" syntax, which is just a nice shorthand for writing some (>>=) with lambdas 
13:08:37 <lambdabot> IO ()
13:08:51 <ksf> :t do {putStr "Hello, "; putStrLn "World!" }
13:08:52 <lambdabot> IO ()
13:08:54 <kmc> and the only recipe which is really executed is the one you call "main" in your Main module
13:09:02 <ksf> > do {putStr "Hello, "; putStrLn "World!" }
13:09:04 <kmc> or if you're in ghci, you can type a recipe at the prompt and it will be executed
13:09:05 <lambdabot>   <IO ()>
13:09:05 <kmc> and that's the 20 second introduction to IO in Haskell
13:09:18 <miniBill|study> ok
13:09:25 <miniBill|study> got that
13:09:27 <kmc> :)
13:09:28 <applicative> kmc, I think data.memocombinators doesn't work to make, e.g. a fast fib.  But maybe I didn't know how to use it.  
13:09:38 <miniBill|study> I don't need a fib :D
13:09:43 <kmc> applicative, i'm not sure if it works; what problem did you run into?
13:09:46 <monochrom> > take 30 (fix (\fs -> 0 : 1 : zipWith (+) fs (tail fs)))
13:09:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:09:57 <ksf> ...and lambdabot will ignore you if you tell her to do impure IO actions.
13:10:12 <kmc> it's more that there's no way to tell her to do an impure IO action
13:10:13 <miniBill|study> her?
13:10:16 <kmc> whatever that means
13:10:22 <ksf> @vixen, a/s/l
13:10:23 <lambdabot> 19/f/California
13:10:27 <kmc> there's no way to ask lambdabot to do execution, only evaluation
13:10:39 <JoeyA> @lambdabot, a/s/l
13:10:39 <lambdabot> Unknown command, try @list
13:10:45 <JoeyA> pah
13:10:52 <monochrom> this is not twitter
13:10:52 <aristid> @vixen asl
13:10:52 <lambdabot> 19/f/California
13:11:14 <jmcarthur> @vixen like, really?
13:11:14 <lambdabot> really!
13:11:19 <applicative> I was studying it in connection with a ridiculous reddit tempest-in-a-teapot.  Let me see
13:11:24 <ksf> @vixen didn't you claim to be 19 last year, too?
13:11:25 <lambdabot> awesome, we're the same age
13:11:32 <miniBill|study> WTF?
13:11:36 <tommd> @vixen not too bright, are you?
13:11:40 <lambdabot> i truely am
13:11:42 <ksf> @vixen now that was either very deep or utterly retarded.
13:11:42 <lambdabot> now now now...so demanding
13:12:04 <aristid> @vixen x 19 y
13:12:04 <lambdabot> awesome, we're the same age
13:12:11 <miniBill|study> @vixen 19
13:12:11 <lambdabot> awesome, we're the same age
13:12:13 <shachaf> > execState (modify succ) 5 -- Execution
13:12:13 <lambdabot>   6
13:12:16 <aristid> @vixen 18
13:12:17 <lambdabot> oh, i used to be that old too
13:12:20 <monochrom> @vixen 57
13:12:21 <lambdabot> wow, most of your life is almost over!
13:12:22 <aristid> lol :D
13:12:26 <miniBill|study> lawl
13:12:48 <kmc> > let œÜ = (1 + sqrt 5)/2; fib n = round ((œÜ^n - (1-œÜ)^n) / sqrt 5) in fib 20 -- the fastest fib
13:12:49 <lambdabot>   6765
13:12:55 <ksf> I think someone should teach her some context.
13:12:58 <monochrom> @vixen 6765
13:12:59 <lambdabot> Fuck me like im a school boy
13:13:07 <kmc> hehehe
13:13:10 <kmc> @. elite nixon
13:13:10 <lambdabot> T|-|3y'Re N0T |IK3 u$. +HEy s/\/\e|1 diphfErEnT, +|-|Ey lOox DiFpher3n7, 7|-|3y 4(T dIffeReN7. T|-|3 +ROubLE iS, y0u (aN'+ phINd ONe tHa+'z |-|one$7.
13:13:13 <c_wraith> what?  where'd that one come form?
13:13:14 <burp> @vixen -10
13:13:14 <lambdabot> Have you ever killed a hobo?  Ive found eating their liver gives me strength.  I think i may just be short on b vitamines.
13:13:30 <ksf> it'd be really, really creepy if she would refer one to something in the scrollback that was not specifically adressed to her.
13:13:36 <miniBill|study> @vixen i
13:13:36 <lambdabot> Beer, it's so much more than just a breakfast drink!
13:13:45 <shapr> Is there one specific Haskell channel where it's best to ask questions about blaze-html?
13:13:52 <miniBill|study> > sqrt -1
13:13:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:13:53 <lambdabot>    arising from a use of `...
13:14:01 <JoeyA> > sqrt (-1)
13:14:02 <dancor> napping: libgmp has mpz_fac_ui()
13:14:02 <lambdabot>   NaN
13:14:08 <miniBill|study> oh, yeah
13:14:11 <miniBill|study> (-1)
13:14:16 <c_wraith> > sqrt (-1) :: Complex Rational
13:14:17 <lambdabot>   No instance for (GHC.Float.RealFloat
13:14:17 <lambdabot>                     (GHC.Real.Ratio GH...
13:14:17 <JoeyA> Haskell is really annoying with the - symbol
13:14:21 <c_wraith> > sqrt (-1) :: Complex Real
13:14:21 <lambdabot>   Class `GHC.Real.Real' used as a type
13:14:25 <c_wraith> > sqrt (-1) :: Complex Double
13:14:25 <JoeyA> sqrt -1 means sqrt - 1
13:14:26 <lambdabot>   (-0.0) :+ 1.0
13:14:32 <c_wraith> I suck at this "memory" stuff
13:14:38 <JoeyA> (+1) means "add 1", as in:
13:14:41 <JoeyA> > (+1) 5
13:14:42 <lambdabot>   6
13:14:46 <miniBill|study> > sqrt (-1) :: Complex Int
13:14:46 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
13:14:47 <lambdabot>    arising from a use o...
13:14:49 <JoeyA> But (-1) means negative 1, as in:
13:14:55 <lambdabot> would it really be that creepy, ksf?
13:14:57 <JoeyA> > (-1) 5 -- doesn't subtract 1 from 5
13:14:58 <lambdabot>   -1
13:15:13 <JoeyA> > 2 2
13:15:14 <c_wraith> ...  how did that compile?
13:15:14 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:15:14 <lambdabot>    `GHC.Num.Num t' arising f...
13:15:16 <ksf> shapr!
13:15:33 <shapr> ksf! Wassup?
13:15:43 <ksf> stop fooling with her!
13:15:51 <kmc> @. elite nixon
13:15:52 <lambdabot> SCRUb8iNg Floorz ANd emptyiN9 B3Dp4nS |-|az0rz aS /\/\u(H DIgNiTY a$ THe PRE5IdenCY.
13:15:53 <shapr> I'm trying to do basic html templating with Blaze, but the example doesn't compiler.
13:15:57 <ksf> and admit that you are the culprit!
13:16:00 <shapr> ksf: Eh? I'm not fooling with anyone!
13:16:01 * miniBill|study is thinking about running in circles screaming of fear
13:16:03 <ksf> don't make me look stupid!
13:16:09 * shapr is confused
13:16:10 <applicative> kmc, hah, jdh30 has just weighed in, a few days late.  Here's the discussion http://www.reddit.com/r/programming/comments/crgxs/do_i_really_want_to_be_using_a_language_where/c0upzm9
13:16:28 <kmc> c_wraith, we have a wacky instance here (Num a) => Num (b -> a)
13:16:40 <kmc> or perhaps even (Num a, Applicative f) => Num (f a)
13:17:04 <ksf> damn reddit.
13:17:09 <napping> shapr: oh, I wonder if there are RULES that target it
13:17:10 <JoeyA> Just curious, has anyone here ever need to compute the fibonacci series for a real-world application?
13:17:16 <ksf> didn't they say they wanted to buy new boxen?
13:17:23 <miniBill|study> JoeyA: not me :)
13:17:35 <applicative> kmc, I think memocombinators yields the same result as 1nine8four's use of unsafePerformIO, It's a different sense of 'memoize' that the OP was looking for. 
13:18:07 <napping> you just need to open up the fixpoint, right?
13:18:45 <pickles> ksf: at least she's not offering you cake?
13:18:46 <kmc> i'm still not clear on why we should care if some very uninterested / incurious / anti-intellectual people don't want to learn Haskell
13:18:48 <applicative> kmc, I'm not sure how you would memoize in Haskell, in the sense that Clojure does, without something exotic.  
13:18:57 <kmc> which sense is that applicative?
13:19:06 <JoeyA> applicative: Now that's cool, although I'd use Data.Map instead :)
13:19:43 <napping> kmc: has that been a problem?
13:20:01 <applicative> kmc, well i tried some of the memoizing libs, once I figured out what was going on, they all give a result like 1nine8fours.  
13:20:30 * ksf thinks one should be able to snatch the Hask applicative and redefine it.
13:20:48 <ksf> ...in a sense no-AST metaprogramming.
13:21:16 <miniBill|study> what are you saying here?
13:21:17 <ksf> oh, and snatch open recursion out of the graph. loops suck.
13:21:34 <kmc> applicative, i don't have the context to know what 1nine8fours is
13:21:37 <applicative> kmc Intuitively, in the calculations of fib 30 one calculates, e.g fib 10 fib 11 etc.  But in calculating fib 30 they are not used.  fib 30 is stored somehow
13:21:44 <kmc> napping, you mean my "don't want to learn Haskell" comment?
13:22:12 <monochrom> memoizing fib is rather dumb actually
13:22:26 <ksf> I got downvoted for pointing that out.
13:22:42 <applicative> kmc, the point was, if he asked for fib 30 in ghci, it'd take a while, but if he asked again it was instantaneous. 
13:22:45 <napping> kmc: I don't think that's much of a problem.  Such people scaring others away from learning Haskell may be a problem
13:22:51 <monochrom> time to cancel your reddit account :)
13:23:24 <applicative> monocrom, it didn't matter that it was fib.  There was something the OP was talking about, but he communicated badly, I don't see how to do it in Haskell
13:23:37 <monochrom> oh ghci remembers a horrendous amount of history, don't use it for fair comparison
13:23:55 <miniBill|study> so no luck? :(
13:24:10 <applicative> the task was to give a general formula which would take any naively defined recursive function,  and, by memoizing speed up the calculation in any case.
13:24:11 <kmc> napping, i refer to things like "do i want to learn a language where [x] is a PhD-level topic"
13:24:19 <monochrom> memoization in general? you can easily use an array
13:24:38 <kmc> ignoring the fact that nearly anything can be made a PhD-level topic if you investigate it deeply enough
13:25:03 * napping imagines such a topic with x = "avoiding segfaults"
13:25:04 <miniBill|study> monochrom: yes, but I haven't got an upper bound
13:25:16 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example  and even then my example there does not really need that much memoization
13:25:18 <kmc> yes, there are probably hundreds of dissertations on avoiding segfaults in C
13:25:27 <Gracenotes> huh. unix-compat won't install because it isn't importing the proper macros
13:25:56 <napping> miniBill|study: it gets big pretty fast
13:26:15 <Gracenotes> it needs major, minor and makedev. which it can get from <sys/sysmacros.h>. but it's importing <sys/types.h>, which doesn't export the macros on this computer
13:26:17 <applicative> monochrom, that's not to the point, it took a while to get it.  He wants a function memo, which applies to any recursive f, and speeds up even a single call of f, by 'memoizing' the recursively prior results.  Clojure actually has such a 'function'.  
13:26:23 <Gracenotes> <:(
13:26:34 <monochrom> without upper bound, in some cases you can use a list, and in some cases it's even faster than array
13:27:10 <napping> applicative: that's the sort of reflectiony stuff you can't do in Haskell
13:27:13 <miniBill|study> napping: what gets big?
13:27:15 <kmc> not easily anywya
13:27:17 <applicative> monochrom, one problem is that the action of the clojure memo function seems to reflect on the definition given in some way.  
13:27:18 <napping> miniBill|study: your sg
13:27:32 <kmc> but you could do it if you wrote f as (fix g)
13:27:34 <napping> sg 43 > 1,000,000, for example
13:27:40 <kmc> you can write a memoizing fix
13:27:43 <napping> doing it by linear scan is maybe not so fast
13:28:02 <monochrom> alright, I'm more than happy to answer "can't be done".
13:28:04 <applicative> napping, right, that's what I was thinking, but all our fellow Haskellers were weighing in saying "oh we have memoization" no problem.  
13:28:15 <monochrom> reflection and code optimization don't mix well
13:28:16 <miniBill|study> kmc: fix?
13:28:19 <kmc> :t fix
13:28:20 <lambdabot> forall a. (a -> a) -> a
13:28:43 <napping> applicative: the memoization is not the problem. If you write it in open style taking the recursive function any approach will work fine
13:28:47 <kmc> > let fact self 0 = 1; fact self n = n * self (n-1) in (fix fact) 5
13:28:47 <lambdabot>   120
13:28:59 <napping> That's a general pattern with Haskell anyway
13:29:01 <applicative> monochrom, that's exactly what I was thinking.  In general we have no reason to think that when we define a function recursively, ghc will take it by stages, naively.
13:29:04 <kmc> miniBill|study, ^^^^ fact doesn't call itself, it only calls this argument it gets, which i called "self"
13:29:17 <kmc> miniBill|study, then "fix" ties the knot to arrange that each time fact is called, self = fact
13:29:27 <napping> you can't do reflection worth a damn, but it's usually pretty easy to define some sort of representation which can be evaluated to give your function, or manipulated more easily
13:29:39 <napping> and, not or
13:29:46 <miniBill|study> ok, maybe this program is best done in Mathematica :D
13:30:05 <napping> miniBill|study: it seems to go exponentially
13:30:09 <applicative> kmc, there is a general procedure for doing this, yes, but each definition must be rewritten.  Clojure takes your stupid naive recursive def, whatever it is, and speeds it up with memoization, you don't need to redefine it
13:30:12 <napping> I think you need a bit more smartness about mods and sums
13:30:30 <kmc> applicative, i understand
13:30:34 <miniBill|study> napping: probable. I probably need a non-bruteforce approeach
13:30:42 <napping> seems like it
13:30:56 <kmc> > fix ((0:).scanl(+)1)
13:30:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:30:59 <napping> I don't think the usual (digitsum x) `mod` 9 == x `mod` 9 trick helps here
13:31:18 <napping> 45 is first reached by sf 12378889
13:31:19 <miniBill|study> just for reference: http://projecteuler.net/index.php?section=problems&id=254
13:31:33 <miniBill|study> kmc: I cant read that :)
13:31:36 <monochrom> pun: einstein's theory implies that haskell cannot be faster than c :)
13:31:47 <miniBill|study> monochrom: :D
13:31:54 <kmc> miniBill|study, the last bit of code is just showoffy, ignore it ;)
13:32:01 <kmc> miniBill|study, but did you understand my explanation of 'fix'?
13:32:02 <pickles> nice one monochrom
13:32:07 <Zao> *groan*
13:32:13 <kmc> monochrom, ;PPP
13:32:24 <miniBill|study> oh, NOW I got it [I was reading c only as "speed of light"]
13:32:24 <kmc> @remember monochrom einstein's theory implies that haskell cannot be faster than c
13:32:25 <lambdabot> It is stored.
13:32:38 <miniBill|study> @rembember monochrom 
13:32:38 <lambdabot> Incorrect arguments to quote
13:32:43 <miniBill|study> @quote monochrom 
13:32:44 <lambdabot> monochrom says: Absolute0> copumpkin: do you give out free pumpkins on halloween? :) monochrom> I think copumpkin takes in free pumpkins.
13:32:44 <kmc> @quote monochrom
13:32:44 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
13:32:44 <lambdabot> entire human race would have to be rewritten!
13:33:06 <miniBill|study> lol?
13:33:11 <kmc> so you're saying we need a tachyon generator
13:33:13 <miniBill|study> @quote kmc
13:33:13 <lambdabot> kmc says: Rule number 1 of Haskell talks: use Comic Sans MS.
13:33:24 <napping> applicative: does Closure's memoize work in higher order functions?
13:33:28 <miniBill|study> kmc: I understood fix, but didnt understand how it helps
13:33:46 <napping> like, (defun (example f) ((memozie f) 10232))
13:33:50 <kmc> miniBill|study, well, what are you trying to do
13:33:52 <miniBill|study> @quote miniBill|study 
13:33:52 <lambdabot> bartek says: It took me 2 years of studying teachings of Oleg Kiselyov (who was raised among types, where he learned to speak their language), but finally, I have the solution.
13:33:55 <BMeph> monochrom: To continue the pun, Haskell can be faster than c, but it would just waste resources to try to make Haskell equal the speed of c.
13:34:03 <applicative> napping, I think it doesn't, that came up in the tide of blather.  
13:34:10 <napping> oh, funny
13:34:22 <napping> I'd expect a symbol table replacement thingy to kind of work, but stack up layers of memoization
13:34:25 <JoeyA> Here's the unsafePerformIO memo trick from the reddit link, adapted to Data.Map:  http://codepad.org/MHL5lsuw
13:34:26 <miniBill|study> kmc: http://projecteuler.net/index.php?section=problems&id=254
13:34:31 <pickles> @quote lambdabot
13:34:32 <lambdabot> lambdabot says: I know nothing about comprehending.
13:34:38 <napping> .. hmm, assuming recursive calls even indirect through the symbol table
13:34:42 <ksf> darn scheme and it's quasiquoting.
13:34:48 <ksf> I want to have that in haskell.
13:34:48 <napping> lisp gets much utility from the mutable global symbol table
13:34:50 <kmc> miniBill|study, ok.  so you coded each of f, sf, g, sg, in Haskell, and now you want to memoize?
13:35:06 <napping> kmc: I doubt it really helps
13:35:12 <napping> he needs to go to 45
13:35:17 <napping> er, to 150
13:35:34 <miniBill|study> eh, that's the point. The code works, but it dies :D
13:35:34 <napping> and argument 46 already requires scanning that [1..] out to 133378889
13:35:51 <miniBill|study> napping: yukk
13:35:58 <kmc> as i recall, later PE problems require you to have some mathematical cleverness
13:36:04 <kmc> more than just brute computation
13:36:12 <miniBill|study> eh, you're probably right
13:37:04 <miniBill|study> wel,, thank you anyway. I guess I'll choose an easier problem :D
13:37:15 <kmc> did you solve PE 1 through 253?
13:37:16 <flazz_> are class functions exported by default?
13:37:22 <miniBill|study> kmc: totally NOT
13:37:28 <kmc> flazz_, if you have no export list, everything is exported
13:37:42 <miniBill|study> kmc: I solved 31 problems
13:38:07 <napping> applicative: reflection kills parametricity anyway
13:38:10 <pickles> @quote lambdabot
13:38:10 <lambdabot> lambdabot says: Will I get a treat if I join #gentoo-uy?
13:38:19 <kmc> miniBill|study, are you running your PE programs in ghci or compiling them?
13:38:33 <napping> applicative: I think it's best to keep parametricity, and figure out nice ways to recover the stuff you want from reflection
13:38:39 <miniBill|study> Also, 320 ppl had an answer to problem 254 :O
13:38:39 <pickles> @qotd
13:38:39 <lambdabot> Maybe you meant: quote vote
13:38:45 <miniBill|study> kmc: ghc --make
13:38:53 <kmc> ok
13:38:55 <kmc> ghc -O2 --make ?
13:38:56 <miniBill|study> but I used mostly C for PE
13:38:59 <kmc> ok
13:39:01 <miniBill|study> no -O
13:39:09 <miniBill|study> could -O2 help?
13:39:15 <kmc> it could make things faster, yes
13:39:31 <miniBill|study> but well, napping said that it is exponential
13:39:46 <miniBill|study> so I guess I have to think mathematically, more than computationally
13:39:50 <kmc> right, i mean more generally
13:40:51 <napping> miniBill|study: well, note sf gives you the same result on anything with the same bag of digits
13:40:57 <napping> that should save you quite a nice factor
13:41:00 <Gracenotes> okay, so I had to unpack unix-compat, edit a C header file, and cabal install that. now it works. :|
13:41:22 <applicative> JoeyA, i see, yours actually works as advertised. I wonder why? 
13:41:33 <dcoutts_> Gracenotes: unix-compat is rather ugly
13:42:03 <napping> applicative: if you want the dark side, meditate on this http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects
13:42:04 <benmachine> Gracenotes: submitabug
13:42:10 <benmachine> or something
13:42:32 * napping has never intentionally overwritten an info table pointer :(
13:42:46 <kmc> am i the only one who sometimes does ¬´type Z = Integer¬ª?
13:43:01 <Gracenotes> well, the bug is this: it imports <sys/types.h> to get things in <sys/sysmacros.h>, but types.h doesn't always re-export it
13:43:10 <Botje> kmc: but then what's S Z? :)
13:43:14 <kmc> ;)
13:43:32 <napping> yes, but in Agda it's traditional to declare data ‚Ñï ...
13:43:42 <Gracenotes> but I'm not sure how widely available sysmacros.h is... and it is supposed to be compat, ne. anyway
13:44:09 * miniBill|study runs before getting completely mad
13:44:11 <roconnor> how does ocaml tell if a pattern item is a variable binding or a constructor name?  Is it the same as in Haskell with upper/lower case letters?
13:44:20 <ickabob> Could someone take a look at this and let me know if it would sucsessfully make Data.Map an instance of the Functor type class?  I'm trying to learn haskell and Learn You a Haskell tasked me with such an action.  http://codepad.org/lHOh8IFU
13:44:39 <copumpkin> ickabob: you couldn't do it
13:44:45 <kmc> ickabob, quite unlikely, Data.Map doesn't export a value constructor
13:44:46 <ickabob> with that code or in general
13:44:50 <napping> roconnor: I'm not sure. I'm pretty sure Agda does something about whether a constructor of that name is in scope
13:44:55 <ickabob> Ah
13:45:00 <ezyang> ickabob: Hmm, this is made complicated by the fact that there is already a functor instance. 
13:45:04 <roconnor> napping: thanks, that is helpful
13:45:06 <kmc> you're trying to use the type Data.Map.Map as if it were a constructor
13:45:13 <kmc> the same sort of confusion as Maybe vs. Just
13:45:15 <copumpkin> ickabob: also, you should use ghc :P
13:45:17 <napping> hmm, it's actually unambiguous if there arguments
13:45:17 <flazz_> i have two functions named update. i'm calling it in a specifically typed context, why would the compiler say it is ambiguous?
13:45:25 <JoeyA> applicative: It works using the exact same function 1nine8four gave:  http://codepad.org/x64eue1s
13:45:35 <kmc> flazz_, because Haskell does not do type-dependent name resolution
13:45:35 <ezyang> flazz_: We don't allow type overloading. 
13:45:35 <roconnor> napping: ya, but there might not be arguments
13:45:37 <copumpkin> flazz_: it doesn't resolve based on type
13:45:38 <kmc> that way lies madness, and C++
13:45:41 <Gracenotes> you could define a functor instance from fromList and toList, reusing the list functor instance. still..
13:45:59 <JoeyA> (in both GHC and hugs)
13:46:13 <napping> applicative: that's just another example where recursion was manually split
13:46:15 <roconnor> napping: it's tempting to mark pattern variables in some way
13:46:29 <ickabob> Thanks all, actuall implementation isnt important to me, I just wanted to verify I had the idea of a Functor correct
13:46:44 <flazz_> so if i want overloading i'm not being abstract enough
13:46:48 <napping> roconnor: Lately I'm thinking it's worth going to some length to minimize lexical overhead
13:46:54 <kmc> flazz_, you might want a type class
13:46:55 <ezyang> ickabob: What you can do is define your own Map type, and then define a Functor for it. 
13:46:55 <applicative> JoeyA, i see that. you just replaced IORef [(k,v)] with IORef (Map k v)   I'm puzzled why it works, maybe it's just lucky...
13:47:06 <kmc> flazz_, but Haskell generally rejects the idea of overloading merely to reuse the same name for two unrelated things
13:47:09 <ickabob> ezyang: yeah I will end up doing that. thanks.
13:47:16 <kmc> flazz_, we overload by type class when things are semantically related
13:47:19 <roconnor> napping: but the ambigutity is kinda unsettling
13:47:24 <napping> though I guess marking the variables in the pattern might not be so bad
13:47:36 <kmc> so you make a class for numerical operations, or for comparison, but not "class of things i want to use >> on, be they bit registers or output streams"
13:47:41 <Gracenotes> ickabob: since Map is a binary tree, you could just define Tree a = Leaf | Node (Tree a) a (Tree a), although that doesn't take care of balancing
13:47:49 <JoeyA> applicative: memo f performs the unsafe action of creating an empty map, then returns a function
13:47:58 <Gracenotes> ickabob: if you want more typeclass practice (albeit under a different name), http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
13:47:59 <napping> I'm kind of interested in indicating it with typesetting
13:48:02 <JoeyA> This function performs an unsafe action to look up on the memo table.
13:48:05 <JoeyA> Where's the mystery?
13:48:19 <JoeyA> And why are people / is a person calling it "wrong"?
13:48:48 <napping> I think M-x describe-char for agda-mode closes the loop nicely on having a display syntax different from the entered text
13:50:07 <napping> It's a shame if people usually start a program in the less elegant/extensible style because it's easier to read
13:50:12 <applicative> JoeyA, but if I ask it for me mo fib 20 or whatever, why doesn't it just insert 6765 for that, why does it have to fill 0 - 20?
13:50:29 <napping> applicative: cause those are touched in the recursive computation of fib 20
13:51:07 <applicative> napping, but if we were certain of that in JoeyA's case, we should be certain in 1nine8four's
13:51:19 <aavogt> the distinction between 'semantically related' and 'semantically unrelated' overloading is pretty arbitrary. The situation is more like this: type errors less helpful the more classes you have, so if every function is a method of its own class for the purpose of type directed name resolution, you're making more trouble that you've saved
13:51:24 <napping> applicative: wasn't your complaint that you had to modify the original fib?
13:51:40 <JoeyA> If we have fib :: Int -> Integer; fib 0 = 0; fib 1 = 1; fib n = fib (n-2) + fib (n-1)
13:51:46 <JoeyA> And we say memo fib
13:51:48 <kmc> aavogt, i agree there's no sharp line, but i think it's worth keeping the distinction in mind as a design guideline
13:51:57 <JoeyA> Yes, it will memoize fib, but not "that way"
13:52:11 <napping> not the O(n) way
13:52:12 <JoeyA> If you say fib 100, it'll spend an eternity computing that, then memoize only that entry.
13:52:28 <applicative> napping, yeah.  JoeyA's (like 1nine8four's) doesn't require a special definition.   But one actually 'memoizes' in the Clojure sense, the other not. 
13:52:36 <napping> huh?
13:53:01 <napping> was the earlier one just memoizing the final result?
13:53:13 <ezyang> I've never quite understood when GHC shares results of function applications and when it doesn't. 
13:53:14 <JoeyA> So you're not scott-free.  You still have to memoize in a similar fashion as with Data.Array
13:53:15 <napping> I thought what you wanted was something that could apply to the unmodified definition
13:53:17 <applicative> napping, yes, like data.memocombinators and all the memo libs
13:53:19 <napping> which JoeyA does not
13:53:31 <aavogt> kmc: if you could retroactively decide that these two functions should have the same name without having to change the first function's defintion (that is, compiler support for type-directed-name-resolution), I think the outcome would be different
13:53:39 <JoeyA> http://codepad.org/x64eue1s
13:53:45 <napping> the memoization JoeyA is doing in is exactly what those libraries provie
13:53:46 <aavogt> (in terms of the kind of code that would be written)
13:53:50 <kmc> aavogt, that is the situation in Java and C++
13:53:52 <JoeyA> In that code, fib depends on fibonacci and vice versa.
13:54:01 <kmc> different how?
13:54:17 <thoughtpolice> oh, someone discussing my totally crappy and trivial memoization function I put on reddit to dispel myths about 'memoization in haskell requires a phd' (1nine8four here, hi applicative & joeyA!)
13:54:19 <JoeyA> It's pretty much the same technique as using Data.Array, but it's infinitely extensible.
13:54:33 <applicative> napping, I don't think so, I tested it in a number of ways, they all gave the sort of result the clojure guy (and now jdh30) complained about
13:54:37 <thoughtpolice> how funny I happen to look at IRC at this moment... :P
13:54:41 <JoeyA> thoughtpolice: You posted that?  I think it's awesome.
13:54:42 <kmc> hi thoughtpolice
13:54:47 <thoughtpolice> JoeyA: hi! thanks
13:54:48 <aavogt> kmc: the noise of using lots of classes stops people from using TDNR as it's already implemented
13:55:03 <napping> fib 0 = 0; fib 1 = 1; fib n = fibonacci (n-2) + fibonacci (n-1); fibonacci = Memo.integral fib
13:55:06 <applicative> 1nine8four, hi!
13:55:19 <applicative> thoughtpolice, i'm not sure how it came up....
13:55:21 <napping> applicative: does that not work efficiently for you?
13:55:24 <JoeyA> Here's a Data.Map version, all wrapped up in a module:  http://codepad.org/A7EdEm6n
13:55:25 <kmc> thoughtpolice, my two cents is that it'd be a better use of time fighting anti-intellectualism in the programming community rather than each individual myth about Haskell specifically
13:55:46 <JoeyA> It works in both GHC and hugs, making it super-cool.
13:55:55 <kmc> the whole "x is a PhD topic" idea is really quite silly
13:56:04 <kyagrd> unsafePerformIO !!
13:56:05 <lambdabot> kyagrd: You have 3 new messages. '/msg lambdabot @messages' to read them.
13:56:06 <kmc> there are PhD dissertations about multiplying two numbers
13:56:48 <napping> kmc: I don't think anti-intellectualism per se is a problem, just when it tries to metastasize with FUD
13:56:50 <JoeyA> I think that memo function will prove to be very useful in programming competitions.
13:57:36 <napping> that is, to the extent we care about the Haskell community in particular it's worth some time debunking this kind of junk
13:57:52 <hgolden> @tell dons is there any show-stopping reason why hs-plugins couldn't be updated to run under ghc-6.12? if not, i'll try.
13:57:53 <lambdabot> Consider it noted.
13:59:20 <kmc> napping, i care about the community.  people who will be scared away from a language because smart people use it are decidedly outside the community
13:59:42 <thoughtpolice> kmc: I try to do that in general, yes
14:00:11 <aavogt> they are more likely scared because they think you need to be smart to use it
14:00:12 <thoughtpolice> JoeyA: hopefully it can be of use to someone
14:00:21 <napping> applicative: just got a nice fast "fibonacci 10000" from those lines I pasted
14:00:41 <kmc> you do have to be smart to use Haskell
14:00:52 <kmc> that's because you have to be smart to write correct programs, in any language
14:00:53 <thoughtpolice> JoeyA: I think the only major caveat to that version that isn't obviously visible I believe is that you must use memo over a CAF or the like, you cannot use it over a higher order function because closures reside on the heap - ghc will lose sharing of the memo table I'm pretty sure
14:01:03 <thoughtpolice> net result: memo fib = good, memo (\x -> ...) = bad
14:01:09 <kmc> Haskell feels harder because it's harder to get away with writing incorrect programs
14:01:18 <kmc> (not to say that's the only reason)
14:01:18 <napping> really?
14:01:20 <JoeyA> What's the CAF?
14:01:28 <thoughtpolice> in this case it would just be 'fibonacci'
14:01:29 <napping> I like not having to be smart all the time
14:01:34 <kyagrd> @tell FunctorSalad I alread made the patch to logic-TPTP myself and updated the hackage package and it works on ghc 6.12.  I also Forked your darcs repo into Patch-tag http://patch-tag.com/r/kyagrd/logic-TPTP and gave you (I believe you are using FunctorSalad as your account name) the full access.
14:01:34 <lambdabot> Consider it noted.
14:01:36 <thoughtpolice> napping: I'm pretty sure, yeah
14:01:43 <thoughtpolice> napping: I know, me too!
14:01:47 <napping> define some cunning types, then bang out any old code
14:01:51 <napping> works better in Coq
14:01:58 <napping> but reasonably well in Haskell
14:02:27 <napping> kmc: also, a good research vehicle is not necessarily a good language for productive use
14:02:29 <aavogt> perhaps you've just shifted the complexity to writing those types
14:02:49 <kmc> napping, what's your point?
14:02:50 <napping> aavogt: The point is that it's isolated
14:03:27 <benmachine> hmm
14:03:27 <kmc> there are tons of dissertations about Haskell, and about Java, C#, assembly, ...
14:03:32 <kmc> i'd wager there's a few about PHP by now
14:03:48 <kmc> though not really 'about', the language is just the medium
14:03:51 <benmachine> I reckon Lift is another class which is subsumed by Data
14:03:54 <kmc> but that's how the anti-intellectuals see it, apparently
14:03:55 <thoughtpolice> I'm pretty sure someone did their Ph.D thesis over optimizing PHP by implementing a compiler for it
14:04:00 <benmachine> hmm
14:04:02 <copumpkin> I hate thought
14:04:04 <napping> in Haskell, yes?
14:04:07 <benmachine> maybe Data is the class to end all classes.
14:04:07 <thoughtpolice> (phc I think, paul biggar iirc?)
14:04:10 <copumpkin> so does thoughtpolice 
14:04:13 <kmc> thoughtpolice, at facebook?
14:04:14 <applicative> copumkin is lying
14:04:16 <benmachine> maybe I should stop trying to read so much into this
14:04:17 <napping> well, dunno if there was a dissertation
14:04:19 <kyagrd> @tell FunctorSalad I also want to make further changes to the parser about parsing comments, so I suggest we use patch-tag as head repository to share the repository access since I don't have community.haskell.org account. I'll send email for further details.
14:04:19 <lambdabot> Consider it noted.
14:04:32 <monochrom> I agree I don't want to be smart all the time. I disagree it implies "define some cunning types, then bang out any old code". It should imply "write some cunning code, then get wasted on IRC for the rest of the day".
14:04:41 <thoughtpolice> kmc: no, not hiphop, this guy did his work independently
14:04:56 <thoughtpolice> kmc: although apparently he did presentations about PHC @ facebook, inevitably they ended up writing hiphop
14:05:05 <kmc> heh
14:05:07 <kmc> figures
14:05:09 <napping> monochrom: ah, but the types divide the labor a bit
14:05:27 <napping> monochrom: so you only have to write part of the code, and can get wasted before starting the rest
14:05:29 <monochrom> well, how to achieve "write some cunning code" is up to you.
14:05:45 <napping> anyway
14:05:53 <applicative> napping, indeed, it's working like the OP wanted, but I wonder if we're lucky? It seems to depend on what the compiler does with the def of fib.   Im certain I checked some things with MemoCombinators and got unpleasant results
14:06:06 <napping> applicative: um, there's nothing strange going on
14:06:26 <napping> it's a function that makes many repeated calls to itself
14:06:31 <thoughtpolice> copumpkin: I don't hate all thoughts, only those which would pose an issue to The Party
14:06:58 <thoughtpolice> in which case you will be sent to the Ministry of Love accordingly with standard Party guidelines
14:06:58 <napping> memo slowfun vs let fast = memo (open_slowfun fast) in fast
14:07:07 <c_wraith> hmm.  download-curl perhaps provides slightly too little information for me.
14:07:13 <Zontar> haskell
14:07:19 <napping> the later intercepts and memoizes the many repeated recursive calls
14:07:22 <napping> the former does not
14:07:24 <Zontar> why
14:07:43 <napping> Zontar: for the fixpoints
14:07:50 <Zontar> poor napping
14:09:36 <kmc> ‚Ä¶
14:09:46 <pesco> so, jumping into the discussion, what's wrong with the memofix solution somebody suggested very early on in those reddit comments?
14:09:58 <napping> not much
14:10:10 <monochrom> perhaps some "this requires phd" sentiment
14:10:24 <napping> though I think applicative would like an automagic version which applies to already-fixed functions
14:10:26 <Zontar> napping: do you admit you're poor?
14:10:40 <monochrom> it is a really wrong sentiment. just 400 years ago, only phds knew how to add.
14:11:09 <monochrom> but oh, 400 years later, only phds will know how to add, too :)
14:11:22 <monochrom> s/later/from now/
14:11:30 <kmc> yeah, the rest of us use our calculators
14:11:41 <benmachine> adding is for chumps
14:11:53 <kmc> so, i think it's valid to have the sentiment "researchers are valuable but i am not one"
14:12:00 <pikhq> monochrom: Yeah, but you'll get a Ph.D. when you're 9, if current education inflation is anything to judge by.
14:12:10 <kmc> however, the fact that someone wrote a dissertation relating to X is not evidence that you can't do X
14:12:10 <monochrom> don't be so happy. 500 years from now, only phds know how to use your calculator
14:12:17 <kmc> it probably means someone is thinking more deeply about X than you want to
14:12:26 <kmc> which is exactly the situation here
14:12:54 <pikhq> There's dissertations on just about everything in CS.
14:13:11 <pikhq> This doesn't mean you need to have a Ph.D. to understand how to write a program.
14:13:34 <kmc> yeah
14:13:34 <pesco> how do the solutions in other languages deal with memoizing closed recursive functions?
14:13:41 <kmc> and that's what i mean by anti-intellectualism
14:13:54 <kmc> a researcher used this, so it must be useless and terrible
14:13:57 <napping> kmc: you may be right. Perhaps even someone who cares mainly about practical results, if they wouldn't mind learning new things, would also not mind learning a few impractical research languages
14:13:59 <monochrom> more seriously, you also need to note what year the phd thesis on X was in. there are numerous examples of phd theses inventing X 30 years ago and considered everyone-knows today, including many ideas in daily OOP.
14:14:00 <pikhq> pesco: Kick in the crotch, ask why you're being such a smart-ass? I dunno.
14:14:03 <olsner> gaah, it seems there is something inherently monadic about state, I can't get both Applicative and Alternative out of anyone of s -> f (a,s), s -> (f a, s) or f (s -> (a,s))
14:14:33 <napping> pesco: well, things allowing lots of reflection can sometimes do evil symbol table things
14:14:38 <kmc> olsner, ? every monad is applicative
14:14:42 <kmc> and every monadplus is alternative
14:14:45 <pikhq> olsner: Uh, write the monad instance and the Applicative instance is free...
14:14:52 <olsner> the last one is closest to the behaviour I want, but in order to have state affect the "shape" of the computation I'll need ... join
14:15:06 <monochrom> At the time of invention of OOP, even phds couldn't understand it.
14:15:06 <napping> pesco: rebinding f to the memoization of the function formerly bound to f, in such a way that the runtime recompiles f if the recursive call was compiled it
14:15:07 <olsner> kmc: f is only an applicative here :)
14:15:12 <kmc> oh i see
14:15:16 <olsner> (and alternative)
14:15:22 <kmc> it's an "applicative transformer" or such
14:15:22 <benmachine> yes there is something monadic about state, I think
14:15:31 <Zontar> napping sucks
14:15:36 --- mode: ChanServ set +o monochrom
14:15:46 <benmachine> applicatives don't really need transformers do they, on the grounds that they compose naturally
14:16:11 <Zontar> benmachine sucks
14:16:14 --- mode: monochrom set +b *!*@80-219-8-29.dclient.hispeed.ch
14:16:17 <kmc> hilarious
14:16:19 --- mode: monochrom set -o monochrom
14:16:23 <kmc> what a clever troll
14:16:31 <benmachine> heh
14:16:32 <kmc> hahaha
14:16:35 --- mode: ChanServ set +o monochrom
14:16:39 <kmc> beautiful
14:16:40 --- mode: monochrom set -b *!*@80-219-8-29.dclient.hispeed.ch
14:16:43 --- mode: monochrom set -o monochrom
14:17:14 <kmc> why are people so bad at trolling IRC
14:17:30 <monochrom> because they're anti-intellectual
14:17:37 <benmachine> hmm but I guess monad transformers aren't the same thing as simple type composition
14:17:42 <monochrom> competent trolling requires a PhD
14:17:43 <kmc> :)
14:18:06 <napping> wasn't there a sociology PhD from trolling some superhero MMO?
14:18:07 * benmachine wishes he sucked less
14:18:32 <applicative> do you really want to use a language where you need a PhD to use the IRC?
14:18:34 <kmc> wonder what he did to get K-Lined
14:19:08 <kmc> someone should link to a dissertation about static analysis in C and say "do you really want to use a language where you need a PhD to write programs that don't crash"
14:19:39 <kmc> and by "someone should" i mean it's a waste of time and counter-productive
14:19:45 * ddarius points to ndm's thesis.
14:19:54 <olsner> I'm actually writing it as an "applicative transformer", although I don't need to (but I might as well try and understand what my functors actually do, which feels slightly easier when writing them like thet)
14:20:19 <applicative> napping, I'm baffled by these various results, I mean why sometimes Clojure-memoization occurs, sometimes not.  
14:20:40 <olsner> but I might need to after all, if it turns out to be impossible as mere applicatives
14:20:42 <pesco> napping: so that rules out any system expecting to compile fib without seeing the memo around it.
14:20:59 <napping> applicative: I thought it was easy to see which ensured recursive calls went through the memo and which did not
14:21:10 <napping> and particularly confusing ones?
14:21:39 <applicative> napping, if it occurs, I know why it occurs; if it doesn't, I know why it doesn't.  But I don't know which to expect.  Why does JoeyA's work?
14:22:25 <napping> cause his recursive calls all go to the memoized definition
14:22:26 <olsner> I could write something like getsJoin join f = join (fmap f get) and pretend I don't have a monad :P
14:22:40 <mathijsje> data a :. b = !a :. !b
14:22:48 <mathijsje> can anybody explains what that does? im clueless
14:23:01 <mathijsje> and in special what ! does on a type parameter??
14:23:17 <copumpkin> strictifies it
14:23:23 <benmachine> mathijsje: ! on a type parameter in a data declaration means the data constructor is applied strictly
14:23:24 <napping> oh, ! is a special thing. It goes only on the definition side, and says that component is strict
14:23:28 <copumpkin> it's more or less like (,)
14:24:00 <copumpkin> but you can stick fewer things into it than you can put into (,)
14:24:18 <aavogt> it removes bottoms
14:24:23 <tensorpudding> If you have a type, say type Q a = [F a], and you want to make Q an instance of a class, how do you write it? 
14:24:32 <applicative> napping, I see, sorry, your definition doesn't meet the OP's conditions.
14:24:39 <ddarius> tensorpudding: You don't in Haskell 98.
14:24:54 <kmc> you can use the TypeSynonymInstances extension
14:24:55 <tensorpudding> I have TypeSynonymInstances
14:25:00 <kmc> and FlexibleInstances
14:25:05 <kmc> because the head is not of the form (C a b c)
14:25:24 <kmc> it's equivalent to ¬´instance C [F a]¬ª.  you can't make Q have a separate instance
14:25:29 <kmc> because it's the same type
14:25:33 <mathijsje> im still confused :') whats the subject involving the ! operator called? I will consul the manual.
14:25:43 <mathijsje> *consult
14:25:43 <monochrom> mathijsje: more examples at http://www.vex.net/~trebla/haskell/strict-field.xhtml and http://www.haskell.org/haskellwiki/Newtype
14:25:44 <tensorpudding> It's still complaining after adding FlexibleInstances
14:25:45 <applicative> napping, I wasn't seeing that fib n = fibonacci n -1 + fibonacci n - 2  -- that's not 'naive'
14:25:51 <kmc> tensorpudding, what's the complaint?
14:25:57 <tensorpudding> It says it should have 1 argument, but has been given 0.
14:26:01 <kmc> tensorpudding, oh, you want to make Q an instance, not (Q a)?
14:26:02 <kmc> can't do
14:26:07 <kmc> instances must be fully applied
14:26:11 <kmc> err
14:26:14 <kmc> synonyms must be fully applied
14:26:15 <copumpkin> synonyms
14:26:16 <tensorpudding> Ugh.
14:26:18 <mathijsje> ty monochrom!
14:26:25 <kmc> though, i think there's an extension there too
14:26:26 <copumpkin> yeah, pigworker agrees with you
14:26:27 <tensorpudding> So I have to wrap it in a data wrapper?
14:26:28 <monochrom> it's called "strictness flag"
14:26:38 <copumpkin> there is something that makes synonyms a little more flexible
14:26:45 <copumpkin> but it won't let you do that, I don't think
14:26:55 <kmc> tensorpudding, it's just not possible.  what you're trying to say is ¬´instance C ([] . F)¬ª
14:27:04 <kmc> but there's no type-level composition of constructors
14:27:07 <kmc> without introducing wrappers
14:27:12 <lispy> hey
14:27:12 <lambdabot> lispy: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:27:15 <napping> applicative: um, yeah, I think I said that a while ago
14:27:18 <lispy> ?messages
14:27:18 <lambdabot> kowey said 12h 56m 42s ago: if you upgrade to the current darcs-benchmark (0.1.8.3), and if you pull in the 2.4.98.1 tag (will hopefully do this later), you'll find yourself only running half the
14:27:18 <lambdabot> benchmarks (the -op ones)
14:27:18 <lambdabot> kowey said 12h 51m 54s ago: OK, tags pulled in, so darcs pull, cabal update, cabal install darcs-benchmark and your benchmarking should take 50% of time
14:27:38 <napping> applicative: if you want the fully automatic version it's hard
14:27:45 <kmc> the extension i referred to is LiberalTypeSynonyms
14:27:48 <kmc> but i think it will still not work
14:27:53 <napping> applicative: just like writing a generic typeOf function
14:27:59 <tensorpudding> the problem is that my data type is eight syllables long
14:28:06 <jmcarthur> o_O
14:28:09 <tensorpudding> I should give it a shorter name
14:28:19 <tensorpudding> maybe an acronym
14:28:22 <napping> SuperCalaFragiliciousExpialaDataType?
14:28:29 <kmc> the problem here is not really about synonyms
14:28:38 <kmc> you can't write what you want even disregarding the synonym
14:28:38 <ddarius> If you have something like: type Foo a = Bar a, you can rewrite that as type Foo = Bar and then use it.
14:30:10 <napping> Why don't you pick a shorter name?
14:30:15 <napping> and perhaps import it qualified
14:30:18 <tensorpudding> I'm trying now to use data Q = Q [F]
14:30:21 <tensorpudding> will that work?
14:30:39 <kmc> only if F has kind *
14:30:43 <kmc> which contradicts what you had earlier
14:30:47 <kmc> where you had [F a]
14:30:48 <tensorpudding> rrr
14:30:49 <tensorpudding> er
14:30:53 <tensorpudding> data Q a = Q [F a]
14:30:58 <tensorpudding> what i mean
14:31:05 <benmachine> the template-haskell haddock is a tiny bit wanting.
14:31:06 <tensorpudding> then instance C Q where blah
14:31:10 <monadic_kid> is there an option to generate C in ghc? i'm wondering if I can build ghc's rts as library and generate c from a haskell program without the need of building an unregistered port of ghc
14:31:11 <kmc> seesms fine
14:31:16 <kmc> (you could use newtype too)
14:31:24 <benmachine> that is to say, there isn't any
14:31:28 <kmc> monadic_kid, -fvia-C -keep-hc-files
14:31:29 <tensorpudding> the problem is I wrote about ten functions that will need to be gently wrapped
14:31:31 <Mkman> hey
14:31:40 <ddarius> monadic_kid: You can generate C, but it isn't portable C.
14:31:52 <kmc> unregisterised GHC produces close to portable C
14:32:03 <kmc> it still depends on platform's word size, alignment, etc
14:32:14 <kmc> but not on GCC extensions, register pinning or evil-mangling
14:32:19 <kmc> hi Mkman
14:36:28 <mathijsje> i figured the ! i just optimization, so the line is "data a :. b = a :. b", yet i am still confused about it.
14:36:53 <mathijsje> you can define operators (:.) in the data type?
14:37:04 <mathijsje> or is (:.) predefined? :o
14:37:17 <copumpkin> you can have type operators
14:37:24 <copumpkin> : is "uppercase punctuation"
14:37:29 <ddarius> Strict fields are not just an optimization.
14:38:13 <aristid> isn't a language extension needed for infix-types?
14:38:33 <monadic_kid> does this sound feasible, build ghc's rts as static library on a port of gcc and then link to this when i compile the generated C from ghc?
14:38:38 <monochrom> yes you can define :. in the data type
14:38:55 <applicative> napping, now I get your meaning, I missed something... I was wondering why you seemed to have changed your tune.  This use of MemoCombinators is certainly idiot simple. 
14:39:44 <kmc> monadic_kid, you're cross-compiling Haskell code? for what platform?
14:39:51 <kmc> monadic_kid, i am doing something similar to that for Android
14:40:40 <aristid> kmc: does your android project have a website?
14:40:47 <kmc> not yet
14:40:52 <kmc> it's for iPwn Studios
14:40:57 <kmc> will probably be open-sourced when it's finished
14:41:23 <kmc> monadic_kid, jhc produces portable C code
14:41:29 <ddarius> "A Play on Regular Expressions" has a good abstract.
14:41:59 <monadic_kid> kmc: on Wii homebrew, i've got it working on jhc but I'd like to use ghc because i wanna use the SDL bindings which don't compile jhc.
14:42:03 <aristid> kmc: isn't iPwn studios also doing haskell on the iPhone?
14:42:04 <napping> applicative: so, are you happy with what you can do with thim?
14:42:07 <kmc> aristid, yes
14:42:14 <aristid> kmc: very nice
14:42:14 <kmc> monadic_kid, ok
14:42:37 <kmc> monadic_kid, my strategy was: configure ghc on a ARM Linux machine (emulated), copy the generated header files over
14:42:42 <aristid> kmc: i suppose you are tailoring it towards games, then?
14:42:45 <kmc> configured for an unregisterised via-C build
14:42:50 <kmc> aristid, uh, not in particular
14:42:57 <applicative> napping, yes, it seems pretty convenient.  I wish I had grasped all these facts when I was reading the OP's whining.
14:43:06 <kmc> but the effort of getting packages to work will be directed towards what's needed for the game
14:43:33 <tensorpudding> hmm, another error has me stumped
14:43:37 <kmc> monadic_kid, then you can build a GHC which produces useless binaries for your dev machine, but also produces .hc files which you can compile with the Wii toolchain
14:43:51 <thoughtpolice> interestingly, while working on LHC, we discovered an interesting piece of code JHC produces which makes gcc 4.4 choke with an internal compiler segmentation fault
14:43:57 <tensorpudding> I have a function f (Q []) = error "empty"
14:43:58 <thoughtpolice> i haven't seen one of those in a looong time
14:44:06 <kmc> watch out for any differences between the Wii ABI and the PPC Linux ABI, if you go that route
14:44:08 <napping> applicative: the source of thw whining is actually something else entirely :)
14:44:19 <tensorpudding> which causes a "cannot construct infinite type a = F a" error
14:44:29 <kmc> ARM Android is different from standard ARM Linux in a few small ways, which made me chase segfaults in the GHC RTS for a long time
14:44:32 <ddarius> Machine generated code is a common way to find compiler errors.
14:44:34 <kmc> tricky debugging
14:44:53 <napping> applicative: there's some clever stuff described in a reasearch paper about representing memo tables as lazily evalauted infinite structures
14:45:06 <napping> applicative: and they seem to be alergic to Computer Modern
14:45:10 <ddarius> @google memo tries polytypically
14:45:11 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272
14:45:19 <Guest340> a newbie question: how do I have openFile open file names having unicode filenames on Windows? (ghc 6.12.1) 
14:45:45 <poincare101> I have a question about IO. Here's my code: http://pastebin.org/420928 It gives me a bunch of scary errors, that I really don't understand. What's going  on? it looks pretty simple to me...
14:46:09 <tensorpudding> so Q a = Q [F a], and i've got instance C Q where f (Q []) = error "something", where f :: (C c) => c a -> a
14:46:40 <napping> poincare101: perhaps your indentation is off?
14:46:40 <monadic_kid> kmc: actually i was thinking a similar thing as well, to use wii-linux just get an unregistered ghc port going, the problem is SDK doesn't look like it provides a full POSIX enviroment so i'll probably get issues trying to get this working outside of linux on the wii
14:46:45 <ddarius> poincare101: It probably has to do with your layout being all messed up.
14:46:56 <napping> poincare101: if you write a do block and don't use explicit { ; } you have to line up the statements
14:47:02 <kmc> monadic_kid, yeah.  perhaps you won't be able to build the "unix" package, anyway
14:47:05 <tensorpudding> so I can't figure out why the [] messes things up
14:47:09 <kmc> monadic_kid, but GHC works on some non-posix platforms
14:47:22 <ddarius> Looks like a tab v. space thing.
14:47:26 <tensorpudding> it doesn't mess up for the next line, where we have f (Q [a]) = something
14:47:54 <napping> Guest340: I don't know much about windows. Have you tried using System.Directory.getDirectoryContents to see what the file name comes in as?
14:48:13 <applicative> napping what was the source of the whining -- you just mean the suggestion that he read some Computer Modern?
14:48:39 <tensorpudding> the input has the right type, because [] :: forall a. [a], and therefore Q [] can have type Q [F a]
14:48:58 <napping> applicative: well, somebody seems to want to avoid reading research papers
14:49:03 <tensorpudding> but it still complains about infinite type a = F a
14:49:33 <tensorpudding> anyone know what the issue could be?
14:49:45 <ddarius> tensorpudding: Post the whole function.
14:49:54 <napping> which are often typeset with TeX, in Computer Modern
14:50:01 <napping> joke fail :(
14:50:12 <monochrom> Guest340, napping: I have Œª.txt and getDirectoryContents gives "\206\187.txt". This is on linux.
14:50:22 <Guest340> napping: getDirectoryContents definitely doesn't return it in Unicode. I am taking the filename from getArgs
14:50:27 <tensorpudding> I essentially posted the whole function.
14:50:37 <Guest340> monochrom: it is working on Linux. It isn't working on Windows :(
14:50:41 <monadic_kid> kmc: I think i'm not going to have much luck with ghc, depending on how much the rts depends posix interfaces. jhc is fine but I don't fancy re-writing the sdl bindings because they use extensions (multi-parameter type-classes) that jhc doesn't support
14:50:50 <tensorpudding> Unless you want me to post the class definition, the datatype definition and the instance definition
14:51:12 <napping> Guest340: handling unicode nicely at all is new in 6.12, I think
14:51:25 <ddarius> tensorpudding: Your code is literally: f (Q [a]) = something ?
14:51:27 <Guest340> napping: I have 6.12.1.... 
14:51:28 <napping> Guest340: I'd be suspicious of different encodings around argument parsing and file namess
14:51:37 <tensorpudding> with names changed to protect the innocent
14:52:02 <napping> who uses Haskell on Windows?
14:52:07 <napping> I don't recall
14:52:24 <jmelesky> (crickets)
14:52:27 <Guest340> napping: I need to take a UTF8-encoded argument and open a filename with this name. And I don't know how :( (works without problem on Unix machines, doesn't work on Win)
14:52:32 <applicative> most GHC installations are on windows
14:52:36 <napping> Some people do, I know. Don't recall them by name
14:52:37 <ezyang> @pl (return ()) 
14:52:37 <lambdabot> return ()
14:52:49 <SevenInchBread> okay...
14:52:51 <tensorpudding> findMin :: (PQ q) => q a -> a, data SBQ a = SBQ [SBT a], instance PQ SBQ where findMin (SBQ []) = error "empty queue" would be literally what I have
14:52:52 <napping> Heck, I've got a GHC installation on windows
14:53:07 <napping> but that is mostly used as a calculator
14:53:10 <CakeProphet> so I've got a potential idea for a monad, I think?
14:53:22 <CakeProphet> where bind is the application of an implicit parameter.
14:53:31 <applicative> instance Monad Char where ?
14:53:39 <CakeProphet> ...ha.
14:54:00 <CakeProphet> I don't believe Char could ever be a monad. :P  "Maybe" String?
14:54:47 <napping> Guest340: are you familiar with the windows API?
14:54:51 <tensorpudding> Char doesn't have the right kind to be a Monad
14:55:14 <napping> Guest340: I have to go, but many of us could probably at least figure out which C function openFile ends up calling
14:55:30 <tensorpudding> ddarius: did you see what I put there?
14:56:25 <Guest340> napping: Umm...well, not exactly. I am working mostly on Linux, but I need just one program to read and process a file...unfortunately sometimes with 'internationalized' names... I guess it's something like 'createFile'...
14:56:50 <ddarius> tensorpudding: Yes, and copying to a file and running it works fine for me so, the error is in what you are not showing.
14:56:59 <Guest340> napping: searching through the internet it seemed to me that the handling was done in such a way, that getArgs could be used directly to openFile - but it doesn't work for me
14:57:38 <tensorpudding> okay, I'll pastebin the whole kit
14:58:57 <tensorpudding> stupid hpaste.el
15:01:16 <ddarius> tensorpudding: Part of the problem, likely, is that your type for findMin says that it can do what it does without knowing anything about a.
15:01:38 <tensorpudding> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28247#a28247
15:02:06 <Guest340> napping: yep, it seems to me that ghc is set to different encoding
15:06:22 <ddarius> tensorpudding: In the third clause of findMin you are calling findMin on ts which is a [SBT a] which it will view as looking for an instance of PriorityQueue [] and so findMin ts :: SBT a which you then return for a.  So you should be getting a = SBT a
15:07:20 <kmc> monadic_kid, the RTS itself doesn't depend much on posix.  it works on Windows too
15:07:29 <kmc> monadic_kid, but the "unix" package does
15:07:37 <kmc> and you may need to write a similar "wii" package
15:07:49 <kmc> in order to provide stuff needed by standard modules like System.IO
15:08:10 <tensorpudding> ddarius: so the problem is not on line 76, but on line 78?
15:08:50 <ddarius> 78 and 79, but those are all part of the findMin definition starting on line 76.
15:08:53 <tensorpudding> huh, that fixed it.
15:09:07 <tensorpudding> I was too fixated on 76, where the error appeared
15:09:18 <tensorpudding> according to the error message GHC gave
15:21:35 <McManiaC> how do you use "* -> *" ?
15:22:00 <McManiaC> in type constraints/forall/etc?
15:22:33 <copumpkin> huh?
15:23:01 <McManiaC> foo :: forall a. (a :: * -> *) => a
15:23:04 <McManiaC> something like this
15:23:05 <McManiaC> dunno
15:23:06 <McManiaC> :D
15:23:57 <copumpkin> you can't have that
15:24:08 <copumpkin> * -> * are type constructors or functions
15:24:11 <kmc> ¬´* -> *¬ª is a kind, not a type
15:24:20 <kmc> kinds classify types and type constructors just as types classify values
15:24:35 <copumpkin> what classifies kinds? :)
15:24:38 <kmc> you can say:  forall (m :: * -> *). a -> m a
15:24:42 <kmc> m is a type
15:24:43 <ddarius> McManiaC: You almost never need to explicitly write out kinds.
15:24:47 <kmc> and you require it has kind * -> *
15:24:52 <ddarius> Its not even possible in Haskell 98.
15:26:06 <ddarius> copumpkin: They don't need to be classified (except trivially, but then where do you stop?)  "Sort" is the next word that would be used.  "Sorts" is the most common general term.
15:26:17 <CakeProphet> I think I figured out what my implicit-application monad is called. Identity. :)
15:26:25 <copumpkin> we need universe polymorphism in haskell!
15:26:37 <copumpkin> the simply kinded lambda calculus
15:27:05 <ddarius> copumpkin: I want polymorphically kinded lambda calculus.
15:27:09 <applicative> CakeProphet, well its certain the best monad. 
15:27:15 <copumpkin> ooh
15:27:17 <BMeph> copumpkin: You want to be sort of kind to your types? ;√æ
15:27:31 <CakeProphet> copumpkin:  so more than one kind and more than one kind constructor?
15:27:55 <CakeProphet> copumpkin:  how do you feel about kindclasses? :)
15:27:56 <copumpkin> CakeProphet: definitely! type-level programming is essentially untyped, sadly
15:32:33 <CakeProphet> are term rewriting languages mostly referentially transparent? It would benefit such a language a great deal.
15:32:43 <CakeProphet> term-rewriting similar to RULE pragmas in Haskell.
15:33:42 <ddarius> I think a lot of term rewriting languages don't have a place to put "statements"
15:35:22 <chrisdone> does PEG count as a term rewriting language?
15:42:15 <Arnar> @hoogle Either a a -> a
15:42:16 <lambdabot> Data.Either rights :: [Either a b] -> [b]
15:42:16 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
15:42:16 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
15:42:35 <jsnikeris> hi all.  I'm trying to solve a problem that seems similar to the subset sum problem.  I've got a bunch of things that have values.  I want to grab the subset of those things that is closest to a certain value.  Actually, closest but greater than that value.  Anyone know what the non-naieve strategy for solving this is?
15:43:14 <jsnikeris> when you sum up the values for each thing in the subset, it needs to be close to some given value
15:43:16 <jsnikeris> that's what I mean
15:44:06 <Arnar> jsnikeris: this sounds more like the knapsack problem
15:44:09 <Arnar> 22:41 < lambdabot> Data.Either rights :: [Either a b] -> [b]
15:44:20 <Arnar> sorry, wrong clipboard
15:44:31 <Arnar> http://en.wikipedia.org/wiki/Knapsack_problem
15:44:45 <jsnikeris> well there's no weight we're trying to stay under
15:45:27 <jsnikeris> I've got a set of numbers {1, 4, 7, 9, 9} and I want the combination that is closest to 10
15:45:32 <jsnikeris> so I pick 9 and 1
15:45:37 <jsnikeris> that's the closest
15:45:44 <jsnikeris> but what for a huge set
15:45:48 <jsnikeris> with widely varying numbers
15:46:17 <Arnar> set the weight to the same as the value
15:46:29 <Arnar> that way you get as close to your preferred number from below
15:46:32 <jsnikeris> some sets you won't have a subset whose value is exactly your number
15:47:08 <Arnar> as close as possible I meant
15:49:25 <jsnikeris> so I'm looking at the 0-1 knapsack problem, right?
15:49:34 <Arnar> jsnikeris: yes, precisely
15:50:20 <jsnikeris> would my above example still be 0-1 knapsack even though there are two items with value 9 in the set?
15:51:12 <Arnar> if your list (your example indicates that you don't have a set, but a list/multiset) of numbers is a_i
15:51:21 <Arnar> then set v_i = w_i = a_i
15:51:36 <Arnar> and run 0-1 knapsack
15:51:57 <Arnar> this will give you the sublist with the largest sum but not exceeding your limit
15:52:21 <Arnar> and just run it again with negative numbers to get the smallest sum not below your limit
15:52:25 <Arnar> and pick the one closer to the limmit
15:52:34 <jsnikeris> it's gotta be over the limit
15:52:43 <Arnar> ok, then just run it once with negative numbers
15:53:02 <Arnar> v_i = w_i = -a_i
15:53:12 <Arnar> and reverse the sign of W (the limit)
15:54:14 <Phyx-> Hi, I'm calling readPackageDescription (Cabal) but it doesn't seem to populate any information on libraries or executables, only the top levels
15:55:13 <dcoutts_> Phyx-: you get back a GenericPackageDescription, the PackageDescription inside that only contains the meta info, the info on the libs and exes is in the GenericPackageDescription.
15:55:48 <dcoutts_> Phyx-: you need to either look at the GenericPackageDescription directly, or flatten or finalise it to get the info about libs/exes
15:55:50 <jsnikeris> I don't understand how setting the weight to be the same as the value negates the weight side of the 0-1 knapsack problem
15:55:59 <dcoutts_> Phyx-: the choice depends on what you're trying to do
15:56:03 <Phyx-> ah
15:56:50 <dcoutts_> Phyx-: the difference between GenericPackageDescription and PackageDescription is the conditionals in a .cabal file, a PackageDescription is what you get after resolving all the conditionals.
15:57:11 <Phyx-> dcoutts_: I ultimately need *all* information defined in a Cabal file, but for now since i'm doing things incrementally, I just need to know the files that are in the .cabal files and the associated type (library, exe)
15:57:19 <Arnar> jsnikeris: it doesn't negate it.. it just says the quantity you are maximising is the same as the one that is bound by the limit
15:58:08 <dcoutts_> Phyx-: the files? you mean the components, the lib or exe, or do you really mean files, like .hs, .hsc files?
15:58:08 <Phyx-> dcoutts_: so I should be looking at condLibrary  and condExecutables?
15:58:25 <Arnar> jsnikeris: basically your version of the knapsack problem is "pick a subset of items as light as possible but not under the weight limit W"
15:58:34 <dcoutts_> Phyx-: if you just want to know the lib/exe names then use flatten to get a PackageDescription
15:58:40 <Phyx-> dcoutts_: I really mean the files, e.g. a Libary has file Foo.hs Bar\Bar.hs etc
15:58:48 <jsnikeris> arnar: I'd agree with that, yes
15:59:08 <dcoutts_> Phyx-: the .cabal does not specify the files, just module names, you have to search the package directories to find corresponding source files.
15:59:22 <dcoutts_> Phyx-: and in general you have to do dependency/import chasing
15:59:27 <Phyx-> dcoutts_: doesn't toFilePath :: ModuleName -> FilePath do taht?
15:59:30 <dcoutts_> Phyx-: and run pre-processors
15:59:50 <dcoutts_> Phyx-: that'll work for libs but we do not enforce that exes list all modules.
16:00:18 <dcoutts_> Phyx-: and that function does not tell you if it's a .hs file or a .chs or .y etc file.
16:00:29 <dcoutts_> Phyx-: it just gives the stem of the file name
16:00:54 <Phyx-> dcoutts_: w=oh, that might be a problem... What I'm trying to do is get all the files relating to a "project" so I can populate the IDE with them
16:01:37 <Phyx-> I could ultimately just get the main entry point for exes, and do a dependency trace with the GHC-API, that should work right?
16:01:47 <dcoutts_> Phyx-: ah ok then you're really in the situation of implementing half a build system
16:01:57 <pchiusano> question, could the typeclass Pure f where pure :: f a -> a be considered a functor between two categories, and if so, what are those categories?
16:02:09 <pchiusano> oops, meant pure :: a -> f a
16:02:15 <dcoutts_> Phyx-: well currently cabal does the preprocessing and then call ghc --make
16:02:50 <dcoutts_> Phyx-: so the equivalent in an IDE would be to call Cabal lib functions to do the preprocessing and then use the ghc api, in the similar way to how cabal calls ghc --make.
16:03:49 <Phyx-> dcoutts_: right, ok, cool. I completely forgot about that part :)
16:04:16 <dcoutts_> Phyx-: you'll notice that the Cabal lib is not that well designed for the IDE use case.
16:04:33 <ezyang> When I use ghci's :m +Some.Module; what file does ghci load up? 
16:05:01 <Phyx-> dcoutts_: oh, I thought that the original Visual Haskell drove some design choices in Cabal. and doesn't Leksah use it as well as the project structure?
16:05:18 <ezyang> oh, looks like the .hi file. 
16:05:40 <dcoutts_> Phyx-: yeah, I'm not sure how much each use the Cabal lib for the build steps, they both use the Cabal lib for handling .cabal files.
16:06:21 <Phyx-> dcoutts_: ah but, I don't really need cabal to build for me (yet) I wanted to grab parts of cabal-install to do that
16:06:41 <dcoutts_> Phyx-: cabal-install mainly just calls the Cabal lib to build
16:06:42 <Phyx-> I do however need the files, extra include dirs etc for calls I make directly to GHC, for typechecking etc
16:07:02 <dcoutts_> Phyx-: it's mainly the pre-processing steps I was thinking of
16:07:11 <dcoutts_> Phyx-: since the ghc api does not help you with that
16:07:48 <Phyx-> dcoutts_: you mean resolving of conditonals? I don't actually want it to say, run hsc2hs on files, I want the original hsc file
16:08:17 <dcoutts_> Phyx-: I did mean preprocessors like hsc2hs
16:08:31 <dcoutts_> Phyx-: since of course the ghc api cannot do anything with .hsc files
16:09:26 * hackagebot test-framework-quickcheck 0.2.7 - QuickCheck support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck-0.2.7 (MaxBolingbroke)
16:09:32 <Phyx-> dcoutts_: Ah, that's true. I'll make a note of that as well, that's another thing I didn't think of :)
16:10:14 <dcoutts_> Phyx-: so that's my suggestion, use the Cabal lib to run the pre-processing steps and then collect the .hs files and pass them to the ghc api
16:10:51 <pokoko222> Are there epfl guys here?
16:11:59 <Phyx-> dcoutts_: yes that does indeed sound like it's the way to go. Can you also maybe point me to the module that does preprocessing? Cabal is rather large, lol
16:12:11 <Phyx-> Ah, I assume stribution.Simple.PreProcess
16:12:17 <dcoutts_> right
16:12:22 <Phyx-> Distribution.Simple.PreProcess*
16:12:32 <dcoutts_> Phyx-: there's a guide to the source code on the Cabal/hackage trac
16:14:01 <Phyx-> dcoutts_: nice, thanks! I'll get to work implementing it right away :)
16:16:54 <Phyx-> dcoutts_: does Cabal also keep trac of what generates what? that's seems a bit hard but I ask since the dependency trace from ghc will always give back .hs files, but if the source are .hsc files for instance, I need those files. So should I just keep a local state and if I see a Foo.hs and in the same place a Foo.hsc just assume Foo was generated?
16:16:59 <Phyx-> track*
16:17:45 <dcoutts_> Phyx-: it pre-processes files into a directory structure under dist/, when it call ghc it sticks that directory on the search path first.
16:17:46 <monoidal> here's why monads are monoids in category of endofunctors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28248
16:17:58 <monoidal> i'm  searching for other examples :-)
16:18:17 <dcoutts_> Phyx-: when deciding if it needs to rerun the preprocessor it looks in that target dir for the .hs file.
16:18:34 <Arnar> jsnikeris: still here?
16:18:44 <Arnar> jsnikeris: a brute force solution:
16:18:50 <Arnar> > let powerset = filterM (const [False, True]); cmpsums = curry $  sum *** sum >>> uncurry compare; pack size items = minimumBy cmpsums [ subset | subset <- powerset items, sum subset >= size] in pack 10 [1,4,7,9,9]
16:18:51 <lambdabot>   [1,9]
16:18:59 <dcoutts_> Phyx-: so any .hs file you find under the dist/build/blah will be one that was generated by the preprocessing step
16:19:25 <Arnar> others: is there something more elegant than cmpsums = curry $ sum *** sums >>> uncurry compare ?
16:19:36 <Phyx-> dcoutts_: Ah, that's handy, thanks!
16:21:07 <Arnar> @type compareBy
16:21:07 <lambdabot> Not in scope: `compareBy'
16:21:15 <Arnar> @hoogle compareBy
16:21:16 <lambdabot> No results found
16:22:57 <Arnar> let powerset = filterM (const [True, False]); pack size items = maximumBy (comparing sum) [ subset | subset <- powerset items, sum items <= size] in pack [1,4,7,9,9] 10
16:23:07 <Arnar> > let powerset = filterM (const [True, False]); pack size items = maximumBy (comparing sum) [ subset | subset <- powerset items, sum items <= size] in pack [1,4,7,9,9] 10
16:23:08 <lambdabot>   No instances for (GHC.Num.Num [t], GHC.Num.Num [[t]])
16:23:08 <lambdabot>    arising from a use...
16:26:32 <jsnikeris> arnar: I don't know haskell unfortunately
16:26:51 <jsnikeris> It looks like I need to memoize the solutions, no?
16:27:10 <Arnar> jsnikeris: the above is brute force, it will try out every subset
16:35:14 <pickles> @quote hoogle
16:35:14 <lambdabot> No quotes match. Just what do you think you're doing Dave?
16:35:25 <pickles> @quote lambdabot
16:35:25 <lambdabot> lambdabot says: Plugin `quote' failed with: getRandItem: empty list
16:35:50 <dankna> @quote dankna
16:35:50 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
16:35:54 <dankna> aw :D
16:36:03 <pickles> hehe
16:36:26 <pickles> @quote pickles
16:36:26 <lambdabot> No quotes match. :(
16:36:44 <dankna> you get a sympathetic emoticon and I get an insult, haha
16:36:54 <pickles> heheh, i noticed that too
16:36:58 <pickles> was pondering why...
16:37:15 <dankna> it's cause computers don't like me.  they do what I say, but they don't like me.
16:37:23 <pickles> ah
16:37:34 <pickles> that must mean they like me, because they don't always do what i say
16:37:39 <dankna> quite so
16:37:52 <dankna> actually the source is available, you can read the full list of responses.  it's fairly amusing.  somebody had fun writing it all.
16:38:05 <pickles> neat, might have to do that sometime
16:38:19 <pickles> puts me in mind of matlab's "why" command
16:38:25 <dankna> not familiar with that
16:38:35 <pickles> basically GIGO
16:38:40 * dankna nods
16:38:55 <Phyx-> dcoutts_: btw, the SouceGuide points to broken links, the "docs" links are broken 
16:39:47 <pickles> dankna: if i weren't booted in linux and had matlab installed, i'd run it a few times for ya
16:39:53 <dankna> cool
16:39:55 <dankna> no worries
16:40:06 <pickles> hm... wonder if there's a #matlab with a bot running...
16:40:24 <dankna> my favorite compiler errors have to be the ones from Apple's old MPW C compiler
16:40:34 <dankna> "Too many errors on one line (make fewer)"
16:40:39 <dankna> "We already did this function"
16:40:41 <dankna> and so on
16:40:55 <pickles> hehe
16:41:27 <pickles> "didn't you make that mistake last time"
16:41:34 <dankna> cute
16:41:45 <dankna> "This label is the target of a goto from outside of the block containing this label AND this block has an automatic variable with an initializer AND your window wasn't wide enough to read this whole error message"
16:41:45 <pickles> (not an actual, just musing)
16:41:48 * dankna nods
16:42:25 <pickles> lol
16:42:29 <dankna> yeah
16:43:03 <pickles> yeah, >why  is along the lines of: "because the very smart, very bald engineer told me to"
16:43:09 <dankna> hah, okay
16:43:12 <dankna> that's cool too
16:43:22 <dankna> I liked SHRDLU's why - that's an old old AI program
16:43:26 <dankna> it gave actual answers!
16:43:33 <pickles> nice
16:43:38 <pickles> haven't heard of it
16:43:49 <dankna> "Why did you put the blue block on top of the red block?"  "To build a tower two blocks high."  "Why did you do that?"  "Because you told me to."
16:43:51 <dankna> or the other path
16:44:01 <pickles> was it one of those things that would take sentences and rearrange them into other questions like elisa?
16:44:14 <pickles> ah
16:44:19 <dankna> "Why did you put the blue block in the box?"  [asking about something it didn't do, to try to trick it]  "I cannot explain a nonexistent event."
16:44:27 <dankna> nope.  it's from the same era, but it was a more serious attempt
16:44:30 <pickles> oho nice
16:44:34 <pickles> ah
16:44:42 <dankna> the author eventually decided that the approach is too limited
16:44:49 <pickles> mm
16:44:51 <dankna> although I can't help but feel that it has potential
16:45:02 <pickles> indeed, it does seem so
16:47:21 <pickles> this must be the quietest i've ever seen this channel
16:47:42 <monochrom> ssshhh
16:47:59 <zachk> @slap 
16:47:59 <lambdabot> why on earth would I slap ?
16:48:06 <zachk> @puke
16:48:06 <lambdabot> Unknown command, try @list
16:48:10 <zachk> @list
16:48:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:48:45 <pickles> monochrom: *_sorry_*
16:49:06 * pickles has decided that *_ ... _* should mean a whisper
16:49:12 <aidalgol> .foldr ++ ["foo","bar","goo"]
16:49:15 <zachk> -_- 
16:49:16 <aidalgol> > foldr ++ ["foo","bar","goo"]
16:49:17 <lambdabot>   Couldn't match expected type `(a -> b -> b) -> b -> [a] -> b'
16:49:17 <aidalgol>  
16:49:17 <lambdabot>         again...
16:49:31 <aidalgol> Why doesn't that work?
16:49:34 <c_wraith> (++)
16:49:42 <aidalgol> > foldr (++) ["foo","bar","goo"]
16:49:43 <c_wraith> it's trying to make foldr a monoid
16:49:43 <lambdabot>   Overlapping instances for GHC.Show.Show
16:49:43 <lambdabot>                              ([[[GH...
16:49:43 <aidalgol>  
16:49:51 <Zao> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28257#a28257
16:49:53 <zachk> > foldr (++) [] . words $ "foo bar goo" 
16:49:53 <lambdabot>   "foobargoo"
16:50:06 <Zao> Is there any fancy shorthand I could use instead of the icky body of foo?
16:50:06 <aidalgol> c_wraith: A what?
16:50:07 <pickles> aidalgol: you need a start state for foldr to mess w/
16:50:29 <c_wraith> The error messages are less useful than normal because lambdabot uses some non-standard definitions
16:50:32 <ddarius> Zao: m >>= return . f = fmap f m
16:50:45 <c_wraith> :t (++) -- this is not the normal type for (++)
16:50:46 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:50:47 <ddarius> Zao: But it looks like you want modify.
16:50:50 <ddarius> :t modify
16:50:50 <Zao> I was looking at liftM and friends, but the signatures are subtly wrong.
16:50:50 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
16:50:53 <aidalgol> Why does it need parentheses around it?
16:51:14 <pickles> > foldr (++) "" ["foo","bar","goo"]
16:51:15 <lambdabot>   "foobargoo"
16:51:15 <zachk> you put parentheses around operators to make them not get evaluated 
16:51:17 <Zao> ddarius: I knew there was such a function somewhere, but I couldn't find it.
16:51:22 <c_wraith> aidalgol, (++) makes it parse as a regular function, rather than an infix function.
16:51:36 <zachk> c_wraith's answer is better
16:51:43 <poucet> zachk: you mean, correct =)
16:51:52 <aidalgol> c_wraith: Ah.  That makes sense.
16:52:17 <Zao> Much like how `` infixifies a regular function, but the other way around :)
16:52:30 <poucet> Yep, purely parse-time techniques =)
16:53:22 <Zao> Ah, modify was in .Class
16:54:33 <aidalgol> Is there a way to make this any briefer? > pythagoreanTriads n = [ (x,y,z) | x <- [1..n], y <- [1..n], z <- [1..n], x^2 + y^2 == z^2 ]
16:55:04 <ezyang> :t (,,) 
16:55:04 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
16:55:22 <ezyang> So, uh 
16:55:51 <aidalgol> It seems a bit silly not to be able to say that x,y,z are all <- [1..n] in the same statement.
16:56:03 <ezyang> > liftM3 (,,) [1..20] [1..20] [1..20] 
16:56:03 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
16:56:16 <ddarius> :t \n -> filter (\(x,y,z) -> x*x + y*y = z*z) $ liftM3 (liftM3 (,,)) [1..n]
16:56:17 <lambdabot> parse error on input `='
16:56:18 <ezyang> aidalgol: Well, you can always do a let ... in ... 
16:56:23 <ddarius> :t \n -> filter (\(x,y,z) -> x*x + y*y == z*z) $ liftM3 (liftM3 (,,)) [1..n]
16:56:24 <lambdabot>     Couldn't match expected type `[(t, t, t)]'
16:56:24 <lambdabot>            against inferred type `[m a2] -> [m a3] -> [m (a1, a2, a3)]'
16:56:24 <lambdabot>     In the second argument of `($)', namely
16:56:39 <c_wraith> you need like a join join in there.
16:56:40 <aidalgol> ezyang: Even that's a bit repetitive.
16:56:44 <c_wraith> err, join . join
16:56:48 <ezyang> > let ls = [1..20] in liftM3 (,,) ls ls ls 
16:56:49 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
16:56:58 <copumpkin> aidalgol: how often do you want to pass the same argument to a function thrice?
16:57:09 <ddarius> Anyway, the original list comprehension is pretty compact already.
16:57:20 <copumpkin> realistically, no one would ever generate pythagorean triples that way
16:57:28 <c_wraith> > (join . join $ liftM3 (,,)) [1..5]
16:57:29 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,2,1),(1,2,2),(1,2,3),(1,2,4),(1...
16:57:37 <aidalgol> Good point.
16:57:45 <aidalgol> (It's for a tutorial.)
16:58:07 <ddarius> > length "[ (x,y,z) | let ns = [1..n], x <- ns, y <- ns, z <- ns, x^2 + y^2 == z^2 ]"
16:58:08 <lambdabot>   74
16:58:10 <ddarius> > length "[ (x,y,z) | x <- [1..n], y <- [1..n], z <- [1..n], x^2 + y^2 == z^2 ]"
16:58:11 <lambdabot>   69
16:59:37 <ddarius> > let n = 10 in liftM2 (\x y -> (x, y, x*x + y*y)) [1..n] [1..n]
16:59:38 <lambdabot>   [(1,1,2),(1,2,5),(1,3,10),(1,4,17),(1,5,26),(1,6,37),(1,7,50),(1,8,65),(1,9...
16:59:39 <c_wraith> I've clearly spent too much time in here if I can tell what "join . join" does on the ((->) a) Monad without thinking.
17:00:02 <Arnar> ddarius: forgetting the sqr root
17:00:22 <ddarius> c_wraith: And runCont . return is what?
17:00:36 <c_wraith> Dunno.  I've avoided Cont and ContT
17:00:41 <c_wraith> ...  So far. :)
17:00:50 <ddarius> @. hoogle type runCont . return
17:00:51 <lambdabot> Parse error:
17:00:51 <lambdabot>   --count=20 "forall r a. a -> (a -> r) -> r
17:00:51 <lambdabot> "
17:00:57 <ddarius> :t flip ($)
17:00:58 <lambdabot> forall a b. a -> (a -> b) -> b
17:01:03 <ezyang> c_wraith: More time in the #haskell clappers for you mate! 
17:01:25 <ezyang> :t runCont . return 
17:01:26 <lambdabot> forall r a. a -> (a -> r) -> r
17:01:35 <ezyang> iirc, it's not that interesting 
17:01:42 <ezyang> > (runCont . return) 3 (+2) 
17:01:43 <lambdabot>   5
17:02:04 <ezyang> Pop quiz: what does runReader . return do? 
17:02:18 <monoidal> const
17:02:22 <ezyang> correct! 
17:02:39 <ddarius> :t runReader . asks
17:02:40 <lambdabot> forall r a. (r -> a) -> r -> a
17:02:46 <ddarius> :t runReader ask
17:02:47 <lambdabot> forall r. r -> r
17:02:52 <ddarius> ask = asks = id
17:03:35 <monoidal> and what does filterM (\x -> ask ($x)) does?
17:03:39 <ezyang> runWriter and runState will do the same thing too, iirc 
17:03:47 <ezyang> :t filterM 
17:03:48 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:04:31 <ddarius> :t filterM (runCont . return)
17:04:32 <lambdabot> forall a. [a] -> (a -> Bool) -> [a]
17:04:39 <zachk> @spell unicron 
17:04:42 <ddarius> :t filterM (\x -> ask ($x))
17:04:43 <lambdabot> forall a. [a] -> (a -> Bool) -> [a]
17:04:55 <ezyang> I was about to say it looked like a normal filter 
17:04:59 <ezyang> but something seems off 
17:05:06 <monoidal> it is, flipped
17:05:08 <aristid> @pl \x -> ask ($x)
17:05:08 <lambdabot> ask . flip id
17:05:21 <ddarius> ask = id as I said, so \x -> ask ($x) is just \x -> ($ x) is just flip ($)
17:05:21 <monoidal> the environment is used to ask if the element is filtered
17:05:35 <ezyang> > runReader (filterM (\x -> ask ($x))) (==2) [1,2,3] 
17:05:36 <lambdabot>   Couldn't match expected type `Control.Monad.Reader.Reader r a'
17:05:36 <lambdabot>         agai...
17:06:04 <ezyang> ahai 
17:06:05 <monoidal> > runReader (filterM (\x -> ($x))) (==2) [1,2,3]
17:06:06 <lambdabot>   Couldn't match expected type `Control.Monad.Reader.Reader r a'
17:06:06 <lambdabot>         agai...
17:06:23 <monoidal> > runReader (filterM (\x -> ($x))) [1,2,3] (==2)
17:06:24 <lambdabot>   Couldn't match expected type `Control.Monad.Reader.Reader r a'
17:06:24 <lambdabot>         agai...
17:06:42 <ezyang> :t runReader (filterM (\x -> ($x))) 
17:06:43 <lambdabot>     Couldn't match expected type `Reader r a'
17:06:43 <lambdabot>            against inferred type `[a1] -> (a1 -> Bool) -> [a1]'
17:06:43 <lambdabot>     In the first argument of `runReader', namely
17:06:45 <monoidal> > filterM (\x -> ($x)) [1,2,3] (==2)
17:06:46 <lambdabot>   [2]
17:06:48 <BMeph> @tyre runReader . filterM
17:06:49 <lambdabot>     Couldn't match expected type `Reader r a'
17:06:49 <lambdabot>            against inferred type `[a1] -> m [a1]'
17:06:49 <lambdabot>     Probable cause: `filterM' is applied to too few arguments
17:06:50 <Phyx-> > id
17:06:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:06:51 <lambdabot>    arising from a use of `...
17:06:55 <Phyx-> hmm still connected
17:07:05 <BMeph> @tyre (runReader .). filterM
17:07:06 <lambdabot> forall r a. (a -> Reader r Bool) -> [a] -> r -> [a]
17:07:08 <Phyx-> seems it only kills my udp
17:07:16 <ezyang> mm, good catch. 
17:07:20 <benmachine> aw, I managed to write a Data.Generics implementation of TH's lift, only to find someone else wrote a TH implementation (which as a concept makes a lot more sense)
17:07:31 <benmachine> and further to find that I don't actually know what lift does anyway
17:08:11 <aidalgol> > map (+3) [1..10]
17:08:12 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
17:08:30 <ddarius> lift turns a Haskell value into its TH representation.
17:08:35 <PetRat> Can someone explain how data type T is used in this module? It is strange to me. It's like they are trying to make everything a T. I'm not sure whether it is used recursively as well to represent lists of items. http://hackage.haskell.org/packages/archive/midi/0.1.5.1/doc/html/Sound-MIDI-File.html
17:08:51 <PetRat> And why make everything a T?
17:09:17 <benmachine> ddarius: is it at all related to the [| thing |] syntaz?
17:09:19 <benmachine> *syntax
17:09:21 <ezyang> It's a Henning-ism 
17:09:43 <ddarius> ezyang: No, there is just one type named T.  It's not that.
17:09:52 <monoidal> PetRat: it is used to force qualified imports. people don't like it
17:10:00 <ezyang> ddarius: I thought that was what Henning liked doing? 
17:10:09 <copumpkin> he does
17:10:14 <copumpkin> but this one has other names too
17:10:15 <ddarius> ezyang: Okay, well, in that particular module it's not -just- that.
17:10:23 <ddarius> But yes, it's a crazy thing he does.
17:10:23 <ezyang> fair enough :-) 
17:10:40 <PetRat> What does the line "type Track = T ElapsedTime T" mean? It seems like T is used as a parameterized type constructor in that line, but I don't see it defined as having parameters.
17:10:55 <copumpkin> PetRat: the issue is that the Ts you see may not all be the T in that page
17:11:06 <monoidal> PetRat: the first one is a value, the second is a type
17:11:06 <ddarius> PetRat: T is a data constructor in the first occurrence.
17:11:17 <copumpkin> like in showEvent, the T there is not the one on that page
17:11:22 <ezyang> type Track = EventList.T ElapsedTime Event.T 
17:11:26 <ezyang> check the source. 
17:11:29 <ddarius> benmachine: Not especially except that it is TH code.
17:11:30 <ezyang> This is a major problem with Haddock. 
17:11:45 <monoidal> PetRat: as in data X = F F, the first F is a constructor, and second is a type.
17:11:48 <copumpkin> usually minor, except with bytestrings and HT's stuff
17:12:06 <ezyang> IT lies. 
17:12:15 <ezyang> Maybe I should hack up a fix for this... 
17:12:21 <tolkad> Is it possible to change program behavior based on available RAM?
17:12:28 <PetRat> Okay I see what you are saying. Is this because he has one data type associated with each module, and he always calls it T, and you always use a qualified import?
17:12:45 <copumpkin> that's the idea
17:12:45 <ddarius> ezyang: Go for it.  I don't think it is quite as easy as you perhaps hope though.  It shouldn't be too hard to at least do better, on the other hand.
17:13:11 <ezyang> ddarius: Yeah, always a problem :_) 
17:13:11 <ddarius> PetRat: As copumpkin said, that's the idea, but it is mostly because he's crazy.
17:13:14 <PetRat> I see that it is clear in the code, but not in Haddock.
17:13:20 <ezyang> Is there a Haddock bug filed for it, at least? 
17:13:22 <tolkad> like testing for malloc returning null in C
17:13:27 <ddarius> ezyang: Probably.
17:13:42 <copumpkin> tolkad: anything is possible, but I'd guess it's pretty uncommon
17:14:00 <copumpkin> most programs will check if it's null and then bail user-friendlily
17:14:10 <ddarius> tolkad: I believe there is an asynchronous exception thrown for an out of memory condition (in GHC) but it is very unlikely you'll be able to recover from it.
17:14:14 <copumpkin> instead of passing a null around for a while and then crashing later
17:14:21 <aidalgol> Don't you just love it when you find a better way--I mean mostly objectively better, not just something that *you* *personally* prefer--to do something than your professor?
17:14:24 <PetRat> Oh, and he always calls the constructor Cons?
17:14:33 <ddarius> aidalgol: No.
17:14:36 <tolkad> ddarius: well then what about preventing it? is there any way to know how much RAM is available in standard haskell?
17:14:36 <ezyang> huh, I don't even know where Haddock bug tracker is 
17:14:53 <ezyang> found it 
17:14:55 <copumpkin> tolkad: that's necessarily FFI- and platform-dependent
17:15:15 <copumpkin> and it's hard to even define what it means for ram to be "available" sometimes
17:15:25 <ddarius> tolkad: There is probably a function somewhere or you could FFI something, but it wouldn't be helpful.  You don't know how big things are and, at least for an FFI call, it wouldn't reflect how much space was available in the heap.
17:15:27 <tolkad> copumpkin: I'm pretty sure all platforms have some sort of memory and a limited amount of it
17:15:47 <ezyang> http://trac.haskell.org/haddock/ticket/22 
17:15:52 <ezyang> http://trac.haskell.org/haddock/ticket/16 
17:15:56 <Philippa> tolkad: yeah, but does the terabyte of potentially available virtual memory count?
17:15:58 <copumpkin> tolkad: yes, but as a recent debacle about a windows utility showed, not everyone agrees about what available means :P
17:16:13 <ezyang> Henning Thielmann is, understandably, CC'ed to the bug :^) 
17:16:35 <Philippa> and you don't /really/ know how much is available until you've run a GC pass, either
17:16:35 <benmachine> hmm, this is odd: when I load a file that does "import X as Y" in ghci, I can't do :i Type, I have to do :i Y.Type
17:16:43 <tolkad> copumpkin: by available I mean my program wont crash if I try to use it
17:16:51 <PetRat> Oh, and he always calls the constructor Cons?
17:16:53 <benmachine> oh wait, it might be ambiguity
17:17:01 <zachk> thats cause you imported it with a qualified name 
17:17:07 <tolkad> copumpkin: obviously there is a race condition inherent to that, I hope haskell provides a way to avoid such a race condition
17:17:15 <ezyang> I thought you needed to add the qualified keyword? 
17:17:16 <benmachine> zachk: but I didn't specify qualified, so I imported it unqialified as well
17:17:27 <copumpkin> most of the time people aren't sitting on the boundary of out of memory errors
17:17:27 <ezyang> anyway, it'll conflict if Type exists already 
17:17:28 * zachk is now confused 
17:17:30 <copumpkin> so I'm not sure it does
17:17:49 <benmachine> import qualified Module as M -- imports M.whatever
17:17:57 <benmachine> import Module as M -- imports whatever *and* M.whatever
17:18:32 <benmachine> and yeah, seems like :info gives surprising results for names that are ambiguous
17:18:46 <monochrom> how surprising?
17:19:18 * copumpkin goes to sleep
17:19:22 <benmachine> monochrom: it says, data constructor not in scope
17:19:26 <benmachine> instead of, ambiguous name
17:21:30 <monochrom> Like this? "module B where import Data.Complex", then ":load B.hs" and ":info :+"? works for me.
17:21:50 <monochrom> oh, "as"
17:22:04 <benmachine> hm?
17:22:11 <benmachine> why would that be ambiguous
17:22:18 <monochrom> "module B where import Data.Complex as C", then ":load B.hs" and ":info :+" still works for me
17:22:25 <benmachine> why wouldn't it?
17:22:54 <benmachine> you need to import two modules which define the same name
17:23:04 <benmachine> and then try to :info that name
17:23:51 <benmachine> you might expect it to fail (although it doesn't for example for types and constructors with the same name)
17:23:55 <aidalgol> Is there a function that works exactly like show, but returns Char instead of [Char]?
17:24:26 <monoidal> @hoogle a -> Char
17:24:26 <lambdabot> Prelude id :: a -> a
17:24:26 <lambdabot> Data.Function id :: a -> a
17:24:26 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:24:29 <benmachine> aidalgol: uh, how
17:24:35 <benmachine> haha
17:24:40 <benmachine> that's hoogle's way of saying "no"
17:24:46 <monoidal> @hoogle Show a => a -> Char
17:24:46 <lambdabot> Prelude show :: Show a => a -> String
17:24:47 <lambdabot> Text.Show show :: Show a => a -> String
17:24:47 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
17:24:53 <monoidal> :)
17:25:11 <monoidal> aidalgol: maybe you want (!!0) . show?
17:25:16 <monoidal> * head . show
17:25:18 <monochrom> OK I have "module B where import Data.Complex as C; import D as DD", "module D where data D a = a :+ a", then ":load B.hs" and ":info :+", I do get Ambiguous occurrence `:+'
17:25:29 <aidalgol> I think so. :P Thanks.
17:25:34 <benmachine> monochrom: huh, ghc version?
17:25:37 <benmachine> I'm still on 6.12.1
17:25:38 <monochrom> 6.12.3
17:25:41 <benmachine> oh ok
17:25:45 <benmachine> I'll assume it's fixed
17:26:47 <aidalgol> > [ x | x <- [1..], (x `mod`) == 0 ]
17:26:47 <lambdabot>   *Exception: (==): No overloading for function
17:27:03 <aidalgol> OK, what's your problem, Haskell?
17:27:09 <aidalgol> > [ x | x <- [1..], x `mod` == 0 ]
17:27:10 <lambdabot>   <no location info>: parse error on input `=='
17:27:19 <aidalgol> Oh...
17:27:25 <aidalgol> Of course.
17:28:37 <benmachine> x mod what :o
17:29:27 <benmachine> ok so what do I do if I want to update a package owned by missing matt morrow?
17:29:39 <benmachine> (I have my eye on haskell-src-meta)
17:29:47 <monoidal> > let (==) = ($) in [ x | x <- [1..], ((x `mod`) == 2) == 0 ]
17:29:48 <lambdabot>   No instance for (GHC.Real.Integral (a -> GHC.Bool.Bool))
17:29:48 <lambdabot>    arising from a ...
17:29:57 <benmachine> hah
17:29:58 <monoidal> > let (==) = ($) in [ x | x <- [1..], ((x `mod`) == 2) /= 0 ]
17:29:58 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:33:37 <ddarius> benmachine: Ideally, if you are willing, I'd recommend claiming maintainership until Matt Morrow returns.
17:34:51 <lispy> Is mmorrow really gone?
17:34:58 <lispy> preflex: seen mmorrow
17:34:58 <preflex>  mmorrow was last seen on #ghc 189 days, 21 hours, 37 minutes and 13 seconds ago, saying: * mmorrow is rtfm'ing
17:35:05 <lispy> oh damn.
17:35:09 <dented42> I have a silly question about style - Is it considered 'proper' to put quick check test in a seperate file (from the functions being tested) or should they be placed alongside the defintions?
17:35:12 <benmachine> he hasn't been seen for a while
17:35:23 <ddarius> lispy: He seems to have gone missing from the internet as a whole and not just the Haskell community.
17:35:31 <lispy> ddarius: hmm
17:35:35 <benmachine> ddarius: it needs some severe updating, if I can manage that then I'll ask -cafe probably
17:35:38 <jaj> ddarius: huh?
17:35:40 <lispy> ddarius: that's not good
17:35:48 <ezyang> :-/ 
17:35:54 <benmachine> apparently some people have phone numbers for him but I don't think anyone's been brave enough to try yet
17:36:08 <jaj> if he's who I think he is then he's actively commiting haskell ports in openbsd
17:41:54 <jaj> well nevermind it's not him
17:42:35 <Phyx-> hmm way to many computer scientist dissappear from the internet without a trace..
17:46:23 <ddarius> Phyx-: We should make an online registry of them and have GPS transponders surgically embedded into them.
17:47:19 <dankna> GPS is actually a one-way thingy, so transponder is a misnomer
17:47:27 <dankna> there's no communication from ground to satellite with it
17:47:48 <ddarius> receive from satellite, send to cell network 
17:47:50 <dankna> however, cute idea
17:47:59 <dankna> indeed
17:48:05 <dobblego> is there a hoogle for category-extras?
17:48:33 <ddarius> dobblego: I doubt the online ones index it, but you could make an offline one.
17:48:43 <dobblego> yeah I guess, cheers
17:48:55 <Phyx-> ddarius: lol, indeed
17:49:54 <Phyx-> I would love to catch up would some old irc friends, If we had them tagged I could track them :(
17:49:58 <ddarius> Soon people will go in for routine maintenance rather than regular checkups.
17:51:12 <Phyx-> atleast it would be faster
17:51:27 <Phyx-> ideally
17:53:00 <ddarius> "Your implant is leaking GPS fluid and we'll need to order 50ft of satellite uplink.  That'll come to 863 dollars and 76 cents."
17:53:48 <dankna> haha
17:54:23 <benmachine> haskell-src-exts has some weird kinds
17:54:31 <benmachine> anyone know what "forall (a :: !) . a" might mean?
17:54:46 <ddarius> Uh, no.
17:55:03 * benmachine wonders what to do with it
17:55:22 <benmachine> hey what, there's a KindVar field as well
17:55:24 * benmachine blinks a bit
17:55:30 <Phyx-> lol
17:55:48 <ddarius> Maybe JHC has those things?
17:55:49 <Phyx-> benmachine: never encountered that
17:56:15 <Phyx-> but then again, I just throw long generic queries over the parse tree
17:56:15 <Phyx-> lol
17:56:41 <ddarius> benmachine: http://repetae.net/computer/jhc/manual.html#on-boxed-kinds
17:57:10 <Phyx-> :t fmap (id &&& (+1))
17:57:11 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a, a)
17:57:13 <benmachine> ! is the kind of boxed strict values, apparently
17:57:18 <benmachine> well, TH doesn't support it
17:57:23 <Phyx-> hm, not the one i'm looking for
17:57:28 <Phyx-> :t fmap (id *** (+1))
17:57:29 <lambdabot> forall b b' (f :: * -> *). (Num b', Functor f) => f (b, b') -> f (b, b')
17:57:34 <Phyx-> there we go
17:57:56 <ddarius> benmachine: TH is GHC thing, ! as a kind is a JHC thing
17:58:12 <ddarius> (unless GHC has added it since I've last checked)
17:58:53 <benmachine> ddarius: yeah, haskell-src-meta is supposed to convert HSE -> TH
17:59:14 <benmachine> question is whether to just make it into * or whine
17:59:44 <Phyx-> oh oh, my ears are ringing
18:02:20 <Phyx-> > ping
18:02:21 <lambdabot>   Not in scope: `ping'
18:02:22 <Phyx-> @ping
18:02:23 <lambdabot> pong
18:02:32 <dankna> @pong
18:02:32 <lambdabot> pong
18:02:46 <Taejo> :t text
18:02:47 <lambdabot> String -> Doc
18:02:57 <Taejo> @let ping = text pong
18:02:58 <lambdabot>  <local>:4:12: Not in scope: `pong'
18:03:02 <Taejo> @let ping = text "pong"
18:03:03 <lambdabot>  Defined.
18:03:10 <Taejo> @let ping = text "> pong"
18:03:11 <lambdabot>  <local>:5:0:
18:03:11 <lambdabot>      Multiple declarations of `L.ping'
18:03:11 <lambdabot>      Declared at: <local...
18:03:19 <Taejo> @forget ping
18:03:19 <lambdabot> Incorrect arguments to quote
18:03:19 <ddarius> benmachine: I'd just convert to * but put a note in the documentation/source.
18:03:27 <Taejo> > ping
18:03:28 <lambdabot>   pong
18:03:32 <Taejo> :)
18:03:33 <ddarius> For the kind variables, I'd complain probably.
18:03:46 <benmachine> ddarius: I'm thinking that- yeah, kind variables have got to cause an error
18:04:13 <benmachine> I think for now I'll make ! error too
18:04:22 <benmachine> better break on the unexpected than work in unexpected ways
18:13:57 <lispy> How do you represent Either types in SQL?
18:14:18 <lispy> say you want to represent Either Int String in your schema?
18:14:39 <dankna> I avoid doing that, haha
18:14:41 <lispy> data Foo = F { .... blah :: Either Int String ... }, and you want to serialize that to your database
18:14:55 <dankna> well, it depends on the larger context
18:15:14 <dankna> you could put two columns, an id and a type tag saying which other table to find the actual value in
18:15:23 <dankna> or you could be using sqlite3, which has polymorphism
18:15:26 <lispy> How so? :)
18:15:42 <dankna> to which?
18:15:51 <lispy1> dankna: sorry, I got disconnected
18:15:52 <dankna> oh, depends
18:15:53 <dankna> np
18:16:12 <dolio> Polymorphism?
18:16:21 <dankna> I was just saying that one approach would be to make two new tables with two columns each, an id and an actual value - in one case int, in the other case string
18:16:33 <dankna> well, not exactly polymorphism because that term is for functions and we're talking about data
18:16:42 <dankna> but it doesn't enforce type constraints, let's put it that way
18:16:46 <Benny_> y helo #haskell
18:16:46 <dankna> (I actually hold that it ought to, but)
18:17:00 <dolio> Ah, so it's kind of like a Dynamic?
18:17:03 <dankna> yes
18:17:09 <Benny_> Is there any good explanation anywhere of what exactly allows, um
18:17:12 <dolio> They should get on the dependent types train.
18:17:17 <dankna> concur fully
18:17:22 <lispy> dankna: Hmm...So it has a foreign key to (Int, String) ?
18:17:34 <dankna> lispy: not exactly what I was thinking
18:17:38 <dankna> although that's another possible model
18:17:46 <lispy> I guess I didn't understand you then :)
18:18:27 <dankna> well, let me say first that this is only a schema I would consider if I've already got a lot of columns in the main table and I really have a strong reason for wanting to jam one more in
18:18:27 <Benny_> Let's say I have a function that grows a list as it recurs; what must hold for: mapM_ (\x -> putStrLn x) (somefunction someinput) to not block until somefunction is entirely evaluated?
18:18:34 <dolio> You have one table (Bool, Key) and two tables (Key, Int) (Key, String).
18:18:35 <dankna> if the main table has no other columns there's probably a better way
18:18:44 <dankna> yes, what dolio just said
18:18:47 <dankna> except he said it better than me
18:18:52 <dolio> For (False, k) you look up k in the first table, for (True, k) you look up k in the second.
18:19:03 <dankna> though bool is not an sql type, but yes
18:19:12 <lispy> dolio: ah
18:19:50 <siracusa> lispy: What about two columns, one holding the value as a string, the other saying if to interpret the value as string or as int?
18:20:06 <lispy> I see.  Or I could do it by adding nullable columns that store Int and String and just hope that only one of the two is null at any time?
18:20:25 <dankna> lispy: or if you're using an sql engine that supports it, you could even add a validity constraint to that effect
18:20:38 <Benny_> That is, somefunction x = foo x ++ somefunction (otherfunction x)
18:20:39 <lispy> dankna: postgres
18:20:40 <dankna> but yes, that's another way.  probably simpler to be honest.
18:20:48 <dankna> I'm insufficiently familiar with postgres
18:21:03 <lispy> Okay.  I'll go with the nullable column hack :)
18:21:17 <lispy> Although the Bool solution is nice too
18:21:20 <dankna> cool cool
18:21:22 <Benny_> (except sufficiently more complicated, such that Haskell seems to be choking and deciding to evaluate somefunction x to completion before returning anything)
18:21:32 <dankna> what's this for btw?
18:21:37 <lispy> I could do add columns (Bool, Maybe Int, Maybe String)
18:21:46 <dankna> true true
18:21:47 <lispy> dankna: it's for a work project.
18:21:50 * dankna nods
18:21:53 <dankna> I see
18:22:22 <lispy> Just trying to clean up this spreadsheet system that has grown out of control
18:22:40 <dankna> ah yes, I hate when people think a spreadsheet can be a database
18:22:51 <lispy> I have something like, data Expense = ExpenseType1 Blah | ExpenseType2 Bar ...
18:23:21 <kmc> Benny_, ¬´\x -> putStrLn x¬ª is just putStrLn
18:23:35 <Benny_> Quite so
18:23:43 <Benny_> I was going to put something more complicated in there at first :P
18:23:51 <kmc> Benny_, mapM_ will evaluate its argument only to the first constructor, then call the function and invoke that action, then recurse
18:24:07 <Benny_> Yes, that's exactly the behavior I want
18:24:09 <kmc> so if the function generating the list can produce one (:) constructor without doing all the work, it should print as it goes
18:24:25 <lispy> dankna: actually.  What I should do, is make a different table for the different expense types and then join them
18:24:25 <kmc> if you can hpaste some code i'll look at it
18:24:32 <dankna> hmm
18:24:35 <Benny_> Sure, it probably won't make much sense though
18:24:54 <kmc> maybe you can pare it down to a small case that still has the undesired behavior
18:25:27 <Phyx-> ggggrrr why does my package database keep getting corrupted
18:26:16 <lispy> Phyx-: how do you know it's corrupt?
18:26:20 <Benny_> kmc: I actually have :3
18:26:24 <Benny_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28262#a28262
18:26:35 <Phyx-> lispy: well, not corrupt, but broken packages
18:26:51 <kmc> Benny_, ok, where does it go wrong
18:26:57 <Phyx-> ghc-pkg check just said so :(
18:26:58 <Benny_> It works fine unless I run it on an input program that uses the rewind instruction
18:26:59 <lispy> Phyx-: Because GHC failed to link something or because you ran 'ghc-pkg check' and it complained?
18:27:01 <Phyx-> happens way too ofthen
18:27:11 <Phyx-> lispy: last one
18:27:19 <Benny_> But I don't modify the "outputs" field when that is called, so I'm utterly baffled
18:27:24 <kmc> btw Debug.Trace will let you see precisely when things are evaluated
18:27:33 <lispy> Phyx-: My experience with ghc-pkg check is that it complains when there isn't a real problem.  Or put another way, normal usage of cabal causes it to think that packages are broken.
18:28:00 <Benny_> For instance, just using it as a mediocre Forth clone a la "in in + out in out" works perfectly
18:28:07 <dcoutts_> lispy: that's actually because "normal" use of cabal can give you broken packages :-(
18:28:46 <Phyx-> lispy: could be, those packages are pretty old and i don't use them anymore, but haddock which it list did stop working
18:28:51 <lispy> dcoutts_: really? even if I never do 'cabal upgrade foo' ?
18:28:52 <dcoutts_> (which is because our package system is mutable rather than persistent)
18:28:57 <dcoutts_> lispy: yes
18:29:02 <lispy> :(
18:29:09 <Phyx-> yay, check is happy again
18:29:26 <lispy> Phyx-: what did you do?
18:29:49 <dcoutts_> lispy: it happens when cabal needs to rebuild a package, other packages that depend on the one cabal chose to rebuild do not themselves get rebuilt, so they end up with missing dependencies.
18:30:07 <Phyx-> lispy: uninstalled the things it mentioned and reinstalled them, it was mostly complaining about older versions of 2 packages, haddock and a library i'm making
18:30:21 <dcoutts_> lispy: if we could install new instances of a package version without overwriting the existing instance then we would not have that problem.
18:30:28 <Phyx-> but last time, I had to modify the binary package database by hand
18:31:09 <dcoutts_> Phyx-: you know about ghc-pkg recache right? you should never have to edit the binary cache file
18:32:11 <Phyx-> bah
18:32:18 <Phyx-> that pause key on the keyboard is really annoying
18:32:30 <Phyx-> seems to push irssi to the background and i can't restore it
18:32:54 <kmc> what's the right flag to make a GHC-compiled program avoid the wrath of the OOM killer on a memory-constrained system?
18:32:58 <kmc> +RTS -M ?
18:33:07 <Benny_> 21:26 < kmc> btw Debug.Trace will let you see precisely when things are  evaluated
18:33:08 <Phyx-> lispy: anyway, the worst thing that happened to me once was that I had to manually modify the package database
18:33:14 <Benny_> I'm not entirely sure how that'd help
18:33:17 <lispy> Phyx-: hmm
18:33:19 <Phyx-> the version has it had for the ghc api somehow changed
18:33:22 <Phyx-> hash*
18:33:24 <lispy> dcoutts_: ah
18:33:51 <kmc> basically i want it to GC more and use less RAM at a time
18:34:11 <lispy> kmc: IIRC, there is an RTS option for that
18:34:13 <Mathnerd314> how many combinators, such as (.) or ($), does one need to write any parenthesized expression, e.g. map (f g) (h xs), using at most one combinator between words, e.g. map . f g $ h xs
18:35:16 <Zao> A ball intercalated between each chunk but the last which has a dollar?
18:35:40 <kmc> :t map (?f ?g) (?h ?xs)
18:35:40 <lambdabot> forall t a b t1. (?xs::t1, ?h::t1 -> [a], ?g::t, ?f::t -> a -> b) => [b]
18:35:41 <Zao> Of course, if you count nestings, you're in pain.
18:35:48 <kmc> :t map . ?f ?g $ ?h ?xs
18:35:49 <lambdabot> forall a b t a1 t1. (?f::t -> a1 -> a -> b, ?g::t, ?h::t1 -> a1, ?xs::t1) => [a] -> [b]
18:35:57 <Mathnerd314> yeah, nestings are where I'm stuck
18:36:01 <kmc> those aren't equivalent
18:36:27 <Mathnerd314> oh, not even my example is right :p
18:36:28 <mm_freak> Mathnerd314: zero
18:36:32 * Zao retracts his statement due to broken premise.
18:36:40 <mm_freak> example: map (f g) (h xs)
18:36:44 <Mathnerd314> Zao: the question still stands
18:37:06 <Zao> I would make a bold statement and say "you can't".
18:37:09 <Mathnerd314> mm_freak: using *at most one*. ") (" counts as two
18:37:17 <Zao> Not without using parens.
18:37:24 <Mathnerd314> Zao: that would be horrible!
18:37:26 <mm_freak> Mathnerd314: parens aren't combinators
18:37:33 <Phyx-> dcoutts_: can I ask you a quick questions? I'm trying to find out how to build a LocalBuildInfo so i can run the preprocessor, the documentation refers to a "Distribution.Setup.ConfigFlags" that doesn't seem to exist and Distribution.Simple.Setup does not seem to be it.
18:37:40 <Mathnerd314> mm_freak: s/combinators/tokens/ then
18:37:42 <Zao> Mathnerd314: Show us on the doll where the paren touched you.
18:38:09 <kmc> stupid types
18:38:10 <Mathnerd314> Zao: the part that says "L-I-S-P"
18:38:11 * hackagebot hexpat 0.18.3 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.18.3 (StephenBlackheath)
18:38:14 <Zao> Phyx-: Docs for Cabal seems to be in a happy state of disagreement with the world.
18:38:21 <Phyx-> :/
18:38:25 <Zao> Mathnerd314: These are not your grandfather's parenthesis.
18:38:47 <Mathnerd314> Zao: I've sworn off parenthesis, after dealing too much with Lisp
18:38:48 <kmc> in a dynamically typed language, my smartass answer is to write a function f which takes a single Integer and decodes it as a function
18:38:52 <Phyx-> I'll grep into cabal-install and see how it does it :)
18:39:14 <dcoutts_> Phyx-: what refers to "Distribution.Setup.ConfigFlags" ?
18:39:20 <kmc> since you can number all possible lambda terms, you can find some n such that ¬´map (f g) (h xs)¬ª is equivalent to ¬´magic n f g h xs¬ª
18:39:25 <Mathnerd314> kmc: then you're just compressing tokens together
18:39:27 <kmc> err
18:39:33 <kmc> ¬´magic n map f g h xs¬ª
18:40:04 <Phyx-> dcoutts_: Distribution.Simple.LocalBuildInfo, it says "Data cached after configuration step. See also Distribution.Setup.ConfigFlags."
18:40:13 * Mathnerd314 thinks of a method
18:40:23 <dcoutts_> Phyx-: in the Cabal lib, the main bit of code that constructs a LocalBuildInfo is the configure code, ie we make one when configuring the package. The other functions for LocalBuildInfo are mostly to save and restore one from a file.
18:41:38 <dcoutts_> Phyx-: oh, that should refer to Distribution.Simple.Setup.ConfigFlags
18:42:23 <Phyx-> dcoutts_: ah thanks, I somehow missed Distribution.Simple.Configure :/
18:43:18 <Phyx-> dcoutts_: oh and did you get my other message? the docs links on http://hackage.haskell.org/trac/hackage/wiki/SourceGuide seem to all be dead
18:44:05 <kmc> Mathnerd314, well, yes
18:45:35 <dcoutts_> Phyx-: ta
18:47:05 <Mathnerd314> ah, it comes down to whether (2n choose n)/(n+1) is eventually greater than x^n for all x.
18:53:43 <kmc> i am confused because my program does 14 unrelated things
18:53:49 <kmc> which should have no shared data
18:54:00 <kmc> and if i do all 14 in a row, the 12th makes the machine run out of memory
18:54:05 <kmc> but if i do only that one, it's fine
18:54:21 <kmc> perhaps it's holding onto a CAF somewhere
18:54:24 <kmc> what's a good way to check?
18:56:03 <mlh> you probably know a lot more than me, so I'm not going to suggest http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/profiling.html :-)
18:56:49 <kmc> ah but you do suggest it :)
18:56:51 <kmc> and i should read it again
18:59:13 <kmc> a graph of heap usage is not precisely what i want, but it may be helpful
18:59:30 <Phyx-> @hoogle (a -> IO ()) -> IO a
18:59:31 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
18:59:31 <lambdabot> Foreign.Marshal.Pool withPool :: (Pool -> IO b) -> IO b
18:59:31 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
18:59:38 <Mathnerd314> aha! I need precisely 4 symbols, because according to Wolfram|Alpha \lim_{n\to infinity} (2n choose n)/(n+1) - 4^n = -infinity
19:00:08 <Phyx-> @hoogle a -> (a -> IO ()) -> IO a
19:00:09 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
19:00:09 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
19:00:09 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
19:00:16 <Phyx-> oh well
19:00:40 <Phyx-> :t \a f->f a>> return a
19:00:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => b -> (b -> m a) -> m b
19:00:59 <Phyx-> thought there would be something like that
19:01:17 * hackagebot spoonutil 0.0.1 - Spoon's utilities. Simple testing and nice looking error reporting.  http://hackage.haskell.org/package/spoonutil-0.0.1 (JohnnyMorrice)
19:01:23 <kmc> also it's a bit of a pain for me to do a profiling build
19:01:25 <CakeProphet> @djinn (a -> b -> c -> d) -> d -> c -> b -> a 
19:01:25 <lambdabot> -- f cannot be realized.
19:02:08 <CakeProphet> awww, Djinn is nowhere as miraculous as I thought. It's only SLIGHTLY miraculous.
19:03:08 <kmc> yeah, it can't prove false theorems
19:03:41 <kmc> try to write that function yourself
19:04:13 <tolkad> is it possible to have something like ?class C (a b)?? I want this class to be for types with a parameter
19:04:19 <micahjohnston> I want to make a dataflow/reactive programming language, and Arrows seem like a good idea to represent the programs
19:04:38 <micahjohnston> but I don't know how I'd go about that
19:04:41 <kmc> tolkad, you can make classes of types with a parameter
19:04:44 <kmc> Functor is such a class
19:04:57 <kmc> class Functor f where { fmap :: (a -> b) -> f a -> f b }
19:05:39 <tolkad> kmc: no, I mean type paramaters
19:05:55 <kmc> ok
19:05:56 <tolkad> parameters*
19:06:06 <kmc> types with a type parameter?
19:06:13 <tolkad> like ?data T n?
19:06:15 <tolkad> yeah
19:06:16 <kmc> yes
19:06:25 <kmc> Maybe is a type with a type parameter
19:06:30 <kmc> Maybe is an instance of Functor
19:07:18 <kmc> (also i'm not seeing your quotation marks properly, they're some unknown character)
19:07:19 <tolkad> but, can I have a class which requires instances to have a type parameter so that the class can make use of that type
19:07:32 <kmc> i'm still not sure what you want
19:07:37 <tolkad> kmc: get a unicode font :P
19:07:44 <kmc> tolkad, i have a unicode font
19:07:48 <kmc> what encoding are you sending?
19:07:49 <benmachine> tolkad: I don't see them either, but I do see ‚Äòthese‚Äô
19:07:54 <kmc> what characters are they supposed to be?
19:07:59 <kmc> > ord '?'
19:08:00 <lambdabot>   63
19:08:03 <kmc> dur
19:08:06 <benmachine> :P
19:08:25 <tolkad> > ord '?'
19:08:26 <lambdabot>   63
19:08:38 <tolkad> 0_o must be my client
19:08:48 <tolkad> it's supposed to be the quotation mark like <<
19:08:49 <benmachine> it seems like instances of Lift are required for [| stuff |] to work properly
19:08:49 <kmc> tolkad, how does what you want differ from a "constructor class" like Functor?
19:08:53 <kmc> these tolkad? ¬´
19:08:55 <tolkad> yes
19:08:59 <tolkad> it must be my client
19:09:02 <tolkad> one moment
19:09:05 <benmachine> ...maybe
19:09:07 * benmachine scratches head
19:09:07 <kmc> ok people used to tell me mine were wrong too
19:09:14 <kmc> then i switched to sending straight-up utf8
19:10:02 <benmachine> aha
19:10:13 <benmachine> let x = () in [| x |] requires Lift ()
19:10:19 * hackagebot snm 0.0.1 - The Simple Nice-Looking Manual Generator.  http://hackage.haskell.org/package/snm-0.0.1 (JohnnyMorrice)
19:10:43 <tolkad> this work? ¬´¬ª
19:10:45 * benmachine notes:
19:10:45 <benmachine> -- comic relief from HERA
19:10:46 <benmachine> instance Lift Rational where lift _ = error "Rational.. what are you doing!"
19:10:50 * benmachine hmms
19:10:54 <benmachine> tolkad: from here, yeah
19:10:59 <kmc> tolkad, looks fine
19:11:31 <tolkad> yay, anyway, I mean like ¬´class (Num b) => C (a b) where f a :: a -> b¬ª
19:11:49 <tolkad> err
19:11:52 <tolkad> yay, anyway, I mean like ¬´class (Num b) => C (a b) where f :: a -> b¬ª
19:12:00 <tolkad> I have a habit of doing that
19:13:33 <benmachine> is the "done thing" to put each extension in a separate language pragma?
19:13:49 <kmc> tolkad, wouldn't work.  for (a b) to be a well-formed type, a and b can't both have kind *, yet the function type ¬´a -> b¬ª requires it
19:13:51 <JoeyA> In Parsec, GenParser has 3 type arguments (token type, ?, and result).
19:13:55 <JoeyA> What is the second type argument for?
19:14:02 <kmc> JoeyA, user-specified state, probably
19:14:15 <JoeyA> The documentation says:  "The type of general parsers is GenParser tok st a, where tok is the type of the tokens, st the type of the local user state and a is the type of the result."
19:14:16 <kmc> it's set to () usually?
19:14:19 <kmc> yeah
19:14:20 * hackagebot snm 0.0.2 - The Simple Nice-Looking Manual Generator.  http://hackage.haskell.org/package/snm-0.0.2 (JohnnyMorrice)
19:14:25 <JoeyA> I don't quite get "local user state"
19:14:32 <tolkad> JoeyA: the parameter of a
19:14:48 <Benny_> kmc: Have you had an epiphanies as to my problem? :3
19:14:49 <tolkad> JoeyA: oh you are talking about something else
19:14:52 <Benny_> I was hoping it was a common enough one
19:14:54 <kmc> Benny_, no sorry :/
19:15:00 <Benny_> Thanks for trying :)
19:15:11 <tolkad> kmc: why can't they both have type *?
19:15:15 <JoeyA> When would it not be () ?
19:15:18 <Benny_> I'll keep looking at it, this is just a prototype of the finished application anyway
19:15:30 <kmc> tolkad, for the same reason that if i write (f x), f and x can't both have type Int
19:15:49 <kmc> whatever type T is the type of x has, f has to have a type like T -> S
19:15:53 <kmc> so they can't be the same
19:16:00 <tolkad> kmc: no, a isn't a function
19:16:05 <tolkad> kmc: a is a data type
19:16:08 <kmc> (a b) is a type application
19:16:14 <kmc> yes?
19:16:21 <kmc> a is a variable ranging over type constructors
19:16:31 <kmc> types are classified by kinds
19:16:32 <kmc> :k Int
19:16:33 <lambdabot> *
19:16:33 <kmc> :k Maybe
19:16:34 <lambdabot> * -> *
19:16:35 <kmc> :k Either
19:16:35 <lambdabot> * -> * -> *
19:16:44 <kmc> Int takes 0 arguments, Maybe takes 1 argument, Either takes two
19:16:46 <kmc> :k StateT
19:16:47 <lambdabot> * -> (* -> *) -> * -> *
19:16:58 <kmc> StateT takes three arguments, where the second argument itself takes one argument
19:17:18 <tolkad> wait what? 0_o this is confusing
19:17:32 <kmc> types/type-constructors are classified by kinds
19:17:37 <kmc> just as values are classified by types
19:17:49 <tolkad> data type arguments are just like java generics, right?
19:17:53 <kmc> no
19:18:09 <kmc> i'll wager that nothing in Haskell is "just like" something else in Java
19:18:12 <tolkad> OH, I see what's wrong
19:18:21 <tolkad> I need this:
19:18:29 <tolkad> ¬´class (Num b) => C (a b) where f :: (a b) -> b¬ª
19:18:42 <kmc> yes, that's more reasonable
19:18:53 <tolkad> great, I'll go do that, thanks
19:18:57 <kmc> because b and (a b) are both types
19:19:00 <kmc> however it's still not allowed
19:19:11 <tolkad> wtf it still didn't work
19:19:13 <tolkad> haskell bug?
19:19:16 <kmc> no
19:19:19 <mm_freak> tolkad: type variables are like java generics, but type constructors are not
19:19:37 <kmc> tolkad, you assume it's a bug even though you don't really understand the situation?
19:20:01 <tolkad> kmc: you said it's reasonable, if it is reasonable this stupid compiler should accept it, I think GHC just hates me
19:20:06 <jystic> didn't phil wadler help the java guys out with generics?
19:20:11 <kmc> i said more reasonable
19:20:22 <kmc> it's still not reasonable
19:20:23 <ddarius> kmc: tolkad just calls every error he encounters "haskell bug."
19:20:28 <kmc> you can't "pattern-match" on a type application
19:20:34 <kmc> just as a function can't pattern-match on a value application
19:20:40 <ddarius> jystic: He was one of the many researchers that suggested ideas for it.
19:20:52 <kmc> i can't say ¬´f (length xs) = xs¬ª
19:21:11 <kmc> a language where this is allowed would be cool, but would be extremely different from Haskell
19:21:21 <tolkad> kmc: but that's totally different
19:21:27 <tolkad> kmc: this is a type, not a function
19:21:31 <jystic> ddarius: they still made a hash of it
19:21:39 <Benny_> That was a... strange line to tab to this channel on
19:21:52 <kmc> tolkad, why is it more reasonable for types?
19:21:58 <kmc> tolkad, maybe you could tell us what you're trying to do
19:22:05 <tolkad> kmc: because they aren't functions, they are like objects
19:22:10 <kmc> no they aren't
19:22:20 <Phyx-> @hoogle die
19:22:20 <lambdabot> Network.HTTP.Base DieHorribly :: String -> ResponseNextStep
19:22:22 <ddarius> jystic: Because of the unreasonable backwards compatibility constraints.  They probably did far better than they would have if left to their own devices.
19:22:33 <kmc> unless you mean the category-theoretic definition of "object"
19:22:46 <tolkad> ok, I understand haskell pretty well now, data types are like objects, classes are like instances, you put the function before the object instead of after it, other than that it's mostly like OOP
19:22:54 <kmc> no
19:22:57 <kmc> that's completely wrong
19:22:57 <tolkad> err classes are like interfaces*
19:23:03 <jystic> ddarius, yeah i completely agree
19:23:13 <tolkad> not instances, sorry, kmc that was a typo
19:23:13 <kmc> ok, better :)
19:23:24 <kmc> i don't think it's mostly like OOP though
19:23:36 <kmc> and i think that viewpoint is likely to create code which massively overuses type classes
19:23:42 <kmc> which is something a lot of beginners do
19:24:05 <tolkad> ok, I'll tell you what I want to do
19:24:08 <mm_freak> tolkad: why are you always trying to compare haskell to some OOP language?
19:24:18 <mm_freak> virtually all of your problems come from this
19:24:28 <kmc> tolkad, try to write your code without type classes at all
19:24:38 <_Ray_> I can rewrite foo (bar x) as (foo . bar) x, right? But not as foo . bar x?
19:24:42 <kmc> right
19:24:45 <tolkad> I have a vector data type for a 3 dimensional vector
19:24:46 <kmc> foo . bar $ x
19:24:53 <jystic> ddarius: i meant that even with good advice Sun still made a hash of it (as you say, the backwards compatibility constraints killed any chance of a good solution)
19:25:01 <_Ray_> What if I have foo (bar x) (baz y)?
19:25:08 <tolkad> I have a vector class with the dot product function
19:25:28 <kmc> why is it in a class?
19:25:42 <kmc> why not just an ordinary function which operates on your vector data type
19:25:49 <tolkad> incase I want to make a vector for 2 dimensions
19:25:55 <kmc> ok
19:26:20 <_Ray_> Can't that vector be represented by a list of its coordinates?
19:26:28 <tolkad> so anyway, my vector data type has a type parameter of classes Fractional and Num
19:27:01 <tolkad> _Ray_: yeah but that would probably be inefficient, also, I wouldn't be able to make sure the list had the proper length and it would just be messy in general
19:27:10 <jystic> couldn't any type implement a function for dot product
19:27:40 <jystic> i guess the result has to be Num  and Fractional
19:28:53 <tolkad> so, I wanted something like ¬´class (Fractional numtype, Num numtype) => Vector (3DimensionalVector numtype) where dotproduct :: (3DimensionalVector numtype) -> (3DimensionalVector numtype) -> numtype¬ª
19:29:20 <kmc> class VectorLike v where { dotProduct :: (Fractional a) => v a -> v a -> a }
19:30:14 <tolkad> wow really? thanks
19:30:26 <kmc> just like the Functor example i gave you a while ago
19:30:37 <tolkad> the functor example didn't use classes
19:30:42 <kmc> instance VectorLike Vec3 where { dotProduct (V3 x1 y1 z1) (V3 x2 y2 z2) = x1*x2 + y1*y2 + z1*z2 }
19:30:47 <kmc> tolkad, Functor is a class
19:31:03 <kmc> <kmc> class Functor f where { fmap :: (a -> b) -> f a -> f b }
19:32:09 <tolkad> wow the last haskell standard was released in 1998? are they planning to release a new one?
19:32:11 <abuiles> Hi guys, does someone know how can I catch within a type when simpleHTTP gives timeout ? I have been trying to figure it out, but the only way I have found is looking at the string of the error.
19:32:28 <tolkad> oh, there is a new one, nevermind
19:32:58 <kmc> tolkad, there will be one every year starting this year
19:33:24 <jystic> tolkad: why do you type out 'numtype' each time instead of just 'a' or 'n'? having such long names makes things it really hard to read/understand sometimes
19:33:27 <tolkad> is haskell 2010 much different from haskell 1998?
19:33:32 <kmc> tolkad, not much different
19:33:40 <kmc> tolkad, it standardizes a few extensions people have been using for many years
19:33:43 <tolkad> jystic: That wasn't my actual code
19:33:51 <jystic> ahh ok :)
19:33:52 <kmc> tolkad, and a few minor syntax tweaks that aren't even in GHC yet
19:34:14 <tolkad> kmc: does it add anything cool like multiparamtypeclasses?
19:34:25 <kmc> tolkad, (Num a, Fractional a) is redundant, because Num is a superclass of Fractional
19:34:27 <kmc> tolkad, no
19:34:49 <tolkad> kmc: yeah but that might change in the future
19:34:57 <kmc> no
19:35:10 <kmc> not in particular
19:35:14 <kmc> not that i've heard of
19:35:32 <jystic> and even if it did, your program wouldn't compile so it would be an easy fix
19:35:36 <kmc> it seems much more likely Num will get broken up into many little classes
19:35:42 <kmc> and probably none of them will be named Num
19:36:00 <kmc> very unlikely that your extra verbosity will make your code keep working when it wouldn't otherwise
19:36:05 <kmc> tolkad, http://www.haskell.org/pipermail/haskell/2009-November/021750.html are the extensions in h2010
19:36:26 <ddarius> A change as dramatic as removing Num as a superclass of Fractional would accompany changes that would require significant effort to adapt to.
19:36:50 <tolkad> =P I didn't know what else to say so I made up a reason
19:37:04 <ddarius> tolkad: That is apparent.
19:37:04 <kmc> great thanks for screwing with the people who are trying to teach you for free
19:37:15 <tolkad> kmc: aww, it was a joke : (
19:38:17 <tolkad> kmc: sorry
19:38:46 <kmc> ok
19:38:49 <kmc> sorry i didn't get your joke
19:40:16 <tolkad> ooh, pattern guards sound nice
19:40:22 <kmc> they are :)
19:40:34 <jystic> kmc: last night you were talking about using thrift as a way for me to do ffi type stuff, have you used it before?
19:40:45 <kmc> no
19:41:37 <jystic> damn :) ok, well i think it's a good idea, so i might take a look
19:41:37 <kmc> i used google protobuf, which is similar; was kind of disappointed
19:41:52 <jystic> i was just going to ask about protobuf
19:41:55 <Phyx-> boy it sure quieted down here, guess the people who came from reddit didn't stay
19:42:06 <kmc> some did i assume
19:42:21 <kmc> i guess the "Haskell is an inferior version of PHP, prove me wrong" crowd got bored and left
19:42:47 <kmc> jystic, mostly because the Python protobuf library was ludicrously slow
19:42:49 <rokoteko> there are perl people :)
19:43:01 <Phyx-> lol
19:43:02 <jystic> wow sounds like i missed out on some fun
19:43:03 <kmc> and it doesn't provide any actual RPC, just serialization
19:43:10 <kmc> Thrift may be superior in both respects
19:43:20 <jystic> i thought protobuf did have some rpc stuff
19:43:24 <kmc> it has hooks only
19:43:27 <kmc> no protoc
19:43:28 <kmc> protocol*
19:43:37 <kmc> not even a convenient way to read/write a whole struct from a socket
19:43:41 <Phyx-> hm, that error seriously confuses GHC, either that or I did something wrong
19:43:55 <Phyx-> nope, it's ghc
19:43:56 <Phyx-> lol
19:43:56 <tolkad> kmc: that VectorLike definition seems strange to me because I think of the part between "class" and "where" defining requirements of the type v. it seems strange that a function within the where section of the class declaration can require v to have a parameter
19:44:16 <Phyx-> the "Last statement in a do must be an expression" makes ghc give all weird SrcSpans back
19:44:30 <freedrull> gah, trying to install cairo thru cabal, but it says: The pkg-config package cairo-pdf is required but it could not be found. is this some sort of non-cabal package i need? I have a /usr/lib/pkgconfig/cairo-pdf.pc, maybe cabal is just not finding it.
19:44:55 <tolkad> kmc: how is haskell similar in any way to PHP?
19:45:01 <jystic> kmc: that's a bit of a let down
19:45:26 <tolkad> kmc: as I understand it, haskell is _very_ rarely even used for web application programming, which is almost all PHP is used for
19:45:26 <pickles> nite all
19:45:55 <kmc> tolkad, yes, it's a ridiculous claim, which i was using to make fun of a certain annoying subset of the people we got during the noob flood
19:46:09 <kmc> of course we got lots of people who actually want to learn haskell too
19:46:15 <kmc> it was probably a good thing overall
19:46:16 <dcoutts_> freedrull: cabal asks pkg-config about cairo-pdf, apparently it reports that cairo-pdf is not available
19:46:36 <kmc> tolkad, just as we have type inference, there is kind inference, where the kind of the class parameter v is inferred from the way it's used in the class's methods
19:46:46 <Phyx-> kmc: I would think so, if only for the exposure
19:47:00 <kmc> tolkad, if you turn on the KindSignatures extension, you can write explicitly ¬´class VectorLike (v :: * -> *) where ...¬ª
19:47:08 <kmc> may be more clear to the reader, but it's an extension
19:47:25 <dcoutts_> freedrull: it calls pkg-config --modversion cairo-pdf
19:48:11 <dcoutts_> freedrull: it's odd, I'd expect pkg-config to report a version given that you say you've got cairo-pdf.pc available
19:48:15 <jystic> so where did our php friends come from?
19:48:15 <kmc> also web programming is (unfortunately) not all PHP is used for
19:48:21 <dcoutts_> freedrull: try running the above command manually
19:48:23 <dolio> > let f :: () -> Int ; f = let ?x = 5 in \() -> ?x ; g :: (?x :: Int) => () -> Int ; g = let ?x = 5 in \() -> ?x ; h :: () -> ((?x :: Int) => Int) ; h = let ?x = 5 in \() -> ?x in let ?x = 4 in (f (), g (), h ()) -- BEHOLD!
19:48:24 <lambdabot>   (5,5,4)
19:48:25 <kmc> jystic, tryhaskell.org made the Reddit front page
19:48:39 <kmc> and had a one-click link to a freenode web client to connect here
19:48:45 <jystic> ahh cool :)
19:48:55 <dolio> Note: f, g and h have identical definitions, merely different types.
19:49:14 <kmc> i worked somewhere that the code was evenly split between Ruby+Rails and PHP, and both used both on frontend and backend
19:51:09 <jystic> that sounds like all sorts of debugging fun
19:51:32 <tolkad> I doubt PHP is even stable when running for more than a few seconds
19:52:23 <tolkad> although maybe I'm wrong, I have only ever used it for web programming
19:52:38 <tolkad> I guess that's enough about PHP though
19:53:29 <EvanR> its an abomination, in design, in practice
19:54:10 <jystic> wow http://gtk.php.net/ - that's a scary proposition
19:54:33 <EvanR> indeed
19:54:48 <EvanR> php has lots of bindings
19:55:09 <EvanR> apparently there are psychotics who use it for not web templating
19:55:29 <ric_> hi there
19:55:38 <jmcarthur> even cocoa apps
19:56:09 <ric_> how os that
19:56:14 <ric_> ++alip
19:56:21 <ddarius> > (1000000000000000000000000000000000, 1000000000000000000000000000000000) :: (Int, Integer) -- behold!
19:56:22 <lambdabot>   (4089650035136921600,1000000000000000000000000000000000)
19:56:45 <ric_> == Apocalisp
19:57:02 <tolkad> > (1 :: Int) * (2 :: Integer)
19:57:02 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:57:02 <lambdabot>         against inferred type ...
19:57:09 <Apocalisp> hello, yes?
19:57:16 <EvanR> > -1 :: Word32
19:57:16 <lambdabot>   4294967295
19:57:17 <tolkad> > (1 :: Int) * (2 :: Int) :: Integer 
19:57:18 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
19:57:18 <lambdabot>         agains...
19:58:26 <tolkad> > fromIntegral (1 :: Int) * (2 :: Int) :: Integer 
19:58:27 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
19:58:27 <lambdabot>         agains...
19:58:37 <JoeyA> > import GHC.Int*.Int*.Int*
19:58:38 <tolkad> > (fromIntegral $(1 :: Int) * (2 :: Int)) :: Integer 
19:58:38 <lambdabot>   <no location info>: parse error on input `import'
19:58:39 <lambdabot>   2
19:58:42 <dolio> @type ((let ?x = 5 in \() -> ?x) :: (?x :: ()) => () -> Int)
19:58:43 <lambdabot> (?x::()) => () -> Int
19:58:59 <dolio> @type ((let ?x = 5 in \() -> ?x) :: () -> ((?x :: Int) => Int))
19:59:00 <lambdabot> (?x::Int) => () -> Int
19:59:07 <dolio> Oops.
19:59:12 <dolio> @type ((let ?x = 5 in \() -> ?x) :: (?x :: Int) => () -> Int)
19:59:12 <lambdabot> (?x::Int) => () -> Int
19:59:17 <jystic> EvanR: i always like the programming language fanboy picture: http://i.imgur.com/hF6mS.jpg - I can't get Tim the Toolman Taylor out of my head whenever I think of PHP
19:59:29 <dolio> GHC will tell you those two have identical types, but they behave differently.
19:59:42 <kmc> that version is obnoxious and self-serving
19:59:47 <kmc> everyone thinks we're smart! yay!
19:59:51 <kmc> congrats to us!
20:00:16 <JoeyA> In Haskell, what exactly is () ?
20:00:20 <jystic> there's another one i think
20:00:21 <JoeyA> A tuple with 0 items?
20:00:24 <jystic> http://i.imgur.com/P9RnL.jpg
20:00:26 <ddarius> JoeyA: Yes.
20:00:28 <JoeyA> And what is it usually called?
20:00:31 <kmc> JoeyA, "unit"
20:00:46 <tolkad> @type  * -> * -> * -> * -> * -> * -> *
20:00:47 <lambdabot> parse error on input `*'
20:01:04 <kmc> it's not an expression
20:01:19 <tolkad> @type Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int
20:01:19 <lambdabot> parse error on input `->'
20:01:24 <tolkad> hmm
20:01:26 <kmc> that's also not an expression
20:01:34 <kmc> jystic, much better :)
20:01:39 <tolkad> :k Int -> Int
20:01:40 <lambdabot> *
20:01:42 <tolkad> oh
20:01:47 <tolkad> :k * -> *
20:01:48 <lambdabot> parse error on input `*'
20:01:51 <tolkad> o
20:01:53 <tolkad> ok
20:01:59 <tolkad> :k Int -> Int -> Int
20:02:00 <lambdabot> *
20:02:02 <EvanR> jystic: ahahahaha
20:02:10 <Phyx-> hmm that's interesting
20:02:12 <Phyx-> Configuring Hs2lib-0.2.2...
20:02:13 <Phyx-> *** Exception: user error (At least the following dependencies are missing: QuickCheck >=2.1.0.1,
20:02:18 <kmc> there's nothing to classify kinds, because there's no kind application, kind abstraction, or kind polymorphism
20:02:25 <Phyx-> C:\Users\Phyx\AppData\Roaming\ghc\i386-mingw32-6.12.1\package.conf.d: QuickCheck-2.1.0.3
20:02:25 <kmc> (though there actually is a little kind polymorphism, in GHC)
20:02:31 * Phyx- scratches head
20:02:48 <kmc> kinds look like the types of the simply typed lambda calculus with one base type
20:02:50 <Phyx-> I though cabal always looked at the user and global pkg lists by default
20:03:09 <tolkad> jystic: WTF @ Java as seen by C fans
20:03:17 <jystic> haha
20:03:20 <EvanR> i know
20:03:29 <EvanR> some of these are 
20:03:34 <jystic> Java as seen by Haskell fans is so right
20:03:36 <EvanR> i cant stop laughing
20:03:39 <dcoutts_> Phyx-: I suppose you're using the API rather than the command line tool
20:04:06 <Benny_> There exist PHP fans? D:
20:04:22 <EvanR> yes
20:04:38 <jystic> Benny_: my boss/manager is one of those
20:04:40 <kmc> PHP as seen by Haskell fans
20:04:44 * JoeyA likes the dynamite
20:04:57 <Benny_> mapM_ patOnHeadGently phpFans
20:05:15 <Benny_> I have to use PHP at work
20:05:20 <tolkad> is there any way to tell GHC to automatically ultithreadilize my program?
20:05:26 <EvanR> map unsafeFireTheMissilesAt phpFans
20:05:48 <tolkad> multithreadilize*
20:05:49 <Phyx-> dcoutts_: yeah, i though that was the internal defaults :)
20:05:57 <tolkad> is there any way to tell GHC to automatically multithreadilize my program?
20:06:00 <Benny_> PHP should have been buried the second someone with a room-temperature IQ noticed magic quotes
20:06:02 <dcoutts_> Phyx-: you control it with the ConfigFlags
20:06:09 <Benny_> Yet this is 2010, and I still have to deal with them
20:06:21 <_Ray_> They did. But they were using Celsius.
20:06:40 <tolkad> Benny_: just add some code to automatically remove them
20:06:42 <Phyx-> dcoutts_: ah, thanks :)
20:06:44 <kmc> tolkad, not completely automatically
20:06:49 <Benny_> tolkad: I do
20:06:57 <EvanR> C fans think they are scotty from star trek
20:07:05 <kmc> tolkad, but we can do parallelism in a simple lightweight way, without explicit threads or communication
20:07:09 <Benny_> I'm not Scotty from Star Trek? ;_;
20:07:13 <kmc> tolkad, http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/ is a good talk, though a bit dated by now
20:07:14 <EvanR> i know i am
20:07:20 <kmc> most of the "coming soon" stuff now exists
20:08:40 <ddarius> kmc: Not kind polymorphism but subkinding.
20:09:24 <Benny_> Also, that's not how a coaxial cable works at all I don't even
20:09:24 <_Ray_> Code style comments? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28263#a28263
20:09:49 <kmc> you're right ddarius
20:10:21 <tolkad> kmc: uh that links to http://www.defun2009.info/blog/tutorial-schedule/multicore-programming-in-haskell-now/
20:10:27 <tolkad> kmc: which doesn't make any sense
20:10:43 <kmc> tolkad, it's a dead domain
20:10:45 <tolkad> I can't figure out how to access the tutorial
20:11:07 <tolkad> it says welcome and has a navigation bar but the options don't make sense
20:11:14 <tolkad> they look like car models
20:11:16 <kmc> it's a domain squatter
20:11:24 <kmc> tolkad, http://www.scribd.com/doc/19465418/Multicore-Programming-in-Haskell-Now
20:11:26 <Phyx-> dcoutts_: yup, that worked, thanks, now to just write the dependency tracer and I should be done :)
20:13:00 <Phyx-> What's typically displayed in a Haskell file's header? Module name, copyright, license, maintainer, stability and portability and description right?
20:14:22 <solrize> anyone know what SAT is, in context "SAT sped up GHC performance on Atom benchmark by 100x"?
20:16:17 <xcthulhu> Usually refers to satisfaction in propositional logic
20:16:38 <tolkad> kmc: is ther portable parallel programing in haskell? : /
20:16:41 <tolkad> there*
20:17:20 <xcthulhu> SAT is a well known NP-Complete problem, so it's used for benchmarks just like the traveling salesman problem.
20:17:42 <solrize> xcthulhu, i don't think it's referring to that
20:17:43 <xcthulhu> But it's confusing from the context whether this is what was intended
20:17:51 <ddarius> "static argument transform"
20:18:01 <ddarius> xcthulhu: It's definitely not what was intended.
20:18:06 <xcthulhu> thanks ddarius
20:18:24 <EvanR> Benny_: funny because my current C project is tricky and i gotta keep it from coming apart under stress! ;)
20:18:29 <Phyx-> bed time, bye bye
20:18:45 <kmc> tolkad, it's not part of the Haskell standards
20:18:55 <kmc> tolkad, it's supported by GHC on most platforms GHC supports
20:18:58 <tolkad> xcthulhu: it is not known whether P=NP, one compiler might happen to optimize the algorithm ruining the benchmark
20:21:50 <tolkad> kmc: I really just want to use multiple threads so I can do non-blocking IO
20:22:05 <kmc> tolkad, then you want concurrency, not parallelism
20:22:20 <kmc> it's also covered in that presentation
20:22:28 <kmc> tl;dr is to use forkIO, and MVar or Chan for communication
20:22:34 <_Ray_> I heard the other day something about "taking the derivative" of types. Like, taking the derivative of a list gives you two lists, which one can use as a sort of iterato (past vs future). Am I completely misremembering? Is there such a thing?
20:22:36 <kmc> RWH also has chapters about this
20:22:44 <_Ray_> *iterator.
20:22:47 <EvanR> MVar is amazing
20:22:50 <kmc> _Ray_, that's a real thing.  it's used to compute zipper types
20:23:04 <kmc> tolkad, maybe you'll like http://www.ugcs.caltech.edu/~keegan/talks/first-class-concurrency/talk.html
20:23:05 <tolkad> hmm, Control.Concurrent has "experimental" stability, it's probably a bad idea to use it
20:23:12 <kmc> tolkad, ignore that
20:23:15 <_Ray_> What could I google to get more info on it?
20:23:31 <benmachine> _Ray_: http://en.wikibooks.org/wiki/Haskell/Zippers is a bit lengthy but should interest you
20:23:38 <_Ray_> Thanks :)
20:23:48 <Phyx-> @pl \file -> fmap (fmap (moduleNameString  . ms_mod_name)) (getGraph file)
20:23:48 <lambdabot> fmap (fmap (moduleNameString . ms_mod_name)) . getGraph
20:23:55 <Phyx-> well gee
20:23:56 <tolkad> is there any way to do a conditional import?
20:23:58 <Phyx-> lol
20:24:20 <kmc> _Ray_, also liked http://byorgey.wordpress.com/2010/04/07/functional-pearl-on-combinatorial-species/, iirc it's related
20:24:26 <tolkad> I could try importing Control.Concurrent and if that doesn't work, don't use Concurrency
20:24:26 <Phyx-> tolkad: using CPP ?
20:24:33 <tolkad> Phyx-: I mean portably
20:24:42 <EvanR> tolkad: why bother?
20:24:48 <EvanR> how will it not work
20:24:55 <kmc> tolkad, that might be handled with conditional stuff in the cabal file
20:25:03 <tolkad> oh, I don't use cabal
20:25:16 <ddarius> @google derivative of a data type
20:25:19 <lambdabot> http://www.cs.nott.ac.uk/~ctm/diff.pdf
20:25:19 <lambdabot> Title: The Derivative of a Regular Type is its Type of One-Hole Contexts
20:25:33 <dcoutts_> tolkad: conditional on what?
20:25:42 <tolkad> dcoutts_: whether it exists
20:26:07 <dcoutts_> tolkad: ignore the "experimental" tag, it's meaningless. Just import it.
20:28:38 <tolkad> I do use cabal to install packages
20:28:47 <tolkad> and I got this message:
20:28:48 <tolkad> Note: there is a new version of cabal-install available.
20:28:48 <tolkad> To upgrade, run: cabal install cabal-install
20:28:51 <tolkad> so I did that
20:29:04 <tolkad> and then when I tried something else I got the same message again!
20:29:06 <dcoutts_> check your $PATH
20:29:30 <dcoutts_> you're still using the old version you had installed somewhere else
20:29:56 <tolkad> my $PATH variable doesn't contain anything to do with cabal or haskell
20:30:24 <tolkad> it's probably in /usr/bin or something, I installed the haskell platform
20:30:24 <Benny_> tolkad: Then add $HOME/.cabal/bin
20:30:36 <Benny_> Which is where your new cabal should be :3
20:31:16 <tolkad> same problem
20:31:40 <dcoutts_> you need it on your path before /usr/bin
20:31:42 <tolkad> I put it at the very beginning of my $PATH
20:31:51 <tolkad> oh wait I forgot to reload my shell
20:31:59 <tolkad> didn't run my bash rc
20:32:24 <tolkad> whoop :s
20:32:29 <tolkad> ok that worked, thanks
20:36:37 <dcoutts_> tolkad: http://hackage.haskell.org/trac/hackage/ticket/670#comment:1
20:37:56 <tolkad> I didn't do anything strange, I only have one installation of the haskell platform and I installed it with the standard installer
20:43:39 <tolkad> http://en.wikipedia.org/wiki/Haskell_class_attack_transport
20:46:17 <EvanR> ._.
20:47:25 <makmanalp> tolkad: Many of the Haskell-class were scrapped in 1973-75.
20:47:27 <makmanalp> heh
20:49:22 <tolkad> darn it, it doesn't make any sense to implement fromRational for my vectors
20:49:35 <tolkad> : / these classes are annoying
20:49:55 <tolkad> any advice?
20:49:59 <EvanR> how are vectors Fractional
20:50:05 <tolkad> you can divide them
20:50:14 <EvanR> no you cant
20:50:21 <tolkad> oh I thought you could
20:50:55 <EvanR> theres inner product, and scalar multiplication
20:52:34 <Veinor> yeah, vector division is not a useful operation
20:53:38 <dobblego> should I introduce a dependency on category-extras just for the Copointed type-class?
20:56:33 <tolkad> dobblego: it depends how much you want the copointed type-class
20:56:43 <dobblego> I want it bad
20:56:57 <dobblego> I think I'll do it; 'll prolly need more category-extras
21:00:41 --- topic: '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:00:41 --- topic: set by dons!~dons@archlinux/developer/dons on [Thu Jul 22 16:55:49 2010]
21:00:41 --- names: list (clog Zeiris_ Adlai_ dleslie |marius| lispy romanandreg derferman gcross otto_s_ seafood sfwc m-i-l-a-n tavelram codolio nettok quasimodo_ zachk conal amon_ zooG danbrown smorg _Ray_ Olathe Apocalisp dropdrive scotty novas0x2a dfkjjkfd JoeyA tolkad orlandu63 tensorpudding old_sound JuanDaugherty trin_cz c_wraith Guest14478 TML siplux DrSyzygy flori Phyx- QinGW ttmrichter jsgf xcthulhu Torrieri Benny_ dancor edwtjo Anarch Walt CakeProphet ozamosi|netbook bens)
21:00:41 --- names: list (kermit mwc dobblego regalia rl fryguybob emmanueloga Mathnerd314 theorbtwo ulfdoz JabDesign horms dankna kniu Dashkal FunctorSalad_ wuehlmaus Gracenotes Rotaerk brntbeer _gaffer alexsuraci miclorb_ tg_ kfish jsnikeris Draconx|Laptop dual klugefoo m3ga roconnor iFire nominolo_ LouisJB tessier Aikawa marienz grahamalot leifw augur mpiechotka dnolen tommd bqf lbc Itkovian jethomas welterde pikhq polux_ programble cheater99 somnium Eridius pprakash saccade bbee)
21:00:41 --- names: list (hgolden tamiko mq jix seric cYmen chrisdone copumpkin shapr path[l] mafs jbauman ddarius jystic fonz Colours siracusa amiri Philippa stepnem gogonkt xinming_ d00m ankit9_ NNshag bd_ tobier gds jmreardon levitation_ wli mvid joed boyscared wisemanby ksandstr s76__ jendap qz paperkettles industrial hackagebot slaye akosch Samy vili avenge scm od_ htoothrot makmanalp Axman6 cyanoacry hamishmack cognominal dilinger palmje Nereid mdmkolbe karld jaj rokoteko pesco)
21:00:41 --- names: list (niksnut bremner GTXL94 dfeuer anders_ ibt andrewsw jedai Taggnostr afarmer wto ketil tarleb Associat0r liyang zax freedrull cozmic_ PepeSilvia chitragupt Ytinasni JaffaCake lsthemes RyanT5000 joelburget2 Krimpet mm_freak MadX` deavid companion_square And[y] tomaw keseldude jao danderson eevar norm2782 Rooz dionoea monochrom niko AnMaster jmcarthur glith mquin PsiOmega Jonno_FTW stenobot2010 ninegrid hzh scott_ catenate1 alexbobP helgikrs jsk eyck Cale dixie)
21:00:41 --- names: list (SimonRC shepheb Berengal jql jonafan jml iratsu dMazz preflex mauke Twey quaestor minsa Botje Amadiro EvanR alpounet stalker vanadium jmad980 Nanar ricky stroan etpace aempirei pchiusano EvanR-work derekwright aasmith_ dibon Counter-Strike u_quark shutdown_-h_now dmwit profmakx jamii MacCoaster suiside Bleadof eagletmt EvanCarroll wang IceDane magcius mroessler parek tilman edwinb jesusabdullah HugoDaniel sad0ur mats_ Igloo Arnar CompanionCube magicman burp)
21:00:41 --- names: list (art[] endojelly elliottcable mietek nniro muep Saizan srh dcolish ray smly- Laney Heffalump scree ToRA bill`` Yahovah nothingmuch QtPlatypus sohum Sisu Starfire snr nzfrio rigpa birkenfeld nornagon canvon sshc dqd ps-auxw Polarina Veinor sbahra thetallguy1 RogueShadow mlh tab vpetro lukish cypher- FauxFaux regulate kadoban gereedy emma drk-sd dcoutts_ pwerken septic helge olsner kevinclark caligula__ cncl saiam araujo solrize ville hvr manjunaths mattam)
21:00:41 --- names: list (fpletz laz0r Jiten hellige Guest42356 ibid shachaf albertosantini Baughn kaol lenbust mfoemmel ahf nasloc__ noj nominolo mornfall Ferdirand creichen McManiaC c3l mux dreixel trez srcerer ihckt dju epmf quicksilver clanehin flux chr1s_ Vq gdsx OnionKnight b4taylor igorgue_ yottis opqdonut sajkr inr Ke kalven zygoloid dons deadguys go|dfish samulihs Innominate sbok chromakode dumael mjrosenb cizra desu ido davidL sproingie davean AnAdorableNick Vulpyne idnar)
21:00:41 --- names: list (osfameron benmachine tvaalen BONUS mercury^ cynick @ChanServ _br_ nimred shawn_ koala_man wagle aristid joga electrogeek fabjan dino- eintopf jb55 tromp_ felipe_ alip erk__ encryptio Raevel ahihi arw jvogel drhodes exDM69 Raku^ kosmikus Liskni_si p_l aiks Aisling noddy Deewiant agemo lomeo thorkilnaur ptrf hc_e erg defn Ornedan luite ath ClaudiusMaximus tew88 thedward jamwt Fingerzam ivan mrd earthy emias majoh mrshoe ehamberg jlouis willb1 ski harlekin tmug)
21:00:41 --- names: list (rdrake zaz\ MasseR g_cross pastorn djahandarie duairc PHO_ obraun milli shortcircuit jrockway sageh^ taruti zsol ezrakilty jd10 nchaimov kloeri wjt Gabbie Obfuscate teukka drewr allbery_b inittab Blub\0 `0660 jayne integral dejones Jaak byorgey ernst biiter dcoutts Tomas Cthulhon cjay ezyang geekounet tltstc mee Fireknight plimsoll Zao okp qebab CalJohn_ Scala_ int-e guerrilla jdsc Lemmih impl lucca hiredman chid|sigma CosmicRay absentia poucet kakos BrianHV)
21:00:41 --- names: list (StoneToad nlogax idoru DustyDingo solidsnack twmi teratorn newsham koninkje_away Valodim joni6128 cods Khisanth cathper thoughtpolice benc___ zakwilson yahooooo netcat)
21:00:41 -gibson(freenode.net)- [freenode-info] help freenode weed out clonebots -- please register your IRC nick and auto-identify: http://freenode.net/faq.shtml#nicksetup
21:01:50 <EvanR> libraries arent extensions
21:02:42 <tolkad> EvanR: PHP, for example, has many extensions that are really just libraries
21:03:28 <tolkad> welcome back
21:04:20 <EvanR> ah php 
21:04:20 <EvanR> our favorite subject
21:04:57 <kmc> oh no netsplit
21:05:27 <heatsink> Why would it be that importing module M (not from a package) causes TH to load package P, but importing everything in M's import list doesn't cause TH to load package P?
21:05:37 <heatsink> TH=Template Haskell, M and P are free variables
21:05:54 --- mode: gibson.freenode.net set +o ChanServ
21:06:45 <unkanon> can anyone help me fix this wikibook example? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28264#a28264
21:07:17 <unkanon> it now says: password.hs:9:22:     The last statement in a 'do' construct must be an expression
21:08:28 <tolkad> I don't think you can define return...
21:08:30 <heatsink> unkanon: The indentation of the last statement in the "do" block is wrong.  It's parsed as being part of the first statement.
21:08:37 <IceDane> What happened to verboseCheck in QC2?
21:08:56 <heatsink> unkanon: I think the problem is on line 12
21:09:07 <heatsink> unkanon: You inserted two lines at the top of the file, right?
21:09:12 --- mode: gibson.freenode.net set +o ChanServ
21:09:54 <unkanon> heatsink: i can't get the indentation right
21:10:12 <Veinor> unkanon: you need to deindent line 12
21:10:13 <heatsink> Stop splitting!
21:10:18 <Veinor> so that case lines up with the word maybe
21:10:54 <unkanon> Veinor: i've tried that and it still doesnt work, can you paste a working version?
21:11:27 <heatsink> unkanon: I use haskell-mode in emacs.  It autoindents, which makes editing much faster.
21:12:01 <unkanon> well i still can't get it right, and it's already indented like you said :(
21:12:08 <Veinor> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28264#a28265
21:12:16 <Veinor> ta-dah
21:12:50 <Veinor> oh, wait
21:13:19 <unkanon> how do i make that work? i can't do main = askPassword because they're different types
21:13:19 <Veinor> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28264#a28266
21:14:16 <tolkad> how do I set tab width in GHC?
21:14:30 <jmcarthur> tab width?
21:14:47 <jmcarthur> tolkad: when writing haskell it's typically best to just use spaces
21:14:49 <heatsink> unkanon: What's the type of (runMaybeT askPassword)?
21:15:06 <jmcarthur> tolkad: i don't think tab width is configurable (it's 8 spaces i believe, but could be 4)
21:15:11 --- mode: gibson.freenode.net set +o ChanServ
21:17:22 <heatsink> > let setTabWidth n = putStrLn . concatMap (\c -> if c == '\t' then replicate n ' ' else [c]) =<< getContents
21:17:25 <unkanon> heatsink: oh ok
21:19:14 --- mode: gibson.freenode.net set +o ChanServ
21:19:39 <unkanon> heatsink: it is now complaining that line 9 has No instance nor default method for class operation GHC.Base.>>=
21:19:39 <unkanon> i'm just trying to get this to run
21:19:39 <unkanon> it's wikibook's code
21:20:17 <heatsink> unkanon: The link scrolled away, repost it again
21:20:25 <heatsink> Oh hey, NickServ finaly noticed me
21:21:13 <unkanon> heatsink: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28264#a28267
21:21:20 <heatsink> thx
21:22:10 <heatsink> unkanon: the definition of (>>=) on line 12 should be part of the instance declaration 
21:22:27 <heatsink> So it should be indented to the same level as the definition of return
21:23:37 <unkanon> heatsink: still the same error on line 12
21:24:08 <heatsink> unkanon: Did you indent the entire function by the same amount?
21:25:42 <unkanon> heatsink: yessir
21:26:28 <ddarius> Veinor: Division of vectors is fine, you just need an algebra and not just a vector space.  Making such an algebra, though, requires going beyond merely vectors.
21:26:45 <trimeta> Is this the place to ask why cabal isn't compiling for me on Gentoo?
21:26:55 <heatsink> unkanon: I don't get an error
21:26:56 <ddarius> Incidentally, u/v is the spinor that rotates and scales v into u.
21:28:03 <trimeta> And if not, where should I go?
21:28:53 <unkanon> heatsink: can you paste your working code?
21:29:04 <heatsink> unkanon: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28264#a28268
21:29:21 <ddarius> trimeta: Here is probably fine.  Ask your question.  Someone will, eventually, answer.
21:29:47 <trimeta> OK. I'll probably just ask my question and go to sleep, then; I'll check in the morning for answers.
21:29:59 <unkanon> heatsink: thanks!
21:30:43 <trimeta> Basically, I had been trying to figure out why xmobar was crashing with a "setup: At least the following dependencies are missing: base ==4.*" error, and someone over in #xmonad told me to upgrade from ghc-6.8.2 to ghc-6.12.3. But when I did so and tried recompiling cabal, it failed.
21:31:16 <trimeta> In particular, after going through all the [? of 54] compile steps, I got "Configuring Cabal-1.6.0.3...", followed by "setup: failed to parse output of 'ghc-pkg dump".
21:31:28 <heatsink> np
21:31:41 <dcoutts_> trimeta: ghc-6.12 comes with (and needs) Cabal-1.8
21:32:02 <trimeta> dcoutts_: Hmm. I guess I'll need to unmask that too...
21:32:04 <dcoutts_> trimeta: the older version of Cabal does not work with the newer ghc (as you found out)
21:32:41 <dcoutts_> trimeta: right, if you're using ~arch Haskell packages you need to do so consistently
21:32:48 <trimeta> Was the person in #xmonad correct in saying that getting a "setup: At least the following dependencies are missing: base ==4.*" error meant that I needed to upgrade ghc?
21:33:03 <dcoutts_> trimeta: yes, ghc-6.8 only has base-3
21:33:23 <dcoutts_> trimeta: so you want ghc 6.10 or 6.12
21:33:45 <trimeta> Anything else notable I'll be needing to unmask?
21:37:55 <unkanon> heatsink: i can almost compile now, i get this weird error: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=28264#a28269
21:38:44 <c_wraith> looks like you need to use --make in the compile command
21:39:58 <mun> hi
21:40:10 <unkanon> c_wraith: thanks, i got it now!
21:41:43 <mun> if I want to express in first-order logic that 'the element(s) in the set with the smallest radius has the value 0', would the following be right? \forall e1 \in S. \forall e2 \in S. Radius e1 <= Radius e2 --> Value e1 = 0?
21:43:39 <c_wraith> No.
21:44:31 <c_wraith> You're saying that for any pair of e1 and e1, radius e1 <= radius e2 implies e1 = 0
21:44:38 <c_wraith> That's certainly not true
21:44:46 <trimeta> Anyway, thanks for your help, dcoutts_.
21:44:46 <heatsink> mun: Counterexample: S = {0, 1, 2}; e1 = 1; e2 = 2
21:45:56 <_Ray_> (Alternatively: Being the smallest element implies that its value is 0)
21:46:14 <mun_> _Ray_, sorry, I got dropped
21:46:24 <mun_> could you repost?
21:46:28 <_Ray_> I didn't say anything else :)
21:46:40 <mun_> oh ok
21:46:56 <_Ray_> c_wraith and heatsink did, however.
21:47:10 <mun_> oh right
21:47:18 <c_wraith> we both said no, because the foralls don't quantify the way you want.
21:47:50 <mun_> c_wraith, right. i thought so. how could they be properly quantified?
21:48:25 <c_wraith> heh.  I'm not the best to help with this.  I can read first-order logic, but I don't have much practice writing it.
21:48:40 <c_wraith> ....  sad admission for someone with a first-order logic proposition tattoo.
21:49:01 <heatsink> I think you want to say "if there does not exist an element smaller than c1, then..."
21:49:43 <heatsink> c_wraith: A math tattoo, really?
21:50:21 <dabblego> @hoogle Either a b -> a
21:50:21 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
21:50:21 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
21:50:21 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
21:50:24 <c_wraith> yep.  Just your standard unsolved number theory proposition. :)
21:50:54 <heatsink> c_wraith: What will you do if it's proven?
21:51:08 <c_wraith> say "I knew it all along!"
21:51:16 <c_wraith> having it disproven would be more annoying
21:51:17 <_Ray_> \forall e1 \in S (\forall e2 in S e1 = e2 v e2 < e1) \Rightarrow e1 = 0.
21:51:32 <c_wraith> But I could possibly get away with calling it "being old-school"
21:51:46 <heatsink> haha
21:53:48 <c_wraith> something like 1/3 the population of this city has tattoos.  I went for the smaller portion. :)
22:03:17 <Cale> c_wraith: Which problem?
22:03:48 <c_wraith> Goldbach's Conjecture
22:03:57 <Cale> Neat
22:04:21 <gwern> frick! spam on the wiki!
22:06:30 <gwern> why has dog cursed us with this second spammer/
22:08:43 <Cale> I think my favourite unsolved problem in mathematics right now is Hedetniemi's conjecture that the chromatic number of the product of two graphs is the minimum of the chromatic numbers of the graphs.
22:09:10 <kmc> that's pretty cool
22:09:31 <kmc> i like the Hadwiger-Nelson problem too
22:09:46 <Cale> It looks like something which ought to be an easy lemma at first, and the realisation that it's very hard comes slowly :)  One direction of the inequality is trivial.
22:09:59 <c_wraith> This one had the advantage of being compact in first-order logic :)
22:10:05 <c_wraith> also, being utterly useless
22:10:48 <Cale> Ah, the chromatic number of the metric graph of R^2, yeah, that's a neat problem.
22:10:52 <gwern> well, at least this spammer only spams a user page
22:10:54 <_Ray_> c_wraith: What is the actual proposition? (I'm trying to think how to compactly express "prime")
22:11:11 <gwern> and this time I made sure to do checkuser *before* I deleted the user page, so I could block their IP too
22:11:32 <gwern> (seriously mediawiki why can't you do checkuser on a user whose contributions have all been delet4ed?_
22:12:51 <c_wraith> _Ray_, long enough to make typing it tough.  but you can express prime as "not the product of two numbers > 1"
22:12:58 <c_wraith> well.  that's *almost* prime.
22:13:13 <c_wraith> that definition happens to include 1, but meh. :)
22:21:59 <tolkad> uh hi
22:22:21 <tolkad> is there anyway to make a function raise an error at compile time if someone tries to call it?
22:22:27 <tolkad> I have these vectors...
22:22:36 <tolkad> and don't know what to do about fromInteger
22:24:55 <tolkad> I'm guessing no...
22:25:14 <tolkad> so uh.. how would it make sense to convert an integer into a vector?
22:26:44 <kmc> tolkad, yeah, Num is an unfortunate type class
22:26:54 <kmc> in that it often forces you to implement things which don't make sense
22:26:58 <kmc> it should eventually be split up
22:27:00 <ddarius> Wouldn't ‚àÉe‚ààS.radius(e) = 0 suffice for mun's proposition?  
22:27:21 <kmc> anyway, you can throw a runtime error
22:27:22 <tolkad> I would preferÀö‚àÜ‚â•‚â•‚â§ÀúÀô¬®¬®¬®¬®‚â§‚â•.radius
22:27:32 <mun> ddarius, well, Radius and Value are two individual functions
22:27:35 <kmc> and also attach a deprecation warning using a pragma
22:27:47 <kmc> or another kind of warning probably more appropriate
22:27:48 <ddarius> mun: Ah.
22:27:59 <mun> ddarius, the radius(e) acts like a constraint on which 'e' to select
22:28:00 <kmc> in general, the compiler can't tell at compile time if a particular function will be called
22:28:03 <tolkad> kmc: uh how do you do that?
22:28:15 <kmc> you google "ghc warning pragma"
22:28:48 <kmc> "Àö‚àÜ‚â•‚â•‚â§ÀúÀô¬®¬®¬®¬®‚â§‚â•.radius"  -- i don't get it
22:29:05 <kmc> did you have a seizure or something
22:29:24 <tolkad> kmc: He just put random characters before radius, does haskell even support unicode characters in code? 0_o
22:30:04 <kmc> "‚àÉe‚ààS.radius(e) = 0" is a well-formed mathematical statement
22:30:21 <kmc> i don't think it was meant to be haskell code
22:30:26 <kmc> also, Haskell does support unicode characters in code
22:30:39 <kmc> Haskell source files are always in UTF-8 encoding, i believe
22:31:02 <tolkad> kmc: oh, interesting. I have never seen the ‚àÉ symbol before
22:31:03 <kmc> > let œÄ = pi in œÄ^2
22:31:05 <lambdabot>   9.869604401089358
22:31:14 <kmc> tolkad, it means "there exists"
22:31:34 <kmc> that statement means "there exists some e in the set S such that radius(e) equals 0"
22:31:57 <kmc> ‚àÉ means "there exists", ‚àÄ means "for all"
22:35:29 <pikhq> tolkad: Sadly, these things aren't generally taught outside of college courses. Even though it's really basic mathematics.
22:36:41 <kmc> tolkad, http://en.wikipedia.org/wiki/Table_of_mathematical_symbols
22:36:50 <jesusabdullah> Some people also just prefer to write them out
22:36:53 <jesusabdullah> even in college courses
22:36:58 <jesusabdullah> Just depends on one's style
22:37:08 <tolkad> pikhq: I have yet to take college calculus, they made me take 2 precalculus courses as prequisites even though I already took that in high school
22:37:17 <ddarius> pikhq: Relying on college courses is a fool's approach.
22:37:44 <jesusabdullah> Also: Nobody in college actually sat me down and gave a "NOTATION TIME!" lecture. I found those out from context.
22:37:48 <tolkad> ddarius: If I ever had the need to use them I would learn them.
22:37:54 <pikhq> ddarius: Yeah, I'm more just irritated that something as basic as that isn't in, y'know, middle school or something.
22:38:00 <tolkad> ddarius: and I will eventually learn them anyway when I take the course
22:38:00 <jesusabdullah> Also the mapping notation (R --> R for example)
22:38:04 <kmc> a lot of maths textbooks have a table of notation in the front
22:38:13 <pikhq> Of course, I'm completely and utterly annoyed at public education mathematical curriculum.
22:39:01 <pikhq> (would it *kill* them to teach anything but calculation and formulae?)
22:39:20 <_Ray_> didn't you hear? math isn't fun. it has to be memorized, there's no other way.
22:39:47 <_Ray_> now repeat after me. the sum of the squares of the cathets is equal to the square of the hypothenuse.
22:40:00 <Veinor> tolkad: ... cathet?
22:40:07 <Veinor> ... how did that tolkad get there
22:40:18 <_Ray_> *cathetus :)
22:40:25 <_Ray_> (translating from Spanish, sorry!)
22:40:28 <jesusabdullah> hah
22:40:29 <jesusabdullah> sides?
22:40:31 <Veinor> I didn't even know that's a word!
22:40:39 <jesusabdullah> legs?
22:40:47 <Veinor> wikipedia says 'leg'
22:40:51 <pikhq> I've *heard* it, but... that's all.
22:40:57 <jesusabdullah> I found that "the distance formula" made more sense than the pythagorean theorem
22:41:01 <jesusabdullah> if that makes sense
22:41:38 <pikhq> It also bothers me that the formulae are not really... Proven at all.
22:42:09 <pikhq> Particularly not simple ones. Pythagorean theorem is proven via a freaking picture of some triangles and squares.
22:42:14 <_Ray_> sometimes it's inevitable. the usefulness of the fundamental theorem of algebra usually comes before knowing how to prove it.
22:42:32 <ddarius> Proving it is fun though.
22:42:49 <pikhq> _Ray_: Yes, but most of the time, the proof would be simple to give.
22:42:57 <pikhq> And quite often, a proof will lead to greater understanding.
22:43:04 <ddarius> But proof is sorely neglected in high school and undergraduate mathematics curricula.
22:43:04 <jesusabdullah> pikhq: How do you prove pythagorean theorem anyway?
22:43:22 <_Ray_> I like the "square whose sides are the hypothenuse" one.
22:43:23 <jesusabdullah> As an engineer, I often think that plausibility arguments are sometimes enough.
22:43:41 <pikhq> jesusabdullah: http://upload.wikimedia.org/wikipedia/commons/d/d2/Pythagorean.svg
22:43:45 <pikhq> Bamf.
22:43:50 <pikhq> :P
22:43:58 <jesusabdullah> Ah, but that's the "freaking picture"
22:44:17 <jesusabdullah> Any proof I can think of would involve trig identities or something, and I'm not sure that's better
22:44:19 <_Ray_> well, we have to use pictures at some point, because they let us use euclidean geometry.
22:44:28 <_Ray_> it's false in non-euclidean geometries, IIRC
22:44:28 <ddarius> That picture is not a proof.
22:44:38 <pikhq> Argh, right, it's not the proof.
22:44:45 <_Ray_> http://upload.wikimedia.org/wikipedia/commons/9/96/Pythaproof.PNG <-- the one I use
22:44:47 <ddarius> _Ray_: You don't need pictures to do Euclidean geometry.
22:44:48 <pikhq> It's related to it, but.
22:45:13 <ddarius> jesusabdullah: There are -hundreds- of proofs of the Pythagorean theorem.
22:45:17 <jesusabdullah> Pictures are nice because they're concrete. People are very good at holding 2-d and even 3-d representations of things in their head.
22:45:26 <jesusabdullah> ddarius: But an easy one for middle schoolers?
22:45:32 <pikhq> Yes.
22:45:34 <ddarius> jesusabdullah: Dozens.
22:45:36 <ddarius> At least.
22:45:47 <_Ray_> area of the big square = (a+b)^2. area of the inner square = c^2. area of the 4 triangles = 4 * a*b/2 = 2*ab. then, (a+b)^2 = a^2 + 2ab + b^2 = c^2 + 2*ab <=> a^2 + b^2 = c^2.
22:46:30 <pikhq> It can in fact be be shown by moving some shapes around.
22:47:06 <_Ray_> ddarius, I don't, right. What would be a simple-to-express axiom that I could use to prove this entirely algebraically?
22:47:18 <_Ray_> The fifth postulate seems kind of hard to mix into proofs.
22:47:51 <ddarius> _Ray_: I'm not saying it's -better- to avoid pictures, but pictures are not required nor do they necessitate Euclidean geometry.
22:48:05 <_Ray_> right right, I agree
22:48:25 <ddarius> Hilbert made a reasonable formal system for Elements, though you'd still want a panoply of theorems to draw upon.
22:48:34 <jesusabdullah> _Ray_: That's the sort of proof I had in mind. I'd never actually seen that. Thanks.
22:48:42 <kmc> i have a program which is like ¬´main = x1 >> x2¬ª; x1 and x2 are totally unrelated and come from separate modules that don't export anything else.  this program exhausts my machine's memory, but "main = x2" by itself does not.  any idea what's going wrong or how to fix it?
22:49:30 <kmc> i should add that "main = x1" also works, and the effects from x1 are performed with "x1 >> x2" before it dies; the exhaustion is during execution of x2
22:51:15 <ddarius> Tarski apparently made one as well.
22:51:37 <kmc> am i right in thinking that updates to CAFs are never garbage collected, because a module's top-level bindings are always roots?
22:51:41 <kmc> or is that incorrect?
22:51:54 <c_wraith> That would be my assumption...
22:54:16 <ddarius> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/CAFs
22:54:34 <Cale> The list of axioms in Elements is sorely incomplete. The very first proposition in the first book, the construction of an equilateral triangle doesn't actually work, because none of the axioms guarantee that the two circles have a point in common.
22:55:48 <ddarius> Cale: There's a paper about this suggesting most of the "missing" axioms are topological ones implied by the diagrammatic constructions.
22:57:34 <kmc> thanks ddarius
22:57:50 <kmc> so CAFs can get GC'd
22:58:39 <ezyang> interesting. 
22:58:47 <ezyang> I've always wondered how GHC managed those 
22:59:03 <solrize> speaking of logic, did anyone see the thing in ndm's recent supercompilation article saying that the termination proof for previous supercompilers used kruskal's tree theorem?  (supercompilers do tree rewriting). 
22:59:19 <solrize> that theorem can't be proved in peano arithmetic, i.e. the # of steps has a completely insane rate of growth
22:59:55 <ddarius> Cale: This was the paper if you are interested: http://journals.cambridge.org/repo_A674ohNM
23:00:44 <ddarius> solrize: Just because a big hammer is used doesn't mean a big hammer is necessary.
23:01:25 <solrize> well the termination condition is homeomorphic embedding which is exactly what kruskal's theorem proves...
23:01:45 <ezyang> There should more editions of "Evolution of a Haskell programmer" 
23:01:51 <solrize> hee
23:02:13 <solrize> ddarius, that article (avigad et al) looks interesting
23:03:06 <ddarius> solrize: It's rather long and I never read all of it.  It also may not be quite what you are expecting.
23:03:38 <solrize> hmm ok
23:09:58 <dolio> Termination of System F can't be proved in peano arithmetic.
23:10:31 <kmc> how do you prove that?
23:11:01 <kmc> what about termination of STLC?
23:11:16 <dolio> Possibly by showing that termination of System F is equivalent to the consistency of Peano arithmetic.
23:12:05 <dolio> I'm not sure what STLC is equivalent to.
23:13:12 <kmc> hehe
23:13:13 <kmc> clever
23:21:48 <pswoo> is Pappy the only packrat generator in town for haskell?
23:22:15 <dolio> Oh, actually, normalization of System F implies the consistency of second-order arithmetic.
23:22:44 <dolio> pswoo: As far as I know.
23:22:57 <dolio> There's frisby, but it's not a generator.
23:24:03 <chrisdon`> i packed that up and put it on hackage
23:24:20 <chrisdon`> reminds me, i was going to package pappy up and put it on hackage too
23:25:09 <pswoo> i'm guessing it doesn't have a maintainer (pappy)?
23:25:36 <chrisdon`> it has the guy who made did his degree or PhD with it, but i don't think he'll be maintaining it
23:25:46 <chrisdon`> http://pdos.csail.mit.edu/~baford/packrat/thesis/
23:27:51 <pswoo> i read the thesis a week or two ago, but might have run into a bug so was just wondering
23:30:39 <chrisdon`> a bug?
23:30:59 <chrisdon`> I just emaled Bryan asking if he would maintain it or not
23:31:32 <chrisdon`> perhaps you could maintain it if you are confident with the code base
23:38:43 <pswoo> perhaps.. it crossed my mind (the code looks fairly straightforward, after having read his paper)
23:41:20 <pswoo> though i have no experience in that realm. are you working on / keeping any projects atm?
23:46:00 <chrisdon`> pswoo: i have a few yeah
23:48:19 <solrize> pswoo,  there is at least one more afaik
23:48:32 <solrize> there is a japanese json parser that uses itt
23:48:33 <solrize> it
23:51:50 <chrisdon`> j-san
23:53:12 <kmc> haha
23:53:21 <mm_freak_> isn't there a combination of type system extensions, which allows to turn 'Monad m => MArrow m' into an arrow directly, where type MArrow m a b = a -> m b?
23:53:46 <mm_freak_> having to wrap everything in Kleisli makes this extremely ugly
23:55:24 <mm_freak_> or is there a way to make this Kleisli wrapping implicit?  something like OverloadedMonads?
23:55:31 <kmc> instance (Monad m) ‚áí Arrow (Œªa b. a ‚Üí m b)
23:56:01 <kmc> you'd need to be able to declare instances for arbitrary type-level functions
23:56:05 <kmc> which is what a partially-applied synonym is
23:56:29 <mm_freak_> yeah, but TypeSynonymInstances still insists on having all three arguments
23:57:04 <dibblego> is there a GHC extension to get "case of" to expand to "\x -> case x of" ?
23:57:14 <kmc> yes, the theory is much more complicated if you allow partially-applied synonyms in instances
23:57:20 <kmc> dibblego, not yet that i know
23:57:32 <kmc> could be a pretty easy external preprocessor, though
23:58:00 <Gracenotes> dibblego: there's a haskell prime page for that
23:58:07 <dibblego> ah that's where I saw it
23:58:25 <Gracenotes> it's not that unintuitive of a syntactical leap to make
23:58:36 <kmc> i think it's odd to introduce an anon function with "case" rather than \
23:58:40 <Gracenotes> especially since I use explicit case statements all over the place...
23:58:49 <kmc> rather have one marker for that
23:58:50 <dibblego> Scala has something like it and it's very handy
23:59:00 <kmc> but "\case" loks silly too
