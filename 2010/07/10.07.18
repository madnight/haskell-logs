00:00:18 <Zao> The IO mo nad?
00:00:49 <koninkje> edwardk: were you using the iteratee package for your iteratee stuff? If so, do you have an instance for ByteString chunks laying around?
00:03:03 <lispy> koninkje: there is one, WrappedByteString
00:03:13 <lispy> koninkje: I forget where it's located
00:03:20 <lispy> ?hoogle WrappedByteString
00:03:20 <lambdabot> No results found
00:03:34 <koninkje> I figured there should be, but couldn't find it...
00:03:39 <lispy> koninkje: http://hackage.haskell.org/packages/archive/iteratee/0.3.5/doc/html/Data-Iteratee-WrappedByteString.html
00:04:11 <koninkje> lispy++
00:13:18 <qwebirc40728> When I import the Control.Monad.State module, is that the lazy one or the strict one?
00:15:29 <etpace> Strict
00:15:33 <etpace> Or wait, lazy
00:15:34 <etpace> :p
00:15:49 <etpace> use use .Strict for strict
00:17:00 <qwebirc40728> I can't tell from the documentation.
00:17:28 <qwebirc40728> And regarding the mapM return [1..] question, I think I found the explanation for why it doesn't returnin GHCI here: http://sites.google.com/site/haskell/notes/Monad-Laziness-Strictness
00:17:28 <etpace> http://www.haskell.org/ghc/docs/6.10.3/html/libraries/mtl/Control-Monad-State.html
00:20:37 * hackagebot container-classes 0.0.0.0 - Generic classes for interacting with different container types  http://hackage.haskell.org/package/container-classes-0.0.0.0 (IvanMiljenovic)
00:28:39 * hackagebot wai-handler-snap 0.0.0 - Web Application Interface handler using snap-server.  http://hackage.haskell.org/package/wai-handler-snap-0.0.0 (MichaelSnoyman)
00:30:39 <ivanm> @tell edwardk http://hackage.haskell.org/package/container-classes-0.0.0.0
00:30:39 <lambdabot> Consider it noted.
00:30:56 <ivanm> time to pack up and head off... :(
00:47:45 <Figs_> I've finally realized something important. I don't understand GHC's type error messages.
00:49:08 <Figs_> What exactly do "expected" and "inferred" mean in a type mismatch error?
00:49:52 <Figs_> And is there any way to get GHC to say how it is arriving at particular deductions?
00:50:05 <Heffalump> inferred is the type of the expression, inferred is the type the context of the expression implied
00:50:34 <Figs_> You just wrote inferred twice...
00:50:38 <Heffalump> ahem
00:50:43 <Heffalump> inferred is the type of the expression, expected is the type the context of the expression implied
00:50:49 <Heffalump> sorry :-)
00:50:55 <Figs_> :)
00:51:24 <Heffalump> > 'char' ++ "string"
00:51:25 <lambdabot>   <no location info>:
00:51:25 <lambdabot>      lexical error in string/character literal at chara...
00:51:28 <Heffalump> > 'c' ++ "string"
00:51:29 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:51:30 <lambdabot>         against inferred type...
00:51:49 * Heffalump looks confused
00:52:08 <Heffalump> ghci gives me:
00:52:09 <Heffalump>     Couldn't match expected type `[a]' against inferred type `Char'
00:52:16 <Heffalump> dunno why lambdabot said what it did
00:52:28 <Heffalump> so anyway, [a] is expected because the context is (++)
00:52:44 <Heffalump> and Char is inferred because that's the type of a character literal ('c')
00:53:23 <Heffalump> but GHC won't really go into details for you, I'm afraid
00:53:56 <Figs_> Why doesn't it say something like "(++) has type [a] -> [a] -> [a] but is used with Char and String in expression ..."?
00:54:20 <Heffalump> in part, because of partial application
00:54:34 <Heffalump> (++) 'c' is the thing that fails type checking here, not (++) 'c' "string"
00:55:06 <Heffalump> arguably it could say (++) has type [a] -> ... but is used with Char in expression ...
00:55:10 <Figs_> So why doesn't it say: "(++) c" has type ... but requires type ... in expression ...  ?
00:55:20 <Heffalump> but that is kind of what it means with the 'expected' and 'inferred' language
00:55:56 <Heffalump> the GHC guys are keen on improving their error messages, so if you email glasgow-haskell-users@haskell.org (I think you may need to subscribe first) you might get a discussion going on improving things.
00:55:56 <Gracenotes> Figs_: are you familiar with unification, when it comes to type inference?
00:55:59 <edwardk> Heffalump: probably because i think cale has lambdabot treating (++) as mappend
00:55:59 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
00:56:12 <Heffalump> edwardk: ah, right. Grmph.
00:56:43 <Figs_> Gracenotes: To a certain extent. I have taken a class where OCaml was used. I don't claim to be an expert on type theory though, or the particular details of how it arrives at its deductions.
00:57:46 <Gracenotes> if you program in Hindley-Milner type systems for a bit, you can sort of vaguely go through the algorithm in your head
00:58:06 <Heffalump> Gracenotes: that's not a good advert for the error messages :-)
00:58:29 <Gracenotes> hah, yeah. sometimes error messages are hard to parse at first, but you can get to the root of the cause very quickly in any case.
00:59:01 <Gracenotes> GHC has remarkably friendly messages though, it tells you where the problem is, etc.
00:59:29 <Figs_> To me 'expected' and 'inferred' are nearly synonymous.
01:00:13 <c_wraith> I actually disagree with what ghc means by each of those just about exactly 50% of the time, making it useless for it to label each
01:00:28 <c_wraith> however, it does at least point to the correct spot, usually.
01:00:44 <Figs_> That's sort of my realization just now is that I didn't know which was which :)
01:00:48 <Gracenotes> I think 'infer' has a jargon-y meaning here, inferring an /expression/
01:01:30 <c_wraith> Is there an obvious place I'm missing where ghc tells me the size of an int?
01:01:32 <napping>  I think GHC is quite consistent
01:01:48 <napping> in saying "expected" for the type coming from the context, and "inferred" for the type coming from the inside
01:02:28 <Gracenotes> GHC fits programs together like a type puzzle. when you tell it to put a puzzle piece somewhere but the edges don't match, it describes the bad puzzle piece in "inferred" and tells you what the shape of the the piece *should* be in "expected"
01:02:36 <Figs_> It's quite likely that the stuff in my head is not consistent, and has just managed to fudge through it without me really thinking about it so far. :)
01:02:53 <Gracenotes> however sometimes it doesn't have all the surrounding edges, so "expected" might not be as specific as you might want it to be
01:03:23 <Gracenotes> but anyway it looks pretty if you get it right
01:03:26 <c_wraith> how do I set a pragma on a typeclass method?
01:05:06 <Figs_> Well, I got an error "Couldn't match expected type '[String] -> SourcePos' against inferred type 'SourcePos'" and I have no idea what's actually wrong at the moment. :)
01:05:22 <c_wraith> That one means you didn't apply enough arguments
01:05:56 <c_wraith> In particular, you forgot to give a list of strings to some function that wanted it, and returns a SourcePos
01:06:44 <c_wraith> It's common for that particular problem to be caused by lack of parenthesis in beginner code.
01:07:22 <c_wraith> Oh, actually, I think I had it backwards.
01:07:24 <c_wraith> again
01:07:38 <c_wraith> I think you are applying a list of strings to something that isn't a function
01:07:45 <Gracenotes> are there clearer words than 'expected' and 'inferred'?
01:08:03 <c_wraith> how about "expected" and "found"
01:08:07 <Gracenotes> 'Required type' and 'Found type'?
01:08:19 <Figs_> The only way I can think of is if it says how it arrived at each deduction
01:08:39 <napping> Figs_: "expected" means it's in a context like (_ ["Foo","Bar"] :: SourcePos)
01:08:53 <napping> so it's being applied and needs to be a function from strings to sourcepos
01:08:56 <Figs_> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#tokenPrim <-- this is the function I'm trying to use
01:09:10 <napping> and the inferred type means the expression seems to be just a SourcePos
01:09:16 <napping> so, maybe too many arguments?
01:09:33 <Figs_> In particular it's having trouble with nextPos
01:09:44 <Figs_> Since I told it to do
01:09:44 <Figs_> nextPos  = updatePosString
01:10:21 <Zao> I remember being equally confused back in my mosml days.
01:10:35 <pastorn> is this blocking? readChan :: Chan  a -> IO  a
01:10:36 <Zao> Type clash: expression of type Foo cannot have type Bar.
01:10:37 <Gracenotes> it's usually easier to see why it came to the "inferred" deduction. because that's derived mainly from the expression itself.
01:10:46 <c_wraith> pastorn, that function will block
01:10:52 <pastorn> c_wraith: awesome :)
01:10:59 <pastorn> oh wait
01:11:01 <pastorn> no it's not
01:11:04 <pastorn> fuck
01:12:12 <Zao> pastorn: Isn't it normally implemented in terms of readMVar? Which does block.
01:12:27 <pastorn> Zao: yeah, i guess it is
01:12:35 <pastorn> the thing is that i have 2 chans
01:12:46 <pastorn> one which i get all my GUI events from
01:12:55 <pastorn> and one which i get data to visualize from
01:13:06 <triyo> Whats the easiest way to parse a String representation of Date/Time to ClockTime?
01:13:10 <pastorn> and i want to update on both
01:13:28 <Zao> Multiplex them onto a single chan?
01:13:50 <pastorn> haha, ugly as hell, but why not :)
01:14:00 <Zao> I'd spin off two threads, one that reads from one channel and puts onto the commmon, and the other doing the same for the other channel.
01:14:44 <Gracenotes> I'm pretty sure it's a simple change to have tryTakeMVar instead of just takeMVar in Chan operations
01:15:00 <Zao> Gracenotes: Is it a desirable change though.
01:15:04 <Zao> s/./?//
01:15:12 <pastorn> using isEmptyChan is the wrong way, right?
01:15:22 <Gracenotes> yes, there's no safe way to peek the top of the list
01:15:24 <c_wraith> isEmptyChan will block in some cases, too!
01:15:30 <pastorn> wat?
01:15:40 <pastorn> chan unification it is then
01:15:44 <Gracenotes> I'm pretty sure isEmptyChan won't block, but it might give you race conditions
01:15:52 <c_wraith> isEmptyChan will block if there's another thread blocked on readChan
01:15:56 <c_wraith> Which is a bug, yes
01:16:25 <Gracenotes> ah. well, in fact it definitely will under any kind of load, interleaving is too easy
01:16:40 <pastorn> i'll just wrap both the datatypes into one and put them in a single chan, then use getChanContents :: Chan a -> IO [a]
01:18:11 <pastorn> btw, how will Chans work with parsed stuff? I have this:
01:18:26 <pastorn> mapM_ (forkIO . join . fmap (writeChan channels) . getAndParse) urls
01:18:42 <pastorn> lazyness here is messing with my head!
01:19:17 <pastorn> it shouldn't write to 'channels' unless the parsing is done, but i don't use deepSeq or anything
01:19:18 <triyo> anyone used parsedate lib? This will solve m date parse problem unless there is something  equivalent in the standard lib?
01:19:37 <c_wraith> Is there some way to control lazy evaluation?  Like, say I have a function that returns ([a], [b]), where both lists are the result of a single computation, and I want to only run the computation far enough to get the next a or b, whichever comes first?
01:20:02 <pastorn> c_wraith: seq?
01:20:26 <c_wraith> pastorn, that doesn't get applied to "the next one of either of these lists, whichever comes first"
01:20:30 <Figs_> Ahh, I think I've figured it out.
01:20:37 <pastorn> oh
01:20:45 <Figs_> The line I needed (for my problem) is:
01:20:45 <Figs_> nextPos pos w ws = updatePosString pos w
01:21:04 <Gracenotes> c_wraith: don't think you can do that for an arbitrary a/b
01:21:23 <c_wraith> I think the only solution is to re-write the function to return a list of Either a b, or the like
01:22:01 <Gracenotes> well, which representation do you want, the one where you only need either an a or a b, or the one where you want an unzipped list of both? :)
01:22:11 <c_wraith> Depends on context, sadly.
01:22:29 <c_wraith> Sometimes I want the unzipped lists.  Sometimes I want a stream of events, essentially
01:23:04 <ClaudiusMaximus> @type Data.Either.partitionEithers
01:23:05 <lambdabot> forall a b. [Either a b] -> ([a], [b])
01:23:36 <Gracenotes> isn't that only in 6.12?
01:23:41 <c_wraith> Sadly, that operation doesn't have a unique inverse
01:23:43 <c_wraith> :)
01:24:00 <Gracenotes> er. well I'm using 6.12 now actually. leavin' 6.10 in the dust yall
01:24:36 <c_wraith> It's getting close to time for 6.14, right?  Only....  4-5 months expected! :)
01:25:36 <pastorn> what are some major changes?
01:25:56 <c_wraith> The type checker is being rewritten, the IO manager is being rewritten...
01:25:56 <Zao> c_wraith: Or is it inferred? :D
01:26:08 <c_wraith> Zao: I don't know!!!! ;)
01:26:22 <pastorn> c_wraith: OutsideIn(X)?
01:26:38 <c_wraith> Oh, and Haskell 2010 support
01:26:47 <c_wraith> ...  Just in time for the end of 2010. :)
01:26:51 <pastorn> haha
01:28:47 <c_wraith> on less theoretical matters...  Is there a value anywhere that happens to contain the size of an int?
01:29:05 <eflister> hi, i'm getting some weird behavior with tryJust not catching an exception...  last line here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27709
01:29:06 <Gracenotes> Haskell 2010 support by another other name would have so many type system extensions
01:29:25 <Gracenotes> any other. :x
01:29:33 <pastorn> c_wraith: sizeof
01:29:39 <ClaudiusMaximus> > logBase 2 (fromIntegral (maxBound :: Int)) :: Double
01:29:40 <lambdabot>   63.0
01:29:55 <c_wraith> :t sizeof
01:29:56 <lambdabot> Not in scope: `sizeof'
01:30:05 <pastorn> @hoogle sizeOf
01:30:05 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
01:30:06 <lambdabot> Network.Socket.Internal sizeOfSockAddr :: SockAddr -> Int
01:30:06 <lambdabot> Network.Socket.Internal sizeOfSockAddrByFamily :: Family -> Int
01:30:14 <ClaudiusMaximus> > ceiling . logBase 2 . fromIntegral $ (maxBound :: Int)
01:30:15 <lambdabot>   63
01:30:20 <Gracenotes> c_wraith: from haskell-cafe. "Ack, I just noticed that IntPtr,IntMax, and WordPtr and WordMax were left out of the report. These are fairly vital for writing portable FFI code."
01:30:26 <pastorn> ClaudiusMaximus: haha... good luck with that :p
01:31:08 <ClaudiusMaximus> > ceiling . logBase 2 . negate . fromIntegral $ (minBound :: Int)
01:31:09 <lambdabot>   63
01:31:12 <Gracenotes> c_wraith: ...which at least tells you what they are, no
01:31:15 <pastorn> hehe
01:31:24 <c_wraith> > ceiling . (/ 8) . logBase 2 . fromIntegral $ (maxBound :: Int)
01:31:25 <lambdabot>   8
01:31:45 <pastorn> > :t sizeOf
01:31:46 <lambdabot>   <no location info>: parse error on input `:'
01:31:51 <pastorn> :t sizeOf
01:31:52 <lambdabot> Not in scope: `sizeOf'
01:31:57 <shachaf> > logBase 2 . fromIntegral . abs $ fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int)
01:31:58 <lambdabot>   64.0
01:32:16 <pastorn> wat?
01:32:22 <pastorn> shachaf: what has science done?
01:32:27 <Gracenotes> fromIntegral :: Int -> Integer
01:32:47 <pastorn> > minBound :: Int
01:32:47 <lambdabot>   -9223372036854775808
01:33:03 <c_wraith> well, I suppose this works.  feels like a hack, but it's never going to be wrong.
01:33:32 <eflister> anyone can help with my exception question above?  :)
01:33:41 <Gracenotes> c_wraith: what happened to IntMax? :x
01:33:42 <shachaf> c_wraith: Ew, don't do that.
01:33:58 <Gracenotes> ooer, though that doesn't give you the size perhaps
01:34:48 <shachaf> Prelude Foreign.Storable> sizeOf (undefined :: Int)
01:34:48 <shachaf> 4
01:35:30 <pastorn> eflister: ehm... i don't get safeList...
01:35:32 <c_wraith> I'm not doing FFI, though.  I'm doing range calculations.  The log approach is actually more correct.
01:35:46 <Gracenotes> shachaf: the problem is that there's no way to specify an instance without a value, even an undefined one
01:36:11 <Gracenotes> er. not a problem that c_wraith is facing but rather one I've run into. :|
01:36:15 <eflister> pastorn: it's supposed to convert any non-total list function that calls error on [] to a Maybe
01:36:25 <Figs_> --<|> is a valid symbol in haskell?
01:36:36 <Gracenotes> yes
01:36:48 <lispy> > let --<|> = 4 in --<|>
01:36:49 <lambdabot>   <no location info>: parse error on input `--<|>'
01:36:55 <Gracenotes> let (--<|>) = (/) in 10 --<|> 4
01:37:00 <ClaudiusMaximus> > let a --<|> b = a + b in 1 --<|> 2
01:37:01 <pastorn> eflister: so basically you're spooning :p
01:37:01 <lambdabot>   3
01:37:08 <Gracenotes> er something like that
01:37:19 <eflister> pastorn: wassat?
01:37:32 <pastorn> check out the *spoon* packages on hackage :)
01:38:21 <Figs_> So comments really start with "-- " then?
01:39:00 <Gracenotes> > "this works" --comment
01:39:01 <lambdabot>   "this works"
01:39:02 <pastorn> Figs_: no, it just can't be any non-alpha, non-num as the first character in the comment
01:39:23 <pastorn> > "lol" --_ lol
01:39:23 <lambdabot>   "lol"
01:39:27 <pastorn> hmmm...
01:39:34 <pastorn> > "lol" --< lol
01:39:35 <lambdabot>   Not in scope: `lol'Not in scope: `--<'
01:39:48 <c_wraith> _ is a letter in haskell's naming scheme
01:39:51 <Gracenotes> the division is that regular identifiers start with a letter or underscore, and may contain any of those (with numbers after first letter)
01:40:20 <Gracenotes> punctuations are the symbol identifiers. those are used infix; so you would say plus 4 3, but 4 + 3.
01:40:28 <eflister> pastorn: spoon looks alright, but i only want to catch empty list errors, not all errors
01:41:10 <Gracenotes> the dash is considered punctuation, so you can have it in a symbol. you can even have -- in a symbol, like .--.  but as a symbol itself, it's instead interpreted as a comment
01:41:21 <Gracenotes> or something like that but stated more clearly
01:41:31 <Figs_> > let a-b = 6 in a-b + 1 -- :p
01:41:32 <lambdabot>   7
01:41:38 <eflister> pastorn: also i'm only teaspooning ;)
01:42:01 <pastorn> eflister: sorry, i suck at exception handling in haskell... i stick to Maybe/Either/similar
01:42:08 <Figs_> In my version of ghci I get "not in scope: 'a', not in scope: 'b'"
01:42:29 <Figs_> Did the parser change recently? (Last year or so?)
01:42:44 <Gracenotes> @type a
01:42:45 <lambdabot> Expr
01:42:53 <pastorn> Figs_: lambdabot is pretty h4xx
01:42:57 <Gracenotes> try 485-349+1, or something
01:42:58 <eflister> pastorn: yeah that's why i want safeList (to hide the exception foo) -- anyone else can help?
01:43:44 <Figs_> > let 485-349 = "wt" in 485-349 ++ "f"
01:43:45 <lambdabot>   "wtf"
01:44:09 <pastorn> @botsnack
01:44:09 <lambdabot> :)
01:44:51 <Gracenotes> hm, is Haskell's sort function more efficient for mostly sorted lists?
01:45:56 <pastorn> @src sort
01:45:56 <lambdabot> sort = sortBy compare
01:46:00 <pastorn> @src sortBy
01:46:00 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
01:46:08 <Gracenotes> that's not the GHC sort
01:46:44 <c_wraith> heh.  That's an insertion sort.
01:46:45 <pastorn> Gracenotes: you asked about haskell's, not ghc's :p
01:47:02 <c_wraith> insertion sort *is* more efficient on near-sorted input!
01:47:08 <Gracenotes> aaaah true enough
01:47:10 <ClaudiusMaximus> Figs_: lambdabot has predefined variables like a b c d e f g, which are shadowed in definition of '-', but on the right hand side of 'in' a and b are taken from the outer scope
01:47:32 <pastorn> > map f [x,y,z]
01:47:32 <lambdabot>   Ambiguous type variable `b' in the constraints:
01:47:33 <lambdabot>    `GHC.Show.Show b'
01:47:33 <lambdabot>      a...
01:47:39 <pastorn> > map f [x,y,z] :: Exp
01:47:40 <lambdabot>   Not in scope: type constructor or class `Exp'
01:47:42 <pastorn> > map f [x,y,z] :: Expr
01:47:43 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
01:47:43 <lambdabot>         against inferred ...
01:47:44 <Gracenotes> though, how can I have a list that's both sorted and indexable
01:47:52 <pastorn> halp?
01:48:06 <Gracenotes> try [Expr]
01:48:12 <ClaudiusMaximus> Figs_: .. the outer scope in lambdabot defines a and b, but ghci doesn't unless you defined them..
01:48:23 <pastorn> > map f [x,y,z] :: [Expr]
01:48:24 <lambdabot>   [f x,f y,f z]
01:48:31 <pastorn> Gracenotes: haha :)
01:49:00 <c_wraith> hmmm.  How bad is it if my random number generator violates referential transparency? >_>
01:49:01 <Gracenotes> 'f x' can not only have the type (Expr), but also (Expr -> Expr), or (Expr -> Expr -> Expr), or whatever else is allowed by its typeclass
01:49:32 <Figs_> ok
01:49:41 <ClaudiusMaximus> in some code i found sorting lists to be slow (using sortBy (comparing snd)), so i did some FFI to C's qsort() which turned out to be quicker...
01:49:56 <Figs_> c_wraith: If you're actually trying to do anything that involves predictably generating random numbers, then it's pretty bad.
01:50:21 <c_wraith> Figs_: It's really all the split function in the RandomGen interface.
01:50:27 <Gracenotes> hm, is there a good histogram data structure out there?
01:50:44 <aavogt> Map Foo Integer?
01:50:47 <Gracenotes> that supports efficient sorting by frequency, updating frequency by key, etc.
01:51:02 <eflister> anyone want to take a look at my exception question above? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27709
01:51:02 <Figs_> c_wraith: For a game I want to write which involves saving points in a time stream, I need to make sure that my random number generator actually gets updated properly, otherwise jumping back in time will cause history to progress differently.
01:51:03 <Gracenotes> Map Foo Integer has the latter but not the former
01:51:23 <c_wraith> Without it, everything fine.  But to support split, I need to either violate referential transparency, or massively damage performance.
01:51:30 <c_wraith> err, everything *is* fine
01:51:42 <Gracenotes> I support I could use two data structures at the same time, but ideally the former should be O(n), and getting the top k should be O(k)
01:51:49 <Gracenotes> s/I support//
01:52:49 <c_wraith> The problem is that the internal state of my RandomGen instance is an infinite list of bytes.
01:53:06 <c_wraith> There's no natural implementation of split for that.
01:53:37 <c_wraith> ...  well, aside from interleaving bytes from the list into two lists, but that's horrible for performance
01:53:56 <ClaudiusMaximus> ... that's what i would do - how often do you need to split?
01:54:19 <c_wraith> I think split is a bad hack to support functions that are written wrong. :)
01:56:02 <c_wraith> Personally, I'll never use split.  But I want this code to be public release quality, even if I decide not to release it.
01:56:33 <Figs_> Why are you writing your own random number generator?
01:56:41 <Gracenotes> eh, is there a pure data structure for a histogram stored sorted by frequency, but also modifiable by key?
01:56:56 * Gracenotes should look around more
01:57:08 <c_wraith> Figs_: I'm actually writing a wrapper for /dev/urandom
01:57:28 <Figs_> That was my guess, but why?
01:58:00 <c_wraith> because sometimes you want crypto-quality random number generation without having to think about getting the algorithms right.
01:58:08 <ClaudiusMaximus> hmm
01:58:18 <c_wraith> Someone already put a lot of effort into making /dev/urandom fast and as good as possible.
01:58:23 <ClaudiusMaximus> @instances-importing Read
01:58:24 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:59:41 <ClaudiusMaximus> ah, it's StdGen that has a Read instance, not a prerequisite of RandomGen
02:01:20 <mornfall> Gah... is there a way to catch Exception: No match in record selector?
02:01:50 <mauke> can't you just fix the code?
02:02:27 <Heffalump> mornfall: yes, in IO like other exceptions..
02:02:39 <mornfall> Prelude `catch` seems to not work.
02:02:49 * mornfall tries Control.Exception...
02:03:05 <Heffalump> Prelude `catch` is rarely the right thing these days :-)
02:03:14 <eflister> speaking of exceptions!  i am getting behavior i don't understand from tryJust -- can anyone help?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27709
02:03:31 <mornfall> Aye, Control.Exception works.
02:04:13 <Heffalump> eflister: it's probably a strictness problem: exceptions are only caught if the value is evaluated in the right scope
02:04:53 <Heffalump> I'm not sure how strict E.evaluate is
02:05:07 <eflister> Heffalump: meaning, the call to evaluate in safeList is too shallow?  it is WHNF.  should i deepseq?
02:06:09 <Heffalump> eflister: I'm not entirely sure, but it's a plausible explanation. Certainly in general I think you'd need to deepseq.
02:06:39 * eflister was recently admonished in this forum for deepseqing
02:07:16 <Heffalump> what are you trying to achieve with safeList?
02:07:35 <eflister> Heffalump: convert list functions that barf on [] to Maybes
02:08:51 <Heffalump> any list function, or just standard Prelude ones?
02:09:33 <Heffalump> I would say that starting again, rather than trying to catch the exceptions, is the better approach. Have you seen the 'Safe' package on hackage?
02:09:39 <ClaudiusMaximus> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/safe
02:13:04 <pastorn> @pl (\f g h -> do { x <- f; y <- g; z <- h; return (f, (g,h))} )
02:13:04 <lambdabot> (line 1, column 15):
02:13:04 <lambdabot> unexpected "{"
02:13:04 <lambdabot> expecting variable, "(", operator or ")"
02:13:13 <pastorn> @pl (\f g h -> do { x <- f; y <- g; z <- h; return (f, (g,h));} )
02:13:13 <lambdabot> (line 1, column 15):
02:13:13 <lambdabot> unexpected "{"
02:13:13 <lambdabot> expecting variable, "(", operator or ")"
02:13:41 <dibblego> don't you mean return (x, (y, z)) ?
02:13:44 <Gracenotes> @type liftM2 (,) f (liftM2 (,) g h)
02:13:45 <lambdabot> forall a1 (m :: * -> *) a11 a2. (SimpleReflect.FromExpr (m a1), SimpleReflect.FromExpr (m a11), SimpleReflect.FromExpr (m a2), Monad m) => m (a1, (a11, a2))
02:13:51 <Gracenotes> @type \f g h -> liftM2 (,) f (liftM2 (,) g h)
02:13:52 <lambdabot> forall a1 (m :: * -> *) a11 a2. (Monad m) => m a1 -> m a11 -> m a2 -> m (a1, (a11, a2))
02:14:08 <Gracenotes> @pl \f g h -> liftM2 (,) f (liftM2 (,) g h)
02:14:08 <lambdabot> (. liftM2 (,)) . (.) . liftM2 (,)
02:14:44 <pastorn> @pl (\f g h -> f >>= \x -> g >>= \y -> h >>= \z -> return (x,(y,z)) )
02:14:44 <lambdabot> (. ((. ((. (((return .) .) . (. (,)) . (.) . (,))) . (.) . (>>=))) . (.) . (>>=))) . (.) . (>>=)
02:14:48 <pastorn> hehe
02:21:57 <yairchu> yo Peaker 
02:22:03 <yairchu> www.soundradix.com
02:22:18 <Peaker> yo
02:22:35 <Peaker> yairchu, did you change it?
02:22:43 <yairchu> oh, I guess not
02:22:48 <yairchu> forgot I already showed ya
02:23:28 <yairchu> heh I thought I was on a different channel
02:25:18 <mornfall> ($>) :: forall rec a. (Data rec, Data a) => (rec -> a) -> [Attribute] -> (String -> [Attribute])
02:25:21 <mornfall> ... how cool is that
02:26:01 <mornfall> (extracts the field name from a record selector)
02:30:43 <drbean> Boolean expressions are allowed as guards on list comprehensions.
02:31:51 <Heffalump> mornfall: eww!
02:32:07 <Heffalump> what's an Attribute?
02:32:10 <mornfall> attrs "recA" $ recA $> [Long ["bla"]] %% recB $> [Long ["foo"]] --> [Long ["bla"]]
02:32:39 <Peaker> @type ($>)
02:32:40 <lambdabot> Not in scope: `$>'
02:32:42 <mornfall> (attrs "recB" then gives [Long ["foo"]])
02:32:51 <mornfall> Peaker: That type is above.
02:33:58 <Araneidae> As a beginner on Ubuntu, what should I install to get started?  The "Haskell Package" looks a bit messed up on Ubuntu, and I don't want to dig myself too deep into a hole!
02:34:10 <Heffalump> You mean the Haskell Platform?
02:34:26 <Araneidae> Sorry, yeah, Platform
02:34:40 <mornfall> Btw. it works by constructing values of type rec with all fields bottom and one non-bottom and then looking which of these values gives the non-bottom under the selector.
02:34:43 <Gracenotes> what I like to do is - sudo apt-get install ghc6 libghc6-dev-http libghc6-dev-zlib
02:34:49 <Peaker> mornfall, Yeah, I thought it was some Functor type like:
02:34:51 <Peaker> @type (<$)
02:34:52 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
02:34:58 <Gracenotes> and then you can install cabal-install from ./bootstrap.sh included in its tarball
02:35:01 <Heffalump> mornfall: double eww
02:35:02 <mornfall> Peaker: Yeah, I guess I need better names.
02:35:14 <Heffalump> Araneidae: what version of the Platform is available?
02:35:15 <mornfall> Heffalump: But it works! :D
02:35:31 <Peaker> mornfall, not every binary function should be an operator :-)
02:35:33 <Heffalump> is this for your command line library?
02:35:36 <Peaker> mornfall, especially not every trinary one :)
02:35:43 <Araneidae> Heffalump, there's no package for the platform, but this web page is discouragin: http://davidsiegel.org/haskell-platform-in-karmic-koala/
02:35:56 <Gracenotes> Araneidae: I tend to avoid ubuntu library packages since they get out of date
02:35:59 <Heffalump> Lucid is the latest, isn't it?
02:36:05 <mornfall> Peaker: Right, but this is a sorta-EDSL for describing program options.
02:36:06 <Araneidae> Gracenotes, I was afraid I was going to have to install stuff by hand...
02:36:15 <mornfall> So eventually, it'll look like
02:36:17 <Araneidae> Heffalump, yeah, 10.04 = Lucid, I think
02:36:24 <Gracenotes> Araneidae: as I said, just the sudo apt-get command above, and install cabal-install from the tarball
02:36:39 <mornfall> myOption %> [Long ["my-option"], Help ["set some preference"]]
02:36:41 <Araneidae> Gracenotes, you recommend compiler packages + cabal-install from wherever I find it...
02:36:51 <Peaker> Araneidae, my experience is that "installing by hand" is the easiest option :)
02:36:52 <mornfall> or whatever
02:37:12 <Araneidae> Here, presumably: http://www.haskell.org/cabal/ ?
02:37:39 <mornfall> I agree it's eww. But it's comparably eww to cmdargs but referentially transparent.
02:37:43 <Heffalump> Araneidae: lucid has GHC 6.12.1, so if you had that I'd recommend installing the distro packages where possible and then using cabal install for other things.
02:37:45 <Peaker> mornfall, Why not something like:  myOption = Option "my-option" "get some preference" ?  or replace "get .." with [Help "get some pref"] ?
02:37:48 <Gracenotes> yeah, the download link. with 'ghc6 libghc6-dev-http libghc6-dev-zlib', you can install that, and subsequently any package on hackage
02:38:23 <Heffalump> karmic has 6.10.4 which is now a bit out of date but should still be ok
02:38:25 <mornfall> Peaker: Because I want to automatically derive a relationship between options and field records / adt constructors.
02:38:44 <mornfall> Peaker: So the primary representation is an ADT and I need to annotate it with help/etc. strings.
02:39:00 <mornfall> Peaker: Either based on record fields or on constructors (the latter has a much cleaner solution, fortunately).
02:39:21 <Gracenotes> Araneidae: I prefer keeping the OS-registered packages to a minimum, and keeping up to date as possible from Hackage instead. this approach has its own disadvantages, but the benefits outweigh personally
02:40:15 <Araneidae> Gracenotes, unfortunately the last time I tried that, because I'm a complete beginner, I got things completely messed up
02:40:32 <Araneidae> Still, guess I'll try again
02:40:50 <eflister> Heffalump: hmm, deepseqing didn't help http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27709#a27712 -- the safe package looks ok, but i'd like to work out why my exception approach doesn't work.  why don't you like the exception catching way?
02:41:11 <mornfall> Heffalump: cmdargs sets a high standard for conciseness, but its annotations are based on evaluating a record with unsafePerformIO annotations and collected during evaluation in an IORef... which breaks transparency and makes reusing helps for option groups fairly impossible... hence, alternative.
02:41:27 <Gracenotes> Araneidae: well, try to install the way I had above; let me know if you get stuck
02:42:21 <Heffalump> mornfall: fair enough
02:42:50 <Heffalump> your record selector trick is neat because it also allows deriving the record update function from the accessor
02:43:09 <Araneidae> Gracenotes, well alas libghc6-dev-http doesn't seem to exist...
02:43:17 <Heffalump> Araneidae: libghc6-http-dev
02:43:28 <Araneidae> huh :)
02:43:34 <Heffalump> Gracenotes has the dev and the actual name the wrong way round in both cases
02:45:02 <Araneidae> I take it the http and zlib packages are needed for the cabal bootstrap
02:45:20 <Heffalump> yeah
02:47:45 <Gracenotes> Heffalump: uh at least I am consistent
02:47:59 <Gracenotes> ly wrong
02:48:08 <Heffalump> :-)
02:48:15 <Heffalump> @quickcheck False
02:48:16 <lambdabot> Unknown command, try @list
02:48:19 <Heffalump> @check False
02:48:20 <lambdabot>   "Falsifiable, after 0 tests:\n"
02:48:33 <Gracenotes> all the precision of a drunken semiautomatic weapon operator
02:54:07 <eflister> Heffalump: see above re deepseq?
02:54:08 <Araneidae> Gracenotes, am I installing the right thing now?  Cabal-1.8.0.4 -- doesn't have a bootstrap.sh, but the README is pretty clear (I run `ghc --make Setup` instead...)
02:55:02 <Gracenotes> Araneidae: Cabal should have been installed with ghc6. what you want is the tarball for cabal-install. deceptively similar names
02:55:19 <Araneidae> ah
02:55:26 <Gracenotes> Cabal is a library like any other, but cabal-install is a command-line tool that gets installed to ~/.cabal/bin/
02:55:26 <Araneidae> Ok, I'll throw my Cabal away...
02:57:17 <Araneidae> mm.  cabal-install-0.8.2 ?  From here: http://hackage.haskell.org/package/cabal-install
02:57:32 <Araneidae> There ought to be a wiki for this somewhere!
02:57:51 <Gracenotes> the second one on http://www.haskell.org/cabal/download.html
02:58:28 <Araneidae> Oh damn, it was right in front of me!
02:59:44 <mornfall> Software: You buy one and then get gears and cranks in your mail for another two years.
03:04:49 <Araneidae> I want to write some Haskell binding for an IO library with a very simple API, but I can't see what the appropriate Haskell typing should be.
03:05:31 <Araneidae> It's a simple subscription api: sub_t subscribe(char*name, callback_t cb, void*context) to subscribe
03:05:49 <Araneidae> void poll(void) to dispatch any active callbacks
03:06:03 <Araneidae> and void unsubscribe(sub_t sub) to unsubscribe
03:06:41 <Araneidae> Most simply, subscribe::String -> [value] except there's IO mixed in with all that...
03:07:03 <Araneidae> Any hints, places to go read, ...?
03:07:06 <Gracenotes> well, you can make your own types that are just wrappers around pointers
03:07:42 <Araneidae> Aye, but that's not quite the point .. my main question is what type should `subscribe` be to take account of its asynchronous IO nature
03:07:56 <Araneidae> ... and the fact that *somebody* has to go poke poll() regularly
03:08:32 <Araneidae> I don't mean what should the FFI binding of subscribe be, I mean the wrapped abstraction I want to build
03:10:00 <Gracenotes> ah. probably best to stick with the C semantics as close as possible
03:11:01 <Gracenotes> I think it's possible to pass Haskell functions to C code with C calling conventions, and referencing arbitrary Haskell closures (values) in C code, but I have no experience with it...
03:12:24 <Zao> foreign import ccall "wrapper"
03:12:35 <Zao> mkBlargh :: Blargh -> IO (FunPtr Blargh)
03:13:00 <Zao> (needs a freeHaskellFunPtr in the end, unless you like leaking)
03:13:37 <Zao> I'd say that it falls under the FFI binding bits though and not the shiny surface of the library.
03:14:11 <Araneidae> Dammit, I'm not explaining my question at all well!
03:14:25 <Araneidae> Ok, here's a more elementary question.
03:14:33 <Zao> Araneidae: I understand what you mean, but I can't say I have any ideas.
03:14:44 <Gracenotes> it's perfectly fine to have just poll :: IO (), by the way, as a simple way to expose it
03:15:10 <Araneidae> In Haskell what is the type of a "list" which needs an IO action to deliver each new value?
03:15:18 <Gracenotes> I'm drawing a blank if you want to heap abstractions onto it :.
03:15:41 <Araneidae> Stream a = a : IO (Stream a)  -- something like that ?
03:15:54 <Zao> That won't do.
03:16:05 <Zao> Assuming you mean list cons with (:)
03:16:16 <Araneidae> Well, it'll need its own constructor I guess
03:16:27 <Gracenotes> iteratee might work there?
03:16:31 <Araneidae> Stream a = a <:> IO (Stream a)
03:17:14 <Araneidae> This: http://www.haskell.org/haskellwiki/Enumerator_and_iteratee ?
03:20:01 <Gracenotes> Araneidae: the package is http://hackage.haskell.org/package/iteratee
03:20:42 <Gracenotes> it's not a bad abstraction for something which requires a stream of data to yield its result. though might be overkill here
03:21:25 <Gracenotes> or a list of results, etc. uh. why do I always insist on staying up so late. *bonks head*
03:21:44 <Gracenotes> your Stream type should be fine
03:22:01 <Araneidae> Yeah, think I'll start with that and see if I can get anywhere
03:22:09 <Heffalump> eflister: one reason I don't like exception catching is it forces you into IO
03:22:18 <Heffalump> also, I suspect it'd be inefficient
03:23:00 <Heffalump> it's not xs you should deepseq, it's the result of f xs
03:23:06 <Heffalump> so try f $!! xs
03:28:36 <eflister> Heffalump: looks like $!! is from hxt, not Control.DeepSeq.  def is f $!! x = x `deepSeq` f x, which i think is what i did, right?  (f xs) `deepseq` (f xs) gave same result.
03:29:06 <Heffalump> oops, sorry, I didn't mean that
03:29:43 <eflister> Hemmalump: i hear ya about IO, agreed it sucks (spoon uses unsafeperformio).  here i'm more concerned w/understanding than efficiency :)
03:29:44 <Heffalump> I meant something like let y = f xs in y `deepseq` (return y)
03:29:54 <Heffalump> which is return $!! f xs
03:31:02 <Heffalump> the whole way you have to hack around with evaluation is also evidence of the dodginess
03:31:30 <Heffalump> the fundamental problem with something like f . head is that the error ends up buried in the result - "hi" ++ <some error>
03:31:47 <Heffalump> and since safeList can't know where it is, it really has to force all evaluation. Which destroys laziness.
03:32:41 <eflister> Heffalump: that's exactly what surprised me -- why isn't ("hi" ++) bypassed?  i wasn't expecting it to append to the error!?!?
03:32:52 <Heffalump> ++ is lazy
03:33:00 <Heffalump> > "hi" ++ error "foo"
03:33:02 <lambdabot>   "hi*Exception: foo
03:33:10 <Heffalump> there's useful data in that expression
03:33:52 <eflister> > reverse $ error "foo"
03:33:53 <lambdabot>   *Exception: foo
03:34:01 <eflister> why isn't reverse lazy?
03:34:10 <Heffalump> what would you expect it to produce?
03:34:42 <eflister> hm.
03:36:02 <eflister> :t "hi" ++ error "foo"
03:36:04 <lambdabot> [Char]
03:36:55 <eflister> :t error "foo"
03:36:56 <lambdabot> forall a. a
03:37:18 <eflister> :t error "foo" :: String
03:37:19 <lambdabot> String
03:37:32 <eflister> that strikes me as bizarre
03:37:49 <eflister> :t error
03:37:50 <lambdabot> forall a. [Char] -> a
03:38:08 <Heffalump> what's bizarre?
03:38:19 <eflister> that type for error
03:39:05 <Heffalump> why?
03:39:11 <Heffalump> errors can go anywhere
03:39:25 <eflister> shouldn't it have its own type, that for instance wouldn't work with ++?
03:39:43 <eflister> something like bottom
03:39:52 <eflister> > "hi" ++ undefined
03:39:53 <lambdabot>   "hi*Exception: Prelude.undefined
03:40:48 <eflister> > isInfixOf "und" $ "hi" ++ undefined
03:40:49 <lambdabot>   *Exception: Prelude.undefined
03:41:18 <eflister> :t isInfixOf
03:41:19 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
03:41:42 <eflister> isInfixOf "und" "undef"
03:41:54 <eflister> > isInfixOf "und" "undef"
03:41:56 <lambdabot>   True
03:42:58 <Heffalump> but you want it to work with (++), otherwise your code wouldn't typecheck
03:43:15 <eflister> how is "hi*Exception: foo even an expression?  it is not terminated by a "
03:43:26 <Heffalump> it's just how the result got printed
03:43:39 <eflister> what is the actual result?
03:43:39 <Heffalump> the actual internal representation is roughly 'h':'i':error "foo"
03:43:55 <Heffalump> which is the result of evaluating (++)
03:44:30 <eflister> if error "foo" is a String there, shouldn't the whole result be a normal string?
03:44:39 <eflister> that i can isinfix of on?
03:45:37 <eflister> i think it's that the isinfixof treats the error "foo" as something like a bottom
03:46:10 <eflister> or maybe the consing
03:46:21 <shachaf> eflister: (error "foo") *is* _|_.
03:47:30 <shachaf> By the way:
03:47:32 <shachaf> > fix error
03:47:33 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:50:48 <mornfall> :D
04:00:31 <eflister> Heffalump: hmm, (return $!! f xs) worked, but i don't get why return ((f x) `deepseq` (f x)) didn't?
04:03:43 <Botje> two different values
04:03:58 <Botje> let fx = f x in fx `deepseq` fx
04:04:07 <Botje> that should seq correctly
04:04:08 <Heffalump> because f x doesn't get memoised
04:04:21 <Heffalump> so the second evaluation produces a new, unevaluated value
04:07:52 <eflister> oh right, duh
04:08:02 <eflister> thx!  it works!  :)  and i sort of get why.
04:11:15 <Araneidae> Do I understand this right: would  let fx = f x in return fx `deepseq` fx  have been different (really the same value this time)?
04:11:37 <Araneidae> Ah.  Just saw what Botje wrote.  Bit of a violation of referential transparency there!
04:12:11 <Botje> why?
04:12:20 <Botje> (f x) and (f x) are two separate values
04:12:29 <Botje> they are guaranteed to evaluated to the same value, true
04:12:45 <Botje> but your compiler doesn't guarantee it'll do CSE
04:12:52 <Araneidae> Referential transparency is the principle that  let x = blah in exp[e]  is equal to  exp[blah]
04:13:13 <Botje> but they are equal
04:13:48 <Araneidae> I missed the difference, something to do with exceptions?  Sorry, there's a big netsplit in the way!
04:14:11 * Araneidae doesn't know what `deepseq` is
04:14:24 <Araneidae> Presumably a variant of seq 
04:14:25 <Botje> do you know seq?
04:14:26 <Botje> yeah
04:14:43 <Botje> it touches every part of a data structure instead only the constructor
04:14:59 <Araneidae> Huh.  
04:15:44 <shachaf> @ty deepSeq
04:15:45 <lambdabot> Not in scope: `deepSeq'
04:15:49 <Botje> f x `seq` f x is the same as f x, indeed
04:15:52 <Araneidae> Would that mean that  let all=[1..] in deepseq all (head all)  would never terminate
04:16:17 <Araneidae> @ty deepseq
04:16:18 <lambdabot> Not in scope: `deepseq'
04:16:24 <shachaf> Ah, (DeepSeq a) =>. Why isn't Seq a type class?
04:16:38 <Araneidae> @ty DeepSeq
04:16:39 <lambdabot> Not in scope: data constructor `DeepSeq'
04:16:46 <Araneidae> @help
04:16:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:16:56 <Heffalump> shachaf: it was discussed for Haskell 98 and they decided against on the basis that it would be too intrusive
04:17:24 <mauke> Seq constraints, Seq constraints everywhere
04:18:23 <shachaf> Something should be done about that. People avoid constraints because they're so annoying to have everywhere, but they're supposed to be a good thing.
04:18:54 <shachaf> Is there a solution? Better than adding a primitive unsafeSeq, that is?
04:20:20 <Heffalump> I think Haskell is now stuck with the current design
04:20:48 <shachaf> Haskell is stuck with a lot of things.
04:21:33 <Heffalump> I would be in favour of having the typeclass, but having more partial type signatures
04:21:58 <Heffalump> so you can say put a wildcard in class constraints, and have them inferred automatically
04:29:21 <Saizan> Heffalump++
04:29:42 <Saizan> we should really get that feature implemented anyhow
04:45:38 <chrisdone> http://gist.github.com/480346
04:45:41 <chrisdone> λ> getPkgNames >>= mapM getPkgModules >>= return . show . length . concat
04:45:41 <chrisdone> "1748"
04:45:44 <chrisdone> :-)
04:46:30 <Twey> I like your prompt
04:46:34 <chrisdone> :-D
04:48:43 <chrisdone> I'm going to use this to do import completion in Emacs, because I can't be bothered writing it in Elisp :-P
04:49:14 <chrisdone> manually parsing a Cabal module, etc. boring!
04:50:07 <ManateeLazyCat> chrisdone: "Import completion"? You mean complete module name?
04:50:28 <chrisdone> ManateeLazyCat: that's right
04:50:52 <ManateeLazyCat> chrisdone: Do you know auto-complete.el ?
04:51:14 <shachaf> chrisdone: Hmm, yes, I will steal that prompt, if you don't mind.
04:51:19 <shachaf> (Or if you do.)
04:51:36 <Twey> Hehe.
04:51:43 <ManateeLazyCat> chrisdone: I have fiish http://www.emacswiki.org/emacs/auto-complete-extension.el that integrate hoogle with auto-complete.el to provide completion any symbol/function can search in hoogle.
04:52:02 <shachaf> There's no way to tell ghci just to show the module marked with * and not all the others, right?
04:52:11 <chrisdone> ManateeLazyCat: hmm, I didn't. that's nice. perhaps with this you can complete modules that are actually installed, too.
04:52:28 <ManateeLazyCat> chrisdone: Though hoogle don't support regexp search, but i have use it long time, works well.
04:52:30 <Twey> I'd like a way to show just the last word of the modules in the prompt, personally.
04:52:50 <ManateeLazyCat> chrisdone: You can completion any symbol/function with completion UI like eclipse.
04:53:25 <ManateeLazyCat> chrisdone: Perfect way is need use "Haskell parser backend" instead hoogle, then integrate with auto-complete.el
04:53:26 <Saizan> chrisdone: seen http://www.haskell.org/ghc/docs/6.12.2/html/libraries/Cabal-1.8.0.4/Distribution-Simple-Program-HcPkg.html#v%3Adump ?
04:54:11 <Twey> :set prompt "-- %s --\nλ> "
04:54:15 <Twey> Best of both worlds?
04:54:54 <chrisdone> Saizan: oh, that's better :-)
04:55:17 <chrisdone> ManateeLazyCat: "Haskell parser backend" is what?
04:55:39 <Milo-> hey, I have been trying to make as effective function as standard library's length (to learn effective recursion), but I seem to hit the stack overflow mark at list length of ~172000.
04:55:55 <chrisdone> Twey: I did try that for a while but personally it cluttered the view more than I found useful. I use :show modules
04:55:56 <Milo-> any tips how that kind of recursion should be done?
04:56:13 <shachaf> Twey: Why the *last* word?
04:56:27 <ManateeLazyCat> chrisdone: auto-complete.el is a Completion UI for Emacs, that need you feed "completion symbol list" for auto-complete.el
04:57:06 <ManateeLazyCat> chrisdone: Example, when i type something in haskell file, i will do filter with hoogle, then i will got a symbol/function list that match current input prefix.
04:57:07 <chrisdone> ManateeLazyCat: right, for symbols. OK
04:57:39 <ManateeLazyCat> chrisdone: Then auto-complete.el will display completion-UI like this : http://www.flickr.com/photos/48809572@N02/4804685480/
04:57:41 <Saizan> Milo-: length = foldl' (\l _ -> l+1) 0 
04:58:04 <Milo-> foldl' ? 
04:58:34 <ManateeLazyCat> chrisdone: Of course, you perhaps to handle . with qualiafied to complete symbol in specify module.
04:59:14 <Twey> shachaf: Because the last word will be things like ‘Arrow’ or ‘Monad’
04:59:38 <Twey> Which, in most cases, should be enough for me to identify it without having to write ‘Control.Arrow’ or ‘Control.Monad’
04:59:40 <Saizan> Milo-: yes, a stricter version of foldl, which is the combinator to use when you want to recurse on a list while building up an accumulator in a tail-recursive fashion
04:59:50 <ManateeLazyCat> chrisdone: In http://www.flickr.com/photos/48809572@N02/4804685480/ i use hoogle as backend to generate list for completion, then auto-complete.el display it.
05:00:00 <chrisdone> ManateeLazyCat: I'm guessing auto-completion supports ido-mode?
05:00:27 <ManateeLazyCat> chrisdone: I think auto-complete.el 's UI is more friendly, you don't need ido-mode
05:00:33 <shachaf> Twey: Oh, the last word of each module -- I thought you meant the last module.
05:00:33 <Milo-> Saizan ah thanks :)
05:00:44 <Twey> No no.
05:00:59 <shachaf> My prompt, if I didn't get rid of the %s: Prelude Control.Applicative Control.Monad Control.Monad.Instances Data.Char Data.Function Data.List Data.Maybe Data.Monoid Data.Ratio Data.String>
05:01:39 <ManateeLazyCat> chrisdone: ido-mode or other Emacs completion solution is not intuitionistic, best completion solution is use Popup-UI like auto-complete.el
05:01:39 <chrisdone> how often do you really need to see what modules are available?
05:01:43 <raichoo> Is there a way to permanently set the ghci prompt?
05:01:46 <shachaf> Twey: (What about Control.Monad.State.Strict and such?)
05:01:52 <shachaf> raichoo: Put it in ~/.ghci
05:02:01 <raichoo> shachaf: Cool thank you :)
05:02:16 <shachaf> chrisdone: Not very. But I like to see that first bit ("Prelude" or "*Something").
05:02:18 <Twey> shachaf: I did say ‘in most cases’.  I'd probably remember, though, anyway.
05:02:53 <ManateeLazyCat> chrisdone: I will check completion list once use change input around pointer.
05:03:03 <chrisdone> ManateeLazyCat: the drop-down is inefficient; in your example, if you want to import Data.Complex, you have to type 'complex'. with ido-mode, you can just type 'x'.
05:03:57 <ManateeLazyCat> chrisdone: But that need some *guess*, not correct always, right? 
05:04:18 <ManateeLazyCat> chrisdone: Like you can type M-/ completion some symbol fuzzy.
05:04:34 <chrisdone> ManateeLazyCat: it's not a guess. you can see from the list yourself, 'x' is unique. it's saving you from typing. no, it's completely different to dabbrev-expand
05:04:50 <ManateeLazyCat> chrisdone: But sometimes you need type many times M-/ for toggle in all possible symbol, so i think ido is same.
05:04:56 <chrisdone> it's a basic substring match
05:05:09 <chrisdone> ido is nothing like dabbrev-expand
05:06:06 <ManateeLazyCat> chrisdone: ido will list all symbol in a popup buffer, right?
05:06:15 <chrisdone> try this: M-: (ido-completing-read "Give me a fruit: " '("Apple" "Pear" "Coconut" "Kiwi" "Clementine"))
05:07:19 <chrisdone> you can type 'co' to get Coconut, or 'ut', or just 'u', because you can see clearly that it's unique. or 'cl' or 'ne' to get Clementine
05:07:25 <ManateeLazyCat> chrisdone: It's just handy for little symbol, when have many possible symbol, it's painful search by eye.
05:07:38 <chrisdone> not really. you just type more to filter it
05:07:53 <chrisdone> i use this for M-x and file navigation
05:08:28 <ManateeLazyCat> chrisdone: You need switch your focus from current pointer and minibuffer, that's why i said it's not intuitionistic
05:09:06 <chrisdone> eh, I'm looking at the minibuffer all day
05:09:08 * ManateeLazyCat For the same reason, that's why i use anything.el and not ido.el for search local file.
05:11:17 <ManateeLazyCat> chrisdone: I agree fuzzy search is handy sometimes, but i think popup-UI is more intuitionistic for completion symbol. Maybe we need fuzzy completion in auto-complete.el, when you type any part of symbol, it will display in completion list.
05:15:17 <ManateeLazyCat> chrisdone: If you like fuzzy completion, you can build your own backend for auto-complete.el, then you can got friendly UI and substring search.
05:16:38 <ManateeLazyCat> chrisdone: Build backend is pretty easy, just generate "symbol list" like you did for ido-completing-read . :)
05:20:56 <chrisdone> ManateeLazyCat: thanks, but I don't care for the UI and I like ido-completing-read just fine. I don't really have a use for auto-complete.el
05:22:09 <ManateeLazyCat> chrisdone: You can try auto-complete.el, it's pretty feature in Emacs, though it's not perfect for unicode character.
05:22:25 <ManateeLazyCat> chrisdone: BTW, do you use auto-install.el ?
05:23:04 <ManateeLazyCat> chrisdone: You can use auto-install.el install all Emacs extension at EmacsWiki.org
05:23:36 <ManateeLazyCat> chrisdone: Download/Install/Replace elisp automatically. :)
05:25:04 <ManateeLazyCat> chrisdone: http://www.emacswiki.org/emacs/AutoInstall
05:29:29 <chrisdone> ManateeLazyCat: are you just showing me all the packages you've made? :-)
05:30:23 <ManateeLazyCat> chrisdone: I will show all useful elisp extensions, not just me. :)
05:31:04 <ManateeLazyCat> chrisdone: Of course, if you want, there are here : http://www.emacswiki.org/emacs/AndyStewart :)
05:31:11 * chrisdone laughs
05:31:22 <chrisdone> thanks. :-0
05:31:35 <ManateeLazyCat> chrisdone: auto-complete.el is build by my Japanese friend. :)
05:33:10 <chrisdone> ManateeLazyCat: I tried to read your ~/.emacs but I don't know Chinese :-P
05:33:18 <ManateeLazyCat> chrisdone: Just ignore it.
05:33:30 <ManateeLazyCat> chrisdone: My ~/.emacs is pretty easy.
05:34:01 <ManateeLazyCat> chrisdone: Just add-subdirs-to-load-path for load elisp files under specify directory.
05:34:15 <ManateeLazyCat> s/pretty easy/pretty simple.
05:34:25 * ManateeLazyCat Damn stupid English Helper.
05:36:43 <chrisdone> ManateeLazyCat: 你能聽見我嗎？
05:36:51 <ManateeLazyCat> chrisdone: 能
05:37:09 <chrisdone> :-)
05:37:15 <ManateeLazyCat> chrisdone: I think we should stop Chinese, will crazy some guy in this channel?
05:37:31 <ManateeLazyCat> chrisdone: 台湾同胞？
05:37:58 <chrisdone> ManateeLazyCat: 我听不懂。你开玩笑吧？
05:38:25 <ManateeLazyCat> 我是说很多 haskeller 看不懂中文
05:38:51 <chrisdone> 不能
05:39:06 <chrisdone> I wonder how many Chinese Haskellers there are
05:39:18 <chrisdone> is it taught in China?
05:39:42 <ManateeLazyCat> chrisdone: I don't know, just few Chinese haskeller in here.
05:40:01 <ManateeLazyCat> chrisdone: No, 99% even don't know Haskell in China.
05:40:30 <ManateeLazyCat> chrisdone: In China, most programmer use Java/C++/C
05:40:43 <chrisdone> sure, it's the same all over the world, I think
05:40:45 <tensorpudding> How does Chinese deal with foreign words anyway?
05:41:14 <Twey> tensorpudding: Phonetic transcription
05:42:18 <ManateeLazyCat> chrisdone: I hope someday have enough Chinese haskeller here, then we can talk in #haskell-zh. :)
05:42:18 <tensorpudding> Is there any rhyme or reason to which character they use for a given sound?
05:42:39 <chrisdone> ManateeLazyCat: sure. :-)
05:42:47 <tensorpudding> (are they able to encapsulate sounds which do not exist in chinese?)
05:42:54 <Jafet> tensorpudding: no and no
05:42:56 <Twey> tensorpudding: Not really, and no
05:43:17 <ManateeLazyCat> chrisdone: http://chrisdone.com/ is you?
05:43:23 <tensorpudding> Is it possible for the phonetic "jibberish" to be confused for real chinese?
05:43:25 <chrisdone> ManateeLazyCat: yes :-)
05:43:40 <Twey> tensorpudding: Theoretically, but highly unlikely
05:43:46 <Jafet> tensorpudding: about as likely as an english name gets mistaken in english
05:43:56 <ManateeLazyCat> chrisdone: Nice to meet you, 你的中文很溜阿。
05:43:59 <tensorpudding> is it possible for someone learning chinese to make that mistake frequently?
05:44:15 <Jafet> No, because they tend to choose improbable characters.
05:44:49 <tensorpudding> it seems it would be more logical for them to have some way of distinguishing them
05:45:15 <Twey> As it would in English
05:45:17 <Jafet> "John went to jack off Jack at the john."
05:45:20 <Twey> Sadly, neither is Lojban :þ
05:45:27 <tensorpudding> I admit, I'm ascribing logical reasoning to a language.
05:45:31 <chrisdone> ManateeLazyCat: 我使用谷歌。抱歉。
05:45:32 <chrisdone> ManateeLazyCat: 你不上當 >_>
05:45:41 <Twey> Lojban does have ways of distinguishing them.
05:46:05 <ManateeLazyCat> chrisdone: 你不上當 ? Haha.
05:46:05 <Jafet> Logic is not the only way to view the world, anyway.
05:46:26 <chrisdone> ManateeLazyCat: <_<
05:46:28 <ManateeLazyCat> chrisdone: Should be "你上当了" (Simple Chinese)
05:46:36 <tensorpudding> Intuitive is probably better for languages.
05:46:43 <tensorpudding> But I don't think Chinese is intuitive either.
05:46:44 <chrisdone> ManateeLazyCat: I was trying traditional
05:46:58 <chrisdone> how can a language be "intuitive"?
05:47:01 <geheimdienst> uh, english has ways of distinguishing proper names as well. note how jafet's example sentence had some words starting with a capital letter :)
05:47:08 <Twey> chrisdone: By being your native language.  ;)
05:47:14 <chrisdone> Twey: ;-D
05:47:20 <tensorpudding> Okay, maybe not intuitive.
05:47:21 <Twey> geheimdienst: But they're not pronounced.
05:47:22 <tensorpudding> Simple?
05:47:24 <ManateeLazyCat> chrisdone: 直觉的
05:47:33 <Twey> tensorpudding: Chinese is pretty simple, as languages go.
05:47:58 <tensorpudding> It doesn't seem so.
05:48:03 <geheimdienst> anything is simple if you do it for several hours per day for 15 years
05:48:05 <Twey> tensorpudding: Why do you think so?
05:48:12 <ManateeLazyCat> tensorpudding: We have "Simple Chinese" and "Traditional Chinese", "Simple Chinese" talk in China mainland. 
05:48:30 <ManateeLazyCat> tensorpudding: "Traditional Chinese" talk in TaiWan or HongKong.
05:48:54 <tensorpudding> How is it more simple compared to, say, Latin?
05:49:22 <chrisdone> ManateeLazyCat: 你知道莊子;？ 我喜歡他。他是一個傑出的哲學家
05:49:36 <ManateeLazyCat> chrisdone: 当然知道啊
05:50:11 <portnov> hm. Is haskell similar to chinese? :)
05:50:20 <ManateeLazyCat> chrisdone: 我喜欢尼采
05:50:22 <tensorpudding> The writing system is not easy compared to any other language.
05:50:25 <Twey> tensorpudding: No inflections, no irregularities, no genders, no cases
05:50:30 <ManateeLazyCat> portnov: No. :)
05:50:32 <chrisdone> ManateeLazyCat: 我自己的“莊子全集” "The Complete Works of Chuang Tzu"
05:50:38 <benmachine> no irregularities?
05:50:41 * benmachine impressed
05:50:50 <ManateeLazyCat> chrisdone: Have English version? I wonder. :)
05:50:51 <tensorpudding> A tonal system.
05:50:53 <Twey> benmachine: For some definition of ‘irregularity’
05:50:56 <geheimdienst> twey, i agree. on the grammar level it's very simple. however on the level of the writing system ...
05:50:56 <benmachine> heh
05:50:57 <chrisdone> ManateeLazyCat: yes, English :-)
05:51:10 <Twey> tensorpudding: Tones are not any more complex than any other phonetic feature
05:51:25 <Twey> tensorpudding: You only think them complex because they're not phonemic in your native language.
05:51:36 <Jafet> It's a disservice to call any natural language "simple"... languages are useful due to their high complexity.
05:51:38 <tensorpudding> How is case complex?
05:51:48 <tensorpudding> It makes the structure of what every part of the sentence clear
05:51:53 <Twey> tensorpudding, geheimdienst: I don't consider the Chinese writing system any more difficult than e.g. English spelling
05:51:54 <benmachine> phonemic is like anaemic only in your ears
05:52:09 <Twey> tensorpudding: I said it was complex, not that it was useless
05:52:21 <tensorpudding> A phonetic spelling system is undebatably simpler than Chinese.
05:52:26 <chrisdone> Twey: so you think it's an uphill battle? :-P
05:52:47 <chrisdone> (re learning English spelling)
05:52:48 <ManateeLazyCat> chrisdone: Do you know "天人合一"?
05:52:48 <vegai> Twey: are you chinese?
05:52:55 <tensorpudding> Are there any complications in Chinese for combining roots?
05:52:56 <Twey> tensorpudding: It's complex because a speaker must remember to inflect each part of the sentence appropriately, and it invariably leads to irregularities and often arbitrary grammatical classes with different treatment
05:53:00 <Twey> vegai: No
05:53:08 <Twey> tensorpudding: But the English system is not phonetic.
05:53:09 <chrisdone> ManateeLazyCat: of 莊子;?
05:53:15 <ManateeLazyCat> chrisdone: Yes.
05:53:35 <chrisdone> ManateeLazyCat: it means nature, right?
05:53:42 <Twey> tensorpudding: It may once have been phonetic, but now a significant proportion of vocabulary has so many contradictory rules applied to it that each word is effectively an arbitrary ideogram.
05:53:43 <tensorpudding> I have a vague intimation with Japanese, which has some complications with that
05:53:47 <benmachine> is it me or is the proposed haskell download page with "take the dive" and then a picture of a diver
05:53:50 <benmachine> a bit
05:53:52 <benmachine> corny?
05:53:53 <vegai> Twey: but the chinese writing system is nowhere near phonetic
05:53:55 <benmachine> um
05:54:00 * benmachine never uses that word but it seems apposite in this case
05:54:18 <vegai> Twey: in fact, the letters have nothing to do with their pronunciation in chinese, right?
05:54:19 <Twey> vegai: No, it's properly (and consistently) ideographic instead
05:54:32 <Twey> vegai: Though, in fact, many characters do have phonetic radicals to indicate the pronunciation of a word
05:54:41 <p_l> vegai: first, they aren't "letters" :)
05:54:42 <ManateeLazyCat> tensorpudding: If you use Chinese, you won't have spelling mistake like English or Latin....
05:54:43 <tensorpudding> The ideographs don't have a 1-1 correspondence with meaning either.
05:54:48 <chrisdone> ManateeLazyCat: Zhuangzi uses "Heaven" but not the Christian heaven, but nature, or mother nature, or something more mystical. this is what I've decided from reading about him
05:55:11 <tensorpudding> Nor do the pictures give you much hint as to meaning in a symbolic sense.
05:55:21 <Jafet> benmachine: see the topic for #learnanycomputerlanguage
05:55:59 <vegai> p_l: and second?
05:55:59 <chrisdone> Topic for #learnanycomputerlanguage: Learn Any Computer Language! But we recommend: Haskell!
05:56:02 * chrisdone chuckles
05:56:08 <Twey> Hehe.
05:56:18 <ManateeLazyCat> chrisdone: I think "Nature is is better translation than "Heaven"
05:56:33 <tensorpudding> Would Chinese be unreadable if it were copied into a pseudo-latin script?
05:56:38 <geheimdienst> learn any language in 21 days. except haskell, which will take eleventy minutes
05:56:44 <chrisdone> ManateeLazyCat: 是的
05:56:44 <p_l> vegai: dunno about second, but I like ideograms
05:57:03 <benmachine> Jafet: what *is* learnanycomputerlanguage?
05:57:08 <mornfall> Is there a way to tell GHC that a type function is injective?
05:57:11 <Jafet> tensorpudding: http://en.wikipedia.org/wiki/Lion-Eating_Poet_in_the_Stone_Den
05:57:15 <benmachine> apart from having an expired URL in the topic
05:57:17 <Heffalump> mornfall: no :-(
05:57:17 <Jafet> benmachine: heh, who knows
05:57:29 <benmachine> mornfall: make it a data family?
05:57:38 <p_l> tensorpudding: there's a group of crazies in Japan that are pursuing the goal of removing Kanji from japanese... rather hard thing to do (genji monogatari is quite hard to read, after all)
05:57:53 <ManateeLazyCat> chrisdone: My English is not good enough for explain philosophy, do you know "太极“?
05:57:55 <chrisdone> ManateeLazyCat: my favourite story is 橡樹
05:58:07 <Jafet> It's actually much easier in Japanese, which is more syllabic.
05:58:08 <ManateeLazyCat> chrisdone: Why?
05:58:12 <chrisdone> ManateeLazyCat: yes, I do
05:58:33 <chrisdone> ManateeLazyCat: do you mean Chi as a life force?
05:59:21 <ManateeLazyCat> chrisdone: 太极的精髓 和 天人合一 在某种程度上有相似的价值取向
05:59:38 <mornfall> Let's try with fundeps then.
05:59:42 <ManateeLazyCat> chrisdone: Yes, i think so.
05:59:44 <chrisdone> ManateeLazyCat: 長在樹上。沒有任何目的。樹只生長。 你明白嗎？
05:59:51 <geheimdienst> jafet, how is japanese more syllabic?
06:00:35 <Jafet> It's more syllabic than Chinese.
06:00:47 <p_l> geheimdienst: less differences due to tone, iirc
06:00:54 <Twey> I think Jafet was trying to say that it has phonetic syllabaries as well as ideograms.
06:01:11 <p_l> though HAshi and haSHI are two different things (caps for stressed element)
06:01:23 <Twey> p_l: Not quite
06:01:23 <ManateeLazyCat> chrisdone: http://baike.baidu.com/view/4259.htm
06:01:24 <chrisdone> this web site is funny: http://translationparty.com/
06:01:33 <Twey> It's tone, not stress, and it varies from region to region
06:01:40 <p_l> Twey: right
06:02:05 <Twey> hàši vs. haši
06:02:21 <ManateeLazyCat> chrisdone: Can you understand my Chinese word, my English is poor to talk philosophy.
06:02:23 <ManateeLazyCat> ?
06:02:26 <chrisdone> Twey: "It's tone, not stress, and it varies from region to region" => "This sound is influenced by local stress."
06:02:38 <geheimdienst> twey, since when do japanese words wear hats?
06:02:44 <geheimdienst> or is that chinese?
06:02:59 <chrisdone> ManateeLazyCat: I understand some
06:02:59 * p_l is out of touch regarding japanese, haven't seriously kept learning for last two years (I still listen quite a lot)
06:03:23 <Twey> geheimdienst: It's a romanisation system of mine for Standard (Tokyo) Japanese, which is capable of indicating pitch-fall.
06:03:58 <geheimdienst> okay i see
06:04:22 <ManateeLazyCat> chrisdone: 我们中国人认为 ‘气' 是一种内在的力量， 就像针灸里面强调经络一样
06:04:40 <Twey> geheimdienst: I haven't written it up properly yet, but there's some information here: http://twey.ath.cx/files/romaji.txt
06:04:51 <chrisdone> ManateeLazyCat: I don't think Zhuangzi really agreed with much of what Confucius had to say, but writers attempted to merge their philosophies
06:04:53 <ManateeLazyCat> chrisdone: 很多中国人从练太极中得到内心的平静
06:04:56 <geheimdienst> thanks
06:05:22 <Jafet> Romaji is the opposite of romanization, no?
06:05:55 <chrisdone> ManateeLazyCat: yes, 安心
06:06:14 <ManateeLazyCat> chrisdone: Yes, ZhungZi is very different with Confucius (KongZi)
06:06:21 <Jafet> Twey: doesn't seem to come with proper encoding-header
06:06:26 <Twey> Sorry, UTF-8
06:06:29 <tensorpudding> I learned a few kanji radicals once
06:06:35 <ManateeLazyCat> chrisdone: Spirit peace...
06:06:55 <tensorpudding> it doesn't help you suddenly recognize any meaning though
06:07:09 <ManateeLazyCat> chrisdone: I think 平静 is more exactly word than 安心
06:07:30 <Twey> Jafet: ‘Ròomaži’ (ローマ字) means ‘Characters/alphabet of Rome’, and indicates the Latin alphabet in general
06:07:56 <Twey> Specifically, it's often used to mean transliteration of Japanese into Latinate characters
06:07:56 <mauke> romaji is romaji
06:08:21 <geheimdienst> attentive cat is attentive
06:08:47 <chrisdone> ManateeLazyCat: it seems modern 道 is good but they deal with the state (政府) and I don't think 道, as seen by ZhungZi, should have anything to do with it, but oh well
06:08:52 <chrisdone> ManateeLazyCat: thanks
06:08:57 <ManateeLazyCat> chrisdone: Confucius 强调的是 “儒家思想“
06:09:18 <chrisdone> sure
06:12:19 <ManateeLazyCat> chrisdone: 在中国， 大多数人接受的都是 “儒家思想“， 以“仁”为核心，以“礼”为形式，重在修身。
06:13:51 <ManateeLazyCat> chrisdone: In other side, China government like Confucius (KongZi)'s philosophy.
06:14:24 <ManateeLazyCat> chrisdone: 儒家思想从某种程度上讲的是对统治阶级的“顺从“
06:15:00 <chrisdone> ManateeLazyCat: I thought Taoism was thrown out in the 1500s in favor of Buddhism (the state changed its main religion)?
06:15:05 * chrisdone checks 
06:15:11 <ManateeLazyCat> Confucianism some extent is obedience to the ruling class 
06:15:26 <chrisdone> no, sorry, it was the other way round
06:15:44 <chrisdone> sure
06:15:53 <ManateeLazyCat> chrisdone: If you really like Chinese philosophy, you should read Chinese resource, and not English version.
06:16:23 <chrisdone> easier said than done :-P
06:16:25 <ManateeLazyCat> chrisdone: English is not exact, sometimes it's not correct.
06:17:12 <ManateeLazyCat> chrisdone: That's why i don't use Google Translation for Chinese philosophy, it's not correct. :)
06:17:19 <p_l> haha
06:17:35 <p_l> I'd avoid statistical translation systems when it comes to philosophy anyway :D
06:17:50 <mauke> heh, I wouldn't trust Google Translate for German philosophy texts, much less Chinese
06:17:51 <chrisdone> ManateeLazyCat: in The Complete Works of Chuang Tzu, the translator is an experienced interpreter of Chinese language and philosophy. it would take years and years for me to get an accurate reading equal to his
06:17:54 <romildo> Does Haskell supports lambda expressions with more than one clause? Something like the ones introduced with the function keyword of OCaml.
06:18:05 <Jafet> You can cycle a koan through translation party and bet on even odds the result makes more sense
06:18:11 <mauke> romildo: no
06:18:35 <Philonous> romildo: No, use case
06:19:22 <Jafet> Or let.
06:19:29 <ManateeLazyCat> chrisdone: So stop read English version, Chinese philosophy is so profound even translator can't understand correctly. 
06:20:02 <ManateeLazyCat> chrisdone: You can join #mandarin to study Chinese.
06:20:19 <ManateeLazyCat> chrisdone: Have many kind people will help you at #mandarin
06:20:21 <mauke> No, John. You are the translator.
06:20:30 <mauke> And then John didn't understand correctly.
06:20:33 <chrisdone> ManateeLazyCat: I already have to learn Italian :-P first. purchasing Rosetta Stone as we speak. thanks for the tip
06:20:35 <ManateeLazyCat> chrisdone: Of course, if you like, i can teach you Chinese. :)
06:20:41 * chrisdone laughs at mauke
06:21:17 <chrisdone> ManateeLazyCat: some day that would be nice. right now I need to concentrate on Italian
06:21:59 <ManateeLazyCat> chrisdone: 我见过一个墨西哥人， 用 新华字典 自学中文， 说的非常好， 把我这个中国人都骗了
06:22:01 <chrisdone> otherwise i'll ask for a pizza in chinese
06:22:17 <ManateeLazyCat> chrisdone: pizza mean 披萨
06:22:22 <mauke> heh, reminds me of Raymond Chen
06:22:42 <ManateeLazyCat> chrisdone: PinYin of 披萨 is "Pi Sha"
06:22:53 <chrisdone> Pi Sha, fun
06:23:05 <ManateeLazyCat> chrisdone: "Pi (1) Sha (2)",
06:23:06 <chrisdone> there is no 'z' sound in Chinese?
06:23:20 <geheimdienst> chrisdone, http://www.youtube.com/watch?v=9JhuOicPFZY
06:23:28 <chrisdone> actually it's not a 'z' sound. it's 'ts'
06:23:35 <ManateeLazyCat> chrisdone: Have.
06:23:44 <mauke> 'z' is a 'ts' sound! (if you're German)
06:24:19 <chrisdone> I suppose 'z' is voiced 'ts', but I'm not sure
06:24:38 <chrisdone> no, it's voiced 's'. d'oh
06:25:06 <ManateeLazyCat> chrisdone: 'z' sound 日， But do not say the Chinese word, is abusive.
06:25:10 <chrisdone> ManateeLazyCat: I'd like to help your English by correcting you, but most of the time I don't know where to start
06:25:28 <geheimdienst> lol
06:25:31 <ManateeLazyCat> chrisdone: No worried, i know how bad my English.
06:25:43 <ManateeLazyCat> chrisdone: I will study at here slowly....
06:26:42 <ManateeLazyCat> chrisdone: The biggest problem of my English is not i can't understand it, just haven't environment let me talk.
06:26:49 <chrisdone> ManateeLazyCat: I suppose Romance languages and Chinese are very far apart, so it's a lot harder to speak idiomatically without loads of practice
06:27:03 <chrisdone> sure
06:27:30 <ManateeLazyCat> chrisdone: Infact, i can't speak English, but i can understand Haskeller's paper. :)
06:27:37 <mauke> internet++
06:27:51 <ManateeLazyCat> chrisdone: I am self-taught in English. 
06:29:04 <chrisdone> ManateeLazyCat: we could both learn Lojban in 3 months and be proficient :-P
06:29:04 <ManateeLazyCat> chrisdone: Chinese have tonal, so Romance character can't explain Chinese correctly, that's why i don't use Romance write my Chinese name.
06:29:35 <mauke> yay, lossy transformations
06:30:03 <mauke> just write the unicode codepoints :-)
06:30:19 <ManateeLazyCat> chrisdone: IIRC, have 57483 character in Chinese, it's long way to proficient. 
06:30:24 <chrisdone> "Chinese is tonal" (like Chinese is fun, Chinese is a language)
06:30:30 <Phyx-> > 4
06:30:31 <Ke> you can use the phonetic alphabet
06:30:31 <lambdabot>   4
06:30:38 <Phyx-> ok, still connected
06:30:58 <ManateeLazyCat> mauke: Then most people in this world can't display it, because they haven't install CJK font.
06:31:08 <mauke> ManateeLazyCat: no, I mean the numbers
06:31:09 <chrisdone> ManateeLazyCat: 57,483 characters, and how many words? it seems like the vocabulary and the orthography are more or less merged
06:31:39 <ManateeLazyCat> mauke: Use Chinese unicode name hinder communication with English people.
06:32:09 <Ke> ManateeLazyCat: mind you that most english speakers are not english
06:32:11 <Jafet> The West African tribe languages are so tonal, they can speak from a tuned drum
06:32:23 <mauke> heh, Andy Stewart?
06:33:11 <chrisdone> Ke: is that true or just exaggeration to get the point across?
06:33:34 <Twey> Of course it's true
06:33:41 <chrisdone> (guessing by "not english" you meant "not native speaker")
06:33:42 <Jafet> That depends on how one defines englishspeakingness and englishpeopleness.
06:33:44 <mauke> chrisdone: some are welsh or irish
06:33:45 <Twey> The Indians and Americans outnumber the English severely
06:34:23 <chrisdone> well obviously if you're saying person of England, well, yeah
06:34:49 <chrisdone> I thought he meant a native english speaker, like,  australian, british, american, south african, etc.
06:34:55 <aristid> seemingly many people think that recursion is "very abstract". weird, i find direct recursion to be extremely low-level (compared to, say, folds)
06:35:00 <tensorpudding> The UK is a small place nowadays
06:35:19 <Jafet> aristid: hence why seemingly many people think that recursion is abstract
06:35:40 <Twey> ManateeLazyCat: You can write tones using numerals: pi1sa4
06:35:53 <aristid> Jafet: hence what?
06:35:55 <Twey> Or Cantonese-style, pi¹sa⁴
06:36:08 <Twey> Or with diacritics, pīsà
06:36:14 <Jafet> aristid: what what?
06:36:43 <tensorpudding> the UK is the home of soccer, but how many world cups have they won?
06:36:54 <aristid> Jafet: why do people think that recursion is abstract, you said "hence why"
06:36:57 <aristid> ?
06:37:08 <Jafet> aristid: what does the word "abstract" mean to you?
06:37:09 <aristid> Jafet: or was that a question?
06:37:33 <Twey> It depends how you define ‘English’, though.  I generally prefer to avoid considering American the same language nowadays, since they're setting their own standards of correctness.
06:37:36 <chrisdone> Wikipedia says, of English:
06:37:36 <chrisdone> First language: 309–400 million
06:37:36 <chrisdone> Second language: 199–1,400 million
06:37:47 <aristid> Jafet: that is a good question, i think it would mean "level of detail"
06:38:09 <aristid> that's at least a definition that somebody else came up with, and i agreed with it
06:38:16 <Twey> chrisdone: 199–1,400?  That's an awfully big deviation.
06:38:22 <Jafet> aristid: or by "folds" you mean combinatory logic?
06:38:34 <aristid> Jafet: by folds i mean functions like foldr
06:39:04 <Jafet> If you want to avoid explicit recursion, functions such as folds allow you to use combinators instead
06:39:05 <Twey> tensorpudding: One
06:39:18 <tensorpudding> well,more than the US anyway
06:39:28 <Twey> Brazil is leading on that score
06:39:34 * geheimdienst lols. geheimdienst likes how they wrote "199" instead of "200" so that the wildly inaccurate estimate looks precise and official
06:39:47 <aristid> Jafet: exactly
06:39:48 <Twey> geheimdienst: Hehe
06:39:59 <Jafet> I regard them as equivalent, because you can trivially map combinators and direct recursion -- see also unlambda/jot
06:40:15 <geheimdienst> and yes, the spread "199 - 1,400" adds a whole new level of hilarity
06:40:18 <chrisdone> http://www.ethnologue.com/show_language.asp?code=eng
06:40:23 <aristid> Jafet: equivalence can mean many things
06:40:29 <benmachine> I once heard that a study found some element of their data came to exactly 15,000, so they changed it to 15,009 to make sure people didn't think they'd rounded
06:40:30 <Twey> geheimdienst: I doubt it is a wild estimate — I suspect, with a range that huge, that there are precise statistical lower and upper bounds
06:40:51 <Twey> geheimdienst: And it's just the bit in between that's fuzzy.
06:42:01 <chrisdone> have to take into account who's judging fluency, what motivations there are for claiming X number of speakers in my school, tourist town, county, country at some speaking level
06:42:02 <Jafet> aristid: the extent to which changing any fragment of code between either notation affects the rest of a program (here, usually close to nil)
06:43:32 <aristid> Jafet: affecting in what way?
06:43:55 <Jafet> Any sane metric you like. I'm making this all up as we go along
06:44:30 <geheimdienst> twey, i still think it's misleading and suggesting precision which isn't there. if you do something like a census, there's gonna be an error margin of a few percent in an industrialized country. in a more disorganized country, it'll be more. so on the question "how many people are there" there's already a lot of margin
06:44:35 <ManateeLazyCat> chrisdone: Sorry, network problem.
06:44:40 <ManateeLazyCat> chrisdone: I missing something?
06:45:02 <chrisdone> ManateeLazyCat: nope :-)
06:45:04 <geheimdienst> for the question of "how many people are there who have english as a 2nd language", there's even more margin. i know 100 words of english. am i a "speaker"? where is the boundary?
06:45:06 <aristid> Jafet: i somehow find code with explicit recursion harder to read than code with folds
06:45:36 <ManateeLazyCat> chrisdone: Do you have any Chinese word want to study? I can teach you. :)
06:45:55 <Jafet> aristid: are you talking about recursion in general, or folds in particular?
06:46:13 <aristid> Jafet: about programming styles
06:46:14 <geheimdienst> so i think saying "199" is baloney. it's the same as inserting random official-sounding words that don't add meaning
06:46:47 <Jafet> geheimdienst: 199 is a natural number. It doesn't mean anything.
06:46:48 <ski> aristid : seen "The Anatomy of a Loop" at <http://www.cc.gatech.edu/~shivers/papers/loop.pdf> by Olin Shivers (2005-09) ?
06:46:48 <chrisdone> ManateeLazyCat: no, not right now. my Rosetta Stone Italian pack downloaded. thanks for offering, though
06:47:05 <Phyx-> what the.. what an off topic discussion
06:47:07 <Phyx-> lol
06:47:33 <geheimdienst> jafet, i meant what chrisdone quoted from wikipedia. "number of english speakers (2nd language): 199 - 1,400 million"
06:47:45 <aristid> ski: 404 not found
06:47:52 <ski> (bah, broken link)
06:48:05 <Jafet> geheimdienst: what does "199 million" mean, in this context?
06:48:37 <aristid> ski: http://www.ccs.neu.edu/home/shivers/papers/loop.pdf
06:48:47 <ski> aristid : try <http://www.ccs.neu.edu/home/shivers/papers/loop.pdf>
06:48:49 <ski> yeah
06:48:57 <ManateeLazyCat> chrisdone: Ok, it's time to read Haskell paper now, nice to meet you. :)
06:49:09 <chrisdone> ManateeLazyCat: okay ;-) enjoy
06:49:47 <Twey> geheimdienst: All of which is true, and the whole point of the huge range between the upper and lower bounds
06:49:49 <geheimdienst> jafet, it means "look how well we have studied this, we totally know 200 would be too much, and 198 too little, so 199 is precisely right as the lower bound"
06:50:10 <Jafet> geheimdienst: and on what information do you base that statement?
06:50:15 <geheimdienst> i agree, twey
06:50:50 <geheimdienst> jafet, on the information that they put "199" there
06:51:03 <Jafet> Then you are the one that's been spouting baloney. Okay.
06:51:31 <chrisdone> geheimdienst: do you think 12345 is less likely than 19352 in a randomly generated number?
06:51:59 <Jafet> Well, that depends on the distribution.
06:52:03 <chrisdone> 5 digits
06:55:19 <geheimdienst> jafet, i think it is naive if you assume numbers don't "mean" anything, as in, they never are used for impressing people. a number is only as trustworthy as the guy who came up with it. it's only as reliable as the work that went into determining it
06:55:52 <geheimdienst> of course numbers are used to impress people, to sound knowledgeable, to sound official, all kinds of things. it's naive to ignore that
06:56:04 <Jafet> I think it is naïve to criticize any publication without reading it
06:56:13 <Jafet> Unless it's the rulebook for FATAL.
06:56:20 <chrisdone> lol
06:58:43 <olsner> again, #haskell-blah and #haskell have switched places
06:59:22 <chrisdone> two sides of the same coin i guess
06:59:34 <Jafet> At least C++ never came up this time
07:00:18 <Philonous> Jafet: Now it did.
07:00:42 <olsner> don't mention not mentioning the war
07:01:10 <chrisdone> in before someone innocently says "I like C++ but I don't like X" and then someone responds to it and the avalanche becomes unstoppable
07:01:18 <Gracenotes> the main difference between C++ and C is that C is like an out-of-tune Spanish guitar, whereas C++ is like a party on a motorboat
07:01:33 * chrisdone watches patiently
07:01:52 <olsner> @quote screwdriver
07:01:52 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
07:02:12 <olsner> (speaking of spanish guitars and motorboats)
07:03:44 <p_l> wasn't C a malformed (musical) triangle?
07:05:41 <Tomsik> C is a sound
07:05:48 <Tomsik> so is C#
07:06:13 <Philonous> geheimdienst: Those numbers are just utterly out of context. Citing them without explanation seems like an error to me. That doesn't mean they are not justifiable.
07:06:39 <Tomsik> and C++ is to this channel what godwin's law is to the rest of the internet
07:07:04 <Philonous> Tomsik: Obviously you people are trying very hard to keep it that way ;)
07:07:24 <p_l> Tomsik: hahaha
07:08:09 <p_l> Tomsik: unlike in #lisp, where C++ becomes usual starter to "how the fuck are we going to interop with it???"
07:08:53 <Tomsik> heh
07:09:15 <Tomsik> actually, is lisp worth learning?
07:09:33 <byorgey> IMO, yes
07:09:36 <aristid> scheme is pretty small, so that's perhaps easier
07:09:44 <aristid> but common lisp is teh lisp
07:09:51 <byorgey> Tomsik: read Paul Graham's "ANSI Common Lisp"
07:09:56 <byorgey> it's a great book
07:09:57 <arw> yes, you should learn lisp or scheme. try SICP.
07:10:03 <aristid> byorgey: the Arc guy? /o\
07:10:11 <byorgey> aristid: yes, the Arc guy.
07:10:11 <Tomsik> hmm
07:10:26 <byorgey> it turns out people can do awesome and dumb things in the same lifetime
07:10:34 <aristid> no wai
07:10:44 <Tomsik> Arc?
07:10:46 <pkrumins> don't start with sicp, start with the little schemer.
07:11:01 <Philonous> Btw, does someone know whether liskell is still developed?
07:11:10 <byorgey> Tomsik: don't ask.  Google it if you really want to know =)
07:11:37 <Tomsik> heh
07:11:47 <Tomsik> The problem is that google is unlikely to give a short answer
07:12:00 <Tomsik> and when you open up wikipedia, you don't come out
07:12:19 <Twey> Philonous: AFAIK, it's not ☹
07:12:32 <byorgey> Tomsik: arclanguage.org
07:12:36 <ski> preflex: xseen therp
07:12:36 <preflex>  therp was last seen on freenode/#xmonad 25 days, 18 hours, 21 minutes and 48 seconds ago, saying: SparFux: gridselect in theory should be able to do that, it was generalized to select arbitrary objects, so with the right tricks you could select desktops, commands, etc
07:12:56 <Philonous> Twey: Bummer. I'd love to see how haskell and lisp macros interact
07:13:09 <Phyx-> haskell has macros?
07:13:10 <ski> (Philonous : you could ask therp, whenever s/he comes online ..)
07:13:32 <Twey> Phyx-: TH
07:13:33 <Philonous> Phyx-: No, but liskell does (or you could trivially add them)
07:13:48 <Phyx-> Twey: ah
07:14:00 <Twey> Phyx-: It's just that laziness obviates much of the need for macros as commonly used in Lisps
07:14:08 <Twey> Phyx-: So you don't see it as much
07:14:09 <Phyx-> Philonous: what the heck is liskell? that sounds murder on my ( key
07:15:03 <Philonous> Phyx-: It's haskell in s-expressions
07:15:34 <Philonous> Phyx-: it was implemented as a ghc front end, iirc
07:15:46 <Phyx-> aha
07:19:12 <tolkad> Is it possible to do something like: data T = TA | TB | TC TA | TC TB
07:19:17 * hackagebot accelerate 0.7.1.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.7.1.0 (ManuelChakravarty)
07:20:20 <Twey> tolkad: No
07:20:22 <tolkad> and remember http://www.biblegateway.com/passage/?search=Deuteronomy%2025:11-12&version=NIV
07:20:28 <Phyx-> Twey: no, TB and TA are constructors not types
07:20:49 <Phyx-> err
07:20:52 <Phyx-> tolkad
07:20:53 <Twey> tolkad: If it were, how would you deconstruct a TC?  You wouldn't know whether its parameter were of type TA or TB.
07:21:12 <Twey> And yes, the two ‘TA’s you've used there are quite distinct.
07:21:20 <Phyx-> tolkad: also, what you describes is basically data T = TA | TB | TC T
07:21:40 <ski> no, the types `TA' and `TB' may be distinct from `T'
07:22:06 <Twey> data T = TA | TB | TC (Either TA TB) -- this works
07:22:31 <Phyx-> ski: sure, but I assume he was refering to the ones in T in his example
07:22:32 <Tomsik> does it?
07:22:32 <byorgey> no it doesn't, not unless TA and TB are types 
07:22:48 <Twey> byorgey: Yes, we've covered that
07:22:49 <Tomsik> data TBase = TA | TB
07:22:54 <Tomsik> data T = TC TBase
07:22:55 <Tomsik> :p
07:23:09 <Twey> byorgey: I was assuming that they were intended to be.
07:23:13 <Phyx-> you don't need the indirection
07:23:17 <byorgey> I was assuming nothing of the sort.
07:23:41 <byorgey> I suppose we whould ask tolkad =)
07:23:42 <Twey> byorgey: Clearly, despite the fact that we have already covered it :þ
07:23:42 <Phyx-> neither did I
07:24:03 <Phyx-> tolkad: what did you intend?
07:24:09 <romildo> Is there anything that would let me use the same label for fields in different record types?
07:24:22 <byorgey> romildo: sadly, no
07:24:24 <romildo> An extenstion, for instance.
07:24:33 <ski> romildo : place them in different modules
07:25:13 <romildo> Unfortunatly the record types belong to the same module.
07:25:52 <Twey> romildo: Well, they shouldn't.
07:25:59 <ski> romildo : this is a price we pay on (heavy-weight records) for having type inference
07:26:02 <Twey> Move them.  :þ
07:28:31 <romildo> I am defining data types for abstract syntax trees for a Tiger compiler I am writing. Almost every data type would be a record with a "position" field. Putting the type definitions into different modules would be strange. Some of them are indeed mutually recursive.
07:29:30 <Twey> Consider splitting them
07:30:00 <Twey> data Positioned a = Positioned { position :: PositionType, data :: a }
07:30:48 <byorgey> although that does get tedious for other reasons
07:30:49 <romildo> If all of the ast had a position, I would factory it out. But some of them has the position inside one of its fields.
07:31:50 <Twey> You don't have to use Positioned for types that don't have positions.
07:32:49 <p_l> Tomsik: btw, regarding Common Lisp, don't got with Graham till you're quite used to CL.
07:33:13 <p_l> Tomsik: also, feel free to come to #lisp, I don't want to spam this channel with more off-topic :)
07:34:52 <Tomsik> Well, I'm just wondering about it right now, honestly today is not a good day for learning for me, considering last night :p
07:35:34 <Twey> romildo: Also, class Positioned a where pos :: a -> PositionType; instance Positioned (Positioned a) where pos = position; instance Positioned OtherType where pos = otherField
07:35:37 <Baughn> @tell ivanm There's a problem with the indenter in general: It doesn't parse Haskell, but a simplified grammar that merely *resembles* haskell. I'm working on it.
07:35:37 <lambdabot> Consider it noted.
07:36:41 <p_l> Tomsik: check priv for materials :)
07:36:51 <p_l> Baughn: hi
07:42:26 <tolkad> > data T = TA | TB | TC TA
07:42:27 <lambdabot>   <no location info>: parse error on input `data'
07:43:07 <tolkad> why doesn't that work?
07:43:10 <ski> aristid : some other related links : <http://groups.google.com/group/comp.lang.scheme/msg/60dcac5ea812398>,<http://mumble.net/~campbell/scheme/loop-comparison.scm>,<http://mumble.net/~campbell/scheme/foof-loop.txt>,<http://mumble.net/~campbell/tmp/nested-foof-loop.txt>
07:43:11 <tolkad> it says TA is not in scope
07:43:19 <ski> aristid : and two LtU discussions <http://lambda-the-ultimate.org/node/1014>,<http://lambda-the-ultimate.org/node/1026> ..
07:43:34 <dafis> tolkad: TA is not a type
07:43:50 <ski> tolkad : you haven't defined the type `TA'
07:44:02 <tolkad> ski: yeah I did, look earlier on the line
07:44:22 <dafis> tolkad: TA is a constructor for the type T
07:44:27 <ski> no, the `TA' that occurs `data T = TA | TB | TC TA
07:44:45 <ski> ' .. right before the `| TB' is not a type, but a data constructor
07:44:49 <aristid> ski: woah lots of links
07:44:53 <ski> (of the type `T' which you're defining)
07:45:15 <ski> aristid : i found them interesting :)
07:45:16 <tolkad> well I can treat constructors as types ususally
07:45:22 <ski> no, you can't
07:45:32 <aristid> ski: yeah i bet they are :)
07:45:53 <tolkad> > f x = False :: a -> False
07:45:54 <lambdabot>   <no location info>: parse error on input `='
07:46:03 <dafis> tolkad: you may be confused by data constructors having the same name as the type
07:46:04 <tolkad> > let f x = False :: a -> False in f 2
07:46:05 <lambdabot>   Not in scope: type constructor or class `False'
07:46:15 <mornfall> Con I use multiple pattern matches in a lamba? :)
07:46:19 <tolkad> dafis: but I can do pattern matching on them at runtime
07:46:21 <mornfall> s/Con/Can/
07:46:25 <theorbtwo> "Punning", making a constructor with the same name as the name of the type, is quite common -- but that doesn't mean that they are the same thing.
07:46:31 <tolkad> dafis: the information must be there at runtime why can't I use it
07:46:47 <ski> aristid : the ones on `mumble.net' describe Riastradh's (Taylor Campbell's) `foof-loop' looping macro, that was inspired by Shivers' paper (but not as "far reaching")
07:47:03 <Zao> mornfall: \x -> case x of ...
07:47:05 <Zao> :D
07:47:06 <dafis> tolkad: pattern matching is "what constructor has been used for this value"
07:47:17 <mornfall> Zao: I was trying to make it a bit more concise :P
07:47:25 <tolkad> dafis: yes, so it must store that with the value unless it gets optimized
07:47:29 <ski> mornfall : unfortunately not (if you mean alternative patterns, rather than a nested pattern, with sub-patterns)
07:47:31 <Zao> mornfall: I did just this with a single pattern the other day.
07:47:41 <mornfall> Yeha, I know about case.
07:47:46 <Zao> mornfall: Almost on the level of  if foo then true else false
07:47:48 <dafis> tolkad: no, type checking is completely compile-time
07:48:19 <mornfall> Well, first-class patterns would be best here, but failing that...
07:48:35 <ski> tolkad : which information must be there at run-time ?
07:48:55 <mornfall> (I am trying to factor out a lot of "get me first value using this constructor in a list" functions...)
07:49:26 <mornfall> Can't use SYB since the type in questin has an existential constructor...
07:49:31 <mornfall> +o
07:49:31 <Zao> There should exist a keyword bytheway that would be like where but inline.
07:49:49 * ski is not convinced `first-class patterns' is a meaningful concept (as it's usually portrayed, at least)
07:49:50 <mornfall> The best I got to is this:
07:49:51 <mornfall> enabled = getattr False $ \k -> case k of Enabled j -> Just j ; _ -> Nothing
07:50:07 <Zao> foo bar (bytheway {f (A a) = ...; f B = ...})
07:50:31 * Heffalump wants to read Barry Jay's book about first-class patterns but it's really expensive
07:50:47 <Heffalump> mornfall: do view patterns help?
07:51:04 <ski> mornfall : .. i suppose you could define a `fromEnabled :: Whatever -> Maybe Something'
07:51:40 <mornfall> ski: Well, that's what is inline in there. It's not like I would have any other use for fromEnabled, though.
07:51:45 <ski> (mornfall : or, if we had monad comprehensions, `\k -> [j | Enabled j <- k]' would work, i think)
07:52:15 <mornfall> Heffalump: I'll have to read up on view patterns to see.
07:52:23 <tolkad> wtf GHC is hanging compiling my program
07:52:26 <ski> (hm, actually, .. so `\k -> do Enabled j <- k; return j' should work, i think :)
07:52:33 <mornfall> tolkad: UndecidableInstances? :D
07:52:44 <tolkad> http://pastebin.com/RPzVr5xn
07:52:49 <tolkad> that's my program
07:52:52 <aristid> :t \k -> do Left j <- k; return j
07:52:53 <lambdabot> forall (m :: * -> *) b t. (Monad m) => m (Either b t) -> m b
07:53:01 <tolkad> why is GHC not halting
07:53:32 <tolkad> wtf it's not even giving me an error this must be a bug
07:54:03 <Twey> ski: The ability to define patterns as a data structure, and e.g. matchPattern :: PatternType a => Pattern a -> Maybe a
07:54:05 <ski> that program (in itself) looks ok ..
07:54:05 <tolkad> that's a simple program! why would GHC have a bug compiling such a simple program?
07:54:30 <tolkad> I ran GHC --make Main.hs && ./Main
07:54:34 <ski> Twey : and how to represent the free variables (to-be-bound) of the pattern ?
07:54:46 <mornfall> This is what bothers me: http://paste.dqd.cz/vJUS/
07:54:46 <tolkad> ski: obviously GHC doesn't think so
07:54:47 <Twey> matchPattern <[a] -> a> [3] -- ==> 3
07:54:59 <dolio> Have you typed something in yet?
07:55:21 <dafis> tolkad: works here
07:55:23 <tolkad> ski: I was proving it has to store the constructor of the "int" variable at runtime rather than compile time
07:55:31 <Philonous> tolkad: Might it be that it is blocking on getline?
07:56:00 <Twey> Er, I meant matchPattern :: PatternResult r => Pattern a r -> a -> Maybe r, I guess
07:56:12 <tolkad> oh... right *facepalm* I forgot GHC doesn't print a message saying it's done
07:56:17 <Twey> And maybe patternMatches :: Pattern a r -> a -> Bool
07:56:33 <Twey> Hm, this looks like an arrow?
07:56:37 <tolkad> ski: well, anyway, that proves it has to do matching on constructors at runtime
07:56:49 <ski> tolkad : yes, `data' constructors (but not `newtype' ones) are stored at run-time .. types themselves are not, however (maybe you weren't claiming this, but it's hard to be sure)
07:56:56 <ski> tolkad : agreed
07:56:56 <Twey> Anyway, that idea.
07:57:19 <Phyx-> hrm, interesting the infered type for "4" is Integer, I expected that to be Num t => t
07:57:31 <Twey> Phyx-: GHCi defaulting
07:57:38 <Twey> Phyx-: It's Num t => t in real programs
07:57:41 <Phyx-> Twey: but i'm not using ghci
07:57:48 <Twey> :t 4
07:57:49 <lambdabot> forall t. (Num t) => t
07:57:59 <dafis> Phyx-: monomorphism restriction
07:58:02 <tolkad> :t "4"
07:58:03 <lambdabot> [Char]
07:58:06 <tolkad> no, it's [Char]
07:58:07 <Twey> Ah, aye
07:58:12 <Phyx-> dafis: ah
07:58:12 <Twey> tolkad: Heh
07:58:20 <ski> tolkad : still, in `data T = TA | TB | TC TA' you might as well say `data T = T0 | T1 | T2 TA' .. the two `TA's in the former have nothing to do with each other - they live in different namespaces - one being a data constructor, the other being a type (constructor)
07:59:21 <tolkad> ski: oh
07:59:50 <tolkad> ski: what if that particular constructor only makes sense when constructed with a certain other?
08:00:13 <tolkad> *sigh* this is going to make my code more verbose, thanks
08:00:27 <Zao> Enforce the invariant elsewhere?
08:00:35 <ski> tolkad : the general (well, to a first approximation) shape of a `data' declaration is `data NewTypeToBeDefined = DataConstructor0 Type00 Type01 ... | DataConstructor1 Type10 ... | ...'
08:01:06 <tolkad> Zao: so some newTC :: T -> Maybe T?
08:01:24 <ski> .. note that the first item in each alternative branch is the name of a data constructor, while all the rest of them (if any) in the branch are to be types
08:01:47 <Zao> data TA' = TA'; data T = TA TA' | TB | TC TA'
08:02:13 <Zao> That is, TA' is a type with a single constructor TA'.
08:02:26 <tolkad> Zao: no, then I have to write even more code to write all the class instances i need for TA'
08:02:31 <ski> tolkad : well, either you factor out the common parts into a new type .. or you make sure your program never use the additional lee-way (and then you loose a bit of type-checking, for sure)
08:03:09 <tolkad> well actually... I could make TA' never visible directly...
08:03:42 <ski> .. there's also in some cases the possibility to use GADT types to express more nuanced uses
08:04:20 <ski> which is the "correct" way will of course depend on the details of what you want to do
08:05:57 <mornfall> @src reverse
08:05:57 <lambdabot> reverse = foldl (flip (:)) []
08:07:12 <romildo> Can a file have many module definitions?
08:07:26 <dafis> romildo: no
08:07:26 <fxr> @t (>=>)
08:07:27 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:07:38 <fxr> @type (>=>)
08:07:40 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:07:42 <dafis> at least, I know of no implementation which allows that
08:07:53 <ski> @type fix . (>=>)
08:07:54 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
08:07:56 <dafis> It's not forbidden by the language definition
08:08:43 <romildo> dafis, but ghc does not allow it, right?
08:08:53 <dafis> romildo: right
08:09:48 <Gracenotes> modules are second-class.. uh.. fundamental units of organizing code
08:10:47 <Tomsik> why not first-class modules? 
08:10:47 <Tomsik> :p
08:11:15 <Tomsik> in ocaml there's this functor thing that takes a module and returns a module
08:11:17 <ski> it could be interesting, yes
08:11:49 <ski> (SML/NJ,OCaml,Alice ML supports constructing modules/structures at run-time)
08:12:23 <ski> (maybe MLton as well, i'm not sure)
08:12:42 <Tomsik> But I'm not sure if it makes much sense in haskell, the type system seems versatile enough to me
08:12:49 <Tomsik> unlike ocaml
08:12:58 <dolio> I kind of doubt MLton does.
08:12:59 <ski> (Tomsik : in case you've not already seen it <http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html>)
08:13:04 <dolio> But maybe that's just me.
08:13:20 <ski> dolio : hm, on second thought, you're probably right
08:14:22 <ski> (given that MLton is focussed on being highly-optimizing and doing whole-program-compilation)
08:14:43 <dolio> Yes. Runtime loading is kind of the extreme opposite of whole-program.
08:19:40 <interferon> does parsec have a combinator that will read "up to n" times?
08:20:18 <dafis> interferon: as far as I remember, you have to write it yourself
08:20:29 <dafis> it's easy, though
08:21:07 <wli> The module system stuff I've been screaming about forever and failing to even get a grip on the concepts in/around implementation.
08:29:04 <Phyx-> I prefer livemocha
08:29:09 <Phyx-> whoops
08:29:12 <Phyx-> wrong channel
08:33:29 <colinhect> how embarrassing
08:33:40 <dafis> what?
08:34:12 <colinhect> talking in the wrong channel.... I guess I was a little late on that
08:34:34 <dafis> oh, that
08:34:44 * hackagebot wai-handler-fastcgi 0.2.0.1 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.2.0.1 (MichaelSnoyman)
08:34:44 <colinhect> old news
08:36:56 <Phyx-> colinhect: well, they both begin with "haskell"
08:37:03 <Phyx-> would have been worse if it was something embarrasing
08:37:16 <colinhect> true
08:37:27 <Phyx-> btw, anyone here use linux and a ghc 6.13 with prof enabled? i just want to know if it compiles there, before i spend time installing nix
08:40:49 <jmcarthur> conal: accelerate has a cuda backend on hackage now, btw
08:40:57 <conal> jmcarthur: neat!
08:41:24 <jmcarthur> conal: it's not complete yet. lacks a few functions from the interface, as i understand it
08:41:51 <jmcarthur> but i still plan to play around with it at some point
08:42:00 <conal> me too
08:44:48 <hpc> i was looking at accelerate a while back; disappointing that it has no openCL backend
08:45:14 <jmcarthur> hpc: yet
08:45:22 <jmcarthur> i would like to see an opencl backend too
08:45:31 <jmcarthur> that's probably the threshold to cross to get me to use it seriously
08:45:43 <conal> me too
08:45:59 <hpc> i was going to use it seriously for a game engine until i saw it was cuda only
08:46:36 <jmcarthur> i don't know cuda, but it might not be that hard to write an opencl backend based on the cuda backend
08:46:52 <Ke> well how about obsidian
08:47:34 <hpc> @hoogle obsidian
08:47:34 <lambdabot> No results found
08:47:41 <jmcarthur> well, it's not on hackage, which normally leads me to believe that it's not really maintained
08:48:14 <jmcarthur> it's also been a long time since i glanced at the paper and i don't remember what the interface is like
08:55:29 <hpc> it's similar to list comprehensions, iirc
08:59:28 <Tomsik> I doubt that such horrible interface as CUDA can be used in haskell without a serious loss of performance
08:59:51 <Tomsik> the amount of details there is just insane
09:05:02 <alexforster> http://www.cse.unsw.edu.au/~dons/data/Prelude.html x==y = not (x/=y); x/=y = not (x==y)
09:05:07 <alexforster> how's that work?
09:06:00 <Twey> alexforster: You have to override one or the other when implementing the class
09:06:17 <noteventime> alexforster: It's only there so that it will be enough to implement one of them.
09:07:45 <alexforster> oh, that's actually neat then
09:07:57 * hackagebot darcs-benchmark 0.1.8.1 - Comparative benchmark suite for darcs.  http://hackage.haskell.org/package/darcs-benchmark-0.1.8.1 (EricKow)
09:08:25 <Twey> alexforster: It's not neat, because it means that if you forget to override one you get an infinite loop
09:08:44 <Twey> What would be neat is if we had a compiler-checked way to specify minimal complete implementations
09:09:24 <chrisdone> ghc could check if there are multually recursive functions sets that aren't specified
09:10:49 <alexforster> agree, it's something like a circular dependency - compilers are good at finding those
09:10:50 <chrisdone> Warning: (==) and (/=) have mutually recursive definitions, and
09:10:51 <chrisdone>  you have not implemented one. Use -Wf-no-mutal-recursive-method-warnings
09:17:04 <dolio> It's difficult to mess that one up.
09:17:20 <jmcarthur> some things are more complicated though
09:17:38 <dolio> Unless you're under the wild impression that implementing Eq manually doesn't require you to write any functions.
09:17:52 <ski> Warning: `fmap' and `(>>=)' have mutually recursive definitions, and you have not implemented one. Use -Wf-no-mutal-recursive-method-warnings
09:17:56 <ski> ?
09:17:56 <jmcarthur> for example, *i* know that Storable requires sizeOf and alignment, but it would be nice if the compiler reminded me if i forgot one of them
09:18:27 <jmcarthur> as opposed to other methods of the same class
09:18:48 <ski> (.. well, i suppose the wording shouldn't be exactly that, in this case)
09:19:24 * Twey finds it strange that jmcarthur happily (presumably) pressed shift to type his asterisks, but went to lengths to leave the ‘I’ in the middle uncapitalised.
09:19:46 <alexforster> wouldn't the only situation where that helps be when writing prelude? and if you're writing prelude it's going hand-in-hand with a compiler implementation
09:20:26 <Eduard_Munteanu> Hi.
09:20:26 <Zao> Twey: Who knows, he might have a deranged layout where they are unshifted?
09:20:37 <hvr> Zao: like a num keypad? ;)
09:21:00 <Twey> Hence the ‘presumably’
09:21:09 <ski> (.. deranged, yes ;)
09:21:20 <Zao> Odd, my numpad doesn't produce any glyphs on the operator keys.
09:21:36 * Twey 's numpad produces ⋅ on the * key
09:21:43 <alexforster> i don't know, it's neat to me that 'they' even make an attempt at specifying it- if i'm the writer of an ide or lint or doc generator, it's nice that there's an absolutely complete specification as far as the language allows
09:21:45 <Twey> … sometimes
09:21:46 <Zao> Nor honors numlock.
09:21:49 <Zao> No big loss, though.
09:21:50 <Twey> It seems rather finicky.
09:21:54 <Twey> I never use it anyway.
09:22:00 <Zao> Probably have to twiddle putty settings or something.
09:22:11 <Zao> All I use it for is playing DCSS.
09:22:37 <Twey> DCSS?
09:22:45 * ski thought DeCSS was a song ..
09:22:48 <Twey> The Dougherty County School System?  :þ
09:22:51 <Zao> Dungeon Crawl Stone Soup.
09:22:54 <Zao> A roguelike.
09:22:55 <Twey> I see
09:23:30 <Zao> It does have vikeys too though, so I _could_ survive without the numpad.
09:39:10 * hackagebot visual-prof 0.1 - Create a visual profile of a program's source code  http://hackage.haskell.org/package/visual-prof-0.1 (DanielVelkov)
10:13:44 <tolkad> let x <- 5 in x
10:13:46 <tolkad> > let x <- 5 in x
10:13:46 <lambdabot>   <no location info>: parse error on input `<-'
10:13:52 <tolkad> uh how do I do that?
10:14:05 <tolkad> > let (x, y) <- (5, 3) in x
10:14:06 <lambdabot>   <no location info>: parse error on input `<-'
10:14:24 <tolkad> oh, I can just use frst I guess
10:14:37 <tolkad> how would I do it with let syntax though?
10:14:52 <tolkad> > fst (1, 2)
10:14:52 <lambdabot>   1
10:15:01 <tolkad> how do I extract that with let syntax
10:15:04 <tolkad> and <-
10:15:51 <ski> > let (x,y) = (5,3) in x
10:15:52 <lambdabot>   5
10:15:59 <tolkad> oh
10:16:00 <tolkad> thanks
10:16:04 <ski> .. not sure what you're after
10:16:17 <tolkad> that's what I wanted, I got a bit confused between different syntaxes
10:16:22 <ski> `<-' is used in list comprehensions and `do'-notation
10:16:58 <ski> ..
10:20:57 <tensorpudding> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
10:20:58 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:31:14 <hpc> :t par
10:31:15 <lambdabot> forall a b. a -> b -> b
10:31:27 <hpc> > a `par` b `pseq` 5
10:31:28 <lambdabot>   5
10:31:33 <hpc> o.O
10:32:12 <hpc> does lambdabot do all the sparking, or just run them in serial?
10:32:47 <aristid> hpc: i guess it does green threads only
10:32:59 <hpc> green threads?
10:33:42 <aristid> hpc: the kind that runs inside haskell only, on a single cpu
10:33:52 <hpc> ah
10:34:03 <byorgey> hpc: the GHC runtime system manages a pool of threads, which get mapped onto a certain number of OS threads
10:34:10 <byorgey> in lambdabot's case, probably just one OS thread
10:34:19 <Eduard_Munteanu> > fix par
10:34:20 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
10:34:20 <lambdabot>    arising from a use of `...
10:34:27 <hpc> :t fix
10:34:28 <lambdabot> forall a. (a -> a) -> a
10:34:52 <Eduard_Munteanu> > fix (par [1..])
10:34:56 <lambdabot>   mueval-core: Time limit exceeded
10:35:18 <Eduard_Munteanu> Well, can't blame me for trying...
10:35:20 <aristid> :t par [1..]
10:35:21 <lambdabot> forall b. b -> b
10:35:30 <aristid> > par [1..] 4
10:35:31 <lambdabot>   4
10:36:22 <byorgey> x `par` y means "evaluate y, and while you're at it you may want to evaluate x in parallel"
10:36:43 <hpc> x `pseq` y means, evaluate x, then y
10:36:54 <Eduard_Munteanu> Oh, so it's only a hint.
10:37:00 <hpc> a subtle change from seq, which has undefined evaluation order
10:37:30 <hpc> the general usage is a `par` b `pseq` f a b
10:37:35 <byorgey> right, it's only a hint.
10:38:04 <Eduard_Munteanu> hpc: ah.
10:38:45 <Eduard_Munteanu> I thought it'd make a good fork bomb.
10:39:03 <Eduard_Munteanu> @hoogle spawn
10:39:04 <lambdabot> No results found
10:39:10 <Eduard_Munteanu> @hoogle thread
10:39:11 <lambdabot> module Data.Graph.Inductive.Internal.Thread
10:39:11 <lambdabot> Data.Graph.Inductive.Internal.Thread type Thread t i r = (t, Split t i r)
10:39:11 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
10:39:37 <hpc> par is nonstrict when it doesn't make a spark, iirc
10:39:56 <hpc> :t const
10:39:57 <lambdabot> forall a b. a -> b -> a
10:40:10 <hpc> par = flip const, essentially
10:40:19 <ddarius> par is not observably strict regardless
10:40:39 <Eduard_Munteanu> Ah, I see.
10:41:37 <hpc> and pseq is strict with its first argument
10:41:57 <ddarius> Both seq and pseq are strict in their first argument by definition.
10:42:01 <Eduard_Munteanu> :t pseq
10:42:03 <lambdabot> forall a b. a -> b -> b
10:42:12 <hpc> seq is strict with both, which results in undefined evaluation order
10:42:17 <hpc> from what i have read
10:42:28 <ddarius> Both pseq and seq are strict in both arguments.
10:43:26 <Eduard_Munteanu> :t liftM2 pseq
10:43:27 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a2
10:43:32 <Eduard_Munteanu> :t >>
10:43:34 <lambdabot> parse error on input `>>'
10:43:37 <Eduard_Munteanu> :t (>>)
10:43:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:43:40 <hpc> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg11022.html
10:45:28 <napping> tricky
10:45:48 <ddarius> hpc: "as far as the strictness analyzer is concerned"  The way pseq is handled in GHC is a "trick" to get the right behavior.  pseq (and seq) are necessarily strict in their second argument, it is impossible to avoid that.
10:46:40 <Eduard_Munteanu> @free (>>)
10:46:40 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
10:46:48 <Eduard_Munteanu> meh
10:46:53 <Eduard_Munteanu> @free liftM2 pseq
10:46:54 <lambdabot> Extra stuff at end of line
10:47:07 <Eduard_Munteanu> @vixen Nevermind.
10:47:08 <lambdabot> What do you think of Foucault's theory of binary constructs as an imprisoning limitation on power imposed by arbiters?
10:48:02 <napping> hpc: there are some good papers on PH
10:48:52 <hpc> oh i see, it is a ghc trick
10:49:08 <hpc> checked the source; it is a ghc lib call
10:49:31 <ddarius> There is no such thing as a "lazy" identity function.
10:49:58 <napping> the runtime is pretty clever. Cheep (N:M) green threads for normal fork, and even lightwork workstealing queue stuff for thunks. Tasty
10:50:32 <magthe> I'm struggling a bit with Cabal, any gurus around to point out how I can get the value of a flag inside a hook (the postBuild hook to be precise)?
10:50:39 <illissius> workstealing
10:50:43 <illissius> how tom sawyer-ish
10:50:52 <illissius> i wish someone would steal my work so i don't have to do it
10:51:28 <napping> Have you tried hanging around people with nothing to do?
10:52:18 <illissius> nein
10:52:35 <monochrom> it seems BuildFlags is a parameter to postBuild.
10:52:55 <Eduard_Munteanu> There's a slight difference between that and being busy doing nothing ;)
10:53:19 <ddarius> In the grand scheme of things we are all just busy doing nothing.
10:53:40 <Eduard_Munteanu> How nihilist :)
10:53:57 <napping> careful, don't fall into the Total Persepective Vortex
10:55:47 <magthe> monochrom: true, but it doesn't seem to contain the values of the flags I pass in to configure (-f Foo)
10:58:37 <zygoloid> is there a way to expand a type function in ghci?
11:04:59 <jmillikin> I'm trying to profile some code using +RTS -p, but the .prof file shows 99% of the time being used in my (trivial) benchmark function. I suspect that all of the code is being inlined into this one function somehow, but compiling with -O0 doesn't fix it. Is there anything I can do to get accurate profiles?
11:05:28 <dafis> jmillikin, lots of {-# SCC "foo" #-}
11:07:16 <jmillikin> I'm using -auto-all -caf-all, do I still have to use SCC pragmas
11:08:13 <dafis> jmillikin, if the profile doesn't show anything, you may have to, but perhaps your code is too lazy
11:08:37 <dafis> so everything only gets evaluated in the top function
11:09:09 <dafis> adding strictness can also make more functions show up
11:12:39 * hackagebot elerea 2.0.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.0.0 (GergelyPatai)
11:16:40 * hackagebot elerea-examples 2.0.0 - Example applications for Elerea  http://hackage.haskell.org/package/elerea-examples-2.0.0 (GergelyPatai)
11:21:41 * hackagebot dow 0.2.1 - Dungeons of Wor  http://hackage.haskell.org/package/dow-0.2.1 (GergelyPatai)
11:23:42 <interferon> i'm looking at formlets and it seems like they create numbered form fields - how do i refer to these fields in javascript?
11:23:43 <romildo> Isn't there any fold over two lists in the standard library?
11:24:13 <Heffalump> what would it do?
11:24:21 <interferon> romildo: foldr (\(x, y) -> dsfsff) init $ zip list1 list2 ?
11:24:22 <Heffalump> you probably want zip then fold
11:24:37 <romildo> yes
11:26:43 <interferon> romildo: well there you go
11:27:13 <romildo> thanks
11:29:31 <interferon> is there some comprehensive document on formlets?
11:29:46 <interferon> they seem fascinating but all i see about them is one blogpost on tupil.com
11:30:36 <illissius> zygoloid: iirc you can do it by making it print an error :) maybe even just "no show instance for...", can't remember
11:32:50 <zygoloid> illissius: "no instance for" is the error i'm trying to figure out
11:32:59 <zygoloid> (it didn't expand the type function there)
11:33:42 <zygoloid> i had a guess at the type, and did: [undefined :: TheTypeFunction, undefined :: MyGuessOfTheType], and it worked, so my guess must have been right
11:34:09 <illissius> heh, ok then
11:35:09 <illissius> i remember reading some blog post or paper where they were demonstrating type functions and noted that the only way they could get ghci to print the evaluated type was some kind of error... but can't remember what or where
11:35:46 * hackagebot species 0.3.1 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.1 (BrentYorgey)
11:36:04 <pastorn> i want to write something similar to mapM_ for the state monad for Yampa arrows
11:36:25 <pastorn> basically i have f :: inp -> s -> (out,s)
11:36:32 <pastorn> but i get a [inp]
11:38:24 <byorgey> illissius: you're probably thinking of my blog post http://byorgey.wordpress.com/2010/07/06/typed-type-level-programming-in-haskell-part-ii-type-families/
11:39:00 <byorgey> although I think I've seen the technique elsewhere before
11:40:33 <ddarius> It has a long history.  It was used in the early parts of C++ template metaprogramming and also for MPTC/FD based type-level programming in Haskell.
11:41:05 <illissius> byorgey: yep, that was it
11:42:40 <djahandarie> Hm, I need an (a -> a) -> StateT s m a -> StateT s m a    or    (m a -> n a) -> StateT s m a -> StateT s n a
11:43:04 <aristid> :t withState
11:43:04 <lambdabot> forall s a. (s -> s) -> State s a -> State s a
11:43:08 <aristid> :t withStateT
11:43:09 <lambdabot> forall s (m :: * -> *) a. (s -> s) -> StateT s m a -> StateT s m a
11:43:13 <illissius> byorgey: when can we expect the next entry, by the way? :)
11:43:26 <djahandarie> aristid, that's for the state, not for the value inside of the monad
11:43:27 <aristid> oh that transforms the wrong thing
11:43:36 <aristid> djahandarie: fmap?
11:44:01 <djahandarie> Oh
11:45:00 <djahandarie> Wait
11:45:06 <djahandarie> I need (m a -> n a) -> StateT s m a -> StateT s n a
11:45:11 <djahandarie> The first one wouldn't work
11:45:22 <djahandarie> Since I have an IO () -> IO ()
11:45:53 <interferon> djahandarie: that's an unusual type signature
11:45:57 <pastorn> indeed
11:46:09 <pastorn> you want to change the transformer?
11:46:19 <djahandarie> It'd from a   handle (throwTo tid)
11:47:15 <djahandarie> @hoogle handle
11:47:15 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
11:47:15 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
11:47:16 <lambdabot> Control.Exception.Base handle :: Exception e => (e -> IO a) -> IO a -> IO a
11:47:24 <djahandarie> @hoogle throwTo
11:47:25 <lambdabot> Control.Concurrent throwTo :: Exception e => ThreadId -> e -> IO ()
11:47:25 <lambdabot> Control.Exception throwTo :: Exception e => ThreadId -> e -> IO ()
11:47:25 <lambdabot> Control.OldException throwTo :: Exception e => ThreadId -> e -> IO ()
11:47:34 <byorgey> illissius: soon, hopefully tomorrow or Tuesday
11:47:35 <djahandarie> So I end up getting stuck with IO () -> IO ()
11:47:55 <djahandarie> And I need to somehow make that fit in with my StateT
11:48:13 <illissius> byorgey: awesome :]
11:49:04 <djahandarie> And it was mentioned in here that it'd be impossible to make IO () -> IO () switch to IO ((), x) -> IO ((), x)
11:49:06 <byorgey> I'd think you could do  (forall a. m a -> n a) -> StateT s m a -> StateT s n a
11:49:16 <djahandarie> Hmmm
11:49:18 <byorgey> but not sure about the non-rank-2 version
11:49:51 <djahandarie> What would the code for that look like? Because runStateT gives back an (a,s)
11:50:35 <ski> @type mapStateT
11:50:37 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
11:52:10 <djahandarie> Right, but I can't make my IO () -> IO () fit into that
11:53:19 <ski> "monad tunneling" ?
11:56:52 <djahandarie> :-(
11:58:09 <Figs_> Hello, is there anyway with parsec to do a match like "manyTill" but returning both the matched result and the stop result?
12:00:42 <dafis> Figs_: not in the library, write yourself. e.g. do { list <- manyTill (lookahead end) thing; e <- end; return (list,e) }
12:02:08 <Figs_> Ahh, lookahead is what I need. Thanks.
12:02:39 <dafis> except it's actually lookAhead :)
12:03:42 <Figs_> anyWordUntil stop = manyTill anyToken (lookAhead $ choice $ map word stop)  -- This seems to do what I want
12:03:47 <djahandarie> There must be something I'm doing wrong here. When I'm using StateT it seems to make it incredibly hard to use any functions that dealt with the inner monad originally
12:04:02 <djahandarie> (Comapred to using ReaderT for example)
12:05:09 <sm> interesting.. things printed to console on windows seem much lazier about when they appear, ie hFlush stdout needed
12:06:35 <dafis> sm: There are some buffering quirks on windows
12:07:38 <davekong> Is there something like sscanf from C in Haskell?
12:08:24 * ddarius doesn't understand why one would want such a thing.
12:08:28 <dafis> davekong: what are you trying to do?
12:08:48 <davekong> dafis: parse a string that has multiple possible types in it
12:09:08 <davekong> and return an error if it is invalid
12:09:10 <dafis> davekong: if you want to parse, write a parser :)
12:10:19 <davekong> dafis: have a guide somewhere?
12:10:37 <dafis> davekong: parsec docs ?
12:10:46 <dafis> or attoparsec, ...
12:10:47 <Figs_> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
12:11:03 <Figs_> ^^ Parsec docs I'm using at the moment.
12:13:57 <davekong> Ok, looks good, thanks
12:15:22 <Figs_> Once you get over the initial head scratching, it's pretty easy to use.
12:15:47 <Figs_> http://snippets.dzone.com/posts/show/3660 <-- this was a fairly handy example
12:16:26 <Figs_> http://book.realworldhaskell.org/read/using-parsec.html <-- as was this
12:23:55 <ddarius> Some basic familiarity with parsing theory will go a long way to easing the use of Parsec (or any parsing library) for more complicated examples.
12:24:16 <davekong> links please :)
12:27:04 <ddarius> davekong: I just found this and it is no doubt far more comprehensive than necessary: http://www.cs.vu.nl/~dick/PTAPG.html
12:28:16 <Figs_> davekong: Do you have any example of what you're trying to parse?
12:30:46 <davekong> Color LetterNum where Color is any of a few different Color strings letter is most but not all of the alphabet no caring about case and num is a number in a certain range
12:32:49 <davekong> split it into two words and then wrote a function that returns Maybe Color and was going to do something similiar for second word but looking for something more elegant
12:36:17 <davekong> if more than two words are in the string they just get ignored
12:37:58 <sm> hledger linux/mac/win binaries are now available at http://hledger.org/download/ , any download or documentation test reports would be welcome
13:06:31 <davekong> when I install a new library on my system ghci should be able to see it right away?
13:06:41 <dafis> yes
13:07:30 <dafis> davekong: I guess you have installed a package and ghci can't see it?
13:08:42 <davekong> dafis: yeah
13:09:00 <dafis> davekong: what does ghc-pkg say?
13:09:17 <dafis> ghc-pkg list new-package
13:09:42 <monochrom> quit ghci and try again?
13:09:54 <davekong> dafis: /usr/lib/ghc-6.12.1/package.conf.d
13:10:00 <davekong> monochrom: I did
13:10:35 <dafis> davekong: so ghc-pkg does find it?
13:10:36 <monochrom> perhaps the new library is not installed
13:10:55 <monochrom> no, one single line "/usr/lib/ghc-6.12.1/package.conf.d" means package not found
13:11:25 <dafis> monochrom: I took it as "that's the location"
13:12:02 <monochrom> to see what should be expected when a package is found, "ghc-pkg list base" and compare
13:13:51 <davekong> monochrom, dafis: Ok I listed them all and found regex-base-0.93.1 which is what I installed
13:14:24 <dafis> davekong: but ghci doesn't find it?
13:15:05 <monochrom> at ghci prompt if ":m + Text.Regex.Base" changes the prompt, everything is normal
13:16:01 <davekong> monochrom: what about Text.Regex.Posix?
13:16:11 <davekong> ":m + Text.Regex.Base" worked
13:16:41 <dafis> dabekong: Text.Regex.Posix is in regex-posix
13:17:00 <dafis> da*v*ekong
13:18:36 <davekong> dafis: ahh I got... the package descriptions confused me, though base included posix etc
13:23:28 <Figs_> Woohoo. I can now parse swear words! :|
13:23:54 <djahandarie> Does this function exist somewhere already?  foo :: (Functor f) => (f a -> f b) -> a -> f b; foo f a = f $ pure a;
13:24:22 <c_wraith> pure isn't part of the Functor interface
13:24:31 <c_wraith> That needs Applicative
13:24:34 <djahandarie> Ah right
13:25:00 <c_wraith> and I don't think it's defined anywhere
13:25:01 <jake4> hello
13:25:01 <byorgey> but no, I don't think that exists somewhere already
13:25:06 <byorgey> hi jake4
13:25:09 <djahandarie> Okay, thanks
13:25:23 <jake4> i am creating a dock and using c#
13:25:36 <jake4> i am using visual studio
13:26:07 <jake4> and i need some help from someone please
13:27:11 <jake4>  can someone help me please i want to create a drag and drop feauture where i can drag any desktop icon onto my dockj and it adds it on the dock
13:27:40 <dafis> jake4: we're not C# experts here
13:27:47 <jake4> where can i find one
13:28:07 <dafis> isn't there a #csharp or so?
13:28:25 <jake4> i dont no
13:28:30 <Saizan> jake4: this channel is about the Haskell programming language specifically
13:29:11 <djahandarie> Yeah, check out #csharp , that's where all the C# programmers provide help
13:29:25 <jake4> where is that 
13:29:28 <dafis> jake4: indeed, there's #csharp on freenode
13:29:45 <byorgey> jake4: you should be able to join it in the same way that you joined this channel.
13:30:07 <djahandarie> jake4, I don't know how you're accessing this channel, but you can try using http://webchat.freenode.net/
13:30:21 <djahandarie> And then just type #csharp in the "Channels" box
13:31:39 <cheater99> jake4: go to efnet and /join #c c
13:31:44 <cheater99> they will help you with C#
13:34:54 <jedai> We must be one of the only channel where one can ask for help in another language and get some directions rather than insults... :/
13:35:18 <dafis> I wonder how they land here
13:35:45 <Saizan> my suspect is that we have "programming" in the topic
13:35:57 <djahandarie> dafis, I just mentioned in -blah, probably http://www.google.com/search?q=programming+chat
13:35:58 <jedai> Yes, this is quite puzzling, we get some real weird case from time to time
13:35:59 <monochrom> I gather that they are guided by some stupid internet search algorithm
13:36:02 <ozamosi|netbook> jedai: yeah. people in here should totally be more abusive.
13:36:44 <jedai> ozamosi|netbook: I don't think so, it's quite refreshing to see really given the usual culture on IRC PL channels
13:36:56 <ozamosi|netbook> ;)
13:37:01 <RyanT5000> do any of the haskell-based web server things support HTTPS?
13:39:15 <jedai> RyanT5000: Yes, happstack for one (probably others too) see http://huygens.functor.nl/blog/?p=21
13:39:27 <eevar> RyanT5000: just leave https to nginx, which you use in front of the haskell app
13:39:31 <eevar> as a reverse proxy
13:39:34 <RyanT5000> ah, ok
13:40:38 <jedai> It's not really up to the app server really, more to the front end
13:40:54 <RyanT5000> right
13:41:11 <RyanT5000> i suspected as much, but i've never actually done the integration
13:43:33 <prsteele> Can anyone tell me how to pattern match against Double and Integer? I know I need to match against the constructors of algebraic datatypes, but how do I for primitives?
13:44:09 <hpc> you don't match against constructors for double and integer
13:44:11 <opqdonut> f 0.0 1 = True
13:44:12 <burp> um that doesn't make sense
13:44:18 <opqdonut> you match against "literals"
13:44:25 <davekong> prsteele: you can use guards and isDigit
13:45:11 <prsteele> I need to differentiate between the different primitives, as well as other types
13:45:13 <ClaudiusMaximus> > let { f 0 = 3 ; f (n+1) = f n * f n } in f 5
13:45:14 <lambdabot>   1853020188851841
13:45:21 <prsteele> something like
13:45:35 <prsteele> f n@(i :+ j) = MyComplex n
13:45:44 <prsteele> f (<Double> d) = MyDouble d
13:45:50 <opqdonut> that doesn
13:45:51 <prsteele> f (<Integer> i) = MyInteger i
13:45:52 <jedai> Well you can consider that literal numbers are constructors for those types (except they're polymorphic and there is an infinity of them so ...)
13:45:53 <opqdonut> 't make sense
13:46:08 <opqdonut> prsteele: what would be the type of f?
13:46:21 <opqdonut> if you want to do that, you should make f part of a type class
13:46:22 <prsteele> (Num a) => a -> MyValues ?
13:46:30 <opqdonut> nuh-uh, you can
13:46:34 <opqdonut> 't know which a it is
13:46:47 <jedai> prsteele: you can't do that, not for a regular function (though you can use a type class to achieve something like that)
13:46:51 <opqdonut> (gah, my ' is too close to my return)
13:47:04 <prsteele> hm, okay
13:47:04 <prsteele> thanks
13:48:10 <jedai> prsteele: with this type (and for a regular function) your code must work for every instance of Num, the same code for all of them
13:48:18 <davekong> newtype MyComplex = Mycomplex {getComplex :: Complex}
13:49:33 <jedai> prsteele: you can write a type class with your function and write instance for every type you want to handle though, this way you can have specific code for every type
13:53:07 <prsteele> Thanks everyone, it worked
13:54:33 <aristid> :k Complex
13:54:34 <lambdabot> * -> *
13:54:46 <aristid> davekong: i'm not sure if that code would be valid
13:55:19 <dafis> aristid: it wouldn't
13:55:31 <davekong> > newtype MyComplex = Mycomplex {getComplex :: Complex}
13:55:32 <lambdabot>   <no location info>: parse error on input `newtype'
13:55:53 <aristid> not like lambdabot accepts any newtypes
13:56:10 <dafis> davekong: it would have to be ... {getComplex :: Complex Double}, e.g.
13:56:28 <aavogt> you need to explicitly pass a parameter in     newtype MyComplex a = MyComplex (Complex a)
14:03:45 <tolkad> Is there an efficient algorithm for calculating the floor of two rational numbers?
14:03:58 <tolkad> err of one rational number*
14:04:35 <djahandarie> Is there some decent way to do some function every x seconds (forked obivously) that doesn't involve forever and threadDelay?
14:05:17 <tolkad> oh nvm haskell seems to have `div`
14:05:36 <illissius> djahandarie: why shouldn't it?
14:06:30 <djahandarie> illissius, I don't know, it just seems ugly :)
14:07:05 <illissius> anyway, the answer to your question is "i don't know" :)
14:07:46 <aristid> :t floor
14:07:47 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:07:53 <aristid> tolkad: how about this one?
14:09:35 <Philonous> djahandarie: Sometimes explicit recursion is more practical (you get a poor mans continuation), but apart from that forever + threadDelay is perfectly fine. 
14:19:25 <hpc> @src floor
14:19:25 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:20:04 <ski> @src flour
14:20:05 <lambdabot> Source not found. That's something I cannot allow to happen.
14:20:12 <ski> @src Float floor
14:20:13 <lambdabot> Source not found. Wrong!  You cheating scum!
14:20:21 <kmc> djahandarie, why's it ugly?
14:20:22 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
14:20:58 <sm> holy cow, http://hackage.haskell.org/package/visual-prof sounds good
14:21:18 <pastorn> > foldl f z [x,y] :: Expr
14:21:19 <lambdabot>   f (f z x) y
14:21:28 * ski idly wonders what a poor man's continuation might be ..
14:21:34 <pastorn> > foldr f z [x,y] :: Expr
14:21:35 <lambdabot>   f x (f y z)
14:23:58 <djahandarie> kmc, mainly because of the GHC specific threadDelay
14:24:07 <monochrom> setjmp and longjmp is poor man's continuation
14:25:47 <ski> maybe <http://www.gnu.org/software/libtool/manual/libc/System-V-contexts.html> as well ?
14:26:20 <hpc> :t setjmp
14:26:21 <lambdabot> Not in scope: `setjmp'
14:28:45 <djahandarie> Data.Foldable.sequence_ should not care about passing the results of things around, right?
14:29:04 <hpc> it shouldn't, judging from the name
14:30:13 <aristid> > f <*> g :: Expr
14:30:13 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
14:30:14 <lambdabot>         against inferred ...
14:36:55 <djahandarie> forkIO should return the moment there is a new thread right?
14:38:24 <c_wraith> It returns as soon as the new thread id is created.
14:38:37 <c_wraith> which probably corresponds with it being added to ghc's run queue
14:38:54 <c_wraith> But forkIO usually will return before the new thread starts running.
14:40:08 <djahandarie> Because right now it is in a Control.Monad.sequence_ and it is blocking everything after it in the list
14:40:47 <c_wraith> forkIO shouldn't block, under normal circumstances.
14:43:26 <Philonous> It might seem like forkIO blocks when your new thread calles into the FFI and you haven't compiled with -threaded or the called function is marked (un-) safe (I can't remember which)
14:45:38 <iocor> can someone look at this parser I wrote in happy http://gist.github.com/480735 and tell me if there's a way I can remove the dpulication of the entire list of terminals that happens a couple of times?
14:45:58 <hpc> > f <$> g
14:45:59 <lambdabot>   No instance for (GHC.Show.Show (f b))
14:45:59 <lambdabot>    arising from a use of `M1381169926...
14:49:25 <Gertm> is there a 'flatten' function available?
14:49:42 <kmc> djahandarie, hmm, interesting point.  threadDelay isn't in the standard for concurrent haskell?
14:49:48 <Axman6> :t concat
14:49:48 <kmc> i'm not sure if there is a standard, really -- there's a paper anyway
14:49:49 <lambdabot> forall a. [[a]] -> [a]
14:49:54 <Axman6> Gertm: that?
14:49:57 <Tomsik> @src concat
14:49:57 <lambdabot> concat = foldr (++) []
14:50:03 <Gertm> Axman6: that'll do :) thanks!
14:50:05 <hpc> @src concat
14:50:05 <lambdabot> concat = foldr (++) []
14:50:28 <djahandarie> kmc, it says "GHC only" on the docs
14:50:28 <Tomsik> :t Mu []
14:50:29 <lambdabot> Not in scope: data constructor `Mu'
14:50:44 <djahandarie> While the other stuff in Control.Concurrent doesn't
14:50:50 <djahandarie> So I suppose taht means it's not in the paper
14:50:54 <djahandarie> that*
14:50:58 <prsteele> how would I convert a Float to a Double?
14:52:02 <hpc> :t fromFractional
14:52:03 <lambdabot> Not in scope: `fromFractional'
14:52:12 <hpc> :t fromRational
14:52:13 <lambdabot> forall a. (Fractional a) => Rational -> a
14:52:32 <cuba> anyone can tell me how i can fix this fucntion? http://pastebin.com/1eWMFwEX
14:52:49 <cuba> so that the results of (viell x:xs ys) will be added to the resulting list?
14:52:51 <ski> @type realToFrac
14:52:52 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
14:52:57 <ski> prsteele : ^
14:53:16 <ski> @src realToFrac
14:53:17 <lambdabot> realToFrac = fromRational . toRational
14:53:26 <opqdonut> cuba: use ++?
14:53:29 <opqdonut> :t (++)
14:53:30 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:53:33 <opqdonut> gah
14:53:40 <ski> @type (Prelude.++)
14:53:41 <lambdabot> forall a. [a] -> [a] -> [a]
14:53:43 <prsteele> thanks
14:53:43 <opqdonut> > [1,2,3] ++ [4,5,6]
14:53:44 <lambdabot>   [1,2,3,4,5,6]
14:53:50 <opqdonut> anyway, it catenates two lists
14:54:21 <opqdonut> so I guess you want to say "viell (x:xs) (y:ys) = foo y (x:xs) ++ viell (x:xs) ys where ..."
14:56:11 <cuba> opqdonut: you are right should be ++
15:30:17 <Peaker> no way a Debug.Trace.trace will print the trace twice for the same trace'd value, right?
15:30:59 <zygoloid> what do you mean by 'same'?
15:31:28 <zygoloid> in any case i think it still can, if two threads try to evaluate it at the same moment
15:31:36 <Peaker> I don't have threads
15:32:01 <kmc> Peaker, perhaps your definition got inlined
15:32:07 <zygoloid> in that case i /think/ the same heap object should only trace once
15:32:11 <kmc> let x = trace "foo" 1 in (x+2, x+3)
15:32:18 <Peaker> kmc, isn't trace pragma'd not-inline?
15:32:20 <kmc> could print once, could print twice if x is inlined
15:32:36 <kmc> Peaker, wouldn't your binding that uses trace have to be not-inline?
15:32:41 <kmc> or is it infectious like that
15:33:12 <zygoloid> ghc shouldn't do inlining which adds reevaluation iirc
15:33:25 <kmc> yeah
15:33:29 <Peaker> I'll allow IO in there and use a normal print to make sure
15:37:37 <ddarius> kmc: GHC does not treat trace specially in any way.
15:38:28 <ddarius> I'm also pretty confident that GHC gives no guarantees about not reevaluating something, though it is unlikely.
15:39:34 <dolio> let x = trace "foo" 1 in (x+1, x+2) has x used twice, so it seems unlikely that GHC would inline it without a pragma telling it to.
15:41:00 <Peaker> It wasn't trace being printed twice
15:41:05 <Peaker> but I still haven't found this bug..
15:41:15 <Peaker> weird, innocuous seeming change
15:41:24 <Peaker> Most of my bugs were found by the type system so far...
15:41:52 <kmc> what was the change?
15:43:19 <Peaker> Changing my db keys to be Guids rather than ByteStrings (thin wrapper) and removing MonadIO constraint and instead having a "newGuid" action in the store which is in the ReaderT of my monad transformer stack
15:43:32 <Peaker> But I've got quite a system around the db, and apparently some part of it is fragile :)
15:43:33 <FunctorSalad_> kmc: doesn't the NOINLINE on trace block inlining of trace itself even if his wrapper doesn't have the pragma?
15:43:43 <FunctorSalad_> missed what the binding to trace is
15:43:53 <dolio> It could inline to two calls to trace.
15:44:12 <dolio> let x = trace "foo" 1 in (x, x) ==> (trace "foo" 1, trace "foo" 1)
15:44:12 <kmc> FunctorSalad_, it would not inline trace, but it could inline a value which calls trace
15:45:33 <FunctorSalad_> I should keep a ghc source dir at arms length for such things
15:45:40 <FunctorSalad_> (finding def of trace)
15:45:52 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Debug-Trace.html
15:46:21 <FunctorSalad_> \x y -> unsafePerformIO (putErr x >> return y) -- guess
15:46:41 <FunctorSalad_> putErr = hPutStrLn stderr
15:47:08 <FunctorSalad_> (missing Prelude function?)
15:48:01 <FunctorSalad_> "debugBelch", heh
15:48:20 <FunctorSalad_> I use `orBarf`
15:48:35 <FunctorSalad_> (different sig ;))
15:49:20 <liufeng> join #emacs
15:54:53 <FunctorSalad_> "no manual entry for debugBelch" -- ghc c function?
15:55:12 <illissius> nah, it's a universal primitive
15:55:19 <FunctorSalad_> (I know it says HsBase.h, but also that it's just a wrapper)
16:00:07 <MarioZ> hello =)
16:01:52 <MarioZ> does anybody here know PHP programming?
16:02:01 <ezyang> Wrong channel. 
16:02:05 <eflister> is there a nice way to do:  (\x -> f x >> g x >> h x >> return x) ?  something in the spirit of last . sequence . ([f,g,h,return] <$>) ?
16:02:32 <FunctorSalad_> illissius: of what other system? curious
16:02:45 <Tomsik> :t >=>
16:02:46 <lambdabot> parse error on input `>=>'
16:02:47 <ezyang> (also, just ask your question) 
16:02:48 <Veinor> @pl \x -> f g >> g x >> h x >> return x
16:02:48 <lambdabot> ap ((>>) . ap ((>>) . (f g >>) . g) h) return
16:02:54 <Veinor> :/
16:02:56 <MarioZ> oh, thanks ezyang... do you know where i can find a PHP channel?
16:03:02 <FunctorSalad_> (can't find it even with man -Ka)
16:03:04 <ezyang> Veinor: You don't want the function monad :-) 
16:03:07 <ezyang> MarioZ: ##php 
16:03:08 <Tomsik> :t >>
16:03:09 <lambdabot> parse error on input `>>'
16:03:11 <Tomsik> what
16:03:16 <Tomsik> @type >=>
16:03:16 <lambdabot> parse error on input `>=>'
16:03:21 <FunctorSalad_> :t (>=>)
16:03:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
16:03:24 <Tomsik> ah
16:03:27 <illissius> FunctorSalad_: as in every language comes with a debugBelch function
16:03:32 <illissius> automatically
16:03:32 <MarioZ> thank you ezyang!
16:03:34 <illissius> even English!
16:03:40 <Veinor> @pl \x -> f g `q` g x `` h x `q` return x
16:03:40 <lambdabot> (line 1, column 19):
16:03:40 <lambdabot> unexpected "`"
16:03:40 <lambdabot> expecting variable, "(", letter, digit, "!!", ".", operator or end of input
16:03:46 <Veinor> @pl \x -> f g `q` g x `q` h x `q` return x
16:03:46 <lambdabot> ap (q . ap (q . (f g `q`) . g) h) return
16:03:47 <Tomsik> :t (>>>)
16:03:48 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:03:51 <Veinor> bah
16:03:55 <Tomsik> not this
16:04:03 <ezyang> is f, g, h arbitrarily many functions, or just three? 
16:04:03 <Veinor> also, I typoed
16:04:08 <ezyang> I think writing it out explicitly is fine... 
16:04:10 <Veinor> @pl \x -> f x >> g x >> h x >> return x
16:04:11 <lambdabot> ap ((>>) . ap ((>>) . liftM2 (>>) f g) h) return
16:04:14 <ezyang> (if it's just three) 
16:04:23 <eflister> ezyang: arbitrary
16:04:29 <FunctorSalad_> illissius: hmm I didn't think it was crazy enough to assume kidding ;) though the camelCase would be surprising for basic system things
16:04:33 <Veinor> but it seems like there's a simpler way to do it
16:05:01 <FunctorSalad_> (there might be some reason why the kernel would like to know what's just debugging output, after all...)
16:05:19 <FunctorSalad_> (conceivably, not actually)
16:05:21 <Veinor> :t  \x -> f x >> g x >> h x >> return x
16:05:22 <lambdabot> forall (m :: * -> *) a a1 a2 b. (Show b, SimpleReflect.FromExpr (m a), SimpleReflect.FromExpr (m a1), Monad m, SimpleReflect.FromExpr (m a2)) => b -> m b
16:05:31 <ezyang> lol. 
16:05:43 <illissius> not bad
16:06:39 <ezyang> I'm thinking maybe something like sequence_ (map ($ x) functions) >> return x 
16:06:52 <Veinor> that sounds reasonable
16:06:55 <Gracenotes> @pl \x -> mapM_ ($x) [f, g, h] >> return x  -- you're quick, ezyang 
16:06:55 <lambdabot> ap ((>>) . flip mapM_ [f, g, h] . flip id) return
16:07:09 <Gracenotes> typed.. too slow ;_;
16:07:26 <Veinor> but you win for combining sequence_ and map_ into mapM_ :D
16:07:33 <ezyang> Oh yeah, we can get rid of sequence 
16:07:42 <Veinor> er, sequence_ and map
16:07:48 <illissius> :t \f g h x -> last $ zipWithM (=<<) [f,g,h,return] x
16:07:49 <lambdabot> forall c. (c -> [c]) -> (c -> [c]) -> (c -> [c]) -> [[c]] -> [c]
16:08:02 <Gracenotes> @pl \x -> mapM_ ($x) [f, g, h]
16:08:02 <lambdabot> flip mapM_ [f, g, h] . flip id
16:08:45 <ksf> is there something like dotty but /usable/?
16:08:48 <Gracenotes> join . liftM2 (>>) (flip mapM_ [f, g, h] . flip id) return  -- meh
16:09:11 <ksf> that is, not failing to draw properly, much less utterly failing to draw once you move stuff?
16:09:25 <Veinor> :t join (f :: a -> b)
16:09:25 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
16:09:26 <lambdabot>       from the context ()
16:09:26 <lambdabot>       arising from a use of `f' at <interactive>:1:6
16:09:31 <Veinor> >:(
16:10:05 <eflister> ah i like illissius' version -- i don't want to special case the functions from return.  but i can't put them in a list together because they are a -> IO () and return is not :(
16:10:09 <Veinor> well, join will take (c -> c -> a -> b) and turn it into (c -> a -> b). so join f x = f x x
16:10:40 <illissius> my version isn't quite right i think but you could probs rightify it
16:10:45 <Veinor> hooray for type-level reasoning!
16:11:51 <illissius> actually you just need plain zipWith, not zipWithM
16:11:54 <ezyang> :t (join) 
16:11:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:12:36 <ezyang> join specialized on function/reader is a smidge more general then that signature. 
16:12:47 <illissius> ..though in that case i don't think the rest get executed
16:12:49 <illissius> :meh
16:12:53 <FunctorSalad_> ksf: graphviz gui? hehe, didn't take me long to just write a source file instead
16:13:05 <Gracenotes> ezyang: the problem is the second argument of liftM2
16:13:08 <FunctorSalad_> (wasn't dotty the one using some ancient X toolkit...)
16:13:09 <Gracenotes> the first one even
16:13:44 <kmc> :t let (>*>) f g x = f x >> g x in ?f >*> ?g >*> ?h >*> return
16:13:45 <lambdabot> forall t (m :: * -> *) a a1 a2. (Monad m, ?f::t -> m a, ?g::t -> m a1, ?h::t -> m a2) => t -> m t
16:13:45 <ezyang> hm. 
16:13:49 <FunctorSalad_> ksf: the input syntax for dot, on the other hand, is very straightforward (if you haven't tried)
16:14:10 <ksf> I'm just looking for a viewer
16:14:15 <Gracenotes> wat, this is functional programming, we can't define our own combinators here
16:14:16 <ksf> ...that lets me rearrange nodes
16:14:25 <ksf> I'm generating all the graphs, anyway.
16:15:06 <kmc> ksf, i have looked for that in vain
16:15:14 <kmc> ksf, i have written bad approximations to it
16:15:19 <FunctorSalad_> ksf: hmm... isn't there some feature to generate clickable areas for html output (don't know what exactly the thing I mean is called)
16:15:29 <FunctorSalad_> you'd have to take it from there
16:16:03 <FunctorSalad_> (I mean masks to be able to click on specific nodes, which may not be rectangular)
16:16:37 <ksf> hmmm http://www.graphviz.org/Resources.php
16:17:06 <ksf> though it'd of course be nice to have a full-fledged gui that you can script so it obeys constraints that make the graphs importable into your app, again...
16:17:10 <FunctorSalad_> (I mean, that may be useful if you need to do the same action to each node, and you just want a graphical way to pick the node)
16:18:15 <ksf> picking, dropping, possibly setting distance constraints.
16:18:40 <ksf> as graphviz can't possibly know which nodes e.g. in a dfa are _semantically_ near.
16:19:23 <FunctorSalad_> ksf: this is what I meant http://www.graphviz.org/doc/info/output.html#d:imap
16:19:43 <FunctorSalad_> (for completeness, not saying it's the right way)
16:20:31 <eflister> ah, i love kmc's version.  avoids my heterogeneous list problem.  how come people haven't run into the need for >*> before?
16:21:06 <Veinor> :t \f g x -> f x >> g x
16:21:07 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (t -> m b) -> t -> m b
16:21:10 <ezyang> I think passing around lists of functions is rarer than you think. 
16:21:20 <FunctorSalad_> @type liftA2 (>>)
16:21:20 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
16:21:36 <FunctorSalad_> that should be it for f = Reader t
16:21:40 <FunctorSalad_> @ eflister 
16:21:57 <FunctorSalad_> now we just need a shorter name for lift[AM]2
16:23:22 <ksf> ...gentoo has kgraphviewer
16:23:34 <noteventime> I'm writing a small haskell binding to an IO intensive library, centred around handles, similar to file handles. Currently I'm using an Either type for error handling. My question is if, in this case, using IO exceptions would be considered more idiomatic.
16:23:38 <eflister> FunctorSalad -- nice
16:24:11 <hpc> Either is probably better form
16:24:26 <Veinor> FunctorSalad_: l[AM]2
16:24:30 <Veinor> ;)
16:24:34 <ksf> noteventime, is it threadsafe?
16:24:44 <noteventime> I haven't got the slightest :)
16:24:51 <noteventime> StormLib
16:24:59 <ksf> if not, forget everything you're doing right now and write a concurrent object around it.
16:25:02 <noteventime> http://www.zezula.net/en/mpq/stormlib.html
16:25:08 <FunctorSalad_> ksf: graph viewing is just a hard task in general
16:25:28 <ksf> but writing a _displayer_ based on graphviz shouldn't be that hard.
16:25:40 <FunctorSalad_> yeah, just remembered that ;)
16:25:47 <ksf> ...I'm still waiting for a fully interactive 3d graph editor, though.
16:25:51 <FunctorSalad_> ksf: the xdot format might help?
16:26:02 <FunctorSalad_> it's an output format that looks like the input, but with all the layout info
16:26:48 <ksf> wtf it wants to upgrade kde, _again_.
16:26:51 <FunctorSalad_> you probably don't want to build a full-scale editor based on that ;) but maybe you can build some simple ad-hoc tool for whatever you are doing
16:26:57 <ksf> and wtf does it pull kdepimlibs?
16:27:01 <noteventime> hpc: What do you mean concurrent object?
16:27:08 <FunctorSalad_> ksf: kmail?
16:27:18 <hpc> noteventime: you mean ksf
16:27:22 <ksf> kgraphviewer.
16:27:25 <noteventime> Ohh, sorry :)
16:27:28 <FunctorSalad_> kdepim=kmail,kopete,kalendar,kontact,kaddressbook and some others
16:27:35 <FunctorSalad_> oh
16:27:37 <noteventime> ksf: What do _you_ mean concurrent object?
16:27:46 <FunctorSalad_> no idea :) though you were doing an upgrade while you're at it
16:27:50 <FunctorSalad_> *thought
16:28:12 <noteventime> hpc: Didn't realise you were two people (or, at least, two nicks)
16:28:26 <FunctorSalad_> Veinor: lM2 would be better already
16:28:45 <ksf> noteventime, a thread that does the IO calls, listening on a channel for messages to perform operations and outputting results via TVars or such that it got passed alongside the message.
16:28:47 <FunctorSalad_> just a bit ugly optically
16:28:47 <hpc> no problem; i get pinged from library names ;)
16:28:58 <ksf> basically, doing what OO is actually about.
16:29:05 <Veinor> why do we have liftM and fmap?
16:29:44 <illissius> because Monad m doesn't have Functor m =>
16:30:04 <noteventime> ksf: If I had any intention of seriously using or distributing the library I might have done that
16:30:36 <noteventime> Mostly I'm trying to learn C2HS
16:30:37 <Veinor> yeah... and there's no way to do instance (Foo t) => Bar t
16:30:41 <Veinor> without doing funky stuff
16:31:17 * FunctorSalad_ wonders how painful it would really be to make a breaking change that can mechanically resolved
16:31:30 <ksf> wtf don't the gentoo devs slot minor kde versions?
16:31:35 <illissius> hmm, if you're doing single writes only and don't need transactions or composability then is atomicallyWriteIORef as good as TVars?
16:31:47 <ksf> I don't want to recompile all my 4.3 stuff just to install a single 4.4 one.
16:31:50 <FunctorSalad_> if the auto-source-converter is perfect, you'd just need to get everyone to run it on their package
16:32:13 <FunctorSalad_> ('perfect' as in always preserves semantics)
16:33:21 <ksf> http://zvtm.sourceforge.net/zgrviewer/applet/
16:33:26 <ksf> well that looks nice for starters.
16:35:02 <FunctorSalad_> (for the previous one, you'd just replace all liftM's with fmap, and autogenerate a Functor instance for the few functors that aren't monads. Though that'd be imperfect because orphan functor instances will break after you've autogenerated a non-orphan one from a monad instance)
16:35:33 <FunctorSalad_> the replacing would have to be done by something that understands semantics on the name resolution level
16:35:41 <FunctorSalad_> (which we already have, ghc ;))
16:38:48 <nominolo> illissius: if you can use it you really should use atomicallyWriteIORef
16:39:03 <nominolo> illissius: it's implemented as a simple CAS + spin loop
16:39:37 <nominolo> illissius: so except in cases of extremely high contention, it works very well
16:40:29 <nominolo> illissius: er, i assume you meant atomicallyModifyIORef
16:41:11 <etpace> Has anyone tried progression? when trying to compare benchmarks with valid .csvs, it generates an empty plot.csv and I get a normalize: base not found
16:41:11 <illissius> yeah
16:41:44 <FunctorSalad_> for which modules exactly will ghci :ctags make tags?
16:41:51 <ksf> don't graph layout algorithms use kernel methods, anyway? in that case it should be fucking trivial to switch from 2d to 3d and back.
16:42:59 <FunctorSalad_> (:load'ed one? its same-source-tree imports? or the whole tree?)
16:43:44 <FunctorSalad_> ksf: don't know about the question, but there is a 'dimension' parameter indeed
16:43:47 <FunctorSalad_> (for the output)
16:44:07 <FunctorSalad_> but it's not used graphically, just as a tag with the output iirc
16:44:33 <FunctorSalad_> http://www.graphviz.org/doc/info/attrs.html#d:dim
16:45:16 <FunctorSalad_> ksf: but it's "spdf, pdf, neato only"
16:45:25 <FunctorSalad_> (not dot)
16:45:26 <ksf> hmmm kernel methods don't have maximum dimensions afaiu
16:46:05 <ksf> FunctorSalad_, what about writing you thesis about 2d/3d graph layouting?
16:46:14 <FunctorSalad_> maybe it's an "nobody will need any more anyway, and this way we can just use a fixed array"? ;)
16:46:22 <ksf> heck you can do 4d via portals...
16:46:55 <ksf> the trick with kernel methods is that you don't actually do anything in the higher dimensions, computationally. it's just the maths.
16:46:56 <FunctorSalad_> hmm you think that'd work for (applied) math?
16:47:41 <ksf> FunctorSalad_, does that http://en.wikipedia.org/wiki/Support_vector_machine  look like math to you?
16:48:04 <ksf> "More formally, a support vector machine constructs a hyperplane  or set of hyperplanes in a high or infinite dimensional space, which can be used for classification, regression or other tasks."
16:48:37 <FunctorSalad_> yeah, but not everything that uses math *is* a math thesis topic ;)
16:49:17 * ksf thinks one can beef up virtually any cs topic to be an applied math thesis.
16:49:37 <Saizan> rephrase it as a constructive proof of something :)
16:49:39 <ksf> basically, all you need is an excuse to do proofs, isn't it?
16:50:35 <FunctorSalad_> ksf: more like 'must be a current topic of research, or at least something that the prof is researching and to which this is related' ;)
16:51:00 <FunctorSalad_> it's not a math thesis if the math in it is basic knowledge
16:51:05 <ksf> reminds me of the graph example we were shown in primary school, which ended up not being drawable in 2d without overlapping edges
16:51:46 <ksf> dunno if there's general, rigourous proofs for any dimension for that.
16:52:03 <ksf> what's the prof working on?
16:52:20 <FunctorSalad_> #blah I guess
16:56:47 <Peaker> Where can I find a newtype around (Monad m => m ()) that is a Monoid?
16:58:25 <Peaker> wrote one :P
17:02:30 <adnap> How do I write a function [a] -> [b], where each element of [b] is computed using 3 successive elements of [a], so that if [a] has n elements, [b] has n-2?
17:02:54 <ketralnis> Recursion with pattern-matching
17:03:26 <ketralnis> myfun (a:b:c:xs) = myfun b:c:xs...
17:03:27 <adnap> For example, if the operation is (+), [1,2,3,4,5] might generate [6,9,12]
17:04:32 <adnap> Oh, wait... I mistyped.
17:04:43 <adnap> It shouldn't be a function [a] -> [b].
17:04:57 <adnap> Let me try to re-explain.
17:06:06 <applicative> adnap if it was two elements you would zip the list with its tail plus the operation.  
17:06:10 <applicative> :t zip3
17:06:11 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
17:06:11 <adnap> There exists a function a -> [b].  I want to write a function a -> [c], which invokes a function [b] -> [c] in the manner previously specified, so if [b] has n elements, [c] has n-2.
17:07:36 <adnap> applicative: Okay, I look at that for a sec.
17:07:41 <applicative> > let maketrio x = zip3 x (tail x) (tail (tail x)) in maketrio "hello earthlings, we are here to destroy you."
17:07:42 <lambdabot>   [('h','e','l'),('e','l','l'),('l','l','o'),('l','o',' '),('o',' ','e'),(' '...
17:08:36 <adnap> applicative: Yes, that's what I'm looking for.
17:08:50 <applicative> is there a zipWith3?
17:08:57 <adnap> applicative: I think so.
17:08:58 <applicative> @type zipWith3
17:08:59 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
17:09:14 <adnap> http://www.haskell.org/hoogle/?hoogle=zipwith3
17:09:18 <applicative> so you just need a convenient way to form the tails.
17:10:12 <applicative> I remember a swank bit of lambabot wit, zip `ap` tail, which forms the pairs you would want.
17:10:17 <adnap> > zipWith3 (+) [1,2,3,4,5] [2,3,4,5] [3,4,5]
17:10:18 <lambdabot>   [3,5,7]
17:10:38 <applicative> >  zip `ap` tail $ "abcdefghijklmnop"
17:10:39 <lambdabot>   [('a','b'),('b','c'),('c','d'),('d','e'),('e','f'),('f','g'),('g','h'),('h'...
17:11:05 <applicative> @quote zip
17:11:05 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
17:11:14 <applicative> hah, there it is
17:11:32 <Tomsik> :t ap
17:11:32 <adnap> applicative: I've never heard of ap.
17:11:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:12:01 <aristid> :t zip <*> tail
17:12:01 <lambdabot> forall b. [b] -> [(b, b)]
17:12:02 <adnap> Monads...
17:12:17 <applicative> @type zip3 `ap` tail `ap` (tail.tail)
17:12:18 <lambdabot> forall c. [c] -> [(c, c, c)]
17:13:40 <noteventime> Fancy :)
17:13:44 <aristid> :t (<$> id)
17:13:45 <lambdabot> forall a b. (a -> b) -> a -> b
17:13:46 <applicative> [(+1),(*8)] 'ap' [1,2,3] 
17:14:01 <adnap> I don't understand what you're doing anymore. XD
17:14:24 <applicative> > [(+1),(*8)] `ap` [1,2,3]
17:14:26 <noteventime> adnap: Check out the Applicative instance of functions :)
17:14:26 <lambdabot>   [2,3,4,8,16,24]
17:14:56 <aristid> or the Monad instance as long as applicative uses ap instead of <*>
17:15:03 <applicative> [(+),(*),(^)] `ap` [1,2,3] `ap` [4,5, 6]
17:15:16 <adnap> noteventime: This: http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
17:15:17 <illissius> should come up with something using both function and list instances, just to be extra confusing...
17:15:25 <listofoptions> well that makes set ordering easer i guess
17:15:26 <noteventime> adnap: Yes
17:15:27 <applicative> > [(+),(*),(^)] `ap` [1,2,3]  `ap` [4,5, 6] 
17:15:28 <lambdabot>   [5,6,7,6,7,8,7,8,9,4,5,6,8,10,12,12,15,18,1,1,1,16,32,64,81,243,729]
17:16:27 <aristid> > fix $ ([1,1]++) . (zipWith (+) <*> tail)
17:16:28 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:16:34 <applicative> adnap, it is a pleasant topic, <*> , aka <$>, but I just mentioned it as a typically witty #haskell approach
17:16:45 <Tomsik> > let fib = 1:1:zipWith (+) `ap` tail $ fib
17:16:46 <lambdabot>   not an expression: `let fib = 1:1:zipWith (+) `ap` tail $ fib'
17:16:54 <aristid> applicative: do you think my version of the fib sequence is readable?
17:16:58 <applicative> to your sort of problem.  zipWith3 with tails and tails.tails is the way
17:17:27 <rgrinberg> does haskell have a goto statement?
17:17:47 <noteventime> rgrinberg: You may want to read about continuations :)
17:17:48 <Tomsik> > let fib = 1:1:(zipWith (+) `ap` tail $ fib)
17:17:49 <lambdabot>   not an expression: `let fib = 1:1:(zipWith (+) `ap` tail $ fib)'
17:17:55 <Tomsik> why is this so
17:18:09 <Tomsik> > let fib = 1:1:(zipWith (+) `ap` $ tail fib)
17:18:10 <lambdabot>   <no location info>: parse error on input `$'
17:18:13 <hpc> > let fib = 1:1:(zipWith (+) `ap` tail $ fib) in fib
17:18:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:18:19 <Tomsik> whoops
17:18:56 <Tomsik> not being in the interpreter monad I see :p
17:19:00 <aristid> @pl let fib = 1:1:(zipWith (+) `ap` tail $ fib) in fib
17:19:00 <lambdabot> fix ((1 :) . (1 :) . (zipWith (+) `ap` tail))
17:19:08 <adnap> > let x = [1,2,3,4,5] in zipWith3 (+) x (tail x) ((tail . tail) x)
17:19:09 <lambdabot>   [3,5,7]
17:19:25 <Tomsik> what's pl?
17:19:36 <noteventime> Tomsik: Point-less
17:19:39 <noteventime> I think
17:19:47 <aristid> points are named function parameters
17:19:53 <applicative> aristid, oh the fix one.  i would say its awesome, but readable I don't know. It's funny, its both hard and a very apt representation of the main idea.  (I was thinking.)
17:20:15 <adnap> > let x = [1,2,3,4,5] in zip3 x (tail x) ((tail . tail) x)
17:20:16 <lambdabot>   [(1,2,3),(2,3,4),(3,4,5)]
17:20:19 <aristid> applicative: the zipWith (+) <*> tail feels sooo wrong to me
17:20:36 <aristid> i did make it up tho
17:21:08 <adnap> > let x = [1,2,3,4,5] in zipWith3 (\a b c -> a + b + c) x (tail x) ((tail . tail) x)
17:21:09 <lambdabot>   [6,9,12]
17:21:38 <aristid> > fix $ ([1,1]++) . liftA2 (zipWith (+)) id tail
17:21:39 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:22:31 <Veinor> > fix (\x -> 1: map (*2) x)
17:22:32 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
17:22:48 <Veinor> > fix $ 1 : map (*2)
17:22:48 <lambdabot>   Couldn't match expected type `[t]'
17:22:48 <lambdabot>         against inferred type `[a] -> [a]'
17:22:56 <Veinor> > fix $ (1 :) . map (*2)
17:22:57 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
17:24:54 <Tomsik> that's getting sick :p
17:25:59 <Veinor> > fix $ (1:) . map ((1+) . (1/)))
17:25:59 <lambdabot>   <no location info>: parse error on input `)'
17:26:03 <Veinor> > fix $ (1:) . map ((1+) . (1/))
17:26:04 <lambdabot>   [1.0,2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.619047619047...
17:28:01 <Tomsik> > zipWith (+) [1/(2*n+1) | n <- [1..]]
17:28:02 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
17:28:02 <lambdabot>    arising from a use ...
17:28:16 <Tomsik> what
17:28:22 <aristid> > (fix $ (1:) . map ((1+) . (1/))) !! 1000
17:28:23 <lambdabot>   1.618033988749895
17:28:25 <applicative> aristid, is it a common device to form an infinite list with 'fix'?   I think I had only thought of trivial cases like fix (:1)
17:28:27 <aristid> > (fix $ (1:) . map ((1+) . (1/))) !! 1001
17:28:28 <lambdabot>   1.618033988749895
17:28:54 <applicative> well, you seem to have mastered it in any case!
17:29:00 <Tomsik> > zipWith (+) [1/(2*n+1) | n <- [1.0..]]
17:29:00 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
17:29:01 <lambdabot>    arising from a use ...
17:29:15 <aristid> applicative: i don't know, i was basically using fibs = 1 : 1 : zipWith (+) fibs (tail fibs) as a starting point, and i was slightly annoyed that there were two fibs on the right hand side
17:29:54 <Tomsik> oh rite
17:30:07 <Tomsik> I'm sleep depraved apparently 
17:30:16 <aristid> applicative: and when you can write a list as a = f a, then why not write fix f?
17:30:31 <Gracenotes> why isn't there a unionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c? :(
17:31:08 <applicative> aristid, no reason, it's obvious, I just hadn't made the connections.
17:32:19 <Gracenotes> applicative: I'm actually using fix a lot nowadays, as I have record fields that reference other record fields. it's not cyclic, but it's still convenient
17:32:38 <aristid> @src scanl
17:32:38 <lambdabot> scanl f q ls = q : case ls of
17:32:39 <lambdabot>     []   -> []
17:32:39 <lambdabot>     x:xs -> scanl f (f q x) xs
17:32:40 <Gracenotes> now, where is this unionWith :(
17:33:10 <Saizan> Gracenotes: in your dreams.
17:33:20 <Gracenotes> nooooooo
17:33:40 <Saizan> do you have (a -> c), (b -> c) ?
17:33:52 <Gracenotes> no.
17:34:15 <Gracenotes> er hm, lemme see
17:34:19 <Saizan> then you couldn't pull it off
17:34:33 <Gracenotes> I might. I need to look at the available functions
17:34:39 <Saizan> if some key appears only in one you can't use (a -> b -> c)
17:35:08 <Gracenotes> true enough. well, I can pass it at an a and a b to act as 'default' parameters, that should be enough
17:35:12 <aristid> > fix $ scanl (+) 1 . (0 :)
17:35:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:35:19 <Saizan> ah, true
17:35:21 <Cale> Gracenotes: are you sure you're not thinking of intersectionWith?
17:35:23 <nominolo> Gracenotes: use fromAscList, toList and list comprehensions  -- should be pretty efficient
17:35:28 <applicative> Saizan is here.  I had dreams last night, why the devil lambdabot reads (sqrt $ sum) as it does.... it was making me crazy
17:35:32 <Cale> Gracenotes: unionWith wouldn't make sense at that type
17:35:46 <aristid> :t sqrt
17:35:47 <lambdabot> forall a. (Floating a) => a -> a
17:35:50 <aristid> :t sqrt $ sum
17:35:51 <lambdabot> forall a. (Floating a) => [a] -> a
17:35:55 <Gracenotes> Cale: well, the modified version :: Ord k => (a -> b -> c) -> a -> b -> Map k a -> Map k b -> Map k c? :(
17:35:57 <Saizan> applicative: there's an instance Num a => Num (b -> a) where
17:35:58 <aristid> :t ($)
17:35:58 <lambdabot> forall a b. (a -> b) -> a -> b
17:36:00 <Gracenotes> which granted is a bit specific
17:36:07 <aristid> :t sum
17:36:08 <lambdabot> forall a. (Num a) => [a] -> a
17:36:14 <aristid> :t sqrt sum
17:36:15 <lambdabot> forall a. (Floating a) => [a] -> a
17:36:21 <Veinor> ... what
17:36:48 <Veinor> :t sqrt product
17:36:49 <lambdabot> forall a. (Floating a) => [a] -> a
17:36:53 <Cale> Gracenotes: That's possible to obtain using the existing stuff, anyway.
17:36:53 <applicative> Saizan, I see. Somehow I decided it wasn't a lambdabot trick. I was stupid enough not to check ghci til the morning. It said what I expected.
17:36:56 <Veinor> > sqrt product [1,2,3]
17:36:57 <lambdabot>   2.449489742783178
17:37:09 <Veinor> how is this even typechecking?
17:37:15 <aristid> > sqrt sum [1,1]
17:37:16 <lambdabot>   1.4142135623730951
17:37:20 <Veinor> EVERYTHING I KNOW IS A LIE
17:37:23 <hpc> Num b => (a -> b) is an instance of Num
17:37:25 <Cale> hehe
17:37:27 <hpc> in lambdabot
17:37:39 <Veinor> hpc: ... why?
17:37:43 <applicative> Veinor, that's the foolish claim I was making to a new learner... then Saizan took me down, not that it's usually necessary...
17:37:46 <hpc> to complicate things
17:37:48 <Saizan> that sqrt acts like (sqrt .)
17:37:56 <Cale> Veinor: It's just the usual lifting instance for functions
17:38:02 <Veinor> > sqrt + sqrt
17:38:03 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:38:03 <lambdabot>    arising from a use of `...
17:38:03 <Gracenotes> Cale: well, such a method would be most convenient in terms of having a least words of code. I wonder if there's a better way to go about it though
17:38:03 <Cale> Like people use in mathematics all the time
17:38:04 <aristid> is there some class that can not have an instance for (e ->) oO
17:38:07 <Veinor> > (sqrt + sqrt) 8
17:38:08 <lambdabot>   5.656854249492381
17:38:14 <Veinor> > sqrt 8
17:38:15 <lambdabot>   2.8284271247461903
17:38:18 <Veinor> that's horrible and yet awesome
17:38:22 <Cale> > (sin^2 + cos^2) 1
17:38:22 <Gracenotes> given that combining function is entirely different, depending on the result of the second map
17:38:23 <lambdabot>   1.0
17:38:44 <Tomsik> what's the ->r instance of monad, continuations?
17:38:56 <Cale> Tomsik: You mean (->) r?
17:39:01 <Cale> Or (r ->)
17:39:02 <Tomsik> yeah
17:39:06 <Tomsik> (->)r
17:39:06 <aristid> Tomsik: (->) r or (r->) is the Reader
17:39:13 <aristid> just without the newtype
17:39:14 <Cale> It's exactly like reader, yeah
17:39:20 <applicative> Cale, but they don't respect sensible type conventions, they figure you'll understand... life f 1 = 4 ... f 2 = 8 ... but then f {1,2} = {4, 8]
17:39:32 <applicative> mathematicians I mean.
17:39:39 <Cale> > (do x <- id; y <- map toUpper; z <- reverse; return (x,y,z)) "hello"
17:39:40 <lambdabot>   ("hello","HELLO","olleh")
17:39:49 <Cale> ^^ that should give you the idea :)
17:40:09 <aristid> with ask = id
17:40:17 <Cale> applicative: Well, in this case, we just put a ring structure on functions
17:40:18 <aristid> @src (->) local
17:40:18 <lambdabot> local f m = m . f
17:40:22 <Tomsik> > (3* + 7*) 15
17:40:23 <lambdabot>   <no location info>: parse error on input `+'
17:40:32 <Tomsik> > ((3*) + (7*)) 15
17:40:33 <lambdabot>   150
17:40:35 <Tomsik> really
17:40:48 <Tomsik> that's just another way to write obfuscated code I guess
17:40:48 <aristid> > sqrt sqrt sqrt
17:40:49 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:40:49 <lambdabot>    arising from a use of `...
17:40:53 <aristid> :t sqrt sqrt sqrt
17:40:54 <lambdabot> forall a. (Floating a) => a -> a
17:41:02 <aristid> :t sqrt $ sqrt sqrt
17:41:03 <lambdabot> forall a. (Floating a) => a -> a
17:41:08 <Tomsik> sqrt sqrt 16
17:41:10 <Gracenotes> > runReader (do x <- ask; y <- asks (map toUpper); z <- asks reverse; return (x, y, z)) "hello"
17:41:10 <lambdabot>   ("hello","HELLO","olleh")
17:41:13 <Tomsik> > sqrt sqrt 16
17:41:14 <lambdabot>   2.0
17:41:19 <aristid> > sqrt sqrt sqrt 16
17:41:20 <lambdabot>   1.4142135623730951
17:41:23 <Cale> It's possible to use it to write obfuscated code, but it's not necessarily obfuscated.
17:41:26 <Gracenotes> it's madness in here :|
17:41:47 <aristid> THIS IS SPARTA
17:42:00 <Gracenotes> better late than never?
17:42:02 * hackagebot HaTeX 1.0.0 - Library for generate LaTeX code.  http://hackage.haskell.org/package/HaTeX-1.0.0 (DanielDiaz)
17:42:13 <Cale> It's actually pretty easy to see how you can treat functions whose codomain is a numeric type as being numeric themselves
17:42:19 <applicative> whao new LaTeX package.  ...
17:42:24 <Cale> > ((+) + (*)) 5 6
17:42:25 <lambdabot>   41
17:42:32 <noteventime> @type iterate ($ sqrt) sqrt
17:42:33 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a -> a) -> b
17:42:33 <lambdabot>     Probable cause: `$' is applied to too many arguments
17:42:34 <lambdabot>     In the first argument of `iterate', namely `($ sqrt)'
17:42:52 <Tomsik> > fix sqrt
17:42:53 <Cale> and of course, if functions of one parameter are numeric, then so are those with two :)
17:42:56 <lambdabot>   mueval-core: Time limit exceeded
17:43:22 <Tomsik> > ((+) + (+)) 3 4
17:43:23 <lambdabot>   14
17:43:25 <Tomsik> hahahahhah
17:43:28 <Tomsik> HAHAHAHA
17:43:30 <noteventime> Ahh, right, that makes sense, it's just me being tired :)
17:43:57 <Tomsik> I herd you liek plus so I added a plus to a plus so you can sum while you sum
17:43:59 <Cale> > (3 + 4) + (3 + 4)
17:44:00 <lambdabot>   14
17:44:46 <Veinor> @unpl ((*) (*) (+)) + ((-) (/) (*))
17:44:46 <lambdabot> (((*) * (+)) + ((/) - (*)))
17:44:51 <aristid> :t ((+) + (+))
17:44:52 <lambdabot> forall a. (Num a) => a -> a -> a
17:44:54 <Veinor> > ((*) (*) (+)) + ((-) (/) (*)) 7 8
17:44:55 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
17:44:55 <lambdabot>    arising from a use...
17:44:56 <noteventime> I put a functor in your functor :)
17:45:01 <Veinor> :t ((*) (*) (+)) + ((-) (/) (*))
17:45:02 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:45:12 <Veinor> >  ((*) (*) (+)) + ((-) (/) (*)) $ 7 8
17:45:13 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:45:13 <lambdabot>    arising from a use of `...
17:45:18 <Veinor> :t ((*) (*) (+)) + ((-) (/) (*)) $ 7 8
17:45:19 <lambdabot> forall a. (Fractional a) => a -> a
17:45:19 <aristid> :t (id + id)
17:45:20 <lambdabot> forall a. (Num a) => a -> a
17:45:21 <applicative> noteventime, how is that line going to continue...
17:45:26 <aristid> > (id + id) 1
17:45:27 <lambdabot>   2
17:45:29 <Veinor> :t ((*) (*) (+)) + ((-) (/) (*)) $ 7 $ 8
17:45:29 <lambdabot> forall b. (Fractional b) => b -> b
17:45:35 <Veinor> :t ((*) (*) (+)) + ((-) (/) (*)) $ 7 $ 8 $ 9
17:45:35 <lambdabot> forall b. (Fractional b) => b -> b
17:45:39 <Veinor> ...
17:45:54 <Veinor> :t ((*) (*) (+)) + ((-) (/) (*)) $ 7 $ 8.0
17:45:54 <lambdabot> forall b. (Fractional b) => b -> b
17:45:59 <Veinor> infinite type!
17:46:01 <noteventime> applicative: So you can naturally transform while you naturally transform?
17:46:07 <applicative> ... and you gave me an adjunction. .... And thus a monad....? that would be weak
17:46:14 <Veinor> :t ((*) (*) (+)) + ((-) (/) (*)) $ 7 $ (8 :: Integer)
17:46:15 <lambdabot> forall b. (Fractional b) => b -> b
17:46:19 <applicative> noteventime, okay
17:46:22 <Veinor> :t ((*) (*) (+)) + ((-) (/) (*)) $ (7 :: Int) $ (8 :: Integer)
17:46:23 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Int'
17:46:23 <lambdabot>     In the first argument of `($)', namely `(7 :: Int)'
17:46:23 <lambdabot>     In the second argument of `($)', namely
17:46:43 <aristid> @src (->) (+)
17:46:43 <lambdabot> Source not found. Where did you learn to type?
17:47:02 <Cale> aristid: (f + g) x = f x + g x
17:47:16 <aristid> does this hold for all binary ops?
17:47:27 <Cale> yeah, for (*) as well
17:47:34 <noteventime> aristid: All the Num ones
17:47:36 <aristid> :t \(+) -> (f + g) x = f x + g x
17:47:37 <lambdabot> parse error on input `='
17:47:37 <Cale> and the rest :)
17:47:45 <Gracenotes> you can define them in terms of lifting functions
17:47:50 <aristid> :t \(+) f g x -> f x + g x
17:47:50 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
17:48:08 <Gracenotes> applicative or monadic
17:48:14 <Cale> > (sin + cos) (pi/2)
17:48:14 <lambdabot>   1.0
17:48:24 <Cale> > (sin + cos) (pi/4)
17:48:25 <lambdabot>   1.414213562373095
17:48:42 <Tomsik> > ((+) * (+)) 3 4
17:48:43 <lambdabot>   49
17:48:49 <applicative> what's the most economical way of writing (sin + cos) (pi/2) in sensible haskell
17:48:54 <aristid> so unary functions are done with fmap/liftA/liftM, and binary with liftA2
17:48:58 <Veinor> @pl \x -> sin x + cos x
17:48:58 <lambdabot> liftM2 (+) sin cos
17:49:07 <Cale> applicative: sin (pi/2) + cos (pi/2)
17:49:08 <aristid> > (sin + cos) (pi/2)
17:49:09 <lambdabot>   1.0
17:49:13 <Veinor> but seriously what Cale said
17:49:15 <nus> > (1 2 3 4 5) id
17:49:16 <lambdabot>   1
17:49:16 <Tomsik> > (sin*cos) (pi/4)
17:49:17 <lambdabot>   0.5
17:49:20 <Tomsik> hahahahaha
17:49:21 <Cale> Or  liftM2 (+) sin cos (pi/2)
17:49:24 <Cale> sure
17:49:55 <aristid> or ((+) <$> sin <*> cos) (pi/2)
17:49:57 <aristid> so many options
17:50:02 <Tomsik> > (2*sin*cos) (pi/4)
17:50:03 <lambdabot>   1.0
17:50:07 <Tomsik> > (2*sin*cos) (pi/2)
17:50:08 <lambdabot>   1.2246467991473532e-16
17:50:17 <Tomsik> whoops, floating point errors
17:50:26 <applicative> hah, i think i was trying a more general question ineptly.  liftM2 is good.   or idiom brackets (|sin + cos |) (pi/2) 
17:50:28 <Cale> > ((sin * cos)^2) (pi/4)
17:50:28 <lambdabot>   0.25
17:50:37 <Cale> > ((sin + cos)^2) (pi/4)
17:50:38 <lambdabot>   1.9999999999999996
17:50:46 <aristid> applicative: idiom brackets?
17:51:27 <aristid> hmm.
17:51:41 <applicative> aristid, they're mentioned in the "Applicative Programming with Effects" paper, and implemented a few ways, with quasiquotes (which I don't get yet) and with the "she" preprocessor
17:51:58 <aristid> instance (Applicative f, Num a) => Num (f a)
17:52:40 <applicative> instead of op <$> x <*> y you write (| x op y |) , for example
17:53:06 <aristid> applicative: oh that would be relatively neat
17:53:29 <aristid> MOAR infixness
17:54:39 <noteventime> Oh joy, badly documented, ugly C libraries pretending they are C++. T_T
17:55:32 <illissius> heh
17:55:48 <illissius> a lot of people here don't like C++
17:56:03 <illissius> i'm not sure how many of those people have seen what glib/gtk programming in straight C looks like
17:56:08 <noteventime> C++ is rather annoying, but I don't dislike C++ as much as I dislike C++ programmers :)
17:56:34 <aristid> illissius: you get the flamebait points :P
17:56:40 <noteventime> At the moment anyway
17:57:09 <applicative> aristid, here Conor McB blogs about it http://personal.cis.strath.ac.uk/~conor/pub/she/idiom.html
17:57:24 <noteventime> But after trying to figure out what error codes belong to what functions and are used when probably isn't the best time to ask me.
17:58:44 <aristid> applicative: too bad it needs a preprocessor
17:59:09 <aristid> applicative: how do the quasiquotes look like?
17:59:27 <illissius> [somefunc| ...code.. |]
17:59:55 <illissius> basically afaik it just treats ...code... as a string, and somefunc parses and generates a TH AST which gets spliced in
18:00:05 <illissius> *parses it
18:00:18 <aristid> illissius: uh i mean in the specific case that applicative mentioned
18:00:36 <Cale> illissius: I basically just won't put up with programming in any language which doesn't have proper support for functions anymore. It's been about 40 years now that we've known how to support functions properly in programming languages and understood the benefits to organising code. There's no excuse.
18:00:51 <Saizan> it could look like [$idiom| x + y |]
18:01:38 <illissius> or even just [i| x + y|], if you're willing to impose "don't name your things i" on your users (which probs isn't realistic)
18:01:53 <Saizan> you need the $ though
18:01:56 <Cale> I really dislike the spurious $'s in TH syntax.
18:02:23 <Cale> They look quite ugly, even if they do make it obvious where code is being spliced in.
18:02:52 <aristid> Cale: that's because you're an academic elitist who doesn't understand the needs of REAL PEOPLE! :>
18:03:18 <nus> > ((1):: (Num a) => (a -> a)) 2
18:03:18 <lambdabot>   1
18:03:24 <applicative> avogt, havent tried them here's text  http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.6/doc/html/src/Language-Haskell-Meta-QQ-Idiom.html
18:03:25 <Cale> aristid: About the TH thing or the remark about functions?
18:03:26 <Saizan> for quasiquotes you could just drop it, but for splices you need some other syntax
18:03:27 <illissius> I actually dislike the ''Name syntax more than the $s
18:03:28 <aristid> illissius: so the she syntax is best
18:03:34 <aristid> Cale: the remark about functions
18:03:59 <aristid> Cale: i recently remarked somewhere that recursion is not very abstract... people found that funny
18:04:43 <Cale> People also associate recursion way too strongly with functional programming. Recursion isn't really how we want to write programs in FP.
18:04:44 <applicative> the example doesn't do infix -- ghci> [$i| (,) "foo" "bar" |]
18:04:44 <applicative> -- [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o','a'),('o','r')]
18:05:02 <Cale> It really is too low-level.
18:05:05 <Cale> ;)
18:05:16 <aristid> Cale: that's what i wanted to say :)
18:05:35 <Cale> We of course want to express things in terms of higher-order functions on various sorts of collections (primarily lists)
18:05:59 <applicative> aristid, it really is ugly.   so i guess cales case would be [$i| (+) sin cos] -- yick
18:06:15 <aristid> applicative: doesn't buy much over liftA2
18:06:45 <Cale> I included the NumInstances because it came with vector-space, and is sort of required to make the vector-space library usable.
18:06:53 <applicative> no.   or over McBrides previous wild version, I forgot about it....
18:07:36 <Cale> (because of the funny instance of VectorSpace for functions which really treats them as a module over themselves)
18:08:40 <Cale> So if you want the usual scalar multiplication for functions, your scalars have to be constant functions
18:08:52 <Cale> and the Num instance for functions makes those simple to write
18:09:42 <Cale> > (3 *^ cos) (pi/4)
18:09:43 <lambdabot>   No instance for (GHC.Num.Num (Data.VectorSpace.Scalar a))
18:09:43 <lambdabot>    arising from a...
18:09:49 <Cale> errr
18:09:59 <applicative> http://haskell.org/haskellwiki/Idiom_brackets -- except for the first line, it's a post to the libraries list or something, i think the full version was funnier.
18:10:06 <Cale> oh, too much polymorphism anyway
18:10:18 <Cale> > (3 *^ (cos :: Double -> Double)) (pi/4)
18:10:19 <lambdabot>   2.121320343559643
18:10:42 <aristid> :t (*^)
18:10:43 <lambdabot> forall v. (VectorSpace v) => Scalar v -> v -> v
18:11:09 <aristid> :k Scalar
18:11:10 <lambdabot> * -> *
18:11:19 <applicative> aristid, that was for you ^^^ another wild version of idiom brackets iI (+) sin cos Ii  
18:11:20 <jmcarthur> > (3 * cos) (pi/4) :: Double
18:11:21 <lambdabot>   2.121320343559643
18:11:32 <jmcarthur> vector-space also has a num instance for functions
18:11:47 <aristid> applicative: thanks, somehow i missed that because of the (*^) stuff
18:11:52 <Cale> Yeah, you don't really even need the VectorSpace instance if you have the Num one ;)
18:12:43 <applicative> aristid, i assume that that is the bad method that e.g. doesn't nest, that McB mentions in the blogpost
18:13:18 * kmc thinks that recursion itself is not abstract or concrete, any more than addition
18:13:40 <aristid> applicative: but i thought the |x + y| is just a wrapper for liftA2 (+) without join?
18:14:07 <djahandarie> I still can't quite figure out why something that should be forked is blocking
18:14:13 <applicative> aristid, yes it should be, am I making a mistake elsewhere?
18:14:37 <aristid> applicative: oh you mean the iI ... Ii stuff?
18:14:38 <applicative> wait, no, brackets should handle any number of arguments.  
18:14:41 <djahandarie> Could it be because there is a StateT and ReaderT wrapped around the IO?
18:15:12 <Cale> djahandarie: What are you doing? You somewhat-obviously can't forkIO something that's in any monad other than IO.
18:15:45 <Saizan> djahandarie: show the code!
18:15:48 <djahandarie> Oh you know, I just realized what I was doing wrong :P
18:15:58 <Saizan> also, maybe -threaded
18:16:03 <applicative> aristid, yes.  idiom brackets be like ... f <$> w <*> x <*> y <*> z , except with whitespace instead of the obnoxious Applicative operators.  You just bracket it all 
18:16:25 <aristid> applicative: well there's liftAn
18:16:35 <applicative> the leading operation is lifted to the Applicative by pure.  
18:16:38 <Cale> People abuse StateT and ReaderT a bit much, I think.
18:16:54 <aristid> Cale: yes they should use IORef instead.
18:16:59 <Cale> They can be handy when you're constructing certain libraries
18:17:12 <Cale> But over IO, they're a bit funny.
18:17:21 <djahandarie> Hm, no, I don't think I figured it out actually
18:18:07 <applicative> aristid, where's there a liftAn liftMn I cant remember
18:18:24 <Cale> applicative: Control.Applicative and Control.Monad respectively
18:18:33 <applicative> i was just looking...
18:18:34 <aristid> stops at liftA3 though
18:18:39 <aristid> and liftM5
18:18:44 <Cale> applicative: It's not literally called "liftMn" though
18:18:51 <Cale> The n is a number :)
18:19:17 <Cale> and they all have different types, so they'd be tricky to unify
18:19:39 <applicative> right, that I know.  I was thinking there might be some clever device that admitted any number of arguments
18:19:41 <djahandarie> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27768#a27768
18:19:45 <djahandarie> There are all the relevant parts
18:20:01 <djahandarie> I believe the problem is with how I defined mapBot'
18:20:03 <aristid> :t liftA2
18:20:04 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
18:20:07 <aristid> :t liftA3
18:20:07 <djahandarie> Surely
18:20:07 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
18:20:29 <djahandarie> It's just that I don't know how to define a mapBot' that'd work with forkIO
18:21:17 <Cale> djahandarie: You already derived Functor for Bot
18:21:26 <Cale> err...
18:21:29 <Cale> Oh, I see.
18:21:36 <illissius> you can do zipWithN (with IncoherentInstances)... maybe you could do liftAN, i dunno
18:21:44 <Saizan> mapBot' runs the second argument and passes the result
18:21:52 <Cale> yeah, hmm
18:21:55 <Saizan> you want to pass the action directly
18:22:01 <applicative>  as the Control Monad docs say, "return f `ap` x1 `ap` ... `ap` xn  is equivalent to     liftMn f x1 x2 ... xn"  That's what idiom brackets are for, though the Applicative class basically isolates just what is neceesary for that, not the full force of a monad
18:22:04 <Saizan> and do somethin not totally silly with the state.
18:22:49 <Saizan> djahandarie: should pingTimeout be able to propagate updates to the state to the rest of the computation?
18:23:06 <Cale> That's pretty tough.
18:23:19 <djahandarie> It doesn't alter the state
18:23:25 <Cale> I suppose you can ignore any changes to the state that the Bot a parameter would incur
18:23:41 <Cale> But you still shouldn't be passing return a to f
18:24:04 <aristid> applicative: a true liftAn would be cool
18:24:07 <djahandarie> I couldn't think of any other way to define that
18:24:23 <djahandarie> It works good for other uses
18:24:23 <Cale> You should runBot the Bot arg to get an IO action, fmap fst on that action
18:24:25 <aristid> it would be the whole ascension: pure, fmap, liftA2, liftA3...
18:24:28 <Cale> and pass that IO action along
18:25:17 * hackagebot smt-lib 0.0.2 - Parsing and printing SMT-LIB.  http://hackage.haskell.org/package/smt-lib-0.0.2 (TomHawkins)
18:25:18 <illissius> http://paczesiowa.blogspot.com/2010/03/generalized-zipwithn.html
18:25:37 <Saizan> djahandarie: ok, in that case you can use "mapBot' f m = do s <- get; r <- ask; liftIO $ f $ fmap fst (runBot r s m)"
18:25:44 <Cale> If you're using mapBot' with forkIO, then essentially what you're doing with this code is running the IO action first, then forkIO'ing (return a)  (which terminates immediately, doing nothing)
18:25:48 <illissius> maybe the same method is portable to liftAn, but atm i'm off to sleep
18:25:59 <djahandarie> Cale, right
18:26:11 <Cale> djahandarie: Yeah, look at Saizan's code :)
18:26:20 <djahandarie> Ahh, neat
18:26:58 <djahandarie> I was really close to that but I could figure it out so I switched to this version
18:27:06 <djahandarie> couldn't*
18:27:43 <Cale> djahandarie: If you ask me though, I probably wouldn't even go to so much trouble with the monad transformers
18:28:12 <Cale> djahandarie: Just use functions which pass along the bot configuration, and make the last ping part of that, turning it into an IORef.
18:28:17 <applicative> aristid, yeah, the idiom brackets are pleasing since they bring out the point of the 'idiom' and 'applicative' metaphors, that it's like a re-interpretation of whitespace, or of application, putting application in another key -- IO, [], whatever
18:29:06 <Saizan> Cale: i'd probably end up using ReaderT to pass that IORef around though :)
18:29:37 <Cale> Well, that's fine, but I wouldn't do it normally until I was really sure that it was going to be a hassle.
18:29:56 <djahandarie> IORefs seem ugly to me though
18:30:09 <djahandarie> Especially if I want to start storing more state
18:30:10 <Cale> As soon as you switch to ReaderT, sure, you don't have to pass the parameter around explicitly, but all of a sudden you have to liftIO all your IO actions
18:30:25 <Cale> and moreover, you'll still have to use ask quite a bit.
18:30:28 <djahandarie> Well if everything used MonadIO instead that wouldn't be a problem :(
18:30:29 <applicative> aristid, but that's how you're supposed to see  f <*> x <*> y <*> z -- as a 'higher whitespace'
18:30:45 <Cale> That's not even really possible.
18:30:54 <djahandarie> Well, a lot of functions can use it
18:30:56 <Cale> There are a lot of higher order things which don't really work out.
18:31:13 <djahandarie> Higher order things?
18:31:29 <Cale> Things which take IO actions as parameters can't just be in MonadIO so easily.
18:31:42 <Cale> (as you're finding out)
18:32:01 <Cale> and it complicates types quite a bit to make everything use MonadIO contexts in place of IO actions
18:32:34 <aristid> applicative: the lack of infixness is what disturbs me most. inserting <$> and <*> isn't that bad
18:33:06 <Cale> djahandarie: IORefs are a little bit ugly, but really not so bad, particularly when you wrap up their use a bit.
18:33:23 <Saizan> in fact, most uses of ReaderT would really much more pleasantly solved by module level abstractions.
18:33:59 <Cale> djahandarie: For example, rather than sticking an IORef for the lastPing in your configuration, you could instead stick an IO action for updating the last ping, and maybe one for reading it back, or something to check if there hasn't been a ping in too long.
18:34:13 <Cale> Or, whatever abstraction you want to build around that piece of state.
18:34:18 <djahandarie> Right
18:35:30 <djahandarie> Saizan, that code worked perfect
18:35:59 <Cale> Monad transformers are cool in some cases, but usually I find there are enough inconveniences related to them that transforming IO is a bit awkward compared to the alternatives. However, StateT over list, for example, is really cool.
18:36:17 <aristid> :t local
18:36:18 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
18:36:20 <djahandarie> This is similar to how xmonad was done
18:36:54 <Cale> Monad transforming nondeterminism monads (and usually then wrapping the transformer methods) is rather nice for doing things like solving puzzles.
18:37:01 <aristid> hmm i can think of a MonadReader instance for IO
18:37:11 <Cale> (Or in more serious contexts, you'd call it discrete optimisation ;)
18:37:13 <aristid> but that would be evil
18:38:04 <Cale> aristid: You can do some funny things with installing signal handlers
18:39:01 <aristid> Cale: huh?
18:39:17 <Cale> I think it was monochrom who did that.
18:39:32 <cncl> does anyone know if the exhaustiveness checker is going to work correctly on GADTs in 6.14?
18:39:32 <aristid> Cale: i was basically thinking of having ask return undefined by default, and only inside a local have it be a defined value
18:39:35 <Cale> aristid: There are some funny ways to hide state in IO without writing to files.
18:40:35 <Cale> cncl: I don't think 6.14 is anywhere close to being released yet, so it's probably not certain, unless there's already a patch for it in HEAD.
18:41:03 <cncl> i looked at the tickets and didn't see any patches, except that a relevant one was assigned to spj
18:41:09 <cncl> with a milestone set for 6.14
18:42:44 <cncl> so i was just wondering if anyone knew what was up. i rely on exhaustive a lot for maintaining correctness, and since it gives erroneous warnings for gadts it makes them less enjoyable to use
18:42:50 <cncl> er exhaustive checking
18:43:05 <cncl> (i realize it's a longstanding issue with ghc)
18:46:05 <cncl> if it'll be working in 6.14 then i'd go ahead and use GADTs on a project i'm starting now, otherwise i'd want to avoid it, since it's a little painful maintaining exhaustive patterns by hand when normal datatypes get it with an automated checker
18:48:44 <Cale> How complicated are the datatypes you're using that it's hard to tell if pattern matches are exhaustive or not? :)
18:49:01 <Cale> I suppose with GADTs some of the use cases can get pretty complex.
18:49:05 <Saizan> cncl: 6.14 should feature the new type checker described in the OutsideIn(X) paper, there's a paragraph on exhaustiveness checking towards the end, i don't remember any definite word on the matter though
18:49:23 <cncl> it's honestly not that bad, but i really like the warm fuzzy feeling from an automated checker
18:49:37 <cncl> rather than putting in a wildcard and returning undefined at the end of some pattern matches
18:50:16 <cncl> Saizan: oh i was meaning to read that one
18:51:40 <trinithis> When I do "cabal install base" I get "cabal: Distribution/Client/Dependency/TopDown.hs:169:37-73: Non-exhaustive patterns in lambda"
18:51:41 <Saizan> it'd be a matter of how good the constraint solver will be at proving the assumptions introduced by some gadt constructor don't make any sense
18:52:23 <Saizan> trinithis: heh, not a good error, but you can't install base anyway
18:52:37 <trinithis> Heh
18:53:02 <cncl> speaking of exhaustiveness :)
18:53:19 <trinithis> Well I'm trying to install my own package using "cabal install" and get an error saying "cabal: There is no installed version of base"
18:53:37 <Saizan> fmap (\(InstalledOnly p) -> InstalledOnly p) (PackageIndex.lookupPackageId available pkgid') -- deliberately partial :)
18:53:46 <Gracenotes> trinithis: so then 'ghc-pkg list' probably doesn't have base in it?
18:54:17 <trinithis> I have base-3.0.3.2 and base-4.2.0.0
18:54:32 <Saizan> are those red?
18:54:38 <trinithis> no
18:55:01 <Gracenotes> how about 'cabal info base'
18:55:42 <trinithis> shows a lot of modules and shows i have "4.2.0.0" vs the current "4.2.0.2"
18:55:52 <Gracenotes> then again that function doesn't have much to do with whether it's installed
18:56:05 <Saizan>  Latest version installed: 4.2.0.2
18:56:26 <Gracenotes> the rest is a pretty-printed cabal file
18:56:34 <Gracenotes> pretty-printed flattened cabal file
18:58:38 <Gracenotes> hum
18:58:41 <Saizan> quite weird, unless your base installation is broken, i.e. by missing some of the dependencies, i don't know how this could happen
18:59:44 <drhodes> anyone know of a sound library that can play a sinewave of specified frequency in real time?  preferable not something which requires integration with JACK or a MIDI controller.  I also want a pony ride and an ice cream cone with jimmies.
19:00:27 <trinithis> oh I think the error was due to the fact that I forgot to fill in my .cabal file
19:01:03 <Saizan> oh, you didn't have base in build-depends?
19:01:31 <trinithis> haha yea
19:01:53 <Saizan> i see, nasty bug :)
19:03:21 <Saizan> in cabal-install, i mean
19:03:36 <Gracenotes> does cabal init say something like "FILL IN YOUR DEPENDENCIES" at the end?
19:04:25 <Saizan> it wants to filter out the availiable base package from hackage, but doing so it actually imposes that you'll have a base package in the solution
19:04:27 <Veinor> I don't think so
19:04:38 <Veinor> because it's meant to be run at the start, when you don't know your dependencies :)
19:08:55 <trinithis> what would be a good project category for a pretty printer for displaying options for a '--help' command?
19:11:32 <adnap> Is there a library that defines operations for points and vectors?  For instance, the difference of two points is a vector.
19:12:07 <adnap> Something that's geared toward Computer Graphics.
19:25:09 <noteventime> adnap: Complex?
19:25:59 <ksf> adnap, thousands.
19:26:14 <ksf> ...it all depends on how much you lean into the math or graphics direction
19:26:47 <ksf> and a point _is_ a vector. from the origin to the point, that is.
19:27:04 <ksf> ...and all vectors have their root in the origin.
19:27:46 <noteventime> adnap: There's also Vec 
19:28:02 <noteventime> For simple stuff you're probably better of with the build in Complex type though :)
19:28:24 <ksf> vec is perfect for graphics stuff
19:28:44 <ksf> basic linear algebra, speed and no fancy stuff like vector-space has
19:29:36 <ksf> ...just don't let the instances in the haddock confuse you.
19:31:28 <noteventime> ksf: If all you want is some basic transformations in euclidean 2D you may be better off with just Data.Complex though :)
19:34:24 <noteventime> How come there's a RealFloat constraint on Comples? 
19:34:26 <noteventime> Complex*
19:34:35 <ksf> for sqrt
19:34:41 <ksf> ...for abs
19:35:11 <noteventime> Couldn't that constraint just be on the RealFloat instance of Complex?
19:35:29 <mauke> there is no RealFloat instance
19:35:30 <noteventime> Or am I missing some Haskell98 problem...
19:35:32 <ksf> speak of premature optimisation. abs could go a -> b instead of a -> a and everything would be fine.
19:36:02 <ksf> wait no
19:36:10 <noteventime> makmanalp: Sorry, I meant Floating
19:36:44 <ksf> for polar
19:37:03 <ksf> ...which I never, ever used in 2d graphics.
19:38:29 <noteventime> ksf: I still don't see why the Complex data declaration needs RealFloat
19:38:46 <dolio> It doesn't. It's just bad design.
19:38:51 <noteventime> I see
19:42:51 <kniu> Is liftM basically fmap specifically for monads?
19:42:58 <mauke> yes
19:43:11 <kniu> :t lift
19:43:12 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
19:43:26 <kniu> uh...
19:43:38 <kniu> okay.
19:53:29 <noteventime> kniu: A MonadTrans t is basically a function between monads, and "lift" lifts a monadic value in Monad m into the Monad (t m)
19:55:39 <c_wraith> :t Language.Haskell.TH.lift
19:55:40 <lambdabot> Not in scope: `Language.Haskell.TH.lift'
19:55:44 <c_wraith> :t Language.Haskell.TH.Syntax.lift
19:55:45 <lambdabot> forall t. (Language.Haskell.TH.Syntax.Lift t) => t -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
19:56:03 <c_wraith> Don't confuse that with the Monad Transformer lift. :)
19:56:25 <noteventime> I have never seen that one :)
19:56:59 <c_wraith> It converts data to its template haskell representation.
19:57:46 <c_wraith> Well, anything you can write an instance for.  But it's really hard to write an instance of that for a function.
19:59:44 <noteventime> So it's Read one level up the abstraction :p
20:00:43 <noteventime> c_wraith: Don't worry, I doubt I'll confuse them :)
20:01:30 <c_wraith> I confused them once, when I was first learning TH.  I was rather confused what the lift was doing there, but the code worked... :)
20:01:41 <c_wraith> Once you figure it out, you don't mix it up again. :)
20:07:48 <noteventime> Primetime is out in the pacific right now, that explains why It's so quiet :9
20:09:13 <djahandarie> Nah, people here are usually up late anyways
20:09:16 <ksf> I'd attribute it to the fact that its 05:08, here.
20:10:32 <noteventime> Well, here too
20:10:57 <noteventime> Didn't know the channel was so Euro centric though 
20:12:22 <Saizan> it isn't, in fact
20:12:36 <Cale> This channel is pretty global
20:12:38 <ksf> it is, but americans don't notice.
20:23:04 <noteventime> Interesting that I didn't say Europe and Africa
20:23:25 <noteventime> On the topic of Eurocentricity :)
20:28:15 <Saizan> heh
20:33:37 <PetRat> Parsec question http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27772#a27772
20:35:03 <om-foxy> if ghci is executing a file "Main.hs" in a directory that contains "./Data/Custom.hs" and Main.hs imports Data.Custom, is there a default package name?  Because according to the documentation for "Module" in the GHC API: \/A Module is a pair of a PackageId and a ModuleName.\/  
20:36:40 <om-foxy> But if ghci is operating with those files on the "-i" load path there is no package.
20:37:53 <Saizan> PetRat: vResult <- fmap (fromMaybe 0) (option v) ..
20:39:06 <Saizan> om-foxy: one is probably conjured up automatically, iirc it's called Main too, but i'm not sure
20:39:28 <om-foxy> okay, thanks.
20:40:28 <handonson> $ cabal install base
20:40:29 <handonson> cabal: Distribution/Client/Dependency/TopDown.hs:169:37-73: Non-exhaustive patterns in lambda
20:41:01 <djahandarie> Ah damn
20:41:15 <djahandarie> Saizan, so now I happen to be modifying the state in the forked thread :3
20:41:18 <Saizan> handonson: that's an horrible way to say "you can't install base"
20:41:30 <handonson> I want to install shared versions of libraries
20:42:12 <handonson> so i tried cabal install base --ghc-options=-dynamic
20:42:13 <Saizan> i'm not familiar with shared libs, though base can only be installed as part of ghc's installation
20:42:31 <Saizan> so there's probably some flag for ghc's ./configure
20:42:44 <Saizan> djahandarie: haha!
20:43:29 <djahandarie> I feel like I should switch off of StateT
20:43:30 <handonson> then cabal should say "you can't install base" instead of "Non-exhaustive patterns"
20:43:36 <Saizan> djahandarie: you've to "s/StateT s/ReaderT (MVar s)/"
20:43:48 <Saizan> handonson: true, it's a bug
20:44:23 <djahandarie> Maybe I should listen to Cale and use an IORef
20:45:12 <Saizan> i guess an IORef is fine too with atomicallyModifyIORef 
20:45:42 <djahandarie> I already have the ReaderT under the StateT so I wouldn't need to have two anyways
20:45:48 * djahandarie sighs
20:46:06 <djahandarie> I went through all this trouble to add StateT and now I'm getting rid of it :3
20:46:23 <Saizan> you'd use one with MonadReader and the other with MonadState
20:46:47 <djahandarie> ... you can make a ReaderT a MonadState?
20:47:30 <Saizan> instance MonadIO m => MonadState s (ReaderT (IORef s)) where ...
20:47:42 <Saizan> instance MonadIO m => MonadState s (ReaderT (IORef s) m) where ... -- actually
20:48:10 <djahandarie> Ah, so I can't just automagically derive it
20:48:57 <Saizan> heh, no, you've to put the code to deal with the IORef :)
20:49:38 <djahandarie> Stacking two ReaderT seems really fugly
20:49:47 <djahandarie> Isn't there a StateT which takes threads into account?
20:50:51 <Gracenotes> didn't someone post a package to hackage recently that did this? I did it once too, but didn't publish anything
20:50:52 <Saizan> yes!
20:50:55 <Saizan> newtype StateThreadedT s m = StateTT (ReaderT (IORef s) m)
20:51:07 <djahandarie> Haha -_-
20:51:08 <Saizan> ;)
20:51:22 <Gracenotes> enjoy
20:51:24 <Gracenotes> http://hackage.haskell.org/package/mstate
20:51:36 <djahandarie> Oh, neat
20:51:38 <handonson> is it possible to change the code while it is running? like reload() in Python
20:52:26 <Saizan> what is the Chan (MVar ()) doing there?
20:52:31 <djahandarie> That's what I was wondering
20:52:45 <djahandarie> Hmmm
20:53:00 <djahandarie> Apparently he provides his own forkIO as forkM and uses it in there
20:53:05 <Saizan> (note that it is otherwise isomorphic to ReaderT (MVar s) :P)
20:53:23 <djahandarie> I know, but the point is the work is already done for me ;)
20:53:56 <Gracenotes> yeah, my implementation just used a regular MVar
20:53:59 <Saizan> ah, runMState waits for all the threads to terminate
20:55:36 <Gracenotes> it's possible to define other Forkable instances for reader-esque monads; the problem with generalizing it is that you need the runReader function, which varies from monad to monad
20:57:01 <Gracenotes> hm.. would it be possible to define an instance for Forkable m => Forkable ()ReaderT s m)?
20:57:40 <lispy> If I get: Data.ByteString.head: empty ByteString, is there any easy way to locate it?
20:58:10 <Gracenotes> ouija board
20:58:23 <Saizan> forkM m = lift . forkM . runReaderT m =<< ask 
20:58:41 <Gracenotes> yes, that would need monadtrans though
20:58:55 <Gracenotes> which isn't a bad thing
20:59:05 <Saizan> you can inline ReaderT's lift if you want :)
20:59:06 <ksf> lispy, grep for head and get rid of _all_ of them, without exception or remorse.
20:59:25 <lispy> ksf: that would take an incredible amount of time/effort
20:59:46 <PetRat> Saizan: okay I updated it here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27772#a27775  However, my problem is that both the vOption and cOption parser consume any leading spaces, so due to the predictive nature I this doesn't work with the case that either a v argument or c argument could be present.
20:59:58 <lispy> ksf: there are nearly 200 uses
21:00:12 <ksf> that's 200 too many.
21:00:13 <lispy> (although, some of that is test suite code, I guess)
21:00:55 <ksf> ...use an uncons class that calls the right continuation.
21:01:24 <ksf> there's a gazillion of generic folds.
21:01:25 <ksf> use them.
21:02:09 <Saizan> PetRat: you could factor the spaces out into play
21:02:16 <lispy> ksf: so you don't actually know how to pinpoint it?
21:02:31 <ksf> I pinpointed the _exact_ location of the error.
21:02:39 <ksf> which is using head, in the first place.
21:02:56 <PetRat> Saizan: okay I'm working on it
21:03:05 <Saizan> lispy: the old -xc trick could work
21:03:07 <lispy> Okay. While you refactor this to not use head, I'll go find the offending code
21:03:16 <lispy> Saizan: what is the old -xc trick?
21:04:05 <Saizan> something about compiling a profiling version and running it with -p -xc iirc, you should get something resembling a stack trace in the .prof file
21:04:26 <Saizan> made of cost centres instead of function calls, though
21:05:05 * lispy starts a build
21:05:25 <sm> current SourceGraph looks at all modules under the current directory, not just the ones referenced by the cabal file you give it, eh
21:06:23 <lispy> ksf: It took me all weekend just to change this code from a custom parser to a non-custom one (attoparsec) and that change was mostly trivial.  I have no idea how many years it will take to remove all uses of ByteString.head from the parser
21:06:41 <PetRat> Saizan: maybe I should apply 'words' to the string, then parse each result individually
21:07:17 <ksf> you could write a preprocessor that adds catch clauses
21:07:20 <handonson> is it possible to change the code while it is running? like reload() in Python
21:07:37 <ksf> handonson, for most values of reload, no.
21:07:44 <Saizan> PetRat: that too
21:07:57 <PetRat> I've got something that can parse v and c arguments but its ugly http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27772#a27776
21:08:09 <Saizan> PetRat: i'm not really a parsing expert..
21:08:58 <handonson> I thought I'd use a simple plugin structure, and I didn't know if having separate process for each plugin (which is easy with GHC) was overkill or not
21:09:32 <lispy> ksf: oh, I can just check my diff for uses of head :)
21:09:59 <Cale> handonson: You might consider using hint to load code at runtime
21:10:10 <ezyang> handonson: You could take a page from XMonad and have your entire program state be serializable. 
21:10:18 <Cale> (hint is a wrapper around the GHC API)
21:10:20 <ezyang> (note: you can actually do this in Haskell!) 
21:13:34 <Saizan> ?type option
21:13:35 <lambdabot> Not in scope: `option'
21:13:38 <Saizan> ?type optional
21:13:39 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
21:13:52 <Saizan> PetRat: ^^^
21:13:58 <handonson> thanks all. i think i'll stick to the process-per-plugin structure.
21:14:30 <Saizan> also, i feel like putting spaces inside v/cOption is making things more difficult.
21:14:43 <Cale> handonson: One thing about that is that you're basically limited to communicating with your plugins via strings.
21:15:18 <Cale> handonson: But if that's not a problem, then it'll work about as well as anywhere.
21:16:07 <handonson> Cale: But having to communicate with more complicated structures than Strings usually means that the plugin (that is changeable while running) system is not quite appropriate
21:16:25 <handonson> well, maybe not if you use Hint
21:17:11 * hackagebot alms 0.4.10 - a practical affine language  http://hackage.haskell.org/package/alms-0.4.10 (JesseTov)
21:21:31 <PetRat> Is there something like skipMany? (I see skipMany1)
21:23:25 <PetRat> Maybe optional (skipMany1 space) ?
21:24:48 <noteventime> PetRat: There's a skipMany in parsec (which I guess is what you're asking about)
21:24:55 <noteventime> Or at least, in the version I have installed
21:25:30 <handonson> isn't "many something >> return ()" skipMany
21:26:09 <prsteele> if I have 'foo (Bar a) = a' and 'foo (Baz a) = a', is there a way to do a catch-all pattern match against the constructors 'Bar' and 'Baz'?
21:26:29 <ezyang> prsteele: Sort of, with guards. 
21:26:34 <ksf> either I'm blind or fgl doesn't come with standard functions to split a graph into connected components.
21:26:54 <ezyang> foo a | isBar a || isBaz a = 
21:27:06 <ksf> ...or, even nicer, follow directed edges from a loop and drop everything unreachable.
21:27:47 <Gracenotes> you only get DFS when you subscribe to FGL Platinum Membership
21:28:15 <prsteele> Okay, so if I had, say, 50 one argument contructors, I'd
21:28:15 <prsteele> 	 still need 50 guards?
21:28:25 <ezyang> In that case, I'd suggest restructuring your type. 
21:28:30 <ezyang> Fooable a Type 
21:28:31 <Saizan> ?type skipMany
21:28:32 <lambdabot> Not in scope: `skipMany'
21:28:34 <Saizan> ?type skipMany1
21:28:35 <lambdabot> Not in scope: `skipMany1'
21:28:39 <ezyang> where Type = Foo | Bar | Baz | ... 
21:29:03 <prsteele> thanks
21:29:22 <Saizan> prsteele: Text.Parsec.Prim.skipMany, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27772#a27777 
21:30:36 <ksf> I don't want to search. none of the things I'm doing here require search.
21:35:15 * hackagebot nonlinear-optimization 0.3.3 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.3 (FelipeLessa)
21:35:16 <ksf> ah, duh. dynamic programming to the rescue
21:36:02 <ksf> (one of those rare things I can pride myself to have invented)
21:43:37 <ksf> .oO( Map (Set k) (n, Map l (Set k)) )
21:50:01 <wolgo> hola
21:51:17 <_minoru> hello, i try to deal with C structs with ffi, and i have problems with understanding what 'alignment' function does
21:52:13 <_minoru> how can i properly define it in the Storable class definition?
21:52:42 <_minoru> after all, why do we need to divide pointer on some value?
21:54:28 <ksf> because some processors or just abis expect certain things at certain places.
21:54:51 <ksf> that is, if you have a 128-bit word, you might need to align it to the next even 32 bit boundary or something
21:54:57 <handonson> is there a nonblocking version of hGetLine? (other than hGetBufNonBlocking)
21:55:23 <ksf> set the handle to unbuffered
21:55:36 <ksf> er wait
21:55:41 <ksf> I misunderstood.
21:55:45 <ksf> the answer is forkIO.
21:55:59 <_minoru> ksf, hm, and how to define it properly?
21:56:19 <ksf> hell if I know
21:57:14 <handonson> i want it to return "" (or Nothing) if there's nothing to read
21:57:21 <ksf> c2hs should figure such things out by itself, just use the right macros.
21:57:31 <handonson> i don't think forkIO will do this. am I wrong?
21:58:10 <ksf> oh, _that_. you want to use fionread
21:58:46 <ksf> but you're getting into real low-level stuff there, I guess you took a wrong turn somewhere.
21:58:54 <ksf> what do you want to do on a higher level?
21:59:43 <ksf> with forkIO, you can implement a more event-driven interface.
22:00:04 <ksf> have a thread block on stdin and let it write to a chan
22:00:14 <handonson> okay, here's the situation
22:00:16 <ksf> ...then you can safely poll that chan.
22:00:21 <handonson> there are some processes running
22:00:46 <handonson> and my program will pass them some string. some of them may respond with another string.
22:01:08 <handonson> some of them may not respond at all, no matter what the given string is.
22:01:36 <handonson> i want to gather the responses and write them to a file.
22:02:40 <ksf> forkIO listeners on each output handle, let them send read lines to another thread that outputs them as they come in.
22:02:55 <ksf> line-wise synchronizing comes for free, like that.
22:03:40 <handonson> oh there's hGetNonBlocking in Data.ByteString
22:03:42 <ksf> ghc uses select() behind the scenes (soon epoll/whatever), so it's actually going to be efficcient.
22:07:42 <_minoru> also, had anybody used popen with haskell? System.Posix.POpen doesn't works at all
22:08:02 <_minoru> exactly, it doesn't ever returns
22:16:18 <FunctorSalad_> ksf: but some of the posix bindings evade it, or not?
22:16:28 <FunctorSalad_> readFromFD, writeToFD or so
22:17:31 <FunctorSalad_> almost... http://hackage.haskell.org/packages/archive/unix/2.4.0.2/doc/html/System-Posix-IO.html#4
22:18:05 <kmc> _minoru, System.Process provides a popen-like capability, is it too high level for what you're doing?
22:18:17 <FunctorSalad_> but since I don't really know how ghc's select() system works, I have no idea if these functions avoid it or not..
22:19:10 <FunctorSalad_> yes, just createProcess ( ..... { stdOut = CreatePipe } )
22:19:16 <FunctorSalad_> (for example)
22:19:47 <FunctorSalad_> the .... could be 'shell ...' or 'proc ... ...', or you can just make your own CreateProcess from scratch
22:25:20 <o^_^o> sorry for ab offtopic question but does anyone know how to checkout in git ?
22:25:35 <o^_^o> rather I had a local file named Vector.hs and I deleted it
22:25:43 <ezyang> git checkout Vector.hs 
22:25:48 <o^_^o> now I don't know how to get it back it is the remote repository though
22:25:49 <ezyang> but #git is the right chan for that question 
22:25:54 <o^_^o> ah..
22:26:02 <ezyang> (they're a very friendly bunch) 
22:26:03 <o^_^o> cool
22:32:42 <ezyang> See, now that wasn't so hard? :-) 
22:33:23 <o^_^o> hehe...yes thanks to you
22:33:35 <o^_^o> I would just chased my tail for an hour
22:33:39 <o^_^o> would've*
22:34:14 <ezyang> It is, strictly speaking, a UI failure on git's part, but it makes perfect sense if you think about it a little. 
22:34:22 <o^_^o> #ok now I forgot why I got in trouble in the first place...what was I doing in haskell ?
22:34:28 <o^_^o> oops
22:34:36 <o^_^o> I didn't mean to type that really
22:34:59 <o^_^o> I even commented it with a #
22:35:29 <o^_^o> ezyang, I have a very vague understanding of git, only that it is like a better CVS
22:35:46 <ksf> > let g (f,t,ls) m = foldr (\l m -> Map.insertWith Set.union l (Set.singleton t) m) Map.empty ls in foldr g Map.empty [(4,3,[1]),(4,4,[1,0])]
22:35:47 <lambdabot>   Not in scope: `Map.insertWith'Not in scope: `Set.union'Not in scope: `Set.s...
22:35:49 <ezyang> http://eagain.net/articles/git-for-computer-scientists/ 
22:35:57 * ksf is stricken with blindness.
22:36:07 <ezyang> (a dark cloud falls upon you) 
22:36:19 <ksf> [(1,fromList [3])] isn't what I am expecting, there.
22:36:23 <o^_^o> ezyang, you are reading my mind
22:36:48 <FunctorSalad_> :t M.insertWith
22:36:49 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
22:36:57 <ksf> :t S.union
22:36:57 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
22:36:59 <ksf> hey
22:37:02 <FunctorSalad_> Caleskell =)
22:37:12 <ksf> > let g (f,t,ls) m = foldr (\l m -> M.insertWith S.union l (Set.singleton t) m) M.empty ls in foldr g M.empty [(4,3,[1]),(4,4,[1,0])]
22:37:12 <lambdabot>   Not in scope: `Set.singleton'
22:37:18 <ksf> > let g (f,t,ls) m = foldr (\l m -> M.insertWith S.union l (S.singleton t) m) M.empty ls in foldr g M.empty [(4,3,[1]),(4,4,[1,0])]
22:37:19 <lambdabot>   fromList [(1,fromList [3])]
22:37:35 <FunctorSalad_> a good choice though, qualifiers are annoying
22:38:12 <ksf> i'd like to see fromList [(1,fromList [3,4]),(0,fromList [4])]
22:41:25 <ksf> > fix error
22:41:26 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
22:41:34 * ksf is off brewing some tea...
22:47:02 <ksf> > let g (f,t,ls) m = foldr (\l m -> M.insertWith S.union l (S.singleton t) m) m ls in foldr g M.empty [(4,3,[1]),(4,4,[1,0])]
22:47:03 <lambdabot>   fromList [(0,fromList [4]),(1,fromList [3,4])]
22:47:11 <ksf> heck someone could've told me...
22:47:36 <ksf> so much about well-typed programs don't go wrong.
22:48:30 <djahandarie> I wish types would solve everything for me
22:52:36 <handonson> Does Data.ByteString.Char8.hGet reads as soon as it is called? Or is it lazy and does not read until the value is needed?
22:53:16 <ksf> not without unsafeInterleaveIO
22:53:18 <c_wraith> It's strict
22:53:22 <ksf> ...have a look at the type
23:04:02 <handonson> What about System.Process.runInteractiveProcess? It seems it doesn't really run it until necessary... right?
23:09:41 <ksf> all IO things are strict by default, except hGetContents.
23:10:01 <ksf> ...wich should be called unsafeHGetContents.
23:10:52 <c_wraith> well, and things written in terms of it, like interact, and some other stuff.
23:11:40 <ksf> well but interact is strict in its output.
23:11:56 <ksf> ...which is probably what people expect, anyway.
23:13:12 <ksf> with plan9-like filesystems a process could provide stdout as a soft file and be lazy until someone wants to read.
23:13:44 <ksf> no bs like blocking on a full pipe buffer or such
23:14:51 <handonson> Really? Weird. Let me test my code just a little bit more and post it. I think I'm definitely having a non-strict I/O problem.
23:14:52 <c_wraith> yeah, interact is actually a good use of unsafePerformIO.  It will only keep a constant amount more of the list in memory than it needs.
23:15:00 <c_wraith> err, unsafeInterleaveIO
23:31:51 * ksf wonders whether he should define his nfas without epsilon transitions
23:32:29 <c_wraith> ksf: is there a benefit to doing so?
23:32:43 <ksf> I don't need to deal with them in my algorithms
23:33:14 <ksf> they're semantic clutter that can be processed away easily.
23:33:34 <ksf> iff you allow multiple start states, that is.
23:34:27 <c_wraith> Well, and it means generating the NFA is slightly more work-intensive.
23:34:38 <c_wraith> But it does mean processing with it is easier, as you say.
23:36:09 <o^_^o> is it possible to find all the functions that are available from a file ?
23:36:16 <o^_^o> I did a :l something.hs
23:36:21 <c_wraith> :browse
23:36:26 <o^_^o> ah
23:36:33 <ksf> I don't see where I would need them except to do e.g. concatenation. and in that case, I could just tell the determiser to continue with the second dfa if it hits a final state of the first.
23:37:01 <o^_^o> ok I have a main function inside the file so all the other functions are not loaded ?
23:37:02 <c_wraith> Oh, you certainly don't need them.  It just makes construction algorithms a little less braindead
23:37:04 <ksf> specifying nfas directly is a whole other topic, of course.
23:37:30 <ksf> ...but I won't do those without smart constructors, anyway.
23:37:51 <ksf> and the payoff is not having to worry about the alphabet.
23:38:22 <c_wraith> o^_^o, all the functions from a file you used :load on *should* be available...  Unless maybe it was compiled previously?
23:38:24 <c_wraith> Try using :load *modulename instead.
23:38:28 <c_wraith> with the * in front of it
23:38:42 <c_wraith> That tells ghci to load it interpreted, even if there's compiled code
23:38:51 <o^_^o> c_wraith, ah...ok
23:41:50 <FunctorSalad_> Data.Trie.Internals.showTrie can be used to visualize strings sets like paths, too :D
23:42:51 <FunctorSalad_> putStrLn . showTrie . fromList . map (Data.ByteString.UTF8.toString &&& Dummy) . lines =<< getContents 
23:43:53 <c_wraith> where "Dummy" is code for "const ()" ? :)
23:44:35 <FunctorSalad_> actually I made a type with invisubel show
23:44:37 <FunctorSalad_> ;)
23:44:48 <FunctorSalad_> (couldn't think of any existing one)
23:45:32 <c_wraith> ah
23:45:40 <FunctorSalad_> but it still prints () (where the show normally goes inside), so you might want to insert a really unlikely string as show instance and then sed..... er, or just edit the code of showTrie maybe ;)
23:46:23 <FunctorSalad_> but it has to be const Dummy, indeed
23:47:15 <c_wraith> unless Dummy took a parameter. :)
23:48:10 <FunctorSalad_> hehe, yes (briefly considered that but concluded it's impossible that 'Dummy a' would unify with a function type... but that's the type level, doh)
23:48:25 <FunctorSalad_> (<- tired)
23:49:25 <FunctorSalad_> wow, a non-ad-hoc example where "negative" lists/strings would be useful
23:49:40 <FunctorSalad_> show Dummy = inverse "(" ++ inverse ")"
23:50:20 <FunctorSalad_> (not sure if you were there when I suggested taking the free group instead of the free monoid that lists are)
23:50:29 <c_wraith> No, I missed that.
23:50:41 <lispy> There's no such thing as a free group.
23:50:58 <lispy> Or was that lunch?
23:50:58 <Jafet> :t inverse
23:50:59 <lambdabot> Not in scope: `inverse'
23:51:08 <FunctorSalad_> c_wraith: essentially, one could simply add formal inverses for lists in the way one adds formal inverses to natural numbers to get integers
23:51:39 <FunctorSalad_> (they'd cancel out with usual lists when appended)
23:51:59 <FunctorSalad_> lispy: lunch. free groups are real :o
23:51:59 <c_wraith> Only if their contents matched, or regardless?
23:52:15 <FunctorSalad_> if the contents matched
23:52:50 <c_wraith> Seems like there's a lot of potential for confusion with that.  But it could be a really neat model for certain types of computation
23:53:08 <FunctorSalad_> otherwise the result doesn't further reduce and you get, say, ` Append (Inverse "foo") (Plain "bar") ' as a formal expression
23:53:27 <FunctorSalad_> (these would be the three constructors of the type, at least that's one way)
23:53:38 <FunctorSalad_> (redundant though)
23:54:34 <FunctorSalad_> it's slightly more confusing/interesting than free monoids (lists) in that appending can collapse things, yes :)
23:55:00 <FunctorSalad_> assuming you always normalize (cancel out adjacent inverse/plain pairs) after appending
23:56:26 <FunctorSalad_> and I don't know any non-redundant encoding, actually
23:56:51 <FunctorSalad_> (an ADT such that the ghc-derived equality is mathematical equality)
23:59:09 <ksf> wait O( log n + log m) = O ( log (m + n) ) , isn't it?
23:59:38 <FunctorSalad_> the system of shortest representatives for `FreeGroup a' goes like '[Either a a]' (Left = negative, Right = positive), but with the extra condition that no two adjacent elements are cancellable
23:59:59 <c_wraith> ksf: probably?  I'd have to do a rigorous proof to convince myself of it 100%
