00:00:06 * hackagebot alms 0.4.9 - a practical affine language  http://hackage.haskell.org/package/alms-0.4.9 (JesseTov)
00:04:05 <gwern> so, it's been a good 2 days
00:04:10 <gwern> I guess I did block the spammer's IP
00:04:11 <gwern> phew
00:04:28 <ivanm> for wiki cleanup you mean?
00:04:30 <gwern> 2 or 3 more 2-3 hour long deleting/blocking sessions would have burnt me out
00:04:33 <gwern> ivanm: yes
00:06:35 * hackagebot yavie 0.0.1 - yet another visual editor  http://hackage.haskell.org/package/yavie-0.0.1 (YoshikuniJujo)
00:11:36 * hackagebot imgurder 1.0 - Uploader for Imgur  http://hackage.haskell.org/package/imgurder-1.0 (DanColish)
00:15:38 * hackagebot highlighting-kate 0.2.7.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.2.7.1 (JohnMacFarlane)
00:30:43 * hackagebot neither 0.0.1 - Provide versions of Either with good monad and applicative instances.  http://hackage.haskell.org/package/neither-0.0.1 (MichaelSnoyman)
00:33:45 * hackagebot persistent-sqlite 0.1.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.1.1 (MichaelSnoyman)
00:44:27 <Veinor> @pl f x = x >> f x
00:44:27 <lambdabot> f = fix (ap (>>))
00:57:21 <gwern> whew. that wasn't fun
00:57:56 <gwern> so, I was experimenting with the 'radeon' driver for X. turns out that on my machine, just swapping "fglrx" for "radeon" leaves you trapped in X, with no visible consoles, and lucky me, xmonad was breaking on recompile
00:58:09 <gwern> after a while, I figured out that the consoles were there, they just weren't *visible*
00:58:40 <gwern> so, I very very carefully navigated to /etc/X11/, blew away the current xorg.conf, replaced it with the old one, and rebooted
00:58:47 <gwern> making sure to sudo in the right places
00:58:53 <gwern> kind of like blindfold chess
00:59:10 <ksf> quick solution: hard reboot, init S
00:59:19 <Veinor> haha
00:59:25 * gwern thinks that's probably one of my cleverer troubleshoots
00:59:40 <Veinor> how did you figure out they were there?
00:59:49 <ksf> the /elegant/ way is to log on via ssh
00:59:57 <gwern> Veinor: I logged in blindly, and sudoed to 'shutdown'
01:00:03 <Veinor> ha!
01:00:08 <gwern> ksf: well, that's great IF YOU HAVE ANOTHER MACHINE TO SSH FROM
01:00:18 <Veinor> @unpl ap f
01:00:18 <lambdabot> (\ e -> f >>= \ b -> e >>= \ a -> return (b a))
01:00:23 <gwern> Veinor: you know, just in case the consoles were there, I wanted to be sure...
01:00:26 <Veinor> how very unhelpful of you.
01:00:31 <gwern> quite relieved when my laptop shut down :)
01:00:33 * Veinor hits lambdabot
01:00:33 <ksf> I _theoretically_ have. an old pentium which I would have to hook up, first.
01:00:45 <ksf> but I've got reiserfs disks and am not afraid of corruption.
01:00:53 <gwern> I don't think I've ever been so happy to see my machine rebooting
01:00:59 <Veinor> i heard it gets killer performance!
01:01:31 <ksf> another possibility is to have the power button do a proper shutdown or suspend
01:01:38 <gwern> ksf: what would that do for me?
01:01:40 <ksf> ...which is a _very_ good idea.
01:01:56 <ksf> you can shut down safely.
01:02:20 <gwern> ubuntu goes straight into X, and as I said, the consoles were invisible. I also tried doing the DISPLAY=0 emacs thing blind, but nothing was showing up in X
01:02:21 <ksf> and when you have shut down, you can add an S or 0 or even init=/bin/bash to the kernel command line.
01:02:32 <gwern> ksf: I have no idea how to do that
01:02:45 <gwern> so, not a live possibility for me
01:02:47 <ksf> it's easy in grub
01:03:03 <gwern> probably it is. but if you don't know it, you don't know it
01:03:11 <ksf> select the entry, hit e, select the proper line, hit e again, edit.
01:03:28 <ksf> then enter and finally b to boot.
01:05:26 <Veinor> @unpl ap
01:05:26 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
01:05:31 <Veinor> >:(
01:05:43 <Veinor> @. do unpl ap
01:05:44 <lambdabot> (\ d e -> do { b <- d; a <- e; return (b a)})
01:05:50 <Veinor> thank you.
01:06:26 <Veinor> @. do unpl ap (>>)
01:06:27 <lambdabot> (\ e -> do { b <- (>>); a <- e; return (b a)})
01:06:49 <Itkovian> quicksilver: I asked the CLasH guy to submit something for HCAR. He was going to look into it.
01:08:30 <gwern> let's see, bin, share, usr, .ghc... does GHC install anywhere else?
01:08:38 <gwern> Itkovian: what is CLasH?
01:08:59 <Deewiant> gwern: lib
01:09:08 <gwern> ah right
01:09:44 <Itkovian> Haskell to Verilog thingie afaik. http://hackage.haskell.org/package/clash-0.1
01:10:52 <Itkovian> thesis here: http://essay.utwente.nl/59482/1/scriptie_C_Baaij.pdf and paper here http://portal.acm.org/citation.cfm?id=1596638.1667736
01:11:35 <Veinor> is one-lining pattern guards like
01:11:48 <Veinor> > let f x | odd x = 2 | otherwise = 7 in f 8
01:11:49 <lambdabot>   7
01:11:58 <Veinor> legal in an actual .hs file? or is that just a ghc-ism
01:12:27 <Veinor> er... ghci-ism
01:12:44 <Veinor> hm, it's legal!
01:12:46 <Deewiant> It's legal
01:13:26 <gwern> I did not know that
01:14:04 <Veinor> doesn't mean it's something you should do, though
01:14:42 <Deewiant> Those, btw, are ordinary guards, not pattern guards (which /are/ a ghc-ism)
01:15:22 <Veinor> oh yeah
01:16:33 <Veinor> pattern guards and view patterns are really cool :D
01:19:34 <DarkUnicorn> what are view patterns?
01:19:58 <Veinor> hm
01:20:44 <Veinor> http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html
01:21:29 <Deewiant> > let f ((1 `elem`) -> True) = "found it"; f _ = "nope" in (f [123], f[1])
01:21:30 <lambdabot>   ("nope","found it")
01:23:36 <DarkUnicorn> oh i see. thank you
01:24:22 <quicksilver> Itkovian: excellent!
01:24:34 <Veinor> I never got the hate for NPlusKPatterns
01:24:35 <Itkovian> quicksilver: I have my moments :-)
01:28:16 <gwern> how ironic. I install cabal-install from my darcs repo of it, using bootstrap.sh, and the first thing cabal update tells me is that there is a new cabal-install available
01:28:23 <gwern> I CAN NEVER CATCH UP!
01:29:20 <Ke> !
01:30:50 <Itkovian> gwern: catching up is overrated anyway
01:32:04 <wli> Yeah, the n+k pattern hate kind of seemed weird to me. There's a lot of other stuff to get worked up about that I'd say is a higher priority. Also not sure where n+k patterns do the kind of damage meriting hate etc.
01:32:34 <gwern> but n+k was weak enough that attacking it did some good
01:32:41 <gwern> the other stuff has more defenders
01:32:46 <gwern> cost effectiveness
01:33:21 <mm_freak> my haskell wish list rather includes missing features, not currently implemented features, which are bad in some way
01:33:53 <mm_freak> like not having to write long LANGUAGE pragmas
01:34:04 <mm_freak> like getting monad comprehensions back
01:34:32 <wli> I don't know. I would literally say n+k patterns are so harmless as to admit extensions of them to e.g. m*n+k patterns.
01:34:38 <mm_freak> like setting map = fmap
01:34:43 <quicksilver> Could you write monad comprehensions as a quasioquoter?
01:34:57 <quicksilver> that would be an easy way to demonstrate their utility and argue for their return.
01:35:10 <malcolmw> Deewiant: pattern guards are not a ghc-ism, they are official Haskell 2010
01:35:26 <gwern> isn't that an argument against? 'you can just write your little comps as quasiquotes if you want them, no need to bake them into the language
01:35:26 <mm_freak> wli: that wouldn't work as easy
01:35:27 <Deewiant> Oh, nice
01:35:29 <wli> I actually tried to figure out ghc enough to get monad comprehensions going but it was too much for a first project etc.
01:35:34 <Deewiant> I'm not up to date on my post-98 standards :-)
01:35:51 <Veinor> why does haskellwiki look like crap now :/
01:36:14 <quicksilver> it broke and they lost the stylesheets.
01:36:20 <Veinor> ...
01:36:29 <Veinor> :(
01:36:41 <quicksilver> gwern: not really. Features don't get standardised until they have been implemented and used.
01:36:52 <quicksilver> gwern: an easy way to implement them lowers the barrier
01:36:58 * Veinor throws his hands up in despair
01:37:11 <gwern> quicksilver: that's a good counter-argument. I wonder which is correct
01:37:12 <quicksilver> otherwise it requires someone to grok GHC internals enough, which as wli demonstrates, is not an easy task.
01:37:27 <Veinor> i liked the old look and the old logo, too :/
01:38:03 <gwern> old logo? aren't we still using the pre-contest one?
01:38:07 <mm_freak> well, i can live without monad comprehensions…  do notation does what i want most of the time
01:38:32 <Veinor> I meant the contest logo
01:38:32 <mm_freak> they just look nicer sometimes
01:38:40 <Veinor> old here means 'before we lost things'
01:39:20 <wli> The thing to really rail about is fail as a Monad class method and MonadPlus and MonadZero/Monad0 being smashed together.
01:39:28 <Veinor> it makes us look kind of unprofessional 
01:39:42 <quicksilver> wli: quite hard to fix that.
01:39:54 <osfameron> Veinor: heh, really?
01:40:13 <wli> quicksilver: Invasive maybe. Hard I'm not convinced of.
01:40:23 <Veinor> I hate the lambda-in-a-circle :/
01:40:29 <quicksilver> wli: socially or culturally or procedurally hard
01:40:32 <quicksilver> wli: not technically.
01:40:36 <osfameron> oh, haskell.org ahs both the old logo and the new one on it
01:40:41 <osfameron> so everyone's happy! ;-)
01:40:47 <quicksilver> we don't have a good plan on how to change the prelude in a fundamental way like that.
01:40:50 <Veinor> :P
01:40:51 <quicksilver> osfameron: I'm not. I don't like either of them.
01:41:05 <Veinor> well, it's not like we lost the new logo
01:41:26 <Veinor> there's still copies of it floating around. the stylesheet's lost, though. :(
01:41:31 <osfameron> quicksilver: I like the new airline-company one
01:41:50 <quicksilver> Veinor: I believe someone is working on a new mediawiki install as a basis of a long term fix with better stylesheets et al
01:42:09 <Veinor> whoo!
01:42:12 <quicksilver> osfameron: if it was airline company that would be OK. It's the fact that it's 1980s train company I don't like :)
01:42:33 <ksf> why not gitit?
01:42:40 <gwern> gitit is insecure
01:42:41 <osfameron> trains have a lower carbon footprint than planes.  surely that's appropriate ;-)
01:42:48 <gwern> and it's unclear whether it will scale
01:43:29 <quicksilver> osfameron: sure. but they have terrible logo design :)
01:43:42 <quicksilver> ksf: why not mediawiki?
01:43:55 <quicksilver> (because that's the first question to answer, if you think a change is merited)
01:44:25 <ksf> eating our own dog food
01:44:40 <gwern> using gitit is a good idea in the long-term
01:44:54 <gwern> but someone needs to use it on a large scale before we use it in such a public place
01:45:12 <KingOfNauru> !rules
01:45:33 <gwern> so performance can be improved, more eyes hunt down security holes (of which there are no doubt many)
01:45:42 <Jafet> gwern: but no one will use it on a large scale if it's not even being used for the haskell website
01:45:54 <gwern> Jafet: you see why gitit is not ready now
01:46:20 <mm_freak> what about the wiki database?  have we lost content or just style?
01:46:21 <Jafet> fix gitit;
01:46:29 <ksf> I don't see where's the problem as long as we have the info to roll back and the bug squad is ready.
01:46:58 <gwern> ksf: even temporary exploits can be bad. take control for a little while, steal passwords, and how many people do you think reuse passwords?
01:47:29 <gwern> suppose 20 or 30 people have their lives fucked up by hackers? that would do haskell's reputation a world of good alright...
01:47:50 <ksf> how hard can it be to sandbox the wiki data from the password data?
01:48:11 <mm_freak> gwern: in general passwords aren't saved in plaintext
01:48:37 <mm_freak> only people with a weak password have to worry
01:48:40 <gwern> 'how hard can it be to make a secure <anything>?'
01:48:45 <gwern> 'very'
01:49:01 <gwern> mm_freak: and what do you think people log in with?
01:49:25 <gwern> they're not typing in their hashes
01:49:33 <mm_freak> gwern: if the attacker has the password database, but not online access to the system, then he can't do much harm
01:49:43 <bnonym> mm_freak: wrong.
01:50:02 <gwern> bnonym: iirc, gitit does salt its hashes, so it's not *as* bad as it could be
01:50:20 <mm_freak> bnonym: enlighten me
01:50:38 <bnonym> mm_freak: reuse of passwords, social engineering etc etc etc
01:50:41 <gwern> the trouble is past holes in gitit have allowed arbitrary shellcode to be executed, making it perfectly possible to backdoor the gitit binary itself, and there go everyone's passwords
01:50:58 <mm_freak> bnonym: passwords are saved as hashes, not in plaintext
01:51:12 <mm_freak> it's as if you would steal an /etc/shadow
01:51:25 <mm_freak> only weak passwords can be broken that way
01:51:25 <bnonym> oh there aren't any rainbow tables out there?
01:51:35 <mm_freak> rainbow tables against salted hashes?
01:51:49 <mm_freak> you'd need to show me a single one of those =)
01:52:22 <gwern> anyway, so that's why we can't just plop gitit on haskell.org
01:52:36 <gwern> that and there are no mediawiki->markdown converters that I know of
01:52:53 <gwern> or mediawiki-install->gitit-install converters either
01:53:31 <mm_freak> have we lost content or just style?
01:53:40 <mm_freak> in other words: is the database gone, too?
01:54:02 <Botje> pandoc (written in haskell) can do markdown->mediawiki
01:54:05 <Botje> but the other way round. huh.
01:54:13 <Botje> *not ..
01:54:51 <mm_freak> what happened anyway?  did someone attack haskell.org?
01:55:43 <gwern> 2 someones I thought - someone backdoored us and the wiki got hit by a spammer
01:57:53 <mm_freak> hmm, ok
01:58:20 <mreh> when did this occur?
01:59:00 <gwern> the backdoor was a few weeks ago iirc
01:59:14 <gwern> or a month or two? something like that
01:59:18 <gwern> the spam was in the last few days
01:59:23 <mreh> so i'd already be hacked :)
01:59:42 <mreh> my email password is always different from any login
01:59:55 <mm_freak> did the spam advocate the use of ocaml and F#?
01:59:57 <mm_freak> ;)
02:00:38 <gwern> no, advocated drugs
02:00:41 <gwern> just say no!
02:01:03 <mreh> illicit programming languages that give you a distorted sense of competency
02:02:43 <cheater99> hello haskell!
02:03:24 <mm_freak> > "hello"
02:03:25 <lambdabot>   "hello"
02:03:34 <mm_freak> > h e l l o
02:03:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:03:36 <lambdabot>    `GHC.Show.Show a'
02:03:36 <lambdabot>      a...
02:04:33 <mm_freak> :t h e l l o
02:04:34 <lambdabot> forall t. (SimpleReflect.FromExpr (Expr -> t)) => t
02:22:39 <dibblego> @djinn (a -> [a]) -> a -> Tee a
02:22:40 <lambdabot> Error: Undefined type []
02:22:41 <dibblego> @djinn (a -> [a]) -> a -> Tree a
02:22:41 <lambdabot> Error: Undefined type []
02:27:57 <dibblego> @type unfoldTree
02:27:57 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
02:28:26 <dibblego> @type \f -> unfoldTree (\k -> (k, f k))
02:28:27 <lambdabot> forall b. (b -> [b]) -> b -> Tree b
02:49:55 <mm_freak> is there any way i can help to restore haskellwiki?
02:52:00 <gwern> mm_freak: find the Seven Sages
02:55:45 <dibblego> @pl \ k -> (k, f k)
02:55:45 <lambdabot> ap (,) f
02:59:03 <mm_freak> seriously
02:59:13 <mm_freak> i could help write the stylesheet, for example
03:00:54 <Deewiant> dibblego: id &&& f
03:01:25 <dibblego> Deewiant, yep got that one, cheers
03:03:07 <quicksilver> mm_freak: I don't know, because I don't know who's doing the work.
03:03:25 <quicksilver> or "second f"
03:03:43 <dibblego> join (,) with second f
03:04:30 <RyanT5000> is there any way to use class contexts in RULES pragmas?
03:05:03 <RyanT5000> i'd like to do something like a rule that converts arr (const x) into arrowConst x whenever the result is in ArrowConst
03:06:34 <quicksilver> RyanT5000: you don't need to, AFAIK
03:06:48 <quicksilver> RyanT5000: the type checker means the rule will only get applied when the types match.
03:06:49 <RyanT5000> oh; it just won't make the substitution if it isn't legal, i guess
03:06:55 <RyanT5000> cool
03:07:01 <quicksilver> how's it all going RyanT5000 ?
03:07:03 <RyanT5000> this opens up all kinds of optimization possibilities :)
03:07:05 <RyanT5000> it's going great
03:07:08 <quicksilver> \o/
03:07:20 <RyanT5000> i'm doing some arrow fiddling right now, trying my hand at some improvements to Yampa
03:07:26 <RyanT5000> (we've forked it at this point)
03:07:44 <quicksilver> you're finding yampa performance a bottleneck?
03:07:51 <RyanT5000> no, Yampa features
03:07:59 <RyanT5000> we need some weird things :)
03:08:09 <RyanT5000> like speculative evaluation of signal functions
03:08:31 <RyanT5000> we evaluate them about 0.3 seconds ahead, and send a chunk of data to C land
03:08:46 <RyanT5000> that way, if we encounter a major GC and Haskell land comes grinding to a halt, our animation is still smooth
03:08:52 <RyanT5000> (this happens once every minute or two)
03:09:48 <RyanT5000> the RULES question was not specifically because performance is an issue, but because i was reading through the Yampa source and they mentioned const arrows in one of their comments as a possible future improvement
03:12:19 <RyanT5000> i must say, i've grown to like arrows much more than i expected to
03:12:37 <RyanT5000> though i've also grown skeptical of the whole "arrows-as-monads" idea
03:12:52 <RyanT5000> which breaks the symmetry of first f >>> second g
03:13:03 <RyanT5000> (which ought to be the same, imo, as second g >>> first f)
03:14:26 <chrisdone> what's the easiest way to use hoogle with all your installed packages?
03:14:55 <chrisdone> have a cabal haddock --hoogle && --convert && --merge script on every install?
03:15:47 <mm_freak> somehow i've never found much use for arrows other than simplifying pair functions
03:15:58 <RyanT5000> yeah, me neither, until i started on FRP stuff
03:16:05 <RyanT5000> (my company is writing a game using Yampa)
03:16:13 <mm_freak> i've never used FRP
03:16:43 <chrisdone> Hakyll web sites are composed using arrows, it's a perfect fit
03:16:46 <mm_freak> i tried to use Reactive, but i didn't know how to wrap my own graphics subsystem around it
03:16:51 <chrisdone> have a look at that if you're interested in uses of arrows
03:17:07 <mm_freak> (because i wanted SDL instead of GLUT)
03:17:26 <mm_freak> does yampa have the same problem?
03:17:38 <RyanT5000> mm_freak: not really; you write your own input and output functions
03:17:53 <RyanT5000> your arrows could even return IO actions if you want, and you could just run them when you get them out
03:18:33 <mm_freak> chrisdone: interesting library, thank you for that note
03:18:39 <mm_freak> r
03:18:48 <mm_freak> RyanT5000: sounds interesting, i'll give it a shot
03:18:55 <quicksilver> RyanT5000: interesting.
03:19:01 <RyanT5000> mm_freak: cool
03:19:28 <RyanT5000> quicksilver: the thing that is nice about Arrows for FRP stuff is that you actually get a lot of information about how the code is structured
03:19:37 <RyanT5000> e.g.: you get sharing information
03:19:42 <RyanT5000> (at least some of it)
03:19:45 <mm_freak> RyanT5000: is it suitable for games in terms of performance?
03:20:00 <quicksilver> RyanT5000: well, if you require first f >>> second g to equal second g >>> first f you're quite dramatically restricting the kind of "effect" you can be modelling.
03:20:08 <quicksilver> RyanT5000: it's always nice to have more equations, in some sense.
03:20:14 <RyanT5000> mm_freak: it seems to be; our game is for iPhone, and the performance problems don't come from Yampa
03:20:17 <quicksilver> (the diagrams actually "make sense" if that rule holds)
03:20:20 <RyanT5000> except that it's tricky with memory sometimes
03:20:34 <RyanT5000> quicksilver: yeah, i don't like the idea of arrows modeling effects
03:20:43 <RyanT5000> imo, the whole point of FRP is to get rid of effects
03:20:50 <quicksilver> well I use the phrase in a loose generic sense like Moggi's "computation"
03:21:00 <quicksilver> if there is no effect at all then you just have functions (by definition)
03:21:02 <RyanT5000> (and, as far as i can tell, the whole point of arrows is FRP :P)
03:21:06 <RyanT5000> yep
03:21:11 <quicksilver> the "effect" is whatever about your arrow makes it not just plain functions.
03:21:12 <RyanT5000> i have functions that i can peer inside of
03:21:23 <RyanT5000> which is all i really want
03:21:41 <quicksilver> yeah that's not really what arrows is.
03:21:52 <quicksilver> that's something which people like - but not arrows.
03:21:56 <RyanT5000> that's fair
03:22:17 <quicksilver> for example "functions which I can peer inside of" probably shouldn't have "arr"
03:22:23 <RyanT5000> well
03:22:26 <quicksilver> but, in some cases you have the opposite of "arr"
03:22:34 <quicksilver> "interpret" :: a ~> b -> a -> b
03:22:41 <RyanT5000> arr is necessary to bring in things that your limited function paradigm can't handle
03:22:49 <quicksilver> (I can turn my structure in a pure function by forgetting my introspection abilities)
03:22:57 <RyanT5000> for example, if you don't have ArrowChoice, but you want to use a case statement, you'll need arr
03:23:45 <RyanT5000> right
03:24:21 <quicksilver> You never have interpret if you have an effect-computation in the moggi sense.
03:24:45 <quicksilver> There is no "interpret :: (a -> IO b) -> a -> b
03:24:49 <RyanT5000> yeah; i'm sure you're right; to be honest i haven't read anything about arrows outside of the FRP context
03:24:54 <quicksilver> or indeed (a -> Maybe b) -> a -> b
03:25:06 <quicksilver> the only other context I've used arrows is as parsers/transformers
03:25:19 <quicksilver> for selecting and transforming parts of tree structures
03:25:33 <quicksilver> (and combining multiple selection/transformations)
03:25:42 <RyanT5000> however, i think that FRP should probably use sequential things about as frequently as most programs use unsafePerformIO
03:26:16 <RyanT5000> and for similar reasons - something that ends up behaving like a nice FRP thing, but for some reason can't be implemented that way
03:26:25 <RyanT5000> anyway, i don't think arrows are ideal for FRP
03:26:39 <RyanT5000> but they're the easiest way i'm aware of to allow people to expose the necessary info to the FRP system
03:27:02 <quicksilver> I still think I like Reactive
03:27:11 <RyanT5000> yeah; does it work yet?
03:27:12 <quicksilver> but I haven't had the time to continue my experiments with it.
03:27:18 <quicksilver> my version does, yes.
03:27:33 <RyanT5000> last i heard, it had extremely unmanageable performance - but that was almost a year ago
03:27:37 <quicksilver> and it doesn't use unamb or any unsafePerformIO at all behind the scenes.
03:27:45 <RyanT5000> hm; that's cool
03:27:47 <quicksilver> but it probably does fail in some cases.
03:27:54 <quicksilver> I haven't had time to keep experimenting/understanding
03:28:00 <quicksilver> there are certainly challenges to avoid space leaks.
03:28:13 <RyanT5000> yeah; that's true in yampa as well
03:28:23 <RyanT5000> i forget: does reactive have its own concept of time?
03:28:40 <quicksilver> my implementation uses a very concrete time type (UTCTime) explicitly.
03:28:43 <RyanT5000> (aside from "anything that's in Ord")
03:28:48 <RyanT5000> ah
03:28:50 <quicksilver> conal's is actually parameterised over a time type
03:28:54 <quicksilver> btu I couldn't be bothered with that.
03:28:55 <RyanT5000> that's cool
03:29:01 <quicksilver> I was writing computer games, I wanted concrete time
03:29:06 <RyanT5000> well, in our game we have two times, which we need to keep separate
03:29:07 <quicksilver> so I could say (make this happen once a second)
03:29:18 <RyanT5000> and right now our approach is just to keep the FRP system out of it
03:29:30 <RyanT5000> we have the realtime clock and the game clock
03:29:35 <RyanT5000> when you pause, obviously, those two are not in sync
03:29:54 <quicksilver> oh yes, quite different, I agree.
03:29:59 <RyanT5000> and even when the game's playing, then synchronization is not guaranteed (you need a control system to do that)
03:30:04 <quicksilver> real time is for frame rate and animations
03:30:07 <quicksilver> it's not "game clock"
03:30:12 <RyanT5000> exactly
03:30:14 <quicksilver> the game clock is a Behaviour which can be altered
03:30:17 <quicksilver> (e.g. by a pause)
03:30:36 <quicksilver> but I did get interpolated frames
03:30:37 <mm_freak> i'd probably use Float as time
03:30:42 <RyanT5000> well, honestly, i don't see what FRP is really getting out of having a built-in time type anyhow
03:30:46 <quicksilver> so my game model was only updating 10 times a second
03:30:57 <quicksilver> and my 60fps frames were interpolated 
03:31:05 <RyanT5000> yeah
03:31:06 <quicksilver> was quite pleased with that.
03:31:12 <RyanT5000> that's cool
03:31:22 <quicksilver> and if it slows down the framerate drops not the game model
03:31:27 <quicksilver> well, until the whole thing implodes.
03:31:31 <RyanT5000> yeah
03:31:54 <RyanT5000> anyway, i must get back to my arrow hackery
03:31:58 <quicksilver> enjoy.
03:32:03 <RyanT5000> i will :)
03:32:04 <mm_freak> quicksilver: that's one of the things, why i want to use SDL instead of GLUT
03:32:05 <quicksilver> let me know when you release somethign so I don't forget to buy it.
03:32:11 <RyanT5000> definitely
03:32:16 <quicksilver> mm_freak: why's that?
03:32:17 <RyanT5000> i'll be yelling from the treetops :)
03:32:23 <mm_freak> for example SDL has this neat getTicks computation
03:32:31 * quicksilver shrugs
03:32:31 <mm_freak> and real event management
03:32:34 <quicksilver> trivial to do yourself.
03:32:52 <quicksilver> IMO the main reason to use SDL is that it has better keyboard/mouse event support.
03:33:03 <mm_freak> yes
03:33:13 <quicksilver> glut's timers are adequate, in fact.
03:33:14 <mm_freak> and better window handling
03:33:15 <chrisdone> http://gist.github.com/478215 -- you can have that one for free
03:33:45 <quicksilver> windows, who needs them? :)
03:33:56 <quicksilver> SDL's image loading is handing too, and the font stuff.
03:34:02 <quicksilver> s/handing/handy/
03:34:08 <quicksilver> althoguh technically different libraries.
03:34:19 <mm_freak> that's not that handy in haskell, and you need more libraries
03:34:38 <mm_freak> and SDL surface can't be converted to an OpenGL texture easily in haskell
03:34:45 <alpounet> maybe having an higher level API with that SDL backend could be nice
03:38:59 <quicksilver> mm_freak: SDL surface can be converted extremely easy to opengl texture
03:39:07 <quicksilver> mm_freak: it's two lines of code. Or one. Or something.
03:39:27 <quicksilver> just a question of getting the pixel format right.
03:39:43 <Jafet> It's not a conversion. It only works if SDL uses OpenGL, and if it does you can directly access the pixel buffer
03:40:31 <Jafet> Nevermind, s/^.*$//m
03:40:40 <mm_freak> quicksilver: and how do i extract the pixels?
03:40:49 <mm_freak> or how do i get a Ptr to the pixels?
03:40:53 <mm_freak> that's what opengl needs
03:45:16 <quicksilver> mm_freak: surfaceGetPixels, or something like that?
03:47:44 <quicksilver> yes, surfaceGetPixels returns a Ptr to the pixel data
03:48:47 <deteego> has anyone here used flex/lex to make a parser file?
03:49:09 <mm_freak> quicksilver: surfaceGetPixels :: Surface -> IO Pixels
03:49:12 <deteego> I was just wondering if its possible to make comments in the same section where you define the tokens
03:49:19 <mm_freak> Pixels is an opaque type
03:49:19 <quicksilver> mm_freak: yes, and Pixels is just a type alias for a Ptr
03:49:29 <quicksilver> it's not, it's a type alias, they're never opaque
03:49:44 <mm_freak> then something's wrong with the haddock documentation
03:49:49 <quicksilver> mm_freak: you can see working example code in luqui's DrawingCombinators
03:49:50 <mm_freak> because Pixels is not a link
03:49:54 <quicksilver> mm_freak: yes, it's a haddock bug.
03:50:03 <quicksilver> haddock doesn't realise that type aliases are never opaque.
03:50:10 <quicksilver> mm_freak: http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/0.3/doc/html/src/Graphics-DrawingCombinators.html
03:50:23 <quicksilver> search for 'surfaceToSprite' in that code
03:50:41 <quicksilver> which even makes some effort to match the pixel format
03:52:04 <mm_freak> well, with that i can just use ConvertSurface
03:52:07 <mm_freak> great
03:52:08 <mm_freak> thank you
03:52:12 <quicksilver> luqui++ # graphics.drawingcombinators
03:52:12 <mm_freak> uhm
03:52:15 <mm_freak> convertSurface
03:52:55 <mm_freak> so i can use values of type Pixels, but cannot give them type signatures?
03:54:46 <quicksilver> mm_freak: Perhaps. I'm not sure in detail actually.
03:54:52 <quicksilver> type aliases are a bit odd.
03:55:28 <mm_freak> well, the type is not exported
03:59:11 <quicksilver> mm_freak: I'd do some experiments on the effect of exported types and partially unknown types and type aliases but I don't have time today :) My curiousity will have to remain un-sated.
03:59:20 <quicksilver> I just point at luqui's code which evidently compiled at least once.
04:00:15 <mm_freak> haskell has no weak types, has it?
04:03:09 <aristid> mm_freak: depends on how you define weak types
04:03:55 <mm_freak> aristid: surfaceGetPixels :: Surface -> IO Pixels
04:04:13 <mm_freak> now pixels is a hidden type alias, which is equal to Ptr something
04:04:37 <mm_freak> with a weak type 'a' i could write:  :t surfaceGetPixels :: Surface -> IO (Ptr a)
04:05:19 <aristid> surfaceGetPixels :: SomeClass a => Surface -> IO a?
04:05:25 * hackagebot graph-rewriting-gl 0.6 - OpenGL interface for interactive hypergraph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.6 (JanRochel)
04:05:27 * hackagebot graph-rewriting-lambdascope 0.4.6 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.6 (JanRochel)
04:05:29 * hackagebot graph-rewriting-ski 0.4.7 - Implementation of the SKI combinators as an interactive graph rewriting system  http://hackage.haskell.org/package/graph-rewriting-ski-0.4.7 (JanRochel)
04:07:19 <mm_freak> it still gives an error, but that error reveals what Pixels is
04:07:28 <mm_freak> :t surfaceGetPixels :: Storable a => Surface -> IO a
04:07:29 <lambdabot> Not in scope: `surfaceGetPixels'
04:07:29 <lambdabot>     Not in scope: type constructor or class `Storable'
04:07:29 <lambdabot>     Not in scope: type constructor or class `Surface'
04:07:35 <mm_freak>     Couldn't match expected type `a'
04:07:35 <mm_freak>            against inferred type `Ptr Graphics.UI.SDL.Types.PixelsData'
04:07:56 <ivanm> hmmm, so graph-rewriting uses a graph type that's just data Graph n = Graph {nodeMap ∷ IntMap n, edgeMap ∷ IntMap IntSet, nextKey ∷ Int}
04:08:02 <quicksilver> mm_freak: you don't want "a", because that's universal
04:08:06 <quicksilver> that means it works for ALL types a
04:08:15 <quicksilver> this works for some specific (but invisible to you) type
04:08:32 <ivanm> which looks like an undirected graph with node labels but no edge labels + that extra term nextKey...
04:08:45 <mm_freak> quicksilver: yes, i didn't expect it to work
04:08:55 <mm_freak> haskell doesn't seem to have weak types in that sense
04:09:33 <ClaudiusMaximus> ivanm: i guess nextKey could be eliminated by using either size.nodeMap or size.edgeMap as appropriate
04:09:44 <ClaudiusMaximus> or something?
04:09:50 <ivanm> yeah
04:09:53 <ivanm> depends upon what it means
04:10:07 <ivanm> if it's the next one to be used in the graph-rewriting stuff, then no, it can't ;-)
04:10:19 <ivanm> but if it means the next available key, then yeah, seems like an odd choice
04:11:37 <quicksilver> mm_freak: well it hasn't existential types but you can't unify with them directly.
04:11:45 <mm_freak> quicksilver: but somehow in the error message the underlying type was given instead of the type alias
04:12:55 <jimt> ?
04:14:20 <ClaudiusMaximus> ah, if it's rewriting then maybe maxKey would be better than size if it's next available key
04:14:28 <ClaudiusMaximus> because nodes might disappear
04:39:48 <Saizan> mm_freak: definitions made with "type" are completely transparent, you should use newtype if you don't want that
04:52:13 <gwern> preflex: seen dons
04:52:14 <preflex>  dons was last seen on #haskell 5 hours, 30 minutes and 45 seconds ago, saying: well, after it is accepted.
04:52:44 <gwern> @ask dons I noticed in your thesis you link to the old unsw.edu webpage for lambdabot; is this deliberate to link to the old code which used hs-plugins?
04:52:44 <lambdabot> Consider it noted.
04:52:47 <gwern> @flush
04:52:53 <roconnor> hey gwern
04:53:19 <deteego> "any ring of characteristic zero with inverses for integers and a notion of limit"
04:53:24 <deteego> can anyone summerize that in one word
04:53:41 <ivanm> he came, he @asked and he left
04:53:45 <ClaudiusMaximus> "huh"
04:53:53 <ivanm> Deewiant: "fleegelboo"
04:53:55 <roconnor> deteego: does that include p-adics?
04:54:19 <ivanm> s/Deewiant/deteego/
04:55:04 <deteego> roconnor: dont think so, its the exponent used for **
04:55:19 <CalJohn_> Is there any good tracer for haskell?  I have been trying ghci's :history feature, but it seems not to work most of the time.  Hat looks very old.
04:55:28 <deteego> im just making a haskell lexer and I am thinking of the word to use for that token
04:55:29 <roconnor> deteego: I can't think of anything other than the reals
04:55:50 <deteego> yeah real will do fine
04:55:59 <deteego> doesn't have to be 100% correct
04:56:19 <ivanm> CalJohn_: Debug.Trace ? :p
04:56:23 <roconnor> a ring of characteristic 0 with inverses for (non-zero) integers contains the rationals
04:56:30 <ivanm> Hat isn't that old, but IIRC it needs YHC
04:56:44 <roconnor> throw in limits and it is a ring that contains the reals
04:56:56 <roconnor> I guess it could be bigger than the reals, say the complex numbers, etc.
04:57:13 <deteego> http://www.haskell.org/haskellwiki/Power_function
04:57:17 <deteego> well thats where it came from
04:57:37 <deteego> but reals will have to do, im not having an enum type that takes up a whole line =D
04:57:50 <malcolmw> Hat last saw any serious implementation work back in 2002.  It predates YHC by quite some margin.
04:58:28 <roconnor> deteego: you could call it a complete field.
04:59:21 <deteego> roconnor: eh reals is nicer
04:59:26 <deteego> thanks for the help
04:59:35 <roconnor> oh wait, it doesn't have to be a field
04:59:42 <roconnor> :)
04:59:44 <roconnor> ok
05:03:24 <Tomsik> integer-inversion limit ring :p
05:05:50 <quicksilver> Saizan: The question is whether definitions with type are transparent even if they are exported (apparently so)
05:06:16 <quicksilver> Saizan: and the second question is, if type Foo = Ptr Bar, where Bar is *not exported*, can client code still unify Foo with Ptr a?
05:06:19 <quicksilver> (apparently yes)
05:06:40 <quicksilver> apparently Ptr <type I cannot name> still matches Ptr a
05:07:34 <dolio> Hugs has an extension to prevent that, as I recall.
05:07:48 <Saizan> that seems the sanest alternative to me, though i can see why it might be surprising
05:08:26 <quicksilver> hmm. in my first question s/are exported/are *not* exported/
05:08:42 <kmc> Hugs has an extension to make a synonym transparent in some code and opaque everywhere else
05:08:46 <quicksilver> i.e. it seems you don't need to list type aliases in your export list they're still effectively exposed + transparent
05:08:49 <Saizan> ah, my brain auto-corrected that :)
05:09:21 <quicksilver> kmc: ISTR there is a reason that's actually not possible in GHC.
05:09:37 <quicksilver> I think it conflicts with System FC
05:09:52 <quicksilver> which needs to have a conservatively accurate view on when two types are distinct
05:09:55 <quicksilver> for separate compilation to be sound.
05:10:23 <quicksilver> the case when two types are apparently distinct (because they are both opaque) but actually the same is a soundness problem.
05:10:26 <quicksilver> I think.
05:10:53 <quicksilver> I'm pretty sure it conflicts with type instances, but I think it is more fundamental than that.
05:11:01 <quicksilver> (family instances)
05:13:00 <ManateeLazyCat> bug tracker's username/password is same as i use for upload cabal package?
05:14:06 <ManateeLazyCat> Looks server refuse my username/password
05:14:23 <ivanm> nope
05:14:30 <ivanm> you need to get a new username/password
05:14:36 <ivanm> for each trac instance :@
05:14:48 <ManateeLazyCat> ivanm: Where i can register it?
05:14:53 <ivanm> at the trac
05:15:00 <ivanm> quicksilver: what isn't possible in GHC?
05:15:40 <CalJohn_> ivanm: yeah, I've already used something like Debug.Trace.trace but it's not really feasible for my case
05:15:42 <ManateeLazyCat> ivanm: How can i close ticker? I must login it?
05:15:49 <ivanm> yeah
05:15:52 <ManateeLazyCat> ivanm: First use hackage's bug ticker
05:16:00 <ManateeLazyCat> s/fist/first time
05:18:21 <ManateeLazyCat> ivanm: Where i can *close* ticker?
05:18:36 <ivanm> you have to be an owner of a ticket to close it AFAIK
05:21:53 <ManateeLazyCat> ivanm: Sorry i don't know how to change owner, i use guest/gtk2hs login in. 
05:22:49 <ivanm> well, you have to be the registered as one of the maintainers for that project IIRC
05:23:12 * ManateeLazyCat Damn....
05:27:59 <ManateeLazyCat> How to register as maintainer for close ticker in bug track?
05:28:25 <ManateeLazyCat> I need external tool?
05:28:30 <Saizan> it's "ticket" btw
05:29:12 <Saizan> and you generally can't, another maintainer could make you a maintainer as well though
05:29:55 <ManateeLazyCat> Saizan: So i can get a new adminName/adminPassword from another maintainer?
05:30:03 <ManateeLazyCat> Saizan: Then i can close ticker at http://hackage.haskell.org/trac/gtk2hs/ticket/1170 ?
05:31:27 <arch1> Hello to all 
05:31:28 <arch1> I've a question regard :
05:31:28 <arch1>    chap-8) Making Our Own Types and Typeclasses
05:31:28 <arch1>    
05:31:28 <arch1> of online tutorial 
05:31:28 <arch1> 	http://learnyouahaskell.com
05:31:30 <arch1> .....................................
05:31:32 <arch1> .....................................
05:31:34 <arch1> class Tofu t where  
05:31:36 <arch1> 	tofu :: j a -> t a j  
05:31:40 <arch1> let's look at what its kind would have to be
05:31:42 <arch1> Because j a is used as the type of a value that 
05:31:44 <arch1> the tofu function takes as its parameter,
05:31:46 <arch1> j a has to have a kind of *
05:31:48 <arch1> question:
05:31:50 <arch1> why j a has to have a kind of * ?
05:31:52 <arch1> they are not two distinct type ?
05:31:54 <arch1> We assume * for a and so we can infer that j has to have a kind of * -> *.
05:31:56 <arch1> question:
05:31:58 <arch1> why infer:
05:32:00 --- mode: ChanServ set +o Saizan
05:32:00 <arch1>    'that j has to have a kind of * -> *.' 
05:32:02 <arch1>    
05:32:03 --- mode: Saizan set +b *!*arch1@217.171.162.*
05:32:03 <kmc> arch1, don't paste big blocks of text into the channel
05:32:17 <kmc> you can upload your text to hpaste.org
05:32:35 <Saizan> arch1: i'll unban you in a short while, when the flood stops :)
05:32:42 <Saizan> (hopefully)
05:33:16 <Saizan> ManateeLazyCat: yeah
05:33:28 --- mode: Saizan set -b *!*arch1@217.171.162.*
05:33:43 <ManateeLazyCat> Saizan: Ok, thanks, i will request adminName/adminPassword from Axel.
05:33:47 <kmc> arch1, «j a» has kind * because all types do.  things with kind other than * are properly called type constructors, not types
05:34:00 <kmc> and so if T appears as the argument type of a function, it has kind *
05:34:09 <Saizan> ManateeLazyCat: you should ask for your own account with admin priviliges
05:34:17 <kmc> you can't write a function «Maybe -> Char», because Maybe does not have kind *.
05:34:35 <kmc> you can write «Maybe Bool -> Char» or «Maybe a -> Char»
05:34:42 --- mode: Saizan set -o Saizan
05:35:00 <ManateeLazyCat> Saizan: Thanks, i see. :)
05:35:01 <vanadium> Both sound relatively boring
05:36:41 <chrisdone> alright, i don't wanna type import Network.FastCGI ever again
05:37:01 <chrisdone> i want to type main = runFastCGI and then emacs uses Hoogle to know what to import
05:37:16 <chrisdone> anyone made any headway on this?
05:37:47 <ivanm> can't use hoogle unless you have it index all the packages on your system
05:37:52 <ivanm> hayoo might work
05:37:57 <ivanm> problem is matching definitions
05:38:30 <ivanm> e.g. if you use foldr, should it use Prelude.foldr or Data.Foldable.foldr ?
05:38:36 <chrisdone> ivanm: ya that's what i'm talking about. hoogle's db will need to be added to when packages are installed
05:38:41 <chrisdone> ivanm: well that's easy, it can just ask you
05:38:47 <ivanm> I suppose
05:38:59 <ivanm> I don't know of anyone that's done that though
05:39:20 <chrisdone> it's a two stage problem the second of which is easy
05:39:37 <chrisdone> (1) index all installed packages, (2) write a bit of elisp to integrate it
05:39:54 <Ke> elisp o_O
05:39:55 <chrisdone> maybe i could whip something up to go through all packages in .cabal and run cabal haddock --hoogle
05:40:08 <chrisdone> then merge with a main hoogle database in .cabal somewhere
05:41:15 <ivanm> chrisdone: cabal haddock --hoogle
05:41:23 <ivanm> oh, you said that
05:41:24 <chrisdone> ivanm: what about it?
05:41:29 <chrisdone> hayoo can provide extra results for when you don't have it installed
05:41:29 <ivanm> you can probably make it a default
05:41:57 <ivanm> does hoogle provide an API?
05:42:03 <ivanm> or would it just be text mangling?
05:42:17 <chrisdone> for what?
05:42:28 <chrisdone> hoogle has a command-line, you know right?
05:42:34 <Saizan> some guy was working on making cabal-install keep an hoogle index.. never heard from him again
05:42:35 <chrisdone> hoogle 'a -> a'
05:43:15 <ivanm> chrisdone: yes, I know; but if it had a library version then you could have a Haskell helper script to do the hard work for you
05:43:17 <chrisdone> Saizan: ah. does sound like patching cabal-install would be the solution
05:43:20 <ivanm> rather than elisp
05:43:30 <chrisdone> ivanm: what hard work?
05:43:37 <ivanm> Saizan: well, someone was working on having cabal-install have an actual package index AFAIK
05:43:42 <ivanm> akin to gentoo's world file
05:43:52 <Saizan> that was orthogonal :)
05:43:54 <ivanm> chrisdone: the lookup, pick a version, etc.
05:43:57 <ivanm> Saizan: aha
05:44:27 <chrisdone> ivanm: the lookup is trivial. pipe hoogle. the choice is trivial. ido-completing-read
05:44:49 <ivanm> chrisdone: put it this way: would you rather do stuff in Haskell or elisp? :p
05:44:56 <ivanm> but yeah, using ido would make it nicer
05:45:06 <chrisdone> ivanm: well, considering i'm using emacs and not yi, i'd rather use elisp..
05:45:26 <ivanm> heh
05:45:29 <ManateeLazyCat> chrisdone: ido with hoogle ?
05:45:40 <chrisdone> no, ido in emacs
05:45:47 <ivanm> chrisdone: hoogle mangling would also require verifying that the chosen function is the one selected
05:46:13 <ivanm> also, how would emacs know where to put the import statement?
05:46:24 <ManateeLazyCat> chrisdone: Icicles is better than ido, i use anything.el
05:46:28 <chrisdone> ivanm: where to put the import is solved
05:46:32 <Saizan> chrisdone: Distribution.Client.Haddock is how the haddock index is kept, but that's "simpler" because "ghc-pkg describe" has haddock-interface/haddock-html fields :)
05:46:34 <chrisdone> ManateeLazyCat: that's your opinion. i prefer ido
05:46:46 <ManateeLazyCat> chrisdone: Yep.
05:46:58 <ivanm> ManateeLazyCat: well, anything /= icicles anyway ;-)
05:47:15 <ivanm> chrisdone: how is it solved?
05:47:17 <ManateeLazyCat> ivanm: I know, anything.el is more friendly sometimes. :)
05:47:28 <chrisdone> ivanm: i already wrote some elisp functions to take me to the import list
05:47:34 <ivanm> fair enough
05:47:48 <Saizan> chrisdone: uuuh, that should go into haskell-mode
05:48:00 <ivanm> we really need to either update the emacs section on the wiki or have Baughn but a list of related packages on the haskellmode-emacs site
05:48:06 <chrisdone> i sent some code to the haskell-mode maintainer, didn't hear anything back
05:48:34 <ivanm> preflex: seen Baughn 
05:48:34 <preflex>  Baughn was last seen on #haskell-blah 7 days, 20 hours, 22 minutes and 7 seconds ago, saying: http://sites.google.com/site/redcodenl/ <- This scares me. If patent holders are going to start coming after minor software writers, we're in for a rough ride.
05:48:35 <chrisdone> he intends on using haskell-src-exts for everything for haskell-mode, so i don't think anything i write will make it into haskell-mode
05:48:40 <ivanm> huh
05:48:53 <Saizan> ah, makes sense
05:49:07 <chrisdone> yeah, it's the logical way to go
05:49:14 <arch1> kmc : i am confused : my problem is the row :    tofu :: j a -> t a j   ; the j a  is a function j applied to  type a or two datatype distinct
05:49:22 <ivanm> except for those "but then it can't become part of emacs!!!" people...
05:49:34 <chrisdone> i don't know how he'll get around syntax errors but it might be trivial
05:49:36 <ivanm> arch1: that type signature doesn't make sense
05:49:47 <ivanm> chrisdone: parsing fragments? *shrug*
05:50:09 <chrisdone> http://gist.github.com/453933
05:50:22 <chrisdone> ^ here's some code to align the imports in your import list up
05:51:27 <ivanm> chrisdone: yeah, that won't work in general... I have a rather long explicit import list... (explicit hiding, that is)
05:53:15 <arch1> ivanm : the signature is the signature of Instance Tofu t where ..... i have problem for the next stmt  : tofu :: j a -> t a j  : the kind is not clear!
05:53:29 <chrisdone> ivanm: how long is long?
05:53:34 <chrisdone> http://pastie.org/1047113
05:53:50 <ivanm> arch1: exactly, that's what I meant by it not making sense
05:54:01 <chrisdone> oh, if you're using `hiding` then my code isn't aimed at you
05:54:04 <ivanm> unless you're doing edwardk's weird co-induction stuff or something
05:54:06 <ivanm> chrisdone: heh
05:54:08 <chrisdone> this is specifically for people who adhere to tibbe's guide
05:54:27 <ivanm> chrisdone: I'm importing the prelude but hiding everything that is list oriented ;-)
05:56:24 <chrisdone> import qualified Prelude
05:57:01 <chrisdone> it's surprising how little of the prelude is required from module to module
05:57:34 <arch1> ivanm : but then why was the example has say
05:58:26 <tibbe> chrisdone: you called? :)
05:58:29 <ivanm> arch1: sense, your question does not make
05:58:30 <ivanm> ;-)
05:58:40 <ivanm> tibbe: just to mention you in passing ;-)
05:58:50 <ivanm> chrisdone: well, I'm going to be re-exporting the rest of it...
06:02:21 <chrisdone> tibbe: have you done any work on fully indexing all installed packages with Hoogle for some nice emacs intellisense?
06:02:36 <tibbe> chrisdone: no, although it would be nice
06:03:09 <tibbe> chrisdone: import chasing would be cool too
06:03:30 <ivanm> what do you people think about this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27630#a27630
06:04:02 <ivanm> I still need to do something analogous to ListLike building off this (not sure what to call it; Sequence?) and a Lookup class, as well as the actual instances
06:06:25 <ManateeLazyCat> If anyone know how to add account for "bug tracker", please let me know. I have search some time, bad luck...
06:07:50 <noteed> ivanm: you should start a poll about how the ocaml poll should be written :)
06:07:57 <ivanm> heh
06:08:15 <ivanm> well, the reason I wrote that email is that I went to answer the first question... and had no idea how to answer it ;s
06:08:20 <ivanm> s/;s/:s/
06:08:44 <kmc> arch1, assume «a :: *».  we know «j a :: *» because it's used as a type, so then «j :: * -> *».  likewise «t a j :: *» so «t :: * -> (* -> *) -> *»
06:08:57 <kmc> arch1, but i'm not sure why you're allowed to assume «a :: *» in the first place
06:09:01 <noteed> ivanm: the simplest it to provide the granularity of the questions
06:09:19 <kmc> there are some places where kinds are assumed to be * unless specified otherwise
06:09:45 <chrisdone> kmc: argh what are you doing with the quotes. it's unreadable
06:10:02 <kmc> chrisdone, they're guillemets
06:10:10 <dabd> is there anything you can do with the ML module system that is difficult to do in Haskell?
06:10:17 <kmc> do you not have working Unicode and UTF-8 support?
06:10:28 <chrisdone> i wish i didn't
06:10:43 <ivanm> dabd: a module-level API?
06:10:53 <kmc> dabd, parametrized modules
06:11:17 <kmc> chrisdone, what's your objection?
06:13:15 <wli> dabd: I don't know if there's some easy answer out there, but sharing constraints sound plausibly in that area.
06:13:24 <ddarius> kmc: The Report says to assume * when ambiguity arises.  The most general kind would be: t :: forall k. k -> (k -> *) -> * and j :: forall k. k -> *
06:13:45 <dabd> what about this http://lambda-the-ultimate.org/node/224?
06:13:57 <kmc> ok, makes sense
06:14:05 <ivanm> hey edon 
06:14:06 <ivanm> grrr
06:14:09 <ivanm> hey edwardk 
06:14:13 <edwardk> =)
06:14:40 <ivanm> waddaya think of this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27630#a27630
06:14:44 <edwardk> you ever come to a conclusion based on your straw poll?
06:15:15 <ivanm> I said I'd leave it till next weekend
06:15:31 <edwardk> ah
06:15:33 <arch1> kmc : thank for help  : my problem is not only study haskell from 6/7 day but english  anyway thanks for trying to make me understand the concept;
06:16:57 <chrisdone> kmc: personally i find them too distracting to be helpful
06:17:47 <arch1> kmc : ok understood: many many thanks
06:18:22 <ivanm> edwardk: 64 responses, some of which are IMHO rather stupid (someone saying they have no opinion, another saying it should be fgl6, etc.)
06:18:23 <edwardk> ivanm: well, i think it probably runs into the same issues as many of the old edison containers, but it can probably be applied across a reasonably wide array of set/list-like types
06:18:33 <defn> Who here actually uses Yi?
06:18:37 <ivanm> edwardk: what issues precisely?
06:18:38 <defn> Who here actually uses Yi?
06:18:45 <chrisdone> okay, i enabled cabal-install's Documentation setting, that's a good start
06:18:49 <defn> whoa my buffer is off, sorry all
06:18:55 <ivanm> so far, inductive-graphs has 59% of the vote
06:18:55 <edwardk> not yet fully awake, but hrmm. 
06:19:29 * ivanm really should sit down and split that up into "actually does graph stuff" and "someone who doesn't use graph stuff but has an opinion"
06:20:10 <edwardk> for one, everything involved in the class signature has kind *, which is good since it can cover things like bytestring, etc. but annoying because you can't say some of the things you can say with Foldable, Functor, etc.
06:20:28 <ivanm> edwardk: I've made a few changes since I uploaded that paste; main one is that elem now has a sensible definition and so you don't have to specify one of elem/notElem
06:20:47 <ivanm> edwardk: yeah, unfortunately you can't just use pre-existing stuff automatically
06:21:13 <edwardk> another is, that if you don't know the asymptotic complexity of something it is very hard to use a generic interface like this wisely.
06:21:23 <ivanm> edwardk: I was originally going to use RFunctor from Heffalump's rmonad library for the CFunctor class, but that was just for the definition of map which I could provide a default one internally anyway
06:21:29 <edwardk> i.e. sure, you can cons or 'insert' into a bytestring, but if you do so on a regular basis you are done for
06:21:46 <ivanm> and not many types seemed to have instances for it anyway
06:21:57 <ivanm> edwardk: oh, I'm not claiming they'll all be _sensible_ for all types
06:22:08 <ivanm> but this means it'll be less work to switch from a list to a Seq
06:22:25 <edwardk> well, that is the argument in favor of the edison typeclasses, listlike, etc.
06:22:26 <ivanm> and that libraries can export generic container types rather than hard-coding them to be a list or something
06:22:31 <ivanm> right
06:22:56 <edwardk> but there is something pretty rough about the fact that you can have vastly different asymptotics and support says nothing at all about efficient support.
06:23:07 <ivanm> edison seems to have gone a bit overboard though IMHO, and listlike doesn't have the hierarchy
06:23:16 <ivanm> as you read in my blog post ;-)
06:23:24 <edwardk> another annoyance i would have to say is that there are no laws relating insert with the semantics of _where_ the object gets inserted
06:23:28 <ivanm> edwardk: yes, unfortunately that is one of the trade offs
06:23:45 <noteed> ivanm: the fact Martin Erwig has given maintership to someone else *and* said he prefer the fgl name is quite important imho
06:23:54 <ivanm> edwardk: I won't be able to enforce it, but I will specify in the documentation that for those types that will also be isntances of my listlike-analogue class, insert = cons
06:24:01 <ivanm> noteed: yup
06:24:24 <ivanm> and when someone emailed him asking about porting FGL to OCaml, he also mentioned to them (and CC'd me) that we were working on new cool stuff
06:24:28 <edwardk> e.g. the most likely implementation using list would just cons, but for sets/maps you'd want to insert at the position specified by the element or by the first element of a key value pair, etc.
06:24:48 <edwardk> plus the semantics of what insert does with duplicates is peculiar to each container
06:24:53 <quicksilver> ivanm: (what GHC can't do) support an extension which makes non-exported type aliases opaque.
06:24:53 <ivanm> yeah
06:24:56 <quicksilver> I could be wrong, though.
06:25:05 <ivanm> edwardk: none of this is perfect, I'll admit
06:25:10 <edwardk> so you can't write code that is polymorphic in the instance and have it have sensible behavior over a wide-array of container classes
06:25:27 <edwardk> ivanm: *nods*. you asked what the issues were. i'm just braindumping ;)
06:25:28 <ivanm> but I think that something like this would be nice to help you design your code, then you can profile different types and choose oen that's best for you
06:25:34 <ivanm> edwardk: yeah, and I appreciate it
06:25:42 <ivanm> quicksilver: hmmm...
06:25:52 * ivanm should hit the sack
06:26:11 <chrisdone> is it possible to pass additional haddock options to cabal install?
06:26:16 <ivanm> edwardk: overall though, waddaya think of the API and default definitions?
06:26:27 <edwardk> ivanm: my honest approach for rapid prototyping is import Data.Foo (Foo); import qualified Data.Foo as Foo
06:26:30 <ivanm> chrisdone: only what "cabal haddock --help" specifies AFAIK
06:27:01 <ivanm> edwardk: right, but then since you're not guaranteed that Foo and Bar have a similar API, it will still requier change
06:27:07 <ivanm> more obvious change, maybe, but still change
06:27:28 <edwardk> ivanm: sure, just saying how i do it now =)
06:27:32 <ivanm> yeah ;-)
06:27:47 <ivanm> edwardk: but really, IMHO the "killer app" for this is for use in libraries
06:27:48 <edwardk> plus it avoids potentially expensive dictionary construction =P
06:28:16 <ivanm> e.g. both Cale and tomberek have expressed to me that they think a graph library should have the option of both a Set and list output from functions
06:28:17 <edwardk> (since i very well may have to construct one for each value type, given that everything there had kind *)
06:28:23 <ivanm> edwardk: yeah, there will be that overhead
06:28:57 <ivanm> I was initially using associated types, but due to superclass constraints not working it made the CFunctor-based type sigs fuglier
06:29:09 <edwardk> and while i like the idea for benchmarking, the problem is that by going through the dictionary, i'll have pissed away the inlining opportunities that i'd want to benchmark in the first place
06:29:16 <ivanm> edwardk: true
06:29:25 <ivanm> didn't think about that
06:29:34 <ivanm> but do you really INLINE up-front like that?
06:29:40 <ivanm> or do you mean automatic INLINEing by GHC?
06:29:49 <edwardk> automatic inlining by ghc
06:30:10 <ivanm> *nod*
06:30:11 <edwardk> when my client code is monomorphic, ghc can have a field day.
06:30:16 <ivanm> @time
06:30:18 <lambdabot> Local time for ivanm is Fri Jul 16 23:29:53
06:30:27 <Saizan> this sounds like a task for mlton.
06:30:36 <edwardk> Saizan: or supero ;)
06:30:42 <edwardk> or one of my crazy jits
06:30:51 <ivanm> edwardk: oh, I typically don't change data structures either, it was just another possible use for this type of library
06:31:05 <ivanm> but the big thing for it is genericity in what something can return
06:31:16 <ivanm> we'll see how it goes in practice anyway
06:31:17 <edwardk> ivanm: *nods* just giving the laundry list of reasons why a generic interface like this hasn't evolved and been adopted yet
06:31:36 <edwardk> personally i'd like to see something less monolithic
06:31:36 <ivanm> edwardk: apart from bikeshedding? :p
06:31:46 <edwardk> (speaking of bikeshedding) =)
06:31:52 <cuba> why does this uglyness not run? http://pastebin.com/qvZPgweh
06:31:59 <ivanm> edwardk: in terms of smaller classes, or more classes?
06:32:08 <edwardk> both =)
06:32:29 <ivanm> I wasn't originally going to have that class be so big, but everything in there is something that could be done by just about any generic "Container" type that I could think of
06:32:38 <quicksilver> cuba: because "/" is not an operator on Ints.
06:32:40 <edwardk> i think the criticisms and benefits that apply to STL-style code all apply here
06:32:43 <ivanm> note that only 3 methods need explicit definitions
06:32:49 <quicksilver> cuba: try `div`
06:32:51 <ivanm> edwardk: never had to use STL ;-)
06:33:27 <cuba> sum and length both return Int quicksilver 
06:33:37 <ivanm> I could take more of those definitions outside the class...
06:33:40 <exDM69> cuba: yeah, and you can't (/) ints
06:33:41 <ivanm> cuba: that's his point
06:33:46 <ivanm> @type (/)
06:33:47 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:33:50 <ivanm> @instances Fractional
06:33:50 <lambdabot> Double, Float
06:33:51 <ivanm> @type div
06:33:52 <lambdabot> forall a. (Integral a) => a -> a -> a
06:33:55 <edwardk> the STL in C++ provides a framework for algorithm reuse in the context of just a few underlying types of iterators, but ultimately, you do need to understand the underlying container type to fully reason about the semantics of what happens to your iterators under mutation, etc.
06:33:57 <ivanm> @instances Integral
06:33:58 <lambdabot> Int, Integer
06:34:10 <ivanm> edwardk: *nod*
06:34:17 <ivanm> so, do you think I'm wasting my time then?
06:34:20 <exDM69> edwardk: also, iterators are not really composable
06:34:21 <edwardk> less of a problem here in the world of explicit mutation
06:34:25 <edwardk> exDM69: yeah
06:34:56 <quicksilver> cuba: Yes. But "/" does not accept them.
06:35:08 <quicksilver> cuba: "/" is your problem, because it is not an operator on Ints.
06:35:10 <edwardk> ivanm: well, i think honestly you might have some luck modeling the input and output iterator (or more likely range) concept from the STL, than directly modeling the container itself.
06:35:11 <quicksilver> `div` is.
06:35:23 <edwardk> ivanm: that'd let you express a lot of generic algorithms
06:35:26 <kmc> cuba, or you can convert Int to a fractional type with fromIntegral
06:35:34 <cuba> thanks
06:35:39 <exDM69> @type fromIntegral
06:35:40 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:35:53 <ivanm> edwardk: *sigh* so you think I'm on the wrong track?
06:36:19 <ivanm> I'm guessing that the iterators are something analogous to fold in that it spits out all the values one at a time (e.g. a toList function) ?
06:37:11 <edwardk> ivanm: not sure. the iterator conceptual model would seem to argue for separating things you can read from (Foldable/Generator) from things you can write to (insert/etc)
06:37:37 <edwardk> the way i currently do this is i tend to use a Generator to read from a structure and a Reducer to build it
06:37:47 <ivanm> I did consider just having toList/fromList, but figured the marshalling back and forth would be even more costly
06:38:02 <edwardk> are you familiar with the generator/reducer interface from monoids?
06:38:08 <quicksilver> edwardk: given a structure which permits in-place modification, though, it is reasonable to ask for a read/write iterator.
06:38:15 <edwardk> quicksilver: sure
06:38:26 <quicksilver> edwardk: zippers are read/write in a sense.
06:38:51 <edwardk> quicksilver: yeah. i was just about to mention zippers as something in the middle. ;)
06:38:59 <ivanm> edwardk: not really
06:39:04 <ivanm> and I really should be hitting the sack
06:39:17 <ivanm> you going to be online in about 12 hours time? :p
06:39:18 <edwardk> @hackage monoids
06:39:18 <lambdabot> http://hackage.haskell.org/package/monoids
06:39:22 <ivanm> actually, even in 10 hours time
06:39:36 <edwardk> look at http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Generator.html
06:39:41 <ivanm> edwardk: oh, another big huge library? :p
06:39:46 <edwardk> and http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Monoid-Reducer.html
06:39:50 <ivanm> why doesn't that surprise me? :p
06:39:55 <edwardk> and in particular: http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Generator-Combinators.html
06:40:13 <edwardk> i occasionally wax OCD what can i say ;)
06:40:22 <ivanm> heh
06:40:26 <ivanm> anyway, I need slepp
06:40:28 <ivanm> *sleep
06:40:31 <ivanm> (that's how tired I am)
06:40:33 <ivanm> g'night all
06:40:41 <edwardk> go sleep, but then check my version of your concept here ;)
06:40:59 <quicksilver> edwardk was designed as a contrivance to test boundary cases in compilers
06:41:10 <quicksilver> probably by SPJ.
06:41:42 <edwardk> quicksilver: =) just because you can do something doesn't mean you should er... well, actually, yes it does. ;)
06:42:27 <ivanm> @remember quicksilver edwardk was designed as a contrivance to test boundary cases in compilers, probably by SPJ.
06:42:28 <lambdabot> Done.
06:44:20 <chrisdone> --  markupIdentifier    = box (TagInline "a") . str . out . head,
06:44:20 <chrisdone>   markupIdentifier    = (>>= box (TagInline "a") . str . out) . take 1,
06:44:20 <chrisdone> am i right?
06:44:39 <cuba> fromInteger on sum([]) works nicely but why does it break on length([])?
06:44:53 <edwardk> quicksilver: besides even if i was ostensibly designed by SPJ, the implementation work would probably have fallen to the other simon, and that, just has so many "Who's your daddy?" connotations that I wouldn't know where to start
06:44:54 <djahandarie> What's with the extra parenthesis?
06:45:27 <kmc> > fromInteger (sum [])
06:45:28 <lambdabot>   0
06:45:32 <kmc> > fromInteger (length [])
06:45:32 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
06:45:33 <lambdabot>         agains...
06:45:43 <kmc> cuba, Int and Integer are not the same type
06:45:45 <quicksilver> because length doesn't return an Integer.
06:45:47 <kmc> cuba, use fromIntegral not fromInteger
06:45:52 <kmc> > fromIntegral (length [])
06:45:53 <lambdabot>   0
06:45:59 <quicksilver> or just `div` in the first place
06:46:09 <quicksilver> if you are in fact after integer division.
06:46:11 <kmc> length returns Int, though arguably it should return Integer
06:46:33 <kmc> cuba, or use genericLength from Data.List -- it will already provide any numerical type you want, including Double or Rational
06:47:03 <cuba> i guess im not supposed to use it :(
06:47:08 <cuba> but good to know
06:47:19 <kmc> not supposed to use what?
06:48:02 <cuba> genericLength
06:48:50 <kmc> why not?
06:49:06 <mm_freak> Saizan: i think you missed the context =)
06:51:19 <Saizan> mm_freak: yep, quicksilver provided me some later :)
06:55:00 <mm_freak> weak types in type signatures would be useful sometimes
06:55:18 <mm_freak> in this case at least
06:55:41 <kmc> weak types?
06:57:15 <quicksilver> "Ptr a" in which a is unknown (rather than universal)
06:57:24 <quicksilver> sometimes written "Ptr _"
06:57:42 <quicksilver> I think you see them called 'partial signatures' and 'signatures with holes'
06:58:07 <kmc> ah yes
06:58:09 <djahandarie> Ooh, diffcabal is pretty nifty
06:58:14 <kmc> i think uhc has those maybe?
06:58:20 <djahandarie> Good for making change logs
06:58:55 <quicksilver> in particular if you use type classes extensively
06:59:03 <quicksilver> type annotations start to be fragile
06:59:12 <quicksilver> making a small change involves changing 100s of type annotations
06:59:22 <quicksilver> it would be useful to only specify some parts.
06:59:26 <quicksilver> q.v. session types.
06:59:30 <kmc> yeah
06:59:43 <mm_freak> i agree
06:59:50 <kmc> it's equivalent to let users write unification variables in types, right?
06:59:53 <quicksilver> http://www.cs.uu.nl/wiki/bin/view/Ehc/UhcUserDocumentation#3_4_Partial_type_signature
07:00:06 <quicksilver> kmc: certainly that's equivalent to my examples.
07:00:19 <quicksilver> "Ptr a" in which a is a unification variable, not an implicitly universal type variable.
07:00:43 <quicksilver> in UHC, that would be Ptr %a
07:00:46 <quicksilver> or simply Ptr ...
07:01:23 <mm_freak> http://okmij.org/ftp/Haskell/types.html#partial-sigs
07:02:24 <mm_freak> smart solution
07:02:36 <quicksilver> hmm. Yes, I've used that solution without realising it constituted a complete solution.
07:02:40 <quicksilver> It's quite ugly though, in general.
07:03:04 <quicksilver> I tend to use `asTypeOf` rather than | False
07:03:08 <quicksilver> but, same difference.
07:04:28 <mm_freak> well, real partial signatures would be better, of course
07:04:52 <mm_freak> especially because in this solution, the type signature doesn't belong to the actual function
07:05:25 <quicksilver> the fact that UHC has them suggests there are no real obstacles.
07:05:27 <edwardk> mm_freak: i keep meaning to write up a version of that partial sigs stuff using Proxy
07:05:32 <quicksilver> (or the UHC guys didn't notice a problem)
07:05:39 <edwardk> (to avoid passing around undefineds)
07:06:28 <amadan> hi all - another newbie question (sorry)
07:06:48 <amadan> I have "ss_prime :: Integer -> IO Bool"
07:07:03 <amadan> "filterM ss_prime (take 3 [3..])" works, but...
07:07:19 <amadan> "liftM (take 3) (filterM ss_prime [3..])" does not terminate. How do I fix it?
07:07:34 <amadan> (and where am I going wrong?)
07:09:13 <mm_freak> i wonder why the first one works
07:09:32 <idnar> mm_freak: because it operates on a finite list
07:09:47 <mm_freak> oh yes
07:09:49 <idnar> filterM ss_prime [3,4,5]
07:09:54 <mm_freak> i didn't see the "take 3"
07:10:20 <mm_freak> take 3 <$> filterM (const (return True :: IO Bool)) [3..5]
07:10:22 <mm_freak> this works for me
07:10:36 <amadan> what is <$>?
07:10:48 <mm_freak> in this case it's liftM
07:10:53 <kmc> same as fmap but infix
07:11:05 <kmc> on monads liftM and fmap are the same
07:11:17 <chrisdone> naughty, naughty. this is why we should avoid partial functions, kids
07:11:20 <amadan> and, yes, for [3..5] works for me too
07:11:33 <chrisdone>       -- render even though there are no input files (usually contents/index)
07:11:33 <chrisdone>       renderStep packages []
07:11:33 <chrisdone>       ... later in the code, with no null checks:
07:11:33 <chrisdone>       ifaceMod (head ifaces) -- kaboom!
07:11:46 <mm_freak> amadan: [3..5] and (take 3 [3..]) are the same thing
07:11:52 <mm_freak> maybe your ss_prime function is flawed
07:12:05 <amadan> as i said, that works - what does not work is take after filtering
07:12:13 <kmc> the problem is that IO is forcing the list to be fully produced before returning anything
07:12:17 <amadan> it's as if filterM is forcing...
07:12:19 <kmc> which doesn't work for an infinite list
07:12:23 <chrisdone> `head` is the devil. i wish people wouldn't use it
07:12:28 <amadan> kmc: lol, read my mind
07:12:33 <mm_freak> well, the outcome is a finite list
07:12:44 <mm_freak> so if ss_prime works, then both version should work
07:12:46 <kmc> mm_freak, but the output of filterM is an infinite list
07:12:48 <mm_freak> try to print the result list
07:12:48 <amadan> kmc: any way to keep an IO list lazy?
07:13:08 <mm_freak> kmc: it's not
07:13:16 <mm_freak> > filterM (const (return True :: IO Bool)) (take 3 [3..])
07:13:16 <mm_freak> [3,4,5]
07:13:17 <lambdabot>   <IO [Integer]>
07:13:24 <djahandarie> IO is lazy and lists are lazy, you are just asking for the whole thing
07:13:28 <amadan> ss_prime works with 2^10000 in 2 seconds...
07:13:36 <kmc> mm_freak, you're misreading.  it's (filterM ss_prime [3..])
07:13:47 <kmc> not (filterM ss_prime (take 3 [3..]))
07:14:01 <mm_freak> oh, indeed
07:14:31 <mm_freak> yes, filterM (in the IO monad) does not give anything, until the whole list is passed through the filter function
07:14:31 <amadan> to restate the problem: 
07:14:33 <amadan> amadan: "filterM ss_prime (take 3 [3..])" works, but...
07:14:33 <amadan> [11:06pm] amadan: "liftM (take 3) (filterM ss_prime [3..])" does not terminate.
07:14:47 <mm_freak> this is a peculiarity of the IO monad
07:14:58 <amadan> ugh grumble. so no way to lazy-eval the IO list?
07:15:12 <kmc> amadan, each test invoked by filterM can have effects on the outside world.  if you allowed the caller to force only a finite amount of the list, performing only a finite number of those tests, you allow evaluation behavior to change which effects occur
07:15:17 <mm_freak> no, maybe you should reconsider your ss_prime function
07:15:17 <kmc> which is disallowed
07:15:22 <amadan> ah...
07:15:23 <mm_freak> why is it an IO computation at all?
07:15:25 <kmc> amadan, you could do it with unsafeInterleaveIO probably
07:15:35 <djahandarie> Ugh
07:15:38 <amadan> mm_freak: because it's stochastic.
07:15:52 <kmc> amadan, perhaps MonadRandom is more lazy
07:16:05 <mm_freak> amadan: ss_prime :: RandomGen g => Integer -> State g Bool
07:16:10 <kmc> anyway it's /probably/ fine to use unsafeInterleaveIO, if all you're doing in IO is generating random numbers
07:16:10 <edwardk> amadan: yes, but you can generate a random number seed, and hand it a list of values generated by that to consume
07:16:21 <edwardk> amadan: stochastic doesn't mean io to run, just io to setup
07:16:37 <edwardk> @type mkStdGen
07:16:38 <lambdabot> Int -> StdGen
07:16:45 <edwardk> @type newStdGen
07:16:46 <lambdabot> IO StdGen
07:16:54 <amadan> as i said, i'm a newbie :) and the most obvious thing i saw was randomRIO
07:16:56 <edwardk> once you have the StdGen you can call randoms, etc.
07:16:59 <edwardk> @type randoms
07:17:00 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
07:17:10 <edwardk> g there can be the StdGen given by newStdGen
07:17:13 <mm_freak> amadan: have a look at randomR instead
07:17:20 * chrisdone proposes a -W-fwarn-partial-functions
07:17:22 <mm_freak> and either use MonadRandom, as kmc noted
07:17:34 <mm_freak> or make your own State monad
07:17:50 <mm_freak> chrisdone: we have that already
07:18:13 <amadan> mm_freak: lol, i'm barely hanging on with IO... I'm definitely not up to making my own State monad o.O
07:18:19 <mm_freak> chrisdone: there is a warning about incomplete pattern matches
07:18:25 <amadan> thanks for all the good ideas.
07:18:34 <mm_freak> amadan: don't worry about the word "monad" too much
07:18:38 <mm_freak> /using/ them is very easy
07:18:44 <kmc> amadan, you're right, randomRIO is the easiest way to generate random numbers as you would in other languages.  but in this case it means you get another feature from other languages: not being able to work with infinite data easily
07:18:45 <monochrom> -fwarn-recursion
07:19:00 <djahandarie> lol monochrom 
07:19:08 <amadan> kmc: yeah, so i see... :p
07:20:08 <mm_freak> amadan: think of "State Int" as something similar to the IO monad, but completely lazy and with implicit state of type Int
07:20:19 <kmc> mm_freak, i think that's bad advice
07:20:22 <kmc> IO is a weird, special monad
07:20:26 <kmc> it's a bad model for other monads
07:20:49 <quicksilver> also the thing about IO which we call laziness is not laziness.
07:20:59 <djahandarie> Oh hey, Boston Haskell coming up soon
07:21:02 <kmc> it's only similar in that both are monads, which just means both of them work with the same control-flow operators
07:21:03 <mm_freak> kmc: it's technically not really correct
07:21:09 <quicksilver> and the thing the state monad does have, would not solve the infinite filterM problem.
07:21:12 <kmc> not that they use those operators in similar ways
07:21:14 <edwardk> amadan: for that matter you don't even need to think about this in terms of a monad at all, you can just plumb the unused portion of the infinite list of random numbers around yourself
07:21:16 <amadan> so far i can wrap my head about Maybe, and maybe [], and possibly IO. beyond is still rather mysterious...
07:21:21 <quicksilver> infinite filterM woudl not work in the state monad either
07:21:29 <mm_freak> amadan: state monads are very easy
07:21:45 <quicksilver> (because it would have to run an infinite number of potentially state-changing actions before returning the infinite list, it needs to calculate the final state value)
07:21:46 <kmc> everything's very easy once you understand it
07:21:51 <mm_freak> amadan: you can use your familiar do notation and there are two special functions 'get' and 'put'
07:21:56 <kmc> quicksilver, what if you don't ask for the final state value?
07:22:02 <quicksilver> kmc: I'm not sure ;)
07:22:07 <kmc> i /think/ it'd be ok
07:22:08 <mm_freak> 'get' gets the current state and 'put' changes it
07:22:32 <mm_freak> that's it
07:22:33 <chrisdone> mm_freak: we don't have it already. i'm talking about *using* partial functions
07:22:43 <amadan> hmm. i see. (tentatively :) )
07:23:02 <mm_freak> amadan: just try it out
07:23:06 <mm_freak> you'll love state monads =)
07:23:19 <chrisdone> Foo.hs:42: warning, you used `head' which is a partial function;
07:23:20 <chrisdone>             its function misses the following cases:
07:23:20 <chrisdone>                 [] -> ...
07:23:45 <kmc> amadan, (State s a) is just a wrapper on functions of type (s -> (a,s))
07:23:58 <mm_freak> > runState (do x <- get; put (x+1); return "hehe") 4
07:23:59 <lambdabot>   ("hehe",5)
07:24:02 <kmc> so the (State s) monad is just syntactic sugar for passing around a state of type s explicitly
07:24:02 <amadan> i will, as soon as i get time :) right now, there's an assignment to calculate. i could do it in ruby with my hands tied behind my back, but... i wanted *some* challenge. ;)
07:24:50 <aristid> :t ask
07:24:51 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
07:24:54 <mm_freak> > runState (do modify (+1); return "haha") 3
07:24:55 <lambdabot>   ("haha",4)
07:25:08 <quicksilver> > runState (filterM (\_ -> return True) [0..]) 0
07:25:10 <lambdabot>   ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
07:25:27 <quicksilver> runState (filterM (\_ -> return True) [0..] >> get) 0
07:25:31 <quicksilver> > runState (filterM (\_ -> return True) [0..] >> get) 0
07:25:38 <lambdabot>   mueval: ExitFailure 1
07:25:39 <mm_freak> > filterM (const [True, False]) "abc"
07:25:44 <quicksilver> kmc: ^^ you're right. It produces output if we don't examine the state.
07:25:51 <quicksilver> kmc: it runs forever if we do
07:25:52 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
07:25:56 <mux> > subsequences "abc"
07:25:58 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
07:26:02 <quicksilver> (even though my action, in fact, doesn't modify the state it doesn't know that)
07:26:06 <mux> (it got added into base recenly)
07:26:10 <aristid> :t filterM
07:26:12 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:26:20 <mm_freak> mux: "recently"?  i think, it's there for months already
07:26:31 <mux> that's what I meant by recently
07:26:39 <djahandarie> It's not the filterM implemention though
07:26:49 <mux> yeah, this one is inefficient, I think
07:27:15 <mm_freak> > runState (filterM (const $ modify not >> get) [1..])
07:27:15 <amadan> okay, on another track; is there a way to flush output while chewing on the infinite list? without waiting to terminate? (i guess that also gets a "no", since we're first dealing with computation, and output is later...?)
07:27:16 <lambdabot>   Overlapping instances for GHC.Show.Show
07:27:16 <lambdabot>                              (GHC.B...
07:27:17 <djahandarie> filterM version is inefficient
07:27:23 <mm_freak> > runState (filterM (const $ modify not >> get) [1..]) True
07:27:25 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
07:27:48 <quicksilver> mm_freak: it's fine if you don't inspect the state, yes.
07:27:50 <kmc> amadan, you can make a "printList :: (Show a) => [a] -> IO ()" which flushes after each element
07:27:50 <djahandarie> Since it can't tail recurse do to how things are ordered inside the monad
07:28:02 <djahandarie> Err, inside the function
07:28:07 <mm_freak> quicksilver: you can inspect the state, but only /during/ filterM, not /after/ it
07:28:13 <quicksilver> mm_freak: yes, that's what I meant :)
07:28:19 <mm_freak> =)
07:28:24 <quicksilver> mm_freak: to produce each elt of that list it generates the state up to that time
07:28:34 <quicksilver> but if you inspect the state after the filterM, it needs to 'finish'
07:28:37 <quicksilver> if you never do, it doesn't.
07:28:41 <mm_freak> well, actually
07:28:57 <amadan> kmc: i meant with my IO [Integer]?
07:28:58 <mm_freak> > evalState (filterM (const $ return True) [1..] >> get) True
07:29:05 <lambdabot>  Terminated
07:29:08 <mm_freak> hmm
07:29:19 <aristid> :t evalState
07:29:24 <lambdabot> forall s a. State s a -> s -> a
07:29:44 <aristid> evalState = fst runState?
07:30:01 <aristid> liberally add dots
07:30:30 <BMeph> @src evalState
07:30:31 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:30:42 * BMeph sighs...
07:30:57 <kmc> amadan, you'd send the output to printList yes
07:31:46 <aristid> :t fmap fst . runState
07:31:47 <lambdabot> forall a b. State b a -> b -> a
07:32:00 <aristid> looks like the types match this way
07:32:47 <amadan> kmc: i can't find it. how do i find what to import?
07:33:32 <mm_freak> :t mapM putStrLn
07:33:32 <lambdabot> [String] -> IO [()]
07:33:38 <mm_freak> :t mapM_ putStrLn
07:33:39 <lambdabot> [String] -> IO ()
07:33:55 <mm_freak> :t mapM_ print
07:33:56 <lambdabot> forall a. (Show a) => [a] -> IO ()
07:34:58 <kmc> amadan, i said you could write it
07:36:34 <amadan> ah.
07:36:54 <amadan> misunderstood, sorry
07:39:13 <mm_freak> amadan: you need only two words to write that function
07:39:21 <mm_freak> look at this:
07:39:24 <mm_freak> :t mapM_
07:39:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:40:07 <amadan> hehe, haskell is fun! infuriating, but fun!
07:40:17 <monochrom> isn't haskell exciting?
07:40:39 <chrisdone> @faq Can Haskell be exciting for me?
07:40:39 <lambdabot> The answer is: Yes! Haskell can do that.
07:40:48 <amadan> lol
07:41:24 <tromp_> @faq can haskell suck balls?
07:41:24 <lambdabot> The answer is: Yes! Haskell can do that.
07:41:54 <kmc> mm_freak, i thought amadan also wanted to do some explicit flushing
07:43:00 <mm_freak> :t mapM_ (print >=> const (hFlush stdout))
07:43:01 <lambdabot> Not in scope: `hFlush'
07:43:02 <lambdabot> Not in scope: `stdout'
07:43:11 <mm_freak> :t mapM_ (print >=> const (return ()))
07:43:11 <lambdabot> forall a. (Show a) => [a] -> IO ()
07:43:26 <amadan> just thinking how i can get as much calculation as i can done before the user gets sick of prime numbers and hits CtrlC
07:43:36 <edwardk> tromp_: that is definitely an IO operation that would give new meaning to the phrase 'sin bin'
07:44:01 <mm_freak> suck :: BallLike a => a -> IO ()
07:44:18 <mm_freak> or even:
07:44:24 <mm_freak> suck :: Suckable a => a -> IO ()
07:44:36 <mm_freak> class Suckable a where suck :: a -> IO ()
07:44:52 <mm_freak> anyway
07:45:41 <edwardk> i'm pretty sure you may need an MPTC to determine the output type
07:45:50 <edwardk> but this waxes NSFW ;)
07:46:07 <mm_freak> > let isPrime n = all (\x -> n `rem` x /= 0) . takeWhile (\x -> x*x <= n) $ primes; primes = 2 : filter isPrime [3..] in primes
07:46:09 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:46:46 <mm_freak> my favorite haskell example to prove that laziness is truely a virtue
07:46:47 <mm_freak> =)
07:47:24 <mm_freak> this isPrime function is extraordinarily difficult to write in a non-lazy language
07:48:14 <EliasAmaral> mm_freak, you mean, a primality test?
07:48:19 <amadan> heh... i'm kind of sorry i can't submit that...
07:48:26 <EliasAmaral> or a specific technique?
07:49:01 <mm_freak> EliasAmaral: isPrime and primes refer to each other
07:49:27 <mm_freak> i.e. isPrime is a normal trial division test, but with the little advantage that it checks only against prime numbers
07:49:47 <tromp_> shldnt be that hard, just using a linked list for primes generated aso far
07:49:48 <EliasAmaral> ah, and it creates a potentially infinite list? yes, this feature helps to keep the code simple
07:50:20 <mm_freak> tromp_: the code is very simple and doesn't use any advanced data structures
07:50:23 <mm_freak> just the laziness of the language
07:51:18 <tromp_> of course it will be much  more verbose in C++, but certainly not extraordinarily difficult 
07:51:41 <mm_freak> tromp_: note that haskell uses sharing
07:51:48 <mm_freak> you need to replicate that feature in C++
07:52:05 <mm_freak> otherwise to test two prime numbers, the prime list will need to be generated two times
07:52:15 <tromp_> there wld only be a single primes list in C++
07:52:29 <mm_freak> you mean by using side effects? ;)
07:52:33 <EliasAmaral> mm_freak, hmm.. you can have an object called "prime list"
07:52:43 <EliasAmaral> that will generate new primes on demand
07:53:02 <mm_freak> you already need global variables for that
07:53:07 <mm_freak> i.e. side effects
07:53:33 <mm_freak> i think you get the point
07:53:38 <tromp_> the same side effects that haskell runtime uses to expand thunks
07:53:53 <EliasAmaral> not global variables (it can hold state inside the object), but maybe some synchonization for multi-threading apps (just one mutex, maybe)
07:53:53 <mm_freak> yes, the side effects are not in the code
07:54:15 <mm_freak> ok, i think we already have 20-30 lines by that
07:54:18 <Jafet> On the other hand, you will spend more time figuring out how to make your Haskell program generate primes using a self-referential algorithm as fast as a C++ program that generates primes using a self-referential algorithm than it takes to write that C++ program to generate primes faster than that Haskell program.
07:54:19 <mm_freak> you get the point?
07:54:26 <EliasAmaral> mm_freak, yes
07:54:58 <mm_freak> and you already had to spend time programming memory management and stuff
07:55:18 <tromp_> no; the STL does that for you
07:55:20 <mm_freak> not to mention that the haskell variant is safe in multithreaded applications
07:55:48 <EliasAmaral> hey, i like haskell & functional programming
07:55:48 <mm_freak> tromp_: you still need to allocate the prime list and make it grow manually
07:55:50 <EliasAmaral> :P.
07:56:00 <mm_freak> "oh, i have so many primes so far, so i don't need to grow the list right now"
07:56:02 <mm_freak> etc.
07:56:34 <mm_freak> Jafet: probably the C++ version of this isn't going to be faster
07:56:46 <mm_freak> the haskell runtime is optimized for handling thunks, because it does that all the time
07:57:24 <mm_freak> and yes, of course you can write a sieve of eratosthenes/atkin, but that's not the point
07:57:41 <EliasAmaral> the one that really needs performance for that might as well be happy with C. or no, but this is his/her problem. ^^.
07:57:52 <mm_freak> the point is:  this particular algorithm can't be reproduced as easily in C++
07:58:34 <mm_freak> and even when it's reproduced, the low-levelness of C++ probably isn't going to give a noticable advantage
07:58:34 <tromp_> i'm not arguing that; i'm arguing your use of "extraordinarily difficult"
07:58:35 <Jafet> A more compact version:
07:58:42 <chrisdone> > take 10 $ nubBy (((>1).).gcd) [2..]
07:58:43 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
07:58:56 <Jafet> Yay, chrisdone wrote it for me
07:59:04 <mm_freak> hehe
07:59:07 <EliasAmaral> chrisdone, @.@'
07:59:11 <mm_freak> but that's a different, slower algorithm
07:59:13 <chrisdone> >_>
07:59:16 <EliasAmaral> *bow*
07:59:32 <hcube> hi! what editor do you use for haskell on mac?
07:59:37 <chrisdone> i use emacs
07:59:39 <quicksilver> emacs.
07:59:45 <mm_freak> i don't use mac, but i would use emacs
07:59:47 <chrisdone> carbon emacs to be precise
08:00:05 <amadan> newbie says vim
08:00:25 <tromp_> u dont need gcd there, just a single mod
08:00:34 <mm_freak> ok, i'm out for now…  see you
08:00:40 <alexbobP> (\x -> true) mm_freak
08:00:42 <chrisdone> tromp_: demonstrate?
08:00:44 <amadan> mm_freak: thanks!
08:00:52 <tromp_> one of the gcd arguments is a prime!
08:00:57 <hcube> I've installed aquamacs, but i'm an mcedit guy on linux, emacs is too complicated for me :P
08:01:23 <chrisdone> what's a mcedit guy?
08:01:26 <augur> hcube: TextMate!
08:02:11 <EliasAmaral> hcube, it's also for me. but vim were too complicated some time ago as well, so i think you (we) may get used o.o'
08:02:15 <hcube> mcedit is midnight commander's editor
08:02:16 <chrisdone> tromp_: how?
08:04:12 <tromp_> > take 10 $ nubBy (((==0).).mod) [2..]
08:04:13 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
08:04:29 <amadan> the only thing i hate about vim is how i start typing jjkkkkl whenever i switch a window...
08:05:18 <Jafet> tromp: that's one stroke longer
08:05:57 <chrisdone> nice use of mod, i didn't think of that
08:06:06 <aristid> :t nubBy
08:06:07 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
08:06:18 <aristid> @src nub
08:06:18 <lambdabot> nub = nubBy (==)
08:06:21 <aristid> @src nubBy
08:06:22 <lambdabot> nubBy eq []             =  []
08:06:22 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
08:06:23 <EliasAmaral> amadan, hmmmm? i navigate with the arrows, idk what people see in the home arrow
08:06:31 <EliasAmaral> i also am no touch typist u.u'
08:06:43 <EliasAmaral> home.. arrow? no..home.. row
08:06:58 <amadan> EliasAmaral: just used to it, i guess. but i'm not a touch typist either...
08:07:29 <Alien_FX_Fiend> is there an ebook for haskell, in the room topic?
08:07:45 <chrisdone> @google real world haskell book
08:07:46 <lambdabot> http://book.realworldhaskell.org/
08:07:47 <lambdabot> Title: Real World Haskell
08:08:00 <chrisdone> Alien_FX_Fiend: this book is available online
08:08:21 <EliasAmaral> the little inconsistencies in the software i use also annoys me amadan .-.
08:08:30 <Alien_FX_Fiend> thanks a lot
08:08:36 <Alien_FX_Fiend> i appreciate it :)
08:08:55 <aristid> @unpl (((==0).).mod)
08:08:55 <lambdabot> (\ e h -> (mod e h) == 0)
08:10:01 <aristid> > let (.:) = (.).(.) in nubBy ((==0) .: mod) [2..]
08:10:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:10:38 <EliasAmaral> (.).(.)? @.@
08:10:49 <EliasAmaral> > let (.:) = . . . in nubBy ((==0) .: mod) [2..]
08:10:50 <lambdabot>   <no location info>: parse error on input `.'
08:11:18 <aristid> EliasAmaral: http://conal.net/blog/posts/semantic-editor-combinators/
08:11:44 <chrisdone> > let boob = (.); (.:) = boob . boob in nubBy ((==0) .: mod) [2..]
08:11:46 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:12:16 <BMeph> > let boob = (.); (.:) = boob . boob in nubBy ((>1) .: gcd) [2..]
08:12:18 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:12:42 <aristid> i love this method of finding primes, because it's so close to the mathematical definition
08:12:55 <BMeph> I guess the "issue" is whether gcd or mod is faster.
08:13:13 <benmachine> mod'll be faster I think
08:13:17 <aristid> BMeph: i would think mod
08:13:21 <aristid> mod is a single division
08:13:25 <aristid> (integer division)
08:13:28 <benmachine> gcd involves log n divisions, or something
08:13:37 <benmachine> (which is still pretty fast, but...)
08:13:49 <aristid> the problem with this algo is the nubBy i think
08:13:54 <BMeph> Subtractions, not divisions, but I smell what you're stepping in... :)
08:14:02 <tromp_> > let multiple x y = x `mod` y == 0 in take 10 $ nubBy multiple  [2..]
08:14:02 <amadan> BMeph: gcd contains recursed mod.
08:14:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
08:14:42 <aristid> tromp_: that is also nice
08:15:00 <chrisdone> aristid: also
08:15:00 <chrisdone> > fix $ \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)
08:15:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:15:29 <chrisdone> close to the mathematical definition
08:15:43 <EliasAmaral> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
08:15:45 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:15:52 <Tomsik> I want to use laziness and do something like render :: [Frame] -> IO () where it's just list of all frames that will ever be created
08:16:03 <aristid> chrisdone: only it doesn't produce primes
08:16:05 <EliasAmaral> > fix $ \fibs -> 1 : zipWith (+) fibs (tail fibs)
08:16:07 <Tomsik> However if there are no frames to render I want to do something else
08:16:09 <lambdabot>   mueval-core: Time limit exceeded
08:16:15 <Tomsik> I thought of [Maybe Frame]
08:16:29 <Tomsik> but I'm not sure how to do it in a way that I can check if it's already waiting or not
08:16:41 <chrisdone> artjom: no, it produces fibonacci numbers... and?
08:17:11 <EliasAmaral> i think i will save this log and study those one liners :P
08:17:11 <BMeph> > fix $ \fibs -> 1 : 2 : zipWith (+) fibs (tail fibs) -- Since you're taking the tail, you need at least two numbers to "prime the pump"
08:17:12 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
08:17:21 <chrisdone> er, aristid
08:17:55 <EliasAmaral> i think fib begins with 1 1
08:18:03 <BMeph> > let multiple x y = x `mod` y == 0 in take 10 $ nubBy (not . multiple)  [2..] -- Powers!
08:18:04 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
08:18:04 <lambdabot>         against inferred ...
08:18:04 <chrisdone> EliasAmaral: it begins with 0
08:19:02 <EliasAmaral> ah :)
08:19:08 <BMeph> > let divisors x y = x `mod` y /= 0 in take 10 $ nubBy divisors  [2..] -- Powers!
08:19:09 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
08:19:39 <amadan> -8, +5, -3, 2, -1, +1, 0, +1, +1, +2, +3, +8....
08:19:46 <Jafet> > let figure = scanl (+) 1 ground; ground = 2:4: filter (not . ap elem ((`takeWhile` figure) . (>))) [5..]; in (take 20 figure, take 20 ground) -- mm_freak: Hofstadter's "Figure-Figure" sequence
08:19:47 <lambdabot>   ([1,3,7,12,18,25,33,42,52,63,75,88,102,117,133,150,168,187,207,228],[2,4,5,...
08:19:50 <amadan> :)
08:19:54 <spray> I'm trying to set up an internal hpaste at my company and am having trouble with the config file. The readme says hpaste.conf needs to contain a Config object. What does this look like? Here is what I have now, which doesnt seem to work (not read at all by hpaste) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27632#a27632
08:20:15 <Jafet> Oh, crap, I had to get it wrong
08:20:30 <dolio> > let f (Left x) = Just (x, Right (x+ 2)) ; f (Right x) = Just (x, Left (x + 4)) in 2 : 3 : unfoldr f (Left 5)
08:20:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,...
08:21:07 <Jafet> > let figure = scanl (+) 1 ground; ground = 2:4: filter (not . ap elem ((`takeWhile` figure) . (>=))) [5..]; in (take 20 figure, take 20 ground) -- the one and only Figure-Figure sequence
08:21:08 <lambdabot>   ([1,3,7,12,18,26,35,45,56,69,83,98,114,131,150,170,191,213,236,260],[2,4,5,...
08:21:24 <EliasAmaral> dolio, @.@
08:21:47 <EliasAmaral> this one has just.. sums?
08:21:55 <EliasAmaral> where's the "catch"?
08:22:06 <EliasAmaral> ah
08:22:08 <EliasAmaral> there's a 25 there
08:22:11 <dolio> :)
08:22:13 <EliasAmaral> :P
08:22:58 <kamatsu> is Haskell's printf typesafe?
08:23:07 <kmc> "safe" how?
08:23:13 <kmc> it won't randomly corrupt memory and cause undefined behavior
08:23:23 <kmc> Text.Printf.printf does some type checking at runtime
08:23:28 <kamatsu> right
08:23:29 <kamatsu> hm
08:23:30 <kmc> matching the format string to arguments
08:23:31 <dolio> > printf "%d" "hello"
08:23:33 <kamatsu> right
08:23:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:23:33 <lambdabot>    `GHC.Show.Show a'
08:23:33 <lambdabot>      a...
08:23:36 <dolio> > printf "%d" "hello" :: String
08:23:37 <kmc> there are various other approaches that don't have this problem
08:23:37 <lambdabot>   "*Exception: Printf.printf: bad argument
08:23:46 <kmc> based on template haskell
08:23:46 <kamatsu> right it is a runtime exception
08:23:48 <kamatsu> yeah
08:23:55 <kmc> or based on using a combinator library to specify the format, rather than a bare string
08:23:56 <kmc> @quote stark
08:23:57 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
08:24:07 <spray> nevermind. just changed the defaults in Config.hs and rebuilt
08:24:09 <kamatsu> i was thinking of making some form of quasiquoter [$printf| %d ] 45
08:24:17 <kamatsu> and then it would be statically checked
08:24:30 <kmc> kamatsu, like http://hackage.haskell.org/package/Printf-TH ?
08:24:40 <kmc> $(printf "%d") 45
08:25:01 <kmc> but anyway, format strings suck
08:25:02 <kamatsu> yeah, i just think that the splice notation of TH is very ugly
08:25:09 <kmc> a combinator library does not have this problem
08:25:20 <kamatsu> right
08:25:22 <Tomsik> Haaay, anyone? :p
08:25:32 <Tomsik> <Tomsik> I want to use laziness and do something like render :: [Frame] -> IO () where it's just list of all frames that will ever be created
08:25:37 <Tomsik> <Tomsik> I thought of [Maybe Frame]
08:25:38 <Tomsik> <Tomsik> but I'm not sure how to do it in a way that I can check if it's already waiting or not
08:26:21 <quicksilver> kamatsu: and a quasiquoter in this context would just be a convenient frontend to the combinator library.
08:26:32 <kamatsu> right
08:26:38 <quicksilver> i.e. the quasiquoter is just a custom syntax for what is actually an ADT of some kind.
08:26:47 <quicksilver> would be a fairly simple QQ in principle.
08:26:50 <kamatsu> yeah
08:26:54 <roconnorWC> hello
08:27:07 <EliasAmaral> about printf: ocaml's approach was to determine the type of (printf "string") at compile-time. so (printf "%d") has type int -> unit. this makes it hard to generate this string dynamically
08:27:23 <kamatsu> EliasAmaral: is that a hard-coded special case in the compiler?
08:27:30 <EliasAmaral> kamatsu, yes. :(
08:27:36 <kamatsu> bah, sucks then
08:27:37 <Jafet> ...on the other hand, gcc barks a warning at you when you generate format strings dynamically
08:27:38 <Tomsik> Nobody? :(
08:28:05 <kamatsu> Tomsik: hold on, why do you need Maybe?
08:28:17 <Tomsik> I don't know what I need
08:28:25 <kamatsu> okay
08:28:33 <kamatsu> so i get you want to have an infinite list of frames?
08:28:35 <kmc> Tomsik, you want a lazy list for which you can query whether the next element is "ready" yet?
08:28:39 <EliasAmaral> kamatsu, yeah. I think the sole way of implementing your own printf is to make a camlp4 macro or something. (or at least I have not managed to make my own printf derivative)
08:28:43 <Tomsik> kmc: exactly
08:28:52 <echosystm> hi guys - functional programming newbie here
08:28:55 <kmc> Tomas, that's tricky
08:29:00 <kmc> err sorry
08:29:01 <kmc> Tomsik,
08:29:14 <kamatsu> echosystm: welcome to the cool crowd
08:29:17 <echosystm> im curious, why are the map and reduce functions so important in functional languages?
08:29:18 <Tomsik> Oh well, I can always have something to draw just one frame if that approach is problematic
08:29:30 <kmc> echosystm, why are for loops so important in imperative programs?
08:29:39 <kamatsu> echosystm: they are the building blocks of functional languages, like for loops and assignments in imperative.
08:29:41 <BMeph> > iterate (liftM2 (:) length (return . head)) [1]
08:29:42 <lambdabot>   [[1],[1,1],[2,1],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2...
08:29:46 <kmc> echosystm, of course the for loop is usually magical built-in syntax, while "map" is an ordinary function we can define, and redefine when necessary
08:29:52 <Jafet> @hoogle reduce
08:29:53 <lambdabot> No results found
08:29:56 <echosystm> mmm, i see
08:29:57 <kamatsu> @src map
08:29:57 <lambdabot> map _ []     = []
08:29:57 <lambdabot> map f (x:xs) = f x : map f xs
08:30:01 <kamatsu> see :)
08:30:05 <echosystm> that makes sense
08:30:11 <kmc> echosystm, map and filter (to use the Haskell name) capture common patterns of recursion
08:30:16 <kmc> you could always write the recursion yourself
08:30:19 <BMeph> > iterate (liftM2 (:) length (return . head).group) [1]
08:30:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:30:20 <lambdabot>         against inferred type ...
08:30:23 <echosystm> however, for the life of me, i cannot think of any circumstance i would need to use reduce
08:30:30 <echosystm> can someone give me a non-trivial example?
08:30:30 <kmc> echosystm, ever need to sum up a list?
08:30:39 <echosystm> non-trivial :P
08:30:47 <kmc> what's trivial here?
08:30:51 <kmc> sums are not useful?
08:30:56 <kamatsu> sum up a list is trivial but extremely common in practice :/
08:31:05 <echosystm> well, whats a more complex example?
08:31:16 <echosystm> something that really shows the benefit of it
08:31:20 <kamatsu> echosystm: that's like asking for a complex example of a for loop
08:31:21 <kmc> echosystm, i wrote a 3D renderer and defined a custom fold which accumulated rendered geometry onto a canvas
08:31:24 <kamatsu> something that really shows the benefit of it
08:31:46 <echosystm> i mean in comparison to what you would do in procedural
08:31:50 <monochrom> yeah, what is the real benefit of loops?
08:32:02 <kmc> echosystm, you're thinking about it the wrong way
08:32:06 <Jafet> @src forM
08:32:06 <lambdabot> forM = flip mapM
08:32:07 <monochrom> and i mean in comparison to what you would do in functional
08:32:12 <kmc> echosystm, there's not a 1:1 feature comparison between imperative and functional code
08:32:23 <echosystm> im not looking for a feature comparison
08:32:38 <echosystm> both paradigms have their plusses and minuses
08:32:39 <kamatsu> well, the FP approach is not a hardcoded feature in the language
08:32:40 <kmc> echosystm, the benefit of using standard map and fold is readability.  someone can come along and see immediately what pattern of recursion you're using, rather than having to read the whole code
08:32:54 <monochrom> strange questions that only a reporter would ask
08:32:58 <echosystm> im just trying to learn about the areas in which functional languages shine, so i can know when to do things a better way
08:33:01 <kmc> echosystm, that's why every decent language allows you to combine the 'paradigms' freely
08:33:19 <kamatsu> folds and maps are composable just like other language features
08:33:31 <kamatsu> most imperative languages don't let you pass around a for loop
08:33:43 <kmc> kamatsu, most of them do.  C++ and Java are atypical
08:33:51 <kmc> most imperative languages have first-class functions
08:34:17 <kamatsu> kmc: right, but then many of those control structures are still hardcoded, instead you're passing around a function containing those control structures
08:34:27 <kamatsu> an exception to this may be something like an imperative lisp
08:34:30 <kamatsu> or perhaps smalltalk
08:34:44 <echosystm> now the next query - why is functional programming becoming so common in parallel computing?
08:34:50 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/31353b866b161ff7
08:35:01 <EliasAmaral> echosystm, FP lets you to share data with no worries
08:35:11 <kmc> echosystm, because modifying variables in-place is a disaster with parallel code
08:35:15 <kamatsu> echosystm: purely functional code has no side effects, hence each part of the program can be evaluated independently without concern for race conditions or nondeterminism
08:35:23 <BMeph> > iterate ((liftM2 (:) length (return . head) =<<). group) [1] -- See and say
08:35:24 <echosystm> ah
08:35:24 <lambdabot>   [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1...
08:35:26 <echosystm> i see!
08:35:28 <echosystm> thats cool
08:35:29 <kmc> echosystm, whereas computing new values by applying equations is nearly trivial to parallelize
08:35:56 <kamatsu> in fact, haskell programs can be parallelized with minimal changes
08:36:03 <echosystm> im a bit raw with multithreaded programming
08:36:19 <kmc> echosystm, the point of parallelism the way it's done in Haskell is that you *don't* have to do multithreaded programming
08:36:20 <echosystm> are you saying in functional languages, you dont need to worry about semaphores and the like?
08:36:35 <echosystm> i see
08:36:35 <kamatsu> er, you're confusing parallelism with concurrency
08:36:38 <kmc> you don't have to worry about threads, synchronization, and thread communication; you just say "evaluate this and this at once"
08:36:51 <kamatsu> parallelism is using concurrency to make your program faster, essentially
08:36:55 <EliasAmaral> echosystm, I've see this principle in some filesystems: whenever you want to change a block, you write a new block instead ("log-based filesystem"). there's a lot of reasons to do that, but one is that someone else that is reading this block doesn't have to worry about races
08:36:57 <kamatsu> concurrency may use threads for other purposes
08:37:09 <kmc> echosystm, Haskell supports both concurrency and parallelism, separately.  concurrent programs have multi-threaded semantics; parallel programs use multiple cores but may look like sequential programs
08:37:25 <kmc> if you're doing only the latter, you dont' need explicit locking or thread communication
08:37:29 <echosystm> hmmm
08:37:30 <echosystm> cool
08:37:30 <EliasAmaral> echosystm, you can have this discipline with any paradigm, but FP gives this behavior for free
08:37:39 <echosystm> sounds like its time for me to learn a functional language!
08:37:43 <kmc> echosystm, indeed
08:38:08 <kamatsu> if you're interested in multiprocessor or multicore work
08:38:11 <mm_freak> in fact, a concurrent program in haskell is generally not parallel, unless you specifically tell it to be
08:38:15 <kamatsu> Haskell is an excellent FP language to start with.
08:38:18 <mm_freak> amadan: you're welcome
08:38:19 <kmc> echosystm, Haskell is a good choice, though it's much different from most FP languages
08:38:31 <echosystm> howso kmc?
08:38:38 <kamatsu> we're serious about being functional
08:38:45 <mm_freak> hehe
08:38:48 <kmc> functions aren't allowed to have side effects when they evaluate
08:38:54 <kmc> we describe effects using a different mechanism
08:38:55 <echosystm> ah
08:39:04 <kmc> which is cleaner and more composable
08:39:22 <kmc> and haskell has lazy evaluation
08:39:25 <mm_freak> well, actually we "describe" effects in that we make them explicit
08:39:28 <kamatsu> many other FP languages make it all too easy to slide back into effectful, imperative habits
08:39:29 <kmc> and it has a very fancy, strong, static type system
08:39:46 <mm_freak> other languages don't even bother to "describe" effects…  most programmers wouldn't even know what a "side effect" is
08:40:13 <kamatsu> the other thing is
08:40:20 <mm_freak> i've even heard imperative programmers ask: "what's state?"
08:40:32 <kmc> echosystm, none of which is part of the core definition of functional programming
08:40:35 <FauxFaux> That's what they call counties in the US.
08:40:43 <kamatsu> Haskell takes concurrent and parallel programming seriously
08:40:45 <echosystm> what functional language do you guys find is most common in the wild?
08:40:49 <kamatsu> there is alot of work put into it
08:40:50 <kmc> Javascript
08:41:03 <kamatsu> although JavaScript is only functional if you use it as such
08:41:12 <kmc> kamatsu, like any other language
08:41:16 <kamatsu> and it doesn't support tail recursion 
08:41:21 <kmc> true
08:41:24 <kamatsu> which limits its functional applications
08:41:27 <echosystm> ive been doing a lot of javascript lately, with extjs
08:41:31 <BMeph> Functions aren't allowed  to have side effects when they evaluate...unless they warn you first.
08:41:34 <theorbtwo> It's pretty clear to me that the better you get at javascript, the more functionally you write it.
08:41:43 <echosystm> they make it so OO i basically havent used any real js at all
08:41:52 <theorbtwo> Of course, it doesn't help that the syntax for a lambda is so long.
08:41:54 <EliasAmaral> most FP languages have strict evaluation, because they don't disallow imperative code. (functional programming here is meant as a paradigm where you don't change state explicitly. you can mix FP code with imperative code in languages like ML)
08:42:22 <mm_freak> echosystm: OO and FP live well together
08:42:34 <echosystm> i see
08:42:34 <mm_freak> you can use both paradigms at the same time
08:42:34 <kmc> you can mix FP with imperative code in languages like Haskell, too
08:42:40 <EliasAmaral> in ML, FP is just a lot more convenient than imperative code, so people usually get used to it
08:42:59 <kamatsu> Haskell just makes sure you're ABSOLUTELY SURE you want to do it imperatively, and then makes sure you keep it ABSOLUTELY CLEAR where the imperative stuff stops
08:43:04 <kmc> and in Perl, Python, Ruby, C#, Javascript, Scala, Clojure, ...
08:43:40 <echosystm> well, ive been meaning to learn perl for a while
08:43:44 <BMeph> JS, XSLFauxFaux: Provinces. ;)
08:43:48 <kmc> echosystm, don't
08:43:51 <kmc> Perl is obsolete
08:43:57 <echosystm> do you think the functional side of it is comprehensive enough to give me a decent foundation?
08:43:58 <theorbtwo> First level administritive districits.
08:44:02 <kamatsu> echosystm: no
08:44:05 <mm_freak> well, languages without TCO aren't very useless for FP, even if they have first class functions, lambdas, etc.
08:44:08 <echosystm> okie doke
08:44:17 <mm_freak> s/useless/useful/
08:44:17 <EliasAmaral> haven't haskell community elected perl 6 as their scripting language of choice?
08:44:25 * BMeph should really finish the first thought, before typing out the second hey, that's awesome! ;þ
08:44:25 <kamatsu> I think the best way to learn FP is to throw yourself into the deep end
08:44:28 <theorbtwo> Do learn perl, but doesn't do it because you want a grounding in functional programming.
08:44:32 <kamatsu> EliasAmaral: Haskell is my scripting language of choice
08:44:40 <EliasAmaral> ah. :)
08:44:50 <echosystm> ok, so haskel is your FP learning language of choice yes?
08:44:57 <mm_freak> mine, yes
08:45:00 <kamatsu> yeah, because it forces you to rethink your approaches
08:45:09 <kamatsu> and helps you to "grok" FP faster
08:45:15 <echosystm> good! haskell it is then
08:45:45 <kamatsu> then again, I don't know, my first language was an FP one
08:45:52 <mm_freak> i think people get much more convinced by conciseness and safety
08:45:54 <kamatsu> i learnt imperative after FP, so I'm the unusual case.
08:46:15 <BMeph> I'd say it's more like Haskell is the Perl community's prototyping engine of choice... ;)
08:46:18 <mm_freak> to force people to program in a certain way always sounds like a bad thing rather than a good thing and shouldn't be mentioned to newcomers
08:47:07 <kamatsu> mm_freak: Right but echosystm wants to learn functional programming, Haskell forces you to do it functionally until you learn IO
08:47:18 <kamatsu> I think that makes it a good language if your stated goal is to learn FP
08:47:29 <EliasAmaral> echosystm, I know very little about haskell u.u I like ocaml and it proves me that you can do a lot of OO stuff functionally (to point to an earlier issue). [ In fact, not exactly related to functional programming, but I like modern type systems that FP languages usually give you. like "the type of all objects that have the method len with type unit -> int")
08:47:53 <mm_freak> kamatsu: even then i think it's much better to mention the constructive/productive features of haskell
08:47:55 <monochrom> I prefer quality to quantity. Of new people. Tell me all the "bad" news. If they stay, they are of quality.
08:48:02 <monochrom> s/me/them/
08:48:04 <mm_freak> i get my stuff done much faster, with far less and much more elegant code
08:48:18 <mm_freak> and that convinced some people to change to haskell
08:48:22 <kamatsu> true
08:48:38 <mm_freak> if i had told them that haskell "forces you to [whatever]", then they would still use c++ or PHP
08:48:41 <kamatsu> but I have also convinced people to choose haskell based on an explanation that a language that forces greater discipline leads to cleaner code
08:48:46 <mm_freak> no matter how good that forcing is
08:49:05 <kamatsu> mm_freak: I would argue that such programmers are immature and really should grow up and realise that languages place constraints on you to help prevent mistakes
08:49:11 <mm_freak> yes, but remember that many people use C, because "it gives them freedom"
08:49:19 <kamatsu> yeah, and i'd rather those people continue use C
08:49:31 <mm_freak> kamatsu: programming languages are like religions
08:49:35 <alexbobP> My big argument for forcing certain things is that they allow for static analysis of your code
08:49:42 <mm_freak> those programmers aren't immature, they just have a particular belief
08:49:43 <EliasAmaral> echosystm, C++0x is trying to bring a little of this power (with, for example, "auto" types), but it's very far from it. (haskell's type system is much more powerful)
08:49:49 <Tomsik> if freedom is freedom of expressing one line of code in thirty :p
08:49:51 <alexbobP> you can look at python and literally not know what *type* a variable could be without looking at the whole damn program
08:49:54 <alexbobP> it's insane
08:49:57 <kmc> kamatsu, but i'm a leet haxor and i never make mistakes!
08:50:04 <quicksilver> mm_freak: some of them are immature programmers (not necessarily immature human beings)
08:50:05 <benmachine> kamatsu: I kinda prefer people to write stupid haskell than stupid C
08:50:13 <kamatsu> mm_freak: any programmer who is worth their salt would take any opportunity to prevent them making mistakes
08:50:25 <quicksilver> mm_freak: sometimes more experience - programming maturity - means you change your view later.
08:50:26 <kamatsu> benmachine: well, GHC tells you if you're being stupid alot more of the time
08:50:35 <benmachine> kamatsu: exactly?
08:50:37 <quicksilver> kamatsu: s/if/that/;
08:50:41 <arw> mm_freak: most programmers use C because it gives control and performance.
08:50:46 <kmc> alexbobP, indeed, you can't do it even if you do look at the whole program
08:50:59 <alexbobP> kmc: true.  halting problem and all that :P
08:51:01 <kamatsu> arw: valid reasons to use C
08:51:15 <kamatsu> arw: "freedom" to screw up, is not
08:51:21 <arw> mm_freak: the "jippie, i can cast a string to an int"-crowd uses stuff like php imho.
08:51:51 <benmachine> it always used to upset me writing C that I couldn't work out what conversions were being done and when
08:51:52 <arw> s/php/scripting languages/
08:52:04 <benmachine> this was partially because I was bad at C
08:52:11 <benmachine> but not entirely.
08:52:22 <kamatsu> when I teach C to first years
08:52:30 <kamatsu> my personification of C is a very stupid, but obedient, person
08:52:43 <kamatsu> When you do this ridiculously stupid thing, C's answer is "Ah, Okay!"
08:52:52 <kamatsu> "You didn't put a type sig there, I'm just going to assume you mean int!"
08:52:58 <amadan> arw: not really. there's a chasm between ruby/python people and php people, in my experience.
08:53:25 <kamatsu> ruby/python people like the dynamism of their language, and are attached to that world of programming
08:53:28 <kamatsu> but they're not bad programmers
08:53:32 <BMeph> Just for the record, programming languages are NOT like religions. Programmers are (like religious) fanatics, though.
08:53:33 <kamatsu> alot of php programmers are
08:53:38 <Jafet> kamatsu: now we know what Ritchie and Kernighan's secret fetish is
08:53:40 <EliasAmaral> i think it has a lot to do with the way you are used to think.. i like functional programming style, and i can usually think how some folds and maps can solve the problem. i know some people that had to study ML for some months and still can't bring to that easily (but instead to equivalent loop constructs)
08:53:45 <arw> amadan: yes, but that chasm is not so much the perceived freedom as it is the perceived "professionality". php is for beginners, ruby or python for pros.
08:53:50 <arw> amadan: something like that.
08:53:56 <EliasAmaral> but still i'm not comfortable with some (most?) haskell constructs
08:54:04 <monochrom> @quote religio
08:54:05 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
08:54:17 <kamatsu> EliasAmaral: I still haven't been able to work with Arrows effectively, but most of the other stuff is clear to me now
08:54:40 <amadan> arw: that i'll agree with. thus, "yippie, i can cast a string into an int" is much more a php people description than ruby/python people description.
08:54:44 <mreh> Arrows are so abstract, it's easy to fool yourself
08:55:25 <arw> amadan: not quite. pythons duck typing comes very close to "if i can cast it to string, it is string"...
08:55:39 <Blkt> good evening everyone
08:55:41 <kamatsu> arw: not cast, but convert
08:55:43 <EliasAmaral> if people studied some serious calculus lambda they would see things
08:55:51 <arw> amadan: its the same mindset, just with a more professional looking packaging.
08:55:51 <kamatsu> EliasAmaral: lambda calculus, not calculus lambda
08:55:51 <kmc> arw, not at all.  Python is much less liberal with implicit conversions than Perl or C++
08:55:56 <amadan> arw: i'm in ruby camp, wouldn't know. :)
08:56:04 <EliasAmaral> yeah, my english .-.
08:56:11 <monochrom> just use latin
08:56:23 <kamatsu> calculus de lambda
08:56:32 <arw> kamatsu: many casts are conversions.
08:56:38 <Jafet> The nii who say knights
08:56:40 <mreh> calculi lambda
08:56:42 <EliasAmaral> "cálculo lambda" was what i thought, but yeah, confusing languages
08:56:55 <mreh> ablative?
08:57:07 <monochrom> latin is a much more composable language
08:57:13 <kamatsu> arw: true, but casts in real type semantics doesn't imply changing the value of the type
08:57:17 <EliasAmaral> mreh, those linguistic terms are a lot obscure to me, i need a dictionary
08:57:18 <kamatsu> arw: it's moving up or down the subtype tree
08:57:35 <kamatsu> arw: not converting it to a completely different value
08:57:58 <kamatsu> monochrom: japanese is very composable too
08:58:00 <mreh> maybe it's calculi lambdorum
08:58:02 <arw> kamatsu: yes, true. but we are talking about languages which don't stick to that stricter meaning of the word.
08:58:23 <monochrom> english is for the "jippie, I can just use a noun as a verb" crowd
08:58:26 <kamatsu> arw: I try and use the general definition of the world in PL theory to prevent confusion
08:58:34 <amadan> mreh wins.
08:58:45 <kamatsu> English is alot like the Perl of natural languages.
08:58:45 <amadan> however, genitive, not ablative.
08:58:47 <mreh> \0/
08:58:59 <amadan> monochrom lol
08:59:10 <mreh> isn't that called a gerund?
08:59:30 <EliasAmaral> isn't gerund "thrashing"?
08:59:37 <monochrom> actually it should be s/verb/adjective/
08:59:45 <monochrom> english is for the "jippie, I can just use a noun as an adjective" crowd
08:59:46 <amadan> no, gerund is like english -ing, or latin -ndum, or...
08:59:46 <EliasAmaral> genitive would be thrash's
08:59:47 <BMeph> Calculus lambdalis! ;þ
08:59:55 <arw> kamatsu: I understand a "cast" to be some implicit or explicit change of a type. sometimes there is a conversion involved, like from int to float, sometimes there is no conversion, just a different interpretation, like from int to struct foo*.
08:59:59 <mreh> BMeph: I already won
09:00:02 <EliasAmaral> yes, -ing
09:00:09 <mreh> f-ing
09:00:17 <ManateeLazyCat> If anyone have important gtk2hs API need to add in next version, please ticket now, but don't too many, just most important you want, I'm cleaning ticket at http://hackage.haskell.org/trac/gtk2hs/report/1?asc=1&sort=type&USER=anonymous
09:00:27 <theorbtwo> arw: I normally think of "cast" only being an *explicit* change of type.
09:00:37 <kamatsu> arw: however that is actually not the definition of "cast" in type theory, hence the confusion
09:00:38 <theorbtwo> (Implicit type changes are "conversions".)
09:00:45 <arw> kamatsu: right.
09:01:00 <kamatsu> theorbtwo: in type theory, cast just means changing the type, not the value.
09:01:05 <theorbtwo> Yeah, but we're talking about C, not about type theory, right?
09:01:09 <kamatsu> theorbtwo: conversion is changing the value (and presumably the type)
09:01:29 <kamatsu> theorbtwo: we are talking about a variety of languages, so using the type theory terms seems most appropriate cos "cast" means different things in different languages
09:02:03 <kamatsu> in C a cast is an arbitrary coercion, except for int/float for convenience
09:02:14 <kamatsu> for strange values of "convenience"
09:02:42 <aristid> not to be forgotten: http://cheezburger.com/View/3749502464
09:02:45 <kamatsu> in Java a cast is actually a cast, except perhaps for int/float, but i'm not sure.
09:03:08 <monochrom> hahahaha
09:03:30 <kamatsu> in Python, well, "cast" isn't really applicable, only conversion is
09:03:45 <amadan> kamatsu: auto toString()ification...: "" + 5 --> "5"
09:03:55 <kamatsu> amadan: that's a conversion
09:04:00 <kamatsu> amadan: not a cast
09:04:07 <theorbtwo> In perl, we tend to just not use a generic.  We talk about stringification and nummification.
09:04:29 <kamatsu> theorbtwo: there's also scalarification for arrays
09:04:51 <theorbtwo> kamatsu: That tends to be "using in scalar context".
09:05:08 <kamatsu> theorbtwo: ah, true, because scalarification could also  refer to \
09:05:19 <amadan> kamatsu: ah, okay, i finally got the diff you're talking about :)
09:05:20 <theorbtwo> kamatsu: No, that's enreffing.
09:05:28 * BMeph prefers nomification. Oh, look, donuts! Om nom nom nom...
09:08:33 <kamatsu> Haskell has the best terminology of any language
09:08:44 <kamatsu> our terminology came from maths, so we're more right than everyone else
09:08:50 <kamatsu> so we can be smug in our terminology
09:09:10 <kamatsu> C++'s use of the word "Functor" is laughable! Ha!
09:12:36 <quicksilver> @faq can haskell make me even smugger?
09:12:36 <lambdabot> The answer is: Yes! Haskell can do that.
09:13:28 <BMeph> quicksilver: You'll never be as much of a git (heh-heh) as Linus Torvalds, so...yeah. ;)
09:26:37 <Tomsik> @src foldl
09:26:38 <lambdabot> foldl f z []     = z
09:26:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:26:51 <Tomsik> @src foldr
09:26:52 <lambdabot> foldr f z []     = z
09:26:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:27:34 <shapr> Good morning #haskell !
09:33:49 <shapr> How's code?
09:33:55 <jmcarthur> codey
09:35:01 <Saizan> incremental
09:35:12 <dv-> barely functional
09:35:49 <chrisdone> just created the cabal file
09:36:28 <proppy> Hi, has anyone used pandoc like a library ?
09:36:35 <chrisdone> yeah
09:36:39 <chrisdone> what's up?
09:37:27 <Tomsik> > fix (\n -> 3)
09:37:28 <lambdabot>   3
09:37:37 <Tomsik> > fix (\n -> if n == 3 then 3 else 3)
09:37:41 <lambdabot>   mueval-core: Time limit exceeded
09:37:51 <Tomsik> Can I ask, what the hell?
09:38:07 <proppy> chrisdone: I'm very new to haskell, I'm looking forward a bunch of html string coming from an sql database to import them into mediawiki
09:38:32 <proppy> chrisdone: I could call pandoc from the command line, but I have extra processing to do on the input string
09:38:54 <Jafet> How's benmachine's evaluator coming along, by the way?
09:38:59 <proppy> so I was wondering it would be possible to do that extra processing from an haskell script before calling pandoc
09:39:21 <proppy> it seems that http://johnmacfarlane.net/pandoc/scripting.html is what I'm looking for
09:39:37 <Saizan> Tomsik: here's how you use fix :) http://www.vex.net/~trebla/haskell/fix.xhtml
09:40:29 <djahandarie> Fully functional, doubtfully denotational
09:41:11 <Tomsik> Saizan: still, why is the second example not 3?
09:41:48 <Tomsik> \n -> 3 is equivalent to \n -> if n == 3 then 3 else 3, no?
09:42:10 <djahandarie> > (\n -> 3) 4
09:42:11 <lambdabot>   3
09:42:15 <tromp_> no
09:42:19 <djahandarie> > (\n -> if n==3 then 3 else 3) 4
09:42:20 <lambdabot>   3
09:42:26 <kmc> Tomsik, the latter is strict in n
09:42:29 <tromp_> it's const 3
09:42:33 <Tomsik> um
09:42:36 <Tomsik> == is strict?
09:42:46 <kmc> it has to pattern match its arguments
09:42:54 <kmc> think about how you might implement Int:
09:42:57 <Saizan> > undefined == 3
09:42:57 <lambdabot>   *Exception: Prelude.undefined
09:43:01 <benmachine> Jafet: wibble
09:43:05 * benmachine scrolls up a bit
09:43:18 <kmc> data Int = ... | I-3 | I-2 | I-1 | I0 | I1 | I2 | I3 | ...
09:43:31 <Jafet> Ah, I was just hoping for a link to it, little more
09:43:36 <kmc> Tomsik, then your implementation of (==) has a bunch of pattern-matching cases
09:43:46 <benmachine> Jafet: I've stalled at the moment on a conceptual issue, I was going to post it to the haskell-cafe about it When I Got Around To It
09:43:51 <benmachine> hmm
09:43:58 * benmachine tries to remember where the github is
09:44:13 <cuba> why doesnt my pattern matching of l [[]] = "" not trigger on an empty list
09:44:13 <Tomsik> Heck, I thought I could use fix somehow, because I've got step :: Interface a ⇒ IO (a, GameState) → IO (a, GameState)
09:44:21 <cuba> *list of lists
09:44:23 <kmc> cuba, [[]] is not an empty list
09:44:24 <Saizan> benmachine: the conceptual issue is about sharing?
09:44:31 <kmc> cuba, it's a list with one element, which is the empty list
09:44:34 <Tomsik> and run it till GameState is not Null
09:44:41 <benmachine> http://github.com/benmachine/stepeval
09:44:43 <benmachine> Saizan: sooort of
09:45:02 <Tomsik> or mfix, something like that
09:45:07 <cuba> :D thx mate
09:45:10 <lispy> ?hoogle mfix
09:45:11 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
09:45:20 <Saizan> Tomsik: fix is not about iterating a step function
09:45:24 <Saizan> Tomsik: nor mfix
09:45:34 <Tomsik> yeah, but I could pass current IO () 
09:45:39 <djahandarie> @hoogle untilM
09:45:40 <lambdabot> No results found
09:45:43 <benmachine> Saizan: basically, the currently failing testcase is case let ... in ... of ... -- when I've done the pattern matching and made me some bindings, it's hard to know where to put the 'let'
09:45:55 <djahandarie> @package monad-loops
09:45:55 <lambdabot> http://hackage.haskell.org/package/monad-loops
09:46:07 <djahandarie> untilM :: Monad m => m a -> m Bool -> m [a]
09:46:09 <kmc> cuba, the empty list is always [], no matter what type is inside, even another list type
09:46:33 <Jafet> Tomsik: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=fix+%28\n+-%3E+if+n%3D%3D3+then+3+else+3%29
09:46:52 <kmc> :O
09:46:59 <kmc> why is this not linked here more often
09:47:00 <Saizan> benmachine: because of variable capturing i guess?
09:47:01 <Jafet> Hmm, that script might need an output size as well as time limit
09:47:14 <BMeph> @package froot-loops
09:47:15 <lambdabot> http://hackage.haskell.org/package/froot-loops
09:47:36 <Tomsik> 404
09:47:38 <benmachine> Saizan: how do you mean
09:48:13 <kmc> @package best-package-evar
09:48:13 <lambdabot> http://hackage.haskell.org/package/best-package-evar
09:49:01 <BMeph> @package thats-what-SHE-said
09:49:01 <lambdabot> http://hackage.haskell.org/package/thats-what-SHE-said
09:49:21 <Jafet> @vixen Do you like getting "packages"?
09:49:22 <lambdabot> yeah, i like
09:49:38 <benmachine> @. package run text $ reverse "http://hackage.haskell.org/package"
09:49:38 <lambdabot> Plugin `compose' failed with: Unknown command: "package"
09:49:41 <benmachine> :(
09:49:58 <Saizan> benmachine: well, one way to do this would be to go from "case let <binds> in <e> of <alts>" to "let <binds> in case <e> of <alts>" and then just evaluate inside the "in" but you've to deal correctly with the scopes
09:50:23 <benmachine> Saizan: what about case xs ++ let xs = ... of ...
09:50:30 <benmachine> I guess I could just alpha that
09:50:39 <aristid> > text $ reverse "http://hackage.haskell.org/package"
09:50:40 <lambdabot>   egakcap/gro.lleksah.egakcah//:ptth
09:50:57 <aristid> @package egakcap/gro.lleksah.egakcah//:ptth
09:50:57 <lambdabot> http://hackage.haskell.org/package/egakcap/gro.lleksah.egakcah//:ptth
09:51:13 <benmachine> but, I wonder if aggressively moving lets about like that could lead to excessive sharing, even
09:51:30 <jmcarthur> @. package > text $ reverse "http://hackage.haskell.org/package"
09:51:31 <lambdabot> Plugin `compose' failed with: Unknown command: "package"
09:51:45 <benmachine> @help package
09:51:45 <jmcarthur> @. @package > text $ reverse "http://hackage.haskell.org/package"
09:51:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:51:46 <lambdabot> Plugin `compose' failed with: Unknown command: "@package"
09:51:55 <benmachine> the conclusion is @package doesn't exist
09:52:20 <jmcarthur> @@ package > text $ reverse "http://hackage.haskell.org/package"
09:52:20 <lambdabot>  package > text $ reverse "http://hackage.haskell.org/package"
09:52:24 <jmcarthur> haha
09:52:36 <Saizan> benmachine: mh, i didn't consider that could happen
09:52:38 <Tomsik> @@yo momma
09:52:43 <jmcarthur> wtf
09:53:16 <Veinor> mm_freak: to belatedly answer your question
09:53:21 <Veinor> it looks like just the wiki stylesheet was lost
09:53:26 <Saizan> benmachine: but i have feeling it can't unless you evaluate under lambdas or something like that :)
09:53:56 <benmachine> Saizan: it can't lead to excessive sharing?
09:54:07 <tommd> is there an "instance Random Word8" in a common package anywhere?
09:54:17 <benmachine> (just unclear on which "it" you're talking about now)
09:54:17 <Saizan> benmachine: "can't" referred to that, yeah
09:54:19 <benmachine> right
09:54:20 <benmachine> ok
09:54:25 <benmachine> you may be right
09:55:17 <benmachine> in principle if you respect the names you should always be able to squeeze 'let's out to the outside, I think
09:55:28 <benmachine> so I might try that, thanks
09:56:09 <Saizan> np, took the idea from wadler anyhow :)
09:57:05 <benmachine> heh
09:57:18 <Jafet> case let foo in bar of baz --> let foo; x = bar in case x of baz?
09:57:50 <benmachine> Jafet: the x is superfluous surely?
09:58:01 <benmachine> case let foo in bar of baz --> let foo in case bar of baz
09:58:05 <Jafet> Why yes it is
10:04:12 <sm___> morning all
10:04:23 <djahandarie> Morning!
10:04:26 <djahandarie> Afternoon here though
10:04:36 <kmc> hi everyone
10:04:39 <sm___> good afternoong djahandarie
10:04:46 <sm___> I wonder why does http://www.haskell.org/ghc/docs/6.12.2/html/Cabal/builders.html#prefix-independence refer to windows and hugs ?
10:05:35 <djahandarie> Because people use Windows
10:05:43 <djahandarie> I don't think people use Hugs but who knows
10:05:48 <dcoutts> sm___: because it's true of windows and hugs, not of ghc or unix
10:05:52 <kmc> sm___, it's describing a feature which is available on Windows and on Hugs
10:06:16 <kmc> it could be implemented on Linux, too
10:06:19 <dcoutts> though we may be able to implement it for ghc on unix in future
10:06:21 <kmc> i'm not sure about standard POSIX
10:06:28 <dcoutts> using the AUX vec stuff
10:06:32 <benmachine> oh hey I found a new bug, joy
10:06:40 <benmachine> Jafet: this is your fault!!
10:07:28 <sm___> so I'm confused about whether I can find my executable's path at runtime on unix
10:07:30 <sm___> with ghc
10:07:42 <kmc> sm___, on Linux you can read the symlink in /proc/self/exe
10:07:49 <sm___> I'll just carry on with Paths_pkgname.getDataFileName I guess
10:07:56 <sm___> kmc: thx
10:08:03 <dcoutts> sm___: you can, it's just not always 100% reliable
10:08:09 <sm___> ack
10:08:10 <dcoutts> nor is it totally portable
10:08:12 <benmachine> $ ls -l /proc/self/exe
10:08:12 <benmachine> lrwxrwxrwx 1 ben users 0 Jul 16 18:08 /proc/self/exe -> /bin/ls
10:08:16 * benmachine brain melt
10:08:34 * kmc ♥ procfs
10:08:36 <dcoutts> sm___: Paths_pkgname.getDataFileName is the right solution.
10:08:45 <sm___> thx dcoutts
10:08:53 <dcoutts> sm___: if we ever get prefix independence working for ghc on unix then that'll still work
10:09:19 <sm___> ok, my real/next question.. does the Paths module normally define "version" as well ? pandoc seems to want it, and I haven't found the specification for that file
10:09:35 <dcoutts> sm___: it does, yes, you can look at the generated file
10:09:38 <deech> Hi all, has anyone successfully used Hare for refactoring, it complains about all kinds of syntax errors in the source file when GHC compiles it just fine. 
10:09:46 <sm___> ok thx
10:10:13 * benmachine cd /proc/self/cwd
10:10:15 <kmc> deech, afaik hare only supports Haskell 98, and no GHC extensions
10:10:43 <kmc> $ pwd
10:10:43 <kmc> /proc/self/cwd/cwd/cwd/cwd/cwd/cwd/cwd/cwd/cwd/cwd/cwd/cwd/cwd/cwd
10:10:45 <sm___> oh neat.. lots of stuff in there
10:11:02 <Tomsik_> ./proc/self/exe
10:11:03 <benmachine> heh
10:11:04 <Tomsik_> ???
10:11:25 <kmc> should launch your shell
10:11:30 <Tomsik_> didn't do a lot :/
10:11:37 <Tomsik_> yeah
10:11:51 <mauke> % ./proc/self/exe
10:11:51 <mauke> zsh: no such file or directory: ./proc/self/exe
10:12:06 <deech> kmc: ah that explains it. Is there a reason for that? Don't the Language modules allow you read in GHC-compatible Haskell code? In any case, it's a nice tool, hope we can use it for production in the near future!
10:12:12 <benmachine> why the .
10:12:24 <kmc> deech, i don't know the reason
10:12:33 <aristid> mauke: /proc is global, so no ./
10:13:36 <mauke> blame Tomsik_
10:13:48 <proppy> Hi, how do I get captured group from a haskell regexp ?
10:14:02 <Heffalump> it's one of the return values from matchRegex
10:14:03 <Tomsik_> yeah, it's easiest to blame me, as usual
10:14:03 <benmachine> $ /usr/bin/stat exe File: `exe' -> `/bin/bash'
10:14:07 * benmachine wonders about this
10:14:14 <proppy> Prelude Text.Regex.Posix>  "<multi>[fr]foo[en]</multi>" =~ "<multi>(.*)" :: String
10:14:16 <proppy> "<multi>[fr]foo[en]</multi>"
10:14:32 <proppy> while I would except it to return everying after <multi>
10:14:38 <benmachine> proppy: use a different return type
10:14:54 <benmachine> I can't remember exactly what
10:14:54 <kmc> ugh, Text.Regex API is so bad
10:14:56 <benmachine> but there are loads
10:15:04 <proppy> reading http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
10:15:19 <benmachine> > "<multi>[fr]foo[en]</multi>" =~ "<multi>(.*)" :: [[String]]
10:15:21 <lambdabot>   [["<multi>[fr]foo[en]</multi>","[fr]foo[en]</multi>"]]
10:15:43 <proppy> (String, String, String, [String])
10:15:52 <proppy> also work
10:16:03 <proppy> I believe this is (before, match, after, [groups]) ?
10:16:05 <sm___> agreed, Text.Regex *really* needs at least a good tutorial for newcomers
10:16:17 <sm___> I still haven't grokked it, and often reach for regexpr instead
10:16:24 <kmc> it needs a good complete API redesign
10:16:39 <kmc> regexpr looks a lot nicer, thanks for mentioning it
10:16:41 <benmachine> it needs burning and replacing with parsec :P
10:16:54 * benmachine hammers round pegs into square holes
10:17:00 <sm___> kmc: np, be aware it can underperform in some cases
10:17:11 <proppy> how I do espace '[' in a pattern ?
10:17:19 <sm___> time or memory wise, I forget which
10:17:26 <kmc> proppy, in a regex?
10:17:29 <proppy> yes
10:17:30 <benmachine> proppy: \[ would be my first guess
10:17:42 <benmachine> [[] might also work?
10:17:42 <proppy> Prelude Text.Regex.Posix>  "<multi>[fr]foo[en]</multi>" =~ "<multi>(.*)\[en\](.*)</multi>" :: [[String]]
10:17:44 <kmc> but \ is also an escape in Haskell string syntax
10:17:46 <proppy> <interactive>:1:46:
10:17:47 <kmc> so \\[
10:17:48 <proppy>     lexical error in string/character literal at character 'e
10:17:52 <benmachine> oh, right yes
10:17:57 <benmachine> that always gets me
10:18:04 <proppy> benmachine: thanks :)
10:18:09 <proppy> kmc: thanks :)
10:18:27 <proppy> I'm trying to filter a string before getting it throught pandoc
10:18:41 <proppy> I hope doing regexp is not a bad way to do it
10:19:03 <benmachine> proppy: personally I think something like parsec is easier to use, but would probably be more verbose
10:19:15 <proppy> didn't know about parsec
10:19:18 <proppy> googling
10:19:34 <benmachine> parsec is a proper full-featured parser, but it's fairly easy to use
10:19:50 <kmc> easy to use, but not so easy to learn imo
10:19:59 <kmc> you need to learn things like left-factoring and when to use 'try'
10:20:08 <benmachine> hmm, true I guess
10:20:18 <kmc> i definitely had a lot of awkward trial-and-error until the 5th or 6th parser i wrote
10:20:26 <benmachine> I have a pathological tendency to work really hard to understand something
10:20:31 <kmc> maybe i'm dumb though
10:20:32 <benmachine> and then think it's really obvious after having done so
10:20:39 <proppy> I need to get 'foo' from <multi>[fr]foo[en]bar</multi> and possibly <multi>[fr]foo</multi>
10:20:51 <sm___> parsec is awesome, HAIL PARSEC
10:20:53 <jmcarthur> i've used parsec several times and still keep forgetting when try is necessary
10:20:53 <proppy> currently I have  =~ "<multi>(.*)(\\[en\\].*)?</multi>" :: [[String]]
10:21:01 <kmc> proppy, i think regex is an okay solution
10:21:04 <proppy> ok
10:21:10 <jmcarthur> i prefer applicative parser combinators when possible
10:21:23 <benmachine> hmm, ReadP is backtracking by default
10:21:38 <benmachine> I vaguely recall trying to use it for a bit and then going screw this, I'm going back to parsec
10:22:37 <proppy> should I use quickcheck to check for discrete input / output ?
10:22:43 <kmc> what do you mean?
10:22:47 <proppy> or is there a more suitable library
10:23:03 <proppy> like asserting that a function return x when called with 'a'
10:23:26 <kmc> quickcheck is mainly designed for generating inputs randomly
10:23:33 <proppy> IIRC quickcheck is more usefull for checking a range of input satisfaying one constraint
10:24:08 <kmc> if you just have (input, output) pairs
10:25:06 <kmc> then it's easy enough to write yourself
10:25:31 <proppy> kmc: is there an assert statement ?
10:25:57 <kmc> no, but there is an assert function
10:26:03 <kmc> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Exception.html#v:assert
10:26:13 <proppy> :0
10:26:17 <proppy> thanks a lot :)
10:26:21 <kmc> you have to arrange for the value to be actually evaluated though
10:26:24 <proppy> sorry for the confusion (statement vs function)
10:26:28 <kmc> no worries :)
10:26:46 <kmc> 'statement' is a syntactic class
10:26:53 <kmc> Haskell is less statement-based and more expression-based than, say,  C
10:27:07 <djahandarie> There is also HUnit
10:27:12 <kmc> proppy, to check a list of input,output pairs i wouldn't use assert though
10:28:45 <kmc> :t let test f ps = catMaybes [if f x == y then Nothing else Just n | (n,x,y) <- ps] in test
10:28:46 <proppy> kmc: I'm writing my very first line of real haskell code, so every suggestion is welcome
10:28:46 <lambdabot> forall t a a1. (Eq a) => (t -> a) -> [(a1, t, a)] -> [a1]
10:28:58 <kmc> > let test f ps = catMaybes [if f x == y then Nothing else Just n | (n,x,y) <- ps] in test succ [("s2", 2, 3), ("wrong", 3, 9)]
10:28:59 <lambdabot>   ["wrong"]
10:29:03 <kmc> returns a list of failed tests
10:30:10 <kmc> proppy, the trick with "assert" is that whether your assertion is ever checked depends on whether you actually evaluate the expression containing "assert"
10:31:05 <proppy> so if you write an expression like
10:31:11 <kmc> :t let test f ps = catMaybes [guard (f x /= y) >> Just n | (n,x,y) <- ps] in test
10:31:12 <lambdabot> forall t a t1. (Eq a) => (t -> a) -> [(t1, t, a)] -> [t1]
10:31:25 <proppy> testSomething = assert (add 1 2) 3
10:31:36 <proppy> testSomethingElse = assert (sub 3 1) 2
10:31:53 <proppy> you have to make a list of testSomething* in order to evaluate all of them ?
10:32:21 <sm___> ghci not loading modules interpreted in constantly tripping me up, I wish it were more automatic. I mean that is why I have turned to ghci, to poke at things
10:32:28 <sm___> s/in/is/
10:35:47 <augur> kmc: how does the runtime know to stop trying to execute? is there an instance of IO that is a sort of "end program"?
10:38:25 <kmc> augur, well, there is System.Exit.exitWith and such
10:38:29 <augur> ok.
10:38:40 <kmc> augur, but also, if you consider IO actions as sequences of primitive steps glued together with (>>)
10:38:43 <dons> augur: well, it reduces the program until 'main' is reduced to a value
10:38:44 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:38:45 <kmc> then it might be a finite sequence
10:38:52 <augur> ok, true.
10:39:04 <aliraz> greetings haskellers, I have a rather theoretical question
10:39:05 <augur> i suppose that makes sense
10:39:12 <kmc> aliraz, we specialize in those ;)
10:39:17 <dons> e --> v, v `elem` [(), exitWith, <exception>]
10:39:17 <aliraz> I must say it maybe even philosophical to some extent 
10:39:23 <kmc> oh boy
10:39:33 <aliraz> I have been thinking about the notion of "types" in general 
10:39:59 <aliraz> from PL theory course, I remember that the denotational semantics of types in general are expressed as CPOs 
10:40:46 <aliraz> I am trying to understand the motivation for this, as I am at the moment trying to devise semantics for types in non-programmatic settings, e.g., UML models
10:40:56 <aliraz> *UML data models* I should say 
10:41:19 <aliraz> so the only reason I can think of for denoting types as CPOs in domain theory 
10:41:34 <kmc> what do you mean by the denotational semantics of types?
10:41:34 <aliraz> it to give an appropriate treatment to recursive type defenitions, 
10:41:41 <kmc> what do the judgements look like?
10:41:55 <aliraz> can someone come up with other intuitions for that?
10:42:34 <aliraz> well, what I mean by it is the theoretical apparatus used to explicate the meaning of typing values 
10:42:53 <aliraz> what does it mean to write x :: Int or f :: Int -> Int ?
10:43:46 <kmc> ah, so the denotation of a type is a set of values or so?
10:44:00 <aliraz> kmc, almost
10:44:16 <aliraz> but sets are not adequate to capture all the intricacies of dealing with recursive types, amongst other issues
10:44:20 <aliraz> hence domains and cpos
10:44:37 <aliraz> in other words, sets alone become paradoxical
10:44:40 <kmc> ok
10:45:21 <aliraz> the caveat is that my main area is not PL theory, so I am hoping to be corrected
10:52:16 <Tomsik_> no MonadPlus IO? :(
10:53:14 <c_wraith> Tomsik_: what would mzero be?
10:53:36 <Tomsik_> Well, something that forces it to be a zero? :p
10:53:48 <Tomsik_> no $guard
10:53:57 <Tomsik_> it's sad
10:54:08 <c_wraith> the MonadPlus laws really can't apply to IO
10:54:54 <BMeph> Tomsik_: An easy counter-example for IO being in MonadPlus is " what should  'getLine >> return ()' do?" 
10:55:04 <c_wraith> the main MonadPlus law that's hard for IO is: mzero === mzero >> a === a >> mzero
10:55:10 <BMeph> s/return ()/mzero/
10:56:05 <kmc> mzero = throwIO (ErrorCall "urk"); mplus a b = a >>= catch (\(_ :: SomeException) -> b)
10:56:16 <djahandarie> lol what
10:56:20 <c_wraith> kmc: doesn't obey the mzero law
10:56:20 <lispy> How does project management work on code.haskell.org?  How do you add/substract people from projects?
10:56:29 <lispy> It seems like you have to contact an admin?
10:56:51 <djahandarie> c_wraith, even if it did I feel like I would have some ideological duty to hold against not having that
10:57:01 <c_wraith> kmc: with that definition, a >> mzero is not the same as mzero or mzero >> a
10:57:54 <Tomsik_> whoooo, I've got a walking @ on the screen
10:58:03 <Tomsik_> :p
10:58:17 <alpounet> lispy, see http://community.haskell.org/
10:58:19 <alpounet> and the page it links to
10:58:29 <Tomsik_> in 97 lines of code, which half of is redundant
10:58:37 * djahandarie imagines a @ with arms and legs dancing
10:59:31 <Tomsik_> It's one step closer to my not-quite-roguelike space game! :p
11:00:23 <c_wraith> Tomsik_: You probably want something like MaybeT IO to get MonadPlus semantics around IO.
11:00:42 <Tomsik_> Well, honestly, I just used an old-fashioned if
11:00:56 <Tomsik_> I don't feel comfortable with monad transformers
11:00:58 <Cale> btw, IO is already a MonadPlus instance
11:01:11 <Cale> (the instance uses exceptions)
11:01:34 <c_wraith> Cale: in what package?
11:01:40 <c_wraith> Or module, at least?
11:01:48 <Cale> Let me check :)
11:02:00 <c_wraith> It's not in Control.Monad.Instances
11:02:01 <Tomsik_> > putStr "a" >> mzero
11:02:02 <lambdabot>   Ambiguous type variable `b' in the constraint:
11:02:02 <lambdabot>    `Data.Typeable.Typeable b...
11:02:07 <Cale> hmm
11:02:15 <Tomsik_> > putStr "a" >> mzero :: IO ()
11:02:16 <lambdabot>   <IO ()>
11:02:23 <Cale> ah, Control.Monad.Error has one
11:02:31 <c_wraith> Like I said, exceptions can't actually obey the MonadPlus laws.
11:02:41 <c_wraith> oh, so yet another broken instance from Control.Monad.Error? :)
11:02:53 <jmcarthur> *sigh*
11:02:58 <Tomsik_> Errors are a broken tool in their very own concept :p
11:03:19 <sm___> hmmm.. is there a way to configure pandoc (programmatically) to not convert tabs to spaces ?
11:03:40 <sm___> I'm trying to parse vimoutliner format, where tabs are important
11:04:38 <Cale> The problem with MonadPlus is that it's currently being used to mean a lot of different things
11:04:43 <kmc> Tomsik_, yes, our programs should be proven correct before we run them
11:05:14 <Cale> But yeah, being a monoid would normally be somewhat important.
11:05:15 <Tomsik_> Yeah
11:05:24 <jmcarthur> isn't it supposed to be a monoid regardless of whatever other laws we use?
11:05:26 <jmcarthur> yeah
11:05:31 <Tomsik_> if there's something you can't do with Maybe, it's wrong! :p
11:05:55 <jbapple> I'm trying to write a C-like layer for imperative computation. Because C code can "return" or "break" at any point, my monad has cases for this. The problem is, every computation has to check if the previous one entered one of these states, so most of the computation time (profiling seems to be telling me) is spent in bind, I assume checking for breaks or early returns that aren't happening.
11:06:06 <jbapple> Since I expect these things to be rare, is there a way to speed up the bind operation?
11:06:21 <Cale> actually, hang on
11:06:29 <Cale> This is a monoid instance.
11:06:32 <jbapple> I was thinking of trying delimited continuations or perhaps exceptions in the IO monad
11:06:32 <lispy> alpounet: thanks
11:07:03 <jmcarthur> oh right
11:07:07 <jbapple> But I'd rather be in the ST monad, so I'd like to avoid exceptions
11:07:11 <monochrom> yes, continuations or delimited continuations will help
11:07:14 <jmcarthur> mzero `mplus` a = a
11:07:22 <Cale> right
11:07:28 <jbapple> OTOH, I don't understand how delimited continuations could be faster than what I've got
11:07:36 <Cale> and  a `mplus` mzero = a  as well.
11:07:40 <Cale> Well...
11:07:49 <Cale> It might alter which exception you get.
11:07:53 <c_wraith> It's not a when you consider the effects produced by the IO
11:07:59 <Cale> c_wraith: huh?
11:08:02 <jmcarthur> yes it is
11:08:21 <jbapple> monochrom: I really only need abort -- how to delim conts handle that without checking for it on every bind?
11:08:24 <jmcarthur> it just doesn't have a right zero, which isn't necessary anyway
11:08:46 <monochrom> not sure about delimited continuations. but the usual kind of continuations (like Cont) is found to be faster than pattern matching on data.
11:08:48 <c_wraith> (print 5 >> mzero) `mplus` print 10 is not the same as print 10
11:08:50 <jmcarthur> a >> mzero  -- not required to be mzero
11:08:56 <jmcarthur> right
11:08:58 <jbapple> I'm still trying to decipher the code, which is much more general than my case, and so not as simple
11:09:09 <Cale> c_wraith: it's not necessarily supposed to be
11:09:13 <jmcarthur> mzero >> a = mzero
11:09:16 <jmcarthur> but the other way is not necessary
11:09:22 <Cale> c_wraith: You used a different law there :)
11:09:39 <jbapple> monochrom: I'll see if I can make them work. Thanks for the tip
11:09:45 <c_wraith> cale, that's true.
11:10:11 <jmcarthur> it's kind of... ugly though :\
11:10:12 <c_wraith> eh?  a >> mzero is not required to be mzero?
11:10:16 <jmcarthur> no
11:10:17 <Cale> Right.
11:10:20 <c_wraith> Oh, ick.
11:10:24 <jmcarthur> at least not according to http://www.haskell.org/haskellwiki/MonadPlus
11:10:58 <jmcarthur> left distribution and left catch are the laws that don't seem to be standardized
11:11:07 <jmcarthur> left catch appears to be in most (all?) instances
11:11:11 <jmcarthur> err
11:11:13 <jmcarthur> left zero
11:11:20 <kmc> jbapple, i'd use continuations
11:11:27 <kmc> ContT ST ?
11:11:39 <kmc> @unmtl ContT ST a
11:11:39 <lambdabot> err: `ContT ST a' is not applied to enough arguments, giving `/\A. (A -> a ST) -> a ST'
11:11:43 <kmc> @unmtl ContT (ST s) a
11:11:44 <lambdabot> err: `ContT (ST s) a' is not applied to enough arguments, giving `/\A. (A -> a (ST s)) -> a (ST s)'
11:11:49 <kmc> @unmtl ContT r (ST s) a
11:11:49 <lambdabot> (a -> ST s r) -> ST s r
11:11:52 <kmc> durr de derr
11:12:04 <monochrom> here is what I mean. suppose conceptually you want your function to return an Either, and its caller will decide what to do next based solely on Left or Right. you have two choices: really use Either; or the function takes two continuations from the caller, and invokes one of them, skipping the Either type and pattern matching. The latter is found to be faster.
11:12:19 <jmcarthur> ew, ContT on top of ST
11:12:36 <kmc> why not?
11:12:42 <kmc> as a model of C
11:12:50 <jmcarthur> sure
11:12:58 <jbapple> monochrom: That explanation makes a lot of sense to me
11:12:58 <kmc> C control flow doesn't revert mutation; neither does ContT r (ST s)
11:13:05 <proppy> kmc: thanks a lot for your help, got to go
11:13:06 <jmcarthur> but i don't like* C's model ;)
11:13:15 <jmcarthur> **like*
11:13:16 <kmc> heh
11:13:44 <jbapple> kmc: I'll try ContT, thanks for the tip
11:15:28 <kmc> jbapple, or you could rewrite your existing monad into continuation-passing style
11:15:44 <Cale> Interesting, mplus won't catch any exception except those thrown by mzero
11:15:58 <jmcarthur> woah
11:16:31 <zygoloid> Cale: which mplus won't?
11:16:35 <jbapple> kmc: I was just thinking about that! I ended up writing my own monad and monad transformer ad I was trying to understand ErrorT, and it really helped
11:16:36 <jmcarthur> IO i assume
11:16:41 <Cale> zygoloid: The one for IO
11:16:47 <zygoloid> IO's mplus definitely does catch other exceptions
11:16:49 <monochrom> mzero says: "everybody loves my mplus but my mplus loves only me"
11:16:58 <zygoloid> i have some working code which uses mplus to catch the exception from readFile
11:17:09 <Cale> hmmm
11:17:33 <jbapple> kmc: My concern is that I might write a slow one
11:17:36 <Cale> oh, *that* works
11:18:03 <jmcarthur> throw (IndexOutOfBounds "bar") `mplus` putStrLn "foo"
11:18:04 <zygoloid> did i luck into the one case which works? ;-)
11:18:07 <jmcarthur> ^^ doesn't catch it
11:18:22 <Cale> Maybe it only catches H98 IO exceptions
11:18:28 <zygoloid> i'm guessing it only catches the haskell'98... yeah
11:18:31 <Cale> and not new-style exceptions
11:19:02 <jmcarthur> does undefined throw a new style exception or a h98 one?
11:19:44 <Cale> Well, it produces an asynchronous exception
11:19:53 <Cale> which is yet another thing :)
11:19:56 <jmcarthur> ah
11:20:02 <jmcarthur> jeez so many
11:20:10 * monochrom fmaps the math asylum d/dx, e^x, d/dy joke into a haskell one.
11:20:15 <Cale> We really ought to eliminate the H98 IO exceptions
11:20:20 <zygoloid> where does the MonadPlus IO instance live anyway? :)
11:20:26 <jmcarthur> Control.Monad.Error
11:20:27 <Cale> Control.Monad.Error
11:20:46 <zygoloid> huh, it's an orphan? :(
11:20:52 <Cale> zygoloid: yeah
11:21:11 <jmcarthur> i really wish we had a better story for orphans
11:21:34 <jmcarthur> especially regarding multiple packages
11:21:47 <monochrom> "in a haskell asylum, there is a patient called 'catch' and all other patients avoided him. except for the patient called AsynException..."
11:22:08 <monochrom> err, AsyncException
11:22:23 <jmcarthur> AsylumException
11:29:24 <BMeph> InsaneException
11:32:37 <opqdonut> ProveRuleException
11:43:34 <mightybyte> Wow, I've never seen #haskell this quiet.
11:43:44 <zygoloid> RAAAAAAH!
11:44:00 <aristid> mightybyte: for quiet hours: http://cheezburger.com/View/3749502464
11:44:09 <monochrom> good sign, people work rather than talk
11:44:37 * monochrom prefers silence to press-conference-kind questions
11:44:59 <monochrom> "what is the real benefit of fold" sheesh
11:46:53 <jmcarthur> is haskell a good language?
11:47:06 <aristid> jmcarthur: no
11:47:07 <mtnviewmark> uhm.... YES!
11:47:09 <aristid> next question
11:47:09 <mightybyte> How does using Haskell make you feel?
11:47:09 <Tomsik_> yeah
11:47:14 <EvanR-work> it has the if statement, but i cant seem to find the for loop
11:47:16 <aristid> mightybyte: warm and fluffy
11:47:18 <EvanR-work> it must suck
11:47:21 <jmcarthur> is it better than something like C++?
11:47:33 <monochrom> hahaha
11:47:52 <mtnviewmark> what is this? a survey from some government labor bureau? 
11:47:57 <kmc> haskell sucks, prove me wrong
11:48:14 <aristid> haskell doesn't even have object oriented
11:48:15 <Tomsik_> http://pastebin.ca/1901938
11:48:16 <kmc> @protontorpedo
11:48:16 <lambdabot> ok is haskell a type of lisp?
11:48:21 <jmcarthur> can i get a job in game development if i know haskell?
11:48:25 <Tomsik_> I wonder how much of C++ code would you need to get that far :p
11:48:36 <kmc> why should i learn haskell when there are so few jobs
11:48:53 <Tomsik_> whoops, game.hs is pasted wrong
11:48:54 <kmc> types are unnecessary with proper unit testing
11:49:07 <jmcarthur> haskell is supposed to only allow correct code, right? that's what my friend told me
11:49:26 <aristid> jmcarthur: when the program typechecks, it is guaranteed to be correct.
11:49:29 <Tomsik_> I have to get a degree in math to code in haskell, rite?
11:49:33 <kmc> you liberal elitist egghead academics are just out of touch with the common-sense hardworking real-world programmers
11:49:37 <jmcarthur> do they use haskell at NASA?
11:50:12 <monochrom> they use lisp at nasa
11:50:16 <EvanR-work> does haskell support extreme programming
11:50:24 <Tomsik_> what are these monadoids?
11:50:28 <kmc> no, only xtreme programming
11:50:40 <jmcarthur> i heard monads are hard. why is that?
11:50:42 <Tomsik_> where are arrays in haskell?
11:50:45 <aristid> Tomsik_: the dual of comonadoids
11:50:55 <kmc> i heard haskell has no side effects, that means you can't write a game or an IRC bot
11:51:09 <kmc> ok we should probably stop at some point
11:51:10 <kmc> ;)
11:51:17 <Tomsik_> i herd that means it doesn't destroy hardware, kmc
11:51:19 <jmcarthur> kmc: i heard that monads are a good enough hack to get around that
11:51:38 <kmc> i herd u liek mudkipz
11:52:28 <Tomsik_> i herd liek monadz
11:52:45 <jmcarthur> one of these days i'm going to come in with a different nick and troll the hell out of you guys
11:52:46 <EvanR-work> haskell forces me to write programs not in the way i think
11:53:08 <jmcarthur> just to see what it feels like
11:53:14 <zygoloid> i cannot haskell when i haz the dums
11:53:15 <aristid> EvanR-work: you think in terms of algorithms of the form 1. do this 2. do that 3. check x and go to step 1?
11:53:19 <Tomsik_> I herd u liek monads so i put a monad in a monad so you can IO while u list
11:53:23 <EvanR-work> aristid: yes
11:53:25 <zygoloid> i can c++ when i haz the dums but my code crashes, fix it for me?
11:53:38 <EvanR-work> add two numbers, store the result in register x
11:53:42 <jmcarthur> haskel guys r smart rite?
11:53:56 <EvanR-work> multiply previous result, im going to optimize and store it in x too since i dont need x anymore
11:54:05 <EvanR-work> that makes way more sense
11:54:12 <kmc> you should always optimize code as much as you can right when you write it
11:54:36 <Tomsik_> compilers suck at optimizing, that's why C code is the best
11:54:44 <kmc> no, assembly
11:54:52 <kmc> that way you can use "xor %eax, %eax"
11:54:57 <kmc> no compiler on the planet is that clever
11:55:04 <Tomsik_> and write x<<2+x<<1 when you want to multiply by 10
11:55:28 <zygoloid> whod use c, everyone nos that php is faster than averything
11:55:38 <Tomsik_> no python
11:55:45 <zygoloid> c doesnt evan have http
11:55:51 <Tomsik_> you heard that java has generics?
11:55:57 <jmcarthur> lol faster at crashing
11:55:59 <Tomsik_> I bet haskell doesn't have anything liek that
11:56:01 <aristid> zygoloid: and you don't need a degree in rocket science to learn PHP
11:56:12 <Tomsik_> coz Java is developed by the INDUSTRY!
11:56:12 <zygoloid> aristid: just to understand other peoples' code
11:56:53 <jmcarthur> Tomsik_: i think java even has null and everybody knows you need null to do real programming
11:57:42 <Tomsik_> but c has void
11:57:57 <Tomsik_> it's like, you can point to int and string AT THE SAME TIME!
11:58:08 <jmcarthur> i bet you can't write an operating system in haskell like you can in python
11:58:31 <jmcarthur> hardware doesn't understand functions
11:58:37 <jmcarthur> python works like your hardware does
11:58:40 <Tomsik_> I heard microsoft writes next windows in C#, it's so low-level
11:58:42 <jmcarthur> haskell doesn't
11:58:47 <monochrom> you people must be really bored :)
11:59:34 <c_wraith> Do people really use ListT IO?
11:59:37 <Tomsik_> > [reverse [1...]] >> [1] 
11:59:38 <lambdabot>   A section must be enclosed in parentheses thus: (1 ...)Not in scope: `...'
11:59:46 <Tomsik_> > [reverse [1..]] >> [1] 
11:59:47 <lambdabot>   [1]
11:59:59 <Tomsik_> u see, it reverses infinite list in no tiem
12:00:16 <c_wraith> @check \x -> x == reverse x
12:00:17 <lambdabot>   "OK, passed 500 tests."
12:00:25 <c_wraith> that's because lists are their own reverse, duh
12:01:13 <Tomsik_> what is this Nothing, why'd you waste space for this
12:03:30 <Tomsik_> what is this emoticon IO()
12:03:44 <Zao> @src Maybe
12:03:44 <lambdabot> data Maybe a = Nothing | Just a
12:03:55 <Zao> Tomsik_: Troll much?
12:04:17 <Tomsik_> I think trolling would have to be less obvious to be trolling
12:04:29 <c_wraith> Zao, there's a reason the rest of us were playing along. :)
12:04:52 <c_wraith> (and that reason was obviously so that newbies who were scared to talk were convinced of lies about the language, of course)
12:04:54 <tommd> Yeah, like claiming "Haskell is no good and you could prove it if you could be bothered to learn what Haskell is."
12:05:30 <zygoloid> everyone knoes real languages have IOT
12:05:37 <Zao> c_wraith: Skimmed my channels and saw the last couple of lines.
12:05:48 <aristid> zygoloid: and STT
12:06:20 <zygoloid> hmm. is STT actually impossible or just hard to implement?
12:06:37 <soupdragon> impossible
12:06:43 <zygoloid> i guess it'd just require a different implementation of ST
12:11:21 <c_wraith> It's impossible if you use true mutation.  And if you don't use true mutation, ST is just a more-limited State, so why bother?
12:12:41 <kmc> this came up yesterday
12:12:55 <kmc> if you implement ST as State (IntMap Dynamic)
12:12:58 * hackagebot alms 0.4.9.1 - a practical affine language  http://hackage.haskell.org/package/alms-0.4.9.1 (JesseTov)
12:13:03 <kmc> then how do you do garbage collection of IntMap keys?
12:13:07 <kmc> this i'm still not clear on
12:14:14 <c_wraith> Ah, and with lazy ST, that could cause real problems.
12:14:26 <kmc> a very clever STT could use true mutation in a DiffArray style
12:14:30 <kmc> but it's probably more trouble than it's worth
12:14:32 <kmc> like DiffArray ;P
12:14:39 * c_wraith thinks of the case of using lazy ST to generate an infinite list
12:15:20 <soupdragon> what about revising history to make the world a safter better place for our children?
12:15:51 * kmc thinks updating immutable arrays is almost never worth it in Haskell
12:16:05 <kmc> IntMap is fast and shares well
12:16:27 <c_wraith> DiffArray is such a cool concept, though.  It's a pure interface, and *should* be efficient for reads to the current version.
12:16:39 <c_wraith> There are just issues with constant factors.
12:16:44 <kmc> hmm
12:16:45 <c_wraith> For reasons I've never seen explained.
12:17:06 <kmc> how about memoizing IntMap lookup into an array?
12:17:18 <kmc> would this be a reasonable way to implement DiffArray?
12:17:33 <soupdragon> > 355/113 :: CREal
12:17:34 <lambdabot>   Not in scope: type constructor or class `CREal'
12:17:36 <soupdragon> > 355/113 :: CReal
12:17:38 <lambdabot>   3.141592920353982300884955752212389380531
12:17:58 <c_wraith> soupdragon has made near-pie
12:18:04 <soupdragon> > (9^+19^2/22)**(1/4) :: CReal
12:18:05 <lambdabot>   Not in scope: `^+'
12:18:07 <soupdragon> > (9^2+19^2/22)**(1/4) :: CReal
12:18:07 <aristid> > (355/113-pi) :: CReal
12:18:08 <lambdabot>   0.0000002667641890624223123689328864963338
12:18:08 <lambdabot>   3.1415926525826461252060371796440223715579
12:18:49 <c_wraith> @src pi
12:18:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:19:28 <edwardk> c_wraith: well, it basically comes down to the need to grab a lock for every read or write
12:20:23 <c_wraith> Hmm.  I wonder if it could be written such that reads didn't require the lock.
12:20:52 <EvanR-work> the source for pi is very large, in any rational base
12:20:53 <c_wraith> Probably not, if you wanted to maintain pure semantics in a concurrent environment
12:21:04 <c_wraith> EvanR-work: not really.
12:21:12 <EvanR-work> unless you cheat and use computation
12:21:31 <c_wraith> that's not cheating.
12:21:35 <EvanR-work> hehe
12:21:41 <soupdragon> pi = 1/2
12:21:58 <c_wraith> It's the only way to sanely define pi for CReal
12:22:02 <Tomsik_> pi = sqrt(10)
12:22:13 <c_wraith> And the fact that it happens to work for other types is a nice touch
12:22:14 <soupdragon> > sqrt(10) :: CReal
12:22:15 <lambdabot>   3.1622776601683793319988935444327185337196
12:22:15 <Tomsik_> > sqrt(10)-pi
12:22:16 <lambdabot>   2.0685006578586407e-2
12:22:30 <Tomsik_> > sqrt(10)-pi :: CReal
12:22:31 <lambdabot>   0.0206850065785860935362501611532156495224
12:22:51 <Tomsik_> I had my physics teacher in high school once simplify sqrt(10) with pi
12:23:18 <EvanR-work> > log(1000) :: CReal
12:23:18 <lambdabot>   6.9077552789821370520539743640530926228033
12:23:18 <soupdragon> haha
12:23:32 <soupdragon> > exp pi
12:23:33 <lambdabot>   23.140692632779267
12:23:41 <soupdragon> > log 23
12:23:43 <lambdabot>   3.1354942159291497
12:25:26 <aristid> > exp pi ^ 2
12:25:38 <lambdabot>   535.4916555247646
12:25:55 <soupdragon> > 535.5*2
12:25:58 <lambdabot>   1071.0
12:26:02 <Tomsik_> > e^pi
12:26:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:26:03 <lambdabot>    `GHC.Real.Integral a'
12:26:03 <lambdabot>   ...
12:26:13 <Tomsik_> > e
12:26:14 <lambdabot>   e
12:26:17 <Tomsik_> um
12:26:20 <soupdragon> > log(sqrt(10070))
12:26:21 <lambdabot>   4.608657992856304
12:26:27 <soupdragon> > log(sqrt(10070/2))
12:26:28 <lambdabot>   4.262084402576331
12:26:40 <soupdragon> > sqrt(log(10070/2))
12:26:42 <lambdabot>   2.9196179210904742
12:26:47 <Tomsik_> > 2.71^pi
12:26:48 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:26:48 <lambdabot>    `GHC.Float.Floating a'
12:26:48 <lambdabot>  ...
12:26:56 <Tomsik_> > 2.71^pi :: CReal
12:26:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:26:57 <lambdabot>    `GHC.Float.Floating a'
12:26:57 <lambdabot>  ...
12:27:04 <Tomsik_> err
12:27:13 <Tomsik_> > 2.71**pi :: CReal
12:27:14 <lambdabot>   22.919922428200682647309925055443327489151
12:27:23 <Tomsik_> > e**pi :: CReal
12:27:24 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
12:27:24 <lambdabot>         against infe...
12:27:29 <Tomsik_> okay, spamming much
12:27:40 <monochrom> use exp 1
12:28:58 <soupdragon> > log 23 / log 271
12:29:00 <lambdabot>   0.5596979136256133
12:29:01 <soupdragon> > log 23 / log 27.1
12:29:03 <lambdabot>   0.9502840323861086
12:29:09 <mreh> but how do I do e^2?
12:29:29 <mreh> > (^ 2) . exp $ 1 
12:29:30 <lambdabot>   7.3890560989306495
12:32:51 <monochrom> > exp 2
12:32:52 <lambdabot>   7.38905609893065
12:33:38 <burp> > exp 2 :: CReal
12:33:39 <lambdabot>   7.3890560989306502272304274605750078131803
12:34:52 <aristid> > showCReal 100 (exp 2)
12:34:52 <lambdabot>   "7.389056098930650227230427460575007813180315570551847324087127822522573796...
12:35:01 <aristid> > text $ showCReal 100 (exp 2)
12:35:02 <lambdabot>   7.3890560989306502272304274605750078131803155705518473240871278225225737960...
12:36:08 <soupdragon> @let minimize f x y = head . sortBy (comparing snd) $ [ ((a,b),f a b) | a <- x, b <- y ]
12:36:09 <lambdabot>  Defined.
12:36:48 <soupdragon> > minimize (\a b -> abs$ pi - b/sqrt(a)) [1..99] [1..99]
12:36:49 <lambdabot>   ((49.0,22.0),1.2644892673496777e-3)
12:37:01 <soupdragon> heh 22/7
12:39:05 <Tomsik_> > 22/7-pi
12:39:06 <lambdabot>   1.2644892673496777e-3
12:39:11 <Tomsik_> That's quite okay
12:40:04 <chrisdone> dons: ping
12:41:56 <soupdragon> > 6^3/50 - sqrt(50)/6
12:41:57 <lambdabot>   3.141488698022421
12:42:24 <soupdragon> @let minimize' f x y z = head . sortBy (comparing snd) $ [ ((a,b,c),f a b c) | a <- x, b <- y, c <- z ]
12:42:26 <lambdabot>  Defined.
12:42:50 <djahandarie> soupdragon, you sure seem to like these things that estimate numbers like pi and e
12:43:39 <Veinor> > exp (pi * sqrt 163)
12:43:49 <lambdabot>   2.6253741264076826e17
12:44:03 <Veinor> > exp (pi * sqrt 163) - 640320 ** 3
12:44:04 <lambdabot>   256.0
12:44:10 <Veinor> ...
12:44:13 <Veinor> that's not right.
12:45:48 <aristid> > log(256 + 640320**3)
12:45:49 <lambdabot>   40.10916999113252
12:46:01 <aristid> > log(256 + 640320**3) / sqrt(163)
12:46:02 <lambdabot>   3.141592653589793
12:46:06 <Veinor> :D
12:46:08 <aristid> > log(256 + 640320**3) / sqrt(163) - pi
12:46:09 <lambdabot>   0.0
12:46:12 <aristid> > log(256 + 640320**3) / sqrt(163) - pi :: CReal
12:46:13 <lambdabot>   -0.0000000000000001455910971885487716825053
12:46:26 <aristid> Veinor: not bad
12:46:45 <aristid> > 256 + 640320^3
12:46:46 <lambdabot>   262537412640768256
12:46:47 <mtnviewmark> can you configure cabal to not build the libraries in a package, just the application?
12:46:48 <Tomsik_> nice
12:46:54 <mtnviewmark> er, executable
12:47:24 <tommd> > 2.71 ** pi
12:47:24 <Veinor> > e^(pi * sqrt 43) - 960^3 - 744
12:47:25 <lambdabot>   22.919922428200678
12:47:25 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:47:25 <lambdabot>    `GHC.Float.Floating a'
12:47:25 <lambdabot>  ...
12:47:30 <Veinor> > e^(pi * sqrt 43) - 960 ** 3 - 744
12:47:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:47:31 <lambdabot>    `GHC.Real.Integral a'
12:47:31 <lambdabot>   ...
12:47:40 <aristid> > log(640320**3+256) - log(640320**3) :: CReal
12:47:40 <Veinor> >:/
12:47:42 <lambdabot>   0.0000000000000009750991198739612864924342
12:48:08 <aristid> > log(640320**3) / sqrt(163) - pi :: CReal
12:48:09 <lambdabot>   -0.0000000000000002219667547300827791377903
12:49:15 <soupdragon> > sqrt(66^2 + 44^2)/(sqrt(66) + sqrt(66+44) + sqrt(44)) :: CReal
12:49:15 <Tomsik_> > log (640320**3 - 163/2) -pi ::CReal
12:49:16 <lambdabot>   36.967577337542723372573676739805545068609
12:49:16 <lambdabot>   3.1420457589033615946477919030376133860319
12:49:43 <Tomsik_> > log (640320**3 - sqrt(163)) -pi ::CReal
12:49:44 <lambdabot>   36.9675773375427236343758099056565073441986
12:49:58 <Tomsik_> > log (640320**3 - 2*163) -pi ::CReal
12:49:59 <lambdabot>   36.9675773375427224412778376414311864300007
12:50:04 <Tomsik_> > log (640320**3 - 163/2) -pi ::CReal
12:50:05 <lambdabot>   36.967577337542723372573676739805545068609
12:50:08 <aristid> > log (640320**3 - 163)
12:50:09 <lambdabot>   40.10916999113252
12:50:20 <Tomsik_> > log (640320**3 - exp (163/2)) -pi ::CReal
12:50:21 <lambdabot>   *Exception: log of negative number
12:50:27 <Tomsik_> haha
12:51:12 <Tomsik_> > log (640320**3 - exp (163)*0.5) -pi ::CReal
12:51:13 <lambdabot>   *Exception: log of negative number
12:51:33 <Tomsik_> meh, whatever
12:52:43 <mtnviewmark> <3 mapMaybe - just do darn' handy!
12:52:50 <mtnviewmark> s/d/s/
12:52:58 <Tomsik_> :t mapMaybe
12:53:01 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
12:53:17 <Tomsik_> mtnviewmark: Maybe. :p
12:54:08 <tommd> To avoid using gnu plot (like don did with ghc-gc-tune) is there a library based method to build a 3D chart in my application?  Something like Chart but 3D?
12:54:29 <Makoryu> Nah, you should just use GTK
12:54:43 <vanadium> Gtk has 3d charts?
12:54:50 <Makoryu> Nah
12:55:24 <soupdragon> > 9/5 + sqrt(9/5)  :: CReal
12:55:25 <lambdabot>   3.1416407864998738178455042012387657412644
12:55:26 <soupdragon> YES!!!!!!
12:55:56 <burp> > pi :: CReal
12:55:58 <lambdabot>   3.1415926535897932384626433832795028841972
12:56:44 <Tomsik_> I'm not sure what you're happy with, it's different on the fourth place after the comma
12:56:52 <burp> yeah
12:56:52 <burp> > 355/133
12:56:53 <lambdabot>   2.669172932330827
12:56:57 <burp> > 355/113
12:56:58 <lambdabot>   3.1415929203539825
12:57:06 <soupdragon> 9/5 + sqrt(9/5)  is accurate
12:57:22 <Tomsik_> > 9/5+sqrt(9/5) - pi
12:57:22 <lambdabot>   4.813291008076703e-5
12:57:30 <Tomsik_> > 355/113 -pi
12:57:31 <lambdabot>   2.667641894049666e-7
12:57:37 <Tomsik_> You see, two orders of magnitude
12:57:57 <djahandarie> > 3.14159
12:57:58 <lambdabot>   3.14159
12:58:00 <soupdragon> see if anyone cant beat e-5 using 2 single digit numbers.....
12:58:01 <djahandarie> Mine is the fastest :)
12:58:13 <aristid> soupdragon: my current favorite is log(640320**3) / sqrt(163)
12:58:38 <soupdragon> aristid: I wan to learn the mathematics of sqrt(163)
12:58:49 <soupdragon> it's a long way away though
12:58:50 <aristid> > log (log(640320**3) / sqrt(163) - pi)
12:58:51 <lambdabot>   -Infinity
12:58:56 <aristid> > log (log(640320**3) / sqrt(163) - pi) :: CReal
12:58:58 <lambdabot>   *Exception: log of negative number
12:59:17 <aristid> > log (abs (log(640320**3) / sqrt(163) - pi)) :: CReal
12:59:19 <lambdabot>   -36.0440040567028086478324745630291138526299
12:59:26 <soupdragon> > sqrt 10 :: CReal
12:59:27 <lambdabot>   3.1622776601683793319988935444327185337196
12:59:28 <aristid> > log (abs (log(640320**3) / sqrt(163) - pi)) / log(10) :: CReal
12:59:31 <lambdabot>   -15.6537120675244533930342332173491407745428
12:59:33 <augur> kmc: i take it that when you do something like  putStr "foo"  in ghci, that the repl isn't -show-ing the eval of the expression, since it's an IO, yeah?
12:59:33 <monochrom> are we done?
12:59:54 <aristid> soupdragon: e-15 is pretty good precision i say
13:00:15 <burp> 22/7 and 355/113 are "best"
13:00:20 <aristid> augur: it special cases IO
13:00:27 <augur> ok
13:00:50 <soupdragon> > (21/34)+(21/34)**(1/2)+(21/34)**(1/3)+(21/34)**(1/4) :: CReal
13:00:51 <lambdabot>   3.1416871220562666226660241343075684844831
13:01:25 <jystic> hi all, what's the best way for me to nuke core packages which have been installed to my user directory? (accidentally did cabal upgrade)
13:01:27 <monochrom> people, you have been at this number crunching for more than 15 minutes. Please take it to pm.
13:01:47 <EvanR-work> hahaha
13:02:19 <monochrom> manually "ghc-pkg unregister ..." many times, once per package
13:02:57 <jystic> will that unregister the user one and the global one?
13:03:05 * chrisdone grunts an outsiders-ain't-welcome-'ere-sound
13:03:44 <chrisdone> http://imgur.com/NjiVh
13:03:45 <chrisdone> too much?
13:03:53 <Ran__> An ugly way of seeing if all integer values in a list xs are even is to do:    all (´mod´ 2 == 0) xs    But what if you want to see if all values in xs are multiples of say 4? Something like    all (x ´mod´ 4 == 0) xs    would of course not work, as x isn't bound. So, how do you use all in such a way? Eg. is there some default name to use? Are there some good websites out there with...
13:03:55 <Ran__> ...examples...
13:03:56 <Ran__> ...of how to use the standard library?
13:03:57 <monochrom> "ghc-pkg --user unregister" will ensure user-only
13:04:09 <dons> http://i.imgur.com/NjiVh.png is really nice, chrisdone 
13:04:22 <jystic> monochrom: cool, thanks :)
13:04:25 <mauke> Ran__: all (´mod´ 2 == 0) xs doesn't work either
13:04:33 <djahandarie> That's neat dons, chrisdone 
13:04:38 <Ran__> It doesn't? Oh.
13:04:48 <soupdragon> shouldn't it just be  " The haskell download" 
13:04:50 <djahandarie> Typography could be better on the bottom but that's me nit-picking ;)
13:05:08 <dons> chrisdone: one other thing, http://code.haskell.org/haskell-platform/download-website/ 
13:05:15 <dons> we need a bit of release timetable info 
13:05:25 <dons> but i think you're definitely onto something here
13:05:37 <dons> we're close to having the best, easiest installer for any language atm :-) 
13:05:54 <Ran__> Then I'm confused.   all (`elem` ys) xs    works great for seeing if all things in xs is also in ys.. hm
13:06:32 <c_wraith> Ran__: all ((== 0) . (`mod` 4)) xs
13:06:33 <mauke> yes, it does
13:06:40 <mauke> ´ is not `
13:06:42 <dons> chrisdone: if you send me the bits and pieces, i might be able to work with this.
13:06:44 <chrisdone> dons: ahhh, true, release dates
13:06:52 <chrisdone> dons: sure, i'll send over the SVG
13:07:02 <dons> chrisdone: re. release dates, maybe some text in the top right.
13:07:03 <Ran__> c_wraith, thanks, what does the dot mean there?
13:07:09 <mauke> @src (.)
13:07:10 <lambdabot> (f . g) x = f (g x)
13:07:10 <lambdabot> NB: In lambdabot,  (.) = fmap
13:07:10 <dons> 2010.2.0.0 "Summer"
13:07:12 <dons> or some such
13:07:23 <Ran__> ah, okay. Scary.
13:07:25 <chrisdone> yeah, that's a good space
13:07:58 <djahandarie> I still don't understand why (.) = fmap
13:08:01 <djahandarie> I mean
13:08:13 <djahandarie> It's like working the instance of Functor backwards
13:08:42 <zygoloid> djahandarie: (.) = fmap because Cale says so, and lambdabot is his mistress ;-)
13:08:55 <djahandarie> I'm sure he has some reasoning behind it though
13:09:02 <djahandarie> Like everything else
13:09:09 <mauke> because it makes sense
13:09:17 <djahandarie> It makes sense the other way around
13:09:21 <c_wraith> well, fmap in the ((->) a) functor *is* composition
13:09:22 <djahandarie> For fmap to be function composition
13:09:27 <djahandarie> Exactly
13:09:29 <vanadium> It is generalised in the other direction
13:09:39 <c_wraith> he just generalized the symbol (.) to mean fmap in all contexts
13:09:48 <djahandarie> Then what is function composition?
13:09:50 <mauke> djahandarie: why do you think . means "function composition"?
13:09:56 <vanadium> .
13:10:13 <lispy> djahandarie: function composition is just a special case of fmap
13:10:17 <mauke> djahandarie: what is integer multiplication?
13:10:19 <zygoloid> (.) is often used to mean composition of arrows in that category. that's not fmap.
13:10:22 <tommd> Ok, seriously we _need_ parallel builds.  I mean, profiling + dynamic + vanilla libraries == 3 compilations per library!  I want my 2nd core to do some of this work!
13:10:32 <tommd> Grrr
13:10:34 <dons> tommd: agreed.
13:10:43 <dons> tommd: the question is where to do the parallelism
13:10:50 <dons> cabal foo and cabal foo -prof simultaneously?
13:10:53 <Ran__> Hm, I'm guessing there's no alternative to the horrible backtick? *rewriting keyboard config*
13:10:53 <dons> or do we have to hack --make ?
13:10:54 <tommd> dons: I thought it was agreed GHC should do it?
13:11:03 <djahandarie> lispy, isn't function which is used in the Functor instance a "sepcial case" of fmap?
13:11:04 <dons> well, ghc parallel is stalled.
13:11:06 <djahandarie> any function*
13:11:08 <lispy> dons: Shouldn't GHC fuse them?
13:11:13 <djahandarie> Ugh, can't type today apparently
13:11:14 <zygoloid> Ran__: use a name built out of symbols not letters
13:11:25 <tommd> dons: I don't think the developer would/should care for 99% of cases, so that leaves us to decide where is easiest and cleanest.  Do other people not agree with that assessment?
13:11:27 <mauke> Ran__: get a sane keyboard layout
13:11:34 <Ran__> zygoloid, huh?
13:11:40 <dons> the easiest place would be cabal, imo.
13:11:51 <dons> but it doesn't have the dependency info
13:11:51 <Ran__> mauke, my keyboard layout is quite good, backticks is the only thing that really doesn't go well.
13:11:52 <tommd> I was thinking that too, till I was told ghc --make was being worked.
13:11:55 <zygoloid> Ran__: let >< = elem in 4 >< [1,2,3]
13:11:55 <dons> while ghc does, but is hard to parallelize
13:11:55 <lispy> dons: Presumably a lot of the work it does for the various options is duplicated and so we'd save a lot by emitting the variouss options all in one go?
13:12:00 <tommd> Ahh
13:12:03 <dons> tommd: see nominolo's talk from HIM last year
13:12:19 <mauke> Ran__: but you can type ´, which isn't even in ASCII?
13:12:22 <dons> tommd: http://vimeo.com/6572966
13:12:26 <Ran__> zygoloid, now I'm confused. How thoes that work?
13:12:26 <tommd> dons: thanks
13:12:36 <dons> tommd: nominolo saying how far they got with --make, and where it got stuck
13:12:48 <dons> meanwhile, cabal doesn't have module deps, so can only do parallel packages
13:12:49 <djahandarie> mauke, the operation in a multiplicative group? Dunno
13:12:50 <tommd> Will look
13:12:51 <dons> or parallel prof/normal
13:12:53 <Ran__> mauke, I can type ` using shift+´, but it doesn't work well in the console by some reason.
13:12:54 <djahandarie> Not sure what answer you want for that
13:13:00 <mauke> huh
13:13:05 <zygoloid> Ran__: instead of using backticks, define an operator for the same operation.
13:13:19 <mauke> Ran__: does it work if you type a space after it?
13:13:20 <lispy> Distributed GHC would be nice too
13:13:21 <zygoloid> > let (><) = elem in 4 >< [1..10]
13:13:22 <lambdabot>   True
13:13:34 <djahandarie> mauke, re: what is integer multiplcation?
13:13:34 <zygoloid> Ran__: that's one alternative to backticks. another is to write the function prefix.
13:13:43 <soupdragon> > (phi + 17/56)^2 - sqrt(17/56) :: CReal
13:13:45 <monochrom> "><" is a valid function name (infix use)
13:13:45 <lambdabot>   3.1415942148593178049025172911507882468813
13:14:05 <Ran__> mauke, yes. zygoloid, hm, okay, I'm still kind of confused there. elem in?
13:14:08 <mauke> djahandarie: a function :: Integer -> Integer -> Integer that multiplies two integers, dude
13:14:10 <tommd> dons: on other news, is there a hackathon so I can finish this Crypto library?
13:14:13 <soupdragon> > sqrt(pi + sqrt(17/56)) - 17/56 :: CReal
13:14:15 <lambdabot>   1.6180335825089268729632729410638059823777
13:14:19 <mauke> Ran__: so you're using a keyboard layout with dead keys
13:14:27 <zygoloid> Ran__: i'm defining >< as another name for elem, so you can use it infix without backticks
13:14:33 <soupdragon> the pi phi connection
13:14:36 <djahandarie> mauke, oh, thought you were attacking this from some non-haskell angle...
13:14:40 <Ran__> mauke, yes.
13:15:23 <zygoloid> > (1 + sqrt 5) / 2 :: CReal
13:15:24 <lambdabot>   1.6180339887498948482045868343656381177203
13:15:37 <Ran__> zygoloid, ah, okay, I'm almost with you. What does "in" mean? And how do you then use that >< operator? And wouldn't you have to do that for all functions you'd want to use backticks on?
13:15:38 <mauke> > 0.5 + sqrt 1.25 :: CReal
13:15:39 <lambdabot>   1.6180339887498948482045868343656381177203
13:15:51 <soupdragon> mauke ++++
13:16:09 <soupdragon> what about generalization of continued fractions?
13:16:10 <monochrom> "in" does not mean anything by itself. the whole construct is "let ... in ..."
13:16:16 <zygoloid> Ran__: oh, i see. "let <definitions> in <expression>" is syntax for defining a bunch of stuff locally
13:16:17 <Ran__> ah
13:16:24 <jamwt> hmm.. google is failing me. guys, if I get `progname: <<loop>>` printed out at me when my program runs
13:16:28 <jamwt> what does that mean?
13:16:28 <mauke> Ran__: what source are you learning Haskell from?
13:16:36 <mauke> jamwt: infinite loop
13:16:42 <Ran__> mauke, learnyouahaskell
13:16:55 <djahandarie> I understand why    instance Functor ((->) a) fmap = (.)   but not the other way around
13:16:59 <zygoloid> Ran__: yes, you'd need to do that for all functions you'd want to use backticks on. you'd probably be better off defining these at the top level, rather than in "let ... in ..." though
13:17:08 <chrisdone> dons: if the background pic fails to show, right click -> image properties, just update the URL
13:17:19 <chrisdone> dons: (sent the design to your galois email)
13:17:25 <zygoloid> djahandarie: that's a question for Cale.
13:17:29 <Ran__> Yes. Hm, I guess easiest would be to just change my keyboard settings and go on with it?
13:17:30 <jamwt> mauke: interesting.. that's kinda what I'm going for here, since this is a "forever" pattern
13:17:43 <Ran__> Is it good style to use backticks at all btw?
13:17:43 <jamwt> it tail-recurses
13:17:50 <zygoloid> Ran__: you may find that easier. or write the function prefix instead
13:17:54 <mauke> jamwt: without doing anything useful
13:17:56 <lispy> djahandarie: well, fmap and (.) are equal for ((->) a), and that's currently the only use for (.) in the Prelude.  Why not "generalize" (.) by using fmap (it is equality right?)
13:17:56 <mauke> jamwt: it just loops
13:17:57 <zygoloid> > elem 5 [1..10]
13:17:58 <lambdabot>   True
13:18:01 <Ran__> It really seems like some deprecated thing that people hate, heh.
13:18:19 <zygoloid> Ran__: it's completely reasonable to use backticks, and common, but only with a few functions
13:18:20 <monochrom> No, we love backticks. I use it all the time.
13:18:27 <dons> chrisdone: cheers
13:18:30 <djahandarie> lispy, because that isn't what function composition is in math
13:18:36 <c_wraith> I commonly use backticks if it reduces paren use
13:18:36 <jamwt> mauke: well, no, it reads stuff off a TChan and manages some IO stuff, writes stuff back on another TChan
13:18:44 <mauke> jamwt: no, it doesn't
13:18:48 <zygoloid> Ran__: elem, notElem, liftM, fmap, ap <-- these spring to mind immediately as places i'd use backticks.
13:18:50 <mauke> jamwt: it goes into an infinite loop and is killed
13:18:51 <monochrom> > 0 `elem` [3,0,4]
13:18:52 <lambdabot>   True
13:19:00 <Ran__> Oh well, thankfully I got some useless local letters on my keyboard that I can rebind to something fun.
13:19:04 <zygoloid> Ran__: though i'd use <$> instead of `liftM` or `fmap` usually
13:19:09 <Ran__> No more ä för you, Haskell.
13:19:10 <zygoloid> and <*> instead of ap
13:19:22 <Ran__> How does that work?
13:19:24 <lispy> djahandarie: in Caleskell, (.) is not function composition.  It's fmap.  And fmap for ((->) r) is function composition.
13:19:26 <zygoloid> the downside of those is they give you the 'wrong' typeclass context
13:19:40 <monochrom> > (\ä -> ä+1) 4
13:19:41 <lambdabot>   5
13:19:48 <zygoloid> Ran__: those are both defined in Control.Applicative as shorthands.
13:19:54 <chrisdone> today i found a bug in haddock that was due to using `head` and assuming the list would always be non-empty. 
13:19:55 <chrisdone> head--
13:19:56 <djahandarie> lispy, I know, but the ∘ symbol is function composition and I believe that is what (.) represents
13:19:58 <chrisdone> @karma head
13:19:58 <lambdabot> head has a karma of -2
13:20:00 <chrisdone> :D
13:20:00 <Ran__> monochrom, ah, I saw that \x -> x thingy before, what does that mean?
13:20:11 <zygoloid> Ran__: i wouldn't worry about fmap and certainly not about ap yet though.
13:20:31 <djahandarie> So it seems weird to generalize it like that
13:20:44 <lispy> djahandarie: ∘ is just a symbol.  and so is (.).  The important part is the semantics we give them in a context.  In Haskell (.) is function composition.  In Caleskell, (.) is fmap.  It's really that simple.
13:20:52 <jamwt> mauke: it does, at least 4 times, recurse and "do stuff".. so what do you mean by "doing nothing"?
13:21:05 <Cale_> fmap is a generalisation of function composition
13:21:14 <Cale_> So it's okay
13:21:16 <mauke> jamwt: dude, which part of "infinite loop without doing anything" is unclear?
13:21:29 <monochrom> (\ä -> ä+1) is approximately python lambda ä: return ä+1
13:21:45 <djahandarie> lispy, sure I understand *what* it is, I'm just asking why anyone would do that and muddle things
13:21:50 <Ran__> monochrom, ah, okay
13:22:01 <jamwt> mauke: you say "without doing anything"; I have handles it has opened and put on a TChan back to other forkIO threads
13:22:06 <jamwt> they use them, they were opened by this thing
13:22:08 <dolio> Some of us aren't muddled by it.
13:22:11 <Ran__> Oh, then I guess that's exactly the answer for what I asked? :)
13:22:13 <Cale_> djahandarie: Do what?
13:22:15 <jamwt> I cannot resolve taht against "not doing anything"
13:22:16 <djahandarie> Cale_, fmap is a generalization of function compositions?
13:22:20 <lispy> djahandarie: It's kind of nice if you get over the type that confuses everyone :)
13:22:21 <Cale_> djahandarie yes
13:22:27 <mauke> jamwt: you think your program is doing something it isn't
13:22:39 <mauke> jamwt: if your program was working, it wouldn't be getting killed
13:22:40 <lispy> > (+1) . (1, 2)
13:22:42 <lambdabot>   (1,3)
13:23:03 <jamwt> mauke: ..
13:23:15 <Cale_> djahandarie: Think of a function of type (e -> a) as being a container which contains values of type a, indexing them by values of type e
13:23:40 <Cale_> djahandarie: What would it mean to apply a function (a -> b) to all the values of type a in that container?
13:23:54 <Cale_> Well, such an operation would have type (a -> b) -> (e -> a) -> (e -> b)
13:24:01 <djahandarie> Right, that helps define why ((->) a) is a function
13:24:03 <djahandarie> That is clear to me
13:24:07 <Cale_> and this is exactly the type that function composition has
13:24:14 <djahandarie> functor*
13:24:27 <Cale_> So yeah, ((->) e) is a functor, and the fmap for it is function composition
13:24:28 <zygoloid> Cale_: djahandarie was wondering the opposite. why is (.) generalized that way in lambdabot?
13:24:39 <Cale_> Oh, simply because it can be.
13:24:53 <aristid> why fmap and not Control.Category..?
13:25:00 <zygoloid> aristid: at least fmap is useful :)
13:25:14 <Cale_> and it's sort of nice, in that the functor laws (at least in part) generalise what we expect from composition
13:25:35 <Cale_> fmap (f . g) x = fmap f (fmap g x)
13:25:43 <Cale_> If rewritten using (.) in place of fmap
13:25:53 <Cale_> becomes (f . g) . x = f . (g . x)
13:26:00 <nschoe> Hi all! I have difficulties reading and writing in a file when it's open in 'ReadWriteMode', is there anything special to do in order to read first and then write in the same file?
13:26:00 <Cale_> It's a sort of associativity
13:26:04 <zygoloid> < zygoloid> djahandarie: (.) = fmap because Cale says so, and lambdabot is his mistress ;-)  <-- this
13:26:10 <djahandarie> Right, but I don't expect for anyone to know what I'm talking about if I use the function composition symbol when talking about two Functors in a math paper
13:26:15 <jamwt> mauke: I'm afraid that isn't precise enough to help me, and you're not giving me credit when I try to communicate with you what exactly is happening
13:26:17 <Cale_> and  fmap id x = x  becomes  id . x = x
13:26:20 <jamwt> mauke: but I appreciate the effort
13:26:26 <mauke> jamwt: you don't know what is happening
13:26:32 <mauke> jamwt: you're explaining what you think is happening
13:26:33 <Cale_> djahandarie: Sure, you'd instead talk about Hom functors.
13:26:37 <lispy> djahandarie: Not everyone likes Caleskell as much as Haskell
13:26:53 <jamwt> mauke: pause for a moment, okay?  give me a chance.  a tiny bit of credit.  I understand what your'e saying, but there is a bit more depth than that
13:27:08 <mauke> jamwt: how can I be precise without seeing any code?
13:27:15 <zygoloid> there is something beautiful about considering fmap as an associative infix operator. i'm not sure (.) is the best name for that operator, but \b isn't my bot.
13:27:18 <djahandarie> lispy, don't worry, this is like the 10th discussion I've had about Caleskell
13:27:30 <jamwt> mauke: it's an IO funciton, it calls itself.. it modifies one of its arguments and calls itself with the modified argument
13:27:31 <Cale_> The reason that I don't like Control.Category is that while it looks very similar to an interface for general categories, it's not really a proper definition of what a category is.
13:27:41 <mauke> jamwt: how do you know it dies there?
13:27:44 <Cale_> Well, that might be a little harsh.
13:27:45 <jamwt> it does that four times (I'm printing it and watching it change) before its killed for not doing anything
13:27:47 <soupdragon> Cale_, in category theory it is nice to write   fg
13:27:52 <soupdragon> Cale_, as opposed to  f o g
13:27:59 <djahandarie> f;g usually?
13:27:59 <zygoloid> it's also only got one useful instance, which makes it less of a generalization and more of a just-confusing-the-type
13:28:00 <soupdragon> Cale_, my question is, how does fmap come into this ?
13:28:02 <dolio> Functor isn't a proper definition of what functors are. :)
13:28:20 <jamwt> I agree that's probably why it's being killed, I just don't understand why it iterates successfully four times before deciding the next recursion is a NOOP or wahtever.  and lemme share the code, I'm fine with that
13:28:25 <FunctorSalad> *ponders whether the yoneda lemma could be taken to say that hom functors are universal for some higher functor*
13:28:42 <Cale_> soupdragon: fmap f for the functor (E ->) would normally be written Hom(E,f) in the usual CT notation.
13:28:49 <djahandarie> Cale_, aren't Hom functors in the category of Sets? I'd want Functors in the category of Functors...
13:28:50 <zygoloid> jamwt: <<loop>> means that a thunk ended up evaluating to itself.
13:28:51 <Cale_> Or C(E,f), making the category explicit
13:29:14 <FunctorSalad> with Hask replacing Set....
13:29:28 <Cale_> djahandarie: Functor encodes endofunctors Hask -> Hask
13:29:41 <jamwt> http://a.libpa.st/82SVP
13:29:48 <jamwt> mauke, zygoloid : ^^
13:29:49 <zygoloid> jamwt: that is, you have a value, x, in your program. reducing x to WHNF required the evaluation of x. and GHC spotted it, and terminated your program rather than hanging.
13:29:57 <Cale_> djahandarie: and we use Hask as sort of being a substitute for Set
13:30:02 <djahandarie> Right
13:30:06 <mauke> jamwt: missing 'main'
13:30:08 <jamwt> zygoloid: thanks, that very helpful, and a bit more detailed about what's actually happening
13:30:40 <FunctorSalad> djahandarie: "make (covariant) Hom functor" is of type C^op -> Func(C,Set) more or less, yes
13:30:48 <FunctorSalad> it's even a higher functor itself iirc
13:30:55 <Ran__> Just to make sure here... given that we know that 2520 is divisable with all values in [1..10], this should be evalued as True:     all ((==0) . (\x -> 2520 `mod` x)) [1..10]        Is that code reasonable? I tried it out and it does give True, but False if I send in [1..11], but still True if I send in [1..9]
13:31:10 <FunctorSalad> (ah of course it is, since the uncurried variant is a bifunctor)
13:31:12 <Cale_> Ran__: Seems reasonable
13:31:17 <zygoloid> Ran__: that sounds right to me.
13:31:23 <FunctorSalad> (is that even sufficient? ;))
13:31:35 <Cale_> FunctorSalad: I think so, if I know what you're asking.
13:31:36 <mauke> jamwt: print . show looks weird. are you sure you want that?
13:31:56 <jamwt> bank' is a Data.Map
13:31:57 <mauke> jamwt: I don't see any obvious problems in that code
13:31:59 <Ran__> Sweet! Is there any more... haskell-ish way to do it? (hm, what do you call it? Python ⇔ Pythonic, Haskell ⇔ ???)
13:32:00 <zygoloid> jamwt: i don't think that code is the problem.
13:32:02 <illissius_> hmm
13:32:08 <FunctorSalad> Cale_: (bifunctoriality being sufficient for the curried functor being a functor)
13:32:09 <zygoloid> Haskellicious
13:32:11 <mauke> <mauke> jamwt: how do you know it dies there?
13:32:12 <Cale_> Ran__: You could use a list comprehension
13:32:14 <illissius_> apparently, asking ghc to compile a module with 10000 foreign export statements is not wise
13:32:28 <Ran__> Cale_, True, but wouldn't that be a lot longer and uglier?
13:32:32 <Cale_> all (== 0) [2520 `mod` x | x <- [1..10]]
13:32:39 <Ran__> ah, nice
13:32:39 <jamwt> mauke: I don't; advice?  is there a ghc flag that will tell me what thunk caused the problem?
13:32:41 <Cale_> and [2520 `mod` x == 0 | x <- [1..10]]
13:32:47 <jamwt> then I could solve this quickly and stop bother you people
13:32:49 <Cale_> One of those :)
13:32:51 <Ran__> that looks a whole lot better, thanks!
13:33:04 <mauke> jamwt: how do you identify thunks?
13:33:10 <Cale_> FunctorSalad: yes
13:33:25 <djahandarie> Cale_, connecting this back, I still think that using the function composition symbol to notate something that it isn't really used for doesn't make sense
13:33:33 <mauke> just thinking out loud here; it could tell you the memory address, but that would be useless
13:33:41 <jamwt> right; context?
13:33:43 <Cale_> djahandarie: We can use it for that, because it's a proper generalisation of function composition.
13:33:57 <Cale_> djahandarie: And we don't really have a proper notion of categorical composition.
13:34:08 <Cale_> We have Control.Category, but that's just something weird. :)
13:34:08 <jamwt> something like that.  I guess it's a question in general about how you find these when they come up, then
13:34:09 <djahandarie> Cale_, couldn't you use the same argument for any function which is the fmap function in its Functor instance?
13:34:13 <aristid> > let multiple x y = x `mod` y == 0 in all (2520 `multiple`) [1..10]
13:34:14 <lambdabot>   True
13:34:14 <jamwt> what the recommended practice is
13:34:14 <Saizan> mauke, jamwt: the profiling trick with -xc could work here, i guess
13:34:22 <Cale_> djahandarie: yes.
13:34:30 <aristid> Ran__: ^
13:34:35 <FunctorSalad> djahandarie: maybe it makes more intuitive sense if you consider containers as functions "storage positions -> element type"
13:34:42 <Cale_> djahandarie: In fact, I think the names that I'd like to keep around are map and (.), and have them both mean functor application.
13:34:48 <Ran__> Cale_, for that last one,   [2520 `mod` x == 0 | x <- [1..10]]   , what's the quickest way to see if something if they are all True?
13:34:51 <jamwt> Saizan: ok, I'll try that
13:34:53 <FunctorSalad> and fmap as "change element type"
13:35:01 <Cale_> Ran__: and
13:35:05 <jamwt> interestingly, that seems to be the loop that's terminated
13:35:15 <Cale_> > and [2520 `mod` x == 0 | x <- [1..10]]
13:35:15 <jamwt> I'll see what -xc gives me
13:35:16 <lambdabot>   True
13:35:24 <aristid> Ran__: and takes a list of Bool and returns True only if all elements are True
13:35:26 <aristid> @src and
13:35:27 <lambdabot> and   =  foldr (&&) True
13:35:31 <FunctorSalad> I agree it's confusing at first because fmap isn't usually a binary op 
13:35:35 <djahandarie> FunctorSalad, I don't have any issues with the Functor instance of ((->)a)
13:35:42 <Ran__> Oh... That's a sweet way of using "and". Nice!
13:35:48 <FunctorSalad> (as in two arguments of almost the same type)
13:36:10 <Saizan> jamwt: -xc is not the whole story
13:36:25 <djahandarie> Actually
13:36:30 <FunctorSalad> djahandarie: yeah but I'm arguing the converse, that every fmap is "really" a (.)
13:36:44 <FunctorSalad> morally ;)
13:36:45 <Cale_> djahandarie: By the way, thinking of (.) as functor application often makes certain things clearer.
13:36:47 <kmc> > all ((== 0) . (2520 `mod`)) [1..10]
13:36:48 <lambdabot>   True
13:37:05 <Cale_> djahandarie: Like when people use that (f .) . g idiom
13:37:15 <FunctorSalad> e.g. for lists, you'd think of length-n A-lists as functions from {1,2,....,n} to A
13:37:23 <FunctorSalad> then fmap should be (.)
13:37:26 <djahandarie> Doesn't Control.Category.(.) make what FunctorSalad just said happen in code?
13:37:30 <Cale_> If you think of the sectioned occurrence of (.) there as functor application, it tends to be easier to follow :)
13:37:38 <FunctorSalad> djahandarie: it should
13:37:45 <FunctorSalad> since (->) is a Control.Category
13:37:49 <c_wraith> I really wish I could define (..) for that, but thanks to list syntax, I can't.
13:38:12 <Cale_> Control.Category places some interesting restrictions on the behaviour of its id and (.)
13:38:30 <c_wraith> let f .. g = \x y -> f (g x y) in blowUpWithASyntaxError
13:38:43 <Cale_> and I don't really understand exactly what those restrictions mean, I just know that there are not many good interesting instances of Control.Category
13:39:11 <Cale_> So, that's why I prefer using (.), which is one of the best pieces of syntax, for an operation which is actually common in code.
13:39:28 <kmc> > succ . "abcd"
13:39:29 <lambdabot>   "bcde"
13:39:36 <Cale_> (Control.Category..) is not nearly so common.
13:39:57 * zygoloid petitions for -XNewQualifiedOperators on #haskell
13:39:57 <djahandarie> Is category-extras imported into lambdabot?
13:39:59 <benmachine> Cale_: do you have a particular view on <$>?
13:40:21 <Cale_> benmachine: My view is that it looks nice in conjunction with <*>, and not as much elsewhere.
13:40:21 <zygoloid> {-# LANGUAGE NewQualifiedOperators #-}
13:40:30 <zygoloid> Control.Category.(.) is not nearly so common
13:40:33 <zygoloid> much better.
13:40:34 <kmc> hmm (<<<) is an alias for (C.C..) right?
13:40:43 <djahandarie> kmc, yep
13:40:46 <Cale_> kmc: That's true
13:40:57 <djahandarie> >>> is flip (.) too
13:40:59 <FunctorSalad> c_wraith: there's a unicode two-thirds-of-an-ellipsis ;)
13:41:01 <FunctorSalad> ..
13:41:17 <kmc> yeah, best thing would be to find some unicode char that looks very much like . and use it for C.C..
13:41:23 <zygoloid> the only two interesting Category's i know of are functions (which have (.)) and kleisli arrows (which have (<=<))
13:41:32 <djahandarie> kmc, that'd make it imposible to use :P
13:41:36 <kmc> ;)
13:41:44 <dolio> Lenses are another.
13:41:45 <c_wraith> 。is kind of close. :)
13:42:01 <FunctorSalad> Cale_: the restriction seems to be at least that the object set of the category is in bijection to Hask's?
13:42:01 <zygoloid> not very common though :)
13:42:10 <kmc> dolio, lenses being the same as sec's / fclabels?
13:42:12 <c_wraith> fclabels makes categories
13:42:19 <dolio> Yeah.
13:42:20 <Cale_> FunctorSalad: id and (.) have to be natural transformations
13:42:20 <swift__> hey all, not really a haskell question but i figured this would be a good place to ask. can anyone suggest a paper or two that would serve as a good introduction to dependent types?
13:42:22 <FunctorSalad> injective due to the way type constructors are, surjective because the category is defined by the image
13:42:25 <kmc> c_wraith, is that the Japanese punctuation?
13:42:29 <c_wraith> kmc: yes
13:42:30 <kmc> swift__, "dependently typed programming in agda"
13:42:31 <soupdragon> @seen edwardk
13:42:31 <preflex>  edwardk was last seen on #haskell 1 hour, 23 minutes and 4 seconds ago, saying: c_wraith: well, it basically comes down to the need to grab a lock for every read or write
13:42:31 <lambdabot> Unknown command, try @list
13:42:34 * benmachine wonders why the docs for base 4.2.0.2 haven't built on hackage
13:42:37 <Cale_> FunctorSalad: Well, even stronger than that, they have to be parametrically polymorphic
13:42:51 <FunctorSalad> Cale_: type cons?
13:42:53 <kmc> swift__, and "software foundations" by pierce et al
13:43:04 <kmc> swift__, these two being fairly practical introductions to DT languages
13:43:11 <soupdragon> swift__, the best intro stuff if the Epigram teams writeups about what the hell they are doing
13:43:15 * zygoloid thinks that #haskell is nice to newbies because we all still remember what it was^Wis like to learn new things about haskell
13:43:15 <kmc> and the latter also a text in PL theory
13:43:18 <FunctorSalad> I think you're allowed to make GADTs or data families categories :)
13:43:53 <Cale_> FunctorSalad: In Control.Category, we have (.) :: (b ~> c) -> (a ~> b) -> (a ~> c), and one is not allowed to put any restrictions on a,b,c, so the data which one is working with there are arbitrary.
13:43:53 <soupdragon> if I define a function like this:
13:44:11 <Cale_> FunctorSalad: So the implementation of (.) has to be a natural transformation in each type variable.
13:44:12 <soupdragon> f y = if y >= 0 then 0 else infinity
13:44:21 <FunctorSalad> Cale_: you can fake something non-parametric by having (~>) be a GADT ;)
13:44:23 <soupdragon> can I differentiate it to get a dirac delta?
13:44:25 <kmc> swift__, _Software Foundations_ was great fun.  only text i've read for fun where i worked *all* the exercises.  Coq is like a puzzle game...
13:44:26 <benmachine> Cale_: well, except you're not given facility to create arbitrary (a ~> b) though?
13:44:28 <swift__> kmc, soupdragan: excellent, thank you both!
13:44:34 <soupdragon> (using edwardks library)
13:44:34 <FunctorSalad> e.g. it can force a,b and c to be Int
13:45:01 <swift__> kmc: i've liked pierce's other work; i'll definitely check out software foundations
13:45:09 <Cale_> FunctorSalad: But even then, you're getting into strange realms where it's not entirely clear exactly what we've defined theoretically.
13:45:19 <FunctorSalad> (.) (IntMor f) (IntMor g) = f . (*2) . g
13:45:26 <Ran__> Finally, my first version of my function is complete. It doesn't look anywhere near as horrible as I thought it would, but I still think that I could solve it in some better way... Any recommendations?
13:45:26 <FunctorSalad> (ridiculous example)
13:45:29 <Ran__> let divisableUpToN n = head (filter (\i -> and [mod i x == 0 | x <- [1..n]]) [1..])
13:45:36 <FunctorSalad> (.) (IntMor f) (IntMor g) = IntMor (f . (*2) . g)
13:45:50 <Cale_> FunctorSalad: hmm...
13:46:06 <FunctorSalad> Cale_: agreed on the unclarity what this is ;)
13:46:07 <kmc> Ran__, head is a code smell
13:46:12 <zygoloid> Ran__: foldr lcm 1 . enumFromTo 1
13:46:18 <kmc> Ran__, i'd use Data.List.find rather than head and filter
13:46:20 <benmachine> kmc: it's applied to an infinite list here though
13:46:33 <Ran__> So, head is evil? Why?
13:46:34 <zygoloid> > (foldr lcm 1 . enumFromTo 1) 10
13:46:36 <lambdabot>   2520
13:46:40 <kmc> Ran__, because it can throw a runtime error
13:46:40 <kmc> > head []
13:46:41 <zygoloid> Ran__: because it crashes if given []
13:46:41 <lambdabot>   *Exception: Prelude.head: empty list
13:46:42 <dolio> FunctorSalad: That doesn't help with id.
13:46:53 <Ran__> ah, okay
13:47:01 <benmachine> in this case it's never going to get []
13:47:09 <kmc> Ran__, you can't necessarily avoid a runtime error here -- with find you'd probably use fromJust and that'd be equally bad
13:47:14 <zygoloid> benmachine: yeah, it's not a bug. but it is a smell
13:47:14 <kmc> but i think find is clearer anyway
13:47:22 <benmachine> mm fair enough
13:47:34 <FunctorSalad> dolio: ah right, for that IntMor has to be like "IntMor a where IntMor :: ((a :==: Int) -> a) -> IntMor"
13:47:44 <FunctorSalad> dolio: not sure if I found a hybrid that makes both work out
13:47:46 <FunctorSalad> thought I did ;)
13:47:48 <djahandarie> Whoa
13:47:50 <Cale_> lcm is the right way to do this :)
13:48:13 <kmc> Ran__, this wouldn't be a problem if we had a standard type for infinite lists ("streams").  head could be total on those, and find wouldn't return in Maybe (though it'd still be partial, due to forever-nontermination)
13:48:47 <zygoloid> kmc: yeah, but filter immediately throws away the 'is definitely nonempty' property
13:49:03 <kmc> zygoloid, it doesn't throw away the "has no end" property
13:49:06 <aristid> kmc: and they would be Comonads
13:49:14 <c_wraith> It just occurred to me that if you have a handy list of Busy Beaver numbers, you can implement a turing machine in a total language!
13:49:22 <kmc> filter on an infinite list might be non-productive, but it'll never hit [] and crash
13:49:29 <FunctorSalad> (this latter thing is "if `a' is Int, I have an `a', else nothing"... the former is "`a' is an Int, and I have one")
13:49:30 <zygoloid> kmc: :) yeah, you're right, you've moved the bottom somewhere else :)
13:49:36 <FunctorSalad> @ dolio 
13:49:44 <kmc> c_wraith, indeed, that's how you prove the busy beaver sequence grows faster than any computable sequence
13:49:53 <dolio> Right.
13:49:55 <Cale_> c_wraith: and all you needed to add to the language was something uncomputable! ;)
13:49:57 <FunctorSalad> maybe you can (|) the two ctors
13:50:06 <djahandarie> @iris Busy Beaver
13:50:07 <lambdabot>  Busy Beaver sequence, or Rado's sigma function: maximum number of 1's that a...
13:50:08 <lambdabot>  [0,1,4,6,13]
13:50:11 <c_wraith> Cale_: I was assuming it'd be user input.  aka, "ask an oracle"
13:50:27 <FunctorSalad> ah or wait, we have two parameters...
13:50:29 <Cale_> c_wraith: With a handy list of Busy Beaver numbers, you could also just do termination checking.
13:50:43 <kmc> Ran__, instead of «\i -> and [mod i x == 0 | x <- [1..n]]» perhaps you'd like «\i -> all ((==0) . (i `mod`)) [1..n]».  it's a matter of taste though
13:50:44 <FunctorSalad> maybe make one "need Int-proof" and the other "have Int-proof"
13:50:49 <zygoloid> just precompute the busy beaver sequence for small n. and hope you never need the large n case ;-)
13:51:03 <c_wraith> zygoloid, I think it's been computed up to n=3. :)
13:51:35 <djahandarie> Where does @iris get stuff from?
13:51:39 <Ran__> kmc, ah, I didn't know it worked like that
13:51:40 <benmachine> @oeis
13:51:41 <lambdabot> Plugin `oeis' failed with: Math/OEIS.hs:316:10-40: Irrefutable pattern failed for pattern ('%' : c : _, rest)
13:51:46 <djahandarie> Nice
13:51:46 <benmachine> @oeis Busy Beaver
13:51:47 <lambdabot>  Busy Beaver sequence, or Rado's sigma function: maximum number of 1's that a...
13:51:48 <lambdabot>  [0,1,4,6,13]
13:51:52 <zygoloid> c_wraith: iirc up to 4
13:51:54 <Ran__> I still don't really get in what way the arguments are sent when you do it like that. hm.
13:52:04 <benmachine> isn't the only way to calculate BB(n) to prove that all machines of size n terminate
13:52:11 <benmachine> which is what termination checking does anyway >_>
13:52:20 <zygoloid> c_wraith: when i was younger i worked on computing it for n=5. got pretty far (narrowed down to about 5 machines for which i couldn't prove termination or nontermination iirc)
13:52:25 <djahandarie> benmachine, for all n, yeah
13:52:27 <kmc> which part Ran__ 
13:52:48 <Ran__> kmc, well, the whole mod-thingy there
13:53:05 <g_cross> Is there a standard package out there for type-level naturals?
13:53:15 <Ran__> The parts of [1..n] is automagically sent as the second argument to (i `mod`)
13:53:15 <g_cross> Vec has its own implementation.
13:53:26 <Cale_> Ran__: (i `mod`) is a function which takes a number x and gives the result (i `mod` x)
13:53:28 <djahandarie> zygoloid, younger? Are you a prodigy? :P
13:53:30 <kmc> @src (.)
13:53:30 <lambdabot> (f . g) x = f (g x)
13:53:30 <lambdabot> NB: In lambdabot,  (.) = fmap
13:53:32 <g_cross> I saw another package with its own implementation, but I can't remember which.
13:53:32 <kmc> Ran__, ^^^^
13:53:40 <zygoloid> benmachine: you mean, prove that all machines of size n that run for more than BB(n) don't terminate.
13:53:52 <zygoloid> djahandarie: no, i'm 27. :p
13:53:52 <kmc> Ran__, so «((==0) . (i `mod`))»  ==  «\x -> (i `mod` x) == 0»
13:53:54 <mauke> Ran__: no magic; 'all' is doing it
13:53:55 <benmachine> zygoloid: err, yes
13:54:05 <kmc> Ran__, which forms a function that you pass to "all"
13:54:08 <kmc> :t all
13:54:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:54:10 <Cale_> g_cross: There are some separate packages for it I believe, but nothing which one would call standard.
13:54:14 <kmc> the first argument here, (a -> Bool)
13:54:15 <mauke> @src all
13:54:15 <lambdabot> all p =  and . map p
13:54:18 * BMeph wonders if people really write "(i `mod`)" instead of "mod i", and if so, is it just because sections are sooooooooooo cool...
13:54:33 <lispy> BMeph: I write the former and yes
13:54:33 <djahandarie> Using sections like that confuses me more than it helps
13:54:34 <mauke> BMeph: some people think in infix
13:54:38 <zygoloid> djahandarie: i was encouraged to look at busy beaver in preparation for the IOI in 2001 :)
13:54:42 <c_wraith> BMeph: it's more because `mod` is usually written infix.
13:54:46 <g_cross> Cale_:  Remember any names at the top of your head?  I've been looking through Hackage but I haven't figured out the right keyword to be looking for.  :-)
13:54:51 <c_wraith> err.  that was somewhat redundant. :)
13:54:52 <lispy> BMeph: Or maybe I misunderstood.  i guess I use the infix version without the section
13:54:59 <djahandarie> I'm pretty sure I didn't know what the IOI was in 2001 :P
13:55:00 <c_wraith> > (`mod`) 5 3
13:55:01 <lambdabot>   <no location info>: parse error on input `)'
13:55:11 <lispy> c_wraith: they are not inverses :(
13:55:20 <g_cross> Ah!  The correct keyword was "type level";  that seems to be helping a bit.
13:55:21 <kmc> BMeph, when you read "mod i" out loud, it sounds like (`mod` i)
13:55:21 <kmc> that's how it's commonly used in maths
13:56:00 <Cale_> g_cross: looking through hackage, there's tfp, type-level, numtype
13:56:07 <zygoloid> BMeph: i'd certainly write (i `mod`) rather than mod i. mod i looks like a bug to me.
13:56:14 * djahandarie is out for the day
13:56:19 <ksf> hmmm there's this grammar notation using arrows
13:56:27 <ksf> ...it'd be cool to have a TH syntax for that.
13:56:33 <BMeph> Okay, gen. math convention makes a lot more sense.
13:56:38 <c_wraith> ksf: a quasiquoter?
13:56:42 <ksf> yep
13:56:53 <ksf> as in literate programming.
13:56:59 <g_cross> Thanks, Cale_
13:57:05 <ksf> ...or rather graphical.
13:57:18 <ksf> it's not a bad idea in the /general/ case
13:57:49 <Ran__> Ah, now I get it, it really is automagically... (`f` a) b ==  b `f` a    and    (a `f`) b == a `f` b
13:58:10 <Cale_> lol http://hackage.haskell.org/packages/archive/tfp/0.2/doc/html/Types-Data-Num-Decimal-Literals.html
13:58:17 <c_wraith> Yeah, the idea of a quasiquoter converting ascii art to code is kind of clever.  I'm not sure if it's a good idea most of the time, but there are cases where it would basically be "parse my documentation and produce code from it"
13:58:44 <Cale_> Ran__: yeah, you can do that with any infix operation
13:59:04 <Cale_> Ran__: So for example (2*) multiplies by 2 (on the left :)
13:59:04 <g_cross> Dear lord that's a lot of declarations...
13:59:18 <BMeph> g_cross: Oleg did a binary work-up as well... YMMV.
13:59:21 <Cale_> Ran__: An exception to this rule is with negation.
13:59:41 <Cale_> Ran__: Since we obviously want (-x) to mean the negation of x and not the function which subtracts x
13:59:53 <mauke> "obviously" :-(
13:59:55 <Cale_> You can instead write (+(-x)) for that if you want it :)
14:00:04 <Cale_> Or (subtract x)
14:00:15 <Ran__> Ah, great
14:00:17 <Tomsik_> in some languages they use ~ for unary negation
14:00:25 <yaru1022> hi folks, I was doing RWH exercise 3 under section Hiding Our Work in Chapter 18 (http://book.realworldhaskell.org/read/monad-transformers.html).
14:00:29 <mauke> preflex: calc ~pi
14:00:29 <preflex>  -3.141592653589793
14:00:31 <Tomsik_> this way -x is not ambigious
14:00:36 <Ran__> I liked that in J you use _, so _3 is -3
14:00:42 <mauke> preflex: calc _3
14:00:42 <preflex>  -3
14:00:45 <mauke> huhu
14:00:53 <yaru1022> When I run my app, I get inappropriate type error... can somebody take a look at it and tell me what i did wrong?
14:01:03 <dolio> The thing is, unary - in haskell works for arbitrary expressions.
14:01:16 <dolio> It isn't just numeric literal syntax.
14:01:28 <Cale_> Unary - works *exactly* like I expect it to in Haskell, which I like.
14:01:37 <c_wraith> > let fact n = product [1..n] in fact -1
14:01:38 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
14:01:38 <lambdabot>    arising from a use of `...
14:01:45 <dolio> And _foo is already a legal variable name.
14:01:46 <c_wraith> That error is the real problem.
14:01:55 <Cale_> For example, -x^2 correctly means -(x^2) and not (-x)^2 like some stupid languages give.
14:01:56 <c_wraith> I don't feel like I should have to parenthesize a numeric literal
14:02:01 <dolio> ~foo isn't, but it'd conflict with ~ patterns, I guess.
14:02:03 <c_wraith> > let fact n = product [1..n] in fact (-1)
14:02:04 <lambdabot>   1
14:02:25 <mauke> Cale_: (-x)^2 is much more regular, though
14:02:33 <mauke> Cale_: consider f x^2
14:02:38 <Cale_> mauke: It's not, though.
14:03:12 <Cale_> mauke: negation is an additive operation, so it should come after multiplication and exponentiation
14:03:27 <mauke> negation is a prefix operation, so it should come before all infix operations
14:03:32 <Cale_> heh
14:03:40 <dolio> Why?
14:03:52 <mauke> because f x^2 is (f x)^2
14:03:59 <dolio> That isn't a prefix operation.
14:04:04 <mauke> totally is
14:04:07 <dolio> It's infix.
14:04:08 <Cale_> It's a function application
14:04:12 <dino-> @paste
14:04:12 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:04:17 <dolio> Space is the operator.
14:04:25 <Cale_> dolio: I agree :)
14:04:41 <mauke> ok, because "suffix beats prefix beats infix" simplifies the C precedence table
14:04:42 <dino-> That paste is dead. Where do we like to paste lately around here?
14:04:53 <kmc> hpaste.org
14:04:55 <kmc> codepad.org
14:05:03 <c_wraith> @where hpaste
14:05:03 <lambdabot> http://hpaste.org/
14:05:07 <Cale_> I like that Haskell took the care to make it work correctly.
14:05:15 <dolio> I don't know why we care about C.
14:05:17 <zygoloid> Cale_: but it /doesn't/ work correctly
14:05:22 <zygoloid> > -3 `mod` 4
14:05:23 <lambdabot>   -3
14:05:24 <Cale_> Rather than just doing something not quite right, because it's simpler.
14:05:30 <Cale_> zygoloid: mod is multiplicative
14:05:31 <mauke> I like how Haskell completely broke -
14:05:32 <c_wraith> > -3 `rem` 4
14:05:33 <lambdabot>   -3
14:05:39 <dino-> Thank you kmc, c_wraith.
14:05:51 <mauke> > -3 + 2
14:05:52 <lambdabot>   -1
14:06:03 <Cale_> So -3 `mod` 4 means -(3 `mod` 4), like I'd expect
14:06:15 <zygoloid> Cale_: your expectations are weird, imo :)
14:06:15 <Cale_> Despite the weird spacing ;)
14:06:28 <mauke> > -3 `shiftL` 1
14:06:29 <lambdabot>   Ambiguous type variable `a' in the constraint:
14:06:29 <lambdabot>    `Data.Bits.Bits a'
14:06:29 <lambdabot>      a...
14:06:34 <mauke> > -3 `shiftL` 1 :: Int
14:06:35 <lambdabot>   -6
14:06:43 <benmachine> hmm but mathematically it's usually written -3 (mod 4)
14:06:46 <c_wraith> > (-3) `mod` 4
14:06:47 <lambdabot>   1
14:06:50 <Cale_> If you just remember that everything having to do with multiplicative structure comes before anything to do with additive structure, it all makes sense.
14:06:50 <benmachine> and that's 1, pretty sure
14:06:54 <c_wraith> > (-3) `rem` 4
14:06:55 <lambdabot>   -3
14:07:18 <zygoloid> Cale_: if you remember to put unary negation in parentheses, it all makes sense :)
14:07:23 <benmachine> except inasmuch as mod isn't really an operator in mathsworld
14:07:24 <zygoloid> but the precedence of mod is still wrong (imo)
14:07:30 <BMeph> -3 (`mod` 4)
14:07:37 <BMeph> > -3 (`mod` 4)
14:07:37 <lambdabot>   -3
14:07:43 <Cale_> mod should have the same precedence as div
14:07:43 <mauke> heh
14:07:47 <Cale_> and div is division
14:07:56 <dolio> No. An expression like that would be '-3 == 1 (modulo 4)', which specifies an equation in modular arithmetic.
14:08:03 <benmachine> why should mod and div necessarily have the same precedence
14:08:04 <dolio> That's not using mod as an operator.
14:08:36 <zygoloid> Cale_: you make a good point... :)
14:09:10 <Cale_> It would be somewhat cool to have a mod like in mathematics, but I'm not sure how that would work.
14:09:12 <BMeph> benmachine: Why shouldn't they?
14:09:17 <mauke> sin x²
14:09:36 <Cale_> x == y (mod n) would have to mean  x `mod` n == y `mod` n
14:09:42 <Cale_> and that would be weird.
14:09:48 <benmachine> BMeph: because it surprises me
14:09:53 <benmachine> er by me I mean people
14:10:09 <BMeph> benmachine: Why does it surprise you?
14:10:30 <BMeph> ...er, "people"... ;)
14:10:35 <benmachine> <_< >_>
14:10:42 <benmachine> in -3 `mod` 4
14:10:44 <Cale_> It's for a similar reason to + and - having the same precedence.
14:10:50 <benmachine> the - looks like it is hugging the 3
14:10:54 <c_wraith> > let f ^ n = (!! (n - 1)) . iterate f in sin ^ 2 $ x
14:10:55 <lambdabot>   sin x
14:10:56 <benmachine> and the mod happens afterwards
14:10:57 <lispy> Cale_: Hmm...I think you could do that in agda using mixfix
14:10:57 <dolio> That confuses people because of the way it's written.
14:11:05 <soupdragon> I HATE SIN^2
14:11:11 <c_wraith> > let f ^ n = (!! n) . iterate f in sin ^ 2 $ x
14:11:12 <lambdabot>   sin (sin x)
14:11:16 <dolio> People thing -3 * 4 is (-3) * 4. The only difference is that it doesn't matter there.
14:11:20 <c_wraith> la de dah...
14:11:23 <mauke> > sin ^ 2 $ x
14:11:24 <lambdabot>   sin x * sin x
14:11:31 <mauke> > sin ^ 3 $ x
14:11:32 <lambdabot>   sin x * sin x * sin x
14:11:35 <mauke> BAM!
14:11:39 <soupdragon> > sin ^ (-1) $ x
14:11:40 <lambdabot>   *Exception: Negative exponent
14:11:42 <benmachine> bam indeed.
14:11:52 <Cale_> > sin ^^ (-1) $ x
14:11:53 <lambdabot>   recip (sin x)
14:11:58 <zygoloid> > 1 2 3 :: Int
14:11:59 <soupdragon> so the functions form a ring with (+) and (*) POINTWISE
14:12:00 <lambdabot>   1
14:12:06 <soupdragon> but linear operators form a ring with (+) and (.) 
14:12:15 <soupdragon> so D^2 f = D(Df) works
14:12:17 <soupdragon> and makes sense
14:12:40 <Cale_> soupdragon: In practice, you disambiguate by context.
14:12:43 <aavogt> @type (^ 2)
14:12:44 <lambdabot> forall a. (Num a) => a -> a
14:12:46 <zygoloid> > 3 x 3
14:12:47 <lambdabot>   Ambiguous type variable `t' in the constraint:
14:12:47 <lambdabot>    `GHC.Num.Num t' arising f...
14:12:50 <zygoloid> > 3 x 3 :: Int
14:12:51 <lambdabot>   3
14:12:56 <Cale_> soupdragon: But sin^-1 is still somewhat awkward
14:13:04 <soupdragon> so now that I think about it,...  sin^2(x) = (sin * sin)(x) = sin(x) * sin(x)  is okay
14:13:06 <Cale_> soupdragon: I prefer arcsin for the inverse sine function
14:13:12 <soupdragon> yes Cale, it's really  sin^-1(x)  that is wrong
14:13:23 <soupdragon> I never realized this before..... I was blaming the wrong guy
14:13:30 <Cale_> f^-1(x) for inverse functions in general however, I mind less.
14:13:33 <zygoloid> soupdragon: yeah, unless you expect sin^2x == sin (sin x)
14:13:46 <soupdragon> zygoloid, the reason that does not make sense it because sin is not linear
14:13:54 <Cale_> It's just a problem of which operation you're inverting with respect to
14:13:58 <soupdragon> so composition cannot be the ring multiplication operation
14:14:17 <Cale_> Usually there's only one which makes sense in a given context, and when writing mathematics, we're all humans and are smart enough to figure it out.
14:14:27 <zygoloid> soupdragon: i'm not sure what your point is?
14:14:29 <soupdragon> I'm gonna go with  fº  for inverses I think
14:14:34 <soupdragon> f^o
14:14:46 <soupdragon> because that's what they use for the opposite of a relation in AoP
14:15:35 <Cale_> You might decide to do something like that if you had a lot of multiplicative and compositional exponentiation in the same place.
14:15:55 <Cale_> another option would be to write a circle around the exponent when it's compositional
14:16:03 <Cale_> or something similar
14:16:33 <Cale_> f^{\circ 2}
14:16:37 <Cale_> for f \circ f
14:16:56 <Cale_> and f^{\cdot 2} for f \cdot f
14:17:08 <Ran__> lambdabot up there claimed  (f . g) x = f (g x)  But   (max . 5) 4   gives me a syntax error, in what way am I thinking wrong here?
14:17:15 <Cale_> (or just f^2 for one of the two)
14:17:22 <mauke> Ran__: max (5 4) is an error
14:17:35 <Cale_> Ran__: 5 isn't (normally) a function
14:17:41 <Cale_> Ran__: So you can't apply it to 4
14:17:59 <zygoloid> Ran__: you want max 5 4 not max (5 4)
14:18:00 <Ran__> Ah, I get it now, it's for applying functions.
14:18:13 <zygoloid> max 5 4 == (max 5) 4
14:18:27 <Cale_> Ran__: Remember that parens in Haskell are used only for grouping (and tuples)
14:18:43 <mauke> and sections
14:18:53 <aristid> > (curry max) (5, 4)
14:18:53 <Cale_> Right, okay :)
14:18:54 <lambdabot>   Overlapping instances for GHC.Show.Show
14:18:54 <lambdabot>                              (b -> ...
14:19:03 <kmc> Ran__, 
14:19:04 <mauke> > uncurry max (5, 4)
14:19:05 <lambdabot>   5
14:19:13 <kmc> there's a difference between composition and application
14:19:17 <Ran__> But "grouping" could also mean "grouping arguments", but that's not the case :)
14:19:19 <kmc> (.) and ($) respectively
14:19:28 <soupdragon> how would you use infinity in haskell (specifically to differentiate a function that uses it)?
14:19:31 <kmc> composition takes two functions and gives you a function that does both computations
14:19:36 <Cale_> Ran__: right, when you write  f x y z  it always means ((f x) y) z
14:19:36 <aristid> mauke: why do i always confuse curry and uncurry *sigh*
14:19:49 <zygoloid> are we considering module where clauses and import lists as grouping or tuples? ;-)
14:19:51 <kmc> application takes a function and an argument and gives you the result
14:20:01 <Cale_> Ran__: which means "apply the function f to the parameter x, and then apply the result to the parameter y, and then apply the result of that to the parameter z"
14:20:10 <zygoloid> (yeah, clearly they're tuples, but not of expressions)
14:20:29 <soupdragon> a principle bundle has moral fiber
14:21:08 <Cale_> Ran__: A nice thing in Haskell is that every function really has exactly one parameter.
14:21:33 <Cale_> and because applying functions to values is so fundamental, we give it the nicest possible syntax: whitespace :)
14:21:41 <Tomsik_> soupdragon: I'm not sure if it makes sense with derivatives in common sense
14:22:00 <soupdragon> I don't need common sense
14:22:15 <Tomsik_> are you talking about what kind of functions?
14:22:17 <Tomsik_> R -> R?
14:22:25 <soupdragon> no it's not R -> R that's my problem
14:22:38 <soupdragon> the function is this: http://upload.wikimedia.org/math/5/2/6/5260159c0620fe316ca2a15b6504616b.png
14:22:43 <soupdragon> in haskell something like
14:22:52 <soupdragon> v q = if q >= 0 then 0 else infinity
14:23:12 <alexbobP> (\x -> true) soupdragon
14:23:13 <EliasAmaral> > ((+ 1) $ 2, (+ 1) 2)
14:23:14 <lambdabot>   (3,3)
14:23:20 <EliasAmaral> it seems that a $ b is the same as a b
14:23:40 <EliasAmaral> maybe $ is used to avoid ()?
14:23:41 <soupdragon> @hackage RAD
14:23:42 <lambdabot> http://hackage.haskell.org/package/RAD
14:23:52 <mtnviewmark> :t ($ "yo")
14:23:52 <lambdabot> forall b. ([Char] -> b) -> b
14:23:53 <EliasAmaral> or maybe i'm misunderstanding it
14:24:00 <mtnviewmark> :t "yo"
14:24:01 <lambdabot> [Char]
14:24:09 <mtnviewmark> hmmm... seem different to me!
14:24:37 <EliasAmaral> > ($ "yo")
14:24:38 <lambdabot>   Overlapping instances for GHC.Show.Show
14:24:38 <lambdabot>                              (([GHC...
14:24:40 <soupdragon> diff (\x -> if x >= 0 then 0 else 1)  appears to just give  const 0
14:24:59 <EliasAmaral> is ($ "yo") a valid piece of code?
14:25:11 <mtnviewmark> yes - it is an operator section
14:25:13 <zygoloid> f x /= 0 => f x = f^2 x * f^-1 x. cos 0 /= 0. therefore 1 = cos 0 = cos^2 0 * cos^-1 0 = pi / 2. hence pi == 2.
14:25:14 <soupdragon> in the case of 0,1 I could just smooth it down.... but with the case of 0,infinity I cannot smooth it afaict
14:25:22 <mtnviewmark> like (+ 10) is a function that adds 10 to it's argument
14:25:41 <Ran__> Ah, now I'm starting to get that nice foldr-function before.  (foldr lcm 1 . enumFromTo 1) n === foldr lcm 1 (enumFromTo 1 n) === foldr lcm 1 [1..n]     They are all the same, right? I can't see why you would want to use the first version.
14:25:50 <mtnviewmark> so ($ "yo") is a function that takes a function from String to x, applies it to "yo" and returns the result
14:26:17 <kau> hello!
14:26:19 <mtnviewmark> really, I think you might have meant earlier to say     f  $ b   is the same as   f b
14:26:21 <EliasAmaral> > ($ "yo") (\x -> x)
14:26:22 <lambdabot>   "yo"
14:26:26 <zygoloid> Ran__: that's correct. you might even want just foldr1 lcm [1..n]
14:26:41 <EliasAmaral> mtnviewmark, @.@''
14:26:55 <mtnviewmark> > ($ "yo") reverse
14:26:56 <lambdabot>   "oy"
14:27:00 <EliasAmaral> yes, i used a $ b but those were "free"
14:27:08 <Ran__> zygoloid, wait... "foldr1" is a foldr function but with the first argument being 1? Nice.
14:27:14 <mtnviewmark> so  (f $ b) is the same as (f b)
14:27:32 <zygoloid> Ran__: no, it's the foldr1 function but with the first argument being the first thing in the list, run on the rest of the list
14:27:38 <mtnviewmark> but, say (f $ b c) is different from (f b c) 
14:27:38 <zygoloid> Ran__: so it fails if the given list is empty
14:27:44 <mtnviewmark> it is the same as (f (b c))
14:27:46 <zygoloid> > foldr f x [a,b,c,d]
14:27:47 <lambdabot>   f a (f b (f c (f d x)))
14:27:49 <zygoloid> > foldr1 f [a,b,c,d]
14:27:50 <lambdabot>   f a (f b (f c d))
14:27:52 <zygoloid> Ran__: ^^ like that
14:27:56 <Ran__> zygoloid, ah, okay
14:27:59 <aristid> @src ($)
14:27:59 <lambdabot> f $ x = f x
14:28:00 <EliasAmaral> mtnviewmark, ahh. as I thought, it has to do with ()
14:28:14 <soupdragon> smooth f x = (f (x-epsilon) + f x + f (x + epsilon))/3
14:28:17 <soupdragon> smooth epsilon f x = (f (x-epsilon) + f x + f (x + epsilon))/3
14:28:43 <mtnviewmark> right: adjacency like    f  b    has very tight precedence, where as $ has very loose precedence 
14:28:45 <EliasAmaral> mtnviewmark, yours and kmc's explanations made it a bit easier to read code pasted here, thank you
14:29:30 <mtnviewmark> you can generally read $ as "parenthesize everything to the right and supply it as a single argument to the current value on the left"
14:29:31 <Ran__> foldr1 f [a,b,c,d] ⇒ f a (f b (f c d)) confuses me a bit, shouldn't it be f d c  first?
14:29:55 <soupdragon> smooth doesn't work actualyl, not sure why
14:30:21 <EliasAmaral> @src foldr1
14:30:21 <lambdabot> foldr1 _ [x]    = x
14:30:22 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
14:30:22 <lambdabot> foldr1 _ []     = undefined
14:30:46 <zygoloid> > let smooth epsilon f x = (f (x-epsilon) + f x + f (x + epsilon))/3; jazz = (+); sax = (/); listen = 3; to = 4 in smooth jazz on sax id listen to
14:30:47 <lambdabot>   0.75
14:31:05 <EliasAmaral> Ran__, the first expansion is to f a (foldr1 [b,c,d])
14:31:13 <kau> I'm currently making a little server. How can i avoid the burden of carrying the "Handle" of a client trought every function that wants to output smthg to the client?
14:31:40 <Ran__> I get that it's expanded like that, but is that what you want most often?
14:31:46 <Ran__> I'm not very used to folding...
14:31:51 <zygoloid> Ran__: well, there's foldl to go the other way
14:31:55 * benmachine hugs zygoloid 
14:31:58 <zygoloid> > foldl1 f [a,b,c,d]
14:31:58 <EliasAmaral> seems to evaluate in the "tail recursive" order (from the head of the list to the tail)
14:32:00 <lambdabot>   f (f (f a b) c) d
14:32:17 <EliasAmaral> evaluating a list in the wrong order might cause stack overflows
14:32:19 <zygoloid> Ran__: but foldr1 allows you to start producing the result before you look at the end of the list
14:35:33 <EliasAmaral> @src foldl1
14:35:33 <lambdabot> foldl1 f (x:xs) = foldl f x xs
14:35:33 <lambdabot> foldl1 _ []     = undefined
14:36:17 <EliasAmaral> @src foldl
14:36:18 <lambdabot> foldl f z []     = z
14:36:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:37:38 <kmc> kau, Reader monad / ((->) Handle) monad
14:38:23 <kmc> kau, or perhaps you can define your functions in a "let" or "where" block where the handle is already in scope, and keep those function / action values around for use later
14:38:30 <kau> kmc: i don't know Reader monad, is that close to State monad (which i know for the moment)
14:38:31 <kau> ?
14:38:38 <kmc> kau, yes, it's like State with no update
14:38:41 <kmc> @unmtl State s a
14:38:42 <lambdabot> s -> (a, s)
14:38:43 <kmc> @unmtl Reader s a
14:38:44 <lambdabot> s -> a
14:38:54 <kmc> i.e., when a client connects, you populate a record with various useful functions / actions that have the Handle baked in
14:40:00 <kau> seems interesting. 
14:40:29 * BMeph prefers the Reader comonad!
14:40:49 <kau> But every function still have to return that Reader monad?
14:41:07 <kmc> you'd build actions in the (Reader Handle) monad, yes
14:41:29 <kmc> you might use Applicative instead of Monad
14:41:38 <kmc> either way, it's basically syntactic sugar so you don't have to mention the handle at every sub-call
14:41:52 <kmc> i think the other suggestion (populate a record) might be nicer though
14:42:02 <kau> My concern is not to polute code with tecnical stuff like Handle, which should be kept hidden from "job oriented" code
14:42:19 <kmc> kau, well, abstract Handle away if you like
14:42:28 <kmc> data ConnectionState = ConnectionState { csHandle :: Handle, other stuff }
14:42:41 <kmc> you can even newtype-wrap the Reader monad too
14:42:46 <kau> yes
14:42:54 <kmc> and provide a "connection monad" with some domain-specific actions
14:43:12 <kau> that seems interresting
14:43:25 <benmachine> I like having write and read closures
14:43:48 <kmc> yes
14:43:56 <kau> oups, what is closures?
14:44:18 <kmc> kau, when you define a function locally which captures some values from its environment
14:44:27 <kau> i never understood that;)
14:44:50 <kmc> strictly speaking, a closure is an in-memory data structure for implementing these
14:45:00 <hpc> @unmtl IO a
14:45:00 <lambdabot> IO a
14:45:06 <benmachine> yeah I couldn't remember what the proper term was
14:45:11 <hpc> >.>
14:46:09 <kau> so closure are not used with top level functions?
14:46:23 <kmc> not really
14:46:31 <kmc> free variables at top level are usually treated differentl
14:46:42 <kmc> but you can have a top-level function that returns a function
14:46:50 <kmc> and the latter function might have closure over free variables
14:46:59 <kmc> and in Haskell every "multi-argument function" is a function which returns a function
14:47:01 <kau> hum i see
14:47:16 <kmc> e.g., if you have your handle hdl, you can call (hPutStr hdl) somewhere, and save that value (of type String -> IO ()), and later use it to send stuff to the client
14:47:24 <kmc> the value is a function which has the handle baked in
14:47:26 <kau> so partial evaluation is a closure?
14:47:34 <kmc> kau, do you mean partial application?
14:47:45 <kau> yes
14:47:49 <kmc> the result of a partial application could be represented in memory by a closure
14:47:55 <kau> ok
14:47:58 <kmc> that is one way to build a closure, out of many
14:48:15 <kmc> Haskell doesn't really have partial application -- every function has only one arg, so it's either not applied or fully applied
14:48:32 <kau> oh, i see! so i'm making closures every days without thinking ;)
14:48:36 <kmc> but we still speak as though it does
14:48:55 <kmc> and "partial application" then just means that you apply a function which returns another function without doing any extra work
14:49:06 <kmc> ... except that laziness and let-lifting complicate the issue eve nmore
14:49:15 <kmc> kau, yes, you are :)
14:50:07 <kau> functions in haskell are allways curried (or uncurried never know)
14:50:21 <kmc> kau, kind of
14:50:30 <kmc> functions in Haskell only have one argument
14:50:41 <kmc> if you want a multi-argument function, you have to choose a convention for how to represent it
14:50:46 <kmc> there's at least two conventions:
14:50:54 <kmc> the "curried convention":  \a -> \b -> ...
14:51:00 <kmc> the "uncurried convention": \(a, b) -> ...
14:51:11 <kmc> returning a function, versus taking a tuple
14:51:18 <kmc> so when people say "Haskell functions are curried"
14:51:31 <kmc> what it means is, Haskell's syntax and standard libraries are set up to encourage the curried convention
14:51:40 <aavogt> people tend to return tuples rather than continuations
14:51:42 <kau> yes
14:51:48 <kmc> that's all it is, convention + convenient syntax
14:51:51 <aavogt> so it's not consistent
14:51:54 <kmc> you can use this convention in any decent language
14:52:06 <kmc> but it's usually more trouble
14:53:04 <kau> in not functionnal languages, must be
14:53:35 <kmc> kau, how do you define "functional language"?
14:54:07 <kmc> most general-purpose languages have first-class functions
14:54:18 <kau> i meant imperative. functional to me would be where function are first class 
14:54:29 <kmc> most imperative languages have first-class functions
14:54:32 <kmc> for example, Haskell
14:54:38 <benmachine> :P
14:54:39 <kau> mmh
14:54:47 <jmcarthur> haskell is super-imperative
14:54:55 <jmcarthur> imperativeness is a library ;)
14:54:57 <kmc> C++ and Java aren't following some "alternative paradigm".  they are just broken.
14:55:10 <kau> lol
14:55:39 <kau> by the way, java uses to feed us
14:56:54 <kmc> C#, Perl, Python, PHP, Ruby, Javascript, Scheme, Lisp, Erlang, Clojure, Scala, Groovy, Haskell, D, Vala, OCaml, SML, haXe, Lua all have first-class functions, even though they have little else in common
14:57:05 <kmc> just like they all have integer types
14:57:14 <kau> wow
14:58:12 <kau> in Ada you have some sort of genericity where you can pass functions...
14:58:29 <kmc> "lacking first-class functions" is no more a paradigm than "lacking integers"
14:58:41 <kmc> both are excusable in special-purpose languages
14:58:45 <aristid> what _is_ a paradigm, then?
14:58:47 <kmc> not so much for general programming
14:58:56 <Veinor> they're also similar in that lacking those is a bad feature of a language ;)
14:58:57 <jmcarthur> "paradigm" is meaningless
14:59:10 <aavogt> aristid: ssh, nobody is supposed to know what we're actually talking about
14:59:19 <kau> but paradigm help to understand, sometimes.
14:59:29 <aristid> aavogt: did you learn that technique from the java guys?
14:59:31 <jmcarthur> it helps to confuse with a false ontology
14:59:37 <kau> even if the bounds of the boxes are kind of blured
14:59:46 <kmc> kau, sure, and i agree there's "functional-style code" versus "imperative-style code".  but that's a property of code, not of the whole language
15:00:00 <kmc> the most you can say about a language is that it encourages some styles and discourages others, and that's often pretty fuzzy
15:00:11 <kau> yes
15:00:18 <kmc> some languages aren't very consistent about what they encourage
15:00:32 <aavogt> aristid: I'm not very familiar with how it works over there
15:00:32 <kmc> Perl and C++ tend to encourage a different style in every programmer
15:00:46 <noobskell> hi
15:00:53 <kmc> hi noobskell
15:01:06 <aavogt> is it the language or the culture that encourages consistency?
15:01:19 <msieradzki> kmc just cause we're trollling
15:01:23 <msieradzki> Perl is more consistent than C++
15:01:38 <kau> for C++, there is a library called FC++. Don't know it.
15:01:38 <kmc> are we trolling? it's not effective trolling if nobody ever comes to the defense of Perl or C++
15:01:42 <kmc> that seems to be the case
15:01:51 <noobskell> how can I atuomatically turn error prone list functionse.g., head or !! to return Maybe rather than raise error?
15:01:55 <kmc> when C++ is mentioned here, there's usually vigorous agreement
15:02:08 <kmc> noobskell, use a different function
15:02:21 <kmc> noobskell, if you really really have to do what you said, there's the "spoon" library on Hackage
15:02:24 <aavogt> @hackage spoon
15:02:24 <lambdabot> http://hackage.haskell.org/package/spoon
15:02:29 <aristid> kmc: i like perl, it's fun
15:02:31 <kmc> noobskell, but almost certainly, you should use a different function.  head and (!!) are both major code smells
15:02:32 <Saizan> noobskell: see the safe package on hackage
15:03:39 <noobskell> how does spoon work?
15:03:47 <ivanm> Saizan: would that be the safe or the Safe package? :p
15:03:48 <kmc> noobskell, unsafePerformIO
15:03:49 <kau> noobskell: or just write your own safeHead :: a -> [a] -> a that takes a default 
15:03:58 <ivanm> or use listToMaybe
15:04:02 <kau> (what i did)
15:04:03 <ivanm> > listToMaybe [1..10]
15:04:04 <kmc> noobskell, very short code: http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/src/Control-Spoon.html
15:04:04 <lambdabot>   Just 1
15:04:09 <ivanm> > listToMaybe []
15:04:11 <lambdabot>   Nothing
15:04:25 <aavogt> preflex: seen copumpkin
15:04:25 <preflex>  copumpkin was last seen on #haskell-blah 39 days, 14 hours, 8 minutes and 20 seconds ago, saying: * copumpkin goes poof
15:04:46 <zygoloid> wow
15:04:56 <zygoloid> preflex: seen pumpkin
15:04:56 <preflex>  pumpkin was last seen on #haskell-blah 38 days, 12 hours, 18 minutes and 56 seconds ago, saying: Ciao!
15:04:56 <aristid> preflex: seen aavogt
15:04:57 <preflex>  aavogt was last seen on #haskell 32 seconds ago, saying: preflex: seen copumpkin
15:05:00 <ivanm> he's on his grand european adventure
15:05:09 <ivanm> so who knows when he'll be back
15:05:17 <aristid> ivanm: i heard there's internet in europe!
15:05:32 <ivanm> aristid: except he's backpacking, etc.
15:05:34 <msieradzki> I heard that americans have more than 56k
15:05:37 <aavogt> they don't really have pumpkins though
15:05:38 <kmc> crackpacking
15:05:42 * zygoloid tests aristid's theory by sending packets all over the world
15:05:44 <ivanm> and may have more important things to do than come here
15:05:51 <ivanm> aavogt: ummm... yes they do...
15:05:53 <aristid> zygoloid: did it work? did it work?
15:05:54 <kau> wow that's fantastic, i use to live in europe
15:06:05 <zygoloid> aristid: not sure. where are you? :)
15:06:14 <aristid> zygoloid: i think i'm in germany
15:06:35 <zygoloid> oh. then i don't know. :) but i know my packets got to california at least
15:06:46 <zygoloid> that's in europe though right?
15:08:05 <aristid> zygoloid: must be
15:08:15 * Lycurgus thought europe was in germany.
15:08:26 <noobskell> kmc, so what are the drawbacks of using it?
15:08:29 <ivanm> Lycurgus: :/
15:08:34 <kau> kmc: thanks for your help.
15:08:47 <zygoloid> is there a module on hackage for z-decoding names?
15:09:02 <aristid> Lycurgus: are you sure you're not confusing that with france?
15:09:03 * ivanm heads off to another day of hacking at AusHac
15:09:30 <kau> Lycurgus: europe actually circle around jupiter
15:09:39 <Lycurgus> mehbe, guess that's why they call it Frankreich
15:11:05 <benmachine> europe's in belgium isn't it?
15:11:16 <benmachine> brussels
15:11:40 <aristid> i thought belgium is just the capital of brussels
15:12:07 * kau is horified
15:12:13 <tensorpudding> europe is in belgium?
15:12:28 <ksf> the capital, yes.
15:12:38 <ksf> for certain values of "capital", at least.
15:12:56 <ksf> the parliament e.g. is in strasbourg.
15:13:04 <msieradzki> EU /= Europe
15:13:07 <ksf> I think that's in france
15:13:09 <tensorpudding> I find it oddd to conflate EU with Europe.
15:13:17 <benmachine> msieradzki: the U stands for Urope doesn't it?
15:13:23 <msieradzki> I think it very simple for someone who doesn't have any idea about Europe
15:13:27 <msieradzki> I find* :P
15:13:28 <tensorpudding> The latter is a continent, the former is a political entity
15:13:40 <kau> yes
15:13:46 <pikhq> And only nominally related with Europe.
15:13:50 <aavogt> the continent is rather fuzzy too
15:13:55 <ksf> hmmm. what's usually called "europe" is, for the most part, in the eu. 
15:14:01 <kau> switzerland is not in Europe.
15:14:03 <msieradzki> EU for instance ends at half of Europe's size
15:14:04 <pikhq> Though unlikely, the US could randomly want to join the EU and the EU could let them.
15:14:10 <ksf> most obvious exceptions are switzerland and norway
15:14:11 <msieradzki> pretty much in the center of it
15:14:34 <bnonym> kau: where is switzerland then?
15:14:40 <tensorpudding> Russia is both in Europe and outside of Europe
15:14:45 <benmachine> pikhq: surely the concept of a continent is rather nominal in any case, though
15:14:48 <tensorpudding> it's not in the EU though
15:14:50 <ksf> norway is in the schengen treaty, though, and switzerland implements virtually all EU regulations
15:14:54 <kau> sorry, i meant not in EU ;)
15:14:58 <zygoloid> what's the nicest way to get the equivalent of python's  a, b, c, rest = s.split('_', 3) ?
15:15:00 <ksf> (as does norway)
15:15:03 <pikhq> benmachine: Particularly the concept of *Europe* as a continent.
15:15:12 <pikhq> Given that it is the exact same landmass as Asia.
15:15:27 <bnonym> asia is just another part of europe :P
15:15:27 <zygoloid> (that is, "foo_bar_baz_quux_abc" -> ["foo", "bar", "baz", "quux_abc"]
15:15:29 <msieradzki> yes, but it's defined as a land from Spain to Ural
15:15:31 <msieradzki> more or less
15:15:41 <bnonym> msieradzki: what is with portugal?
15:15:43 <aavogt> zygoloid: there's a package for that
15:15:44 <ksf> as to the less defined parts, iceland isn't in, and technically everything up to the ural and turkey could well be considered europe.
15:15:46 <aavogt> @hackage split
15:15:46 <lambdabot> http://hackage.haskell.org/package/split
15:15:48 <tensorpudding> What about turkey?
15:16:08 <ksf> after the east states joined, though, it's common to conflate the EU and europe
15:16:09 <kau> Turkey in Europe. 
15:16:13 <bnonym> tensorpudding: turkey is for thanksgiving :P
15:16:15 <zygoloid> aavogt: Data.List.Split doesn't do the at-most-three-splits thing
15:16:40 <aavogt> you can take the first three, then unsplit the rest
15:16:42 <zygoloid> i can split and reassemble the tail, but i was hoping for something cleaner
15:17:12 <ksf> turky is as much europe as say utah is in the US
15:17:37 <tensorpudding> The landmass or the conception of Europe?
15:17:46 <aavogt> > iterate (takeWhile (/= '_') . dropWhile (== '_') "foo_bar_baz_quux_abc" !! 3
15:17:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:17:54 <aavogt> > iterate (takeWhile (/= '_') . dropWhile (== '_')) "foo_bar_baz_quux_abc" !! 3
15:17:55 <lambdabot>   "foo"
15:17:58 <ksf> the landmass up to istanbul, plus culturally and linguistically.
15:18:20 <ksf> turkish is closely related to the finno-uguric languages
15:18:37 <aristid> to the continentalist: you say europe is a continent, i say europe has multiple meanings.
15:18:45 <aristid> it can mean the continent
15:18:49 <aristid> it can mean the EU
15:18:53 <msieradzki> no
15:19:01 <ksf> them trying to burn vienna doesn't count, it's not like e.g. france and england have always been friends
15:19:02 <tensorpudding> There are plenty of languages in the IE group that are not in Europe
15:19:02 <aristid> it can mean a vague half-defined concept "European culture"
15:19:02 <aavogt> > iterate (break (== '_') . snd) (undefined,"foo_bar_baz_quux_abc") !! 3
15:19:03 <lambdabot>   ("","_bar_baz_quux_abc")
15:19:04 <aristid> msieradzki: yes.
15:19:10 <ksf> there's no continent called eu.
15:19:14 <ksf> er europe.
15:19:16 <msieradzki> continent, culture fine
15:19:17 <ksf> that'd be eurasia.
15:19:25 <msieradzki> very specific union of countries not exactly
15:19:31 <aristid> msieradzki: you don't get to choose how people use words
15:19:42 <aristid> and how the words are used is what defines the language
15:19:42 <msieradzki> but I can say that it's a mistake :)
15:19:47 <msieradzki> yes ^
15:19:57 <mtnviewmark> anyone have a good mnemonic for remembering the difference between intersperse and intercalate?
15:20:03 <aristid> what does "mistake" mean, even?
15:20:17 <msieradzki>  what was originally a mistake
15:20:19 <msieradzki> if commonly used
15:20:27 <aavogt> mtnviewmark: the one with a c involves a concat
15:20:43 <msieradzki> just gets accepted as a normal definition
15:20:50 <mtnviewmark> ah - nice, thanks aavogt!
15:21:03 <aavogt> @type (intersperse, \x -> concat intersperse x, intercalate)
15:21:04 <lambdabot>     Couldn't match expected type `[[a]]'
15:21:04 <lambdabot>            against inferred type `a1 -> [a1] -> [a1]'
15:21:04 <lambdabot>     In the first argument of `concat', namely `intersperse'
15:21:10 <aavogt> @type (intersperse, \x -> concat . intersperse x, intercalate)
15:21:11 <lambdabot> forall a a1 a2. (a -> [a] -> [a], [a1] -> [[a1]] -> [a1], [a2] -> [[a2]] -> [a2])
15:21:14 <msieradzki> europe certainly isn't few countries out of ~50 that Americans tend to visit from time to time ;P
15:21:45 <zygoloid> aavogt: turns out i want to turn '_' to ' ' in the final word. so i do that first and do the rest with words and unwords. :)
15:22:20 <aristid> msieradzki: if i as a german say europe, i usually don't mean russia, or ukraine... yes, that is arrogant and western-centric, but it's the truth
15:22:48 <Ran__> I really need to get away from this whole \x syntax... I got phi = foldr1 (\x y -> sqrt (x + y)) (take 500 (repeat 1))   to calculate phi, but I know that there's a better way to send in those two arguments... how?
15:23:20 <Saizan> not really..
15:23:22 <mauke> take n . repeat == replicate n
15:23:32 <jmcarthur> @pl foldr1 (\x y -> sqrt (x + y)) (take 500 (repeat 1))
15:23:32 <lambdabot> foldr1 ((sqrt .) . (+)) (take 500 (repeat 1))
15:24:11 <jmcarthur> :t foldr1 ((fmap.fmap) sqrt (+)) $ replicate 500 1
15:24:13 <lambdabot> forall a. (Floating a) => a
15:24:14 <aristid> msieradzki: it's also that culture and politics shape each other. if a more or less random collection of 25 states is lumped together, and called EU, then that defines an in-group, and it affects how people use words like "Europe"
15:24:25 <ksf> huh.
15:24:38 <ksf> greenland isn't in the eu, but all greenlanders are eu citizens.
15:25:06 <ksf> that's what happens if you're both independent _and_ belong to denmark.
15:25:58 <kmc> noobskell, the drawbacks of using spoon?
15:26:35 <kmc> noobskell, many
15:26:47 <kmc> noobskell, shall i list some?
15:28:49 <aavogt> what's a practical drawback besides less laziness?
15:28:58 <benmachine> :t stream2list
15:29:00 <lambdabot> Not in scope: `stream2list'
15:29:02 <benmachine> aw
15:29:28 <benmachine> zygoloid: just for your amusement:
15:30:01 <benmachine> import Data.Iteratee as I; let bit = I.break (== '_') <* I.drop 1 in run =<< (enumPure1Chunk "foo_bar_baz_quux_abc" $ (,,) <$> bit <*> bit <*> stream2list)
15:30:37 <zygoloid> haha, nice :)
15:32:06 <kmc> speed (throw and catch versus returning Maybe directly), dependence on non-Haskell98 (unsafePerformIO from FFI, extensible exceptions, scoped type variables), caring about evaluation order when you otherwise wouldn't, need NFData instances, slowness of deepseq exhaustive traversal
15:32:26 <kmc> non-monotonic denotational semantics
15:32:39 <kmc> arbitrary list of catchable bottoms
15:32:50 <benmachine> spoon doesn't actually *require* scopedtypevariables
15:32:59 <benmachine> and only catches bottoms that shouldn't have been thrown :P
15:33:14 <kmc> who's to say they caught only and all of the deterministic exceptions
15:33:24 <benmachine> well, only isn't that hard
15:33:36 <benmachine> hmm except you can abuse throwTo perhaps
15:33:44 <benmachine> all isn't necessary is it?
15:34:24 <kmc> anyway i'm not trashing on spoon for what it claims to be, but it's nowhere as good a solution as actually using the right function in the first place ;)
15:34:27 <aavogt> you believe that Maybe is quicker than exceptions?
15:34:41 <kmc> aavogt, i have a guess that Maybe is quicker than exceptions + Maybe
15:34:55 <kmc> it's only a guess, i'd want to check it to be sure
15:35:16 <aavogt> this is supposing you don't have an expensive NFData instance (or the one that uses seq is enough)
15:35:35 <benmachine> teaspoon?
15:35:55 <aavogt> I guess
15:36:26 <aavogt> kmc: you need to check for Nothing every time you handle values that are Maybe
15:36:38 <kmc> aavogt, but if you're using spoon, presumably you're checking the result too
15:36:42 <FunctorSalad> Cale_: dolio : I got the IntCatIsInt category ;) to work, but I lost the plot on what exactly the point was :(
15:36:44 <FunctorSalad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27642#a27643
15:36:49 <aavogt> kmc: checking at the end
15:36:58 <kmc> aavogt, oh, i see
15:37:02 <kmc> good point
15:37:24 <FunctorSalad> (what I'm gaining over the simple data IntCat a b = IntCat (Int -> Int))
15:37:42 <aavogt> but who knows what gets inlined or whatever
15:37:52 <FunctorSalad> I guess the point is that the GADT can depend in arbitrary ways on a and b, not just constant
15:38:22 <aavogt> rules like     fmap f . fmap g  == fmap (f . g)    should lessen the cost of operating on Maybe values
15:40:04 <kau> kmc: i would have one further question: the functions that have to deal with the Handle are all already using a StateT GameState IO (). I could modify it to be ReaderT Handle StateT GameState IO (). But layering too must monad transformer is not good, is it?
15:40:49 <aavogt> you need some parentheses in that type kau
15:41:02 <kau> furthermore, this monad transformer layer would oblige me to modify all function's code
15:41:04 <kau> ye
15:41:06 <kau> ss
15:41:29 <dolio> FunctorSalad: I don't know. You'd have to come up with, essentially, a category where objects are sets, but id and composition aren't parametric, and see if you can encode that.
15:41:37 <kau> ReaderT Handle (StateT GameState IO ())
15:41:53 <aavogt> :k ReaderT
15:41:54 <lambdabot> * -> (* -> *) -> * -> *
15:42:03 <aavogt> :k StateT S IO ()
15:42:04 <lambdabot> Not in scope: type constructor or class `S'
15:42:08 <aavogt> :k StateT s IO ()
15:42:09 <lambdabot> Not in scope: type variable `s'
15:42:18 <aavogt> :k StateT Int IO ()
15:42:19 <lambdabot> *
15:42:28 <aavogt> kau: see how the kinds don't match up?
15:42:58 <kau> yeh
15:43:00 <aavogt> the second argument to ReaderT has to be   * -> *
15:43:05 <aavogt> :k StateT Int IO
15:43:06 <lambdabot> * -> *
15:43:58 <kau> in the doc the exemple is ReaderT String IO ()
15:45:09 <aavogt> but you transform a Monad that isn't IO
15:47:15 <FunctorSalad> dolio: I suspect that it is parametric in some GADT-adapted sense on one level, but it seems that one can still do arbitrary type-cases with the gadt
15:47:47 <FunctorSalad> (didn't someone claim that the two don't have to contradict, in fact? maybe it's just this)
15:47:52 <dolio> FunctorSalad: GADTs essentially turn * into a discrete category. Or parts of it, at least.
15:48:01 <dolio> Using the parametricity-as-naturality analogy.
15:48:22 <kau> It's late in europe.
15:48:25 <FunctorSalad> hmm that can't be the full story?
15:48:25 <kau> bye!
15:48:36 <dolio> That's roughly it.
15:48:58 <FunctorSalad> isn't that just like saying "no parametricity at all"? ;)
15:49:13 <FunctorSalad> every transformation is natural for the discrete category
15:49:18 <FunctorSalad> (as domain)
15:49:18 <dolio> It depends what you mean by that.
15:49:50 <FunctorSalad> that the naturality square is tautological if we only plug in identities...
15:49:51 <dolio> When some people talk about parametricity, they're talking about the general theorem.
15:49:58 <FunctorSalad> given that functors map id to id
15:50:09 <FunctorSalad> ok
15:50:22 <dolio> So, like, Bool -> Bool has some result there, which is 'f = f' or something.
15:50:38 <dolio> But that part of the theorem is like saying "there's no parametricity".
15:51:12 <FunctorSalad> (for GADTs?)
15:51:14 <FunctorSalad> ("that part")
15:51:16 <dolio> In the intuitive sense of a parametric function/value being something that ignores an argument in a certain way.
15:51:41 <dolio> Look for the paper Parametricity and Dependent Types.
15:51:46 <FunctorSalad> well, 'treats them all the same way'
15:51:51 <FunctorSalad> ignores the type ;)
15:52:31 <dolio> In a dependent type theory, you can conceivably extend parametricity to dealing with more than types.
15:52:43 <dolio> But, in an ordinary such theory, discrete types are kind of uninteresting.
15:53:08 <dolio> Unless you can enforce somehow that you have to ignore them on some level, in which case you get more interesting free theorems.
15:54:15 <dolio> With */Set, it's kind of the opposite. Ordinarily you can do no inspection, so you get interesting theorems, whereas with GADTs, it's as if you can inspect *, and the theorems become more trivial.
15:54:55 <dolio> Although, I suppose you could argue that they don't exactly, because there's always a corresponding GADT that is causing the theorem to be trivial.
15:55:05 <dolio> Rather than * itself being trivial.
15:55:11 <dolio> Anyhow, I've got to jet.
15:55:18 <dolio> I'll be back in a while.
16:01:12 * BMeph coughs. Oddly, it sounds like "ReaderT Handle (StateT GameState IO) ()"...odd indeed.
16:02:00 <Saizan> your cough sounds like that?
16:03:03 <BMeph> Not always. I think that's the weirdest part of it. Hopefully, the summer will warm up, and it'll just sound like a regular cough again. :)
16:03:50 <cap11235> How do parentheses sound?
16:07:17 <ksf> elparen, arparen
16:07:33 <ksf> you can also use "banana"
16:08:02 <ksf> [] and {} would be brack and brace, respectivly.
16:08:41 <ksf> ...and # is lattice fence. no discussion.
16:10:16 <ksf> more importantly, what's the sound of an unmatched paren?
16:15:46 <BMeph> ksf: ..."Dyck-less"? ;þ
16:17:45 <c_wraith> @pl \x y -> (x * 256) + y
16:17:45 <lambdabot> (+) . (256 *)
16:17:54 <c_wraith> err, yeah, right
16:18:09 <ksf> rpn ftw.
16:18:16 <ksf> or rather pn.
16:47:35 <inetic> hi, I just finished reading the main part about the Zipper patern on wiki books, if I understand it correctly, when working with trees, it's an analogy to holding a pointer to a node of the tree in OO languages, is this correct? if so, could you please redirect me to an analogy where one keeps multiple pointers to nodes?
16:48:09 <ezyang> “multiple fingers” 
16:48:24 <c_wraith> @pl \x y -> (x * 256) + fromIntegral y
16:48:25 <lambdabot> (. fromIntegral) . (+) . (256 *)
16:49:53 <soupdragon> :t (. ?f)
16:49:54 <lambdabot> forall a b (f :: * -> *). (?f::f a, Functor f) => (a -> b) -> f b
16:50:03 <soupdragon> :t (. ?f) . (+)
16:50:05 <lambdabot> forall b (f :: * -> *). (?f::f b, Functor f, Num b) => b -> f b
16:50:13 <soupdragon> what the hell
16:50:49 <inetic> ezyang, were you answering to my question?
16:52:01 <inetic> (the article on wiki books I've read is http://en.wikibooks.org/wiki/Haskell/Zippers , I must say it's very good and funny, enjoyed it a lot, in case the author was here :-) )
16:52:10 <ezyang> Sort of. 
16:52:47 <ezyang> finger trees are generalizations of zippers, and they can have multiple fingers. 
16:52:59 <ezyang> each finger gives constant time access to where it's pointing to. 
16:53:14 <ezyang> Edward Kmett has written extensively about them; I suggest you go take a look :-) 
16:54:08 * ezyang doesn't quite understand finger trees (yet!) 
16:57:15 <Saizan> finger trees are not really used the same way as zippers though, or are they?
17:00:48 <jbapple> Saizan: They can be used as such
17:01:33 <jbapple> Finger trees in a non-functional setting are often more similar to binary search trees, but with pointers to whatever nodes are the fingers
17:01:48 <dolio> I'm not, off the top of my head, convinced that "finger trees are a generalization of zippers" is accurate.
17:02:03 <ezyang> dolio: I just read that off the internet. :-) It seems plausible to me. 
17:02:24 <jbapple> The Hinze & Paterson fingertree in Data.FingerTree doesn't have a pointer to the root node, for instance, while imperative finger trees often do
17:03:03 <jbapple> "zipper" is a very broad concept, but it is more or less the same as a "finger"
17:03:56 <jbapple> With both, you travel to a location, reversing the pointers along the way, giving yourself a trail by which you can return
17:04:47 <jbapple> In H&P fingertrees, the spines are reversed (they head toward the root) while the trees hanging of the spines are usual
17:05:55 <jbapple> Treaps are the same way.
17:06:12 <ddarius> "Finger trees" are, at best, a generalization of a -particular- zipper.  You can make a Zipper on any algebraic data type.
17:06:30 <jbapple> http://www.cs.cmu.edu/afs/cs/project/pscico/pscico/papers/fingertrees/main.pdf
17:07:02 <jbapple> Some finger trees, like some of those by Kaplan & Tarjan use deques for the spines
17:07:34 <jbapple> Making them equivalent to doubly-linked lists
17:07:50 <jbapple> Imperative finger trees tend to be even more complex
17:08:24 <jbapple> They often have a goal of supporting \omega(1) fingers.
17:08:55 <jbapple> dolio: I agree
17:09:05 <inetic> sorry, my connection got broken for a while, as part of learning haskell I'm trying visualize a tree structure I've got (graphically) and I would like to be able to select some of the nodes and manipulate them (like translate and such)
17:09:23 <jbapple> I think a better analogy is that fingers and zippers are close, rather than "finger trees" and zippers
17:12:55 <dolio> jbapple: Given what you've said, it sounds like H&P finger trees are similar to some structure involving two coherent zippers of a 2-3 tree where the zippers are at the far left and far right of the tree.
17:12:57 <jbapple> Also, though Haskell people often say "finger tree" to mean H&P's famous swiss army knife structure, a finger is just a pointer into a data structure, so even regular binary trees have a finger at the root. Some trees have a finger at the root and at a leaf or somewhere in between, and H&P's trees have fingers at the ends
17:13:09 <jbapple> dolio: yup
17:13:24 <jbapple> (IIUC what you mean by "coherent")
17:13:35 <dolio> You probably do.
17:13:37 <ivanm> preflex: seen edwardk
17:13:37 <preflex>  edwardk was last seen on #haskell 4 hours, 54 minutes and 9 seconds ago, saying: c_wraith: well, it basically comes down to the need to grab a lock for every read or write
17:14:42 <ivanm> @tell edwardk had a look at the stuff you do in monoid; it seems to be an explicit way of doing fold-like operations without actually using a fold
17:14:42 <lambdabot> Consider it noted.
17:14:44 <jbapple> So deques are like finger lists
17:15:07 <jbapple> or "2-finger lists"
17:18:49 <ivanm> preflex: seen Baughn 
17:18:49 <preflex>  Baughn was last seen on #haskell-blah 8 days, 7 hours, 52 minutes and 22 seconds ago, saying: http://sites.google.com/site/redcodenl/ <- This scares me. If patent holders are going to start coming after minor software writers, we're in for a rough ride.
17:19:46 <jbapple> Another use of fingers is O(1) imperative decreaseKey in tree-like priority queues like fibonacci heaps (and many others)
17:19:47 <jbapple> From fingers in search trees we get the name for the "finger search property", which a tree has when, given a finger at node A and navigating to an element at node B takes time proportional to the log of the distance between them
17:20:27 <jbapple> That's not too hard to get, but adding or deleting elements at fingers is usually O(lg n) -- it is naively in both RB and AVL trees, though both can be fixed up with some effort
17:22:08 <jbapple> Of course, H&P finger trees allow O(1) amortized modification at fingers. They are a simplification of http://www.math.tau.ac.il/~haimk/papers/loglog23.ps , which offer O(1) worst-case modification at fingers
17:22:26 <ivanm> @ask Baughn do you know if there's a problem with guards in default definitions for class methods?  After using one the indentor keeps throwing a hissy fit whenever I try and indent extra methods after doing so
17:22:27 <lambdabot> Consider it noted.
17:25:07 <inetic> even though I think the debate has diverged quite a bit ( :-) ), I also have quite a bit of keywords I can stuff google with. My internet connection doesn't feel healthy, plus it's getting really late here (2:30 am), so Im going to sleep. In case my ISP has dropped my thanks: thank you again and good night
17:31:05 <EvanR> i have antihaskell propaganda for you. in haskell you must explicitly denote operations which do i/o with the type constructor IO. (function returning IO actions must have the x -> IO y type). kicker: this reduces encapsulation and exposes the inner workings (does it do IO or not) to the client code
17:31:33 <dolio> Heh.
17:31:45 <altmattr> @seen ivanm
17:31:45 <preflex>  ivanm was last seen on #haskell-blah 5 minutes and 26 seconds ago, saying: oh, you were just quoting
17:31:45 <lambdabot> Unknown command, try @list
17:32:04 <mrd> you know what exposes inner workings and reduces encapsulation? side effects
17:32:06 <ivanm> wow, preflex is smart enough to get lambdabot's output now? :o
17:32:10 <ivanm> hey altmattr 
17:32:21 <arw> EvanR: counter-propaganda: doing IO is communication with something outside, which is part of the interface. interfaces don't violate encapsulation.
17:32:32 <ksf> EvanR, collect those things and bait jdh30 with them.
17:32:46 <soupdragon> I have some antihaskell propaganda:  Lazyness makes it impossible to reason about space/time complexity
17:32:55 <EvanR> good one
17:33:09 <dolio> That one's pretty played out, thanks to jdh.
17:33:16 <altmattr> ivan: hi
17:33:37 <ksf> I thought it has been reduced to jdh is incapable of understanding lazyness.
17:33:48 <altmattr> ivanm: on my way in as we speak, just left redfern behind
17:34:02 <ivanm> or just incapable of understanding anything except OCaml and F# (and possibly Mathematica)
17:34:17 <ivanm> but m3ga was telling us yesterday that apparently even the OCaml community hate jdh
17:34:32 <dolio> Mathematica is easy to understand. He rewrote it in a weekend.
17:34:56 <m3ga> and not just for being a bad embassador for ocaml
17:35:10 <EvanR> the reason i bring this one up is that i am thinking about a database. there is no difference, in principle, if my database were a separate program waiting query requests or was a Data.Map hardcoded into the source of my database module, it will still function the same way. (ignore mutating the database, ignore communication failures)
17:35:26 <ksf> ivanm, he's getting dowvoted in fsharp, too.
17:35:34 <ivanm> lol
17:35:34 <ezyang> EvanR: Lazy IO, maybe? 
17:35:44 <ivanm> dolio: oh, right
17:36:23 <ksf> I've never done anything serious with mathematica
17:36:28 <ksf> ...and no programming, at all.
17:36:33 <ksf> only term reduction
17:36:57 <EvanR> but haskell requires one by type IO Result and the other AnyThingIWantOrJust Result
17:37:00 <ksf> (after scribbling terms on three pages of a4 and then noticing an error at the beginning)
17:37:16 <aavogt> EvanR: if it is indistinguishable from some Data.Map that's pretty reasonable grounds for unsafePerformIO
17:37:25 <aavogt> @docs System.IO.Unsafe
17:37:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
17:37:28 <Saizan> EvanR: if you really get to expose a referentially transparent interface there's unsafePerformIO
17:37:35 <EvanR> ah
17:37:57 <EvanR> my propaganda fails
17:38:08 <EvanR> unless you arent telling me the whole truth about unsafePerformIO
17:38:28 <mauke> EvanR: if it could do IO, it should be in IO
17:38:32 <mauke> even if it's just a Data.Map
17:39:07 <mauke> (surprise: I can keep everything in IO and you know shit about my inner workings!)
17:39:16 <EvanR> lol
17:39:26 <EvanR> yes, then you are just using c++
17:39:28 <mauke> I mean, I can practically write C in Haskell, pointer arithmetic and all
17:39:40 <BMeph> Why does no one ever mention that strict/eager evaluation both stops computations that could give an answer, and wastes resources on computations that aren't needed. Laziness is Green! ;þ
17:39:54 <soupdragon> mauke yeah but who's to know if you secretly used some pure functions in there?
17:39:55 <benmachine> mauke: writing C in haskell is much more pleasant :P
17:39:58 <EvanR> so this propaganda fails because every other language is by default might be using IO anyway
17:40:11 <benmachine> what with currying and lambdas and so forth
17:40:12 <ivanm> BMeph: lol
17:40:14 <EvanR> as if i wrote a haskell progrma totally in IO
17:40:25 <aavogt> BMeph: because lazy eval is less efficient if you're going to force everything eventually
17:40:50 <ivanm> @remember BMeph Why does no one ever mention that strict/eager evaluation both stops computations that could give an answer, and wastes resources on computations that aren't needed. Laziness is Green! ;þ
17:40:51 <lambdabot> Good to know.
17:41:08 <dolio> aavogt: That's not necessarily true.
17:41:34 <ivanm> EvanR: main = interact (map toUpper) :p
17:41:36 <aavogt> it is for stuff like Int
17:42:01 <BMeph> aavogt: If you're going to force everything eventually, then are you doing actual computation, or just running a huge spin-lock simulation? ;)
17:42:47 <EvanR> challenge, write a haskell program to compute everything possible to compute
17:42:56 <aavogt> dolio: or is space usage involved (so calculate and collect garbage as you print the results)
17:43:19 <ksf> EvanR, that's easy.
17:43:21 <dolio> That's one way it could be untrue.
17:43:25 <ksf> > [0..]
17:43:26 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:43:30 <EvanR> haha
17:43:31 <ksf> there, all solutions to all problems.
17:43:42 <EvanR> is there a limit to Integer?
17:43:52 <ksf> due to gmp, yes.
17:43:55 <benmachine> not according to the h98 standard :O
17:43:57 <EvanR> epic fail
17:44:05 <ksf> it fails somewhere around maxint^maxint
17:44:23 <dolio> There are also problems that are provably less efficient to solve in a pure, strict language than a pure, lazy language. Not that people regularly use the former.
17:44:33 <benmachine> such a number would require basically all of the ram of any reasonable computer to hold surely
17:44:51 * BMeph is surprised at all of the times that Int and Integer types are used for non-negative values ('length', I'm looking at you!)...
17:44:55 <aristid> > let a = toInteger (maxBound :: Int) in a ^ a
17:45:01 <lambdabot>   mueval: ExitFailure 1
17:45:05 <Saizan> benmachine: memristors!
17:45:07 <EvanR> BMeph: yes that bothers me
17:45:08 <benmachine> BMeph: you think we should use Word?
17:45:18 <benmachine> or [()
17:45:19 <benmachine> ]
17:45:24 <Saizan> Nat
17:45:25 <EvanR> UnboundedWord
17:45:39 <ksf> Nat would be the Int thing, Natural Integer.
17:45:48 <dolio> But 'print [1..2^32]' is likely to complete faster in a lazy language unless you have absurd amounts of memory.
17:45:59 <EvanR> so numbers less than zero are supernatural?
17:46:00 <Saizan> copumpkin started binding the naturals in gmp before going poof
17:46:03 <ksf> ...and as Nats aren't closed under - and *, there needs to be a split in the num class.
17:46:09 <ksf> er under /
17:46:12 <benmachine> EvanR: giggle
17:46:14 <dolio> Simply because an eager language will fill your memory with the list.
17:46:26 <BMeph> benmachine: I think we should break thing, laugh, and use Naturat types! Word too (although I'd prefer the "generic" version to be called Nat, but that's totally opinion-based).
17:46:38 <aristid> ksf: my machine crumbles before maxint^maxint is computed
17:46:40 <Saizan> ksf: / is in Fractional
17:46:52 <ksf> well but -
17:47:16 <Saizan> do subtraction like real men 0 - n = 0
17:47:23 <benmachine> > 32 * maxBound :: Int
17:47:24 <lambdabot>   -32
17:47:24 <benmachine> er
17:47:30 <ksf> I think I rather do induction
17:47:31 <BMeph> I want Gaussians and Eisensteinian Integers, too!
17:47:34 <benmachine> > 32 * toInteger (maxBound :: Int)
17:47:36 <lambdabot>   295147905179352825824
17:47:44 <benmachine> aristid: 2^that
17:47:46 <benmachine> = lots
17:48:02 <aristid> oh, lots:)
17:48:35 <BMeph> If there were a competition for premature optimized language features, I'd nominate (RealFloat f) => Complex f
17:48:56 <aavogt> Int perhaps
17:49:05 <dolio> That's not really even an optimization.
17:49:39 <ksf> the whole num hierarchy works better with associated types, where you can say (/) :: Fractional a => Int -> Int -> a
17:49:47 <soupdragon> Gaussians and Eisensteinian Integers are very interesting
17:49:55 <benmachine> BMeph: I think the RealFloat constraing is to give access to sqrt for abs
17:49:59 <benmachine> *constraint
17:50:06 <soupdragon> I wonder if there are more useful ones (and what are they for?)
17:50:15 <ksf> or rather (/) :: a -> a -> DivTy a
17:50:38 <Saizan> wouldn't be much different with fundeps
17:50:47 <benmachine> ksf: DivTy Integer = ?
17:51:03 <ksf> Rational, I think.
17:51:08 <benmachine> mm, ok
17:51:25 <ksf> er and that should be (/) :; a -> b -> DivTy a b
17:51:31 <benmachine> that sounds like some extra complexity for not a huge deal of gain
17:51:34 <Cale_> I think I prefer just doing an explicit conversion for cases like that
17:51:55 <EvanR> division thank you?
17:51:58 <ksf> the nice thing is that you can say Vector * Scalar = Vector
17:52:11 <ksf> ...and Vector * Vector = Matrix
17:52:14 <Cale_> I actually think that scalar multiplication ought to be different.
17:52:36 <Cale_> With humans it's okay that it looks the same, but computers are not as clever :P
17:52:57 <EvanR> im human and i am not ok
17:53:00 <ksf> I'm quite sure mine can distinguish a scalar and a vector
17:53:22 <aavogt> humans have different notation for direct sums and so on
17:53:27 <ksf> ...or Regex * Regex = Regex.
17:53:30 <EvanR> i dont like millions of uses of *
17:53:34 <ksf> where * is kleene-concatenate.
17:53:57 <BMeph> benmachine: I'm more sure that the Complex class restraints are for doing trig stuff, but sqrt does deserve consideration...
17:54:46 <benmachine> BMeph: it's pretty weird that there's a class constraint on the constructor, anyways
17:55:14 <tolkad> Is there a library for representing lemurs in some sort of data strucutre?
17:55:17 <tolkad> structure*
17:55:23 <soupdragon> lol
17:55:38 <tensorpudding> representing...lemurs?
17:55:40 <ivanm> tolkad: [Lemur]
17:55:41 <EvanR> LemurMap a b
17:55:43 <aavogt> that is a question for @faq maybe
17:55:56 <c_wraith> Hmm.
17:55:57 <ivanm> @faq Can Haskell store lemurs in a data structure?
17:55:58 <lambdabot> The answer is: Yes! Haskell can do that.
17:56:00 <tensorpudding> unboxed lemurs
17:56:03 <ivanm> Hooray!
17:56:10 <c_wraith> Data.ByteString foldr appears to be less lazy than I want.
17:56:11 <EvanR> rofl
17:56:25 <benmachine> c_wraith: lazy bytestring?
17:56:38 <c_wraith> benmachine: I don't want a lazy bytestring.  I want a lazy fold
17:56:51 <c_wraith> In particular, it appears to be forcing the base value
17:56:53 <tolkad> c_wraith: buy it some video games
17:57:05 <c_wraith> I don't understand why foldr would ever force the base value
17:57:20 <benmachine> for efficiency points
17:57:34 <tolkad> http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/Data-ByteString-Lazy.html
17:57:41 <c_wraith> tolkad: irrelevant
17:58:04 <c_wraith> I don't care if the fold over the bytestring is lazy or not.  I just want it to not force the base value
17:58:30 <aavogt> c_wraith: isn't it cheap to convert to a lazy bytestring (one that has a single chunk), so maybe if the foldr for the other one is more lazy...
17:58:46 <benmachine> c_wraith: seems the bytestring functions are all stricted
17:58:51 <c_wraith> aavogt, I guess that is worth checking out
17:59:03 <aavogt> the other option is to start with a Nothing
17:59:04 <benmachine> c_wraith: you could put it in an identity monad :P
17:59:16 <benmachine> well, identity constructor anyway
17:59:36 <tolkad> @faq can haskell delete my system files when I use the foldl function?
17:59:37 <lambdabot> The answer is: Yes! Haskell can do that.
17:59:43 <benmachine> uhm
17:59:53 <benmachine> insofar as I can tell, foldr == foldr'
17:59:56 <benmachine> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.7/doc/html/src/Data-ByteString.html#foldr
18:00:22 <c_wraith> Doesn't appear that .Lazy doesn't force the base value either.
18:00:24 <c_wraith> ick.
18:00:28 <tolkad> c_wraith: you could make your own fold function
18:00:34 <tolkad> c_wraith: and use it instead
18:00:49 <tolkad> c_wraith: maybe import and overwrite the Data.ByteString one
18:00:51 <aavogt> bytestring is abstract
18:01:14 <tolkad> what does that mean? I didn't know haskell had abstract classes
18:01:14 <benmachine> isn't that what Data.ByteString.Internal is for?
18:01:20 <benmachine> it has abstract data types
18:01:27 <aavogt> benmachine: so it is exported somewhere?
18:01:28 <c_wraith> Eh.  I can just use list foldr with unpack.
18:01:29 <benmachine> ADTs where constructors aren't expoerted
18:01:33 <jbapple> kmc, monochrom: your continuation suggestions solved my problems. Three cheers for you!
18:01:37 <c_wraith> That will serve my purposes well enough, I guess
18:02:00 <tolkad> c_wraith: yeah, I always use unpack
18:02:09 <tolkad> especially after a vacation
18:02:31 <tolkad> have I been helpful?
18:02:35 <c_wraith> yes! :)
18:03:09 <c_wraith> I do still wish the base was forced in B.foldr, but I guess I can survive this way.
18:03:18 <c_wraith> err, *wasn't*
18:05:35 <c_wraith> still annoys me.  Oh well.  fusion gets the case of fold/build, right?
18:05:35 <tolkad> http://en.wikipedia.org/wiki/Haskell_class_attack_transport
18:05:52 <tolkad> interesting vulnerability in ghc
18:06:02 <tolkad> surprised it hasn't been fixed yet
18:06:12 <BMeph> @faq Can Haskell enable me to mail unsuspecting persons packages containing rabid badgers?
18:06:12 <lambdabot> The answer is: Yes! Haskell can do that.
18:06:30 <soupdragon> tolkad ahahaha
18:06:33 <soupdragon> "The Haskells were very active in the World War II Pacific Theater of Operations, landing Marines and Army troops and transporting casualties at Iwo Jima and Okinawa. Ships of the class were among the first Allied ships to enter Tokyo Bay at the end of World War II, landing the first occupation troops at Yokosuka. After the end of World War II, most participated in "Operation Magic Carpet", the massive sealift of US personnel back to the United State
18:06:33 <soupdragon> few of the Haskell-class were reactivated for the Korean conflict, with some staying in service into the Vietnam War."
18:08:05 <tolkad> how do you make class aliases?
18:08:23 <tolkad> oh, wait nvm
18:08:32 <tolkad> can I do
18:08:52 <ksf> you can with undecidable instances, but ghc won't unify them.
18:08:59 <tolkad> class (* a) => Something a
18:09:01 <tolkad> oh
18:09:04 <Cale> tolkad: The first step is to wait for class aliases to be implemented in GHC
18:09:05 <ksf> they're more or less slated for inclusion.
18:09:32 <ksf> class (Foo a, Bar a) => Baz a; instance (Foo a, Bar a) => Baz a
18:09:48 <ksf> which simplifies your type sigs, but not the errors
18:13:07 <ivanm> dons: you around?
18:13:44 * hackagebot TernaryTrees 0.2.0.0 - Efficient pure ternary tree Sets and Maps  http://hackage.haskell.org/package/TernaryTrees-0.2.0.0 (AlexMason)
18:14:18 <EvanR> what the hell is ternary, why not trinary?
18:14:23 <EvanCarroll> how do i get a type of Double to Int? Or to something that can go into Int when called
18:14:43 <EvanR> fromIntegral
18:14:47 <dibblego_> is there a means of deprecating a hackage package?
18:15:48 <ivanm> dibblego_: ask Ross Patterson, I think
18:16:19 <ivanm> though by "deprecate", it just gets hidden from the main package listing
18:16:26 <ivanm> e.g. packedstring
18:16:38 <ivanm> EvanR: round, trunc, ceil, floor
18:16:40 <ivanm> take your pick
18:17:00 <dibblego_> ok ta
18:17:01 <EvanR> ah
18:17:16 <EvanR> :t floor
18:17:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:18:32 <BMeph> Ternary: Having to do with sea birds! ;þ
18:19:06 <shachaf> Is there a standard way of turning "abcdef" into ["abc","def"]?
18:19:15 <shachaf> (No constant functions please.)
18:19:33 <kmc> > splitAt 3 "abcdef"
18:19:34 <lambdabot>   ("abc","def")
18:19:45 <shachaf> kmc: I mean a list.
18:19:48 <kmc> i know
18:19:59 <shachaf> "abcdefghij" into ["abc","def","ghi","j"]
18:20:03 <geheimdienst> > take 3 "abcdef"
18:20:04 <lambdabot>   "abc"
18:20:09 <EvanR> shachaf: chunk
18:20:12 <shachaf> You could unfoldr with splitAt, I suppose.
18:20:13 <kmc> :t chunk
18:20:14 <lambdabot> Not in scope: `chunk'
18:20:14 <geheimdienst> @hoogle chunk
18:20:15 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
18:20:15 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
18:20:15 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
18:20:22 <msieradzki> does cabal-install use more than 1 process and if not why?
18:20:26 <EvanR> something like that
18:20:32 <msieradzki> (compilation)
18:20:55 <dibblego_> > Data.List.Split.splitEvery 3 "abcdefghi"
18:20:56 <lambdabot>   Not in scope: `Data.List.Split.splitEvery'
18:21:24 <shachaf> > map (map snd) . groupBy ((<) `on` fst) . zip (cycle [0,1,2]) $ "abcdefghij" -- is another way.
18:21:24 <lambdabot>   ["abc","def","ghi","j"]
18:22:04 <shachaf> Ah, Data.List.Split.
18:24:11 <EvanCarroll> EvanR: how do  iuse fromIntegral with f, let f = foldr (+) 0 $ map (**2) [1..]
18:24:26 <EvanCarroll> EvanR: Can i compose the fromIntegral part on the **2
18:26:17 <ivanm> msieradzki: because ghc --make doesn't use more than one process
18:26:22 <ivanm> (didn't I answer this yesterday?)
18:26:32 <msieradzki> I asked this but I didn't get answer
18:26:35 <msieradzki> or didn't notice then
18:26:42 <ivanm> well, I did answer... ;-)
18:26:49 <ivanm> msieradzki: Cabal (and thus also cabal-install) just calls "ghc --make" for the actual building
18:27:02 <ivanm> and since ghc --make currently can't do stuff in parallel, neither can Cabal
18:27:29 <ivanm> building package dependencies in parallel is another issue entirely; my guess there is that it will make it harder to read error messages, etc. if you try to build more than one package at a time
18:30:59 <adnap> Is there a function in the Haskell library that takes [1,2,3] and [4,5,6] and produces [1,4,2,5,3,6]?
18:31:12 <EvanR> EvanCarroll: i gave you the wrong function because you want to convert a double to an integer
18:31:22 <EvanR> not the other way around
18:31:25 <EvanR> you want floor or something
18:31:33 <EvanCarroll> there we go
18:31:36 <EvanCarroll> that sounds more right.
18:31:36 <EvanR> and yes you can compose them
18:32:09 <EvanR> :t floor . (**2)
18:32:10 <lambdabot> forall b a. (RealFrac a, Integral b, Floating a) => a -> b
18:32:53 <EvanCarroll> how come this doens't work ? let f = foldr (+) 0 $ map floor.(**2) [1..]
18:32:57 <davekong> > [1,2,3] ++ [4,5,6]
18:32:57 <lambdabot>   [1,2,3,4,5,6]
18:33:09 <EvanR> EvanCarroll: try parens around the x.y
18:33:20 <EvanR> and a space on both sides of the .
18:33:32 <EvanCarroll> nifty!
18:33:34 <EvanCarroll> didn't need spaces
18:33:39 <aavogt> > transpose [[1,2,3] , [4,5,6]]
18:33:40 <lambdabot>   [[1,4],[2,5],[3,6]]
18:33:42 <Botje> > (foldr (.) id $ zipWith (\a b -> a:b:) [1,2,3] [4,5,6]) []
18:33:43 <Zao> (map floor) . (**2) [1..]  -- not quite sanely typed
18:33:43 <lambdabot>   <no location info>: parse error on input `)'
18:33:47 <EvanR> > transpose []
18:33:48 <lambdabot>   []
18:33:50 <aavogt> > concat $ transpose [[1,2,3] , [4,5,6]]
18:33:51 <lambdabot>   [1,4,2,5,3,6]
18:34:39 <BMeph> > let chunk n = takeWhile (not . null) . map (take n) . iterate (drop n) in chunk 3 "abcdefghij"
18:34:40 <lambdabot>   ["abc","def","ghi","j"]
18:34:44 <EvanCarroll> EvanR: I'm still not getting this  take 50 $ foldr (+) 0 $ map (floor.(**2)) [1..]
18:34:57 <EvanCarroll> oh wait
18:34:58 <EvanCarroll> nvm
18:34:59 <Botje> > (foldr (.) id $ zipWith (\a b x -> a:b:x) [1..3] [4..6] ) []
18:34:59 <EvanCarroll> =(
18:35:00 <lambdabot>   [1,4,2,5,3,6]
18:35:14 <davekong> trying to find the most convoluted way to do it?
18:36:15 <adnap> aavogt: Thanks
18:36:25 <EvanR> EvanCarroll: how about take 50 . foldr (+) 0 . map (floor . (**2)) $ [1..]
18:37:00 <EvanR> do it in smaller steps first
18:37:20 <davekong> > concat [[1,2,3],[4,5,6]]
18:37:20 <lambdabot>   [1,2,3,4,5,6]
18:37:39 <davekong> what is transpose for?
18:37:53 <EvanR> to flip data around
18:38:00 <davekong> I mean why use it here
18:38:06 <EvanR> where
18:39:09 <davekong> nm... maybe that is what he wants
18:39:56 <aavogt> the order is different
18:40:04 <EvanCarroll> EvanR: the problem was the take 50 came after the foldr, it should be in erverse order
18:40:14 <EvanCarroll> EvanR: foldr . take 50 $ map..
18:40:19 <BMeph> > foldr (+) 0 . map (floor . (**2)) . take 50 $ [1..]
18:40:20 <lambdabot>   42925
18:40:32 <EvanR> EvanCarroll: ah. right, foldr takes a list and makes one value, take takes a list and produces a list
18:40:53 <chessguy> > sum . map (floor . (**2)) . take 50 $ [1..]
18:40:54 <EvanR> legos werent matching up ;)
18:40:54 <lambdabot>   42925
18:40:55 <EvanCarroll> no it takes a list and a produces a value which might itself be a list.
18:41:02 <EvanCarroll> in this case it isn't
18:41:23 <EvanR> EvanCarroll: well if you are talking about lists of lists, ok but i left that to the generality
18:41:41 <EvanR> (+) leads us to the simpler case of numbers
18:42:11 <chessguy> @type sum
18:42:12 <lambdabot> forall a. (Num a) => [a] -> a
18:42:26 <chessguy> @type foldr (+) 0
18:42:27 <lambdabot> forall a. (Num a) => [a] -> a
18:46:12 <kniu> @hoogle Int -> PortI
18:46:13 <lambdabot> Warning: Unknown type PortI
18:46:14 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:46:14 <lambdabot> Data.List (!!) :: [a] -> Int -> a
18:46:15 <kniu> @hoogle Int -> PortId
18:46:16 <lambdabot> Did you mean: Int -> PortID /count=20
18:46:16 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:46:16 <lambdabot> Data.List (!!) :: [a] -> Int -> a
18:47:32 <EvanCarroll> man for the life of me i can't do shit in haskell
18:49:53 <soupdragon> such as
18:50:59 <EvanCarroll> I tink my problem stems from using ** instead of ^
18:51:33 <EvanCarroll> but for the purpose of figuring it out, tihs compiles let f x = sum [ e**2 | e<-x, even e ]
18:51:42 <EvanCarroll> how do I call it though with a series 
18:51:45 <EvanCarroll> f [1..100] dies
18:52:31 <aavogt> @type even
18:52:32 <lambdabot> forall a. (Integral a) => a -> Bool
18:52:43 <soupdragon> @let let f x = sum [ e**2 | e<-x, even e ]
18:52:44 <lambdabot>   Parse error: KW_Let
18:52:47 <soupdragon> @let f'' x = sum [ e**2 | e<-x, even e ]
18:52:49 <lambdabot>  Defined.
18:52:51 <soupdragon> > f'' [1..5]
18:52:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:52:52 <lambdabot>    `GHC.Real.Integral a'
18:52:52 <lambdabot>   ...
18:53:01 <soupdragon> > let f'' x = sum [ e^2 | e<-x, even e ] in f'' [1..5]
18:53:02 <lambdabot>   20
18:53:07 <soupdragon> I don't see a problem
18:53:20 <soupdragon> I woul dhave write  sum . map (^2) . filter even
18:53:22 <soupdragon> but it doesn't amtte
18:53:22 <aavogt> the problem is that ** and even use different typeclasses
18:53:39 <EvanCarroll> soupdragon: how do you make it work **
18:54:13 <ps-auxw> You need a number of a type that is both Integral and Floating. Such a type doesn't really exist, though.
18:54:13 <EvanCarroll> aavogt: so how do you make f work for that? through some from$function or to$function, or is there something that can make it work?
18:54:25 <EvanCarroll> and how would I know what the problem is from the error message
18:54:35 <EvanCarroll> what gave it away for you, because it wasn't obvious to me
18:55:05 <aavogt> @type \x -> even (round x)
18:55:07 <lambdabot> forall a. (RealFrac a) => a -> Bool
18:55:14 <aavogt> @type \x -> even (truncate x)
18:55:14 <lambdabot> forall a. (RealFrac a) => a -> Bool
18:55:37 <ps-auxw> @type \x -> sum [ e**2 | e<-x, even e ]
18:55:38 <lambdabot> forall t. (Integral t, Floating t) => [t] -> t
18:55:42 <aavogt> this is probably the reason why even doesn't work for non-integral numbers
18:55:55 <EvanCarroll> you know what would be really useful, a quiz or something interactive where you build your skills reading ghc debug messages ;)
18:55:59 <aavogt> and there aren't any types that manage both instances
18:56:33 <aavogt> > (\x -> sum [ e**2 | e <- x, even (round e) ]) [1..5]
18:56:34 <lambdabot>   20.0
18:57:24 <hiptobecubic> > round 3
18:57:25 <lambdabot>   3
18:57:28 <hiptobecubic> > round 3.5
18:57:29 <lambdabot>   4
18:57:59 <EvanCarroll> why isn't ** polymorphic to work on its arguments type? 
18:58:09 <EvanCarroll> why not just rewrite ** and ^ to work on all (Num a)
18:58:16 <aavogt> so rather than doing some arbitrary rounding, `even' just doesn't work on numbers with fractional parts
18:58:26 <aavogt> EvanCarroll: it's an arbitrary choice
18:58:32 <EvanCarroll> fair enough
18:58:47 <EvanCarroll> that kind of stuff makes the language much harder and frustrating
18:58:48 <ddarius> They are different functions.
18:59:00 <aavogt> as you see there would be this confusing situation if you allowed even to work for other types
18:59:04 <ddarius> I think they made the right choice with respect to the exponentiation operators.
18:59:16 <EvanCarroll> ddarius: why?
18:59:43 <EvanCarroll> + works on `Num a` why should exponetatnion be different?
19:00:09 <ddarius> As I said, each is a different function, which is also reflected in the types.
19:01:26 <g_cross> EvanCarroll:  (^) computes the exponential by repeated multiplication, whereas (**) computes the exponential by using e^x
19:01:39 <ddarius> x ** y, for example, is exp(y * log x), which is the usual mathematical definition but doesn't even make sense for types that aren't (approximations) of reals.
19:02:03 <soupdragon> "Simulating the motion of a 1,500-atom molecule, a small protein, for a time interval of 10^-10 seconds i s a six hour computation on a Cray X-MP."
19:02:17 <g_cross> EvanCarroll:  For small integers (^) is faster since it is just multiplication, but (**) has the advantage that it can work for an arbitrary real.  (The implementation uses something like a power series under the hood, similar to sin and cos.)
19:02:50 <ddarius> (or rather "continuous" to be more general)
19:02:59 <ddarius> :t (^)
19:03:01 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
19:03:01 <ddarius> :t (^^)
19:03:02 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
19:03:04 <ddarius> :t (**)
19:03:05 <lambdabot> forall a. (Floating a) => a -> a -> a
19:03:23 <JoeyA> In this type signature, (why) is the forall needed here?  build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
19:03:27 <EvanCarroll> there is a ^^ too 
19:03:36 <g_cross> Cool, I didn't realize that.
19:03:38 <EvanCarroll> =(
19:03:59 <kniu> guys
19:04:06 <kniu> how do I make a Network.PortNumber?
19:04:12 <ddarius> JoeyA: Yes it is, to answer one question.
19:04:15 <ddarius> kniu: fromIntegral
19:04:16 <kniu> I don't see any constructors
19:04:18 <kniu> oh
19:04:22 <soupdragon> JoeyA, are you read the build/fusion paper?
19:04:26 <JoeyA> Yes
19:04:29 <ddarius> kniu: Which, if you are using a literal constant, you don't even need to do that.
19:04:39 <JoeyA> well, I'm reading "Rewriting Haskell Strings"
19:04:42 <soupdragon> um I think they go into a lot of detail about why its needed in that
19:04:44 <soupdragon> oh I see
19:04:50 <soupdragon> yes you are reading the wrong one wait a sec
19:04:50 <JoeyA> mainly about ByteString
19:05:30 <JoeyA> I'm mainly trying to understand what forall here does at all, not how it applies to short cut fusion.
19:05:43 <soupdragon> http://research.microsoft.com/en-us/um/people/simonpj/papers/deforestation-short-cut.ps.Z
19:05:50 <soupdragon> JoeyZ, this paper describes how it all works
19:06:03 <soupdragon> but it takes a little bit of explanation before you get to that forall
19:06:31 <Saizan> JoeyA: it forces the argument of build to be polymorphic in 'b'
19:06:46 <ddarius> JoeyA: Look up encoding algebraic data types into System F.
19:06:59 <ddarius> @google typed church encoding
19:07:00 <lambdabot> http://en.wikipedia.org/wiki/Church_encoding
19:07:00 <lambdabot> Title: Church encoding - Wikipedia, the free encyclopedia
19:10:39 <keseldude> what is ((,) e)?
19:11:47 <ddarius> Arguably (^) could be moved into the Num class and (^) and (^^) could be combined.
19:11:55 <JoeyA> It's a function that converts something into a pair with e as the 2nd argument.
19:12:03 <JoeyA> > let e = "pie"
19:12:05 <lambdabot>   not an expression: `let e = "pie"'
19:12:12 <aavogt> first argument
19:12:17 <aavogt> it could be a type too
19:12:20 <JoeyA> oops
19:12:21 <ddarius> keseldude: It's simply a partial application of the (,) function which is just the constructor for pairs.
19:12:29 <JoeyA> > ((,) "pie") "pizza"
19:12:30 <lambdabot>   ("pie","pizza")
19:12:31 <keseldude> oh okay, so it's exactly what it looks like
19:12:48 <keseldude> the mention in the typeclassopedia confused me a little
19:12:49 <dolio> > (,"pie") pizza
19:12:49 <keseldude> thank you
19:12:50 <lambdabot>   <no location info>: parse error on input `"'
19:13:01 <keseldude> > (,) "hello" 3
19:13:02 <lambdabot>   ("hello",3)
19:13:23 <ddarius> > undefined :: (,) Int Bool
19:13:24 <lambdabot>   *Exception: Prelude.undefined
19:13:28 <ddarius> :t undefined :: (,) Int Bool
19:13:29 <lambdabot> (Int, Bool)
19:13:57 <aavogt> show could be lazier, but maybe it's that way for debugging purposes
19:14:33 <ddarius> aavogt: Nah, it's probably just defined as show (x,y) = ... instead of show ~(x,y) = ...
19:14:39 <ddarius> For no particular reason.
19:16:04 <ddarius>     showsPrec p (x,y) = showChar '(' . shows x . showChar ',' .
19:17:04 <aavogt> hmm, `.' for appending ShowS
19:17:16 <ddarius> That was the idea.
19:18:07 <ivanm> hi Cale 
19:18:11 <Cale> hi
19:18:20 <aavogt> whether that's the same as other languages may be a coincidence?
19:18:31 <soupdragon> hi Cle !
19:18:32 <soupdragon> Cale
19:18:39 <ddarius> aavogt: What other language uses that notation?
19:20:31 <JoeyA> :t id
19:20:31 <lambdabot> forall a. a -> a
19:20:36 <JoeyA> :t const
19:20:37 <lambdabot> forall a b. a -> b -> a
19:21:18 <ivanm> :t const id
19:21:19 <lambdabot> forall a b. b -> a -> a
19:21:29 <aavogt> ddarius: perl, MuPad
19:22:05 <JoeyA> I'm still trying to grasp build :: (forall b. (a -> b -> b) -> b -> b) -> [a] .  Why not forall a as well?
19:22:15 <soupdragon> JoeyA, didn't like the paper I sheowde you?
19:22:22 <ddarius> JoeyA: There is an implicit forall a at the outside.
19:23:21 <kniu> so I got a handle,
19:23:28 <kniu> how do I make a HandleStream out of it?
19:23:31 <JoeyA> It looks like forall b. touches all the b's.  I guess leaving [a] out of the forall b. world means something?
19:23:38 <soupdragon> JoeyA, ummm hello?
19:23:41 <kniu> @hoogle Handle -> HandleStream String
19:23:42 <lambdabot> Prelude show :: Show a => a -> String
19:23:42 <lambdabot> Text.Show show :: Show a => a -> String
19:23:42 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
19:23:58 <kniu> @hoogle Handle -> IO (HandleStream String)
19:23:58 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:23:58 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:23:59 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
19:24:03 <gwern> ddarius: if the a can be implicit, why not the b?
19:24:05 <kniu> well dang.
19:24:26 <ddarius> gwern: Because then it would have a different scope.
19:24:34 <gwern> ?
19:24:56 <soupdragon> @free g :: forall b. (A -> b -> b) -> b -> b
19:24:57 <lambdabot> (forall x. f . h x = k x . f) => f . g h = g k . f
19:24:57 <gwern> you mean the result could then be something like [(a,b)]?
19:25:02 <gwern> and that's bad?
19:25:09 * soupdragon sighs..... wonders why everyone is ignoring me today
19:25:21 <gwern> ([(a,b)] as opposed to [b] I mean)
19:25:29 <gwern> er, [a]
19:25:29 <ddarius> gwern: No, it would mean that the whole function is parameterized by b rather than it is a function that takes a function parameterized by b.
19:25:35 <JoeyA> soupdragon: I found the counterexample in the paper; reading
19:27:39 <ddarius> gwern, JoeyA : It's just like logic (it actually -is- logic).  "If everyone has a dog, then Tim has a dog" means something different from "For every person, if that person has a dog, then Tim has a dog."
19:28:08 <ddarius> The first is (forall p. p has a dog) -> Tim has a dog, the latter is forall p. p has a dog -> Tim has a dog.
19:28:55 <monochrom> "for some person, if that person drinks, then Tim drinks"
19:29:14 <gwern> so, 'for all pairs of as and bs such that there is a function taking a and b and yielding  b, then there can be made an [a] suchly'?
19:30:08 <edwardk> preflex: xseen jaffacake
19:30:08 <preflex>  jaffacake was last seen on freenode/#ghc 10 hours, 44 minutes and 40 seconds ago, saying: yes (but there was a bit more to it than that, IIRC)
19:30:09 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
19:30:29 <ddarius> gwern: The type of build explicitly is: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
19:30:30 <edwardk> preflex: xseen ivanm
19:30:30 <preflex>  ivanm was last seen on freenode/#haskell-blah 7 minutes and 48 seconds ago, saying: looks like BMeph didn't want to lurk for too long...
19:30:53 <ivanm> edwardk: voila!
19:31:35 <ddarius> gwern: It sounds like you are trying to say (forall a b. (a -> b -> b) -> b -> b) -> [a] which isn't even well scoped, or maybe you meant: forall a b. ((a -> b -> b) -> b -> b) -> a which is what this is not (and what you'd get if you left b implicitly quantified.
19:31:47 <gwern> hmmm
19:31:57 <edwardk> ivanm: re monoids, yeah, the generators are all about folding in that same monomorphic way your class supports, I just separated the generation or monoidal results from the ability to construct a structure piecemeal.
19:32:04 <ivanm> *nod*
19:32:06 <edwardk> er generation of
19:32:30 * ivanm is also generalising the Integral type of take, length, etc. to make copumpkin happy
19:32:32 <edwardk> turns out that doing things monoidally gives you a lot of opportunities for parallelism and 'incrementalizing' computation
19:32:48 <ivanm> hmmm.....
19:32:53 <edwardk> ivanm: please if you do so, make those 'genericLength' etc.
19:33:09 <edwardk> otherwise the performance concerns will definitely keep me from ever being able to use your class =/
19:33:20 <ivanm> awwwwww......
19:33:48 <ivanm> would then having "length = genericLength" be sufficient?
19:34:01 <edwardk> ivanm: as a default definition? sure
19:34:24 <ivanm> so both length and genericLength should be class methods?
19:34:25 <edwardk> but it should be in the class
19:34:26 <edwardk> yeah
19:34:27 <ddarius> Word needs to be put in the Prelude.
19:34:31 <ivanm> hmmm.....
19:34:34 <edwardk> ddarius: yeah
19:34:54 <ivanm> I agree that something like it should be in the prelude, but I've never liked the name "Word"
19:34:55 * ddarius is just not a beer person.
19:35:08 <ivanm> ddarius: huh?
19:35:10 <ddarius> UInt?
19:35:12 <edwardk> ivanm: there exist Int valued length implementations for almost every container known to man, it seems silly to throw away that efficiency in the name of generality that ISN'T supported universally
19:35:19 <ivanm> edwardk: true
19:35:31 <ivanm> I didn't think that using generic versions would affect performance
19:35:57 <ivanm> I was going to try providing a default foldl defintion in terms of foldr, but then realised that that was just stupid
19:36:30 <edwardk> it can make a rather insane difference, especially when going through a dictionary like this because you've further limited the ability to inline, so its quite a heroic feat for ghc to see enough with -fspec-constr, etc to make the Integer overhead go away
19:36:39 <edwardk> but it is just a simple worker-wrapper transform for it to make Int go away
19:36:43 <ivanm> why is it that generic versions of length, etc. have a performance hint (even if you use Int) than the specialised Int versions?
19:37:00 <ivanm> oh, right
19:37:04 <ivanm> all the fromIntegral stuff?
19:37:28 <soupdragon> edwardk, I can't differentiate stuff like  V(q) = if q < 0 then infinity else 0  with RAD/AD (just to make sure)
19:37:29 <soupdragon> ?
19:37:40 <edwardk> that and consider that just tossing around an Integer has to deal with both S# and I# constructors, so its no longer sufficient to just work with Int#'s in the transformed worker.
19:38:04 <edwardk> soupdragon: sure you can. it'll just say the derivative is 0
19:38:28 * soupdragon is trying to figure out how to implemetn thsi numerically
19:38:31 <edwardk> soupdragon: everywhere the derivative exists you'll get an answer.
19:39:01 <edwardk> everywhere it doesn't exist, you may get nonsense., so at your discontinuity at 0, you'll still get 0
19:39:06 <ivanm> is lambdabot's @src plugin available as a standalone (same as @pl is)?
19:39:27 <soupdragon> what's baffling me is these people use infinity in their equations.. and seem to differentiate it and stuff
19:39:31 <soupdragon> which is not something I have any idea how to do
19:39:39 <edwardk> soupdragon: who are these people?
19:40:03 <soupdragon> well I saw it on wikipedia for the hamiltonian of billiards, but it's used in computational chemistry too (hard sphere)
19:40:21 <soupdragon> I tried to program it using 999999 instead of infinity .. that doesn't work
19:43:35 <EvanCarroll> seriously I'm not sure what book has worse example problemms the thompson book or rwh
19:44:02 <soupdragon> well read LYAH instead
19:44:25 <EvanCarroll> one of them has silly puzzles that require wikipedia, the other one has questions that spur 20 messages by experienced haskell programmers not understanding the subject matter.
19:44:45 <ddarius> ivanm: @src basically consults a hand-built database.
19:44:48 <jbapple> Is there any way to get two STArrays out of ST without using unsafe*?
19:44:51 <jbapple> get2STArrays :: (forall s . ST s (STArray s a b,STArray s c d)) -> (Array a b, Array c d)
19:45:04 <EvanCarroll> soupdragon: I've read LYAH
19:45:06 <ivanm> ddarius: yeah, I know that; just wondering if the database was available as a standalone
19:45:15 <jbapple> runSTArray works for one at a time
19:45:26 <EvanCarroll> soupdragon: it was a good enjoyable introduction, but I still don't know enough to get even the most minimal task done with haskell.
19:45:29 <ivanm> I've already got :hoogle and :pl working in ghci; having :src would remove my main other reason for using lambdabot whilst hacking ;-)
19:45:33 <EvanCarroll> so I'll file it under partial fail.
19:45:39 <soupdragon> what is the most minimal task?
19:45:41 <ddarius> ivanm: It should be in the state directory of lambdabot as as gzipped text file (with no extension specifying that(
19:45:49 <ivanm> heh
19:45:55 <EvanCarroll> the other books aren't working with me at all, so I file them under total fail ;( LYAH wins.
19:46:00 <ivanm> probably too much effor to do that ;-)
19:46:05 <jbapple> If I runSTArray the first, then the second, will I be running the computation that is encapsulated in the outer ST twice?
19:46:07 <ddarius> ivanm: Do what?
19:46:15 <EvanCarroll> soupdragon: figuring out why ** doesn't work with even, reading ghc error messages. etc.
19:46:26 <ivanm> ddarius: get the file, put it somewhere, and write a wrapper script to look it up for me ;-)
19:46:30 <soupdragon> no be precise
19:46:38 <soupdragon> you still dont know why ** doesn't work?
19:46:42 <ivanm> EvanCarroll: which other books have you tried?
19:46:48 <EvanCarroll> No, now I undersetand that.. 
19:46:51 <EvanCarroll> but only because I was told.
19:46:53 <ivanm> have you tried _real_ books as opposed to online tutorials?
19:46:59 <ddarius> ivanm: http://code.haskell.org/lambdabot/State/source
19:47:03 <soupdragon> so what are you stuck on now/
19:47:03 <soupdragon> ?
19:47:06 <EvanCarroll> ivanm: I've tried RWH, and I'm reading the thompson book now
19:47:17 <ivanm> thompson book is good, if outdated
19:47:23 <EvanCarroll> soupdragon: how do you write last using foldr,
19:47:53 <ivanm> ddarius: yeah, I'd still need to bother writing something to look that up for me ;-)
19:48:25 <soupdragon> EvanCarroll, okay foldr is quite difficult at first - but that's because there is a tremendous amount packed into it
19:48:27 <soupdragon> EvanCarroll, I mean it is one o fthe most fundamental things in functional programming
19:48:48 <soupdragon> EvanCarroll, anyway I can tell you some advice to solve this (and it will apply in general, for harder problems)
19:49:08 <soupdragon> the first thing is this, 
19:49:08 <EvanCarroll> I've gotten a ton of advice on stackoverflow
19:49:10 <soupdragon> :t last
19:49:11 <lambdabot> forall a. [a] -> a
19:49:18 <soupdragon> :t foldr ?f ?z :: [a] -> a
19:49:20 <lambdabot>     Could not deduce (?f::a -> a -> a) from the context ()
19:49:20 <lambdabot>       arising from a use of implicit parameter `?f'
19:49:20 <lambdabot>                    at <interactive>:1:6-7
19:49:26 <soupdragon> hm I have a mistake 
19:49:59 <EvanCarroll> what is ?f
19:50:02 <EvanCarroll> what is forall
19:50:11 <soupdragon> well let me figure out the mistake I have made first
19:50:21 <EvanCarroll> this is the problem with haskell.
19:50:31 <EvanCarroll> see, not unique to me!
19:50:34 <ddarius> soupdragon: Your type is too specific.
19:50:42 <EvanCarroll> writing 10 lines without a compiler error is too difficult to be practical.
19:50:50 <ddarius> soupdragon: You simply gave the wrong type.
19:51:01 <JoeyA> EvanCarroll: It'll pass, trust me :-)
19:51:08 <ddarius> EvanCarroll: Then stick to Perl and you won't have that problem.
19:51:19 <EvanCarroll> ddarius: or, C#
19:51:46 <EvanCarroll> or pretty much any language other than Haskell. If it wasn't for the mystical lazy quality and type inference I would.
19:51:49 <ivanm> EvanCarroll: implicit variables methinks
19:51:56 <ddarius> EvanCarroll: C# is typed and gives compiler errors aplenty.  Furthermore, C# is adopting more and more from Haskell.  Not a safe place for you to stay.  Perl is better.
19:51:58 <EvanCarroll> Or, if perl wasn't so bloody behind the times internally.
19:52:20 <EvanCarroll> C# is generally speaking much more user-friendly. and I've only uesd mono
19:52:38 <soupdragon> EvanCarroll: so I figured out my mistake, want to hear my hint now?
19:52:41 <adnap> I'm trying to generate indices for a triangle strip following the order specified here: http://dan.lecocq.us/wordpress/wp-content/uploads/2009/12/strip.png  Here is my implementation: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27647  I was wondering if anyone could improve upon it.
19:52:47 <EvanCarroll> soupdragon: oh yea, continue.
19:53:54 <soupdragon> EvanCarroll, so we want to write a function last :: [a] -> a in terms of foldr, so  last = foldr <something> <something> ... the first thign we can do is ask the compiler what types are for <somethign> and <something> -- then that will guide us
19:54:10 <soupdragon> EvanCarroll, so I always write it into a .hs file like this: http://pastie.org/1048203.txt
19:54:20 <soupdragon> then you cah load it and check
19:54:21 <soupdragon> *Main> :t f
19:54:21 <soupdragon> f :: a -> a -> a
19:54:21 <soupdragon> *Main> :t z
19:54:22 <soupdragon> z :: a
19:54:33 <soupdragon> (I tried to get lambdabot to do this rather than going through a haskell file, but appraently don't know how to )
19:54:59 <soupdragon> now at this point there are two obvious functions of type a -> a -> a to  try: What are they?
19:55:33 <soupdragon> now if you just try them both, you find that one works.. that's lucky - but usally it's not so easy..... that's when you have to think a bit harder
19:55:45 <soupdragon> (we leave z as undefined, because last is partial)
19:56:57 <soupdragon> EvanCarroll, fun puzzle to try is,  write  length  in terms of foldr, and also write  sum in terms of foldr.. then merge the two folds together
19:57:48 <EvanCarroll> i've done length, and sum
19:57:51 <EvanCarroll> I just don't understand last
19:57:53 <EvanCarroll> it doesn't work
19:58:00 <soupdragon> did you try what I said?
19:58:06 <EvanCarroll> (\a _ -> a)
19:58:13 <EvanCarroll> (\_ b -> b)
19:58:15 <EvanCarroll> neiter work
19:58:49 <soupdragon> oh yeah you're right lol - it's returning z
19:59:01 <soupdragon> so it will have to be  [a] -> Maybe a
19:59:06 <soupdragon> with z = Nothing
19:59:16 <EvanCarroll> but we haven't learned that yet.
19:59:22 <soupdragon> yes we have
19:59:27 <EvanCarroll> and, I saw that suggestion somewhere and I don't understand it.
19:59:36 <EvanCarroll> no i mean the thompson book hasn't mentioned Maybe yet.
19:59:43 <soupdragon> but this is real life
20:00:28 <EvanCarroll> we need the government to regulate computer books, and require that all of them ship with answer keys.
20:00:35 <ddarius> EvanCarroll: Can you define last in the form of: last [] = ...; last (x:xs) = ... ?
20:00:42 <soupdragon> if you put down [a] -> Maybe a and ask what type f will be you will find it easy to finish the problem......
20:01:00 <soupdragon> but you seem more interested in complaining so I will finish reading my book
20:01:28 <EvanCarroll> ddarius: I was thinking about that, I think so, if you can get last to call itself recursively until it matches [x] and then just return x
20:01:52 <ddarius> EvanCarroll: Can you fill in those ...s?
20:04:21 <EvanCarroll> last' [x] = x
20:04:21 <EvanCarroll> last' (x:xs) = last' xs
20:04:23 <EvanCarroll> ddarius: yes
20:04:38 <EvanCarroll> ddarius: wanted t omake sure it would work, because I'm on a roll of epic fail proportions today
20:04:39 <ddarius> EvanCarroll: Those aren't the ...s I gave you.
20:05:01 <EvanCarroll> oh!
20:06:12 <EvanCarroll> no, I can't.
20:06:17 <EvanCarroll> I can if I add another variable
20:06:27 <EvanCarroll> and make the second part a local function
20:06:29 <EvanCarroll> or something
20:06:30 <EvanCarroll> I think
20:06:49 <EvanCarroll> re ddarius 
20:06:52 <ddarius> EvanCarroll: You can just rewrite the definition you gave me before.
20:07:03 <ddarius> What happens when you write last []?
20:08:17 <EvanCarroll> it dies, unmatched case expression...
20:08:32 <EvanCarroll> but I could just add last [] = [] and make it safe
20:08:41 <ddarius> So it errors out, therefore: last [] = error "last of empty list"
20:08:47 <ddarius> EvanCarroll: That wouldn't be type correct.
20:08:58 <ddarius> It also wouldn't be semantically correct.
20:09:50 <EvanCarroll> well, last is only supposed to work on a list, and an empty list is a polymorphic type? 
20:09:55 <EvanCarroll> why would it not be type correct
20:10:01 <ddarius> last doesn't return a list
20:10:31 <EvanCarroll> ah
20:10:34 <edwardk> @type last
20:10:35 <lambdabot> forall a. [a] -> a
20:10:35 <EvanCarroll> touché
20:10:54 <EvanCarroll> so last of a list should error - gotcha
20:11:03 <EvanCarroll> so what was wrong with my definition?
20:11:08 <edwardk> now, theoretically if you foam pad the world you could make tail [] = [] -- but that has issues of its own
20:11:19 <ddarius> EvanCarroll: Nothing, it just isn't in the form I asked for.
20:11:36 <orlandu63> edwardk: so how would you be able to define last while only pattern matching against [] and (x:xs)?
20:11:53 <orlandu63> wait nevermind
20:11:57 <orlandu63> i just found out
20:11:59 <adnap> Why do I have to do this?:
20:12:09 <adnap> > [5,4..1]
20:12:10 <lambdabot>   [5,4,3,2,1]
20:12:17 <adnap> Instead of:
20:12:19 <ddarius> Every strict function on lists can be written in the form: f [] = ...; f (x:xs) = ...
20:12:20 <adnap> > [5..1]
20:12:22 <lambdabot>   []
20:12:39 <ddarius> adnap: Because the [m..n] only goes up.
20:12:42 <adnap> Why does .. assume I'm counting up?
20:12:48 <orlandu63> i can see why that is
20:12:48 <edwardk> last (x:xs) = go x xs where { go x [] = x; go _ (x:xs) = go x xs }; last [] = error "last"; 
20:12:51 <ddarius> adnap: Because that's what it means by definition.
20:12:57 <adnap> ddarius: Okay
20:13:13 <adnap> ddarius: It's making my code ugly.
20:13:17 <alexbobP> (\x -> true) adnap
20:13:35 <orlandu63> edwardk: i was thinking last (x:xs) = if null xs then x else last xs
20:13:48 <ddarius> adnap: That choice was made because usually you want [m..n] when n < m to be the empty list for out of bounds/boundary cases.  It usually simplifies code.
20:14:00 <edwardk> orlandu63: yes, but the problem with that approach is that you effectively are pattern matching each term twice, so it can be much slower
20:14:16 <orlandu63> oh okay
20:14:22 <ddarius> adnap: [m, m-1 .. n] hardly seems like something that would significantly uglify your code.  If it is that much of a problem, define your own function that does it.
20:15:37 <adnap> ddarius: Check this out: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27649#a27649
20:15:56 <ddarius> edwardk: If we were caring about performance, we'd write EvanCarroll's original definition and not restrict ourselves in this way.
20:15:57 <EvanCarroll> edwardk: here is the second pattern match in that?
20:16:12 <adnap> ddarius: Can you see a nice way to refactor this?
20:16:15 <adnap> alexbobP: Hey!
20:16:28 <alexbobP> adnap: I wanna take you to a gay bar, gay bar, gay bar!
20:16:51 <ddarius> adnap: If that works, I don't see why it would need to be improved.
20:16:58 <adnap> ddarius: It's so ugly!
20:17:22 <adnap> ddarius: I did it to avoid using reverse.  Do you think that's important?
20:17:36 <adnap> ddarius: reverse is O(n)
20:18:05 <ddarius> adnap: Is that a problem?  Your code is going to be at least O(n) as is.
20:19:04 <adnap> ddarius: Yeah, so it's O(n) vs O(2 * n).  I'm not sure if it's a big deal.  I was thinking I needed to optimize because these lists could be very big.
20:19:39 <ddarius> adnap: Why don't you decide that you need to optimize when you have a performance problem?
20:19:59 <EvanCarroll> i do not see the extra pattern match in adnaps function, unless you're referring to the `null xs`
20:20:01 <adnap> ddarius: I agree with you.  Plus, the reverse is much more readable.
20:20:14 <ddarius> @src null
20:20:15 <lambdabot> null []     = True
20:20:15 <lambdabot> null (_:_)  = False
20:20:26 <EvanCarroll> right, so that is what makes it slower?
20:20:27 <alexbobP> adnap: if you need to optimize
20:20:32 <ddarius> EvanCarroll: The only way to get information from an algebraic data type in Haskell is through pattern matching.
20:21:12 <adnap> alexbobP: I don't know if I do yet or not.
20:21:14 <edwardk> EvanCarroll: the null check is a pattern match
20:21:25 <alexbobP> adnap: (....) a b = if (a<b) then [] else a:((a-1)....b)
20:21:30 <ddarius> EvanCarroll: It causes the check for (:) v. [] to occur twice.  Whether it makes it slower or not depends on what optimizations are performed.
20:21:39 <alexbobP> adnap: problem solved
20:22:02 <ddarius> alexbobP: Why four dots?
20:22:22 <alexbobP> ddarius: I have no idea if three dots is taken :P
20:22:30 <alexbobP> I figured four was silly enough to be available
20:22:31 <ddarius> It isn't by any common function.
20:22:37 <alexbobP> okay
20:22:42 <adnap> alexbobP: I don't know if that's readable.  Certainly your function is, but someone might mistake ... for .. within my function.
20:22:59 <EvanCarroll> alright, I'm going to grocery shoping and then going home
20:23:01 <alexbobP> adnap: then ,,
20:23:05 <adnap> alexbobP: XD
20:23:10 * EvanCarroll leaves panarera bread.
20:23:13 <ddarius> alexbobP: That's not a legal identifier.
20:23:18 <alexbobP> ddarius: aww...
20:24:12 <alexbobP> adnap: (♥) a b = if (a<b) then [] else a:((a-1) ♥ b)
20:24:37 * alexbobP wonders if unicode is legal
20:25:03 <alexbobP> > 9 ♥ 2 where (♥) a b = if (a<b) then [] else a:((a-1) ♥ b)
20:25:04 <lambdabot>   <no location info>: parse error on input `where'
20:25:08 <Axman6> > let (♥) a b = if (a<b) then [] else a:((a-1) ♥ b) in 10 ♥ 3
20:25:09 <lambdabot>   [10,9,8,7,6,5,4,3]
20:25:11 <gwern> mofo! I just figured out why my crontab wasn't running - I'd forgotten a blank last line
20:25:17 <gwern> apparently that *still* hasn't been fixced
20:25:21 <Axman6> heh
20:25:24 <adnap> alexbobP: I *love* it.
20:25:27 <alexbobP> Axman6: thanks
20:25:29 <alexbobP> adnap: :D
20:25:39 <alexbobP> adnap: put the code in unicode!
20:35:12 <alexbobP> adnap: so I've decided I'm gonna rice the shit out of my macbook, because it has a nice case
20:35:26 <orlandu63> rice meaning?
20:35:31 <alexbobP> make it moar faster!
20:35:41 <alexbobP> I ordered an SSD
20:35:44 <alexbobP> put in 4GB of ram
20:35:46 <alexbobP> gonna install gentoo
20:35:53 <alexbobP> and maybe get a new processor if it's replacebale
20:35:55 <gwern> orlandu63: see http://funroll-loops.info/
20:35:59 <gwern> speaking of gentoo...
20:36:01 <alexbobP> exactly :D
20:36:12 <alexbobP> and the hostname is going to be "onigiri"
20:36:17 <gwern> o.o
20:36:54 <orlandu63> oh man
20:36:59 <orlandu63> that website is great
20:37:25 <alexbobP> well that website aside, there are good reasons to run gentoo
20:37:49 <orlandu63> no there isn't
20:38:05 <alexbobP> 1) it makes sure you have all the headers present for software you have, which makes building things much easier
20:38:37 <alexbobP> 2) cpu-specific tuning (there is a slight benefit to letting gcc know you have a core2 vs amd phenom, etc)
20:38:42 <orlandu63> that is after you compile your own kernel for a 2% speed boost
20:38:43 <Cale> Compiling things you're not hacking on is for suckers ;)
20:38:59 <alexbobP> 3) use flags kick ass (if you want oss, compile everything without alsa support, no need to configure software)
20:39:05 * Cale holds gentoo users personally responsible for the heat-death of the universe.
20:39:12 <alexbobP> lawl
20:39:15 <alexbobP> hold friggin car drivers.
20:39:18 * alexbobP bikes everywhere
20:39:21 <orlandu63> really? i think use flags are an abomination
20:39:28 <orlandu63> i much prefer freebsd's ports system
20:39:58 <alexbobP> freebsd's crushing lack of support from any software?
20:41:04 <alexbobP> anyways building software doesn't take that long these days
20:41:12 <alexbobP> and I just have my computer do it while I sleep so it's not a problem
20:41:27 <orlandu63> freebsd has over 20000 ports, or packages
20:42:02 <alexbobP> does it have a packager with dependancy resolution?
20:42:43 <orlandu63> yeah, only during installing. when removing software you're out of luck
20:42:50 <alexbobP> lovely :P
20:42:52 <orlandu63> you just reminded me why i dont use freebsd anymore
20:42:54 <orlandu63> heh
20:43:13 <alexbobP> well I like gentoo because it has *most* of the niceties of a modern distro
20:43:25 <alexbobP> and also makes it easy when I want to hack around on stuff
20:43:48 <gwern> I distrust gentoo; it seems adrift
20:44:25 <orlandu63> i don't like gentoo because ebuilds fail to build not uncommonly and package maintainers are lazy, it seems
20:44:57 <orlandu63> i.e there isn't any official php 5.3 ebuild released, 1.2 years after its release
20:45:18 <orlandu63> alsa nginx isn't registered as an httpd in webapp-config
20:45:30 <orlandu63> (which is a 2yo bug)
20:46:25 <orlandu63> oh yeah and emerge is slow
20:46:43 <adnap> alexbobP: I like how you've hijacked this channel. XD
20:46:46 <orlandu63> and paludis is good but it broke my system somehow
20:48:00 <alexbobP> adnap: onigiri
20:48:22 <adnap> alexbobP: What about it?
20:48:39 <alexbobP> adnap: it's gonna be the hostname of my riced up linux mac
20:48:50 <alexbobP> orlandu63: anyways it's important to rice up a computer that has a metal exterior
20:48:55 <adnap> alexbobP: Let's talk about this in #club-ubuntu or something!
20:49:04 <alexbobP> orlandu63: it already has make-it-faster plaid stripes
20:49:09 <alexbobP> adnap: okay.
20:49:22 <alexbobP> adnap: you fail at being there.
20:49:26 <alexbobP> oh not anymore
20:57:26 <deech> Hi all, does anyone know of a bridge between Free Pascal and Haskell? Google didn't turn up anything.
20:58:36 <ezyang> iirc, we only support the ccall and stdcall calling conventions. 
21:00:00 <ezyang> s/we/ghc/ 
21:01:19 <deech> ezyang: that's what I figured, just hoping i guess. Thanks!
21:02:34 <ddarius> stdcall should be similar to Pascal (though perhaps not similar enough).  At any rate, Free Pascal should let you export functions in a C-callable format.
21:03:15 * monochrom finishes rebuilding haskell platform 2010 to provide linux x86 shared libs! \o/
21:03:41 * monochrom now goes around ghc --make -dynamic 'ing
21:08:45 <soupdragon> > cos pi
21:08:46 <lambdabot>   -1.0
21:08:48 <soupdragon> > cos (pi/2)
21:08:49 <lambdabot>   6.123233995736766e-17
21:09:12 <soupdragon> > cos (pi/3) + cos (pi-pi/3)
21:09:13 <lambdabot>   -1.1102230246251565e-16
21:09:31 <soupdragon> why are theer so many double digits?
21:09:41 <soupdragon> 6.123233995736766e-17 <-- 3 double digits
21:09:50 <soupdragon> -1.1102230246251565e-16 <-- 2 double digits
21:13:45 <Cale> That's not *so* improbable, I think.
21:13:56 <soupdragon> > 2*cos (2*pi/3)
21:13:57 <lambdabot>   -0.9999999999999996
21:14:03 <soupdragon> > 2*cos (0)
21:14:04 <lambdabot>   2.0
21:21:51 <tolkad> Is there anyway to create a class or data type that can only be of a restricted set of values of another type, and can be used in place of that type?
21:22:22 <tolkad> like, let's say I wanted to create a type which would be all Integers from 1 to 10000
21:22:40 <ezyang> tolkad: You can create a smart constructor, so that invariants are preserved at runtime. 
21:22:54 <tolkad> ezyang: how?
21:22:55 <ezyang> There are also type system tricks you can pull. 
21:23:12 <ezyang> tolkad: Write a function, and don't export the data constructor. 
21:23:17 <tolkad> oh
21:23:26 <ibt> tolkad: http://www.haskell.org/haskellwiki/Smart_constructors
21:23:54 <Cale> tolkad: You can of course create a type which has exactly 10000 values and a function which converts to and from integers (though the 'from' part obviously will have exceptional cases)
21:24:06 <tolkad> btw, will haskell ever save memory by sharing the same bit to store information about multiple variables?
21:24:10 <Cale> But this is not terribly convenient.
21:24:42 <Cale> tolkad: Well, parts of datastructures which came from the same place will be shared.
21:25:42 <Cale> tolkad: This is taken advantage of in things like Data.Map, which is really a tree structure.
21:26:21 <tolkad> It would be nice to be able to create datatypes as subsets of others
21:26:28 <Cale> When you add a new element to the Map, only a path from the root down to the place where the new element occurs (and a constant width swath around that for balancing) need be created.
21:26:32 <tolkad> Is there an exension for this?
21:26:36 <Cale> Everything else can be shared with the original tree.
21:26:47 <jkingkong> can anybody familiar with dph tell me if there's an easy way to deconstruct [:a:]? like a (:) operator for parallel lists?
21:26:48 <Cale> tolkad: That's really tough.
21:26:56 <tolkad> Cale: it would be awesome though
21:27:06 <Cale> tolkad: Remember that types are properties which are verified statically by the compiler.
21:27:34 <tolkad> Cale: not sure what that means but it would still be awesome
21:27:54 <Cale> tolkad: So if you allow, say, addition on these restricted integers, that means the compiler must check that whatever recursive computations you do, you'll never construct too large an integer.
21:28:25 <Cale> Whenever you add two of them, it has to ensure that there are somehow properties that ensure that they won't sum to more than 10000, without actually running the program.
21:28:36 <dibblego> I lament, will there ever be a nicer name than "mappend/mempty"?
21:28:40 <tolkad> Cale: is that uncomputable?
21:28:48 <Cale> tolkad: In general, yes.
21:28:54 <ibt> dibblego: what would you call it?
21:29:02 <Cale> In order to do that, you'd typically get the programmer to include a proof.
21:29:39 <tolkad> Cale: well, what happens if an Int overflows in haskell?
21:29:44 <Cale> The types get really fancy. I don't doubt that it's doable in GHC Haskell with all the extensions, but it's probably quite painful.
21:29:52 <Cale> tolkad: Runtime exception.
21:30:04 <Cale> Er, actually, not even, I think :)
21:30:06 <monochrom> > 2^80 :: Int
21:30:08 <lambdabot>   0
21:30:12 <Cale> Int is modulo 2^n
21:30:13 <ibt> dibblego: seems like 'op' and 'unit' would be better
21:30:15 <Cale> for some n
21:30:21 <tolkad> Cale: yeah that seems like it would be pretty inefficient to check
21:30:27 <tolkad> at runtime that is
21:30:57 <Cale> It's not so bad actually, but if you cared about overflow, you might as well just use Integer
21:31:01 <monochrom> I don't recall haskell specifying "it must crash" or "it must not crash"
21:31:01 <tolkad> so, don't check it
21:31:03 <dibblego> ibt, ⊕ ∅
21:31:15 <tolkad> if it fails it's the programers fault and it causes UB
21:32:13 <monochrom> OTOH most CPUs actually check overflows in hardware, always, can't even be disabled. It was C which started the tradition of not caring.
21:32:20 <tolkad> It's no different than using Int, Int8, etc. it would just allow you to create those on the fly
21:32:35 <Cale> "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined; an implementation may choose error (_|_, semantically), a truncated value, or a special value such as infinity, indefinite, etc."
21:32:45 <monochrom> So much for "C is oh so low level" "C is oh so close to hardware". It can't even act on a simple hardware flag.
21:33:02 <tolkad> monochrom: yeah you can
21:33:08 <tolkad> monochrom: it's just not standard
21:33:36 <tolkad> because it's not implemented on all hardware
21:34:02 <jkingkong> in the "Harnessing the Multicores" paper on data parallel haskell, there appears to be a splitP function
21:34:11 <monochrom> stdio is not implemented on all hardware. yet it's standard.
21:34:11 <jkingkong> however i can't actually find the function
21:34:21 <tolkad> I wonder why they didn't just define something that said whether the function was available or not
21:34:23 <Cale> jkingkong: It's internal, I'm pretty sure.
21:34:27 <jkingkong> what happened to it? and if it is gone, what should i use instead?
21:34:30 <Cale> jkingkong: If it's what I'm thinking of.
21:35:00 <jkingkong> cale: well, how can you partition parallel lists?
21:35:18 <jkingkong> it seems silly that there is a convenient way of concatenating them, but now way to split them up again
21:35:19 <tolkad> Cale: allowing subsets of datatypes would work just the same why
21:35:20 <Cale> Partition how?
21:35:44 <jkingkong> by a predicate or by index i suppose
21:36:59 <tolkad> > [1,1,2..]
21:37:01 <lambdabot>   <no location info>: parse error on input `..'
21:37:09 <Cale> Well, there's filterP at least
21:37:09 <tolkad> > [1,1,2,3,5,8..]
21:37:10 <lambdabot>   <no location info>: parse error on input `..'
21:37:16 <tolkad> > [1,1,2,3,5,8,13..]
21:37:17 <lambdabot>   <no location info>: parse error on input `..'
21:37:20 <tolkad> > [1,1,2,3,5,8,13,21..]
21:37:21 <lambdabot>   <no location info>: parse error on input `..'
21:37:32 <tolkad> > [1,1,2,3,5,8,13,21,34..]
21:37:33 <lambdabot>   <no location info>: parse error on input `..'
21:37:39 <Cale> jkingkong: It's a bit surprising if they don't provide a splitAtP
21:37:42 <tolkad> > [1,1,2,3,5,8,13,21,34,55..]
21:37:43 <jkingkong> yea
21:37:43 <lambdabot>   <no location info>: parse error on input `..'
21:37:50 <tolkad> > [1,1,2,3,5,8,13,21,34,55,89..]
21:37:52 <lambdabot>   <no location info>: parse error on input `..'
21:37:52 <jkingkong> i was hoping for a deletefilter of sorts
21:38:02 <jkingkong> because sometimes, you want what's leftover too
21:38:11 <tolkad> > [1,1,2,3,5,8,13,21,34,55,89,144..]
21:38:12 <lambdabot>   <no location info>: parse error on input `..'
21:38:18 <tolkad> it's not working
21:38:25 <jkingkong> i could just filter it twice with an extra (not) somewhere, but that feels a little lame
21:38:36 <qwebirc119> Can someone tell whether mapM is supposed to be lazy or not?
21:39:10 <Cale> jkingkong: The dph stuff is still being worked on and rather experimental
21:39:16 <jkingkong> or, i could do a list comprehension and an unzipP
21:39:19 <jkingkong> yea i understand
21:39:28 <Cale> qwebirc119: well... lazy in what sense?
21:39:38 <Cale> qwebirc119: and in which monad?
21:39:47 <qwebirc119> Cale: Very frustrated with the following code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27652
21:39:54 <Cale> > mapM (\x -> [x,x]) [1..]
21:39:56 <lambdabot>   *Exception: stack overflow
21:39:59 <qwebirc119> If I replace line (1) with line (2), it works.
21:40:28 <tolkad> thik it's possible to turn this into an infinite list in haskell? http://www.research.att.com/~njas/sequences/?q=5%2C+12%2C+13%2C+14%2C+23%2C+25%2C+27%2C+31%2C+34%2C+38%2C+40%2C+41%2C+42%2C+44&sort=0&fmt=0&language=english&go=Search
21:40:30 <tolkad> think*
21:42:32 <Cale> qwebirc119: Well, yeah, it has to run all those computations, and it'll never finish.
21:42:58 <qwebirc119> So it's not possible to do a mapM on an infinite list? 
21:43:00 <Cale> qwebirc119: let c = map id b (why map id?) doesn't actually do anything. It just defines the meaning of c.
21:43:26 <Cale> qwebirc119: It's just not possible to collect any of the results of the mapM, because it never finishes.
21:43:41 <tolkad> [1,6,14,107..]
21:43:45 <tolkad> > [1,6,14,107..]
21:43:46 <lambdabot>   <no location info>: parse error on input `..'
21:43:51 <tolkad> darn it, I expected that to work
21:43:55 <Cale> tolkad: Why?
21:44:09 <Cale> tolkad: The only things which are defined like that are arithmetic progressions.
21:44:25 <tolkad> Cale: Yeah, this is an arithmetic progression
21:44:31 <Cale> > [1,6..]
21:44:32 <lambdabot>   [1,6,11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96,101,106,111,116,...
21:44:38 <tolkad> Cale: first 4 values of the busy beaver function
21:44:59 <Cale> The busy beaver function isn't arithmetic.
21:45:16 <Cale> (It's not even computable :)
21:45:16 <tolkad> oh so how do you do it in haskell?
21:45:24 <Cale> It can't be computed.
21:45:41 <tolkad> Cale: by turing-limited languages
21:46:12 <Cale> You can work out the first handful of values by checking all small Turing machines and proving that some of them will never terminate, but eventually you will reach a Turing machine for which you won't be able to prove whether it halts or not.
21:46:38 <ivanm> this one? http://en.wikipedia.org/wiki/Busy_beaver
21:46:42 <ivanm> tolkad: "turing-limited"?
21:46:51 <ivanm> how does turing-completeness "limit" you?
21:47:30 <tolkad> ivanm: turing completeness specifies a lower bound of what your language can compute
21:47:53 <ivanm> so, what kind of stuff can you do in a language which is not "limited" by turing completeness?
21:47:54 <tolkad> ivanm: by turing-limited, I meant turing-completeness as an upper bound
21:48:05 <Cale> I refuse to work in an environment without at least an omega stack of termination oracles.
21:49:11 <Cale> ivanm: You might, for instance, be able to determine if an arbitrary Turing machine halts :P
21:49:30 <ivanm> OK, can _any_ language currently do that?
21:49:30 <tolkad> ivanm: the church turing thesis is, at best, wild conjecture
21:49:32 <dibblego> @pl liftM2 mappend (runMaybeT (f p)) (runMaybeT (g p))
21:49:32 <lambdabot> liftM2 mappend (runMaybeT (f p)) (runMaybeT (g p))
21:49:41 <Cale> ivanm: No.
21:49:43 <ivanm> tolkad: I wouldn't call it a wild conjecture
21:49:59 <CakeProphet> wait a second
21:50:04 <CakeProphet> what can solve the halting problem?
21:50:06 <Cale> ivanm: It's thought to be impossible, and it can be proven impossible within various physical models.
21:50:07 <CakeProphet> other than a human mind, that is.
21:50:10 <ivanm> Cale: so does that indicate that "turing complete" limits us or that it is not actually possible to compute such a thing at all?
21:50:15 <ivanm> Cale: right
21:50:18 <Cale> CakeProphet: A human mind isn't any better.
21:50:18 <tolkad> CakeProphet: ahahahaha the human mind is a turing machine
21:50:27 <tolkad> CakeProphet: we cannot solve the halting problem
21:50:31 <Cale> The human mind isn't even as powerful as a Turing machine.
21:50:35 <CakeProphet> tolkad:  well, turing-equivalent at least.
21:50:36 <ivanm> so the "turing thesis" would be a theory/hypothesis in the scientifiic sense
21:50:41 <Cale> It doesn't have infinite memory
21:50:56 <CakeProphet> Cale:  no, for sure the human mind can solve a halting problem. I'd say you've done with arbitrary programs. I know I have.
21:51:00 <ivanm> it looks right, sounds right, all evidence seems to support it, but it might be possible to disprove
21:51:04 <Cale> CakeProphet: hah
21:51:11 <tolkad> CakeProphet: arbitrary programs of limited length
21:51:12 <CakeProphet> Cale:  s/done/done it/
21:51:46 <CakeProphet> tolkad:  ah, I forget about those. And how are these arbitrary infinite programs created?
21:51:50 <tolkad> CakeProphet: A turing machine exists that solves the halting problem on any finite number of turing machines
21:51:59 <CakeProphet> by a procedure? can't we solve the halting problem on it?
21:52:28 <Cale> CakeProphet: If you had the magical ability to determine whether any arbitrary program can terminate, you could become quite wealthy just by solving all the open problems in mathematics.
21:52:32 <tolkad> CakeProphet: we can only solve the halting problem for a limited set of turing machines
21:52:56 <CakeProphet> ah. so technically
21:53:09 <tolkad> CakeProphet: however, the human mind is not an isolated system, you can, for instance, use a computer to help you in your computations, or a piece of paper, so really you are limited to what the universe can compute
21:53:29 <CakeProphet> there are programs that can be defined without language, or semantics? But infinite in length?
21:53:39 <tolkad> CakeProphet: wat
21:53:53 <tolkad> CakeProphet: only if you stretch the definition of program to be useless
21:54:01 <CakeProphet> tolkad:  yeah, input output. You're still computing.
21:54:07 <Cale> CakeProphet: It's easy, after all, to construct a program which just looks for a proof, and only terminates if the nth symbol of the first proof (in some ordering) is some specific symbol. By repeating that process, you can construct a proof from answers to termination questions.
21:54:28 <CakeProphet> tolkad:  so why bother with these inconceivable programs? Why consider that they exist if they cannot be defined easily?
21:54:30 <Cale> So you could find proofs for all outstanding mathematical problems.
21:55:05 <Cale> (supposing that they're decidable)
21:55:27 <CakeProphet> I couldn't tell you that. Not likely. I'm hardly a brilliant mathematician. I'm just saying it is possible for a human mind to solve the halting decision problem on any arbitrary, well-defined program.
21:55:44 <Cale> and so if you could really tell if an arbitrary Turing machine halts, you should be able to win the prize for proving the Riemann Hypothesis.
21:56:04 <Cale> CakeProphet: I think you're using the word 'arbitrary' incorrectly.
21:56:04 <tolkad> CakeProphet: think of it this way
21:56:21 <tolkad> CakeProphet: there are an infinite number of programs
21:56:25 <Cale> CakeProphet: There are lots of programs which I could write and you couldn't tell me if they halt on all inputs or not.
21:56:50 <tolkad> CakeProphet: using all the atoms in the universe, you can't even store all the programs individually
21:57:10 <tolkad> CakeProphet: and only a tiny subset of the ones you can store are computable for you
21:58:21 <Cale> > let wonder n | n < 0 = []; wonder 1 = [1]; wonder n = n : if even n then wonder (n `div` 2) else wonder (3 * n + 1) in wonder 57
21:58:22 <lambdabot>   [57,172,86,43,130,65,196,98,49,148,74,37,112,56,28,14,7,22,11,34,17,52,26,1...
21:58:37 <Cale> CakeProphet: Please check for me that this program terminates for all n :)
21:59:18 <Cale> (That is, that it produces a finite list)
21:59:40 <tolkad> oh, I can do that
21:59:49 <soupdragon> "it is possible for a human mind to solve the halting decision problem on any arbitrary, well-defined program" -- no no you got it the wrong way around "It is possible to convert an arbitrary well defined mathematical statement into a halting problem"
22:00:05 <tolkad> > tail wonder
22:00:06 <lambdabot>   Not in scope: `wonder'
22:00:20 <tolkad> @let wonder n | n < 0 = []; wonder 1 = [1]; wonder n = n : if even n then wonder (n `div` 2) else wonder (3 * n + 1) in wonder 57
22:00:21 <lambdabot>   Parse error: KW_In
22:00:30 <tolkad> 0_o
22:00:36 <Cale> @let wonder n | n < 0 = []; wonder 1 = [1]; wonder n = n : if even n then wonder (n `div` 2) else wonder (3 * n + 1)
22:00:38 <lambdabot>  Defined.
22:00:42 <tolkad> > tail wonder
22:00:42 <Cale> > wonder 83
22:00:43 <lambdabot>   Couldn't match expected type `[a]'
22:00:43 <lambdabot>         against inferred type `a1 -> [a1]'
22:00:43 <lambdabot>   [83,250,125,376,188,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274...
22:00:50 <Cale> tolkad: wonder isn't a list
22:00:55 <tolkad> oh, right
22:01:00 <Cale> tolkad: it's a list-producing function
22:01:11 <tolkad> > tail $ map wonder [1..]
22:01:12 <lambdabot>   [[2,1],[3,10,5,16,8,4,2,1],[4,2,1],[5,16,8,4,2,1],[6,3,10,5,16,8,4,2,1],[7,...
22:01:18 <tolkad> uh whoops
22:01:21 <tolkad> uh
22:01:34 <tolkad> wait what?
22:01:44 <Cale> What's confusing?
22:01:50 <Cale> > map wonder [1..]
22:01:51 <lambdabot>   [[1],[2,1],[3,10,5,16,8,4,2,1],[4,2,1],[5,16,8,4,2,1],[6,3,10,5,16,8,4,2,1]...
22:01:54 <tolkad> oh, I didn't mean tail
22:02:02 <CakeProphet> hmmm
22:02:19 <tolkad> > last $ map wonder [1..]
22:02:23 <lambdabot>   mueval-core: Time limit exceeded
22:02:23 <Cale> CakeProphet: This is actually an open problem in mathematics. Nobody has solved it yet.
22:02:31 <tolkad> uh, sec, I'll get ghci
22:02:36 <tolkad> Cale: well I'm about to solve it
22:02:45 <Cale> tolkad: Well, there's certainly no last element to the list you gave there.
22:03:00 <tolkad> Cale: oh right uh
22:03:01 <tolkad> hmm
22:03:11 <djahandarie> All we need is an infinitely powerful proccessor or infinite amounts of time
22:03:21 <Cale> > map (last . wonder) [1..]
22:03:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:03:28 <CakeProphet> tolkad:  that specific program? You want me to prove that it halts?
22:03:30 <CakeProphet> or not?
22:03:37 <tolkad> CakeProphet: no, it doesn't halt
22:03:54 <Yahovah> tolkad: Are you sure it doesn't halt?
22:03:57 <tolkad> CakeProphet: cale's
22:04:02 <Cale> We want to show that for each n,  wonder n  will halt
22:04:11 <tolkad> Yahovah: lol I mapped it onto [1..], it doesn't halt
22:04:14 <luite> > filter ((==aleph0).length) $ map wonder [1..]
22:04:15 <lambdabot>   Not in scope: `aleph0'
22:04:25 <Cale> luite: haha
22:04:31 <CakeProphet> tolkad:  well then how is that demonstrating a well-definable program that we cannot solve? I concede now that there are possible programs we cannot solve, but I think some of the ones we can't solve are the ones that don't exist.
22:04:31 <Yahovah> tolkad: Yeah, it didn't halt in so many seconds. Does it halt if you give it a second more time to compute? :)
22:04:41 <luite> Cale: please add the correct definition to lambdabot ;)
22:05:03 <Cale> CakeProphet: Well, we can do better.
22:05:05 <tolkad> Yahovah: no, because [1..] is an infinite list...
22:05:21 <CakeProphet> perhaps a "closed program", with no access to an outside world
22:05:28 <CakeProphet> that can be defined.
22:06:02 <Cale> CakeProphet: hm?
22:06:05 <tolkad> CakeProphet: wait what? cale's problem doesn't exist?
22:06:15 <Cale> CakeProphet: It's just an example of something which is hard.
22:06:16 <tolkad> CakeProphet: it certainly looks like it does
22:06:44 <CakeProphet> tolkad:  map wonder [1..]?  No it clearly halted. 
22:06:53 <Cale> CakeProphet: and if you can really tell us whether arbitrary Turing machines halt or not with your magical human brain, then you ought to be able to tell whether this program halts or not :)
22:07:01 <tolkad> CakeProphet: that's because I didn't run it on a turing machine
22:07:13 <Cale> CakeProphet: It clearly didn't halt.
22:07:18 <CakeProphet> tolkad:  er, ratjer
22:07:21 <Cale> CakeProphet: We just stopped running it after a while.
22:07:45 <CakeProphet> tolkad:  it doesn't halt. It only halts in the real world where other things can terminate it.
22:07:49 <Cale> CakeProphet: There's a difference between a Turing machine halting and us giving up on continuing to run it.
22:07:58 <Cale> right
22:08:02 <CakeProphet> tolkad:  that's what I meant. a typo. :P
22:08:10 <CakeProphet> but, I can determine that, by staring at the program....
22:08:11 <shuping> Hi, I am new to haskell, may I ask a question?
22:08:18 <dibblego> shuping, sure mate go for it
22:08:22 <Cale> CakeProphet: Right. But that's not actually the question.
22:08:26 <Cale> shuping: Absolutely.
22:08:28 <tolkad> shuping: first tell us what the question is
22:08:36 <tolkad> shuping: then we'll tell you if you can ask it
22:08:38 <shuping> Is there any function that averaging a list?
22:08:44 <tolkad> yes you can ask that
22:08:54 <Cale> CakeProphet: The question is whether for all n, whether the program wonder n will halt.
22:09:16 <Cale> shuping: Not a built in one, but it's not so hard to write.
22:09:22 <CakeProphet> Cale:  for all n??
22:09:31 <Cale> sum xs / fromIntegral (length xs)
22:09:42 <Cale> CakeProphet: yeah, for all possible inputs.
22:09:58 <CakeProphet> Cale:  well then the answer is no
22:10:00 <Cale> CakeProphet: Or for each possible input, to say the same thing in a different way :)
22:10:02 <tolkad> @let average xs = sum xs / fromIntegral (length xs)
22:10:04 <lambdabot>  Defined.
22:10:12 <tolkad> > average [1..10]
22:10:13 <lambdabot>   5.5
22:10:16 <tolkad> err
22:10:19 <tolkad> uh
22:10:25 <tolkad> 0_o
22:10:29 <shuping> oh, that's what I do
22:10:44 <tolkad> oh
22:10:46 <tolkad> yeah
22:10:48 <tolkad> ok
22:11:00 <tolkad> sum [4,5,6]
22:11:07 <Cale> shuping: Note that this only works for lists of numbers which have a Fractional type (like Float, Double, Rational, etc.)
22:11:09 <tolkad> > average [4,5,6]
22:11:10 <lambdabot>   5.0
22:11:17 <tolkad> > average [1..52395]
22:11:18 <lambdabot>   26198.0
22:11:24 <shuping> but I just thought sum and length would loop the list twice.
22:11:29 <Cale> shuping: They will.
22:11:34 <tolkad> average [pi,pi*2..]
22:11:39 <Cale> shuping: It's not particularly efficient, this version I gave you.
22:11:41 <tolkad> > average [pi,pi*2..]
22:11:47 <Cale> shuping: But it's fine for small enough lists :)
22:11:49 <lambdabot>  Terminated
22:11:53 <tolkad> > average [pi,pi*2..pi*100]
22:11:58 <lambdabot>   158.65042900628436
22:11:59 <Cale> shuping: If you want to be fancy...
22:12:01 <tolkad> =D
22:12:09 <shuping> ok, got thanks! :)
22:12:19 <CakeProphet> shuping:  you could define it recursively if you really wanted.
22:12:34 <CakeProphet> and do it in one loop
22:12:34 <ivanm> preflex: seen edwardk 
22:12:34 <preflex>  edwardk was last seen on #haskell 1 hour, 51 minutes and 20 seconds ago, saying: EvanCarroll: the null check is a pattern match
22:13:26 <shuping> I am lost in the mixed messages since I am also new to irssi :(
22:13:49 <CakeProphet> shuping:  ah. that's the client I use. What do you need to do?
22:13:54 <Cale> > let average xs = s/n where (s,n) = foldl' (\(!s,!n) x -> (s+x,n+1)) (0,0) xs in average [1..1000000]
22:13:55 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
22:14:00 <Cale> oh, no BangPatterns
22:14:09 <tolkad> bang
22:14:11 <ivanm> just seq them?
22:14:24 <Cale> > let average xs = s/n where (s,n) = foldl' (\(s,n) x -> s `seq` n `seq` (s+x,n+1)) (0,0) xs in average [1..1000000]
22:14:27 <lambdabot>   500000.5
22:14:31 <BMeph> Is "fromIntegral . length" faster than "genericLength"?
22:14:36 <Cale> Yeah, that works. Nicer with bang patterns though.
22:14:42 <shuping> there are sessions, how can I figure out my session easily?
22:15:01 <ivanm> Cale: you mean lambdabot doesn't use -fglasgow-exts? :p
22:15:13 <luite> BMeph: probably, but it's limited by the range of the Int type
22:15:48 <ivanm> which is the main reason people use genericLength to start with
22:15:58 <ivanm> (as well as copumpkin's Natural tricks)
22:16:25 <Cale> hrm, I no longer can build lambdabot
22:16:40 <Cale> ... why does lambdabot depend on readline anyway...
22:17:13 * Cale wonders where lispy went
22:17:15 <ivanm> because it was never updated to work with haskeline?
22:17:19 <ivanm> preflex: seen lispy
22:17:19 <preflex>  lispy was last seen on #haskell 8 hours, 6 minutes and 21 seconds ago, saying: Cale_: Hmm...I think you could do that in agda using mixfix
22:18:25 * BMeph just noticed that he pronounces "haskeline" the same way he does "Vaseline"...
22:18:55 <Cale> Vase line.
22:19:08 <Cale> Urn row
22:19:33 <BMeph> Cale: Please - "Urn queue". ;
22:19:42 <tolkad> @let average = f x 1 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + y)
22:19:43 <lambdabot>   Parse error: EOF
22:19:46 <tolkad> @let average = f x 1 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + y)}
22:19:48 <lambdabot>  <local>:10:0:
22:19:48 <lambdabot>      Equations for `average' have different numbers of argumen...
22:19:56 <tolkad> @unset average
22:19:57 <lambdabot> Unknown command, try @list
22:19:59 <tolkad> @list
22:20:00 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:20:11 <tolkad> @delete average
22:20:11 <lambdabot> 4\/3Ra93
22:20:19 <tolkad> @forget average
22:20:20 <Cale> 甕列
22:20:20 <lambdabot> Incorrect arguments to quote
22:20:36 <tolkad> @undefine average
22:20:43 <tolkad> @let average = f x 1 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + y)}
22:20:45 <lambdabot>  <local>:1:12:
22:20:45 <lambdabot>      Couldn't match expected type `[t]' against inferred type ...
22:21:07 <tolkad> @let average = f x 1 0 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + y)}
22:21:08 <lambdabot>  <local>:1:12:
22:21:08 <lambdabot>      Couldn't match expected type `[t]' against inferred type ...
22:21:20 <Cale> @undefine undefines everything
22:21:32 <Cale> Regardless of what parameters you give it :)
22:21:53 <tolkad> @let average = f x 1 0 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + x)}
22:21:54 <lambdabot>  <local>:1:12:
22:21:54 <lambdabot>      Couldn't match expected type `[a]' against inferred type ...
22:21:58 <Cale> (There's at present no way to be more specific than that)
22:22:13 <tolkad> @let average = f x 1 0 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + x)}
22:22:15 <lambdabot>  <local>:1:12:
22:22:15 <lambdabot>      Couldn't match expected type `[a]' against inferred type ...
22:22:15 <tolkad> @let average = f x 1 0 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + x)}
22:22:17 <lambdabot>  <local>:1:12:
22:22:17 <lambdabot>      Couldn't match expected type `[a]' against inferred type ...
22:22:18 <ivanm> why are you insisting on providing lambdabot with some average value?
22:22:25 <tolkad> @let average = f x 1 0 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + x)}
22:22:27 <lambdabot>  <local>:1:12:
22:22:27 <lambdabot>      Couldn't match expected type `[a]' against inferred type ...
22:22:38 <BMeph> tolkad: Where are you pulling that 'x' you're giving the 'f' function -- "the Darkest Place in the Galaxy"? ;)
22:22:40 <Cale> tolkad: If something is a type error once, it's not going to stop being a type error the next time
22:22:47 <tolkad> @let average x = f x 1 0 where {f [] y z = z `div` y; f (x:xs) y z = f xs (y + 1) (z + x)}
22:22:49 <lambdabot>  Defined.
22:22:52 <keseldude> tolkad: there's also another way
22:23:02 <tolkad> > average [1..10]
22:23:04 <ivanm> yes, by using it directly
22:23:06 <lambdabot>   5
22:23:18 <tolkad> > average [1..3]
22:23:19 <lambdabot>   1
22:23:25 <tolkad> @undefine
22:23:28 <ivanm> yeah, I think your average function is borked
22:23:33 <tolkad> @let average x = f x 1 0 where {f [] y z = z / y; f (x:xs) y z = f xs (y + 1) (z + x)}
22:23:35 <lambdabot>  Defined.
22:23:42 <tolkad> > average [1..10]
22:23:44 <lambdabot>   5.0
22:23:49 <ivanm> tolkad: next time, just do: > let average x = ... in average [1..10]
22:23:50 <tolkad> > average [1..3]
22:23:51 <ivanm> or whatever
22:23:51 <lambdabot>   1.5
22:24:22 <lucca> That's a strange average
22:24:26 <Cale> tolkad: Your initial list length is 1
22:24:31 <tolkad> let average = "your face is a just do: > let average x = ... in average [1..10]" in average
22:24:32 <BMeph> > let average = f 0 0  where {f y z [] = z `div` y; f y z (x:xs) = f (y + 1) (z + x) xs} in average [1..10]
22:24:33 <lambdabot>   5
22:24:39 <tolkad> > let average = "your face is a just do: > let average x = ... in average [1..10]" in average
22:24:40 <lambdabot>   "your face is a just do: > let average x = ... in average [1..10]"
22:24:56 <tolkad> > let average = f 0 0  where {f y z [] = z / y; f y z (x:xs) = f (y + 1) (z + x) xs} in average [1..10]
22:24:57 <lambdabot>   5.5
22:25:00 <tolkad> ah
22:25:36 <tolkad> let 5 = 2 in let 5 = 3 in 2
22:25:40 <tolkad> > let 5 = 2 in let 5 = 3 in 2
22:25:42 <lambdabot>   2
22:25:53 <tolkad> > let 5 = 2 in let 2 = 3 in 5
22:25:55 <lambdabot>   5
22:25:57 * ivanm thinks @let should be banned...
22:26:16 <Cale> ivanm: It's rather easy to clear it :)
22:26:26 <tolkad> @let (x = y) = "your mom"
22:26:26 <lambdabot>   Parse error: Equals
22:26:37 <tolkad> @let x (=) y = "your mom"
22:26:38 <lambdabot>   Parse error: Equals
22:26:42 <tolkad> @let (=) x y = "your mom"
22:26:43 <lambdabot>   Parse error: Equals
22:26:52 <tolkad> @let x `=` y = "your mom"
22:26:53 <lambdabot>   Parse error: Equals
22:26:56 <Cale> = isn't a valid symbol name
22:27:07 <tolkad> @let x == y = "your mom"
22:27:09 <lambdabot>  Defined.
22:27:14 <tolkad> > 5 == 2
22:27:16 <lambdabot>   Ambiguous occurrence `=='
22:27:16 <lambdabot>  It could refer to either `L.==', defined at <loc...
22:27:21 <tolkad> : /
22:27:27 <Cale> > 5 L.== 2
22:27:28 <lambdabot>   "your mom"
22:27:29 <tolkad> just overwrite
22:27:47 <tolkad> Cale: make it overwrite existing functions, buitin or not, permanently
22:28:04 <dons> http://code.haskell.org/haskell-platform/download-website/
22:28:07 <Cale> @undefine
22:28:09 <dons> any objections?
22:28:17 <tolkad> the chaos would be beautiful
22:28:20 <ivanm> tolkad: *sigh* you can't even spell "mum" correctly...
22:28:22 <ivanm> ;-)
22:28:36 <ivanm> dons: did you get my @ask message?
22:28:41 <dons> hmm no??
22:28:49 <ivanm> *sigh* silly lambdabot 
22:28:58 <ivanm> anyway, comment on the platform page: it's too slow to load ;p
22:29:23 <dons> i shrunk the size of the files, and the actual site won't be on the code.h.o vm
22:29:25 <ivanm> and the OS logos go over the "Robust" text here
22:29:39 <dons> can you take a screenshot with the above link, plz?
22:29:45 <ivanm> sure
22:29:47 <tolkad> ivanm: that's the way stupid british people spell it think they are so great talking all pompous like with their tea and crumpets and horse races and they have a queen so they are all ruled by a monarchy but here in the us we are a democracy because we are the only free country on earth and we owned you guys in the revolutionary war and the only reason we aren't invading you right now to take your oil is we are busy doing that in iraq so watch out
22:29:58 <luite> dons: the tiling background looks a bit ugly here
22:30:07 <dons> ivanm: and let me know your os / browser / geometry
22:30:12 <dons> same for luite ^^^
22:30:15 <luite> is it supposed to open in a fixed size popup window?
22:30:17 <tolkad> dons: how do I download the website?
22:30:26 <keseldude> dons: want a screenshot?
22:30:28 <ivanm> dons: *sigh* might have been something to do with not loading properly
22:30:31 <dons> tolkad: oh, darcs get http://code.haskell.org/haskell-platform/
22:30:41 <tolkad> dons: it says download website on that page
22:31:04 <dons> tolkad: the beta site is http://code.haskell.org/haskell-platform/download-website/
22:31:07 <tolkad> dons: it's kind of misleading to say you can download the website when you cant
22:31:10 <dons> which is a subdir of the darcs repo
22:31:16 <dons> tolkad: i don't understand
22:31:27 <tolkad> dons: yeah it says "download-website" but I can't see a way to download the website on that page
22:31:36 <Cale> haha
22:31:43 <dons> tolkad: that's the repo for the beta, not the live site.
22:31:54 <dons> the live site is haskell.org/platform 
22:32:10 <tolkad> dons: but I want to download the website like the url says I can why doesn't it have a link to download the website?
22:32:22 <dons> ok. you'll have to think about that.
22:32:32 <ivanm> dons: http://omploader.org/vNHloOA res is 1280x800
22:32:53 <dons> ivanm: your screen seems narrow?
22:33:04 <ivanm> short ;-)
22:33:10 <tolkad> dons: why is there a commented <br />?
22:33:10 <ivanm> 12.1" screen
22:33:11 <dons> possibly i could make the font ratios smaller
22:33:21 <ivanm> dons: if I make xmonad go full screen, then it's OK
22:33:26 <ivanm> same if I make firefox go fullscreen
22:33:37 <ivanm> so I think it's some dynamic sizing/placement thing at work
22:33:42 <luite> dons: one moment, I'll take a screenshot
22:33:46 <keseldude> http://img.skitch.com/20100717-mn14qd7fwhs7g2kqrabwn12wg9.png
22:34:10 <dons> keseldude: thanks!
22:34:12 <dibblego> http://paste.pocoo.org/show/238587/ why do I see y on the output?
22:34:32 <ivanm> so yes, small screen + lots of tabs == placement problems ;-)
22:34:40 <dons> it seems hard to center horizontally and vertically via CSS2
22:34:41 <Cale> dons: Probably not really a problem, but did you purchase that background? :)
22:34:47 <tolkad> dons: it's really ugly when the border repeats itself on the right
22:34:55 <dons> Cale: chrisdone did, yes.
22:34:59 <Cale> ah, okay :)
22:35:02 <dons> tolkad: can't help that
22:35:17 <tolkad> dons: you could get an image that blends into itself from left to right
22:35:17 <dons> tolkad: it means your browser doesn't support scalable background
22:35:24 <tolkad> dons: and top to bottom
22:35:28 <dons> try upgrading to chrome.
22:35:54 <ivanm> dons: anyway, what I had @ask'd you yesterday was that I'm working on the generic container stuff I talked about in that blog post you put on the haskell reddit, and I wanted to know what you thought about how to do map: define it internally or use RFunctor Heffalump's rmonad package: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27630#a27630
22:35:56 <ddarius> dibblego: Why the heck are you expecting not to?
22:36:00 <dons> keseldude: that's useful. maybe the columns should be related to each other.
22:36:04 <ivanm> (that's an old version; I've been working on it all day)
22:36:19 <dibblego> ddarius, because the First monoid needn't inspect the second argument
22:36:52 <ddarius> dibblego: So?  Both IO actions will already be run before mappendf gets applied.
22:37:12 <luite> dons: http://94.124.88.78/~luite/platform.png
22:37:54 <dibblego> ddarius, of course, thanks
22:38:16 <luite> dons: chrome 5.0.375.99 on windows 7, don't look at the illegal sites in my bookmarks bar ;p
22:38:46 <dons> luite: nice. thanks.
22:38:57 <Cale> I actually think it looks pretty decent with no scaling. I don't have a large enough display for an image that large to tile :P
22:39:14 <ivanm> luite: what's library genesis?
22:39:19 <dons> interesting seeing all these wide and tall screens
22:39:25 <luite> ivanm: nothing ;p
22:39:46 <ivanm> anyone know what the "build" function present in the Prelude source file is?
22:39:49 <Cale> (plus, I almost never maximise my browser)
22:39:59 <dons> Cale: yeah, that's the idea. and the CSS says to scale anyway, so most browsers will stretch it
22:40:34 <dons> unless you have a tall screen, like luite 
22:40:46 <dons> i find web design boring, btw. its tedious :-)
22:41:09 <dons> at least CSS + html is a little like latex, but that's about as fun as it gets
22:41:34 <ddarius> It can be annoying, though mostly due to browser's failing to correctly implement standards.
22:41:39 <dons> yup
22:41:58 <keseldude> it's probably more fun as a team sport
22:42:02 <dons> and the CSS language is baroque as a layout DSL, though it could be worse.
22:42:19 <luite> Cale: the image is scaled down to the width of the browser in chrome, so you only need to make the browser window narrow
22:42:47 <ddarius> dons: It's not too bad.  There are only a few crazy gotchas and it can be overly limited at times.  You could write XSLT.
22:42:48 <Cale> luite: yeah
22:43:31 <luite> dons: I don't have a tall screen, I just tend to keep a tall/narrow browser window at the side of the screen
22:43:59 <JasTastic> Does anyone on here know a website/irc network/channel similiar to #dshield/#shadowserver.org where it would be possile to report Botnet activities?
22:45:06 <luite> dons: by the way, firefox does not scale the image
22:46:05 * hackagebot smt-lib 0.0.1 - Parsing and printing SMT-LIB.  http://hackage.haskell.org/package/smt-lib-0.0.1 (TomHawkins)
22:47:12 <ivanm> dons: anyway, what I had @ask'd you yesterday was that I'm working on the generic container stuff I talked about in that blog post you put on the haskell reddit, and I wanted to know what you thought about how to do map: define it internally or use RFunctor Heffalump's rmonad package: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27630#a27630
22:47:14 <dons> luite: yes, i noticed  that.
22:48:54 <tolkad> dons: I tried updating to chrome but I can't find noscript
22:49:18 <tolkad> dons: I don't want to run without noscript, what if someone links me to last measure or something...
22:51:05 <ksf> hmmm on the one hand there's a lot of literature about state transducers, otoh at least folklore seems to say that they're equivalent to dfa's over the product of input and output alphabet.
22:51:41 <CakeProphet> so from what I can gather
22:51:42 <ksf> which, at least modulo epsilon in the output, seems to be trivially true.
22:52:08 <CakeProphet> if you prove the Riemann hypothesis, you can prove that properties of finite sets of numbers can analyically continue to infinite sets.
22:52:08 <ksf> actually, it should be true anyways.
22:53:43 <ivanm> preflex: seen edwardk 
22:53:43 <preflex>  edwardk was last seen on #haskell 2 hours, 32 minutes and 29 seconds ago, saying: EvanCarroll: the null check is a pattern match
22:54:28 <ivanm> @ask edwardk are your generator/reducor concepts similar to what's in the "shortcut to deforestation" paper?
22:54:29 <lambdabot> Consider it noted.
22:55:06 <ksf> by rule of thumb, they should be eqivalent to mapAccumR
22:55:37 <ksf> ...and you can do a lot with mapAccumR.
22:57:55 <ivanm> ksf: was that to me, or are you talking to yourself?
22:58:02 <ivanm> (oh, and to CakeProphet)
22:58:16 <ezyang> Assertion: I think delimited continuations are less useful in languages that encourage function composition. 
22:58:18 <ezyang> Discuss. 
22:58:37 * ivanm hates it when people just go "blah blah blah, discuss"
22:58:50 <ksf> oh, I didn't even notice CakeProphet was talking to me, as that was over my head.
22:59:03 <tolkad> I pwn
22:59:04 <tolkad> discuss
23:00:14 <ksf> I should probably stop _thinking_ about fsa's and get started on implementing dfas, but I feel I have still some pondering to do.
23:00:15 <ivanm> @slap tolkad 
23:00:16 <lambdabot> I'd rather not; tolkad  looks rather dangerous.
23:00:28 <ivanm> grrrrr......
23:01:04 <luite> hmm, finally found the bug in my "obviously correct" program :)
23:01:10 <ksf> the confusion might be to the fact that computational linguists are linguists, not programmers...
23:03:26 <ezyang> ivanm: heh 
23:03:45 <ezyang> In this case, I was thinking about delimited continuations and version control and thinking "It doesn't by you much, does it." 
23:06:20 <CakeProphet> ksf:  dfas?
23:06:43 <ksf> deterministic finite automata
23:07:05 <ksf> I know, I should abbreviate the plural dfaa ;)
23:09:23 <ezyang> ksf: What are you planning on doing with the impl? 
23:10:38 <ksf> protocol parsing and handling
23:11:14 <ksf> ...I started out with all that parser stuff because there's no as-fast-as possible parser that I could've used for my iteratee lib.
23:12:06 <ksf> while attoparsec is fast, it's certainly slower than a minimized dfa compiled to straight code, and virtually everything that you want to read over the net or such is regular.
23:12:30 <ksf> transducing, then, comes into play to construct values out of the matched stuff.
23:13:44 <ksf> my current working assumption is that one can write a state transducer for a regex that outputs a nested word that corresponds to all kleene stars etc. so you can match it just like you would do in a sax parser.
23:14:22 <ksf> thinking of it, one could use the implementation to generate a sax driver...
23:17:58 <ksf> and I'm still waiting to stumble across the excact relation between iteratees and automata.
23:25:46 <BMeph> ivanm: Is there some benefit to not declaring "sequence(_) = mapM(_) id" ? :)
23:26:02 <ivanm> that, probably not
23:26:09 <ivanm> just didn't think about it ;-)
23:26:36 <ivanm> hmmm.... is it possible to implement build/fold fusion using custom build and fold functions, or does it require GHC hackery?
23:27:10 <ksf> rules pragmas
23:27:26 <ivanm> do they support polymorphism though?
23:27:45 <ksf> so, yes, for certain values of ghc hackery it does.
23:27:50 <ksf> why wouldn't they?
23:28:17 <ivanm> as in this kind of polymorphism: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27630#a27630
23:30:49 <ksf> shouldn't you be doing stream fusion, anyway?
23:33:11 <ksf> and I think elem and notElem call for a function (a -> Bool) -> c -> Bool
23:51:32 <davekong> > a `elem` "foobar"
23:51:33 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
23:51:33 <lambdabot>         against inferred ...
23:51:44 <davekong> > 'a' `elem` "foobar"
23:51:44 <lambdabot>   True
23:58:19 <krainboltgreene> Q: Why is the Haskell website [http://haskell.org] so terribly designed? :(
23:58:42 <dibblego> A: Because you weren't around to design it until now.
23:59:25 <PetRat> Problem about writing concise code using Monads or something: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27655#a27655
