00:00:03 <ddarius> ivanm: That's how its been for a very long time.
00:01:22 <tensorpudding> 6.8 is available in Lenny for PPC, so you can use that to bootstrap 6.12
00:02:10 <tensorpudding> or wait, you didn't say if you actually used Debian
00:02:12 <ivanm> should you go straight to 6.12 or go via 6.10?
00:02:18 <ivanm> tensorpudding: I think he doesn't IIUC...
00:03:11 <ddarius> ivanm: Straight to 6.12
00:03:58 <ivanm> and then use 6.12 to rebuild 6.12? ;-)
00:04:14 <ddarius> ivanm: That's part of the build process of GHC regardless.
00:04:16 <tensorpudding> You can build 6.12 using anything after 6.6, according to the build site
00:04:31 <ivanm> dammit, my new test failed on its first go :s
00:06:24 <ski> tolkad : got your type running ?
00:06:42 <ivanm> oh, wait, that's because my test sucks
00:08:37 <tolkad> ski: not yet, got distracted :P
00:10:40 <tolkad> I wonder why Num doesn't extend Ord 0_o
00:12:07 <tolkad> uh, no, it doesn't work
00:12:34 <Veinor> tolkad: you mean why num doesn't require ord?
00:12:35 <tolkad> it says the arguments of one of my functions using the constructor are "not in scope" 0_o
00:12:41 <ski> tolkad : (a) what did you try ? (b) what did you expect ? (c) what did you actually get ?
00:12:41 <tolkad> Veinor: yeah
00:12:45 <Veinor> complex numbers.
00:12:55 <tolkad> Veinor: ah
00:13:03 <tolkad> Veinor: is there a Real?
00:13:03 <Veinor> or any other non-ordered field, really
00:13:13 <tolkad> Veinor: well all real numbers can be ordered
00:13:17 <Veinor> Real is a typeclass that require Num and Ord
00:13:40 <ski> @src Real
00:13:40 <lambdabot> class  (Num a, Ord a) => Real a  where
00:13:41 <lambdabot>     toRational      ::  a -> Rational
00:13:41 <Veinor> as well as the ability to divide
00:13:48 <Veinor> oh wait, that's integral
00:13:50 <Veinor> whoops
00:13:56 <tensorpudding> isn't there a way to make a space filling curve from R to C?
00:14:02 <ski> @src Fractional
00:14:03 <lambdabot> class  (Num a) => Fractional a  where
00:14:03 <lambdabot>     (/)             :: a -> a -> a
00:14:03 <lambdabot>     recip           :: a -> a
00:14:03 <lambdabot>     fromRational    :: Rational -> a
00:14:12 <Veinor> tensorpudding: you can do [0,1] to [0,1] x [0,1]
00:14:15 <Veinor> so possibly
00:15:56 <tensorpudding> Hmm, but a space filling curve is self-intersecting, so you won't be able to make a distinct ordering of C using the ordering on R
00:16:31 <Jafet> You can, but it won't make any sense.
00:16:42 <Jafet> Might also be a bother to compute
00:17:31 <tensorpudding> Well, you can't order C, but you can order Z[i] anyway
00:18:04 <Veinor> you can order any set ;)
00:19:16 <monadic_kid> I wonder why there is no visual pl for arrows that generates haskell arrow code. I think that would be quite interesting way to build game with yampa
00:19:30 <tensorpudding> Okay, totally order
00:20:38 <Veinor> can you totally order any set without the AoC?
00:20:44 <Jafet> Yes, you can total order any set!
00:21:24 <Veinor> proof?
00:22:01 <ski> tensorpudding : you can't order the complex numbers, such that the order "plays nice" with the field structure (i.e. you can't make it an ordered field)
00:22:51 <tensorpudding> The well-ordering theorem is equivalent to choice.
00:22:59 <Veinor> right.
00:23:16 <Veinor> WOT => AC is easy, just order the union of the sets and pick the smallest element
00:23:20 <tolkad> Jafet: you can order any set, but not all sets have a defined order
00:23:27 <tensorpudding> You can't constructively give a total ordering of C.
00:23:44 <Jafet> Uh, lexicographical order?
00:24:18 <Veinor> Jafet: the point is that that doesn't play well with multiplication
00:24:32 <Jafet> <insert what ski said>
00:25:42 <Veinor> wikipedia says a field can be ordered if and only if 0 is not a sum of squares
00:26:31 <Veinor> the 'if' part is easy, the 'only if' isn't
00:26:37 <Veinor> er, swap that
00:27:14 <tolkad> ski: data T where A :: (Real a) => a -> T <newline> f :: (Real a) a -> T <newline> f x = A x
00:27:38 <tolkad> ski: it says x is not in scope on the last line
00:27:56 <tolkad> oh... wait
00:28:04 <tolkad> I guess it thinks I never finished my type definition
00:29:12 <tolkad> why though...
00:29:19 <Axman6> assuming do syntax didn't exist in haskell already, could it be defined in haskell we have currently, minus do notation?
00:29:59 <Jafet> What does that mean?
00:30:17 <Axman6> ?
00:30:20 <tolkad> ?
00:30:25 <Jafet> !
00:30:34 <Jafet> You can't define new syntax in haskell.
00:30:47 <ivanm> Axman6: nope
00:30:51 <Veinor> Axman6: do syntax is technically syntactic sugar, if that's what you mean
00:30:59 <tolkad> We might not be able to define syntax, but we can try
00:30:59 <Axman6> i know, but i was wondering if it would in any way be possible
00:31:07 <Axman6> bleh, you're all missing my point :(
00:31:14 <ivanm> Veinor: yeah, I think he's asking if its possible to implement syntactic sugar inside haskell
00:31:16 <Veinor> @undo {x <- f y; let x' = g x; z; return x x'}
00:31:16 <lambdabot>  Parse error at "{x" (column 1)
00:31:17 <Jafet> "could ... do syntax ... be defined in haskell ..., minus do notation?"
00:31:18 <ivanm> Axman6: ^^ did I get your point?
00:31:20 <Veinor> bah!
00:31:23 <tolkad> Axman6: you can do it!
00:31:27 <tolkad> Axman6: don't give up!
00:31:28 <ivanm> Veinor: you need a do there
00:31:37 <ivanm> @undo do{x <- f y; let x' = g x; z; return x x'}
00:31:37 <lambdabot>  Parse error at ";" (column 29)
00:31:44 <ivanm> @undo {do x <- f y; let x' = g x; z; return x x'}
00:31:44 <lambdabot>  Parse error at "{do" (column 1)
00:31:46 <ivanm> bah
00:31:54 <ivanm> obviously I'm doing it wrong
00:31:58 <Veinor> @undo do {x <- f y; z; return x x'}
00:31:58 <lambdabot> f y >>= \ x -> z >> return x x'
00:32:26 <Veinor> how does that parenthesize?
00:32:26 <Axman6> no, i don't necessarilly mean syntactic sugar, i mean if it could be implemented in any way that would typecheck, so you could have say do (a <- b) (c <- d) where do is some kind of function
00:32:54 <ivanm> Veinor: looks like it doesn't like the let
00:32:57 <Veinor> f y >>= (\x -> (z >> return x x'))?
00:32:58 <Veinor> yeah
00:33:04 <ski> tolkad : in `f :: (Real a) a -> T', you're missing a `=>' .. try `f :: Real a => a -> T'
00:33:13 <ivanm> Axman6: hmmm.... don't think so...
00:33:15 <Jafet> Axman6: you can't make do syntax a function. It's... syntax.
00:33:17 <ivanm> not without a preprocessor
00:33:44 <Jafet> Axman6: what's wrong with (>>=)?
00:33:49 <Axman6> Jafet: my question is does it need to be
00:34:27 <Jafet> Unlike if, probably yes. Depending on what your secret ideas about it are.
00:35:21 <Veinor> @undo do {x <- f y; return (x + 1)}
00:35:21 <lambdabot> f y >>= \ x -> return (x + 1)
00:35:39 <ivanm> hmmm.... I'm guessing the point of the Suitable class here is to avoid having to put the constraint on for RFunctor, RMonad, etc. ? http://hackage.haskell.org/packages/archive/rmonad/0.5/doc/html/Control-RMonad.html
00:35:40 <CakeProphet> @src on
00:35:40 <lambdabot> (*) `on` f = \x y -> f x * f y
00:36:10 <tensorpudding> THe syntactic sugar of do-notation surely will not give you programmer's diabetes
00:36:42 <ivanm> ugh, rmonad has extremely poor documentation :s
00:36:47 <ivanm> tensorpudding: heh
00:37:00 <ivanm> @remember tensorpudding The syntactic sugar of do-notation surely will not give you programmer's diabetes
00:37:00 <lambdabot> I will remember.
00:37:55 <ivanm> preflex: seen Heffalump 
00:37:55 <preflex>  Heffalump was last seen on #haskell 9 hours, 18 minutes and 2 seconds ago, saying: Saizan: I see, thanks
00:42:43 <CakeProphet> where is liftM3?
00:42:44 <CakeProphet> :t liftM3
00:42:45 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
00:43:04 <CakeProphet> @hackage liftM3
00:43:04 <lambdabot> http://hackage.haskell.org/package/liftM3
00:43:05 <etpace> @hoogle liftM3
00:43:05 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
00:43:13 <CakeProphet> ah.
00:43:24 <CakeProphet> thought I had that imported, guess not. :P
00:43:41 <Veinor> @src liftM3
00:43:41 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
00:43:49 <etpace> :t f <$> x <*> y <*> z
00:43:50 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
00:43:51 <lambdabot>     In the second argument of `(<$>)', namely `x'
00:43:51 <lambdabot>     In the first argument of `(<*>)', namely `f <$> x'
00:44:02 <ivanm> or else you can use ap
00:44:16 <etpace> :t \f x y z -> f <$> x <*> y <*> z
00:44:17 <etpace> :t ap
00:44:17 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
00:44:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:44:21 <ivanm> @type \ f a b c -> f `ap` a `ap` b `ap` c
00:44:22 <lambdabot> forall (m :: * -> *) a a1 a2 b. (Monad m) => m (a -> a1 -> a2 -> b) -> m a -> m a1 -> m a2 -> m b
00:44:30 <ivanm> @type \ f a b c -> liftM3 f a b c
00:44:31 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
00:44:44 <etpace> :t <$>
00:44:45 <lambdabot> parse error on input `<$>'
00:44:49 <ivanm> oh, it's not quite the same
00:44:50 <etpace> :t (<$>)
00:44:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:44:58 * ivanm wonders what he's doing wrong
00:45:06 <ivanm> should it be return f `ap` ... ?
00:45:07 <CakeProphet> emptyWorldState = liftM3 WorldState (newTVarIO M.empty) (newTVarIO M.empty) (newTVarIO M.empty)
00:45:12 <etpace> yeah i think so
00:45:15 <etpace> ap wants f to be in the monad
00:45:25 <CakeProphet> does this function produce an IO action that yields a WorldState consisting of three TVars set to empty Maps?
00:45:52 <ivanm> @ask Heffalump is the purpose of the Suitable typeclass in rmonad to avoid having to put the constraint in both RFunctor and RMonad?
00:45:53 <lambdabot> Consider it noted.
00:53:01 <ski> @type \ f a b c -> return f `ap` a `ap` b `ap` c  -- looking for this ?
00:53:02 <lambdabot> forall a a1 a2 b (m :: * -> *). (Monad m) => (a -> a1 -> a2 -> b) -> m a -> m a1 -> m a2 -> m b
00:53:06 <ski> ivanm : ^
00:53:26 <ivanm> ski: yeah, I figured it'd be something like that
00:53:33 <ivanm> I just didn't recall having to use return, that's all
00:54:02 * ski is more familiar with using  return f `ap` ma `ap` ...  than  f <$> ma <*> ...
00:56:40 * ivanm is more familiar with using liftM<n>
00:57:12 <ski> .. well, that's a third option (which i wasn't comparing with above), yes
00:57:24 <ivanm> ;-)
00:59:49 <tolkad> ok, now I have another problem
00:59:49 <tolkad> data T where C :: (Real a) => a -> T; f :: (Real a) => T -> a; f (T a) = a
01:00:05 <ivanm> wtf?
01:00:09 <tolkad> it says it couldn't match that type of f against the type Real a in C
01:00:12 <ivanm> tolkad: didn't you say you were only learning haskell?
01:00:18 <tolkad> ivanm: yes
01:00:19 <ivanm> if so, why are you suddenly using GADTs?
01:01:01 <tolkad> ivanm: someone told me to when I asked how to use classes like interfaces in java where you can cast something to them
01:01:14 <ivanm> yes, but just because you can doesn't mean you should
01:01:43 <ivanm> I'm not saying GADTs are bad, but maybe you should learn to walk before you try breaking any unpowered land-speed records... ;-)
01:03:07 <tolkad> well... is there a fromReal function? =D
01:03:20 <ivanm> from Real to what?
01:03:23 <tolkad> I guess not considering they aren't countable
01:03:27 <ivanm> @hoogle (Real a) => a -> b
01:03:31 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
01:03:31 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
01:03:31 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
01:03:49 <tolkad> ivanm: from real to num
01:03:49 <ivanm> only the first one is what you want
01:04:03 <tolkad> ivanm: it's actually not possible I gues
01:04:05 <tolkad> guess*
01:04:06 <ivanm> to _any_ num?
01:04:08 <ivanm> no, not really
01:04:15 <ivanm> same as how it isn't possible in other languages
01:04:27 <tolkad> ivanm: a second later I was like... wait the reals aren't countable
01:04:38 <ivanm> Int -> Double is easy; Double -> Int isn't in general possible
01:04:52 <tolkad> well there's also that
01:04:53 <ivanm> because the maximum Double value is > the maximum Int value
01:05:12 <ivanm> Double -> Integer is feasible using round, truncate, ceil and floor
01:05:29 <tensorpudding> Implementations of Real aren't going to be true reals.
01:05:54 <tolkad> tensorpudding: What!?!
01:06:25 <tolkad> tensorpudding: aww, that was why I was using haskell... I thought it was more powerful than a turing machine
01:06:43 <ivanm> tolkad: it's impossible to accurately store any arbitrary floating-point value
01:06:53 <ivanm> e.g. I want the number 0.0000000000....... 1
01:07:12 <ivanm> (i.e. infinite number of 0s followed by a 1 in the fractional part)
01:07:21 <tensorpudding> that isn't a real number
01:07:22 <tolkad> ivanm: (0, [0..], 1)
01:08:03 <ivanm> tolkad: *sigh* OK, it's still possible to come up with numbers that are not representable even using that scheme
01:08:13 <tolkad> I'm just kidding... the thing about the reals being uncountable was a joke
01:08:27 <ivanm> there is, however, the concept of computable reals which covers all _reachable_ real numbers (i.e. there is some way to compute it)
01:12:45 <ivanm> wow... I added tests to my testsuite and magically the runtime went down from 55 min to 50 min!
01:12:54 <ivanm> adding tests makes the other tests go _faster_!!!!!
01:13:15 <ivanm> (or else some of the stuff I changed internally affected the performance; take your pick)
01:13:54 <Jafet> Now you have justification to ship it with the tests
01:14:17 <Jafet> Why, if you add even more tests, your program might start faster
01:17:16 <ivanm> well, these are tests for a library, not a program
01:20:35 <ivanm> hmmm.... should I remove the Int version of Point here? http://hackage.haskell.org/packages/archive/graphviz/2999.9.0.0/doc/html/Data-GraphViz-Attributes.html#t%3APoint
01:30:12 <CakeProphet> Dashkal: do you end up passing your world state value around to processes a lot?
01:30:20 <CakeProphet> I suppose it's necessary.
01:30:40 <ivanm> you can hide that kind of stuff under a State monad
01:30:52 <ivanm> (or even better, a Reader if you're not going to edit it)
01:31:11 <CakeProphet> ...no, because processes are IO ()
01:31:20 <CakeProphet> :t forkIO
01:31:21 <lambdabot> Not in scope: `forkIO'
01:31:30 <CakeProphet> :t System.Process.forkIO
01:31:31 <lambdabot> Not in scope: `System.Process.forkIO'
01:31:37 <CakeProphet> oh.
01:31:43 <CakeProphet> :t Control.Concurrent.forkIO
01:31:44 <lambdabot> IO () -> IO GHC.Conc.ThreadId
01:32:01 <ivanm> oh, you're passing it around in IO?
01:32:06 <ivanm> sounds like you're doing it wrong IMHO...
01:32:21 <CakeProphet> ...no, it's the only thing I can do there.
01:32:31 <ivanm> huh?
01:32:33 <CakeProphet> because forkIO is how you spawn threads. It's not a big deal, and actually makes sense to do.
01:32:38 <ivanm> a monad transformer for State can help with that though...
01:32:41 <ivanm> CakeProphet: oh, threading?
01:32:43 <ivanm> see STM
01:32:51 <CakeProphet> ...yes I know. I'm using it.
01:32:53 <ivanm> then you don't explicitly pass your state around, you stick it in a TVar
01:33:06 <ivanm> CakeProphet: I didn't realise you were doing inter-thread communication
01:35:08 <CakeProphet> ivanm:  I'm not really having a problem or anything. I was asking someone who is doing a similar project what they did for something.
01:35:17 <ivanm> yes
01:35:25 <ivanm> and I'm just providing un-asked for advice! ;-)
01:35:38 <CakeProphet> ivanm:  but I have a good idea of what I plan to do now. And yeah, it involves StateT. But why is Reader preferred over State? Is it more efficient?
01:35:43 <ivanm> if you're wanting to do inter-thread communication, STM is a very nice way of doing it
01:35:57 <ivanm> CakeProphet: Reader is preferred if you're only going to read it and not mutate the state
01:36:11 <ivanm> because then you have a guarantee that you're not going to accidentatly mutate the state
01:36:16 <CakeProphet> I have a mixture of both. So I'll probably just throw it all in State and be done with it. :)
01:36:22 <ivanm> fair enough
01:36:43 <ivanm> or you can do a stack with ReaderT and StateT ;-)
01:36:44 <CakeProphet> haha. I can't even imagine myself accidentally mutating the state.
01:37:02 <CakeProphet> "Oh no, I didn't realize deleteGame would delete /everything/!"
01:41:19 <Peaker> CakeProphet, It's nice to be able to just glance at a *type* and know it doesn't call deleteGame or addPoints anywhere
01:43:20 <CakeProphet> Peaker:  it's even better to have written the code yourself and know that it doesn't. 
01:43:37 <ivanm> CakeProphet: maintainability is more important than ease of writing _now_
01:43:56 <Peaker> CakeProphet, The problem is that yourself varies over time :) Your future self is different from your current self
01:44:03 <CakeProphet> I don't see how Reader would make my code more maintainable.
01:44:08 <Peaker> CakeProphet, We humans have limited memory
01:44:24 <ivanm> CakeProphet: you can immediately see and be guaranteed that the value stored in there isn't mutating
01:44:32 <ivanm> thus giving you more to reason with
01:44:41 <Peaker> CakeProphet, You might even make a typo and call the wrong method which modifies the state, and ReaderT would prevent that. Also, the code is simply more readable if it explicitly says "This stuff is read-only"
01:44:47 <ivanm> CakeProphet: put it this way: why should we have an explicit Bool type rather than just using Int like C, etc. do?
01:45:21 <CakeProphet> I suppose.
01:45:40 <CakeProphet> though at the moment, it's all mutating data. I'm only assume something will be read-only that I haven't thought of yet.
01:45:44 <Peaker> ivanm, I really don't understand why they messed that up, and why Python and others copied that mistake
01:45:49 <Peaker> many C mistakes were later copied to other languages
01:46:27 <ivanm> Peaker: becuase it's more efficient! duh!
01:46:29 <CakeProphet> C isn't meant to be Haskell.
01:46:46 <ivanm> (and people thought I was an idiot when I said Python was deliberately designed to be a nice wrapper around C...)
01:47:07 <ivanm> CakeProphet: part of that is we aren't afraid to say "why should we copy what every other language does?"
01:47:23 <ivanm> being a completely different language gives us quite a bit of freedom, as there's no obligation to ensure similarity, etc.
01:47:25 <wli> The bool mistake is actually fairly serious because the hardware it's supposed to be "close to" has these boolean condition flags etc. that C compilers can never figure out.
01:48:16 <CakeProphet> ivanm:  all I meant was that C was made in a different time and for differnt reasons. It's portable high-level assembly.
01:48:27 <ivanm> heh, not quite
01:48:41 <ivanm> there was a discussion about that on -cafe recently IIRC, saying how non-portable it was
01:48:48 <ivanm> wli: *groan*
01:50:06 <wli> CakeProphet: It's not great as far as high-level assembly goes.
01:50:46 <CakeProphet> I don't know, I guess I just don't understand why C has such a bad reputation.
01:51:02 <Peaker> ivanm, where's the discussion?
01:51:12 <Peaker> CakeProphet, I like C but hate some of its big mistakes
01:51:26 <FauxFaux> Peaker: On -cafe! </runs>
01:51:33 <ivanm> I forget, but it was a discussion about portability of Haskell vs portability of C (or was it C++?) on different architectures and OSs
01:51:34 <Peaker> And I use it daily so I have a hard time with its lack of parameterized types too
01:51:57 <Peaker> ivanm, the title should contain "portab" ?
01:52:04 <ivanm> Peaker: not sure...
01:52:05 <CakeProphet> Peaker:  that certainly can be annoying. "Time to make /another/ linked list struct"
01:52:08 * ivanm tries searching his email
01:52:31 <Peaker> CakeProphet, Well, linked-lists (and most other data structures) have a nice solution in C
01:52:45 <wli> Like, dislike, whatever. Present-day language designers could do far better wrt. portable asm than C.
01:53:03 <Peaker> wli, not if those designers are the C# designers or Java designers :P
01:53:36 <Peaker> CakeProphet, There's the "intrusive data structure" pattern in C which makes it possible to write pretty generic data structure code. But other forms of polymorphism are harder
01:53:54 <CakeProphet> Peaker:  intrusive data structure? I don't know if I've ever seen that.
01:54:08 <ivanm> Peaker: in the "Transformers versus monadLib versus..." thread
01:54:12 <ivanm> but it was about C++, not C
01:54:40 <wli> Peaker: Their goals were different; they sought a different niche from "close to the metal" but present-day language designers can still do far better.
01:55:16 <Peaker> CakeProphet, For example, you define a linked list like:  struct list { struct list *next, *prev; };    Then you define:  #define list_entry(ptr, containername, membername)  ((containername *)((ptr) - offsetof(containername, membername))
01:55:34 <wli> Peaker: First and foremost a module system would do wonders even without any other differences.
01:55:38 <Peaker> wli, I think the C# designers just sucked (e.g: nullable references)
01:56:37 <wli> Peaker: They're not using container_of() for list_entry()? What kernel version is this?
01:56:46 <Peaker> CakeProphet, Then you pure a (struct list) inside your data structures, that's why it's called "intrusive" and that makes them potential members of lists. You can put multiple list structs in your data and it can be in multiple lists
01:57:03 <Peaker> wli, Maybe they are, I haven't really followed kernel development of that
01:57:08 <Peaker> wli, what's container_of?
01:57:50 <wli> Peaker: It does address calculation to find the beginning of a data structure given the type name and component name and component address.
01:58:27 <Peaker> wli, Ah, yeah, I use a macro too in my data structures.. (I call it struct_ptr_from_member_ptr or such)
01:58:39 <Peaker> container_of may be a better name :)
01:58:59 <wli> Peaker: It's always wrapped with rb_entry(), list_entry(), etc.
01:59:22 <Peaker> wli, They verify the member is indeed the right type?
02:00:26 <wli> Peaker: No, I'm not sure why it's wrapped. They just pass all 3 of their arguments to container_of()
02:00:50 <Peaker> wli, I guess it allows them to do that in the future, or with some verification tool, and a bit of readability
02:00:57 <Peaker> and possibly backwards compatibility
02:01:32 <Peaker> btw: Monad transformers in real code are annoying :( Too much code in the world has type (IO a -> ...) -> IO ...
02:01:43 <wli> Peaker: A crude sort of backward compat is probably why; if the patch to use container_of() went and swept all users of list_entry() it'd be a massive patch.
02:01:46 <Peaker> It seems like monad transformers are mainly useful for internal loops/etc
02:02:09 <Peaker> wli, Yeah, I hate the textual representation of code we all use :(
02:02:11 <Peaker> Renames are hard
02:05:05 <Peaker> At least I'm making some progress with my non-textual (structural) editor and revision control
02:05:24 <wli> Nice, a *nix -based structure editor.
02:08:02 <Peaker> At first it will edit dumb trees (e.g: XML) so I focus on revision control
02:08:11 <Peaker> later the trees become smarter graphs that represent code
02:08:36 <tolkad> If I have class G a where f :: a -> Int; data (Real a) => T a = TC a; instance G (T a) where f (T a) = 0
02:08:36 <tolkad> I get a could not deduce error for my f implementation. How do I fix that?
02:09:05 <tolkad> err I mean
02:09:16 <tolkad> class G a where f :: a -> Int; data (Real a) => T a = TC a; instance G (T a) where f (TC a) = 0
02:10:27 <codolio> data (Real a) => T a = ... is a bad idea.
02:10:39 <tolkad> why?
02:10:53 <codolio> It just constraints what 'a' you're allowed to use T with.
02:11:03 <tolkad> I know
02:11:08 <codolio> It doesn't give you back evidence that 'Real a' when you match on T.
02:11:11 <codolio> Hence your error.
02:11:36 <Peaker> codolio, why is that, btw? Wouldn't it be safe to have it give you the evidence back?
02:11:42 <ivanm> constraints should go in the functions, not int he data structure definition
02:11:57 <ivanm> (since you'd still need to put it in the functions anyway)
02:11:59 <Peaker> ivanm, or in the GADTs
02:12:02 * ivanm glares at Data.Complex
02:12:15 <ivanm> Peaker: sure, if you're using GADTs
02:12:26 <codolio> Peaker: The only reason I can think of for constraints on datatypes is the pre-98 strictness annotations.
02:12:30 <ivanm> what tolkad had didn't look like a GADT to me though
02:12:40 <codolio> Where you'd need 'data (Eval a) => T a = T !a'.
02:13:10 <codolio> But that class doesn't exist in Haskell 98 anymore, so the constraints are kind of worthless.
02:13:20 <tolkad> so... how do I fix it?
02:13:21 <Peaker> ivanm, it wasn't
02:13:57 <Peaker> tolkad, Put the constraint on the instance
02:14:09 <tolkad> oh
02:14:10 <Peaker> tolkad, instance Real a => G (T a) where
02:14:15 <tolkad> thanks
02:14:16 <Peaker> tolkad, and remove it from "data"
02:15:06 <tolkad> Peaker: it worked without that last step
02:15:31 <dolio> Peaker: And yes, it'd be safe to store the evidence as far as I know. I'm not sure why it doesn't do that. Probably they didn't have that in mind when they desgined it.
02:16:33 <dolio> Although that'd probably have some caveats. Like, you wouldn't be able to constrain newtypes or something.
02:16:39 <tolkad> Peaker: it needs to be on data T because I only want T to be constructed with Nums
02:17:13 <Peaker> tolkad, You don't have to remove it from data but it would be a good idea. then your "T" type becomes the Identity type :)
02:17:44 <tolkad> Peaker: but I only want those to be reals
02:17:49 <tolkad> err real
02:18:07 <Peaker> tolkad, Well, if all useful functions/instances on T have that constraint, then the constraint on the "T" constructor is redundant. You could do: " T 'a' " but there would be nothing you could do with that T
02:18:50 <tolkad> but... it's kind of annoying the constraints are attached to type instead of the constructor. it seems to me a type represents some category of thing and a constructor is a way to store that thing
02:19:15 <tolkad> Peaker: but then it wouldn't make sure they all do : )
02:19:25 <tolkad> and I want them all to
02:19:25 <Peaker> tolkad, data T :: * -> * where T :: Eval a => a -> T a
02:19:54 <Peaker> tolkad, GADTs anticipated your desire :)
02:19:57 <tolkad> Peaker: ivanm told me GADTs are terrible and never to use them
02:20:07 <ivanm> no I didn't
02:20:16 <Peaker> Well, I tend to avoid features outside Haskell98/2010 if it's cheap
02:20:17 <ivanm> I said that _you_ shouldn't be using them yet if you're still learning
02:20:47 <Peaker> GADT's are pretty awesome - I wish they go in Haskell2011 :)
02:21:30 <tolkad> I keep reading "gadget" instead of GADT
02:21:41 <tolkad> must be because I'm tired
02:22:14 <ivanm> Peaker: propose it!
02:22:58 <Peaker> ivanm, I wouldn't, not knowing the consequences of it.. There are bigger experts on the subject... I thought Higher-Ranked types were ready for prime time until I used them a bit more heavily and now I'd be very wary of putting them into Haskell in their current state
02:23:08 <Peaker> I love how GADT's are one huge step towards Dependent Types though
02:23:37 <Peaker> Storing proof inside constructors allowing different values to have different type-level proofs
02:23:37 <wli> What on earth is this about higher-ranked types?
02:23:47 <Peaker> wli, What?
02:24:02 <wli> I thought higher-ranked types were fairly innocuous.
02:24:08 <Peaker> wli, I thought so too
02:24:17 <tolkad> they shouldn't be so careful about putting stuff in haskell
02:24:21 <tolkad> follow PHPs example
02:24:26 <wli> What's his about them not being ready for prime time?
02:24:28 <Peaker> wli: With the Rank2Types extension, for example, f (g x)  is no loner equivalent to  (f . g) x 
02:24:32 <tolkad> stick in whatever you happen to implement
02:24:51 <ivanm> tolkad: and look at the atrocious mess that is PHP
02:25:08 <Peaker> wli,  runST  $ do ...   works, and:   runST (forever (do ...))   works, but  runST . forever $ do ...  doesn't work
02:25:15 <wli> Peaker: That's surprising. How badly do the consequences hurt?
02:25:31 <Peaker> wli, Well, I think there's always a "workaround" but I wouldn't want Haskell to become C++ in this regard
02:25:41 <tolkad> ivanm: PHP is an elegant, expressive, simplistic yet powerful language
02:26:00 <ivanm> you're joking, right?
02:26:05 <ivanm> doesn't look at all simplistic to me
02:26:07 <Peaker> wli, I think (f . g) x should always be a safe replacement  for  f (g x)   and I think they need to resolve the way they do type inference with higher-ranked types (there are a bunch of papers about ideas to do it) so it works well before putting that feature in
02:26:15 <ivanm> and I've heard enough horror stories about it...
02:26:17 <Peaker> tolkad, PHP is elegant? :)
02:26:24 <Peaker> In PHP, the == operator isn't transitive!
02:26:26 <Jafet> @remember tolkad PHP is an elegant, expressive, simplistic yet powerful language
02:26:26 <lambdabot> I will remember.
02:26:37 <Peaker> a == b && b == c    does not imply   a == c   in PHP
02:26:44 <ivanm> Jafet: heh, now he's scarred for life! mwahahahahahahaha!!!
02:26:47 <Peaker> and I don't mean it in the broken Eq instance way
02:26:52 <tolkad> @tolkad
02:26:52 <lambdabot> Unknown command, try @list
02:26:54 <Peaker> I mean the built-in types
02:26:57 <tolkad> @quote tolkad
02:26:57 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
02:27:14 <Jafet> @quote php
02:27:14 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
02:27:18 <tensorpudding> "== isn't transitive" is the kind of argument against PHP that a Haskell person would argue first.
02:27:18 <wli> Peaker: I'm unfamiliar with the choies in this regard. I thought it was relatively bolted down by things.
02:27:19 <Jafet> Cool.
02:27:30 <tolkad> Peaker: as it should be, for PHP says it is so
02:27:53 <ivanm> tensorpudding: as opposed to automatic casting, etc.?
02:28:09 * ivanm really, really hopes tolkad is joking...
02:28:20 <Peaker> tolkad, Tautologic quality arguments always fascinate me
02:28:28 <tensorpudding> As opposed to a lack of sensible design
02:28:32 <Jafet> ivanm: as opposed to more general comments such as "no well-defined semantics"
02:28:33 <Peaker> "It has high quality because it's spec says the implementation should have this horrid behavior and it does" :)
02:28:56 <ivanm> Jafet: well, there's that, but let's pick on the easy/practical things first
02:29:07 <tensorpudding> Though one might say that the behavior of == is indicative of the lack of sensible design.
02:29:17 <Peaker> The problem with "no well-defined semantics" is that it takes a lot of work to really substantiate such a comment
02:29:33 <Peaker> It is after all a relative statement so you have to venture into comparisons of semantics of languages
02:30:05 <Peaker> tensorpudding, Yes, I don't actually have experience with PHP, it is this and other similar examples that suggest PHP was designed by retarded monkeys
02:30:46 <tolkad> Peaker: like $v = 'v'; print "{$v}"; -> v but $v = 'v'; print "{ $v }"; -> { $v }
02:31:27 <Peaker> tolkad, That sounds like reasonable behavior to me
02:31:31 <msieradzki> you can implement something like PHP in 1 day I guess
02:31:35 <tensorpudding> Of course, I really don't know anything about PHP either.
02:31:37 <msieradzki> with just no typing
02:31:45 <msieradzki> not even dynamic weak typing
02:31:47 <tolkad> Peaker: of course it is
02:31:59 <tensorpudding> Though lack of experience hasn't stopped people on the Internet from pronouncing judgment before!
02:32:07 <ivanm> Peaker: does Haskell have well-defined semantics? or is it just formal semantics that it's missing?
02:32:08 <tolkad> Peaker: The way each new language feature is accompanied by new, unique syntatical constructs... It's beautiful
02:33:01 <msieradzki> PHP should be called a templating engine
02:33:06 <msieradzki> on steroids
02:33:07 <tolkad> Peaker: but $v = 'v'; print "{$v }"; -> v
02:34:23 <msieradzki> it all fits when you think of it as about (h|j)stringtemplate
02:34:26 <msieradzki> more or less
02:34:41 <Jafet> ivanm: when you cannot even determine whether you have written a valid or portable PHP program, you can safely say that PHP has no semantics.
02:34:48 <ivanm> heh, fair enough
02:35:07 <ivanm> tolkad: any language that requires a dollar sign to get the value of a variable cannot be beautiful
02:35:11 <Peaker> tolkad, Of course you could cherry pick reasonable things in PHP. Maybe even beautiful things
02:35:12 <ivanm> expensive to use maybe... :p
02:35:20 <tolkad> ivanm: what about perl!?!?
02:35:27 <ivanm> hmmm.... do European PHP programmers use the euro symbol rather than $? :p
02:35:34 <Peaker> tolkad, but if you compare the language with others, you see it has much less beautiful things, and is much more error-prone, etc
02:35:34 <ivanm> tolkad: thank you for making my point for me
02:36:14 <Jafet> @ let (€) = ($)
02:36:17 <Jafet> @let (€) = ($)
02:36:18 <lambdabot>  Defined.
02:36:30 <Jafet> Oh wait, are they at parity?
02:36:35 <msieradzki> euru is hard to write :P
02:36:38 <msieradzki> euro*
02:36:50 * wli seriously wonders if anyone's come up with ideas for getting typeclasses to work with higher-order modules.
02:37:37 <dolio> Well, people have.
02:38:06 <dolio> The question is whether you'll like what they came up with.
02:38:14 <wli> I get the feeling I may have asked before, but don't remember any of the answers.
02:39:23 <dolio> Coq has type classes. I'm not sure what sort of modules they have, I guess now that I think about it.
02:39:38 <dolio> But there's also the Modular Type Classes paper.
02:39:47 <wli> dolio: I'd probably like it if I could understand any of it.
02:39:52 <mreh> higher-order modules?
02:40:01 <dolio> Which basically desugars type classes into modules somehow.
02:40:02 <wli> mreh: Like SML and ocaml.
02:42:43 <tolkad> $x = array(1);var_dump($x);foreach($x as &$v){}var_dump($x); -> array(1) {[0]=>int(1)} array(1) {[0]=>&int(1)}
02:42:50 <dolio> The advantage of that translation is that it supports associated types automatically.
02:42:53 <ivanm> dammit, I was so busy hacking that I missed the beginning of Dr Who! :s
02:43:24 <tolkad> ivanm: Star Trek > Doctor Who
02:43:42 <ivanm> @slap tolkad 
02:43:42 * lambdabot slaps tolkad
02:43:48 <tolkad> ivanm: Star Trek > Star Wars > Doctor Who
02:43:54 <Peaker> I've never used higher-order modules (ML/Ocaml style?) so I don't know what I'm missing.. Type-classes cover what I think I need. Maybe I don't know what I need :)
02:44:41 <wli> Peaker: Higher-order modules are insanely useful and typeclasses are not a substitute.
02:44:50 <Peaker> wli, example?
02:45:16 <wli> ML for the Working Programmer has a bunch of fully functorial stuff.
02:45:27 <Peaker> No chance of a simple example here?
02:45:41 <Peaker> wli, Why aren't type-classes a super-set of higher-order modules?
02:45:47 <wli> It's not been on the front burner.
02:45:56 <zygoloid> Peaker: because you can't build an instance at runtime based on runtime values
02:46:08 <wli> Peaker: Sharing constraints, signature matching, etc.
02:46:10 <zygoloid> (or at least not without evil oleg-style tricks)
02:46:10 <Peaker> zygoloid, ah. so wouldn't it make sense to add that?
02:46:26 <Peaker> zygoloid, I mean, extend type classes and not extend the module system
02:46:42 <Peaker> I wanted lexically scoped instances here and there :)
02:46:50 <zygoloid> yeah, i want that too
02:47:07 <wli> Peaker: It really doesn't make sense to do what module systems do with typeclasses. The namespace control etc. is not what typeclasses are meant for.
02:47:23 <Peaker> zygoloid, Yeah, I'm just wondering if extending the module system is a senseful place to add that functionality (seems to make language features more redundant to each other)
02:47:36 <Peaker> wli, don't we already have namespace control?
02:47:46 <wli> Peaker: Not like what higher-order modules do.
02:48:08 <Peaker> currently: Modules do Namespacing  and  Type-classes do overloading and a bunch of other stuff.   It sounds like higher-order modules are a lot closer to the latter?
02:48:18 <Peaker> than the former
02:48:37 <tolkad> PHP solved the namespace problem elegantly using backslashes. Haskell could switch from periods to backslashes
02:48:41 <wli> Higher-order modules are not conceptually like overloading.
02:48:51 <tolkad> there is a builtin . function so backslashes might make more sense
02:49:30 <zygoloid> @type (\\)
02:49:31 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
02:49:40 <Heffalump> ivanm: re Suitable, what exactly do you mean by "putting the constraint in RFunctor/RMonad"?
02:49:55 <Heffalump> the idea is to abstract over what the constraint is for any given container
02:50:08 <ivanm> well, not having to have "(Ord a) => RFunctor Set a", etc.
02:51:08 <tolkad> @type (\)
02:51:09 <lambdabot> parse error on input `)'
02:51:13 <tolkad> see? no \ function
02:51:20 <ivanm> yes, we know
02:51:25 <wli> Just because encodings can be done doesn't mean the language features are redundant.
02:51:38 <ivanm> \ on its own is not a defined operator (and probably isn't a valid one)
02:52:01 <tolkad> @let \ x = x
02:52:01 <lambdabot>   Parse error: Backslash
02:52:04 <zygoloid> > let (\=) = (/=) in 4 \= 5
02:52:05 <lambdabot>   True
02:52:11 <Heffalump> wel, you could only write that for instances
02:52:28 <Heffalump> whereas I wanted something that was really a precondition for the *class* - they have fundamentally different effects
02:52:29 <tolkad> > return (5)
02:52:30 <lambdabot>   No instance for (GHC.Show.Show (m t))
02:52:30 <lambdabot>    arising from a use of `M3368090839...
02:52:46 <tolkad> it should just say (IO (5))
02:52:51 <zygoloid> Foo\=Bar would still be ambiguous
02:52:59 <wli> The important part is the "software engineering" use of it, not the compiler doing some kind of intermediate representation or whatever.
02:53:15 <Blkt> good day everyone
02:53:17 <tolkad> > sqrt
02:53:18 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
02:53:18 <lambdabot>    arising from a use of `...
02:53:32 <tolkad> > (5 `sqrt`)
02:53:33 <lambdabot>   2.23606797749979
02:53:55 <ivanm> Heffalump: yup, fair enough
02:54:05 <ivanm> any particular reason for not having the type family be inside the class though?
02:54:10 <zygoloid> wli: yeah. fundeps and type classes are equivalent, and type classes are a superset of GADTs, but i have a module here which uses all three :)
02:54:11 <tolkad> @let g x = `x`
02:54:11 <lambdabot>   Parse error: BackQuote
02:54:31 <Peaker> wli, If higher-order modules aren't about overloading (instances with runtime parameters) what are they about?
02:54:34 <zygoloid> s/type classes/type families/ d'oh
02:54:36 <wli> zygoloid: Type families?
02:54:40 <zygoloid> yeah :)
02:54:48 <zygoloid> sorry, i just woke up
02:54:59 <Peaker> zygoloid, Fundeps are more directly redundant to type families aren't they?
02:55:08 <tolkad> > let g f x = x f in g 5 sqrt
02:55:09 <lambdabot>   2.23606797749979
02:55:10 <Peaker> zygoloid, How are type-classes a superset of GADTs?
02:55:14 <wli> Peaker: Actually mostly compile-time parameters, but runtime parameters can be done also, I suppose.
02:55:23 <Peaker> zygoloid, also, how are type classes are fundeps equivalent?
02:55:40 <zygoloid> Peaker:  < zygoloid> s/type classes/type families/
02:55:51 <Peaker> wli, I admit I speak of ignorance, but I have yet to see the utility of higher-order modules beyond adding runtime parameterization to type-class instances
02:56:00 <Peaker> zygoloid, ah, Why use both type families and fundeps?
02:56:16 <Peaker> zygoloid, I would hope fundeps get phased out in favor of families
02:56:24 <zygoloid> Peaker: using a fundep was just a little clearer in one case.
02:56:26 <wli> Peaker: Modules are pieces to be manipulated like data structures / functions / etc.
02:56:40 <zygoloid> (my type class was much more a relation than a type function)
02:56:43 <Peaker> wli, I heard the comparison of OO "objects" with "modules"
02:57:13 <wli> Peaker: It's bullcrap. OO objects need module systems around them like everything else.
02:57:52 <Peaker> wli, I see the need for modules as a namespace mechanism. I don't understand why more things need to be attached to that
02:59:58 <wli> I'm a lousy debater. I don't have ready examples. I don't have sources to cite. I don't have anything.
03:01:10 <Heffalump> Peaker: explicit instance control?
03:01:13 <zygoloid> Peaker: i'm reading this, might be relevant: http://www.cis.upenn.edu/~bcpierce/FOOL/papers9/shields.pdf
03:01:51 <Peaker> Heffalump, I wouldn't want that
03:02:06 <Peaker> Heffalump, I like some of the guaranteed type-class invariants
03:02:31 <Peaker> zygoloid, thanks
03:02:54 <wli> Modules are another level. You need the control at the level above terms for the software engineering stuff.
03:05:40 <zygoloid> wli: that paper i pasted a link to argues that you don't
03:05:57 <wli> A lot of it is pretty dumb. Pass a module as a parameter to control some back-end implementation. etc.
03:06:03 <zygoloid> (or at least that's my reading of it)
03:06:47 <wli> zygoloid: It's a horrendous mistake to unify the module and term languages.
03:06:56 <zygoloid> wli: why?
03:07:14 <Peaker> wli, I do a lot of software engineering with Haskell right now, and I don't feel type-class weaknesses or the module system are a major problem..
03:07:25 <wli> Because the whole point of a module language is a sort of metaprogramming.
03:07:55 <Peaker> wli, Why pass a module and not a normal record, or polymorphic instance?
03:08:07 <zygoloid> i'm with Peaker. the only hole i'd like filled is that if i have something :: (forall a. C a) => F a, then i want to be able to generate my own C a based on values i have locally
03:08:31 <wli> Peaker: Because you can't pass instances as parameters to anything in any way that makes sense and records are terms.
03:09:12 <wli> Peaker: Records being terms means the data types (and other term/etc. language constructs) can't go with them.
03:09:36 <Peaker> wli, Well, I can't pass instances as parameters, but almost all classes have the type in "positive positions" so you can just make a parameterized data constructor that forms a parameterized instance
03:09:37 <Heffalump> peaker: http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html
03:09:46 <zygoloid> wli: please read that paper i posted a link to, it suggests a solution to that
03:09:50 <Heffalump> ivanm: have the type family inside which class?
03:10:25 <wli> zygoloid: Writing by hand what compilers should be spitting out in their IR's is not an answer to anything except how to make yourself miserable.
03:11:17 <ivanm> Heffalump: the Suitable class
03:13:20 <Heffalump> which family then, then?
03:13:26 <Heffalump> s/then, //
03:13:34 <ivanm> Constraints
03:14:04 <Heffalump> oh, I see. Errm, dunno :-) I vaguely remember considering it.
03:14:06 <wli> Heffalump's citing augustss' blog is better.
03:14:34 <Peaker> Heffalump, that's a nice link
03:14:49 <Heffalump> read the follow up entries too, the situation isn't quite as bleak as his original post suggests
03:15:09 <Peaker> Heffalump, Yeah, even I have ideas on how to improve on his attempts, which seems weird, augustuss is a huge guru :)
03:15:24 <Heffalump> modules definitely do stuff type classes don't. The problem is there's so much overlap that it's difficult to see how they should be added without making a nasty mess.
03:16:46 <wli> I think the overlap is overestimated.
03:17:17 <wli> Now, nasty mess is very well possible. Overlap is not that big a deal.
03:17:32 <Heffalump> ivanm: hmm. It does look like it'd be nicer that way. I wish I could remember why I didn't do it.
03:17:49 <zygoloid> wli: there is such a thing as too much syntactic sugar. basically it seems to me that while a functorial module system is a well-explored point in the design-space, giving us the tools to build our own module system may allow even better solutions to some problems.
03:17:55 <ivanm> Heffalump: heh
03:18:25 <zygoloid> wli: i'm also interested in finding out exactly where current Haskell falls short, since it's not clear to me where the holes are currently.
03:19:14 <zygoloid> (a grand unified separate module system would mean we'd be less likely to get useful new term-level features afaics)
03:19:38 <wli> Actually functorial module systems aren't all that common and there's not all that much exploration going on that I know of.
03:20:01 <wli> zygoloid: Dare I ask how a module system is supposed to retard the progress of term-level features?
03:20:29 <Peaker> wli, I think overlap is a big deal: It causes people to implement identical things multiple times, often in incompatible ways
03:20:30 <zygoloid> wli: in comparison to implementing the needed features at the term-level, you ... umm ... don't get the needed features at the term level
03:21:54 <wli> We're speaking at cross purposes or something.
03:22:45 <zygoloid> wli: ultimately my concerns are that 1) it's clear what the new features are, and that 2) they're composable with the existing features
03:23:30 <zygoloid> saying "don't do it at the term level" seems to violate the second of these goals
03:24:01 <wli> They're not composable with existing features. The features don't exist to be composed with.
03:24:18 <Peaker> Heffalump, The amount of spam in there is terrifying
03:24:19 <zygoloid> i'm confused. how can existing features not exist?
03:24:59 <wli> There's no oxymoron. The features are absent. They're not existing features.
03:25:26 <zygoloid> the new features are absent, but we have plenty of existing features. like type classes, type families, GADTs, records
03:25:49 <wli> Which are not module systems.
03:26:15 <zygoloid> *sigh* no, but i want them to be composable with any newly-added features, like a module system
03:27:32 <wli> Namespace control etc. Maybe typeclasses/instances need to be a bit less "open world" to do it.
03:28:08 <wli> (Well, "open world" garbage is a disaster anyway.)
03:28:17 <zygoloid> i don't see that haskell has a namespace control issue
03:29:10 <wli> I'm tearing my hair out over here. It's difficult to describe it in polite terms.
03:30:04 <zygoloid> wli: i'm sorry i'm being dense :( but it's not clear to me what specific things haskell (with current GHC extensions) is missing
03:30:38 <zygoloid> and saying "it's missing a whole new language" seems wrong
03:30:49 <zygoloid> or at least unhelpful
03:31:03 <msieradzki> it's not clear for a newcomer which extensions to use
03:31:04 <msieradzki> and why
03:31:39 <wli> I've had 12 years to figure it out and I've figured out there are no useful equivalents.
03:31:46 <zygoloid> msieradzki: the answer, to a great extent, is "it depends"
03:32:07 <msieradzki> the obvious namespace problem (not the one that wli is talking about probably) is data A = A { a::Int, b::Int} data B = B { a::Int, b::Int} A.a vs B.a
03:32:17 <msieradzki> I'm either missing something stupid
03:32:27 <msieradzki> or Haskell is missing really stupid syntactic sugar for selectors
03:32:32 <wli> You can "simulate" it with unmaintable garbage, but anyway.
03:32:43 <msieradzki> I can use qualified import I guess
03:32:51 <Saizan> yup
03:32:53 <msieradzki> not that I want to explicitly type :)
03:32:54 <zygoloid> msieradzki: qualified import gives you exactly A.a and B.a
03:33:04 <msieradzki> type it*
03:33:51 <zygoloid> msieradzki: sadly you can't do the same thing for records, but that's because the types of the field selector functions conflict, and in any case would hurt type inference a lot
03:35:25 <Saizan> zygoloid: unless you define them in different modules :)
03:35:31 <Peaker> msieradzki, I thought about that and maybe GHC could auto-instance records to automated (anonymous) classes like:  auto-class HasA i r where a :: r -> i ; auto-instance HasA Int A
03:35:31 <wli> It's pretty frustrating. "How do you not get this?" etc.
03:35:37 <zygoloid> Saizan: haha yeah :)
03:35:56 <Peaker> msieradzki, So all record fields are actually polymorphic accessors for automatically generated classes of which all records are automatically instances.. A bit messy maybe :)
03:36:05 <zygoloid> wli: perhaps because i've never seen the "better world" where the solution is present. an example of a current problem would be helpful.
03:36:15 <Peaker> wli, I find my Haskell code maintainable and scales up pretty well in complexity :)
03:36:40 <Peaker> wli, maybe we have different preferences for what abstractions we like to use
03:36:43 <Saizan> with nested modules (which could be desugared away with simple enough semantics) it wouldn't even be so cumbersome
03:36:49 <wli> Peaker: You've never seen the "better world" either, have you?
03:37:02 <Peaker> wli, What "better world"? SML/OCaml?
03:37:13 <Peaker> wli, I tried to look, but the lack of type-classes made the tutorials unbearable :)
03:37:25 <Peaker> (+) vs (+.) etc
03:37:26 <wli> Peaker: Well, to the extent they have higher-order modules etc.
03:37:38 <ivanm> ugh, haskell-src-exts is spitting out "Ambiguous infix expression" errors :s
03:37:43 <ManateeLazyCat> Text terminal is enough for you? I'm use gtk2hs developing a terminal.....
03:37:55 <wli> Peaker: Their term languages leave something to be desired.
03:38:11 <ManateeLazyCat> Since graphics terminal maybe need long time to test, so i want provide a "text terminal" first...
03:38:31 <nus> graphics terminal?
03:38:43 <ManateeLazyCat> nus: You can display image in it.
03:38:57 <nus> oh
03:39:27 <Peaker> ivanm, Yeah, I just went to report an hlint bug about that today! And discovered it was already reported. Apparently it doesn't seem to catch fixity behind imports
03:39:44 <ManateeLazyCat> nus: You can install w3m w3m-img, and running w3m in gnome-terminal, you will see image in temrinal... :)
03:39:47 <ivanm> oh? can you give me an example where it occurs?
03:40:00 <ivanm> or how?
03:40:02 <Peaker> ManateeLazyCat, I'd love to see a graphical terminal emulator that renders speedily.. my console GUI is *slow* in xterm/rxvt/etc. It's fast in Apple's terminal emulator and in the real console
03:40:18 <ivanm> (so that I can then go and remove that bit from my code so that SourceGraph will work on it properly)
03:40:34 <ManateeLazyCat> Peaker: I plan to develop a MVC "Graphics temrinal" with gtk2hs.
03:40:42 <ManateeLazyCat> Peaker: Render by Cairo/Pango.
03:40:43 <Peaker> ivanm, http://code.google.com/p/ndmitchell/issues/detail?id=302&q=proj:HLint&colspec=ID%20Status%20Proj%20Summary%20Priority%20Stars
03:41:09 <ManateeLazyCat> Peaker: That's report by me. :)
03:41:13 <Peaker> ManateeLazyCat, Well, don't re-render the entire screen expensively after every stdout :)
03:41:20 <ivanm> OK, I'm still confused about what causes that bug
03:41:43 <Peaker> ManateeLazyCat, "Ambiguous infix expressions cause statement not to be fixitied (blocked on HSE)" ?
03:42:08 <ManateeLazyCat> Peaker: My report at "Another example: ... "
03:42:21 <nus> ManateeLazyCat, wouldn't that require some mark-up language for the (graphical) terminal?
03:42:35 <Peaker> ManateeLazyCat, did ndmitchell copy all these from a different tracker? It says "ndmitchell" said on all of them
03:42:36 <ManateeLazyCat> nus: Pango can do that. :)
03:43:09 <ManateeLazyCat> Peaker: I think someone has report this bug when i report to Neil. 
03:43:12 <ManateeLazyCat> Peaker: Same as you.
03:43:16 <Peaker> ManateeLazyCat, what's with each terminal emulator having it's own encodings for keyboard keys?
03:44:56 <ManateeLazyCat> Peaker: Because terminal has many different type, such as vt100, vt52..... so it's encoding different....
03:45:20 <ManateeLazyCat> Peaker: My temrinal is base on Cairo/Pango, and support Unicode.
03:45:38 <ManateeLazyCat> Peaker: Maybe i need send some patch to gtk2hs when i implement it.
03:46:13 <ManateeLazyCat> Peaker: In gnome, Cairo can render by Hardware, so render is fast.... :)
03:46:54 <Peaker> ManateeLazyCat, I mean each one sends different binary sequence for keys like "Alt-f1" -- I don't think vt* define them?
03:46:58 <ivanm> Peaker: ugh, I figured "I'll find where the error is using hlint..." then realised after I opened every damn file and ran hlint on it that ndm had done a workaround :@
03:48:25 <ManateeLazyCat> Peaker: You mean handle different encoding "send string" to shell? 
03:49:03 <ivanm> Peaker: any idea on how I can test which part of my source is causing the problem?
03:49:16 * ivanm should work-around this in SourceGraph as well, but can't be bothered atm
03:49:42 <ManateeLazyCat> Peaker: I found Neil's reply, he said it's need help from the haskell-src-ext
03:52:20 <ivanm> Peaker: so, does that bug come up when you use more than one $ ?
03:52:27 <ivanm> or just any infix operators?
03:54:04 <ManateeLazyCat> ivanm: I think that's bug can fix by add parentheses.
03:54:39 <ManateeLazyCat> Peaker: BTW, your console GUI is fast in gnome-terminal or other vte base terminal ?
03:57:53 <ivanm> ManateeLazyCat: yeah, but the question is _where_ :s
03:58:16 <ManateeLazyCat> ivanm: Last $
03:58:39 <ManateeLazyCat> ivanm: When you add too many $ after `bla` will cause that problem
03:58:39 <ivanm> well, I don't seem to use more than one $ per line
03:59:03 <ivanm> might be interaction between $ and >>
03:59:48 <ivanm> nope, that wasn't it
04:00:08 <Peaker> ManateeLazyCat, It's faster in gnome-terminal
04:00:17 <Peaker> gotta go
04:00:27 <ManateeLazyCat> Peaker: Like my guess, it's because Cairo engine.
04:02:31 <ManateeLazyCat> ivanm: After yesterday discuss, now i have better idea how to design hot-swapping engine.... :)
04:04:16 <ManateeLazyCat> ivanm: Example, you can hot-swapping browser after touch browser code, but any other module (such as editor, file-manager) still running..
04:07:21 <Heffalump> ivanm: ah, found the reason:
04:07:37 <Heffalump> Wed Mar 18 19:26:00 GMT 2009  Ganesh Sittampalam <ganesh@earth.li> * lift Constraints out of Suitable and make it only indexed on the container type
04:08:02 <kau> Hello!
04:08:06 <ivanm> Heffalump: what benefit does that give you?
04:08:13 * ivanm waves idly in kau's general direction
04:08:23 <ivanm> ManateeLazyCat: hmmm...
04:08:50 <kau> Do you know how to catch efficiently/cononicaly read exceptions?
04:08:56 <kau> hello ivanm
04:09:16 <Heffalump> it means that you can deduce the Constraints type just from the container, and don't need to know the element type. Makes resolution work better.
04:09:29 <Jafet> kau: you want to catch exceptions, using Control.Exception?
04:09:47 <kau> i tryed catch but the exception seems not to be cautgh
04:09:59 <ivanm> you have to specify the type of exception to be caught
04:10:11 <ivanm> Heffalump: aha
04:10:27 <ivanm> but in practice, don't you dep on the class anyway?
04:10:38 <kau> what is the name of the exception, in the case of read no parse?
04:11:08 <kau> can't find it
04:11:14 <ivanm> oh, that's a bit of a different case
04:11:20 <ivanm> in that case, you want to do your reading differently
04:11:24 <ivanm> use reads or something
04:11:26 <ivanm> @type reads
04:11:27 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:11:40 <ivanm> > reads "1a" :: [(Int, String)]
04:11:41 <lambdabot>   [(1,"a")]
04:11:45 <kau> i tryed reads too
04:12:38 <Heffalump> ivanm: I think it worked out nicer when writing code, especially when working with monad transformers. I can't entirely remember though.
04:13:26 <kau> but i try to test if the list is empty and the compiler tells me that the type variable Exception is ambiguous
04:14:05 <kau> let me give you an exemple
04:15:36 <kau> let f = if not . null $ reads "" then return $ reads "" else f
04:15:42 <kau> > let f = if not . null $ reads "" then return $ reads "" else f
04:15:42 <lambdabot>   not an expression: `let f = if not . null $ reads "" then return $ reads ""...
04:16:11 <kau> that tells me Ambiguous type variable `a1' in the constraint: `Read a1' arising from a use of `reads'
04:16:29 <kau> How can i fix that??
04:17:32 <slom> kau: add a type annotation
04:17:53 <kau> > let f s = if not . null $ reads s then return $ reads s else f s
04:17:54 <lambdabot>   not an expression: `let f s = if not . null $ reads s then return $ reads s...
04:18:08 <kau> slom: what is that?
04:19:07 <kau> and why can't i catch the exception "no parse"?
04:19:50 <slom> kau: what should the return type of f be?
04:20:17 <kau> f is something like (Read a) ⇒ String →  IO a
04:21:48 <kau> in my code, this is a function that ask the user for an integer, and is the read fails, it asks again ;)
04:23:34 <ivanm> Heffalump: fair enough
04:23:47 <ivanm> Heffalump: in that case, however, is there any possibility of adding more docs? :p
04:26:16 <kau> i have:
04:26:28 <kau> > safeRead :: (Read a) ⇒ String →  IO a
04:26:29 <lambdabot>   Not in scope: `safeRead'
04:26:35 <kau> safeRead :: (Read a) ⇒ String →  IO a
04:26:44 <kau> safeRead s = do
04:26:49 <kau>    putStrLn $ s
04:26:56 <kau>    m ← getLine
04:27:02 <kau>    if (¬ $ null $ ((reads m) :: forall a∘Read a => [(a, String)] )) then return (fst $ head $ reads m) else safeRead s
04:27:11 <kau> is that correct?
04:28:40 <slom> kau: sorry for the slow responses ... my brain is working slowly due to the weather :(
04:29:54 <kau> no pb ;) that's kind of you
04:30:01 <kau> it's hot here too
04:35:11 <kau> hello? someone here?
04:35:25 <kmc> hi
04:35:32 <kau> hi
04:36:35 <hpc> i am not really familiar with the aliases for all your unicode, so i couldn't help
04:37:43 <kau> Sorry, this is leksah. ⇒ is =>,  → is ->, ¬ is not, ∘ is .
04:37:57 <slom> kau: I think 'read' is the wrong approach here
04:38:20 <slom> I doesn't seem to allow to catch the error ....
04:38:31 <kau> how would you do?
04:38:56 <slom> good question :)
04:39:31 <kau> i've searched around with no success. That's pretty a simple problem though
04:40:03 <ManateeLazyCat> Haha, i found http://vt100.net/
04:41:07 <hpc> that's a handy reference
04:42:36 <kau> in my function above, is the type variable 'a' accessible for the rest of the code?
04:43:31 <slom> kau: try readIO
04:43:40 <hpc> :t readIO
04:43:41 <lambdabot> forall a. (Read a) => String -> IO a
04:44:01 <hpc> :t read'
04:44:02 <lambdabot> Not in scope: `read''
04:44:21 <kau> ho, i'll try that
04:45:36 <kau> Wow, it seem to be good
04:46:51 <kmc> to read with failure, use reads
04:46:52 <kmc> :t reads
04:46:52 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:48:28 <kmc> :t listToMaybe . map fst . reads
04:48:29 <lambdabot> forall a. (Read a) => String -> Maybe a
04:49:59 <hpc> i prefer to extract from reads by matching against [(a, "")], myself
04:50:32 <kmc> yeah
04:54:30 <slom> > safeRead p = do {putStrLn p; catch readLn (\ _ -> safeRead prompt)}
04:54:30 <lambdabot>   <no location info>: parse error on input `='
04:55:59 <slom> safeRead :: (Read a) => String -> IO a
04:56:00 <slom> safeRead p = do {putStrLn p; catch readLn (\ _ -> safeRead p)}
05:02:12 <paczesiowa> hello, I have a problem with utf8 file reading, this "System.IO.UTF8.readFile file >>= System.IO.UTF8.putStr" throws an exception on the first utf8 character "commitAndReleaseBuffer: invalid argument (Invalid or incomplete multibyte or wide character)"
05:02:12 <lambdabot> paczesiowa: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:04:42 <Saizan> paczesiowa: on ghc-6.12+ you should probably use System.IO and set the TextEncoding (or let it default to your locale)
05:05:07 <kau> slom: it works just fine. thank you. 
05:05:34 <kau> slom: but i have to use the catch from Prelude, the one from Control.Exception won't work.
05:09:14 <slom> kau: I will imediatly reward myself with some ice-cream :) cu later 
05:12:04 <kau> ++
05:13:44 <paczesiowa> Saizan: is there anything else that could affect this behaviour? it works on one machine but fails on the other (same binary, same locales) 
05:14:42 <Saizan> paczesiowa: same file?
05:14:54 <Saizan> paczesiowa: same OS?
05:15:52 <paczesiowa> Saizan: 2*yes
05:18:09 * Saizan can't think of anything else
05:18:36 <Saizan> http://ghcmutterings.wordpress.com/2009/09/30/heads-up-what-you-need-to-know-about-unicode-io-in-ghc-6-12-1/ <- might help though
05:19:48 <wli> There are all these fantastic monad transformers and none are used in substantial ways by the libraries. Oh, and fail in Monad
05:27:49 <paczesiowa> Saizan: what locale settings do you use?
05:27:49 <paczesiowa>  
05:30:56 <jacobian> paczesiowa: I'm having a similar problem
05:31:15 <jacobian> paczesiowa: If I change locale to C, then I get that error for lhs2Tex
05:33:18 <Saizan> paczesiowa: en_US.utf8
05:35:43 <ivanm> Yay! found the cause of the parsing problem!
05:37:05 <paczesiowa> ok, explicit setting utf8 encoding on handles solves the problem, too bad it's not my code (BlogLiterately)
05:39:44 <Saizan> i guess someone should put up a release of utf8-string that Does The Right Thing on ghc-6.12+
05:48:46 * hackagebot darcs-beta 2.4.98.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.4.98.1 (ReinierLamers)
05:59:54 <ski> @let listToMonadPlus :: MonadPlus m => [a] -> m a; listToMonadPlus = foldr (mplus . return) mzero
05:59:55 <lambdabot>  Defined.
06:00:20 <ski> @let readM :: MonadPlus m => ReadS a -> String -> m a; readM reads s = do (a,"") <- listToMonadPlus (reads s); return a
06:00:21 <lambdabot>  Defined.
06:01:36 <ski> @let readMaybe :: Read a => String -> Maybe a; readMaybe s = case reads s of [(a,"")] -> Just a; _ -> Nothing
06:01:37 <lambdabot>  Defined.
06:01:47 <ski> (that latter ought to use `MonadZero', really)
06:02:38 <wli> O, for 1.4's library sanity
06:05:05 <Twey> Ick
06:05:51 * Twey doesn't like do-blocks for pattern-matching ☹
06:09:53 <ski> Twey : you'd prefer an explicit call to `mzero', there ?
06:11:44 <ivanm> hooray! with the updates for FGL I've made, my multiple edges now work in SourceGraph! http://code.haskell.org/~ivanm/Sample_SourceGraph/SourceGraph/graphs/codeCore.svg
06:11:49 <Twey> No, it's nicer to use the do for the error-handling, but I find myself wanting to just write fst <$> listToMonadPlus (reads s)
06:12:03 <ski> but that's not the same thing
06:12:05 <Twey> Indeed
06:12:16 <ivanm> now they're just a bit _too_ obvious, especially in the getExp -> maybeEnt one :s
06:12:29 * ivanm isn't sure what's with the bit on the getExp end
06:13:26 <ivanm> oh, that's a loop
06:13:39 <ivanm> of width 32 (as opposed to width 7 going to maybeEnt)
06:18:14 <ski> @type liftM fst . (runKleisli . second . Kleisli) (guard . null) <=< listToMonadPlus . reads
06:18:15 <lambdabot> forall a (m :: * -> *). (MonadPlus m, Read a) => String -> m a
06:18:27 <ski> Twey : i suppose something like that is possible ..
06:18:43 <ski> (not really that obvious or readable, though)
06:21:17 <chrisdon`> i very rarely use patterns in a do bind
06:22:41 <chrisdon`> i'd prefer it if do patterns weren't even supported, and instead binding to a case statement was instead
06:22:53 <kmc> how would that look?
06:23:42 <ivanm> like magic!
06:24:14 <chrisdon`> same as `let':
06:24:14 <chrisdon`> do let foo = bar
06:24:14 <chrisdon`>    case m
06:24:14 <chrisdon`>      Just x -> foo
06:24:17 <chrisdon`>      Nothing -> bar
06:24:20 <chrisdon`>  
06:26:25 <ivanm> do you mean to have that case statement as part of the let?
06:26:26 <chrisdon`> avoids partial patterns and makes it easier to do a proper case
06:26:41 <ivanm> because you can already do that, cna't you?
06:26:43 <chrisdon`> no, forget the let. i put the let to show how monadic let differs from pure let in missing the keyword
06:27:09 <ivanm> oh, you mean extract the value from the monad?
06:27:14 <chrisdon`> yeah
06:27:24 <ivanm> so it's equivalent to m >>= \ x -> case x of ... ?
06:27:27 <chrisdon`> do v <- m
06:27:27 <chrisdon`>   case v of ... 
06:27:32 <chrisdon`> yeah
06:27:37 <ivanm> hmmm...
06:27:44 <ivanm> I'd prefer we have anonymous case statements
06:27:47 <mauke> but I like partial patterns
06:27:56 <ivanm> then you could just do m >>= case of ... directly
06:28:18 <chrisdon`> but then it's breaking the do style
06:28:33 <mauke> your example isn't parseable
06:28:38 <chrisdon`> anonymous case statements would be nice though
06:28:48 <ivanm> mauke: well, whatever the syntax would be
06:29:14 <kmc> hmm i like "m >>= case of"
06:29:30 <kmc> because we want "case of" anyway
06:29:43 <chrisdon`> doesFileExist >>= case of True -> ..
06:30:07 <kmc> if you want further sugar for "m >>= case of" i think it needs to be more distinct than "case m".  perhaps "case <- m"
06:30:24 <kmc> (i love the smell of bikesheds in the morning)
06:30:59 <chrisdon`> that's alright yeah
06:32:16 <Jafet> kmc: they're not even painted yet!
06:33:00 <kmc> any colour you like
06:33:19 * ski sighs
06:33:39 <kmc> would also be nice to elect one branch of the "case" to continue at the same nesting/indent level as the outer "do"
06:33:49 <ski> (.. this is one case where monadic reflection would be great, imo)
06:34:10 <kmc> case <- m { Nothing -> error "urk"; Just x -> .. }; print x
06:34:15 <kmc> that's kinda wacky though
06:34:35 <kmc> monadic reflection?
06:34:57 <mauke> I'd prefer something where I can use layout
06:34:59 <ski> well, rather a syntax i've been trying to invent for it
06:35:49 <ski> kmc : basically a limited form of side-effects (and i don't mean dropping purity, here)
06:36:54 <ski>   m :: IO (Maybe String)
06:37:13 <ski>   [< m >] :: Maybe String  -- with `IO'-side-effects
06:37:42 <ski>   case [< m >] of Nothing -> ...; Just s -> ..s.. :: Frob  -- with `IO'-side-effects
06:37:58 <ski>   [> case [< m >] of Nothing -> ...; Just s -> ..s.. <] :: IO Frob
06:38:27 <ski> in between `[>' and `<]', we are using something that looks a bit like Haskell, but which has `IO'-side-effects (in this case)
06:39:13 <ski> each side-effect is marked by `[<' and `>]', so you visually can spot them easily (and you know that if you swap the order, it needn't be the same)
06:39:38 <Jonno_FTW> is it better practice to use $ or parantheses when defining a functions arguments?
06:39:52 <Jonno_FTW> do I use: fromRoman x = fromRoman' 0 (toArab x)
06:39:59 <Jonno_FTW> or fromRoman x = fromRoman' 0 $ toArab x
06:40:01 <ski> also, if you call an ordinary Haskell function `foo' inside there, it can't perform any side-effects by itself .. you are required to use `[>' and `<]' somewhere in a function body if you use this feature
06:40:12 <ski> kmc : that's the basic idea
06:40:13 <mauke> fromRoman = fromRoman' 0 . toArab
06:40:20 <Jonno_FTW> oh right
06:40:39 <ski> (i have notes with type system rules, and translation rules for implementing this .. but it's not fully worked out yet)
06:41:42 <Jonno_FTW> and one last thing, what is wrong with my fromRoman' pattern match? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27314#a27314
06:43:13 <hpc> you aren't accumulating your result, i think
06:43:33 <mauke> Jonno_FTW: uh, nothing?
06:43:33 <hpc> you want to be recursing with (a+x), not just x
06:43:39 <hpc> or y-x
06:43:46 <Jonno_FTW> that makes sense
06:43:56 <hpc> so if you give it LI, it returns 1, not 51
06:45:38 <Jonno_FTW> thanks
06:46:01 <Jonno_FTW> now I get a type error
06:49:46 <hpc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27314#a27315
06:50:11 <hpc> you didn't remove the parameter from fromRoman when you changed it to pointfree
06:50:27 <hpc> and you were missing a pattern for a list with one element, which you need when you are folding like that
06:51:05 <hpc> there's still a logic error in there somewhere
06:51:12 <hpc> III == 2
06:52:22 <Jonno_FTW> oh right
06:53:09 <hpc> oh, i forgot to accumulate a
06:53:23 <hpc> add that in there and it will work
06:54:14 <Jonno_FTW> how does III = 2?
06:54:25 <mauke> logic error
06:56:29 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27314#a27316
06:56:38 <Jonno_FTW> I fixed it up but now I get a type error
06:56:59 <mauke> better not tell us the error, otherwise we might be able to fix it
06:57:01 <Jonno_FTW> nvm I tested it wrong
07:01:36 <ivanm> mauke: heh
07:01:48 <ivanm> @remember mauke better not tell us the error, otherwise we might be able to fix it
07:01:48 <lambdabot> It is forever etched in my memory.
07:10:42 <hpc> by the way, in haskell, just about everything is a type error
07:10:53 <hpc> so just saying "type error" doesn't give us much direction
07:10:55 <ivanm> ummm.... wtf?
07:11:30 <hpc> s/everything/every mistake/
07:13:57 <ivanm> nah, it's still possible to have logic errors
07:13:58 <ivanm> loops
07:14:01 <ivanm> binding problems
07:14:03 <ivanm> parsing problems
07:14:04 <ivanm> etc.
07:14:14 <ivanm> but they are the most _common_ mistake, I'll admit
07:14:18 <Jonno_FTW> I think my new code is a practices error
07:14:24 <Jonno_FTW> *best practices
07:15:08 <Jafet> In agda, you can make partialness a type error
07:20:19 <hpc> @seen mreh
07:20:19 <lambdabot> Unknown command, try @list
07:28:08 <Saizan> preflex: seen mreh
07:28:08 <preflex>  mreh was last seen on #haskell 4 hours, 48 minutes and 16 seconds ago, saying: higher-order modules?
07:30:02 <hpc> ty
07:41:55 <greygjhart> hello there
07:42:44 <greygjhart> I'd like to know where to learn things about file inclusions
07:42:56 <mauke> a C channel?
07:43:14 <greygjhart> can someone help ? I cannot find the documentation
07:43:49 <mauke> about what?
07:44:24 <greygjhart> about compiling several files, declaring variables somewhere and using them in another file
07:44:35 <Jonno_FTW> ghc docs have that
07:44:51 <mauke> is this about haskell?
07:45:19 <greygjhart> yeah of course ! Why would I ask here if not ?
07:45:55 <Lemmih> greygjhart: You'd be surprised the kind of questions people ask here.
07:46:09 <mauke> because Haskell has no "file inclusion", and people have asked java and php questions here
07:46:10 <greygjhart> ^^ ok
07:46:18 <greygjhart> sorry
07:46:36 <greygjhart> I'm a complete newbie to haskell
07:46:45 <EvanR> haskell advice has got to be some of the least applicable possible for php
07:46:53 <greygjhart> but @ least Im im the right place
07:47:06 <Lemmih> greygjhart: Haskell has a module system. You go 'module X where' in one file and 'import X' in another.
07:47:16 <greygjhart> so you said no file inclusion
07:47:22 <greygjhart> that's why
07:47:23 <greygjhart> ok
07:48:11 <Lemmih> greygjhart: The file name has to match the module name, btw.
07:48:14 <greygjhart> is that appropriate to write a config file with only variables, and import that in a main file ?
07:48:22 <greygjhart> of course
07:48:40 <greygjhart> and how about compiling ? ghc -c ?
07:48:44 <mauke> that doesn't really sound like a config file
07:48:47 <EvanR> i tried that config file module thing, and it is a hassle if you intend on changing those values
07:48:47 <Lemmih> greygjhart: ghc --make
07:48:55 <EvanR> better make a real config file
07:49:07 <mauke> the point of having a separate config is so you can make changes to it without recompiling the program
07:49:24 <greygjhart> no not a config file - a fake one, with params compiled hard into it
07:49:36 <greygjhart> it's not meant to change often
07:49:51 <EvanR> then its like C defined constants
07:49:56 <greygjhart> but rather to be set an compiled before execution
07:50:32 <greygjhart> yeah sort of
07:50:53 <greygjhart> would a module work here ?
07:50:58 <EvanR> yes
07:51:09 <EvanR> a module of constants
07:51:39 <greygjhart> great - then I think I'll RTFM and bother you again when I'm done : )
07:51:46 <hpc> i think that's pretty common practice, actually
07:51:56 <greygjhart> thanks for help
07:52:01 <greygjhart> thanks a lot
07:55:42 <tone12345> What is the best book in Haskell for a person who never program in a functional language?
07:56:15 <Jonno_FTW> tone12345: 'Learn you a Haskell' is a good starting point
07:56:25 <Jonno_FTW> or Real World Haskell
07:56:45 <tone12345> and Programming in Haskell?
07:56:56 <Jonno_FTW> I've never read it
07:57:07 * ski thought "Haskell: The Craft of Functional Programming" was good
07:57:13 <aristid> tone12345: i haven't read Programming in Haskell, but Real World Haskell was quite good
07:57:32 <ski> there's probably people who would recommend "The Haskell School of Expression" as ell
07:57:35 <ski> s/ell/well/
07:57:41 <tone12345> ok, one more questions, wjy Haskell and not Scheme?
07:57:48 <hpc> scheme has mutable state
07:57:48 <ski> why not both !?
07:57:52 <hpc> or both
07:57:54 <EvanR> scheme is dynamically typed
07:58:19 <mauke> scheme looks like )))))))))))))
07:58:19 <ski> Scheme has continuations, and macros
07:58:32 <EvanR> @src ContT
07:58:33 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
07:58:38 <ski> mauke : your editor handles that
07:58:50 <mauke> ski: only in haskell
07:58:59 <hpc> mauke: haskell looks like (++) >>=(<$> (<*>))$(.)<<fmap
07:59:03 <hpc> :P
07:59:12 <ski> mauke : only what in haskell ?
07:59:15 <EvanR> much more interesting thatn )))))))))
07:59:15 <aristid> tone12345: oh sure, learn Scheme. go for it. it's not mutually exclusive, you can learn BOTH haskell and scheme!
07:59:32 <mauke> ski: $ and whitespace instead of explicit end markers
08:00:07 * ski is confused
08:00:47 <ski> for larger expressions, you need brackets anyway .. but i'm not sure what your point really was about
08:01:00 <aristid> :t ((++) >>=)
08:01:01 <lambdabot> forall m b. (Monoid m) => ((m -> m) -> m -> b) -> m -> b
08:01:25 <hpc> :t (<$> (<*>))
08:01:25 <lambdabot> forall b (f :: * -> *) a b1. (Applicative f) => ((f a -> f b1) -> b) -> f (a -> b1) -> b
08:01:29 <hpc> oh god
08:02:03 <wlangstroth> ski: you can use $ instead of parens: (x (y (z 1))), x $ y $ z 1
08:02:15 <wlangstroth> I think that's what he was getting at
08:02:15 <nus> @ty ($)
08:02:16 <lambdabot> forall a b. (a -> b) -> a -> b
08:02:19 <hpc> or you would do x . y . z $ 1
08:02:22 <EvanR> x . y . z $ 1
08:02:27 <wlangstroth> right
08:02:33 <nus> @ty (.)
08:02:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:02:37 <nus> heh
08:02:44 <nus> @ty Prelude.
08:02:45 <lambdabot> parse error (possibly incorrect indentation)
08:02:49 <nus> fsck
08:02:54 <Gertm> this is perhaps a stupid question, but why is a pattern for a list written as (x:xs) and not [x:xs] ?
08:03:09 <EvanR> [x:xs] is a list of lists
08:03:10 <ski> wlangstroth : and for `foo (bar (quux x) (\y -> frob (barf y (z ++)) x)) (baz (frotz x) (defrotz x))' ?
08:03:28 <sepp2k> It's written as x:xs, the parens are just for precedence. [x:xs] would be a list containing another list
08:03:31 <ski> Gertm : `x:xs' is a pattern for lists
08:03:33 <Jafet> Gertm: (:) is a list constructor
08:03:33 <mauke> Gertm: because [x] is the same as x : []
08:03:44 <mauke> so [x:xs] would be (x : xs) : []
08:04:05 <EvanR> oh
08:04:17 <ski> Gertm : `f x:xs' means `(f x):xs', however, so you need `f (x:xs)' if you want to pass `x:xs' as argument to `f' (regardless of whether this is to the left or to the right of `=' in a defining equation)
08:04:25 <benmachine> > case [1,3,4] of x:xs -> (x, xs)
08:04:26 <lambdabot>   (1,[3,4])
08:04:36 <benmachine> ^ parentheses not always required
08:04:37 <ski> @type (Prelude..)  -- nus
08:04:38 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:04:43 <Gertm> ski: I just reached that conclusion too here :) thanks for the clarification guys
08:05:06 <wlangstroth> ski: haha - refactor
08:05:13 <illissius> > let f x:xs = x in f [1..]
08:05:14 <lambdabot>   <no location info>: Parse error in pattern
08:05:19 <illissius> hm.
08:05:48 <illissius> what is it needed to disambiguate, er, against?
08:05:49 <ski> wlangstroth : sometimes a (not too) large expression is better than naming individual parts
08:07:02 <ski> > let Just x:xs = map (\x -> guard (even x) >> Just (x,x `div` 2)) [0..] in (x,xs)
08:07:03 <lambdabot>   ((0,0),[Nothing,Just (2,1),Nothing,Just (4,2),Nothing,Just (6,3),Nothing,Ju...
08:07:14 <wlangstroth> ski: yeah, I was kidding - I'm actually pretty comfortable with parens (via Lisp) so it's whatever reads easier for your team/workplace
08:07:53 <Lajla> Gertm, it is because Haskell has stupid syntax that uses infix notation, use Liskell instead.
08:08:13 <ski> illissius : if `f' is a constructor `Just', that is a pattern binding
08:08:29 <EvanR> > (+) 4 5
08:08:30 <Jafet> Liffkell? Whaffhat?
08:08:31 <lambdabot>   9
08:08:38 <Lajla> Jafet, liskell
08:08:44 <Lajla> Haskell in S-expression. \o/
08:08:56 <flippo> Oh boy.
08:08:59 <Jafet> Phaffenating.
08:09:16 <Lajla> All shall bow before the glory of sensible notation.
08:09:22 * Lajla bows before the glory of sensible notation
08:09:24 <ski> (and if you'd want `f' to be handled differently than `Just' here .. then you'd either need to handle precedence differently in patterns vs. expressions .. or you'd need to have strange precedences of constructor functions (so an application of one is now no longer an ordinary function application))
08:09:24 <EvanR> ok stallman
08:09:58 <Lajla> My beard is greyer and messier, your argument is invalid.
08:10:36 <illissius> ski: functions-are-lower-case, constructors-are-upper-case isn't enough then?
08:10:50 <wlangstroth> liskell! That's adorable.
08:11:06 <ski> illissius : see the parenthetical comment above
08:12:05 * ski idly wonders whether Liskell has hygienic macros ..
08:12:44 <flippo> ski, how deeply nested?
08:13:11 <flippo> (the parenthetical comment)
08:13:57 <ski> sorry ?
08:14:19 * Twey briefly considers writing FORTHaskell
08:14:53 <illissius> ski: hmm, ok. not really relevant to anything, just wondering
08:14:56 <Philippa> is that forth in haskell, haskell in forth, a forth front end for haskell, or what?
08:15:05 <Philippa> *reads up*
08:15:17 <Twey> Haskell with FORTHy syntax, to parallel Liskell.
08:15:27 * Lajla halaa tweyn
08:16:03 * ski has pondered writing a concatenative language which allows definition by pattern-matching, something like `: nil length = 0 | cons length = drop length 1 + ;'
08:16:05 <Lajla> Twey, this logician I know has the hypothesis that Japanese grammar expressed in S-expressions would effectively inverse the sentence, do you agree?
08:16:21 * Lajla has pondered eating ski.
08:16:21 <Twey> Maybe
08:16:29 <Twey> There are some corner cases
08:16:39 <Lajla> Twey, such as?
08:17:09 * ski ponders getting some habanero to spice up Lajla's impending meal
08:17:26 <p_l> Lajla: then never try to put a japanese song into a S-expression
08:17:36 <Twey> Lajla: Mostly particle combinations
08:17:59 <Twey> Also, sentence islands, including adjectives
08:18:51 <ski> Lajla : "inverse" meaning what ? reverse the order of words ? reverse subject and object ? turning it inside-out, getting leaves at root and vice-versa (somehow) ?
08:19:24 <Lajla> ski, you cannot ask these quaestions, you are eaten, what is this trickery?
08:19:53 * Lajla eats Twey's top hat, thereby robbing him of his English accent.
08:20:14 <ski> Lajla : why, you've only pondered that, as of yet
08:21:14 <Lajla> ski, I am all powerfull, I shape reality with my thoughts alone.
08:21:42 <Lajla> Twey, kerro niille että olen kaikkimahtava.
08:23:58 <donri> za'a do selbau lo nordo doi la lajla
08:25:47 <Lajla> donri, you are a nigger, but you program in Haskell, that means you cannot be a nigger, for to program means to have fingers, and to have fingers means to not have leprosy, that means the universe is inconsistent and we are trapped in a simulated reality by evil machines, Q.E.D.
08:26:22 <nus> "Liskell brings meta-programming to the Haskell world by introducing the concept of parse tree transformers (ptt). This concept is more general than the meta-programming
08:26:23 <nus> facilities defmacro and symbol-macrolet in Common Lisp. Liskell provides a single hook into the compiler, namely envlet."
08:26:54 <Lajla> Maybe it's hygienic high level.
08:27:04 <donri> Lajla: I'm no nigger for I'm a faggot.
08:27:14 <Lajla> I don't see how it can be more general than defmacro, as defmacro can take any turing complete function.
08:27:30 <Lajla> donri, ah, that explains all, having aids does not praeclude one's ability to type.
08:27:51 <soupdragon> shut up
08:27:51 <donri> I don't type, for I program in Python.
08:27:52 <p_l> excuse me, I think I missed #haskell and entered #/prog/
08:27:54 <p_l> ...
08:29:39 <nus> turing complete function?
08:29:49 <Lajla> nus, turing computable
08:29:50 <Lajla> I rephrase
08:30:08 <Lajla> donri, I don't like python, I think Dutch people are evil because they don't have death penalty on homosexuals.
08:30:16 <Philippa> Lajla, donri: can it
08:30:21 <Philippa> not appropriate in here
08:30:23 <soupdragon> Lajla, shut up you fucking moron
08:30:35 <p_l> go back to 4chan
08:31:00 <wlangstroth> whoa, did everyone suddenly get Tourette's? What's up?
08:31:03 <Lajla> Oh no, swear words, the Dutch have invaded with their liberalism.
08:31:10 <Lajla> Soon family guy will be legal.
08:31:26 <Lajla> We must return to traditional values.
08:31:28 --- mode: ChanServ set +o mauke
08:31:28 --- kick: Lajla was kicked by mauke (Lajla)
08:31:36 <mauke> this looks off-topic to me
08:31:46 <nus> quite
08:32:00 <soupdragon> you should set +b so they don't come back
08:32:00 <wlangstroth> off topic is right
08:32:09 <Philippa> there was me about to say we mostly don't give a shit about the swearing but the behaviour's inappropriate
08:32:11 <Philippa> oh well
08:32:24 <soupdragon> Philippa: apparently we do give a shit about swearing since a few months ago :(
08:32:32 <Philippa> soupdragon: oh? I must've missed that
08:32:34 <EvanR> yeah, get that schemer outta here
08:32:42 <Philippa> I mean, swearing /at/ people, fair enough
08:32:50 <soupdragon> Philippa: yeah I got snarked at for using a syntactically invalid token
08:33:28 --- mode: mauke set -o mauke
08:34:04 <Philippa> soupdragon: *shrug*
08:44:18 <Jonno_FTW> what is wrong with my definition of f c n in toRoman'? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27314#a27317
08:44:35 <Jonno_FTW> I get an infinite type error
08:46:42 <Olathe> Jonno_FTW: What's the type of f ?
08:47:14 <Jonno_FTW> f :: Char -> Int -> String
08:47:53 <zygoloid> Jonno_FTW: what's the type of (a:c) :)
08:47:55 <Olathe> Jonno_FTW: You can't have x:'c'
08:48:20 <Jonno_FTW> then how do I accumulate?
08:48:23 <zygoloid> (did you mean c:a or a ++ [c]?)
08:48:42 <EvanR> > 'c':['4','2','x']
08:48:44 <lambdabot>   "c42x"
08:48:53 <Olathe> Jonno_FTW: Well, you can start from the biggest (M, then D, ...).
08:49:04 <Jonno_FTW> ok
08:49:30 <Jonno_FTW> but that is the least of my problems now because I need to make it follow the rules of subtraction in roman numerals
08:49:40 <Olathe> Jonno_FTW: You can also use reverse.
08:49:47 <zygoloid> Jonno_FTW: it'd be more idiomatic to get rid of the accumulating parameter and lazily build the result
08:50:17 <EvanR> roman numerals are a presentational form only, not convenient for arithmetic
08:50:40 <EvanR> like but much worse than a base 10 expansion in arabic digits
08:50:41 <zygoloid> EvanR: i think Jonno_FTW means subtraction as in IV and XC
08:51:33 <EvanR> so were trying to show a number in roman numerals
08:52:29 <illissius> interesting project: type-level arithmetic with type-level roman numerals :-)
08:52:50 <EvanR> mucking about in the turing tarpit ;)
08:53:16 <aavogt> you can do arithmetic on roman numerals?
08:53:30 <Jonno_FTW> I was considering making my own types, but thought this way would be easier
08:53:32 <aavogt> (I mean directly, without converting to some sensible representation)
08:54:18 <illissius> i dunno
08:54:20 <Jonno_FTW> I don't think it would be simple to do arithmetic
08:54:49 <soupdragon> type level turing tarpit church roman numerals
08:57:51 <theorbtwo> In real roman numerals, you just concatinate the two numbers, and then renormalize.
08:58:23 <ezyang> “roman numerals are fancy peano numbers” 
08:58:25 <theorbtwo> IX as 9 is a fairly recent invention, old-school romans would have written VIIII.
08:59:30 <bremner> I thought old school romans were called greeks
08:59:40 <nlogax> did they also use VIM?
08:59:53 <nlogax> sorry, that was terrible
08:59:54 <soupdragon> lol
09:03:32 <Jonno_FTW> My toRoman' has a problem in that it won't accumulate and I don't know why
09:11:02 <Olathe> http://codepad.org/M5eDP6kn
09:11:17 <soupdragon> cool
09:12:52 <monochrom> neato
09:13:08 <astroboy> When I run cabal install in a folder with a .cabal file, it runs on that file right?
09:13:24 <monochrom> yes
09:13:46 <astroboy> Because I am trying to modify xmonad while having it installed with cabal install from hackage. I have added my module in xmonad-contrib.cabal but nothing changes
09:14:25 <astroboy> do I have to remove the other version?
09:15:21 <ezyang> astroboy: No. 
09:15:34 <ezyang> You need cabal configure && cabal build && cabal copy && cabal register 
09:17:05 <astroboy> ezyang: on cabal copy it says "cabal: Error: Could not find module: XMonad.Doc with any suffix: ["hi"] in the search path ["dist/build"]"
09:17:29 <ManateeLazyCat> ManateeLazyCatRo: Looks works.
09:17:35 <monochrom> works for me for some other package.
09:17:39 <aavogt> cabal install  works just fine for .cabal files in the same dir
09:18:11 <roconnor> > 876.69/31432.56
09:18:12 <lambdabot>   2.7891142178683506e-2
09:18:27 <ezyang> aavogt: Oh, I didn’t know that. 
09:19:22 <aavogt> astroboy: do you have multiple copies of the same library? (ghc-pkg list xmonad-contrib)
09:19:42 <astroboy> aavogt: yes
09:21:31 <astroboy> but in ghc-pkg list it apprears just once
09:21:37 <astroboy> and I have installed it only as a user
09:21:45 <astroboy> while it appears in /usr/lib/ghc-6.12.3/package.conf.d
09:22:11 <monochrom> then someone hacked into your computer and installed it as --global too
09:22:59 <astroboy> I think is the package manager fault... again
09:23:03 <aavogt> and perhaps ghc is choosing to use the package that that unknown person installed
09:23:43 <astroboy> mcnulty XMonadContrib # ghc-pkg unregister xmonad-contrib --global
09:23:44 <astroboy> ghc-pkg: cannot find package xmonad-contrib
09:26:40 <solrize> rnf turns space leaks into time leaks :(
09:27:48 <astroboy> and I've got no xmonad in /usr/lib/ghc-6.12.3/package.conf.d/
09:45:11 <zygoloid> @hoogle [(a,[b])] -> [(a,b)]
09:45:11 <lambdabot> No results found
09:45:40 <soupdragon> @hoogle (,) a [b] -> [(,) a b]
09:45:40 <lambdabot> No results found
09:45:44 <Twey> fmap (second head)
09:45:45 <soupdragon> it should exist
09:45:49 <Twey> :t map (second head)
09:45:51 <lambdabot> forall a d. [(d, [a])] -> [(d, a)]
09:46:11 <zygoloid> @hoogle (Monad m, Functor f) => m (f (m b)) -> m (f b)
09:46:12 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:46:12 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:46:12 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
09:46:15 <zygoloid> Twey: that's not the one i want
09:46:27 <Twey> What is the one you want?
09:46:44 <noobskell> hi 
09:47:06 <Twey> Hello
09:47:08 <zygoloid> concat $ map (\(a,bs) -> map ((,) a) bs)
09:47:34 <noobskell> I have a question regarding how to more elegently implement a chain of functions that pass the same parameter arround using the reader monad
09:47:41 <noobskell> for example
09:47:56 <Amagineer> Is it better to bind a one-off function in a where statement (Expression?) or is it better to use a lambda defined inline?
09:48:10 <aristid> @pl (>>=) (\(a,bs) -> map ((,) a) bs)
09:48:10 <lambdabot> (uncurry (map . (,)) >>=)
09:48:33 <aristid> zygoloid: that @pl form is almost readable.
09:48:37 <noobskell> I have the top level function foo:: Param -> a -> b
09:48:46 <Twey> concatMap $ fmap map . cycle
09:48:53 <Twey> Oh, wait
09:48:57 <noobskell> in which it callss bar:: Param -> c -> d
09:49:06 <noobskell> and bar calls quak :: Param -> e -> f
09:49:12 <kmc> Amagineer, not sure there's a general guideline
09:49:43 <noobskell> so I want to avoid passing Param to all these functions, hence the idea of using the reader monad
09:49:57 <Twey> concatMap . uncurry $ fmap zip . repeat
09:50:01 <noobskell> but the thing is, in so doing, I have to change the type of all of these funcitons, no?
09:50:07 <Twey> :t concatMap . uncurry $ fmap zip . repeat
09:50:09 <lambdabot>     Couldn't match expected type `[b]'
09:50:09 <lambdabot>            against inferred type `[b1] -> [(a, b1)]'
09:50:09 <lambdabot>     In the first argument of `fmap', namely `zip'
09:50:13 <Twey> Bah, humbug
09:50:17 <kmc> Amagineer, you could hpaste both versions and i'll give a subjective judgement which is nicer
09:50:37 <Twey> Oh, that was in the original
09:50:49 <Amagineer> So there isn't really a big difference I take it?
09:50:57 <kmc> Amagineer, what do you mean?
09:51:53 <zygoloid> why is there no Traversable instance for ((,) a) ?
09:52:37 <aavogt> @type flip
09:52:38 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:52:43 <Twey> :t concatMap . uncurry $ zip . cycle
09:52:44 <lambdabot> forall a b. [([a], [b])] -> [(a, b)]
09:52:46 <Twey> That's the one
09:52:54 <Twey> Oh, repeat, not cycle
09:52:56 <Twey> :t concatMap . uncurry $ zip . repeat
09:52:57 <lambdabot> forall a b. [(a, [b])] -> [(a, b)]
09:53:16 <zygoloid> Twey: nice
09:53:51 <zygoloid> zip . repeat = map (,) ?
09:54:07 <Twey> Yeah
09:54:08 <zygoloid> map . (,) i guess
09:54:10 <Twey> :t zip . repeat
09:54:11 <lambdabot> forall a b. a -> [b] -> [(a, b)]
09:54:12 <Twey> Yeah
09:54:17 <Twey> :t map . (,)
09:54:18 <lambdabot> forall a a1. a1 -> [a] -> [(a1, a)]
10:00:39 <rmp> hello, anyone awake?
10:00:58 <Jonno_FTW> yes
10:01:40 <rmp> I'm trying to get started using Haskell, it's been on my todo list for too long. My first task is to write a "script-like" haskell app similar to Don Stewart's cpuperf sample
10:02:08 <kmc> i'm awake
10:02:12 <kmc> for some reason
10:02:29 <monochrom> wait for the world cup finals then :)
10:02:39 <rmp> I grabbed the package from hackage db.. and tried to build it, but i'm getting a weird error when the system.process module tries to build
10:02:51 <rmp> i'm doing a windows build, so I know it's an uphill battle :D
10:03:29 <chrisdone> nominolo: ping
10:03:30 * ManateeLazyCat So many people wait World Cup final. :)
10:03:52 <kmc> rmp, it's pretty uncommon to start Haskell by writing a complete app
10:04:10 <kmc> usually people start by playing around in ghci a while, then writing small functions and testing them interactively
10:05:07 <rmp> right, i realize that :D
10:05:23 <rmp> that's why i was going to start with a known working sample and just mess about from there
10:05:26 <kmc> ok
10:05:47 <rmp> I've used object caml before so that gets me 10% of the way in terms of "typiness" :D
10:05:51 <rmp> http://pastebin.com/mGjsCqZb
10:06:09 <rmp> Can someone take a look at that and see if they recognize anything quickly?
10:06:11 <kmc> well also, it's uncommon to start with code that does IO
10:06:13 <rmp> it's the build log
10:06:24 <rmp> yeah, monads are a little weird
10:06:30 <kmc> yeah
10:06:38 <kmc> well monads are nearly irrelevant if you're only doing IO
10:06:40 <rmp> but dons's sample is fairly close
10:06:41 <chrisdone> it's talk like that that makes 'em weird
10:06:46 <rmp> heh
10:06:47 <ManateeLazyCat> rmp: Forgot monads. :)
10:06:59 <ManateeLazyCat> rmp: If you want study how to use it. :)
10:07:00 <kmc> the abstraction named "monad" doesn't matter if you're only looking at one at a time
10:07:38 <kmc> but yes, the idea of sequencing IO actions with a first-class operator is a bit weird at first
10:07:51 <kmc> rmp, i think i know what the build problem is, sec
10:07:58 <rmp> the error I'm getting on build of the sample "looks" like there is something wrong with the process module, but it's hard to believe that 
10:08:09 <rmp> given that it's used pretty often by other packages
10:08:33 <kmc> rmp, it builds for me
10:08:39 <kmc> rmp, what GHC version are you using?
10:09:06 <rmp> kmc: is that on linux? 9.10, haskell platform
10:09:10 <kmc> the "Process" module here is not part of the standard "process" package
10:09:11 <rmp> er
10:09:14 <rmp> 6.10
10:09:27 <kmc> it's just the file "Process.hs" that comes with cpuperf
10:09:30 <rmp> sorry just checked 6.21.1
10:09:36 <kmc> 6.12.1?
10:09:36 <rmp> oh
10:09:39 <kmc> 's what i have
10:10:10 <kmc> rmp, try changing "import Control.Exception" to "import Control.OldException"
10:10:17 <kmc> cabal should handle this for you
10:10:20 <kmc> and it does on my system
10:10:23 <rmp> k, that may be part of my problem. I ended up adding "process" to the cabal file at the suggestion of the compiler, but I think that's wrong in light of what you just said
10:10:25 <kmc> but it's not for you, for some unknown reason
10:10:30 <rmp> (knowing NOTHING)
10:11:11 <ketil> Nothing is still Maybe something :-)
10:11:12 <lambdabot> ketil: You have 1 new message. '/msg lambdabot @messages' to read it.
10:11:43 <tommd> rmp: Quick education - not too long ago the exception module changed drastically so old programs / demos that used Control.Exception must now use Control.OldException.  Also, not too long ago the "base" library was split up into many smaller libraries so some packages must get added dependencies (exception, containers, array, old-time, etc) to compile.
10:12:20 <kmc> rmp, ah, i replicated it.  if you do "runhaskell Setup.lhs configure -f small_base"
10:12:39 <kmc> (small_base is a flag named in the cpuperf cabal file.  not something more general in cabal)
10:12:54 <tommd> small_base is a common concept though and found in many .cabal files.
10:12:58 <kmc> ok
10:13:10 <tommd> a relic from the base split
10:13:21 <kmc> then it grabs the new Control.Exception, which is too new; it should nowadays grab Control.OldException
10:13:29 <rmp> ah
10:13:32 <kmc> if you don't have small_base then it uses an ancient version of base which only has the old Exception
10:13:38 <aavogt> this means the cabal file is broken
10:13:46 <kmc> yeah, it should probably say "base >= 3 && < 4"
10:14:06 <kmc> it's necessary now to have upper bounds on base version
10:14:12 <kmc> but was not practiced in the past
10:14:17 <tommd> thank goodness.
10:14:30 <tommd> If you don't have an upper bound its supposed to force you to base 3.0 I thought.
10:14:31 <kmc> with that change to the cabal file, it works even with -f small_base
10:14:34 <aavogt> @hackage extensible-exceptions
10:14:34 <lambdabot> http://hackage.haskell.org/package/extensible-exceptions
10:14:48 <rmp> ah
10:14:49 * aavogt would just use that library instead
10:14:54 <rmp> very cool
10:15:12 <crazycaw> learnyouHaskell vs Real Word Haskell, what is best?
10:15:25 <kmc> crazycaw, they're both fine, read them both and see what you like
10:15:30 <kmc> we recommend both of them regularly
10:15:39 <kmc> rmp, so, you've jumped in the deep end of grungy build system stuff :)
10:15:56 <crazycaw> but in the same time?
10:16:01 <kmc> crazycaw, if you like
10:16:12 <kmc> crazycaw, if you read the introduction to each
10:16:20 <kmc> then you may have a better idea which you'd like to read first
10:16:29 <hpc> you might try learn you a haskell first, as i think it teaches things in a better order
10:16:33 <crazycaw> and Programming in Haskell ?
10:16:33 <aavogt>  read $ zip lyah rhw
10:17:08 <crazycaw> aavogt, what?
10:17:09 <aavogt> that is a type error and typo
10:17:17 <hpc> :t zip
10:17:18 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
10:17:35 <kmc> crazycaw, i'm cheap and so only read things that are free online ;P
10:17:44 <kmc> crazycaw, but it looks good, well recommended by some competent pepole
10:17:46 <crazycaw> eheh :D
10:18:01 <aavogt> crazycaw: I'm suggesting you interleave sentences from each book
10:18:03 <tommd> crazycaw: He's being silly, using the haskell function 'zip' to build a list of pairs of pages from the sources of lyah and rwh.
10:18:09 <tommd> yeah, that.
10:18:34 <kmc> unlines $ zipWith (++) (lines lyah) (lines rwh)
10:18:48 <kmc> @pl \lyah rwh -> unlines $ zipWith (++) (lines lyah) (lines rwh)
10:18:48 <lambdabot> (unlines .) . (. lines) . zipWith (++) . lines
10:18:54 <kmc> :t (unlines .) . (. lines) . zipWith (++) . lines
10:18:55 <lambdabot> String -> String -> String
10:19:00 <kmc> haha
10:19:20 <monochrom> there is absolutely no need to "x vs y which is best? I'm reading only one of them"
10:19:54 <tommd> someone has clearly given him an ultimatum.
10:20:05 <hpc> when is BONUS getting around to publishing the monads chapter?
10:21:13 <kmc> pfft, monads.  so overrated
10:21:24 <monochrom> perhaps there is a correlation between "I'm adhering to only one language, it's the best ever" and "I'm adhering to only one book, it's the best ever"
10:21:32 <kmc> heh
10:22:00 <hpc> isn't that what every haskell programmer thinks?
10:22:05 <hpc> "haskell is the best ever"
10:22:13 <monochrom> not every
10:22:28 <hpc> :P
10:23:00 <ManateeLazyCat> There is no best language, only the most suitable for your language.
10:23:25 <aavogt> some things are unsuitable for any task
10:23:59 <aavogt> (well maybe the task is to be unsuitable for another task ....)
10:24:01 <idnar> aavogt: hmm, that depends on how creatively you define your task
10:24:09 <idnar> heh
10:24:44 <kmc> hpc, the true Haskell programmer accepts that Haskell is unsuitable for some problems.  those problems are best solved using domain-specific languages implemented in, well, you can guess
10:25:22 <kmc> anyway it would be strange to have the attitude of one language being best, while attempting to learn another
10:26:04 <kmc> the people who think one language is best for everything tend to avoid learning in general
10:26:11 <aavogt> kmc: that's how you reinforce your belief that one language is best
10:26:14 <kmc> heh
10:26:20 <kmc> yeah i'm guilty of this
10:26:32 <kmc> spend 5 minutes reading about Go, declare that it sucks and Haskell is still better
10:26:41 <Phyx-> Does anyone know if the windows binaries of ghc come with libraries compiled with profiling support?
10:26:44 <ManateeLazyCat> kmc: That's true.
10:26:58 <ManateeLazyCat> kmc: Go is suck.
10:27:18 <chrisdone> did the haskellwiki get hacked, again?
10:27:25 <Phyx-> and would  cabal install ghc-paths --ghc-options="-prof --auto-all" --reinstall be the right command to recompile a libary with profiling?
10:27:40 <kmc> oh ffs
10:27:42 <aavogt> chrisdone: you saw my hackskells?
10:27:42 <chrisdone> http://haskell.org says "TO BUY Cilamox ONLINE" 
10:27:55 <chrisdone> they should upgrade the bloody wiki
10:27:58 <kmc> that's fucking embarrassing
10:28:07 <Phyx-> LOOOOL
10:28:08 <chrisdone> dons: are you there?
10:28:13 <FauxFaux> Teee hee.
10:28:49 <soupdragon> XD
10:28:56 <Phyx-> yes, that is kinda embarrassing
10:29:07 <FauxFaux> Should've written the wiki in haskell.
10:29:17 <kmc> indeed
10:29:20 <ManateeLazyCat> chrisdone: I guess dons in vacation... :)
10:29:24 <Phyx-> yes, chances are, the ones who hacked it don't know haskell :P
10:29:47 <kmc> yay, security through obscurity
10:30:06 <Phyx-> kmc: well, security the other way isn't working apparently :P
10:30:08 <ManateeLazyCat> Phyx-: I think should write by Mars language
10:30:22 <tensorpudding> D?
10:30:23 <kmc> let's rewrite the wiki in Ur/Web
10:30:23 <Phyx-> ManateeLazyCat: or whitespace :P
10:30:36 <FauxFaux> Mmm, I wonder if it's related to *.wiki.kernel.org being down.
10:30:42 * ManateeLazyCat Bla bla for testing my gtk2hs irc client .... :)
10:30:52 <kmc> i worked somewhere where the SSH gateway was OpenBSD on Indy MIPS for this reason.  because 1) OpenBSD, 2) who would release an 0-day for MIPS OpenBSD anyway
10:30:56 <Phyx-> but seriously, anyone know the answer to my two questions? :P
10:30:59 <Phyx-> pretty please?
10:31:02 <Phyx-> i'll give you cookies
10:31:06 <FauxFaux> Oh, wait, no, it's not a serious wiki software. :p
10:31:09 <kmc> omnom
10:31:21 <Phyx-> hey, answers, then cookies!
10:33:31 <Phyx-> lol
10:33:35 <Phyx-> and so it went quiet
10:34:15 <Phyx-> what the heck is Cilamox anyway?
10:34:30 <chrisdone> @tell Baughn http://haskell.org/ we really need to get control over the server, or the domain. jesus
10:34:30 <lambdabot> Consider it noted.
10:35:36 <rmp> kmc: thanks for the assist -- I just got back and tried your changes.. works well!!
10:35:37 <kmc> could be worse
10:35:39 <kmc> could be goatse
10:35:41 <kmc> rmp, cool :)
10:36:16 <Phyx-> well, control over the domain wouldn't do much in this case
10:36:17 <rmp> lol, i had a friend that suggested that the iphone finger "spread" was ideal for zooming in on that picture
10:36:27 <rmp> goatse control scheme he c
10:36:31 <rmp> calls it
10:38:01 <kmc> apparently cilamox is amoxicillin, a mostly obsolete antibiotic
10:38:14 <Phyx-> hmm, I changed my code from using Lists to Vector
10:38:18 <Phyx-> and it actually got slower
10:38:20 <Phyx-> xD
10:38:22 <kmc> overused hence everything is resistant to it
10:38:28 <kmc> haha Phyx-
10:38:50 <monochrom> haha that is worse than selling snake oil.
10:39:11 <kmc> but how else will i make my snake shiny
10:39:36 <lispy> Phyx-: less fusion now?
10:39:36 <Phyx-> code currently runs in 0.9s down from 1.3 by changinga few stuff, but need it faster :/
10:39:39 <Phyx-> sub 0.5range
10:39:55 <lispy> Phyx-: are you just running it randomly or using something like criterion?
10:40:26 <lispy> Phyx-: what does the profiler show as the slow places?
10:40:31 <Phyx-> lispy: just running it 100x and getting the average. What I really wanna do is run using -prof and see where the bottle necks are, it's a big function and it collects alot of information
10:41:01 <Phyx-> lispy: that's the thing, I can't run the profiler :/ missing prof support on 1 ghc, when i recompile it with it segfaults during compilation
10:41:15 <lispy> Phyx-: averages are nice, but without an idea of the distribution it's hard to make sense of them.  What is your stddev?
10:41:25 <Phyx-> and another one says ghc-paths is missing profiler support, and i recompile it with, and it still says the same
10:41:47 <Phyx-> lispy: less than 0.1s 
10:42:12 <Phyx-> actually, less than 0.01s
10:42:54 <Phyx-> lispy: i'm using cabal install ghc-paths --ghc-options="-prof --auto-all" --reinstall but somehow it's not doing anything :P
10:42:57 <lispy> Phyx-: what platform are you on?  I've never run into a machine with broken support for profiling
10:43:13 <chrisdone> looks like someone fixed the wiki 
10:43:18 <lispy> Phyx-: that's not how you do it :)
10:43:52 <lispy> Phyx-: --enable-library-profiling
10:43:58 <lispy> Phyx-: or just -p for short
10:43:59 <Phyx-> lispy: windows, but I'm using 2 ghcs, a 6.12.1 that seems to have support for it. but the current HEAD of ghc segfaults when compiled with profiling support
10:44:06 <Phyx-> lispy: oh, that's handy :P
10:44:31 <Phyx-> submitted a ticket,  but i suppose it's gonna take a while
10:44:32 <soupdragon> second chapter of Awody: WTF
10:44:34 <lispy> Phyx-: the trick is that you need the library compiled both ways.  So if you just pass the option to Ghc then things will get confused
10:44:54 <arjanb> Igloo++ for quickly fixing haskell.org
10:45:04 <Phyx-> Igloo++
10:45:25 <Phyx-> lispy: ah ok.  yeah I see it's compiling it twice
10:45:32 * soupdragon notices the "DOWNLOAD HASKELL" button still here :( .... ;`(
10:45:51 <lispy> Phyx-: I highly recommend having that option in your .cabal file
10:46:04 * chrisdone downloads HTML
10:46:08 <lispy> Phyx-: otherwise, as soon as you want to profile something you have to do a lot of dependency re-installing
10:46:10 <Phyx-> yeah, it seems very handy *finds file*
10:46:53 <lispy> Phyx-: I guess I meant, ~/.cabal/config not your .cabal file.  But I think you knew what I meant :)
10:47:28 <Phyx-> yeah, already enabled library-profiling: True
10:47:29 <Phyx-> :)
10:47:40 * ManateeLazyCat Hmm, Haskell thread very good. IRC client is fast and stable....
10:48:00 <lispy> ManateeLazyCat: what client?
10:48:08 <ManateeLazyCat> lispy: My own gtk2hs client.
10:48:16 <ManateeLazyCat> lispy: I'm testing it.... :)
10:48:25 <kmc> thanks, Igloo
10:48:29 <kmc> thigloo
10:48:32 <ManateeLazyCat> ManateeLazyRot: This is my bot. :)
10:48:33 <lispy> ManateeLazyCat: cool.  Will it be configurable with plugins like xmonad?
10:48:47 <Phyx-> lispy++ for helping me enabled profiling
10:48:50 <ManateeLazyCat> lispy: It's sub-module project in my framework.
10:48:55 <Phyx-> now to recompile a few more packages
10:49:00 <ManateeLazyCat> lispy: And my framework can do that.
10:49:23 <ManateeLazyCat> lispy: http://farm5.static.flickr.com/4098/4771492256_e1f3a318ef_b.jpg
10:50:16 <ManateeLazyCat> lispy: I will bring many cool feature from erc. (If you use emacs) . :)
10:50:33 <lispy> ManateeLazyCat: I used to use erc
10:50:36 <chrisdone> ManateeLazyCat: are you using a ... proportional FONT, FOR CODE?
10:50:48 <lispy> ManateeLazyCat: it had too many memory leaks, but it was nice
10:51:08 <ManateeLazyCat> lispy: I have test haskell-thread, just 2MB.
10:51:34 <ManateeLazyCat> chrisdone: I use a Chinese font.
10:51:35 <lispy> nice.  My erc sessions would get into the 1/2 gig range after a month or two
10:51:51 <chrisdone> ManateeLazyCat: looks proportional to me
10:51:58 <chrisdone> ~_~
10:52:26 <ManateeLazyCat> chrisdone: sudo aptitude install ttf-wqy-microhei -y
10:53:36 <chrisdone> ManateeLazyCat: what does that do?
10:53:38 <ManateeLazyCat> chrisdone: It's base on Google's Droid font, but more complete for CJK font.
10:53:41 <Phyx-> lispy: weee it's building
10:53:50 * Phyx- finds the wiki page on profiling
10:53:56 <lispy> Phyx-: cool
10:53:59 <ManateeLazyCat> chrisdone: You mean font or my project?
10:54:09 <soupdragon> @seen Cale
10:54:09 <lambdabot> Unknown command, try @list
10:54:11 <lispy> Phyx-: rwh has a nice chapter (25? 26?) on profiling if you need to learn how
10:54:22 <Cale> soupdragon: yes?
10:54:25 <soupdragon> hi Cale!
10:54:44 <soupdragon> I just wondered if there is more than duality ? like  (C^op)^op = C 
10:54:47 <Phyx-> lispy: ah, thank god it's online too, my copy of it is back home
10:54:55 <soupdragon> but what about ((C^*)^*)^* = C triality
10:55:06 <soupdragon> maybe arrows would have to be triangle though
10:55:11 <ManateeLazyCat> lispy: BTW, i love the algorithm of erc-nick-colors.el
10:55:30 <Cale> soupdragon: Well, there will surely be categories with such a functor.
10:55:33 <ManateeLazyCat> lispy: Use MD5 compute nick color. :)
10:55:34 <lispy> ManateeLazyCat: Who wrote that?
10:55:37 <lispy> ah yeah
10:55:39 <monochrom> @quote 1970s.terminals
10:55:40 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
10:55:41 <soupdragon> is ^op a functor?
10:55:43 <lispy> I sit next to the guy that wrote it
10:55:52 <lispy> at work I mean
10:55:55 <soupdragon> omg it is
10:56:10 <soupdragon> wow........ why didn't I realize this befoer
10:56:17 <Cale> But ^op is special in that it's something that all categories allow.
10:56:26 <zygoloid> isn't it a contravariant functor?
10:56:31 <Phyx-> monochrom: lol
10:56:39 * ManateeLazyCat pasted "erc-highlight-nicknames.el" at http://paste2.org/get/911454
10:56:39 <ManateeLazyCat> lispy: ^^^^
10:56:53 <Cale> zygoloid: Well, yes :)
10:57:26 <lispy> ManateeLazyCat: oh.  That's different than the one I used which also used md5s
10:57:29 <ManateeLazyCat> lispy: I add patch to fix a bug of erc-highlight-nicknames.el
10:57:58 <ManateeLazyCat> lispy: erc-highlight-nicknames.el will adjust color to avoid too light or too dark....
10:58:45 <ManateeLazyCat> lispy: IMO, i prefer like rcirc's code, neat and clean.
10:58:58 <ManateeLazyCat> lispy: Just ERC have more features
11:00:05 * lispy nods
11:00:44 * hackagebot graph-rewriting 0.4.8 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.4.8 (JanRochel)
11:00:46 * hackagebot graph-rewriting-layout 0.4.1 - Force-directed node placement intended for incremental graph drawing  http://hackage.haskell.org/package/graph-rewriting-layout-0.4.1 (JanRochel)
11:01:44 * hackagebot graph-rewriting-gl 0.5 - OpenGL interface for interactive hypergraph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.5 (JanRochel)
11:01:46 * hackagebot graph-rewriting-ski 0.4.3 - Implementation of the SKI combinators as an interactive graph rewriting system  http://hackage.haskell.org/package/graph-rewriting-ski-0.4.3 (JanRochel)
11:02:33 <Phyx-> how do the GHC version pragmas work again?
11:04:01 <ManateeLazyCat> lispy: Which one do you use?
11:04:34 <lispy> ManateeLazyCat: these days I don't have a specific client.  I use xchat at home, pidgin at work, or freenode's webchat (until they muted it)
11:05:00 <ManateeLazyCat> lispy: Why not use erc?
11:05:44 <ManateeLazyCat> lispy: I think erc/rcirc is much better than most irc client. :)
11:06:14 <ManateeLazyCat> lispy: Just hate elisp's speed... 
11:07:16 --- mode: ChanServ set +o monochrom
11:07:33 --- mode: monochrom set -q *!~riki@*
11:09:04 <ManateeLazyCat_> Hello, i'm a robot of ManateeLazyCat .... 
11:09:15 <ManateeLazyCat> Cool....
11:10:08 --- mode: monochrom set -bbb *!*@89.148.146.* *!*@64.120.233.114 *!*@host81-132-34-201.range81-132.btcentralplus.com
11:10:21 --- mode: monochrom set -o monochrom
11:11:11 * ManateeLazyCat 20 minutes countdown.
11:11:53 <kmc> ManateeLazyCat, your very own robot :)
11:12:23 <ManateeLazyCat> kmc: I'm test my irc client that translate Chinese to English. :)
11:12:31 <kmc> oh, very cool :)
11:13:45 <Phyx-> lispy: that RWH chapter was very useful :)
11:13:56 <lispy> Phyx-: cool!
11:14:06 <ManateeLazyCat> kmc: BTW, i was think your suggestion today for hot-swapping, it's a great idea.
11:15:42 <ManateeLazyCat> kmc: I just need keep core little enough, then i don't need touch core, any extension process can hot-swapping in runtime and won't conflict with other extension processes.
11:19:25 * ManateeLazyCat Bye all, enjoy World Cup.... :)
11:23:02 <soupdragon> "If A^x +B^y = C^z , where A, B, C, x, y and z are positive integers and x, y and z are all greater than 2, then A, B and C must have a common prime factor."
11:24:31 <tensorpudding> beal's conjecture
11:25:35 <Phyx-> well, that's disappointing
11:25:38 <Phyx-> according to this
11:25:48 <Phyx-> the slowest part was the ghc-api
11:25:58 <Phyx-> taking 40% of the time to load a module
11:26:15 <Phyx-> which explains why nothing I do makes the code much faster
11:26:43 <c_wraith> the ghci api is slow.  try not to use it in a loop. :)
11:27:12 <c_wraith> If you're loading a bunch of modules at once, figure out how to get it to load them all in one pass.
11:27:18 <Phyx-> c_wraith: does calling it every 500ms after last keypress count as loop? :P
11:28:10 <Phyx-> well, actually, loading and typecheck and renaming take about 78% of the execution of the program
11:28:20 <Phyx-> only 1.6% being my actual code
11:28:38 <c_wraith> phyx:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27321#a27321
11:29:01 <c_wraith> I wrote that to wrap reloading actions via the ghc api (via hint) in my app
11:29:19 <c_wraith> It's a combination of short-term caching and thread isolation
11:29:41 <c_wraith> But it is designed for always evaluating the same expression
11:29:48 <c_wraith> Which it sounds like may not be your case
11:30:56 <Phyx-> well, repeated calles will always be on the same slightly modified module. so if the dependencies are cached that would already save alot
11:31:06 <c_wraith> sadly, it doesn't do that.
11:31:23 <c_wraith> It doesn't know anything about the internals of the action it evaluates
11:31:41 <Phyx-> does the ghc api even support that? so if i keep HscEnv around, and i call load again, does it still load all dependencies?
11:32:43 <c_wraith> I only traced through the portion of the code that loads package lists..  It gets preserved in the HscEnv
11:33:00 <c_wraith> I don't know about the portion that keeps track of actual loaded code
11:33:53 <Phyx-> well, it should, the timestamps in the HscEnv should still be the same for the dependencies
11:34:28 <Phyx-> And if i remember correctly Load checks those
11:35:16 <Phyx-> but my next problem would be, the program is compiled to library which is loaded into memory for the duration of the caller's lifetime
11:35:29 <Phyx-> but a call to my haskell code always fully terminates
11:35:48 <Phyx-> so i'd need to find a way to keep the GC from garbage collecting the HscEnv and to refer to t
11:35:51 <Phyx-> it*
11:36:23 <Phyx-> maybe write it to a Ptr and also pass the address along as a result of the function
11:39:02 <Phyx-> Ptr is the only thing the GC won't cleanup right?
11:39:55 * hackagebot graph-rewriting-lambdascope 0.4.3 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.3 (JanRochel)
11:40:26 * Phyx- drops a pin
11:40:42 <c_wraith> You could also use the unsafePerformIO newIORef trick
11:40:55 <lispy> Or you could tell the GC not to collect your pointer
11:41:09 <Phyx-> lispy: how? 
11:41:17 <Phyx-> c_wraith: how would i refer to it later?
11:41:19 <lispy> I forgot the function name
11:41:39 <Phyx-> hehehe
11:41:56 <c_wraith> Phyx-, you make it a CAF in your module.
11:42:23 <Phyx-> hmm
11:42:30 <Phyx-> that could work
11:42:33 <c_wraith> It's a commonly-known trick, though it has a long list of caveats
11:42:43 <c_wraith> meaning it's not that commonly used
11:43:28 <c_wraith> You need to give it a non-polymorphic type, you need to use the NOINLINE pragma on it, and probably a couple other things I've forgotten
11:43:43 <kmc> hehe
11:43:49 <kmc> i think it's fairly common despite these caveats
11:44:32 <kmc> non-polymorphic type is an important one, although you shouldn't expect to have a polymorphic ioref anyway
11:44:37 <lispy> Phyx-: this might work: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-StablePtr.html
11:44:38 <kmc> existential ioref, yes
11:45:07 <Phyx-> c_wraith: those are fine with me :)
11:45:23 <Phyx-> lispy: ah, StablePtr forgot about that
11:46:19 <c_wraith> There's also a race condition in the unsafePerformIO newIORef thing...  I don't think that can be worked around.
11:46:33 <lispy> Phyx-: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-ForeignPtr.html#v%3AtouchForeignPtr
11:46:44 <kmc> oh, if two threads hit it before either has updated the CAF closure?
11:46:48 <c_wraith> yes
11:46:49 <kmc> that's real tricky
11:46:52 <kmc> i didn't think about that
11:47:11 <kmc> sucks
11:47:16 <Phyx-> I thought GHC synchronized closure entries
11:47:24 <c_wraith> I think there's a one-frame gap
11:47:35 <c_wraith> err, too many fighting games.  one instruction :)
11:48:00 <Phyx-> lispy: i think StablePtr is what i need, the first link :)
11:48:06 <kmc> it does synchronize
11:48:09 <kmc> but iirc GHC takes the attitude that a very rare race resulting in duplicated work is better than the cost of locking every call
11:48:45 <kmc> and that's very true, but not when that work is an impure evaluation
11:48:54 <Phyx-> hehhehe
11:49:04 <kmc> JHC has a thing for top-level IO bindings
11:49:14 <Phyx-> ok, time to write up a small implementation to test this
11:49:17 <kmc> would be nice for GHC to adopt similar
11:49:20 <Phyx-> thanks lispy, c_wraith 
11:49:23 <c_wraith> Yeah, having real compiler support for that is the only way to make it safe.
11:49:41 <kmc> c_wraith, hmm, you could do it with FFI i think
11:49:52 <c_wraith> oh, interesting.  I didn't think about that.
11:50:03 <kmc> very roundabout
11:50:04 <Phyx-> kmc: yeah, that's what lispy proposed
11:50:15 <Phyx-> I can just create a stablePtr with the value
11:50:22 <Phyx-> and store it in the caller
11:50:37 <Phyx-> everytime i want to retypecheck, pass it along as an argument
11:50:49 <kmc> ah yes
11:50:49 <Phyx-> load the value and *hopefully* Load caches
11:50:50 <kmc> makes sense
11:52:21 <Phyx-> my file should be easy enough to modify to test that
11:52:34 <Phyx-> i'll test 100x full loading and typechecking
11:52:37 <kmc> i think you could use FFI to synchronize a top-level IORef also
11:52:51 <kmc> or more generally any top-level impure value
11:53:11 <Phyx-> kmc: but are IORef's guaranteed not to be touched by the GC?
11:53:47 <kmc> Phyx-, not sure what you mean.  anyway i meant more generally, since c_wraith explained to me a race condition in creating top-level IORefs; I'm not sure it's suitable for what you're doing
11:54:20 <kmc> hmm should be possible to write (using FFI or other RTS trickery) a globally synchronized unsafePerformIO
11:54:33 <kmc> that'd do it i guess?
11:54:52 <c_wraith> Phyx-, the main thing is, you need to share a reference (of some sort) anyway
11:55:02 <c_wraith> Phyx-, that means you need to share a name between calls.
11:55:20 <c_wraith> Your options are therefore something environmental, like a StateT wrapper for your stuff
11:55:31 <c_wraith> Or even a ReaderT wrapper
11:56:05 <c_wraith> Or something at the CAF level, created via tricks to give you a mutable value at the top level
11:56:45 <Phyx-> c_wraith: a mutable value at top level works, but I don't think a StateT or Reader would work, I always understood their values to be lost once the computation terminates
11:57:24 <c_wraith> Phyx-, I meant wrapping your whole program in a ReaderT or StateT or somthing
11:58:53 <Phyx-> c_wraith: I think you're misunderstanding what I'm looking for, the program, or call terminates. but the RTS remains in memory waiting to subsequent calls
11:59:06 <Phyx-> in between those calls I want to share information, which is why i think lispy's solution would work
11:59:27 <c_wraith> Phyx-, you still need a reference to the shared state.
11:59:42 <Phyx-> c_wraith: that's where lispy's stablePtr come in I think
11:59:51 <c_wraith> Just making sure it doesn't get thrown out doesn't do anything but create a memory leak
12:00:29 <Phyx-> correct, with the stablePtr I can read, update and free it later
12:00:54 <c_wraith> I guess I don't know anything about the stablePtr api
12:01:13 <roconnor> @free zipWith
12:01:14 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
12:01:17 <kmc> it gives you an opaque value, which you can dereference to get the Haskell value back
12:01:51 <Phyx-> and which you can pass to foreign code
12:02:14 <c_wraith> Doesn't that require you to still have the same stablePtr in subsequent calls?
12:02:32 <kmc> yeah, you'd have to stuff it somewhere
12:02:33 <Phyx-> c_wraith: yes, nothing stops me from passing it along as an argument in the calls
12:03:22 <Phyx-> it has a Storable instance, so It can be marshalled
12:03:47 <c_wraith> In that case, why use a stablePtr at all?  Why not just use an opaque (to the calling app) data type?
12:04:03 * hackagebot redis 0.7.1 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.7.1 (AlexanderBogdanov)
12:05:08 <Phyx-> c_wraith: what do you mean? why not pass HscEnv along itself you mean?
12:05:31 <c_wraith> or something wrapping it and other information you want, yes
12:06:00 <c_wraith> I guess you want a mutable value, so maybe an IORef
12:06:32 <Phyx-> well, the reason for that is HscEnv is quite big, and marshalling that whole thing is costly, not to mention my tool can't automatically do it because of the unboxed types
12:06:45 <c_wraith> basically, why bother with a Ptr type if you're not involving FFI?
12:06:58 <Phyx-> c_wraith: but I am
12:07:02 <c_wraith> ah, ok
12:07:04 <Phyx-> every call is over FFI
12:07:06 <c_wraith> sounds good then :)
12:07:13 <kmc> StablePtr is not much like Ptr or ForeignPtr
12:07:15 <Phyx-> hehehe :)
12:07:37 <nus> @hoogle Ptr
12:07:37 <lambdabot> module Foreign.Ptr
12:07:37 <lambdabot> Foreign.Ptr data Ptr a
12:07:38 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
12:08:02 <ccasin> If I get a C array with Foreign.Marshal.Array.newArray, am I responsible for freeing it, or will the memory be freed when it goes out of scope?
12:08:33 <Phyx-> you're responsible
12:08:47 <kmc> you can cast a StablePtr to/from «Ptr ()», but you're not allowed to peek/poke that memory.  it's just there so that C functions can receive/return references to Haskell values as void*
12:09:08 <kmc> some C apis do this too, using void* (or a typedef thereof) as an opaque type for something which isn't really a pointer
12:09:16 <ccasin> Phyx-: thanks
12:09:23 <Phyx-> kmc: true, but that's also all i need, I'll only read it inside the haskell world
12:09:33 <Phyx-> ccasin: don't forget to keep around how big the array was
12:09:57 <Phyx-> I found an old presentation from Simon marlow, where he describes a function "typeOfId :: SrcLoc -> ModuleInfo -> Maybe Type
12:10:02 <Phyx-> was that ever made?
12:10:05 <Phyx-> i can't seem to find it
12:30:17 <Phyx-> c_wraith: hmm I see one small issue with this approach, but it's one I can live with
12:30:25 <Phyx-> HscEnv will only grow
12:30:28 <Phyx-> never shrink
12:30:33 <Phyx-> so if you add imports that fine
12:30:47 <Phyx-> if you remove imports you have interfaces loaded which are not needed
12:30:55 <Phyx-> but those shouldn't take up too much space
12:31:13 * hackagebot graph-rewriting-ski 0.4.4 - Implementation of the SKI combinators as an interactive graph rewriting system  http://hackage.haskell.org/package/graph-rewriting-ski-0.4.4 (JanRochel)
12:32:18 * hackagebot graph-rewriting-lambdascope 0.4.4 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.4 (JanRochel)
12:34:57 <Peaker> I was trying to write something like:  class Something s where type SomethingMonad s :: * -> * ; ...    But now if I want a monad context on (SomethingMonad s) I need Flexible Contexts in addition to type families :(  If I use Fundeps instead, I only need multi-param + fundeps, and not flexible contexts..
12:34:57 <nus> rhoscope
12:35:10 <Peaker> It seems like Type Families almost immediately implies the need for flexible contexts?
12:35:24 <Peaker> I am trying to avoid as many extensions, especially controversial ones, as possible
12:35:47 <kmc> i don't think FlexibleContexts is controversial
12:36:01 <kmc> TypeFamilies is much more so
12:36:49 <Peaker> Is it true though that TF is not very usable without FC too?
12:37:00 <Peaker> Any time you want any type-class restriction on an associated type/data...
12:37:03 <lispy> kmc: I think FlexibleInstances is non-controversial, but FlexibleContexts is just weird IMO
12:37:27 <Peaker> Monad (SomeMonad t) => ...
12:38:46 <Peaker> I wonder how monads-fd puts monad restrictions on associated types
12:41:43 <ddarius> lispy: What's weird about it?
12:43:40 <lispy> ddarius: It's been a while since I had an example using it, but it seemed like I had to use both the type class name and the full type.  That seems weird because it seems to defeat the purpose of having a type class
12:46:01 <lispy> flexible instances on the other hand, makes it possible to declare multiparameter type class instances with repeated type variables, which makes sense to me
12:46:17 <lispy> Some of the other stuff flexible instances allows, doesn't necessarily make sense to me
12:46:54 <kmc> Peaker, i wouldn't say that lack of class restrictions on ass-types makes them useless
12:49:03 <Phyx-> does code.haskell.org support something other than darcs?
12:55:34 <Gertm> is LYAH still maintained/worked on?
12:55:53 <arcatan> how to test if a string contains invalid UTF-8?
12:56:49 <Zao> arcatan: Try decoding it?
12:57:16 <arcatan> well, yeah, but how?
12:58:17 <Zao> Data.Text's functions?
12:58:23 <Cale> Gertm: Probably. You'd have to ask BONUS.
12:58:28 <Zao> The misc utf8 packages probably have some functions too.
12:58:38 <arcatan> Zao: i'll take a look at Data.Text. thanks.
12:58:43 <Cale> Gertm: Last I heard, it was on its way to being published.
12:58:47 <kmc> Gertm, yes.  BONUS is working on a dead-tree book
12:58:55 <ahmed> hlooo
12:58:57 <kmc> and also will publish a monad chapter Real Soon Now
12:59:06 <Zao> Particularly, Data.Text.Encoding
12:59:14 <Guest65034> how are you eveybady?
12:59:21 <kmc> hi
12:59:37 <Zao> http://hackage.haskell.org/packages/archive/text/0.7.2.1/doc/html/Data-Text-Encoding.html#v%3AdecodeUtf8With
13:01:23 <Gertm> cool, if it gets out in dead-tree form I'll get a copy.
13:02:02 <Mkman> hey
13:04:58 <kmc> hi Mkman
13:05:50 <Mkman> :)
13:14:33 <ezyang> Refactoring in Haskell is a lot more fun than refactoring in other languages :-/ 
13:15:34 <aristid> ezyang: you mean ":-)", not ":-/"?
13:16:02 <soupdragon> is  Simple word problems in universal algebras  easy to understand?
13:16:06 <p_l> aristid: I suspect :-> :)
13:16:32 <aristid> soupdragon: so, did you improve upon my approximation of the pi?
13:16:42 <soupdragon> aristid, I couldn't improve !
13:17:29 <aristid> soupdragon: it must be possible by increasing the freedom of the search
13:17:44 <soupdragon> yes but if you let the number get too big it loses memorability
13:17:54 <soupdragon> well unless the number has a special form
13:18:22 <aristid> that restriction is new :D
13:19:10 <aristid> soupdragon: if we had a model of memorability, we could search for the most memorable closed equation for calculating pi :D
13:19:36 <soupdragon> that would  be excellent
13:21:19 <ezyang> :-) if I’m in Haskell, :-/ otherwise ;-) 
13:28:08 <soupdragon> it's funny how in physics and stuff you get 'cranks'
13:28:09 <CakeProphet> > fix (const 5)
13:28:10 <lambdabot>   5
13:28:20 <soupdragon> and they're ridiculed and isolated for having their own theories
13:28:35 <soupdragon> but in programming the equivalent get lots of dedicated followers
13:28:55 <CakeProphet> soupdragon:  that is pretty lame. Especially considering mainstream theoretical physics has yet to truly validate much of string theory.
13:29:04 <CakeProphet> from what I can tell, at least.
13:29:06 <Loriel> I figure in programming you sit down an evening and write a crazy library or interpreter or what not
13:29:21 <Loriel> and in physics you need a couple billions to build a time cube accelerator or whatever the hell
13:29:28 <soupdragon> lol
13:29:37 * CakeProphet has a few esoteric programming language designs.
13:30:03 <aristid> soupdragon: it's probability about difficulty of falsifying
13:30:21 <CakeProphet> one design has byte cells moving across a 2D grid of instructions (the text file). Every cell is a concurrent thread, and can only contain one word of data.
13:30:35 <CakeProphet> you spawn new threads by creating copies of old ones.
13:31:14 <CakeProphet> > length "Hello, World!"
13:31:15 <lambdabot>   13
13:31:24 <CakeProphet> so "Hello, World!" spawns 14 threads. :)
13:32:39 <CakeProphet> I never made an implementation because until I started learning Haskell I didn't know a language that supported lightweight threads. 14 OS threads would be crazy.
13:32:47 <CakeProphet> perhaps I should make one in Haskell. :)
13:37:57 <kmc> you could use various sorts of cooperative threading
13:38:17 <kmc> even in a language/implementation which does not support lightweight preemptive threading
13:38:31 <CakeProphet> the current semantics use message queues.
13:38:45 <kmc> you usually get continuations, coroutines, generators, iterators, etc., or can fake them from something else
13:38:50 <CakeProphet> that you actually place on the instruction grid somewhere. read and write operations are instructions adjacent to a channel character.
13:39:10 * lispy was going to suggest making message queues on top of continuations
13:39:29 <CakeProphet> so, for example, to synchronize "Hello, World!" you have every byte cell wait for a message to be received before it advances to the stdout channel.
13:40:04 <CakeProphet> and the character that is supposed to come before it sends the okay message once it has been send to stdout
13:40:07 <kdvh> if i want GHCi to load up in a folder i want, i add ":cd /path/" to my ~/.ghci?
13:40:33 <lispy> kdvh: you can add any interactive command to your ~/.ghci
13:40:53 <kdvh> lispy: alright, thanks
13:41:02 <CakeProphet> lispy:  how would continuous works programatically? The program is a 2d grid of single-character instructions.
13:41:09 <CakeProphet> *continuations
13:41:43 <lispy> CakeProphet: I'm not sure, but I know that continuations can implement co-routines, yielding, and system calls
13:42:03 <lispy> CakeProphet: so it seems like implementing waiting on message queues should also be possible
13:43:00 <lispy> CakeProphet: also, you might want to look at stencil algorithms and also some of the concurrent logo implementations
13:43:22 <lispy> cellular automata seems related as well
13:43:45 <CakeProphet> know plenty about CA, but not the other two. I'll check them out.
13:44:03 <CakeProphet> the interesting thing about befunge-like languages such as this is that the possibility for self-modifying code exists.
13:44:08 <lispy> CakeProphet: http://education.mit.edu/starlogo/
13:44:52 <CakeProphet> an easy way to synchronize is to round-robin schedule one instruction step at a time.
13:45:10 <CakeProphet> so essentially every thread is guaranteed to advance forward on the grid at a fixed rate.
13:45:45 <arcatan> i'm trying to use ByteStrings with OverloadedStrings, but get complains about "No instance for (Data.String.IsString ByteString)"
13:46:17 <CakeProphet> arcatan:  could you create your own instance?
13:46:29 <mauke> arcatan: you need to import the instance
13:49:44 <CakeProphet> lispy:  this star logo thing is interesting. You know I could possibly extend the threads to being finite-state-machines rather than simply word or byte cells.
13:49:57 <CakeProphet> that can react to events.
13:52:26 <arcatan> mauke: thanks, now it works
13:55:36 <chrisdone> heh, i joined #haskel and it redirected me here
13:56:44 <lispy> CakeProphet: starlogo isn't all that well known, but it's very cool.  And very efficient at what it does
14:01:19 <Phyx-> lispy: i came up with this http://phyx.pastebin.com/P2ZBn6BB a simplified version. and the Env I can pass around
14:02:10 <CakeProphet> hmmm, I think I understand comonads... sort of
14:02:14 <CakeProphet> just not what they're used for.
14:02:24 <CakeProphet> but by looking at the type compared to Monad I see the key difference.
14:02:41 <benmachine> the arrows all go the other way?
14:02:45 <lispy> Phyx-: cool.  One thing you might want to change is that modifyIORef is lazy.  You very likely want a strict version
14:03:23 <CakeProphet> benmachine:  you are speaking to someone who knows almost nothing about category theory
14:04:16 <Twey> CakeProphet: He was being quite literal, if rather whimsical :þ
14:04:19 <benmachine> CakeProphet: so are you :)
14:04:21 <danharaj_> Yay for spain!
14:04:55 <Phyx-> lispy: which one is the strict version? reading and writing?
14:04:57 <CakeProphet> ...I'm just trying to figure out the "killer app" fpr comonads..
14:05:04 <ManateeLazyCat> Spain win!
14:05:05 <CakeProphet> but it's not arising.
14:05:14 <ManateeLazyCat> 116 minutes
14:05:19 <Phyx-> whoohoo go Spain
14:05:21 <soupdragon> has anyone read KNUTH
14:05:29 <soupdragon>  Simple word problems in universal algebras 
14:05:33 <Twey> CakeProphet: Monad has ‘join :: m (m a) -> m a’ and ‘pure :: a -> m a’; Comonad has ‘unjoin :: m a -> m (m a)’ and ‘extract :: m a -> a’
14:05:46 <Twey> Or cleverer mathematical names
14:05:57 * hackagebot sendfile 0.7.0 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.0 (JeremyShaw)
14:06:05 <soupdragon> Monad has  join :: m (m a) -> m a
14:06:17 <soupdragon> Comonad has cojoin :: m (m a) <- m a
14:06:23 <benmachine> heh
14:06:27 <ManateeLazyCat> I need sleep.... 5:00 am
14:06:37 <tensorpudding> conjoin?
14:06:52 <benmachine> and extend :: (w a -> w b) -> (a -> w b) -- cf. (=<<)
14:07:20 * benmachine thinks the tendency to use w for comonads is cute
14:07:37 <CakeProphet> ha. yeah I noticed that.
14:07:41 <CakeProphet> but WHAT IS THE APPLICATION
14:07:45 <CakeProphet> I understand all of this.
14:07:54 <CakeProphet> but not where that could be useful to abstract.
14:08:04 <soupdragon> the category Hask has Monad
14:08:12 <soupdragon> the category Hask^op has Comonad?
14:08:25 <CakeProphet> soupdragon: that means nothing to me. I don't know category theory.
14:08:31 <tensorpudding> Comonads are useful for modelling streams, so I hear
14:08:37 <soupdragon> but Hask is not isomorphic to Hask^op so I don't see how to reconcile this
14:08:38 <CakeProphet> I'm talking about programming applications, not theoretical.
14:08:47 <danharaj_> Hask has monad and comonad
14:08:58 <soupdragon> how can we get comonad from monad
14:09:00 <soupdragon> using duality
14:09:16 <danharaj_> You just reverse the arrows in the definition of monad.
14:09:47 <nus> "Show me coburritos!"
14:10:01 <CakeProphet> tensorpudding:  I suppose a stream would fit the model.
14:10:03 <soupdragon> is there a functor Co : Hask -> Hask
14:10:21 <soupdragon> no there isn't..
14:11:33 <Phyx-> lispy: you mean i should use atomicModifyIORef  instead?
14:11:44 <Phyx-> :t (id &&&)
14:11:45 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
14:11:50 <Phyx-> :t (id ***)
14:11:50 <lambdabot> forall b b' c'. (b' -> c') -> (b, b') -> (b, c')
14:11:58 <Twey> nus: It's like a burrito, but with the tortilla on the inside.  ;)
14:12:10 <lispy> Phyx-: no, that's different
14:12:24 <Twey> :t (id ***, second)
14:12:25 <CakeProphet> > tails ([1,2,3])
14:12:25 <lambdabot>     A section must be enclosed in parentheses thus: (id ***)
14:12:26 <lambdabot>   [[1,2,3],[2,3],[3],[]]
14:12:32 <Phyx-> can't see any other function to modify IORef
14:12:32 <Twey> :t ((id ***), second)
14:12:33 <lambdabot> forall b b' c' (a :: * -> * -> *) b1 c d. (Arrow a) => ((b' -> c') -> (b, b') -> (b, c'), a b1 c -> a (d, b1) (d, c))
14:12:40 <tensorpudding> Monads are useful because they abstract a common pattern, but the pattern that comonads use seems to be less popular
14:12:40 <lispy> Phyx-: http://osdir.com/ml/haskell-cafe@haskell.org/2009-06/msg00886.html
14:12:41 <CakeProphet> > jeads [1,2,3]
14:12:42 <lambdabot>   Not in scope: `jeads'
14:12:44 <Twey> That's a very helpful error, though
14:12:45 <CakeProphet> > heads [1,2,3]
14:12:46 <lambdabot>   Not in scope: `heads'
14:12:51 <CakeProphet> ...haha
14:12:54 <CakeProphet> heads = id ?
14:12:57 <Twey> CakeProphet: Yep
14:13:08 <CakeProphet> instance Comonad [a] where (=>>) w f = map f (tails w)
14:13:12 <nus> Twey, hah, now gimme "Coburritos are like comonads" tutorial (-;
14:13:18 <Phyx-> lispy: AH, nice thanks :)
14:13:26 <lispy> Phyx-: you almost always want to store evaluated things in IORefs and you almost always want to modify them strictly.  Unfortunately, this wasn't realized when the original api was written
14:13:42 <CakeProphet> but I have no what extract would be for [a]
14:13:57 <Phyx-> lispy: ah, think it's time for a Data.Strict.IORef :P
14:14:10 <lispy> Phyx-: so, we really need to have both lazy and strict variants for some things.  modifyIORef is a case where no amount of adding strictness to the update will make it a strict update.  You need modifyIORef' that simply does it strictly
14:14:40 <tensorpudding> if you only considered non-empty lists, head would be extract
14:14:41 <Phyx-> lispy: right
14:14:48 <benmachine> CakeProphet: infinite streams are often used
14:15:03 <CakeProphet> ah
14:15:04 <CakeProphet> so
14:15:16 <benmachine> data Stream a = Cons a (Stream a)
14:15:26 <CakeProphet> extract [] = Nothing
14:15:34 <CakeProphet> extract x = Just (head x)
14:15:46 <CakeProphet> ?
14:15:47 <CakeProphet> ...no
14:15:50 <Heffalump> eww
14:15:51 <CakeProphet> that doesn't match the type.
14:15:51 <tensorpudding> that won't be well-typed, you can't have maybe
14:15:59 <lispy> That Stream a is a codata version of [a], BTW (someone was just talking about comonads...)
14:16:06 <tensorpudding> you could you head for real, and get error whenever you do head []
14:16:25 <CakeProphet> I suppose.
14:16:40 <CakeProphet> that would be the case of "EOF" on a stream.
14:16:44 <CakeProphet> so it's appropriate.
14:17:00 * hackagebot sendfile 0.7.1 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.1 (JeremyShaw)
14:17:11 <CakeProphet> but I don't =>> w f = map f (tails w)
14:17:15 <CakeProphet> is going to be particularly useful
14:17:20 <CakeProphet> I was just playing around with what matched the type.
14:17:48 <soupdragon> does anyone know knuth-bendix algorthm
14:18:04 <soupdragon> i have no tunderstood this first content
14:20:47 <CakeProphet> what are other functions from [a] -> [[a]]  such as tails?
14:20:48 <CakeProphet> :t tails
14:20:49 <lambdabot> forall a. [a] -> [[a]]
14:21:05 <ezyang> @hoogle [a] -> [[a]] 
14:21:06 <lambdabot> Data.List inits :: [a] -> [[a]]
14:21:06 <lambdabot> Data.List permutations :: [a] -> [[a]]
14:21:06 <lambdabot> Data.List subsequences :: [a] -> [[a]]
14:21:16 <CakeProphet> subsequences [1,2,3,4]
14:21:21 <CakeProphet> > subsequences [1,2,3,4]
14:21:22 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
14:21:30 <CakeProphet> > subsequences "abc"
14:21:31 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
14:21:48 <CakeProphet> so any of those functions could be used for >>= instead of tails
14:22:06 <ezyang> CakeProphet: Not necessarily. 
14:22:11 <ezyang> You need to fulfill the monadic laws. 
14:22:17 <CakeProphet> > inits [1,2,3,4,5,6]
14:22:18 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6]]
14:22:35 <CakeProphet> ezyang:  what are the "co-monadic" laws?
14:23:03 <ezyang> why, take the monadic laws and flip all of the arrows :-) 
14:23:16 <CakeProphet> ...I don't know what that means in this context.
14:23:33 <soupdragon> too confusing I give up
14:23:53 <CakeProphet> no, not too confusing. I just don't have a very good explaination for what I know.
14:24:02 <ezyang> I know there are laws. I don’t know what they are (though I could probably figure them out with a little calculating) 
14:24:17 <CakeProphet> okay so what's...
14:24:49 <ezyang> what's... ? 
14:25:06 <CakeProphet> I'm trying to remember the monadic law for return being an identity of sorts.
14:25:34 <minh> I want to install xmobar....however I get an error: cabal: cannot configure xmobar-0.11.1. It requires base ==4.*
14:25:35 <CakeProphet> m >>= return  == m? 
14:25:35 <Twey> m >>= return = m; return a >>= f = f a 
14:25:43 <CakeProphet> there we go
14:25:44 <Twey> Right and left identities
14:25:49 <CakeProphet> so how do I "flip the arrows" of that?
14:26:00 <ezyang> We need to make it point-free. 
14:26:10 <soupdragon> you have to remember
14:26:12 * ezyang pulls up the sigfpe article 
14:26:13 <soupdragon> when we write something, say,
14:26:17 <soupdragon> (a -> b) -> (f a -> f b)
14:26:18 <soupdragon> in haskell
14:26:31 <soupdragon> this is not quite accurate
14:26:44 <Twey> I guess coreturn return =>> w = w; f =>> coreturn a = f a
14:26:44 <soupdragon> the truth is  (a >--> b) --> (f a >---> f b)
14:26:47 <soupdragon> or something like that
14:26:52 <Twey> For =>> as cojoin
14:26:55 <ezyang> mult' . (one <*> id) . lambda' = id 
14:27:03 <soupdragon> so you don't flip EVERY arrow
14:27:11 <CakeProphet> soupdragon:  ...what?
14:27:15 <CakeProphet> what is this new notation?
14:27:19 <soupdragon> and knowing which ones to flip is sometimes difficult, because the haskell code does not make it clear
14:27:47 <soupdragon> I'm just saying there is a distinction between different sorts of arrows, but it is not explicit in haskell
14:27:51 <ezyang> where lambda' x = Id x; rho' x = fmap Id x; alpha' = id; f <*> g = f . fmap g 
14:28:03 <CakeProphet> ah. what is the distinction? Or would that require too much explaining?
14:28:12 <ezyang> so, uh 
14:28:37 <CakeProphet> exDM69:  coreturn? Is that extract in the Comonad typeclass?
14:28:44 <Twey> Yes
14:28:49 <ezyang> lambda'r . (one'r <*> id) . mult'r = id 
14:28:49 <soupdragon> some arrows are functions, some are logical implication, some arrows are not even arrows -- for example a matrix is a linear transform but it's represented as a grid of numbers
14:29:09 <CakeProphet> hmmm, okay. aren't arrows in Haskell functions then?
14:29:37 <soupdragon> A whole bunch of difference concepts get turned into (->) when you translate them into haskell code
14:29:38 <ezyang> where one'r = coreturn, lambda'r (Id x) = x and mult'r = cojoin 
14:29:59 * ezyang wipes his brow 
14:30:05 * hackagebot darcs-benchmark 0.1.8 - Comparative benchmark suite for darcs.  http://hackage.haskell.org/package/darcs-benchmark-0.1.8 (EricKow)
14:30:21 <ezyang> The notion of arrow really makes the most sense when you have a commuting diagram in front of you, IMO. 
14:30:30 <Twey> CakeProphet: Functions are arrows; arrows are not necessarily functions
14:30:33 <ezyang> Then the arrows are literally the arrows in the diagram. 
14:30:49 <CakeProphet> Twey:  but in Haskell the only arrows you deal with are functions, right?
14:30:53 <Twey> CakeProphet: No
14:30:57 <ezyang> nope 
14:31:01 <CakeProphet> example?
14:31:02 <Twey> CakeProphet: See Control.Arrow
14:31:19 <Twey> CakeProphet: Umm, HXT uses an arrow-based framework
14:31:25 <CakeProphet> is Control.Arrow the notion of an arrow in category theory? I thought it was different.
14:31:34 <ezyang> I think it’s different. 
14:31:41 <soupdragon> nothing I said was any referece to Control.Arrow (which is an abomination)
14:31:45 <soupdragon> just to be clear
14:31:56 <CakeProphet> soupdragon:  alright.
14:32:20 <CakeProphet> I like Arrow. I think there are potential applications for DSP. Something I want to explore in Haskell.
14:32:22 <ezyang> Control.Category might be a little closer. 
14:32:27 <Twey> Oh okay.
14:32:27 * CakeProphet knows DSP much better than category theory. :P
14:32:39 <ezyang> Although it can only deal with categories (and objects and arrows) of a certain kind... 
14:32:41 <CakeProphet> ezyang:  I didn't even know such a thing existed. 
14:32:59 <CakeProphet> how is the distinction made formally? 
14:32:59 <ezyang> It’s not terribly interesting from an engineering POV 
14:33:23 <CakeProphet> and how do you know what to flip?
14:33:40 <CakeProphet> do I just need to read a book on category theory?
14:33:47 <ezyang> CakeProphet: No need. 
14:33:54 <CakeProphet> what if I want to know? :D
14:33:59 <ezyang> You just need to get to the pointer where you can understand commuting diagrams. 
14:34:05 <ezyang> Taken a linear algebra class, by any chance? 
14:34:09 <ezyang> *point 
14:34:16 <CakeProphet> ezyang:  not yet. Maybe next year.
14:34:26 * ezyang might be off base, someone should stab me and drag me to #haskell-blah in that case. 
14:34:38 <CakeProphet> for my math electives I was considering linear algebra and topology. Screw Calculus III
14:34:44 <ezyang> CakeProphet: So, after you get past the matrix multiplication and start talking about linear transformations 
14:34:51 <ezyang> you'll start seeing things that look awfully like Haskell types. 
14:35:04 <CakeProphet> but with dimensions I assume?
14:35:07 <ezyang> yes. 
14:35:14 <CakeProphet> ah
14:35:30 <ezyang> Commuting diagrams are pretty, and I wished I learned them earlier. 
14:35:31 <CakeProphet> but where is the distinction at?
14:35:48 <soupdragon> lol
14:35:51 <soupdragon> "Screw Calculus"
14:35:56 <CakeProphet> yep
14:36:05 <ezyang> soupdragon: :-P 
14:36:12 <mauke> don't end sentences with a preposition
14:36:14 <int80_h> hiya. I remember running across a url that outlined how to go about doing software development in haskell. Usings darcs , hlint etc. Does this ring a bell with anyone. I cannot find this url.
14:36:24 <CakeProphet> mauke:  What for?  :)
14:36:25 <mauke> "but at where is the distinction?"  <- fixed that for you
14:37:11 <benmachine> mauke: prepositions are fine things to end sentences with
14:37:30 <int80_h> mauke: what are youtalking about?
14:37:41 <mauke> about "at where" and how stupid it looks
14:37:50 <CakeProphet> haha. programmers have a very liberal sense of what makes correct grammar. :)
14:37:50 <ezyang> I think vector spaces = Haskell types; linear transformations = functions in Haskell 
14:38:01 <int80_h> heh, yeah that looks ridiculous
14:38:35 <ezyang> I should just learn Algebra, really, but I got scared away from that math class series :-. 
14:38:44 <mauke> does it converge?
14:38:52 <Twey> It's ridiculous because it was a ridiculous sentence to start with
14:38:53 <CakeProphet> hmmm...
14:38:58 <CakeProphet> I just don't understand which arrows to flip and which not.
14:39:08 <Twey> There's no need for the ‘at’ at all — it's implicit in the ‘where’ in English
14:39:22 <CakeProphet> Twey:  hey now. Stop analyzing my grammar. :P
14:39:32 <benmachine> a little analysis never did anyone any harm
14:40:09 * Twey gets out the biopsy needle.
14:40:15 <ezyang> CakeProphet: Maybe I should write a blog post about that :-) 
14:40:20 * benmachine puts it back in
14:40:25 <Twey> Heh
14:40:34 <CakeProphet> ezyang:  okay, go write about it on your blag.
14:40:49 <CakeProphet> let's see... I'm just going to ask a bunch of questions until some get answered. That way I can piece things together
14:40:52 <ezyang> I already have a nicely flamey article lined up for tomorrow 
14:41:06 <CakeProphet> What's an example of an arrow that does get flipped when constructing a co-something in Haskell?
14:41:08 <ezyang> CakeProphet: But will you ask the /right/ questions? :-o 
14:41:15 <CakeProphet> ezyang:  we'll see.
14:42:17 <ezyang> CakeProphet: The natural transformation 
14:42:32 <CakeProphet> ..and praytell what is that?
14:42:50 <ezyang> CakeProphet: Roughly, a polymorphic function. 
14:43:00 <nus> CakeProphet, http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html
14:43:04 <ezyang> Functor f, Functor g => f a -> g a 
14:43:17 <CakeProphet> nus:  Peano arithmetic right?
14:43:23 <ezyang> no 
14:43:32 <ezyang> the transformations got omitted from the filename ;-) 
14:43:38 <CakeProphet> data Nat = Succ a | Zero
14:43:56 <CakeProphet> Succ Nat
14:43:57 <CakeProphet> actually.
14:44:03 <msieradzki> C++ templates > peano arithmetic in data types used for 100th time
14:45:00 <CakeProphet> ezyang:  so you /don't/ flip the arrows if the function has a monomorphic type?
14:45:35 <nus> CakeProphet, from the url: "Category theory was more or less invented for natural transformations."
14:45:56 <ezyang> The monad typeclass doesn’t have monomorphic types 
14:45:58 <ezyang> but sure. 
14:47:28 <zzo38> BONUS:
14:47:58 <zzo38> The PDF has some pictures missing and some are important (and the text mentions it directly)
14:49:10 <CakeProphet> nus:  I followed it up to the first paragraph involving functors
14:50:11 <CakeProphet> The function that coverts a set X to X x X, or X x X x X forms part of a functor. The other part maps functions between sets to functions between containers. So we can work with the usual ordered pair functor L with LX = X x X and Lf(x,y) = (f(x),f(y)).
14:50:25 <CakeProphet> I just I've never seen this notation.
14:50:31 <CakeProphet> s/just/guess/
14:50:36 <ezyang> x = cartesian product 
14:50:41 <ezyang> you can substitute it with (,) 
14:50:46 <CakeProphet> right
14:50:48 <CakeProphet> but what is Lf?
14:50:55 <ezyang> f with the functor L applied to it 
14:50:57 <ezyang> fmap f 
14:51:00 <CakeProphet> ah.
14:51:17 <ezyang> Mathematicians don’t like pesky parentheses 
14:51:47 <CakeProphet> so Lf(x,y) = f(x,y) x f(x,y)?
14:52:22 <ezyang> no. 
14:52:42 <ezyang> In particular, we use cartesian products on types, not values. 
14:52:47 <CakeProphet> ah
14:52:50 <CakeProphet> so it's (,) instead of x
14:52:54 <CakeProphet> as the example uses. :P
14:53:05 <ezyang> Also, your lhs doesn't make sense 
14:53:18 <CakeProphet> (a,b) is a value of type a x b right?
14:53:40 <ezyang> sure. 
14:53:45 <CakeProphet> aka an element in the set a x b
14:53:57 <ezyang> Oh no, it’s your rhs 
14:54:06 <CakeProphet> rhs = right-hand side?
14:54:10 <ezyang> Lf = "fmap f"; f = "f" 
14:54:12 <ezyang> yeah 
14:54:29 <ezyang> f takes only one argument 
14:54:45 <CakeProphet> Lf(x,y) = (f(x,y), f(x,y))
14:55:04 <ezyang> nope 
14:55:04 <CakeProphet> L f = (,) `on` f
14:55:07 <CakeProphet> ...oh
14:55:32 <CakeProphet> ah
14:55:33 <CakeProphet> I see
14:55:39 <CakeProphet> f x and f y
14:55:43 <CakeProphet> missed that bit
14:56:01 <CakeProphet> but how does that work? How does both f(x,y) and f(x), f(y)  work?
14:56:16 <CakeProphet> or is (x,y) the arguments of Lf and not f?
14:56:20 <CakeProphet> *argument
14:56:32 <ezyang> it's Lf, not f. 
14:57:01 <CakeProphet> okay, so yeah. Lf's domain is X x X and f's domain is X
14:57:18 <ezyang> yes 
14:57:39 <CakeProphet> how do I say that L takes a function of a certain type and results in a function with a new type?
14:57:43 <ezyang> (note that fmap f :: [a] -> [b]'s domain is 1 + X + X x X + X^3 + ...) 
14:57:48 <CakeProphet> s/type/domain/
14:57:52 <CakeProphet> whatever term you prefer.
14:57:59 <ezyang> CakeProphet: They're different. 
14:58:14 <ezyang> the functor affects the domain and range. 
14:58:23 <CakeProphet> what is the notation for that effect?
14:58:25 <Veinor> ezyang: so its domain is 1/(1-X)?
14:58:32 <ezyang> Veinor: Yes :-) 
14:58:37 <ezyang> go go combinatorial species 
14:58:41 <CakeProphet> X -> X x X
14:58:44 <CakeProphet> ?
14:58:50 <ezyang> nope 
14:59:03 <CakeProphet> I'm just trying to figure out the notation of what I wanted to express. The english was verbose.
14:59:45 <ezyang> X x X -> X x X 
15:00:04 <ezyang> (X, X) -> (X, X) 
15:00:12 <ezyang> LX -> LX 
15:00:15 <CakeProphet> but how do you say what the domain of f must be?
15:00:21 <ezyang> that's the left side of the arrow 
15:00:28 <CakeProphet> the domain of f is X, not X x X
15:00:38 <ezyang> yes. 
15:01:48 <ezyang> it Haskell, things are automatically curried 
15:02:02 <ezyang> mathematicians will use cartesian products instead, if they don't need that machinery 
15:02:43 <CakeProphet> so X represents the domain of f
15:02:58 <ezyang> yes. 
15:03:15 <ezyang> X × X is the domain of LF 
15:03:17 <CakeProphet> L :: (x -> x) -> (x,x) -> (x,x)
15:03:24 <ezyang> Yes. 
15:03:30 <ezyang> and that’s just a specialized fmap. 
15:03:41 <CakeProphet> how do I notate that in the notation we've been using?
15:03:57 <CakeProphet> I want to describe the domain of L, not just Lf
15:04:06 <ezyang> So, that’s a tad tricky 
15:04:15 <ezyang> Since we overload L to be both the type operator and the value operator 
15:04:24 <ezyang> but, variously, L :: * -> * 
15:04:35 <ezyang> (actually, that’s still Haskell) 
15:05:09 <CakeProphet> ezyang:  what do you mean we overload L?
15:05:32 <ezyang> actually, I don't know if Piponi does it (doublechecks) 
15:06:02 <ezyang> Oh, he does. 
15:06:10 <ezyang> L : C -> D, where C,D are categories 
15:06:19 <ezyang> C=D=Hask, in the case of Haskell. 
15:06:39 <CakeProphet> hmmmm
15:06:49 <CakeProphet> so what is C?
15:06:54 <CakeProphet> the category of f?
15:06:55 <ezyang> A category. 
15:06:58 <ezyang> not of f. 
15:07:07 <ezyang> but f is a morphism inside C. 
15:07:12 <CakeProphet> ah okay
15:07:12 <ezyang> categories contain objects and morphisms 
15:07:19 <CakeProphet> so C is the "type" of f, sort of?
15:07:22 <ezyang> in Hask, fucntions are morphisms and types are objects. 
15:07:27 <ezyang> only sort of. 
15:07:40 <CakeProphet> C defines the relationship that f has with... stuff?
15:07:45 <ezyang> Correct! 
15:07:58 <CakeProphet> the more vague the wording, the better. :P
15:08:59 <ezyang> So, if I say L : C -> D is a functor 
15:09:39 <ezyang> that means I have some operation on morphisms (functions, i.e. fmap) and some operation on objects (types) that also hold by some laws. 
15:09:56 <ezyang> And then we’re lazy and say LT or Lf because by context we can ambiguate them. 
15:10:58 <CakeProphet> ezyang:  so LT is the application of L to any morphism?
15:11:11 <ezyang> erm, in that case, T was a type, and LT was the new type 
15:11:16 <ezyang> (T,T) in this case 
15:11:18 <CakeProphet> ah
15:11:28 <CakeProphet> so L is the type (,) in Haskell. :)
15:12:17 <ezyang> no! 
15:12:28 <ezyang> because (,) L = (L, ???) 
15:12:38 <ezyang> erm, 
15:12:42 <ezyang> (,) T = (T, ???) 
15:12:50 <ezyang> (,) :: * -> * -> * 
15:12:55 <tensorpudding> a functor takes types to types, and arrows to arrows
15:13:08 <bluetaslem> Could I get help seeing if there's something wrong with this?
15:13:16 <bluetaslem> (ser val lis ind+1) 
15:13:28 <bluetaslem> ser is a function, the others are values.
15:13:31 <tensorpudding> [] is a functor, it takes a type a to [a], and an arrow f to (fmap f)
15:14:02 <CakeProphet> tensorpudding:  so is a Functor in Haskell a functor in category theory?
15:14:07 <ezyang> Mostly. 
15:14:18 <danharaj_> If it satisfies the laws not enforced by the type system.
15:14:22 <ezyang> We can write things in Haskell that are categorical abominations 
15:14:30 <ClaudiusMaximus> bluetaslem: that gets interpreted as ((((ser val) lis) ind) + 1), maybe you meant (ser val lis (ind + 1))
15:14:33 <ezyang> and category theory can have functors that we can’t talk about driectly with the Functor typeclass. 
15:14:37 <sioraiocht> ezyang: as it should be!
15:15:19 <handonson> there's no "depthTest" in Haskell OpenGL. how can i do glDisable (GL_DEPTH_TEST); in Haskell?
15:15:23 <bluetaslem> I see.
15:15:42 <ClaudiusMaximus> @hoogle depth +opengl
15:15:43 <lambdabot> Could not find file:
15:15:43 <lambdabot>     opengl
15:15:43 <lambdabot> Searched:
15:16:28 <ClaudiusMaximus> handonson: depthFunc :: StateVar (Maybe ComparisonFunction)
15:16:49 <ClaudiusMaximus> handonson: maybe something like   depthFunc $= Nothing   would do the trick
15:17:01 <handonson> ClaudiusMaximus: No.
15:17:17 <handonson> ClaudiusMaximus: that is the equivalent of "glBlendFunc"
15:17:29 <handonson> oops
15:17:49 <handonson> i mean, glDepthFunc
15:18:11 <bluetaslem> Is it possible to see which functions were called with what arguments etc, in a Haskell file?
15:18:20 <bluetaslem> I'm trying to debug but can't figure out the problem.
15:18:58 <bluetaslem> Oh, never mind.
15:19:08 <handonson> what I'd liked to do is { depthTest $= Disabled }
15:19:13 <handonson> but there's no depthTest
15:19:13 <Peaker> debugging with GHC sucks
15:19:32 <Peaker> Fortunately much less of it is needed.. but it still sucks
15:20:24 <ClaudiusMaximus> handonson: yes, seems strange
15:20:50 <ClaudiusMaximus> handonson: maybe you could import the required functionality from OpenGLRaw
15:21:27 <ClaudiusMaximus> handonson: and submit a patch that adds the interface you want to the maintainer of OpenGL
15:21:46 <handonson> uhm
15:22:40 <handonson> i wanted to antialias polygons because the output was ugly. the OpenGL Red Book tells me that i have to first turn off the depth buffer to have control over how overlapping pixels are drawn
15:23:00 <handonson> which means depthTest is quite an essential StateVar for antialiasing
15:23:23 <handonson> amazing that this feature is missing in Haskell OpenGL
15:23:33 <ezyang> handonson: Submit a patch! 
15:23:41 <handonson> which makes me doubt
15:23:45 <handonson> is it really missing?
15:23:51 <ClaudiusMaximus> http://www.haskell.org/hoogle/?hoogle=%3a%3a+StateVar+Capability+%2bopengl
15:23:55 <ezyang> you should at least try grepping the codebase for a mention. 
15:24:43 <handonson> great idea.
15:24:54 <handonson> where usually is the codebase? (on linux)
15:25:04 <ClaudiusMaximus> cabal unpack OpenGL
15:25:28 <ClaudiusMaximus> (run in a directory where you don't mind creating a subdirectory with the OpenGL sources)
15:25:30 <handonson> don't i already have it somewhere?
15:25:43 <ClaudiusMaximus> that's easier than finding it :)
15:27:05 <cozachk> @src concatMap 
15:27:05 <lambdabot> Source not found. I feel much better now.
15:27:09 <cozachk> :(
15:27:53 <handonson> there it is ~/.cabal/lib/OpenGL-2.4.0.1
15:29:25 <chrisdone> @pl (concat .) . map
15:29:26 <lambdabot> (=<<)
15:29:30 <soupdragon> which topos can you build consturctive mathematics in?
15:30:22 <chrisdone> soupdragon: http://chrisdone.com/WHAT.gif
15:30:28 <ddarius> soupdragon: All of them.
15:31:01 <Tomsik__> sohum: intuitionistic logic, or is that not what you mean?
15:31:17 <soupdragon> I want to build a category theory like dependent type theory (to write proofs and programs) .. 
15:31:30 <soupdragon> but I don't know what axioms to use
15:34:37 <soupdragon> how can I find out how to do this :(
15:39:01 <ddarius> Bart Jacobs thesis and book has a lot on categorical type theory, but the thesis, at least, is not easy going.
15:40:42 <danharaj_> The book is pretty hard.
15:40:48 <danharaj_> I couldn't digest it, at least.
15:41:08 <handonson> or this could be why Graphics.Rendering.OpenGL doesn't have it. http://www.gamedev.net/community/forums/topic.asp?topic_id=410872
15:41:35 <handonson> but the thread says they're functionally different
15:41:38 <int80_h> What is the haskell way of doing something like #define FOO bar?
15:41:42 <handonson> or does it?
15:42:45 <Heffalump> int80_h: if you really need that, you need to use a preprocessor - either CPP itself, or cpphs which does a better job of dealing with Haskell's lexical syntax
15:43:20 <Heffalump> of course foo = bar would work if bar is just a value
15:44:03 <int80_h> ah thanks. Not sure if I really need it. I'm doing a haskell port of a c library. And I still think in C. So my initial attempot is likely to be all wrong and not haskell like at all. But once I have something I can come to the community for feedback.
15:44:48 <Peaker> int80_h, Usually simply foo = bar
15:46:49 <int80_h> I'm going to try foo = bar until it becomes clear I really need #define
15:46:55 <int80_h> thanks for your feedback :)
15:50:46 <handonson> ClaudiusMaximus, ezyang: yeah, i ended up actually making a patch.
15:51:11 <ezyang> Cool! 
15:51:16 <ezyang> \o/ open-source. 
15:54:27 <soupdragon> "Althuogh the definition of a fibration is not so difficult, it appears one does not obtain a practical 'working knowledge' or fibrations so easily"
15:54:48 <int80_h> Say I want to "define a macro (in the C sense" only in the case when the macro isn't define already. In other words, if I need to use #ifdef, does this mean I need cpphs? Or is there another way , the haskell way, to do this?
15:57:12 <prsteele`> Anyone mind helping with an IO question?
15:57:19 <Peaker> prsteele`, ask?
15:57:24 <ezyang> don't ask to ask 
15:57:31 <ezyang> ask = not ask 
15:57:46 <prsteele`> sorry; all I want to do is print out whatever value I'm returning in a function
15:57:53 <prsteele`> In addition to returning it
15:58:01 <geheimdienst> no try there is, young jedi. do, or do not, you must</yoda>
16:00:01 <geheimdienst> i suggest writing a little function that takes something, prints it, and returns it. then you can use that wherever you want
16:00:30 <prsteele`> I can manage that, but it always returns "IO a" rather than just "a"
16:00:45 <prsteele`> I understand the need for returning "IO a" when there's input, but I don't have any
16:01:02 <ezyang> prsteele`: >>= 
16:01:03 <danharaj_> Why don't you understand the need when there's output?
16:01:09 <ezyang> :t (>>=) 
16:01:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:01:14 <ezyang> or, specialized 
16:01:20 <ezyang> IO a -> (a -> IO b) -> IO b 
16:01:32 <geheimdienst> yes, and there's no way around it. if you want to use "print", the function is in IO. it will always return IO a, never a
16:01:36 <Peaker> prsteele`, IO is also used to mark things that have side-effect outputs, not just inputs
16:01:38 <danharaj_> prsteele`: Do you want to do logging in pure code?
16:03:04 <danharaj_> prsteele`: I have never done logging, but I'm sure someone in here can help you.
16:03:11 <slade118> showTrace?
16:03:17 <slade118> :t showTrace
16:03:19 <lambdabot> Not in scope: `showTrace'
16:03:23 <slade118> hmm
16:03:25 <slade118> :t traceShow
16:03:26 <lambdabot> Not in scope: `traceShow'
16:03:28 <slade118> pfft
16:03:32 <geheimdienst> @hoogle trace
16:03:33 <lambdabot> Debug.Trace trace :: String -> a -> a
16:03:33 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
16:03:33 <lambdabot> module Debug.Trace
16:03:54 <prsteele`> Debug.Trace looks like what I need, thank you so much
16:03:56 <slade118> traceShow :: Show a => a -> b -> b
16:04:11 <benmachine> Debug.Trace is for debugging, not output :P
16:04:12 <slade118> is what I was after
16:04:37 <prsteele`> well I'm really only doing debugging for now, so its a start
16:04:57 <ezyang> Debug.Trace may confuse you. 
16:05:02 <danharaj> warning: you can't rely on trace to give you things in any sane order.
16:05:10 <danharaj> That is what happens when you leave the safety of IO
16:05:18 <prsteele`> okay
16:05:25 <prsteele`> A follow up question, then
16:05:46 <prsteele`> if I have "foo n = print "asdf"
16:05:50 <prsteele`>     return 2*n
16:05:57 <mauke> prsteele`: syntax error
16:06:05 <prsteele`> then how do I do something like "2 * (foo 5)"
16:06:06 <jmcarthur> needs do
16:06:11 <prsteele`> sorry, yes
16:06:15 <ezyang> msysgit works fine. 
16:06:20 <ezyang> but crlf is a pain in the ass. 
16:06:27 <jmcarthur> (2 *) <$> foo 5
16:06:27 <mauke> prsteele`: foo n = print "asdf" >> return (2*n)
16:06:27 <geheimdienst> o rly
16:06:39 <mauke> prsteele`: foo 5 >>= \x -> return (2 * x)
16:06:44 <ezyang> wrong chan ^_^ 
16:06:45 <jmcarthur> (<$>) = fmap = liftA = liftM
16:06:45 <chrisdone> i was just reading dons's slides on engineering large projects, and someone commented that 100k lines of code is not a large codebase. what's the biggest haskell codebase you've worked on?
16:07:07 <Peaker> chrisdone, Haskell 100k is C's 2Mil
16:07:17 <Peaker> chrisdone, and 2Mil is large :)
16:07:21 <geheimdienst> exactly, peaker
16:07:38 <danharaj> It's like someone complaining about Spivak's Calculus on Manifolds because it is so short.
16:07:57 <geheimdienst> and comments like "100k is not large" are dangerously close to just a pissing contest
16:08:14 <chrisdone> i'm wondering, how does a codebase get so large without being separated into smaller components?
16:08:33 <danharaj> I'm sure that's not 100k for a single module.
16:08:56 <Peaker> chrisdone, lack of support for modularity in the core language, libraries, framework, etc
16:09:09 * jmcarthur has written a 1.2Kloc module, but hated it
16:09:40 <jmcarthur> it was just bashed out with intent to break it up later
16:09:53 <Peaker> my Haskell modules are ~60lines long on average
16:10:04 <jmcarthur> yeah that sounds about right for me too if you don't count that one
16:10:38 <jmcarthur> maybe closer to 100 lines
16:10:53 <jmcarthur> i should probably count
16:10:59 <chrisdone> yeah i usually start from one file and move into separate files when i'm seeing patterns
16:11:13 <Peaker> ~48 lines average in my current project
16:11:20 <danharaj> o.O
16:11:30 <danharaj> I think some of my modules get up to at least 100 lines of code.
16:11:34 <chrisdone> mine's probably about 200 max, 5 lines min
16:11:35 * geheimdienst ran find . -name "*hs" on the xmonad-contrib dir, and it's 32k apparently. however there's only one file > 1k, and that's Doc.Extending
16:11:47 <geheimdienst> 32kloc, obviously
16:11:49 <ezyang> ffi modules can run pretty long 
16:12:04 <slade118> does anyone have a recommendation for a haskell graphics library suitable for graphics noobs?
16:12:06 <chrisdone> one file i have here has 26 import lines
16:12:20 <Peaker> slade118, I like graphics-drawingcombinators
16:12:21 <jmcarthur> my 1.2Kloc module was a wrapper around OpenGLRaw that i just never broke up
16:12:42 <ezyang> hm. 400 lines each 
16:12:43 <jmcarthur> slade118: i second Peaker's suggestion
16:12:49 <ezyang> maybe I should refactor 
16:12:59 <slade118> thanks
16:13:05 <Peaker> I wish graphics-drawingcombinators had "crop"
16:13:14 <Peaker> I have no idea how you crop stuff in OpenGL
16:13:22 <Peaker> (2d-crop)
16:13:28 <jmcarthur> stencil?
16:13:45 <Peaker> jmcarthur, That sounds overly complicated?
16:13:50 * geheimdienst hands peaker scissors
16:13:53 <jmcarthur> nah
16:13:55 <int80_h> is it possible to load .cpphs files in ghci to play with?
16:14:04 <jmcarthur> opengl is overly complicated anyway
16:14:14 <jmcarthur> what's a cpphs file?
16:14:19 <Peaker> Poorly designed API yeah
16:15:13 <int80_h> jmcarthur it's a file that is supposed to be pre-processed and let's you use things like #define.
16:15:30 <int80_h> I want to load one into ghci and just see if it's working
16:15:33 <Peaker> int80_h, it's doubtful a newbie would need preprocessing in Haskell
16:15:39 <jmcarthur> int80_h: oh, files with a .cpphs extension are assumed to have -XCPP? i did not know that
16:16:11 <geheimdienst> aside, i sometimes see .hsc files in the xmonad source. what's the difference to .cpphs?
16:16:16 <int80_h> well, though I am a newb, I am trying to port a c liobrary to haskell. I was thinking I would need to do this anyway eventually and should learn to do it now.
16:16:41 <mauke> int80_h: port or wrap?
16:16:42 <jmcarthur> geheimdienst: .hsc means it will be processed by hsc2hs
16:16:46 <int80_h> port
16:16:55 <mauke> then why use cpp?
16:16:57 <jmcarthur> int80_h: you don't need #define to port anything
16:16:58 <int80_h> I could wrap but porting sounds more fun
16:17:05 <jmcarthur> you just write it in haskell
16:17:10 <geheimdienst> yeah i know, but what is .cpphs processed with?
16:17:16 <jmcarthur> geheimdienst: i assume CPP
16:17:25 * ezyang is convinced it’s a good first project. 
16:17:29 <ezyang> *isn’t 
16:17:32 <Saizan> Cabal will preprocess .cpphs files with cpp
16:17:50 <int80_h> mauke the library I am using makes use of many C macros. Initial study tells me I should leave this as - is until I find a better way. Therefore I need cpphs
16:18:04 <jmcarthur> int80_h: then you are wrapping, not porting
16:18:16 <geheimdienst> okay. kinda obvious :-) my question was a little stupid
16:18:36 <mauke> int80_h: that makes no sense to me
16:18:51 <mauke> you can't export macros from haskell modules, so how would your users access this?
16:19:30 <int80_h>  mauke, the users should not have to use any of the macros. The library I am writing will use them.
16:19:30 <Peaker> is it a problem to have a baseclass context restriction on a type family defined within the class?  class Blah (Foo f) => Class f where type Foo f  ?
16:19:42 <Heffalump> is there any good reason to use cpp rathe than cpphs, apart from the better integration of cpp with GHC?
16:19:42 <mauke> int80_h: what for?
16:19:46 <jmcarthur> mauke: if you are porting then you are rewriting. you should not be using the library that you are rewriting
16:19:54 <jmcarthur> mauke: sorry, wrong person
16:19:57 <int80_h> I am using cpphs, not cpp.
16:19:57 <jmcarthur> int80_h: ^^
16:20:02 <Heffalump> Peaker: I think I've done that and it works fine.
16:20:11 <Heffalump> I wouldn't swear to it though.
16:20:16 <Peaker> Heffalump, I hate that it requires Flexible contexts :(
16:20:29 <Heffalump> well, it fundamentally is a flexible context :-)
16:20:37 <illissius> Peaker: yeah, that's 'standard practice' more or less afaik
16:20:39 <handonson> i've just sent the patch to the maintainer. hope it gets accepted
16:20:44 <int80_h> jmcarthur, I am just using the library written in C as a model of what my library needs to include in terms of what needs to be calculated.
16:20:48 <jmcarthur> Peaker: what's wrong with FlexibleContexts?
16:20:50 <Peaker> illissius, thanks!  makes it easier to go ahead and do that
16:20:53 <Heffalump> the H98/H2010 type class language is quite impoverished, with some good reason
16:20:58 <illissius> if you want to do FD-like things with TFs that's basically how you do it
16:21:02 <Peaker> jmcarthur, almost all my code (except one module using ST) is Haskell98
16:21:08 <jmcarthur> int80_h: i still don't see why that means you need to *use* the library in your haskell code
16:21:20 <Peaker> jmcarthur, I'm thinking of taking TF's in
16:21:31 <Peaker> jmcarthur, But I am trying to find ways to do things the H98 way
16:21:33 <int80_h> oh I am not using it in my haskell code. Sorry for the confusion.
16:21:37 <jmcarthur> Peaker: i find sticking with h98 unnecessarily restrictive, personally
16:21:44 <jmcarthur> int80_h: then why use CPP?
16:21:53 <Peaker> jmcarthur, Only when it isn't too expensive (I used ST eventually)
16:22:03 <Phyx-> lispy: wow, using this method gave me a speedup of 2871.42%
16:22:06 <Phyx-> that's insane
16:22:11 <Peaker> good night
16:22:16 <lispy> Phyx-: nice!
16:22:18 <jmcarthur> nite!
16:22:25 <int80_h> not using cpp, using cpphs. I am going to include #define keywords in my header files. Until I find a better way.
16:22:37 <jmcarthur> int80_h: cpphs just means you're using cpp :P
16:22:51 <mauke> int80_h: what header files?
16:22:51 <int80_h> ooh I misunderstood the cpphs wiki page then
16:22:54 <jmcarthur> int80_h: what are you doing with #define? there should be no need for it whatsoever
16:22:55 <Phyx-> lispy: my test dropped from 44.22secs to 1.54secs . memory usage dropped drastically aswell due to reuse of the HscEnv
16:23:10 <geheimdienst> in80_h, i think we could help you better if you told us a little more about that library. the c macros that you want to port, what do they typically look like?
16:23:47 <jmcarthur> header files?!
16:23:51 <lispy> Phyx-: and it's still correct? :)
16:23:54 <int80_h> ah , okay here's is the library http://libnova.sourceforge.net/
16:24:08 <int80_h> and here's an example of why I think I need cpp
16:24:30 <int80_h> #if(!defined(M_PI_2) && (!defined(_MSC_VER) || !defined(_USE_MATH_DEFINES)))
16:24:30 <int80_h> #define M_PI_2          1.5707963267948966192313216916398
16:24:40 <Phyx-> lispy: yeah, well, the reason for the radical drop is mostlikely also that it now sees that nothing changed, so it's basically not reloading anything
16:24:42 <int80_h> oops missed the comment
16:24:47 <elitheeli> Hi, I'm having some issues with numeric types. What's the easiest way to get a list from 2 to floor (sqrt n)?
16:24:57 <jmcarthur> ah! build flags
16:25:00 <Phyx-> lispy: it's immediately moving on the the parsing part
16:25:01 <dons> lispy: what was the method?
16:25:06 <Heffalump> > (\n -> [2..floor (sqrt n)]) 10
16:25:07 <lambdabot>   [2,3]
16:25:19 <Heffalump> > map (\n -> [2..floor (sqrt n)]) [9..16]
16:25:20 <lambdabot>   [[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3,4]]
16:25:39 <jmcarthur> int80_h: you can use .hs instead of .cpphs if you put {-# LANGUAGE CPP #-} at the top of the file. that should also load properly in ghci
16:25:50 <Heffalump> elitheeli: the obvious list comprehension (as in my code above) looks fine to me
16:25:53 <int80_h> nice!
16:26:02 <int80_h> excellent I will try it out and see what happens
16:26:24 <lispy> Phyx-: I think Phyx- is using ghc-api to load code.  I suggested he store the HscEnv in a StablePtr so that it wouldn't have to load/link code everytime
16:26:27 <lispy> er
16:26:30 <lispy> dons: ^^
16:26:31 <int80_h> I was trying to be simple at first but it occured to me that these #define's were nessecary and I would end up putting them in anyway
16:27:05 <mauke> necessary for what?
16:27:27 <jmcarthur> i still wouldn't say necessary
16:27:29 <mauke> m_pi_2 = pi / 2
16:27:32 <mauke> bam!
16:27:38 <jmcarthur> int80_h: you realize of course that we have pi already ;)
16:27:44 <geheimdienst> i might be missing something here, but the example you pasted could be expressed in plain haskell i think. sometimes in C you need the preprocessor to avoid a performance penalty, but in haskell there's no need for the preprocessor
16:28:39 <Olathe> > let iSqrt 0 = 0; iSqrt n = let a = iSqrt (div n 4)*2; b = a + 1 in if b*b > n then a else b in map (\n -> [2..iSqrt n]) [9..16]
16:28:40 <lambdabot>   [[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3,4]]
16:28:54 <int80_h> jmcarthur : well yes, I was just giving an example.
16:28:57 <jmcarthur> > pi/2
16:28:58 <lambdabot>   1.5707963267948966
16:29:08 <jmcarthur> > pi/2 :: CReal
16:29:09 <lambdabot>   1.5707963267948966192313216916397514420986
16:29:44 <Olathe> > showCReal 100 (pi/2)
16:29:45 <lambdabot>   "1.570796326794896619231321691639751442098584699687552910487472296153908203...
16:30:06 <jmcarthur> > drop 100 $ showCReal 200 (pi/2)
16:30:07 <lambdabot>   "39910740432566411533235469223047752911158626797040642405587251420513509692...
16:30:13 <int80_h> jmcarthur : okay my #define of PI loads fine in ghci but I cannot seem to use it
16:30:16 <dons> lispy: good idea.
16:30:24 <jmcarthur> int80_h: right, because it's not a haskell value
16:30:36 <jmcarthur> int80_h: it makes more sense to just use haskell and not cpp for this
16:30:42 <geheimdienst> int80_h, an example: suppose C didn't have if/then/else. you can't implement it as a function because if(condition, something, something2) would evaluate everything, which is exactly what you don't want. in haskell however, because it is lazy, you have no trouble at all writing an if-then-else function. (gurus: is that right?)
16:31:18 <jmcarthur> geheimdienst: C still has short circuiting && and || operators
16:31:32 <lispy> dons: the other suggestion was using a strict modifyIORef
16:31:32 <int80_h> okay good, this is the kind of thing I'm trying to learn from this project. I'll just stick with haskell.
16:33:02 <dons> well, you should do that anyway.
16:33:04 <geheimdienst> jmcarthur, yes granted. however what i meant was implementing a function my_if(...)
16:33:15 <jmcarthur> geheimdienst: if it's possible to use && and/or || to implement if in C then it would still have to be a macro though, so you're right about that
16:33:16 <lispy> geheimdienst: lisp has the same problem
16:33:30 <jmcarthur> and of course there's also the ternary operator, which is closer to haskell's if anyway
16:34:00 <lispy> Right, Haskell's if sans the type checking
16:34:01 <Phyx-_> stupid internet
16:34:03 <Twey> geheimdienst: Yes, it's true.
16:34:06 <geheimdienst> (because ?: it returns a value, which is what haskell's if then else does)
16:34:49 <Phyx-_> lispy, dons basically i'm using these helper functions http://phyx.pastebin.com/mUfcDcn8 and passing the Context through FFI to store at the client side
16:34:54 <Twey> if :: Bool -> a -> a -> a; if True = const; if False = const id
16:35:19 <geheimdienst> @src if
16:35:19 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:35:38 * jmcarthur fusses with opengl some more
16:35:44 <handonson> Has anyone tried antialiasing polygons in Haskell OpenGL?
16:35:49 <lispy> Phyx-: modifyIORef env_value ((const val) $!)  <-- still not strict, BTW
16:36:15 <lispy> But, it doesn't always matter either...
16:36:26 <lispy> If you're not having a space leak, then maybe it doesn't matter
16:37:01 <Phyx-> heheh
16:38:30 <Phyx-> lispy: upon closer inspection, the trick works, but the api balks at it, it seems load doesn't check the module graph before loading, and just blindly adds to the graph. cauzing the module to be in the graph multiple times and cauzing an exception
16:38:56 <Phyx-> i'm gonna try and clear the graph, hopefully it does check the loaded modules info
16:39:41 <lispy> I was afraid something like that would happen
16:39:52 <lispy> In GHCi when you do :reload it does so from a clean slate
16:39:59 <Phyx-> lispy: how do i make that strict btw? (id$!) ?
16:40:02 <lispy> So, the api you're using probably does as well
16:40:32 <Twey> @src ($!)
16:40:32 <lambdabot> f $! x = x `seq` f x
16:40:41 <lispy> Phyx-: read all the way to the end of this email: http://osdir.com/ml/haskell-cafe@haskell.org/2009-06/msg00886.html
16:40:44 <Twey> x `seq` id x = x
16:41:03 <Phyx-> yeah, I hope it doesn't reload the interfaces when i clear the graph. but we'll see soon enough
16:41:08 <lispy> Phyx-: No matter what you pass to modifyIORef, it still retains some laziness.  You really have to modify the primitives it uses
16:41:31 <Phyx-> lispy: ah
16:41:34 <Phyx-> i missed that last part
16:41:35 <lispy> Phyx-: So you need a strict modifyIORef
16:42:54 <lispy> Phyx-: but, that's a lower priority than getting it working :)
16:43:01 <lispy> You can use the lazy one till you find it leaks
16:43:05 <Phyx-> lispy: yeah, gonna clear the mod graph now
16:43:50 <CakeProphet> what's a good Parsec tutorial?
16:46:04 <Saizan> the parsec tutorial
16:46:23 <Randroid> CakeProphet: Trial and farking error is what I used, though I tend to use REBOL (sacrilege!) instead of Haskell/Parsec when doing custom DSLs.
16:46:56 <Saizan> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html <- it's about parsec-2, but shouldn't be so hard to port to parsec-3
16:46:58 <wli> > let isqrt' n (a, b) | b <= a + 1 = (a, b) | otherwise = let c = (a + b) `div` 2 ; ts = [(x*x+n) `div` (2*x) | x <- [a,b,c]] ; abscissae = sort . nub $ a : b : c : [x | x <- ts, x > a && x < b] ; candidates = [(u, v) | u:vs <- tails abscissae, v <- vs, u*u <= n, v*v >= n] in isqrt' n $ minimumBy (comparing . uncurry $ flip (-)) candidates in isqrt' 300 (1, 300)
16:46:59 <lambdabot>   (17,18)
16:47:09 <handonson> CakeProphet: the Parsec section of RWH helped me a lot. http://book.realworldhaskell.org/read/using-parsec.html
16:47:51 <handonson> CakeProphet: with that chapter, I am now more comfortable with Parsec than regex.
16:50:57 <benmachine> parsec is awesome
16:51:31 * wli isn't sure how much (if at all) all that stuff helps.
16:54:45 <CakeProphet> do I want Text.ParserCombinators.Parsec?
16:54:49 <CakeProphet> or Text.Parsec?
16:55:12 <handonson> Text.Parsec is newly added in Parsec 3 afaik
16:55:43 <CakeProphet> ah.
16:56:27 <handonson> and I assume there's a reason when they add something new
16:57:03 <handonson> the library design of Text.Parsec is more.. uhm.. generalized? i think
16:57:57 <handonson> the RWH Parsec section uses Text.ParserCombinators.Parsec, but its examples (at least the ones I tried) work perfectly fine with Text.Parsec
16:59:16 <handonson> i think you already know this since you're asking about Text.Parsec, but just in case - you have to force your cabal in order to install Parsec 3. 2 is the default in cabal
16:59:18 <CakeProphet> many :: GenParser tok st a -> GenParser tok st [a]
16:59:22 <CakeProphet> I don't understand this type signature
16:59:23 <CakeProphet> because
16:59:32 <CakeProphet> GenParser has two type parameters
16:59:33 <CakeProphet> not three.
16:59:40 <Phyx-> lispy: works now, only a 517.79% improvement now, which is more reasonable i suppose :P but still significant
16:59:42 <CakeProphet> according to Hackage.
16:59:55 <benmachine> CakeProphet: cite your sources!
17:00:08 <CakeProphet> type GenParser tok st = Parsec [tok] st
17:00:21 <CakeProphet> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-ParserCombinators-Parsec-Prim.html#t%3AGenParser
17:00:31 <benmachine> ah
17:00:37 <Phyx-> lispy: because I know that only 1 module changed (guaranteed, I can just call "removeTarget (targetId target)")
17:01:02 <benmachine> Parsec [tok] st :: * -> &
17:01:02 <benmachine> er
17:01:04 <benmachine> Parsec [tok] st :: * -> *
17:01:09 <Phyx-> which seem safe, as in doesn't crash when the target isn't found
17:01:14 <benmachine> it's not a type it's a type constructor
17:01:15 <handonson> CakeProphet: think about { inc = (+) 1 }
17:01:53 <handonson> CakeProphet: it may look like a function that doesn't take any argument at all at the first glance, but you know in fact it does take one argument
17:02:24 <CakeProphet> ah wait
17:02:25 <handonson> the fact gets clearer if you write it like { inc x = (+) 1 x }
17:02:29 <benmachine> type GenParser tok st a = Parsec [tok] st a -- same thing
17:02:30 <CakeProphet> I think I was looking at a different version from the one I was using
17:02:35 <CakeProphet> http://cvs.haskell.org/Hugs/pages/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html#t%3AGenParser
17:02:39 <CakeProphet> says that GenParser has three parameters
17:02:52 <lispy> Phyx-: yeah, 500+% change is definitely significant
17:03:20 <benmachine> CakeProphet: so does the other thing you pasted!
17:03:27 <benmachine> it's just that one of the parameters was implicit
17:03:27 <handonson> CakeProphet: both versions of GenParser has three parameters
17:04:07 <CakeProphet> handonson:  ah I see.
17:04:17 <CakeProphet> it all tanslates to ParsecT, which has 4 parameters
17:04:29 <CakeProphet> Parsec s u = ParsecT s u Identity
17:04:37 <handonson> yeah eventually
17:04:52 <handonson> they're all just type synonyms
17:06:39 <CakeProphet> and CharParser is the type that's most convenient for traditional string parsers right?
17:06:59 <mtnviewmark> are Ashley Y or John Peterson about?
17:07:26 <mtnviewmark> The Haskell wiki is under siege
17:08:42 <Phyx-_> grrr my internet sucks
17:09:30 <Phyx-> ok, time to plug it in
17:09:36 <Phyx-> see how well it does in the IDE
17:11:13 <handonson> CakeProphet: you don't have to care about types at all in Parsec
17:11:39 <handonson> no, that's hyperbole
17:12:04 <handonson> well, just trust the type inference
17:12:47 <handonson> the (almost) only important thing you have to remember is that Parsec parsers are monadic functions
17:13:22 <handonson> so you use the same techniques that you used to combine IO functions
17:18:42 <CakeProphet> handonson:  well, I'm passing around state that holds a Map String (parser of some kind here...)
17:18:54 <CakeProphet> though I might not need it...
17:19:12 <nkpart> hey all, I'm putting together a cabalized package to distribute on hackage. It seems to me like I have to specify *every* module in my project in 'Other-Modules'. Is there another way?
17:19:13 <CakeProphet> basically I want to dispatch to multiple different parsers based on what the first word of a line is
17:19:23 <nkpart> It's an executable package
17:20:58 <CakeProphet> handonson:  so is this well typed?  type AsmParser = CharParser AsmState.  data AsmState = AsmState [String] (Map String (AsmParser))
17:21:30 <handonson> CakeProphet: you don't need that type at all, i think
17:22:00 <mtnviewmark> nkpart: nope, I think you have to
17:23:18 <handonson> CakeProphet: usually parsers have type like { ParsecT s u m a } but the only thing you have to care about (and specify if needed) is a
17:23:53 <handonson> CakeProphet: you normally don't touch the other three, whatever the thing you want to parse is
17:24:45 <CakeProphet> :t foldl
17:24:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:24:50 <mtnviewmark> nkpart: this might help you generate that:
17:24:52 <mtnviewmark> find src -name '*.hs' | sed -e 's:src.:    :' -e 's:/:.:g' -e 's:\.hs$::'
17:25:09 <CakeProphet> > (+) x [y,z]
17:25:10 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
17:25:11 <lambdabot>         against inferred ...
17:25:18 <CakeProphet> > (+) x [y,z] :: [Expr]
17:25:19 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
17:25:19 <lambdabot>         against inferred ...
17:25:23 <CakeProphet> > foldl (+) x [y,z] :: [Expr]
17:25:24 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
17:25:25 <lambdabot>         against inferre...
17:25:26 <CakeProphet> :P
17:25:38 <nkpart> champion, thanks mtnviewmark :)
17:25:52 <nkpart> I don't suppose I can embed that in the .cabal 
17:26:00 <mtnviewmark> nope
17:26:10 <CakeProphet> so if I want to fold <|> across a list of parsers... should I use foldl or foldr?
17:26:19 <mtnviewmark> but you find out soon enough if you forget one... 
17:26:28 <mtnviewmark> 'cause the tar ball won't build when unpacked
17:26:52 <CakeProphet> @src foldr
17:26:53 <lambdabot> foldr f z []     = z
17:26:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:26:55 <CakeProphet> @src fold
17:26:56 <lambdabot> Source not found. There are some things that I just don't know.
17:27:22 <handonson> CakeProphet: myParser = do { first <- many $ noneOf; case first of ... }
17:28:06 <CakeProphet> handonson:  what does many (noneOf) match on?
17:28:10 <handonson> oops
17:28:15 <handonson> many $ noneOf space
17:28:19 <CakeProphet> ah okay.
17:28:25 <CakeProphet> and then first is a string?
17:28:34 <CakeProphet> of the first word encountered?
17:28:57 <mtnviewmark> :t foldl1 (<|>)
17:28:58 <lambdabot> forall (f :: * -> *) a. (Alternative f) => [f a] -> f a
17:29:15 <mtnviewmark> actually, in the context of Text.ParserCombinators.Parsec
17:29:15 <mtnviewmark> that is
17:29:21 <mtnviewmark> foldl1 (<|>) :: [GenParser tok st a] -> GenParser tok st a
17:29:24 <mtnviewmark> so - yes
17:29:28 <mtnviewmark> fold away
17:30:24 <CakeProphet> handonson:  space includes newlines though, correct? That's not desired. How would I make a space that doesn't include line characters?
17:30:47 <handonson> CakeProphet: noneOf " \t"
17:31:28 <mtnviewmark> whitespace = skipMany (oneOf "\n\t ")
17:32:22 <mtnviewmark> well, replace with what ever whitespace chars you want in the string
17:32:26 <mtnviewmark> then it is useful to define
17:32:27 <mtnviewmark> lexeme p = do { r <- p; whitespace; return r }
17:32:29 <mtnviewmark> where
17:32:36 <mtnviewmark> lexeme :: Parser a -> Parser a
17:32:54 <mtnviewmark> so   lexeme foo   parses a foo, and skips all following whitespace
17:33:44 <handonson> CakeProphet: and yes, 'first' is a [Char]
17:33:51 <handonson> you can think of noneOf as { [Char] -> m Char } and many as { m a -> m [a] }
17:34:00 <CakeProphet> :t put
17:34:01 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
17:34:09 <danharaj> Conal Elliott has a soothing voice :p
17:34:42 <conal> :)
17:35:02 <conal> danharaj: are you watching one of my talk videos?
17:35:10 <handonson> CakeProphet: depend on <|> only when necessary
17:35:52 <mtnviewmark> dinnertime
17:37:09 * hackagebot UMM 0.3.0 - A small command-line accounting tool  http://hackage.haskell.org/package/UMM-0.3.0 (UweHollerbach)
17:38:13 <danharaj> conal: push pull frp talk from haskell symposium
17:38:22 <conal> ah.
17:38:51 <danharaj> I managed to finally get SDL + GL + GLUT (not freeglut though) to build on my windows box, so I want to start playing with frp-based interactive graphics.
17:39:01 <conal> nifty.
17:39:32 <danharaj> It's a bit harrowing getting bindings to work on windows. :\
17:39:33 <soupdragon> hey conal
17:39:34 <handonson> soothing voice? sounds like you get sleepy while watching the video...
17:39:38 <conal> i'm on mac these days, and have about given up on haskell for gui & graphics.  only seems to work well on linux.
17:39:47 <CakeProphet> does (.) have higher precedence than >>=?
17:39:48 <soupdragon> I tried to spivak 3 times and its too hard :( what shoud I do
17:40:01 <conal> soupdragon: yeah.  pretty tough going.
17:40:13 <danharaj> Is this calculus spivak or baby spivak or papa spivak?
17:40:34 <soupdragon> maracas on manifords
17:40:45 <danharaj> It's really hard.
17:40:49 <CakeProphet> @src (.)
17:40:49 <lambdabot> (f . g) x = f (g x)
17:40:50 <lambdabot> NB: In lambdabot,  (.) = fmap
17:40:59 <conal> CakeProphet: ghci's :i will tell you
17:41:23 <CakeProphet> 10 is the highest precedence right?
17:42:15 <conal> CakeProphet: yeah, and i think only juxtaposition (application) has prec 10
17:42:16 <handonson> or 11
17:42:45 <handonson> 10? i probably mixed up with some other language
17:43:01 <danharaj> haskell tap goes to 11
17:43:12 <handonson> what is tap
17:43:16 <prsteele> Question on memoization: if I have a function _primes :: (Integral n) => n -> [n] that correctly computes the list of all primes less than n, can I memoize repetetive calls with primes n = let _mem n = _primes n in _mem n ? It doesn't seem to do it this way...
17:43:19 <danharaj> a play on spinal tap
17:43:35 <danharaj> a fictional band from the comedic mockumentary 'This is Spinal Tap'
17:43:41 <CakeProphet> also, can I explicitly make a parse fail in Parsec?
17:43:45 <prsteele> Their amps go to 11
17:44:08 <soupdragon> bleghhhhh
17:44:17 <handonson> CakeProphet: fail
17:44:19 <soupdragon> theres no hope for me
17:44:26 <danharaj> soupdragon: Disagree.
17:44:34 <slade118> not quite fictional - they've toured since the film was released
17:45:08 <handonson> CakeProphet: myParser = (try someParser) <|> (fail "miserably.")
17:45:11 <danharaj> soupdragon: on which chapter do you get stuck?
17:45:17 <soupdragon> I dont remember
17:45:19 <Twey> No need for the brackets
17:45:23 <soupdragon> it was a whnile ago 
17:45:34 <danharaj> did you get stuck on the chapter on alternating tensors?
17:45:35 <CakeProphet> :t fail
17:45:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
17:45:39 <handonson> you mean parentheses?
17:45:39 <conal> prsteele: i don't see anything in that def that would memoize.
17:45:50 <soupdragon> probably.. if i even got there
17:45:59 <Twey> Parentheses are a type of bracket, yes
17:46:03 <soupdragon> I am not even sure
17:46:08 <soupdragon> whats the motivation for it anyway
17:46:16 <conal> prsteele: check out data-memocombinators and MemoTrie on hackage
17:46:18 <danharaj> ah well, just have another go at it some time later
17:47:06 <CakeProphet> handonson:  How would I do "satisfy one or zero occurances of this character"
17:47:08 <Cale> soupdragon: What's up?
17:47:14 <Cale> soupdragon: Calculus on Manifolds?
17:47:37 <handonson> CakeProphet: try $ char 'x' ?
17:47:38 <soupdragon> yeah I read another person saying how it changed their whole understand of mathematics
17:47:49 <soupdragon> and I was thinking I should try and work through ti again
17:47:57 <soupdragon> but I don't really think there's any point
17:48:04 <soupdragon> because I will not manage
17:48:14 <lispy> soupdragon: manifolds are pretty deep mathematically, IIRC
17:48:46 <lispy> I never made much of an effort as I'm more interested in algebra, but it sounded very complicated when I went to a seminar about them
17:48:57 <soupdragon> I want to learn all of mathematics
17:49:09 <soupdragon> but I am not very skilled so it is difficult
17:49:44 <Cale> soupdragon: I'm not sure quite how far along you are, but Spivak's other book, "Calculus" is rather good.
17:49:47 <handonson> CakeProphet: or { do { s <- (char 'x' >> return True) <|> (return False) ; if s then ... else ... } } -- a little redundant
17:49:53 <prsteele> Anyone like to take a stab at explaining the following to me? "memoized_fib :: Int -> Integer
17:49:53 <prsteele> memoized_fib =
17:49:53 <prsteele>    let fib 0 = 0
17:49:53 <prsteele>        fib 1 = 1
17:49:56 <prsteele>        fib n = memoized_fib (n-2) + memoized_fib (n-1)
17:49:56 <Cale> Calculus on Manifolds is good too, but it's more advanced
17:49:59 <prsteele>    in  (map fib [0 ..] !!)"
17:50:32 <CakeProphet> handonson:  so I've got. do {instruction; many(many newline >> instruction); eof}
17:50:41 <CakeProphet> does that sound right if instruction parses any valid instruction?
17:50:46 <wli> Spivak's differential geometry series is out there, too, if you're a Spivak fan.
17:50:57 <prsteele> More specifically, are repeated calls to memoized_fib stored, or is the speedup only on internal computations?
17:51:08 <soupdragon> prsteele: only internal
17:51:14 <Cale> prsteele: Lists don't make the greatest memo tables since it takes O(n) time to get to the nth element, but basically that's what's happening here. map fib [0..] is a list of the Fibonacci sequence
17:51:54 <handonson> CakeProphet: i think so. why don't you try running it
17:52:07 <wli> O(lg(n)) reduction to the range covered by the memo table is probably a good idea somewhere.
17:52:15 <CakeProphet> handonson:  well currently instruction fails on everything because I don't know the instruction set yet. :)
17:52:19 <soupdragon> whats differential geometry for
17:52:27 <Cale> prsteele: However, this memoised fib is a little shaky. It relies a bit on GHC lifting out constants.
17:52:35 <soupdragon> does it hap applications other than physics
17:52:37 <Cale> prsteele: Let's look at a similar one
17:52:42 <lispy> Cale: oh, is that the same Spivak that gave the "databases are categories too" talk?
17:52:45 <prsteele> thanks all
17:53:15 <Cale> prsteele:  fibs = map fib [0..];  fib 0 = 0; fib 1 = 1; fib n = fibs !! (n-1) + fibs !! (n-2)
17:53:32 <handonson> CakeProphet: maybe trivial, but do { first <- instruction; rest <- many (many newline >> instruction); eof; return $ first : rest }
17:53:32 <Cale> This is more reliably going to memoise, because fibs is a top-level constant.
17:53:52 <Cale> prsteele: Since it's a constant list, it won't be recomputed as long as it remains in scope.
17:53:53 <lispy> Cale: this gentleman http://www.uoregon.edu/~dspivak/
17:54:08 <Cale> Michael Spivak
17:54:19 <wli> No, it's a different Spivak, somewhere on the East Coast.
17:54:23 <handonson> so you can get the whole point of parsing.
17:54:29 <lispy> soupdragon: my opinion on learning math: http://blog.codersbase.com/2006/08/learn-math-10-tips.html
17:54:38 <lispy> soupdragon: may you find my tips helpful!
17:54:40 <pkrumins> click
17:54:45 <CakeProphet> handonson:  I'm using state monad to accumulate output. 
17:54:49 <lispy> Cale: ah
17:54:51 <CakeProphet> should I just use the return values?
17:55:18 <Cale> prsteele: Suppose we compute fib 10 now
17:55:22 <ddarius> lispy: Just stop at step 1.
17:55:38 <Cale> prsteele: That'll evaluate to fibs !! 9 + fibs !! 8
17:56:30 <Cale> prsteele: and once we get to the bottom of the recursion, elements of the list will start getting worked out, but once they're worked out, they won't need to be recomputed
17:56:31 <soupdragon> what I really want is a category theory programming language and proof language
17:56:37 <soupdragon> like dependent types except categories
17:59:13 <soupdragon> also i was going to program knuth bendix but the paper doesn't make sense
17:59:25 <handonson> CakeProphet: I have no idea, since I have never used the state monad. Sorry. Let's ask someone else.
17:59:32 <handonson> Hey everybody! Is using the state monad to accumulate output in Parsec a good idea?
17:59:46 <soupdragon> handonson: no
17:59:49 <CakeProphet> well, it seems natural for me so I think I'll stick with it.
18:00:02 <CakeProphet> well, actually.
18:00:03 <lispy> soupdragon: I think we have knuth bendix on hackage
18:00:10 <CakeProphet> I won't accumulate output. I'll just pass around a Handle.
18:00:10 <handonson> soupdragon: would you kindly elaborate
18:00:31 <soupdragon> handonson: parsers can take the state into account and that complicates things
18:00:54 <lispy> hmm, I see this http://www.kennknowles.com/blog/2007/12/20/infinite-lazy-knuth-bendix-completion-for-monoids-in-haskell/
18:01:44 <handonson> soupdragon: what if you just accumulate, and never 'read' from them
18:02:07 <soupdragon> handonson, but that's just a promise you don't know if its being kept for sure
18:02:26 <soupdragon> lispy I wanted to do it myself though 
18:02:50 <CakeProphet> :t modify
18:02:51 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
18:03:19 <lispy> soupdragon: hmm...in that case, maybe you should quote parts of the paper on haskell-cafe and ask questions about it?
18:03:39 <handonson> soupdragon: thank you very much.
18:03:41 <handonson> CakeProphet: a Handle? why? will some parsers I/O to that Handle?
18:03:44 <lispy> I bet people would like to help you with it
18:04:06 * lispy >>= outside
18:04:22 <ddarius> :t outside
18:04:23 <lambdabot> Not in scope: `outside'
18:04:35 <Twey> CakeProphet: Needs more iteratees
18:05:32 <CakeProphet> handonson:  er, nevermind. I realized that wouldn't work. I'll just keep the output as a string in state.
18:05:55 <ddarius> handonson: You could use ParsecT with a Writer monad underneath.  What "state" do you need to accumulate?  Why can't it just be part of the output?
18:07:02 <handonson> ddarius: :)
18:09:24 * hackagebot kit 0.2 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.2 (NickPartridge)
18:10:13 <handonson> CakeProphet: It is believed that that parsers are just for parsing, which is a 'static' process. It should only generate an 'abstract syntax tree' for further processing. So, just like all other non-I/O Haskell functions, a parser should take a string as input and return something, doing nothing else at all.
18:11:44 <handonson> Well, of course, sometimes you don't need the whole AST. The point is, you can do something 'less' than generating an AST, but you shouldn't do 'more' than generating an AST with a parser
18:12:00 <CakeProphet> what is "many or none" in Parsec?
18:12:13 <CakeProphet> try?
18:12:24 <Twey> ‘many’
18:12:26 <handonson> what do you mean by many or none?
18:12:31 <CakeProphet> ah. so many is many or none. :P
18:12:35 <Twey> The one-or-many version is called many1
18:12:42 <CakeProphet> okay. that works then.
18:14:30 <ddarius> CakeProphet: I highly recommend reading the Parsec Letter if you haven't alreaody.
18:15:23 <CakeProphet> hmmm...
18:15:34 <CakeProphet> so it's saying that GenParser Char st is not an instance of MonadState
18:15:42 <CakeProphet> do I need to import an instance?
18:15:51 <Twey> :i GenParser
18:16:03 <CakeProphet> > "Hello"
18:16:04 <lambdabot>   "Hello"
18:17:57 <handonson> oh yeah
18:18:16 <handonson> CakeProphet: while using Parsec, you may encounter the notorious MR
18:18:49 <CakeProphet> handonson:  would that be causing this problem?
18:19:57 <handonson> can you give me the exact error message? (use hpaste, you know, if it's longer than three lines...)
18:20:20 <CakeProphet> oh... I need to get using getState and setState
18:20:23 <CakeProphet> rather than get and put
18:23:49 <CakeProphet> er...
18:23:52 <CakeProphet> what encoding are Strings in
18:23:57 <Heffalump> am I right that if a .cabal file has one executable listed as buildable: false, but still has build-deps listed for that executable, then cabal still treats them as dependencies? (And actually gets even more confused: it fails to install them from 'cabal install' and then fails the build later)
18:24:18 <Zao> CakeProphet: String (as in [Char]) are lists-of-codepoints.
18:24:44 <CakeProphet> Zao:  so if I want to output as good ol' ASCII to a file, how do I do that? or does String do that anyways?
18:25:14 <CakeProphet> basically I'm writing a simple virtual assembler, so I'm outputting to a binary format.
18:25:26 <soupdragon> does anyone have a good description of knuth-bendix
18:25:30 <Cale> CakeProphet: If you want binary output, use ByteStrings.
18:25:44 <CakeProphet> do ByteStrings support ++? this is the only operation I use on Strings at the moment.
18:25:49 <Zao> CakeProphet: ByteString.Char8 might suit you somewhat, as you seem to want truncation.
18:25:55 <Cale> CakeProphet: You can also open files in binary mode, but it's probably more convenient working with ByteString anyway.
18:26:04 <Cale> CakeProphet: yep
18:26:05 <ddarius> :t Data.ByteString.append
18:26:06 <lambdabot> BSC.ByteString -> BSC.ByteString -> BSC.ByteString
18:27:09 <Cale> You might even want the non Char8 version of the module, which treats the ByteString as a sequence of Word8 numbers.
18:27:37 <Zao> Heh, I missed the binary format bit there, thought he was outputting assembly code :)
18:29:04 <soupdragon> "We introduce a general critical-pair/completion algorithm, formulated in the language of 
18:29:04 <soupdragon> category theory. It encompasses the Knuth–Bendix procedure for term rewriting systems 
18:29:05 <soupdragon> (also modulo equivalence relations), the Gr¨obner basis algorithm for polynomial ideal 
18:29:05 <soupdragon> theory, and the resolution procedure for automated theorem proving."
18:29:06 <soupdragon> interesting
18:30:05 * wli doesn't understand F4 or F5.
18:30:40 <soupdragon> hi psnively
18:30:49 <psnively> Hi there!
18:32:45 <soupdragon> "the Peterson–Stickel algorithm presented by Peterson and Stickel (1981), which extended the Knuth–Bendix procedure to the associative-commutative case, ..."
18:32:51 <soupdragon> this sounds much better
18:37:36 <soupdragon> omg there's a Rho cube as well
18:38:59 <soupdragon> oh it's basically the lambda cube with one letter replaced
18:41:51 <CakeProphet> is there a parsec function that retrieves the current line number?
18:41:59 <soupdragon> yes
18:42:50 <monochrom> yes. look harder. (busy now)
18:49:35 <soupdragon> yikes http://twelf.plparty.org/wiki/Zermelo_Frankel
18:49:39 <soupdragon> thats' impressivle
18:51:33 <Cale> soupdragon: That's a cute encoding of the ZFC axioms.
18:51:43 <danharaj> ZFC can never be cute >:|
18:52:02 <soupdragon> you forget that Cale eats foundations of mathematics for breakast
18:52:11 <Cale> Well, it makes the operations on sets explicit rather than implicit like most treatments.
18:52:17 <danharaj> It's part of this complete semantics.
18:52:40 <Cale> Which (at least for me ;) makes them easier to read
18:56:29 <soupdragon> I wonder if I ould write a proof checker for ZFC in haskell
18:57:16 <CakeProphet> is Data.Map.Lazy lazy in the keys?
18:58:00 <Cale> Data.Map.Lazy? From what package?
18:58:29 <ddarius> Cale: I'm not sure what you mean by "it makes the operations on sets explicit rather than implicit like most treatments?"
18:58:43 <CakeProphet> oh... so it doesn't exist?
18:58:55 <Cale> CakeProphet: Well, it might.
18:59:17 <soupdragon> What lambda calculus do I need to implement if I want classical first order logic?
18:59:25 <aavogt> @type lookup
18:59:26 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:59:30 <ddarius> CakeProphet: It wouldn't make sense to make a variant of Data.Map that's lazy in the keys, though you could possibly make some kind of map-like structure.
18:59:42 <Cale> ddarius: I mean the explicit declarations  empty, double, unions, powerset, replace, omega
18:59:45 <ddarius> soupdragon: None of them.
18:59:53 <soupdragon> :(
19:00:07 <soupdragon> I need a lambda calculus set theory
19:00:18 <danharaj> classical first order logic is not constructive is it?
19:00:21 <ddarius> @google "classical type theory"
19:00:22 <lambdabot> http://gtps.math.cmu.edu/har15.ps
19:00:30 <danharaj> and by that I mean it can't be embedded in intuitionistic first order logic.
19:00:50 <Cale> ddarius: Often you see treatments where there's a statement that says a set exists having the properties that are given those constructions, but this presentation explicitly names those set constructions.
19:01:22 <soupdragon> okay let me put it a differentw ay:  What's the quickest way to build a ZFC proof checker in haskelll
19:01:28 <soupdragon> from scratch
19:01:32 <ddarius> That paper is interesting for its generalized use of the . syntax.
19:03:01 <Cale> Old fashioned logic symbols :)
19:03:04 <danharaj> soupdragon: call the agda library :p </flippant>
19:03:55 <Cale> ddarius: You mean using dots to avoid writing parens?
19:04:00 <Cale> (over connectives)
19:04:39 <Cale> er, hmm
19:05:22 <Cale> Well, adjacent to connectives in its case :)
19:05:42 <soupdragon> there doesn't seem to be any good proof notation for FOL
19:06:16 <ddarius> Cale: Yes.
19:06:55 <ddarius> Kind of like what we'd write as 3 * $ 5 + 7 if that were legal.
19:08:42 <Cale> I've seen conventions where one uses multiple dots to indicate more and more loosely-binding versions of things.
19:11:47 <soupdragon> so if I do classical propositional logicl using simple lambda calculus and control operator is it possible to add forall and exist (so that I can add axioms of ZFC
19:17:16 <danharaj> Type checking first order logic is undecidable, isn't it?
19:17:42 <danharaj> withdrawing that statement.
19:17:50 <mlh> not sure? :-)
19:18:18 <soupdragon> $(\mu \beta.u)v \; \triangleright_c \; \mu \beta.u \left [ [\beta](w v)/[\beta] w \right ]$
19:18:27 <soupdragon> http://upload.wikimedia.org/math/d/c/3/dc31ca5d8b25b08a5dc46f65d9570d19.png
19:21:39 <soupdragon> anyone know where I can find Beyond BHK by: Adrian Rezus?
19:22:18 <danharaj> it's not on amazon.com?
19:23:51 * hackagebot roguestar-engine 0.4.0.2 - Sci-fi roguelike (turn-based, chessboard-tiled, role playing) game  http://hackage.haskell.org/package/roguestar-engine-0.4.0.2 (ChristopherLaneHinson)
19:24:53 * hackagebot roguestar-gl 0.4.0.2 - Sci-fi roguelike (turn-based, chessboard-tiled, role playing) game  http://hackage.haskell.org/package/roguestar-gl-0.4.0.2 (ChristopherLaneHinson)
19:24:55 * hackagebot rsagl 0.4.0.2 - The RogueStar Animation and Graphics Library  http://hackage.haskell.org/package/rsagl-0.4.0.2 (ChristopherLaneHinson)
19:32:41 <ddarius> sumsqdiff xs = sumsqdiff' xs 0 0 where n = length xs - 1; sumsqdiff' [] !acc !s = acc; sumsqdiff' (x:xs) !acc !s = sumsqdiff' xs (acc + n*x*x - 2*x*s) (s + x)
19:34:47 <CakeProphet> is State strict by default?
19:35:05 <ddarius> Define "strict" but the answer is probably "no."
19:35:54 <Cale> If you import Control.Monad.State you get Control.Monad.State.Lazy
19:36:21 <soupdragon> Gamma,phi[x := t] |- Sigma
19:36:22 <Cale> and regardless of which one you pick, the state itself can be lazily evaluated
19:36:28 <soupdragon> what the heck is t?
19:36:54 <ddarius> Some term presumably.  That look like only part of a rule.
19:36:55 <Cale> soupdragon: phi[x := t] means the formula phi with each free occurrence of x replaced with t
19:38:10 <Cale> all we can tell from just that bit is that t is the replacement for x ;)
19:39:30 <ddarius> Probably something related to an existential introduction (or dually a universal elimination.)
19:39:59 <ddarius> (Well probably the opposite of those if it is a left rule.)
20:07:38 <CakeProphet> @pl addLabel name = do {o <- getOffset; updateBuildMap (insert name o)}
20:07:38 <lambdabot> (line 1, column 20):
20:07:38 <lambdabot> unexpected "{"
20:07:38 <lambdabot> expecting variable, "(", operator or end of input
20:08:04 <soupdragon> getOffset >>= updateBuildMap . insert name
20:08:14 <CakeProphet> ah. thank you. :)
20:11:18 <danharaj> You know, it just occured to me how silly a soup dragon would be.
20:11:31 <danharaj> Would it be made of soup? Or would it breathe firey soup?
20:11:46 <soupdragon> x)
20:13:29 <o-_-o> hello
20:15:40 <Veinor> hi.
20:18:59 * CakeProphet is using knot-tying in his parser and it's BLOWING HIS MIND.
20:20:20 <ben> Haha
20:20:33 <ben> Read about knot-tying at one time, still not recovered
20:29:14 <o-_-o> haha I have so much to read in Haskell I will probably grow old before I am even half way
20:29:23 <o-_-o> heck
20:30:49 <o-_-o> so how is Aushac going ?
20:30:55 <o-_-o> is there a website for it ?
20:33:05 <ben> Whatever happened to haskell weekly news?
20:33:38 <blackdog> o-_-o: yeah, http://www.haskell.org/haskellwiki/AusHac2010
20:40:17 <Eduard_Munteanu> Hi.
20:40:48 <zachk> hello
20:53:32 <CakeProphet> bens: My assembler uses knot-tying to construct a map of labels to offset values
20:54:00 <CakeProphet> so that it can both translate intructions and interpret labels in one pass
20:55:28 <wli> CakeProphet: Assembler for what machine?
20:55:43 <CakeProphet> wli:  a virtual machine that I and others are working on.
20:55:57 <djahandarie> What does knot theory have to do with a parser?
20:56:08 <wli> CakeProphet: What's the virtual machine like?
20:56:09 * djahandarie would be interested in reading about that application
20:56:13 <CakeProphet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27329#a27331
20:56:26 <CakeProphet> wli:  dunno yet. :) still being made. But I've got the skeleton for an assembler
20:56:30 <CakeProphet> just need to fill in the instructions
20:56:49 <ddarius> djahandarie: Knot tying not knot theory.
20:57:06 <djahandarie> Oh, haha somehow misread that
20:57:27 <CakeProphet> ah... actually that's the wrong version
20:57:31 <CakeProphet> I thought I updated it
20:57:37 <Cale> Relating parsers and knot theory would be pretty awesome though.
20:58:47 <CakeProphet> here's the latest version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27329#a27333
20:58:52 <Cale> Probably something via braided monoidal categories if you're going to do it :)
20:59:01 <CakeProphet> the instruction set isn't implemented yet so I can't test it. Any recommendations are welcome.
20:59:33 <CakeProphet> the knot-tying occurs in parseAsm
20:59:57 <mtnviewmark> CakeProphet: you might consider the habit of type annotating all your top level declarations
21:00:00 <mtnviewmark> especailly your parsers
21:00:18 <CakeProphet> ah yeah. I prefer to do that when I'm finished. It is a good habit for type safety.
21:00:32 <CakeProphet> but I didn't in this case because it's still a draft.
21:00:42 <mtnviewmark> well, actually, it helps me keep my head straight as I'm coding parsers
21:00:56 <djahandarie> Cale, I know those are important in knot invariants but beyond that I'd have no idea how that'd help connect parsing and knot theory. What made you say that?
21:01:10 <mtnviewmark> also, I see that you are taking the tact of building up state as you parse, rather than having the parsers build up partial structures
21:01:39 <mtnviewmark> for example, I'd be inclined to have asmFile return a list fo Either Label Instruction   (or some such)
21:01:50 <mtnviewmark> and have instruction return an Instruction 
21:01:57 <mtnviewmark> (both, inside the Parser monad)
21:02:02 <Cale> djahandarie: You mean the quip about braided monoidal categories?
21:02:19 <djahandarie> Yeah
21:02:26 <mtnviewmark> then, in a separate pass, convert such a list into a ByteString
21:02:37 <CakeProphet> mtnviewmark:  it seemed more natural to use the State monad, especially with the helper functions.
21:02:44 <mtnviewmark> that would remove all the fiddily bits with state
21:03:31 <Cale> djahandarie: Well, not for any particularly *good* reason, but hey, we have parsing monads, maybe there are other categorical objects related in useful ways to parsing.
21:03:34 <mtnviewmark> well, I see a lot of lines of code dealing with state, and few with parsing
21:03:56 <Cale> djahandarie: and braided monoidal categories have an obvious tie-in with knots
21:04:03 <CakeProphet> mtnviewmark:  that's true. There was a lot of boilerplate unfortunately.
21:04:07 <djahandarie> Ah okay
21:04:22 <mtnviewmark> See, then I'd think that "assembling" would be a series of stages
21:04:55 <CakeProphet> mtnviewmark:  well yes, the output could be constructed with return values. But the maps and offset are probably best kept in state.
21:05:22 <mtnviewmark> [Either Label Instruction] -> [(Offset, Either Label Instruction)] -> (Map Label Offset, [(Offset, Instruction)]) -> ByteString
21:05:24 <mtnviewmark> say
21:06:08 <mtnviewmark> well, my point is that if you build them up with successive passes over the list, then you don't have to sort of carry them around --- and since it's lazy, in fact, the machinery of Haskell will do it all pipelined for ya
21:07:25 <CakeProphet> mtnviewmark:  You may have a point there. At this point I think I'd rather leave it the way it is. How would you tie the knot in that design?
21:07:29 <mtnviewmark> I'm thinking by analogy to how an AST is often successively "refined" into the compiled form
21:07:41 <mtnviewmark> what knot is there to tie?
21:08:22 <mtnviewmark> (sorry, came in after that part of the thread)
21:08:50 <CakeProphet> mtnviewmark:  oh. well buildMap and labelMap both represent the map of labels to offset values
21:09:00 <CakeProphet> but buildMap is what the parser constructs, and lableMap is what it refers to
21:09:10 <CakeProphet> labelMap is based in lazily as the result of buildMap /after/ parsing
21:09:16 <CakeProphet> s/based/passed/
21:10:00 <mtnviewmark> not sure I'm getting it --- don't you need a map of labels to offsets -- then a subseqent pass to generate instructions?   or is buildMap keeping track of where you need to "back insert" references?
21:10:48 <CakeProphet> mtnviewmark:  no it's done in one pass. Though the dataflow is effectively two passes I guess.
21:11:07 <CakeProphet> when label "instructions" are found, they're added to buildMap
21:11:16 <CakeProphet> when labels are referenced in gotos, labelMap is accessed
21:11:28 <CakeProphet> labelMap is buildMap after parsing has finished.
21:11:37 <CakeProphet> ...it's magic. :)
21:12:06 <mtnviewmark> so - what I'm suggesting is that trying to do all the bookkeeping is - well - busy work
21:12:25 <mtnviewmark> first question, are labels on instructions in your ASM langauge, or do that optionally annotate instructions?
21:14:22 * ddarius fixes his rhythm on "Spatter the Dew."
21:14:38 <CakeProphet> mtnviewmark:  they just mark offset points. I don't know the syntax will look like yet. but I assume you simply declare them above their entry point.
21:14:47 <mtnviewmark> so, you code this a multi-pass - which is generally cleaner in the code 
21:15:13 <mtnviewmark> so, I'd code the parser to produce, say    [(Maybe Label, Instruction)]
21:15:34 <CakeProphet> mtnviewmark:  I actually think the knot-tying approach saved conceptual work, as now I only need to work in a single pass.
21:16:04 <CakeProphet> the boilerplate wasn't bad at all.
21:16:06 <mtnviewmark> well - tell how you feel about that after coding up a dozen instructions
21:16:08 <mtnviewmark> :-)
21:16:14 <mtnviewmark> I think you'll find it is much more verbose
21:16:23 <ddarius> mtnviewmark: By tying the knot you magically make the multi-pass version single-pass.
21:16:53 <ddarius> Tying the knot is great for resolving forward references.
21:17:12 <mtnviewmark> okay - I await the code!
21:17:15 <mtnviewmark> :-)
21:17:28 <mtnviewmark> since, I bet, in this case, it'll be easier code the other way 
21:17:37 <ddarius> mtnviewmark: I made a minimal example on the Tying the Knot page a long time ago.
21:18:03 <mtnviewmark> and unless we are talking about Megabyte ASM files, no real difference in efficiency, time or space
21:18:08 * mtnviewmark goes to read
21:18:22 <ddarius> mtnviewmark: See the last code block on: http://haskell.org/haskellwiki/Tying_the_Knot
21:18:53 <ddarius> That particular example isn't quite as minimal as it could be because I'm demonstrating something else as wel.
21:19:01 <CakeProphet> mtnviewmark:  the actual code won't be done until a later date. The designer of the actual machine code hasn't completed it yet.
21:19:08 <CakeProphet> I just went ahead and saved some work for myself later.
21:19:41 <CakeProphet> I don't really think either approach will change the nature of the instruction code. I'll just have some helper parsers that I use to extract arguments, and then translate to machine code with the addOutput function.
21:19:50 <CakeProphet> which automatically increments offset for me.
21:20:52 <ddarius> mtnviewmark: Basically in a multi-pass approach, you have a pass that collects references and builds an appropriate mapping and then a second pass that uses that mapping to resolve references.  By tying the knot, you can fuse those two passes.
21:21:17 <mtnviewmark> sure - I get how it works
21:21:48 <mtnviewmark> it's just that, unlike the doubly-linked list case, there is no algorithmic need to do so
21:21:50 <CakeProphet> ddarius:  he's saying that using state instead of return values will be more tedious.
21:21:56 <CakeProphet> in Parsec.
21:21:57 <mtnviewmark> and I suspect the code will be longer
21:22:13 <mtnviewmark> correct- because such an approach requires state management
21:25:32 <ddarius> When using tying the knot for resolving forward references, you roughly have a Reader+Writer structure, not a State one.  I.e. you have something more like ReaderT LUT (Writer LUT) a v. State LUT a, though, of course those look the same when expanded.
21:25:34 <CakeProphet> mtnviewmark:  I've already managed the state by defining those utility functions. If I used return values I'd end up having to concatenate at multiple different points. With addCode and addOutput I simply accumulate as I go.
21:25:42 <ddarius> @unmtl ReaderT A (Writer A) B
21:25:42 <lambdabot> A -> (B, A)
21:25:47 <ddarius> @unmtl State A B
21:25:47 <lambdabot> A -> (B, A)
21:26:06 <CakeProphet> ddarius:  well, state is a reference to Parsec. which has a state monad feature.
21:26:06 <mtnviewmark> well, actually, things like many and so on in Parsec already accumulate for you!
21:26:50 <CakeProphet> ah. that's true
21:27:58 <CakeProphet> mtnviewmark:  but keeping track of an offset, I think, is easier with state. I have the offset increment inside addCode, and addOutput defined in terms of addCode. So each byte I accumulate will increment the offset automatically.
21:28:30 <handonson> CakeProphet: you should't end up having to concatenate at multiple different points. if so, the design is wrong.
21:28:44 <mtnviewmark> whereas I'd just do a fold over [(Maybe Label, Instruction)]
21:28:55 <CakeProphet> handonson:  yes. mtnviewmark showed me why that wouldn't occur.
21:29:12 <mtnviewmark> to get [(Offset, (Maybe Label, Instruction))]
21:30:00 <handonson> CakeProphet: you shouldn't keep track of an offset either
21:30:58 <CakeProphet> mtnviewmark:  how do you get Offset in the first place exactly? Wouldn't you have to pass around old offsets?
21:31:23 <mtnviewmark> foldl (\(off, out) (ml, ins) -> let s = instructionSize ins in (off + s, (off, (mi, ins)):out)) (0, [])  
21:31:33 <CakeProphet> handonson:  Oh I shouldn't? And how exactly do I associate labels to offsets if an offset is not "kept track of"?
21:32:39 <gio123> hi all, is there anyone fimilier with latex?
21:32:50 <Zao> Not in relation to Haskell, no.
21:32:56 <handonson> CakeProphet: getPosition
21:33:03 <Zao> Except for literate Haskell, of course.
21:33:19 <handonson> (if this is what you mean by offset)
21:33:53 <mtnviewmark> then      fromList $ catMabes $ map (\(offset, (ml, _)) -> maybe Nothing (\lab -> (lab, off)) ml)
21:34:27 <mtnviewmark> now you have a map of Labels to offsets
21:34:52 <mtnviewmark> then I'd re-write the Instructions to all have non-Label arguments
21:34:52 <CakeProphet> I don't know. I think it will look cleaner this way.
21:35:05 <mtnviewmark> and finally, generate the bytes with a simple concatMap
21:35:27 <gio123> hi all, is there anyone fimilier with latex?
21:35:37 <mtnviewmark> well - I'm curious now
21:35:45 <mtnviewmark> give me a few minutes and I'll code up a real version
21:35:54 <danharaj> gio123: Probably half the channel knows how to use latex to some extent. What's the question?
21:36:10 <danharaj> (but you should probably take it to #haskell-blah
21:36:54 <CakeProphet> the largest boilerplate section are the update* functions, but I can't really see a way to shorten them with Haskell's record syntax.
21:39:15 <handonson> CakeProphet: I think you can get rid of it entirely if you don't rely on state at all and generate a pure AST instead
21:40:01 <CakeProphet> handonson:  ...there's absolutely no need for a full AST for what is going to be a very simple grammar and instruction set.
21:41:04 <handonson> CakeProphet: an AST is nothing like some giant monster. ASTs should be generated for the simplest script languages, including assembly-level ones, as well
21:41:42 <handonson> CakeProphet: having a 'state machine' for a very simple grammar and instruction set is overkill, not generating AST is
21:42:14 <CakeProphet> okay, but the point of the state monad is to implicitly carry around what would otherwise need to be explicitly mentioned all the time. I have many such things that I'd like to implicitly carry around, so I used state...
21:42:57 <handonson> CakeProphet: I bet your code will get a lot simpler if you just generate a list, or a map, or a data type that contains some lists and maps
21:43:27 <handonson> besides, you usually don't need to "carry" around them in Parsec
21:43:34 <handonson> since you don't read them at all
21:43:42 <handonson> you're just appending new items, right?
21:44:19 <CakeProphet> the label map is read. offset is read too but it's just an incrementing number. 
21:44:40 <CakeProphet> it increments upon each output byte.
21:44:43 <pikhq> CakeProphet: Why are you using State? There are good reasons, I will grant, but you need to actually have a good reason for this. :)
21:45:28 <handonson> when is the label map read? do you read them when you have to insert a new pair?
21:45:45 <CakeProphet> handonson:  I read it when a label is encountered as an argument to an instruction.
21:45:53 <gio123> http://pastebin.com/Y5bfwNHF
21:45:58 <Lajla> gio123, hai
21:46:06 <handonson> CakeProphet: what? why? how?
21:46:17 <handonson> you mean like jump instructions, right?
21:46:41 <CakeProphet> at this point I don't really feeling justifying my reasons, because I don't need to. The suggestion is noted, however, but at this point I think it will just be too much work to reimplement the whole thing for the sake of not using state.
21:46:45 <CakeProphet> handonson:  right.
21:46:49 <CakeProphet> it converts the label to a byte offset
21:47:05 <handonson> but what's the point? maybe the label isn't parsed yet
21:47:15 <handonson> maybe it's at the end of the assembly code
21:47:19 <CakeProphet> it has been, lazily. I use something called knot-tying.
21:47:37 <gio123> Lajla: hi, could u see pm please
21:47:53 <CakeProphet> handonson:  would you like to see source or do you already have the link?
21:48:02 <handonson> i'm seeing it
21:48:56 <mtnviewmark> actually, where's the knot tying in that code?
21:49:04 <CakeProphet> mtnviewmark:  parseAsm
21:49:21 <CakeProphet> mtnviewmark:  at the bottom.
21:50:28 <mtnviewmark> I see it - I'm just wondering if it will work!  :-)
21:50:48 <handonson> I highly doubt that it will work...
21:50:48 <mtnviewmark> better make sure that offsets are dependent on the resolution of the labels
21:51:16 <mtnviewmark> (say, if, for example, the length of an instruction requires to know the size of the offset to the target)
21:51:57 <CakeProphet> mtnviewmark:  I believe all instructions will have the same byte size.
21:52:01 <CakeProphet> or something
21:52:04 <CakeProphet> I'm not sure what you're saying.
21:52:23 <handonson> CakeProphet: in compiler studies, they commonly suggest about five stages of compiling, and three or four of them are necessary for interpreting as well. ancient programming languages didn't have these separate stages, later resulting in a horrible bug-tracking hell
21:53:03 <CakeProphet> handonson:  I see...
21:54:00 <handonson> CakeProphet: the first three steps are lexical analysis -> parse -> (type check ->) semantic analysis, and it is considered almost necessary to separate the parsing phase and semantic analysis phase
21:55:43 <handonson> otherwise bugs are a lot more likely to appear
21:56:50 <CakeProphet> but I only need one..
21:57:03 <CakeProphet> really. I'm sure.
21:57:21 <handonson> you'll do the semantic analysis anyway in future, won't you?
21:57:36 <CakeProphet> not really. it's an assembler. the instructions pretty much map directly to the machine code.
21:57:49 <CakeProphet> *virtual machine code
21:58:09 <handonson> well that's called semantic analysis
21:58:16 <handonson> or at least part of it
21:58:17 <CakeProphet> ah, well then yes.
21:58:41 <CakeProphet> I thought semantic analysis involved things like optimizations and strictness analysis.
21:59:25 <handonson> why do you want to do this in one go? performance?
21:59:33 <CakeProphet> handonson:  no. simplicity.
21:59:40 <handonson> :(
22:00:31 <handonson> wait
22:00:35 <CakeProphet> the labels were the only reason to do two passes
22:00:41 <handonson> you're going to assemble the code
22:00:52 <handonson> which means you will be converting the code line-by-line
22:00:55 <CakeProphet> and a very smart friend of mine showed me how to do the knot-tying thing.
22:01:09 <handonson> this is already a two-go
22:01:09 <CakeProphet> handonson:  correct.
22:01:21 <CakeProphet> semantically it probably does two passes, yes
22:01:26 <handonson> and you can do the label-to-byteoffset conversion in the second go
22:01:53 <handonson> which makes a lot more sense, because the second go is about generating machine-friendly stuff
22:02:01 <CakeProphet> handonson:  yeah, but the lazy semantics allow me to treat it as one pass conceptually. Which I do, gladly. :)
22:02:56 <handonson> well...
22:03:05 * Lajla sneaks upon handonson and lays her eggs into him.
22:03:36 <ezyang> o.o 
22:03:55 <ddarius> CakeProphet: No, not tying does not just "hide" the second pass.  The end result is very similar to storing mutable references in the map and AST and then mutating them when the declaration shows up.
22:04:14 <tensorpudding> ooh, parasitic incubation
22:04:43 <CakeProphet> ddarius:  ah, so it is in fact one pass?
22:04:50 <djahandarie> ezyang, probably should not question. :P
22:04:50 <Lajla> tensorpudding, it will be a mess in 2 months or so, but gotta have young you know, biologial urge.
22:05:19 <handonson> what i'm surprised about is
22:05:27 <handonson> Lajla: are you 'her'?
22:05:38 <ddarius> CakeProphet: Yes.  The input AST is traversed only once.
22:06:52 <Lajla> handonson, I lay eggs, don't I?
22:07:12 <Lajla> But my species has five sexes, three of which lay eggs.
22:07:41 <Lajla> The combination of pairing results into the role of the young in our caste hive society.
22:16:05 <E5kr3St> l0l \x/uzzU|> ppl3z
22:19:52 <Axman6> what?
22:20:29 <o-_-o> after reading applicative functors I have the same feeling like I did going through high-school math
22:20:48 <o-_-o> I get all the little things
22:20:57 <o-_-o> but I am missing the big picture
22:22:00 <dmwit> The way I understand functor, monad, applicative, etc. is that there's a bunch of useful things that happen to fit into a pattern, and functor/monad/applicative is just the name for that pattern.
22:22:46 <dmwit> Or: the Applicative class is useless without the context of the various Applicative instances, and so you should study the instances, not the class
22:24:04 <Cale> o-_-o: The purpose for the Monad class, for example, is that it lets us write all the functions in Control.Monad, and whenever we find a new instance of Monad, we implement just return and (>>=), and we get all those functions for free.
22:24:44 <Cale> o-_-o: The reason for it is pretty much the same as with almost every programming abstraction ever: code reuse :)
22:24:47 <CakeProphet> @hoogle labelThread
22:24:47 <lambdabot> No results found
22:24:55 <CakeProphet> @hackage labelThread
22:24:55 <lambdabot> http://hackage.haskell.org/package/labelThread
22:25:02 <CakeProphet> er... no
22:25:11 <CakeProphet> where is labelThread defined?
22:25:35 <Cale> CakeProphet: uhh... context?
22:25:57 <aavogt> you can do  :info  labelThread   in ghci
22:26:00 <CakeProphet> Cale:  standard library. 
22:26:03 <CakeProphet> ah okay.
22:26:22 <CakeProphet> aavogt:  no I cannot actually.
22:26:27 <CakeProphet> have to be in scope.
22:26:30 <CakeProphet> *has
22:26:37 <Cale> Oh, it's in GHC.Conc
22:26:39 <aavogt> well you have it in scope somewhere right?
22:26:51 <aavogt> (otherwise you wouldn't know it exists)
22:26:52 <CakeProphet> no, I'm trying to find it
22:26:56 <CakeProphet> the whole point is that I want to import it.
22:27:00 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/GHC-Conc.html#v%3AlabelThread
22:27:08 <CakeProphet> I know it exists because I've read about it but didn't remember which module it was in.
22:29:17 <Cale> I'd never heard of it. GHC.Conc is GHC's internal interface to the concurrency stuff.
22:30:22 <Lajla> Cale, dey see me rollin, dey haitin.
22:33:49 <Quaffe> @pl f x = x*x
22:33:50 <lambdabot> f = join (*)
22:35:23 <o-_-o> ack...ick...
22:35:45 <ddarius> > join (*) 3
22:35:45 <lambdabot>   9
22:35:48 <o-_-o> the applicative functor tutorial links to a mailing list threadas
22:35:52 <o-_-o> thread*
22:36:01 <ddarius> o-_-o: So?
22:36:03 <Cale> o-_-o: yeah?
22:36:13 <o-_-o> in which a practical application of applicative functor is given
22:36:26 <o-_-o> but the mails are missing :-(
22:36:58 <Cale> o-_-o: What's the link?
22:37:00 <o-_-o> http://www.haskell.org/pipermail/haskell-cafe/2007-June/027536.html
22:37:17 <o-_-o> So I don't get what is happening :-)
22:38:10 <Cale> okay, that's weird
22:39:00 <o-_-o> hehe...also all the 'seeable' posts are people asking how to solve the problem with arrows and unseeable contain how to solve it...atleast some of them
22:39:16 <o-_-o> I think it was an html formatted e-mail and it got scrubbed
22:40:27 <kmc> o-_-o, you want a practical example of applicative functors?
22:40:29 <Cale> http://www.mail-archive.com/haskell-cafe@haskell.org/msg25736.html
22:40:37 <o-_-o> kmc, yes please
22:40:40 <Quaffe> @src join
22:40:40 <lambdabot> join x =  x >>= id
22:41:09 <Quaffe> > ((*) >>= id) 3
22:41:10 <lambdabot>   9
22:41:15 <o-_-o> Cale, cool thanks
22:41:17 <kmc> o-_-o, you know some practical uses of monads?
22:41:41 <o-_-o> kmc, yes like mAYBE and sTATE
22:41:43 <o-_-o> er
22:41:48 <o-_-o> Maybe and State
22:42:58 <o-_-o> I am kinda, sorta, type of...very very slowly... getting monads
22:43:11 <kmc> o-_-o, ok.  well monads are more powerful / more complicated than applicatives
22:43:21 <kmc> o-_-o, ok, so you've probably written do-blocks like «do x <- a; y <- b; return (f x y)»
22:43:27 <o-_-o> kmc, yes
22:43:29 <kmc> where x is not used in b
22:43:43 <o-_-o> yes
22:43:47 <kmc> you run a few actions, and combine the results with f, but you don't use the intermediate results to decide which actions to run
22:44:01 <kmc> so in fact we can write this as «liftM2 f a b»
22:44:27 <kmc> but it's ugly to have this whole family of functions liftM2, liftM3, liftM4, etc.
22:44:34 <kmc> and it doesn't really get to the core of what's going on
22:44:42 <kmc> so instead let's write «f <$> a <*> b»
22:45:37 <gweber> I am trying to automatically generate JSON from a data structure that contains UTCTime. Can anyone help me derive Data for UTCtime? 
22:45:37 <o-_-o> ok
22:45:42 <kmc> > (+) <$> [1,2,3] <*> [10,20,30]
22:45:43 <lambdabot>   [11,21,31,12,22,32,13,23,33]
22:45:56 <o-_-o> ok...wow
22:45:58 <o-_-o> hang on
22:46:07 <CakeProphet> kmc:  where are <$> and <*> defined again?
22:46:11 <kmc> Control.Applicative
22:46:21 <o-_-o> Control.Applicative
22:46:24 <o-_-o> ok
22:46:26 <kmc> > liftM2 (+) [1,2,3] [10,20,30]
22:46:27 <lambdabot>   [11,21,31,12,22,32,13,23,33]
22:46:36 <kmc> > do { x <- [1,2,3]; y <- [10,20,30]; return (x + y) }
22:46:37 <lambdabot>   [11,21,31,12,22,32,13,23,33]
22:46:40 <kmc> all equivalent
22:47:26 <kmc> so Applicative is, first, an alternative syntax for writing monadic code, an alternative to "do" or liftM
22:47:55 <kmc> but it turns out that there are some types which are in Applicative and not in Monad
22:48:09 <o-_-o> ok..yes..I read that too
22:48:11 <kmc> so it's more general / less powerful
22:48:29 <kmc> > (+) <$> [1,2] <*> [10,20]
22:48:30 <lambdabot>   [11,21,12,22]
22:48:34 <kmc> > (+) <$> ZipList [1,2] <*> ZipList [10,20]
22:48:35 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
22:48:35 <lambdabot>    arising ...
22:48:52 <kmc> > getZipList ((+) <$> ZipList [1,2] <*> ZipList [10,20])
22:48:53 <lambdabot>   [11,22]
22:49:04 <aavogt> what is power?
22:50:18 <Olathe> It's the stuff that comes from the power company.
22:50:26 <kmc> o-_-o, a practical example of this is parsers
22:50:54 <CakeProphet> @src ZipList
22:50:54 <lambdabot> Source not found. stty: unknown mode: doofus
22:51:04 <CakeProphet> @src Control.Applicative.ZipList
22:51:04 <o-_-o> kmc, yes I am reading the Parsec chapter in RWH
22:51:04 <lambdabot> Source not found. Wrong!  You cheating scum!
22:51:05 <kmc> lots of parser libraries like Parsec allow you to define parsers as monadic actions
22:51:16 <kmc> and when you do so, you can write context-sensitive grammars
22:51:24 <kmc> but if you restrict to Applicative syntax, you get context-free grammars
22:51:24 <Cale> aavogt: interface A is more powerful than interface B if all the primitive operations in interface B can be constructed from operations in interface A such that the laws for interface A imply the laws for interface B
22:51:31 <kmc> and a somewhat more direct / natural / declarative syntax
22:51:47 <o-_-o> ok../
22:52:00 <o-_-o> s/\//./g
22:52:36 <aavogt> Cale: A is more powerful than itself?
22:52:47 <Cale> I suppose ;)
22:53:03 <Cale> Perhaps I should say "not less powerful"
22:53:22 <danharaj> I think it should be "constructed efficiently"
22:54:11 <danharaj> because you might be able to construct the interface, but cannot give as good algorithmic complexity guarantees as the original.
22:54:12 <handonson> Can I, with GHC, compile for 64-bit linux on my 32-bit linux machine?
22:54:14 <o-_-o> so monadic actions in parsers make for context-sensitive grammars and applicative yields to context-free grammar ?
22:54:27 <aavogt> well power is F * d, so perhaps you need to consider how 'far' your operations 'force' can take you
22:54:58 <aavogt> the distance there being how many types your polymorphic function can work over
22:55:07 <o-_-o> rather it is possible to...
22:55:34 <aavogt> perhaps 'expressiveness' is what we're trying to describe
22:56:02 <o-_-o> ah...so applicative makes for more expressive ?
22:56:09 <o-_-o> or less expressive ?
22:56:11 <aavogt> less
22:56:13 <o-_-o> ok
22:56:20 <o-_-o> then why use it :-) ?
22:56:26 <aavogt> because it works for more types
22:56:31 <o-_-o> ah...ok
22:56:35 <o-_-o> right
22:57:40 <Cale> aavogt: It's the usual sort of power or strength for assumptions in mathematics. A is at least as powerful as B is another way of saying that A implies B.
22:58:27 <kmc> handonson, not easily
22:59:21 <kmc> o-_-o, it works for more types, and it may be a closer fit for what you actually want to describe
22:59:38 <kmc> monads allow you to use intermediate results to compute later actions; that's most of the point of "do" syntax
22:59:40 <mtnviewmark> which module has the instance of Monad for Either String ?
22:59:45 <aavogt> another reason you may want something less expressive is because you allow more transformations. Ex. why all code isn't in IO (hopefully).
22:59:47 <int80_h> how do I get pi to more digits than is provided in prelude by default?
22:59:48 <kmc> sometimes this is necessary, and sometimes it's a distraction
23:00:06 <int80_h> real :: pi or something similar?
23:00:23 <aavogt> Cale: I still think the analogy for that term is broken, as usual
23:00:43 <o-_-o> kmc, ok
23:01:14 <Jafet> int80_h: where will you put all those extra digits?
23:01:21 <o-_-o> anyone here from HP ?
23:01:44 <aavogt> you could put them in a Rational
23:02:17 <int80_h> I tried Rational :: pi in ghci, got a "not in scope" error
23:02:37 <aavogt> there are a few things wrong with that
23:02:42 <Axman6> int80_h: pi :: Rational
23:02:45 <int80_h> Would you tell me what?
23:02:51 <Axman6> > pi :: Rational
23:02:52 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
23:02:52 <lambdabot>    arising from a us...
23:03:03 <Axman6> ah, Rational's a class
23:03:08 <Axman6> @instances Rational
23:03:09 <lambdabot> Couldn't find class `Rational'. Try @instances-importing
23:03:14 <aavogt> > 1 :: Rational
23:03:15 <lambdabot>   1 % 1
23:03:16 <Axman6> huh
23:03:21 <Axman6> right
23:03:23 * wli I think it's a type synonym for Ratio Integer
23:03:27 <Axman6> :t toRational
23:03:28 <lambdabot> forall a. (Real a) => a -> Rational
23:03:29 <aavogt> pi isn't defined for Rational though
23:03:43 <Axman6> > toRational (pi :: Double)
23:03:44 <lambdabot>   884279719003555 % 281474976710656
23:03:53 <kmc> pi is irrational
23:04:09 <aavogt> int80_h: pi isn't a type (though it's not a syntax error because as you write it, it's a type variable like 'a')
23:04:17 <kmc> there's nothing in Prelude's treatment of numbers to get arbitrary rational approximations of irrational numbers
23:04:22 <Axman6> > pi CReal
23:04:23 <lambdabot>   Not in scope: data constructor `CReal'
23:04:26 <Axman6> > pi :: CReal
23:04:27 <lambdabot>   3.1415926535897932384626433832795028841972
23:04:36 * Axman6 did hit those :'s...
23:04:38 <aavogt> well we need to figure out where to put the extra digits
23:04:46 <int80_h> I thought I saw someone earlier show me another rep. of Pi. IUt may not have been from prelude however
23:04:46 <wli> >> :info Rational
23:04:47 <wli> type Rational = GHC.Real.Ratio Integer 	-- Defined in GHC.Real
23:05:11 <kmc> int80_h, basically you'll have to find or write a library which either a) provides rational approximations for irrationals, or b) has a type which can represent irrational reals exactly, with a Floating instance to get pi
23:05:13 <Jafet> > showCReal 100 pi
23:05:14 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
23:05:34 <kmc> CReal is such a type for (b); the HERA library on hackage provides a newer version of it
23:05:52 <int80_h> gotcha
23:06:28 <Axman6> > 1 / pi :: CReal
23:06:29 <lambdabot>   0.3183098861837906715377675267450287240689
23:06:46 <int80_h> pi :: CReal
23:06:52 <int80_h> meah
23:07:20 <int80_h> pi / 1 :: CReal
23:07:32 <int80_h> 1 / pi :: CReal
23:07:51 <int80_h> okay why doesn't lambdabot rteposnd to me?
23:07:55 <int80_h> respond
23:08:05 <o-_-o> Axman6, in AusHac 2010 the MPI binding that is the list of stuff that might be worked on
23:08:06 <Eduard_Munteanu> You're not asking him nicely
23:08:08 <Axman6> > 1+1
23:08:08 <Jafet> Because it's very literal.
23:08:09 <lambdabot>   2
23:08:20 <int80_h> > 1 / pi :: CReal
23:08:21 <lambdabot>   0.3183098861837906715377675267450287240689
23:08:21 <Axman6> o-_-o: what about it?
23:08:26 <int80_h> > pi :: CReal
23:08:27 <lambdabot>   3.1415926535897932384626433832795028841972
23:08:29 <o-_-o> http://www.foldr.org/~michaelw/hmpi/ here the page lists a newer version of it that works with latest version of ghc
23:08:41 <Eduard_Munteanu> '>' is like intercal's "please" for lambdabot :P
23:08:42 <Axman6> interesting
23:08:44 <o-_-o> here -> http://www.cs.utah.edu/~hal/software.html
23:09:06 <int80_h> okay when I try pi :: CReal in ghci I get "not in scope" do I need to load a particular module?
23:09:12 <o-_-o> rather later versions of GHC, I don't know if it works with latest version
23:09:24 <kmc> int80_h, yes
23:09:32 <int80_h> okay what do I need to load / install?
23:09:39 <kmc> Eduard_Munteanu, lambdabot is female
23:09:40 <o-_-o> Axman6, http://hal3.name/newhmpi.tar.gz
23:09:43 <kmc> @vixen what is your name?
23:09:43 <lambdabot> My name is Emily
23:09:50 <o-_-o> how does one find out it does
23:09:56 <Jafet> @nixon
23:09:56 <lambdabot> I believe in the battle-whether it's the battle of a campaign or the battle of this office, which is a continuing battle.
23:10:01 <Axman6> by installing it and testing it i guess
23:10:26 <Eduard_Munteanu> kmc: oh, then I must apologize
23:10:46 <kmc> that happens a lot on IRC
23:10:50 <kmc> @nixon
23:10:51 <lambdabot> I can see clearly now... that I was wrong in not acting more decisively and more forthrightly in dealing with Watergate.
23:10:54 <o-_-o> Axman6, ack...the tar untars everything into current directory
23:11:02 <Eduard_Munteanu> Heh.
23:11:08 <int80_h> how can I load CREal, what module do I need?
23:11:24 <int80_h> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
23:11:27 <int80_h> I found that ^
23:11:32 <int80_h> don't know how to use it
23:11:51 <kmc> int80_h, maybe you want the Data.Number.Real module from the HERA package on hackage
23:12:16 <kmc> int80_h, if all you really want is rational approxmitaions of pi, you can rip that out of the CReal source probably
23:13:37 <Quaffe> @instances Applicative
23:13:37 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
23:13:48 <int80_h> thanks :)
23:13:52 <Eduard_Munteanu> @vixen Could you ever forgive me?
23:13:54 <lambdabot> is that really what you want to know?
23:13:58 <o-_-o> @instances Control.Applicative
23:13:59 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
23:14:03 <o-_-o> @instances Control
23:14:04 <lambdabot> Couldn't find class `Control'. Try @instances-importing
23:14:05 <Eduard_Munteanu> @vixen Yes, of course.
23:14:06 <lambdabot> yeah, why not?
23:14:13 <Eduard_Munteanu> @vixen Thanks
23:14:14 <lambdabot> girls masturbate too you know... probably more than guys. we can do it anywhere discretely
23:14:20 <Eduard_Munteanu> lol
23:14:24 <jesusabdullah> o_o
23:14:29 <o-_-o> o_O
23:14:30 <o-_-o> nsfw
23:14:50 <CakeProphet> that's why they invented /clear  :)
23:15:00 <o-_-o> hehe
23:15:05 <o-_-o> I want a clear like tail
23:15:14 <Quaffe> @instances-importing Control.Applicative Applicative
23:15:15 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
23:15:15 <o-_-o> /clear 50
23:15:18 <o-_-o> or something
23:15:29 <o-_-o> just the last 50 lines should be cleared
23:16:00 <kmc> also "discretely"
23:16:25 <Eduard_Munteanu> Heh :).
23:16:35 <Quaffe> Is it possible to use @src to show the code for the Applicative instance of (-> a)?
23:16:41 <aavogt> yeah, you can't have fractions of lines left
23:21:03 <Axman6> @src (->) Applicative
23:21:03 <lambdabot> Source not found.
23:21:51 <Cale> Quaffe: Well, pure is const, and <*> is ap, or S: (f <*> g) x = f x (g x)
23:22:28 <Axman6> > (f <*> g) x
23:22:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:22:29 <lambdabot>    `SimpleReflect.FromExpr ...
23:22:35 <Axman6> > (f <*> g) x :: Expr
23:22:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:22:36 <lambdabot>    `SimpleReflect.FromExpr ...
23:22:40 <Axman6> :(
23:22:47 <int80_h> okay I just installed it with cabal install. but "import Data.Number.Real" doesn't work. Am I missing something?
23:22:55 <Axman6> > ap f g x
23:22:55 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:22:56 <lambdabot>    `GHC.Show.Show a'
23:22:56 <lambdabot>      a...
23:23:10 <Cale> int80_h: Doesn't work how?
23:23:21 <Cale> int80_h: Are you compiling with --make ?
23:23:26 <Lajla> handonson, are you keeping those eggs of mine nice and warm?
23:23:36 <int80_h> could not find module "Data.Number.Real"
23:23:53 <int80_h> no no trying to load in ghci
23:24:19 <Cale> int80_h: Okay, well, that ought to work if it's installed properly...
23:24:26 <ivanm> so, should ANNOUNCE emails go to libraries@ as well?
23:24:45 <Cale> int80_h: Which package was that in?
23:24:48 <handonson> okay, it's supposed to be a joke, but i don't see anything funny of it, so i think i should just ignore it
23:25:09 <int80_h> okay it works
23:25:20 <ivanm> handonson: what's this?
23:25:35 <blackdog> ivanm: am thinking i might do a quick announcement about aushac at the ruby night - you don't mind a few scruffy dynamic-typers, do you?
23:25:38 <int80_h> I installed it as root, and it didn't work until I ionstalled it as my user account. It may have to do with my $PATH
23:25:39 <handonson> ivanm: Lajla said something
23:25:54 <int80_h> installed it uner my user account, works fine now
23:26:09 <ivanm> blackdog: only if they're willing to admit that we're superior :p
23:26:32 <aavogt> int80_h: if you do it as root, add the --global flag to get it installed for everybody (not just root)
23:27:10 <blackdog> ivanm: jeez, do you make your students say uncle before you teach them anything too? :)
23:27:23 <ivanm> not at all
23:27:24 <mtnviewmark> CakeProphet: still here? here's sort of what I was thinking
23:27:26 <mtnviewmark> http://bitbucket.org/mtnviewmark/haskell-playground/src/tip/irc/SimpleAsm.hs
23:27:40 <mtnviewmark> (it compiles and assembles the samples at the end)
23:28:23 <int80_h> Prelude Data.Number.Real> pi :: CReal
23:28:24 <int80_h> <interactive>:1:0:
23:28:27 <int80_h>     No instance for (Floating CReal)
23:28:27 <int80_h>       arising from a use of `pi' at <interactive>:1:0-1
23:28:27 <int80_h>     Possible fix: add an instance declaration for (Floating CReal)
23:28:27 <int80_h>     In the expression: pi :: CReal
23:28:27 <int80_h>     In the definition of `it': it = pi :: CReal
23:28:53 <Axman6> blackdog: they can come, but won't be able to get wifi access easily
23:28:59 <int80_h> as you can see, I loaded the right moudle but still get an error when trying to express pi as a CReal
23:29:18 <Lajla> I guess those eggs hatched sooner than I thought.
23:29:22 <Axman6> though, I may bring another laptop and see if i can do some kind of bridging
23:29:22 <blackdog> Axman6: oh, is that all done, is it?
23:29:25 <blackdog> damn
23:29:41 <Axman6> int80_h: you want Real, not CReal. the package you installed isn't the one what defines CReal
23:29:58 <ivanm> Axman6: do you know if there's enough power points there?
23:30:08 <ivanm> or should we ask some sydneysiders to bring powerboards?
23:30:15 <Axman6> ivanm: nope, but i'll be looking into it on thursday probably
23:30:37 <Axman6> blackdog: you have a car and you're planning to go to fp-syd right?
23:30:43 <ivanm> well, send me a txt message or something and I can bring a powerboard if need be
23:30:48 <blackdog>  one of those is true
23:30:48 <Axman6> ok
23:30:58 * Axman6 hopes for the former
23:31:05 <mtnviewmark> @pl \a -> f a >>= return . g
23:31:05 <lambdabot> (g `fmap`) . f
23:31:05 * Axman6 suspects the latter
23:31:15 <int80_h>  Axman6 : when I do pi :: Real I get 'Real' uised as a type.
23:31:24 <blackdog> what good would me having a car be if i wasn't coming? :)
23:31:26 <int80_h> > pi :: CReal
23:31:27 <lambdabot>   3.1415926535897932384626433832795028841972
23:31:32 * hackagebot fgl 5.4.2.3 - Martin Erwig's Functional Graph Library  http://hackage.haskell.org/package/fgl-5.4.2.3 (IvanMiljenovic)
23:31:33 <int80_h> that's what I want
23:31:34 <Axman6> i'd make you come :P
23:31:44 <mtnviewmark> :t >=>
23:31:45 <lambdabot> parse error on input `>=>'
23:31:46 <blackdog> oh, hang on
23:31:48 <blackdog> fp-syd?
23:31:50 <blackdog> when is it?
23:31:52 <Axman6> yeah
23:31:56 <Axman6> thursday night
23:31:58 <mtnviewmark> :t (<=<)
23:31:59 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
23:32:02 <blackdog> i can't come :/
23:32:06 <Axman6> :(
23:32:08 <Axman6> how come?
23:32:10 <int80_h> hackage says Data.Number.Real defines CReal, unless I totally misunderstand.
23:32:18 <blackdog> funnily enough,  i have stephen blackheath arriving
23:32:28 <Axman6> ok
23:32:41 <Axman6> blackdog, ivanm -> #haskell-blah ?
23:32:57 <ivanm> sure
23:33:06 <elitheeli> Could someone explain what's going on here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27337#a27337
23:33:34 <elitheeli> as in, why the first fails?
23:33:42 <int80_h> AXman6: which module is the right one for CReal then?
23:33:43 <Axman6> sohum: you around?
23:33:51 <Axman6> int80_h: i don't know, i've never used it
23:34:32 <Cale> elitheeli: in order to mod n by something, it must have an integer-like type (such as Integer), in order to take the square root of n, it must have a fractional type (like Double)
23:34:46 <ivanm> int80_h: it's in the numeric package IIRC
23:34:46 <Cale> Well, to be more precise, a Floating type
23:35:03 <int80_h> :module numeric
23:35:08 <Cale> There are no types which are both Floating and Integral
23:35:15 <mtnviewmark> also, I'm guessing, elitheeli, you want  (`mod` n)   
23:35:19 <sohum> Axman6: for the first time in a long time, yeah
23:35:22 <Cale> So that's why you get a complaint. It doesn't know how to choose a type for you.
23:35:23 <mtnviewmark> though I could be wrong...
23:35:31 <Axman6> sohum: are you coming to aushac?
23:35:34 <elitheeli> mtnviewmark: well, I don't really need that function specically, I just simplified it
23:35:39 <elitheeli> specifically*
23:35:43 <Axman6> can't remember if you said you were or not
23:35:43 <sohum> Axman6: lappy's motherboard fried basically right after exams, just got it back from repair
23:35:45 <Cale> foo itself can be typed, but it gets a type in which you could never actually use it
23:35:48 <sohum> I is!
23:35:53 <elitheeli> Cale: so how do I make the first thing work?
23:36:01 <Eduard_Munteanu> You could use fromIntegral
23:36:08 <Eduard_Munteanu> :t fromIntegral
23:36:09 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:36:09 <Cale> elitheeli: Just use  fromIntegral on n before taking the square root
23:36:14 <elitheeli> ok
23:36:15 <Axman6> rough :( mine's in the shop too. hopefully i'll get it back tomorrow, because i'm leaving for sydney on wednesday...
23:36:54 <sohum> Axman6: ouch :(
23:37:08 <Cale> fromIntegral converts from any integer-like type to any numeric type at all, and so passing in an Integer will work then
23:37:09 <elitheeli> Awesome, thanks Cale
23:37:15 <int80_h> installing numeric-prelude :)
23:37:19 <sohum> Axman6: they were saying it might take another week, whcih would have been... bad.
23:37:44 <mtnviewmark> let foo n = map (mod n) [2..floor$sqrt$fromIntegral n]
23:37:52 <elitheeli> yeah, that works
23:38:37 <sohum> Axman6: any eta on when it might be coming?
23:39:55 <mtnviewmark> silly me --- (`mod` n) version is a dull result -- but (mod n) is interesting!   Hah - just that in most programming situations, you want to mod by a stable modulus, --- whereas here you don't!
23:41:07 <Eduard_Munteanu> :t flip (mod n)
23:41:08 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
23:41:08 <lambdabot>     In the first argument of `mod', namely `n'
23:41:08 <lambdabot>     In the first argument of `flip', namely `(mod n)'
23:41:53 <Eduard_Munteanu> :t (flip . curry) (mod n
23:41:54 <lambdabot> parse error (possibly incorrect indentation)
23:41:57 <Eduard_Munteanu> :t (flip . curry) (mod n)
23:41:59 <lambdabot>     Couldn't match expected type `(a1, a)' against inferred type `Expr'
23:41:59 <ClaudiusMaximus> hmm, is there any way to specify to GHC at compile-time that i want to run the resulting executable with +RTS -M2G -RTS as default instead of unlimited heap?
23:41:59 <lambdabot>     In the first argument of `mod', namely `n'
23:41:59 <lambdabot>     In the first argument of `(flip . curry)', namely `(mod n)'
23:42:26 <Eduard_Munteanu> Ah, I'm kinda misusing :T
23:42:35 <int80_h> > :show modules
23:42:35 <lambdabot>   <no location info>: parse error on input `:'
23:42:43 <int80_h> > :how modules
23:42:44 <lambdabot>   <no location info>: parse error on input `:'
23:42:49 <int80_h> > show modules
23:42:49 <lambdabot>   Not in scope: `modules'
23:44:21 <Veinor> ClaudiusMaximus: sadly, I don't think so
23:45:28 <ClaudiusMaximus> Veinor: seems you are wrong!  http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html#rts-hooks
23:45:59 <Veinor> ah!
23:50:03 <mtnviewmark> CakeProphet: incase you missed my earlier post of it
23:50:07 <mtnviewmark> this is what I was thinking: http://bitbucket.org/mtnviewmark/haskell-playground/src/tip/irc/SimpleAsm.hs
23:50:37 * hackagebot graphviz 2999.10.0.0 - Graphviz bindings for Haskell.  http://hackage.haskell.org/package/graphviz-2999.10.0.0 (IvanMiljenovic)
23:54:38 * hackagebot Graphalyze 0.10.0.0 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.10.0.0 (IvanMiljenovic)
23:56:03 <ManateeLazyCat> ivanm: Are you "Ivan Lazar Miljenovi" ?
23:56:17 <ivanm> well, I have a `c' on the end of my surname, but yes ;-)
23:57:47 <ManateeLazyCat> ivanm: Oh my...
23:57:50 <ivanm> what?
23:58:47 <ManateeLazyCat> ivanm: I found a guy suggest me use hint instead plugins in haskell-cafe.
23:59:09 <ivanm> yes, that was me
23:59:22 <ivanm> well, I suggested you look at hint, anyway
23:59:23 <ivanm> I thought you realised that...
23:59:25 <ManateeLazyCat> ivanm: Then i think "I think that guy would not you?"
