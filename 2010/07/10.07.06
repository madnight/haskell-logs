00:00:05 <solrize> right
00:00:10 <FunctorSalad> it's just that because first-order-logic *is* complete, we can forget provable vs. valid...
00:00:22 <solrize> so when you say "enumerate all the true theorems" you mean "enumerate all the theorems" which is trivial to do...
00:00:27 <FunctorSalad> if you *can't* identify the two, then valid stays an informal concept, no?
00:00:33 <FunctorSalad> s/valid/"valid"/
00:00:52 <FunctorSalad> oh, that was an oversight
00:00:56 <soupdragon> ski curious
00:00:57 <FunctorSalad> I didn't mean theorems
00:01:30 <Eduard_Munteanu> Mmm, how is it complete?
00:01:30 <FunctorSalad> all the true sentences of arithmetic
00:01:39 <ski> soupdragon : to be more concrete, they defined `<' and `=<' on ordinals by defining an inference system (with infinitary rules) on sequences of the form `|- F_0 , F_1 , ... , F_{n-1}' each `F_i' being either `a < b' or `a =< b' for every `i'
00:01:49 <Eduard_Munteanu> It reallly isn't.
00:01:55 <FunctorSalad> Eduard_Munteanu: the usual inference rules will let you enumerate all valid sentences
00:02:04 <ski> soupdragon : no logical connectives in the system at all, though the "feel" of the `,' was that of a (multiplicative) disjunction
00:02:08 <FunctorSalad> the catch is that you can't pin down the natural numbers in first-order logic
00:02:21 <soupdragon> ski ah
00:02:29 <Eduard_Munteanu> Hm, I see.
00:02:34 <FunctorSalad> the first-order peano axioms don't define the naturals uniquely
00:03:00 <FunctorSalad> you get strange models with copies of Z which are larger than all the integers IIRC
00:03:09 <Eduard_Munteanu> Now really, when we say "math", what logic are we referring to?
00:03:15 <Eduard_Munteanu> I'm a bit confused atm.
00:03:36 <FunctorSalad> it's all informal at the outer level
00:04:11 <Eduard_Munteanu> Because ZFC is known not to be complete.
00:05:02 <ski> soupdragon : the two single rules in the system was `(forall i : S. (|- Gamma , a_i < b)) <=> (|- Gamma , (sup i : S. a_i) =< b)' and  `(exists i : S. (|- Gamma , a =< b_i)) <=> (|- Gamma , a < (sup i : S. b_i))', where `S' is any recursively enumerable subset of the naturals (you choose which `S' in each rule application)
00:05:03 <FunctorSalad> it's more basic -- formalism can't pull itself up by its own hairs
00:05:08 <ClaudiusMaximus> @djinn (c, Either a b) -> Either (c, a) (c, b)
00:05:09 <lambdabot> f (a, b) =
00:05:09 <lambdabot>     case b of
00:05:09 <lambdabot>     Left c -> Left (a, c)
00:05:09 <lambdabot>     Right d -> Right (a, d)
00:05:14 <FunctorSalad> ZFC is a first-order theory
00:05:24 <FunctorSalad> making first-order logic rigorous requires a background logic
00:05:41 <Eduard_Munteanu> Oh, I get the idea.
00:06:21 <ski> soupdragon : then they defined `a < b' as `|- a < b' being derivable in the system, and `a =< b' as `|- a =< b' being derivable in the system
00:06:32 <Eduard_Munteanu> Which makes that background logic necessarily second order if it concerns theorems in ZFC?
00:06:53 <ski> soupdragon : they went on to prove stuff like `|- a =< a', by using ordinal induction ..
00:07:23 <FunctorSalad> (my conclusion is that ZFC is a language, not something you can believe in or not)
00:07:33 <ski> soupdragon : btw, this is in "Notes on Constructive Mathematics" by Per Martin-Löf
00:08:00 <soupdragon> ski :( my libraries don't hold any of his work it is such a shame
00:08:09 <ski> indeed :(
00:08:12 <FunctorSalad> (I'm not the first to say something like that, mind you :D)
00:08:15 <ski> inter-library loan ?
00:08:22 <FunctorSalad> was just making it clear that it's opinion
00:08:47 <Eduard_Munteanu> I see.
00:11:01 <solrize> yawnn
00:11:04 <solrize> oops
00:11:17 <FunctorSalad> ?
00:11:27 <solrize> didn't mean to yawn in here ;)
00:11:50 <FunctorSalad> it's indeed a common topic around these parts, but I figured "wth, why not once more"
00:11:57 <FunctorSalad> ;)
00:12:47 <ski> FunctorSalad : iirc, completeness of first-order predicate logic was proved non-constructively
00:14:19 <ski> (soupdragon : btw, when i said "multiplicative disjunction" i mean stuff like that `|- a < b , b =< a' was provable .. or is `a < b \/ b =< a' provable intuitionistically, for the ordinals (i assumed it weren't, but i'm not familiar enough with them to tell))
00:14:24 <FunctorSalad> ski: hmm IIRC the strategy is to show that if a set of formulae is not contradictory, you can construct a model where they hold
00:14:44 <FunctorSalad> seems constructive enough to me, though it contains a counterpositive or two I guess ;)
00:14:51 <ski> aren't you talking about soundness, now ?
00:15:00 <dolio> http://www.math.unipd.it/~silvio/papers/WorkInProg/IntCompl.pdf
00:15:07 <ski> completeness should construct proofs
00:15:15 <FunctorSalad> no, for that you just have to show that inference rules preserve truth
00:15:20 <FunctorSalad> (for soundness)
00:15:25 <ski> (or construct counter-models, by contra-position .. but that's non-constructive :)
00:15:56 <ski> or, hm .. let me think this through
00:16:02 <FunctorSalad> the proof I know doesn't construct proofs; it's easier to show that if you can't disprove something, then that is because it's true in some model
00:16:23 <FunctorSalad> it's a dizzying chain of negations indeed, maybe I made some mistake
00:16:28 <ski> the proof i saw (but only remember vaguely) used contraposition
00:17:07 <ski> iirc, i asked Coquand about it, and he said it was non-constructive
00:17:17 <FunctorSalad> (you make up a sort of term algebra as the model, but it's a bit more tricky than in equational theories due to the existential quantifier)
00:17:34 <dolio> Completeness of first-order logic was originally proved non-constructively, yes.
00:17:43 <dolio> As far as I've read.
00:17:52 <dolio> That paper says you can do it intuitionistically, though.
00:18:03 <ski> maybe there's a proof in a constructive meta-theory too .. i'm not sure
00:18:11 <ski> what paper ?
00:18:11 <FunctorSalad> ski: it identifies "provable" and "not contradictory" in the object logic
00:18:14 <FunctorSalad> maybe that?
00:18:27 <FunctorSalad> that seems fair since the object logic is classical
00:18:38 <FunctorSalad> err wait
00:18:39 * ski glances upwards .. oh
00:18:42 <Eduard_Munteanu> Well you don't need a way to construct proofs, you only need to show that that set of finitely many axioms is complete.
00:18:47 <Eduard_Munteanu> That's easier.
00:18:53 <FunctorSalad> what was I just trying to say....?
00:18:54 <FunctorSalad> ;)
00:19:10 <Eduard_Munteanu> Oh, right.
00:19:13 <FunctorSalad> or I think that was right actually
00:19:49 <FunctorSalad> ("contradictory" on the proof level... "inconsistent" is the word for the model level, right?)
00:20:00 <Eduard_Munteanu> Yes.
00:20:25 <ski> i recall "inconsistent" being used of sets of formulae
00:20:42 <FunctorSalad> I'm unsure too
00:20:47 <FunctorSalad> insatisfiable for models?
00:20:54 <ski> (meaning that `_|_' is derivable, or that every formula is derivable)
00:21:11 <ski> that sounds reasonable
00:21:38 <dolio> Inconsistent means |- false. Or maybe G |- false as an extension.
00:22:08 <ski> yes .. or `forall F. (G |- F)'
00:22:29 <ski> (useful for para-consistent logics, i imagine)
00:22:50 <dolio> Yeah, probably.
00:22:55 <Eduard_Munteanu> Isn't paraconsistent logic a result of long term crack use?
00:23:24 <ski> well .. one might view linear logic as, sortof, a para-consistent logic
00:23:25 <FunctorSalad> valid => provable   <--- counterpositive ---> not provable => insatisfiable
00:23:43 <FunctorSalad> but how do we get from 'not provable' to 'contradictory'/'inconsistent'?
00:23:45 <ski> FunctorSalad : yes, the direction to the left there is non-constructive
00:24:06 <FunctorSalad> as a defense, I'm tired :o
00:24:15 <ski> (at least taken at face value, without some redeeming theorem)
00:24:28 <FunctorSalad> ski: yeah, but currently I'm trying to replicate how it went classically, even ;)
00:24:56 <ski> ok
00:25:34 <dolio> FunctorSalad: The book I have goes through a lot of lemmas first.
00:25:50 <tolkad> data T a = T a
00:25:50 <tolkad> class A a where f :: Integral v => a -> v
00:25:50 <tolkad> instance A (T a) where f (T a) = 5 :: T a -> Int
00:25:56 <tolkad> why doesn't that work...
00:26:19 <tolkad> fails with
00:26:22 <tolkad> Could not deduce (Num (T a2 -> Int)) from the context ()
00:26:23 <dolio> First you talk about how to extend sets of sentences...
00:26:26 <FunctorSalad> dolio: I thought the reduction to "if it isn't contradictory, we can make a model" was elementary
00:26:30 <tolkad> and Couldn't match expected type `v' against inferred type `T a -> Int'
00:26:44 <FunctorSalad> but if nobody else sees how to get there from the RHS above, maybe it wasn't
00:26:47 <ski> tolkad : `5 :: T a -> Int' doesn't work
00:26:56 <tolkad> ski: why?
00:27:05 <ski> because `5' is not a function ?
00:27:22 <ski> (unless you import some `instance (...) => Num (a -> b)' thing ..)
00:27:24 <tolkad> ski: oh, I thought that :: was for the function
00:27:34 <ski> no
00:27:37 <tolkad> ski: I didn't realize it was casting the 5
00:27:40 <tolkad> ski: thanks
00:27:58 <ski> s/cast/ascribe or constrain/
00:28:03 <FunctorSalad> ah. I confused opposites and negations
00:28:14 <dolio> Why are you putting a type annotation on anyway?
00:28:14 <FunctorSalad> not(valid) == opposite is satisfiable
00:28:21 <Eduard_Munteanu> tolkad: :: binds to 5 there, plus there's no sense in writing signatures since you already have the method signature in the class definition.
00:28:24 <FunctorSalad> rather than not(valid) == insatisfiable
00:28:30 <tolkad> ski: well, whatever it is (looks like casting to me but you haskell people like your fancy names),
00:28:34 <ski> `x :: Int' doesn't "cast" to `Int', it ascribes the expression `x' has (already) having type `Int'
00:28:41 <FunctorSalad> err not(valid) == negation is satisfiable
00:28:48 <FunctorSalad> that should fix it
00:28:49 <ski> in different words : it constrains the type to be `Int'
00:29:33 <ski> (and, this is when `x :: Int' is used as an *expression* (or pattern) .. when `x :: Int' is a type signature, then it's a type signature, not a type ascription)
00:30:01 <FunctorSalad> so we need to show that if F is not  provable, then not(F) is satisfiable
00:30:02 <Eduard_Munteanu> There's really no casting operator in Haskell, although you can get a similar behavior with unsafePerformIO
00:30:17 <FunctorSalad> now set G := not(F)
00:30:24 <FunctorSalad> yielding my claim
00:30:49 <FunctorSalad> (we reduced it to "if not(G) is not provable, then G is satisfiable")
00:31:30 <FunctorSalad> the last step is just cosmetic of course
00:31:45 <ski> tolkad : to me "cast" means "treat this expression as if it had this type, just because i say so"
00:32:14 <tolkad> well, why doesn't this work?
00:32:16 <tolkad> data T a = T a Int
00:32:16 <tolkad> class A a where f :: Integral v => a -> v
00:32:16 <tolkad> instance A (T a) where f (T a i) = i
00:32:36 <ski> there's a variant of that in Haskell, that fails if it doesn't have the type you want
00:32:40 <ski> @type cast
00:32:42 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
00:32:53 <ski> > cast "foo" :: Maybe String
00:32:54 <lambdabot>   Just "foo"
00:32:56 <ski> > cast "foo" :: Maybe Int
00:32:57 <lambdabot>   Nothing
00:33:18 <Eduard_Munteanu> tolkad: i isn't a parameter there.
00:33:24 <FunctorSalad> ski: but yes, the counterpositive is clearly classical at face value :)
00:33:27 <Eduard_Munteanu> It's the return value.
00:33:33 <ski> tolkad : `f :: Integral v => a -> v' promises to return something of type `v' for whatever `Integral' type `v', the *caller* wants
00:33:40 <FunctorSalad> but at least you get to construct a free algebra =)
00:33:43 <ski> you're always returning an `Int'
00:33:43 <Eduard_Munteanu> and you're pretending to have an extra parameter in the instance definition
00:33:50 <ski> that doesn't work if the caller wanted a `Double'
00:34:38 <tolkad> ski: `f :: Integral v => a -> v' promises to return something of a  type in the class Integral, right?
00:34:54 <Eduard_Munteanu> Yes.
00:35:09 <tolkad> so, I can return whatever I want as long as it's in the class Integral
00:35:20 <Eduard_Munteanu> Or rather, of _any_ type in the Integral.
00:35:28 <ski> tolkad : so, either say `data T a = T a (forall v. Integral v => v)' to make sure you only can store something there which can be anything the caller likes
00:35:30 <Eduard_Munteanu> tolkad: no, it's still polymorphical.
00:36:10 <Eduard_Munteanu> The caller chooses types.
00:36:21 <ski> tolkad : or, effectively, say `f :: a -> exists v. Integral v *> a -> v' .. but since haskell doesn't have first-class existentials, you'll have to wrap that in an existentially quantified data type (or use a CPS trick)
00:36:24 <Eduard_Munteanu> As ski said, it can choose Double.
00:36:44 <tolkad> I'll call child protective services immediately
00:37:06 <ski> tolkad : "`f :: Integral v => a -> v' promises to return something of a type in the class `Integral'", where the *caller* of `f' chooses what that type is
00:37:21 <FunctorSalad> ski: but is all this a problem? we do have the recursive-enumeration procedure
00:37:29 <FunctorSalad> only the proof that it works is nonconstructive
00:37:29 <ski> `f' doesn't get to choose what `v' is in `f :: Integral v => a -> v', the *caller* of `f' does
00:37:44 <ski> if you want `f' to choose, use an existential, as i mentioned above
00:37:47 <FunctorSalad> (which I'm generally comfortable with)
00:37:59 <tolkad> ski: so... I add another type parameter to data T?
00:38:07 <ski> which do you want ?
00:38:13 <ski> do you want `f' to choose ?
00:38:24 <tolkad> ski: data (Integral i) => T a i = T a i
00:38:34 <ski> that is certainly possible
00:38:42 <ski> but i'm not sure whether that is what you want, or not
00:38:47 <tolkad> and uh maybe that will work
00:38:55 <tolkad> idk, I just try stuff until haskell compiles it
00:38:57 <ski> it's definitely different from using an existential
00:39:10 <tolkad> this whole type system seems like a bother
00:39:20 <Eduard_Munteanu> Yeah, here the caller supplies that value anyway.
00:39:33 <ski> it requires you to say which kind of situation you really want
00:39:39 <Eduard_Munteanu> (though you can process it if you know it's an Integral)
00:40:11 <Eduard_Munteanu> s/if/since/
00:41:27 <tolkad> really, I just want data T to use an Int, but I want `f' for any instance of `A' to always return a type in the class Integral
00:41:30 <ski> either (a) the caller of `f' gets to choose what type `v' should be; or (b) `f' itself gets to choose; or (c) you make it a parameter of the type `T' (so `T' is now different from before, so you can't store several `T's in a list (directly) that have different `v' types in them); or (in this case) (d) you add `v' as a parameter of the class
00:41:47 <FunctorSalad> tolkad: look at it as proving theorems about your program...
00:42:12 <ski> hm .. then maybe you want to insert a call to `fromIntegral', or something like that
00:42:15 <ski> @type fromIntegral
00:42:16 <lambdabot> forall a b. (Integral a, Num b) => a -> b
00:42:19 <FunctorSalad> can never do that with tests (unless the domain is finite or there's some other special argument)
00:42:45 <tolkad> ?src fromIntegral
00:42:45 <lambdabot> fromIntegral = fromInteger . toInteger
00:42:51 <ski> `Int' is definitely in `Integral', and any `Integral' (for the return type) is a `Num'
00:42:58 <tolkad> ?src fromInteger
00:42:58 <lambdabot> Source not found. Sorry.
00:43:03 <tolkad> ?src toInteger
00:43:03 <lambdabot> Source not found. It can only be attributed to human error.
00:43:06 <ski>   instance A (T a) where f (T a i) = fromIntegral i
00:43:09 <tolkad> 0_o
00:43:13 <ski> @type fromInteger
00:43:14 <lambdabot> forall a. (Num a) => Integer -> a
00:43:18 <ski> @type fromInt
00:43:19 <lambdabot> Not in scope: `fromInt'
00:43:26 <tolkad> well, how do I define something like fromIntegral for my own types
00:43:55 <ski> @src Num
00:43:55 <lambdabot> class  (Eq a, Show a) => Num a  where
00:43:56 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:43:56 <lambdabot>     negate, abs, signum     :: a -> a
00:43:56 <lambdabot>     fromInteger             :: Integer -> a
00:44:09 <ski> you define `fromInteger' when you make an instance of `Num'
00:44:27 <ski> (or is there's a default implementation of that ?)
00:44:35 <tolkad> like let's say I have class L which type Q is a member of  and then I want data (L l) => T a l = T a l
00:44:45 <tolkad> err wait
00:45:01 <tolkad> like let's say I have class L which type Q is a member of  and then I want data T a = T a Q
00:45:29 <ski> @src Integral
00:45:29 <lambdabot> class  (Real a, Enum a) => Integral a  where
00:45:29 <lambdabot>     quot, rem, div, mod :: a -> a -> a
00:45:29 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
00:45:29 <lambdabot>     toInteger           :: a -> Integer
00:45:49 <ski> ok, so you define `toInteger' when you `instance Integral Q'
00:45:58 <tolkad> but, then I want class A a where f :: (L v) -> a -> v
00:46:33 <tolkad> and then I have instance A (T a) where f (t a q) = q
00:46:34 <ski> or, if you can define your own conversion `Integral v => Q -> v', then you can use that instead, in `f'
00:46:35 <augur> is there a good resource for finding interesting and innovative papers like the huet or abbot et al papers?
00:47:03 <digitteknohippie> anyone know a good iq test?   i was thinking we could do a poll of iq in here.  haskell seems to atract the real smarties.  ;)
00:48:07 <ski> tolkad : you haven't really answered whether you want `f :: a -> forall v. Integral v => a -> v' or `f :: a -> exists v. Integral v *> a -> v' (or something else) yet ..
00:48:21 <Eduard_Munteanu> tolkad: f (t a q), look at it again
00:48:30 <Eduard_Munteanu> You don't have a second parameter there.
00:48:46 <Eduard_Munteanu> t a is the only parameter you have.
00:48:53 <ski> <tolkad> data T a = T a Int
00:48:55 <ski> Eduard_Munteanu : ^
00:49:03 <Eduard_Munteanu> Which in fact should be some data constructor + value
00:49:10 <ski> <tolkad> really, I just want data T to use an Int, but I want `f' for any instance of `A' to always return a type in the class Integral
00:49:13 <Eduard_Munteanu> ski: oh.
00:49:16 <Eduard_Munteanu> Sorry :)
00:49:45 <tolkad> here's how it looks altogether:
00:49:47 <tolkad> class L a
00:49:47 <tolkad> data Q = Q
00:49:47 <tolkad> instance L Q
00:49:47 <tolkad> data T a = T a Q
00:49:47 <tolkad> class A a where f :: L v => a -> v
00:49:47 <tolkad> instance A (T a) where f (T a q) = q
00:49:59 <augur> ski? do you know of any?
00:50:18 <ski> tolkad : ^ it is not clear whether that means you really want `f :: a -> forall v. Integral v => a -> v'  (i.e. caller decides what type `v' to use) .. or `f :: a -> exists v. Integral v *> a -> v' (i.e. callee decides what type `v' to use)
00:50:51 <ski> augur : LtU, c.l.f, here ?
00:50:57 <augur> clf?
00:51:14 <ski> the comp.lang.functional newsgroup on usenet
00:51:20 <augur> oh
00:51:20 <augur> aha
00:51:24 <tolkad> ski: I want the callee to decide what type `v' to use, but I want whatever type that is to be within the class Integral
00:51:27 <Eduard_Munteanu> I think he should stick to the first one really, since existentials can't be exposed to the exterior.
00:51:28 <dolio> c.l.f is mostly worthless these days.
00:51:33 <ski> tolkad : ok, ty
00:51:38 <dolio> It's all spam and Xah Lee.
00:51:48 <ski> tolkad : so you want the `f :: a -> exists v. Integral v *> a -> v' in that case
00:51:57 <ski> dolio : ok .. i haven't checked in some while
00:52:04 <augur> imma check out the journal of functional programming
00:52:07 <Eduard_Munteanu> IMHO, this needs not polymorphism, because the problem is ill-defined.
00:52:21 <dolio> And not even that much Xah Lee, really.
00:52:38 <tolkad> ooh, *> restricts it but lets the callee decide what to use then? that's cool
00:52:42 <Eduard_Munteanu> If he simply returns an Integer, that's an Integral too.
00:53:01 <Eduard_Munteanu> (and other polymorphic functions up the chain will choose Integer too)
00:53:41 <ski> tolkad : so, to make this actual Haskell, rather than pseudo-Haskell, make that into `f :: a -> SomeIntergral' and define `data SomeIntegral = forall v. Integral v => WrapIntegral v' (or `data SomeIntegral where WrapIntegral :: Integral v => v -> SomeIntegral' if you prefer the GADT-syntax .. they do the same, here)
00:54:19 <ski> tolkad : the `exists v. ' and `Integral v *> ' there is pseudo-Haskell .. in actual (current, at least) Haskell, you have to wrap in a data type
00:54:49 <ski> actually, a typo above
00:54:52 <ski> it should have been
00:54:56 <adu> hi ski
00:55:03 <ski>   f :: a -> exists v. Integral v *> v
00:55:12 <ski> (but this is pseudo-Haskell anyway ..)
00:55:36 <adu> i love pseudo-haskell, my favorite function is launchTheMissiles
00:55:47 <tolkad> oh, I'd rather not wrap it... this is so easy in Java... I can have class X {Number f()} and then class Y extends X {Float f()}
00:56:00 <tolkad> I don't understand why it's so much harder in haskell
00:56:15 <ski> tolkad : but, yes, the intended interpretation of `f :: a -> exists v. Integral v *> v' is that the function `f' takes an input of type `a' (the class parameter, that is the instance of the class), and then it decides on some secret type `v', such that the only thing you (the caller) know about `v' is that it is in `Integral', .. and then it returns a value of that type `v'
00:56:17 <Eduard_Munteanu> @faq Can Haskell launch the missile
00:56:17 <lambdabot> The answer is: Yes! Haskell can do that.
00:56:19 <Eduard_Munteanu> :P
00:56:43 <ski> tolkad : classes in Java are quite different from type classes in Haskell
00:57:17 <Eduard_Munteanu> tolkad: only that you don't use any base classes values in Haskell
00:57:17 <ski> tolkad : also note that type classes (e.g. together with existentials) are more powerful than Java classes .. you can do things in the former that you can't do in the latter
00:57:25 <dolio> It's because in Java, classes and interfaces are existentially typed.
00:57:26 <adu> tolkad: first of all, there are at least 2 ways to do inheritance in Haskell, and at least 3 ways to do interfaces/overriding
00:57:39 <digitteknohippie> @faq Can Haskell do genetic algorythms
00:57:39 <lambdabot> The answer is: Yes! Haskell can do that.
00:58:03 <ski> tolkad : also, Java classes *also* do inheritance, which the type classes & existentials doesn't do by themselves (it can be encoded, though)
00:58:07 <Eduard_Munteanu> In Java you usually solve that by
00:58:15 <Eduard_Munteanu> having a pointer to a base class.
00:58:27 <Eduard_Munteanu> And a virtual function that is being called.
00:58:53 <Eduard_Munteanu> Here you don't use any base class values, you simply choose the return type.
00:59:04 <adu> tolkad: secondly, haskell isn't object-oriented, so don't expect it to be
00:59:19 <ski> tolkad : so, the answer why it is "harder" (it might be, i'm not sure) than in Java is that Haskell allows you to say more things, so you must tell more explicitly which thing you actually want, not just like with Java where you (simplifying) only get one thing
00:59:23 <tolkad> adu: types are objects
00:59:38 <tolkad> adu: their methods are the functions that operate on them
00:59:45 <tolkad> adu: and otherwise haskell is just like java
00:59:46 <adu> maybe that's why you don't like haskell, because types are NOT objects
01:00:20 <Eduard_Munteanu> What adu means is that there's no encapsulation in the usual sense of OO.
01:00:21 <tolkad> no, I'm just confused :P, reading over everything ski said atm
01:00:51 <ski> tolkad : anyway, continuing with existentials .. so since we have `f :: a -> SomeIntegral' you should now in your `instance A (T a)' say `f (T a q) = WrapIntegral q'
01:01:12 <CakeProphet> Hello. I have a question regarded withSocketsDo
01:01:29 <CakeProphet> should I call it for every thread or only once for the entire program (in main)
01:01:38 <CakeProphet> *regarding
01:02:09 <ski> so, collected
01:02:12 <ski>   class L a
01:02:43 <ski>   data SomeL = forall v. L v => WrapL v
01:02:50 <ski>   {- alternatively
01:02:57 <ski>   data SomeL
01:02:58 <ski>     where
01:03:09 <ski>     WrapL :: L v => v -> SomeL
01:03:10 <ski>   -}
01:03:13 <ski>   data Q = Q
01:03:18 <ski>   instance L Q
01:03:22 <ski>   data T a = T a Q
01:03:27 <ski>   class A a
01:03:28 <ski>     where
01:03:30 <adu> i personally don't like encapsulation, it assumes that you can get all the methods right the first time around
01:03:48 <ski>   --f :: a -> exists v. Integral v *> v
01:03:59 <ski>     f :: a -> SomeL
01:04:03 <ski>   instance A (T a)
01:04:04 <ski>     where
01:04:12 <ski>     f (T a q) = WrapL q
01:04:25 <adu> i like languages like Haskell, Objective-C, and Go which let you add methods to existing classes _without_ requiring that you subclass it or define a new class/type
01:04:29 <ski> (er, s/Integral/L/, of course)
01:05:10 <CakeProphet> also
01:05:19 <CakeProphet> right now I'm looking at GHC.Conc
01:05:25 <ski> tolkad : is that clearer ?
01:05:34 <CakeProphet> but it's saying that it is not very portable. What's the most portable concurrency library?
01:05:55 <adu> IPP
01:05:58 <tolkad> ski: still reading over it
01:06:51 <CakeProphet> hmmm... Control.Concurrent?
01:06:56 <ski> tolkad : so, in `WrapL q', that takes your `Q' value, and wraps it up, and simultaneously forgets that it was of type `Q', only rememebering that it was of *some* type `v' which is in the class `L'
01:07:32 <CakeProphet> I'm just trying to figure out the difference between Control.Concurrent and GHC.Cont if anyone can help me.
01:07:51 <CakeProphet> also... whether or not I should use withSocketsDo for each thread or only once.
01:07:54 <tolkad> ski: Is there a way I could just define some function like fromIntegral that could convert my Q to a L without having to use a wrapper?
01:08:11 <ski> tolkad : so, when you unpack a `Q' value (by pattern-matching), the only thing you know about the contents is that it is of some unknown type, that is an instance of type class `L' .. so the only thing you can do with the internal value is to call methods of the type class `L' on it
01:08:31 <tolkad> yay encapsulation
01:09:04 <Zao> Ooh.
01:09:04 <ski> tolkad : iow, there's nothing here like Java's `instanceof' to let you recover which type it really was (if you really want that, there's ways of doing it, but you'll have to change the type `SomeL' somewhat for that)
01:10:15 <ski> tolkad : you mean a conversion `fromQ :: L v => Q -> v' ? sure you can write one, if you want (assuming it is possible to do, which depends on what `Q' and `L' are)
01:10:26 <CakeProphet> ski:  are we talking about existential types here?
01:10:54 <tolkad> maybe encapsulation isn't so great in haskell
01:10:58 <CakeProphet> data Showable = (Show x) => Showable x
01:11:22 <tolkad> is it?
01:11:26 <CakeProphet> tolkad:  the problem with that statement is that Haskell doesn't really need it. The semantic model is entirely different from any imperitive/OO language that you might be accustomed to.
01:12:01 <adu> ski: your examples don't make sense
01:12:25 <CakeProphet> tolkad: what is encapsulation in Haskell?
01:12:32 <tolkad> well, thanks a lot ski, I'm going to bed in a second
01:12:37 <tolkad> : )
01:12:58 <adu> ski: are you trying to convert from a datatype to a typeclass?!?
01:13:02 <Zao> ski: Damn you, I had put Haskell aside, considering it inadequate for my needs. Now I have to pick it up again and hack around :(
01:13:27 <CakeProphet> well anyways... can anyone answer my previous question about withSocketsDo and threads? 
01:13:43 <Zao> Most particularly, how to make a [a] from which I could do something useful with the `a's.
01:13:49 <adu> CakeProphet: i know nothing about Conc or Concurrent
01:13:58 <Zao> CakeProphet: I would expect it to be once per application.
01:14:06 <CakeProphet> hmmm... okay
01:14:11 <CakeProphet> I guess I'll call it in main and see what happens
01:14:17 <Zao> CakeProphet: As (as far as I know) it invokes WinSock init code on Windows (which is once per app).
01:14:25 <CakeProphet> not that I plan on using Windows for my application. I still like to design portably.
01:14:35 <CakeProphet> Zao:  okay cool. That helps a lot then.
01:14:38 <Zao> The canonical way is main = withSocketsDo $ do {
01:14:40 <adu> portability++
01:14:59 <qwebirc9028>  @pl (\rate x g -> let (r, g') = random g in if r > rate then mutate x g' else (x, g'))
01:15:01 <CakeProphet> Zao:  also should I use Control.Concurrent or GHC.Cont for maximum portability? Or something else entirely?
01:15:11 <adu> or in Haskell: Y portability
01:15:26 <Zao> CakeProphet: C.C has been sufficient for my uses.
01:15:40 <CakeProphet> alright.
01:15:43 <Zao> (which is spawning off a pile of threads doing STM gunk, as well as some native calls)
01:15:52 <qwebirc9028> @pl const
01:15:53 <lambdabot> const
01:16:13 <qwebirc9028>  @pl \rate x g -> let (r, g') = random g in if r > rate then mutate x g' else (x, g')
01:16:21 <qwebirc9028> Boo.
01:16:32 <qwebirc9028> @pl \rate x g -> let (r, g') = random g in if r > rate then mutate x g' else (x, g')
01:16:32 <lambdabot> (line 1, column 18):
01:16:32 <lambdabot> unexpected "("
01:16:32 <lambdabot> expecting "()", natural, identifier or "in"
01:17:09 <CakeProphet> This is my first time using concurrency in Haskell. Should be fun. :D
01:17:14 <ski> adu : er, which examples ?
01:17:26 <ski> adu : did you mean tolkad's examples ?
01:17:51 <adu> er, ya the L and Q stuff
01:17:56 <ski> (and yes, tolkad appeared to be trying to convert from a datatype to (any instance of) a type class)
01:18:07 <adu> wierd
01:18:20 <adu> thats like trying to convert a number to a macro
01:18:23 <Eduard_Munteanu> I still think existentials is a bad idea to choose first.
01:18:30 <ski> (well, tolkad appeared to be trying to do that as a sub-problem of a larger problem, rather)
01:19:00 <Eduard_Munteanu> ski: no, he admitted to messing around with classes "until stuff compiled" :)
01:19:18 <CakeProphet> hmmm
01:19:19 <CakeProphet> so
01:19:20 <ski> @type foldr (mplus . return) mzero
01:19:21 <ski> @type msum . map return
01:19:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
01:19:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
01:19:27 <ski> adu : like that ?
01:19:33 <CakeProphet> can anyone explain why accept returns a Handle instead of a Socket as the first tuple element?
01:19:45 <ski> Eduard_Munteanu : hence "appeared" :)
01:19:51 <Zao> CakeProphet: Because Sockets are icky low-level thingies?
01:20:02 <CakeProphet> Zao:  what should I use instead?
01:20:03 <Blkt> good day everyone
01:20:06 <CakeProphet> for a server-side listening socket.
01:20:08 <exDM69> CakeProphet: are you using Network.Socket or Network?
01:20:11 <CakeProphet> Network
01:20:11 <Zao> CakeProphet: If you want to play with more bare metal gunk, use the stuff in Network.Socket or something?
01:20:18 <exDM69> CakeProphet: Network.Socket is lower level
01:20:31 <CakeProphet> I'm using Network. But Network uses Sockets as well
01:20:35 <Zao> Network is a friendly high level wrapper.
01:20:45 <CakeProphet> so I use onListen to create my listening socket
01:20:46 <adu> ski: oh, that's a much better example
01:20:48 <Zao> Some of the detail might leak through.
01:21:05 <adu> ski:  MonadPlus is much better than "L"
01:21:06 <CakeProphet> and then accept to accept new connections. It just seemed weird that Network would suddenly switch from using Socket to using Handle in this one specific caser.
01:21:11 <CakeProphet> -r
01:21:15 <ski> (adu : and btw, converting a *static* number to a macro needn't be that insane :)
01:22:00 <ski> adu : `L' was just a dummy name. tolkad initially said `Integral', though i'm not sure whether that is the actual type class s/he wanted to use, there
01:22:54 <CakeProphet> Zao:  where are functions on Handles defined in Haskell?
01:23:02 <CakeProphet> need moar documentationz
01:23:26 <ski> @type hGetChar
01:23:28 <lambdabot> Not in scope: `hGetChar'
01:23:33 <ski> @type System.IO.hGetChar
01:23:35 <lambdabot> GHC.IOBase.Handle -> IO Char
01:23:39 <ski> &c.
01:23:40 <ski> ?
01:23:51 <CakeProphet> ah nevermind. Found System.IO  :)
01:24:28 * ski still thinks that GHC shouldn't leak internal stuff like `GHC.IOBase' (unless you ask for it, e.g. by importing `GHC.IOBase')
01:24:47 <Zao> CakeProphet: Wherever the usual IO functions are.
01:25:23 <CakeProphet> Zao:  yeah I found it. I forgot I could Google. :)
01:25:29 <CakeProphet> happens sometimes.
01:26:12 <ski> (CakeProphet : btw, yes we were talking existentials (took a while to determine that) .. and you're missing `forall x. ' there above)
01:26:25 <ski> @hoogle Handle
01:26:26 <lambdabot> System.IO data Handle
01:26:26 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
01:26:26 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
01:26:43 <adu> Haskell filesystem operations are very inconsistent, 1% use CFile, 1% use Fd, and 98% use Handle
01:26:47 <ski> (et `@hoogle+')
01:26:58 <CakeProphet> hmmm... okay
01:27:00 <CakeProphet> another question
01:27:15 * ski wonders how one measures degrees of inconsistency ..
01:27:20 <CakeProphet> how do I create values of type PortNumber? The documentation doesn't describe any constructors and I don't see any functions that generate PortNumbers.
01:27:44 <ski> CakeProphet : just `6667 :: PortNumber' or simply `6667', i think
01:27:44 <CakeProphet> but PortID uses PortNumber.
01:27:57 <ski> (it's an instance of `Num')
01:28:00 <CakeProphet> ah okay.
01:28:20 <CakeProphet> could I do that for any instance of Num? self-defined?
01:28:27 <ski> @instances-importing Network Num
01:28:28 <lambdabot> Double, Float, Int, Integer, PortNumber
01:28:36 <ski> do what ?
01:28:44 <CakeProphet> like if I had myNumType
01:28:45 <CakeProphet> could I do
01:28:52 <CakeProphet> 6667 :: myNumType
01:29:06 <CakeProphet> and magic would happen???
01:29:07 <CakeProphet> ...
01:29:13 <ski> as soon as you define `fromInteger' in `Num' you can use integral literals for your `Num' instance type
01:29:19 <Zao> CakeProphet: MyNumType?
01:29:30 <CakeProphet> Zao:  er, yes. 
01:29:37 <ski> it expands to `fromInteger 6667 :: MyNumType'
01:29:44 <CakeProphet> ski:  ah. gotcha. 
01:29:59 <ski> (and you can also use those literals in patterns)
01:30:12 <Zao> Aren't one supposed to use a mkPortNum function to construct PortNumber's?
01:30:20 <Zao> To ensure that the endianess is right?
01:30:52 <ski> @hoogle mkPortNum
01:30:52 <lambdabot> No results found
01:31:21 <CakeProphet> ski:  okay so if I do PortNumber 6667 is the explicit type hint still needed since PortNumber is a constructor from PortNumbers?
01:31:45 <ski> iirc, the `fromInteger' function "does the right thing" wrt endianess (but just using the constructor of `PortNumber' didn't, which was tripping people up before .. possibly the constructor is not exported any longer)
01:32:14 <CakeProphet> yeah according to the documentation type PortNumber has no constructors defined.
01:32:34 <Zao> Ah, the ctor seems to be gone indeed.
01:32:49 <ski> no, the type "hint" (i.e. ascription) is not needed in any case, unless your context doesn't determine what type you want there (and it usually *does* determine that)
01:33:11 <ski> CakeProphet,Zao : all well and good, then
01:33:36 <CakeProphet> ski:  okay good. I was going to say... if I have to explicitly write out (PortNumber Config.port :: PortNumber)... something is wrong.
01:34:04 <Zao> In my defense, I haven't used Network.* since 6.8 or so.
01:34:15 <Zao> For my awesome xtris implementation :)
01:34:27 <ski> if you were typing (only) `6667' in GHCi, then it wouldn't know you wanted a `PortNumber', but if you pass it as an argument where a `PortNumber' is wanted, or return it from a function that returns `PortNumber', the context will determine it (as usual), so no ` :: PortNumber' needed
01:34:35 <Zao> CakeProphet: I'd link you my source but I'm too ashamed about it.
01:35:17 <CakeProphet> ha.
01:35:45 <CakeProphet> so far Haskell is very clean to write networking/concurrent code... I just need more practice.
01:35:58 <CakeProphet> @src forever
01:35:58 <lambdabot> Source not found. That's something I cannot allow to happen.
01:36:17 <CakeProphet> @src Control.Monad.forever
01:36:17 <lambdabot> Source not found. It can only be attributed to human error.
01:36:50 <CakeProphet> I would almost say Control.Monad should be Prelude.
01:36:54 <Zao> let port = PortNumber (fromIntegral serverPort)
01:37:03 <Zao> Heh, I did it right enough back then :)
01:37:12 <Zao> But with the explicit ctor.
01:37:26 <Zao> Of wait, that's the PortID ctor. Nevermind.
01:37:56 <Zao> http://www.acc.umu.se/~zao/Hastris/trunk/ <- don't forget to pack some eye bleach
01:38:43 <CakeProphet> I'm having a hard time naming all of these concurrent functions
01:38:55 <CakeProphet> I'd like their name to somehow indicate that they're intended to be spawned with forkIO.
01:39:49 <Eduard_Munteanu> CakeProphet: if you're going to use Haddock, just try putting them under a module with a description that says it.
01:40:08 <ski>   forever ma = fix (ma >>)
01:40:14 <Eduard_Munteanu> That or you could try somthing like fioThread.
01:40:34 <CakeProphet> yeah I think what I'll do is abstract forkIO for each specific type of thread
01:41:13 <CakeProphet> so I spawn threads upon an accepted connection... I can make the fork action into a function that forks a thread as well as sends messages to various control/state threads.
01:41:38 <CakeProphet> forkNewUser handle hostname port
01:41:42 <CakeProphet> or whatever.
01:41:58 <ski> (adu : btw, hi)
01:44:34 <CakeProphet> data ConnectionInfo = {getHandle :: Handle, getHostName :: HostName, getPort :: PortNumber}
01:44:40 <CakeProphet> it seems like this should already exist somewhere.
01:44:52 <CakeProphet> or is unnecessary.
01:46:24 <Saizan> i've a DAG with labelled edges (so there can be more than one edge between two nodes), how'd you find the maximal subgraphs where for each node all the incoming edges have the same label?
01:47:47 <CakeProphet> Use -v to see a list of the files searched for.
01:48:04 <CakeProphet> was the advice given to me when a module I tried to load via :l was not found.
01:48:15 <CakeProphet> ...but I don't know where I'm supposed to put that option
01:48:24 <Botje> you load modules with :m
01:48:26 <Saizan> :set -v
01:48:30 <CakeProphet> ah okay.
01:48:47 <Botje> maybe ghci should DTRT and load the module
01:48:58 <Saizan> :m [+] is for installed modules
01:49:07 <Saizan> :l is for modules you want to load from source
01:49:09 <CakeProphet> well
01:49:12 <CakeProphet> I have server.hs
01:49:13 <handonson> Saizan: maybe modify the idea of Prim's or Kruskal's algorithm for finding minimum spanning trees
01:49:22 <CakeProphet> and server.hs defines module Mud.Server
01:49:32 <Saizan> CakeProphet: ah, you can't do that
01:49:54 <CakeProphet> ah okay. I'm not familiar with Haskell's module system (this is pretty much my first real application in Haskell)
01:49:54 <Saizan> CakeProphet: you've to put the module Mud.Server into the file Mud/Server.hs or Mud.Server.hs
01:50:04 <handonson> I didn't really understand your question, though
01:50:25 <CakeProphet> Saizan:  ah okay. That makes more sense. 
01:50:56 <CakeProphet> Saizan:  so the convention with Haskell files is to be titlecase?
01:51:48 <handonson> CakeProphet: afaik, the rule is that you HAVE TO titlecase the module names, and the convention is that the file name resembles the module name
01:52:02 <Saizan> yeah, that's it
01:52:09 <CakeProphet> so I can have lowercase filenames?
01:52:14 <Saizan> no
01:52:19 <handonson> no?
01:52:39 <CakeProphet> well, I know it's possible. but I want GHC to know where my module is based on filename.
01:52:39 <Saizan> module names have to start with an uppercase letter
01:52:57 <handonson> but he asked about filenames 
01:52:58 <CakeProphet> so that means I should use titlecase for my filenames and directories.
01:53:12 <Saizan> and so GHC will look for a file name with the same case.
01:53:19 <handonson> oh.
01:53:23 <CakeProphet> Mud/Server.hs starts with module Mud.Server where ...
01:53:38 <CakeProphet> previously it was 
01:53:44 <CakeProphet> mud/server.hs starts with module Mud.Server where ...
01:53:47 <CakeProphet> but that wasn't working.
01:54:13 <CakeProphet> this isn't working either though
01:54:53 <CakeProphet> oh I see
01:54:59 <CakeProphet> I need to use :l first I think
01:55:21 <Saizan> for modules you interpret from source you've to use :l not :m
01:55:34 <Saizan> btw, you can use import and it'll work in either case :)
01:55:41 <Saizan> with a sufficiently recent ghc
01:55:54 <CakeProphet> Saizan:  ah okay. Yeah I'm debugging at the moment so I just want to load from source.
01:56:30 <CakeProphet> but I should definitely turn -v off
01:56:34 <CakeProphet> because it is... verbose
01:58:10 <Saizan> handonson: in a minimal example i could have a graph like "B -a-> A <-b- C" then i'd want it splitted into two subgraphs "B -a-> A" and "C -b-> A" so that in each of them the edges going to A have the same label, if i had "B -a-> A <-a- C" instead i'd just pick the whole graph
01:58:57 <CakeProphet> hmmm, odd. Apparently I do need to explicitly define my port number as a PortNumber
01:59:15 <CakeProphet> I have a config module that just contains some constants, like server port and host name and such
01:59:20 <CakeProphet> so when I try
01:59:27 <CakeProphet> listenOn (PortNumber Config,port)
01:59:40 <CakeProphet> it is saying that Config.port is an Integer and not a (Num a) => a
02:00:01 <Saizan> yeah, that's the awful Monomorphism Restriction
02:00:06 <CakeProphet> is that because it compiles the Config module first and determines the type to be Integer by default?
02:00:47 <ski> dolio : hm, is there a link to the Agda list re Peter Lumsdaine,homotopy (i only saw <http://logical.saclay.inria.fr/coq-puma/messages/126f4f00bad49567#msg-f9cfa12bfcff10e6> ..)
02:01:27 <Saizan> CakeProphet: a definition like "port = 123" i.e. with no formal arguments, is not allowed to be polymorphic if it'd have a typeclass context
02:01:36 <handonson> MR is too awful that there won't be any problem if GHC sets -XNoMonomorphismRestriction by default
02:01:50 <handonson> and I think GHC should
02:01:58 <Saizan> CakeProphet: so defaulting kicks in and Integer is choosen
02:02:00 <dolio> ski: It's this thread: http://permalink.gmane.org/gmane.comp.lang.agda/1714
02:02:34 <CakeProphet> oh... there's an option to turn off MR?
02:02:39 <CakeProphet> I might just use that then. :)
02:03:12 <CakeProphet> it has to be in each module correct?
02:03:39 <Saizan> in each module it'd work for what's defined there
02:04:03 <ski> dolio : btw, it seems like there should be a distinction between logics which allow quantification over `*',`* -> *',&c., and such that allow quantification over `tau',`tau0 -> tau1',&c. (with System F_omega allowing both, mixing them, iiuc)
02:04:08 <ski> dolio : ty
02:04:30 <dolio> What's tau?
02:04:37 <CakeProphet> Saizan:  now what is the syntax for enabling extensions in source code instead of command line?
02:05:00 <Saizan> CakeProphet: be aware that the evaluation of such polymorphic "constants" won't be shared across their uses
02:05:21 <Saizan> CakeProphet: {-# LANGUAGE NoMonomorphismRestriction #-}
02:05:42 <CakeProphet> Saizan:  ah so port will still be an integer when used in an exported context?
02:06:01 <CakeProphet> unless I use a annotation that is.
02:06:11 <Saizan> CakeProphet: no, why?
02:06:26 <CakeProphet> Saizan:  I thought that's what you meant by "won't be shared across their uses"
02:06:46 <Saizan> CakeProphet: i was talking about the evaluation there
02:06:58 <CakeProphet> oh... well okay. That's what I want
02:07:42 <Saizan> e.g. if you have port = sum [1..1000] with the MR off, and you have "main = print (port, port)" you'll get the sum computed twice
02:08:49 <Eduard_Munteanu> Isn't that stupid?
02:09:04 <Eduard_Munteanu> I mean why in hell isn't that optimized out?
02:09:14 <CakeProphet> Saizan:  ah okay. I guess I could expect that, but I wouldn't have really thought about it
02:10:07 <dolio> It is optimized, by the monomorphism restriction.
02:10:41 <CakeProphet> should each LANGUAGE declaration have its own set of {-# #-}
02:10:44 <kamatsu> dolio: if you provide a typesig for port :: Int, that resolves the issue, yes?
02:10:51 <Eduard_Munteanu> dolio: obviously MR isn't something you want in all cases.
02:10:52 <dolio> Yes.
02:11:02 <Eduard_Munteanu> Oh.
02:11:12 <kamatsu> CakeProphet: I use one LANGUAGE
02:11:15 <CakeProphet> yeah if I just did port :: PortNumber it would fix my problem. But I'd still rather have port as a Num a
02:11:33 <Saizan> Eduard_Munteanu: well, maybe in the same expression like that a compiler could do some CSE, but in general you might be using port in far away places
02:11:37 <Eduard_Munteanu> Ok, I understand.
02:11:56 <Eduard_Munteanu> Saizan: ah, so even in that case, CSE is still a posibility.
02:12:03 <Saizan> though i don't think GHC does that kind of CSE
02:12:04 <CakeProphet> I don't want what is supposed to be a simple "config" file to be littered with type declarations that a person editing the config data might not understand.
02:12:16 <ski> dolio : `tau',&c. are any types
02:13:01 <Saizan> Eduard_Munteanu: yeah, the language spec doesn't mandate the re-evaluation, but the language spec doesn't even guarantee the sharing we all assume we'll get :)
02:13:01 <ski> dolio : meaning, things that "contain" values, rather than types
02:13:04 <chrisdone> heyo
02:13:35 <Eduard_Munteanu> Yeah, well the specs need not specify this stuff.
02:13:47 <dolio> So, first-order and related? F_omega doesn't have that.
02:14:21 <ski> dolio : in `forall x : |N. P x', we can do different things depending on what `x' is; in `forall A : Set. P A' we're parametric in `A'
02:14:34 <CakeProphet> Sweet. I no longer have any type errors.
02:14:43 <CakeProphet> NoMonomorphismRestriction ftw
02:15:06 <ski> it just seems to be that a system that allows the latter but not the former would be misnamed as "second-order" (since it isn't "first-order")
02:15:09 <Eduard_Munteanu> Yeah, it probably sucks having to type signatures if it's a config.
02:15:56 <Eduard_Munteanu> Idea...
02:16:03 * Saizan tends to use record types and Read/Show for configs
02:16:10 <Saizan> if it's something quite small..
02:16:14 <dolio> ski: Oh yes. F is a weird logic.
02:16:16 <Eduard_Munteanu> What happens if the actual user of configVariable is f = doSomething configVariable :: Integer ?
02:16:35 <Eduard_Munteanu> Doesn't that make configVariable an integer?
02:16:46 <dolio> ski: F_omega is also weird, though. You have higher-order but not first-order.
02:16:51 <CakeProphet> I think MR enforces that the type be monomorphic
02:17:04 <Eduard_Munteanu> CakeProphet: I meant with MR off
02:17:14 <CakeProphet> so for Num GHC apparently defaults integer interals to type Integer
02:17:18 <Eduard_Munteanu> (because with MR on the reevaluation wouldn't be a problem)
02:17:21 <ski> Eduard_Munteanu : that only makes the use of `configVariable' an `Integer' (assuming you meant `f = doSomething (configVariable :: Integer)'), `configVariable' itself could still be polymorphic
02:17:23 <CakeProphet> Eduard_Munteanu:  oh... well with MR off the problem is solved. The type is inferred.
02:17:27 <dolio> Except you can, I guess, build first-order like things at the second order level, and then quantify over them using the higher orders.
02:17:37 <dolio> Or something.
02:17:49 <Eduard_Munteanu> ski: meh... I thought that would make the inferrence pick something else as a default type.
02:18:12 <ski> Eduard_Munteanu : the uses of `configVariable' doesn't affect the typing that the definition of it gets
02:18:14 <Eduard_Munteanu> CakeProphet: but risk double evaluation as ski said.
02:18:32 <Eduard_Munteanu> ski: I see.
02:18:34 <Saizan> Eduard_Munteanu: if in the same module you've "x = 1; y = x :: T" then the type inferred for x will be T, rather than the default Integer
02:18:36 * ski didn't say anything about double evaluation :)
02:18:37 <CakeProphet> eh, I'm not too worried about my integers being evaluated twice. :)
02:18:39 <Eduard_Munteanu> What's the "default" type anyway?
02:18:59 <dolio> Like encoding naturals at the type level. But that works in Haskell (and the like) more because you have (effectively) type-case, which lets you treat * as if it were a set of particulars.
02:19:01 <Eduard_Munteanu> Ah.
02:19:09 <CakeProphet> I really only use the variable once anyways. I guess twice to print to shell. I don't think it matters at all.
02:19:16 <dolio> I'm not sure that works in vanilla F_omega.
02:19:59 <CakeProphet> okay so what's the quickest way to embed integers into output?
02:20:06 <CakeProphet> like + in Java and printf in C, essentially.
02:20:17 <ski> Eduard_Munteanu : in Ocaml (and SML/NJ), iirc, in some cases, they have something quite similar to MR (but for different reasons) .. i.e. they can't make `foo :: ..a..' polymorphic in `a' .. so what they do is say they type is `foo :: .._a..', where `_a' is a, yet to be determined, type .. then when `foo' is used with type `Int', `_a' becomes `Int' so `foo :: ..Int..' :)
02:20:27 <CakeProphet> say I want to print the port number to stdout, with a helpful message.
02:20:31 <ski> (and that's transcribed in terms of Haskell syntax, yes)
02:20:53 <Saizan> CakeProphet: the most basic way is to use show and ++, or concat
02:21:09 <CakeProphet> Saizan:  but you can't do "port number: " ++ port can you?
02:21:21 <CakeProphet> > :t (++)
02:21:22 <lambdabot>   <no location info>: parse error on input `:'
02:21:24 <ski> `show port' ?
02:21:25 <Saizan> CakeProphet: "port number: " ++ show port
02:21:25 <Eduard_Munteanu> ski: hm... not really polymorphism. It just gets all possible monomorphic variants at compile-time.
02:21:31 <CakeProphet> Saizan:  ah okay.
02:21:40 <ski> Eduard_Munteanu : no, only a single one of them
02:21:45 <CakeProphet> :t (++)
02:21:46 <lambdabot> forall m. (Monoid m) => m -> m -> m
02:21:50 <ski> (if there're more than one, you get a type error)
02:21:50 <CakeProphet> :t concat
02:21:51 <lambdabot> forall a. [[a]] -> [a]
02:21:53 <Eduard_Munteanu> Ah.
02:22:25 <CakeProphet> I might just make some helper functions to make logging convenient
02:22:35 <CakeProphet> ah... but I'd need existentials. Damn.
02:22:42 <Saizan> i also like "unwords ["port number:", show port, "something else"]"
02:22:48 <ski> Eduard_Munteanu : i mentioned this because this would be an example of the use of `foo' actually helping determine the type that `foo's definition gets
02:22:50 <Eduard_Munteanu> CakeProphet: maybe not.
02:22:54 <CakeProphet> I completely forgot something like showConcat ["Port number: ", port] would be entirely fallacious.
02:23:06 <ski> Eduard_Munteanu : but this situation doesn't exist in Haskell
02:23:23 <Saizan> ski: well, it kind of does with the MR on
02:23:25 <Twey> Wait, why is Haskell below C and C++ for thread-ring now?
02:23:39 <ski>   concat ["Port number: ", show port]
02:23:58 <ski> Saizan : well, it's not the use that determines, but `default' declarations ..
02:24:44 <Saizan> ski: no, e.g. "x = 1; y = x :: Word" within the same recursive binding (e.g. the same module) will infer Word as the type of x
02:24:53 <Eduard_Munteanu> CakeProphet: for every showable type, you can have a function that concats that with another string.
02:24:58 <Saizan> s/as/for/
02:25:05 <chrisdone> ski: unwords is specifically convenient when you don't want to balance spaces... especially if the list only contains variables... unwords [x,y,z] vs concat [x ++" ",y++" ",z]
02:25:06 <Eduard_Munteanu> You don't really need existentials.
02:25:09 <ski> (however, if you use monorphic binders like `\' or `<-', then the use helps determines the type of the "definition", of course)
02:25:23 <ngochai> Hi, can someone please tell me what's wrong here: http://pastebin.com/pUa92MJb?
02:25:41 <ski> chrisdone : well, vs. `concat [x," ",y," ",z]', but yes
02:25:46 <chrisdone> "Unknown paste ID, it may have expired or been deleted!"
02:25:50 <CakeProphet> Eduard_Munteanu:  that would work.
02:26:19 <CakeProphet> (<++>) :: (Show a) => String -> a -> String
02:26:20 <ngochai> here http://pastebin.com/pUa92MJb
02:26:51 <ski> Saizan : hm, ok .. i wasn't aware of that .. so only after doing its best on binding groups does it refer to `default', then ?
02:26:52 <Eduard_Munteanu> a <++> b = a ++ show b
02:26:52 <chrisdone> ngochai: did you reinstall containers?
02:27:24 <Eduard_Munteanu> Though I'm not sure about associativity.
02:27:28 <ngochai> <chrisdone> yes
02:27:29 <ski> Eduard_Munteanu : s/<++>/++:/ :)
02:27:37 <ivanm> ngochai: yeah, you shouldn't have...
02:27:50 <chrisdone> ngochai: then you need to reinstall cabal
02:27:52 <ski> (or should i have directed that to CakeProphet ?)
02:27:53 <Eduard_Munteanu> Well, yeah, that's better.
02:27:55 <ivanm> chrisdone: not quite
02:28:02 <ivanm> if this is in your user config, then probably the easiest thing to do is to delete that and start again
02:28:03 <Eduard_Munteanu> CakeProphet: ^
02:28:04 <Eduard_Munteanu> done :)
02:28:10 <ivanm> rm -rf ~/.ghc
02:28:11 <ngochai> oh dear!
02:28:28 <ivanm> ngochai: you should never use "cabal upgrade"
02:28:42 * ski . o O ( "reboot reboot reboot, i'm in my happy place" )
02:28:46 <chrisdone> what is this, bad advice hour?
02:28:56 <ngochai> ivan, why?
02:29:07 <ivanm> ngochai: precisely to avoid situations like this
02:29:17 <ivanm> the libraries that come with GHC should not be upgraded (except for Cabal)
02:29:29 <ivanm> but cabal-install is not currently smart enough to know which ones those are
02:29:43 <CakeProphet> Edward_:  hmmm, alright.
02:29:45 <ivanm> so if you want to upgrade a library you've already installed _by hand_, do "cabal install foo --reinstall"
02:29:53 <Saizan> ski: yep
02:30:02 <ivanm> it's situations like this that make me wish that ghc-pkg had an extra field to denote which ones are boot libraries, so cabal-install, etc. won't try to upgrade them
02:30:21 <ski> (i assume dcoutts is aware of the issue ..)
02:30:37 <CakeProphet> okay so if I call hIsEOF on a socket Handle it should only give (return True) when there's a disconnection.
02:31:23 <ngochai> actualy, I'm lost here, what's Cabal-1.8.0.2?
02:31:38 <ivanm> the actual Cabal library
02:31:40 <ivanm> @where Cabal
02:31:40 <lambdabot> http://www.haskell.org/cabal
02:32:03 <ivanm> I also happen to think that this is relevant for some reason... :p http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
02:32:38 <ngochai> ivan, damn, that's what I thought
02:32:47 <ivanm> cabal-install uses Cabal
02:32:52 <ivanm> (hence the name)
02:33:07 <JaffaCake> we really need to fix the naming
02:33:20 <JaffaCake> Cabal-> cabal-lib cabal-install -> cabal
02:33:31 <Saizan> also, ghc -> ghc-api :)
02:33:33 <ivanm> JaffaCake: yeah, I think dcoutts is planning on something like that for cabal-2
02:33:56 <ivanm> IIUC, they never thought about that before because the original plan was to have something like cabal-install as part of Cabal
02:34:06 <ivanm> then they realised that it would need extra libraries...
02:34:13 <Saizan> people use "build-depends: ghc >= 6.9" when they just want to depend on some version of the compiler, not the api
02:34:33 <Saizan> e.g. the vector package
02:34:41 <JaffaCake> yes, in retrospect perhaps calling it 'ghc' wasn't a great idea
02:35:09 <ivanm> Saizan: well, sometimes it's because they're also depending on compiler features
02:35:32 <ivanm> e.g. if you want to do some LLVM-related stuff, you'd want ghc >= 6.13; AFAIK that has nothing to do with its actual internal API
02:35:47 <ivanm> JaffaCake: what should it have been? CHC? MHC? MRHC?
02:35:48 <ivanm> ;-)
02:36:03 <Saizan> ivanm: that's what i meant by "depend on some version of the compiler"
02:36:06 <JaffaCake> the package, I meant
02:36:20 * wli is unsure what drove his last ghc upgrade cycle.
02:36:22 <JaffaCake> ghc-lib maybe
02:36:32 <ivanm> Saizan: I thought you were referring to the API, my apologies
02:36:44 <ivanm> though I find depending upon the version of base used to work as well
02:36:49 <wli> Maybe it was that having an ancient ghc made it tough to deal with other people's code.
02:37:29 <ivanm> and meant you were missing out on cool new features... ;-)
02:37:38 <Saizan> to depend on some version of ghc for it's features you use "if impl(ghc < ver) buildable: False" btw
02:38:23 <Saizan> afaiu, at least
02:39:08 <ngochai> well, so in my case I should reinstall cabal-install or Cabal?
02:39:36 <wli> I never understood the cool new features well enough to use them.
02:39:57 <ivanm> ngochai: your install of containers was borked
02:40:02 <ivanm> you probably have bigger issues than this
02:40:21 <ivanm> actually, you could try "ghc-pkg recache"
02:40:25 <ivanm> that _might_ fix it...
02:41:44 <CakeProphet> okay
02:42:08 <CakeProphet> so what would be the most painless way to automatically transform linux lines to windows lines in a file?
02:42:26 <CakeProphet> technically a String at this point.
02:42:51 <ivanm> CakeProphet: in Haskell?
02:43:05 <ivanm> I would normally just use dos2unix and unix2dos to do my conversions
02:43:26 <ivanm> CakeProphet: anyway, one possibility: get the split library, and do a split on \n
02:43:46 <ivanm> then remove those \n's from the front/end of each sub-list (not sure how split does it)
02:43:50 <ivanm> and then use unwords
02:43:56 <ivanm> s/unwords/unlines/
02:44:18 <ivanm> tweak as necessary for blank lines, etc.
02:44:21 <dibblego> @type (=<<) (\c -> if c == '\n' then "\r\n" else [c]
02:44:22 <lambdabot> parse error (possibly incorrect indentation)
02:44:28 <dibblego> @type (=<<) (\c -> if c == '\n' then "\r\n" else [c])
02:44:29 <lambdabot> [Char] -> [Char]
02:44:30 <CakeProphet> well... hmm
02:44:41 <CakeProphet> basically I'm doing it for networking, but I'm thinking it won't matter if I just use \n
02:45:04 <CakeProphet> because I beieve telnet uses windows style by default.
02:45:23 <augur> Saizan! Cale! :o
02:45:57 <augur> i believe i mightve mentioned to one of you that huet's zippers seem a lot like barker and shan's approach to natural language continuations in the types-as-graphs paper
02:46:09 <augur> well it turns out that huet's zippers are referenced
02:46:31 <augur> huet, abbott et al, and hinze and jeuring are cited
02:46:32 <wli> It's not Windows style. It's issuing terminal commands, not parroting text encodings.
02:46:50 <augur> as is belnap's display logic, which seems to have a conceptual predecessor in a different setting than huet
02:47:30 <CakeProphet> dibblego:  what would I need to do to change to \r\n ONLY if there's no \r
02:47:49 <CakeProphet> I'd need to be able to refer to the previous character.
02:47:59 <dibblego> parsec
02:48:09 <arcatan> regexp
02:48:15 <CakeProphet> hmmm, alright.
02:50:05 <ivanm> CakeProphet: that means he'll have 2 problems
02:51:43 <arcatan> i believe regexps have their time and place.
02:51:47 <CakeProphet> :t (<<=)
02:51:48 <lambdabot> Not in scope: `<<='
02:51:52 <CakeProphet> :t (=<<)
02:51:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:52:47 <arcatan> (<<=) is just flip (>>=)
02:53:03 <ivanm> you mean =<< ?
02:53:06 <ivanm> there's no <<=
02:53:12 <ivanm> @type (=<<)
02:53:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:53:18 <arcatan> mm yeah
02:53:18 <ivanm> @type flip (>>=)
02:53:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
02:53:23 <arcatan> I mistype it all the time
02:55:47 <CakeProphet> alright, another question. Is there a function like hGetLine but with the newline omitted?
02:56:35 <chrisdone> :t hGetBuf
02:56:35 <lambdabot> Not in scope: `hGetBuf'
02:56:41 <Twey> takeWhile (`notElem` "\r\n") <$> hGetLine
02:56:44 <chrisdone> lies
02:57:22 <chrisdone> Twey: lol
02:57:27 <Twey> >.>
02:57:34 <Twey> It's what I always end up doing
02:57:39 <chrisdone> could be a good solution if he specifies his requirements further
02:57:44 <ski> `(<<=)' is like `flip (=>>)' :)
02:57:51 <chrisdone> CakeProphet: does you want to consume a newline or not?
02:58:01 <CakeProphet> yes. consume newline, but not keep it.
02:58:04 <CakeProphet> I don't need it.
02:58:07 <ski>   (<<=) :: Comonad w => (w a -> b) -> (w a -> w b)
02:59:29 <chrisdone> Twey: i'm surprised there's no isNewLine in Data.Char
03:00:44 <Twey> Yeah
03:00:53 <chrisdone> the \n vs \r\n problem probably makes such a function more confusing than helpful
03:01:04 <Twey> Yeah :-\
03:01:11 <chrisdone> isCr, isLf, lol
03:01:12 <Twey> It depends on the handle
03:01:24 <ski> @let isNewLine = ('\n' ==)
03:01:26 <lambdabot>  Defined.
03:01:34 <chrisdone> can it be determined from a Handle?
03:01:35 <ski> @let isCarriageReturn = ('\r' ==)
03:01:37 <lambdabot>  Defined.
03:01:55 <chrisdone> in VB, it's vbCr, vbLf, vbCrLf >_>
03:02:25 <Saizan> if your Handle is in text mode on windows \r\n gets translated to \n
03:02:57 * ski thought `hGetLine' already didn't keep the newline ..
03:04:31 <CakeProphet> ski:  it would make sense that it wouldn't. The documentation doesn't seem to specify however.
03:04:53 <Eduard_Munteanu> Cobind won't work with monads though.
03:05:26 <Eduard_Munteanu> and it's probably not there if you don't pull category-extras
03:06:49 <ski> (it works with comonads, obviously :)
03:07:17 <ski> (though, i suppose e.g. `Stream' is both a monad and comonad ..)
03:07:40 <Eduard_Munteanu> @src Stream
03:07:41 <lambdabot> Source not found. That's something I cannot allow to happen.
03:07:45 <Eduard_Munteanu> Meh.
03:08:38 <augur> Saizan: hey. did you get what i said before? dont know if you saw it, my client crashed
03:08:44 <chrisdone> ski: you're right, it doesn't keep the newline. i don't know why CakeProphet's question made me think that it did
03:08:51 <chrisdone> subliminal
03:08:58 <ski>   data Stream a = Cons { head :: a , tail :: Stream a }  -- like this
03:09:19 <Eduard_Munteanu> Ah, category-extras makes it a Cofree
03:09:40 <Eduard_Munteanu> Well, that looks monadic, the one you show.
03:10:01 <Saizan> augur: saw it now :)
03:10:06 <augur> :)
03:10:11 <ski> augur : i don't see anything later than "<augur> is there a good resource for finding interesting and innovative papers like the huet or abbot et al papers?","<augur> ski? do you know of any?" where you attributed me ..
03:10:14 <CakeProphet> putStr = hPutStrLn h; putStrLn = hPutStrLn h; getLine = hGetLine h; prompt s = putStrLn s >> read
03:10:16 <chrisdone> Twey: which leads me to wonder why you do "takeWhile (`notElem` "\r\n") <$> hGetLine" considering hGetLine doesn't keep the newline?
03:10:21 <augur> ski: D:
03:10:32 <augur> well, i mentioned that barker and shan cited huet and others on the idea of zippers
03:10:37 <CakeProphet> dp {putStr =<< getLoginTxt; username <- prompt Mud.Config.prompt_username; ...} 
03:10:45 <CakeProphet> *do
03:10:47 <ski> Eduard_Munteanu : `return = repeat; join = diagonal'
03:10:50 <chrisdone> Î»> getLine >>= putStrLn . show
03:10:50 <chrisdone> hello
03:10:50 <chrisdone> "hello"
03:10:56 <CakeProphet> I don't know why. But I enjoy how clean do-notation can be.
03:10:58 <Eduard_Munteanu> :t diagonal
03:10:59 <lambdabot> Not in scope: `diagonal'
03:11:02 <ski> Eduard_Munteanu : `extract = head; split = tails'
03:11:11 <ski> Eduard_Munteanu : that's the basic operations
03:11:41 <Eduard_Munteanu> ski, nice, what's 'split'?
03:12:05 <wavewave> hello, any expert on gtk2hs?
03:12:24 <Eduard_Munteanu> ski: cojoin?
03:12:33 <ski> Eduard_Munteanu : in pseudo-haskell `diagonal [[a0,...],[b0,b1...],[c0,c1,c2,...],[d0,d1,d2,d3,...],...] = [a0,b1,c2,d3,...]'
03:12:45 <Eduard_Munteanu> Ah.
03:12:50 <ivanm> wavewave: ManateeLazyCat is who you want, but he doens't seem to be here atm
03:12:55 <ivanm> preflex: seen ManateeLazyCat
03:12:55 <preflex>  ManateeLazyCat was last seen on #haskell 5 hours, 4 minutes and 20 seconds ago, saying: mbuf: But i don't the detail, just information. :)
03:12:57 <ski> Eduard_Munteanu : yes, maybe `category-extras' calls it `cojoin' or `duplicate' or something like that, i don't recall
03:13:02 <wavewave> gtk2hs significantly changed, so many previous functions marked as deprecated..
03:13:16 * ski thinks `duplicate' is not really that good
03:13:17 <Eduard_Munteanu> ski: oh. They use duplicate and extend.
03:13:38 <Eduard_Munteanu> Where extend is =>>
03:13:45 <wavewave> I couldn't find some information on the new functions..
03:14:04 <CakeProphet> hmmm... how could I make the h implicit when dealing with handles
03:14:27 <CakeProphet> right now I just define a bunch of helper functions in a where clause. But I'd rather not do that for every function that will be prompting input (there will be multiple)
03:15:01 <Eduard_Munteanu> In fact scratch that, it's extract for coreturn, and either duplicate or extend.
03:15:17 <ski> yea, you can define `split'/`cojoin`/`duplicate' from `(<<=)'/`preserve', and in the other direction too, if you use `fmap' 
03:15:46 <Eduard_Munteanu> They should probably stick to coreturn, cojoin and =>> (cobind), it's probably easier to tell.
03:16:34 <ski> `extract' reads nice, i think
03:16:45 <Eduard_Munteanu> Yeah, that's more sensible.
03:16:58 <Eduard_Munteanu> It really fits m a -> a
03:17:06 <ski> `split' isn't really ideal, either .. though i think it is slightly better than `duplicate'
03:17:31 <Eduard_Munteanu> ski: maybe that works better for streams than comonads in general.
03:17:34 <ski> @src RandomGen
03:17:34 <lambdabot> class RandomGen g where
03:17:34 <lambdabot>    next     :: g -> (Int, g)
03:17:34 <lambdabot>    split    :: g -> (g, g)
03:17:35 <ski> ^
03:17:36 <lambdabot>    genRange :: g -> (Int,Int)
03:17:57 <Eduard_Munteanu> Yeah, there too.
03:18:32 <ski> the idea is that just as `join' collapses two monadic levels `m' into one, `split' "stages up" a single comonadic level `w' into two
03:19:00 <ski> (and that isn't just a simple duplication (in the usual sense), in general)
03:19:47 <Eduard_Munteanu> That's true.
03:19:54 <ski> it's more like splitting a natural number `n' into `a + b' in every possible way .. like in `sum_{n = a + b} (f a * g b)'
03:20:06 <Eduard_Munteanu> Though for categorical stuff, I usually prepend 'co-' in my head.
03:20:09 <ski> (cf. convolution)
03:20:39 <Eduard_Munteanu> and reverse arrows.
03:21:40 <ski> yeah .. but that doesn't really explain anything in a direct fashion
03:24:09 <ski> (hrm .. would `scaffold' ring the right bells ?)
03:24:39 <Eduard_Munteanu> For duplicate/cojoin/etc ?
03:24:42 <ski> yes
03:24:50 <Eduard_Munteanu> Yeah, actually it does.
03:25:22 <Eduard_Munteanu> Since it reapplies the (complex) comonad structure to a given value.
03:25:27 <ski> (other possibilities might maybe be `substructures' or `partition' .. but i think those are probably too specific)
03:25:52 <ivanm> preflex: seen bos
03:25:53 <preflex>  bos was last seen on #haskell 3 days, 11 hours, 15 minutes and 53 seconds ago, saying: ivanm: yeah, i'd fixed it before he reported it
03:26:08 * ski 'l try using `scaffold' instead of `split', then next time comonads come up, then :)
03:26:22 <Eduard_Munteanu> I image we could use barbershopmirroreffect for it too :P
03:26:47 <Eduard_Munteanu> *imagine
03:27:17 <Eduard_Munteanu> Though that's particular.
03:28:32 <Saizan> the recent thread on libraries made me connect prolog's select to duplicate for the list zipper comonad, though it doesn't quite match because on the outer layer you've a list (or bag?) of the possible splits, not a zipper
03:29:18 <Eduard_Munteanu> ski: btw, you know any other comonads that are also monads? Generally I'm talking about a trivial distributivity law, no concerns about that.
03:29:30 <dibblego> Identity
03:29:41 <ski> Eduard_Munteanu : i mentioned `Stream' above .. there's also `Identity', obviously
03:29:47 <Eduard_Munteanu> Mm, yeah.
03:30:48 <Eduard_Munteanu> Obviously I'm thinking whether something that has both return and coreturn is safe to use?
03:30:58 <Eduard_Munteanu> s/?/\./
03:31:00 <ski> Eduard_Munteanu : also, `(rho ->)' where `Monoid rho' .. and `(w,)' where `Monoid w'
03:31:32 <ski> (basically, both of those uses the trivial comonoid for the "other" one of `Monad' and `Comonad')
03:31:33 <Eduard_Munteanu> Nice, thanks.
03:32:18 <ski> so, `Stream' is basically the same as `(Nat ->)', just defined directly, coninductively, insteda
03:34:14 <CakeProphet> okay. so if I have a case expression within a do
03:34:29 <CakeProphet> do I need to enclose each individual case inside a sub-do expression?
03:35:16 <Taejo> CakeProphet: each branch of a case must have an expression on the right hand side, so if you want to write that expression in do-style, yes
03:35:18 <Eduard_Munteanu> CakeProphet: if cases would just fill in the blanks upon evaluation, no
03:35:40 <CakeProphet> case ... of { Just p -> do {...}; Nothing -> do {...}}
03:36:33 <Taejo> CakeProphet: that is valid Haskell, but whether it does what you want (or is necessary) depends on the contents of the ..., and the context
03:37:16 <ski> (btw, this makes me wonder how useful `class Monad m => ComonoidM m w where destroyM :: w -> m (); splitM :: w -> m (w,w)' possibly used together with a `Monad' or `Comonad' class relativized to `Kleisli m', for the `m' in `ComonoidM m w' might be ..)
03:37:29 <Eduard_Munteanu> CakeProphet: you should take a look at what 'do' does and how it's expressed without syntactic sugar.
03:37:42 <CakeProphet> Eduard_Munteanu:  I understand how it's expressed without sugar
03:37:53 <CakeProphet> I'm asking if the syntax has special forms for case expressions
03:37:58 <ski> no
03:38:01 <Taejo> no, it doesn't
03:38:04 <CakeProphet> alright.
03:38:06 <ski> (but it might have had ..)
03:38:34 * ski str the corresponding case for `proc' has such ..
03:38:50 <Eduard_Munteanu> ski: ah, actually I'm thinking in simpler terms, like instancing from both Monad and Comonad.
03:39:24 <ski> Eduard_Munteanu : heh .. i was just wanting to generalize from the trivial comonoid to some useful non-trivial comonoid :)
03:40:01 <Eduard_Munteanu> ski: there's a thorough paper on combining monads and comonads...
03:40:08 <Eduard_Munteanu> Not sure where I found it.
03:41:56 <Eduard_Munteanu> Found it... http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.4130
03:42:06 <Eduard_Munteanu> But I still need to go through Awodey a bit better for that.
03:42:33 <ski> Eduard_Munteanu : like e.g. `instance ComonoidM [] [a] where destroyM [] = [()]; destroyM _ = []; splitM as = ([],as) ++ case as of [] -> []; a:as -> [(a:l,r) | (l,r) <- splitM as]'
03:43:27 <ski> @let destroyM :: MonadPlus m => [a] -> m (); destroyM [] = return (); destroyM _ = mzero
03:43:28 <lambdabot>  Defined.
03:43:48 <ski> @let splitM :: MonadPlus m => [a] -> m ([a],[a]); splitM as = ([],as) ++ case as of [] -> []; a:as -> [(a:l,r) | (l,r) <- splitM as]
03:43:49 <lambdabot>  <local>:7:85:
03:43:49 <lambdabot>      Couldn't match expected type `([a1], [a])'
03:43:49 <lambdabot>             ag...
03:44:48 <ski> @let splitM :: MonadPlus m => [a] -> m ([a],[a]); splitM as = return ([],as) `mplus` case as of [] -> mzero; a:as -> liftM (\(l,r) -> (a:l,r)) (splitM as)
03:44:49 <lambdabot>  Defined.
03:45:01 <Eduard_Munteanu> I see.
03:45:15 <ski> > splitM "abcd" :: [(String,String)]
03:45:17 <lambdabot>   [("","abcd"),("a","bcd"),("ab","cd"),("abc","d"),("abcd","")]
03:45:24 <ski> > splitM "abcd" :: [()]
03:45:26 <lambdabot>   Couldn't match expected type `()'
03:45:26 <lambdabot>         against inferred type `([GHC.Type...
03:45:30 <ski> > destroyM "abcd" :: [()]
03:45:31 <lambdabot>   []
03:45:33 <ski> > destroyM "" :: [()]
03:45:34 <lambdabot>   [()]
03:45:44 <ski> .. and similarly for naturals
03:46:28 <ski> (note that with the current interpretation of `MonadPlus', i think those types are probably slightly too general .. the corresponding laws won't hold when `m' is `Maybe', e.g.)
03:47:22 <ski> another example of comonoids might be comonoids over vector spaces .. usually called "coalgebras" (stupid name)
03:48:13 <Eduard_Munteanu> Mmm... how is that useful?
03:49:02 <Eduard_Munteanu> Oh, I think I know, it relates a tiny bit to Cale's example of cellular automata.
03:49:10 <CakeProphet> is there a monad I could use to simplify transactions with a single handle/device/whatever?
03:49:16 <Raynes> When are they going to change the name of Haskell to cohaskell?
03:49:46 <Taejo> no, no, Cohaskell is a different language
03:49:54 <CakeProphet> for example I have a socket connection that is connected to a user on the other end. I want to prompt them for a lot of things and display text back to them. Is there a way to avoid typing a bunch of handle variables?
03:49:56 <Taejo> one with id :: a <- a
03:50:06 * Eduard_Munteanu imagines writing f :: a <- b <- c in coHaskell :P
03:50:15 <Eduard_Munteanu> Heh yeah.
03:50:53 <Eduard_Munteanu> CakeProphet: perhaps there's a variant of 'interact' for that.
03:51:04 <Eduard_Munteanu> (or you could write one)
03:51:44 <Eduard_Munteanu> @src interact
03:51:44 <lambdabot> interact f = do s <- getContents; putStr (f s)
03:52:21 <ski> Eduard_Munteanu : well, i don't know that much about it, but : <http://en.wikipedia.org/wiki/Coalgebra#Examples> has some examples, and <http://en.wikipedia.org/wiki/Hopf_algebra> which is something which is sortof like simultaneously like a group and a cogroup
03:52:21 <Eduard_Munteanu> That way you could keep writing pure code for the most part.
03:52:37 <Eduard_Munteanu> Oh, I remember reading a bit on Hopf algebra.
03:52:50 <Eduard_Munteanu> Thanks for reminding me.
03:53:22 <Eduard_Munteanu> Though I'm not sure what a cogroup is.
03:53:30 <Eduard_Munteanu> (and I'm okay with group theory)
03:53:41 <CakeProphet> Eduard_Munteanu:  I think what I want is Continuation actually.
03:54:00 <CakeProphet> I just want to write in do-notation, and then substitute values in later.
03:54:37 <Eduard_Munteanu> Ah, if you want to stick to do stuff, probably an interact variant isn't what you need.
03:55:48 <ski> obviously, Cohaskell must correspond via Curry-Howard to dual-intuitionistic logic
03:56:12 <CakeProphet> if the main thread quits
03:56:17 <CakeProphet> does the entire application exit?
03:56:28 <ski> (<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.8339> "Dual intuitionistic logic revisited"  <- not read)
03:56:47 * Eduard_Munteanu writes that down
03:57:25 <ski> Eduard_Munteanu : in Hopf algebra, instead of being able to define a map `(a,b) |-> a^-1 * b * a', e.g.
03:59:21 <ski> Eduard_Munteanu : you're not allowed to reuse (or discard) `a' (or any input) as you like, instead you must use specific `destroy : H -> I' and `split : H -> H (x) H' morphisms, where `I' and `(x)' in our category form a monoidal category that generally is *not* the categorical product with terminal object
04:03:04 <harlekin> Is there a FRP library for GTK programming which is actively used?
04:03:44 <handonson> harlekin: what do you mean by GTK programming
04:03:46 <ski> augur : iirc, Oleg relates Zippers to delimited continuations
04:03:56 <augur> cool
04:04:15 <handonson> since "GTK programming", interpreted literally, is a very imperative programming
04:04:16 <harlekin> handonson, I'd like to use reactive programming for GTK applications.
04:04:37 <harlekin> Grapefruit seems like a good attempt, but it doesn't seem to be actively maintained.
04:04:51 <handonson> harlekin: you may use some FRP layers that depends on wxHaskell
04:05:04 <handonson> i don't know if Phooey is still active
04:05:32 <ski> preflex: xseen conal
04:05:46 <ski> preflex: seen conal
04:05:49 <ski> ..
04:06:44 <CakeProphet> when does readFile close the file?
04:06:55 <CakeProphet> well, no that's not the question
04:06:59 <harlekin> handonson, thanks. I'll take a look at Phooey and FRP libraries for wxHaskell.
04:07:00 <CakeProphet> I'm asking if it does close the file.
04:07:21 <ski> iirc, when you read the end of the string, or when it GCs the rest of the string
04:07:53 * hackagebot cuboid 0.14.1 - 3D Yampa/GLUT Puzzle Game  http://hackage.haskell.org/package/cuboid-0.14.1 (PedroMartins)
04:08:06 <ski> (.. you could ask conal about Phooey, if he were here)
04:08:46 <harlekin> ski, thanks.
04:09:47 <gwern> @wn endue
04:09:49 <lambdabot> *** "endue" wn "WordNet (r) 2.0"
04:09:49 <lambdabot> endue
04:09:49 <lambdabot>      v : give qualities or abilities to [syn: {endow}, {indue}, {gift},
04:09:49 <lambdabot>           {empower}, {invest}]
04:10:00 <gwern> well, there's an unusual form of 'imbue'
04:10:05 <gwern> wonder why I used it
04:11:01 <ski> > "indue" == "imbue"
04:11:02 <lambdabot>   False
04:11:05 <handonson> CakeProphet: yes, it closes the file for you. (and even if it didn't, there's nothing you can do about it, because it doesn't return you the handle - file descriptor to open/close the stream.)
04:12:08 <ski> `hReadFile' "semi-closes" the `Handle' .. meaning that it `hClose's it for you some time later .. you should not `hClose' it yourself
04:13:47 <handonson> CakeProphet: needless to say but ... there is 'openFile' that does give you the handle, but in most cases it is not a recommended practice to use it directly. 'withFile' is usually the answer.
04:14:48 <ski> preflex: xseen conal
04:14:49 <preflex>  conal was last seen on freenode/#haskell 18 hours, 11 minutes and 34 seconds ago, saying: technogeeky: hey there
04:15:11 <ski> harlekin : ^ not *that* long ago ..
04:18:41 <aavogt> harlekin: I think phooey is abandoned, but maybe that's changed or I remember incorrectly
04:19:29 <Raynes> I hate people who use LaTeX style quotes.
04:19:37 <Raynes> That means you, ski. ;p
04:20:23 <aavogt> ghc does it
04:20:35 <bremner> Raynes: \textbf{Why?}
04:22:04 <osfameron> Raynes: apparently it balances in some font on X-terminals that don't exist anymore
04:22:14 <osfameron> the fact that it doesn't in any font currently in use is of no importance
04:23:32 <cheater99> hey guys
04:23:55 <cheater99> how does unit testing work in haskell?
04:24:42 <ivanm> @google HUnit
04:24:43 <lambdabot> http://hunit.sourceforge.net/
04:24:43 <lambdabot> Title: HUnit -- Haskell Unit Testing
04:24:45 <ivanm> cheater99: ^^
04:24:48 <cheater99> ok thanks
04:24:52 <ivanm> even better: QuickCheck!
04:24:53 <cheater99> next question
04:24:57 <ivanm> @hoogle QuickCheck
04:24:58 <lambdabot> package QuickCheck
04:24:58 <lambdabot> module Debug.QuickCheck
04:24:58 <lambdabot> module Test.QuickCheck
04:25:04 <ivanm> @hackage QuickCheck
04:25:04 <lambdabot> http://hackage.haskell.org/package/QuickCheck
04:25:14 <Raynes> Even better: No check! Just write correct software.
04:25:17 <Raynes> :D
04:25:19 <cheater99> is it possible to test a function not using specific values, but e.g. ranges of values? or against 'all possible values'?
04:25:39 <ski> (osfameron : actually they balanced on a GNU Emacs at uni some years ago ..)
04:25:44 <ivanm> Raynes: how do you prove it though?
04:25:46 <cheater99> like say...
04:25:52 <ivanm> cheater99: QuickCheck...
04:25:58 <ivanm> see the section in RWH
04:26:18 <cheater99> ivanm: quickcheck does range testing?
04:26:21 <arw> cheater99: "all possible values" would be a mathematical proof. thats mostly a little harder to do than a test.
04:26:23 <Raynes> ./application
04:26:26 <ski> cheater99 : for small ranges, you can enumerate everything in that range, yes
04:26:30 <osfameron> ski: yay ;-)
04:26:30 <Raynes> If it runs, it's proof enough for me. :D
04:26:48 <ClaudiusMaximus> @hoogle smallcheck
04:26:48 <lambdabot> No results found
04:27:05 <cheater99> ski: i'm thinking of infinite ranges.
04:27:40 <ski> cheater99 : also, in some cases, you can use something like <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/> and <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/> for infinite ranges
04:27:50 <dafis> cheater99, for infinite ranges, a mathematical proof would be faster than an exhaustive test
04:28:00 <ski> cheater99 : in general, you'll need to sample the test space somehow, though ..
04:28:20 <cheater99> something like this:       for all x \in R: f "seq" x == x+1
04:28:56 <cheater99> or even: if x = "add" and g is specified, then f "add" == g
04:29:21 <cheater99> dafis: that's exactly what i'm hoping for, a mathematical proof
04:29:27 <cheater99> ski: no
04:29:46 <cheater99> ski: you can make deductions based on the function.
04:29:47 <ski> cheater99 : e.g. given a two *total* function `f,g :: (Natural -> Bool) -> Bool', it is possible to check whether `f' and `g' are equal, by running a Haskell program :)
04:30:29 <ski> (the program you run is 'forAll $ \xs -> f xs == g xs' .. and that always terminates, when `f' and `g' are total)
04:30:47 <dafis> cheater99, either get out pencil and paper and prove it (there are some rare cases where a proof can be constructed by a programme, but usually, human brain is the best bet) or be satisfied with testing on a number of arbitrary inputs
04:31:20 <cheater99> dafis: i am not satisfied with either approach you suggest and think it is not smart to be satisfied with that
04:31:31 <ski> .. so, i'm imagining that for some programs, one might actually check properties exhaustively on infinite data, this way
04:31:31 <dafis> cheater99, why?
04:32:01 <cheater99> dafis: because functions can obviously act in a discontinuous manner.
04:32:20 <dolio> That's obvious?
04:32:37 <dolio> Some folks say it's obvious that all functions are continuous.
04:32:37 <cheater99> dolio: as i said.
04:32:40 <dafis> cheater99, so how's that an argument agains a proof with pencil and paper?
04:32:44 <ivanm> cheater99: so you want a program to automagically prove your code is correct?
04:33:36 <ski> cheater99 : <http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/> "Sometimes all functions are continuous" ;)
04:35:13 <interferon> what do i do about this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27030#a27030
04:35:14 <interferon> 0
04:35:30 <varnie> hello again. where can i find list of common typeclasses and type constraints  ? 
04:35:47 <interferon> varnie: the typeclassopedia
04:35:48 <aavogt> varnie: in some code
04:35:56 <cheater99> ivanm: ? not automatically. i tell it what tests to run.
04:36:00 <dafis> interferon, remove the directory package from your user database
04:36:06 <varnie> bad joke
04:36:17 <interferon> dafis: i tried hide, are you saying i should use unregister?
04:36:36 <varnie> ooops. i didn't know it exists ;))
04:36:47 <dafis> interferon: very probably.
04:37:05 <varnie> and what about type constraints list ?
04:37:13 <interferon> more generally, how do i keep getting these package conflicts?  i'm not doing anything stupid like "cabal upgrade"
04:37:47 <cheater99> ski: so how does this forAll thing work?
04:38:27 <Saizan> interferon: see the first cabal FAQ
04:38:31 <dafis> interferon: what does ghc-pkg check say?
04:38:47 <Saizan> ghc-pkg check won't report any problem, i think
04:39:06 <dafis> Saizan: probably not, just checking
04:39:11 <interferon> hmm, ghc-pkg check is very angry: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27031#a27031
04:39:30 <Saizan> hah
04:39:47 <benmachine> so something went wrong with directory and that broke haskell98 and then lots of things got upset
04:39:49 <interferon> Saizan: but i'm not intentionally installing system packages in my userdb, not sure how it keeps happening
04:39:58 <dafis> interferon: then the more interesting question, what does ghc-pkg unregister --user directory say?
04:40:19 <interferon> dafis: ghc-pkg: unregistering directory would break the following packages: ghc-6.12.1 QuickCheck-2.1.0.3 bin-package-db-0.0.0.0 hpc-0.5.0.4 wxFruit-0.1.2 QuickCheck-2.1.0.3 dyre-0.8.3 xdg-basedir-0.2 cautious-file-0.1.5 haddock-2.7.2 hashed-storage-0.5.2 wx-0.12.1.6 wxcore-0.12.1.6 darcs-2.4.4 haskeline-0.6.2.2 hashed-storage-0.4.13 haskelldb-hdbc-sqlite3-0.13 heist-0.2.0 TCache-0.6.5 haskelldb-hdbc-0.13 haskelldb-0.13 
04:40:20 <interferon> HStringTemplate-0.6.3 vector-0.6.0.1 heist-0.1.2 directory-tree-0.1.1 (use --force to override)
04:40:43 <benmachine> dafis: try ghc-pkg list directory, to check which versions are installed where
04:40:56 <interferon> do most people install packages globally?
04:41:04 <benmachine> I don't think most people do but I do
04:41:07 <interferon> maybe that's my problem
04:41:12 <benmachine> can't quite remember why :P
04:41:36 <benmachine> cabal-install defaults to user installs
04:41:44 <Saizan> interferon: cabal-install might decide to do that if it's needed to build a consistent dependency tree for the package you ask it to install, the problem is that it later won't understand the situation it created :)
04:41:44 <benmachine> runhaskell Setup.hs defaults to global, I think
04:41:46 <dafis> interferon:your problem is that at sometime you've installed a second version of a core library
04:42:06 <dafis> benmachine, correct
04:42:15 <Saizan> interferon: hopefully by the end of this week i'll have a patch to make it do so
04:42:44 <Saizan> interferon: installing globally would just be worse
04:43:47 <dafis> interferon: and then a lot of libs were built against the new directory, breaking everything also depending on (some) other core libs
04:44:25 <dafis> interferon: as long as you do user installs, you can just nuke the package-db in case of emergency
04:44:52 <dafis> interferon: with global installs, you'd probably have to reinstall ghc
04:45:19 <interferon> Saizan: a patch for what?
04:45:27 <interferon> dafis: true
04:45:28 <Saizan> interferon: for cabal-install
04:45:33 <Saizan> interferon: and Cabal
04:45:36 <interferon> Saizan: sorry :)  a patch to do what?
04:45:52 <dafis> Saizan: That would be widely appreciated
04:45:54 <interferon> dafis: so how should i resolve my current problem?  blow away the userdb?
04:46:17 <Saizan> interferon: to not get confused by the presence of multiple installations of the same version of the same package
04:47:15 <interferon> Saizan: is there a simple, all-purpose way to decide that?
04:47:35 <Saizan> interferon: decide what?
04:48:26 <interferon> Saizan: which package to use when there are multiple installations
04:48:47 <dafis> interferon: I don't know, ghc-pkg says unregistering directory from the *user* db would break the ghc package, that seems very serious
04:49:19 <dafis> interferon: try finding a Cabal expert
04:49:22 <Saizan> mh, that might be a bug in ghc-pkg, i can't see how that'd happen..
04:49:50 <Saizan> unless the directoy built for the userdb got the same ABI hash by chance
04:50:23 <ski> cheater99 : see the above "Seemingly impossible functional programs" and "A Haskell monad for infinite search in finite time" links
04:51:02 <Saizan> interferon: if you're using a package B that depends on A, and you have multiple installations of A, then you've to pick the installation B was built against
04:52:41 <Saizan> interferon: otherwise it'd use some default criterion
04:52:45 <Saizan> *defaulting
04:52:59 <interferon> true
04:53:21 <interferon> okay, so is my package set just hopeless?  do i need to "rm -rf ~/.cabal" and start from scratch?
04:54:19 <Saizan> it's "rm -rf ~/.ghc" btw
04:54:59 <Saizan> however i don't know, we'd have to look at the "depends" fields
04:55:24 <Saizan> and if what ghc-pkg says is right you'd need to reinstall ghc from scratch
04:56:33 <interferon> Saizan: oof!
04:56:51 <interferon> i've had to do something like that already once in the past....nobody else has this problem?
04:57:04 <benmachine> I broke something by installing random a while back
04:57:19 <Saizan> it's a recurring problem, maybe not so severe though
04:57:26 <benmachine> luckily for me the problem could be contained, but it involved some reinstalling
04:57:29 <Saizan> i guess it's mostly a problem if you use the ghc api
04:57:30 <benmachine> and losing all the dph libraries
05:00:34 <ivanm> I wish there was a way for ghci to automatically save its bytecode for modules so it didn't have to re-load large modules when I want to look at a different module :s
05:01:28 <dafis> ivanm: compile, then it'll just have to slurp in an .o file ;)
05:06:56 <HugoDaniel> exceptions should pop inside IO monad
05:13:04 <interferon> thanks for the help, all
05:28:29 <aavogt> HugoDaniel: and any infinite stream should take infinite space in the IO monad?
05:32:16 <chrisdone> ivanm: yeah i do what dafis says. ghc --make -c
05:32:59 <ivanm> chrisdone: huh?
05:33:10 <ivanm> oh, wait, I forgot I asked that :s
05:33:44 <ivanm> is it possible to use a build directory and also have ghci look in there?
05:33:54 <exDM69> aavogt: nope, they are lazily evaluated like everything else
05:35:19 <chrisdone> woops, i accidentally changed my haskell IRC buffer to haskell-mode
05:36:42 <kmc> hahaha
05:36:48 <ivanm> chrisdone: heh
05:36:52 <kmc> set it to literate haskell and it will highlight lambdabot queries?
05:37:05 <chrisdone> ivanm: maybe :set -I<foo>?
05:37:11 <chrisdone> kmc: :)
05:39:06 <chrisdone> ivanm: also :set -odir<object files dir>
05:39:29 <chrisdone> i was thinking about writing a lil something for inferior-haskell-mode to support doing this automatically
05:40:10 <ivanm> hmmmm.....
05:40:28 <ivanm> kmc: once again using you as my test guinea pig :p
05:40:35 <ivanm> what did you think of my proposals on -cafe?
05:41:49 <chrisdone> no one responded to my hdbc thread
05:42:00 <ivanm> chrisdone: well, that's because I have no view on the matter
05:42:09 <ivanm> which is the same reason why no-one responded to mine :p
05:42:16 <chrisdone> most of my haskell-cafe threads go un-replied-to. i must just have uninteresting problems
05:42:28 <ivanm> but kmc admitted to me the other day that he uses graphviz...
05:42:36 <kmc> which proposal?
05:42:39 * ivanm tries to cover up his maniacal grin
05:43:03 <quicksilver> chrisdone: or too interesting, so it's too hard to reply
05:43:05 <chrisdone> ivanm: mechanical grin. don't forget that you're a robot and i made you
05:43:07 <ivanm> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/77012
05:43:17 <ivanm> chrisdone: I beg to differ
05:43:27 <ivanm> I have neither American nor Italian connections
05:43:32 <chrisdone> quicksilver: thanks for the looking on the bright side advice :p
05:44:01 <ivanm> s/advice/of life/
05:44:14 <ivanm> strangely enough, listware.net was google's first result for "haskell graphviz canonical" (sans quotes)
05:44:37 <chrisdone> ivanm: is that a reference to my nationality? just checking, you're aware that i'm british
05:44:44 <kmc> ivanm, i don't have a strong opinion
05:44:52 <ivanm> chrisdone: fine, s/American/British/
05:44:55 <ivanm> my apologies
05:45:01 <ivanm> kmc: *nod*
05:45:32 <ivanm> then again, I discovered trying to do a graphviz visualisation of something (not in Haskell) that there's some really weird interactions going on
05:45:33 <chrisdone> it doesn't bother me, but for demographical purposes i suppose it's important
05:47:17 <ivanm> the result of this dot code is non-intuitive IMHO: digraph { a; subgraph cluster {a -> b}}
05:47:30 <ivanm> I would expect b to be inside the box and a to be outside; in fact they're _both_ inside
05:47:41 <ivanm> which puts a crimp into my canonicalisation plans :s
05:48:50 <aavogt> exDM69: you won't get the exceptions forced as HugoDaniel was asking then
05:49:55 <aavogt> since the only way to tell realistically whether some code will throw an exception is by evaluating it
05:51:59 <ski> preflex: xseen mmorrow
05:51:59 <preflex>  mmorrow was last seen on freenode/#ghc 169 days, 9 hours, 54 minutes and 14 seconds ago, saying: * mmorrow is rtfm'ing
05:52:00 <aavogt> exDM69: also, there are varying degrees of laziness.   compare what happens with:     fmap (head . lines) getContents    vs.   getLine
05:52:06 <ski>  
05:52:50 <aavogt> exDM69: so I'm not sure what you mean by "like everything else"
05:53:17 <quicksilver> aavogt: getContents is broken.
05:53:20 <quicksilver> aavogt: it is not lazy
05:53:29 <quicksilver> aavogt: it is an absolute burning abomination.
05:53:36 <quicksilver> lazy IO is utterly unrelated to laziness
05:53:39 <quicksilver> (and utterly broken)
05:54:08 <exDM69> aavogt: I think I misunderstood you
05:54:32 <aavogt> maybe you hate it, but it's the same laziness for values applied to IO actions, quicksilver
05:54:53 <ivanm> ski: when should we start worrying?
05:54:59 <handonson> quicksilver: I'm interested. How exactly is it broken?
05:55:07 <ivanm> copumpkin and I already made one stab at finding him online, etc. about a month ago
05:55:07 * ski is not sure
05:55:11 <zygoloid> aavogt: no, it's really not. forcing lazy values doesn't cause side-effects.
05:55:18 <ski> i suppose it's a fuzzy property
05:55:20 <quicksilver> aavogt: no it's not.
05:55:28 <quicksilver> aavogt: it's somethign entirely different.
05:55:43 <ivanm> ski: when vacuum stops compiling and working? :p
05:55:45 <benmachine> laziness gets very very difficult without purity
05:55:52 <quicksilver> the whole point of lazy evaluation is that, because of purity, it doesn't matter what order you force things in
05:55:56 <quicksilver> that's what makes laziness sane.
05:56:06 <quicksilver> interleaving execution of non-deterministic actions
05:56:10 <quicksilver> with evaluation
05:56:14 <quicksilver> is definitely *not* laziness
05:56:23 <quicksilver> it's something altogether more powerful - and semantically unclear.
05:56:28 <aavogt> why is something completely different just because it behaves in a way that's unpleasant sometimes?
05:56:29 <ski> aavogt : you're aware that after `fmap (head . lines) (hGetContents h)' you may not touch `h', yes ?
05:56:43 <zygoloid> lazy IO is normal laziness in the same way that dynamic typing is static typing
05:56:52 <aavogt> ski: vaguely
05:56:55 <quicksilver> aavogt: "completely different" is hyperbole, yes.
05:57:15 <quicksilver> there is obviously a strong analogy which motivates the notion
05:57:26 <quicksilver> however they are not the same thing at all.
05:57:28 <aavogt> sure it's ugly, but the name makes sense: defer IO actions until you demand the value
05:57:35 <quicksilver> it makes sense
05:57:39 <quicksilver> but it *isn't* laziness
05:57:43 <quicksilver> (and it isn't sound)
05:57:54 <ski> ("sound" meaning what, here ?)
05:58:33 <quicksilver> ski: well, what I'm referring too is that the same 'pure thunk' may not have a well-defined denotation.
05:58:45 <quicksilver> ski: so you get 'pure thunks' which don't admit normal semantics.
05:58:57 <zygoloid> lazy IO is call-by-need on some denotational semantics. but not the denotational semantics of pure haskell.
05:58:59 <quicksilver> it's a kind of soundness failure IMO.
06:00:15 * ski thinks one probably could do a small-step operational semantics annotated with I/O that handled also `getContents' ..
06:00:30 * quicksilver nods
06:00:36 <quicksilver> I think you probably could too.
06:00:45 <ski> (but we still need a notion of `soundness' to compare with ..)
06:01:34 <Jafet> ski, so... taking the existing behaviour of hGetContents, and calling that the semantics?
06:02:23 <ski> heh, obviously it would be sound wrt to that :)
06:02:38 <ski> we'd want something more "natural-looking"
06:02:43 <ski> (whatever that means)
06:03:02 <Jafet> Admittedly, that's what "operational semantics" often means
06:03:22 <Jafet> <absentia> I submitted a bug to larry wall for perl.. way back when... saying that some math function was returning incorrect results ...so he changed the man page so that the results matched the man page. that was the last bug I ever submitted.
06:03:49 <ski> (.. maybe one could say something useful wrt some observational equivalence .. i'm not sure)
06:04:11 <Baughn> Implementation-defined semantics? Yay.
06:04:32 * Baughn would like to get getContents out of the prelude, please..
06:04:58 <aavogt> > lex "123 132 abc"
06:04:59 * ski wouldn't object
06:04:59 <lambdabot>   [("123"," 132 abc")]
06:05:25 <quicksilver> I wouldn't mind it being in the prelude, even, if (a) there was a non-interleaved alternative and (b) the situation was better documented.
06:05:28 <ski> > lex "'\\n'foo"
06:05:30 <lambdabot>   [("'\\n'","foo")]
06:05:40 <quicksilver> I'd rather the non-interleaved alternative got the straightforward name
06:05:45 <ivanm> Baughn: join the Haskell 2011 committee and push that through then!
06:05:57 <ski> you mean a "slurp all" variant ?
06:05:59 <Baughn> ivanm: I'd be too busy trying to fix the functor/monad mess
06:06:05 <Baughn> ivanm: And failing, no doubt.
06:06:07 <ivanm> heh
06:06:13 <quicksilver> getContents (note, slurps whole file into memory); interleavedGetContents (does IO sneakily in the background, please read list of caveats)
06:06:16 <ski> or one which iterated using a function argument ?
06:06:19 <Jafet> Perhaps it should be renamed
06:06:23 <cathper> If I have a function that I'd implement in a second that is used in some code, can I do something like "f = something" just to make it compile?
06:06:34 <quicksilver> cathper: f = undefined
06:06:34 <Jafet> I'd bet most existing programs don't care either way.
06:06:37 <ivanm> Baughn: btw, one thing in haskell-mode that's been bugging me for a while: for some reason, haskell-mode nowadays upon having a compilation error, the first error printed in ghci is skipped (as in no auto-linking, etc.)
06:06:40 <ivanm> any ideas why?
06:06:44 <aavogt> @hoogle something
06:06:45 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
06:06:51 <cathper> quicksilver: Thanks a bunch :-)
06:07:00 <Baughn> ivanm: Nope, I never used that, but I probably should. I'll have a look.
06:07:10 <ski>   foldContents :: s -> (Char -> s -> s) -> IO s
06:07:22 <quicksilver> ski: the iterating version is cool but significantly harder to use for newbies
06:07:30 <quicksilver> ski: I think the slurping version is worth having.
06:07:34 <ski>   foldContents' :: s -> (Char -> s -> IO s) -> IO s
06:07:36 <quicksilver> even with it's space-usage cavets.
06:07:49 <ivanm> Baughn: ta
06:07:53 <quicksilver> wouldn't the latter be foldContentsM?
06:07:55 <aavogt>   getContents == foldContents [] (:) ?
06:08:05 <ski> quicksilver : sure, when it's what you really want, you really want it (tautologically :)
06:08:10 <quicksilver> ski: quite.
06:08:33 <quicksilver> ski: but I think the emphasis for the prelude should be 'easy to use and powerful' combinators for newcomers
06:08:59 <aavogt> those requirements conflict I think
06:09:03 <ski> aavogt : i was actually thinking more like `getContents = foldContents [] (\s c -> s ++ [c]) = liftM reverse (foldContents [] (:))'
06:09:20 <ski> (s/s c/c s/)
06:09:26 <Baughn> A strict readFile would be perfectly fine; needing interleaved I/O is very much the exception, not the rule
06:09:31 <Jafet> getContentsNow = do let s <- getContents; return $ length s `seq` s
06:10:01 <ski> quicksilver : well, i wouldn't say `slurpContents' is really that powerful
06:10:12 <Baughn> And yes, I'm starting to think of Prelude as being the module for beginners, not something that should be used everywhere
06:10:47 <aavogt> @type gfoldl
06:10:48 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
06:10:48 <Baughn> It might be useful to have an explicit split, with an AdvancedPrelude in the base
06:10:53 <ski> (nice to have in awhile, yes .. but often you'd want a folding variant instead, then)
06:11:12 <aavogt> the more fancy the parameters, the more you can do, the harder it is to figure out how to use the function
06:11:36 <ski> Baughn : you mean like `class Functor f where map :: (a -> b) -> (f a -> f b)' in `AdvancedPrelude' ?
06:11:55 <djahandarie> Why does the monad/functor mess even exist in the first place? It's not like they were treading new ground when they were coming up with this stuff
06:11:58 <ski> aavogt : sometimes
06:12:25 <Baughn> ski: http://hackage.haskell.org/packages/archive/ClassyPrelude/0.1/doc/html/Prelude-Classy.html <- More like this
06:12:42 <Baughn> ski: Setting map = fmap is a possibility; I just removed map entirely, to avoid clashing with Data.Map and such.
06:13:22 <aavogt> think of the cartographers you saved, Baughn
06:13:36 <aavogt> (the ones who enjoy -Wall that is)
06:14:40 * ski doesn't think qualified imports would be that bad .. with enough proper support so that enough module context is provided in errors when there'd be ambiguity otherwise
06:15:50 <Baughn> ski: And, oh yes, I flipped the associativity of $. =3=3
06:15:52 <ski> (and it would be nice to be able to `import' or at least "open" an `import'ed module inside a `let' and `where' (and `do' and list comphrehensions as well, i suppose))
06:16:25 <benmachine> interact/getContents as used with stdin are possibly more often wanted lazy than strict
06:16:31 <benmachine> but then getLine is more often wanted than either :P
06:17:26 <benmachine> I would appreciate a nice function for iterating over the lines of a file
06:17:52 <Darkovski> Huh. Just installed new haskell platform. Haven' read through anything yet, but I see something called "WinGHCi"?
06:18:01 <benmachine> and also, I'd like to be able to get a file line-by-line and not have to handle eof as an exception
06:18:05 <ivanm> Darkovski: just a gui wrapper around ghci
06:18:09 <Jafet> Iteratees, sir; they're all the rage
06:18:22 <benmachine> Jafet: yes but simpler
06:18:23 <Darkovski> Ahhh
06:18:45 <CakeProphet> :t interleave
06:18:46 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
06:18:49 <ski> Baughn : `interact . perLine' using <http://www.haskell.org/haskellwiki/TV#IO> ?
06:19:04 <CakeProphet> :t split
06:19:05 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
06:19:16 <CakeProphet> :t splitBy
06:19:17 <lambdabot> Not in scope: `splitBy'
06:19:19 <Baughn> ski: I hadn't heard about TV. Looks interesting.
06:19:39 <CakeProphet> benmachine:  you could just use hGetContents and then split the resulting string by newlines.
06:20:05 <ski> TV is quite interesting it itself (conal has invented it) .. i only linked for the SEC operaions `perLine',`perWord',`onLines',`onWords'
06:20:06 <benmachine> CakeProphet: yes but hGetContents is lazy and we're discussing how unpleasant lazy IO is :P
06:20:56 <benmachine> CakeProphet: so I'm asking for solutions that are sensibly deterministic *and* have reasonable space usage
06:21:02 <ski> (CakeProphet : what'cha looking for ?)
06:21:17 <benmachine> :t splitAt
06:21:18 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:21:21 <benmachine> :t span
06:21:21 <byorgey> :t span
06:21:22 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:21:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:21:26 <benmachine> :t break
06:21:27 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:21:36 <CakeProphet> I'm looking for whatever you could use to split a string into lines.
06:21:42 <byorgey> :t lines
06:21:44 <lambdabot> String -> [String]
06:21:47 <benmachine> heh
06:22:34 <CakeProphet> benmachine:  what's wrong with lazy IO?
06:25:01 <ski> @let onLines, onWords :: ([String] -> [String]) -> (String -> String); onLines f = unlines . f . lines; onWords f = unwords . f . words
06:25:02 <lambdabot>  Defined.
06:25:04 <ski> @let perLine,perWord :: (String -> String) -> (String -> String); perLine f = onLines (map f); perWord f = onWords (map f)
06:25:05 <lambdabot>  Defined.
06:28:55 <benmachine> CakeProphet: basically, surprising behaviour
06:29:11 <benmachine> the nice thing about normal laziness is that purity hides it from you
06:29:23 <benmachine> so it doesn't matter what order things are evaluated in, you get the same result
06:29:45 <benmachine> lazy IO isn't like that - subtle strictness concerns can change the behaviour of your program
06:30:07 * benmachine wonders if one could construct a program whose behaviour was changed by strictness analysis in optimisation
06:30:39 <ivanm> benmachine: a heisenprofile? :p
06:32:22 <benmachine> ivanm: maaaybe!
06:33:20 <ski> @check \x -> x == () ==> () == x
06:33:21 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:33:21 <lambdabot>                     (Test.QuickCh...
06:33:24 <ski> mfr ?
06:34:15 <ski> benmachine : i think so ..
06:34:56 <augur> ski, whats ==>
06:35:11 <ivanm> augur: it means only do this test if the LHS is true
06:35:18 <ski> @type (==>)
06:35:20 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
06:35:20 <ivanm> usually used for things like checking if a list is non-empty
06:35:30 <ski> augur : implication in QuickCheck
06:35:36 <augur> whaaa
06:35:38 <augur> prop? what
06:35:41 <augur> this is madness
06:35:51 <augur> also, so its simply implication?
06:36:06 <ski> @check \x -> not x == False ==> x == True
06:36:07 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:36:07 <lambdabot>                     (Test.QuickCh...
06:36:18 <augur> > True ==> True
06:36:19 <lambdabot>   Not in scope: `==>'
06:36:19 <ski> ought to work, except that something appears broken
06:36:41 <ski> @type True ==> True
06:36:42 <lambdabot> Property
06:37:01 <augur> is ==> a constructor??
06:37:03 <augur> what is it
06:37:12 <ski> > True Test.QuickCheck.==> True
06:37:13 <lambdabot>   Not in scope: `Test.QuickCheck.==>'
06:37:15 <McManiaC> @check \x -> (x == True) ==> (x == False)
06:37:16 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:37:17 <lambdabot>                     (Test.QuickCh...
06:37:18 <ski> it's a function
06:37:23 <augur> hm
06:37:28 <augur> its not in prelude is it
06:37:35 <ski> @index (==>)
06:37:36 <lambdabot> Test.QuickCheck, Debug.QuickCheck
06:37:40 <augur> ghci is telling me it doesnt exist
06:37:45 <augur> aha, ok
06:37:51 <augur> so its probably not implication then, eh.
06:37:51 * ski can never recall which of those one should use
06:38:01 <ski> iirc, it's in a package `quickcheck'
06:38:06 <handonson> gah! is there putChar that REALLY put char immediately?
06:38:14 <ski> augur : it is an implication .. of sorts
06:38:23 <augur> but not logical, as such
06:38:34 <ski> it's more like empirical implication
06:38:35 <McManiaC> handonson: immediately?
06:39:07 <quicksilver> handonson: hSetBuffering
06:39:15 <handonson> i wrote a code which putChars many time, compiled it with optimization option, then the executable just hangs for a while and suddenly prints everything
06:39:31 <quicksilver> because by default IO is buffered on all sane operating systems.
06:39:34 <quicksilver> You can turn the buffering off.
06:39:39 <ski> augur : in `foo ==> bar', if `foo' is `True' but `bar' is `False', then this is a counter-example to the property being checked, so there's a bug somewhere
06:39:49 <quicksilver> or you can keep calling hFlush.
06:39:59 <handonson> this didn't happen when i just ran it, rather than compiling it
06:40:00 <augur> ok so its implication for bugfinding
06:40:16 <ski> augur : if `foo' is `True' and `bar' is `True', then this is one piece of evidence for the property being checked
06:40:29 <Saizan_> handonson: ghci disables buffering
06:40:39 <handonson> oh, i see.
06:40:53 <ski> augur : however, if `foo' is `False', then this is not a valid example to test, so we *discard* it (instead of counting it also as a positive piece of evidence)
06:41:17 <augur> ok
06:42:21 <EvanR-work> @src Any
06:42:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:42:23 <ski> augur : then QuickCheck looks for some number of evidence (default 100, iirc), stopping if it finds a counter-example .. and giving up if it can't get the wanted amount of evidence in some large number of tries of generating examples (10000 per default, or something like that)
06:43:11 <ski> (also, SmallCheck, if it finds a counter-example, will try to "shrink" it so that it's reduced to a locally minimal counter-example)
06:43:45 <ski> @scheck True
06:43:46 <lambdabot>   "OK, passed 500 tests."
06:44:02 <ski> @index Any
06:44:02 <lambdabot> bzzt
06:44:07 <ski> @hoogle Any
06:44:07 <lambdabot> Data.Monoid newtype Any
06:44:07 <lambdabot> Data.Monoid Any :: Bool -> Any
06:44:07 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
06:44:35 <ski>   newtype Any = Any {getAny :: Bool}  -- i think
06:46:08 <McManiaC> @check True
06:46:09 <lambdabot>   "OK, passed 500 tests."
06:46:14 <McManiaC> @check \_ -> True
06:46:15 <lambdabot>   "OK, passed 500 tests."
06:46:17 <McManiaC> hm
06:46:44 <ski> @check False
06:46:45 <lambdabot>   "Falsifiable, after 0 tests:\n"
06:47:09 <McManiaC> @check \(x :: Bool) -> x
06:47:09 <lambdabot>   Parse error in pattern at "->" (column 14)
06:47:15 <djahandarie> @check \a -> a /= "z"
06:47:16 <lambdabot>   "OK, passed 500 tests."
06:47:20 <djahandarie> ;-)
06:47:37 <ski> @check not
06:47:38 <lambdabot>   "Falsifiable, after 1 tests:\nTrue\n"
06:47:41 <McManiaC> @check id
06:47:42 <lambdabot>   "Arguments exhausted after 0 tests."
06:47:46 <McManiaC> lol
06:47:54 <ski> @check (id :: Bool -> Bool)
06:47:55 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\n"
06:49:16 <McManiaC> @check (<= 500)
06:49:17 <lambdabot>   "OK, passed 500 tests."
06:49:20 <McManiaC> @check (< 500)
06:49:21 <lambdabot>   "OK, passed 500 tests."
06:49:25 <McManiaC> :>
06:49:36 <McManiaC> @check (< 5)
06:49:37 <soupdragon> "compact,   totally disconnected toplogical ring that contains the ordinary integers as a subring"
06:49:37 <lambdabot>   "Falsifiable, after 8 tests:\n6\n"
06:49:47 <McManiaC> @check (< 498)
06:49:48 <lambdabot>   "OK, passed 500 tests."
06:49:52 <McManiaC> @check (< 497)
06:49:52 <lambdabot>   "OK, passed 500 tests."
06:49:55 <McManiaC> :D
06:50:37 <burp> everything is smaller 497? :D
06:50:50 <McManiaC> obviously :)
06:51:43 <McManiaC> @check \x y -> x < y
06:51:44 <lambdabot>   "Falsifiable, after 0 tests:\n()\n()\n"
06:51:59 <McManiaC> () () ?
06:52:00 <McManiaC> :O
06:52:18 <McManiaC> > () < ()
06:52:19 <lambdabot>   False
06:52:27 <McManiaC> @type ()
06:52:28 <lambdabot> ()
06:52:36 <McManiaC> instances?
06:53:56 <mornfall> @check (< 300)
06:53:57 <lambdabot>   "OK, passed 500 tests."
06:54:07 <mornfall> @check (< 300 :: Nat)
06:54:08 <lambdabot>   Parse error at "::" (column 8)
06:54:11 <mornfall> Bleh. :)
06:54:41 <McManiaC> @check (< 100)
06:54:42 <lambdabot>   "Falsifiable, after 270 tests:\n116\n"
06:55:14 <mornfall> Well, it's random and hunched around 0.
06:55:28 <mornfall> @check (> (-200))
06:55:30 <lambdabot>   "Falsifiable, after 441 tests:\n-201\n"
06:55:32 <ivanm> @check liftM2 (||) (<300) (>300)
06:55:33 <lambdabot>   "OK, passed 500 tests."
06:55:36 <ivanm> ;-)
06:55:55 <McManiaC> =)
06:56:00 <mornfall> ivanm: ...
06:56:14 <ivanm> mornfall: checking to see if it generates _precisely_ 300!
06:56:21 <ivanm> (well, not 300 factorial, just 300)
06:56:31 <mornfall> Yes, I figured that much. :)
06:56:48 <McManiaC> (/= 300) :P
06:56:53 <mornfall> @check (/= 100)
06:56:54 <lambdabot>   "Falsifiable, after 287 tests:\n100\n"
06:56:58 <mornfall> :)
06:58:21 <mornfall> @check \x -> x > 0 ==> x < 300
06:58:22 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:58:22 <lambdabot>                     (Test.QuickCh...
06:59:08 <mornfall> Bummer.
06:59:25 <McManiaC> @check (> 0) ==> (< 300)
06:59:26 <lambdabot>   The section `GHC.Classes.> 0' takes one argument,
06:59:26 <lambdabot>  but its type `GHC.Bool.B...
06:59:54 <mornfall> Well, it works with my lambda above in GHCi.
07:00:02 <mornfall> And seems to produce desirable results. :)
07:02:37 <orlandu63> what is a use case for sequence? 
07:03:22 <soupdragon> if you haev alist of tings you want to d
07:03:23 <soupdragon> o
07:03:25 <soupdragon> sequence it
07:03:32 <McManiaC> sequence [return 5, Nothing, return 0]
07:03:35 <McManiaC> > sequence [return 5, Nothing, return 0]
07:03:36 <lambdabot>   Nothing
07:04:17 <soupdragon> sequecen [go to the kitchen, fill the kettle, wait for it to boil, get out a teacup, get a teabag, pour the water, ...]
07:04:32 <McManiaC> sequence [...] = do { ... }
07:04:46 <soupdragon> you have to change  ,  to  ;
07:04:47 <cathper> I have a function fun :: Integer -> Integer. I know that fun is decreasing. I want the sum of (fun i) for all i >= 0. How do I get this?
07:05:15 <cathper> Whould I have to find out when fun is zero first?
07:05:30 <soupdragon> cathper oh like once its zero it doesn't go negative?
07:05:32 <kdvh> make fun recursive
07:05:35 <McManiaC> sum (map fun [1..])
07:05:47 <McManiaC> or 0..
07:05:48 <McManiaC> ^^
07:05:49 <soupdragon> put
07:05:55 <soupdragon> sum (takeWhile (> 0) . map fun $ [1..])
07:05:55 <cathper> soupdragon: Right.
07:06:11 <kdvh> he said decreasing though
07:07:00 <cathper> kdvh: It won't be elegant, I think.
07:08:28 <McManiaC> > sum $ fun <$> [0..]
07:08:29 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
07:08:29 <lambdabot>    arising from the literal `...
07:08:37 <McManiaC> :D
07:08:58 <McManiaC> > let fun = (`subtract` 1) in sum $ fun <$> [0..10]
07:09:00 <lambdabot>   -44
07:09:23 <McManiaC> huh
07:09:43 <McManiaC> > let fun = (`subtract` 1) in fun <$> [0..2]
07:09:44 <lambdabot>   [1,0,-1]
07:09:47 <McManiaC> oh
07:09:47 <McManiaC> :D
07:09:51 <cathper> I'm constructing the set http://dl.dropbox.com/u/526970/set.jpg
07:11:08 <leino> say I want to define a datatype data Point = (MyType, MyType), but I want to restrict it so that MyType is a member of some typeclass (say Num for instance).. how would I do that?
07:11:36 <leino> oops, should be "data Point = Point (MyType, MyType)"
07:11:45 <McManiaC> type Num a => Point a = (MyType a, MyType a)
07:12:09 <CakeProphet> McManiaC:  I think he wants data not type.
07:12:10 <soupdragon> l e h = [ d | all (\d_i -> d_i + h s < q), (product . map (\d_i -> q - d_i - h * undefined) $ d) > e ]
07:12:27 <leino> CakeProphet: thats right
07:12:32 <McManiaC> data Num a => Point a = Point (MyType a) (MyType a)
07:13:07 <McManiaC> or use existential types and something like
07:13:19 <CakeProphet> why MyType a?  data Num a => Point a = Point a a
07:13:26 <CakeProphet> leino:  ^
07:13:38 <McManiaC> data Point = forall a. (Num a) => Point (MyType a) (MyType a)
07:13:39 <McManiaC> ^^
07:13:52 <McManiaC> yeh, or like that :>
07:14:33 <leino> what does the (Num a) => ... syntax mean exactly?
07:14:43 <CakeProphet> leino:  it constrains a to be of typeclass Num
07:14:46 <leino> that the type variable a is to be a member of Num?
07:14:47 <kdvh> class constraint
07:14:49 <McManiaC> "a" has to be instance of "Num"
07:14:54 <leino> ok
07:15:03 <kdvh> means that type variable a is a member of the Num typeclass
07:15:22 <leino> but then if MyType is a type, what means "MyType a" ?
07:15:32 <McManiaC> nothing :)
07:15:43 <CakeProphet> leino:  that's a polymorphic type. In this case that's not what you want. Instead you just want a by itself.
07:15:54 <leino> yeah I thought so
07:15:56 <CakeProphet> MyType would be some kind of type like []... which takes a type parameter.
07:16:03 <CakeProphet> or IO
07:16:07 <leino> you mean a typeclass?
07:16:12 <CakeProphet> if that were the behavior you wanted
07:16:13 <CakeProphet> and no
07:16:16 <CakeProphet> a polymophic type
07:16:30 <McManiaC> data Maybe a = Nothing | Just a
07:16:34 <McManiaC> foo :: Maybe Int
07:16:45 <CakeProphet> leino:  there's a difference between something like (Num  m) => m  and [m]
07:17:38 <CakeProphet> leino: [m] is a specific type: a list of type m. Num a is a typeclass constraint, a can be any type. [a] is a specific type.
07:18:01 <leino> ok, is data MyList a = [a] a polymorphic type?
07:18:19 <McManiaC> data always needs a constructor on the "right hand side"
07:18:20 <CakeProphet> leino:  the definition is technically not correct, but you've got the right idea.
07:18:33 <McManiaC> data MyList a = MyList [a]
07:18:36 <kdvh> you need a value constructor
07:18:36 <McManiaC> but yeh
07:18:36 <CakeProphet> leino:  data [a] = a : [a] | []
07:18:36 <McManiaC> :)
07:18:41 <leino> ah of course :)
07:19:01 <Paczesiowa> @pl \foo x -> ($foo x)
07:19:01 <lambdabot> (flip id .)
07:19:05 <CakeProphet> leino:  you can't do that in actual Haskell. But if you were to write out a data declaration for [a] that would be it.
07:19:27 <CakeProphet> leino:  to do something like that yourself you'd do.  data List a = Cons a [a] | Empty
07:19:29 <exDM69> leino: data List a = Cons a (List a) | Nil    -- here's an equivalent with less confusing syntax
07:21:02 <CakeProphet> leino:  do you get the difference between typeclasses and polymophic types?
07:21:28 <leino> I think so...
07:21:36 <CakeProphet> leino:  if you're familiar with standard OO languages, typeclasses are similar to interfaces, whereas polymorphic types are like generics.
07:21:53 <leino> a polymorphic type is something which takes a type as a parameter and spits out a type?
07:22:19 <philed> leino: Yeah, you can think of it as a function.
07:22:20 <Saizan_> no
07:22:26 <CakeProphet> leino:  not quite. It's a type that takes a type as a parameter. The values are partially dependent on an unknown type that is filled in later.
07:22:40 <Saizan_> a parameterized type is a type level function..
07:23:08 <Saizan_> a polymorphic type is a type function wrapped in a forall :)
07:23:23 <philed> A polymorphic expression can be regarded as a function from a type to another expression. The type of such an expression is a polymorphic type.
07:24:13 <Saizan_> rexactly
07:24:19 <McManiaC> btw, would something like "data |a> = |a>" be possible somehow? :>
07:25:02 <soupdragon> no it can't :(
07:25:24 <Saizan_> (even if it's more common to say "polymorphic value" instead of "polymorphic expression")
07:25:49 <CakeProphet> leino:  it's a sort of function in the type namespace, if you'd like to think of it that way. data Point a = Point a a. The left-hand side is the polymorphic type, and the right-hand side is the constructor that constructs values of Point a. if Point a is actually Point Int then the constructor holds two Ints, Point Char contains two Chars, and so on. Point a means that the type parameter is unknown or we don't care what 
07:26:42 <kdvh> to simplify, polymorphic types use type variables
07:27:05 <leino> allright, and what is a typeclass?
07:27:59 <Saizan_> i think it's quite wrong to say Point is a polymorphic type, but terminology is always a mess i guess, and implicit quantification doesn't help
07:28:41 <CakeProphet> leino:  a typeclass is a set of operations. You can declare types to be instances of that typeclass, and define the operations on that type. For example, all instances of the Show typeclass implement the show operation, which converts the value to a descriptive String
07:28:56 <kdvh> leino: if you are familiar with OO languages like java, type classes are like interfaces
07:29:25 <CakeProphet> typeclass Show a where show :: a -> String
07:29:31 <Saizan_> except that a java interface is a type, while a typeclass is not.
07:29:38 <Saizan_> and other things..
07:29:53 <Saizan_> like that overloading can be resolved on the result type too
07:29:57 <leino> allright.. maybe I should state my original problem :)
07:30:22 <Saizan_> CakeProphet: the keyword is class
07:30:44 <kdvh> the typeclass defines some behavior and members of the typeclass must behave that way
07:30:52 <CakeProphet> Saizan_:  ah. I guess I've yet to define my own typeclasses. :P
07:31:00 <kdvh> e. g. all members of the Num typecalss behave like numbers
07:31:13 <kdvh> all members of EQ typeclass support equality testing
07:31:15 <kdvh> and so on
07:32:17 <leino> I want to write a polynomial library, and so I want something called Coefficient, Monomial, Term, Polynomial... and I want Coefficient to be in Eq, and I want Term, Polynomial and Monomial to be in Ord
07:32:42 <CakeProphet> leino:  then you'll want to make instance declarations
07:32:45 <leino> but Coefficient should be "variable" so that I can have coefficients from Z, Q, Z_n etc...
07:32:51 <CakeProphet> for each type that implements a certain typeclass.
07:33:19 <Saizan_> leino: you can parametrize Polynomial on the coefficient type
07:34:36 <CakeProphet> Saizan_:  would it be easier to do something like data Coefficient = ConstantCoeff Int | VariableCoeff String
07:34:37 <leino> Saizan_: like "data Polynomial c = [Term c] ?
07:35:02 <leino> argh.. I meant data Polynomial c = Polynomial [Term c]
07:35:03 <Saizan_> leino: yeah
07:35:58 <Saizan_> CakeProphet: that doesn't let me use Integer/Rational/IntegerModuloN/.. as i please.
07:36:11 <CakeProphet> ah.
07:36:40 <CakeProphet> hmmm, but what would the definition for Term c be?
07:36:59 <leino> data Term c = (Coefficient c, Monomial)
07:37:16 <leino> data Term c = Term (Coefficient c, Monomial) rather :)
07:37:25 <CakeProphet> leino:  with the first syntax you'd want to use type
07:37:28 <Saizan_> probably without the tuple :)
07:37:45 <Saizan_> leino: ah, wait, why Coefficient c?
07:38:19 <leino> because Coefficient should be "variable"
07:38:50 <Saizan_> i mean, why not just c?
07:39:12 <leino> who not indeed...
07:39:15 <leino> yeah youre right
07:39:57 <leino> but then I need "data (Eq c) => Term c = Term (c, Monomial)"
07:40:01 <leino> if that is valid?
07:40:21 <CakeProphet> it is.
07:40:31 <keep_learning> http://pastebin.com/F0ChPmQr   I am trying to find out the length fo list input by user but getting Compiler error
07:40:32 <CakeProphet> but I would ditch the tuple
07:40:36 <CakeProphet> or use it exclusively
07:40:40 <keep_learning> kindly tell me 
07:40:44 <Saizan_> leino: that's valid but discouraged.
07:40:49 <keep_learning> askForWords return a list 
07:41:13 <Saizan_> leino: the Eq constraint should only be on the functions that use it
07:41:14 <keep_learning> but how can i use this list in other function 
07:41:15 <keep_learning> ?
07:41:27 <leino> ok so: data (Eq c) => Term c = Term c Monomial
07:41:55 <keep_learning> any one pleasr
07:41:59 <keep_learning> plesr
07:42:06 <keep_learning> please
07:42:08 <leino> Saizan_: I need coefficients to be testible for equivalence
07:42:40 <Saizan_> keep_learning: if you want to print the result of (fun lst) you've to use "print (fun lst)" in a do-block
07:42:42 <CakeProphet> leino:  what he means is that each function that requires equivalence would constrain the type
07:42:56 <leino> aha
07:42:56 <soupdragon> keep_learning: what you've written looks good
07:43:04 <soupdragon> keep_learning: just one mistake
07:43:07 <leino> but it seems like a good idea to me to constrain the type itself
07:43:12 <Saizan_> leino: that's fine, you'll just have functions with type :: Eq a => Polynomial a -> ...
07:43:12 <soupdragon> keep_learning: when you write  fun lst  it should be,   print (fun lst)
07:43:25 <CakeProphet> leino, PolynomialEqual :: (Eq a) => Polynomial a -> Polynomial a -> Bool
07:43:47 <CakeProphet> leino:  I don't think it matters much here.
07:44:09 <keep_learning> thank you soupdragon
07:44:12 <Saizan_> leino: it's a bad idea because it might get in the way for operations like [de]serialization that won't need it, and you don't gain any extra safety anyhow
07:45:02 <Saizan_> but it's not a huge deal..
07:45:11 <leino> ok I see what you mean
07:45:23 <leino> I'll opt for adding the constraint to functions that require them
07:45:59 <leino> time for lunch
07:46:05 <leino> thanks a lot guys!
07:46:11 <Saizan_> np :)
07:46:40 <CakeProphet> :t length
07:46:42 <lambdabot> forall a. [a] -> Int
07:46:44 <CakeProphet> keep_learning:  ^
07:47:19 <CakeProphet> keep_learning: but I suppose defining it yourself is good practice.
07:48:32 <keep_learning> CakeProphet : i did get you 
07:48:53 <keep_learning> actually i am trying to get some input from user
07:49:11 <keep_learning> and using in it some function which is not IO
07:49:54 <CakeProphet> keep_learning:  well there you go. You succeeded.
07:50:56 <CakeProphet> keep_learning:  askForWords = do {inp <- getContents; return (lines inp)}
07:51:13 <CakeProphet> or
07:51:18 <keep_learning> CakeProphet : tell me what do you mean . I am new to haskell and my programming experience is from C/c++
07:51:26 <CakeProphet> getContents >>= lines
07:51:33 <keep_learning> so i am trying to get some       input 
07:51:41 <keep_learning> and processing it
07:51:50 <keep_learning> just learning IO 
07:51:59 <CakeProphet> keep_learning: You mean the first thing I said? I was simply saying that a length function already exists.
07:52:39 <CakeProphet> keep_learning:  the second part is an example of how to shorten your askForWords function.
07:52:39 <keep_learning> CakeProphet : yes , Thank you
07:52:54 <keep_learning> :) thank you again 
07:53:06 <CakeProphet> keep_learning:  do you see how it works?
07:53:13 <keep_learning> considering my haskell knowledge 
07:53:21 <keep_learning> it seems bit tuff 
07:53:27 <keep_learning> but yes 
07:53:29 <CakeProphet> keep_learning:  do you know what getContents does?
07:53:43 <arcatan> why hackage.haskell.org just broke?
07:53:44 <keep_learning> it tooks a line 
07:53:50 <keep_learning>  i suppose
07:54:12 <keep_learning> of whole content until i press empty line
07:54:28 <djahandarie> arcatan, because we have incredibly unreliable servers hosting everything
07:54:31 <CakeProphet> keep_learning:  not quite. getContents returns an IO action. When the IO action is executed (by being evaluated within main) it returns ALL input as a string.
07:54:44 <CakeProphet> keep_learning:  all of it. Even if the input is infinite/indefinite.
07:55:19 <djahandarie> Although, I think hackage is on Galios servers which are better than the Yale ones
07:55:30 <keep_learning> CakeProphet : ok , i will try this 
07:55:43 <CakeProphet> keep_learning:  so if you do something like inp <- getContents
07:56:25 <CakeProphet> keep_learning:  you can refer to the entire inp as a string named inp.
07:56:30 <CakeProphet> *entire input
07:56:42 <keep_learning> CakeProphet : ok 
07:56:54 <CakeProphet> keep_learning:  and then (lines inp)  splits the input into a list of lines.
07:57:49 <keep_learning> so i don;t need recursion any more 
07:57:56 <keep_learning> don't 
07:58:03 <Saizan_> CakeProphet: though, askForWords stops when the user enters an empty line, while getContents will stop only on EOF 
07:58:12 <CakeProphet> keep_learning:  because of lazy evaluation, we can pass around unevaluated chunks of data. That's how getContents works. If you reach the end of the current input, it will wait indefinitely for new input to lazily fill into the string.
07:59:02 <CakeProphet> keep_learning:  not in this case no. Usually you can avoid recursion by using pre-defined functions. And also what Saizan_ said, getContents only stops at EOF.
08:00:37 <Saizan_> (also getContents does something sneakier than lazy evaluation, it's more akin to some form of concurrency)
08:00:37 <keep_learning> ok , i think i got it 
08:00:54 <CakeProphet> keep_learning:  Here's an example of how you can get the behavior you want with a shorter line of code. takeWhile (/= "") (lines inp)
08:01:07 <CakeProphet> keep_learning:  I'll probably need to explain that...
08:01:11 <Saizan_> (not that it matters much here, since length will force the whole input anyway)
08:03:48 <CakeProphet> keep_learning:  takeWhile is a function in the module Data.List. Its first argument is a function from list elements to a boolean, and its second argument is a list. It calls the test function on each element of the list, as long as the test function returns true. If at any point the test function returns false, the rest of the list is omitted.
08:05:12 <CakeProphet> > takeWhile (==0) [0,0,0,0,1,0,0,0,0]
08:05:12 <lambdabot>   [0,0,0,0]
08:05:58 <CakeProphet> > takeWhile (/="") ["this", "is", "a", "", "test"]
08:05:59 <lambdabot>   ["this","is","a"]
08:06:32 <CakeProphet> I guess I scared him off. :D
08:10:32 <winxordie> he learned well then :P
08:11:43 <soupdragon> this Kac guy sounds like quite an incredible mathematician
08:12:21 <soupdragon> Hearing the shape of a drum, ErdÅs-Kac theorem,  ..
08:13:04 <edwardk> is hackage down?
08:13:27 <soupdragon> yes
08:13:49 <winxordie> soupdragon: hearing the shape of a drum?
08:14:19 <winxordie> that's a little on the high side for me.
08:16:11 <edwardk> trying to figure out the best way to optimize the number of equivalance classes i need for luthor
08:16:36 <edwardk> so given an nfa i can ransack that nfa for all of the charsets used during its transitions
08:17:46 <edwardk> i can and do, break those charsets up into the sets of contiguous ranges in each, identifying the start of each run of present or missing characters by the first character in it, and store that as an IntSet. 
08:18:34 <edwardk> i then union together those intsets getting a set of all of the characters that start distinctly handled runs of characters
08:19:42 <edwardk> so if your grammar uses 'a' and 'c' and '[a-z]' -- you get 'a','b', 'c', and '[d-z]' as runs with exemplars 'a','b','c' and 'd' respectively (and a run starting at z + 1)
08:19:57 <soupdragon> edwardk is that differentiation ?
08:20:03 <edwardk> but since i'm doing this for unicode, i can wind up with a lot of contiguous ranges
08:20:04 <soupdragon> wait
08:20:12 <soupdragon> no I didn't even read it correctly
08:20:31 <edwardk> i.e. \p{Lowercase_Letter} contains a lot of character ranges in unicode
08:21:42 <edwardk> http://darcs.haskell.org/packages/base/cbits/WCsubst.c shows how many distinct ranges just by category there are
08:22:50 <edwardk> so it behooves me to fold together ranges that are treated the same by your grammar. i.e. if every time you match a japanese letter you also match thai letters because you just happened to use the generic class \p{Letter} in the grammar, then i should be able to put both in the same equivalence class
08:23:07 <edwardk> even though the ranges aren't contiguous
08:23:47 <edwardk> http://github.com/ekmett/luthor/blob/master/Text/Luthor/Classifier.hs is the sketch of what i'm thinking so far
08:24:01 <edwardk> so what i have right now is that i first organize everything into distinct runs
08:24:54 <edwardk> and then i go back through and check each of those runs to see the 'signature' of which charsets include or disinclude it entirely. if the number if signatures is smaller than the number of runs this is a win
08:24:59 <edwardk> but i think i can do a LOT better
08:25:13 <edwardk> \i'm just not sure quite the right way to encode it
08:25:45 <soupdragon> -1 = infinity ?
08:25:51 <soupdragon> how is that a prime number
08:25:58 <edwardk> soupdragon: ?
08:26:59 <edwardk> the idea being that the number of signatures explodes based on the number of runs, but nothing stops me from grabbing runs that are highly contentious and play a role in a lot of signatures, and just treating that as a separate equivalence class, gambling that i might be able to cut the overall number of signatures under consideration by some large fraction if i separated that run and all runs with the same signature into an equiva
08:27:54 <edwardk> but now i'm doing an awful lot of work at compile time to optimize this profile
08:28:44 <edwardk> anyone have any thoughts? i'm very open to other ideas, since this is likely to be fairly slow
08:31:36 <edwardk> my current goal is to encode the equivalence class lookup in an array of words, smashing the char and the equivalence class into the same word, so i'd have 2048 classes available and an at most 8k LUT
08:39:28 <leino> lets say I have "data MyData a = MyDataConstr a a", how would I make MyData an instance of Eq in such a way that == tests equivalence only of the first member x in MyData x y?
08:40:47 <soupdragon> instance Eq a => Eq (MyData a) where MyDataContsr m _ == MyDataContsr n _ = m == n
08:42:47 <leino> I get errors: Not in scope: data constructor `MyDataContsr'
08:43:08 <edwardk> you typo'd look at the s and r
08:43:19 <leino> aha
08:44:17 <CakeProphet> leino:  I'm still not sure if that's going to do what you expect it to do.
08:44:51 <CakeProphet> ah wait. no it might.
08:44:54 <leino> CakeProphet: how so?
08:45:06 <CakeProphet> leino:  I misread because the == threw me off.
08:45:54 <edwardk> trying to see if i can figure out what other folks are doing to compress these =)
08:48:25 <leino> my initial try was "instance Eq (Eq a) => (MyData a) where ..."
08:49:14 <leino> I quess I just dont know how the "TypeClass a =>" syntax works
08:50:42 <soupdragon> Leino, Eq (Eq a)  doesn't make sense because  Eq a  is not a type
08:51:25 <soupdragon> oh I guess you didn't mean it like  (Eq (Eq a))  so you can ignore what I just said
08:54:42 <monochrom> it is not going to be "TypeClass (TypeClassAgain a) => ..." in any case.
08:55:34 <leino> but "(Eq a) => (MyData a)" is a datatype right?
08:55:36 <monochrom> "instance Eq a => MyData a" would have sufficed. or "instance (Eq a) => MyData a" if you like more parenthesis.
08:55:43 <monochrom> No.
08:55:57 <monochrom> @src Eq
08:55:58 <lambdabot> class  Eq a  where
08:55:58 <lambdabot>     (==), (/=)   :: a -> a -> Bool
08:56:41 <monochrom> Oh? "MyData" is defined as a data type by you?
08:56:55 <leino> data MyData a = MyDataConstr a a
08:57:00 <monochrom> instance Eq a => Eq (MyData a)
08:58:20 <jmcarthur> think of it like this:   given the constraint Eq on a, i can define an instance for Eq (MyData a)
08:58:32 <monochrom> Yeah.
08:59:13 <monochrom> (isn't it like explained in practically all tutorials?)
09:00:42 * jmcarthur shrugs
09:00:59 <quicksilver> in some, certainly, but it's not verboten to ask questions here which are also explained in tutorials :)
09:01:22 <djahandarie> What is a monad?
09:01:48 <cncl> a monster
09:01:52 <handonson> a warm fuzzy thing.
09:01:56 <sm> someone should port gitit to hack or wai
09:02:08 <kaol> One that you can never escape.
09:02:12 <handonson> in other words, yes, a monster.
09:02:14 <hearit> xmondad its a x system manager
09:02:23 <hearit> that run with haskell
09:02:47 <handonson> (>>=) :: (Monster m) => m a -> (a -> m b) -> m b
09:02:48 <hearit> x windows manager*
09:04:19 <handonson> See? a monster wannabe (a -> m b) kills another monster (m a) and opens its carcass to take the heard (a), devouring it and becoming a new monster (m b).
09:04:27 <handonson> heard -> heart
09:04:54 * hackagebot CSPM-Frontend 0.4.0.0 - A CSP-M parser compatible with FDR-2.83  http://hackage.haskell.org/package/CSPM-Frontend-0.4.0.0 (MarcFontaine)
09:05:10 <handonson> How monstrous. Stay away from them.
09:05:41 <Jafet> An outlaw monad appears! It wields a disfigured (>>=)! Roll for initiative.
09:06:55 * hackagebot CSPM-Interpreter 0.4.0.2 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.4.0.2 (MarcFontaine)
09:09:55 * hackagebot CSPM-cspm 0.3.0.0 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.3.0.0 (MarcFontaine)
09:11:00 <leino> jmacarthur: thanks, that helped me understand it a little better
09:11:11 <leino> I think I've been reading some crappy tutorials :)
09:17:35 <Sp4rKy> hi
09:17:46 <Sp4rKy> is there some benchmark haskel code ? 
09:19:00 <Sp4rKy> just foudn nofib
09:23:35 <leino> @src Ord
09:23:35 <lambdabot> class  (Eq a) => Ord a  where
09:23:36 <lambdabot>     compare      :: a -> a -> Ordering
09:23:36 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:23:36 <lambdabot>     max, min         :: a -> a -> a
09:23:46 <yrlnry> @src Ordering
09:23:46 <lambdabot> data Ordering = LT | EQ | GT
09:23:50 <yrlnry> Oh, right.
09:25:19 <flabron> hi there. How do i compare x==y in a list like [(4,3),(2,2),(5,4)] ?
09:26:06 <Saizan_> can you rephrase?
09:26:32 <djahandarie> > (4,3) == (2,2)
09:26:33 <lambdabot>   False
09:26:56 <quicksilver> > filter (\(x,y) -> x == y) [(4,3),(2,2),(5,4)]
09:26:57 <lambdabot>   [(2,2)]
09:27:13 <flabron> exactly that quicksilver 
09:27:17 <djahandarie> Nice lol
09:27:18 <cizra> > filter (=) [(4,3),(2,2),(5,4)]
09:27:20 <lambdabot>   <no location info>: parse error on input `='
09:27:20 <flabron> thank you
09:28:22 <arbitrarylogic> map (==) [(4,3), (2,2), (5,4)]
09:28:30 <arbitrarylogic> > map (==) [(4,3), (2,2), (5,4)]
09:28:31 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, t1) -> GHC.Bool.Bool)
09:28:31 <lambdabot>    arisi...
09:28:33 <quicksilver> > concatMap (\(x,y) -> "In the tuple " ++ show (x,y) ++ " the two components are " ++ (if x==y then "the same" else "distinct") ++ ".  ") [(4,3),(2,2),(5,4)]
09:28:34 <lambdabot>   "In the tuple (4,3) the two components are distinct.  In the tuple (2,2) th...
09:28:46 <quicksilver> arbitrarylogic and cizra are both missing an uncurry
09:28:57 <arbitrarylogic> oopsie
09:28:57 <quicksilver> > map (uncurry (==)) [(4,3),(2,2),(5,4)]
09:28:59 <lambdabot>   [False,True,False]
09:29:07 <quicksilver> but I decided lambda notation was clearer than uncurry.
09:29:10 <quicksilver> which is why I didn't use it.
09:29:12 <arbitrarylogic> > map (\(x,y) -> x == y) [(4,3), (2,2), (5,4)]
09:29:13 <lambdabot>   [False,True,False]
09:29:53 <cizra> I agree about clearness
09:30:02 <arbitrarylogic> yeah, good call
09:30:02 <quicksilver> > text $ concatMap (\(x,y) -> "In the tuple " ++ show (x,y) ++ " the two components are " ++ (if x==y then "the same" else "distinct") ++ "\n") [(4,3),(2,2),(5,4)]
09:30:04 <lambdabot>   In the tuple (4,3) the two components are distinct
09:30:04 <lambdabot>  In the tuple (2,2) the ...
09:30:18 * quicksilver shrugs
09:30:22 <quicksilver> that works in PM ;)
09:30:26 <quicksilver> PM has longer message limits.
09:33:07 <leino> > let lst = [(4,3), (2,2), (5,4)] in [(x,y) | (x,y) <- lst, x==y]
09:33:08 <lambdabot>   [(2,2)]
09:35:14 <quicksilver> > [(4,3),(2,2),(5,4)] >>= ap ((>>) . guard . uncurry (==)) return
09:35:15 <lambdabot>   [(2,2)]
09:35:40 <djahandarie> Heh
09:36:14 * cizra is trying to tinker up a tile-based turn-based strategy game in Haskell + SDL. It most probably will be abandoned like most of my projects, but it's fun while it lasts.
09:36:19 <McManiaC> > filter (liftM2 (==) fst snd) [(2,2),(3,4)]
09:36:20 <lambdabot>   [(2,2)]
09:36:23 <McManiaC> :D
09:36:41 <leino> > [(2,2)]
09:36:43 <lambdabot>   [(2,2)]
09:36:46 <leino> win!
09:36:49 <McManiaC> ok you win :(
09:36:51 <arbitrarylogic> best yet
09:49:56 <flabron> following that thougth how do i print n times a char like [('a',2),('b',4)] should do "aabbbb"
09:51:30 <McManiaC> > concatMap (\(c,i) -> replicate i c) [('a',2),('b',4)]
09:51:31 <lambdabot>   "aabbbb"
09:52:53 <flabron> McManiaC, Thank you, i was trying something with map, but i was dont getting the result
09:53:12 <McManiaC> although there might be a function for it, aswell
09:53:14 <McManiaC> not sure
09:54:19 <flabron> the replicate work properly for the purpose :)
10:02:01 <sm> dangit.. I thought I'd fixed my libiconv woes with a newly built ghc on mac.. but now haskell programs give " hGetContents: invalid argument (Illegal byte sequence)" on non-ascii input
10:09:09 <Saizan_> well that just means it's using an encoding that doesn't match the one of the input
10:09:42 <Saizan_> so either specify the one to use explictly or change your locale or change your input :)
10:09:55 <Veinor> > do { (x, c) <- [('a', 2), ('b', 4)]; return $ replicate c x}
10:09:56 <lambdabot>   ["aa","bbbb"]
10:10:17 <aristid> :t liftM2 (==) fst snd
10:10:18 <lambdabot> forall b. (Eq b) => (b, b) -> Bool
10:10:47 <Veinor> > do { (x, c) <- [('a', 2), ('b', 4)]; replicate c x}
10:10:48 <lambdabot>   "aabbbb"
10:10:53 <Veinor> monads!
10:12:34 <djahandarie> > [('a', 2), ('b', 4)] >>= replicate c x
10:12:36 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:12:36 <lambdabot>         against inferred type ...
10:13:02 <djahandarie> Oh lol
10:14:42 <aristid> @pl \(x, c) -> replicate c x
10:14:42 <lambdabot> uncurry (flip replicate)
10:15:01 <Veinor> > [(2,2), (3,3)] >>= uncurry (flip replicate)
10:15:03 <lambdabot>   [2,2,3,3,3]
10:15:04 <djahandarie> Sigh
10:15:06 <djahandarie> Just beat me to it
10:15:07 <Veinor> > [(2,2), (3,3)] >>= uncurry $ flip replicate
10:15:08 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
10:15:17 <djahandarie> Except I didn't cheat with pl
10:15:21 <aristid> :t uncurry (==)
10:15:22 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
10:15:23 <Veinor> :P
10:15:26 <aristid> woo
10:20:13 <flabron> you people are crazy :P
10:20:26 <McManiaC> > [(2,2), (3,3)] >>= uncurry . flip replicate
10:20:27 <lambdabot>   Couldn't match expected type `[b]'
10:20:28 <lambdabot>         against inferred type `(a, b1) -...
10:20:44 <McManiaC> nooope
10:21:22 * hackagebot monad-loops 0.3.1.0 - Monadic loops  http://hackage.haskell.org/package/monad-loops-0.3.1.0 (JamesCook)
10:22:06 <burp> loops :O
10:23:40 <augur> lmfao
10:24:03 <augur> Nuel Belnap, a rather well known logician, has a paper on what he calls Display Logic
10:24:18 <augur> at one point, he defines some things, and then says that so and so are all "display equivalent"
10:24:25 <augur> he has below this the following:
10:24:31 <augur> "Proof. By diddling."
10:27:03 <orlandu63> is there core function that is \x f -> x >>= (return . f) ?
10:27:30 <McManiaC> fmap
10:27:48 <McManiaC> (here flip fmap)
10:27:58 <elliottt> does anyone know if it's possible to convince the new GHC build system to just build the RTS, without causing it to try to build everything else?
10:28:11 <elliottt> make all_rts doesn't seem to work as advertised
10:28:17 <orlandu63> ah thank you
10:28:45 <mauke> :t \x f -> x >>= (return . f)
10:28:46 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> a1) -> m a1
10:28:52 <mauke> @hoogle (Monad m) => m a -> (a -> a1) -> m a1
10:28:52 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
10:28:53 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
10:28:53 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
10:30:15 <McManiaC> \x f -> f `fmap` x
10:30:16 <McManiaC> ^^
10:31:02 <aristid> McManiaC: flip fmap!
10:31:13 <McManiaC> <McManiaC> (here flip fmap)
10:31:56 <aristid> McManiaC: i did not scan so far up
10:32:02 <McManiaC> :)
10:34:48 <asdfwef> hm
10:35:54 <dons> elliottt: cd rts ; make
10:35:55 <dons>  ?
10:40:12 <elliottt> dons: that makes all of ghc :)
10:40:27 <elliottt> their new goal was to have it build everything from anywhere, and they've certainly done it
10:42:05 <EvanCarroll> how come this doesn't work `map (\x -> do _ <- x) $ map print [1..10]`
10:42:33 <handonson> "map print" looks suspicious
10:42:35 <EvanCarroll> I know the lambda isn't valid, but I'm not sure why
10:42:45 <EvanCarroll> I know this is supposed to be done with `sequence` too
10:42:51 <handonson> wait, never mind
10:42:53 <EvanCarroll> I'm just wondering why my lambda doesn't work
10:43:22 <handonson> EvanCarroll: the last item of "do" has to be an expression
10:43:29 <McManiaC> mapM_ print [1..10]
10:43:35 <McManiaC> but print doesnt return anything
10:43:52 <McManiaC> hm
10:43:53 <McManiaC> well
10:43:53 <McManiaC> ^^
10:43:59 <mauke> EvanCarroll: _ <- looks like a no-op
10:44:08 <mauke> what's that supposed to do?
10:44:18 <McManiaC> _ <- print "moep"
10:44:20 <EvanCarroll> mauke: the same thing sequence does but with map
10:44:23 <McManiaC> inside a do-block
10:44:28 <chrisdone> avoiding the -Wall warning presumably
10:44:30 <McManiaC> you want mapM_ tho
10:44:44 <mauke> EvanCarroll: huh?
10:44:44 <EvanCarroll> McManiaC: no --  I want to know why my lambda doesn't work
10:44:58 <mauke> sequence isn't a map
10:44:58 <handonson> EvanCarroll: what does the compiler say?
10:45:10 <EvanCarroll>     The last statement in a 'do' construct must be an expression
10:45:19 <chrisdone> EvanCarroll: last statement in a "do" must be an expression
10:45:20 <handonson> EvanCarroll: which is exactly what i just said
10:45:21 <chrisdone> yeah
10:45:24 <McManiaC> > (\x -> do _ <- x) (return 5)
10:45:25 <lambdabot>   <no location info>:
10:45:25 <lambdabot>      The last statement in a 'do' construct must be an ...
10:45:29 <McManiaC> > (\x -> do x) (return 5)
10:45:29 * hackagebot ghc-gc-tune 0.2.1 - Graph performance of Haskell programs with different GC flags  http://hackage.haskell.org/package/ghc-gc-tune-0.2.1 (DonaldStewart)
10:45:30 <lambdabot>   No instance for (GHC.Show.Show (m t))
10:45:30 <lambdabot>    arising from a use of `M2470629532...
10:45:37 <handonson> EvanCarroll: "_ <- x" is not an expression.
10:45:42 <McManiaC> > (\x -> do x) (return 5 :: Maybe 5)
10:45:43 <lambdabot>   Only unit numeric type pattern is valid
10:45:44 <EvanCarroll> WHY!?!?!?!?!
10:45:47 <EvanCarroll> jesus christ.
10:45:51 <EvanCarroll> nevermind, I'll take it to SO.
10:46:02 <McManiaC> EvanCarroll: read the error message
10:46:06 <EvanCarroll> thanks, twat.
10:46:07 <mauke> EvanCarroll: because most things are syntax errors
10:46:17 <mauke> EvanCarroll: random text isn't valid haskell code by default
10:46:32 <mauke> EvanCarroll: SO WHAT DID YOU MEAN WHEN YOU WROTE _ <- x
10:46:48 <McManiaC> "a <- f" is the same as "f >>= \b ->"
10:46:48 <chrisdone> sure is loud in here
10:46:55 <McManiaC> you cannot end with that
10:47:01 <McManiaC> *\a ->
10:47:43 <EvanCarroll> mauke: Execute X and throw away the result, just like `_ <- print "foo"` does, just like `perl -e'map {print $_} [1..10]'` would do.
10:47:53 <EvanCarroll> But, i don't suppose your end-game is to help, it normally isn't.
10:47:53 <mauke> EvanCarroll: <- doesn't execute stuff
10:48:08 <handonson> yes they do
10:48:33 <McManiaC> not inside a "map" ;)
10:48:36 <McManiaC> well ok
10:48:38 <mauke> handonson: no
10:48:43 <mauke> EvanCarroll: do you know javascript?
10:48:44 <handonson> in a do construct, "_ <- print something" does print something
10:48:50 <mauke> handonson: no, it doesn't
10:49:36 <handonson> mauke:
10:49:36 <handonson> Prelude> let main = do { x <- print "asdf"; return () }
10:49:37 <handonson> Prelude> main
10:49:37 <handonson> "asdf"
10:49:49 <mauke> Prelude> let main = do { x <- print "asdf"; return () }
10:49:52 <McManiaC> EvanCarroll: map (\x -> do _ <- x; return ())
10:49:54 <mauke> nothing was printed
10:50:00 <Saizan_> EvanCarroll: then just drop the "_ <-" and use "print "foo""? the problem is that with a do block like "do x <- foo" it's not clear what the returned value should be.
10:50:08 <handonson> mauke: did you call main after that?
10:50:18 <mauke> handonson: no, you said using <- in a do block is enough
10:50:37 <handonson> no, i never said that.
10:50:55 <mauke> <handonson> in a do construct, "_ <- print something" does print something
10:50:59 <McManiaC> if you want to execute that do block you'll have to use "sequence . map" or just "mapM_"
10:51:04 <EvanCarroll> handonson: he knows what he is talking about, and what I'm asking, it is his deeply rooted desire to not give assistance, but just to frustrate that ultimately gets him off.
10:51:27 <chrisdone> alright, calm down
10:51:32 <mauke> EvanCarroll: what the heck is wrong with you?
10:51:43 <EvanCarroll> mauke: You know where the confusion is, and you're playing games.
10:51:51 <chrisdone> EvanCarroll: are you still unsure about the reasoning?
10:52:14 <McManiaC> EvanCarroll: fact is, a "[IO a]" does *nothing* until you run a "sequence" on it
10:52:16 <mauke> EvanCarroll: no, I really didn't know what you meant when you wrote "do _ <- x"
10:52:43 <McManiaC> [IO a] is what you create with a "do print..."
10:53:02 <Saizan_> McManiaC: ?
10:53:16 <mauke> EvanCarroll: also, I tried to help you but you don't seem to want to answer my questions
10:53:16 <McManiaC> *map (do print...)
10:53:26 <handonson> mauke: of course i meant that function with do construct has to be called afterwards! not only "_ <- x", but absolutely NOTHING will be executed anywhere universally if you don't CALL anything.
10:53:34 <Saizan_> McManiaC: still a type error :)
10:53:39 <mauke> handonson: your 'main' isn't a function
10:53:40 <McManiaC> Saizan_: :P
10:53:50 <mauke> handonson: nothing is called; there are no functions involved
10:53:54 <orlandu63> do { x <- e } is invalid, there is no translation rule for it
10:53:55 <McManiaC> Saizan_: pseudo-haskell ;)
10:53:57 <mauke> that's like the whole point
10:54:08 <handonson> mauke: main is a function.
10:54:19 <Saizan_> main is not a function in haskell
10:54:23 <mauke> handonson: no
10:54:34 <handonson> i mean main in Prelude> let main = do { x <- print "asdf"; return () }
10:54:36 <mauke> if it was, you could call it
10:54:36 <McManiaC> of course is main a function
10:54:36 * hackagebot hmatrix-gsl-stats 0.1.2.1 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.1 (VivianMcPhail)
10:54:36 <McManiaC> lol
10:54:37 <Saizan_> it's a value of type IO A for some A, 
10:54:48 <djahandarie> A value is not a function.
10:54:49 <mauke> McManiaC: ?
10:55:06 <handonson> EVERYTHING in Haskell is function
10:55:10 <handonson> even a value is a function
10:55:10 <Saizan_> a function is a value of type A -> B for some A and B, possibly with an additional typeclass context
10:55:19 <aristid> handonson: no it's not
10:55:20 <handonson> a value is a function that does not take any argument
10:55:22 <mauke> handonson: no
10:55:23 <aristid> a value is a value
10:55:32 <aristid> and a function always takes ONE argument
10:55:36 <Saizan_> functions are values, not all values are functions
10:55:42 <mauke> handonson: I mean, you could define things that way, but then why call things "function" at all?
10:55:52 <Saizan_> but well, it's a matter of definitions
10:55:52 <McManiaC> so whats the point? lol who cares whether main is a function or netâ¦
10:55:54 <McManiaC> *not
10:56:04 <mauke> handonson: what's the difference between "value" and "function" then?
10:56:10 <McManiaC> you can pass it around and do everything you're used from a "IO a" type
10:56:10 <aristid> main is an IO action value \o/
10:56:12 <chrisdone> EvanCarroll: http://www.haskell.org/onlinereport/exps.html scroll down to 3.14. it's been defined like that in the original grammar. it's obvious from what it maps to underneath. how do you write this in do-notation? f >>= \x -> a >> b
10:56:17 <mauke> McManiaC: you can't call it
10:56:33 <McManiaC> mauke: main = putStrLn "main" >> main
10:56:43 <mauke> yes?
10:56:52 <McManiaC> I just "called" it
10:56:53 <McManiaC> :>
10:56:55 <mauke> no, you didn't
10:57:02 <mauke> xs = 1 : xs doesn't make xs a function either
10:57:26 <McManiaC> "called"
10:57:36 <c_wraith> Is there a quick way to turn of lambdabot plugins?
10:57:41 <c_wraith> *off
10:57:43 <EvanCarroll> chrisdone: I can't read that to know how to write that.
10:57:48 <handonson> gee. i'll have to blame the guy who taught me Haskell at the first place
10:57:55 <handonson> mauke: you said "<-" doesn't execute stuff.
10:57:57 <djahandarie> c_wraith, manually prefix everything with Prelude? :P
10:58:00 <mauke> handonson: right
10:58:04 <EvanCarroll> chrisdone: and about 95% of that text is above my pay grade.
10:58:05 <handonson> mauke: what executes stuff, then?
10:58:11 <mauke> handonson: the runtime system
10:58:19 <handonson> ...
10:58:24 <handonson> oh yeah.
10:58:31 <mauke> i.e. something outside of haskell-the-language
10:58:46 <c_wraith> djahandarie, plugins.
10:58:53 <djahandarie> Oh
10:58:57 <djahandarie> Like actually lambdabot plugins
10:58:59 <Saizan_> c_wraith: you've to remove them from the list of plugins in a module whose name i forgot and rebuild, i think
10:59:01 * djahandarie doesn't touch labmdabot
10:59:25 <McManiaC> mauke: with that definition you can even "execute" a pure list of Ints... like, saving it to memory, recalling it etc
10:59:26 <chrisdone> EvanCarroll: i thought you already knew do-notation. do you know about lambda expressions?
10:59:28 <McManiaC> :D
10:59:36 <djahandarie> It uses hs-plugins I think, so you should be able to remove them run-time, I think
10:59:38 <EvanCarroll> chrisdone: yes
10:59:53 <handonson> aristid: a function always takes ONE argument? sounds pretty far from the ordinary term 'function' people use in the world of Haskell, since that means, for example, "take" is NOT a function
11:00:05 <mauke> handonson: how is take not a function?
11:00:12 <chrisdone> EvanCarroll: and do you know about the bind method (>>=) and its meaning?
11:00:14 <aristid> handonson: sure, take only takes one argument, and returns another function
11:00:30 <EvanCarroll> chrisdone: not yet, just working through lyah
11:00:37 <handonson> oh well...
11:00:47 <sproingie> take is a function that takes a number and returns a function over a list that takes that many items
11:00:55 <mauke> handonson: do you understand flip id?
11:01:01 <Saizan_> handonson: "do x <- foo; bar x" is an action that when executed will execute foo, get its result x, and then execute (bar x), the "... <- ...; ..." is just constructing the action
11:01:05 <McManiaC> mauke: btw, you could define "function" as something that returns a value. in that case something of kind "m a" would be a function :)
11:01:23 <aristid> :t uncurry take
11:01:24 <lambdabot> forall a. (Int, [a]) -> [a]
11:01:27 <djahandarie> Oh god, here comes "return" to come and confuse things again
11:01:32 <handonson> Saizan_: i never rejected that. in fact, what i've explained was that.
11:01:52 <EvanCarroll> is return a function or a value?
11:01:58 <handonson> Saizan_: it was mauke's view that <- won't execute anything
11:01:58 <mauke> EvanCarroll: both
11:02:07 <aristid> :t return
11:02:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:02:10 <sproingie> take maps a number to a function that maps a list to a list of that many items taken
11:02:12 <Saizan_> handonson: i'm saying that <- doesn't execute anything too
11:02:13 <sproingie> better?
11:02:14 <mauke> handonson: uh, isn't that what Saizan_ just said?
11:02:16 <aristid> EvanCarroll: there is a ->, so it is a function
11:02:32 <McManiaC> EvanCarroll: use function types, not words, to describe things in haskell
11:02:36 <mauke> EvanCarroll: all functions are values, and return is a function
11:02:37 <djahandarie> > do { a <- ["hi"]; }
11:02:38 <lambdabot>   <no location info>:
11:02:38 <lambdabot>      The last statement in a 'do' construct must be an ...
11:02:40 * hackagebot hstatistics 0.2.0.6 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.0.6 (VivianMcPhail)
11:02:48 <sproingie> personally as long as you understand that functions really only take one arg, you really are allowed to think of "take" as taking two args
11:02:56 <sproingie> thinking in higher levels and all
11:03:02 <handonson> Saizan_: you said "do x<- foo; bar x" is an action that ... WILL EXECUTE foo ...
11:03:11 <djahandarie> <- doesn't even mean anything by itself
11:03:29 <djahandarie> It's only syntax that maps to the non-do version of things
11:03:31 <mauke> handonson: when executed, yes. that doesn't mean x <- foo will do stuff
11:03:31 <handonson> while mauke said <- won't execute at all.
11:03:40 <chrisdone> EvanCarroll: i'm not sure that LYAH yet explains the (>>=) method. regardless, consider the following, what do you think it means? do (a,b) <- x
11:03:49 <Saizan_> handonson: "when executed"
11:03:59 <djahandarie> And the non-do version of things makes it a lot clearer what is actually happening imo
11:03:59 <handonson> yes, when executed, it WILL execute!
11:04:03 <Saizan_> handonson: that's crucial, meaning that execution comes from outside.
11:04:14 <Saizan_> handonson: <- just composes two actions together
11:04:19 <Trevion> Does anyone know if -dynamic should "just work" with GHC 6.12.3. on Windows
11:04:28 <Saizan_> handonson: can you see there are two levels here? conflating them is not helpful
11:04:42 <mauke> handonson: when execution happens, there is no <- anymore
11:05:13 <noob8> hi 
11:05:17 <noob8> I have a question
11:05:34 <noob8> suppose I have an XML schema (or DTD for that matter)
11:05:35 <handonson> that's not the way people use the word "execute". if you apply that view to the word "execute", nothing in a source code "executes" at all even in imperative languages.
11:05:54 <EvanCarroll> chrisdone: that x returns two io types, that will be assigned to a,b. or, the program will die.
11:06:13 <noob8> what is the best way of structuring my program to read the schema first and its instance next and validate the instance against the schema
11:06:14 <mauke> handonson: do you think getChar is a function?
11:06:31 <handonson> mauke: how's that relevant to what i've just said
11:06:32 <noob8> I understand this is more of a decomposition strategy question than detail implementation
11:06:50 <mauke> handonson: I have the feeling you're missing something fundamental, but I'm not quite sure what
11:07:19 <Saizan_> handonson: but in haskell we've first class actions and purity, so conflating the two levels like when you think about imperative code is harmful, because it obscures the expressiveness that's available
11:07:35 <djahandarie> handonson, execution has a pretty specific meaning in Haskell (versus evaluation).
11:07:45 <slom> hello, is there a accepted name for  (flip (>>=) sequence)? join looks similar ... but not quite the same
11:08:00 <mauke> :t (=<<) sequence
11:08:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [m a] -> m [a]
11:08:18 <chrisdone> EvanCarroll: good guess. it actually doesn't make sense due to the way Haskell works. but you'll learn that soon with LYAH, i expect, so i'll not try to confuse matters by introducing concepts that are like in the next chapter :D
11:08:20 <handonson> Saizan_: you say the execution comes from outside, therefore the do construct doesn't execute anything. then even machine codes don't execute anything at all, because they GET executed by something else, like an ISA.
11:08:38 <Saizan_> handonson: right, so?
11:08:50 <aristid> @. pl unpl (=<<) sequence
11:08:50 <lambdabot> (sequence =<<)
11:08:54 <handonson> Saizan_: but that's not the ordinary usage of the word "execute"
11:08:57 <chrisdone> handonson: are you aware of function pointers?
11:09:02 <aristid> heh.
11:09:14 <EvanCarroll> fair enough
11:09:28 <chrisdone> handonson: in say, other languages like C or C++?
11:09:39 <mauke> > length [getChar, do getChar]
11:09:40 <lambdabot>   2
11:10:04 <Saizan_> handonson: ok, i agree that we're using a more refined sense of the word execute, but it's not gratuitous, it's actually the one that fits better with what you can and have to do in haskell.
11:10:16 <slom> @mauke: thanks, didnt know about =<< :)
11:10:16 <lambdabot> Unknown command, try @list
11:10:24 <handonson> Saizan_: ergo, IMO, it will increase newcomers' confusion if you force that view on the word "execution." just saying "yes, x <- print something prints something." will be far easier to understand.
11:10:46 <Saizan_> handonson: but that gives a false intuition.
11:10:52 <chrisdone> :t (>=>)
11:10:53 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:11:00 <mauke> handonson: except it leads to people writing map (\x -> do _ <- x) actions and wondering why it doesn't work
11:11:07 <djahandarie> :t ($$)
11:11:09 <lambdabot> Doc -> Doc -> Doc
11:11:41 <handonson> Saizan_: then woudn't saying "this machine code executes something" also give a false intuition
11:12:36 <mauke> handonson: no, because you can write movl $1, %eax; int $128 and it does something
11:12:46 <Saizan_> handonson: i'm not that familiar with programming assembly, but in e.g. python evaluation and execution (as we intend it) are conflated, so the distinction is less relevant.
11:13:03 <djahandarie> :t Data.FunArr.($$)
11:13:05 <lambdabot> Couldn't find qualified module.
11:13:10 <djahandarie> Stupid lambdabot 
11:13:16 <handonson> mauke: that hazard is realistic, but in that case you should have said "the do construct doesn't execute anything, it just gives you a chain of monadic functions" instead of "<- doesn't execute stuff"
11:13:30 <mauke> handonson: what the heck are monadic functions?
11:13:44 <handonson> monadic values, if you want
11:13:51 <mauke> how about no
11:14:04 <mauke> why introduce monads if all we're trying to do is understand IO
11:14:11 <EvanCarroll> btw, I bought the thompson book
11:14:27 <handonson> mauke: that hazard is realistic, but in that case you should have said "the do construct doesn't execute anything" instead of "<- doesn't execute stuff"
11:14:31 <handonson> sounds better?
11:14:47 <handonson> since that was actually my point
11:14:52 <mauke> I don't agree
11:14:52 <djahandarie> Nothing Haskell-the-language executes anything
11:14:59 <djahandarie> Nothing in*
11:15:10 <djahandarie> (Including <- of course)
11:15:26 <handonson> mauke: movl $1, %eax; int $12 does something? then main = putStrLn "Hello" does something as well. they're both, just codes.
11:15:41 <mauke> handonson: there's a difference
11:16:10 <mauke> in the haskell version you have two layers
11:16:25 <handonson> a code does something. this is the common intuition. although it's not true (codes don't do anything by themselves, they just get executed by ISAs) it is a very useful intuition.
11:16:28 <mauke> the inner layer is haskell proper, which is pure and just builds some values
11:16:45 * hackagebot hstatistics 0.2.0.7 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.0.7 (VivianMcPhail)
11:16:51 <aristid> handonson: you can compare this with the C preprocessor. in haskell, most of the programming is done at the "C preprocessor" level :)
11:16:55 <mauke> the outer layer is the runtime system, which takes the value (action) bound to main and actually executes it
11:16:57 <pchiusano> hello
11:17:05 <chrisdone> hi there
11:17:13 <mauke> there's no intermediate value in asm
11:17:49 <mauke> and this isn't just a theoretical argument because the difference is visible when you write haskell
11:17:52 <handonson> aristid: yes, i got that feeling as well. i also got the feeling that's probably why when a haskell code compiles, it runs.
11:17:52 <Saizan_> handonson: the problem is what in haskell you've to pay attention to the fact that what "putStrLn "Hello"" does is to build an action, i.e. a recipe, not actually perform the side-effect
11:18:28 <Saizan_> handonson: in an imperative language instead that's not true
11:18:59 <pchiusano> I am reading Bejamin Pierce's 'Types and Programming Languages', he doesn't seem to cover HM, or am I missing it somewhere?
11:19:00 <handonson> Saizan_: movl $1, %eax; int $12 builds an action as well. it doesn't do anything by itself. it's just a description about what would happen if this really gets executed by some outer system.
11:19:12 <Saizan_> handonson: no, that's not true
11:19:32 <pchiusano> http://www.amazon.com/Types-Programming-Languages-Benjamin-Pierce/dp/0262162091/ref=sr_1_1?ie=UTF8&s=books&qid=1278440326&sr=8-1
11:19:44 <djahandarie> > print "hi"
11:19:45 <lambdabot>   <IO ()>
11:19:52 <djahandarie> That code was evaluated by lambdabot, but not executed
11:19:55 <chrisdone> handonson: what's the difference between  \x -> 10*20  and  10*20?
11:20:13 <Saizan_> handonson: you can't reference "movl $1, %eax; int $12" as an action directly from within assembly, you'd have to ask for the pointer to that instruction or use some other indirection.
11:20:19 <pchiusano> he talks about system F, but from what I understand, there is some restriction to system F that makes type inference tractable
11:20:22 <handonson> chrisdone: err... the former takes an argument?
11:20:32 <pchiusano> i was hoping to read more about that...
11:20:51 <chrisdone> handonson: what are the results of running either of them?
11:21:41 <Saizan_> handonson: the main point is that you can talk about "imperative code" from within haskell, while in other imperative languages you've to go to the meta-level to talk about it.
11:21:45 <handonson> chrisdone: 200s? i get extremely nervous when i get a math question
11:22:20 <chrisdone> handonson: okay, what do you get when you run this exact expression? "foo" ++ "bar"
11:23:06 <handonson> mauke: if you're worried about false intuitions, i think you should have said "do construct don't execute anything" instead of "<- don't execute anything." that's all
11:23:22 <Saizan_> handonson: this, incidentally, is why it's so easy to define your own control structures from within haskell
11:23:57 <Saizan_> "movl $1, %eax; int $12" is not a first-class object in assembly
11:24:11 <mauke> handonson: same thing
11:24:18 <mauke> <- is a part of do
11:24:23 <pchiusano> another question I had, totally unrelated, is could we consider instances of (class Pure f where pure :: a -> f a) to be a functor between two categories? And if so what would those categories be?
11:24:34 <handonson> mauke: newcomers get it wrong
11:24:55 <handonson> chrisdone: that question is too difficult for me. even with all my might, i can never reach the answer "foobar". please kindly lower your expectation.
11:25:18 <mauke> handonson: I'm not sure you get it right
11:25:38 <chrisdone> handonson: good job. now what do you get when you run this exact expression? \x -> x ++ "bar"
11:25:40 <handonson> mauke: i'm relatively a newcomer
11:27:18 <handonson> chrisdone: by run, what do you mean? if you mean typing that code in ghci, i'd bet it'll complain that there's no instance of the Show class for (String -> String)
11:28:23 <chrisdone> handonson: well, ghc tries to show the result of everything. so, what result do you get?
11:28:46 <djahandarie> ghci*
11:29:03 <handonson> chrisdone: i'd complain to you
11:29:06 <chrisdone> woops, yeah, i meant ghci
11:30:14 <chrisdone> handonson: does (++) get run?
11:30:27 <handonson> huh?
11:30:59 <chrisdone> handonson: the (++) function in the following expression, if it put it in GCHi: \x -> x ++ "bar"
11:31:10 <djahandarie> ghci*
11:31:16 <chrisdone> hahaha
11:31:34 <chrisdone> i just can't spell that word
11:31:45 <djahandarie> :P
11:32:19 <handonson> uhm.. no..
11:32:25 <chrisdone> handonson: why not?
11:32:40 <handonson> because GHCi doesn't have to evaluate it?
11:32:57 <chrisdone> why?
11:33:08 <handonson> since you didn't demand any value out of that function
11:33:17 <chrisdone> how do you do that?
11:33:44 <shapr> Is there an Ubuntu Haskell Team?
11:33:58 <djahandarie> Don't think so, shapr
11:34:00 <chrisdone> i use haskell on ubuntu. but i don't want to help *you*
11:34:01 <handonson> give some argument and ask for the result?
11:34:35 <djahandarie> shapr, I believe Ubuntu gets their haskell-related packages mostly from Debian
11:34:43 <chrisdone> handonson: for example?
11:35:38 <handonson> (\x -> x ++ "bar") "gay "
11:37:30 <jesusabdullah> > (\x -> "start a" ++ x ++ "war!") NUCLEAR
11:37:31 <lambdabot>   Not in scope: data constructor `NUCLEAR'
11:37:37 <jesusabdullah> > (\x -> "start a" ++ x ++ "war!") "NUCLEAR"
11:37:38 <lambdabot>   "start aNUCLEARwar!"
11:37:39 <chrisdone> handonson: so you're saying i need to put (\x -> x ++ "bar") in a special place construct or x ++ "bar" will never get run? sounds pretty weird
11:37:42 <jesusabdullah> curses!
11:37:44 * jesusabdullah fail
11:38:16 <chrisdone> jesusabdullah: what's that saying, better to be quiet and let people think you're stupid than open your mouth and remove all doubt :-P
11:38:30 <jesusabdullah> Hah!
11:38:30 <shapr> djahandarie: Perhaps I should start an Ubuntu Haskell Team.
11:38:43 <jesusabdullah> I figure it's better to let people know exactly how clever I am from the start
11:38:51 <djahandarie> shapr, that'd be good, since a lot of people use Ubuntu!
11:38:54 <jesusabdullah> That way nobody has unrealistic expectations
11:38:55 <djahandarie> I don't use Ubuntu though
11:39:24 <jesusabdullah> That, and I'd rather fail than be scared of said failure
11:39:28 <shapr> I do use Ubuntu. I get easier setup, but less control compared to debian.
11:39:30 <jesusabdullah> ...for small levels of fail :)
11:39:39 <jesusabdullah> I use xubuntu some places, fedora in others
11:39:52 <jesusabdullah> I'm kinda on the fence with both of them tbh
11:40:48 <handonson> chrisdone: i think there is a point in what you've said, but i don't think you example is making it. think about def f(x): return x + "bar" in Python. you write it, and it doesn't get run if you don't put it in a special place construct.
11:40:53 <handonson> so it's not weird at all.
11:41:17 <djahandarie> shapr, if there were a team then we could push the language more in Ubuntu as well :)
11:41:34 <handonson> that particular one is normal, in almost all general-purpose programming languages.
11:41:42 <chrisdone> handonson: i guess not. i suppose the function f describes some computation rather than running it directly
11:41:43 <jesusabdullah> It'd be nice to see better ubuntu action with haskell :/
11:41:46 <shapr> There's already a Haskell package section, but it's not updated as often as the Debian packages.
11:41:52 <jesusabdullah> Not that it's terrible, but...idk.
11:42:31 <handonson> chrisdone: you said it's weird because it doesn't get run if you don't place it carefully. i'm saying that applies to all other languages too.
11:43:52 <handonson> i know in Haskell some stuff doesn't get run even if it really looks like it has to be run once. but that one is irrelevant to the laziness, the purity, or whatever special of Haskell.
11:44:25 <handonson> by "that one" i mean... (\x -> x ++ "bar")
11:45:27 <chrisdone> handonson: sure. it's just a value that you pass a around until you put it in a special place and want to run it
11:46:20 <handonson> chrisdone: and, to answer your earlier question, yes i know function pointers, although i wasn't a big fan of them when i was forced to write in C in college
11:47:43 <Trevion> When GHCi says "Loading object (dynamic) xxx ... done" on Windows, does that mean it's loading a DLL?  What's it actually doing?
11:48:54 <kaol> Whee, runContT is lovely. runContT (`callCC` return) $ \exit -> ... when (a == b) $ exit "stop here" ... liftIO launchMissiles
11:49:18 <chrisdone> handonson: if i run this program, do you know what gets printed?
11:49:18 <chrisdone> main = do putStrLn "foobar"
11:49:18 <chrisdone>           return (putStrLn "sausages")
11:49:18 <chrisdone>           return ()
11:49:51 <handonson> although totally irrelevant, it's 3:48 in the morning here, and these tiny flying insects are all over my room.
11:50:09 <handonson> chrisdone: foobar?
11:50:13 <handonson> i mean, foobar\n
11:50:35 <chrisdone> good. what happens to (putStrLn "sausages")?
11:52:52 <handonson> chrisdone: from my previous remarks.... (>>=) :: (Monster m) => (m a) -> (a -> m b) -> (m b) there is a monster wannabe (a -> m b) who wants to kill another monster (m a), opens up the carcass and and devour its heart (a), becoming a new monster (m b)
11:53:32 <kaol> > do {b <- Just 123; return undefined; return "abc"}
11:53:33 <lambdabot>   Just "abc"
11:53:46 <handonson> notably, if this monster is of a special tribe called IO, they release some toxic gas called side-effect when their body gets opened up by evil (>>=)s or (>>)s
11:55:29 <jesusabdullah> good lord
11:55:37 <jesusabdullah> BEST ANALOGY EVER
11:55:43 <jesusabdullah> even if it almost doesn't make sense >_<
11:55:48 <handonson> so the second line, the poor { return (putStrLn "sausages") } which is (m (m a)) will be killed and ripped apart, but nothing toxic will be release because anything wrapped up by return doesn't cause any side-effect when unwrapped
11:55:54 <Baughn> Makes almost no sense whatsoever, but I don't care. :P
11:55:57 <jesusabdullah> handonson: Turn this into a blog post.
11:56:02 <jesusabdullah> handonson: With pictures.
11:56:15 <c_wraith> The "monster" thing came from an email on the -cafe list a while ago.
11:56:18 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2704 <- I was going to say, here's a quick haskell hack for generating passwords. Do any of you have similar things in ~/bin?
11:56:21 <winxordie> I almost miss the monads contain nuclear waste idea.
11:56:23 <c_wraith> But the violence and toxic gas are new :)
11:56:34 <jesusabdullah> haha
11:56:41 <jesusabdullah> I like the m is for monster part
11:56:54 <shapr> I discovered that Laney is the Ubuntu Haskell Team!
11:56:57 <shapr> Laney++
11:56:59 <edwardk> handonson: this is notably less cheerful than the "warm fuzzy thing" analogy we've been searching for. This is more of the "where the fuzzy things are" version.
11:57:15 <jesusabdullah> I got a werewolf heart! She knew that right from the start that I would tear her apart at the first full mooooooon
11:57:22 <winxordie> you could make it warm fuzzy monsters
11:57:30 <chrisdone> bears, essentially
11:57:32 <Laney> :)
11:57:40 <jesusabdullah> monads: NRA American Hunter version
11:57:44 <shapr> jesusabdullah: Hey dude, this channel is about Haskell, heavily off-topic stuff goes to #haskell-blah.
11:58:10 <edwardk> heya shapr
11:58:12 <jesusabdullah> I'm not trying to be outrageously off-topic
11:58:15 <shapr> y0 edwardk
11:58:27 <shapr> jesusabdullah: Well, werewolves fit into that category.
11:58:46 <djahandarie> Laney++
11:59:17 <handonson> jesusabdullah: thank you.
11:59:27 <jesusabdullah> handonson: huh?
11:59:44 <handonson> for... calling that a good analogy?
11:59:47 <jesusabdullah> Oh
11:59:52 <jesusabdullah> Yeah, no problem
11:59:56 <handonson> chrisdone: hope that answered your question.
12:00:39 <handonson> edwardk: SPJ is deceiving us. monads are definitely monsters.
12:01:09 <Baughn> If so, what are functors?
12:01:23 <djahandarie> handonson, I think the whole aim of this discussion was to make it clear when something actually gets printed.
12:01:25 <edwardk> handonson: well, nothing precludes monsters from being warm, fuzzy or things. so perhaps he is just being selective in the attributes he chooses to describe
12:01:46 <djahandarie> handonson, and the main point was that you can mess around a lot after the "print a" before it actually gets printed.
12:01:56 <djahandarie> handonson, and that do notation has nothing to do with it (no pun intended). :P
12:02:51 <shapr> tjenare pukka!
12:03:10 <handonson> djahandarie: i'm quite familiar with that notion now, using do constructs heavily for no-doing-at-all tasks while learning how to use Parsec.
12:03:14 <pukka> hej hej :)
12:03:52 <zygoloid> spj is secretly a monster, trying to convince us otherwise with suggestions of warm fuzzy things ;-)
12:04:17 <djahandarie> handonson, the accepted terminology is that something can be evaluated, but nothing will actually happened until it is executed (and that execution happens outside of anything you can do in the language).
12:04:31 <chrisdone> unsafeTrustSPJ
12:05:09 <zygoloid> unsafeTrustSPJ :: WarmFuzzyFeelings m => m SPJ
12:05:12 <djahandarie> At least, accepted within the Haskell community
12:06:07 <djahandarie> Personally those terms make sense to me and don't really conflict with meanings from other languages (they clarify the meanings from other languages rather than conflict with them).
12:06:13 <djahandarie> Unlike return. -_-
12:06:38 <zygoloid> and class :o
12:07:12 <Ferdirand> Monads are like Magritte's painting "this is not a pipe"
12:07:22 <djahandarie> lol
12:07:29 <jesusabdullah> elaborate?
12:07:31 <jesusabdullah> :)
12:07:33 <handonson> how?
12:07:49 <chrisdone> Monads are tauntauns
12:07:58 <chrisdone> And I thought they smelled bad on the inside!
12:08:02 <djahandarie> @quote endospacesuit
12:08:03 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
12:08:03 <sproingie> and i thought they smelled bad ... on the outside!
12:08:04 <chrisdone> er, outside. damnit
12:08:11 <aristid> jesusabdullah: postmodernism does not explain anything
12:08:31 <Ferdirand> M a is a painting of some a, but it is not an a
12:08:33 <sproingie> ceci n'est pas une Monad
12:08:37 <jesusabdullah> hah
12:08:38 <zygoloid> jesusabdullah: yes, the analogy is elaborate.
12:08:43 <aristid> @quote monochrom.*postmodernism
12:08:43 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
12:08:51 <aristid> hmmm
12:08:58 <Ferdirand> so  you have your (a -> m b) that is a machine that makes paintings of a
12:09:00 <aristid> @quote postmodern
12:09:00 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
12:09:05 <aristid> ah, yes!
12:09:11 <jesusabdullah> @quote cuil
12:09:11 <lambdabot> No quotes match. Just what do you think you're doing Dave?
12:09:16 <jesusabdullah> tssch!
12:09:17 <Ferdirand> you cannot use your machine on an existing painting, BUT you can make a painting of the machine making a painting in the painting
12:09:21 <zygoloid> @quote monochrom interpret
12:09:21 <lambdabot> monochrom says: Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing
12:09:21 <lambdabot> is not fixed.
12:09:37 <Ferdirand> and then you zoom the picture and get the other small painting in your painting, that is what (>>=) does
12:09:49 <djahandarie> Ferdirand, stop while you're ahead :P
12:10:00 <jesusabdullah> Is it pipes all the way down?
12:10:07 <sproingie> turtles
12:10:09 <Ferdirand> djahandarie: what ? it makes perfect sense !
12:10:14 <zygoloid> Ferdirand: categorically speaking, that's actually quite accurate :)
12:10:21 <sproingie> monads are turtle burritos
12:10:32 <jesusabdullah> haha
12:10:59 <jesusabdullah> I've heard of weirder things! Mom used to make spaghetti burritos when she needed to find creative ways to use leftovers
12:11:02 <jesusabdullah> No joke
12:11:06 <sproingie> ew
12:11:10 <zygoloid> jesusabdullah: nom!
12:11:21 <mauke> Ferdirand: http://mauke.ath.cx/stuff/img/lol,internet/bthreads/1174226702634.jpg
12:11:26 <jesusabdullah> They were actually surprisingly good
12:11:29 <jesusabdullah> I miss spurritos
12:11:31 <djahandarie> I really think the only reason monads are so confusing is because everyone hears they are really confusing and tries to figure them out before learning more important stuff like type classes
12:11:31 <jesusabdullah> XD
12:11:41 <jesusabdullah> djahandarie: Could be!
12:11:54 <djahandarie> They are a frequent topic in here
12:12:31 <sproingie> they're confusing if you try to find a consistent metaphor that fits all monads
12:12:34 <sproingie> because there isn't one
12:12:58 <djahandarie> I don't know why people tried to come up with metaphors in the first place
12:13:09 <jesusabdullah> People learn from analogy
12:13:16 <sproingie> they're a way of putting two particular endofunctors of the same type together, that that's about it
12:13:19 <jesusabdullah> describing something they don't know with something they DO know
12:13:33 <jesusabdullah> It's pretty integral to how people understand things imo
12:13:35 <sproingie> where "put together" means something different for each monad
12:13:49 <djahandarie> jesusabdullah, and monads are sufficiently abstract that there is nothing that people do know
12:14:03 <jesusabdullah> Well, sure, but that's what makes them hard
12:14:16 <djahandarie> But they aren't hard if you just use them for a day
12:14:21 <sproingie> addition is abstract but most people grok it intuitively
12:14:23 <jesusabdullah> Learning things through analogy is fairly easy, compared to having to learn something completely different
12:14:32 <djahandarie> Rather than read analogies about them for a day
12:14:36 <sproingie> just learn monads as a set of operators and the similarities will just click
12:14:44 * djahandarie agrees with sproingie
12:15:03 <sproingie> big stacks of monad transformers still screw with my brane sometimes
12:15:06 <jesusabdullah> It takes people years before they REALLY learn the basic functions
12:15:10 <sproingie> but not the basic idea
12:15:22 <jesusabdullah> I'm not disagreeing with the idea that trying to find a good analogy is a dead end
12:15:35 <handonson> djahandarie: this time it came up again because someone thought i don't have sufficient knowledge about monads. well, i know what they are... i know how to stay away from monstrous things!!!
12:15:51 <jesusabdullah> and that just using them is probably the best way to learn--learning-by-doing is another really good way to pick things up. Still, there's a reason people try to teach by analogy.
12:16:58 <djahandarie> handonson, if you are talking about chrisdone, his point wasn't about monads but rather about evaluation vs. execution. It just got muddled up in things.
12:17:32 <handonson> djahandarie: i wasn't talking about anything. i was joking, which, apparently, failed miserably.
12:17:53 <djahandarie> Oh. Whoops.
12:18:03 <jesusabdullah> Honestly, I think the biggest issue with learning monads for people is that people get impatient when they're told they have to learn a new concept before they can do proper input/output <_>
12:18:13 <jesusabdullah> Or at least fake it
12:18:24 <jesusabdullah> *shrug*
12:18:42 <djahandarie> I like http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html for those people :-)
12:19:08 <c_wraith> Heck.  I think people *shouldn't* learn what a monad is before they learn IO.
12:19:43 <c_wraith> I think people should learn to use several different specific monads before someone tells them what the common pattern is.
12:19:59 <djahandarie> It's fairly hard to grasp any pattern without knowing any applications of it.
12:20:04 <jesusabdullah> You could be right!
12:20:05 <c_wraith> Doing so makes people far more ready to understand what precisely the abstraction does.
12:20:15 <jesusabdullah> But that still requires faking it, y'know?
12:20:24 <jesusabdullah> Or, y'know, using something you don't 100% understand
12:20:27 <djahandarie> I dislike how people always start with the List monad when they try to explain monads though, it's a confusing one
12:20:28 <jesusabdullah> *shrug*
12:20:39 <jesusabdullah> I should make myself learn more haskell
12:20:46 <jesusabdullah> Then I wouldn't be a poser ;)
12:20:58 * jesusabdullah is LAZY
12:20:59 <c_wraith> You can learn everything about doing IO in haskell without learning what a monad is.
12:21:13 <jesusabdullah> djahandarie: That's awesome.
12:21:34 <djahandarie> It is! What are we talking about? :P
12:21:59 <jesusabdullah> The sigfpe link
12:22:24 <djahandarie> Ah, right
12:22:54 <handonson> c_wraith: agreed. totally. i managed to make a small OpenGL game with 400 lines of source code without knowing a bit of what a monad is.
12:23:51 <djahandarie> Well I've wasted enough time in here when I was suppose to be working
12:23:58 * djahandarie disappears
12:25:40 <b0fh_ua> Hello! Can somebody please explain, how do I create a typeclass, which define a method taking an argument of one type and producing another type?
12:25:44 <b0fh_ua> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27049#a27049
12:26:23 <dolio> a -> b says you'll produce any b the caller wants.
12:27:02 <sproingie> @hoogle a -> b
12:27:03 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:27:03 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:27:03 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:27:29 <dolio> So, maybe you want 'class C a b where foo :: a -> b', both being parameters.
12:27:49 <dolio> Then you could have 'instance C Int String where foo = show'.
12:28:17 <b0fh_ua> hm
12:28:21 <b0fh_ua> sounds interesting
12:28:35 <b0fh_ua> will need a lot of language extensions involved, I guess
12:28:36 <dolio> That will require the MultiParamTypeClasses extension.
12:28:42 <b0fh_ua> flexible instances as least
12:28:49 <b0fh_ua> yeah, that one as well
12:29:37 <tolkad> Is it possible for a class to have two type arguments?
12:29:54 <Heffalump> tolkad: yes, that's what multi parameter type classes do
12:30:37 <tolkad> when I try to do it, it says "too many parameters"
12:31:11 <tolkad> it says you can enable it with an option.... but I'm not sure that's  good idea
12:31:25 <tolkad> will it make my code non-portable or unstable?
12:36:31 <tensorpudding> Most everything uses GHC now, and GHC has supported multi-parameter typeclasses for a while
12:36:48 <applicative> tolkad, it's in Hugs too  http://cvs.haskell.org/Hugs/pages/hugsman/exts.html
12:46:00 <shapr> When will I be able to cabal install ghc?
12:46:07 <dcoutts> ho ho
12:46:21 <dcoutts> shapr: don't hold your breath
12:46:26 <shapr> :-)
12:48:19 <handonson> would there be any chance return gets renamed in haskell prime
12:49:08 <Igloo> I wouldn't hold your breath for that, either
12:49:18 <handonson> :(
12:50:06 <jesusabdullah> haskell``, maybe.
12:50:07 <Igloo> Well, I guess it's actually feasible to change it in a staged way if there is agreement, so maybe it's not out of the question
12:50:14 <handonson> i think it is the first priority to be changed if we redo the spec breaking backward compatibility
12:50:18 <tensorpudding> You don't have to use return, use pure instead if it bothers you that much
12:50:46 <mtnviewmark> true - of all things I'd change in Haskell, return isn't really high on my list
12:51:25 <handonson> tensorpudding: i can "wrap =return" or "monadic = return" in the beginning of my code, but that doesn't really comfort me
12:51:47 <mtnviewmark> my #1: remove if statement and replace with  if :: Bool -> a -> a -> a    and perhaps also   bool :: a -> a -> Bool -> a
12:52:06 <tensorpudding> neither of those terms are better than return
12:52:13 <mtnviewmark> of all the nits, that's the one that bugs me the most when writing code
12:52:37 <handonson> mtnviewmark: imo that would drastically decrease the readability of code
12:52:57 <handonson> mainly because "else" will be visible
12:52:58 <mtnviewmark> really? if / then / else   seems SO unlike the rest of Haskell to me
12:53:04 <handonson> you can't make out
12:53:28 <alexyk> return is a nice touch t o return the imperative folks back into their dirty world
12:53:45 <handonson> then it isn't nice at all.
12:53:48 <tensorpudding> Why do people dislike return?
12:54:07 <alexyk> "take back the return!"
12:54:09 <handonson> the design should be attracting, instead of returning people.
12:54:13 <FunctorSalad> alexyk: uh, in the limited number of cases where it plays a similar role
12:54:26 <kaol> monad fail is fail
12:54:29 <alexyk> handonson: it's attracting the right people
12:54:30 <tensorpudding> I can understand people who dislike it because they dislike do-notation and wouldn't mind it getting removed.
12:54:51 <FunctorSalad> if you were saying that 'return' makes haskell easier to understand for the imperative-habituated
12:55:29 <FunctorSalad> tensorpudding: do-notation isn't just for people who don't get the primitives :D it usually saves a few characters
12:55:47 <FunctorSalad> *if* you couldn't have done it pointlessly in a sane way
12:55:50 <EvanCarroll> BONUS: You know what would of huge assistance to LYAH, an index of the functions mentioned.
12:55:51 <CakeProphet> yeah I get the primitives and use do-notation still because it is a natural way to think about monadic computations
12:56:11 <alexyk> FunctorSalad: no, I meant it as a manhood ceremony; those who learn to distinguish the monadic return from its procedural namesake stay, the rest are catapulted back into imperative abyss by their derision
12:56:23 <handonson> alexyk: that is totally unfair. suppose someone have been accidentally exposed to imperative languages and got deeply intoxicated by side-effects all over the code. that is unlucky and sad enough, and you're saying they shouldn't even get a chance to escape from hell
12:56:28 <EvanCarroll> maybe a right pane display:static, so you can just click on them in every page
12:56:30 <alexyk> "the manhood return rites"
12:56:47 <shapr> Speaking of nice syntax, I like GADTs where the constructors have type signatures. I think that's especially newbie-friendly.
12:56:58 <FunctorSalad> alexyk: uh, the celebration after you've passed or the manhood *test*? not that I really get it either way :D
12:57:04 <handonson> alexyk: was it their own fault to be trapped in hell at the first place? no.
12:57:13 <tensorpudding> I really don't think that return is that big of a hurdle to people.
12:57:28 <mtnviewmark> c'mon - doesn't Haskell have enough coming-of-age rites?   What about "Now unlearn the ordering of the . operator!"
12:57:38 <tensorpudding> Even if they have baggage on what return means, just giving it another name won't lessen the burden of having to learn the paradigm
12:57:52 <FunctorSalad> handonson: and what about people who are living in places where FP missionaries haven't gone yet? will they go to hell too?
12:58:08 <handonson> FunctorSalad: they are already in hell
12:58:25 <CakeProphet> ha
12:58:25 <FunctorSalad> I think this was an actual theoretical problem once because parts of the world were believed to be impassable or something
12:58:30 <tensorpudding> the order of (.) makes complete sense
12:58:30 <CakeProphet> the analogies in this conversation are ridiculous.
12:58:41 <FunctorSalad> (and it seemed a bit unfair that they'd inevitably go to hell)
12:58:42 <alexyk> CakeProphet: look at your nick then!
12:59:01 <handonson> FunctorSalad: i hope they go to heaven if there is afterlife, for, you know, a make-up for their miserable imperative lives they had on earth
12:59:03 <alexyk> CakeProphet is a very good candidate to the mission to the imperatve unworthy
12:59:25 <CakeProphet> I have a somewhat conversational statement to make: I like imperitive code.
12:59:33 <philed> Comparisons of programming languages to religions only fail because it's actually important to have the right programming language.
13:01:09 <alexyk> philed: in fact, people who do not use the said right language, whose name shall not be repeated unnecessarily, are wrong and will be punished for their infidel ways.
13:01:10 <heatsink> ...because programming actually does something useful, I'd say.
13:01:38 <mtnviewmark> tensorpudding - not if you've been coding self.elements().containerAt(100,50).description().name()
13:01:40 <alexyk> ...punished by relentlessly rewriting their code
13:02:00 <tensorpudding> mtnviewmark: they don't even mean remotely the same thing
13:02:23 <handonson> actually that sounds quite interesting. what is the most Haskell-ish religion? Buddhism?
13:02:28 <philed> mtnviewmark: The F# people seem to think the ordering is a big deal and have a pipe-operator (flipped composition) as idiomatic. Maybe it's for that reason.
13:02:47 <heatsink> handonson: Some have compared it to Taoism
13:02:50 <FunctorSalad> nothing wrong with that (the pipe) I'd guess
13:02:53 <mtnviewmark> I know - I know --- that's sort of the point, after you've been coding with periods meaning execting left to right for so long, getting used to periods meaning applying right to left is a "coming-of-age" rite
13:02:54 <mtnviewmark> :-)
13:03:19 <alexyk> infidel ways == not of high fidelity where the effective modeling and techniques are concerned
13:03:20 <Heffalump> one big reason for the pipe is that F# type inference runs left-to-right for the purpose of name resolution
13:03:23 <handonson> wait, never mind. it's satanism, obvious in its overuse of (Monster m) => ...
13:03:24 <FunctorSalad> heh PLs seem nothing whatsoever like religions to me
13:03:30 <CakeProphet> I don't think it bothered me at all. I /have/ taken a math class after all.
13:03:33 <FunctorSalad> the meta-conversation is a different matter
13:03:40 <FunctorSalad> but a lang in and of itself?
13:03:41 <tensorpudding> (.) makes sense to anyone who's seen it before in mathematics
13:03:51 <CakeProphet> tensorpudding:  yeah, see above
13:03:54 <philed> But some category theorists like to do morphism composition the other way around to function composition. Maybe (.) should be the other way around.
13:04:00 <mtnviewmark> Yup - saw that in F#, and wondered if it was that communty's common idiom, or a crutch for new folks
13:04:23 <mtnviewmark> actually, to be honest, when I first saw it in mathematics (what, 10th grade?) I thought it was backwards!
13:04:33 * alexyk prefers the |> of F#, now in OCaml's Batteries pointful, |- point-free
13:05:13 <aristid> philed: you mean like >>>?
13:05:23 <mtnviewmark> (|) = (.) would really bring in the shell scripters!
13:05:25 <alexyk> x |> y |> is better-looking than y . x . ... $ ...
13:05:30 <aristid> :t (>>>)
13:05:30 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
13:05:31 <dons> dafis: do your patches apply against today's darcs ?
13:05:35 * edwardk realized he was making the equivalence class stuff too complicated.
13:05:45 <heatsink> We can use (.) for right-to-left composition and (?) for left-to-rigth composition.
13:05:49 <philed> aristid: Yeah, I guess so.
13:06:00 <alexyk> and programming runs left to right unless you're used to Hebrew/Arabic, I suppose
13:06:02 <philed> I haven't looked into arrows much.
13:06:08 <Heffalump> alexyk: the big problem with pipelines is that they don't give you subexpressions
13:06:23 <dolio> x |> y |> is making the same mistake as y $ x $
13:06:24 <alexyk> dafis: am trying your enchancements
13:06:25 <aristid> philed: >>> is separated from arrows now
13:06:26 <Heffalump> I guess you could use foo |> y >> z >> w, if the precedences work, but people don't
13:06:29 <tensorpudding> I don't think that there are many programming languages that are in right-to-left languages
13:06:47 <aristid> f(g(h()))
13:06:59 <dafis> dons: you mean ghc-gc-tune?
13:07:10 <aristid> hmm
13:07:50 <philed> alexyk: How much is the batteries syntax extensions being used, if that question is even answerable? I'm doing a lot of HOL Light at the moment, which is unfortunately stuck with camlp5 so I don't think I can make much use of the batteries stuff. But I might be able to write the odd library module. 
13:08:09 <alexyk> dafis: what's the purpose of the treesc.hs and treescNN.hs?  they differ only in didintern2.  Are they supposed to save the new Trie SLP using the instance provided?
13:09:27 <alexyk> philed: I just used Batteries for my OCaml version of the twitter shootout, but since I picked |> up in F#, I loved it right away and peppered all my code with it.  And |- is cute for point-free, although OCaml is often incapable of generalizing with it.
13:09:56 <dafis> alexyk: triesc saves the entire trie, including people not in the sample (so just short of a million leaves), triescNN leaves out people not in the sample, so that gives a trie of the same size as the Map
13:09:57 <philed> Yeah, that's what I was thinking. The value-restriction has bitten me plenty of times already.
13:10:00 <alexyk> aristid: f(g(h))) is so 1700s!
13:10:26 <aristid> alexyk: that was obviously the best century of them all.
13:11:04 <mtnviewmark> Gauss!  We can thank Gauss for that notation - 
13:11:31 <edwardk> mtnviewmark: thank? or blame? =)
13:11:33 <dafis> alexyk: they save the tries via Data.Trie, nothing new there, the new stuff is only in the deserialising
13:11:41 <mtnviewmark> He inadvertandly created a real bind for computer language designers 300 years later
13:11:43 <mtnviewmark> BLAME!
13:11:47 <dons> dafis: yeah, your patches. do they apply against head?
13:11:53 <mtnviewmark> I've cursed his name before when working on language design
13:12:27 <alexyk> dafis: so can I read an existing dump of a Trie [(Int, Float)] with it?
13:12:33 <dafis> dons: I sent you the whole file, as I modifed it from 0.2 on hackage
13:12:43 <dafis> alexyk: yes
13:13:13 <alexyk> dafis: what about [(Int,Double)] where I swicthed meanwhile?  Should it work if I replace Float by Double eveywhere?
13:13:26 <dafis> alexyk: the serialisation gives the same results, I only changed deserialisation
13:13:40 <dafis> alexyk: It should
13:13:58 <edwardk> mtnviewmark: clearly you should just force your users to adopt juxtaposition as application like Haskell. problem solved. now you just need to untrain 2-3 generations of computer scientists.
13:14:37 <alexyk> dolio: I meant |> ... |> z of course.
13:15:00 <dolio> It doesn't matter. Repeated |> is the problem.
13:15:08 <mtnviewmark> Exactly!  I once tried to force semantic meaning on font formatting (bold and italic had meaning in the language) -- but was resoundly beaten with large pre-1980 text editors for it
13:15:08 <dons> dafis: ok. i changed a few things in 0.2.1, so will merge by hand.
13:15:12 <alexyk> dolio: as are repeated . ?
13:15:16 <yrlnry> It would be better if all function application notation was postfix.
13:15:32 <alexyk> how can you not repeat if you apply more functions?
13:15:35 <yrlnry> That way you could read an expression like x h g f  and it would read in the order that the operations were carried out.
13:15:35 <dolio> No. Repeated $ is the problem. They should be replaced by .
13:16:10 <alexyk> dolio: |> is different from .
13:16:11 <dolio> f $ g $ h $ x and f . g . h $ x work the same in Haskell, for instance.
13:16:20 <mtnviewmark> a problem as in     foo x $ bar y $ reverse $ sort $ map f thingies      is ugly?
13:16:30 <mtnviewmark> yes, $ is a very unfortunate choice, typographically
13:16:33 <dafis> alexyk: one thing that should be intereting too is changing the (de)serialisation of Floats/Doubles via unsafeCoerce to Word32/Word64 and put/getWordNNbe
13:16:36 <soupdragon> why is it ugly
13:16:50 <alexyk> you get |> for x |> f and (f |- g) x for x |> f |> g
13:17:03 <mtnviewmark> $ as a glyph isn't designed to format and read well with letters - and it doesn't
13:17:14 <dolio> But only the latter allows you to, say, remove the x point and get a valid expression.
13:17:16 <mtnviewmark> it carries too much ink on the page - 
13:17:26 <mtnviewmark> and it's height and visual mass is large
13:17:26 <dolio> f $ g $ h is a type error, but f . g . h is not.
13:17:46 <tafryn> Is there a 'best' way to extract something from a Just?
13:17:53 * mtnviewmark admits to having been taught the ways of publication layout at his mother's knee
13:17:57 <alexyk> dolio: usually you either have a point or not
13:18:06 <alexyk> for F#/OCaml folks at least
13:18:14 <alexyk> they're less, um, monadic
13:18:17 <edwardk> dolio: i waffle back and forth on that, some times i'm all for the functional notation but other times the $ just seems to fit. most notably when i can't remove the last point
13:18:21 <dafis> tafryn: maybe default id, resp. fromMaybe default
13:18:26 <sproingie> tafryn: fromJust
13:18:34 <edwardk> i realize cale might have my head for saying that ;)
13:18:39 <sproingie> > fromMaybe Nothing
13:18:41 <lambdabot>   Overlapping instances for GHC.Show.Show
13:18:41 <lambdabot>                              (Data....
13:18:46 <sproingie> oh FINE
13:18:50 <dolio> edwardk: I know. That happens to me sometimes.
13:18:50 <sproingie> > fromMaybe Nothing :: Maybe Int
13:18:52 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
13:18:52 <lambdabot>         again...
13:18:54 <alexyk> mtnviewmark: is your mother Ventura Publishing?
13:18:59 <sproingie> oh silly me
13:19:02 <sproingie> > fromMaybe Nothing :: Int
13:19:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:19:03 <lambdabot>         against inferred type ...
13:19:24 <sproingie> yay.  i'd just pattern match myself
13:19:45 <dafis> > fromMaybe 3 (Just 5) :: Int
13:19:46 <lambdabot>   5
13:19:53 <dafis> > fromMaybe 3 Nothing :: Int
13:19:54 <lambdabot>   3
13:20:00 <edwardk> operationally the interpretation of $ is more likely to be kind to your program than . anyways, since the $'s _will_ vanish as they replace themselves with id but the .'s may leave a residue 
13:20:01 <dolio> alexyk: Following the f . g . h $ x convention also allows you to change the associativity of $, to where f $ x $ y = f x y.
13:20:04 <mtnviewmark> no alexyk, I'm older than that --- Presstype!
13:20:11 <sproingie> oh i misunremembered it
13:20:26 <dolio> And from there, you get new opportunities for use, like 'f $ g x $ h y = f (g x) (h y)'.
13:20:49 <dolio> Which is impossible to de-parenthesize currently.
13:21:15 <edwardk> clearly that should be ! ;)
13:21:39 <dolio> Why is that clear? ! is already strictness and array indexing. :)
13:22:03 <edwardk> because ? seems so indecisive ;)
13:23:00 <zygoloid> edwardk: and $ seems so capitalist?
13:23:25 <edwardk> if you had -- available you could make them look like options f --g x --h y ;)
13:23:26 <FunctorSalad> (.) in math is bad IMHO, but the cost of reform might be too high
13:23:41 <FunctorSalad> severely increasing the confusion in the transition period, and for people reading older texts
13:24:01 <dolio> In Agda, with unicode available, I kind of like a bullet character.
13:24:47 <alexyk> FunctorSalad: (.) should be sold to Google to become the GoogleDot.  You get 15 free AdSense clicks for each usage.  f GoogleDot g iPhoneDot x
13:25:02 <alexyk> (10000000 usages, and you get a free white one)
13:25:13 <FunctorSalad> hmm?
13:25:14 <sproingie> i remember sun's disastrous "we're the dot in dot com" campaign
13:25:28 <sproingie> apropos enough it ran just before the dot com crash
13:25:29 <FunctorSalad> I meant that the order or arguments is bad
13:25:30 <dolio> f â g â h â¢ x
13:25:33 <alexyk> (if . has to go, might as well cash it in!)
13:25:37 <zygoloid> what about a non-breaking space for $ ?
13:25:44 <FunctorSalad> it sucks especially for transcribing from/to diagrams
13:25:50 <FunctorSalad> unless you make all your arrows point backwards to
13:25:52 <FunctorSalad> *too
13:26:03 <alexyk> FunctorSalad: but yeah, the order of the . was pre-computer workflow
13:26:20 <FunctorSalad> how's it computer-specific?
13:26:37 <FunctorSalad> it was simply an extension of the convention of writing args to the right
13:26:40 <alexyk> sproingie: they didn't know there will be a crash
13:26:51 <sproingie> no but it was stupid even then
13:26:58 <FunctorSalad> yes
13:27:16 <edwardk> dolio that is like multiple choice. =)
13:27:23 <FunctorSalad> if you intuitively consider function application "forwards", and left-to-right "forwards"
13:27:26 <FunctorSalad> the latter being cultural
13:27:34 <alexyk> zygoloid: with X-ray vision goggles to discern the space
13:27:35 <edwardk>  f â g â h y â¢ x  f â g â¢ h â¢ x
13:27:44 <dolio> Heh.
13:28:09 <alexyk> FunctorSalad: well monotype is linearized; in math you scan sun/integral symbols up and down already
13:28:10 <dolio> There's no bubble for either f or x, though.
13:28:14 <edwardk> zygoloid: tab! ;)
13:28:17 <alexyk> sum
13:28:44 <alexyk> the phat dot wins
13:28:59 <alexyk> how about a dot with a bite where the direction goes
13:29:02 <alexyk> a packman dot
13:29:15 <sproingie> f â  g
13:29:39 <alexyk> that's Hazkell Piratez
13:29:48 <alexyk> Piratz I meant
13:29:55 <sproingie> arr
13:30:15 <alexyk> arrgs!  left to right arrgs!
13:30:47 <dafis> alexyk: anything on the memory consumption yet?
13:31:02 * alexyk gets back to work
13:31:18 <FunctorSalad> dolio: was that @ extension of application syntax? it's just that it makes the definition of . just a matter of shifting punctuation around
13:31:37 <FunctorSalad> rather than letters, with (f | g) x := g (f x)
13:32:03 <FunctorSalad> but there seems to be no good reason why application is argument-right
13:32:04 <dolio> I don't understand the question.
13:32:27 <FunctorSalad> <dolio> There's no bubble for either f or x, though.
13:32:42 <dolio> Oh, no. edwardk said it looked like multiple choice.
13:32:55 <FunctorSalad> oh, sorry. thought that was an objection to how (f.g)'s def grew from application syntax
13:33:05 <dafis> FunctorSalad, hysterical, you say "sine of x" and not "x sine", I imagine
13:33:27 <FunctorSalad> what's the filled dot edwardk ?
13:33:51 <dolio> â¢
13:33:56 <FunctorSalad> dafis: I meant a-priori reason, as opposed to custom
13:34:27 <FunctorSalad> <sproingie> f â  g <-- hmm you may suggest that for 'annihilators' or 'annulators' in some math
13:34:39 <FunctorSalad> (commutative algebra or so)
13:34:50 <dafis> FunctorSalad, yes, but I imagine the pronunciation was the reason for the historical decision to write the arguments to the right of the functions
13:35:06 <dafis> and after a few hundred years, it just stuck
13:35:22 <alexyk> dafis: in order to explore disinterning either through IntMap or Trie component of the dic, I went back to loading the whole triple; while your disintern2 works with the IntMap part.  Would it be preferable to use the Trie part?  I noticed that reading the whole triple is not a big deal, and also if the Trie is better, I can revert to saving it first.
13:35:44 <FunctorSalad> dafis: some operators are postfix traditionally though
13:35:50 <FunctorSalad> not sure if that's relevant
13:36:05 <FunctorSalad> (factorial, squaring etc)
13:36:09 <dafis> FunctorSalad, some, but not many
13:36:17 <philed> "x sin" could be read as "x's sine".
13:36:26 <sproingie> FunctorSalad: it'd be a good "poison" operator for CHP :)
13:36:31 <alexyk> dafis: good point re: pronunciation
13:36:41 <FunctorSalad> you'd probably want to read postfix app as "into" or so
13:37:49 <Saizan_> well, you also say "x factorial" no? at least that's what we do in italian :)
13:37:54 <FunctorSalad> sproingie: no clue about CHP but is that in the sense of going into a mode that terminates all the threads? (without OS divine intervention)
13:38:22 <dafis> alexyk: disintern2 was for the Trie, for the sample, on my box, IntMap was faster and took less memory
13:38:23 <FunctorSalad> Saizan_: yes
13:38:31 <FunctorSalad> (german and engl afaik)
13:39:03 <alexyk> dafis: you mean IntMap from the IntBS you mean, right?
13:39:11 <dafis> FunctorSalad, yes, and french too, iirc
13:39:19 <FunctorSalad> what Tries? out of curiosity
13:39:24 <FunctorSalad> I've only used ByteString ones
13:39:28 <alexyk> Saizan_: in Russian, x ÑÐ°ÐºÑÐ¾ÑÐ¸Ð°Ð» too
13:39:31 <dafis> alexyk: right
13:39:51 <dafis> alexyk: not the library thing, that's too lazy for your data
13:39:58 <Saizan_> though i wouldn't be so sure about the spoken version coming first
13:39:59 <sproingie> FunctorSalad: it's basically a value that shuts down the channel when it's read
13:40:04 <alexyk> dafis: right
13:40:16 <sproingie> FunctorSalad: sort of a delayed exception
13:40:17 <dafis> FunctorSalad, ByteString tries
13:40:35 <FunctorSalad> sproingie: for the purpose of terminating threads without breaking normal control flow, I thought
13:40:52 <FunctorSalad> (like for controlledly terminating the whole program)
13:40:55 <aristid> @let (|->) = flip id
13:40:56 <lambdabot>  Defined.
13:41:00 <sproingie> FunctorSalad: yah, pretty much
13:41:08 <FunctorSalad> ok
13:41:10 <aristid> > 1 |-> sin
13:41:11 <lambdabot>   0.8414709848078965
13:41:34 <aristid> there you have your postfix application :P
13:41:58 <dafis> alexyk: wait
13:42:35 <alexyk> aristid: "1 is a sin"?
13:42:55 <alexyk> one unto sin
13:42:59 <c_wraith> @let (!) n = product [1..n]
13:42:59 <lambdabot>  Defined.
13:43:04 <c_wraith> > (5!)
13:43:05 <lambdabot>   Ambiguous occurrence `!'
13:43:05 <lambdabot>  It could refer to either `L.!', defined at <local...
13:43:11 <c_wraith> boo
13:43:15 <aristid> > 5 |-> (!)
13:43:16 <lambdabot>   Ambiguous occurrence `!'
13:43:16 <lambdabot>  It could refer to either `L.!', defined at <local...
13:43:21 <c_wraith> @let (!!!!) n = product [1..n]
13:43:22 <lambdabot>  Defined.
13:43:26 <c_wraith> > (5!!!!)
13:43:27 <lambdabot>   120
13:43:32 <alexyk> yay!!!!
13:43:34 <c_wraith> postfix operator application :)
13:43:42 <heatsink> FunctorSalad: You can find some linguistic universals at http://typo.uni-konstanz.de/archive/intro/index.php
13:43:45 <mtnviewmark> > let yay=5 in yay!!!!
13:43:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:43:55 <mtnviewmark> > let yay=5 in (yay!!!!)
13:43:55 <heatsink> FunctorSalad: The ones relevant to you will be the syntactic universals
13:43:57 <lambdabot>   120
13:44:06 <aristid> mtnviewmark: damn you idea stealer
13:44:07 <c_wraith> It's a cute trick, but not useful. :)
13:44:14 <mtnviewmark> just a fast typist
13:45:03 <dafis> alexyk: I meant, deserialising to a *Map ByteString SLP* was faster than to Data.Trie SLP
13:45:52 <alexyk> dafis: aha!
13:45:54 <aristid> is http://cale.yi.org down for you?
13:46:29 <FunctorSalad> heatsink: is this about a-priori notation merits?
13:46:38 <heatsink> FunctorSalad: yeah
13:46:41 <Apocalisp> @type \f g x y -> f x >>= \a -> f y >>= \b -> return g a b
13:46:42 <dafis> aristid, as a first guess, yes
13:46:42 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> t -> m b
13:46:50 <FunctorSalad> sorry was confused from all the topics ;)
13:47:02 <Apocalisp> @hoogle (t -> m a) -> (a -> m b) -> t -> t -> m b
13:47:03 <lambdabot> No results found
13:47:34 <FunctorSalad> heatsink: before looking there, I didn't mean left-to-right is a priori better, but what *is* a-priori better is making the writing direction and the intuitive direction of function application agree ;)
13:47:39 <alexyk> dafis: so readBSMapSLP would be the fastest to try?
13:47:42 <dafis> aristid: http://downforeveryoneorjustme.com/cale.yi.org
13:47:43 <FunctorSalad> the mirror would be just as good
13:48:19 <dafis> alexyk: Well, here, for the sample. Might be different for the whole set on your server
13:48:21 <aristid> Cale: your site is always down when i want to show people your cool articles :(
13:48:54 <dafis> alexyk: but I'd try readBSMapSLP first
13:49:27 <alexyk> dafis: what does it read, the result of a dumped Map ByteString?
13:49:28 <dafis> alexyk: then compare to trieReadSLP
13:50:21 <dafis> alexyk: yes, the dump of Map ByteString [(Int,Float)] (Double if you replace the types)
13:51:00 <dafis> alexyk: and trieReadSLP reads the dump of a Trie [(Int, Float | Double)]
13:51:17 <alexyk> dafis: OK, good.  I killed my old dcaps which littered the disk, so first will write me a new Map one with a regular saveData...
13:51:37 <heatsink> FunctorSalad: Natural languages put verbs all over the place.  However, languages that put the verb first or last typically show additional syntactic tendencies.
13:51:43 <alexyk> dafis: I noticed that writing a Map is faster than a Trie, too.  So the Tries are no good! :)
13:51:43 <aristid> preflex: seen cale
13:51:43 <preflex>  cale was last seen on #haskell 14 hours, 12 minutes and 1 second ago, saying: varnie: filter p xs
13:51:59 <dafis> alexyk: okay, that's going to take how long, approximately?
13:53:06 <alexyk> dafis: I'll try to do it this afternoon.  Have a paper submission deadline and a porposal edit, so might be a bit.  I'll email you the results
13:53:22 <dafis> alexyk: Not necessarily. For the whole set, trie-lookup may be fast enough to compensate
13:53:44 <dafis> alexyk: okay, fine
13:53:50 <FunctorSalad> (or I guess there are in fact three signums here: 1. cultural writing direction, 2. order of composition arguments, 3. intuitive direction of function application (forwards/backwards). #1 and #2 should be equal iff #3==forwards)
13:54:03 <alexyk> dafis: right, the multiple lookup may be worth it; a single lookup would make faster load time preferable
13:54:26 <alexyk> dafis: for the multiple ones, I'd add a simple server on a socket
13:54:50 <FunctorSalad> heatsink: ah, you're at application again
13:54:54 <FunctorSalad> (prefix or postfix)
13:54:58 <McManiaC> can you say "function (xy :: X a -> X a) _corresponds to_ function (yx :: a -> a)"?
13:55:01 <FunctorSalad> I was still at composition syntax ;)
13:56:31 <FunctorSalad> though admittedly a function isn't a process and might as well describe backwards time-evolution
13:56:46 <chrisdone> McManiaC: i'm sure there's a categorical definition. ski?
13:56:54 <alexyk> dafis: I'll unify the driver with both choices, distinguishing by the composite suffix of the file to be written, and make modules out of your map and trie SLPs
13:57:01 <McManiaC> chrisdone: ski?
13:57:17 <chrisdone> someone in here who i know knows category theory
13:58:13 <chrisdone> probably not isomorphic to
13:58:23 <dafis> alexyk: fine, the SLP is identical in both
13:58:28 <heatsink> FunctorSalad: Hmm.  Maybe relativization would be a natural language analogue of composition.  http://wals.info/supplement/intro122-123
14:00:16 <FunctorSalad> heatsink: with "verb fist/last", do you mean left-right or timewise in vocal speech?
14:00:32 <FunctorSalad> the latter I guess
14:00:53 * hackagebot hstatistics 0.2.0.8 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.0.8 (VivianMcPhail)
14:01:01 <heatsink> FunctorSalad: Timewise
14:02:26 <FunctorSalad> heatsink: composition isn't just nesting/"recursion" (not sure of linguists call it like that)? like "the father of the mother of Foo"
14:02:46 <FunctorSalad> now that's just double application, but if you pointlessify it ;)
14:03:37 <Apocalisp> is there a shorthand combinator for (liftM2 g) `on` f ?
14:04:28 <FunctorSalad> @ty (liftM2 ?g) `on` ?f
14:04:29 <lambdabot> forall a2 r (m :: * -> *) a. (?g::a2 -> a2 -> r, Monad m, ?f::a -> m a2) => a -> a -> m r
14:05:12 <FunctorSalad> can't think of anything simpler
14:05:29 <FunctorSalad> maybe it just looks too long due to the silly 'liftM2' name
14:06:17 <FunctorSalad> (\x y -> g <$> f x <*> f y) may be slightly easier to read?
14:06:42 <Apocalisp> FunctorSalad: Quite possibly
14:06:43 <heatsink> FunctorSalad: Genitives are a special case though, they often don't work like verbs.  
14:07:27 <FunctorSalad> heatsink: hmm with activities, composition seems a bit like "<verb1> the Foo and then <verb2> it"
14:07:39 <FunctorSalad> ("it" now referring to the result of <verb1>ing the Foo)
14:08:32 <FunctorSalad> but I've lost sight of what exactly the point we're discussing is =)
14:09:18 <mtnviewmark> "Verbing wierds language."
14:09:22 <heatsink> Now that I look at it, composition in natural languages seems to be relational.
14:09:55 <heatsink> That is, f(g(x)) involves the result of g(x), which is never mentioned explicitly
14:10:36 <heatsink> But natural language equivalents seem to give that result a name
14:10:44 <heatsink> such as using a pronoun
14:10:59 <FunctorSalad> and how do you abstract over x in NL?
14:11:08 <FunctorSalad> we want \x -> f(g(x)) after all
14:11:08 <aristid> x g f
14:11:21 <zygoloid> heatsink: \pasta -> eat (cooked pasta)
14:11:31 <FunctorSalad>  "the process of taking a foo, and first f'ing than g'ing it" ;)
14:11:41 <FunctorSalad> flip
14:12:04 <zygoloid> FunctorSalad: technically, g'ing it, then f'ng /the result/
14:12:16 <zygoloid> silly imperative natural languages
14:12:40 <FunctorSalad> zygoloid: yeah, hence 'flip' ; I have just 1 hand free
14:13:01 <zygoloid> FunctorSalad: my point was that you're not f'ing it, you're f'ing /the result/
14:13:11 <FunctorSalad> yes
14:13:49 <FunctorSalad> flip was to destructively apply to my prev line :)
14:13:56 <Veinor> zygoloid: you cook pasta with a heatsink?
14:14:14 <aristid> :t flip
14:14:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:14:17 <zygoloid> Veinor: it's an "advanced technique" :)
14:14:37 <aristid> ah, lambdabot.
14:14:45 <aristid> :t Prelude.flip
14:14:46 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:14:46 <sm> how do I make #ifdef HOSTNAME ... hostname = "HOSTNAME" ... #endif work ?
14:14:52 <aristid> @src flip
14:14:52 <lambdabot> flip f x y = f y x
14:15:00 <aavogt> sm: -XCPP
14:15:21 <sm> cpp is working, but the quotes disable it
14:15:52 <monoidal> @pl \f x -> fmap ($x) f
14:15:52 <lambdabot> flip (fmap . flip id)
14:15:56 <L8star> hello
14:16:12 <dino-> On a strangely related note, I'm having trouble figuring out the type of flip fmap (* 5)
14:16:20 <dino-> I mean without asking ghci for it
14:16:38 <monoidal> (Int -> ) is a functor
14:17:27 <dino-> monoidal: Right, so it's good as first arg to flip fmap :: Functor f => f a -> (a -> b) -> f b
14:18:10 <Veinor> > flip [(+1)] 2
14:18:10 <dino-> But how does it then become (Num a) => (a -> b) -> a -> b  ?
14:18:10 <lambdabot>   [3]
14:18:33 <Veinor> > flip [(5-)] 2
14:18:34 <lambdabot>   [3]
14:18:34 <dino-> ( the type of flip fmap (* 5) )
14:18:42 <Veinor> > flip [(5-), (/4)] 2
14:18:43 <lambdabot>   [3.0,0.5]
14:18:57 <monoidal> (*5) :: Num a => a -> a
14:19:58 <monoidal> so if you substitute f ::Num a => a -> a in Functor f => f a -> (a -> b) -> f b it becomes (a -> a) -> (a -> b) -> (a -> b), and giving (*5) it is (a -> b) -> (a -> b)
14:20:16 <zygoloid> dino-: so, flip fmap :: Functor f => f a -> (a -> b) -> f b.   (* 5) :: Num a => (->) a a.  so f ~ (->) a.
14:20:21 <monoidal> * substitute f a = a -> a
14:20:50 <zygoloid> dino-: that gives flip fmap (* 5) :: Num c => (c -> a) -> (a -> b) -> (c -> b)
14:21:43 <zygoloid> or rather :: Num c => (a -> b) -> (c -> b), where a ~ c
14:22:56 <dino-> I'm confused, like we lost the f b at the end.
14:23:09 <monoidal> f b is a -> b
14:24:04 <zygoloid> it would have been much clearer if we'd used two different names for 'a'.
14:24:06 <monoidal> dino-: for (a->), fmap is the same as (.)
14:24:47 <monoidal> dino-: if you take f y = x -> y, then  (a -> b) -> f a -> f b becomes (a ->b) -> (x ->a) -> (x->b), which is type of (.)
14:25:58 <monoidal> giving (*5) as the second argument x->a, x is unified with a and the type is (a -> b) -> (a -> b).
14:25:59 <sm> Although macro expansion does not occur within a quoted string, the text of the macro arguments can be quoted and treated as a string literal by using the "#" directive (also known as the "Stringizing Operator") <- doesn't seem to work with ghc
14:28:23 <shapr> #haskell is SO MUCH NICER than #python !
14:28:33 <shapr> This channel is awesome!
14:28:41 * chrisdone high-fives shapr
14:28:48 <McManiaC> \o/
14:28:52 <zygoloid> hugs all round! :)
14:29:01 <McManiaC> â¥
14:29:06 <shapr> Yay!
14:29:10 <aristid> :t love
14:29:11 <lambdabot> Not in scope: `love'
14:29:36 <zygoloid> > bitchiness
14:29:37 <lambdabot>   Not in scope: `bitchiness'
14:29:39 <dino-> monoidal, zygoloid: thank you
14:29:40 <zygoloid> you said it, lambdabot
14:29:44 <sm> hmm. cpphs docs: Macros are never expanded within Haskell comments, strings, or character constants, unless you give the --text option. 
14:29:58 <sm> is there any way to specify cpphs options from the module ?
14:30:14 <zygoloid> sm: onoes! since when? that means my python bytecode parser is broken :(
14:30:54 <shapr> zygoloid: Are you hacking on berp?
14:31:05 <zygoloid> oh, just macros and not preprocessor directives. that's fine then :)
14:31:10 <zygoloid> shapr: nope.
14:31:31 <zygoloid> shapr: didn't even know it existed. cool :)
14:31:42 <aavogt> sm: -optl-P="..."
14:31:51 <aavogt> but you're probably not using cpphs...
14:32:13 <sm> aavogt: why ? I have LANGUAGE CPP ...
14:32:36 <shapr> Does anyone know if berp works on ghc 6.12 yet?
14:32:58 <aavogt> sm: I think it uses gcc's cpp
14:33:11 <sm> doh.. I see
14:33:18 <sm> thanks for the tip
14:33:29 * zygoloid almost felt dirty for using {- #include "OpCodes.h" -} stopCode = STOP_CODE; ...
14:34:06 <dino-> I'm still having problems with how we got from this one line to the next:
14:34:12 <dino-> 17:20 < zygoloid> dino-: that gives flip fmap (* 5) :: Num c => (c -> a) -> (a -> b) -> (c -> b)
14:34:15 <dino-> 17:21 < zygoloid> or rather :: Num c => (a -> b) -> (c -> b), where a ~ c
14:34:22 <zygoloid> yeah, the first line was just wrong.
14:34:50 <zygoloid> we have: flip fmap :: Functor f => f a -> (a -> b) -> f b.  and (* 5) :: Num c => c -> c
14:35:18 <dino-> zygoloid: mm, that's bad, because I came up with that first line on paper substituting (c -> c) for f a
14:35:53 <zygoloid> so unification gives f ~ (c ->), so: flip fmap :: Functor f => (c -> a) -> (a -> b) -> (c -> b).  and (* 5) :: Num c => c -> c
14:36:01 <dino-> Ok, so f is (c ->) and a is c ?
14:36:21 <zygoloid> then we see that a ~ c, so flip fmap :: (a -> a) -> (a -> b) -> (a -> b) with (* 5) :: a -> a
14:36:32 <sm> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/options-phases.html#cpp-string-gaps look like a workaround for this, but I can't make it work
14:36:58 <zygoloid> finally, applying flip fmap to (* 5) we get: (Num a, Functor ((->) a)) => (a -> b) -> (a -> b)
14:37:28 <zygoloid> Functor ((->) a) is satisfied by Control.Monad.Instances.
14:37:49 <zygoloid> @type flip fmap (* 5)
14:37:51 <lambdabot> forall b a. (Num a) => (a -> b) -> a -> b
14:37:52 <alexyk> dafis: Trie SLP lookup launched
14:38:08 <alexyk> (for the dcaps trie I have handy)
14:38:51 <dafis> alexyk: that took 38GB with the library instance, or do I misremember?
14:39:18 <dino-> zygoloid: ok, got it
14:41:06 <alexyk> dafis: yes, that effer
14:41:27 <alexyk> dafis: now, 5 min 20 secs vs 7 min 50 sec original
14:41:42 <alexyk> dafis: memory lower, must rerun to see again
14:41:52 <dafis> alexyk: so if the ratio on your server is about the same as o my box, we'd be at about 11GB now
14:42:14 <alexyk> dafis: exactly, I saw 11 GB before I went for that another coffee refill :)
14:43:20 <dafis> alexyk: Do you perchance know how many (Int, Double) pairs there are altogether?
14:43:28 <alexyk> "the top watchers"
14:43:42 <alexyk> dafis: easy to compute... when I'm in that Clojure repl :)
14:43:48 <sm> weird.. does use of CPP prohibit haskell multiline string literals ?
14:44:07 <dafis> sm: the other way round
14:44:20 <alexyk> dafis: gotta count explicitly, will do later
14:44:30 <alexyk> now all eyes are on the top
14:44:34 <dafis> alexyk: a rough number?
14:44:52 <sm> dafis: so I have LANGUAGE CPP, and multiline strings are giving a syntax error. Expected ?
14:44:55 <alexyk> dafis: I'd say 10 pairs per user, so 50 million or so
14:45:28 <alexyk> dafis: I also go with -A5G out of habit, gotta try different ones
14:45:35 <alexyk> 11 g reazched
14:45:35 * sm is losing ground here
14:45:42 <dafis> sm: cpp can't cope with backslash-newline, don't know why
14:45:43 <ketil> sm: string literals with backslash on end of line?
14:45:48 <sm> yes
14:45:55 <dolio> sm: Probably, although I don't know CPP that well.
14:46:00 <yairchu> sm: you can using QuasiQuotes for multiline strings and with nice syntax
14:46:02 <ketil> sm: presumably cpp joins it with the next one, no?
14:46:05 <alexyk> 14 g breached
14:46:23 <alexyk> virt goes a bit ahead ot actual, at 14.6 g
14:46:38 <sm> ketil: no, seems to not
14:46:45 <dafis> alexyk: the sample contained ~3.3 million pairs for ~140000 users, so I'd think it'll be more than 10 on average
14:46:58 * sm considers quasiquotes to string-quote this cpp macro
14:47:03 <alexyk> dafis: it may be a but more, like 90 mil edges (pairs)
14:47:21 <alexyk> dafis: done at 14 g
14:47:34 <alexyk> just a bit before the end virt jumped from 14.6 to 15 g
14:47:42 <alexyk> looks like it preallocates from OS but not uses
14:47:57 <yairchu> sm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27053#a27053
14:48:04 <dafis> alexyk: then there's still a lot of waste somewhere.
14:48:34 <alexyk> dafis: so, 14 g is much more stomachable than 38 g; the latter got me into arguments with co-users
14:48:36 <sm> yairchu: thank you
14:48:48 <dafis> alexyk: can you try with -A2G ?
14:48:50 <soupdragon> > (3:+2)*(3:+(-2)) 
14:48:51 <lambdabot>   13.0 :+ 0.0
14:48:54 <alexyk> dafis: yep
14:48:55 <yairchu> de nada :)
14:49:39 <alexyk> dafis: I also add -K1G to overlook any stack-related bugs :)
14:50:31 <dafis> alexyk: I don't think such a huge stack will actually help
14:51:03 <alexyk> dafis: should I cap at -K100m?
14:51:17 <dafis> alexyk: try it
14:51:33 <alexyk> dafis: so -A2G goes up more carefully
14:52:10 <dafis> alexyk: the question is, how far up will it go, and how fast
14:52:14 <alexyk> dafis: the SLP shows that Haskell's default serialization with Data.Binary is not a suitable general-purpose serialization
14:52:22 <ketil> sm: my cpp interprets \newline as nothing, i.e. it joins lines.  I thought that was standard - what system are you on?
14:52:32 <alexyk> dafis: which is worrysome
14:52:50 <dafis> alexyk: or it shows that yours is a very *special* purpose
14:53:19 <alexyk> dafis: c'mon, a puny [(Int,Double)] list would be the meat of any data mining
14:53:21 <handonson> i know the definition of curry, but how, in terms of code, is it defined?
14:53:34 <dafis> alexyk: but yes, it's not adequate for large Maps/Tries
14:53:38 <alexyk> ocmal serializes any giant blobs of data with Marshal.to_channel in a flash
14:53:50 <alexyk> ocaml does; Data.Binary is not on par
14:53:52 <ketil> sm: just add a space after the first backslash?
14:53:54 <alexyk> out of the box
14:54:03 <alexyk> only works when dafisized! :)
14:54:15 <dafis> alexyk: one puny list is harmless, millions of them...
14:54:17 <dino-> monoidal: Ok, now also get the for (a ->) fmap is (.)
14:54:19 <dino-> monoidal: thank you
14:54:30 <pastorn> can haskell be compiled on ARM9?
14:54:36 <alexyk> dafis: one puny list for one man, 5 million for Twitter! :)
14:54:40 <sm> ketil: I'm using ghc 6.12.3 built recently on a mac, on a module with LANGUAGE CPP. Space after the \ didn't help..
14:54:46 <pastorn> @faq can haskell compile on ARM 9?
14:54:46 <lambdabot> The answer is: Yes! Haskell can do that.
14:54:52 <pastorn> cool
14:54:57 <alexyk> dafis: looks like 11 G and 4 min 11 secs for -A2g
14:55:05 <dafis> alexyk: I don't know o'caml, does that have mutable structure?
14:55:12 <dafis> structures
14:55:21 <alexyk> dafis: it does take mutable Hashtbl
14:55:41 <alexyk> so that is unfair, of course
14:56:14 <dafis> alexyk: mutable Maps etc. can be deserialised *much* faster (and serialised faster, too)
14:56:50 <dafis> alexyk: so -A2G is faster and uses less memory, now try -A1G, -A512M
14:57:10 <alexyk> dafis: I almost wish for an unsafeLoad which will do whatever it takes and blesses the thing as a Map
14:57:41 <alexyk> gobbling up huge chunks of disk into RAM is not a place to be finicky with IO pedantries
14:58:00 <alexyk> nor mutability; everything must yield in the face of father Time
14:58:01 <dafis> alexyk: I suppose it'd be possible, but extremely fiddly
14:58:30 <sm> I give up, for now.. thanks all
14:58:44 <alexyk> sm: Haskell never gives up
14:59:45 <dafis> alexyk: build the stuff either in IO or ST, but one would still need to play with the compiler internals, I think
15:00:19 <alexyk> dafis: I can simply stick it back into Tokyo Cabinet
15:00:34 <alexyk> dafis: my cafÃ© is closing, so I'll resurface later
15:00:45 <dafis> alexyk: I don't even know what Tokyo cabinet is :)
15:00:53 <dons> dafis: nice patches.
15:01:05 <dafis> dons: thanks
15:01:06 <dons> dafis: do you have time to merge it in, or should I? 
15:01:17 <alexyk> dafis: the thing imported from some files, a binary key-value database
15:01:30 <alexyk> later...
15:02:38 <dafis> dons: I don't care, I thought you'd perhaps want to clean up a bit
15:02:46 <dons> ok. i think i can do the merge.
15:02:56 <dafis> dons: cool :)
15:04:21 <Darkovski> Let's see if I did this right
15:04:23 <Darkovski> @hoogle replicateM
15:04:23 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
15:04:24 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
15:04:52 <dons> is Peak or Residency more interesting?
15:06:04 <ddarius> "WTFM" definitely underused.
15:07:38 <dafis> dons: depends. the problem with peak is, with -Hx, it can no way be less than x, the problem with residency, it seems, when the allocation area is large and much of the data is in there, that doesn't get counted
15:07:51 <dons> yeah. that's what I thought.
15:08:08 <dons> not being less than -Hx is less useful, and missing residency is also not useful.
15:08:12 <zygoloid> gah. my LANGUAGE pragma wraps onto four lines. maybe i should just use OPTIONS_GHC -fglasgow_exts ? ;)
15:08:17 <dons> and there's no other easy portable way to get the memory footprint
15:08:29 <dons> zygoloid: you can put them on separate lines
15:08:40 <dons> or a .cabal file...
15:09:38 * djahandarie votes for .cabal file
15:09:39 <zygoloid> dons: i have a .cabal file but i'm using different extensions in each file, and want to avoid extension proliferation where i can :)
15:09:47 <dafis> dons: right, nevertheless, with suitably constrained ranges for -A and -H, there's something to learn from it, but one could see more with smaller steps
15:10:02 <djahandarie> I guess it's better to only use extensions where needed, at least the weird ones
15:10:18 <djahandarie> Maybe you should just stop using crazy extensions ;)
15:11:04 <CakeProphet> {-# LANGUAGE EnableWorldDominationMode #-}
15:11:07 <dafis> dons: I think, overall, peak is more useful
15:11:15 <zygoloid> i'm not actually using any particularly crazy ones. just Flexible{Instances,Contexts}, Type{Families,Operators}, MPTC, PatternGuards, EmptyDataDecls and so on :)
15:11:36 <zygoloid> my instances are decidable and everything! :)
15:12:08 <djahandarie> I don't see the problem with dropping any of those in the .cabal file (unless they are used in just one file or something)
15:12:45 <zygoloid> hmm, maybe not. it's not like this will ever compile on anything other than GHC anyway
15:12:53 <Lajla> So like, without usig the fact that let is secretly a let rec in Haskell, Haskell would not be turing complete, right?
15:13:02 <zygoloid> (heck, the compile process needs access to 10 ghc source trees!)
15:13:22 <Lajla> At least, all definitions of the fixedpoint in haskell I saw used the let rec.
15:13:56 <dafis> Lajla: it's plain let, just stupid languages decided to call it let rec
15:13:57 <zygoloid> Lajla: if you exclude fix etc. from the standard library, and see a top-level module 'where' as being a 'let', then that could be right
15:14:02 <monochrom> there are top-level definitions like "f = f" that don't literally say "let". do you include them or not?
15:14:31 <Lajla> dafis, I'm just making it unambiguous here, there is a difference in conventional semantics.
15:14:39 <zygoloid> there are various other ways to allow things to implicitly refer to themselves; you'd have to nuke them all too
15:14:46 <Lajla> monochrom, what you call it isn't relevant, it's about refering to a function in its own definition
15:15:00 <monoidal> Lajla: do you allow well-founded recursion?
15:15:06 <monochrom> Milner's original paper separates "let" and "let rec". :)
15:15:06 <Lajla> I'm simply meaning 'would Haskell be turing complete without refering to a function in its own definition?'
15:15:27 <monochrom> then you are right.
15:15:27 <Lajla> Indeed, there are some theoretical and practical reasons for that.
15:15:44 <Lajla> monochrom, right in that it would not be turing complete?
15:15:47 <monoidal> "its own definition" is too weak: a = b, b = a
15:15:47 <monochrom> right
15:15:51 <ddarius> monochrom: That's because the typing rule for let rec is quite a bit more complicated and actually different than the one for let.
15:16:08 <zygoloid> Lajla: presumably you mean transitively, since f x = g (h x); g x = f x is fix, with no functions referring to themselves
15:16:32 <Lajla> zygoloid, yes, of course.
15:16:49 <Lajla> zygoloid, this is a encompassed by the difference between let and let rec by the way.
15:16:58 <Lajla> let can only refer to bindings in an outer block.
15:17:12 <Lajla> in let rec, the bindings that are created by the block may shadow outer bindings.
15:17:13 <monoidal> i think you could create recursive structure using IORefs without recursion
15:17:14 <zygoloid> Lajla: indeed. but there are more ways to encode recursion in haskell than let rec.
15:17:29 <Lajla> zygoloid, how?
15:17:48 <Lajla> I was under the impression that this trick was what extended System F to turing completeness.
15:17:48 <zygoloid> Lajla: if we have access to a primitive [0..], then we're turing complete
15:17:57 <ddarius> monoidal: Of course you can.
15:18:08 <zygoloid> Lajla: if we have access to a primitive fix, then we're turing complete.
15:18:14 <monoidal> with a recursive structure & fold, there's fix
15:18:20 <Lajla> zygoloid, yes, but those are made using let rec, right?
15:18:34 <zygoloid> Lajla: not necessarily. fix could be implemented in C in the RTS
15:18:52 <Lajla> zygoloid, well, then I shall be even more explicit, using only lambda abstractions then.
15:19:00 <Lajla> But I guess you already answered my quaestion here.
15:19:57 <zygoloid> Lajla: well, the simply-typed lambda calculus is not turing complete; i don't know if that helps you
15:20:19 <Lajla> zygoloid, I know that
15:20:21 <Lajla> And neither is system F
15:20:33 <Lajla> But what I am interested in is if adding let rec to system F makes it turing complete.
15:20:44 <Lajla> Apparently CORE is just system F extended with constants, case and let (rec)
15:20:51 * monochrom invents System (let F=F in F)
15:20:55 <zygoloid> ah, now that's a question with a precise answer. and i believe the answer is yes.
15:21:02 <monoidal> data T = A (T -> T) and there's untyped lambda calculus
15:21:10 <Lajla> zygoloid, so let rec alone is enough?
15:21:40 <monochrom> turing completeness is too easy
15:21:40 <Lajla> I still do nt like your 'types' as practical thinks, but from a theoretical perspective they are quite interesting.
15:21:44 <monoidal> then, define Y without using self-reference
15:21:51 <monoidal> and you can loop
15:21:58 <zygoloid> Lajla: i believe so; i don't know of a paper with a proof, though.
15:22:02 <Lajla> monoidal, well, you can't in System F.
15:22:13 <Lajla> You can't find a type for any fixed point combinator.
15:22:19 <dolio> What's to prove?
15:22:30 <dolio> let rec fix f = f (fix f) in ...
15:22:30 <monoidal> it's "type rec" similar to "let rec"
15:23:00 <monoidal> Lajla: recursion can sneak using let rec, type rec, IO references, one single infinite value
15:23:13 <zygoloid> dolio: what's to prove is that System F isn't missing anything else you might need.
15:23:28 <monoidal> Lajla: if you forbid all those things, haskell becomes system Fc (system F + equality constraints)
15:23:28 <Lajla> System F is avery bad trance artist.
15:23:33 <dolio> Need for what? That's a general recursion combinator.
15:23:46 <Lajla> I always wondered if he got the name from the parametric lambda calculus, but I would hate to think he's as smart as we..
15:24:27 <Lajla> Well, I remember this guy on google giving a talk on google I/O
15:24:38 <Lajla> And he said 'And as you know, Haskell is itself a lambda calculus'
15:24:44 <Lajla> And I began tow onder what is 'a lambda calculus'
15:25:08 <djahandarie> And that's how you fell into the downwards doom spiral of computer science
15:25:18 <djahandarie> Touching story *tear*
15:25:23 <monochrom> that is like "what is a branch of math"
15:25:25 <Lajla> Essential elements to me seem to be call  by name (excluding lisp) and in essense having anonymous functions only (excluding ML's), so what'sleft?
15:25:40 <Lajla> Yeah, but the term is sooo vague
15:25:44 <dolio> Call-by-name has nothing to do with it.
15:25:44 <Lajla> But one years it so often.
15:25:45 <zygoloid> dolio: it's possible to have a recursion combinator but not turing completeness if you're missing a lot of other stuff ;)
15:25:53 <Lajla> dolio, I beg to differ.
15:26:03 <Lajla> The original lambda calculus was quite obviously call by name.
15:26:04 <zygoloid> for instance, if all you have is a recursion combinator and no way to apply it ;-)
15:26:12 <Lajla> The substitution rules imply it.
15:26:18 <dolio> Haskell isn't call-by-name.
15:26:18 <Philippa> yeah, but you don't have to have a lot on top of fix
15:26:26 <Lajla> dolio, it's not?
15:26:30 <dolio> Well, it needn't be.
15:26:39 <dolio> And lambda calculi needn't be, either.
15:26:43 <hpc> it can be whatever it wants; values are immutable
15:26:57 <soupdragon> Lajla, no that is not correct
15:26:58 <Philippa> hpc: not true, call by value isn't haskell
15:27:01 <zygoloid> Lajla: i'd say a lambda calculus is a system with lambda abstraction and application
15:27:18 <Philippa> a call by name haskell implementation is valid
15:27:19 <soupdragon> Lajla, beta conversion defines an equivalence relation - not operational semantics
15:27:20 <Lajla> zygoloid, yes, but a lambda application implies call by name.
15:27:25 <CakeProphet> > main = (x -> x ++ (show x)) "> main = (\\x -> x ++ (show x)) "
15:27:26 <lambdabot>   <no location info>: parse error on input `='
15:27:29 <dolio> Haskell isn't really a pure lambda calculus, either, because it has datatypes and case expressions and such.
15:27:30 <hpc> how is call by value invalid?
15:27:35 <Tomsik> call-by-name is an evaluation strategy
15:27:37 <Philippa> Lajla: no, it really, really doesn't. Plenty of cbv lambda calculi in the literature
15:27:38 <zygoloid> Lajla: why would you assume that?
15:27:38 <Lajla> hpc, it's how substition is defined
15:27:41 <CakeProphet> > (x -> x ++ (show x)) "> (\\x -> x ++ (show x)) "
15:27:42 <lambdabot>   Pattern syntax in expression context: x -> x ++ (show x)
15:27:42 <Tomsik> lambda calculus itself doesn't speak about it
15:27:53 <CakeProphet> > (\x -> x ++ (show x)) "> (\\x -> x ++ (show x)) "
15:27:54 <lambdabot>   "> (\\x -> x ++ (show x)) \"> (\\\\x -> x ++ (show x)) \""
15:27:58 <CakeProphet> ...oh my
15:28:06 <Lajla> Lambda application is defined in terms of s[t := x], which' definition clearly implies call by name.
15:28:08 <Philippa> Lajla: no, call by name isn't. Call by name is a specific reduction strategy, it's not how substitution is defined
15:28:21 <ddarius> CakeProphet: ap(++)show"ap(++)show"
15:28:25 <Philippa> hpc: call by value haskell is invalid because it's strict
15:28:30 <Tomsik> Lajla: you could reduce things under lambda abstraction
15:28:31 <soupdragon> Lajla, no it does not
15:28:31 <zygoloid> Lajla: call-by-name is an operational semantics. application-through-substition is a denotational semantics.
15:28:44 <hpc> Philippa: oh duh, i should have noticed that
15:28:49 <CakeProphet> ddarius:  is that the shortest known quine in Haskell?
15:28:54 <Lajla> I think we might be talking about different 'call by names'
15:29:04 <soupdragon> Lajla, no you're reading the rules slightly wrong
15:29:09 <zygoloid> Lajla: nothing about s[t := x] says the instances of t in s can't share a value.
15:29:10 <sproingie> > 1
15:29:11 <ddarius> CakeProphet: The shortest known quine would be 1.
15:29:12 <lambdabot>   1
15:29:13 <monochrom> perhaps you invented your own "call by name"
15:29:18 <sproingie> there's your quine
15:29:18 <Philippa> Lajla: yes, we're talking about the one that's meaningful in the context of lambda calculi
15:29:21 <Lajla> zygoloid, that has nothing to do with call by name.
15:29:30 <djahandarie> > 
15:29:31 <lambdabot>   not an expression: `'
15:29:36 <CakeProphet> ddarius:  not in an actual Haskell program. There would be no output.
15:29:37 <Lajla> Call by name means that the arguments are substituted into the function body.
15:29:40 <Philippa> monochrom: some people refer to mutable languages' call by reference as call by name
15:29:42 <Lajla> Or that this is equivalent.
15:29:50 <Philippa> Lajla: no, it doesn't. Not in the context of lambda calculi
15:29:51 <zygoloid> Lajla: you don't seem to understand what call by name means (and in particular the difference between call by name and call by need)
15:29:55 <dolio> Call-by-name is roughly 'reduce (\x -> e) m to e[x := m] first'. Call-by-value is 'reduce (\x -> e) m to (\x -> e) n if m reduces to n'
15:29:58 <Philippa> and I'd like to know where the hell it /does/ mean that
15:30:01 <ddarius> ap(++)show"ap(++)show" is a string, not an IO action.
15:30:05 <Lajla> zygoloid, call by need is a subform of call by name!
15:30:20 <Lajla> Which is purely a strategy one can use if one has referential transparency.
15:30:43 <Philippa> Lajla: no, call by name is specifically the strategy dolio's referring to in every piece of literature I have ever seen on the subject
15:30:50 <ddarius> You can use call-by-need in an impure language.
15:31:04 <dons> dafis: in the new flags model multiple graphs are generated?
15:31:05 <Lajla> Call byvalue means: reduce the arguments outside of the function body, then substitute the reductions into the body. Call by name: substitute the entire expressions into the body, then reduce them there.
15:31:09 <zygoloid> Lajla: your definitions do not match mine here. i also believe they do not match the community at large, but i'm no authority there. i think once we're past the definitions we're in agreement though.
15:31:14 <dons> dafis: how does that work in interactive mode?
15:31:23 <Lajla> zygoloid, well, we can call it what we like.
15:31:32 <Philippa> Lajla: yes, and it means /exactly/ that. CbyNeed isn't CbyName
15:31:35 <monochrom> "applicative order"
15:31:42 <Lajla> What is the relevant issue is that in lisp: arguments are evaluated outside of the functin body, with their results substituted into it.
15:31:54 <Philippa> Lajla: relevant to you, perhaps. We're not lispers
15:31:59 <soupdragon> do you know what an equivalence relation is
15:32:02 <dafis> dons: oh, didn't think of interactive.
15:32:13 <soupdragon> and why it is worthwhile to define one on lambda term
15:32:15 <Lajla> And in lambda calculus,, the arguments are placed into the function bdy, and evaluated there.
15:32:16 <soupdragon> (this is not obvious)
15:32:25 <zygoloid> we live in a happy world where call-by-name and call-by-need are denotationally equivalent
15:32:30 <Philippa> Lajla: argument, singular.
15:32:35 <Lajla> It makes a significant difference, both models in terms of terms which have n normal form, that's all.
15:32:54 <Tomsik> Lajla: you could evaluate arguments before putting them in the body
15:32:54 <Lajla> Philippa, well, that doesn't matter accordingly the church rosser theorem.
15:32:56 <Tomsik> for example
15:33:23 <Lajla> Say I have \xyz.B M N O, whether I substitute z for O in B first, or first x for M, the result is the same.
15:33:24 <Tomsik> which doesn't necessarily end, sometimes it hangs when lazy evalution works
15:33:29 <dons> dafis: i think i have to fix the interactive code to not require ^C :)    
15:33:52 <Philippa> Lajla: yes, but you're still introducing ideas that don't belong in at least most lambda calculi
15:33:55 <Tomsik> Lajla: (\x y. x) (\z.z) (theta)
15:34:07 <Philippa> (I've specified ones that do have explicit multiparameter lambdas, but there was a reason for it)
15:34:15 <Tomsik> if you evaluate argument first or last makes a difference
15:34:16 <dafis> dons: and one would need to be able to turn off flags without editing the config file
15:34:18 <monochrom> it doesn't matter what you call "a lambda calculus"
15:34:33 <Lajla> Philippa, well, the point is that the original lambda calculus was explicit about first substituting, then reducing.
15:34:36 <Mathnerd314> soupdragon: how non-obvious is your question's answer?
15:34:49 <Lajla> And lisp and many other languages do it in reverse.
15:34:51 <dolio> It was?
15:34:55 <Lajla> Which in some cases causes a significant difference.
15:35:05 <Philippa> Lajla: Citation needed, methinks
15:35:07 <Lajla> dolio, yes, in the definition of s[x := t]
15:35:10 <zygoloid> Lajla: i think you have your answer: we can't agree on what exactly "a lambda calculus" is :)
15:35:21 <ddarius> Lajla: The original lambda calculus' semantics were given using call by name, but it has been 80 years...
15:35:23 <Philippa> no, that's not explicit about it. You can carry out /any/ reduction at /any/ place according to that
15:35:24 <chrisdone> alpha conversion, beta reduction. two steps right?
15:35:31 <soupdragon> Mathnerd314: I mean to a beginner
15:35:59 <Lajla> zygoloid, well, that is my point the term 'a lambda calculus' is too vague to use in a masterclass.
15:36:01 <ddarius> Philippa: That's true.  The original lambda calculus also reduced to normal form, not head normal form.
15:36:16 <CakeProphet> HORN
15:36:53 <dafis> dons: so the type flags should become OptArgs
15:36:54 <dolio> Lajla: The difference between call-by-name and call-by-value has nothing to do with how s[x := t] is defined.
15:37:17 <ddarius> dolio: It could slightly, but usually it doesn't.
15:38:19 * Philippa wouldn't call haskell a lambda calculus, but would say it contains one if you strip away all the module functionality and perhaps IO
15:38:20 <dolio> It has to do with which redexes you choose to reduce first.
15:38:24 <dafis> dons: but I won't do anything about it before breakfast (in nine hours or so)
15:38:35 <dolio> Redices?
15:38:49 <dons> dafis: pushing your patches now
15:38:58 <dons> dafis: oh, you just want to have only one graph?
15:38:58 <monochrom> I think "redexes" is common.
15:39:10 <dons> i like multiple graphs, but need to make the interactive version work properly
15:39:14 <dons> opening them up in serial.
15:39:19 <dafis> dons: I'd want to give the choice
15:39:23 <ddarius> You could cut back on your crazy New Age lingo and say "reducible expressions."
15:39:34 <Philippa> monochrom: "redices" if you're a wanker, right?
15:40:29 <dafis> dons: for non-interactive modes, there's no problem creating as many graphs as one wants, I'm not sure about interactive
15:40:46 <monochrom> I haven't seen "redices". I haven't seen wankers either.
15:40:51 <Lajla> dolio, the defintion of s[ x:= t] clearly implies that t is substiuted into s t.
15:40:54 <Lajla> into s*
15:41:00 <Lajla> In fac,t it says nthing about first reducing t.
15:41:13 <Lajla> That's simply subject ot different rules.
15:41:16 <dafis> dons: if you can leave gnuplot without exiting the programme, you could get more than one in interactive mode, too
15:41:25 <Lajla> Repitition of same rule once inside the body.
15:41:29 <Philippa> Lajla: it's subject to the same damn rule, s and t are of the same nature
15:41:30 <dons> dafis: exactly
15:41:38 <Philippa> you can apply that rule to /any/ s
15:41:44 <dolio> Lajla: The reduction strategy isn't encoded into the substitution rule, usually. It's built on top of it.
15:41:53 <dons> dafis: anyway, just pushed your changes.
15:41:59 <Lajla> dolio, it's not a strategy.
15:42:07 <Lajla> And the difference is significant, see Curry's fixedpount
15:42:09 <monochrom> s[x:=t] is notation for substitution. "the definition of s[x:=t] says you should substitute" = "the definition of substitution says you should substitute". this is a tautology. this says nothing about reduction order.
15:42:15 <Philippa> Lajla: that's his point, it's not a strategy and it doesn't contain one
15:42:16 <Lajla> It is not significant fr forms which have a normal form.
15:42:24 <Lajla> But it is significant for terms which diverge.
15:42:32 <Philippa> monochrom: it also doesn't say you should, it says you can
15:42:32 <dafis> dons: for the time being, one could make a choice of a single graph mandatory if interactive mode is selected
15:42:42 <zygoloid> can you work around the incomplete implementation of superclass equalities with 'class Eq a b | a -> b, b -> a; instance Eq a a' ?
15:42:55 <dolio> (\x.x) ((\xy.x)yz) => (\x.x) y => y is call-by-value, (\x.x)((\xy.x)yz) => (\xy.x)yz => y is call-by-name.
15:43:00 <Lajla> Like, if you have (\x.x x) (Y f)
15:43:06 <Lajla> Where Y is curry's fixedpoint
15:43:21 <Lajla> One first reduces to (Y f) (Y f)
15:43:26 <dolio> Both use s[x := m] in their description, though.
15:43:30 <Lajla> And then one tries to reduce those two again.
15:43:33 <Philippa> Lajla: The original form of that is an inference rule, (\x.t) s |- s [x := t]. You can apply that inference rule to any lambda
15:43:38 <Lajla> THe other way around doesn't work as (Y f) diverges.
15:43:43 <Philippa> or rather, to any redex, being an applied lambda
15:43:57 <ddarius> In typical presentations of the lambda calculus substitution is a meta-operation.
15:44:42 <Tomsik> Lajla: you're merging few levels of abstraction here
15:44:44 <Philippa> exactly
15:45:03 <FunctorSalad> (and be very careful about names...)
15:45:13 <Philippa> Tomsik: there's more cheating than just that going on, as I've just pointed out
15:45:29 <FunctorSalad> if you recurse into a lambda, rename the bound variable to something fresh (and all its occurences in the body)
15:45:44 <Lajla> Not atll, it follows from the definition that (x x)[x := (Y f)] is (Y f) (Y f)
15:45:45 <FunctorSalad> probably irrelevant, just began reading here
15:46:09 <Tomsik> Lajla: (x x) being x applied to x, you mean?
15:46:12 <dafis> dons: just got the repo, will look tomorrow, now it's bedtime for me
15:46:35 <FunctorSalad> "redex" is new age lingo? thought it occured in the honorable foundational scriptures or soon after
15:46:36 <Lajla> Tomsik, I just gave the beta reduction of (\x. x x) (Y f) (Y f)
15:47:10 <Lajla> By definition, the beta reduction of the term (\x. x x) (Y f) (Y f) is (x x)[x := (Y f)], and by definition of that it's (Y f) (Y f)
15:47:17 <Tomsik> Sorry, I'm kind of fuzzy today, but what are you trying to point out with reducing (\x. x x) (Y f) (Y f)
15:47:17 <dolio> Defining beta reduction doesn't define the overall evaluation strategy.
15:47:22 <dons> dafis: looks pretty easy to modify nobench to collect stats for each program
15:47:26 <FunctorSalad> "* Philippa wouldn't call haskell a lambda calculus, but would say it contains one if you strip away all the module functionality and perhaps IO" <-- and a correct one even ;)
15:47:33 <dons> i as thinking about collecting all .dat files and computing the average...
15:47:34 <Lajla> (x x)[x := t]  where t is the beta reduction of the term (Y f)
15:47:40 <Tomsik> Lajla: no, it's ((Y f) (Y f)) (Y f)
15:47:57 <Lajla> Tomsik, ehh, whoops
15:48:00 <Philippa> FunctorSalad: really you'd need to lose the top-level definitions as well, and just work with a context containing the sorts of things that go in them
15:48:01 <dafis> dons: that would be very interesting
15:48:05 <Lajla> sorry, one extra argument added.
15:48:11 <Lajla> I meant (\x. x x) (Y f)
15:48:28 <Tomsik> Yeah, then it's (Y f) (Y f) and?
15:48:28 <dons> dafis: i think we can just cat them all together and graph the result.
15:48:36 <Tomsik> I'm not sure what's the point here
15:48:37 <Philippa> guys, go back to the inference rule. It makes it very clear that beta-reduction can be applied to any redex, assuming you know how inference rules work
15:48:45 <Lajla> Anyway, the definition of (x x)[x := (Y f)] is quite clearly (Y f) (Y f), that's impossible to deny.
15:48:50 <dons> but we'd need to normalize time somehow
15:48:54 <Lajla> Tomsik, Lisp has a different model.
15:49:00 <ddarius> Lajla: No one is denying it.
15:49:02 <Lajla> In lisp, it's (r r)
15:49:04 <Tomsik> Lisp has a bug in it
15:49:08 <Tomsik> and it's not lambda-calculus
15:49:09 <ddarius> Lajla: That is false.
15:49:15 <Lajla> Where r is the beta reduction of (Y f)
15:49:19 <Tomsik> as really they use context and not lambda terms
15:49:21 <ddarius> Lajla: In -any- lambda calculus, call
15:49:26 <Tomsik> I mean, not lambda beta-reduction
15:49:41 <ddarius> -by-name or call-by-need, s[x:=t] is the term with x replaced by t everywhere in s.
15:49:52 <Tomsik> And you just showed one way to reduce (\x. x x) (Y f) Lajla 
15:49:55 <ddarius> s/need/value/
15:50:05 <Lajla> ddarius, np
15:50:14 <Tomsik> Another way would be (\x. x x) (Y f) -> (\x. x x) (f (Y f))
15:50:15 <Lajla> Call by value is is replacing it with the reduction of t
15:50:17 <ddarius> The difference between call-by-name and call-by-value is the applicability of the -beta rule-.
15:50:19 <Philippa> ddarius: right, it's just that in call-by-value ones t might be v for a value, being a different syntactic category, instead
15:50:21 <ddarius> Lajla: False.
15:50:22 <Lajla> THat's the difference
15:50:27 <ddarius> Lajla: False.
15:50:34 <Lajla> ddarius, what?
15:50:53 <Lajla> You deny that in call by value, the arguments are first reduced outside of the function body, and then the result is substituted into it?
15:50:57 <FunctorSalad> Philippa: toplevels are kinda different from bound variables indeed, since their name *is* substantial
15:50:59 <dafis> dons: choose a sensible anchor, something like -A1M -H64M and divide all times by that (or if there are things with large memory requirements, -H256M or so
15:51:14 <ddarius> Lajla: The difference is (\x.E) M where M is reducible is -not- a redex in CbV and -is- a redex in CbN.  It never even gets to the E[x:=M] part.
15:51:17 <Philippa> Lajla: the beta rule is the thing I quoted above. (\x.t) s |- s [x:=t
15:51:18 <Philippa> ]
15:51:19 <FunctorSalad> but that seems to be a practical matter
15:51:32 <Philippa> it's emphatically /not/ just s [x:=t]
15:51:43 <Lajla> ddarius, that's what I'm saying.
15:51:47 <Philippa> in missing out the first half, you miss out the criteria for applying it, which are simple: any redex will do
15:51:53 <ddarius> Lajla: No, that is not what you are saying.
15:51:54 <Lajla> It makes a significant difference where your argument does not have a normal form.
15:51:57 <FunctorSalad> (I guess you could re-lambda-calculus-ify it by rewriting a module to (\top1 top2 top3 -> ....) (def_top1) (def_top2) ...
15:52:03 <FunctorSalad> add fix if needed
15:52:16 <Philippa> Lajla: we're haskellers, we /know/ what the practical difference between cbn and cbv is, you don't need to patronise us on that front
15:52:19 <FunctorSalad> hmm wait, there'd be nothing left for the body ;)
15:52:52 <FunctorSalad> I guess a module just isn't an expression; the left "...." remains unspecified
15:53:02 <FunctorSalad> (it gives a context for specifying one)
15:53:22 <aavogt> @type LamE
15:53:23 <lambdabot> Not in scope: data constructor `LamE'
15:53:40 <Lajla> Philippa, I'm quite skeptical if you claim that lambda calculus does can use call by value.
15:53:42 <ddarius> Lajla: What you are saying is essentially that s[x:=M] is -defined- in CbV to "reduce M first".  That is not what happens.  s[x:=M] is not syntax of lambda calculus (it is part of the meta-notation) and so there are -no- rules to allow it to be reduced.
15:53:55 <Lajla> I mean, it's a common hazzle that many fixed point operators do not work in call by value, but do in call by need.
15:54:10 <Tomsik> Lajla: haskell doesn't guarantee any specific strategy really
15:54:14 <ddarius> There are explicit substitution calculi where s[x:=M] -is- an actual term of the language.
15:54:20 <Philippa> Lajla: the notion of "lambda calculus" using call-by-value is bullshit. It's legitimate to use call-by-value as your reduction strategy in performing a sequence of beta reductions in a lambda calculus unless it takes measures to specify otherwise
15:54:24 <Tomsik> it does very mysterious things about order of computation
15:54:24 <ddarius> But they are far from the norm.
15:54:31 <Tomsik> because of optimizations
15:54:32 <Lajla> Tomsik, that's possible, because haskell can't make a fixed point cominbator from lambd aterms.
15:54:51 <FunctorSalad> Philippa: but I was just alluding to how nice it is to have a real lambda calculus with unconditional alpha-equivalence ;)
15:54:53 <Philippa> "lambda calculus" doesn't use the reduction strategy, the entity calculating with the calculus does
15:54:57 <ddarius> Lajla: That's irrelevant.  It doesn't matter whether fix is a primitive or not.
15:54:59 <FunctorSalad> compared to more textual schemes
15:55:00 <Lajla> Philippa, how you 'do it' makes no difference, but the definition of s[x : = t] simply implies call by nam,e.
15:55:13 <Philippa> Lajla: no, it doesn't, it doesn't care what t is
15:55:17 <Lajla> And in many cases, call by name and call by value do yield the same result.
15:55:26 <Lajla> Philippa, that's true.
15:55:29 <Philippa> t is /any/ expression, including one you've already reduced
15:55:31 <Tomsik> Lajla: it's haskell vs ocaml really
15:55:37 <Lajla> But in lambda applications, t is the argument.
15:55:43 <Tomsik> write a few things in these languages and you'll see the difference
15:55:55 <Lajla> In \x. x x (Y f)
15:56:02 <Lajla> the term t is (Y f)
15:56:11 <FunctorSalad> elisp gives a funny result for the usual example why you need to avoid capture... but it's not the naive mistaken result either
15:56:12 <FunctorSalad> =)
15:56:18 <Lajla> And indeed, if you reduce (Y f) first it won't work.
15:56:21 <ster> Lajla: s[x:=t] is just a short-hand we use for the term s with every occurrence of x replaced by t
15:56:22 <Lajla> Because (Y f) has no normal form.
15:56:26 <Philippa> the rule is that for any s, any t and any x, anywhere you see the term (\x.t) s, you can replace it with s[x:=t]
15:56:36 <Lajla> Philippa, yes.
15:56:41 <Lajla> But what if s is not a normal form itself?
15:56:46 <Lajla> What if s is a term that can be reduced?
15:56:47 <ddarius> Lajla: But s[x:=t] isn't limited to just the results of beta reduction.  You can write wherever you like.  Not that (x + x)[x:=2] is -equal- to 2 + 2 but (\x.x+x)2 is -not- equal to 2+2, it only reduces to 2+2.
15:57:00 <ddarius> s/Not that/Note that/
15:57:07 <Philippa> Lajla: do you see a rule saying you can't attempt to reduce it?
15:57:11 <FunctorSalad> what exactly is the topic of that thread?
15:57:13 <Lajla> ddarius, yes, but when beta reduction is defined in terms of s[x := t] it follows that it uses call by name.
15:57:22 <FunctorSalad> meaning of foo[x:=2] notation?
15:57:26 <Philippa> ddarius: let me carry on here, we're almost done
15:57:27 <Tomsik> Lajla: you can reduce _inside_ a term
15:57:28 <Tomsik> like
15:57:31 <ddarius> Lajla: No it does not.  Call-by-value beta reduction is defined exactly the same way.
15:57:43 <Tomsik> (\x. (\y.y) M) Z
15:57:44 <ddarius> Lajla: In fact, tell me the rule for CbV beta reduction.
15:57:45 <Tomsik> like
15:57:51 <Tomsik> -> (\x. M) Z
15:57:56 <Lajla> Philippa, no, but lambda calculus is quite clear that the beta reduction of (\x . x x) (Y f) is (Y f) (Y f) 
15:58:14 <Philippa> Lajla: yes, it is. But you don't have to reduce in that order
15:58:21 <Philippa> nevertheless, you /can/
15:58:28 <Lajla> Philippa, and in this case, you must.
15:58:32 <Lajla> In most cases it makes no difference.
15:58:37 <Philippa> no, Y f is also reducible
15:58:37 <Lajla> Assuming your arguments have normal forms.
15:58:39 <Lajla> But if they do not.
15:58:45 <Lajla> Philippa, yes, and it diverges.
15:58:46 <Tomsik> Lajla: in LOTS of cases it makes a difference
15:58:47 <Lajla> It has no normal form.
15:58:48 <Philippa> yes, so?
15:58:52 <Tomsik> Lajla: infinite lists, really
15:58:54 <Philippa> again, where's the rule saying you can't?
15:59:06 <ster> (\x. x x) (Y f) also reduces to (\x. x x) (f (Y f))
15:59:09 <Lajla> Philippa, there is no rule saying you can or you can't.
15:59:13 <Philippa> also: it doesn't diverge. The process of repeatedly reducing inside it does
15:59:21 <Lajla> It simply says that the beta reduction is defined as (Y f) (Y f) 
15:59:23 <Philippa> no single reduction can diverge
15:59:40 <Lajla> There's also no rule that says 'You can't replace it with the string "Cows dream of George Bush"
15:59:46 <Tomsik> Lajla: beta reduction of (\x.x x) (Y f) in this particular redex is
15:59:49 <Philippa> Lajla: no, but there's no rule allowing you to
15:59:52 <ddarius> Lajla: Can you tell me the rule for call-by-value beta reduction?
15:59:56 <Philippa> whereas there is one allowing you to reduce
15:59:58 <Tomsik> but you can have many more redexes
16:00:20 <Philippa> guys, can I please tackle this one alone? We're on the right track here, it'll waste time if Lajla's responding to you too
16:00:32 <Tomsik> Okay
16:00:39 <Lajla> Philippa, I understand your point that it doesn't diverge after a single term
16:00:39 <Tomsik> Godspeed pilot.
16:00:57 <Philippa> Lajla: do you understand that the beta reduction rule applies to any redex, and doesn't say anything about divergence?
16:00:57 <Lajla> And you reasoning that you could after N reductions of (Y f) just substitute it.
16:01:15 <Lajla> Like, first reduce (Y f) 282 times, then substitute the result of that, rigt?
16:01:22 <Philippa> yes, I could
16:01:41 <Philippa> any redex is, by definition, reducible if I choose to
16:02:02 <Lajla> And that's all fine and that would work, but I'm not talking about 'what next step to take'
16:02:13 <Philippa> if I choose to sit there forever reducing, that's my perogative. The only thing preventing me from doing that is adopting a reduction strategy - a choice of reductions - that doesn't diverge unless it has to
16:02:30 <Lajla> I'm talking about the fact that the reduction of the term (\x . x x)(Y f) is simply defined as (Y f)(Y f)
16:03:00 <Philippa> the reduction strategy is not in the rule for reduction. If I have (\x.(\y.a)b) ((\z.c) d), I have three reductions I can carry out
16:03:02 <hpc> :t (fix f) (fix f)
16:03:03 <lambdabot> forall t a. (Show (a -> t), SimpleReflect.FromExpr (a -> t), Show a, SimpleReflect.FromExpr a) => t
16:03:16 <Philippa> Lajla: yes, but that is not the only reduction I can carry out on that term
16:03:27 <Philippa> I can /pick and choose which term to reduce/ within a larger term
16:03:27 <Lajla> Philippa, yes, I concede that.
16:03:39 <Lajla> But we were talkinga bout the fact wether reductions follow a call by name model or not.
16:04:04 <Philippa> no, an individual reduction cannot follow a call by name model. Call by name is a model for which reduction you carry out
16:04:14 <Philippa> if you believe otherwise, it is because the literature you have read is misleading
16:04:19 <Lajla> Okay, let's just take that as a definition, I
16:04:22 <Lajla> 'm fine with that.
16:04:22 <Philippa> call by name /is a reduction strategy/, no more, no less
16:04:24 <Lajla> Names are irrelevant.
16:04:49 <Philippa> what you've been told is an informal description thereof, which suffices for lisp but not for talking about the lambda calculus formally
16:05:20 <Lajla> The point is that lisp and many other languages explicitly define reduction or 'function application' as substituting the reductions of the arguments, not the arguments.
16:05:53 <Lajla> As you would put it, they do define a direction, where lambda calculus does not.
16:05:55 <Philippa> yes, they adopt a call by value strategy
16:06:10 <Philippa> yes, lambda calculus does not in itself define a strategy. Therefore it isn't call by name either
16:06:29 <Lajla> Philippa, no, I'mtalking about that once you've decide you're going for the larger beta reduction, it is call by name.
16:06:34 <Lajla> I said 'beta reductions are call by name'
16:06:36 <Philippa> Haskell, incidentally, only requires that the reduction strategy terminate if termination is possible
16:06:39 <Lajla> I never said you had to start with beta reudciotns.
16:06:41 <Philippa> and I'm telling you that's a misuse of call by name
16:06:50 <Lajla> That could be.
16:06:52 <Philippa> call by name refers to a reduction strategy
16:07:06 <Philippa> that is, a means of picking which reduction to perform amongst the possible reductions
16:07:32 <PetRat> trying to use debugger -- on doing :print <some identifier> I get "Top level: not in scope". I guess it's not a top-level ident, but is there a way I can inspect it? It is defined on the line where I set a breakpoint.
16:07:36 <Philippa> in the context of the lambda calculus, that has /always/ been what call by name means
16:07:43 <Lajla> Philippa, that's fine by me, call it as you like.
16:07:53 <Lajla> My essential point is that lisp's model is fundamentally different.
16:07:53 <Philippa> right, someone who knows the ghci debugger better than I help PetRat out :-)
16:08:12 <Philippa> Lajla: yes, and we knew that. We're haskellers, we have to explain that difference every time we explain the language
16:08:26 <PetRat> Philippa: yes help would be good :)
16:08:36 <Philippa> Lajla: that said, there is such a thing as a call by value lisp. Not commonly used, but they exist
16:08:48 <Lajla> Philippa, you mean by name, right?
16:08:54 <Philippa> oops, yes, thinko :-)
16:09:17 <Lajla> Philippa, anyway, I don't care how it's called, I'm concerned with the existence of nonisomorphism.
16:09:25 <Lajla> Philippa, I'm coding one at the moment. =P
16:09:28 <sproingie> nosuchmorphism
16:09:28 <Lajla> A call by value lisp.
16:09:34 <Philippa> (strictly speaking a call by name lisp'd have to be defined with a mapping from multi-lambdas to single lambdas, but normal order'll do)
16:09:36 <ddarius> Lajla: "Non-isomorphism" between what?
16:09:53 <Lajla> I think Scheme originally had call-by-name, but they droped it at some point
16:09:57 <Veinor> @pl \f -> f f
16:09:57 <lambdabot> join id
16:10:01 <ddarius> Lajla: It did not.
16:10:04 <Philippa> Lajla: okay, fine, congratulations. You just wasted a large amount of chan time insisting your incorrect terminology was right against repeated explanation to the contrary from the chan though, so please try not to do that in future
16:10:06 <hpc> @src join
16:10:06 <lambdabot> join x =  x >>= id
16:10:15 <Lajla> Philippa, I never did that.
16:10:19 <Lajla> I mnever asserted any terminology.
16:10:22 <Lajla> I clarified my terms.
16:10:27 <Lajla> I defined my definition of 'call by name'
16:10:28 <Lajla> That suffices.
16:10:34 <Lajla> I could have called it 'targ' because I defined it.
16:10:40 <Veinor> aw man, I can't do \x -> x x :(
16:10:48 <Philippa> Lajla: that may have been your intention, but it wasn't what you communicated
16:11:13 <Lajla> I clarified explicitly that by 'call by name' I meant that (\x . x x) (Y f) >> (Y f) (Y f)
16:11:45 <Lajla> Philippa, well, I clarified my terms, I could use the term 'atomic bomb' and say 'for the purposes of this debate, atomic bomb means 'republican sex scandal'
16:11:45 <Philippa> no, you clarified that /it means that/, not that you are using it to mean that regardless of what call by name means normally
16:11:57 <Lajla> Philippa, there is no difference.
16:12:04 <Lajla> Terms are subject to how you define them.
16:12:12 <Lajla> They have inhaerent objective meaning.
16:12:32 <Lajla> If I say 'cow means small nuclear device' then for the remainder of the debate it does so.
16:12:57 <Lajla> Definitions can't be right or wrong, they're shortcuts because spelling out their axioms out large the entire time gets cumbersome.
16:13:26 <Lajla> I said from the start that I didn't care how it was called, I offered to call it 'targ' and 'blarg' or anything.
16:13:31 * sproingie launches a tactical cow at Lajla
16:13:36 <Philippa> no, you didn't. I just went back to read the start
16:13:38 <ddarius> Lajla: If you say "cow means small nuclear device" therefore McDonald's sells cooked small nuclear devices, that would not be valid.
16:13:54 <Lajla> ddarius, indeed it would not.
16:13:54 <Philippa> nor actually is the statement as commonly read in English true
16:13:57 <sproingie> i knew those things were bad for you
16:14:01 <Lajla> Because in our definition of cow, McDonalds does not sell them.
16:14:05 <Philippa> cow does not, in the general case, mean "small nuclear device"
16:14:26 <sproingie> if I define black as white, I am merely wrong
16:14:30 <ster> If a young child says "2 + 2 = 5" do you attempt to correct them or assume they are making a definition?
16:14:45 <Lajla> Philippa, that is irrelevant, I gave it that definition there. I'm fine with people assuming implicitly the 'standard' definition where not specified, but my own shadows it when I do.
16:14:49 <Philippa> indeed the whole point is so that "x means y" statements /can/ be argued about and clarified
16:14:57 <Lajla> ster, that people attempt to correct is what is wrong with them.
16:15:01 <Philippa> Lajla: you did no such thing. I went back and read it. Go away.
16:15:09 <Lajla> ster, and of course, the child shall have to accept from then on that 5 + 2 = 6
16:15:11 * sproingie defines Lajla as wrong
16:15:15 <Philippa> and take some damn responsibility for your actions
16:15:23 <Lajla> sproingie, you can do that, but by your definition then I am no longer Lajla.
16:16:11 <handonson> ster: that was rude. rhetorically it is a way of saying that Lajla is as dumb as young children saying "2 + 2 = 5"
16:16:21 <PetRat> trying to use debugger -- on doing :print <some identifier> I get "Top level: not in scope". I guess it's not a top-level ident, but is there a way I can inspect it? It is defined on the line where I set a breakpoint.
16:17:00 <handonson> PetRat: i heard scion supports that.
16:17:04 <Philippa> PetRat: you need to step inside that binding, I suspect
16:17:05 <Lajla> Philippa, "Call by value is is replacing it with the reduction of t"
16:17:09 <Lajla> I said that.
16:17:09 <sproingie> man i have two steaks in the fridge i gotta cook.  no one tell the IAEA.
16:17:23 <ster> well, my only intention is to demonstrate that Lajla's position is not univerally defensible
16:17:26 <Philippa> Lajla: that does not mean "for the purpose of discussion, call by value is..."
16:17:32 <Lajla> You at that point should have said 'Your definition of call by value is nonstandard, use another word' which was fine by me, or accepted it from then on.
16:17:36 <Igloo> This discussion sounds off-topic
16:17:46 <Lajla> ster, well, it is.
16:17:46 <sproingie> "for this discussion, assume everything i say is correct because i said so"
16:17:48 <Philippa> Lajla: we were telling you that it wasn't standard by telling you it doesn't mean that
16:17:52 <Lajla> If we define 2 + 2 = 5, we can
16:17:57 <Lajla> we just have to accept the consequences.
16:18:02 <Lajla> Like that 5 + 2 = 6
16:18:06 <Lajla> And that S(3) = 5
16:18:13 <Lajla> And that the old 5 no longer equals 5.
16:18:15 <Philippa> yes, but you have to state you're doing it as a definition. English doesn't work the way you're using it.
16:18:29 <sproingie> this is all kind of amusing
16:18:32 <Lajla> Philippa, and I said very early on already 'call it what you like, that'snot relevant'
16:18:40 <Philippa> and we told you it was for our purposes
16:18:46 <ddarius> sproingie: Yes, it's a great way to win an argument.
16:19:00 <Philippa> you were also /still/ wrong about it being a consequence of the reduction rule, incidentally
16:19:09 <ster> but, sadly the real world is not so idealised and humans need some prompts to know whether you are making a definition or asserting a fact about a predefined object
16:19:18 <McManiaC> is there a good tutorial/paper on template haskell?
16:19:19 <Lajla> Philippa, and it still does not make a difference to my original argument that Lisp has a fundamentally different processof evaluation than lambda calculus.
16:19:22 <Lajla> Philippa, in what waty?
16:19:24 <sproingie> ddarius: i define "argument" as "situation where i am always right".  except i think my girlfriend already owns that definition
16:19:33 <aavogt> @wiki template haskell
16:19:33 <lambdabot> http://www.haskell.org/haskellwiki/template_haskell
16:19:36 <Lajla> Call by name, as in, my definition and use of the concept was prettyy much defined as the way reduction is done.
16:19:43 <sproingie> yes, and it's wrong
16:19:47 <ddarius> ster: That's not specific to humans.  Programs need to kno whether you are making a definition or checking an equality, hence = and ==.
16:19:52 <sproingie> call by name is purple monkey dishwasher
16:19:53 <Lajla> sproingie, you can do that, it just means that when you're wrong, you're not having an arugment any more.
16:19:54 <aavogt> McManiaC: this page links good stuff: http://www.haskell.org/haskellwiki/Template_Haskell
16:20:04 <Lajla> You can redefine all you want, you just have to accept the implications of it.
16:20:04 <Philippa> Lajla: okay, fine. But your idea of call by name is, well, almost irrelevant because there's no other form of call possible
16:20:05 <sproingie> therefore all of you are talking nonsense
16:20:08 <sproingie> because you are all using my term
16:20:19 <Philippa> Lajla: which is to say, practically nonsensical. It's a plain bad definition
16:20:20 <ster> ddarius: yes indeed!
16:20:27 <Lajla> Philippa, well, lisp has a different one.
16:20:35 <Lajla> We can call it  'nondeterminstic' that's fine by me.
16:20:43 <Philippa> in the meantime, it was /not/ the notion of call by name given in the context, and you took a while to back out of that statement
16:20:44 <Lajla> Note that I also said that it wasn't an 'evaluation strategy'
16:20:52 <Lajla> With call by name I didn't mean a strategy.
16:21:06 <Lajla> I meant replacing the bound paramatres with the arguments, not their reduction
16:21:12 <sproingie> assuming "nondeterministic" has another special magical private definition, yes
16:21:12 <Lajla> I said explicitly that it was not a strategy.
16:21:26 <Lajla> You could've known that I meant a different thing with my use thereof.
16:21:29 <sproingie> it also means kumquat or euphonium
16:21:35 <Lajla> You're debating 'my definition is more right than yours!'
16:21:50 <Philippa> yes, but in the context it /is/. Welcome to human interaction
16:22:17 <Philippa> you're in #haskell, the default meaning of terminology is more likely to come from the lambda calculus tradition than the lisp tradition
16:22:21 <elspru> hey, I'm trying to output binary text, 0xFF but it comes out c3 bf
16:22:29 <Philippa> the lisp tradition is often mauled variants of the lambda calculus one too
16:22:39 <elspru> I'm using a simple String
16:22:42 <Lajla> Philippa, that is a naturalistic fallacy.
16:22:49 <Lajla> That people do it needn't make it 'right'
16:22:57 <Philippa> Lajla: no, it's a statement of how interaction in this channel works
16:23:00 <Lajla> You know that formally I am correct, I defined my terms and used them accordinly.
16:23:08 <Lajla> Philippa, then it is not an argument
16:23:11 <Philippa> formally what you did doesn't exist
16:23:13 <Lajla> But simply an unconnected observation
16:23:14 <sproingie> i do know you're basically a pain in the ass
16:23:51 <elspru> > putStrLn (chr(0xFF):[])
16:23:52 <lambdabot>   <IO ()>
16:24:03 <elspru> > putStrLn show (chr(0xFF):[])
16:24:04 <lambdabot>   Couldn't match expected type `GHC.Base.String'
16:24:04 <lambdabot>         against inferred typ...
16:24:06 <sproingie> neat we have IO.  kinda.
16:24:08 <elspru> > putStrLn $ show (chr(0xFF):[])
16:24:09 <lambdabot>   <IO ()>
16:24:10 <Philippa> Lajla: no shit, except that it's not unconnected. And I'm telling you not to waste the channel's time again in that manner. The chan's reaction was entirely predictable from your behaviour, and it will react in the same way again if you behave the same way again. So don't.
16:24:16 <elspru> > putStrLn $ show (chr(0x20):[])
16:24:18 <lambdabot>   <IO ()>
16:24:21 <elspru> > putStrLn $ show (chr(0x30):[])
16:24:22 <lambdabot>   <IO ()>
16:24:23 <sproingie> elspru: not gonna get much out of \bot as IO goes
16:24:24 <elspru> hmmm
16:24:38 <Lajla> Philippa, that is all completely tangent to if I'm right or not.
16:24:45 <mtnviewmark> are you just trying to push funny octets to all our IRC clients?
16:24:45 <aavogt> > text $ show (chr(0x30):[])
16:24:46 <lambdabot>   "0"
16:24:47 <elspru> okay, well any ideas on how to get it to print the string to file literally?
16:24:59 <Philippa> and if you're right or not is completely at tangent to whether you're considered too disruptive to remain here. Understood?
16:24:59 <mtnviewmark> try "\xFF"
16:24:59 <mwotton> Lajla: is it important to you to be seen to be right?
16:25:02 <elspru> instead of converting 0xFF into 0xc3 0xbf
16:25:05 <mtnviewmark> > "\xFF"
16:25:06 <lambdabot>   "\255"
16:25:10 <mtnviewmark> d'oh!
16:25:11 <aavogt> @type showIntAtBase
16:25:12 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:25:13 <ddarius> elspru: Set the mode to binary for reading and writing.
16:25:21 <elspru> ddarius: how ?
16:25:25 <Lajla> mwotton, not at all, it is important to me that people don't make logical falalcies.
16:25:28 <Lajla> Philippa, that is true
16:25:31 <aavogt> @type showsHex
16:25:32 <lambdabot> Not in scope: `showsHex'
16:25:35 <aavogt> @type showHex
16:25:35 <lambdabot> forall a. (Integral a) => a -> String -> String
16:25:41 <Philippa> Lajla: thank you. Now stop wasting time
16:25:47 <Lajla> But that is all irrelevant ot the point I was making, and the fallacy is yours, not mine, though 'praedictable'.
16:25:50 <aavogt> > showHex 0xFF ""
16:25:51 <lambdabot>   "ff"
16:25:58 <sproingie> Lajla: actually i think it's important to you that people pay attention.  i can relate, but i do it by being a clown, not a twit
16:26:01 <Lajla> Philippa, stop putting blame on me for your own inability at formal thought.
16:26:04 <Philippa> PetRat: did you get anywhere?
16:26:19 <Philippa> Lajla: you are now trolling. Stop or get kicked.
16:26:30 <ddarius> elspru: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#21
16:27:00 <Lajla> You made an error formally, I did not, I clarified my terms and used them as I defined them without logical fallacies, I said _explicitly_ a lot of times 'call it what you like that's not my concern', what you are effectively saying is 'it is praedicable that people cannot read', to which I would concede.
16:27:13 --- mode: ChanServ set +o Philippa
16:27:17 <handonson> Lajla: you're wrong.
16:27:18 <Philippa> this is your last warning. Stop.
16:27:19 <sproingie> some people you just can't reach
16:30:40 <Philippa> Being formally correct in a statement that nobody else interpreted the way you do is not an acceptable excuse for wasting time by failing to /sufficiently/ clarify your interpretation and then trying to pick a fight about it. Everyone else, carry on.
16:31:07 <dons> hmm. 
16:31:18 <Philippa> dons: I'll de-op here, over to you
16:31:23 --- mode: Philippa set -o Philippa
16:31:38 <PetRat> handonson: is there a way to get ghci to do it or a hack to work around it?
16:32:10 <PetRat> Philippa: I don't know what you mean by step inside the binding. I set a breakpoint at the line where it is defined (inside a 'where' clause)
16:32:29 <handonson> PetRat: I am not a ghci expert at all, but i heard it is sadly impossible for now, which is quite frustrating for me as well
16:32:48 <Philippa> PetRat: get it to carry out a single reduction
16:33:06 <PetRat> Philippa: does that mean use :force?
16:33:33 <elspru> ddarius: I'm not really sure how to use  what you've given me. right now I'm using writeFile
16:33:41 <Philippa> no, that carries out more than one :-) Gimme a mo to RTFM and I'll hopefully find something?
16:33:42 <elspru> I'm not sure what the binary file analog would be
16:34:22 <ddarius> elspru: You will have to explicitly open the file.
16:34:50 <Philippa> "Where identifier names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place." <- this is why it's behaving like this, no pattern match yet
16:35:12 <Philippa> you can set a breakpoint by line and column to the first char on the RHS of the =, that'd do it
16:35:50 <Philippa> you can only :step to breakpoints, so define one and :step looks like it
16:36:38 <handonson> interesting. let me try too.
16:36:50 <Philippa> RTFMing FTW :-)
16:37:08 <ddarius> Who would have ever thought the answer would be there?
16:37:21 <Lajla> Philippa, take it to pm, please, I beg you.
16:37:45 <Philippa> Lajla: take what, helping someone out with their problem in chan? No, that's what the chan is for
16:38:29 <g_cross> Hey everyone!  I've got a question to toss out.  Is it possible to implement "goto" using the continuation monad?
16:38:38 <ddarius> g_cross: More or less, yes.
16:38:38 <handonson> wow.
16:38:42 <g_cross> So
16:38:55 <handonson> that's one mind-blowing question
16:38:57 <g_cross> I can see how to implement "return", as in terminate and return up the stack
16:38:59 <Lajla> Philippa, the rest of the discussion, you ended so nicely with this sentence "Lajla: thank you. Now stop wasting time", which has no logical form and thus cannot contain a fallacy, then you start another sentence again which does have a logical form triggering my compulsion to note it.
16:39:21 <g_cross> But not how to embed a "goto" inside some nested statement that can jump to a different monad.
16:39:46 <PetRat> Philippa: thanks will try
16:39:47 <Philippa> Lajla: if you want to continue /that/, it stays out of chan
16:40:04 <g_cross> Like:  when (condition) $ goto A
16:40:09 <elspru> ddarius: so how do I write to it now?
16:40:18 <g_cross> which then jumps control to some monad named A
16:40:21 <elspru> I did openBinaryFile (file++".compiled") WriteMode
16:40:34 <lispy> Lajla: Please take this to some off topic place like #haskell-blah.  This channel is for haskell related discussions
16:40:42 <PetRat> Philippa: oops I edited my code some and it doesn't currently compile... it'll take me 30 minutes to get to this. But super thanks. I am new to Haskell and even when I RTFM I don't understand all of it.
16:41:02 <mwotton> g_cross: hm. does it really make sense to talk about jumping to a monad?
16:41:25 <g_cross> I'm not experienced with IRC... is it possible to paste in a snippet of multi-line code?
16:41:33 <mwotton> if you've nested State monads, how would you know which one you wanted to jump to?
16:41:39 <handonson> g_cross: http://hpaste.org
16:41:49 <PetRat> The great thing about the Haskell community is the help available to beginners. I enjoy learning Haskell very much, and having that help is a HUGE part of it. I think I would have given up without it.
16:42:03 <g_cross> yay!  Thanks, I'll write up a little example to show what I mean.
16:42:03 <handonson> g_cross: paste the code there, and paste the generated URL here.
16:42:04 <monoidal> g_cross: post on hpaste and link here, don't do multiline
16:42:30 <elspru> ddarius: I tried hPutStr handle text
16:42:33 <elspru> but it ends up blank
16:42:37 <elspru> blank file
16:43:04 <monoidal> elspru, do you do hClose handle?
16:43:09 <monoidal> (i'm not sure if it's needed)
16:43:50 <monoidal> oh, nvmd
16:43:59 <elspru> oh yes thanks :)
16:44:01 <elspru> now it works
16:44:10 * elspru is pleased
16:44:15 <g_cross> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27060#a27060
16:44:21 <ddarius> It needed to be flushed.  hClose flushes the handle.
16:44:33 <g_cross> So the idea is that the goto causes the rest of the statements in the do to be skipped.
16:44:50 <g_cross> This is not quite the same as the Abort monad, because it doesn't break to the callee
16:45:28 <mtnviewmark> g_cross - you are willing to have x and y be in some new monad for this purpose? if so, seems easy enough
16:45:50 <g_cross> No, that's the easy part
16:45:55 <g_cross> I can create a new monad;  in fact, I already have.
16:46:39 <g_cross> I use a trampoline, so that runGotoT runs the monad, and the "goto" causes the rest of the monad to be skipped and it to return a special value that tells runGotoT to run the included monad rather than returning a value
16:46:51 <g_cross> what I am wondering is if this can be done inside the continuation monad, rather than creating a new monad
16:46:59 <ddarius> s/monad/monadic value/
16:47:02 <g_cross> I am having trouble seeing how this could be done
16:47:15 <g_cross> ddarius, could you explain how I am mis-using the terminology?
16:47:19 <AnAdorableNick> ddarius: What do you onsider a "monad"?
16:47:23 <Twey> A monad is a type.
16:47:26 <hpc> that sounds sort of like Either a a
16:47:27 <g_cross> oh, I see
16:47:33 <handonson> elspru: Just for your information - avoid using "open*" and "close*" family when you can use "with*". the problem you've just encountered is the reason for that.
16:47:33 <ddarius> AnAdorableNick, g_cross: A monad is a functor, a type constructor in Haskell.
16:47:40 <g_cross> Yes, so GotoT = Either (GotoT a) a
16:48:12 <g_cross> Okay, so yes I meant monadic value I suppose.
16:48:29 <g_cross> newtype GotoT r m a = GotoT { unwrapGotoT :: m (Either (GotoT r m r) a) }
16:48:40 <g_cross> runGotoT (GotoT m) = m >>= either runGotoT return
16:49:01 <g_cross> So this is what I currently have been using, but I was wondering if it was possible to get the same functionality using ContT
16:49:34 <g_cross> Based on the vague notion that any flow control can be implemented using continuations, and therefore ContT should in theory be able to do this even though I can't see how  :-)
16:49:55 <g_cross> Oh, and
16:50:02 <g_cross> goto = GotoT . return . Left
16:50:39 <ddarius> g_cross: Your "Goto" monad is just an exception monad.  It is straight forward to model exceptions with continuations.
16:51:07 <monoidal> it looks like partiality monad for me
16:51:26 <ddarius> monoidal: The partiality monad is a degenerate exception monad.
16:51:33 <g_cross> It isn't the exception monad because the Left type inside the either refers recursively to the GotoT type
16:51:46 <g_cross> Oops, let me rephrase that
16:51:51 <ddarius> g_cross: That doesn't make it not an exception monad.
16:51:54 <g_cross> The monad instance does indeed look like the exception monad.
16:52:02 <monoidal> ddarius: by partiality I mean Now a | Later (Partial a), by exception monad Either e
16:52:35 <g_cross> However, the only way I can see how to implement the "goto" functionality is using the trampoline that you see in runGotoT
16:52:56 <ddarius> monoidal: I think you want "Resumptions" or "Pause" or something.  Usually "partiality" (in this context) means "not totally defined" and can be modelled with a Maybe monad.
16:52:58 <g_cross> So the functionality comes not from the monad, in a sense, but how the monadic value is unwrapped by runGotoT
16:53:51 <ddarius> g_cross: Why is that a problem?
16:53:56 <g_cross> It isn't  :-)
16:54:00 <monoidal> it's the choice of terminology. I always think about nonterminating functions - uustalu's monad, and it allows unamb to be defined purely
16:54:04 <g_cross> I'm just curious if it could be implemented using ContT
16:54:21 <ddarius> g_cross: It can, but it won't be very different from what you have.
16:54:45 <monoidal> if 'partiality' means error like division by 0, then Maybe can be called partiality monad.
16:55:20 <ddarius> monoidal: "Partiality" as in "partial function" which does indeed include that example, as well as non-terminating functions and other examples.
16:55:55 <monoidal> yes. the difference is that Uustalu's monad gives a reification of nontermination
16:56:02 <monoidal> http://www.ioc.ee/~tarmo/tday-veskisilla/uustalu-slides.pdf
16:58:17 <monoidal> it's a choice of terminology, both are fine but GotoT seems similar to uustalu's one to me, not to exceptions
16:59:36 <ddarius> monoidal: I consider Uustalu's Partial monad also similar to exceptions.
16:59:53 <g_cross> I suppose it depends on what you are looking
16:59:59 <g_cross> the monadic instances are very similar
17:00:02 <ddarius> Admittedly, it is used in a way that is unusual for exceptions.
17:00:03 <g_cross> however the "runner" is different
17:00:10 <monoidal> there's a map from exceptions -> partial monad. reverse is uncomputable
17:00:18 <g_cross> in the case of exceptions, the runner returns either an exception of the final value
17:00:33 <monoidal> you can throw an exception and catch it, but you cannot catch Later (Later (...))
17:00:37 <g_cross> in the case of GotoT, it always returns a value, it just might have to go through a few iterations in order t oget it
17:00:46 <seric> I have jsut installed FUtil from http://github.com/facebook/futil.git but when I try to import FUtil, I get Could not find module `FUtil' - any idea what I am missing?
17:00:57 <ddarius> monoidal: Why not?
17:01:14 <seric> cabal searches for FUtil.hs - but in  /usr/local/lib/FUtil-0.1/ghc-6.12.1/ there is just a FUtil.hi
17:01:16 <g_cross> Because Later (...) iterates forever due to the "trampoline" in the runner.
17:01:30 <ddarius> g_cross: I was asking monoidal.
17:01:46 <monoidal> halting problem
17:01:47 <PetRat> I don't need the ghci debugger for now because I found my bug by inspecting the code
17:02:18 <ddarius> monoidal: Presumably I can add an exceptions-like catch function.
17:02:34 <ddarius> At any rate, I was not saying the that monad is equivalent to the exceptions monad.
17:02:37 <mtnviewmark> I'm wondering, g_cross, if there is a lot of bouncing around, isn't there going to be a lot of captured context to support the execution of the expressions after each goto, even though those will never execute?
17:03:26 <monoidal> there's unsafePerform :: Partial a -> a
17:03:41 <g_cross> Can you give me an example of what you mean?
17:03:49 <g_cross> I can't see any cases where this would hold.
17:03:57 <ddarius> monoidal: That's irrelevant.  I'm saying a function like: step :: Partial a -> Partial (Partial a)
17:04:00 <soupdragon> you can actually write programs that are _more lazy_ than haskell
17:04:05 <soupdragon> using partiality
17:04:20 <g_cross> The monad instance is
17:04:21 <g_cross> (GotoT m) >>= f = GotoT $ m >>= either (return . Left) (unwrapGotoT . f)
17:04:57 <g_cross> So what happens is that when it sees a left it ignores f, and so all of the context is thrown out
17:05:24 <g_cross> (Except, of course, for any context that is contained in the continuation contained in Left.)
17:05:46 <monoidal> ddarius: fmap return?
17:05:49 <mtnviewmark> right - so all the context to execute f must be kept around while the thing that was (goto x) is executing
17:06:04 <monoidal> I wouldn't call it "exceptions-like catch function", since it doesn't remove the monad layer
17:06:09 <mtnviewmark> since the >>= won't be evaluated until AFTER it completes
17:06:09 <ezyang> How would one implement a breadth-first search in functional style? 
17:06:20 <ezyang> depth-first is easy: just use the recursion in the data structure. 
17:06:41 <mtnviewmark> exyang - reformulate it as an iteration over a list of trees
17:06:47 <monoidal> > let tree = [] : (tree >>= \x -> [x++"L", x++"R"]) in take 10 tree
17:06:47 <mtnviewmark> er, recursion
17:06:47 <lambdabot>   ["","L","R","LL","LR","RL","RR","LLL","LLR","LRL"]
17:06:54 <ddarius> monoidal: Hell, just return would do given the constructors being exposed.
17:07:03 <g_cross> mtnviewmark:  actually, runGotoT evaluates the monad to weak head normal form in order to decide what to return, so in the case of a goto it does evaluate the >>= before it executes the continuation
17:07:16 <lispy> ezyang: not sure I would actually recommend this, but you might find this interesting: http://www.haskell.org/haskellwiki/Library/CC-delcont#Breadth-first_Traversal
17:07:18 <ddarius> I probably wanted something more like Partial a -> Partial (Either a (Partial a)) to distinguish the levels of abstraction.
17:07:33 <g_cross> mrnviewmark:  So by the time it sees that it has run into a goto, the >>= is already evaluated and the f is no longer referenced by anything
17:07:35 <ezyang> lispy: Continuations were the first thing I thought of too... 
17:07:45 <soupdragon> bfs (Leaf a : ts) = a : bfs ts ; bfs (Branch l r : ts) = bfs (l : r : ts)
17:07:52 <monoidal> ezyang: that's DFS of the tree where \x -> [x++"L", x++"R"] specifies the leaves of x
17:07:55 <monoidal> *BFS
17:08:17 <seric> someone an idea why I can't import FUtil?
17:08:18 <soupdragon> not actually bfs :S
17:08:20 <mtnviewmark> g_cross - that's the kind of thing I was wondering -- I suppose I'd like to see your full implementation of the monad
17:10:09 <ddarius> ezyang: You can implement the traditional imperative algorithm directly.
17:10:15 <g_cross> mtnviewmark:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27061#a27061
17:10:21 <ezyang> ddarius: Aw, that's laaame :-) 
17:10:21 <lispy> ezyang: Well, you can convert continuations to zippers, so I guess I would say that a zipper is a nice way to do it :)
17:10:35 <Alex4> hello everybody! anybody knows how to connect two apis ??? I NEED HELP!
17:10:53 <lispy> ?faq Can Haskell connect 2 APIs?
17:10:53 <lambdabot> The answer is: Yes! Haskell can do that.
17:11:17 <ddarius> ezyang: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.342  Not exactly your problem (though it solves your problem) but something you might appreciate reading.
17:11:21 <Alex4> :D... i need to code it in C# and using a cloud connector 
17:11:42 <ivanm> are you actually going to be using Haskell though?
17:11:54 <ivanm> because if not, I think you're in the wrong spot...
17:11:59 <Alex4> yep
17:12:01 <ezyang> Anyway, it makes me kind of sad that BFS requires modest cleverness. 
17:12:25 <ezyang> Thanks for the link. 
17:12:30 <ddarius> ezyang: Why?
17:12:46 <ezyang> No rational reason. I just feel like it should look as beautiful as depth first searches. 
17:12:48 <ivanm> Alex4: well, there's salsa, hs-dotnet, etc.
17:13:00 <ezyang> Probably it is, and I just haven't learned it yet :-) 
17:13:14 <ddarius> ezyang: Note, (unless I chose the wrong paper) Okasaki argues that many functional programmers fail to see an "easy" solution.
17:13:27 <ivanm> ezyang: have you looked at how FGL does it?
17:13:31 <Alex4> hmm im kind of lost in this guys!
17:13:32 <monoidal> he said that the solution was immediate, and about mental mindblock
17:13:33 * ivanm can't actually recall how it does it tbh
17:13:33 <Alex4> :(
17:13:37 <monoidal> immediate for him
17:13:49 <ddarius> Alex4: You haven't asked any question.
17:14:17 <g_cross> monoidal:  indeed, that was exactly what I thought when I read his paper  :-)
17:14:22 <Alex4> first at all, what software is better to start to work on it? visual studio 2008 ?
17:14:34 <mtnviewmark> ezyang -- look at levelorder in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27062#a27062
17:15:35 <ezyang> ivanm: No, although I guess I'd expect no less from FGL 
17:15:56 <ezyang> ... 
17:15:58 <Alex4> http://img.en25.com/Web/Eloqua/EloquaCloudConnectorSampleGuide.pdf <---- this is what i have to do and i dont know where to start from
17:15:59 <ezyang> LOL. 
17:16:07 <ezyang> mtnviewmark: That is so simple :^) 
17:16:17 * mtnviewmark aims to please
17:16:26 <ezyang> and I imagine GHC will implement the ++ efficiently too. 
17:16:27 <mtnviewmark> g_cross - got it - get it - nice!
17:16:41 <ezyang> yay laziness! 
17:16:48 <Alex4> anybody is willing to help me? 
17:17:22 <ezyang> Alex4: Briefly glancing at that PDF, I suspect you're in the wrong channel. 
17:17:34 <mtnviewmark> ezyang - adapting element and subtrees operations to your flavor of Tree should be easy enough
17:17:37 <ezyang> Oh, that must have been what the >>= was doing. 
17:17:38 <eflister> i have mapM (g :: (a -> a) . f :: (b -> a)).  f makes very very large a's, and the purpose of g is to cut out large parts that i don't need and don't have space to keep.  however laziness is apparently causing g not to be applied until too late, cuz i get memory allocation failures (even when g literally throws everything away).
17:17:39 <mtnviewmark> (which is why I wrote it like that)
17:17:51 <eflister> i thought i could fix it with mapM((\x -> deepseq x x) . g . f), but no luck.
17:18:03 <ezyang> It always takes me a littlebit of time to interpret the list monad. 
17:18:33 <ezyang> eflister: I bet you need to get g and f to fuse. 
17:18:56 <g_cross> Yeah, so GotoT works just fine, it's just that I wonder if there is some way that "goto" could be implemented as something with type "goto :: ContT r r -> ContT r a", so that you could use goto inside the standard continuation passing monad transformer without having to write a special "runner"
17:19:06 <mtnviewmark> the key for levelorder (or breadth first) is to recast it as a recursion over a list of trees, not recursion over a single tree
17:19:31 <mtnviewmark> each step makes the list "bushier" (until you get to the leaves)
17:19:36 <Alex4> okay thank you thoug
17:19:39 <ezyang> yep. 
17:19:55 <eflister> ezyang: with a rewrite rule or something? that sounds more involved than necessary - g . f works fine on any single one of the inputs to the mapM, it's just once i accumulate tons of them that f's output is too large (and needs g to throw some of it away).
17:20:21 <ezyang> ah, I see. 
17:21:14 <eflister> any idea why the deepseq isn't the right approach?
17:21:48 <ddarius> eflister: If g were const A then f would never even be applied so the problem lies elsewhere.
17:22:00 <ddarius> Deepseq is never the right approach.
17:22:59 <eflister> ddarius: hmm, how do i think about this differently?
17:23:37 <dom96> Why does this not work, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27063#a27063 ?
17:24:25 <g_cross> Because there are lots of possible types of rational numbers, and it doesn't know which one you want.
17:24:26 <FunctorSalad> is there a setArgs analogue to getArgs?
17:24:34 <eflister> ddarius: can you help me see how i'm thinking about this wrong?
17:24:42 <ezyang> FunctorSalad: I feel like you're asking the wrong question. 
17:25:10 <dom96> g_cross: how can i fix it ?
17:25:25 <ddarius> eflister: No because all you've provided is some meaningless code.  I don't know how you are thinking about whatever it is you are thinking about or what the actual problem is.
17:25:42 <FunctorSalad> ezyang: indeed. I'm wondering about invoking another program's main (without exec)... the cleaner solution would be to split the main function into main = getArgs >>= main' , main' = ...
17:25:49 <monoidal> FunctorSalad: withArgs
17:25:57 <ezyang> oh, I see. 
17:26:07 <eflister> ddarius: the things i'm processing are Map a b, and f makes some really big maps.  g goes through the elements and removes almost all of them.
17:26:16 <FunctorSalad> monoidal: thanks
17:26:27 <FunctorSalad> (System.Environment? should have looked there first)
17:26:44 <g_cross> dom96:  Actually, you can't, because odd requires an integral number and / requires a fractional number
17:27:27 <g_cross> Though you could change it to something like [ (fromIntegral x)/2 | x <- [50..100], odd x]
17:27:42 <eflister> ddarius: i want to make sure the elements i'm trying to get rid of never make it out of the mapM because i run out of memory, but somehow they are being held onto.
17:27:47 <dom96> g_cross: oh, thank you
17:28:08 <ezyang> eflister: what happens if you mapM_? 
17:28:34 <eflister> ezyang: well i need the output :)
17:28:46 <eflister> ezyang: the stuff that survives g, that is.
17:29:05 <ezyang> Yes, but your code seems really weird. 
17:29:10 <ezyang> does f have side effects and g doesn't? 
17:29:17 <ddarius> Which monad are you using?
17:29:23 <ddarius> Or just post your code.
17:29:35 <dom96> g_cross: why does it work, without the fromIntegral, if i remove the predicate ?
17:29:36 <eflister> @paste
17:29:36 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:29:55 <FunctorSalad> (this is in the context of "the year of haskell on the shell" again, btw... if the idea is having lots of tiny haskell scripts as we use bash scripts now, we probably don't want to start a new process all the time)
17:30:30 <ezyang> FunctorSalad: Most modern shells start new processes except for a small set of builtin commands. 
17:30:39 <FunctorSalad> (assuming the little scripts should be executables in their own right, not simply haskell libs)
17:31:22 <FunctorSalad> (like I said you could split each script into pure-haskell and main-wrapper, but do you want to have to do that for every 2-liner?)
17:31:47 <FunctorSalad> ezyang: and sourcing
17:31:56 <tg_afk> My guitar instructor once compared me to Jimi Hendrix. He said, "Compared to Jimi Hendrix, you're crap at playing guitar".
17:31:58 <FunctorSalad> (well, technically 'source' is builtin :F)
17:32:24 <FunctorSalad> anyway, sourcing another bash script (as a command) instead of running it would be the equivalent
17:32:56 <Baughn> > odd
17:32:57 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
17:32:57 <lambdabot>    arising fro...
17:33:05 <Baughn> ..yeah, that's odd.
17:33:05 <tg_afk> sorry, wrong chatroom
17:33:11 <CakeProphet> an arising fro?
17:33:48 <FunctorSalad> I know the shell isn't supposed to be extreme-performance, but why not let things stay fast if you do decide to use another script in an inner loop over thousands of files...
17:34:04 <eflister> ezyang and ddarius: ok it's a little involved: line 65 of http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27064 -- i'm in IO and BrowserAction
17:34:08 <soupdragon> I dont awnna go to bed I want o stay up :(
17:34:10 <CakeProphet> > filter odd [1..]
17:34:10 <soupdragon> it's1 am
17:34:11 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:34:51 <soupdragon> > filter (odd.(`div`2)) . filter (odd.(`div`2)) . filter (odd.(`div`2)) . filter (odd.(`div`2)) . filter odd $ [1..]
17:34:51 <CakeProphet> :t iterate
17:34:51 <lambdabot>   [3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,95,99,1...
17:34:52 <lambdabot> forall a. (a -> a) -> a -> [a]
17:35:22 <eflister> ezyang and ddarius:  right, ezyang, f has side effects (downloading a web page), and g does not
17:35:23 <monoidal> soupdragon: filter f is idempotent
17:35:28 <FunctorSalad> ezyang: with haskell the difference between in-haskell-call and exec should be even larger, because the former enables inlining&rewriting
17:35:33 <CakeProphet> > iterate (+2) 1
17:35:34 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:35:49 <CakeProphet> lol I can optimizez.
17:36:20 <ezyang> FunctorSalad: Yes, but in that case, you shouldn't be using withArgs 
17:36:30 <ezyang> you should use plain old arguments. 
17:36:43 <ezyang> But I won't bikeshed, because you're the one doing the work, so you call the shots :-) 
17:37:00 <FunctorSalad> but I do *not* want to require a real build system for shell fragments -- the "dependency system" should stay limited to "you can use anything in PATH"
17:37:30 <FunctorSalad> ezyang: I'm not very settled on the design either
17:38:07 <CakeProphet> > sum $ take 1000 $ iterate (+2) 1
17:38:07 <lambdabot>   1000000
17:38:13 <CakeProphet> ...ha. swanky.
17:38:17 <FunctorSalad> so far I've decided that haskell *sources* should be in the path dir, with a shebang that causes invisible compilation to a global cache
17:38:33 <ivanm> ezyang: "expect no less" ?
17:38:45 <CakeProphet> > sum $ take 100 $ iterate (+2) 1
17:38:46 <lambdabot>   10000
17:38:46 <FunctorSalad> you can rapidly drop a script in /usr/local/bin just like in bash, yet it gets optimized =)
17:38:57 <FunctorSalad> and no extra clutter in /usr/local/bin
17:39:18 <ezyang> FunctorSalad: Well, not if you're interpreting it... 
17:39:26 <ezyang> ivanm: ? 
17:39:27 <ivanm> (admittedly, most of its algorithms are poorly implemented IMHO)
17:39:30 <CakeProphet> huh. so apparently the sum of the first n primes is n*100? I wonder if that's obvious and I'm simply not thinking about it.
17:39:44 <monoidal> sum of first n odd even numbers = n*n
17:39:45 <ivanm> ezyang: you said you'd expect no less from FGL
17:39:45 <ezyang> ivanm: Is that re FGL? 
17:39:48 <ivanm> yeah
17:39:49 <ezyang> oh, I see. 
17:40:05 <FunctorSalad> ezyang: I mean using a program #!/hask that compiles its argument file 
17:40:07 <monoidal> *odd numbers
17:40:10 <ezyang> What I meant was, "as a graph library, I'd expect it to have some breadth-first traversal" 
17:40:15 <ivanm> aha
17:40:16 <g_cross> FunctorSalad:  Cool idea, but it sounds like a potential security risk though
17:40:20 <CakeProphet> > sum $ take 100 $ iterate (+2) 2
17:40:20 <lambdabot>   10100
17:40:21 <FunctorSalad> (only once; subsequent invocations will use the compiled thing)
17:40:25 <ezyang> FunctorSalad: Where does the compiled file go? 
17:40:25 <CakeProphet> > sum $ take 1000 $ iterate (+2) 2
17:40:26 <FunctorSalad> (if the timestamps are ok)
17:40:26 <lambdabot>   1001000
17:40:36 <ezyang> Does hask have suid? 
17:40:46 <FunctorSalad> ezyang: $HOME/.CompileAndRunhaskell/cache currently
17:40:54 <ivanm> actually, lbft might almost be alright
17:40:56 <ivanm> @hoogle lbft
17:40:56 <lambdabot> Data.Graph.Inductive.Query.BFS lbft :: Graph gr => Node -> gr a b -> LRTree b
17:40:59 <FunctorSalad> no big deal to compile it for every user seperately
17:41:14 <FunctorSalad> and maybe that avoids your security concerns, g_cross ?
17:41:17 <ivanm> though IIRC the actual definition of LRTree is a bit weird
17:41:22 <CakeProphet> > map (\n -> sum $ take n $ iterate (+2) 1) [1..]
17:41:23 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
17:41:23 <FunctorSalad> *separately
17:41:39 <CakeProphet> > map (\n -> sum $ take n $ iterate (+2) 2) [1..]
17:41:40 <lambdabot>   [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,5...
17:41:56 <ddarius> eflister: Try changing the body of the mapM to (\p -> do content <- doPage url p; return $! prune usrFilt cargoFilt cargo content)
17:41:56 <CakeProphet> n*(n-1) for evens it seems.
17:41:57 <g_cross> FunctorSalad: Ah, that sounds like it should work, though I am hardly an expert in security  :-)
17:42:09 <FunctorSalad> err and the basename is currently the name of the source file, with path separators replaced
17:42:29 <FunctorSalad> necessity of rebuild is currently simply by mtimes
17:42:37 <FunctorSalad> I could store it myself if really necessary
17:43:31 <ezyang> eflister: I kind of suspect the deepseq might work, but is at the wrong layer. 
17:43:41 <chicom___master> can a not very smart guy go from knowing bash to learning haskell with just the online docs and a unix pc?
17:44:20 <ddarius> chicom___master: Yes.
17:44:21 <CakeProphet> chicom___master:  maybe. It's certainly possible.
17:44:25 <FunctorSalad> it seems reasonable that every script should have access to all the other haskell scripts in $PATH
17:44:39 <soupdragon> chicom___master: you need a type checker
17:44:42 <FunctorSalad> maybe simply make a module automatically for each script?
17:44:53 <FunctorSalad> and autoimport them all
17:45:02 <monoidal> chicom___master: http://learnyouahaskell.com/, http://book.realworldhaskell.org/read/
17:45:13 <FunctorSalad> (the #!/hask program has an opportunity to preprocess the source after all :))
17:45:38 <eflister> ezyang: yeah i was wondering that -- ddarius, do you agree?  i'm trying your suggestion now and waiting to see how the space grows...
17:45:41 <ezyang> FunctorSalad: I suspect you might have a better time clustering implementations in one file, using the normal module system, and having small stubs that invoke the appropriate file. 
17:45:42 <FunctorSalad> *autoimport them all qualified
17:46:04 <ezyang> You could even use some cleverness with getting the program name. 
17:46:14 <FunctorSalad> getProgName ;)
17:46:23 <FunctorSalad> (System.Environment)
17:46:52 <FunctorSalad> ezyang: seems similar to having each little script implicitly define a module
17:47:06 <FunctorSalad> (and implicitly importing the others qualified)
17:47:23 <ddarius> eflister: deepSeq -can- fix problems, but it's not the right -way- to fix such problems, though occassionally it is the only way due to library misdesign.  I don't think this is one of those cases.
17:48:07 <FunctorSalad> so if I have an "ls" haskell script... invoking it from another will be (Ls.whatever "/etc"), with zero import/dep management needed at that point
17:48:26 <ddarius> Using deepSeq is like reformatting your hard drive because its running low on space.
17:48:50 <ezyang> FunctorSalad: Another thing you're going to have to think about is pipe design. 
17:49:17 <FunctorSalad> ezyang: currently I just use HSH for haskell-nonhaskell pipes
17:49:28 <FunctorSalad> haskell-to-haskell is automatically a pipe, of course ;)
17:49:49 <ezyang> FunctorSalad: But if I just invoke something as (Ls.whatever "/etc"), how do I know it's going to stdout? 
17:50:25 <FunctorSalad> hmm depends on whether Ls.whatever is pure or already dumps to stdout...
17:50:45 <eflister> ddarius: :)  your solution appears to be working!  i tried mapM((id $!) . g . f) before deepseq, but that didn't work, and i concluded whnf wasn't enough because that would just get to the level of the Map, and not all of its elements and their contents.
17:50:47 <FunctorSalad> (I was going with the suggestion of Ls.main being a wrapper for Ls.whatever)
17:51:20 <FunctorSalad> ezyang: you could do it either way ('whatever' does writing to stdout, vs. 'main' does it)
17:51:29 <FunctorSalad> then 'whatever' should take a Handle as arg
17:51:44 <ezyang> But you could have typed pipes. 
17:51:46 <FunctorSalad> maybe invisibly through a Reader monad
17:52:16 <FunctorSalad> yeah, but that's not absolutely essential for 0.1
17:52:49 <FunctorSalad> (and you could just split up the Ls source further and just use it like a lib)
17:53:05 <ddarius> (id $!) = \x -> x `seq` id x = \x -> x `seq` x = \x -> x = id
17:54:39 <eflister> ddarius: how come the last step is allowed (throwing away the strictness?)
17:54:40 <FunctorSalad> ezyang: 'main' could be autogenerated as a wrapper against a 'main2' function with a more haskelly type
17:55:26 <amuck> Is there a relationship between monads and closures?
17:55:31 <ddarius> eflister: It's not throwing away anything, but yes, the seq x x = x step is key.  seq x x can be read as "force x when x is forced" which is clearly redundant.
17:55:33 <FunctorSalad> main2 :: [String] -> ReaderT (Handle,Handle,Handle) IO () -- for starters
17:55:37 <ddarius> amuck: Yes!
17:56:09 <ddarius> Assuming by "closures" you mean "closure operators" and not higher order functions.
17:56:25 <FunctorSalad> heh, unlikely IMHO
17:56:41 <eflister> ddarius: how come it isn't read "force x"?
17:56:43 <amuck> ddarius: I mean higher order functions
17:57:08 <FunctorSalad> the relation to closure operators is interesting though
17:57:13 <ddarius> eflister: To start with, seq takes two arguments.
17:57:27 <FunctorSalad> ddarius: monads seem like a kind of categorification of closure ops...
17:57:32 <ddarius> amuck: Then call them higher order functions.  And then the answer to your question is that there is no special relationship.
17:57:37 <FunctorSalad> (replace equalities with morphisms)
17:57:39 <ddarius> FunctorSalad: They are exactly that.
17:57:43 <monoidal> FunctorSalad: monads in Pos are closure operators\
17:57:45 <eflister> ddarius: sure, but here they're both the same :)
17:57:52 <ddarius> eflister: Indeed.
17:57:55 <FunctorSalad> I see :)
17:58:05 <ddarius> eflister: seq x y means force x when y is forced.
17:58:14 <ddarius> (To use a somewhat overly operational reading.)
17:58:27 <eflister> ddarius: orly?  i thought it was always "force x and return y"
17:58:32 <FunctorSalad> monoidal: hmm? the types don't seem to match
17:58:36 <ddarius> eflister: What does "return y" mean?
17:59:03 <monoidal> FunctorSalad: where?
17:59:07 <eflister> ddarius: :) i guess i mean "evaluate to y"
17:59:16 <dolio> Presumably he means that merely evaluating y doesn't evaluate x once 'seq x y' is around.
17:59:20 <FunctorSalad> monoidal: if the object part of the monad should be the closure operator, we need a category with objects = powerset(A)
17:59:24 <FunctorSalad> A a fixed poset
17:59:29 <monoidal> oh, sorry, yes
17:59:34 <dolio> Evaluating 'seq x y' first evaluates x, then reduces to y.
17:59:42 <dolio> (Maybe)
17:59:49 <ddarius> eflister: It does evaluate to y (assuming x terminates) but you don't evaluate seq x y until you want to evaluate y.
17:59:49 <monoidal> FunctorSalad: A monad in P, where P is a poset considered as a category is a closure operator.
18:00:26 <monoidal> eta ensures that X <= FX, and mu that F(FX) <= FX, so this means F(FX)=FX
18:00:30 <eflister> ddarius: ah, got it.  thanks for your help!
18:00:32 <FunctorSalad> monoidal: Hom(S1,S2) = S1 \subseteq S2 ? {*} : {} presumably
18:00:35 <monoidal> yes
18:00:44 <monoidal> not necessarily \subseteq, <
18:00:54 <monoidal> objects are element of the poset
18:01:04 <dolio> Clearing up possible misconceptions that evaluating 'let x = factorial 50000 ; y = 7 ; z = seq x y in y' evaluates x, I suppose.
18:01:28 <monoidal> * <=
18:01:39 <FunctorSalad> monoidal: ah, you were talking about closure ops on posets, I was thinking of the specific case of a powerset poset
18:02:01 <FunctorSalad> (which is a universal example IIRC, but still confusing ;))
18:02:04 <monoidal> agreed
18:02:08 <monoidal> it is
18:02:24 <FunctorSalad> I meant confusing that we weren't using the exact same definition
18:02:33 <FunctorSalad> (of closure operator)
18:02:42 <djahandarie> Today is all about definitions huh
18:02:52 <monoidal> you can embed poset A into A -> 2 by using (<=) :: a -> (a -> 2)
18:03:26 <FunctorSalad> (to be accurate, I meant "subset of a powerset poset" should cover all the posets up to iso)
18:03:46 <FunctorSalad> right
18:04:11 <CakeProphet> hmmm
18:04:19 <FunctorSalad> (special case of the yoneda lemma IIRC :))
18:04:32 <ddarius> Indeed.
18:04:48 <CakeProphet> could I define a typeclass, and then make every instance of Show have an instance of my typeclass... EXCEPT that I want String to have a slightly different implementation?
18:04:57 <FunctorSalad> for {Yes,No}-enriched categories though, it seems
18:05:09 <FunctorSalad> "enriched" being quite the euphemism here ;)
18:05:16 <FunctorSalad> since Bool replaces Set
18:05:45 <CakeProphet> is a functor salad a kind of topological object?
18:05:46 <CakeProphet> :P
18:06:36 <FunctorSalad> I suppose the normal yoneda lemma will work too
18:07:02 <FunctorSalad> if you note that the (A -> Set) we get has range in {}.{*}
18:07:29 <Philippa> ddarius: hmm, re monads and 'closures' I'd say there is in that monadic values are reified 'parameterless functions' (sticking to the sort of terminology that might make sense to amuck)
18:07:54 <FunctorSalad> (I'm just reconciling monoidal's type sig and that of the yoneda lemma here)
18:07:59 <makuro> hello everyone. I'm gonna tromp right in here and say that I don't understand a lick of haskell, but am still curious to know if a closure (a la javascript)  has even the slightest bit of relation to a monad
18:08:20 <makuro> for instance, they are both used to manage/hide state. sorta.
18:08:40 <Philippa> the ways they're used to manage/hide state are rather different
18:08:59 <Philippa> a monad effectively gives you a 'virtual machine' with a chunk of state to run programs inside
18:09:11 <makuro> I would be interested in all manner of links and elaboration.
18:09:25 <Philippa> a closure is just making your scope 'portable' so you can keep stuff in that scope without letting anything else see
18:09:45 <FunctorSalad> the State monad clearly depends on closures beyond monads depending on them in general =)
18:09:47 <makuro> that kiiinda sounds like a full-featured closure factory thing.
18:09:50 <ddarius> Philippa: re your response to me, in a very hand-wavy way.  One formal way to think of it is that monads don't require a closed category.  However, the fact that Haskell monads are strong is related to "closures."
18:09:50 <Philippa> honestly, that's a lot easier if you know a little bit of haskell
18:09:54 <lispy> a closure is really about capturing variables that are lexically visible 
18:10:03 <lispy> Otherwise you endup with dynamic scope
18:10:15 <Philippa> lispy: yeah, I know. But it becomes first-class, hence the 'portable scope' comment
18:10:35 <FunctorSalad> (the do-block use of bind doesn't seem to require real closures, since the first-class functions in the bind aren't passed upwards?)
18:10:36 <lispy> Philippa: I didn't intend to contradict you
18:10:41 <makuro> but add in a bind statement or something and a monad and closure still seem painfully close in my head.
18:10:53 <Philippa> makuro: monads don't give you first-class functions
18:10:59 <Philippa> monads don't 'capture' either
18:11:17 <Philippa> er, to be fair: monads do effectively give you 'first-class computations', it's a consequence of bind
18:11:36 <Philippa> but return just gives you the equivalent of a value
18:11:51 <lispy> makuro: a monad gives you a way to compose things but a closure is like a packaged up thing
18:11:55 <Philippa> and bind just does an abstract form of sequencing (that may turn out not to be a sequence in any meaningful sense)
18:11:55 <FunctorSalad> say: x >>= (\x1 -> y >>= (\y1 -> ...foo... x1 y1))
18:12:11 <Philippa> lispy: yeah, I'm thinking the analogy goes "return packages things up too"
18:12:14 <FunctorSalad> doesn't seem to require the full powers of closures
18:12:16 <dolio> There are conversations about two different notions of "closure" going on here, right?
18:12:27 <Philippa> dolio: there have been, yes
18:12:28 <FunctorSalad> dolio: yes, as pointed out at the beginning
18:12:43 <dolio> Okay. Just making sure I'm following.
18:13:10 <FunctorSalad> sorry, that wasn't a "omg you didn't read everything?", just a "if you want to know exactly which two defs"
18:13:16 <FunctorSalad> :)
18:13:23 <makuro> so, I use closures to make portable scope.
18:13:24 <dolio> I'm pretty sure I know which two.
18:13:30 <makuro> and monads do something like that , too.
18:13:36 <makuro> but it seems monads do a whole lot more.
18:14:18 <Philippa> monads don't give you portable scope
18:14:26 <Philippa> monads let you run 'programs' in 'virtual machines'
18:14:36 <Philippa> sometimes the virtual machine is, well, the real one - that's the IO monad
18:14:37 <FunctorSalad> (but considering haskell's lazyness, it's a bit absurd to ponder whether a given haskell fragment uses closures ;))
18:15:45 <Philippa> but the type system keeps track of what kind of machine, and thus what the program can do
18:16:01 <Philippa> you might pass something in to the virtual machine when you set it up to run...
18:16:15 <ddarius> Monads don't "do" anything.  Monad is an interface.  Specific monads do stuff in different ways.  To be all Cale-like, the value of recognizing monads overall is so you can apply monad generic functions to them.
18:16:18 <Philippa> and that's how the state monad works, you pass in an initial state and get out a final state and a result
18:16:19 <FunctorSalad> (and as conceptual scaffolding)
18:16:19 <Philippa> ddarius: yeah, I'm talking about a specialisation that does at least have some value when applied to haskell
18:16:19 <lispy> Is #haskell a monad? ;)
18:16:20 <ddarius> lispy: No.
18:16:20 <monoidal> @djinn haskell -> #haskell
18:16:20 <lambdabot> Cannot parse command
18:16:20 <FunctorSalad> (which wouldn't require any representation of the monad concept in haskell source though)
18:16:20 <Philippa> (I've yet to see a good counterexample to the way I've described it that's a haskell Monad)
18:16:33 <monoidal> @djinn ##haskell -> #haskell
18:16:33 <lambdabot> Cannot parse command
18:16:44 <monoidal> seems it isn't
18:17:11 <ddarius> monoidal: The existence of such functions would only suggest that # is a monad.
18:17:16 <monoidal> :)
18:17:47 <Philippa> or if we're really being picky, that there is a monad on #
18:17:58 <Philippa> makuro: got enough info yet?
18:17:58 <FunctorSalad> but the nonexistence does prove it isn't
18:18:05 <lispy> So, I wonder if we could construct a closure monad
18:18:05 <FunctorSalad> (:E)
18:18:19 <Philippa> lispy: 'scalled Identity, isn't it?
18:18:44 <lispy> Philippa: oh, Reader came to my mind
18:18:44 <makuro> this recent discussion about #haskell being a monad is giving me a chance to read more so that I can phrase things in a more correct way perhaps
18:18:51 <FunctorSalad> maybe lispy means another layer of indirection
18:18:57 <FunctorSalad> that seems much like Reader, yes
18:19:11 <Philippa> depends where you want your bindings, I guess
18:19:13 <FunctorSalad> if the object lang is immutable like haskell
18:19:39 <makuro> But yeah, I just imagine that closures and monads are mostly unrelated concepts, but in usage they can be made to intersect.
18:19:39 <FunctorSalad> (thinking of Reader (Map Name Thunk) or so)
18:19:45 <lispy> So, if we can have a Closure monad and we could also have a Monad closure then there would be a certain level of correspondence
18:20:20 <lispy> I don't really know of a Monad closure makes sense though
18:20:25 <FunctorSalad> btw I'm *still* not convinced ImplicitParams are evil =(
18:20:31 <FunctorSalad> (talking about Reader monad)
18:20:40 <Philippa> would we call it the Wadler-McCarthy correspondance?
18:20:50 <lispy> heh
18:20:58 <FunctorSalad> say you've written a monstrous main function with subfunctions in where or do-let-clauses
18:21:14 <FunctorSalad> with IPs it's trivial to make the local functions toplevel
18:21:23 <lispy> FunctorSalad: ImplicitParams are similar to dynamic scope, IIRC that's why they got labeled as evil
18:21:32 <FunctorSalad> just pass the environment they've lost from the uprooting as an IP
18:21:56 <Philippa> eh, so maybe it'd be nice to have lambda lifting in your refactoring tool. I'm guessing HaRe does it already?
18:22:05 <lispy> and on that note, I must pass myself home
18:22:16 <FunctorSalad> lispy: dynamic scope seems a lot less scary with the type system tracing it for you
18:22:41 <FunctorSalad> Philippa: the refactoring I just described?
18:22:46 <FunctorSalad> (and I don't know lambda lifting)
18:22:53 <lispy> FunctorSalad: well, the real question is, can you reason about the behavior of the program easily?
18:22:56 <Philippa> lambda lifting's the equivalent thing done with explicit parms
18:23:00 <makuro> alright everyone, thanks for the help. I may be back, though, to bug you more about making javascript more functional.
18:23:16 <Philippa> makuro: you start by burning it, I think :-)
18:23:17 <lispy> FunctorSalad:  and I would hazard a guess that heavy use of implicit params significantly hampers your ability to reason about it
18:23:36 <lispy> makuro: there is a JS package/library for tht
18:23:41 <makuro> philippa: ha!
18:23:50 <Philippa> makuro: why're you thinking about that, anyway?
18:23:52 <makuro> lispy: yeah, underscore is what I'm using now. and node.js.
18:24:13 <lispy> makuro: http://osteele.com/sources/javascript/functional/
18:24:18 <FunctorSalad> lispy: maybe I haven't seen the ugly cases... in my case it was simply things like the program name (which is locally bound in main since it needs IO)
18:24:24 * lispy >>= home
18:24:39 <FunctorSalad> which was needed by the "print error" function
18:24:40 <Philippa> my guess is there's not too much you can do for it other than perhaps good syntactic support for currying, at least not at the language level
18:24:45 <FunctorSalad> IPs were perfect for that
18:25:10 <mwotton> lispy: isn't home for returning, not binding?
18:25:19 <Philippa> FunctorSalad: seen the implicit configurations with type classes trick?
18:25:46 <FunctorSalad> (maybe because the program name is something that'll never get "mutated" through reentry of the let ?foo = ... binder?
18:25:48 <FunctorSalad> )
18:25:50 <ddarius> Philippa: Yes, HaRe does that.
18:25:56 <makuro> Philippa: node.js uses tons of callbacks and then I was reading about monads on the wikiiiiipedia. closures hide state, monads kind of use callbacks (which node also does).
18:26:14 <FunctorSalad> Philippa: yes, but couldn't get it to work "transparently"
18:26:24 <FunctorSalad> the current package uses the 'Tagged' monad
18:26:33 <makuro> plus few people seem to understand monads and not tooooo many people get closures.
18:26:36 <FunctorSalad> which is far from transparent if your code was pure before
18:26:47 <FunctorSalad> but I might have misunderstood the proper usage of the package
18:27:01 <ddarius> makuro: Most popular languages have closures nowadays.
18:27:15 <necroforest> like java?
18:27:16 <necroforest> oh wait
18:27:28 <necroforest> well, i guess java sort of has closures with inner classes
18:27:30 <makuro> ddarius: they are a bit more requisite in javascript, you see.
18:28:16 <FunctorSalad> does bash have closures? :D
18:28:23 <ddarius> makuro: My point is that "many" people do "get" "closures."
18:28:28 <FunctorSalad> call-by-name ones, sort-of ;)
18:28:32 <ddarius> FunctorSalad: Bash is presumably like Tcl.
18:28:38 <FunctorSalad> (by splicing)
18:28:59 <FunctorSalad> and using source as first-class-functions...
18:29:14 <FunctorSalad> ddarius: never used Tcl
18:29:30 <ddarius> Me neither, but I know roughly how it works.
18:30:13 <makuro> ddarius: I don't know how your previous statement really says anything about people understanding closures. The language implementors obviously, but most programmers just don't need them. With javascript, closures are a fact of life, and if you wanna go anywhere doing javascript, you'll be learning closures post haste.
18:30:32 <FunctorSalad> makeAdder.sh: echo "echo $1 + \$1"
18:30:35 <FunctorSalad> or so ;)
18:30:57 <FunctorSalad> application would be like: set -- args go here; eval $myclosure
18:30:57 <makuro> aaanywho, take care yall
18:30:58 <FunctorSalad> ;)
18:31:17 <ddarius> makuro: You'd be surprised about that.  I'm sure there are plenty of people who use Javascript and barely use higher order functions.  On the other hand, Ruby and Smalltalk programmers use blocks regularly.
18:31:28 <Philippa> FunctorSalad: nonono, the implicit configurations pearl
18:31:33 <FunctorSalad> oh and add arithmetic parens so that thing will actually add
18:31:59 <Philippa> honestly, the first thing to make people "get" first-class functions is to stop calling them special names
18:32:02 <FunctorSalad> Philippa: yes, but edwardk(?)'s  reflection package is the implementation I think
18:32:19 <Philippa> FunctorSalad: what's this /the/ implementation? :-) Last I recall, it doesn't require a monad
18:32:58 <ddarius> Philippa: The Tagged monad is just a clever way of propagating type information.  It isn't used like the IO monad say, unless I'm horribly mistaken.
18:33:10 <Draconx> FunctorSalad, you don't even need eval to implement sort-of first-class functions in bash.  You don't pass the functions per-se, but you can define them on the fly and pass their name.
18:33:33 <FunctorSalad> Philippa: it doesn't, but the package changed from having the 's' type parameter floating around, to the (Tagged s) monad, and I presume that this was done because it made the pkg *easier* to use ;)
18:33:43 <Philippa> ddarius: cool, that figures. Personally I figure anything you're likely to have to really "engineer" with probably ought to be in a monad anyway, mind
18:33:46 <ddarius> Draconx: That's similar to what is sometimes done in Prolog and related to a simplified form of defunctionalization.
18:34:06 <Philippa> (obvious exceptions for eg if it has to live in an Applicative instead)
18:34:24 <FunctorSalad> Tagged isn't a fundamental problem like IO of course, I'm just talking 'bout verbosity
18:35:13 <FunctorSalad> Draconx: I tried that too, but the function environment seems a bit fragile ;)
18:35:28 <FunctorSalad> maybe I was defining my function in a subshell
18:35:44 <Draconx> yes, scoping in *sh can sometimes be very non-obvious.
18:35:52 <FunctorSalad> btw how do you splice into function bodies without eval?
18:36:47 <FunctorSalad> (... as illustrated by SHLVL vs BASH_SUBSHELL vs. PS4 repetition being three distinct notions of nested shells, hehe)
18:37:13 <FunctorSalad> oh and the 'caller' stack, but maybe that's equivalent to one of these
18:37:29 <Draconx> FunctorSalad, uh, maybe what I'm thinking of is only possible in zsh.
18:37:37 <Draconx> FunctorSalad, I don't use bash very much :)
18:38:58 <mwotton> Draconx: ah, you're a bash basher
18:39:13 <Draconx> FunctorSalad, zsh you can just do $name () { ... } ... $name
18:40:23 <FunctorSalad> Draconx: meant to learn that one day (zsh)
18:41:26 <mwotton> I tend to use zsh but aren't religious about it... it's hard to get motivated, as soon as I start doing nontrivial stuff I tend to want to get out of the shell anyway.
18:41:27 <FunctorSalad> Draconx: ah. but I meant this: eval "f() { echo $foo; }"
18:41:38 <FunctorSalad> to define a function that echoes a *constant*
18:41:51 <FunctorSalad> (as in a literal)
18:43:31 <Draconx> FunctorSalad, re: learning zsh, I find it's pretty much the same except with less inexplicable inconsistencies.
18:43:45 <ivanm> mwotton: don't you like your usual nick anymore?
18:43:49 <FunctorSalad> ok, but still need to learn the change ;)
18:44:42 <FunctorSalad> (I think I've become accustomed to the details of bash's syntax now)
18:45:19 <Draconx> FunctorSalad, yeah, if you want the function body itself to depend on a variable, I would imagine that need to use eval.
18:45:55 <Draconx> FunctorSalad, probably the biggest difference is that in zsh, word splitting is not performed on variable expansions by default.
18:46:11 <FunctorSalad> Draconx: or dump the program to a tempfile, but sourcing that file will be 'eval' too in essence
18:46:13 <ddarius> Draconx: Inexplicable inconsistencies add spice to life.
18:46:55 <FunctorSalad> and now that I've invested so much energy in them, my suffering must have been for a reason! *kidding*
18:47:59 <FunctorSalad> Draconx: that difference is a very good idea
18:48:14 <FunctorSalad> those " " add up
18:49:14 <FunctorSalad> I heard zsh has better completion though
18:49:21 <FunctorSalad> that'd be a good selling point for me
18:49:42 <mwotton> it does... very nice to be able to complete hosts in ssh
18:49:55 <Draconx> FunctorSalad, to put it in perspective, zsh comes with a completion module that implement's bash's completion functionality.
18:50:03 <FunctorSalad> mwotton:  bash_completion probably does that too
18:50:15 <FunctorSalad> but must be more fun to write new completions with better shell support
18:50:29 <FunctorSalad> Draconx: *nod*
18:50:47 <dolio> zsh does a couple simple things that I miss when I have to use bash.
18:51:05 <mwotton> dammit, i disconnected for a few days through a routing stuffup at home and someone's taken my nick:/
18:51:06 <Draconx> FunctorSalad, I haven't really used fancy completion, though.  Other people's rules always annoy me, and I've been too lazy to write my own.
18:51:37 <dolio> For instance, I can type 'cd h/a' and press tab, and it will complete to 'cd haskell/Agda'.
18:52:06 <FunctorSalad> it's often easy enough to get hold of a wordlist for your new script's args
18:52:30 <FunctorSalad> for a goto-local-haddock thing, I just grep'ed ghc-pkg's output
18:52:42 <dolio> Or 'cd /u/l/s/g/f' completes to 'cd /usr/local/share/games/fortune'.
18:53:35 <FunctorSalad> dolio: good freature but I already made symlinks for the most common dirs ;)
18:53:45 <FunctorSalad>  /ulb is invaluable ;)
18:54:39 <FunctorSalad> and /i -> /etc/init.d ....
18:55:13 <dolio> I think it even takes the whole string into account. So '/u/l/s' may have more than one completion, but the others don't contain completions for 'g/f', so it knows what you want.
18:55:24 <FunctorSalad>  /h -> my home
18:55:46 <FunctorSalad> yes, that's the point
18:55:55 <FunctorSalad> the 'xd' utility does something similar
18:57:13 <FunctorSalad> (I know about ~, but it doesn't work in all contexts, and my tilde key is damaged)
19:03:52 * hackagebot hpage 0.12.0 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.12.0 (FernandoBenavides)
19:05:56 <djahandarie> This hblah thing is eventually going to fail, I think
19:12:23 <tolkad> If I have a data type with an instance of a class which has multiple parameters, is it possible to derive one of those parameters in the class instance from a type parameter of the data type?
19:15:00 <sRp> i'm looking at ghc-6.12.1's Control/Monad.hs; is there some reason liftM is defined using the do notation? Couldn't it just as well be something like: "liftM f = (>>= return . f)" ?
19:15:18 <sRp> or is there some wierd laziness/termination difference i'm missing?
19:17:29 <Draconx|Laptop> sRp, it could also be defined as you wrote it, yes.
19:18:37 <sRp> cool, thanks
19:20:36 <ddarius> @help
19:20:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:20:41 <ddarius> @list
19:20:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:21:16 <ddarius> @freshname
19:21:17 <lambdabot> Hadb
19:21:25 <ddarius> djahandarie: We have it handled.
19:21:42 <ddarius> (That's not even a bad name...)
19:22:10 <djahandarie> Haha
19:22:12 <djahandarie> @freshname
19:22:13 <lambdabot> Hadc
19:22:18 <djahandarie> Creative. :P
19:22:23 <djahandarie> @freshname
19:22:24 <lambdabot> Hadd
19:22:33 <djahandarie> Ah, it's just sequential. :P
19:22:43 <BMeph> tolkad: Look up "Functional dependencies"
19:23:42 <cw> OT; anyone here heard from wli recently?
19:24:08 <tolkad> BMeph: thanks
19:24:09 <c_wraith> cw, he's around a lot.
19:24:14 <BMeph> cw: Does a minute ago count as "recently"? ;)
19:24:18 <djahandarie> He was talking in -blah moments ago
19:25:03 <ddarius> @hackage haha
19:25:03 <lambdabot> http://hackage.haskell.org/package/haha
19:25:13 <djahandarie> haha
19:25:14 <djahandarie> lol
19:25:15 <djahandarie> ...
19:26:48 <tolkad> wow... that's actually really cool: http://www.youtube.com/watch?v=OpYylmcjPJg
19:27:38 <djahandarie> Heh that is pretty nifty
19:28:32 <kyagrd> Just found a cabal bug !!!
19:29:14 <kyagrd> Don't use "documentation: True" setting in cabal.  It screws up base library depenency and can cause link errors.
19:29:51 <aavogt> I think that one has since been fixed
19:30:47 <BMeph> djahandarie: Have you checked out dons' "pony" package?
19:31:33 <kyagrd> aavogt, I have the most recent version of cabal.  And when I use that option it ignores the base dependey for 4 >= and reverts back to 3.x always
19:31:36 <tommd> Pony has nothing on the Christmas tree.
19:31:50 <cw> BMeph: a minute is a very long time if you're a resonance particle
19:32:39 <aavogt> kyagrd: oh, I'm thinking of something different where haddock generation messes around with .hi files
19:33:16 <BMeph> cw: ...and are you? ;þ
19:33:33 <cw> i've since decayed
19:40:09 <eflister> ddarius: hmm, how come this isn't good enough?  i am trying to desugar the do block.   \p -> (prune usrFilt cargoFilt cargo <$>) $! doPage url p
19:40:34 <djahandarie> Heh BMeph
19:46:08 <Locke-mobile> Is / can a while loop alone or nested for loops be considered recursion in any way shape or form?  I am having a debate with a friend about this.
19:47:13 <FunctorSalad> they can be reduced to each other, but that doesn't answer whether it's instructive to think of one as the other
19:48:11 <Locke-mobile> what do you mean by instructive?
19:48:22 <FunctorSalad> (reduced, taking more basic language features as a given... you grow your own stack to reduce recursion to looping)
19:48:35 <FunctorSalad> whether it is useful for one's thinking
19:48:56 <eflister> can anyone help me understand why (\p -> do content <- doPage url p; return $! prune usrFilt cargoFilt cargo content) is stricter than (\p -> (prune usrFilt cargoFilt cargo <$>) $! doPage url p)?
19:49:17 <FunctorSalad> almost everything can be encoded as almost everything in CS ;) but it may not be a useful way of looking at a thing
19:50:00 <FunctorSalad> but that said, the direction "loop -> recursion" is clean
19:50:09 <FunctorSalad> just add the loop var as a parameter
19:50:25 <FunctorSalad> call yourself with the changed loop variable value at the end of the function
19:51:05 <keseldude> mind if I ask a potentially lengthy question?
19:52:17 <tommd> We only mind if you ask if we mind then don't ask the question.
19:52:17 <FunctorSalad> (or not just the loop variable, but all the things that change with each loop iteration)
19:52:31 <tommd> But if it has significant code then past it on hpaste.org
19:52:33 <tommd> @where paste
19:52:34 <lambdabot> http://hpaste.org/new
19:52:38 <keseldude> I already did
19:52:45 <keseldude> I just didn't want to ask in the middle of another question
19:53:08 <keseldude> anyway, let's say I have this fairly simple data structure http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27065#a27065
19:53:47 <keseldude> extra_fields works like name of field -> data type
19:53:59 <tommd> yuck, why not "data Entry a = Entry { ... , extra_fields :: Map String a }
19:54:05 <tommd> ... end quote
19:54:13 <keseldude> because that's not what I want
19:54:16 <Locke-mobile> by saying call yourself again you are saying call the function in which the loop exists to set a new loop variable?
19:54:24 <keseldude> now let's say I want to restrict the data types allowed by Map
19:54:26 <Cale> keseldude: The a there isn't in scope
19:54:26 <FunctorSalad> Locke-mobile: yes
19:54:40 <keseldude> okay, I don't know the syntax yet
19:54:53 <keseldude> anyway
19:54:59 <keseldude> normally, I would create a class
19:55:04 <Cale> keseldude: I'm pretty sure you *don't* want it to be completely polymorphic, because then you might as well be putting () values into your Map
19:55:13 <keseldude> and make instances of that class for each data type
19:55:25 <Cale> (You can't do anything with a value which could have any type at all)
19:55:44 <Locke-mobile> FunctorSalad: So they only way to have recursion is through calling the same function with data that is returned from that function?  Whether it be from a loop iteration or what have you?
19:55:46 <FunctorSalad> Locke-mobile: loop i = do { print i; when (i>0) (loop (i-1)) }
19:55:55 <FunctorSalad> looks almost like a real loop :D
19:55:59 <tommd> All you'll be able to do with extra_field is sort it, determine equity, and make a string.
19:56:00 <keseldude> Cale: right, which is why I would make sure that each is also an instance of Show, Ord, and Eq
19:56:17 <FunctorSalad> (that will print the numbers from the starting argument down to 1)
19:56:48 <FunctorSalad> Locke-mobile: no, you were asking about considering loops as recursion
19:56:50 <FunctorSalad> not the other way
19:56:51 <keseldude> let's say I want only Int, String, and Date data types in the extra_fields Map
19:56:58 <keseldude> I could create a class EntryType
19:57:01 <Cale> keseldude: okay, so, is the concern that the ordering/equality comparison on these values isn't compatible with the alphabetical ordering on strings?
19:57:06 <FunctorSalad> for that you must make your own call stack
19:57:33 <Cale> You seem to be trying for an existential here, which you can get by sticking 'forall a.' before the data constructor name.
19:57:33 <keseldude> no, the concern is that I don't know how to group these data types
19:58:12 <Cale> Oh, that's easy enough
19:58:12 <keseldude> I don't want to group them with a class because the classes that I want already exist but aren't exclusive to the data types I want
19:58:23 <keseldude> you see?
19:58:34 <Cale> data EntryType = ETInt Int | ETString String | ETDate Date
19:58:39 <Cale>   deriving (Eq, Ord, Show)
19:58:54 <keseldude> oh okay
19:58:57 <keseldude> so that's the way to do it
19:59:04 <Cale> and then just make the extra_fields field have type Map String EntryType
19:59:09 <keseldude> right
19:59:19 <keseldude> but I can't just do data EntryType = Int | String | Date, can I?
19:59:20 <Cale> That way, you have something to pattern match on when you get values out of the Map
19:59:36 <Cale> and so you can tell which type of data you have dynamically
19:59:50 <Cale> Types are normally removed by the process of compilation
20:00:00 <Cale> Data at runtime don't have types attached to them
20:00:45 <ddarius> eflister: By using fmap (<$>) you are going to get: return (prune ... $! result)
20:01:04 <Cale> But we can do various things to ensure the type information is preserved. This one is a little bit crude. You could also, say, use Data.Dynamic
20:01:22 <Cale> :t Data.Dynamic.toDynamic
20:01:23 <lambdabot> Not in scope: `Data.Dynamic.toDynamic'
20:01:27 <Cale> :t Data.Dynamic.toDyn
20:01:28 <lambdabot> forall a. (Typeable a) => a -> Dynamic
20:01:32 <Cale> :t Data.Dynamic.fromDyn
20:01:33 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
20:02:20 <Locke-mobile> Thanks FunctorSalad
20:02:20 <Cale> Note the Typeable constraint. That means that you'll only be able to cast values of various monomorphic types to Dynamic, but a lot of stuff is Typeable, and it's a derivable class in GHC.
20:02:24 <eflister> ddarius: isn't that good?  isn't that strict in result?
20:02:35 <Cale> :t Data.Dynamic.fromDynamic
20:02:36 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
20:03:04 <keseldude> hm, then maybe that is what I was looking for
20:04:15 <ddarius> eflister: (prune ...) expression won't be forced until the result of the action is demanded.  You want to force the result before the return returns.
20:04:15 <keseldude> great. Thank you, Cale!
20:04:23 <Cale> keseldude: No problem.
20:04:50 <Cale> keseldude: Dynamic is a little more awkward in that you have no guarantee that what's in your map is really one of the 3 types you wanted.
20:04:51 <ddarius> eflister: Again, seq and $! (and deepSeq and $!!) are just expressions.  The don't have a global effect.
20:05:16 <keseldude> Cale: but that's more of what I wanted
20:05:32 <keseldude> I don't necessarily want to restrict the data type to Int, String, Date
20:05:32 <eflister> ddarius: ah right i just got confused - i don't want to be strict in result, i want to be strict in the evaluation of prune...
20:05:43 <keseldude> I want to restrict it to EntryType
20:05:53 <keseldude> which any data type can be
20:06:38 <keseldude> where EntryType is more like a class
20:06:42 <keseldude> it's a bit hard for me to describe without the proper terminology
20:07:02 <Cale> keseldude: Okay, then what you can do is to make your EntryType class a subclass of Typeable
20:07:43 <keseldude> yep
20:08:15 <Cale> and then when building Entry values, perhaps use Dynamic internally, but only outwardly present an interface which requires an instance of EntryType
20:08:33 <turiya> can i convert a bytestring into an array of Int?
20:08:47 <Cale> hmm
20:08:54 <Cale> turiya: Sure
20:09:04 <keseldude> Cale: the only problem is that I can't think of any function to use in the class EntryType
20:09:09 <Cale> turiya: But it's a couple of steps, you'd have to convert to a list of Word8 first
20:09:23 <Cale> turiya: Then you could use listArray to convert that list to an array
20:09:38 <Cale> Maybe inserting a map fromIntegral in there to convert Word8 to Int
20:09:52 <keseldude> not only do I want it to be Typeable, but I also want it to be an instance of Show, Eq, Ord, and probably some others
20:10:16 <Cale> keseldude: hmm...
20:10:22 <turiya> Cale: Can it be done with Get?
20:10:51 <Cale> turiya: Oh, that might actually work better, if you want to cluster groups of Word8 into Ints
20:12:28 <turiya> Cale: ok
20:14:00 <keseldude> Cale: it sounds to me like a class/context alias, but I was hoping there was some other neat alternative
20:14:58 <eflister> ddarius: here we go:  (((return $!) . prune usrFilt cargoFilt cargo) =<<) . doPage url
20:15:18 <Cale> keseldude: Well, you could do something like  data EntryVal where EV :: (Typeable a, Eq a, Ord a, Show a) => a -> EntryVal
20:15:59 <Cale> keseldude: Or the equivalent with the old existential notation:  data EntryVal = forall a. (Typeable a, Eq a, Ord a, Show a) => EV a
20:16:50 <ezyang> What's the usual ETA for Hackage accounts? 
20:16:53 <keseldude> and then how do I use it? :D
20:16:56 <Cale> keseldude: Then when you take the value of unknown type out of the EV constructor with pattern matching, you can use Data.Typeable.coerce to try to coerce it back to a specific type.
20:17:05 <Cale> :t Data.Typeable.coerce
20:17:06 <lambdabot> Not in scope: `Data.Typeable.coerce'
20:17:09 <Cale> er...
20:17:26 <Cale> cast, right
20:17:30 <Cale> :t Data.Typeable.cast
20:17:31 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
20:17:55 <Cale> You'll get Nothing if your guess for what type you're extracting is wrong, and Just x otherwise.
20:17:56 <keseldude> doesn't that complicate it, though?
20:17:58 <ezyang> oh wait, it looks like I got one (goes and checks mail) 
20:18:00 <keseldude> I don't need the original type
20:18:06 <keseldude> I just need to know that it can show
20:18:16 <Cale> Well, you know that too.
20:18:26 <Cale> But if that's *all* you need to know, why not just use a String?
20:18:27 <keseldude> so then I wouldn't need to cast, right?
20:18:40 <keseldude> oh, you're right, of course
20:18:43 <keseldude> I was just thinking short term
20:19:01 <Cale> If all you'll ever be doing with the values is showing them, then you could just apply show before sticking them into the map :)
20:19:08 <keseldude> right, heh
20:19:23 <keseldude> Thank you so much
20:21:23 * hackagebot groom 0.1 - Slightly prettier printing for well-behaved Show  instances.  http://hackage.haskell.org/package/groom-0.1 (EdwardYang)
20:21:33 * edwardk waves hello.
20:22:43 <tolkad> Why are all these cool haskell features like multi-parameter classes, type families, and functional dependencies not in standard haskell?
20:22:54 <tolkad> are they going to be added to future standards?
20:22:59 <Cale> keseldude: Oh, another thing: if you can decide on a small finite set of things which you might be doing with the values, you could also apply those functions to them beforehand and stick the record of the results in the Map :)
20:23:09 <ezyang> edwardk: :-) 
20:23:19 <Cale> keseldude: Laziness can be a fair bit of a win in that case :)
20:23:29 <edwardk> tolkad: because we're still working out what the right way is to handle things like MPTCs, fundeps and type families. What is the cleanest way to extend the language isn't clear
20:23:35 <ezyang> What's the ETA for build times? 
20:23:43 <edwardk> ezyang: when do you get back to boston?
20:24:02 <ezyang> edwardk: Late August. 
20:24:13 <ezyang> Then I bum around for a month unemployed and a non-student :-) 
20:24:23 <edwardk> fair enough. want to do a boston haskell talk about your summer vacation? =)
20:24:24 * hackagebot liboleg 2010.1.7.0 - An evolving collection of Oleg Kiselyov's Haskell modules  http://hackage.haskell.org/package/liboleg-2010.1.7.0 (DonaldStewart)
20:24:37 <keseldude> Cale: thanks, but I'm not writing this to actually use it
20:24:50 <keseldude> I'm just trying to start with something simple and give it room for extensibility
20:24:59 <keseldude> an address book
20:25:03 <keseldude> not much is simpler
20:27:08 <tolkad> well what version of the standard are they going to be added to?
20:27:50 <napping> keseldude: If all you know about a type is that's it's showable, then you might as well just pass the string
20:28:03 <keseldude> yeah, that's going to change ;-)
20:28:08 <edwardk> tolkad: well, they aren't likely to go away any time soon. they'll get adopted if folks can find a semantics for something like them that doesn't have horrible warts or require inexplicably complicated internal type system extensions
20:28:23 <keseldude> I was just using those three classes because they seemed useful at the time of writing
20:28:39 <edwardk> or when they've just been around long enough that we just give in and take them as they are ;)
20:28:53 <napping> in general you can supply methods, if that's all your really need
20:28:56 <Cale> keseldude: Ord and Eq can be awkward ones to use
20:29:24 <Cale> keseldude: Because even if you know that a value is of some type which is in Ord, you don't know that its type matches the type of any other value you have
20:29:35 <napping> or make a dictionary with the GADT like Cale showed
20:29:36 <edwardk> tolkad: one of the things that i love about haskell is their willingness to let experiments like these span multiple years =)
20:29:46 <Cale> keseldude: So you end up only being able to compare things with themselves, unless you also have Typeable
20:30:04 <napping> It's generally best to avoid hetergeneous containers
20:30:17 <edwardk> tolkad: they are stable enough to use in production code, so they can get real data and make an informed decision about language design.
20:34:35 <keseldude> okay, I understand why I shouldn't use Ord
20:34:43 <keseldude> but if I don't require Eq, then how can I search?
20:34:44 <tolkad> edwardk: horrible warts?
20:35:04 <keseldude> also, napping, I don't see how to avoid a heterogeneous container in this case
20:36:32 <napping> why do need flexibility at runtime at all?
20:37:53 <edwardk> tolkad: type inference with all these extensions can get quite complicated, the hardest part of language design is deciding what to take out to make a cleaner, extensible foundation. 
20:40:19 <wli> Maybe being very cautious about putting things in isn't enough.
20:42:22 <Cale> keseldude: The trouble is using either Ord or Eq in the first place.
20:42:32 <ddarius> edwardk: Only been working on MPTCs and FDs for about 18 years.
20:42:45 <Cale> keseldude: If you have Typeable, then you can cast your values back to their original types which will allow comparison
20:44:07 <edwardk> ddarius: exactly. they need to bake for another 20 or so. after all we don't want people to see us as some crazy academic language. ;)
20:44:11 <Cale> keseldude: but without that Typeable constraint, you've essentially thrown away the type information, and can't show that it's okay to apply == to two different values once you get them out of your Map again
20:44:12 <keseldude> it will allow comparison if those original types are instances of whatever allows them to be compared
20:44:17 <keseldude> Eq, Ord
20:44:29 <edwardk> ddarius: wouldn't want to be too hasty ;)
20:44:54 <Cale> Okay, suppose I have a value of some type a (which I've forgotten, except that I know it's in Eq), and another value of type b (which I've also forgotten, but I know it's in Eq)
20:45:04 <Cale> Say these values are x and y
20:45:09 <Cale> Is it okay to write x == y?
20:45:13 <keseldude> no
20:45:15 <keseldude> and I get that
20:45:15 <Cale> right
20:45:18 <keseldude> but it can't just be Typeable
20:45:28 <Cale> Sure
20:45:28 <keseldude> otherwise those underlying types might not be comparable
20:45:36 <Cale> right
20:46:00 <Cale> I'm just saying why you need Typeable in addition to Eq or Ord if you want to be able to get any real use from those classes
20:46:14 <keseldude> yes
20:46:21 <napping> I don't see why you need to mix types at all
20:46:27 <keseldude> napping: one use case would be just for input
20:46:42 <keseldude> let's say I'm the user, and I want to create a field anniversary
20:46:45 <keseldude> of type Date
20:46:56 <keseldude> which has a certain constructor
20:47:18 <keseldude> if I just store the "show"ed value, the user can't edit easily, I suppose
20:47:38 <keseldude> but if you know it's a Date type, you can create a specific date input "form'
20:47:38 <napping> do users need to define new types?
20:47:52 <keseldude> not users but future programmers
20:48:04 <keseldude> the users use the types available
20:48:15 <napping> well, that's an easier problem
20:48:33 <napping> to make it so you don't have to modify much of the program when you extend parts of it
20:49:04 <keseldude> yeah, but I don't like just making a data type and using that
20:49:17 <keseldude> because then you can't use this as a library in another program
20:49:22 <Cale> keseldude: One advantage of that simple algebraic type approach is that a programmer who adds a new case to the datatype can switch on the warning flag for incomplete pattern matches, and the compiler will tell them everywhere that they have to extend the code
20:49:45 <Cale> But yeah, if this is a library, then that's another thing again
20:50:13 <keseldude> why is it another thing?
20:50:42 <keseldude> haven't we abstracted enough to make it easy to just make instances of Typeable (and maybe a few other classes)
20:51:53 <aavogt> you might end up with wildcard patterns which don't trigger a warning, but the new constructor should be handled differently in that equation
20:54:04 <napping> If it's a library it should mostly be polymorphic in the type to work over
21:01:28 <tolkad> What kind of restrictions can I put on the type parameter of a class in standard haskell?
21:02:41 <napping> tolkad: type classes only, if you mean H98
21:03:51 <tolkad> so... I can't force the type parameter to have it's own type argument?
21:04:11 <napping> instance (C_1 v_{i_1}, C_2 v_{i_2} ..) => C (T v_1 .. v_k)
21:04:34 <napping> that comes for free, just from the base type T needing a parameter of a particular kind
21:04:53 <napping> That's something you can't even get wrong
21:04:58 <tolkad> not in the instance, I mean in the class declaration
21:05:05 <napping> If you've got a T :: (* -> *) -> * -> *
21:05:20 <tolkad> like... class X (Num b => a b)
21:05:28 <napping> you could write T Maybe Int or T IO Bool, but T Char Char isn't well formed
21:05:44 <napping> that's a superclass constraint
21:05:49 <napping> those are the C earliier
21:06:11 <napping> except it's class (Num b) => (C b)
21:06:34 <napping> on an instance you can constraint the arguments
21:06:37 <tolkad> no, I mean where b is the type argument of a
21:06:44 <napping> e.g class (Real b) => R
21:06:48 <napping> Real (Combplex b)
21:06:52 <tolkad> I want to constrain the arguments on the class
21:07:03 <tolkad> I guess that's not possible in H98 then...
21:07:09 <napping> arguments on the class?
21:07:28 <napping> you can write a superclass constraint to require that an instance of the new class also be an instance of the old class
21:08:23 <napping> you can constrain the arguments in an instance declarations
21:08:30 <napping> class declarations don't even have arguments
21:10:18 <tolkad> you know, everything in haskell is very confusing
21:11:57 <edwardk> tolkad: what is keeping you from saying class Num b => X a b ?
21:12:31 <edwardk> tolkad: that is the syntax for what it sounds like you want
21:12:51 <tolkad> for example, I learned that "class A a where f :: Num b => a -> b" doesn't mean that b can be any type of class Num, it means it the CALLER can request it to be of any type in class Num that they want, which seems to make no sense to me but using the fromIntegral function seems to magically fix the problem
21:13:35 <tolkad> but I have no idea how to make this work for other types
21:13:45 <napping> hmm?
21:13:49 <edwardk> tolkad: well, think about return. you just can't give that a type in a language that conflates classes with vtables baked into a type.
21:14:02 <napping> that says "a" is an instance of "A" as long as there is a method
21:14:17 <napping> f :: forall b . Num b => a -> b
21:14:43 <napping> so to make String an A you need to provide an f :: Num b => String -> b
21:15:16 <napping> if you wanted to pick a particular type when you were defining the class you could have written the required method type as f :: a -> Integer or something
21:15:38 <tolkad> yes, but I orginally assumed that meant that f could return any type within Num. apparently it means the caller can request it to return anything of type Num. I'm not sure how "f" is supposed to be implemented in an instance of A
21:16:10 <aavogt> @type fromInteger
21:16:11 <lambdabot> forall a. (Num a) => Integer -> a
21:16:12 <edwardk> or class Num (Result a) => A a where type Result a :: *; f :: a -> Result a
21:16:13 <napping> well, Num is a class itself, and gives you fromIntegral for making values of any requested instance
21:16:18 <tolkad> aavogt: yeah but for other types?
21:16:33 <aavogt> convert them to an Integer first
21:16:36 <napping> so yeah mentioning Num only in the return type is not too interesting
21:17:28 <edwardk> tolkad: the problem is that returning 'any' a value that is a member of some particular Num instance, isn't very useful. you can't do anything elsw with that number once you have it except show it, add it to itself, take its absolute value, ask for its sign, and check it for equality with some operation performed on itself (or obtained via fromintegral)
21:17:59 <edwardk> tolkad: you coulndn't use f x + f y -- in any meaningful way, because they could return completely different Num instances
21:18:25 <napping> existentials are damn near useless
21:18:41 <edwardk> you can make an existential box to throw it into, you can use the machinery above with the typeclass, you can make an MPTC to do the same thing, etc.
21:19:06 <napping> Now, if you want the num type to depend on the type a then there are plenty of options
21:19:41 <napping> the simplest would probably be to make a multi-parameter class (Num b) => A a b where ... f :: a -> b
21:19:43 * hackagebot gtk-serialized-event 0.11.0 - GTK+ Serialized event.  http://hackage.haskell.org/package/gtk-serialized-event-0.11.0 (AndyStewart)
21:19:53 <magee0> I'm trying to encode the natural numbers and recurse over them at the type level, however I'm unsure as to how to get my recursion to terminate: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27073#a27073
21:20:00 <tolkad> so, how would I implement class A without using fromIntegral?
21:20:46 <tolkad> err, implement an instance of class A
21:20:46 <napping> with the mptc, you get to pick the b when you make the instance
21:21:18 <napping> so you might write instance A (Map k v) Int where f = Map.size
21:22:16 <edwardk> tolkad: well, you can't. in general you need to be able to build up any Num type on demand, and the only tool you have to construct one out of whole cloth with nothing else is fromIntegral =P
21:22:50 <Master> hi
21:23:11 <edwardk> the result type of f is (forall a. Num a => a) -- that is a rather constrained type. you know nothing about it except that it implements Num.
21:23:13 <tolkad> edwardk: well, fromIntegral is just a function, I could just copy whatever it's source is and use it in my implementation of A
21:23:30 <napping> no, fromIntegral is a method of Num
21:23:32 <tolkad> ?src fromIntegral
21:23:33 <lambdabot> fromIntegral = fromInteger . toInteger
21:23:42 <napping> er, fromInteger is the method, yes
21:23:42 <tolkad> ?src fromInteger
21:23:43 <lambdabot> Source not found. You speak an infinite deal of nothing
21:23:45 <edwardk> sadly no, fromIntegral is a function that is specific to each Num type.
21:24:01 <napping> that's why it works on any Num type - because each Num type defines it
21:24:31 <napping> Do you want the choice of numeric type to depend on "a"?
21:24:37 <napping> then use a fundep or associated type
21:24:39 <edwardk> so what you're saying is given some Num instance, you'll use it sight unseen to build up a value of that type
21:24:54 <edwardk> you can do fairly crazy things, but all of them are determined solely by the Num instance
21:25:07 <napping> Or, if you make a method that accepts values of the Num type as well, that can be interesting
21:25:32 <napping> because then the caller of your type can pick an interesting Num instance like some of the automatic differentiation stuff, and pass in some fancy values
21:25:46 <tolkad> ooooh, I think I'm starting to understand how this works
21:25:51 <edwardk> since (Eq a, Show a) => Num a  -- you can fromIntegral some value, show it, count the chars, fromIntegral that, compare that with your original using the Eq, add them, multiply them negate them, take their absolute value, etc.
21:26:13 <edwardk> but the only machinery you know a supports is the power of Num
21:26:13 <napping> otherwise, you pretty much might as well just return Integer if you really want the flexibility - the client can fromInteger it if they like
21:26:38 <tolkad> so... how is fromInteger implemented?
21:26:47 <tolkad> hmm
21:26:54 <tolkad> ?src Double
21:26:54 <lambdabot> data Double = D# Double#
21:26:54 <napping> every single instance of Num has to provide an implementation
21:27:19 <ddarius> data NUM = EQ NUM NUM | SHOW NUM | ADD NUM NUM | MULTIPLY NUM NUM | FROMINTEGER Integer
21:27:33 <Master> I'm new to programming, can anyone suggest a place where I might see the logical layout of the code?
21:27:46 <edwardk> tolkad: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#t%3ANum
21:27:59 <Cale> Master: I'm not sure what you mean by that.
21:28:00 <edwardk> each type defines its own impelementation
21:28:28 <ddarius> fromInteger = flip replicate ()
21:28:39 <edwardk> ddarius =)
21:28:53 <ddarius> Except that takes an Int
21:28:55 <Cale> Master: If your code has comments in the right form for it, then the haddock program will give you documentation in HTML format.
21:28:56 <tolkad> I don't know what these # are for
21:29:13 <Master> Cale: like how HTML is divided into logically defined sections with tags, how is Haskell laid out?
21:29:21 <Cale> Oh, in that sense
21:29:28 <tolkad> or the \subsection... I thought \ was for defining anonymous functions
21:29:55 <edwardk> tolkad: in Double? they are internal details. the compiler knows how to manipulate 'unboxed' values that are not polymorphic
21:29:57 <Cale> Master: Well, there's a formal grammar for Haskell 98 you could look at if you want, but perhaps something gentler would be better :)
21:30:13 <Cale> http://cs.anu.edu.au/student/comp1100/haskell/tourofsyntax.html
21:30:14 <edwardk> \begin{ ...} and \end{...} are a literate haskell convention.
21:30:38 <Cale> This gives an overview of various syntax components. It doesn't cover absolutely everything, but it's enough to get you started for sure.
21:31:19 <Cale> Master: If you're confused about something in particular, just ask :)
21:31:25 <edwardk> data Int = I# Int# -- internally it manipulates variables of a different kind, that you can't use interchangeably with other kinds using primitive operations supported directly by the runtime system.
21:31:56 <edwardk> it wraps it up in the data constructor I#, so that the result is something you can mix with other types
21:32:07 <ddarius> :k I#
21:32:08 <lambdabot> Not in scope: type constructor or class `I#'
21:32:21 <ddarius> :k Int#
21:32:22 <lambdabot> Not in scope: type constructor or class `Int#'
21:32:29 <ddarius> :k GHC.Prim.Int#
21:32:31 <lambdabot> #
21:32:35 <Master> Cale: I think this should do it for now. A friend gave me a webapp that scrapes a game and finds things at certain locations. I want to modify it by adding more search parameters and having it scrape automatically. I'll probably be back.  but thanks for now.
21:32:35 <edwardk> :k GHC.Types.I#
21:32:36 <lambdabot>     Not in scope: type constructor or class `GHC.Types.I#'
21:33:22 <napping> does lambdabot allow #?
21:33:39 <Cale> Master: You might also want to take a look at one of the Haskell tutorials
21:33:51 <edwardk> napping: it may not import many of them
21:34:08 <ddarius> :t reallyUnsafePtrEq#
21:34:09 <lambdabot> Not in scope: `reallyUnsafePtrEq#'
21:34:18 <Master> Cale: where might I find these?
21:34:20 <napping> oh, it does seem to be running with MagicHash
21:34:38 <Master> Cale: or do you just mean general tutorials found on the web?
21:35:13 <napping> tolkad: GHC.Integer.doubleFromInteger is probably used in the instance Num Double
21:35:36 <Cale> http://learnyouahaskell.com/
21:35:44 <Cale> http://book.realworldhaskell.org/read/
21:35:47 <tolkad> ... I don't understand in instance Num INt: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Num.html#line-99
21:35:47 <tolkad> fromInteger should be returning something of type Int probably, but it's returning something of type I#
21:35:51 <ddarius> fromInteger should be in its own class...
21:36:14 <edwardk> tolkad: data Int = I# Int#
21:36:17 <napping> that's not a type, that's a vlue
21:36:19 <Cale> http://en.wikibooks.org/wiki/Haskell/YAHT
21:36:20 <napping> value
21:36:25 <edwardk> I# is the constructor for how Ints are built behind the scenes
21:36:31 <Cale> Master: General tutorials :)
21:36:36 <tolkad> ah
21:36:36 <edwardk> GHC.Prim defines a bunch of operations for manipulating values of type Int#
21:36:44 <edwardk> which are the 'secret sauce' behind Int
21:36:45 <tolkad> ok, I think I understand enough now
21:36:47 <tolkad> thanks
21:36:56 <edwardk> I# wraps an Int# into an Int
21:37:28 <edwardk> manipulating Int#'s is tricky, they can't be used polymorphically. i.e. you can't have a type variable 'a' that get instantiated with Int# one minute and Char# the next.
21:37:47 <ddarius> Leave unboxed types alone.
21:38:16 <blackdog_> hey! teacher! leave them types alone!
21:38:17 <tolkad> is it ok to have cyclical import dependencies in haskell?
21:38:19 <edwardk> so we box them up to make them easier to deal with. manipulating Int#'s is also 'strict' in the sense that the evaluation order on those operations isn't as lenient as usual haskell operations
21:38:20 <danharaj> read that in the 'leave britney alone' tone
21:38:44 <edwardk> tolkad: yes and no, you need to use some trickery. in general, avoid it. 
21:39:00 <edwardk> it exists, but if you need it you're doing something wrong ;)
21:39:27 <edwardk> and general should be moving all of the types that need to be circularly defined out into some other module and re-exporting them through the module you want to have them appear in
21:40:51 <tolkad> edwardk: well... imagine Integer and Num were in different files. You would need to import Integer into Num to define fromInteger, and you would need to import Num into Integer to define the class instance Num Integer
21:41:05 <edwardk> the mechanism to do mutually recursive compilation is to define an hs-boot file, which specifies which files own which definitions
21:41:56 <Cale> I'm not quite sure why GHC can't make hs-boot files itself.
21:42:18 <edwardk> tolkad: yeah, the mechanism used there is they move them into a common module sopmewhere in the bowels of GHC.*, then they export them separately through Prelude, or through somewhere else
21:42:26 <napping> well, if you didn't give type signatures it would be a problem
21:42:52 <Cale> The standard says that recursive modules should just plain be okay, as I recall.
21:43:07 <edwardk> tolkad: a lot of stuff internally in GHC is defined this way, like there is a GHC.Arr module that defines a bunch of mutually recursive array stuff, that gets exposed through a slightly more public Data.Array.Base and then through the very public Data.Array and Data.Array.Unboxed, etc.
21:43:19 <napping> tolkad: actually, class Num and instance Num Integer are defined in the same module
21:43:22 <Cale> You could always just compile all those modules together, or at least look at them all for the purposes of doing some typechecking to construct an hs-boot
21:44:30 <dolio> It's good to see that the most activity the Haskell reddit has had in days is a tabs-vs-spaces war.
21:44:46 <napping> if you have to process all of both modules it's not exactly separate compilation
21:44:54 <danharaj> people use tabs?
21:45:01 <dolio> Apparently.
21:45:13 <edwardk> aliens
21:45:40 <edwardk> a good chunk of my cleanup of alex as i loaded bits of it into luthor was stripping out tabs and renaming things to camelcase ;)
21:45:51 <Cale> napping: There's been some neat things...
21:45:56 <dolio> It wasn't using camelcase?
21:46:07 <turiya> i cant get this (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27074#a27074) code to work, can someone help?
21:46:09 <Cale> er... dolio rather
21:46:12 <edwardk> lots of e_close. mk_int_dfa_foo, etc.
21:46:15 <dolio> What did it use, underscores?
21:46:33 <dolio> I guess that's affirmative.
21:46:42 <tolkad> edwardk: hmm, that's cool, I didn't think of doing that
21:46:45 <edwardk> and random abbreviations =)
21:47:01 <Cale> dolio: dons posted a bunch of cool stuff today, and there was a post by akborder of a blog post by byorgey
21:47:03 <tolkad> edwardk: I didn't know you could add access restrictions to modules
21:47:33 <edwardk> tolkad: yeah its useful when you want to trim the public API and still internally use convenient combinators to build everything
21:48:14 <tolkad> so... how do you do that?
21:48:17 <dolio> Cale: Yeah, but those don't have 23 comments. :)
21:48:28 <napping> export lists?
21:48:38 <tolkad> no, I mean restrict access to a module
21:48:40 <edwardk> module MyModule (MyDataType(SomeConstructor), foo, bar, baz) where ....
21:49:05 <napping> It's not restricting access to a module, but making another module that exports a subset of the things
21:49:09 <edwardk> will only export the single SomeConstructor from MyDataType, the MyDataType itself, and those 3 functions
21:49:10 <tolkad> no, I mean restrict access to the module so only certain other models can access it
21:49:23 <tolkad> edwardk said GHC.Arr wasn't "public"
21:49:24 <napping> that's not nearly as often necessary
21:49:40 <napping> It's perfectly public - you can import it if you really want
21:49:44 <tolkad> or, rather implied it
21:49:45 <edwardk> tolkad: well, when you build a package with cabal you specify exposed-modules and other-modules. technically GHC.Arr is exposed, but its an implementation detail
21:49:55 <napping> It's just not often used
21:49:57 <edwardk> but when you make your own you can make private modules you don't give out
21:50:14 <tolkad> so... I can't do private module ...
21:50:21 <edwardk> yes you can
21:50:26 <edwardk> GHC.Arr just isn't one ;)
21:50:34 <edwardk> look at http://hackage.haskell.org/packages/archive/category-extras/0.53.5/category-extras.cabal
21:50:38 <edwardk> there are two 'other-modules'
21:50:43 <mtnviewmark> @pl \x y -> w x == w y
21:50:43 <lambdabot> (. w) . (==) . w
21:50:45 <edwardk> those aren't visible outside of the code of category-extras
21:50:50 <tolkad> oh, I don't use cabal
21:50:51 <napping> It's almost always enough just to have private things not exported from the module that defines them
21:51:04 <Dashkal> Is there a term for a "non-composite" type.  ex: Integer as opposed to [Integer] or Maybe Integer
21:51:14 <edwardk> even though 'Control.Functor.Internal.Adjunction' is exported in part by Control.Functor.Adjunction' and 'Control.Functor.Zap', etc.
21:51:25 <edwardk> tolkad: you will ;) it is just a matter of time ;)
21:51:34 <napping> you have to mess with packages to have private modules, because that's the first level where you have some notions of groups of modules you could hide a "private" module from
21:51:53 <tolkad> oh, I guess that's a feature that Java has and haskell doesn't
21:52:12 <edwardk> you can do all of this by manually building, etc. but its a lot easier in cabal, and to get things redistributable as a library to where you care about other people accessing the package, you use cabal
21:52:14 <napping> Dashkal: well, data Integer = S# Int# | J# Int# ByteArray#
21:52:24 <edwardk> nah, 'other-modules' is our version of 'internal linkage'
21:52:46 <edwardk> we don't limit scope to the current arbitrary namespace, our scope is the package
21:52:52 <napping> tolkad: hmm, does Java have a notion other then public, protected, private, and package?
21:52:53 <Dashkal> napping: Just looking for a term.  I'm defining a type system and am looking for sutable names for FSKind () as opposed to FSKind (a,b)
21:53:20 <edwardk> napping: the package isn't the internal linkage limitation it is the current namespace
21:53:29 <tolkad> import org.haskell.ghc.arr?
21:53:31 <edwardk> for .NET it is package
21:53:34 <napping> If you mean definitions of kind * that would be like base type, maybe?
21:54:08 <edwardk> tolkad: it is just a slightly different convention
21:54:12 <napping> yeah, I think "base type" is best
21:54:41 * Dashkal nods
21:54:42 <Dashkal> that works
21:55:09 <napping> I'd keep primtive for the distinction between things defined inductively, and stuff built in like Int#
21:56:06 <Dashkal> I'm writing a DSL.  The primatives are the three basic types I support literals for.  Int, String, Bool
21:56:44 <Dashkal> A related question, I need a name for a fully qualified type as opposed to a type constructor.  'Type' is getting a little overloaded.
21:56:53 <Dashkal> Or, a name that covers both types and tycons
21:57:28 <c_wraith> You could say you need something with kind *
21:57:58 <Dashkal> c_wraith: that's more or less what I'm trying to capture, but in a valid identifier name.
21:58:19 <c_wraith> oh.  well, then.  I'm short on suggestions
21:58:37 <edwardk> saturated type, type-with-kind *, etc.
21:59:09 <Dashkal> I'm using GADTs to simplify my type system.  Being able to differentiate between a type construcor and a type at the type level is handy.  Having to type ouyt FSType (FSKind ()) is a touch verbose.
21:59:52 <edwardk> smart constructors to the rescue ;)
22:02:23 <Dashkal> Works great when defining my builtin types.  Not so much when writing signatures for builtin functions
22:12:22 <alexyk> dons: so guess what's ocaml's lookup time vs haskell's in the results :)
22:13:29 <kmc> "Haskell is a post-OO language."
22:13:29 <kmc> heh
22:13:44 <pikhq> Arguably so's C.
22:15:31 <kmc> eh
22:15:41 <napping> Dashkal: type synonyms?
22:16:00 <CakeProphet> hmmm
22:16:47 <CakeProphet> I'm trying to understand when I would use ST over IO. Should I essentially use ST when my computation can return a pure value?
22:17:43 <Cale> CakeProphet: When you're doing some pure computation for which your algorithm needs memory effects.
22:18:10 <CakeProphet> Cale:  how does it ensure referential transparency?
22:19:10 <Cale> CakeProphet: By ensuring that no references to memory that you allocate can escape from the given call to runST (using a type system trick), and by only giving you a very limited set of effects (just operations on STRefs and STArrays)
22:21:06 <kyagrd> lambdabot, where
22:23:32 <kmc> CakeProphet, if you're using IO only for the mutable cell (IORef, IOArray, etc.) you can convert your code to ST
22:23:35 <Dashkal> perhaps more context is in order: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27075#a27075
22:23:58 <kmc> what you gain by doing so is Â«runST :: ST a â aÂ»  (except the real type is more complicated)
22:23:59 <Dashkal> It's actually coming out FAR more sane than my last attempt using exitentials.  But I havne't done values yet.
22:25:06 <kmc> CakeProphet, runST and unsafePerformIO have nearly identical implementation in GHC, but runST is guaranteed (using the type system) to have deterministic results without observable side effects
22:26:05 <dolio> Unless you use something with 'unsafe' in the name.
22:26:10 <kmc> yeah
22:27:06 <CakeProphet> :t unsafePerformIO
22:27:06 <lambdabot> Not in scope: `unsafePerformIO'
22:27:11 <CakeProphet> makes sense. :)
22:27:13 <kmc> unsafePerformIO :: IO a â a
22:27:28 <kmc> so if you don't need runST, there's not much point to using ST over IO
22:27:53 <kmc> you still gain something by restricting the effects used in part of your program
22:28:25 <kmc> CakeProphet, if you like i can explain the type system trickery by which runST guarantees referential transparency
22:29:17 <CakeProphet> how cooperative is STM with other concurrency primitives in Haskell? I'm trying to decide how I want to lay out a concurrent system and I'm considering using mostly message passing... but I might want to use STM for certain things. Can I sanely do both?
22:29:39 <kmc> you can do message passing within STM
22:29:41 <kmc> TChan
22:29:46 <CakeProphet> kmc:  perhaps another day. 
22:29:58 <CakeProphet> kmc:  would there be any reason not to use TChan over Chan?
22:30:06 <kmc> CakeProphet, i can't say for sure
22:30:47 <CakeProphet> perhaps STM is the way to go. I'm pretty sure I will, at some point, require atomic transactions across multiple processes.
22:30:48 <kmc> CakeProphet, it's probably more overhead than Chan if you aren't building larger atomic transactions
22:30:57 <kmc> you can do lock-based atomicity with MVar too
22:31:09 <kmc> the advantage of STM is that it's composable in a way simple locking isn't
22:31:33 <CakeProphet> nah I don't need MVar. I need pretty much message-passing. I'm thinking with a well-designed message protocol I can guarantee atomicity even for complex operations.
22:31:52 <kmc> CakeProphet, you might not even need STM then
22:32:14 <kmc> STM guarantees atomicity for you.  if you're getting atomicity from your protocol design, you don't need STM
22:32:16 <CakeProphet> well my program is a text-based online game. a MUD if you know the term.
22:32:26 <kmc> yeah
22:33:00 <CakeProphet> and I intend to represent at least players and rooms, but maybe even individual objects... as processes.
22:33:02 <kmc> CakeProphet, anyway you can use STM together with other concurrency primitives.  Â«atomically :: STM a â IO aÂ» runs an STM action as an IO action; and you could sequence that together with other IO actions including forkIO, MVar/Chan stuff, etc
22:33:14 <napping> Well, it should be pretty easy to mix
22:33:31 <kmc> CakeProphet, sounds good
22:33:49 <CakeProphet> hmmm... okay. I guess I'll start with Chan and see if I need STM later.
22:34:01 <markmcw> Q on HUnit: anybody got a pointer to a simple example? I'm new enough to Haskell that I don't see when I should use "" and when [] in the AssertEqual call
22:34:39 <kmc> CakeProphet, you'd need STM if you expect to need to do two or more channel operations (read or write) with the guarantee that nothing else happens between them
22:34:44 <c_wraith> STM is best when you have many mutable cells, and you need to update small, generally non-overlapping subsets of them at the same time.
22:35:02 <napping> CakeProphet: Of course, no safety is lost if you use both in the same program
22:35:05 <kmc> markmcw, [] and "" are the same value, except that the latter is restricted to the type [Char], while the former has type [t] for any type t
22:35:25 <napping> CakeProphet: and if you can get away with message sends on single channels at a time
22:35:39 <Dashkal> CakeProphet: a mud?  Nice.  I have a similar pet project.
22:36:07 <Dashkal> CakeProphet: STM is a *very* good idea if you want to be able to process multiple player's actions at the same time.
22:36:08 <napping> then you can replace  writeChan c v with atomically (writeTChan c v) if you need to make a Chan into a TChan
22:36:13 <markmcw> kmc: thx, but I'm just trying to get a 'hello world' example of HUnit to compile, specifically taking the 'head' of a small list
22:36:21 <markmcw> and can't get it to compile
22:36:24 <CakeProphet> Dashkal:  That is what I was considering. 
22:37:12 <CakeProphet> Dashkal:  it's a roleplay-oriented mud, however. I'm not even entirely sure if there will be anything but rooms and players, which greatly reduced the complexity of doing things like item transfers via messages.
22:37:21 <Dashkal> CakeProphet: You may wish to follow along when I ask about types and such.  The context is scripting for the mud.
22:38:09 <CakeProphet> Dashkal:  I was also considering implementing a scripting language of some kind in Haskell. That is for a much later date however.
22:38:12 <Dashkal> Ahh, fair enough.  Scripting is super overkill for that
22:38:21 <CakeProphet> right now I need to figure out which Haskell idioms are the best to use
22:40:14 <roconnor> @hoogle writeSTRef
22:40:14 <lambdabot> Data.STRef writeSTRef :: STRef s a -> a -> ST s ()
22:40:14 <lambdabot> Data.STRef.Lazy writeSTRef :: STRef s a -> a -> ST s ()
22:40:44 <CakeProphet> Dashkal:  scripting might come in handy for creating interactive environments later on.
22:41:17 <roconnor> @hoogle readSTRef
22:41:18 <lambdabot> Data.STRef readSTRef :: STRef s a -> ST s a
22:41:18 <lambdabot> Data.STRef.Lazy readSTRef :: STRef s a -> ST s a
22:41:28 <Dashkal> CakeProphet: Some of the best pure RP muds I've seen are super-scriptable.
22:41:37 <Dashkal> @kind []
22:41:38 <lambdabot> * -> *
22:41:46 <Dashkal> @kind (->)
22:41:47 <lambdabot> ?? -> ? -> *
22:41:50 <Dashkal> O.o
22:42:31 <Dashkal> durr, -> needs two types to produce a concrete type
22:43:19 <napping> the ?? and ? are about letting you write functions that take unboxed types and stuff.
22:43:39 <Dashkal> *nods* That part I wasn't concerned with.  I was just brain-farting and expecting * -> *
22:43:56 <Dashkal> or in my case, K :> K
22:45:20 <CakeProphet> Dashkal:  I think you could easily extend the typical MUD command syntax into a scripting language of its own. Similar to MOO.
22:45:28 <CakeProphet> but more like bash. :)
22:45:35 <Dashkal> CakeProphet: oh absolutely.
22:46:09 <Dashkal> CakeProphet: I've already written the first revision of a scripting language that looks curiously like haskell.  Rev 2 is all about making the damn thing usable.
22:46:24 <Dashkal> Nothing but \x -> x is a little harsh
22:46:34 <markmcw> Never mind; I see what I had wrong
22:47:02 <CakeProphet> Dashkal:  one reason I like Haskell for MUDs is the string handling capabilities. I intend to allow commands to implement their own Parsec parsers for input reading
22:47:40 <Dashkal> CakeProphet: nifty.  I have a similar plan.  A provided parsec for the standard space delinated arguments and just provide the String for the command to play with if so required.
22:48:11 <Dashkal> Lazy evaluation being what it is, if the command never touches the pre-parsed arguments, they won't be parsed at all.
22:48:32 <Dashkal> That took some serious mental-rearrangement to get a handle on.
22:48:55 <CakeProphet> ha. it's awesome though isn't it?
22:49:01 <Dashkal> Oh hell yes it is.
22:51:42 <CakeProphet> Dashkal:  What are the arguments passed to your command functions?
22:52:52 <Dashkal> CakeProphet: In the most revent revision, cmdName :: String, args :: [String], rawArgs :: String
22:53:14 <Dashkal> and the return value is Game () (my monad transformer stack for most game logic)
22:59:06 <CakeProphet> Dashkal:  ....monad transformer stack?
23:00:05 <Dashkal> CakeProphet: Read the RWH chapter on monad transformers.  My Game monad is StateT over ReaderR over IO
23:00:28 <Dashkal> StateT handles mutable game state.  ReaderT handles things that never change.  IO allows me to actually do useful stuff
23:02:38 <Dashkal> "things that never change" includes things like the command Chan I use to shut down sockets and stuff like that.
23:12:11 <Dashkal> How would one implement the Typeable typeclass without automatically deriving it?  I see no way to create a TypeRep
23:12:55 <mbuf> I am hitting this error, http://www.mail-archive.com/cabal-devel@haskell.org/msg05968.html, when using "runghc Setup haddock"; how can I build documentation with UTF-8?
23:15:19 <kmc> Dashkal, it's a dangerous thing to do, but it can be done
23:16:03 <kmc> Dashkal, you can use mkTyCon and mkTyConApp etc
23:16:18 <kmc> look at base/include/Typeable.h for some CPP macros used for poor man's deriving of Typeable
23:16:23 <Dashkal> mkTyConApp with an empty list?
23:16:41 <kmc> empty list?
23:16:47 <Dashkal> :t mkTyConApp
23:16:49 <lambdabot> TyCon -> [TypeRep] -> TypeRep
23:17:00 <kmc> but yeah, if you screw up writing Typeable instances, you can cause segfaults and other nasty memory corruption
23:17:11 <kmc> Dashkal, if you have a 0-ary type constructor, you'd just use mkTyCon
23:17:14 <kmc> > mkTyCon "Foo"
23:17:15 <lambdabot>   Foo
23:17:17 <Dashkal> That's the only function I can see that allows for creation of a TypeRep without having one onhand.
23:17:39 <kmc> > mkTyConApp "Either" [mkTyCon "Char", mkTyCon "Bool"]
23:17:40 <lambdabot>   Couldn't match expected type `Data.Typeable.TyCon'
23:17:40 <lambdabot>         against inferred...
23:17:47 <kmc> oh hmm
23:18:09 <kmc> > mkTyConApp "Either" [mkTyConApp (mkTyCon "Char") [], mkTyConApp (mkTyCon "Bool") []]
23:18:09 <lambdabot>   Couldn't match expected type `Data.Typeable.TyCon'
23:18:10 <lambdabot>         against inferred...
23:18:55 <Dashkal> > mkTyConApp "Maybe" [mkTyConApp (mkTyCon "Char") [])
23:18:57 <lambdabot>   <no location info>: parse error on input `)'
23:18:58 <kmc> yeah, typeable.h uses mkTyConApp with []
23:19:04 * Dashkal nods
23:19:07 <kmc> > mkTyConApp "Maybe" []
23:19:07 <lambdabot>   Couldn't match expected type `Data.Typeable.TyCon'
23:19:08 <lambdabot>         against inferred...
23:19:17 <kmc> > mkTyConApp (mkTyCon "Maybe") []
23:19:18 <lambdabot>   Maybe
23:19:26 <Dashkal> ok.  more curious than actually insane enough to play with those wires.  I'm trying to get as strong a handle on the type system as I can.
23:19:27 <kmc> > mkTyConApp (mkTyCon "Maybe") [mkTyConApp (mkTyCon "Char") []]
23:19:27 <lambdabot>   Maybe Char
23:19:35 <kmc> yeah
23:19:47 <kmc> it's really inadvisable to write your own Typeable instances
23:20:12 <Dashkal> I take it haskell' will allow for deriving that without an extension? :P
23:20:21 <kmc> eventually, probably
23:20:27 <kmc> Haskell 2010 doesn't
23:20:34 <kmc> i'm not sure if it's scheduled for inclusion in Haskell 2011
23:20:46 <Dashkal> Seems odd to have a typeclass that's effectively only usable via extensions.
23:21:00 <Dashkal> usable for new types
23:21:01 <kmc> there's plenty of those
23:21:05 <kmc> for example every multi-parameter type class
23:21:29 <FunctorSalad_> maybe it should have been called 'mkTyApp' o_o
23:21:32 <Blkt> morning everyone...
23:22:03 <kmc> Typeable is also mostly useless without unsafeCoerce, or other magical primitives
23:22:30 <FunctorSalad_> in that case it'd seem to be analogous to show
23:22:34 <kmc> morning Blkt
23:22:43 <Dashkal> kmc: murr?  I've been using it with cast plenty
23:22:51 <kmc> Dashkal, cast is implemented with unsafeCoerce
23:22:52 <Blkt> hi kmc 
23:22:56 <Dashkal> ok, fair enough
23:22:57 <FunctorSalad_> (still usable for reporting, but no special powers)
23:24:41 <Dashkal> I'm about ready to drop dynamic typing and just have my variable contain Integer IDs that outside code can use to lookup the actual values somehow.  Though that only offloads the issue to the code where I store all the maps.
23:25:00 <kmc> Dashkal, are you using Data.Dynamic also?
23:25:11 <Dashkal> kmc: I was looking at it, but I haven't actually used it yet.
23:25:33 <kmc> there's your dynamic typing
23:26:06 <Dashkal> It's not offering me anything that cast doesn't so far.  I only have singular values.  No functions.
23:26:34 <Dashkal> Functions are handled specially, since they actually require evaulating parts of the script's AST.
23:28:23 <Dashkal> well, they do let me nuke a couple LANGUAGE pragmas.  That's something
23:32:05 <nejucomo> How feasible is a cross-platform app written in haskell?  (Particularly, I'm interested in binary installers for windows and mac.)
23:32:32 <nejucomo> I'm only familiar with ghc on linux and a tiny bit of cabal user experience.
23:33:48 <McManiaC> as long as you dont depend on os specific libs, that should be no problem
23:34:50 <kmc> Dashkal, what's a "singular value"?
23:35:04 <CakeProphet> Dashkal:  How do your command functions access state? Through StateT?
23:35:11 <napping> Dashkal: it's easy to define something like Typeable if you have a closed universe of types
23:35:13 <kmc> Dashkal, how are you using cast?
23:35:25 <napping> using GADTs
23:35:45 <Dashkal> ok, catching up
23:36:31 <Dashkal> kmc: Disregard that.  I've switched to Dynamic simply because it lets me nuke a bunch of pragmas.  All I meant was that an FSValue can contain no functions.  No application.
23:37:04 <Dashkal> CakeProphet: for simply reading, getS.  For modifications, I wrote some helper modXX functions that take parts of state and allows modification only those parts.
23:37:44 <CakeProphet> Dashkal:  ah so this isn't concurrent?
23:37:48 <Dashkal> napping: Fair enough.  I'm content to actually derive it, but I wanted to get a handle on how they worked to see if I could glean some hints on how to handle my own types.
23:38:06 <Dashkal> CakeProphet: Sure it is.  The parts intended to be concurrent are in TVars
23:38:11 <wli> Not an SVD singular value?
23:38:12 <Dashkal> Not everything needs to eb
23:38:17 <CakeProphet> Dashkal:  ah gotcha.
23:39:05 <CakeProphet> Dashkal:  I was trying to figure out how to propogate handles/references throughout the system. Perhaps State or StateT is the answer.
23:39:44 <Dashkal> StateT is amazing for that.  The state is threaded through whatever you do, but stays out of your way unless you pull it out.
23:39:53 <napping> Dashkal: what you can do with GADTs has nothing to do with Typeable
23:40:10 <Dashkal> napping: I need Typeable when it comes time to pull the values out
23:40:28 <Dashkal> Without cast, how would I get my v -> Integer extractor?
23:40:39 <Dashkal> well, v -> Maybe Integer to be safe about it
23:40:40 <napping> data Rep t where RInt :: Rep Int | RBool :: Rep Bool | ... | RList :: Rep a -> Rep [a] | RMaybe :: Rep a -> Rep (Maybe a) ...
23:40:54 <napping> then data Dyn where mkDyn :: Rep a -> a -> Dyn
23:41:07 <napping> then you can pattern match on the Rep to do stuff
23:41:19 <Dashkal> Open types.  Pattern matching no good.
23:41:21 <napping> oh, and use type classes to make it easier to build Reps if you want
23:41:36 <McManiaC> data Rep where Rep :: a -> Rep
23:41:37 <McManiaC> :D
23:41:38 <napping> nah, GADTs mean pattern matching improves the type
23:41:54 <CakeProphet> Dashkal:  hmmm, so what's the point of ReaderR if StateT can pretty much do the same thing?
23:42:04 <Dashkal> CakeProphet: typo: ReaderT
23:42:20 <napping> e.g., castToInt :: Dyn -> Maybe Integer; castToInt (mkDyn RInteger i) = Just i; castToInt _ = Nothing
23:42:21 <dolio> What's the point of immutability if mutability can do everything?
23:42:25 <Dashkal> CakeProphet: You can't change things in the ReaderT.  They stay static for you.  Useful for command channels and static configuration
23:43:52 <CakeProphet> Dashkal:  well I mean, I didn't mean in general. I meant why use it in your specific case?
23:44:09 <Dashkal> Because I had things that would never change for the life of the application
23:44:23 <kmc> Dashkal, which pragmas did you nuke?
23:44:44 <Dashkal> I seperated IO into it's own thread cluster.  One for the primary socket and one each for listen sockets.  I had a Chan that I could send commands through to shut down the socket.  That Chan lives in the ReaderT since it will never change.
23:44:54 <Dashkal> kmc: FlexibleContexts, RankNTypes
23:45:10 <Dashkal> napping: I'm not entirely following. Gimme a sec to reread and I'll see if I can grasp this
23:46:02 <CakeProphet> Dashkal:  multiple listen sockets? Wouldn't you only need one? Or are "listen sockets" the player sockets?
23:46:09 <Dashkal> CakeProphet: by moving even the listen socket handling into its own thread I can avoid the 0.25s delay between game ticks before accepting a connection.
23:46:19 <Dashkal> CakeProphet: oops.  one listen socket, n connected sockets
23:46:24 <CakeProphet> ah okay
23:46:27 <CakeProphet> yeah. that's what I do at the moment.
23:47:11 <Dashkal> I'm not sure that'll survive as-is into my next revision.  Closing from the primary thread during shutdown works as well.  Something to ponder.
23:47:24 <CakeProphet> that is what I plan to do
23:47:34 <CakeProphet> simply have a channel spawned from main
23:47:53 <CakeProphet> wait until receive of a shutdown message and then terminate the whole program after some clean-up.
23:50:42 <napping> Dashkal: if you have a limited set of types, you can make a dynamic type system without using anything unsafe. It won't handle polymorphic functions, but Typeable doesn't either
23:52:23 <Dashkal> napping: Would more context help you get at what I'm doing?
23:52:34 <napping> you're doing scripting, right?
23:53:46 <Dashkal> napping: I'm writing a DSL for a mud.  The DSL is to be related to haskell (immutability, lazy evaluation, currying, etc).  There are 6 built in types.  Integer, String, Boolean, List, Pair, and Func.  Consumers of the library may contribute types, but not language constructs to work with them (only functions).
23:54:51 <Dashkal> So I'm considering two approaches.  Closed system where FSType has constructors for those six and 'External', or an open system where all types are handled the same way
23:55:05 <napping> how can clients define types?
23:55:38 <napping> If you mean compile-time clients of your library code, you could probably define FSType in a parameterized way
23:56:18 <Philippa> Dashkal: how are you going to handle resource issues in the presence of lazy evaluation?
23:56:37 <Dashkal> Currently: mkFSType :: String -> FSType (FSKind ()) or mkFSTyCon :: String -> FSKind (a,b) -> FSType (FSKind (a,b))
23:56:52 <Dashkal> Philippa: Emergency bailout if the variable stack gets too large
23:57:26 <Dashkal> This revision will _not_ support tail-call optomization, so I pretty much require that escape hatch
23:58:01 <Philippa> even if it did you'd only have the same issue with time. Assume MUDders are occasionally incompetent at best, malicious at worst :-)
23:58:03 <napping> hey, is that a plain "Func", or a Func a b
23:58:15 <Dashkal> Types are defined at runtime.  Types are just values.  The Type's _kind_ is parameterized into the type.
23:58:35 <Dashkal> Int, Bool, Str are *.  List is * -> *, Pair and Func are * -> * -> *
23:58:35 <napping> dynamic typing is not unreasonable, and you could just have a Func :: *
23:59:00 <Dashkal> Func as *? O.o
23:59:01 <napping> one option is trying to reflect the type definition language
23:59:12 <napping> Dashkal: sure, that's how real dynamic languages do it
23:59:24 <Dashkal> The language is Statically typed
23:59:28 <nejucomo> Hm.  After reading the cabal docs, I realize I should be more specific.  I want a tool that takes my source code and package description and spits out a .deb for debian, a .msi for windows, and a whatever for macs.  It seems like haskell is a ways off from this goal.
23:59:30 <napping> if you have an application you check that it's Func, which acts like Dyn -> Dyn
23:59:41 <Dashkal> At least inside the interpreter.  In haskell, it's very much Dyamic.
23:59:55 <napping> I highly doubt you'll get complete reflection of a statically typed language with anything short of full dependent types
23:59:58 <wli> Is this the bit where scripting with bounds on execution time etc. is needed?
