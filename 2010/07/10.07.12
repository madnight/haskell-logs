00:00:09 <lispy> > foldl1 (+) [1..3] :: Expr
00:00:11 <lambdabot>   1 + 2 + 3
00:00:25 <lispy> > foldr1 (+) [1..3] :: Expr
00:00:26 <lambdabot>   1 + (2 + 3)
00:11:46 <ClaudiusMaximus> is it possible using Cabal to get a sensible-for-each-platform "user" data dir, eg:   ~/.pkgname/
00:13:53 <ManateeLazyCat> ivanm: Wow http://code.haskell.org/~ivanm/Sample_SourceGraph/Graphalyze/Graphalyze.html
00:15:03 <Eduard_Munteanu> ClaudiusMaximus: what do you mean by platform? You might be able to make a symlink in ~/.cabal and change it.
00:16:03 <ClaudiusMaximus> Eduard_Munteanu: i want an ordered list of places to look for config:  current dir; user data dir; cabal data dir
00:16:43 <ManateeLazyCat> ivanm: So use SourceGraph manatee.cabal will generate beautiful svg for manatee?
00:17:03 <ivanm> ManateeLazyCat: hopefully it should do ;-)
00:17:09 <ClaudiusMaximus> Eduard_Munteanu: this is so users can add their own presets/configuration without messing with cabal (eg: cabal install --global  might mean that the cabal data dir is unwritable by mortals)
00:18:12 <ClaudiusMaximus> Eduard_Munteanu: by platform i mean the usual:  linux -vs- windows -vs- os x -vs- something esoteric
00:18:19 <ManateeLazyCat> ivanm: SourceGraph won't touch my code?
00:18:24 <ivanm> nope
00:18:26 <ivanm> just reads it
00:18:47 <ManateeLazyCat> ivanm: Okay, try to use it even i don't know what's it ...
00:18:51 <ivanm> there are quite a few dodgy things it does atm (e.g. includes code source files that aren't actually used...)
00:19:07 <ManateeLazyCat> ivanm: Just want to try after see your beautiful svg. :)
00:19:28 <ivanm> ManateeLazyCat: http://ivanmiljenovic.files.wordpress.com/2010/03/sourcegraph_pepm10_reprint.pdf
00:19:35 <ivanm> ^^ the paper I wrote about SourceGraph
00:19:58 <m3ga> ivan: does sourcegraph only work with a cabal file?
00:20:17 <ivanm> m3ga: nope; you can give it a single .hs file to act as the main file of the project
00:20:25 <ManateeLazyCat> ivanm: Cool.
00:20:29 <ivanm> see the hackage page for more info
00:20:46 <ClaudiusMaximus> cabal is awesome!  i wrote my first .cabal file today, was relatively painless apart from trying to decide what bounds to give the build dependencies...
00:21:18 <m3ga> ivan: thanks. interested in pointing it at ddc
00:21:26 * ManateeLazyCat Installing SourceGraph....
00:22:24 <ClaudiusMaximus> ...and also trying to decide whether i should make -optc-msse4 the default or not..
00:26:14 <ivanm> ClaudiusMaximus: "cabal init"
00:26:15 <ivanm> ;-)
00:26:27 <ClaudiusMaximus> ivanm: i did :)
00:26:56 <ivanm> good-o
00:27:51 * ManateeLazyCat pasted "SourceGraph error" at http://paste2.org/get/911973
00:27:55 <ManateeLazyCat> ivanm: ^^^^
00:28:52 <ivanm> yeah, that's a haskell-src-exts bug
00:28:57 * ivanm tries to find the bug report
00:29:18 <ivanm> http://trac.haskell.org/haskell-src-exts/ticket/191
00:29:30 <ivanm> ManateeLazyCat: ^^ so I can't do much about it :s
00:30:10 <ivanm> as an example, I had in graphviz some code like "f . g &&& h . j"; I had to replace that with "f . (g &&& h) . j" to get haskell-src-exts to play nicely with it :s
00:30:12 <ManateeLazyCat> ivanm: It's depend on user's code?
00:30:18 <ivanm> to an extent
00:30:29 <ivanm> it depends upon how good haskell-src-exts can parse the code in question
00:31:06 <ManateeLazyCat> ivanm: Looks my gtk2hs code confuse haskell-src-exts that broken SourceGraph
00:31:47 <ivanm> yup
00:31:49 <ivanm> :(
00:32:56 <ManateeLazyCat> brb
00:33:24 <ivanm> malcolmci: will you be joining us at AusHac this coming weekend in Sydney?
00:36:05 <malcolmci> I'm in Brisbane, unfortunately, ivanm
00:36:27 <ivanm> malcolmci: well, I believe juhp from brisbane is coming...
00:36:36 * ivanm _was_ from brisbane, but is now in canberra
00:36:50 <ivanm> miclorb: will you be joining us at AusHac this coming weekend in Sydney?
00:37:18 <miclorb> ivanm: no - I was mentioned to it by a friend
00:37:27 <miclorb> just really busy with work, and a wedding this weekend
00:37:33 <miclorb> this is the thing at UNSW? 
00:37:34 <ivanm> heh, fair enough
00:37:41 <ivanm> you seem to have your priorities straight ;-)
00:37:45 <ivanm> miclorb: sure is!
00:38:50 * ivanm -> dinner
00:42:30 <miclorb> ivanm: oh if I could, I probably would prefer to avoid wedding, just a bit tiring. but it is family... 
00:43:59 <ivanm> miclorb: and you can choose your friends but you can't choose your family? :p
00:44:15 <miclorb> ivanm: apparently not. 
00:44:57 <miclorb> If I avoided it and went to AusHac instead... probably wouldn't go down to well...
00:54:38 <ClaudiusMaximus> @hoogle getAppUserDataDirectory
00:54:38 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
00:55:34 <Eduard_Munteanu> ClaudiusMaximus: (sorry for the delay) I actually don't know much about Cabal, but an ad-hoc solution seems reasonable to me.
00:55:49 <ClaudiusMaximus> Eduard_Munteanu: i think i found it ^^^
00:56:03 <Eduard_Munteanu> Oh :)
00:56:13 <ClaudiusMaximus> returns ~/.appName on *nix, something weird on Windows
01:03:44 <ClaudiusMaximus> @hoogle FilePath -> FilePath
01:03:44 <lambdabot> System.FilePath.Posix addTrailingPathSeparator :: FilePath -> FilePath
01:03:44 <lambdabot> System.FilePath.Windows addTrailingPathSeparator :: FilePath -> FilePath
01:03:44 <lambdabot> System.FilePath.Posix dropDrive :: FilePath -> FilePath
01:03:53 <ClaudiusMaximus> @more
01:18:30 <harlekin> Just to make sure my following question isn't silly: Both reactive and Yampa are libraries to accomodate function reactive programming, right?
01:21:00 <ivanm> harlekin: yup
01:23:18 <harlekin> Mh, what should I chose if I want to do 2D OpenGL programming?
01:23:46 <harlekin> Is one of them more advanced than the other generally or more likely to be maintained in future?
01:25:35 <ivanm> I think reactive gets more work on it, but neither of them are particularly efficient atm
01:25:40 <kmc> harlekin, why are those your two options?
01:25:58 <harlekin> kmc, because I want to try FRP. Is there any other library I should consider?
01:26:01 <kmc> harlekin, maybe you could use http://hackage.haskell.org/package/graphics-drawingcombinators
01:26:45 <harlekin> Cool. That could be what I want of course.
01:27:21 <ivanm> *ugh* I went changed some code in graphviz to make haskell-src-exts happier when parsing it... and then uploaded before I checked that the edited version was correct
01:27:24 * ivanm facepalms
01:29:40 <harlekin> kmc, still for animation I need to manipulate the image over time. FRP isn't a good option for it?
01:30:26 <napping> maybe nice, but not required
01:31:31 <harlekin> napping, if that's so: Will Yampa or will reactive be nicer? (: (Or anything else?)
01:31:55 <harlekin> I'm having a hard time to chose since I feel the libraries are doing the same thing and I cannot find a comparison of them.
01:32:19 <harlekin> Seems like a "choice doesn't matter, just chose" situation to me, but is it really?
01:33:10 <kmc> harlekin, it probably does matter, but it sounds like none of us have the required experience to advise you
01:33:16 <kmc> maybe you should read some sample code or papers about each
01:34:08 <harlekin> I will. Thank you. (-:
01:34:28 <arch1> hello to all : i have a question relate the good manual online learnyouhaskell :during read of  http://learnyouahaskell.com/making-our-own-types-and-typeclasses chap-8 , after infixr 5 :-:  data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)  i found this example :ghci> 3 :-: 4 :-: 5 :-: Empty  (:-:) 3 ((:-:) 4 ((:-:) 5 Empty))  In my ghc6 (GHCi, version 6.12.1)*Main> 3 :-: 4 :-: 5 :-: Empty 3 :-: (4 :-: (5 :-: Empty)) the position of :-: is
01:34:28 <arch1>  infixed in my ghci but prefixed in html doc Is possible an error in html document ?
01:35:48 <ivanm> arch1: does it say (:-:) ?
01:35:53 <ivanm> (in the documentation)
01:35:55 <napping> arch1: if it is wrapped as (:-:) then it is correct to write as prefix
01:36:07 <ivanm> as an example:
01:36:11 <ivanm> > (+) 1 2
01:36:12 <lambdabot>   3
01:37:00 <arch1> ah ! okay but  why ghci say  in infix mode ?
01:37:58 <ivanm> because usage-wise it's preferred infix
01:38:10 <ivanm> what do you normally say: 1 + 2, or (+) 1 2 ?
01:38:11 * hackagebot graphviz 2999.10.0.1 - Graphviz bindings for Haskell.  http://hackage.haskell.org/package/graphviz-2999.10.0.1 (IvanMiljenovic)
01:38:46 <arch1> ok : capito ! grazie ( Thank's)
01:39:18 <triyo> I'm new to testing programs in Haskell. I have read ch11 in RWH and I have read some wiki posts on QuickCheck and HPC. I have a few questions I hope you guys can help me answer. 
01:39:39 <triyo> What is the best way to structure the test, properties?
01:39:54 <ivanm> in what sense?
01:40:10 <triyo> I have number of sub-projects with their own .cabal files
01:40:45 <ivanm> and these sub-projects' tests all depend upon each other?
01:40:45 <triyo> What would be a common approach? where would I place my test code form starters.
01:41:20 <triyo> ivanm: yes, there are some lib sub-projects that are shared
01:41:27 <ivanm> you could see how happstack does it then in that case
01:41:32 <ivanm> since they have a similar situation
01:41:49 * ivanm heads off
01:42:11 <PetRat> I think I found a good use of liftM2 to lift (,) into the Maybe monad. Can someone take a look? Look at the latest revision:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27338#a27339
01:43:25 <kmc> PetRat, looks good
01:44:01 <kmc> PetRat, btw i'd make a "type" alias for the Ints in Play, so it's obvious what they mean
01:44:07 <triyo> ivanm: thanks, I'll have a look at happstack's setup
01:44:39 <PetRat> kmc: thanks! yes, there is nothing there to indicate what Play Int [Int] actually means.
02:08:25 * hackagebot constructive-algebra 0.1.6 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.1.6 (AndersMortberg)
02:28:40 <slyfox> what status does hmake have? does anyone use it in favour of cabal? (http://www.haskell.org/hmake/)
02:30:53 <kmc> slyfox, never heard of it
02:48:47 <napping> slyfox: isn't that something from an old haskell compiler?
02:49:21 <quicksilver> no.
02:49:35 <slyfox> it seems to support a bunch of compilers
02:49:36 <quicksilver> it's an old build framework from which cabal took some inspiration.
02:49:51 <quicksilver> I think it's fading into obsolesence
02:49:54 <slyfox> i just wanted to know whether upstream plans to support recent GHC
02:49:59 <quicksilver> although malcolmw would be the one to ask, I guess
02:51:36 <CakeProphet> :t now
02:51:38 <lambdabot> Not in scope: `now'
02:51:39 <CakeProphet> :t not
02:51:40 <lambdabot> Bool -> Bool
03:24:30 <Heffalump> (repost of a question from earlier, in case anyonw watching now knows): am I right that if a .cabal file has one executable listed as buildable: false, but still has build-deps listed for that executable, then cabal still treats them as dependencies? (And actually gets even more confused: it fails to install them from 'cabal install' and then fails the build later)
03:25:59 * hackagebot graph-rewriting-ski 0.4.5 - Implementation of the SKI combinators as an interactive graph rewriting system  http://hackage.haskell.org/package/graph-rewriting-ski-0.4.5 (JanRochel)
03:26:01 * hackagebot graph-rewriting-lambdascope 0.4.5 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.5 (JanRochel)
03:26:12 <Jonno_FTW> is there an equivalent to wget for haskell?
03:26:39 <And[y]> http://hackage.haskell.org/package/http-wget-0.6.2
03:26:40 <And[y]> ? :>
03:28:37 <kmc> Jonno_FTW, you want a library, or just a reimplementation of the tool "wget"?
03:30:09 <Jonno_FTW> I need a library
03:33:50 <kmc> there's lots of HTTP libs on hackage
03:33:58 <kmc> including "HTTP", which is in Haskell Platform
03:34:03 <kmc> also bindings to libcurl
03:40:36 <slyfox> Heffalump: http://hackage.haskell.org/trac/hackage/ticket/656
03:41:19 <Jonno_FTW> I just need something to download a file
03:43:49 <Heffalump> slyfox: this isn't with executables depending on the same library
03:44:06 <CakeProphet> what is lambdabots thing that lets me tell people things?
03:44:09 <CakeProphet> when they come back?
03:45:28 <Heffalump> but I did fail to search the bug database, I'll do that now
03:46:05 <quicksilver> @tell CakeProphet you use @tell
03:46:05 <lambdabot> Consider it noted.
03:48:54 <ClaudiusMaximus> how to avoid this from my package during cabal install? "Warning: No documentation was generated as this package does not contain a library. Perhaps you want to use the --executables flag."
03:54:23 <Jonno_FTW> is it possible to compile windows executables in linux?
03:57:13 <hpc> i don't think so, for nontrivial programs
03:57:30 <hpc> you need to have all the libraries you are linking to, and the compiler must support it
03:57:33 <Twey> You can compile to C and then mingw it, I guess
03:57:40 <hpc> or that
03:57:49 <Twey> You'd have to do all the libraries, too, though
04:01:14 <Jonno_FTW> I keep getting this error when installing directory 1.0.1.2
04:01:25 <Jonno_FTW> http://filevo.com/eylfe58j3xfe.html
04:01:28 <Jonno_FTW> wait
04:01:51 <Jonno_FTW> wrong paste, this error  Missing header file: HsDirectory.h
04:02:19 <Jonno_FTW> even when I run this: C:\temp\directory-1.0.1.2>Setup.exe configure --extra-lib-dirs="C:\temp\director
04:02:22 <Jonno_FTW> y-1.0.1.2\include"
04:02:26 <tellme> hello could you recomend me any Haskell IDE?
04:02:37 <tellme> I wanna start with that programming language :)
04:02:49 <Jonno_FTW> windows or linmux?
04:02:55 <Jonno_FTW> *linux
04:02:57 <tellme> windows (vista or xp)
04:03:02 <Jonno_FTW> I use notepad++
04:03:05 <hpc> tellme: notepad++
04:03:11 <Jonno_FTW> with a few custom shortcuts
04:03:34 <tellme> (in linux i write everything in vim ;) )
04:04:01 <hpc> with the platform installed, .hs associates with ghci, too, if compilation is not necessary
04:05:25 <tellme> ok, thanks a lot, i'll try it ;)
04:06:04 <ClaudiusMaximus> how to avoid cabal sdist warning about cc-options: -O[n] interfering with --disable-optimization (ican i test for that flag in my .cabal and avoid setting cc-options: in that case?)
04:06:07 <Jonno_FTW> tellme: it is really helpful if you setup a shortcut to run your .hs files with ghci
04:19:11 <Lajla> Jonno_FTW, nodepad++ isn't really what most people would call an IDE, rigt?
04:19:29 <Lajla> I mean, I use it, but often contrasting an IDE when I am not in need of any fancy debugging or stepping
04:20:20 <hpc> an IDE isn't necessary for haskell because of the ease of running programs
04:20:36 <hpc> but what most people mean by IDE is editor
04:20:44 <hpc> usually
04:23:17 <jedai> vim works on Windows too, you know (or at least gvim)
04:23:40 <jedai> Personally I use emacs everywhere
04:23:52 <hpc> gvim is awful on windows
04:24:08 <hpc> it leaves swap files everywhere and the color scheme is hard to configure
04:24:12 <kaustuv> I am porting some code from OCaml to Haskell. One of the things it does is millions of simple operations on small arrays of integers. I'm noticing a strange performance issue with this. Here's a comparison with the array operation grossly simplified: http://haskell.pastebin.com/MEGAJXm9 vs. http://ocaml.pastebin.com/9F668nxx . How might I rewrite the Haskell version to match the speed of the OCaml version?
04:24:27 <jedai> hpc: Really ? That's good to know I guess
04:25:04 <hpc> i just use notepad myself, because i am afraid to have my opinion of notepad++ ruined by actually using it :P
04:25:05 <Lajla> hpc, integrated development environment
04:25:10 <Lajla> And IDE is usually contrasted with a text editor.
04:25:33 <Lajla> hpc, notepad doesn't even support "\n" as endline, right?
04:25:35 <hpc> Lajla: i know, but the two are also easily confused
04:25:44 <Lajla> hpc, ahh
04:26:05 <Lajla> you rightfyully anticipated noobishness and adjusted accordingly as to praeserve our superior status as the knowledgeable, I like it.
04:26:12 <hpc> :D
04:26:13 <Lajla> The weak shall serve the strong.
04:26:18 <jedai> hpc: notepad is really awful though, almost anything is better (emacs is pretty good on Windows too)
04:26:30 <hpc> oh, cool; ill try it out
04:26:50 <Lajla> jedai, now now, notepad is an excellent text editor, all it lacks is a good operating system.
04:27:10 <Lajla> Besides, edlin > all
04:27:17 <danderson> it's an excellent editor, if you're editing text.
04:27:30 <danderson> what most of us in fact do is write code, not edit text :)
04:27:33 <Lajla> And your files are under 5 MB.
04:27:42 <Lajla> danderson, not even that I fear.
04:27:50 <Lajla> It can't copy and paste with shortcuts I think.
04:28:13 <Lajla> danderson, besides, on windows, you write code by dragging windows and clicking things I heard.
04:28:36 <ClaudiusMaximus> kaustuv: have you tried profiling to see where it's being slow?
04:29:44 <kaustuv> ClaudiusMaximus: Yes. Unsurprisingly, it spends 95% of its time in the spin loop. GC time is negligible as there is no allocation.
04:30:34 <kaustuv> Some of the bang patterns were inserted based on profile-info. Then I went overboard and banged everything.
04:35:11 <kmc> woah, a bang pattern in do
04:35:13 <kmc> haven't seen that before
04:36:36 <kmc> kaustuv, btw -fglasgow-exts is deprecated
04:36:51 <kmc> {-# LANGUAGE BangPatterns, Rank2Types, whatever #-}
04:37:17 <Twey> @tell hpc http://ergoemacs.org/ — this is much nicer on Windows than stock emacs
04:37:17 <lambdabot> Consider it noted.
04:37:17 <kmc> kaustuv, are you using +RTS -s ?
04:37:45 <Twey> (also comes with haskell-mode)
04:39:30 <Lajla> I see brackets.
04:39:39 <kaustuv> kmc: How is +RTS -s supposed to help me?
04:39:51 <kmc> just to get more info
04:40:13 <kmc> like what % is spent in GC
04:40:16 <kmc> (very little, as you observed)
04:41:18 <kmc> kaustuv, you could use the "vector" package instead of STUArray
04:41:53 <kaustuv> kmc: How does it improve on STUArray?
04:42:02 <kmc> loop fusion
04:42:06 <kmc> i can't say more specifically
04:42:40 <kmc> it may or may not be faster
04:42:48 <kmc> probably worth trying on this small example you've pasted
04:43:11 <kaustuv> Since there is a single loop and the intermediate structure can't be eliminated by fusion, I am doubtful that it will be much use. I will try it out though.
04:43:20 <kmc> it may be better in other ways
04:49:03 <kmc> kaustuv, STUArray is unboxed therefore strict, so i think the $! on writeArray is unnecessary.  it may have a slight cost
04:49:59 <kaustuv> (x `seq x) is more expensive than just x if it is already WHNF?
04:50:08 <kaustuv> err, `seq`
04:50:20 <kmc> i'm not sure
04:50:56 <kaustuv> removing the $! has no observable effect.
04:52:58 <zygoloid> kaustuv: i'd hope that x `seq` x gets compiled away to just x, but i don't know for sure
04:53:40 <kmc> ah, i believe i've found the problem.  incrArray and spin have no type signatures, so they're inferred as general, typeclass-polymorphic functions
04:53:52 <kmc> adding a signature for Int drops the time from about 25s to about 7s on my system
04:54:07 <zygoloid> kaustuv: ok, i've tried it in ghc-core. they compile to identical code.
04:56:20 <Lajla> I saw brackets again.
04:57:03 <kaustuv> kmc: Interesting.
04:58:14 <kmc> kaustuv, my guess is that the Int version is subject to heavy unboxing and strictness analysis
04:58:32 <kmc> while the polymorphic version has to treat its numeric arguments as well as the array elements and the array itself as opaque boxed values
05:00:17 <kmc> kaustuv, out of curiosity since i don't know ocaml that well -- are the arrays you're using there polymorphic?
05:04:26 <kaustuv> kmc: OCaml arrays are polymorphic, but arrays of integers are stored unboxed.
05:04:50 <kaustuv> I've added type signatures to everything and don't notice a dramatic improvement in speed.
05:13:50 <kmc> perhaps it only matters when profiling
05:17:30 <Phyx-> kaustuv: you would only notice speed gains if you added monomorphic types instead of overloaded types
05:21:36 <ski> 4
05:29:54 <hptans> Haskell is harder to learn than Scheme?
05:30:02 <hptans> Haskell is used for what?
05:31:25 <Lajla> hptans, depends on the person.
05:31:57 <Lajla> But generally, haskell is used for commercial sellout stuff and selling your soul to the devil, and Scheme is used to safe babies and cute animals from certain death.
05:32:15 <hptans> ????
05:32:22 <Lajla> Also, the atomic bomb was coded in Haskell and terrorists and atheists use Haskell.
05:33:04 --- mode: ChanServ set +o quicksilver
05:33:07 --- mode: quicksilver set +b *!*Lajla@*.adsl.xs4all.nl
05:33:07 --- kick: Lajla was kicked by quicksilver (On Mondays, there are no warnings.)
05:33:08 <kaustuv> kmc: minor progress, but not entirely satisfactory: http://haskell.pastebin.com/NsfDEwU4 (I had to upgrade GHC, so delayed)
05:33:28 <quicksilver> hptans: How hard haskell is to learn depends what you have learnt before.
05:33:47 <hptans> quicksilver: i know only C
05:34:16 <quicksilver> then Haskell is probably harder to learn than scheme, for you, yes.
05:34:31 <quicksilver> but interesting and recommended, still.
05:34:40 <quicksilver> (both are interesting and recommended, in fact)
05:34:42 <hptans> and why ? :P
05:34:59 <quicksilver> because it's very different.
05:35:13 <quicksilver> purity, laziness, a powerful type system with automatic type inference.
05:35:23 --- mode: quicksilver set -o quicksilver
05:38:13 <hptans> Haskell dont have much opensource projects?
05:38:58 * hackagebot hscolour 1.17 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.17 (MalcolmWallace)
05:39:30 <quicksilver> hptans: http://hackage.haskell.org/packages/archive/pkg-list.html
05:39:50 <quicksilver> hptans: (but, compared to some other languages I agree it's fewer)
05:40:26 <silver> hptans, I think haskell doesn't have much closed source projects
05:40:34 <quicksilver> hptans: also, http://www.haskell.org/communities/05-2010/html/report.html
05:40:48 <quicksilver> gives a good overview of some of the interesting active developments (most of which, although not quite all, is open source)
05:40:56 <zygoloid> hptans: i think everything on hackage is open source (for some value of open source). that's quite a lot of stuff (but mostly libraries)
05:41:09 <hptans> Haskell is not a quick language right?
05:41:20 <silver> quite quick
05:41:29 <silver> it depends
05:41:38 <zygoloid> hptans: in what sense? it makes rapid development easy once you're past the steepest part of the learning curve
05:42:10 <zygoloid> hptans: you can create programs whose performance is competitive with C, but it often requires writing non-idiomatic code.
05:42:45 <hptans> the learning curve is big?
05:43:02 <silver> hptans, you can check performance of toy-examples here http://shootout.alioth.debian.org/
05:43:03 * wli sticks with idiom and lets the compiler writers figure it out (okay, I'm a hypocrite)
05:43:17 <quicksilver> hptans: no worse than, say, Java or C++ in my opinion
05:43:22 <quicksilver> it's a *different* learning curve though.
05:43:35 <quicksilver> learning Java is about learning your way around buggy libraries and a complex IDE.
05:43:45 <zygoloid> unlike Java and C++, there's very little in common between the learning curve of Haskell and other languages
05:43:54 <Phyx-> quicksilver: well said
05:44:13 <quicksilver> learning haskell is about your head exploding day after day
05:44:25 <quicksilver> until you get the hang of some really general abstractions
05:44:43 <Phyx-> quicksilver: though, I don't think it ever stops exploding
05:45:05 <jaj> but after some time you actually enjoy the daily explosion
05:46:34 <nlogax> and learn how to use it to blow up problems
05:46:38 <Axman6> hptans: you can write code in haskell that runs faster than the equivalent C code produced by GCC with optimisations in haskell, though this isn't all that common (not because it couldn't be, but because people's main concerns usually isn't speed)
05:46:55 <Axman6> uh, -"in haskell"
05:47:07 <mreh> unidiomatic haskell still isn't that bad to write though
05:47:19 <Phyx-> btw, ghc says that -fvia-C is deprecated, what's in it's place?
05:47:34 <kmc> Phyx-, LLVM perhaps
05:47:36 <jaj> Axman6: ok for a moment I thought you were saying you could produce faster haskell code than C code compiled with gcc ;)
05:48:05 <dolio> The native code generator is in its place.
05:48:06 <Axman6> jaj: that is what i was saying i believe
05:48:08 <quicksilver> Phyx-: the native code generator (-fasm)
05:48:22 <mreh> is the llvm backend out now?
05:48:28 <mreh> in the mainline
05:48:35 <Phyx-> kmc: you know, I keep hearing about LLVM, both in UHC and GHC. but having read nothing about it... WTF is it.. some intermediate language?
05:48:35 <Axman6> not yet
05:48:43 <Phyx-> mreh: it's in the nightly builds
05:48:48 <Phyx-> should be out on 6.14 no?
05:48:50 <kmc> Phyx-, http://llvm.org/
05:49:14 <zygoloid> jaj: the machine code produced by GHC is very unusual. equivalent C code could be written, but it would probably be harder than writing C-like code in haskell.
05:49:55 <hptans> i need a book in haskell, what you recommend?
05:50:06 <kmc> @where LYAH
05:50:06 <lambdabot> http://www.learnyouahaskell.com/
05:50:07 <kmc> @where RWH
05:50:08 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:50:11 <zygoloid> the continuation-passing-style mechanism used by GHC can indeed produce very efficient code sometimes (better than idiomatic C)
05:50:11 <kmc> hptans, both of these ^^^^
05:50:21 <Phyx-> quicksilver: ah ok
05:50:23 <Twey> Phyx-: http://en.wikipedia.org/wiki/LLVM
05:50:29 <kaustuv> kmc and others: I'm going to have to shelve this effort. Thanks for your suggestions.
05:50:32 <zygoloid> hptans: if you're a beginner, learnyouahaskell is probably the best place to start.
05:51:13 <hptans> ok, i am a beginner in functional programming, i already know C
05:51:25 <Twey> hptans: I recommend RWH.
05:51:31 <Axman6> hptans: knowing C won't help you
05:51:37 <kmc> hptans, regarding speed: the simplest Haskell solution is usually not fast, but will take very little time to write compared to C
05:51:52 <kmc> hptans, then you can spend time optimizing the parts that matter, whereas C basically forces you to spend that time everywhere
05:51:56 <Twey> Well… FSVO ‘not fast’
05:52:00 <Phyx-> Twey: ah, thanks, that wiki page cleared it up. In my head i thought it was some jitted language
05:52:11 <kmc> Phyx-, it is, among other things, that
05:52:19 <quicksilver> Phyx-: LLVM is lots of things.
05:52:22 <Twey> It's probably not going to be very fast, but it will generally be adequate
05:52:27 <quicksilver> there is, indeed, a JIT for it.
05:52:35 <Phyx-> lol :/
05:52:55 <jaj> does LLVM fix the cross-platform problems and bootstrapping?
05:52:56 <Phyx-> but GHC uses it as an intermediate language for optimizations right?
05:52:59 <hptans> ok, Haskell+learnyouahaskell or Scheme + SICP  what is better for me?
05:53:07 <hptans> sorry i have a lots of doubts
05:53:14 <Axman6> jaj: it may
05:53:18 <kmc> hptans, it depends on what you want to do
05:53:41 <kmc> hptans, SICP is a fantastic book though, one of the best introductory computer science texts
05:53:49 <kmc> hptans, you should definitely read it at some point
05:53:58 <kmc> and you should definitely learn scheme, even if you won't use it much
05:54:16 <zygoloid> hptans: the SICP videos are great too
05:54:19 <Axman6> ((how (much do) (you like reading) (code that)) (looks like this) hptans?)
05:54:22 <hptans> kmc: why?
05:54:23 <kmc> Phyx-, no.  recent GHC can output LLVM, and use external (to GHC) optimizations that others have written for it
05:54:29 <quicksilver> jaj: no.
05:54:29 <kmc> hptans, why learn scheme?
05:54:35 <hptans> kmc: yes
05:54:46 <kmc> hptans, because it's a simple and beautiful language which will clarify your thinking about a lot of other languages and concepts
05:55:27 <kmc> hptans, it's very different from Haskell, from C, and from just about everything else
05:55:55 <Phyx-> kmc: and then what? are those tools then responible for compiling it? or do you just specify a tool to use somewhere in the pipeline afterwhich ghc takes over again
05:55:56 <zygoloid> hptans: Scheme+SICP would make a good foundation for FP in general, and would probably be helpful in thinking about how to structure code in haskell
05:56:00 <kmc> though the Lisp family (including Scheme) has been tremendously influential -- you'll see echoes of it in Javascript, Ruby, Haskell, everywhere
05:56:06 <kmc> Phyx-, the former
05:56:11 <kmc> Phyx-, GHC has no way to input LLVM
05:56:17 <kmc> Phyx-, LLVM output takes the place of C or asm output
05:56:39 <kmc> and the LLVM tools are responsible for producing native code (statically or JIT), or interpreting directly
05:56:53 <Phyx-> alright
06:03:02 <ketil> Er - what network is this channel on?  (And how do I find out?)
06:03:07 <kmc> FreeNode
06:03:43 <ketil> thank you, kmc :-)
06:04:33 * kmc still thinks it's silly that "functional programming" is this weird little side thing only a few people learn, when it's a good foundation for OOP and most other 'paradigms'
06:05:34 <Axman6> m3ga: are you around?
06:05:56 <m3ga> yep!
06:06:10 <m3ga> Axman6: yep!
06:06:34 <Axman6> all set for AusHac?
06:08:44 <Axman6> hmm, Google Sydney has a great location
06:10:27 <m3ga> yep, building up for it. been doing some massive hacking on ddc i want to continue on.
06:11:06 <m3ga> Axman6: google location is ok, but my work has an even better one :-)
06:11:39 <Axman6> excellent :)
06:12:29 <Axman6> m3ga: how accurate is this location for where FP-Syd is going to be? http://tinyurl.com/27laask
06:14:38 <Axman6> ah, searching for Google Sydney seems to give a better location
06:15:15 <Axman6> and its right near the casino, light rail++
06:15:17 <m3ga> the google map location is the suck
06:15:34 <Axman6> heh
06:16:39 <m3ga> Axman6: what time will you be in sydney. a couple of us meet up at a pub at about 5pm.
06:17:07 <Axman6> i'm arriving about noon on wednesday
06:19:32 <m3ga> pub is oscars tavern, in Union st pyrmont, just where Pyrmont Bridge road breaks off Union
06:20:00 <Axman6> got a google maps link for me? :)
06:47:01 <djahandarie> dons, in http://www.galois.com/~dons/talks/decade-white.pdf it says "Put type sigs in 'when you're done' with the design". What do you mean by done with the design? Is "design" something you do in Haskell?
06:48:54 <Phyx-> why isn't compile with profiling support the default for cabal under windows?
06:49:12 <quicksilver> it isn't the default on any platform.
06:49:17 <quicksilver> Because it doubles compile times, I suppose.
06:49:17 <Phyx-> the ghc ships with profiling version of it's own libraries, and it would save alot of times later on
06:49:30 <Heffalump> djahandarie: not particularly formally
06:49:34 <Phyx-> quicksilver: I rather have that then having to reinstall all my packages :/
06:49:37 <Heffalump> but projects tend to go through prototyping
06:49:55 <kmc> Phyx-, i think you can configure your cabal for that default
06:50:13 <djahandarie> Heffalump, usually the way I work is I put in type signatures before I even write my functions
06:50:15 <Phyx-> kmc: yeah, i already have, but only recently
06:50:19 <kmc> Phyx-, off by default makes sense in a world where most users are not developers.  for Haskell this may be more of a goal than a reality :)
06:50:23 <Phyx-> now i have to reinstall a plethora of packages
06:50:24 <Phyx-> lol
06:50:33 * hackagebot hprotoc 1.7.1 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-1.7.1 (ChrisKuklewicz)
06:50:36 <kmc> though -- once you have lots of users, it's nice to coerce them into being developers ;)
06:50:50 <Phyx-> kmc: end user software isn't delivered via cabal one would hope
06:51:09 <kmc> Phyx-, how else to deliver? statically linked binary?
06:51:29 <Phyx-> I would assume so, don't most real projects have dependencies that cabal can't deal with
06:51:37 <kmc> i've no idea
06:51:47 <kmc> i think most "real projects" in Haskell are not released at all
06:52:08 <Phyx-> kmc: lol
06:52:18 <kmc> most software in general isn't
06:52:28 <kmc> it's in-house stuff
06:52:52 <Phyx-> kmc: but even so, that's usually deployed in terms of binaries not source
06:53:17 <kmc> depends
06:53:25 <kmc> anyway xmonad seems like a "real project"
06:53:40 <Phyx-> would it be hard to say, first time cabal is ran, to aska  few questions? like would you like to enable profiling etc?
06:53:41 <kmc> and if someone had a linux distro without xmonad in the package manager
06:53:45 <kmc> then i'd advise them to use cabal
06:53:53 <kmc> but perhaps this is bad advice.
06:54:04 <Heffalump> djahandarie: I think that's another valid approach
06:54:12 <kmc> i do think xmonad's cabal file captures its dependencies
06:54:13 <Phyx-> after compiling xmonad you would still need to put it in the right place don't you?
06:54:21 <Phyx-> it doesn't magically find its way
06:54:21 <kmc> i'm not sure what you mean
06:54:27 <kmc> cabal will install binaries for you
06:54:40 <kmc> when i do "cabal install pony" i get a binary
06:54:44 <Phyx-> will it install them in any folder you want? didn't know that
06:55:07 <kmc> it will install them into the prefix you've chosen
06:55:28 <Phyx-> right, but again, you still have to change the prefix
06:55:51 <kmc> i think cabal install for system-wide would install in /usr/local or something
06:55:54 <kmc> on Linux
06:55:58 <kmc> xmonad doesn't have to be anywhere special
06:56:20 <Phyx-> well, on windows, or atleast my machines
06:56:32 <Phyx-> cabal installs to some folder not on my path
06:56:57 <kmc> yeah
06:57:00 <kmc> i don't know the windows side
06:57:22 <kmc> left that world years ago, no regrets :)
06:58:26 <Phyx-> i also have no regrets on staying with it
06:58:32 <kmc> ok
06:59:42 <Phyx-> but that's now what this about
06:59:42 <Phyx-> lol
07:01:03 <Phyx-> my original point was, that about 90+% of the people using cabal are developers (i'm purely speculating here). It would seem more beneficial to have profiling enabled by default. the down side is a longer compile time, but it's not like most things take long anyway
07:01:48 <Phyx-> or ask on first run, that shouldn't be too bad would it?
07:03:06 <Phyx-> then again, I wonder how many people would type no, so maybe the current values are the best
07:03:10 <Phyx-> *shrug*
07:03:18 * Phyx- hands kmc a cookie
07:04:35 <quicksilver> Phyx-: that's your fault for not putting it in your path, surely?
07:04:48 <Phyx-> why can't it just do it
07:04:56 <quicksilver> on linux it installs to ~/.cabal/bin which surely isn't in ones default path
07:04:59 <quicksilver> but it's trivial to add.
07:05:17 <quicksilver> I dunno. It's considered bad manners to modify the user's path, I think.
07:06:33 <Phyx-> quicksilver: but the implication i made was that end user software probably isn't delivered with cabal, because it among other won't do stuff like that. e.g. modify paths etc
07:06:51 <quicksilver> end users probably don't want to compile stuff.
07:06:54 <quicksilver> I certainly don't.
07:07:21 <ben__> Hello all. Can anyone point me towards a simple Haskell image library? All I desire is to be able to specify the position and colour, then display on the screen or output to an image (ideally both). (I'm thinking something similar to CImg for C++ if you are familiar with it). Simpler is better. Many thanks for your help.)
07:07:55 <Phyx-> correct, which is the point i agrued, in that we can wouldn't it be sensible to enable profiling by default, since the base libs already have them enabled, or ask on first run.
07:08:40 <Phyx-> errr. remove "we can" from that sentence
07:09:38 <Phyx-> wow
07:09:44 <Phyx-> let me retype that sentence
07:10:06 <Phyx-> *correct, which is the point i argued, in that wouldn't it be sensible to enable profiling by default, since the base libs already have them enabled, or ask on first run.
07:11:32 <Phyx-> ben__: sorry, never done image processing in haskell
07:13:13 <Phyx-> quicksilver: or am i just spouting nonsense? :P
07:13:47 <gbacon> ?src (***)
07:13:48 <lambdabot> f *** g = first f >>> second g
07:14:01 <gbacon> ?src (&&&)
07:14:02 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
07:14:03 <ClaudiusMaximus> ben__: for plotting pixels IOUArray (Int,Int,Int) Word8  might work if the in-memory representation is sane, then you could display with OpenGL textured quad quite easily, or output to PPM quite easily.
07:14:44 <gbacon> ?pf \f -> f *** f
07:14:44 <lambdabot> Maybe you meant: bf pl
07:14:48 <ClaudiusMaximus> where the triple is height/width/channels
07:14:53 <gbacon> ?pl \f -> f *** f
07:14:53 <lambdabot> join (***)
07:19:19 <ben__> Alright guys, thanks for your help! I might give openGL a try, otherwise I guess I can always output image data in a format I can easily render with a simple C program. Thanks for your help
07:19:55 <quicksilver> Phyx-: You make reasonable points. I hate software which asks me questions when I install it.
07:20:02 <quicksilver> Phyx-: but I'm probably irrational.
07:24:36 <ClaudiusMaximus> i would like if cabal-install's bootstrap script compiled its dependencies with profiling enabled so i don't have to reinstall them after enabling profiling in my ~/.cabal/config - but i just looked into bootstrap.sh and there's an envVar you can set to do that
07:25:18 <ClaudiusMaximus> bootstap.sh calls ./Setup configure ... ${EXTRA_CONFIGURE_OPTS} ...
07:26:05 <yitz> too late, ben__ left already, but there's a new library called "wumpus" that probably is what he's looking for. like cairo, but far lighter and simpler.
07:27:08 <yitz> i sure hope that cabal won't start enabling profiling by default
07:30:23 <ClaudiusMaximus> yitz: same here i guess; but the "EXTRA_CONFIGURE_OPTS=--enable-library-profiling ./bootstrap.sh" (or whatever the flag should really be) will save me having to recompile parsec/network/Cabal/mtl/HTTP/zlib with profiling enabled if i so happen to want to profile a program that indirectly uses one or more of them
07:31:54 <quicksilver> ClaudiusMaximus: the platform comes with everything enabled for profiling
07:32:02 <quicksilver> ClaudiusMaximus: (including c-i and its dependent libs)
07:32:08 <Phyx-> yitz: why not, what's the downside
07:37:57 <ManateeLazyCat> Have any function return the bin path of cabal ?
07:38:42 <ClaudiusMaximus> quicksilver: i prefer to get a ghc binary, get cabal-install, then go from there (have had bad experiences mixing distribution packages with cabal-install packages, and not everything i need is in my distribution)
07:39:02 <kowey> hi all, any tips for how to deal with this haddock + cpp interaction? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27346#a27348
07:39:35 <quicksilver> ClaudiusMaximus: your comments don't appear to explain what you don't like about the platform.
07:39:52 <quicksilver> ClaudiusMaximus: I can understanding worrying about the tension between the c-i'ed packages and dist packages
07:40:04 <quicksilver> ClaudiusMaximus: but the platform is just a convenient way to bootstrap your GHC and c-i. Why wouldn't you use it?
07:40:19 <yitz> Phyx-: because i almost never use profiling, why should i have to manually disable it every time?
07:40:20 <ManateeLazyCat> kowey: You can check gtk2hs's source code to study how to use haddock with cpp.
07:40:33 <kowey> thanks! do you have a specific module I could at
07:40:40 <kowey> err, *look at?
07:41:15 <yitz> ClaudiusMaximus: yeah, in the very rare case that i do need profiling, it would be nice to be able to just turn it on without having to worry about libs
07:41:26 <ClaudiusMaximus> quicksilver: because i'm scared of things i've never tried before :)
07:41:31 <kowey> (the problem here being that 'bug' is a cpp macro but also a common word you may want to say in a haddock comment in English)
07:42:05 <ManateeLazyCat> kowey: https://patch-tag.com/r/AndyStewart/gtk2hs-sync-mirror/snapshot/current/content/pretty
07:44:37 <yitz> kowey: cpp will definitely apply to the word bug in the comment.
07:45:11 <kowey> yitz: yeah, hence the funny looking haddock complaint in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27346#a27348
07:45:25 <quicksilver> ClaudiusMaximus: OK, well, the platform is a good way of getting a working GHC + c-i + some generally useful packages, with profiling enabled.
07:46:14 <ClaudiusMaximus> quicksilver: i'll look into it next time i need to get a fresh ghc :)
07:46:16 <yitz> kowey: i don't see any way around avoiding those kinds of words for cpp macros
07:47:25 <kowey> yitz: ok, thanks
07:47:43 <kowey> I guess the path of least resistance for now is to s/bug/error/ in the comment
07:47:56 <yitz> quicksilver: what? HP packages are all compiled for profiling?
07:48:06 <kowey> although will just creep up again later if we don't rename bug to eg. dbug in the long run
07:48:20 <yitz> kowey: s/bug/ BUG/
07:48:30 <yitz> uh, without the space
07:48:48 <yitz> DBUG even better
07:48:56 <kowey> you mean the macro, right?
07:49:12 <quicksilver> yitz: the haskell platform comes with profiling libraries, yes. Why would it not?
07:49:28 <yitz> right. it's a pretty well-accepted convention to name cpp macros with all caps
07:49:34 <kowey> that's not so nice because bug is really trying to look like a Haskell function, like error
07:49:36 <yitz> for this reason, among others
07:49:43 <kowey> but then again, I suppose it does make things quite explicit
07:50:27 <kowey> random comment: we've also macroed fromJust in the same fashion to report the line number of our source code
07:50:32 <yitz> kowey: i rarely see very much C-like usage of cpp like that in haskell. usually it's just #ifdef GHC and the like
07:51:06 <kowey> is this sort of thing (source code line numbers in errors) available in GHC yet?
07:51:28 <kowey> I dimly recall seeing something about it pass by on a mailing list, but maybe hallucinating?
07:51:48 <yitz> quicksilver: but doesn't enabling profiling slow everything down? but how can my non-profiling modules link against them?
07:53:19 <quicksilver> yitz: the same way as cabal --enable-profiling
07:53:26 <quicksilver> yitz: you get two copies of every library
07:53:30 <quicksilver> profiled and non-profiled.
07:53:32 <yitz> ah, i see
07:53:40 <quicksilver> kowey: you could try using cpphs
07:53:50 <quicksilver> kowey: it doesn't expand macros inside haskell comments 
07:54:07 <quicksilver> (and integrates more neatly with haskell in some other ways too)
07:54:35 <CakeProphet> @tell mtnviewmark I'm not quite sure that your solution is more concise. I'll be sure to show you the completed version once the instruction set is finalized so we compare techniques.
07:54:35 <lambdabot> Consider it noted.
07:54:53 <kowey> quicksilver: interesting idea, thanks... I'll broach it in #darcs
08:02:27 <Phyx-> yitz: if you don't use profiling you don't have to turn anything off
08:02:36 <Phyx-> the libs are always compiled double
08:02:42 <Phyx-> the reverse isn't true
08:02:49 <yitz> yeah quicksilver explained that.
08:02:58 <yitz> so then it just slows down compilation
08:03:04 <quicksilver> the only disadvantage with profiling is installing *new* libraries takes twice as long
08:03:10 <Phyx-> which doesn't take alot anyway
08:03:18 <quicksilver> the only reason to have it off for a binary download like the platform is disk space.
08:03:22 <quicksilver> disk space I really don't care about.
08:03:28 <yitz> and slightly more than doubles disk usage. not really too bad.
08:03:28 <quicksilver> compile time I can see that some people care about 
08:03:37 <quicksilver> some haskell packages do compile pretty slowly
08:03:56 <Phyx-> but the thing is, it already is on for the binary downloads
08:03:59 <quicksilver> so the current situation seems sane to me - profiling libs included in the haskell platform
08:04:01 <Phyx-> atleast for the corelibs
08:04:11 <quicksilver> but the default is off for new things you install by source
08:04:16 <quicksilver> and that default is extremely easy to change
08:04:22 <quicksilver> to me this seems the sensible solution.
08:04:32 <Phyx-> quicksilver: sure, if you know about it from the start
08:04:48 <Phyx-> i had to manually reinstall about 8 packages just to enable it
08:05:59 <Phyx-> oh well, i suppose that's a minor annoyance for the majority :)
08:21:33 <kmc> this channel is amazing
08:21:40 <kmc> i've realized that everywhere else on freenode
08:21:48 <kmc> the ratio of questions asked to questions answered is like 10:1
08:22:00 <quicksilver> yup, this channel breaks all accepted laws of IRC conduct
08:22:04 <gbacon> ?src (.)
08:22:05 <lambdabot> (f . g) x = f (g x)
08:22:05 <lambdabot> NB: In lambdabot,  (.) = fmap
08:22:07 <quicksilver> people are actually *nice* to each other here.
08:22:16 <yrlnry> #haskell is superb.
08:22:22 <yrlnry> #git is excellent also.
08:22:45 <yrlnry> #perl is a hive of scum and villainy.
08:22:57 <djahandarie> A lot of questions get answered in #mysql but the air is kinda tense over there
08:23:00 <Phyx-> kmc: yes, this channel is abour 10:2
08:23:02 <Phyx-> :)
08:23:31 <kmc> i'm not even talking about the civility aspect
08:23:45 <zygoloid> this channel is great. but it seems to lose some of its greatness over the weekends :(
08:23:51 <kmc> just the chances that your question will go totally ignored
08:24:12 <Phyx-> i can't tell you how much i hate the "google" it answer
08:24:22 <Phyx-> people who do that go instantly on my ignore list
08:24:26 <kmc> sometimes that is the right answer
08:24:33 <kmc> i try not to be a dick about it
08:24:54 <kmc> but sometimes you *have* googled it and found nothing
08:25:17 <kmc> for a very general question of the form "what's foo", where "foo" or "foo haskell" finds it in the top few results, i think "google it" is a reasonable response
08:25:28 <Phyx-> more likely than not I have searched and found nothing, #haskell is almost a last resort really
08:26:04 <kmc> i've had a few negative experiences in other language channels
08:26:18 <Phyx-> oh no doubt, so have I
08:26:29 <kmc> which don't seem to happen here
08:26:31 <Phyx-> which is why, #haskell and #haskell-blah are the only channels i am in
08:26:40 <Phyx-> #csharp isn't bad either
08:27:04 <Phyx-> even if they don't know the answer, they're helpful in that i can bounce ideas off them
08:27:17 <Phyx-> which is also *usually* the case here
08:27:22 <djahandarie> I think this channel gets a little weird when someone comes here and tries to troll
08:27:27 <Phyx-> if the appropriate people are online :P
08:27:27 <kmc> one thing i've never seen here is someone getting flamed for giving incorrect responses
08:28:07 <zygoloid> another thing i've seen here but nowhere else is people realizing they're wrong and apologising
08:28:08 <kmc> in another language channel i answered a couple dozen beginners' questions correctly over a period of weeks, then i got something wrong about a tricky corner of the language, and the immediate response was "gtfo idiot"
08:28:20 <Phyx-> heh
08:28:29 <zygoloid> kmc: ##c++? :)
08:28:42 <kmc> whenever i've given an incorrect response here i seem to get an immediate but polite correction
08:28:48 <kmc> zygoloid, close ;P
08:29:11 <kmc> djahandarie, weird how?
08:29:33 <Phyx-> i've had people in ##c almost lynch me once, for having asking about mutually recursive structures
08:29:51 <Phyx-> asked*
08:30:10 <zygoloid> Phyx-: this is why you should be careful not to tell them where you live ;)
08:30:19 <Phyx-> lol
08:30:55 <djahandarie> kmc, I think there have been instances where everyone is responding to a troll and legitimate questions have been ignored. I've seen a few times where the troll would have been handled a lot better with a +q
08:31:27 <Phyx-> In my experience, people in #haskell are much more open to out-of-the-box thinking than the traditional language channels like ##c and ##c++
08:31:32 <quicksilver> sure, but the direct honest response to trolls is one of the charming things, too.
08:31:36 <quicksilver> occasinally quite amusing results.
08:31:52 <Phyx-> quicksilver: agreed :P
08:31:58 <djahandarie> I like the fact that people are given the benifit of the doubt that they are not trolling, but sometimes it's clear but the conversation seems to be extended just to have fun
08:32:28 <alexbobP> So how come haskell sucks so much
08:32:47 <alexbobP> (just kidding, it is me who sucks at haskell...)
08:33:13 <pikhq> alexbobP: Don't you know? It comes with free cookies & blowjobs.
08:33:31 <Phyx-> rofl.. so haskell isn't rated G? :P
08:34:04 <alexbobP> pikhq~> oh, awesome.  I need to learn mah monads!
08:34:14 * alexbobP searches for blowjobs on hoogle
08:34:33 <pikhq> :P
08:34:59 * Phyx- stops procrastinating and goes to modify his tool
08:35:26 <kmc> in my experience, people in #haskell are self-congratulatory about how great #haskell is ;)
08:35:30 <kmc> but it is true
08:35:41 <kmc> cabal install blowjob
08:35:57 * Phyx- stops himself from making a joke
08:36:03 <Phyx-> since on mondays.. there are no warnings
08:36:06 <Phyx-> 14:32:29 -!- mode/#haskell [+o quicksilver] by ChanServ 14:32:29 -!- Lajla was kicked from #haskell by quicksilver [On Mondays, there are no warnings.] 
08:36:09 <Phyx-> :P
08:36:50 <kmc> haha
08:36:59 <kmc> is it pantsless tuesday already
08:37:26 <Phyx-> no, a couple of more hours
08:38:24 * Phyx- hugs GHC
08:40:01 * Phyx- did not know types can be prefixed with package names
08:40:33 <kmc> with a colon?
08:41:03 <kmc> i sometimes see things like "base-4.2.0.0:Maybe" in output
08:41:10 <kmc> but i don't think that's actually valid input syntax
08:41:42 <kmc> another thing i love about this channel is that i learn something new absolutely every day i'm here
08:41:48 <Phyx-> kmc: yeah, that's where i spotted it
08:42:01 <kmc> granted that's probably true of many channels
08:42:02 <Phyx-> i don't indeed know if it's valid syntax
08:42:28 <Phyx-> however, i still haven't found out how to print out the context out
08:42:43 <kmc> i think the closest you can do on input is {-# LANGUAGE PackageImports #-} import qualified "base-4.2.0.0" Prelude as Base4200Prelude
08:42:47 <Phyx-> instead of like Num a => a -> a it gives me something like t
08:42:55 <Phyx-> instead of like Num a => a -> a it gives me something like t_eue -> t_eue
08:42:56 <kmc> gwa?
08:43:06 <kmc> what is printing this?
08:43:11 <kmc> you're using ghc api or something?
08:43:15 <Phyx-> yeah
08:44:01 <Phyx-> someone suggested using GHC.showSDocForUser unqual (GHC.pprTypeForUser False ty)
08:44:07 <Phyx-> but it gave the same results
08:48:57 <djahandarie> It'd be nifty if something could parse your code and draw diagrams of the logic
08:49:11 <djahandarie> Especially stuff like arrows
08:50:36 <int80_h> < pi :: CReal
08:50:46 <int80_h> > pi :: CReal
08:50:47 <lambdabot>   3.1415926535897932384626433832795028841972
08:56:39 <int80_h> I would like to be able to express pi as a CReal
08:56:44 <int80_h> > pi :: CReal
08:56:45 <lambdabot>   3.1415926535897932384626433832795028841972
08:56:52 <int80_h> which package do I need?
08:57:14 <ben> I cannot think of a pie/cereals joke, send help
08:57:48 <int80_h> CReal pi?
08:57:48 <Phyx-> :t pi
08:57:50 <lambdabot> forall a. (Floating a) => a
08:58:03 <Phyx-> int80_h: you don't need any i think
08:58:11 <int80_h> Phynx, I do.
08:58:11 <Phyx-> @index CReal
08:58:12 <lambdabot> bzzt
08:58:24 <Phyx-> int80_h: oh, CReal is probably in Foreign.C.Types
08:58:25 <zygoloid> @hackage numbers
08:58:25 <lambdabot> http://hackage.haskell.org/package/numbers
08:58:31 <int80_h> pi :: CReal doesn't work in my ghci as it is right now
08:58:32 <zygoloid> ^^ it's in there
08:58:47 <int80_h> so it seems I would need something that is missing
08:58:56 <zygoloid> int80_h: you need the numbers package
08:59:06 <djahandarie> It's Data.Number.CReal.CReal in numbers
08:59:06 <int80_h> ah numbers. I htink I may have that let me check
08:59:11 <int80_h> oooh!
08:59:23 <zygoloid> CReal is quite unrelated to the FFI CFloat and CDouble :)
08:59:32 <djahandarie> (Confusingly)
08:59:42 <Phyx-> hey, it's prefixed with "C" my reasoning was sound :P
08:59:43 <zygoloid> yeah, perhaps not the best choice of name :(
09:00:22 <Phyx-> is it refering to Complex Real?
09:00:29 <djahandarie> No
09:00:49 <djahandarie> It's a dynamic precision library
09:01:22 <djahandarie> augustss maintains it I believe
09:01:33 <int80_h> how do I load the numbers package into ghci?
09:01:40 <djahandarie> The C is apparently for "constructive"
09:02:01 <soupdragon> computable ?
09:02:08 <djahandarie> int80_h, import the package
09:02:15 <int80_h> colloquial?
09:02:23 <djahandarie> Ugh
09:02:34 <djahandarie> import the module*
09:02:49 <djahandarie> If you have the package on your system you should have access to the module
09:03:02 <djahandarie> (As long as it isn't hidden)
09:04:02 <djahandarie> :m + Data.Number.CReal    is one way to do it
09:04:07 <BMeph> ben: What, are your pi(e) and cereal skills a little..."crusty"? ;þ
09:05:05 <int80_h> djahandarie :L it says Data.Number.CReal 'Could not find module'
09:05:07 <Phyx-> *golf clap*
09:05:15 <Phyx-> int80_h: :m +
09:05:18 <Phyx-> not :l
09:05:26 <int80_h> Sorry I mean it says Could not find module 'Data.Number.CREal'
09:05:32 <djahandarie> int80_h, if it can't find the module you need the numbers package
09:05:48 <djahandarie> int80_h, get it from your distribution. If your distribution doesn't have it, you can get it from cabal
09:05:56 <int80_h> hmm I just installed it, maybe I need to quit ghci and start it again
09:06:02 <Phyx-> int80_h: module names are case sensitive
09:06:31 <Phyx-> it's easy to check if you have it. type on a commandline ghc-pkg find-module "Data.Number.CReal"
09:06:39 <Phyx-> it if shows no result you don't have it
09:06:43 <needshelp> need help: http://miburl.com/fFytK4  plz!!
09:07:03 <djahandarie> Don't click that link
09:07:04 <djahandarie> @ops
09:07:05 <lambdabot> Maybe you meant: docs oeis pl
09:07:08 <djahandarie> @where ops
09:07:09 <geheimdienst> @where ops
09:07:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
09:07:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
09:07:20 --- mode: ChanServ set +o Igloo
09:07:23 <BMeph> Oh, quicksilver...
09:07:28 <Phyx-> oh god damnit
09:07:31 --- mode: Igloo set +b *!*@gateway/web/freenode/ip.60.228.242.112
09:07:34 <Phyx-> that link is disturbing
09:07:37 --- kick: needshelp was kicked by Igloo (needshelp)
09:07:38 <geheimdienst> thanks, igloo
09:07:40 <BMeph> Ooh, Igloo, even better!
09:07:46 <BMeph> Igloo++
09:07:55 <Phyx-> Igloo++
09:08:02 <Phyx-> now.. how do i get those images out
09:08:11 <int80_h> okay it says I have the package numbers-2009.8.9
09:08:27 <Phyx-> 18:06:25 < djahandarie> Don't click that link
09:08:36 <Phyx-> why didn't i see that before i clicked
09:09:13 <ben> Can you elaborate on "don't click that link"?
09:09:19 <ben> I fear my curiosity will be getting the better of me
09:09:30 <Phyx-> ben: DON'T
09:09:42 <Igloo> If you must, on -blah, please
09:09:45 <Phyx-> int80_h: and what does ghc-pkg field numbers exposed
09:09:46 <int80_h> okay I have loaded the module
09:09:47 <Phyx-> say?
09:09:47 <Saizan> int80_h: so, does ":m + Data.Number.CReal" work?
09:10:12 <int80_h> Saizan, yes but I am getting syntax wrong for expressing pi as a CReal
09:10:19 <int80_h> pi :: CReal doesn't work
09:10:30 <int80_h> wait!!
09:10:33 <int80_h> it works
09:10:33 <ben> :I
09:10:36 <Phyx-> :/
09:10:38 <ben> Is it a browser exploit, or a shock picture, or what 
09:10:50 <int80_h> probably the guy with the missing colon
09:11:04 <int80_h> that still burns in my brain a decade later
09:11:17 <Igloo> ben: If you must, on -blah, please
09:11:21 <kmc> i'm guessing all of the above
09:11:35 <int80_h> where is the "internet 2", where goatse doesn't exists anymore and it is a wonderful academic wonderland?
09:11:39 <ben> All right
09:12:23 <geheimdienst> but the internet 2 will include lolcats, right? right?
09:12:38 <int80_h> no cats, kittens, or frogs of any kind.
09:12:42 <kmc> goatse is not IPv6 compatible
09:12:56 <geheimdienst> okay, i think the internet 2 is a complete non-starter
09:13:15 * geheimdienst thinks lolcats are to the internet what the gutenberg bible was to movable type
09:13:35 <int80_h> > pi :: CReal /2
09:13:36 <lambdabot>   Only unit numeric type pattern is valid
09:13:51 <Saizan> > (pi :: CReal) / 2
09:13:51 <int80_h> what is wron with my expression?
09:13:52 <lambdabot>   1.5707963267948966192313216916397514420986
09:13:55 <int80_h> ah
09:14:02 <djahandarie> int80_h, it thinks /2 was part of your type
09:14:15 <BMeph> int80_h: Short answer? UR DOIN IT RONG!!!111!11!!1ichi11!11
09:14:22 <djahandarie> > (pi / 2) :: CReal
09:14:23 <lambdabot>   1.5707963267948966192313216916397514420986
09:14:25 <djahandarie> That is also valid
09:14:33 <int80_h> hey is this the ubuntu channel?
09:14:43 <int80_h> I was confuzzled for a minute
09:14:54 <int80_h> thanks, much more readable
09:15:01 <djahandarie> int80_h, nope, this is #haskell
09:15:19 <int80_h> heh I was joking with BMeph
09:15:31 <djahandarie> Oh, lol
09:16:16 <int80_h> okay I go to tilt at windmills. I am trying to port libnova to haskell
09:16:28 <int80_h> and I imagine it will look very C-like at first
09:16:37 <int80_h> so I will need lots of feedback when I have some code to show
09:17:20 <AnAdorableNick> What was that link?
09:17:53 <djahandarie> AnAdorableNick, we're discussing it in #haskell-blah since it's off-topic in here
09:18:36 <soupdragon> what are you discussing?
09:18:56 * djahandarie sighs
09:19:06 <ben> haskell.
09:19:20 <soupdragon> thats not allowed in -blah
09:21:07 * Phyx- falls down laughing
09:23:55 <Phyx-> arg, i hate that ghc is always right
09:24:58 <c_wraith> it's so annoying that way
09:25:06 <c_wraith> it never lets me get away with wrong code
09:25:10 <zygoloid> Phyx-: not always. sometimes it's overly cautious
09:25:35 <BMeph> int80_h: I'd suggest, as long as you're tilting at windmills, try sipping some Bushmills! ;)
09:25:43 <Phyx-> exactly, it never gives me the benefit of the doubt :)
09:26:05 <zygoloid> it claims that "type instance a :<=: a = True; type instance a b :<=: a c = b :<=: c" is unsound, for instance.
09:27:01 <zachk> zygoloid: i have no idea what you are talking about but that does just look "wrong" imho 
09:27:46 <zygoloid> zachk: the point is that type family instances have to be equal wherever they overlap (otherwise the type system is unsound)
09:28:04 <Phyx-> zachk: why does it look wrong?
09:28:10 <Phyx-> it seems reasonable to me
09:28:18 <Phyx-> :t any
09:28:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:28:24 <Phyx-> :t any elem
09:28:25 <lambdabot>     Couldn't match expected type `Bool'
09:28:26 <lambdabot>            against inferred type `[a] -> Bool'
09:28:26 <lambdabot>     In the first argument of `any', namely `elem'
09:28:31 <Phyx-> :t elem
09:28:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:28:43 <Phyx-> :t any (flip elem [])
09:28:44 <lambdabot> forall a. (Eq a) => [a] -> Bool
09:29:04 <Goldy> what's a good way of doing [(1,2), (3,4)] -> [1,2,3,4]?
09:29:19 <zygoloid> ghc is not looking hard enough. it sees overlap on "a b :<=: a b" and sees that one gives True and the other gives "b :<=: b", but it's not able to see (by induction) that the latter must also be True.
09:29:36 <geheimdienst> createPipe gives me two things of type Fd. the easiest way to write into them is fdToHandle, then hPutStrLn, right?
09:30:11 <quicksilver> > concatMap ( \(a,b) -> [a,b]) ) [(1,2),(3,4)]
09:30:13 <lambdabot>   <no location info>: parse error on input `)'
09:30:17 <quicksilver> > concatMap ( \(a,b) -> [a,b] ) [(1,2),(3,4)]
09:30:18 <lambdabot>   [1,2,3,4]
09:30:24 <quicksilver> Goldy: ^^ like that, probably
09:30:25 <Phyx-> > concatMap (\(a,b)->[a,b]) [(1,2), (3,4)]
09:30:25 <zygoloid> geheimdienst: sounds reasonable to me.
09:30:26 <lambdabot>   [1,2,3,4]
09:30:32 <Phyx-> oh, beaten  to it
09:30:33 <Phyx-> :P
09:30:48 <Goldy> thanks guys
09:30:54 <geheimdienst> okay thanks
09:32:04 * hackagebot cfopu 1.0.0 - cfopu processor  http://hackage.haskell.org/package/cfopu-1.0.0 (ByronJohnson)
09:33:12 <Phyx-> Goldy: foldr (\(a,b) c->a:b:c) []  [(1,2),(3,4)] also works, and should be more efficient
09:33:41 <BMeph> Woot, the Phyx is IN! ;)
09:33:57 <Phyx-> hm?
09:34:09 <quicksilver> Phyx-: I'm not sure. Doesn' concatMap have RULES for this kind of thing?
09:34:53 <Phyx-> quicksilver: that might very well be the case :) never looked at prelude
09:35:00 <Phyx-> the source of i mean
09:35:12 <zachk> where are the sources to modules for haskell anyways? 
09:35:20 <Goldy> Phyx-, yeah, i settled for something a lot like that (this was actually for a python program). reduce(lambda a, b: list(a + b), [(1,2), (3,4)])
09:35:59 <Phyx-> Goldy: ah
09:36:37 <Phyx-> zachk: it depends, packages are on hackage and corelibs are on haskell/org/ghc/docs
09:37:31 <Phyx-> haskell.org*
09:42:35 <bfrog> does haskell have built in or a library that allows the creation of something close to erlang's processes?
09:43:19 <zachk> forkIO ??! 
09:45:17 <kmc> bfrog, not standard Haskell 98
09:45:22 <geheimdienst> bfrog, check http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Concurrent.html , in particular forkIO and forkOS
09:45:25 <kmc> GHC supports lightweight threads
09:45:30 <kmc> but not distribution over multiple machines
09:48:04 <kmc> in particular you should probably ignore forkOS
09:48:11 <kmc> it is poorly named and does not do what people expect
09:48:21 <kmc> forkIO is the basic way to spawn threads in GHC Haskell
09:48:34 <kmc> you can communicate with MVar, Chan, etc.
09:48:47 <bfrog> what if I wanted something that can do fully what erlang does but with haskell?
09:48:52 <bfrog> as in, distributed
09:49:12 <kmc> then it's trickier
09:49:17 <kmc> not aware of an out of the box solution
09:50:03 <kmc> bfrog, this package may be useful: http://hackage.haskell.org/package/net-concurrent
09:50:07 <kmc> as well as many others on hackage
09:50:48 <kmc> bfrog, there's also an implementation of the Erlang network protocol in Haskell: http://hackage.haskell.org/package/erlang
09:51:46 <zygoloid> bfrog: there was Glasgow Distributed Haskell: http://www.macs.hw.ac.uk/~dsg/gdh/  however it seems to have been dead for a while, sadly
09:51:59 <djahandarie> That's a nifty package
09:52:18 <djahandarie> The github for it seems to have disappeared though
09:53:57 <soupdragon> > 1/(1+0.2)
09:53:58 <lambdabot>   0.8333333333333334
09:54:17 <soupdragon> > 1 - 0.2 + 0.2^2 - 0.2^3 + 0.2^4 - 0.2^5 + 0.2^6
09:54:18 <lambdabot>   0.8333440000000001
09:54:31 <int80_h> > a = 1
09:54:32 <lambdabot>   <no location info>: parse error on input `='
09:55:24 <soupdragon> here's a funny one  (p-1)p + p^2 + (p-1)p^3 + ...
09:55:53 <soupdragon> > (0.2-1)*1 + 0.2 + (0.2-1)*0.2^2 + 0.2^3 + (0.2-1)*0.2^4 + 0.2^5 + (0.2-1)*0.2^6
09:55:54 <lambdabot>   -0.6250112000000001
09:56:05 <soupdragon> = ?(0.2)?
09:57:47 <soupdragon> > 0.2/(1-0.2) - 1/(0.2-1)
09:57:49 <lambdabot>   1.5
09:57:58 <soupdragon> > 1/0.625
09:57:59 <lambdabot>   1.6
09:58:06 <soupdragon> > 1/(0.2/(1-0.2) - 1/(0.2-1) + 0.2)
09:58:08 <lambdabot>   0.5882352941176471
10:05:31 <Jonno_FTW> Why won't this work: Prelude Codec.Compression.GZip Data.ByteString Control.Applicative> decompress <
10:05:34 <Jonno_FTW> $> Data.ByteString.readFile "bt_level1.gz"
10:06:02 <zachk> can the hating problem be expressed in constructive logic? 
10:06:11 <Jonno_FTW> I get a type error
10:06:30 <Jonno_FTW> it expects `Data.ByteString.Lazy.Internal.ByteString'
10:06:38 <c_wraith> I'm unfamiliar with the hating problem.
10:06:40 <Jonno_FTW> but inferred ByteString
10:07:01 <Philippa> c_wraith: it's what happens to people who're too lazy to reach the l key
10:07:22 <Saizan> Jonno_FTW: use Data.ByteString.Lazy.readFile
10:07:31 <Goldy> what's the hating program?
10:07:35 <Goldy> oh, hahah
10:07:39 <Goldy> i get it
10:07:46 <Goldy> good one Philippa 
10:08:14 <Philippa> zachk: I believe so, but I've not seen it done myself
10:08:37 <djahandarie> > foldl1' (+) . snd $ mapAccumL (\a x -> (not a, if a then negate x else x)) False (take 50 $ iterate (join (*)) 0.2)
10:08:38 <lambdabot>   0.16159744000655357
10:09:03 <djahandarie> > 1 - foldl1' (+) . snd $ mapAccumL (\a x -> (not a, if a then negate x else x)) False (take 50 $ iterate (join (*)) 0.2)
10:09:05 <lambdabot>   0.8384025599934464
10:09:13 <int80_h> > 1 :: Unsigned Short
10:09:15 <lambdabot>   Not in scope: type constructor or class `Unsigned'Not in scope: type constr...
10:09:19 <zachk> if it could then you could construct a function to negate falses as well 
10:09:35 <zachk> but i dont know that much about constructive logic but i remember that not being included 
10:09:57 <djahandarie> > 1 - foldl1' (+) . snd $ mapAccumL (\a x -> (not a, if a then negate x else x)) False (take 5000 $ iterate (join (*)) 0.2)
10:09:58 <lambdabot>   0.8384025599934464
10:09:59 <Saizan> what do you mean by "negate falses"?
10:10:50 <mux> I interepret that as taking the absolute value of a number
10:11:51 <Philippa> zachk: expressing the problem isn't the same as expressing its solution
10:12:30 <zachk> im guessing thats an issue of semantics of for the life of me i can not the understand the definition of it (semantics) 
10:13:44 <int80_h> > Word :: 1
10:13:45 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
10:13:45 <lambdabot>         against inferred t...
10:15:19 <int80_h> > 1 :: Word
10:15:20 <lambdabot>   1
10:15:45 <hpc> > maxBound :: Word
10:15:46 <lambdabot>   18446744073709551615
10:15:46 <lambdabot> hpc: You have 1 new message. '/msg lambdabot @messages' to read it.
10:18:16 <llama> is there any way to do these list comprehensions in a more dynamic way: http://pastebin.com/bD863Sb8 ?
10:18:50 <jmcarthur> more "dynamic"?
10:18:54 <kmc> you want a function like «choose n xs», returning all the ways to choose n things from xs?
10:19:03 <llama> yes
10:19:15 <kmc> llama, write the recursion yourself
10:19:16 <jmcarthur> ah
10:19:18 <mauke> all of your first equations are redundant
10:19:29 <int80_h> it seems I do not have the module which defines Word. I see on haskell.org I can find word in Data. But I tried doing :m + Data in ghci, and that didn't work. What is the right way?
10:19:33 <llama> yeah, and I'd like to avoid having to do all that
10:19:35 <kmc> how do you choose 0 things from xs? how do you choose n things from []? how do you choose n things from (x:xs)?
10:19:45 <mauke> int80_h: where did you see that on haskell.org?
10:19:45 <jmcarthur> int80_h: :m Data.Word
10:20:01 <jmcarthur> int80_h: the module is Data.Word, and it exposes a type called Word
10:20:13 <int80_h> mauke :   http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/Data-Word.html
10:20:31 <jmcarthur> the module is Data.Word, not Data
10:20:44 <int80_h> gotcha
10:20:50 <hpc> and the type is Data.Word.Word
10:21:39 <llama> kmc: I was mostly wondering if it was possible to set up one list comprehension that would do that
10:22:04 <kmc> llama, i don't think it is
10:22:33 <djahandarie> If if it were I sure wouldn't do it in a list comprehension because it'd definitetly be impossible for anyone else to read
10:22:38 <llama> ok, thank you
10:33:58 <lowasser> Do *data* family instances have to always be fully saturated?
10:36:39 <Saizan> i'd think so, have you tried?
10:38:07 <lowasser> Yeah, and I'm getting failures
10:38:52 <tommd> Code snippet?
10:39:50 <lowasser> working working
10:40:32 <lowasser> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27360#a27360
10:41:20 <kmc> hmm how's it not saturated?
10:41:38 <lowasser> the thing I'm really interested in having work is the deriving (Bar) application
10:41:57 <kmc> hmm
10:42:01 <kmc> try StandaloneDeriving?
10:42:13 <kmc> deriving instance Bar (Foo Int)
10:42:28 <kmc> Foo is indeed fully saturated there, w.r.t its data family arity
10:42:34 <lowasser>     No family instance for `Foo Int'
10:42:34 <lowasser>     In the stand-alone deriving instance for `Bar (Foo Int)'
10:42:42 <kmc> it has kind not *, but all the family indices are specified
10:43:32 <lowasser> which is really weird
10:43:39 <lowasser> that it doesn't see the family instance
10:43:51 <kmc> yes
10:43:53 <kmc> seems like a bug
10:44:20 <lowasser> lol, I've been trying so many workarounds for this thing I want to do and they *all* lead to bugs
10:44:28 <kmc> :/
10:44:36 <kmc> open a ticket? or look for one
10:45:04 <lowasser> I mean, it's good to know, but I've filed at least two bug reports on other workarounds, and was hoping this one would work =P
10:45:12 <kmc> heh
10:48:07 <lowasser> bug filed
10:59:28 <int80_h> http://paste.org/pastebin/view/20470
11:00:35 <soupdragon> yuck
11:00:45 <ClaudiusMaximus> hm, is it likely to cause problems if my cabalized package has files named Foo.hs and foo.c ? (given that they will compile to Foo.o and foo.o which might be considered identical by some filesytems)
11:01:08 <int80_h> soupdragon : was that in response to my paste?
11:02:49 <otto_s_> int80_h: struct accessors are top-level functions.
11:03:32 <int80_h> otto_s : not sure what that means
11:03:36 <Phyx-> records
11:03:52 <Phyx-> int80_h: it means that for every label in the record a top level function is made
11:04:05 <otto_s_> Yeah, record, not struct, sorry.
11:04:05 <Phyx-> int80_h: the error you see is because it makes a function
11:04:22 <Phyx-> years :: LN_date -> Int and years :: LN_zonedate -> Int
11:04:37 <Phyx-> so two function with the same names
11:04:48 <geheimdienst> int80_h, your "seconds" is a function. so suppose d is some LN_dms, then you can say "seconds d" and it returns an Int, namely the seconds extracted from d. you can't have multiple functions with the same name "seconds"
11:05:25 <geheimdienst> a common workaround is to have a prefix for each member of a record ... dms_seconds, dms_minutes, etc.
11:06:05 <Phyx-> int80_h: another workaround is, that sinve LN_zonedate and LN_date are almost the same, just make them one type, then you can share label names
11:06:11 <int80_h> geheimdienst : it's not supposed to be a function. It's supposed to be a variable
11:06:34 <Phyx-> int80_h: you misunderstand records
11:06:44 <int80_h> yes I do
11:06:47 <Phyx-> int80_h: those labels generate top level accessor functions
11:07:00 <geheimdienst> also, you might save some work if you use the Data.Time module, in particular file://localhost/usr/share/doc/ghc/html/libraries/time-1.1.4/Data-Time-LocalTime.html
11:07:27 <int80_h> thanks. This is what I was hoping to get out of this project, the Haskell Way.
11:07:27 <Phyx-> LN_date { years :: Int } will generate years :: LN_dat -> Int; years (LN_date a) = a
11:07:49 <Phyx-> so for ever record field, a function is generated by the compiler
11:13:05 <geheimdienst> int80_h, sorry, i pasted a link to my harddrive :-/ i'm an idiot. http://www.haskell.org/ghc/docs/6.12.2/html/libraries/time-1.1.4/Data-Time-LocalTime.html
11:20:30 <davekong> Is there kind of offline version of the Haskell Libraries reference?
11:20:36 <davekong> *some kind
11:21:35 <geheimdienst> davekong, if you install things from cabal with --enable-documentation, it will write a bunch of html files into .cabal/share/doc/...
11:22:05 <geheimdienst> (you can also put that switch into your ~/.cabal/config to do it always)
11:22:49 <flazz_> if i have [Maybe a] what is a slick way to filter out the Nothings and map to the a's?
11:23:13 <geheimdienst> and your distro may have already put documentation files into /usr/share/doc/... when you installed ghc
11:23:50 <geheimdienst> if not, then there's probably a package with a name ending in "-doc" which contains the docs for ghc and the base api
11:23:55 <mauke> @hoogle [Maybe a] -> [a]
11:23:55 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:23:55 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:23:55 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:24:46 <djahandarie> > catMaybes [Just 5, Nothing, Just 10, Just 2, Just -4] 
11:24:47 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t'
11:24:47 <lambdabot>         against inferred ...
11:24:57 <flazz_> thanks
11:25:21 <davekong> geheimdienst: thanks, looks like my distro did
11:25:47 <rfh> how can i define remdups using foldr/foldl? http://pastie.org/1041275
11:26:12 <Morex> I have a question....
11:26:23 <kmc> cool
11:26:25 <chicom___master> I have an answer
11:26:27 <davekong> now I am trying to find the primary index file
11:26:29 <mreh> we like questions
11:26:59 <Morex> Is it possible to create a Java App that can open two different user profiles?
11:27:07 <kmc> Morex, why are you asking us?
11:27:15 <kmc> this is the channel for the programming language Haskell
11:27:25 <mauke> Morex: YOOOUUUUUUUUUUUUUUUUUUUUUUU!
11:27:53 <soupdragon> why isn't 1/(1-1) = -1/2
11:27:57 <djahandarie> soulja boy up in it oooh
11:28:14 <mreh> because it's equal to 1/0
11:28:19 <chicom___master> replace all java with haskell
11:28:23 <kmc> why isn't 3 = 5
11:28:24 <mauke> I thought 1/0 was -0.5
11:28:24 <chicom___master> today!
11:28:37 <Morex> Is it possible to create a Haskell App that can open two different user profiles?
11:28:37 * geheimdienst lets out a zombie howl and lumbers towards morex. "must .... kill .... heretic ...."
11:28:38 <soupdragon> mauke it should be imo
11:28:44 <soupdragon> at least 0=1-1
11:28:47 <kmc> Morex, what's a "user profile"?
11:28:49 <SheepdaCalculus> chicom: how?
11:28:56 <soupdragon> how do you derive that thuogh
11:29:07 <davekong> sweet...
11:29:13 <mreh> you don't start with a preposition you wish to prove in maths usually
11:29:26 <Morex> like how you can log into a computer with an administrator or guest
11:29:40 <kmc> Morex, you mean on Windows?
11:29:43 <mreh> are we using the same definitions of minus, divide and equals?
11:29:51 <Morex> yeah
11:29:53 <mreh> and one and two
11:30:04 <kmc> Morex, I think this is a question about Windows, not about a particular programming language
11:30:15 <Phyx-> yes you can
11:30:16 <soupdragon> Why is everyone replying to Morex????????????
11:30:25 <Phyx-> since you can spawn processes
11:30:28 <djahandarie> soupdragon, your question seems to make just as little sense...
11:30:29 <djahandarie> :P
11:30:38 <Phyx-> and processes can be ran under different credentials
11:30:48 <Morex> Can you write a program that incorperates the idea is what im asking
11:31:00 <mauke> forget it, it's NP-complete
11:31:02 <kmc> Morex, me? i certainly can't, i know nothing of Windows development
11:31:04 <Phyx-> which I just answered :P
11:31:15 <kmc> this is really not the place to ask
11:31:25 <Phyx-> but I did answer...
11:31:29 * Phyx- taps the mic
11:31:32 <Phyx-> oh forget it :/
11:31:38 * djahandarie taps out Phyx- 
11:31:45 <Morex> Well how would you go about it Phyxx
11:31:58 <mauke> Morex: how about you start talking about Haskell?
11:31:59 <kmc> this is going to be fun
11:33:34 <Morex> Phyxx?
11:33:46 <kmc> Morex, ask in ##windows or #winapi
11:34:05 <kmc> if they give you an answer in C, we can help you translate it to Haskell
11:34:26 <Morex> Ok then Ill try that...
11:34:36 <msieradzki> does ghci collect garbage?
11:34:40 <kmc> think so
11:34:46 <Phyx-> only on mondays
11:34:59 <msieradzki> I mean it may keep root variables that I referenced or something
11:35:02 <SheepdaCalculus> lol, tuesdays in my area
11:35:08 <msieradzki> I mean GC in the lower part of the tree
11:35:23 <msieradzki> like starting happstack and expecting to see DB connections freed
11:35:32 <Phyx-> ooh a new msdn page, it's pretty
11:35:42 <msieradzki> where
11:35:53 <msieradzki> the one that they have since a year or more
11:35:54 <msieradzki> ?
11:36:07 <msieradzki> few years ago you had to download like 2MB to see simple doc page
11:36:10 <Phyx-> no, this is definately not older than a week or two
11:36:11 <msieradzki> for every one
11:36:19 <msieradzki> is it the front page only?
11:36:21 <msieradzki> that changed
11:36:31 <Phyx-> no
11:36:43 <kmc> "developers developers developers"
11:37:08 <msieradzki> bs ;)
11:37:19 <msieradzki> at least for quite a long time in many parts of MSDN :P
11:37:42 <Phyx-> msieradzki: msdn had a major overhaul already this passed year which changed more than just the homepage
11:37:50 <Phyx-> with the release of visual studio 2010 it was finished
11:37:52 <Phyx-> so no BS
11:38:15 <msieradzki> no I meant 5 years ago
11:38:25 <msieradzki> dev dev dev mantra was really old
11:38:36 <msieradzki> not so long ago all their sites were crap I think that still
11:38:41 <Phyx-> 20:32:44 Morex [~Morex@adsl-240-193-130.bna.bellsouth.net] requested CTCP VERSION from Phyx-:
11:38:42 <msieradzki> google is best tool to search them
11:38:44 <Phyx-> WTF
11:38:46 <chicom___master> doesn't microsoft employ one of the haskell inventors?
11:38:53 <Phyx-> why does he keep sending me ctcp queries
11:39:04 <msieradzki> Phyx-, maybe he tries PM
11:39:08 <msieradzki> and doesn't know what to click
11:39:11 <mauke> cause I like you, yeah I like you
11:39:13 * Phyx- types /ignore Morex ALL
11:39:20 <mauke> and I'm feeling so bohemian like you
11:39:41 <Phyx-> wasn't haskell designed by commity?
11:39:51 <kmc> mauke ♥
11:39:53 <Philippa> one potential reason to VERSION random people is looking for exploitable clients
11:40:17 <mauke> my #1 reason is to see which OS they're on
11:40:19 <Phyx-> anyway, i do have the page he was looking for
11:40:23 <soupdragon> Philippa++
11:40:26 <Philippa> chicom___master: MS Research employs JaffaCake and Simon Peyton-Jones, is that what you had in mind?
11:40:31 <kmc> chicom___master, yeah, Microsoft Research in Cambridge UK does a bunch of Haskell stuff, and employs SPJ iirc
11:40:44 <kmc> MSR is its own little world within MS
11:40:46 <Phyx-> Philippa: they also employ Simon marlow and Daan leijen
11:40:59 <Philippa> Phyx-: JaffaCake is Simon Marlow :-)
11:41:06 <mreh> haskell was stolen from miranda
11:41:08 <geheimdienst> isn't eric meijer from MS involved with haskell too ...?
11:41:12 <kmc> but apparently they did tell SPJ he had to use more Microsoft products, so he started writing all his slides in Comic Sans MS
11:41:13 <Phyx-> Philippa: aha
11:41:28 <djahandarie> LOL kmc
11:41:31 <Phyx-> Philippa: I would have never guessed :P
11:41:36 <llama> geheimdienst: yes, and the videos he has on ch9 are awesome
11:41:48 <Philippa> mreh: Miranda was a major influence, but no, it didn't start out as a Miranda clone
11:42:05 <mreh> Philippa: compare the syntax :)
11:42:24 <Philippa> mreh: Miranda had ancestors too
11:42:34 <Phyx-> if anyone sees Morex, tell him to look at http://msdn.microsoft.com/en-us/library/aa393617(VS.85).aspx
11:42:39 * Phyx- goes back to coding
11:42:43 <mreh> Philippa: interesting
11:42:46 <Philippa> and IIRC there were actually two syntactic styles that Haskell deliberately supported
11:42:57 <triyo> RWH ch11 uses QuickCheck 1.2, however modules seem to have changed since v2. Chapter refers to runTests function from Test.QuickCheck.Batch. Are the QC drivers still available in v2?
11:45:37 <triyo> Is there an up to date tutorial on QuickCheck 2?
11:45:50 <Phyx-> Linking main.exe ...
11:45:55 <Phyx-> *** Creating library file: HSdll.dll.a
11:45:57 <Phyx-> what ya know
11:45:58 <Phyx-> it works
11:46:26 <Phyx-> that was alot less work than expected
11:46:55 * Phyx- writes a small C test file
11:47:03 * Phyx- also runs regression testing
11:48:27 <int80_h> > 20
11:48:29 <lambdabot>   20
11:48:48 <EvanR-work> > 19
11:48:49 <lambdabot>   19
11:48:53 <aristid> > 18
11:48:54 <lambdabot>   18
11:48:56 <Phyx-> > 7
11:48:57 <lambdabot>   7
11:48:59 <Phyx-> whoops
11:49:01 <aristid> Phyx-: NOOO
11:49:01 * Phyx- runs
11:49:01 <int80_h> > 20 :: Data.Time.LocalTime
11:49:02 <lambdabot>   Not in scope: type constructor or class `Data.Time.LocalTime'
11:49:11 <geheimdienst> c-c-c-combo breaker
11:49:22 <int80_h> > 20 :: Data.Time.LocalTime.todHour
11:49:23 <lambdabot>   <no location info>:
11:49:23 <lambdabot>      parse error on input `Data.Time.LocalTime.todHour'
11:49:43 <kmc> > 20 :: IntPtr
11:49:44 <lambdabot>   Not in scope: type constructor or class `IntPtr'
11:49:46 <Phyx-> lol
11:49:54 <Phyx-> sowwy
11:49:55 <mreh> 100 ways to use 20
11:50:01 <Phyx-> I swear, I did press 1
11:50:12 <geheimdienst> 100 ways to get 20 rejected by the compiler
11:50:14 <Phyx-> mreh: but only 1 works :P
11:50:47 * geheimdienst makes a note to never employ phyx- as the nasa countdown guy
11:50:55 <int80_h> I'm trying to understand what I am reading on http://www.haskell.org/ghc/docs/6.12.1/html/libraries/time-1.1.4/Data-Time-LocalTime.html
11:50:55 <slade118> is there a way to paste stuff into ghci on windows, besides clicking about?
11:51:07 <mreh> they don't count down from 20
11:51:15 <Phyx-> geheimdienst: to be fair, they only count in single digits
11:51:24 <Phyx-> except for 10, :P
11:51:28 <jaj> 3 - 2 - 1 - 7
11:51:40 <int80_h> I see a Constructor in TimeOfDay of type todHour :: Int
11:51:53 <djahandarie> @type tdHour
11:51:54 <lambdabot> Not in scope: `tdHour'
11:51:57 <djahandarie> @type todHour
11:51:58 <lambdabot> Not in scope: `todHour'
11:52:13 <djahandarie> Not loaded on lambdabot apparently
11:52:14 <int80_h> okay it's not a type
11:52:23 <int80_h> ooh that's possible too
11:52:32 <geheimdienst> int80_h, wait, that's a function to extract a value from a TimeofDay. the constructor (the only constructor) is called TimeOfDay
11:52:42 <Phyx-> int80_h: that's a field accessor
11:52:55 <int80_h> gotcha
11:52:57 <Phyx-> it's *real* type is todHour :: TimeOfDay -> Int
11:53:02 <Phyx-> like I tried explaining before
11:53:22 <int80_h> you're explaining fine, I'm takin in alot at once.
11:53:29 <Phyx-> :P
11:53:51 <Phyx-> > getTimeZone
11:53:52 <lambdabot>   Not in scope: `getTimeZone'
11:54:01 <geheimdienst> int80_h, don't be shy to ask. the time and date handling can get a little confusing
11:54:07 <Phyx-> :t timeToTimeOfDay
11:54:08 <lambdabot> Not in scope: `timeToTimeOfDay'
11:54:19 <EvanR-work> :t malloc
11:54:20 <lambdabot> Not in scope: `malloc'
11:54:28 <EvanR-work> :t fscanf
11:54:29 <lambdabot> Not in scope: `fscanf'
11:54:29 <geheimdienst> phyx-, try getZonedTime
11:54:41 <Phyx-> :t getZoneTime
11:54:42 <lambdabot> Not in scope: `getZoneTime'
11:54:49 <geheimdienst> :t getZonedTime
11:54:50 <Phyx-> geheimdienst: don't think lambdabot has them loaded
11:54:50 <lambdabot> Not in scope: `getZonedTime'
11:54:58 <geheimdienst> @hoogle getZonedTime
11:54:59 <lambdabot> Data.Time.LocalTime getZonedTime :: IO ZonedTime
11:55:02 <Phyx-> and lambdabot would also not run anything with IO in the type
11:55:11 <geheimdienst> > print 42
11:55:12 <lambdabot>   <IO ()>
11:55:15 <int80_h> geheimdienst : thanks. I'm going forward with no clear idea of what I am doing. Things become clearer as I move along.
11:55:17 <aristid> > show 42
11:55:18 <lambdabot>   "42"
11:55:20 <Phyx-> afaik
11:55:23 <djahandarie> @type show
11:55:24 <lambdabot> forall a. (Show a) => a -> String
11:55:31 <djahandarie> @src print
11:55:31 <lambdabot> print x = putStrLn (show x)
11:55:36 <aristid> > let print = text . show in print 42
11:55:37 <lambdabot>   42
11:56:03 <aristid> > text "a\nb"
11:56:04 <lambdabot>   a
11:56:05 <lambdabot>  b
11:56:29 <aristid> *must refrain from abuse*
11:56:35 <geheimdienst> @src text
11:56:36 <lambdabot> Source not found.
11:56:47 <djahandarie> It will cut it off after a certain amount of lines regardless of how it's getting printed
11:56:55 <aristid> it's mentally hard not to exploit such opportunities for abuse :D
11:56:56 <djahandarie> And the b has a space before it
11:57:07 <kmc> Phyx-, lambdabot doesn't treat IO-typed values specially
11:57:11 <aristid> djahandarie: well even if it's just 5 lines it'd be annoying
11:57:17 <djahandarie> I think it's three
11:57:31 <djahandarie> > text "a\nb\nc\nd"
11:57:32 <lambdabot>   a
11:57:33 <lambdabot>  b
11:57:33 <lambdabot>  c
11:57:33 <lambdabot>  d
11:57:39 <djahandarie> Uh, maybe not
11:57:39 <djahandarie> :P
11:57:40 <jaj> > show $ print a
11:57:41 <lambdabot>   "<IO ()>"
11:57:50 <geheimdienst> aristid, you could just mark a lot of text in your browser, then middle-click the irc window. getting banned in 2 easy steps.
11:57:53 <geheimdienst> ;-)
11:58:00 <aristid> > text . join . replicate 10 $ "a\n"
11:58:01 <lambdabot>   a
11:58:01 <lambdabot>  a
11:58:01 <lambdabot>  a
11:58:01 <lambdabot>  a
11:58:01 <lambdabot>  a
11:58:03 <lambdabot> [5 @more lines]
11:58:09 <c_wraith> Does a bang pattern in "let !foo = f x in foo" actually do anything?
11:58:13 <Phyx-> kmc: i assumed it did, to prevent you from running things like deleteFile
11:58:20 <aristid> geheimdienst: yeah but that would be boring
11:58:34 <kmc> Phyx-, lambdabot is an evaluator, not an executor.  it will evaluate IO actions, but it won't execute them
11:58:50 <mauke> Phyx-: running IO actions would be treating them specially
11:59:03 <kmc> yeah.  the GHCi prompt has special treatment
11:59:13 <Phyx-> hmm okay, guess I misunderstood it :)
11:59:39 <c_wraith> the GHCi prompt is also special in that it treats "Show a => IO a" differently than "IO a"
11:59:52 <Phyx-> :t readFile
11:59:53 <lambdabot> FilePath -> IO String
11:59:59 <Phyx-> readFile "."
12:00:03 <Phyx-> > readFile "."
12:00:03 <kmc> > readFile "."
12:00:04 <int80_h> http://paste.org/pastebin/view/20471
12:00:05 <lambdabot>   <IO [Char]>
12:00:05 <lambdabot>   <IO [Char]>
12:00:08 <kmc> > readFile "." `seq` ()
12:00:09 <lambdabot>   ()
12:00:09 <geheimdienst> actually that might be a good explanation of IO vs. pure. IO is done at program runtime, pure things are done at compile time. things like lambdabot are easy to do safely in haskell because you can just run the pure part, skip IO, and no damage can be done
12:00:16 <Phyx-> interesting, I could have sworn that didn't work before
12:00:18 <kmc> "pure things are done at compile time"?
12:00:31 <Phyx-> :t unsafePerformIO
12:00:32 <lambdabot> Not in scope: `unsafePerformIO'
12:00:36 <int80_h> If you'd like to take a look at my paste, I would appreciate it.
12:00:41 * geheimdienst is not sure if he's making sense
12:00:48 <kmc> GHCi will evaluate and execute IO actions, printing the result if it's not ().  for any other type, it simply prints the value
12:00:55 <kmc> so it is a special rule
12:01:15 <kmc> which lambdabot lacks -- it uniformly calls "show" on the input
12:01:24 <kmc> it does have a non-standard «instance (Typeable a) => Show (IO a)»
12:01:39 <jaj> kmc: does ghci use  unsafePerformIO for this?
12:01:40 <int80_h> test
12:01:41 <Phyx-> ah, that makes sense
12:01:57 <c_wraith> kmc: it also will execute things that have a result type that isn't in show
12:01:58 <Philippa> geheimdienst: in general pure things /can't/ be done at compile-time because little things like termination properties may depend on input
12:02:05 <kmc> c_wraith, ah, didn't know that
12:02:06 <mauke> jaj: no, I'm pretty sure ghci is in IO
12:02:14 <Phyx-> int80_h: why would you want to translate it? why not use Data.Time ?
12:02:20 <kmc> jaj, not really.  GHCi is wired deep into the GHC runtime system itself
12:02:53 <kmc> jaj, however GHC's implementation of the IO monad is built on impure functions at the lowest level, and only wrapped into the nice world of pure functions and IO actions when presented to the user
12:03:04 <int80_h> Phyx : Well, that's what I meant by translation. I would be using Data.Time where it makes sense. Having difficulty making sense out of it.
12:03:22 <kmc> indeed lambdabot's show does not even evaluate IO actions, let alone execute them:
12:03:27 <kmc> > undefined :: IO ()
12:03:27 <lambdabot>   <IO ()>
12:03:36 <kmc> but
12:03:37 <kmc> > (undefined :: IO ()) `seq` ()
12:03:37 <lambdabot>   *Exception: Prelude.undefined
12:03:55 <geheimdienst> > () `seq` ()
12:03:56 <lambdabot>   ()
12:04:12 <Phyx-> kmc: for IO isn't evaluation execution?
12:04:20 <kmc> Phyx-, no
12:04:34 <kmc> that's the whole point
12:04:55 <kmc> evaluation is pure computation, it means reducing expressions to normal form
12:05:08 <kmc> reducing function applications by substituting arguments within bodies
12:05:14 <kmc> beta-reduction and pattern matching
12:05:23 <kmc> so e.g.
12:05:46 <kmc> «(\x -> print (3+x)) 5» will evaluate to «print 8»
12:05:47 <SheepdaCalculus> >  2 + 2
12:05:48 <Phyx-> yes, I was thinking of a more naive view of evaluation when i said that
12:05:48 <lambdabot>   4
12:06:10 <kmc> oh, not the Haskell meaning then?
12:06:24 <jaj> it would be interesting to have an operating system that differenciates pure and unpure actions
12:06:32 <Phyx-> not particulairly no
12:06:43 <kmc> other languages tend to confuse evaluation with execution.  i don't think that's really the simpler / more naive view, but it is the common view
12:06:44 <Phyx-> int80_h: what can't you make sense of
12:07:05 <int80_h> Phyx : thanks for asking, I'll give you an example
12:07:19 <kmc> most languages use functions for at least three unrelated roles; in Haskell they are three separate features
12:07:37 <Phyx-> kmc: which are?
12:08:01 <kmc> argument dependence, effects, and deferred evaluation
12:08:05 <CakeProphet> I wonder how you could make sense of record syntax...
12:08:06 <lambdabot> CakeProphet: You have 1 new message. '/msg lambdabot @messages' to read it.
12:08:29 <CakeProphet> like, the problem I see with record syntax, isn't really the syntax... but the semantics. There's no update function defined!
12:08:30 <mreh> CakeProphet: it is possible, but only after considerable effort
12:09:01 <CakeProphet> I can't express the update of a state as a computation without resorting to a lambda expression.
12:09:02 <kmc> yeah, Haskell records suck.  use a package like fclabels and they get better
12:09:28 <CakeProphet> that's really the only thing I don't like. everything else is fine really.
12:09:32 <int80_h> I'd lke to make a record where I can do something like "daybaz Day" and get "27" , "daybaz seconds" and get "30" , "daybaz year" and get "1986" for example
12:09:41 <Phyx-> yeah, Haskell records are rather limiting
12:09:51 <int80_h> so I am looking for a datatype that will do something like this, and I'm not recognizing it
12:09:52 <kmc> int80_h, that's not how Haskell records work, the selector is a function that operates on the record
12:09:56 <Phyx-> kmc: ah, right, not the 3 i was thinking of
12:10:00 <kmc> year :: MyRecordType -> Int
12:10:06 <kmc> Phyx-, which were?
12:10:49 <CakeProphet> why couldn't Haskell simply make a ' version of each accessor as an update function?
12:11:02 <Philippa> CakeProphet: foo {bar = (bar foo) - 1} ?
12:11:03 <int80_h> Phyx - am I thinking in the wrong terms then? Should I be looking for another constructor? Or hsould I be re-think what I want to conform with what haskell records offers?
12:11:32 <kmc> CakeProphet, there's no fundamental reason it couldn't
12:11:54 <CakeProphet> Philippa:  but that isn't a function. I can't curry that or pass it to a higher-order function? I'm still required to write boilerplate code to make update functions.
12:11:54 <kmc> CakeProphet, i'm guessing they wanted a minimal record system, with further research required
12:11:59 <Phyx-> kmc: i was only thinking of arguments, defered evaluation and CAFs, since I when i think of effects i think of methods not functions
12:12:12 <Philippa> CakeProphet: fair enough
12:12:15 <kmc> it's hard to make a CAF in a lot of languages
12:12:26 <kmc> CakeProphet, making updater functions which are composable and otherwise nice to work with is tricky
12:12:31 <kmc> again, i recommend the fclabels package
12:12:36 <Philippa> kmc: record systems were very much a research topic at the time, so yes
12:12:38 <CakeProphet> fclabels?
12:12:39 <kmc> (also look at data-accessor and lenses)
12:12:42 <kmc> fclabels yes
12:12:54 <CakeProphet> what does that stand for?
12:13:00 <Heffalump> is fclabels becoming the standard?
12:13:02 <Heffalump> first class labels
12:13:03 <kmc> first class labels
12:13:10 <kmc> @hackage fclabels
12:13:11 <lambdabot> http://hackage.haskell.org/package/fclabels
12:13:27 <int80_h> kmc : was that recommendation directed toward me?
12:13:27 <slade118> can you write recursive lambda expressions?
12:13:48 <kmc> int80_h, it was directed towards CakeProphet but might be relevant for you too
12:13:54 <CakeProphet> kmc:  ah. that looks like something I'm highly interested in.
12:13:58 <c_wraith> slade118, only with a fixed-point operator.
12:14:02 <kmc> slade118, not directly.  you can use "let" or "fix" instead
12:14:14 <int80_h> http://hackage.haskell.org/package/fclabels
12:14:28 <kmc> > let f x = x : f (x+1) in f 0
12:14:29 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:14:40 <kmc> > fix (\f x -> x : f (x+1)) 0
12:14:41 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:14:47 <roconnor> data-accessor!
12:14:50 <kmc> slade118, "let" is syntax, "fix" is an ordinary function
12:14:51 <kmc> :t fix
12:14:52 <lambdabot> forall a. (a -> a) -> a
12:15:04 <CakeProphet> kmc:  that's actually quite similar to the kind of system I'd envision to "fix" records.
12:15:08 <Phyx-> int80_h: like kmc said, the selector functions work on a datatype. you can theoretically get what you want by just filling in the field of the record with different value, but semantically it would not be what the user expects. so you fclabels might be a better choice
12:15:21 <CakeProphet> kmc:  I end up doing something like "get field" in my code a lot.
12:15:40 <Phyx-> kmc: yes, but that's typically one thing i think about when i think of haskell functions
12:15:48 <int80_h> phyx : yes this looks alot nicer to my newbie eyes.
12:15:50 <slade118> ok, thanks
12:15:59 <int80_h> and I don't mind going down dead ends if it leads to learning something
12:16:11 <int80_h> so I will try doing it this way
12:16:16 <kmc> Phyx-, well, whether a binding in Haskell is a CAF is independent of whether it is a function (i.e., has function type)
12:16:18 <kmc> many of them aren't
12:16:32 <Phyx-> this is true
12:16:54 <Philippa> if it has function type, it's not really a CAF
12:17:15 <zygoloid> Philippa: "foo = \x -> x + 1" is a CAF i thought
12:17:22 <int80_h> what does CAF mean?
12:17:24 <kmc> it's not an applicative form
12:17:28 <zygoloid> constant applicative form
12:17:49 <kmc> «foo = (\x y -> (3+x) + y) 4»
12:17:55 <zygoloid> kmc: what about "foo = id (\x -> x + 1)" ?
12:17:58 <kmc> sure
12:18:09 <kmc> the RHS of that is an application
12:18:09 <zygoloid> i think GHC treats the first one as a CAF though
12:18:21 <kmc> ok
12:18:28 <Philippa> zygoloid: as I understand it, the F's "really" function, in the C sense
12:18:50 <conal> does "applicative" in "an application?  anyone have a dependable definition reference?
12:18:51 <conal> ?
12:19:03 <Philippa> the whole point being things that're semantically constant but which get evaluated lazily at runtime
12:19:15 <conal> oops -- does applicative in "CAF" mean an application? ...
12:19:23 <kmc> conal, i think so yes
12:19:42 <kmc> i think "CAF" means roughly "constant which is not in WHNF"
12:19:42 <Philippa> (the applicative pretty much gets you that in practice)
12:19:44 <conal> kmc: do you have a reference? i'd like to know.
12:19:49 <cozachk2> ghci
12:19:50 <cozachk2> oops
12:19:52 <kmc> no. ghc manual maybe?
12:20:02 <zygoloid> Philippa: indeed, we all seem to agree that "foo = id (\x -> x)" is a CAF. but is "foo = \x -> x" a CAF? I think so...
12:20:05 <geheimdienst> say if i have: f = foo { field = 42 }, can i write that as f x = foo { x = 42 } ? there's no way to do something like that, right?
12:20:25 <kmc> CAFs need special treatment in an STG-like implementation, since they are updatable closures
12:20:28 <Philippa> zygoloid: it's definitely not the sort worth talking about, IYSWIM
12:20:33 <Philippa> and what kmc is saying
12:21:01 <kmc> geheimdienst, correct. regular Haskell 98 record labels are not first class. that's what packages like fclabels provide
12:21:20 <cozachk2> fclabels looks pretty cool
12:21:22 <geheimdienst> i see. thank you
12:21:24 <int80_h> fclabels looks heavy
12:21:37 <kmc> there's also data-accessor and lenses
12:21:38 <int80_h> template haskell, that's , like...advanced
12:21:45 <zygoloid> Philippa: my point was merely that your statement "if it has function type, it's not really a CAF" is inaccurate
12:21:56 <cozachk2> does ghc have template haskell builtin now? 
12:22:02 <kmc> cozachk2, has for a long time
12:22:03 <zygoloid> since there amy still be nontrivial work in actually building the function
12:22:05 <conal> zygoloid: that's my understanding as well.  the type is irrelevant to CAFness
12:22:10 <kmc> int80_h, yes, its is exceptionally difficult to write TH code.  it's not so hard to use properly-written TH code
12:22:14 <Phyx-> bleh, gcc is being annoying
12:22:26 <kmc> int80_h, you can basically pretend that TH libraries are language extensions
12:22:32 <kmc> usually they add new top-level declarations
12:22:47 <kmc> like fclabels's mkLabels
12:22:53 <zygoloid> TH code isn't /so/ hard once you give up the idea of using quotation brackets.
12:22:57 <kmc> yeah :/
12:23:26 <Phyx-> hey whatya know
12:23:31 <Phyx-> that crazy idea works
12:23:38 <Phyx-> lispy++
12:23:39 <Phyx-> :P
12:23:42 <zygoloid> and stop being annoyed about the Q [Dec] / [DecQ] inconsistency
12:23:59 <zygoloid> haha, my TH codegen is working too!
12:24:17 <zygoloid> except i can't generate a type instance for an associated type family called :~>: :(
12:24:59 <kmc> man with wiggly nose
12:25:37 <Tomsik> What do TH and CAF stand for?
12:25:45 <zygoloid> Illegal type constructor or class name: `'
12:25:50 <cozachk2> th = template haskell 
12:25:58 <zygoloid> caf = constant applicative form
12:30:19 <int80_h> okay I have loaded the module for Data.Record.Label, and am trying out code from the fclabels page. However it mentions some missing brackets, and the code I am trying breaks. Makes me think I am missing brackets. This is what happens
12:30:45 <int80_h> name      :: Person :-> String
12:30:55 <int80_h> Illegal operator `:->' in type `Person :-> String' Use -XTypeOperators to allow operators in types
12:31:18 <soupdragon> > 1-0.2*(1/(1-0.2)-1/(2*(0.2-1)))
12:31:19 <lambdabot>   0.625
12:31:20 <zygoloid> int80_h: can you paste a link to the fclabbels page?
12:31:21 <int80_h> how can :-> be an illegal operator, when I have loaded the module that exposes it?
12:31:24 <soupdragon> > (0.2-1)*1 + 0.2 + (0.2-1)*0.2^2 + 0.2^3 + (0.2-1)*0.2^4 + 0.2^5 + (0.2-1)*0.2^6
12:31:25 <lambdabot>   -0.6250112000000001
12:31:32 <int80_h> http://hackage.haskell.org/package/fclabels
12:31:35 <zygoloid> int80_h: because you haven't set -XTypeOperators.
12:31:38 <illissius> TH is annoying to write, and the whole staging thing when using it is -really- annoying
12:31:49 <illissius> but you can do things with it which you can't otherwise, so.
12:31:58 <int80_h> ah, the example makes no mention of that
12:32:09 <Phyx-> int80_h: put {-# LANGUAGE TypeOperators #-} at the top of your file
12:32:25 <int80_h> Phyx : what about playing in ghci?
12:32:28 <zygoloid> int80_h: yeah, that's a bit rubbish of it :)
12:32:34 <zygoloid> int80_h: :set -XTypeOperators
12:32:40 <int80_h> I've just got ghci open trying to familiarize myself with this new stuff
12:34:42 <int80_h> new error
12:34:51 <int80_h> name      :: Person :-> String
12:34:55 <int80_h> yields
12:35:06 <int80_h> Not in scope: `name'
12:35:21 <zygoloid> int80_h: you need a definition with that.
12:35:47 <zygoloid> it looks like the TH is supposed to generate one
12:35:49 <int80_h> I'm trying out code from the fclabels page
12:36:00 <zygoloid> do you have the $(mkLabels [''Person, ''Place]) line in your file?
12:36:30 <int80_h> zygoloid, no I thought that was referring to the code above it
12:36:44 <zygoloid> yeah. it looks like how it's supposed to work is:
12:37:06 <zygoloid> 1) you define some datatypes, 2) you use the TH mkLabels function to generate some accessors, 3) you annotate some type signatures
12:37:40 <zygoloid> so you'll need the mkLabels in there. incidentally, in ghc6.12 you can simply write: mkLabels [''Person, ''Place] (no "$(", ")" needed at the top level)
12:39:10 <int80_h> gotcha
12:39:22 * hackagebot mandulia 0.4 - A zooming visualisation of the Mandelbrot Set as many Julia Sets.  http://hackage.haskell.org/package/mandulia-0.4 (ClaudeHeilandAllen)
12:40:08 <CakeProphet> :t (>>=)
12:40:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:45:16 <aristid> zygoloid: no $() needed? huh, why that?
12:45:38 <kmc> it's just a new syntactic feature
12:45:48 <kmc> (top level decl splices only)
12:45:51 <kmc> i prefer to leave them in
12:46:15 <kmc> because TH splices don't *really* act like other decls -- for example, you have to quote names where you otherwise wouldn't
12:46:39 <zygoloid> not only that but they split the module into two not-quite-connected halves
12:46:54 <zygoloid> if anything the brackets point the wrong way
12:47:16 <zygoloid> "|] top-level splice [d|" ;)
12:47:28 <kmc> heh good point zygoloid
12:53:00 <derekwright> Hi, anybody interested in #anglohaskell ?
12:53:55 <aristid> derekwright: anglohaskell? what is that?
12:54:00 <geheimdienst> guys, what is the easiest haskell equivalent of java's serialization? i have two processes connected by a pipe, and i'd like to push a few Strings and Ints through
12:54:23 <lowasser> Binary, probably
12:54:34 <lowasser> http://hackage.haskell.org/package/binary
12:55:02 <geheimdienst> so that mechanism with read and show is not applicable here?
12:55:18 <lowasser> I mean, sure, that works too =P
12:55:27 <derekwright>  aristid:
12:56:16 <kmc> binary or cereal
12:56:16 <derekwright>  aristid: The annual UK Haskell meeting. It's been in Cambridge and London before
12:56:21 <geheimdienst> @instances Read
12:56:21 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:56:50 <aristid> derekwright: i see
12:57:06 <aristid> is there a list of worldwide haskell meetings?
12:57:16 <Philippa> derekwright: why do you ask?
12:57:43 <Philippa> I guess I'm still vaguely interested in cobbling together an event if someone else can manage it, I wasn't really up to pushing things this year
12:58:10 <conal> what's the status the haskell platform for mac os x?  is it safe & easy to install?
12:58:16 <lowasser> geheim, what's the problem with read/show ?
12:58:59 <derekwright> Philippa: I am trying to get it organised. I was the one who put his hand up in Cambridge last year. Probably should have done something sooner....
12:59:09 <geheimdienst> that my puny understanding of haskell is especially feeble in the area of read/show
12:59:10 <geheimdienst> ;)
12:59:25 <geheimdienst> > show (Left 42)
12:59:26 <lambdabot>   "Left 42"
12:59:35 <geheimdienst> > read $ show (Left 42) 
12:59:36 <lambdabot>   *Exception: Prelude.read: no parse
12:59:48 <geheimdienst> > (read :: Either) $ show (Left 42) 
12:59:49 <lambdabot>   `Data.Either.Either' is not applied to enough type arguments
12:59:49 <lambdabot>  Expected kind...
12:59:56 <geheimdienst> > (read :: Either Int String) $ show (Left 42) 
12:59:57 <lambdabot>   Couldn't match expected type `Data.Either.Either
12:59:57 <lambdabot>                           ...
13:00:12 <geheimdienst> why it no worky?
13:00:19 <Boxo> > (read :: String -> Either Int String) $ show (Left 42) 
13:00:20 <lambdabot>   Left 42
13:00:42 <geheimdienst> thanks :-)
13:01:15 <triyo> QuickCheck 2 doesn't seem to have "generate" function that was in version 1. Is there an alternative?
13:01:31 <lowasser> sample'
13:01:39 <triyo> thanks
13:15:02 <aristid> > read . show (Left 42) :: Either Int a
13:15:02 <lambdabot>   Couldn't match expected type `Data.Either.Either
13:15:02 <lambdabot>                           ...
13:15:07 <aristid> > read . show (Left 42) :: Either Int String
13:15:08 <lambdabot>   Couldn't match expected type `Data.Either.Either
13:15:08 <lambdabot>                           ...
13:15:11 <aristid> hmm
13:15:21 <geheimdienst> > (read . show (Left 42)) :: Either Int String
13:15:21 <lambdabot>   Couldn't match expected type `Data.Either.Either
13:15:22 <lambdabot>                           ...
13:15:27 <aristid> oh!
13:15:30 <geheimdienst> > (read $ show (Left 42)) :: Either Int String
13:15:31 <lambdabot>   Left 42
13:15:43 * geheimdienst thumps his chest
13:15:53 * Phyx- hands geheimdienst a banana
13:16:08 * geheimdienst lets out a tarzan yodel
13:16:11 * aristid steals the banana and quickly eats it and say "ugh ugh nom nom"
13:16:49 * Phyx- goes to find jane while those two fight
13:17:21 * geheimdienst uses google to find jane
13:17:23 <ezyang> Should I feel awkward about using fail in the IO monad? 
13:18:15 <zygoloid> i have a template haskell Q [Dec]. I want to turn it into haskell code so that people using my package don't have to regenerate it. how can i pretty-print it into working code?
13:18:55 <Saizan> zygoloid: derive has a sane pretty printer, iirc
13:19:06 <Cale_> ezyang: A bit. Why not use throw instead?
13:20:17 <ezyang> Cale_: I'd need to come up with a datatype for every error condition in the application, then. 
13:20:28 <ezyang> (it's FFI, so there are a lot of error conditions) 
13:20:34 <ezyang> You know what, Let's do things the right way. 
13:20:52 <djahandarie> theRightWay++
13:21:07 <lowasser> zygoloid: pprint :: [Dec] -> String
13:21:22 <lowasser> or, really, Ppr a => a -> String, but that's not the point
13:23:03 <zygoloid> Saizan: thanks. looks like it'd be some work to get it to support the language features i'm using (associated types in particular) but definitely doable
13:23:41 <zygoloid> lowasser: TH's built-in 'pretty' sadly doesn't produce actual Haskell.
13:23:51 <ezrakilty> conal: Haskell Platform on OSX works great for me.
13:24:22 <lowasser> What does it produce?  I seem to recall otherwise...
13:24:23 <conal> ezrakilty: glad to hear.  thx.  are you using the mac installer (dmg)?  or macports?
13:24:30 <conal> ezrakilty: or from source?
13:25:10 <lowasser> also, I'm not sure I understand why you can't just use a splice =P
13:25:27 <conal> ezrakilty: version 2010.1.0.1-i386 http://hackage.haskell.org/platform/mac.html ?
13:25:41 <zygoloid> lowasser: it produces, for instance 'GHC.Err.undefined'
13:26:05 <zygoloid> lowasser: it also produces: type instance :~>: Foo Bar = Baz, when it means type instance Foo :~>: Bar = Baz
13:26:19 <lowasser> I think that's all still legal
13:26:26 <zygoloid> not without parentheses it's not
13:26:53 <lowasser> meh, but still, why can't you just use a splice?
13:27:32 <zygoloid> lowasser: because i don't want everyone installing my package to have to have 10 versions of GHC installed and wait a few minutes while Language.C parses the RTS headers 160 times ;-)
13:27:46 <zygoloid> (i'm not even kidding!)
13:27:59 <lowasser> TH isn't *that* big a constraint?!
13:28:11 <ezrakilty> conal: I used the dmg; it worked easily.
13:28:20 <conal> ezrakilty: sweet.  thx again.
13:28:30 <ezrakilty> no prob!
13:28:31 <lowasser> I have only one GHC installed, and it takes <1sec to do the TH generation I need for most of my applications, which are pretty intense
13:28:57 <conal> ezrakilty: oh yeah.  do you have macports installed?  i kept running into library version clashes (especially iconv).
13:29:04 <conal> (with earlier ghcs)
13:29:16 <zygoloid> lowasser: my TH code is parsing the ghc rts headers. for 10 versions of ghc. i don't want to require installing the headers of 10 versions of ghc to install my package.
13:29:27 <lowasser> hmmmmmmmmm.
13:30:17 <lowasser> could you #ifdef out some of the TH code based on the GHC version?
13:30:18 <ezrakilty> conal: I think that I didn't have macports installed when I installed the Platform.
13:30:30 <coolcool1> Hello can you help me read one blurry text
13:30:46 <zygoloid> lowasser: there's no version problem. my code requires ghc6.12.
13:30:51 <triyo> I need to create sample data for my test property function. However the input needs to be a string of certain pattern. How do I define a Arbitrary instance to fit this requirement?
13:30:51 <conal> ezrakilty: glad to know.  if i get the clashes, i'll uninstall macports.
13:31:09 <ezrakilty> yeah; I've installed MacPorts since then and it didn't conflict on that installation.
13:31:36 <conal> phew!  maybe the ghc-vs-macports nightmare is over.
13:31:38 <lowasser> but you're parsing GHC somethings for 10 different versions of GHC...?
13:32:22 <lowasser> if I understand correctly, you're designing a tool in ghc-6.12 to manipulate code for lots of versions of GHC?
13:32:25 <zygoloid> yes, i am. this code is a library for messing around in the address space of other haskell binaries. i need to know the memory layout of those binaries, which might be built with a different version of ghc
13:32:32 <kmc> :O
13:32:45 <conal> sadly, i still don't know of a gui library that works natively with mac os x and doesn't kill ghci.  so i've given up on my functional gui work until the situation improves.
13:32:59 <conal> oh -- and that's compatible with 3d.
13:33:07 <lowasser> could you just take the ghc version as an argument to your TH command?
13:33:27 <zygoloid> lowasser: no, i want to support versions of ghc which the person building the package doesn't have installed.
13:33:31 <tg_> conal: what about something in browser?
13:33:36 <conal> since i have a nifty functional->gpu compiler
13:34:04 <lowasser> zygoloid: that's fine, we just write "data GhcVersion = Version1 | Version2 | ..." and then "generateFoo :: GhcVersion -> Q [Dec]"
13:34:15 <conal> tg_: i want general accelerated graphics (gpu programming).  don't know how to in a browser.
13:34:18 <tg_> I realize it depends on the use of the word 'native'
13:34:34 <zygoloid> lowasser: i have that. but generateFoo needs access to the GHC RTS headers for that version;.
13:35:06 <zygoloid> therefore generateFoo must be called on a machine with those headers. i don't want that to be the machine of the person installing.
13:35:09 <lowasser> ....which are package imports.  I think I get it
13:35:16 <tg_> conal: do you use CUDA now?
13:35:16 <lowasser> ew
13:35:25 <tg_> or OpenGL or a substitute?
13:35:31 <zygoloid> lowasser: your "ew" indicates you get it well enough ;-)
13:35:55 <lowasser> the honest answer is there's no good solution except fixing up the syntax differences in the TH code by hand
13:36:13 <conal> tg_: no.  glsl for now, as i'm targeting mobile as well as desktop.  i'd like to learn opencl or cuda next, with help from someone with experience.
13:36:20 <zygoloid> lowasser: i think fixing the 'derive' pretty-printer is probably easier than writing a script to fix the output of the TH pretty printer
13:36:41 <tg_> I have CUDA experience
13:36:47 <lowasser> TH is always behind the times, and this is one example of that
13:36:54 <tg_> no openCL yet, though
13:37:08 <lowasser> for one thing, TH has no internal representation for infix type constructors, I think
13:37:12 <conal> tg_: nice.  what have you done in cuda?
13:37:18 <lowasser> I mean, the language rewrites them to prefix
13:37:37 <zygoloid> yeah. it'd be fine if the pretty-printer knew to parenthesize them.
13:37:50 <tg_> conal: mostly maintnence, not original programming - changing code so that it could be run distributed over a cluster of GPUs
13:37:52 <lowasser> I mean, it doesn't know that they're infix in the first place
13:38:00 <lowasser> it rewrites them as prefix internally
13:38:21 <tg_> have you looked at processing.org?
13:38:48 <conal> tg_: yeah.  imperative graphics programming -- blech 
13:38:48 <lowasser> it translates [d| ﻿type instance Foo :~>: Bar = Baz |] into [d| type instance :~> Foo Bar = Baz |], it couldn't help it if it wanted to at the moment
13:39:30 <zygoloid> lowasser: right, but that's a lossless translation. if it put parens round the operator when pretty-printing that'd be correct behaviour.
13:39:36 <tg_> sure. I would guess there is a way to map over it using something pure.
13:39:41 <tg_> s/pure/functional/
13:40:04 <conal> graphics is so naturally functional, but its practice is so habitually imperative.
13:40:07 <tg_> are you trying to match or surpass existing performance, or just trying to get it to work?
13:40:31 <ezrakilty> an FRP system that could produce demos like processing's would be killer.
13:40:35 <tg_> I would say the decisions of hardware makers have had a lot to do with it :)
13:40:43 <tg_> ezrakilty: indeed
13:40:46 <conal> tg_: i have a highly optimizing compiler, evolved from the techniques i used in pan & vertigo.
13:40:47 <lowasser> mrawr
13:41:20 <conal> tg_: speed is very important to me.  right after semantics.
13:41:35 <lowasser> this might be true, albeit damned tricky in the presence of qualified infix expressions
13:41:50 <tg_> conal: ok. but at the end of the day, you're stuck working within the paramaters of someone's rastering pipeline, yes?
13:42:34 <tg_> speaking of which, did you ever get a chance to watch the memristor introduction video?
13:42:40 <conal> tg_: just as language compilers are stuck targeting someone else's computational pipelines.
13:42:58 <conal> tg_: (memristor) not yet.
13:43:29 <conal> fortunately, gpus are continuing to evolve into general purpose stream computers
13:44:29 <tg_> conal: I agree. The landscape of attempted GPU or stream processor pipelines (SIMD) is much less populated than that of CPU configurations.
13:45:01 <tg_> Though, the "beyond the Von Nuemann" paper made me question the veracity of that statement somewhat.
13:45:26 <jmcarthur> i've relinquished to imperative gpu programming for now
13:45:34 <lowasser> shunnnnnnn
13:45:54 <tg_> jmcarthur: curious, some of the most prolific game engine and hardware designers are adopting the opposite view
13:45:56 <tg_> in the past year
13:46:08 <jmcarthur> oh, no, i agree with the functional view of graphics programming
13:46:13 <conal> i see these newish massively parallel architectures as a huge opportunity for denotative/functional programming.
13:46:15 <slade118> where can I find the windows equivalent of the .ghci file?
13:46:27 <zygoloid> lowasser: there's a patch which fixed the same bug for the value level here: http://hackage.haskell.org/trac/ghc/ticket/779
13:46:27 <jmcarthur> i just mean that i have relinquished to the imperativeness of opengl regarding... getting things done *today*
13:46:34 <lowasser> unshun
13:46:54 <tg_> jmcarthur: right, I understood. The Unreal guys and some within the NVIDIA camp have decided they need to do it sooner rather than later.
13:47:06 <BMeph> notDooinItRong++
13:47:12 <jmcarthur> i had been working on functional graphics APIs, but i would rather, at the point, just get a game written
13:47:12 <tg_> conal: you really, really need to see the memristor video.
13:47:21 <jmcarthur> *at this point
13:47:31 <conal> tg_: ok, thanks for the prods.
13:47:41 <BMeph> tg_: "the" memristor video?
13:47:42 <tg_> for anyone else interested: http://www.youtube.com/watch?v=bKGhvKyjgLY
13:47:54 <tg_> BMeph: the most informative one yet
13:47:59 <tg_> Without reading their papers.
13:48:09 <jmcarthur> tg_: yes, i am aware of tim sweeney's evangelism for this, and i agree wholeheartedly (except for his dismissal of haskell because he thinks it has a confusing syntax) :)
13:48:15 <BMeph> tg_: I _like_ papers... ;)
13:48:25 <tg_> BMeph: sure, but conal doesn't have time
13:48:30 <tg_> at least, not yet :)
13:48:34 <tg_> he's got fish to fry
13:48:51 <Philippa> jmcarthur: there're much better reasons to dismiss haskell for gamedev, definitely :-)
13:49:29 <jmcarthur> i have compromised on making a non-sucky, somewhat-but-not-entirely more functional wrapper around opengl for now
13:49:33 <tg_> jmcarthur: yeah. Anytime someone dismisses a strongly typed language because of syntax makes me sad inside.
13:49:36 <jmcarthur> Philippa: quite so :\
13:50:17 <Philippa> tg_: I dunno. I mostly can't be arsed to learn ocaml due to the syntax, but that's from a position of already knowing haskell
13:50:28 <jmcarthur> in his defense, i think he also cited lazy evaluation and a couple other things, but the fact that syntax was among the reasons at all (and that he suggest ocaml as having a nicer syntax!) saddened me
13:50:31 <tg_> Philippa: yeah, that's an unbalanced comparison.
13:50:43 <Philippa> jmcarthur: incidentally, the disagreement we had re OO? I think your model (from what little you'd said) still meets my definition of OO
13:50:45 * BMeph suspects conal is going to be the chapter head of California's Procrastinators Anonymous group...
13:50:57 <tg_> In this case, he's making a huge leap from C++ to {some strongly typed, pure functional} and he expects the syntax to be sexy
13:50:58 <conal> :)
13:51:05 <jmcarthur> Philippa: honestly i don't even remember that :)
13:51:10 <conal> i'm working on a blog post at the moment.
13:51:26 <tg_> conal: link me when you post it :)
13:51:42 <Philippa> jmcarthur: I'd commented about the lack of extensible records or something similar in the type system being a big weakness for the sort of stuff that e.g. UnrealScript gets used for
13:51:58 <BMeph> =8*O
13:52:05 <jmcarthur> oh i think i remember now
13:52:14 <conal> and i've been working on lazy quad-trees for infinite continuous images made from chunks living in gpu memory.
13:52:22 <tg_> BMeph: have you learned the details about memristors yet?
13:52:25 * BMeph had wondered if conal had forgotten/abandoned blogging...
13:52:30 <zygoloid> conal: ouch my eyes
13:52:49 <jmcarthur> conal: like virtual texturing?
13:52:57 <tg_> note: lazy refers to the quad-trees, not his work ethic.
13:53:06 <conal> i get pretty focused.  hence the blog neglect.  but now i'm giving the obj-c a rest.
13:53:14 <conal> jmcarthur: i don't know.  what's virtual texturing?
13:53:30 <tg_> jmcarthur: not exactly, as I understand it
13:53:32 <BMeph> tg_: The details as in Chua's '71 paper, Kung's '75 paper, or Williams' (et al.) results? ;)
13:53:43 <tg_> BMeph: Certainly #1
13:53:46 <tg_> that paper is great
13:54:02 <Philippa> jmcarthur: I figured out a fugly way to encode what I really want for there, anyway. I wouldn't want to have to hand it to, say, my 16 year old QuakeC-coding self though
13:54:27 <sm> conal: I get those iconv errors with ghc 6.12 on osx; I think it would the same with HP's ghc. The fix is to always ghc --make with -L/usr/lib and add extra-lib-dirs=/usr/lib to ~/.cabal/config
13:54:52 <soupdragon> why doesn't everyone use the saem programming language?
13:54:53 <conal> sm: oh, wow.  thx very much for that fix.  
13:55:06 <tg_> soupdragon: the same reason everyone doesn't use the same religion
13:55:14 <tg_> 1. some are better than others at somethings
13:55:25 <tg_> 2. you tend to pick the one you grow up around
13:55:36 <tg_> 3. shouting at other people about it is awesome
13:55:42 <jmcarthur> conal: i don't think what you just said is virtual texturing now :)
13:56:01 <sm> you're welcome. Also, I needed to export LANG=en_US.UTF-8 in ~/.bash_profile to avoid errors when haskell apps try to handle non-ascii data
13:56:04 <tg_> jmcarthur: though he will have to solve the same sort of problem
13:56:09 <conal> on soupdragon's question, i suspect different people have different notions of what programming is for.
13:56:17 <Philippa> soupdragon: I think Goedel had one good argument
13:56:41 <conal> for instance, (a) controlling machines or (b) viewing ideas.
13:57:01 <Philippa> at the very least you need something turing complete and unsafe as a target and a family of safer langs
13:57:08 <conal> which might lead to preferences for imperative or denotative respectively
13:57:23 <Philippa> but then someone's ideas might well be fairly imperative too
13:57:33 <Philippa> OO modelling of business processes isn't all that crazy, for example
13:57:46 <tg_> Philippa: that's a difficult argument, since it's highly unlikely that our brains are imperative
13:57:57 <Philippa> (now, using OO to take the old, paper-driven process and computerise it rather than asking what you can do with the computer? Crazy)
13:58:51 <Philippa> tg_: it's pretty certain that our real world interactions aren't "purely functional" in any useful sense though
13:59:23 <conal> oh -- this haskell platform is ghc 6.12.1, not 6.12.3.
13:59:45 <tg_> Philippa: I haven't actually seen much evidence or analysis on that level.
14:00:06 <jmcarthur> "purely functional" is a model, so i'm no longer sure whether to say that anything in the real world is *or* isn't purely functional
14:00:35 <tg_> jmcarthur: well, I was about to say, as a physicist (second to computer scientist), it's not exactly clear what kind of computation "spacetime" can do, so to speak
14:00:42 <jmcarthur> "stateful" is also such a model
14:00:49 <Philippa> jmcarthur: a functional model of the Theory of Everything as a response is going to elicit no small amount of snark from me :-)
14:00:52 <soupdragon> what do you think reality is?
14:01:09 <tg_> soupdragon: pretty spectacular.
14:01:13 <jmcarthur> soupdragon: any answer i say will be wrong
14:01:32 <jmcarthur> i mean that literally, not that you or somebody else will be argumentative about it (which may also be the case of course) :)
14:01:41 <tg_> We are more unsure of the answer to that question than we have ever been before in human history
14:01:57 <soupdragon> isn't that weird that there's word and nobody knwos what it means!!
14:02:22 <soupdragon> do you think we'll get so confused one  day that everything makes sense
14:02:22 <Philippa> jmcarthur: it's definitely the case that I won't necessarily get the same response saying something to you now as I would've, say, a decade ago though. Stateful isn't an entirely crazy model of the real world, and OO makes sense insofar as you have 'things' that behave autonomously and may react differently to things over time
14:02:35 <Philippa> now, what that has to do with how you make the computer do stuff is another matter
14:02:39 <jmcarthur> the only words we can attribute meanings to are the ones which are derived from the composition of other words
14:02:41 <tg_> soupdragon: it's pretty common practice for physicists to do that, actually. Not that they actively did this for the word 'reality', but 'dark matter' and 'dark energy' are examples of putting names on something completely unknown.
14:02:57 <soupdragon> like algebar
14:02:59 <soupdragon> algebra
14:03:41 <tg_> algebar
14:03:42 <jmcarthur> Philippa: right. i wouldn't discount state as a reasonable model of the world. my issues with state have nothing to do with power, but in complexity
14:03:48 <tg_> that sounds like a cartoon character
14:04:00 <Philippa> conal: out of interest, do you have any view on what I'm talking about? I'm quite serious about the part where I'm not talking about how to write code :-)
14:04:21 <tg_> Philippa: what is the original question?
14:04:22 <jmcarthur> and i'm not of the opinion that any one model better fits whatever notion of "real world" we have than any other model
14:04:52 <jmcarthur> i often argue for the purely functional model just to offset the swarms of people who argue against it
14:05:12 <tg_> the use of the word 'pure'
14:05:17 <Philippa> jmcarthur: hmm, I'd have to disagree firmly with that. For example, "nothing exists" is a pretty shit model
14:05:19 <tg_> is loaded
14:05:27 <triyo> Hmm, I still can't figure it out. I need QuickCheck to produce sample data of type [Char], but the catch is that I need the [Char] to conform to a certain string pattern.
14:05:47 <jmcarthur> Philippa: well, pretty useless, but i can't call it inaccurate unless you want to start arguing philosophy
14:05:51 <triyo> is this possible?
14:06:01 <tg_> jmcarthur: don't we all want to do that? *giggles*
14:06:20 <soupdragon> triyo yes
14:06:44 <triyo> soupdragon: could you give me any hint as to how to go about this?
14:07:20 <soupdragon> triyo, i would write a  newtype FOOBAR = BAZQUUX String
14:07:21 <jmcarthur> my only point is that while some models are nicer or more useful than others, that doesn't mean that the nicer or more useful models are necessary good or bad "fits" for the real world. the real world doesn't care what is convenient or inconvenient for us
14:07:32 <soupdragon> triyo, then define a way to generate random _WELL FORMED_ FOOBARs 
14:07:38 <Jafet> Does it matter, if models are equivalent?
14:07:39 <soupdragon> triyo, extracting the string for testing
14:07:39 <Philippa> jmcarthur: well yes, but anyone pulling a reductio ad fuckall on that front isn't really worth debating with - my statement there only really assumes an 'objective' reality within which there's at least one agent attempting to reason
14:08:11 <jmcarthur> you've already defined the model by using the word "agent"
14:08:22 <Jafet> Imperative and declarative designs are equivalent, and Haskell demonstrates that fact well.
14:08:37 <triyo> soupdragon: if I go the newtype route, shouldn't I then create an instance of Arbitrary?
14:08:39 <tg_> equivalent?
14:08:50 <tg_> don't you mean a less strong word of some sort?
14:08:57 <Philippa> jmcarthur: Rather minimally, though. To be fair, you could remove the effectors and the sensors if you're that bothered
14:09:41 <soupdragon> triyo, yeah thats waht i said
14:09:44 <Jafet> tg: Isomorphic, if you like. Although perhaps not in a syntactic sense (there is a paper studying that, which I've forgotten)
14:09:47 <Philippa> jmcarthur: you'll note that technically, raw solipsism actually fits it for example
14:09:51 <jmcarthur> Philippa: by arbitrarily defining the world as a model you have in a sense proven my point
14:10:08 <jmcarthur> s/proven/demonstrated/
14:10:36 <jmcarthur> we choose the model that benefits us insofar as it enables us to reason about the world in some way
14:11:02 <Philippa> having some connection to how the world actually behaves is generally useful for that
14:11:50 <jmcarthur> sure, a model requires a mapping, and some mappings are meaningless, but i have not intended to endorse useless models like that
14:11:51 <Philippa> if all you want to say is that we'll never have a good intensional model, well yeah
14:12:07 <Philippa> ah, so now we're suddenly supposed to read your mind instead of your statements :p
14:12:16 <jmcarthur> all i mean to say is that i don't like it when people argue "the world is stateful" or "the world is functional"
14:12:47 <jmcarthur> because it's a meaningless argument in the end, to me
14:12:50 <Philippa> I think there's a good argument for the world being at least as stateful as a functional encoding of a stateful program is
14:13:03 <Philippa> and that's not a meaningless statement
14:13:04 <tg_> jmcarthur: well, I highly doubt people are trying to make physical arguments about that, but there could be one.
14:13:12 <Jafet> By the way, SICP devotes two sections and a navel-gazing footnote to this. Worth rereading.
14:13:35 <tg_> navel-gazing?
14:14:44 <kuribas> Where do I install local libraries for ghc?
14:14:57 * Lycurgus wonders if google is pinned to a specific lang, completely lang agnostic or what?
14:15:03 <soupdragon> Cale ?
14:15:04 <conal> jmcarthur: i've never found substance in those claims either.  and your remark about complexity resonates with me.
14:15:14 <kuribas> I have written html combinators for HXT.
14:15:16 <tg_> Lycurgus: they use many different languages actively
14:15:46 <jacobian> anyone had the issue: "Package xcolor Error: Undefined color `Blue'"  using beamer and lhs2tex
14:15:52 <Jafet> Lycurgus: their job advertisements should give clues
14:16:21 <conal> i like rigor and simplicity.  and denotative supports that combo for me better than imperative.
14:16:42 <Philippa> conal: I figure if the complexity is reasonably intrinsic to the problem, that's close enough. If I have to model, for example, one of the beaurocracies I'm stuck interacting with, it's going to have a bunch of state lying around however I then model that state in turn
14:16:48 <conal> and of course i include haskell io in "imperative", since i'm talking about semantics.
14:16:52 <Lycurgus> Jafet, I've been advised C/C++, python, and java
14:17:28 <Jafet> Ok, less subtle hint: you're in the wrong channel.
14:17:51 <conal> one problem i have with imperative is that it doesn't support nearly enough state/mutation.
14:18:05 <sproingie> what state doesn't it support?
14:18:17 <conal> continuous mutation
14:18:18 <Philippa> conal: no argument there. You might end up with 'local imperative' going on, but that's not the same thing
14:18:56 <conal> and it handles concurrent mutation only with great agony.
14:19:03 <kmc> google does use Haskell a bit
14:19:14 <kmc> but you shouldn't expect it to be a selling point
14:19:30 <Lycurgus> Jafet, dunno if you're talking to me, so won't give the reply I would if I thought you were.
14:19:31 <sproingie> sure but STM doesn't exactly fit well with arbitrary side effects
14:19:40 <conal> i like mutation so much that i want oodles of it -- simultaneous & continuous.
14:19:51 <sproingie> i can't think of any way to describe continuous mutation but functionally
14:19:59 <jmcarthur> :)
14:20:00 <sproingie> going full circle i guess
14:20:01 <kmc> if you're lucky you will get the attitude "Haskellers are smart, let's hire some and make them do boring tasks in C++"
14:20:02 <Philippa> sproingie: relationally
14:20:06 <kmc> fact is, C++ is as hard to learn properly as Haskell
14:20:20 <ManateeLazyCat> soupdragon: Do you have time ? Can you install package poppler (pdf viewer)? 
14:20:26 <sproingie> i used to like C++ til i read Effective C++
14:20:30 <ManateeLazyCat> soupdragon: If poppler is okay, i will release gtk2hs-0.11.1
14:20:38 <ManateeLazyCat> soupdragon: Then i can release my project.
14:20:43 <sproingie> some saw it as a treasure trove of knowledge.  i saw it as a partial map to the minefield that the langauge is
14:20:59 <tg_> kmc: for some levels of provability, c++ is impossible to learn properly
14:21:00 <conal> c++'s complexity is the tip of the iceberg.  much more complex is the semantics of systems described in c++ (or other imperative languages/types)
14:21:11 <conal> ("types" to include haskell io)
14:21:34 <soupdragon> im trying to update right now
14:21:54 <ManateeLazyCat> soupdragon: Thanks,
14:22:17 <ManateeLazyCat> soupdragon: If have any error, please let me know, i will fix it.
14:22:26 <Jafet> Lycurgus: no need to be modest. This is IRC, after all.
14:22:31 <soupdragon> I dont seem to be getting update
14:23:08 <ManateeLazyCat> soupdragon: I binding to newest version of poppler, but looks most user haven't install newest version, maybe i need add some marco to fix version problem.
14:23:10 <kmc> Lycurgus, i don't think this is "the wrong channel" for someone interested in programming
14:24:03 <conal> afaict, the complexity of imperative concurrency is mainly due to nondeterminism, which comes from interleaving.  continuous mutation interferes with interleaving and hence nondeterminism and hence that complexity.
14:24:14 * ManateeLazyCat Build patch-tag.com repository for alpha test ...
14:24:25 <soupdragon> ManateeLazyCat  does poppler use GTK ??? (I don't have that)
14:24:44 <conal> i've been playing with this perspective.  don't know whether it makes sense to anyone else.
14:24:51 <jmcarthur> i get it
14:24:56 <ManateeLazyCat> soupdragon: Yes.
14:25:00 <conal> :)
14:25:08 <soupdragon> ManateeLazyCat - it wont run for me
14:25:13 <ManateeLazyCat> soupdragon: Oh, i forgot you're Mac user.
14:25:17 <ManateeLazyCat> soupdragon: Sorry.
14:25:18 <jmcarthur> conal: although i think i would have said that interleaving interferes with continuous mutation
14:25:19 <soupdragon> I never managed to get the working install
14:25:33 <jmcarthur> brb
14:25:36 <Lycurgus> kmc, yeah it's a crowded channel a lot of different types. I'm not thin skinned fortunately.
14:25:47 <kmc> that's good :)
14:25:58 <ManateeLazyCat> soupdragon: BTW, you can install gtk+ on Mac?
14:26:02 <soupdragon> no
14:26:29 <conal> jmcarthur: yeah.  that statement is probably more easily approached.
14:26:32 <ManateeLazyCat> soupdragon: Hmm, you perhaps can't use my program.
14:26:44 <ManateeLazyCat> soupdragon: It's base gtk2hs, it need you install Gtk+
14:27:26 <Philippa> the way delay (and related concepts) work still occasionally does my head in regarding the potential complexity
14:28:21 <conal_> thx for the chat, all.  i'm heading out.
14:28:39 <Jafet> conal: what do you think of erlang, then? It's an imperative stateful concurrent language -- and highly regarded
14:29:02 <Jafet> Drat, oh well
14:29:32 <sproingie> erlang's syntax makes my eyes bleed
14:29:49 <conal_> Jafet: i think denotationally.  erlang has always struck me as very operational (e.g., message sending), so it hasn't grabbed my interest enough to learn more.
14:32:05 <jmcarthur> back
14:36:05 * hackagebot data-object 0.3.1.2 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.1.2 (MichaelSnoyman)
14:39:06 * hackagebot convertible-text 0.3.0.1 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.1 (MichaelSnoyman)
14:39:08 * hackagebot wai 0.2.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.2.0 (MichaelSnoyman)
14:39:10 * hackagebot wai-extra 0.2.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.0 (MichaelSnoyman)
14:39:12 * hackagebot wai-handler-fastcgi 0.2.0 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.2.0 (MichaelSnoyman)
14:43:15 <om-foxy> I was trying to install package cairo, which led me to upgrade from debian lenny to sid (and recompile the kernel on the way).  Now ghci won't load because the libgmp library has changed.  I can see libgmp.so.3 in /usr/lib.  Do I have to recompile ghc?  Or can I run some sort of pkg-config tool?
14:43:57 <ManateeLazyCat> om-foxy: Just re-compile cairo package.
14:47:02 <om-foxy> ManateeLazyCat:  I'm not yet at doing anything with cairo.  I'm trying to rebuild hmatrix.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27370#a27370
14:48:27 <ManateeLazyCat> om-foxy: No idea about hmatrix
14:48:50 <om-foxy> hmatrix isn't the problem.  ghci won't load
14:50:21 <om-foxy> (see hpaste)
14:53:10 * hackagebot formlets 0.7.2 - Formlets implemented in Haskell  http://hackage.haskell.org/package/formlets-0.7.2 (DougBeardsley)
14:54:08 <Jafet> @let US = (++" measly bucks") . show
14:54:09 <lambdabot>  <local>:7:0: Not in scope: data constructor `US'
15:00:42 <chrisdone> beep
15:00:44 <Itkovian> Just in case anybody is interested: http://lctes2011.elis.ugent.be/?file=kop1.php
15:00:55 <chrisdone> @tell nominolo where's your wiki template at?
15:00:55 <lambdabot> Consider it noted.
15:02:16 <soupdragon> what is that Itkovian???
15:02:24 <ManateeLazyCat> Can anyone help me test poppler package? It's version looks too new that build failed on hackage. 
15:02:55 <Itkovian> soupdragon: CFP for LCTES
15:03:35 <Itkovian> Given that haskell excels at domain-specific language stuff, I thought it might be approapriate.
15:06:28 <tommd> Is there a tool (like derive or DriFT) that can derive a one-off Show instance?  
15:06:28 <tommd> For example, I want "data Foo = Foo | Bar deriving (Eq, Ord, {-! ShowLower !-})" such that an instance of Show will be generated using "map toLower"
15:07:13 <lowasser> I mean, you could, y'know, actually write out the instance =P
15:08:16 <tommd> lowasser: Yes, that is obvious - if I couldn't write out  the instance manually then I'd have no hope of an automated tool getting it.
15:08:43 <Jafet> You could use a middle typeclass and some ghc extensions
15:10:11 <tommd> Not a bad idea.  Something like "class LowShow a where lshow :: a -> String" and "instance (Show a) => LowShow a where lshow = map toLower . show"
15:10:40 <soupdragon> can anyone recommend to me:
15:10:47 <soupdragon> The best way to write a FOL proof checker
15:12:00 <Jafet> I can recommend WarGames.
15:12:35 <soupdragon> can it be done in a basic type theory?
15:14:04 <soupdragon> lambda calculus is much simpler....
15:14:23 <hpc> tommd: s/map/fmap
15:14:28 <hpc> you might want more than just lists
15:14:30 <geheimdienst> using Parsec 3, can this be simplified? line = do k <- foo; v <- bar; return (k,v)
15:14:41 <Jafet> Which lambda calculus?
15:14:47 <hpc> :t mapM2
15:14:48 <lambdabot> Not in scope: `mapM2'
15:14:51 <geheimdienst> a list instead of a tuple would also be okay
15:14:52 <hpc> :t liftM2
15:14:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:15:06 <geheimdienst> ok i'll try that ...
15:15:11 <hpc> liftM2 (,) foo bar
15:15:24 * ManateeLazyCat Do a diff for poppler-0.12.4 and poppler-0.14.0 
15:15:50 <geheimdienst> yay it works :-) thanks hpc
15:17:44 <tommd> hpc: Typically a reasonable point, but how can 'show' give something besides a list? ;-)
15:18:03 <Jafet> :t show
15:18:04 <lambdabot> forall a. (Show a) => a -> String
15:19:17 <benmachine> tommd: what's the point of the class?
15:19:26 <benmachine> why not just define lshow = map toLower . show
15:19:28 <benmachine> and be done with it
15:19:52 <lowasser> smart
15:21:33 <andreo> I want to create script on haskell like #!/usr/bin/.... How can i do it?
15:21:47 <ddarius> #!/usr/bin/runhaskell
15:21:51 <hpc> #!/usr/bin/runhaskell
15:21:53 <hpc> or ninja
15:22:10 <sproingie> ninja?
15:22:17 <sproingie> oh
15:22:41 * sproingie has a black cat named ninja
15:23:09 <hpc> nice
15:23:15 <dancor> where is the latest version of yampa space invaders?
15:23:39 <sproingie> and i think he's even part oriental shorthair
15:24:26 <dancor> the haskell code for it
15:25:30 <hpc> @hoogle String -> IO a
15:25:31 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
15:25:31 <lambdabot> Network.Socket.Internal throwSocketError :: String -> IO a
15:25:31 <lambdabot> System.Environment withProgName :: String -> IO a -> IO a
15:25:47 <hpc> @hoogle String -> IO ()
15:25:48 <lambdabot> Prelude putStr :: String -> IO ()
15:25:48 <lambdabot> Prelude putStrLn :: String -> IO ()
15:25:48 <lambdabot> System.IO putStr :: String -> IO ()
15:25:55 <hpc> bah
15:25:59 <hpc> should be something in System
15:28:21 <dancor> also where is the yampa repo
15:28:52 <dancor> lol @ haskell yampa page Last updated March 22 2004 by Antony Courtney
15:30:07 <RyanT5000> @seen jaffacake
15:30:07 <lambdabot> Unknown command, try @list
15:30:23 <RyanT5000> that's odd; what happened to the seen command?
15:30:52 <slade118> has anyone tried Yi?
15:31:06 <dancor> i guess yampa is dead, last upload in '08 says that was a messy dev version?
15:31:44 <hpc> preflex: seen jaffacake
15:31:44 <preflex>  jaffacake was last seen on #ghc 11 hours, 47 minutes and 32 seconds ago, saying: and several of them  refer to _HOST_OS etc.
15:32:21 <RyanT5000> oh, is preflex a new lambdabot?
15:32:23 <hpc> contrary to all appearances and preconceptions, there are multiple bots in this channel
15:32:29 <RyanT5000> haha
15:32:31 <hpc> no, just a bot
15:33:07 <benmachine> preflex basically does the @seen thing because lambdabot's plugin bleeds memory everywhere
15:33:18 <dancor> /nick preflex seenbot
15:33:28 <dancor> clarity for all
15:33:31 <benmachine> heh
15:33:38 <mauke> preflex: list
15:33:38 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
15:33:47 <benmachine> preflex: botsnack
15:33:47 <preflex>  om nom nom
15:33:50 <benmachine> ic
15:34:46 <hpc> perhaps have preflex respond to @?
15:35:02 <hpc> i see no command collisions
15:35:20 <hpc> er, karma, nvm
15:35:24 <mauke> tell, ask
15:35:42 <mauke> remember
15:35:59 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27372#a27372
15:36:04 <int80_h> hi mauke :)
15:36:17 <Jafet> Make lambdabot delegate @seen requests to preflex!
15:36:32 <benmachine> heh that'd be cool
15:36:45 <dancor> it could use rabbitmq
15:37:38 <int80_h> would anyone care to look at my hpaste?
15:38:16 <hpc> i looked, but i don't know much of extensions
15:38:21 <dancor> int80_h: your ghci doesn't have TH
15:38:42 <int80_h> dancor : how to I import TH?
15:38:51 <int80_h> *do
15:39:42 <dancor> int80_h: i added    -XTemplateHaskell   before  --interactive  in /usr/bin/ghci
15:40:00 <dancor> i couldn't get anything less ridic to work
15:40:45 <int80_h> so you did "ghci -XTemplateHaskell" to start up ghci?
15:41:09 <dancor> that also works
15:41:22 <dancor> but i wanted it every time so i put it in the ghci shellscript itself
15:41:29 <int80_h> I wonder if there is a directive I could put in my file
15:41:36 <int80_h> ah!
15:41:41 <dancor> {-# LANGUAGE TemplateHaskell #-}
15:41:49 <dancor> but i think it didn't work for me..
15:42:28 <int80_h> seems to have worked so far
15:42:32 * ddarius considers getting a new classical electric/acoustic.
15:42:36 <int80_h> at least, no lerrors when I load the file
15:43:03 <dancor> well can you do $ stuff interactively tho?
15:43:06 <dancor> i don't think you can
15:43:12 <dancor> without the hack i did
15:43:29 <dancor> anyway idk
15:43:33 <int80_h> ya, still haveparse error
15:43:42 <soupdragon> what if I take lambda calculus and add classical logic axioms
15:44:02 <dancor> int80_h: can you edit /usr/bin/ghci
15:44:23 <int80_h> dancor : I can, but am trying my command line test first. I will try that next
15:44:29 * hackagebot poppler 0.11.1 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.11.1 (AndyStewart)
15:45:42 <int80_h> dancor : okay now I have a whole new problem
15:46:11 <ddarius> soupdragon: If you are taking a CH perspective, then you need to determine the proof terms and rewrite rules for those axioms.  If you are taking a logical framework perspective, then you simply need to develop an appropriate proof theory.
15:46:26 <int80_h> I'm going to try something first before posting current error
15:47:18 <tommd> benmachine: This is born from me wanting to have a data declaration for supported architectures of the GNU linker, but I can't directly use "show" (which would be convenient) due to the capital of the constructor ("Arm" vs "arm").  Having a class could be useful and at the same time let me override the default for those data declarations that have symbols (object formats are named annoying things like "elf-" and "a.out").  Obviously to overr
15:47:30 <soupdragon> I don't have a clue how to do this :9
15:47:31 <soupdragon> (
15:47:59 <benmachine> tommd: message got cut off at "Obivously to overr"
15:48:10 <benmachine> but you aren't suggesting using OverlappingInstances are you :O
15:48:10 <tommd> Having a class could be useful and at the same time let me override the default for those data declarations that have symbols (object formats are named annoying things like "elf-" and "a.out").  Obviously to override I'd need overlapping instances, so this is more annoyance than its worth.
15:48:16 <tommd> No, I'm not
15:48:26 <benmachine> heh
15:48:27 <benmachine> ok
15:48:50 <ddarius> soupdragon: Just start doing it until you run into a problem.
15:48:51 <tommd> odd - I thought Pidgin was better about breaking up IRC messages.
15:49:15 <soupdragon> but I dont want problems
15:49:27 <ddarius> soupdragon: Too bad.
15:53:34 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27372#a27373
15:53:49 <int80_h> ddarius, that's where I ended up
15:54:20 <dancor> are there any FRP libraries that are still alive?
15:56:02 <mauke> @seen
15:56:02 <preflex>  what
15:56:02 <lambdabot> Unknown command, try @list
15:56:14 <mauke> @seen lambdabot
15:56:14 <preflex>  lambdabot was last seen on #haskell 12 seconds ago, saying: Unknown command, try @list
15:56:14 <lambdabot> Unknown command, try @list
15:56:35 <mauke> preflex: version
15:56:36 <preflex>  2.647
15:57:21 <djahandarie> > "Known command!"
15:57:23 <lambdabot>   "Known command!"
15:57:47 <mauke> @run
15:57:48 <lambdabot>   not an expression: `'
15:57:51 <mauke> @eval
15:57:55 <djahandarie> Nice
15:57:57 <mtnviewmark> grr.. wish XHTML package had just a little bit of documentation
15:57:57 <lambdabot> mtnviewmark: You have 1 new message. '/msg lambdabot @messages' to read it.
15:57:59 <djahandarie> @run "Test"
15:58:00 <lambdabot>   "Test"
15:58:01 <int80_h> mauke, could you take a look at my hpaste?
15:58:04 <djahandarie> Oh
15:58:09 <djahandarie> That was lambdabot lol
15:58:12 <mauke> yeah, @seen needs to become an alias for @eval
15:58:31 <int80_h> oh wait, how about you djahandarie? I remember you from earlier :)
15:58:58 <djahandarie> Seems like it stays "Here's where I am at now" at the top of your file
15:59:20 <soupdragon> Why is there no category theory proof assistant?
15:59:35 <soupdragon> if you can axiomatize SET
15:59:54 <int80_h> djahandarie : hah no the next line is where I begin
16:00:15 <int80_h> besides my errors would look different if that were in my file
16:00:49 <djahandarie> I don't know much about fclabels, waiting for hackage to stop going slow as molasses for me
16:01:09 <djahandarie> Oh
16:01:15 <djahandarie> It worked fine after you added -XTypeOperators
16:01:17 <djahandarie> What's the problem?
16:01:58 <djahandarie> ghci will print out what the expression evaluates to, and you directly typed in a function. It doesn't know how to print a function
16:02:43 <int80_h> ah!
16:03:16 <djahandarie> Try :t _name
16:04:20 <int80_h> *Main> :t _name
16:04:20 <int80_h> _name :: Person -> String
16:04:23 <djahandarie> Yep
16:04:59 <djahandarie> And once you run the mkLabels
16:05:24 <djahandarie> Template Haskell will derive your new label functions
16:05:43 <djahandarie> And in your file you need to give those functions types
16:06:04 <int80_h> ah, I tried that and it compiles
16:06:17 <mreh> everyone gets excited about template haskell, what's there to be excited about? boilerplate reduction?
16:06:18 <int80_h> okay so I can't use ghci for everything I want, that's fine
16:06:33 <int80_h> I'm not excited, just bound to use it.
16:06:40 <djahandarie> int80_h, all ghci can do is evaluate an expression (and execute IO)
16:06:41 <int80_h> I don't even understand it
16:06:48 <dancor> "cabal: cannot configure QuickCheck-2.1.1.1. It requires ghc -any"
16:06:52 <int80_h> gotcha
16:08:06 <djahandarie> When you typed in name :: Person :-> String, you were basically asking "give me a 'name' with the type of Person :-> String"
16:08:14 <djahandarie> And since that is a valid type for it, it did.
16:08:53 <dancor> mreh: the TH paper lists like five things including that
16:09:10 <dancor> iirc they make the biggest deal about custom optimizations?
16:09:15 <mreh> oh, paper
16:09:39 * hackagebot xine 0.0.0.2 - Bindings to xine-lib  http://hackage.haskell.org/package/xine-0.0.0.2 (JoachimFasting)
16:09:43 <dancor> in the wild, i think boilerplate reduction is what i've seen the most
16:10:19 <djahandarie> I don't use template haskell, haven't had a need yet
16:11:59 <dancor> DeriveTH is very useful
16:12:24 <dancor> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
16:13:28 <dancor> but if you are content to write your binary instances, have fun
16:14:00 <marcot> http://www.spoj.pl/SHORTEN/problems/LOOK_SAY/
16:14:01 <djahandarie> Neil Mitchell seems to constantly put out sweet shit
16:14:14 <marcot> I got to 108.  Anyone wanna try a smaller one?
16:14:45 <Phyx-> Is it possible to profile calls across FFI?
16:14:53 <Phyx-> I suppose it should.. the rts is still running
16:15:20 <Jafet> Well, it obviously gets in the way of profiling certain things
16:15:48 <marcot> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27378#a27378
16:15:49 <Phyx-> well, i'm only interested in time spend in haskell functions
16:15:54 <marcot> If anyone knows how to improve it.
16:16:54 <Phyx-> even though my standalone benchmarks show radical improvements, I see none in actual usage, so I wanna know why..
16:17:37 <Jafet> Yeah, that's one of the things FFI gets in the way of.
16:17:57 <Phyx-> hmm, any ideas how to do it then?
16:18:07 <dancor> so cabal-install hates QuickCheck-2.1.1.1 for me.  can i blacklist it?
16:18:51 <dancor> i want to install a bunch of things with cabal-install and none of them will build over this.
16:19:51 <dancor> http://hackage.haskell.org/trac/hackage/ticket/380#comment:2
16:19:53 <djahandarie> There seriously needs to be some tutorials and stuff on quickcheck 2
16:19:57 <djahandarie> Along with the wiki being updated
16:20:53 <dancor> ok i can do --constraint 'QuickCheck < 2.1.1.1'
16:21:28 <dancor> i had to go back several versions to QuickCheck-2.1.0.2.  i wonder what this ghc dependency business is.
16:22:35 <Phyx-> what's the flag to enable profiling in cabal again?
16:22:45 <Phyx-> -p?
16:23:07 <dancor> Phyx-: yes
16:23:36 <dancor> there's some other weird stuff in  cabal help install
16:23:39 <tensorpudding> You don't get much out of profiling unless you use it on everything
16:24:07 <dibblego> e
16:24:11 <Phyx-> damnit, my ghc 6.13 doesn't have profiling support
16:24:11 <tensorpudding> you can change your cabal configuration to build everything with profiling support
16:25:27 <Phyx-> but when i try to build with it segfaults
16:25:48 * hackagebot hmatrix-gsl-stats 0.1.2.3 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.3 (VivianMcPhail)
16:25:53 <Phyx-> it must be marshalling that's brutally slow
16:26:14 <Phyx-> there's nothing else but that left to optimize :S
16:26:35 <dancor> been there :/
16:27:01 <blackdog> that's something that's sort of annoying - if you change your default cabal parameters (like enable-library-profiling), you pretty much have to blow away your install - it won't rebuild dependencies with profiling otherwise
16:29:44 <mtnviewmark> yup - I think everyone of us had encountered that snag, blackdog
16:30:36 <blackdog> mtnviewmark: it'd be interesting to know why it happens. does cabal not store in its database what options were enabled for a given package?
16:30:50 * hackagebot hstatistics 0.2.2.2 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.2 (VivianMcPhail)
16:31:00 <mtnviewmark> actually, cabal doesn't have a db of packages installed - ghc keeps that
16:31:21 <mtnviewmark> and, it *does* know if there is or isn't a profile version
16:32:01 <mtnviewmark> but I think the issue is that cabal doesn't know the history of the settings - therefore it doesn't try to "fix up" 'cause it doesn't really know if what is there conforms to the current settings or no
16:32:12 <mtnviewmark> (other than the existence of the profile version)
16:33:06 <mtnviewmark> a similar problem happens when you install A which requires a newer version B than you have --- that all goes smoothly, but all the things you have that relied on the older B will, at some point need to be rebuilt
16:33:11 <mtnviewmark> or you won't be able to use them with A
16:33:28 <mtnviewmark> once again, ghc *knows* this, but cabal doesn't know when (or if) it should go ahead and rebuild
16:34:17 <blackdog> i'm not really sure i understand
16:34:21 <blackdog> why can't cabal ask ghc?
16:34:33 <blackdog> is it just a plain bug, or a deep consequence of a design decision?
16:34:55 * hackagebot hsignal 0.1.2.2 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.2.2 (VivianMcPhail)
16:36:06 <mtnviewmark> blackdog - I think the issue is that say you have B.1 and C.1 relying on B.1.  Now you install A.2 requiring B.2 -- so now you have A.2, B.1, B.2, and C.1 ---- 
16:36:59 <mtnviewmark> cabal doesn't know *if* you want to recompile C.1 to rely on B.2 or not ---- if you are trying to combine C with A, then you'd want it -- -but if you were trying to combin C with, say D.1 relying on B.1, then no
16:37:11 <mtnviewmark> now, it could just say "re-up 'em all!"
16:37:20 <mtnviewmark> but what if D.1 can't use B.2????
16:37:33 <blackdog> hang on, i'm going to draw a diagram
16:37:39 <mtnviewmark> now it doesn't know which you'd prefer - to break C w/A or C w/D
16:38:01 <blackdog> did you mean to say "B.1 and C.1 relying on B.1"?
16:39:01 <mtnviewmark> C.1 needs B.1 or B.2, but is compiled against B.1 (say)
16:39:13 <mtnviewmark> D.1 needs B.1, but is marked as can't use B.2
16:39:13 <blackdog> ah, this is just the versioning stuff, though - we have a closed set of shared/profiling/blah options, so i don't think the same argument works
16:39:20 <mtnviewmark> A.1 needs B.2
16:39:52 <mtnviewmark> sorry - thought you were asking about the "same things goes" part ....
16:40:23 <blackdog> well, yes, i was, but i only just realised that it's a different problem
16:40:27 <mtnviewmark> as for profiling - It could, I suspect, just generate all the missing profile libs (assuming you still have the versions of the packages things were built from)
16:42:10 <Phyx-> dictionaries are resolved at compile time aren't they? so those shouldn't be a source of slotdown right? I have alot of calls to class methods in my marshalling code
16:42:26 <Jafet> Not in polymorphic code.
16:42:52 <Phyx-> but if explict type signatures were given?
16:42:54 <Jafet> Blaming them is probably unproductive, though
16:43:00 <Jafet> Then probably optimized out.
16:44:19 <soupdragon> I like the proofs in Awodey
16:44:26 <soupdragon> it's usually just two words
16:46:18 <Veinor> "It's trivial."
16:48:24 <Phyx-> after coding for 14 hours straight today, I think I've had just about enough...
16:49:59 * hackagebot mwc-random 0.5.1.4 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.5.1.4 (BryanOSullivan)
16:50:57 <olsner> Phyx-: do everyday object produce synesthetic images of syntax trees and data types?
16:51:04 <olsner> if not I think you can go a little bit further
16:51:27 <Phyx-> hehehe
16:51:39 <Phyx-> I just noticed that... ghc was throwing errors compiling the file
16:51:50 <Phyx-> but the later phases still say linking
16:51:57 <Phyx-> it must be reusing an old object file
16:52:09 * Phyx- crosses his fingers and hopes that's it
16:52:34 <Phyx-> actually, how the heck is it working...
16:53:37 <olsner> how it works? files and bits and spinning disks and some kind of state machine in the middle... it's complicated :P
16:54:03 <Phyx-> olsner: well, i mean, hos does it still work while throwing errors
16:54:35 <Phyx-> oh i get it
16:54:43 <Phyx-> that's silly...
16:55:33 <Phyx-> it appears that because i compiled the tool on 6.12.1
16:55:40 <Phyx-> but was running it on a path with 6.13
16:55:49 <tensorpudding> oh noes, I broke darcs
16:55:51 <Phyx-> that it was still using the 6.12.1 ghc api
16:56:27 <tensorpudding> ncurses got upgraded and now darcs is disappointed
16:58:05 * Phyx- is rapidly approaching the point where begging ghc seems like an option
16:58:50 <hpc>  /usr/src/package $] please ghc --make Main.hs
16:59:02 * hackagebot statistics 0.6.0.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.6.0.1 (BryanOSullivan)
16:59:30 <hpc> this makes me wonder if there is a "please" utility in GNU
16:59:41 <Phyx-> most likely
17:00:06 <Phyx-> and does "man female" work? :P
17:00:55 <Jafet> See woman(1)
17:03:02 <Phyx-> http://phyx.pastebin.com/WXGBr1bX that's the marshalling code. anyone got any clues on where to start looking for slowdowns?
17:03:03 * Phyx- sees everyone disconnect their screens
17:04:04 * hackagebot criterion 0.5.0.2 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.2 (BryanOSullivan)
17:04:41 <Phyx-> i should start bribing you folks with cookies
17:05:30 <hpc> i got to almost the end of the imports before losing attention span
17:05:40 <Phyx-> rofl
17:05:46 <Phyx-> there are only 26 imports :P
17:05:53 <hpc> "only"
17:06:14 <hpc> if the comment at the top is accurate, i might start with whatever did the generating?
17:06:27 <olsner> I got as far as the import WinDll-something
17:06:35 <Phyx-> hpc: that would be my tool :P
17:08:53 <Phyx-> can... you add inline pragmas to class members too?
17:09:21 <olsner> in the class or in the instance declaration?
17:09:30 <olsner> in instances, yes you can
17:10:04 <Phyx-> question is, would that give me any benefits
17:11:07 <Phyx-> there are roughtly atleast 50-60 calls to instance members in that code. most with implementation just other function calls
17:11:48 <olsner> profiling and ghc-core are your friends
17:12:34 <Phyx-> i can't do profiling
17:13:01 <Phyx-> my ghc doesn't support it. (the baselibs) and when i compile using it, it segfaults
17:13:17 <Phyx-> and afaik, dictionaries are still explicit in core
17:14:26 <olsner> of course, you *could* sprinkle inline and specialize liberally and see what effects it has
17:15:27 <Phyx-> well it's worth a shot
17:17:51 <Phyx-> guess the first thing to do is make some objective way of measuring
17:18:08 <Veinor> @pl \x -> (length x, x !! 0)
17:18:09 <lambdabot> liftM2 (,) length (!! 0)
17:18:26 <olsner> x !! 0 == head x
17:18:29 <Veinor> derp
17:18:47 <Veinor> > map (liftM2 (,) length head) $ group "aaabcccba"
17:18:48 <lambdabot>   [(3,'a'),(1,'b'),(3,'c'),(1,'b'),(1,'a')]
17:18:54 <Phyx-> both equally unsafe..
17:19:02 * Phyx- wonders why the prelude doesn't have a safeHead
17:19:18 <Veinor> > group []
17:19:19 <lambdabot>   []
17:19:30 <Veinor> group xs is guaranteed not to contain [], I think
17:19:48 <Veinor> so I'm safe
17:20:44 <Veinor> > concatMap (\x -> (show . length) x : head x : []) (group "11123")
17:20:44 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:20:45 <lambdabot>         against inferred ty...
17:20:57 <Veinor> :t (\x -> (show . lengtH) x : head x : [])
17:20:58 <lambdabot> Not in scope: `lengtH'
17:21:01 <c_wraith> Veinor, liftM2 (,) is the same as (&&&)
17:21:04 <Veinor> :t (\x -> (show . length) x : head x : [])
17:21:05 <lambdabot> [String] -> [String]
17:21:13 <Veinor> hm
17:21:24 <Veinor> > map  (\x -> (show . length) x : head x : []) (group "11123")
17:21:24 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:21:25 <lambdabot>         against inferred ty...
17:21:36 <Veinor> oh awit.
17:21:42 <Phyx-> @google
17:21:42 <lambdabot> Empty search.
17:21:47 <Phyx-> @google define:help
17:21:47 <lambdabot> No Result Found.
17:21:53 <Phyx-> boo
17:21:59 <Veinor> > concatMap  (\x -> (show . length) x ++ [head x]) (group "11123")
17:22:00 <lambdabot>   "311213"
17:22:28 <Veinor> > let lookAndSay = concatMap (\x -> (show . length) x ++ [head x]) . group in iterate lookAndSay "1"
17:22:29 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
17:22:52 <Veinor> > let lookAndSay = concatMap (\x -> (show . length) x ++ [head x]) . group in iterate lookAndSay "2"
17:22:53 <lambdabot>   ["2","12","1112","3112","132112","1113122112","311311222112","1321132132211...
17:23:59 <hpc> shame that operation isn't reversible
17:24:02 <Veinor> @pl \x -> (show . length) x ++ [head x]
17:24:02 <lambdabot> ap ((++) . show . length) (return . head)
17:24:03 <Phyx-> wait.. how does the inline pragma work again, do you put it at the definition site of the function or at the call site?
17:24:05 <hpc> would be a fun exercise
17:24:21 <Veinor> hpc: writing a function that computes an inverse isn't terribly difficult
17:24:25 <soupdragon> I always hated stuff like that
17:24:31 <soupdragon> when people show you a sequence and ask whats the pattern
17:24:56 <Phyx-> @google GHC PRagmas
17:24:57 <lambdabot> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/pragmas.html
17:24:58 <lambdabot> Title: 7.13.�Pragmas
17:25:22 <Veinor> > let lookAndSay xs = group xs >>= (\x -> (show . length) x ++ [head x]) in iterate lookAndSay "2"
17:25:23 <lambdabot>   ["2","12","1112","3112","132112","1113122112","311311222112","1321132132211...
17:25:31 <Veinor> monads!
17:25:57 <djahandarie> @pl let lookAndSay xs = group xs >>= (\x -> (show . length) x ++ [head x])
17:25:58 <lambdabot> (line 1, column 71):
17:25:58 <lambdabot> unexpected end of input
17:25:58 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<", ";" or "in"
17:26:04 <djahandarie> @pl lookAndSay xs = group xs >>= (\x -> (show . length) x ++ [head x])
17:26:05 <lambdabot> lookAndSay = (ap ((++) . show . length) (return . head) =<<) . group
17:26:33 <djahandarie> lol, @pl being usless as usual
17:26:49 <Veinor> :P
17:27:37 <hpc> @pl let f=(\x -> (show . length) x ++ [head x]) in lookAndSay xs = group xs >>= f
17:27:37 <lambdabot> (line 1, column 62):
17:27:38 <lambdabot> unexpected "="
17:27:38 <lambdabot> expecting variable, "(", operator or end of input
17:28:01 <hpc> bah
17:28:23 <djahandarie> > iterate(ap((++).show.length)(return.head)=<<).group "2"
17:28:24 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:28:24 <lambdabot>         against inferred ty...
17:28:31 <djahandarie> Aww
17:28:33 <Veinor> "Every sequence eventually splits into a sequence of "atomic elements", which are finite subsequences that never again interact with their neighbors. There are 92 elements containing the digits 1,2,3 only, which John Conway named after the natural chemical elements. There are also two "transuranic" elements for each digit larger than 3"
17:29:29 <adu> wow!?!
17:29:41 <Veinor> :D
17:29:50 <hpc> that's clever
17:30:03 * adu <3 John Conway
17:30:16 <adu> he also invented chained arrow notation
17:30:44 <Veinor> I met him once!
17:30:51 <hpc> awesome
17:30:51 <Veinor> in, like, fifth grade
17:30:56 <om-foxy> adu: what IRC command is used for that emote? (<3 John Conway)
17:31:14 <Veinor> om-foxy: it's just a less than sign followed by a 3
17:31:23 <om-foxy> no, the IRC command
17:31:24 <Veinor> I guess your client renders that differently
17:31:33 <Veinor> oh
17:31:33 <hpc> it isn't a command
17:31:39 <om-foxy> :)
17:31:39 <Veinor> /me does stuff
17:31:41 * Veinor does stuff
17:31:48 * om-foxy learned something
17:31:49 * hpc /me's
17:32:42 <Cale> I met him at what turned out to be Coxeter's last birthday party, held at the Fields Institute in Toronto.
17:32:55 <Cale> Well, I think it was his last...
17:32:59 <Cale> Maybe second last
17:33:59 * Veinor has a signed copy of ONAG and Winning Ways volumes 1 and 2 <3
17:34:39 * Phyx- is lost in his own code
17:35:44 <Phyx-> whah, nvm, found my way
17:36:23 <Phyx-> ok, INLINE pragmas sprinkeled
17:36:29 <Phyx-> time to compile and test
17:36:33 <djahandarie> >iterate((ap((++).show.length)(return.head)=<<).group)"2"::[String]
17:36:47 <djahandarie> > iterate((ap((++).show.length)(return.head)=<<).group)"2"::[String]
17:36:48 <lambdabot>   ["2","12","1112","3112","132112","1113122112","311311222112","1321132132211...
17:40:41 <Veinor> are we golfing look and say?
17:41:47 <djahandarie> If golfing == pl and remove spaces then stop thinking about it, yes
17:41:48 <Phyx-> i remember the look and see
17:42:25 <Phyx-> say*
17:42:41 <Veinor> :D
17:45:09 <Cale> > iterate(((++)<$>show.length<*>return.head=<<).group)"1"
17:45:10 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
17:45:57 <Cale> > iterate(((++)<$>show.length<*>(:[]).head=<<).group)"1"
17:45:58 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
17:46:05 <Nikc> Boo
17:46:11 <Cale> hello
17:46:18 <hpc> hey
17:46:20 <Nikc> Scared one away, summoned another
17:46:21 <twanvl> > iterate(((++)<$>show.length<*>pure.head=<<).group)"1"
17:46:23 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
17:46:25 <Nikc> Clearly this is going to be fun
17:46:35 <davekong> Would it be sane or feasible to write a kernel in Haskell(or has it been done)?
17:46:44 <Cale> davekong: Has been done
17:46:49 <hpc> a group designed it in haskell
17:46:54 <mreh> didn't somone verify one
17:46:54 <hpc> implemented in C after proving it correct
17:47:01 <mreh> yah
17:47:04 <ezyang> Cale: Really? I thought they just made GHC not need a kernel... 
17:47:09 <Cale> http://programatica.cs.pdx.edu/House/
17:48:18 <krey> hi
17:48:20 <krey> (fmap f x,fmap f y)          ?=           fmap (fmap f) (x, y)
17:48:33 <krey> (ghci says no)
17:48:55 <krey> can someone help please?
17:49:01 <soupdragon> krey, yes the thing about pairs is the functor is  (,) a :: * -> *
17:49:03 <mreh> @instances Functor
17:49:03 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:49:05 <soupdragon> so a is completely fixed
17:49:39 <mreh> (,) is not a functor
17:49:49 <krey> ah
17:49:54 <krey> thank you
17:50:01 <JoeyA> "hpc> implemented in C after proving it correct" However, you have to dig deeper into that story to find out they spent about 10 man-years writing about 200,000 lines of Isabelle proof code to do that.
17:50:21 <hpc> oh right, forgot about that
17:50:37 <mreh> how much is man-year?
17:50:46 <JoeyA> one man spending a year
17:50:47 <hpc> 40*52 hours, i think
17:51:00 <JoeyA> bah, my answer was inane
17:51:25 <JoeyA> So one thing they didn't prove is that writing programs in Haskell doesn't magically make them correct.
17:51:45 <hpc> it magically makes them easily provable :P
17:51:51 <JoeyA> heh
17:51:59 <mreh> semantic errors get into my code all the time
17:52:03 <mreh> I am only human
17:52:04 <ksf> shouldn't it be possible to abuse seq to influence the memory layout of a data structure?
17:52:07 <JoeyA> I wonder if there's a way to make this shorter:  return foo <*> a <*> b >>= id
17:52:26 <JoeyA> (to clarify, it's the same as x <- a; y <- b; foo a b
17:52:28 <JoeyA> )
17:52:29 <soupdragon> x >>= id  -->  join x
17:52:42 <hpc> :t join
17:52:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:52:48 <davekong> JoeyA: uses triple negatives in a sentence obscures the meaning
17:52:49 <JoeyA> @hoogle join
17:52:50 <soupdragon> :t 
17:52:50 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
17:52:50 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
17:52:50 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
17:52:51 <lambdabot> <no location info>: not an expression: `'
17:52:51 <soupdragon> :t join . return 
17:52:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
17:52:53 <soupdragon> :t join . return
17:52:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
17:52:58 <soupdragon> join . return ~~> id
17:53:23 <davekong> double negatives*
17:53:26 <soupdragon> return foo <*> ...  --> foo <$> ...
17:53:28 <JoeyA> heh
17:53:40 <soupdragon> f <$> x <*> y --> liftA2 f x y
17:53:52 <ksf> that is, if I deepseq a generator of a vanilla binary tree in van emde boas order, do I get a cache-oblivious (albeit pointer-based) memory layout?
17:54:11 <hpc> plus the constraint that x and y are also monads, i think
17:54:15 <hpc> because of the use of return
17:55:13 <ksf> hmmm even if I do get one, it's not going to survive compaction.
17:56:32 <Cale> hpc: x and y aren't monads, they're computations (in some monad or applicative functor)
17:56:46 <Phyx-> anyway, gn all
17:56:53 <Phyx-> i've had enough haskell for one day
17:56:55 <hpc> i mean, to match the type constraints of what he wanted shortened
17:57:08 <hpc> :t \a b -> return foo <*> a <*> b >>= id
17:57:09 <lambdabot> Not in scope: `foo'
17:57:14 <hpc> :t \a b -> return f <*> a <*> b >>= id
17:57:15 <lambdabot> forall a a1 (m :: * -> *) b. (Show a, Show a1, SimpleReflect.FromExpr (m b), Monad m, Applicative m) => m a -> m a1 -> m b
17:57:38 <hpc> :t \a b -> f <$> a <*> b
17:57:39 <lambdabot> forall a a1 b (f :: * -> *). (Show a, Show a1, SimpleReflect.FromExpr b, Applicative f) => f a -> f a1 -> f b
17:57:46 <hpc> missing a monad constraint
17:58:07 <Cale> Yeah, it's more general
17:58:40 <FunctorSalad> anyone else likes to build contrived cabal-wrapper shell scripts? I have one that manually unpacks the package so it can cabal haddock wit custom objects... and one that repeatedly cabal installs a list of packages until the success/failure list becomes a fixed point, lol
17:58:56 <FunctorSalad> s/wit/with/
17:59:00 <hpc> FunctorSalad: haha
17:59:24 <blackdog>  FunctorSalad: "like to build", no. "end up building"... :)
17:59:24 <ezyang> FunctorSalad: ... 
17:59:32 <hpc> actually, the last one would be handy as a way of doing a "maximal install"
17:59:40 <mreh> some of the "discussion" in -blah regularly gets out of hand
17:59:40 <hpc> to install everything that's possible to install
17:59:55 <hpc> clearly we need a #haskell-blah-blah
18:00:14 <hpc> where the topic is (haskell && not haskell)
18:00:15 <FunctorSalad> (the former also autochases "Perhaps you haven't installed the .... blah.dyn library" quasi-dependency-errors :))
18:00:20 <soupdragon> lolololol
18:00:22 <FunctorSalad> blackdog: correct
18:00:59 <FunctorSalad> the second could be made more robust by detecting arbitrary cycles, not just length-1... ;)
18:01:44 <hpc> FunctorSalad: my first thought was that that would be memory-hungry, but each loop takes a while, so could be handy
18:02:43 <tolkad> > fix (\a -> a)
18:02:47 <lambdabot>   mueval-core: Time limit exceeded
18:02:55 <FunctorSalad> hpc: why? it just runs single cabal-installs in sequence
18:03:10 <tolkad> > fix (\(a -> a) -> a)
18:03:11 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:03:11 <lambdabot>         against inferred ...
18:03:28 <hpc> FunctorSalad: for tracking the results of each iteration; i was being foolish
18:03:29 <tolkad> > fix (\(a -> a) -> (a -> a))
18:03:29 <lambdabot>   Pattern syntax in expression context: a -> a
18:03:31 <hpc> > fix id
18:03:35 <lambdabot>   mueval-core: Time limit exceeded
18:03:36 <tolkad> > fix (\(a -> a) -> (\a -> a))
18:03:36 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:03:37 <lambdabot>         against inferred ...
18:03:43 <hpc> > fix $
18:03:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:03:49 <hpc> > fix ($)
18:03:50 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
18:03:50 <lambdabot>    arising from a use of `...
18:05:25 <FunctorSalad> hpc: ah, it's basically just "echo $? $package > tmp/$i" after each package, then diff tmp/$((i - 2)) tmp/$((i - 1))
18:05:27 <FunctorSalad> ;)
18:05:45 <FunctorSalad> you can just compare them like that because the order is the same every time..
18:06:06 <hpc> oh right, files
18:06:35 <FunctorSalad> yeah, you can even tail -f it for a high-level progress report that way =)
18:07:51 <FunctorSalad> (the context is that I'm trying out the --enable-shared feature, btw)
18:08:11 <FunctorSalad> lots of now-broken-but-not-auto-reinstalled dependencies
18:14:57 <Veinor> every time I think about how a language's syntax can be kind of ugly sometimes
18:14:59 <Veinor> I look at erlang
18:16:42 <FunctorSalad> (there's both a -dynamic and a -shared flag to ghc, btw?)
18:16:54 <FunctorSalad> while cabal seems to unify it in --enable-shared
18:17:35 <ksf> http://www.cs.umass.edu/~emery/pubs/06-06.pdf
18:19:04 <tolkad> why doesn't this work?
18:19:04 <tolkad> > iterate (\x -> head $ [a | a <- [last x..], not $ 0 `elem` [a / b | b <- x]]) [2]
18:19:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:19:10 <HugoDaniel> hey
18:19:15 <HugoDaniel> i need something very l33t in haskell
18:19:18 <HugoDaniel> i need to be able
18:19:21 <HugoDaniel> to call a function
18:19:24 <HugoDaniel> knowing only its name
18:19:26 <HugoDaniel> say
18:19:29 <HugoDaniel> i have a set of functions
18:19:33 <HugoDaniel> all with the same type sig
18:19:43 <HugoDaniel> and i want to call them by name
18:19:55 <HugoDaniel> "addNewLine" calls addNewLine
18:19:57 <HugoDaniel> ah
18:19:57 <tolkad> HugoDaniel: lookup "name" [("name", f)]
18:19:58 <HugoDaniel> yes
18:19:59 <FunctorSalad> the name is gone at runtime, by default
18:20:11 <tolkad> HugoDaniel: put them in a list like that
18:20:19 <FunctorSalad> use TH to deal with names first-class, or (as tolkad implied) name them with strings
18:20:32 <HugoDaniel> hmm
18:20:36 <FunctorSalad> (with 'names' in the first part I mean the actual indentifiers)
18:20:37 <HugoDaniel> i dont want to list them
18:20:54 <Cale> Another option: put them in a separate module, and interpret that module using something like hint
18:21:05 <HugoDaniel> ah
18:21:08 <HugoDaniel> thanks Cale :)
18:21:11 <tolkad> HugoDaniel: Do you expect haskell to include the names of all in-scope functions in compiled code?
18:21:12 <Cale> (You can even compile the module, and if you leave the .o around, it'll load it)
18:21:15 <Twey> > lookup "succ" [("succ", succ)] <*> Just 5
18:21:17 <lambdabot>   Just 6
18:21:25 <FunctorSalad> (I'm not sure in which form you'd be given the functions)
18:21:55 <aavogt> use TH to read your module containing those funs at compile time
18:21:58 <Cale> Using things like hint is also handy if you need a lot of isolation from failures.
18:21:59 <Twey> > lookup "succ" [("succ", succ)] `fromJust` 5
18:22:00 <lambdabot>   6
18:22:07 <aavogt> via runIO
18:22:18 <Cale> Because it turns runtime errors into strings :)
18:22:18 <FunctorSalad> you could also make a "declareNamefulFunction" macro with TH
18:22:49 <tolkad> are there any plans to port GHC to haskell?
18:22:55 <aavogt> FunctorSalad: that gets you into trouble if they are mutually recursive
18:23:01 <Cale> tolkad: GHC is written in GHC Haskell
18:23:02 <pikhq> tolkad: It is *in* Haskell.
18:23:12 <tolkad> really? I thought it used llvm?
18:23:16 * BrianHV has written his first successful foldl call.
18:23:16 <FunctorSalad> aavogt: not sure where exactly it'd store the first-class name...
18:23:25 <FunctorSalad> aavogt: but you mean due to quotation alone?
18:23:26 <HugoDaniel> thanks for all the ideas
18:23:27 <HugoDaniel> :D
18:23:35 <pikhq> LLVM is the most recently added backend.
18:23:50 <pikhq> tolkad: GHC has always been in Haskell.
18:23:55 <Cale> It also has a native code generator
18:24:01 <tolkad> oh, when I heard it used LLVM, I assumed it was written in C
18:24:09 <aavogt> FunctorSalad: I assume     declareNamefulFunction :: Q [Dec] -> Q [Dec]
18:24:12 <Cale> There are nice LLVM bindings for Haskell.
18:24:18 <aavogt> and then it writes to some IORefs
18:24:23 <pikhq> The only parts that aren't are the runtime library (in C of necessity) and the evil mangler (which is in Perl)
18:24:33 <tensorpudding> GHC will soon have LLVM output
18:24:40 <Cale> The evil mangler is pretty much obsolete anyway
18:24:50 <adu> Cale: do you mean ghc-asm?
18:24:52 <djahandarie> Has that GSoC project for switching the LLVM backend to the LLVM bindings had any progress?
18:24:56 <pikhq> And the evil mangler is an awful hack to get the obsolete C backend to work.
18:25:02 <stralep> :t fromJust
18:25:03 <lambdabot> forall a. Maybe a -> a
18:25:06 <aavogt> pikhq: supposedly the RTS doesn't have to be in C, but it is for performance
18:25:12 <FunctorSalad> aavogt: that seems like the most convenient approach indeed
18:25:17 <tolkad> if GHC is written in haskell, how do you know it doesn't contain hidden code injected every time it compiles itself but hidden from the source code?
18:25:19 <Cale> adu: ghc-asm?
18:25:28 <tolkad> http://portal.acm.org/citation.cfm?id=358210
18:25:30 <FunctorSalad> or maybe ... :: Name -> Q Exp -> Q [Dec]
18:25:36 <pikhq> aavogt: It doesn't *need* to be in C, but if you want reasonably fast code. :)
18:25:38 <Cale> adu: I mean the default backend which does native code generation.
18:25:40 <adu> pikhq: C is obsolete? i thought all programs used the C backend
18:26:04 <pikhq> adu: No, the default's been the native code gen for a while.
18:26:15 <aavogt> tolkad: how do you know 15 ninjas aren't going to pounce on you in the next minute?
18:26:17 <HugoDaniel> i like C
18:26:18 <HugoDaniel> :)
18:26:19 <pikhq> tolkad: Yes, yes. Trusting trust. This is a problem inherent to all compilers.
18:26:23 <HugoDaniel> hmm
18:26:39 <pikhq> And, for that matter, almost all *computers*.
18:26:48 <pikhq> The only way to really be sure is to build everything yourself.
18:27:01 <pikhq> And when I say everything I mean *everything*.
18:27:13 <tolkad> pikhq: or reverse engineer it from the bottom up
18:27:23 <adu> tolkad: explain how what you're talking about is possible?
18:27:30 <tolkad> adu: read the paper
18:27:47 <tolkad> adu: http://www.google.com/search?q=reflections+on+trusting+trust
18:27:59 <pikhq> adu: Trusting trust. It's a very old paper.
18:28:10 <tolkad> anyway, why doesn't this generate a list of primes?
18:28:11 <aavogt> > cycle "trusting "
18:28:11 <tolkad> > iterate (\x -> head $ [a | a <- [last x..], not $ 0 `elem` [a / b | b <- x]) [2]
18:28:11 <pikhq> It was actually *done* on early Unix.
18:28:12 <lambdabot>   <no location info>: parse error on input `)'
18:28:12 <lambdabot>   "trusting trusting trusting trusting trusting trusting trusting trusting tr...
18:28:39 <aavogt> @vixen do you trust?
18:28:39 <lambdabot> i do occassionally, i guess
18:28:46 <tolkad> @tolkad
18:28:46 <lambdabot> Unknown command, try @list
18:28:50 <tolkad> @quote tolkad
18:28:50 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
18:29:01 <blackdog> dude.
18:29:11 <djahandarie> @quote PHP
18:29:12 <lambdabot> fr30n says: <fr30n> php? eso es para vrutos
18:29:20 <djahandarie> @quote PHP
18:29:20 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
18:29:20 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
18:29:57 <Cale> > iterate (\x -> head $ [a | a <- [last x..], not $ 0 `elem` [a / b | b <- x]]) [2]
18:29:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:30:05 <pikhq> PHP? Elegant?
18:30:08 <Cale> tolkad: because it is a type error
18:30:19 * pikhq cannot imagine
18:30:22 <HugoDaniel> i want to be a great Haskell coder, and a great Assembly coder
18:30:58 <HugoDaniel> i should start using Harpy more often
18:31:42 <tolkad> oh, I forgot [1..] becomes [1,1,1,1...]
18:31:46 * geheimdienst will be, when he grows up, a great hassembly coder
18:31:54 <Cale> > [1..]
18:31:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:32:00 <tolkad> oh, it doesn't?
18:32:01 <JoeyA> I'm a great assembly coder.
18:32:03 <tolkad> > [1:]
18:32:03 <lambdabot>   A section must be enclosed in parentheses thus: (1 :)
18:32:08 <JoeyA> Problem is, I only know 68000 assembly :P
18:32:10 <tolkad> > [:1]
18:32:11 <lambdabot>   A section must be enclosed in parentheses thus: (: 1)
18:32:16 <tolkad> > [1,1..]
18:32:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:32:20 <tolkad> oh that's that
18:32:24 <tolkad> > [4..]
18:32:25 <lambdabot>   [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
18:32:26 <geheimdienst> > [1..] (1:)
18:32:27 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
18:32:28 <tolkad> oh nevermind
18:32:32 <geheimdienst> > [1..] (1:3)
18:32:32 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
18:32:46 <pikhq> geheimdienst: [a] is not of type a -> b
18:33:14 <JoeyA> > (cycle . return) 1
18:33:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:33:17 <JoeyA> :-)
18:33:44 <geheimdienst> yeah, i just wanted to try something. lambdabot said "(1:) is not a section", and i had to think of python's array sections, which are array[1:3] or something
18:33:46 <geheimdienst> nevermind
18:33:56 <Philonous> > fix (1:)
18:33:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:34:36 <JoeyA> By the way, is there a shorter way to express the function that wraps a value as a list item than (\x -> [x]) or return (whenever type inference can figure out you're using the List monad).
18:34:43 <Cale> geheimdienst: 'section' in this case refers to operator sections like (1+) and (/2)
18:34:55 <Cale> JoeyA: (:[])
18:35:05 <Cale> It's the robot monkey operator
18:35:05 <jmcarthur> pure
18:35:12 <JoeyA> lol
18:35:21 <JoeyA> I see
18:35:25 <jmcarthur> > pure 5 :: [Int]
18:35:26 <lambdabot>   [5]
18:35:28 <Cale> Or yeah, pure
18:35:39 <Philonous> @type point
18:35:39 <lambdabot> Not in scope: `point'
18:35:40 <geheimdienst> ah i see, thanks
18:36:10 <FunctorSalad> tolkad: @"how do you know ...": because it'd be a lot of effort and haskellers are not a high-priority target? ;)
18:36:47 <FunctorSalad> and the change would probably be suspicious in the version history
18:36:50 <Cale> You'd have to sneak it past the two Simons.
18:37:10 <FunctorSalad> (can't hide itself from source totally unless it was compromised from the beginning, no?)
18:38:08 <FunctorSalad> hmm and it doesn't completely depend on itself in the sense of needing all the features, I assume
18:38:12 <FunctorSalad> haven't checked
18:38:34 <Cale> It depends on itself enough that only GHC can compile GHC right now.
18:38:44 <shapr> "doing research in the area of Haskell type hacks and not being familiar with Oleg's work is a sin" from http://paczesiowa.blogspot.com/2010/07/two-dimensional-analog-literals-in.html
18:39:10 <ddarius> The very first GHC was built with a Haskell compiler.
18:39:38 <ezyang> shapr: Haha! +1 
18:40:17 <BrianHV> I found how to convert a string to an int with read.  but I have a list of strings to convert.  I was able to use map by defining readInt = read, but is there a better way?
18:42:21 <tolkad> @let divAll a x = [a / b | b <- x]
18:42:22 <lambdabot>  Defined.
18:43:11 <Zao> > map read ["42", "3", "9001"] :: [Int]
18:43:12 <lambdabot>   [42,3,9001]
18:43:41 <Cale> BrianHV: map read ?
18:43:52 <Zao> BrianHV: As long as the type of the expression can be inferred, you don't need to monomorphize like that.
18:44:07 <Cale> BrianHV: If you use the resulting list as a list of Int values, then it'll read the right type.
18:44:40 <Cale> BrianHV: You could also just write  map read xs :: [Integer]  or whatever
18:44:53 <BrianHV> hmmmm
18:44:53 <ddarius> Wie geht's shapr?
18:45:20 <FunctorSalad> is typeclass choice ambiguity considered a type inference failure?
18:45:52 <FunctorSalad> seems to be of a different sort than the failure of inference you get with rank-n and other extensions
18:46:41 <FunctorSalad> (with underconstrained typeclass-using code the goal is not well-defined, while with the outside-HM stuff, you just can't solve it...?)
18:46:50 <BrianHV> Cale, Zao: that worked.  I was trying it in my main method where I didn't have a type specification.  breaking the map code into another function did the trick.  thanks!
18:47:14 <shapr> ddarius: tired from weekend adventures, wanting to write Haskell code
18:47:22 <shapr> but going to sleep instead
18:47:28 <tolkad> Why can't I import Data.Fraction?
18:47:41 * shapr wants Data.Friction for his physics library
18:47:41 <FunctorSalad> Data.Ratio?
18:47:49 <tolkad> I'll try using that instead
18:47:58 <ddarius> Control.Tribology
18:48:17 <shapr> ddarius: Ooh, good word
18:48:48 <soupdragon> hi #Haskell
18:48:52 <tolkad> :t (/)
18:48:53 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:49:02 <FunctorSalad> hmm, sounded nsfw
18:49:03 <tolkad> > 5 / 2
18:49:04 <lambdabot>   2.5
18:49:29 <soupdragon> When I saw "Today's featured picture" on wikipedia I though 'oh that's so sad, all those poor one legged men'
18:49:44 <soupdragon> turns out they're baseball bats
18:50:07 <ksf> hmmm. that took me quite a while to spot. that pseudo-depth-first layout is nearly exactly van emde boas.
18:50:28 <ddarius> Yay van Emde Boas
18:50:51 <ddarius> shapr: I'm happily reunited with my guitars.
18:51:06 <aavogt> FunctorSalad: you can add/use defaulting
18:51:12 <ksf> ...so if ghc follows its pointers smartly, it should do the right thing when compacting.
18:52:03 <shapr> ddarius: Glad to hear it. You missed the latest gossip on my project on -blah
18:52:05 <ksf> nearly exactly meaning that you reorder a small amount of nodes, but the basic structure how it fits the cache is identical.
18:54:16 <FunctorSalad> aavogt: yes; I was just idly pondering the semantics of "type inference problem", not very useful
18:55:33 <FunctorSalad> (typeclass inference vs. "find a type that makes this expression legal" vs "find most general type" being the variants)
18:56:17 <aavogt> FunctorSalad: if you pretend defaulting doesn't exist, it's probably safe to say that type inference addresses cases where adding a type signature cannot change the behavior of code (provided it typechecks)
18:56:18 <FunctorSalad> with 'show . read' there simply is no non-arbitrary solution, rather than the compiler not being able to find it... /statingTheObvious
18:56:31 <aavogt> yeah
18:56:50 <ksf> I've come to the conclusion that even considering implementing cache-oblivious structures via arrays is a waste of time.
18:57:00 <soupdragon> it could have type   (Read a, Show a) => String -> String
18:57:06 <ksf> ...the problem can only be properly attacked in the gc.
18:57:09 <soupdragon> I don't see a problem
18:57:18 <ksf> possibly with hooks into it
18:57:30 <aavogt> soupdragon: you need a way to pick the `a', but your type doesn't let that happen
18:57:33 <FunctorSalad> soupdragon: yes, but choice of instance affects the result
18:57:37 <soupdragon> huh
18:57:40 <soupdragon> that's normal
18:57:41 <ksf> ...some guys did that for java and got up to 22% speedups.
18:58:08 <ddarius> ksf: Use Ptr
18:58:24 <FunctorSalad> hmm it's not normal if the quantified-over variable doesn't occur in the type
18:58:25 <aavogt> soupdragon: other times there is a unique instance to choose (due to other types fixing it)
18:58:32 <ksf> same problem as arrays: sharing is going to suck, everything is going to be monadic.
18:59:02 <ezyang> If I just used sdist to create a tar.gz, how can I install it (I want to test that it packaged correctly) 
18:59:03 <FunctorSalad> (hmm and it's not normal without typeclasses :))
18:59:14 <ddarius> ksf: Well, yeah, overall it is probably a waste of time to attempt to implement cache-oblivious structures in Haskell unless you are looking to do some research.
18:59:25 <ezyang> unpack it and then install? 
18:59:41 <ksf> the basic idea would be to have a typeclass method that is called when an object is being copied, which would then return the next thing(s) to be copied.
18:59:43 * ezyang has always thought cache-oblivious was a funny name 
18:59:57 <ksf> ...that way you can influence the memory layout on compacting.
19:00:33 <ddarius> I've considered half-baked ideas about declarativily specifying memory layout of ADTs but nothing particularly compelling came up.
19:01:41 <ksf> hmm
19:02:08 <ksf> "do this node now" "do this node recursively now" "do the rest in whatever way you please"
19:03:23 <ezyang> zounds! the hackage upload bot does not work. 
19:03:50 * hackagebot system-posix-redirect 1.0 - A toy module that allows you to temporarily redirect  a program's stdout.  http://hackage.haskell.org/package/system-posix-redirect-1.0 (EdwardYang)
19:03:59 <ksf> on a tangent, I think it would be cool to have a gc-less primitive haskell... so that you can write the gc in it. strict if it has to be.
19:04:57 <ezyang> ksf: I feel like... that would not be Haskell anymore 
19:05:38 <ksf> indeed. it would be proto-haskell.
19:05:56 <tg_afk> why?
19:06:00 <tg_afk> a change in GC policy?
19:06:30 <ksf> I just think that languages should be staged.
19:06:54 <tg_> like in horse racing?
19:07:16 <ksf> no, like in a koi beauty contest.
19:07:19 <ezyang> ksf: But in this case, it would be a pretty fundamental change. 
19:08:16 <ksf> oh, not at all. it would be a radical change, and keep everything we have as it is.
19:09:10 <g_cross> ksf: It seems to me that it would require a more sophisticated type system if referential transparency were to be preserved.
19:09:18 <jmcarthur> what's the benefit in this case, especially considering we probably wouldn't actually use this new protohaskell in any normal haskell code at all
19:10:01 <ksf> faster evolution of implementations.
19:10:20 <ezyang> Of GCs, you mean? 
19:10:23 <jmcarthur> i do think it would be nice if the RTS was written with a well-defined API so we could plug our own implementations in if we wanted (if it's not that way already, but i doubt it is)
19:10:25 <ksf> ...when you can implement+replace runtime systems quite easily, people will do it.
19:10:25 <ezyang> because most of GHC is already written in Haskell. 
19:10:43 <jmcarthur> i don't see why a new-ish language would be necessary though
19:10:44 <ezyang> ksf: Sure. And I think an RTS API is something SPJ and co are interested in. 
19:10:47 <ksf> not the rts. that's written in c--
19:10:53 <ksf> in jhc's case it's grin iirc.
19:11:48 <ksf> well, there's ddc...
19:12:00 <int80_h> have a great evening haskellers.
19:14:35 <geheimdienst> no. we only have great evenings in the appropriate monad.
19:15:57 <soupdragon> does anyone have any really good books to recommend?
19:16:36 <conal> soupdragon: any topics in particular?
19:16:52 <ksf> hmmm. the main benefit would be to have a referential transparent low-level language that is optimization-compatible with haskell.
19:18:00 <soupdragon> hmmmm 
19:18:22 <soupdragon> I don't know which topics
19:18:46 <conal> soupdragon: my favorites include byron katie's "loving what is" and anything by eckhart toelle or marshall rosenberg..
19:19:05 <conal> soupdragon: also alan watts's "the wisdom of insecurity".
19:19:06 <soupdragon> thanks im going to look these up
19:19:11 <conal> :)
19:19:12 <ksf> ...region inference when it's working for convinience and support for manual management and registering gc primitives.
19:21:23 <conal> sm: that mac/ghc/cabal tip you gave me earlier (/usr/lib) is being terrifically helpful to me.
19:24:03 <conal> sm++
19:24:42 <conal> does c's karma decrement every time someone mentions c-- ?
19:24:58 <Axman6> @karma c
19:24:58 <lambdabot> c has a karma of 2
19:25:09 <Axman6> i think c++ is mentioned more than c--
19:25:11 <Axman6> @karma c
19:25:12 <lambdabot> c has a karma of 2
19:25:17 <Axman6> c++
19:25:19 <Axman6> @karma c
19:25:19 <lambdabot> c has a karma of 2
19:25:19 <conal> hah.
19:25:22 <Axman6> :(
19:25:26 <shepheb> preflex: karma c
19:25:27 <preflex>  c: 149447
19:25:31 <Axman6> c--
19:25:34 <Axman6> @karma c
19:25:34 <lambdabot> c has a karma of 2
19:25:39 <Axman6> preflex: karma c
19:25:39 <preflex>  c: 149446
19:25:46 <dolio> C is special-cased in lambdabot.
19:25:56 <conal> oho!
19:25:58 <pikhq> We must discuss C++ a lot.
19:26:18 <shepheb> pikhq: preflex isn't measuring just in here
19:26:37 <aavogt> @karma I
19:26:37 <lambdabot> I has a karma of 15
19:26:44 <pikhq> And nobody else discusses C-- at all.
19:27:26 <Axman6> isn't it Cmm in GHC?
19:28:35 <BMeph> ksf: What (if you) do think about Pure?
19:29:09 <ddarius> BMeph: Was that question supposed to be grammatical?
19:29:37 <BMeph> ddarius: Neither one, no. ;
19:31:45 <Eridius> anyone here used HOC?
19:32:16 <soupdragon> I have assessed HOC and it's worth discarding
19:32:27 <soupdragon> you're better off to build your own from scartch
19:32:33 <Eridius> my own Obj-C <-> Haskell bridge?
19:32:39 <soupdragon> yes
19:32:46 <Eridius> that's quite a lot of work
19:33:03 <conal> Eridius: hey there.  nice to see you in #haskell.
19:33:06 <blackdog> it depneds how much you want it to do. always possible to just communicate at the C level.
19:33:11 <Eridius> hey conal
19:33:53 * Eridius is trying to write an OS X service using Haskell
19:34:01 <Eridius> and I've nearly got it compiling
19:34:03 <conal> nice :)
19:34:15 <Eridius> but I'm having issues declaring a selector where one of the arguments is an NSString**
19:34:22 <conal> at the last icfp, manuel chakravarty said he planned to get back into design & implementation of HOC.  i wonder whether he has.
19:36:29 <conal> i think eelco & chris were interested in helping
19:39:05 <Eridius> ah hah, solved the problem. I can't use Ptr (NSString a), instead I have to use Ptr (NSString ())
19:40:41 <ksf> dynamic typing?
19:41:43 <ksf> ...and why, oh why do they _enforce_ semicolons.
19:41:46 <Eridius> :m
19:41:48 <Eridius> oops
19:41:59 <Eridius> ksf: what do you mean?
19:42:12 <ksf> Pure. BMeph asked me about it
19:42:18 <ksf> http://en.wikipedia.org/wiki/Pure_(programming_language)
19:42:26 <Eridius> oh, I was wondering if you were looking at Obj-C
19:43:44 <conal> Eridius: is the 'a' vs '()' there used for simulating subtyping?
19:44:13 * FunctorSalad still isn't sure whether 'pure' is a technical term or a vague family of concepts
19:44:48 <Eridius> conal: exactly
19:45:18 <FunctorSalad> (evaluation order doesn't matter, expand definitions of items at will, no mutation, referential transparency, ...)
19:45:32 * conal wonders how "pure" came to mean specifically purely *functional*.  and how widespread that use is.
19:46:02 <ksf> isn't it a synonym for "referentially transparent"
19:46:03 <Eridius> hrm, there's no Storable instance for HOC obj-c classes. I wonder how you're supposed to set an NSString** ?
19:46:09 <FunctorSalad> conal: hmm, a function in the mathematical sense is 'pure' in the sense that its graph is all there is to it
19:46:21 <om-foxy> running GTK programs through ghci causes a segmentation fault.  Is there a way to debug?
19:46:27 <ksf> and haskell is a "pure, functional" language, not "purely functional"
19:46:28 <FunctorSalad> so it can't possibly have side effects
19:46:41 <FunctorSalad> (or depend on any hidden context)
19:47:04 <conal> FunctorSalad: still quite a biased use of the term.  e.g. there is OO purity.
19:47:12 <FunctorSalad> *its graph and its codomain, if you insist of it ;)
19:47:20 <tg_> referential transparency comes from a system which consists entirely of pure functions
19:47:36 <ksf> but then there's people who claim hamburg is a "free hanse city", not a "free and hanse city".
19:47:37 <aavogt> om-foxy: I'm not sure it's supposed to work through ghci
19:47:50 <FunctorSalad> "graph" as in { (x,f(x)) | x in dom(f) }
19:47:53 <soupdragon> Q: If I have a 4D shape
19:47:56 <om-foxy> aavogt: okay
19:48:10 <soupdragon> how good is it to have say, 12 3D slices of it in a row
19:48:14 <ksf> you can get barred from beer consumption by the next bartender for such things.
19:48:17 <aavogt> it's not much slower to just compile it
19:48:17 <soupdragon> for visualization
19:48:34 <FunctorSalad> hehe, it's the most general city satisfying the hanse laws?
19:48:34 <conal> FunctorSalad: saying a (programming) function is pure is just saying that it's a (math) function.  odd that "function" came to mean anything else in programming.
19:48:35 <soupdragon> and you can rotate the xyz axis, or you can switch (smoothy) xw, yw or zw
19:48:40 <conal> oops.
19:48:58 <tg_> soupdragon: that depends on the function
19:49:15 <conal> sometimes my irc client (colloquy) eats most of my text.  and i don't know how to recover it.
19:49:20 <om-foxy> aavogt: I'm trying to use it to display functions on (Vector Double) that get computed at the ghci prompt
19:49:21 <FunctorSalad> is that a 0x06 char? :)
19:50:44 <FunctorSalad> conal: the concepts have quite diverged... a "function" in programming usually includes its implementation, even in haskell
19:51:25 <conal> FunctorSalad: i've noticed :( .  
19:51:35 <aavogt> how about math 'functions' like dirac delta?
19:51:52 <geheimdienst> i'm using "lookup" to get a few Strings out of a Map. if all Strings are present, i'll do something with them, however if any String is missing, i'd like to bail out. how do i do that, and does it get easier with MaybeT witchcraft?
19:51:54 <FunctorSalad> (but maybe that last part was besides the point)
19:52:04 <conal> "function" is often used to mean "definition" or "code".  jumbling syntax & semantics.
19:52:26 <FunctorSalad> haskell is still much closer to math in the sense that functions with the same graph can't be distinguished (I think)
19:52:31 <conal> a pet peeve of mine.
19:52:55 <FunctorSalad> :)
19:53:11 <conal> FunctorSalad: yeah.  that's what landin means by "denotative" -- a term i much prefer over "functional".
19:53:17 <BMeph> geheimdienst: I'd check out Data.Maybe; there's sure to be some good stuff there. :)
19:53:36 <FunctorSalad> conal: haven't heard it in this contexts, but seems like a good idea
19:53:42 <conal> since "functional" has gotten so vague as to be practicallly meaningless.
19:53:47 <FunctorSalad> yep
19:54:09 <FunctorSalad> while this "this is all there is to it" seems quite essential...
19:54:18 <FunctorSalad> (abstracting from performance)
19:54:27 <aavogt> conal: perhaps this fate exists for any technical definitions that are used increasingly frequently
19:54:36 <conal> and "denotative" clarifies how haskell's IO is qualitatively different from the "pure" part of haskell.
19:55:03 <conal> aavogt: hence the dictum of "avoid success at all costs".
19:55:43 <conal> and my mixed feelings about the growing popularity of haskell.
19:55:46 <FunctorSalad> "functional" was ever technical with PLs?
19:55:56 <aavogt> or make sure that only pedants learn haskell
19:55:59 <conal> does it benefit a programming language to gain the world and lose its soul?
19:56:10 <FunctorSalad> technically I can only think of the sense occuring in "functional dependencies", "functional relation" etc
19:56:36 <conal> FunctorSalad: i don't know whether "functional" ever had a clear/precise meaning.
19:56:41 <tolkad> why doesn't this work? > ((\x -> ((\x -> x) :: Integral a => a -> a)) :: Integral a => a -> a) 5
19:56:44 <tolkad> > ((\x -> ((\x -> x) :: Integral a => a -> a)) :: Integral a => a -> a) 5
19:56:45 <lambdabot>   Couldn't match expected type `a1' against inferred type `a -> a'
19:56:45 <lambdabot>    `a1' is...
19:56:52 <conal> landin gives a crisp def for "denotative"
19:56:59 <tolkad> err wait
19:57:01 <tolkad> one second
19:57:14 <tg_> conal: usually it's only considered precise when loaded with some adjectives
19:57:17 <tolkad> nevermind
19:57:22 <conal> which corresponds exactly to how i thought of as "functional".
19:57:29 <FunctorSalad> conal: should be easy to explain with a counterexample... if a function writes to or reads from a global variable, there is more to know about it than its graph
19:57:35 <tg_> like continuious, invertable, etc, etc.
19:57:37 <conal> *how i thought of "functional"
19:57:50 <FunctorSalad> (which makes it harder to keep track of what affects what...)
19:57:57 <geheimdienst> and what does the "error" function from prelude do? does is really abort the program? isn't that a bit crude?
19:58:05 <conal> FunctorSalad: probably neither necessary nor sufficient for non-pure/denotative/functional
19:58:10 <aavogt> geheimdienst: you can catch those
19:58:25 <aavogt> but you probably shouldn't
19:58:29 <FunctorSalad> (the global var can be remedied if you include the system state in the domain and codomain of the function.... which is just what we do in State, of course ;))
19:58:38 <conal> FunctorSalad: moreover, it's an operational/implementation def, while i'd like a denotational/semantic def.
19:58:42 <geheimdienst> okay but it's not like failing a monad, right?
19:59:08 <FunctorSalad> conal: heh it's just a (non-)example, not necessary or sufficient ;)
19:59:24 <aavogt> geheimdienst: right, it's awkward to force values enough to make the exceptions happen (to force them)
19:59:27 <conal> FunctorSalad: yeah.  i'm looking for crisp.  there's tons of fuzzy out there.
19:59:44 <conal> FunctorSalad: e.g.,  the pure function ignores the read value or re-writes the old value.  or some cleverness akin to runST.
19:59:45 <FunctorSalad> conal: the point is that the denotation doesn't capture the function (unless you translate the state of the global environment to the denotational word as I mentioned)
20:00:01 <FunctorSalad> (that was in reply to "like a denotational def")
20:00:03 <aavogt> geheimdienst: so in some way exceptions result in code being more 'lazy' than an explicit Maybe or Either WhatWentWrong
20:00:22 <conal> FunctorSalad: or that the denotation would have to be complex enough to capture the (non)function
20:00:53 <FunctorSalad> conal: that sounds like what I meant, yes
20:01:42 <conal> i suspect the sequential model has damned practitioners to superstitions & heuristics -- that rigor is impractical in the imperative model.  *especially* with parallelism.
20:01:43 <FunctorSalad> the next step would be to argue that reasoning is harder if every function has an implicit RealWorld in its domain and codomain, I guess ;)
20:01:51 <BMeph> geheimdienst: Actually, for that Maybe question, I think sequence will do what you want.
20:02:10 <conal> FunctorSalad: that RealWorld business is a myth.  doesn't apply to modern imperative programming (including haskell IO)
20:02:22 <conal> only to *purely sequential* imperative computing.
20:02:29 <geheimdienst> > sequence [Just 42, Nothing, Just 3]
20:02:30 <lambdabot>   Nothing
20:02:36 <geheimdienst> > sequence [Just 42, Just 10, Just 3]
20:02:37 <lambdabot>   Just [42,10,3]
20:02:44 <conal> *really* sequential, including stop-the-universe during computation
20:02:46 <geheimdienst> i see!
20:02:48 <FunctorSalad> conal: ? yes, but for nonsequential computing, surely it is even more complex
20:02:52 <geheimdienst> thanks a lot bmeph
20:03:17 <FunctorSalad> which would support the argument that functions in the math sense are a good idea even more
20:03:28 <conal> FunctorSalad: even for what we call "sequential computing", meaning in parallel with the physical universe.
20:03:35 <tolkad> uh... http://www.zvon.org/other/haskell/Outputprelude/fail_f.html
20:03:37 <conal> FunctorSalad: yeah.
20:03:37 <tolkad> fail indeed
20:04:00 <aavogt> > fail "no" :: String
20:04:01 <lambdabot>   ""
20:04:05 <tg_> conal: it was't needed before
20:04:08 <FunctorSalad> conal: essentially you're saying that a function in an imperative lang of apparent type A -> B isn't just (World,A) -> (World,B), but even more messy ;)
20:04:14 <tg_> (rigor, *especially* with paralleism)
20:04:30 <conal> this persistent RealWorld myth of IO/imperative is another peeve of mine.  a mental virus people pass around.
20:04:38 <tolkad> > fail "x"
20:04:39 <lambdabot>   No instance for (GHC.Show.Show (m a))
20:04:39 <lambdabot>    arising from a use of `M5990604832...
20:04:40 <aavogt> @src IO
20:04:41 <lambdabot> Source not found. Take a stress pill and think things over.
20:04:43 <tolkad> > fail "x" : Integer
20:04:44 <lambdabot>   Not in scope: data constructor `Integer'
20:04:47 <conal> FunctorSalad: yeah.  that's what i'm saying.
20:04:49 <tolkad> > fail "x" : Int
20:04:50 <lambdabot>   Not in scope: data constructor `Int'
20:04:57 <tolkad> 0_o
20:04:59 * BMeph doffs his chapeau in geheimdienst's direction...
20:05:05 <aavogt> tolkad: : is for lists, :: is for type annotations
20:05:14 <tolkad> whoops
20:05:23 <tolkad> > fail "x" :: Int
20:05:24 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:05:24 <lambdabot>         against inferred type ...
20:05:33 <aavogt> @type fail
20:05:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
20:05:55 <aavogt> if you look closely, the kind of m there doesn't match the kind of Int or Integer
20:05:57 <aavogt> :k Int
20:05:58 <lambdabot> *
20:06:00 <Axman6> > fail "x" :: [Int]
20:06:01 <lambdabot>   []
20:06:27 <FunctorSalad> conal: I carelessly triggered that peeve simply because it's a simplification that only weakens what I was proposing :)
20:06:28 <aavogt> so there couldn't be an  instance Monad Int    to match that
20:07:00 * aavogt thinks there might be a better explanation for why it's nonsense
20:07:13 <aavogt> (at least within haskell's type system)
20:08:30 <FunctorSalad> conal: anyway, about the crisp definition, what's wrong with "two functions f and g can't be distinguished (except by space and time use) if forall x in the (presumed common) domain, f x = g x"?
20:08:42 * BMeph wnders what algebra is formed from IO...
20:08:55 <tg_> by the way, to recall a discussion from above, idempotentence is a concept which is very, very close to the "pure" function
20:08:57 <aavogt> BMeph: babby?
20:09:03 <conal> FunctorSalad: you've defined (extensional) equality of functions, not "function" itself.
20:09:05 <FunctorSalad> the idea behind that def would be that it's not a function that is pure or not, it's the notion of equality of functions
20:09:29 <conal> FunctorSalad: not "pure"
20:09:39 <FunctorSalad> conal: exactly. a programming language is pure if functions are subject to extensional equality
20:09:41 <BMeph> avogt: Hush, you. I did _not_ ask "how", I asked "what". ;)
20:09:45 <FunctorSalad> (proposed def)
20:10:13 <aavogt> :P
20:10:24 <FunctorSalad> the "functions" in "two functions f and g" refers to what the PL says are functions
20:10:36 <FunctorSalad> not to necessarily mathematical functions
20:10:48 <FunctorSalad> then I would just be reiterating extensional equality, yes
20:10:59 <conal> FunctorSalad: wait -- what?  for that def to be a def, we'd have to know what 'function' equality is in the PL.
20:11:06 * BMeph thinks FunctorSalad sounds like a Positivist... ;)
20:11:23 <deech> Hi all, I was wondering if there are any techniques (aside from using STM) for creating global mutable variables in Haskell. 
20:11:40 <johnw> if you're in the IO monad, there's io-storage
20:11:42 <conal> deech: there's a standard hack.
20:11:44 <aavogt> yes. Do you need it?
20:12:09 <conal> deech: it's not quit "in Haskell", though.
20:12:14 <conal> *not quite
20:12:24 <BMeph> deech: Not only are there any, there are many! :)
20:12:24 <FunctorSalad> conal: some version of observational equality
20:12:38 <deech> conal: Are there any resources that describe it? 
20:13:03 <FunctorSalad> (yes, I'm assuming an independent equality and asserting it is implied by extensional equality)
20:13:15 <BMeph> deech: See my last; it's a dual-purpose answer today! :)
20:13:34 <CakeProphet> would fclabels benefit from having language support?
20:13:53 <aavogt> @hackage reflection
20:13:53 <lambdabot> http://hackage.haskell.org/package/reflection
20:13:58 <FunctorSalad> conal: this other equality must be defined in more concrete terms than denotational semantics I think
20:14:00 <conal> FunctorSalad: i don't see a close connection with what we call purely-functional.  maybe more to the point is whether a PL 'function' is extensionally equal to itself.
20:14:46 <blackdog> got a slightly strange problem - i'd like to use a quasiquoter to include C source in a Haskell file
20:14:48 <deech> BMeph: I don't understand.
20:15:11 <tg_> what are the correct term(s) for the property that, given a function, any given set of inputs will always result in the same output?
20:15:13 <conal> FunctorSalad: you could try following through with your idea precisely.  might get somewhere or might find you're going in circles.  if you do make it precise/rigorous, i'd love to hear how it comes out.
20:15:21 <aavogt> blackdog: then what happens to the sources?
20:15:39 <blackdog> there'll be preprocessor directives in it, unfortunately - the haskell compiler's going to try to do something with them that i'd rather it didn't, i think.
20:15:52 <blackdog> i compile them and create a .so file
20:16:14 <tg_> Regardless of what that's called, all you need to define 'pure' is the above property plus idempotency
20:16:23 <aavogt> blackdog: which preprocessor?
20:16:25 <blackdog> currently it's a pretty horrible list of strings that i run unlines on
20:16:27 <blackdog> cpp
20:16:34 <blackdog> was hoping to get a nicer syntax
20:16:35 <FunctorSalad> conal: it's not exactly originally mine, there was something similar (but for a toy language, a pure one iirc) in a domain theory course
20:16:53 <conal> FunctorSalad: oh -- maybe full abstraction?
20:16:53 <tg_> FunctorSalad: agree?
20:17:09 <conal> FunctorSalad: i definitely don't want to discourage you from trying.
20:17:24 <FunctorSalad> conal: I realize we need an independent definition of equality for this not to be circular :) but you can inductively define something based on the operational semantics
20:17:28 <wli> Full abstraction like Mitchell did in Foundations for Programming Languages for PCF with parallel AND/OR/etc.?
20:17:53 <conal> wli: yes
20:18:35 <conal> iirc, full abstraction say that observationally indistinguishable programs are denotationally indistinguishable
20:18:43 <aavogt> blackdog: I don't think any leading # are going to cause problems... but you could strip off some fixed amount of leading space? Otherwise you could put those QQs in a module that doesn't get looked at by the CPP
20:19:14 <FunctorSalad> conal: full abstraction was in that course indeed, but I simply mean the equality that is roughly like f=g :<=> t(f)=t(g) for every "test program" t
20:19:20 <wli> conal: Is it pattern matching in case statements that needs to happen "in parallel" somehow to do it more generally?
20:19:32 <FunctorSalad> t would return some base type with uncontroversial equality
20:19:37 <wli> conal: Or at least discriminating between constructors?
20:19:52 <conal> wli: funny you should ask.  i'm currently writing a related blog post.
20:20:01 <soupdragon> thats like reverse liebniz
20:20:10 <conal> wli: see http://conal.net/blog/posts/lazier-function-definitions-by-merging-partial-values/
20:20:40 <FunctorSalad> sorry, I'm a bit confused now too about all the equalities (denotational vs observational-based, applicative vs the one I just mentioned, ...)
20:21:48 <FunctorSalad> it makes a different because in the "test program" variant, you can run the function more than once, which would matter in impure languages...
20:21:51 <FunctorSalad> *difference
20:22:04 <tg_> FunctorSalad: that property *is* idempodence
20:22:04 <ManateeLazyCat> What's mean http://hackage.haskell.org/packages/archive/poppler/0.11.1/logs/failure/ghc-6.12 ? 
20:22:10 <tg_> idempotetence
20:22:24 <ManateeLazyCat> I can build on my box, why hackage package can't ?
20:22:54 <tg_> conal: thanks for the link
20:22:54 <FunctorSalad> tg_: idempotence is "f(f(x)) = f(x)" in my book
20:22:59 <tg_> are you writing a follow up?
20:23:00 <conal> see http://conal.net/blog/posts/is-haskell-a-purely-functional-language/ for an extract from landin's description of "denotative" and a pointer to his paper (next 700).  his focus resonates with me as the heart of what i like in what i used to call "functional" programming.
20:23:23 <FunctorSalad> tg_: sorry, missed what you were referring to with "agree?", just found it
20:23:51 <conal> tg_: sort of a follow-up, in that i build on the "lazier" post and other unamb/lub posts.
20:24:13 <blackdog> aavogt: so you have to explicitly turn on the preprocessor if you want to use it? that'd suit me fine.
20:24:38 <FunctorSalad> tg_: I'd call that equality 'extensional' or 'applicative' (to emphasize you only apply the function to args, rather than applying a probing function to the function)
20:24:46 <aavogt> blackdog: if you use {-# LANGUAGE, instead of flags from cabal
20:25:26 <soupdragon> so ummmm
20:25:30 <tg_> FunctorSalad: I want to say that your definition isn't correct, but I can't see how it's not.
20:25:34 * tg_ sighs
20:25:37 <soupdragon> if you take slices of a 3D object and lay them out
20:25:47 <conal> FunctorSalad: this extensionality notion is so important.  and it tells us why not to use "function" to mean code/definition/algorithm.
20:25:48 <soupdragon> this is not a very good way to understand the 3D shape is it?
20:26:01 <tg_> soupdragon: that depends on the shape.
20:26:04 <soupdragon> I mean it's discrete
20:26:07 <tg_> If it's a fractal, it might be.
20:26:14 <soupdragon> there is a continuuum which you are not obeying
20:26:26 <FunctorSalad> conal: @full abstraction: effectful languages would fail at the basic converse property ("denotational equality implies observational equality") unless you model effects in the denotation
20:26:28 <tg_> Is it renormalizable?
20:26:30 <blackdog> aavogt: good-o. cheers.
20:26:37 <FunctorSalad> (don't remember the name)
20:26:50 <tg_> Didn't you ask about this earlier, but you said 3d slices of a 4d object?
20:26:56 <blackdog> i am already in love with quasiquotation.~
20:26:57 <tg_> Do you mean 2d slices of a 3d?
20:27:03 <soupdragon> I really want to do 4D
20:27:10 <soupdragon> but it might be best to use analogies with 3D
20:27:10 <conal> FunctorSalad: you have to model effects in the denotation.  otherwise, the denotation is not the denotation of the language.
20:27:15 <tg_> i can provide you examples of exactly this
20:27:17 <tg_> if you want to see
20:27:21 <soupdragon> yes
20:27:28 <tg_> http://visualphysics.org/
20:27:43 <tg_> animating and analyzing 4d wave equations with quaternions
20:27:57 <soupdragon> coool
20:27:59 <tg_> with slices & shadows
20:28:21 <soupdragon> I love this guy
20:28:27 <tg_> he's a smart guy
20:28:33 <tg_> his math is correct too :)
20:29:14 <djahandarie> Man, lists seem to be a reoccurring source of runtime errors for me. (Contemplates SafeList)
20:29:36 <FunctorSalad> conal: if you define denotation that way, then my proposed definition would simply be that the claimed type of a function is essentially the type of the denotation, rather than hiding a denotation which includes the real world as input/output (or worse, as you pointed out)
20:29:39 <conal> FunctorSalad: didn't mean to make a dogmatic statement there.  i mean that i don't know how to understand "denotation of a language" if the denotation disagrees with the actual behavior of the language.
20:29:49 <ManateeLazyCat> Saizan: Do you know what's wrong with http://hackage.haskell.org/packages/archive/poppler/0.11.1/logs/failure/ghc-6.12 ?
20:30:49 <FunctorSalad> [[A->B]] = [[A]] -> [[B]] rather than [[A->B]] = World x [[A]] -> World x [[B]] (or worse)
20:30:57 <FunctorSalad> (semantics brackets)
20:31:10 <conal> FunctorSalad: yeah.
20:31:50 <conal> FunctorSalad: and the worse includes power-sets of sequences of intermediate states of the program and the world.
20:32:59 <CakeProphet> *can you do things like
20:33:07 <tg_> wow
20:33:09 <conal> which is the most crisp & compelling indication i've seen that imperative programming is doomed -- by its own intrinsic complexity.
20:33:16 <CakeProphet> module Foo (x) where import Bar (x)
20:33:46 <FunctorSalad> conal: we had different ideas of "denotation of a function" in mind for imperative languages
20:33:52 <CakeProphet> or does the import Bar (x) form automatically import x?
20:33:55 <CakeProphet> *export
20:33:57 <conal> FunctorSalad: ah!
20:34:16 <tg_> heh
20:34:16 <conal> FunctorSalad: hence the static :)
20:34:28 <FunctorSalad> I meant "the shadows you see when you naively look at the input/output-behaviour"; in that context I was saying that the denotation doesn't fully describe the function, in an imperative lang
20:34:29 <tg_> the LHC just doubled 
20:34:35 <tg_> luminosity
20:34:50 <FunctorSalad> while you included all the things that affect the result in the denotation
20:34:53 <FunctorSalad> (global env, etc)
20:36:36 <conal> i've come to think of communication as an iterative process, hopefully converging to a mutual understanding.  i'm glad when the intermediate misunderstandings reveal themselves.
20:37:15 <FunctorSalad> I haven't dealt with denotational semantics for imperative languages before :)
20:38:17 <lispy> conal: Do you think that programming (also an iterative process that can uncover misunderstands) helped you reach that point of view?
20:38:23 <CakeProphet> from the Haskell 98 report: "Because they are allowed to be mutually recursive, modules allow a program to be partitioned freely without regard to dependencies."
20:38:33 <CakeProphet> I found it funny. because I was just having problems with mutual dependencies the other day. :)
20:38:42 * edwardk waves hello,
20:38:53 <soupdragon> hi
20:39:03 <lispy> edwardk: hiya
20:39:29 * BMeph gives edwardk particles of greeting
20:39:31 <lispy> CakeProphet: yeah.  It seems that feature was well intentioned, but too difficult/unused in practice to be worth it
20:39:39 <conal> lispy: dunno.  maybe.  probably more my work with personal communication (http://awakeningcompassion.com).  but they're related, below the surface.
20:39:51 <FunctorSalad> using your notion of denotation as including all the behind-the-scenes stuff in an imperative language, the point just becomes that an imperative language won't give you types that are really just what they claim to be, without all the extra stuff
20:40:16 <soupdragon> ooh edwardk you are a good person to as about this
20:40:42 <soupdragon> if I wanted to use category theory as a foundation of mathematics but also having computational meaning (like coq and such) is it feasible ?
20:41:06 <conal> FunctorSalad: yeah.  even strict functional languages have this property -- though more mildly.
20:41:27 <lispy> soupdragon: What do you mean, foundation of mathematics?  And when you say "use" what do you have in mind?
20:42:26 <conal> FunctorSalad: hm.  come to think of it, pure lazy functional languages have this problem also.  in that "->" really means *continuous function*, not just function.
20:42:40 <lispy> soupdragon: I think of mathematics as a creative process, so when you talk about giving it foundations in category theory I'm a bit confused
20:42:45 <soupdragon> a foundation of mathematics to build algebra and (computable) analysis in -- doing it in the foundational should justify their correctness
20:42:47 <tg_> conal: i mentioned that like an hour ago :o
20:42:55 <FunctorSalad> that it should be possible to come to an agreement given unbounded rationality and communication is one of the nicer properties of math/programming/science actually ;) not always the case in personal relationships apparently
20:43:02 <soupdragon> I mean formal mathematics
20:43:08 <conal> tg_: hah!
20:43:18 <tg_> i was feeling ignored before
20:43:23 <CakeProphet> ....oh. okay. I just figured out how I export an imported module without having to maintain an explicit export list
20:43:25 <tg_> but then I realized I wasn't adding anything useful anyho
20:43:34 <CakeProphet> module Foo( module Foo, module Bar) where ...
20:43:34 <conal> tg_: and now shamelessly plagarized!
20:43:37 <soupdragon> like set theory and CIC
20:43:44 <tg_> conal: oh, the humanity!
20:43:53 <tg_> at least I got a good laugh out of it lol
20:44:12 <FunctorSalad> conal: the "->" in the semantic domain must be continuous functions (or whatever category of domains you have), yes...
20:44:19 <conal> to right the wrong: "as tg_ pointed out like an hour ago, pure lazy functional languages have this problem also.  in that "->" really means *continuous function*, not just function."
20:44:24 <lispy> soupdragon: hmm...So, you want to use cat. theory as the foundation for the way in which you are precise about your definitions and their implications?
20:44:26 <tg_> FunctorSalad: that is a *really* unfortunate thing
20:44:28 <conal> :)
20:44:34 <tg_> lol
20:44:36 <tg_> thanks
20:44:53 <conal> tg_: my pleasure!
20:45:01 <tg_> I like how you included my measure of accuracy "like an hour ago"
20:45:05 <tg_> lol
20:45:23 <FunctorSalad> tg_: the agreement-possible-in-principle thing? sounds cheesy but who hasn't found it out the hard way :(
20:45:40 <lispy> soupdragon: I don't know much (any?) cat. theory, but you'll still need to agree upon a logic, right?  Will you take intuitionistic logic?
20:46:12 <tg_> FunctorSalad: no, more like physical reality is turning out to be rather discontinous
20:46:19 <soupdragon> lispy - I don't know about the details here though
20:46:31 <FunctorSalad> tg_: 'continuous' in the order theory sense
20:46:38 <soupdragon> lispy - there seems to be an internal logic for categories and it might be that which I need .... or not 
20:47:07 <FunctorSalad> which can be made topological if you squint really hard ;) but is far from continuity in R^3 or whatever
20:47:12 <tg_> FunctorSalad: yes, that's not sufficient to describe reality
20:47:19 <conal> tg_: heh
20:47:25 <CakeProphet> Lexically, the terminal symbols "as", "qualified" and "hiding" are each a varid rather than a reservedid. They have special significance only in the context of an import declaration; they may also be used as variables.
20:47:25 <lispy> soupdragon: You might want to raise this question in #logic
20:47:31 <tg_> well, some physical realities :o
20:47:32 <CakeProphet> import Foo hiding (hiding)
20:48:12 <FunctorSalad> tg_: I'm not a domain theory expert, but it's more of a technicality, nothing about physical reality
20:48:15 <FunctorSalad> (continuity)
20:48:17 <lispy> import As hiding (qualified)
20:48:18 <edwardk> soupdragon: yes it is possible. there are a couple of categorical programming languages, and there is of course a categorical approach to logic, and a model by which you can use categories to build up an alternative formulation to mathematics that builds on categories not ZFC directly
20:48:50 <FunctorSalad> tg_: it means that f(sup X) >= sup_x f(x)
20:48:52 <tg_> FunctorSalad: I'm not either. I'm just in this game for the physics, so it's relevant to me
20:48:59 <CakeProphet> import As(as, qualified) hiding (hiding)
20:49:04 * ddarius is in a sublime mood.
20:49:09 <soupdragon> :))
20:49:17 <lispy> edwardk: is #logic still around?  I haven't been there in some time...
20:49:26 <edwardk> yeah its still kicking
20:49:26 <FunctorSalad> (the "<=" follows from monotony already)
20:49:37 <napping> monotony?
20:50:19 <FunctorSalad> we're in partially-ordered-set country... monotony is the least you can demand ;)
20:50:21 <napping> some sublime, some bored
20:50:28 * lispy realizes he should actually learn some real category theory at some point :)
20:50:41 <FunctorSalad> the order being "less defined or equal"
20:50:43 <ddarius> lispy: It won't hurt you.
20:50:43 <CakeProphet> Haskell's module system is pretty comprehensive. It's not really too confusing either, though there are some cases where it's not obvious what's going to happen unless you read the report thoroughly
20:50:47 <dmwit> *monotonicity
20:50:54 <dmwit> unless that was supposed to be a joke
20:50:57 <ddarius> lispy: Other than the fact that we have but fleeting and finite time.
20:51:03 <soupdragon> lispy - I am trying to but I want to program in category theory -- that would make me learn it very strongly
20:51:20 <lispy> soupdragon: good point!
20:51:26 <tg_> soupdragon: you are trying to learn mathematical foundations in haskell
20:51:33 <ddarius> soupdragon: Have you read Computational Category Theory?  Not quite the same thing, but still somewhat interesting.
20:51:34 <napping> soupdragon: the bit about initial algebras is probably the most useful
20:51:44 <lispy> CakeProphet: I gather that the same became true for the implementors.
20:51:46 <napping> at least for understanding programming languages
20:51:47 <FunctorSalad> dmwit: no, translation issue
20:51:53 <FunctorSalad> Monotonie 
20:51:54 <FunctorSalad> ;)
20:52:01 <soupdragon> yes it's almost exactly like yes Computational Category Theory, what I have in mind - I just want the proofs as well as the programs
20:52:07 <dmwit> okay =)
20:52:22 <lispy> soupdragon: Are you familiar with Isabelle?
20:52:30 <soupdragon> well I know what it is
20:52:35 <soupdragon> I've never used it
20:52:48 * ddarius will go see if he can find ice cream or something similar and then watch another episode of Firefly.
20:53:06 <conal> ddarius: have fun!
20:53:07 <lispy> soupdragon: it's a theorem proving language. In Isabelle there is a separation between the logic language (HOL) and the language of your program (about which you use HOL to prove things)
20:53:34 <conal> hm!  what's wrong with my brain that i read "fish cream" instead of "ice cream"?
20:53:37 <FunctorSalad> anyway, continuity is a property concerning infinite sequences of more-and-more-defined values, it doesn't directly map to physical continuity, tg_ 
20:53:42 <CakeProphet> It is not an error for there to exist names that cannot be so resolved, provided that the program does not mention those names.
20:53:45 <CakeProphet> best feature ever.
20:53:46 <lispy> soupdragon: the programming language of Isabelle is essentially (exactly?) SML
20:53:47 <soupdragon> fish cream..... lol
20:53:51 <djahandarie> Is there a way to make certain errors propegate out of a catch?
20:54:01 <tg_> conal: i don't know, but i don't want any.
20:54:08 <conal> :) !
20:54:29 <tolkad> is it possible to implement this algorithm in haskell to form an infinite list? http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
20:54:33 <monochrom> yes, by restricting "catch" or using "catchJust" so you don't catch them.
20:54:40 <conal> FunctorSalad: although it seems that the only information-continuous functions on reals are continuous in the calculus sense as well.
20:55:03 <djahandarie> Ah nice, catchJust is just what I was looking for
20:55:09 * djahandarie fails at reading documentation
20:55:14 <FunctorSalad> conal: left-continuous
20:55:30 <CakeProphet> tolkad:  yes, but I don't recall the code at the moment.
20:55:31 <dmwit> tolkad: See http://haskell.org/haskellwiki/Prime_numbers
20:55:33 <tolkad> each element in sequence needs the list of previous elements, is there so way to pass those along without recalculating them?
20:55:34 <CakeProphet> but I've seen it.
20:55:34 <FunctorSalad> f(x)=if x<=0 then 0 else 1 would do
20:55:42 <FunctorSalad> since we're biased to suprema
20:55:52 <conal> we are?
20:56:06 <tolkad> dmwit: I'm not asking because I need prime numbers, I'm asking because I want to know if that is possible
20:56:46 <Cale> tolkad: There's a whole paper http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
20:56:54 <Olathe> +
20:56:55 <FunctorSalad> conal: you mean your definition of continuous function (in order theory) includes the analogous property for infima too?
20:57:06 <FunctorSalad> never saw it included
20:57:09 <Cale> tolkad: My favourite compromise between performance and conciseness is this one:
20:57:20 <soupdragon> so I could essentially defined my own theory of categories in isabelle, as opposed to using ZFC or anything
20:57:36 <CakeProphet> tolkad:  yes. Any infinitely sized data structure that can be constructed iteratively/recursively can be produced in 
20:57:39 <CakeProphet> Haskell.
20:57:40 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
20:57:40 <conal> FunctorSalad: oh!  i thought you were remarking on the second half of my comment ("continuous in the calculus sense").
20:57:42 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
20:57:49 <FunctorSalad> anyway, R is totally misleading, being a total order ;) with base types being flat orders
20:57:52 <CakeProphet> tolkad:  due to lazy evaluation.
20:58:05 <FunctorSalad> conal: I was
20:58:07 <solidsnack> So I want to use template Haskell to make a list of the names of a data tyoes constructors -- is there a library for this?
20:58:35 <FunctorSalad> but "preserves suprema" only gives you left continuity on R
20:58:51 <soupdragon> lispy?
20:58:57 <c_wraith> solidsnack: is JSONb your library?
20:59:03 <dmwit> CakeProphet: It is not clear to me straight off that an infinitely sized Sieve of Eratosthenes can be constructed iteratively/recursively.
20:59:06 <solidsnack> c_wraith: Yes.
20:59:13 <Cale> tolkad: This defines the primes as the sequence of numbers starting with two, followed by the odd numbers from 3,5,7,... satisfying isPrime, and isPrime n checks that all primes whose square is less than n don't divide n.
20:59:15 <solidsnack> c_wraith: Is it not working for you?
20:59:23 <Cale> Er, less than or equal to n, rather
20:59:24 <solidsnack> c_wraith: Is it slow or buggy?
20:59:31 <soupdragon> I sort of wanted to build my own in haskell but it's not really feasable I don't know what I am doing
20:59:31 <c_wraith> solidsnack: It's working great.  I'm just curious about what the Schema stuff is for
20:59:48 <dmwit> The SoE is pretty special.
21:00:25 <solidsnack> c_wraith: Say you have a big collection of JSON that you got from some data feed and you wonder, how many variations in structure there really are.
21:00:34 <dolio> soupdragon: Mike Shulman, who posts over at the n-category cafe, is working on 2-logic, which, if I understand correctly, is like regular logic, but with categories instead of sets.
21:00:53 <solidsnack> c_wraith: I used it on a bunch of data from the Twitter firehose to see what different kinds of documents one is likely to see.
21:00:56 <soupdragon> those n-category guys are out of this world
21:00:58 <dolio> Presumably that has some connection to a programming language based on categories.
21:01:01 <Cale> dmwit: It can be using a priority queue :)
21:01:15 <solidsnack> It gave me a nice bird's eye view of the data.
21:01:52 <dmwit> Anyway, he really should go to the page I linked to, and the paper you linked to.
21:01:58 <CakeProphet> dolio:  like a Prolog with category theory. :)
21:02:04 <dmwit> Since both have some very clear and interesting information about the SoE and FP.
21:03:33 <FunctorSalad> SoE?
21:03:40 <dmwit> Sieve of Eratosthenes.
21:04:02 <Cale> Trial division is not so horrible if you just need a small number of primes, and it works better if you write it in this nice mutually recursive way :)
21:04:15 <solidsnack> c_wraith: Maybe I should factor that out so it doesn't install the binary everywhere people use the library.
21:04:17 <dolio> CakeProphet: No, I mean like a Curry-Howard correspondence.
21:04:17 <soupdragon> yeah I don't even know what an elephant is, let alone which parts want categorified
21:04:24 <CakeProphet> what's an efficient way to accumulate a string in Haskell?
21:04:27 <FunctorSalad> oh. guessed 'school of expression', and I only know that from the gtksoe package
21:04:40 <c_wraith> solidsnack: I didn't even realize there was a binary.  Shows how much attention I pay.
21:04:43 <CakeProphet> dolio:  ah
21:04:48 <solidsnack> Ah.
21:04:48 <soupdragon> dolio - it's so frustrating that all this stuff is aeons away
21:04:50 <lispy> CakeProphet: in reverse :)
21:05:12 <dmwit> :t shows -- CakeProphet
21:05:13 <lambdabot> forall a. (Show a) => a -> String -> String
21:05:43 <CakeProphet> lispy:  ha. Not very useful when I want the string to be going the right way. :)
21:05:56 <FunctorSalad> conal: hmm the 'order topology' gives us the usual topology on R, though... so apparently it doesn't give the same continuity as the upwards-directed-limits continuity
21:06:11 <FunctorSalad> or I'm just missing something...
21:06:13 <kmc> CakeProphet, «type ShowS = String -> String» is in the prelude
21:06:23 <kmc> (.) on ShowS is equivalent to (++) on String
21:06:30 <lispy> CakeProphet: I wasn't being as facetious as I sound.  Each cons is O(1), followed by an O(n) reverse.  Compared with (++) which is O(m) where m is the length of the first param to (++).
21:06:35 <FunctorSalad> (order topology = the one generated by the open intervals of the order, IIRC)
21:06:54 <tolkad> How many operating systems are written in haskell?
21:06:58 <kmc> CakeProphet, it basically builds a tree, then walks it once
21:07:03 <lispy> tolkad: I know of 2
21:07:17 <lispy> tolkad: I guess each is more of a kernel
21:07:23 <conal> FunctorSalad: i'm talking about computable exact reals.  are you?
21:07:35 <conal> trying to remember author & paper.
21:07:35 <FunctorSalad> conal: no, classical
21:07:37 <tolkad> lispy: no, standalone operating system not incorporaating code of any other languages
21:07:44 <kmc> CakeProphet, like «data StrTree = Leaf String | Node StrTree StrTree», except simpler by choosing a higher-order representation
21:07:56 <kmc> tolkad, every haskell implementation i know of has some runtime system written not in Haskell
21:08:11 <soupdragon> dolio do you think there exists something of this sort which would sovle the problems of dependent type theory//?
21:08:19 <kmc> either an entire interpreter (Hugs) or services like garbage collection and thread scheduling (GHC)
21:08:23 <dolio> Which problems?
21:08:28 <conal> ah -- here it is: http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/
21:08:29 <lispy> tolkad: do you allow me to write my run-time system in hardware?
21:08:33 <soupdragon> dolio lack of quotients, primarily
21:08:53 <monochrom> hell, do you allow me to run any OS on hardware?
21:09:03 <dolio> Epigram has quotients.
21:09:21 <dolio> As does NuPRL.
21:09:26 <CakeProphet> kmc:  would using ShowS be more efficient than simply constructing the string in reverse and revsersing it?
21:09:26 <kmc> CakeProphet, anyway if you want to glue together strings nicely, i recommend Text.PrettyPrint
21:09:39 <kmc> CakeProphet, no, but it supports more use cases than that
21:09:59 <FunctorSalad> you might like Data.Sequence ;)
21:10:12 <CakeProphet> well, my purpose is very simple actually.
21:10:15 <FunctorSalad> better than list headaches for queue-like things
21:10:21 <CakeProphet> I want to convert to and from \n and \r\n
21:10:28 <CakeProphet> from sent/received socket data.
21:10:31 <FunctorSalad> but may not be so efficient for sequences of chars....
21:10:54 <lispy> CakeProphet: iteratees or other stream processing abstractions might be better suited to your task
21:10:58 <Cale> CakeProphet: That should already happen automatically, as long as you set text mode on the handle.
21:11:02 <tolkad> lispy: no, it must be some standard hardware, the runtime systems implemented by standard haskell compilers are fine but the OS code itself can only use standard haskell
21:11:17 <dmwit> :t (>>= \c -> case c of '\n' -> "\r\n"; _ -> [c])
21:11:18 <lambdabot> [Char] -> [Char]
21:11:21 <dmwit> CakeProphet: ?
21:11:31 <dolio> soupdragon: Anyhow, the homotopy lambda calculus stuff seems like it might turn out decent.
21:11:35 <CakeProphet> Cale:  so I should only encounter \n then, and sending \n is fine too?
21:11:52 <Cale> CakeProphet: yeah
21:11:54 <soupdragon> dolio, has there been any news about that?
21:12:04 <kmc> tolkad, well, the House project had to modify GHC's RTS, does that count?
21:12:05 <dolio> I don't know what it does with respect to quotients, though.
21:12:12 <CakeProphet> well, if I'm in text-mode. Is text mode default on sockets received from accept?
21:12:17 <CakeProphet> s/socket/handle/
21:12:25 <Cale> CakeProphet: If not, then just  hSetBinaryMode hdl False
21:12:30 <dmwit> :t let f ('\r':'\n':xs) = '\n':f xs; f (x:xs) = x : f xs in f -- the other direction
21:12:30 <lambdabot> [Char] -> [Char]
21:12:32 <dolio> Someone apparently wrote a Coq module showing that some principle provides extensionality for functions, so that's good.
21:12:35 <CakeProphet> Cale:  alright. thanks. :)
21:12:45 <kmc> tolkad, most operating systems in C have some assembly (inline or otherwise), and I expect Haskell to be no different
21:12:49 <lispy> tolkad: http://jfla.inria.fr/2007/actes/Presentation/tolmach.pdf
21:12:56 <kmc> though you could probably emit most of it dynamically from a Haskell-embedded DSL
21:13:17 * dmwit is embarrassed that he forgot a [] case
21:13:33 <tolkad> Cale: that was not an implementation of the Sieve of Eratosthenes
21:13:34 <lispy> tolkad: HalVM is mentioned in that
21:13:46 <kmc> tbh it's kind of a pointless question; the lines aren't really that sharp
21:13:49 <CakeProphet> hmmm... so let's see. ByteString's append is faster than (++) right?
21:14:05 <kmc> CakeProphet, don't think so, it still has to copy doesn't it?
21:14:11 <CakeProphet> yes it does a memcpy
21:14:26 <tolkad> Cale: the Sieve of Eratosthenes algorithm only attempts to divide each number by previous primes, yours attempts division against all previous numbers up to the square root of the number in question
21:14:27 <Cale> tolkad: Right, it's not
21:14:30 <kmc> or did you not mean asymptotically
21:14:49 <kmc> tolkad, you certainly can't implement an OS in /standard/ Haskell
21:14:55 <CakeProphet> kmc:  yes.
21:15:04 <Cale> tolkad: It's a fairly decent small implementation of a list of all primes though. You can do a real sieve of Eratosthenes using a priority queue
21:15:21 <Cale> (which is much faster, but you'll only care about that if you need a lot of primes)
21:15:27 <wli> Data.Map will do in a pinch
21:15:57 <tolkad> kmc: oh, so you can't write operating systems in standard Haskell? well you can do it in standard C by invoking undefined behavior
21:15:58 <FunctorSalad> if you need a lot of primes you probably just want some existing library ;)
21:16:28 <kmc> tolkad, the behavior of undefined behavior in C is undefined
21:16:46 <kmc> tolkad, i don't see how you could call a program "standard C" if it depends on undefined behavior
21:16:51 <tolkad> Cale: so it's impossible to implement that algorithm in FP?
21:17:01 <Cale> tolkad: I just said it's very possible.
21:17:07 <FunctorSalad> (I assume it's one of these things that has been tweaked like crazy over years of work already)
21:17:11 <Cale> tolkad: See the paper.
21:17:15 <tolkad> ok
21:17:16 <kmc> what does "in FP" mean? lambda calculus is turing-complete...
21:17:55 <Cale> tolkad: I think if I was setting out to write an OS in Haskell, I would go the route of metaprogramming for at least a decent portion of it.
21:18:12 <tolkad> FunctorSalad: I actually just want to know how to define an infinite list in such away that the calculation of each member includes the list that has been generated so far
21:18:13 <Pseudonym> That's a pretty good idea, yes.  Generate the code of the OS.
21:18:22 <Cale> tolkad: There are a lot of nice benefits of using Haskell as a high level assembler.
21:19:04 <FunctorSalad> tolkad: accumulator?
21:19:20 <FunctorSalad> but you want something else than a list if you need to do lookups in the so-far part
21:19:26 <Cale> tolkad: Just define a list recursively
21:19:32 <FunctorSalad> (IntMap or so)
21:19:59 <tolkad> kmc: yes, but the implementation of a some algorithms isn't possible in some languages, if the language is turing complete there will always be another way to calculate whatever that algorithm calculates
21:20:12 <lispy> If I were going to write an OS, high assurance would be my goal.  Good enough low assurance OSs already exist :)
21:20:24 <Cale> tolkad: you might also be interested in inits
21:21:00 <wli> I'd have particular algorithmic and data structure design goals for OS kernels.
21:21:07 <FunctorSalad> tolkad: go nmax acc n = if n == nmax then acc else go nmax (calaculate new element and add to accumulator) (n+1)
21:21:15 <FunctorSalad> -a
21:21:15 <kmc> tolkad, true.  i think it's proven that some problems can't be solved with only persistent data structures without a O(log n) hit compared to mutable data
21:21:26 <kmc> tolkad, but of course every practical FP language provides mutable data types
21:21:37 <Axman6> even pure ones
21:21:38 <Axman6> ST++
21:21:40 <FunctorSalad> that's the low-level thing you'd do if there isn't a HOF already
21:21:41 <ben> kmc: Is it proven that a O(log n) hit is the worst case?
21:21:47 <kmc> ben, don't know
21:22:14 <FunctorSalad> and you'd factor nmax out, but anyway
21:22:18 * conal decides not to take the bait and go back to writing.
21:22:23 <Cale> kmc: I don't think it's proven for lazy evaluation.
21:22:30 <Cale> ben: Yes
21:22:30 <kmc> interesting
21:22:33 * conal ... and *goes* back ...
21:22:45 <tolkad> kmc: yes, which is why I said FP rather than "haskell"
21:22:48 <Cale> The proof that O(log n) is the worst hit is easy. :)
21:22:59 <kmc> tolkad, what distinction do you make?
21:23:13 <Cale> You can always use a balanced binary tree as your heap.
21:23:17 <tolkad> kmc: I was talking about the non-imperitive parts of haskell
21:23:17 <Cale> and simulate mutation
21:23:19 <kmc> makes sense
21:23:23 <FunctorSalad> conal: not to ((take the bait) /\ (go back to writing)), a pretty weak proposition ;)
21:23:26 <kmc> tolkad, ah.  that's not what i took FP to mean
21:23:28 <ben> Cale: I figured it would be something like that
21:23:49 <kmc> Cale, here n is the maximum number of active heap cells?
21:23:55 <conal> FunctorSalad: indeed!
21:24:22 <tg_> good night
21:24:24 <kmc> is it easy to prove that some specific problem can't be done persistently with better than O(log n) slowdown?
21:24:25 <tg_> everyone
21:24:29 <kmc> 'night tg_
21:24:29 <Cale> It has been shown that there are programs for which the fastest pure functional program under strict evaluation is asymptotically worse than one which uses mutation.
21:24:33 <kmc> ok
21:24:38 <conal> tg_: take care
21:24:52 <tg_zzz> conal: you too. send me the link to your new article when you post it
21:25:01 <Cale> However, the specific example that was found can be implemented using lazy evaluation with the same asymptotic cost as the mutating program.
21:25:09 <Cale> kmc: yeah
21:25:23 <Cale> (that's what n is)
21:25:27 <kmc> ok
21:25:32 <FunctorSalad> is it taken into account that memory addresses become longer as n -> infty
21:25:37 <FunctorSalad> ?
21:25:43 <conal> tg_zzz: will be on haskell planet.  do you subscribe?
21:25:58 <conal> or "planet haskell".  i keep forgetting which.
21:26:13 <Cale> But it's unknown (at least to me) whether for all mutating programs there is a corresponding lazy pure program which has the same asymptotic complexity
21:26:14 <tg_zzz> nope.
21:26:42 <ben> How far will we get just hiding all these algorithms in ST and telling everybody not to look too closely
21:26:44 <Cale> Because it's really hard to show that there isn't a sneaky way to do something in general.
21:26:54 <kmc> ben, look as closely as you want :)
21:27:02 <Cale> and lazy evaluation has a *kind* of restricted mutation in it
21:27:07 <conal> tg_zzz: k
21:27:09 <Cale> (In the implementation)
21:27:10 <FunctorSalad> Cale: I would have thought that lazy is equivalent to strict for the optimal solution
21:27:11 <kmc> FunctorSalad, don't think that changes the asymptotics of a trie on (arbitrarily-long) bitstring addresses
21:27:17 <tg_zzz> not yet at least
21:27:24 <FunctorSalad> since you can simulate either in either at constant(?) cost
21:27:38 <Cale> FunctorSalad: It's not. There are lazy functional programs which are (by a log factor) asymptotically better than the best strict functional ones.
21:27:50 <Cale> hmm
21:27:59 <kmc> well i mean it does, because the fixed-size trie has O(1) everything ;P
21:27:59 <tolkad> hey uh, I was wondering if you guys could change standard haskell to use != instead of /=
21:28:09 <kmc> tolkad, you can do this yourself
21:28:25 <tolkad> kmc: yeah but that might confuse people reading my code
21:28:32 <Cale> tolkad: I like /=
21:28:34 <FunctorSalad> kmc: I was wondering whether it makes possible array accesses in the mutating solution O(log(n)) rather than the O(1) they are under remotely realistic conditions ;)
21:28:36 <tolkad> kmc: which is why I want them to change it for everyone
21:28:42 <kmc> we should really use ≠
21:28:46 <Cale> It looks more like "not equal to" is supposed to look.
21:28:56 <tolkad> Cale: it makes my think of (a /= x) == (a = a / x)
21:29:03 <tolkad> from c-like languages
21:29:11 <Cale> tolkad: except that's only true if x = 1 ;)
21:29:19 <Cale> heh
21:29:37 <conal> tolkad: if we try to make haskell look like C, i'm afraid people will then want it to *mean* like C.
21:29:40 <FunctorSalad> Cale: hmm... log factors sound like they'd depend on the concrete lazy/strict language, no idea
21:29:44 <kmc> another case where Haskell is simply out of touch with the common hardworking everyday programmer.  this (!=) versus (/=) issue is surely the main obstacle to its widespread adoption
21:29:54 <Cale> FunctorSalad: Yeah, that's a good point you make about simulating one in the other
21:30:10 <ben> We do not get to say !(foo || bar), so in using /= over != we are not using consistency with that, at least
21:30:18 <tolkad> Cale: yeah, I meant that conceptually, not literally. actually, that value of that is undefined in C
21:30:21 <FunctorSalad> Cale: \() -> foo doesn't let you simulate lazy in strict in constant overhead?
21:30:22 <conal> that was my experience at Microsoft in the 90s, trying to sneak a purely functional paradigm through as an OO library.  created mistaken expectations about semantics.
21:30:23 <Cale> FunctorSalad: Oh, right.
21:30:24 <mtnviewmark> kmc: that and >>= really aught to be right-shift-assign
21:30:30 <Cale> FunctorSalad: Right, that doesn't work. :)
21:30:33 <mtnviewmark> I mean, geez! EVERY programmer knows that!
21:30:40 <Cale> FunctorSalad: That simulates normal order evaluation
21:30:43 <kmc> mtnviewmark, no, it ought to be overloaded for both, like C++'s right-shift and stream-output operator
21:30:47 <Cale> FunctorSalad: But not lazy evaluation. :)
21:30:54 <kmc> after all overloading is just a way to reuse lexical character sequences, right?
21:31:00 <tolkad> is it true the linux kernel is being ported to haskell?
21:31:01 <FunctorSalad> Cale: I have no idea what the overhead for that encoding is, but it seems like it'd depend on implementation details
21:31:11 <Cale> FunctorSalad: You need to do the trick where you make sure that you don't re-evaluate function parameters.
21:31:19 <Cale> When they occur more than once in the body
21:31:24 <Axman6> tolkad: i highly doubt it... o.O
21:31:39 <Cale> FunctorSalad: and for that, you'd need mutation
21:31:41 <Axman6> though you can write kernel modules/drivers in Haskell for linux
21:31:53 <Cale> FunctorSalad: Or you need a heap simulation, which costs you a log factor
21:31:56 <FunctorSalad> Cale: hmm right... seems hard without mutation
21:32:05 <soupdragon> I think there's no rational points on x^2+y^2=3
21:32:09 <gwern> good lord there's a lot of vandalism to clean on hawiki
21:32:15 <FunctorSalad> (with mutation one could just make a self-overwriting thunk, I guess)
21:32:24 <FunctorSalad> (with the value)
21:32:35 <Cale> gwern: !! hawiki still exists?
21:32:56 <gwern> yes, I used the ultimate nullifier on the past destruction
21:33:00 <Cale> FunctorSalad: right.
21:33:42 <kmc> is it true that aliens from Alpha Centauri have landed in Pittsburgh and are distributing free hot dogs?
21:34:20 <FunctorSalad> s/aliens/small furry creatures/
21:34:20 <gwern> it's easy to aim into the past - you just point quuxwards of up
21:34:25 <FunctorSalad> then probably
21:36:04 <FunctorSalad> why wouldn't the wiki still exist?
21:36:12 <FunctorSalad> (AFAIK hawiki is just its former name)
21:37:18 <dolio> Hawiki was entirely different software.
21:37:28 <mtnviewmark> +1 to gwern for all the wiki clean up
21:37:35 <sm> conal: yay, you're welcome, I just figured it out
21:37:45 <conal> :)
21:37:58 <sm> after much pulling out of hair
21:38:06 <dolio> And only stuff that people ported to the new wiki got kept in the changeover.
21:38:16 <conal> sm: you saved me much anguish
21:40:05 <FunctorSalad> dolio: I see
21:43:22 <Cale> hawiki was so much more friendly than the current wiki
21:43:47 <Cale> Ever since we changed it to MediaWiki, the communication aspect of the wiki sort of died.
21:44:31 <djahandarie> What exactly was hawiki? Was it written in haskell?
21:44:42 <tg_zzz> gitit is
21:44:43 <Cale> djahandarie: No, it was just a moinmoin, I think.
21:44:59 <Cale> djahandarie: There wasn't much web software at all written in Haskell back then.
21:45:07 <sm> still isn't
21:45:20 <djahandarie> Someone should write a wiki with one of the fancy web frameworks we have now so we can showcase it :)
21:45:21 <gwern> what was more friendly about it?
21:45:21 <gwern> seems like the same people
21:45:31 <Cale> gwern: It was just in the way that people used it.
21:45:54 <gwern> Cale: yeah, but why did it change? it's not like moinmoin is any better than mediawiki
21:46:00 <Cale> gwern: I think it's that just looking like MediaWiki makes people think of wikipedia and wikipedia's rules.
21:46:24 <Cale> and so there's none of the usual talking through page edits that normally goes on with a real wiki.
21:47:04 <CakeProphet> I was thinking you could match a compasable pattern matching grammar in Haskell. class Pattern p where pmatch :: p a -> a -> Bool.   data SomePattern = SomePattern (Pattern p) => p.  data AnyPattern a = AnyPattern (a -> Bool)
21:47:20 <CakeProphet> and you could possibly make it a monad. The only obstacle is I can't figure out what bind should give you  as an argument.
21:47:28 <CakeProphet> s/match/make/
21:47:52 <CakeProphet> SomePattern and AnyPattern, that is, could be monads.
21:48:02 <gwern> Cale: I suppose that's possible
21:48:40 <CakeProphet> it could just give you the value being matched over, but that seems dubious.
21:48:43 <djahandarie> I don't even like looking at the wiki because it feels like I'm in a timewarp back to the brink of the internet
21:49:21 <djahandarie> Jokes aside, if the CSS for the new design can't be recovered, someone should seriously be working on making it look nice again
21:49:23 <gwern> hm. ashley said I had checkuser, but checkuser doesn't even seem to be installed
21:50:15 * sm thinks the haskell wiki looks better now
21:53:38 <napping> solidsnack: what are you trying to do with constructors?
21:54:19 <napping> solidsnack: I am confused because reify and Info in TH is exactly the thing to list the constructors of a data type
21:54:39 <FunctorSalad> CakeProphet: folds are the first-class representations of (recursive use of) 'case', more or less
21:54:49 <CakeProphet> instance Monad AnyPattern where (>>=) p f = AnyPattern (\x -> pmatch p x && pmatch p (f x)); return x = AnyPattern (==x) 
21:55:07 <CakeProphet> er...
21:55:08 <napping> solidsnack: and Data.Data.toConstr tells you about individual values
21:55:10 <FunctorSalad> the types get hard if you stray from regular types, though
21:55:14 <CakeProphet> I messed up bind
21:55:34 <CakeProphet> should be (\x -> pmatch p x && pmatch (f x) x)
21:55:49 <FunctorSalad> (a pattern doesn't just return Bool, btw)
21:55:56 <FunctorSalad> it decomposes its arg
21:56:03 <solidsnack> napping: Oh, okay -- good to know. I will look at Reify.
21:56:25 <CakeProphet> FunctorSalad:  hmmm, not sure I can describe that behavior with this mechanism then.
21:57:02 <FunctorSalad> the type of the fold depends on the constructors and their fields
21:57:26 <napping> solidsnack: ''Ident gives you the Name for the type
21:57:38 <CakeProphet> FunctorSalad:  I suppose that would give a handy bind argument, for monad.
21:59:28 <CakeProphet> x <- matchSomeValueInData1; y <- matchSomeValueInData2
21:59:29 <CakeProphet> perhaps.
22:00:43 <FunctorSalad> CakeProphet: ( /\ a -> pattern-of-type-a ) is to become a monad? (type lambda, not valid haskell)
22:01:17 <napping> solidsnack: that's "reify" as in Language.Haskell.TH.reify
22:01:17 <CakeProphet> FunctorSalad:  I'm afraid I don't follow that notation.
22:01:33 <solidsnack> napping: Aye; my memory is fuzzy.
22:01:59 <FunctorSalad> CakeProphet: the /\ is lamba on the typelevel, which doesn't exist in haskell (but (fun fact) in ghc's core language)
22:02:01 <napping> FunctorSalad: the problem with that is representing the bindings
22:02:19 <FunctorSalad> which bindings?
22:02:34 <FunctorSalad> I didn't claim it's a monad, just asking if that's the problem ;)
22:02:50 <CakeProphet> FunctorSalad:  a -> Pattern a would be the right-hand side of >>=.  Pattern a -> (a -> Pattern b) -> Pattern b.  I'm just trying to figure out what is possible from that type.
22:03:15 <CakeProphet> what a pattern could represent.
22:03:53 <FunctorSalad> what's return?
22:03:56 <FunctorSalad> pattern guard?
22:04:11 <CakeProphet> ...don't really know. :)
22:04:19 <CakeProphet> it worked well with predicate functions
22:04:23 <CakeProphet> but I don't know about constructors.
22:04:48 <FunctorSalad> maybe think of fmap first
22:05:00 <FunctorSalad> I don't see how to do that generally
22:05:19 <CakeProphet> :t fmap
22:05:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:05:35 <FunctorSalad> if I give you f:: (String,String) -> Int, how do you convert patterns?
22:05:45 <solidsnack> napping: Yeah, I think reify is just what I need; thank you.
22:06:09 <FunctorSalad> you don't have any string values in general, just variables
22:06:35 <Axman6> @src (->) fmap
22:06:35 <lambdabot> fmap = (.)
22:06:42 <Axman6> @src (.)
22:06:42 <lambdabot> (f . g) x = f (g x)
22:06:42 <lambdabot> NB: In lambdabot,  (.) = fmap
22:07:01 <FunctorSalad> it is a contravariant functor though, simply by "fmap f x = wrap x in view-pattern with function f"
22:07:11 <Axman6> > let fmap = (.); (.) = fmap in fmap f (Just x)
22:07:12 <lambdabot>   Ambiguous type variable `a' in the constraint:
22:07:12 <lambdabot>    `SimpleReflect.FromExpr a...
22:07:21 <Axman6> > let fmap = (.); (.) = fmap in fmap f (Just x) :: Maybe Expr
22:07:22 <lambdabot>   Ambiguous type variable `a' in the constraint:
22:07:22 <lambdabot>    `SimpleReflect.FromExpr a...
22:07:28 <CakeProphet> FunctorSalad:  I would need to figure out the fields of the Pattern type itself. 
22:07:47 <Axman6> > let fmap = (.); (.) = fmap in fmap (f :: Expr -> Expr)(Just (x::Expr)) :: Maybe Expr
22:07:51 <lambdabot>   mueval-core: Time limit exceeded
22:08:01 <djahandarie> lol?
22:08:01 <FunctorSalad> CakeProphet: I even assumed you have perfectly modelled actual patterns =)
22:08:13 <FunctorSalad> still seems impossible barring undefined
22:08:21 <napping> CakeProphet: suppose you have a pattern for strings, like (x:xs), and a function from strings to Int like length. How to you put "(x:xs)" and length together to make a pattern on Int?
22:08:33 <FunctorSalad> napping: yep
22:08:43 <FunctorSalad> that's what I meant
22:09:32 <FunctorSalad> (given an int-pattern p, we can make a string-pattern (length -> p) -- that's the contrafunctor I meant)
22:10:42 <CakeProphet> hmmm, the only thing I can think of, is that fmap would produce the pattern that matches the length of (x:xs)?
22:10:50 <CakeProphet> dunno what that means, exactly.
22:11:07 <napping> that's x:xs as a pattern
22:11:13 <CakeProphet> correct.
22:11:17 <FunctorSalad> the bigger picture is that patterns *consume* things of type a, and consumers transform contravariantly
22:11:39 <FunctorSalad> only things that *produce* a's tend to be (covariant) functors
22:12:26 <napping> the part you can be covariant in is what gets matched
22:12:43 <CakeProphet> is there a generalization of patterns that also produces values?
22:12:45 <napping> So, (ReaderT a Maybe) is kind of like patterns in a
22:13:09 <napping> most patterns bind variables
22:13:18 <CakeProphet> well that is what >>= should do
22:13:24 <napping> I don't know what other results you could use
22:13:24 <CakeProphet> in a pattern monad of any kind.
22:13:45 <soupdragon> why is there infinite solutions for n=2 and NONE or any other n
22:13:51 <soupdragon> x^n + y^n = z^n
22:13:53 <FunctorSalad> ("producer" includes containers here, a list gives you values from indices)
22:13:54 <soupdragon> that's weird
22:14:09 <napping> um, there are plenty of solutions for n = 0 and n = 1 as well
22:14:27 <dolio> Not for n = 0.
22:14:33 <FunctorSalad> soupdragon: I can answer the former ;) because there are orthogonal triangles
22:14:38 <FunctorSalad> forgot the real english term
22:14:51 <soupdragon> pythagorean triples? you mean?
22:14:54 <napping> not for n = 0, I guess
22:14:56 <FunctorSalad> yes
22:14:58 <napping> right triangles
22:15:05 <CakeProphet> FunctorSalad:  the pattern fmap f p binds the value of f applied to the value matched by p.
22:15:16 <FunctorSalad> for n>2, I won't even think about it, I don't have 300 years to spare
22:15:17 <FunctorSalad> ;)
22:15:23 <napping> the trick is knowing that there are right triangles with 3 integer sides
22:15:41 <FunctorSalad> CakeProphet: "the" value matched by p?
22:15:53 <FunctorSalad> a pattern doesn't contain actual values in general, that's the problem
22:16:22 <napping> CakeProphet: that's making a monad out of the result part, which is plausible. and pretty much equivalent to ReaderT over Maybe
22:16:39 <soupdragon> my book doesn't seem to say how to prove there's no points on the cubic
22:17:25 <soupdragon> stuff like  x^2 + y^2 = 3  can coem from modular congrence or decsrent, I think
22:17:31 <soupdragon> but  x^3 + y^3 = 1?
22:17:32 <wli> You mean no rational points?
22:17:37 <soupdragon> yes
22:18:05 <CakeProphet> FunctorSalad:  well you could think of a pattern as containing all possible values that it matches. And then a specific application of the pattern yield concrete values.
22:18:18 <FunctorSalad> ( soupdragon : you do know that this is a famously long story? and you ask us to explain it via *irc*? ;) no offense, it's not a bad question or anything, but the answer (which I don't know) would be loooong)
22:19:17 <kmc> what's the story? fermat's last theorem?
22:19:46 <soupdragon> It's easy to prove fermats last theorem for n=4 if you use the pythagorean triples
22:19:50 <FunctorSalad> CakeProphet: yes, so a pattern is (let's take the Bool simplification) like (a -> Bool)
22:19:54 <soupdragon> n=3 is harder
22:19:57 <soupdragon> (I don't know how)
22:20:04 <FunctorSalad> CakeProphet: you can't get (b -> Bool) from (a -> Bool) and (a -> b)
22:20:29 <FunctorSalad> wrong direction
22:20:51 <CakeProphet> FunctorSalad:  hmmm... okay so a "pattern monad" would be the computation of values matched by patterns?
22:21:08 <FunctorSalad> modelling patterns more faithfully than with bool won't make the 'a' on the input side disappear, of course
22:21:15 <Cale> soupdragon: http://en.wikipedia.org/wiki/Proof_of_Fermat%27s_Last_Theorem_for_specific_exponents#n.C2.A0.3D.C2.A03
22:21:28 <FunctorSalad> CakeProphet: monads have to be functors first
22:21:31 <CakeProphet> you not only match an input but you compute and return values that are functions applied to the bound variables.
22:21:33 <gwern> wow, I've been at this an hour now
22:21:44 <FunctorSalad> kmc: yes... or did I misread?
22:22:37 <FunctorSalad> CakeProphet: well, (a -> a) is not a functor in a either
22:22:47 <FunctorSalad> making the result more complex won't help
22:22:59 <gwern> if I were reading the wikipedia articles fror all these drugs, it'd probably be quite a pharmacological education
22:23:16 <FunctorSalad> it's just that you'll never turn an 'a' in the argument position to a 'b' if all you have is an 'a -> b'
22:23:43 <FunctorSalad> gwern: famous last words? ;)
22:23:45 <CakeProphet> FunctorSalad:  then perhaps the idea I have is not quite a functor or a monad, but can be composed in a similar fashion?
22:23:48 <FunctorSalad> (which drugs :o)
22:23:54 <gwern> FunctorSalad: 'I wonder what this drug does?'
22:24:17 <FunctorSalad> gwern: I meant your message literally ;)
22:24:39 <FunctorSalad> ('surely wikipedia is sound pharmacological education') ;)
22:24:44 <kmc> yes better take them all
22:24:47 <kmc> so you have first hand knowledge
22:25:00 <FunctorSalad> but that was just for the sake of witticism, wikipedia isn't so bad actually
22:25:04 <FunctorSalad> just depends on article
22:25:23 <gwern> wikipedia's drug articles are usually very good
22:25:28 <FunctorSalad> CakeProphet: contravariant functor
22:25:44 <FunctorSalad> maybe a monad for the dual category too, no idea
22:25:55 <kmc> contramap :: (a -> b) -> f b -> f a
22:25:58 * mtnviewmark wonders if wikipedia considers Haskell a drug.... I know my spouse does!
22:26:18 <kmc> mtnviewmark, it is widely known to be mind-altering
22:26:21 <FunctorSalad> (a comonad reverses other arrows, not the ones we need ;((
22:26:27 <FunctorSalad> s/((/))/
22:26:32 <FunctorSalad> (posix basic regexp)
22:27:33 <CakeProphet> FunctorSalad:  ...that is really all way over my head at this point.
22:28:03 <FunctorSalad> CakeProphet: ok :) but kmc gave you the sig at least
22:28:57 <FunctorSalad> CakeProphet: try to write contramap for the dual of the Reader monad
22:29:03 <CakeProphet> FunctorSalad:  ...how would a function such as that work?
22:29:27 <kmc> here's an example of a contrafunctor:  data ToInt a = ToInt (a -> Int)
22:29:33 <Cale> Heh, cool, (Sir) Andrew Wiles was knighted for proving FLT.
22:29:36 <FunctorSalad> that one, yes
22:29:39 <FunctorSalad> (@kmc)
22:29:43 <soupdragon> he is an inspiration
22:29:51 <FunctorSalad> (CoReader Int?)
22:29:53 <kmc> CakeProphet, so perhaps you can write contramap for that type
22:30:01 <Cale> He actually proved something a whole lot cooler than FLT.
22:30:11 <Cale> FLT was just a corollary :)
22:30:13 <soupdragon> I dont beleive tha tI am capable to understand it
22:30:16 <soupdragon> yet......
22:30:39 <kmc> is the FLT proof machine-checkable?
22:30:42 <kmc> Coq or it didn't happen
22:30:45 <soupdragon> absouletly not
22:30:57 <kmc> there's a proof of the Four Color Theorem in Coq
22:31:25 <Cale> kmc: The proof is 100 pages long even in English :)
22:31:28 <kmc> hehe
22:31:37 <kmc> well, how long is the 4CT proof in English?
22:31:46 <soupdragon> it's not in english
22:31:56 <kmc> supposing you make your case analysis enumerator output English text
22:32:50 <gwern> hah. I just blew Recent Changes's stack
22:32:55 <gwern> I can't even see what vandalism I've missed
22:33:19 <gwern> have to manually edit the URL to go further back
22:33:19 <soupdragon> im trying to search for 'proving elliptic curves has no solutions'
22:33:42 <gwern> well, only 50-100 more to go
22:36:11 <FunctorSalad> CakeProphet: don't get me wrong, your idea is a good idea, just wrong sign :)
22:36:32 <FunctorSalad> in case the explanation why it can't work covariantly sounded to disapproving...
22:36:48 <CakeProphet> yeah, I don't think I'll be able to get it to match. Perhaps I should just write it up without worrying about existing typeclasses
22:36:52 <CakeProphet> and then see what types happen to match if any.
22:37:21 <FunctorSalad> I mean even if patterns were first-class already
22:38:12 <FunctorSalad> was I even understanding correctly that the 'a' is the type being matched on?
22:38:35 <CakeProphet> yes, that is a. here's the problem I see:
22:39:02 <CakeProphet> there is the type being matched on, and then there is the type of computations. The reason you need to express the second type is because the act of /binding/ a variable involves a function that it binds to.
22:39:42 <CakeProphet> you can't simply have Pattern a, because that doesn't tell you anything about the function(s) that the Pattern is being applied to.
22:40:51 <CakeProphet> @src map
22:40:51 <lambdabot> map _ []     = []
22:40:51 <lambdabot> map f (x:xs) = f x : map f xs
22:41:12 <FunctorSalad> a 'Pattern a' tells you how to take an 'a' apart. say you can make 'b's from 'a's. there's no way you can take apart a 'b' from these two pieces of knowledge
22:41:34 <FunctorSalad> but it all falls into place if you can make 'a's from 'b's :)
22:42:13 <CakeProphet> hmmm
22:42:17 <CakeProphet> well... that would be the constructor right?
22:42:32 <CakeProphet> (:) in map
22:42:48 <CakeProphet> hmmmm
22:42:56 <CakeProphet> I think this requires structural typing of some kind.
22:43:24 <CakeProphet> @src filter
22:43:24 <lambdabot> filter _ []     = []
22:43:24 <lambdabot> filter p (x:xs)
22:43:24 <lambdabot>     | p x       = x : filter p xs
22:43:24 <lambdabot>     | otherwise = filter p xs
22:43:31 <FunctorSalad> (well, there is a way if you take all the preimages, but that will yield any number of answers, possible zero)
22:43:42 <CakeProphet> oreimages?
22:43:44 <CakeProphet> *p
22:44:11 <FunctorSalad> 'invert' a noninvertible function ;)
22:44:22 <wli> So it's nondet (any number) vs. multidet (1 or more) or semidet (0 or 1).
22:44:51 <FunctorSalad> which returns a set, called the preimage
22:45:18 <FunctorSalad> (given y, the preimage of y under f is { x | f x = y })
22:45:34 <FunctorSalad> but that was just a side remark
22:45:47 <CakeProphet> Pattern ([a] -> [a]) ??? is that possible?
22:46:06 <FunctorSalad> wli: multidet if the function is surjective, semidet if it's injective
22:46:29 <FunctorSalad> exactly 1 preimage if it's invertible aka bijective
22:46:47 <CakeProphet> perhaps a Pattern is a notion over functions and not single values.
22:48:26 <CakeProphet> but I think that would require type pattern matching.  data Pattern (a -> b) = ...
22:48:37 <CakeProphet> ...or just Pattern a b  :P
22:49:26 <kmc> CakeProphet, i'm curious what you're working on
22:49:33 <CakeProphet> first-class patterns.
22:50:35 <CakeProphet> okay....
22:50:37 <CakeProphet> :t (:)
22:50:38 <lambdabot> forall a. a -> [a] -> [a]
22:56:03 <gwern> whew
22:56:06 <gwern> I'm done!
22:56:17 <CakeProphet> :t filter
22:56:18 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:56:19 <CakeProphet> :t map
22:56:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:56:40 <gwern> took 1.5 hours to delete all the vandalism and indefban the accounts
22:56:47 <gwern> hope I don't have to do that again
22:59:15 <blackdog> gwern: what was vandalised?
22:59:19 <gwern> haskell.org
23:02:07 <CakeProphet> data PAttern2 a b c = (a -> b -> c) (c -> a) (c -> b)
23:02:54 <CakeProphet> Pattern2 $ (:) head tail
23:03:15 * hackagebot pointedlist 0.4.0 - A zipper-like comonad which works as a list, tracking a position.  http://hackage.haskell.org/package/pointedlist-0.4.0 (JeffWheeler)
23:04:23 <CakeProphet> data PAttern2 a b = (c -> a) (c -> b)
23:05:46 <CakeProphet> match (Pattern2 a b) f x =  f (a x) (b x)
23:06:05 <CakeProphet> now... how to generalize that.
23:06:57 <ezyang> something like reader. 
23:07:40 <CakeProphet> I'm not very familiar with reader. I've never needed to use it.
23:08:47 <Axman6> > do { x <- show; y <- (*2); return (x, y)} 3
23:08:48 <lambdabot>   <no location info>: parse error on input `3'
23:08:55 <Axman6> > (do { x <- show; y <- (*2); return (x, y)}) 3
23:08:56 <lambdabot>   ("3",6)
23:10:17 <kamatsu> is it possible to constrain a type family with a class?
23:10:24 <Axman6> > (do { x <- show; y <- (*2); z <- (y^); return (x, y, z)}) 3
23:10:25 <lambdabot>   ("3",6,216)
23:10:30 <kamatsu> i.e all instances of this type family must be a member of a typeclass
23:10:36 <Axman6> > (do { x <- show; y <- (*2); z <- (y^); return (x, y, z)}) 2
23:10:36 <lambdabot>   ("2",4,16)
23:10:45 <kmc> kamatsu, use an associated type instead
23:10:55 <kamatsu> what if they're already an associated type?
23:11:03 <kmc> hmm
23:11:13 <kniu> @hoogle trace
23:11:13 <lambdabot> Debug.Trace trace :: String -> a -> a
23:11:14 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
23:11:14 <lambdabot> module Debug.Trace
23:11:16 <kmc> then you'd add the constraint as a superclass of the class you're defining
23:11:19 <kamatsu> ah
23:11:20 <kamatsu> right
23:11:28 <kamatsu> wait, hm
23:11:30 <kmc> not sure if it can be done elseways
23:11:34 <kamatsu> > class Process p where
23:11:35 <kamatsu> >   type HasChannel p
23:11:35 <lambdabot>   <no location info>: parse error on input `class'
23:11:36 <lambdabot>   <no location info>: parse error on input `type'
23:11:40 <CakeProphet> Is there a reason Haskell shouldn't have structural typing?
23:11:54 <kamatsu> CakeProphet: it does, see the Has library :)
23:12:08 <kmc> CakeProphet, do you mean structural subtyping?
23:12:34 <kamatsu> kmc: I want to restrict the HasChannel p associated type to be only members of the Boolean typeclass.
23:12:42 <gwern> hm, I wonder if there is an IRC channel good for asking X questions in
23:12:43 <kamatsu> seems like i could do this with fundeps but not tfs?
23:12:49 <CakeProphet> no, structural typing. as in specifying a type based on the number and types of constructor fields.
23:12:57 <m3ga> blackdog: that tutorial does look interesting
23:13:06 <kamatsu> CakeProphet: see the has library.
23:13:07 <blackdog> m3ga: yeah
23:13:12 <kmc> kamatsu, ah, you're restricting the RHS of the type synonym family, not the indices
23:13:13 <kmc> ?
23:13:19 <kamatsu> kmc: yes
23:13:23 <om-foxy> :t (:=)
23:13:23 <CakeProphet> gwern:  perhaps you should go to the channel dedicated to questions related to which channel you should ask questions in.
23:13:24 <lambdabot> forall a b. a -> b -> Assoc a b
23:13:29 <blackdog> m3ga: i feel a bit bad, actually - I can't come to FP-Syd tonight
23:13:33 <gwern> CakeProphet: ok. what channel is that?
23:13:35 <blackdog> gah, i mean thursday
23:13:37 <om-foxy> :t Assoc
23:13:38 <lambdabot> Not in scope: data constructor `Assoc'
23:13:41 <CakeProphet> gwern:  dunno, ask them.
23:13:51 <blackdog> and i asked for the ATS talk, too ;/
23:14:02 <kmc> CakeProphet, ah.  i think the "records" library is also relevant
23:14:04 <gwern> CakeProphet: it seems I ought to find a channel for finding a channel to ask where to ask my qestion
23:14:17 <kmc> CakeProphet, so you want "anonymous" sum and product types?
23:14:23 <Axman6> blackdog: :(
23:14:36 <CakeProphet> kmc:  yes, that's a good way to describe it. I don't want, I'm just wondering if such a thing would break the type system
23:14:38 <blackdog> Axman6: I can't, I'm meeting blackh.
23:14:40 <Axman6> kamatsu: you're coming to AusHac right?
23:14:42 <Axman6> yeah
23:14:44 <blackdog> he gets in about 8:30
23:14:45 <kamatsu> Axman6: yeah, 
23:14:59 <FunctorSalad> gwern: just picky any? aren't people on irc usually happy to tell you to go somewhere else? ;)
23:15:00 <Axman6> then both of you need to join #AusHac2010 ;)
23:15:02 <kmc> CakeProphet, you can encode that within the Haskell type system.  (,) and Either are anonymous products and sums
23:15:07 <m3ga> blackdog: it on thursday, not tonight
23:15:09 <gwern> FunctorSalad: ah, so we reach a base case!
23:15:14 <CakeProphet> kmc:  ...well, I mean.
23:15:19 <CakeProphet> structural typing as in
23:15:22 <FunctorSalad> (generic "you")
23:15:23 <blackdog> m3ga: yeah. just mistyped
23:15:25 <kamatsu> blackdog: blackh... bernard blackham?
23:15:32 <blackdog> stephen blackheath
23:15:34 <kamatsu> oh
23:15:34 <CakeProphet> (a, [a])   ...this is the type of all values that are constructed from an a and a [a]
23:15:38 <blackdog> nz hacker, works with iPwn
23:15:40 <Axman6> NZ Haskell hacker
23:15:42 <kamatsu> right
23:15:45 <m3ga> blackdog: you coming to AusHac?
23:15:53 <CakeProphet> so it would be a type of [1,2] but not []
23:15:57 <blackdog> m3ga: does the pope defecate woodswise?
23:16:02 <kmc> CakeProphet, i don't follow
23:16:16 <m3ga> well you should join us in #AusHac2010
23:16:27 <gwern> so anyway. it occurs to me that it's probably possible to write a program to scrape all display text from X; X presumably knows about all the text since it has to be able to doubleclick on it, store it in selection, and render it using its fonts
23:16:31 <gwern> am I wrong?
23:17:18 <FunctorSalad> hmm, why couldn't it be that the GUI toolkit is responsible for telling X the selection?
23:17:25 <CakeProphet> kmc:  a structural type would match at the constructor level.  I'll use curly brackets to represent it. so {a,b} is /any/ product (or is it sum? what is the difference again?) of a and b.
23:17:28 <FunctorSalad> with X being text-agnostic
23:17:48 <c_wraith> gwern: you could go with the really hacky "write a program to select everything, then examine the clipboard" approach
23:17:54 <kmc> CakeProphet, (,) is a binary product, Either is a binary sum.
23:17:55 <gwern> c_wraith: that's awful!
23:17:59 <kmc> data Prod a b = Prod a b
23:18:02 <c_wraith> gwern: I agree :)
23:18:05 <kmc> data Sum a b = L a | R b
23:18:07 <gwern> FunctorSalad: well, I suppose that's possible
23:18:19 <CakeProphet> kmc:  {a,b} would be the shared  type of both [1,2] and (1,2).
23:18:20 <kmc> product corresponds to logical conjunction / AND, and sum corresponds to logical disjunction / OR
23:18:23 <FunctorSalad> that's hacky? ocr'ing the screen would be
23:18:25 <CakeProphet> and [1,2,3] and (1,2)
23:18:26 <kmc> and product distributes over sum like you'd expect
23:18:34 <CakeProphet> any value constructed from two elements is {a,b}
23:18:39 <kmc> CakeProphet, a and b are type variables?
23:18:40 <kmc> i see
23:18:44 <CakeProphet> kmc:  yes.
23:18:48 <gwern> FunctorSalad: well, I did consider OCR'ing the screen. but that's too CPU-intensive
23:18:51 <m3ga> blackdog: you need another irc channel : #AusHac2010
23:19:00 <kmc> presumably [1,2] is also in {a,a}
23:19:07 <kmc> but (1,'x') is in {a,b} but not {a,a}
23:19:17 <kmc> CakeProphet, it sounds a tiny bit like the combinatorial species stuff
23:19:17 <FunctorSalad> gwern: no clue, isn't it straightforward with perfect pixels?
23:19:23 <FunctorSalad> rather than a scan
23:19:24 <CakeProphet> kmc:  you could also pattern match with it. so {a,b} = c  would grab the first and second fields of c. I'm just wondering if such a notion of structural typing would break Haskell's type system.
23:19:35 <kamatsu> kmc: so, no way to restrict the RHS of the associated type?
23:19:47 <kmc> kamatsu, i can't think of one
23:19:47 <gwern> FunctorSalad: a high-res scan can be basically as high-res as a screen; and there's aliasing and whatnot smearing over pixels
23:19:55 <kmc> other than putting constraints on the values that use it, of course
23:20:07 <kamatsu> kmc: yeah, but that means putting a large constraint on every single function
23:20:08 <kamatsu> sigh
23:20:16 <kamatsu> constraint synonyms would also suffice.
23:20:21 <kmc> or you can wrap them in a GADT whose ctor holds the constraint
23:20:24 <FunctorSalad> gwern: I mean all copies of a char will be exactly identical for a screen capture
23:20:34 <kamatsu> kmc: ah, that might work, let me see
23:20:41 <FunctorSalad> in contrast to a scan
23:20:50 <gwern> FunctorSalad: I don't think so; proportional fonts, hinting, stuff a toolkit or aliasing or whatnot all mess up pixel identity
23:20:53 <gwern> it's not a terminal
23:21:19 <FunctorSalad> those aren't done once only per letter? don't know
23:21:26 <FunctorSalad> (and bg color)
23:22:01 <FunctorSalad> anyway, maybe dbus can solve your problem much more directly? ;)
23:22:10 <FunctorSalad> not the general text-extraction one though
23:22:48 <gwern> dbus?
23:23:04 <CakeProphet> kmc:  I suppose it would give every value in Haskell a "nominal" type (aka the types we normally use) and a structural type. [] is ntype [a] and stype {}. [1..] is ntype [Int] and stype {Int,[Int]}.
23:23:32 <FunctorSalad> gwern: if your particular program offers it
23:23:36 <Zeiris> How do I write seconds since Jan 1st 1970 in "mm/dd/yyyy" format?
23:23:55 <kmc> CakeProphet, so the stype is a direct consequence of using the (:) constructor?
23:24:00 <gwern> FunctorSalad: yeah, that wouldn't be general enough
23:24:03 <CakeProphet> kmc:  correct.
23:24:25 <FunctorSalad> just curious, is this for an xmonad addon?
23:24:36 <gwern> FunctorSalad: nah, just general lifelogging thoughts
23:24:50 <FunctorSalad> gwern: ah :) I use arbtt for that
23:24:51 <gwern> FunctorSalad: I figure text dumps will be much smaller and compress better than taking PNG screneshots
23:25:00 <kmc> CakeProphet, interesting
23:25:03 <FunctorSalad> (that's way more abstract though)
23:25:06 <CakeProphet> kmc:  I'm really wondering if it will break dedicability. 
23:25:08 <kmc> CakeProphet, do you imagine that stypes are statically known?
23:25:12 * gwern thinks arbtt isn't the same thing
23:25:39 <FunctorSalad> it logs idleness, window titles, active window, every n seconds
23:25:44 <kmc> Data.Data provdes something close to your stypes, at runtime
23:25:54 <kmc> it seems like types that always know which ctor is used, statically, are close to dependent typing
23:25:58 <CakeProphet> kmc:  hmmm... in many cases, yes. But some types don't have constructors, so that couldn't really be reasoned with at all structurally.
23:25:59 <kmc> and you'd lose decidable inference
23:26:10 <kmc> CakeProphet, i imagine you'd introduce a stype meaning "abstract type"
23:26:15 <FunctorSalad> and that's still too much data to read directly ;)
23:26:15 <CakeProphet> yes.
23:26:26 <gwern> FunctorSalad: yeah, but that's not going to save te actual window contents
23:26:32 <FunctorSalad> my primary use is abstracting it to idle/nonidle timelines, actually
23:26:34 <kamatsu> kmc: you can do this, surprisingly
23:26:35 <kamatsu> > class (Boolean (HasChannel p)) => Process p where
23:26:36 <kamatsu> >   type HasChannel p
23:26:36 <kamatsu> >   type ProcessInfo p
23:26:36 <kamatsu> >   type ProcessState p
23:26:36 <lambdabot>   <no location info>: parse error on input `class'
23:26:36 <lambdabot>   <no location info>: parse error on input `type'
23:26:37 <lambdabot>   <no location info>: parse error on input `type'
23:26:38 <lambdabot>   <no location info>: parse error on input `type'
23:26:42 <kamatsu> ah, sorry lambdabot 
23:26:56 <CakeProphet> kmc:  I'm trying to think of a situation in which a structural type wouldn't be known statically.
23:27:35 <RyanT5000> what's the practical difference between using "type" and "data" for associated types?
23:28:16 <kamatsu> RyanT5000: Type defines a type synonym, data defines a data type.
23:28:31 <RyanT5000> right, i know what the keywords do
23:28:35 <ski> wli : logic programming ?
23:28:35 <kamatsu> RyanT5000: the major upshot is that data is guaranteed to be injective but each instance must be unique.
23:28:50 <ski> gwern : what, hawiki is still available online ?
23:28:50 <kamatsu> e.g
23:28:58 <FunctorSalad> don't expect much type inference with 'type family'... OTOH, more wrapping boilerplate with 'data family'
23:29:08 <FunctorSalad> apart from that I have little experience
23:29:15 <ski> CakeProphet : maybe what you want is light-weight record and variant types (like e.g. OCaml's polymorphic variants)
23:29:20 <kamatsu> data family Foo a
23:29:23 <RyanT5000> FunctorSalad: that makes sense
23:29:24 <gwern> ski: haskell.org?
23:29:27 <gwern> seems to be up
23:29:30 <kamatsu> data instance Foo Qux = Bar
23:29:38 <kamatsu> data instance Foo Fuz = Bar
23:29:39 <kamatsu> is an error
23:29:43 <ski> gwern : well, that takes me to haskellwiki, not hawiki
23:29:46 <CakeProphet> kmc:  the values given by various IO actions might not have known structural types. hgetLine might return {} or {Char, [Char]}
23:29:58 <FunctorSalad> kamatsu already mentioned injectivity
23:30:08 <kmc> RyanT5000, each "data instance" introduces a new type with ctors, just like plain old "data"
23:30:10 <CakeProphet> kmc:  but it could be known as stype "a", perhaps?
23:30:19 <gwern> ski: bah, haskellwiki is hawiki
23:30:20 <RyanT5000> yeah
23:30:27 <kmc> "type instance" introduces a pattern matching clause of a function on existing types
23:30:28 <ski> gwern : no :)
23:30:45 <kamatsu> RyanT5000: the data family introduces a data type, a type family doesn't
23:30:46 <FunctorSalad> normally type application is even injective in *both* args
23:30:47 <RyanT5000> alright, so in the specific thing i'm working on, i think what i'd really like is a "data", but i'm wondering about performance now
23:30:57 <kmc> RyanT5000, you can make a data family with newtype instances
23:31:00 <ski> gwern : <http://web.archive.org/web/20061011050149/www.haskell.org/hawiki/FrontPage> is hawiki
23:31:06 <FunctorSalad> we discussed how maybe type fams should be lowercase to mislead less
23:31:11 <RyanT5000> kmc: oh? what's the syntax for that?
23:31:13 <kmc> or a mix of newtype and non-newtype
23:31:26 <RyanT5000> that's exactly what i was thinking of doing, but i wasn't aware it was possible
23:31:33 <kmc> "data family F a; newtype instance F Int = FInt; data instance F Char = FChar"
23:31:42 <RyanT5000> cool
23:31:43 <kamatsu> RyanT5000: performance of a data family is just as good as a normal data type.
23:32:13 <CakeProphet> I'd imagine the compiler would get along just fine if it at least knew the stype or the ntype of every value. It wouldn't need to know both.
23:32:44 <RyanT5000> kamatsu: yeah, i expected that, but i wasn't sure whether i could achieve newtype-level efficiency
23:32:50 <RyanT5000> basically, i'm writing an interface
23:32:58 <RyanT5000> and i didn't want to impose slowness on every implementor
23:33:05 <kamatsu> right
23:33:11 <kamatsu> well yes, you can have newtype instance.
23:33:12 <FunctorSalad> hehe 'newtype instance' surprised me too
23:33:12 <RyanT5000> in the form of an associated "data" type
23:33:28 <RyanT5000> so i'm glad to know i can newtype it
23:33:43 <kmc> imo data families are a bit cleaner than type families, because normalizing evaluation at type level doesn't quite seem to be there yet
23:33:56 <ezyang> Besides comonads, what are other co- datastructures that tend to show up in the Haskell blogosphere? 
23:33:59 <kamatsu> kmc: ah, i discovered that you can constrain the RHS btw
23:34:01 <kmc> an application of a data family is always in normal form
23:34:03 <CakeProphet> instance Two {a,b} where fst {a,b} = a; snd {a,b} = b
23:34:03 <kmc> kamatsu, cool, how?
23:34:17 <RyanT5000> kmc: yeah; they seemed especially better in my circumstances because the types i'm using are meant to be opaque to the end user
23:34:21 <kmc> mm
23:34:21 <FunctorSalad> how does it handle overlaps, btw?
23:34:29 <kmc> how does which?
23:34:37 <kamatsu> kmc: you put the constraint in the class header of the type, it surprisingly works.
23:34:48 <FunctorSalad> hmm, seems to apply to both type fam and data fam
23:35:00 <Saizan> it doesn't allow any overlap
23:35:04 <kamatsu> lass (Boolean (HasChannel p)) => Process p where type HasChannel p
23:35:09 <kamatsu> *class
23:35:11 <kmc> FunctorSalad, you're asking how type/data instance overlap is determined?
23:35:16 <kmc> kamatsu, ahh, right
23:35:48 <FunctorSalad> kmc: I mean instances that have at least one common specialization
23:35:57 <FunctorSalad> (but Saizan said it's simply disallowed)
23:36:07 <kmc> i thought the rules for overlap (and the extensions) were the same as classes
23:36:32 <kmc> hmm ghc sez "The instance declarations of a data family used in a single program may not overlap at all"
23:36:40 <kmc> but "The instance declarations of a type family used in a single program may only overlap if the right-hand sides of the overlapping instances coincide for the overlapping types"
23:36:48 <FunctorSalad> ok I see
23:37:09 <CakeProphet> ....here's an interesting idea for the stype/ntype thing. The tuple types could have known stypes but inferred ntypes.
23:37:16 <CakeProphet> anonymous type constructors.
23:37:29 <FunctorSalad> so you couldn't have 2 clauses, one for Int and a default one, just like with classes
23:37:51 <kmc> you can do that with classes with OverlappingInstances
23:37:57 <CakeProphet> so (1,2) :: a ; {Int,Int}
23:38:03 <kmc> but i guess you can't do it with type synonym families
23:38:09 <CakeProphet> or just have the tuple type itself be the structural type syntax.
23:38:14 <FunctorSalad> kmc: not incoherent?
23:38:15 <CakeProphet> so (1,2) :: a ; (Int,Int)
23:38:28 <kmc> FunctorSalad, it wouldn't necessarily be incoherent
23:38:35 <FunctorSalad> hmm, right, misremembered
23:38:47 <FunctorSalad> but ISTR this doesn't work well even with OI
23:38:58 <kmc> if you have "instance C Int; instance C a" and you use C at the totally fixed type Int, it's not incoherent
23:39:41 <Saizan> it does work, but some OO guys find how it works confusing
23:39:48 <FunctorSalad> yes, but with a polymorphic function it always uses the default unless it can deduce a=Int statically?
23:39:58 <FunctorSalad> or is it dynamically dispatched then
23:40:22 <kmc> FunctorSalad, it would be incoherent if there's some chance of committing to the general case, then having someone else introduce a new special case
23:40:22 <Saizan> if it's forced to solve the C a constraint it'll use the (C a) instance in some cases, yeah
23:40:37 <CakeProphet> ...surely there's some flaw in this idea of structural type.
23:41:00 <FunctorSalad> kmc: istr you need 2 params for incoherence
23:41:09 <kmc> maybe
23:41:12 <FunctorSalad> hmm, or one tuple
23:41:23 <Saizan> FunctorSalad: they are going to allow overlapping instances for closed type/data families
23:41:34 <FunctorSalad> instance (Int,a) vs instance (z,Int), none is most specific for (Int,Int)
23:42:02 <maurer_> Why do we not implicitly typeclass all record field accessors, so that if I did data Person = Person {name :: String} and later data Building = Building {name :: String} we would be fine?
23:42:19 <FunctorSalad> Saizan: if it's closed it could just work as on the value-level (first (lexically) clause wins))
23:42:21 <maurer_> That way we could just infer with our typing that the thing needs a name, and throw an error if two things have a different type name?
23:42:40 <Saizan> FunctorSalad: right
23:43:33 <FunctorSalad> Saizan: I'm not an OO guy primarily, but I do find it bad that generalizing should change the behaviour for the specific you started with
23:44:11 <kamatsu> is there a way to specify a default RHS in type families?
23:44:27 <Saizan> FunctorSalad: that i find bad too, but it doesn't happen if you let the constraint propagate
23:44:30 <kamatsu> so, type Foo a = Bar
23:44:39 <kamatsu> type Foo <specific> = Baz
23:44:52 <FunctorSalad> Saizan: as opposed to artificially narrowed sigs?
23:45:01 <FunctorSalad> (that was the case I have in mind)
23:45:03 <CakeProphet> I think this is invent-new-language-extensions hour.
23:45:23 <kmc> CakeProphet, that's every hour
23:45:49 <CakeProphet> GHC should have a plugin interface for language extensions, so we can hack Haskell to our whim.
23:45:55 <Saizan> FunctorSalad: yeah, but also, more worrying, with higher-rank types
23:46:12 <kmc> CakeProphet, it does, it's called Template Haskell.  sort of.
23:46:45 <kmc> you can prototype most language extensions using either TH or an external preprocessor
23:46:57 <CakeProphet> kmc:  what about structural typing?
23:47:02 <Saizan> foo :: (forall a. a -> B) -> B, bar :: C a => a -> B, i thinkg foo bar will just use the most general instance
23:47:03 <kmc> i'm not sure
23:47:26 <FunctorSalad> if you can express it as macros expanding to plain haskell types
23:47:43 <kmc> CakeProphet, as for an implementation encouraging extension experimentation, I'd favor a simple interpreter over a fancy compiler like GHC
23:47:46 <kmc> much easier to hack
23:47:55 <kmc> Hugs is nearly abandoned though
23:48:04 <CakeProphet> kmc:  yeah an interpreter would be easier to hack for sure.
23:48:13 <kmc> i think UHC is designed this way
23:48:57 <Saizan> FunctorSalad: ah, no "foo bar" is a type error
23:48:59 <FunctorSalad> Saizan: what would the special instance be? (and the TC isn't used in that example)
23:49:25 <CakeProphet> surely a smart person on this channel can show me that having a structural typing system on top of the standard Haskell type system would cause chaos and discord. 
23:49:27 <FunctorSalad> oh right, negative positions negate generality too =)
23:49:46 <ski> ezyang : not sure about blagosphere, but how about `comonoid',`coalgebra',`costrength',`CoYoneda',`CoIdeal' and `CoFree' comonads,`CoDensity' monad ?
23:50:01 <ezyang> ski: Good list. 
23:50:12 <ezyang> maybe add coindicution and codata to it. 
23:50:19 <ezyang> *induction 
23:50:21 <FunctorSalad> cothings package?
23:50:28 <ski> i'm sure edwardk could give you more, if you prod him
23:50:32 <ezyang> does that exist? 
23:51:18 <ezyang> Google says no. 
23:51:21 <Zeiris> Why do the two functions provide different outputs? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27394#a27394
23:51:30 <ezyang> ok, lessee, how many of these do I vaguely understand. 
23:51:34 <ezyang> none of 'em. bleh. 
23:51:50 <Saizan> FunctorSalad: i was thinking of this, http://www.haskell.org/pipermail/glasgow-haskell-users/2010-February/018366.html
23:51:50 <ezyang> writing my "explaining duality" post is going to be harder 
23:51:59 <FunctorSalad> ezyang: I was asking whether you're currently *making* a cothings package ;)
23:52:03 <ski> `CoYoneda' is simple
23:52:04 <FunctorSalad> not saying it exists
23:52:27 <ezyang> FunctorSalad: Ah. 
23:52:34 <ezyang> No need to step on category-extras toes :-) 
23:52:54 <ski> ezyang : `data CoYoneda f a = forall x. FMapIncl (x -> a) (f x)' with `incl :: f a -> CoYoneda f a; incl fa = FMapIncl id fa' and `fmap ba (FMapIncl xb fx) = FMapIncl (ba . xb) fx'
23:53:23 <ski> ezyang : regardless of what `f' is `CoYoneda' is "like" `f', but supports `fmap'
23:53:45 <ski> ezyang : e.g. `CoYoneda IORef' is like an `IOReadRef', which you can `fmap' over
23:53:48 <CakeProphet> Zeiris:  They don't seem to do similar things at all.
23:54:47 <Zeiris> CakeProphet, the only difference is the toInteger, which I needed to resolve a type error :E
23:55:16 <FunctorSalad> Saizan: hehe, not shocking that there's a questionable corner case with the combination of these extensions =)
23:55:19 <ski> ezyang : also, if `f' is already a functor, but wheter `fmap' is not trivial, then `CoYoneda f' is more efficient, in that it collects the functions to map, and only performs the maps when you extract the contents (in exchange for you not being able to look at the elements before doing that)
23:56:00 <Saizan> FunctorSalad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27395#a27395 <- works when church encoded too :)
23:56:01 <FunctorSalad> I'd be more likely to expect dynamic dispatch for the existential, though
23:56:15 <Itkovian> dons: will the cufp tutorial be made available?
23:56:20 <ManateeLazyCat> I'm ready to release bug fix version : gtk2hs-0.11.1, does anyone have any bug in gtk2hs-0.11.0?
23:56:31 <ski> ezyang : iirc, `data Ideal f a = Return a | Incl (f a)' (a monad), so `data CoIdeal f a = MkCoIdeal { extract :: a , proj :: f a }'
23:56:38 <CakeProphet> Zeiris:  Why does test not result in a type error then if that is the only difference?
23:56:38 <ManateeLazyCat> If have, please report to me, i will fix it in gtk2hs-0.11.1
23:56:57 <ezyang> ski: CoYoneda feels like cheating: we're not actually ever "fmapping"... 
23:56:59 <Zeiris> I dunno, I moved the position of toIntegral and now it works and I give up
23:57:15 <ezyang> but that's a pretty good intuition. 
23:57:21 <ManateeLazyCat> Saizan: Can you help me look http://hackage.haskell.org/packages/archive/poppler/0.11.1/logs/failure/ghc-6.12 ? I don't understand why package can't buld at hackage.
23:57:30 <CakeProphet> Zeiris:  what is the return type of toSeconds?
23:57:34 <ManateeLazyCat> Saizan: I can build http://hackage.haskell.org/package/poppler-0.11.1 on my box.
23:57:46 <FunctorSalad> Saizan: but doesn't sneak around Incoh. Inst. that way at least?
23:57:50 <ezyang> where's readref from? 
23:57:52 <ski> ezyang : also, `data FreeMonad f a = Return a | JoinIncl (f (FreeMonad f a))' and `CoFreeCoMonad f a = MkCFCM {extract :: a , projScaffold :: f (CoFreeCoMonad f a)}'
23:58:09 <FunctorSalad> (in the way existentials do according to first posting)
23:58:21 <ski> ezyang : the actual mapping occurs in `unIncl :: Functor f => CoYoneda f a -> f a; unIncl (FMapIncl xa fx) = fmap xa fx'
23:58:25 <ezyang> oh, missed your later messages. 
23:58:47 <FunctorSalad> Saizan: btw, maybe we should special case this particular type inference problem (folding an existential)
23:59:05 <Saizan> FunctorSalad: oh, i forgot i had II there, and it doesn't pass without
23:59:06 <ezyang> wait up wait up! 
23:59:10 <FunctorSalad> it seems to come up often, and seems solvable for the basic case
23:59:33 <ski> ezyang : `IOReadRef' is not in libs, afaik .. i've previously defined it as `data IOReadRef a = forall x. MkIOReadRef (IORef x) (x -> a)' .. but later i've noticed this is `CoYoneda IORef'
23:59:35 <FunctorSalad> (special-case it from the "won't even try" policy ghc has for undecidable typing problems)
