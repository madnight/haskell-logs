00:03:17 <mm_freak_> kmc: why?  most functions are written without lambdas
00:03:41 <mm_freak_> sum = foldl' (+) 0
00:04:15 <mm_freak_> but honestly i've never found a case, where i would desperately ask for a points-free 'case'
00:04:33 <mm_freak_> i did, however, often encounter something like this:  do x <- c; case x of …
00:04:42 <mm_freak_> so i'd vote for an 'mcase'
00:04:53 <mm_freak_> do mcase c of …
00:05:20 <Heffalump> if we had case of, then you could do c >>= case of ...
00:05:50 <mm_freak_> Heffalump: well, the problem with (>>=) is that it would introduce unnecessary indentation
00:05:57 <Heffalump> true
00:06:33 <mm_freak_> also IMO there should be some whenM and unlessM in the base library
00:06:47 <mm_freak_> i often end up doing this:  do x <- c; when x …
00:07:09 <mm_freak_> alternative:   whenM c …
00:07:26 <mm_freak_> but in this case (>>=) actually helps a bit
00:07:28 <Veinor> mm_freak_: what's the source of whenM?
00:08:22 <mm_freak_> whenM p c = p >>= (`when` c)
00:08:43 <mm_freak_> :t \p c -> p >>= (`when` c)
00:08:44 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
00:08:50 <mm_freak_> :t when
00:08:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
00:09:35 <Veinor> ah
00:13:36 <Schalken> Is there such as a thing as the identity monad? Something like "data ID x = ID x" with a trivial Monad instance?
00:13:43 <kmc> yes
00:13:44 * Trollzilla lets out a loud fart in the chanel
00:14:06 <kmc> Schalken, http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Identity.html
00:14:07 <Schalken> kmc: What is it and how do I get access to it?
00:17:10 <Schalken> kmc: Ah, that's it. Cheers.
00:20:16 <Veinor> @pl \r -> let a = f a r in a
00:20:17 <lambdabot> fix . flip f
00:22:26 <dibblego> is there a pure haskell HTTP client library?
00:26:51 <Gracenotes> doesn't HTTP qualify?
00:27:18 <dibblego> yeah just found it
00:35:19 <Veinor> ... so what exactly does withSocketsDo do?
00:38:27 <Veinor> the source says it's equal to id
00:38:49 <Cale> Veinor: Nothing on Linux, does stuff to initialise/uninitialise the sockets system on Windows.
00:39:09 <Veinor> ah
00:39:18 <Veinor> I'm curious as to what those things are
00:43:15 <Cale> withSocketsDo :: IO a -> IO a
00:43:15 <Cale> #if !defined(WITH_WINSOCK)
00:43:15 <Cale> withSocketsDo x = x
00:43:15 <Cale> #else
00:43:15 <Cale> withSocketsDo act = do
00:43:16 <Cale>     x <- initWinSock
00:43:18 <Cale>     if x /= 0
00:43:20 <Cale>        then ioError (userError "Failed to initialise WinSock")
00:43:22 <Cale>        else act `finally` shutdownWinSock
00:44:14 <Veinor> how illuminating :D
00:44:20 <Veinor> also, where'd you get that?
00:44:24 <Cale> initWinSock and shutdownWinSock are direct foreign imports
00:44:39 <Cale> http://hackage.haskell.org/packages/archive/network/2.2.1.7/network-2.2.1.7.tar.gz
00:44:40 <kmc> miscellaneous windows-related bullshit.  pay it no mind
00:44:49 <Cale> Network/Socket/Internal.hsc
00:44:54 <Veinor> ahh.
00:47:40 * hackagebot weighted-regexp 0.1.1.0 - Weighted Regular Expression Matcher  http://hackage.haskell.org/package/weighted-regexp-0.1.1.0 (SebastianFischer)
00:49:41 * hackagebot snm 0.0.3 - The Simple Nice-Looking Manual Generator.  http://hackage.haskell.org/package/snm-0.0.3 (JohnnyMorrice)
00:50:04 <Cale> Veinor: Oh, I see, there is some additional C code which defines those two things
00:50:18 <Cale> See initWinSock.c
00:52:20 <Cale> But again, it *mostly* consists of calling WSAStartup and WSACleanup appropriately.
00:52:57 <Cale> So all the interesting stuff is inside Windows.
00:55:09 <triyo> Is there a way to setup a file listener to listen for file modifications? I have a Haskell program that should perform some work when a file has been modified. Any suggestions would be great.
00:59:50 <kmc> triyo, mostly a systems question
00:59:57 <kmc> on Linux you can use inotify
01:00:23 <kmc> libfam provides a platform-independent interface to such features
01:00:44 * hackagebot snm 0.0.4 - The Simple Nice-Looking Manual Generator.  http://hackage.haskell.org/package/snm-0.0.4 (JohnnyMorrice)
01:00:53 <kmc> gamin also
01:01:29 <kmc> by "platform independent" i mean "might work on BSD too"
01:01:31 <triyo> kmc: great, thanks. I am looking for a platform agnostic solution.
01:02:22 <kmc> anyway, such libraries can be FFI-called
01:09:12 <adu> hi kmc
01:12:14 <kmc> hi adu
01:12:29 <kmc> how goes?
01:16:25 <adu> good
01:16:43 <adu> busy, hot, humid
01:16:56 <adu> and very Japanese
01:17:06 <ksf> wait.
01:17:22 <ksf> there's americans that are actually _answering_ that question?
01:17:53 <ksf> my experience goes that americans tend to say "how are you?" "thanks, how are you?" "thanks."
01:17:59 <kmc> heh
01:18:02 <adu> no, the usual response is "how are you?" no thanks
01:18:27 <opqdonut> the best is when two people simultaneously say "how are you"
01:18:29 <opqdonut> optimization!
01:18:34 <adu> lol
01:18:48 <ksf> though even germans nowaday reduce the answer to either "good" or "it must".
01:18:53 <kmc> easier just to say "syn" / "syn ack"
01:18:57 <ksf> (as answer to "how goes", that is)
01:19:04 <opqdonut> or just drop the packet
01:19:20 <adu> kmc: how about you?
01:19:30 <kmc> goes well
01:19:34 <adu> error, syn ack timeout 1000ms
01:20:05 <kmc> "it must"?
01:20:15 <adu> kmc: how goes the supersecret ghc project?
01:20:19 <kmc> haha
01:20:30 <kmc> not so secret, i'm talking about it here and on reddit all the time ;P
01:20:34 <adu> oops now everyone knows
01:20:35 <ksf> or "it has to". hard to translate precisely.
01:20:38 <kmc> ;)
01:20:45 <kmc> anyway i have all 14 nofib imaginary programs working now
01:20:52 <kmc> fixed some RTS crashes
01:21:04 <adu> kmc: did i tell you about what i did?
01:21:32 <ksf> as in "my wife's currently being a bitch, my boss is being stupid like ever, yes, I think about that, but actually, I'm quite fine with it".
01:22:05 <adu> i was able to compile a hello world, and i was able to execute it on my Android phone, but instead of printing "Hello world" it printed the contents of config.h
01:22:46 <adu> so far i haven't fixed it
01:23:49 <dolio> I'm not sure I've ever heard anyone answer "thanks" to "how are you?"
01:24:09 <kmc> adu, wow, strange
01:24:15 <kmc> adu, using the stuff i sent you?
01:24:58 <adu> yes, but i wrote my own libffi... just stubs... maybe i should use the real libffi :P
01:26:47 <kmc> ah ok
01:26:51 <kmc> going to bed now, ttyl
01:26:54 <adu> later
01:27:06 <kmc> 'night
01:28:01 <adu> kmc: wait
01:28:12 <mm_freak_> i'm having a very strange and annoying problem with cabal/GHC
01:28:34 <mm_freak_> sometimes packages disappear with no apparent reason
01:29:14 <mm_freak_> i'm certain that i've installed the 'markov-chain' package, and the module is still linked in the documentation, but trying to load it in GHCi suddenly fails
01:29:22 <mm_freak_>     Could not find module `Data.MarkovChain':
01:29:22 <mm_freak_>       it is not a module in the current program, or in any known package.
01:29:43 <mm_freak_> this is not the first time i encountered that
01:30:03 <eevar2> adu: compiling android apps with ghc, or?
01:30:50 <eevar2> s/android apps/android-phone apps
01:32:29 <dcoutts_> mm_freak_: you might get some useful info from: ghc-pkg list markov-chain  or  ghc-pkg check
01:33:59 <mm_freak_> dcoutts_: i've reinstalled it now (it went through without the --reinstall flag)
01:34:23 <mm_freak_> is there any way to rebuild everything using cabal, when you upgrade GHC?
01:34:37 <dcoutts_> mm_freak_: we're working on that, it's not quite ready yet
01:34:46 <mm_freak_> hmm, ok
01:34:47 <mm_freak_> thanks
01:46:44 <_Ray_> How can I understand "The type of binary tree is the fixed point of the recursive equation Tree2 = 1 + Tree2 x Tree2"?
01:47:24 <ksf> + is either, x is a tuple.
01:47:57 <ksf> that is, first translate it to data Tree = Leaf | Node Tree Tree
01:48:56 <_Ray_> But why is it talking about the "fixed point" of that equation?
01:49:00 <ksf> the fixed point just refers to not following the term "Tree" blindly.
01:49:11 <ksf> otherwise, you'd have an infinite type.
01:49:17 <_Ray_> Ah
01:49:28 <_Ray_> So it's basically just notation?
01:49:31 <ksf> ...well, the type is still in a sense infinite, but its representation is not.
01:49:33 <ksf> yes.
01:49:50 <_Ray_> Thanks :)
01:50:07 <dolio> I'm not sure that sentence's phrasing is entirely kosher.
01:50:09 <chrisdone> good old math notation
01:50:15 <chrisdone> someone's gotta invent it
01:50:33 <dolio> You might instead think of a function "F X = 1 + X x X".
01:50:43 <dolio> Then, the solution to that equation is the fixed point of F.
01:50:47 <dolio> In that X = F X.
01:51:00 <dolio> Or, Tree2 = F Tree2.
01:52:23 <ksf> there are many truths out there which don't increase your understanding a bit.
01:52:43 <Ke> calling that an equation or fixed point seems blasphemy to me
01:53:23 <dolio> Although technically, when you're working with Haskell-like types, it's a fixed point only in the sense than X is isomorphic to F X.
01:53:26 <Ke> eg X = X + Y = Y forall X,Y
01:53:34 <Ke> not transitive
01:53:59 <Cale> Ke: hm?
01:54:13 <ksf> pointless use of formalisms.
01:54:24 <opqdonut> itym pointfree
01:54:25 <opqdonut> ;)
01:54:31 <Ke> !
01:54:41 <ksf> YES IT IS POINTLESS.
01:54:48 <Cale> ksf: What's pointless?
01:55:02 <ksf> I don't care about the formal definition when I don't intend to analyse it formally.
01:55:16 * _Ray_ is reading about using type differentiation in the concept of zippers, and "one hole contexts". Interesting stuff.
01:56:05 <ksf> blindly stuffing everything into math formulas is like saying "let's translate it to latin, that makes everything clearer".
01:56:27 <ksf> it just won't. that's academic self-delusion.
01:56:32 <Cale> _Ray_: In any case, "fixed point of the equation" is a bit of an abuse of terminology. It should be "solution to the equation" or "fixed point of the function F Tree2 = 1 + Tree2 x Tree 2
01:56:47 <Cale> (up to isomorphism)"
01:58:52 <ksf> especially in CS, that is. virtually everybody reading those papers is perfectly capable of understanding that definition written in any concrete pl syntax, _except_ the plain mathematical definition.
01:58:53 <ksf> how comes?
01:59:21 <adu> eevar2: yes
01:59:38 <adu> eevar2: but I'm starting with command-line apps
02:00:12 <ksf> you can say "an automaton is a 5-tuple \sigma, whatever, whatever", or you can say "we can view an automaton as a struct with the fields... and then give plain, readable, ascii names.
02:00:27 <ksf> no loss of generality, a lot gain in clarity.
02:02:40 <ksf> in fact, the second formulation is _more_ general, because it doesn't silently imply that an automaton _is_ something, but that one of its formulations looks that-and-that.
02:02:46 <opqdonut> some mathematicians advocate mnemonic identifiers too
02:02:52 <opqdonut> like Center[G] instead of Z(G)
02:03:44 <opqdonut> I guess the problem is that brevity is attractive to the writer
02:03:54 <ksf> (how am I supposed to do product types? my language only comes with tuples...)
02:04:00 <writer> opqdonut: ;)
02:04:05 <ksf> nope.
02:04:16 <ksf> it's attractive to the printer and mailman.
02:04:26 <ksf> less paper to buy or carry.
02:04:44 <opqdonut> i dunno
02:05:01 <opqdonut> once you've written Center[G] three tiems in an equation, Z(G) starts looking really nice
02:05:12 <opqdonut> and besides, the writer doesn't need mnemonics as much as the reader
02:05:19 <opqdonut> the writer is usually pretty immersed when writing
02:05:28 <writer> :D
02:05:35 <ksf> when writing code, I do need good names.
02:05:37 <opqdonut> of course, latex and macros help a lot here
02:05:48 <opqdonut> writer: sorry :)
02:05:52 <opqdonut> anyway, lunch ->
02:06:01 <writer> opqdonut: price to pay for being a writer :p
02:06:09 <ksf> they define clear boundaries of thought, clear destinctions of concern.
02:06:12 <mm_freak_> well, if math wouldn't use so many single-letter names, it wouldn't be that bad
02:06:23 <mm_freak_> but mathematicians love to omit the multiplication operator
02:06:25 <mm_freak_> bad habit
02:07:07 <ksf> well, at least if it's clear what is ommited. in some rings, it's just not immidiately clear what multiplication is.
02:07:32 <mm_freak_> but anyway, whether we express equations symbolically or using natural language, it's a formalism in any case =)
02:07:54 <mm_freak_> and we need formalisms
02:08:04 <ksf> read, for example, the definition of kleene algebras on wikipedia. it takes some thought to identify concatenation and choice.
02:08:39 <ksf> ...and what exactly the identity elements are.
02:10:20 <ksf> in a usual lecture, the lecturer doesn't even give you time to think about it before confusing you with things that build upon some definition.
02:11:00 <ksf> ...lectures are a way to transfer symbols from the lecturer's note into the notes of students, without touching anyone's brain.
02:11:47 <Ke> !
02:14:51 * ksf subvertively points to http://ocw.mit.edu/courses/chemistry/5-95j-teaching-college-level-science-and-engineering-spring-2009/
02:15:26 <ksf> *subversivly
02:16:51 <nominolo> preflex: seen lemmih
02:16:51 <preflex>  lemmih was last seen on #haskell 20 hours, 10 minutes and 53 seconds ago, saying: Phantom_Hoover: As a linked list.
02:18:43 <DamienCassou> hi
02:19:56 <DamienCassou> I have a "Non-exhaustive patterns in function ..." problem. How can I know which pattern misses?
02:20:57 <ksf> in the same way as ghc: look at the definition of your type.
02:21:28 <ksf> care to paste some code?
02:21:30 <ksf> hpaste.org
02:23:15 <DamienCassou> ksf: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28271#a28271
02:23:59 <DamienCassou> ksf: ok, I've just used -fwarn-incomplete-patterns and there is a problem with the TVar matches
02:25:02 <ksf> you're fixing value to be a TNat
02:25:10 <DamienCassou> ksf: thank you !! I just removed the last part which matched TNat
02:25:21 <DamienCassou> in fact, I didn't care about this TNat :-)
02:26:28 <DamienCassou> ksf: is it possible to set the -fwarn-incomplete-patterns option directly in my source file? That way, I can continue to use my shortcuts to compile
02:26:47 <ksf> {-# OPTIONS_GHC -fwarn-incomplete-patterns #-}
02:27:01 <ksf> I think -Wall should include that.
02:27:09 <dolio> Doesn't it?
02:27:19 <ksf> also, running hlint over your source from time to time won't hurt.
02:27:49 <ksf> (and switching to literate mode and turning each module into a paper)
02:28:14 <blackdog> ksf: stop trying to turn perfectly useful programmers into academics
02:28:17 <DamienCassou> how can I include -Wall directly in my file?
02:28:25 <ksf> with OPTIONS_GHC
02:28:47 <ksf> well, I think in the -Wall case it's safte to leave out the _GHC part, every compiler should know about it.
02:29:49 <DamienCassou> what do you mean by "turning each module into a paper"?
02:30:16 <ksf> have you ever read a literate program from knuth?
02:30:24 <fasta> DamienCassou, extensive documentation. 
02:30:49 <DamienCassou> ksf: I haven't
02:31:35 <mm_freak_> > sort (iterate (^2) 2)
02:31:42 <lambdabot>   mueval: ExitFailure 1
02:32:43 <fasta> ksf, there is only a small set of programs where it is useful to do that. 
02:33:20 <ksf> well, the rest is doable with extensive haddocks, yes.
02:33:26 <fasta> (and in most cases a reference to the original algorithm is all that is needed, unless you actually have invented something "new", which is a pretty rare thing to do these days)
02:34:19 <ksf> it all depends upon the chunking used in the interface. if you have small functions it's sufficient to give a description of each function and a high-level module description, if you've got longish algorithms it's useful to go literate.
02:34:56 <mm_freak_> :t \p c -> if p then c else pure ()
02:35:00 <lambdabot> forall (f :: * -> *). (Applicative f) => Bool -> f () -> f ()
02:35:02 <fasta> If you plan for your company to exist longer than 20 years, documentation is key. 
02:36:38 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28272#a28272
02:36:54 <ksf> note that this isn't even polished code
02:37:47 <ksf> ...but each and every comment gives an entry point to the implementation, that is, it documents the abstraction boundaries.
02:37:53 <fasta> ksf, that misses what a "virgin node" is.
02:38:04 <ksf> virgin node?
02:38:16 <fasta> ksf, it probably is a node without edges, but it does not say so.
02:38:32 <fasta> ksf, and it is not standard graph terminology. 
02:39:07 <ksf> oh no, it's a new node that isn't connected _yet_, and might never be connected.
02:39:12 <fasta> ksf, and it seems that this muddles the concept of a graph with a particular implementation. 
02:39:35 <fasta> ksf, but it is a lot better than what I usually see. 
02:40:19 <fasta> Writing code such that another person can understand it is inversely proportional to job security. 
02:40:41 <ksf> depends on company culture.
02:41:02 <ksf> I certainly wouldn't let it slip.
02:41:26 <ksf> what do you mean with muddling the concept of a graph with the implementation?
02:41:42 <Ferdirand> writing code that noone can understand is proportional to the odds of being bugged to no end by your ex-employer long after you've left for better grounds
02:41:56 <fasta> ksf, it seems that you write your algorithms against a particular map, not a graph type. 
02:42:35 <ksf> well, that's for lookup efficiency.
02:42:49 <fasta> ksf, that means Haskell is broken if you need to do that.
02:42:57 <fasta> ksf, or rather its compilers.
02:43:17 <ksf> it just means that fgl doesn't optimise lookup in the way I'd like it to.
02:43:32 <fasta> ksf, ah, fgl, talk no more. 
02:43:43 <ksf> I failed to point out what C and D actually represent, that's true.
02:43:52 <fasta> I still don't understand why people even use that.
02:44:09 <fasta> FGL was an academic hack with no relation at all to efficient code.
02:44:17 <ksf> it's more convinient than rolling your own graph type.
02:44:22 <fasta> (efficient code is what CS is supposed to be about save for constant factors)
02:44:40 <fasta> Well, even constant factors are important, as are additive constants.
02:45:45 <fasta> Publishing a paper about how to do something less efficiently should be forbidden by law ;)
02:46:00 <ksf> well, graph performance isn't my primary concern, it's part of a compiler, after all.
02:46:27 <ksf> and writing fast code is magnitudes easier if you have a working reference implementation.
02:47:00 <ksf> ...only in the rarest of cases, and with very well understood algorithms one can start out with the optimal implementation.
02:47:13 <ksf> A* over a regular grid comes to mind.
02:47:35 <ksf> (every programmer should have read amits A* pages)
02:48:50 <DamienCassou> ksf: what are "amits A* pages" ?
02:49:09 <fasta> ksf, what is so special about his A* pages?
02:49:14 <ksf> http://www.reddit.com/r/coding/comments/cu5mx/implementing_an_algorithm_optimally_by_example/
02:50:06 <fasta> ksf, yes, I have seen his page, but I don't see anything I hadn't heard about yet or is a trivial extension of A*.
02:50:35 <ksf> http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html
02:50:41 <ksf> that's the key thing I'm referring to
02:51:24 <ksf> many, many programmers just don't know how to figure out what data structures to use for an algorithm, and he gives a very good description of that process, by example.
02:51:35 <fasta> ksf, without benchmark results it is not really interesting for me at least. 
02:51:49 <fasta> ksf, all of that stuff is part of a CS curriculum. 
02:51:58 <ksf> ha!
02:52:29 <ksf> I've implemented the stock A* for elkware, which was the third implementation of it and was subsequently used in every case.
02:53:08 <ksf> the runtimes went down by a factor of 2000 from the initial implementation by a graduate.
02:53:24 <fasta> ksf, not all CS programs are created equal. 
02:54:09 <fasta> ksf, and if you take into account caches and switch to another programming language (e.g. from Python to C++) you can get those kinds of numbers.
02:54:15 <ksf> hell even a dumb dijkstra would have been faster than the bs that guy did. yes, A* has a better common-case complexity, but if you implement everything with darned linked lists...
02:54:36 <ksf> java/j2me
02:55:10 <fasta> ksf, I also optimized something by a factor of 45000 on relatively large inputs here. More like 500 for realistic inputs. Not really an achievement. 
02:55:37 <fasta> ksf, that is, AFAIK, everyone should be able to do that. 
02:55:42 <ksf> it's an improvement to calculate a path in sub-frame time instead of coding up a waiting screen...
02:55:46 <m3ga> if i have a darcs repo on community.haskell.org that i access via ssh, how do i work out what the http address is?
02:56:24 <ksf> well, I had the advantage that I needed an implementation that was suitable for an RTS, he needed it as a minor graphical detail in port royale.
02:56:36 <ksf> the other one needed it for the ai in the fall.
02:56:51 <aleator> Is it normal to have large efficiency issues with typeclasses?
02:57:02 <ksf> ...which wasn't that time critical, but still not unimportant run-time wise.
02:58:14 * ksf still doesn't get how some people manage to write a program that works without actually understanding both the problem and their solution.
02:58:39 <fasta> aleator, not large, and if the compiler is good, there should be none.
02:58:53 <fasta> aleator, GHC isn't optimal, AFAIK. 
02:59:06 <ksf> ...with our without monomorphism restriction?
02:59:42 <aleator> fasta: I get something like 50% hit when I wrap my rng calls in a class..
02:59:53 <aleator> fasta: using 6.10.4
03:00:08 <fasta> aleator, you should always try to use the latest stable. 
03:00:32 <fasta> aleator, and if you can reproduce this in a small test case, report it.
03:01:03 <aleator> Ok, I'll pick a newer ghc and try again. 
03:01:37 <fasta> aleator, it all the types are known at compile time, the overhead should be zero.
03:01:51 <fasta> aleator, that is, there are no class dictionaries anymore. 
03:02:43 <fasta> For certain relatively complicated types this cannot be done in general, but for a small number of types even in this case it could be optimized. 
03:04:02 <aleator> fasta: If the overhead is there and everything is relatively simple, what can be done?
03:04:49 <aleator> fasta: The overhead appears in a separate "generic" module defined by the tc that gets used by the main
03:05:45 <fasta> aleator, if it depends on whether or not you call something in a different module it has nothing to do with classes.
03:07:29 <aleator> fasta: It works without classes though..
03:07:45 <fasta> aleator, then report a bug for the compiler. 
03:08:23 <fasta> aleator, if you can know exactly which instance is going to be called, then a compiler should be able to do the same.
03:08:59 <zachk> @pl (\x->x^2+x) 
03:09:00 <lambdabot> (+) =<< (^ 2)
03:09:10 <RyanT5000> is there a way to dynamically add an SCC to the stack?
03:09:14 <aleator> fasta: Ok. I'll try and see if it still happens with newer ghc
03:09:50 <zachk> > (+) =<< (^2) $ 5 
03:09:52 <lambdabot>   30
03:24:01 <h_noob> hello fellows
03:24:41 <h_noob> I have to admit - I failed in googling this basic question: how do I use both Text.ParserCombinators.Parsec and Text.PrettyPrint.HughesPJ?
03:24:50 <h_noob> I got Ambiguous occurrence `char' message
03:25:13 <ivanm> h_noob: either qualify one of them or use them in different modules
03:25:53 <h_noob> ivanm: you mean to add "qualified" keyword after import? where do I read more about it?
03:26:10 <ivanm> a haskell tutorial?
03:26:17 <ivanm> @google haskell qualified import
03:26:18 <lambdabot> http://www.haskell.org/onlinereport/modules.html
03:26:18 <lambdabot> Title: The Haskell 98 Report: Modules
03:26:30 <ivanm> heh, well, that will definitely talk about it
03:26:38 <h_noob> thanks
03:26:44 <ivanm> IIRC RWH talks about it, and I assume LYAH does as well
03:26:53 <ivanm> see also the documentation for Data.Set and Data.Map
03:36:50 <DamienCassou> when I activate -fwarn-incomplete-patterns, I get warnings for patterns that I know won't happen. Unfortunately, ghc doesn't know they won't happen. I can't return any value for these cases. Is there a simple way to make the warn-incomplete-patterns shut-up?
03:38:04 <ivanm> well, you can have -fno-warn-incomplete-patterns
03:38:19 <ivanm> DamienCassou: and I wouldn't guarantee that you'll have patterns that wont' happen
03:38:22 <profmakx> bad style?
03:38:40 <ivanm> I've had situations where I thought "this will never happen so I can ignore it" and down the track have to work out wtf the bug is
03:38:57 <benmachine> DamienCassou: you can always just make your last pattern lazy
03:38:58 <ivanm> much better off havign something like: foo _ = error "Module.Name.foo: this shouldn't happen!!!"
03:39:06 <ivanm> so you at least know where the error is coming from
03:39:17 <DamienCassou> I would like to activate this warning to make my code clean. But sometimes, I just can't do anything for a particular pattern because it should not happen. Maybe an exception?
03:40:05 <benmachine> > case compare 1 2 of GT -> True; ~LT -> False -- wouldn't lead to a warning
03:40:06 <lambdabot>   False
03:40:10 <ivanm> well, an error, like I said
03:40:26 <ivanm> benmachine: that's a rather nasty hack IMHO
03:40:30 <DamienCassou> ivanm: an error looks perfect, thank you
03:40:41 <benmachine> ivanm: maaaaybe
03:40:43 <ivanm> better off having an explicit catch-all error so you at least know where the problem is coming from
03:40:52 <benmachine> that is better yes
03:41:08 <benmachine> > case [] of ~(x:xs) -> x
03:41:10 <lambdabot>   *Exception: <interactive>:1:133-155: Irrefutable pattern failed for pattern...
03:41:18 <benmachine> ^ you do actually get a source location anyway
03:41:30 <benmachine> so it's not that bad
03:41:33 <ivanm> true
03:41:49 <ivanm> but still, better off making it explicit
03:41:50 <benmachine> yes
03:42:03 <benmachine> one should be aware of all the options :P
03:42:17 * ivanm just became severely dissapointed/disillusioned when reading oleg's latest email to -cafe
03:42:31 <benmachine> aw, why?
03:43:47 <handonson> I have list of functions [A -> B] and a value whose type is A. Is there a library function with which I can generate a new list [B] that is the result of applying each function in [A -> B] against the value A?
03:43:50 <ivanm> in container-classes, I had written something like "class CFunctor c a where map :: (CFunctor c b) => (a -> b) -> c a -> c b"
03:44:03 <ivanm> in his email, he defined something similar but had "class Functor' c a b"
03:44:17 <ivanm> and I thought that was weird, and went to check that mine worked with Data.Set...
03:44:19 <ivanm> and it didn't :(
03:44:31 <benmachine> why not?
03:44:35 <ivanm> the map definition for Sets required an explicit Ord instance for b
03:44:56 <benmachine> doesn't CFunctor Set b imply Ord b?
03:44:57 <ivanm> it can't just automatically pick that up from the fact that it has to be a CFunctor instance, and only Ord ones are instances
03:44:58 <zygoloid> ivanm: huh, that sucks :(
03:45:05 <benmachine> ah, true
03:45:26 <handonson> oh, I can use list comprehension.
03:45:40 <ivanm> handonson: even better
03:45:41 <benmachine> handonson: that's one way
03:45:43 <zygoloid> handonson: map ($x) fs
03:45:47 <ivanm> > map ($2) [(^2), succ]
03:45:49 <lambdabot>   [4,3]
03:46:08 <benmachine> ($ 2) to not confuse template haskell :P
03:46:12 <handonson> you can use $ that way!
03:46:23 <zygoloid> handonson: absolutely :) it's a great trick
03:46:25 <handonson> never thought of it.
03:46:30 <handonson> awesome.
03:49:41 <zygoloid> ivanm: i'm not sure why your CFunctor Set didn't work. how were you writing the instance?
03:50:21 <ivanm> zygoloid: instance (Ord a) => CFunctor Set a where map = Set.map
03:50:32 <ivanm> but ghci says it can't tell that b is Ord
03:51:17 <zygoloid> oh! S.map is broken.
03:51:20 <zygoloid> @type S.fromList . map ?f . S.toList
03:51:21 <lambdabot> forall a a1. (Ord a, ?f::a1 -> a) => S.Set a1 -> S.Set a
03:51:24 <zygoloid> ^^ that's the right type.
03:51:26 <zygoloid> @type S.map
03:51:27 <lambdabot> forall a b. (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
03:51:34 <zygoloid> ^^ that has an unnecessary Ord a constraint.
03:51:39 <benmachine> interesting
03:51:55 <ivanm> zygoloid: except it's the b bit that ghci is bitching about
03:52:10 <ivanm> still, why is that "Ord a" constraint unnecessary?
03:52:19 <zygoloid> ivanm: surely not. your Ord b => CFunctor Set b provides the Ord b constraint
03:52:33 <zygoloid> (the second type parameter of CFunctor is the result type not the argument type)
03:52:36 <benmachine> :t S.toList -- no Ord here
03:52:38 <lambdabot> forall a. S.Set a -> [a]
03:52:40 <dolio> ivanm: Because it's just reading things out of an already formed set.
03:52:47 <dolio> You don't need Ord for that.
03:53:08 <ivanm> zygoloid: *shrug* my guess is that the typechecker is looking for an explicit instance for b; it can't tell that all Ord values are instances
03:53:10 <ivanm> dolio: true
03:53:18 <benmachine> :t Data.Foldable.toList
03:53:19 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
03:53:22 <opqdonut> ivanm: that sounds about right
03:53:32 <ivanm> still, having the constraint there on the a shouldn't hurt
03:53:37 <zygoloid> ivanm: there's an Ord b instance carried by the Ord CFunctor Set b instance
03:53:47 <zygoloid> s/Ord CFunctor/CFunctor/
03:53:49 <dolio> It's not the main problem, certainly.
03:54:03 <ivanm> zygoloid: except it can't tell that when it's only looking in the "Set a" instance
03:54:20 <zygoloid> ivanm: huh?
03:54:32 <Heffalump> ivanm: what are you actually trying to do?
03:55:09 <ivanm> Heffalump: something similar to your RFunctor class but without using an external type family instance like you do
03:55:44 <ivanm> zygoloid: within the "instance (Ord a) => CFunctor Set a ...", how can it tell that "CFunctor Set b" is only valid for `b'?
03:55:55 <ivanm> (I mean, it _should_ be able to tell that, but it looks like it can't)
03:55:56 <zygoloid> ivanm: this works: "instance Ord b => CFunctor S.Set b where fmap' f = S.fromList . map f . S.toList"
03:56:00 <dolio> zygoloid: I believe the issue is that 'instance C a => D a' does not give you access to 'C a' given a constraint of 'D a'.
03:56:21 <dolio> zygoloid: Only when 'class C a => D a' is declared does that work.
03:56:22 <zygoloid> dolio: it does /within the instance's members/.
03:56:31 <zygoloid> and that's all that ivanm needs
03:56:57 <ivanm> zygoloid: except I don't want that
03:57:21 <zygoloid> ivanm: ok, i think i've fundamentally misunderstood something then :)
03:57:31 <dolio> Constraints on instances are used to simpilify contexts. So given that instance 'D a => ...' reduces to 'C a => ...'.
03:57:32 <ivanm> sure, that will work for that one specific instance
03:57:48 <ivanm> but it won't work for other times when I need something like that
03:58:10 <ivanm> e.g.: sequence :: (Monad m, CFunctor c a, CFunctor c (m a)) => c (m a) -> m (c a)
03:58:31 <ivanm> actually, a better example: mapM   :: (Monad m, CFunctor c a, CFunctor c b) => (a -> m b) -> c a -> m (c b)
03:58:40 <ivanm> (it might work there though)
03:59:33 <handonson> Prelude> catch (error "!") (\ e -> putStrLn "caught")
03:59:33 <handonson> *** Exception: !
03:59:44 <handonson> Am I misunderstanding the usage of catch?
04:00:10 <ivanm> @hoogle catch
04:00:10 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
04:00:10 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
04:00:10 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
04:00:14 <Monaliza> hii
04:00:19 <zygoloid> ivanm: i'm confused. are you trying to make a CTraversable too?
04:00:26 <ivanm> handonson: you have to use IOError or something for errors
04:00:27 <Monaliza> hiiiiiiiiiiiiiii
04:00:34 <ivanm> since they're usually used to indicate something completely broken
04:00:40 * ivanm waves idly in Monaliza's general direction
04:00:45 <ivanm> zygoloid: eventually, yes
04:01:03 <Monaliza> any one knows how to do CHAT in a website??????????????????????????????????????
04:01:07 <ivanm> I was just trying to keep it to as few classes as possible, but that doesn't seem to be soemthing that'll work
04:01:14 <zygoloid> ivanm: ok, well that sounds like a more interesting problem :)
04:01:17 <ivanm> Monaliza: do you realise what this channel is for?
04:01:43 <ivanm> zygoloid: and sure, your CFunctor instance for Set hack would work... but would require me to re-define CFunctor, and it might not work in the more general case
04:01:49 <Monaliza> ivanm: yes! computer help :) isn't it??
04:02:06 <zygoloid> ivanm: why do you need to redefine CFunctor?
04:02:26 <ivanm> Monaliza: no
04:02:29 <h_noob> I'm pretty lost in all the pretty-printers available - what would be easiest way to print heavily nested tuple of lists and tuples?
04:02:30 <zygoloid> Monaliza: no, this channel is for discussing the programming language called Haskell.
04:02:33 <ivanm> Monaliza: this is about the functional programming language Haskell
04:02:44 <Monaliza> :O
04:02:46 <ivanm> h_noob: write your own Pretty class
04:02:54 <Monaliza> oops!!
04:02:56 <ivanm> IIRC, there already is one on Hackage if you just wanted to steal it
04:02:56 <zygoloid> h_noob: the easiest way would be to just use 'show' ;-)
04:02:58 <Monaliza> :) thx guys!
04:03:15 <zygoloid> h_noob: but i guess you want something prettier than that
04:03:16 <Monaliza> I didn't know :D
04:03:19 <Monaliza> bye
04:03:31 <ivanm> good riddance...
04:03:40 <Heffalump> that had to be a troll...
04:03:46 <zygoloid> e was pleasant for a lost soul
04:03:53 <h_noob> zygoloid: you mean just "print x"?
04:03:55 <ivanm> I dunno, seemed too dumb to be a troll
04:04:02 <h_noob> zygoloid: hardly pretty :)
04:04:11 <ivanm> not a registered nick, anyway
04:05:02 <h_noob> ivanm: am I really the first who actually wanted to print nested structures? I can't believ there is no easier way :)
04:05:12 <zygoloid> hmm, is the HughesPJ pretty-printer in base?
04:05:30 <ivanm> h_noob: what do you mean?
04:05:36 <ivanm> zygoloid: no, but it comes with GHC
04:05:39 <ivanm> it's in the pretty library
04:06:05 <ivanm> h_noob: see also the json library, and the bit about how to write a json library in RWH
04:06:15 <ivanm> they develop their own pretty-printer just for json
04:07:04 <handonson> can I write an exception handler that catches all exceptions regardless of the exception type?
04:07:08 <h_noob> ivanm: I read a bit in rwh about writing pretty-printer... as far as I understood they recommend to use HughesPJ as a pretty-printer instead writing my own
04:07:42 <h_noob> ivanm: the thing is - I do not see how to use HughesPJ to pretty-print nested tuple with lists and tuples for example
04:07:56 <ivanm> h_noob: I really don't get what your problem is
04:08:19 <ivanm> you want to pretty print something like: ('a', [1,2], [(1,2), (3,4)]) ?
04:08:31 <ivanm> write a pretty printing class
04:08:59 <h_noob> ivanm: yepp you got it right
04:09:05 <ivanm> for example, for a 2-tuple: instance (Pretty a, Pretty b) => Pretty (a,b) where pretty = bracket $ pretty a <> comma <> pretty b
04:09:11 <ivanm> (or whatever the syntax is)
04:10:01 <h_noob> ivanm: this is fine but I do not know my syntax in advance - it's a result of parsec so I do not even know how nested is it
04:10:20 <ivanm> doesn't matter
04:10:31 <ivanm> write a class, write instances for that class
04:11:23 <h_noob> ivanm: what should I read to get it - is there some common documentation I overlooked?
04:11:35 <ivanm> for what?
04:12:16 <h_noob> ivanm: for writing pretty-printer class to print structures with unknown syntax? :)
04:12:16 <Benny_> 07:06 < handonson> can I write an exception handler that catches all exceptions  regardless of the exception type?
04:12:20 <Benny_> Yes
04:12:29 <handonson> how?
04:12:32 * zachk ghc 6.12.3 is still compiling -_- 
04:12:33 <Benny_> Just a moment
04:12:56 <ivanm> Benny_: please don't suggest SomeException
04:13:02 <ivanm> it's an evil, evil hack that shouldn't be used
04:13:03 <Benny_> Why not?
04:13:08 <ivanm> h_noob: you write a class...
04:13:09 <Benny_> It's the only way to do it :P
04:13:19 <ivanm> Benny_: because it will even catch Ctrl-C
04:13:50 <Benny_> Well, it's not my fault Haskell's exceptions are... exceptionally ridiculous
04:13:53 <handonson> oh that's not a concern
04:14:02 <handonson> at least for me
04:14:08 <ivanm> Benny_: how is that ridiculous?
04:14:10 <Benny_> I didn't know that, since I'm using it in a GUI application
04:14:13 <ivanm> handonson: still, the point is you don't
04:14:21 <ivanm> you catch specific exceptions and do something specific with them
04:14:27 <ivanm> you don't do a catch-all case
04:14:35 <ivanm> h_noob: seen how I define such a class here: http://hackage.haskell.org/packages/archive/graphviz/2999.10.0.1/doc/html/src/Data-GraphViz-Printing.html
04:14:40 <Benny_> That would be great if there weren't 43809240 different exception types
04:15:03 <handonson> ROFL
04:15:24 <ivanm> h_noob: note that you won't need as many class methods; I just need to be able to deal with quoting differently from non-quoting, and sometimes use special instances for lists
04:15:26 <zachk> Benny_, is that an exact figure ? 
04:15:29 <ivanm> Benny_: except... there aren't
04:15:32 <ivanm> zachk: hell no
04:15:40 <ivanm> Benny_: you can always use Control.OldException if you wish
04:16:11 <h_noob> ivanm: thanks, I'll dig into it
04:16:26 <zygoloid> one issue with catching all exceptions is that there's no upper bound on how long it takes to catch a NonTermination ;-)
04:16:29 <ivanm> as I said, RWH defines such a class for json as well
04:16:40 <ivanm> the fact that they use their own pretty printer to do so is irrelevant
04:17:20 <handonson> i execute a plugin function that should just give me the error information when it fails to do something, instead of terminating the thread/process
04:17:24 <Benny_> So how do I catch one of, say, five exceptions
04:17:36 <zygoloid> @hoogle catches
04:17:36 <lambdabot> Control.Exception catches :: IO a -> [Handler a] -> IO a
04:17:51 <Benny_> In the prayer that I've enumerated all the ones that might possibly be thrown
04:18:28 <Benny_> Also, I should specify that I'm catching all exceptions then printing them out to the user to report to me
04:19:03 <ivanm> Benny_: you have five different catch statements
04:19:08 <Benny_> That's ridiculous
04:19:19 <ivanm> or else define your own custom exception type which is a sum type of one of the five you want to catch
04:19:31 <handonson> If SomeException is not supposed to be used, why does it even exist in the standard library?
04:19:47 <Benny_> Or just use SomeException, which is equivalent to doing that for all intents and purposes?
04:20:01 <Heffalump> handonson: because there are situations where you would need it
04:20:09 <Heffalump> it's just that you need to be careful
04:20:15 <Benny_> Except better, because it'll catch undocumented exceptions as well
04:20:19 <Heffalump> like unsafePerformIO
04:20:57 <McManiaC> "error" will always result in an IOException?
04:20:59 <Benny_> Because nothing is worse than having the entire application bomb out on the user without any idea what just happened, just because some function throws an error that it's not documented to throw
04:21:11 <handonson> McManiaC: I doubt
04:21:35 <handonson> <handonson> Prelude> catch (error "!") (\ e -> putStrLn "caught")
04:21:36 <handonson> <handonson> *** Exception: !
04:21:52 <handonson> note that Prelude.catch is supposed to catch IOExceptions
04:22:33 <handonson> Prelude> catch (ioError $ userError "!") (\ e -> putStrLn "caught")
04:22:33 <handonson> caught
04:23:27 <handonson> By the way, what exception does ^C throw? IOException?
04:23:28 <McManiaC> what kind of exception is error then?
04:24:11 <ivanm> McManiaC: you have to use Control.IOException or something IIRC
04:24:15 <ivanm> (to catch error)
04:24:33 <ivanm> handonson: I believe so, yes
04:24:49 <handonson> where is Control.IOException
04:25:16 <McManiaC> > Control.Exception.catch (error "!") (let f :: ErrorCall -> IO (); f = print in f)
04:25:17 <lambdabot>   Not in scope: `Control.Exception.catch'Not in scope: type constructor or cl...
04:25:22 <McManiaC> hmkay
04:25:43 <McManiaC> > catch (error "!") (let f :: ErrorCall -> IO (); f = show in f)
04:25:44 <lambdabot>   Not in scope: type constructor or class `ErrorCall'
04:25:47 <McManiaC> hm
04:25:47 <McManiaC> ^^
04:26:47 <ivanm> handonson: System.IO.Error I mean
04:27:17 <handonson> Control.Exception.ErrorCall
04:28:17 <ivanm> huh?
04:28:20 <ivanm> that's not in base...
04:28:32 <ivanm> oh, wait, that's the data type, not the module...
04:28:43 <handonson> yup
04:28:44 <ivanm> McManiaC: print, not show
04:28:48 <ivanm> you want IO
04:30:53 <zygoloid> Benny_: for what it's worth, i have some code implementing a ghci-style REPL loop, and i catch SomeException there...
04:31:28 <ivanm> zygoloid: because ctrl-c is stopping whatever is running in the REPL?
04:31:43 <McManiaC> ivanm: jup
04:32:13 <McManiaC> which is kinda stupid since a pure function can throw an "error" aswell :S
04:32:52 <zygoloid> ivanm: not just that. because the code in the REPL could throw any sort of exception at all, and i want to catch them all
04:33:13 <zygoloid> i have inner handlers for specific exception types (such as the one produced by exit)
04:33:18 <ivanm> McManiaC: the catching is done in IO as well though
04:33:32 <ivanm> zygoloid: so you do multiple levels of catch?
04:33:42 <ivanm> rather than just one big SomeException?
04:34:01 <Lemmih_> nominolo: pong.
04:34:25 <zygoloid> ivanm: i do multiple levels. the outermost level is a SomeException catch.
04:34:44 <zygoloid> ivanm: actually, i can't really remember and don't have the code with me
04:34:58 <zygoloid> ivanm: but the intent is: catch some specific things, then use a catchall for everything else
04:36:01 <handonson> What exception does (read "asdf" :: Int) throw?
04:36:27 <ivanm> zygoloid: that's different from just doing a one big catch-all though
04:36:36 <ivanm> which is what I was advocating against
04:36:41 <ivanm> > read "asdf" :: Int
04:36:42 <lambdabot>   *Exception: Prelude.read: no parse
04:36:47 <ivanm> handonson: ^^ an error
04:36:54 <handonson> no i mean
04:36:55 <handonson> the type
04:36:57 <ivanm> handonson: anything pure uses error to denote pleasure
04:37:06 <handonson> Control.Exception.ErrorCall?
04:37:15 <ivanm> if that's what used for error, then yes
04:42:52 <pp__> wtf???
04:51:59 <nominolo> Lemmih: I was wondering how lhc deals with multiple modules
04:52:00 <CakeProphet> > "test"
04:52:00 <lambdabot>   "test"
04:52:28 <nominolo> Lemmih: in particular multiple packages
04:52:44 <zachk2> @src ap 
04:52:45 <lambdabot> Source not found. You speak an infinite deal of nothing
04:53:21 <nominolo> Lemmih: I saw that you're somehow using ghc-pkg, but how do you get to the sources / lhc interface files for such packages?
05:00:36 <Lemmih> nominolo: The compiled libraries are saved in ~/.lhc/packages/
05:03:26 <Lemmih> nominolo: Cabal basically installs the libraries twice; Once for GHC and once for LHC.
05:03:39 <nominolo> Lemmih: so you use your custom package.conf managed by ghc-pkg and then look into .lhc/packages to find the binaries?
05:05:01 <Lemmih> nominolo: The compiled modules are placed in .lhc/packages. All we do is follow the dependencies from the Main module.
05:06:07 <zachk2> > (+) =<< (^2) $ 5 --now how do i get this to work in ghci :-/ 
05:06:09 <lambdabot>   30
05:06:36 <Lemmih> zachk2: :m Control.Monad.Instances
05:06:59 <zachk2> sweet
05:07:06 <zachk2> whats that module do? let me do that? 
05:07:34 <luite> it contains the instance for the (->) e monad
05:08:36 <zachk2> lets me use regular functions as monads? 
05:17:15 <nominolo> Lemmih: are you reusing Ghc's Id/Var type or do you use your own?
05:17:22 <Gracenotes> zachk2: yes. however, most of the time I never have to import it, because it's imported from some other module somewhere
05:17:59 <zachk2> Gracenotes: what modules do you usually import? 
05:18:14 <nominolo> Lemmih: I.e., if GHC's core has a reference to foo:Bar.baz you have to look up its code from .lhc/packages/foo/Bar.bytecode (or sth. like that)
05:18:49 <Gracenotes> a wide variety of them. but chances are, at least one of them somewhere down the import line also imports Control.Monad.Instances, and that's good enough for GHC
05:19:39 <Gracenotes> e.g. if you import Control.Applicative, you can get applicative combinators and monad instances in one go
05:21:22 <Phyx-> @ping
05:21:22 <lambdabot> pong
05:25:27 <IceDane> Wow.. Looking at some code I wrote a while back. I'm replicating so much built in functinoality
05:25:33 <IceDane> like maybe, either, fromMaybe etc
05:25:47 <dafis> IceDane: that's normal in the first few months
05:26:30 <IceDane> dafis: Aye
05:26:53 <dafis> you have to worry if you still do it after several years :)
05:27:24 <IceDane> I wish I could fast-forward time in that respect
05:27:31 <IceDane> fast-forward my haskell fu
05:27:44 <dafis> as if time didn't pass fast enough already
05:28:09 <adu> IceDane: one way to ff your hs-fu is by forgetting java
05:28:22 <IceDane> adu: I forgot to learn java. Does that count?
05:28:34 <dafis> IceDane: not a bad start
05:28:41 <adu> IceDane: yes, you on the path, young grasshopper
05:28:49 <IceDane> thank you sensei
05:28:51 <Lemmih> nominolo: We rename the code when translating it into GRIN.
05:29:17 <Lemmih> nominolo: #lhc-compiler is a great place for such questions (:
05:30:02 <p00ya> when i first learnt haskell i was told pattern matching was superior to guards and if-then-else. is this still good advice?
05:30:26 <hpc> if-then-else is never a good idea, imo
05:30:30 <dafis> p00ya: within bounds
05:30:40 <dino-> p00ya: Sometimes you need guards though. They work together, patterns and guards.
05:30:41 <dafis> hpc: not ever?
05:31:02 <hpc> if-then-else is sugar for a two-case guard
05:31:11 <hpc> which i think is more idomatic
05:31:22 <p00ya> i have this:
05:31:23 <p00ya> label (Trie _ s _ _ _) = s
05:31:23 <p00ya> isRoot = null . label
05:31:42 <adu> p00ya: i generally prefer cases over pattern matching, but i do use lots of pattern matching in my cases
05:31:42 <p00ya> and there are a few places where i'm matching (Trie _ [] _ _ _)
05:31:56 <p00ya> and i'd like to replace that with a guard or if-then-else using isRoot
05:32:17 <p00ya> just wondering what the possible consequences are
05:32:25 <p00ya> e.g. for laziness or whatever
05:32:26 <adu> pattern matching in functions requires the less-than-perfect repetition of the function-name each time
05:32:41 <adu> cases just need -> each time
05:33:16 <zachk2> is there something like case pattern matching but more like guards? 
05:33:24 <p00ya> adu: a case doesn't really escape the ugliness for me
05:33:25 <dafis> p00ya: wrt laziness, there's no difference
05:33:30 <adu> zachk: i think theres something in Haskell2010 about that
05:33:50 <nominolo> zachk2: you mean PatternGuards?
05:34:09 <zachk2> the stuff in function definitions with | and otherwise 
05:35:06 <dafis> zachk2: case ex of { pat1 | cond11 -> alt11; | cond12 -> alt12; pat2 | cond21 -> alt21; | cond22 -> alt22 } ?
05:35:33 <nominolo> zachk2: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#pattern-guards
05:36:03 <dino-> To do that I would just impl the function twice (for each pattern) and in each of those use regular guards.
05:36:48 <dino-> But I don't mind the less-than-perfect repetition. :)
05:37:34 <dafis> dino-: when you're defining a function, sure; but case-with-guards is nice e.g. in do-blocks
05:37:59 <dino-> dafis: Can use let or where and a helper function perhaps for that.
05:38:51 <dino-> This starts me thinking "is this function getting too long? Can it be split up more?" :)
05:38:51 <zachk2> so i just need to include the right extension to get pattern guards working? 
05:39:06 <Gracenotes> well with GHC nowadays you can use it without a warning
05:39:18 <Gracenotes> I mean, without an explicit extension. but you get a warning.
05:39:24 <dafis> dino-: not the right question in a tight loop :)
05:39:40 <Gracenotes> but they're going to become part of standard Haskell. or already are. I'm not sure.
05:42:07 <jem777> when already discussing syntactic sugar: is it common to use the do-notation?
05:42:21 <jem777> i always avoid it
05:42:40 <hpc> do notation is quite common
05:43:03 <hpc> i generally try to use >>= when the desugar is trivial
05:43:55 <arw> many use bind when it doesn't get longer than a line or so.
05:44:24 <hpc> there are so many large useful monadic actions that it is nearly impossible to avoid
05:44:37 <arw> but you can easily write code which is even more unreadable than bad perl that way.
05:44:58 * dafis objects
05:44:59 <IceDane> *shiver*
05:45:01 <jem777> in which cases?
05:45:03 <IceDane> @ bad perl
05:45:20 <hpc> "bad perl" methinks you have an extra word in that sentence
05:45:34 <dafis> more unreadable than bad perl, can only be C++, Brainfuck, Intercal, ...
05:45:36 <dino-> arw: absolutely action1 >>= \(x, y) -> action2 >>= \z -> action3 y >> action4 z x
05:45:43 <dino-> bleh!
05:46:28 <IceDane> dino-: The RWH guy does that a lot
05:46:28 <dafis> dino-: if you cram it on one line, it's bad, if you use layout, it's so-so
05:46:32 <IceDane> he calls it 'hanging lambdas'
05:46:40 <IceDane> But he does 'layout' it as dafis mentioned
05:46:55 <hpc> @pl ?f >>= \(x, y) -> ?g >>= \z -> ?h y >> ?i z x
05:46:56 <lambdabot> (line 1, column 1):
05:46:56 <lambdabot> unexpected "?"
05:46:56 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:47:47 <hpc> :t f
05:47:48 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
05:48:03 <hpc> @pl f >>= \(x, y) -> g >>= \z -> h y >> i z x
05:48:03 <lambdabot> uncurry (((g >>=) .) . flip ((.) . (>>) . h) . flip i) =<< f
05:48:27 <dafis> perly
05:48:40 <IceDane> lol.
05:48:57 <ivanm> preflex: seen dcoutts 
05:48:58 <preflex>  dcoutts was last seen on #haskell 1 day, 7 hours, 52 minutes and 40 seconds ago, saying: mtnviewmark: right we don't have any easy way to install just docs (ie without rebuilding code too), you'd have to do what you suggested about rigging up a script to cabal unpack; cabal configure; cabal haddock
05:48:59 <ivanm> preflex: seen dcoutts_ 
05:48:59 <preflex>  dcoutts_ was last seen on #haskell 4 hours, 14 minutes and 21 seconds ago, saying: mm_freak_: we're working on that, it's not quite ready yet
05:49:02 <hpc> all it needs now is copious amounts of dollar sign
05:49:25 <IceDane> hpc: everywhere
05:49:52 <hpc> actually, since ($) == id, we CAN put it everywhere
05:49:53 <IceDane> Haskell in general could use more dollar signs.
05:49:54 <hpc> :D
05:50:11 <IceDane> hpc: Hehe
05:50:14 <IceDane> You can indeed
05:50:28 <Axman6> :t f $ $ g
05:50:29 <lambdabot> parse error on input `$'
05:50:32 <Axman6> :(
05:50:42 <Ferdirand> :t ($.$)
05:50:44 <lambdabot> Not in scope: `$.$'
05:50:50 <hpc> :t $ . $
05:50:51 <lambdabot> parse error on input `$'
05:50:56 <Ferdirand> :t ($).($)
05:50:57 <lambdabot> forall a b. (a -> b) -> a -> b
05:51:15 <hpc> oh right, that's just fmap id which is id
05:51:16 <Axman6> :t f $ . $ g
05:51:17 <lambdabot> parse error on input `.'
05:51:34 <hpc> :t (f $) . ($ g)
05:51:36 <lambdabot> forall b a b1. (Show b1, SimpleReflect.FromExpr b, SimpleReflect.FromExpr a) => (a -> b1) -> b
05:51:56 <dafis> :t f $g
05:51:57 <hpc> well that's a strange signature
05:51:58 <lambdabot>     Ambiguous type variable `a' in the constraints:
05:51:58 <lambdabot>       `Show a' arising from a use of `f' at <interactive>:1:0
05:51:58 <lambdabot>       `SimpleReflect.FromExpr a'
05:53:36 <zachk2> maybe thats why (.) is preferred over ($) 
05:54:23 <hpc> :t . . .
05:54:24 <lambdabot> parse error on input `.'
05:54:32 <hpc> :t fmap fmap fmap
05:54:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:54:38 <jem777> :t (.) (.)
05:54:39 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
05:54:46 <Phyx-> hmm is TH really that usefull to learn? I've only had to use it once :/
05:55:24 <dafis> Phyx-: that's once more than I needed it
05:55:30 <hpc> TH is really unnecessary
05:55:38 <hpc> the language itself is so powerful already
05:56:24 <McManiaC> I work a lot with TH currently :>
05:57:13 <Phyx-> dafis: lol, I just used it to generate some boilerplate 
06:22:55 <Phyx-> @hoogle normalise --info
06:22:56 <lambdabot> System.FilePath.Posix normalise :: FilePath -> FilePath
06:22:56 <lambdabot>  
06:22:56 <lambdabot> Normalise a file
06:23:04 <Phyx-> ...
06:23:18 <Phyx-> @hoogle makeValid --info
06:23:19 <lambdabot> System.FilePath.Posix makeValid :: FilePath -> FilePath
06:23:19 <lambdabot>  
06:23:19 <lambdabot> Take a FilePath and make it valid; does not change already valid FilePaths.
06:23:26 <Phyx-> ...
06:23:38 <Phyx-> what very useful comments
06:25:30 <dafis> Phyx-: the actual Haddocks give a few examples to illustrate
06:26:10 <Phyx-> ok, my router doesn't allow any udp connections atm, so I can't do any dns queries, :(
06:27:15 <dafis> Phyx-: haven't you local docs?
06:28:09 <Phyx-> not unless ghc comes with them
06:28:47 <Phyx-> hmm. I thought the command: haddock <file1> <file2> <file3> --hoogle was valid
06:29:18 <Phyx-> it returns a file-not-found exception on everything but the first file
06:29:23 <dafis> Phyx-: perhaps the flag before the files?
06:30:32 <Phyx-> dafis: nope, same thing
06:30:59 <dafis> Phyx-: but you haven't typo'd the filenames, I suppose?
06:31:25 <Phyx-> no, if i pass the same files one at a time, they all work
06:32:09 <Phyx-> oh my
06:32:13 <masp> alguem que entenda portugues-brasil?
06:32:46 <dafis> Phyx-: worked here, haddock --version?
06:34:05 <dafis> masp: apparently, the Brasilian-Portuguese speakers are still in bed
06:34:16 <Phyx-> dafis: 2.7.2
06:35:23 <dafis> Phyx-: have another haddock you can try?
06:35:59 <masp> dafis  undstand me 
06:36:27 <dafis> masp: but not much more
06:37:35 <Eduard_Munteanu> Hi.
06:37:43 <masp> why have been in brazil
06:40:09 <Phyx-> grrr
06:40:14 <Phyx-> I really hate that pause key
06:43:28 <tommd> Phyx-: Didn't follow all the previous conversation, but if you're looking to use --hoogle with haddock and having problems with multiple files then (aside from a bug report) use xargs -n1 -P1
06:43:33 <dafis> Phyx-: haddock-2.7.2 worked here too
06:47:06 <Phyx-> tommd, dafis well, I just figured out it might not be haddock, It could be msys not recognising the windows style paths
06:48:16 <dafis> Phyx-: that might be, do double quotes help?
06:49:20 <tommd> And if not, I'd try triple quotes.
06:49:30 <dafis> :D
06:50:02 <Phyx-> dafis: well, if i run the command myself, it works but it's being run as part of a pipeline of a tool, and then it fails
06:50:45 <Phyx-> but the tool echos the command it tried to run, and that command is what also works. so must be something in how it exe.... I think I know why...
06:51:21 <Phyx-> in runProcess if you pass an argument like "foo.hs al.hs" the receiving program no longer splits that, so it must be quoting it or something
06:52:20 <tommd> Isn't there a runProcess like command that allows you to give a list of arguments?
06:52:47 <Phyx-> yeah, I should pass it as a list not a single line
06:52:47 <jmcarthur> there is
06:58:32 <IceDane> Using ReaderT, I cannot update the state?
06:59:02 <dafis> IceDane: no, that's the point of Reader[T] vs. State[T]
06:59:07 <IceDane> dafis: I see
06:59:19 <quicksilver> although you can change it temporarily with local
06:59:19 <noteventime> @type local
06:59:20 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
06:59:40 <IceDane> Would it require a drastic modification of preexisting code to change to StateT ?
06:59:50 <noteventime> So you can run a sub-ReaderT with a modified state :)
06:59:52 <dafis> IceDane: probably not
07:00:02 <IceDane> Alright, I'll try my luck at that then
07:00:14 <dafis> IceDane: but if local works, use that
07:00:23 <IceDane> I'm not entirely sure
07:00:52 <IceDane> I'm not grokking the state monads and co. entirely, but i'm still managing to use it
07:01:11 <IceDane> trying to use it until I get that magical "Aha!" haskell moment
07:01:27 <IceDane> Maybe I should get drunk.. Worked last time
07:01:38 <Zao> My Aha! are normally followed by Uhu!? when my model breaks.
07:01:50 <IceDane> Zao: haha.
07:01:59 <Heffalump> IceDane: with ReaderT, you can change the value for a defined scope that is entered when you change it. For StateT, you can change the value forever.
07:02:16 <Heffalump> it's like how you can only catch exceptions over a defined scope
07:03:05 <IceDane> Heffalump: Yes, I figured it would be something like that. So using local, the value is changed as long as I'm still 'in the monad'?
07:03:19 <IceDane> Or is that an entirely incorrect way to view it?
07:03:20 <Heffalump> no, it's changed as long as you're still within the scope of the local call.
07:03:27 <IceDane> ah
07:03:31 <IceDane> then local won't do
07:03:37 <Heffalump> so do x <- local $ .... ; y
07:03:42 <Heffalump> its changed only for the ....
07:03:47 <IceDane> aaah
07:04:01 <IceDane> Ah yes, I understand now
07:05:19 <zygoloid> IceDane: if you want to change the value for the rest of the time 'in the monad', you want StateT not ReaderT.
07:05:37 <IceDane> zygoloid: Alright
07:05:45 <noteventime> IceDane: It's a little like the difference between dynamic and lexical scoping
07:06:18 <noteventime> Though I guess that's a somewhat problematic analogy
07:06:22 <IceDane> zygoloid: the code I'm writing is based off of something else(Roll your own ircbot @ haskellwiki), where they used ReaderT to implement (I guess read-only) state
07:06:37 <IceDane> I'll have a go at switching it
07:08:23 <Zao> Judging by xmonad and friends, a Reader is mostly for gluing configuration information to your thread of execution.
07:08:38 <Heffalump> it can be used for lots of things
07:09:08 <Zao> My code happily abuses State for just about anything :)
07:10:27 <Eduard_Munteanu> You can use it to pass various context (e.g. "globals") around.
07:10:28 <IceDane> Zao: Yeah. In this code it was used to for containing state like socket and start time(of the application), and that's constant stuff that never needs to be changed
07:10:40 <IceDane> But if ReaderT is read only, is WriterT write-only?
07:10:53 <noteventime> IceDane: Yes
07:11:11 <IceDane> How does write-only make sense? How does storing state that you can never access again make sense?
07:11:15 <IceDane> Unless I'm misunderstanding something..
07:11:20 <noteventime> IceDane: Logging, for example
07:11:46 <IceDane> noteventime: Ah
07:12:08 <noteventime> You get all the "written" information when running the Writer value
07:13:14 <quicksilver> WriterT is not write-only.
07:13:23 <quicksilver> you can read the log at any time.
07:13:38 <quicksilver> the point about WriterT is that you cannot *alter* what is already written
07:13:43 <quicksilver> you can read it, or you can append to it.
07:13:56 <quicksilver> read and append but not modify.
07:14:28 <noteventime> Sorry, you're quite correct
07:14:51 <Phyx-> dafis, tommd yeah it works now :)
07:15:24 <zygoloid> quicksilver: how do you read the log? i thought it was much like reader, in that you can read another monadic action's log, but not your own?
07:16:45 <zygoloid> (you can do a 'run this subcomputation and grab its log' with listen, like you can do a 'run this subcomputation with a different input' with local)
07:17:37 <dafis> :t listen
07:17:38 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
07:23:43 <quicksilver> zygoloid: dafis has your answer.
07:24:04 <quicksilver> zygoloid: to be fair the existence of 'listen' is at least slightly controversial as it makes some instances impossible to write.
07:24:51 <quicksilver> zygoloid: ISTR you can't write the 'listen' instance for WriterT Cont and/or ContT Writer
07:24:57 <quicksilver> (but you can write 'tell')
07:25:17 <byorgey> listen is a bit different than being able to read the log, which I would think of having a type like  readLog :: MonadWriter w m => m w
07:25:21 <byorgey> unless that's encodable?
07:26:30 * Eduard_Munteanu sees comonads in w usually
07:26:41 <quicksilver> I don't think that's encodeable.
07:26:49 <quicksilver> I agree it's not the same but it's still reading the log in a sense.
07:26:54 <Heffalump> @type listen
07:26:55 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
07:27:03 <byorgey> well, sure.
07:27:07 <quicksilver> it still makes it available as an action inside the single monad m
07:27:17 <Heffalump> @type listenT
07:27:19 <lambdabot> Not in scope: `listenT'
07:27:26 <zygoloid> quicksilver: sure, but it doesn't allow me to say "what is the log up to this point?"
07:27:28 <quicksilver> without explicit use of 'runSomething'
07:27:34 <quicksilver> zygoloid: no, that's right
07:27:56 <zygoloid> quicksilver: so it doesn't really allow reading the log, in the same way ReaderT doesn't allow changing the value.
07:27:57 <quicksilver> arguably it makes the typeclass promise the ability to 'runWriter' wherever it is in the stack
07:28:09 <quicksilver> which can be a bit fiddly to arrange.
07:28:11 <handonson> I'm trying to implement a CP949 instance for this library http://hackage.haskell.org/package/encoding
07:28:21 <handonson> any good idea about how to begin?
07:31:56 <handonson> or is it a good idea to use the encoding library at all?
07:47:27 <p00ya> @pl \c -> f a b (g c) c
07:47:28 <lambdabot> f a b =<< g
07:47:58 <p00ya> i get an error No instance for (Monad ((->) Char)) when trying to use that pointfree form
07:48:17 <dafis> p00ya: import Control.Monad.Instances
07:48:23 <p00ya> thanks
07:48:30 <dafis> (or C.M.Reader)
07:53:18 <fryguybob> @hoogle Maybe [a] -> [a]
07:53:19 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
07:53:19 <lambdabot> Prelude cycle :: [a] -> [a]
07:53:19 <lambdabot> Prelude init :: [a] -> [a]
07:55:13 <EvanR-work> fryguybob: whats that supposed to do?
07:55:53 <EvanR-work> fromMaybe [1,2,3] listOfMaybes ?
07:56:00 <fryguybob> (Just [1.2]) becomes [1,2], Nothing becomes []
07:56:11 <fryguybob> (Just [1,2]) that is.
07:56:22 <EvanR-work> > fromMaybe [] (Just [1,2])
07:56:23 <lambdabot>   [1,2]
07:56:29 <EvanR-work> > fromMaybe [] (Nothing)
07:56:30 <lambdabot>   []
07:56:48 <fryguybob> > Data.Foldable.concat (Just [1,2])
07:56:50 <lambdabot>   [1,2]
07:56:58 <fryguybob> > Data.Foldable.concat (Nothing)
07:56:59 <lambdabot>   []
07:57:11 <EvanR-work> :t (fromMaybe [])
07:57:12 <lambdabot> forall a. Maybe [a] -> [a]
07:57:15 <EvanR-work> ;)
07:57:47 <EvanR-work> for [Maybe a] -> [a] there catMaybes
07:58:00 <EvanR-work> > catMaybes [Just 3, Nothing, Just 7]
07:58:01 <lambdabot>   [3,7]
08:03:39 <scotty> foldl . (/2) . (+) . 1 $ [1..5]
08:04:33 <dafis> > foldl . (/2) . (+) . 1 $ [1..5]
08:04:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
08:04:42 <scotty> ha-ha, sorry.
08:04:55 <scotty> I was just reading something someone wrote earlier.
08:05:03 <EvanR-work> > foldl . (/2) . (+1) $ [1..5]
08:05:03 <zygoloid> > map Data.Foldable.fold [Nothing, Just [], Just [1], Just [1,2,3]]
08:05:04 <lambdabot>   [[],[],[1],[1,2,3]]
08:05:04 <lambdabot>   Couldn't match expected type `a -> b -> a'
08:05:05 <lambdabot>         against inferred type `[...
08:05:12 <scotty> Someone said "just make it point-free."
08:05:14 <zygoloid> fryguybob: ^^ i think that's what you wanted
08:05:29 <jystic> Hi all, i'm building a network library that will allow you to get the IP and MAC addresses of the local computer under linux and windows (like ifconfig/ipconfig) but I'm a bit unsure about how it fits in with existing libraries, should I use Network.Socket.Internal.HostAddress as the representation for IP addresses?
08:05:29 <zygoloid> @type Data.Foldable.fold :: Maybe [a] -> [a]
08:05:30 <lambdabot> forall a. Maybe [a] -> [a]
08:05:33 <scotty> I realized that was from a few days ago and I just hadn't scrolled down.
08:05:41 <dafis> > foldl . (/2) . (+) . const 1 $ [1..5]
08:05:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
08:05:44 <fryguybob> zygoloid: Data.Foldable.concat worked for what I wanted.
08:06:21 <zygoloid> looks like concat is just fold with the monoid fixed to [a]?
08:06:30 <danderson> jystic: see netlink-hs.googlecode.com
08:06:37 <danderson> I'm building something similar (but more powerful) for linux only
08:06:53 <danderson> because I need to manipulate interface state, address allocation and routing tables from haskell
08:07:09 <jystic> cool, maybe i can just copy your interface and implement some readonly bits for windows
08:07:18 <danderson> jystic: currently under heavy development
08:07:19 <jystic> i really only need what ifconfig/ipconfig can give me
08:07:28 <danderson> (as in: I'm trying to fix my netlink packet decoder)
08:07:45 <danderson> jystic: ah, then check out tunskell.googlecode.com
08:07:50 <danderson> under Tunskell.Local.KernelConfig
08:07:56 <danderson> it's an internal module, but feel free to steal it
08:08:08 <danderson> I'll eventually replace that internal module with this netlink library, once it's finished
08:08:25 <danderson> the current implementation just shells out to `ip` (the preferred replacement to ifconfig) on linux
08:08:33 <danderson> might give you appropriate pointers
08:09:22 <danderson> gotta run, but back in 15 if you want to chat about this. Accessing network state from haskell is near and dear to my heart :P
08:09:25 <jystic> I actually have working code written in C and wrapped in Haskell to get the info that I need, but I'm wondering about naming and if there is existing libraries that I can fit in with
08:09:35 <danderson> aha
08:09:36 <danderson> no.
08:09:40 <danderson> well, not that I know at least
08:09:47 <IceDane> Using StateT, doing state with data A = B {a, b, c}, how would I only update the c part of this using put and so on?
08:09:49 <jystic> danderson: ok cool, i'll chat when you get back
08:10:14 <danderson> jystic: if you want to build a portable API for this sort of thing, I'd like to help if I can find the time
08:10:48 <danderson> I'm building the linux-specific swiss army chainsaw right now because that's what I need (eg. setting routes with custom route IDs, so I can distinguish routes my software sets from others)
08:10:58 <danderson> but wrapping the common stuff into something portable would be nice
08:11:27 <jystic> danderson: cool, yeah i don't really need anything that fancy, but i'd like to be able to get basic networking details in a portable fashion
08:12:02 <jystic> the names, ip addresses and mac addresses of all the local network adapters specifically
08:12:26 <fryguybob> IceDane: put $ s { c = value } ?
08:12:34 <IceDane> fryguybob: Ah, thank you
08:12:52 <EvanR-work> IceDane: update syntax isnt first class... so you can like 'modify . c' or something
08:13:06 <IceDane> Oh yeah
08:13:12 <EvanR-work> s/can/cant/
08:13:45 <EvanR-work> but there are probably lots of tricks ;)
08:15:24 <zygoloid> modify $ \a -> a { c = foo (c a) }. but it's common to write a helper: withC f (a { c = c }) = a { c = f c }, then use: modify . withC $ foo
08:15:55 <aristid> isn't fclabels another possibility?
08:16:55 <EvanR-work> complex techniques to write complex stateful code! ;)
08:26:55 <IceDane> Such insolence
08:27:11 <EvanR-work> im thinking that a separate module should be dedicated to providing an interface to updating the state in various ways, adding self documentation to the mutator code, and avoiding low level updates being distributed troughout like a C program
08:27:12 <IceDane> book.realworldhaskell.org goes down when I'm trying to learn me a haskell.
08:27:31 <Botje> there's learnyouahaskell as well
08:27:36 <IceDane> I know
08:27:42 <IceDane> It's just not quite as good on monad transformers
08:27:43 <IceDane> iirc
08:28:15 <EvanR-work> IceDane: StateT over IO?
08:28:33 <IceDane> oh, it has exactly no sections on monads and monad transformers
08:28:40 <IceDane> EvanR-work: Umm, I think so
08:28:44 <IceDane> Yeah
08:28:55 <EvanR-work> theres also ReaderT over IO with IORefs ;)
08:29:02 <IceDane> No clue what you mean by that
08:29:16 <IceDane> I'm trying to change from readerT to stateT to have some mutable state
08:29:41 <EvanR-work> right, thats where IO comes in
08:30:19 <EvanR-work> then updating individual fields becomes writing to individual IORefs
08:31:10 <EvanR-work> of course if you dont need IO then just State or StateT over something else i think would be cleaner
08:31:51 <IceDane> I do need iO
08:31:53 <IceDane> IO*
08:31:55 <IceDane> networked and all
08:32:31 <EvanR-work> sounds like a job for IORef
08:33:43 <IceDane> hmm
08:33:51 <IceDane> I'll look into them, thanks
08:34:39 <fasta> IceDane, there is no need to ever use IORefs, AFAIK.
08:34:59 <fasta> IceDane, STRefs can be used instead. 
08:35:08 <IceDane> aah
08:35:25 <fasta> IceDane, but in fact you probably want some kind of overloaded RefMonad.
08:35:26 <EvanR-work> no need for any mutable variables
08:36:15 <fasta> EvanR-work, if you don't have O(1) writing and reading of array cells, then you do need them. 
08:36:44 <EvanR-work> nah
08:37:22 <fasta> EvanR-work, please explain how you can provide the interface of a mutable array with the right complexities without using mutable memory? 
08:37:44 <fasta> (It's a rhetorical question. )
08:37:48 <EvanR-work> he didnt require that
08:38:06 <Heffalump> fasta: DiffArray
08:38:19 <fasta> Heffalump, that doesn't count. 
08:38:21 <Heffalump> why not?
08:38:36 <fasta> Heffalump,  "if you don't have O(1) writing and reading of array cells"
08:38:36 <EvanR-work> but the memory module has its own complexity, as memory increases in absolute size its updates are going to take longer...
08:38:44 <EvanR-work> its not really O(1)
08:39:12 <fasta> EvanR-work, yes, but functional solutions are a log n factor over that O(1).
08:39:28 <wli> O(lg(address_space)) circuit depth?
08:39:56 <Heffalump> fasta: what do you mean by a "functional solution"?
08:40:00 <fasta> Yes, that's what he means and the next thing on the list is the speed of light. 
08:40:39 <fasta> Heffalump, something which can use everything except for DiffArray. 
08:40:41 <EvanR-work> anyway you slapped the array on an an extra requirement
08:40:45 <EvanR-work> as an*
08:40:57 <fasta> EvanR-work, no, I didn't.
08:41:00 <Heffalump> fasta: I see :-)
08:41:06 <wli> (There are virtual and physical addresses involved somewhere but anyway.)
08:41:13 <fasta> EvanR-work, you need those arrays if you want to build your own reference like objects.
08:41:13 <EvanR-work> we were talking about individual mutable variables not arrays
08:41:43 <wli> Memory modules only care about physical address space which is not the full 2^64 by a longshot.
08:41:44 <fasta> EvanR-work, if you cannot modify e.g. the leaves of a mutable tree data structure in constant time you lose another log n factor there.
08:41:55 <EvanR-work> you mean integer keys with index arithmetic
08:42:15 <EvanR-work> thats the key, otherwise you pass integer key, value pairs around
08:42:16 <wli> Virtual address space is somewhere else in the calculation involving the TLB etc.
08:43:18 <EvanR-work> fasta: 'i need array-like datastructure with O(1) updates and lookups' is an extra requirement
08:43:35 <fasta> EvanR-work, feel free to implement http://cs.nyu.edu/cs/faculty/cole/papers/COS00.ps without using mutable data structures or DiffArray. 
08:43:49 * copumpkin moos
08:43:57 <Heffalump> what's your actual rationale for banning DiffArray?
08:44:09 <EvanR-work> i would ban RAM also
08:44:11 <jmcarthur> DiffArray is terribly slow :(
08:44:21 <EvanR-work> both are not functional
08:44:25 <jmcarthur> for unknown reasons
08:44:28 <fasta> Heffalump, DiffArray is incredibly slow and other "functional programming" has zero meaning. 
08:44:40 <fasta> Heffalump, otherwise*
08:44:43 <Heffalump> fasta: it has the right time complexity, though.
08:44:54 <Heffalump> are you going to ban laziness too?
08:45:12 <fasta> Heffalump, yes, so they say. I never measured it though, other than that it was slow. 
08:45:23 <fasta> Heffalump, that is a trap.
08:45:30 <fasta> Heffalump, yes, I read the haste paper...
08:45:38 <fasta> Heffalump, and no, I am not banning that.
08:46:08 <jmcarthur> when you have log n vs. a huge constant, the log n often wins
08:46:17 <EvanR-work> it stands to reason that you may want a certain speedup in performance of something, but that is an extra requirement
08:46:58 <fasta> Everyone who doesn't know about functional programming says "functional programming" is different, yet if we try to define "functional programming" we come into all kinds of silly debates. The only viable conclusion is that there is no difference :)
08:47:06 <Saizan> EvanR-work: i think fasta just started a discussion about needing mutable references in general, rather than this particular case
08:47:24 <fasta> Saizan, yes, I made a slight generalization. 
08:47:47 <fasta> In specific cases it is often possible to reorganize the computation, but I have not been able to do that always.
08:47:52 <EvanR-work> i guess you need them in general because general includes kernel code and such
08:48:27 <fasta> EvanR-work, by general I mean computations, not I/O messy stuff.
08:48:35 <jmcarthur> it occurs to me that the answer to conal's question about why so many people believe everything in haskell is a function might be due to misinterpreting the "purely" in "purely functional"
08:48:40 <EvanR-work> me too
08:48:54 <zygoloid> purely functional? i thought it was pure, functional ;-)
08:49:09 <jmcarthur> zygoloid: that would be the better way to phrase it
08:49:16 <jmcarthur> but a lot of people just say "purely function"
08:49:19 <jmcarthur> *functional
08:49:28 * fryguybob thinks if it is so pure, why does my computer heat up...
08:49:43 <Saizan> i also think conal tends to redefine "pure" and "functional" to mean what he likes them to be, without saying so explicitly
08:49:45 <fasta> fryguybob, we didn't figure out how to do reversible computation yet.
08:50:00 <EvanR-work> yes we have
08:50:06 <zygoloid> fryguybob: that's pure-as-in-referentially-transparent-(most-of-the-time)-(don't-ask-about-unsafePerformIO)-(seriously-don't-ask)
08:50:06 <jmcarthur> i do think that is a source of his frustration
08:50:07 <fryguybob> Thinking about math makes me burn calories too.
08:50:10 <fasta> EvanR-work, we do?
08:50:21 <fasta> EvanR-work, I mean the physical part of it.
08:50:45 <EvanR-work> well, wouldnt you need unlimited memory and exponentially growing circuit wiring to match
08:50:50 <fryguybob> jmcarthur: Good insight.
08:51:36 <fasta> EvanR-work, reversible computation means that the energy required to compute X is only related to its output, not the process by which it was computed.
08:52:01 <fasta> I see no reason why it would ever work, but it would be great if someone proved me wrong.
08:52:18 <EvanR-work> you just need to save all answers ever
08:52:24 <zygoloid> why is it desirable even?
08:52:45 <EvanR-work> reconfigure the combinational logic of the chip
08:53:01 <fasta> Actually, I think it is pretty easy to prove it is not possible based on some other fundamental laws. 
08:53:19 <roconnor> what isn't possible?
08:53:21 <winxordie> zygoloid: miniaturization of chips leads to more dissipation of heat. if all computation is reversible, then hypothetically there would ridiculously little heat dissipation
08:53:33 <fasta> The Halting problem + the laws of thermodynamics make sure of that. 
08:53:43 <EvanR-work> pah
08:53:46 <jmcarthur> what if we didn't have turing complete hardware?
08:53:48 <zygoloid> fasta: i think we could put a time bound on computations if we could put an energy bound on them
08:54:04 <fasta> zygoloid, yes, then there might be some room.
08:54:24 <roconnor> all computation can be made reversable by simply copying the input to the output
08:54:53 <roconnor> and reversable computation has zero theoretical energy requirements
08:54:57 <winxordie> fasta: check out Landeur, 1960
08:55:14 <winxordie> I can't find a link, but he showed it's *theoretically* possible
08:55:22 <zygoloid> winxordie: i don't see that follows. there's no guarantee that the heat bound would be small, and physical reality interferes with appealing to asymptotics
08:55:25 <roconnor> overall there is a time/space/energy tradeoff when designing algorithms
08:56:38 <roconnor> Though reversable computation has no energy requirements, setting the input does require heat to be disipated.
08:57:04 <winxordie> roconnor: right, setting the input is itself not necessarily reversible
08:57:16 <EvanR-work> http://en.wikipedia.org/wiki/Toffoli_gate
08:57:35 <winxordie> i.e. setting a register to zero would be irreversible; the question is then how much computation is necessarily irreversible?
08:57:47 <EvanR-work> you can do anything irreversible
08:57:48 <EvanR-work> cant*
08:58:14 <EvanR-work> whatever part of the algorithm that doesnt show up in the answer must go somewhere
08:58:18 <wli> Register clobbers are irreversible...
08:58:24 <EvanR-work> cant be erased
08:58:32 <roconnor> winxordie: I answered that, No computation is necessarily irreversible
08:58:45 <roconnor> all computation can be made reversable by copying the input to the output
08:59:27 <zygoloid> ah, wikipedia explains that reversible actually means the obvious thing, not that the energy required to compute X only depends on its output
08:59:32 <zygoloid> that makes a lot more sense as a notion
08:59:48 <winxordie> EvanR-work: I mean irreversible form the previous state. If I clear all registers, there's no way of knowing from the register set how to get back to th previous state
09:00:10 <winxordie> and if we can't do anything irreversible, we could all be using Carnot engines :P
09:00:29 <EvanR-work> use a simpler machine than a cpu with registers
09:00:38 <zygoloid> winxordie: the miniaturization argument falls down since most of the extra heat is due to leakage power, which is essentially independent of the computation being performed.
09:01:04 <roconnor> EvanR-work: sure, all physics is reverable, but we realize irreverable computations by physically disappating heat into the environment.
09:01:18 <winxordie> EvanR-work: like what, a stack machine?
09:01:26 <EvanR-work> a combinational logic circuit
09:01:45 <EvanR-work> roconnor: i was just saying to avoid dissipating heat you cant do anything irreversible
09:01:48 <fasta> winxordie, did he actually build something that worked? 
09:01:51 <roconnor> EvanR-work: good
09:02:09 <winxordie> zygoloid: how's it independent?
09:02:17 <fasta> winxordie, or did he prove that it really could work concretely laying out how the various logic operations could be compiled?
09:02:20 <wli> EvanR-work: Care to propose a specific sort of machine?
09:02:22 <winxordie> fasta: no one has as far as reversible gates go
09:02:31 <EvanR-work> i pasted such a gate above
09:02:33 <winxordie> he proved that it doesn't violate any of the thermodynamic laws
09:02:37 <fasta> winxordie, I don't care about the size of these gates. 
09:02:52 <fasta> winxordie, did he have any concrete design?
09:02:53 <wli> EvanR-work: 3AC memory/memory system? Then the memory addresses take the place of registers and you're clobbering a memory cell every time.
09:03:02 <winxordie> EvanR-work: I meant built one.
09:03:17 <winxordie> at least as far as I know. *reads*
09:03:17 <EvanR-work> wli: theres no memory in a combinational logic circuit
09:03:40 <roconnor> ``The Toffoli gate has been successfully realised in January 2009 at the University of Innsbruck, Austria.[3][4]
09:04:00 <EvanR-work> such circuits are a lot like pure functions
09:04:12 <winxordie> fasta: I didn't see any designs by him.
09:04:26 <EvanR-work> but unless designed correctly they will irrersibly compute and dissipate heat
09:04:35 <winxordie> functional hardware eh?
09:04:52 <EvanR-work> but yeah its all about power leakage
09:05:30 <monochrom> hardware is functional by nature. much contortion to make them into memory
09:05:48 <monochrom> a transistor is a transfer function.
09:05:56 <zygoloid> winxordie: it's independent in that the leakage power of a circuit depends pretty much on the silicon area and threshold voltage, and not on how much the circuitry actually switches
09:06:55 <winxordie> oh, gotcha. that would take the miniaturization out.
09:07:00 <fasta> Slow computation that takes almost zero power is also useful for some purposes, if it is light you could even put it in space.
09:09:52 <EvanR-work> monochrom: which brings us back to the apparent but maybe illusory incompatibility of IO and pure functional
09:10:24 <EvanR-work> hookup the circuits in the right way and its pure, use feedback and its not? or is it something else entirely
09:10:34 <EvanR-work> maybe we need a new calculus
09:10:42 <Benny_> EvanR-work: It's... not pure either way
09:10:49 <EvanR-work> effectively pure
09:10:53 <Benny_> It's just a good way of modelling it
09:10:57 <zygoloid> it's pure-as-a-function-of-time either way ;-)
09:11:26 <zygoloid> (well, after making certain assumptions about the funtamental nature of the universe...)
09:11:27 <roconnor> computation that doesn't need to be couple to the environement is pure
09:11:30 <EvanR-work> stop destroying the differentiating criteria!
09:11:41 <roconnor> IO needs to be coupled to the environment
09:11:52 <EvanR-work> roconnor: no
09:11:57 * Benny_ runs zygoloid'd circuits in a freezer
09:12:00 <Benny_> * 's
09:12:23 <zygoloid> Benny_: your freezer is part of my function :p
09:12:32 <Benny_> :P
09:12:35 <Benny_> Fair enough
09:12:47 <EvanR-work> roconnor: two different computers using a pure RCP interface... or two CPU submodules using combinational logic seems about the same mix of IO and purity to me
09:12:57 <EvanR-work> though there will be differences at the quantum level
09:13:04 <EvanR-work> at some point
09:13:22 <roconnor> EvanR-work: I don't see how they are the same
09:13:30 <EvanR-work> both require external inputs and ouputs
09:13:58 <zygoloid> so i heard there's a programming language called haskell. what's all that about?
09:14:16 <roconnor> if you have two coupled CPU then the two CPU, plus their connecting line count as the computer, and only outside of that is the environment.  In particular, the lines connecting the CPUs are not part of the environment.
09:14:25 <EvanR-work> both have the same amount of pesky IO reality, be in transport failure or random EM interference..
09:14:35 <roconnor> zygoloid: haskell is about evil irreversible computation
09:14:40 <EvanR-work> roconnor: sure so the computer abstraction is relative
09:14:40 <monochrom> haskell is about exploding your brain and ruling the world
09:15:01 <zygoloid> roconnor: i thought it was more denotational and less operational than that? ;-)
09:15:23 <EvanR-work> but when you get sequential logic and feedback circuitry (the other half of IO) then it cant be modeled with computer science
09:15:31 <EvanR-work> at least, functions
09:15:46 <roconnor> EvanR-work: if you want to consider my display and printer and myself as part of the computer, then fine it is all pure, but I think that is a silly way to define things
09:15:59 <EvanR-work> problem is that its got feedbak
09:16:18 <roconnor> zygoloid: irreversable functions are defined denotationally
09:16:34 <roconnor> irreversable functions := non-injective functions
09:16:46 <EvanR-work> so its got to be a turing machine, not a recursive function
09:16:51 <EvanR-work> so its not pure
09:16:57 <Benny_> That's not true
09:17:07 <roconnor> EvanR-work: I don't see what feedback has to do with anything
09:17:21 <zygoloid> roconnor: sure, but my implementation could be reversible for all i know. :)
09:17:24 <Benny_> Brainfuck is turing-complete, and I wrote a purely-functional BF
09:17:51 <EvanR-work> roconnor: is forces an imperative model rather than a functional model of computation
09:18:06 <roconnor> Benny_: New Kind of Science has a nice example of a reversable celular automoton that is turing complete.
09:18:11 <EvanR-work> time dependences
09:18:39 <monochrom> so A New Kind of Science is good for something afterall? XD
09:18:48 <Benny_> And this is all kind of a funny subject, I actually joined to ask a question about the reversible programming language thingy I'm working on
09:18:48 <roconnor> monochrom: a few things
09:19:06 <EvanR-work> i have a reversible jacket
09:19:15 <Benny_> It's reversible in the sense of storing all past state and having an instruction to go back, that is
09:19:22 <Benny_> (well, not *all* past state)
09:19:34 <Benny_> (just the addressable past state)
09:19:48 <roconnor> EvanR-work: I don't really understand why you say that time-depencencies can't be modeled in a purely functional way.  Haskell does so doesn't it?
09:20:21 <fryguybob> @hoogle read a => String -> Maybe a
09:20:22 <lambdabot> Did you mean: Read a => String -> Maybe a /count=20
09:20:22 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
09:20:22 <lambdabot> Prelude fail :: Monad m => String -> m a
09:20:36 <EvanR-work> roconnor: no, thats why everyone cant tell you time complexity of haskell code ;)
09:20:58 <Benny_> They whaaa
09:21:11 <roconnor> EvanR-work: time-complexity is a totally different issue
09:21:15 <Benny_> I can't tell if you're joking :P
09:21:40 <EvanR-work> i dont know
09:21:50 * EvanR-work takes a break
09:21:52 <copumpkin> omnom
09:22:19 <copumpkin> preflex: seen smerdyakov
09:22:19 <preflex>  smerdyakov was last seen on ##C 65 days, 1 hour, 39 minutes and 31 seconds ago, saying: * smerdyakov gives up on converting strings to seconds-since-UTC-epoch.  String comparison seems to work. :P
09:24:06 <zygoloid> preflex: seen mmorrow
09:24:06 <preflex>  mmorrow was last seen on #ghc 190 days, 13 hours, 26 minutes and 21 seconds ago, saying: * mmorrow is rtfm'ing
09:24:14 <Phyx-> @hoogle unsafePerformIO
09:24:14 <lambdabot> Foreign unsafePerformIO :: IO a -> a
09:24:15 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
09:25:30 <jmcarthur> i miss mmorrow
09:25:32 <copumpkin> still no word from mmorrow?
09:25:34 <copumpkin> aww
09:25:35 <copumpkin> :(
09:26:24 <c_wraith> vanishing that suddenly and completely makes me suspect something bad happened.
09:26:25 <zygoloid> did anyone know him in person? can we find out whether he's ok?
09:26:55 <copumpkin> I tracked down his parents but didn't feel comfortable calling
09:27:19 <copumpkin> can't even remember where I found them
09:37:47 <Phyx-> @ping
09:37:48 <lambdabot> pong
09:38:05 <Benny_> @bing
09:38:05 <lambdabot> pong
09:38:10 <Benny_> haha.
09:38:22 <Phyx-> nice try
09:38:39 <Benny_> @bing goes the Internet?
09:38:40 <lambdabot> pong
09:39:03 <Benny_> I deeply apologize to anyone else who now has that awful jingle stuck in their head
09:40:25 <jmcarthur> @ding
09:40:26 <lambdabot> pong
09:40:37 <Benny_> @fing
09:40:38 <lambdabot> pong
09:40:39 <jmcarthur> lambdabot should really respond to these appropriately :)
09:40:49 <heatsink> @thing
09:40:49 <lambdabot> pong
09:40:58 <Benny_> @éing
09:40:59 <lambdabot> pong
09:41:03 <monochrom> it is already appropriately
09:41:07 <Benny_> @hyperventilating
09:41:08 <lambdabot> Unknown command, try @list
09:41:08 <heatsink> @where are you going
09:41:09 <lambdabot> I know nothing about are.
09:41:12 <heatsink> @whereareyougoing
09:41:12 <lambdabot> Unknown command, try @list
09:46:47 * Phyx-
09:47:36 <Phyx-> :t uncurry
09:47:37 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:47:44 <Phyx-> :t curry
09:47:45 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
09:48:00 <Phyx-> :t (id *** (.))
09:48:01 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (b, a -> b1) -> (b, f a -> f b1)
09:49:30 <Phyx-> :-]
09:50:39 <Phyx-> \o/
09:50:43 <Phyx-> \o_
09:50:47 <Phyx-> _o_
09:50:53 <Phyx-> _o/
09:50:58 <Phyx-> \o/
09:51:04 <Phyx-> now break it down
09:51:44 <monochrom> that is a Gray code
09:52:27 <Phyx-> hm?
09:53:00 <aristid> :t second (.)
09:53:01 <lambdabot> forall a b (f :: * -> *) d. (Functor f) => (d, a -> b) -> (d, f a -> f b)
09:53:05 <monochrom> Gray code is a periodic sequence of n-bit strings. consecutive members differ by exactly 1 bit.
09:54:04 <monochrom> example: cycle [11, 10, 00, 01].  think of 11 as \o/, 10 as \o_, etc.
09:54:54 <Phyx-> no, well, Haslol
09:55:03 <Phyx-> lol*
09:57:37 <monochrom> and the sequence has to go through all 2^n strings.
09:59:30 <Phyx-> I just want a dancing man
10:01:26 <byorgey> to visualize Gray codes with greater number of bits, imagine a dancing man with n arms...
10:01:50 <Phyx-> you've been watching too much SyFy
10:02:00 <byorgey> I don't even know what that is
10:02:53 <Phyx-> SciFi
10:02:59 <Phyx-> Science Fiction
10:03:07 <byorgey> "an American cable television channel that specializes in science fiction, fantasy, horror, professional wrestling, and paranormal programming"
10:03:16 <byorgey> ...professional wrestling!?
10:04:03 <Phyx-> hahahha, yes, that is a big "Wtf" of them
10:04:08 <BMeph> Paranormal wrestling actually sounds interesting... ;)
10:05:13 <monochrom> that channel is tailored for male weirdos
10:05:14 <byorgey> > let gray 0 = [[]]; gray (n+1) = map (0:) (gray n) ++ map (1:) (reverse (gray n)) in gray 3
10:05:17 <lambdabot>   [[0,0,0],[0,0,1],[0,1,1],[0,1,0],[1,1,0],[1,1,1],[1,0,1],[1,0,0]]
10:09:02 * hackagebot dbmigrations 0.2 - An implementation of relational database "migrations"  http://hackage.haskell.org/package/dbmigrations-0.2 (JonathanDaugherty)
10:09:30 <zygoloid> Benny_: damn you, i just read your @bing in the scrollback. fortunately that earworm has turned into 'mr stabby' and all is well again
10:09:47 <monochrom> byorgey: examples of n-hands-dancing on http://www.youtube.com/results?search_query=%E5%8D%83%E6%89%8B&aq=f
10:10:06 <monochrom> err, n-arms-dancing
10:12:26 <byorgey> monochrom: woah, very cool
10:12:48 <byorgey> unfortunately they don't seem to be doing anything Gray-code related ;)
10:13:15 <aristid> their arm movements seem to need more than one bit
10:14:30 <FauxFaux> > let a (n-5) = n in a 7
10:14:30 <lambdabot>   <no location info>: Parse error in pattern
10:14:47 <copumpkin> only + works
10:18:35 <aavogt> -XNMinusKPatterns
10:18:46 <aavogt> > let a (subtract 5 -> n) = n in a 7
10:18:47 <lambdabot>   2
10:19:20 <zygoloid> > let (1 + 1 -> 3) = 2 in 0
10:19:21 <lambdabot>   0
10:19:28 <aavogt> that's not what the - pattern is supposed to do though, right?
10:19:40 <zygoloid> not quite, no.
10:20:13 <zygoloid> > let f (n+1) = n in f 0
10:20:14 <lambdabot>   *Exception: <interactive>:1:145-155: Non-exhaustive patterns in function f
10:20:37 <roconnor> lame
10:21:09 <heatsink> >f minBound
10:21:13 <heatsink> > f minBound
10:21:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:21:14 <lambdabot>    `SimpleReflect.FromExpr ...
10:21:26 <heatsink> > f (minBound :: Int)
10:21:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:21:28 <lambdabot>    `GHC.Show.Show a'
10:21:28 <lambdabot>      a...
10:22:02 <heatsink> Why is it non-exhaustive?
10:22:18 <zygoloid> heatsink: well, for a start that's a different f :)
10:22:23 <copumpkin> because n+k patterns assume you're positive
10:23:00 <heatsink> huh, I didn't know they checked for that. 
10:23:54 <copumpkin> > let f (n+1) = n in (f 10, f (-5))
10:23:56 <lambdabot>   (9,*Exception: <interactive>:1:153-163: Non-exhaustive patterns in function f
10:24:31 <zygoloid> heatsink: yeah. the desugaring with -XNoImplicitPrelude requires a (-) and a (>=) iirc
10:25:17 <heatsink> It's funny how the pattern language is getting so complicated
10:25:29 <heatsink> Eventually we will be able to write entire programs as pattern matches
10:25:29 <copumpkin> the n+k patterns are on their way out aren't they?
10:25:40 <copumpkin> they've been around for ages and most people hate them
10:25:44 <zygoloid> copumpkin: gone in h'10 iirc
10:25:58 <heatsink> yeah
10:26:00 <copumpkin> pattern matching in agda can be pretty tricky :)
10:26:08 <copumpkin> I'm struggling with one right now
10:28:01 <roconnor> IIRC you have to put random dots in Agda patterns
10:28:20 <copumpkin> well not random
10:28:26 <roconnor> :)
10:28:29 <copumpkin> :P
10:28:33 <roconnor> to me they are random
10:28:33 <copumpkin> but yeah
10:28:47 <copumpkin> and sometimes you need to bring extra knowledge in with "with" clauses
10:28:52 <roconnor> Like having to say PLEASE enough time to make Intercal happy
10:29:04 <copumpkin> I'm having trouble with one right now :(
10:29:26 <roconnor> copumpkin: what are you writing in Agda?
10:29:43 <copumpkin> working with modular arithmetic, just doing the basics right now
10:30:29 <copumpkin> would love to get up to finite fields
10:30:36 <copumpkin> but given my skills it's unlikely :P
10:31:20 <roconnor> how do people represent finite fields?
10:31:37 <roconnor> Do they use vectors of the prime fields and and funky multiplication?
10:31:38 <copumpkin> how do you mean?
10:32:01 <copumpkin> well, I haven't gotten anywhere close to that yet
10:33:03 <roconnor> copumpkin: ya,  I was working on Galois theory in Coq, so these thoughts are on my mind.
10:33:12 <roconnor> but I was working with abstract fields so far.
10:33:13 <copumpkin> ah cool
10:33:28 <copumpkin> I should look to see how other people have approached it
10:33:33 <roconnor> I actually went out of my way to no build field extenstions
10:33:34 <copumpkin> especially with all my newfound coq knowledge
10:33:39 <roconnor> *not
10:37:10 <ccasin> copumpkin: can I have a look?  I love hard agda pattern matching questions :)
10:38:45 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28281#a28281 :P
10:39:00 <copumpkin> line 64 is the painful one
10:44:31 <JonatasTeixeira> Someboddy has a tutorial for i to lern haskel?
10:44:49 <pikhq> @where LYAH
10:44:50 <lambdabot> http://www.learnyouahaskell.com/
10:44:53 <pikhq> ^
10:46:55 <JonatasTeixeira> kkk Great pics kkk
10:47:01 <JonatasTeixeira> Tks. ;)
10:47:05 <c_wraith> It's a great beginner's tutorial.
10:49:42 * Saizan bets we need heterogenous equality for lemma2
10:53:41 <roconnor> Saizan: I'll take that bet
10:54:06 <ccasin> yeah, I think we just need to rename the index temporarily
10:54:50 <roconnor> I don't really see the point of EmbMax though
10:57:55 <chrisdone> hai
10:58:27 <zygoloid> moin
10:59:01 <chrisdone> got the go ahead from the pappy author to package pappy and pop it on hackage
10:59:04 <chrisdone> ^__ ^
11:00:04 <zygoloid> @google hackage pappy
11:00:05 <lambdabot> No Result Found.
11:00:13 <chrisdone> i'm doin' it now!
11:00:31 <zygoloid> @google haskell pappy
11:00:32 <lambdabot> http://pdos.csail.mit.edu/~baford/packrat/thesis/
11:00:32 <lambdabot> Title: Packrat Parsing: a Practical Linear-Time Algorithm with Backtracking
11:00:41 <zygoloid> 's what i meant :)
11:05:29 <zygoloid> chrisdone: wow, that's pretty cool
11:05:35 <chrisdone> yeah, it's a neat library
11:06:33 <copumpkin> ugh, damn internet :P
11:06:33 <copumpkin> did I miss anything?
11:06:45 <ccasin> nope
11:06:48 <chrisdone> zygoloid: guess you already saw this right? http://pegjs.majda.cz/online
11:07:23 <copumpkin> ccasin: what do you mean by renaming the index?
11:08:13 <zygoloid> chrisdone: i'm wondering whether that's powerful enough to parse c++. looks like it might be :)
11:08:21 <Phyx-> quick question... I have a tool that installs two folders into wherever cabal installs it, how do I later find them? 
11:09:00 <ccasin> copumpkin: I'm trying to make it work out, will tell you if it does :)
11:09:09 <Phyx-> > 260 /60
11:09:10 <lambdabot>   4.333333333333333
11:09:26 <copumpkin> ccasin: thanks :) glad to know it isn't entirely trivial
11:09:30 <Phyx-> lol, so i have been talking to myself for 4 and a half minutes
11:09:49 <chrisdone> zygoloid: is c++ context-free?
11:09:55 <ccasin> copumpkin: you get a more informative error if you first split p into two cases, then ask agda to split q for you with C-c C-c
11:09:56 <chrisdone> (pretty sure it isn't)
11:10:13 <ccasin> ccasin: I've seen that more informative error before, so I'm trying to reconstruct what I did then
11:10:16 <chrisdone> zygoloid: oh you were joking :D
11:10:20 <ccasin> oops... wrote my own name...
11:10:42 <copumpkin> no
11:10:44 <zygoloid> chrisdone: well, it's sorta-kinda locally context-free, if you parse a statement at a time, maybe ;-)
11:10:53 <dancor> how is the Fractional instance decided in > 26/6
11:11:11 <monochrom> probably defaults to Double
11:11:13 <chrisdone> zygoloid: http://github.com/chrisdone/pappy
11:11:13 <chrisdone> zygoloid: looks good, I'll upload it
11:11:20 <ccasin> copumpkin: let's take it to #agda
11:11:25 <copumpkin> ccasin: that's how I wrote it at first, then fudged with it for a while and got to the ugliness I sent you
11:11:37 <copumpkin> ccasin: ok
11:12:19 <chrisdone> hmmm. cute: http://hackage.haskell.org/packages/archive/generator/0.5.1/doc/html/Data-List-Class.html
11:12:47 <EvanR-work> is there an esoteric language that is easy to understand and write programs in but 'esoterically difficult' to implement?
11:13:13 <chrisdone> seems like it might've been developed before Foldable and Traversable
11:15:41 <joyfulgirl> EvanR-work: You might do a google search for the esoteric language list...I think such a thing exists
11:16:40 <BMeph> EvanR-work: I'm looking to Haskellize the OCaml workup of Levien's Io "notation"... ;)
11:16:44 <chrisdone> EvanR-work: a lazy language will be hard to implement
11:17:05 <EvanR-work> lazy is not hard
11:17:22 <chrisdone> EvanR-work: well, Simon Peyton-Jones disagrees 
11:17:28 <zygoloid> EvanR-work: behavioural verilog. produce a compiler to optimized silicon and copper ;-)
11:17:30 <roconnor> EvanR-work: Isn't Haskell and example of what you seek?
11:17:52 <copumpkin> reductio ad simonum
11:17:54 * chrisdone shams newsham 
11:17:56 <chrisdone> copumpkin: :D
11:18:07 <EvanR-work> haskell without type inferrence is pretty easy
11:18:11 <EvanR-work> and still works
11:18:27 <EvanR-work> right?
11:18:49 <copumpkin> you get a polymorphic agda minus the dependent types and its super weak inference
11:19:05 <copumpkin> with a more restrictive grammar and no do notation or list or tuple sugar
11:19:28 <roconnor> EvanR-work: if you count segfaults as works
11:19:44 <JoeyA> Is it possible to express getLine >>= putStrLn on the applicative functor level rather than the monad level?  That is, can these actions be combined in this fashion with <*> and <$> ?
11:19:59 <EvanR-work> haskell has many implementations, and i read a book on graph machines, so clearly its no esoteric enough
11:20:03 <copumpkin> JoeyA: no
11:20:35 <chrisdone> let peyton = (++) . (++"E"); jones = "D"; simon = "Q" in simon `peyton` jones
11:20:38 <chrisdone> > let peyton = (++) . (++"E"); jones = "D"; simon = "Q" in simon `peyton` jones
11:20:40 <lambdabot>   "QED"
11:20:48 <copumpkin> JoeyA: you'll need join if you use those
11:20:48 <copumpkin> :t fmap putStrLn getLine
11:20:49 <g_cross> JoeyA:  You can't use the Applicative style when the second action depends on the result of the first.
11:20:49 <lambdabot> IO (IO ())
11:20:52 <copumpkin> :t join $ fmap putStrLn getLine
11:20:54 <lambdabot> IO ()
11:21:37 <EvanR-work> :t join
11:21:38 <chrisdone> haskell's easier to if you're writing an interpreter in haskell
11:21:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:21:46 <chrisdone> <_<
11:21:50 <copumpkin> it's a monad thing
11:21:56 <mtnviewmark> @src join
11:21:57 <lambdabot> join x =  x >>= id
11:22:11 <EvanR-work> yeah
11:22:25 <BMeph> EvanR-work: Here's a link to the paper ('cause there HAS to be a paper for it, right?) describing what I'm looking at: http://bit.ly/9bvYkv
11:22:36 <EvanR-work> chrisdone: see, using a nicer language makes implementing another language easier. what about a language which no one can implement in any language ;)
11:22:56 <aristid> :t join $ putStrLn <$> getLine
11:22:57 <lambdabot> IO ()
11:23:08 <JoeyA> So, taking IO for example, Functor is simply the notion of applying a function to the result of performing the action.  Applicative brings sequence into the picture, but doesn't let you pass the result of one action to the next (unless you're only interested in tweaking the latter's output).
11:23:09 <EvanR-work> BMeph: i meant to lol at your remark earlier but never got to it
11:23:37 <aristid> JoeyA: and Monad adds join / >>=
11:23:52 <g_cross> JoeyA:  Exactly!
11:24:16 <g_cross> JoeyA: Applicative lets you sequence actions and combine their results, but you lose the ability to have some actions influence others.
11:24:25 <JoeyA> (\x -> (x +)) <$> (putStrLn "first" >> readLn) <*> (putStrLn "second" >> return 5)
11:24:32 <BMeph> EvanR-work: Which one? I do so much to "lol" at, I'm never sure... ;)
11:24:39 <JoeyA> pretend the >> stuff is premade actions.
11:25:00 <JoeyA> This demonstrates that Applicative lets you sequence, but not change what the second action actually does.
11:25:06 <aristid> JoeyA: (>>) is in Applicative if you write it as (*>)
11:25:28 <JoeyA> @src *>
11:25:29 <lambdabot> (*>) = liftA2 (const id)
11:25:33 <JoeyA> cool
11:25:35 <aristid> :t [(>>), (*>)]
11:25:36 <lambdabot> forall (m :: * -> *) a b. (Monad m, Applicative m) => [m a -> m b -> m b]
11:26:22 <aristid> JoeyA: and (\x -> (x +)) is the same as (+), isn't it?
11:26:33 <JoeyA> yes
11:26:47 <sproingie> so Applicative has >> but not >>= ?
11:26:53 <aristid> sproingie: yeah
11:27:16 <chrisdone> applicative functors -- the key word is 'functors'
11:27:27 <JoeyA> I'm playing with the idea of writing a monadic parser combinator.  The thing I don't like about Parsec is that it doesn't perform nondeterministic matching by default.
11:27:32 * hackagebot pappy 0.1 - Packrat parsing; linear-time parsers for grammars in TDPL.  http://hackage.haskell.org/package/pappy-0.1 (ChrisDone)
11:27:34 <chrisdone> :t (<*>)
11:27:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:27:51 <BMeph> Monad lets you use the results of one action to influence another action. Thus, "Monad is promiscuous." 
11:28:04 <JoeyA> optional (string "amy") >> "ambiguous"
11:28:06 <chrisdone> f (a -> b), but no a -> f b
11:28:29 <JoeyA> err, string "amy" <|> string "ambiguous"
11:28:44 <JoeyA> In Parsec, this will fail if you have the string "ambiguous" as input.
11:29:02 <chrisdone> JoeyA: yeah, i'd use Applicative and Alternative where possible
11:29:35 <JoeyA> Parsec makes you left-factor your rules to weed out nondeterminism.
11:30:16 <JoeyA> Meaning the code used for parsers (unless you bring in chain1 and such, I guess) is a lot like code written by hand.
11:30:32 * hackagebot on-a-horse 0.1 - "Haskell on a Horse" - A combinatorial web framework  http://hackage.haskell.org/package/on-a-horse-0.1 (JasonPriestley)
11:30:44 <chrisdone> another web framework!
11:30:49 <c_wraith> wtf.  that package name is frightening
11:31:00 <chrisdone> i think more web frameworks are written in Haskell than any other language
11:31:21 <danderson> seriously?
11:31:27 <roconnor> Ruby on Rail, Python on Planes, Haskell on a Horse
11:31:28 <danderson> python has around 5 really popular
11:31:36 <danderson> and dozens more obscure ones
11:31:52 <JoeyA> Python on Planes... clever :D
11:31:55 <Heffalump> whereas Haskell has several obscure ones :-)
11:31:57 <chrisdone> i meant 'written' in the present form
11:32:23 <chrisdone> i mean, since last year a new haskell web framework seems to be popping up once every one or two months
11:32:29 <dino-> Maybe we can zazz that up more than horses or rails. Hydrogen Powered Haskell!
11:32:59 <monochrom> web frameworks proliferate like nuclear weapons
11:33:24 <dino-> monochrom: Haskell on Hydrogen Bombs?
11:33:26 <mornfall> Cold War 2.0
11:33:46 <chrisdone> "Please read the introduction at http:haskell.on-a-horse.org", someone should've tested before uploading ;-)
11:34:14 <Phyx-> a lazy bomb....
11:34:20 <Phyx-> how would that work..
11:34:25 <JoeyA> Haskell on a Hare?
11:34:32 <jmcarthur> haskell on a horse!
11:34:40 <JoeyA> lol
11:34:51 <Phyx-> Haskell on a Hill
11:34:57 <chrisdone> haskell on a hoares would've been cleverer
11:35:06 <jmcarthur> lol
11:35:23 <jmcarthur> how is that pronounced?
11:35:26 <solrize> http://coboloncogs.org 
11:35:35 <BMeph> chrisdone: "i c wat u did ther..." ;)
11:35:39 <monochrom> software-for-profit has not really changed. programmers still re-invent the soccer ball to justify their purpose of existence.
11:36:29 <jmcarthur> we need Smalltalk on a Segway now
11:36:30 <monochrom> 10 years ago in #math it was all about "hi what math do I need to write yet another graphics engine for games?"
11:36:35 <chrisdone> jmcarthur: hahaha
11:36:53 <jmcarthur> Perl on a Pogostick?
11:37:03 <monochrom> now it has just changed to "yet another web thingy"
11:37:22 <JoeyA> C on a Cane
11:37:22 <jmcarthur> wait, people went to #math to talk about graphics engines?
11:37:31 <BMeph> jmcarthur: I thought the Smalltalk one was called Seaside? ;)
11:37:31 <monochrom> yes
11:37:33 <aristid> jmcarthur: you need vectors!
11:37:35 <chrisdone> wait, people went to math to talk?
11:37:38 <jmcarthur> *sigh*
11:37:47 <jmcarthur> wector wector wector
11:37:59 <aristid> hector
11:38:12 <chrisdone> the salvia web package is actually pretty awesome, i saw the guy demonstrating it at zurihac
11:38:17 <monochrom> I guess you have to give them credit for knowing to ask in #math
11:38:52 <Phyx-> jmcarthur: lol, that reminds me of star trek
11:39:02 <jmcarthur> Phyx-: then you got the reference
11:39:05 <Phyx-> hehehe
11:39:07 * BMeph is "seriously" thinking of naming the Haskell rewrite of Amalthea (OCaml's implementation of Io) "Hebe"...
11:39:16 <chrisdone> hebe is a nice name
11:39:32 <EvanR-work> nuclear wessels
11:39:38 <sproingie> then you can write a companion named Jebe
11:39:46 <monadic_kid> anyone got any ideas for a simple way to replace mult-parameter type classes in the SDL bindings?
11:39:56 <jmcarthur> EvanR-work: that was the worst star trek movie ever made
11:39:57 <BMeph> chrisdone: So what do you call folks who use that package, "salviators"? ;)
11:40:08 <Zao> If you like it, are you a hebephile then?
11:40:14 <sproingie> i want to read salvia as saliva
11:40:14 <chrisdone> BMeph: druggies
11:40:27 <chrisdone> BMeph: the author is from the netherlands after all
11:40:55 <monadic_kid> I wanna change this to not use multi-param type-classes http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/Graphics-UI-SDL-Utilities.html
11:41:51 <jmcarthur> type families instead?
11:41:53 <zygoloid> monadic_kid: class Enum a where type EnumBits a :: *
11:42:04 <BMeph> monadic_kid:  ...and do you have some other mechanism that you _do_ want it to use? ;)
11:42:18 <EvanR-work> jmcarthur: it was my favorite as a kid
11:42:39 <jmcarthur> EvanR-work: sorry to piss your cheerios ;)
11:42:56 <EvanR-work> ._.
11:43:02 <monadic_kid> BMeph: trying to build sdl bindings with jhc which doesn't support type classes, so i can build them with the Wii SDL port
11:43:02 <EvanR-work> but yeah it was pretty bad
11:43:08 <EvanR-work> but search for spock was worse
11:43:20 <monadic_kid> BMeph: sorry i mean doesn't support multi-param type-classes
11:43:29 <zygoloid> monadic_kid: make them all use Word32
11:43:30 <zygoloid> ?
11:43:50 <BMeph> monadic_kid: There ya go, thanks! It's always more helpful to know how we can help, instead of how we can't... :)
11:43:50 <monadic_kid> zygoloid: good point
11:44:51 <BMeph> EvanR-work: There's an Engineer Manager where I work, named "Wessels". Guess what I call him? :)
11:46:16 <jmcarthur> Wector? ;)
11:46:30 <jmcarthur> Wictor, is what i meant
11:46:51 <EvanR-work> nuclear
11:46:59 <EvanR-work> chekov?
11:47:05 <jmcarthur> SPOCK oh wait
11:47:16 <jmcarthur> i'm thinking chekov
11:47:44 <jmcarthur> han solo, final answer
11:47:57 * jmcarthur ducks
11:48:38 <monadic_kid> zygoloid: looking at the instances list on haddoc, the second type parameter is not always Word32
11:49:32 <Veinor> hm
11:49:51 <Veinor> if I'm writing a shell prompt in Haskell, which category on hackage d'you think that'd fall under?
11:49:54 <Veinor> System?
11:51:01 <EvanR-work> BMeph: this Io thing is pretty cool
11:53:11 <ozataman> Hey all.. If I am trying to read off the "p" value deep inside this data structure, how would I do it the best:
11:53:13 <ozataman> Right (JObject (fromList [("663012871",JObject (fromList [("lb",JString "kingyorkie"),("p",JNumber (4543 % 100)),("sl",JNumber (14 % 1))]))]))
11:54:52 <EvanR-work> composed accessors
11:55:12 <EvanR-work> or a better structure ;)
11:55:22 <ezyang> Veinor: Might even be an application? 
11:55:24 <kmc> i used this once http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28287#a28287
11:55:29 <kmc> ozataman, might be useful to you
11:55:40 <ozataman> hm it is a real disadvantage that one can't simply do result["663012871"]["p"]
11:56:12 <kmc> well you can use Data.Map.
11:56:16 <Veinor> ezyang: yeah, I think it's going to be an executable under System
11:56:16 <kmc> i mean Data.Map.!
11:56:35 <EvanR-work> (lookup "p") . (lookup "663012871")
11:56:59 <EvanR-work> :t Data.Map.!
11:57:00 <lambdabot> parse error on input `Data.Map.!'
11:57:06 <kmc> :t (Data.Map.!)
11:57:08 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
11:57:26 <EvanR-work> bah doesnt take the key first
11:57:32 <EvanR-work> flip
11:57:57 <ozataman> EvanR-work: right, but how do I do that in this data structure?
11:58:29 <kmc> you could probably write a lib to access it nicely with fclabels or lenses or data-accessor
11:58:39 <kmc> or a smaller hack like the one i pasted
11:58:53 <aavogt> but which one?
11:59:01 <EvanR-work> you can also write a pattern match
11:59:05 <EvanR-work> i think
11:59:12 <kmc> no, because Map is abstract
11:59:18 <EvanR-work> bah
11:59:22 <ozataman> people need to stop writing ADT based parsers.. everything should parse into Data.Map!!
11:59:22 <kmc> you can use view patterns or pattern guards though
11:59:32 <kmc> ozataman, heh
11:59:45 <kmc> this *does* parse into Data.Map, and it's the more difficult part to deal with
11:59:52 <kmc> if it were just an ADT you could pattern match directly
12:00:27 <kmc> ozataman, with my hack you would say walkOne (key "663012871" :=> key "p" :=> End) obj
12:00:49 <ozataman> kmc: yeah I see your point
12:00:54 <ozataman> kmc: OK, let me try that
12:00:57 <kmc> basically you could retool this hack to give a fclabel instead of a simple accessor
12:01:05 <kmc> and then you could use it for modification as well
12:01:42 * hackagebot Annotations 0.1.1 - Constructing, analyzing and destructing annotated trees  http://hackage.haskell.org/package/Annotations-0.1.1 (MartijnVanSteenbergen)
12:02:40 <Apocalisp> f (a `Either` b) -> (f a, f b) -- for which f can this be implemented?
12:03:18 <kmc> contravariant functors
12:03:31 <kmc> type F 
12:03:33 <kmc> err
12:03:53 <kmc> type F t = t -> r
12:04:09 <kmc> e.g. ((a `Either` b) -> r) -> (a -> r, b -> r)
12:04:10 <Phyx-> Bazinga
12:04:27 <Apocalisp> @djinn Maybe (Either a b) -> (Maybe a, Maybe b)
12:04:28 <lambdabot> f a =
12:04:28 <lambdabot>     case a of
12:04:28 <lambdabot>     Nothing -> (Nothing, Nothing)
12:04:28 <lambdabot>     Just b -> case b of
12:04:28 <lambdabot>               Left c -> (Just c, Nothing)
12:04:30 <lambdabot>               Right d -> (Nothing, Just d)
12:04:32 <kmc> :t \f -> (f . Left, f . Right)
12:04:34 <lambdabot> forall b a b1. (Either a b1 -> b) -> (a -> b, b1 -> b)
12:04:48 <kmc> :t (.Left) &&& (.Right)
12:04:50 <lambdabot> forall b a b1. (Either a b1 -> b) -> (a -> b, b1 -> b)
12:05:21 <Apocalisp> kmc: cool, I hadn't thought of that
12:06:01 <mauke> :t liftA2 (,) (. Left) (. Right)
12:06:03 <lambdabot> forall b a b1. (Either a b1 -> b) -> (a -> b, b1 -> b)
12:08:00 <aristid> @. pl djinn Maybe (Either a b) -> (Maybe a, Maybe b)
12:08:01 <lambdabot> (line 3, column 13):
12:08:01 <lambdabot> unexpected ">" or "-"
12:08:01 <lambdabot> expecting variable, "(", operator or end of input
12:08:13 <aristid> too bad :D
12:08:31 <monadic_kid> okay I had an idea how to do this with minmal change to the code, I change the Enum multi-param type-class into a small set of type-classes called EnumWord32, EnumWord8, EnumInt, etc
12:09:02 <monadic_kid> then I only  need just change the name of the instance
12:09:21 <Apocalisp> @pl f a = case a of Nothing -> (Nothing, Nothing); Just b -> case b of Left c -> (Just c, Nothing); Right d -> (Nothing, Just d)
12:09:22 <lambdabot> (line 1, column 25):
12:09:22 <lambdabot> unexpected ">" or "-"
12:09:22 <lambdabot> expecting variable, "(", operator or end of input
12:09:31 <Apocalisp> oh, right
12:11:44 <Apocalisp> @pl f a = maybe (Nothing, Nothing) (\b -> either (\c -> (Just c, Nothing)) (\d -> (Nothing, Just d)))
12:11:45 <lambdabot> f = const (maybe (Nothing, Nothing) (const (either (flip (,) Nothing . Just) ((,) Nothing . Just))))
12:12:02 <monadic_kid> nope that doesn't work
12:12:53 <aristid> :t maybe (Nothing, Nothing) $ either Just (const Nothing) &&& either (const Nothing) Just
12:12:55 <lambdabot> forall a a1. Maybe (Either a a1) -> (Maybe a, Maybe a1)
12:13:04 <aristid> that looks right, no?
12:15:19 <Veinor> ... why do I have base-3 and base-4?
12:15:29 <copumpkin> compatibility
12:15:46 <Veinor> it's causing spew when I install stuff
12:15:54 <Nibble> hello, I am having problems with cabal
12:15:59 <handonson> ...
12:16:02 <Nibble> it will not recognize installed packages
12:16:04 <EvanR-work> hahaha
12:16:09 <Nibble> cabel*
12:16:25 <mauke> *cabal
12:16:27 <Veinor> Nibble: what do you mean?
12:16:28 <monadic_kid> any ideas to replace multi-param type-classes with something haskell98 compatible?
12:16:34 <aristid> Nibble: why did you "correct" your correct spelling into a wrong one?
12:16:46 <ezrakilty> an FRP system that could produce demos like processing's would be killer.
12:16:57 <Nibble> aristid: because I thought that was what the newcomer-hostile handonson was complaining about
12:17:07 <Nibble> I thought cabel would fit better in his ass... or something
12:17:14 <Nibble> Veinor: well
12:17:20 <copumpkin> Nibble: lol
12:17:39 <Nibble> Veinor: I first run cabel update
12:17:45 <copumpkin> Nibble: he might have been responding to what Veinor said a second before you joined, fwiw :)
12:17:47 <mauke> Nibble: cut it out
12:17:48 <Nibble> then cabel install cabel-install --global
12:18:04 <Nibble> mauke: it is no specific problem with one install
12:18:23 <Nibble> Veinor: but it keeps wanting to update to the same version I just updated to
12:18:26 <handonson> Nibble: someone was complaining about cabal right before you entered. i thought, what a coincidence. no more than that. don't interpret everything to hostility
12:18:28 <Nibble> and says that there is a never version
12:18:32 <aristid> somehow i think that Nibble is a troll.
12:18:42 <Nibble> ..
12:18:44 <Nibble> I am not
12:18:53 <Nibble> but back to my problem
12:19:04 <aristid> Nibble: you say things like "I thought cabel would fit better in his ass"
12:19:15 <Nibble> aristid: because from my point of view
12:19:21 <copumpkin> let's not go calling each other trolls yet
12:19:23 <Nibble> he was just being a dumbass
12:19:29 <handonson> was I?
12:19:30 <Nibble> 21:15 < Nibble> hello, I am having problems with cabal
12:19:30 <Nibble> 21:15 < handonson> ...
12:19:30 <Nibble> 21:15 < Nibble> hello, I am having problems with cabal
12:19:30 <Nibble> 21:15 < handonson> ...
12:19:31 <Nibble> 21:15 < Nibble> hello, I am having problems with cabal
12:19:41 * chrisdone golf claps
12:19:49 <EvanR-work> ._.
12:20:13 <handonson> ...maybe this is a proof that Haskell is gaining more and more popularity.
12:20:20 <copumpkin> Nibble: not everything is about you on IRC :) you join a room with 600 people and someone says something as soon as you join, it might not even be directed at you. It's usually safer to make sure it was directed at you before taking offense. Let's get on with haskell now, everyone? :)
12:20:21 <Nibble> hoddamit
12:20:23 <Nibble> goddammit*
12:20:29 <mauke> Nibble: you are not the center of the universe
12:20:48 <Nibble> damn, didn't see the text come so I was kicked for flooding
12:21:00 <copumpkin> yeah, pasting stuff into channels is not a good idea in general
12:21:14 <Nibble> copumpkin: But back to my problem
12:21:20 <copumpkin> yep
12:21:29 <copumpkin> cabal won't recognize in what way?
12:21:40 <Saizan> Nibble: so you "cabal install cabal-install" and then it still asks you to upgrade cabal-install later?
12:21:57 <Nibble> Saizan: yes
12:22:05 <EvanR-work> you guys are some tolerant ass people
12:22:05 <Nibble> and when trying to install gtk2hs-buildtools
12:22:19 <copumpkin> EvanR-work: that's #haskell for you :P
12:22:26 <Saizan> Nibble: if that's what's happening, the most probable reason is that you've multiple "cabal" executables in you $PATH at this point, and the older cabal is masking the newly installed one
12:22:39 <EvanR-work> copumpkin: not used to it ;)
12:22:39 <Nibble> Saizan: ok
12:22:50 <Saizan> Nibble: cabal will install executables under "~/.cabal/bin" by default
12:22:57 <mauke> EvanR-work: who are you calling ass people!
12:23:03 <aristid> EvanR-work: heh that reminds me of the xkcd about switching hyphens... sweet-ass car becomes sweet ass-car :D
12:23:11 <EvanR-work> yes
12:23:17 <Nibble> Saizan: only one there
12:23:24 <EvanR-work> i thought about putting the hyphen between ass and people
12:23:34 <Nibble> Saizan: It does not recognize installed pacakges
12:23:37 <Nibble> packages*
12:23:57 <Nibble> Saizan: any ideas?
12:24:07 <Saizan> cabal doesn't maintain any registry of installed executables, it looks into your $PATH
12:24:18 <Saizan> for libraries there's "ghc-pkg list"
12:24:30 <Nibble> Saizan: but as I said
12:24:40 <Nibble> it doesn't recognize other packages either
12:24:42 <eikke> if I want to write a server application in haskell (for a custom protocol), are there any recommended hackage libs to look into which might be useful, instead of writing the server loop etc myself?
12:25:09 <Saizan> Nibble: that's too vague, what errors are you getting? are those packages libraries? do they show in ghc-pkg list ?
12:25:16 <handonson> eikke: hlibev?
12:25:42 <Nibble> Saizan: no they do not show up
12:26:14 <Nibble> Saizan: wait, will get errors
12:26:21 <Saizan> then either they don't contain a library or they weren't installed
12:26:35 <Nibble> http://beta.yapaste.com/Ud
12:26:44 <Nibble> like that one
12:26:47 <tibbe> eikke: just use a forkIO per connection, the attoparsec library for parsing and network-bytestring for networking
12:26:48 <Nibble> but I have already installed alex
12:27:44 <eikke> handonson: I dont think libev will be required, it's not highly-concurrent
12:27:47 <EvanR-work> eikke: the loop is forever accept forkIO ;)
12:27:52 <tibbe> eikke: forkIO is implemented using a thread pool for CPU bound tasks and select() for tasks waiting for I/O
12:27:55 <Nibble> so
12:27:56 <Saizan> Nibble: what does "which alex" say?
12:28:13 <Nibble> Saizan: which: no alex in (/bin:/usr/bin:/sbin:/usr/sbin:/usr/bin/perlbin/site:/usr/bin/perlbin/vendor:/usr/bin/perlbin/core)
12:28:24 <tibbe> eikke: forkIO will handle a few hundred concurrent requests (after GHC 6.14 it will handle tens of thousands)
12:28:25 <Nibble> Saizan: but I have executable in .cabal/bin
12:28:31 <eikke> the thing is: I know how to write the accept loop/forkio stuff, but I wonder whether there's some lib which already has code for this, since its something which one often needs i guess
12:28:46 <Nibble> eikke: I haven't found any
12:28:54 <Nibble> eikke: write one and maky a library for it :)
12:28:56 <EvanR-work> is trivial
12:28:57 <tibbe> eikke: not really, I thought about writing a tcp-server lib that does some of the heavy lifting
12:29:01 <Saizan> Nibble: try "cabal install --root-cmd=sudo gtk2hs-buildtools"
12:29:28 <Saizan> Nibble: and make sure $HOME/.cabal/bin is in your user's $PATH
12:29:34 <eikke> tibbe: that's it :) are you the guy who wrote the epoll binding?
12:29:41 <Nibble> Saizan: that might be it ;)
12:29:56 <Saizan> Nibble: i told you from the start it was a $PATH problem.
12:30:01 <EvanR-work> ghc should be using epoll for you
12:30:16 <tibbe> eikke: Bryan O'Sullivan and I wrote the new I/O manager for GHC
12:30:28 <tibbe> eikke: it does epoll among other things (e.g. kqueue)
12:30:40 <eikke> interesting
12:30:43 <Nibble> Saizan: sure. but I just started with haskell yesterday night and installd cabal a few minutes ago so it was a bit too many new things to keep track of
12:30:59 <kmc> :t contramap
12:31:00 <lambdabot> Not in scope: `contramap'
12:31:01 <Nibble> especially since I thought using --global on installs would remove the path problem
12:31:37 <Nibble> anyhow
12:31:49 <aristid> kmc: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Contra.html
12:31:53 <Saizan> you didn't install alex with --global though, anyhow use --root-cmd=sudo rather than "sudo .."
12:31:54 <Nibble> I am back to programming haskell, I have a few questions soon so don't leave yet :P
12:32:02 <tibbe> (chatting in several windows right now, please mention my name in any message so my IRC client notifies me)
12:32:21 * tibbe is validating the new I/O manager patches on Windows
12:32:25 <Nibble> Saizan: I did indeed install with --global
12:32:33 <Nibble> I tried it with cabal too
12:32:57 <Saizan> with --global executables go into /usr/local/bin by default
12:33:09 <Nibble> Saizan: types, I am not really getting the whole concept
12:33:14 <danderson> jystic: sorry, I wandered off and got caught in other stuff, but still interested in chatting at some point
12:33:29 <kmc> :t let contramap :: (a -> b) -> f b -> f a; contramap = undefined in contramap Left &&& contramap Right
12:33:31 <lambdabot> forall a b (f :: * -> *). f (Either a b) -> (f a, f b)
12:34:15 <Nibble> I understand that I can specify my own types, but I first imagined them as objects
12:34:36 <aristid> kmc: Maybe is a ContraFunctor?
12:34:39 <Nibble> I soon realised that thinking of them like that is wrong, and that they are more functions
12:34:42 <kmc> aristid, no
12:34:46 <eikke> if a type is both a Functor and a Monad, can I generally say fmap == liftM ?
12:34:51 <aristid> kmc: :(
12:34:51 <kmc> eikke, yes
12:35:01 <kmc> Nibble, a type is a little like a class from OOP, but you're best off forgetting whatever you know about OOP for now
12:35:07 <eikke> ty!
12:35:07 <Nibble> could anyone with a bit of time (very) briefly sum them
12:35:09 <Nibble> kmc: ye
12:35:12 <kmc> once you understand Haskell better, you'll understand better how to encode OOP in it
12:35:13 <Nibble> I understand that
12:35:29 <Nibble> kmc: I have covered basically everything up to types
12:35:38 <mauke> how are types like functions?
12:35:47 <kmc> in particular, Haskell beginners often overuse Haskell's type-class feature, because they think it's as central as the thing called "class" in OOP
12:35:55 <tibbe> eikke: all monads are functors
12:35:57 <aristid> kmc: so your contramap code has almost the correct type except for ContraFunctor not allowing Maybe?
12:36:06 <aristid> tibbe: except in haskell
12:36:08 <Nibble> mauke: I meant more that my view of them was wrong
12:36:14 <tibbe> aristid: right, a small oversight ;)
12:36:15 <kmc> aristid, err, it's the correct type for what Apocalisp was asking originally
12:36:42 <eikke> tibbe: i figured, yes
12:36:45 <kmc> Nibble, it's hard to summarize "types" in a few sentences.  about as hard as summarizing "how to write correct programs"
12:36:45 <aristid> tibbe: i wonder if that will be fixed sometime
12:37:04 <Nibble> kmc: could you explain to me then how they are supposed to be used
12:37:10 <aristid> kmc: what was Apocalisp asking for originally?
12:37:21 <Nibble> like an example definition of a Coordinate point, and use that in a type called Particle
12:37:21 <kmc> types are used to describe properties of our programs
12:37:30 <kmc> what sorts of values functions accept, and what they guarantee to return
12:37:31 <chrisdone> hmm, google's new image search seems to have regressed
12:37:45 <kmc> we do this so that the computer can check some of the correctness properties of our program, before we even run it
12:37:56 <Nibble> kmc: you are talking to me, right?
12:37:58 <kmc> we also use it to specify data we'd like to store
12:37:59 <kmc> yes
12:38:07 <Nibble> that is what static typing is for
12:38:08 <Nibble> right?
12:38:14 <kmc> but unlike C types, we're not specifying low-level details of the machine-level representation
12:38:15 <kmc> yes
12:38:22 <Nibble> kmc: I understand that part
12:38:24 <kmc> i'm describing Haskell's type system
12:38:24 <kmc> ok
12:38:35 <Nibble> kmc: it is just the syntax I am struggling with
12:38:40 <Nibble> like when to use paranthesis
12:38:41 <kmc> ohh
12:38:46 <kmc> well, syntax is the easy part
12:38:48 <mauke> oh, syntax is trivial
12:38:49 <kmc> compared to concepts
12:38:51 <mauke> :-)
12:39:07 <Nibble> kmc: Well, considering I am 14 I think I grasp the concepts fairly well
12:39:16 <kmc> if you are confused about the syntax for X, you should say so; if you ask for an explanation of X itself you will probably get a pile of theory :)
12:39:18 <kmc> someone else here will help you, i've got to go though
12:39:20 <kmc> ttyl good luck :)
12:39:27 <micahjohnston> I might be able to help
12:39:29 <Nibble> kmc: thanks for your time
12:39:42 <Nibble> micahjohnston: sounds great, take it in PM beacuse it is a bit flooded here?
12:39:45 <micahjohnston> ok
12:39:57 <jmcarthur> no it belongs here :)
12:40:21 <chrisdone> PM stands for proprietary!
12:40:22 <Nibble> jmcarthur: sure, but it is hard to write when there is so much flood
12:40:30 <tibbe> aristid: I think was needed is a way to add new super classes after the fact; even if we fix Functor/Applicative now we'll have the same problem again in a few years.
12:40:31 <jmcarthur> i don't see any
12:40:56 <Nibble> chrisdone: then consider this properitary
12:41:12 <aristid> tibbe: well maybe class aliases and such things can help
12:41:20 <tibbe> aristid: yes
12:41:36 <tibbe> aristid: if we just switched over today we'd break a lot of code
12:41:58 <aristid> tibbe: mostly instances of Monad, right?
12:42:10 <tibbe> aristid: yes
12:42:31 <aristid> tibbe: constructing superclass function implementations from subclasses might help too
12:42:38 <tibbe> aristid: also if we added instances for core types we might break code that also adds instances for those types
12:42:39 <aristid> like fmap = liftM
12:42:41 <Apocalisp> kmc: Yeah, so I guess I could say that f:C=>D takes coproducts in C to products in D. That would be true for contravariant functors, and a zoo of others.
12:42:59 <tibbe> aristid: I think we need a mechanism to control visibility of type classes
12:43:10 <Apocalisp> kmc: Not all that interesting a property I guess :)
12:43:32 <monadic_kid> i'm still struggling to think of way to change  a code base that uses multi-param type-classes to a haskell98 compatable solution, the best i can think of is to define a number of type-classes for which of the second type parameter and also slightly change the function name for each type
12:45:44 <jmcarthur> which kind of defeats the purpose
12:47:10 <jmcarthur> monadic_kid: if you can come up with a sufficient constraint for the result type then you could translate something like (class Foo a b where foo :: a -> b) to something like (class Foo a where foo :: Bar b => a -> b)
12:47:39 <jmcarthur> that's not going to be good for replacing MPTCs in general, but maybe in some specific instances
12:49:11 <monadic_kid> one thing i've learn is never write haskell extensions in binding libraries!
12:53:14 <uranther> i'm trying to build LambdaBot. I installed all the deps using cabal install (prefix is set to ~/.cabal)
12:53:28 <uranther> how do i point runhaskell Setup configure to that dir? --prefix doesn't seem to work
12:53:41 <micahjohnston> :t add
12:53:42 <lambdabot> Not in scope: `add'
12:55:47 <byorgey> uranther: you shouldn't need to point runhaskell Setup configure to that dir.
12:56:03 <byorgey> uranther: but you might need to give a --user flag so that it looks in your local user packages
12:57:53 <ClaudiusMaximus> you can run "cabal install" from the directory containing the Setup.hs and it will install it, that's what i do when i'm testing
12:59:02 <ClaudiusMaximus> i've only tried it with a few packages, not sure if it would work for everyone, and i'm pretty sure it needs a .cabal file
12:59:59 <mornfall> ClaudiusMaximus: It's a normal and supported workflow (using cabal install in the root of an unpacked cabal package).
13:00:14 <ClaudiusMaximus> mornfall: great :)
13:00:36 <mornfall> ClaudiusMaximus: Although if you are working on the package, cabal configure + cabal build + cabal copy + cabal register may be more appropriate.
13:00:51 <mornfall> ClaudiusMaximus: (Since you can avoid the unnecessary steps, which cabal install always runs)
13:01:17 <ClaudiusMaximus> what are those other steps?
13:01:31 * ClaudiusMaximus should rtfm
13:02:24 * byorgey wonders what the other steps are too
13:02:27 <danderson> just to be sure, there's nothing in the well-known libs that implements a whileM ? (while condition action true, run then-action, when condition fails return m [results])
13:02:43 <danderson> easy to implement, just wondering if I'm going to reinvent a wheel with a slightly different shape
13:02:43 <byorgey> danderson: have you looked in the IfElse package?
13:02:55 <byorgey> I don't know if whileM specifically is in there
13:02:57 <danderson> nope, looking
13:03:02 <danderson> whileM is.
13:03:18 * danderson curses hoogle for not returning it when he searched quite exactly for "whileM"
13:03:45 <byorgey> hoogle doesn't index everything on hackage.
13:03:51 <jmcarthur> monadic_kid: why not?
13:03:57 <danderson> byorgey: how come?
13:04:06 <byorgey> it's too big.
13:04:14 <byorgey> if you want to search all of hackage, try hayoo.
13:04:17 <danderson> oh
13:04:20 <byorgey> but hayoo can't do type search.
13:04:21 <danderson> that's backwards
13:04:40 <danderson> searching a subset of the whole should be called hing, not hoogle :P
13:04:49 <byorgey> hehehe
13:04:50 <danderson> (cheap shot, I know, thanks for the tips)
13:05:22 <monoidal> anyone know if UHC has interactive mode, like ghci
13:05:24 <monoidal> ?
13:05:25 <ClaudiusMaximus> if you know the package name, you can hoogle "whileM +ifelse" and get the answer, but that's not that much help
13:05:45 <danderson> ClaudiusMaximus: yeah, the point here is that I know what I, the average joe, might name the function
13:05:52 <ClaudiusMaximus> danderson: i know
13:05:58 <danderson> and want to see if another average joe implemented it :)
13:06:00 <Veinor> which package should I use to do terminal colors?
13:06:09 <byorgey> ClaudiusMaximus: huh, I didn't know you could do that. nice.
13:06:10 <ClaudiusMaximus> ansi-terminal maybe?
13:06:12 <meteficha> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:whileM
13:06:26 <ClaudiusMaximus> hscolour has some terminal stuff in it
13:06:36 <meteficha> oops, does that link work at all? =/
13:06:47 <meteficha> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=whileM&start=0
13:07:43 <ClaudiusMaximus> byorgey: it's very useful for searching OpenGL stuff
13:07:44 <meteficha> so, monad-loops has whileM :: m Bool -> m a -> m [a]
13:08:14 <danderson> argh, except IfElse's version doesn't accumulate results. Bah.
13:08:18 <danderson> oh, there we go then
13:08:28 <danderson> meteficha: cheers
13:08:34 <aristid> meteficha: nice.
13:08:40 <monadic_kid> jmcarthur: Makes it less usable in other haskell compilers that don't support those extensions
13:08:44 <aristid> meteficha: iterateWhile looks nice too
13:08:53 <jmcarthur> ah
13:09:08 <jmcarthur> what compiler are you using that doesn't support MPTCs?
13:09:14 <monadic_kid> jmcarthur: jhc
13:09:19 <jmcarthur> aha
13:09:24 <meteficha> danderson: no problem :)
13:09:27 <jmcarthur> oh are you the one doing the wii stuff?
13:09:34 <monadic_kid> jmcarthur: yeah
13:09:39 <jmcarthur> cool stuff
13:10:23 <monadic_kid> jmcarthur: my next step is aiming for Wii SDL + Haskell SDL bindings
13:10:27 <jmcarthur> does the fact that it builds for wii homebrew mean that it could theoretically be built for normal distribution on unmodded wiis?
13:10:44 <jmcarthur> i have not really done console development before
13:11:22 <jmcarthur> well of course it theoretically could. just mean "without many more changes"
13:11:40 <meteficha> aristid: but that doesn't return a list of results, only the last one
13:12:29 <aristid> meteficha: yes, i just noticed that too
13:12:57 <monadic_kid> jmcarthur: it will only works on  softmodded Wii. The sdk I'm using is open source made by the homebrew community, not offical Wii SDK. I don't know what compiler they are using but technically if they implemenated most of the posix interfaces you can make jhc cross-compile to C on the offical sdk compiler
13:13:21 <jmcarthur> ah okay
13:13:30 <dankna> I know a little about Nintendo APIs; I have programmed the Nintendo DS both using the homebrew API and the official one.  They're not very similar at all.
13:13:46 <dankna> I would assume that the Wii is the same in that respect.
13:13:57 <monadic_kid> jmcarthur: The homebrew sdk (DevkitPro) is based on a port of gcc
13:14:14 <jmcarthur> dankna: what were the nintendo APIs like?
13:14:22 <dankna> well, I'm under NDA about them, but they weren't awful
13:14:23 <Phyx-> dankna: which ons is better? I've only done homebrew
13:14:25 <jmcarthur> anythign standard, or all proprietary?
13:14:26 <acowley> Can anyone point me to where I could force specific flags for cabal install in a custom Setup.hs?
13:14:34 <jmcarthur> i guess proprietary then
13:14:36 <uranther> byorgey: thanks! that --user flag worked
13:14:40 <dankna> the official one has a lot more capabilities than the homebrew, so it's better in that sense, but it has some ugliness too
13:14:41 <ezyang> acowley: What kind of flags? 
13:14:42 <dankna> proprietary yes
13:14:47 <acowley> --bindir and --libdir
13:14:50 <olsner> I would guess that the real SDK comes with a broken, old or plain weird compiler (a modded xlc perhaps), and the stdlib may be very different from glibc or whatever homebrew wii comes with
13:14:59 <acowley> I have a Setup.hs that does some other things
13:15:18 <acowley> so I'd like to just cram these into that somehow, if possible
13:15:20 <ezyang> acowley: You'll have to look at the flags 
13:15:29 <ezyang> that are passed to user hooks 
13:15:39 <jmcarthur> dankna: is it something that you think would be reasonable to try doing haskell with?
13:15:40 <acowley> ezyang: I can't see where I'm allowed to generate new flags, though
13:16:04 <jmcarthur> with C generated by JHC, for example
13:16:25 <jmcarthur> presumably with lots of tweaks
13:16:37 <ezyang> acowley: What are you looking at? 
13:16:49 <acowley> ezyang: BuildInfo
13:17:08 <monadic_kid> It would be cool if more people helped John on Jhc
13:17:29 <acowley> ezyang: The documentation in the Cabal package is really sparse, so it's hard to explore
13:17:33 <dankna> plain weird is correct.  and the standard C library isn't implemented at all except for like the math.h stuff.
13:17:34 <uranther> now, when Loading package readline, it complains that /usr/lib/libncurses.so is too short
13:17:34 <ezyang> Wrong data structure. 
13:17:40 <jmcarthur> ew
13:17:48 <ezyang> acowley: Yes. You really should 'cabal unpack Cabal' and snoop around the source. 
13:18:10 <acowley> ezyang: But what else can a user hook supply?
13:18:17 <ezyang> It depends on the hook. 
13:18:44 <acowley> ezyang: Sure, but I'm looking at UserHooks and not seeing a lot
13:18:50 <ezyang> preConf, for example, takes Args and ConfigFlags 
13:19:10 <acowley> ezyang: Yes, but only outputs BuildInfos
13:19:14 <monadic_kid> dankna: what about posix type stuff?
13:19:31 <ezyang> I think you want confHook 
13:19:41 <ezyang> confHook will override the default configuration behavior 
13:19:54 <aristid> @hoogle [a] -> Maybe [a]
13:19:56 <ezyang> But you want mostly default behavior, so fiddle with the flags and then call the original. 
13:20:15 <dankna> jmcarthur: sure, you could FFI to it no problem.  assuming the runtime was well-behaved-enough, but my understanding is that it is.
13:20:27 <jmcarthur> cool
13:20:29 <EvanR-work> does haskell have any competition? clean? f#? ocaml? scala?
13:20:42 <lambdabot> Prelude cycle :: [a] -> [a]
13:20:42 <lambdabot> Prelude init :: [a] -> [a]
13:20:42 <lambdabot> Prelude reverse :: [a] -> [a]
13:20:43 <jmcarthur> EvanR-work: NONE COMPARE
13:20:46 <acowley> ezyang: any idea which fields correspond to bindir or libdir?
13:21:04 <Heffalump> EvanR-work: to some extent, though to a large extent they fit different niches
13:21:16 <jmcarthur> EvanR-work: clean is probably the closest to haskell in that list in ideas and in performance, if i understand things correctly
13:21:19 <monadic_kid> jmcarthur: I think i know what i'm going to do now, i'm going to tear out the type-class entirely and implement the functionality like this: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html#id654840
13:21:35 <EvanR-work> jmcarthur: so is it competing? :)
13:22:05 <jmcarthur> EvanR-work: "competing" is such a strong word
13:22:28 <ezyang> acowley: Go check out the ConfigFlags datastructure 
13:22:30 <EvanR-work> i know ;)
13:22:41 <jmcarthur> haskell has moved into the mainstream a lot more than clean by now, so i guess they are in somewhat different niches now
13:22:58 <monadic_kid> I hardly hear anything about clean
13:23:01 <EvanR-work> thats what i thought
13:23:02 <jmcarthur> me either
13:23:06 <EvanR-work> so basically no ;)
13:23:18 <jmcarthur> agda might compete with haskell some day
13:23:20 <jmcarthur> maybe
13:23:33 <monadic_kid> it seems things do happen in Clean but they don't talk about it much
13:23:36 <Heffalump> If you're on Windows only then I guess F# and Haskell compete. I think people generally choose Scala because of the JVM.
13:23:46 <ezyang> hmmm 
13:24:02 <jmcarthur> i guess it would be kind of strange to say that adga might compete with haskell though, considering haskell is its FFI
13:24:07 <Heffalump> Haskell and O'Caml are probably closest in terms of functionality and platforms.
13:24:24 <ezyang> Actually, it looks like those flags are in configInstallDirs 
13:26:10 <EvanR-work> ocaml seems wildly different
13:26:14 <monadic_kid> from?
13:26:15 <EvanR-work> haskell
13:26:36 <Heffalump> well, it's a functional language :-)
13:26:54 <EvanR-work> i heard it has side effects, that seems weird
13:27:06 --- mode: gibson.freenode.net set +o ChanServ
13:27:11 <Heffalump> and it doesn't try to do any of the OO integration stuff that F# and Scala do (it does have its own object system, but that's a bit different)
13:28:06 <monadic_kid> well it's sub-typing is different
13:28:20 <aristid> :t (<=<)
13:28:39 <aristid> omg lambdabot is gone
13:29:02 --- mode: gibson.freenode.net set +o ChanServ
13:30:13 <aristid> EvanR-work: couldn't you express ocaml as a language where every function is a -> IO b?
13:30:13 <Phyx-_> what the
13:30:13 <Phyx-_> > id 3
13:30:19 <Veinor> netsplit!
13:30:32 <Phyx-_> did services just go down?
13:30:40 <Raynes> I think freenode just exploded.
13:31:05 <EvanR-work> aristid: and is executed immediate
13:31:06 <EvanR-work> ly
13:31:11 <Phyx-_> must be evil Will Weaton's doing
13:31:14 <mauke> I like how preflex is on the other side of the netsplit
13:31:17 <EvanR-work> Will Wheaton
13:31:30 --- mode: gibson.freenode.net set +o ChanServ
13:31:34 <Phyx-_> so is lambdabot
13:31:35 <Phyx-_> :P
13:31:41 <Phyx-_> and nickserv apparently
13:31:59 <mauke> yeah, but lambdabot is not setting next to me
13:32:02 <EvanR-work> aristid: and so yeah, its weird ;)
13:32:22 <Phyx-_> mauke: lol
13:32:29 <EvanR-work> map :: (a -> IO b) -> [a] -> IO [b]
13:32:32 <meteficha> @help
13:32:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:32:35 <Phyx-_> wee
13:32:38 <meteficha> these netsplits generate a lot of noise on Empathy client =/
13:32:38 <Phyx-_> split over
13:32:48 * jmcarthur wants to set up a system some day that does everything in its power to be a pain in the ass
13:32:48 <jmcarthur> e.g. beeping for every connect and disconnect in irc
13:32:49 <aristid>  :t unfoldWhileM (not . null) getLine
13:32:49 <aristid> unfoldWhileM (not . null) getLine :: IO [[Char]]
13:32:49 <Phyx-_> meteficha: lol, i get 1 message
13:32:55 <aristid> i like the monad-loops package :D
13:32:56 <EvanR-work> aristid: ah, multiparam functions, a -> b -> c becomes a -> IO (b -> IO c)
13:33:14 <Phyx-__> heh
13:33:16 <aristid> EvanR-work: can't you express that as a -> b - >IO c theoretically?
13:33:18 <mauke> Phyx-_: seriously, it's in the same screen session as this irc client
13:33:34 <Phyx-_> mauke: it probably connected to another server due to efnet's load balancing
13:33:37 <EvanR-work> aristid: only if you say that partial evaluation cant have side effects
13:33:42 <aristid> EvanR-work: hmm i guess the nested IO is necessary for composability
13:33:51 <mauke> heh
13:34:02 <mauke> no wonder it's so bouncy here!
13:34:03 <EvanR-work> and yeah functiosn that operate on functions wont work anymore unless you have 2 versions (or more?)
13:34:07 <mauke> it's EFNet!
13:34:28 <Phyx-> mauke: oops, typo :P
13:34:29 <aristid> :t (<=<)
13:34:31 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:34:37 <aristid> composition!
13:34:51 <Phyx-> mauke: I've been on efnet way longer than freenode, force of habbit :P
13:35:21 <Veinor> whenever I do a 'cabal list', I get a bunch of entries, and then
13:35:23 <Veinor> cabal: Couldn't read cabal file "./HaTeX/1.0.1/HaTeX.cabal"
13:36:32 <Veinor> and then it stops. the last entry right before it is HaRe, so I assume it's trying to display HaTeX and failing
13:36:42 <micahjohnston> :t instead
13:36:43 <lambdabot> Not in scope: `instead'
13:37:11 <EvanR-work> :t betterNot
13:37:13 <lambdabot> Not in scope: `betterNot'
13:37:22 <micahjohnston> :t confused
13:37:23 <lambdabot> Not in scope: `confused'
13:37:26 <EvanR-work> :t rather
13:37:27 <micahjohnston> :t noo
13:37:27 <lambdabot> Not in scope: `rather'
13:37:28 <lambdabot> Not in scope: `noo'
13:37:29 <meteficha> :t lolwut
13:37:29 <lambdabot> Not in scope: `lolwut'
13:37:32 <micahjohnston> :t watf
13:37:33 <lambdabot> Not in scope: `watf'
13:39:58 <aristid> are you alright?
13:40:46 <aristid> :t unfoldWhileM
13:40:47 <lambdabot> Not in scope: `unfoldWhileM'
13:41:01 <meteficha> daijobu desu :)
13:41:15 <ezyang> Can I use QuickCheck to build up monadic values? 
13:41:26 <ezyang> or does Arbitrary not really support that kind of operation? 
13:41:44 <scotty> Is Data.Serialize the preferred method of serialization?
13:42:08 <ezyang> It's one of two main contendors 
13:42:15 <scotty> That is, using cereal, the serialization library.
13:42:28 <scotty> ezyang: What's the other?
13:42:30 <EvanR-work> Storable ?
13:42:31 <ezyang> binary 
13:42:43 <meteficha> scotty: binary works with lazy bytestrings, cereal with strict ones
13:43:11 <meteficha> scotty: but IIRC dons said on the list something about binary superceding cereal in the future
13:44:54 <scotty> meteficha: Thanks
13:52:42 <EvanR-work> @src fix
13:52:42 <lambdabot> fix f = let x = f x in x
13:53:02 <napping> I'm trying to do the basic type-level contains, like
13:53:20 <napping> instance Contains x (x,r); instance (Contains x r) => Contains x (h,r)
13:53:24 <EvanR-work> ^this is why people see haskell as einstein proving e=mc^2 ;)
13:53:48 <Phyx-> hm?
13:53:49 <napping> is going for HList's TypeEq really the only way?
13:54:04 <ToRA> anybody know where the BinaryDerive.hs script lives nowadays?  the link in the haddock documentation doesn't point anywhere valid
13:54:08 <ToRA> ?
13:54:11 <mauke> @quote mauke.*=0
13:54:12 <lambdabot> No quotes match. Just try something else.
13:54:16 <mauke> @quote mauke =0
13:54:17 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
13:54:26 <meteficha> lol
13:54:26 <lambdabot> meteficha: You have 1 new message. '/msg lambdabot @messages' to read it.
13:55:58 * Phyx- wonders why he is getting spam on his blog from a online gambling site...
13:56:30 <Botje> because it will contribute 10^-10 points to the pagerank of said gambling site
13:56:47 <Phyx-> well, WordPress's spam filters caught them all
13:56:54 <Botje> .. unless your software appends rel=nofollow, but it's not like spammers think about that
13:57:04 <Phyx-> but still, the first comment was "This is the biggest load of bullshit I have ever read"
13:57:07 <Phyx-> :/
13:57:29 <micahjohnston> link to post?
13:57:30 <micahjohnston> :P
13:57:33 <Phyx-> with a link to the gambling site in nickname
13:57:50 <Phyx-> micahjohnston: http://mistuke.wordpress.com/2010/07/12/optimizations/
13:58:08 <napping> So, should I just copy in TypeEq?
13:58:58 <napping> Incidentally, I think some kind of untyped compile-time expansion thing could be a convenient solution
13:59:14 <Saizan> TH?
13:59:16 <napping> (I'm using type classes, so dynamic typing is hardly the win)
13:59:31 <napping> nah, TH would be bigger than just writing it all by hand
14:00:07 <Saizan> for a pratical "instance Contains x (x,r); instance (Contains x r) => Contains x (h,r)" the only way is to turn on OverlappingInstances, ime
14:01:30 <napping> oh, thanks, I thought I had that on
14:01:40 <BMeph> I think we should quit pretending, and just replace Haskell's type system with a whole other language... ;)
14:01:43 <hpc> how does overlapping instances resolve the overlaps?
14:01:49 <napping> BMeph: no, with the same language :)
14:01:54 <napping> hpc: most specific instance
14:02:08 <EvanR-work> BMeph: yeah
14:02:16 <napping> x;(x,b) requires those parts to agree, so it's more specific than x;(h,b)
14:02:25 <EvanR-work> i claimed the type system was more complex than the actual language and they disagreed ;)
14:02:50 <napping> EvanR-work: I think it's actually the type class system thats more complicated than the rest of anything
14:02:59 <BMeph>  napping: type-level modules would just be silly. And no better help.... ;)
14:03:08 <EvanR-work> 'embedded esoteric function language'
14:03:12 <EvanR-work> functional
14:03:33 <napping> BMeph: well, there's dependent types, or more isolated stratification like Omega
14:03:43 <hpc> i think all you would really need is a way to "extend"
14:03:52 <hpc> and all the hacky typeclass hacks would just melt away
14:04:09 <meteficha> BMeph: type-level modules?  what does that means anyway?  lol
14:04:39 <napping> Coq seems to do rather well with an untyped macroish language, with heavy typechecking of the results
14:04:55 <hpc> meteficha: my guess is "module Main where main = import Data.List"
14:05:23 <stelleg> @ a -> b -> b
14:05:28 <stelleg> :t a -> b -> b
14:05:30 <lambdabot> parse error on input `->'
14:05:34 <stelleg> hmm
14:05:39 <stelleg> how to get list of function with certain type?
14:05:41 <napping> To implemented pattern matching over a language with several sorts in the syntax, I've made a record with many Maps from a Var type to various types
14:05:42 <hpc> a -> b -> b is a type
14:05:53 <hpc> @hoogle a -> b -> b
14:05:54 <lambdabot> Prelude seq :: a -> b -> b
14:05:54 <lambdabot> Control.Parallel par :: a -> b -> b
14:05:54 <lambdabot> Control.Parallel pseq :: a -> b -> b
14:05:55 <jaj> @hoogle a -> b -> b
14:05:56 <lambdabot> Prelude seq :: a -> b -> b
14:05:56 <lambdabot> Control.Parallel par :: a -> b -> b
14:05:56 <lambdabot> Control.Parallel pseq :: a -> b -> b
14:05:57 <stelleg> ah thanks
14:06:13 <napping> I'm trying to simplify things like adding a binding to the appropriate map based on type, or unioning two sets of bindings together
14:06:24 <stelleg> @src seq
14:06:25 <lambdabot> Source not found. You speak an infinite deal of nothing
14:06:31 <stelleg> @src Prelude seq
14:06:31 <lambdabot> Source not found. My brain just exploded
14:06:34 <stelleg> haha
14:06:39 <stelleg> hmm
14:06:40 <hpc> seq !x y = y
14:06:52 <hpc> the ! means strictly evaluate x
14:07:03 <stelleg> seq x y
14:07:06 <stelleg> seq 3 4
14:07:10 <stelleg> hmm
14:07:12 <hpc> > seq 3 4
14:07:13 <lambdabot>   4
14:07:16 <meteficha> hpc: so you changed the mysterious definition to a mysterious extension :)
14:07:18 <stelleg> sweet
14:07:19 <stelleg> thanks
14:07:23 <hpc> > seq undefined 4
14:07:24 <lambdabot>   *Exception: Prelude.undefined
14:07:26 <copumpkin> also, the mysterious extension calls seq
14:07:27 <stelleg> nice
14:07:31 <copumpkin> so that doesn't terminate ;)
14:07:35 <stelleg> undefined = bottom?
14:07:38 <hpc> yes
14:07:47 <hpc> copumpkin: oh? i thought that was the definition
14:07:49 <stelleg> learn something cool every day
14:07:55 <copumpkin> hpc: nah, it's just a primitive
14:08:08 <BMeph> Once you resort to an "untyped" language, it's like trying to build a house out of spaghetti. It may be standing, but you can never be sure it isn't going to collapse at any time.
14:08:15 <copumpkin> it can almost be written in actual haskell with a typeclass
14:08:16 <copumpkin> but not quite
14:08:28 <meteficha> hpc: in fact, if 'seq' didn't exist, Haskell would be a very different language :)
14:08:33 * copumpkin is in italy, in a house made of spaghetti
14:08:35 <copumpkin> thank you very much
14:08:38 <hpc> @src rwhnf
14:08:38 <lambdabot> Source not found. Take a stress pill and think things over.
14:08:45 <hpc> @src rnf
14:08:45 <lambdabot> Source not found. stty: unknown mode: doofus
14:08:46 <copumpkin> :t rnf
14:08:47 <lambdabot> forall a. (NFData a) => a -> Done
14:08:54 <ClaudiusMaximus> stelleg: there is also the web interface to hoogle, which provides more info, more results, and clickable links to documentation (which has clickable links to source)
14:09:53 <aristid> @hoogle rnf
14:09:53 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
14:10:00 <stelleg> ClaudiusMaximus: thanks
14:14:01 <Nibble_> okay guys
14:14:18 <Nibble_> newtype Blah = Blah Int
14:14:26 <KSkrzet> There is git mirror of darcs repo for GHC: http://github.com/ghc-hq/ghc, but it doesn't seem to be updated. Why?
14:14:35 <Nibble_> is test :: Blah == test :: Int
14:14:41 <Nibble_> and, which one of them is the correct
14:14:45 <Nibble_> I am guessing Blah
14:14:49 <Nibble_> and a followup question
14:15:04 <Botje> Nibble_: no, you're thinking of type.
14:15:15 <Nibble_> Botje: are you sure?
14:15:17 <Botje> Blah 42 :: Blah Int
14:15:23 <Nibble_> no
14:15:26 <Nibble_> I don't think so
14:15:32 <Nibble_> It was explained to me
14:15:41 <Nibble_> that newtype bind the argh
14:15:46 <Nibble_> what's the name again
14:15:52 <Nibble_> type constructor
14:16:06 <Nibble_> of, example, blah, to Int
14:16:11 <burp> is anyone using takusen with sqlite? when I insert string data it inserts them within "-chars
14:16:14 <Nibble_> are you sure this is not the case?
14:16:20 <EvanR-work> each function takes exactly one argghhh
14:16:28 <hpc> haha
14:16:48 <chrisdone> Nibble_: are you specifically asking about the (==) method?
14:16:53 <Nibble_> chrisdone: no
14:17:01 <Nibble_> let me explain
14:17:14 <Botje> Nibble_: oh. Blah 42 :: Blah, yeah.
14:17:16 <Nibble_> when doing newtype Blah = Blah Int
14:17:21 <Botje> misread
14:17:29 <EvanR-work> Blah 42 == 42
14:17:33 <EvanR-work> True
14:17:55 <chrisdone> no
14:18:00 <chrisdone> :t (==)
14:18:02 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:18:06 <chrisdone> the types have to be the same
14:18:12 <chrisdone> Blah 42 is not the same type as 42
14:18:21 <EvanR-work> newtype Blah = Blah Int ?
14:18:21 <Nibble_> that's kinda what I asked
14:18:29 <Nibble_> wait one sec
14:18:48 <EvanR-work> i thought you can use a Blah wherever you can use Int
14:18:51 <chrisdone> a newtype is a distinct type, if that's what you're asking
14:18:56 <chrisdone> EvanR-work: nope, it's distinct
14:19:03 <chrisdone> it's a *new* type
14:19:07 <hpc> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword
14:19:08 <EvanR-work> oh
14:19:11 <hpc> ^
14:19:13 <EvanR-work> i got newtype mixed up with type
14:19:23 <EvanR-work> type Blah = Blah Int
14:19:31 <chrisdone> EvanR-work: yeah, for type Blah = Int
14:19:36 <burp> @check \x -> unpack (pack x) == x
14:19:37 <lambdabot>   Not in scope: `unpack'Not in scope: `pack'
14:19:38 <hpc> type Blah = Blah Int is an infinite type
14:19:44 <burp> @check \x -> BS.unpack (BS.pack x) == x
14:19:44 <lambdabot>   "OK, passed 500 tests."
14:19:57 <EvanR-work> type Blah = Int
14:20:20 <burp> um, wtf takusen is inserting strings within " when I directly specify the strings, and not when I specify unpack. pack $ "content"
14:20:32 * hackagebot hackport 0.2.8 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.8 (LennartKolmodin)
14:20:44 <monadic_kid> fatuhoku!
14:20:47 <burp> oh wait overloadedstrings might do something strange let me check
14:20:53 <fatuhoku> hullo, hullo :P
14:21:13 <Veinor> if I want to run, say, ls, and capture the output into a string, which package should I use for that?
14:21:32 <burp> um, it is
14:21:33 <Phyx-> @hoogle runProcess
14:21:33 <lambdabot> No results found
14:21:56 <fatuhoku> @hoogle [a] -> a
14:21:57 <lambdabot> Prelude head :: [a] -> a
14:21:57 <lambdabot> Prelude last :: [a] -> a
14:21:57 <lambdabot> Data.List head :: [a] -> a
14:22:00 <chrisdone> Veinor: System.Process. I think it's standard in GHC now
14:22:01 <fatuhoku> wow.
14:22:11 <Phyx-> Veinor: System.Process
14:22:17 <Phyx-> whoops, chrisdone beat me to it
14:22:22 <Veinor> ah
14:22:34 <chrisdone> it used to be a bit naff but they cleaned it up and it's a nice module
14:22:47 <Phyx-> and why do i keep thinking createProcess is called runProces
14:22:53 <Phyx-> @hoogle createProcess
14:22:53 <lambdabot> No results found
14:23:02 * Phyx- goes to sit in a corner
14:23:19 <Nibble_> @hoegle gal
14:23:20 <lambdabot> Language.Haskell.Syntax HsEThingAll :: HsQName -> HsExportSpec
14:23:20 <lambdabot> Language.Haskell.Syntax HsIThingAll :: HsName -> HsImportSpec
14:23:20 <lambdabot> System.IO.Error illegalOperationErrorType :: IOErrorType
14:23:31 <Nibble_> so that is your girls, haskell users?
14:23:32 <Phyx-> fatuhoku: ?
14:23:52 <Nibble_> now that I understand types
14:23:57 <Nibble_> what should I look into?
14:24:05 <EvanR-work> kinds!
14:24:13 <Nibble_> kinds of what?
14:24:17 <mauke> of types
14:24:17 <EvanR-work> types
14:24:24 <Nibble_> sure
14:24:25 <fatuhoku> ...
14:24:26 <fatuhoku> types.
14:24:27 <fatuhoku> ;P
14:24:30 <Nibble_> I know type, newtype, data
14:24:34 <mauke> @kind Int
14:24:35 <lambdabot> *
14:24:38 <Philippa> class and instance?
14:24:41 <Phyx-> then you should look into Kinds of Kinds
14:24:43 <EvanR-work> newkind
14:24:43 <Phyx-> of types..
14:24:44 <mauke> @kind Either
14:24:45 <lambdabot> * -> * -> *
14:24:49 <Philippa> kinds are mostly fairly ignorable in Haskell
14:24:53 <monochrom> people, please don't troll.
14:25:07 <Phyx-> monochrom: lol, why do I feel that was aimed at me :P
14:25:15 <Philippa> monochrom: there's a difference between trolling and taking the piss, but yeah, try not to
14:25:23 <Phyx-> :k (->)
14:25:23 <lambdabot> ?? -> ? -> *
14:25:49 * EvanR-work takes Philippa's piss
14:25:56 <Phyx-> ...
14:26:05 <chrisdone> EvanR-work: collecting samples?
14:26:14 * Phyx- walks away very slowly
14:26:22 <Phyx-> chrisdone: he has to pass his mandatory drug tests somehow
14:26:23 <hpc> @kind (->)
14:26:23 <lambdabot> ?? -> ? -> *
14:26:32 <Nibble_> if you feel like trolling, do /exec -o cat /dev/urandom
14:26:32 * EvanR-work throws a (->) at Phyx- as he tries to leave
14:26:33 <Nibble_> please.
14:26:34 <hpc> what's with the freakiness of (->)?
14:26:40 <Nibble_> hpc: it's a monad
14:26:42 <Nibble_> I have been told
14:26:54 <aristid> Nibble_: no that's not what hpc means
14:27:00 <chrisdone> hpc: what's freaky about (->)'s kind?
14:27:05 <hpc> yes
14:27:09 <aristid> chrisdone: why the question marks?
14:27:12 * Philippa throws an extra sample over EvanR
14:27:20 <Nibble_> aristid: what is it that he means then
14:27:30 <EvanR-work> you just borked my sample rate
14:27:31 <zygoloid> hpc: the kind ? is anything, including unboxed types
14:27:34 * hackagebot twidge 1.0.3 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.0.3 (JohnGoerzen)
14:27:40 <Nibble_> oh
14:27:41 <Nibble_> lol
14:27:45 <Phyx-> hpc: those are kinds of kinds, kinds can be arranged in a sort of hierachy, because of ghc's use oof unboxed types etc
14:27:46 <aristid> zygoloid: and ??
14:27:46 <hpc> as opposed to * which is only boxed types
14:27:47 <Philippa> ?? and ? are GHCisms
14:27:48 <lambdabot> Plugin `compose' failed with: Unknown command: ""
14:27:48 <zygoloid> hpc: the kind ?? is just boxed and unboxed things, but no unboxed tuples
14:27:53 <Nibble_> make it prefix?
14:28:01 <Nibble_> beacuse -> is infix
14:28:02 <mauke> Nibble_: (->) can't be a monad, it's a kind mismatch
14:28:10 <Nibble_> mauke: then I missunderstood something
14:28:12 <Nibble_> but nvm that
14:28:23 <Nibble_> but I was correct about the (->)
14:28:26 <Nibble_> rajt?
14:28:27 <mauke> but (->) x is a monad (for all types x)
14:28:33 <aristid> zygoloid: so function's can't take unboxed tuples as parameters?
14:28:34 <Nibble_> this monad thing
14:28:40 <zygoloid> aristid: that is correct.
14:28:42 <Nibble_> from the mathematical type
14:28:46 <Itkovian> Which book on category theory would you guys recommend? I'm a computer scientist, but not that well versed in pure math stuff.
14:28:52 <Nibble_> I can assume that it is when the output isn't always the same
14:29:06 <Nibble_> or in haskell terms, the function, with the same input, does not always get the same output
14:29:09 <Nibble_> correct?
14:29:11 <aristid> Nibble_: (r ->) is a monad for all r
14:29:14 <Phyx-> why is it, that typeclasses don't work on things of Kind #? is that just a haskell98 restriction?
14:29:17 <hpc> Nibble_: wrong
14:29:19 <aristid> (->) not, tho
14:29:27 <hpc> Nibble_: monads are just a typeclass, like any other
14:29:33 <Nibble_> hpc: sure
14:29:50 <Nibble_> but from what I understand it is when you do something that has a side-effect
14:29:54 <Nibble_> like priniting a character
14:29:57 <aristid> Phyx-: what is kind #?
14:29:58 <mauke> Phyx-: Haskell98 doesn't have #
14:29:59 <Phyx-> Itkovian: Category theory for computer scientist, by Benjamin C. Pierce
14:30:06 <monadic_kid> # unboxed types
14:30:07 <mauke> Nibble_: no
14:30:07 <EvanR-work> Nibble_: thats IO
14:30:09 <hpc> yes, but the side effects are contained in a pure structure
14:30:23 <Nibble_> so? a monad is still a monad?
14:30:24 <Phyx-> mauke: right, so I mean, is that a restriction stemming from that haskell98 doesn't have it, or something else?
14:30:26 <hpc> IO isn't native haskell
14:30:30 <Nibble_> hpc: I know.
14:30:44 <aristid> Nibble_: i think you should forget everything you "know" about monads ;)
14:30:44 <napping> BMeph: about untyped languages, that's why you only use them to generate code in typed languages
14:30:56 <Nibble_> aristid: I think everything I know is right
14:30:56 <chrisdone> Nibble_: in Haskell, what do you understand the Monad to be?
14:31:31 <zygoloid> aristid, hpc: about half way down, "Kinds are Types": http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
14:31:33 <Itkovian> Phyx-: thx
14:31:34 <AnAdorableNick> Nibble_: IO can be thought of keeping track of a "RealWorld" value, and updating it.
14:31:39 <Nibble_> chrisdone: not much. except that it is used when things has so called side-effects or the evaluation of the function can give different results with the same input.
14:31:45 <AnAdorableNick> Nibble_: Non-monadic implementations of IO have been proposed.
14:31:50 <Nibble_> AnAdorableNick: sure
14:31:57 <Nibble_> but they wouldn't be so much functional?
14:31:58 <EvanR-work> i dont know about RealWorld
14:32:05 <mauke> Nibble_: yes, the would
14:32:08 <mauke> *they
14:32:14 <Nibble_> mauke: how is that?
14:32:22 <mauke> Nibble_: because monads are not magic
14:32:25 <sproingie> didn't haskell originally do IO without monads?
14:32:28 <mauke> IO is still IO
14:32:36 <Nibble_> it would still be a side-effect and a uncertainty
14:32:42 <Nibble_> sproingie: correct
14:32:43 <napping> BMeph: when the untyped stuff is only used as a convenience inside the body of definitions with explicit type signatures there's very little damage it can do
14:32:48 <Nibble_> haskell 98 implemented monads I think
14:32:55 <micahjohnston> you can do effects on the outside world without monads and without functional impurity
14:33:00 <sproingie> no they were definitely in 1.4
14:33:02 <AnAdorableNick> Nibble_: You could, for example, still use the State type purely and even choose not to use the monad typeclass
14:33:07 <chrisdone> Monad is just a class that the IO library provides an instance for
14:33:09 <monadic_kid> i'm having issues with defining class instances in jhc, for Bits class
14:33:18 <Nibble_> chrisdone: what?
14:33:36 * hackagebot hackport 0.2.9 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.9 (LennartKolmodin)
14:33:43 <Nibble_> http://en.wikipedia.org/wiki/Monad_(functional_programming)
14:33:45 <Philippa> zygoloid: that's a specific of GHC internals in the Core language, it doesn't have anything to do with kinds in Haskell per se
14:33:47 <mauke> Nibble_: which part of that was unclear?
14:33:48 <chrisdone> Nibble_: Monad is a type class. its definition is
14:33:49 <chrisdone> @src
14:33:49 <lambdabot> src <id>. Display the implementation of a standard function
14:33:55 <chrisdone> @src Monad
14:33:55 <chrisdone>  
14:33:55 <lambdabot> class  Monad m  where
14:33:55 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:33:55 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:33:55 <lambdabot>     return      :: a -> m a
14:33:55 <lambdabot>     fail        :: String -> m a
14:34:12 <Phyx-> uru
14:34:13 <Phyx-> is that new?
14:34:21 <Phyx-> @src Monoid
14:34:21 <lambdabot> class Monoid a where
14:34:21 <lambdabot>     mempty  :: a
14:34:21 <lambdabot>     mappend :: a -> a -> a
14:34:21 <lambdabot>     mconcat :: [a] -> a
14:34:24 <Nibble_> mauke: nothing. Just that what I am saying is correct also
14:34:24 <aristid> :t join
14:34:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:34:28 <Nibble_> from my understanding
14:34:35 <chrisdone> Nibble_: as long as you can implement this for a given type, and satisify the monad laws, then it's a Monad instance
14:34:42 <Nibble_> chrisdone: exactly
14:35:04 * Phyx- stops trolling and goes back to coding
14:35:04 <Nibble_> classes
14:35:10 <Nibble_> what's the deal with that?
14:35:13 <Nibble_> with them*
14:35:14 <chrisdone> so Monads aren't to "get around" side effects
14:35:21 <Nibble_> chrisdone: didn't say that
14:35:35 <AnAdorableNick> Monads are no more "magical" than the Ord class
14:35:38 <Nibble_> I said that monads are used when there are side-effects of the actions done in the function
14:35:54 <chrisdone> Nibble_: this isn't true. you can do side effects without monads
14:35:57 <aristid> AnAdorableNick: definitely more interesting though
14:35:58 <meteficha> what is magical is "main :: IO ()" getting executed by the RTS :D
14:36:01 <Nibble_> chrisdone: so?
14:36:02 <EvanR-work> so whats the definition of side effect
14:36:05 <Nibble_> they are used
14:36:06 <hpc> and you can do monads without side effects
14:36:09 <EvanR-work> what is it to the side of
14:36:13 <Nibble_> doesn't mean that you must sue them
14:36:15 <napping> chrisdone: not nicely
14:36:24 <Nibble_> EvanR-work: that's what the guide says
14:36:25 <micahjohnston> napping: frp...?
14:36:28 <aristid> > do x <- [1,2,3]; y <- [1,2,3]; x+y
14:36:29 <lambdabot>   No instance for (GHC.Num.Num [b])
14:36:29 <lambdabot>    arising from a use of `e_1123123' at <...
14:36:29 <chrisdone> napping: pretty easily actually
14:36:33 <Nibble_> like printing a variable on the screen
14:36:36 <aristid> > do x <- [1,2,3]; y <- [1,2,3]; return $ x+y
14:36:36 * hackagebot mongoDB 0.7 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.7 (TonyHannan)
14:36:37 <lambdabot>   [2,3,4,3,4,5,4,5,6]
14:36:44 <napping> chrisdone: oh, so not the stuff like unsafePerformIO and so on
14:36:46 <Nibble_> that is a side effect of putting the value into the videocards memory
14:37:04 <Nibble_> that kind of side-effect
14:37:07 <chrisdone> napping: how do you think any IO gets performed?
14:37:11 <napping> chrisdone: right then, carry on. No side effects in pure code, though
14:37:13 <AnAdorableNick> Printing a variable on the screen requires modifying the real world.  You can't do that only with the monad class and the rest fo pure code.  You need IO, regardless of how it's implemented.
14:37:22 <Nibble_> AnAdorableNick: exactly
14:37:45 <Nibble_> there was some nice diagram with it
14:38:02 <AnAdorableNick> You can change the values in a monad, but it's entirely "self-contained".  You can also "change" a value purely without monads, such as using "succ" or any other function.
14:38:04 <Veinor> @pl \(x,y) -> not (null y)
14:38:05 <lambdabot> not . null . snd
14:38:06 <monoidal> IO a type is a normal type, like [a]. it's pure and doesn't do any side effects
14:38:09 <EvanR-work> Monad and IO are orthogonal concepts
14:38:17 <monoidal> the side effects are when you write main = something
14:38:26 <Nibble_> so
14:38:28 <monoidal> that IO is a monad is not important for that
14:38:30 <napping> chrisdone: oh, perhaps you are still confused. Do you understand the denotational semantics of the language, and the operational semantics of values in IO imposed by the runtime?
14:38:42 <Nibble_> I was correct, monad is used when there is some kind of side-effect
14:38:43 <micahjohnston> @pl
14:38:44 <lambdabot> (line 1, column 1):
14:38:44 <lambdabot> unexpected end of input
14:38:44 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:38:51 <EvanR-work> IO has operational semantics?
14:38:53 <AnAdorableNick> Nibble_: What do you consider a "side-effect"
14:38:55 <Nibble_> like a function f x = x * x
14:38:55 <AnAdorableNick> ?
14:39:02 <Nibble_> there is no side-effect
14:39:09 <AnAdorableNick> Nibble_: I don't consider those side effects.  I consider those "main" effects.
14:39:10 <napping> chrisdone: not that you need to understand that stuff, but knowing whether you do will help me understand you
14:39:24 <napping> EvanR-work: there are various partial proposals
14:39:41 <Nibble_> AnAdorableNick: http://www.haskell.org/haskellwiki/Why_Haskell_matters#Functions_and_side-effects_in_functional_languages
14:39:45 <monoidal> Nibble_: in f x y = [a+b | a <- x, b <- y] is there a side effect?
14:39:52 <napping> EvanR-work: and even if it's not formalized, well, it's not like we have a formal denotational semantics for the pure stuff either
14:39:57 <aristid> Nibble_: it's ok not to understand everything. you don't need to pretend you are always correct about everything.
14:40:01 <EvanR-work> biggest question on the millenium, is the 'written' result of a Writer computation a side effect or a main effect ;)
14:40:03 <monoidal> Nibble: or in f x = putChar x?
14:40:11 <Nibble_> monoidal: I can't answer anyone
14:40:17 <Nibble_> aristid: I am not saying that I know everything
14:40:20 <Nibble_> but from what you have written
14:40:41 <micahjohnston> @pl \ x -> \ y -> \ z -> x z (y z)
14:40:41 <lambdabot> ap
14:40:48 <micahjohnston> :t ap
14:40:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:40:59 <Nibble_> aristid: but, as I said NUMEROUS amounts of time
14:41:10 <Nibble_> this is what a tutorial said
14:41:28 <aristid> whatever. monads are not about side effects.
14:41:35 <Nibble_> http://stackoverflow.com/questions/2488646/why-are-side-effects-modeled-as-monads-in-haskell
14:41:35 <burp> @pl \x -> [x]
14:41:36 <lambdabot> return
14:41:40 <EvanR-work> aristid: or are they
14:41:40 <AnAdorableNick> "Monads" don't have side effects any more than pure, regular functions do.
14:41:44 <Nibble_> aristid: side-effects are about monads
14:41:52 <Nibble_> aristid: stop pretending you know everything...
14:41:56 <Nibble_> applies to you too.
14:41:59 <copumpkin> Nibble_: side effects can be modeled with monads
14:42:06 <micahjohnston> monads are not about side effects
14:42:06 <copumpkin> Nibble_: I wouldn't equate them 
14:42:08 <napping> Nibble_: but also other pretty things
14:42:15 <Nibble_> copumpkin: sure
14:42:32 <aristid> EvanR-work: i don't think the Maybe instance of Monad involves a lot of side effects.
14:42:37 <Axman6> copumpkin: in the current haskell we have at the moment anyway
14:42:43 <chrisdone> napping: well, for example, I could have an applicative instance :-)
14:42:48 <EvanR-work> someone here explained to me the original concept of monad was computation with effect
14:42:49 <copumpkin> Nibble_: "stop pretending you know everything" as a reflection of what he told you earlier isn't productive
14:42:53 <monoidal> Nibble_: you need to define "side effect". If it is doing I/O of any sort, everything in haskell is pure
14:43:00 <AnAdorableNick> Side effects can also be modeled with functions
14:43:01 <Nibble_> monoidal: I did not
14:43:05 <Nibble_> look
14:43:13 <Nibble_> oh wait
14:43:16 <Nibble_> missread
14:43:17 <hpc> AnAdorableNick: everything in haskell is modelled with functions ;)
14:43:20 <Nibble_> http://stackoverflow.com/questions/2488646/why-are-side-effects-modeled-as-monads-in-haskell
14:43:23 <napping> chrisdone: well, in Haskell, you need to use IO at some point to have actual effects, even if it's only calling interact or your runFRP or whatever
14:43:28 <Nibble_> I defined side-effect numerous amount of time
14:43:29 <Nibble_> s
14:43:34 <copumpkin> hpc: except for values that aren't functions, unless you're looking hask :P
14:43:40 <Nibble_> http://www.osnews.com/story/15230/Haskell_Programming_Equals_Coding_Without_Side_Effects
14:43:52 <Nibble_> and obviously, given from that text
14:43:55 <Nibble_> as I said
14:43:56 <chrisdone> napping: sure -- but once you've done that you can forget about it
14:44:01 <aristid> EvanR-work: i guess they gave you a paper too :D
14:44:02 <Nibble_> something with unpredictable output
14:44:08 <EvanR-work> aristid: yeah...
14:44:11 <EvanR-work> :(
14:44:11 <Nibble_> i.e the equality doesn't always work
14:44:24 <monoidal> you mean that x == y but f x /= f y?
14:44:25 <aristid> EvanR-work: this channel is so predictable :)
14:44:28 <Nibble_> eh, just read that link
14:44:39 <Nibble_> monoidal: are you talking with me?
14:44:43 <monoidal> yes
14:44:43 <Nibble_> use highlights. please
14:44:47 <monochrom> this channel is predictable? is it a pure function? :)
14:44:55 * copumpkin is pure
14:44:56 <Nibble_> monoidal: I would argue
14:45:05 <monochrom> highlights are annoying
14:45:08 <Nibble_> that because there is a unpredictability
14:45:13 <EvanR-work> #haskell :: Misconception -> Paper
14:45:14 <Nibble_> it is not a pure function
14:45:18 <aristid> monochrom: well, predictable in an incomplete, and probably impure, way
14:45:20 <Nibble_> monoidal: read that link
14:45:30 <Nibble_> that defines what "without side-effects" is
14:45:31 <napping> sounds like some popular article thing
14:45:36 <Nibble_> and side-effects is what it is not
14:45:46 <napping> is it not "referential transparency"?
14:45:50 <Axman6> afaik, there are only two monads which may have unpredictable results: IO and STM
14:45:59 <AnAdorableNick> Nibble_: The same input passed to a monadic value will always return the same output.
14:46:03 <aristid> Axman6: STM can be unpredictable?
14:46:08 <Axman6> yes
14:46:17 <aristid> oh, STM
14:46:21 <aristid> i confused it with ST
14:46:22 <aristid> lol
14:46:31 <Nibble_> AnAdorableNick: sure?
14:46:32 <Nibble_> A file
14:46:32 <copumpkin> :)
14:46:37 <Nibble_> lets say the harddrive crashes
14:46:41 <Nibble_> will the output be the same?
14:46:44 <Axman6> i was going to say three monads, and include ST, and remembered the point was that it was predictable, and pure :P
14:46:45 <mauke> Nibble_: yes
14:46:46 <chrisdone> napping: I like Hakyll for an example of having an Arrow instance to compose actions in a restricted way
14:46:56 <napping> Axman6: well, you can always define your own implemented in terms of IO :)
14:46:58 <EvanR-work> lets say your RAM crashes while computing a pure function
14:47:00 <hpc> if the hard drive crashes, the input has changed
14:47:02 <EvanR-work> then what, bitch
14:47:07 <AnAdorableNick> Nibble_: Let's pretend that hardware fail doesn't exist
14:47:08 <napping> chrisdone: the stuff on Lawvere theories seems nice
14:47:12 <Nibble_> AnAdorableNick: we can't
14:47:22 <Nibble_> that's why there are so called side-effects
14:47:24 <Axman6> yes we can
14:47:28 <AnAdorableNick> Yes we can pretend.
14:47:29 <EvanR-work> Nibble_: also 2+2 doesnt equal 4 because of cosmic rays
14:47:29 <Nibble_> did you guys read the links I sent?
14:47:40 <EvanR-work> also computer science is meaningless we dont have infinite memory
14:47:40 <AnAdorableNick> That's what pure is all about.  Pretending that the hardware works as intended.
14:47:48 <Nibble_> EvanR-work: stop. please.
14:47:51 <napping> Axman6: oh, and the semantics of imprecise exceptions
14:47:59 <monoidal> Nibble_: there is no function that, say, reads from file in Haskell
14:48:02 <chrisdone> napping: hmm, sounds neat
14:48:02 <Nibble_> AnAdorableNick: yes? I am not saying anything else
14:48:05 <AnAdorableNick> Nibble_: The input for IO is a RealWorld value, which can vary well vary at two different times.
14:48:19 <mauke> AnAdorableNick: I don't like that model
14:48:24 <napping> Nibble_: evanr is being impolite (first wrote imprecise), but I think the point has merit
14:48:24 <mauke> there is no RealWorld
14:48:27 <Nibble_> The point is
14:48:29 <monoidal> Nibble_: there is only an I/O "action" that says "oh imagine I read from file, what should be done next"?
14:48:35 <aristid> mauke: ST RealWorld is real!
14:48:38 <Nibble_> The IO functions, has a side effect
14:48:39 <mauke> aristid: no
14:48:44 <Nibble_> and therefore, they are not pure functions
14:48:54 <mauke> Nibble_: what do you mean by "IO functions"?
14:48:54 <aristid> mauke: yes :P
14:48:58 <AnAdorableNick> Nibble_: They aren't functions at all.
14:48:59 <napping> Nibble_: after all lazy evaluation is implemented in terms of mutation, but we come up with a nice formal mathematical definition, and then try to implement it reliably
14:49:01 <EvanR-work> RealWorld may change between two IO actions despite your program
14:49:06 <AnAdorableNick> Nibble_: They're declarations that describe how a program should behave.
14:49:07 <monoidal> Nibble_: they have a side effect when *executed*. not *evaluated*
14:49:13 <napping> EvanR-work: I think that is not true
14:49:14 <Nibble_> monoidal: so?
14:49:22 <EvanR-work> napping: why?
14:49:24 <mauke> aristid: no
14:49:34 <Nibble_> If there is some sort of side-effect, then it is no pure function
14:49:38 <Axman6> Nibble_: so, they are pure
14:49:47 <Nibble_> Axman6: so?
14:49:50 <aristid> mauke: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad-ST.html#v%3AstToIO
14:49:50 <micahjohnston> because the Parsec monad, and [] monad, etc., are all pure
14:49:56 <EvanR-work> napping: imagine the getTimeOfDay or something
14:49:56 <Axman6> well you're arguing they;re not
14:49:57 <napping> EvanR-work: to get a pure denotational semantics, you have to pretend the functions you are running also decide on all those changes (or perhaps apply them from a list of concurrent processes hidden in the RealWorld, or something)
14:50:00 <micahjohnston> so monads don't mean side effects
14:50:05 <aristid> mauke: the RealWorld type does seem to exist.
14:50:16 <micahjohnston> aristid: I'm pretty sure it's just in ghc though
14:50:21 <mauke> aristid: "We never manipulate values of type RealWorld; it's only used in the type system"
14:50:22 <AnAdorableNick> mauke: Why don't you like the RealWorld concept?
14:50:32 <mauke> AnAdorableNick: because it doesn't explain anything
14:50:36 <aristid> mauke: so? :P
14:50:38 <AnAdorableNick> mauke: Sure it does.
14:50:43 <mauke> aristid: so it doesn't really exist
14:51:01 <napping> Nibble_: that article doesn't really define things clearly
14:51:07 <AnAdorableNick> mauke: With different states of the real world (different time being evaluated is always a different state), you can get different output.
14:51:09 <napping> the point is referential transparency
14:51:18 <mauke> AnAdorableNick: but that's not what actually happens
14:51:19 <Nibble_> napping yeah. what article. I linked like five of them
14:51:23 <EvanR-work> where do you get the time from?
14:51:27 <aristid> mauke: what does "really exist" mean? the type does exist :)
14:51:27 <napping> if you ever define "x = <expr>", you should be able to replace x with <expr> everywhere
14:51:31 <Nibble_> Who EvanR-work 
14:51:32 <monoidal> Nibble_: http://stackoverflow.com/questions/3117583
14:51:46 <Axman6> @src IO
14:51:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:51:50 <napping> EvanR-work: pretending you can define a purely functional RealWorld value (as needed to make sense of things in denotational semantics) gets really silly
14:51:50 <Axman6> bah!
14:51:57 <AnAdorableNick> mauke: As long as the actual underlying implementation is compatible with the concept or how it should work, I don't think it matters much.
14:52:05 <napping> EvanR-work: for example, it might have a list of times at which syscalls are to be considered to have finished
14:52:10 <monochrom> links are overrated. you can create a link to say whatever you want it to say.
14:52:12 <AnAdorableNick> mauke: You might use unsafePerformIO or something to define sort
14:52:21 <mauke> AnAdorableNick: it matters when I'm trying to understand how IO actually works
14:52:23 <napping> Nibble_: I was looking at the osnews thing
14:52:30 <Nibble_> napping: sure
14:52:36 <EvanR-work> napping: alright, but dont we have to decide 'how long' each IO action takes
14:52:45 <Nibble_> napping: it had a context, tho
14:52:45 <EvanR-work> so it can update the RealWorld 'current time'
14:52:51 <napping> EvanR-work: sure, the real world is very complicated
14:52:59 <EvanR-work> and what about quantum mechanics
14:53:02 <AnAdorableNick> mauke: And how does RealWorld intejfere with that?
14:53:10 <ddarius> monochrom: sentences are overrated.  you can create a sentence to say whatever you want it to say.
14:53:10 <EvanR-work> alright my original point is defeated
14:53:11 <napping> EvanR-work: that's why it's a formal semantics, not the actual one
14:53:24 <monochrom> haha. did you read my sentence? :)
14:53:25 <mauke> AnAdorableNick: that the universe isn't actually piped through my computer, which then spits out a new (modified) universe
14:53:46 <napping> Nibble_: It's a reasonable approximation, but you seem to be getting to the point where the holes in it matter
14:54:01 <AnAdorableNick> mauke: IO describes how your program interacts with the real world.
14:54:05 <ddarius> monochrom: Yes, but my response was mostly independent of the content of it, very much in the spirit of the response itself.
14:54:38 <monochrom> hackage almost has enough libs to do whatever you want it to do. therefore hackage is overr...
14:54:40 <napping> mauke: one point of making up the RealWorld model is to explain how you can have IO things that actually do stuff, without compromising the purity of the rest of your program
14:54:54 <EvanR-work> napping: ironically, getting a real purely function program to simulate such a real world, wed never be able to actually take as long as the model says ;)
14:55:05 <EvanR-work> in real time
14:55:10 <mauke> napping: again, the Haskell runtime doesn't actually clone the universe
14:55:18 <Nibble_> napping: you mean point in haskell-knowledge or what?
14:55:20 <meteficha> mauke: =O
14:55:21 <mauke> this explanation Does Not Work™
14:55:35 <napping> mauke: in the same sense that pretending getContents precognitively returns a string truncated at just the point where you hClosed the file explains why it doesn't break the purity of pure functions to have these "values" floating around
14:55:50 <Nibble_> napping: no, I just today understood curried functions
14:56:26 <Ozgur> :t curry
14:56:27 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:56:49 <AnAdorableNick> mauke: The RealWorld model doesn't require that every single part of it can be accessed and modified.
14:57:02 <napping> Nibble_: ah, well, maybe you should just write some code with stuff like IO, but also with stuff like Maybe, and leave worries about imprecise terminology like "side effects" for a bit later
14:57:23 <mauke> AnAdorableNick: but it requires you to clone the universe
14:57:39 <napping> mauke: no, you make sure it's used linearly
14:57:39 <mauke> AnAdorableNick: including myself, sitting in front of the computer
14:57:48 <mauke> napping: that's just the interface
14:57:50 <hpc> mauke: that isn't too hard, if you exploit the right axioms
14:57:54 <mauke> napping: internally, it's copied
14:57:56 <Nibble_> napping: I have a pretty clear idea of side-effects
14:58:05 <napping> mauke: internally, it's mutated
14:58:10 <Nibble_> I carefully defined what I meant with side-effeects. too
14:58:13 <napping> mauke: or do you consider last second and this a copy?
14:58:18 <napping> Nibble_: oh, I must have missed that?
14:58:25 <Nibble_> napping: probably
14:58:27 <napping> Nibble_: anyway, I think this stuff is pretty clear if you use it
14:58:29 <Nibble_> let me check
14:58:37 <AnAdorableNick> mauke: You could think of RealWorld as a lazy type.
14:58:43 <AnAdorableNick> mauke: Why does it need to clone the universe?
14:58:45 <mauke> napping: type IO a = RealWorld -> (a, RealWorld)
14:59:03 <ddarius> AnAdorableNick: What does "a lazy type" mean?
14:59:05 <EvanR-work> AnAdorableNick: time dependence is a non trivial feature of this RealWorld paradigm
14:59:10 <napping> mauke: the need to enforce linearity is why GHC hides the RealWorld in an abstract type, and Clean can let it hang out
14:59:27 <mauke> this is all bullshit
14:59:37 <mauke> RealWorld is a hack in the compiler
14:59:41 <napping> mauke: um, yes
14:59:45 <napping> mauke: and in the theory
14:59:55 <EvanR-work> something about it just doesnt work
15:00:05 <mauke> I don't care about the theory
15:00:10 <mauke> I'm trying to understand IO
15:00:13 <Nibble_> a side-effect is something that occurs due to something else, may be related or unrelated. like printing a character to the screen, you insert it into the video-memory and it appears on the screen.
15:00:14 <napping> mauke: actually, GHC has primitive fuctions that have side effects when applied
15:00:23 <mauke> well, not really "trying" because I already understood it
15:00:33 <aristid> napping: you mean like all of them, strictly speaking?
15:00:41 <Saizan> napping: you don't need RealWorld in a theory of IO
15:00:43 <aristid> they generate heat!
15:00:56 <napping> mauke: and it uses RealWorld to ensure they appear to be ordered by data dependencies, so the optimizer preserves the order
15:01:04 <napping> that's the practical use of it
15:01:06 <mauke> implementation details
15:01:09 <mauke> irrelevant
15:01:17 <Nibble_> anyhow
15:01:29 <napping> well, you are one mentioning things from the source of IO
15:01:42 <napping> I generally prefer the resumption/syscall model
15:01:42 <aristid> napping: so ST RealWorld is a hack to get ST optimizations for IO?
15:01:58 <napping> well, to avoid multiplying things, I think
15:02:29 <AnAdorableNick> After thinking about it, I do think that thinking of IO as simply describing a method of interacting with the real world is a better way to think about it, without RealWorld.
15:02:49 <EvanR-work> yeah
15:02:49 <napping> mauke: have you seen Li and Zdancewic's thread paper?
15:02:50 <Nibble_> graphics libraries for haskell
15:02:57 <micahjohnston> you don't need RealWorld
15:03:14 <Nibble_> Oh
15:03:16 <micahjohnston> you could make IO actions be a datatype that only the compiler can read
15:03:21 <Nibble_> And multithreaded programming, how is that done?
15:03:24 <mauke> napping: no
15:03:32 <napping> Nibble_: using forkIO, mostly
15:03:33 <aristid> micahjohnston: isn't that what IO does?
15:03:40 <EvanR-work> main :: IO () gives us somewhere to stand in the haze of wtf to do with this giant execution graph
15:03:46 <micahjohnston> aristid: I don't know
15:03:58 <micahjohnston> aristid: the RealWorld approach is not that
15:04:06 <napping> mauke: well, the important point is that they define a monad with constructors for various requests you can make of the environment (or perhaps it's parameterized)
15:04:11 <napping> mauke: and then an interpreter that runs it
15:04:27 <chrisdone> tbh I never found the RealWorld analogy helpful
15:04:53 <napping> like, data MyIO a where getChar :: IO Char; putChar :: Char -> IO (), that sort of thing
15:05:29 <napping> you could imagine a Haskell program working in a similar way, just defining a nice ordinary functional value
15:05:53 <napping> and then the runtime/operational semantics examines it, and forces things and stuff, and actually goes out and has some behaviour
15:06:10 <monochrom> you should read Andrew Gordon's "functional programming and input/output" http://research.microsoft.com/en-us/um/people/adg/Publications/fpio.html
15:06:12 <mauke> napping: yes, that's my model
15:06:21 <napping> mauke: oh, ok, that's a good one
15:06:30 <mauke> it's 1) pure and 2) actually implementable
15:07:13 <napping> well, considering that the RealWorld one is the one that's actually implemented (perhaps up to worries about time machines?)
15:07:16 <chrisdone> type IO = State IOState
15:07:17 <c_wraith> mauke: that model has a heart attack when you look at the source code for bytestring. :)
15:07:18 <Nibble_> napping: forkIO, ok. I guess mutex is a no problem because variables are immutable, or am I thinking wrong here?
15:07:30 <napping> yeah, mutex is rarely a problem
15:07:32 <ddarius> napping: For GHC and using hacks in the optimizer.
15:07:33 <mauke> c_wraith: I don't think so
15:07:52 * hackagebot mongoDB 0.7.1 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.7.1 (TonyHannan)
15:08:05 <mauke> c_wraith: does it use more than unsafePerformIO?
15:08:14 <c_wraith> mauke: yes.  look at inlinePerformIO
15:08:15 <napping> mauke: well, it would be best to avoid a real data type that needs to be extended with every foreign import
15:08:21 <ezyang> > (Just 3) `mplus` (Just 4) 
15:08:22 <lambdabot>   Just 3
15:08:53 <mauke> napping: just have a constructor ForeignIO Whatever
15:09:04 <napping> Nibble_: yeah, pure values behave pretty nicely (the implementation also does a good job to handle different threads demanding a lazy value)
15:09:13 <aristid> i wish Data.List would contain a function with equivalent to not . null - that would be convenient
15:09:52 <napping> Nibble_: when you need some communication it's easiest to use things like MVar or Chan or perhaps STM which combine synchronization with access to the data
15:09:56 <hpc> @check \x -> (Just x) `mplus` (Just 4) == (Just x)
15:09:57 <lambdabot>   "OK, passed 500 tests."
15:10:10 <Nibble_> napping: take it easy, I don't even know what that means yet
15:10:11 <napping> I'm sure it's even safe to try to use an MVar () as a lock over some IORefs
15:10:13 <Nibble_> Types?
15:10:18 <Nibble_> Because of the capital
15:10:29 <napping> Conctrol.Concurrent.{MVar,Chan,STM}
15:10:34 <EvanR-work> or just use MVar to hold what the IORefs would have
15:10:43 <EvanR-work> take the value, operate on it, put it back
15:10:48 <ddarius> napping: Yes, MVar () can be used as a lock, though that's rarely necessary.
15:10:50 <napping> so MVar a is either empty, or has one a
15:11:06 <napping> ddarius: are you sure enough fences and so on are added to order it wrt IORef access?
15:11:29 <EvanR-work> dont use IORef for shared state
15:11:53 <napping> well, sure
15:11:57 <EvanR-work> even if its safe, it doesnt mean you are free from race conditions
15:12:03 <ddarius> napping: If there aren't then that's an implementation error, not a specification error.
15:12:15 <napping> ddarius: I don't believe it's specified to be safe
15:13:56 <ddarius> napping: I doubt anything one way or the other is specified, but I'm sure any such failures would be considered implementation bugs.
15:15:19 <monoidal> is Chan a functor?
15:16:19 <napping> I guess they are
15:16:19 <Heffalump> monoidal: No
15:16:23 <aristid> @info Chan
15:16:23 <lambdabot> Chan
15:16:34 <aristid> @src Chan
15:16:35 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:16:38 <Heffalump> monoidal: it can't possibly be, because writeChan would require an inverse of the fmap'd function
15:16:50 <aristid> lambdabot: passwd djfqgh7q
15:16:54 <monoidal> ah right
15:16:55 <mauke> oh, it's that old pointer thing again
15:17:02 <mauke> sink+source
15:17:10 <ddarius> Invariance of mutable cells.
15:17:19 <monoidal> Heffalump: and readChan would require the fmap'd function, so it can't be contravariant neither.
15:17:22 <napping> right, it would be read-only channels
15:17:40 <ddarius> If we did separate the read and write facets, you could have that though.
15:17:40 <napping> there's no way to map a function over the result can get a Chan back anyway
15:17:53 <napping> so the interface would have to be extended
15:18:05 <ddarius> (Well, modulo needing IO)
15:18:48 <Nibble_> guys
15:18:59 <Nibble_> what is the function that checks for a value inside a list
15:19:00 <Nibble_> like
15:19:09 <mauke> Nibble_: what would its type be?
15:19:19 <Nibble_> someFuncName 1 [1,2,3] == True or something
15:19:23 <ddarius> Nibble_: null, but usually pattern matching is what you want.
15:19:26 <ddarius> Er elem
15:19:30 <Nibble_> elem
15:19:31 <ddarius> :t elem
15:19:31 <Nibble_> that's it
15:19:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
15:22:11 <EvanR-work> if its really supposed to be a list of arbitrary length that may contain a value, elem is good
15:22:42 <EvanR-work> at any position
15:23:08 <ddarius> data Sink a = forall b. Sink (a -> b) (Chan b); data Source a = forall b. Source (b -> a) (Chan b); instance Functor Source where fmap f (Source g c) = Source (f . g) c; instance CoFunctor Sink where cofmap f (Sink g c) = Sink (g . f) c
15:23:40 <EvanR-work> @src elem
15:23:41 <lambdabot> elem x    =  any (== x)
15:23:50 <EvanR-work> hehe
15:25:09 <ddarius> @src Foldable
15:25:09 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:26:15 <monoidal> there's move :: Source a -> Sink a () -> IO ()
15:26:29 <monoidal> * Source a -> Sink a -> IO ()
15:26:38 <ddarius> I would call that connect.
15:26:49 <monoidal> yes, better
15:27:30 <ddarius> (In fact I did call it connect in a related library and also made (>->) an alias.)
15:29:27 <ddarius> connect gets used (directly) surprisingly rarely
15:37:00 <Nibble_> Is there any market for haskel programmers out there?
15:37:23 <ddarius> Yes.
15:37:32 <Nibble_> ddarius: like where?
15:37:55 <napping> Most correct to say there are commercial users
15:38:11 <ddarius> Nibble_: America, Europe, Japan, no doubt other places.
15:38:23 <Nibble_> ddarius: don't be a smartass
15:38:24 <napping> Galois, Eaton, Credit Suisse, etc.
15:38:38 <ddarius> Nibble_: I wasn't being one.  Your question wasn't very clear.
15:38:38 <aristid> i think more and more companies will use haskell in the future
15:39:09 <napping> I'm not sure there's a market in the sense that some HR guy goes out and tries to order up 40
15:39:54 <Nibble_> napping: I guess creating companies is the only viable way
15:40:05 <Nibble_> but thinking about how great haskell it is
15:40:12 <napping> There are companies that use Haskell and hire people
15:40:17 <Nibble_> napping: sure
15:40:19 <ddarius> There are plenty of such companies.
15:40:29 <Nibble_> but there are a lot of people using Haskell so they have a lot to pick from
15:40:58 <ddarius> Nibble_: There are a lot of people using Java too, that doesn't mean its hard to get a Java job.
15:41:05 <Heffalump> it's actually quite hard to recruit Haskell programmers, IME
15:41:36 <ddarius> Heffalump: Others seem to be having little trouble though that be due to time and location (and other things.)
15:41:44 <aavogt> when did these experiences happen?
15:41:54 <ddarius> Heffalump: In your particular case, I'd think you were looking for a more specific type of programmer.
15:42:05 <sshc> Heffalump: Why would it be?
15:42:24 <Heffalump> mostly 2 or 3 years ago, though we're also hiring people to write F# now and Haskell programmers are welcome to apply
15:43:37 <sshc> I wonder how hard it would be to find a job as a Haskell programmer compared to finding a job as a C++ programmer.[C
15:44:18 <ddarius> sshc: Quite a bit harder if you don't have any particular things that set you out (and assuming the same for C++).
15:44:32 <sinelaw> aloha!
15:44:33 <lambdabot> sinelaw: You have 1 new message. '/msg lambdabot @messages' to read it.
15:44:45 <Nibble_> ddarius: I just meant that there are more haskell people per job that there are java
15:44:53 <ddarius> Nibble_: I doubt that.
15:45:04 <Heffalump> you need to count the people looking, not the total people
15:45:13 <napping> I get the impression it has been possible to get a job in Java while being only vaguely competent
15:45:15 <sshc> ddarius: Why would that be true?
15:45:37 <napping> I don't think there are jobs looking for Haskell experience where the same is true
15:45:45 <Nibble_> I mean, my 9 year old cousin could get a job programming java
15:46:14 <sinelaw> ahola!
15:46:36 <ozamosi|netbook> But that's because only vaguely competent programmers write java, no? ;)
15:46:38 <sshc> ddarius: Which "particular things" do you suppose would increase the chances?
15:46:49 <napping> anybody know a filesystem that can handle hundreds of thousands of files in a directory?
15:46:54 <ddarius> sshc: I imagine there are significantly more jobs as an entry-level C++ programmer than as a entry-level Haskell programmer.
15:47:01 <monochrom> henceforth, I start my do-blocks with "aloha" and end them with "ahola" :)
15:47:03 <napping> or, I guess, know whether filesystems tend to blow up then
15:47:11 <Heffalump> how do you define "entry-level"?
15:47:33 <aavogt> no PhD
15:47:41 <ddarius> Heffalump: Let's say requires Bachelor (or less) and no experience.
15:47:43 <monochrom> napping: does ext4 work for that?
15:47:50 <Heffalump> no commercial experience, or no experience?
15:47:59 <monochrom> oh the wikipedia has a table listing such limitation parameters
15:48:12 <ddarius> sshc: I was going to get to that because it is probably easier to "stand out" enough to better position yourself to get a Haskell job than a C++ one.  If you are active in the community, particularly in making or maintaining notable projects, you will likely be noticed.
15:48:18 <napping> dunno, just reading reddit and seeing someone claim hundreds of megabytes of heap usage from running a du program
15:48:22 <wli> napping: A fair number probably use B+ tree directory indexing algorithms like jfs, xfs, etc. (which have horrible constants lurking somewhere but AIUI reasonable asymptotics).
15:48:25 <Nibble_> ddarius: that's not what you said
15:48:30 <napping> and other claiming it's from getDirectoryContents returning [String]
15:48:33 <Nibble_> 00:44 < Nibble_> ddarius: I just meant that there are more haskell people per job that there are java
15:48:35 <ddarius> Heffalump: No expectation of experience beyond what would be gotten in an undergraduate curriculum.
15:48:36 <Nibble_> 00:44 < ddarius> Nibble_: I doubt that.
15:48:38 <Nibble_> shit
15:48:40 <Nibble_> almost again
15:48:42 <Nibble_> 00:44 < Nibble_> ddarius: I just meant that there are more haskell people per job that there are java
15:48:45 <Nibble_> 00:44 < ddarius> Nibble_: I doubt that.
15:48:48 <Nibble_> hu
15:48:54 <Nibble_> if I had pressed that darn button one more time
15:48:59 <Nibble_> I would have been kicked for flooding.
15:49:24 <Heffalump> ddarius: well, we've never hired anyone in that position, but we did hire one person who had a Bachelors plus some basic Haskell experience.
15:49:41 <monochrom> oh darn, none of the tables has number of files per directory
15:50:09 <Philippa> heh, I guess all I have to do now is find somewhere that'll happily employ me for five unscheduled hours a week and I'm sorted then
15:50:35 <Nibble_> Heffalump: what is best
15:50:50 <Heffalump> Nibble_: what do you mean?
15:50:54 <Nibble_> wait
15:51:06 <napping> Philippa: Depends what kind of salary you want
15:51:32 <ddarius> Nibble_: The number of entry-level jobs /= the number of jobs.
15:51:38 <Nibble_> Heffalump: two bs or one ms?
15:51:42 <Nibble_> what is the best
15:51:51 <napping> I had a nice job one summer in high school wandering the CS department and doing random programming projects for whoever needed it
15:51:51 <Heffalump> one ms
15:52:16 <monochrom> getDirectoryContents source code looks like slurping lots of stuff and creating a lengthy list before returning.
15:52:43 <napping> monochrom: that's not the root of the problem, though you might very well be able to improve it if you care
15:52:58 <napping> monochrom: the given code runs for me in no more than 16MB, even compiled -O0
15:53:03 <monochrom> loop dirp = do { e<-readDirStream dirp; if ... then ... else do { es<-loop dirp; return (e:es) } }
15:53:08 <napping> (and trapped in a symlink loop under /sys)
15:53:27 <Philippa> napping: yeah, the marginal utility for me on 5 hours at any small multiple of minimum wage here is pretty much bugger all unfortunately - all the 'helpful' schemes for someone in my position only apply if you're doing 16+
15:53:52 <napping> Philippa: ooh, going above integer multiples of minimum wage is pretty hard
15:54:44 <Philippa> napping: different value of "small" :-)
15:54:59 <aavogt> napping: integers aren't supposed to be bounded
15:55:11 <napping> well < 10x
15:55:15 <napping> single digit, I guess
15:55:33 <danderson> so, design question. I have a parsing function that returns an Either String Packet
15:55:41 <Philippa> *nod*. Well, 5x doesn't show much improvement in my case, anyway
15:55:47 <danderson> now I'm writing some query helpers that return IO (Either String Packet)
15:56:00 <danderson> but I'd like to switch that to use EitherT, to get nice error fallthrough behavior
15:56:00 <Philippa> 10x would
15:56:16 <danderson> but how do I plug a pure Either into a transformed EitherT IO ?
15:56:18 <aavogt> @type ErrorT
15:56:19 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
15:56:19 <hpc> @unmtl EitherT
15:56:19 <lambdabot> EitherT
15:56:30 <aavogt> @type ErrorT . return
15:56:31 <lambdabot> forall (m :: * -> *) e a. (Monad m) => Either e a -> ErrorT e m a
15:56:38 <aavogt> danderson: ^^
15:57:48 <danderson> aavogt: thanks, parsing...
15:58:06 <aavogt> @type ErrorT . (return :: a -> IO a)
15:58:06 <lambdabot> forall e a. Either e a -> ErrorT e IO a
15:58:14 <danderson> wait, who's ErrorT and how did he get here
15:58:27 <aavogt> aren't they the same?
15:58:33 <aavogt> @src ErrorT
15:58:33 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
15:58:50 <danderson> yeah, pretty much, just a different name
15:58:57 <danderson> arguably better since I'm using Either for error handling
15:59:20 <aavogt> some people get all excited about error /= exception
15:59:32 <danderson> I'm just not sure why the two exist
15:59:52 <hpc> exceptions are kinda silly, like the Either monad shoved into IO
16:00:05 <hpc> oh wait... :D
16:00:58 <danderson> well, I suppose I could just use IO exceptions in this part of the code
16:01:18 <danderson> which then defeats the whole point of having used Either in the other part, rather than just "error and screw you"
16:01:48 <aavogt> there's a library on hackage that uses class constraints to force you to be explicit about unhandled exceptions or something like that
16:01:54 <aavogt> @hackage explicit-exception
16:01:54 <lambdabot> http://hackage.haskell.org/package/explicit-exception
16:02:15 <hpc> i approve of explicit exceptions
16:02:26 <aavogt> maybe it's not that one
16:02:26 <Heffalump> hpc: exceptions can come from pure code
16:02:46 <hpc> Heffalump: yes, but that's an abomination which shouldn't have existed
16:03:05 <Heffalump> do you claim non-termination shouldn't exist either?
16:03:23 <Nibble_> Heffalump: I define myself to be outside
16:03:34 <Heffalump> Nibble_: outside what?
16:03:39 <Nibble_> http://ifaq.wap.org/science/definetheproblem.html
16:03:59 <hpc> non-termination isn't a break with the workings of lambda calculus
16:04:12 <Heffalump> then neither are exceptions
16:04:33 <hpc> i don't see the logical bridge between non-termination and exceptions
16:04:55 <Heffalump> they can all be collapsed into the semantic value _|_, from the point of view of the pure code.
16:05:05 <Heffalump> (or, with a more refined semantics, you can look at the bag)
16:06:14 <napping> catching exceptions in pure code would be evil, but raising them is not so bad
16:06:21 <Heffalump> right
16:06:30 <hpc> so what would the type of an exception be?
16:06:37 <Heffalump> a
16:06:45 <hpc> so how would you look inside?
16:07:07 <Heffalump> sorry, I thought you meant in the pure code
16:07:18 <Heffalump> Once you catch them, they're whatever type the Exception was when thrown.
16:07:29 <Heffalump> but the throw operation produces a value of any type.
16:07:29 <hpc> why would they have two different types?
16:07:35 <Heffalump> @type throw
16:07:37 <lambdabot> Not in scope: `throw'
16:07:47 <monoidal> (Exception e) => e
16:08:06 <aavogt> no String argument?
16:08:10 <monoidal> (Exception e) => e -> a
16:08:12 <hpc> so any pure function that raises an exception should have an Exception e constraint
16:08:18 <danderson> oh dear, I believe I've started a religious war on error handling
16:08:24 <hpc> er
16:08:28 <Heffalump> no, because it can just discharge the constraint itself
16:08:30 <monoidal> throw (ErrorCall "X")
16:08:34 <Nibble_> hpc: there are no errors in functional-ism
16:08:42 <aavogt> throw ball
16:08:51 <Heffalump> hpc: are you aware of the paper "A semantics for imprecise exceptions"?
16:08:55 <Nibble_> since everything always evaluates to the same thing
16:09:06 <JuanDaugherty> Yi hah! or Jihad! or whatever
16:09:06 <mauke> Nibble_: non sequitur
16:09:12 <Nibble_> mauke: hu?
16:09:21 <Nibble_> it is to generalise a bit
16:09:26 <hpc> so what would the source of the throw operation be?
16:09:29 <Nibble_> but it applies in some cases
16:09:35 <hpc> or would it be more magic like IO?
16:09:36 <mauke> Nibble_: what if a function always evaluates to an error?
16:09:41 <Heffalump> it would be magic, like error.
16:09:42 <Nibble_> hpc: asset " lol"
16:09:48 <Nibble_> mauke: there would be no need fo rit
16:09:51 <Nibble_> assert*
16:09:55 <mauke> why not?
16:09:55 <Nibble_> for it*
16:10:00 <monoidal> @type assert
16:10:00 <lambdabot> Not in scope: `assert'
16:10:09 <Nibble_> monoidal: lol..
16:10:13 <hpc> so exceptions introduce magic to pure code...
16:10:21 <mauke> @hoogle assert
16:10:21 <lambdabot> Control.Exception assert :: Bool -> a -> a
16:10:22 <lambdabot> Control.OldException assert :: Bool -> a -> a
16:10:22 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
16:10:24 <hpc> which is precisely the kind of thing haskell shouldn't have
16:10:34 <Nibble_> well
16:10:46 <Nibble_> I say that there is no need for it, since there is so few things that can go wrong
16:10:47 <Heffalump> so you think error should be removed too?
16:10:53 <JuanDaugherty> saying "magic' makes you sound stupid
16:10:53 <Nibble_> Heffalump: nope
16:11:03 <Nibble_> Voodo is a better word
16:11:15 <Heffalump> I was asking hpc
16:11:16 <hpc> sure, error can be removed
16:11:19 <aristid> @src assert
16:11:19 <lambdabot> Source not found. You untyped fool!
16:11:22 <aristid> :/
16:11:30 <napping> ah, so elimination of pattern match failures and nontermination?
16:11:32 <aristid> lambdabot: never call me untyped again
16:11:32 <hpc> :t error
16:11:33 <lambdabot> forall a. [Char] -> a
16:11:39 <Heffalump> napping: not non-termination
16:11:41 <EvanR> but i like error
16:11:54 <Heffalump> but I presume hpc wants to remove pattern matching too, that's not in lambda calculus
16:11:56 <EvanR> @src head
16:11:57 <lambdabot> head (x:_) = x
16:11:57 <lambdabot> head []    = undefined
16:12:01 <napping> well, I guess you could leave that _|_
16:12:02 <hpc> error the function can be removed
16:12:18 <hpc> find me a first-class representation of a pattern match fail
16:12:21 <Nibble_> @src tail
16:12:22 <lambdabot> tail (_:xs) = xs
16:12:22 <lambdabot> tail []     = undefined
16:12:24 <napping> IO can already do all kinds of crazy reflection
16:12:35 <Nibble_> but, error checkking
16:12:35 * Heffalump goes to bed rather than continue the religious war
16:12:51 <Nibble_> there isn't a need as big as in C or C++
16:12:56 <Nibble_> From my understanding
16:13:04 <EvanR> not in a pure function
16:13:09 <Nibble_> EvanR: exactly
16:13:11 <EvanR> but head and tail are tricky
16:13:15 <EvanR> they arent safe
16:13:19 <napping> like measure how much time or memory evaluating some pure code takes
16:13:28 <mauke> Nibble_: all the important stuff is syscalls, and those need error checks
16:13:32 <monoidal> there's a paper on total haskell somewhere, and consequences of it
16:13:48 <hpc> failures of head and tail are ostensibly pattern match failures
16:13:50 <EvanR> ideally the important stuff is consolidated in pure code
16:13:53 <Nibble_> mauke: I still argue that it is a such small portion
16:13:56 <napping> as far as the pure code knows, you might as well have throw exn = throw exn
16:14:19 <monoidal> aside pattern matches, you have to forbid e.g. data T = T (T -> T) which can express fix
16:14:44 <hpc> total haskell as in guaranteed termination?
16:14:48 <mauke> :t In
16:14:49 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
16:14:52 <napping> yeah, you pretty much have to split data from codata
16:14:52 <monoidal> hpc: yes
16:14:58 <aristid> monoidal: don't you have to forbid recursion too?
16:15:02 <hpc> would that even be turing complete?
16:15:07 <monoidal> aristid yes, only well-founded one
16:15:16 <napping> hpc: no, and that's kind of the point
16:15:18 <monoidal> aristid: and this stops being Turing-complete
16:15:24 <Peaker> I am building a Trie over /usr/share/dict/words.  It seems like Map Char may not be the most efficient way to store a Trie node.. any idea about a cheaper approach?
16:15:43 <Peaker> Maybe I should use an IntMap over the Ord of the chars?
16:15:46 <EvanR> does anyone know of a haskell exercise list?
16:15:49 <aristid> monoidal: so the paper concludes that the consequences are too grave?
16:16:00 <EvanR> or work book
16:16:00 <Peaker> Is IntMap cheaper, in terms of memory, than Map?
16:16:02 <hpc> EvanR: project euler?
16:16:18 <EvanR> something haskell oriented and has easier problems?
16:16:31 <napping> Peaker: you could check the source, I think it uses unboxed ints
16:16:44 <monoidal> link to the paper on total haskell: http://lambda-the-ultimate.org/node/2003
16:16:47 <napping> you might also consider Array
16:16:55 <hpc> evanr: is this for you or someone else?
16:17:11 <monoidal> aristid: no, it concludes basically "enforcing totality is useful"
16:17:13 <hpc> because you might be able to make one
16:17:22 <EvanR> someone else but ideally there is 'two star' or advanced problems too
16:17:23 <wli> Map Char probably not since the branching factor and trie node residency is too small.
16:17:28 <aristid> monoidal: oh? despite losing turing completeness?
16:17:35 <monoidal> yes
16:17:49 <EvanR> hpc: thought about it but i dont know if im up to it 
16:17:53 <napping> aristid: how many programs do you actually write where you do not know whether it will terminate?
16:17:53 <hpc> you quarantine the totality, like you quarantine IO
16:18:06 <aristid> napping: i don't know whether i could prove it
16:18:08 <monoidal> aristid: it has some arguments, since rarely one writes something that's hard to prove to terminate
16:18:17 <hpc> EvanR: im sure others here can contribute ideas
16:18:20 <ClaudiusMaximus> EvanR: a textbook generally has exercises along with the main content
16:18:32 <EvanR> know the name of such a haskell textbook?
16:18:46 <ClaudiusMaximus> EvanR: eg: Bird's Introduction to Functional Programming using Haskell
16:18:47 <wli> Now if you had UTF-32/UCS-4 ...
16:18:48 <napping> aristid: and for servers and the like there's a dual notion of productive coiteration, which covers things like mapping over a lazy stream in such a way that you generate each additional value in finite time
16:18:49 <monoidal> aristid: except things like operating systems/streams, which are separated (data/codata)
16:18:53 <EvanR> ClaudiusMaximus: ah
16:19:05 <hpc> actually, the wikibook has exercises
16:19:19 <aristid> monoidal: is this like agda?
16:19:20 <EvanR> hpc: but good idea coming up with problems myself and getting reviews
16:19:28 <EvanR> sounds like a nice website
16:19:32 <napping> aristid: actually, that should be "coinduction"
16:19:58 <hpc> i would definitely be interested in reviewing what you come up with, for selfish reasons :D
16:20:17 <monoidal> aristid: i don't know agda much, but I think yes. You don't write "proofs" but just write in limited subset of haskell without some features
16:20:30 <napping> I'm not sure totality is so useful outside a theorem proving situation, though
16:20:51 <monoidal> aristid: sometimes it requires nontrivial restructuring, like when doing induction on binary digits of a number
16:20:51 <hpc> napping: for lambdabot's @eval?
16:20:54 <aristid> monoidal: and the subset is good enough to do things without being able to proof additional things?
16:21:00 <napping> hpc: hah, no
16:21:06 <monoidal> aristid: i think so
16:21:10 <Nibble_> quick question about something regarding haskell
16:21:14 <Nibble_> lambdas
16:21:20 <aristid> monoidal: hmm
16:21:24 <napping> hpc: I'm looking for a link, just a minute
16:21:49 <Nibble_> \ x -> \y -> x^2
16:22:04 <Nibble_> that's an expression, not a function, or?
16:22:09 <hpc> Nibble_: that's a function
16:22:11 <ezyang> Nibble_: It's an expression. 
16:22:14 <Nibble_> hehe
16:22:15 <monoidal> and an expression too
16:22:20 <Nibble_> lol
16:22:23 <Nibble_> three different things
16:22:23 <ezyang> > (\x -> \y -> x^2) 2 3 
16:22:25 <lambdabot>   4
16:22:25 <hpc> if you gave it a name, it would be foo x y = x**2
16:22:26 <mauke> Nibble_: it's an expression that evaluates to a function, so it's both
16:22:27 <Nibble_> I was expecting this
16:22:28 <monoidal> a function is a value just like a number
16:22:28 <napping> hpc: http://djm.cc/bignum-results.txt
16:22:37 <monoidal> an expression is something that when evaluated gives a value
16:22:45 <Nibble_> ok
16:22:47 <Nibble_> seems resonable
16:22:49 <Veinor> @pl \(a, b, c, d) -> hGetContents b
16:22:49 <lambdabot> (line 1, column 7):
16:22:50 <lambdabot> unexpected ","
16:22:50 <lambdabot> expecting letter or digit, operator or ")"
16:22:50 <lambdabot> ambiguous use of a non associative operator
16:22:53 <hpc> foo x y z = bar x y z ~> foo x y = \z -> bar x y z
16:22:54 <Peaker> I wish there was more diagnostics about stack overflows
16:22:58 <Veinor> @pl \(a, b) -> hGetContents b
16:22:59 <lambdabot> hGetContents . snd
16:23:20 <napping> hpc: it's quite trivial to write a a total function that would reach a recursion depth of oh, a trillion or so
16:24:21 <napping> and not much harder to do something like the winner of that contest and set up something that will end up with numbers way bigger you can write compactly with any silly knuth notation
16:24:35 <napping> so, not a replacement for timeouts and memory limits :)
16:24:39 <Nibble_> heard this joke?
16:25:01 <napping> actually, the first quote on the page is a decent description of the use of total programs in a proof environment
16:25:12 <EvanR> hpc: do problems typically take the form of 'define a function with these properties' or ?
16:25:32 <Nibble_> A bird flies at the speed of 5km/h, two trains are ten km from each other, they move at a speed of 2,5km/h towards each other. for how long does the bird fly?
16:25:40 <Nibble_> Von Neumann was asked this
16:25:45 <hpc> EvanR: some are like that, some are "implement a typeclass", and so forth
16:25:48 <napping> if you have a function with a type that claims to produce "evidence" that something is true, and you know it can't weasel out by nontermination, then you don't actually need to run it
16:25:57 <Nibble_> he replied instantly: 2h
16:26:04 <napping> Nibble_: as you've described it, for as long as the bird likes.
16:26:19 <Nibble_> napping: the bird moves at a speed of 5km/h sorry
16:26:45 <danderson> still an incomplete description
16:26:49 <danderson> starting position not specified
16:26:49 <napping> Nibble_: no, you left the bit about flying back and forth between the trains, and "stopping" when they "meet"
16:26:51 <danderson> end condition not specified
16:27:10 <Nibble_> napping: before writing this joke
16:27:18 <Nibble_> I realised that all of you would have read it before.
16:27:36 <Nibble_> so I just didn't care to write it correctly
16:27:39 <Nibble_> ok?
16:27:39 <napping> hmm, though not mentioning that constraint does make the clever solution a bit more obvious
16:27:40 <hpc> .oO (this question is impossible; "train" is a verb)
16:29:03 <KaneTW> not neccessarily
16:29:04 <Veinor> ... why does process-1.0.1.3 keep installing every time I cabal-install a script that I'm writing?
16:29:21 <napping> So, yes, Von Neumann was pretty darn quick
16:30:10 <napping> It's a bit surprising, now that I think about it, that thinking maybe twice as fast as people expected made such a huge difference
16:30:20 <aavogt> is it a homing pidgin?
16:30:30 <Veinor> also, cabal install process keeps installing itself when I say 'cabal install process'
16:30:39 <danderson> what if it's a kiwi?
16:30:52 <hpc> is it an african swallow, or a european swallow?
16:30:53 <danderson> then the answer is zero, since it'll waddle between the two trains, not fly
16:30:58 <aavogt> birds probably can't fly at 5km/h
16:31:04 <aavogt> that's rather slow
16:31:10 <m3ga> Q : how do i convert this example http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28292#a28292 which works with Control.OldException to Control.Exception?
16:31:13 <Nibble_> aavogt: if the wind is blowing towards them
16:31:19 <Nibble_> they can indeed fly that slow
16:31:30 <aavogt> air speed
16:31:52 <aavogt> Nibble_: that's what you'd specify anyways
16:34:04 <aavogt> m3ga: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28292#a28293
16:35:54 <m3ga> aavogt: thanks.
16:38:42 <Veinor> hm...
16:41:11 <napping> As tricky as it is, using the GADTs and typeclasses seems to be a win for wrangling my herd of Maps
16:47:33 <Veinor> okay. right now I have process-1.0.1.3 installed in user and global. every time I cabal install this program, it recompiles it.
16:48:26 <aavogt> perhaps the install is broken due to other dependencies being broken
16:48:31 <Veinor> nah, it works fine
16:49:07 <Veinor> it just recompiles it each time
16:49:27 <c_wraith> if it recompiles it every time, something in your package database isn't right.
16:49:38 <Veinor> okay, so how do I fix it?
16:50:05 <Veinor> or at least find out what's wrong
16:50:31 <Saizan> Veinor: you probably have upgraded some dependency of process in the past
16:50:38 <napping> there's no standard Bool -> a -> Maybe a, is there?
16:50:54 <aavogt> what would it be?
16:51:07 <napping> \b v -> if b then Just v else Nothing
16:51:07 <aavogt> @type guard
16:51:08 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:51:14 <napping> or, guard b >> return v
16:51:38 <aavogt> const return
16:51:45 <hpc> > let _|_ = undefined in _|_
16:51:45 <Veinor> Saizan: ... possibly
16:51:45 <lambdabot>   <no location info>: parse error on input `|'
16:51:51 <hpc> :(
16:52:08 <Veinor> each time I cabal install process, it installs it again, so it's not something weird in my project
16:52:30 <napping> does ghc-pkg show it?
16:52:33 <Veinor> yeah, twice
16:52:35 <aristid> hpc: i wonder if unicode has that symbol
16:52:39 <Veinor> in /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.3/package.conf.d
16:52:51 <Saizan> Veinor: it's a know bug in Cabal, what does cabal install process --dry-run -v says?
16:52:53 <Veinor> and in ~/.ghc/i386-darwin-6.12.3/package.conf.d
16:52:59 <hpc> aristid: it does, just don't have my handy 65535-cell table next to me
16:53:27 <hpc> plus a giant multi-char bottom is aesthetically better
16:53:31 <aristid> hpc: you have only yourself to blame for this blatant oversight.
16:53:33 <Saizan> Veinor: two installations of process-1.0.1.3 confuse the current cabal, but we also need to figure out why it installed the second one at all
16:53:40 <napping> that would be a nice table
16:53:56 <Veinor> okay.
16:53:58 <napping> I'm thinking mosaic
16:54:08 <napping> 1cm tiles
16:54:26 <napping> not much of a market, I guess :(
16:54:37 <aristid> > let ⏊ = undefined in ⏊
16:54:38 <lambdabot>   <no location info>: parse error on input `⏊'
16:54:45 <aristid> :(
16:54:58 <Veinor> http://pastebin.com/7NKHxxeP
16:55:27 <hpc> it doesn't like |
16:55:39 <hpc> oh, that's single-width
16:55:40 <Veinor> that's what I get.
16:55:42 <stelleg> is anyone here doing work on Strictness Analysis?
16:56:04 <Saizan> Veinor: ok, so if you get rid of directory-1.0.1.2 and the user process-1.0.1.3 it should be fine, unless you explicitly need directory-1.0.1.2 for some reason
16:58:28 <Veinor> yeah, that does it
16:58:36 <Veinor> but what if for some reason I did need directory-1.0.1.2?
16:59:30 <ddarius> > maxBound :: Char
16:59:31 <lambdabot>   '\1114111'
16:59:59 <aristid> > ord (maxBound :: Char)
17:00:00 <lambdabot>   1114111
17:00:09 <aristid> \ is decimal?
17:00:27 <ddarius> > '\32'
17:00:27 <Veinor> > '\32'
17:00:28 <lambdabot>   ' '
17:00:29 <lambdabot>   ' '
17:00:34 <c_wraith> > text [maxBound :: Char]
17:00:35 <lambdabot>   􏿿
17:00:46 <aristid> > text "ä"
17:00:47 <lambdabot>   ä
17:00:51 <c_wraith> ...  Did lambdabot just crash those connections?
17:00:56 <c_wraith> That would be kind of funny.
17:01:00 <c_wraith> and easy to test...
17:01:02 <ddarius> c_wraith: I doubt it.
17:01:04 <c_wraith> > text [maxBound :: Char]
17:01:05 <lambdabot>   􏿿
17:01:11 <ddarius> But then I could be wrong...
17:01:12 <c_wraith> looks like it to me. :)
17:01:34 <ddarius> You guys may want to get a better client...
17:01:59 <ddarius> Probably never know that we're talking to/about them.
17:02:05 <aristid> 􏿿
17:02:08 <aristid> LOL
17:02:24 <aristid> *must refrain from exercising instincts*
17:02:31 <Benny_> Haha, I'm pretty sure I know what client that is
17:02:42 <Saizan> Veinor: a workaround is to manually install a process-1.0.1.3.1 by editing the .cabal file
17:02:47 <Benny_> Oh wow, I'm wrong :O
17:02:50 <dankna> VERSION telepathy-idle 0.1.6 Telepathy IM/VoIP Framework http://telepathy.freedesktop.org
17:03:15 <Benny_> Crazy, I thought that there could only be one client that stupid
17:03:22 <Veinor> Saizan: hm :/
17:03:37 <Benny_> I wonder...
17:03:39 <Benny_> Aww
17:03:43 <aristid> Benny_: never underestimate the ability of C programmers to produce crashes :P
17:03:54 <Benny_> So at least it's not the same code, since that would have crashed them
17:04:00 <Benny_> I think at least
17:04:05 <Benny_> Maybe it was this: 
17:04:12 <ddarius> Benny_: Does that make it better?
17:04:14 <Nibble_> aristid: I would argue that c programmers produce less crashes than C++ programmers
17:04:16 <Benny_> (I'm inserting empty color/bold codes)
17:04:23 <Nibble_> templates is a pain in the ass
17:05:25 <Saizan> Veinor: i'm also working on solving the problem within Cabal/cabal-install, it's actually working in my tests, so i guess i could put a tarball on c.h.o you could try
17:05:32 <Veinor> nah, it's fine
17:05:58 <aristid> > text '\1114110'
17:05:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:05:59 <lambdabot>         against inferred ty...
17:06:06 <aristid> > text "\1114110"
17:06:08 <lambdabot>   􏿾
17:06:24 <aristid> so it doesn't seem to depend on the specific code.
17:07:36 <Benny_> водка
17:08:10 <aristid> > text "\65535"
17:08:11 <lambdabot>   �
17:08:19 <aristid> > text "\65536"
17:08:20 <lambdabot>   𐀀
17:08:36 <aristid> > text "\65537"
17:08:37 <lambdabot>   𐀁
17:08:52 <aristid> so it's not the BMP border, hmm
17:10:09 <lambda_complex> Hi! I'm just learning Haskell, and I've been inspired by Hudak's book to play with some 2D graphics. Other than the SOEGraphics packages, what is the "de facto" package for drawing 2D stuff in Haskell (I;m
17:10:11 <Saizan> Veinor: http://code.haskell.org/~Saizan/cabal-noconfusion/ <- there they are, anyhow :)
17:10:32 <lambda_complex> Whoa, line noise. I blame my new keyboard. (:
17:10:49 <lambda_complex> Anywho, I'm using GHC, but you knew that.
17:11:02 <dankna> > text "\100000"
17:11:03 <lambdabot>   
17:11:19 <dankna> > text "\1000000"
17:11:20 <lambdabot>   󴉀
17:11:26 <dankna> > text "\10000000"
17:11:27 <lambdabot>   <no location info>:
17:11:27 <lambdabot>      lexical error in string/character literal at chara...
17:11:43 <dankna> > text "\1100000"
17:11:44 <lambdabot>   
17:11:49 <dankna> > text "\1110000"
17:11:50 <lambdabot>   􎿰
17:11:54 <dankna> > text "\1114000"
17:11:55 <lambdabot>   􏾐
17:12:00 <dankna> > text "\1114100"
17:12:01 <lambdabot>   􏿴
17:12:09 <dankna> > text "\1114110"
17:12:10 <lambdabot>   􏿾
17:12:34 <dankna> > text "\1114109"
17:12:34 <lambdabot>   􏿽
17:12:35 <Saizan> lambda_complex: i wonder, maybe cairo?
17:12:40 <Nibble_> lambdabot
17:12:42 <napping> lambda_complex: lots under http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
17:12:47 <Nibble_> is she written in haskell?
17:12:50 <dankna> so it has a problem with exactly two codepoints
17:12:51 <napping> cairo with gtk for interactive stuff is pretty popular
17:12:53 <dankna> the final ones
17:13:08 <napping> wow, there are a few more libaries than I remember
17:14:09 <napping> gloss is supposed to be pretty simple, and is done over OpenGL
17:14:25 <dankna> I like to use OpenGL directly for stuff
17:14:44 <napping> that works too, I guess
17:15:02 * napping wishes there was some way to map over heterogeneous tuples
17:15:05 <hpc> i just wish gpipe had the whole api
17:15:11 <napping> I just want to show them all
17:15:37 <napping> but no, I have to make some kind of typeclass and GADT evidence that all are showable
17:15:38 <Nibble_> is lambdabot written in haskell?
17:15:47 <napping> well, maybe simpler just to write a typeclass that does the showing
17:15:51 <napping> Nibble_: mostly, I think
17:15:55 <hpc> napping: calling show on the tuple isn't enough?
17:15:58 <Nibble_> napping: source?
17:16:24 <hpc> > (45, "yes")
17:16:25 <lambdabot>   (45,"yes")
17:16:29 <napping> hpc: well, it's a nested tuple so it's a bit ugly
17:16:44 <aristid> @where lambdabot
17:16:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:16:58 <hpc> but just calling show will require instances for every sub-tuple
17:17:01 <aristid> Nibble_: http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:17:12 <hpc> and so on to the values themselves
17:17:12 <napping> yeah, I've got those
17:17:45 <aristid> and http://haskell.org/haskellwiki/Lambdabot
17:17:55 <napping> hmm, maybe a TH thing wouldn't be that bad
17:24:53 <Veinor> okay, I've just spent the last half an hour agonizing over a design decision
17:25:19 <Benny_> Veinor: Use XML
17:25:23 <Veinor> :P
17:26:04 <olsner> Veinor: use an applicative functor
17:26:17 <Benny_> To parse XML!
17:26:46 <Saizan> XML that represents an applicative expression.
17:26:48 <Veinor> well, the question is... I'm writing a script for my $PS1 that outputs my pwd, user@host, and a few other things
17:27:15 <etpace> is there a fold where I can halt and return the acc? something like foldl (
17:27:19 <etpace> oops
17:27:30 <zachk1> you could roll your own 
17:27:49 <etpace> yeah, was wondering if there was anything in prelude though
17:27:57 <etpace> or well nt prelude
17:28:00 <etpace> but somewhere :p
17:28:04 <Saizan> foldM with EitherDoneRight
17:28:16 <Saizan> or Cont
17:29:09 <etpace> :t foldM
17:29:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:29:40 <Saizan> ?type let abort x = Cont \_ -> x in abort
17:29:42 <lambdabot> parse error on input `\'
17:29:46 <Saizan> ?type let abort x = Cont $ \_ -> x in abort
17:29:48 <lambdabot> forall r a. r -> Cont r a
17:30:44 <etpace> wonder if thats easier than just explicit recursion
17:32:36 <Saizan> ?type let foldE f z xs = flip runCont id $ foldM (\a b -> either abort return (f a b)) z xs; abort x = Cont $ const x in foldE
17:32:37 <lambdabot> forall a b. (a -> b -> Either a a) -> a -> [b] -> a
17:32:53 <Saizan> nicer API?:)
17:34:46 <etpace> aha
17:35:46 <thebloggu> can someone tell what's wrong with this code? http://pastebin.com/HAXWPYH3
17:37:02 <thebloggu> i'm sorry, that one is not the one i wanted. this is the one: http://pastebin.com/vN2wcKx4
17:37:27 <Saizan> you should first tell us why you think it has something wrong
17:37:33 <Phyx-> well. the error would be useful
17:37:36 <Saizan> i.e. do you get an error?
17:37:59 <zachk1> try using do notation and explicit let's and see if it works correctly 
17:38:47 <etpace> hmm Saizan 
17:38:58 <etpace> i think a simple head . filter would work for me
17:39:04 <Saizan> btw, flip (!!) x == (!! x)
17:39:11 <aavogt> thebloggu: what does ghc say is wrong?
17:39:44 <Saizan> ?type find -- etpace
17:39:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:40:07 <etpace> or that ;)
17:41:39 <thebloggu> Saizan,Phyx-,aavogt: ghci outputs this: http://pastebin.com/wNvRYePn
17:41:53 <thebloggu> Saizan: thanks for the tip :)
17:42:47 <hpc> @djinn (a -> Bool) -> [a] -> Maybe a
17:42:48 <Saizan> thebloggu: oh, right, you lack a "return ." there
17:42:48 <lambdabot> Error: Undefined type []
17:42:54 <aavogt> thebloggu:  ... >>= return .    ....
17:43:15 <Saizan> thebloggu: btw, m >>= return . f == fmap f m
17:43:37 <Saizan> or "f <$> m" if you import Control.Applicative
17:43:44 <Saizan> which might be nicer to read.
17:44:00 <Phyx-> why are there so many functions that do the same :|
17:44:11 <hpc> <$> should really be in functor
17:44:39 <Phyx-> well, shouldn't fmap also really be a functor?
17:45:01 <Saizan> fmap is in the Prelude
17:45:27 <hpc> fmap is /exported/ by prelude
17:45:56 <ezyang> Does Hackage have any copy-on-write data structures? 
17:46:04 <kfish> <$> is (also) in functor
17:46:10 <Saizan> yeah, but it's not defined in any standard module, is it?
17:46:12 <Phyx-> *sigh* time to fullfill my geekly family duties and format this pc
17:46:16 <ezyang> I'm not quite sure how this is different from being persistent. 
17:46:21 <hpc> :t (Control.Functor.<$>)
17:46:22 <lambdabot> Couldn't find qualified module.
17:46:29 <Phyx-> Saizan: but since fmap is , why define <$> aswell?
17:46:33 <kfish> data.functor
17:46:39 <hpc> :t (Data.Functor.<$>)
17:46:40 <lambdabot> Couldn't find qualified module.
17:46:54 <Phyx-> :t <$>
17:46:55 <lambdabot> parse error on input `<$>'
17:46:56 <Saizan> Phyx-: because infix operators are nicer for some expressions
17:47:00 <Phyx-> :t (<$>)
17:47:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:47:12 <Saizan> it mixes better with (<*>), in particular
17:47:18 <Phyx-> heh
17:47:28 <aavogt> the precedences are different
17:47:37 <etpace> i think it looks better overalll anyway
17:47:52 <Saizan> ?type liftA -- this one is just for consistency, i guess
17:47:53 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
17:47:55 <hpc> fmap looks a bit better in pointfree
17:48:16 <Saizan> oh, it's actually defined via pure, it seems
17:48:30 <hpc> the lifts are a nice teaching tool, to make it oh so painfully obvious that monad and applicative are very similar
17:48:33 <kfish> fmap . fmap . fmap
17:48:40 <hpc> and mutually definable
17:49:13 <Saizan> mutually?
17:49:54 <hpc> i think so, yes
17:50:59 <interferon> are there any large haskell web applications?
17:51:14 <Saizan> you can't define join with Applicative
17:51:17 <interferon> especially with things like snap, it seems like there ought to be
17:51:26 <thebloggu_> did someone get the chance to take a look at my code?
17:51:38 <hpc> @src join
17:51:39 <lambdabot> join x =  x >>= id
17:52:28 <Veinor> @pl \x y -> f x y []
17:52:29 <lambdabot> flip flip [] . f
17:52:30 <Saizan> thebloggu_: did you get disconnected? you lack a "return ." in front of process anyhow
17:53:10 <interferon> how is "join x" different from "x"?
17:53:28 <hpc> > join [[1,2],[3,4]]
17:53:28 <lambdabot>   [1,2,3,4]
17:53:37 <Saizan> for example :)
17:53:40 <hpc> > join ["yes", "no"]
17:53:40 <lambdabot>   "yesno"
17:53:48 <Phyx-> :t guessPaths
17:53:48 <lambdabot> Not in scope: `guessPaths'
17:53:58 <Phyx-> I hate memory leaks
17:54:03 <thebloggu_> Saizan: i'm sorry if i sound stupid, but i'm still trying to get monads right. when i use (>>=) do i need to have a return after it?
17:54:17 <ezyang> thebloggu_: Not usually 
17:54:35 <hpc> (Just (Just 4)) <$> id
17:54:39 <ezyang> tehbloggu_: Follow the types. 
17:54:40 <interferon> thebloggu_: only if the value on the right-hand side isn't in the monad
17:54:41 <hpc> > (Just (Just 4)) <$> id
17:54:41 <lambdabot>   Couldn't match expected type `a -> b'
17:54:42 <lambdabot>         against inferred type `Data.M...
17:54:56 <hpc> > (Just (Just 4)) <*> id
17:54:57 <lambdabot>   Couldn't match expected type `a -> b'
17:54:57 <lambdabot>         against inferred type `Data.M...
17:55:01 <ezyang> and in that case, you don't even need >>= 
17:55:03 <interferon> thebloggu_: e.g. getLine >>= putStrLn (both are in IO), but getLine >>= return . length  (length is pure)
17:55:14 <Saizan> thebloggu_: you need return when you have to promote a value into a monadic action, i.e. something of type A to something of type M A where M is the monad
17:55:17 <ezyang> (liftM length . getLine) 
17:56:13 <Saizan> thebloggu_: you could think of return making a statement out of an expression, that way it's very similar to imperative languages
17:56:15 <interferon> length <$> getLine
17:56:51 <hpc> :t (<*> id)
17:56:52 <lambdabot> forall a b. (a -> a -> b) -> a -> b
17:57:13 <hpc> :t (<*> pure)
17:57:14 <lambdabot> forall b a (f :: * -> *). (Applicative f) => (a -> f a -> b) -> a -> b
17:57:15 <thebloggu_> ezyang: Saizan: interferon: oh, i got it, thanks. but then what's the best way the print the results of current and forecast in the same way as i have in my main?
17:57:17 <aavogt> @type length . getLine
17:57:17 <lambdabot> IO Int
17:57:27 * Phyx- has to apologize, after rewriting some of his fmaps, <$> does look nicer
17:57:38 <interferon> i love <$>
17:57:53 <interferon> aavogt: length . getLine is not type-correct
17:57:56 <aristid> is there a reverse <$>?
17:58:02 <aristid> :t flip fmap
17:58:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
17:58:19 <interferon> aristid: reverse?
17:58:19 <etpace> how do you write fmap . fmap . fmap with <$> though
17:58:22 <aavogt> interferon: is here
17:58:26 <aristid> interferon: as in flip
17:58:36 <aristid> :t \a b -> a >>= return . b
17:58:37 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> a1) -> m a1
17:58:49 <interferon> aristid:  =<<, i think
17:58:55 <interferon> :t (=<<)
17:58:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:58:57 <aristid> interferon: no, reverse of <$>
17:59:00 <aristid> flip (<$>)
17:59:00 <Saizan> thebloggu_: oh, there your problem is that current and forecast are not Strings they are actions that will produce strings when run, so you need >>= there too, or do-notation
17:59:03 <aristid> just as an operator
17:59:27 <interferon> :t flip (<$>)
17:59:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
17:59:29 <Saizan> thebloggu_: main = do c <- current; f <- forecast; putStrLn $ unwords [c,f]
17:59:29 <interferon> :t (>>=)
17:59:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:59:38 <aristid> note the additional m
17:59:40 <interferon> aristid: actually, looks like >>=
17:59:54 <Phyx-> how the...
17:59:57 <interferon> aavogt: how?
18:00:00 <Phyx-> @type length . getLine
18:00:01 <lambdabot> IO Int
18:00:04 <Phyx-> heh
18:00:08 <Phyx-> @type length
18:00:09 <lambdabot> forall a. [a] -> Int
18:00:10 <interferon> what's going on there?
18:00:12 <interferon> :t length
18:00:13 <lambdabot> forall a. [a] -> Int
18:00:13 <Phyx-> @type getLine
18:00:14 <interferon> :t getLine
18:00:14 <lambdabot> IO String
18:00:15 <lambdabot> IO String
18:00:16 <interferon> :t (.)
18:00:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:00:21 <Phyx-> wtf
18:00:27 <Phyx-> who redefined (.)
18:00:38 <aristid> Phyx-: Cale
18:00:44 <interferon> aristid: why?
18:00:49 <Phyx-> oh, I thought i was going crazy :P
18:00:50 <aristid> why what?
18:01:00 <interferon> did he redefine (.)
18:01:06 <Cale> Because it can be :)
18:01:15 <hpc> because (.) == fmap, specialized
18:01:16 <Cale> The current definition is a generalisation of the usual one
18:01:20 <aavogt> I was pointing out  ezyang | (liftM length . getLine)
18:01:26 <aavogt> (or I tried)
18:01:31 <Phyx-> interferon: to screw with our heads, that's reason enough for everyone here :P
18:01:37 <hpc> there's other neat ones too, like (++) = mplus
18:01:44 <aavogt> flip
18:01:48 <hpc> :t (++)
18:01:48 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:02:18 <aavogt> .oO ( we could have a fixed Monad class here too )
18:02:35 <aavogt> I guess that's more work though
18:03:06 <Cale> aavogt: Yeah, quite a lot more work.
18:03:14 <m3ga> i have a large chunk of XML in a ByteString. what do people recommend to parse it (ie without unpacking it to a String)?
18:03:28 <Cale> aavogt: At present I just import the Prelude hiding a handful of definitions, and define those things locally.
18:03:49 <Cale> aavogt: But redefining the Monad class usefully would require rebuilding all the other modules which use it.
18:04:41 <aavogt> surely that's just a few s///?
18:05:20 <aavogt> but maybe not
18:08:06 <meteficha> m3ga: there are mainly two ways of parsing XML files
18:08:37 <meteficha> m3ga: if you want to recreate the XML tree in memory, there are many alternative packages, of which I'm told 'xml' is the simplest that works fine.
18:08:43 <meteficha> m3ga: see http://hackage.haskell.org/packages/archive/xml/1.3.7/doc/html/Text-XML-Light-Input.html
18:09:11 <meteficha> m3ga: you could also try something like hexpat or tagsoup
18:09:32 <meteficha> m3ga: which support SAX-like processing of the XML file
18:10:00 <meteficha> instead of creating the whole tree, you get "events" like "open this tag", "get this content", "close that tag"
18:10:32 <meteficha> m3ga: SAX on Wikipedia: http://en.wikipedia.org/wiki/Simple_API_for_XML
18:10:57 <meteficha> m3ga: SAX processing with Haskell isn't as ugly as with Java and can be pretty fast.
18:11:02 <meteficha> m3ga: hope that helps ;)
18:12:08 <zeiris> Suppose I have an existing network protocol. I want to describe its packet structure -once-, and generate data structure, serialization, deserialization, pretty printing, and god-knows-what-else functions automatically. Can Haskell do that?
18:12:41 <zeiris> (Preferably without resorting to Template Haskell, where it seems I may as well write my own code generator.)
18:12:45 <meteficha> zeiris: that's an interesting question and I started to think about this since this weekend
18:13:05 <meteficha> zeiris: there is one package on Hackage to do parsing and pretty printing, although it is very crude
18:13:20 <meteficha> zeiris: http://hackage.haskell.org/package/bidispec
18:13:27 <meteficha> zeiris: http://hackage.haskell.org/package/httpspec
18:13:55 <meteficha> zeiris: other than this I can't give you more pointers, sorry
18:15:26 <ClaudiusMaximus> > sqrt $ 4 / pi
18:15:26 <lambdabot>   1.1283791670955126
18:17:36 <zeiris> The only ideas I have, lack compile-time type safety. Using tuples or lists or whatever for data repr.
18:20:10 <zeiris> Also, damn it, yet another Hackage package with zero documentation. Type signatures might give a hint as to what the function does, but nothing about how to use it...
18:20:29 <zeiris> Has there ever been motivation to have some kind of community documentation program?
18:20:34 <meteficha> zeiris: go directly to the source code, that's what I did :)
18:20:35 <ddarius> zeiris: You could represent the format in a generic manner and "interpret" out those functions, perhaps using things like the finally tagless techniques, but Drift or TH would be the most direct routes and would save you having to manually add some meta-information.
18:21:04 <meteficha> zeiris: I'm thinking about an EDSL with a language clooooose to a parser
18:21:24 <meteficha> zeiris: however everywhere you construct something you need to be able to deconstruct it as well
18:22:01 <meteficha> zeiris: for example, you can't say 'fmap Just', you need something like 'otherfmap Just (\(Just x) -> x)'
18:22:09 <ddarius> meteficha: You'd want to look at languages like Boomerang and its relatives/predecessors.
18:22:14 <meteficha> zeiris: however this is just handwaiving
18:22:38 <meteficha> ddarius: those are languages designed for that, right?
18:23:26 <ddarius> Boomerang is a language that will have properties like that built-in, yes.
18:24:15 <meteficha> ddarius: if a DSL exists somewhere, then we can do the same with a Haskell EDSL, right? :D
18:24:29 <ddarius> The lenses/functional accessors/a couple of other names libraries on Hackage do embed such features to varying degrees.
18:24:38 <meteficha> ddarius: and probably generic enough to accomodate different parser/pretty-printing libraries
18:25:45 <meteficha> ddarius: you mean, 'pointless-lenses'?
18:26:41 <ddarius> There are several packages: lenses, fclabel, data-accessor and no doubt others
18:34:16 * hackagebot RSA 1.0.5 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-1.0.5 (AdamWick)
18:34:40 <m3ga> meteficha: i looked at xml, but couldn't figure out how to maje it accept ByteString data
18:35:28 <meteficha> m3ga: just use parseXML or parseXMLDoc from Text.XML.Light.Input
18:36:01 <meteficha> m3ga: String, strict ByteStrings and lazy ByteStrings are instance of XmlSource.
18:36:33 <meteficha> m3ga: so parseXML/parseXMLDoc works with all three.
18:38:44 <m3ga> metaliving: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28297#a28297
18:39:01 <m3ga> its complaining about ByteString
18:40:13 <askhader> I'm attempting to solve a problem that involes computations with geographical map projections, are there any useful libraries for this already defined in haskell?
18:46:11 <meteficha> m3ga: probably you have an old version of 'xml'.
18:46:22 <meteficha> m3ga: http://hackage.haskell.org/packages/archive/xml/1.3.7/doc/html/Text-XML-Light-Input.html
18:46:28 <meteficha> m3ga: http://hackage.haskell.org/packages/archive/xml/1.2.6/doc/html/Text-XML-Light-Input.html
18:46:58 <m3ga> nope, 1.3.7 here
18:47:14 <m3ga> ghc-6.12.1
18:47:42 <meteficha> m3ga: really?  what does ':t parseXML' on GHCi give you?
18:47:45 <solrize> i wonder if it makes any sense to unify the different bytestring functions with string and list functions, using type families.  i hate converting a string-using program to bytestrings for speed, then having to figure out what places i have to change "map" to B.map"
18:48:39 <m3ga> parseXML:: (Text.XML.Light.Lexer.XmlSource s) =>s -> [Text.XML.Light.Types.Content]
18:48:50 <m3ga> they type seem right
18:49:01 <meteficha> m3ga: perhaps you have two versions of the library?
18:49:08 <meteficha> m3ga: try loading that source file into GHCi
18:49:13 <meteficha> m3ga: using :load
18:49:44 <m3ga> metaliving: i only install pre-compiled debian packages (ie no cabal-installed stuff)
18:49:58 <m3ga> the package manager says i have 1.3.7
18:50:56 <Saizan> "ghc-pkg list xml"
18:51:17 <m3ga> /var/lib/ghc-6.12.1/package.conf.d
18:51:21 <m3ga>    xml-1.3.7
18:51:24 <m3ga> and thats it
18:52:10 <m3ga> i'll try the same code on my freebsd vm where i only use cabal-install
18:53:04 <Saizan> doesn't really make sense, unless you're also using dat somewhere else
18:53:13 <Saizan> or it could be defaulting..
18:53:44 <m3ga> the code in the paste is the whole file.
18:54:14 <meteficha> m3ga: i'm compiling the 'curl' package to test the paste myself
18:54:25 <applicative> where is the IsString for ByteSring
18:54:32 <m3ga> meteficha: thanks for taking the time
18:54:50 <applicative> The type error is "curlGetXml connectInfoUrl" isn't it?
18:54:52 <meteficha> m3ga: no problem 
18:55:18 <applicative> connectInfoUrl is a string.
18:55:29 <meteficha> m3ga: my ghci loaded fine :D
18:55:45 <m3ga> applicative: yes, but curlGetXml returns ByteString
18:55:50 <meteficha> m3ga: I've just removed the lines after ------ on your paste
18:55:51 <m3ga> explict type annotation
18:55:52 <applicative> metaficha, with the file m3ga posted?
18:55:55 <meteficha> m3ga: and it worked
18:55:57 <meteficha> applicative: yep
18:56:26 <meteficha> GHC 6.12.3
18:56:41 <m3ga> so that means there is something wrong with the xml package I installed?
18:57:03 <meteficha> using -Wall just says that import of Data.ByteString is redundant, nothing else.
18:57:34 <meteficha> m3ga: I don't really know, because your GHCi seemed to have the right type for parseXml
18:58:01 <meteficha> m3ga: how about ":t \x -> parseXML (x::ByteString)
19:00:14 <m3ga> metaliving: i don;t use ghci much. do I need to load/import ByteSting and Text.XML first?
19:00:50 <meteficha> :m Text.XML.Light Data.ByteString
19:00:57 <meteficha> :t \x -> parseXML (x::ByteString)
19:00:58 <lambdabot> Not in scope: `parseXML'
19:00:58 <lambdabot>     Not in scope: type constructor or class `ByteString'
19:01:38 <m3ga> \x -> parseXML (x::ByteString) :: ByteString -> [Content]
19:01:40 <meteficha> m3ga: so yes, you need, just use :m until GHCi understands the usual import syntax.
19:02:00 <meteficha> m3ga: so it really knows that parseXML can accept ByteStrings :)
19:02:16 <m3ga> yes
19:02:33 <meteficha> m3ga: are you compiling that paste with GHC?
19:03:02 <Saizan> ghci understands "import Foo.Bar" btw
19:03:32 <meteficha> Saizan: oh, nice, I thought that feature was planned for 6.14 :D
19:03:42 <m3ga> meteficha: yes, ghc 6.12.1
19:04:04 <meteficha> Saizan: hmmm, but it doesn't support "import qualified" ='(
19:04:15 <Saizan> meteficha: right, nor any other fancyness
19:05:07 <m3ga> metaliving: thanks. it works on debian, doesn't work on ubuntu. definitely an ubuntu bug
19:06:03 <meteficha> m3ga: lol, this 'metaliving' guy won't understand why you are talking to him :)
19:06:29 <m3ga> damn autocomplete still can't read my mind :-)
19:07:09 <meteficha> m3ga: are you a native English speaker?  IME many read "mete" as "meta" subconsciously :)
19:08:21 <Saizan> "complete to the latest active first" is almost as good as mind-reading :)
19:11:16 <m3ga> yes, native english speaker, lazy/poor typist :-)
19:13:22 <applicative> m3ga, I see, mine didn't compile like yours; but now it does, I didn't have the new XML light
19:13:54 <Veinor> whoo, text processing in Haskell
19:14:08 * Veinor is starting to see why people like Perl >_>
19:14:23 <m3ga> tahnks everyone. looging a bug with ubuntu after i have some lunch
19:14:24 <Benny_> haha
19:14:43 <Benny_> I always throw up a little in my mouth thinking of processing test in Haskell
19:14:52 <meteficha> m3ga: good luck :)
19:14:57 <Benny_> <Me at work> Oh, I'll just write a little Haske-hahahahahahaha, oh me
19:15:16 <Saizan> unparse . processAST . parse
19:15:43 <applicative> it doesn't seem that grave a problem, its cabal install vs. apt problem
19:15:55 <roconnor> Saizan: if you are parsing into a data structure apparently it doesn't count as text processing anymore.
19:16:09 <m3ga> meteficha: i know it won't get fixed in ubuntu, i just think its important to log the bug
19:16:29 <m3ga> applicative: in my experience, apt and cabal-install do not play nicely together
19:17:16 <Saizan> roconnor: according to who? reddit?
19:17:18 <meteficha> m3ga: I'm a happy gentoo user and IME portage and cabal-install work nicely together
19:17:25 <meteficha> m3ga: I have libraries installed in both
19:17:35 <meteficha> m3ga: although I prefer using the real package manager
19:17:38 * Veinor is coding stuff to figure out the current state of a git repo
19:17:53 <Veinor> by looking at the output of git-status, git-branch, etc.
19:18:13 <m3ga> meteficha: i really like deb packages, especially for production stuff
19:19:08 <ezyang> Veinor: You don't want to use the porcelain commands 
19:19:14 <Veinor> why not?
19:19:25 <applicative> m3ga, do you have a good reason not to use cabal install?  
19:19:25 <ezyang> because they may change arbitrarily between releases 
19:19:40 <Veinor> and the other commands won't?
19:19:50 <ezyang> The plumbing commands will be more stable. 
19:20:25 <ezyang> anyway, this is the wrong chan for such things :-) 
19:21:06 <m3ga> applicative: a number of reasons. i find cabal-install a pita in comparison to apt-get. i need packages for autobuilder which starts with a base system and then installs the build-deps before doing the build
19:21:55 <meteficha> ezyang: two of the main reasons I prefer portage is 1) being able install binaries system-wide without hassle and 2) being able to uninstall a package cleanly
19:22:06 <ezyang> meteficha: Wrong person? 
19:22:21 <meteficha> ezyang: sorry, yes :P
19:22:31 <meteficha> applicative: I meant talking to you :P
19:22:40 <applicative> m3ga, i guess I had a similar thought, its just that I understand cabal install better than any package manager... so I suppress the package manager in haskell land.  but I think, this is not advised... 
19:22:42 <Zao> ezyang: Since when does zealots need to establish prior relationship with the victims?
19:23:02 <Benny_> Every package manager ever is awful at Haskell
19:23:05 <ezyang> Like those prosletyzers who come up to you in the streets and give you pamphlets? 
19:23:18 <Benny_> Ubuntu's ghc is probably still five years old
19:23:30 <ezyang> At risk of going off topic, I'd love to see a distro package manager that integrates well with sub-package managers that come with languages 
19:23:32 <m3ga> Benny_: lucid ships 6.12.1
19:23:36 <meteficha> Benny_: you should try Gentoo :D
19:23:50 <meteficha> Benny_: perhaps Arch, that's what dons uses I guess
19:23:55 <Benny_> I use Arch
19:24:09 <Benny_> Entirely because of crap like that from Ubuntu/Fedora
19:24:12 <Benny_> Mostly Ubuntu
19:24:21 <m3ga> Benny_: debian support for haskell has improved immensely in the last year. (using debian testing or unstable)
19:24:38 <m3ga> what is not in debian testing is about to transition to stable.
19:24:39 <Benny_> I've never really liked Debian
19:24:45 <meteficha> for us, developers, I think using a bleeding-edge distribution is better
19:25:02 <meteficha> but Ubuntu/Debian are quite nice for a non-developer
19:25:04 <Benny_> I like having new packages
19:25:35 <m3ga> haskell in debian testing is now very close to the bleeding edge
19:25:40 <applicative> In arch too we are supposed to use the package manager for haskell libs, no?  
19:26:05 <m3ga> don't have 6.12.3 yet bcause of the impending testing -> stable transition
19:26:46 <Benny_> I'd always end up having to recompile things on Ubuntu/Debian constantly, which ruins the whole point of having a package manager
19:26:55 <Benny_> * Ubuntu/Fedora
19:27:08 <meteficha> m3ga: I've used Debian unstable for quite a long time, I remember those dreadly transitions :)
19:27:16 <Benny_> Fedora has been better since 11, but Ubuntu still has some horribly ancient/broken packages 
19:27:38 <Benny_> It's always embarassing when I tell someone to install ghc and they say nothing works, because Ubuntu has such an old version
19:28:19 <Benny_> <Them> Well Haskell is stupid, I shouldn't have to download anything outside my package manager!
19:28:30 <danderson> grmbl; is there any way to check if a number is a valid value for a particular enum?
19:29:03 <m3ga> Benny_: the version in lucid is 6.12.1.
19:29:12 <aristid> Benny_: ubuntu has 6.12.1, is that too old?
19:29:26 <applicative> danderson, you mean, other than waiting for the typechecker to reject it?
19:29:29 <Benny_> I haven't tried it in a while, okay? :P
19:29:34 <Benny_> Before it was like 6.8.something
19:29:49 <meteficha> :t flip elem $ map fromEnum [minBound..maxBound]
19:29:50 <lambdabot>     Ambiguous type variable `a' in the constraints:
19:29:50 <lambdabot>       `Enum a' arising from a use of `fromEnum' at <interactive>:1:16-23
19:29:50 <lambdabot>       `Bounded a'
19:30:01 <meteficha> :t \x -> elem x $ map fromEnum [minBound..maxBound]
19:30:02 <lambdabot>     Ambiguous type variable `a' in the constraints:
19:30:02 <lambdabot>       `Enum a' arising from a use of `fromEnum' at <interactive>:1:19-26
19:30:02 <lambdabot>       `Bounded a'
19:30:17 <danderson> applicative: (toEnum 42) if 42 is not a valid enum value won't fail at compile time
19:30:17 <meteficha> :t \x -> elem x $ map fromEnum [minBound..maxBound `asTypeOf` x]
19:30:18 <lambdabot> Int -> Bool
19:30:19 <m3ga> Benny_: that was probably right for hardy the last long term support release
19:30:21 <danderson> it'll throw an error at runtime
19:30:33 <danderson> meteficha: you're assuming that the values are continuous.
19:30:55 <danderson> I have a discontinuous set of enum constructors (defines mapped in from C)
19:31:15 <meteficha> danderson: I'm just kidding in the sense that that function is terribly innefficient
19:31:40 <meteficha> danderson: but I thought enumFromTo shouldn't give any invalid intermediate results 
19:31:47 <rwbarton> Haskell's Enum is not very much like enum in C
19:31:59 <danderson> meteficha: okay, how do you find the valid starting value? :)
19:32:04 <meteficha> minBound
19:32:06 <meteficha> maxBound
19:32:16 <meteficha> danderson: so your Enum should be an instance of Bounded as well.
19:32:29 <danderson> which it can't be by automatic binding
19:32:36 <danderson> so I'm basically screwed, is what you're telling me.
19:32:41 <rwbarton> in fact, it doesn't really have a coherent meaning, it mainly exists to support enumFromTo etc.
19:36:24 <danderson> ooh
19:36:27 <danderson> meteficha: thanks.
19:36:37 <danderson> enumFromTo does indeed seem to work, from a quick test.
19:36:39 <meteficha> danderson: no problem, but please don't use that function :)
19:36:54 <PetRat> I read in typeclassopedia that there's a Monoid instance of Map. Can someone explain how that works. Obviously mempty is an empty map. What is map1 `mappend` map2?
19:36:56 <meteficha> danderson: unless you know that your domain range is very small
19:37:05 <danderson> meteficha: my domain range is very small :)
19:37:13 <meteficha> danderson: okay then, go ahead :)
19:37:18 <danderson> the Enum types are mappings of C enums
19:37:25 <danderson> it's dirty, but the alternative is to map them manually
19:37:35 <danderson> instead of semi-automatically with a little extra work at runtime
19:38:09 <applicative>  PetRat, the source says   mempty  = empty mappend = union mconcat = unions
19:38:09 <Saizan> PetRat: union
19:38:34 <PetRat> where do you find this source? 
19:38:58 <meteficha> PetRat: in other words, the result has all key/value pairs that either map have, and the values of the left map when both have the same keys
19:39:14 <PetRat> oh sorry I see it in Data.Map
19:39:37 <danderson> oh, darn
19:39:44 <danderson> meteficha: I take that back, it doesn't work :(
19:39:49 <PetRat> meteficha: I guess that's how it satisfies the monoid laws, e.g. associatiation, by giving priority to the left map
19:40:04 <danderson> it only works for C enums which happen to map a continuous range
19:40:16 <danderson> if discontinuous, it explodes.
19:40:35 <meteficha> PetRat: you could also define an instance the uses Monoid on the values (that is, mappends them when both have the same key), I guess
19:40:44 <Saizan> ?src enumFromTo
19:40:45 <lambdabot> Source not found.
19:41:02 <ClaudiusMaximus> :t (toEnum, fromEnum)
19:41:03 <lambdabot> forall a a1. (Enum a, Enum a1) => (Int -> a, a1 -> Int)
19:41:09 <meteficha> danderson: that function explots, or enumFromTo explodes?
19:41:18 <danderson> enumFromTo
19:41:24 <meteficha> danderson: how are you creating the Enum instances? by deriving (Enum)?
19:41:32 <Saizan> iterate succ ?
19:41:35 <danderson> meteficha: no, c2hs derives the instance
19:41:46 <meteficha> hmmmm... I don't know what c2hs does
19:41:52 <danderson> to map the right integer constants to the right constructors
19:42:10 <Saizan> danderson: can you paste one such instance?
19:42:11 <danderson> the instance defines toEnum and fromEnum, nothing else
19:42:15 <meteficha> its 'succ' implementation shouldn't be (+1) :)
19:42:28 <danderson> so it probably should be defining succ and pred properly
19:42:29 <meteficha> danderson: well, that's the problem then
19:42:43 <Saizan> ah, i see, then there's really no way it could work
19:42:45 <rwbarton> using fromEnum and toEnum for this purpose is kind of wrong
19:43:03 <meteficha> Saizan: it could work if it defined 'succ' manually
19:43:19 <rwbarton> c2hs should really use another class entirely
19:43:21 <meteficha> e.g. succ This = That; succ That = Foo...
19:43:22 <Saizan> meteficha: "then" was referring to how it's defined
19:43:32 <Saizan> +currently
19:44:00 <meteficha> rwbarton: IMHO c2hs should continue using Enum but providing the correct instances :D
19:44:17 <ezyang> meteficha: Well, then you have to change what integers you map to 
19:44:21 <ezyang> but then your C code stops working 
19:44:36 <ClaudiusMaximus> are there any laws that state   fromEnum . succ . toEnum  =  (+1)  or similar?
19:44:39 <Saizan> ezyang: do you?
19:44:51 <ezyang> no. 
19:44:56 <rwbarton> Enum is lawless territory :)
19:44:58 <ezyang> But my enums are nice and continuous :-) 
19:45:20 <danderson> meteficha: it'd also be nice to have extra functions; for example one to check if a Num is a valid enum value
19:45:38 <danderson> case in point, I have an enum which defines some values of the origin of an IP route
19:45:48 <meteficha> danderson: perhaps some generic hackery could give you a list of all possible Haskell values, from which you just apply 'fromEnum'.
19:45:54 <danderson> but the spec also says that "anything from 1-255 can be used freely by administrators"
19:45:59 <meteficha> danderson: that's the whole idea of [minBound..maxBound]
19:46:21 <Saizan> ClaudiusMaximus: no
19:46:56 <danderson> meteficha: the short term fix is to add definitions for succ/pred to the enum instance
19:47:03 <meteficha> danderson: perhaps some TH code
19:47:09 <Saizan> ezyang: i meant that there's no law that says fromEnum (succ x) == fromEnum x + 1
19:47:18 <danderson> since c2hs already knows the mapping of constructor to value at the time
19:47:34 <danderson> meteficha: seems better to tweak c2hs and fix it for everybody
19:47:52 <meteficha> danderson: as a quick fix, I'd just copy & paste the constructors, use an Emacs keyboard macro and try to sleep at night knowing that I wrote some ugly code :)
19:48:07 <meteficha> danderson: yes, that's the real solution
19:48:30 <danderson> meteficha: except this is generated code, so unless I stop reading the system values and separately hardcode the constants, I can't
19:48:44 <danderson> unless there's a ruby-like "reopen the instance for this type and add these functions" extensions?
19:49:09 <meteficha> danderson: I thought about listing the Haskell constructors, not the C values, do these change as well?
19:49:41 <Saizan> with TH you can get a list of the constructors too
19:50:11 <etpace> can I import qualified within ghci?
19:50:16 <danderson> meteficha: the c2hs code takes the name of a C enum, and generates a corresponding haskell data declaration and Enum instance
19:50:22 <Saizan> etpace: no
19:50:40 <danderson> but yeah, I suppose I could add a layer of TH
19:51:00 <danderson> it'll be the most convoluted file for miles around; first c2hs, then TH, then FFI
19:51:01 <bogiebro> etpace: you can with a development ghc version
19:51:10 <danderson> nobody will have any idea what the heck is inside :-)
19:51:18 <meteficha> danderson: lol \o/
19:52:00 <danderson> anyway, I'll sleep on it and see what I come up with. Thanks for the thoughts.
19:59:51 <cabbage`> .
20:00:13 <cabbage`> sure is quiet in here.
20:00:33 <Zao> Blissfully.
20:01:00 <cabbage`> oh, so there is someone else here.  mind if I bother you with a question?
20:02:17 <cabbage`> so I've been playing with monad transformers recently and I wrote a little function for practice.  It's 3 lines long and I don't know if it's "right"
20:02:31 <ezyang> Don't ask to ask questions :-) 
20:02:36 <cabbage`> (already asking)
20:02:38 <ezyang> post it and see :-) (hpaste probably) 
20:04:05 <cabbage`> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28302#a28302
20:04:20 <cabbage`> i was just trying to write a little function that prints a list of pairs using no recursion
20:04:25 <cabbage`> but its super ugly... must be a nicer way
20:05:30 <rwbarton> You could use forM_
20:05:44 <ezyang> Yeah, in this case use one of the list-monad fucntions 
20:05:48 <ezyang> *functions 
20:05:58 <rwbarton> forM_ vals $ \(key, val) -> putStrLn (key ++ ": " ++ val)
20:06:18 <cabbage`> ohh, interesting.   quite a lot shorter.
20:06:20 <cabbage`> thank you.
20:12:34 <PetRat> test
20:12:47 <meteficha> PetRat: 10-4
20:13:05 <PetRat> If Monoid e => ((,) e) is an instance of Applicative, why am I getting an error here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28303#a28303
20:13:46 <ezyang> What are your imports? 
20:14:16 <ezyang> Also, to the left of <$> should be a normal function 
20:14:32 <ezyang> so you probably want <*> instead 
20:14:48 <ezyang> > ("a", (+2)) <*> ("b", (2)) 
20:14:49 <lambdabot>   ("ab",4)
20:15:00 <PetRat> ezyang: ah, that was it
20:16:25 <PetRat> > pure (+2) <*> ("a",2)
20:16:26 <lambdabot>   ("a",4)
20:22:32 <ezyang> If I have a table of well-typed lambda terms, and I see this giant fractions, what do those indicate? 
20:22:37 <ezyang> Also, what does the sideways T mean? 
20:23:02 <ezyang> paper in qusetion: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.9849 
20:23:17 <rwbarton> I forget what they're called but they're basically inference rules
20:23:21 <rwbarton> or evaluation rules
20:23:22 <ClaudiusMaximus> usually the giant fractions are rules, given the top stuff the bottom stuff follows
20:24:00 <ezyang> ah, ok. 
20:24:04 <ezyang> How about the sideways T? 
20:24:05 <applicative> the ordinary logical meaning  x |- y  is x proves y
20:24:15 <ezyang> savvy 
20:24:28 <applicative> x |= y ,  x entails y by model
20:24:45 <ezyang> wait, how is that different from →? 
20:24:49 <Saizan> in typechecking it divides the context from the term :)
20:25:19 <applicative> Saizan, yes, but the general logical use comes first
20:25:30 <rwbarton> in particular the context can introduce variables which are free in the term
20:25:30 <Saizan> etpace: look at the rule for lambda and you'll see the connection
20:25:50 <ezyang> Hmm, maybe I should look up some text that defines this and figure the notation out 
20:26:39 <ezyang> What's the difference between a Context and a Type Context? 
20:26:41 <applicative> wait, how is that different from ??    -- in plain logic |- relates sentences, -> is syntax used to form sentences
20:26:48 <applicative> |- is 'meta'
20:27:54 <ezyang> Hmm, I guses I should find the original HM paper 
20:28:25 <Saizan> http://en.wikipedia.org/wiki/Deduction_theorem <- also
20:28:50 <ezyang> Saizan: ah, excellent 
20:28:58 <ezyang> (also, I was confused by your autocompleting etpace :-) 
20:29:39 <applicative> ezyang, the diagrams here are complicated by the context   C;  typing claims |- other typing claim
20:29:58 <ezyang> Does |- or -> have higher precedence? 
20:30:02 <ezyang> (which binds more tightly?) 
20:30:06 <Saizan> ezyang: http://en.wikipedia.org/wiki/Sequent_calculus#Inference_rules <- more about the syntax
20:30:25 <ezyang> ah, even more excellent 
20:30:28 <applicative> -> for sure, though that's not the way to look at it. 
20:30:49 <applicative> Gentzen, the absolute master....
20:31:33 <Saizan> though in typing rules the RHS of |- will usually always be a statement of the form "term : type"
20:32:03 <Saizan> some actually prefer to see the whole thing as a three-place relation _|-_:_
20:32:36 <ezyang> Great, Sequent calculus makes the LK syntax crystal clear 
20:32:55 <Saizan> the inference rules translate naturally to prolog clauses or constructors for a gadt, if that helps :)
20:33:10 <ezyang> not... really. yet. :-) 
20:34:02 <ezyang> Oooh, contexts in this paper are the implicit parameter typing 
20:34:20 <ezyang> whereas type contexts are traditionally on the lhs of => 
20:34:25 <applicative> wow, the wikipedia page on natural deduction has been sabotaged by overeager Martin Lofites http://en.wikipedia.org/wiki/Natural_deduction
20:37:08 <lispy> hello
20:37:30 <lispy> What exciting code did we write today?
20:38:01 <dolio> applicative: It has?
20:38:17 <applicative> p Prop p True etc
20:38:25 <applicative> you wont find those in Gentzen
20:38:35 <dolio> Oh, true.
20:38:57 <_Ray_> In lambda-calculus, does this represent the identity function? (λx. x)
20:39:18 <Saizan> yes
20:39:24 <applicative> actually, it looks pretty dangerous to me, from the point of view of informing people of the basic idea....
20:39:24 <lispy> ?pl \x -> x
20:39:25 <lambdabot> id
20:39:28 <_Ray_> Thanks :)
20:41:03 <applicative> which is why i was looking at it, to separate  the sequent calculus, complicated by |- , and the 'giant fractions' that are also in his natural deduction
20:43:12 <dolio> prop versus true and such prepares you for more complicated stuff, though.
20:43:15 <dolio> Like modal logic.
20:45:56 <applicative> dolio, maybe, it seems to me that just to display the standard Gentzen figures of or introduction, or elimination, etc etc.
20:46:11 <_Ray_> Hrmph. What would be the difference between, knowing that F :: Int -> Int,  "F(n) = if n == 0 then 1 else n * F(n - 1)" and "F = \n.  if n == 0 then 1 else n * F(n - 1)"? Is the latter even valid Haskell?
20:46:12 <applicative> throw a flood of light on everything in the universe
20:46:34 <ezyang> Where can I find out what "axiomatic semantics" and "translational semantics" are? 
20:46:41 <ezyang> The WP article is not being very helpful 
20:47:04 <ezyang> _Ray_: No difference. 
20:47:22 <ezyang> > let f n = if n == 0 then 1 else n * (f (n-1)) in f 4 
20:47:23 <_Ray_> What's the "= \n. " notation representing, then?
20:47:23 <lambdabot>   24
20:47:38 <ezyang> > let f = \n -> if n == 0 then 1 else n * (f (n-1)) in f 4 
20:47:40 <lambdabot>   24
20:47:43 <ezyang> lambda. 
20:49:10 <_Ray_> Ah, ok. One assigns an anonymous function to f, the other just talks about f
20:49:21 <applicative> \n. p  is the standard way  forming a lamba term. given that \ is lambda
20:49:23 <_Ray_> Which should be essentially the same
20:49:31 <ezyang> yep 
20:49:36 <ddarius> ezyang: http://www.cs.uiowa.edu/~slonnegr/fsspl/Contents.html
20:49:40 <_Ray_> Thanks :)
20:49:44 <ezyang> ddarius: cool, looking. 
20:50:20 <applicative> _Ray_ here's the standard syntax http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28306#a28306
20:50:24 <ezyang> oh, it's a book, no text :-( 
20:50:37 <ezyang> maybe google books has it 
20:51:49 <ddarius> ezyang: I'm pretty sure it used to be available online.
20:52:05 <ddarius> http://www.cs.uiowa.edu/~slonnegr/fsspl/Ordering.html
20:52:12 <ezyang> oh, yes it is 
20:52:22 <ezyang> http://www.cs.uiowa.edu/~slonnegr/plf/Book/ 
20:52:38 <mjrosenb> is Control.Monad.State not part of the boot libraries anymore?
20:52:48 <ezyang> mtl good sir 
20:52:51 <ddarius> ezyang: That's it.  I knew it was somewhere.
20:55:26 <drbean> The historical background of the natural deduction article is nice. None of the people in it I've ever heard of. http://en.wikipedia.org/wiki/Natural_deduction
20:58:29 <applicative> drbean, http://plato.stanford.edu/entries/proof-theory-development/#NatDedSeqCal looks a lot better to me. 
20:59:46 <dibblego> @hoogle (Traversable t, Monoid a) -> t a -> a
20:59:47 <lambdabot> Warning: Unknown type Traversable
20:59:47 <lambdabot> No results found
21:06:45 <applicative> hah, I see a noted haskell hacker is the author of the associated http://plato.stanford.edu/entries/logical-constants/
21:10:14 <ezyang> What does a squiggly arrow mean in the translational semantics table? 
21:10:40 <Saizan> "reduces to", usually
21:10:56 <lispy> Saizan: big step reduction?
21:11:03 <ezyang> ah, excellent. 
21:11:06 <drbean> I like that page. And the historical approach to understanding logic.
21:11:22 <lispy> Or just that it reduces there after some number of steps?
21:11:49 <ezyang> wait, but it's on both sides of the fraction. Mrr? 
21:11:54 <ezyang> oh, that makes sense 
21:19:33 <ttmrichter> join #jruby
21:20:06 <lispy> Anyone release a new library today?
21:24:16 <applicative> lispy, did you?
21:24:33 <lispy> applicative: nope :)
21:24:42 <lispy> I've scarcely uploaded anything to hackage
21:25:03 <lispy> I've heard a rumor that dons used to do a library a week
21:25:17 <ezyang> Under what circumstances would you use \() -> ... in Haskell? 
21:26:09 <lispy> ezyang: I'm not sure.  I've seen that in code that is trying to be strict, but I'm not sure how well it works
21:26:35 <lispy> ezyang: I mean, if something returns say, m (), and you do () <- foo, then does it really force anything more than just foo
21:26:35 <ezyang> Wouldn't you use rnf and friends in that case? 
21:26:43 <Cale> (\() -> expr) would be a reasonable way to avoid sharing.
21:27:10 <ezyang> Cale: Ah, that's true. When would you want to avoid sharing, though? 
21:27:21 <ezyang> I guess if you're unsafe-perform-ioing 
21:27:41 <lispy> How does it avoid sharing?
21:27:52 <_Ray_> Given a function f :: a -> b, what type would the fixed point of f be?
21:28:02 <Cale> In cases where the expression you're evaluating is much smaller than the amount of memory used by the thing it evaluates to, and you'll want to recompute it later.
21:28:03 <ClaudiusMaximus> ezyang: when you have a lazy infinite structure in an interactive program, it's sometimes better to recompute than to share, trading time for (possibly infinite) space
21:28:17 <lispy> _Ray_: How can you find the fixed point?
21:28:20 <Cale> lispy: Results of functions are not memoised
21:28:22 <lispy> :t fix unsafeCoerce
21:28:23 <lambdabot> Not in scope: `unsafeCoerce'
21:28:27 <ezyang> Cale: aha 
21:28:47 <lispy> ?hoogle unsafeCoerce
21:28:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:28:51 <_Ray_> lispy, not fully sure about the concept yet, reading a bit about it, 's why I asked what type it would be
21:29:15 <lispy> :t fix
21:29:15 <ezyang> Now, let me change things slightly: Any reason to use \() -> ... that changes the /semantics/ of the program? 
21:29:16 <lambdabot> forall a. (a -> a) -> a
21:29:25 <Cale> ezyang: no
21:29:33 <ezyang> Ok. 
21:29:44 <ezyang> dolio discovered a case in which it does change the semantics of the program :-) 
21:29:50 <lispy> where is unsafeCoerce located?  That hoogle was wrong
21:29:54 <ezyang> but you need to add very silly types :-) 
21:30:00 <ezyang> http://hackage.haskell.org/trac/ghc/ticket/4226 
21:30:10 <ezyang> I'm trying to figure out whether or not it's a bug or a feature. 
21:30:11 <aavogt> lispy: no it's there
21:30:19 <Cale> Well, sure. Evaluating \() -> expr doesn't evaluate expr
21:30:26 <lispy> Could not find module `Unsafe':
21:30:38 <aavogt> lispy: Unsafe.Coerce.unsafeCoerce
21:30:40 <dolio> The types change the semantics.
21:30:50 <dolio> But are subsequently displayed the same.
21:30:58 <lispy> oh, weird, there is no Unsafe but there is Unsafe.Coerce, got it.  Thanks
21:31:13 <_Ray_> Well. Given the function f :: Int -> Int, f = \n -> if n = 0 then 1 else n * (f (n-1)), I'm told its fixed point is g :: (Int -> Int) -> Int, where g(fact) = \n -> if n = 0 then 1 else n * (fact (n-1)). Is this true? If so, how does it fit with :t fix?
21:31:14 <lispy> _Ray_: :t fix unsafeCoerce 
21:31:14 <lispy> fix unsafeCoerce :: a
21:31:24 <lispy> _Ray_: What happens is that the b becomes a
21:31:37 <dolio> > let x :: (?x :: Int) => Int ; x = let ?x = 5 in ?x in let ?x = 4 in x
21:31:38 <lambdabot>   5
21:31:48 <dolio> I guess that doesn't work, though.
21:32:22 <aavogt> lispy: just like how there isn't a Control or Data module (at least in the common libraries)
21:32:33 <ezyang> dolio: yeah, you need the higher rank one 
21:32:34 <lispy> _Ray_: in your exmaple fix and g have similar types, but fix's type uses 'a' and g uses Int
21:33:01 <dolio> ezyang: I'm pretty sure it's not supposed to work that way.
21:33:07 <dolio> I'm kind of amazed it does.
21:33:13 <_Ray_> Oh, ok, yeah, I see :t fix now. It's a = Int in this case. Cool :)
21:33:14 <ezyang> I know... I know... 
21:33:29 <ezyang> But there should be a mechanism to get that behavior, so that Oleg is happy. 
21:34:32 <lispy> Whatever Oleg wants, Oleg gets (as long as it's in the type system)
21:34:37 <lispy> ?olegfact
21:34:37 <lambdabot> Unknown command, try @list
21:34:43 <lispy> ?quote olegfact
21:34:43 <lambdabot> No quotes match. Where did you learn to type?
21:34:47 <lispy> ?quote oleg
21:34:48 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
21:34:51 <dolio> Oleg can write his own implicit parameters in the type system.
21:34:52 <lispy> ?quote oleg
21:34:52 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
21:35:17 <lispy> ?quote oleg
21:35:17 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
21:35:36 <lispy> There was one about unsafePerformIO in the type system or something like that
21:35:42 <ezyang> It's true. 
21:35:59 <applicative> "unsafePerformIO in the type system " -- youre kidding?
21:36:17 <lispy> applicative: yeah, it's a spoof on chuck norris facts
21:36:38 <lispy> applicative: but, the type system is an untyped programming language
21:38:05 <aavogt> there are kinds
21:39:49 <dolio> Yeah, it's simply typed.
21:40:06 <dolio> With a giant trash heap datatype.
21:40:16 <ezyang> Hmm, Oleg's implementation still needs to pass around opaque values which are the "names" 
21:40:18 <dolio> For all the nullary stuff.
21:40:27 <ezyang> Ok, time to figure out if I can combine the two for great justice 
21:41:40 <lispy> dolio: trash heap?
21:41:43 <lispy> Not sure I understand
21:41:54 <aavogt> *
21:41:59 <lispy> oh
21:42:16 <dolio> Instead of having lots of different datatypes, built by constructors, you put them all in a single datatype.
21:42:17 <lispy> Kinds, trash heap of the *s
21:42:53 <dolio> data Star = (Star, Star) | Either Star Star | Zero | Suc Star | Star -> Star | ...
21:42:57 <lispy> When I was a kid, we only had one datatype and we were happy.
21:43:38 <p00ya> we used the bit and we were happy with its dual non-recursive nature!
21:43:42 <ddarius> There's nothing trash heapy about *.  There -is- only one base kind.
21:44:39 <ddarius> There are no kind level naturals or pairs or sums and * -> * is not the same thing as *.
21:45:06 <_Ray_> So 'fix f' is just (f(f(f(f(f(......))))), and it works because Haskell is lazy?
21:45:28 <_Ray_> (Missed one closing parenthesis there)
21:45:34 <ddarius> _Ray_: Yes.
21:45:53 <ddarius> _Ray_: Though it would be little trouble to modify it slightly so that it would work in an eager language.
21:45:59 <ezyang> You don't even need silly tricks like the Y combinator :-) 
21:46:23 <ezyang> actually, that doesn't have anything to do with lazy/eager 
21:46:35 <ezyang> that has to do with the availability of letrec 
21:46:42 <_Ray_> letrec?
21:46:52 <ezyang> let bindings that are allowed to be recursive 
21:46:55 <_Ray_> ah
21:46:58 <ezyang> @src fix 
21:46:59 <lambdabot> Source not found. Are you on drugs?
21:47:07 <ezyang> by default Haskell's are 
21:47:09 <_Ray_> fix f = f(fix f)
21:47:18 <ddarius> fix f = let x = f x in x
21:47:23 <applicative> > fix show -- my favorite
21:47:24 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:47:28 <_Ray_> wtf
21:47:32 <aavogt> @src foldMap
21:47:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:47:35 <_Ray_> oh. right. escape and escape.
21:47:35 <aavogt> @src drugs
21:47:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:47:59 <mm_freak> i sometimes use fix to write recursive formulae
21:48:14 <mm_freak> > fix (\r x y -> x : r y (x+y)) 0 1
21:48:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:48:29 <_Ray_> At what rate does the spacing between " in fix show grow? 2^n?
21:48:41 <ezyang> _Ray_: Well, what do you think? 
21:48:52 <_Ray_> 4^n-1, or something.
21:49:02 <lispy> > map length . group . fix $ show
21:49:08 <lambdabot>  Terminated
21:49:13 <lispy> > map length . take 10 . group . fix $ show
21:49:15 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
21:49:20 <dolio> ddarius: It's trash heapy if you try to use it for actual programming.
21:49:26 <dolio> Writing partial functions all over the place.
21:49:26 <_Ray_> Yeah, 4^n-1.
21:49:36 <etpace> thats not 4^n-1
21:49:43 <ddarius> dolio: It's just sparse.
21:49:45 <_Ray_> err, 4*n-1.
21:49:47 <BMeph> Try 2^n-1.
21:49:52 <lispy> > filter (/= 1) . map length . take 10 . group . fix $ show
21:49:53 <lambdabot>   [3,7,15,31]
21:50:48 <_Ray_> Oh, right, every \\ gets transformed into \\\\, so duplicate each one. 
21:51:09 <BMeph> I.e., It has to start with a '"', because it's a String. But, to print a '"', takes an escaping backslash. Ditto for backslashes themselves.
21:51:48 <aavogt> > iterate show "\\"
21:51:49 <lambdabot>   ["\\","\"\\\\\"","\"\\\"\\\\\\\\\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\\\\\\...
21:52:04 <jesusabdullah> o_o
21:52:24 <_Ray_> cool. :)
21:52:28 <ddarius> > fix error
21:52:29 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:54:50 <lispy> Hmm...so foldl1 (==) iterate, is a form of fixed point?
21:54:56 <lispy> Well, fixed point finder
21:55:11 <lispy> Er, actually no
21:55:28 <lispy> But what I wanted to express was that iterate should stop when adjacent elements are equal
21:57:14 <dolio> foldl doesn't stop until the end of the list.
21:57:26 <lispy> true
21:57:46 <aavogt> @type map snd . take 1 . dropWhile (uncurry (/=)) . (\x -> zip x (tail x)) . iterate ?f
21:57:49 <lambdabot> forall a. (Eq a, ?f::a -> a) => a -> [a]
21:58:29 <lispy> > let escape k x y = k (x + y) in foldr (escape id) 0 [1..4]
21:58:30 <lambdabot>   10
21:58:42 <lispy> That did not, actually escape
21:59:15 <lispy> But, I've been thinking that given a suitable continuation, you could write a foldr that way that does stop early
22:00:01 <aavogt> > foldr const undefined [1..10]
22:00:01 <lambdabot>   1
22:00:07 <aavogt> > foldr const undefined [1..]
22:00:07 <lambdabot>   1
22:00:21 <mtnviewmark> anyone here generate haddock w/hscolour from cabal?
22:00:27 <mtnviewmark> as in
22:00:35 <mtnviewmark> cabal haddock --hscolour=some.css
22:00:36 <mtnviewmark> ?
22:00:39 <lispy> mtnviewmark: haddock does
22:00:42 <lispy> er god
22:00:44 <lispy> hackage does
22:01:01 <mtnviewmark> is that only command you need?
22:01:08 <aavogt>  --hyperlink-source
22:01:08 <lispy> That I don't know
22:01:18 <aavogt> mtnviewmark: there's no flag for cabal the executable
22:01:26 <aavogt> you have to use   Setup.lhs
22:01:26 <mtnviewmark> aavogt - that's to haddock, right? 
22:01:42 <lispy> aavogt: you can pass options to haddock from cabal
22:01:47 <aavogt>  runghc Setup hadock --hyperlink-source
22:01:50 <mtnviewmark> uhm, well, there *IS* a --hscolour flag to cabal's haddock command, and a separate hscolour command in cabal
22:02:09 <lispy> you just need a special flag --haddock-options=OPTS 
22:02:26 <ttmrichter> Does anybody know when the Haskell Platform for Ubuntu/Lucid will be updated to the latest version?
22:02:44 <mtnviewmark> hmmm.. wonder what --hscolour flag to cabal haddock does, then
22:02:44 <lispy> ttmrichter: in 3 years? ;)
22:03:05 <ttmrichter> lispy: That bad, eh?  :D
22:03:07 <mtnviewmark> ... didn't seem to do anything on my machine, except insist that the .css file existed!  :-O
22:03:09 <etpace> @hoogle a -> b -> IO b
22:03:09 <lambdabot> Prelude seq :: a -> b -> b
22:03:10 <lambdabot> Control.Parallel par :: a -> b -> b
22:03:10 <lambdabot> Control.Parallel pseq :: a -> b -> b
22:03:23 <lispy> ttmrichter: well, I don't know.   Ubuntu is pretty crazy about upgrading things.
22:03:32 <lispy> ttmrichter: But if it were debian, I would say 3 years
22:03:36 <ttmrichter> This is a PPA, though, not the main respository.
22:03:49 <ttmrichter> The PPAs tend to be bleeding edge.  (In many cases emphasis on bleeding....)
22:04:24 <etpace> > let echo s = print s >> return s in return True >>= echo >>- print
22:04:25 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> m b'
22:04:25 <lambdabot>         against inferre...
22:04:29 <aavogt> lispy: which option do you pass to haddock then?
22:05:50 <lispy> aavogt: Maybe I misunderstood you.  I thought you said that cabal was missing an option to pass to haddock
22:06:01 <mtnviewmark> okay, so runhaskell Setup.hs haddock --hyperlink-source   worked for me
22:06:32 <mtnviewmark> but I've been invoking haddock via cabal since I need to re use --with-haddock  and --haddock-option
22:06:33 <lispy> mtnviewmark: but cabal haddock --hyperlink-source doesn't work?
22:06:54 * lispy boggles
22:07:07 <aavogt> that option doesn't exist
22:07:26 <mtnviewmark> oh - it does!
22:07:35 <mtnviewmark> aavogt - it does exist and works
22:07:48 <aavogt> oh for haddock
22:07:51 <lispy> $ cabal haddock --help | grep "\--hyperlink-source"
22:07:51 <lispy>     --hyperlink-source     Hyperlink the documentation to the source code
22:07:57 <aavogt> I want it for cabal install
22:08:13 <mtnviewmark> right  it *IS* in cabal install
22:08:32 <lispy> --PROG-options=OPTS            give extra options to PROG
22:08:37 <lispy> that's for cabal install
22:08:52 <lispy> so, cabal install --haddock-options="--hyperlink-source" should work
22:09:02 <lispy> If so, put that in your preferences fiel
22:09:03 <lispy> file*
22:09:22 <mtnviewmark> no no didn't need that
22:09:33 <mtnviewmark> oh ah oy
22:09:43 <mtnviewmark> I'm running "cabal haddock" in an unpacked project
22:09:47 <aavogt> lispy: that makes haddock fail
22:10:03 <lispy> hah
22:10:04 <lispy> Lame
22:10:10 <lispy> I don't know then
22:10:18 <lispy> try with --verbose=3
22:10:22 <mtnviewmark> right - --hyperlink-source isn't an option of haddock - haddock doesn't know how to invoke hscolour
22:10:22 <lispy> see if you can figure out the difference
22:10:38 <mtnviewmark> it is an option of cabal, but only if you invoke the haddock command directly in an unpacked project
22:10:57 <mtnviewmark> (I'm echoing what I think you've helped me figure out)
22:11:25 <lispy> mtnviewmark: But, you might try running -v3 on both commands to see what the differences are.  You might be able to manually supply the missing bits?
22:11:27 <mtnviewmark> it isn't, sigh, an available option for "cabal install" - which leaves one unable to have access to the source pages for projects installed that way
22:12:08 <aavogt> complain here http://hackage.haskell.org/trac/hackage/ticket/517 or at similar bugs
22:12:29 <aavogt> the issue was bikeshedding over how flags should look really
22:15:03 <lispy> > let escape k x y = k (x + y) in foldr (escape const) 0 [1..4]
22:15:04 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
22:16:51 <aavogt> > foldr (\n (b,t) -> if b then (b,t) else (t > 5, b+t)) (False,0) [1..]
22:16:52 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
22:16:52 <lambdabot>    arising from the literal `5'...
22:17:00 <aavogt> > foldr (\n (b,t) -> if b then (b,t) else (t > 5, n+t)) (False,0) [1..]
22:17:01 <lambdabot>   *Exception: stack overflow
22:17:39 <aavogt> oh, we never get to touch the accumulating parameter
22:18:43 <aavogt> > foldr (\n _ -> if n > 5 then const else (n:)) undefined [1..] []
22:18:44 <lambdabot>   Couldn't match expected type `b -> [a]' against inferred type `[a]'
22:18:58 <lispy> aavogt: we could if we resume
22:19:02 <aavogt> :t foldr (\n _ -> if n > 5 then const else (n:)) undefined [1..]
22:19:03 <lambdabot>     Couldn't match expected type `b -> [a]' against inferred type `[a]'
22:19:03 <lambdabot>     Probable cause: `:' is applied to too many arguments
22:19:03 <lambdabot>     In the expression: (n :)
22:19:09 <aavogt> :t foldr (\n _ -> if n > 5 then const else (n:)) undefined
22:19:10 <lambdabot>     Couldn't match expected type `b -> [a]' against inferred type `[a]'
22:19:10 <lambdabot>     Probable cause: `:' is applied to too many arguments
22:19:10 <lambdabot>     In the expression: (n :)
22:19:25 <aavogt> > foldr (\n -> if n > 5 then const else (n:)) undefined [1..] []
22:19:26 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
22:19:38 <aavogt> > foldr (\n -> if n > 5 then id else (n:)) undefined [1..] []
22:19:38 <lambdabot>   Couldn't match expected type `[a] -> t'
22:19:39 <lambdabot>         against inferred type `[a1]'
22:19:48 <aavogt> hmm, this isn't working out
22:21:55 <aavogt> > foldr (\n -> if n > 5 then const [n] else (n:)) undefined [1..]
22:21:56 <lambdabot>   [1,2,3,4,5,6]
22:22:41 <aavogt> > foldr (\n -> if n > 5 then const n else (n+)) undefined [1..]
22:22:42 <lambdabot>   21
22:23:04 <aavogt> lispy: resume which?
22:23:28 <lispy> aavogt: I'd like it to return something that we can call to continue the fold
22:23:48 <aavogt> return a list?
22:24:12 <lispy> More like, (current value, continuation)
22:28:09 <ezyang> I beat Oleg's RegionIO code into this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28312#a28312 
22:28:21 <ezyang> Could I have made the LiftTo typeclasses more compact? 
22:31:48 <aavogt> @type foldr (\n a -> if n > 5 then \k -> k n else \k -> (?op n (a k))) undefined [1..]
22:31:49 <lambdabot> forall a t. (Num a, Ord a, ?op::a -> t -> t, Enum a) => (a -> t) -> t
22:33:17 <lispy> hmm
22:33:28 <aavogt> so t could be a tuple
22:34:49 <Saizan> ezyang: the instances don't make sense to me
22:35:09 <ezyang> Saizan: Yeah, they're Oleg style weird. (But they work :-) 
22:35:46 <ezyang> Basically, we use the type of a label to figure out how many lifts we need to prepend to any given ask so that we get the "right" readerT 
22:36:03 <aavogt> @type foldr (\n a k -> if n > 5 then k n else ?op n (a k) `const` (?a `asTypeOf` a)) undefined [1..]
22:36:04 <lambdabot> forall a a1. (Num a, Ord a, ?op::a -> a1 -> a1, ?a::(a -> a1) -> a1, Enum a) => (a -> a1) -> a1
22:36:21 <Saizan> ezyang: Oleg ones make more sense, usually :)
22:37:07 <ezyang> Saizan: Oh noes 
22:37:22 <ezyang> Maybe I need a better name 
22:37:32 <lispy> :t (,)
22:37:32 <lambdabot> forall a b. a -> b -> (a, b)
22:37:42 <lispy> aavogt: I don't think t can be a tuple
22:37:51 <lispy> aavogt: or rather, op can't be (,)
22:38:25 <ezyang> Here's a new version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28313#a28313 
22:38:33 <aavogt> infinite types
22:40:34 <lispy> aavogt: So, I think n should be a continuation and a is a list element
22:41:38 <lispy> aavogt: at least, position-wise, n is the accumulator, or the thing we thread, so I think we need to generate the call to the next step of the fold and pass it in that parameter
22:42:50 <Saizan> ezyang: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28313#a28315 two instances suffice. and less parameters
22:43:25 <ezyang> Oh, clever! 
22:43:35 <ezyang> Should've guessed. :-) 
22:43:58 <ezyang> though, calling m2... m2 is a little bit of a misnomer, eh? 
22:44:07 <ezyang> oh, no it isn't nevermind :-) 
22:44:41 <ezyang> I also understand why people like transformers over mtl now :-) 
22:44:57 <Saizan> why?
22:45:37 <int80_h> good evening everyone
22:45:37 <ezyang> I /think/ that for mtl, I have to add another instance to support vanilla Reader 
22:45:41 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28314#a28314
22:45:47 <ezyang> but for transformers there's no need for an extra instance 
22:45:58 <int80_h> anyone care to take a look at my problem? I'm building a blog based off of the yesod tutorials.
22:46:18 <ezyang> int80_h: Is that data structure yours? 
22:46:26 <ezyang> IO String is, while not out of the question, slightly odd. 
22:46:36 <ezyang> are you trying to do lazy IO? 
22:47:02 <int80_h> well, I made it based off of the tutorial, but it was the result of sussing out what I wanted to do , here on this channel.
22:47:19 <lispy> aavogt: oh, heh, n/m I was misread the type.  It is the second param that needs to be the continuation
22:47:31 <int80_h> I am trying to only read a file when it is referenced
22:47:48 <lispy> ?src foldr
22:47:48 <lambdabot> foldr f z []     = z
22:47:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:47:52 <int80_h> the data structure works fine. I need to get the code to conform to the data structure.
22:47:58 * ezyang thinks maybe you want unsafeInterleaveIO? Not sure... 
22:48:18 <ezyang> well, basically, if you want to do anything with the string, everything has to be put into IO now 
22:48:36 <Zeiris> Are there any Haskell GUI libraries that work on Windows without needing an entire Linux toolchain?
22:48:36 <int80_h> Well, when I get to a certain stage of development, I will re-assess that. For now I'm keeping it.\
22:49:03 <Saizan> int80_h: it's hard to help without knowing well what $hamlet is doing.
22:49:16 <ezyang> int80_h: What is the expanded type of Handler? 
22:49:27 <ezyang> Zeiris: GHC pulls in MingW, so not really... 
22:49:43 <m3ga> wow, debian testing is significantly better for haskell that ubuntu lucid. lucid has old versions of tagsoup and xml that don't handle ByteString
22:49:48 <int80_h> oooh , no worries. That's something special to Yesod. I will post the whole thing. I was trying to keep unnessecary code out. Brb with a better posting.
22:50:08 <Saizan> int80_h: wait, is Handler a MonadIO?
22:50:17 <ezyang> because if it contains IO and you can unsafely cast into that, there's an easy way to do this 
22:50:26 <ezyang> otherwise, you might be kind of sad. 
22:50:30 <int80_h> Yes, I believe it is a MonadIO
22:50:38 <int80_h> what's the easy way?
22:50:41 <ezyang> Ok, that's where you need to extract the string version of the JSON 
22:50:46 <ezyang> erm 
22:50:51 <ezyang> entryContent 
22:51:00 <Saizan> unsafely cast? that's never going to wrok.
22:51:03 <ezyang> and then stick into jsonMap 
22:51:14 <ezyang> Where by "Cast" I mean "Lift into MonadIO" 
22:51:20 <int80_h> I'm having a problem with syntax.
22:51:38 <ezyang> post what you have now 
22:51:45 <int80_h> yeah, that's what I need to do. The problem is what the syntax should look like.
22:51:45 <ezyang> or what you tried 
22:51:56 <ezyang> you've already got a do block in Handler 
22:52:04 <int80_h> what I tried is what I posted. Or rather what I need to accomplish. 
22:52:07 <ezyang> and lexically things look ok too 
22:52:11 <int80_h> ooh checking
22:52:13 <ezyang> right, that won't work 
22:52:25 <int80_h> see this line
22:52:31 <int80_h> entry:_ -> applyLayoutJson (entryName entry) mempty (html entry) (json entry)
22:52:35 <Saizan> int80_h: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28314#a28317 <- maybe like this?
22:52:50 <ezyang> yes, and json is defined in the where block... 
22:53:52 <ezyang> so you need to pull out most of that code 
22:53:53 <int80_h>  Saizan : that's it!
22:54:08 <int80_h> I think. anyway I want to try what Saizan suggested.
22:56:57 <int80_h> crap
22:57:15 <int80_h> that wasn't it
22:57:40 <int80_h> I thought I knew what to do, I had a similar problem with a simpler version of my blog
22:57:40 <Saizan> which error did you get?
22:57:57 <int80_h> I will paste it, it's more than 4 lines
22:58:30 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28314#a28318
22:58:50 <int80_h> when I got that error with a simpler blog, we used liftIO to solve the problem.
22:59:00 <int80_h> but now, the code is getting more complicated.
22:59:24 <Saizan> you forgot to edit the json function in your real code?
22:59:28 <int80_h> I'm pretty sure liftIO is what I need to use. If it isn't then I just don't understand what is happening here.
22:59:34 <Saizan> the error is referring to the old version.
22:59:47 <Saizan> i have ", ("content", jsonScalar $ string $ content)" there
22:59:53 <int80_h> ack!
22:59:56 <int80_h> duh
23:04:53 <Saizan> works?:)
23:05:11 <int80_h> saizan: that compiled!
23:05:17 <int80_h> I'm going to run it
23:06:07 <int80_h> ah, now I need to tweak the template, but it's basically working
23:06:12 <int80_h> thanks :)
23:06:16 <Saizan> np
23:08:59 <int80_h> yeah when this is the way I want it, I'll put it up for code review on the beginners mailing list. So whatever needs to be changed can happen then.
23:09:35 * hackagebot convertible-text 0.3.0.2 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.2 (MichaelSnoyman)
23:10:01 <int80_h> speak of the devil, he's the yesod creator.
23:14:21 <lispy> ?src scanr
23:14:22 <lambdabot> scanr _ q0 []     =  [q0]
23:14:22 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
23:14:22 <lambdabot>     where qs@(q:_) = scanr f q0 xs
23:23:45 <int80_h> crap, I'm not done yet. Hope you are going to be around for awhile Saizan
23:31:26 <p00ya>  \f x -> maybe Nothing (Just f x) x seems like a common pattern, am I missing some obvious name for it?
23:33:35 <Ke> >:t maybe
23:33:35 <lambdabot> Ke: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:33:48 <Ke> @type maybe
23:33:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:34:36 <Ke> I can't even parse that expression
23:35:03 <p00ya> f (Just x) -> Just (f x)
23:35:07 <p00ya> f Nothing -> Nothing
23:36:26 <Ke> perhaps the Maybe monad instance?
23:37:57 <Ke> > fmap (+1) Just 1
23:37:58 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
23:37:58 <lambdabot>    arising from a use of...
23:39:07 <p00ya> yeah >>= looks right
23:39:22 <Ke> > Just 1 >>= (\l -> return (l+1))
23:39:24 <lambdabot>   Just 2
23:39:26 <Ke> yup
23:39:27 <dibblego> > fmap (+1) $ Just 1
23:39:28 <lambdabot>   Just 2
23:39:52 <dibblego> fmap f x = x >>= (return . f)
23:40:42 <dibblego> @type \f -> maybe Nothing (Just . f) -- =<<
23:40:43 <lambdabot> forall a a1. (a1 -> a) -> Maybe a1 -> Maybe a
23:41:16 <p00ya> thanks
23:41:24 <johnw> how is return . f different from lift?
23:42:07 <dibblego> you mean liftM? that's the same as fmap
23:42:17 <dibblego> liftM f x = x >>= (return . f)
23:42:27 <johnw> then what is regular lift?
23:42:27 <dibblego> @src liftM
23:42:28 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:42:31 <johnw> @src lift
23:42:32 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:42:40 <dibblego> I don't know, which lift are you thinking?
23:42:57 <johnw> i'm not completely sure
23:43:01 <johnw> on http://en.wikibooks.org/wiki/Haskell/Monad_transformers I see this:
23:43:05 <dibblego> sometimes "lift" is used as a verb as in "to lift (+1) into the Maybe functor"
23:43:15 <johnw> lift mon = MaybeT (mon >>= return . Just)
23:43:24 <johnw> oh, it's not a general utility function?
23:43:27 <dibblego> ah yeah, that's a bit trickier
23:43:47 <dibblego> it's used for stacking monads i.e. monad transformers
23:43:53 <johnw> ok
23:44:10 <johnw> i've used return . f before, and wondering if I wasn't "lifting" the return value from f into the current monad
23:44:28 <dibblego> @type \f -> return . f
23:44:30 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
23:44:45 <johnw> that doesn't really help me :)
23:44:54 <dibblego> it's like a transformer
23:48:40 <Peaker> I'm trying to debug the heap use of: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28319#a28319  - for a Trie of 90,000 words, converting to a suffix-trie crashes with overuse of heap.. Can anyone try this code on a more powerful computer?
23:48:49 <Peaker> I wonder if the heap use is big, or an overflow
23:49:00 <Peaker> Also would love feedback about how to compact it
23:49:21 <Peaker> brb
23:51:43 <zachk2> @babel Y HACER CASO GRACIAS
23:51:44 <lambdabot> Plugin `babel' failed with: Error: Language Y not supported
23:51:52 <zachk2> @babel spanish Y HACER CASO GRACIAS 
23:51:53 <lambdabot> Plugin `babel' failed with: Error: Language Y not supported
23:51:59 * zachk2 sighs
23:54:32 <theorbtwo> @babel es en Y HACER CASO GRACIAS
23:54:32 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
23:54:40 <theorbtwo> ...or not.
23:54:57 <QtPlatypus> @help babel
23:54:58 <lambdabot> babel <lang1> <lang2> <phrase>.
23:54:58 <lambdabot> Translate a phrase in lang1 to lang2.
23:54:58 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
23:55:26 <lispy> ?babel en de hello
23:55:26 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
23:55:38 <QtPlatypus> I think its just broken
23:55:57 <Gracenotes> @bf +.
23:55:58 <lambdabot>  Done.
23:56:04 <Gracenotes> oh that's working again?
23:56:12 <zachk2> @help bf 
23:56:13 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
23:56:18 <zachk2> nice nice
23:56:48 <lispy> The full bf interpreter can do a lot more than what lambdabot lets you do with it
23:56:55 <lispy> lambdabot doesn't let you do any IO with it :(
23:56:58 <Gracenotes> @bf +++++[->++++++++<].
23:56:58 <lambdabot>  Done.
23:57:07 <Gracenotes> oh well that's sort of useless
23:57:32 <lispy> Yeah.  I wrote it to support I/O, but when it went into lambdabot dons disabled it :)
23:57:40 <lispy> For safety reasons, I guess
23:57:51 <Gracenotes> or er forget one last >
23:59:57 <noteed> What was the question?
