00:00:58 <dmwit> :t let foldb f = foldb' where chunk (x:y:zs) = f x y : chunk zs; chunk zs = zs; foldb' [x] = x; foldb' xs = foldb' (chunk xs) in \f -> (foldb f .) . (:)
00:00:59 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
00:05:12 <monadic_kid> "I think Haskell's type classes don't compare quite favorably with D's constrained templates. Haskell's facility is nicely principled but is rigid, verbose, and difficult to use, in addition of being quite underpowered: type classes constrain one type, whereas D's constrained templates naturally allow establishing constraints involving several types and also values.
00:05:12 <monadic_kid> Haskell does allow constraints on multiple types, but it's quite an advanced trick, as mentioned by a paper I just reviewed for WGP 2010
00:05:12 <monadic_kid>  
00:05:13 <monadic_kid> .
00:05:15 <monadic_kid> "
00:05:17 <monadic_kid> http://www.reddit.com/r/programming/comments/cmn67/c_concepts_a_postmortem/c0tpl2v
00:05:44 <monadic_kid> This person is clearly miss-understanding multiple type constraints with multi-parameter type-classes
00:06:15 <ski> dmwit : i would just drop the `a' argument .. (or use it only in the case the input list is empty)
00:06:40 <wli> Eh? How is that not multiple parameter type classes?
00:07:23 <arcatan> is (>=>) like (.) but for monads?
00:07:41 <ski> monadic_kid : a 386 case, then ?
00:07:42 <c_wraith> arcatan, exactly
00:07:51 <ski> arcatan : more like `flip (>>>)'
00:07:53 <ski> er
00:07:55 <ski> arcatan : more like `flip (.)'
00:07:59 <c_wraith> well, <=< is like .
00:08:03 <ski> which is like `(>>>)'
00:08:09 <ski> @type (>>>)
00:08:10 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
00:08:13 <ski> @type flip (.)
00:08:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
00:08:20 <ski> @type (Control.Arrow.>>>)
00:08:21 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
00:08:22 <monadic_kid> wli: it's incorrect to say that haskell can not have a polymorphic function with multiple type constraints, multi-parameter type-classes is a different problem
00:08:24 <ski> @type flip (Prelude..)
00:08:26 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
00:08:36 <ski> @type (>=>)
00:08:37 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:09:11 <arcatan> c_wraith, ski: okay, thanks.
00:09:14 <Amagineer> I've written a program that prints out text continuously, and when I try to pipe that text from stdout to a file (via > in my shell) the file is empty, what might be causing that?
00:09:49 <c_wraith> lack of flushing?
00:10:10 <Amagineer> I flush after every print
00:10:17 <Amagineer> http://xmonadneer.pastebin.com/7smiv7ye
00:11:37 <monadic_kid> wli: he's trying to compare D template constraints against type constraints in Haskell, he must have a looked at multi-parameter type-classes and misunderstood that haskell doesn't support multiple type constraints at all
00:14:31 <arcatan> I have both mtl and transformers installed. When I use Control.Monad.Trans, ghci complains about ambiguous module name. How to work around?
00:15:22 <c_wraith> arcatan, the best way is to build with cabal.  as a work around, you can use "ghc-pkg hide mtl" or "ghc-pkg hide transformers"
00:15:52 <arcatan> c_wraith: I do building with cabal and that works fine, but I'd like to interactively play with my modules.
00:16:20 <c_wraith> you can also use the -hide-package command-line arg to ghci, then
00:16:36 <c_wraith> or ":set -hide-package blah" in ghci
00:17:53 <arcatan> okay. thanks again.
00:21:27 <jmcdon> hi guys, I just installed 6.12.2 from source, but when I try to install the platform I get The core package base-4.2.0.0 is missing
00:21:42 <jmcdon> and it looks like Control.Monad isn't there
00:21:47 <c_wraith> platform only works with 6.12.1
00:22:22 <c_wraith> and you should avoid 6.12.2 anyway.  It was some rather severe bugs.  Use 6.12.1 or 6.12.3
00:22:30 <monadic_kid> http://www.reddit.com/r/programming/comments/cmn67/c_concepts_a_postmortem/c0tpl2v
00:22:54 <jmcdon> hmm okay
00:23:08 <jmcdon> I'm on OSX and I was getting weird issues with 6.12.1
00:23:14 <jmcdon> maybe .3 will be alright though
00:25:48 <jmcdon> is there a least painful way to uninstall?
00:27:09 <jmcdon> I guess if I install from source it'll just relink (unlike with pkgs)
00:59:36 <chrisdone> good morning
01:03:34 <Amagineer> I have a program (written in haskell) that continuously prints out text. When I try to pipe that text from stdout into a file (via >) the file is created, but is empty. What could be causing that? (Source here http://xmonadneer.pastebin.com/7smiv7ye)
01:04:23 <SubStack> hFlush stdout
01:04:39 <Amagineer> I do
01:05:53 <SubStack> Amagineer: perhaps the program is blocking on those getLines?
01:06:35 <Amagineer> The program works fine when I don't pipe it into a file
01:07:01 <SubStack> also mixing iorefs and threads is bad news
01:07:23 <Amagineer> So then what should I use?
01:07:29 <SubStack> mvars or stm
01:07:35 <Amagineer> Ah, alright
01:07:52 <Amagineer> Why is it that IORefs are not to be mixed with threads?
01:08:22 <SubStack> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-IORef.html#v%3AatomicModifyIORef 
01:09:55 <chrisdone> Amagineer: because it allows two threads to write an IORef simultaneously
01:10:14 <Amagineer> Ah, alright
01:11:01 <chrisdone> i'd suspect, anyway. check the docs for IORef. i call it says something like "theseare not thread-safe"
01:11:52 <chrisdone> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-IORef.html#v%3AatomicModifyIORef
01:14:20 <dsdeiz> heya, um, anyone familiar with this error? `unlift' is not a (visible) method of class `Network.OAuth.Http.HttpClient.HttpClient'
01:14:48 <dsdeiz> was an error from installing twidge (is this the right channel? :D)
01:15:25 <chrisdone> sounds like perhaps whatever twidge is, it could be expecting a different version of the library
01:15:50 <chrisdone> otherwise the alternate explanation is they forgot to import unlift, but not likely
01:16:02 <chrisdone> how are you installing it?
01:16:15 <dsdeiz> chrisdone: was using "cabal install"
01:16:58 <chrisdone> did it install anything like the package above; Network.OAuth....?
01:17:22 <dsdeiz> um, i've unregistered hoauth first then re-installed - how do i update btw? i did ghc-pkg unregister hoauth then did cabal install hoauth.. 
01:17:29 <dsdeiz> chrisdone: yep.. it install hoauth
01:17:32 <chrisdone> cabal update
01:17:35 <dsdeiz> installed*
01:17:41 <chrisdone> cabal install packagename
01:18:05 <chrisdone> cabal install packagename --reinstall to reinstall a package so that it uses new versions of packages just installed
01:20:13 <dsdeiz> oh men.. same error.. is there a way to install a package to a version before the latest one?
01:20:39 <chrisdone> sure. cabal install package==6.6.6
01:24:33 <dsdeiz> chrisdone: awesome! thanks mate!
01:24:53 <dsdeiz> uninstalling is just ghc-pkg unregister correct? :-? or is there a way using cabal? 
01:24:55 * edwardk is sad that april fools came and went without an 'adult' category being added to hackage yet again. ;)
01:25:13 <edwardk> (the 6.6.6 example made me think of that)
01:36:29 <Throwback> ALERT:  The cookie monster is NOT going to visit the gallery -  
01:37:26 <chrisdone> ... unless it's a cookie gallery!
01:37:32 <chrisdone> i forgot how useful notifyOSD is
01:37:50 <chrisdone> cabal install munch && notify-send "done compiling munch"
01:45:57 <chrisdone> hg update --clean
01:46:08 <chrisdone> ignore that
01:55:43 <arcatan> huh. i just cabal installed hdaemonize, then did cabal install salvia-extras and it reinstalled hdaemonize?
01:56:51 <chrisdone> arcatan: check the versionf of hdaemonize that are available/required by salvia-extras
01:58:16 <arcatan> it was the same version
01:58:20 <QinGW> @list
01:58:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:00:12 <CakeProphet> http://www.haskell.org/haskellwiki/Simple_STM_example
02:00:17 <Saizan> arcatan: it could have been to avoid the "diamond dependency problem"
02:00:30 <chrisdone> arcatan: how many versions do you have installed?
02:00:43 <Saizan> arcatan: "--dry-run -v" would have explained the reason
02:02:20 <chrisdone> i had this problem with parsec
02:02:34 <chrisdone> it would reinstall and i had parsec2 and parsec3 on the go
02:02:43 <chrisdone> just removed parsec2 and updated all my packages to be installed with parsec3
02:03:04 <arcatan> Saizan: hmm, maybe. i remember that command next time cabal does mysterious dependency things.
02:04:12 <CakeProphet> bah, dc'd
02:04:34 <CakeProphet> shared <- atomically $ newTVar 0
02:04:49 <CakeProphet> is this line in the STM example I linked the same as newTVarIO
02:05:05 <CakeProphet> newTVarIO 0, that is
02:07:26 <Saizan> arcatan: maybe cabal-install should have a mode where it presents what it's going to install and asks confirmation, like most package managers do
02:08:20 <Saizan> CakeProphet: they should be equivalent from the outside
02:08:22 <arcatan> yeah. anyway everything seems to work. it also gave this warning: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27142#a27142
02:08:51 <Saizan> oh, so you're mixing uses of Setup and of cabal install?
02:08:55 <FunctorSalad_> Saizan: there almost is
02:09:20 <arcatan> Saizan: no, that warning came up when cabal-installing salvia-extras
02:09:20 <Saizan> do you know that you can "cabal install" directly from a directory with a .cabal file?
02:09:25 <FunctorSalad_> cabal install --dry-run; echo press Ctrl-C to abort; read && cabal install
02:09:26 <FunctorSalad_> hehehe
02:09:38 <FunctorSalad_> (cheap&nasty yes/no question)
02:09:51 <Saizan> arcatan: ah, i see
02:10:00 <Saizan> arcatan: i'm surprised it worked out fine..
02:10:50 <FunctorSalad_> dry-run is especially useful if you're using paco or checkinstall and want to install the deps into their own pkges
02:10:52 <arcatan> but what causes that warning? the random versions are the same
02:10:59 <kmc> CakeProphet, GHC source says it's equivalent but much faster
02:11:02 <CakeProphet> arcatan:  salvia-extras? What on earth is that?
02:11:05 <FunctorSalad_> lol
02:11:07 <kmc> hehe
02:11:18 <Saizan> arcatan: the ABIs are probably different
02:11:27 <CakeProphet> arcatan:  if I install it will I trip balls?
02:11:33 <kmc> most likely
02:11:58 <arcatan> you should try!
02:12:18 <kmc> print out the code, roll it up and smoke it
02:12:20 <CakeProphet> haha. that's a hilarious name for a program. I love it.
02:12:21 <FunctorSalad_> nobody cares about the poor other salvia species which aren't active
02:12:34 <kmc> FunctorSalad_, people care plenty, they put them in gardens all the time
02:12:35 <CakeProphet> FunctorSalad_:  aren't they all mints?
02:12:49 <FunctorSalad_> hehe yes, I was thinking of mints too
02:12:52 <kmc> always funny when idiot stoners go to home depot and buy a "salvia" plant to smoke
02:13:46 <CakeProphet> ah well.. I guess since salvia is the mint family that is a much more reasonable name for a web server than I originally thought.
02:13:50 * Saizan grew up eating salvia
02:13:51 <arcatan> i didn't even know salvia was a psychedelic before learning about salvia the web framework
02:13:54 <kmc> hehe
02:13:55 <CakeProphet> I just automatically think of divinorum.
02:13:58 * FunctorSalad_ remembers the craze with poppy seeds... (which supposedly was actually true)
02:14:06 <FunctorSalad_> but probably cracked down by now
02:14:18 <FunctorSalad_> they actually still had some morphine sticking to them...
02:14:32 <FunctorSalad_> so people would buy a few packs and.... 
02:15:07 <CakeProphet> FunctorSalad_:  do you know about LSA/morning-glory-seeds?
02:15:31 <FunctorSalad_> (I mean the poppy seed packs sold in supermarkets btw)
02:15:38 * kmc wonders if he'd classify salvinorin as "psychedelic"
02:15:44 <FunctorSalad_> CakeProphet: heard yes, not more ;)
02:15:57 <CakeProphet> ha.
02:16:17 <FunctorSalad_> kmc: "maybe" in the widest sense, "not remotely related" if psychedelic:=5-ht2a agonist
02:16:18 <kmc> it's kind of not like anything else
02:16:19 <FunctorSalad_> ;)
02:16:20 <kmc> yeah
02:16:50 <kmc> i feel like "psychedelic" implies that you can learn something interesting or useful about your own mind from it
02:17:10 <CakeProphet> hmmm
02:17:12 <FunctorSalad_> 'soul uncovering' literally
02:17:21 <kmc> "mind-manifesting" is the translation i've seen
02:17:25 <kmc> but yes
02:18:26 <FunctorSalad_> ah. not sure which is more accurate... but I meant 'soul' in a religiously uncommited sense ;)
02:18:31 <CakeProphet> what an odd channel to be having a conversation about psychonautics.
02:18:39 <FunctorSalad_> (where it's equivalent to 'psyche')
02:18:45 <arcatan> yeah, usually we do it on -blah
02:19:10 <FunctorSalad_> that's what I meant by "sort-of"@shapr's comment on family friendlyness of haskell
02:19:16 <FunctorSalad_> *giggle*
02:19:47 <CakeProphet> arcatan:  talk about odd things or psychonautics specifically. :)
02:19:54 <FunctorSalad_> (don't look at me! I didn't start talking about drugs this time :o)
02:20:14 <CakeProphet> twas me I suppose.
02:20:39 <kmc> CakeProphet, at my school, there was significant overlap between the Haskell nerds and the drug nerds
02:20:51 <CakeProphet> that's "surprising"
02:21:09 <FunctorSalad_> in the sense of not surprising?
02:21:10 <edwardk> kmc: when you have a small population, expect there to be odd correlations ;)
02:21:11 <FunctorSalad_> ;)
02:21:16 <CakeProphet> FunctorSalad_:  ha. yes.
02:21:18 <kmc> true edwardk
02:21:21 <FunctorSalad_> he did specify drug nerds, even
02:21:48 <kmc> obviously there is some bias in the people i know ;)
02:21:50 <FunctorSalad_> Graham explains it via both being outcasts
02:22:28 <FunctorSalad_> thus sympathy with people considered "weird" for a different reason...
02:23:43 <FunctorSalad_> (this was about adolescents, where being a nerd is a lot more negative)
02:26:40 <kmc> the main connection i see is novelty-seeking
02:33:42 <roconnor> @type \f g a -> liftM g (f a)
02:33:43 <lambdabot> forall t a1 r (m :: * -> *). (Monad m) => (t -> m a1) -> (a1 -> r) -> t -> m r
02:33:55 <roconnor> @type \f g a -> join (liftM g (f a))
02:33:56 <lambdabot> forall t a1 (m :: * -> *) a. (Monad m) => (t -> m a1) -> (a1 -> m a) -> t -> m a
02:34:30 <yottis> hmm, is there a good ordered data structure available that supports finding the previous/next element from given key
02:34:39 <yottis> (the key doesn't need to be in the strucure)
02:39:15 <dolio> You could do it with a tree, I think.
02:40:54 <kmc> yeah, a binary search tree
02:41:37 <kmc> > head . S.toList . snd . S.split 'j' . S.fromList $ "hello world"
02:41:38 <lambdabot>   'l'
02:42:51 <yottis> yeah, but i was thinking if there already is a package for that
02:43:01 <kmc> not to my knowledge
02:43:14 <kmc> arguably it should be in Data.Set, or some "set extras" package
02:43:17 <kmc> but it's a one-liner
02:43:39 <kniu> if I made some modifications to another dude's package,
02:44:00 <kniu> how do I get those changes "registered" on hackage?
02:44:36 <Botje> mail the maintainer first
02:44:51 <kniu> oh yeah, that.
02:45:03 <Botje> if other people can use your code they'll be happy to include your changs
02:45:05 <kniu> why did I ask something this obvious?
02:48:12 <CakeProphet> so what are all the conditions in which an STM aborts?
02:48:16 <CakeProphet> and how do they compose?
02:53:01 <kmc> well if you execute "retry" for one
02:53:24 <kmc> or if you read/write TVars etc in a way which conflicts with other threads
02:53:29 <kmc> i don't know exactly what those conditions are
02:53:36 <CakeProphet> hmmm
02:53:54 <CakeProphet> so I guess if the state of a TVar that is being accessed changes mid-transaction?
02:54:09 <kmc> yeah
02:54:38 <CakeProphet> ah okay.
02:54:40 <kmc> you get to the end of the transaction, and if anyone else has written the TVars you read since you started, you start over
02:54:49 <CakeProphet> I keep confusing the notion of abort with the notion of logic failure.
02:54:50 <kmc> something like that, but i bet the reality is more complicated
03:00:10 <kmc> hmm, what do you mean by logic failure?
03:02:50 <CakeProphet> kmc:  well, I'm writing a roleplay-oriented MUD, so one of the features of the MUD is that characters have "score sheets" that basically have sets of stats. You use a dice roller along with these stats to make dice rolls.
03:03:00 <CakeProphet> or movement from room to room.
03:03:22 <CakeProphet> would be a feature that STM actions would be useful
03:03:54 <CakeProphet> so I was wondering why I would want retry semantics in the event that state wasn't correct for the transaction. But I was simply confused at the purpose of retry
03:04:12 <CakeProphet> a transaction can be "successful" but still return a condition in which the intended logic shouldn't occur.
03:04:33 <CakeProphet> like moving from one room to another, or retrieving a stat that no longer exists
03:06:06 <CakeProphet> kmc:  it's kind of late... so I might not be making sense.
03:06:19 <CakeProphet> well. early actually. 6:05 AM
03:06:45 <kmc> CakeProphet, sure.  you can have an STM action "canMoveToRoom :: Room -> STM Bool"
03:06:59 <kmc> which could succeed with a false result
03:07:12 <CakeProphet> right
03:07:12 <kmc> what you say does make sense :)
03:07:46 <kmc> i think basically any failure which is to be propagated to the user would not be an STM retry
03:07:55 <kmc> unless the user really means "block my session until i can do that"
03:08:04 <CakeProphet> right. I was making that fallacy a few hours ago when reading through STM
03:08:14 <kmc> *nod*
03:08:17 <kmc> are you reading RWH?
03:08:31 <CakeProphet> no.
03:08:42 <CakeProphet> was reading Beautiful Concurrency at the time.
03:11:46 <blackdog> possibly off-topic, but you guys are generally on the ball - preferred OS for a netbook?
03:11:59 <blackdog> the supplied Windows XP is clearly unacceptabl
03:12:14 <CakeProphet> I'd probably run xubuntu or something similar. a lightweight linux distro
03:12:25 <kmc> i use what i use elsewhere
03:12:27 <aristid> blackdog: ask such things in #haskell-blah :)
03:12:45 <CakeProphet> aristid: how formal of you. :P
03:12:47 <kmc> CakeProphet, RWH has a good STM chapter
03:13:15 <kmc> personally i don't mind OT here when traffic is otherwise light
03:13:18 <kmc> except for certain topics
03:13:31 <blackdog> if it drags it back on-topic, xmonad is a given :{
03:13:48 <kmc> anyway i think most linux distros can be coerced into a fairly lightweight setup
03:13:57 <kmc> so just pick whatever you like / are familiar with / been meaning to try
03:13:57 <aristid> kmc: dunno i think "preferred OS" is a bit boring as a question
03:14:01 <kmc> aristid, ok
03:14:37 <kmc> Ubuntu Netbook Remix has a somewhat special window manager, which you may or may not like
03:14:48 <kmc> if you're comfortable with xmonad or another tiling WM, that's probably better
03:15:55 <blackdog> cheers. might look at the netbook remix.
03:16:43 <kmc> a friend of mine had a hackintosh netbook
03:16:51 <kmc> he liked it, i'm not sure why
03:18:16 <blackdog> I was thinking of that, but I run Mac on everything else - I kinda need a linux machine around for Hubris testing
03:18:35 <blackdog> and constantly rebuilding GHC is painful enough on the MPB
03:18:36 <blackdog> MBP
03:18:57 <aristid> blackdog: i recommend getting a real linux machine additionally
03:19:16 <kmc> virtualization?
03:19:24 <aristid> kmc: on a netbook?
03:20:14 <blackdog> aristid: not really needed - I've got a pretty hefty mac desktop, and it runs linux in a vm reasonably well
03:20:33 <aristid> blackdog: can you ssh inside that VM?
03:20:38 <blackdog> of course
03:20:45 <aristid> hmm then it might be tolerable :D
03:21:03 <blackdog> ... how would you set up a VM such that ssh isn't possible? :) you'd have to deliberately lock it down...
03:21:20 <kmc> they don't necessarily have network access out of the box
03:21:44 <aristid> well or they might do all kinds of insane things with the network setup
03:22:01 <aristid> i know i've had my share of network problems with vms
03:22:16 <aristid> maybe i'm just too stupid to configure them
03:30:53 <blackdog> guess i was lucky, both virtualbox and vmware worked out of the box
03:37:52 <PetRat> Have question about monads and monad transformers.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27146#a27147
03:44:18 <kmc> what's your question?
03:47:08 <kmc> PetRat, you probably want to change everything to use StateT PlayState IO
03:47:26 <kmc> (StateT PlayState IO a) is an action in a monad which can do both state updates and IO
03:47:48 <kmc> (IO (State PlayState ())) is an action which can only do IO, and which returns an action which can only do state updates
03:51:14 <ski> well
03:51:57 <ski> why do you want to query in the middle of this operation ?
03:53:19 <PetRat> sorry everyone, I'm back.
03:53:44 <PetRat> kmc: I think you are right
03:53:58 <ski> (and if there's sizable chunks of your program that needs the `State PlayState' bit, and which doesn't need `IO', i would rather use a `Monad m => State s a -> StateT s m a' conversion that changing everything in that sizable chunk to use `StateT PlayState IO a' .. of course, it depends on how likely you think it is that that part of the program may later need to do `IO' or not)
03:54:30 <kmc> PetRat, you may also want to use IORef ("real" mutable variables in IO) rather than StateT (sugar for pure functional state passing)
03:54:40 <PetRat> Let me describe the issue: I'm writing software that plays midi files, but doesn't just play them once---it will let me enter commands to select sections to play or perform transformations.
03:55:14 <PetRat> so the whole thing has to be in the IO monad in order to play midi files
03:55:42 <PetRat> but also, there is a lot of state associated with playback... each time it loops it might modify or update the state, so State or StateT seems appropriate
03:57:46 <ski> i assume you want to be able to pause or stop/restart at any time ?
03:57:50 <PetRat> ski: by using `Monad m => State s a -> StateT s m a' ... um well yes a lot of my code will be doing computation and not IO
03:58:06 <PetRat> ski: for simplicity I just wait for it finish a section
03:58:22 <ski> ok
03:58:26 <PetRat> Pause/stop goes beyond my current understanding of PorMidi
03:58:57 <PetRat> so it plays a section, I wait for it to finish, then it takes a command for the next section
04:00:12 <PetRat> ski: regarding your suggestion about conversion, is there an existing function with that signature? I don't quite understand it
04:01:10 * ski thinks there ought to be a `class (MonadTrans t,Monad m) => MonadTransformerable m t where toTrans :: Monad n => m a -> t n a; fromTrans :: t Identity a -> m a' in libs, somewhere ..
04:03:17 <ski> (with `instance MonadTransformerable (State s) (StateT s) where toTrans (State s_as) = StateT (\s -> return (s_as s)); fromTrans (StateT s_mas) = State (\s -> runIdentity (s_mas s))', &c.)
04:05:28 <ski> PetRat : the point is that with something like that, if you have `deltaCursor :: Int -> State PlayState ()', and you want to call this from `IO' (where you've queried the user for a `delta', say), *without* having to change `deltaCursor' to use `StateT PlayState IO' instead of `State PlayState', then you just call `toTrans (deltaCursor delta)' instead of `deltaCursor delta' from your `StateT PlayState IO' code
04:15:04 <PetRat> ski: okay, yes that makes sense. I guess I should challenge myself to write toTrans
04:16:19 <msieradzki> is haskelldb actively maintained?
04:17:25 <PetRat> I just realized I really want the Reader monad because I only have one variable that needs update, which I could put in an IORef I suppose
04:37:56 * ski annotated "." by . with "`deltaCursorQuery',some more" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27146#a27152>
04:38:01 <ski> PetRat : ^
04:38:06 <quicksilver> ski: hoist, I think I've seen it called
04:38:15 <ski> @hoogle hoist
04:38:15 <lambdabot> No results found
04:38:18 <quicksilver> ski: (the combinator to run a State action in StateT foo)
04:38:38 <ski> it should work from `Reader rho' to `ReaderT rho m',&c. as well
04:38:45 <quicksilver> right
04:39:35 <quicksilver> ski: http://www.mail-archive.com/haskell-cafe@haskell.org/msg39100.html
04:39:57 <quicksilver> I'm glad to see that my mental index of 2 year old -cafe messages is as good as ever.
04:40:03 <quicksilver> If only I could remember useful stuff instead.
04:40:40 <ski> PetRat : well, if you're going to do sizable chunks of you program needing to modify `PlayState', but not doing any `IO', you could just as well use `State PlayState' (or `ReaderT (STRef s PlayState) (ST s)' i suppose)
04:41:50 <ski> (whether `State PlayState' would be preferable to `ReaderT (STRef s PlayState) (ST s)' or vice versa is not as clear cut, i think)
04:41:58 <quicksilver> ski: and of course there is a bijection between State s a and forall m . (MonadState s m) => m a
04:42:01 <ski> quicksilver : ty
04:42:18 <quicksilver> ski: and MonadState kind of avoids the hoist problem by encouraging you to use that version instead.
04:42:50 <ski> quicksilver : hm, i wonder whether one could do conversions to and from that in the class ..
04:42:55 <augur> ski: pm :|
04:43:35 <quicksilver> ski: and there is the further bijection to the simple (s -> (s,a))
04:43:47 <quicksilver> ski: ...which you sometimes want when you have a Lens with an 's' in it lying around.
04:43:54 <ski> quicksilver : well, as long as you don't mind doing lots of code like `Monad m => ... -> StateT Foo m Bar' or `MonadState Foo m => ... -> m Bar'
04:43:56 <quicksilver> to use modifyLens or something.
04:44:13 <ski> @type runState
04:44:15 <lambdabot> forall s a. State s a -> s -> (a, s)
04:44:36 <ski> (well, add a `swap' -- for some reason they did the wrong way in both `State' and `Writer')
04:44:38 <quicksilver> MonadState is a bit more composable in the sense that you can have (MonadState s m, MonadReader r m) if you need both.
04:44:53 <ski> yes, i know
04:45:10 <quicksilver> I know you know :)
04:45:16 <ski> i'd just like better support for mixing different transformer towers
04:45:18 <augur> http://okmij.org/ftp/gengo/NASSLLI10/ << oh man i almost went to nasslli :(
04:45:34 <ski> adding and removing monads both at the bottom and in the middle
04:45:40 <augur> im so jealous that i didnt go. shan is pretty neat
04:46:14 <ski> quicksilver : re lenses, i think it could be useful to go the other way around, i.e. make the lenses meet the state monad
04:47:57 <HugoDaniel> *** Exception: Prelude.(!!): index too large
04:48:17 <ski> hunt down and kill all uses of `(!!)'
04:48:18 <Deewiant> > "abc" !! 3
04:48:19 <lambdabot>   *Exception: Prelude.(!!): index too large
04:51:19 <aristid> > zipWith (!!) "abc" [3,2,1]
04:51:20 <lambdabot>   Couldn't match expected type `[a]'
04:51:20 <lambdabot>         against inferred type `GHC.Types...
04:51:48 <aristid> oh, stupid me
04:52:22 <Deewiant> > map ("abc"!!) [2,1,0]
04:52:23 <lambdabot>   "cba"
04:53:35 <Jafet> reverse xs = map (xs!!) [length xs-1, length xs-2 .. 0]
04:54:02 <kmc> haha
04:54:13 <aristid> Jafet: surely wins the award for least efficient reverse :)
04:54:21 <kmc> O(nÂ²)
04:54:26 <kmc> i think we can do better... err, worse
04:55:25 <wli> reverse = rev' [] where rev' xs (y:ys) = rev' (y:xs) ys ; rev' xs [] = xs ?
04:55:56 <aristid> wli: that doesn't look like it has major inefficiency, so you lose
04:56:06 <HugoDaniel> i usually do a dirty hack instead of !!
04:56:15 <HugoDaniel> something like: let func n lst = last $ take (n + 1) lst
04:56:23 <wli> Trying for inefficiency? Ugh.
04:56:26 <aristid> HugoDaniel: why?
04:56:47 <HugoDaniel> because i hate exceptions :P
04:56:49 <LakatosI> Can a noob ask a question here? :P
04:56:50 <aristid> HugoDaniel: oh, i see, because it succeeds for all non-empty lists?
04:56:51 <kmc> > last []
04:56:52 <lambdabot>   *Exception: Prelude.last: empty list
04:56:56 <kmc> HugoDaniel, ^^^^
04:56:57 <aristid> LakatosI: no wai
04:57:05 <kmc> LakatosI, of course :)
04:57:09 <LakatosI> ok then :P
04:57:31 <HugoDaniel> ok, then: let func n lst = take 1 $ reverse $ take (n + 1) lst
04:57:34 <LakatosI> I started learning haskell yesterday using a couple of tutorials on the Internet
04:57:44 <HugoDaniel> exceptions are the root of all evil
04:57:56 <HugoDaniel> i find it extremely awkward that haskell has them :(
04:58:16 <Deewiant> > let reverse xs = map (head . flip drop xs . pred) . ap enumFromThenTo pred (length xs) $ 1 in reverse "12345"
04:58:17 <kmc> HugoDaniel, yeah, we should use only total languages like Agda
04:58:17 <lambdabot>   "54321"
04:58:27 <kmc> LakatosI, cool :)
04:58:29 <LakatosI> However, what I found didn't explain things very clearly, like syntax, how to write scripts, etc
04:58:30 <msieradzki> another library question: why does haskelldb not support stored functions (procedures in pgsql)
04:58:35 <kmc> LakatosI, which ones?  we mostly recommend LYAH and RWH
04:58:36 <kmc> @where LYAH
04:58:36 <lambdabot> http://www.learnyouahaskell.com/
04:58:38 <kmc> @where RWH
04:58:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:58:45 <HugoDaniel> kmc: no, but we should learn how to exploit monads and functors instead of relying in exceptions for anything usefull
04:58:45 <aristid> HugoDaniel: try Agda
04:58:59 <kmc> LakatosI, at the beginning you won't be writing code into a file, you'll be poking around interactively in ghci
04:59:18 <LakatosI> yeah, I noticed :P
04:59:26 <kmc> once you do want to write a file, use any text editor you like, name it something.hs, and load it into ghci with "ghci something.hs", or compile to a binary with "ghc --make something.hs"
04:59:35 <kmc> in the latter case you need a value named "main" of type "IO ()" (roughly)
04:59:40 <HugoDaniel> aristid: im in the good programming languages bizness :)
04:59:41 <kmc> which is the top-level IO action
04:59:52 <aristid> HugoDaniel: how about this? (map Just x ++ repeat Nothing) !! n
05:00:01 <kmc> LakatosI, do you have specific questions about syntax, or just looking for a general reference?
05:00:04 <LakatosI> It's just that I want to try out the things I have learnt, and I find writing scripts to do small stupid things to be helpfull
05:00:05 <LakatosI>  :P
05:00:10 <kmc> ok
05:00:34 <LakatosI> I was going to ask for a couple of tutorials, but you already answered my question :P
05:00:38 <kmc> are you using a syntax-highlighting editor?
05:00:45 <LakatosI> Yeah, about that
05:00:45 <aristid> HugoDaniel: that code is exception-free too :)
05:00:54 <LakatosI> I was thinking of using vim
05:00:54 <kmc> emacs's haskell-mode does highlighting, plus can cycle through possible indentation points by hitting "tab" repeatedly
05:00:58 <kmc> (though, very rarely, it's wrong)
05:01:16 <kmc> vim is fine too; i use it but i don't have it tricked out fancy-like for haskell; others may have more useful information
05:01:19 <aristid> > let (!!!) x n = (map Just x ++ repeat Nothing) !! n in "abc" !!! 3
05:01:20 <lambdabot>   Nothing
05:01:23 <aristid> > let (!!!) x n = (map Just x ++ repeat Nothing) !! n in "abc" !!! 2
05:01:23 <LakatosI> I installed this thing called haskellmode for it, but it keeps giving me an error whenever I open a haskell file
05:01:24 <lambdabot>   Just 'c'
05:01:49 <yottis> is there yet an option to ghc that would give a warning for any partial function?
05:01:57 <yottis> iirc that's been requested for long
05:01:59 <Deewiant> > let (!!!) x n = (map Just x ++ repeat Nothing) !! n in "abc" !!! (-1)
05:02:00 <lambdabot>   *Exception: Prelude.(!!): negative index
05:02:01 <yottis> it'd be really useful
05:02:11 <kmc> yottis, also mathematically impossible
05:02:13 <yottis> (mainly for your own code9
05:02:13 <kmc> ;P
05:02:20 <LakatosI> By the way, how do I activate haskell mode in emacs?
05:02:35 <kmc> LakatosI, if properly installed it should pick up any file ending in .hs
05:02:35 <benmachine> kmc: not necessarily, you'd just have to have either false positives or false negatives
05:02:39 <yottis> kmc: what do you mean?
05:02:39 <kmc> or you can do M-x haskell-mode
05:02:47 <p_l> HugoDaniel: I wonder how you react to systems that have OS-spanning exception handling :D
05:02:57 <Saizan> yottis: there's a flag to turn on warnings about incomplete patterns
05:03:03 <kmc> benmachine, right.  requiring it for "any partial function" means you can't have false negatives
05:03:05 <LakatosI> I'll try that
05:03:06 <kmc> yottis, are you using ghc -Wall?
05:03:11 <aristid> Deewiant: ok, we need to do this another way!
05:03:19 <yottis> i meant if i have a "f :: Bool -> Something", and only define f True = ... but not f False = ..., then that would cause a warning
05:03:22 <wli> Saizan: Do you mean inexhaustive pattern matches?
05:03:31 <LakatosI> and what should I start learning firstz? LYAGH, or RWH?
05:03:33 <p_l> HugoDaniel: (like VMS or Windows NT)
05:03:35 <Saizan> wli: yeah
05:03:40 <kmc> LakatosI, depends on taste.  skim them both maybe
05:03:43 <HugoDaniel> :D please stop beating the poor blind man, im open of discussion
05:03:43 <wli> It's inexhaustive not incomplete.
05:03:44 <yottis> kmc, yeah, is that included? iirc i have 8.10 installed, but haven't used that a lot
05:03:49 <HugoDaniel> s/of/for
05:04:02 <aristid> > let (!!!) :: [a] -> Word -> a; (!!!) x n = (map Just x ++ repeat Nothing) !! n in "abc" !!! (-1)
05:04:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:04:03 <lambdabot>         against inferred type ...
05:04:24 <HugoDaniel> aristid:  :D
05:04:27 <kmc> yottis, yes.  you can warn on some obvious cases, not on all cases
05:04:33 <kmc> it is included in GHC 6.12 and i think earlier
05:04:45 <kmc>     Warning: Pattern match(es) are non-exhaustive;              In the definition of `f': Patterns not matched: False
05:05:00 <LakatosI> ok, thanks for the help :) I'll guess I'll be around here a lot. From what I noticed haskell is awesome!
05:05:10 <yottis> ok, cool
05:05:17 <benmachine> there are some patterns that are really too thorny to be properly warned about
05:05:27 <benmachine> e.g. view patterns, nasty guards, etc
05:05:28 <kmc> yottis, ndm had some tool to go above and beyond this checking
05:05:36 <kmc> i forgot its name
05:05:47 <Saizan> catch
05:05:48 <Deewiant> aristid: You could just add an if n < 0 :-)
05:05:49 <benmachine> sometimes I use a ~ on the last pattern to tell ghc to stop whining >_>
05:06:08 <aristid> Deewiant: yes i was hoping to utilize the type system for maximum joy
05:06:10 <FunctorSalad_> last time I checked view patterns throws warnings without making much of an attempt at deduction
05:06:11 <kmc> benmachine, :(
05:06:25 <benmachine> > fromIntegral (maxBound :: Word) :: Int
05:06:26 <FunctorSalad_> very likely undecidable in general
05:06:26 <lambdabot>   -1
05:06:28 <Deewiant> aristid: No joy available, I think; !! takes Int
05:06:37 <benmachine> kmc: don't judge me :(
05:06:38 <aristid> Deewiant: well that can be fixed
05:07:05 <aristid> > let (!!!) :: [a] -> Word -> a; (!!!) x n = (map Just x ++ repeat Nothing) !! fromIntegral n in "abc" !!! (-1)
05:07:06 <lambdabot>   Occurs check: cannot construct the infinite type:
05:07:06 <lambdabot>    a = Data.Maybe.Maybe a
05:07:20 <aristid> > let (!!!) :: [a] -> Word -> Maybe a; (!!!) x n = (map Just x ++ repeat Nothing) !! fromIntegral n in "abc" !!! (-1)
05:07:21 <lambdabot>   *Exception: Prelude.(!!): negative index
05:07:35 <FunctorSalad_> f ( weird -> True ) = 0 -- end of definition
05:07:38 <aristid> aaah, lol
05:07:40 <HugoDaniel> take 1 $ reverse $ take (n + 1) lst
05:07:42 <Deewiant> aristid: See? :-)
05:07:42 <HugoDaniel> :P
05:07:47 <FunctorSalad_> is exhaustive if and only if f returns True for every input ;)
05:07:51 <FunctorSalad_> am I missing sth?
05:07:53 <HugoDaniel> it would be nice of ghc if it could optimize that
05:07:54 <benmachine> use Word8!
05:08:01 <aristid> Deewiant: 't is the evil conversion from Word to Int that breaks everything
05:08:02 <FunctorSalad_> (to prove undecidability)
05:08:05 <Deewiant> aristid: Yep
05:08:13 <FunctorSalad_> *if weird returns True
05:08:55 <aristid> > let (!!!) :: [a] -> Word -> Maybe a; (!!!) x n = (map Just x ++ repeat Nothing) `genericIndex` n in "abc" !!! (-1)
05:08:58 <benmachine> FunctorSalad_: arguably you might want GHC to tell you to put a pattern in there for the case that you change the behaviour of weird
05:08:59 <lambdabot>   mueval-core: Time limit exceeded
05:09:03 <benmachine> or it goes wrong somehow
05:09:06 <benmachine> or <other>
05:09:16 <benmachine> in which case that'd still be considered inexhaustive
05:09:23 <aristid> HugoDaniel: note that while it may take a few hours to compute, this is not an exception
05:09:27 <Deewiant> :-D
05:09:29 <aristid> HugoDaniel: or bottom in any way
05:10:16 <FunctorSalad_> benmachine: hmm maybe... and it does seem decidable to just check that the pattern part of the view pattern is exhaustive....
05:10:53 <FunctorSalad_> (which would be sufficient, though as above not necessary for exhaustiveness)
05:11:08 <FunctorSalad_> but better than no smartness on ghc's side at all
05:11:17 <Deewiant> > let (!!!) :: [a] -> Word -> Maybe a; (!!!) x n = case genericDrop n x of [] -> Nothing; a:_ -> Just a in "abc" !!! (-1)
05:11:18 <lambdabot>   Nothing
05:11:24 <benmachine> ghc still has a tricky time with things like guards though
05:11:52 <benmachine> I think you end up heuristicking if you want to make a decent job of it
05:12:38 <benmachine> Deewiant: I don't think you even need it to be a Word there anymore
05:12:42 <benmachine> > drop (-1) "abc"
05:12:43 <lambdabot>   "abc"
05:12:46 <benmachine> oh
05:12:52 <benmachine> yeah, I guess you do sorta
05:12:52 <Deewiant> I do :-)
05:12:55 <benmachine> well
05:12:57 <benmachine> ish
05:13:03 <benmachine> you're relying on overflow doing something silly :P
05:13:08 <cathper> I have this code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27156#a27156 that seems to eat quite some computation time.
05:13:14 <kmc> there was a paper about a thing which found partial functions by feeding in successively more-defined values
05:13:19 <benmachine> if you gave it like -4billion then it might give you 'c'
05:13:24 <kmc> i forgot the name :/
05:13:34 <kmc> i really ought to organize the papers i read
05:13:52 <cathper> I do not always use `cartesian' where all "size" are the same, but often I do.
05:14:25 <cathper> I guess I can buy some computation time for that flexibility, but I don't know how to do it.
05:15:55 <Deewiant> benmachine: Well, that's more an issue of "-1" being a valid Word literal
05:16:58 <benmachine> Deewiant: mm, you can't really win except by explicitly checking for < 0
05:17:29 <Deewiant> benmachine: I think this is sort of a win in that the type disallows negatives
05:17:55 <benmachine> except it doesn't, it just messes them up :P
05:18:10 <benmachine> also, how are you going to give me the seven trillionth element of my list, huh??
05:18:25 <benmachine> we need a proper Natural type, perhaps
05:18:36 <Deewiant> It does, it's just that literals are Num a and there's no PositiveNum a
05:18:55 <Deewiant> If you do fromIntegral (x :: Int) :: Word it's your fault :-P
05:19:38 <benmachine> > let xs !? n = guard (n >= 0) *> listToMaybe (drop (n - 1) xs) in "abc" !? (-1)
05:19:39 <lambdabot>   Nothing
05:19:42 <benmachine> > let xs !? n = guard (n >= 0) *> listToMaybe (drop (n - 1) xs) in "abc" !? 2
05:19:44 <lambdabot>   Just 'b'
05:19:47 <benmachine> oh whoops
05:19:52 <benmachine> > let xs !? n = guard (n >= 0) *> listToMaybe (drop n xs) in "abc" !? 2
05:19:54 <lambdabot>   Just 'c'
05:19:58 <benmachine> sorte
05:19:59 <benmachine> d
05:20:20 <Deewiant> Ah, I forgot about listToMaybe
05:20:33 <benmachine> you can also do
05:20:41 <Deewiant> But yeah, of course it works with a check
05:20:53 <benmachine> > let xs !? n = guard (n >= 0) *> foldr (const . Just) Nothing (drop n xs) in "abc" !? 2
05:20:54 <lambdabot>   Just 'c'
05:21:33 <benmachine> hmm
05:21:36 <Deewiant> Heh, that's cute
05:22:41 <zygoloid> > let xs !? n = guard (n >= 0) >> listToMaybe (drop n xs) in "abc" !? 2
05:22:42 <lambdabot>   Just 'c'
05:22:47 <zygoloid> oh, we've had that :(
05:22:51 <benmachine> > let xs !? n = guard (n >= 0) *> msum (zipWith id (replicate n (const Nothing) ++ repeat Just) xs) in "abc" !? 2
05:22:57 <lambdabot>   Just 'c'
05:23:04 <benmachine> that was rather slow
05:23:14 * benmachine wonders if it's just a glitch in the internets
05:23:21 <benmachine> > let xs !? n = guard (n >= 0) *> msum (zipWith id (replicate n (const Nothing) ++ repeat Just) xs) in "abc" !? 3
05:23:23 <lambdabot>   Nothing
05:24:08 <benmachine> yeah, my ghci is pretty snappy
05:24:19 * hackagebot constructive-algebra 0.1.4 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.1.4 (AndersMortberg)
05:25:04 <benmachine> > let xs !? n = msum $ guard (n >= 0) : zipWith id (replicate n (const Nothing) ++ repeat Just) xs in "abc" !? 3
05:25:05 <lambdabot>   Couldn't match expected type `()'
05:25:05 <lambdabot>         against inferred type `GHC.Types....
05:25:07 <benmachine> aw
05:25:18 <benmachine> > let xs !? n = msum $ undefined <$ guard (n >= 0) : zipWith id (replicate n (const Nothing) ++ repeat Just) xs in "abc" !? 3
05:25:19 <lambdabot>   Couldn't match expected type `()'
05:25:19 <lambdabot>         against inferred type `GHC.Types....
05:25:23 <benmachine> fff
05:26:08 <benmachine> no that doesn't work anyway
05:26:17 <Deewiant> ?ty (undefined <$)
05:26:18 <lambdabot> forall a (f :: * -> *) b. (Functor f) => f b -> f a
05:26:51 <benmachine> it went wrong there because <$ has lower precedence than :, but it would have broken if I'd parenned it
05:27:02 <benmachine> because msum does the opposite of what I want
05:31:17 <Phyx-> > ide
05:31:18 <lambdabot>   Not in scope: `ide'
05:31:50 <ClaudiusMaximus> aaarrgh :(    realToFrac :: Double -> GLdouble    is eating 33% of time/allocs
05:32:32 <benmachine> ClaudiusMaximus: oh dear
05:32:53 <benmachine> is this some old-GL application that was converted to new-GL by just realToFraccing everywhere
05:33:04 <Deewiant> {-# RULES "realToFrac/Double->GLdouble" realToFrac = unsafeCoerce #-}
05:33:33 <ClaudiusMaximus> benmachine: no, this is something i wrote this week, but didn't want to use GLdouble everywhere in the non-GL parts
05:33:37 <benmachine> Deewiant: the library should have that, it's technically quite dangerous in client code
05:33:43 <benmachine> ClaudiusMaximus: oh right, hmm
05:33:54 <ClaudiusMaximus> i'm going to try that, Deewiant 
05:33:58 <Deewiant> benmachine: How is it dangerous? (But yes, the library should have it)
05:33:58 <benmachine> it'd be really nice if the GL bindings provided some cheap conversions
05:34:13 <Deewiant> Okay, I suppose we can't assume that Double is CDouble
05:34:14 <benmachine> Deewiant: the whole point of GLdouble's existence is that it's not guaranteed to be Double
05:34:26 * hackagebot feldspar-language 0.3.1 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.3.1 (EmilAxelsson)
05:34:27 <ClaudiusMaximus> where do i put rules pragmas?  just at top level module scope?
05:34:27 <Deewiant> I always thought it had no point
05:34:28 * hackagebot feldspar-compiler 0.3.1 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.3.1 (EmilAxelsson)
05:34:32 <benmachine> heh
05:34:43 <benmachine> it's required by the GL spec I think
05:34:47 * benmachine vague recollection
05:34:48 <Deewiant> Precisely because everything in C I've seen assumes double == GLdouble
05:34:48 <msieradzki> benmachine, then what is it :>
05:35:01 <benmachine> msieradzki: who knows?? maybe a long double?
05:35:16 <benmachine> Deewiant: yes but everything in C assumes sizeof(void *) == 4
05:35:21 <benmachine> doesn't mean that's *right* :P
05:35:22 <Deewiant> No, not everything
05:35:26 <msieradzki> not everything
05:35:32 <Zao> benmachine: Everything written by dimwits on x86 does.
05:35:35 <Deewiant> Everything does assume double == GLdouble, though ;-)
05:35:43 <benmachine> Zao: dimwits frequently write C >_>
05:35:57 <msieradzki> it's just counterintuitive to have GLDouble that might not be trivially convertible to Double
05:36:00 <msieradzki> if name says DOUBLE
05:36:39 <benmachine> msieradzki: the types do the same job, but that doesn't necessarily mean they have the same representation
05:36:56 <Deewiant> But of course, there's no OpenGL implementation where they don't
05:37:14 <aristid> @src (*>)
05:37:15 <lambdabot> (*>) = liftA2 (const id)
05:37:50 <Deewiant> A "more right" thing to do would be to go via CDouble, since the compiler presumably has rules for that, and then uncoerce that into GLdouble
05:37:53 <aristid> :t (*>)
05:37:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
05:37:56 <aristid> :t (>>)
05:37:57 <zygoloid> msieradzki: is it counterintuitive that Double might not trivially be convertible to CDouble?
05:37:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
05:37:58 <Deewiant> Er, unsafecoerce*
05:38:10 <msieradzki> I should add: for a newbie
05:38:14 <msieradzki> newcomer or whatever
05:38:27 <msieradzki> intuition isn't always right :)
05:39:22 <ClaudiusMaximus> ok, i what does this mean?  orphan rule?? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27158#a27158
05:40:09 <benmachine> I think it's upset that the rule isn't anywhere near any of the things involved in it
05:40:10 <zygoloid> ClaudiusMaximus: a rule is an orphan basically if it's not guaranteed to be visible whenever the types and CAFs it mentions are
05:40:14 <Deewiant> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/separate-compilation.html#orphan-modules
05:40:46 <zygoloid> (in the same way an instance is an orphan if it's not guaranteed to be visible whenever the types and classes it mentions are)
05:40:47 <Deewiant> AIUI it's not a problem, just something to be avoided
05:41:08 <zygoloid> it means that the module gets added to a special list which GHC searches on every instance and rule lookup
05:41:31 <Deewiant> But that rule probably isn't such a good idea anyway, as realToFrac is evidently not the identity function on Double->Double (and thus not Double->GLdouble)
05:42:05 <Deewiant> So you should probably just write your own toGLdouble = unsafeCoerce :: Double -> GLdouble, or whatever
05:42:13 <chrisdone>   fixpoint f g = let x = f g
05:42:13 <chrisdone>                      y = f x
05:42:13 <chrisdone>                  in if x == y then y else fixpoint f y
05:42:17 <ClaudiusMaximus> ok, i can do that
05:42:19 <chrisdone> is this nicer with Control.Monad.Fix?
05:42:59 <zygoloid> Deewiant: realToFrac :: Double -> Double is not id? because of values with no Rational representation like Inf and NaN?
05:43:08 <zygoloid> > realToFrac (1/0) :: Double
05:43:09 <lambdabot>   Infinity
05:43:29 <zygoloid> > realToFrac (0/0) :: Double
05:43:30 <lambdabot>   -Infinity
05:43:35 <Deewiant> zygoloid: Yeah, because realToFrac = fromRational . toRational
05:43:36 <zygoloid> > 0/0 :: Double
05:43:37 <lambdabot>   NaN
05:43:47 <zygoloid> i see
05:44:22 <Deewiant> GHC evidently has or had a rewrite rule which made it id, but that caused observable differences in behaviour depending on whether you had optimizations on or not
05:44:24 <zygoloid> @check \d -> realToFrac d == (d :: Double)
05:44:25 <lambdabot>   "OK, passed 500 tests."
05:44:26 <benmachine> chrisdone: that requires Eq on x and y, it's not really the same sort of thing as Control.Monad.Fix.fix
05:44:50 <chrisdone> benmachine: i didn't think so. i can't think ofa  way to express it well in fix
05:44:58 <benmachine> @check d == d
05:44:59 <lambdabot>   "OK, passed 500 tests."
05:45:02 <zygoloid> > map (\d -> realToFrac d == (d :: Double)) [0/0, 1/0, 1e-308]
05:45:03 <lambdabot>   [False,True,True]
05:45:17 <benmachine> @check d == (d :: Float)
05:45:18 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
05:45:25 <zygoloid> huh, that's not even the right check :-/
05:45:40 <zygoloid> stupid nans.
05:45:45 <benmachine> @check \d -> d == (d :: Float)
05:45:46 <lambdabot>   "OK, passed 500 tests."
05:45:50 <benmachine> there we go
05:46:13 <benmachine> (doesn't seem to be checking nan)
05:46:22 <Deewiant> > (isNegativeZero (-0), isNegativeZero (realToFrac (-0)))
05:46:23 <lambdabot>   (True,False)
05:46:29 <quicksilver> if you pick 500 at random, what's the change you pick NaN? :)
05:46:39 <quicksilver> (actually I think QC's distribution on floats will never ever pick it)
05:46:54 <Deewiant> Pretty big actually
05:47:14 <aristid> quicksilver: there are lots of nans
05:47:15 <Deewiant> If you just pick a random bit-pattern, that is
05:47:33 <zygoloid> > map (\d -> decodeFloat (realToFrac d) == decodeFloat (d :: Double)) [0/0, 1/0, 0, -0, 1e-320]
05:47:34 <lambdabot>   [False,True,True,True,True]
05:47:42 <aristid> Deewiant: is there a reason why more than 1 value was reserved for this?
05:48:10 <Deewiant> You can put payloads in NaNs
05:48:15 <aristid> > decodeFloat 5
05:48:16 <lambdabot>   (5629499534213120,-50)
05:48:27 <zygoloid> > (decodeFloat (-0), decodeFloat 0)
05:48:28 <lambdabot>   ((0,0),(0,0))
05:48:35 <Deewiant> I guess the point is to be able to encode the origin/meaning of the NaN
05:48:48 <aristid> Deewiant: haven't seen that used ever
05:48:53 <zygoloid> P(NaN) is pretty small but not tiny
05:49:05 <zygoloid> 2^-11 iirc
05:49:22 <Deewiant> aristid: Yeah, it's not really taken advantage of
05:49:24 <zygoloid> so maybe we'd expect one every four runs of @check
05:49:42 <aristid> zygoloid: i don't think @check generates random bitpatterns there
05:49:59 <zygoloid> no, probably not
05:50:02 <aristid> of course i haven't checked :D
05:50:33 <ClaudiusMaximus> @check \x -> x < (2::Float)
05:50:34 <lambdabot>   "Falsifiable, after 0 tests:\n2.5\n"
05:50:53 <zygoloid> @check \x -> x < 1e50
05:50:55 <lambdabot>   "OK, passed 500 tests."
05:51:06 <Deewiant> @check \x -> x >= (-1000 :: Double)
05:51:06 <lambdabot>   "OK, passed 500 tests."
05:51:16 <aristid> ok this is bad
05:51:22 <zygoloid> @check \x -> abs x > 1e-10 || x == 0
05:51:23 <lambdabot>   "OK, passed 500 tests."
05:51:26 <mreh> what the?
05:51:36 <zygoloid> @check \x -> abs x > 1e-3 || x == 0
05:51:37 <lambdabot>   "OK, passed 500 tests."
05:51:41 <zygoloid> @check \x -> abs x > 1e-1 || x == 0
05:51:42 <lambdabot>   "Falsifiable, after 247 tests:\n-4.999999999999982e-2\n"
05:51:46 <benmachine> quicksilver: if I could only test five float values, I think I'd pick zero, negative zero, both infinities, and NaN :P
05:51:58 <zygoloid> benmachine: which NaN? ;-)
05:52:15 <zygoloid> QNaN or an SNaN?
05:52:20 <benmachine> *shrug*
05:52:37 <benmachine> I only vaguely recall the difference
05:53:14 <ClaudiusMaximus> wonder what my local tandoori would say if i rang up to order zero, negative zero, both infinities and a NaN
05:53:36 <zygoloid> benmachine: if i could pick five more, i'd pick denorm_min, -denorm_min, max_double, -max_double and 1 :)
05:53:53 <Jafet> Ask them to cut in multiples of pi
05:54:21 <aristid> i'd test 0 and 1 first
05:54:23 <benmachine> heh, yeah
05:54:31 <zygoloid> ClaudiusMaximus: hahaha
05:58:13 <zygoloid> > (5e-324 == 0, 1 / 5e-324)
05:58:14 <lambdabot>   (False,Infinity)
05:59:35 * hackagebot constructive-algebra 0.1.5 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.1.5 (AndersMortberg)
05:59:41 <ClaudiusMaximus> hm, now my profile indicates that this function is eating most of my time/allocs:  sortOn p = map fst . sortBy (comparing snd) . map (\x -> (x, p x))
06:00:49 <zygoloid> ClaudiusMaximus: how expensive is p?
06:01:04 <zygoloid> you might be better off with sortBy (comparing p) if it's cheap
06:03:11 <ClaudiusMaximus> good point - it's only:  4 (+)/(-), 3 (*), 1 sqrt, 1 (**)
06:03:40 <ClaudiusMaximus> will check :)
06:04:01 <zygoloid> otherwise, map (\x -> let px = p x in px `seq` (x, px)) might help
06:11:05 <ClaudiusMaximus> zygoloid: thanks, i think that one's the winner
06:17:59 <aristid> why is it better?
06:19:26 <ClaudiusMaximus> aristid: i looked at my profiling output and the totals for sortOn and p were least with that variant
06:19:36 <Taejo> is StateT s ]
06:19:38 <zygoloid> aristid: it avoids building the thunk for p x when each pair is forced
06:19:41 <Taejo> ack, misplaced enter
06:20:02 <edlinde> hi guys I was wondering if someone can point me to a tutorial or a web resource that explains RECURSION in more detail ?
06:20:02 <lambdabot> edlinde: You have 1 new message. '/msg lambdabot @messages' to read it.
06:20:28 <Taejo> is StateT s [] a list of stateful computations or a stateful computation of a list?
06:20:31 <kmc> edlinde, http://mitpress.mit.edu/sicp/full-text/book/book.html
06:20:37 <kmc> Taejo, neither
06:20:42 <aristid> > let x = 1 : x in x
06:20:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:20:46 <edlinde> yeah I got that book
06:20:47 <ClaudiusMaximus> as   sortBy (comparing snd)   will force all the snd's anyway, no point putting them in a thunk
06:20:48 <kmc> it's a computation in a monad which combines statefulness with the list monad
06:20:49 <aristid> edlinde: there, recursion
06:21:03 <kmc> edlinde, what more detail would you like?
06:21:05 <edlinde> but it had just two pages on recursion
06:21:24 <Taejo> kmc: yeah, I know that, but how does it combine them?
06:21:29 <edlinde> nah I don't mean it in the haskell way ... but just the general theory of how its supposed to work
06:21:43 <Taejo> when do I want StateT [] and when so I want ListT State
06:22:04 <kmc> edlinde, it works when you recognize that you can solve a big instance of a problem by solving one or more smaller instances of the same problem, until you get down to a trivial size
06:22:12 <aristid> edlinde: why do you ask in #haskell if you're not interested in the haskell way? :D
06:22:18 <kmc> like, you can solve the problem "how long is (x:xs)" by solving the problem "how long is xs"
06:22:29 <kmc> and you can solve "how long is []" immediately -- that's the base case
06:22:43 <kmc> @unmtl StateT s [] a
06:22:44 <lambdabot> s -> [(a, s)]
06:22:57 <kmc> @unmtl ListT (State s) a
06:22:57 <lambdabot> s -> ([a], s)
06:23:03 <edlinde> kmc: yep I get that...  the thing is that I was doing a C implementation and it had some tree recursion and code that got executed before the recursive call and right after
06:23:11 <Taejo> very cool feature, thanks kmc and lambdabot
06:23:21 <djahandarie> lambdabot++
06:23:23 <edlinde> so I just wanted to understand it better... and I know with FP you guys use recursion a lot
06:23:25 <edlinde> :)
06:23:27 <kmc> Taejo, so (StateT s [] a) produces many possible (value, state update) pairs
06:23:36 <kmc> and (ListT (State s) a) produces a single state update with many possible values
06:23:48 <kmc> <3 lambdabot
06:23:52 <kmc> @botsnack
06:23:52 <lambdabot> :)
06:24:14 <kmc> edlinde, do you have a question aboutyour C code?
06:24:46 <edlinde> kmc: ehm no not really... just wanted to know where you guys understand the concept of recursion from?
06:24:52 <edlinde> just the pure theory aspect of it
06:25:04 <zygoloid> edlinde: if you want to understand recursion better, check the IRC logs for #haskell and search for edlinde
06:25:06 <edlinde> like linear recursion, tail recursion and tree recursion etc
06:25:29 <kmc> edlinde, SICP talks about those some, google/wikipedia will find more articles, etc
06:25:35 <kmc> i can't point to one book and say "this is where i learned recursion"
06:25:43 <philed> edlinde: There's probably lots of ways to finally "get" it. Which way works for you will depend on your background.
06:25:46 <kmc> the closest would be SICP but meh you already rejected it
06:26:15 <kmc> edlinde, trying to understand "the theory" of something without having any questions can be a trap
06:26:18 <edlinde> kmc: well yeah I read through it... but I don't really know scheme that well so the examples were a bit weird for me
06:26:25 <kmc> edlinde, err, the book is supposed to teach you scheme
06:26:33 <edlinde> is it?
06:26:34 <kmc> it doesn't assume you know scheme going in
06:26:35 <kmc> yes
06:26:53 <edlinde> I thought it was just a theory book and scheme was their language of choice for the illustrations
06:27:13 <kmc> i mean
06:27:18 <kmc> the /point/ of the book is not to teach you Scheme
06:27:24 <kmc> but i think it does a decent job of that along the way
06:27:25 <edlinde> i know
06:27:26 <zygoloid> edlinde: if you understand divide-and-conquer, you can view recursion as just a way of implementing that.
06:27:44 <kmc> they don't even use much of Scheme
06:27:52 <aristid> > fix f :: Expr
06:27:52 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
06:27:57 <edlinde> well the thing that puzzled me the most with my C code problem was that I was doing a tree recursion
06:28:14 <edlinde> and also had code that was placed right after the recursive call
06:28:28 <edlinde> so to say that it gets executed when the recursion returns
06:28:34 <kmc> edlinde, maybe you'd also like to study the untyped lambda calculus and its fixed-point combinators, like the Y combinator
06:28:41 <edlinde> the way I envision it is as a stack
06:28:45 <Phyx-> anyone here try to build the HEAD on windows?
06:28:51 <kmc> yes, that's probably the way it's implemented too
06:28:54 <Phyx-> tried*
06:29:07 <edlinde> you keep placing your calls on to it .. when you hit the base case.. you start to pop off each function call
06:29:08 <cathper> Hmm, how to get [ [x1,...,xn] <- x1 <- [1..m], ..., xn <- [1..m] ] when n and m are variables?
06:29:27 <cathper> [ [x1,...,xn] | x1 <- [1..m], ..., xn <- [1..m] ] even.
06:29:36 <zygoloid> edlinde: that's a reasonable way of thinking about it in C
06:29:41 <edlinde> so you kind of execute the calls in reverse yeah?
06:29:46 <zygoloid> yeah
06:29:49 <edlinde> zygoloid: ok
06:29:55 <kmc> edlinde, a recursive call isn't special though
06:29:59 <edlinde> so I just wanted to confirm that
06:30:00 <kmc> it's just an ordinary function call
06:30:09 <edlinde> yeah to you kmc 
06:30:11 <edlinde> :)
06:30:21 <edlinde> it can be a pain in the butt in C
06:30:28 <kmc> i mean that the implementation probably doesn't have to do anything special
06:30:31 <edlinde> coz I was getting all sorts of segmentation faults
06:30:45 <zygoloid> edlinde: stack overflows, i guess?
06:30:47 <edlinde> memory allocations and deallocs had to be done right
06:30:50 <kmc> > replicateM 5 "abc"
06:30:51 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaba","aaabb","aaabc","aaaca","aaacb","aaacc","a...
06:30:51 <aristid> kmc: well there are some systems where functions are not reentrant
06:30:55 <kmc> cathper, ^^^^
06:30:56 <edlinde> nah wasn't really a stack overflow as such
06:31:14 <edlinde> kmc: was that for me?
06:31:27 <kmc> > replicateM 3 [4,5,6]
06:31:28 <lambdabot>   [[4,4,4],[4,4,5],[4,4,6],[4,5,4],[4,5,5],[4,5,6],[4,6,4],[4,6,5],[4,6,6],[5...
06:31:33 <zygoloid> edlinde: no, that's for cathper
06:31:36 <edlinde> ah ok
06:31:41 <edlinde> was wondering :)
06:31:41 <kmc> edlinde, the line before i said "cathper, ^^^^" was for cathper
06:31:50 <aristid> edlinde: c++ does help you with the memory alloc/dealloc, and i'm always sad when people don't use these facilities. of course you don't have anything of that sort in C without ++.
06:31:57 <edlinde> I missed his qn... ok cool
06:32:10 <kmc> edlinde, i agree that functions are a pain to use in C, recursive or not
06:32:22 <edlinde> well functions are ok
06:32:36 <kmc> C doesn't really support functions, only this limited special case called "first-order functions"
06:32:36 <cathper> > replicateM 2 [1,3]
06:32:37 <lambdabot>   [[1,1],[1,3],[3,1],[3,3]]
06:32:48 <edlinde> its when you start making them more complicated with recursion and all sorts of loops within and data structures that it gets screwed
06:33:00 <zygoloid> even then, they're not really functions either since they're impure
06:33:01 <cathper> Hmm, not really what I want.
06:33:05 <edlinde> I was like... where the hell should I allocate and when should I dealloc and in what order etc
06:33:19 <kmc> cathper, how so? did i misread your question?
06:33:30 <aristid> zygoloid: a -> IO b is not a function?
06:33:38 <cathper> It's like lists of length n in all combinations where each entry is at most m.
06:33:43 <zygoloid> > (\m n -> replicateM n [1..m]) 4 2
06:33:45 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4...
06:33:45 <edlinde> so how do you guys understand recursion as opposed to how spomeone like me coming from a C background?
06:33:55 <kmc> aristid, sure it is, but applying that function isn't going to perform any effect
06:34:12 <kmc> edlinde, i don't think we can usefully answer that question
06:34:19 <zygoloid> aristid: if we had first-class IO actions in C then that'd be a satisfying viewpoint.
06:34:21 <edlinde> hmm ok :)
06:34:53 <zygoloid> (if you view it that way then C has >>= but no normal function application)
06:35:02 <kmc> edlinde, it sounds like you have more issues with C's explicit memory management and other low-level stuff
06:35:07 <kmc> and not with the theory of recursion
06:35:15 <aristid> zygoloid: yes:)
06:35:26 <edlinde> yeah its in combination with the recursion that I noticed that I had to refresh it a bit 
06:35:50 <edlinde> but for example what is tail recursion?
06:35:59 <cathper> n = 3, m = 2 should give [ [0,0,0], [0,0,1], [0,1,0], ..., [1,1,1], [0,0,2], ..., [2,2,2], [1,1,2], ..., ]
06:36:04 <edlinde> I mean put simply for me :)
06:36:10 <zygoloid> edlinde: laziness changes the nature of recursion somewhat. because f n = n:f (n+1) is recursive but you don't get a stack of 'f's.
06:36:20 <zygoloid> s/because/for instance/
06:36:27 <cathper> [ [x1,...,xn] | x1 <- [1..m], ..., xn <- [1..m] ]
06:36:41 <cathper> Hmm.
06:36:46 <zygoloid> cathper: do you want to start from 0 or 1?
06:36:52 <cathper> I probably misunderstod replicateM.
06:37:01 <edlinde> zygoloid: so my understanding is that when you say lazy it means the evaluation is deferred?
06:37:04 <Saizan> > replicatM 3 [0..2]
06:37:06 <lambdabot>   Not in scope: `replicatM'
06:37:06 <kmc> cathper, ah, do you care about order?
06:37:08 <Saizan> > replicateM 3 [0..2]
06:37:09 <aristid> @src replicateM
06:37:09 <lambdabot> replicateM n x = sequence (replicate n x)
06:37:10 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[1...
06:37:12 <edlinde> and only when you need to it will calculate the sub problem yeah?
06:37:13 <zygoloid> > (\m n -> replicateM n [1..m]) 2 3
06:37:14 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
06:37:24 <zygoloid> cathper: ^^ isn't that what you want?
06:37:25 <kmc> edlinde, it's easier to consider tail recursion with strict (not lazy) evaluation
06:37:26 <aristid> > sequence [[0,1,2],[0,1,2]]
06:37:27 <lambdabot>   [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]
06:37:27 <edlinde> so you don't really allocate any memory in haskell?
06:37:40 <kmc> no, Haskell programs typically allocate tons of memory
06:37:47 <edlinde> yeah?
06:37:50 <kmc> that memory is largely storing unevaluated expressions that will be forced later
06:37:51 <edlinde> even in lazy mode?
06:37:52 <zygoloid> edlinde: memory is allocated by the system in order to store 'things to do later' and the results of things already done
06:38:06 <edlinde> hmm ok i see
06:38:07 <kmc> edlinde, how are you going to remember something to do for later, if you don't have memory?
06:38:18 <zygoloid> edlinde: but it's unusual for programmers to explicitly write code to allocate memory (it happens in the IO monad sometimes, though)
06:38:27 <yitz> kmc: i know that feeling
06:38:30 <edlinde> ok
06:38:35 <kmc> edlinde, if by "you don't really allocate any memory" you mean that we don't explicitly write malloc and such, then you're right
06:38:43 <kmc> edlinde, but that's nothing to do with laziness -- most programming languages are like that
06:38:46 <kmc> C and C++ are exceptions
06:39:07 <Taejo> :t lift . guard
06:39:08 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *). (MonadTrans t, MonadPlus m) => Bool -> t m ()
06:39:08 <edlinde> well what I meant was that you don't have to pre-allocate this memory in haskell.. I assume
06:39:11 <cathper> zygoloid: Right.
06:39:12 <kmc> most languages you just create values / objects / whatever without worrying about how big they are and where they go
06:39:26 <kmc> and you don't have to deallocate them -- the runtime system does it for you
06:39:27 <cathper> kmc: Not really, I misunderstood replicateM.
06:39:29 <kmc> Haskell is like this
06:39:34 <edlinde> becuse you for example have concepts like infinite sets etc.. I mean you cannot have allocated infinite memory for it?
06:39:46 <Taejo> :t lift . get
06:39:47 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) (f :: * -> *). (MonadTrans t, Monad m, MonadState (m a) f, Functor f) => f (t m a)
06:39:50 <kmc> edlinde, it allocates finite memory to store the expression which computes "the rest of the list"
06:39:50 <edlinde> yeah I get that
06:40:00 <edlinde> you have automatic memory management and garbage collection 
06:40:13 <edlinde> kmc: ok
06:40:13 <kmc> and as you ask for element successively it updates that expression to know how to compute the part after what you've evaluated
06:40:19 <zygoloid> edlinde: if you were to write [0..], and then hold onto that list for later while iterating down it, you would eventually run out of memory.
06:40:36 <edlinde> yeah coz I always notice that in FP .. for example a list is ... x followed by many x's
06:40:39 <edlinde> or something
06:40:51 <edlinde> ok
06:40:54 <kmc> [0..]  â  0:[1..]  â  0:1:[2..]  â  0:1:2:[3..]  â  ...
06:41:08 <zygoloid> that's what we call a 'space leak', where we're accidentally retaining something which refers to a large object which we're never actually going to look at again
06:41:15 <edlinde> I wish I had learnt a FP language too
06:41:22 <kmc> edlinde, no time like the present :)
06:41:23 <edlinde> I think next course I do is going to use ML
06:41:27 <edlinde> so that will be my first
06:41:33 <Starfire> @src enumFrom
06:41:33 <lambdabot> Source not found. Where did you learn to type?
06:41:33 <kmc> ok
06:41:42 <kmc> @src Enum
06:41:43 <lambdabot> class  Enum a   where
06:41:43 <lambdabot>     succ                     :: a -> a
06:41:43 <lambdabot>     pred                     :: a -> a
06:41:43 <lambdabot>     toEnum                   :: Int -> a
06:41:43 <lambdabot>     fromEnum                 :: a -> Int
06:41:45 <lambdabot> [3 @more lines]
06:41:54 <edlinde> kmc: yeah i don't have the time to immerse myself into it at the moment unfortunately
06:41:54 <orlandu63> zygoloid: how do you fix a space leak in haskell?
06:41:55 <kmc> you can imagine that the expression "[3..]" takes a finite amount of memory to store -- it certainly takes a finite amount of characters to represent in our source code
06:41:59 <kmc> edlinde, :/
06:42:05 <djahandarie> edlinde, you've talked about learning functional programming at least 4 or 5 times in this channel now, you should actually do it
06:42:21 <edlinde> djahandarie: hahha yeah I know
06:42:29 <edlinde> I been looking at bits and pieces of the SICP book
06:42:30 <kmc> you can learn functional programming without learning a "functional language"
06:42:34 <edlinde> and this little schemer
06:42:42 <edlinde> yeah true I agree
06:42:43 <zygoloid> orlandu63: usually space leaks are caused by unevaluated thunks holding onto something which the final result will not reference
06:42:47 <kmc> by the narrow definition usually used
06:42:59 <kmc> Python, Ruby, JavaScript, C# are all fine arenas for learning FP
06:43:00 <edlinde> I just know some bits and pieces of this stuff by reading say the first chapter of SICP
06:43:04 <zygoloid> orlandu63: in those cases you can fix the space leak by applying strictness: forcing the thunk to be evaluated sooner so it drops the reference.
06:43:06 <edlinde> its a good book to understand the concepts
06:43:35 <orlandu63> zygoloid: ah okay
06:43:42 <edlinde> ok I better go now then
06:43:45 <edlinde> cheers guys
06:43:49 <kmc> :)
06:43:57 <edlinde> next time I will come around and teach you guys how to code in Haskell :)
06:44:08 <edlinde> lol kidding
06:44:19 <zygoloid> orlandu63: other times they can be caused by holding a reference to say a pair (BigThing, ThingI'mGoingToUse) and the fix there is to make sure you only hold onto the snd of the pair :)
06:44:20 <edlinde> coding in Haskell the C way
06:44:22 <edlinde> :)
06:44:57 <kmc> @quote uncompile.make
06:44:58 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
06:45:05 <zygoloid> orlandu63: /finding/ the space leaks on the other hand is currently somewhat of a dark art :/
06:45:39 <zygoloid> heap profiles can help a lot, and i'm working on a tool which will help further, but that's some way off yet ;-)
06:45:42 <Taejo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27161#a27161 -- I'm trying to solve n queens using monad transformers, but in the line "row <- gets $ IS.toList . rows", I want row to bind to each row in turn, rather than the list of rows -- how do I do that?
06:45:59 <aristid> kmc: wtf this quote is a strange compilation of words
06:46:33 <zygoloid> aristid: sounds like you need to uncompile "make into java gcc 3.3 under ubuntu freebsd" into a meaningful sentence
06:46:45 <Jafet> @protontorpedo
06:46:45 <lambdabot> how does haskell compare to c++?
06:46:45 <kmc> Taejo, "rows <- gets stuff; row <- rows" ?
06:46:49 <zygoloid> and maybe that's what NIXDAEMON-COOL wanted help with?
06:46:56 <kmc> Taejo, or simply "row <- join $ gets stuff"
06:47:53 <aristid> zygoloid: i prefer spending my time on finding a general solution to the halting problem
06:48:01 <zygoloid> kmc: wouldn't it need to be: rows <- gets stuff; row <- lift rows
06:48:08 <kmc> zygoloid, perhaps
06:48:43 <zygoloid> @type lift :: [a] -> StateT s [] a
06:48:44 <lambdabot> forall a s. [a] -> StateT s [] a
06:49:02 <djahandarie> ...
06:49:25 <kmc> â¦â¦â¦
06:50:01 <yitz> > fix ('.':)
06:50:02 <lambdabot>   ".............................................................................
06:50:09 <kmc> > fix ('â¦':)
06:50:10 <lambdabot>   "\8230\8230\8230\8230\8230\8230\8230\8230\8230\8230\8230\8230\8230\8230\823...
06:50:17 <kmc> > text $ take 30 $ fix ('â¦':)
06:50:18 <lambdabot>   â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦â¦...
06:50:20 <yitz> > text $ fix ('.':)
06:50:25 <lambdabot>   mueval: ExitFailure 1
06:50:37 <djahandarie> text is strict I think
06:50:55 <Taejo> zygoloid: right
06:51:35 <cathper> kmc,zygoloid: It got it. Thanks for your help :-)
06:51:47 <kmc> aristid, zygoloid weird thing was, he actually turned out to have a legit haskell question, which had nothing to do with make, java, gcc, ubuntu, or freebsd
06:52:28 <aristid> kmc: why did he use these words then?
06:52:31 <kmc> no idea
06:52:45 <kmc> it may have been a joke which was lost in translation
06:52:52 <jmcdon> 09:47    aristid  : zygoloid: i prefer spending my time on finding a general solution to the halting problem
06:52:53 <Taejo> :t replicate
06:52:54 <lambdabot> forall a. Int -> a -> [a]
07:01:27 <Taejo> can I get ghci to time each computation?
07:02:06 <Axman6> you can indeed
07:02:18 <Taejo> Axman6: do you know the option?
07:02:27 <tg_> -P?
07:02:29 <Axman6> but, i don't have GHC installed on this machine so can't check the option. check the ghc manpage
07:02:45 <Axman6> you can use :set <whatever the flag is>
07:02:49 <tg_> http://linux.die.net/man/1/ghc
07:04:30 <tg_> Taejo: under profiling options
07:04:33 <tg_> -prof
07:05:04 <Taejo> *Main> :set -prof
07:05:05 <Taejo> ghc: <no location info>: -prof\
07:05:17 <Taejo> I thought it was -t, but that shows the type
07:05:55 <tg_> -auto
07:05:59 <cathper> If you compile it, you can use ghc -prof -auto-all file.hs; then ./file +RTS -p -RTS.
07:06:12 <Taejo> cathper: I don't want to profile
07:06:30 <Taejo> I just want something like bash's time, but in ghci
07:06:37 <tg_> -auto is evidently the thing that adds timers to each function
07:06:39 <Taejo> I thought ghci had it -- hugs used to
07:07:25 <tg_> Taejo: -auto adds _scc_s to all exported functions, -auto-add adds _scc_s to all top-level functions
07:07:43 <Taejo> tg_: like I said, I don't want to profile
07:07:52 <tg_> Taejo: sorry. I don't know the difference.
07:08:00 <tab> Taejo: you can probably make a small wrapper function to do that
07:08:23 <Taejo> tg_: profiling adds extra code, slowing down execution, and times each function individually
07:08:40 <tg_> Taejo: I figured.
07:08:41 <Taejo> tab: yeah, of course I could, but I thought it was already done
07:09:01 <Taejo> anyway, tg_, I don't think ghci has a nice interface to it
07:09:01 <tg_> @hoogle profile
07:09:02 <lambdabot> No results found
07:09:32 <Phyx-> > primAdd
07:09:33 <lambdabot>   Not in scope: `primAdd'
07:09:57 <Phyx-> > isBottom undefined
07:09:58 <lambdabot>   Not in scope: `isBottom'
07:10:10 <Phyx-> @hoogle bottom
07:10:10 <lambdabot> Test.QuickCheck.Batch bottom :: a
07:10:10 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
07:10:22 <ClaudiusMaximus> when will "./Main +RTS -p +N2 -RTS" work ?
07:10:40 <Phyx-> > Test.QuickCheck.Batch.isBottom undefined
07:10:40 <lambdabot>   Not in scope: `Test.QuickCheck.Batch.isBottom'
07:11:00 <tg_> Taejo: I remember doing similar such things in the Linux kernel using the high precision timer on the CPU.
07:11:06 <tg_> But I haven't a clue where to begin in Haskell
07:11:07 <ClaudiusMaximus> tg_: ghci ; :set +s ; length [0..100]
07:11:27 <ClaudiusMaximus> oops, Taejo was asking
07:11:45 <Taejo> ClaudiusMaximus: thanks!
07:11:59 <tab> nice
07:12:10 <tg_> length is setting what?
07:12:19 <tab> that does beat the small wrapper :)
07:12:29 <ClaudiusMaximus> just an example computation
07:12:33 <tg_> oh ok
07:13:06 <tg_> ugh. seriously? there isn't a whole word match in Chrome?
07:35:22 <cizra> tg_: Try adding spaces OSLT to the search term
07:45:21 <aristid> @src isBottom
07:45:21 <lambdabot> Source not found.
07:45:37 <nlogax> hmm, how do i get yi-gtk up and running? installed yi with -fgtk, dunno if that changed anything
07:45:38 <zygoloid> isBottom = isNothing . spoon
07:45:40 <aristid> so isBottom solves the halting problem?
07:45:53 <tibbe> dcoutts_: yt?
07:46:02 <zygoloid> aristid: if so, its runtime is unbounded ;-)
07:46:06 <Taejo> aristid: the implementation gives you a hint
07:46:10 <Taejo> there is no spoon
07:46:20 <aristid> my shpoon is too big
07:47:05 <aristid> Taejo: in case you wonder: http://www.youtube.com/watch?v=MuOvqeABHvQ
07:47:05 <Taejo> aristid: spoon uses unsafePerformIO to catch the exception raised by error
07:47:22 <aristid> does it also catch <<loop>>?
07:47:34 <Taejo> can't remember
07:47:37 <Taejo> @hackage spoon
07:47:37 <lambdabot> http://hackage.haskell.org/package/spoon
07:48:15 <Taejo> "This library considers pureish to be any error call or undefined, failed pattern matches, arithmetic exceptions, and array bounds exceptions."
07:48:37 <zygoloid> the library is sadly nondeterministic as a reslut
07:48:48 <zygoloid> it should have just caught any exceptions it could
07:50:58 <aristid> :t spoon
07:50:59 <lambdabot> Not in scope: `spoon'
07:52:10 <Taejo> aristid: just go to the hackage page
07:52:20 <aristid> Taejo: i wanted to see if i can use it here
07:52:25 <Taejo> oic
07:52:38 <tg_> yesterday in this chatroom someone used a word which meant 'unit' of a set
07:52:40 <tg_> or something like that
07:52:42 <tg_> any clues?
07:52:58 <zygoloid> point ?
07:53:09 <jor> hi
07:53:11 <tg_> nope
07:53:30 <aristid> Prelude Control.Spoon> teaspoon (head [])
07:53:30 <aristid> Nothing
07:53:30 <jor>  ineed a programmer to make a slot game .........
07:53:38 <aristid> Taejo: spoon is evil
07:53:59 <jor> just like beetle frenzy........
07:54:52 <zygoloid> jor: i'll do it for Â£100K, if i can work in my spare time :)
07:54:55 <Axman6> why don't you just write one?
07:55:27 <jor> you know the slot beetle frenzy........?
07:55:43 <jor> call me prive
07:55:52 <Axman6> no
07:56:03 <zygoloid> > length "beetle frenzy........" == length "beetle frenzy........"
07:56:04 <lambdabot>   True
07:56:17 <zygoloid> so are the periods part of the name then?
07:56:28 <zygoloid> prive: are the periods part of the name of the game?
07:57:06 <Axman6> jor: why can't we call you jor? prive is a stupid name
07:58:20 <Axman6> and don't pm people without asking them
07:59:38 * hackagebot test-framework 0.3.2 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.3.2 (MaxBolingbroke)
08:00:33 <Axman6> i think i scared him off
08:00:37 <Saizan> maybe (s)he meant "send me a pm"?
08:01:02 <zygoloid> Saizan: but interpreting it that way would have been no fun at all
08:01:24 <soupdragon> it's trigonometry relevant in this day and age?
08:01:24 <aristid> indeed........
08:01:32 <Taejo> soupdragon: yes!
08:01:43 <aristid> soupdragon: no........ its not........
08:02:06 <zygoloid> soupdragon: not knowing trig in this day and age is a sin.
08:02:17 <zygoloid> (so knowing trig is a cos)
08:02:26 <soupdragon> >:D
08:02:29 <Jafet> It's a sin, 'cos we're tangential to the topic.
08:02:32 <Taejo> aristid: sailors and pilots should still be able to navigate without GPS
08:02:36 <soupdragon> this discussion has gone off at a tangent
08:02:42 <Taejo> and anyway, people still have to write GPS software
08:02:49 <Taejo> so even the original use is still alive
08:02:51 <aristid> Taejo: y........ u can just use the garmin
08:02:54 <soupdragon> I heard that GPS uses relativity as well
08:02:55 <aristid> ........
08:03:03 <soupdragon> to correct for time distortion
08:03:53 <soupdragon> how did Soddy prove his theorem
08:04:00 <soupdragon> it's amazing
08:04:18 <Taejo> aristid: WWIII starts while you're in the air and the GPS satellites get disabled, or... the gps just runs out of batteries
08:04:38 <Phyx-> @faw
08:04:38 <lambdabot> The answer is: Yes! Haskell can do that.
08:04:38 <Taejo> anyway, like I said, somebody has to build and program the GPSes
08:04:40 <Phyx-> @faq
08:04:41 <lambdabot> The answer is: Yes! Haskell can do that.
08:05:25 <aristid> Taejo: lets play beetle frenzy........
08:05:38 <Taejo> aristid: I *am* playing beetle frenzy
08:05:43 <Taejo> http://www.casinolistings.com/games/free-beetle-frenzy-slot-machine
08:05:50 <aristid> no beetle frenzy........
08:05:51 <Taejo> it's not very exciting
08:05:51 <aristid> with ........
08:06:06 <Taejo> I couldn't find it
08:06:10 <Taejo> I googled it
08:06:16 <eevar2> @fat
08:06:17 <lambdabot> Maybe you meant: fact faq ft
08:06:37 <eevar2> @faw
08:06:37 <lambdabot> The answer is: Yes! Haskell can do that.
08:07:11 <Axman6> @fuq
08:07:11 <lambdabot> The answer is: Yes! Haskell can do that.
08:07:27 <soupdragon> what is the meaning of a circles position (x+iy) divided by it's radius?
08:07:36 <aristid> @faw Why is @faw the same as @faq?
08:07:36 <lambdabot> The answer is: Yes! Haskell can do that.
08:07:44 <soupdragon> does this number (x/r)+i(y/r) mean something on it's own?
08:07:53 <zygoloid> haha, excellent, "portugese polymorphism" has made its way into wikipedia
08:08:01 <Axman6> soupdragon: it's a unit vector no?
08:08:05 <soupdragon> no
08:08:20 <Axman6> oh, right
08:08:41 <soupdragon> http://www.math.brown.edu/~alexk/newer6.jpg
08:08:51 <Axman6> i was assuming you meanx x+iy was a position on a circle's circumference
08:09:07 <Axman6> o.O
08:09:56 <soupdragon> http://graphics.ethz.ch/~peikert/personal/packing/images/apoll3d.png
08:10:15 <kmc> zygoloid, where does that term come from?
08:10:47 * Axman6 -> sleep
08:12:56 <zygoloid> kmc: came up randomly on -blah yesterday
08:15:36 <kmc> there can be only one!
08:43:51 <Taejo> :t liftM lift
08:43:52 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) (m1 :: * -> *). (MonadTrans t, Monad m, Monad m1) => m1 (m a) -> m1 (t m a)
08:45:12 <aristid> :t join . liftM lift
08:45:13 <lambdabot> forall a (m :: * -> *) (t :: (* -> *) -> * -> *). (Monad (t m), MonadTrans t, Monad m) => t m (m a) -> t m a
08:47:33 <kmc> hmm
08:47:52 <kmc> would be nice if (MonadTrans t, Monad m) implied (Monad (t m))
08:47:56 <Phyx-> @fix (\f n -> if n > 0 then f (n-1) + 1 else 0)
08:47:56 <lambdabot> Maybe you meant: bid faq ft id thx
08:48:00 <Phyx-> > fix (\f n -> if n > 0 then f (n-1) + 1 else 0)
08:48:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a1)
08:48:02 <lambdabot>    arising from a use of ...
08:48:04 <kmc> but i think that can't be expressed in GHC's typeclass system?
08:48:05 <Phyx-> > fix (\f n -> if n > 0 then f (n-1) + 1 else 0) 0
08:48:06 <lambdabot>   0
08:48:10 <Phyx-> > fix (\f n -> if n > 0 then f (n-1) + 1 else 0) 10
08:48:10 <lambdabot>   10
08:48:15 <ManateeLazyCat> *HTTP* and *dbus-core* depend on "network", re-install anyone (dbus-core or HTTP) will re-install "network" package, cause broken another package. Any idea fix?
08:48:48 <Saizan> kmc: can you implement it with the current methods of MonadTrans ?
08:48:55 <Phyx-> > fix (\f n -> if n > 0 then f (n-1) * f (n - 2) else 0) 10
08:48:56 <lambdabot>   0
08:49:03 <Phyx-> > fix (\f n -> if n > 0 then f (n-1) * f (n - 2) else 1) 10
08:49:04 <lambdabot>   1
08:50:38 <kmc> Saizan, hmm, don't think so
08:51:05 <kmc> @type lift
08:51:06 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
08:54:09 <Saizan> a constraint synonym for "Monad m, MonadTrans t, Monad (t m)" would be nice though
08:55:56 * ManateeLazyCat Hmmm, looks i need install those two packages together to fix broken...
08:57:28 <Phyx-> > fix (\f n -> if n >= 0 then f (n-1) * f (n - 2) else 1) 10
08:57:29 <lambdabot>   1
08:59:04 <dmwit> Phyx-: Maybe you meant (+) instead of (*) in the "then" branch.
09:02:29 <EvanCarroll> You know, I was looking at dwtm, xmonad, and regular screen.
09:03:03 <EvanCarroll> It seems as if out of all them, screen's dirt simple panes were the best fit for my need
09:03:13 <Phyx-> dmwit: it's early :) 
09:04:14 <EvanCarroll> I couldn't get used to xmonad for the life of me, and for the amount of functionality I use in a window manager, I couldn't justify having to set up xmobar, and x-status-bar-thingy
09:05:00 <Phyx-> hah, deleting those lines from the .mk file seems to have worked..
09:10:07 <cheater99> does haskell have the normalization property?
09:10:35 <cheater99> and if so, is it strong or weak?
09:10:56 <soupdragon> no
09:11:04 <jmcarthur> haskell is not strongly normalizing. i don't know what weakly normalizing means, though
09:11:22 <pikhq> EvanCarroll: You may like DWM. It's a single (readable) file window manager.
09:11:34 <philed> I believe weakly normalising means that different rewrite paths lead to different normal forms.
09:11:42 <soupdragon> jmcarthur, it just means that not every reduction strategy will work - there's at least one which will normalize the term
09:11:50 <cheater99> weakly normalizing means "at least one rewrite path that terminates"
09:11:54 <jmcarthur> ah
09:12:05 <Saizan> so no
09:12:09 <cheater99> strongly means "all of them terminate to the same thing"
09:12:15 <jmcarthur> > let x = x in x
09:12:19 <lambdabot>   mueval-core: Time limit exceeded
09:12:29 <jmcarthur> i don't think any evaluation order will cause that to terminate ;)
09:12:48 <cheater99> ok
09:13:05 <zygoloid> seems like you could exhaustively try all normalization strategies breadth-first, so even weakly-normalizing means not-turing-complete?
09:13:07 <cheater99> thanks
09:13:18 <cheater99> zygoloid: no idea.
09:13:47 <jmcarthur> zygoloid: a "mixed strategy"? :P
09:16:42 <Philippa> cheater99: no turing complete language has strong normalisation for the whole of the language
09:17:02 <cheater99> interesting
09:17:16 <cheater99> if i have a lambda expression, is it possible to check if it is strongly normalizing?
09:17:25 <philed> If it is simply typed, it will be.
09:17:39 <cheater99> was that for me?
09:17:49 <Philippa> in general, no. That's the halting problem transposed to the lambda calculus, and it's only semi-decidable
09:17:56 <cheater99> ok
09:18:03 <zygoloid> cheater99: yes. simply-typed lambda calculus is strongly-normalizing
09:18:05 <philed> Yeah. If you can give it a simple type, then it will be strongly normalising.
09:18:07 <Philippa> (which is to say: you can try to normalise it and if you ever finish, it normalises...)
09:18:34 <Philippa> philed: that's sufficient, but far from necessary though
09:18:45 <soupdragon> if you have a lambda term in haskell that types it is going to strongly normalize
09:18:53 <philed> Sure.
09:19:00 <philed> (to Philippa)
09:19:06 <soupdragon> if you introduce recursive function definitions or negative data types - you will lose termination
09:19:21 <Philippa> or if you call something that uses them
09:19:29 <soupdragon> by 'negative data types' I basically mean data types which model untyped lambda calculus
09:20:05 <philed> Philippa: Is it completely accurate to say that all Turing complete languages will be not be strongly normalising? If, say, type-checking is undeciable, could it not be Turing complete? I'm thinking of things like Coq here.
09:20:43 <soupdragon> typechecking is decidible in Coq
09:20:48 <Philippa> philed: at that point you're talking about the turing completeness of the type language, which is something else
09:20:54 <Philippa> and what soupdragon said
09:21:41 <Philippa> philed: basically, for formal purposes using the type system to do your computation is a different language
09:21:48 <Philippa> with a different notion of normalisation
09:22:40 <danharaj> There are systems whose typed terms are exactly the lambda terms with normal forms.
09:22:57 <danharaj> The explanation is "something something intersection types"
09:23:12 <philed> Ah okay. Surprised about the Coq thing though. I don't know enough about it, clearly. My understanding was that there was a one-one correspondence between typing judgements and theorems in intuitionistic higher-order logic. That's not decidable, right?
09:23:44 <Philippa> no, the correspondance is between types and theorems, not typings
09:24:04 <Philippa> typings are /also/ proofs, of course, but then it's not one-to-one
09:24:06 <cheater99> can i somehow enforce that the functions i write have a normal form?
09:24:08 <philed> Ack, sorry. I meant typing judgements and derivations.
09:24:25 <danharaj> cheater99: Not within Haskell.
09:24:37 <Philippa> cheater99: much more easily, so long as you don't mind having to either manually prove they terminate or losing the ability to write some terminating functions
09:24:51 <Philippa> danharaj: at least, not in haskell without external convention
09:25:03 <philed> lol. Just realised what I'm saying there. Ignore me!
09:25:07 <cheater99> Philippa: i would like this to be enforced automatically if possible
09:25:17 <danharaj> Use Agda.
09:25:21 <Philippa> cheater99: try using a language like Agda or Coq
09:25:31 <cheater99> Philippa: ok. but in haskell?
09:25:34 <Philippa> it won't be completely automatic, you'll have to give it help to type your code sometimes
09:25:41 <Philippa> no, you can't. Just like you can't in, say, C++
09:26:08 <danharaj> And it can never be completely automatic.
09:26:16 <soupdragon> termination checking is so difficult to do ab initio that we just don't bother
09:26:18 <Philippa> it's easier to show termination for a haskell program than a C++ one though
09:26:25 <soupdragon> oops
09:26:32 <soupdragon> thats not what I meant :P
09:26:57 <Philippa> it's difficult to do ex ano, too?
09:28:28 <danharaj> It is difficult to implement in media res.
09:28:31 <danharaj> :p
09:29:17 <b0fh_ua> Hello! How do I fix the error: package xmonad-0.9.1-ef9ba4a11ee93e7fa35937a2b2f1391f is unusable due to missing or recursive dependencies:  process-1.0.1.2-bc35b1653d620c4947a34fb0a64973ff ?
09:35:02 <Saizan> b0fh_ua: pass "-package-id xmonad-0.9.1-ef9ba4a11ee93e7fa35937a2b2f1391f" to ghc[i]
09:35:31 <Saizan> unless you're building this via Cabal?
09:35:54 <c_wraith> :t on (&&)
09:35:55 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
09:36:14 <c_wraith> that's not really what I want..
09:36:22 <Philonous1> What do you want?
09:36:26 <b0fh_ua> Saizan: I am using cabal, yes
09:36:30 <Saizan> liftM2 (&&) ?
09:36:30 <b0fh_ua> oh, no
09:36:39 <b0fh_ua> I trying to get xmonad compiled
09:36:56 <Saizan> b0fh_ua: what command are you running?
09:36:57 <c_wraith> :t liftM2 (&&) even odd
09:36:58 <lambdabot> forall a. (Integral a) => a -> Bool
09:37:03 <c_wraith> yeah, that's what I want
09:37:08 <b0fh_ua> ghc -v --make -o xmonad-i386-freebsd xmonad.hs
09:37:16 <abbe> Is http://haskell.org loading fine for others ?
09:37:27 <c_wraith> abbe: yes
09:37:35 <Saizan> b0fh_ua: ok, add the "-package-id xmonad-0.9.1-ef9ba4a11ee93e7fa35937a2b2f1391f" then
09:37:41 <soupdragon> :t showIntAtBase
09:37:42 <b0fh_ua> Saizan: this worked...
09:37:42 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
09:37:49 <b0fh_ua> but what's wrong with my cabal packages?
09:38:07 <c_wraith> > let constFalse = liftM2 (&&) even odd in map constFalse [1..5]
09:38:09 <lambdabot>   [False,False,False,False,False]
09:38:10 <abbe> c_wraith, thanks.
09:38:11 <soupdragon> :t showDigit
09:38:12 <lambdabot> Not in scope: `showDigit'
09:38:12 <b0fh_ua> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27166#a27166
09:38:24 <soupdragon> > showIntAtBase (143*88) (head . show) 7 ""
09:38:25 <lambdabot>   "7"
09:38:32 <soupdragon> > showIntAtBase 7 (head . show) (143*88) ""
09:38:33 <lambdabot>   "51455"
09:39:09 <Saizan> b0fh_ua: i'd guess that you've two installations of process-1.0.1.2 and the one xmonad was built against is shadowed by the other
09:39:45 <b0fh_ua> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27167#a27167
09:39:49 <b0fh_ua> right, and how to fix that?
09:40:45 <Saizan> well, you can ghc-pkg unregister with either --global or --user, since most probably they are not in the same package db
09:40:59 <Saizan> but that'll break the packages built against that specific installation.
09:41:27 <benmachine> soupdragon:
09:41:33 <benmachine> :t (intToDigit, digitToInt)
09:41:34 <lambdabot> (Int -> Char, Char -> Int)
09:41:51 <b0fh_ua> Saizan: hmm
09:41:55 <b0fh_ua> and what I should do?
09:42:23 <soupdragon> thanks
09:42:27 <benmachine> b0fh_ua: if unregistering a package would break something, you will be warned
09:42:43 <benmachine> so I'd just try each unregister, find out which will break fewer things
09:42:59 <benmachine> then unregister that and reinstall all its dependencies >_>
09:43:00 <monochrom> I would erase, install afresh
09:43:02 <b0fh_ua> well, but I could reinstall it?
09:43:09 <b0fh_ua> remove, then install
09:43:41 <b0fh_ua> monochrom: erase what?
09:43:49 <monochrom> the whole ghc installation
09:44:03 <b0fh_ua> wow
09:44:11 <benmachine> heh
09:44:24 <c_wraith> honestly, reinstalling ghc isn't bad.
09:45:10 <monochrom> It is a very strong "would". I have never needed to. I have never had all these inconsistency conflict problems.
09:46:25 <monochrom> In fact the other day I tried to create such a problem and failed.
09:50:48 <yrlnry> Is there some Prelude function that I can use to abbreviate  (\d -> (d `mod` p) /= 0)  ?
09:51:10 <wjt> @pl f d = (d `mod` p) /= 0
09:51:10 <lambdabot> f = (0 /=) . (`mod` p)
09:51:26 <yrlnry> Oh, sure.  Thanks.
09:51:31 <wjt> huh, it knows to flip the arguments to /=
09:51:45 <yrlnry> Yeah, it knows which operators are commutative.
09:52:22 <dons> ?yow
09:52:23 <lambdabot> Couldn't find fortune file
09:52:32 <wjt> I'm surprised nothing defines divides, but I guess it's short enough...
09:52:46 <benmachine> technically /= doesn't have to be commutative
09:53:19 * benmachine wonders if there are any sensible cases in which it is not
09:53:40 <napping> technically, it does, if you respect the side conditions on Eq
09:53:41 <lambdabot> napping: You have 1 new message. '/msg lambdabot @messages' to read it.
09:53:48 <FunctorSalad_> yrlnry: huh?
09:53:55 <yrlnry> noncommutative /= would be like a Monad instance that fails to obey the monad laws.
09:53:58 <benmachine> napping: oh, true I suppose
09:54:10 <FunctorSalad_> even with rewrite rules, commutativity is problematic
09:54:23 <benmachine> I was wondering if strictness could be different
09:54:30 <yrlnry> FunctorSalad_: "it" here refers to @pl.
09:54:34 <benmachine> but that doesn't really make sense in this case
09:54:38 <FunctorSalad_> (will just loop unless you impose some ordering of expressions)
09:54:38 <yrlnry> Not "the universe".
09:54:49 <FunctorSalad_> ah! thought ghc =)
09:55:21 <zygoloid> @hoogle divides
09:55:22 <lambdabot> No results found
09:55:30 <FunctorSalad_> it could sneak commutativity in to a rewrite rule that *does* make the program shorter though
09:56:41 <napping> == will have to be strict on any type with more than one element
09:57:00 <yrlnry> Not so.
09:57:07 <napping> I guess it might be reasonable to cheat and define Eq for a partial equivalence relation, if you have use for one in your program
09:57:15 <yrlnry> a == b  = True
09:57:17 <benmachine> > Just undefined == Nothing
09:57:18 <lambdabot>   False
09:57:29 <benmachine> ^ *how* strict is a fair question
09:57:58 <Jafet> > let a == b = True in 0 == 1
09:58:00 <lambdabot>   True
09:58:01 <napping> oh hey, nan /= nan
09:58:03 <FunctorSalad_> hmm? 'strict' is f(_|_)=_|_
09:58:19 <napping> more than one equivalence class
09:58:45 <benmachine> FunctorSalad_: only constant functions don't have f _|_ = _|_, surely
09:58:55 <benmachine> well no that's not true
09:59:04 <benmachine> they could have f _|_ = [_|_] I guess
09:59:11 <c_wraith> or many other things.
09:59:31 <danderson> a type declaration merely declares an alias, correct?
09:59:33 <benmachine> well ok but they're all constant in the top-level constructor at least
09:59:37 <benmachine> danderson: correct
09:59:45 <danderson> So all type class instances of A should propagate to B in `type B = A` ?
09:59:47 <FunctorSalad_> benmachine: e.g. arguments to fix must have f(_|_)/=_|_
09:59:55 <c_wraith> benmachine, that much is true.
09:59:55 <FunctorSalad_> if you want something other than _|_ as a result
10:00:21 <FunctorSalad_> (since fix = sup_{n -> infinity} f^n (_|_))
10:00:41 <FunctorSalad_> this point includes implicit uses of fix :)
10:00:46 <danderson> specifically, in ghci -XOverloadedStrings, passing "foo" where ghci expects a Cookie, with type Cookie = ByteString, fails because there is no IsString instance for Cookie
10:00:52 <danderson> ... But there is one for ByteString.
10:00:59 <aristid> > fix (const 1)
10:01:00 <lambdabot>   1
10:01:06 <ClaudiusMaximus> hm, in my latest profile report, i get 10% of time/allocs from a record accessor for a strict field - how does that work?
10:01:08 <FunctorSalad_> btw that was "fix f" on the LHS
10:01:13 <danderson> hmm, no there isn't
10:01:16 <danderson> never mind...
10:01:26 <soupdragon> :t showIntAtBase
10:01:27 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
10:01:35 <Saizan> danderson: import ....Char8
10:01:45 <soupdragon> @let base base int = showIntAtBase base intToDigit int ""
10:01:46 <lambdabot>  Defined.
10:01:48 <soupdragon> > base 7 2341235
10:01:49 <lambdabot>   "25620521"
10:01:58 <soupdragon> how do you read an int at a base?
10:02:12 <FunctorSalad_> benmachine: surprised me too at first that this property which apparently loses so much detail should define the essence of the informal 'strictness' concept =)
10:02:21 <soupdragon> > base 7 (3*(4+5*7+1*7*7))
10:02:22 <lambdabot>   "525"
10:02:26 <soupdragon> > base 7 (6*(4+5*7+1*7*7))
10:02:27 <lambdabot>   "1353"
10:02:28 <soupdragon> > base 7 (1*(4+5*7+1*7*7))
10:02:29 <lambdabot>   "154"
10:02:49 <benmachine> soupdragon: you import Numeric, you type read<tab>, and then you search through the names until you find one that sounds likely :P
10:02:53 <benmachine> :t readInt
10:02:54 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
10:03:10 <soupdragon> > base 7 (6*4)
10:03:11 <lambdabot>   "33"
10:03:11 <soupdragon> > base 7 (6*5)
10:03:12 <zygoloid> soupdragon: if you want octal or binary or hexadecimal, add the right prefix then use read :)
10:03:13 <lambdabot>   "42"
10:03:30 <FunctorSalad_> (for any given function, it doesn't capture all the information... but you can usually recast functions about how lazy f is as questions about strictness in the technical sense, of another function)
10:03:35 <benmachine> > readInt 7 isDigit digitToInt "13"
10:03:35 <soupdragon> 3+3 = 4+2 = 6
10:03:36 <lambdabot>   [(10,"")]
10:03:43 <FunctorSalad_> *recast _questions_
10:03:48 <danderson> Saizan: ah, yes, cheers.
10:04:20 <FunctorSalad_> "strict in first argument" or whatever for a f :: (a,b) -> c function
10:04:47 <benmachine> FunctorSalad_: neat
10:04:51 * benmachine makes a note
10:08:06 <soupdragon> if 6*4 = 33 and 6*5 = 42... how come 6*45 isn't 354
10:08:20 <soupdragon> > base 7 $ 6*(4+5*7)
10:08:21 <lambdabot>   "453"
10:08:34 <soupdragon> > base 7 $ 6*(4+5*7+1*7*7)
10:08:35 <lambdabot>   "1353"
10:08:37 <FunctorSalad_> fix g where g f = \n -> if n==0 then 1 else f (n-1) -- out favourite recursive definition :D
10:09:03 <FunctorSalad_> g _|_ != _|_, or fix wouldn't work
10:09:05 <Jafet> FunctorSalad: surely you're fibbing
10:09:09 <FunctorSalad_> :)
10:09:14 <FunctorSalad_> s/out/our/
10:09:28 <soupdragon> > base 7 $ 5+5+2
10:09:29 <lambdabot>   "15"
10:09:32 <dmwit> soupdragon: 4 + 5 * 7 is not 45
10:09:53 <centrinia> > base 37 (37*36+1)
10:09:54 <lambdabot>   "*Exception: Char.intToDigit: not a digit 36
10:09:59 <centrinia> > base 37 (37*35+1)
10:10:00 <lambdabot>   "*Exception: Char.intToDigit: not a digit 35
10:10:17 <dmwit> > base 7 $ (6 * (4*7 + 5))
10:10:18 <lambdabot>   "402"
10:10:21 <centrinia> > base 37 (37*10+1)
10:10:22 <lambdabot>   "a1"
10:10:28 <benmachine> FunctorSalad_: mm, I never looked at it like that I guess
10:10:33 <FunctorSalad_> of course I fail at defining factorial, but that's so besides the point that nobody noticed ;)
10:10:39 <dmwit> soupdragon: Also, why would it be 354?
10:10:51 <dmwit> 330 + 42 /= 354 seems like a fine inequality to me
10:11:26 <lispy> :t base
10:11:27 <lambdabot> forall a. (Integral a) => a -> a -> String
10:11:28 <benmachine> > intToDigit 15
10:11:29 <lambdabot>   'f'
10:11:31 * benmachine shrugs
10:11:59 <lispy> > intToDigit 30
10:12:00 <lambdabot>   *Exception: Char.intToDigit: not a digit 30
10:12:10 <lispy> yay for partial functions
10:12:24 <benmachine> yaaay
10:13:45 <ddarius> lispy: You should stick only to types that are decidably isomorphic.
10:14:15 <ddarius> It would make the world a better place.
10:14:21 <FunctorSalad_> @let superDigit = (!!) (['0'..'9']++['a'..'z']++[max '9' 'z' ..]) 
10:14:22 <lambdabot>  Defined.
10:14:23 <lispy> Or use Maybe/Either/MonadError more often :)
10:14:25 <FunctorSalad_> :)
10:14:30 <FunctorSalad_> > superDigit 30
10:14:31 <lambdabot>   'u'
10:14:35 <soupdragon> @undef
10:14:38 <FunctorSalad_> noooo
10:14:44 <ddarius> lispy: Maybe requires energy in typical cases.
10:14:51 <soupdragon> do it again
10:14:58 <soupdragon> please
10:15:01 <FunctorSalad_> off by one error...
10:15:07 <FunctorSalad_> @let superDigit = (!!) (['0'..'9']++['a'..'z']++[1+max '9' 'z' ..]) 
10:15:07 <lambdabot>  <local>:1:44:
10:15:08 <lambdabot>      No instance for (Num Char)
10:15:08 <lambdabot>        arising from the litera...
10:15:08 <soupdragon> @let base base int = showIntAtBase base superDigit int ""
10:15:08 <lambdabot>  <local>:1:35: Not in scope: `superDigit'
10:15:10 <lispy> ddarius: My understanding of physics is that just about everything takes energy :)
10:15:13 <soupdragon> @undef
10:15:33 <FunctorSalad_> @let superDigit = (!!) (['0'..'9']++['a'..'z']++[succ(max '9' 'z') ..]) 
10:15:34 <lambdabot>  Defined.
10:15:36 <soupdragon> @let base base int = showIntAtBase base superDigit int ""
10:15:37 <lambdabot>  Defined.
10:15:59 <dmwit> > base 37 36
10:16:00 <lambdabot>   "{"
10:16:14 <dmwit> > max '9' 'z'
10:16:15 <lambdabot>   'z'
10:16:19 <ddarius> lispy: You are hurtling through space at ~30km/sec without using energy.
10:16:26 <aristid> succ('z')
10:16:28 <aristid> > succ('z')
10:16:29 <lambdabot>   '{'
10:16:30 <FunctorSalad_> hehe I just thought "this could be partially evaluated" too ;o
10:16:40 <aristid> > [succ('z')..]
10:16:40 <lambdabot>   "{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\1...
10:16:53 <Jafet> ddarius: since we protrude from the earth, we contribute to energy loss from tidal forces
10:17:00 <napping> FunctorSalad_: might it be?
10:17:05 <dmwit> ddarius: Nonsense, I'm hardly moving at all -- but accelerating a huge amount thanks to the gravity of the sun.
10:17:10 <Jafet> Er, potential loss
10:17:12 <FunctorSalad_> napping: in ghc? no idea
10:17:23 <ddarius> Jafet: Depends on where you are.
10:17:23 <FunctorSalad_> maybe through inlining and beta reduction?
10:17:48 <aristid> @let hyperDigit = (!!) (['0'..'9']++['a'..'z']++['A'..'Z']++repeat (error "screw you"))
10:17:49 <lambdabot>  Defined.
10:17:58 <napping> in particular, string constants can compile to fromCStringLen of a constant array
10:18:02 <FunctorSalad_> (apart from that people say it isn't very eager at partial evaluation)
10:18:25 <FunctorSalad_> aristid: that's not a good encoding :o
10:18:38 <FunctorSalad_> at least use unicode screwing
10:18:48 <ksf> someone care to upvote http://www.reddit.com/r/programming/comments/cn1xo/generalising_the_expression_problem_evolutivity/ ? I think it's been downvoted because some php-"coders" just plainly don't understand what it's about.
10:19:15 <ksf> (no I'm not karma-whoring)
10:19:16 <aristid> FunctorSalad_: hmm unicode has so many wonderful letters we could abuse for this!
10:19:31 <ksf> (I have enough)
10:19:36 <FunctorSalad_> even some ornamental copies of the latin alphabet IIRC
10:19:49 <lispy> ddarius: I'm using energy regardless of how fast I move through space
10:19:57 <lispy> ddarius: metabolic processes and all :)
10:20:09 <soupdragon> > base 7 $ 6*4
10:20:11 <lambdabot>   "33"
10:20:11 <soupdragon> > base 7 $ 6*5
10:20:12 <lambdabot>   "42"
10:20:33 <soupdragon> > base 7 $ 6*(4+5*7)
10:20:35 <lambdabot>   "453"
10:20:53 <soupdragon> > base 7 $ 6*(4+5*7+1*7*7)
10:20:54 <lambdabot>   "1353"
10:20:59 <FunctorSalad_> @let elite c = chr (ord 'á ' - ord 'd' + ord c)
10:21:00 <lambdabot>  Defined.
10:21:08 <soupdragon> > elite . "fwtapbwt awfunco"
10:21:09 <lambdabot>   "\5026\5043\5040\5021\5036\5022\5043\5040\4956\5021\5043\5026\5041\5034\502...
10:21:12 <FunctorSalad_> > elite <$> ['a' .. 'z']
10:21:13 <lambdabot>   "\5021\5022\5023\5024\5025\5026\5027\5028\5029\5030\5031\5032\5033\5034\503...
10:21:14 <FunctorSalad_> :(
10:21:44 <Jafet> > text $ elite . "etaoin shrdlu"
10:21:45 <lambdabot>   á¡á°áá«á¥áªáá¯á¤á®á á¨á±
10:21:53 <Jafet> Heh, I'm missing glyphs.
10:22:16 <FunctorSalad_> > text (elite <$> ['a' .. 'z'])
10:22:16 <lambdabot>   áááá á¡á¢á£á¤á¥á¦á§á¨á©áªá«á¬á­á®á¯á°á±á²á³á´áµ...
10:22:18 <sproingie> WOW
10:22:23 <FunctorSalad_> hmm, not quite what I thought
10:22:28 <sproingie> that caused gnome-term to pop up a modal dialog to install the font
10:22:33 <FunctorSalad_> ^^
10:22:39 <FunctorSalad_> try dejavu mono sans or so
10:22:41 <sproingie> always looking out for usability, those gnome folks
10:22:47 <sproingie> i am using that
10:22:58 <FunctorSalad_> hmm odd, it has the funny D at least
10:23:20 <sproingie> "hey no one will be annoyed when a dialog grabs focus in the middle of a terminal session because of arbitrary data the other end could send"
10:23:25 <eflister> is it possible to write Strategy (m b) -> Strategy (m [b])?
10:23:36 <FunctorSalad_> in xchat I'm using the nonmono though, which is missing 2 of jafet's and 3 of mine
10:23:45 <eflister> i think it's the same as (m b -> Eval (m b)) -> (m [b]) -> Eval (m [b]), right?
10:24:18 <soupdragon> I wish numbers were written the other way around
10:24:23 <aristid> @let megaDigits = filter ((&&) <$> not . isLower <*> isAlphaNum) [minBound..maxBound]
10:24:26 <lambdabot>  Defined.
10:24:30 <napping> ksf: what is this "evolutivity"?
10:24:32 <FunctorSalad_> sproingie: better than "moving the file to the trash can has finished" or so ;) to be fair, that was just an annoying notification, not a modal dialog (modal? wth...)
10:24:42 <aristid> @let take 100 $ megaDigits
10:24:42 <lambdabot>   Parse error: SemiColon
10:24:46 <aristid> > take 100 $ megaDigits
10:24:47 <lambdabot>   "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\178\179\185\188\189\190\192\193\194\1...
10:24:50 <napping> ksf: weak translation of evolvability?
10:24:54 <sproingie> FunctorSalad_: popping up a package dialog like that is basically a DOS attack
10:24:55 <aristid> > text $ take 100 $ megaDigits
10:24:56 <lambdabot>   0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÂ²Â³Â¹Â¼Â½Â¾ÃÃÃÃÃÃÃÃÃÃÃÃÃÃ...
10:25:02 <ksf> napping, the expression problem extended with maintainance
10:25:04 <sproingie> FunctorSalad_: tho at least it's not prompting me again
10:25:05 <FunctorSalad_> modal is for 'we will have to launch the missiles to have the program proceed. Yes/no'
10:25:09 <aristid> FunctorSalad_: better digits? :P
10:25:11 <Cale> > foldr (\x xs -> x + 10*xs) 0 [1,2,3]
10:25:12 <lambdabot>   321
10:25:19 <ksf> ...that is, not just extending by a data type or function, but also changing the implementation
10:25:24 <Cale> > foldl (\xs x -> x + 10*xs) 0 [1,2,3]
10:25:25 <lambdabot>   123
10:25:44 <napping> ksf: not good style to start the first paragraph with an undefined term
10:25:55 <ksf> heck it's a paper
10:25:59 <ksf> and I didn't write it.
10:26:18 <ksf> I will definitely think a bit more about titles the next time I submit to proggit, though.
10:26:20 <FunctorSalad_> aristid: hehe, no idea what exactly is 'alphaNum' in unicode...
10:26:37 <aristid> > length megaDigits
10:26:38 <ksf> ...as the audience can't even be expeted to know what say a dfa or fizzbuzz is.
10:26:39 <lambdabot>   93921
10:26:47 <aristid> FunctorSalad_: there are lots of them, that is for sure
10:26:54 <eflister> can anyone help me write Strategy (m b) -> Strategy (m [b])?
10:26:59 <napping> ksf: the first page of the paper uses the word a lot without defining it
10:27:29 <ksf> well, "to evolute" has a meaning, and it carries over.
10:27:34 <aristid> @hoogle m b -> m [b]
10:27:35 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
10:27:35 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
10:27:35 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
10:27:51 <aristid> eflister: do you want many or some? :>
10:28:01 <napping> ksf: indeed it does : http://en.wikipedia.org/wiki/Evolute
10:28:06 <FunctorSalad_> better known as 'evolve'? :p
10:28:11 <napping> but what does that have to do with software?
10:28:33 <eflister> aristid: hm, will that work?  do you know that Strategy (m b) = m b -> Eval (m b)?
10:28:55 <aristid> eflister: i don't know what Strategy is:)
10:29:01 <ksf> I'd take evolute to be a thing that you do to something, in contrast to natural selection evolving, which natural selection does to something.
10:29:02 <eflister> aristid: these are from Data.Parallel.Strategies
10:29:21 <aristid> :t fmap repeat
10:29:22 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f [a]
10:29:24 <ksf> napping, did you ever, ever, change code after it has been written?
10:29:51 <ksf> ...and possibly had to refactor the whole codebase not to go mad doing that?
10:30:00 <ksf> that's what the paper is about.
10:30:11 <eflister> aristid: so i think what we want is  (m b -> Eval (m b)) -> (m [b]) -> Eval (m [b])
10:30:31 <FunctorSalad_> > text (chr 2400)
10:30:32 <lambdabot>   Couldn't match expected type `GHC.Base.String'
10:30:32 <lambdabot>         against inferred typ...
10:30:38 <FunctorSalad_> > text (return$chr 2400)
10:30:39 <lambdabot>   à¥
10:30:55 <eflister> aristid: but i don't see how to get m [b] -> [m b], which i think would help
10:31:06 <eflister> aristid: sort of unsequence
10:31:08 <FunctorSalad_> > text (return$chr 0x2400)
10:31:08 <lambdabot>   â
10:31:08 <int80_h> there was a web page that described what to do in setting up a haskell software project. Now that I am actually looking for it, I cannot find it. Does anyone know which page I am talking about?
10:31:23 <aristid> eflister: oh, that is UNPOSSIBLE on general monads, i think
10:31:30 <FunctorSalad_> > text (chr <$> [ 0x2400 .. 0x2421])
10:31:31 <eflister> @hoogle m [b] -> [m b]
10:31:31 <lambdabot>   âââââââââââââââââââââââââ...
10:31:31 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
10:31:31 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:31:31 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:31:33 <FunctorSalad_> neat eh
10:31:42 <FunctorSalad_> elite control characters
10:32:09 <aristid> FunctorSalad_: i like how you use <$> instead of map :>
10:32:10 <soupdragon> oil drops in a bowl make an appolonian packing
10:32:13 <eflister> aristid: ah yeah, i had one working for traversables, but i am not in a traversable situation
10:32:19 <michael_1> hey that made me have to leave the channel!
10:32:22 <napping> ksf: I'm taking issue with the term. "Evolvability" seems to cover it
10:32:26 <FunctorSalad_> aristid: sometimes it saves a few characters
10:32:32 <FunctorSalad_> depending on surrounding precedence ;)
10:33:00 <napping> and "Evolute" has a standard meaning in geometry
10:33:01 <FunctorSalad_> foo bar <$> baz -- vs. fmap (foo bar) baz
10:33:05 <aristid> FunctorSalad_: also it looks so neatly symmetric
10:33:26 <ksf> napping, feel free to flame the paper's authors.
10:33:34 <FunctorSalad_> napping: which is that?
10:34:16 <napping> FunctorSalad_: locus of centers of curvature. The evolute of a circle is the center point, other things are funnier
10:34:55 <FunctorSalad_> ah
10:35:39 <soupdragon> huh what's this about circles??
10:35:47 <FunctorSalad_> guess it would be the passive? "make unrolled" vs "to unroll"
10:35:52 <napping> ksf: I suspect it's an issue of writing in a foreign language
10:35:58 <eflister> so apparently i am doing this wrong, but i am trying to write a parMapReduceM.  for the map part, i thought it would be as simple as (mapM mapF =<< xs) `using` parListM strat, where parListM :: Strategy (m b) -> Strategy (m [b]), but apparently parListM isn't possible -- what's the right way to do this?
10:36:08 <napping> it seems there is a french word Ã©volutivitÃ©. damn false cognates
10:36:34 <FunctorSalad_> oh? and that one is not from volvere?
10:37:39 <napping> well, translating that by "evolutivity"
10:38:50 <FunctorSalad_> istr there is some other example of mathematician babelfishing words to noun and back or similar to avoid running out of words ;)
10:38:55 <FunctorSalad_> can't remember what I mean
10:39:03 <FunctorSalad_> *...cians
10:39:47 <napping> I don't see how they will solve their problem without fancy tool support
10:40:04 <FunctorSalad_> to get unique names?
10:40:29 <eflister> anyone want to help with my Data.Parallel.Strategies question above?  :)
10:41:12 <FunctorSalad_> sorry, got slightly offtopic'ed away
10:41:43 <napping> eflister: just a type error?
10:41:57 <FunctorSalad_> @ty foldMap
10:41:58 <lambdabot> Not in scope: `foldMap'
10:42:02 <FunctorSalad_> @ty Fold.foldMap
10:42:02 <lambdabot> Couldn't find qualified module.
10:42:10 <napping> @ty mapF
10:42:11 <lambdabot> Not in scope: `mapF'
10:42:32 <FunctorSalad_> not sure if the instances of that one were parallel...
10:42:33 <eflister> napping: well i think my whole approach is wrong cuz it looks like parListM can only be written for traversables
10:42:35 <napping> anyway, the parallel bit should go on the list
10:42:41 <illissius`> ...anyone ever had a hang/freeze/deadlock/whatever in typeOf? o.o
10:42:42 <FunctorSalad_> but seems like a great function for it
10:42:48 * Saizan thinks parMapReduceM doesn't actually make sense if you're polymorphic in the monad
10:42:54 <napping> once you've got an IO action but together you can't look in it
10:43:06 <napping> mapM mapF =<< (xs `using` strat)
10:43:33 <napping> wait, that's not quite right either
10:43:43 <napping> do list <- xs; mapM mapF (list `using` strat)
10:43:54 <napping> that should evaluate the list in parallel
10:44:25 <napping> seeing as xs is an action already I don't think there are any fusion opportunities to lose
10:46:04 <FunctorSalad_> are the unicode char names in haskell somewhere?
10:46:35 <FunctorSalad_> illissius`: hmm it's a typeclass method, anything goes ;)
10:46:50 <FunctorSalad_> but shouldn't happen with auto-derived instances
10:46:55 <zygoloid> FunctorSalad_: unicode char names?
10:47:02 <napping> FunctorSalad_: try unicode-* on hackage?
10:47:11 <napping> unicode-name, unicode-properties
10:47:30 <FunctorSalad_> zygoloid: LATIN EXTREME CAPITAL LETTER A
10:47:30 <zygoloid> you mean like "MODIFIER LETTER SMALL U' (U+1D58)"
10:47:33 <illissius`> FunctorSalad_: yeah just autoderived instances that i know of
10:47:34 <FunctorSalad_> ;)
10:47:38 <zygoloid> haha yeah
10:47:45 <illissius`> think it might be something to do with HashTable which it uses internally
10:47:48 <illissius`> anyway, it's weird.
10:47:48 <zygoloid> "EXTREME CAPITAL"! nice
10:48:05 <napping> illissius`: it really shouldn't break in derived instances
10:48:05 <FunctorSalad_> napping: ah ok, not Data.Char then
10:48:08 * illissius` tries a sudden idea...
10:48:21 <illissius`> yeah probably I'm doing something dumb
10:48:50 <Phyx-> i have a weird problem, i've installed a version of SYB but cabal doesn't seem to find it and tries to install one of it's own and fails
10:48:56 <zygoloid> illissius`: it's a rarety since it's the only type class for which you can break type soundness if you define instances yourself
10:49:01 <eflister> napping: how come you're using mapM once you've unwrapped the xs?  to get inside Eval?
10:49:14 <napping> eflister: no idea, that's what your code seemed to be doing
10:49:29 <napping> you wanted to manufacture a list from xs, then mapM over it, but somehow force parallel evaluation of the list
10:49:48 * Phyx- predicts ghc 6.14 is gonna break ALOT of packages
10:49:58 <napping> of course, that only makes sense if xs is producing a lazy list in the first place - if xs is using mapM it will be fully evaluated anyway
10:50:02 <eflister> napping: but xs was already m [a] right?
10:50:02 <roconnor> oh man, I just realized that what "side" means in side-effects.
10:50:33 <idnar> roconnor: did they stab you in the side? :P
10:50:49 <eflister> napping: i just want to mapM over the xs, they already are a list, so i don't get what you mean by manufacture a list
10:50:54 <roconnor> side-effects are effects that occur along side evaluation.
10:51:28 <zygoloid> Phyx-: which changes in particular?
10:51:32 <napping> eflister: but if it
10:51:46 <roconnor> so Haskell has no side-effects at all (but of course we knew this). It has effects, but they are not side because they don't occur allong side evaluation.
10:51:47 <napping> eflister: if it's "m [a]" then you need to sequence it to get an "[a]" out
10:52:08 <roconnor> well, at least not in the same sense as along side.
10:52:23 <roconnor> It's so obvious
10:52:40 <zygoloid> haskell has front-effects
10:52:46 <roconnor> but it should help me explain how haskell "does IO" in the future to people.
10:52:50 <zygoloid> unsafePerformIO gives you side-effects.
10:53:02 <Phyx-> zygoloid: well, haven't really found any packages that won't install (if you don't count dependencies problems) but almost evry package throws alot of warnings 
10:53:03 <roconnor> zygoloid: yes, though it isn't in Haskell
10:53:07 <Phyx-> mostly on patterns
10:53:16 <Phyx-> and deprecation warnings
10:53:28 <roconnor> zygoloid: I guess we could use a cool name for Haskell kind of effects.
10:53:32 <zygoloid> Phyx-: i'm guessing... n+k patterns?
10:53:44 <roconnor> zygoloid: monadic-effects doesn't quite seem web 2.0 enough.
10:53:53 <zygoloid> effects 2.0?
10:54:03 <roconnor> better
10:54:13 <zygoloid> iFects?
10:54:22 <roconnor> better still
10:54:24 <eflister> napping: isn't sequence for [m a] -> m [a]?  i'm not getting it -- here's where i'm at (doesn't work) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27170
10:54:44 * BMeph wants to change the spelling of his nick to start with a LATIN EXTREME CAPITAL LETTER B! Raar! :D
10:55:09 <Phyx-> zygoloid: no, usually overlapping patterns, deprecated imports and warns on patterns like _ <- do ..
10:55:12 <Silvah> How does it look like, eh?
10:55:23 <Silvah> I mean the letter.
10:55:34 <Phyx-> ANyone know whow this can happen, ghci sees the packages, ghc-pkg also does
10:55:40 <Phyx-> but cabal and the ghc api don't
10:55:52 <zygoloid> Phyx-: cabal is running in global mode i guess
10:55:58 <roconnor> :O
10:56:08 <zygoloid> try adding --user and stirring vigorously
10:56:12 <Phyx-> zygoloid: no, my config writes to user, but shouldn't it check both?
10:56:55 <zygoloid> *shrug* you have exhausted my knowledge of cabal quirks
10:57:10 <Phyx-> when i try to install my lib it says
10:57:11 <Phyx-> $ cabal install --user
10:57:11 <Phyx-> Resolving dependencies...
10:57:13 <Phyx-> cabal.exe: cannot configure syb-0.2.1. It requires base >=4.0 && <4.3
10:57:21 <Phyx-> so ok, i unpack syb
10:57:26 <Phyx-> remove the upperbounds
10:57:28 <Phyx-> and install it
10:57:32 <monochrom> bad idea
10:57:51 <Phyx-> ghc-pkg shows it
10:57:59 <Phyx-> monochrom: don't really have a choice
10:57:59 <monochrom> but syb is supposed to come with ghc
10:58:09 <Phyx-> doesn't come with it anymore it seems like
10:58:23 <BMeph> roconnor: Haskell has REA - Rich Effect Applications! :D
10:58:35 <zygoloid> REA.net
10:58:53 <Saizan> Phyx-: are you using debian's GHC?
10:58:58 <BMeph> REA.haskell.org -- quick, reserve the name!
10:59:04 <Phyx-> monochrom: 60 patches ago it installed fine, don't think there are any breaking changes it uses.
10:59:11 <monochrom> I see, syb-0.1.0.2 comes with ghc 6.12.3, but you want 0.2.1.
10:59:13 <Phyx-> Saizan: no, just the current HEAD of ghc
10:59:47 <Phyx-> monochrom: and i'm using 6.13.20100702 for various reasons... primary of which a bug i needed was fixed
10:59:48 <eflister> Saizan: can you help me see why you think it doesn't make sense?  in my case, the map function is for downloading+processing a list of url's
11:00:25 <eflister> Saizan: so it seems to make as much sense as mapM to me?
11:00:29 <monochrom> I also misread. You removed <4.3 which is fine. I misread as removing >=4 which is bad.
11:00:47 <Saizan> if it built it built :)
11:00:49 <monochrom> I know some package that says base<10 :)
11:01:01 <Phyx-> it installs, and poking it in ghci shows it works
11:01:08 <Phyx-> but cabal still tries to install it
11:01:13 <FunctorSalad_> BMeph: "extreme" was just a quick idea to emphasize the angryness of unicode names... one could surely do better
11:01:18 <Phyx-> and that ofcourse fails due to the upperbound
11:01:35 <Phyx-> for some reason cabal doesn't see it
11:01:44 <Saizan> eflister: it can make sense for specific monads, not in general, also what you describe is not really parallel evaluation, it's more concurrent execution
11:02:15 <Saizan> Phyx-: use "--dry-run -v" it'll tell you why it wants to reinstall syb
11:02:37 <napping> eflister: your types are all wrong
11:02:59 <Saizan> eflister: you need to use forkIO and friends
11:03:06 <BMeph> FunctorSalad_: Aww, you mean there isn't really such a name, just your interpretation of the "back-to-the-60's" style of all-caps descriptions? Pity...
11:03:11 <lowasse1> When was the last time anyone compiled a large package with -fstrict-dicts and GHC didn't bomb?
11:03:21 <lowasse1> It's very depressing.
11:03:25 <eflister> Saizan: i'm interested to understand both a monad where it doesn't make sense and how to proceed for this problem :)  isn't parallel evaluation the same as concurrent execution in this case?
11:03:37 <nejucomo> I'm new to cabal and just tried "cabal install 'base == 4.2.0.2'" but it fails with "ghc-prim -any" and "integer-simple -any" and says no version of either is available.  Any ideas?
11:03:44 <Phyx-> Saizan: thanks, i'll take a look
11:03:45 <lowasse1> You don't reinstall base.
11:03:49 <cizra> Can I create a global IORef?
11:03:54 <eflister> Saizan: really?  i thought the idea of Data.Parallel was that for a situation like this managing your own threads could be abstracted
11:03:56 <lowasse1> cizra: Only if you're a bad person
11:04:01 <Saizan> nejucomo: you can't install base via cabal, you've to use the one that comes with ghc
11:04:05 <eflister> napping: can you be a little more specific?  :)
11:04:12 <monochrom> base comes with ghc. no way you can change it.
11:04:14 <lowasse1> okay, so parallelism and concurrency:
11:04:19 <nejucomo> So in order to get certain packages I need to upgrade ghc?
11:04:21 <Saizan> eflister: not for side-effecting computations
11:04:31 <Saizan> nejucomo: yes
11:04:35 <lowasse1> Control.Parallel just adds parallelism annotations to pure computations
11:04:50 <napping> eflister: does that code even typecheck?
11:05:06 <monochrom> there are usually older versions of your wanted packages that work with older ghc.
11:05:09 <lowasse1> it's only used to write programs exactly as if you weren't using any parallelism, except that you also give the program suggestions for how to exploit parallelism if it's available
11:05:09 <napping> it looks like you are trying to use mStrat on a [a] instead of b, for example
11:05:28 <eflister> napping: not with the do block instead of the commented out part
11:05:41 <napping> us should have type [a]
11:05:46 <eflister> napping: but it did witht he commented out part if i have a traversable parListM
11:05:53 <napping> mStrat is a Strategy b
11:05:59 <lowasse1> concurrency is when you have several different IO threads running at the same time and talking to each other, and it's in the IO monad, and impure
11:06:02 <FunctorSalad_> BMeph: didn't realize it was a 60s thing rather than release of "the f*cking fury"
11:06:03 <lowasse1> </rant>
11:06:11 <FunctorSalad_> (caps lock poster)
11:06:15 <napping> I agree with lowasse1 that this seems a bit confused
11:06:26 <FunctorSalad_> (we are family friendly, remember? ;))
11:06:38 <lowasse1> It's confused in the sense that people get confused, not in the sense that there isn't a clear distinction =P
11:06:46 <napping> Strategies are about structring evaluate of pure values
11:06:48 <lowasse1> it's just not a well-understood distinction
11:06:52 <lowasse1> napping: correct
11:07:00 <cizra> lowasse1: What's a good way to hold the state? Think strategy game with IORef [Unit]
11:07:06 <BMeph> FunctorSalad_: Heh-heh. I use a clip of the lifeguard version of those posters as my avatar in an online game... :)
11:07:12 <Phyx-> Saizan: doesn't seem to find it, http://phyx.pastebin.com/MLJC7rMi even though ghc-pkg dump shows it
11:07:29 <lowasse1> In that sort of thing, you're going to be using concurrency, 'cause it'll be IO stuff
11:07:46 <lowasse1> except that whenever you have multiple threads going, you shouldn't be using IORefs, you should be using MVars
11:07:48 <nejucomo> If I install a new ghc in /usr/local, will this break previously installed cabal packages?  (I used the âuser option.)
11:07:54 * Phyx- is profoundly confused
11:08:00 <Philonous1> cizra: You _could_ say something like myGlobalVariable = unsafePerformIO $ newIORef 0, but I strongly advise against it. It does usually work, but there is no guarantee that it will be reevaluated at some point. Also, global variables lead to incpmprehensible code. I'd much rather pass an IORef around
11:08:12 <dmwit> nejucomo: No, but you will need to install all those cabal packages again with your new GHC.
11:08:18 <lowasse1> nejucomo: Your system won't explode, and you'll have the old ghc running with the old cabal packages, and you'll have a new ghc with none of those cabal packages
11:08:25 <Philonous1> cizra: that it won't be reevaluated*
11:08:27 <nejucomo> Ok, thanks.
11:08:33 <lowasse1> You can have several GHCs installed at once without asplosions
11:08:33 <Saizan> Phyx-: ok, i see why, it's a quirk of the dependency solver, bump the version of syb in the cabal file before "cabal install"-ing it, then you'll have no problems
11:08:34 <nejucomo> cabal seems pretty awesome.
11:08:34 <cizra> Philonous1: Thanks
11:08:43 <monochrom> Phyx-: you can several versions of base? "all your base belongs to you"?
11:09:10 <Phyx-> Saizan: ah ok, thanks :) gonna try that
11:09:18 <Phyx-> monochrom: lol, i actualy only have 4.3 installed
11:09:26 <Phyx-> don't know why it considered the rest :P
11:09:27 <napping> eflister: strategies provide a strategy for evaluating pure values. Most things in monads produce more completely evaluated things. mapM for example probably produces a list which is at least fully evaluated down the spine
11:09:38 <Saizan> Phyx-: by "bumping" i mean appending a .1 btw :)
11:09:38 <Philonous1> cizra: You may also want to have a look at the StateT monad transformer
11:09:41 <eflister> lowasse1 and napping: why does parallelism have to be for pure values?  i'm fine working with threads/concurrency, but in this case they don't need to coordinate with each other at all, downloading each url can put its own IO Result in the list -- so it seems like a perfect opportunity to go to a higher abstraction
11:10:09 <Phyx-> Saizan: yeah, i figured :)
11:10:12 <lowasse1> eflister: that's concurrency, not parallelism, essentially
11:10:15 <Philonous1> cizra: Or you could have a ReaderT that holds an IORef
11:10:16 <napping> eflister: um, that's what Strategies does
11:10:22 <lowasse1> napping: false
11:10:31 <lowasse1> Control.Parallel/Strategies don't deal with IO
11:10:45 <cizra> Philonous1: Until recently I only felt comfortable around pure functional code.. This IO and state stuff is pretty scary to me right ow.
11:10:59 <napping> eflister: it only provides a plan for evaluating pure values, for making suggestions like "if you need to force this part of this lazy structure, it might be a good idea to evaluate this other part in parallel too"
11:11:02 <eflister> lowasse1: why is this concurrency?  i thought farming out downloads to happen in parallel was a classic example for when to use parallelism.
11:11:09 <Philonous1> cizra: Oh, StateT is pure, actually. 
11:11:26 <lowasse1> you can't use StateT with concurrency
11:11:34 <Phyx-> Saizan: yup, that did the trick, thanks Saizan :)
11:11:42 <lowasse1> at least, not without knowing *exactly* what you're doing =P
11:11:57 <lowasse1> eflister: "Downloads" aren't pure.
11:12:27 <eflister> lowasse1: i totally get that, what i don't get is why parallelism requires purity
11:12:33 * ezyang can never remember the offside rule for where blocks for do blocks 
11:12:40 <napping> eflister: there's "parallel" in general, with multiple processors and stuff
11:12:42 <Philonous1> cizra: Or rather, it is implemented as a set of pure functions, yet it emulates stateful computations. It's hard to tell the difference between pure and effectfull code these days
11:12:53 <Saizan> Phyx-: np :) 
11:12:53 <lowasse1> It's more that "impure parallelism" has a different name, "concurrency"
11:13:02 <lowasse1> and is done differently
11:13:22 <napping> eflister: and then there's a distinction between "parallelism" and "concurrency", where the first is about running a deterministic program faster, and the second is about writing stuff that's inherently parallel
11:13:43 <eflister> lowasse1: since the downloads don't have to interact, i don't get why in principle they are different here
11:13:44 <lowasse1> sure, if you have a [IO Foo], you can farm it out to several threads
11:13:56 <lowasse1> eflister: it's not about interaction, it's about IO and non-IO
11:14:08 <napping> an in particular, the Strategy stuff is only useful for the first case, and won't help at all for the second
11:14:22 <lowasse1> you got it switched =P
11:14:43 <lowasse1> Control.Parallel and Control.Parallel.Strategies are for non-IO, and don't work for IO stuff
11:14:47 <eflister> lowasse1: isn't the reason that the purity distinction is important is so that the parts can be broken up without worrying that they have mutual dependencies?
11:15:04 <napping> more or less
11:15:24 <lowasse1> Counterexample: suppose your downloads are from a website that maintains stateful information
11:15:38 <lowasse1> as far as Haskell is concerned, IO isn't to be trusted =P
11:15:48 <eflister> lowasse1: ok i got that, but i'm trying to understand why.  if you have [IO Foo] and they don't interact, why couldn't Control.Parallel or something like it evaluate them?
11:16:01 <lowasse1> oh, you could use Control.Concurrent to have several threads evaluate them
11:16:10 <lowasse1> it's just not exactly the same thing =P
11:16:20 <eflister> lowasse1: aren't i asserting that that isn't the case by doing it this way?  (the stateful server example)
11:16:23 <napping> eflister: It's certainly possible to write useful combinators for that sort of thing, it's just that Strategy is not that library
11:16:47 <lowasse1> eflister: no, because as far as Haskell is concerned, anything in IO is untrustworthy, period
11:17:00 <lowasse1> hold on just a sec
11:17:08 <eflister> lowasse1: i know i can do it with Control.Concurrent and have written plenty of code with it, in this case i thought it was a great opportunity to learn Data.Parallel
11:17:27 <Saizan> the parallel package is only for parallel evaluation of pure expressions, no more no less.
11:18:19 <eflister> Saizan: everyone keeps saying that but i'm asking why monadic values that i assert don't interact can't be treated as 'pure' for purposes of spreading them across processors automatically
11:18:38 <lowasse1> okay, here's a reason:
11:18:59 <lowasse1> pretty much the *definition* of a monad is that it defines how to *sequence* operations
11:19:14 <Saizan> eflister: well, first because it's an hard to check side-condition and so that would be avoided for a reason of style
11:19:15 <lowasse1> that's the whole point of (>>=)
11:19:27 <voker57> Is there a way to get fields' names of a record type as Strings?
11:19:47 <Saizan> eflister: second because it would be hard to implement it for monads in general
11:19:53 <lowasse1> you couldn't use any kind of parallelism to get from [State s a] -> State s [a]
11:19:53 <aavogt> voker57: using template haskell
11:20:05 <lowasse1> Saizan: in fact, it's genuinely impossible
11:20:06 <eflister> lowasse1: each download is one entry in the [IO Foo] -- they are there own independent "sequences" and never have =<< applied betwixt them
11:20:27 <lowasse1> okay, I'm going to argue that you can't do it for *general* monads
11:20:43 <lowasse1> or, I just did
11:20:53 <napping> eflister: Strategies pretty much just "seq"s values in lots of threads
11:21:00 <lowasse1> do you see why you couldn't use any kind of parallelism to get from [State s a] to State s [a]
11:21:06 <aavogt> voker57: look at the output of      reify 'ConstructorName   or   reify ''TypeName
11:21:09 <lowasse1> not really
11:21:13 <napping> so you can't use it for IO without something ugly like unsafePerformIO
11:21:33 <lowasse1> no, that's not the lesson to take =P
11:21:41 <lowasse1> the lesson to take is to use concurrency for parallelizing IOish things
11:22:15 <Saizan> eflister: for example, for [State Foo] it'd make sense only if those computations never do any put, so you can actually convert that to [Foo] easily and evaluate that list in parallel, but only because you know about State and this side condition on the actions
11:22:40 <lowasse1> well, in that case, you wouldn't be using State in the first place
11:22:52 <napping> eflister: also, internally the runtime has a lot of fancy stuff to make sure referring to unevaluated pure values in different threads is safe
11:23:08 <lowasse1> if you use State, then you're telling the compiler that there is State-ish stuff going on
11:23:16 <BMeph> eflister: Your guarantee on non-interaction is only valid for you; it isn't valid for the values themselves. :)
11:23:27 <BMeph> guarantee *of
11:23:48 <lowasse1> Working in the IO monad accepts the abilities and limitations on the IO monad
11:24:05 <napping> eflister: which means a library that just handles pure stuff can be much simpler than one that needs to fork threads and make synchronization variables to get results back, and that sort of thing
11:24:11 <lowasse1> one of those limitations is that you can't use Control.Parallel, you need to use Control.Concurrent
11:24:19 <Saizan> essentially, parallel makes use of an already present guarantee, rather than asking a promise from the user
11:24:30 <lowasse1> that's a good way of putting it
11:26:15 <napping> eflister: try something like parMapM fun list = mapM takeMVar =<< mapM (\x -> do v <- newEmptyMVar; forkIO (f x >>= putMVar v)) list
11:26:18 <eflister> Saizan: ok, i think the [State Foo] example helps -- am i essentially asking to create a bunch of RealWorlds and there's no way to combine them back together at the end?  does this explain why i seemed to be able to write it for Traversables?  Traversables say how to sequence the states back together?
11:26:57 <Trevion> Hey.. does anyone know of packages/blog posts/etc. that discuss handling callbacks with lazy IO?
11:27:12 <lowasse1> eflister: The way you create a bunch of RealWorlds and combine them back together is to use Control.Concurrent, essentially =P
11:27:14 <Saizan> eflister: using par with IO actions make little sense simply because the side-effects won't be performed
11:27:45 <aristid> :t par
11:27:45 <lambdabot> forall a b. a -> b -> b
11:27:47 <lowasse1> yeah, using par with IO actions doesn't compute the values faster, it just computes the RealWorld -> (a, RealWorld) *function* faster
11:27:48 <Saizan> eflister: just like you can use it with "State Foo" but you'll end up only evaluating the action, not actually transforming the state
11:27:59 <lowasse1> which is rarely the bottleneck =P
11:28:49 <eflister> napping: thx, using Control.Concurrent isn't confusing for me, i just thought this was a good chance to learn Control.Parallel
11:28:55 <Saizan> you can surely write a parMapIO :: [IO a] -> IO [a] though, wiht napping's code above
11:29:23 <napping> eflister: yeah, you'll have to find some pure code to try out strategies
11:29:34 <jmcarthur> pay with unsafePerformIO, however...
11:29:36 <jmcarthur> *par
11:30:02 <jmcarthur> not reliable, but would actually run the action *if* it runs
11:30:18 <Saizan> guess so :)
11:30:46 <eflister> Saizan: what is an 'action' in the State monad?  i would have thought it *was* transforming the state.
11:30:55 <Saizan> ?src State
11:30:56 <lambdabot> Source not found.
11:30:56 <lowasse1> it's the function s -> (a, s)
11:31:15 <lowasse1> as opposed to a value of type a
11:31:31 <eflister> lowasse1: so it figures out how it would transform the state but doesn't actually do it?
11:31:35 <Saizan> eflister: a value of type State a is just a function of type "s -> (a, s)" wrapped in State's constructor
11:31:36 <lowasse1> yup
11:31:54 <jmcarthur> exactly. runState is the only function that actually does anything with the state concretely
11:32:02 <jmcarthur> well, or runStateT or other variants
11:32:16 <Saizan> i.e. it just applies the function to a supplied initial state
11:34:24 <Saizan> the good old distinction between "evaluation" and "execution" might be the central concept to grasp for working properly with monads
11:35:10 <lowasse1> that's actually pretty accurate
11:35:18 <FunctorSalad_> not just with IO?
11:35:44 <Saizan> no, we've just seen it in action for State
11:36:08 <FunctorSalad_> I still think of State as well inside the sheltered world of well-defined semantics ;)
11:36:12 <Saizan> (execution is parameterized by the monad :)
11:36:19 <FunctorSalad_> which doesn't contradict 'execution', granted
11:36:46 <lowasse1> I mean, most nontrivial examples of monads are actually wrappers around functions
11:36:52 <lispy> ?faq Can Haskell do everything Rust will do?
11:36:52 <lambdabot> The answer is: Yes! Haskell can do that.
11:37:30 <Saizan> (Rust?)
11:37:40 <lispy> http://wiki.github.com/graydon/rust/language-faq
11:37:54 <lowasse1> and figuring out that m a isn't the same thing as a value of type a, and possibly hasn't evaluated any values of type a at all, is pretty crucial
11:38:14 <FunctorSalad_> yeah, but 'Maybe' demonstrates that already :)
11:38:22 <FunctorSalad_> not that I'm really arguing against you...
11:38:38 <FunctorSalad_> I just thought the 'eval vs exec' story was to explain IO
11:38:43 <napping> lispy: explicit memory layout control is nice
11:38:47 <FunctorSalad_> no real disagreement
11:38:55 <napping> lispy: hacking up that and typestate will get realy ugly
11:39:35 <eflister> i have not ever felt that the words action/execution help me think about monads
11:40:12 <lowasse1> I mean, it's more in the sense of "what does it mean when you treat State s a as a value?  it doesn't mean the same thing as a value of type a"
11:41:24 <Trevion> napping: there's been work on explicit memory layout in Haskell-like languages: http://web.cecs.pdx.edu/~mpj/pubs/bytedata.pdf for instance.
11:41:43 <tommd> And there is more work going on all the time.
11:41:50 <napping> yes, and it takes a good bit of ugly type-level stuff
11:42:43 <napping> being able to have similar control while still exposing apparently ordinary data types would be nice
11:42:51 <tommd> Memory areas are actually rather pretty imo.
11:43:04 <Saizan> FunctorSalad_: eval vs. exec is the same thing as considering "m a" as a value or considering it as code for some other abstract machine, you can do that with every monad
11:43:21 <Saizan> FunctorSalad_: also, original vs. kliesli category
11:43:46 <Tomsik_> I think of monads as of boxes that you can put various types in
11:43:49 <FunctorSalad_> fair enough, that's one way of looking at general monads
11:43:51 <Tomsik_> and there's bind for getting them out
11:44:35 <lowasse1> I think of monads as a functor from a category to itself together with two natural transformations =D
11:44:42 <FunctorSalad_> they're also like free algebras and like words such as "possibly" or "many" ;)
11:45:22 <eflister> one can easily understand that m (a -> b) is not (a -> b) and may not have evaluated (a -> b) and that some f :: (m (a -> b)) -> c does something without using words like action
11:45:24 <FunctorSalad_> ("many" being the list monad... at least if you're parsec-brainwashed enough to consider "0" many)
11:45:28 <FunctorSalad_> ;)
11:46:37 <Tomsik_> FunctorSalad_: can you think a better word for '*'? :p
11:46:40 <FunctorSalad_> (free algebras of some fixed signature and variable name set (represented as a type) `a', with substitution being >>= ...
11:46:46 <FunctorSalad_> Tomsik_: :)
11:46:57 <FunctorSalad_> "any number of"... not exactly a word
11:47:03 <Saizan> eflister: sure, the names are not important
11:47:08 <Trevion> tommd: Anything new public yet?
11:47:26 <tommd> Trevion: Yes, see the Habit language definition by Jones.
11:47:37 <FunctorSalad_> 'howeverManyYouLike' ;)
11:47:46 <eflister> i can never get straight if "pure" means "no IO" or "no monads".  seems like people sometimes refer to, for instance, State code as "pure", and sometimes as "impure"
11:47:47 <tommd> Trevion: Habit is the HASP groups idea of Haskell for systems programming.
11:47:57 <tommd> http://www.google.com/url?sa=t&source=web&cd=1&ved=0CBIQFjAA&url=http%3A%2F%2Fwww.latrobe.edu.au%2Flinguistics%2Fstaff%2FData%2FLaPolla%2FPublicationItems%2FUnpublished%2Fhabit.pdf&ei=Px02TL_6LpHSsAP2pJTTAQ&usg=AFQjCNF63-D21Grrm1UBLuL9RQJpRQuzYQ&sig2=J6awTqtqiZOkzqVI7U3cLg
11:48:02 <monochrom> data NotHere a = NotHere; instance Monad NotHere where return x = NotHere; NotHere >>= f = NotHere.
11:48:04 <tommd> oops
11:48:12 <mauke> eflister: functions form a monad; it's kind of hard to do without
11:48:12 <tommd> ignore that one - google failed me then I failed.
11:48:24 <Saizan> eflister: yeah, it can mean one or the other depending on context
11:48:36 <tommd> http://hasp.cs.pdx.edu/habit-report-Aug2009.pdf
11:48:53 <tommd> Trevion: ^^ That is an old version but the concepts are all the same.
11:48:56 <Saizan> (and the context is very much related to the distinction i hinted at above)
11:49:22 <FunctorSalad_> I wouldn't call monadic code impure as long as there's no IO hidden inside
11:49:23 <Saizan> maybe s/context/perspective/g
11:49:27 <Trevion> tommd: Thanks, I'll check it out!
11:49:37 <FunctorSalad_> that's be against the 'monads are just an interface' doctrine
11:49:41 <FunctorSalad_> *that'd
11:49:45 <napping> eflister: that comes from the base and kleisli views
11:50:09 <FunctorSalad_> ST is borderline...
11:50:10 <napping> eflister: If you are thinking of haskell functions, whether something uses State inside doesn't matter
11:50:11 <Saizan> FunctorSalad_: that's quite rare, it's much more common to mean non-monadic and say pure though :)
11:50:39 <FunctorSalad_> Saizan: which 'that'?
11:50:45 <napping> but if you are thinking in terms of the Kleisli category, then the results from x <- get depends on whether you've done "modify (+1)" before
11:50:50 <FunctorSalad_> confused by negations ;)
11:51:51 <voker57> Can't I get list of record fields without using TH?
11:52:04 <FunctorSalad_> (simple referent question, not understanding)
11:52:23 <Saizan> FunctorSalad_: that=calling monadic code impure
11:52:40 <FunctorSalad_> ok
11:52:45 <eflister> is it interesting that i can write parListM :: (Traversable m) => Strategy b -> Strategy (m [b]) ?
11:53:21 <BMeph> Are there any Random monads based in ST, vice IO?
11:53:32 <lowasse1> BMeph: Nope, and for good reason
11:53:41 <lowasse1> namely, that runST m is supposed to be deterministic ;)
11:53:53 <eflister> is this the same as telling Control.Parallel how to "put all the states back together again"?
11:53:56 <lowasse1> eflister: thinking...
11:53:57 <monochrom> there is not.
11:54:19 <eflister> parListM x y = sequenceA (sequence . map (Par . (`using` x)) <$> y)
11:54:20 <Saizan> eflister: "State s" is not a Traversable, nor is IO
11:54:20 <lowasse1> eflister: nope, not the same thing
11:54:23 <ezyang> I canât write a Storable instance for a C struct that uses the foo[0] idiom, correct? 
11:54:33 <lowasse1> <--- Saizan got it
11:54:41 <napping> BMeph: I suppose you could do StateT (STVar s StdGen) (ST s)
11:54:43 <ezyang> because thereâs no reasonable sizeOf declaration 
11:54:48 <Saizan> BMeph: there's a mwc-random that requires an initial seed
11:54:51 <mauke> ezyang: right
11:54:53 <FunctorSalad_> BMeph: IIRC monte-carlo uses IO to achieve high speeds but doesn't leak the IO
11:54:55 <FunctorSalad_> I might be off
11:55:19 <lowasse1> BMeph: just do this:
11:55:49 <lowasse1> http://hackage.haskell.org/packages/archive/MonadRandom/0.1.5/doc/html/Control-Monad-Random.html
11:56:13 <lowasse1> and runRand m (mkStdGen {- some fixed seed -})
11:56:27 <FunctorSalad_> BMeph: nevermind, apparently it's a pure state monad, only the 'run' function uses unsafePerformIO to make a seed
11:57:20 <ezyang> Although, I /do/ think I want to be able to peek, so maybe I'll just write a peekStruct function 
11:57:31 <monochrom> "Computes the storage requirements (in bytes) of the argument. The value of the argument is not used." The 2nd sentence kills variable-size storables. Someone will give you "undefined" and you will be hosed if you try to determine size from value.
11:58:06 <eflister> Saizan: i know, but i'm wondering if one could write a traversable instance for state -- does traversable basically mean "there will be some way to sequence these things"
11:58:28 <McManiaC> hm
11:58:43 <FunctorSalad_> let's make Printf-TH part of the language as an operator *runs*
11:59:03 <McManiaC> main = do forkSomeThread; forever (return ()) -- needs 100% cpu - is there a way to "wait" without doing anything?
11:59:23 <FunctorSalad_> come on, it's better than "..."++show...++"..." ;)
12:00:06 <FunctorSalad_> Printf-TH is fine as is except I still have to type so much
12:00:17 <monochrom> funny thing: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/Cabal-1.8.0.4/Distribution-System.html#v%3AVax
12:00:27 <Saizan> eflister: Traversable t => t a sort of means that you can actually take values of type 'a' out of the 't a' without any external aid, to take a value of type 'a' out of 'State s a' you need a value of type 's'
12:00:35 <monochrom> one day haskell and cabal will run on vax!
12:00:38 <FunctorSalad_> th pragma + import + $(printf "...")
12:00:49 <FunctorSalad_> maybe I should make a preproc :p
12:01:33 <eflister> or maybe, does traversable identify those monads that will work well with Control.Parallel?
12:02:10 <Saizan> a type constructor t isn't required to be a Monad to be a Traversable
12:02:38 <eflister> but are the traversable monads good to go for Control.Parallel
12:03:00 <eflister> Reader for instance should be ok right?
12:03:07 <Saizan> well, sort of yes, since you've toList
12:03:20 <napping> Monad has nothing to do with it. The important thing about Traversable is that's is possible for pure code to extract a list of the values of type a
12:03:21 <Saizan> Reader won't
12:03:35 <napping> and apply some stragegy for forcing them
12:03:46 <FunctorSalad_> btw is haskell-src-exts robust for writing a preprocessor?
12:04:00 <eflister> doesn't "extract" mean that monad does have something to do with it?
12:04:07 <eflister> well, functor i guess
12:04:08 <Saizan> eflister: well, "Reader r" won't be a Traversable, but would be quite easy to make it work with Control.Parallel
12:04:11 <FunctorSalad_> or will you get annoying failures because it treats some corner cases different than ghc...
12:04:44 <Saizan> eflister: Functor is much more general than Monad
12:05:47 <McManiaC> main = forever (return ()) -- takes up 100% cpu, is there a way to just do "nothing"?
12:06:10 <chrisdone> is there a Monad m => m a -> m () knocking about in a libr somewhere?
12:06:13 <dmwit> main = forever (threadDelay 100000) -- a little better
12:06:41 <dmwit> main = forever getChar -- another way to block for a while
12:06:53 <McManiaC> hm :S
12:07:20 <dmwit> Give us a little more context, maybe.
12:07:27 <dmwit> (sounds like an XYZ problem)
12:07:39 <monochrom> there is usually no need to do nothing. if you are waiting for someone, wait for it for real.
12:07:43 <napping> chrisdone: just to ignore a result?
12:08:02 <dmwit> chrisdone: No. =/
12:08:08 <dmwit> chrisdone: There's one in my personal library. =)
12:08:16 <dmwit> ignore x = x >> return ()
12:08:29 <monochrom> sml also has ignore :)
12:08:45 <Philonous1> procrastinate :: IO a -> Maybe (Tomorrow (IO a))
12:08:53 <lowasse1> lol
12:09:17 <chrisdone> dmwit: yeah
12:10:04 <chrisdone> dmwit: maybe it'll appear in Control.Monad someday like `forever' did
12:10:16 <FunctorSalad_> Philonous1++
12:10:48 <FunctorSalad_> even encodes how deferring it doesn't require any execution *now*
12:11:06 <chrisdone> Philonous1: that's a good stereophonics song
12:13:17 <mreh> their ex drummer died
12:20:38 <idnar> haha
12:23:32 <benmachine> chrisdone: I believe it's planned; in the meantime, see (<$)
12:23:38 <benmachine> :t (() <$)
12:23:40 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
12:24:08 <tommd> ezyang++
12:24:13 <tommd> groom rocks!
12:25:16 <Ferdirand> am I the only one bothered by the fact that we cannot write: Î£ = sum ?
12:25:34 <benmachine> yes
12:25:39 <benmachine> I asked everyone else
12:25:42 <benmachine> they're all okay with it
12:25:48 <Ferdirand> oh good
12:25:49 <Ferdirand> thanks
12:26:25 <chrisdone> how awesome would a code golf game be for lambdabot?
12:26:39 <FunctorSalad_> sigma is an operator char?
12:26:59 <Ferdirand> well, it is a capital sigma
12:27:05 <chrisdone> Ferdirand: but you can use (a Î£)
12:27:44 <Ferdirand> chrisdone: not sure I understand that...
12:27:59 <rfh> how can i define takeWhile with foldr?
12:28:07 <FunctorSalad_> U+03A3 GREEK CAPITAL LETTER SIGMA
12:28:07 <FunctorSalad_> Category: Lu (Letter, Uppercase)
12:28:14 <chrisdone> rfh: sounds like homework!
12:28:18 <FunctorSalad_> is the category what matters?
12:28:24 <Ferdirand> use Î£ as a constructor of a dummy type, and do the smart work in a ?
12:28:29 <FunctorSalad_> Ferdirand: oh right, capital
12:28:30 <soupdragon> Ferdirand: just write  sigma = sum
12:28:34 <chrisdone> > let (Î£) a = sum a in ([1..5] Î£)
12:28:34 <lambdabot>   <no location info>: Parse error in pattern
12:28:38 <chrisdone> i can't remember the syntax
12:28:40 <rfh> chrisdone: in self-study everything is homework.
12:28:46 <FunctorSalad_> there's a Sum unicode char too
12:28:47 <chrisdone> > let Î£ a = sum a in ([1..5] Î£)
12:28:48 <lambdabot>   Not in scope: data constructor `Î£'Not in scope: data constructor `Î£'
12:28:54 <FunctorSalad_> (which looks like capital sigma)
12:28:57 <chrisdone> bah  it's uppe rcase
12:29:12 <soupdragon> rfh, foldr cons nil [a,b,c,d,e,f] = cons a (cons b (cons ... nil))
12:29:38 <soupdragon> rfh, so if you want to define takeWhile, the property of 'cons' should be what ?
12:29:40 <chrisdone> rfh: what part of "how do i define x" is self-study lol
12:30:02 <monochrom> "i" is self, "how" is study
12:30:12 <soupdragon> chrisdone, I think he needs to see the methodological framework to derive programs in
12:30:30 <chrisdone> type driven programming, mm
12:30:36 <rfh> soupdragon: associative to the left?
12:30:58 <chrisdone> start from the types
12:31:01 <soupdragon> rfh, no forget about associativity - what I am saying is that it just replaces all the (:) constructors with cons and [] with nil
12:31:01 <chrisdone> :t foldr
12:31:02 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:31:36 <soupdragon> if the list is  1 : 2 : 3 : []  then  foldr cons nil will gives  1 `cons` (2 `cons` (3 `cons` nil))
12:31:39 <rfh> soupdragon: yeah
12:31:52 <monochrom> I don't know how to write takeWhile with foldr
12:31:59 <napping> Ferdirand: have you tried Agda?
12:32:03 <soupdragon> if you let cons = (:) and nil = [] it will be the identity function
12:32:05 <FunctorSalad_> ;  u+1d6ba math bold capital sigma u+1d6d3 math bold small final sigma u+1d6d4 math bold small sigma u+1d6f4 math italic capital sigma u+1d70d math italic small final sigma u+1d70e math italic small sigma u+1d72e math bold italic capital sigma u+1d747 math bold italic small final sigma u+1d748 math bold italic small sigma u+1d768 math sans-serif bold capital sigma
12:32:15 <rfh> foldr f x:xs...
12:32:17 <Ferdirand> napping: no, just vaguely heard of it here
12:32:18 <FunctorSalad_> hope that isn't too spammy... already abbreviated MATHEMATICAL for you ;)
12:32:23 <Ferdirand> if "heard" is the correct term
12:32:33 <napping> you can use unicode characters and define infix operators
12:32:39 <FunctorSalad_> so, there's a bit more than "a" special-purpose math sigma ;)
12:32:49 <napping> like, if_then_else_ True t e = t; if_then_else_ False t e = e
12:33:10 <rfh> soupdragon: but foldr applies functions first to the last elements, does it not?
12:33:46 <rfh> not apply, but evaluate
12:33:53 <soupdragon> rfh, there is no ordering: Think of it like whipping a tablecloth out from under a set table
12:34:22 <FunctorSalad_> (what's a "final sigma"?)
12:34:29 <napping> it seems to be rather powerful for the implementation complexity, compared to a full-blown extensible grammar like Coq
12:34:37 <soupdragon> FunctorSalad_: it's the final count up ! duun dun dun dun
12:34:39 <rfh> but parentheses would suggest that the innermost expression will be evaluated first
12:34:50 <FunctorSalad_> soupdragon: hahaha that was my thought too
12:34:53 <soupdragon> rfh: no that's not related at all
12:35:01 <FunctorSalad_> (without the extra "up" pun)
12:35:02 <soupdragon> rfh: you need to free yourself of these ideas
12:35:03 <rfh> soupdragon: k
12:35:11 <andreo> I have two functions: f1 :: IO (Maybe Int) and f2 :: IO (Maybe Int)
12:35:15 <andreo> I need the f2 to be executed if f1 rethrns Nothing.
12:35:20 <andreo> This expression 'r <- f1 `mplus` f2' doesn't do what I want. How should I write the expression?
12:36:20 <Ferdirand> final sigma would be the special glyph required for sigmas at the end of a word, I guess
12:36:29 <chrisdone> this would make a good code golf question on lambdabot
12:36:41 <monochrom> rfh: http://cale.yi.org/index.php/Fold_Diagrams shows what foldr really does. also do not think in terms of what is evaluated first; think in terms of what is the final result
12:37:12 <FunctorSalad_> Ferdirand: aw :( so, nothing epic
12:37:26 <Ferdirand> anyhow, it's not something critical, just a small annoyance. I was expecting a prettier solution than just #define Î£ sum 
12:37:30 <Ferdirand> if that is even possible
12:37:36 <dafis> andreo: f1 >>= \mi -> case mi of { Nothing -> f2; _ -> return mi }
12:37:58 <FunctorSalad_> Ferdirand: you might want to keep your code ascii and extend your editor's pretty-rendering-table if it exists
12:38:09 <FunctorSalad_> (like in haskell-mode for emacs)
12:38:19 <Ferdirand> FunctorSalad_: a sound suggestion. I use vim and I have no clue if that exists
12:38:19 <FunctorSalad_> there's likely something for vim...
12:38:25 <rfh> monochrom: yes thank you, i saw those diagramms before, think i know what foldr,foldl do, but have my problems to define takeWhile with foldr. (is an exercise from richard bird's intro to FP with haskell)
12:38:33 <FunctorSalad_> Ferdirand: I'd like to know too actually ;)
12:39:05 <soupdragon> rfh, here's my solution http://pastie.org/1036468.txt
12:39:06 <Cale> Ferdirand: Î£ is uppercase, so it should be the name of a data constructor
12:39:11 <monochrom> note that f has the liberty to unuse some of its parameters. this is why "evaluated first" is harmful.
12:40:07 <monochrom> > const "OK!" (1 `div` 0)
12:40:08 <lambdabot>   "OK!"
12:40:10 <rfh> soupdragon: quick coder you are.
12:40:21 <dafis> rfh: if takeWhile p == foldr fun start; obviously start must be [], because takeWhile _ [] is [], now, what should fun x ys do if a) p x holds, b) p x doesn't hold?
12:40:22 <monochrom> things in parentheses are not evaluated first.
12:40:50 <monochrom> parentheses encode the parse tree only.
12:40:57 <soupdragon> it's only in lisp that the things in parens get evaluated first
12:41:42 <rfh> well like in x1:(x2:(x3:[]))), x3 well be first applied to []
12:41:49 <soupdragon> no bube
12:41:51 <soupdragon> dude
12:41:56 <rfh> ^^
12:42:08 <Ferdirand> Cale: so, what would you recommend to let Î£ be a constructor but behave like a sum ? in a not-too-intrusive way ?
12:42:11 <rfh> got that now
12:42:13 <soupdragon> time just complicates things
12:42:25 <monochrom> in kids' school they say "parentheses evaluated first" because it's for kids, simplified story.
12:42:27 <soupdragon> rfh, just let time away for now it makes everything harder
12:42:52 <Ferdirand> (use some invisible character to act as an evaluation function... sounds dreadful :p)
12:43:06 <b0fh_ua> Hello! Can somebody please help me in resolving the problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27173#a27173 ?
12:43:06 <rfh> indeed (moreover, does it exist at all^^)
12:43:12 <soupdragon> hehe
12:43:24 <b0fh_ua> I don't understand what's going on and how to fix this problem
12:43:40 <b0fh_ua> curl package is installed - but for some reason it can't be used
12:44:02 <napping> try reinstalling it
12:44:04 <b0fh_ua> ghc-pkg check doesn't produce any output
12:44:34 <napping> do you have the cabal program?
12:44:43 <b0fh_ua> sure
12:44:49 <napping> try cabal install curl
12:44:56 <b0fh_ua> i did that
12:45:09 <b0fh_ua> same result
12:45:25 <b0fh_ua> package curl-1.3.5-3aafbb743d5287ee910bbcc23315b5f7 is unusable due to missing or recursive dependencies:
12:45:32 <dafis> b0fh_ua, I think line 8 may have something to do with it
12:45:38 <monochrom> you have many containers-0.3.0.0 ??!!
12:45:54 <monochrom> package containers-0.3.0.0-339506fe3cdbf89bbfb2d85bb3085ace is shadowed by package containers-0.3.0.0-409fe3b8f0dda25b98e03716d26be411
12:45:55 <b0fh_ua> dafis: hmm, makes sense
12:46:09 <b0fh_ua> and what should I do?
12:46:13 <monochrom> deletia
12:46:24 <b0fh_ua> delete what?
12:46:32 <b0fh_ua> containers-0.3.0.0-409fe3b8f0dda25b98e03716d26be411 - this one?
12:46:47 <dafis> b0fh_ua, have you containers-0.3.0.0 in both, the global and user db? If so, unregistter it from the user db
12:47:23 <b0fh_ua> dafis: well, how do I check which db is being used for certain package?
12:47:37 <monochrom> ghc-pkg list containers
12:47:48 <b0fh_ua> sorry, I'm not familiar with cabal and ghc-pkg, so I can be stupid
12:47:54 <dafis> b0fh_ua, ghc-pkg list should separate them
12:48:08 <monochrom> but most likely just go ahead and ghc-pkg unregister --user containers
12:48:28 <b0fh_ua> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27174#a27174
12:48:33 <monochrom> "cabal install --force" should be disabled.
12:48:53 <b0fh_ua> monochrom: I didn't do anything with --force
12:49:15 <dafis> b0fh_ua, so ghc-pkg unregister --user containers
12:50:13 <monochrom> if it complains, tell us its complaint, it will mean more packages to unregister
12:51:09 <b0fh_ua> yes, Cabal, hpc, template-haskell
12:51:15 <b0fh_ua> and curl
12:51:44 <dafis> what, Cabal depends on your user db?
12:51:48 <monochrom> unfortunately you will have to unregister them and rebuild them.
12:51:49 <b0fh_ua> tried to install curl, it installed containers - and failed again
12:51:59 <dafis> ghc-pkg list Cabal ?
12:52:37 <b0fh_ua> dafis: now there is only one version of Curl
12:52:47 <b0fh_ua> I think I know what is the problem
12:52:58 <dafis> namely?
12:53:01 <b0fh_ua> I did cabal update, and then upgraded several packages
12:53:06 <FunctorSalad_> echo 'exec /usr/local/bin/cabal --global "$@"' > /myoverridebins/cabal 
12:53:07 <FunctorSalad_> ;)
12:53:09 <b0fh_ua> and looks like they were installed in user
12:53:25 <b0fh_ua> database
12:53:36 <b0fh_ua> so finally I have several versions of same packages
12:53:39 <FunctorSalad_> (one time for all times...) (has to be modified so it only does --global for commands that allow it)
12:53:47 <b0fh_ua> do I have to use --global always?
12:54:01 <napping> that sounds like a bug, if it didn't also rebuild the packages that depend on the updated packages
12:54:07 <FunctorSalad_> only if you want to avoid it ever using the --user db :) b0fh_ua 
12:54:20 <dafis> b0fh_ua, I always install in the user db
12:54:23 <b0fh_ua> FunctorSalad_: okay, let's try it out
12:54:46 <FunctorSalad_> IIRC cabal sometimes used my user db if I do sudo cabal, rather than sudo -i cabal
12:54:48 <FunctorSalad_> ?
12:55:36 <FunctorSalad_> b0fh_ua: err this is assuming that /myoverridebins is a directory in your $PATH before /usr/local/bin, obviously
12:55:45 <b0fh_ua> sure
12:56:28 <FunctorSalad_> (and you want to check whether the command is one of... install,configure,register,upgrade, I think)
12:56:54 <CakeProphet> hmmmm, so I can't decide between TChan or Chan
12:57:12 <monochrom> try TChan first :)
12:57:29 <CakeProphet> mainly because I don't see the advantages of using TChan, and see possible disadvantages due to the restriction to the STM monad (sure, I can just return values and then work in IO, but the inconvenience still exists)
12:59:17 <monochrom> it is still strange that one can get two instances of container-0.3.0.0, I mean, same version!
12:59:31 <CakeProphet> it seems that most of the time I will simply be using atomically with a single TChan read or write
12:59:42 <b0fh_ua> monochrom: yup
12:59:43 <FunctorSalad_> for x in $( cabal --list-opt | grep '^\w' ); do cabal $x --help | grep -e --global && echo $x; done
12:59:57 <FunctorSalad_> ^^^^ list all cabal commands allowing the --global flag =)
13:00:22 <dafis> monochrom, not at all if one uses --reinstall
13:00:26 <FunctorSalad_> for x in $( cabal --list-opt | grep '^\w' ); do cabal $x --help | grep -e --global && echo $x; done | xargs echo | s '\s+' ' '
13:00:29 <FunctorSalad_> err sorry
13:00:39 <FunctorSalad_> that was supposed to be private /exec ;)
13:01:09 <monochrom> Oh I see, I can do it, without --reinstall too
13:01:37 <dafis> monochrom: without --reinstall, how?
13:01:54 <CakeProphet> I suppose I could just make TChan a -> IO (a|()) functions
13:02:16 <CakeProphet> atomically.readTChan
13:02:34 <monochrom> I have my own package tarball unpacked. In that directory, I just do "cabal clean", "cabal install --global", "cabal clean", "cabal install --user"
13:02:43 <b0fh_ua> nice
13:02:43 <nolrai> Hey if I want to mapM but over a finite map what do I use?
13:02:46 <FunctorSalad_> install configure register upgrade
13:02:47 <CakeProphet> but... why. I don't see the benefit of atomically composing message sends and receives for my purposes.
13:02:55 <dafis> monochrom: evil
13:02:56 <b0fh_ua> so I solved my problem with reinstalling haskell-platform
13:03:03 <FunctorSalad_> (further cut-down result of that command ;))
13:03:06 <b0fh_ua> and installing everyting as --global
13:03:40 <napping> CakeProphet: that depends what you want to do with the channels
13:03:41 <FunctorSalad_> monochrom: programmatically? me too, for the reason that I want to cabal haddock
13:03:46 <dafis> nolrai: when you say finite map, do you mean Data.Map?
13:03:50 <FunctorSalad_> to hyperlink sources...
13:03:54 <napping> in particular, if there is only ever one reciever it probably doesn't help
13:04:01 <monochrom> cabal-install version 0.8.0, cabal lib 1.8.0.6, both from haskell platform 2010.1.0.0
13:04:40 <FunctorSalad_> I could upload that script after some cleanup ;)
13:04:42 <CakeProphet> napping:  well there might be multiple receivers... but I'll be using dupChan to achieve that effect.
13:04:58 <napping> but, something like atomically (liftM2 (,) (readTChan a) (readTChan b)) in parallel with atomically (liftM2 (,) (readTChan b) (readTChan c))
13:05:06 <napping> is hard to do otherwise
13:06:02 <monochrom> Oh I see, "cabal install <packagename>" (implying straight from hackage) refuses to duplicate packages.
13:06:03 <nolrai> dafis: yeah
13:06:10 <CakeProphet> napping:  not if the second operation was passed dupTChan b instead of b
13:06:48 <napping> no, the problem is if you did that without TChan and were in a state where only a and b had a message, the second thread might grab the item from b and wait for one from c, and everything deadlocks
13:06:53 <dafis> nolrai: one of mapM action (assocs fm) or mapM action (elems fm), depending on the type of action
13:07:43 <CakeProphet> napping:  ah, I see.
13:08:03 <CakeProphet> napping:  well, for the added safety I guess I'll use TChan and then make IO helper functions for simple cases.
13:08:08 <monochrom> hahaha not so! it depends on order.
13:08:14 <napping> you may not have to do that sort of thing, but it's a case where TChan can be more useful
13:08:43 <monochrom> "cabal install --user binary-search" "cabal install --global binary-search" in that order
13:08:48 <Phyx-> @package foo
13:08:49 <lambdabot> http://hackage.haskell.org/package/foo
13:09:05 <napping> I doubt you will have to do that sort of thing
13:09:07 <monochrom> that will get you 2 instances and 0 complaints.
13:09:38 <akosch> how would you generate a infinite list of all possible ascii strings (with increasing lenght)?
13:10:09 <nolrai> dafis: and then put it back in a Map with fromAscList? 
13:10:11 <soupdragon> generate all the length n ones
13:10:24 <CakeProphet> napping:  my resource sharing is fairly user-driven, so technically almost any kind of operation can occur simultaneously.
13:10:27 <soupdragon> > sequence ["abc","abc","abc"]
13:10:28 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
13:10:34 <CakeProphet> napping:  but in the average case will not.
13:10:35 <soupdragon> > replicateM 3 "abc"
13:10:35 <dafis> nolrai: probably
13:10:36 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
13:10:49 <soupdragon> > flip replicateM "abc" =<< [1..]
13:10:50 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
13:11:03 <lispy> replicate 3M?
13:11:08 <CakeProphet> soupdragon:  woah. fancy.
13:11:10 <akosch> wow, thx
13:11:24 <CakeProphet> soupdragon:  time to make a brute force password cracker in Haskell. :)
13:11:25 <FunctorSalad_> neat
13:11:35 <jmillikin> Is it possible to export qualified imports? I want to do something like << module Foo.A ( module Foo.B ) where import qualified Foo.B >>, but GHC prints a warning about "The export item `module Foo.B' exports nothing.
13:11:41 <jmcarthur> heh, inspired by cryptohash or something?
13:11:43 <akosch> soupdragon: could you explain your solution a bit?
13:11:51 <ezyang> Hey guys, I have an arbitrarily large sized bit field in C that I want to convert into Haskell. Should I do [Bool] or SomeArray Bool or find a legit arbitrary sized bit field type that has a Bits instance? 
13:11:53 <soupdragon> which step is not clear?
13:12:14 <akosch> soupdragon: what's =<< for example?
13:12:27 <FunctorSalad_> that seems like pretty good PR material for haskell... not being as vulnerable as the "quicksort" ;)
13:12:29 <lispy> ezyang: what is the C snippet that defines it?
13:12:40 <soupdragon> I can't explain what =<< is
13:12:44 <ezyang> Itâs just a unsigned foo[0] 
13:12:49 <FunctorSalad_> hehehe
13:12:55 <soupdragon> but we can get rid of it
13:12:55 <ezyang> with macros for doing masking on it and stuff 
13:12:58 <FunctorSalad_> concatMap in this context, no?
13:13:08 <soupdragon> > concat (map (flip replicateM "abc") [1..])
13:13:09 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
13:13:11 <CakeProphet> akosch:  =<< is swap (>>=) ....if you know what that is.
13:13:16 <jmcarthur> ezyang: uvector packs booleans into a bitfield, iirc
13:13:19 <jmcarthur> but vector does not :(
13:13:28 <akosch> CakeProphet: yes, thx
13:13:43 <ezyang> Oh no! uvector is deprecated... 
13:13:48 <jmcarthur> yeah
13:14:04 <lispy> I wonder if we could merge that bit of uvector to vector
13:14:05 <FunctorSalad_> > concatMap (`replicateM` "ab") [1..] -- just golfing...
13:14:06 <lambdabot>   ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb...
13:14:10 <lispy> That would be a nice long term solution
13:14:16 * ski . o O ( "Who deprecates the deprecators ?" )
13:14:22 <FunctorSalad_> ^^
13:14:50 * lispy deprecates ski
13:14:58 <FunctorSalad_> 'it is deprecated' makes it sound like a divine decree, indeed
13:15:04 <soupdragon> what comes first:  Integration or Differentiation?
13:15:09 <ezyang> I wonder why it doesn't have it. 
13:15:10 <verdelyi> can someone enlighten me about this? http://fpaste.org/9wix/ how can I fix it? I need to tell the typechecker that "type Size a" only counts for "IntScalar a" types and () isn't one
13:15:21 <jmcarthur> probably just haven't gotten around to adding it
13:15:21 <FunctorSalad_> (though usually I'd trust the library author to know which of his functions are bad ;))
13:15:36 <ezyang> I see. Maybe would be a good thing to submit a patch. 
13:16:00 <jmcarthur> in fact, i think packed bools was on a todo list somewhere when vector was first released
13:16:01 <nolrai> @hoogle isNothing
13:16:02 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
13:16:05 <jmcarthur> but i don't think it's been done
13:16:06 <lispy> It's open source, patches are how we say hello :)
13:16:24 <dafis> verdelyi, the context IntScalar a is not considered for instance selection
13:16:43 <FunctorSalad_> "hello" *starts taking apart and rebuilding your house*
13:16:46 <FunctorSalad_> ;)
13:16:54 * hackagebot bloomfilter 1.2.6.4 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-1.2.6.4 (BryanOSullivan)
13:17:06 <verdelyi> dafis: anything I can do about it? I don't want to manually write an instance for all IntScalars
13:17:23 <Esteth> Hey guys. I'm wondering what type to use for a grid of squares, each able to contain something. the size can vary between instances, but not once created, and rooms are always rectangles. A list-of-lists seems horribly inefficient, but an 80x25 tuple seems stupid.
13:17:29 <verdelyi> dafis: my best idea would be TH
13:17:45 <dafis> verdelyi: I don't know a way, TH may work, though
13:17:47 <jmcarthur> Esteth: how about an array?
13:17:57 <jmcarthur> or nested array
13:18:05 <chrisdone> a tuple indexed array?
13:18:19 <verdelyi> dafis: ok thx
13:18:25 <jmcarthur> repa ;)
13:18:44 <soupdragon> The mating habits of deep-sea squid have been revealed for the first time, after the discovery of a male squid with a huge elongated and erect penis.
13:18:51 <soupdragon> http://news.bbc.co.uk/earth/hi/earth_news/newsid_8792000/8792008.stm
13:19:08 <Esteth> thanks jmcarthur and chrisdone. I'll take a look-see and figure out what'll work best
13:19:19 <soupdragon> oh not this channel
13:19:31 <abbe> soupdragon, relevant for #emacs :-)
13:21:01 <verdelyi> dafis: problem is, the last time I tried to solve this using TH, I ended up reporting 2 tickets for GHC :)
13:21:36 <dafis> verdelyi: There's still room for more tickets on the GHC trac :/
13:23:45 <verdelyi> dafis: I would prefer concentrating on the actual problem, not on devising evasive maneuvers regarding GHC bugs :|
13:23:48 <FunctorSalad_> Esteth: if the size is really fixed at compile-time, TH could be an option... but that wouldn't be a trivial task
13:23:56 <CakeProphet> @pl writeTChanIO chan m = atomically $ writeTChan chan m
13:23:56 <lambdabot> writeTChanIO = (atomically .) . writeTChan
13:24:06 <ezyang> Strange: I canât find any mention of the lack of bool packing in the vector Trac or codebase 
13:24:10 <FunctorSalad_> though you'd probably just write a fold or so in TH, and the rest could be derived from it in ordinary haskell
13:24:14 <CakeProphet> for some reason that idiom always escapes me.
13:24:43 <FunctorSalad_> Esteth: I mean TH to generate code for a 80x25-tuple
13:24:48 <nlogax> anyone using yi? i can't find any (noob-friendly) examples.. the cua keymap is pretty good, but <tab> does nothing. trying to figure out how to add something for it :)
13:25:16 <ezyang> Though dons mentions it on his blog 
13:25:18 <FunctorSalad_> not sure if this is a serious advantage over an array :)
13:25:49 <Esteth> FunctorSalad_: 80x25 is the maximum size at the moment. It might later be decided to make larger versions, so I'd rather not venture into TH to generate tuples. Thanks for the suggestion though, it's always nice to have more ideas :)
13:26:12 <FunctorSalad_> CakeProphet: someone advised me that you shouldn't wrap 'atomically' around utility functions, since that makes them uncomposeable... (within STM)
13:26:23 <FunctorSalad_> and always add the atomically at point of usage
13:27:10 <FunctorSalad_> Esteth: the size would only have to be fixed at compile-time, not hardwired to 80x25 specifically
13:27:23 <CakeProphet> FunctorSalad_:  well, these utility functions aren't intended to be composable. The whole point is that they execute as a single atomic act in IO.
13:27:27 <CakeProphet> which is what I want. so no worries.
13:27:37 <CakeProphet> when I want to compose I'll simply write functions for STM instead of IO
13:27:51 <monochrom> yeah, don't wrap atomically around too large pieces of code. really think why you need it and where you need it.
13:28:00 <FunctorSalad_> but fair enough @ not venturing into TH; it'd probably be messier than just using an array
13:28:18 <FunctorSalad_> (at least the TH part, anyway)
13:28:56 <CakeProphet> all of my *IO functions will be explicitly for single STM actions to IO
13:29:11 <FunctorSalad_> (weasel words were added because I have little exp with STM)
13:29:32 <CakeProphet> for instances when I only need to write one value to a channel as an atomic action. writeTChanIO.
13:29:54 <FunctorSalad_> sure, it's fine for that
13:30:27 <Esteth> FunctorSalad_: These are rooms for a roguelike game I'm attempting to make to try something practical with haskell. They'll be generated by a generator at runtime, and I'm not familiar with TH. It might be possible, but it strikes me as overcomplicated for this. I'm still new to haskell though, so I might be going down the wrong road
13:30:34 <FunctorSalad_> I guess the problem is if it's a less trivial utility and you later want to use it as part of a transaction rather than as its own transaction
13:30:51 <CakeProphet> FunctorSalad_:  ah yeah. Anything large I write will definitely have a return type of STM a
13:31:25 <FunctorSalad_> Esteth: yes, it kinda is
13:31:29 <FunctorSalad_> (overcomplicated)
13:33:18 <CakeProphet> FunctorSalad_:  I'm really surprised these utility functions do not already exist. 
13:34:48 <FunctorSalad_> *nod*, but I think there's a boundary of triviality where it will be harder for the library user to find the name for the trivial utility than to write it himself ;)
13:35:22 <CakeProphet> ha. perhaps.
13:35:31 <FunctorSalad_> I sometimes find myself naming all the basic combinations of my primitives and then forgetting which is which ;)
13:35:47 <FunctorSalad_> systematic naming would matter
13:36:10 <CakeProphet> hmmm... okay so
13:37:08 <CakeProphet> I have a channel that is listened to by my main thread, that will receive a shutdown event. Is there a monad utility function that repeats a monad until some kind of event?
13:37:23 <CakeProphet> hmmm, actually forever will probably do the trick
13:37:28 <CakeProphet> since I'll end up exiting.
13:37:54 <monochrom> there is nothing to repeat here. readTChan >> return ()
13:38:04 * illissius thanks whatever gods may be for extundelete
13:38:04 <FunctorSalad_> I usualy use manual recursion guarded by 'when'
13:38:08 <FunctorSalad_> *usually
13:38:12 <monochrom> err of course atomically (readTChan) >> return ()
13:38:25 <FunctorSalad_> CakeProphet: fix (\loop -> do { ... stuff ... ; when condition loop; })
13:38:39 <FunctorSalad_> wait, maybe fix is wrong here...
13:39:01 <FunctorSalad_> hmm no, looks ok?
13:39:02 <CakeProphet> FunctorSalad_:  never understood fix. What is the argument, the function itself?
13:39:13 <FunctorSalad_> I was just trying to be clever and failing ;)
13:39:28 <monochrom> fix (\loop -> do { ... stuff ... ; when condition loop; }) is correct.
13:39:28 <FunctorSalad_> let loop = do { ... stuff ... ; when condition loop; } in loop
13:39:34 <FunctorSalad_> would be my intention
13:39:57 <FunctorSalad_> CakeProphet: the argument is the function you want to take the 'fixed point' of, yes
13:40:30 <CakeProphet> so essentially referring to the argument repeats the function, and not referring to it "exits" from the loop?
13:40:37 <FunctorSalad_> (recursion can be made sense of mathematically by compiling it down to fix...)
13:40:41 <monochrom> just pretend "fix" means "recurse". or you can read http://www.vex.net/~trebla/haskell/fix.xhtml if you have time
13:41:01 <FunctorSalad_> (so it's kinda sacred ;))
13:41:02 <CakeProphet> ...that's pretty damn cool.
13:41:18 <FunctorSalad_> but not always useful for reading, as I demonstrated to myself
13:41:19 <monochrom> this is why recursion is easier to use than loops.
13:42:09 <FunctorSalad_> (this assumes that you have an ambient space where you can take such "fixed points" though, it's called domain theory)
13:42:30 <CakeProphet> I think I'll use fix just because it's cool. If you know what fix does I don't think readability will suffer. Is fix in Prelude?
13:42:34 <FunctorSalad_> it resembles taking limits of monotonically increasing sequences in calculus
13:42:43 <monochrom> Data.Function.fix
13:43:11 <monochrom> not much shorter than writing it yourself: fix f = let x = f x in x
13:43:17 <CakeProphet> and... how do I import only fix again? import syntax escapes me.
13:43:26 <monochrom> import Data.Function(fix)
13:43:31 <CakeProphet> ah okay
13:43:46 <FunctorSalad_> (except that our sequence isn't one of increasing real numbers, but increasingly "defined" programs =))
13:43:54 <CakeProphet> my import list is officially getting "large".
13:44:01 <monochrom> readability is subjective. function of educational background. there is no "readable for everyone".
13:44:16 <FunctorSalad_> CakeProphet: hehe I made a giant reexport module and put it in its own package
13:44:17 <tg_nokeyboard> unless it's in proper Queens english.
13:44:29 <FunctorSalad_> then I just 'import SP' in a new mini-program ;)
13:44:46 <FunctorSalad_> (@large import list)
13:45:03 <CakeProphet> hmmm, I might make a common export module. This will involve looking up how to export imported modules, because, again, I haven't really learned all the fancy uses of import except for "qualified" and "as"
13:45:13 <FunctorSalad_> monochrom: hmm yes, but even understanding fix to some degree, it has a certain mindbendingness ;)
13:45:19 <FunctorSalad_> compared to the equivalent 'let'
13:45:28 <monochrom> certain people's readability rules of thumb lead to drastically unreadable results. see http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
13:46:03 <CakeProphet> @src fix
13:46:04 <lambdabot> fix f = let x = f x in x
13:46:04 <FunctorSalad_> CakeProphet: module A(module Data.Function) where \nimport Data.Function
13:46:04 <roconnor> @type (<<<)
13:46:05 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
13:46:13 <CakeProphet> FunctorSalad_:  ah okay.
13:47:07 <FunctorSalad_> monochrom: maybe 'readable' was a euphemism for 'I find it semantically tricky a bit because it reifies the higher-order functional instead of it remaining implicit in let-syntax'
13:47:08 * hackagebot Ordinals 0.0.0.1 - Ordinal arithmetic  http://hackage.haskell.org/package/Ordinals-0.0.0.1 (KiYungAhn)
13:47:18 <FunctorSalad_> nothing unmanageable, mind you
13:48:13 <kyagrd> We now have a ordinal implementation ~
13:48:20 <danharaj> gah
13:48:30 <danharaj> why the hell would you mutilate a list comprehension like that?
13:49:10 <ReinH> kyagrd: http://skitch.com/reinh/dmswu/ssl-error :(
13:49:20 <tg_no2key> FunctorSalad_: I find that 'readability' in code is a lot like 'drinkability' for Budweiser's beer. Un-drinkable beer is chunky yeast ferment. All beer is drinkable, all code is readable.
13:49:20 <tg_no2key> [16:13] <tg> http://maps.google.com/maps?hl=en&q=saint%20simon%20island&cts=1278619969160
13:49:30 <tg_no2key> s/$LAST//
13:49:52 <kyagrd> didn't know that patch tag was a dangerous site
13:50:07 <CakeProphet> readTChan blocks correct?
13:50:13 <monochrom> yes
13:50:16 <CakeProphet> alrighty.
13:50:20 <kyagrd> Maybe I should of used http rather than https
13:50:30 <kyagrd> s/of/have/
13:50:33 <tg_no2key> kyagrd yeah probably just not configured propery
13:50:34 <CakeProphet> so I actually don't even need fix. But I will in the future if I end up implementing more than a shutdown message.
13:50:57 <ReinH> kyagrd: sucks for them/you :(
13:51:05 <ReinH> http works fine
13:51:13 <ReinH> maybe they just redirect https like idiots
13:51:18 <tg_no2key> i'm going to reboot to see if I can get y 'two' key back.
13:51:19 <FunctorSalad_> tg_no2key: seems like a general language point :) not sure how invalid it is to express "has quality X enough that I won't bother" as "is not(X)" :)
13:51:33 <CakeProphet> oh my... I'm going to have a difficult time naming all of my different message types.
13:51:35 <tg_no2key> FunctorSalad_: that was my point.
13:51:48 <CakeProphet> MudShutdownMsg, MudControlMsg, MainMsg, ????  What to use...
13:51:59 <tg_no2key> I mean, maybe code which doesn't follow language conventions (is made up entirely of pictures or symbols) (is read upward diagonally)
13:52:07 <tg_no2key> might not be readable
13:52:09 <FunctorSalad_> wouldn't descriptivists say that this is a new valid way of talking if it's in common use?
13:52:36 <FunctorSalad_> though it makes a subjective statement masquerade as one about the intrinsic qualities of the beer
13:52:40 <tg_no2key> FunctorSalad_: yeah, but they don't know what the hell they're talking about
13:53:00 <tg_no2key> Do I think that Budweiser should be able to purchase 'drinkability' into the dictionary
13:53:10 <tg_no2key> rather, into the lexicon of our brains?
13:53:24 <monochrom> is "drinkability" readable?
13:53:24 <soupdragon> no
13:53:26 <ReinH> wat
13:53:31 <tg_no2key> Maybe the onus is on us to demonstrate that there exists undrinkable beer.
13:53:37 <Dashkal> Ran across a nifty blog post: http://laplacian.wordpress.com/2009/01/10/how-shazam-works/ Makes me wonder.  Any good audio packages that can convert songs into spectrographs?
13:54:15 <Zao> Dashkal: Anything with a FFT.
13:54:24 <kyagrd> If anyone knows or where to find how to do ordinal division let me know the division is currently missing
13:54:35 <CakeProphet> bah... I can't decide. Perhaps it would be easier to simply throw an exception to main instead of going through all the trouble of using message passing. Or maybe each is equally troublesome...
13:54:38 <danharaj> transfinite ordinal division?
13:54:57 <kyagrd> well I only need things less than epsilon_0
13:55:04 <danharaj> 'only'
13:55:06 <kyagrd> danharaj, yes
13:55:11 <Dashkal> hmm.  pure-fft
13:55:25 <Dashkal> I suspect I'm going to have to learn a lot more about digitial processing to make use of this...
13:55:33 <FunctorSalad_> tg has left?
13:55:45 <monochrom> message passing is very minimal work for you.
13:56:11 <danharaj> kyagrd: I don't think division is a natural operation on ordinals, why do you want it?
13:57:01 <kyagrd> danharaj, it is a natural operation actually just as subtraction is.
13:57:03 <CakeProphet> Dashkal:  do you get fft?
13:57:09 * CakeProphet happens to know a good bit about DSP
13:57:31 <danharaj> kyagrd: I don't think subtraction is natural on the ordinals either.
13:58:08 <kyagrd> danharaj, see planet math or wikipedia it is quite natrually defined.
13:58:08 <zygoloid> kyagrd: what is w / 2 ? what is w - 1? what is 2 / w? what is 1 - w? ;-)
13:58:21 <zygoloid> are they just not defined?
13:58:42 <kyagrd> zygoloid, it is just the reverse of addition.
13:58:54 * monochrom read the Cooley and Tukey paper. Nice algebra.
13:58:56 <kyagrd> a + (b - a) = b when b > a
13:59:31 <Dashkal> CakeProphet: No.  And I think I'd better put this down until after my scripting language project is done.
13:59:32 <kyagrd> This is uniquely defined.
13:59:37 <Dashkal> This looks like a _deep_ rabbit hole.
13:59:43 <danharaj> ok fair enough. I would think of it as iterations of the predecessor operator than the reverse of addition.
13:59:45 <kyagrd> http://en.wikipedia.org/wiki/Ordinal_arithmetic
13:59:48 <orlandu63>  
13:59:57 <orlandu63> disregard
14:00:01 <CakeProphet> Dashkal:  haha, alright. 
14:00:15 <CakeProphet> Dashkal:  can you link me to the docs?
14:00:18 <kyagrd> Similarly division can be uniquely defined but it's trubling my head to figure out how to write down :(
14:00:23 * CakeProphet is interested in using DSP for Haskell.
14:00:41 * edwardk waves hello.
14:00:45 <soupdragon> hi
14:00:50 <CakeProphet> so what's the best way for a program to restart itself?
14:00:55 <danharaj> kyagrd: how would you define division on the natural numbers
14:01:15 <Dashkal> CakeProphet: I found http://hackage.haskell.org/package/dsp and http://hackage.haskell.org/package/pure-fft
14:01:20 <zygoloid> kyagrd: that wikipedia page tends to agree, in that right subtraction does not work
14:01:22 <kyagrd> danharaj, `div` in haskell is exactly that one.
14:01:36 <kyagrd> zygoloid, of couse left subtraction and left division.
14:01:41 <zygoloid> kyagrd: how would you notate left subtraction?
14:01:42 <edwardk> CakeProphet: http://nathanwiegand.com/wp/2010/02/hot-swapping-binaries/ has some nice thoughts that work well with serialization and mmap to maintain state
14:01:54 <danharaj> kyagrd: no, how would you define it mathematically. Try extending from this definition.
14:02:26 <CakeProphet> edwardk:  though I am slightly interested in hotswapping, I was actually just wondering about a naive restart. exit and run again.
14:02:26 <edwardk> CakeProphet: effectively you can just execl yourself. if you do it after forking someone who will send you back all your important data, you can do so while maintaining file handles, etc.
14:02:30 * CakeProphet is a somewhat novice programmer.
14:03:07 <kyagrd> zygoloid, Ordinal addition is left calelative. What else do I need? The definition of left subraction is immidate form the definition of addition.
14:03:14 <Dashkal> Yeah, I'm definitely shelving this for now.  Linear algebra is the one area of math that's still got me beat.  *grumbles something about calculus and monads but matricies beat him...*
14:03:21 <CakeProphet> edwardk:  where is execl located in Haskell modulespace?
14:03:25 <CakeProphet> Posix?
14:03:28 <kyagrd> s/calelative/cancellative/
14:03:28 <zygoloid> kyagrd: sure, but you do you notate / denote / write it? what operator do you use?
14:03:46 <tg_no2key> dot line dot
14:03:53 <edwardk> CakeProphet: i believe it is executeFile in System.Posix.Process but i don't use that part of the hierarchy mch
14:03:54 <edwardk> er mch
14:03:57 <kyagrd> zygoloid, I am just using the (-) operator Num class in right now.
14:03:59 <edwardk> er much
14:04:03 <edwardk> u stuck =)
14:04:05 <kyagrd> b - a 
14:04:19 <kyagrd> b > a othwerise I just return zero
14:04:23 <luite> Dashkal: it's not that hard, if you're determinant enough ;p
14:04:56 <FunctorSalad_> @just reverse of addition: but addition with a fixed ordinal isn't bijective ;)
14:04:56 <lambdabot> Maybe you meant: list quit
14:05:04 <FunctorSalad_> not even injective at times
14:05:19 <Dashkal> luite: *golfclap* :p
14:05:20 <FunctorSalad_> but maybe that's only possible when fixing the left arg
14:05:24 <edwardk> luite: either an interesting malapropism or a terrible pun ;)
14:05:41 <FunctorSalad_> sorry, the right... like (+omega)
14:05:45 <CakeProphet> edwardk:  so basically I just evoke the process again right as I exit?
14:05:46 <kyagrd> zygoloid, There isn't a class for quasigroup in haskell standard library, so I know that it is not conceptually right but I'm just exploiting the Num class
14:05:46 <luite> hehe I'd say terrible pun :p
14:05:51 <edwardk> CakeProphet: yeah
14:06:02 <Dashkal> I think after my scripting project I'll try to write a simple matrix math library in haskell.  Perhaps implementing that crap will help the rules stick in my mind for more than an hour.
14:06:43 <FunctorSalad_> which rules?
14:07:18 <zygoloid> kyagrd: yeah, you really want an operator for -a + b. it's not obvious how you'd write that though... :(
14:07:39 <Dashkal> FunctorSalad_: My problem when attempting to learn linear algebra is that I cannot remember what I've learned after a day or so.  I've learned to multiply matricies 5 or so times now.  Nothing.
14:07:42 <edwardk> Dashkal: linear algebra isn't that bad once you start thinking of things like gassian elimination as just using the rules of algebra to rewrite equations, etc or matrix multiplication to change variables, etc.
14:07:55 <CakeProphet> edwardk:  is getProgramName sufficient in most cases as a file path?
14:08:18 <Dashkal> edwardk: If I could get to the point where 'gassian eliminiation' was an approachable subject I'd be far better off than I am now.
14:08:19 <edwardk> you may need to canonicalize the path to ensure that you can find it
14:08:28 <FunctorSalad_> Dashkal: I suspected it's that. I suppose they didn't tell you about linear maps first...
14:08:34 <FunctorSalad_> then matrix mult makes perfect sense
14:09:04 <Dashkal> The most recent book I've tried is "linear algebra demystified" - McMahon
14:09:05 <zygoloid> kyagrd: i have a suspicion that ordinal division is just a generalized polynomial division
14:09:14 <CakeProphet> edwardk:  canonicalize?
14:09:17 <FunctorSalad_> in a nutshell, a matrix represents a linear map, given fixed coordinate systems on the domain and codomain
14:09:35 <Dashkal> starts with systems of linear equations then moves into matrix algebra
14:09:39 <edwardk> CakeProphet: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/directory-1.0.1.1/System-Directory.html#v%3AcanonicalizePath
14:09:44 <FunctorSalad_> matrix mult calculates the representation of the composition of f and g, given the reps of f and of g
14:10:22 <Dashkal> FunctorSalad_: *gives blank look* Unfortunately, I'm not kidding.  That went right over my head
14:10:31 <Dashkal> and it drives me up the wall...
14:10:47 <FunctorSalad_> ok =) didn't mean to; it's hard to guess how far people are into their studies
14:11:14 <edwardk> Dashkal: one way to 'ground' linear algebra is to play with something that uses it tangibly. i.e. hacking around on something like an isometric game engine using opengl, etc.
14:11:30 <CakeProphet> edwardk:  ah, so if I call that onto getProgramName at the beginning of my program I should get an accurate absolute file path to my program?
14:11:39 <Dashkal> edwardk: opengl is part of the reason I want to get past this.  I want to be able to do 3d game projects.
14:11:49 <FunctorSalad_> Dashkal: the idea is that there is a world of *abstract* vector spaces and linear maps, and that coordinate vectors and matrices are merely a tool to map them out for you
14:11:56 <edwardk> CakeProphet: theoretically. though be warned getProgramName can be rewritten before you see it if folks are doing tricky things =)
14:12:10 <FunctorSalad_> (not sure if you've been told about vector spaces and linear maps already)
14:12:58 <Dashkal> FunctorSalad_: My studies on this subject stopped at Grade 12 (canadian system -- we got to simple vectors and basic calculus)  Higher education was mostly applications with a calculus course thrown in
14:13:02 <danharaj> Vectors and matrices transform something abstract and non-obvious: computing linear transformations on some vector space, into something easy: arithmetic.
14:13:25 <monochrom> good memory helps learning
14:13:37 <Dashkal> "applications" applications of programming.  Little math background.
14:13:38 <monochrom> (shoot, that's tautological...)
14:13:58 <Dashkal> monochrom: I'm ADHD.  "good memory" is a lost cause.  I cope with "good lookup skills"
14:14:16 <FunctorSalad_> Dashkal: ok, I guessed 1st semester math or first few semesters of math-using science :)
14:14:40 <Dashkal> FunctorSalad_: Had I hit university, I'd be better off here *sigh*.  I hit tech school and got a diploma.  Not a degree.
14:14:44 <FunctorSalad_> (I mean I based what I said on that guess)
14:15:08 <Dashkal> So I'm missing a lot of general science stuff that would have come with a CS degree.  Missing that stuff.  I need to go back
14:15:08 <monochrom> everyone must rely on good lookup skills eventually anyway, e.g., when old and memory fails
14:15:27 <Dashkal> Learning Haskell kind of drove that home...
14:16:14 <CakeProphet> edwardk:  I guess if I wanted to be extra careful I could use getModificationTime? 
14:16:15 <FunctorSalad_> the method that matrix mult is taught at secondary school is pretty much exactly how you should not do it ;)
14:16:22 <danharaj> Someone should compile a set of books that make up a beginner theoretical computer science course.
14:16:23 <Dashkal> *snickers*
14:16:25 <soupdragon> how should you do it?
14:16:33 <FunctorSalad_> (drop definition without any rationale)
14:16:44 <monochrom> I also know of and kind of agree with an opinion that says memorizing things is so passe, now searching skill such as asking the right question is the important skill.
14:16:46 <danharaj> First two books on such a list, I would put Sipser and Pierce.
14:16:48 <Dashkal> The rules I can remember is basically the width of a must match the height of b (or was it vice versia) and you cross multiply or some such.
14:17:00 <Dashkal> Feel free to shudder at how badly I mangled that
14:17:08 <FunctorSalad_> soupdragon: introduce vector spaces/linear maps and the concept of rep'ing linear maps as matrices, let them figure out the matrix mult formula as an exercise ;)
14:17:31 <Dashkal> But you're right, I should really try again with something grounded rather than try to learn the pure abstract terms directly.
14:17:33 <FunctorSalad_> (that will make it the *solution* to a meaningful problem)
14:17:35 <monochrom> memorizing things is nice, but just a caching issue.
14:17:39 <FunctorSalad_> fsvo meaningful
14:17:45 <soupdragon> ah yes
14:18:07 <soupdragon> matrix multiplication is just composition
14:18:20 <FunctorSalad_> or if not as an exercise, do the reasoning of the exercise in the lecture
14:18:24 <FunctorSalad_> yes
14:18:29 <FunctorSalad_> forgot to say that
14:18:38 <soupdragon> which explains the reason for what Dashkul just said
14:18:47 <FunctorSalad_> (that that would be the task: compute rep of composition)
14:19:09 <soupdragon> (*) :: (R^k -o R^m) -> (R^n -o R^k) -> (R^n -o R^m)
14:19:58 <FunctorSalad_> the dimension matching is for the same reason that the signature of haskell's (.) contains 'b' two times
14:20:01 <FunctorSalad_> @ty (.)
14:20:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:20:07 <FunctorSalad_> hrhr
14:20:08 <Esteth> In an instance declaration, how do you do a where clause? Do you just use a let..in instead?
14:20:16 <FunctorSalad_> caleskell strikes again ;)
14:20:36 <CakeProphet> edwardk:  hmmm, executeFile is execv. I don't really know the difference between execl and execv
14:20:41 <ezyang> Is there a single Haskell operator for rounded up division? 
14:20:46 <ezyang> e.g. 7/4=2 
14:20:51 <Dashkal> (.) :: (b -> c) -> (a -> b) -> a -> c
14:21:14 <soupdragon> If I give a map  f :: R^n -> R^m  and claim it's linear, can you find a matrix representation
14:21:16 <FunctorSalad_> @ty (\x y -> let types = [x undefined, y undefined] in x.y)
14:21:17 <lambdabot> forall a a1. (a -> a) -> (a1 -> a) -> a1 -> a
14:21:21 <soupdragon> (this is a theorem from linear algebra)
14:21:24 <FunctorSalad_> hmpf
14:21:46 <soupdragon> :t \f g x -> f (g x)
14:21:47 <lambdabot> forall t t1 t2. (t1 -> t2) -> (t -> t1) -> t -> t2
14:21:51 <FunctorSalad_> soupdragon: or a map between to abstract vector spaces even, given a fixed basis...
14:21:55 <FunctorSalad_> *two
14:22:00 <soupdragon> oh yeah you have to fix a basis!
14:22:03 <soupdragon> that's the important thing
14:22:10 <CakeProphet> edwardk:  would forkProcess main work?
14:22:18 <FunctorSalad_> not for R^n as you said, since there is a 'standard basis'
14:22:19 <ezyang> I know I could do it with div mod, but it's pretty long 
14:23:09 <FunctorSalad_> (it gets confusing if you introduce different coordinate systems but for R^n instead of an abstract vector space...)
14:23:19 <FunctorSalad_> the latter gives you type safety =)
14:23:24 <soupdragon> ahh
14:23:25 <monochrom> no, there is not a single operator for rounded up division. maybe you don't mind ceiling and floating-point...
14:23:35 <soupdragon> yes this is a good point I shouldn't have just gone R^n straight away
14:23:43 <FunctorSalad_> ("V is the thing itself, these two mappings to R^n are our coordinate systems")
14:24:21 <FunctorSalad_> if you use V=R^n too there it becomes very confusing...
14:25:19 <FunctorSalad_> while with the abstract space it's just "make the types match" =)
14:25:48 <mreh> how come I have glib-0.10.1 installed?
14:25:57 <mreh> hackage has no earlier than 11.0
14:26:04 <mreh> that's all it has
14:26:13 <FunctorSalad_> (that theme continues in differential geometry even more severely...)
14:27:33 <FunctorSalad_> where things that are "arbitrary" in vector spaces become simply ill-defined (things that are defined in terms of coordinates, but don't stay the same if you change coordinate charts...)
14:27:51 <FunctorSalad_> just thought it's a cute analogy to type-safety in programming
14:27:52 <FunctorSalad_> :)
14:28:18 <Taejo> @unmtl StateT s (ListT (WriterT (Sum Int))) a
14:28:18 <lambdabot> err: `WriterT (Sum Int) [(a, s)]' is not applied to enough arguments, giving `/\A. [(a, s)] (A, Sum Int)'
14:28:37 * ddarius agrees with FunctorSalad_ insofar as focusing on linear functions and only secondarily considering how matrices represent them is the way to go.
14:28:40 <mreh> the plot thickens... cabal is looking for glib-0.10.1 when I'm installing yi
14:28:51 <Taejo> @unmtl StateT s (ListT (WriterT (Sum Int)))
14:28:52 <lambdabot> err: `StateT s (ListT (WriterT (Sum Int)))' is not applied to enough arguments.
14:28:56 <mreh> how can I find out what wants which package with cabal?
14:29:08 <Taejo> @unmtl StateT s (ListT (Writer (Sum Int))) a
14:29:08 <lambdabot> s -> ([(a, s)], Sum Int)
14:29:58 <CakeProphet> hmmm so, for CreateProcess
14:30:01 <Taejo> :t lift =<< get
14:30:02 <lambdabot> forall (m :: * -> *) b (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m, MonadState (m b) (t m)) => t m b
14:30:11 <CakeProphet> if I set close_fds to False... socket connections will remain intact?
14:32:52 <Taejo> :t lift =<< gets ?f
14:32:53 <lambdabot> forall (m :: * -> *) b (t :: (* -> *) -> * -> *) s. (MonadTrans t, Monad m, ?f::s -> m b, MonadState s (t m)) => t m b
14:33:26 <Esteth> if I want to write a method which prints characters, and every x characters prints a newline, should I use the state monad to keep track of a count, or is there a better way. Sorry for these silly questions by the way, I feel really stupid in haskell compared to java (a good thing)
14:34:45 <ezyang> Esteth: Pretty printing is a typical âhigherâ abstraction over this 
14:34:56 <FunctorSalad_> Esteth: "where is the chunk function" is a bit of a running gag here ;) so it has been put into a package 'split' with all the variations you can imagine ;)
14:35:09 <FunctorSalad_> they it's just "chunk x mystring" (or similar)
14:35:55 <FunctorSalad_> *then
14:36:30 <Esteth> FunctorSalad_: Haha. My characters are individual characters stored inside data structures stored in an array, so should I fold the data structure into a string, then use chunk?
14:36:55 <FunctorSalad_> yes, though in that case I don't know how efficient it is
14:37:30 <SubStack> Esteth: sounds like a job for map
14:37:34 <SubStack> then chunk over that
14:37:50 <danharaj> I have thought of a new troll for people who use GPL instead of BSD for their haskell libraries.
14:38:03 <danharaj> "Free as in free of ideological baggage"
14:38:10 <FunctorSalad_> (that wasn't to say that it's a stupid question at all, more like an embarassing one because 'chunk' isn't in the stdlib ;))
14:38:19 <CakeProphet> can I use record syntax to modify a record?
14:38:22 <Esteth> SubStack: so use map to get the characters out of the structure, which will give me a string. That's much more elegant than my fold, thanks :D
14:38:25 <CakeProphet> oldRecord {newparams=newvalues ...}
14:40:23 <SubStack> Esteth: something like putStrLn . unlines . chunk 80 . map f $ someData
14:40:31 <SubStack> is what I would do
14:41:09 <FunctorSalad_> (and because the oneliner to implement it is untypically long)
14:41:09 <Esteth> righto, *goes to check for mappable interface or declaration for Array*
14:41:15 <FunctorSalad_> for such elementary operations
14:41:54 <SubStack> FunctorSalad_: agree
14:43:04 <FunctorSalad_> @let chunks n = unfoldr (\x -> if null x then Nothing else Just (breakAt n x))
14:43:04 <lambdabot>  <local>:6:60: Not in scope: `breakAt'
14:43:06 <SubStack> Esteth: if you're using Data.Array you can use elems
14:43:10 <FunctorSalad_> @let chunks n = unfoldr (\x -> if null x then Nothing else Just (splitAt n x))
14:43:11 <lambdabot>  Defined.
14:43:21 <FunctorSalad_> > chunks 3 ['a'..'z']
14:43:22 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
14:43:28 <FunctorSalad_> *relief*
14:43:41 <FunctorSalad_> these lambdabot stunts usually end in 3 pages of spam for me
14:43:58 <FunctorSalad_> @where+ chunks unfoldr (\x -> if null x then Nothing else Just (splitAt n x))
14:43:58 <lambdabot> Good to know.
14:44:02 <FunctorSalad_> @where chunks
14:44:02 <lambdabot> unfoldr (\x -> if null x then Nothing else Just (splitAt n x))
14:44:10 <soupdragon> @where Data.Split
14:44:10 <lambdabot> I know nothing about data.split.
14:44:14 <soupdragon> @where Data.List.Split
14:44:14 <lambdabot> I know nothing about data.list.split.
14:44:19 <Esteth> subStack: I'm using IArray, but it seems to have elems too. Will that require yet another iteration though?
14:44:19 <soupdragon> @where Split
14:44:20 <lambdabot> I know nothing about split.
14:44:23 <FunctorSalad_> at least that's the shortest sane one I know
14:44:24 <soupdragon> @where Data.Chunks
14:44:24 <lambdabot> I know nothing about data.chunks.
14:44:36 <SubStack> whoa unfoldr, how have I missed that?
14:44:40 <FunctorSalad_> or s/shortest sane/most elegant/
14:44:48 <SubStack> no more catMaybes . foldr for me
14:44:48 <CakeProphet> is it bad that the first hit for "Haskell records" is a blog post about host record syntax is bad in Haskell?
14:44:55 <FunctorSalad_> the if null then Nothing is still slightly inelegant ;))
14:45:02 <danharaj> No, it's pretty bad.
14:45:26 <FunctorSalad_> pretty bad != bad?
14:45:39 <SubStack> :t (?)
14:45:40 <lambdabot> Not in scope: `?'
14:45:51 <danharaj> No, it's not bad, because the record syntax is pretty bad.
14:46:12 <centrinia> The record syntax is both pretty and bad? :p
14:46:16 <FunctorSalad_> soupdragon: Data.List.Split
14:46:21 <monochrom> the pretty and the bad
14:46:42 <Taejo> :t gets (lift . IS.toList . rows)
14:46:43 <lambdabot> Not in scope: `rows'
14:46:43 <CakeProphet> so... can anyone answer my question about updating records. :P
14:46:46 <edwardk> CakeProphet: no, because fork process will literally copy the current state and start running main again with everything you've already done still having happened
14:46:46 <CakeProphet> can I just do
14:46:49 <monochrom> with cute dinnerware!
14:46:50 <SubStack> @let (?) p x y = if p then x else y
14:46:51 <Taejo> :t gets (lift . IS.toList)
14:46:51 <lambdabot>  Defined.
14:46:52 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *). (MonadTrans t, MonadState IS.IntSet m) => m (t [] Int)
14:47:06 <CakeProphet> oldRecord {newparams=value...}
14:47:13 <monochrom> yes!
14:47:22 <CakeProphet> ...good
14:47:29 <edwardk> centrinia: yes, it is 'pretty bad' ;)
14:47:48 <FunctorSalad_> @where+ split http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html
14:47:49 <lambdabot> Okay.
14:47:54 <FunctorSalad_> @where+ Data.List.Split http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html
14:47:54 <lambdabot> Good to know.
14:48:36 <CakeProphet> edwardk:  I think I'll end up using createProcess then, because it seems like the most customizable one.
14:48:44 <monochrom> someone should take statistics of how often these @where factoids are actually recalled
14:48:49 <CakeProphet> I can choose to leave fds open, which I think will allow me to implement a kind of hotswapping
14:48:49 <FunctorSalad_> hmm suggestion: @module
14:48:52 <Esteth> Huh, I don't seem to have Data.List.Split
14:49:05 <FunctorSalad_> e.g. using hayoo
14:49:10 <edwardk> CakeProphet: note that that does something different
14:49:13 <FunctorSalad_> Esteth: 'split' package
14:49:19 <FunctorSalad_> (cabal install split)
14:49:21 <CakeProphet> edwardk: oh?
14:49:28 <edwardk> CakeProphet: that spawns ANOTHER process running your program, executeFile replaces your current process
14:49:48 <CakeProphet> edwardk:  if a spawn another process and then exit immediately then it should be equivalent correct?
14:49:52 <Esteth> aha, thanks. Strikes me that chunk/split should be in Data.List
14:50:05 <FunctorSalad_> monochrom: hmm I'd have recalled the chunks/unfoldr if I had saved it ;)
14:50:20 <FunctorSalad_> @where -xnmr
14:50:20 <lambdabot> I know nothing about -xnmr.
14:50:24 <FunctorSalad_> @where nmr
14:50:24 <lambdabot> I know nothing about nmr.
14:50:24 <edwardk> CakeProphet: no, because there is a whole mess of things you'd need to understand about child processes, zombies, what winds up in the background, etc.
14:50:42 <FunctorSalad_> hmm I thought I stored the -Xnomono... there once ;)
14:51:31 <monochrom> -XNomonomorphismRestriction
14:51:39 <monochrom> err
14:51:43 <monochrom> -XNoMonomorphismRestriction
14:51:50 <CakeProphet> edwardk: another question. will executeFile close fds?
14:51:50 <FunctorSalad_> @where nmr -XNoMonomorphismRestriction
14:51:51 <lambdabot> I know nothing about nmr.
14:51:55 <FunctorSalad_> @where+ nmr -XNoMonomorphismRestriction
14:51:55 <lambdabot> Nice!
14:52:07 <monochrom> you may as well ask me
14:52:35 <FunctorSalad_> monochrom: I do remember the spelling... it's for saving typing when telling it to others ;)
14:53:05 <FunctorSalad_> which could be achieved by an xchat rule...
14:53:21 <SubStack> > [ n < 5 || n > 10 ? 0 $ n * 10 | n <- [3..13] ]
14:53:22 <lambdabot>   [0,0,50,60,70,80,90,100,0,0,0]
14:53:32 <SubStack> yay, can do infixr in a @let
14:53:45 <CakeProphet> @where
14:53:45 <lambdabot>  @where <key>, return element associated with key
14:53:51 <CakeProphet> @where getProgramName
14:53:51 <lambdabot> I know nothing about getprogramname.
14:53:53 <FunctorSalad_> SubStack: how?
14:53:53 <CakeProphet> :)
14:54:00 <SubStack> @let infixr 1 ?
14:54:01 <lambdabot>  <local>:8:9:
14:54:01 <lambdabot>      Multiple fixity declarations for `?'
14:54:02 <lambdabot>      also at  <local>...
14:54:08 <FunctorSalad_> I see
14:54:10 <SubStack> well, already declared it, but yeah
14:54:27 <edwardk> CakeProphet: probably not. ;) 
14:54:39 <monochrom> @let data Monochrom = Monochrom
14:54:40 <lambdabot>  Invalid declaration
14:54:43 <monochrom> oh well
14:54:52 <zygoloid> > True ? True ? True $ False
14:54:53 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> GHC.Bool.Bool'
14:54:53 <lambdabot>         again...
14:54:54 <ddarius> monochrom: @where rwh and @where lyah and others are used commonly.
14:55:00 <CakeProphet> ah. getProgName
14:55:06 <FunctorSalad_> I suppose the problem holding back hayoo-on-the-irc is figuring out how to write a lambdabot plugin, not with hayoo? ;)
14:55:25 <FunctorSalad_> hayoo will even send you json if you like
14:56:22 <ddarius> Most of the lambdabot plugins that exist were written by beginners.
14:56:35 <FunctorSalad_> @where+ where ^^^^^^
14:56:35 <lambdabot> Done.
14:56:46 <dons> plugins are actually very easy to write
14:57:03 <dons> there's a small DSL for the infrastructure parts, so you just focus on adding a String -> String reponse function
14:57:05 <zygoloid> @where where
14:57:05 <lambdabot> ^^^^^^
14:57:06 <FunctorSalad_> good to know :)
14:57:10 <zygoloid> nice
14:57:45 <FunctorSalad_> I was intimidated from it from all the people asking here how to get the bot to build, maybe
14:57:47 <FunctorSalad_> :)
14:58:01 <zygoloid> yeah, that was a ghc version incompatibility sort of thing
14:58:23 <FunctorSalad_> dons: hmm... hayoo would be String -> IO String
14:58:28 <dons> well, it may be hard to build these days. unknown.
14:58:32 <Taejo> how do I convert between ListT Identity a and [a]?
14:58:52 <FunctorSalad_> (and not sure how useful it would be given 3 lines of space?)
14:58:54 <ddarius> There should be a runListT function or something similarly named.
14:59:20 <FunctorSalad_> for the broken ListT?
14:59:29 <FunctorSalad_> @unmtl ListT m a
14:59:30 <lambdabot> m [a]
14:59:31 <Taejo> FunctorSalad_: in MTL
14:59:52 <FunctorSalad_> ('broken' as in "must execute the side effects for the whole list at once")
14:59:55 <Taejo> ah, runIdentity . runListT works in one direction
15:00:01 <edwardk> Taejo: rnIdentity . runListT
15:00:11 <FunctorSalad_> there's a package where every cons cell is wrapped in `m'
15:00:23 <ddarius> :t msum . map return
15:00:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
15:00:30 <FunctorSalad_> executing side effects only when needed
15:00:33 <edwardk> taejo to go the other direction ListT . Identity ;)
15:00:38 <verdelyi> can I define in a module what NOT to export? (the opposite of module M ( export1, export2) where ...)
15:00:49 <monochrom> no
15:01:13 <verdelyi> hmm
15:01:14 <FunctorSalad_> using an auxilliary module
15:01:25 <FunctorSalad_> let M export everything...
15:01:27 <monochrom> on the bright side, the export list also informs haddock how to order things, add section headings...
15:01:42 <FunctorSalad_> then in the aux module, module M2(module M) where { import M hiding(blah) }
15:01:42 <Taejo> FunctorSalad_: is it's broken even for things like ListT Writer?
15:02:11 <edwardk> verdelyi: functorsalad gives the only real way. define module MyModule.Internal where ... and then module MyModule ( module MyModule.Internal) where import MyModule.Internal hiding (...)
15:02:14 <verdelyi> FunctorSalad_: huh nice trick thx
15:02:41 <FunctorSalad_> Taejo: for Writer it amounts to eagerly producing the writer output instead of only producing the output associated to the first element if you bind the first element
15:02:46 <edwardk> but the haddocks you get will suck =)
15:02:55 <FunctorSalad_> though with a lazy monoid op it may not matter?
15:03:50 <FunctorSalad_> depends on Writer.Strict vs Writer.Lazy too maybe...
15:03:52 <Taejo> FunctorSalad_: I'm using | StateT s (ListT (WriterT (Sum Int) Identity)) a |, and I want to count the number of branches in my non-determinism
15:05:03 <FunctorSalad_> Taejo: maybe 'broken' was exaggerating; it is just unnecessarily "strict" with respect to how many side-effects happen (side-effects in the ListT IO picture)
15:05:18 <Taejo> ok
15:05:41 <ddarius> ListT is actually broken insofar as ListT M is not a monad for non-commutative monads M.
15:05:59 <FunctorSalad_> e.g. appendListT {- name made up -} l1 (liftIO (putStrLn "oh no") >> l2)
15:06:21 <FunctorSalad_> then obtaining the first element will print 'oh no' AIUI
15:06:22 <Taejo> ddarius: is it non-broken for commutative M?
15:06:28 <CakeProphet> hmmm, anyone familiar with Erlang?
15:06:31 <ddarius> Taejo: Yes.
15:06:44 <CakeProphet> I was wondering how I could get the link/monitor semantics of Erlang processes with Haskell threads
15:06:55 <Taejo> ddarius: excellent, so Writer is safe, but State is not
15:07:17 <FunctorSalad_> appendListT = liftM2 (++), modulo newtypes....
15:07:37 <ddarius> Writer (Sum Int) is safe because Sum Int is a commutative monoid.
15:07:42 <FunctorSalad_> aka mplus I guess ;)
15:08:35 <FunctorSalad_> hmm I see how it orders the monadic effects, but why the wrong way?
15:09:40 <verdelyi> some dumb TH question if you don't mind: http://fpaste.org/GaD0/ how can I change the "Feldspar.Core.InstanceGenerator" part in that TH quotation?
15:10:37 <FunctorSalad_> verdelyi: crowbar method: Data.Generics.everywhere ;)
15:10:56 <edwardk> ddarius: i'm not sure i buy that statement. writer isn't commutative, no?
15:11:01 <verdelyi> FunctorSalad_: umm can you point me to some rtfm about that?
15:11:25 <edwardk> oh i see what you're saying =)
15:12:14 <FunctorSalad_> verdelyi: http://hackage.haskell.org/package/syb , but learning it from the haddock may be a challenge
15:12:41 <FunctorSalad_> verdelyi: your case would be something like: everywhere (mkT f) where f is a function modifying names
15:12:46 <msieradzki> why are there packages on hackage with no haddock docs?
15:13:02 <msieradzki> available on hackage.org I mean basic ones
15:13:07 <msieradzki> list of functions/modules
15:13:18 <FunctorSalad_> verdelyi: to modify the name you'd want to convert from/to String
15:13:18 <verdelyi> FunctorSalad_: you mean it would traverse that AST and apply f everywhere?
15:13:28 <FunctorSalad_> one direction is mkName... don't remember the other
15:13:32 <FunctorSalad_> maybe just Show ;)
15:13:49 <verdelyi> show usually works with Name, yes
15:13:49 <FunctorSalad_> verdelyi: yes, at types where f applies
15:14:02 <FunctorSalad_> (f must be monomorphic for that to work)
15:14:11 <FunctorSalad_> i.e. fixed to Name -> Name, here
15:14:52 <FunctorSalad_> not sure if syb support was builtin in TH or was an addon package?
15:15:00 <FunctorSalad_> (support as in Data instances)
15:15:28 <verdelyi> FunctorSalad_: the original problem is that TH's staging restriction makes our code hard to generate because there are internal dependencies in every module
15:15:42 <FunctorSalad_> verdelyi: syb carries some performance penalty, which probably won't matter at all for typical TH ;)
15:15:55 <verdelyi> FunctorSalad_: so I replaced it with a phantom class and some undefined's
15:16:08 <benmachine> how difficult is basic H98 typechecking as a problem? would I be insane to attempt to implement it without examining existing algorithms?
15:16:19 <verdelyi> FunctorSalad_: and wanted to use that for generating the AST
15:16:40 <verdelyi> FunctorSalad_: but it put the exact module name and even wants to use that when $()-ing
15:16:51 <FunctorSalad_> hmm to beat the staging restriction, wouldn't a single TH module be enough?
15:17:03 <FunctorSalad_> imported by all the modules who want to splice
15:17:14 <CakeProphet> @pl restartMud path = executeFile False path []  
15:17:14 <lambdabot> restartMud = flip (executeFile False) []
15:17:18 <CakeProphet> talk about pointless. :)
15:17:26 <FunctorSalad_> ah, your problem is that the macros need the other modules in turn...
15:17:29 <FunctorSalad_> ?
15:17:36 <FunctorSalad_> due to quotation
15:17:45 * hackagebot libtagc 0.11.0 - Binding to TagLib C library.  http://hackage.haskell.org/package/libtagc-0.11.0 (AndyStewart)
15:17:48 <verdelyi> FunctorSalad_: ok but in order to be able to use [d|...|] it needs other parts of the code
15:17:55 <FunctorSalad_> yeah
15:18:05 <verdelyi> FunctorSalad_: so right now, only building the AST by hand is the only way
15:18:12 <FunctorSalad_> you don't need the other parts of code if you make the AST programmatically though
15:18:30 <FunctorSalad_> it does sound tricky if you want to keep the quotations, indeed
15:18:33 <verdelyi> FunctorSalad_: yes, but you saw the size of one of them
15:18:48 <verdelyi> there are several
15:18:53 <FunctorSalad_> well, the qual-names are the main culprit ;)
15:19:09 <verdelyi> I intended to use [|d...|] for readability
15:19:15 <verdelyi> [d|
15:19:19 <CakeProphet> @pl restartMud path = executeFile path False []   
15:19:19 <lambdabot> restartMud = flip (flip executeFile False) []
15:19:31 <CakeProphet> wonderful
15:20:00 * CakeProphet runs all of his functions through pointless and substitutes the results back in to his source code. :)
15:20:01 <aavogt> verdelyi: using [d| |] and then post-processing is common: http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/src/Data-HList-MakeLabels.html
15:20:03 <CakeProphet> for maximum obfuscation.
15:20:15 <FunctorSalad_> verdelyi: there's the hs-boot method, but it's weird enough without the staging restriction being there too ;)
15:20:21 <verdelyi> FunctorSalad_: current TH code if that counts: http://fpaste.org/3pJf/
15:20:34 <FunctorSalad_> (for circular dependencies)
15:20:57 <FunctorSalad_> what about alternating ordinary modules and TH modules then?
15:21:06 <FunctorSalad_> in order of dependencies
15:21:35 <verdelyi> sounds reasonable, once I see through all the dependencies
15:21:43 <FunctorSalad_> (I'd try to keep the [d| too if possible btw...)
15:21:44 <verdelyi> the whole thing is ~4000 lines
15:22:07 <verdelyi> written mostly by someone else
15:22:18 <aavogt> ast2 looks terrible
15:22:19 <FunctorSalad_> follow the compiler errors? ;)
15:22:34 <FunctorSalad_> (after pulling something into a seperate module)
15:22:44 <verdelyi> aavogt: any f function is appreciated that makes it nicer :)
15:23:09 <verdelyi> FunctorSalad_: I think I just began doing something like that, separating everything to modules
15:23:13 <FunctorSalad_> hmm? ast2 is not so bad
15:23:24 <FunctorSalad_> seems highly compressable ;)
15:24:06 <FunctorSalad_> verdelyi: afraid I don't know an easier solution than the options we discussed...
15:24:28 <FunctorSalad_> ghc can depend minimal imports after you do have it compiling, if that helps
15:24:32 <monochrom> heh 4000 lines
15:24:38 <FunctorSalad_> s/depend/generate/
15:24:40 <Taejo> if I'm using record syntax, where does {-# UNPACK #-} go? before the name, after the name, or after the ::
15:25:19 <verdelyi> FunctorSalad_: ok, I think I'll try to walk the modularization way
15:25:34 <verdelyi> thanks for the info
15:26:12 <FunctorSalad_> verdelyi: adding type parameters can "cut" a dependency loop btw
15:26:34 <FunctorSalad_> replace type you depend on by a parameter, tie knot only in the end
15:26:42 <verdelyi> monochrom: I even had a generator written in Java that generated 1500 lines of hs code for our compiler (generic structure walker functions)
15:27:07 <verdelyi> hmm
15:27:19 <Phyx-> 1500lines including whitespace?
15:27:26 <edwardk> Taejo: after the :: 
15:27:46 <Taejo> edwardk: thanks
15:27:47 <verdelyi> there weren't many whitespace but as far as I remember, without empty lines
15:28:49 <tg_> my keyboard decided to fix itself.
15:28:51 <tg_> > 2 + 2
15:28:53 <lambdabot>   4
15:29:02 <verdelyi> Phyx-: this one is the biggest generated block http://hackage.haskell.org/packages/archive/feldspar-compiler/0.3.1/doc/html/Feldspar-Compiler-PluginArchitecture.html
15:29:03 <Phyx-> tg_: it'sa  replicator
15:29:10 <tg_> Phyx-: huzzah!
15:29:15 <tg_> the weird thing was
15:29:23 <tg_> 2 didn't work @ didn't work, 3 DID work
15:29:30 <tg_> but # didn't work with the *LEFT* shift but did work with the right shift
15:29:41 <verdelyi> Phyx-: I mean http://hackage.haskell.org/packages/archive/feldspar-compiler/0.3.1/doc/html/src/Feldspar-Compiler-PluginArchitecture.html
15:29:56 <tg_> that's what i get for cleaning my keyboard with soapy water and taking it apart
15:29:58 <CakeProphet> anyone mind checking the correctness of this program for me
15:30:01 <CakeProphet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27178#a27178
15:30:16 <CakeProphet> correctness as in canonicitiy and all that.
15:30:33 <edwardk> verdelyi: sounds like a job for template haskell ;)
15:31:00 <Phyx-> verdelyi: nice, I have one myself, though kinda odd, wrote 8k lines and up till i've generated like 2k lines total :P
15:31:03 <verdelyi> edwardk: yes, the 2nd version of the generator is (well, will be) exactly  TH
15:31:57 <verdelyi> Phyx-: for me the advantage was that any change in the structure, one click and the modified version is there
15:32:15 <soupdragon> CakeProphet canonicitiy?
15:32:20 <soupdragon> oh you don't mean any technical term
15:32:25 <Phyx-> verdelyi: same for me, and i've regenerated alot of time
15:32:38 <tg_> soupdragon: I think he just wants a nod of approval from the Haskell elite
15:32:39 <Phyx-> I found alot of bugs unfortunately when running it over Cabal :/
15:32:40 <soupdragon> I thought you meant like, formal correctness
15:32:41 <Phyx-> so fixing those now
15:33:01 <CakeProphet> soupdragon: no, not at all.
15:33:07 <soupdragon> s/case (eventMsg) of/case eventMsg of/
15:33:12 <Feuerbach> Does anyone have experience of using binary + network-bytestring for IPC?
15:33:16 <soupdragon> but it's fine otherwise
15:33:25 <CakeProphet> soupdragon:  ah. Habit from C/Java. :P
15:34:05 <Phyx-> is the "vector" package good? I'm hoping to get some speed using it over my current listy implementation
15:34:32 <tg_> Phyx: I don't think it's supposed to be speedy
15:34:47 <Feuerbach> Phyx-: yeah, it should be better than using lists
15:34:59 <CakeProphet> @pl hPrompt h s = hPutStrLn h s >> hGetLine h
15:34:59 <lambdabot> hPrompt = ap (flip . ((>>) .) . hPutStrLn) hGetLine
15:34:59 <Feuerbach> tg_: why? Afaik it's the point of it
15:35:07 <tg_> Phyx-: but clearly I don't know what the hell I'm talking about
15:35:14 <tg_> Feuerbach: hehe
15:35:16 <Phyx-> lol
15:35:26 <Phyx-> Feuerbach: ok, cool. will give it a try
15:35:39 * tg_ stuffs a big pile of vector in his mouth
15:35:40 <Phyx-> i generate alot of lists in this code, and 1.2secs is way to slow
15:36:51 <ezyang> Blah. It looks like I need separate functions of type a -> a and (forall a. a) -> (forall a. a) 
15:36:56 <ezyang> That's annoying 
15:37:19 <tg_> ezyang: are you in school this semester?
15:37:31 <tg_> i liked your article so I e-stalked you a bit (read your homepage)
15:37:42 <tg_> keep up the good work and focus. You'll go a long way :)
15:38:35 <ezyang> tg_: haha, thanks! yeah, Iâll be a Junior next year 
15:38:35 <CakeProphet> @src ap
15:38:35 <lambdabot> ap = liftM2 id
15:38:46 <CakeProphet> :t liftM2
15:38:47 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:38:57 <tg_> MIT was my ideal school but I didn't have the grades, so I went to Georgia Tech (in state)
15:38:58 <centrinia> :t liftM3 id
15:38:58 <lambdabot> forall a2 a3 r (m :: * -> *). (Monad m) => m (a2 -> a3 -> r) -> m a2 -> m a3 -> m r
15:39:05 <tg_> though I didn't apply because I couldn't really afford either :)
15:39:35 <tg_> Is Haskell taught there? I assume you're doing all of this work on your own.
15:39:41 <CakeProphet> :t ap
15:39:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:39:53 <CakeProphet> hmmm
15:40:05 <CakeProphet> so ap just like... composes lift operations?
15:40:10 <ezyang> Yep! 
15:40:31 <ezyang> It can also be written as <*> 
15:40:35 <ezyang> for the suggestive notation 
15:40:41 <ezyang> f <$> a <*> b <*> c 
15:40:53 <CakeProphet> ooooh
15:41:06 * Zao gets horrible flashbacks from uuparsinglib.
15:41:49 <tg_> http://brownsharpie.courtneygibbons.org/?p=359
15:41:54 <tg_> that was the first hit for suggestive notation
15:42:06 <CakeProphet> @src <$>
15:42:06 <lambdabot> f <$> a = fmap f a
15:42:10 <CakeProphet> ah.
15:42:18 <tg_> CakeProphet: that's so cheap
15:42:29 <tg_> <$> is just infix fmap?
15:42:37 <tg_> @src <`>
15:42:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:42:49 <tg_> @src <^>
15:42:49 <lambdabot> Source not found. :(
15:43:00 <CakeProphet> :t <$>
15:43:01 <lambdabot> parse error on input `<$>'
15:43:05 <CakeProphet> :t (<$>)
15:43:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:43:10 <tg_> :t fmap
15:43:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:43:14 <CakeProphet> not sure why I was expecting differently...
15:43:21 <tg_> that's so cheap
15:43:23 <CakeProphet> I guess I just don't trust @src, since someone told me not to.
15:43:42 <tg_> i need to note to link <$> to fmap in all of my source docs
15:43:56 <CakeProphet> tg_:  define cheap. :)
15:44:24 <tg_> CakeProphet: disappointing that I didn't learn that sooner. *grimace*
15:44:49 <CakeProphet> tg_:  I didn't know what <$> was until now. What did you think it was?
15:45:08 <tg_> CakeProphet: I didn't know, but I am sure I would have understood some xmonad code I read a few months ago a lot better had I known that.
15:45:30 <tg_> I thought that infix operators were always... explicitly infix.
15:45:51 <tg_> > @src `fmap`
15:45:52 <lambdabot>   <no location info>: parse error on input `@'
15:45:55 <tg_> @src `fmap`
15:45:56 <lambdabot> Source not found. Where did you learn to type?
15:46:37 <monochrom> fmap is a type class method, multiple implementations depending on actual types
15:46:44 <tg_> weird.
15:46:55 <tg_>   the command :t doesn't work in PM with lambda
15:46:57 <monochrom> fmap for lists is map.
15:47:06 <Phyx-> tg_: try @type
15:47:34 <tg_> Phyx-: ok. I need to note it anyhow, as I decided to try and write lbot2.0
15:47:50 <Phyx-> ah ok :)
15:47:59 <tg_> clearly something I'm not prepared to do.
15:48:28 <tg_> But it's a specific, personally desirable, useful example codebase where other people will have lots to contribute and existing code is available.
15:48:28 <Phyx-> no better way to get better then taking on a project you think is too difficult
15:48:54 <tg_> And the actual project I want to do in haskell is not clear in concept yet.
15:49:01 <tg_> yeah.
15:49:45 <tg_> I am confident I will learn it. I have never found a language I can't learn yet. Except Mandarin.
15:50:17 <CakeProphet> tg_:  I'm basically getting in over my head with my MUD codebase. 
15:50:26 <Phyx-> I have, I can't learn PHP
15:50:29 <Phyx-> I try.. but..
15:50:31 <Phyx-> ug..
15:52:13 <tg_> I had originally typed s/yet./yet, though there are several that I quickly decided I didn't want to./
15:52:34 <tg_> I knew perl though. I can't understand why anyone who knows any perl would choose to write anything in PHP.
15:52:48 <tg_> In fact, I wager $1 fake e-dollar that no such person exists.
15:53:43 <Zao> tg_: Few people work alone.
15:54:50 <tg_> Zao: elaborate, please?
15:55:19 <Zao> tg_: PHP tends to be a lowest common denominator.
15:59:41 <geheimdienst> so, i have another newbie question. how do i shut up the warning "defaulting constraints to type integer"? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27181#a27181
15:59:57 <geheimdienst> i tried inserting ":: Integer" into the expression at random places, but no luck
16:00:00 <soupdragon> {-# LANGUAGE NoMonomorphismRestriction #-}
16:00:30 <tg_> @src print
16:00:30 <lambdabot> print x = putStrLn (show x)
16:01:07 <monochrom> @type properFraction
16:01:08 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
16:01:10 * hackagebot snap-core 0.2.8 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.8 (GregoryCollins)
16:01:10 <soupdragon> geheimdienst: that ^ as the first line of your fiele
16:01:21 <geheimdienst> soupdragon, that doesn't help in this case. thanks anyway.
16:01:54 <soupdragon> oh
16:02:17 <monochrom> subsec is expected to be Double, is that right?
16:02:37 <monochrom> (properFraction :: Double -> (Integer,Double))
16:02:42 <monochrom> there are other ways
16:03:11 * hackagebot snap-server 0.2.8 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.8 (GregoryCollins)
16:03:19 <geheimdienst> (i inserted NoMoRe into tiny test program, and also, the bigger program where i got those lines from has NoMoRe anyway)
16:03:32 <monochrom> it is hard to fix because the integer part is deliberately thrown away (by using snd). it's hard to specify the type of what you throw away!
16:04:46 <geheimdienst> it's something integer-ish which Data.Time uses. it's a Data.Fixed.Pico, which in turn is a Data.Fixed.Fixed Data.Fixed.E12. so i guess that would be a 12-digit number or
16:06:20 <monochrom> then (properFraction :: Pico -> (Integer,Pico))
16:06:36 <verdelyi> is it intentional from GHC that it matters where I put a $(...) within a file? (I mean if I put it before X classdef or after Y instancedef, it doesn't work, and vica versa)
16:07:15 <geheimdienst> oh wow. it works if i replace properFraction with this: (properFraction :: (RealFrac a => a -> (Integer, a)))
16:07:39 <verdelyi> I thought the staging restriction is there because it needs all dependencies to do the $() and then compile the next one as a "simple" (non-TH) .hs
16:08:18 <monochrom> that's even better!
16:08:30 <g_cross> Quick question:  What's the best way to convert FilePath to [Word8]?
16:08:38 <geheimdienst> monochrom, your solution works too. thanks a lot. i totally didn't realize ghc was warning me about the fst of the tuple
16:09:11 <geheimdienst> monochrom, you think? i mean, it's a great deal longer :-/
16:09:29 <geheimdienst> @hoogle FilePath -> [Word8]
16:09:29 <lambdabot> Prelude fail :: Monad m => String -> m a
16:09:29 <lambdabot> Control.Monad fail :: Monad m => String -> m a
16:09:29 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
16:09:33 <mauke> map (toEnum . fromEnum)
16:09:35 <monochrom> it saves looking up the actual type of todSec :)
16:09:50 <g_cross> Whoa, cool!
16:11:20 <g_cross> Should I be able to expect that Char will be of size Word8 though?
16:11:42 <mauke> no
16:11:42 <lowasse1> Oh hell no.
16:11:53 <g_cross> Yeah, so that's why I am hesitant to use something like map (toEnum . fromEnum)
16:11:57 <mauke> Char is a 21-bit type
16:11:58 <monochrom> "fail" doesn't sound very good...
16:12:11 <mauke> g_cross: then you need to decide which encoding you want to use
16:12:14 <lowasse1> verdelyi: here's a workaround
16:12:23 <lowasse1> or, let's put it anotherway
16:12:32 <geheimdienst> uh, i just wanted to see if there's a convenience function somewhere. turns out there isn't
16:12:41 <lowasse1> $(liftM2 (++) splice1 splice2) typechecks even if they're recursive
16:12:51 <lowasse1> yeah, GHC will evaluate splices sequentially
16:13:19 <g_cross> mauke:  Makes sense;  where should I look for a convenience function to decode and unpack the string?
16:13:20 <lowasse1> but combining splices so they occur at the same time is straightforward
16:13:37 <mauke> g_cross: uh, strings are decoded by definition
16:13:40 <mauke> you want to encode
16:13:46 <benmachine> g_cross: you could try the utf8-string module
16:13:48 <verdelyi> lowasse1: I'm not exactly concerned about the order of $()'s but the place of $()'s between other code
16:13:51 <hearit> =( im i reprobe a test in university like 5 times, and its easy but i dont study propertly, its like a vander robot or similar
16:14:07 <lowasse1> hmmm.
16:14:08 <monochrom> from String to [Word8] is encode. do you want utf8? utf16?
16:14:32 <mauke> utf7?
16:14:33 <lowasse1> yeah, i dunno
16:14:34 <benmachine> monochrom: I thought utf16 used two-byte things?
16:14:34 <g_cross> Awesome, that does it!  Thanks everyone.  :-)
16:14:43 <lowasse1> I just encountered that issue with a project I'm working on
16:14:45 <verdelyi> lowasse1: I mean [someCode] $(thstuff1) [somecode2] $(thstuff2) [somecode3]
16:14:49 <benmachine> uh, and by module, I mean package
16:14:53 <monochrom> Joel's minimal unicode must-know: http://www.joelonsoftware.com/articles/Unicode.html
16:14:54 <verdelyi> lowasse1: and permutations
16:15:01 <mauke> benmachine: two or four byte things
16:15:09 <g_cross> It actually doesn't matter in this casebecause I am feeding the result into a hashing function that takes in a [Word8]
16:15:09 <geheimdienst> benmachine, google "surrogate pairs" :)
16:15:10 <monochrom> oops yeah utf16 is probably best for Word16
16:15:50 <monochrom> then utf8 definitely
16:16:01 <benmachine> g_cross: utf8-string has a function fromString
16:16:07 <benmachine> that will take you String -> [Word8]
16:16:14 <benmachine> erm, I think
16:16:32 <benmachine> ah yes
16:16:45 <g_cross> Yeah, that looks like exactly what I was looking for.  Thanks!  :-)
16:16:50 <monochrom> neato
16:16:59 <g_cross> BTW, what is Haskell converging towards in how Unicode is handled?
16:17:11 <danharaj> pi over 6
16:17:18 <g_cross> is String assumed to be in Unicode?  :-)
16:17:18 <benmachine> wait a sec, http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Codec-Binary-UTF8-Generic.html#t%3AUTF8Bytes
16:17:19 <geheimdienst> i thought everything in the world is converging towards utf8
16:17:42 <benmachine> with that functional dependency, how is there UTF8Bytes ByteString Int64 and UTF8Bytes ByteString Int
16:17:43 <mauke> g_cross: yes
16:17:55 <zygoloid> geheimdienst: String is defined to be [Char]. Char is defined to be a unicode codepoint.
16:18:02 <benmachine> surely the functional dependency says, only one of those please
16:18:06 <zygoloid> s/geheimdienst/g_cross/ :(
16:18:12 <benmachine> oh it's a different kind of bytestring :/
16:18:15 <lowasse1> yeah
16:18:17 <lowasse1> lazy vs strict
16:18:21 <benmachine> I wonder why one uses Int64 and the other Int
16:18:30 <lowasse1> lazy ones can be much longer
16:18:38 <zygoloid> benmachine: because a strict one really can't be very big :)
16:18:39 <benmachine> oh, I suppose that makes sense
16:18:43 <lowasse1> more than could fit in memory at once
16:18:48 <benmachine> because they don't need to fit in memory all at yes that
16:19:06 <g_cross> mauke:  Okay, that's good to know.  Thanks!
16:19:19 <lowasse1> btw, does anyone know if ï»¿is the following are equivalent? (\ x -> (f (x `cast` a)) `cast` b) =?= (f `cast` (a -> b))
16:19:44 <zygoloid> g_cross: there's some nastiness in filename handling, but that's caused by unix versus windows differences, not by haskell itself :(
16:19:58 <benmachine> :t cast
16:20:00 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
16:20:01 <mauke> which one of those isn't a syntax error?
16:20:09 <lowasse1> lol, not that kind of cast
16:20:21 <chrisdon`> i've made a little program that downloads reddit's proggit feed periodically and rates the freshness of the feed. it's fun making little stable web services with haskell with a json interface
16:20:21 <benmachine> right, I thought not
16:20:23 <lowasse1> the dirty ones GHC uses internally when it can prove your program typechecks
16:20:32 <lowasse1> like the newtype ones
16:21:25 <chicom___master> anyone mmprog in haskell?
16:21:38 <chicom___master> I am applying job and game is mmprog in c++
16:23:49 <zygoloid> lowasse1: they're not equivalent at all. the former assumes f :: a -> c, x :: d. the latter assumes f :: c -> d, x :: a.
16:26:01 <zygoloid> if you mean just (\x -> (f x) `cast` b) =?= ((f :: c -> b) `cast` (a -> b)), then i don't know
16:27:25 <astroboy> I have just upgraded to ghc 6.12.1 (with gentoo) and I am rebuilding all the packages, but when building Network it says: http://pastebin.com/jmTqaSeJ
16:30:21 <geheimdienst> astroboy, if you increase verbosity, does that give you any clues? might be that the package containing Stream somehow gets hidden or can't be found
16:31:27 <astroboy> geheimdienst: actually I am running haskell-updater to do that. Is there a way to increase verbosity with that tool?
16:33:37 <geheimdienst> i don't know ... have you checked haskell-updater --help ?
16:36:15 <astroboy> geheimdienst: there doesn't seem to be a verbose option. what's the traditional way of installing it?
16:36:42 <geheimdienst> i guess: cabal install -v network
16:36:55 <geheimdienst> however i'm not sure if that might interfere with haskell-updater
16:37:03 <geheimdienst> (i don't use gentoo)
16:37:37 <astroboy> mhm...
16:37:55 <astroboy> But if I find out which package provides that module
16:42:44 <medfly> @hoogle (a->b->a) -> b -> [a] -> b
16:42:45 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
16:42:45 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
16:42:45 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
16:42:56 <medfly> hmm...
16:43:20 <soupdragon> :t foldl
16:43:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:43:40 <lowasse1> it's the same
16:43:43 <lowasse1> just with a and b switched =P
16:43:46 <medfly> how do I go about making Haskell evaluate something strictly?
16:44:28 <medfly> I get a stack overflow.
16:45:23 <lowasse1> medfly: show us the code
16:45:28 <jesuLippers> #1 GAY NIGGER SPAMMER BIKCMP HAS A MESSAGE FOR YOU: I'm not a goth. Many goths say this, but I'm really not one. Well, OK, I wear black. And I like goth music. And regularly go to goth clubs. Argh, and I've been known to wear silly goth outfits when I go. But I'm still not a goth.
16:45:46 <medfly> foldr ((+) . (\n->1/n^2)) 0 [1..10^10] -- <- that's all.
16:45:49 <medfly> ^^
16:45:55 <lowasse1> lawl
16:45:59 <kayQww> #1 GAY NIGGER SPAMMER BIKCMP HAS A MESSAGE FOR YOU: I disagree with the software "Fruity Loops" on the grounds that only 50% or less of the musicians that use this software are actually homosexual. I think they need to either change the name of the software, or have some kind of provision in the EULA that you can only use it if you're gay. Stop faking the funk already.
16:46:02 <Groupenemnone> #1 GAY NIGGER SPAMMER BIKCMP HAS A MESSAGE FOR YOU: I disagree with the software "Fruity Loops" on the grounds that only 50% or less of the musicians that use this software are actually homosexual. I think they need to either change the name of the software, or have some kind of provision in the EULA that you can only use it if you're gay. Stop faking the funk already.
16:46:05 <medfly> @where ops
16:46:06 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
16:46:27 --- mode: ChanServ set +o mauke
16:46:28 --- kick: kayQww was kicked by mauke (kayQww)
16:46:28 --- mode: mauke set +b *!*@gateway/web/freenode/ip.189.10.100.34
16:46:30 --- kick: Groupenemnone was kicked by mauke (Groupenemnone)
16:46:30 <lowasse1> foldl' (+) [1/n^2 | n <- [1..10^10]]
16:46:38 <lowasse1> > ï»¿foldl' (+) [1/n^2 | n <- [1..10^10]]
16:46:39 <lambdabot>   <no location info>: lexical error at character '\65279'
16:46:42 <lowasse1> aww
16:46:43 <medfly> o.O
16:46:47 <lowasse1> one sec
16:46:50 --- kick: jesuLippers was kicked by mauke (jesuLippers)
16:46:50 --- mode: mauke set +b *!*@gateway/web/freenode/ip.189.108.210.38
16:46:53 <danderson> mauke: /ban *!*@gateway/web/*
16:46:56 <medfly> :t foldr'
16:46:57 <lambdabot> Not in scope: `foldr''
16:47:00 <medfly> okay...
16:47:05 <danderson> there's an attack going on all over freenode from their web gateway
16:47:05 <lowasse1> sum [1/(fromIntegral n :: Double)^2 | n <- [1..10^10 :: Integer]]
16:47:07 --- mode: mauke set +q *!*@gateway/web/freenode/ip.*
16:47:12 <lowasse1> > ï»¿ sum [1/(fromIntegral n :: Double)^2 | n <- [1..10^10 :: Integer]]
16:47:13 <lambdabot>   <no location info>: lexical error at character '\65279'
16:47:19 <lowasse1> wut
16:47:36 <medfly> > sum [1/n^2 | n <- [1..10]]
16:47:37 <lambdabot>   1.5497677311665408
16:47:43 --- kick: ekrjwe_Pwll9kwe was kicked by mauke (ekrjwe_Pwll9kwe)
16:47:43 --- mode: mauke set +b *!*@gateway/web/freenode/ip.222.28.145.124
16:47:47 --- kick: oerjQww_lunar was kicked by mauke (oerjQww_lunar)
16:47:48 --- mode: mauke set +b *!*@gateway/web/freenode/ip.200.52.66.194
16:47:53 <medfly> > foldl' (+) [1/n^2 | n <- [1..10]]
16:47:54 <lambdabot>   No instance for (GHC.Num.Num [t])
16:47:54 <lambdabot>    arising from a use of `e_112110' at <i...
16:47:56 <medfly> odd.
16:48:03 <lowasse1> ï»¿> foldl' (+) 0 [1/n^2 | n <- [1..10]]
16:48:12 <medfly> oh, right.
16:48:15 <danderson> mauke: with the blanket ban, you're all set. Banned hostmasks cannot join, and cannot speak if already joined
16:48:24 <danderson> eventually those still joined will drop off
16:48:27 <mauke> danderson: wasn't a ban
16:48:45 <danderson> oh, my bad.
16:49:31 <lowasse1> foldl' (+) 0 [1/n^2 | n <- [1..10^7]] works just fine
16:49:47 --- mode: mauke set -o mauke
16:50:10 <astroboy> geheimdienst: at the end I solved upgrading to network 2.2.1.7
16:51:12 <astroboy> geheimdienst: actually I should've checked the Network module page. Version 2.2.1.2 fails with ghc 6.12.1.
16:52:46 <medfly> huh, so unless the thread that took up the memory is killed, it keeps holding onto the memory? can't free it? I seem to have heard about it somewhere before.
16:53:03 <CakeProphet> what is a varsym?
16:53:06 <geheimdienst> weird. clearly an inconvenience. but it's great that it's fixed in 2.2.1.7
16:53:16 <medfly> @hoogle foldl'
16:53:16 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
16:53:16 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
16:53:16 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
16:53:25 <Phyx-> hmm, Is an SDoc more efficient than a String?
16:53:30 <Phyx-> a*
16:53:39 <lowasse1> @hoogle SDoc
16:53:39 <lambdabot> No results found
16:53:40 <Phyx-> well, screw efficiency, is it faster?
16:53:46 <lowasse1> .........
16:54:07 <medfly> lowasse1, thanks
16:54:08 <Phyx-> lowasse1: it's an internal GHC structure used for pretty printing
16:54:24 <lowasse1> the ..... was for "screw efficiency, is it faster"
16:55:11 <CakeProphet> > f Prelude.. g
16:55:12 <lambdabot>   Not in scope: `Prelude..'
16:55:26 <dpratt71> so I'm reading what I would guess is the canonical paper on zippers...
16:55:26 <Phyx-> lowasse1: well, they'll be destroyed almost as soon as they're created.. if i can just keep the SDocs and convert between them an CWString I should gain a few ms
16:55:34 <dpratt71> ...and trying to translate one of the examples to a tree with a slightly different structure
16:55:42 <lowasse1> what're you using it for?
16:55:43 <dpratt71> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27182#a27182
16:56:10 <dpratt71> (not sure if go_up is right
16:56:32 <lowasse1> you should have
16:56:37 <Phyx-> lowasse1: traversing the generated AST for a haskell file, then marshalling it
16:56:50 <lowasse1> hmmm
16:57:01 <lowasse1> then where do strings come into it?
16:57:50 <Phyx-> my current impementation is naive, it was just to get this rolling, It renders the SDocs into strings, and then later on, it converts the Strings to CWStrings for marshalling
17:00:34 <lowasse1> why not use ByteStrings?
17:00:34 * hackagebot hmatrix-gsl-stats 0.1.2.2 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.2 (VivianMcPhail)
17:00:35 <CakeProphet> alright, what should I look at first for serialization in Haskell?
17:00:36 * hackagebot hstatistics 0.2.1.1 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.1.1 (VivianMcPhail)
17:01:29 <CakeProphet> according to Wikipedia. show and read is serialization in Haskell. 
17:01:47 <Phyx-> lowasse1: for what?
17:01:53 <lowasse1> in place of Strings?
17:02:00 <lowasse1> if that's what you're concerned about
17:02:06 <Phyx-> i'm getting rid of that intermediate step all together
17:02:09 <lowasse1> CakeProphet: look up the binary package
17:02:10 <lowasse1> oh
17:02:10 <lowasse1> heh
17:02:19 <lowasse1> then I'm not sure what you're doing at all
17:03:09 <Phyx-> ok, Naive approach Doc -> String -> CWString only because it was basically function composition to get that working
17:03:49 <lowasse1> okay, I have no idea what a CWString is, and I need to go home
17:04:11 <Phyx-> lowasse1: it's a C Wide Char
17:04:18 <lowasse1> oh, weird
17:04:44 <CakeProphet> lowasse1:  actually I think for my purposes I can get away with show/read. I don't need to serialize massive amounts of data at all.
17:04:50 <CakeProphet> just need to save some state
17:05:32 <lowasse1> oh, then what's the problem?
17:05:36 <Phyx-> lowasse1: not so weird when using it with FFI, since it's a Ptr CChar , and in C you would then expect a wchar_t*
17:05:53 <CakeProphet> lowasse1:  no problem, I just didn't consider that read/show would be a possible solution.
17:05:58 <Phyx-> atleast on windows ghc always uses wchar
17:07:24 <lowasse1> oh lol
17:07:29 <lowasse1> okay train catching time
17:07:50 <geheimdienst> lowasser `catch` train
17:10:42 <Phyx-> Couldn't match expected type "Paying User" against the infered "User"
17:11:12 <Phyx-> Try getting a ticjet by using -XTrainTicket
17:13:15 <om-foxy> > (==) train exception
17:13:16 <lambdabot>   Not in scope: `train'Not in scope: `exception'
17:14:28 <orlandu63> hehe, haskell jokes
17:14:51 <geheimdienst> > jokes
17:14:52 <lambdabot>   Not in scope: `jokes'
17:15:01 <geheimdienst> orlandu63, no, they're not in scope
17:21:06 <om-foxy> @quote joke
17:21:07 <lambdabot> wrake says: "Huet also called his theorem prover Cock^H^Hq. He likes that kind of joke, apparently." atonivs "I suppose the next program we can expect from him will be called Pousse."
17:21:51 <om-foxy> @quote joke
17:21:51 <lambdabot> wrake says: "Huet also called his theorem prover Cock^H^Hq. He likes that kind of joke, apparently." atonivs "I suppose the next program we can expect from him will be called Pousse."
17:22:13 * dolio is tired of Coq jokes.
17:22:21 <om-foxy> apparently there's only one joke and it's off-colour
17:22:23 * tg_ is tired of Coq.
17:22:29 <geheimdienst> apparently there is only one joke
17:22:31 <tg_> @joke
17:22:32 <lambdabot> Maybe you meant: join more vote
17:22:40 <medfly> @quote
17:22:40 <lambdabot> <aristid> says: i only read bold text ;)
17:22:43 <tg_> there are tons of quotes
17:22:46 <tg_> i saw the file
17:22:53 * soupdragon wishes I could figure out how to make CoqMT do pi-conversion
17:22:55 <om-foxy> @quote missile
17:22:55 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
17:23:25 <tolkad> Do you guys think haskell should be legal? I mean, it's not really fair for people who graduated before functional languages even existed because it might be hard for them to learn haskell. It might be more fair and better for everyone as a whole if they just make it illegal
17:23:35 <tg_> You know, if it weren't Simon talking about firing the missles all the time, it would be a loss less endearing.
17:23:42 <tg_> s/loss/lot/
17:24:10 <om-foxy> tolkad: legality depends on the type of the programmer
17:24:14 <monochrom> what the bloody hell are you talking about? legal?
17:24:19 <tg_> tolkad: I tried to make the same argument about corn subsidies, but instead they took more money, grew more corn, and sell it as fuel now.
17:25:00 <om-foxy> dons: ping
17:25:39 <tolkad> monochrom: I mean they could make haskell against the law
17:25:58 <om-foxy> dons: how are instances stored in object files?  I was thinking about applying delimited control to incomplete code as a way of dynamically loading class instances
17:26:17 <chicom___master> lets make marriage illegal first
17:26:18 <tolkad> also, haskell is a complicated language it probably violates some long forgotten software patents somewhere or other which adds to my point
17:26:31 <monochrom> I declare this trolling
17:26:43 <chicom___master> I am considering trying to compiel ghc 6.12 on dragonflybsd
17:26:43 <pikhq> tolkad: All non-trivial programs violate a software patent.
17:26:51 <pikhq> Sorry, but you're in an illegal field.
17:26:57 --- mode: ChanServ set +o monochrom
17:26:59 <monochrom> I declare this trolling
17:27:02 --- mode: monochrom set +q *!*@unaffiliated/tolkad
17:27:08 --- mode: monochrom set -o monochrom
17:27:37 <geheimdienst> it seems discussing if haskell should be illegal is illegal
17:28:33 <lispy> legalized functional programming?
17:28:48 <lispy> I've heard they have that in Oregon
17:28:54 <tg_> geheimdienst: meta {that statement}
17:29:52 <geheimdienst> in amsterdam, there's lots of functional programming openly in broad daylight!
17:29:57 <medfly> !!!
17:30:03 <tg_> geheimdienst: those disgusting heathen!
17:30:10 <tg_> I bet they smoke drugs too!
17:32:04 <CakeProphet> trolls? on the internet?
17:32:05 <CakeProphet> are you sure?
17:32:32 <tg_> CakeProphet: We already made those illegal, but damn it - law doesn't seem to affect those intertubes.
17:32:58 <geheimdienst> trolls wouldn't exist without the "there's somebody wrong on the internet" crowd ... http://xkcd.com/386/
17:33:16 <tg_> hehe
17:33:24 <tg_> In their defense, there is a whole big heap of wrong in this world.
17:33:32 <tg_> But so little serious wrong is on the internet.
17:36:42 <soupdragon> but yeah anyway
17:37:01 <soupdragon> I can't seem to get past the psychological block to read about hensels lemm
17:38:08 <soupdragon> I wondre why books like Algebra of Programming are so unpopular
17:38:33 <danharaj> because programming is totally a category not an algebra.
17:38:46 <CakeProphet> soupdragon:  hmmm. People with jobs don't need to know it maybe?
17:38:50 <soupdragon> Why are boks like Category theory for Computing Science so unpopular?
17:39:45 <ClaudiusMaximus> how can i speed up:  length . show :: Integer -> Int
17:40:07 <soupdragon> maybe you can implement a fast integer logarithm
17:40:08 <soupdragon> base 10
17:40:08 <EvanR> 1 + floor(log)
17:40:30 <ClaudiusMaximus> :t log10
17:40:31 <lambdabot> Not in scope: `log10'
17:40:36 <stoltene2> Why is Matroid Theory unpopular?
17:40:37 <eikke> i'm having lots of problems with a 64bit build of ghc 6.12.[23] on OSX :s mmap above 2GB, resulting in a crash
17:40:37 <CakeProphet> :t log
17:40:38 <lambdabot> forall a. (Floating a) => a -> a
17:40:44 <CakeProphet> > log 10
17:40:45 <lambdabot>   2.302585092994046
17:40:45 <soupdragon> because matroids are STUPiID1
17:40:51 <ClaudiusMaximus> @instances Floating
17:40:51 <lambdabot> Double, Float
17:40:53 <soupdragon> I think there's some interesting results actually
17:40:55 <soupdragon> in matrooid theory
17:41:00 <CakeProphet> > logBase
17:41:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
17:41:01 <lambdabot>    arising from a use...
17:41:07 <CakeProphet> :t logBase
17:41:08 <lambdabot> forall a. (Floating a) => a -> a -> a
17:41:10 <stoltene2> It's very nice, actually.
17:41:15 <CakeProphet> ClaudiusMaximus:  there you go sir.
17:41:31 <Twey> Oh, we have a logBase?  Oops.
17:41:40 <stoltene2> Where else can you generalize parts of linear algebra and graph theory?
17:42:04 <soupdragon> hm
17:42:06 <stoltene2> But that is off topic, I suppose.
17:42:13 <Twey> logBase = flip $ on (/) log
17:42:28 <CakeProphet> :t on
17:42:29 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
17:42:42 <CakeProphet> ah.
17:42:46 <CakeProphet> I forgot about on.
17:42:53 <ClaudiusMaximus> @djinn  (b -> b -> c) -> (a -> b) -> a -> a -> c
17:42:54 <lambdabot> f a b c _ = a (b c) (b c)
17:43:20 <tg_> igor: heat =is= http://www.rasmussen.edu/student-life/blogs/main/heat-a-visual-tour/
17:43:24 <tg_> sorry
17:43:49 <ezyang> If I understand correctly, FFI imports need to be safe to interact nicely with threading? 
17:43:51 <CakeProphet> @src logBase
17:43:51 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:44:27 <ClaudiusMaximus> ezyang: that's what i understood too, but i'm (still) a bit confused
17:44:29 <ezyang> So to use unsafe properly, you need to be sure that 1. it won't call back to Haskell and, 2. there isn't a situation in which you'd like another Haskell thread to pre-empt it. 
17:44:48 <ezyang> I think the second is not quite obvious, though it follows directly from the first. 
17:45:11 <ezyang> tricky. 
17:45:38 <ClaudiusMaximus> ezyang: i think it's worse than that; as far as i understand it unsafe => whole haskell runtime (all threads) stop and wait for the foreign call to finish
17:46:02 <ezyang> I think OS threads will be ok 
17:46:14 <soupdragon> forget about using unsafe properly
17:46:17 <soupdragon> there is no such thing
17:46:41 <soupdragon> there's this joke where we pretend it's okay to use it if your code satisfies some 'pre condition'
17:47:05 <soupdragon> which was funny until stuff like amb and spoon started getting released
17:47:07 <ezyang> Hehe 
17:47:27 <soupdragon> no we're trying to fight off the collapse of an empire of purity
17:49:51 * ezyang hears the rattle of battle-gear for battle 
17:50:54 <g_cross> What confuses me, though, is that there are function such as sin() and cos() which could be external and are effectively pure and will never call any Haskell functions, so it seems like I have to choose between adding unnecessary overhead by marking them "safe" and making the runtime to do extra work to prepare for a call that will never happen, or adding "unsafe" which avoids this overhead...
17:50:55 <g_cross> ...but prevents them from being premptable even though they are pure and no problem should arise.
17:50:58 <CakeProphet> ezyang:  I haven't even made my MUD yet... are you sure?
17:51:01 <g_cross> Am I missing something here?
17:51:11 <soupdragon> g_cross: there's no trade-off
17:52:13 <ezyang> CakeProphet: Hehe, it was a nethack reference :^) 
17:52:35 <CakeProphet> oh sweet. I've never played nethack actually.
17:53:09 <CakeProphet> The only old school text-based games I've played are Ultima and Zork
17:53:19 <ezyang> soupdragon: Can you help us out and elaborate? 
17:53:24 <ezyang> CakeProphet: nethack is the classic 
17:53:31 <soupdragon> ??
17:54:26 <ezyang> soupdragon: Are you claiming that there actually is no important overhead from keeping a foreign import safe, or that itâs not a tradeoff you care about? 
17:54:34 <ezyang> (or something else) 
17:54:40 <soupdragon> i don't really undersrtand the question
17:54:47 <g_cross> To rephrase my earlier point succinctly:  it seems like there is a trade-off between paying extra overhead for a "safe" call, versus allowing pre-emption.
17:55:09 <CakeProphet> I don't think, for sin and cos at least, there's any overhead at all. You're just using the usual sin() and cos(), correct?
17:55:11 <g_cross> You can't avoid *both* costs, even neither cost is needed.
17:55:26 <g_cross> I was using them as hypotheticals.
17:55:41 <sproingie> ultima is text based?  i'd call it "tile" based
17:55:42 <g_cross> As examples of cases where you call an external function that really is pure.
17:55:57 <CakeProphet> sproingie: well, it's the closest thing to a classic text based game I've played other than Zork.
17:56:08 <ezyang> sproingie, CakeProphet: Shall we move to #haskell-blah? 
17:56:17 <CakeProphet> sure.
17:56:28 <soupdragon> lol tactful use of 'we'
17:57:36 <g_cross> Yeah, we in the haskell community are all about purity, so no impurities in the conversation for like MUDs are allowed.  ;-)
17:58:10 <geheimdienst> the impure conversation must be done in a monad
17:58:13 <ezyang> Hereâs an even more degenerate example: suppose I have a function that does a pure computation that would take an appreciable amount of time. 
17:58:43 <ezyang> What is the threshold at which I say, âIt is important for Haskell to be able to suspend this computation temporarily and run another thread?â 
17:59:29 <ezyang> &green thread 
18:02:00 <lowasser> ezyang: I'm pretty sure that Haskell forces the computation to switch back and forth
18:02:21 <ezyang> lowasser: Not if itâs unsafe. 
18:02:22 <lowasser> otherwise bottom `par` x /= x
18:02:54 <ezyang> actually, that strikes me as a really good way of demonstrating this 
18:03:20 <lowasser> oh, I just read up through the rest of the thread, lol
18:03:48 <lowasser> but bottom `par` x is semantically equivalent to x
18:04:39 <ezyang> I'm coding up a quick test. I might be wrong 
18:05:40 <g_cross> ezyang:  It would be good to test this, but I am pretty sure that I remember reading in the GHC manual that the runtime halts all threads before running unsafe calls.
18:06:15 <ezyang> yeah, Iâll check forkOS too 
18:06:26 <ezyang> halting all OS threads seems a bit... sadistic 
18:06:47 <g_cross> Yeah, especially when you are explicitly telling it that you are doing something that might be unsafe but promising that it will work.
18:07:04 <g_cross> It would make more sense to me, in fact, for it to shut down all threads when doing a _safe_ call then when doing an unsafe calls.
18:14:28 --- mode: ChanServ set +o monochrom
18:14:37 --- mode: monochrom set -q *!*@unaffiliated/tolkad
18:14:42 --- mode: monochrom set -o monochrom
18:15:06 <soupdragon> anyone know how to learn to do arithmetic in your head?
18:15:06 <ezyang> It looks like, for some reason or another, par doesnât tickle this 
18:15:11 <soupdragon> like  3 x _ = 0 (mod 5)
18:15:20 <soupdragon> how would you do that in your head
18:15:24 <ClaudiusMaximus> ezyang: as far as i understand, GHC context switches happen only on allocation, so if you have a long loop that isn't allocating anything...
18:15:38 <soupdragon> > (`mod`5) . (3*) . [0..4]
18:15:39 <lambdabot>   [0,3,1,4,2]
18:15:43 <ezyang> ClaudiusMaximus: Huh, interesting 
18:16:05 <soupdragon> > (`mod`5) . (+2) . (3*) . [0..4]
18:16:06 <lambdabot>   [2,0,3,1,4]
18:17:05 <g_cross> That makes sense;  however, it should work then if you run with two threads, since then even though one is tied up in an infinite loop the other can continue working.
18:17:21 <g_cross> (that is, by two threads I mean +RTS -N2)
18:17:54 <ClaudiusMaximus> @hoogle yield
18:17:54 <lambdabot> Control.Concurrent yield :: IO ()
18:19:09 <ezyang> Ok, I have a working test 
18:19:31 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27184#a27184 
18:19:46 <edwardk> safeBottom?
18:19:47 <ezyang> with the obvious loop 
18:20:04 <ezyang> edwardk: Safe as in safe FFI import :-) 
18:20:08 <edwardk> ah
18:21:30 <ezyang> It looks like I donât even need a yield 
18:21:44 <g_cross> So, what is the result?
18:21:46 <ezyang> but Iâll keep it in, in case the RTS changes 
18:21:53 <ezyang> the first line prints, the other doesn't 
18:22:04 <ezyang> so I'll swap it with forkOS now and see what happens 
18:22:18 <g_cross> Also, are you running the run-time with -N2 ?
18:22:33 <ezyang> Yep 
18:22:43 <g_cross> Cool;  go scientific method!  :-D
18:22:48 <ezyang> forkOS fails too 
18:22:51 <g_cross> Thanks, ezyang
18:23:00 <lowasser> I can't remember, where is the Haddock for the guts of GHC?  That is, the internal compiler stuff?
18:29:46 <kyagrd> Is there any way to document member function definitions inside class instances?
18:30:04 <kyagrd> with haddoc of course.
18:30:30 <kyagrd> haddock I mean :(
18:31:50 <edwardk> cheesy tree-based memoization example: http://stackoverflow.com/questions/3208258/memoization-in-haskell/3209189#3209189
18:32:25 <edwardk> that was fun =)
18:33:13 <soupdragon> prove that the decimal expansion of a fraction repeats
18:34:53 <ezyang> We donât see this in par because âPar doesn't actually create a new thread immediately; instead it places a pointer to its first argument in the spark pool.â 
18:36:44 <cheater99> ok, i must say haskeline isn't as dire and terrible as editline
18:37:51 <etpace> Hmm.. I'd like to tokenise a binary file hellaquick, as in using a lexer fast, is that plausable?
18:43:10 <ddarius> soupdragon: For a given rational number, you can write a program that prints out the sequence of digits using a finite, fixed size of state.  Therefore such a program can be represented by a finite state machine and therefore its output must be periodic.
18:43:16 <ddarius> (or terminate)
18:44:00 <soupdragon> that is a nice way to do it!
18:44:22 <soupdragon> I was using 1/9^k
18:47:25 <soupdragon> > 22/7 :: CReal
18:47:26 <lambdabot>   3.1428571428571428571428571428571428571429
18:47:32 <soupdragon> > 142857/7 :: CReal
18:47:33 <lambdabot>   20408.1428571428571428571428571428571428571429
18:47:59 <CakeProphet> @src swap
18:47:59 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:48:07 <soupdragon> :t flip
18:48:08 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:48:20 <CakeProphet> @djinn forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a ->  f b
18:48:20 <lambdabot> Cannot parse command
18:48:56 <CakeProphet> (Functor f) => f (a -> b) -> a ->  f b
18:49:03 <CakeProphet> @djinn (Functor f) => f (a -> b) -> a ->  f b
18:49:03 <lambdabot> Error: Class not found: Functor
18:49:23 <CakeProphet> bah.
18:49:44 <CakeProphet> @pl swap f x y = f y x
18:49:45 <lambdabot> swap = flip
18:49:55 <CakeProphet> @pl flip f x y = f y x
18:49:56 <lambdabot> flip = flip
18:50:02 <CakeProphet> -gasp-
18:50:05 <CakeProphet> genius.
18:52:01 <CakeProphet> @djinn a -> a
18:52:02 <lambdabot> f a = a
18:52:19 <CakeProphet> @djinn a -> a -> a
18:52:20 <lambdabot> f _ a = a
19:03:19 * hackagebot dbus-core 0.8.3.1 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.3.1 (JohnMillikin)
19:26:45 <soupdragon> 1 + 2 + 4 + ... = -1
19:27:11 <Pseudonym> True in 2's complement.
19:27:17 <soupdragon> :D
19:27:28 * hackagebot anansi 0.2 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.2 (JohnMillikin)
19:27:46 <soupdragon> 1/(7^2-1) = 665656565656565...
19:27:54 <napping> 2-adic as well, if I remember my old maths
19:29:26 <soupdragon> napping, some of these p-adic fields have got square roots of negatives numbers in them naturally!
19:29:29 * hackagebot Ordinals 0.0.0.2 - Ordinal arithmetic  http://hackage.haskell.org/package/Ordinals-0.0.0.2 (KiYungAhn)
19:29:38 <soupdragon> that's so weird to me because they usually come only by force
19:31:17 <JohnnyL> any of you here use Clean?
19:32:30 * hackagebot dbus-client 0.4 - Monadic and object-oriented interfaces to DBus  http://hackage.haskell.org/package/dbus-client-0.4 (JohnMillikin)
19:32:36 <napping> seems like no
19:33:08 <napping> it's not too different though, unless you are asking about the uniqueness part of the type system or the type-safe serialization
19:34:09 <soupdragon> frustrating that I can't write the types I want in haskell
19:34:18 <napping> like what?
19:34:37 <soupdragon> I just want normal numbers like 3 and whatevera
19:35:04 <napping> Oh, even Î©mega will do those
19:35:38 <soupdragon> there's a hack to do it in haskell but it's not very nice
19:35:59 <soupdragon> (by that I mean I don't understand it)
19:37:47 <napping> Or, try a proper dependently-typed language
19:38:32 <soupdragon> when I try to use a dependently-typed I start to implement category theory and it all just goes downhill from there
19:38:56 <soupdragon> I am waiting for someone else to do it well so I can just copy them 
19:40:37 <JohnnyL> afaics Clean is a purely functional language easier to read than Haskell
19:40:57 <soupdragon> yeah it's easier to read because the code is a lot "Cleaner" huhu
19:41:13 <flippo> My language "Pure" is purer.
19:41:33 <edwardk>  JohnnyL: not any more
19:41:41 <ketralnis> I prefer "The Genetically Superior Master Language"
19:42:31 <edwardk> JohnnyL: 'easier to read' is somewhat debatable. the types that result and the inability to reason about partial application, etc are pretty damn high costs just to pick up uniqueness typing
19:42:39 <napping> easier to read? I wasn't aware of any significant syntactic differences
19:42:42 <Cale> JohnnyL: It shouldn't be much different to read, though GHC Haskell has more features, so I guess there are technically more things you might have to learn about to read Haskell in general. Clean has some features that Haskell doesn't too though, like uniqueness types.
19:43:17 <soupdragon> can I ask a q to math people: Have you read Conways book The Sensual Form ?
19:43:21 <ketralnis> I'm walking through "learn yourself a haskell" and am trying to grasp typeclass instance declarations. So I'm trying to implement Functor on a "Tree a", and am not understanding the error I'm getting http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27187#a27187
19:43:29 <napping> I'm having trouble thinking of a pair of languages with more similar syntax
19:43:33 <stoltene2> No
19:43:33 <soupdragon> what is the error?
19:43:36 <ketralnis> (and the error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27188#a27188 "http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27188#a27188")
19:43:46 * geheimdienst thinks if the language is pure as in has-no-side-effects, it's gonna stay a toy language. valuable academically, but not practically
19:43:50 <edwardk> your tree map can't be a functor.
19:43:52 <ketralnis> Err, the error at the URL is "Expected kind `* -> *', but `Tree a' has kind `*'" (mis-pasted)
19:43:58 <napping> JohnnyL: both are very similar to each other and Miranda as well.
19:44:07 <soupdragon> it needs to be instance (Ord a) => Functor Tree where
19:44:16 <soupdragon> well
19:44:19 <soupdragon> that's not even correct
19:44:29 <Cale> ketralnis: You want Tree to be an instance of Functor, not Tree a
19:44:37 <soupdragon> I can't say how to fix this
19:44:42 <stoltene2> soupdragon: No, the most recent math book I'm reading is Computational Geometry by Mark de Berg
19:44:44 <soupdragon> you will need to use advanced techniques
19:44:45 <edwardk> ketralnis: if you remove the order restraint you can get a functor, but then you can't do the fast look up you want
19:44:51 <edwardk> Cale: note he assumes the Ord instance everywhere
19:45:07 <Cale> Ah, yeah, you won't be able to reorder the tree.
19:45:43 <soupdragon> stoltene2: that looks good
19:46:15 <edwardk> ketralnis: you have two problems, fmap shouldn't do anything like the to-list from-list stuff, it should be able to replace the values in place, if you need to change th shape like that what youy have is something vaguely Functor-like but not a Functor
19:46:32 --- mode: ChanServ set +o mauke
19:46:33 --- mode: mauke set -b *!*@gateway/web/freenode/ip.189.10.100.34
19:46:44 <ketralnis> And the second problem?
19:46:47 <stoltene2> soupdragon: I'm also partway through "To mock a mockingbird"
19:46:51 <edwardk> and second, you have the wrong 'kind' for the instance. you can define instance Functor Tree, but you'll note that gives you no place to put the ord restraint!
19:46:52 --- mode: mauke set -b *!*@gateway/web/freenode/ip.189.108.210.38
19:47:07 --- mode: mauke set -q *!*@gateway/web/freenode/ip.*
19:47:09 <om-foxy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27187#a27190
19:47:12 <soupdragon> stoltene2, ah I love that one!
19:47:18 <edwardk> you can define 'Foldable' for your tree, but not Functor
19:47:34 <stoltene2> soupdragon: I'm thinking of skipping the majority of the first half though.
19:47:42 --- mode: mauke set -b *!*@gateway/web/freenode/ip.222.28.145.124
19:47:46 <soupdragon> the knight/knave stuff?
19:47:46 <om-foxy> ketraInis:  why not this definition (see hpaste above)
19:47:52 --- mode: mauke set -b *!*@gateway/web/freenode/ip.200.52.66.194
19:47:54 <ketralnis> om-foxy: I'm having trouble spotting the differences
19:47:54 <stoltene2> yeah
19:47:54 <soupdragon> yeah that's sort of out of place 
19:48:03 <soupdragon> I wrote prolog programs to solve them
19:48:13 <edwardk> om-foxy: note that that breaks all of the invariants assumed by treeInsert and treeElem
19:48:15 <stoltene2> I plowed through the first 15 of the puzzles or so
19:48:20 <soupdragon> which is kind of an interesting exercise
19:48:25 <stoltene2> and then decided that I got the book for the combinator fun
19:48:33 <soupdragon> the combinator birds are brilliant though
19:48:38 <soupdragon> it is really a magical book
19:48:39 <JohnnyL> napping :)
19:48:53 <om-foxy> arg
19:49:07 <stoltene2> It is a great book.  I found it by accident.
19:49:14 <edwardk> om-foxy: this is the reason why 'Data.Set.Set' is not a Functor
19:49:52 --- mode: mauke set -o mauke
19:50:14 <ketralnis> Ah hah. So my lesson here is basically that it just can't be a functor because just can't do things like guarantee invariants on the result?
19:50:25 <edwardk> yeah
19:50:38 <soupdragon> ketralnis: you've bumped into a very technical and awkward part of haskell D:
19:50:54 <geheimdienst> wikipedia informs us that to mock a mockingbird "contains many nontrivial recreational puzzles". i guess that mus be because his other book, to buck a buckingham, contains many trivial recreational puzzles ...
19:50:56 <edwardk> Functor provides you with a lot of power. you can put ANY type you want in for 'a'. which means you can't put restrictions on it
19:51:16 <geheimdienst> *must
19:51:18 <edwardk> soupdragon: honestly, i think it is a beautiful and wonderful part. once you understand parametricity you can tackle free theorems
19:51:19 <soupdragon> geheimdienst: no seriously you are expected to prove theorems due to Godel and Curry
19:51:24 <edwardk> Functor gives you laws =)
19:51:54 <ddarius> geheimdienst: (re earlier) You're going to have to level up your trolling skill.
19:52:21 <edwardk> if you can prove fmap id = id then you can show fmap f . fmap g = fmap (f . g) MUST hold just by the types. without that parametricity guarantee, if people could smuggle dependencies on Ord, etc in, that wouldn't hold.
19:52:49 <edwardk> this gives you as a programmer many tools for working with opaque third party types, and also gives those tools to the compiler
19:53:10 <napping> hmm, what do GADTs do to your free theorems then
19:53:14 <solrize> i remember that book.  it was cool
19:54:10 <edwardk> napping, free theorems work in the presence of GADTs as well with care: http://www.seas.upenn.edu/~sweirich/talks/param-gadt.pdf
19:54:55 <napping> oh, Set isn't a functor because you can't gurantee the result of the argument to fmap will be in Ord
19:55:14 <geheimdienst> ddarius, what do you mean, that i think pure languages are not very useful? i don't see what's so trollish about that. i think side-effects are essential. what's the point of a program that doesn't have at least the side-effect of printing its result at the end?
19:55:30 <soupdragon> thats not a side effect
19:55:33 <edwardk> napping: and because the functor would replace the values in place, so the result of the mapping, the relative ordering of the elements wouldn't be necessarily respected either.
19:55:46 <stoltene2> soupdragon: Did you read the Conway book?
19:55:55 <napping> well, that depends how your equality is defined
19:56:03 <tg_> room question: anyone done/seen OCR done in Haskell?
19:56:09 <soupdragon> stoltene2, I'm on the first chapter
19:56:18 <tg_> Or have a suggestion for a good ORC package otherwise?
19:56:22 <edwardk> very well, the 'natural' definition of Functor then ;)
19:56:33 <solrize> tg_ ocropus ?
19:56:38 <ketralnis> That all makes sense soupdragon, and edwardk, and om-foxy. Thank you all very much :)
19:56:39 <napping> in particular, quotient types can handle that sort of thing nicely
19:56:48 <edwardk> ketralnis: no problem
19:57:00 <edwardk> napping: wake me when they get added to core ;)
19:57:04 <ketralnis> That's an unfortunate side-effect though :-/
19:57:30 <tg_> ketralnis: care to state what you learned, in your own words (for your benefit and for my laziness)?
19:57:56 <edwardk> napping: and sadly, while i love quotient types they are hell to reason about. there is a reason why everyone uses setoids ;)
19:58:18 <ketralnis> That a functor is a convenient abstraction in some cases where its laws hold, but you can't make its laws hold for all container types
19:58:23 * geheimdienst wonders, speaking of unfortunate side-effects, if there should be an Unfortunate monad for those
19:58:36 <ddarius> geheimdienst: We call it IO.
19:58:48 <stoltene2> soupdragon: I love when Conway takes something so complex in Euclidean Geometry and then extends it to non-euclidean.
19:59:18 <tg_> ketralnis: and, what are the laws? 
19:59:19 <tg_> ;)
19:59:25 <ketralnis> Specifically, in my posted snippet of implementing a tree, you can't cause the tree to be a functor while retaining its invariants
19:59:29 <tg_> or, the ones you were interested in
19:59:32 <edwardk> ketralnis: yeah. i go through and define Functor, Foldable and Traversable for any type for which the underlying constraints will permit them, even ones where the resulting instance seems a little odd (like Foldable/Traversable for ((,) a))
20:00:09 <edwardk> but sadly, i often wind up with just Foldable or even none of the above =/
20:00:18 <ddarius> edwardk: Why would that instance seem odd?
20:00:37 <ketralnis> I don't know all of the functor laws, but the ones that apply here is that you can't introduce new type-constraints in the process. Which means that my tree can't guarantee that it's a valid tree after applying a function to its members
20:00:42 <edwardk> ddarius: well, it seems perfectly natural to me, but i've had people complain about it
20:00:57 <ddarius> edwardk: What were their complaints?
20:01:15 <tg_> ketralnis: well said and concise. thanks :0
20:01:23 <edwardk> ddarius: well, a false intuition might be that fmap (+1) (1,2) ==> (2,3)
20:01:45 <ketralnis> Why is that a false intution?
20:01:56 <edwardk> fmap (+1) (1,2) = (1,3) ;)
20:02:06 <geheimdienst> > fmap (+1) (1,2)
20:02:06 <lambdabot>   (1,3)
20:02:11 <geheimdienst> > fmap (+1) [1,2]
20:02:12 <lambdabot>   [2,3]
20:02:13 <ddarius> ketralnis: You can tell that it doesn't make sense just from the types.
20:02:18 <ketralnis> That's curious
20:02:23 <geheimdienst> > fmap (+1) ("lol",2)
20:02:24 <lambdabot>   ("lol",3)
20:02:42 <ddarius> Admittedly, you could make a pair type constructor, data Pair a = Pair a a, where that would be the Functor instance.
20:02:42 <ketralnis> Why that and not fmap (+1) (1,2) -> (2,2)?
20:02:43 <edwardk> ketralnis: there are two type arguments to (,)
20:02:51 <edwardk> ddarius: yeah
20:02:58 <geheimdienst> > fmap (+1) ("lol",3,4,5,6,2)
20:02:58 <lambdabot>   No instance for (GHC.Base.Functor
20:02:59 <lambdabot>                     ((,,,,,) [GHC.Types.C...
20:03:05 <geheimdienst> > fmap (+1) ("lol",3,2)
20:03:06 <lambdabot>   No instance for (GHC.Base.Functor ((,,) [GHC.Types.Char] t))
20:03:06 <lambdabot>    arising fro...
20:03:11 <geheimdienst> why it no worky?
20:03:16 <ketralnis> Oh I see true, but I don't understand why
20:03:26 <ddarius> geheimdienst: No one has written the Functor instances.
20:03:38 <edwardk> geheimdienst: because the compiler guys got bored before they handled that many ,,'s ;)
20:04:03 <edwardk> ketralnis: fmap f (a,b) = (a, f b)
20:04:28 <edwardk> ketralnis: the reason is because the functor only affects the 'last type argument to (,) because the instance is for instance Functor ((,) a) where ...
20:04:31 <tg_> > fmap (+1) ("lol",2)
20:04:32 <lambdabot>   ("lol",3)
20:04:43 <edwardk> you'd need a Bifunctor to make both parameters change
20:05:02 <tg_> > fmap (+1) (2,"lol")
20:05:03 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
20:05:04 <lambdabot>    arising from the literal ...
20:05:04 <edwardk> (and then you'd still be passing in two functions)
20:05:17 <tg_> hmm?
20:05:35 <geheimdienst> tg_, what you essentially did is: "lol" + 1
20:05:41 <edwardk> tg_: can't add one to "lol"
20:05:48 <ddarius> And there is no way in current Haskell to "flip" a type constructor.
20:06:09 <edwardk> newtype Flip f a b = Flip (f b a)
20:06:13 <edwardk> =)
20:06:45 * ddarius tries to remember what that one paper on (restricted) type level lambdas had to say about instance resolution.
20:06:51 <tg_> geheimdienst: why did it work when lol was first?
20:07:02 <tg_> :t fmap
20:07:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:07:03 <tg_> @src fmap
20:07:04 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:07:08 <dolio> Because fmap :: (a -> b) -> (c, a) -> (c, b)
20:07:26 <geheimdienst> tg_, the fmap always goes for the last part of the tuple and leaves the first alone
20:07:43 <ddarius> If we had instance Functor (\a -> (a,b)) where ... how would the compiler choose the instance?
20:07:49 <edwardk> > fmap (+1) (Right 2)
20:07:50 <lambdabot>   Right 3
20:07:54 <edwardk> > fmap (+1) (Left 2)
20:07:55 <lambdabot>   Left 2
20:08:09 <edwardk> same idea there. Either takes two type parameters, the Functor instance works on the second one
20:08:19 <edwardk> ddarius: yeah i remember that paper
20:08:40 <geheimdienst> so i'm probably missing something, but for an array there's one type arg, right? for a 2-tuple, it's 2 type args. then why does the functor for an array use the 1st type arg, but for a tuple the 2nd?
20:08:54 <soupdragon> if I define a 3D model as the set of solutions to some equations what algorithm would produce a nice rough outline ? marching cubes looks horrible
20:08:55 <edwardk> the functor for the array uses the second
20:09:06 <edwardk> it is 'Array indextype elementtype"
20:09:07 <geheimdienst> :t [1,2]
20:09:08 <lambdabot> forall t. (Num t) => [t]
20:09:20 <edwardk> when you fmap over the array you fmap changing the elements, the index remains the same
20:09:38 <geheimdienst> > [1,2] !! "lolcat"
20:09:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:09:39 <lambdabot>         against inferred type ...
20:09:42 <edwardk> recall there is an Ix constraint on the index!
20:09:47 <ddarius> soupdragon: Raytracing works reasonably well in some of those cases.
20:10:03 <edwardk> soupdragon: you've just reinvented implicit surfaces ;)
20:10:05 <ddarius> geheimdienst: [] isn't an array.
20:10:08 <geheimdienst> i guess the index type is hardcoded to Int, right? as i would expect. i mean i've never heard of non-Int index types
20:10:27 <napping> soupdragon: you can try Taylor expansion
20:10:29 <geheimdienst> guys, you're confusing me. why is [1,2] not an array?
20:10:32 <edwardk> geheimdienst: [1,2,3,4] is a list, not an array
20:10:47 <tg_> :t [1,2,3,4]
20:10:48 <napping> decompose the space until a linear approximation is reasonable, and then draw that surface in each cube
20:10:48 <lambdabot> forall t. (Num t) => [t]
20:10:50 <geheimdienst> yeah okay sorry. my bad
20:10:50 <edwardk> > array (1,100) ((1,1) : [(i, i * a!(i-1)) | i <- [2..100]])
20:10:51 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
20:10:52 <lambdabot>         against inferred t...
20:10:55 <geheimdienst> i mean list, of course
20:11:05 <tg_> :t (1,100)
20:11:06 <ddarius> Also, in that case your question is odd.  "Why does the functor instance use the first of one type argument?"
20:11:06 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
20:11:55 <edwardk> data List a = Nil | Cons a (List a) -- would be a rough equivalent of the built in list. note there is only one type argument.
20:12:06 <ddarius> At any rate, Functor always expects a type constructor of one argument and that's all we give in well-kinded programs.
20:12:09 <geheimdienst> okay, so as the rule of thumb, functors always transmogrify the last argument, right?
20:12:40 <monochrom> yes
20:12:44 <edwardk> geheimdienst: well, by construction. a Functor f has f :: * -> * -- so that only matches things with one argument remaining
20:13:12 <edwardk> instance Functor Maybe; instance Functor [], instance Functor (Either a) -- anything else would fail to compile
20:13:12 <ddarius> :k Either
20:13:13 <lambdabot> * -> * -> *
20:13:15 <ddarius> :k Either Int
20:13:16 <lambdabot> * -> *
20:13:20 <ddarius> :k Either Int String
20:13:21 <lambdabot> *
20:13:25 <tg_> :k Int Int Int
20:13:26 <lambdabot>     Kind error: `Int' is applied to too many type arguments
20:13:34 <tg_> :k Either Int Int
20:13:35 <lambdabot> *
20:13:40 <tg_> :k Either Int Int Int
20:13:41 <lambdabot>     Kind error: `Either' is applied to too many type arguments
20:13:43 <geheimdienst> yeah, i just got confused by the fmap (+1) ("x", 2). but this is a ((,) String) and has kind * -> * i guess
20:13:52 <geheimdienst> and that's what the functor sees
20:13:53 <edwardk> geheimdienst: yep
20:13:55 <ddarius> :k (,) String
20:13:56 <lambdabot> * -> *
20:14:01 <tg_> :k ("x",2)
20:14:03 <lambdabot> parse error on input `"'
20:15:18 * geheimdienst can't believe that he's using scary words like "kind" and actually sorta making sense
20:15:55 <monochrom> "kind" is the opposite of "scary" anyway. "monochrom is kind" vs "monochrom is scary"
20:16:43 <edwardk> nicely as you climb up the hierarchy of sorts things get easier. ;)
20:17:11 <ddarius> edwardk: Not in general.
20:17:12 <napping> unfortunate, isn't it?
20:17:14 <edwardk> i mean all kinds have the same sort "box". types only have a few sorts, and there are no quantification tricks like forall or exists that work on kinds.
20:17:19 <monochrom> types are scary, kinds are kind :)
20:17:20 <edwardk> ddarius: well, in Haskell =)
20:17:22 <dolio> That's not necessarily "nice".
20:17:39 * ddarius senses DT vibes from dolio.
20:17:40 <napping> I like Set_i :: Set_{i+1}
20:17:51 <monochrom> types are scary, kinds are kind, but not as kind as monochrom
20:17:55 <dolio> ddarius: Kind polymorphism would be useful, at least.
20:17:56 <edwardk> dolio: some of us are er... less dependent than others ;)
20:18:11 <ddarius> dolio: I know this as well as kind products and a few other niceties no doubt.
20:18:21 <geheimdienst> types are scary, kinds are kind, all your base, are belong to ...
20:18:25 <ddarius> class Category :: forall k. k -> k -> *
20:19:07 <edwardk> i would just like sort polymorphism so i can reuse my non-recursive functions at the type level ;)
20:19:09 <ddarius> Kind polymorphism would still put the type level of Haskell well below the complexity of the value level.
20:19:40 <dolio> Also, 'data Witness (t :: k) = Witness', for all your non-injective type family uses.
20:20:13 <monochrom> types are scary, kinds are kind, all your base>=4, are belong to cabal
20:20:33 <geheimdienst> cabal doesn't rhyme with kind
20:20:55 <geheimdienst> types are scary, kinds are kind, all your base<4 are belong behind
20:20:58 <ketralnis>  Then to whom belongs my base <4?
20:21:11 <monochrom> ok that works
20:21:25 <ddarius> ketralnis: Still cabal for base>=3
20:22:38 * monochrom contemplates a package that depends on base >=4 && <10000000000000000000000
20:23:13 <dolio> I think dons has already done that.
20:23:24 <monochrom> nice
20:23:42 <tg_> base !:: Integer
20:24:04 <geheimdienst> sounds like somebody heard that it's a best practice to add a "<" to all dependencies
20:24:32 <geheimdienst> and then circumvented the spirit while complying to the letter
20:25:18 <monochrom> I saw one that says "base < 10"
20:27:30 <monochrom> in fact it's judy
20:27:53 <monochrom> in fact it's from dons
20:28:07 <tg_> he's never wrong
20:28:14 <tg_> though he is sometimes drunk
20:28:14 <dolio> That's probably what I'm thinking of.
20:28:19 <edwardk> monochrom: hah. i have slipped a few times and written 5 or 6 in there ;)
20:28:39 <edwardk> but i haven't been brave enough to say 10 ;)
20:28:47 <geheimdienst> a slip is something different from a mistake, i guess
20:28:55 <monochrom> yeah, 5 and 6 are pretty reasonable
20:29:06 <napping> tg_: so he's promising Haskell has a bright future?
20:29:37 * ddarius typoed once and ended up with 577215665 there once.
20:29:52 <soupdragon> I don't understand p-adic _integers_
20:29:55 <tg_> napping: maybe he thought it was binary
20:30:04 <monochrom> or Haskell has such a dim future that base version 10 is pretty much the same
20:30:04 <soupdragon> there are some very NON-integer-like numbers in that set
20:30:21 <edwardk> ddarius: i didn't think they allowed cats on the base ;)
20:30:44 <ddarius> edwardk: Sure they do.
20:31:13 <tg_> OMG lol
20:31:14 <edwardk> monochrom: or he conflated having to give a response IN base 10 with it being base 10
20:31:22 <geheimdienst> well technically they're allowed, but they generally get caught by quickcheck
20:31:27 <tg_> from next futurama. Prof. Farnsworth: "All this knowledge is giving me a rrrraaaaginggg brainer!"
20:33:56 <soupdragon> you watch before they're released? I guess that's fitting
20:34:00 <soupdragon> for a show called...... futurama
20:34:34 <tg_> preview :o
20:36:32 * ddarius hugs slip jigs.
20:37:07 <soupdragon> if a slip jigs is what I think it is, I hope you turned it off first
20:37:24 <aavogt> maybe it's a dance
20:37:27 <soupdragon> mm no it's not
20:37:35 <soupdragon> (what I thought it was)
20:38:26 <aavogt> oh it is
20:39:16 <Pseudonym> "Slip jig" also sounds like a dance-induced injury.
20:39:38 <Pseudonym> Or possibly a device used in woodworking.
20:39:54 <aavogt> or a shot glass
20:40:12 <soupdragon> we'll never know!
20:40:17 <edwardk> yeah i can see that: I feel really sorry for that contestant on "So you think you can dance" I hear he had a slip jig.
20:40:56 <geheimdienst> no, a slip jig is the newest thing from category theory. it's a setoid matronal cryomonor with a little monoid on top.
20:41:25 <Pseudonym> Oh, of course.  I have heard of cojigs
20:41:30 <edwardk> geheimdienst: i wouldn't put it past one of them. after all operads are so called because barry jay's mom was an opera singer
20:41:38 <geheimdienst> good to see they're getting away from that overly dry greek-latin jargon
20:42:42 <edwardk> and consequently, monads were (re)named by way of analogy to those, because their existing name sucked so bad ;)
20:42:57 <geheimdienst> in related news, barry jay's mom recently during a performance in the Belgian state opera actually suffered a slip jig
20:43:04 <ddarius> What's wrong with "standard construction"?
20:43:23 <edwardk> ddarius: makes a crappy typeclass name
20:43:50 <Pseudonym> monad = monoid + triad, I assume
20:44:05 <edwardk> return :: Triple t => a -> t a
20:44:46 <edwardk> Pseudonym: nah, mon as on one/monoid 'ad' as in 'like anoperad'  ;)
20:44:58 <geheimdienst> doesn't the word monad go back to leibniz or something who came up with all those off-the-wall philosophical theories
20:45:10 <edwardk> geheimdienst: separate derivation
20:45:35 <edwardk> monads a la category theory just happened to stumble on the same name, no relation to the 'indivisible unit of thought' leibniz wanted
20:46:44 * geheimdienst is not entirely convinced that it was separate derivation. it sounds a little bit derivative http://xkcd.com/626/
20:46:46 <ddarius> Apparently Google's OCR identifies â¥ and _L
20:47:39 <edwardk> geheimdienst: the above info came from a history of category theory paper i read by the people involved. ;)
20:49:00 <geheimdienst> nvm, i believe you. i just make up excuses to post newton with a wig and sunglasses
20:49:24 <edwardk> " Incidentally, I persuaded MacLane to discard the term âtripleâ in favor of
20:49:24 <edwardk> âmonadâ in his book âCategories for the working mathematicianâ [17]1, which was
20:49:24 <edwardk> being written about the same time. I was convinced that the notion of an operad
20:49:24 <edwardk> was an important one, and I wanted the names to mesh. "
20:49:32 <edwardk> woops sorry for the multiline paste
20:50:23 <edwardk> er and sorry, i meant JP May. i had the name wrong
20:50:38 <edwardk> http://www.math.uchicago.edu/~may/PAPERS/mayi.pdf
20:50:47 <geheimdienst> the dude whose mom had the slip jig?
20:50:53 <edwardk> yeah
20:52:28 <ddarius> edwardk: Yeah.  I would be very surprised if Barry Jay was involved in the early history of category theory.
20:52:50 <edwardk> ddarius: =)
20:53:32 <edwardk> for some reason my brain kept mixing up jp may and the pattern calculus guy
20:54:54 * soupdragon learns a new thing:   default (Integer,Rational,Double)
20:56:45 * ddarius recommends default().
20:57:41 <edwardk> Or just use -Wall and then let it complain at you whenever if defaults
20:57:46 <edwardk> er it
20:58:02 * ddarius would like defaulting removed from the language.
20:58:21 <edwardk> it is rather useful at ghci
20:58:41 <ddarius> edwardk: It's fine to have it be an optional flag to be enabled in GHCi.
20:59:29 <Mathnerd314> so when is defaulting used, besides ghci?
20:59:50 <ddarius> Mathnerd314: It's on by default.  The default default is (Integer, Double)
21:00:52 <edwardk> Mathnerd314: basically any time you just consume an Integral/Fractional without specifying its type, defaulting comes in and saves you.
21:01:03 <edwardk> @type fromIntegral
21:01:04 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:01:09 <edwardk> fromIntegral 12
21:01:12 * ddarius would not describe defaulting to Double as "saving" someone.
21:01:48 <edwardk> well in the case of accidentally using fromIntegral rather than fromInteger it doesn't do a bad job
21:02:01 <ddarius> Always use fromIntegral.
21:02:28 <edwardk> ddarius: given your stance on defaulting i'm shocked to hear that ;)
21:02:36 <Mathnerd314> @type fromIntegral
21:02:38 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:02:42 <Mathnerd314> @type fromIntegral 12
21:02:43 <lambdabot> forall b. (Num b) => b
21:03:05 <ddarius> edwardk: Why?  Writing fromIntegral (foo :: Integer) is not that burdensome and is rarely necessary.
21:03:12 <Pseudonym> fromInteger should be called doNotCallThisFromIntegerFunctionBecauseItsAnImplementationDetail
21:03:19 <ddarius> Pseudonym: Agreed.
21:03:25 <edwardk> Pseudonym: hahahahaa
21:03:33 <Mathnerd314> so what's the problem? Haskell doesn't know which instance to use?
21:03:40 <ddarius> Mathnerd314: Correct.
21:04:03 <ddarius> Mathnerd314: That comes up in many other scenarios as well where defaulting does nothing to help you.
21:04:10 <Mathnerd314> so why not specify that all instances must give the same answer?
21:04:23 <Mathnerd314> then ghc can pick one at random.
21:04:37 <ddarius> Mathnerd314: Then why would you be using a type class?
21:05:04 <Mathnerd314> you'd specify the type if you cared about specific behavior
21:06:34 <Mathnerd314> @src Integral
21:06:35 <lambdabot> class  (Real a, Enum a) => Integral a  where
21:06:35 <lambdabot>     quot, rem, div, mod :: a -> a -> a
21:06:35 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
21:06:35 <lambdabot>     toInteger           :: a -> Integer
21:07:09 <Mathnerd314> @type toInteger . fromInteger
21:07:10 <lambdabot> Integer -> Integer
21:07:53 <soupdragon> "Now stop complaining, and think a little."
21:07:56 <Mathnerd314> @type toInteger >>> fromInteger
21:07:57 <lambdabot> forall a a1. (Integral a, Num a1) => a -> a1
21:07:59 <soupdragon> this is a fun tutorial
21:08:10 <ddarius> soupdragon: Which?
21:08:23 <soupdragon> pari/gp <http://pari.math.u-bordeaux.fr/pub/pari/manuals/2.3.3/tutorial.pdf>
21:08:35 <Mathnerd314> @type toInteger >>> fromInteger $ 12
21:08:36 <lambdabot> forall a. (Num a) => a
21:09:06 <Mathnerd314> @type (^)
21:09:07 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
21:09:10 <soupdragon> ? exp(Pi * sqrt(163))
21:09:10 <soupdragon> %2 = 262537412640768743.99999999999925007259719818568888
21:09:14 <soupdragon> I really want to understand this someday
21:09:46 <ddarius> What do you want to understand about it?
21:10:07 <soupdragon> why it's an almost-integer
21:10:17 <Pseudonym> Does there need to be a reason?
21:10:50 <Pseudonym> > log 262537412640768743
21:10:51 <lambdabot>   40.10916999113252
21:14:10 <cheater99> i'm beginning with haskell, what's the difference between hugs and ghci for me?
21:15:32 <andyjgill> exph
21:15:50 <ryan_baker> cheater99: http://www.haskell.org/haskellwiki/Implementations has some in-depth descriptions of the two
21:15:59 <kmc> cheater99, you should almost certainly use ghci
21:16:34 <cheater99> ryan_baker: i'm not really looking for in-depth info.. just for an overview of what really noticable differences there are for a beginner like me.
21:16:41 <ddarius> The short answer is: Hugs sucks.
21:16:41 <cheater99> like, better tools, ergonomy, etc.
21:17:08 <kmc> Hugs is old, it's no longer maintained
21:17:16 <ryan_baker> cheater99: Gotcha, go with ghci.
21:17:23 <cheater99> ok
21:17:31 <kmc> the Implementations page says "[Hugs] is certainly the best system for newcomers to learn Haskell"
21:17:37 <kmc> i think that's certainly a lie ;)
21:18:11 <kmc> if you are doing Haskell "for real" you will be using GHC, and there's no reason not to start on GHCi
21:18:26 <ddarius> Hugs sucked when it was maintained.
21:21:03 <andyjgill> kmc: it may have been true when it was written
21:21:10 <edwardk> i keep wanting to write a small "turbo haskell" compiler, and then i look at ghc, and i put down the editor and back away slowly
21:23:29 <dolio> Why do you want to do that? To further confuse people into thinking you write Pascal?
21:24:00 <ddarius> He wants to make the THC compiler.
21:24:17 <CakeProphet> hahaha
21:24:28 <CakeProphet> know /I/ want to make the THC compiler.
21:24:45 <CakeProphet> *now
21:25:31 <edwardk> dolio: i figure if they are going to mishear anyways, you might as well capitalize on it for name recognition ;)
21:25:59 <ddarius> Edward gets a bunch of people dusting off old Borland software.
21:26:12 <cheater99> thanks guys
21:26:15 <edwardk> dusting off? you mean you don't still have it installed? ;)
21:26:45 <ddarius> edwardk: I actually do have a Borland Turbo C/C++ compiler installed on this machine right now.  Never had Turbo Pascal.
21:27:25 <edwardk> a shame. the turbo pascal compiler was so much nicer than the turbo c compiler ;)
21:27:49 <ddarius> That's a benefit of designing your language for the compiler writer's benefit.
21:28:11 <edwardk> and not giving a crap about optimizing the executable ;)
21:28:55 <ddarius> edwardk: That is actually the magic sauce in actually finishing a compiler.
21:29:04 <ddarius> My C++ heritage makes that extremely hard for me.
21:31:00 <ddarius> That's why you write interpreters, because no one feels bad about writing an interpreter that is slow as molasses in winter.  Just ask Matz or Ousterhout.
21:34:08 <ddarius> "Every Haskell program has a well-defined translation to a formula in the Lambda Calculus, and the Lambda Calculus is part of mathematics."  I argue with the "well-defined" bit.
21:37:30 <edwardk> ddarius: heh
21:39:04 <thaostra> "Every Haskell user is a math weenie." I agree with the "math weenie" bit. 
21:41:00 * geheimdienst reduces every haskell weenie to a formula in the lambda calculus, not entirely well-defined, but very close
21:42:33 <danharaj> What's a math weenie?
21:43:07 <thaostra> synonymous with math nerd.
21:43:14 <geheimdienst> @wn weenie
21:43:14 <lambdabot> *** "weenie" wn "WordNet (r) 2.0"
21:43:15 <lambdabot> weenie
21:43:15 <lambdabot>      n : a smooth-textured sausage of minced beef or pork usually
21:43:15 <lambdabot>          smoked; often served on a bread roll [syn: {frank}, {frankfurter},
21:43:15 <lambdabot>           {hotdog}, {hot dog}, {dog}, {wiener}, {wienerwurst}]
21:43:36 <geheimdienst> dictionary.com says an insignificant, disliked person
21:44:29 <thaostra> merriam webster says nerd
21:44:43 <thaostra> http://www.merriam-webster.com/dictionary/weenie
21:45:06 <davekong> @wn nerd
21:45:07 <lambdabot> *** "nerd" wn "WordNet (r) 2.0"
21:45:07 <lambdabot> nerd
21:45:07 <lambdabot>      n : an insignificant student who is ridiculed as being affected
21:45:07 <lambdabot>          or studying excessively [syn: {swot}, {grind}, {wonk}, {dweeb}]
21:45:23 <geheimdienst> i reckon for the definitive answer we should ask in #python what they think of the dudes in #haskell
21:45:48 <thaostra> why #python?
21:46:19 <danharaj> Python has an... interesting culture.
21:46:58 <thaostra> their minds must be crippled from overexposure to the language..
21:47:08 <geheimdienst> http://i.imgur.com/hF6mS.jpg
21:47:34 <Pseudonym> Haskell stole all of the good features from Python, didn't you know?
21:48:02 <davekong> python is named after Monty Python and haskell after Haskell Curry, what does that say?
21:48:03 <thaostra> python has good features?
21:48:08 <danharaj> What I love about the png is that you can interpret the Haskell picture in a different way for each square.
21:48:27 <geheimdienst> in python, the function to partially apply must be called monty
21:48:28 <danharaj> I thought Python was named so people can give libraries stupid names punning on snake terminology.
21:48:55 <davekong> danharaj: no they pun on Monty Python's flying circus
21:48:59 <Pseudonym> davekong: Lemon curry?
21:49:56 <thaostra> so is that supposed to be beneficial?
21:49:59 <geheimdienst> a really good python-ish project name is http://jasonfruit.com/thnake/
21:50:30 <danharaj> Oh god I would hit that guy. I would hit him twice.
21:50:37 <Pseudonym> Snake puns make more sense than sticking an "h" on everything.
21:50:51 <danharaj> Really? I think, say, hSDL is pretty descriptive.
21:50:54 <emilmeln> What does Haskell-Ruby picture mean? I don't understand :)
21:50:55 <geheimdienst> pseudonym, i think you mean heverything
21:51:06 <Pseudonym> Which seems like a lite version of iEverything.
21:51:15 <Pseudonym> Off by one.
21:51:21 <danharaj> The i doesn't mean anything. The h means Haskell.
21:51:21 <davekong> Keverything?
21:51:38 <davekong> *or*
21:51:41 <danharaj> I think it's the most appropriate naming scheme for bindings.
21:52:27 <thaostra> the Ruby-Haskell picture actually does look interesting to interpret
21:53:07 <geheimdienst> emilmeln, it's the "transmogrifier" that calvin and hobbes use. it's just a cardboard box, but in calvin's imagination, it's a device that can do improbable things. in the view of haskellers, ruby is an overly simple language that can't really do much, almost like being smoke and mirrors only
21:53:14 <danharaj> If you guys remember the story arcs in Calvin and Hobbes with the transmogrifier, you'd know that it implies poor semantics and a penchant for going wrong ;p
21:53:32 * geheimdienst has a phd in transmogrification interpretation
21:54:17 <emilmeln> geheimdienst: Oh, thanks.
21:54:18 <davekong> danharaj: have a link?
21:54:28 <thaostra> interesting
21:55:08 <geheimdienst> i actually like danharaj's explanation better than mine, come to think of it
21:55:11 <geheimdienst> what i'm wondering about is: why do the php guys view ruby as the flying spaghetti monster
21:55:56 <thaostra> dunno, but i like the way ruby guys view php
21:56:18 <emilmeln> btw, ruby-ruby section really should show something from anime world
21:56:34 <thaostra> i agree.
21:57:08 <geheimdienst> i think almost every one of the pictures hits the nail on the head. it's so perfect
21:57:41 <emilmeln> haskell-haskell is defenitely wrong!
21:57:43 <thaostra> after all, it does have its roots in japan, and japan is known for improving technology, like cars, cartoons and programming languages =P
21:57:49 <emilmeln> .. at least for me.
21:58:04 * geheimdienst notices haskellers seem to view all the other languages as inanimate objects, while all other languages have people with the odd animal mixed in
21:58:11 <wli> The Japanese Fifth Generation project too.
21:58:28 <geheimdienst> emilmeln, what would you put there?
21:59:12 <ddarius> I think the Haskell view of PHP is extremely well-executed and exactly right.
21:59:28 <emilmeln> geheimdienst: A Swiss watch: precise, perfect, state-of-the-art thing =)
22:00:07 <thaostra> i like japanese automatic watches more, mind you >_>
22:00:21 <geheimdienst> ddarius, oh i agree very much with the timebomb as well. and the overloaded collapsing truck is good too
22:00:25 <ddarius> thaostra apparently just likes things from Japan.
22:00:37 <thaostra> that i do.
22:01:03 <geheimdienst> emilmeln, a swiss watch is not what i'd have thought :)
22:01:09 <thaostra> hell, i'm even learning japanese
22:01:17 <emilmeln> geheimdienst: this ticking bomb don't stop haskell userf from writing bindings and do low-level stuff through C.
22:01:24 <emilmeln> s/userf/users
22:01:46 <geheimdienst> the bindings are pretty much impossible to avoid. c is the lowest common denominator api-wise
22:02:15 <pikhq> æ¥æ¬ãç¿ã£ã¦ãï¼ããã­ãåãå¥½ãã ã
22:02:34 <davekong> C is dangerous but handled correctly won't explode... seems to make sense
22:02:50 <davekong> and can also be very useful when you do want to blow something up
22:03:19 <pikhq> davekong: It's dangerous, but in a way it's better designed than a lot of other things out there. Most of its faults come from being an artifact of a previous age, rather than poor design.
22:04:45 <thaostra> pikhq, what are you using for an input method?
22:05:01 <BMeph> I like the one with Lisp at the end, instead.
22:05:14 <pikhq> thaostra: SCIM
22:05:19 <geheimdienst> bmeph, i can has link?
22:05:41 <davekong> I think I like the ruby perspective the most
22:05:48 <davekong> looks the most fun
22:05:48 <thaostra> thanks
22:06:07 <thaostra> ruby is an artful language, i suppose
22:06:45 <BMeph> geheimdienst: No idea, I just have the picture.... :)
22:07:06 <davekong> http://omploader.org/
22:07:09 <geheimdienst> oh, here's a variant: http://imgur.com/P9RnL
22:07:37 <geheimdienst> made by dons, apparently
22:07:53 <geheimdienst> no scratch that. i'm an idiot
22:08:20 <thaostra> haha i like that one
22:09:54 <geheimdienst> found the one with lisp! http://i.imgur.com/1gF1j.jpg
22:10:31 <thaostra> pshh lisp users are even worse than haskell users
22:11:08 <davekong> I really enjoy the PHP image of themselves
22:11:27 <jesusabdullah> I like that
22:12:18 <geheimdienst> python and perl are notably absent
22:12:50 <emilmeln> Haskell column in the second picture doesn't make any sense to me...
22:14:38 <davekong> yea
22:14:43 <davekong> first one better
22:15:03 <geheimdienst> to rubyists, haskell is entirely impenetrable (chinese). same for php (black box). the java fans view us as ridiculous nerds
22:15:24 <davekong> for PHP I would say the pictures are equivalent from the PHP view although different in from other perspectives
22:16:03 <davekong> a PHP person who idealized Tim the Tool man would not under stand mathematics
22:16:11 * geheimdienst likes how lispers view haskell as akin to an excited fluffy kitty
22:16:12 <davekong> idolizes 
22:16:32 <davekong> understand
22:16:44 <thaostra> i view haskell as something that isn't practical
22:16:52 <thaostra> just throwing that out there
22:16:57 <emilmeln> I liked the picture with lisper's view about Haskell :)
22:17:25 * BMeph imagines the kitty screaming, "NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO!!!"
22:17:43 <davekong> Thaostra in the history of haskell the narrator mentions how they had to IO for a while and that other communities were nice enough to not mention it at conferences
22:17:50 <davekong> *had no IO
22:18:34 <geheimdienst> now we have IO with monads, and they keep not mentioning it at conferences
22:20:27 <geheimdienst> kinda like uncle chuck who is kind of an okay guy but you really shouldn't get him started on something he has his crazy theories about
22:20:43 <thaostra> are you just cherry picking your arguments, or is this some really important abstraction that will give haskell the recognition it deserves?
22:21:29 <ezyang> thaostra: Perhaps a better way of thinking about it is that Haskell figured out how to be lazy and separate pure/impure code. 
22:21:41 <ezyang> thaostra: Monads are the (surprisingly deep) technical innovation that let this happen 
22:21:43 <emilmeln> Is that cat a Schrodinger cat?
22:22:00 <harblcat> I keep wondering how to turn a stream of six-sided die rolls into a stream of twenty-sided die rolls...
22:22:06 * djahandarie would not categorize it as a technical innovation
22:22:14 <djahandarie> Makes it sound too technical ;)
22:22:17 <thaostra> but again, how will that solve people's problems?
22:22:22 <pikhq> thaostra: Haskell is exceptionally practical.
22:22:42 <ezyang> thaostra: You mean, laziness? Or pure/impure separation? 
22:22:46 <ezyang> I could give reasons for both :-) 
22:22:48 <djahandarie> thaostra, it solves my problems and I'm a person.
22:22:50 <thaostra> either
22:23:44 <danharaj> What is impractical about Haskell?
22:23:44 <harblcat> two sides and three sides are trivial, and four sides are just a product of two sides, but I cannot come up with a method to get five sides from six
22:24:30 <thaostra> perhaps i should have been more specific. people, like the ones who are forced to, say, use java because there is no better solution for an application?
22:24:30 <harblcat> just re-rolling on a six isn't acceptible, since it could be (theoretically) infinite
22:24:47 <danharaj> Huh?
22:24:50 <davekong> harblcat: but in practice it will only fail 1/6th of the time
22:24:56 <djahandarie> thaostra, if there is no better solution why would they be forced?
22:24:56 <thaostra> and i'm not saying java is any good by itself
22:25:28 <thaostra> because even though java isn't that great as a language, there is a lot of commercial backing for it
22:25:31 <geheimdienst> thaostra, for me the selling point is the type system. it's hard to get something to compile, but once it does, it rarely is buggy. i actually can't stand dynamic languages anymore; i just get mad that the compiler (interpreter) is so damn unhelpful and doesn't work with me at all
22:25:53 <danharaj> harblcat: If you think about flipping a coin stream as a stream of bits, think about how many bits you need to make a stream of die rolls with n sides. Then you can convert to bit streams and back.
22:25:56 <pikhq> thaostra: Commercial backing generally hass very little to do with language quality or even language usefulness.
22:26:14 <Axman6> thaostra: why are you trolling? :\
22:26:14 <ezyang> Nothing wrong with randomized algorithms. 
22:26:43 <harblcat> danharaj: well, I'd ideally like the 'five-sided die' to have the same probability characteristics as the real thing.
22:26:45 <geheimdienst> in principle you could get that in java, c# or what-have-you, but that is defeated by the lack of type inference. you have so much overhead because you have to spell out the type at every turn
22:26:47 <thaostra> right. you seem to advertise the language as just a language, rather than as a solution for everyday problems
22:27:00 <djahandarie> thaostra, I don't advertise anything.
22:27:01 <Axman6> all languages are just languages
22:27:08 <ezyang> harblcat: Consider generating prime numbers: primality tests only have a probability of getting it right 
22:27:18 <Axman6> java won't help you lose weight
22:27:20 <Cale> thaostra: Of course it's also a solution for everyday problems.
22:27:24 <ezyang> So we just run it a bunch of times until cosmic radiation is more likely to mess up our algorithm 
22:27:27 <Axman6> C won't make your car faster
22:27:35 <pikhq> thaostra: It is, in fact, a solution for everyday problems.
22:27:37 <Axman6> program written in them might though
22:27:38 <danharaj> harblcat: You won't be able to exactly get it without the infinitesmal chance of never terminating.
22:27:41 <ezyang> harblcat: So thereâs nothing wrong with rerolling on 6. Itâll give you the right probability distribution too. 
22:28:01 <danharaj> harblcat: but the probability of a reroll taking n rerolls drops off exponentially, so it'll never actually happen.
22:28:03 <emilmeln> geheimdienst: You'ww be answered by dynamic typing people that "static typing gets in our way when we need to temporary violate program correctness for the sake of experiments".
22:28:12 <thaostra> and haskell won't have an open job position. am i hitting it correctly, axman6?
22:28:23 <Axman6> no, you're trolling
22:28:27 <pikhq> I find that programs in Haskell are significantly more terse and more readable than the functional equivalent in alternate languages.
22:28:27 <thaostra> sure
22:28:44 <Axman6> which generally involves being very wrong most of the time, which you have been
22:28:53 <danharaj> Haskell is slowly gaining market penetration. It is a slow process for technologies as expensive as programming languages.
22:28:54 <ezyang> thaostra: Well, let me ask you: why do you think a separation of pure and impure code might be useful? 
22:28:54 <harblcat> hmm, there is a point. I suppose it's a tradeoff between having the same probability characteristics, or using just a set amount of die rolls..
22:29:18 <danharaj> The markets that can gain the most from haskell are big and slow moving: Things like banks and governments who need high fidelity software.
22:29:19 <geheimdienst> parallelization
22:29:21 <ezyang> harblcat: If the probability of failure is still bothering you, perhaps a comparison with our friend, cosmic radiation. 
22:29:33 <ezyang> geheimdienst: Donât give it away! 
22:29:33 <thaostra> danharaj, can you please give links?
22:29:43 <djahandarie> thaostra, if you want us to give you a good answer, you need to pick a good question rather than try to poke as many holes as you can.
22:30:01 <danharaj> thaostra: Did you come into this channel with a mind full of preconceptions and troll-bait before browsing haskell.org?
22:30:09 <harblcat> ezyang: I understand the thing about cosmic radiation, yes. I was more worried about some rolls taking, say, three dice, and others taking eight
22:30:22 <thaostra> how am i trolling?
22:30:22 <kmc> i just walked in.  is this conversation just "haskell sucks, prove me wrong" or is there something more specific at stake?
22:30:29 <geheimdienst> thaostra, i think it is true that haskell's market share (also job market share) is small
22:30:33 <ezyang> harblcat: Are you programming a realtime system? 
22:30:36 <danharaj> thaostra: Because you are throwing around loaded questions.
22:30:36 <kmc> i didn't see a specific claim made by either "side"
22:30:37 <Axman6> galois.com, a company that uses haskell exclusively (i believe) for high assurance financial and government projects
22:30:38 <ezyang> If the answer is no, you donât care. 
22:30:40 <Cale> It's useful not just for parallelisation, but also because it makes the behaviour of programs easier to comprehend and reason about, which, even if you only ever do it informally, is crucial to eliminating bugs.
22:30:42 <ezyang> kmc: Nope, spot on. 
22:30:50 <pikhq> thaostra: You're going "I think Haskell sucks" in a Haskell chatroom.
22:30:50 <djahandarie> kmc, you nailed it.
22:30:50 <geheimdienst> if you're solely looking for job opportunities, maybe you should use php or something
22:30:51 <danharaj> kmc: It is exactly a "haskell sucks, prove me wrong" scenario.
22:30:53 <pikhq> Classic troll.
22:30:57 <kmc> i think we should probably be less defensive
22:30:57 <Axman6> thaostra: java is a crappy language because its ugly and makes concurrency hard
22:31:02 <kmc> if other people want to believe haskell sucks, fine
22:31:04 <danharaj> kmc: Fuck you.
22:31:05 <harblcat> ezyang: actually there is little to no programming at all. It was merely a thought
22:31:08 * danharaj circles the wagons.
22:31:09 <danharaj> ;)
22:31:11 <djahandarie> lol danharaj
22:31:16 <ezyang> harblcat: Aha :-) 
22:31:16 <thaostra> no, i said more along the lines of "i think haskell is impractical"
22:31:17 <Axman6> thaostra: C is a crappy languages because concurrency in it is even harder than java
22:31:24 <kmc> thaostra, did you give some reasons for that?
22:31:30 <ezyang> harblcat: Well, you need to throw out the notion of actually rolling a die. 
22:31:35 <ezyang> Computers are much faster then that :-) 
22:31:43 <pikhq> thaostra: Hey, do the same trick in any other language chatroom (not associated with an esolang, like Brainfuck).
22:31:45 <kmc> thaostra, perhaps specific points which could be confirmed or refuted
22:31:47 <Cale> thaostra: Of course, you're free to think that :)
22:31:49 <ezyang> And even so, if I did your algorithm by hand it probably wouldnât be a problem either. 
22:31:50 <davekong> guys you are overacting to nothing
22:31:55 * geheimdienst wonders if rolling a die is similar to trolling a die
22:31:59 <pikhq> (Of course, Brainfuck *is* impractical. That's the point. :D)
22:32:02 <danharaj> davekong: I am bored and I want to start some drama llamas.
22:32:10 <thaostra> i have given a few, however to keep up since this channel is moving quickly
22:32:21 <thaostra> *however it is difficult to keep up
22:32:35 <harblcat> ezyang: I was thinking of a source of random d6 rolls that is available on the internet. It is only d6 rolls, and I was wondering what someone would do if they needed different rolls.
22:32:37 <ezyang> thaostra: You havenât answered my question. 
22:32:41 <Axman6> thaostra: well you tell us, what makes haskell impractical?
22:32:48 <Axman6> since you seem to know so much about it
22:32:48 <ezyang> harblcat: Ah. 
22:32:58 <ezyang> I missed that context. 
22:33:00 <pikhq> thaostra: Please, tell us why. We have a mutable language spec. ;)
22:33:02 <kmc> thaostra, if "impractical" means "it is hard to get a job if you're only willing to program in haskell"
22:33:05 <kmc> then i agree entirely
22:33:06 <ezyang> harblcat: Go back to the comment about bitstreams 
22:33:16 * geheimdienst agrees with thaostra on the point that haskellers sometimes bury simple things under piles of complicated jargon
22:33:19 <danharaj> Your best chances would be with a contractor like galois.com
22:33:21 <kmc> i find often "impractical" means "less popular than Java"
22:33:30 <pikhq> geheimdienst: s/haskellers/programmers/
22:33:32 <kmc> or "not trivial to learn if you know Java"
22:33:42 <davekong> harblcat: www.random.org
22:33:47 <ezyang> You can easily get a binary bitstream; an easy implementation that throws out a lot of information comes to mind. 
22:33:52 <thaostra> well, it seems to not gain much mindshare past those who are academic
22:34:02 <Axman6> so?
22:34:04 <kmc> thaostra, that's not an argument that it's impractical
22:34:06 <danharaj> also: http://www.fourmilab.ch/hotbits/
22:34:09 <Axman6> how does that make it impractical?
22:34:13 <pikhq> thaostra: And what, pray tell, does this have to do with practicality?
22:34:17 <kmc> thaostra, also http://www.haskell.org/haskellwiki/Haskell_in_industry
22:34:19 <tolkad> hello
22:34:22 <pikhq> thaostra: Seems to me that has everything to do with fandom.
22:34:24 <kmc> hi tolkad
22:34:26 <Cale> thaostra: I actually like the way that it splits its mindshare between academic and industrial use.
22:34:28 <ezyang> I thought this one was neat too: http://gamesbyemail.com/News/DiceOMatic 
22:34:28 <harblcat> davekong: the special part about these d6 rolls is that they are actual d6's being rolled and counted (by machine)..
22:34:34 <thaostra> because of that, not many companies have job openings for haskell users
22:34:37 <pikhq> tolkad: It's "Haskell sucks prove me wrong" hour in #haskell.
22:34:37 <danharaj> Industry moves slowly, except for the web, where most new languages are being adopted quickly.
22:34:45 <ezyang> harblcat: How can you reduce a d6 roll into a coin flip? 
22:34:47 <pikhq> thaostra: And that has what to do with practicality?
22:34:49 <Axman6> thaostra: so? that doesn;'t make haskell an impractical language
22:34:51 <davekong> harblcat: so they are less random?
22:34:52 <djahandarie> pikhq, oh god, this is going to go on for an hour?
22:34:54 <tolkad> All programming languages suck
22:34:56 <kmc> thaostra, you've confused practicality for popularity
22:34:57 <tolkad> deal with it
22:34:57 <harblcat> for some reason it is really popular to blame the pseudo-random number generator..
22:34:58 <Cale> thaostra: Don't worry about getting hired programming in Haskell. You can use it for your own purposes well enough.
22:35:01 <danharaj> Look how long it took C# to become relevant, and C# had *microsoft* backing it.
22:35:02 <Axman6> an impractical language would be one that isn't fit for the job its being used for
22:35:02 <tolkad> haskell's a bit better sometimes
22:35:14 <pikhq> thaostra: C++ is a horribly impractical language, and yet it's *everywhere*.
22:35:19 <emilmeln> The only way I can think of Haskell as impractical is that there isn't as much programmer and code base as in, say, Java.
22:35:20 <davekong> harblcat: I don't see how that is important
22:35:22 <ezyang> harblcat: PRNGs are hard, as far as theoretical CS goes :-) 
22:35:28 <Cale> thaostra: That said, it's not as hard as one might think to find people advertising Haskell jobs.
22:35:36 <tolkad> but really, it's a new field. Programming has only been around for like 30 or so years
22:35:36 <harblcat> ezyang: simply say a 1, 2, or 3 is a 'head', and the others are 'tails'
22:35:38 <ezyang> davekong: I imagine harblcat is thinking of gambling type industries 
22:35:45 <ezyang> harblcat: Great. You know have a binary stream of bits. 
22:35:52 <geheimdienst> i think one thing that _is_ standing the the way of haskell's mass sex appeal is the strange words for not-that-difficult things: functor, monad, category, ...
22:35:54 <ezyang> Now propose a modification that throws out less information. 
22:36:06 <harblcat> davekong: I guess it doesn't need to be. like I said, it's a thought experiment
22:36:11 <pikhq> tolkad: Longer, but it kinda is pre-history before microcomputers. ;)
22:36:16 <wli> There aren't alternatives.
22:36:24 <kmc> geheimdienst, when we use common names people also complain.  like "return"
22:36:37 <djahandarie> kmc, that's because our return isn't the normal return. -_-
22:36:39 <thaostra> and yeah, haskell does have a steep learning curve compared to other languages, and the user of a lot of jargon does make it very confusing for new users
22:36:39 <djahandarie> Bad example
22:36:40 <ezyang> return is such a bad name ^_^ 
22:36:52 <pikhq> geheimdienst: Clearly we should use Mappable, LINQ, and Class.
22:36:53 <pikhq> :P
22:36:58 <danharaj> Jargon is developed because it is needed.
22:37:00 <Cale> I still say return is a good name for what it is
22:37:01 <harblcat> I kind of like the haskell 'return'
22:37:04 <geheimdienst> i thought the consensus on "return" is that that was a bit of a misnomer, and should have been pure or something
22:37:08 <danharaj> In this case, the jargon is essentially mathematical foundation.
22:37:10 <pikhq> thaostra: Learning curve has what to do with practicality?
22:37:10 <ezyang> harblcat: I can think of an easy one, in which you process two dies at a time. 
22:37:16 <Cale> geheimdienst: Not consensus at all
22:37:20 <davekong> ezyang: harblcat: random.org uses atmospheric noises and gets some really good really random data so I don't understand
22:37:26 <harblcat> it makes you think differently once you realize it isn't the same
22:37:31 <pikhq> thaostra: Fun fact: *programming* has a steep learning curve. Yet nobody argues about the practicality of telling computers to do things.
22:37:38 <Cale> return v  is the action which does nothing, returning v as its result
22:37:42 <danharaj> pikhq: but pyythooonnnn
22:37:47 <ezyang> davekong: I think weâre mostly theorizing for fun, at this point. 
22:37:47 <djahandarie> Cale, that has nothing to do with it being a misnomer
22:37:49 * danharaj snicker
22:37:50 <Axman6> thaostra: i wouldn't say there's very much jargon compared to any other language. it's just that a lot of jargon from other areas in maths can be accurately represented in haskell, and get used a lot as well
22:37:51 <djahandarie> @wn misnomer
22:37:52 <lambdabot> *** "misnomer" wn "WordNet (r) 2.0"
22:37:52 <lambdabot> misnomer
22:37:53 <lambdabot>      n : an incorrect or unsuitable name
22:38:00 <Cale> If you're thinking of various monads from the computational viewpoint, it's a perfectly natural name to have chosen.
22:38:08 <pikhq> danharaj: Just lets you not think about some of the more retarded stuff in lower level imperative languages. :P
22:38:10 <harblcat> davekong: stubbornness, I think. There is a certain appeal in solving problems in a less efficient way :)
22:38:10 <Cale> It's not a misnomer at all.
22:38:12 <thaostra> languages take time and effort to learn. most of the time, jobs can be done in less time with languages that are easier to learn
22:38:19 <ezyang> (in a moment, I'm going to ask what the Shannon entropy of a dice roll is) 
22:38:28 <pikhq> thaostra: Your last statement is false.
22:38:33 <ezyang> (if harblcat is paying attention, anyway) 
22:38:49 <pikhq> thaostra: "most of the time, jobs can be done in less time with languages that are easier to learn" That's a ridiculous non sequitur.
22:38:53 <Axman6> thaostra: that's complete nonsense
22:39:01 <harblcat> ezyang: shannon entropy?
22:39:09 <geheimdienst> danharaj, i disagree. jargon is just as often created to preserve an expert status, or to make others feel out of their depth, or to bewilder, or any number of social reasons
22:39:10 <tolkad> anyway, in haskell what's the best way to restrict a data type integral argument to be within certain bounds of my choosing?
22:39:13 <emilmeln> Well, of course it's fine to invent awful names for OO-patterns, but when you encounter a word "monad", is't the Dead End.
22:39:23 <ezyang> hablcat: yah 
22:39:30 <danharaj> geheimdienst: I like to think mathematics is a bit more honest than that. But I am not impartial.
22:39:32 <tolkad> that is, an argument for a data type constructer, sorry
22:39:40 <Axman6> tolkad: that's one of my most missed features in haskell
22:40:05 <pikhq> tolkad: Pain and agony.
22:40:13 <thaostra> also, there are these many tools for languages like netbeans which aid in development
22:40:20 <danharaj> Haskell is harder to learn for people who use imperative languages than it is for people who have no programming experience at all.
22:40:27 <pikhq> thaostra: ...
22:40:32 * ezyang motions for a kickban 
22:40:35 <pikhq> thaostra: Have you written even a single line of Haskell?
22:40:36 <danharaj> Because there is a gap between imperative and declarative thinking that must be bridged.
22:40:37 <tolkad> I could make my own int datatype with 1000s of constructors...
22:40:42 <geheimdienst> cale, when i said misnomer, i meant it's a little misleading. you know "return"s from other languages, but that knowledge misleads you
22:40:43 <tolkad> integral datatype*
22:40:43 <thaostra> yes i have
22:40:52 <harblcat> ezyang: the wikipedia article is making my eyes spin :P
22:40:54 <pikhq> thaostra: Nontrivial program?
22:40:57 <Axman6> tolkad: you could have something like data BoundNum = N Integer | UnderRange | OverRange; toBN n | n > maxn = ... | n < minn = ... | otherwise = N n
22:41:03 <danharaj> The question is, *which* line of Haskell did you write :p
22:41:05 <ezyang> Itâs a pretty easy concept. 
22:41:27 <djahandarie> Wikipedia articles are sometimes overly-complex
22:41:28 <Cale> geheimdienst: Well, there are a lot of other things which if you interpret them with exactly their meaning from other languages, you'll be confused. For example, = 
22:41:30 <thaostra> i have made a bizzbuzz program, which is trivial
22:41:31 <harblcat> I've never been quite at ease reading mathematical formulae..
22:41:39 <Axman6> thaostra: what have you written in haskell?
22:41:40 <ezyang> Don't need it. 
22:41:47 <pikhq> Axman6: Fizzbuzz.
22:41:51 <ezyang> though it will help make precise the notion. 
22:41:52 <geheimdienst> djahandarie, absolutely true
22:41:53 <Axman6> anything else?
22:42:14 <thaostra> i have tried the opengl library and made a skeleton window
22:42:27 <ezyang> harblcat: The intuition is that some statements, such as âI rolled a die and got a 2â have more information in them than âI flipped a coin and it came up heads.â 
22:42:31 <Axman6> because... there are plenty of languages i've ever used in my life before that i could probably do that with given 5 minutes to research, and end up with exactly no insight into the language at all
22:42:34 <pikhq> So, he seems to be basing his opinion of Haskell off of hardly anything, and hence hasn't seen any of its advantages.
22:42:37 <thaostra> truth be told, i have only tried a bit of each 
22:42:50 <geheimdienst> cale, could you elaborate how haskell's = is unlike other languages' =?
22:43:04 <ezyang> harblcat: The funny thing is, I can exactly quantify what the information contained in those statements is. Not just the first has more info than the second. Actual numbers. 
22:43:04 <danharaj> = is usually some sort of destructive assignment
22:43:18 <danharaj> in Haskell it is just naming a term.
22:43:20 <Axman6> thaostra: you'll find that people will think more highly of your views if you at least have the credibility earned by trying something properly first
22:43:21 <ezyang> But we should move to #haskell-blah before #haskell gets mad at us. 
22:43:23 <danharaj> or defining it.
22:43:23 <thaostra> alright, that's enough trolling for me
22:43:24 <Cale> also, recursion :)
22:43:25 <harblcat> ezyang: Oh, yes, I was just beginning to get that from the article
22:43:36 <thaostra> thanks for the discussion, it was educational for me
22:43:44 <pikhq> thaostra: BTW, you really, truly should cease asking loaded questions.
22:43:53 <geheimdienst> thaostra, that will be $57.50 then, please
22:43:57 <thaostra> i do it..a lot.
22:44:01 <pikhq> Either that or you should walk into #c++ and claim C++ isn't a practical language.
22:44:05 <pikhq> :)
22:44:10 <danharaj> Who wants to bet we'll see something in reddit programming about thaostra's anthropological findings.
22:44:22 * pikhq gives thaostra some asbestos underpants
22:44:33 <Axman6> "Why is Java so shitty as a functional language? this makes it impractical for me"
22:44:38 <thaostra> haha
22:44:38 <dolio> Go ahead. Just don't say it in ##c++.
22:45:00 <thaostra> this was some of the most fun i have had in weeks
22:45:10 <pikhq> Trolltastic!
22:45:19 <djahandarie> Trolltacular!
22:45:26 <thaostra> trollololololololo!
22:45:31 <ezyang> Trollerskates. 
22:45:40 <thaostra> ducktroll
22:45:43 <tolkad> hmm... if I implemented my own Int8 type like "data MyInt8 = m-128 | m-127 | m-126 | ..." would it be any slower than the builtin Int8 type if I compile with GHC?
22:45:59 <kmc> yes
22:46:05 <emilmeln> tolkad: of course
22:46:10 <geheimdienst> trololo cat http://www.youtube.com/watch?v=dIR3XFuY4Qs
22:46:13 <pikhq> tolkad: Undoubtedly.
22:46:23 <djahandarie> Man there is some hardcore echo in here today
22:46:23 <tolkad> really? why? it seems like it would be easy for GHC to optimize it to the same code
22:46:47 <Cale> thaostra: If you're having trouble doing something practical in particular with Haskell, make sure to ask about it here :)
22:47:02 <thaostra> oh you know i will ;)
22:47:15 <tolkad> what about storage? would it take more memory?
22:47:18 <emilmeln> tolkad: numbers are represented as (I# Int#). Here I# is the usual data constructor, and Int# is the type of unboxed integers.
22:47:33 <Cale> thaostra: I'm sure you'll find people's reactions to be more pleasant when there's obvious effort on your part :)
22:47:38 <thaostra> you know, i like you guys. you have some great personalities
22:47:40 <thaostra> http://www.youtube.com/watch?v=2Z4m4lnjxkY
22:47:53 <kmc> tolkad, doesn't seem that easy.  for example when you define your (+) function by 65536 different pattern match cases, GHC would have to recognize that this is equivalent to the machine's underlying "add" instruction
22:47:54 <geheimdienst> (... and watch how we come up with a solution invariably involving monads)
22:48:05 <Cale> geheimdienst: heh
22:48:12 <Pseudonym> I did a personality test a couple of weeks ago, and I did indeed test positive.
22:48:13 <dolio> Because your heuristic for what constitutes "easy" optimizations is terrible.
22:48:22 <Axman6> Cale: it's a lost cause man, trolls are incapable of learning
22:48:30 <Cale> geheimdienst: Just be glad it doesn't involve Kan extensions.
22:48:44 <thaostra> axman is trolling a troll, apparently.
22:48:44 <Cale> Axman6: My policy is never ever to assume someone is trolling.
22:49:00 <tolkad> kmc: Doesn't sound too hard
22:49:08 <kmc> tolkad, ok.  i await your ghc patches :)
22:49:25 <kmc> anyway i think it's pretty hard and also, would this optimization be useful?
22:49:32 * geheimdienst is pretty sure now that ghc is a troll. that bitch is so incapable of learning.
22:49:56 <thaostra> because it has its brain explode and doesn't afraid of anything
22:49:58 <pikhq> kmc: Instances of Enum in general?
22:50:18 <tolkad> kmc: yeah, it would compute the optimal way to encode any function as machine code
22:50:22 <pikhq> Those are somewhat common.
22:50:52 <kmc> tolkad, err, yes, you've correctly defined what optimization is
22:51:12 <kmc> there's a reason compilers don't just magically produce the best possible code
22:51:16 <danharaj> that is not a decidable problem :p
22:51:32 <kmc> and it's really hard too
22:51:36 * pikhq curses halting
22:51:37 <tolkad> danharaj: Your statement is unproven
22:51:38 <kmc> not only is it impossible, it's also very hard
22:51:53 <tolkad> danharaj: It is only undecideable to a turing machine
22:51:54 <pikhq> tolkad: Halting problem says no.
22:52:03 <pikhq> At least, not in the general case...
22:52:09 <kmc> every nontrivial property of programs is undecidable
22:52:16 <kmc> http://en.wikipedia.org/wiki/Rice's_theorem
22:52:28 <ezyang> Oh I love that theorem :-) 
22:52:32 <pikhq> Though, as we're on subTuring machines, it is perfectly *possible* to solve the halting problem.
22:52:34 <pikhq> Just very impractical.
22:53:00 <danharaj> No, optimization is undecidable.
22:53:10 <tolkad> danharaj: by a turing machine
22:53:21 <pikhq> danharaj: By and for a Turing machine.
22:53:37 <pikhq> We're on finite state automata.
22:53:37 <tolkad> danharaj: Seems like you believe that church-turing thesis stuff
22:53:59 <kmc> the flying spaghetti monster can solve it
22:54:02 <danharaj> If you implement a function on your computer and your computer halts because it ran out of memory, you haven't solved the halting problem for that function.
22:54:26 <danharaj> If you try to solve optimization on your computer, the fact that your computer will halt because it ran out of memory doesn't mean you've solved optimization.
22:54:33 <danharaj> Optimization is undecidable.
22:54:45 <pikhq> danharaj: You have, however, solved the halting problem for your implementation of that function on a system with X memory.
22:54:49 <geheimdienst> what about premature optimization?
22:54:55 <johnw> can I recurse into a lamba?
22:54:58 <tolkad> danharaj: you're assuming a turing machine is doing the computation
22:55:07 <johnw> lambda
22:55:20 <danharaj> tolkad: I am assuming the computation is being done w.r.t. to the known laws of physics.
22:55:31 <kmc> johnw, yes
22:55:33 <Axman6> > let f = \x -> x * f (x+1)
22:55:34 <lambdabot>   not an expression: `let f = \x -> x * f (x+1)'
22:55:39 <johnw> ah, let; thank you
22:55:40 <kmc> johnw, you need a way for a lambda's body to refer to itself
22:55:42 <kmc> ?
22:55:55 <johnw> yes, I was missing a way to name it
22:55:55 <tolkad> danharaj: an audacious assumption
22:55:57 <johnw> hadn't thought of let
22:56:01 <kmc> or just "let f x = x * f (x+1)"
22:56:03 <Axman6> you can use fix as well
22:56:10 <pikhq> danharaj: It is perfectly possible to optimise any arbitrary function for *my computer*.
22:56:12 <danharaj> pikhq: No you haven't. If the function doesn't return a value, then it didn't halt. The computer crashing is really "Don't know" for a decider.
22:56:18 <kmc> fix (\f x -> x * f (x+1))
22:56:34 <pikhq> It just requires something significantly greater in computation power.
22:56:40 <pikhq> danharaj: Computer crashing = bottom.
22:56:45 <Axman6> > fix (\f x -> if x < 2 = 1 else f (x-1) + f (x-2)) 10
22:56:46 <lambdabot>   <no location info>: parse error on input `='
22:56:53 <Axman6> > fix (\f x -> if x < 2 then 1 else f (x-1) + f (x-2)) 10
22:56:55 <lambdabot>   89
22:57:47 <ddarius> Pseudonym: You should get that checked out by a doctor.
22:58:22 <johnw> fix worked better in my case acutally
22:59:42 <pikhq> danharaj: Then one can consider the computer crashing to be not halting, just as one can consider an infinite loop not halting or trying to pattern match undefined not halting.
23:00:25 <tolkad> danharaj: for any finite set of turing machines and finite set of inputs, there is a computable function on those turing machines and inputs that determines whether each pair halts
23:01:37 <danharaj> tolkad: wat
23:01:58 <tolkad> danharaj: what don't you understand?
23:02:11 <danharaj> Give me the construction of this computable function.
23:02:59 <tolkad> danharaj: it's not one function, there is one function for each set of inputs and set of turing machines combination
23:03:15 <tolkad> or, at least one I should say
23:03:26 <danharaj> tolkad: I give you a list of turing machines and a list of inputs, give me your function.
23:03:27 <ezyang> tolkad: Are you familiar with the concept of an uncomputable number? 
23:04:11 <tolkad> danharaj: THAT, is undecideable
23:04:20 <tolkad> ezyang: not really, but I am sure of my statement
23:04:28 <pikhq> tolkad: Seems equivalent to saying "there exists a solution to the halting problem".
23:04:34 <tolkad> pikhq: no
23:04:51 <tolkad> pikhq: there does not
23:04:55 <pikhq> Oh, wait. *Finite set of inputs*. Ahahahah.
23:04:56 <danharaj> That's a complete cop-out. Of course there is a function that encodes the answer to the halting problem for finite inputs. That is trivial.
23:05:11 <danharaj> I am kind of irked at the trivialities being described in this conversation.
23:05:12 <thaostra> i'm bored #haskell. what should it do? should i actually read that book on catagory theory i was linked to?
23:05:12 <pikhq> Complete copout, yes.
23:05:17 <tolkad> then why are you arguing against me?
23:05:28 <davekong> If I am writing a game with a "global state" that functions either update or use to translate into some IO how should I implement the "global state"?
23:05:36 <danharaj> That bear nothing on the fact that, if I give you a program in some language, and tell you to give me the optimal encoding in another language, it is *undecidable*.
23:05:56 <danharaj> You can't do it. And you can't get around it by copping out because your machine doesn't have unbounded memory.
23:06:57 <pikhq> danharaj: I can compose the entire list of programs in that other language and select the ones that have the same output for the same input and select the ones that operate most optimally according to whatever criteria I have.
23:07:17 <pikhq> All this because there's a finite set of programs and a finite set of input and a finite set of output.
23:08:06 <danharaj> pikhq: and if the program takes an input an unbounded domain?
23:08:14 <pikhq> Granted, "finite" is 2^1103806595072 or so...
23:08:22 <pikhq> danharaj: Because I am on a finite machine, there is no such thing.
23:08:28 <danharaj> Except we're not talking about any machine.
23:08:29 <tolkad> pikhq: you will never know whether you found the most optimal one though
23:08:32 <danharaj> We are talking about languages.
23:08:39 <danharaj> Say, C and x86 assembly.
23:08:46 <tolkad> err wait
23:08:48 <emilmeln> I need a data structure which maps continous ranges of integers on some values (e.g. (40;156) maps to "foo", (157;500) maps to "bar" etc.).  In my case, ranges are *very* large.  Can someone suggest me a data structure that I am looking for?
23:08:51 <tolkad> sorry, nevermind
23:09:00 <ddarius> Ultrafinitism, it's the only way to be.
23:09:01 <pikhq> danharaj: Sorry, C and x86 assembly are mandated finite. ;)
23:09:07 <davekong> danharaj: tolkad can you take this somewhere sle
23:09:15 <danharaj> I'm about to go to bed.
23:09:34 <pikhq> Also: I'm discussing implementation of X language on Y machine.
23:09:36 <danharaj> So yes, I will take it to super dream land where I will continue the discussion with the queen of unicorns.
23:09:46 <pikhq> It's hypothetically decidable for this case.
23:10:02 <pikhq> (though impossible unless you've got a few universes to work with)
23:11:10 <kmc> thaostra, i think reading the CT book would be a good investment towards your further trolling efforts
23:11:22 <emilmeln> Moreover, I need to look up values by specifying ranges, and it's possible for lookup to return multiple answers.
23:11:45 <thaostra> hey hey! i'm not here for just trolling!
23:12:03 <kmc> thaostra, just saying :)
23:12:09 <ddarius> emilmeln: There's probably an interval tree somewhere on hackage, but I don't know where.  Implementing a one dimensional one should be fairly easy to do.
23:12:16 <thaostra> hehe. well, thanks for the tip then.
23:13:00 <thaostra> however, it is very late. see you guys some other time
23:13:25 <thaostra> i thoroughly enjoyed our little discussion
23:13:30 <ddarius> Nothing roils the waters more than claiming toposes handle logic poorly.
23:14:21 <kmc> "The liberal elitist academics in #haskell have no respect for common hardworking programmers who aren't in their egghead club.  I had to read a book on *advanced category theory* before they'd stop calling me a troll."
23:14:45 <ezyang> snerk 
23:14:57 <gwern> 'I've recently done much reading of work by Adam Chlipala, who has been studying certifiable compilers for a while now - albeit for a much simplified language and to 'idealized' machine language targets compared to Rust. Comments like the above, regarding Rust, are gradually scaring me into submission to the Coq.'
23:15:02 * gwern groans
23:15:04 <kmc> haha
23:15:10 <thaostra> anyway: http://www.youtube.com/watch?v=ETO3-MxMe2Q
23:15:14 <emilmeln> ddarius: Thank you very much.  I've just needed to know the name of this structure, I can implement it myself.
23:15:16 <thaostra> night fellas
23:15:18 <ddarius> I believe you can do something clever with FingerTrees to get an interval tree for free.
23:15:26 <kmc> gwern, comments like which?
23:15:34 <gwern> kmc: see http://lambda-the-ultimate.org/node/4009
23:15:36 <dolio> See, now "certifiable compilers" is a decent pun.
23:16:05 <emilmeln> Like "extensible XML" :)
23:16:26 <kmc> Rust looks good; i'm glad at least that the FAQ answer on "Have you heard of Go" recognizes some of the clear flaws of Go
23:24:50 <ddarius> @tell emilmeln http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-IntervalMap-FingerTree.html
23:24:50 <lambdabot> Consider it noted.
23:24:56 <cozachk> what do i need to do to get cabal to build leksah on ubuntu karmic? ive downgraded to ghc 6.10.4 but im still get a glib error 
23:25:05 <gwern> rust's typestate stuff looks like phantom types
23:25:14 <gwern> @hpaste
23:25:14 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
23:25:19 <gwern> cozachk:  ^
23:25:46 <cozachk> ack and downgrading monadius and frag still fail to build D-: 
23:25:54 <cozachk> gl errors
23:26:00 <ezyang> Hey guys, question for you. Suppose I want to look at the HTML of a web site, and say whether or not itâs broken or not. 
23:26:08 <ivanm> cozachk: do you have gtk2hs installed?
23:26:11 <ezyang> What kind of algorithmic approaches should I take? 
23:26:13 <gwern> ezyang: you mean, validates or not?
23:26:23 <ezyang> gwern: No, as in, âthe database is brokenâ 
23:26:26 <ivanm> or even just the separate glib, etc. packages
23:26:27 <gwern> well, I guess you'd go look at HaXml and whatnot
23:26:37 <cozachk> the seperate glib wont install
23:26:43 <cozachk> should i paste the error? 
23:26:44 <ezyang> It needs to work across arbitrary skins, but you can assume that the same underlying application is for all of them. 
23:27:09 <gwern> ezyang: hm. how about you take the app, run 'strings' on it, and then see whether the HTML contains any of the those whole strings infix?
23:27:38 <gwern> any text error the app can emit would get picked up
23:27:41 <ezyang> The best I can come up with is: thereâs is some sort of underlying common structure for any given application not eliminated by reskinning that I can match against. 
23:27:45 <ezyang> gwern: That'd match webapps too 
23:27:48 <ezyang> *errors 
23:27:58 <ezyang> and that's precisely what I want to match 
23:28:01 <gwern> ezyang: I don't follow
23:28:37 <ezyang> as in, when itâs an erroring, I want to know that 
23:28:40 <gwern> why would your server ELF have the same `strings` output as your database ELF?
23:29:06 <ezyang> gwern: When I say web application, I mean something like "PHP application" 
23:29:08 <ezyang> :^) 
23:29:30 <gwern> well, maybe you could fix your web app to return a non-normal status code, like it ought to...
23:29:31 <cozachk> cabal install glib error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27194#a27194
23:29:36 <gwern> maybe not a 404, but one of the others
23:29:50 <ezyang> (let's imagine this validation program is written in Haskell, for sake of staying on topic :-) 
23:29:58 <ezyang> gwern: Interesting thought. 
23:30:11 <ezyang> But these aren't my web applications, unfortunately :-( 
23:30:23 <gwern> ...isn't this exactly what error codes are for? out-of-band signalling like this? in-band sucks for precisely the resons we're covering
23:30:25 <ezyang> So that would reduce to âfind all error paths and mark them appropriatelyâ 
23:30:36 <ezyang> yeah. In the face of lack of out-of-band signalling, how do you cope? 
23:30:41 <gwern> well, *someone* has to distinguish error from success. the computer neither knows nor cares
23:31:02 <gwern> the quesiton is, do you do it manually and make your checker know it all, or put the knowledge in the generating app?
23:31:04 <ezyang> Well, if I go look at a web page, it's blindingly obvious to me if something's amiss. 
23:31:21 <gwern> you say you can't change the generating app, so your checker must hold the knowledge
23:31:25 <ezyang> yeah 
23:31:31 <ezyang> But I don't know what knowledge to teach it. 
23:31:52 <ezyang> For example, right now I have "these are strings that should be found in a working app" and "here are strings taht are not found in a working app" 
23:32:04 <ezyang> but this has both false positives and negatives 
23:32:05 <napping> gwern: phantom types alone won't quite do it, you need them to change with actions
23:32:15 <napping> gwern: you can probably hack up something horrible with indexed monads
23:32:27 <cozachk> indexed monads sound scary 
23:33:09 <gwern> ezyang: how about you filter all the PHP sources for string literals, manually prune it for ones used for errors, and tell it to look for any of the error strings in the source. presumably your app isn't often saying in non-error contexts "database missing". for bonus points, you can specify the HTML is only to be checked in the <body> or whatever
23:33:45 <ezyang> Quite possible. I'll have to write a tool to extract string literals, but that shouldn't be too hard. 
23:33:55 <gwern> napping: but don't phantom types let you do things like 'forbid writing to a closed file handle'? I'm sure there was a paper on that
23:34:03 <ezyang> gwern: Yep. 
23:34:13 <ezyang> see monadic regions 
23:34:13 <napping> gwern: sure, but how to you make sure the open handle becomes a closed handle when you close it?
23:34:16 <gwern> ezyang: well, since you can't do it the right way, you have to do it a nasty heuristic way. life sucks sometimes
23:34:19 <gwern> napping: heck, I dunno
23:34:37 <ezyang> gwern: Yeah, I guess I'm looking for the simplest heuristic that gets it right the most :-) 
23:34:37 <napping> you can do ugly things with regions and stuff to kind of make it work
23:34:45 <ezyang> regions are not ugly! 
23:34:50 <napping> probably more trouble than it's worth to encode in Haskell
23:34:51 <ezyang> They're elegant and simple. 
23:35:13 <ezyang> I want to write a blog post, âMonadic regions for the common manâ 
23:35:26 <napping> well, ok, but manufacturing region encapsulation from higher rank types and type class constraints is not so nice
23:35:44 <gwern> ezyang: it might be fun to train up a naive bayes filter to recognize errors, but I suspect that's harder than just using grep and emacs macros to generate a list
23:35:44 <napping> heck, even simulating type-level computation with type classes is pretty annoying
23:35:46 <ezyang> sure, but you were just asking for handles that were inaccessible when closed. 
23:36:02 <napping> ah, that's a little different
23:36:05 <ddarius> napping: You don't need type classes at all and it is fairly reasonable.
23:36:11 <napping> making handles that are only accessible in the region where it is open is ok
23:36:22 <ddarius> However, what would really make this workable and flexible is a substructural type system.
23:36:48 <napping> ddarius: oh really? I was pretty sure you had to do something like the ST trick, and then at the opening of the nested region include a class constraint saying the new region is a subregion of the old region
23:36:58 <napping> ddarius: exactly, it's the linearity you really want
23:37:31 <ddarius> napping: Have you read the rgnURAL paper?
23:37:40 <napping> yes, it's quite nice
23:38:15 <napping> linearly held capabilities in partcular are a nice solution t manage access to stuff in the region
23:38:25 <gwern> ezyang: although, it might be a cool project to write a tool which implements bayes, which you train in a GUI where you say 'yes, this live page on the internet has the Buddha nature' or 'no, it doesn't', and then when it's trained you let it run on a domain. it could probably report its results as a RSS feed too
23:38:45 <ezyang> Yeah, I think it would be a cool project. 
23:39:08 <ezyang> And thinking about what kind of input you want to feed the bayes checker would also be interesting 
23:39:17 <ezyang> for example, maybe stripping all HTML tags will result in faster training 
23:39:44 <cozachk> woot got glib going had to get the c lib 
23:39:48 <gwern> good for sysadminning like your example, although it'd be hard for something more difficult. wikipedia vandalism, for example. training on just words doesn't get you much
23:40:11 <gwern> ezyang: I'd expect HTML cruft to just be noise. slow it down perhaps but most HTML is very common and would be ignored
23:40:26 <ezyang> fair enough 
23:40:46 <ezyang> Can Bayesian filters work on higher-level structure? 
23:41:00 <ezyang> or do you have to turn that structure into superficial text and then feed taht to the filter? 
23:41:20 <gwern> I'm not sure. it's harder, at least
23:42:15 <ddarius> I don't see why it would be harder necessarily.
23:44:22 <gwern> ddarius: well, bayesian filters are basically just frequency-counting, 'penis' is used in X% of spam but 1-x% of ham where x=large fraction
23:45:01 <napping> ddarius: treating input as a bag of words with conditional independence makes the baysian updating part a lot easier
23:45:33 <gwern> ddarius: this is fine when the vocab alone tells you stuff. but what if it's the same exact vocab and frequency, just the order matters? ie. 'obama is gay' and 'obama is not gay' are basically the same to a frequency count, since 'not' is such a common english word, but one is nasty wikipedia vandalism and the other isn't
23:46:02 <gwern> this may not be the best example. but maybe you get my meaning
23:46:35 <ezyang> :-) 
23:46:42 <ezyang> (in my book, both are :-P ) 
23:46:52 <ivanm> ezyang: you have a book?
23:46:53 <ivanm> ;-)
23:47:42 <theorbtwo> To answer your original question, there's no reason the tokens you feed a bayes classifier have to be words.
23:47:59 <theorbtwo> They could just as well be two-word pairs.
23:48:01 <ezyang> theorbtwo: Sure. So I'm wondering what would the tokens be. 
23:48:29 <gwern> theorbtwo: yeah, but what's both easy and useful? an English AST might be useful, but no one has tossed up a language-english on hackage...
23:49:35 <theorbtwo> If you want to detect wikipedia spam?  I expect just words would be a pretty good start.
23:49:45 <ddarius> You could use subtrees of HTML for example.
23:50:00 <theorbtwo> Then add in a special token for "adds a link".
23:50:09 <ezyang> ddarius: You'd have to strip out text, but that's not bad. 
23:50:20 <gwern> theorbtwo: the state of the art has moved well beyond that for wikipedia anti-vandal bots
23:50:23 <ezyang> I keep forgetting trees can be tokens :-) 
23:50:34 <ddarius> You can really use anything and it doesn't need to even be a "thing."
23:50:40 <napping> ddarius: the problem is, for the "bayesian" part you need a model of probabilities over trees
23:51:00 <theorbtwo> gwern: OK, so what use case *are* we talking about?
23:51:02 <napping> for words under conditional independence it's easy, you just multiply individual word probabilites to score a text
23:51:04 <gwern> and AVBs based on flagging edits containing words like 'penis' are the least interesting, since humans catch all those vandals anyway
23:51:18 <ddarius> Words aren't independent.
23:51:30 <gwern> theorbtwo: well, one pernicious form of vandalism is changing a single number in a figure without also including a link/ref
23:51:37 <gwern> theorbtwo: eg, dates, ages
23:51:56 <gwern> (what are you going to do, target any modification of numbers?)
23:52:25 <gwern> napping: so just use a model that every tree is equally probable and let the training fix it
23:52:37 <gwern> (good ol maxent)
23:52:43 <napping> sure, but how do you represent your model so you can update the probabilities of trees?
23:52:46 <theorbtwo> gwern: Interesting point, especially since there are a fair number of cases, I should think, where modifying a number without citation is considered reasonable.
23:53:03 <theorbtwo> Updating "as of 2009" to "as of 2010", for example.
23:53:21 <gwern> yep
23:53:41 <gwern> but updating 'died in 1909 to 'died in 1910' is bad!
23:53:42 <Cale> Evil plan: Make a Windows virus which causes people's computers to randomly turn words in Wikipedia pages into links to articles with those names.
23:54:00 <theorbtwo> On the other hand, I'm not sure "a human could spot it easily" is a good argument against a classifier.
23:54:16 <theorbtwo> The point isn't to do things a human couldn't, but to do them with less effort.
23:54:26 <gwern> theorbtwo: well, I mean that to be 'it's vandalism so obvious that a human who knows nothing about wikipedia or the subjet matter can spot it'
23:54:42 <ddarius> theorbtwo: That effort is free and also a human will likely need to intervene anyway.
23:55:30 <theorbtwo> Not neccessarly.  Throw in a simplification of the number of accepted edits a user has made as a token, and with a little training, well-known users will be more trusted.
23:55:55 <theorbtwo> Then stop edits that score as more then 99% spam.
23:56:00 <gwern> great. so of the 300 million edits or whatever, now you only have to focus on 150 million
23:57:06 <theorbtwo> gwern: No.  You do that *as an additional token*, and like spam filtering, you kill outright those that are almost certianly spam, you stick those that are mearly very probably spam in a moderation queue, and you let the rest go.
23:58:07 <gwern> anyway, the best vandalism detection efforts I've heard of use SVMs. I wonder how they work
23:58:38 <ezyang> oh man, support vector machines 
23:59:02 * ezyang learned about them in AI class but didn't really understand them... 
23:59:10 <theorbtwo> Aha, I've seen some interesting mappings of politicians using SVMs.
