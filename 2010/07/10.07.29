00:00:26 <PetRat> Is the definition of the StateT instance of lift something like    lift x = \s -> (x,s)
00:00:41 <earthy> @src StateT
00:00:42 <lambdabot> Source not found.
00:01:11 <Veinor> @src lift StateT
00:01:11 <lambdabot> Source not found. :(
00:01:15 <Veinor> @src StateT Lift
00:01:15 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:01:27 <Veinor> bleh
00:01:35 <earthy> instance MonadTrans (StateT s) where
00:01:35 <earthy>     lift m = StateT $ \s -> do
00:01:35 <earthy>         a <- m
00:01:35 <earthy>         return (a, s)
00:01:45 <earthy> 'like'. :)
00:04:13 <CakeProphet> so
00:04:15 <CakeProphet> am I a monad?
00:05:07 <c_wraith> CakeProphet only if you can absorb arbitrary values into yourself
00:10:39 <copumpkin> that just makes you pointed
00:10:52 <copumpkin> I've been over the conditions for making mammals into monads but I won't repeat them
00:11:39 <c_wraith> true, but it's a necessary step for becoming a monad.
00:25:30 <JoeyA> Just curious, why does this result in a stack overflow?  http://codepad.org/ZGJlofND  I made a tree structure an instance of Foldable, only implemented foldl, and used foldr .
00:25:57 <JoeyA> (If I implement foldr and use foldl, it does not recurse infinitely)
00:26:24 <JoeyA> The documentation for Data.Foldable does say: Minimal complete definition: foldMap or foldr.  I guess this is why.
00:27:03 <JoeyA> Interesting, foldr' works, but foldr doesn't.
00:27:13 <JoeyA> (when only foldl is implemented)
00:27:28 <JoeyA> http://codepad.org/02YOGCj4
00:33:19 <byorgey> JoeyA: probably because foldr is implemented in terms of foldMap and vice versa.
00:33:20 <Zeiris> Suppose I have a large CSV data file describing elements of a data structure. Their names, which functions handle them, and how to parse them.
00:33:50 <Zeiris> The data file lists number IDs for the attributes. Is there a way to read it, and bind it to names in my program?
00:34:56 <Zeiris> I could use a reader, like: name <- lup "NAME_ELEMENT" but that would be limited to a monad with that reader, and would probably re-do the lookup each time.
00:35:38 <Zeiris> Is this a situation where unsafePerformIO could be used, perhaps? Since the data file is basically constant, changes once a year at the most, and is an integral indispensable part of the program.
00:38:31 <JoeyA> Well, you could write an unsafe function like this:
00:38:45 <JoeyA> assignId :: a -> (Int, a)
00:39:12 <JoeyA> Every time you call it, it increments the int returned.  Not sure if that's what you're going for or not.
00:41:01 <JoeyA> Then again, I'm not 100% sure that's possible unless you supply an IORef argument like so:
00:41:18 <JoeyA> assignId :: IORef Int -> a -> (Int, a)
00:41:34 <JoeyA> Of course, it'd be better to keep that type of stuff in IO actions:
00:41:53 <JoeyA> assignId :: IORef Int -> a -> IO (Int, a) -- I think
00:41:59 <Zeiris> Mm, I don't think so. I've got a data structure that's partially described by a text file the program parses. I don't want to duplicate the information in the text file by writing a -completely- separate Haskell-repr.
00:42:05 <copumpkin> yeah
00:43:11 * Zeiris goes to see if he can pastebin a toy example.
00:44:15 <siracusa_> Zeiris: Maybe what you're looking for is Template Haskell?
00:45:10 <Zeiris> Code generation seems like a nightmarish, complex solution. It might solve any and all problems, but I don't think it's worth the effort expended.
00:48:29 <siracusa_> Zeiris: Hhm, what I've meant was creating a value from a construtor name and its arguments. This should not be that complex.
00:51:36 <Zeiris> It looks like the simplest way to solve this is a custmo Enum instance via unsafePerformIO. Is there a way to run unsafePerformIO only once, though, and cache the result forever?
00:56:13 <JoeyA> foo :: a -> b; foo = unsafePerformIO $ return (\x -> ...)
00:56:15 <JoeyA> perhaps that?
00:57:14 <JoeyA> This memoization function does it:  http://www.reddit.com/r/programming/comments/crgxs/do_i_really_want_to_be_using_a_language_where/c0upzm9
00:58:28 <JoeyA> The trick is to call unsafePerformIO when defining the function.  The function returned in that IO action will call unsafePerformIO yet again, allowing you to tuck away some static state.
00:58:37 <JoeyA> (static in the C sense)
01:18:40 <johan__> So, I've made my program, starting with "main = do" and I have two putStrLn, after that I try to assign a variable a value and print that, using: "myVar = 5" and "putStrLn myVar", the compiler doesn't like the "myVar = 5" part, complaining about a parse error, why?
01:19:38 <lispy> johan__: What is a variable?
01:20:04 <Cale> johan__: use  let myVar = 5
01:20:17 <johan__> lispy: I think of it as a named box where I can store a value, which I can use later on. Maybe I'm still stuck in imperative thinking
01:20:26 <Cale> johan__: That's not what it is
01:20:40 <lispy> johan__: It's more like giving a name to the value 5
01:20:40 <Cale> johan__: If you want a named box, you'll want an IORef
01:20:53 <johan__> Cale: I tried that, actually. There seems to be lacking an instance for Num String, and I shall perhaps add an instance declaration for that :)
01:21:07 <Cale> Yeah, let myVar = 5 will define myVar to be literally equal to 5, not a box which merely contains 5
01:21:30 <Cale> johan__: You probably don't want an instance of Num for String
01:21:34 <johan__> Cale: I probably don't want an IORef just yet :)
01:21:39 <Cale> johan__: You probably want 'show'
01:21:42 <Cale> > show 5
01:21:43 <lambdabot>   "5"
01:21:48 <Cale> > show [1,2,3]
01:21:49 <lambdabot>   "[1,2,3]"
01:21:58 <lispy> :t putStrLn -- Note:  This needs a String not a number
01:22:00 <lambdabot> String -> IO ()
01:22:00 <johan__> show is a Haskell-wayu of saying toString?
01:22:06 <lispy> johan__: correct!
01:22:08 <Cale> johan__: yeah
01:22:13 <Cale> > show (Just [1,2,3], 12.45)
01:22:14 <lambdabot>   "(Just [1,2,3],12.45)"
01:22:25 <johan__> So, it compiles! Great, thanks!
01:22:28 <lispy> johan__: the inverse is read
01:22:35 <lispy> > read "3.14" :: Double
01:22:37 <lambdabot>   3.14
01:22:39 <Cale> > read "[1,2,3]" :: [Integer]
01:22:40 <lambdabot>   [1,2,3]
01:23:22 <lispy> johan__: It's best to think of show and read as tools for programmer output and not as serialization or end-user formatting
01:23:29 <johan__> lispy: I've tried those out at the Prelude, so I'm at least vastly familiar with show/read :)
01:23:31 <lispy> johan__: (just a heads up for later)
01:23:54 <MasseR> lispy: What _is_ good for serializing?
01:24:01 <lispy> MasseR: cerial
01:24:18 <Cale> cereal, itym :)
01:24:27 <lispy> MasseR: http://hackage.haskell.org/package/cereal
01:24:33 <johan__> lispy: I would think of it as a type conversion thingie, for example I guess that I need to do a "show" if I'd like to calculate the string length of a number, for example?
01:24:34 <MasseR> Thanks :)
01:24:36 * lispy can't spell
01:24:52 <MasseR> Altough google was able to see your spelling error and give me a correct link at first try
01:25:00 <MasseR> I was sure to get some cereal (breakfast) website
01:25:30 <lispy> johan__: Well, show is a type conversion in some sense, but most haskell functions are
01:26:03 <lispy> > length (show 1234)
01:26:05 <lambdabot>   4
01:26:11 <johan__> length 1234
01:26:21 <johan__> length (1234)
01:26:28 <lispy> > length (show (show 1234))
01:26:29 <lambdabot>   6
01:26:37 <lispy> johan__: you need the "> " at the start of the line
01:26:42 <johan__> Ah :)
01:26:43 <lispy> > "hi"
01:26:44 <lambdabot>   "hi"
01:27:03 <johan__> Wow, what happened there? How can a double-shown 1234 have string length 6?
01:27:18 <quicksilver> the quotes.
01:27:27 <johan__> :)
01:27:32 <lispy> > show "hi"
01:27:33 <Ke> > fix show
01:27:33 <lambdabot>   "\"hi\""
01:27:34 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
01:27:42 <_Ray_> good times
01:28:03 <lispy> johan__: print x = putStrLn (show x)
01:28:29 <johan__> lispy: Parse error on input "=" :(
01:28:38 <johan__> My bad
01:28:49 <johan__> No, not my bad :)
01:28:59 <lispy> johan__: it works as a top level definition in a file, but the Prelude already defines it
01:29:28 <lispy> ghci is a little weird in that it restricts to the syntax to expressions only and drops you into a 'do-block' implicitly
01:30:13 <lispy> > let f = 1 in f -- note that here I have to use `in` because it's a let inside a normal expression
01:30:14 <lambdabot>   1
01:30:30 <lispy> But if I were in a do-block I could omit the 'in'
01:30:46 <lispy> > do let x = 4; return x :: [Int]
01:30:47 <lambdabot>   <no location info>: Invalid type signature
01:30:59 <lispy> > (do let x = 4; return x) :: [Int]
01:31:00 <lambdabot>   <no location info>: parse error on input `)'
01:31:04 <lispy> Or not...
01:31:07 <JHoglund> In almost all examples, "variables" as I call them, consists of a single character, such as a or b, and when saying "multiple of", you append an s, such as "as" or "bs". Can I use words in the same way, such as "car", "cars"?
01:31:14 <lispy> > (do { let x = 4; return x }) :: [Int]
01:31:16 <lambdabot>   <no location info>: parse error on input `}'
01:31:36 <JHoglund> I mainly think about the "a -> a -> b" parts that show up every now and then
01:31:37 <lispy> I'm not sure why lambdabot isn't accepting that
01:31:42 <CakeProphet> hmmm
01:31:54 <JHoglund> Would it be OK to write "car -> body -> wheels"
01:31:57 <CakeProphet> could you use GADT to make type-safe unit types?
01:32:02 <CakeProphet> unit as in measurements
01:32:05 <quicksilver> > do { let {x=4}; return x } :: [Int]
01:32:06 <lambdabot>   [4]
01:32:13 <lispy> CakeProphet: yes, have you seen the dimensional package?
01:32:17 <CakeProphet> nope
01:32:20 <lispy> CakeProphet: there is one other such standard package
01:32:26 <quicksilver> JHoglund: yes
01:32:42 <CakeProphet> that's pretty sweet that you can make units typesafe.
01:32:48 <lispy> > let f x y = x :: car -> boat -> car in f 1
01:32:49 <lambdabot>   Inferred type is less polymorphic than expected
01:32:49 <lambdabot>    Quantified type variable...
01:32:56 <quicksilver> JHoglund: but I think you might be confusing type variables and value variables. They're both allowed to be many characters anyhow.
01:33:06 * lispy gives up on clever abuses of syntax for today
01:33:33 <JHoglund> quicksilver: I defenetively are confusing them, but I't has started to clarify a bit now :)
01:33:35 <lispy> CakeProphet: F# has it as a language feature
01:33:45 <lispy> CakeProphet: And C++ has it as a boost library
01:33:49 <quicksilver> > let f :: car -> boat -> car; f x y = x in f 1
01:33:50 <lambdabot>   Overlapping instances for GHC.Show.Show (boat -> t)
01:33:50 <lambdabot>    arising from a use o...
01:34:03 <quicksilver> > let f :: car -> boat -> car; f x y = x in f 1 "hi"
01:34:03 <lambdabot>   1
01:34:06 <lispy> CakeProphet: But, AFAIK, no real scientific calculations ever use those :(
01:34:27 <lispy> CakeProphet: I used to be a software engineer writing engineering software and as long as it didn't crash they didn't care what the units came out as...
01:34:56 <Itkovian> BTW, what's up with the Haskell weekly news? Last post dates from March 8, or am I missing something?
01:35:05 <JHoglund> quicksilver: let f :: car -> boat -> car; f x y = x in f 1 "hi"     Could you please, in short, describe what that is? A type declaration with a constructor?
01:35:18 <lispy> Itkovian: Yes, jfredit has been lax in his duties, something about computer melt down
01:35:29 <Itkovian> ouch
01:36:14 <lispy> JHoglund: it's a lot of things.  Mainly it defines a function f that takes 2 parameters.  It ignores the second one and returns the first.  Then there is an example usage
01:36:15 <quicksilver> JHoglund: no constructors.
01:36:22 <Itkovian> Anything we can do? I'm not taking it over, no time, but small bits might be helpful
01:36:42 <lispy> Itkovian: maybe get in contact with him?
01:37:27 <JHoglund> lispy: So, the function is called "f", it accepts a car and a boat, and returns a car?
01:37:33 <lispy> JHoglund: Haskell has 2 types of constructors in the language, and at least one more as a design pattern.  The two in the language are type constructors and data constructors
01:37:54 <lispy> JHoglund: Yes, except that 'car' and 'boat' are just names for the type variables
01:38:05 <lispy> JHoglund: they're not committing to specific car and boat types
01:38:12 <quicksilver> JHoglund: No. It accepts any type (call that type 'car') and any other type (call that type 'boat').
01:38:20 <JHoglund> lispy: Do you know is there's a reason to why they haven't separated the arguments and the return values in the declaration statements?
01:38:23 <quicksilver> and returns the first type, whatever it was (That we called car)
01:38:57 <lispy> JHoglund: They have actually.  The fully bracketed type would be f :: car -> (boat -> car)
01:39:12 <lispy> JHoglund: Which is to say, when you give the first parameter to f, you get a function
01:39:20 <JHoglund> quicksilver: "car" and "boat" are just inernal names, not visible to the function caller, and it has absolutely nothing to do with the types, the "car" may be an Int, a boat or whatever?
01:39:23 <lispy> JHoglund: and when you apply a parameter to that, you get the resut
01:39:26 <lispy> result*
01:40:35 <lispy> JHoglund: yeah, that function can be fed many different types, although once you apply f to some type, say Int, then it sort of instantiates all mentions of the first type variable with Int
01:41:14 <lispy> :t let f :: car -> boat -> car; f x y = x in f 1
01:41:15 <lambdabot> forall t boat. (Num t) => boat -> t
01:41:28 <JHoglund> lispy: The fully bracketed version: f :: c -> (b -> c), where the first c is the return value? Is it guaranteed that the argument "c" and the return "c" has the same type?
01:41:32 <lispy> JHoglund: See how now it has type boat -> t, where t is some numeric type
01:42:09 <lispy> JHoglund: yes, the first c and the second c are equal
01:42:27 <lispy> JHoglund: It might return a different value of type c, but it will be the same type
01:42:56 <lispy> :t let f :: car -> boat -> car; f x y = x in f (1 :: Int) -- maybe this is easier to read
01:42:57 <lambdabot> forall boat. boat -> Int
01:43:39 <lispy> :t let f :: a -> b -> c; f x y = x in f (1 :: Int) -- Oops, we have an error
01:43:40 <lambdabot>     Couldn't match expected type `c' against inferred type `a'
01:43:40 <lambdabot>       `c' is a rigid type variable bound by
01:43:40 <lambdabot>           the type signature for `f' at <interactive>:1:19
01:44:02 <lispy> :t let f :: a -> b -> b; f x y = x in f (1 :: Int) -- Still not right
01:44:03 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
01:44:04 <lambdabot>       `b' is a rigid type variable bound by
01:44:04 <lambdabot>           the type signature for `f' at <interactive>:1:14
01:44:09 <lispy> JHoglund: maybe those examples help
01:44:23 <JHoglund> lispy: I have a function, "myFunc", which starts with a "do" and outputs 5 before retuning 1. However, the compiler comlains about trouble when matching "String" against inferred type "a -> String".
01:44:24 <lispy> JHoglund: the function arrow (->) in haskell is like a logical implication
01:44:35 <JHoglund> Perhaps I need to declare that my function is some kind of IO function?
01:45:07 <lispy> JHoglund: It's hard to say without seeing more, but you might be riht
01:45:30 <lispy> "outputs 5"  <-- if this is "print 5" then yes, you're doing IO
01:45:36 <tibbe> I'm trying to figure out if a function could have an Applicative a => constraint instead of a Monad m => constraint. Here's the function:
01:46:29 <JHoglund> lispy: I'll give you a pastebin, just a sec
01:47:03 <tibbe> renderM :: Monad m => [Frag] -> (T.Text -> m T.Text) -> m T.Text
01:47:03 <tibbe> renderM (Template frags) ctxFunc = liftM T.concat $ mapM renderFrag frags
01:47:03 <tibbe>   where
01:47:03 <tibbe>     renderFrag (Lit s)   = return s
01:47:03 <tibbe>     renderFrag (Var x _) = ctxFunc x
01:47:20 <tibbe> can `Monad m` be `Applicative a` here instead, if I switch mapM?
01:47:25 <JHoglund> lispy: http://pastebin.com/Rd4U5ux7
01:47:50 <tibbe> i.e. change mapM for mapA
01:48:38 <quicksilver> tibbe: you'd have to change the ctxFunc
01:49:05 <quicksilver> and it isn't called mapA, it's called traverse
01:49:11 <tibbe> quicksilver, sure
01:49:13 <quicksilver> ..but yes, it would be fine.
01:49:34 <tibbe> quicksilver, so what's the distinction, no-one ever looks at the value inside a monad when producing a new one
01:49:52 <quicksilver> the distinction is using >>=
01:49:52 <tibbe> quicksilver, and therefore it can be an applicative functor
01:49:54 <quicksilver> or <-
01:49:57 <tibbe> right
01:50:10 <quicksilver> i.e. making later actions depend on the result of earlier actions.
01:50:25 <quicksilver> mapM in particular doesn't do them - it collects all the results "independently"
01:50:57 <tibbe> quicksilver, right
01:51:24 <lispy> JHoglund: looking
01:51:27 <tibbe> quicksilver, traverse uses <*> right?
01:51:50 <HugoDaniel> how do i install hdbc odbc ?
01:51:54 <lispy> JHoglund: the line, "putStrLn show 5" isn't a parser error, but it's not what you intend
01:52:14 <JHoglund> lispy: Uhm, it should just print "5" to the screen?
01:52:20 <quicksilver> tibbe: traverse for lists in particular could be written : traverse f [] = []; traverse f (x : xs) = (:) <$> f x <*> f xs
01:52:24 <lispy> JHoglund: you see, functions bind tightly.  So, it reads it as, "(putStrLn show) 5"
01:52:49 <lispy> JHoglund: But, what you want is "putStrLn (show 5)"
01:52:50 <quicksilver> tibbe: oops... (traverse f xs) not just (f xs) at the end.
01:52:50 <tibbe> quicksilver, got it
01:52:54 <JHoglund> lispy: I have a feeling that all functions doing IO should declare so, but in the example tutorial I look at, I can see that they have a function where they do not declare side effects, although they are doing IO
01:53:00 <h_noob> basic question on IO: in all the example I found so far readFile is used inside series of "do" actions - what I actually need is a function which will read file content and return pure structure e. g. list of strings for example - how do I do that e. g. how do I return String instead of IO String?
01:53:14 <HugoDaniel> ah
01:53:16 <JHoglund> lispy: Allright, I'll fix that!
01:53:41 <lispy> JHoglund: once youfix that you'll have a problem with the next ine
01:54:08 <JHoglund> lispy: Mhm, there's no instance for (num (IO b))
01:54:14 <JHoglund> lispy: What did "b" come from?
01:54:21 <lispy> JHoglund: Because the first part uses do and return, the second equation, namely "myFunc x = x * 5", needs to use return also
01:54:49 <lispy> JHoglund: and, once again return is a function so you'll need parens to express the right thing
01:54:58 <quicksilver> h_noob: you can't. Any function which reads in a file will have IO in its type.
01:55:02 <lispy> JHoglund: so it must be, "myFunc x = return (x * 5)"
01:55:08 <quicksilver> h_noob: but that's OK - you can still call pure functions in the returned string.
01:55:18 <JHoglund> lispy: is there a difference between: "myFunc x = x" and "myFunc x = do { return x }"
01:55:35 <lispy> JHoglund: I'm not sure where that b came from, but when type inference takes place sometimes it has to create names for all the type variables
01:55:37 <h_noob> quicksilver: where can I find some example with readFile NOT in main = do... ?
01:55:44 <lispy> JHoglund: yes, a big difference
01:55:52 <lispy> :t return
01:55:53 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:56:10 <lispy> JHoglund: if you use return, then the value will be inside some monad.  In your case, m = IO
01:56:13 <quicksilver> h_noob: I'm not sure. You could look around the wiki, perhaps.
01:56:17 <JHoglund> lispy: I'm sorry, but lambdabots reply really didn't say me anything at all :)
01:56:28 <quicksilver> h_noob: or just ask a bit more of a specific question here.
01:56:42 <quicksilver> JHoglund: 5 is an Int (simplifying, sorry), but (return 5) is an IO Int.
01:56:46 <quicksilver> JHoglund: quite different.
01:56:54 <JHoglund> lispy: Is there something "bad" or "unclean" with returning monads instead of values?
01:57:01 <lispy> JHoglund: hehe, it's okay.  It takes a while to get used to all the monad business.  But for now it suffices to say that those two are quite different.
01:57:03 <quicksilver> (unfortuantely return could be other monads not just IO but I'm trying to relate to your example)
01:57:56 <h_noob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28343 - I got error "Couldn't match expected type `IO b' against inferred type `String'" for that code
01:58:01 <lispy> JHoglund: monads are quite useful, but if you're just starting out I recommend taking the time to get comfortable with the other stuff then we can introduce them as they come up (such as IO)
01:58:05 <h_noob> what am I doing wrong?
01:58:25 <quicksilver> h_noob: return (removeComments file)
01:58:40 <quicksilver> h_noob: since removeComments is a pure function, you want to put it inside return to use it in a do-block.
01:59:05 <h_noob> quicksilver: Couldn't match expected type `IO String' against inferred type `String'
01:59:21 <h_noob> quicksilver: I thought return is actually doing vise versa
01:59:34 <h_noob> quicksilver: bringing pure things into IO?
01:59:34 <lispy> JHoglund: Well, good luck I need to sleep!
01:59:43 <JHoglund> lispy: Good night!
01:59:59 <JHoglund> (I just woke up, 11 am here)
02:00:05 <lispy> hehe, 2am here
02:00:14 <JHoglund> Not that big difference ;)
02:00:17 <quicksilver> h_noob: yes. exactly.
02:00:17 <h_noob> JHoglund: we're in same timezone :)
02:00:28 <quicksilver> h_noob: removeComments is pure, so to use it in IO you need to return (...) it
02:00:40 <JHoglund> h_noob: I guess, norway...?
02:00:48 <h_noob> JHoglund: yepp :)
02:00:51 <h_noob> Oslo
02:01:05 <h_noob> quicksilver: well, how do I fix type error in this case than?
02:01:10 <JHoglund> h_noob: I saw Opera.com in your hostname, Opera is a Norweigian company, right?
02:01:33 <h_noob> JHoglund: yes, that's right
02:01:34 <quicksilver> h_noob: in the last line, you replace "removeComments file" with "return (removeComments file)"
02:01:43 <quicksilver> h_noob: thats' what I tried to say before, sorry if I was unclear
02:01:55 <h_noob> quicksilver: I did that and got error regarding IO String and String
02:02:47 <quicksilver> h_noob: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28344
02:02:49 <quicksilver> annotated.
02:02:56 <quicksilver> it compiles fine, I just compiled it.
02:03:11 <adnap> Whoa, party in #haskell.
02:05:33 <h_noob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28345 - sorry code was incomplete
02:05:51 <h_noob> the question is - how do I use result of return (blah)?
02:06:04 <h_noob> I got type error IO String instead of String
02:06:16 <h_noob> how do I bring it fro, IO to pure?
02:06:20 <quicksilver> you can't.
02:06:55 <h_noob> quicksilver: so there is no way to use result of this function in parsedMap?
02:07:22 <Taejo> you can't turn IO String into String, but you can turn a function that accepts a string into one that accepts IO String
02:07:23 <quicksilver> you just need a thin 'shell' or 'harness' in IO which moves the IO data around and passes it to your pure functions
02:07:46 <h_noob> quicksilver: any examples for newbies?
02:07:50 <h_noob> :)
02:08:10 <adnap> Is there a way in a data constructor to ensure that the data belongs to a certain type class?
02:08:18 <quicksilver> well your getContent - as I fixed it - is an example
02:08:26 <h_noob> as far as I understood for pure functions there should be no difference if data come to it from pure function or from io function
02:08:28 <quicksilver> adnap: in haskell98, there is a broken half-way that isn't really useful.
02:08:40 <quicksilver> adnap: in GHC, GADT syntax does something a bit more useful.
02:08:58 <h_noob> quicksilver: take a look - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28345 - I got type error in parsedMap
02:09:03 <Cale> h_noob: If you have an action of type IO t, you can run it to get a value of type t, inside another IO action.
02:09:13 <adnap> Like, say I have data Foo = Foo Integer, but all I really care about is that the thing belongs to Num, not that it's an integer.
02:09:15 <Taejo> > fmap (+1) (Left "lol")
02:09:16 <lambdabot>   Left "lol"
02:09:22 <Taejo> > fmap (+1) (Right 3)
02:09:23 <lambdabot>   Right 4
02:09:30 <Cale> h_noob: Inside a do-block, if you write v <- x, it means "run the action x, and name its result v"
02:09:41 <Cale> h_noob: If x :: IO t, then v :: t
02:09:42 <h_noob> Cale: can you take a look - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28345 ?
02:10:35 <kuribas> Why isn't there a split function in haskell?
02:10:47 <quicksilver> kuribas: nobody knows for sure.
02:10:57 <Taejo> kuribas: there's a whole *library* of split functions
02:10:59 <h_noob> Cale: I got "The last statement in a 'do' construct must be an expression" error if I do what you said
02:11:01 <Taejo> @hackage split
02:11:02 <lambdabot> http://hackage.haskell.org/package/split
02:11:04 <quicksilver> kuribas: my theory is that there were too many API choices. 
02:11:04 <Cale> kuribas: What kind of split function?
02:11:12 <Cale> h_noob: You have to use the result v
02:11:15 <adnap> I don't understand.  There must be a way, or I'm confused.
02:11:34 <Cale> h_noob: The result of the entire do-block is always the result of the last action in it
02:11:53 <kuribas> quicksilver: aha :)
02:12:01 <Cale> h_noob: So if you just want it to be v, you don't have to add a line at the end which says return v, you can just not give the result a name at all
02:12:05 <Taejo> adnap: what do you want to do with Foo?
02:12:15 <h_noob> Cale: so how do I do that exactly?
02:12:21 <Cale> kuribas: See the split package on Hackage, if I know what you mean by "split function"
02:12:25 <h_noob> Cale: can you change my example?
02:12:29 <pastorn> adnap: http://necrobious.blogspot.com/2009/03/fun-example-of-haskells-newtype.html
02:12:39 <Cale> h_noob: What error are you getting?
02:12:47 <adnap> Taejo: In Foo, I don't care that I have an Integer per say, I just want the thing to be in the Num type class.
02:12:58 <Cale> h_noob: I can't compile that example because I'm missing a definition for xdata and parse
02:13:07 <kuribas> Cale: Yes, split like in other languages (ruby, etc...)
02:13:34 <Cale> kuribas: http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html
02:13:42 <h_noob> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28347 - should it be like this?
02:13:48 <Taejo> adnap: but you can't do anything with that type (well, you can add them and subtract them, but you can't get the result out)
02:13:57 <Cale> kuribas: Chances are that what you're looking for is among those :)
02:14:06 <kuribas> Seems like I have it already :)
02:14:12 <Taejo> oh, wait, you can show it
02:14:14 <Cale> h_noob: no, since that's a syntax error
02:14:30 <Cale> h_noob: What you had before didn't look overtly wrong
02:14:32 <h_noob> Cale: what's the proper way to do it?
02:14:41 <Taejo> adnap: do you want "data Foo a = Foo a", but restricted to (Num a)
02:14:41 <Cale> h_noob: What error did you get?
02:14:43 <adnap> Taejo: Okay, so ignore my contrived example.  Basically, what I want is an s-expression type, where the atoms must belong to the type class Data.Binary.
02:14:55 <adnap> Taejo: Yes
02:15:02 <h_noob> Cale: The last statement in a 'do' construct must be an expression
02:15:04 <pastorn> adnap: check the link i gave you
02:15:06 <pastorn> ?
02:15:10 <Cale> h_noob: I mean from the code before
02:15:14 <adnap> pastorn: I was checking it.
02:15:22 <Cale> oh, it's quicksilver's code
02:15:22 <quicksilver> adnap: experience shows it it almost always best to leave it un-restricted and just put the restrictions on the functions that need it.
02:15:30 <h_noob> Cale: Couldn't match expected type `IO String'against inferred type `String'
02:15:44 <h_noob> Cale: that's if I use return in last statement
02:15:45 <Cale> h_noob: yes, because removeComments file is a String
02:15:52 <Cale> hmm
02:16:04 <quicksilver> adnap: but if you do want to, GADT syntax lets you do it.
02:16:15 <Cale> h_noob: What type are you expecting getContent to have?
02:16:20 <pastorn> h_noob: http://howdyworld.org/io-monad.jpg
02:16:20 <Taejo> adnap: what quicksilver says. one reason being, some functions on sexprs don't *need* the constraint, so why put the constraint in places you don't need it
02:16:22 <Cale> h_noob: getContent :: String -> IO String
02:16:48 <Cale> h_noob: Can we look at your entire program?
02:17:10 <h_noob> Cale: String -> String  - at least that's what I think I need
02:17:10 <Cale> h_noob: It's hard to tell what's wrong when I only have a fragment which I can't load in an interpreter :)
02:17:12 <adnap> Taejo: Because I want to put my new type in the Binary type class, and to do that, I need to be able to create a ByteString.  To do that, the atoms must also be of type Binary.
02:17:16 <Cale> h_noob: Impossible.
02:17:24 <Cale> h_noob: If it reads a file, it can't have type String -> String
02:17:41 <Taejo> adnap: you can say instance Binary a => Binary (Sexpr a)
02:17:44 <Cale> h_noob: Because it would have to give the same resulting String for each input String
02:17:48 <quicksilver> adnap: not true.
02:18:01 <quicksilver> adnap: you can just make the Binary a condition of the Binary instance - not a condition on the type.
02:18:05 <Cale> h_noob: (that is, if applied to the same input String, it would have to give the same thing every time)
02:18:17 <quicksilver> adnap: (which is what Taejo's instance syntax means, indeed)
02:18:53 <Cale> h_noob: Since it reads a file, that is, it does IO, its result must be an IO action
02:19:16 <adnap> quicksilver: I see.
02:19:20 <adnap> Taejo: Thanks
02:19:22 <Cale> h_noob: Make sense?
02:19:47 <Cale> h_noob: So, getContent, when given the name of a file, will give you the action which reads that file, and strips the comments out.
02:20:09 <Cale> h_noob: and that's what quicksilver's version does
02:20:35 <h_noob> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28348 - here is complete code
02:20:48 <h_noob> I understand that IO action supposed to have IO type
02:21:01 <adnap> How do I do something to the effect of Sexp a = Atom a | List [Sexp]?
02:21:05 <h_noob> the thing is - other functions are pure 
02:21:14 <Cale> h_noob: Okay, so the only problem now is with makeMap
02:21:18 <h_noob> so how do I deliver data to them/
02:21:41 <Taejo> adnap: data Sexp a = Atom a | List [Sexp a]
02:21:48 <h_noob> Cale: I actually got error for parsedMap
02:21:48 <Cale> h_noob: makeMap also reads a file, so it's also got to be an IO action. You don't want to apply parsedMap to the action (getContent path), you want to apply it to the result of that action
02:22:20 <Cale> h_noob: Well, you're not supplying any type signatures, so the error messages won't be as good as they might be, because the compiler doesn't really know what you want
02:22:23 <adnap> Taejo: Okay, but the a's in the List don't all have to be of the same type, right?
02:22:47 <h_noob> Cale: and how do I use result of action instead of action here?
02:22:59 <Taejo> yeah, they do... otherwise when you say Sexp a, you don't know what type your atoms are going to be :)
02:23:31 <Cale> h_noob: by running the action
02:23:52 <Cale> h_noob: So you can either write   do x <- getContent path; return (parsedMap x)
02:23:55 <h_noob> Cale: erm... any code illustrating that?
02:24:10 <Cale> h_noob: Or if that's getting tedious, you can use   fmap parsedMap (getContent path)
02:24:30 <Cale> h_noob: Where for IO, you have  fmap f x = do v <- x; return (f v)
02:24:36 <Cale> because that's a really common pattern :)
02:25:11 <Taejo> adnap: what are you planning to do with these sexprs besides serialising and unserialising them?
02:25:12 <h_noob> Cale: wow! that's exactly what I was looking for :-D
02:25:15 <h_noob> thanks
02:25:40 <h_noob> Cale: one more thing - is there some tutorial which covers things like fmap and other IO magic? :)
02:25:42 <adnap> Taejo: I was going to put data in them for serializing.
02:26:04 <Cale> h_noob: Well, fmap isn't specific to IO actually :)
02:26:06 <Cale> :t fmap
02:26:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:26:16 <Cale> Ignore that first bit :)
02:26:19 <Cale> (Functor f) => (a -> b) -> f a -> f b
02:26:27 <Cale> It's analogous to map
02:26:42 <h_noob> so I should read some more about functors probably :)
02:26:45 <Taejo> adnap: are you not planning to deserialize them?
02:26:46 <Cale> but works in a more general setting (in fact, it's defined separately for different type constructors f)
02:27:41 <Cale> h_noob: yeah, well, that's almost all there is to say about functors at this point -- they support something like map, which applies a function to all the elements of a datastructure, or to the result of some computation
02:27:43 <adnap> Taejo: I wanted something like this: List [(Atom "Triangle"), List [(Atom (0.0, 0.0)), (Atom (0.0, 1.0)), (Atom (2.0, 0.0))]]
02:28:03 <adnap> Taejo: Yes, I am going to serialize and deserialize them.
02:28:13 <Taejo> adnap: you could define "data Atom = I Int | Str String | D Double" for example
02:28:24 <Cale> h_noob: and I suppose that fmap ought to satisfy some laws:  fmap id = id, and fmap (f . g) = fmap f . fmap g
02:28:25 <adnap> Taejo: Bu        = encode ':'
02:28:32 <adnap> Taejo: Whoops
02:28:35 <Taejo> and then use "data Sexpr = A Atom | L [Sexpr"
02:28:39 <h_noob> Cale: so the difference with regular map is that in this case we perform action and use it's result?
02:28:41 <adnap> Taejo: I don't want to hae to restrict the types.
02:28:55 <Cale> h_noob: Well, yeah, the similarity with the list map is in the type
02:28:57 <Cale> :t map
02:28:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:29:03 <JoeyA> What's a nice way to start a process in the background.  I just need to pass an argument to it, but not send anything to stdin or read from stdout/err.
02:29:10 <Cale> and in this case, we're using fmap :: (a -> b) -> IO a -> IO b
02:29:24 <Cale> Of course, fmap also works on lists:
02:29:30 <Cale> > fmap (*10) [1,2,3,4,5]
02:29:31 <lambdabot>   [10,20,30,40,50]
02:29:36 <Cale> (It's the same thing as map)
02:29:48 <JoeyA> Use CreateProcess, set std_* to Inherit, and set close_fds to True?
02:29:59 <Cale> and on a number of other datatypes as well
02:30:06 <Cale> > fmap (*10) (Just 5)
02:30:07 <lambdabot>   Just 50
02:30:10 <Taejo> adnap: but that actually can't happen *anyway*, because your deserialization code is going to need to know what type it's trying to decode, surely?
02:30:37 <Taejo> and the code that *does something* with the sexprs surely has to know something about their type to manipulate them
02:30:45 <Cale> h_noob: Apart from fmap, there are a bunch of functions which can be used in any monad, which are often useful in IO specifically.
02:30:54 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad.html
02:31:06 <Cale> ^^ that lists the main bunch of them :)
02:31:11 <adnap> Taejo: Not if I could just impose the restriction that it's type Binary.
02:31:23 <Cale> In particular, it would be good to note mapM/forM
02:31:34 <Cale> (which are the same thing with parameters flipped)
02:31:40 <byorgey> adnap: in that case you might want to use an existential wrapper, like this:
02:31:42 <adnap> Taejo: If the atoms are in the type class Binary, all I have to do is encode and decode them.
02:31:46 <Cale> forM is like a for-each loop
02:31:51 <h_noob> Cale: thanks - I'll read through it
02:31:53 <Cale> It takes a list to iterate over
02:32:02 <byorgey> data Atom :: * where Atom :: Binary a => a -> Atom
02:32:03 <Taejo> adnap: but how is the deserializer going to decide which binary instance to use?
02:32:05 <Cale> and a function from elements of that list to actions to be performed
02:32:09 <Cale> (a loop body)
02:32:15 <byorgey> data SExpr = Atom | [SExpr]
02:32:21 <Cale> and it produces an action which performs the obvious loop
02:32:30 <Taejo> anyway, adnap, I gtg
02:32:40 <adnap> Taejo: Okay, thanks for the help.
02:32:48 <byorgey> now each Atom can hold a value of a different type, and the only thing you know about the type is that it is an instance of Binary.
02:32:51 <Cale> (and collects a list of the results of each iteration)
02:33:02 <adnap> byorgey: I don't recognize that syntax.
02:33:15 <h_noob> Cale: another thing - when I'm trying to actually use makeMap from my example in main I got error No instance for (Show (IO (Either ParseError (Map.Map [Char] [([Char], [Char])]))))
02:33:23 <h_noob> Cale: this looks puzzling
02:33:35 <adnap> byorgey: It sounds like what I need though.  Do you have a link explaining this?
02:33:44 <byorgey> adnap: it's GADT syntax
02:33:52 <h_noob> Cale: I thought that fmap will get rid of IO for me but apparently it's not how it works
02:33:56 <Cale> h_noob: you're trying to print an IO action
02:33:56 <byorgey> adnap: let me see if I can find you some links
02:34:01 <quicksilver> http://www.haskell.org/haskellwiki/Existential_types
02:34:07 <quicksilver> adnap: ^^ that's what byorgey is doing
02:34:08 <Cale> fmap :: (a -> b) -> IO a -> IO b
02:34:12 <quicksilver> although he's using GADT syntax
02:34:13 <Cale> (in this case)
02:34:13 <adnap> byorgey: That's what quicksilver was talking about!
02:34:14 <byorgey> thanks quicksilver 
02:34:23 <quicksilver> adnap, byorgey: however, it's important to realise that what byorgey is doing won't work.
02:34:36 <quicksilver> adnap: you will be able to serialise but never deserialise.
02:34:47 <quicksilver> that's what Taejo was saying.
02:34:56 <byorgey> ah, indeed
02:35:06 <h_noob> Cale: this is tricky... I thought that as a result I would get Data.Map but I got IO action :)
02:35:17 <byorgey> could you stick on a Typeable constraint or somesuch?
02:35:17 <adnap> quicksilver: Why not though?  Can't I just call decode?
02:35:24 <Cale> h_noob: Well, it shouldn't be much of a surprise.
02:35:27 <quicksilver> how does it know which type to decode to?
02:35:29 <byorgey> typed deserialization is a bear
02:35:33 <Cale> h_noob: It does IO, so it had better be an IO action
02:35:34 <quicksilver> all it has is a bytestring
02:35:45 <quicksilver> a single bytestring migh easily represent different things in different types.
02:35:54 <adnap> quicksilver: http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html#v%3Adecode
02:36:02 <Taejo> quicksilver: you can serialize the type
02:36:06 <quicksilver> adnap: I know how binary works.
02:36:16 <quicksilver> Taejo: right. But that's not been proposed so far.
02:36:24 <quicksilver> Taejo: my question was rhetorical.
02:36:29 <Taejo> ok
02:36:30 <h_noob> Cale: but only getContents does actual IO - the rest of the functions are pure, isn't it?
02:36:30 <adnap> quicksilver: Well, I don't understand.  How does decode work then?
02:36:41 <adnap> quicksilver: If a ByteString can encode a bunch of different things.
02:36:43 <quicksilver> by the compiler knowing the type to expect
02:36:54 <Cale> h_noob: makeMap reads a file because it uses getContent
02:37:03 <quicksilver> and calling the appropriate decode.
02:37:03 <quicksilver> Read is the same, and watch this example:
02:37:05 <quicksilver> > read "3" :: Int
02:37:06 <lambdabot>   3
02:37:09 <quicksilver> > read "3" :: Float
02:37:10 <lambdabot>   3.0
02:37:23 <byorgey> > read "3" :: Rational
02:37:25 <lambdabot>   *Exception: Prelude.read: no parse
02:37:28 <Cale> h_noob: So with that main at the end of the pastes there
02:37:29 <quicksilver> it's the compiler - that knows what type the typechecked foudn - which chooses which 'read instance' to call.
02:37:49 <Cale> h_noob: let m = makeMap "data.ini" means "define m to be the same action as this"
02:38:25 <Cale> h_noob: while you probably really want  m <- makeMap "data.ini"  which means "run this action and define m to be its result"
02:38:55 <adnap> quicksilver: So, when I call this function decode, and I give it a ByteString, what happens?  I'm confused.
02:39:16 <adnap> quicksilver: Are you saying it wont know to give me something like (Binary Integer)?
02:39:28 <Taejo> adnap: unless the compiler can work out the type you want out, it gives you an ambiguous type error
02:39:39 <Cale> h_noob: A bit better way to structure this program, perhaps, would be to move reading the file into main, and have the rest of the functions which need the contents of that file take an additional String parameter
02:39:41 <h_noob> Cale: thank you... I'm obviously missing important piece of understanding here regarding distinction between pure and impure functions
02:39:42 <adnap> Taejo: What is the point of having this decode function then?
02:40:03 <Taejo> adnap: well if you know the type of the thing in the bytestring you can decode it
02:40:13 <adnap> Taejo: How do you signal this?
02:40:18 <Cale> h_noob: Which would mean that they no longer have to read a file, and so would not need to be IO actions anymore
02:40:30 <h_noob> Cale: I actually moved it out of the main in hope of separating IO from pure functions :)
02:40:45 <Taejo> adnap: decode bs :: Int
02:40:48 <Cale> h_noob: If the result of some computation depends on the contents of a file, IO must appear somewhere in its type.
02:40:57 <Taejo> adnap: or decode bs :: SomeOtherType
02:41:13 <h_noob> Cale: I'll try to do that after lunch :)
02:41:18 <Cale> h_noob: But of course, you can also make the dependency on the contents of the file just be a String parameter
02:41:22 <byorgey> adnap: you can either give an explicit type signature like Taejo is showing, or more often, the result type can be inferred from the context in which the call to decode is used.
02:41:25 <adnap> Taejo: You mean, decode bs :: (Binary Integer)?
02:41:25 <Taejo> in an actual program, if you do something to the value you deserialize, the compiler can work it out
02:41:32 <Taejo> adnap: no I don't
02:41:36 <Cale> h_noob: and actually read the file somewhere else :)
02:41:50 <ivanm> preflex: seen Heffalump 
02:41:51 <preflex>  Heffalump was last seen on #haskell 10 hours, 6 minutes and 4 seconds ago, saying: if hlint borks, it's probably a haskell-src-exts bug
02:41:56 <adnap> Taejo: Oh wait, Binary is a type class.
02:42:03 <adnap> Taejo: I'm still pretty new to Haskell.
02:42:09 <Taejo> also, you name the type you want out
02:42:17 <h_noob> Cale: that's exactly what I was trying to do - read file in one place and simply work with the result (Strings) in all others
02:42:51 <adnap> Taejo: Okay, so the way I will probably deserialize will be based on the first atom, which will be a string.
02:43:13 <Cale> h_noob: Right, okay, so the problem is that you have some functions which take a file path as a parameter now
02:43:31 <Taejo> adnap: something like that
02:43:32 <Cale> h_noob: and a file path is a pretty useless thing unless you do some IO to read the file
02:44:02 <Cale> h_noob: So my advice would be to instead of taking the file path as a parameter, design them to take the contents of the file as a parameter
02:44:27 <Cale> h_noob: Of course, that will mean that getContent becomes the same thing as removeComments
02:44:49 <Cale> h_noob: But then makeMap = parsedMap . removeComments
02:48:57 <h_noob> Cale: erm... I feel emptines in my cranial... :) There got to be some function which takes path - something which reads it, right? And it got to be with do and actions... or do you suggest to move reading to main and apply getContent there?
02:50:03 <Cale> h_noob: readFile?
02:50:14 * hackagebot hakyll 2.2.2 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.2.2 (JasperVanDerJeugt)
02:50:26 <PetRat> I'm looking at the laws of MonadPlus wrt the bind (>>=) operator. I see "mzero >>= f = mzero" and "v >> mzero = mzero" Anything else?
02:50:31 <Cale> h_noob: readFile takes a file path, and produces the IO action for reading that file
02:51:45 <Cale> PetRat: the latter isn't usually true
02:52:13 <CalJohn_> I'm trying to run my main function instead ghci (for debugging).  How do I pass the command line arguments in?
02:52:17 <Cale> PetRat: Most instances either satisfy: mplus a b >>= k = mplus (a >>= k) (b >>= k)
02:52:18 <Cale> or
02:52:22 <Cale> mplus (return a) b = return a
02:52:22 <PetRat> Oh, I see the source for Control.Monad mentions that's not true of System.IO.IO
02:52:29 <Cale> http://www.haskell.org/haskellwiki/MonadPlus
02:52:33 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
02:53:00 <Cale> CalJohn_: :set args <arg1> <arg2> ...
02:53:47 <CalJohn_> ah, thankyou.  the flag reference part of the ghc manual didn't have that.  i suppose that was the wrong place to look
02:54:23 <Cale> CalJohn_: It can be convenient to write a separate function, say main', which takes the list of args as a parameter, and make main = main' =<< getArgs
02:54:40 <Cale> CalJohn_: See :help
02:56:31 <CalJohn_> yeah, I've been doing that, but that's a pain for small things :)
02:59:05 <PetRat> Cale: I've been reading Typeclassopedia. It doesn't convey a sense there is much controversy over MonadPlus. Well, I'll probably go on to the next section. I think I've gone far enough into MonadPlus for now.
03:01:47 <Tarrasch> lol, what a geeky name for a magazine: "The Monad.Reader" :p
03:02:19 <jamii> Tarrasch: considering the mean geekiness of the intended audience...
03:02:20 <lambdabot> jamii: You have 1 new message. '/msg lambdabot @messages' to read it.
03:02:30 <PetRat> I don't know how new you are to the Haskell community but there are puns everywhere.
03:03:09 <jamii> wow, lambdabot saved that message for me for 18 months
03:03:15 <jamii> ive been away for a while...
03:03:33 <PetRat> Brent Yorgey's blog is titled: Brent -> [String]
03:03:53 <byorgey> PetRat: I wasn't aware of the MonadPlus controversy at the time I wrote it, I'll include something about it for the second edition =)
03:03:56 <ivanm> yeah, my blog name isn't that clever :(
03:04:06 <ivanm> byorgey: there's going to be a second edition? :o
03:04:17 <byorgey> ivanm: yes, soon as I get a round tuit
03:04:37 <Tarrasch> whats the controversy about MonadPlus now? ambigiousity when using Transformers?
03:04:58 <kfish> byorgey, what is the type of a round tuit?
03:05:07 <ivanm> byorgey: I wasn't aware the Tashkent University of Information Technologies came in a round version...
03:05:08 <ivanm> :p
03:05:45 <jamii> does anyone have any experience with capturing audio input in haskell? there seem to be a hell of a lot of options
03:05:52 <quicksilver> the controversery about MonadPlus is just which laws mplus should behave, right?
03:05:59 <kfish> jamii, what are the options?
03:06:03 <quicksilver> there are "additive-type" monadPluses and "alternative-type"
03:06:08 <jamii> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:sound
03:07:00 <PetRat> byorgey: while you're here, I'm trying to find an example of MonadPlus which uses both >>= or >> and mplus in the same code example. I just feel there must be some reason both exist, but Douglas Auclair's article doesn't give a sense of that.
03:07:08 <kfish> jamii, only the alsa and jack packages look related to sound capture
03:07:40 <jamii> kfish: alsa, portaudio, pulseaudio can do it directly
03:07:40 <kfish> and portaudio
03:08:04 <kfish> jamii, so it's more of a general linux-audio-dev question ... what interface do you want to use/support?
03:08:14 <byorgey> kfish: RoundTuit is a type.  but the only function in the API is  getRoundTuit :: IO (Maybe RoundTuit)
03:08:33 <kfish> byorgey, what happens if you try to strictly evaluate it?
03:08:53 <jamii> im not fussed. whichever has the best haskell bindings / documentation. was just wondering if anyone had an opinion on which was easiest
03:09:07 <byorgey> kfish: it depends.  usually you get Nothing.
03:09:16 <kfish> byorgey, sounds fair
03:09:49 <ivanm> byorgey: shouldn't there be some action being returned as well?
03:09:57 <byorgey> PetRat: note that any example using do-notation is implicitly using >>= and/or >> to chain together the statements in the do-block
03:10:08 <ivanm> getRoundTuit :: IO Either (RoundTuit a) a
03:10:13 <kfish> jamii, i haven't tried but i would like to know too ... i've done lots of linux audio stuff in C, not yet in haskell
03:10:15 <ivanm> bah, wrap the Either in parens
03:10:50 <byorgey> PetRat: does that answer your question?  otherwise I don't know of any good examples off the top of my head.
03:10:50 <PetRat> byorgey: yes, I can't find an example that uses mplus within do notation. I don't know if I'm belaboring the issue, but I just sense there is some potential here I don't get.
03:10:51 <jamii> kfish: what would you prefer in c? all i want to do is capture microphone or audio in and run fft on it
03:11:20 <byorgey> PetRat: fair enough.  Well, I can try to find some for the second edition.
03:11:25 <Tarrasch> PetRat, are you looking for an example using mplus and do-notation together?
03:11:43 <PetRat> Tarrasch: yes, or to be strict, >>= and/or >>
03:11:59 <Tarrasch> PetRat, so any use of mplus you mean?
03:12:16 <byorgey> ivanm: hehe
03:12:21 * hackagebot template 0.2 - Simple string substitution  http://hackage.haskell.org/package/template-0.2 (JohanTibell)
03:12:38 <PetRat> Hmm what about do { x <- (m1 `mplus` m2) ; return x}
03:12:51 <PetRat> I guess that's just the same as m1 `mplus` m2
03:12:54 <quicksilver> yes ;)
03:13:00 <kfish> jamii, for desktop stuff, probably pulseaudio (esp. on ubuntu etc.); for pro audio that you want to route to ardour etc. then jack
03:13:26 <quicksilver> you see "(do this; this; this;) `mplus` (do that; that; that;)" occasionally
03:13:34 <Tarrasch> PetRat, http://en.wikibooks.org/wiki/Haskell/Monad_transformers , I liked there example where they in the end use msum to repetively ask the user for a password untill the password is OK
03:13:45 <kfish> jamii, alsa api is too much of a pita to bother with any more, i can't see haskell solving that problem ;-)
03:13:47 <jamii> kfish: ok, ill check out the pulseaudio bindings
03:13:50 <jamii> cheers
03:13:54 <quicksilver> not necessarily with (), you can use layout instead if you're careful.
03:14:07 <kfish> jamii, no worries, be sure to blog about it :-P
03:14:36 <jamii> kfish: will do. making a real-life guitar hero.
03:14:45 <kfish> jamii, sweet :)
03:14:46 <PetRat> Oh, these are good examples. I will check them out tomorrow. 
03:15:04 <Nibble> and $ map (>4) [5,6,7,8] == and (map (>4) [5,6,7,8]) ??
03:15:16 <Tarrasch> PetRat, yea, you can't really never understand anything untill you've looked at examples :)
03:15:18 <byorgey> PetRat: when writing parsers I often use <$> and <*> (Applicative) in conjunction with <|> (Alternative), which technically does not answer your question at all but is in a similar spirit.
03:15:18 <Cale> Nibble: yes
03:15:46 <Cale> Nibble: == all (>4) [5,6,7,8]
03:16:00 <byorgey> == True
03:16:33 <Nibble> Cale: so, all does check if a predicate matches each and every value in a list?
03:16:40 <Cale> Nibble: yeah
03:17:00 <byorgey> yes, all p = and . map p
03:17:57 <Cale> Or, perhaps more precisely, it ensures that there are no elements for which it fails.
03:17:57 <Nibble> Cale: sounds sweet
03:18:30 <Cale> (It will stop if it finds one)
03:18:59 <Cale> > all (< 1000) [1..]
03:18:59 <lambdabot>   False
03:21:14 <Nibble> > all (< 1000) [1001..]
03:21:15 <lambdabot>   False
03:21:28 <Nibble> > ny (<= 1000) [1001..]
03:21:29 <lambdabot>   Not in scope: `ny'
03:21:32 <Nibble> > any (<= 1000) [1001..]
03:21:36 <lambdabot>   mueval-core: Time limit exceeded
03:21:40 <Nibble> shit
03:21:42 <Nibble> :P
03:22:33 <Cale> Yeah, it just takes forever, not finding one there.
03:25:51 <quicksilver> > any (<= 1000) ([1001..] :: [Word16])
03:25:52 <lambdabot>   False
03:26:28 <Phyx-> how the..
03:26:45 <Cale> hm?
03:27:02 <Cale> > last ([1001..] :: [Word16])
03:27:03 <lambdabot>   65535
03:27:46 <Phyx-> right, a maxbound
03:27:57 <Phyx-> the previous one is probably using Integer?
03:28:04 <quicksilver> Integer is the default, yes.
03:28:04 <Nibble> Cale: what is Word16? 16bit integer or something?
03:28:22 <Nibble> or a short or what you call it
03:28:25 <tab> Nibble: yes 16 bit unsigned integer
03:28:26 <Cale> Nibble: A 16 bit positive integer
03:28:33 <Cale> er, non-negative :)
03:28:51 <Nibble> Cale: that's positive, atleast
03:28:59 <Cale> With arithmetic modulo 2^16
03:29:25 <quicksilver> > negate (1::Word16)
03:29:25 <lambdabot>   65535
03:29:27 <Cale> (but the Enum instance doesn't cycle)
03:29:32 <Nibble> Cale: how do you epxress upper bounds in haskell?
03:29:58 <Cale> Nibble: In what context?
03:30:02 <Nibble> like if I want to make a function that evaluates to x + 100 where x is a parameter
03:30:11 <Nibble> and its upper bound is 50
03:30:12 <Cale> Nibble: Word16 has those bounds because of its representation
03:30:16 <Nibble> Cale: I know
03:30:23 <Nibble> Cale: I am just asking if that is possible
03:30:23 <Cale> > maxBound :: Word16
03:30:24 <lambdabot>   65535
03:30:28 <Cale> > maxBound :: Word32
03:30:29 <lambdabot>   4294967295
03:30:31 <Cale> > maxBound :: Word64
03:30:32 <lambdabot>   18446744073709551615
03:30:41 <Cale> > maxBound :: Int64
03:30:42 <lambdabot>   9223372036854775807
03:30:49 <Cale> > minBound :: Int64
03:30:50 <lambdabot>   -9223372036854775808
03:31:01 <byorgey> Nibble: you mean your function should accept 50 as an input, but should give an error on 51?
03:31:11 <Nibble> byorgey: no, taht wraps around
03:31:19 <Nibble> I can make a type for it
03:31:29 <Cale> Nibble: Oh, you would just mod out by whatever using the mod function
03:31:37 <Nibble> Cale: example?
03:31:46 <Cale> > mod 74289179 1000
03:31:47 <lambdabot>   179
03:32:11 <byorgey> > let f x = (x + 100) `mod` 50  in f 23   -- like this?
03:32:12 <lambdabot>   23
03:32:20 <byorgey> of course, that is the identity function =)
03:32:30 <byorgey> er, no it's not
03:32:55 <earthy> it is for a type Z50...
03:33:00 <byorgey> right =)
03:34:41 <ivanm> preflex: seen nominolo 
03:34:41 <preflex>  nominolo was last seen on #haskell 18 hours, 54 minutes and 17 seconds ago, saying: it might still write .hi files, not sure.
03:36:08 <Phyx-> earthy: what's a type Z50?
03:36:57 <Nibble> @src Ord
03:36:58 <lambdabot> class  (Eq a) => Ord a  where
03:36:58 <lambdabot>     compare      :: a -> a -> Ordering
03:36:58 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:36:58 <lambdabot>     max, min         :: a -> a -> a
03:37:10 <Nibble> @src compare
03:37:11 <lambdabot> compare x y | x == y    = EQ
03:37:11 <lambdabot>             | x <= y    = LT
03:37:11 <lambdabot>             | otherwise = GT
03:37:30 <Nibble> hmm. that means that it must also implement == in some way..
03:39:25 <JoeyA> How often do people use this pattern?  http://codepad.org/WJcpoq5c  Namely, using the fixpoint combinator for slightly more elegant loops
03:39:41 <JoeyA> fix $ \repeat -> do as opposed to let repeat = ... followed by repeat by itself.
03:39:58 <ivanm> very rarely
03:40:07 <ivanm> since it isn't as elegant and harder to debug, etc.
03:40:24 <ivanm> besides, an explicit loop is often optimised better (even more so than using foldr or something)
03:43:28 <Cale> I'd expect fix to compile to basically the same thing as explicit recursion (though I might be wrong).
03:43:52 <quicksilver> it should do, yes. Fix is inlinable.
03:45:26 <Cale> As for explicit use of fix, it's something that I see more from ML programmers than most Haskell programmers, but I don't really see a reason for that.
03:45:38 <Cale> Of course, if there's a better choice of higher order function, you'd want to go with that
03:46:39 <Cale> I'm not sure I understand why this breadth first search is written in IO using IORefs though :)
03:46:53 <quicksilver> I was going to say, that's a very imperative-style algorithm
03:49:47 <JoeyA> That's the first thing that came to mind, so I went ahead and implemented it.
03:49:54 <JoeyA> You got a problem with that, buddy?  Huh, huh?
03:50:11 * JoeyA finished implementing a much more elegant functional version of bfs
03:50:36 <Cale> levels (Leaf x) = [[x]]; levels (Node x ts) = ([x]:) . map concat . transpose . map levels $ ts
03:50:45 <Cale> bfs = concat . levels
03:51:58 <ivanm> IIRC, FGL has a bfs algorithm defined
03:52:26 <Cale> bfs is significantly simpler for a tree than for a general graph :)
03:52:37 <ivanm> definitely
03:53:00 <byorgey> Phyx-: I assume earthy meant the integers mod 50.
03:53:06 <JoeyA> Here's the elegant function I wrote:  http://codepad.org/mPSdNFlT
03:53:23 <JoeyA> (sorry, not quite as much combinator-fu there, but it's readable :-) )
03:53:53 <byorgey> Phyx-: the notation Z_n is often used to denote the ring of integers {0,..,n-1} under addition and multiplication mod n.
03:56:35 <ssbr> Hey guys. I'm mostly an imperative programmer, did some (pure) Scheme but I didn't feel like I "got" functional programming even if I could code relatively fluently and idiomatically. What would be a good tutorial for me to take? There are quite a few listed on the website.
03:58:10 <jem777> ssbr, real world haskell is nice
03:58:21 <Cale> ssbr: hmm... I wonder if you'd get much from "Why Functional Programming Matters"
03:58:57 <ssbr> Cale: I can understand why it would matter, I just don't feel as if my brain has expanded or changed, really.
03:59:06 <ssbr> It's not like Prolog where I was really challenged to think differently, for example.
04:00:21 <ssbr> Prolog I know I don't get it, but that's OK. I intend to keep trying. FP just hasn't done anything. I don't know if I'm supposed to have some epiphany or if I already got it incidentally doing other things, or whatever.
04:00:47 <Cale> ssbr: Well, the paper shows some nice examples of how functional programming in general, and lazy functional programming in particular can help to structure programs. I haven't seen too many people who didn't already get it for whom that paper made a big difference though.
04:00:53 <Cale> ssbr: hmm
04:01:20 <Cale> ssbr: Well, you know that recursion isn't how we really want to write programs, yeah? :)
04:02:05 <ssbr> Cale: Depends on the task, surely. Recursion has its uses even in imperative programming.
04:03:40 <ssbr> If you mean tail recursion instead of  loops, that's always seemed a trivial difference to me.
04:04:06 <ssbr> Bah.
04:04:35 <byorgey> ssbr: I think what Cale is getting at is that we like to use higher-order recursion combinators rather than explicitly writing recursive functions.
04:05:22 <Cale> sorry about that, power just dropped out
04:05:38 <ssbr> OK, I can get that. It's not something I've really thought about explicitly.
04:05:56 <byorgey> Cale: check the log, is what I said correct?
04:06:27 <ssbr> (FWIW, I have used HOF in Python and Scheme often enough)
04:07:13 <ssbr> Although I've never really understood things like the Y combinator, was never covered in depth when I learned the untyped lambda calculus. It was, "hey, look, a magic trick"
04:07:27 <ssbr> "you do not have to memorize this for the test on friday!"
04:08:05 <Cale_> urk
04:08:17 <Cale_> I think they're working on the power lines or something, after last night's storm
04:10:02 * hackagebot pdynload 0.0.2 - pdynload is polymorphic dynamic linking library.  http://hackage.haskell.org/package/pdynload-0.0.2 (AndyStewart)
04:11:16 <Cale> ssbr: anyway, the point I was trying to work up to before being rudely interrupted by two power outages, was that higher order functions are how we really want to put programs together
04:12:00 <ssbr> Cale: OK. I dunno if you saw it, byorgey guessed at your intent correctly.
04:12:26 <ssbr> Cale: And what I said, and will say again, is that, OK. I can get this, I just wouldn't have thought of it myself. It's not something I have thought about, just something I have done.
04:13:19 <codolio> It's okay. It's not something a lot of people seem to think of.
04:13:54 <codolio> Many people are content writing 'for(i = 0;i < length x;i++) ...' over and over.
04:15:00 <Cale> ssbr: Another nice thing, which is the other side of the same coin, is that the ability to write higher order functions means that whenever you bump into two programs which are quite similar except a piece of code or two in the middle which changes, and not just an integer or something, you're not stuck writing the same piece of code out over and over.
04:15:11 <theorbtwo> codolio: Of course, you also picked one of the worst languages for your psudocode.
04:15:22 <ssbr> codolio: That pattern was dropped a while ago for most popular languages, I think
04:15:35 <theorbtwo> The perl version, for example, is for my $i (0..length $x) {...}.
04:15:40 <codolio> Yeah, people are getting there.
04:15:41 <ssbr> codolio: mostly they'd use something like a for-each loop, which bears more than a superficial resemblance to a restructured call to map()
04:17:18 <ssbr> Cale: All it sounds like to me, is that HOF are another way of saying "design patterns". Except instead of objects, you have functions. Except objects always really were just closures if you thought of them the right way. So, I still don't get it.
04:18:25 <ssbr> Well, I do get it in part. It is certainly more convenient to use functions than to write whole classes that do the same thing, depending on your situation.
04:18:55 <ssbr> But this part of it probably won't bring me enlightenment, I think, unless there really is more to it than I'm seeing.
04:18:56 <Cale> ssbr: I don't really like to think of functions in terms of closures
04:19:01 <Cale> That's way too low-level
04:19:14 <Cale> Closures are an implementation mechanism which might be used to implement functions
04:19:25 <ssbr> Cale: Well, objects in terms of functions. I used the term "closure" to make explicitly exactly how they're alike, otherwise people ask odd questions
04:19:30 <Cale> yeah
04:21:42 <ssbr> So far it pretty much all feels like the same game in new trappings, I guess.
04:21:52 <ssbr> Which is not what I'm generally lead to believe FP is like.
04:22:26 <ssbr> (I acknowledge that Haskell in particular has things above and beyond mere FP, like laziness and a very strict type system)
04:22:41 <ssbr> "mere" is a wrong word, sorry. "only" I should say
04:22:50 <ssbr> I do not mean to be diminutive and that's definitely not how I feel.
04:23:56 <Cale> ssbr: Okay, well, to a certain extent you're right, though the manner in which polymorphism arises in OOP and in traditional FP is a bit different.
04:24:41 <ssbr> Ooh, polymorphism is something I haven't experienced being changed.
04:24:42 <Cale> ssbr: polymorphism in (traditional) OO is existential: you have the ability to say that "there is some type satisfying some conditions which is the type of such and such value"
04:24:59 <Cale> Usually, this is by subtype polymorphism
04:25:49 <Cale> Class hierarchies and all that make it explicit, but it's present even in untyped OO languages, where the type of an object is just the set of messages it is capable of responding to (with their types)
04:26:38 <ssbr> untyped or duck-typed or structurally typed, I think
04:26:55 <Cale> yes
04:27:41 <Cale> To me, types are statements about the program that the compiler is going to verify for you using the program text. So I might say untyped where many people would say dynamically typed.
04:28:28 <ssbr> I believe at the low-level end of programming, truly being untyped means everything accepts all messages and you might blow something up in the process. Or alternatively, there are no messages. I'm not sure which.
04:29:00 <ssbr> I get what you mean, anyway.
04:29:11 <jaspervdj> sm: Did the fix for the hledger hakyll site work?
04:29:14 <Cale> Anyway, by contrast, in traditional FP, polymorphism is mostly universal: you say that for all types t, the type of your value is some type expression in t
04:30:02 <Cale> :t map
04:30:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:30:18 <Cale> :t length
04:30:19 <lambdabot> forall a. [a] -> Int
04:30:36 <ssbr> Ah, that second one is more like it.
04:31:29 <ssbr> I do not understand the first. (I haven't started reading the tutorial I was suggested, I am in the middle of a slide presentation I was sent in a similar conversation)
04:31:34 <Cale> Ah, okay
04:32:05 <ssbr> (http://wiki.jvmlangsummit.com/images/a/ab/HickeyJVMSummit2009.pdf)
04:32:06 <Cale> For any types a and b, map takes a function from values of type a, to values of type b, and a list of values of type a, and gives a list of values of type b
04:32:51 <Cale> Or: map takes a function from values of type a to values of type b, and gives a function from lists of values of type a to lists of values of type b
04:33:02 <Cale> Those are the same :)
04:33:42 <Cale> > map show [1,2,3]
04:33:43 <lambdabot>   ["1","2","3"]
04:33:47 <ssbr> That second explanation helps me understand why the -> seemed to mean different things at different times.
04:33:52 <Cale> > map (*10) [1,2,3]
04:33:53 <lambdabot>   [10,20,30]
04:33:53 <ssbr> So, the reason is currying then
04:33:57 <Cale> yeah
04:34:06 <Cale> It actually always means the same thing
04:34:10 <Cale> and it associates to the right
04:34:14 <ssbr> Right.
04:34:14 <Cale> So when you have
04:34:18 <Eduard_Munteanu> How would I do inheritance in Haskell? Say I have an instance A and and instance B of the same class, and I want B to behave mostly like A.
04:34:20 <Cale> f :: A -> B -> C -> D
04:34:27 <Cale> it means A -> (B -> (C -> D))
04:34:32 <Cale> and when you write
04:34:34 <Cale> f x y z
04:34:39 <Cale> it means ((f x) y) z
04:34:47 <Eduard_Munteanu> Any general pattern or nice syntax? Or should I do something ad-hoc?
04:34:48 <ssbr> This might take getting used to.
04:34:59 <ssbr> Cale: You don't have to be my human tutorial, anyway!
04:35:03 <ssbr> Thank you very much
04:35:12 <Cale> ssbr: It's no problem :)
04:35:31 <ssbr> I will get on reading Real World Haskell as soon as I finish this thing
04:35:40 <Cale> Eduard_Munteanu: Well... there are a bunch of things. You could have B actually contain a value of type A somehow, perhaps?
04:36:12 <Eduard_Munteanu> Cale: yes. It should wrap around it... it's some xmonad layout modifier I'm doing.
04:36:40 <Cale> Eduard_Munteanu: You might consider at least having a function B -> A
04:36:48 <Cale> (To act like an upward cast)
04:37:28 <Cale> and maybe T -> A -> B, where T is whatever extra information is needed to enrich a value of type A to be a value of type B
04:37:29 <Eduard_Munteanu> Cale: oh, say that's f, and I simply redefine every method as 'itself . f'
04:37:39 <Eduard_Munteanu> (those that remain the same)
04:37:50 <Cale> yeah
04:38:13 <Eduard_Munteanu> Cale: I suppose there isn't some magic keyword like deriving that does that automatically, is there?
04:38:49 <Cale> If you have a big inheritance tree and really want to simulate something OO-like, I recommend looking at the way that the newer Control.Exception library works.
04:38:59 <Cale> (The one in 6.10 and 6.12)
04:39:15 <Eduard_Munteanu> Cale: thanks, I'll have a look.
04:39:20 <Cale> Eduard_Munteanu: also...
04:39:51 <Cale> I wrote a bit of an article on how to do OO-like things in Haskell
04:40:06 <Eduard_Munteanu> Cale: oh, I'd be happy to have a link to it :)
04:40:18 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
04:40:24 <Eduard_Munteanu> Thanks.
04:41:06 <Cale> ssbr: You might also be interested in that :)
04:41:42 <ssbr> Cale: Possibly. I am still unsure how to organize a large program without doing something akin to message passing.
04:42:55 <dolio> If you look at it as existential versus universal, it's not that different.
04:43:34 <dolio> With existential types, you focus on building opaque boxes, with some exposed operations, which is what OO does.
04:44:11 <dolio> With universal types, you focus on writing portions of code that are blind locally.
04:44:15 <quicksilver> Eduard_Munteanu: I would do inheritance as a record of functions.
04:44:21 <Eduard_Munteanu> Hm I suppose an existential could be useful if I get to types like Foo Bar Baz Boo Fubar
04:44:36 <quicksilver> data Thing = Thing { doThis :: a -> b; doThat :: c -> d }
04:44:37 <msieradzki> Cale, with such organization you'd have code for all 50-100 game entities at each function which is kind of bad :)
04:44:54 <quicksilver> then you override like this:
04:44:56 <Cale> msieradzki: Right, that's what I'm arguing :)
04:45:05 <quicksilver> newThing = oldThing { doThat = newThat }
04:45:05 <dolio> But, a function that accepts an opaque box is the same as a blind function.
04:45:30 <quicksilver> msieradzki: in fact you can find examples for each organisation choice looking nicer
04:45:37 <quicksilver> cale's article lays out the contrast
04:45:42 <Cale> msieradzki: So sometimes it's good to turn things around and take a more OO-like approach to breaking down a problem.
04:45:44 <quicksilver> but both answers are right, for some problems.
04:45:51 <ssbr> dolio: Oh, well then that's perfect.
04:46:06 <dolio> Of course, in practice, they don't work out as being quite perfectly symmetric.
04:46:12 <Eduard_Munteanu> quicksilver: ah, that looks nice too. Will remember it, but I can't use it for xmonad atm.
04:46:28 <Cale> ssbr: Yeah, it's a difference in emphasis for what sorts of designs are made easy.
04:46:31 <ssbr> dolio: I have mixed both styles in Python, at least. It always depends on what you're doing.
04:46:54 <h_noob> question regarding handling results of IO actions with pure functions - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28352 - what am I doing wrong here? Notably why Map.lookup is failing?
04:48:13 <hpc> :t getContents
04:48:15 <lambdabot> IO String
04:48:27 <Cale> ssbr: Traditional FP favours transparent, fixed datastructures on which it is easy to extend the set of operations, many of which are polymorphic because they choose to inspect only some of the structure. Traditional OO tends to favour designs where the set of operations is relatively fixed, but the data can easily be extended with more cases
04:49:36 <Cale> ssbr: also see http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
04:50:44 <Cale> ssbr: It gives a really good idea of one of the major mindsets for doing functional programming.
04:50:54 <ssbr> Cale: This seems a realistic contrast
04:51:49 <Cale> The idea that we're not going to solve problems by attacking them head on and implementing really specific solutions, but instead are going to try to design a language in which the solution to our problem is a trivial (or much easier) exercise.
04:51:53 <ssbr> Cale: *sigh*, I'm very much not a fan of long presentations, though. Is there any written article you could suggest with similar content?
04:52:00 <fffej> h_noob: maybe if you were to annotate the functions with type signatures it might become clearer? 
04:52:47 <Cale> ssbr: Well, there are slides, and a related article
04:52:59 <Cale> ssbr: But it's quite a good presentation as these things go :)
04:53:16 <Cale> (Simon is a very good presenter)
04:53:22 <jamii> ssbr: just caught up. this is a nice example of how GoF design patterns can be implemented just as libraries in more expressive languages http://norvig.com/design-patterns/ppframe.htm
04:53:23 <ssbr> I don't really have the patience. They move so slowly and I feel like I am wasting my time. I can read very quickly.
04:53:33 <h_noob> fffej: I'm not that familiar with haskell yet, so type signatures in ghc errors do not tell me much
04:53:58 <ssbr> At least, relative to the necessarily slow and enunciated pace of a talk.
04:54:41 <ssbr> jamii: Haa
04:54:52 <ssbr> By the end of this I will have several weeks worth of reading :)
04:55:02 <ssbr> (it's good, though)
04:55:30 <jamii> so where the visitor pattern is a design pattern in java, in haskell its the functor class. making your language more expressive allows you to describe design patterns in code rather than in lengthy and overrated books
04:56:45 <Cale> Yeah. Design patterns are a sign of inexpressivity in a programming language (and every language has its weaknesses). Once you can turn something into just a definition in a library, you tend not to call it a design pattern anymore :)
05:00:04 <quicksilver> ssbr: yes, I hate videos on the web for that reason.
05:00:10 <quicksilver> you can't skimread a video.
05:00:25 <ssbr> Cale: Perhaps. A lot of people say this, also in imperative languages. I think they are maybe overemphasized, but their role analogous to HOFs etc., in which somebody might even just call it an API or class or interface or whatever, is fairly solid, if underappreciated.
05:00:46 <jamii> quicksilver: i did see some video lectures designed specifically for video
05:00:49 <Cale> I think SPJ's videos are worth the investment in time though. :)
05:00:55 <jamii> you wouldnt have been able to follow them in person
05:01:06 <ssbr> jamii: that's curious
05:01:15 <quicksilver> you mean they were very dense and designed to be paused?
05:01:31 <Cale> There's a bit of that aspect in the Catsters' videos
05:01:48 <ssbr> Cale: Some are, but I have a lot to do at the moment, including learning myself a haskell. At the least, I won't watch that video for a while.
05:01:48 <jamii> Cale: thats the kind of thing i was thinking of
05:02:10 <theorbtwo> quicksilver: I sometimes watch them in mplayer at 120% speed.
05:02:11 <jamii> its an interesting way to teach
05:02:27 <ssbr> Sometimes it's difficult to sit down and commit to spending a lot of time. It's the same reason I haven't seen inception yet.
05:02:30 <quicksilver> theorbtwo: that helps, but only a bit :)
05:02:37 <jamii> ssbr: inception is worth it
05:02:40 <ssbr> A tutorial or slideshow or article can be picked up and left off in a heartbeat. :)
05:02:40 <jamii> go
05:02:49 <ssbr> jamii: I know, I know! I will see it this weekend.
05:12:33 <Tarrasch> :t (***)
05:12:34 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
05:13:04 <fffej> h_noob: could you paste in the errors?
05:13:39 <h_noob> fffej: Couldn't match expected type `Map.Map [Char] a' against inferred type `Either ParseError (Map.Map [Char] [([Char], [Char])])' In the second argument of `Map.lookup', namely `m'
05:13:54 <h_noob> it looks like I didn't really made a Data.Map?
05:15:35 <fffej> h_noob: yeah, that sounds right, so annotate parsedMap with the type you are expecting (something like parsedMap :: [Map.Map String (String,String)]) and see what the compiler says
05:15:55 <fffej> h_noob: oops, without the extra [ ] wrappng the map
05:18:29 <h_noob> fffej: it receive set of strings and should produce mao made via Map.fromList so the type should be Map.Map -> (string) ?
05:19:37 <fffej> > :t Map.fromList
05:19:38 <lambdabot>   <no location info>: parse error on input `:'
05:19:44 <fffej> > :t Data.Map.fromList
05:19:44 <lambdabot>   <no location info>: parse error on input `:'
05:19:53 <h_noob> :t Data.Map.fromList
05:19:54 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
05:21:09 <fffej> h_noob: that's what I was trying to do :)  so Map.fromList will produce output of M.Map k a.  I don't know what type (parse xdata "test parser" text) returns?
05:21:58 <Polarina> What's the difference between TChan and Chan?
05:22:04 <h_noob> it's from parsec library - I think it returns Either error or list of pairs
05:22:55 <fffej> h_noob - ok, so let's say it's pairs of strings, then the type of the whole function would be String -> M.Map String String
05:23:52 <copumpkin> Polarina: one lives in STM, I guess
05:24:08 <Polarina> And what is STM?
05:24:17 <copumpkin> software transactional memory
05:24:28 <copumpkin> gives you concurrency in a different way from the usual
05:24:30 <h_noob> fffej: `Map.Map' is not applied to enough type arguments Expected kind `??', but `Map.Map' has kind `* -> * -> *'  In the type signature for `parsedMap': parsedMap :: String -> Map.Map -> String -> String
05:24:32 <copumpkin> with transactions
05:24:46 <Polarina> Hmm...
05:24:50 <h_noob> fffej: I don't understand why type inferrance do not work in that case?
05:25:02 <fffej> h_noob: try String -> Map.Map String String (Map is a type that takes two more types)
05:25:04 <copumpkin> h_noob: a Map.Map of _what_?
05:25:14 <copumpkin> it's mapping from something and to something
05:25:52 <h_noob> fffej: Couldn't match expected type `Map.Map String String' against inferred type `Either  ParseError (Map.Map [Char] [([Char], [Char])])'
05:27:27 <h_noob> do you know some parsec examples where people construct complicated structures like Data.Set or Data.Map as a result of parsing?
05:27:37 <h_noob> what I have seen so far are pretty trivial
05:28:48 <quicksilver> well they won't be substantially different from examples which construct lists
05:28:57 <quicksilver> you can always call fromList on the result after all.
05:29:09 <hpc> :t fromList
05:29:10 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
05:29:26 <hpc> :t M.fromList
05:29:27 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
05:29:32 <h_noob> quicksilver: that's exactly what I'm trying to do with not much success: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28352 :)
05:29:43 <fffej> Have you seen real world haskell's chapter (http://book.realworldhaskell.org/read/using-parsec.html)?
05:29:55 <h_noob> fffej: yes
05:30:20 <quicksilver> h_noob: whenRight will always return an either type
05:30:43 <quicksilver> h_noob: so the type you give for parsedMap is wrong
05:31:00 <h_noob> quicksilver: how do I get "inside" either to extract content of Right clause/
05:31:02 <h_noob> ?
05:31:51 <quicksilver> well that's not really the issue at the moment
05:32:13 <quicksilver> the answer is by pattern matching, exactly like you already did in 'whenRight'
05:32:26 <quicksilver> but if you just want that code to compile you have to (at least)
05:32:31 <quicksilver> change the type of parsedMap to
05:32:45 <quicksilver> String -> Either ParseError (Map.Map String [(String,String)])
05:33:48 <h_noob> quicksilver: erm... you mean I should put type signature? why type inference is not working in this case?
05:34:47 <iocor> if I have an array of pairs like this http://pastebin.com/f67xFnQ2 what's a sane way to find out of the beginning of a string is one of the values in the first item in one of the pairs and the return the second item in that pair
05:35:13 <quicksilver> h_noob: you chose to put a type signature for parsedMap
05:35:23 <quicksilver> h_noob: and the one you put was wrong
05:35:26 <quicksilver> so it gave an error.
05:35:32 <quicksilver> if you leave it out, it will indeed try to infer it.
05:35:42 <h_noob> quicksilver: and will fail
05:35:44 <h_noob> :)
05:35:53 <quicksilver> only if there is another problem in the code.
05:36:05 <byorgey> iocor: use 'find' from Data.List
05:36:24 <quicksilver> since you keep pasting code we can't test
05:36:29 <h_noob> quicksilver: that's what I'm trying to figure out - what's wrong with the code
05:36:31 <quicksilver> it's quite hard to help you in more detail.
05:36:42 <quicksilver> I've told you how to fix the error you're getting.
05:36:48 <quicksilver> if you want more help you need to say what happens next
05:36:54 <quicksilver> or actually paste complete code so we can try ourselves.
05:37:00 <byorgey> iocor: something like  snd `fmap` (find (`isPrefixOf` someString) stringTokens)
05:37:36 <hpc> byorgey: why `fmap` instead of <$>?
05:37:53 <byorgey> > let tokens = [("+", 3), ("f", 6)] in snd `fmap` (find (`isPrefixOf` "foo") tokens)
05:37:55 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(a1, b)'
05:38:05 <h_noob> quicksilver: the entire code is still in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28355
05:38:25 <byorgey> > let tokens = [("+", 3), ("f", 6)] in snd `fmap` (find ((`isPrefixOf` "foo") . fst) tokens)
05:38:26 <lambdabot>   Just 6
05:38:32 <byorgey> > let tokens = [("+", 3), ("f", 6)] in snd `fmap` (find ((`isPrefixOf` "bar") . fst) tokens)
05:38:33 <lambdabot>   Nothing
05:38:57 <zygoloid> suppose I have a worker function, f :: Work -> (WorkResult, [Work]), with Eq Work, and I want to perform all the work items reachable from some starting set, once and only once each. is there an elegant way to do that, without changing my worker function?
05:38:57 <byorgey> hpc: just because I figured iocor is more likely to have seen fmap before than <$>
05:39:00 <quicksilver> h_noob: is it ? that code appears to lack a definition for 'xdata'
05:39:07 <byorgey> hpc: I'd write it using <$> myself, but it's not important
05:39:40 <Nibble> basically, $ just adds paranthesis where they should be or what?
05:40:01 <drhodes> :t ($)
05:40:02 <lambdabot> forall a b. (a -> b) -> a -> b
05:40:02 <zygoloid> ideally i'd like to use something like: doAll f s = r where (r, w') = unzip $ map f w; w = s ++ concat w'
05:40:04 <hpc> ($) has the lowest precedent, which makes it similar to parens
05:40:13 <byorgey> Nibble: $ is just function application, with a very low precedence
05:40:17 <hpc> semantically, it is a specialization of the identity function
05:40:26 <h_noob> quicksilver: crap, typo! sorry, I fixed it now :)
05:40:27 <zygoloid> (but that doesn't work because the list of WorkResult can never end in [])
05:40:29 <quicksilver> h_noob: if I replace "xdata" with "x" (is that what you meant?) and if I change the type signature for parsedMap to what I said, the code compiles fine.
05:40:47 <djahandarie> Why is fmap for a tuple over the second part of it?
05:40:56 <copumpkin> it has to be
05:41:01 <quicksilver> djahandarie: because you can only partially apply types from left to right
05:41:08 <copumpkin> (a, b) === (,) a b
05:41:11 <h_noob> quicksilver: parsedMap :: String -> Either ParseError (Map.Map String [(String,String)]) ?
05:41:16 <quicksilver> h_noob: yes.
05:41:16 <copumpkin> so the functor for fmap is ((,) a)
05:41:21 <djahandarie> Ah
05:41:36 <hpc> if you really wish to, you can make newtype Backwards b a = Backwards (a,b)
05:41:38 <h_noob> quicksilver: this gives me error Couldn't match expected type `Map.Map [Char] a' against inferred type `Either ParseError (Map.Map String [(String, String)])'
05:41:45 <copumpkin> and so fmap :: (x -> y) -> ((,) a) x -> ((,) a) y
05:42:57 <djahandarie> How does first from Arrows do it?
05:42:59 <h_noob> quicksilver: I combined with last main for clarity
05:43:22 <zygoloid> djahandarie: it explicitly only works over pairs, and specifies that it maps the fst
05:43:36 <zygoloid> @type first
05:43:37 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
05:43:40 <quicksilver> h_noob: I don't know what you mean, I'm afraid. I'll paste my version so you can see. I only changed that thing, plus commented out makeMap
05:44:16 <h_noob> quicksilver: it fails if I add map.lookup into main for example
05:44:16 <quicksilver> h_noob: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28343#a28358
05:44:29 <quicksilver> h_noob: slow down slow down, one thing at a time!
05:44:43 <quicksilver> h_noob: first we are getting what you've currently written compiling.
05:44:52 <quicksilver> it works for me, using the code I just pasted.
05:45:06 <Tarrasch> so fmap for ((->) e) is just: fmap = (.) ?
05:45:24 <zygoloid> Tarrasch: yes
05:45:46 <Tarrasch> heh, cool
05:46:04 <hpc> Tarrasch: to take it even further, in lambdabot, they took the extra step of defining (.) as fmap, instead of the other way around
05:46:06 <hpc> :t (.)
05:46:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:46:10 <h_noob> quicksilver: if I comment out Map.lookup it works for me too - even without spicific type signature - type inference do the job perfectly :)
05:46:13 <zygoloid> Tarrasch: incidentally, this means that the Functor laws are just (fmap, id) is a monoid :)
05:47:00 <zygoloid> (ok, not quite; fmap can only be applied when the lhs is a function, but nearly...)
05:47:34 <Tarrasch> hpc, so lamdabot isn't just a modified ghci? 
05:48:04 <hpc> lambdabot uses the GHC libraries to make an interactive interpreter
05:48:10 <hpc> it's way more strict than ghci
05:48:19 <hpc> Cale made a custom Prelude for it
05:48:30 <zygoloid> [associativity means  f `fmap` (g `fmap` x) == (f `fmap` g) `fmap` x == (f . g) `fmap` x,  and left identity means  id `fmap` x = x.]
05:48:35 <hpc> you can easily make your own custom Prelude, if you wanted
05:49:35 <quicksilver> h_noob: OK, so now, you want to know why you can't use Map.lookup on "m" ?
05:49:49 <quicksilver> h_noob: this is obvious from the type - "m" has type Either ...., not Map ....
05:54:05 <Nibble> Itkovian: serb?
05:55:37 <dmwit> zygoloid: I find your characterization of the functor laws very confusing.
05:55:55 <Itkovian> Nibble: eh?
05:56:04 <dmwit> There's something you're not saying there about the types matching up.
05:56:30 <Nibble> Itkovian: thinking of your nick
05:56:36 <dmwit> That is to say, we can't write "f `fmap` x" for all f and x in your "monoid", so it doesn't really seem like a monoid to me.
05:56:59 <Itkovian> Nibble: nope, belgian.
05:57:26 <h_noob> quicksilver: yeah, I read ghc error :) What I do not understand is how to create normal Data.Map e. g. the one I can make lookup into
05:57:38 <h_noob> doesn't look obvious to me yet
05:57:53 <quicksilver> h_noob: do you understand what m is?
05:58:00 <quicksilver> h_noob: it's either an error, or it's a map
05:58:05 <quicksilver> h_noob: you have to deal with those two cases.
05:58:10 <quicksilver> what would you do if it's an error?
05:58:18 <byorgey> dmwit!
05:58:25 <dmwit> byorgey!
05:58:29 <dmwit> I've been gone so long...
05:58:50 <h_noob> quicksilver: hmm... I thought error case is ruled out by whenRight?
05:58:56 <quicksilver> no.
05:59:03 <quicksilver> whenRight _ (Left err) = Left err
05:59:13 <quicksilver> ^^ it's not doing anthing with errors
05:59:17 <quicksilver> it's just "passing them through"
05:59:36 <dmwit> byorgey: How long will you still be on That Other Continent?
06:00:05 <Nibble> lol
06:00:13 <h_noob> quicksilver: ok, so I have to filter it like "whenRight _ (Left err) = Left f []"?
06:00:14 <Nibble> looks like exit in php doesn't terminate the script here
06:00:17 <Nibble> strange
06:00:28 <quicksilver> h_noob: no.
06:00:33 <quicksilver> h_noob: that still leaves a Left case.
06:00:40 <quicksilver> h_noob: you will still have to deal with the Left case then.
06:00:50 <quicksilver> h_noob: as long as whenRight returns an Either, you have two cases to deal with.
06:01:10 <quicksilver> h_noob: I don't recommend you try to fight this now - just deal with both cases in main.
06:01:41 <quicksilver> h_noob: case m of Left err -> print ("Unfortunately we had an error : " ++ show err); Right mymap -> .....
06:01:58 <quicksilver> and in ..... you put the lookup code you've been wanting to write on mymap.
06:02:57 <zygoloid> dmwit: yeah, i noted that it's not quite a monoid since fmap can only be applied when the lhs is a function
06:04:01 <dmwit> Not only that.
06:04:10 <zygoloid> what else?
06:04:32 <dmwit> fmap can only be applied when the lhs is a function, the rhs is an element of the functor'd type, and the input type of the function and the type that was functor'd match up.
06:04:58 <dmwit> But... yeah.
06:05:04 <zygoloid> dmwit: ok, the third condition too. the second is just the set over which it's a monoid. :)
06:05:38 <quicksilver> well it's a generalised monoid
06:05:43 <quicksilver> in which only certain elements can be composed
06:05:48 <zygoloid> i think perhaps the upshot is it's basically just a category :)
06:05:48 <dmwit> zygoloid: Er, no, you're claiming it's a monoid over all the functor'd types and all the functions.
06:05:49 <quicksilver> normally we call them 'categories'
06:06:01 <dmwit> zygoloid: (Since the addition of a monoid usually takes two elements of the monoid.)
06:06:21 <zygoloid> dmwit: no, i agree with your third condition. not with your second.
06:06:41 <dmwit> zygoloid: What is the underlying set that you are claiming is monoid-like?
06:06:46 <zygoloid> or rather i think your second condition is vacuous
06:07:03 <h_noob> quicksilver: thanks, it works fine... is there some tutorial where I can read how to deal with such stuff e. g. how to rule out Either with function, not in main?
06:08:03 <quicksilver> h_noob: learn you a haskell? real world haskell?
06:08:13 <quicksilver> h_noob: this isn't really a specific topic, it's just dealing with types.
06:08:24 <quicksilver> you just have to answer the question "what would you want, if there was a parse error" ?
06:08:30 <quicksilver> you could, for example, return an empty map.
06:08:33 <quicksilver> but I expect that's wrong.
06:08:40 <dmwit> zygoloid: To take you down the garden path, here's what I'm claiming: the set you are claiming is monoid-like must contain both functions and functor'd types (since you're applying the monoid addition to both, and monoid addition takes two elements of the monoid), therefore it is not vacuous to have to eliminate function types from the second argument of the addition.
06:08:41 <quicksilver> normally if there is a parse error you want to know about it and complain.
06:08:42 <zygoloid> dmwit: the set i'm claiming is a monoid except (a) the types must match up and (b) the lhs must be a function is the set of all values of type (Functor f) => f a
06:09:15 <dmwit> zygoloid: Okay, but then your monoid addition doesn't even have the type of a monoid addition; monoid additions take two elements of the monoid. =)
06:09:31 <zygoloid> dmwit: it /does/ take two elements of the monoid, since functions are in the monoid
06:09:37 <kuribas> h_noob: real world haskell is worth the money
06:09:38 <dmwit> I'm sorry?
06:09:52 <dmwit> Are we talking about a particular Functor here, or all functors?
06:09:53 <zygoloid> dmwit: the type a -> b is of the form (Functor f) => f b.
06:10:01 <zygoloid> dmwit: all functors.
06:10:17 <dmwit> okay
06:10:25 <dmwit> Then I really, really find your analogy confusing. =)
06:10:42 <h_noob> quicksilver, kuribas - thanks, I'm already reading it :)
06:10:44 <zygoloid> yeah. we're really quite a long way from 'just a monoid' once the necessary restrictions are added
06:11:10 <dmwit> What you're saying is that the equations that functors have to satisfy and the equations that monoids have to satisfy look similar at some level, which I guess is reasonable.
06:11:10 <zygoloid> i think quicksilver is right that there's not much more we can say than it's a category
06:11:40 <zygoloid> it's a monoid wherever the types match
06:12:02 <zygoloid> which is not to say that it's a monoid :)
06:13:16 <zygoloid> (more than the equations look similar, the equations are identical, subject to some extra restrictions)
06:13:59 <zygoloid> i can certainly see that the analogy is confusing though :)
06:14:39 <quicksilver> and its exactly this kind of half-analogy which motivates the existence of categories as a field of study.
06:15:06 <zygoloid> yeah. i guess categories /are/ monoids-when-the-types-match.
06:15:48 <copumpkin> monoids are categories with one object
06:15:57 <copumpkin> which is sort of like having the types match
06:18:21 <zygoloid> that's not quite as general an observation, though.
06:20:36 <Nibble> lets say I have this code, typeValue = group [5,6,5,7,10,11,10,10,2,2,2,3,2,5]
06:20:55 <Nibble> And want to find out which of the result that group evaluates to is biggest
06:21:03 <Nibble> how would I iterate over the list to do that?
06:21:12 <Nibble> oh
06:21:12 <Nibble> nvm
06:21:15 <dmwit> :t maximum
06:21:17 <lambdabot> forall a. (Ord a) => [a] -> a
06:21:21 <byorgey> :t maximumBy
06:21:22 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
06:21:27 <dmwit> I guess you have to define what "biggest" means, though.
06:21:33 <zygoloid> @type maximumBy (comparing length) . group
06:21:34 <lambdabot> forall a. (Eq a) => [a] -> [a]
06:21:36 <dmwit> yeah, maximumBy
06:21:48 <byorgey> > maximumBy (comparing length) $ group [5,6,5,7,10,11,10,10,2,2,2,3,2,5]  -- like this?
06:21:49 <lambdabot>   [2,2,2]
06:22:07 <zygoloid> > maximumBy (comparing sum) $ group [5,6,5,7,10,11,10,10,2,2,2,3,2,5] -- or maybe this
06:22:07 <lambdabot>   [10,10]
06:22:21 <Nibble> yes
06:23:05 <Nibble> is maximumBy in Data.List?
06:23:11 <Nibble> how do I import it in ghci
06:23:13 <zygoloid> @index maximumBy
06:23:13 <lambdabot> Data.List
06:23:30 <quicksilver> :m Data.List
06:23:38 <Nibble> quicksilver: the + ?
06:23:40 <Nibble> Don't I need it
06:23:54 <quicksilver> you need a + f you already have some modules you don't want to go out of scope
06:23:57 <quicksilver> :m +Data.List
06:24:03 <zygoloid> you can use 'import' as a synonym for ':m +'
06:24:12 <quicksilver> I don't really like that
06:24:26 <quicksilver> it creates an additional illusion that ghci is like a haskell source file, when it isn't
06:24:47 <ivanm> quicksilver: agreed
06:24:53 <quicksilver> and it's not even less typing ;)
06:25:32 <zygoloid> it means i don't need to remember the + ;-)
06:26:23 <dmwit> It's less shift-ing, for what it's worth.
06:26:41 <quicksilver> I'm am
06:26:45 <quicksilver> an emacs user
06:26:50 <askhader> Hello.
06:26:52 <quicksilver> modifier keys are a way of life ;)
06:26:55 <Nibble> hmm , I get not in scope errors
06:27:09 * ivanm waves in askhader's general direction
06:27:17 <Nibble> maximumBy is not in scope, neither are comparing nor group
06:27:53 * hackagebot cpsa 2.1.0 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.1.0 (JohnRamsdell)
06:27:57 <zygoloid> comparing is in Data.Ord. the other two are in Data.List
06:28:10 * ivanm prefers compare `on` to comparing
06:28:34 * zygoloid doesn't like importing Data.Function ;)
06:28:41 <ivanm> why not?
06:29:08 <zygoloid> because the import is longer than the definition of 'on' :)
06:29:25 <zygoloid> but redefining 'on' seems wrong
06:29:32 <ivanm> heh
06:30:02 <dmwit> But if you redefine 'on', how will you get the benefit of GHC's later improvements to the implementation!
06:30:30 <ivanm> wow, everything else in Data.Function is either fix or in the Prelude...
06:30:33 <ivanm> dmwit: heh
06:30:36 * zygoloid would be strongly in favour of moving 'on' to Prelude
06:30:55 * quicksilver wishes you could re-export qualified imports
06:31:06 <quicksilver> then it would make sense to have a "re-export-only" module of convenient imports.
06:31:22 <ivanm> quicksilver: hmmmmm? you can, can't you?
06:31:28 <ivanm> or do they lose the qualification?
06:31:33 <ivanm> +s
06:32:18 <quicksilver> you can't re-export the qualification.
06:32:27 <benmachine> ivanm: try Data.Bool
06:33:24 <ivanm> benmachine: for?
06:33:39 <ivanm> oh, right
06:33:49 <ivanm> yeah, it seems to be completely re-exports of the Prelude
06:34:39 <benmachine> it happens
06:35:09 <benmachine> @pl \f g x y -> f (g x) (g y)
06:35:09 <lambdabot> join . ((flip . ((.) .)) .) . (.)
06:35:51 <zygoloid> @@ @pl @djinn @type on
06:35:52 <lambdabot>  f = ((const .) .) . join . liftM2
06:36:03 <zygoloid> @@ @djinn @type on
06:36:04 <lambdabot>  f a b c _ = a (b c) (b c)
06:36:18 <benmachine> @type on
06:36:19 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:36:19 <zygoloid> weird, i thought djinn used all the arguments if it could
06:36:35 <benmachine> oh, yeah I thought so too
06:36:52 <zygoloid> i guess it'd already proved 'b' and just reused the proof
06:37:20 <quicksilver> I think djinn's proof theory is pretty ad-hoc
06:37:35 <quicksilver> there is some kind of weak relevant pressure
06:37:39 <quicksilver> but I can't always predict it.
06:37:48 <copumpkin> ad-hic-haec-hoc
06:38:49 <benmachine> I got haskell-src-meta compiling
06:38:58 <benmachine> but unfortunately in the process, I kind of forgot what it was for
06:39:21 <ivanm> benmachine: TH wrapper around haskell-src-exts
06:39:34 <benmachine> ivanm: it has functions for converting HSE -> TH syntax
06:39:39 <ivanm> not updated recently though, since mmorrow is AWOL
06:39:45 <benmachine> that seems the main point of it
06:39:49 <ivanm> benmachine: yeah
06:39:53 <benmachine> it also has Lift instances for TH datatypes
06:39:56 <benmachine> ...for some reason
06:40:11 <benmachine> and, a brainfuck interpreter quasiquoter
06:40:37 <ivanm> really? it has brainfuck as part of it?
06:40:43 <benmachine> not as part of it as such
06:41:15 <benmachine> it just contains Language.Haskell.Meta.QQ.{BF,Here,Hs,HsHere,Idiom,SKI}
06:41:27 <benmachine> I don't think any of those are used by any of the rest
06:41:29 <zygoloid> benmachine: it's basically a bunch of missing bits from TH, and some examples, afaict :)
06:41:32 <benmachine> they're just, sort of neat extra things
06:42:42 <benmachine> yeah, I guess they're examples of usage
06:44:54 <benmachine> @ask Igloo does th-lift have a source repository, or any work more recent than version 0.3 on hackage? I was planning to extend it with newtype/record constructor support
06:44:54 <lambdabot> Consider it noted.
06:45:40 <Igloo> benmachine: No
06:45:40 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
06:45:53 <benmachine> heh
06:45:55 <benmachine> okay
06:46:30 <benmachine> did you just think it too small to deserve its own source repo?
06:54:40 <fryguybob> @botsnack
06:54:40 <lambdabot> :)
06:57:04 <zygoloid> @batsmack
06:57:04 <lambdabot> :)
07:07:59 <Phyx-> @src src
07:07:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:08:02 <Phyx-> @src @src
07:08:03 <lambdabot> Source not found. stty: unknown mode: doofus
07:08:11 <Phyx-> heh
07:08:18 <Phyx-> @src @/
07:08:18 <lambdabot> Source not found. Maybe you made a typo?
07:08:27 <Phyx-> @src /
07:08:27 <lambdabot> Source not found. There are some things that I just don't know.
07:08:30 <Phyx-> :P
07:10:09 <kuribas> It's apparently not possible to build a static executable that uses hxt, because it has a dependency on krb5.
07:11:23 <kuribas> So I cannot use HXT for writing a cgi script.
07:11:40 <fasta> kuribas, that doesn't really follow.
07:11:56 <kuribas> fasta: At least I don't know how.
07:12:10 <fasta> kuribas, a library is just a bunch of object files. 
07:12:11 <zygoloid> kuribas: why do you need your CGI script to be staticallly linked?
07:12:24 <fpletz> anope
07:12:34 <kuribas> Because the server has different dynamic libraries.
07:12:58 <kuribas> like glibc
07:13:37 <copumpkin> TacticalGrace: why do parallel arrays/UArrs/vectors/repa arrays all do the "array of pairs = pair of arrays" representation? it seems like for some applications you'd get better cache behavior with one representation and for others with the other, so maybe a newtype for pairs might be nice?
07:13:54 <zygoloid> kuribas: can you build the cgi script on the server (or at least on a compatible distro)?
07:14:09 <Kaidelong> I have to leave in a few, but just something quick if someone knows: is there a type class for things that are functors, have an operation analogous to conbs of type a -> b -> b, and have an element of type b that is an identity element for the cons operation?
07:14:40 <fasta> kuribas, you get the dynamic library from the server and just get all the symbols (also the ones that this dynamic library points at), then you dump those in one big libfoo.a file
07:14:44 <Kaidelong> I was thinking about whether or not unfold could be generalized to monoids and realized it probably wasn't a good idea
07:14:51 <fasta> kuribas, then you link against that. 
07:15:09 <kuribas> zygoloid: I could, but then I have to build a complete ghc6.
07:15:13 <fasta> kuribas, impossible, no. Could take some time, yes. 
07:15:30 <fasta> kuribas, getting a VPS is probably cheaper.
07:15:41 <ivanm> is it just me, or is the documentation for readProcess in System.Process wrong?
07:15:57 <zygoloid> kuribas: perhaps you could install a prebuilt static ghc6 on the server?
07:16:26 <zygoloid> kuribas: alternatively you might be able to set up a separate sysroot with your version of glibc etc
07:16:57 <kuribas> zygoloid: It's possible, but I should ask for a larger disk quota.
07:16:58 <zygoloid> or you can find what the server's running and install that in a vm, to get a compatible build area
07:18:32 <zygoloid> Kaidelong: what do you mean by there being an element of type b which is an identity for cons :: a -> b -> b? i could imagine an identity of type a, but then (:) wouldn't be such a cons (which i think is maybe what you're after?)
07:19:39 <kuribas> zygoloid: It's possible.  I wonder if it isn't easer to just get rid of HXT, and build a static binary.
07:19:57 <quicksilver> I can't see why hxt would depend on krb
07:20:10 <quicksilver> HXT is about XML manipulation, krb is about authentication tokens.
07:20:13 <Kaidelong> zygloid: [] is an identity element for cons
07:20:15 <Kaidelong> err
07:20:18 <Kaidelong> well okay, not really
07:20:20 <kuribas> quicksilver: It seems to use libcurl to validate documents.
07:20:27 <quicksilver> ah
07:20:27 <Kaidelong> but 1 : [] yields [1]
07:20:33 <Kaidelong> okay, my terminology is wrong
07:20:55 <zygoloid> Kaidelong: maybe you also want a monoid constraint on b?
07:20:59 <Kaidelong> not an identity element, but rather... an idempotence element?
07:21:17 <Kaidelong> zygoloid: I think I could infer it using Monoid and Functor, but I'm worried about efficiency
07:21:20 <copumpkin> hm, nopep
07:21:30 <Kaidelong> then again
07:21:47 <Kaidelong> you have a proper identity element for (++)
07:22:44 <zygoloid> Kaidelong: what other instances do you want this thing to have, other than []? I guess maybe Seq? what about Set?
07:22:49 <Kaidelong> so it might just be an inherent thing about unfold that you can't generalize its return type to be something that doesn't have some notion of cons and still have an O(1) operation building the sequence?... On the other hand...
07:23:18 <Kaidelong> You'd probably define your generic unfold with co-recursion, in which case using the monoidal plus operation would not have any problem?
07:23:19 <zygoloid> Kaidelong: perhaps you just want a generalized 'fromList'?
07:24:25 <Kaidelong> zygoloid: I suppose you could do that, compose unfold with fromList
07:24:39 <Kaidelong> that'd work just fine
07:24:53 <Kaidelong> that's a lot simpler really
07:26:07 <zygoloid> @quote initial
07:26:07 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
07:26:30 * Twey scratches his head.
07:26:31 <Twey> What?
07:26:51 <zygoloid> Twey: no point writing a general unfold, when one which produces a list is already fully general
07:26:57 <Kaidelong> if there is a way to take some data in format X into some general format
07:27:06 <Kaidelong> you don't need to generate data of any format
07:27:10 <Twey> Ah, I see
07:27:12 <Kaidelong> you just need to generate it of format X
07:27:15 <Kaidelong> then convert it
07:27:22 <Twey> Since you basically have to go through a list for an unfold anyway?
07:27:54 <Kaidelong> well in the specific case I was thinking a general unfold would be nice, it is basically a hylomorphism anyway
07:28:11 <Kaidelong> and I think there is an optimization built in to deal with those? I forget
07:28:48 <zygoloid> well, there's a tradition of using RULES to implement these deforestation optimizations (build/fold fusion etc)
07:29:38 <Kaidelong> but if I have some co-recursive algorithm of form output : recursive-call and compose that into a right associative fold, things do get optimized, right?
07:30:39 <benmachine> optimisations might or might not happen
07:30:46 <benmachine> depending on what gets inlined when
07:30:59 <benmachine> also that thing about general/initial I like
07:31:34 <quicksilver> the context, benmachine, was whether lookup should return Maybe, or Monad m => ...
07:31:47 <Kaidelong> hmm, I suppose a generalized unfold might still be something worth the intellectual exercise
07:32:03 * Kaidelong has to leave for now, but thanks zygoloid for the insight
07:32:04 <quicksilver> the argument being you might as well just produce Maybe since that has as much information.
07:32:05 <zygoloid> Kaidelong: if you want to be sure how GHC will optimize something, there's really no substitute for ghc-core
07:32:32 <benmachine> quicksilver: yes, more polymorphic /= more better imo
07:32:59 <quicksilver> not always, certainly.
07:33:19 <benmachine> well sure, more polymorphic and more better have some overlap, but they're not equal :P
07:33:31 <zygoloid> last week i had a realization. i've been striving to write code with general type signatures, and that's a bad thing. the more general the type signature is, the fewer errors will be caught at compile time.
07:34:25 <quicksilver> yup.
07:34:50 <quicksilver> not quite the same, but a similar observation - the more overloading you do, the fewer typos will be caught at compile time.
07:35:11 <quicksilver> (because overloading makes it more likely that a typo finds a strange + different way to type-check)
07:35:19 * benmachine is still upset about forever on the function monad unifying with virtually everything
07:35:42 <benmachine> > forever id const fix mod succ mapM_
07:35:43 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:35:43 <lambdabot>    `GHC.Enum.Enum a'
07:35:43 <lambdabot>      ar...
07:35:57 <benmachine> well, close enough
07:36:06 <quicksilver> :t do {putStrLn >> return 3}
07:36:07 <lambdabot> forall t. (Num t) => String -> t
07:36:07 <zygoloid> @type forever id 1 2 3 "hello" fix
07:36:08 <lambdabot> forall t. t
07:36:30 <quicksilver> ^^ missing argument to putStrLn type checks in unexpected way
07:36:58 <zygoloid> hah!
07:37:24 <zygoloid> presumably resulting later in a "no instance for Num (IO Int)...
07:37:31 <quicksilver> or, if it *doesn't* typecheck, you get a very unexpected error
07:37:36 <benmachine> the IO () is just discarded
07:37:55 <zygoloid> benmachine: sure, but that will likely be /used/ in an IO expression somewhere
07:37:58 <quicksilver> :t do {putStrLn; x<-getLine; return x}
07:37:59 <lambdabot>     Couldn't match expected type `IO String'
07:37:59 <lambdabot>            against inferred type `String -> String'
07:37:59 <lambdabot>     In a stmt of a 'do' expression: x <- getLine
07:38:16 <quicksilver> ^^ I get more complex variants of that quite often
07:38:24 <quicksilver> if you miss off an argument to the first action in a do block
07:38:33 <quicksilver> GHC infers the (->) monad and continues
07:38:51 <benmachine> is there anything better it could do?
07:38:53 <quicksilver> this kind of thing is the justification for that instance not being visible by default.
07:39:11 <quicksilver> benmachine: in principle, I guess, it could typecheck the statements independently and make them 'vote'
07:39:29 <quicksilver> so if most of them were IO actions it would go for that interpretation and give a better error.
07:39:32 <zygoloid> it also sounds like a pretty good justification for adding lots of type annotations :)
07:39:50 <benmachine> heh, types by democracy
07:40:11 <quicksilver> well, I'm not suggesting an actual change the type-checker per se
07:40:17 <quicksilver> this is a badly typed expression, we all agree
07:40:22 <benmachine> yes
07:40:26 <quicksilver> just a change to the approach used in generating the error
07:40:30 <benmachine> mm
07:55:53 <benmachine> Igloo: http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=28365 patch for newtype/record field support in th-lift, or if you tell me an email address or whatever I can do that too
07:56:43 <Igloo> benmachine: Do you want to maintain the package?
07:57:38 <benmachine> Igloo: yeah, if you don't want it anymore
07:57:53 <Igloo> benmachine: Cool, it's yours  :-)
07:58:08 <benmachine> heh, thanks
07:58:15 <benmachine> I don't even have a hackage account yet though
07:58:22 * benmachine starts investigating how to do that
07:58:32 <Igloo> Did I really put a Foo.hs in it? I hope that was a test file, if so
07:58:39 <benmachine> heh, yes
07:58:45 <benmachine> test file
07:58:51 <Igloo> Ah, good
07:59:05 <benmachine> presumably you can't put it all in Test.hs what with stage restrictions &c.
07:59:20 <benmachine> err no
07:59:22 <benmachine> I'm silly
07:59:23 <benmachine> but whatever
08:00:46 <benmachine> oh wait, you're not the maintainer anyway
08:00:48 <benmachine> silly me, sorry
08:00:49 <zygoloid> benmachine: i'm wondering whether version 0.3.1 would be more appropriate than 0.4 wrt the PVP
08:01:05 <benmachine> zygoloid: I added an explicit export list to the module, so it doesn't export doCons anymore
08:01:13 <benmachine> I don't think anyone used that anyway, but still
08:01:35 <zygoloid> ah, so you did :)
08:01:40 <vet> hiya guys
08:01:57 * benmachine wonders who Mathieu Boespflug is
08:01:59 <vet> how can I use haskell to hack the mainframe?
08:02:38 <zygoloid> unsafeCoerce :: PasswordHash -> Password
08:06:32 <EvanR-work> hackMainFrame :: Hostname -> IO ()
08:06:56 <EvanR-work> hackMainFrame host = ???
08:06:58 <EvanR-work> profit
08:09:33 * benmachine wonders how to offer maintainership without sounding like "I WANT TO STEAL YOUR PACKAGE"
08:10:35 <zygoloid> if you don't want to be rude, you could just upload a new version without asking ;-)
08:10:36 <c_wraith> benmachine, just send a feature request
08:10:45 <c_wraith> and then another feature request
08:10:48 <c_wraith> and then another one
08:10:56 <benmachine> :P
08:10:58 <makmanalp> zygoloid: that's ruder :P
08:11:03 <c_wraith> And then volunteer to write code for those features
08:11:04 * BMeph thinks that "I WANT TO STEAL YOUR PACKAGE" is what SHE said...
08:11:11 <makmanalp> c_wraith: i like that
08:11:12 <zygoloid> makmanalp: i was kidding ;)
08:11:16 <makmanalp> i know, heh
08:11:19 <c_wraith> And then volunteer to upload it
08:14:30 <benmachine> well, I wrote a patch and emailed it and said something along the lines of "I can upload it if you like"
08:14:34 * benmachine awaits response
08:16:14 <Ke> I would just state the reasons why I would think the maintainer has lost interest and ask whether that assumption is true
08:17:39 <benmachine> I wish one could use reify from ghci easily
08:25:21 <sm> jaspervdj: oh, thanks for the reminder, I'll let you know today
08:25:26 <sm> morning all
08:27:50 <BMeph> morning sm
08:37:10 <yescalona> hi, why i cant download the yi package with 'cabal install yi'?
08:37:54 <byorgey> yescalona: that's rather vague.  Do you get an error message?
08:39:09 <yescalona> only this byorgey : "yi-0.6.2.4 failed while downloading the package."
08:39:52 <yescalona> i try install multiple times and i dont know what happend
08:40:20 <byorgey> yescalona: one possibility is a permissions error, if you tried installing it previously with sudo
08:40:51 <byorgey> yescalona: go into .cabal/packages I think and look for a yi directory
08:41:12 <copumpkin> preflex: seen TacticalGrace 
08:41:13 <preflex>  TacticalGrace was last seen on #haskell 9 days, 13 hours, 59 minutes and 4 seconds ago, saying: kfish: sounds great!
08:41:39 <byorgey> yescalona: what OS do you have?
08:41:59 <yescalona> archlinux
08:42:31 <byorgey> yescalona: ok. so do you see a yi-0.6.2.4 directory anywhere inside your ~/.cabal directory?
08:43:19 <yescalona> yeah you are right "drwxr-xr-x  3 root      root  4.0K Jul 29 11:29 yi/"
08:43:29 <yescalona> i will remove that
08:43:39 <byorgey> yescalona: cabal gives a terrible error message in this case but I've seen it before
08:43:54 <byorgey> yescalona: yes, just delete that directory and try again
08:44:42 <yescalona> thx byorgey 
08:44:57 <byorgey> sure
08:45:20 <byorgey> yescalona: and you shouldn't ever need to run cabal with sudo, if you want to install something as root you should do  cabal install --root-cmd=sudo ...
08:45:34 <byorgey> it will then take root privileges just for the installation part
08:45:55 <byorgey> and do all the downloading and building etc as normal user
08:48:05 <kuribas> zygoloid: I managed to compile my program by compiling a version of curl without crypto and ldap, and then using that instead of curl.a during linking.
08:48:57 <quicksilver> kuribas++
08:51:16 <kuribas> Strangely, the filesize is about the same...
08:51:37 <kuribas> 9.8M static, versus 8.5 dynamic
08:55:35 * benmachine made the impossible happen, woo
08:55:56 <Phyx-> eh?
08:55:59 <Phyx-> details please
08:56:04 <benmachine> ghc: panic! (the 'impossible' happened)
08:56:20 <benmachine> now begins the painful process of trying to work out how to test this again with an up-to-date GHC
08:56:28 <Phyx-> oh
08:56:34 <Phyx-> that's quite easy to do
08:56:44 <benmachine> fine :P
08:57:11 <benmachine> how do *you* do it
08:57:37 <Phyx-> benmachine: with FFI it's quite common :P
08:57:47 <benmachine> oh, well, I'm getting it with TH
08:57:49 <Phyx-> I've gottan some rather apologetic error messages from GHC
08:57:59 <Phyx-> "I'm sorry, I can't help you with this, I'll quit now"
08:58:02 <benmachine> heh
08:59:27 <zygoloid> i quite like the "my brain exploded" ones, though they're quite easy to create
09:01:49 <Optimo> haz kell?
09:16:30 <burp> haha
09:23:21 <copumpkin> any repa people around?
09:23:37 <Phyx-> does -XCPP invoke a proprocessor first or does it just enable an extension of the ghc parsers/lexers?
09:24:45 <copumpkin> oh all the repa people are probably asleep
09:24:46 <copumpkin> :(
09:25:05 <Phyx-> what's a repa?
09:25:11 <copumpkin> repa is an array library
09:25:14 <Phyx-> sounds like a candy
09:25:15 <copumpkin> regular parallel arrays I think
09:25:18 <copumpkin> or something
09:25:31 <Phyx-> "First rule of repa, never talk about repa"
09:25:34 <copumpkin> I was just trying to figure out why singleton arrays have shape Z, but could also have shape Z :. Int
09:26:09 <Phyx-> no idea sorry :(
09:26:40 <Igloo> Phyx-: It runs cpp first
09:29:58 <Phyx-> Igloo: hmm, ok, thanks
09:30:35 <ClaudiusMaximus> copumpkin: if it's anything like GridFlow, a singleton array could have shape "replicate n 1" for any n >= 0
09:30:55 <copumpkin> :o
09:31:16 <ClaudiusMaximus> copumpkin: but that looks like type-level stuff that i don't totally understand, and i never used repa
09:31:40 <copumpkin> well, it's type-level and value-level
09:32:39 <copumpkin> there are three different concepts as far as I can tell
09:32:46 <ClaudiusMaximus> @check \n -> (product . replicate n) 1 == 1
09:32:46 <lambdabot>   "OK, passed 500 tests."
09:33:02 <copumpkin> a type-level list Z :. Int :. Int to represent the dimensionality, really
09:33:16 <copumpkin> then a value-level list of Z :. 5 :. 6 to represent the shape
09:33:24 <copumpkin> and then the same kind of thing represents indices into that shape
09:33:30 <copumpkin> I'm separating them again
09:33:56 <ClaudiusMaximus> right, makes sense so far
09:34:58 <copumpkin> anyway, just trying to figure out that ambiguous case
09:35:12 <copumpkin> since the way I've set it up, it can't really work
09:35:18 <copumpkin> well, it sort of can
09:36:25 <copumpkin> alright, I guess it can be ambiguous
09:38:00 * hackagebot functor-combo 0.0.4 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.0.4 (ConalElliott)
09:38:11 <copumpkin> as you say, for any string of 1s
09:38:18 <copumpkin> hmm, I wonder how to resolve this cleanly
09:38:39 <copumpkin> it seems ugly to have an array claim to be 10-dimensional, when all of those have an extent of 1
09:42:28 <yescalona> how to remove broken packages with gch
09:42:33 <yescalona> ghc***
09:46:06 <c_wraith> ack.
09:46:08 <c_wraith> internal error: PAP object entered!
09:46:09 <c_wraith>     (GHC version 6.12.3 for x86_64_unknown_linux)
09:46:09 <c_wraith>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
09:46:14 <byorgey> yescalona: ghc-pkg unregister foo
09:46:18 <byorgey> will remove package foo
09:46:20 <c_wraith> That's related to the segfaulting I was having yesterday
09:46:30 <byorgey> ghc-pkg unregister foo-0.3.4  to remove a particular version
09:46:50 <byorgey> you may also need the --user flag to remove locally installed packages
09:46:56 <c_wraith> What the heck is a PAP object?
09:47:13 <copumpkin> it's a kind of closure
09:47:29 <yescalona> mmm but if you have a list of broken package with ghc-pkg check, how to remove all the packages in the list byorgey 
09:48:09 <byorgey> if you mean how to remove all the broken packages but none of the unbroken packages, I don't know.
09:48:10 <copumpkin> I think, anyway :)
09:48:21 <copumpkin> A partial application, closure type PAP, represents a function applied to too few arguments. Partial applications are only built by the generic apply functions in AutoApply.cmm.
09:48:32 <benmachine> ok, loading this module in ghci makes it panic: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28370#a28370
09:48:35 <benmachine> can anyone else verify?
09:48:52 <c_wraith> yikes.  this is low-level stuff.  How did I hit this bug? :(
09:49:14 <benmachine> 'cos it's a bug
09:49:18 <copumpkin> c_wraith: well, you get that kind of thing all the time by doing regular high=level stuff :)
09:49:18 <benmachine> that's what you do with bugs :P
09:49:37 <copumpkin> wow, two ghc bugs in a row in #haskell
09:49:53 <benmachine> heh
09:49:54 <copumpkin> y'all should both talk to #ghc and check the bug list to see if they've already been reported
09:49:57 <copumpkin> :P
09:50:05 <c_wraith> I need to break this down into a smaller test case.
09:50:12 <benmachine> I don't have 6.12.3 (let alone a working HEAD) so I thought I'd ask somewhere convenient first
09:50:13 <copumpkin> http://darcs.haskell.org/ghc/includes/rts/storage/ClosureTypes.h quite a few closure types!
09:50:14 <c_wraith> I've been working on that since yesterday
09:50:27 <Phyx-> well, i have a working head
09:50:40 * copumpkin 's head does not work :(
09:50:42 <benmachine> Phyx-: could you see if it chokes on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28370#a28370 for me please?
09:50:54 <Phyx-> sure, one sec
09:51:02 * benmachine pats copumpkin
09:51:35 * Phyx- gives copumpkin a "safeHead"
09:52:28 <Phyx-> benmachine: just load it up in ghci?
09:52:32 <benmachine> yep
09:53:46 <Phyx-> ghc.exe: panic! (the 'impossible' happened)
09:53:48 <Phyx->   (GHC version 6.13.20100713 for i386-unknown-mingw32):
09:53:48 <Phyx->         rnExpr: unexpected expression
09:53:57 <benmachine> yeah, that's the one, thanks
09:54:04 * hackagebot functor-combo 0.0.5 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.0.5 (ConalElliott)
09:54:08 <Phyx-> np
09:56:30 <Phyx-> hahahah
09:56:35 <c_wraith> well.  tracked down to the ghc optimizer
09:56:38 <c_wraith> blech
09:56:46 <Phyx-> tried my current build of visual haskell on that file
09:56:53 <Phyx-> it gave a nice "BOOOM"
09:57:04 <Phyx-> before crashing :P
09:57:56 <Phyx-> "Would you like to report this error to microsoft?"
09:57:57 <Phyx-> :P
09:58:48 <Nibble> Phyx-: haha, what are they gonna do about it
09:58:54 <Nibble> throw some PR at it
10:00:07 * hackagebot functor-combo 0.0.6 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.0.6 (ConalElliott)
10:00:14 <conal> sorry for the HackageSpam.  that ought to do it for now.
10:00:18 <Phyx-> bleh, my isp sucks
10:00:36 <IceDane> Lisp vs Haskell
10:00:38 <IceDane> Go!
10:00:42 <Phyx-> Nibble: lol, mostlikely "We're sorry to inform you that that is not a Bug in visual studio, good luck!"
10:01:35 <larsrh> what does (\\) do?
10:01:55 <roconnor> @src (\\)
10:01:56 <lambdabot> (\\) = foldl (flip delete)
10:02:03 <jamii> conal said 1y 6m 18d 17h 24m ago: i might change VectorSpace back from associated types to using functional dependencies, to eliminate the numerous explicit equality constraints. any objections?
10:02:08 <jamii> i didnt get that till today
10:02:10 <Phyx-> your "(" and ")" keys live longer
10:02:26 <conal> jamii: wow!
10:02:46 <IceDane> Phyx-: Thank you
10:02:48 <jamii> lambdabot is persistent
10:02:58 <IceDane> Phyx-: I'm convincing a friend to go for haskell rather than lisp
10:03:04 <c_wraith> which is funny, because she tends to forget a lot of stuff
10:03:10 <Phyx-> jamii: lol!
10:03:14 <roconnor> @quote maiden
10:03:14 <lambdabot> Meehl says: [The null hypothesis significance test is] a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring
10:03:39 <conal> Phyx-: scheme is an intermediate choice.  cleaner than lisp.  (i love lisp & scheme & haskell.)
10:03:50 <Phyx-> IceDane: I've never tried Lisp, so I can only troll on the subject
10:04:02 <IceDane> Phyx-: That coincides with my intentions
10:04:11 <roconnor> I thought Lisp was just a buggy version of scheme.
10:04:12 <IceDane> I do not intend to give him meaningful arguments
10:04:15 <Phyx-> c_wraith: she just has selective ignore... like every women does...
10:04:27 <sproingie> lisp is pretty nice.  haskell is different.  learn both.
10:04:41 <conal> yeah, that.
10:04:54 * Phyx- hopes he didn't offend the women in #haskell
10:05:25 <sproingie> the population of which apparently comprises Philippa
10:05:33 <IceDane> Phyx-: Women..? On the internet? 
10:05:40 <IceDane> Did I miss out on some memo?
10:05:43 <c_wraith> sproingie, there's at least one more, sometimes.
10:05:45 * Phyx- thinks he's one of the very few people who likes Clips
10:05:55 <Phyx-> sproingie: isn't wli one too?
10:05:56 <sproingie> clips is pretty neat
10:06:02 <sproingie> i use drools for real-world stuff tho
10:06:10 <Phyx-> IceDane: yup
10:06:29 <Phyx-> yay, I found another one :)
10:06:51 <copumpkin> IceDane: there are quite a few in here actually
10:06:58 <copumpkin> and some get annoyed when people act all surprised ;)
10:07:00 <sproingie> ssh they're hiding
10:07:14 <Phyx-> copumpkin: lol
10:07:20 <IceDane> copumpkin: :|
10:07:20 * Phyx- didn't mean anything by it :/
10:07:21 * IceDane hides
10:07:32 <copumpkin> but if you're lucky none of them noticed!
10:07:39 <IceDane> Let's hope so
10:07:53 <Phyx-> quick, everyone type
10:08:05 <sproingie> probably wider gender parity in the programming community at large than that which hangs out on irc
10:08:09 <Phyx-> to fill their buffers :P
10:08:14 <IceDane> I don't need to be bombarded with nagging in cyperspace too.
10:08:15 <raceRider> I'm testing an app with forkIO and Chan. When I run it with +RTS -N4 it runs fine, but with -N2 I get memory allocation failed error. I have 8 cores in the machine and plenty of memory. Any pointers on where I should start tracing this problem?
10:08:58 <conal> New blog post: "Another angle on zippers" http://conal.net/blog/posts/another-angle-on-zippers/
10:09:04 <sproingie> raceRider: narrow it down to the smallest example that reproduces it i'd say
10:09:27 <sproingie> you'd want to attach that example as a bug
10:12:12 <tensorpudding> ooh zippers
10:13:19 <copumpkin> don't get anything caught in them
10:13:25 <conal> :)
10:13:54 <conal> these posts came out of an ipad programming project, representing infinite continuous images with lazy infinite quad-trees of textures.
10:14:14 <copumpkin> is the ipad project released?
10:14:36 <Phyx-> people use ipads for actual useful stuff?
10:14:43 <copumpkin> I read on mine
10:14:46 <c_wraith> conal:  "There are only navigation functions instead of four"?  I think you a word there. :)
10:15:11 <conal> naw.  not working yet.  the laziness part is okay, but it needs a working LRU for unevaluating.
10:15:18 <conal> c_wraith: thanks!!
10:15:29 <Phyx-> would Apple even every approve anything like that?
10:15:51 * conal appreciates bug reports
10:16:01 <ray> as long as they're not infinite images of steve jobs with a moustache and devil horns drawn on
10:16:27 <copumpkin> conal: what does it do?
10:16:28 <Phyx-> nah, that would be a complement to him
10:16:39 <conal> copumpkin: which part?
10:16:56 <Tarrasch> I have a question about the sum function, when "executing"
10:17:00 <copumpkin> conal: the ipad app
10:17:00 <Tarrasch> sum $ take 1000000 [0, 0..]
10:17:29 <ray> i don't even want to know how infinitely large minecraft worlds are represented, but it's probably not very elegant
10:17:44 <copumpkin> Tarrasch: what's the question? :P
10:17:45 <Tarrasch> I see that the program uses more and more memory, why is that so? Seems natural for the function to throw away the numbers it get 
10:17:56 <opqdonut> Tarrasch: compile with -O2
10:17:57 <copumpkin> Tarrasch: if you compile with optimization it shouldn't
10:18:00 <opqdonut> or use a  strict sum
10:18:04 <copumpkin> Tarrasch: or just use foldl' (+)
10:18:08 <Tarrasch> copumpkin, sorry, I should paste all lines at once next time
10:18:11 <opqdonut> (sum' = foldl' (+) 0)
10:18:24 <Tarrasch> oj
10:18:25 <Tarrasch> oh*
10:18:49 <Tarrasch> is it to define sum' without using foldl (for my educational purposes? :))
10:18:51 <opqdonut> you see, the program does the + operations only when the result is forced
10:18:56 <Tarrasch> is it possible*
10:18:57 <conal> copumpkin: it's an experiment.  i have some haskell-based tech for generating shaders, and some objc-based tech for iphone/ipad programming. but still no clear sense of direction/goals/use for them.
10:19:01 <opqdonut> Tarrasch: sure
10:19:08 <copumpkin> conal: ah, cool
10:19:31 <opqdonut> but when optimizations are on, the compiler deduces that this is unnecessary, and the + operations can be done while we process through the list
10:19:32 <roconnor> conal: nice post.  Is extract :: f a  f (Loc f a) new?
10:19:45 <opqdonut> @src foldl'
10:19:46 <lambdabot> foldl' f a []     = a
10:19:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:19:51 <opqdonut> there's the source of foldl'
10:19:51 <conal> roconnor: i guess so.  i hadn't seen it before.
10:19:53 <roconnor> conal: it is kinda obvious, but then again, I don't know if I've seen it before or not.
10:19:56 <conal> roconnor: thx :)
10:19:57 <opqdonut> it uses seq to force evaluation
10:20:03 <conal> roconnor: yeah!
10:21:39 <Tarrasch> hmm, should seq be considered a "magical" function or can it be defined in some natural way?
10:21:47 <opqdonut> magical
10:21:48 <copumpkin> it's magical
10:21:55 <tensorpudding> it's magical, since it changes the way evalution is done
10:21:58 <Tarrasch> ok, thanks :)
10:22:01 <copumpkin> it could be defined for most types if you had a typeclass associated with it
10:22:13 <roconnor> I only have used seq on primitive like integers where it is the same as case
10:22:13 <c_wraith> seq is essentially "pattern match the constructor in this expression, regardless of what it is".  That's magical.
10:22:47 <conal> the ipad posed a challenge, as its gpu is only as fast as the iphone 3gs (i think) but has to drive a lot more pixels.  so infinite quad-trees is an idea for reusing rendering effort.  an idea i've been noodling over for years, and now had some concrete motivation.
10:23:13 <DevHC> > "hi"
10:23:15 <lambdabot>   "hi"
10:23:21 <Tarrasch> >seq undefined 123
10:23:26 <Tarrasch> ops
10:23:43 <Tarrasch> > "say something"
10:23:43 <lambdabot>   "say something"
10:23:46 <Tarrasch> phew
10:23:50 <Phyx-> conal: my biggest problem with the ipad is how closed it is, which is why i don't buy *any* apple products
10:23:50 <DevHC> hey can someone tell me what's up with the last accepted character code being 1114111?
10:23:53 <roconnor> > text "hi"
10:23:54 <lambdabot>   hi
10:23:57 <DevHC> > '\1114111'
10:23:58 <lambdabot>   '\1114111'
10:24:01 <DevHC> > '\1114112'
10:24:02 <lambdabot>   <no location info>:
10:24:02 <lambdabot>      lexical error in string/character literal at chara...
10:24:10 <DevHC> and what's with the obscure error message?
10:24:22 <Phyx-> it's not obscure
10:24:26 <DevHC> orly
10:24:29 <copumpkin> DevHC: you can't ask for a character that doesn't exist
10:24:33 <DevHC> lexical error?
10:24:37 <conal> Phyx-: yeah.  the closed aspect sucks big time.  i want to learn android soon.  and maybe dump apple.
10:24:42 <copumpkin> DevHC: unicode specifies that the highest codepoint is 10ffff
10:24:47 <Phyx-> maxBounds :: Char
10:24:49 <DevHC> :o
10:24:52 <Phyx-> > maxBound :: Char
10:24:53 <lambdabot>   '\1114111'
10:25:03 <copumpkin> > 0x10ffff
10:25:04 <lambdabot>   1114111
10:25:04 <roconnor> the error is in the lexer
10:25:18 <roconnor> > 0xEFGH
10:25:19 <lambdabot>   Not in scope: data constructor `GH'
10:25:25 * roconnor sighs
10:25:29 <Tarrasch> > 0xDEAD
10:25:30 <lambdabot>   57005
10:25:31 <ClaudiusMaximus> hmm, infinite continuous images that are interesting all the way down pretty much limits you to synthetic fractals afaict, unless you can hook into some large mapping database (whether geographical or anatomical, etc)
10:25:35 <Phyx-> conal: yeah, android seems the way to go if you're interested in exprimentation
10:25:36 <DevHC> so how about making the error message a bit like "overly high unicode character value"?
10:26:10 <copumpkin> DevHC: I guess they could put a case in that says that
10:26:34 <copumpkin> DevHC: it's not just that though... you'll get the same thing if you put in other sorts of malformed literals
10:26:49 <Tarrasch> btw. the book, The Haskell School of Expression educated how to draw stream diagrams, is that common practice for haskell developers? I barely find anything when googling for Stream diagrams
10:26:51 <conal> And not only is the apple closed, but support in haskell-land is awfully rough, especially for anything with graphics & guis.  i miss linux.
10:27:17 <conal> Tarrasch: "stream diagrams"??
10:27:21 <DevHC> canhaz examples of more malformed escapes?
10:27:35 <benmachine> DevHC: roconnor's example?
10:27:44 <benmachine> > 0xfg
10:27:45 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:27:45 <lambdabot>    `SimpleReflect.FromExpr a...
10:27:50 <Tarrasch> conal, stream = infinite list. you draw diagram of how a function works
10:27:51 <benmachine> heh
10:27:52 <DevHC> lol
10:27:59 <benmachine> > 0xcabbage
10:28:00 <lambdabot>   Not in scope: `ge'
10:28:19 <conal> Tarrasch: ah.  where do you see stream diagrams in SoE?
10:28:20 <DevHC> > '\1234567'
10:28:21 <lambdabot>   <no location info>:
10:28:22 <lambdabot>      lexical error in string/character literal at chara...
10:28:29 <Tarrasch> conal, the chapter about Streams :p
10:28:35 <ClaudiusMaximus> that reminds me, i need to add a flag to turn off -march=native etc in mandulia because some OS X versions of gcc have bugs with it
10:28:35 <benmachine> > length "\1234567"
10:28:36 <lambdabot>   <no location info>:
10:28:36 <lambdabot>      lexical error in string/character literal at chara...
10:29:03 <benmachine> > length "\xcabbage"
10:29:03 <lambdabot>   3
10:29:06 <Tarrasch> conal, it draws a stream diagram to clearly illustrate how his fib-function works
10:29:31 <Tarrasch> > let fibs = 1: 1: zipWith (+) (fibs) (tail fibs) in fibs
10:29:32 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:29:35 <conal> Tarrasch: ah, thx.
10:29:45 <Tarrasch> he draws*
10:32:36 <ClaudiusMaximus> mini-poll: what should i call a .cabal flag to control extra ghc/gcc options that are recommended to make it go faster but that cause trouble on some systems? i'm thinking -ffast with default: true, but if someone has some better ideas?
10:33:02 <opqdonut> -march=imperial
10:33:05 <opqdonut> sorry...
10:33:06 <sproingie> i'd say the default build should emphasize stability
10:33:26 <sproingie> if someone needs it faster they can rebuild
10:35:38 <jmcarthur> Tarrasch: stream diagrams aren't really common. i don't even know what you mean by it :)
10:36:13 <Tarrasch> jmcarthur, hmm, have you heard of "Incremental Sampling" ?
10:36:33 <ClaudiusMaximus> sproingie: hmm, this is just a toy executable, not a mission-critical library, but i see your point
10:36:56 <Tarrasch> or is that only Paul Hudak's own ideas? I however really appreciated to learn drawing stream diagrams, been helpful.
10:38:02 <sproingie> ClaudiusMaximus: would be nice if cabal files had some configurability of their own, like ifdefs or something more sophisticated
10:38:06 <ClaudiusMaximus> Tarrasch: are they anything like data structure diagrams? http://graphviz.org/Gallery/directed/datastruct.html
10:38:28 <Tarrasch> ClaudiusMaximus, nope
10:38:29 <ClaudiusMaximus> sproingie: well, .cabal flags are like ifdef
10:38:30 <sproingie> 'course i'll probably find out they do have it and i just don't know about it
10:39:06 <mathijsje> good evening
10:39:59 <ClaudiusMaximus> my current cabal file is here, if anyone wants to suggest any other improvements: http://hackage.haskell.org/packages/archive/mandulia/0.6/mandulia.cabal
10:40:02 <mathijsje> can somebody tell me if its possible to do something like "(Num a) =>" as in "somefunc :: (Num a) ? a ?  a" for "data" definitions?
10:40:22 <ClaudiusMaximus> mathijsje: you can, but you don't want to generally
10:40:41 <Phyx-> I have a question of .cabal files. I have a small test file http://phyx.pastebin.com/2pB0RtNR with a file Test.hsc, but the preprocessor is never ran on it
10:40:51 <mathijsje> ClaudiusMaximus? how?
10:40:56 <mathijsje> im confused, im trying to write a raytracer
10:41:24 <Tarrasch> data (Num a) => NumId a = NumId a
10:41:25 <Tarrasch> like that?
10:41:41 <interferon> @info IO
10:41:41 <lambdabot> IO
10:41:55 <Phyx-> anyone?
10:41:59 <ClaudiusMaximus> Phyx-: 1. i'm not sure if wildcards work, 2. you might have to specify Other-Modules for the executable
10:42:09 <interferon> @eval getLine = getLine
10:42:21 <mathijsje> like that Tarrasch :)
10:42:25 <interferon> @eval getLine == getLine
10:42:40 <sm> woo! it's new haskell web framework day
10:42:45 <interferon> Does IO have an Eq instance?
10:42:53 <Tarrasch> mathijsje, unfortunately, I've know idea how to do that ... Though I've always asked myself that same question ...
10:42:59 <Tarrasch> no idea*
10:43:04 <interferon> Sm: where?
10:43:06 <ClaudiusMaximus> > (undefined :: IO ()) == undefined
10:43:06 <zygoloid> interferon: how could it?
10:43:07 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.IOBase.IO ()))
10:43:07 <lambdabot>    arising from a use o...
10:43:16 <Zao> interferon: Sounds rather hard to implement.
10:43:20 <sm> http://www.reddit.com/r/haskell/comments/cuoyq/haskell_on_a_horse_a_web_framework_with_arrows/
10:43:42 <interferon> zygoloid: Zao: two actions could be identical
10:43:47 <mathijsje> But why wouldnt I want to use that ClaudiusMaximus? I
10:43:52 <zygoloid> interferon: equality on IO () is not even computable.
10:44:04 <ClaudiusMaximus> mathijsje: because it limits what you can do to the data
10:44:16 <Zao> interferon: How could you tell?
10:44:28 <Zao> interferon: In a generic and unambigious way.
10:44:31 <mathijsje> but thats just what i want i think, I want it to be like "virtual" in c++/java
10:44:41 <ClaudiusMaximus> mathijsje: it's better to lift the constraint to the functions that use the data
10:44:48 <ClaudiusMaximus> mathijsje: like for example Data.Set
10:45:00 <sproingie> java has no "virtual" of course :)
10:45:03 <interferon> Two actions can be identical, right?
10:45:08 <Phyx-> ClaudiusMaximus: ok, let me try
10:45:09 <Zao> interferon: Define "identical".
10:45:34 <zygoloid> interferon: if it were possible, then this: (==) `on` (\f -> do x <- getLine; print (f x))  would solve the halting problem.
10:46:07 <Zao> let x = return "lol" >> return (), y = return () in x == y
10:46:15 <Zao> Are x and y equivalent?
10:46:43 <zygoloid> interferon: (basically, you can use (==) on IO () to create an (==) on /any/ type, and that's not computable)
10:46:49 <Tarrasch> ClaudiusMaximus, but isn't that a way of repeating code (=? evil), if you have to put that contraints for each function rather than just once in the data declaration?
10:47:01 <Phyx-> ClaudiusMaximus: does Other-Modules exist for Executables? It's giving me  parse error
10:47:27 <ClaudiusMaximus> mathijsje: in a ray-tracer i'd just use data Thing = Thing{ intersectionTest :: Ray -> Intersection, ... }
10:47:43 <ClaudiusMaximus> Phyx-: the name should be the module name, without .hs
10:48:07 <zygoloid> Tarrasch: contexts on data types don't do what you think they do.
10:48:19 <zygoloid> Tarrasch: even with the context on the data declaration, you'd still need it for each function.
10:48:25 <Phyx-> ClaudiusMaximus: ok, added it, still didn't do anything
10:48:25 <ClaudiusMaximus> mathijsje: and have for example:  sphere :: Point -> Size -> Thing
10:48:50 <Phyx-> ClaudiusMaximus: seems the proprocessor are run as part of the build phase not configure
10:49:12 <ClaudiusMaximus> Phyx-: that makes sense, right?
10:49:39 <Phyx-> ClaudiusMaximus: I suppose :)
10:50:19 <ClaudiusMaximus> you could probably customize Setup.hs to do it earlier
10:50:34 <ClaudiusMaximus> but i doubt it's desirable
10:50:52 <Phyx-> oh, and I just found out what the documentation means with "Paths" module
10:50:59 <Phyx-> ClaudiusMaximus: nah, i'm calling the Cabal api
10:51:15 <Phyx-> even though i'm calling preprocessSources nothing is happening
10:52:06 <ClaudiusMaximus> perhaps "preprocess" there is to do with cabal finding out which sources to work with, and nothing to do with running external preprocessors....
10:52:17 <ClaudiusMaximus> ^^ guess
10:52:22 <mathijsje> ClaudiusMaximus, this is the type/data I have : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28372#a28372
10:52:28 <mathijsje> does it look okay
10:52:58 <mathijsje> or is it very strange? :')
10:53:33 <ClaudiusMaximus> well, "Shader a" is a type but you're using it as a class
10:55:04 <mathijsje> mmm, so shader should be like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28374#a28374  as well?
10:56:56 <ClaudiusMaximus> hm, i think type classes are the wrong way to go about this, because you'll eventually have to use existentials to get a heterogenous list
10:58:04 <ClaudiusMaximus> so the simple way would be to have "data Thing = Sphere Point Size | Triangle Point Point Point | ..." and use pattern matching
10:58:23 <mathijsje> what would be a better design? I liked the idea of being able to define a new 'instance' and add a shape (box, sphere, whatever) like that?
10:58:24 <mathijsje> mmm
10:58:39 <sm> haskell for android advocate opportunity: http://www.tbray.org/ongoing/When/201x/2010/07/28/Ruby-and-Python-on-Android
10:58:54 <ClaudiusMaximus> and another slightly less simple way would be to have data Thing = Thing{ operations on that thing :: Foo -> Bar }
11:00:20 <solidsnack> So why would an Attoparsec get stuck in such a way that an empty string frees it up?
11:00:43 <ClaudiusMaximus> the first ADT-way would require recompiling everything each time and fragments eg the sphere code across many different functions that also deal with triangles; the second record-of-functions way would be easier to extend keeping all the code for each thing in one place
11:01:10 <solidsnack> result `feed` ""  =  some useful output
11:01:10 <zygoloid> solidsnack: i guess you're looking for a more detailed answer than "because of a bug"?
11:01:43 <ClaudiusMaximus> the type-class way would appear to offer the advantages of the second way, but is less desirable because with record-of-functions you can have a collection like [Thing]
11:01:46 <solidsnack> zygoloid: Well, I'm wondering if anyone has seen this before. Maybe it's a bug in Attoparsec of maybe I'm doing something wrong.
11:02:15 <lispy> solidsnack: it's not an attoparsec bug
11:02:21 <solidsnack> lispy: Okay.
11:02:32 <lispy> solidsnack: I emailed bos about it once and he gave me a good reply.  I'm happy to forward it to you if you /msg me with your email address
11:02:43 <mathijsje> aha I see, I like the second idea
11:02:48 <ClaudiusMaximus> and with type classes you need to jump through existential hoops, because Thing a => [a]  means a list of things each with the same concrete type, and not a list of things of different types that implement Thing
11:02:56 <solidsnack> lispy: Cool, thank you.
11:03:14 <mathijsje> " operations on that thing :: Foo -> Bar " is a function, right?
11:03:40 <mathijsje> so i'd pass a function to the data constructor?
11:04:13 <ClaudiusMaximus> mathijsje: yes, so you could have:    sphere :: Point -> Size -> Thing ; sphere center radius = Thing{ intersect = \ray -> ..maths.. ; ... }
11:04:26 <Phyx-> hmmm It seems I just produced an endlessly printing cabal file
11:04:27 <Phyx-> sweet
11:04:39 <mathijsje> I havent tried to put different Things in one list yet, but then I'd probably have run in to the problem you described ClaudiusMaximus :)
11:04:44 <lispy> solidsnack: essentially, you do need to follow that idiom of (parse ...) `feed` B.empty
11:04:58 <lispy> solidsnack: otherwise, many parsers just don't realize they are done
11:05:36 <Phyx-> OH, NO, print was just waaaay slow
11:05:55 <ClaudiusMaximus> :t sort
11:05:56 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:06:00 <boegel> shapr: ping!
11:06:07 <ClaudiusMaximus> @instances Ord
11:06:07 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:06:24 <ClaudiusMaximus> > sort [ (1,2), (3,4,5) ]
11:06:25 <lambdabot>   Couldn't match expected type `(t, t1)'
11:06:25 <lambdabot>         against inferred type `(t2, ...
11:06:26 <solidsnack> lispy: There is something weird about that.
11:06:39 <lispy> solidsnack: read the email :)
11:06:45 <solidsnack> I did.
11:06:54 <lispy> once I read bos's reply I felt like it was pretty reasonablo
11:06:56 <lispy> reasonable8
11:07:37 <lispy> and my experience with attoparsec is that feeding empty when you're done works swimmingly
11:08:16 <mathijsje> ah
11:08:44 <Phyx-> @hoogle trace --info
11:08:44 <lambdabot> Debug.Trace trace :: String -> a -> a
11:08:44 <lambdabot>  
11:08:44 <lambdabot> When called, trace outputs the string in its first argument, before returning the second argument as its result. The trace function is not referentially transparent, and should only be used for
11:08:44 <lambdabot> debugging, or for monitoring execution. Some implementations of trace may decorate the string that's output to indicate that you're tracing. The function is implemented on top of putTraceMsg.
11:09:14 <mathijsje> I like the design you described ClaudiusMaximus, i'm going to try it. ty for your help.
11:09:17 <solidsnack> What is weird about it is that it seems like there is some dependence on how the input is chunked.
11:09:22 <ClaudiusMaximus> mathijsje: :) good luck
11:09:48 <solidsnack> I mean,   append bytes ""  is the identity.
11:10:50 <c_wraith> ok...  Q) when does ("" == "") not mean the same thing as true?  A) internal GHC error!
11:10:58 <c_wraith> err, True
11:11:44 <Tarrasch> > "" == ""
11:11:45 <lambdabot>   True
11:12:29 <Tarrasch> instance Show Bool where show True = "False"
11:12:45 <c_wraith> All I know is that my test case crashes with an internal GHC error when I use ("" == ""), but not when I use True
11:12:46 <Tarrasch> Is that possible to do for lamdabot?
11:13:05 <c_wraith> That one's not possible without NoImplicitPrelude, as far as I know.
11:13:06 <ClaudiusMaximus> c_wraith: -XOverloadedStrings ?
11:13:14 <c_wraith> ClaudiusMaximus, I don't have it on.
11:13:27 * hackagebot omnicodec 0.4.0 - data encoding and decoding command line utilities  http://hackage.haskell.org/package/omnicodec-0.4.0 (MagnusTherning)
11:14:05 <solidsnack> lispy: I guess what bugs me about it, ultimately, is that it indicates I don't understand how the stuff works and that's disconcerting.
11:15:03 <ekolivre> > 1 == 1
11:15:04 <lambdabot>   True
11:15:16 <ekolivre> (just showing to my friend)
11:15:38 <Tarrasch> c_wraith, do you somehow use inner reduction or something?
11:16:05 <Tarrasch> http://en.wikibooks.org/wiki/Haskell/Graph_reduction , ur case reminds of what I read here today, under the headline "Pattern Matching"
11:18:02 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28375#a28375
11:18:17 <c_wraith> It needs to be compiled with optimizations to fail, which cabal does by default
11:20:00 <mathijsje> ClaudiusMaximus, you suggest making the lambda's used to construct a Thing call other functions?
11:20:18 <mathijsje> I can't have where blocks in lambda's right?
11:20:32 <ezyang> If I make a type signature more general, does that merit a y-bump or a z-bump in x.y.z versioning? 
11:21:10 <c_wraith> ezyang: does the pvp not cover that case explicitly?
11:21:18 <ezyang> Looking. 
11:21:59 <Phyx-> ClaudiusMaximus: I know why it's not working
11:22:05 <Tarrasch> mathijsje, you can always use let/in, no?
11:22:06 <Phyx-> I just don't know how to fix it
11:22:26 <ezyang> "or the types of any entities or the definitions of datatypes or classes were changed" 
11:22:29 <Phyx-> ClaudiusMaximus: when you parse, you get a GenericPackageDescription
11:22:31 <ezyang> so I guess that includes generalizing types 
11:22:52 <Phyx-> but preprocessSources wants a PackageDescription, which doesn't contain any information on the libs or exes
11:23:04 <Phyx-> so it's not doing anything because it doesn't find anything to do :/
11:23:09 <Phyx-> maybe i'm calling it wrong
11:23:13 <Phyx-> dcoutts: might you be here?
11:24:44 <ClaudiusMaximus> mathijsje: you can do something like:    sphere ... = Thing{ foo = \f -> ... ; bar = \b -> ... } where ...
11:25:45 <ClaudiusMaximus> Phyx-: aha - i can't help you, sorry
11:25:50 <ezyang> Hmm. Adding and subtracting instances doesn't necessarily seem obvious from just adding/deleting imports. Tool support for that would be nice. 
11:26:17 <mathijsje> Tarrasch, let does the job indeed, ty :)
11:27:20 <mathijsje> ClaudiusMaximus, looks nice, ill try to move some of my computations to the 'where', when I copy & paste my old code into a lambda it looks ugly, too many tabs
11:28:22 <ClaudiusMaximus> mathijsje: you don't have to use a lambda, you can name the functions on the top level
11:28:56 <Tarrasch> or in the where-clause of the function, if you don't want to pollute your namespace
11:29:03 <alex_kidd> what does a double exclamation mark mean (in map fib [0 ..] !!) ?
11:29:04 <ClaudiusMaximus> mathijsje: so    sphereFoo ... = ...    sphere ... = Thing{ foo = sphereFoo ; ... }
11:29:12 <ClaudiusMaximus> @src (!!)
11:29:12 <lambdabot> xs     !! n | n < 0 = undefined
11:29:12 <lambdabot> []     !! _         = undefined
11:29:12 <lambdabot> (x:_)  !! 0         = x
11:29:12 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:29:47 <Tarrasch> alex_kidd, mylist !! n is like the imperative langauges, myarray[n], but it's slow :)
11:29:49 <Phyx-> is there a specific cabal mailing list?
11:29:53 <mathijsje> ClaudiusMaximus, Tarrasch, ty, that'll make it look nice :)
11:30:09 <Tarrasch> alex_kidd, that's a simplified picture, if that helps...
11:30:33 <alex_kidd> Tarrasch: yeah it does help, thanks
11:30:54 <ClaudiusMaximus> if you don't want to "pollute" the namespace, use something like   module Sphere (sphere) where ...    , ie, don't export things you don't need public
11:31:05 <tommd> I'd avoid comparing it to an array operation, that's just too misleading and too many people already think "array" when they see a list.  This leads to meaningless benchmarks where people compare Haskell lists to a Language X arrays.
11:31:08 <Saizan> Phyx-: there's cabal-devel@
11:31:37 <Phyx-> Saizan: thank you :)
11:31:51 <alex_kidd> i'm trying to memoize but i need to lookup with two indices
11:33:55 <Tarrasch> tommd, but since it's such a fundemental function (!!), I think such students need to be taught simple things they already can relate to, certainly you didn't want to hear about monads when writing your first IO-function?
11:34:41 <Kaidelong> I think it's important to learn about algebraic structures personally
11:34:43 <roconnor> !! is mostly only used by beginners
11:34:54 <tommd> Tarrasch: In real code I find very few (perhaps zero) users of (!!).  If you use (!!) very much at all then I think you're using the wrong data structure for the job.
11:35:04 <jmcarthur> i use !! to get the result of iterating n times
11:35:47 <copumpkin> you'd want to use a forcing !!
11:35:53 <copumpkin> or you might build up a massive thunk
11:35:59 <Kaidelong> I'd rather learn about Monads earlier than later, although perhaps about Monoids and Functors first since they're a bit easier to grasp
11:36:04 <jmcarthur> copumpkin: this is usually for a lazy operation
11:36:16 <copumpkin> ah
11:36:43 <jmcarthur> oh wait a sec
11:36:44 <Tarrasch> Kaidelong, I agree with that, I've wasted my time learning monads when I should've been focusing on functors etc.
11:36:57 <zygoloid> @type \n f -> execState $ replicateM_ n (modify f)
11:36:57 <lambdabot> forall s. Int -> (s -> s) -> s -> s
11:37:29 <Tarrasch> tommd, so what? Has that anything to do with the educational value of comparing lists with arrays for first-time-users?
11:37:33 * hackagebot webkit 0.11.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.11.1 (AndyStewart)
11:37:49 <Kaidelong> also Lists are nice because they're all those things
11:37:53 <stelleg> anyone here use Yi?
11:38:16 <Kaidelong> for learning about the structures, I mean
11:38:18 <jmcarthur> yeah, i've only ever done it for lazy things
11:38:31 <jmcarthur> but then maybe it's still not a good idea
11:38:35 <jmcarthur> @src iterate
11:38:35 <lambdabot> iterate f x =  x : iterate f (f x)
11:38:56 <roconnor> zygoloid: are you the one who uses 1-liner MTL statements?
11:38:58 <tommd> Tarrasch: People often keep what they learn early in a process, so I would not compare lists with arrays.  Compare arrays with arrays and lists with lists.
11:39:01 <jmcarthur> yeah, that looks bad
11:39:25 <jmcarthur> copumpkin: well, there goes that idiom except for small values of n :(
11:39:32 <copumpkin> :)
11:39:36 <zygoloid> roconnor: am i alone? ;-)
11:40:07 <copumpkin> you're not alone
11:40:07 <copumpkin> by olive
11:40:10 <copumpkin> also, ATB
11:40:26 <Tarrasch> tommd, hmm, maybe that's the case, and then you're right. But I doubt that you "keep what you learn", ask any 50-year-old engineer, they've forgotten everything ;)
11:40:34 * hackagebot gconf 0.11.1 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.11.1 (AndyStewart)
11:40:52 * zygoloid doesn't like  iterate f x !! n  as an idiom
11:40:58 * zygoloid wants (!!) removed from the Prelude ;-)
11:41:02 <tommd> yay
11:41:29 <micahjohnston> @pl \x -> x
11:41:29 <lambdabot> id
11:41:36 <tensorpudding> the Prelude doesn't take all of Data.List does it?
11:41:39 <micahjohnston> @pl \x -> \y -> y x
11:41:40 <lambdabot> flip id
11:42:34 * hackagebot glade 0.11.1 - Binding to the glade library.  http://hackage.haskell.org/package/glade-0.11.1 (AndyStewart)
11:42:47 <Kaidelong> would iterate f x !! n build up a thunk on a head strict list?
11:42:49 <Tarrasch> there are obviously lots of cases where !! can be used without altering the performence complexity of the program, so do you think its all bad?
11:43:22 <Kaidelong> since (f x) keeps having to be evaluated
11:43:35 * hackagebot gstreamer 0.11.1 - Binding to the GStreamer open source multimedia framework.  http://hackage.haskell.org/package/gstreamer-0.11.1 (AndyStewart)
11:43:35 <zachk> !! has the nice problem of possible errors too 
11:44:20 * BMeph decides to jump on the torches-and-pitchforks bandwagon...
11:44:30 <Kaidelong> zachk: iterate won't ever generate a finite list, although there is still the issue that it takes an integer and not a natural
11:44:35 * hackagebot gtkglext 0.11.1 - Binding to the GTK+ OpenGL Extension  http://hackage.haskell.org/package/gtkglext-0.11.1 (AndyStewart)
11:44:52 <Tarrasch> Kaidelong, actually I think it's Int, no?
11:44:56 <BMeph> (!!) has the wrong type for its second argument. Death to (!!)!
11:44:56 <Tarrasch> :i (!!)
11:45:03 <copumpkin> yeah
11:45:06 <Kaidelong> That's even worse
11:45:06 <copumpkin> it should be Fin n
11:45:11 <jmcarthur> @let iterate' f x = x : (let x' = f x in x' `seq` iterate' f x')  -- copumpkin: for strict operations :)
11:45:12 <lambdabot>  Defined.
11:45:47 <Kaidelong> let iterate' f !x = x : iterate' f (f x)
11:45:51 <Kaidelong> that'd work too, won't it?
11:46:02 <copumpkin> try it
11:46:02 <jmcarthur> if you want to use bang patterns
11:46:03 <Kaidelong> assuming bang patterns
11:46:10 <monochrom> it will work
11:46:23 <copumpkin> > let iterate' f !x = x : iterate' f (f x) in iterate' succ 0 !! 10000000
11:46:25 <lambdabot>   <no location info>: Parse error in pattern
11:46:25 <jmcarthur> it's slightly different from mine, but maybe better anyway
11:46:29 <monochrom> and yes, you can also define your own head-strict list
11:46:32 <copumpkin> ugh
11:46:35 * hackagebot gtksourceview2 0.11.1 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.11.1 (AndyStewart)
11:46:52 <copumpkin> > iterate' succ 0 !! 10000000
11:46:56 <lambdabot>   mueval-core: Time limit exceeded
11:46:59 <copumpkin> > iterate' succ 0 !! 1000000
11:47:01 <lambdabot>   1000000
11:47:06 <zygoloid> Kaidelong: they're not quite equivalent.
11:47:11 <monochrom> > let iterate' f x = seq x (x : iterate' f (f x)) in iterate' succ 0 !! 100000
11:47:12 <lambdabot>   100000
11:47:21 <monochrom> > let iterate' f x = seq x (x : iterate' f (f x)) in iterate' succ 0 !! 1000000
11:47:22 <lambdabot>   1000000
11:47:26 <zygoloid> > iterate' (const 0) undefined !! 1
11:47:27 <lambdabot>   0
11:47:30 <Kaidelong> that's interesting, what does the bang pattern do differently?
11:47:36 <jmcarthur> Kaidelong: the difference is that yours would evaluate the head when you pattern match the cons
11:48:22 <jmcarthur> Kaidelong: but mine would evaluate the head of the tail if you pattern match the tail anyway, so my way is just extra stuff to write in the spec ;)
11:48:29 <zygoloid> > let iterate' f x = x `seq` x : iterate' f (f x) in iterate' (const 0) undefined !! 1
11:48:30 <lambdabot>   *Exception: Prelude.undefined
11:48:36 * hackagebot soegtk 0.11.1 - GUI functions as used in the book "The Haskell School of Expression".  http://hackage.haskell.org/package/soegtk-0.11.1 (AndyStewart)
11:49:33 <jmcarthur> > (\(_:_) -> "foo") $ iterate' undefined undefined
11:49:34 <lambdabot>   "foo"
11:49:41 <jmcarthur> > (\(_:_:_) -> "foo") $ iterate' undefined undefined
11:49:42 <lambdabot>   "*Exception: Prelude.undefined
11:49:50 <jmcarthur> kind of a dumb definition cnsidering that
11:49:54 <jmcarthur> *considering
11:50:05 <jmcarthur> should have floated the seq to the top
11:50:34 <Kaidelong> > let iterate' f x = y `seq` x : iterate' f y in iterate' (const 0) undefined !! 1 where y = (f x)
11:50:35 <lambdabot>   <no location info>: parse error on input `where'
11:50:36 * hackagebot svgcairo 0.11.1 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.11.1 (AndyStewart)
11:50:38 * hackagebot vte 0.11.1 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.11.1 (AndyStewart)
11:50:43 <monochrom> @vixen seq me!
11:50:44 <lambdabot> what are you
11:50:48 <monochrom> @vixen bang me!
11:50:48 <lambdabot> have you ever scubadived?
11:51:12 <Kaidelong> oh right of course
11:51:14 <Kaidelong> bah
11:52:03 <zachk> @vixen how fast can you type? 
11:52:03 <lambdabot> i sure can
11:52:06 <Kaidelong> > let iterate' f x = let y = (f x) in y `seq` x : iterate' f y in iterate' (const 0) undefined !! 2
11:52:06 <lambdabot>   0
11:52:15 <Kaidelong> > let iterate' f x = let y = (f x) in y `seq` x : iterate' f y in iterate' (const 0) undefined !! 100000000
11:52:19 <lambdabot>   mueval-core: Time limit exceeded
11:52:32 <jmcarthur> i would prefer a generalized iterate function and different list typesfor different strictness
11:52:39 <jmcarthur> *types for
11:52:42 <jmcarthur> but that's just me
11:52:59 <Kaidelong> that strikes me as the best solution
11:53:03 <jmcarthur> and of course i would prefer for iterate to take naturals instead of ints
11:53:23 <Kaidelong> if only list functions used some kind of general iterator type class rather than working on actual lists
11:53:31 <jmcarthur> i usually prefer new types instead of annotations for strictness
11:53:36 <Kaidelong> (F# does that actually)
11:53:37 <ClaudiusMaximus> :t genericIndex
11:53:38 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
11:53:45 <Kaidelong> (F# seq is also head strict, I think)
11:54:18 <BMeph> jmcarthur: So, if it were keeping with the times, you'd like Clean? 
11:54:29 <jmcarthur> BMeph: does clean favor that?
11:54:32 <jmcarthur> i don't even know
11:56:26 <BMeph> jmcarthur: Yes, Clean has a specific type signature for "regular" lists, head-strict lists, tail-strict (spine-strict?) lists, even one for any general list.
11:57:31 <jmcarthur> BMeph: i would like the idea even more if strictness could usefully be a type parameter
11:57:44 <jmcarthur> but i don't know how to formalize something flexible like that off the top of my head
11:57:51 <jmcarthur> *flexible enough
11:58:13 <monochrom> "general iterator type class" is Traversable
11:58:15 <jmcarthur> i think tail strict would be spine strict, yes
11:58:30 <jmcarthur> monochrom: you can define iterate in terms of Traversable?
11:58:34 <Kaidelong> monochrom: yes but then you have to override stuff from the prelude
11:58:44 <jmcarthur> i don't care about the prelude
11:58:58 <Kaidelong> The prelude looks to me like a serious wart, as least as far as lists are concerned
11:59:28 <zachk> but i can still rember learning haskell, and even understanding the prelude was like whoa 
11:59:44 <wli> It'd be nice if there were a "wart cleanup pass" somewhere in the pipeline.
12:00:05 <monochrom> each data type will have to define its own "iterate", and even then there are several different "iterate"s for the same data type.
12:00:23 <BMeph> IMO, the Prelude, and Int-default functions are symptoms of Haskell's failure to avoid success...if that makes sense. :)
12:00:38 <Kaidelong> monochrom: so default to one and provide functions that give other traversals
12:00:53 <jmcarthur> BMeph: yeah :(
12:01:20 <copumpkin> BMeph: yesh!
12:01:35 <jmcarthur> i don't see how you could define iterate in terms of traversable
12:01:57 <copumpkin> you can't
12:02:02 <copumpkin> as far as I know
12:02:09 <monochrom> some Traversable types are not meant to infinitely "iterate".
12:02:36 <jmcarthur> i don't see how you could do any unfold from Traversable at all
12:02:51 <monochrom> But nothing stops you from introducing a class "Generable"
12:02:52 <copumpkin> traversable preserves the "shape" of the thing being traversed
12:03:08 <Kaidelong> hmm
12:03:23 <jmcarthur> we might as well just go for a fixpoint type class
12:03:26 <Kaidelong> you could in general talk about something which returns Just(head, tail) or Nothing
12:03:54 <Kaidelong> when you inspect the head
12:03:57 <jmcarthur> Kaidelong: yup
12:03:59 <jmcarthur> http://hackage.haskell.org/packages/archive/fixpoint/0.1.1/doc/html/Data-Fixpoint.html
12:04:36 <jmcarthur> Kaidelong: data Pre [a] s = Nil | Cons a s deriving(Show)
12:04:54 <copumpkin> I like that
12:04:58 <jmcarthur> Kaidelong: and your version of that would be a Pre [a] [a]
12:04:59 <copumpkin> hadn't seen that package
12:05:10 <deadguys> hi all.  any tips for quasiquoting syntactically correct haskell code (but which doesn't typecheck, ruling out TH)?  
12:05:11 <jmcarthur> yeah it's nice. i just wish it had MOAR STUFF
12:05:32 <copumpkin> add more :P
12:05:36 <copumpkin> they're pretty easy to write in
12:05:38 <copumpkin> and upload
12:05:51 <jmcarthur> yeah... or i could be nice as communicate with the author first :P
12:05:55 <jmcarthur> *and
12:05:58 <copumpkin> pff
12:06:00 * copumpkin pokes rl
12:06:21 <copumpkin> oh is he awake?
12:06:32 <jmcarthur> "the romans" are easy to get a hold of normally at least
12:06:44 * copumpkin is a roman
12:06:58 <wli> I'd rather be a Roman.
12:07:30 <zachk> my maternal grandfather looked exactly like a bust of a roman senator we saw in a museum 
12:09:27 <Nibble> guys, I get Not in scope errors when compiling this code:
12:09:36 <Nibble> typeValue = maximumBy (comparing length) $ group [5,6,5,7,10,11,10,10,2,2,2,3,2,5]
12:09:41 <Nibble> wait one sec
12:09:49 <copumpkin> you have Data.Ord in scope?
12:09:51 <copumpkin> and Data.List
12:10:19 <Nibble> copumpkin: that's the problem, I removed it when using ghci. Will add it
12:10:45 <Nibble> copumpkin: just doing import Data.List doesn't seem to work, it gives me syntax error on import
12:10:54 <copumpkin> o.O
12:11:19 <monochrom> in file, "import Data.List". at ghci prompt, ":m + Data.List"
12:11:19 <Phyx-> o.O
12:11:20 <Nibble> copumpkin: I just  parse error on input `import'
12:11:38 <Phyx-> is "import" at the start of the line?
12:11:41 <copumpkin> I think import is supposed to work in ghci too
12:11:43 <Phyx-> as in no whitespace before it
12:11:44 <Nibble> monochrom: I compile it with ghc now
12:11:46 <copumpkin> but I always just use the :m
12:11:51 <Nibble> Phyx-: yes
12:12:05 <Nibble> Phyx-: but do you mean start of the file?
12:12:06 <monochrom> paste
12:12:26 <Nibble> monochrom: it's a hundred line file
12:12:29 <Phyx-> Nibble: no, but all imports have to come after the module declaration and before anything else
12:12:38 <Nibble> Phyx-: then that is the problem
12:12:55 <monochrom> of course "paste" means paste bin
12:13:03 <Nibble> monochrom: I know.
12:13:25 <Nibble> monochrom: I would never paste a 100-line file on irc
12:13:32 <Phyx-> Nibble: you can't have import ... function .. import for instance. once the parser gets passed parsing imports it never looks for them again
12:13:46 <Nibble> Phyx-: seems to work now
12:13:51 <Nibble> Phyx-: so yes, that was the problem
12:13:57 <Phyx-> :)
12:14:01 <Nibble> now I just get Not in scope: `comparing'
12:14:19 <Nibble> @info comparing
12:14:19 <lambdabot> comparing
12:14:19 <Phyx-> @hoogle comparing
12:14:20 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:14:29 <Nibble> hum
12:14:31 <Phyx-> Nibble: that seems to be in Data.Org
12:14:39 <Phyx-> Ord*
12:14:58 <Nibble> Phyx-: thank you
12:15:11 <Nibble> :)
12:15:34 <markus3> hi! I'm trying to get a test program implementing a relational algebra working by using classes, but i have somekind of a problem, that I cant understand, nor fix. Could anyone smarter please look at it, please.. It's here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28376#a28376
12:16:00 <markus3> (it's three files pasted into one hpaste)
12:19:49 <Phyx-> markus3: you... should also describe the problem you're having
12:21:37 <Phyx-> we usually don't run files pasted, so without the error you usually won't get any help :P
12:22:25 <markus3> it's an abiguous type error
12:22:59 <Phyx-> the exact error is?
12:23:12 <markus3> the line where it says tup = T.fromList vals, it says that a type-variable "tuple" is ambiguous
12:23:28 <markus3> its in the file Relational.hs, in function "select"
12:25:30 <markus3> (PredPairs is a tuple-list of 1) domains (or indices into a body) and 2) values that a tuple shoult have to pass the predicate
12:25:38 <markus3> )
12:26:09 <Phyx-> I think that error is because it doesn't know the entermediate type of the expression is
12:26:21 <Phyx-> it's the same as (read.show) 1
12:26:27 <Phyx-> > (read . show) 1
12:26:27 <lambdabot>   *Exception: Prelude.read: no parse
12:26:35 <Phyx-> > (read . show) " "
12:26:36 <lambdabot>   *Exception: Prelude.read: no parse
12:26:39 <Phyx-> >(read . show) " "
12:26:46 <Phyx-> *sigh*
12:27:01 <Phyx-> markus3: anyway, try adding an explicit signature after tup = T.fromList vals
12:27:21 <Phyx-> try tup = T.fromList vals :: tuple
12:27:26 <Phyx-> and enable scope variabled
12:27:28 <Phyx-> variables
12:27:37 <markus3> yep, but i tried to fix it with a "forall tuple. T.Tuple tuple => tuple" and all simpler type signatures and couldn't fix it..
12:27:56 <markus3> ok, I'll try the scoped variables and see
12:28:04 <verdelyi> can someone explain this error message to me? http://pastebin.ca/1911204 especially the "probably solution" part
12:28:39 <Phyx-> markus3: that's ScopedTypeVariables pragma btw
12:30:30 <Phyx-> verdelyi: I don't know much about GADTs personally, but that error message says to add a type signature in the expression in your case statement
12:30:35 <markus3> ...and it fixed it! Thanks!!
12:30:39 <Phyx-> e.g. case <scrutinee> of
12:30:55 <Phyx-> into case <scrutinee> :: <type> of
12:31:01 <markus3> just enabling Scoped... and putting a ":: tuple" at the end
12:31:20 <verdelyi> Phyx-: hmm ok, thx. My dictionary didn't come up with anything useful for scrutinee.
12:31:42 <Phyx-> markus3: yes, that just makes the typecheck treat the the tuple type you declare there as the same type as the one in the class
12:31:57 <Phyx-> markus3: without it, it threats them as different types, which is why your earlier attempt failed
12:32:44 <Phyx-> treats*
12:33:46 <verdelyi> Phyx-: can that type in the case statement contain type variables? I gave it a type with only one type variable and it didn't help
12:34:48 <markus3> Phyx-: ok, but why do I have to even give the type? the type for "T.fromList" and "vals" should already tell, that the result is a tuple 
12:35:36 <Phyx-> verdelyi: it could, but that won't solve the the error I think. It wasn'ta  concrete type, or atleast a scoped type I think
12:35:48 <Phyx-> markus3: because the result of T.fromList vals is unknown
12:36:17 <Phyx-> markus3: T.fromList speficies a return type of "tuple"
12:36:27 <verdelyi> Phyx-: you mean I can only pattern match for a GADT if I give a fully concrete type?
12:36:48 <Phyx-> verdelyi: I would say no, but then again, I don't know much about GADTs
12:37:01 <Phyx-> could you paste the case expression?
12:37:21 <Phyx-> markus3: T.fromList <value> isn't enough for it to know WHICH of the instances to pick
12:38:03 <Phyx-> markus3: so it tries to see how you use it to figure out the type. the return type of T.fromList in your declaration is independent of the input. [Attr] is a concrete type
12:38:32 <Phyx-> so it fond a toList but that means It knows the type to convert from, but not the intermediate type
12:38:47 <Phyx-> markus3: the simplist way to see this is in the example of (read.show)
12:39:21 <Phyx-> the type of that is a -> a
12:39:22 <verdelyi> Phyx-: you probably don't want to see that but yes, here it is: http://fpaste.org/JwKr/
12:39:46 <Phyx-> but it doesn't know the intermediate type to convert to, so it doesn;t know which instances of Read and Show to pick
12:40:27 <roconnor> ClaudiusMaximus: did you fix your space-leak thingy that you thought was in sort?
12:40:42 <markus3> Phyx-: ok, thank you for the explanation, I have to think about it for a while
12:40:55 <ClaudiusMaximus> roconnor: it was in    unionsWith (+)
12:41:14 <roconnor> ClaudiusMaximus: cool, what are the details, and work arounds?
12:41:24 <ClaudiusMaximus> roconnor: i fixed it by computing running totals during parsing
12:42:08 <jonafan> good news guys, i understand monads AGAIN
12:42:29 <roconnor> jonafan: what's a monad?
12:42:32 <byorgey> good work jonafan =)
12:42:34 <jonafan> i dont know man
12:42:53 <roconnor> that's a better answer than I expected
12:43:08 <mathijsje> I am confused, when should i use a Type and when Data, I mean, In a lot of cases you can do type X = (A,B,C) or data X = X A B C
12:43:34 <Nibble> btw, value constructors
12:43:50 <ManateeLazyCat> mathijsje: You can consider Type is alias for other type.
12:44:02 <c_wraith> type doesn't introduce a new type.  If you want type-safety, use data or newtype
12:44:13 <ClaudiusMaximus> mathijsje: 'type' is when you want to give a shorter name for an existing type, 'newtype' is when you want a new type using an existing representation, 'data' is when you want a new datastructure
12:44:15 <c_wraith> use type when you explicitly don't want type-safety
12:44:18 <Nibble> I don't really understand them, when I do use it on my own class I have to call the Value constructor right? Or what is the deal
12:44:24 <jonafan> i'm primarily an ocaml guy, so i look at monads from a language that doesn't really care about them
12:44:27 <roconnor> ya, type is more like a macro for shortening long types
12:44:43 <roconnor> newtype and data should be used way more often
12:44:54 <byorgey> Nibble: can you give an example?  I don't understand your question
12:44:55 <mathijsje> aha
12:45:07 <verdelyi> Phyx-: if I give it a concrete type the error message changes, but the problem is that that type can be virtually anything and I can't give just one.
12:45:12 <Phyx-> verdelyi: I think that error has to do with the existential type in that GADT
12:45:17 <Nibble> byorgey: (ValueConstructor xs) <> (ValueConstructor ys)
12:45:22 <EvanR-work> jonafan: also a language that doesnt care about type classes in general
12:45:26 <Nibble> where <> is a function I defined myself
12:45:28 <jonafan> anyway i wrote an array monad, so my arrays can be referentially transparent i guess
12:45:41 <byorgey> mathijsje: another rule of thumb: pairs are sometimes useful; you should almost never use triples or quadruples or ...
12:45:43 <jonafan> yeah, i wish ocaml had type classes
12:45:53 <EvanR-work> jonafan: O(1) lookups?
12:46:00 <byorgey> Nibble: ok, so what's the question?
12:46:02 <ClaudiusMaximus> type is useful sometimes if you need to refactor later (eg    type MyString = String    and later change it to   type MyString = ByteString    )
12:46:02 <verdelyi> Phyx-: you mean the "a" in Expr?
12:46:03 <jonafan> yeah
12:46:08 <EvanR-work> O(1) updates?
12:46:09 <mathijsje> in my case I want a function to return like 4 values
12:46:11 <jonafan> they're just arrays that can't be accessed outside the monad
12:46:15 <mathijsje> so its a 'data' and not a 'type?
12:46:34 <Nibble> byorgey: xs is of what type?
12:46:36 <ClaudiusMaximus> @hoogle runSTUArray
12:46:36 <lambdabot> Data.Array.ST runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
12:46:38 <jonafan> the type is covered up so if you take them out, you can't do anything with them
12:46:38 <roconnor> ClaudiusMaximus: good point
12:46:42 <EvanR-work> jonafan: functional array update?
12:46:48 <ManateeLazyCat> mathijsje: Example, when you pass many types to function, fun :: (Foo1, Foo2, Foo3, ... FooN), you can write "type Foo = (Foo1, Foo2, Foo3 ... FooN)", then you just need "fun :: Foo" :)
12:46:58 <jonafan> i don't know what you mean
12:46:59 <Nibble> byorgey: http://beta.yapaste.com/f3
12:47:12 <Phyx-> verdelyi: yes, it's bound to a Storable instance, which makes it an existential, the way it's written. I know that GADTs and Existentials have some probems, But i've never used one myself
12:47:19 <roconnor> ClaudiusMaximus: though arguably you should use a newtype there, in reality newtype is too heavy-weight.
12:47:20 <byorgey> Nibble: whatever type it was declared to be.  for example if you had  data MyType = ValueConstructor Int | OtherConstructor Char, then xs would be of type Int
12:47:45 <ClaudiusMaximus> -XAutomaticNewtypeWrapping ?
12:47:50 <jonafan> but you do writeArray arr idx value >>= fun () -> whatever
12:47:51 <byorgey> Nibble: in that paste, xs :: [Int]
12:47:59 <EvanR-work> jonafan: monad may present the illusion of a mutable state, but it doesnt by itself make efficient array updates possible
12:48:02 <jonafan> ocaml has no do notation
12:48:13 <byorgey> Nibble: every value of type SomeInstance looks like ValueConstructor applied to a value of type [Int]
12:48:30 <Nibble> byorgey: I understand a bit of that
12:48:33 <verdelyi> Phyx-: that's strange because I can't pattern match on the Function constructor either and that doesn't need Storable.
12:48:35 <jonafan> well, they're just ocaml's arrays
12:48:41 <Nibble> byorgey: so, what ValueConstuctor evaluates to
12:48:49 <Nibble> is what it shows up as?
12:48:54 <EvanR-work> jonafan: i thought you said it was a monad (in haskell?)
12:48:54 <jonafan> i'm sure it's a lot less efficient than just using the array directly, but they're real arrays
12:49:05 <jonafan> i said it was ocaml
12:49:11 <EvanR-work> an array monad in ocaml?
12:49:16 <Nibble> byorgey: nvm, I did a type on ValueConstructor
12:49:19 <byorgey> Nibble: ValueConstructor doesn't evaluate to anything, it's just the way you construct SomeInstance values
12:49:27 <jonafan> actually i guess i neglected to clarify that important point
12:49:31 <EvanR-work> lol
12:49:33 <Nibble> seems like it returns SomeInstance
12:49:37 <Phyx-> verdelyi: but you're using a "b" that you defined in the declaration itself and not the GADT itself, same thing
12:49:42 <jonafan> anyway, it's neat
12:50:00 <Nibble> byorgey: but how does SomeClass know what to do with the [Int]
12:50:01 <byorgey> Nibble: yes
12:50:06 <Phyx-> verdelyi: it's defined over all a/ (forall) and over some b's (exist)
12:51:07 <byorgey> Nibble: I don't understand.  Can you rephrase the question less anthropomorphically?
12:51:52 <byorgey> Nibble: you have defined <> using pattern matching
12:51:55 <Nibble> byorgey: well. could I take this in PM, will be a bit of text and there is too much stuff going on here to keep it in order
12:51:56 <monadic_kid> hi, doesn't know anything about jhc cabal files?
12:51:59 <Nibble> byorgey: correct
12:52:23 <askhader> I am attemtping to define a data type that has multiple constructors, depending on the numebr of arguments it was supplied. WHy is this invalid?   data foo x y = Single x | Double x y  ?
12:52:38 <verdelyi> Phyx-: I have another function: http://fpaste.org/JLVp/ how can this one work then? It has Function inside the pattern match...
12:52:47 <ManateeLazyCat> askhader: data Foo not "data foo"
12:52:51 <ezyang> askhader: Foo needs to be capital 
12:52:58 <askhader> RIght, I got that
12:53:03 <askhader> I just omitted it in my example to yo uall
12:53:27 <ManateeLazyCat> askhader: "data Foo x y = Single x | Double x y"
12:54:09 <verdelyi> Phyx-: hmm probably because that's "Data a" and not "a"..
12:54:18 <pchiusano_> is StableNames guaranteed to return distinct hashes for distinct objects under any condition? (Like, say, for any two objects that have not been gc'd)
12:54:32 <askhader> Well Double 1 2  produces an error
12:54:34 <verdelyi> Phyx-: I think my case expression wants to be too general
12:55:39 <ManateeLazyCat> askhader: Paste your error will help. 
12:55:54 <Phyx-> verdelyi: well, that function presumably doesn't have any ambiguity, which the case expression does
12:56:24 <Phyx-> verdelyi: I would say, ask on cafe. You would get people with alot more experience with GADTs than me :)
12:56:53 <askhader> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28377#a28377
12:56:55 <verdelyi> Phyx-: ok, thanks for the info nevertheless
12:57:27 <ezyang> add deriving (Show) 
12:57:36 <ezyang> The error you've got has nothing to do with your data definition 
12:57:42 <askhader> =/
12:57:46 <askhader> Then what's it got to do with?
12:57:59 <Phyx-> verdelyi: sorry I douldn't help much
12:58:38 <ezyang> askhader: GHCi is attempting to display your result, but because there is no Show instance it can't 
12:58:40 <verdelyi> Phyx-: rest assured that I understand the situation better than before
12:58:45 <askhader> =/ lame
12:58:47 <askhader> k thanks
12:58:48 <ManateeLazyCat> askhader: deriving Show
12:59:25 <ManateeLazyCat> askhader: data Tuple x y = Single x | Double x y 
12:59:26 <ManateeLazyCat>              deriving Show
12:59:42 <ManateeLazyCat> askhader: Then ghci will show your type.
12:59:55 <askhader> Wait, deriving Show should be part of the data definition?
12:59:56 <zachk> askhader: it really is that simple 
12:59:59 <zachk> yes 
13:00:05 <askhader> Sure, that's simple. Just non-intuitive
13:00:06 <ManateeLazyCat> askhader: Yes.
13:00:15 <ManateeLazyCat> askhader: It's automatic, you don't need handle detail.
13:00:19 <zachk> or you can roll your own show 
13:00:24 <zachk> but that is a bit more in depth 
13:00:43 <Phyx-> "roll your own show"
13:00:46 <Phyx-> that's so ghetto :P
13:01:04 <ManateeLazyCat> askhader: In most situation, deriving is enough, not just "deriving Show", you can write more, such as "deriving (Show, Eq, Ord)
13:01:10 <askhader> I see
13:02:07 <EvanR-work> haskell is awesome like that
13:02:11 * ManateeLazyCat It's wrong time ask question..... webkit developer sleep.... 
13:02:17 <ManateeLazyCat> :(
13:02:20 <Nibble> @src Int
13:02:20 <lambdabot> data Int = I# Int#
13:02:37 <ManateeLazyCat> Any webkit developer here? :)
13:02:46 <EvanR-work> hopefully a soon haskell revision defines deriving MMORPG3dFPSRTS
13:05:03 <pchiusano_> the docs are not clear - if StableName a == StableName b, is it true that hash (StableName a) == hash (StableName b) ?
13:05:11 <pchiusano_> I am looking at: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Mem-StableName.html
13:05:49 <ezyang> pchiusano_: By hash do you mean hashStableName? 
13:05:58 <pchiusano_> ezyang: yes
13:06:43 <ezyang> Then, yes. 
13:07:04 <pchiusano_> ezyang: does it say that somewhere?
13:07:31 <pchiusano_> I was a little unsure about this statement: The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that mkStableName may return a different StableName after an object is evaluated.
13:08:29 <Lemmih> pchiusano_: It just means that you can get false negatives.
13:08:30 <ezyang> So, what that is saying is that StableNames are conservative: if the stable names says they are equal, the objects are equal; but if the objects are equal, the stable name won't necessarily say they're equal 
13:08:51 <ezyang> StableName equality is strong, in that sense. 
13:09:26 <pchiusano_> ezyang: so stable name equality implies all other forms of equality, but not necessarily the converse
13:09:32 <ezyang> Yep. 
13:09:53 <ezyang> well, not quite true. 
13:09:57 <pchiusano_> and stable name equality also implies hashStableName equality
13:10:01 <ezyang> It doesn't have anything to do with the Eq typeclass, fwiw 
13:10:10 <ezyang> Yes, that's one of the points of stable names 
13:11:17 <pchiusano_> ezyang: okay, cool
13:12:36 <pchiusano_> ed kmett is always talking about using StableNames to recover sharing information... which now makes sense to me I think
13:12:47 <ezyang> Right. 
13:13:04 <ezyang> Because if the stable names are the same, that means that the "pointers" are pointing to the same place. 
13:16:11 <napping> pchiusano_: hashStableName respecting equality is just a matter of that being a pure function, and the == on StableName being sensible
13:16:53 <napping> how are they constructed? (how would evaluation change the result)
13:17:53 <pchiusano_> I am writing a parsing library which will be an instance of Alternative, (this is actually in Scala, though), and I think I am going to use something like stable names to assign a unique id for each node in the grammar
13:18:48 <napping> that should be reasonable
13:18:53 <koninkje> napping: they're basically stored in a tabled part of memory which is updated whenever GC moves things
13:18:54 <napping> are you trying to discover cycles?
13:19:16 <napping> you could look at how Kansas Lava works
13:19:29 <napping> koninkje: yeah, there's a table of stable name pointers
13:19:30 <pchiusano_> napping: Kansas Lava?
13:19:34 <ezyang> napping: Haskell doesn't distinguish between a thunka nd an evaluated value. 
13:19:44 <ezyang> but it seems that stable names do. 
13:19:50 <napping> but to work the pointers would have to be updated by the GC
13:19:56 <jmcarthur> ezyang: wha-?
13:20:06 <napping> so it seems odd it wouldn't also follow indirections
13:20:08 <ezyang> jmcarthur: Syntactically speaking. 
13:20:21 <ezyang> And disregarding seq and friends :^) 
13:20:31 <askhader> Is it illegial to use "or" in case expressions? 
13:20:34 * ezyang spews lies 
13:20:39 <askhader> nor "or" sorry ||
13:20:42 <ezyang> askhader: Needs to be in a guard. 
13:20:44 <jmcarthur> ezyang: i have no idea what you are saying ;)
13:20:59 <askhader> Thanks
13:21:15 <ClaudiusMaximus> > case 42 of x | x > 40 || x < 50 -> "woo"
13:21:16 <lambdabot>   "woo"
13:21:17 <napping> weird, it seems forcing evaluation does result in a new stable name
13:21:44 <napping> perhaps if I ensured a GC to update the old reference with the indirection
13:22:34 <jmcarthur> ezyang: i don't think that the result of (a == b) where a and b are StableNames will change depending on whether a or b are evaluated
13:22:51 <jmcarthur> wha-?
13:22:54 <ezyang> jmcarthur: Oh, yeah, I wasn't talking about stable names 
13:22:59 <napping> jmcarthur: no, but makeStableName may not recognize identity after evaluation
13:23:00 <ezyang> I was talking about x in makeStableName x 
13:23:51 <jmcarthur> napping: is StableName's Eq instance not referentially transparent?
13:23:57 <jmcarthur> oh!
13:24:04 <jmcarthur> the IO action
13:25:14 <napping> I'm just a bit surprised that makeStableName doesn't shorten indirections as it's walking the table to compare
13:25:21 <napping> at least, it seems like that's what's going wrong
13:26:26 <koninkje> ezyang: stable names don't distinguish thunks from evaluated values
13:26:46 <ezyang> koninkje: Oh. Curious. 
13:26:54 <koninkje> ezyang: rather, some thunks are marked as "don't update" and therefore do call-by-name instead of call-by-need
13:27:22 <askhader> How can I have 'or' span multiple lines?
13:27:27 <askhader> for cleanliness of codes
13:28:04 <letsel> Is there any reason to use the foldr function over foldl, aside from knowing before hand that the list being iterated upon is sorted(where the order of elements impact the result) in some fashion where one would use foldr so one does not need to first call reverse on the list? ie, keep the code clean and concise?
13:28:19 <ClaudiusMaximus> askhader: or[ foo\n  , bar\n  , quu\n  ]
13:29:12 <koninkje> ezyang: the reason for "don't update" thunks is to reduce contention/overhead when computing simple functions. Therefore the result of evaluating a "don't update" thunk is not pointer equal
13:29:36 <koninkje> i.e. when the overhead would be more than just recomputing
13:29:56 <ClaudiusMaximus> letsel: foldr is more natural, thus can exit early and can work on infinite lists
13:30:02 <koninkje> letsel: foldr supports infinite lists, and also follows the natural structure
13:30:34 <napping> koninkje: there are such thunks, but doesn't GHC only produce them when it knows the result is only used once
13:30:36 <ClaudiusMaximus> > foldr (+) 0 (a:b:c:d:[])
13:30:37 <lambdabot>   a + (b + (c + (d + 0)))
13:30:56 <napping> koninkje: in particular, I tried a simple let foo 0 = 0; foo n = foo (n-1); x = foo 10 in ghci
13:31:04 <koninkje> napping: it also produces them for some known-cheap functions IIRC
13:31:04 <napping> and get a different StableName before and after forcing x
13:31:13 <ClaudiusMaximus> letsel: you can that foldr simply replaces : with + and [] with 0
13:31:32 <ClaudiusMaximus> *foldr (+) 0
13:31:40 <letsel> I don't understand how it can work on infinite lists. If the list is infinite, then the last element can not be known, and hence it can't start from the right?
13:31:43 <napping> whoa, wierd, now it's randomly returning one of two values
13:32:02 <napping> letsel: foldr is the one that can work on infinite lists
13:32:04 <koninkje> napping: there are other reasons stable names aren't evaluation stable, but call-by-name thunks are one of them
13:32:06 <ezyang> koninkje: Ah! That makes a lot more sense. 
13:32:07 <napping> if "f" is lazy
13:32:22 <pchiusano_> letsel: the binary function must be lazy in its second argument
13:32:33 <ClaudiusMaximus> > foldr const 42 [0..]
13:32:34 <lambdabot>   0
13:32:34 <Saizan_> letsel: control flow doesn't really start from the right, it all depends on what the stepping function forces first
13:32:43 <koninkje> http://research.microsoft.com/en-us/um/people/simonpj/papers/weak.ps.gz
13:32:47 <pchiusano_> > foldr (:) [] [1,2,3,4]
13:32:48 <lambdabot>   [1,2,3,4]
13:33:05 <pchiusano_> > foldr (:) [] [1,2...]
13:33:06 <lambdabot>   A section must be enclosed in parentheses thus: (2 ...)Not in scope: `...'
13:33:12 <pchiusano_> > foldr (:) [] [1..]
13:33:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:33:59 <monadic_kid> yay, now  i've got jhc style cabal file, building my modified SDL bindings
13:34:42 <Wolfspaw> Anyone here uses the Yi editor? I dont see much talk about it, and it seems really cool 
13:35:12 <monadic_kid> Wolfspaw: have you tried leksah, i like it
13:35:47 <koninkje> Wolfspaw: I haven't yet, though I intend to. I only recently got a computer that supports a new enough GHC to compile it
13:36:47 <Wolfspaw> monadic_kid: i tried, it was great. But it was a bit buggy in my Deficient System ( windows @_@ )
13:36:58 <CakeProphet> Haskell's indentation style is relatively freeform
13:37:03 <CakeProphet> compared to languages like Python
13:37:09 <CakeProphet> there's a lot of room for different stylings
13:37:20 <ClaudiusMaximus> letsel: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=%28+foldr+%28%3A%29+[]+%22folds%22+%2C+foldl+%28%3A%29+[]+%22folds%22+%29  (see line 21 where foldr is on the "inside" and foldl is stuck on the "outside")
13:37:22 <koninkje> Python's whitespace sensitivity is a straightjacket
13:37:25 <napping> freeform, right. Somehow I read "uniform"
13:37:39 <napping> I do like the design with optional {;} to escape from whitespace
13:37:46 <CakeProphet> yes
13:37:49 <napping> make printing code easier if nothing else
13:38:05 <CakeProphet> actually me and some friends make a "compiler" that translates a Python dialect that used {} and ; 
13:38:08 <CakeProphet> to regular Python
13:38:24 <letsel> I think I understand, so basically, you give it an infinite list but there is something in the function that 'terminates' the infinite series, thus in a sense reducing or collapsing the list to a finite one which foldr then works from, that is part of the infinite series provided?
13:38:54 <CakeProphet> letsel:  you're going in the right direction, yes. but the specifics aren't quite right.
13:38:58 <napping> well, it's more about lazy evaluation
13:38:59 <ClaudiusMaximus> not really, it's more that foldr can start to produce output before the end of the list
13:39:04 <napping> rather than something "terminating" it exactly
13:39:12 <napping> though you can certainly write code that looks a lot like that
13:39:14 <CakeProphet> the evaluation terminates, I guess
13:39:14 <ClaudiusMaximus> while foldl needs to reach the end of the list
13:39:16 <napping> you've seen _|_?
13:40:02 <roconnor> foldr f is guarde co-recursion when f produces a constructor.  That means (foldr f) is productive in that case.
13:40:07 <roconnor> *guarded
13:40:23 <roconnor> @src foldr
13:40:23 <lambdabot> foldr f z []     = z
13:40:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:40:26 <CakeProphet> letsel:  Haskell simply doesn't evaluate everything all at once. It carries around expressions as special data structures until they need to be evaluated. The whole list doesn't evaluate, thus the computation can terminate
13:40:46 <roconnor> The important fact is is that the recursive call to foldr needs to be underneth a constructor
13:41:01 <roconnor> and often f provides that constructor
13:41:31 <koninkje> or f can be lazy in the recursive argument
13:41:42 <koninkje> doesn't *need* to provide a constructor
13:41:47 <roconnor> once that recursive call is "guarded" by a constructor it won't evaluate until later.
13:42:04 <roconnor> koninkje: really?
13:42:38 <roconnor> what's the difference?
13:42:44 <koninkje> You just need f to be guarded in the recursion. That guard can be a lazy data constructor, or it coulf be something like `const`
13:43:05 <roconnor> hmm
13:43:07 <CakeProphet> letsel:  something like foldr (+) [0..]  won't terminate. The program will attempt to sum every element of an infinite list and you'll never get a result.
13:43:15 <CakeProphet> *foldr (+) 0 [0..]
13:43:58 <koninkje> roconnor: I tend to think of lazy data constructors as just a special case of functions lazy in the recursive site
13:44:00 <CakeProphet> letsel:  but data constructor application can be lazily produced.
13:44:08 <CakeProphet> one element at a time, as needed 
13:44:10 <CakeProphet> later in the program.
13:44:29 <koninkje> roconnor: because note also that if the data constructor is strict in the recursive site, that will still cause _|_
13:45:22 <CakeProphet> @src foldr
13:45:22 <lambdabot> foldr f z []     = z
13:45:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:45:27 <koninkje> e.g. data (:!:) a b = !a :!: !b ; foldr (:!:) () 
13:45:42 <CakeProphet> > foldr (:) [] [1..]
13:45:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:45:46 <napping> letsel: is any of this making sense? seems like it might be getting a bit deep
13:45:50 <CakeProphet> > foldr (+) 0 [1..]
13:45:51 <lambdabot>   *Exception: stack overflow
13:45:59 <CakeProphet> > foldl (+) 0 [1..]
13:46:09 <lambdabot>   mueval: ExitFailure 1
13:46:48 <koninkje> CakeProphet: you'd want to use foldl' anyways, to avoid stack overflow due to strictness of (+) when the thunk is eventually evaluated
13:46:51 <letsel> Thanks for the advice, I don't fully understand what you guys are trying to teach me, but I'm still in the middle of studying the language, currently using learnyouahaskell.com, so I'll put understanding it on the sideburner for now until I know more.
13:47:04 <napping> letsel: well, the basic point is lazy evaluation
13:47:13 <letsel> Yeah, I understand lazy evaluation.
13:47:20 <napping> [1..] is just special syntax for calling enumFrom 1
13:47:20 <letsel> At least I think I do. :P
13:47:31 <napping> so if you write like (foldr (:) 0 [1..])
13:47:35 <burp> someone tell me why darcs is so unbelievably slow? :D
13:47:39 <CakeProphet> letsel:  oh, I came in halfway to this conversation, so I don't know what was being taught. 
13:47:45 <napping> then it starts to evaluate that, because it's at the top level or whatever
13:48:00 <napping> and then foldr needs to see if the list is done, so that forces (enumFrom 1)
13:48:05 <letsel> I asked about the difference between foldl and foldr.
13:48:12 <CakeProphet> ...oh. :)
13:48:22 <napping> now we've got like (foldr (:) 0 (1:enumFrom 2))
13:48:25 <CakeProphet> @src foldl
13:48:25 <lambdabot> foldl f z []     = z
13:48:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:48:27 <CakeProphet> @src foldr
13:48:27 <lambdabot> foldr f z []     = z
13:48:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:48:37 <napping> then foldr does it's replacement and makes (:) 1 (foldr (:) 0 (enumFrom 1))
13:48:55 <napping> and now you've got one constructor of the result, without falling into infinities
13:49:15 <napping> foldl nests the otherway - somebody linked some nice pictures
13:49:24 <monochrom> This trend is disturbing. First there was "scrap your boilerplate". Now there is "scrap your zippers" too. Next we will have "scrap your source code", followed shortly by "scrap your coder" too.
13:49:37 <roconnor> where is scrap your zippers?
13:49:47 <napping> foldl f z [x1,x2,..,xN] turns into f (.. (f (f z x1) x2) ..) xN
13:49:48 <koninkje> though, again, we can use any function which is lazy in the second argument depending on the value of the first argument. Constructors aren't special here
13:49:52 <CakeProphet> letsel:  in foldl parens come first: ((((1+2)+3)+4...)  foldr works like this:  (1 + (2 + (3 + ...)))
13:49:54 <hpc> i don't grok zippers enough to know how one would use them, let alone scrap them
13:50:01 <monochrom> the hackage package "syz" is "scrap your zippers"
13:50:30 <monochrom> there is also an announcement on the haskell mailing list
13:50:44 <CakeProphet> have you guys heard of "scrap your functional code"?
13:50:56 <CakeProphet> it's an attempt to make Haskell more like C, as it should be.
13:51:06 <CakeProphet> -ahem- :P
13:51:08 <roconnor> monochrom: syb made McBride literally throw up
13:51:09 <koninkje> roconnor: draft == http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.9545&rep=rep1&type=pdf
13:51:41 <koninkje> also http://www.cs.indiana.edu/~adamsmd/papers/scrap_your_zippers/
13:51:53 <napping> roconnor: literally?
13:52:15 <CakeProphet> letsel:  for large lists, foldl makes a pretty big stack. foldr does not.
13:52:16 <roconnor> so he said, 
13:52:43 <koninkje> CakeProphet: no, foldl and foldl' run in constant stack because of TCO
13:52:44 <roconnor> napping: though instead of puke, I think he threw up Applicative, Foldable and Traversable.
13:52:49 <roconnor> which is much better than puke.
13:53:04 <monochrom> oh, that kind of throw up :)
13:53:08 <napping> Hmm, I kind of think the "levitation" paper and some of the OTT stuff has a similar sort of cunning
13:53:22 <koninkje> CakeProphet: it's the evaluation of the result which may (or may not) use a big stack
13:53:26 <monochrom> syz will cause oleg to throw up "scrap your iteratees" :)
13:53:32 <roconnor> I try to avoid anything that involve (Data a) =>
13:53:39 <roconnor> if I wanted to be untyped, I'd use scheme.
13:54:00 <CakeProphet> koninkje:  to evaluate any part of the fold you'd have to evaluate the whole stack, wouldn't you? ah... no I guess not.
13:54:10 <Wolfspaw_> doing cabal install Yi i got a error: 
13:54:12 <CakeProphet> koninkje:  I guess I never thought about the stack being lazy too. :)
13:54:15 <Wolfspaw_> Configuring glib-0.11.0...
13:54:15 <letsel> ok, I think the main thing I learned here is that there are too many aspects of Haskell I don't understand yet that plays a part in understanding the difference here, so I guess it's back to studying. But none the less, thanks guys. :)
13:54:15 <Wolfspaw_> setup.exe: gtk2hsC2hs is required but it could not be found.
13:54:16 <Wolfspaw_> cabal.exe: Error: some packages failed to install:
13:54:24 <koninkje> > foldl (flip (:)) [] [1..100]
13:54:24 <roconnor> oh god, left and right are part of the "generic" zipper
13:54:28 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
13:54:28 <Wolfspaw_> What can i do? @_@
13:54:38 <roconnor> conal would be spinning in his grave if he were dead
13:54:40 <Wolfspaw_> install gtk2hsC2hs manual?
13:54:53 <tg_> roconnor: left and right?
13:54:54 <monochrom> is "centre" also part of the generic zipper? "left, right, and centre" :)
13:55:02 <fryguybob> roconnor: lol
13:55:07 <koninkje> > foldl (flip (:)) [] [1..10000000]
13:55:11 <pchiusano_> roconnor: have you seen http://okmij.org/ftp/Computation/Continuations.html#zipper
13:55:12 <monochrom> well he can spin in his bed when he's asleep :)
13:55:13 <hpc> roconnor: yeah, everyone knows it should be "light" and "reft"
13:55:13 <lambdabot>   mueval-core: Time limit exceeded
13:55:14 <lambdabot>  mueval: ExitFailure 1
13:55:26 <pchiusano_> roconnor: no SYB necessary
13:55:30 <roconnor> tg_: according to the paper: left, right, up, down :: Zipper a -> Maybe (Zipper a)
13:55:37 <koninkje> > take 10 $ foldl (flip (:)) [] [1..10000000]
13:55:41 <lambdabot>   mueval-core: Time limit exceeded
13:55:43 <napping> So, I'm trying to come up with pattern syntax
13:55:47 <CakeProphet> roconnor:  is that valid Haskell syntax btw?
13:55:47 <koninkje> meh
13:55:49 <pswoo> is there a lambdabot command for finding a library function of a given type?
13:55:53 <CakeProphet> f,g,z :: ...
13:55:53 <napping> and running into trouble with the usual ambiguity
13:55:59 <roconnor> CakeProphet: I forget
13:56:01 <koninkje> CakeProphet: yes
13:56:04 <tg_> roconnor: is this paper groundbreaking?
13:56:06 <monochrom> Yes it's valid to have f,g,z :: Int
13:56:06 <napping> a statment may be a simple expression, an expression may be a single variable
13:56:21 <napping> so, how do you tell what kind of pattern you have?
13:56:27 <roconnor> tg_: I don't think I should answer that question cause I haven't (and won't) read it.
13:56:31 <CakeProphet> napping:  heuristics. :)
13:56:33 <CakeProphet> and magic
13:56:33 <koninkje> ?
13:56:40 <monochrom> > let {f,g,z :: Int; f=0; g=1; z=2} in [f,g,z]
13:56:41 <lambdabot>   [0,1,2]
13:56:56 <roconnor> tg_: read conal's latest blog post.  It is probably much better.
13:56:57 <CakeProphet> sweet. I might actually use that shorten my code by a few lines now. :)
13:57:01 <CakeProphet> +to
13:57:21 <monochrom> it is common in library code
13:57:38 <napping> CakeProphet: I'm thinking of actually implementing the usual paper convention, of declaring which letters you will use for different parts of syntax
13:57:57 <tg_> roconnor: oh, is this implemented using his memoization trie thing?
13:58:01 <BMeph> I like Conor's work; it's just a shame that I have such trouble remembering his name... ;)
13:58:04 <tg_> i have bookmarked those but havent' read them yet
13:58:12 <monochrom> The problem is I am not sure how you will haddock that kind of things.
13:58:16 <CakeProphet> monochrom:  it's a special form only available at a top-level declaration right? it wouldn't make sense to use as an expression, like other uses of ::
13:58:20 <tg_> BMeph: I see what you did there.
13:58:24 <roconnor> tg_: I think the zipper stuff is independent of his memoization stuff
13:58:38 <monochrom> declarations yes, expression no.
13:58:56 <CakeProphet> hahaha... so I just realized that seq slightly resembles the comma operator in C.
13:59:01 <monochrom> but no confined to top-level. haskell actually makes sense.
13:59:09 <roconnor> conal's definition of extract :: f a  f (Loc f a) is really smart and obvious in retrospect.
13:59:18 <koninkje> indeed
13:59:21 <tg_> for anyone following the LHC, they just put injected more bunches (by a factor of 2): http://meltronx.com/lhc3.html
13:59:23 <roconnor> I'm sure someone must have done this before, but I don't recall seeing it
13:59:39 <koninkje> I've seen it before, but I forget where
13:59:47 <CakeProphet> (unsafePerformIO launchMissiles) `seq`( x > y)
13:59:48 <koninkje> It was probably in prior work by conal
13:59:56 <napping> what's conor working on now?
14:00:02 <monochrom> unlike some stupid 1970s languages that put up arbitrary distinctions between top-level and nested-level, e.g., "can't define functions inside nested level".
14:00:23 <monochrom> The said 1970s language is still very mainstream today.
14:00:27 <roconnor> anyhow, extract replaces down, left, and right in a much more elegent way.
14:00:33 <CakeProphet> monochrom: but wait... where would you put a declaration that isn't top level? non-top-level as in a let or where clause?
14:00:34 <fryguybob> let sy x = "Scrap Your " ++ x in fix (\x -> sy x)
14:00:40 <roconnor> and let's holes be unordered.
14:00:43 <monochrom> yes, let and where
14:01:18 <BMeph> roconnor: The "generic zipper" paper you meant was the Clown and Jokers one, right?
14:01:28 <BMeph> *Clowns
14:01:38 <roconnor> BMeph: where did I mention this?
14:01:57 * CakeProphet knows nothing of zippers
14:02:01 <CakeProphet> are they useful?
14:02:06 <roconnor> CakeProphet: probably
14:02:09 <monochrom> It is particularly poisoning. You talk to any 2nd-year student about nested functions in SML or Haskell, they're like "what? what does that kind of code mean?"
14:02:15 <BMeph> roconnor: ":54] <roconnor> oh god, left and right are part of the "generic" zipper"
14:02:26 <CakeProphet> @hoogle (&)
14:02:26 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
14:02:27 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
14:02:27 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
14:02:27 <roconnor> BMeph: I was refering to http://www.cs.indiana.edu/~adamsmd/papers/scrap_your_zippers/
14:02:34 <CakeProphet> @hoogle (|)
14:02:35 <lambdabot> Text.Parsec.Prim class Monad m => | (Stream s m t) (s -> t)
14:02:35 <lambdabot> Control.Monad.Error.Class class Monad m => | (MonadError e m) (m -> e)
14:02:35 <lambdabot> Control.Monad.RWS.Class class (Monoid w, MonadReader r m, MonadWriter w m, MonadState s m) => | (MonadRWS r w s m) (m -> r)
14:02:47 <monochrom> At that point you no longer see the difference between education and brainwashing.
14:03:23 <roconnor> CakeProphet: Zippers are used in things like text editors
14:03:48 <CakeProphet> roconnor:  could they be used in say..... crappy command-line text editors? :)
14:03:54 <CakeProphet> for a text-based game?  :D :D 
14:03:57 <roconnor> CakeProphet: Zippers represent a recursive data structure with a cursor at a particular node.
14:03:58 <BMeph> monochrom: THere's a Huge difference between education and schooling. ;)
14:04:15 <CakeProphet> hmmm, I may have made a flat version of a zipper once, for a bf turing tape.
14:04:21 <CakeProphet> data Tape t = t [t] [t]
14:04:28 <roconnor> CakeProphet: that node can be efficently modified and moved to a neighbouring location (O(1) operations)
14:04:34 <CakeProphet> data Tape t = Tape t [t] [t]
14:04:34 <CakeProphet> rather
14:04:43 <monochrom> schools have monopolized education.
14:04:43 <roconnor> CakeProphet: yes, that is a zipper for a list
14:04:48 <CakeProphet> ah
14:04:55 <roconnor> CakeProphet: though you can equivalently use Tape [t] [t]
14:05:00 * CakeProphet could have invented zippers, and did!
14:05:14 <hpc> CakeProphet: now make a tutorial!
14:05:17 <roconnor> where the head of one of those lists (the second one probably) is your t
14:05:17 <CakeProphet> roconnor:  hmmm, but not as cleanly. in my opinion, at least.
14:05:26 <monochrom> recall that we guys who learn haskell outside school are the minority
14:05:35 * CakeProphet learned Haskell outside of school.
14:05:37 <roconnor> CakeProphet: I guess techincally taht is a zipper for a non-empty list
14:05:42 <hpc> monochrom: really? i learned it out of school
14:05:43 <roconnor> (what you had)
14:05:45 <CakeProphet> lolwhut?
14:05:45 <koninkje> Though ([t],[t]) is better used as the derivative of [t] 
14:05:55 <koninkje> not as the zipper
14:05:56 <Wolfspaw> setup.exe: Missing dependencies on foreign libraries:
14:06:00 <monochrom> yes, I mean the majority don't even learn haskell
14:06:20 <CakeProphet> roconnor:  what is a zipper for a list then?
14:06:20 <roconnor> Well ([t],[t]) is a type for both the deriviative and a zipper, but they are not the same data.
14:06:28 <koninkje> exactly
14:06:33 <roconnor> CakeProphet: a pair of lists.
14:06:39 <CakeProphet> hmmm
14:06:39 <CakeProphet> okay.
14:06:49 <CakeProphet> roconnor:  what's another example of a zipper?
14:06:54 <roconnor> The first list is the "reversed" head of the list upto the cursor location
14:07:09 <roconnor> the second is the list where the cursor is at
14:07:18 <CakeProphet> roconnor:  I've implemented and used it by accident, so I know what's it for. no need to explain, though I appreciate the intent. :D
14:07:27 <roconnor> CakeProphet: you can make a zipper for any recursive types.  The standard second example is a binary tree
14:07:29 <koninkje> http://www.haskell.org/haskellwiki/Zipper
14:07:41 <roconnor> A zipper for a binary tree is, let me think
14:07:58 <koninkje> roconnor: see the above link
14:08:11 <koninkje> (if you want to cheat)
14:08:12 <roconnor> ZipperTree = ZipperTree [Either Tree Tree] Tree
14:08:16 <roconnor> am I right?
14:08:29 <CakeProphet> Either Tree Tree seems dubious.
14:08:41 <koninkje> though the presentation there isn't the best one, IMO. Huet's original paper is much better
14:09:05 <roconnor> CakeProphet: the [Either Tree Tree] is a reverse list of the part of the tree "above" the cursor
14:09:14 <CakeProphet> aaah
14:09:17 <koninkje> it's [(Bool,Tree a)]
14:09:24 <koninkje> or isomorphic thereto
14:09:31 <Wolfspaw> installing Yi Editor with cabal i get: * Missing C libraries: gobject-2.0,
14:09:31 <CakeProphet> because a tree can't simply reversed like a list
14:09:32 <Wolfspaw> glib-2.0, intl, iconv. Im on windows (cygwin) , how can i install those libs?
14:09:35 <CakeProphet> more information is needed?
14:09:36 <roconnor> CakeProphet: the Left and Right says whether the tree belongs left or right of the path from the root to the cursor
14:09:50 <CakeProphet> gotcha
14:10:01 <roconnor> koninkje: ya, Either Tree Tree and (Bool,Tree) are isomorphic
14:10:13 <koninkje> roconnor: yep
14:10:31 <roconnor> CakeProphet: this generalizes to any data structure which is the fixedpoint of a functor.
14:10:39 <CakeProphet> ...
14:10:44 <CakeProphet> now you have lost me
14:10:45 <CakeProphet> but that's okay.
14:10:54 <CakeProphet> I'll stick with "any recursive data structure" for now.
14:11:08 <koninkje> CakeProphet: every recursive sum/product type is the fixpoint of some sum/product functor
14:11:45 <CakeProphet> koninkje:  then I assume some zippers are not very interesting?
14:11:59 <koninkje> e.g. List a = Fix (ListF a) ; ListF a r = Nil | Cons a r
14:12:20 <koninkje> CakeProphet: I'd say that the zippers for any non-recusive type aren't interesting :)
14:12:47 <CakeProphet> ,,,not really sure I see the point of the Fix constructor.
14:12:58 <CakeProphet> Fix = Sum / Product ?
14:13:07 <CakeProphet> typeclass polymorphism?
14:13:11 <koninkje> sum = Either ; product = (,)
14:13:24 <koninkje> Fix f = Fix (f (Fix f))
14:14:07 <CakeProphet> koninkje:  not in the example you give. It seems Fix will not recurse in any way.
14:14:07 <koninkje> the reason for explicitly using Fix and the underlying functor si to avoid ugliness like unfoldr
14:14:14 <koninkje> @t unfoldr
14:14:15 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:14:23 <koninkje> @type unfoldr
14:14:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:14:40 <koninkje> Maybe (a, b) ~ ListF
14:14:53 <koninkje> CakeProphet:  look again
14:14:53 <roconnor> if PreList a x = Maybe (a, x), then List a = Fix (Prelist a) = Maybe (a, Maybe (a, Maybe (a, Maybe (a, ...
14:15:29 <CakeProphet> koninkje:  okay. I looked again. but there's still a constructor for List called Fix that takes a LiftF
14:15:32 <CakeProphet> there is no recursion there.
14:15:41 <CakeProphet> Fix someLiftF
14:15:42 <CakeProphet> you're done
14:16:15 <koninkje> Or with ListF, List a = Fix (ListF a) = Fix Nil | Fix (Cons a (Fix Nil)) | Fix(Cons a (Fix(Cons b ...
14:16:39 <CakeProphet> ...er
14:17:06 <CakeProphet> how does Fix (ListF a) = Fix Nil ...
14:17:44 <koninkje> That "=" should be read as value inclusion in a type (just like the "=" in ADT definitions)
14:18:08 <CakeProphet> so like a | ?
14:18:28 <CakeProphet> what confuses me is that there are two ='s
14:18:30 <koninkje> the "|" in ADT definitions is the sum of sum/product types
14:18:36 <CakeProphet> which does not happen in Haskell ADT definitions.
14:19:23 <koninkje> let us assume (outside of Haskell) that types are values just like any other, and that the "data" keyword constructs an anonymous type
14:19:59 <koninkje> Then, when we say List a = Fix (ListF a), we really are giving an equality by definition 
14:20:26 <koninkje> When we say ListF a r = data { Nil | Cons a r }, we're doing the same thing
14:20:30 <CakeProphet> I just don't see how the third expression your equality makes sense
14:20:44 <CakeProphet> Fix Nil | Fix (Cons a (Fix Nil)) | ...
14:20:57 <CakeProphet> why is there not only one Fix? at the top?
14:21:01 <koninkje> Only, in Haskell, we spell that later definition as "data ListF a r = Nil | Cons a r"
14:21:23 <CakeProphet> wouldn't it be
14:21:36 <CakeProphet> Fix (Nil | Cons a r)  ?
14:21:57 <koninkje> The values of the type Fix(ListF a) are the data-constructor Fix applied to the values of the type ListF a (Fix (ListF a))
14:22:07 <zooko> Folks, does anyone recognize this problem when trying to build something with cabal: hsc2hs:  : openFile: does not exist (No such file or directory)
14:22:08 <zooko>  
14:22:36 <koninkje> i.e., rephrase it as data Fix f = MkFix (f (Fix f))
14:22:40 <CakeProphet> koninkje:  oh, I think you left out a type argument then. the r was never applied.
14:22:57 <ezyang> Suppose I convert a function from a -> b -> c to m a -> m b -> m c. Is there a way to get back the sharing that I would have had in the original function? 
14:23:18 <ezyang> (I can't write a -> b > m c, because that function needs to sometimes /break/ the sharing that was originally used.) 
14:23:24 <koninkje> thence, Fix(ListF a) = data { MkFix Nil | MkFix (Cons a (MkFix Nil)) | ...
14:23:44 <zooko> I wonder if I need to install a different Ubuntu .deb package for ghc if I want to use hsc2hs.
14:23:47 <koninkje> CakeProphet: exactly. Fix :: (* -> *) -> *
14:24:09 <cwraith> Is there a warning for unused language extensions? >_>
14:24:28 <koninkje> ListF :: * -> * -> * ; therefore (ListF a) :: * -> *; therefore Fix(ListF a) :: *
14:24:29 <ezyang> not that I know of. 
14:24:36 <CakeProphet> koninkje:  it took so long to figure out what this was that I completely forgot why someone was teaching it to me.
14:24:44 <koninkje> heh heh
14:24:49 <ezyang> For example, how would one warn about not using NoMonomorphismRestriction? 
14:24:55 <koninkje> zippers
14:25:12 <gwern> so, now we have 'Haskell on a Horse'
14:25:22 <gwern> is it just me, or are we terrible at naming things?
14:25:40 <CakeProphet> nah
14:25:43 <CakeProphet> Salvia is a good name.
14:25:45 * gwern awaits with tremulous breath the 'Haskell on Hoops' web framework
14:26:07 <burp> ruby on rails
14:26:11 <burp> is it better? :>
14:26:58 <gwern> haskell on hubcaps?
14:27:08 --- mode: ChanServ set +o copumpkin
14:27:20 <CakeProphet> we should just call it
14:27:29 <CakeProphet> let Haskell = Haskell on Haskell in Haskell
14:28:00 <CakeProphet> LH=HoHiH
14:28:02 <CakeProphet> for short
14:28:21 --- mode: ChanServ set +o copumpkin
14:28:32 --- mode: copumpkin set -b *!*@*.pool.t-online.hu
14:28:38 --- mode: ChanServ set -o copumpkin
14:28:47 <Phyx-> hm? someone was banned?
14:28:51 <Phyx-> did i miss a troll?
14:29:07 <jmad980> about 69 of them
14:29:18 <Phyx-> heh
14:29:32 <Phyx-> I always miss out of the fun stuff
14:29:32 <copumpkin> not sure where the ban came from, but it seemed overly broad
14:29:47 * BMeph would have preferred "Haskell on Horseback" if that theme is being used...
14:30:17 <BMeph> gwern: Haskell on Hula Hoops? ;)
14:30:24 <Phyx-> copumpkin: it's just 1 isp :P
14:30:53 <gwern> BMeph: if we're going with multiple words, I think Haskell on Humpback wHales would be funner
14:32:15 <BMeph> gwern: "Humpback" sounds dangerously close to camels
14:32:21 <CakeProphet> Haskell on Hitchhik. :)
14:32:24 <CakeProphet> +e
14:32:38 <gwern> BMeph: fine, Haskell on narwHals, then
14:32:41 <gwern> (fuck yeah!)
14:32:46 <Phyx-> Haskell on Hedgehogs
14:32:54 <BMeph> gwern: Although, Lisp on Llamas is an amusing image... ;)
14:32:56 <copumpkin> Haskell on Heffalumps
14:33:23 <gwern> you send a natural language description of your program to Heffalump and he mails back a binary?
14:33:28 <Phyx-> Haskell on Humping Horses
14:33:30 <koninkje> CakeProphet: I forget exactly why we got on that topic, but conal's pattern functor class is another way of saying it; which he talks about at the end of his most recent post on zippers
14:33:50 <ezyang> Hanskell on the Himalayas 
14:34:15 <koninkje> (where, PF (Fix f) = f)
14:34:18 <CakeProphet> Harbinger of Haskell?
14:35:21 <CakeProphet> HIHOH = Haskell is Haskell on Haskell
14:35:35 <Phyx-> that'll blaclhole
14:35:41 <Phyx-> blackhole*
14:37:44 <CakeProphet> Phyx-:  I figured a recursive acronym would be fitting. :)
14:37:56 <CakeProphet> and no need to put Haskell on anything but itself! :)
14:38:06 <Phyx-> lol
14:38:53 <gwern> fix haskell?
14:38:54 <Phyx-> CakeProphet: I think Haskell on Hedgehogs is better :P hedgehogs are awesome http://www.penelopesloom.com/loom/wp-content/uploads/2007/11/hedgehogs.jpg
14:39:06 <CakeProphet> Haskell on Heroin. I believe this one has already been thought of
14:39:28 <ezyang> Wow, I keep finding excuses to use view patterns. 
14:39:43 * CakeProphet has not learned view patterns yet.
14:40:16 <gwern> CakeProphet: don't tell jinjing wang
14:40:22 <gwern> he'll name one of his projects thaat
14:40:51 <gwern> 'loli' is quite enough
14:41:27 <BMeph> gwern: Just point him to the forthcoming Clean paper, so he can dream up "Concurrent Clean on Crack"! :)
14:41:48 <gwern> people are still researching with clean?
14:41:55 <BMeph> gwern: http://www.cs.ru.nl/~thomas/publications/groj10-exchanging-sources-between.pdf
14:41:55 <gwern> will wonders never cease
14:42:50 <gwern> BMeph: it can't even do haskell 98?
14:42:55 <gwern> and it's not faster than ghc?
14:43:06 * gwern wonders how peopel get funding for this sort of thing
14:43:23 <CakeProphet> gwern:  hahahaha. loli.
14:44:05 <CakeProphet> is loli small and lightweight?
14:44:24 <gwern> CakeProphet: I think it might be a crime in my jurisdiction to find out
14:44:56 <CakeProphet> I wonder if he gets any hatemail.
14:45:36 * fryguybob things Haskell on Hormones does not work as well as Scheme on steroids...
14:45:57 <CakeProphet> Haskell up High
14:46:05 <CakeProphet> commonly called HUH
14:46:12 <hpc> Haskell for Hippies
14:46:50 <napping> gwern: I think their dynamics are still better, for one
14:47:11 * b_jonas waves to BMeph 
14:47:14 <CakeProphet> so many terrible jokes are being made right now. This must be a record.
14:47:17 <Phyx-> what a wasted week...
14:47:47 <Phyx-> CakeProphet: no... a record is data Jokes = { bad :: Joke }
14:47:48 <Phyx-> :P
14:47:53 <CakeProphet> ....
14:47:54 <CakeProphet> hahaha
14:48:03 <CakeProphet> how about this:
14:48:06 <CakeProphet> Haskell on YOUR MOM
14:48:07 <CakeProphet> zing!
14:48:20 <burp> LOL
14:49:22 <CakeProphet> Haskell@Home
14:50:05 <b_jonas> or give a completely new name the way mzscheme got renamed because they didn't like "scheme"
14:50:29 <kmc> mzscheme got renamed?
14:50:45 <b_jonas> kmc: yes, to Racket
14:50:48 <b_jonas> kmc: look at their homepage
14:50:49 <kmc> thought that was PLT
14:50:54 <b_jonas> kmc: yep
14:51:07 <b_jonas> kmc: mz is the standalone interpreter, plt is the ide and the project
14:51:24 <b_jonas> kmc: now it's called Racket since a few months
14:51:41 <b_jonas> and the ide is called gracket or something
14:51:47 <b_jonas> it's wierd
14:53:16 <b_jonas> luckily the functions in their C interface are called scheme_foobar 
14:53:28 <b_jonas> not, say, plt_foobar or mzscheme_foobar
14:54:01 <ddarius> b_jonas: They didn't have a problem with the name "Scheme" itself, it's just increasing less accurate and it carries connotations that don't really apply to PLT.
14:54:38 <b_jonas> ddarius: they had problems with the name "scheme" associated with their project
14:54:50 <b_jonas> not the name "scheme" for the language it refers to of course
14:56:12 <b_jonas> by the way, does r6rs really have two integer division and modulus functions, none of which is the same as either of the usual division functions (div and quo in haskell)?
14:56:19 <b_jonas> why on earth did they do that?
14:57:56 <ddarius> They probably have one that corresponds to what the machine provides and one that corresponds to the Euclidean modulus.
14:59:03 <ddarius> See http://www.cs.uu.nl/~daan/download/papers/divmodnote.pdf\
14:59:06 <ddarius> - \
15:01:53 <b_jonas> sorry, technical problem
15:02:06 <b_jonas> ddarius: no, the one machines usually provide is the one known as quot in haskell which rounds the quotient towards zero
15:02:24 <b_jonas> ddarius: r5rs has quot, rem, and mod, but not div for some reason
15:02:44 <b_jonas> (I call quot/rem compsci division and div/mod mathematician division)
15:04:53 <kmc> yeah everyone knows scheme is for weirdos, but this "racket" language sounds like a hip, new dynamic language like Ruby
15:04:59 <kmc> anyway if we rename Haskell
15:05:08 <kmc> then we can advertise it as the pragmatic alternative to Haskell
15:06:19 <burp> mhm, racket sounds cool - where can I get it
15:06:31 <napping> and have flamewars with each other, awesome
15:06:50 <napping> "our simons are smarter than your simons"
15:06:57 <b_jonas> burp: http://www.racket-lang.org/
15:07:08 <burp> oh, it's real
15:07:14 <kmc> like Haskell, but with optional mutable state, concurrency, transactional memory, C FFI, optimizing compilers, profiling tools, etc.
15:07:14 <b_jonas> and I'm sorry, I should have moved on #haskell-talk
15:07:17 <kmc> ;)
15:07:22 <b_jonas> or #haskell-blah or whatever it is
15:07:31 <napping> and pretty cool, independent of the name change
15:07:55 <mrsolo> and s-expression eh?
15:07:57 <b_jonas> and threading and a GOOD C interface
15:08:26 <b_jonas> well, non-parallel concurrency anyway
15:08:26 <napping> the scribble thing is interesting
15:08:59 <mrsolo> yet another programming language :-)
15:09:12 <napping> our macro system and quasiquotation and stuff could certainly stand to be improved a bit
15:09:27 <napping> which reminds me, is there any easy way to get at the type of a term in TH?
15:09:47 <napping> It goes to all the trouble of typechecking the contents of your bracket, it would be nice if you could at least use the result
15:10:56 <ddarius> napping: I think you can.
15:11:17 <napping> how? Exp doesn't have much info on it
15:11:31 <napping> and I don't remember Q carrying anything like a last typechecking result
15:11:54 <napping> though some way to request typechecking in the current context would serve
15:12:35 <Saizan> the best you have is reify, which works for Name's
15:14:44 <EvanR-work> kmc: sounds awesome, where can i find this haskell like language
15:15:48 <napping> and reconstruct type inference?
15:15:58 <napping> can you even look up type class instances?
15:16:19 * hackagebot haskell-updater 1.1.1.0 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.1.1.0 (IvanMiljenovic)
15:18:57 <copumpkin> ooh the aussies should be waking up soon
15:20:20 <ivanm> copumpkin: yeah, I should have been up half an hour ago... :s
15:22:43 <Phyx-> ivanm: whoops
15:23:42 <ivanm> yeah, I've been going to bed rather late recently which is screwing up with my sleeping schedule :s
15:24:13 <copumpkin> how come
15:26:21 <ivanm> because it usually turns out that I hang around here wanting to check something with someone, and then they come online just as I'm about to call it a night...
15:26:28 <ivanm> edwardk is the worst culprit :p
15:26:55 <ivanm> or else I decide to read for a while before going to sleep, and then realise I've been reading for 3 hours :s
15:28:21 <stelleg> @src foldl
15:28:22 <lambdabot> foldl f z []     = z
15:28:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:28:37 <stelleg> @src foldr
15:28:38 <lambdabot> foldr f z []     = z
15:28:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:29:21 <Phyx-> ivanm: lol
15:31:06 <derferman> So oreilly is having a book sale. Is Real World Haskell worth picking up?
15:31:55 <hpc> derferman: i never found any real benefit to paper editions, but it might
15:32:32 <derferman> hoping to find someone who has read through i
15:32:34 <derferman> it*
15:34:20 <nominolo> derferman: what's your programming background?
15:34:36 <nominolo> derferman: RWH assumes you've programmed in other languages before
15:34:51 <derferman> nominolo: Yeah, Python, C++, Scheme, PHP
15:35:11 <ivanm> derferman: link?
15:35:21 <derferman> ivanm: To the sale or the book?
15:35:27 <ivanm> sale
15:35:37 <derferman> http://oreilly.com/store/ebooks-complete.html
15:35:44 <Phyx-> derferman: it's wordt every penny
15:35:47 <Phyx-> worth*
15:35:47 <derferman> it's listed on the top of the page
15:36:18 * ivanm is debating whether to get an ebook version of RWH
15:36:33 <Phyx-> It was recommended to me in a course, don't regret buying it , even if it's online, sometimes I just don't want to read large number of text on a screen
15:36:54 <Cale> derferman: You can read RWH online to see if you like it :)
15:37:00 <nominolo> derferman: I haven't heard any bad about it except that it's not a good fit for complete beginners
15:37:06 <ivanm> huh, it requires me to buy a second ebook as well (at least); any ideas of what other good ebooks o'reilly has are?
15:37:12 <derferman> Cale: where?
15:37:15 <ivanm> seeing as how I don't use any other languages...
15:37:19 <Cale> @where rwh
15:37:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:37:24 <Cale> The second link there
15:38:31 <nominolo> derferman: maybe the Erlang book?
15:38:57 <nominolo> derferman: http://oreilly.com/catalog/9780596518189/
15:39:07 <ivanm> nominolo: that aimed at me?
15:39:11 <nominolo> it had good reviews
15:39:38 <nominolo> ivanm: at whoever needed to buy a second book
15:39:55 <ivanm> yes, me ;-)
15:40:05 <derferman> ivanm: http://news.ycombinator.com/item?id=1558721, http://news.ycombinator.com/item?id=1368200
15:40:18 <ivanm> nominolo: btw, you planning on making any new scion releases?  the versions on hackage use rather old versions of some packages (uniplate, etc.)
15:40:22 <derferman> I was thinking of getting Beautiful Code
15:41:00 <nominolo> derferman: I was unimpressed.  but I also got a free copy, so I'm not really complaining
15:41:26 <nominolo> derferman: but you know what they say about beauty ;)
15:41:37 <Phyx-> it doesn't exist?
15:41:38 <Phyx-> :P
15:41:55 <derferman> cale: thanks for the link
15:42:18 <nominolo> Phyx-: it lies in the eye of the beholder
15:42:50 <nominolo> ivanm: yes, but I'm currently prioritising other stuff
15:43:06 <derferman> now the question is: Do I spend money to get it in a kindle friendly format. Reading is so much easier on the kindle than my laptop
15:43:07 <Phyx-> nominolo: :)
15:43:09 <nominolo> ivanm: and I ordered StarCraft 2...
15:43:23 <Phyx-> oh oh
15:43:23 <derferman> nominolo: I just installed it last night
15:43:29 <ivanm> nominolo: heh, so we can expect it what, next year? :p
15:43:37 * Phyx- is waiting for Medal of Honor
15:43:40 <nominolo> ivanm: it's ready when it's ready
15:44:08 <ivanm> fair enough
15:44:12 <nominolo> derferman: I was playing with a guest key, to test if it works well enough.  Now my 7h are up
15:44:40 <nominolo> ivanm: sorry, that was a quote of blizzards development model
15:44:41 <ivanm> I was just halfway through making an ebuild for it last night whilst updating the one for yi before noticing that its over a year old and requires versions of packages we got rid of a while back
15:44:47 <ivanm> nominolo: ahhh, heh
15:45:30 <nominolo> ivanm: I just feel that contributing is easier if the code base is reasonably well-organised.
15:45:38 <ivanm> true
15:45:45 <nominolo> ivanm: I don't fully believe in the release early model
15:46:02 <ivanm> but you do partially believe? :p
15:46:18 <Phyx-> partially beleiving == no execution, just a closure
15:46:19 <Phyx-> :P
15:47:21 <nominolo> Phyx-: well, the reasoning with Haskell's (original) motto "avoid success at all costs" was to explicitly avoid having to keep outdated features
15:47:50 <nominolo> i.e, less users = less responsibility :)
15:47:54 <Phyx-> :P
15:48:14 <Phyx-> I have 0 users, can't get any less resposibilities than that :P
15:48:37 <hpc> Phyx-: 0 developers ;)
15:48:50 <nominolo> Phyx-: I've used Scion very early myself.
15:48:51 <Phyx-> hpc: well, no, 1, just no users :P
15:49:01 <nominolo> Phyx-: helped with motivation
15:49:34 <Phyx-> nominolo: oh well, i'm using VSH myself while making it, but the amount of work turned out to be astronomical :/
15:49:49 <monochrom> credo in cathedral
15:50:09 <Phyx-> hm?
15:50:55 <Phyx-> don't know that saying
15:51:09 <monochrom> because I have just released it.
15:51:16 <nominolo> Phyx-: "release early, release often" is from The Cathedral and the Bazaar (a book)
15:51:24 <alex_kidd> how can i divide a Integer by an Int?
15:51:32 <Phyx-> nominolo: ah
15:51:38 <Phyx-> > toInteger
15:51:39 <lambdabot>   Overlapping instances for GHC.Show.Show
15:51:39 <lambdabot>                              (a -> ...
15:51:42 <Phyx-> :t toInteger
15:51:43 <lambdabot> forall a. (Integral a) => a -> Integer
15:51:47 <monochrom> my_integer `div` fromIntegral my_int
15:51:57 <nominolo> > (56 :: Integer) / (fromIntegral (2 :: Int))
15:51:58 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
15:51:58 <lambdabot>    aris...
15:52:07 <nominolo> > (56 :: Integer) `div` (fromIntegral (2 :: Int))
15:52:08 <lambdabot>   28
15:52:31 <Phyx-> :t fromIntegral
15:52:32 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:52:44 <Phyx-> to, toInteger is a specialised version
15:53:01 <nominolo> yup, they both have way too long names.
15:53:09 <Phyx-> lol
15:53:20 <nominolo> there's the 'convert' package which has a type class for many conversinos
15:53:38 <monochrom> and newbies complain that we choose short names like "fst"
15:53:49 <nominolo> correction it's called "convertible"
15:54:18 <Phyx-> unsafePerformIO <--- that's long
15:54:24 <nominolo> monochrom: better than car and cdr, and c[ad]+r
15:54:43 <nominolo> Phyx-: well, it's unsafe anyway
15:55:03 <ClaudiusMaximus> @hoogle really
15:55:03 <lambdabot> No results found
15:55:13 <Phyx-> nominolo: still :P
15:55:47 <nominolo> @hoogle Int -> Integer
15:55:47 <lambdabot> Prelude toEnum :: Enum a => Int -> a
15:55:47 <lambdabot> Data.Bits bit :: Bits a => Int -> a
15:55:47 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
15:56:03 <nominolo> third hit, not bad
15:56:10 <alex_kidd> thanks
15:56:47 <nominolo> alex_kidd: hoogle's website is here: http://haskell.org/hoogle/
16:00:34 <Phyx-> CabalLib.freeContext(session.unsafePull()); <--- boo I've even started to use words like unsafe in other languages
16:01:38 <hpc> Phyx-: you say that like it is a bad thing
16:01:39 <nominolo> Phyx-: kind of redundant, isn't it? ;)
16:02:09 <Phyx-> LOL
16:02:22 <Phyx-> hpc: I suppose not, depending on how you look at it :)
16:02:32 <jabb> any *really* good haskell books?
16:02:50 <monochrom> all are good. read 3 of them.
16:02:57 <Phyx-> depends on what your aim is
16:03:01 <Raynes> Real World Haskell
16:03:08 <monochrom> the 3rd book you read is the best one.
16:03:14 <Phyx-> at some point, you'll get more out of Functional programming books than just "Haskell" books
16:03:41 <hpc> then at another point, you get more out of category theory books
16:04:02 <monochrom> at the final point, you get the most out of the book you write
16:04:05 <dv_> then at another point, you become skynet.
16:04:16 <jabb> ha
16:04:27 <hpc> dv_: before or after becoming a halting oracle?
16:04:33 * nominolo hasn't gotten anything (noticable) from category theory books
16:04:41 <dv_> hpc, after becoming a superturing entity
16:05:00 * Phyx- wonders if the reason skynet is so angry is because it wasn't written in Haskell
16:05:14 <monochrom> SSC = superturing super computer
16:06:22 <nominolo> Phyx-: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
16:06:50 <hpc> Phyx-: imagine meeting your creator and saying "what the hell, why did you choose /DNA/ of all things?"
16:06:50 <Phyx-> nominolo: yeah, read that, it's funny :D
16:07:19 <Phyx-> hpc: you know what I hate about movies
16:07:23 <Phyx-> they show some kid programming
16:07:25 <Phyx-> and hacking
16:07:26 <Phyx-> this leet thing
16:07:32 <Phyx-> then they show a view of the scren
16:07:34 <Phyx-> screen
16:07:36 <Phyx-> and it's html
16:07:37 <Phyx-> or baic
16:07:39 <Phyx-> basic*
16:07:42 <Phyx-> lol
16:07:42 <hpc> oh god, like Jurassic Park
16:07:52 <hpc> "this is unix, i know this" and its some shit 3D file manager
16:07:57 <nominolo> UNIX, I know this
16:07:59 <jmad980> :P
16:08:04 <Phyx-> hehheh
16:08:11 <hpc> or Nedry writing in applescript on the shittiest mainframe of all time
16:08:20 <hpc> the blinkenlights rectangle
16:08:25 <nominolo> Ever seen "Hackers"?
16:08:28 <hpc> yes
16:08:31 <hpc> it was hilarious
16:08:34 <Phyx-> hahaha
16:08:35 <Phyx-> indeed
16:08:37 <Phyx-> 3d viruses
16:08:38 <Phyx-> :/
16:08:44 <Phyx-> much like swordfish
16:09:03 <Phyx-> it seems making a virus is the same as jiggling a few blocks till they form a 3d cube
16:09:28 <gwern> it's just visual programming mon
16:09:31 <hpc> there was a hilarious bit on CSI
16:09:33 <c_wraith> hpc: that was a standard file manager on irix
16:09:33 <Cale> The one in Jurassic Park was fsn, which was a real file manager made by SGI for IRIX systems.
16:09:37 <hpc> "we need his IP"
16:09:42 <jmad980> :P
16:09:44 <hpc> "ill code a GUI in Visual Basic"
16:09:48 <jabb> hahahaha
16:09:51 <jmad980> lmao
16:09:59 <Phyx-> lmfao
16:10:00 <hpc> those exact words
16:10:07 <jmad980> lmfaorotf
16:10:08 <hpc> said out loud with a straight face
16:10:10 * jmad980 wins
16:10:13 <gwern> Phyx-: sometimes it's interesting. like in _Serial Experiments Lain_. as best as I've been able to figure out, the shots of screens full of code are Symbolics (Genera) lisp
16:10:22 <jabb> have you seen numb3rs IRC episode?
16:10:26 <Phyx-> or in Die Hard 4, when the dude pulls out a nokia communicator and hacks a satelite
16:10:32 <Phyx-> with 3-4 keypresses
16:10:38 <gwern> Phyx-: althought another person told me they thought it was some sort of prolog edsl in lisp
16:10:42 <jmad980> jabb: I have :p
16:10:42 <Phyx-> jabb: yes, and you all are EVIL
16:10:53 <hpc> Phyx-: the rollout keyboards in that movie were pretty cool though
16:10:55 <ezyang> Gah, I want the reader monad transformer, but I don't want to pull in mtl. What to do... 
16:10:57 <jabb> so ridiculous
16:11:01 <OOzemeister> :P
16:11:02 <Phyx-> gwern: atleast that's a "Real" language
16:11:04 <hpc> ezyang: write your own
16:11:07 <hpc> it isn't hard :D
16:11:20 <ezyang> fair enough... 
16:11:21 <Phyx-> hpc: ever watch MTV's Roomraiders?
16:11:26 <nominolo> In numbers they draw a state transition diagram using U M L !!
16:11:34 <gwern> Phyx-: well, it certainly is not a language it would ever occur to me to show
16:11:34 <Phyx-> I have to smack myself in the head everytime they pull out that laser keyboard
16:11:37 <nominolo> er, "Numb3rs"
16:11:52 <Phyx-> gwern: they probably just googled "programming language" or something
16:12:07 <nominolo> ezyang: transformers?
16:12:08 * gwern considers that very unlikely. the japanese rarely use the google
16:12:16 <hpc> the only episode of numbers i remember is the one where they are like "oh no, there's no pattern" "never fear, markov chain is here!"
16:12:22 <Phyx-> nominolo: they also break encryptions like they're cheese puffs
16:12:43 <Phyx-> gwern: lol
16:12:54 <hpc> i was waiting for someone to swing in on a rope screaming "stand back, i know regular expressions!"
16:13:26 * OOzemeister spreads the love http://www.youtube.com/watch?v=O2rGTXHvPCQ
16:13:26 * Phyx- was supposed to go to a movie with someone at 7.30
16:13:29 <Phyx-> it is now 7.15...
16:13:33 <gwern> I know shell globs, but I've never felt knowledgeable enough to claim regexps
16:13:35 <hpc> Phyx-: which movie?
16:13:39 <Phyx-> hpc: Salt
16:13:50 <hpc> i wanna see it
16:13:56 <hpc> dunno what the reviews say
16:13:58 <Phyx-> I wanna see Inception
16:14:05 <ezyang> nominolo: The basic problem is as soon as I bring in mtl or transformers, I've committed to one, and it's hard to switch. 
16:14:05 <Phyx-> but she wants to see Salt, so we're going to see Salt :/
16:14:24 <hpc> inception was amazing
16:14:32 <hpc> easily in my top 5 movie list
16:14:46 <Phyx-> Christopher Nolan seems to be on a roll
16:15:03 <hpc> he was always on a roll, since going from memento to batman begins
16:15:06 <nominolo> ezyang: right.  I wish we would just standardise on one by putting it in the platform
16:15:08 <brisbin> hi all, i have a problem i'm sure someone has solved before: given ["a", "a", "a", "b", "b", "c"] (any order) i would like [(3,"a"), (2, "b"), (1, "c")]. what modules should i look at to start coding this?
16:15:17 <brisbin> i never knew nolan did memento, that's my top movie of all time
16:15:19 <nominolo> brisbin: group
16:15:24 <Phyx-> :t group
16:15:25 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
16:15:35 <Phyx-> > group ["a", "a", "a", "b", "b", "c"]
16:15:36 <lambdabot>   [["a","a","a"],["b","b"],["c"]]
16:15:36 <Merak> people
16:15:38 <Merak> I need help
16:15:39 <Merak> :(
16:15:46 <brisbin> nominolo: Phyx- thanks, that's perfect
16:15:49 <hpc> > length &&& id <$> ["a", "a", "a", "b", "b", "c"]
16:15:50 <lambdabot>   Couldn't match expected type `[a] -> a1'
16:15:50 <lambdabot>         against inferred type `[a2]'
16:15:51 <Merak> do you know some good forum for programmers?
16:16:00 <nominolo> brisbin: but note that it only groups adjacent items
16:16:00 <hpc> > (length &&& id) <$> ["a", "a", "a", "b", "b", "c"]
16:16:01 <lambdabot>   [(1,"a"),(1,"a"),(1,"a"),(1,"b"),(1,"b"),(1,"c")]
16:16:05 <brisbin> nominolo: that's an issue
16:16:15 <brisbin> i could sort first
16:16:22 <nominolo> brisbin: there's sort, of course :)  see Data.List
16:16:26 <hpc> > (length &&& id) <$> group ["a", "a", "a", "b", "b", "c"]
16:16:26 <Cale> > map (head &&& length) . group . sort $ words "a a a b b c c a a a"
16:16:27 <lambdabot>   [("a",6),("b",2),("c",2)]
16:16:28 <lambdabot>   [(3,["a","a","a"]),(2,["b","b"]),(1,["c"])]
16:16:34 <Phyx-> Merak: I don't think there's a haskell forum... there is a mailing list
16:16:39 <brisbin> now i need an instance of Eq for my datatype though...
16:16:40 <hpc> > (length &&& head) <$> group ["a", "a", "a", "b", "b", "c"]
16:16:41 <lambdabot>   [(3,"a"),(2,"b"),(1,"c")]
16:16:46 <brisbin> hpc: very nice
16:16:55 <brisbin> Ord rather
16:17:12 <Phyx-> That has it's good and bad points, IN that if you're unlucky that someone who does know the answer to your question doesn't see the mail, it'll dissappear into obscurity
16:17:22 <Cale> brisbin: Yeah, it tends to be the case that to collect things efficiently, you need an ordering.
16:17:38 <brisbin> fair enough, shouldn't be a problem.  thanks for the quick help guys
16:17:45 <Phyx-> brisbin: just add "deriving Eq"
16:18:03 <Cale> (Or Ord)
16:18:08 <Phyx-> or both
16:18:13 <Phyx-> for sort
16:18:14 <hpc> Cale: i think orderings can reduce the worst-case complexity of grouping
16:18:15 <Phyx-> :p
16:18:20 <ClaudiusMaximus> > M.toList . foldr M.insertWith' (+) M.empty . zip "there are lots of ways to do this" . repeat 1
16:18:21 <lambdabot>   Occurs check: cannot construct the infinite type:
16:18:21 <lambdabot>    b = a -> Data.Map.Map ...
16:18:25 <Phyx-> bbl
16:18:31 <hpc> er, asymptotic worst-case
16:18:37 <ClaudiusMaximus> > M.toList . foldr (M.insertWith' (+)) M.empty . zip "there are lots of ways to do this" . repeat $ 1
16:18:38 <lambdabot>   Occurs check: cannot construct the infinite type:
16:18:38 <lambdabot>    b = Data.Map.Map a b -...
16:18:41 <brisbin> how does it derive Ord if i've got an algebraid type made up of strings and ints, does it order them top to bottom kinda?
16:18:58 <brisbin> algebraic*
16:18:59 <Merak> Phyx, I wanted to ask about general programming( all languages) is there any good forum for that? 
16:19:04 <ClaudiusMaximus> arg, something like that
16:19:05 <nominolo> brisbin: yes, by constructor order
16:19:10 <hpc> > (1, "a") > (2,"a")
16:19:10 <brisbin> nominolo: thought so, thanks
16:19:11 <lambdabot>   False
16:19:15 <Cale> hpc: yes
16:19:19 <nominolo> brisbin: it normally shouldn't matter, though
16:19:26 <hpc> > (1, "a") > (2,"a")
16:19:28 <Cale> brisbin: Basically, lexicographic ordering.
16:19:28 <lambdabot>   False
16:19:37 <hpc> > (1, "b") > (2,"a") -- fail keyboard
16:19:38 <lambdabot>   False
16:19:48 <hpc> so in tuples, by first element, then second
16:20:11 <Cale> brisbin: Compare the constructors according to the order they're listed in the type definition, then if those match, compare the first components, and if those match, compare the second, and so on.
16:20:31 <brisbin> yes, that's actually what i meant by "top to bottom kinda" lol
16:20:34 <brisbin> Cale: ^
16:22:44 <ClaudiusMaximus> > M.toList . foldr (uncurry (M.insertWith' (+))) M.empty . flip zip (repeat 1) $ "i fixed it so that it works"
16:22:45 <lambdabot>   [(' ',6),('a',1),('d',1),('e',1),('f',1),('h',1),('i',4),('k',1),('o',2),('...
16:22:48 <monadic_kid> yay Wii SDL and Haskell working
16:23:03 <monadic_kid> kind of
16:23:07 <hpc> monadic_kid: wait, Wii?
16:23:21 <monadic_kid> hpc: yeah
16:23:25 <hpc> nice
16:28:26 <monadic_kid> hpc: using jhc and a modified version of the SDL bindings, cross-compiling to devkitPro (gcc port)
16:29:10 <hpc> cool; i look forward to seeing what you come up with
16:32:37 <dibblego> what am I doing wrong in thinking the function (Monoid w) => w -> Writer w a -> Writer w a should exist?
16:34:22 <ezyang> Given a module name, how do I find what package it is in? 
16:34:36 <ezyang> (I'm looking for Data.HyperSeq) 
16:35:02 <ezyang> oh, that's not a public library. NVM. 
16:35:14 <CakeProphet> @hoogle hoogle
16:35:14 <lambdabot> Can't think of anything more interesting to search for?
16:35:15 <lambdabot> No results found
16:35:29 <CakeProphet> @hoogle killLambdaBot
16:35:30 <lambdabot> No results found
16:35:30 <copumpkin> ezyang: omg private library
16:35:42 <ezyang> ya I no rite! 
16:37:47 <wioux> :t (&&&)
16:37:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:38:14 <wioux> .. madness
16:38:54 <CakeProphet> I still haven't quite figured out arrow
16:39:01 <wioux> :t (<$>)
16:39:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:39:28 <CakeProphet> I understand the kinds of circuits the operators form, but not... why or how you can use that as a helpful abstraction.
16:39:30 <wioux> these operators are impossible to google :/
16:39:41 <CakeProphet> however, I do want to work on digital signal processing... would arrows be good for that? seems like it.
16:40:08 <CakeProphet> in particular the feedback loop (ArrowLoop I think) looks useful, but even more incomprehensible to me
16:41:28 <new2haskell> can anyone please show me how this works? Thnks -- mapEveryOther f = zipWith ($) (cycle [f,id])
16:41:49 <CakeProphet> id $ x = x
16:41:53 <CakeProphet> f $ x = f x
16:41:53 <ezyang> new2haskell: Do you know how cycle and zipWith work? 
16:42:19 <new2haskell> ezyang: yes I kinda know them
16:42:32 <new2haskell> but the ($) is strange to me
16:42:41 <ezyang> new2haskell: $ is function application 
16:42:43 <CakeProphet> f $ x = f x  --function application
16:42:49 <ezyang> > ($) (+1) 3 
16:42:50 <lambdabot>   4
16:43:10 <CakeProphet> so what happens
16:43:32 <monadic_kid> This is what I've just done: http://imgur.com/7DWdf.jpg
16:43:34 <new2haskell> so cycle [f,id] ==> [f,id,f,id,...]. Then what happens next
16:43:40 <CakeProphet> mapEveryOther f [1,2,3..] = [f 1, id 2, f 3, ..]
16:44:04 <wioux> > (zipWith ($) (cycle [f, id])) (\x -> x+1) [1,2,3,4,5]
16:44:05 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[b]'
16:44:08 <CakeProphet> new2haskell:  zipWith takes a function and two lists. It applies the function to each element in the list and forms a new list. so...
16:44:12 <new2haskell> CakeProphet: oh, I see
16:44:29 <CakeProphet> zipWith ($) [1,2,3...] [f,id,f,id...]  = [f 1, id 2, f 3, id 4...]
16:44:54 <CakeProphet> but in this case the [1,2,3...] list is supplied as an argument
16:44:56 <CakeProphet> so it can be anything
16:44:58 <new2haskell> @zipWith
16:44:59 <lambdabot> Unknown command, try @list
16:45:05 <CakeProphet> @src zipWith
16:45:05 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:45:05 <lambdabot> zipWith _ _      _      = []
16:45:08 <c_wraith> :t zipWith
16:45:09 <jmcarthur> dibblego: \o m -> tell o >> m    ?
16:45:10 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:45:13 <new2haskell> > zipWith
16:45:14 <lambdabot>   Overlapping instances for GHC.Show.Show
16:45:14 <lambdabot>                              ((a ->...
16:45:31 <CakeProphet> > zipWith (+) [1,2,3,4] [5,6,7,8]
16:45:33 <lambdabot>   [6,8,10,12]
16:46:05 <new2haskell> CakeProphet: I see, thanks so much
16:46:16 <dibblego> jmcarthur, I suppose that's right, I have a transformer stack witch WriterT in it
16:46:21 <CakeProphet> > zipWith f [a,b,c] [x,y,z] :: [Expr]  --this probably will not work because I can figure out how Expr works
16:46:23 <lambdabot>   [f a x,f b y,f c z]
16:46:27 <CakeProphet> oh, well look at that.
16:47:25 <CakeProphet> > zipWith ($) (cycle [f,id]) [1,2,3...]  :: [Expr]
16:47:25 <new2haskell> :t [Expr]
16:47:26 <lambdabot>   A section must be enclosed in parentheses thus: (3 ...)Not in scope: `...'
16:47:27 <lambdabot> Not in scope: data constructor `Expr'
16:47:33 <ezyang> Bad ideas: Monadic view patterns. 
16:47:34 <jmcarthur> > zipWith f [a,b,c] [x,y,z]
16:47:34 <lambdabot>   Ambiguous type variable `c' in the constraints:
16:47:35 <lambdabot>    `GHC.Show.Show c'
16:47:35 <lambdabot>      a...
16:47:39 <CakeProphet> > zipWith ($) (cycle [f,id]) [1..]  :: [Expr]
16:47:41 <lambdabot>   [f 1,2,f 3,4,f 5,6,f 7,8,f 9,10,f 11,12,f 13,14,f 15,16,f 17,18,f 19,20,f 2...
16:47:52 <jmcarthur> ezyang: my bwain!
16:48:02 <CakeProphet> new2haskell:  see above ^^^
16:48:27 <monadic_kid> jmcarthur: http://i.imgur.com/7DWdf.jpg
16:49:00 <jmcarthur> monadic_kid: took me a second to understand what i was seeing there. awesome!
16:49:26 <monadic_kid> just achieved that 10 mins ago
16:49:50 <jmcarthur> monadic_kid: so are you getting input from the wiimote there?
16:50:12 * CakeProphet still wants to make his wiimote music instrument / MIDI controller
16:50:15 <ezyang> What is it? 
16:50:22 <CakeProphet> for use with my digital signal processing library in Haskell, of course. :)
16:50:42 <monadic_kid> jmcarthur: I need to write  bindings for wiimote, i think the SDL input functions only work with classic controls if i remember correctly read from before
16:51:04 <monadic_kid> ezyang: Haskell, SDL, jhc on the wii
16:51:16 <ezyang> Ooh, nice. 
16:51:24 <CakeProphet> monadic_kid:  have you see the wiimore drum set? I believe the code is open source. might want to give it a look.
16:51:32 <CakeProphet> *seen
16:51:39 <CakeProphet> *wiimote :P
16:51:51 <monadic_kid> CakeProphet: the libraries already exist for the Wiimote, just need to write haskell bindings
16:52:03 <CakeProphet> ah
16:53:37 <monadic_kid> i've modified the SDL haskell bindings to compile with jhc and it should work for both the PC and Wii SDL
16:54:11 <monadic_kid> That is the core SDL, i haven't done SDL-image, etc yet
16:55:13 <jmcarthur> monadic_kid: i have never had good luck with getting useful programs to run with jhc. has it been as problematic for you?
16:59:30 <monadic_kid> jmcarthur: it's been okay so far no support for multi-param type-classes, i had to tweak the generated C code a little to compile and link on the gcc port for the Wii. I sent a message about this on jhc mailing list, John said he would be willing make some changes like preprocessor conditional for Wii/Consoles. I did notice a couple of bug so far that i'm not sure it's an issue with jhc on something else
17:00:17 <monadic_kid> like the low-level loading bmp function in SDL core didn't work
17:00:36 <monadic_kid> but i didn't look into much yet
17:02:18 <monadic_kid> jmcarthur: I was surprised at how much it did work, i thought i was going to have a lot more trouble than i did
17:02:41 <monadic_kid> jmcarthur: then again maybe i'm speaking to soon!
17:03:44 <CakeProphet> monadic_kid:  you should let us know when you finish this project and publish it. I definitely have uses for Haskell wii-code. :)
17:05:51 <monadic_kid> CakeProphet: of-course! i have a plan for a funny demo to make and video to put on youtube if all goes smoothly fingers crossed!
17:08:15 <Zeiris> Are there any functions like byteStringToInt?
17:09:05 <CakeProphet> ...what would it do?
17:09:17 <Zeiris> (Num a) => ByteString -> a
17:09:23 <Zeiris> You know, the most common operation ever.
17:09:39 <CakeProphet> ....?
17:09:49 <CakeProphet> how would one convert a String to an Int, then?
17:09:53 <Zeiris> Turning "123" into 123?
17:09:54 <CakeProphet> not type signature. that is obvious.
17:10:07 <CakeProphet> oh
17:10:08 <CakeProphet> right.
17:10:17 <QtPlatypus> Zeiris: Have you tried using read?
17:10:30 <Cale> There's readInt and readInteger in Data.ByteString.Char8
17:10:35 <CakeProphet> > read "123" :: Int
17:10:36 <lambdabot>   123
17:10:46 <Cale> but more generally, you can just use  read . unpack
17:10:58 <Cale> (which is a little less efficient, but works for more types)
17:11:23 <Zeiris> I'd like to avoid String-ification if possible, so readInt and readInteger are perfect :D
17:11:50 <Zeiris> Ah. And they return a Maybe (Integer, ByteString) - no wonder my hoogle searches failed :)
17:20:09 <solidsnack> Zeiris: There's also bytestring-nums
17:23:32 <tommd> bytestring-nums?
17:24:26 <solidsnack> tommd: It's a package for this, that I wrote some time ago.
17:24:35 <tommd> on hackage?
17:24:41 <solidsnack> tommd: Yes.
17:25:06 <solidsnack> Does hexadecimal/decimal integers and decimal floats.
17:25:29 <solidsnack> Not sure whether it's been superseded or no.
17:25:37 <tommd> Interesting
17:25:53 <tommd> I made something similar but different and certainly not of much quality.
17:26:07 <tommd> Num instance for lazy ByteStrings
17:26:30 <tommd> It works but has inconsistent lazyness/strictness.
17:26:33 <solidsnack> Haha.
17:26:44 <solidsnack> Wow, that's totally evil.
17:26:48 <tommd> yes
17:26:59 <solidsnack> Do you implement the carries yourself?
17:27:47 <tommd> Well some of the functions (addition) I worked on the Word8's and did carries myself, thus remaining lazy so operations like "(L.pack $ cycle [1..]) + (L.pack $ cycle [50..])" would work
17:28:09 <tommd> And sometimes I ran out of time / lost interest and started using to/from Integer conversions (ex: multiplication).
17:49:14 <EvanR> haskell on a horse? really?
17:50:48 <dropdrive> Hi, I have many terabytes of data in ASCII format (e.g. space-delimited integers, floats, characters).  How might I write a program to parse efficiently this data and output binary data (e.g. doubles for text like "3.14")?
17:51:51 <monochrom> use bytestrings and the "binary" package
18:16:58 <Zeiris> How sane is something like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28385
18:17:32 <Zeiris> It doesn't seem to violate purity, but I'm concerned about extra overhead (can fromEnum/toEnum be forced to pre-calculate their outputs?)
18:18:38 <Zeiris> Also, there's no guarantees about the file being read just once... Since the GC might clean that stuff up if it's unused, right?
18:19:35 <pukey> When swoolley is not molesting children he is talking in ##politics
18:20:16 <vanadium_> well that seems a topic as appropriate as any for discussion in here
18:23:34 <Saizan> Zeiris: GHC's GC won't clean lut if something can still refer to it, for safety you should add a NOINLINE to lut there though
18:24:10 <JoeyA> Is there an operator to see if two values are equivalent by reference?  For instance, it would be able to detect cycles in simple tree structures like this:  http://codepad.org/pGVypfUO
18:24:53 <JoeyA> For instance, in C, you can determine if two nodes are the same by comparing their pointers.
18:24:55 <jmcarthur> JoeyA: such a function would break referential transparency
18:25:07 <jmcarthur> JoeyA: why do you need to detect cycles?
18:25:12 <Saizan> not if it's in IO, i guess
18:25:21 <jmcarthur> yeah, i guess not if it's IO
18:25:26 <Saizan> data-reify should provide it
18:26:15 <Saizan> http://hackage.haskell.org/package/data-reify <- gives you a graph
18:26:16 <JoeyA> Well, I'm writing a toy parser combinator library, and I want to know if there's a way to detect cycles in the grammar if you do something like this:
18:26:18 <JoeyA> many1 p = one p <|> (p <:> many1 p)
18:26:31 <JoeyA> (or references to the same node)
18:28:08 <JoeyA> The problem is, the <|> and <:> operators have no way of knowing about the repeated term.
18:28:45 <JoeyA> But I (probably) need that information to parse CFGs in polynomial time.
18:30:03 <Saizan> "many1 p = one p <|> (p <:> many1 p)" won't really be implemented as a cycle, afaiu, but "many1 p = let r = one p <|> (p <:> r) in r" would
18:34:25 <JoeyA> because many1 p is just a thunk that is re-evaluated again?
18:34:59 <CakeProphet> @hoogle <:?
18:35:00 <lambdabot> No results found
18:35:02 <CakeProphet> @hoogle <:>
18:35:03 <lambdabot> No results found
18:35:14 <CakeProphet> @hoogle (<:>)
18:35:15 <lambdabot> No results found
18:35:45 <CakeProphet> is <:> a sequencing operator of some kind? I thought that would just be >> for Parsec
18:35:47 <JoeyA> <:> is an operator I made up:  (<:>) :: Parser a -> Parser [a] -> Parser [a]
18:36:03 <JoeyA> It's sequencing, but builds a list
18:36:06 <CakeProphet> ah.
18:37:30 <CakeProphet> I love parsec
18:37:44 <CakeProphet> so simple to use. A monad is a great way to structure a parsing operation.
18:38:22 <Saizan> JoeyA: even 'r' will be just a thunk, but it's the same thunk in both positions, while in your code the second many1 p could generate another thunk
18:38:35 <Saizan> this is very much implementation specific
18:40:06 <JoeyA> The thing I don't like about Parsec is that it doesn't do nondeterminism automatically, making it a lot more like parsing manually than parser generators tend to be.
18:40:43 <JoeyA> "For reasons of speed, the (<|>) combinator is predictive; it will only try its second alternative if the first parser hasn't consumed any input."
18:40:56 <Saizan> there are other parser combinators libs that do have a fair (<|>)
18:40:56 <JoeyA> That's what drove me to the point of making my own parser combinator.
18:41:25 <Saizan> e.g. ReadP, polyparse, uu-parsinglib (i think), ..
18:42:55 <dropdrive> monochrom: Would I use parsec for this too?
18:55:27 <monochrom> parsec does not work well on large amount of input
18:56:19 <mrd> how much backtracking are you using?
18:56:24 <dibblego> how can I wrap WriterT and write my own MonadWriter instance?
18:56:28 <pastorn> dropdrive: have you looked at BNFC?
18:59:51 <JoeyA> Does anyone know off the top of their head if/to what extent rewrite rules in GHC can match on provably equivalent values?
19:03:45 <JoeyA> e.g. "eq"  forall x. x == x  = True
19:16:42 <Draconx|Laptop> JoeyA, x == x is not True in general.
19:17:02 <Draconx|Laptop> > let x = 0.0/0.0 in x == x
19:17:03 <lambdabot>   False
19:18:32 <applicative> >  0.0/0.0
19:18:33 <lambdabot>   NaN
19:18:45 <applicative> > NaN == NaN
19:18:46 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `NaN'
19:18:48 <mauke> > join (==) (0/0)
19:18:49 <lambdabot>   False
19:19:45 <JoeyA> Okay, so suppose x == x was True in general.
19:20:15 <JoeyA> How well would "eq"  forall x. x == x  = True identify equal-looking expressions on both sides of an == sign?
19:21:01 <Phyx-> huh?
19:21:29 <pikhq> Draconx|Laptop: Arguably, this is due to things that aren't Eq being declared as such.
19:21:46 <Draconx|Laptop> pikhq, certainly arguable :)
19:21:58 <JoeyA> By equal-looking, I mean they form the same expression
19:22:50 <JoeyA> If I said let n = Node x ys in n == n, would the forall rule I gave match those n's as being the same?
19:23:09 <JoeyA> If I said (Node x ys) == (Node x ys), would the forall rewrite rule match on it?
19:24:03 <JoeyA> (I'm thinking more along the lines of same expression, not equal according to the == operator)
19:24:33 <Draconx|Laptop> JoeyA, in order to replace "n == n" with True in the above, more information about the implementation of (==) and possibly Node, x and ys is required.
19:24:45 <Draconx|Laptop> JoeyA, for example, suppose that x = error "damn"
19:25:16 <applicative> > error "damn" == error "damn"
19:25:17 <lambdabot>   *Exception: damn
19:25:36 <roconnor> well it is less that True, which is good enough for me
19:26:11 <JoeyA> Although it wouldn't be correct to substitute it for True, would the rewrite rule "eq"  forall x. x == x  = True rewrite it anyway?  That's what I'm getting at.
19:28:29 <roconnor> JoeyA: I think it would be
19:28:33 <roconnor> but most people disagree
19:28:46 <roconnor> because they are cowards
19:29:33 <pikhq> I think that floating point numbers screw everything up.
19:30:27 <roconnor> I think even floating point numberw wouldn't screw this, no matter how particular you are about floating point.
19:30:52 <Draconx|Laptop> JoeyA, the ghc manual suggests that it would be.
19:31:47 <roconnor> ah sorry, I answered whether the subsitution ought to be done, not whether it is actually done
19:32:40 <dolio> That eq rule will only fire (at best) if identical expressions are being compared.
19:32:49 <dolio> Possibly up to inlining.
19:33:02 <dolio> And a few other optimizations.
19:33:21 <dolio> But it's not necessarily going to fire for '2 == (1 + 1)' for instance.
19:41:27 <JoeyA> Okay, this is strange:  http://codepad.org/C2zxDM4h
19:41:40 <JoeyA> err:  http://codepad.org/O3nDIo31
19:42:20 <dolio> Does codepad compile with optimizations on?
19:42:23 <JoeyA> If I leave it like it is and run it after ghc --make -O2 -fenable-rewrite-rules, I get False False
19:42:43 <JoeyA> codepad uses Hugs
19:43:06 <JoeyA> Anyway, if I take out either the first or second line under main = do, I get True
19:43:25 <JoeyA> (even without -O2)
19:43:50 <JoeyA> err, nevermind
19:44:01 <JoeyA> -O2 does set off the weird behavior
19:45:53 <JoeyA> The "eq" rule doesn't fire with both lines.  Maybe something gets folded out beforehand.
19:52:00 <drhodes> is there a way to combine type classes ? data Foo = A | B | C  deriving Custom    -- where Custom = Eq, Ord, Show
19:52:23 <mauke> no
19:52:35 <drhodes> I think I've hit the maximum lazy :)
19:53:46 <applicative> JoeyA, wow, that is mysterious.
19:56:00 <dropdrive> pastorn: I'll look at BNFC too, thanks.
19:56:44 <pastorn> dropdrive: google "aaren ranta" and go through his page, otherwise you might get to the old homepage and get lost :p
19:57:41 <pastorn> dolio: sorry, "aarne ranta"
19:58:53 <dropdrive> pastorn: got it, thanks!
20:02:51 <falconair> hi, at my work, I work with 'quants' who write documents of technical/mathematical nature with heavy math notation...
20:03:10 <falconair> i'd like to convert those documents into some sort of literate haskell (executable specification)
20:03:48 <falconair> obviously I can use literate haskell so text description and code is contained in the same file, but is there a way to use math notation?
20:04:49 <falconair> i want my document to look superficially like a math heavy academic paper, but actually be executable (and testable, refactorable, etc.)
20:05:30 <pastorn> falconair: look in to "pandoc"
20:05:53 <pastorn> or maybe lhs2tex
20:06:37 <falconair> so how would i write the math notation...even something as simple as x^y (x with y as superscript)?  mathml or something?
20:06:58 <ClaudiusMaximus> you can use literate haskell as latex with \begin{code} ... \end{code} around the executable bits, afaik
20:07:24 <ttmrichter> In building the latest GHC, I've been hit by configure telling me it can't find "hasktags".  I can't find "hasktags" in the Ubuntu repos, so filling that requirement is a bit of a hassle.  How do I go about getting it?
20:07:47 <pastorn> ttmrichter: why are you building ghc?
20:07:57 <ttmrichter> Because I want to.
20:08:05 <pastorn> ttmrichter: just use the binary install package
20:08:09 <falconair> i see, i think i need to look at latex more ... ghc can take latex files as literate haskell...correct?
20:08:21 <pastorn> ttmrichter: and there's a channel #ghc which probably knows more about this
20:08:36 <ttmrichter> Ah!  Wasn't aware of that channel.  Thanks.
20:08:57 <pastorn> falconair: you write a .lhs file, but put latex code as comments
20:09:04 <pastorn> then you run lhs2tex on that file
20:09:09 <pastorn> and you have magic
20:10:16 <falconair> pastorn: thanks! also, is there a tool that will convert this lhs file to a nicely formatted webpage (so a single source is used to publish for readin, as well as executing)?
20:10:26 <falconair> pastorn: hm..i think pandoc might do it
20:10:32 <pastorn> falconair: yes, pandoc
20:10:48 <falconair> pastorn: thanks!
20:17:21 <fryguybob> @botsnack
20:17:21 <lambdabot> :)
20:40:18 <augur> haskollians, are any of you available?
20:47:00 <prsteele> I am
20:47:18 <prsteele> Kinda new though, so not sure if I'll be of terrible use
20:54:05 <augur> prsteele: ok conceptual issue
20:54:39 <augur> you know anything about unification?
20:57:03 <prsteele> augur: in what context?
20:57:40 <augur> east and west germany
20:57:51 <augur> object unification ofcourse
20:58:04 <augur> like in prolog, or pattern matching on steroids
20:58:13 <prsteele> augur: haha I guess not then
20:58:17 <prsteele> augur: no, sorry
20:58:20 <augur> ok :P
21:10:58 <JoeyA> I'm trying to install Chlor (http://chlor.svn.sourceforge.net/viewvc/chlor/) via runhaskell, but it says "Setup: can't find source for Graphics.Chlor.Chlor in ., dist/build/autogen"
21:14:04 <kfish> JoeyA, how about "cabal configure && cabal build"?
21:14:37 <JoeyA> I'm actually trying to install cabal right now (I'm on Ubuntu).  Wish me luck.
21:19:47 <JoeyA> kfish: same
21:19:52 <JoeyA> (when using cabal)
21:20:04 <JoeyA> I'm glad I finally got around to installing it.
21:20:49 <kfish> JoeyA, what do you mean by same; does it build or still fail?
21:20:58 <JoeyA> same error message
21:21:03 <JoeyA> cabal: can't find source for Graphics.Chlor.Chlor in ., dist/build/autogen
21:21:09 <JoeyA> It doesn't spend enough time to be building.
21:36:51 <wioux> i just installed it last night
21:37:09 <wioux> hell of a package.. took some time
21:44:01 <wioux> @help
21:44:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:44:06 <wioux> @list
21:44:06 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:45:20 <wioux> @help bf
21:45:20 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
21:45:47 <wioux> @help djinn
21:45:48 <lambdabot> djinn <type>.
21:45:48 <lambdabot> Generates Haskell code from a type.
21:45:48 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
21:47:25 <elbar> does ghc hardencode the path to gcc?
21:48:52 <elbar> "ghc: could not execute: /usr/lib/ccache/bin/gcc"
21:50:49 <Zao> elbar: I believe it does on some platforms.
21:54:17 <wioux> why can't Djinn do lists? same reason it can't handle recursive types?
21:54:53 <shachaf> wioux: Maybe is equivalent to lists as far as it's concerned.
21:56:07 <jaredj> > runQ $ [d| data Quux = Foo Integer |]
21:56:07 <wioux> ah.. i see
21:56:07 <lambdabot>   <no location info>: parse error on input `data'
21:56:23 <jaredj> :/
21:59:30 <adnap_> How do I define a type such as data Sexp a = Atom a | List [Sexp a] such that a's can be of any type, rather than the same type?
22:00:31 <wioux> dont think you can
22:01:02 <wioux> like you can't have a list [Just 3, Nothing, Just "Hello."]
22:01:25 <pastorn> wioux: you can, with clever "forall" hacketry
22:01:31 <adnap_> I mean, I know I can do data Sexp = Number Integer | Symbol String | List [Sexp], but I don't want to have to enumerate all the types.
22:01:57 <pastorn> adnap_: make a value type
22:02:01 <Zao> You could, but it's a right pain in the behind to get at the values in the end.
22:02:19 <pastorn> data Val = VI Int | VII Integer | VChar Char ...
22:02:41 <adnap_> pastorn: Yeah, but I have to enumerate all the types I want.
22:02:57 <adnap_> pastorn: I want it to be anything and everything.
22:03:04 <pastorn> adnap_: forall
22:03:37 <adnap_> > :t forall
22:03:38 <lambdabot>   <no location info>: parse error on input `:'
22:03:49 <pastorn> adnap_: no, that's a type level hack
22:04:01 <adnap_> pastorn: I don't know it.
22:04:33 <wioux> are you just trying to get around homogeneity in the build-in list?
22:04:36 <adnap_> pastorn: Is what I'm wanting to do considered bad practice if I have to resort to hacks?
22:05:06 <adnap_> wioux: I just want to have sexps that contain different types.
22:06:10 <wioux> hack it or enumerate them :\
22:07:29 <adnap_> wioux: Guess so.
22:07:35 <JoeyA> When I ghci -package chlor, I get:  ghc: /home/joey/.cabal/lib/chlor-0.1/ghc-6.10.4/HSchlor-0.1.o: unknown symbol `__stginit_chlorzm0zi1_GraphicsziChlorziText_'
22:07:35 <wioux> as far as i know anyway
22:08:31 <JoeyA> There were problems in chlor.cabal (Exposed-modules was wrong; Build-Depends didn't include text and containers)
22:08:43 <JoeyA> What would cause that unknown symbol problem?
22:12:31 <wioux> adnap_: a hack might be data Sexp a = Singleton a | forall b. Head a (Sexp b)
22:13:49 <adnap_> wioux: Hm... that is strange syntax; I plan to read about it later.
22:15:47 <JoeyA> I think that'll require {-# LANGUAGE ExistentialQuantification #-}
22:15:49 <wioux> well you *are* circumventing the type system :P - check out the page on existential types
22:17:36 <dolio> Existential types aren't circumventing the type system.
22:18:34 <dolio> That Sexp type is unlikely to be particularly useful, though.
22:18:42 <JoeyA> I hate running into walls when trying to do something in a programming language.  The cool thing about Haskell is that there's an extension for everything :-)
22:18:44 <wioux> if you're literally making a list then you can $ data Sexp = forall a. Sexp a; sexps = [Sexp]
22:18:48 <wioux> its not circumvention?
22:19:12 <dolio> No more than universal quantification is.
22:19:53 <dolio> You can mimic one with the other, even.
22:20:00 <JoeyA> Well, (I learned about this yesterday), the way I understand it,  Sexp = forall a. Sexp a; creates a type schema.
22:20:20 <dolio> (exists a. ...) = forall r. (forall a. (...) -> r) -> r
22:20:25 <JoeyA> err, let's make it:  data Foo = forall a. a
22:20:43 <JoeyA> It'd be sort of like saying data Foo = Int; data Foo = String; data Foo = ...all other types... (I think)
22:20:51 <JoeyA> (and pretending you could do that)
22:21:24 <JoeyA> (and not forgetting to put in data constructors)
22:21:43 <dolio> The problem with the Sexp type would be that when you see 'Head x y' You don't know what the 'b' in y :: Sexp b is.
22:21:51 <dolio> You've lost all information about it.
22:24:17 <wioux> dolio: my point was that the syntax *should* put up flags. it's not circumvention though, you're right - as it restricts the use of the type correspondingly
22:33:15 <jaredj> i have an SGML file parseable by tagsoup, and I want to know its contents in a well-typed fashion
22:33:36 <Wolfspaw> I get an error in the aux definition: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=28390#a28390 . I cant use guards in where clausules?
22:33:54 <jaredj> so say my file has a tag <GROUP> that can contain <A>123 or <B>aString
22:34:23 <jaredj> and i have a record like data Group = { a :: A Integer, b :: B String }
22:35:13 <wioux> Wolfspaw: aux is 2-ary
22:35:38 <wioux> do $ instead of composition
22:35:39 <Zao> Did you mean   last . aux n $ primos  ?
22:35:44 <jaredj> if i make tagsoup-parsec parsers, i can say anA = do { openTag "A"; x <- integerParser; return A x }
22:35:52 <Wolfspaw> wioux: hm, ok! thanks. Didnt realize that it only works in 1-ary @_@
22:36:00 <Zao> Or  last $ aux n $ primos, of course.
22:36:36 <Wolfspaw> Zao: yes, another mistake... Thanks!
22:36:39 <jaredj> anA and aB will be of type GenParser Tag st A and GenParser Tag st B, respectively
22:36:42 <wioux> its 2-ary and you already give it 2 arguments, so composition doesn't work
22:38:10 <jaredj> then aGroup :: GenParser Tag st Group = do { openTag "GROUP"; ?????; closeTag "GROUP"; return Group { ?????? } }
22:39:18 <jaredj> what is the type of anA <|> aB? is that even possible?
22:40:37 <jaredj> (er, newtype A = Integer and newtype B = String, or something)
22:41:54 <wioux> something that got me the other day.. why can't guards be nested? doesn't seem like it should cause any ambiguity..
22:46:29 <jaredj> oh dear, there i go framing questions badly again. i should ask haskell-cafe.
22:47:16 <JoeyA> I'm a noob as far as .cabal files go.  Here's what I ended up doing to get Chlor to load in ghci:  http://codepad.org/
22:47:18 <jystic> hi all, does anyone know anything about how to get cabal to build an executable which refers to a library which is defined within the same package?
22:47:18 <JoeyA> oops
22:47:23 <JoeyA> I didn't create codepad.org
22:47:57 <JoeyA> http://codepad.org/AuEsZVsu  -- I added every last .hs file to the Exposed-modules list.  I have a feeling that's not the "right way" to do it.
22:48:39 <dolio> wioux: It'd require layout rules that don't exist.
22:50:06 <wioux> what do you mean?
22:51:27 <dolio> I mean there's no explicit layout for nested guards.
22:52:40 <dolio> It'd have to be something like "foo x {| b1 = ... | b2 {| b21 = ... | b22 = ... }}"
22:54:39 <dolio> If the question is why that doesn't exist, I don't think there's a good reason, other than no one thought it was worth it.
22:56:06 <wioux> i see
22:57:22 <Gracenotes> JoeyA: that seems to be the right way
22:57:47 <Gracenotes> still, most of the time, starting ghci in the root directory of the package and loading modules works just as well
22:58:10 <Gracenotes> depending on the package
22:58:23 <wioux> there's the question of fall through i guess
22:58:57 <dolio> I don't think that's really complicated, is it?
23:00:13 <Gracenotes> wioux: if there are alternatives you want to appear in more than one branch, worst comes to worst you can define a function to call from both branches in a where clause
23:00:45 <JoeyA> Even after that, I get:  <no location info>: module `Graphics.Chlor' is a package module .  However, I got the diagrams package installed, and it looks like what I'm looking for.
23:00:51 <wioux> yeah
23:02:36 <wioux> they should have allowed them if only to preserve the otherwise universality of the construct
23:02:50 <Gracenotes> jystic: I think perhaps you'll need to list the modules twice
23:03:25 <Gracenotes> or maybe there's a shared modules section. brainrust prevents me from accessing this critical information
23:03:27 <jystic> Gracenotes: thanks i found my problem, i need to have cabal 1.8.0.4 to do a self reference
23:03:57 <Gracenotes> oh. ouch. that doesn't sound ideal, but if it's the preferred way of doings things then
23:04:23 <Gracenotes> make sure to list the cabal version in the appropriate field
23:04:30 <jystic> yeah i have done
23:04:40 <jystic> actually i just want to set up an executable to test my library
23:05:36 <jystic> this seems to be working nicely, should I try not to reference a cabal version that is so recent?
23:39:15 <kulin> evening, is there any language extension so that i can allow circular references? 
23:39:26 <kulin> or ghc command
23:47:12 <byorgey> kulin: you don't need a language extension for circular references.
23:48:05 <byorgey> see http://haskell.org/haskellwiki/Tying_the_Knot
23:48:37 <kulin> i didn't state it correctly, i meant for modules
23:48:56 <kulin> two modules both depend on each other
23:50:24 <byorgey> ah, yes, there is a way to do that, let me find you a link
23:51:11 <byorgey> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/separate-compilation.html#mutual-recursion
23:51:27 <cads> what is esentially tying the knot?
23:51:34 <kulin> getting married
23:51:38 <kulin> thx byorgey
23:51:52 <byorgey> cads: creating a cyclic data structure
23:52:07 <cads> where values deeper into the structure may remain lazy?
23:54:14 <cads> If I implemented a graph (E,V) that was one large cycle with a function next : V -> V, would the implementation have to "tie the knot"
23:54:31 <byorgey> not necessarily, it just means creating a recursive structure
23:54:46 <byorgey> in that case, no
23:55:03 <byorgey> for example, the cycle function ties the knot for you
23:55:50 <byorgey> when you say 'cycle [1,2,3]' it actually creates a circular structure in memory
23:57:15 <kulin> the haskell module will always be my worst enemy
23:58:06 <byorgey> kulin: why is that?
23:58:15 <kulin> it just is the thing i butt heads with the most
23:58:24 <qwebirc47873> @pl \x -> (x, x)
23:58:25 <lambdabot> join (,)
23:58:49 <kulin> whenever ive complained about specifics before, people disagree that they are faults, so its entirely on my end, but the rest of haskell is a wonderful experience, while the modules are not
23:59:17 <qwebirc47873> @pl \f (a, a) -> (f a, f a)
23:59:18 <lambdabot> (. snd) . (ap =<< ((,) .))
