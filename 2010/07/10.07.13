00:00:13 <qwebirc20298> @pl (\x -> (f x, x))
00:00:13 <lambdabot> (,) =<< f
00:00:19 <kamatsu> is it possible to get some sort of ifthenelse construct in type constraints?
00:00:36 <FunctorSalad> Saizan: s/folding/definining the fold for an/
00:00:50 <kamatsu> i.e if this constraint is true then this constraint should hold else this constraint
00:00:57 <ski> ezyang : note also that there's a corresponding `data IOWriteRef a = forall x. MkIOWriteRef (IORef x) (a -> x)' ..
00:01:03 <CakeProphet> qwebirc20298:  I believe you have to import an instance declaration for (->) a in order for that to work, btw.
00:01:13 <ezyang> ... cooool 
00:01:14 <FunctorSalad> kamatsu: maybe with oleg's type-equality trick?
00:01:23 <ezyang> ski: I think I understood all that. 
00:01:41 <kamatsu> FunctorSalad: link?
00:01:50 <ezyang> ski: Would it be fair to say that CoYoneda lets you be even lazier than the language is already? 
00:01:52 <FunctorSalad> I don't remember the details, but he does what appears impossible though some apparently useless dummy classes
00:01:53 <ski> ezyang : given `data CoYoneda_Op f a = forall x. ContraFMapIncl (a -> x) (f x)', that becomes `CoYoneda_Op IORef' ..
00:02:26 <ski> ezyang : i'm not sure if that would mean much .. but i suppose you can say what you want :)
00:02:53 <CakeProphet> Haskell should make juxtaposition a typeclass method. -evil thoughts-
00:02:58 <FunctorSalad> kamatsu: http://hackage.haskell.org/package/type-equality-check
00:02:59 <CakeProphet> ( )
00:03:09 <ezyang> ski: Huh. Why isn't CoYoneda_Op just Yoneda... 
00:03:23 <ski> ezyang `a -> x' vs. `x -> a'
00:03:25 <ezyang> I guess it's not obvious to me which category is getting dualizing. 
00:03:30 <FunctorSalad> not sure if it's applicable, but I thought it's how hlist does the apparently-impossible case distinctions
00:03:30 <ski> er, actually not
00:03:35 <ezyang> oh, right, it's the endofunctor. 
00:03:44 <ezyang> is it? 
00:04:12 <ski> ezyang : `data Yoneda f a = MkYoneda (forall x. (a -> x) -> f x)'
00:04:44 <FunctorSalad> http://hackage.haskell.org/packages/archive/type-equality-check/0.0.0.0/doc/html/src/Data-TypeEq.html
00:04:48 <ski> ezyang : both `Yoneda f' and `CoYoneda f' are (covariant) functors .. while `CoYoneda_Op' above would be a contravariant functor
00:04:50 <FunctorSalad> truly absurd =)
00:05:10 <ski> ezyang : what endofunctor ?
00:05:27 <CakeProphet> > data Test = Test
00:05:28 <lambdabot>   <no location info>: parse error on input `data'
00:05:32 <CakeProphet> :(
00:05:32 <ezyang> arrows are mied up. 
00:05:42 <CakeProphet> @let data Test = Test
00:05:42 <lambdabot>  Invalid declaration
00:05:50 <ezyang> Yoneda_op f a = MkYonedaOp (forall x. (x -> a) -> f x) 
00:05:52 <ezyang> ? 
00:06:01 <FunctorSalad> the haddock seems to be mistaken, there's both a True and a False instance
00:06:09 <ski> i suppose so, but i've not pondered it
00:06:16 <FunctorSalad> (is the function total?)
00:06:43 * ski invented `CoYoneda_Op' just to be able to describe `IOWriteRef' in terms of it
00:06:49 <FunctorSalad> (the partial function defined by the TypeEq class/relation)
00:07:09 <CakeProphet> class SpecificValue a where specific :: a
00:07:10 <CakeProphet> :)
00:07:58 <ezyang> seeing that there are datatypes, I wonder if these are F-algebras 
00:08:04 <ezyang> *initial-algebras 
00:08:12 <ezyang> I guess if you universally quantify them, no. 
00:09:09 <ezyang> erh? 
00:09:13 * ezyang scratches head. 
00:09:30 <FunctorSalad>  "these"?
00:09:31 <ezyang> ski: Anyway, the pickin's were good before you introduced CoYoneda_op 
00:09:42 <ezyang> thanks for sharing. 
00:10:00 <FunctorSalad> datatypes are the initial algebra for the functor you get by "opening" the recursion up
00:10:11 <CakeProphet> instance HaskellProgrammer p where scratchHead :: p -> Ideas
00:10:22 <FunctorSalad> (replace all recursive positions with a parameter (the same parameter))
00:10:37 <ezyang> FunctorSalad: These definitions are very recursive. 
00:10:39 <CakeProphet> s/instance/class/
00:10:42 <ezyang> *aren't 
00:10:46 <ski> ezyang : one intuition, which i'm so sure is of help here, is that if you replace `x -> a' with `x >= a', and let `f x' express `P x', being a property of an element `x', then what `CoYoneda' and `Yoneda' does is take arbitrary ("chaotic" / non-monotone / non-upper) predicate `P' on the underlying set of a preorder, and construct a new predicate (`Yoneda P' and `CoYoneda P') on the preorder, and this new predicate respects the
00:10:52 <ezyang> so I guess it's not a useful intuition. 
00:11:02 <FunctorSalad> "open" like data OpenList self a = Nil | Cons a self
00:11:23 <ezyang> hm. Is Yoneda open? 
00:11:31 <ski> ezyang : here `CoYoneda_Op' would just take the opposite order, making the new predicate a lower / antitone one instead
00:11:37 <ezyang> I guess it is. 
00:11:40 <CakeProphet> ...you know.
00:11:48 <ski> s/i'm so sure/i'm not sure/
00:11:51 <CakeProphet> typeclass variables would be pretty nifty.
00:12:05 <FunctorSalad> [a] would be the initial algebra for the higher-order functor /\self -> /\ a -> Nil | Cons a (self a)
00:12:16 <FunctorSalad> forgot the application of self to a in the OpenList
00:12:47 <FunctorSalad> and the final one too, by the "initial-final-coincidence" or what it was called
00:12:55 <CakeProphet> data HList TC = forall a. (TC a) => a : (Hlist TC) | Empty
00:12:58 <FunctorSalad> (this is connected to lazyness)
00:12:58 <ezyang> ski: I now see that the op is describing the functor-nature of Yoneda. 
00:13:43 <ezyang> ski: I'd temporarily forgotten that contravariant functor = cofunctor 
00:13:50 <ski> ezyang : `CoYoneda_Op' was just for describing `IOWriteRef' .. i haven't pondered its categorical significance much, apart from that i think it's just `CoYoneda', except with the domain category `C' replaced by `C_op'
00:14:00 <FunctorSalad> ezyang: sorry wasn't following the CoYoneda thread, just read initial algebra/datatype
00:14:08 <ski> ezyang : contravariant functor /= cofunctor
00:14:17 <ezyang> FunctorSalad: Tis cool, trying to parse what you're saying. 
00:14:21 <ezyang> ski: Oh? 
00:14:21 <ski> ezyang : don't believe anyone who tells you that, they're confused
00:14:28 <dolio> "Cofunctor" isn't a real term.
00:14:49 <ezyang> Oh, it's /covariant/ 
00:14:59 <FunctorSalad> dolio: not even a shorthand?
00:15:00 <ezyang> in the dual category 
00:15:16 <ski> the `co' in `covariant' and `contravariant' has nothing to do (technically/mathematically) with the ones in `product' vs. `coprodct', `monad' vs. `comonad' &c.
00:15:26 <dolio> FunctorSalad: It'd be a poor shorthand for either choice of the usual functor cases, since they both start with 'co'.
00:16:06 <ski> ezyang : also, the correspondence between `covariant' and `contravariant' is not the same correspondence as between `foo' and `co-foo' (the dualizing correspondence)
00:16:13 <ezyang> huh. I thought there was a good relationship between covariant/contravariant functors and monad and comonad 
00:16:16 <ezyang> darn it. 
00:16:25 <FunctorSalad> dolio: indeed, but OTOH nobody specifies 'covariant functor'
00:16:33 <ski> both monads and comonads are covariant functors
00:16:36 <FunctorSalad> unless in contrast to contra, granted...
00:17:06 <ezyang> ski: that is true. 
00:17:16 <ski> ezyang : "covariant" vs. "contravariant" are a bit like "increasing" vs. "decreasing" (function)
00:17:33 <ezyang> ski: Sure, which is why you suggested s/->/=>/ 
00:17:36 <FunctorSalad> monad/comonad flip the natural transformations, not the category as contrafuncs do
00:17:39 <ezyang> because you've just flipped it around 
00:17:50 <ezyang> FunctorSalad: Some category gets dualized... 
00:17:59 <FunctorSalad> yes, but one dimension higher, kinda
00:18:08 <ski> ezyang : in some contexts, if you say "monotone", you mean either "increasing" or "decreasing" .. but if you're more into order theory you use "monotone" for "increasing" and "antitone" for "decreasing", only (afaik)
00:18:12 <ezyang> right, th category of endofunctors. 
00:18:28 <ezyang> ski: Huh, interesting. 
00:18:36 <ski> ezyang : well, i suggested s/->/>=/ ;)
00:18:45 <ezyang> that is, endofunctors as objects and nat trans as morphisms 
00:18:49 <ezyang> ski: :o) 
00:19:03 <ezyang> ah, so the nat trans /do/ get flipped. 
00:19:27 <FunctorSalad> I said that, yes :)
00:19:33 <ezyang> yes you did! 
00:19:39 <ezyang> took me a little longer to figure it out :-) 
00:19:53 <ezyang> ok, so it seems to me the best way to sort out the co- nonsense is to imagine the category involved. 
00:20:21 <ski> (to me, `=>' is right-implication, while `>=' is "greater-than-or-equal" (alt. "non-lesser-than") .. note that `=>' is an instance of `=<', not `>=' (given the standard ordering on propositions) !)
00:21:14 <FunctorSalad> join :: T . T -> T
00:21:21 <FunctorSalad> duplicate :: W -> W . W
00:21:48 <FunctorSalad> but T and W don't have their signatures flipped, they remain functors
00:21:52 <FunctorSalad> (hmm?)
00:22:14 <ski> ezyang : btw, note that if you have `F : C >-> D', a (covariant) functor from `C' to `D', then `F^op : C^op >-> D^op' is still a covariant functor from `C' to `D'
00:23:02 <ezyang> ski: Right, because you've dualized too many categories 
00:23:10 <FunctorSalad> ezyang: maybe a 2-d diagram would be best not to get confused with the levels
00:23:19 <ezyang> but C^op >-> D should be isomorphic to C >-> D^op 
00:23:25 <FunctorSalad> yes
00:23:41 <ski> ezyang : if we have a *contravariant* functor `G : C >#> D' (imaginary syntax), then this corresponds to a covariant functor from `C^op' to `D' .. and also to a covariant functor from `C' to `D^op'
00:23:59 <dolio> Monad vs. comonad does flip the categories, though. it just flips both (since they're the same).
00:24:16 <ezyang> dolio: I thought there was only one category? 
00:24:18 <dolio> A monad over C is a comonad over C^op and vice versa.
00:24:33 <FunctorSalad> hmm
00:24:35 <ezyang> FunctorSalad: what do you mean by flipped signature? 
00:24:49 <FunctorSalad> dolio: haven't thought of it like that, ok :)
00:25:07 <FunctorSalad> but that's not a flip like with contrafunctors
00:25:07 <ezyang> ah, sure. 
00:25:19 <FunctorSalad> ezyang: C -> D to C^op -> D
00:25:21 <qwebirc98813> So I have a question regarding the random and randomR functions.
00:25:24 <ezyang> the "flip" in the contrafunctor comes from the fact that the morphisms change directions 
00:25:36 <dolio> But F : C -> D and G : C^op -> D^op are both covariant functors.
00:25:49 <ski> ezyang : this means that `F |-> F^op', as a `(2-)endo-functor' over `(2)Cat', is *co*variant in its morphism (i.e. functor) mapping part .. (and, incidentally, *contra*variant in its 2-morphism (i.e. natural transformation) mapping part .. and i think it's contravariant in its object mapping part, but one can't really see a difference)
00:25:56 <qwebirc98813> randomR doc says that it gives a random number over the CLOSED interval [a,b].
00:26:16 <qwebirc98813> random says it gives a random number over [0,1), where the right side is OPEN.
00:26:25 <qwebirc98813> but random is defined as random = randomR (0, 1)
00:26:42 <qwebirc98813> How does this work.
00:26:48 <ski> dolio : `G' usually being written `F^op'
00:26:58 <dolio> Although, it can make a difference for functors with more structure.
00:27:10 <ski> (cf. `F f' for the functor `F' mapped over the morphism `f')
00:27:25 <dolio> An oplax monoidal functor from C to D is a lax monoidal functor from C^op to D^op, I think.
00:27:39 <dolio> For example.
00:28:18 <ezyang> qwebirc98813: Where'd you get that code from? 
00:28:31 <FunctorSalad> dolio: funny how op'ing all categories leaves functors the same but not NTs :)
00:28:56 <ezyang> dolio: Hot damn! 
00:29:22 <ski> FunctorSalad : (as said), `op' is contravariant in its 2-morphism mapping part :)
00:29:31 <ezyang> Btw, one thing I still don't quite understand about monads commuting diagrams 
00:30:01 <ezyang> Why is having two paths from T (T (T A)) -> T (T A) -> T A interesting? 
00:30:16 <FunctorSalad> reminds me how the (*-1) map is a rotation in even-dimensional space, but orientation-inversing in odd-dimensional :)
00:30:30 <ski> ezyang : associative law
00:31:04 <FunctorSalad> ezyang: it isn't interesting, so you want to argue why you can in fact ignore it once and for all ;)
00:31:07 <ski> ezyang : it shouldn't matter if we first squish the two outer levels, or first squich the two inner levels
00:31:37 <FunctorSalad> from a paper about a specific case of that law... "so trivial that it takes some time to convince ourselves that there is in fact something to prove" ;)
00:31:51 <ezyang> haha 
00:32:05 <FunctorSalad> but you could construct counterexamples
00:32:08 <ezyang> ski: So, I see that. 
00:32:23 <ski> ezyang : in terms of `do'-notation, this means that `do y <- do {x <- f; g x}; h y' is the same as `do x <- f; y <- g x; h y' .. so you can factor out prefices (and inner parts) of a sequence of `do'-commands
00:32:28 <ezyang> but for me, I should like to see something like F_1 (F_2 (F_3 A)) 
00:32:41 <dolio> It does disqualify some stuff. Like nondeterminism-via-diagonalization.
00:32:49 <ezyang> ski: Even better: join (join (join x)) = join (join x) = join x 
00:33:01 <ezyang> erm 
00:33:07 <ski> ?
00:33:17 <ezyang> no, that's where I'm confused, sorry. 
00:33:18 <dolio> Or, diagonal enumeration. Or whatever you want to call it. The stuff in omega.
00:33:32 <ski>   join . liftM join  =  join . join
00:33:52 <ezyang> T (T (T X)) looks a lot like join (join (join x)) 
00:33:57 <ezyang> ski: Hmmm 
00:34:00 <ezyang> yeah, that works 
00:34:15 <Saizan>  T (T (T X)) would be the type of x on which you apply join . join
00:34:16 <FunctorSalad> it's an 'associative law' if you take functor composition as your binop
00:34:41 <ezyang> mmmwait 
00:34:43 <ski> dolio : maybe i'm weird, but when i hear "diagonalization" here, i think of selecting out the sole diagonal in `[[a]]' .. alt. `join ff = \a -> ff a a'
00:34:45 <ezyang> what category are we in again? 
00:34:55 <FunctorSalad> sorry, I was confused
00:35:05 <ski> (.. and that latter is related to the `A >-> A * A' diagonal map)
00:35:10 <CakeProphet> hmmm
00:35:14 <FunctorSalad> the functor composition replaces the cartesian product from the world of ordinary monoids
00:35:18 <dolio> ski: Zig-zagging, maybe?
00:35:25 <CakeProphet> would it be feasible to have a type system that could express laws like the monadic laws?
00:35:26 <Saizan> ezyang: in the category C given T : C >-> C and X is an object in C
00:35:34 <ski> dolio : maybe
00:35:56 <FunctorSalad> ezyang: the associativity diagram for a plain monoid looks just like for a monad, just with cart. product vs. functor composition
00:35:58 <ezyang> Saizan: But C is an endofunctor... 
00:35:58 <ski> ezyang : `Hask' ?
00:36:01 <RyanT5000> what's the deal with there not being any deriving for newtype associated types?
00:36:17 <ezyang> oh, C >-> C is the endofunctor? 
00:36:21 <Saizan> ezyang: T is an endofunctor, you mean?
00:36:27 <FunctorSalad> the monad is the endofunctor
00:36:28 <ezyang> yeah 
00:36:31 <ski> `C >-> C' is a class of endofunctors
00:36:39 <FunctorSalad> join is the "monoid multiplication" equivalent
00:36:45 <ezyang> oh duh *smack* 
00:36:47 <Saizan> "T : C >-> C" is a way to say that T is an endofunctor over the category C
00:37:00 <ski>   join : (T . T) >-> T
00:37:01 <ezyang> RyanT5000: What do you mean? 
00:37:05 <ski>   return : id >-> T
00:37:22 <ezyang> mmmm ok. 
00:37:24 <CakeProphet> ezyang:  what are you talking about? C is a programming language!
00:37:28 <FunctorSalad> ezyang: hmm, no need to smack ;) the weird difference is that product is commutative, and (.) is far from it ;)
00:37:34 <FunctorSalad> monoid mult: M x M -> M
00:37:39 <FunctorSalad> join: T . T -> T
00:37:41 <ezyang> I think I've got morphisms and 2-morphisms straight for monads now. 
00:37:41 <Saizan> join_X is a morphism in C
00:38:18 <Saizan> CakeProphet: yes, the dependent typed languages in general can
00:38:28 <ezyang> Saizan: Yes, so it gets flipped when we dualize the category to get comonads 
00:38:35 <RyanT5000> ezyang: i don't seem to be able to write: instance C T where newtype A T = A Int deriving (Num)
00:38:55 <ski> FunctorSalad : well, we only require a monoidal category, not a symmetric (or even braided) monoidal one
00:39:01 <CakeProphet> Saizan:  if only there was a dependent typed language as AWESOME as Haskell. :)
00:39:09 <FunctorSalad> (ok, product isn't quite commutative at face value ;) but more symmetric somehow, surely)
00:39:19 <Saizan> *dependently
00:39:33 <ezyang> CakeProphet: I hear they're working on it. 
00:39:47 <ezyang> Is bind a morphism in C? 
00:39:49 <FunctorSalad> ski: I meant I think that this is the most tricky part of the categorification monoid -> monad
00:39:55 <ezyang> OHH! 
00:40:11 <ski> FunctorSalad : well, removing "on-the-nose" things, `symmetric' is the sane replacement of `commutative'
00:40:20 <ezyang> currying has been confusing me! 
00:40:55 <ezyang> (>>=) :: (m a, a -> m b) -> m b 
00:40:57 <FunctorSalad> ski: but we don't want something so lax that functor composition satisfies it too ;)
00:41:00 <ski> ezyang : `extend' is a construction mapping a `C'-morphism of type `A >-> T B' to a `C'-morphism of type `T A >-> T B'
00:41:25 <ezyang> no, that's not quite right 
00:41:29 <Saizan> ezyang: no currying (but flipping) is what makes it CT's saner
00:41:34 <FunctorSalad> ezyang: 'bind' seems rather confusing in this POV, or I just don't see it
00:41:36 <ski> (and "construction" here means "function", unless you're doing internal categories of some kind)
00:41:47 <FunctorSalad> (due to currying and the CCC it requires)
00:42:13 <ski> (though, i suppose you can always try to internalize `extend' as (e.g.) `bind' inside your category, if you've got some kind of exponentials)
00:42:14 <ezyang> FunctorSalad: Well, basically the idea is to understand why bind -> cobind makes sense 
00:42:27 <ezyang> after join and cojoin start making sense 
00:42:29 <CakeProphet> I need to stop frequenting this channel or I'm going to go crazy.
00:42:42 <CakeProphet> oh wait, I already am crazy.
00:43:33 <Saizan> ezyang: (A -> T B) -> (T A -> T B) vs. (T B -> A) -> (T B -> T A)
00:43:36 <ski> ezyang : focus on `extend :: Monad m => (a -> m b) -> (m a -> m b)', rather than `(>>=)'
00:44:03 <FunctorSalad> bind makes most sense if you take the kleisli category into the picture too, IIRC
00:44:07 <Saizan> well, i guess the outer -> is not really a morphism in any category
00:44:18 <ski> it's a function in our meta-system
00:44:20 <ezyang> FunctorSalad: Sure. 
00:44:25 <FunctorSalad> it's the adjunction isomorphism or somehow related to it
00:44:27 <ezyang> FunctorSalad: What is the Kliesli Category? 
00:44:37 <Saizan> ski: which is why it doesn't get flipped i guess
00:44:40 <ezyang> dammit, haven't learned adjunctions yet. 
00:44:42 <FunctorSalad> (we discussed this here once to great confusion of the categories involved ;))
00:44:47 <ski> if we're doing internal categories inside some category `C', then the outer `->' becomes the morphism arrow in our ambient `C'
00:44:58 <ski> Saizan : yes, you could see it like that
00:45:06 <FunctorSalad> ezyang: same objects as C, but Kleisli(A,B) = C(A, T B)
00:45:15 <FunctorSalad> (looks familiar ;))
00:45:20 <ezyang> mm, yes it does! 
00:45:45 * ski . o O ( `A >-{Kleisli T}-> B  =  A >-{C}-> B' )
00:45:52 <ezyang> which makes cobind just a sort of unpacked coKliesli arrow 
00:45:58 <FunctorSalad> (composition in kleisli is (<=<) in haskell notation)
00:46:04 <ezyang> wait, I forgot what extend was. 
00:46:15 <ski> extend is `(=<<)'
00:46:19 <ski> @type (=<<)
00:46:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
00:46:26 <ezyang> oh, that is extend. 
00:46:31 <Saizan> in this conversation :)
00:46:38 <Saizan> other times it's cobind
00:46:40 <ezyang> teehee 
00:46:43 <ezyang> wait, balls. 
00:46:54 <ezyang> I thought extend == cobind. aggggh 
00:47:14 <ski> in the literature, sometimes `(=<<) f' (i.e. `(f =<<)') is written like `f^*' so that `f =<< ma' becomes `f^* ma' .. i've also seen `f * ma' for the latter
00:47:39 <FunctorSalad> I'm too hungry or something to reassemble what the kleisli adjunction was now, though ;)
00:47:46 <FunctorSalad> but it may give bind as the adjunction iso
00:47:46 <ezyang> wtf. wait, =<< is in Control.Monad 
00:47:52 <ezyang> :info (=<<) 
00:47:57 * ski tentatively uses "preserve" for `(<<=) :: CoMonad w => (w a -> b) -> (w a -> w b)'
00:48:16 <FunctorSalad> =<< seemed off to me too...
00:48:17 <ezyang> oh, they're not the same *phew* 
00:48:34 <ski>   (=<<) = flip (>>=)
00:48:44 <ski>   (<<=) = flip (=>>)
00:48:58 <ezyang> ok. just makin' sure. 
00:49:26 <Saizan> ^* is also called "kliesli star"
00:49:33 <ski> *nod*
00:49:38 <ezyang> anyway, comonads are just cokliesli arrows, right?! 
00:49:47 <FunctorSalad> wasn't it a dagger? ;)
00:49:50 <Saizan> ..no?
00:49:51 <FunctorSalad> maybe not the same
00:50:00 <ezyang> yeahh 
00:50:27 <Saizan> well, in a sense, you can make a CoKliesli Arrow out of every comonad
00:50:31 <ezyang> uh, comonads are the domain of any cokliesli arrow 
00:50:37 <ski> we have a functor from `C' to `Kleisli T'
00:50:46 <ezyang> identity? 
00:50:59 <ezyang> no... 
00:51:06 <ski> (identity on objects, but `(return .)' on morphisms)
00:51:11 <ski> do we have a functor from `Kleisli T' to `C' ?
00:51:20 <FunctorSalad> anyway, assume we have the adjunction, then the types are like: C(A,TB) =iso= Kleisli(TA,B) =bydef= C(TA,TB)
00:51:30 <ski> i think so
00:51:32 <FunctorSalad> that looks very suspiciously like bind to me ;)
00:51:49 <ski>   P : Kleisli T >-> C
00:51:56 <ski>   P A = T A
00:52:13 <ezyang> what is T? 
00:52:23 <FunctorSalad> oops, right, I somehow pretended it's an adjunction with itself
00:52:32 <ski>   P (f : A >-{Kleisli T}-> B) = (f^*) : T A >-{C}-> T B
00:52:34 <FunctorSalad> one of my T's should be that P
00:52:48 <ski>   T : C >-> C  -- the endofunctor of the monad
00:53:04 <ski> so, since
00:53:10 <ezyang> oh, P is a type operator 
00:53:17 <ski>   f : A >-{Kleisli T}-> B
00:53:19 <ski> we have
00:53:27 <ski>   f : A >-{C}-> T B
00:53:37 <ski> (because of how `Kleisli T' was defined from `C')
00:53:39 <ski> so then
00:53:43 <ski>   (f^*) : T A >-{C}-> T B
00:54:06 <FunctorSalad> we just need the morphism parts for P and the other adjoint
00:54:15 <ski> so
00:54:29 <ski>   I : C >-> Kleisli T  -- inclusion functor
00:54:38 <ski>   P : Kleisli T >-> C  -- projection functor
00:54:57 <ski> so, the adjunction is (i think)
00:55:02 <ski>   I ---| P
00:55:14 <FunctorSalad> P(f)=?
00:55:23 <FunctorSalad> f:Kleisli(A,B)
00:55:28 <ski> see above
00:55:47 <FunctorSalad> oh ok
00:55:57 <FunctorSalad> that should be it
00:56:23 <ezyang> P = f^*. Hmmm 
00:56:32 <FunctorSalad> T(f) = f . return
00:56:35 <ski> so, this yields `M = P . I'
00:56:36 <FunctorSalad> err
00:56:40 <FunctorSalad> I(f) = f . return
00:56:46 <FunctorSalad> not quite an inclusion :)
00:56:48 <ski> er, `T = P . I'
00:56:51 <FunctorSalad> but identity on objects
00:56:55 <ski> (the monad was called `T' ..)
00:57:31 <ski> FunctorSalad : well, the interesting proposition, afaiac, is whether it is faithful
00:58:12 <ski> (and i just added "inclusion" and "projection" since they seemed maybe appropriate .. i'm not sure they actually are)
00:58:38 <FunctorSalad> hmm right, I thought set-inclusion
00:58:58 <FunctorSalad> might be a fine inclusion as in faithful functor :)
00:59:44 <ski> so, `I' being faithful means that for `f,g : A >-{C}-> B', if `I f = I g', must `f = g' follow ?
00:59:46 <ezyang> Is it just me or do I and P seem trivial? 
01:00:04 <ski> expanding : if `return . f = return . g', does that make `f = g' ?
01:00:27 <FunctorSalad> ski: (f . return)
01:00:36 <ezyang> ski: That seems no. 
01:00:48 <ezyang> well... not sure now. 
01:00:50 <FunctorSalad> oh sorry
01:00:53 <FunctorSalad> return . f
01:00:54 <ski> ezyang : `I' is certainly quite trivial, while `P' is not as trivial
01:00:57 <FunctorSalad> o_o
01:01:04 <ski> FunctorSalad : *nod* ;)
01:01:40 <ski> (i mean in the sense that `return' usually is less interesting in itself than `(=<<)')
01:01:44 <FunctorSalad> they're trivial rearrangements of the monad ingredients, yes, but it's highly confusing to keep track of how we're considering the same stuff with two cat structures
01:01:47 <ezyang> consider instance NullMonad where _ (>>=) _ = NullMonad; return _ = NullMonad 
01:02:21 <FunctorSalad> good point, just thought it too
01:02:23 <ezyang> but that might not actually be a monad. 
01:02:35 <FunctorSalad> return . f = const NullMonad
01:02:38 <FunctorSalad> it is
01:02:41 <ezyang> no, it is. 
01:02:43 <FunctorSalad> (yes, it is)
01:02:50 <ezyang> :-) 
01:03:21 <ski> well, `_|_ >>= return  =  NullMonad', while a monad law says it should be `_|_'
01:03:40 <ski> hm, or did i err ?
01:03:53 <FunctorSalad> but it works with the trivial monad in ordinary mathematics
01:04:01 <ezyang> P (f : A >-{Kleisli T}-> B) = (f^*) : T A >-{C}-> T B still feels a little funny. 
01:04:03 <FunctorSalad> not sure about the _|_ complications :)
01:04:08 <ski> .. no, that's right
01:04:22 <ezyang> because f : A >-{C} -> T B, no ? 
01:05:26 <FunctorSalad> ezyang: that part is bind, apparently
01:05:37 <FunctorSalad> you'd define bind from the join,fmap,return we're given
01:05:49 <ski> well, `extend', not `bind'
01:06:01 <ezyang> bind f m = join (fmap f m) 
01:06:23 <ezyang> the little extra structure from Kliesli is giving me trouble. 
01:06:38 <ski> ezyang : one could distinguish syntactically between objects and morphisms in `C' and those in `Kleisli T'
01:06:40 <ezyang> s/bind/extend/ 
01:07:00 <FunctorSalad> ski: ok, I don't make that distinction usually :)
01:07:07 <ezyang> fwiw, why isn't it `Kliesli T C`? 
01:07:24 <ski> `C' is an implicit argument, there .. you could make it explicit
01:07:29 <ezyang> ah, ok. 
01:07:29 <FunctorSalad> (I just rely on >>= and =<< suggestive visualization)
01:07:31 <ezyang> just makin' sure. 
01:08:09 <FunctorSalad> (and call =<< 'bind' too ;))
01:08:30 <FunctorSalad> >>= is pretty confusing with <- or .
01:08:44 <ezyang> I still can't match up the notations. 
01:08:55 <ezyang> extend f m = join (fmap f m) 
01:08:57 <FunctorSalad> (f -> y) <- foo >>= baz . bar
01:08:58 <FunctorSalad> ;)
01:09:24 <FunctorSalad> (view pattern)
01:09:27 <ezyang> what 
01:09:33 <ezyang> oh. 
01:09:38 <FunctorSalad> just a confusing 'do' statement ;)
01:09:55 <ezyang> equivalent to... 
01:10:13 <ezyang> y <- fmap f . baz . bar =<< foo 
01:10:54 <FunctorSalad> hmm right. could have added a lambda -> and a case -> for bonus points
01:11:18 <FunctorSalad> don't you need parens?
01:11:25 <FunctorSalad> hmm, maybe not
01:11:35 <ezyang> actually. 
01:11:43 <ezyang> why isn't the projection more trivial 
01:11:56 <ezyang> A -> T B is totally a morphism in C, pants and all. 
01:12:12 <ezyang> why does it need to be T A -> T B? 
01:12:25 <FunctorSalad> A -> T B is from Kleisli(A,B)
01:12:44 <FunctorSalad> functor law state that fmap :: Kleisli(A,B) -> C(P A, P B) :)
01:12:47 <FunctorSalad> *states
01:12:56 <FunctorSalad> and ski set P=T
01:13:02 <ski>   Kleisli (C : Cat) (T : Monad C) : Cat  =  This
01:13:06 <ski>     where
01:13:07 <ezyang> hum. 
01:13:10 <ski>     This.Obj  =  C.Obj
01:13:16 <ski>     A This.>-> B  =  A C.>-> T.Functor.mapObj B
01:13:17 <ezyang> I could have set P = Id. 
01:13:57 <FunctorSalad> Kleisli depends on T yes, but it clutters the notation if there's just one T IMHO
01:14:26 <ezyang> ski: Nice explicit notation. 
01:14:48 <FunctorSalad> ezyang: ah. you said you hadn't read about adjunctions yet; the whole point of the exercise is to confabulate an adjunction that will produce T again if you apply the (standard) adjunction-to-monad procedure
01:14:58 <ezyang> ahhhh 
01:15:00 <ski> if you want to treat the objects and the morphisms of `C' and `Kleisli C T' different, then say instead
01:15:30 <ezyang> I think I'm pretty well equipped at this point to figure them out. 
01:15:33 <ezyang> But after going to bed. 
01:15:35 <FunctorSalad> (fun trivia: this one is even the 'minimal' such adjunction ;))
01:16:19 <ski>     newtype This.Obj = ToKleisli {fromKleisli :: C.Obj}
01:16:21 <ski> &c.
01:16:45 <ezyang> "hey, that sounds familiar!" 
01:16:46 <FunctorSalad> ezyang: it's largely another round of restating the same principle ;) though adjunctions are slightly more varied than monads
01:17:02 <FunctorSalad> (we can make monads from adj and adj from monad, but there are many adj for a monad)
01:17:37 <ezyang> I'll also want to make sure I've gotten my co-things in the right places. 
01:17:42 <FunctorSalad> (restating it in three equivalent ways, even ;))
01:17:53 <FunctorSalad> it's all very trivial and very confusing
01:17:58 <ezyang> hehe 
01:18:14 <FunctorSalad> the types just fit together in one way, but there are many of them :)
01:18:56 <ski> well, given a monad, you can both from the kleisli category, and the eilenberg-moore category .. these being some extreme cases, iirc
01:19:07 <FunctorSalad> ski: yes
01:19:37 <Saizan> how does the latter look like?
01:19:40 <FunctorSalad> so "monad" is a kind of higher-order retract of "adjunction"... seems almost as good as an iso
01:19:49 <ski> if we have
01:19:57 <ski>   F ---| G
01:20:06 <FunctorSalad> Saizan: category of algebras for the monad, in a nutshell
01:20:12 <ski> so `F' and `G' form an adjuction situation
01:20:21 <ski> then the monad constructed from this is `G . F'
01:20:24 <ezyang> bleh, I never did figure out what an F-algebra was. 
01:20:26 <FunctorSalad> eilenberg-moore of the free group monad is the category of groups, e.g.
01:20:29 <ski> (and `F . G' is a comonad)
01:20:30 <ezyang> good night #haskell 
01:20:35 <ski> night ezyang
01:20:37 <FunctorSalad> night ezyang :)
01:21:16 <ski> istr kleisli was related to a least solution, while eilenberg-more to a greatest ..
01:21:30 <FunctorSalad> yes
01:21:42 <ski> but i'm not sure in which sense this was meant
01:21:43 <FunctorSalad> initial and final in the dizzying category of solutions
01:21:59 <FunctorSalad> or so I think
01:22:14 <ski> hm, maybe it was something like this
01:22:21 <ski> given a monad `T'
01:22:38 <ski> we want to split it into `G . F', so that `F ---| G' is an adjunction situation
01:22:41 <FunctorSalad> you have the option of fixing the 'other' category or even abstracting over *that* ;)
01:22:52 <FunctorSalad> ski: yes
01:23:09 <FunctorSalad> so you get to make up a cat as part of a solution
01:23:09 <ski> in the kleisli case, then `F' becomes nearly trivial (like `I' above),
01:23:21 <ski> while in the eilenberg-moore case, `G' becomes nearly trivial ?
01:23:25 <ski> yes
01:23:29 <FunctorSalad> we can either consider solutions for a fixed cat, or maybe glue them all together
01:23:38 <FunctorSalad> probably just bookkeeping
01:23:41 <FunctorSalad> *hand-wave*
01:24:00 * ski wants a programming language with constructs similar to `data' and `codata' which allows us to construct new categories based on a monad
01:24:01 <FunctorSalad> (glue them together as a dependent sum-kind of thing)
01:25:34 <FunctorSalad> ski: yes, 'G' is a projection for E-M
01:25:45 <FunctorSalad> since an algebra morphism by definition includes a morphism of the base sets
01:25:55 <FunctorSalad> (to use suggestive words.... needn't be sets)
01:26:13 <ski> hm .. so the eilenberg-moore category is always a construct, then ?
01:26:33 <ski> s/consrtuct/concrete category/
01:27:18 <FunctorSalad> I don't know, I was just thinking about the traditional algebras example still
01:27:47 <ski> hm
01:28:06 <FunctorSalad> where an algebra is a set X and a "law" T X -> X
01:28:16 <FunctorSalad> but needn't be the category of sets
01:28:28 <ski> maybe i was confusing things .. typical underlying functors are faithful in common cases, but needn't be (in case of multiple sorted algebras)
01:28:30 <FunctorSalad> Set just happens to be the domain of the monads I was thinking of
01:28:46 <ski> but maybe underlyinf functions always should be projections ?
01:29:30 <FunctorSalad> hmm 'projection' sounds surjective to me
01:29:40 <FunctorSalad> it's quite nonsurjective on morphisms
01:29:53 <ski> hm
01:30:06 <ski> .. maybe this is the fault of the dependent types
01:30:40 <FunctorSalad> but the morphism part is a 'projection' to one of the edges of the diagram definining 'algebra - morphism'
01:30:46 <FunctorSalad> different meanings
01:31:22 <FunctorSalad> it does look faithful in general, not sure
01:32:02 <FunctorSalad> since the algebra-morphism-diagram only has this single morphism as 'data' :)
01:32:20 <FunctorSalad> (you know the diagram I mean?)
01:32:33 <FunctorSalad> T X --{ T f }--> T Y
01:32:43 <FunctorSalad> X ---{ f }----> Y
01:32:56 <FunctorSalad> vertical edges are fixed parts of the two algebras
01:35:31 <ski> FunctorSalad : hm
01:37:20 <ski> well, consider directed (multi-)graphs .. objects consist of `V : Set',`E : Set', together with `src : E >-> V' and `tgt : E >-> V'; morphisms are what you expect
01:37:48 <ski> here one can make one underlying functor that maps objects to the vertex part only, e.g.
01:38:10 <ski> (and this is not faithful)
01:38:36 * ski wonders about a more natural-sounding example
01:39:11 <ski> (.. maybe a category of vector spaces where objects contain both the field `K' and the vectors `V' ?)
01:39:15 <FunctorSalad> what's the domain cat of your monad?
01:39:28 <ski> .. er, which monad ?
01:39:48 <FunctorSalad> thought we were making the Eil-Moore of a monad :)
01:39:52 * ski was only talking about non-faithful "underlying" functors, here
01:40:22 <FunctorSalad> ah, thought you defined them as the right adjoints of E-M adjunctions
01:40:28 <FunctorSalad> which seems like a pretty good match
01:40:42 <ski> well, i can't even state the definition of Eilenberg-Moore .. i only have a vague idea about it
01:41:37 <ski> i suppose one could try looking for familiar examples of underlying functors (faithful or not), and try to consider whether Eilenberg-Moore yields something familiar in these cases
01:41:53 <ski> (.. as a means of better grasping what Eilenberg-Moore is about, i mean)
01:46:49 <kamatsu> TacticalGrace: I have a question re type families. Would it be feasible to implement another constraint, along with ~, in GHC that determines if a type is inhabited? I want to enforce in a constraint that a data family has an instance in my function signature.
01:50:35 <illissius> speaking of type families -- they can be used to replace fundeps (once ghc gets a full implementation and ignoring overlappinginstances), but don't obviate the need for multiparamtypeclasses, right?
01:51:44 <FunctorSalad> ski: AFAIK it covers universal algebra, at least
01:51:53 <FunctorSalad> not entirely sure...
01:51:59 <FunctorSalad> but seems to work generically
01:51:59 <ski> "covers" meaning ?
01:52:01 <Saizan> illissius: right, though maybe there's some encoding :)
01:52:06 <ManateeLazyCat> How to setup darcs make other people send patch to specify address?
01:52:28 <FunctorSalad> ski: that if you take as the monad the "make free algebra of this type" monad, the E-M should be the original category of such algebras
01:53:06 <ivanm> ManateeLazyCat: you want to put your email address in a darcs repo?
01:53:12 <ski> illissius : hm, how to replace `class C a b c | a b -> c , c -> a , c -> b' (e.g.) with type families ?
01:53:14 <ManateeLazyCat> ivanm: Yes.
01:53:17 <ivanm> so that "darcs send" will send it to you?
01:53:21 <ManateeLazyCat> ivanm: Yes.
01:53:31 <FunctorSalad> doesn't seem to do anything for topological spaces though
01:53:33 <ivanm> make a file _darcs/prefs/email and put your email address in there
01:53:43 <ManateeLazyCat> ivanm: Or i should build mail-list for receive patch?
01:53:45 <FunctorSalad> (discrete space/indiscrete space adjunctions to set)
01:53:59 <FunctorSalad> since these are just the identity on sets...
01:54:14 <FunctorSalad> (the 'free' functor)
01:54:17 <quicksilver> ski, illissius : I think they technical do obviate the need for MPTCs
01:54:31 <illissius> ski: forward-deps are replaced by associated types, backwards-deps can be done with superclass equality constraints, afaik
01:54:33 <ski> @wn obviate
01:54:34 <ivanm> ManateeLazyCat: up to you if you use a mailing list
01:54:35 <lambdabot> *** "obviate" wn "WordNet (r) 2.0"
01:54:35 <lambdabot> obviate
01:54:35 <lambdabot>      v 1: do away with [syn: {rid of}, {eliminate}] [ant: {necessitate}]
01:54:35 <lambdabot>      2: prevent the occurrence of; prevent from happening; "Let's
01:54:35 <lambdabot>         avoid a confrontation"; "head off a confrontation"; "avert
01:54:37 <lambdabot>         a strike" [syn: {debar}, {deflect}, {avert}, {head off}, {stave
01:54:39 <lambdabot>         off}, {fend off}, {avoid}, {ward off}]
01:54:41 <quicksilver> because you can always replace class Foo a b c with (effectively) class Foo (a,b,c)
01:54:44 <illissius> but i only know this because spj said so and haven't fully thought it through :)
01:55:12 <ManateeLazyCat> ivanm: Ok, i will put my mail to /prefs/email now, i will change it after i create mail-list.
01:55:21 <ivanm> that'd work as well
01:55:37 <ski> illissius : how do one know whether a dependency is "forward" or "backward" ?
01:55:43 <ManateeLazyCat> ivanm: BTW, i found another project also called "Manatee" (http://manatee.sourceforge.net/), it's a big problem with *same* name?
01:55:55 <ivanm> ManateeLazyCat: probably not
01:56:13 <ManateeLazyCat> ivanm: Becaust http://manatee.sourceforge.net/ i even can't create Manatee page at GoogleCode.
01:56:24 <ivanm> e.g. I have here in gentoo three different packages called "graphviz": the official one, my haskell one and a perl one
01:56:42 <ivanm> ManateeLazyCat: :o they won't let you just because there's a sourceforge page? :o
01:56:43 <ski> quicksilver : but then one possibly could make instances `Foo x' where `x' is not a triple type ..
01:56:45 <ivanm> that sucks
01:56:50 <ManateeLazyCat> ivanm: yes.
01:56:55 <ManateeLazyCat> ivanm: But it's GoogleCode.
01:57:09 <dolio> ski: class (c ~ T1 a b, a ~ T2 c, b ~ T3 c) => C a b c where type T1 a b ; type T2 c ; type T3 c
01:57:10 <ivanm> why would google code care what's on sourceforge?
01:57:14 * ski bewoes the absense of type tuples (or better, type records) in Haskell
01:57:15 <illissius> ski: basically you can do class Foo a b | a -> b with just an associated type, but if you also want to add b <- a you need a superclass equality constraint. my terminology is loose -- maybe 'unidirectional' and 'bidirectional' is better
01:57:34 <Saizan> ski: well, the class would require the projections as type families though
01:57:35 <ivanm> huh, that manatee looks serious though...
01:57:39 <ivanm> not some throw-away project
01:57:53 <ManateeLazyCat> ivanm: I don't understand, Google even don't allowe me create Manatee Page, just because have same name at SourceForge?
01:58:03 <ivanm> that's what I'm asking you!
01:58:07 <ski> Saizan : hm, i suppose that might be enough, in many cases, then ..
01:58:33 * ManateeLazyCat pasted "Google mail." at http://paste2.org/get/913151
01:58:34 <ManateeLazyCat> ivanm: ^^^^
01:58:35 <quicksilver> ski: yes, I'm not sure how much that matters. The instance type becomes just a token
01:58:58 * quicksilver isn't sure at all.
01:59:02 <ivanm> ManateeLazyCat: oh, so it's not automatic; sounds like the other manatee project already booked it
01:59:30 <illissius> quicksilver: by (effectively) class Foo (a,b,c) you mean class abc ~ (a,b,c) => Foo abc?
01:59:49 <Stalafin> i was recently wondering - considering the good scalability of haskell, are there people using haskell on gpgpus? what about haskell and this new processor by tilera (the tile* processors)?
01:59:58 <ivanm> ManateeLazyCat: so you have a few options: 1) completely rename your project; 2) use a slightly different name for googlecode (hs-manatee or something); 3) forget about googlecode and use github/patch-tag/code.haskell.org/etc.
02:00:19 <ivanm> Stalafin: there is some work on cuda backends, etc. for haskell
02:00:24 <ivanm> and I've never heard of tilera
02:00:42 <Stalafin> ivanm: check the wiki article; i think it's really interesting :)
02:01:06 <Stalafin> ivanm: one chip with 100 cpu's
02:01:16 <ski> @wiki Tilera
02:01:16 <lambdabot> http://www.haskell.org/haskellwiki/Tilera
02:01:24 <ivanm> heh
02:01:27 <ivanm> but it's for microprocessors rather than actual desktops?
02:01:44 <ManateeLazyCat> ivanm: I think i will drop GoogleCode since it don't support Darcs hosting...
02:01:56 <ivanm> well, barely anyone does
02:02:07 <ivanm> you've got c.h.o, patch-tag and darcsden (if it's up and running yet)
02:02:09 <ivanm> AFAIK, that's it
02:02:43 <Stalafin> ivanm: well, using that beast on desktops is gonna take quite a while i guess :-p stuck with x86 for now ::)
02:02:48 <ManateeLazyCat> ivanm: It's a problem i also named "Manatee"? I mean Trademark issue.
02:02:51 <Stalafin> ski: thanks; it's empty
02:03:07 <ManateeLazyCat> ivanm: I prefer patch-tag.com, c.h.o server break my heart... :)
02:03:18 <ivanm> heh
02:03:30 <ivanm> ManateeLazyCat: I don't think there's a trademark issue
02:03:41 <ManateeLazyCat> ivanm: Ok.
02:03:55 <ManateeLazyCat> ivanm: Do you know what's wrong with http://hackage.haskell.org/packages/archive/poppler/0.11.1/logs/failure/ghc-6.12 ?
02:04:05 <ManateeLazyCat> ivanm: My project need this package,
02:04:12 <ivanm> no, I had a look at that
02:04:12 <ManateeLazyCat> ivanm: But it can't build on hackage.
02:04:15 <ivanm> couldn't work it out though
02:04:19 <ivanm> preflex: seen dcoutts_ 
02:04:19 <preflex>  dcoutts_ was last seen on #haskell 9 days, 19 hours, 6 minutes and 37 seconds ago, saying: Flags class with to/fromFlags
02:04:21 <ivanm> preflex: seen dcoutts
02:04:22 <preflex>  dcoutts was last seen on #haskell 5 days, 16 hours, 39 minutes and 47 seconds ago, saying: * dcoutts is disappearing for a week
02:04:25 <ivanm> huh
02:04:39 <ivanm> ManateeLazyCat: I'd suggest you ask dcoutts, but it looks like he's away for another few days at least
02:05:11 <ManateeLazyCat> ivanm: I have upload all my project to patch-tag.com, for build it, need "darcs gtk2hs", "gio-branch" and "poppler" 
02:05:18 <ManateeLazyCat> ivanm: https://patch-tag.com/reposstarted 
02:05:38 <ManateeLazyCat> ivanm: Repository that beginning with manatee-*.
02:05:44 <ivanm> *nod*
02:05:56 <ivanm> sorry, but I"m not sure if I can help you out with that bug
02:06:08 * ivanm -> dinner
02:06:18 <ski> (Stalafin : .. as expected)
02:11:25 <quicksilver> illissius: actually I just meant class d where type a; type b; type c; and probably some projections/constraints.
02:11:34 <quicksilver> illissius: not sure about the details
02:12:53 <Saizan> .. type A d; type B d; type C d; .." and (A d) in place of a etc..
02:14:59 <illissius> and then you'd do instance FOo (a,b,c) where type A (a,b,c) = a, etc.?
02:15:02 <dolio> That encoding will contain non-standard instances, though.
02:15:34 <Saizan> illissius: yep
02:15:45 <illissius> (where a, b, and c are whatever conrete types you want, not variables)
02:16:09 <Saizan> though it'd be hard to use
02:16:22 <Saizan> because you'll have to add a 'd' parameter to all the methods
02:18:28 <Saizan> anyhow, i don't think anyone could make an argument for going that route
02:24:04 <illissius> Saizan: basically i was just wondering whether, if they ever actually end up standardizing TypeFamilies, there would still be any incentive/reason to add MultiParamTypeClasses as well
02:25:34 * ski wonders when local types will be added ..
02:26:35 <illissius> ski: what's that?
02:26:52 <ski> declaring `type's, `data's and `newtype's inside `where' and `let'
02:27:19 <ski> sometimes i've wanted such temporary types ..
02:27:32 <dolio> When we get first-class modules.
02:27:49 <ToRA> does anybody know where the repo for OpenGL / OpenGLRaw lives?
02:28:07 <ski> of course, those types couldn't leak out of their respective scopes .. a bit similar to existential unpackings, maybe
02:28:17 <ski> dolio : well, that's quite another thing
02:29:28 * ToRA finds it
02:30:59 <ski> (hm, i suppose there'd be some subtlety with defining `instance's in those local scopes .. specifically regarding functional dependencies (maybe re type families as well ?))
02:32:11 <Saizan> illissius: yeah, my last comment was on that, if that's how you encode MPTCs with type families then we do need MPTCs :)
02:32:15 <ski> one simple concrete example :
02:32:36 <ski>   zipWith :: forall a b c. (a -> b -> c) -> ([a] -> [b] -> [c])
02:33:22 <ski>   zipWith f as bs = build (\cons nil -> foldr (..) (..) as `unA` foldr (..) (..) bs)
02:34:07 <illissius> Saizan: could the class abc ~ (a,b,c) => Foo abc way work... ? it's unfortunate that we can't just try it out
02:34:08 <ski>   newtype A a b c = MkA (unA :: B a b c -> c)
02:34:16 <ski>   newtype B a b c = MkA (unA :: a -> B a b c -> c)
02:34:28 <dolio> illissius: That doesn't work because a, b and c are not in scope.
02:34:52 <illissius> i see :(
02:34:58 <ski> i'd much rather define `newtype A = ...' and `newtype B = ...' inside a `where'-clause attaching to the previous definition, as `A' and `B' are only temporary types anyway
02:35:22 <Saizan> dolio: are you sure that'd be a problem?
02:35:29 <dolio> Yes.
02:35:59 <dolio> You could do 'class abc ~ (A abc, B abc, C abc) => ...'.
02:36:03 <Saizan> maybe "class Foo abc where foo :: ((a,b,c) ~ abc) => ..."
02:36:27 <chrisdone> awe man, awesome. i've got two strings containing source. one is arbitrary, another is fully normalised and atomic. newtypes up in this mother
02:36:46 * chrisdone sings the enforce invariants in the type system song
02:46:47 <krey> Hi, i'm using Data.Bits to represent (operations on) sets of integers but I can't seem to figure out how to do membership testing, any ideas?
02:49:34 <quicksilver> krey: have you tried using IntSet? It's probably no slower. Might well be faster.
02:50:08 <quicksilver> krey: the answer to your question, though, is 'testBit'
02:50:11 <quicksilver> @hoogle testBit
02:50:12 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
02:51:10 <ManateeLazyCat> I found hackage can't build my poppler package, can anyone help me test "cabal install poppler"? Thanks
02:51:39 <krey> quicksilver: wow, there's something called IntSet? no need to reinvent it then, thanks :)
02:51:46 <ski> > testBit (-1 :: Integer) 100
02:51:47 <lambdabot>   True
02:52:36 <ManateeLazyCat> @tell dcoutts_ I upload my poppler package to http://hackage.haskell.org/package/poppler-0.11.1 , i can install it on my box, but i don't why hackage can't build it somehow, can you help me look it?
02:52:36 <lambdabot> Consider it noted.
02:53:08 <exDM69> @type testBit
02:53:09 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
02:53:17 <ManateeLazyCat> ivanm: Can you help me test one package?
02:53:24 <ivanm> depends what it is
02:53:30 <ski> > testBit (-1 - 1/9 :: Rational) 100
02:53:32 <lambdabot>   No instance for (Data.Bits.Bits GHC.Real.Rational)
02:53:32 <lambdabot>    arising from a use of...
02:53:35 <ski> bah !
02:53:36 <quicksilver> ski: weird.
02:53:38 <ManateeLazyCat> ivanm: I need know it whether can install by other people.
02:53:42 <quicksilver> ski: how does the bits instance for Integer work?
02:53:43 <ski> quicksilver : which ?
02:53:51 <ivanm> poppler?
02:53:51 <ManateeLazyCat> ivanm: "cabal install poppler"
02:53:55 <ManateeLazyCat> ivanm: Yes.
02:53:59 <ivanm> k
02:54:09 * ivanm was going to wipe his ~/.cabal anyway, so might as well
02:54:09 <ManateeLazyCat> ivanm: If it can install your box, it's a bug of hackage.
02:54:12 <ManateeLazyCat> ivanm: Thanks.
02:54:16 <ski> quicksilver : presumably `-1' has all bits set, `-2' has all bits set, except the least significant, &c.
02:54:21 <ManateeLazyCat> ivanm: You use Debian?
02:54:23 <ivanm> ManateeLazyCat: what is the build tools package I need to install first?
02:54:25 <ivanm> ManateeLazyCat: nope, gentoo
02:54:26 <Heffalump> ManateeLazyCat: can poppler manipulate pdfs?
02:54:45 <ManateeLazyCat> ivanm: libpoppler-glib-dev
02:54:50 <quicksilver> ski: an infinite extension of 2s complement?
02:54:53 * quicksilver had never heard of this
02:54:56 <ivanm> ManateeLazyCat: no, the haskell package with the build tools
02:54:59 <ski> (like some kind of extended 2's complement .. or like mechanical cipher display, when counting down)
02:55:22 <ManateeLazyCat> ivanm: gtk2hs-buildtools, glib, gtk
02:55:26 <ManateeLazyCat> ivanm: gtk2hs-buildtools, glib, gtk, cairo
02:55:27 <ivanm> that's the one
02:55:44 <ski> > testBit (-1 :: Integer) `map` [0..]
02:55:45 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
02:55:48 <ski> > testBit (-2 :: Integer) `map` [0..]
02:55:49 <lambdabot>   [False,True,True,True,True,True,True,True,True,True,True,True,True,True,Tru...
02:55:54 <ski> > testBit (2 :: Integer) `map` [0..]
02:55:55 <lambdabot>   [False,True,False,False,False,False,False,False,False,False,False,False,Fal...
02:56:35 <ski> (quicksilver : slightly remniscent of `p'-adic numbers as well, i suppose)
02:57:13 <ManateeLazyCat> ivanm: YOu need install developer file of poppler-glib-0.12.4 or higher, then install "cabal install gtk2hs-buildtools gtk poppler"
02:57:39 <ivanm> Heffalump: with your Constraints/Suitable stuff in RMonad, can you think of any way something like that can be defined to work with something like "data instance Constraints Bytestring Word8 = ..." such that RFunctor would still make sense? (i.e. for Bytestring, only Word8 -> Word8 mappings would be allowed)
02:57:54 <ivanm> ManateeLazyCat: this is gentoo... we don't have no stinkin' dev packages ;-)
02:57:56 <ManateeLazyCat> ivanm: If gentoo repository haven't poppler-glib, you can dowenload it from http://poppler.freedesktop.org/releases.html
02:58:07 <ivanm> yes, we have it ;-)
02:58:17 <ManateeLazyCat> ivanm: Can you help me test it?
02:58:27 <ivanm> hang on, it takes a while for it all to build!
02:58:32 <krey> Is it possible/sensible to use a zipper for a cyclic maze?
02:58:33 <ManateeLazyCat> ivanm: Thanks.
02:58:41 <ManateeLazyCat> ivanm: http://patch-tag.com/r/AndyStewart
02:58:42 <Jonno_FTW> how do I get y from the maximum x in  [(x,y)]
02:58:43 <Jonno_FTW> ?
02:58:51 <ivanm> ugh, it obviously doesn't know my $PATH :s
02:59:04 <ivanm> "setup: gtk2hsC2hs is required but it could not be found."
02:59:11 <ManateeLazyCat> ivanm: http://patch-tag.com/r/AndyStewart is my repository at patch-tag.com , if poppler okay, i can release gtk2hs-0.11.1 and my project.
02:59:16 <ivanm> even though gtk2hsC2hs is in my $PATH :s
02:59:26 <ManateeLazyCat> ivanm: build link in ~/.cabal/bin/
02:59:37 <ivanm> yeah, I have that
02:59:37 <ManateeLazyCat> ivanm: gtk2hsC2hs at ~/.cabal/bin/
02:59:59 <ivanm> ManateeLazyCat: I get this when it tries to build cairo and glib: warning: #warning Setup.hs is guessing the version of Cabal. If compilation of Setup.hs fails use -DCABAL_VERSION_MINOR=x for Cabal version 1.x.0 when building (prefixed by --ghc-option= when using the 'cabal' command)
03:00:11 <ivanm> ~/.cabal/bin is already in my $PATH
03:00:12 <ManateeLazyCat> ivanm: Ignore it. :)
03:00:30 <ManateeLazyCat> ivanm: Can you do "which gtk2hsC2hs" ?
03:00:36 <ivanm> yes
03:01:00 * ivanm randomly tries rebuilding cabal-install
03:01:52 <ManateeLazyCat> ivanm: If you can install poppler, you can bulid my project for a try. :)
03:01:57 <ivanm> ugh, sorted it out
03:02:03 <ivanm> no, wait, I didn't :@
03:02:25 <ivanm> Jonno_FTW: what do you mean?
03:02:35 <ski> hm .. how do i split a number in the integral and the fractional part ?
03:02:39 <ManateeLazyCat> ivanm: So still can't found gtk2hsC2hs ?
03:02:42 <ivanm> nope
03:02:55 * ivanm tries setting his $PATH again
03:03:02 <ManateeLazyCat> ivanm: What say "which gtk2hsC2hs" ?
03:03:14 <ski> krey : not easily, at least
03:03:40 <krey> ski: ok, won't bother then, thanks
03:03:43 <Jonno_FTW> ivanm: I have a list of tuples [(x,y)]. I want the maximum value of x's corresponding y value
03:03:46 <ivanm> aha, got it!
03:03:49 <ski> (krey : i used a zipper for a non-cyclic (except trivial cycles) maze quite well, though)
03:03:54 <ivanm> using ~ in my PATH didn't work :@
03:04:09 <ivanm> Jonno_FTW: so for each x what is the maximum y value?
03:04:29 <ManateeLazyCat> ivanm: I use "PATH=$PATH:~/.cabal/bin", can work. 
03:04:40 <ski> .. ah
03:04:45 <Jonno_FTW> ivanm: no, the maximum in the list of tuples
03:04:46 <ski> @type properFraction
03:04:47 <ski> it is
03:04:47 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
03:04:47 <ivanm> @type maximumBy (compare `on` snd) . groupBy ((==) `on` fst) . sortBy (compare `on` fst)
03:04:49 <lambdabot>     Couldn't match expected type `(a, b)'
03:04:49 <lambdabot>            against inferred type `[(a1, b1)]'
03:04:49 <lambdabot>       Expected type: [(a, b)]
03:05:14 <ivanm> @type map (maximumBy (compare `on` snd)) . groupBy ((==) `on` fst) . sortBy (compare `on` fst)
03:05:15 <lambdabot> forall a b. (Ord b, Ord a) => [(a, b)] -> [(a, b)]
03:05:21 <ivanm> Jonno_FTW: so just the maximum y value?
03:05:26 <ivanm> or the maximum x value?
03:05:31 <Jonno_FTW> y
03:05:33 <ivanm> > snd . maximumBy (compare `on` fst)
03:05:34 <lambdabot>   Overlapping instances for GHC.Show.Show ([(a, b)] -> b)
03:05:34 <lambdabot>    arising from a u...
03:05:38 <ivanm> @type snd . maximumBy (compare `on` fst)
03:05:39 <lambdabot> forall a b. (Ord a) => [(a, b)] -> b
03:05:57 <Heffalump> ivanm: so you want to use something of kind * as the "container"?
03:06:03 <exDM69> @type on
03:06:04 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:06:07 <ivanm> Heffalump: yup
03:06:24 <Heffalump> is wrapping it ok?
03:06:32 <ManateeLazyCat> Heffalump: poppler just can view.
03:06:37 <ManateeLazyCat> Heffalump: Can't edit.
03:06:52 <Heffalump> ManateeLazyCat: pity, I need to change some PDFs around
03:06:54 <ManateeLazyCat> Heffalump: Infact, poppler is base on xpdf-3.0 code.....
03:06:56 <ivanm> Heffalump: what do you mean by wrapping it? creating a dummy type around Bytestring with a phantom type or something?
03:06:56 <ski> > properFraction `map` [-1.5,0,1.5]
03:06:57 <lambdabot>   [(-1,-0.5),(0,0.0),(1,0.5)]
03:07:01 <Heffalump> ivanm: yeah
03:07:21 <ivanm> I'd rather not; I was wondering if a generic way of doing that would work
03:07:22 <Heffalump> just thinking out loud really, but I can't see any other way it could work
03:07:33 <ski> @let integralPart :: (RealFrac q,Integral i) => q -> i; integralPart = fst . properFraction
03:07:35 <lambdabot>  Defined.
03:07:39 <ski> @let fractionalPart :: RealFrac q => q -> q; fractionalPart = snd . properFraction
03:07:41 <lambdabot>  Defined.
03:07:42 <ivanm> yeah, I dind't think so either :(
03:07:50 <Heffalump> even if we had polymorphic kinds in GHC, it wouldn't really make sense to say "ByteString Word8".
03:08:04 <ivanm> just trying to think of a way of writing a new version of something like Edison
03:08:16 <Heffalump> which would be the inevitable consequence of using ByteString in that parameter position
03:08:18 * ski 'd like to say `integralPart &&& fractionalPart = properFraction'
03:08:38 <ivanm> Heffalump: yeah
03:08:41 <ManateeLazyCat> Heffalump: Perhaps poppler will support edito in the future version.
03:08:52 <ivanm> ski: pattern matching on functions?
03:09:02 <ivanm> Heffalump: there is hPDF on hackage IIRC...
03:10:00 <ManateeLazyCat> Heffalump: Maybe you can edit Tex file and generate PDF by Tex?
03:10:20 <ski> ivanm : well, in this case, `f &&& g' and `(f,g)' determines each other, so ..
03:10:23 <ivanm> pdf2html, then use pandoc? :p
03:10:55 <ski> ivanm : sometimes i'd like to shorten `foo (Blah x) = bar (baz x)' to `foo . Blah = bar . baz', as well
03:11:25 <ManateeLazyCat> ivanm: Any luck with poppler package?
03:11:29 <ivanm> ski: hmmm...
03:11:37 <ivanm> ManateeLazyCat: just finished; seemed to build successfully
03:11:52 <ivanm> this is with 6.12.3 + cabal 1.8.0.6
03:12:05 <ivanm> maybe hackage is still using the buggy 6.12.2 release?
03:12:31 <Heffalump> ManateeLazyCat: I know other command-line tools to do it with from Linux, I'd just like something already bound to haskell
03:12:56 <ManateeLazyCat> ivanm: Can you do "ghci -package poppler-0.11.1" for a test?
03:13:11 <ski> (ivanm : possibly this could be considered a case of view patterns .. not sure)
03:13:32 <ManateeLazyCat> ivanm: Yeap, looks it's a bug of hackage, not my problem.
03:13:33 <ivanm> ManateeLazyCat: doesn't work here because of how gentoo has stupid static linking scripts that ghci can't deal with :@
03:13:40 <ivanm> ski: no idea :s
03:13:52 <ManateeLazyCat> ivanm: Why not use Debian?
03:14:04 <ivanm> because I don't want to...
03:15:24 <ManateeLazyCat> ivanm: What's the result of "pkg-config --modversion poppler-glib" ?
03:15:44 <ManateeLazyCat> ivanm: I want to make sure all poppler-glib-0.12.4 can compile pass.
03:15:46 <ivanm> 0.14.1
03:15:49 <TacticalGrace> kamatsu: In Haskell every time is inhabited, by \bottom (aka 'undefined')  that is why Haskell type system is not a sound logic (in contrast to Agda)
03:15:54 <ManateeLazyCat> ivanm: Bad,
03:15:58 <ivanm> why?
03:16:28 <ManateeLazyCat> ivanm: Because i binding poppler-glib-0.14.0, but Debain base system (Ubuntu) just has poppler-glib-0.12.4
03:16:28 <TacticalGrace> kamatsu: the problem with checking that a family has an instance is that that can change from one module to the next
03:16:46 <ivanm> ManateeLazyCat: one reason why I don't use debian :p
03:16:51 <TacticalGrace> kamatsu: What do you need that for?
03:17:03 <ManateeLazyCat> ivanm: I'm afraid user that just have poppler-glib-0.12.4 will build failed
03:17:20 <ivanm> *shrug*
03:17:33 <ManateeLazyCat> ivanm: Most user haven't power play gentoo. :)
03:17:59 <ManateeLazyCat> ivanm: I have a friend use 1 weeks build him gentoo, and i just need 2 hours on Debain... .:)
03:18:33 <ivanm> *shrug* each to their own
03:18:59 <ManateeLazyCat> Heffalump: Do you use Debian or Ubuntu 10.04? Can you help me test "cabal install poppler" ?
03:20:21 * ManateeLazyCat uninstall poppler-glib-0.14.0 to install poppler-glib-0.12.4
03:22:40 * hackagebot hamlet 0.4.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.4.0 (MichaelSnoyman)
03:22:42 * hackagebot web-routes-quasi 0.5.0 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.5.0 (MichaelSnoyman)
03:22:44 * hackagebot persistent 0.1.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.1.0 (MichaelSnoyman)
03:22:47 * hackagebot persistent-postgresql 0.1.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.1.0 (MichaelSnoyman)
03:22:49 * hackagebot yesod 0.4.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.4.0 (MichaelSnoyman)
03:23:08 <Heffalump> ManateeLazyCat: sure
03:23:51 * hackagebot persistent-sqlite 0.1.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.1.0 (MichaelSnoyman)
03:23:54 <ivanm> hackage spam! :p
03:23:55 <ManateeLazyCat> Heffalump: Thanks a lot. You just need install libpoppler-glib-dev by aptitude, then do "cabal install gtk2hs-buildtools poppler".
03:25:28 <ski> hm .. how to write `divMod_RealFrac :: (RealFrac q,Integral i) => q -> q -> (i,q)' ?
03:26:05 <Heffalump> ManateeLazyCat: yep, just did that. Seems fine.
03:26:13 <Heffalump> I already had gtk2hs-buildtools (and gtk2hs)
03:26:20 <ManateeLazyCat> Heffalump: "ghci -package poppler-0.11.1" ?
03:26:39 <Heffalump> gets to a ghci prompt fine
03:27:07 <ManateeLazyCat> Heffalump: Your install libpoppler-glib-dev from source of Ubuntu-10.04?
03:27:37 <ski> > let divMod_RealFrac n d = (* d) `fmap` properFraction (n / d) in divMod_RealFrac 17.2 7.3  -- approximation of it
03:27:38 <lambdabot>   (2,2.6000000000000005)
03:27:43 <Heffalump> ManateeLazyCat: yes
03:27:57 <ManateeLazyCat> Heffalump: Last confirm, "pkg-config --modversion poppler-glib". 
03:28:06 <ManateeLazyCat> Heffalump: Is 0.12.4 ?
03:28:08 <zygoloid> :( i cannot upgrade cabal-install because my version of cabal-install is too old
03:28:16 <Heffalump> ManateeLazyCat: yes
03:28:29 <ManateeLazyCat> Heffalump: Ok, thank you very much!
03:28:34 <ManateeLazyCat> Heffalump: I'm happy now.
03:28:38 <ManateeLazyCat> :)
03:29:10 <ManateeLazyCat> Haha, now just need release gtk2hs-0.11.1
03:29:27 <ski> > let divMod_RealFrac n d = (* d) `fmap` properFraction (n / d) in divMod_RealFrac (120 % 17) (18 % 7)
03:29:28 <lambdabot>   (2,228 % 119)
03:31:09 <ManateeLazyCat> ivanm: If you want try my system, you can get source code from http://patch-tag.com/r/AndyStewart
03:31:10 <laufbaum> :q
03:31:27 <ivanm> not atm; a tad busy
03:31:28 <ManateeLazyCat> ivanm: Need "darcs version gtk2hs" and "http://patch-tag.com/r/AndyStewart/gio-branch/home"
03:31:33 <ivanm> laufbaum: doesn't work here sorry ;-)
03:31:34 <ski> > let divMod_RealFrac n d = (* d) `fmap` properFraction (n / d) in divMod_RealFrac pi (atan 1)
03:31:35 <lambdabot>   (4,0.0)
03:31:36 <kamatsu> TacticalGrace: I think I can do what I want to do using just an ordinary typeclass, actually, let me try and figure it out
03:32:47 <ManateeLazyCat> Thanks all for help! :) Need off now...
03:40:16 <kamatsu> Okay, now what I need to do is do one thing if a type is an instance of a type class, and another thing if it isn't.
03:40:20 <kamatsu> that's impossible isn't it..
03:40:21 <kamatsu> hm
03:41:51 * hackagebot yesod-examples 0.4.0 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.4.0 (MichaelSnoyman)
03:53:37 <Bacta> I just downloaded hugs but cannot get anything to run in the 'console' ... Python coder here
03:53:55 <Bacta> Is the console not interactive like it is with python?
03:55:59 <ivanm> Bacta: you can't define data structures or type classes at the prompt
03:56:06 <ivanm> you can define new values and functions, but it's messy
03:56:28 <Bacta> But I can't go `hello = "world"` can I?
03:56:29 <ivanm> the general approach is to write your definitions in a file (say Foo.hs) and then load that ("hugs Foo.hs")
03:56:41 <ivanm> Bacta: you can like this: let hello = "world"
03:56:56 <Bacta> Sounds like a file is the better approach
03:56:58 <ivanm> HBC let you define data structures, etc. apparently, but it's a bit long in the tooth
03:57:09 <ivanm> Bacta: any particular reason for not using ghci rather than hugs?
03:57:36 <Bacta> I did a bit of Haskell at university using hugs ... It just came to mind
03:57:57 <Twey> GHC is what all the big boys use nowadays.
03:58:29 <TacticalGrace> kamatsu: ok
03:58:33 <ivanm> the only real reasons for using hugs are due to its size and portability
03:59:12 <Bacta> So what can Haskell be used for besides solving Project Euler problems?
03:59:31 <bremner> s/haskell/any programming language/
04:00:02 <SubStack> Bacta: I use it for underwater ROVs
04:00:14 <ivanm> s/any programming language/any turing-complete programming language/
04:00:19 <ivanm> SubStack: oooohhhh..... sounds cool!
04:00:21 <alpounet> @hoogle trace
04:00:21 <lambdabot> Debug.Trace trace :: String -> a -> a
04:00:21 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
04:00:21 <lambdabot> module Debug.Trace
04:00:46 <bremner> ivanm: what are non-turing complete programming languages? it sounds like an oxymoron to me.
04:00:53 <Bacta> I've always imagined using it for embedding AI into games
04:01:00 <ivanm> bremner: IIRC, agda and coq aren't
04:01:09 <bremner> oh, weird. 
04:01:13 <ivanm> SQL isn't
04:01:27 <SubStack> ivanm: http://github.com/substack/underwater-rov-2010 
04:01:28 <kamatsu> TacticalGrace: ah, now the problem has resurfaced where I am trying to do something if something is an instance of a type class and something else if it is not.
04:01:32 <Bacta> SQL or PL/SQL?
04:01:35 <ivanm> SQL
04:01:37 <bremner> I wouldn't call SQL a programming language
04:01:40 <ivanm> PL/SQL is turing complete
04:01:44 <ivanm> bremner: some do *shrug*
04:01:50 <SubStack> haskell stuff is in control/
04:02:01 <Bacta> ivanm: I used to work for a company that implemented their entire business logic layer in PL/SQL :(
04:02:07 <ivanm> ugh
04:02:20 <ivanm> SubStack: a blog post or something on this would be cool
04:02:30 <SubStack> yes, planning on it
04:02:44 <bremner> ivanm: yeah, ok. I guess programming language isn't really a technical term.
04:02:46 <SubStack> also gearing up to announce a startup, so I'm super busy
04:02:58 <Twey> ivanm: I think Agda is, since it has the partiality monad (?)
04:02:58 <ivanm> bremner: yup
04:03:02 <ivanm> SubStack: cool
04:03:09 <Twey> No idea about Coq
04:03:15 <ivanm> Twey: I'm going off what someone (copumpkin?) told me here; I'm quite possibly mistaken
04:03:20 <kamatsu> TacticalGrace: seeing as that's not possible (afaik), i think i'm out of luck
04:03:33 <Jonno_FTW> how can I stop a number using scientific notation for Doubles?
04:03:39 <Jonno_FTW> > 1/179
04:03:41 <lambdabot>   5.58659217877095e-3
04:03:41 <Twey> Jonno_FTW: Numbers don't use notation
04:03:42 <ivanm> for show?
04:03:48 <dolio> Agda is not Turing complete if you expect programs to pass the termination checker.
04:03:52 <ivanm> the Numeric module has some pretty-printers
04:03:55 <dolio> And assuming there aren't any paradoxes.
04:03:57 <Bacta> Agda?
04:04:01 <Jonno_FTW> i would like to start it at 0.01234...
04:04:03 <Bacta> Is BrainFuck turing complete?
04:04:11 <ivanm> Jonno_FTW: see Numeric (comes with GHC)
04:04:14 <ivanm> Bacta: I believe so
04:04:23 <Twey> Bacta: Yes
04:05:42 <ivanm> ugh, it appears hpaste is getting full of spam again
04:08:36 <bremner> Bacta: that is the whole point of BF
04:22:37 * byorgey makes haggis with neeps and lambdas
04:22:55 <ivanm> what are neeps?
04:23:05 <byorgey> mashed rutabagas
04:23:09 <byorgey> quite delicious
04:23:57 <byorgey> if you can't tell I was just in Scotland =)
04:24:53 <ivanm> well, you might have been aclimatising yourself to go there...
04:25:07 <ivanm> you're at MSR atm, aren't you?
04:25:08 <byorgey> hehe, true
04:25:18 <byorgey> yep
04:25:33 <ivanm> aha, rutabagas are swedes...
04:26:03 <byorgey> yes, or "yellow turnips" apparently
04:26:23 * hackagebot yesod 0.4.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.4.0.1 (MichaelSnoyman)
04:27:14 <Jonno_FTW> I can't work out this Numeric lbrary
04:27:36 <Jonno_FTW> > showFloat 1.234
04:27:36 <ivanm> if I want to visualise class hierarchies as a graph, what's the better way of doing it?
04:27:37 <lambdabot>   Overlapping instances for GHC.Show.Show
04:27:37 <lambdabot>                              (GHC.B...
04:27:48 <ivanm> Num -> Integral, or Integral -> Num ?
04:28:07 <Jonno_FTW> :t showFloat
04:28:08 <ivanm> > showFloat 1.234 ""
04:28:09 <lambdabot> forall a. (RealFloat a) => a -> String -> String
04:28:09 <lambdabot>   "1.234"
04:28:17 <ivanm> @type ShowS
04:28:18 <lambdabot> Not in scope: data constructor `ShowS'
04:28:20 <ivanm> bah
04:28:31 <ivanm> Jonno_FTW: type ShowS = String -> String
04:29:06 <Jonno_FTW> > showFlot (1/17) ""
04:29:08 <lambdabot>   Not in scope: `showFlot'
04:29:11 <Jonno_FTW> > showFloat (1/17) ""
04:29:13 <lambdabot>   "5.8823529411764705e-2"
04:29:15 <byorgey> ivanm: the Haskell 98 report used Num -> Integral, dunno if that means it's better though
04:29:26 * hackagebot yesod 0.4.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.4.0.2 (MichaelSnoyman)
04:29:27 <Jonno_FTW> i don't want the e-2 part though
04:29:41 <ivanm> hmmm...
04:30:04 <ivanm> > showFFloat (1/17) ""
04:30:05 <byorgey> http://www.haskell.org/onlinereport/basic.html#sect6.3
04:30:06 <lambdabot>   No instance for (GHC.Real.Fractional
04:30:06 <lambdabot>                     (Data.Maybe.Maybe ...
04:30:15 <ivanm> oh, right, it wants a precision
04:30:33 <ivanm> > showFFloat Nothing (1/17) ""
04:30:35 <lambdabot>   "0.058823529411764705"
04:30:38 <ivanm> Jonno_FTW: ^^
04:30:43 <Jonno_FTW> ahh
04:30:44 <Jonno_FTW> thanks
04:30:54 <ivanm> tah byorgey 
04:30:57 <ivanm> *ta
04:35:23 <ski> ivanm : Hugs doesn't support bindings ..
04:35:42 <ivanm> oh?
04:35:44 <ivanm> *shrug*
04:40:22 <roconnor> > 1/17 :: CReal
04:40:23 <lambdabot>   0.0588235294117647058823529411764705882353
04:40:44 <roconnor> :O, showFFloat isn't rounding correctly
04:40:51 <roconnor> scandelous.
04:41:45 <roconnor> hmm, maybe it is due to binary rounding followed by decimal rounding
04:42:28 <ski> @hoogle showFloatAtBase
04:42:28 <lambdabot> No results found
04:46:36 <nominolo> preflex: seen chrisdone
04:46:36 <preflex>  chrisdone was last seen on #haskell 2 hours, 9 minutes and 50 seconds ago, saying: * chrisdone sings the enforce invariants in the type system song
04:50:07 <Jonno_FTW> t/redraw
04:55:39 <Jonno_FTW> is there a way to track where an error is occuring in a pattern match?
04:55:59 <Jonno_FTW> actually, nvm
04:57:31 <chrisdone> use -Wall
04:58:17 <Jonno_FTW> I have a pattern match
04:58:36 <Jonno_FTW> and I don't know why an error is occuring with !!
04:58:37 <chrisdone> put it down, it's got germs on it
04:58:44 <chrisdone> what is the error?
04:58:58 <Jonno_FTW> | (2*a) > (length x) = 0 |   (x !! a) == (x !! (2*a)) = a
04:59:06 <chrisdone> the `=`
04:59:08 <Jonno_FTW> I get an index too large error on !!
04:59:17 <chrisdone> oh right
04:59:29 <chrisdone> that's not a pattern, that's just a regular function call
04:59:44 <chrisdone> > [1,2,3] !! 9999 
04:59:45 <lambdabot>   *Exception: Prelude.(!!): index too large
04:59:51 <ben> Well, it is inside a pattern guard or whatever they are called
04:59:57 <Jonno_FTW> but shouldn't the first part catch that though?
05:00:06 <ben> and the first case looks like it should prevent a from being too large as far as I can tell
05:00:06 <chrisdone> > let getByIndex = (!!) in getByIndex [1,2,3] 9999 
05:00:07 <lambdabot>   *Exception: Prelude.(!!): index too large
05:00:24 <chrisdone> no
05:00:28 <chrisdone> it should be >=
05:00:35 <chrisdone> > [1,2,3] !! 0
05:00:35 <chrisdone> > [1,2,3] !! 3
05:00:36 <lambdabot>   1
05:00:36 <lambdabot>   *Exception: Prelude.(!!): index too large
05:00:41 <chrisdone> indexes start at zero
05:00:43 <noteed> Jonno_FTW: no it catches the second indexing, not the first one
05:00:50 <ben> I see I am not awake enough to help people on irc
05:01:28 <Jonno_FTW> i see now
05:01:34 <chrisdone> ;D
05:01:44 <chrisdone> that's an easy mistake to make
05:01:46 <noteed> Jonno_FTW: i.e. a can be between length x and 2*a
05:01:50 <chrisdone> off-by-1 errors
05:04:02 <Jonno_FTW> My pattern match still has logic errors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27403#a27403
05:04:25 <Jonno_FTW> I don't know why it get stuck on fractions like 0.5
05:05:13 <noteed> Jonno_FTW: length x is never equal to 1
05:05:27 <Jonno_FTW> how come?
05:05:48 <noteed> Jonno_FTW: because you have x@n:m:ns), which is a list of at least two elements
05:06:51 <noteed> > length (undefined:undefined:[])
05:06:52 <lambdabot>   2
05:07:03 <Jonno_FTW> interesting
05:07:21 <ben> > 1:2:[]
05:07:22 <lambdabot>   [1,2]
05:09:09 <hpc> > []:[]:[]
05:09:10 <lambdabot>   [[],[]]
05:09:55 <chrisdone> > fix ([]:)
05:09:56 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
05:10:15 <chrisdone> []:<
05:10:21 <Jonno_FTW> hehehe
05:10:42 <hpc> > fix (:[])
05:10:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
05:11:17 <chrisdone> hpc: that would be like
05:11:17 <chrisdone> > fix Just
05:11:18 <lambdabot>   Occurs check: cannot construct the infinite type:
05:11:18 <lambdabot>    a = Data.Maybe.Maybe a
05:11:21 <zygoloid> the robot combinator is not broken and cannot be fixed
05:12:24 <hpc> > fix (join . Just)
05:12:28 <lambdabot>   mueval-core: Time limit exceeded
05:12:39 <hpc> i see
05:13:21 <chrisdone> :t fix
05:13:22 <lambdabot> forall a. (a -> a) -> a
05:13:27 <chrisdone> :t (undefined:)
05:13:28 <lambdabot> forall a. [a] -> [a]
05:13:30 <chrisdone> :t Just
05:13:31 <lambdabot> forall a. a -> Maybe a
05:14:00 <chrisdone> :t (:undefined)
05:14:01 <lambdabot> forall a. a -> [a]
05:14:14 <chrisdone> so you can see why (x:) makes sense but (:x) or Just doesn't
05:15:13 <zygoloid> > let f :: Show x => x -> String; f x = show [f x] in f []
05:15:14 <lambdabot>   "[\"[\\\"[\\\\\\\"[\\\\\\\\\\\\\\\"[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"[\\\\\\...
05:15:23 <chrisdone> hpc: right?
05:16:36 <chrisdone> is there a PEG -> Haskell parser generator knocking about?
05:16:36 <hpc> yeah, i ssee
05:16:50 <dolio> There are a couple.
05:17:01 <chrisdone> one which is formatted like this:
05:17:01 <chrisdone> x <- a   { \x -> Foo x } -- or whatever
05:17:09 <dolio> Frisby is a parser combinator library.
05:17:14 <dolio> And there's another that's a generator...
05:17:17 <dolio> Pappy maybe?
05:17:19 <chrisdone> hmm it can't be a combinator, i need a generator
05:17:23 <chrisdone> thanks i'll check that out
05:17:33 <exDM69> chrisdone: why must you use a generator
05:18:01 <chrisdone> awesome. i wonder why this isn't a hackage package
05:18:03 <quicksilver> combinators can be generators.
05:18:20 <chrisdone> exDM69: because i'm using two different languages and i only want to maintain one grammar
05:18:24 <quicksilver> the boundary is not particularly clear.
05:18:45 <quicksilver> you could do that by making it a parameter to the combinators, chrisdone 
05:19:06 <quicksilver> the S-D parser combinators are generator-like
05:19:19 <quicksilver> (in that they have a static analysis / optimisation element)
05:19:45 <chrisdone> i don't know if i feel like rewriting my parser to another syntax
05:20:59 <chrisdone> what are S-D parser combinators?
05:21:59 <ski> (Swierstra-Duponchel ?)
05:22:52 <noteed> chrisdone: what does the syntax look like?
05:23:00 <chrisdone> it's just PEG syntax
05:23:40 <noteed> chrisdone: I mean, the syntax of your two languages
05:23:51 <chrisdone> one is haskell, one is javascript
05:24:23 <noteed> chrisdone: ok
05:25:26 <chrisdone> quicksilver: it might be a good idea to use combinators to generate parser syntax seeing as i want to couple the conversion to AST process
05:26:07 <chrisdone> x <- foo { {x:$1} } -- JS
05:26:07 <chrisdone> x <- foo { X $1 } -- Haskell
05:28:57 <dancor> i have ghc 6.12.1 but when i try to cabal-install hint it says "cabal: cannot configure hint-0.3.2.3. It requires ghc >6.6"
05:29:39 <chrisdone> pappy needs packaging and sticking on hackage anyway, i'll do that while i remember
05:30:36 <chrisdone> dancor: what does ghc --version show?
05:31:49 <dancor> chrisdone: The Glorious Glasgow Haskell Compilation System, version 6.12.1
05:32:09 <chrisdone> dancor: how many versions of GHC do you have installed?
05:32:23 <Saizan> dancor: it's referring to the "ghc" package, does "ghc-pkg check" report any problem?
05:32:26 <chrisdone> actually, 6.6 was a long time ago. sounds more serious
05:32:30 <dancor> chrisdone: one.  this is a new computer and i installed it via archlinux
05:33:06 <Saizan> dancor: or, "ghc-pkg list ghc", maybe the ghc lib is in another archlinux package..
05:34:00 <Saizan> (pacman -Ss ghc reports only one package though..)
05:36:07 <chrisdone> hmm. -v is a useful flag for Cabal (verbose)
05:36:23 <chrisdone> maybe that will give more information about what it's doing
05:36:56 <chrisdone> Reading installed packages...
05:36:56 <chrisdone> /home/chris/Programs/bin/ghc-pkg dump --global
05:36:56 <chrisdone> /home/chris/Programs/bin/ghc-pkg dump --user
05:37:05 <chrisdone> do you see ghc in any of those lists?
05:37:21 <Saizan> that's the same as doing "ghc-pkg list ghc"
05:37:22 <chrisdone> ghc-pkg list --global | grep ghc
05:37:29 <chrisdone> w/e
05:37:35 <chrisdone> is the package installed?
05:38:06 <dancor> no.  i'm going to reinstall ghc from archlinux and everythign
05:38:10 <chrisdone> hmmm
05:38:14 <chrisdone> but that's a fresh install?
05:38:26 <chrisdone> sounds like a bug if so and you should report it
05:38:37 <chrisdone> what steps did you take to install?
05:44:18 <Jonno_FTW> How can I have Haskell give me a fraction to a specified number of decimal places of precision?
05:45:21 <Jonno_FTW> or dI have to implement long division?
05:45:37 <dancor> i imagine it's better not to go thru a double
05:48:44 <kmc> > (1 % 3) * (10^5)
05:48:45 <lambdabot>   100000 % 3
05:48:50 <kmc> > floor ((1 % 3) * (10^5))
05:48:51 <lambdabot>   33333
05:49:03 <kmc> > floor ((22 % 7) * (10^5))
05:49:04 <lambdabot>   314285
05:49:12 <kmc> Jonno_FTW, ^^^^
05:50:14 <Jonno_FTW> thanks
05:50:57 <illissius> @hoogle (a -> Bool) -> a -> Maybe a
05:50:57 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
05:50:58 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
05:50:58 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
05:56:52 <kmc> :t \p x -> guard (p x) >> return x
05:56:54 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
05:57:00 <kmc> @hoogle (MonadPlus m) => (b -> Bool) -> b -> m b
05:57:00 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
05:57:00 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
05:57:00 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
05:57:25 <kmc> @pl \p x -> guard (p x) >> return x
05:57:25 <lambdabot> (`ap` return) . (((>>) . guard) .)
05:57:32 <Axman6> :(
05:58:34 <kmc> :t \p x -> ([const Nothing, Just] !! fromEnum (p x)) x
05:58:35 <lambdabot> forall b a. (Enum a) => (b -> a) -> b -> Maybe b
06:01:39 <Jonno_FTW> What is wrong my cycle detection for the decimal part of a number here?: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27403#a27404
06:02:34 <ivanm> Jonno_FTW: 1) what are you trying to do, and 2) what's the error?
06:02:53 <Jonno_FTW> I'm doing http://projecteuler.net/index.php?section=problems&id=26
06:02:57 <ivanm> if you're trying to find a loop, maybe consider the tortoise & hare algorithm (or whatever it's called)
06:03:06 <Jonno_FTW> Tha's what I am using
06:03:41 <ivanm> Jonno_FTW: IIRC, Numeric had a function to get you the list of decimals from a floating point number...
06:03:49 <aristid> @pl \p -> guard (p x) >> return x
06:03:49 <lambdabot> (>> return x) . guard . ($ x)
06:03:51 <ivanm> @hoogle Double -> [Int]
06:03:52 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
06:03:52 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
06:03:52 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
06:03:55 <ivanm> ugh
06:04:01 <Jonno_FTW> It does, but it stops after 20 places
06:04:06 <Jonno_FTW> it just puts 0's on the end
06:04:55 <Jonno_FTW> > 1/253
06:04:56 <lambdabot>   3.952569169960474e-3
06:05:05 <Axman6> TacticalGrace: you around?
06:05:07 <MoALTz> you don't even need floating point numbers for that problem :)
06:05:19 <ivanm> > floatToDigits 10 pi
06:05:21 <lambdabot>   ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],1)
06:05:32 <Jonno_FTW> > showFFloat (Just 30) (1/253) ""
06:05:33 <lambdabot>   "0.003952569169960474000000000000"
06:05:55 <ivanm> > floatToDigits (1/253)
06:05:56 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
06:05:56 <lambdabot>    aris...
06:06:08 <ivanm> > floatToDigits 10 (1/253)
06:06:09 <lambdabot>   ([3,9,5,2,5,6,9,1,6,9,9,6,0,4,7,4],-2)
06:06:29 <Jonno_FTW> > floatToDigits 25 (1/253)
06:06:29 <MoALTz> > ((1/6, 1 `div` 6), (100000/6, 100000 `div` 6))
06:06:30 <lambdabot>   ((0.16666666666666666,0),(16666.666666666668,16666))
06:06:30 <lambdabot>   ([2,11,18,24,7,17,17,4,21,1,4,16],-1)
06:06:38 <ivanm> ugh, that is one ugly definition
06:07:13 <ivanm> and the digits library only deals with Integrals...
06:07:47 <Jonno_FTW> should I implement long division?
06:08:01 <ivanm> if you so wish
06:08:08 <dancor> it seems like long div is the right way
06:08:21 <Jonno_FTW> Unless there's an easier way and my cycle detection is valid
06:09:23 <ivanm> does your code detect a cycle that has a sub-cycle as part of it?
06:09:39 <ivanm> e.g. what will it pick as the cycle out of this: 123423456123423456 ?
06:10:29 <Jonno_FTW> I don't know
06:10:30 <dancor> "detecting" the cycle like this is a flawed approach in that there could always be a bigger cycle
06:10:49 <Jonno_FTW> Is there a better algorithm than tortoise and hare?
06:11:27 <Jonno_FTW> wikipedia only has 2
06:12:02 <ivanm> AFAIK t & h is probably it
06:12:22 <ski> @type floatToDigits
06:12:23 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
06:12:29 <Jonno_FTW> then how do I improve my implementation?
06:12:39 <ski> @index floatToDigits
06:12:40 <lambdabot> Numeric
06:13:11 <ski> > floatToDigits 3 pi
06:13:12 <lambdabot>   ([1,0,0,1,0,2,1,1,0,1,2,2,2,2,0,1,0,2,1,1,0,0,2,1,1,1,1,1,0,2,2,2],2)
06:13:30 <ski> > floatToDigits (-3) pi
06:13:31 <lambdabot>   ([-2,-3,-1,-2,-1,-1,-2,-2,-1,-2,-3,-1,-3,-1,-1,-2,-1,-1,-2,-2,-1,-3,-3,-2,-...
06:13:49 * ski doubts that is really base `-3' ..
06:14:24 <aristid> > floatToDigits 10 pi
06:14:25 <lambdabot>   ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],1)
06:15:16 <MoALTz> > (\(n,rp) -> n*(-3)**rp) $ enumerate [-2,-3,-1,-2,-1,-1,-2,-2,-1,-2,-3,-1,-3,-1,-1,-2,-1,-1,-2,-2,-1,-3]
06:15:17 <lambdabot>   Not in scope: `enumerate'
06:16:00 <Jonno_FTW> my text book on algorithms has nothing on cycle detection D:
06:16:46 <MoALTz> > (\(n,rp) -> n*(-3)**rp) (zip [1..] [-2,-3,-1,-2,-1,-1,-2,-2,-1,-2,-3,-1,-3,-1,-1,-2,-1,-1,-2,-2,-1,-3])
06:16:47 <lambdabot>   Couldn't match expected type `(a, a)'
06:16:47 <lambdabot>         against inferred type `[(t, b...
06:16:52 <jacobian> Can you have the @ char in your files when using lhs2TeX?  I'm getting an error for one of my tabular decls which appears to be caused by lhs2TeX.
06:17:30 <aristid> > foldl ((+) . (* (-3))) [-2,-3,-1,-2,-1,-1,-2,-2,-1,-2,-3,-1,-3,-1,-1,-2,-1,-1,-2,-2,-1,-3]
06:17:31 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
06:17:31 <lambdabot>    arising from a us...
06:17:41 <aristid> > foldl ((+) . (* (-3))) [-2,-3,-1,-2,-1,-1,-2,-2,-1,-2,-3,-1,-3,-1,-1,-2,-1,-1,-2,-2,-1,-3] :: Integer
06:17:42 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
06:17:42 <lambdabot>         agains...
06:17:45 <aristid> hmm
06:17:51 <aristid> > foldl ((+) . (* (-3))) 0 [-2,-3,-1,-2,-1,-1,-2,-2,-1,-2,-3,-1,-3,-1,-1,-2,-1,-1,-2,-2,-1,-3] :: Integer
06:17:52 <lambdabot>   10954056258
06:17:57 <MoALTz> > sum $ map (\(n,rp) -> n*(-3)**rp) (zip [1..] [-2,-3,-1,-2,-1,-1,-2,-2,-1,-2,-3,-1,-3,-1,-1,-2,-1,-1,-2,-2,-1,-3])
06:17:58 <lambdabot>   -32.33333333333333
06:18:27 <MoALTz> > sum $ map (\(n,rp) -> n*(-3)**(negate rp)) (zip [1..] [-2,-3,-1,-2,-1,-1,-2,-2,-1,-2,-3,-1,-3,-1,-1,-2,-1,-1,-2,-2,-1,-3])
06:18:28 <lambdabot>   -891.0
06:19:53 <TacticalGrace> Axman6: hey
06:19:59 <Axman6> o/
06:20:07 <Axman6> care to join us in #AusHac2010?
06:22:53 <MoALTz> i wonder if there's a more efficient way to that PE problem (i did it by using 2 mathematical facts and then eyeballing for a solution)
06:23:39 <Jonno_FTW> is it that certain numbers produce the longest cycles?
06:24:07 <MoALTz> yes
06:24:32 <Axman6> TacticalGrace: would you be able to talk to the network admin people to see if i can get wifi access on thursday? i'd like to come and visit to make sure we've got everything
06:24:41 <Jonno_FTW> are they irrational numbers that have this property?
06:24:51 <Jonno_FTW> or not
06:24:55 <MoALTz> some primes
06:28:02 <ivanm> preflex: seen Cale 
06:28:02 <preflex>  Cale was last seen on #haskell 7 hours, 56 minutes and 37 seconds ago, saying: kmc: The proof is 100 pages long even in English :)
06:28:22 <ivanm> @ask Cale can you have lambdabot @join #AusHac2010 for this weekend?
06:28:23 <lambdabot> Consider it noted.
06:33:38 <TacticalGrace> Axman6: Ben organised that, you'd have to ask him
06:33:54 <TacticalGrace> but the problem is that he will be traveling tomorrow
06:34:09 <TacticalGrace> I think he gave rl the details in case there is some problem on Fr
06:34:28 <dancor> has anyone tried making cabal-install use hbuild
06:35:11 <Axman6> TacticalGrace: ok, i'll talk to him i guess.
06:36:06 <TacticalGrace> Axman6: I'm also not sure whether he will be able to do anything about Thursday
06:36:20 <TacticalGrace> Axman6: this is via UNSW central IT (not out School IT)
06:36:25 <Axman6> ok
06:36:29 <TacticalGrace> and central IT is very slow
06:36:36 <Axman6> will you be around on thursday?
06:36:45 <TacticalGrace> nope, sorry
06:36:48 <Axman6> bleh :(
06:36:50 <Axman6> how come?
06:37:32 <TacticalGrace> working from home
06:38:02 <TacticalGrace> our 2yo is 3 day/week at child care
06:38:18 <TacticalGrace> the other two days, we usually work from home
06:38:49 <TacticalGrace> plus it is school holidays right now, so there is actually two kids to look after
06:40:12 <TacticalGrace> Axman6: anyway, I think, we have everything covered with the wireless being the most speculative as it is really out of our hands
06:40:34 <TacticalGrace> and we have never tried to use the UNSW guest sign up before
06:41:47 <TacticalGrace> Axman6: we also have a look network port on which we can run an ad hoc network
06:41:58 <TacticalGrace> but that won't work for 20 people
06:42:11 <TacticalGrace> but should be ok for a few unexpected attendants
06:42:21 <TacticalGrace> look = local
06:42:31 <Axman6> It might, if I can get my thinkpad set up properly (i've got two wifi dongles, plus the internal one)
06:43:03 <TacticalGrace> it won't take you machine
06:43:21 <TacticalGrace> the ports are all configured to rejected unknown macs
06:43:27 <TacticalGrace> you = your
06:43:38 <Axman6> ah, lame
06:43:48 <TacticalGrace> secure! :)
06:44:21 <Axman6> pfft
06:44:43 <Axman6> we've got open ethernet ports at ANU. they're all marked with a red dot
06:45:10 <Axman6> all the rest use port security
06:45:28 * Jonno_FTW wishing I was there
06:45:59 <adu> secure?!?
06:46:03 <adu> nothing is secure
06:46:31 <Axman6> port security isn't exactly secure
06:46:43 <adu> do you mean firewalls?
06:46:50 <adu> firewalls don't mean anything
06:47:00 <Axman6> no, i mean switches which have port security
06:47:14 <Axman6> only allow certain MAC addresses
06:47:20 <Jonno_FTW> Will the same thing be going on next year?
06:47:33 <adu> oh, i don't know anything about switches, I restrict myself to the IP layer
06:47:48 <Axman6> Jonno_FTW: ?
06:47:58 <Axman6> TacticalGrace: are you going to join #AusHac2010 ?
06:48:16 <TacticalGrace> ah, right
06:48:19 <TacticalGrace> meant to do that
06:48:40 <Jonno_FTW> will there be an AusHac2011?
06:48:48 <Axman6> hopefully
06:48:58 <Jonno_FTW> I might attend that then
06:49:09 <Axman6> it's not like this one was hard to setup, just had to know the right people
06:49:46 <ivanm> yeah
06:49:50 <ivanm> i.e. TacticalGrace
06:49:51 <ivanm> ;-)
06:51:50 <Jonno_FTW> Does UNSW have a dedicated haskell topic?
06:52:20 <ivanm> well, it has a group that do haskell research: TacticalGrace, benl23, kamatsu, etc.
06:52:45 <Jonno_FTW> Interesting
07:03:58 <ivanm> preflex: seen edwardk 
07:03:59 <preflex>  edwardk was last seen on #haskell 10 hours, 14 minutes and 35 seconds ago, saying: yeah its still kicking
07:06:03 <edwardk_> yo
07:14:37 <BMeph> ho
07:14:37 <wlangstroth> edwardk: did David Spivak contact you, by any chance?
07:16:50 <chrisdone> nominolo: ping
07:28:11 <edwardk> wlangstroth: regarding?
07:28:28 <wlangstroth> category-extras
07:28:40 <edwardk> not that i know of =)
07:30:38 <wlangstroth> okay - I emailed him to ask some questions about his talk at galois, and he asked about category-extras, and I directed him to you
07:30:55 <edwardk> what was he curious about?
07:32:45 <wlangstroth> he was trying to model a Grothendiek construction in Haskell, from what I could figure
07:34:11 <edwardk> ah
07:37:09 <edwardk> that won't fit very nicely with the haskell Category class =/
07:38:16 <edwardk> hrmm
07:38:42 <dancor> can i make haddock run on multiple cores
07:38:50 <ski> (edwardk : btw, ezyang earlier wanted education on `CoIdeal CoMonads', `CoYoneda', and other `Co'-things)
07:38:57 <wlangstroth> no - I think at best it would be a kind of simulation
07:40:22 <edwardk> ski: i think i saw my name flash by
07:41:25 <edwardk> dancor: i can too, i just run it on a bunch of smaller packages in parallel ;)
07:41:53 <edwardk> dancor: oh sorry, i misparsed you i thougth you said you could, didn't parse that as you asking how.
07:42:13 <edwardk> dancor: probably not
07:42:30 <wlangstroth> edwardk: it's actually pretty unnecessary, given the context: we were discussing how to implement a category-oriented data format
07:43:07 <edwardk> wlangstroth: well, databases are categories ;)
07:43:48 * ski glances towards "Categories for Software Engineering"
07:44:04 <wlangstroth> ski: ooh - thanks for that
07:44:30 <edwardk> dancor:  can you pass something like -optghc -j4 ?
07:44:40 <ski> (i'm not sure how relevant it is .. but it might be interesting)
07:45:00 <ski> (oh, author : Jos Luiz Fiadeiro)
07:45:14 <benmachine> edwardk: can ghc run on multiple cores?
07:45:17 <edwardk> er that probably won't work, i misread something
07:45:49 <edwardk> benmachine: i don't think so actually. i was reading a page that said something about the ghc build system, but it was talking about the bild system used to build ghc not the one used by ghc to build stuff ;)
07:45:56 <benmachine> heh
07:47:55 <edwardk> dancor: in fact i'm recalling a conversation where it explicitly came up that you can't get ghc to compile in parallel. since haddock uses ghc internally, i'm guessing you're probably out of luck
07:56:19 <edwardk> hrmm. got bored and started updating the approach used in the old financial contracts paper to use modern approaches. observables are Applicative with a couple of extra combinators.
07:56:51 <edwardk> (i wanted to parameterize contracts, so i could use them with automatic differentiation, etc)
07:56:53 <Heffalump> I believe ghc uses IORefs internally for global state.
07:57:18 <edwardk> Heffalump: sounds right. that was the substance of the conversation i'm recalling
07:57:43 <wlangstroth> edwardk: is there code to go with this paper?
07:58:40 <edwardk> wlangstroth: yeah. there is a short snippet or two, including a literate haskell source file i found somewhere. you can find more by mining the lexifi stuff which uses this approach much more seriously.
07:59:56 <wlangstroth> that's excellent - thank
07:59:59 <wlangstroth> ...s
08:00:09 <edwardk> i wanted to change a few things, for one i wanted to be able to support 'continuous time', i wanted the ability to use different numeric types, arbitrary currency types, etc
08:00:26 <edwardk> wlangstroth: i'll throw something on hackage as soon as i have some usable models
08:02:08 <edwardk> it has been a few years since i did anything financial and i don't want to forget how, so this seemed like a good way to avoid getting rusty
08:08:08 <wlangstroth> edwardk: what kind of financial stuff did you do?
08:10:10 <edwardk> wlangstroth: well, i studied up for the actuarial exams back in college before i decided that i'd rather not be an actuary ;)
08:10:40 <nominolo> chrisdone: pong
08:11:57 <nominolo> chrisdone: I've installed mediawiki and am now building a proper skin (before it was only CSS rules).  I'm trying to make a "fluid" layout so it works well on all screen sizes.
08:22:26 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27410#a27410
08:22:29 <int80_h> hiya
08:24:46 <edwardk> int80_h: sadly you'd need touse the _'s to build it with the record syntax.
08:29:00 * ksf notices that generalising the kleene star to n..m repetitions and just not allowing anything that isn't a kleene star eases things.
08:29:19 <edwardk> ksf ?
08:29:46 <edwardk> ksf: makes compiling down to nfa/dfa form problematic though, hence the usual macro expansion
08:29:48 <ksf> that is, a terminal isn't something like "a", but "a{1,1}"
08:30:32 <edwardk> the result of that formulation is a form of pushdown automata
08:31:01 <ksf> hmmm wait I still have to distinguish between n and 0, then.
08:37:04 <ksf> I've already decided to go nested-word in parts. that is, I snatch the matching part out of the grammar, compile it to an enumerator eating tokens and producing data NW a = Word a | Push | Pop and then an iteratee snatching the fmap parts out of the applicative grammar and parsing the nested word stream.
08:37:35 <ksf> ...and all that because TH can't lift functions.
08:38:08 <ksf> (so that I can generate the matcher with TH and use vanilla haskell for the semantics interpreter)
08:41:20 <ksf> and never mind me, I was just thinking aloud. (ab)*c should compile down to Push (foo : Match [a -> Yield a ->  Match b -> Yield b -> foo, Match c -> Pop -> Yield c])
08:41:42 <ksf> modulo ad-hoc broken syntax.
08:41:59 <ksf> my paper scribblings are more readable.
08:44:41 <ksf> thinking of it, regular -> nested word pipelines are quite common. think of SAX
08:45:48 <chrisdone> what means "peanut gallery"?
08:46:09 <kmc> http://en.wikipedia.org/wiki/Peanut_gallery
08:46:11 <tg_zzz> chrisdone: it's a term to describe a collection of observers
08:46:19 <jesusabdullah> <--peanut gallery
08:46:24 <tg_zzz> usually, they poke fun at the thing being observed
08:46:46 <Taejo> or just throw peanuts at it
08:46:47 <int80_h> edwardk : I was afk, just read your feedback. Thanks :)
08:46:53 <dancor> does anyone use yi as an ide?  can i make F5 do a compile in a separate buffer?
08:46:55 * jesusabdullah is out of peanuts though
08:47:32 <ksf> you can do everything with yi
08:47:38 <ksf> ...provided you are willing to hack on it.
08:47:39 <chrisdone> dancor: first question, no. second question, yes
08:47:47 <dancor> i guess i meant has anyone already done this
08:47:57 <ksf> it's not hard
08:47:58 <chrisdone> iirc key bindings are eay
08:48:24 <chrisdone> (check the docs for key bindings or other keybinding examples)
08:48:53 <ksf> locate the source for your keybinding, read up a bit on the editor monad, then do something like withNamedBuffer "*compile*" do ...
08:49:21 <dancor> chrisdone: the haddock docs?
08:49:24 <chrisdone> isn't it already bound to C-c C-l?
08:49:52 <ksf> dancor, nope, the source
08:50:08 <ksf> how stuff is done depends on the emulation you're using.
08:50:52 <djahandarie> I've had yi crash on me
08:51:01 <ksf> though I imagine non-vi bindings share a lot of stuff
08:51:13 <djahandarie> Due to something with MVars
08:51:24 <chrisdone> http://hackage.haskell.org/packages/archive/yi/0.6.2.3/doc/html/Yi-Mode-Haskell.html
08:51:32 <chrisdone> ghciLoadBuffer :: YiM  ()
08:51:38 <chrisdone> there's your ghci loading part
08:52:01 <chrisdone> now you just need to check out http://hackage.haskell.org/packages/archive/yi/0.6.2.3/doc/html/Yi-Keymap.html and http://hackage.haskell.org/packages/archive/yi/0.6.2.3/doc/html/Yi-Keymap-Keys.html
08:52:29 <chrisdone> alright?
09:12:07 <ksf> someone tell me how to write a show instance for Mu.
09:12:30 <soupdragon> Show (f (Mu f)) => Show (Mu f)
09:13:54 <aavogt> it seems that people only use serious type variables
09:13:55 <ksf> that's undecidable
09:14:06 <ksf> ...but it works.
09:14:28 <ksf> and I should know better than to try to show infinite structures.
09:14:49 <EvanR-work> show it using a perspective projection
09:15:02 <ksf> I think I'm going to show it using data-reify
09:15:31 <EvanR-work> http://en.wikipedia.org/wiki/0.999...
09:15:45 <Saizan> "show (undefined :: Mu Identity)" is quite funny
09:18:55 <EvanCarroll> zomfg
09:19:04 <EvanCarroll> BONUS: Check this out! http://chikuyonok.ru/u/demo/infoscroller/
09:19:13 <EvanCarroll> BONUS: that would be nifty for your book
09:19:29 <soupdragon> perspective projection? lol
09:19:56 <EvanR-work> another way is with a fractal
09:21:34 <tg_zzz> EvanCarroll: that's very cool
09:23:27 <EvanCarroll> tg_zzz: I love it! I saw another scrollbar UI for windows toolkits that was *really* awesome too, it came out about 2 years ago, and I was really excited because at that time I thought it would be provided by gtk+
09:25:11 <EvanCarroll> http://www.youtube.com/watch?v=-PnXY4wjuH8
09:41:08 <lispy> is c.h.o down again?
09:41:52 <Jafet> lispy: It's not just you!
09:47:07 <BMeph> Wow, nothing says "dedication to your craft" like porting an OCaml program... ;
09:47:45 * BMeph needs to read more to figure out why something would have the type "(io_id list) option" in it...
09:48:16 <lispy> Maybe [IO_id] is the haskell version of that type, right?
09:48:45 <BMeph> lispy: That's how I see it, yes.
09:49:22 <BMeph> Apparently, there's some significance between having an empty list, and not having a list at all...
09:52:06 <aristid> BMeph: porting to ocaml or from?
09:53:24 * SyntaxNinja magically fixes c.h.o, hopefully not messing up anything in the process
09:57:14 <Heffalump> SyntaxNinja++
09:57:27 <SyntaxNinja> Heffalump: how you been, man? :)
09:59:32 <Heffalump> not bad. You? :-)
10:03:35 <SyntaxNinja> Heffalump: pretty good. having fun in Portland still :)
10:04:36 <ksf> let [(6,RMatch (RM [(x == 'a',3),(x == 'c',7)])),(4,RMatch (RM [(x == 'b',5)])),(3,RYield 4),(5,RYield 6),(8,RYield 9),(1,RPush 6),(7,RPop 8),(9,RFin)] in 1
10:07:16 <ski> ksf : is that supposed to describe a graph of some kind ?
10:08:12 <ksf> it's even supposed to describe a regular acceptor spouting out nested words
10:09:13 <aristid> ksf: is that generated code?
10:09:16 <ksf> ...where each Match saves what it matched and yield outputs it.
10:09:29 <ksf> (no stack there, just a register)
10:09:38 <ski> and `x' is ?
10:09:47 <ksf> aristid, yes and no
10:10:00 <aristid> i love clear answers
10:10:00 <ksf> it's generated from an intermediate representation, not source yet.
10:10:22 <aristid> ksf: so parser generators are still popular?
10:10:31 <ksf> x is due to the ideosyncratic show instance of data.ranged
10:10:49 <ksf> aristid, indeed, they are.
10:11:15 <aristid> ksf: why not just use parser combinator libraries?:)
10:11:18 <ski> hm .. you mean they probably ought to have at least included a `\x ->' somewhere ?
10:11:31 <ksf> to the best of my knowledge, there's no regex library that has an applicative interface
10:12:08 <ksf> ski, well, the main point is syntax like 'a' <= x <= 'z'
10:12:29 <ddarius> ksf: There's a regex library over Parsec and Parsec has an Applicative interface...
10:12:57 <ksf> does it compile down to honest-to-x86 code?
10:14:52 <ksf> ...I don't want to backtrack, I don't want to lookahead, I want as fast as possible execution and I want an applicative interface.
10:15:04 <Phyx-> does anyone know if there's an efficient way to convert Doc to ByteString or CWString?
10:15:21 <ksf> the whole thing is meant as a backend for all those regular grammars around, e.g. in RFC's. compile once, run fast.
10:28:09 <wapcaplet> hi folks. I noticed a lot of spam over the last few days on the Haskell Wiki: http://www.haskell.org/haskellwiki/Special:Recentchanges -- lots of new user pages like "User:Buymicrodox", "User:Buywormin", "User:Buycefocep". I deleted a few but there are just too many :-) anyone here have an easier way to clean these up?
10:29:21 <ksf> captchas
10:29:38 <fffej> captchas in the form of Haskell puzzles!
10:29:39 <ksf> for some unexplicable reason, the admins don't want them.
10:29:41 <wapcaplet> heh
10:29:47 <ksf> so just let them do the cleanup.
10:29:50 <wapcaplet> captchas would be nice
10:30:44 <aristid> i want type captchas. it shows some haskell expression and you have to get the type. if you're lazy you can use ghci of course
10:31:10 <ksf> as it came up on the cafe, before they disabled account creation for some time, they were all like "ah but no captcha is truly unbreakable"
10:31:42 <ksf> we don't want to prevent newbies from registering
10:31:58 <ksf> ...and that's way too easy to automize.
10:32:00 <wapcaplet> true, no captcha is perfect, but it'd at least filter out some of the riff-raff
10:32:01 <aristid> no security system is totally secure
10:32:04 <Jafet> Perhaps textual captchas should be privileged based
10:32:16 <aristid> it's really about difficulty of breaching
10:32:26 <aristid> ksf: spammers are too stupid to know about ghci!
10:32:32 <Jafet> So, doing something unusual will require you to construct a rank-3 state monad
10:32:45 <ksf> Jafet, like getting rid of login captchas when there's a number of unreverted edits for some time?
10:33:31 <ksf> erm no login captchas suck. better would be a hellalotofedit-captchas
10:33:40 <nominolo> preflex: seen chrisdone
10:33:40 <preflex>  chrisdone was last seen on #haskell 1 hour, 41 minutes and 11 seconds ago, saying: alright?
10:34:01 <wapcaplet> well in unrelated news, I've been making an effort at useful contributions, moving the "99 Haskell Problems" solutions to sub-pages. I'm finding these problems to be good exercises while learning Haskell, and having the solutions right there is just too tempting :-)
10:34:21 <ksf> heh.
10:34:36 <ksf> the first one should be to write a rot13-decoder. then just encode the solutions.
10:35:22 <Cale> wapcaplet: It might be good to let one of the admins know about it.
10:35:26 <Jafet> "Please complete this captcha to finish the package update process. Your captcha is: post a build log of building with base-4 in the box below"
10:35:51 <Jafet> Oh, you're only talking about the wiki
10:36:07 <jmcarthur> yeah the wiki needs to be a lot tougher ;)
10:36:13 <ksf> from 50 onwards, stuff would be rc4 encoded
10:36:55 <Jafet> ksf: that's a rather twisted form of cbc
10:37:27 <ksf> and the first problem of course doesn't come with a solution, just with a complete description on how to piece together a rot13 decoder.
10:39:02 <ksf> cry baby corner? creeper by choice? cute but crazy?
10:39:55 <Jafet> I like cute but crazy, we can go with that
10:40:13 <ksf> oh, and the rc4 key would be of course a value returned by the previous exercise.
10:40:46 <zygoloid> type captchas sounds like a really nice solution. i can't imagine a spammer would ever spend the time to write code to fill in a hsakell.org captcha
10:41:03 <ksf> newbies. think of the newbies.
10:41:05 <Jafet> Unless he wanted to spam haskell
10:41:27 <Jafet> But you could generate puzzles with undecidable instances
10:41:39 <zygoloid> ksf: exactly. it'd enforce a certain minimal level of knowledge to update the wiki ;-)
10:41:40 <Jafet> Problem is, I can't solve those
10:42:23 <zygoloid> Jafet: that's my point. what spammer would ever specifically want to spam haskell enough to write a special-case script?
10:42:46 <zygoloid> that's not how these SEO spammers generally work -- they want lots of sites pointing at them, not one site pointing at them a lot
10:43:17 <Jafet> Someone who knows haskell and hates the haskell wiki communi... oh yeah, empty set
10:43:24 <ksf> and we should switch to gitit
10:43:36 <ksf> Jafet, jdh30?
10:43:49 <zygoloid> Jafet: i can think of a few people who fit that, but none that would stoop to spamming
10:44:04 <wapcaplet> Cale: I'm not sure who the admins are. I assumed they might hang out here
10:45:54 <tommd> wapcaplet: There is really only one, this is a known issue that has gotten lots of attention on -cafe lately.   A new (better managed) server will be up soonish.
10:48:49 <wapcaplet> tommd: cool
10:49:50 <Phyx-> bleh, how annoying, all the types i need are abstract in ghc
10:50:12 <tommd> bleh, how annoying, all the types I need are ambiguous to ghc
10:50:36 <illissius> Phyx-: which ones?
10:51:57 <Phyx-> illissius: i'm currently trying to inspect the Doc type, to determine whether GHC uses the FastString ListString or normal Strings constructor most often
10:52:20 <Phyx-> i usually get around it by recompiling ghc
10:52:35 <nominolo> Phyx-: most likely FastString
10:52:45 <dom96> how can i convert a number in scientific notation such as '2.16e19' to what the actual number is ?
10:52:56 <kmc> dom96, you have a string?
10:52:59 <Phyx-> nominolo: that's what i'm hoping :)
10:53:02 <kmc> > read "2.16e19" :: Double
10:53:03 <lambdabot>   2.16e19
10:53:20 <Phyx-> nominolo: but now i need to make an SDoc -> FastString function
10:53:31 <kmc> > log (read "2.16e19" :: Double)
10:53:32 <lambdabot>   44.51922498858294
10:53:32 <Phyx-> which also requires me to have access to the constructors
10:53:34 <dom96> kmc: no a float i think
10:53:39 <kmc> dom96, ok
10:53:53 <kmc> dom96, then it's already an "actual number"
10:53:54 <nominolo> Phyx-: Why not use Data.Text.pack ?
10:54:05 <Cale> wapcaplet: http://haskell.org/haskellwiki/Special:Listusers%26group%3Dsysop
10:54:11 <Phyx-> nominolo: most likely, because I don't know abou it. *finds*
10:54:15 <nominolo> Phyx-: or the same for utf8 string
10:54:29 <kmc> dom96, it's not as though some floats are stored in sci notation and others in decimal.  probably, they are all stored uniformly (in binary mantissa + exponent form) and only formatted one way or another for output
10:54:32 <illissius> I wonder if defining a datatype with an identical RHS and unsafeCoercing is "safe"...
10:54:49 <nominolo> Phyx-: i.e., I think if you immediately consume the string and turn it into another packed represantation it should be fine.
10:54:57 <dom96> kmc: Can't i convert it to 2160000, or whatever that number is.
10:55:10 <nominolo> Phyx-: FastString maintains an internal symbol table, so it's actually not a good idea to create many big ones
10:55:25 <nominolo> Phyx-: since this symbol table is never GC'd -- it's a huge space leak.
10:55:29 <Phyx-> nominolo: what I ideally really need is a fast SDoc -> CWString to marshall
10:55:34 <kmc> you mean 21600000000000000000?
10:55:44 <dom96> kmc: yeah
10:55:47 <kmc> > 21600000000000000000 :: Double
10:55:47 <Phyx-> converting to string and then to CWString seems to be my source of slowdowns
10:55:48 <lambdabot>   2.16e19
10:56:00 <nominolo> Phyx-: CWString is uint16_t[] ?
10:56:09 <kmc> dom96, 21600000000000000000 and 2.16e19 are the same number.  they are stored identically in memory
10:56:16 <kmc> dom96, there's nothing to convert
10:56:33 <nominolo> Phyx-: I think Data.Text uses UTC16 internally, so converting that to CWString should be a no-op
10:56:45 <dom96> kmc: sorry, let me rephrase. If i convert that number to a string, i would like it to be 21600000000000000000
10:56:49 <kmc> right
10:56:53 <kmc> that's a different question
10:56:53 <Phyx-> nominolo: well, the documentation is vague about that, it'l always be a type that supports unicode, but on windows it's guaranteed to be wchar_t which is why i use it
10:57:14 <kmc> and the default Show instance for Float or Double will use sci notation above some size
10:57:45 <kmc> > printf "%g" 2.16e19
10:57:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:57:46 <lambdabot>    `Text.Printf.PrintfType ...
10:57:49 <kmc> > printf "%g" 2.16e19 :: String
10:57:50 <lambdabot>   "2.16e19"
10:58:06 <Phyx-> nominolo: but the type of pack is String -
10:58:17 <Phyx-> nominolo: but the type of pack is String -> Text, I was hoping to avoid getting a string at all
10:58:17 <dom96> kmc: ahh, actually i think that's allright, i thought the number was much smaller, 2160000, not 21600000000000000000
10:58:33 <dom96> kmc: thanks for the help.
10:58:36 <mee> ugh, the day job language is becoming increasingly frustrating as I learn more Haskell -- there should really be a warning ;)
10:58:55 <kmc> mee, yes.  Haskell is bad for job satisfaction
10:58:56 <nominolo> Phyx-: well, ideally if you immediately consume the string it might optimise.  Though I'm not sure that's actually happening
10:59:52 <nominolo> Phyx-: SDoc is just a wrapper around Doc which comes from the pretty printing library and is intentionally kept abstract
11:00:30 <nominolo> you'd have to modify that to translate Doc -> Builder or so
11:00:48 <Phyx-> nominolo: yeah, I know, my initial idea was this, to write a function that works on Doc, and converts the FastString directly to CWString.
11:01:06 <kmc> mee, which day job language?
11:01:27 <Phyx-> but if fusion takes place then maybe I can just indeed consume the strings immediately. my current implementation stores them for a few moments before converting
11:01:31 <nominolo> Phyx-: you probably want to use the builder abstraction (see Data.Binary and Data.Text)
11:01:35 <illissius> 'I wonder if defining a datatype with an identical RHS and unsafeCoercing is "safe"...' -- ugliest hack ever ever ever, but would it _work_?
11:01:52 <Phyx-> nominolo: cool, I'll take a look, thanks :)
11:02:13 <nominolo> Phyx-: try -ddump-simpl, it should tell you which rules fired
11:02:29 <kmc> i think a cool project in a shitty language can be fulfilling, but if it's something mundane then it's tremendously annoying to use a language that gets in the way
11:02:43 <Phyx-> nominolo: ah, that's a good one, I keep forgetting the plethora of ghc flags :)
11:02:54 <kmc> illissius, i expect it would work, but there are no guarantees
11:03:04 <nominolo> Phyx-: -ddump-simpl-stats might be useful as well
11:03:38 <nominolo> Phyx-: you're looking for buildr/foldr fusion
11:03:52 <nominolo> pack might actually be a left fold
11:05:06 <Phyx-> nominolo: yeha, i'm looking at Data.Binary and I don't think that'll be beneficiary, as it would require more fusion to work, I'll get a String which i'll need to make a ByteString and that gets me a Builder which then needs to become a CWString. I think pack might be better
11:05:13 <nominolo> Phyx-: sorry, scratch that, text uses its own fusion library
11:05:29 <Phyx-> nominolo: A key point is, that I actually don't need/want to process the strings at all in the haskell world
11:05:48 <nominolo> Phyx-: can you cache the strings?
11:05:48 <Phyx-> they're simply passed along
11:05:58 <nominolo> Phyx-: then you can just stuff them into a DB
11:06:20 <Phyx-> nominolo: no, they're the result of a typecheck call. e.g. type errors etc
11:06:37 <Phyx-> or in case they succees, information about the module
11:06:42 <Phyx-> succeed*
11:06:42 <nominolo> Phyx-: but those are usually pretty small
11:07:03 <nominolo> Phyx-: In scion I actually serialise them via a socket
11:07:27 <Phyx-> nominolo: but i have a heck of alot of them :) In case an error occurs I do get the errors pretty quickly, no noticeable lag
11:07:37 <Phyx-> but in my largest file, ~500kb haskell file
11:07:46 <Phyx-> (ghc parsers themselves)
11:08:02 <Phyx-> it takes 2-3seconds to give me information about all the functions in the file
11:08:24 <Phyx-> but my benchmarks show that the actual gathering of information is completed in less than 0.5seconds
11:08:29 <Phyx-> so the rest is marshalling overhead
11:08:46 <nominolo> hm.
11:09:37 <Phyx-> someone suggested on cafe that it might be becuase while gathering information i generate strings, and later on I convert them to CWStrings
11:09:38 <nominolo> well, option 1: don't send over text, but the actual data types (e.g., Type, and Name)
11:09:48 <Phyx-> suggesting that the walking of all the string structures take long
11:09:53 <nominolo> option 2: send information asynchronously
11:10:13 <nominolo> Phyx-: I wouldn't guess with this stuff
11:10:28 <Phyx-> hehehe
11:10:33 <nominolo> Phyx-: it's too complex, just measure
11:10:46 <Phyx-> well, option 2 would be very hard at this point, my tool doesn't support that yet
11:10:47 <nominolo> Phyx-: for example it might be pretty printing
11:11:16 <nominolo> Phyx-: your plugin is written in C#?
11:11:35 <Phyx-> nominolo: that's the thing, because of alot of types in GHC being abstract, I had to put the Storable instances for those types in GHC itself, which meant source. but when I try compiling ghc with profiling support it segfaults
11:11:53 <MasseR> I'm trying to do some monad tutorials, and I'm at state monads. I try to import with "import Control.Monad.State" and ghc complains "ambiguous module name 'Control.Monad.State': it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.1.0.12
11:11:59 <Phyx-> nominolo: yeah, but with tool i mean what i use to generate the marshalling information, since i'm not typing those out by hand
11:12:54 <nominolo> Phyx-: so what i have in mind is that you first send over the names of all the top-level functions, then send over the type info (perhaps in chunks)
11:13:39 <nominolo> you'll have to deal with arbitrary delays anyway, since template haskell can take arbitrarily longe
11:13:57 <Phyx-> TH in typechecking you mean?
11:14:05 <nominolo> e.g, try to compile the type-level library.  It's got this one completely rediculous module
11:14:12 <nominolo> yup
11:14:33 <Phyx-> currently, what i send across on quick queries are
11:15:00 <nominolo> that module has 10000+ definitions declared via template haskell.  It taks 1G+ RAM to compile.  Fucking rediculous
11:15:04 <wapcaplet> Cale: Thanks. I'll drop them a line
11:15:24 <Phyx-> for the function, the span it occupies, the name, the type is any, the span that the body of the function ocupies (what's afther the =), if the type signature was explicit and any child functions it declares (same info)
11:15:53 <Cale> wapcaplet: I think Ashley Yakeley is the guy you want to talk to, though gwern hangs around here, and maybe he could do something about it.
11:15:58 <Phyx-> nominolo: lol, it's my best have, If i can get that to be responsive I can be pretty sure everything else will
11:16:03 <ksf> hmmmm (a|aa)*b . I need to move the indicator that it's the left or right branch outside of the star to get efficient code
11:16:20 <ksf> but doing that in the general case boycots online result construction
11:16:49 <Phyx-> nominolo: I also recently with help of lispy found a way to help ghc not load the interfaces everytime
11:16:59 <Phyx-> by keeping the HscEnv around for future calls
11:17:16 <Phyx-> that cut the execution time down dramatically
11:17:23 <nominolo> Phyx-: yes, but that has other problems.  You might get overlapping instances
11:17:27 <ksf> and what I still don't get is how to parse b*b greedily without backtracking.
11:17:44 <aristid> ksf: modify to bb*?
11:17:58 <ksf> yep.
11:18:04 <nominolo> Phyx-: because HscEnv is never flushed.
11:18:30 * wli always built state machines for regexes.
11:18:33 <Phyx-> nominolo: well, i clear the targets, ghc is smart enough to only readd targets and not the interfaces when the timestamps on the files don't change. the only thing that changes in between the rapid invocation will be the current file in the editor
11:18:35 <nominolo> Phyx-: also sometimes you have to use HscNothing, sometimes HscInterpreted
11:19:41 <Phyx-> nominolo: It requires a bit more memory, since you'll have 1 HscEnv per open source file, but it's not that bad in my tests, you don't notice at all. Well, I always use HscInterpreted since GHC won't typecheck otherwise
11:20:12 <nominolo> Phyx-: ok, that's the same I do.  but it won't flush the external package state.  So if you change a dependency (e.g., mtl to monads-fd) it won't remove the old instances
11:20:49 <Phyx-> nominolo: well, if you change something like that in the configuration i can just flush the HscEnvs
11:21:05 <shidima> evnin
11:21:28 <nominolo> Phyx-: ok, so you run a GHC instance *per source file*?
11:22:03 <Phyx-> nominolo: no 1 instance, just 1 pointer to a pinned HscEnv in GHC's heap per open source file
11:22:17 <CakeProphet> hey. So I'm trying to explain monads to a friend and nothing is really working. What is a good tutorial for them? I think he's probably read RWH but I'll check.
11:23:03 <nominolo> Phyx-: you're sharing the HscEnv?
11:23:04 <ski> wapcaplet : iirc, gwern said a few hours ago he/she/it removed a lot of spam off haskellwiki
11:23:12 <CakeProphet> from a C++/electrical-engineering background.
11:23:20 <CakeProphet> what would be a good tutorial for monads?
11:24:02 <nominolo> CakeProphet: google for "you could have invented monads yourself"
11:24:10 <Phyx-> nominolo: between subsequent calls yes, since every source file has one, i just send their last HscEnv along
11:24:19 <Phyx-> nominolo: http://phyx.pastebin.com/ahWwfXss is explains what I do
11:24:28 <thoughtpolice> yeah, I agree with nominolo - dan (sigfpe) has an amazing way of explaining things
11:24:29 <ski> wapcaplet : btw, note that lisppaste has a "captcha" where the word to enter always is the same, it appears to have worked rather well, though i think recently there was some trouble prompting code modification (for details ask chandler)
11:24:30 <BMeph> Are there any running conversations, on -cafe perhaps, on an indicator (or not to have one) to denote strict arguments of a function?
11:24:42 <kmc> CakeProphet, what do you / your friend want to learn about monads?
11:24:51 <kmc> CakeProphet, what they "really are", or how to use them for specific task X?
11:24:53 <flazz> what does unode do, i'm confused with t (http://hackage.haskell.org/packages/archive/xml/1.3.7/doc/html/Text-XML-Light.html#v%3Aunode)
11:25:11 <thoughtpolice> CakeProphet: aside from sigfpe, it's mainly important to understand they're no more special than any other abstraction. they happen to have many occurences, though
11:25:18 <CakeProphet> kmc:  I think he wants to learn what they really are. Hopefully by now he grasps how to use things such as IO. u_u
11:25:23 <kmc> oh
11:25:45 <kmc> yeah, understanding monads is neither sufficient nor necessary for using IO successfully
11:26:21 <kmc> CakeProphet, anyway i recommend Typeclassopedia as well as http://haskell.org/haskellwiki/Monads_as_containers and http://haskell.org/haskellwiki/Monads_as_computation
11:26:31 <kmc> http://haskell.org/haskellwiki/What_a_Monad_is_not may be helpful
11:26:54 <kmc> _All About Monads_ was useful for me, but various people have found bits of it misleading or nearly wrong
11:27:18 <nominolo> Phyx-: ok, so this might work, if you don't share it between concurrent sessions
11:27:53 <ksf> aristid, and (a|b)*a?
11:28:03 <Phyx-> nominolo: well, since only file can be typed in at a time it's safe, and within a file i guard access to the pointer with a semaphore
11:28:15 <Phyx-> that also makes *all* calls into haskell land threadsafe
11:28:22 <Phyx-> since the calls need the pointer
11:28:39 <ksf> ...not that I would be convinced that maximum munch is a good idea
11:29:16 <nominolo> Phyx-: ok, so this is essentially equivalent to just having a long-running session.
11:30:13 <Phyx-> nominolo: exactly, since i make calls every 500ms after the last keypress it's beneficial, gives me a pretty reactive environment. it also serves as a base to ask for identifier information etc, since nothing will have to be loaded again, just use the last known information
11:32:48 <Phyx-> still have to adjust that number though, sometimes little pauses cause it to check already, but i'll do that later.
11:33:14 <Phyx-> currently rewriting it to consume the strings as soon as it produces them, then check if fusion takes place
11:36:37 <BMeph> aristid: (Sorry about the delayed answer) Porting from OCaml to Haskell. I think the initial translation will help me to get a grasp on the structure good enough to rewrite it into better Haskell afterwards.
11:38:33 * Phyx- has to find a new version control system while his svn server is down
11:38:40 <Phyx-> but I just can't get used to darcs :/
11:38:51 <mauke> git
11:38:52 <ben> git is pretty cool!
11:38:56 <kmc> git git git git git git git git
11:39:03 <kmc> @quote subversion
11:39:03 <lambdabot> LinusTorvalds says: The slogan of Subversion for a while was 'CVS done right', or something like that, and if you start with that kind of slogan, there's nowhere you can go. There is no way to do
11:39:03 <lambdabot> CVS right.
11:39:21 <Phyx-> what's the difference between git and darcs?
11:39:37 <illissius> the one advantage of svn over git is that the commands are way simpler and easier to remember.
11:39:40 <mauke> what's the difference between a raven and a writing desk?
11:39:56 <kmc> Phyx-, various
11:40:01 <nominolo> what's the problem with darcs?
11:40:10 <FauxFaux> The speed.
11:40:10 <mauke> what is love?
11:40:14 <FauxFaux> Baby don't hurt me.
11:40:21 <BMeph> mauke One was made by using the other? ;)
11:40:34 <kmc> Don't hurt me no more
11:40:42 <Phyx-> there's no problem with darcs.. except cancelling pulls get you in a world of pain, but i just can't get used to it
11:40:48 <ben> illissius: That sounds subjective
11:40:48 * FauxFaux high-fives kmc.
11:40:51 <Phyx-> keep forgetting it's commands
11:40:54 * BMeph runs away before the head-bobbing gets violent...
11:41:25 <illissius> ben: git lets you / forces you to interact with the repository at a lower level
11:41:49 <illissius> maybe that's necessary because of it being a DVCS, i dunno.
11:41:50 <kmc> git has a very simple clean data model, and a somewhat fancy set of commands for manipulating it
11:41:58 <kmc> i like this, because you're always relatively sure what's being stored
11:42:16 <ClaudiusMaximus> git bisect is nice
11:42:56 <kmc> git does not try to store patches and combine/move them in clever ways, as darcs does
11:43:15 <kmc> git stores whole files semantically, and recovers differences on the fly as desired
11:43:20 <Saizan> i never know what kind of traces i'm leaving where with git, though
11:43:37 <kmc> (by "semantically" i mean that it has the semantics of storing whole files, but can do transparent compression to avoid this overhead)
11:44:12 <kmc> git is also very explicit about being a content-addressable filesystem *and* a DVCS implemented on top of that
11:44:18 <kmc> there are several layers of commands
11:44:20 <illissius> i wonder if you could (re)implement some kind of VCS using btrfs's snapshotting as the backed
11:44:24 <illissius> *backend
11:44:36 <illissius> i'm also sure i'm not the first person to have thought of this
11:47:05 <Phyx-> yay 3 errors more to go
11:48:45 <Phyx-> sweet compiles
11:48:56 <Phyx-> now lets check the simplifier report
11:51:13 <Phyx-> the flag is "--fforce-recomp" right?
11:51:20 <kmc> one dash
11:51:28 <Phyx-> ah ok
11:51:30 <Phyx-> thanks :)
12:02:47 <Phyx-> nominolo: just compared them, and dirctly consuming the strings result in the same amount of unfold/fold rules firing
12:04:39 <Scala_> Basically all a monad is is a system where you declare what types of properties a val (var?) can hold and what should happen and how methods that use the monad as an argument should work?
12:04:46 <aristid> BMeph: sorry for the delayed answer to the delayed answer (:D)
12:04:50 <soupdragon> no
12:05:19 <ksf> hmmm no I should factor things like a*a such that the tail of the star gets matched at the same time as the star itself.
12:05:23 <mauke> Scala_: monad as an argument? what?
12:05:32 <EvanR-work> Scala_: not methods, functions, to start with
12:05:47 <soupdragon> class Monad m where map :: (a -> b) -> (m a -> m b) ; join :: m (m a) -> m a ; return :: a -> m a
12:06:31 <aristid> are you used to people arguing stuff like "people just think imperatively" and "why not do imperative programming directly?"
12:06:54 <EvanR-work> 'i just think in terms of OO'
12:06:56 <Scala_> Sorry, I'm trying to nail down the concept in my head, I don't know much haskell so the terminology is there
12:06:57 <BMeph> aristid: Aren't you? ;)
12:07:02 <Scala_> isn't*
12:07:08 <aristid> BMeph: i think only in terms of Applicative.
12:07:13 <mauke> Scala_: why bother thinking about monads?
12:07:13 <soupdragon> learn the haskell terminology
12:07:23 <mauke> they're not important
12:07:45 <BMeph> aristid: Fair enough; I translate everything into continuations... :D
12:07:46 <Scala_> mauke: Are you being sarcastic?  Isn't it an essential feature of haskell
12:07:50 <aristid> BMeph: :)
12:07:53 <soupdragon> Scala_ you say you don't know haskell
12:07:54 <mauke> Scala_: no
12:07:58 <EvanR-work> Scala_: theres a syntactic sugar for them
12:08:00 <ksf> Scala_, monads aren't a haskell feature.
12:08:14 <aristid> Scala_: in fact, haskell had I/O even before monads were invented.
12:08:24 <ksf> http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_a_language_feature
12:08:44 <mauke> Scala_: seriously, I'd just ignore monads and learn Haskell
12:08:52 <Phyx-> wow, the simplifier output of ghc is nasty
12:09:24 <aristid> Real World Haskell, for example, doesn't teach monads until very late in the book
12:09:48 <Scala_> mauke: Well I'm mostly curious about how the concept works, I haven't had a reason to use haskell yet, though I'm always interested in how different languages implement and benefit from various concepts
12:10:06 <benmachine> haskell's main concepts are probably purity and laziness
12:10:08 <benmachine> and types
12:10:11 <mauke> Scala_: do you know groups (from algebra)?
12:10:12 <nominolo> Phyx-: right, so rules can only fire if things are inlined, and I don't think that's happening
12:10:18 <Scala_> mauke: Yes
12:10:35 <nominolo> benmachine: and type classes
12:10:41 <mauke> Scala_: they're a bit hard to explain if you haven't used numbers yet :-)
12:10:45 <ksf> ...and you won't grok those concepts before using them when you come from any other language than say clean
12:11:11 <soupdragon> class Group g where 0 :: g ; (+) :: g -> g -> g ;; inverse :: g -> g
12:11:14 <Scala_> Well, don't other languages implement 'monads' yet simply have other names for them?
12:11:16 <mauke> Scala_: in Haskell, monads are types that implement certain operations
12:11:19 <soupdragon> Scala_, read that
12:11:24 <soupdragon> that's a group right?
12:11:31 <soupdragon> here is monad:  class Monad m where map :: (a -> b) -> (m a -> m b) ; join :: m (m a) -> m a ; return :: a -> m a
12:11:41 <nominolo> Scala_: maybe this gives you an idea how monads came to be: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
12:11:43 <Phyx-> nominolo: i'll force inlining of that function and see
12:11:43 <ksf> Scala_, nope. they may use things that haskell models are monads, but they don't abstract it in the same way.
12:11:54 <nominolo> Phyx-: no, the producing functions must be inlined
12:12:08 <nominolo> Phyx-: i.e., the code that generates the strings
12:12:20 <ksf> it's like getting rid of basic. suddenly, you can define your own functions!
12:12:34 <Phyx-> nominolo: right, that's gonna be a problem :)
12:13:43 <Phyx-> i'll try and see if i can't get profiling up and running, so atleast I know for sure it's marshalling before i continue
12:15:07 <Scala_> nominolo: I'll take a look at that
12:15:49 <geheimdienst> deer #haksells, i has maked u a lolcat. hope u lykes. sinceriously, geheimdienst http://cheezburger.com/View/3749502464
12:16:33 <mauke> geheimdienst: :-[
12:16:37 <soupdragon> ;_;
12:17:11 <Phyx-> lol
12:17:15 <EvanR-work> cats
12:17:38 <aristid> geheimdienst: so insightful!
12:18:13 <aristid> i voted for excellent
12:18:33 <geheimdienst> aristid, thanks :)
12:18:39 <noteed> geheimdienst: now for the nuclear waste kitteh
12:18:46 <Phyx-> me too :)
12:19:06 <Phyx-> but now i got a sudden urge for a burrito
12:19:08 <nus> ...Every time you write a monad, a kitten gets choked?
12:19:29 <geheimdienst> nus, every time you write a monad, a kitty has some explaining to do
12:21:26 <aristid> the proper spelling is "kitteh" AFAIK
12:21:57 <geheimdienst> noteed, i'm pretty sure this might be relevant: http://www.google.com/images?q=kitty+has+reached+critical+mass
12:22:05 <Phyx-> is there a haskell kitty?
12:22:17 <nus> "No animals were while explaining this monad."
12:22:23 <nus> were harmed
12:22:35 <noteed> nus: you accidently the kitteh
12:22:56 <geheimdienst> phyx-, there were the lambdacats once, but they are no more. they were very funny if you ask me
12:23:39 <aristid> http://www.scannedinavian.com/~shae/lift-concat.jpg ?
12:24:14 <Phyx-> geheimdienst: they went extinct?
12:24:25 <sproingie> i just like the picture on http://fedora.org for no good reason
12:24:29 <sproingie> nom nom nom
12:26:43 <geheimdienst> phyx-, there was a place once where there was a whole collection of lambdacats. the site was called arcanux.com or something like that. server went down, domain expired. now you find only a few scattered ones here and there
12:27:14 <Phyx-> GOTTA CATCH EM ALL, LAMBDACATS
12:28:17 <Gracenotes> not even archive.org has them
12:28:49 <geheimdienst> it's a tragedy
12:29:09 <Phyx-> the internets has failed us
12:30:27 <nus> tooth for tooth
12:32:16 <Phyx-> i'm bored, think i'll go out and see the outside world
12:32:46 <geheimdienst> phyx-, link please
12:33:21 <Phyx-> geheimdienst: http://RealWorld/Outside
12:33:51 <geheimdienst> woah. didn't know it was accessible via http
12:34:33 <Phyx-> you'll get an installer 
12:35:10 <angstrom> http://incredimazing.com/static/media/2008/08/28/8a78212d96652ae/realityworstgame.jpg
12:35:36 <Phyx-> geheimdienst: http://farm4.static.flickr.com/3521/3704252356_686305032b_b.jpg is what's literally outside my window atm.. but don't feel like swimming
12:39:52 <aristid> Phyx-: you are evil.
12:40:13 <nus> Phyx-, .AN?
12:41:37 <Phyx-> aristid: lol, aww don't say that :)
12:41:40 <Phyx-> nus: yeah
12:41:47 <olsner> ski: did you try to send me a freshly baked scone cake over IRC?
12:43:44 <geheimdienst> that question you don't hear every day
12:44:12 <mauke> [freenode] DCC SEND from ski [85.224.18.232 port 14112]: freshly_baked_scone_cake [22kB bytes] requested in channel #haskell-blah
12:44:52 <Phyx-> that's a small scone
12:45:00 <geheimdienst> how bizarre
12:45:06 <Zao> mauke: The cake is a lie, I never got anything sent.
12:45:10 <Zao> Even though I had auto-accept :(
12:48:39 <Phyx-> SO.. If Apple is forced to do a consumer recall of the iPhone 4.. will that then be the largest recal in history?
12:50:56 <sproingie> doubtful
12:51:51 <sproingie> the carrier might demand a recall, but unless its a safety hazard, i doubt theyd be forced to recall them
12:52:47 <geheimdienst> didn't you read fake steve jobs? there is no problem. even if, it's your fault. also, it's your fault for not buying the $29 rubber band
12:53:09 <soupdragon> what irritates me is all the anti-apple stuff is about the money
12:53:15 <aristid> and even if you did, it's your fault for being a complainer bitch
12:53:15 <soupdragon> when the real evil isn't the cost of the things
12:53:19 <geheimdienst> so, problem solved. even though there was none.
12:53:56 <Phyx-> it's kinda weird that i *have* to buy a case to be able to use my phone to make calls..
12:54:07 <Phyx-> well.. there's farmville on the iOS now, so...
12:54:10 <Phyx-> and we rule...
12:54:52 <aristid> Phyx-: but the worst thing is that it isn't 100% sure whether Haskell is allowed
12:55:12 <Phyx-> I thought it was 100% that it wasn't allowed
12:55:34 <aristid> it's more complicated than that :/
12:55:46 <Phyx-> doesn't the iOS 4 charter state that you may only use objective C running on apple's software on macos to make iphone/ipad apps?
12:56:10 <sproingie> or javascript for safari
12:56:16 <Phyx-> it's particulairly one of the reasons I don't give a kitten's bum about making anything for any "i" products
12:56:28 <sproingie> but yeah that's basically why i won't buy an iPad
12:56:36 <geheimdienst> i was joking the other day that the iphone 5 will be a shape-less heap of electronics, advertised as the thinnest, smallest iphone ever. it's just that you need to buy a $29 rubber band, a $89 front glass pane thing and a $119 back casing, and put them all together
12:56:43 <sproingie> phone-wise i like a physical keyboard so i like my G1
12:57:15 <sproingie> i need to upgrade my phone tho, cyanogen on a G1 gets painfully slow 
12:57:20 * geheimdienst has a motorola droid
12:57:41 <Phyx-> geheimdienst: hah, the iPhone 5 will only allow you to make calls after you dance for it and say pretty please
12:57:51 <Phyx-> and pay a toll
12:57:54 <sproingie> i'll probably stick with an htc, i really love their phones
12:58:13 * Phyx- is sticking with an htc too
12:58:21 <Phyx-> but I won't mention which one, since i'll be lynched
12:58:53 <Phyx-> http://www.wolframalpha.com/input/?i=haskell lol
13:00:02 <sproingie> oh huh droid is htc
13:00:22 <Phyx-> i thought droid is motorola
13:00:40 <sproingie> well oddly verizon is selling the htc incredible using the droid name
13:00:46 <Phyx-> nexus one is htc
13:01:03 <geheimdienst> i mean this thing: http://images.google.com/images?q=motorola+droid
13:01:18 <sproingie> if i want a cheap phone i'm stuck with t-mobile's awesomely anemic offerings
13:01:29 <geheimdienst> (however it's sold under the name "motorola milestone" around here, but i googled and it's just marketed with two names"
13:01:44 * Phyx- is glad europe doesn't have those vendor specific deals
13:01:46 <sproingie> verizon's got the incredible, sprint's got the evo, t-mo has basically jack
13:01:53 <Phyx-> atleast not for a long time
13:03:36 <Phyx-> geheimdienst: gonna upgrade to a droid x?
13:03:57 <geheimdienst> no idea :) i'm not following phones too closely
13:04:03 <geheimdienst> i'm happy with this one for now
13:04:10 <Phyx-> hehe
13:04:14 <geheimdienst> anything cool about the droid x?
13:05:42 <Phyx-> no idea, don't follow android phones closely. I just know of people are hyper about it :P
13:06:11 <Zao> If I want to have a zipper over a possibly empty list, should I have   data Zip a = Zip [a] (Maybe a) [a]  or  data Zip a = EmptyZip | Zip [a] a [a]  ?
13:07:05 <aristid> there are 1000 persons with the name Haskell? more than expected
13:07:23 <kyagrd> aristid, last name or first name?
13:07:39 <aristid> "given name" means first name, right?
13:07:44 <kyagrd> right
13:08:07 <aristid> my name is not even recognised oO
13:08:36 <kyagrd> well actualy the other way in many Western cultures first name is the position for the given name
13:08:58 <Cale> Zao: We could do this the straightforward way. If you differentiate  L a = 1 + a * L a, you get L' a = L a + a * L' a.
13:10:49 <Cale> Zao: Which says that a list with a hole in it either has the hole in the very first position, followed by a normal list of elements, or it consists of some element followed by a list with a hole in it.
13:12:03 <Cale> Zao: Unsurprisingly, the thing a list with a hole in it always has is a hole :)
13:12:25 <Cale> Zao: and so the natural zipper will will always have at least that hole filled in.
13:12:38 <Zao> I see.
13:12:48 <Cale> But of course you can do it in other ways
13:13:34 <Zao> I think my use case leans towards the latter form.
13:13:53 <Zao> As the cases of "empty sequence" and "tracking an element in a list" are rather disjoint cases.
13:14:01 <Cale> Or you could have  data Zip a = Zip [a] a [a]  and use Maybe (Zip a) in some places
13:14:47 * tibbe is happy that to have finished integrating the new I/O manager into GHC.
13:14:52 <Cale> (just another option)
13:14:54 <jmcarthur> data Zip a = Zip [a] [a]  -- head of one of the lists is the hole
13:15:42 <stoltene2> Does anyone have a link to a good paper on zippers?
13:16:08 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.8611
13:16:17 <kyagrd> The Zipper or Scrap your zippers?
13:16:51 <Cale> The original link there is dead, click the cached PDF instead :)
13:17:25 <Cale> That might be a bit of a technical explanation
13:21:06 <soupdragon> they differentiate functions on finite sets too
13:21:35 <soupdragon> like f : |Z[X] has a derivative
13:34:23 <stoltene2> Thanks for the paper link
13:41:30 <ksf> there seem to be two drawing plugins for vim, one which does diagonals and arrows, and the other which can use unicode.
13:49:34 <ksf> hmmm I didn't use cpan for a looooong time
13:53:36 <Peaker> What do you think about renaming fromJust to unJust? :)
13:54:00 <geheimdienst> unjustified
13:54:03 <ddarius> Just remove fromJust.
13:54:21 * ddarius writes fromNothing :: Maybe a -> a
13:54:33 <geheimdienst> Maybe remove fromJust, Just remove fromJust
13:54:53 <hpc> remove Nothing
13:55:36 <Peaker> ddarius, Heh
13:55:39 <geheimdienst> done, i've removed nothing. haskell is exactly as it was before
13:55:56 <Peaker> Well, I guess each particular "fromJust" has its own reason, so should have it's own "fromJust" with a proper error message
13:56:27 <geheimdienst> maybe (fail "bla") (your code)
13:56:30 <Peaker> I have "Proof tokens" that some condition holds, and something that returns (Just x) when the condition holds, or Nothing when it doesn't
13:56:54 <Peaker> maybe (fail "bla") return
13:57:11 <Peaker> or: fromMaybe (error "bla")
13:57:20 <sproingie> data Vague = Nothing | Something
13:57:37 <benmachine> data Definitely a = Just a
13:58:17 <aristid> ddarius: fromNothing = const undefined?
13:58:29 <sproingie> fromNothing = Nothing
13:58:35 <aristid> sproingie: wrong type
13:58:39 <sproingie> darn
13:58:48 <jmcarthur> data OMGIDunno a = OMGYeah a | OhNo
13:59:01 <benmachine> heh
13:59:07 <sproingie> you mean ONOEZ
13:59:09 <aristid> sproingie: lol i just realized that i noticed the type mismatch in less than 6 seconds
13:59:54 <jmcarthur> data Shrug a = Nod a | HeadShake
14:00:01 <Peaker> yairchu wrote some TH macro to generate ADT getters, so you get something like: fromNothing :: Maybe a -> Maybe () ; fromJust :: Maybe a -> Maybe a   (It makes more sense for non-Maybe ADT's :)
14:01:19 <aristid> Peaker: for Maybe the usefulness of fromJust seems questionable:)
14:01:42 <lispy> fromJust = id?
14:01:50 <lispy> Or does it fail on Nothing?
14:01:55 <c_wraith> it just blows up
14:01:57 <pikhq> It fails on Nothing.
14:02:09 <Peaker> aristid, Yeah, it's more for things like:  fromLeft :: Either a b -> Maybe a   or:   fromCons :: [a] -> Maybe (a, [a])
14:02:15 <lispy> Partial function fail
14:02:17 <ksf> Graph::Easy is great.
14:02:24 <Peaker> lispy, It's just id
14:02:27 <Peaker> lispy, it's auto-generated
14:02:42 <pikhq> Peaker: Not the familiar fromJust.
14:02:46 <pikhq> :t fromJust
14:02:47 <lambdabot> forall a. Maybe a -> a
14:03:01 <Peaker> Right, I'm talking about the fromJust you'd get from the ADT getter TH macro
14:03:07 <Peaker> which generates safe getters (results wrapped in Maybe)
14:03:57 <aristid> Prelude.fromJust is arguable unsafe.
14:04:33 <pikhq> Not merely arguably.
14:04:55 <Phyx-> it just plain is unsafe :/
14:05:08 <djahandarie> It's also not in Prelude last I checked
14:05:10 <pikhq> Just as much as head and tail.
14:05:14 <Peaker> Maybe the unsafe partial functions should take an error string for the partial case? Getting crashes like: "fromJust: Nothing" is terrible
14:05:19 <pikhq> :i fromJust
14:05:21 <Peaker> Haskell needs some form of program trace on crashes
14:05:33 <pikhq> Erm.
14:05:36 <Peaker> It's fun that debugging is much more rare.. But when you need to debug Haskell, it's a pain
14:05:41 <pikhq> Nope, not Prelude.
14:05:45 <Phyx-> Peaker: SPJ wrote one once
14:05:57 <Phyx-> hasn't made it into the release ghcs
14:06:01 <Peaker> Phyx-, :-(
14:06:04 <lispy> Peaker: well, you can use ghci debugger, or some of the other tricks for compiled programs
14:06:05 <Peaker> SPJ is awesome
14:06:27 <lispy> Phyx-: oh, really?  That's cool
14:06:27 <pikhq> Peaker: It's a bit of a pain to define what debugging Haskell even entails.
14:06:29 <ClaudiusMaximus> my favourite crash is "Prelude.undefined", especially when my own code doesn't use it
14:06:33 <Peaker> lispy, It's hard to use ghci for a real-world program that broke due to a set of changes, and you're not sure why/where
14:06:35 <benmachine> fromJust isn't unsafe
14:06:45 <benmachine> it's just not terribly helpful
14:06:48 <zygoloid> GAH! i've generated a CAF called 'type' with TH and now i can't call it :(
14:06:52 <aristid> djahandarie: i was writing Prelude.fromJust to distinguish it from Peaker's toJust but you are right, it's not actually in Prelude :/
14:07:00 * zygoloid cries
14:07:03 <Phyx-> lispy: yeah, it's not really all that hard, me and someone else made a basic implementation for UHC aswell
14:07:06 <pikhq> @hoogle fromJust
14:07:07 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
14:07:12 <lispy> Peaker: Yeah.  But in those cases, you can instrument partial functions and other exceptions to print out line numbers
14:07:13 <pikhq> Thar
14:07:21 <Phyx-> but it involves you having a "debug" version of every module around
14:07:21 <pikhq> That's a silly silly function.
14:07:48 <lispy> Phyx-: oh.  Like how the profiler works?
14:07:53 <aristid> :t maybe id undefined
14:07:54 <lambdabot> forall a a1. Maybe a1 -> a -> a
14:08:00 <Peaker> lispy, how?
14:08:03 <Phyx-> lispy: basically
14:08:11 <Phyx-> lispy, Peaker http://research.microsoft.com/~simonpj/papers/stack-trace/DebugTraces.pdf
14:08:13 <soupdragon> I have found  Divergent Series - Hardy,G.H -- On archive.org
14:08:17 <aristid> :t maybe undefined id
14:08:17 <pikhq> Phyx-: I dunno about you, but I have debugging symbols for every C, C++, and asm program on my computer...
14:08:18 <lambdabot> forall a. Maybe a -> a
14:08:27 <pikhq> And the source code for the relevant symbols.
14:08:34 <Peaker> Phyx-, is that usable?
14:08:40 <nominolo> Phyx-: Tristan wrote that, not SPJ.  He did create a lot of input, of course.
14:08:41 <lispy> Peaker: I'm not a good encylopedia so I forgot the details, but I've seen 2-3 different ways to do this.  CPP macros, using assert, and one other that I don't recall at the moment
14:08:45 <Phyx-> pikhq: I wasn't saying it's a bad thing, I was just saying what it requires
14:08:50 <pikhq> Mmkay.
14:09:00 <Phyx-> nominolo: ah, it was a SPJ paper so I assumed :P
14:09:09 <nominolo> Phyx-: SPJ was the second author
14:09:13 <Phyx-> Peaker: what is?
14:09:13 <zygoloid> haha, TH takes away, and TH gives back again. type' = $( varE . mkName $ "type" )
14:09:34 <Phyx-> nominolo: yeah, there are 3 of them :)
14:09:39 <Peaker> Phyx-, "DebugTraces"
14:09:44 <soupdragon> it'sa book about stuff like 1 + 1 + 1 + 1 + ... = -1/2
14:09:44 <nominolo> Phyx-: usually the first author did most of the work.
14:09:53 <Phyx-> Peaker: haven't seen a public build really
14:10:02 <Phyx-> nominolo: ah, i was not aware of that :) good to know
14:10:08 <ksf> zygoloid, up to modules.
14:10:29 <Phyx-> Peaker: when we implemented our version it was pretty usable.
14:10:41 <Peaker> Phyx-, Have you made it available?
14:10:46 <ksf> ...usually, you want 'type.
14:10:54 <Phyx-> though it only supported functions from the Prelude, due to not having enough time
14:10:55 <zygoloid> ksf: does that work? :O
14:11:06 <ksf> it's the only way to do 'Foo.bar
14:11:08 <zygoloid> no, it does not work :(
14:11:10 <Phyx-> Peaker: no, it was part of a class, so the code is in a deep dark svn hole by now
14:11:24 <zygoloid> ksf: my identifier is in scope, tis fine
14:11:25 <ksf> ...and of course, no, type is a keyword.
14:11:35 <zygoloid> ksf: that was the cause of my original problem
14:11:44 <Peaker> Phyx-, Haskellers all around are in dire need of stack/evaluation/w.e traces
14:12:01 <ksf> Peaker, and those that aren't around use monadloc
14:12:22 <zygoloid> why do the C bits of the GHC RTS have to use haskell keywords as identifiers? it's /so/ inconsiderate :)
14:13:00 <Phyx-> Peaker: who knows, maybe in the future someone will bake it in, it's one of those features that's again, nice to have but no one wants to implement
14:13:44 <nominolo> Phyx-: Tristan implemented it as a Core plugin.  It might be better to do it at a higher level.  Tristan had some problems with lost information.
14:14:05 <nominolo> Phyx-: for example, it sometimes depended on implementation details of the desugarer
14:14:14 <Peaker> ksf, how id that used
14:14:18 <Peaker> ksf, how is that used?
14:15:26 <Phyx-> nominolo: right, we tried to make our on the HS level first, but that didn't really work out, pointfree functions with no types were a problem, so we needed to do it after typechecking, So we implemented it in the EH phase (of UHC) i suppose in GHC you could do it on typechecked module. that should contain everything you need
14:15:33 <hgolden> FYI: Lots of spam "users" were added to the Haskell wiki. Can someone delete them, please?
14:16:03 <mtnviewmark> I believe that there has been a clean up effort going on for days now
14:16:45 <hgolden> maybe this is a job for lambdabot?  ;-)
14:17:15 <ksf> Peaker, it's part of control.monad.exception
14:17:30 <Axman6> Peaker: heh, i read that first sentence as "how that used"
14:17:43 <ksf> you either give explicit points or use a preprocessor which inserts info at every statement line.
14:17:55 <Phyx-> nominolo: we also found out that strict lambdas shouldn't be annotated, since that changes the semantics, unless you also force the immediate evaluation of the stack push
14:18:04 <Peaker> ksf, What monads does it work with?
14:18:11 <ksf> it's a transformer
14:18:14 <Peaker> ksf, ah
14:18:30 <Phyx-> or rather, abstactions bound to a strict application
14:18:33 <Peaker> ksf, That's a bit too intrusive for a debugging technique, I think
14:18:39 <soupdragon> > map ((`mod`27).(3^)) [1..20]
14:18:40 <lambdabot>   [3,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
14:18:44 <soupdragon> > map ((`mod`27).(4^)) [1..20]
14:18:45 <lambdabot>   [4,16,10,13,25,19,22,7,1,4,16,10,13,25,19,22,7,1,4,16]
14:18:54 <ksf> or rather, it's a typeclass.
14:19:06 <ksf> I've only used it with cme
14:20:11 <soupdragon> > let a = 3 ; map (\i -> ((a^19^i)`mod`(19^i),(a^19^(i+1)`mod`(19^i)) [1..20]
14:20:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:20:15 <soupdragon> > let a = 3 in map (\i -> ((a^19^i)`mod`(19^i),(a^19^(i+1)`mod`(19^i)) [1..20]
14:20:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:20:26 <soupdragon> hmf
14:20:29 <soupdragon> why is this happening
14:20:32 <Axman6> let ... in ...
14:21:00 <Phyx-> Peaker: http://www.vimeo.com/6679381 a video of it
14:21:10 <ddarius> soupdragon: You're missing a parenthesis.
14:21:13 <Axman6> > let a = 3 in map (\i -> ((a^19^i)`mod`(19^i),(a^19^(i+1)`mod`(19^i))) [1..20]
14:21:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:21:22 <soupdragon> I hate all these stupid bcrakets
14:21:29 <Peaker> Phyx-, Thanks
14:22:06 <Twey> Don't use them, then
14:22:11 <soupdragon> > let a = 4 in (\m -> ((a^7^m)`mod`(7^m),(a^7^(m+1))`mod`(7^m))) map [1..6]
14:22:12 <lambdabot>   Couldn't match expected type `t1 -> t'
14:22:12 <lambdabot>         against inferred type `(a, a...
14:22:22 <soupdragon> > let a = 4 in (\m -> ((a^7^m)`mod`(7^m),(a^7^(m+1))`mod`(7^m))) `map` [1..6]
14:22:23 <lambdabot>   [(4,4),(18,18),(18,18),(1047,1047),(15453,15453),(82681,82681)]
14:22:34 <Phyx-> And on that note, I'm going to go outside, bbl
14:22:48 <soupdragon> what the hell they are actually equal... I thought it was a misprint
14:23:10 <Phyx-> nominolo: or just simply strict application :P can't remember atm, i'll check the read me we wrote later :/
14:24:46 <nominolo> Phyx-: Max Bolingbroke also tried to do a similar thing but for the dynamic call stack
14:24:58 <nominolo> Phyx-: I'm not sure how far he got.
14:26:47 <nominolo> ok, got to go
14:26:58 <Phyx-> nominolo: we toyed with the idea, to annotate at a highlevel, and if debug is desabled, having the optimized optimize it out completely. since UHC does whole program analysis
14:27:04 <Phyx-> nominolo: ok, have fun :)
14:27:38 <aristid> if i wanted to implement whole-program optimization i think i'd use GHC as the basis
14:28:13 <Phyx-> GHC doesn't even have the whole program afaik
14:28:16 <FunctorSalad> hmm compiling a lib both as split objects and as a shared library doesn't make much sense, does it?
14:28:31 <FunctorSalad> and might be the reason of some compile errors I'm getting?
14:29:08 <FunctorSalad> (I thought the point of split objects is to make executables that statically use them smaller?)
14:29:38 <aristid> Phyx-: doesn't prevent you from using it as the basis for compiling the units to intermediate representation
14:30:01 <Phyx-> aristid: but why not use something that's designed for it in the first place
14:30:31 <FunctorSalad> (my understanding of linking is very basic...)
14:30:44 <soupdragon> > let a = 4 in (\m -> ((a^7^m)`mod`(7^(m+1)),(a^7^(m+1))`mod`(7^m))) `map` [1..6]
14:30:45 <lambdabot>   [(18,4),(18,18),(1047,18),(15453,1047),(82681,15453),(82681,82681)]
14:32:06 <FunctorSalad> (I have split-objects on in my cabal config, and I'm running cabal with --enable-shared)
14:32:24 <aristid> Phyx-: because maintaining a compiler is a lot of effort.
14:32:26 <Phyx-> have no idea what split-objects are :P
14:33:08 <Phyx-> aristid: exactly, so you'll be modifying a compiler to do something it wasn't meant to, and then you would have to maintain it
14:33:59 <aristid> Phyx-: i don't see why GHC would be unable to adapt to whole-program compilation
14:34:12 <aristid> Phyx-: most of the code can probably be unchanged
14:34:23 <jmcarthur> isn't somebody *working* on whole program compilation in ghc?
14:34:45 <FunctorSalad> you mean it isn't present already?
14:35:06 <ddarius> It exists to a minor extent due to cross-module inlining.
14:35:12 <triyo> Args data type of QuickCheck has a field "maxSize" - "size to use for the biggest test cases". What does this exactly mean?
14:35:25 <jmcarthur> under the assumption that whole program compilation is required for supercompilation, this effort seems relevant: http://hackage.haskell.org/trac/ghc/wiki/Supercompilation
14:35:43 <Phyx-> I'm not sure all the optimizations would scale that well to whole programs. It seems to me like some would become quite slow. especially the ones that collect alot of local information. since that has to be done over a much larger collection everytime
14:35:45 <mtnviewmark> triyo: I believe it is left to the particular data types to decide on their own
14:35:54 <ddarius> I don't see why whole program compilation would be necessary for supercompilation.
14:36:26 <jmcarthur> my understanding of supercompilation is that it requires a ton of evaluation at compile time, right?
14:36:37 <jmcarthur> without crossing module boundaries, that doesn't seem very useful
14:36:46 <ddarius> It doesn't do any "evaluation" at compile-time, though it can get that effect.
14:36:47 <triyo> is this the max size of the arbitrarily generated values? Seems to be.
14:37:14 <ddarius> (Of course, practically all optimization get the effect of doing evaluation at compile-time.)
14:37:26 <triyo> mtnviewmark: its adjustable of course, and does seem to generate different size of arbitrary values.
14:38:12 <mtnviewmark> right - instances of Arbitrary interpret it as they see fit -- the idea that they should be generating "increastingly complex" values as the "size" parameter increases
14:39:00 <triyo> mtnviewmark: ah, thats exactly the effect I am observing during my test runs
14:39:57 <CakeProphet> class Reply m r where reply :: m -> r; replyTo :: TChan m -> TChan r -> STM ()   --minimally complete = reply
14:40:19 <CakeProphet> bam. message passing. :)
14:47:10 <ddarius> CakeProphet: That seems like an awkward class to use...
14:48:05 <ddarius> CakeProphet: What is the default definition of replyTo?
14:48:36 <Gracenotes> I do wonder where do you get the tchans from..
14:48:59 <Zao> When a daddy tchan and a mommy tchan like each other a lot...
14:49:43 <Peaker> All my Haskell code has huge import lists on the top.. I wish my editor could manage that as I just happily hoogle my names :(
14:49:55 <Peaker> Tiny module -> huge import list
14:50:05 <soupdragon> > let a = 2 in (\m -> ((a^2^m)`mod`(2^(m+1)),(a^2^(m+1))`mod`(2^m))) `map` [1..22]
14:50:06 <lambdabot>   [(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0...
14:50:19 <ddarius> Peaker: Get Visual Haskell working again (and likely add quite a bit of features to it as well...)
14:50:26 <soupdragon> > let a = 2 in (\m -> ((a^3^m)`mod`(3^m),(a^3^(m+1))`mod`(3^m))) `map` [1..22]
14:50:31 <lambdabot>   mueval: ExitFailure 1
14:50:59 <Peaker> ddarius, What's Visual Haskell? Does it auto-maintain the import lists? Remove stuff when you remove code, etc?
14:51:18 <Peaker> ddarius, I'm currently working on something similar -- a structural code editor which should eventually have these features
14:51:46 <ddarius> Peaker: It was some Haskell support built into Visual Studio.  Visual Studio can clean import lists and can resolve imports though it does not do that automatically (and I wouldn't want it to.)
14:52:11 <Peaker> ddarius, why wouldn't you want it to?
14:52:45 <Peaker> I don't even want to see import lists - I want to see qualified names when I hoogle, but otherwise I don't see why I should care to manually manage or even look at the import list
14:52:56 <ddarius> Peaker: Why -would- I want it to?  I don't want it adding modules just because I typo a name or removing modules for the same reason or I may just want modules imported that aren't (currently) used.
14:53:08 <ddarius> Peaker: Use Java.
14:53:21 <Peaker> ddarius, Well, if you typ-o during search, you see that you did, you explicitly select a fully qualified name
14:53:30 <Peaker> ddarius, I heard good things about Java IDE's indeed
14:53:37 <Peaker> But the language :-(
14:53:39 <ddarius> Peaker: I wasn't talking about the IDE.
14:53:53 <Peaker> ddarius, What then?
14:53:57 <ddarius> Peaker: In Java you can just fully qualify every name and don't need to import anything.
14:54:07 <Zao> I can't wait for the work of this person to be finished: http://mistuke.wordpress.com/
14:54:20 <Peaker> ddarius, Oh, I don't want to type fully qualified names, I just want them displayed that way in my name search completion box
14:54:40 <Peaker> ddarius, Or if there's ambiguity or if I press a special key combo, I'd like my editor to show names fully qualified
14:54:58 <Peaker> Or when the cursor is on a name, it'd be nice to have an info pane display info about it, including fully qualified name, too
14:58:59 <sm> do we know which xml lib is "winning" ?
14:59:41 <Peaker> I like the simple one, though it seemed to have some bugs regarding some XMLisms (encoding specs, and maybe other things)
14:59:46 <Twey> HXT, probably
15:00:00 <Twey> It has a fairly steep learning curve, though
15:00:09 <sm> HXT is what I was just studying
15:00:15 <Peaker> It's the arrow one right? I dislike arrows :)
15:00:20 <sm> yes
15:01:26 <Gracenotes> weren't they ranked by downloads recently?
15:04:06 <Peaker> That's a bit of a problem given indirect popularity.. if xmonad used one of the XML libs, it would jump to be the "most popular" one
15:04:09 <c_wraith> I thought galois' simple xml lib was winning.
15:04:24 <c_wraith> The one that has precisely 0 fancy features. :)
15:04:24 <Peaker> Maybe if you subtract the amount of downloads of dependents from each package download count
15:04:35 <Peaker> that doesn't work either though, maybe the max of all dependents
15:04:48 <Peaker> c_wraith, I like non-fancy :)
15:05:16 * sm likes reliable
15:08:08 <BMeph> Why do people seem to love spouting an obvious lie as an obvious fact: that "Haskell has no side effects"? :\
15:08:32 <soupdragon> haskell isn't practical because it doesn't support input and output
15:08:34 <Saizan> define Haskell.
15:08:43 <ivanm> BMeph: you prefer dons' characterisation where Haskell has controlled side-effects?
15:08:43 <aristid> BMeph: define "side effects"
15:09:04 <pikhq> ivanm: It at least has relation with reality.
15:09:23 <Peaker> BMeph, Or jdh's: Haskell "struggles with Quicksort/hash tables"...
15:09:30 <Saizan> BMeph: my pov is that haskell has no side-effects, only effects, they are not side anymore :)
15:09:46 <BMeph> ivanm: It's surely better than the clain that Haskell has or allows no side effects, isn't it?
15:09:50 <Saizan> BMeph: modulo unsafePerformIO off course
15:09:57 <aristid> Saizan: just wanted to say that:)
15:10:50 <aristid> Peaker: heh the whole haskell community seems to unite against that guy as an enemy
15:11:19 <Peaker> aristid, Well, he does clearly have an agenda and he repeats his refuted lies
15:11:22 <ivanm> BMeph: well, even though it isn't strictly true the whole "no side effect" claim has more shock value... *shrug*
15:11:27 <BMeph> aristid: You'd have to ask the folks that insist that Haskell "disallows any side effects." Hopefully, it's a definition that every PL around does not also trivially match....
15:11:44 <ivanm> Peaker: I did find an old lambda-the-ultimate discussion where he admitted Haskell was used in industry...
15:11:45 <ivanm> ;-)
15:11:54 <aristid> Peaker: oh i definitely agree that the guy deserves the hate
15:12:03 * BMeph hates "shock value".
15:12:06 <zygoloid> haskell has "effects". i wouldn't say they're particularly "side" though
15:13:13 <sproingie> my shock value statement is "haskell doesn't even have VARIABLES"
15:13:26 <sproingie> gets their attention
15:13:32 <ddarius> BMeph: 'prefer "shock effect"?
15:13:42 <Veinor> haskell disallows side effects if you don't use the mechanism it has for side effects!!!!
15:13:49 <ivanm> reddit says there are 18 comments here: I count 5: http://www.reddit.com/r/haskell/comments/cou33/haskell_2010_accepted_papers/
15:13:52 <aristid> sproingie: but that's a lie. what about IORef and similar?
15:14:24 <pikhq> Veinor: So does C. :)
15:14:30 <Gracenotes> ivanm: perhaps someone made a comment and subsequently deleted it 13 times
15:14:37 <ivanm> Gracenotes: heh
15:14:41 <BMeph> I agree on principle with those who say that running a program has effects, not "side effects" - although perhaps the characterization is a way to mentally deal with the difficulty of Concurrency control. ;)
15:14:55 <Veinor> I wish I could think in parallel
15:14:59 <Veinor> then I could write concurrent programs
15:15:39 <ivanm> For those who care: I've currently had 25 responses to my FGL-naming survey; 63% of people prefer inductive-graphs
15:15:43 <sproingie> aristid: yes there is much handwavey inaccuracy to the statement.  you have variables galore in your various monads like IO
15:16:17 <BMeph> ddarius: I'd "prefer" "dramatic exaggeration"...if it's how it's being used.
15:16:58 <sproingie> i think it's safe to say that "invisible side effects" are not allowed
15:17:04 <geheimdienst> ivanm, what's the survey? i can has link plz?
15:17:12 <aristid> sproingie: unsafePerformIO is not invisible?
15:17:13 <sproingie> if you mutate an IORef, you're returning IO something, no way out of it
15:17:23 <ivanm> geheimdienst: https://spreadsheets.google.com/viewform?formkey=dGpzMmFnUWY3Uktodk5wdHlLQk5kT1E6MA&theme=0AX42CRMsmRFbUy1jZGZhYTJjOC0xYzc1LTQyYzEtYWM3MC1mMjQ1YzEwYWM3NzE&ifq
15:17:28 <sproingie> unsafe is, well, unsafe :)
15:17:29 <geheimdienst> thanks
15:17:43 <ivanm> geheimdienst: you obviously don't read haskell@, haskell-cafe@, libraries@, planet-haskell or the haskell reddit :p
15:18:14 * ddarius loves it when he's playing guitar and looks at his hands and thinks, "I wish I could do that."
15:18:21 <aristid> ivanm: why would he. burrito kitteh does all the splaining for him
15:18:36 <geheimdienst> true. i hang out on irc, read xmonad@, and try to keep an eye on -cafe, but it's just such a boatload ...
15:18:40 <ivanm> aristid: heh
15:19:28 <geheimdienst> ... and for 80% of the topics, i'm nowhere near even understanding what's being discussed. let alone contributing.
15:19:47 <ddarius> Understanding is optional.
15:20:31 <geheimdienst> ddarius, not for me. i'm neither a troll nor an academic, so i want understanding
15:20:47 <sm> now a pandoc question - why does it generate a table of contents only with --standalone ?
15:20:54 <ivanm> geheimdienst: reading stuff will eventually help with your comprehension
15:21:07 <ivanm> sm: because otherwise it generates little sub-pages that you might want to stick together
15:21:16 <ivanm> and do you really want multiple TOCs on the same page?
15:22:04 <ivanm> anyone here have a reddit account and willing to submit a response on my behalf to this? http://www.reddit.com/r/haskell/comments/cp50y/should_the_new_graph_library_be_called_fgl_or/c0u6b6n
15:22:25 <sm> ivanm: I'm not following.. I want the one big TOC at the top, regardless of whether I'm adding standard header with --standalone
15:22:59 <aristid> ivanm: it's hard to read everything on -cafe :)
15:23:31 <Peaker> The Prelude is so narrow in Haskell, compared with other languages..  Control.Monad, Control.Applicative, Data.Maybe, Data.List, and many others should probably go in.. Many conflicts should be resolved by more use of type-classes
15:23:45 <sm> I see.. the toc is added by the output template, and an output template is used only in --standalone mode
15:23:52 <aristid> @pl (f .$ g) x = (f) . (g $ x)
15:23:53 <lambdabot> (line 1, column 12):
15:23:53 <lambdabot> unexpected "="
15:23:53 <lambdabot> expecting variable, "(", operator or end of input
15:24:06 <aristid> @pl dotdollar f g x = (f) . (g $ x)
15:24:06 <lambdabot> dotdollar = (.) . (.)
15:24:18 <sm> guess I need to use standalone mode but with a custom template
15:24:22 <ivanm> sm: without --standalone, you're just converting a small fragment to html, and you might be converting lots of smaller files to join up later on
15:24:22 <aristid> hey that's the same as result.result
15:24:33 <ivanm> aristid: heh, true
15:24:52 <soupdragon> I still don't get why people don't just use lambda everywhere
15:25:20 <ivanm> sm: why not join the pandoc mailing list and ask there, or email john macfarlane directly?
15:25:23 <sm> thanks. This is rather useful in fact
15:25:47 <sm> ivan: too slow for a quick question.. got it now, thanks for the help
15:25:52 <Saizan> soupdragon: heavier syntax, names to invent and to follow
15:26:56 <yitz> soupdragon: no guards, only one bind per function
15:27:05 <ivanm> sm: well, that's just my guess about why anyway ;-)
15:27:15 <ivanm> maybe it's a bug that --toc doesn't work if you don't enable --standalone
15:27:36 <msieradzki> is anyone working on haskell library that'd generate vectorized code for GPU?
15:27:47 <Peaker> soupdragon, I find them ugly and take it as a challenge to find/invent the points-free combinators necessary to avoid the lambdas :)
15:27:55 <msieradzki> like numpy or its extension (forgot the name)
15:27:57 <Peaker> soupdragon, and if that fails, I use a "where" clause and give the lambda a name
15:28:15 <Saizan> Peaker: that's perverse
15:28:29 <yitz> Saizan: why perverse?
15:28:50 <ivanm> msieradzki: there are a few attempts
15:28:57 <ivanm> none really at the "usable" stage yet IIUC
15:28:59 <msieradzki> what I meant is
15:29:07 <msieradzki> that python has small, simple usable library
15:29:20 <msieradzki> that just works on CUDA ;P
15:29:20 <ivanm> last I checked, numpy wasn't small or simple ;-)
15:29:23 <yitz> msieradzki: http://www.haskell.org/haskell-symposium/2010/accepted.html
15:29:31 <ivanm> (hence why they still haven't ported to python-3)
15:29:40 <jmcarthur> msieradzki: accelerate, but only the API is on hackage, not a GPU implementation
15:29:42 <ivanm> yitz: dammit, I was just about to paste a link to that!!!
15:29:56 <jmcarthur> msieradzki: and for graphics, there's GPipe and a project that conal is working on
15:30:00 <jmcarthur> that generate shaders
15:30:07 <msieradzki> ivanm I don't even remember if it was numpy or some other library, friend showed it to me and I forgot what it was
15:30:14 <msieradzki> just really simple not trying to achieve a lot but works
15:30:25 <ivanm> msieradzki: if it has a GPU backend, it isn't small or simple
15:30:35 <msieradzki> 500 lines of code?
15:30:38 <aristid> ivanm: the confusing thing about twaan van laarhovens composition operators is that seemingly the second set is entirely different from the first set
15:31:03 <Saizan> yitz: avoiding lambdas in favour of where's is just too heavy for something that you even tried to eliminate..
15:31:03 <ivanm> I highly doubt any library with a GPU-backend is only 500 lines of code
15:31:13 <msieradzki> I should use word primitive
15:31:17 <ivanm> aristid: huh?
15:31:24 <ivanm> msieradzki: that's a different story then ;-)
15:31:28 <aristid> ivanm: look at the types of the two different (.$)
15:31:40 <aristid> :t let (f .$ g) x = (f) . (g $ x) in (.$)
15:31:41 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
15:31:41 <ivanm> here in Haskell-land we don't like "primitive" libraries; we want nice abstractions!
15:31:47 <Dashkal> I am really starting to hate mutable languages... I could really use head for a php array...
15:31:48 <aristid> :t let (f .$ g) x = (f x) (g) in (.$)
15:31:49 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t1 -> t -> t2
15:31:59 <Veinor> Dashkal wants to get head
15:32:06 <ivanm> aristid: I'm not sure of the context of why you just said that to me, hence my "huh?"
15:32:07 <Dashkal> >.>
15:32:12 <Dashkal> No comment?
15:32:16 <Veinor> :D
15:32:39 <ivanm> Dashkal: just get the first value?
15:32:49 <ivanm> but arrays /= lists
15:33:13 <Dashkal> ivanm: The only way I know to do that is to $foo = array_keys($ary); return $ary[$foo].  Which feels nasty.
15:33:15 <jmcarthur> msieradzki: we also have a couple libraries for automatically parallel arrays, they just use multiple CPUs rather than the GPU
15:33:25 <Dashkal> erm, $foo[0]
15:33:28 <Dashkal> bleh
15:33:35 <aristid> ivanm: hmm
15:33:44 <aristid> <ivanm> aristid: heh, true
15:33:45 <Dashkal> I miss [(a,b)]...
15:33:47 <msieradzki> the difference between nv 8xxx GPU and 4 cores
15:33:49 <msieradzki> is enormous
15:33:59 <aristid> ivanm: i thought you knew that this was referring to http://twan.home.fmf.nl/blog/haskell/more-function-composition.details
15:34:01 <ivanm> aristid: that was to the "there are too many discussions on -cafe to follow" comment you made to me ;-)
15:34:08 <aristid> oh
15:34:15 <jmcarthur> msieradzki: well, they are each good for different things at least
15:34:22 <ivanm> (or words to that effect)
15:34:32 <aristid> yeah i did say that:)
15:40:39 <ddarius> soupdragon: The original purpose of point-free notation was to ease algebraic manipulations.  map f . map g = map (f . g) is nicer than, \xs -> map f (map g xs) = map (\x -> f (g x)) which isn't even true due to unclear capturing issues.
15:40:48 <lispy> Yeah, -cafe is pretty high volume these days
15:40:56 <lispy> I've been making a point to follow it lately, but I think I'm being insane
15:41:13 <ivanm> lispy: whereas I just go "boring discussion, next thread"
15:41:29 <lispy> ivanm: you comment a lot actually :)
15:41:57 <ivanm> I also procrastinate ;-)
15:43:01 <Peaker> I have the daily train ride to keep me from procrastinating
15:43:03 <Peaker> no internet/IRC there
15:43:08 <lispy> ivanm: how is the new fgl coming along?
15:43:16 <FauxFaux> Peaker: Most phones can do irc these days.
15:43:31 <ddarius> Peaker: That doesn't (itself) keep you from procrastinating.
15:43:35 <ivanm> kinda stopped atm; the last couple of weeks I was hacking on old-fgl + graphviz + etc.
15:44:02 <ivanm> also, tomberek keeps being on holidays and I don't want to make too many more changes without discussing it with him
15:44:04 <Peaker> ddarius, I have a laptop, no internet, and developing my project is the only pastime :)
15:45:01 <Peaker> FauxFaux, I intentionally don't get internet, though I could :)
15:45:21 <lispy> ivanm: ah
15:45:31 <Phyx-> i disconnected again
15:45:33 <Phyx-> sheesh
15:45:42 <lispy> ivanm: did you guys ever find a way to work around the graphviz limitations so that it will work on large code bases like ghc/darcsr?
15:46:14 <ivanm> lispy: it takes a long, long, time as it is...
15:46:17 <lispy> ivanm: I'm refering to SourceGraph or whatever it's called.  You work on that, right?
15:46:29 <ivanm> so the work around will probably be "write bindings to something else like tupil" :s
15:46:39 <lispy> oof
15:47:27 <ivanm> yeah :s
15:47:55 <dbueno> Hello.  Has anyone ever encountered a case where with a custom monad the bind operator is dominating the program runtime?
15:48:34 <ivanm> dbueno: sounds like a bug in your monad definition
15:49:11 <dbueno> ivanm: that is certainly possible.
15:49:34 <dbueno> Basically, I have some code that should account for much (say 70%) of the runtime.
15:49:54 <lispy> dbueno: I've heard of that when there was a lot of dictionary passing for the moand instance
15:50:06 <lispy> dbueno: are you using monadLib or mtl to generate your monad?
15:50:12 <dbueno> But it only accounst for 21% or so and he monadc-bind for the monad the code is written in acually takes up 70% or
15:50:24 <dbueno> lispy: no, I'm not.
15:50:30 <dbueno> I could past the instance.
15:50:44 <c_wraith> I've also heard of it in cases like using the Either monad for lots of small operations, resulting in a lot of pattern matching and construction of new values in the bind operator.
15:50:54 <lispy> dbueno: pastebin if you do that :)
15:50:57 <dbueno> Basically I wanted a monad with a few features -- I was using mtl but thought it would be faster if I didn't stack the monads
15:51:31 <lispy> dbueno: Well, profiling is the first step.  You could take a look at ghc-core, but if you're not used to reading it then it's gibberish :)
15:52:03 <dbueno> pasted: http://haskell.pastebin.com/6i1WnWV0
15:52:29 <dbueno> lispy: initially after going from the monad stack to the monad, I got unconditional speed up.  Not alays fantastic, but acceptable.
15:52:41 <dbueno> But I'm wondering if there's a bug or what in the definition.
15:52:56 <lispy> hmm
15:53:02 <dbueno> c_wraith: That _may_ be my problem.  Could you recognise it if you saw it?  I just pasted the code.
15:53:04 <lispy> I'm not familiar with the type classes you're using
15:53:24 <dbueno> lisp: which ones?
15:53:59 <lispy> dbueno: none of your code looks bad to me at a glance
15:54:07 <lispy> dbueno: Well, MonadST.  I've used ST but never seen MonadST
15:54:09 <dbueno> lispy: MonadST I think I wrote.  The idea was to let you lift from an arbitrary monad built on ST into ST itself.
15:54:33 <dbueno> Say if you had a stack of stuff on ST, and you wanted to call readSTRef.  You'd instead call "liftST (readSTRef r)"
15:54:53 <dbueno> instead of "lift . lift . lift $ readSTRef r" if you had stacked three high on top of ST.  Does that make sense?
15:55:08 <lispy> yes it makes sense
15:55:15 <c_wraith> dbueno, doesn't look like it's the match/construct overuse issue.  In fact, it looks like you're explicitly CPSing around that.
15:55:19 <lispy> IIRC, monadLib has a liftBase for this sort of thing
15:55:25 <dbueno> The other thing is I was using continuation-passing style to avoid what c_wraith was talking about.
15:55:33 <dbueno> lispy: I'll have to take a look at monadLib
15:56:21 <lispy> dbueno: okay, but I don't want to imply monadLib will improve your situation.  It will, with all likelihood, give you a pessimization
15:56:36 <dbueno> lispy: heh, thanks, I'll make sure it actually improves things
15:56:49 <dbueno> I feel like I might be doing something really dumb... but I don't see it.
15:57:10 <lispy> dbueno: you might want to start using criterion/progression for the changes to ensure that it's getting faster in a statistically robust sense
15:57:10 <Peaker> It's a bit sad that monad transformers have a performance penalty.. it doesn't feel like they really should
15:57:36 <zygoloid> Peaker: this sounds like a job for a supercompiler :)
15:57:38 <lispy> dbueno: you might check the space usage.  make sure you don't have any crazy garbage collection eating up the time
15:58:22 <dbueno> I just pasted an amendment: the profile from running the code is here: http://haskell.pastebin.com/rb5ABVms
15:58:38 <dbueno> lispy: good idea.  One moment.
15:59:53 <Peaker> zygoloid, I'm not sure what "supercompiler" means.. cross-module optimizations?
15:59:55 <ezyang> What's the easiest way to read a file, do something to it, and then write it back out to the same file? 
16:00:07 <ezyang> I think that lazy IO makes this a little tricky. 
16:00:11 <ddarius> @google supercompilation turchin
16:00:12 <lambdabot> http://en.wikipedia.org/wiki/Valentin_Turchin
16:00:12 <lambdabot> Title: Valentin Turchin - Wikipedia, the free encyclopedia
16:00:41 <Peaker> ezyang, You want it fully copied into memory first, or via some other file, or written in parallel to reading?
16:00:54 <lispy> dbueno: I have a hunch that if you want more performance, you're going to have to look at the core and make sure that the generated code is as unboxed as possible.  It seems ilke that bind function is called a ridiculous amount of time, so any minor tweaks to the performance there should be a huge win
16:00:59 <ezyang> Peaker: As efficiently as possible will do. 
16:01:18 <ezyang> (and it doesn't have to be /that/ efficient, just not silly) 
16:01:20 <lispy> ezyang: use the strict package on hackage for a strict readFile.  But if the file is going to be large...hmm
16:01:46 <ezyang> All I'm going to be doing is basically dos2unix comments. 
16:02:00 <lispy> ezyang: in linux, I think  you can actually close the file after the read starts and open it again and stream between the file handles
16:02:07 <dbueno> lispy:  Okay.  Core will be new for me. =]  But you're right, I call that sucker everywhere.
16:02:15 <ezyang> portably, please! 
16:02:20 <dbueno> It's all polymorphic ... is it possible to SPECIALIZE bind?
16:02:22 <lispy> dbueno: cabal install ghc-core
16:02:33 <Peaker> ezyang, then use a strict bytestring read of the file
16:02:35 <lispy> dbueno: I think RULE has replaced SPECIALIZE
16:02:38 <Peaker> @hackage strict
16:02:38 <lambdabot> http://hackage.haskell.org/package/strict
16:02:48 <dbueno> lispy: Oh man ... I haven't looked at this in a while.
16:02:59 <dbueno> I guess I should read the ghc manual to ind out about RULE?
16:03:02 <Peaker> ezyang, http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html
16:03:27 <lispy> oh yeah, bytestring is the real way to go
16:03:37 <lispy> Don't even bother with String :)
16:03:52 <lispy> (that was meant at ezyang)
16:04:28 <ezyang> Hm. This is for a hacky patch for not-my-software, so I kind of want to avoid pulling in more deps. 
16:04:32 <Peaker> ezyang, http://hackage.haskell.org/packages/archive/bytestring/0.9.1.7/doc/html/Data-ByteString.html#v%3AreadFile
16:04:42 <ezyang> (lispy: It's the c2hs thing) 
16:04:44 <Peaker> ezyang, bytestring is already a dep?
16:05:08 <ezyang> Peaker: Unfortunately no. 
16:05:26 <Phyx->  > id
16:05:39 <Phyx-> > id
16:05:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:05:41 <lambdabot>    arising from a use of `...
16:05:55 <Phyx-> o.O
16:06:05 <lispy> ezyang: Well, IIRC the project you're on requires 6.12, and bytestring ships with that version of ghc
16:06:13 <Phyx-> > id :: Int -> Int
16:06:15 <lambdabot>   Overlapping instances for GHC.Show.Show
16:06:15 <lambdabot>                              (GHC.T...
16:06:27 <ezyang> lispy: c2hs? 
16:06:36 <ezyang> I think it works on more version of ghc... 
16:06:52 <lispy> Oh, you're changing it in c2hs.  I would have assumed you'd just changed the c2hs parser :)
16:07:01 <Phyx-> @quote ghc
16:07:01 <lambdabot> ghc says: TELL SIMON: evalAbsence
16:07:10 <Phyx-> huh
16:07:25 <ezyang> ah no. 
16:08:16 * Phyx- wished darcs had transactions, where if patching fails it rolls back
16:08:47 <nominolo_> Phyx-: that's what darcs revert is for
16:09:19 <lispy> Phyx-: what version of darcs are you using?
16:09:22 <Phyx-> nominolo_: and that also nicely blows away my local unrecorded changes :/
16:09:24 <ezyang> ok, I guess I'll do something silly: read the file in and then spew out to another file. 
16:09:26 <lispy> Phyx-: and what repository format (darcs show repo)
16:09:31 <ezyang> in which case I can do it lazily. 
16:09:48 <nominolo_> Phyx-: right, well, git has git stash for that
16:10:13 <Phyx-> lispy: 2.3.1 and darcs-1.0
16:10:20 <lispy> Phyx-: ah.  Here is a workflow you might try.  Before doing a pull, darcs record -am "UNFINISHED: my current state"; darcs pull; darcs unrecord {- now unrecord that unfinished work, or you could leave it and amend it-}
16:10:27 <lispy> Phyx-: hashedPristine?
16:10:52 <Phyx-> lispy: PlainPristine, it's the ghc repo
16:10:52 <dbueno> lispy: Pget the heap profile.  Looks like it might be generating a lot of garbage
16:11:11 <Phyx-> nominolo_: another point for git, heheh
16:11:15 <dbueno> lispy: I mean I _got_ it.  Anyway, I'm trying to get the types of the stuff it's generating.  I'm betting it's functions.
16:11:17 <lispy> Phyx-: oh  yikes.  Yeah, okay.  hashedPristine and darcs2 format have much better transaction support.
16:11:33 <lispy> dbueno: ah, cool
16:11:45 <nominolo_> Phyx-: well, it's the same as what lispy just showed you, but slightly more automated
16:11:57 <dbueno> lispy: also have ghc-core installed.  I'll google for a tutorial
16:12:05 <Phyx-> but yeah, i'll remember what lispy said just now
16:12:14 <Phyx-> everytime i do a pull *something* always breaks
16:12:27 <lispy> darcs stash should really be available.  I'll make a feature request right now
16:12:30 <nominolo_> Phyx-: are you talking about the GHC repo?
16:12:35 <Phyx-> nominolo_: yup
16:12:44 <nominolo_> Phyx-: oh, that's a different beast
16:12:56 <lispy> Phyx-: BTW, just because their repo isn't hashedPristine, doesn't mean that your local branch can't be hashedPristine
16:13:03 <nominolo_> yes, I avoid updating
16:13:26 <Phyx-> lispy: how do i do that? darcs convert?
16:13:35 <nominolo_> Phyx-: only once it's time merging to I update to the latest version.  And I usually have at least 3 separate repos
16:13:47 <nominolo_> Phyx-: don't convert the GHC repo
16:13:49 <Phyx-> nominolo_: well, I update sometimes so that in the end I don't have to fight off alot of changes
16:14:18 <lispy> Phyx-: Well, never darcs should defeault to hashedPristine on a get.  optimize might have an option for it.  2.3.x is old-ish now.  You could try 2.4.4 (stable) or the just released 2.5 beta.
16:14:24 <lispy> s/never/newer/
16:14:40 <Phyx-> ah ok, will update it
16:14:55 <nominolo_> Phyx-: there's also a hashed ghc repo somewhere
16:15:03 <nominolo_> so lazy pull should work as well
16:15:37 <Phyx-> nominolo_: well, I'm just downloading the most recent tar and doing pulls from that
16:15:46 <nominolo_> Phyx-: also, never create conflicting patches in the GHC repo.  unrecord, fix conflicts, then record
16:15:46 <Phyx-> i accidently stopped a pull twice this week
16:15:52 <Phyx-> and I think that introduced bugs in the compiler
16:15:59 <Phyx-> and it wouldn't continue the pulls either so
16:16:22 <Peaker> Maybe they should switch to git
16:16:36 <nominolo_> well, it explicitly says that you can press Ctrl-C.  if it doesn't say that, then it doesn't support it.
16:16:44 <nominolo_> Peaker: it's the ghc repo
16:17:08 <Phyx-> nominolo_: well, the largest thing I changed, and this is the only conflict I get on pulls, is in the DriverPipeline to support using an in-memory buffer instead of files only
16:17:32 <Peaker> nominolo_, If you press Ctrl+C on darcs it can screw things up?
16:17:34 <Phyx-> the other changes rarely give me conflicts
16:17:52 <nominolo_> Peaker: it might on old repos
16:18:16 <Phyx-> Peaker: what it was doing here was it half applied patches. but somewhere it thinks it applied them all
16:18:18 <nominolo_> Peaker: there's going to be a huge merge in the typechecker soonish
16:18:18 <Peaker> nominolo_, Why don't the ghc guys upgrade their darcs repos?
16:18:42 <lispy> Phyx-: prior to the hashedPristine format you could have some non-atomic updates.  Not a problem with modern darcs on hashedPristine though
16:18:46 <Peaker> nominolo_, and after that they'll do it?
16:18:48 <Phyx-> nominolo_: oh.. that's gonna be a nightmare...
16:19:10 <nominolo_> Peaker: not sure.  I think darcs2 was slower in some cases a while ago.  and there're lots of in-progress repos lying around.
16:19:20 <Peaker> nominolo_, is it a big deal to switch ghc to git?  It's nice to use a dvcs written in Haskell, but I do think git is a better fit for a large project as ghc
16:19:24 <lispy> Peaker: we've been working with the ghc guys to get everything fixed so they can convert but it's a slow process and they want to move cautiously
16:19:25 <nominolo_> Peaker: so it would have to be done during some release at least.
16:19:41 <Phyx-> lispy: cool, is there any reason why they don't upgrade the ghc repo?
16:19:52 <Phyx-> ah, nominolo_ is explaining
16:19:58 <lispy> Peaker: SimonM uses windows a lot, and git has worse support for windows than darcs, IIRC
16:20:04 <nominolo_> Peaker: there are several repos.  and the git workflow isn't necessarily easier.
16:20:17 <lispy> And darcs performance has really been catching up
16:20:23 <nominolo_> Peaker: so in the end you would need darsc *and* git
16:20:26 <Peaker> lispy, I think that's very old news
16:20:33 <Peaker> lispy, afaik there's no real problem with git on Windows.. Maybe "git clone" is slightly less efficient (no hardlinks?). What does darcs do to share history on Windows?
16:20:43 <Peaker> nominolo_, during a transition phase, sure
16:20:48 <lispy> windows has hardlinks, BTW
16:20:57 <Phyx-> Peaker: NTFS has hardlinks
16:20:58 <Peaker> lispy, does darcs use them?
16:21:13 <nominolo_> Peaker: the libraries and nofib are shared with other projects.  so they would need to switch too
16:21:17 <lispy> I don't hack on darcs on windows or use it there, so I don't know the status
16:21:19 <Peaker> nominolo_, "git" has a horrible CLI/UI, but I think it has a superset of darcs' features/power, and some of the extra power is really handy, esp. for a large project
16:22:05 <nominolo_> Peaker: I know, I'm using it for most of my projects.  But for it to work well, you need to follow certain workflows
16:22:36 <Peaker> nominolo_, That's probably true with darcs too?
16:22:50 * Phyx- wonders about the haskell wiki...
16:22:51 <nominolo_> Peaker: sure, but the main developers already know it.
16:22:56 <Phyx-> it says to do "sh boot"
16:23:00 <Phyx-> but that never works for me
16:23:10 <nominolo_> Phyx-: it's perl boot, now
16:23:13 <Phyx-> while chmod +x boot; ./boot does
16:23:26 <nominolo_> I think
16:23:43 <Phyx-> think it is
16:23:48 <nominolo_> Phyx-: you mean the GHC, wiki, no?
16:23:50 <Phyx-> that wiki page needs an update
16:23:53 <Phyx-> nominolo_: yup
16:23:58 <nominolo_> which page?
16:24:04 <Phyx-> let me see
16:24:04 <dbueno> lispy: I moved the monad declaration to a place where I could specialise it to common types ... no improvement.
16:24:09 <lispy> Phyx-: http://bugs.darcs.net/issue1891
16:24:27 <lispy> dbueno: you should ask dons for help :)
16:24:34 <lispy> dbueno: I feel out of my league
16:24:46 <Phyx-> lispy: hehe, did you just create that?
16:24:51 <lispy> Phyx-: yeah
16:25:01 <lispy> Phyx-: this is how open source software gets better :)
16:25:30 <Phyx-> lispy: I thought it gets better when someone *eventually* closes one of ticket :P
16:25:35 <dbueno> lispy: Yeah ... I approeciate your help, so I was giving an update.  I'll try to isolate the type of garbage I'm generating to see if that leads anywhere
16:25:59 <lispy> dbueno: ah yeah.  IIRC, add -hy when you compile for profiling
16:26:19 <lispy> Phyx-: hehe.  One step at a time
16:26:36 <dbueno> lispy: I did -hy -hcbindSSTErrMonad which appears to group by type and also restrict it to that one fnction.
16:26:43 <dbueno> By far the offender is [] -- lists
16:26:43 <Phyx-> nominolo_: oh, my bad, it seems the page *has* been updated since the last time I saw it
16:26:49 <lispy> dbueno: ah, good idea
16:27:02 <nominolo_> Phyx-: yes, it was a recent change
16:27:07 <dbueno> lispy: since that function does not touch lists it must be the callers fault.
16:28:20 <Phyx-> nominolo_: One thing i have noticed, and this is not really a build thing, but haskell programs tend to hang in msys, cauzing the build to hang. like I can't leave it unattended
16:28:25 <Phyx-> usually configure hangs
16:29:20 <Phyx-> I need to try and find out why... but it's only haskell programs and only when they're repeatedly invoked like in build scripts, so it's most likely msys
16:29:34 <nominolo_> Phyx-: hm.  I know at MSR that we had special combinations of msys + autotools + whatever.   in particular, some newer versions did not work.
16:30:36 <Phyx-> nominolo_: fortunately mine isn't that bad, It does work, once it passes the phase where it has to configure it's fine
16:30:51 <Phyx-> though building documentation also hangs, but i never build that anymore
16:30:54 <nominolo_> Phyx-: there are some locking problems on Windows.  e.g., if you close a file and then delete it, it might fail because teh file is still locked.  this might be because the virus scanner is scanning it.
16:31:25 <dbueno> lispy and cmwraith: thanks for your help.  I'm off now.
16:32:03 <Phyx-> nominolo_: I have no virus scanner, but I have done some light poking around, and actually the hung programs are basically done, they just never exit cleanly so everything gets stuck. As far as i can tell there were no threads doing anything or blocked
16:32:31 <nominolo_> Phyx-: ok, this might be a problem with the existing GHC.
16:32:39 <nominolo_> i don't know if it's a known issue.
16:32:59 <nominolo_> Phyx-: you should ask on the cvs-ghc list
16:34:18 <Phyx-> nominolo_: ah, ok, will do :)
16:34:21 <jbapple> I have something of type (ST s (STRef s (Bool,STUArray s Int Float))), and I want to runST it and get out a (Bool, UArray Int Float), but I'm having a bit of trouble
16:34:29 <Phyx-> I'll try to scrape up some more information aswell that might be useful
16:34:43 <jbapple> Did I write a foolish type?
16:35:11 <nominolo_> jbapple: you have to freeze the array
16:35:45 <stralep> Is there a function to detect a cycle in digraph in data.graph.inductive?
16:35:54 <nominolo_> jbapple: because the array must not be modified after you leave the ST monad
16:36:06 <stralep> I was unable to find it...
16:36:21 <nominolo_> jbapple: i.e., you can only return a UArray Int Float
16:36:28 <jbapple> nominolo_: thanks for the tip. I was trying to use runSTUArray
16:37:04 <jbapple> nominolo_: But I couldn't get my types to match appropriately. I'll try freeze
16:37:33 <nominolo_> jbapple: well, runSTUArray does just that for you.
16:37:45 <nominolo_> jbapple: the point is you can't return the STArray
16:37:56 <nominolo_> by design
16:38:26 <jbapple> right, but if you look at my original question, I don't want to return the STArray, I want a (Bool, UArray Int Float)
16:38:57 <jbapple> nominolo_: my problem is that I can only seem to get one half of the pair out at a time
16:39:13 <nominolo_> jbapple: right.  The implementation of runSTUArray is very simple, so you can adapt it to your use case
16:39:37 <jbapple> and I'm concerned that calling runST and join on the same ref twice to get out both halves of the pair will run my computation twice
16:39:50 <jbapple> nominolo_: What do you mean by "adapt" in this case?
16:41:38 <c_wraith> he means "look at the source, and write something similar"
16:41:58 <nominolo_> :t \st -> runST (do (b, arr) <- st; let uarr = unsafeFreezeSTArray arr; uarr `seq` return (b, uarr))
16:41:59 <lambdabot> parse error on input `)'
16:42:37 <nominolo_> what c_wraith said
16:42:37 <c_wraith> you need {} around the let body inside the do block
16:42:43 <nominolo_> d'oh
16:42:45 <jbapple> Ok, well I guess I should ask a tougher question then: can I do this without writing my own array library or using "unsafe" operations?
16:43:15 <nominolo_> jbapple: not without copying
16:43:33 <jbapple> copying what? bytes? code?
16:43:41 <nominolo_> jbapple: the array
16:44:02 <jbapple> Oh, I don't mind copying
16:44:06 <nominolo_> jbapple: well, you could use a monad transformer or so, but that feels overkill
16:44:28 <jbapple> (the array I don't mind copying, but I don't want to redo the computations that led to the array)
16:44:41 <nominolo_> oh, I see you're using an STRef, so you'll hae to read from that again
16:44:53 <jbapple> What do you mean again?
16:45:26 <nominolo_> jbapple: then take a look at http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-MArray.html#v%3Afreeze
16:46:01 <nominolo_> jbapple: the unsafe is there because you have to be sure no-one else has a reference to that array.
16:46:32 <jbapple> ok, I'm going to try freeze
16:49:13 <jbapple> So, once I freeze, I seem to lose the polymorphism I need for runST
16:49:33 <jbapple> Is not losing it just a matter of making sure I have the right type signatures?
16:50:05 <nominolo_> jbapple: no, once you leave runST the error cannot be mutable anymore -- that's the whole point
16:50:46 <jbapple> I don't know what "the error cannot be mutable anymore"
16:50:50 <jbapple> means
16:50:52 <nominolo_> jbapple: if you want it to remain mutable, you have to use an IOArray.   but then you don't need ST, really
16:51:02 <jbapple> Also, the problem is I'm losing polymorphism BEFORE I call runST
16:51:04 <nominolo_> well, STUArray allows inplace updates
16:51:20 <jbapple> wait, did "error" mean "Array"?
16:51:38 <nominolo_> oh, er, yes
16:52:16 <nominolo_> it's not even a homophone...
16:52:25 <jbapple> Ok, by annotating my functions and using freeze, I got mostly what I wanted
16:52:45 <ddarius> Perhaps see processArray on this page (it may not quite work now because it is old and people have fiddled with it): http://haskell.org/haskellwiki/Introduction/Direct_Translation
16:52:46 <jbapple> Thanks for the help, nominolo_
16:56:47 <om-foxy> given that polyvariadic printf can be implemented, I should be able to implement (in a CC monad) an action that takes a enum and then different arguments based on the value of the enum, should I not?  Can anyone give me a few pointers as to where to start?  e.g.    foo Line :: (Int,Int) -> (Int,Int) -> m (), foo Point :: (Int,Int) -> m().
16:57:18 <soupdragon> om-foxy,
16:57:28 <om-foxy> yes.....
16:58:32 <ddarius> om-foxy: Unless Point and Line are different types, no you can't do that.
16:59:36 <om-foxy> http://www.google.com/url?sa=t&source=web&cd=4&ved=0CCcQFjAD&url=http%3A%2F%2Fpllab.is.ocha.ac.jp%2F~asai%2Fpapers%2Ftr08-2.pdf&ei=qv08TLH9I8jXceO-gdQC&usg=AFQjCNHbokU1IpIOXK92l5gKx7MPoKSsVQ&sig2=3QQIQGGSCXNVuzIC8C5Qbw
16:59:47 <om-foxy> @google printf Haskell polyvariadic
16:59:48 <lambdabot> http://okmij.org/ftp/typed-formatting/
16:59:48 <lambdabot> Title: Type-safe Formatted IO
17:00:09 <ClaudiusMaximus> my understanding (which is vague at best) is that it's more that the number of arguments provided determines the type of printf which determines it's behaviour, rather than the argument determining the type ?
17:00:30 <ddarius> ClaudiusMaximus: More or less, yes.  It's "backwards" in a sense to the C version.
17:00:49 <jbapple> nominolo_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27422#a27422
17:00:52 <c_wraith> It uses type inference to decide if you wanted the version that returns a function, or the version that returned a non-function value
17:01:02 <ddarius> om-foxy: You could make a foo that would give an error if it was passed Line at type (Int, Int) -> m (), but you can't make the type depend on the passed in value.
17:01:13 <ddarius> c_wraith: It's a bit more than that.
17:01:15 <jbapple> I can't get the context into the type to runST properly
17:01:53 <jbapple> If I make t a type that STUArray works on, like Float or Int32, and remove the contexts, it works just find
17:01:54 <jbapple> *fine
17:01:56 <om-foxy> ddarius: but isn't that what polyvariadic printf does?  printf "My nick is %s" "om-foxy"
17:02:11 <ddarius> om-foxy: No.  ClaudiusMaximus said what it does.
17:02:24 <jbapple> But GHC's complaint seems very strange to me
17:02:33 <jbapple> I mean, the context is RIGHT THERE :-)
17:02:37 <nominolo_> jbapple: right, the outer 's' is different from the nested 's'
17:02:41 <ddarius> om-foxy: What that example does is make a printf that verifies that the -format specifier- corresponding to the first argument is %s.
17:02:46 <nominolo_> jbapple: lemme play around with it
17:03:01 <jbapple> nominolo_: thanks
17:03:09 <om-foxy> ddarius, but printf "%s" takes a string and printf "%i" takes an Int
17:03:24 <ddarius> om-foxy: No.
17:03:24 <jbapple> The outer s looks meaningless to me
17:03:29 <ddarius> :t printf "%s"
17:03:30 <lambdabot> forall r. (PrintfType r) => r
17:03:34 <ddarius> :t printf "%i"
17:03:35 <lambdabot> forall r. (PrintfType r) => r
17:03:36 <ddarius> Same type.
17:03:43 <jbapple> Nothing in the result type references s
17:04:19 <om-foxy> ddarius, I'm quite sure it's been done with delimited control monads, I just can't get my head around it at the moment
17:04:25 <ddarius> > printf "%i" "hello" :: String
17:04:26 <lambdabot>   "*Exception: Printf.printf: bad argument
17:04:45 <geheimdienst> > fromString "meow"
17:04:46 <lambdabot>   Not in scope: `fromString'
17:05:17 <ddarius> om-foxy: Those approaches don't use a format -string-.  They use combinators to describe the format specifier.  The combinators are typed.
17:05:31 <om-foxy> ddarius: that'a an implementation using typeclasses, not delimited control
17:06:03 <geheimdienst> hm ... converting a haskell String to an array of utf8 bytes. Data.String.UTF8 from the package utf8-string is the default way to do that, right?
17:06:16 <ddarius> om-foxy: No.  The type class approach uses Strings.  That's what is happening with printf.  The delimited control stuff uses combinators.  It is based on Danvy's "Functional Unparsing"
17:06:38 <om-foxy> delimited control operators can change the answer type, right?
17:07:19 <ddarius> om-foxy: Of the overall continuation passing computation.  They can't magically get types from values.  ML/Haskell are not dependently typed.
17:07:35 <om-foxy> hm...
17:07:42 <lispy> Although, Haskell is "close enough" in many cases
17:08:10 <lispy> the implicit params paper converts arbitrary types to values and back
17:08:13 <ddarius> om-foxy: The stuff you are looking at looks like: format (lit "hello, " % str) "Tim",  not like format "hello, %s" "Tim"
17:08:19 <lispy> Not sure if that's what you mean though
17:08:53 * hackagebot monad-mersenne-random 0.1 - An efficient random generator monad, based on the Mersenne Twister  http://hackage.haskell.org/package/monad-mersenne-random-0.1 (DonaldStewart)
17:09:45 <ddarius> lispy: To the extent that Haskell can occasionally mimick dependent typing it is still a long way from being able to do what would be needed for the equivalent of a dependently typed printf.
17:10:28 <om-foxy> http://www.mail-archive.com/haskell@haskell.org/msg20758.html
17:10:36 <om-foxy> see the end of that post
17:10:41 <ddarius> As a trivial example, there's no way for Haskell to look at the value of "%s" in printf "%s" and know printf "%s" should have the type String -> ... at compile-time.
17:11:01 <om-foxy> stest3 = run $
17:11:03 <ddarius> om-foxy: Which reflects -exactly- what I've been saying.
17:11:03 <om-foxy>           sprintf (ret "The value of " ^ fmt str ^ ret " is " ^ fmt int) 
17:11:05 <om-foxy>             $$ "x" $$ 3
17:11:06 <om-foxy> -- "The value of x is 3"
17:11:14 <ddarius> om-foxy: [19:07] <ddarius> om-foxy: The stuff you are looking at looks like: format (lit "hello, " % str) "Tim",  not like format "hello, %s" "Tim"
17:18:27 <nominolo_> jbapple: ah, so the problem is that the type of runST doesn't allow you to stuff a context in there
17:18:43 <nominolo_> jbapple: but if you fix the type of the array it works.
17:18:56 <nominolo_> jbapple: see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27422#a27424
17:19:09 <jbapple> nominolo_: unfortunately, that won't work for me - I need the array to be polymorphic
17:19:18 <jbapple> I mean, not the array, obviously
17:19:31 <jbapple> I need the function to be polymorphic over any unpacked array
17:19:40 <jbapple> I was thinking about trying to pack the context up
17:19:47 <jbapple> As a context on a data type
17:19:52 <jbapple> or maybe with a GADT
17:20:11 <nominolo_> yes, you may be able to do some tricks with existentials 
17:20:15 <jbapple> or maybe packing runST into a data type, continuation passing style
17:20:20 <jbapple> What a pain in my ass
17:20:29 <nominolo_> yeah.
17:20:47 <nominolo_> Rank[2N]Types are that way
17:20:57 <jbapple> I mean, if runST generally doesn't work with classes, what's the point?
17:21:11 <jbapple> You get either state threads OR ad--hoc polymorphism?
17:26:26 <soupdragon> Remember when Usain Bolt smashed the world record!!
17:30:55 <Phyx-> soupdragon: all i remember is 2nd and 3rd place being screwed with afterwards
17:31:11 <soupdragon> Usain Bolt is a TITAN
17:31:58 * monochrom 's ghc-api-fu has increased, can now load and reload modules
17:32:17 <Phyx-> lol
17:32:20 <tensorpudding> you could say he was as fast a bolt of lightning
17:32:27 <Phyx-> monochrom: well done grasshopper
17:33:22 <c_wraith> @quote theomorphisms
17:33:23 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
17:33:23 <lambdabot> object in the category of religions and theomorphisms.
17:33:46 * Phyx- has bought a category theory book, but can't bring himself to read it
17:34:36 <dons> is there a standard approach to indexed monads yet?
17:36:03 <Phyx-> I have no idea... I'm at page 1 :/, I keep coding instead of reading
17:36:40 <Philippa> dons: I don't know about fully standard, but Conor's IFunctor family looked the right thing last I saw
17:37:17 <Philippa> I'm not aware of any others that aren't subsumed by it, but I've not carried out a proper survey
17:38:02 <Peaker> What does indexing add to a functor? Two functors can't be fused..?
17:39:17 <Philippa> http://personal.cis.strath.ac.uk/~conor/pub/SlicingIt/SlicingIt.pdf
17:42:22 <Philippa> dons: I suspect it's a little too SHE-dependent in practice :-(
17:42:38 <dons> Peaker: more types work.
17:46:31 <Philippa> dons: are you looking for something more specific and/or more packaged-and-ready-with-GHC-as-is?
17:46:48 <Philippa> (not bundled with GHC, but... well, bundleable with)
17:49:14 <tolkad> Is wave function collapse caused by lazy evaluation in whatever programming language the universe is written in?
17:49:18 <tolkad> just curious if this is a valid theory
17:50:01 <c_wraith> tolkad, If so, we have no clue what physical mechanism plays the part of the RTS in executing IO..
17:50:27 <Philippa> tolkad: AIUI the whole copenhagen interpretation is... distinctly dodgy ground
17:51:06 <Philippa> (notice how they've still not got an entire cat into a superposition state? :p)
17:53:01 <soupdragon> -_-
17:53:28 <etpace> hmm
17:54:19 <etpace> if I have a huge list, and I do something like do state <- get; put state { hugelist = tail (hugelist state) }
17:54:25 <etpace> is there any reason for this to blow up my memory?
17:54:44 <etpace> it shouldnt strictly evalaute the list or anything right?
17:55:22 <aavogt> no it won't
17:55:33 <etpace> this is extremely queer then
17:55:54 <tolkad> :t (x:)
17:55:55 <lambdabot> [Expr] -> [Expr]
17:55:58 <tolkad> 0_o
17:56:07 <tolkad> what exactly does that do?
17:56:10 <aavogt> etpace: perhaps it's being forced somewhere else (and still has references somewhere so it can't be garbage collected)
17:56:16 <aavogt> > (x:) [y]
17:56:17 <lambdabot>   [x,y]
17:56:29 <tolkad> ah, now it makes perfect sense
17:56:45 <sproingie> is this Expr business a new \bot feature
17:56:47 <sproingie> ?
17:56:50 <Phyx-> those are still actually really confusing
17:56:51 <etpace> its being really weird, going through the file returning something is fine, going through not returning blows up
17:57:00 <Phyx-> sproingie: it imports them from somewhere
17:57:02 <etpace> folding through this infinite list is fine, tailing a few times and then folding blows up
17:57:06 <Phyx-> > dataTypeOf x
17:57:08 <lambdabot>   DataType {tycon = "SimpleReflect.Expr", datarep = AlgRep [Expr]}
17:57:16 <aavogt> sproingie: not particularly new
17:57:23 <aavogt> @hackage simple-reflect
17:57:23 <lambdabot> http://hackage.haskell.org/package/simple-reflect
17:57:25 <tolkad> > (:[y..]) x
17:57:26 <lambdabot>   [x*Exception: not a number
17:57:33 <tolkad> > (:[1..]) 0
17:57:33 <om-foxy> ddarius: thanks, I think that stuff only works from the command line anyway.
17:57:34 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:58:12 <tolkad> :t curry curry curry curry curry curry curry curry curry
17:58:13 <lambdabot>     Couldn't match expected type `(a, b)'
17:58:13 <lambdabot>            against inferred type `(a1, b1) -> c'
17:58:13 <lambdabot>     In the first argument of `curry', namely `curry'
17:58:32 <sproingie> :t badger badger badger badger badger
17:58:33 <hpc> :t curry . uncurry
17:58:34 <lambdabot> Not in scope: `badger'
17:58:34 <lambdabot> Not in scope: `badger'
17:58:34 <lambdabot> Not in scope: `badger'
17:58:34 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
17:59:03 <tolkad> :t buffalo buffalo buffalo buffalo buffalo
17:59:05 <lambdabot> Not in scope: `buffalo'
17:59:05 <lambdabot> Not in scope: `buffalo'
17:59:05 <lambdabot> Not in scope: `buffalo'
17:59:10 <Philippa> :t spam
17:59:11 <lambdabot> Not in scope: `spam'
17:59:24 <geheimdienst> :t scope
17:59:26 <lambdabot> Not in scope: `scope'
17:59:39 <Phyx-> > let spam = "Stop doing that!"
17:59:40 <lambdabot>   not an expression: `let spam = "Stop doing that!"'
17:59:47 <Phyx-> @def spam = "Stop doing that!"
17:59:48 <lambdabot> Maybe you meant: bf do let
17:59:53 <Phyx-> uhm.
17:59:57 <tolkad> > bf do let
17:59:59 <lambdabot>   <no location info>: parse error on input `do'
18:00:01 <tolkad> wtf?
18:00:07 <Phyx-> @let spam = "Stop doing that!"
18:00:09 <lambdabot>  Defined.
18:00:11 <hpc> @let spam = fix ("spam"++)
18:00:12 <lambdabot>  <local>:2:0:
18:00:12 <Phyx-> :t spam
18:00:12 <lambdabot>      Multiple declarations of `L.spam'
18:00:12 <lambdabot>      Declared at: <local...
18:00:13 <lambdabot> [Char]
18:00:17 <hpc> crap
18:00:20 <Phyx-> lol
18:00:27 <tommd> @undef spam
18:00:32 <Phyx-> one would think it replaces them
18:00:32 <aavogt> > cycle "spam"
18:00:33 <lambdabot>   "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamsp...
18:00:42 <dons> Philippa: i need, basically, Unboxed a => Monad (State a)
18:00:44 <hpc> @let spam = cycle "spam"
18:00:45 <lambdabot>  Defined.
18:00:51 <Phyx-> tommd: afaik @undef always undefined everything
18:00:53 <tolkad> @undef cycle
18:00:54 <dons> where Unboxed provides the constructors for    the type
18:01:02 <tolkad> @def cycle "lol"
18:01:03 <lambdabot> Maybe you meant: bf do let
18:01:11 <tolkad> @let cycle = "lol"
18:01:12 <lambdabot>  Defined.
18:01:30 <tolkad> :t cycle
18:01:31 <lambdabot>     Ambiguous occurrence `cycle'
18:01:31 <lambdabot>     It could refer to either `L.cycle', defined at <local>:1:0
18:01:32 <lambdabot>                           or `Data.List.cycle', imported from Data.List at State/L.hs:35:0-33
18:01:40 <sproingie> haha
18:01:46 <Philippa> dons: ah. I'm not aware of a standard way to do constrained monads yet, but I'm a bit out of the loop to be fair
18:01:46 <Phyx-> fail
18:01:48 <Phyx-> :P
18:01:52 <sproingie> @undef cycle
18:02:10 <Phyx-> @let a = 1
18:02:12 <lambdabot>  Defined.
18:02:14 <Phyx-> @let b = 1
18:02:15 <lambdabot>  Defined.
18:02:18 <Phyx-> @undef a
18:02:23 <sproingie> it really should give feedback on @undef
18:02:25 <Phyx-> :t b
18:02:25 <tommd> > b
18:02:26 <lambdabot>   b
18:02:26 <lambdabot> Expr
18:02:29 <Phyx-> see
18:02:34 <Phyx-> undef just removed everything
18:02:44 <Phyx-> removes*
18:02:52 <sproingie> then it should definitely give feedback
18:03:09 <Phyx-> i9k99i998jilkuoujkloiupiu8opioujopjkl
18:03:09 <wolf1oo> has anyone here worked with the System.USB module? I'm having some difficulties with the while read/write process...
18:03:19 <Phyx-> sorry cleaning keyboard
18:04:20 * sproingie cleans his keyboard, types in the nine billionth name of God, and ends the world.
18:05:02 <sproingie> i hate it when i do that
18:06:29 <Phyx-> you know
18:06:37 <Phyx-> i think this profiler might be on  crack
18:06:56 <Phyx-> i can't possibly have used 16,783,273,2208 Tbytes of memory
18:08:10 <wli> Accounting bug, counter went negative.
18:09:04 <tolkad> > cycle "5"
18:09:05 <lambdabot>   "55555555555555555555555555555555555555555555555555555555555555555555555555...
18:09:08 <Phyx-> wli: oh an I love the last line "division by zero error"
18:09:11 <Phyx-> and*
18:09:20 <etpace> Parser is just a type for the statemonad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27425#a27425 <- I have no idea how to explain this: calling uniqueRics with allHeaders on a lazy reading of a file makes my memory blow up quite promptly, removing allHeaders lets it run fine: when tracing bool, allHeaders is only called three times, so it only actually inspects two lines -- what in allHeaders is causing the program to keep the read data abou
18:10:26 <Philippa> etpace: traditionally parsing monads provide backtracking as well as a stateful wrapper around the input
18:10:53 <etpace> I don't need the backtracking element for this, and parsec was way too slow
18:11:48 <Philippa> what happens if you use a strict state monad?
18:12:11 <etpace> i'm not sure, how deep does it strictly evaluate?
18:12:36 <etpace> if it deepseqs so unseen will be evaluated, then itll blow up
18:13:01 <Philippa> it doesn't deepseq
18:13:17 <etpace> ill try a strict runthrough now
18:13:58 <etpace> blows up like before
18:15:46 <Philippa> I'm afraid I'm too tired to go through all the code. You'll find it helps if you wrap more of the boxing/unboxing in slightly higher-level terms
18:16:03 <etpace> i can't explain why, its keeping old values of unseen about
18:16:34 <etpace> what do you mean by the boxing/unboxing?
18:19:15 <Philippa> all the manipulation of your state record
18:20:26 <tolkad> I still don't think it's possible to implement the sieve of eratosthenes to create an infinite list of primes without using IO
18:20:28 <etpace> isn't that reduced at compilation
18:21:12 <tolkad> > sum [1..10]
18:21:13 <lambdabot>   Ambiguous occurrence `sum'
18:21:13 <lambdabot>  It could refer to either `L.sum', defined at <l...
18:21:32 <tolkad> > even 4
18:21:33 <lambdabot>   Ambiguous occurrence `even'
18:21:34 <lambdabot>  It could refer to either `L.even', defined at ...
18:21:38 <Philippa> I'm not telling you to do it for the compiler's sake or the runtime's
18:21:45 <tolkad> > filter odd [1]
18:21:47 <lambdabot>   Ambiguous occurrence `filter'
18:21:47 <lambdabot>  It could refer to either `L.filter', defined...
18:21:56 <tolkad> 0_o
18:22:30 <sshc> @undefine
18:22:37 <sshc> > even 4
18:22:38 <lambdabot>   True
18:23:44 <Philippa> not giving us the type of unseen isn't really helpful either, but hey
18:23:48 <tolkad> aww you can undefine them all at once? : (
18:23:55 <tolkad> I thought that was pretty cool
18:24:06 <etpace> sorry, it's a large file, I thought I got everything
18:24:13 <etpace> these are just the problem functions :p
18:24:35 <tolkad> :t sqrt . sqrt . sqrt
18:24:37 <lambdabot> forall a. (Floating a) => a -> a
18:24:58 <etpace> i've added the datatype of ps now Philippa 
18:24:58 <tolkad> :t . . .
18:24:59 <lambdabot> parse error on input `.'
18:25:14 <tolkad> :t (.) . (.) . (.) . (.) . (.)
18:25:15 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) a b (f4 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4) => (a -> b) -> f (f1 (f2 (f3 (f4 a)))) -> f (f1 (f2 (
18:25:15 <lambdabot> f3 (f4 b))))
18:25:31 <EvanR> you just broke the universe
18:25:34 <Philippa> etpace: so what's that double list representing?
18:25:56 <etpace> it's a CSV file, list of lines which are a list of fields
19:02:00 <Zao> "My brain just exploded."
19:03:00 <Pseudonym> What happened to lambdacats>?
19:03:58 <Zao> Down since a year or so.
19:04:39 * geheimdienst will never stop agreeing how tragic that is
19:04:55 <Phyx-> i'm sure someone has an archive
19:05:12 <EvanR> :t id
19:05:13 <lambdabot> forall a. a -> a
19:05:14 <Pseudonym> http://andrew.bromage.org/pictures/explodid.jpeg
19:05:18 <EvanR> :t const
19:05:19 <lambdabot> forall a b. a -> b -> a
19:05:54 <Wolfspaw> Could someone take a quick look on my doubt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27428#a27428 . And tell me why the first version works, but the second doesnt? ; - ;
19:06:35 <Veinor> :t map (\z->fst.random $ z) . map fst $ x
19:06:36 <lambdabot>     Couldn't match expected type `[(a, b)]'
19:06:36 <lambdabot>            against inferred type `Expr'
19:06:36 <lambdabot>     In the second argument of `($)', namely `x'
19:06:45 <EvanR> :t id . id
19:06:46 <lambdabot> forall a. a -> a
19:06:51 <Veinor> :t map (\z->fst.random $ z) . map fst 
19:06:52 <lambdabot> forall a a1 b. (Random a, RandomGen a1) => [(a1, b)] -> [a]
19:07:11 <koninkje> I'm getting a ""Parse error in pattern"" error for using [n,n-1..1] in monadic code... any idea why that would happen?
19:07:15 <Veinor> :t map (\z->snd.random $ z) . map snd
19:07:16 <lambdabot>     Ambiguous type variable `a' in the constraint:
19:07:16 <lambdabot>       `Random a' arising from a use of `random' at <interactive>:1:13-18
19:07:16 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
19:07:22 <Veinor> >:(
19:07:52 <EvanR> :t flip const
19:07:53 <lambdabot> forall b a. a -> b -> b
19:07:57 <aavogt> koninkje: [n, n-1, .. ] is not a pattern
19:08:06 <EvanR> is there another name or way to express flip const
19:08:08 <koninkje> aavogt: yes, I know :(
19:08:09 <aavogt> err what you wrote
19:08:24 <Veinor> Wolfspaw: you only need to change the second fst to snd
19:08:25 <aavogt> you want it to be a pattern?
19:08:44 <Cale> EvanR: \x y -> y
19:08:51 <Wolfspaw> Veinor: ah! Thanks a lot! You're right, that was driving me crazy >)
19:08:56 <koninkje> aavogt: but that's what's at the row#/col# for the error
19:09:08 <koninkje> aavogt: there are no actual patterns anywhere near there...
19:09:12 <aavogt> koninkje: what's the code?
19:09:21 <EvanR> Cale: seems like im missing something basic, isnt there a simpler way?
19:09:33 <koninkje> an HMM I'm working on...
19:09:34 <Veinor> Wolfspaw: also you can combine the maps
19:09:47 <Veinor> into map (fst . random . snd)
19:10:12 <koninkje> aavogt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27429#a27429
19:10:33 <EvanR> Cale: why does const have a name and that function doesnt
19:10:48 <koninkje> aavogt: it's a translation of some Perl code, so it's ugly as all sin right now. But the error just doesn't make any sense
19:11:13 <aavogt> > [3,3-1 .. 1]
19:11:14 <lambdabot>   [3,2,1]
19:11:15 <Veinor> so, randomNumberList = map (fst . random . snd)
19:11:18 <aavogt> > [3,3-1..1]
19:11:19 <lambdabot>   [3,2,1]
19:11:27 <geheimdienst> how would i convert (cast) a [CInt] to [Word8]?
19:11:29 <Wolfspaw> Veinor: wow, great! It's a lot better combining the maps! *_*
19:11:36 <Veinor> yeah.
19:11:38 <koninkje> aavogt: line 180
19:12:10 <koninkje> I didn't know if this is some bizarre regression in 6.12 or what
19:12:43 <aavogt> I'm confused too
19:13:11 <koninkje> hmm
19:13:18 <Cale> EvanR: there's also const id
19:13:37 <EvanR> > const id
19:13:38 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a -> a)
19:13:38 <lambdabot>    arising from a use...
19:13:42 <EvanR> :t const id
19:13:44 <lambdabot> forall a b. b -> a -> a
19:13:47 <EvanR> hah!
19:13:49 <EvanR> i knew it
19:14:39 <aavogt> koninkje: you're missing a do?
19:14:51 <aavogt> in the same line after the ->
19:15:34 <aavogt> at that point it parses for me, but some names aren't defined
19:16:14 <koninkje> aavogt: yeah, I just found that
19:16:29 <koninkje> bloody hell that was an unhelpful errmessage
19:16:42 <aavogt> agreed
19:17:04 <koninkje> yeah, it doesn't/shouldn't run just yet; I was just testing parsing etc
19:25:46 <etpace> Parser is just a type for the statemonad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27425#a27425 <- I have no idea how to explain this: calling uniqueRics with allHeaders on a lazy reading of a file makes my memory blow up quite promptly, removing allHeaders lets it run fine: when tracing bool, allHeaders is only called three times, so it only actually inspects two lines -- what in allHeaders is causing the program to keep the read data abou
19:32:52 <ClaudiusMaximus> etpace: maybe if you posted a complete runnable example it would help
19:33:12 <ClaudiusMaximus> etpace: oops, i didn't scroll down
19:34:44 * hackagebot snap-core 0.2.8.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.8.1 (GregoryCollins)
19:35:48 <EvanR> i need to try snap
19:36:45 * hackagebot snap-server 0.2.8.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.8.1 (GregoryCollins)
19:37:00 <Raynes> EvanR: It's a snap!
19:37:08 <etpace> I think it's got everything there ClaudiusMaximus, tell me if i forgot anything
19:39:29 <ClaudiusMaximus> etpace: "<$> elemIndex foldl' get headerNames put trace Columns Instrument Parser" are missing after i added 2 obvious imports
19:44:47 <ClaudiusMaximus> :t span
19:44:48 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:46:03 * ddarius should learn sheaf theory comprehensively.
19:48:54 <ClaudiusMaximus> :t let isHeader :: [String] -> Bool in span isHeader . map words . lines
19:48:55 <lambdabot>     The type signature for `isHeader' lacks an accompanying binding
19:48:55 <lambdabot> Not in scope: `isHeader'
19:49:16 <ClaudiusMaximus> :t let { isHeader :: [String] -> Bool ; isHeader = undefined } in span isHeader . map words . lines
19:49:17 <lambdabot> String -> ([[String]], [[String]])
19:49:31 <lispy> ddarius: someone I was talking to recently was playing with the idea of using sheafs to deal with conflicts in vcs
19:56:21 <Amagineer> what would be the proper way to do getArgs >>= return $ map read ?
19:57:15 <aavogt> use .
19:57:21 <Amagineer> Ah, thanks
20:04:10 <monochrom> @hoogle unsafePerformIO
20:04:10 <lambdabot> Foreign unsafePerformIO :: IO a -> a
20:04:11 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
20:46:24 <etpace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27425#a27434 is the updated ClaudiusMaximus, can just type Instrument = String or something, its not used in the code, after profiling i still have no idea whats causing the space leak
20:58:40 <mtnviewmark> I'm wondering - is Gregory Collins around? or any of the snap framework folks?
21:06:53 <etpace> I think next is the problem but ive got no idea when i should be strict
21:19:25 <ezyang> Is the best commuting diagram for functors a square or two squares? 
21:20:02 <Cale> ezyang: best?
21:20:36 <ezyang> Cale: As in, covering all of the important points but not having extra unnecessary points. 
21:21:36 <Cale> etpace: A good rule of thumb is that you want strictness when you're taking a large number of separately evaluatable bits of data and summarising them (as opposed to searching through them) into a single piece of data (whose value can't be known without all or most of the inputs)
21:22:22 <etpace> well
21:22:25 <drbean> I need to read or do some 'lifting' material. I have only a vague understanding of what it is, and I'm trying to read http://www.computational-semantics.eu/ on how to lift extensional functions.
21:22:54 <etpace> I think something as simple as: f = do state <- get; put state { rec = tail (rec state) } is causing a spaceleak
21:23:04 <etpace> do you think thats reasonable?
21:23:18 <etpace> (if rec state was a very large list read in lazily)
21:23:49 <Cale> drbean: 'lifting' means different things in different contexts. Generally it means taking something and adding structure to it to make it work in another environment which is considered larger or more general.
21:24:46 <Cale> etpace: Well, if you're doing that over and over again, then maybe. Out of interest, are you compiling with -O2?
21:25:09 <etpace> I am doing it over and over, a very large number of times, and yes
21:25:37 <Cale> okay, so probably what's happening is that an expression is building up in your state which applies tail again and again to the initial state
21:25:54 <etpace> aha
21:25:56 <etpace> so seq the tail?
21:26:29 <Cale> If you never actually examine the value at any point, then that'll happen. Well, yes, you could do that...
21:26:55 <Cale> let (_:rec') = rec state
21:27:12 <ezyang> Hmm, I guess it's not possible to write a natural transformation from a contravariant functor to a covariant functor. 
21:27:14 <Cale> rec' `seq` put state { rec = rec' }
21:27:28 <Cale> Or even...
21:27:33 <Cale> case rec state of
21:27:38 <Cale>   [] -> ... error? ...
21:27:53 <Cale>   (x:rec') -> put state { rec = rec' }
21:29:02 <Cale> case expressions are another way to force evaluation to occur
21:29:45 <etpace> hmm, still leaking
21:30:34 <etpace> It's really bizzare, sec ill post the condensed paste
21:32:28 <etpace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27436#a27436
21:32:33 <Cale> > let foo xs = foldl' (\acc (_:y:_) -> if y `elem` acc then acc else (y:acc)) [] xs in foo "aaabbcbccabc"
21:32:33 <etpace> in the function uniqueRics
21:32:34 <lambdabot>   Couldn't match expected type `[t]'
21:32:34 <lambdabot>         against inferred type `GHC.Types...
21:32:41 <etpace> calling allheaders causes a spaceleak
21:32:48 <etpace> but if i leave allHeaders and then change it to
21:32:51 <etpace> return []
21:32:53 <ddarius> ezyang: Sure you can.
21:32:56 <etpace> theres no space leak
21:33:07 <etpace> so its from calling allHeaders and THEN transversing the list it breaks
21:33:13 <Cale> :t foo xs = foldl' (\acc (_:y:_) -> if y `elem` acc then acc else (y:acc)) [] xs in foo
21:33:13 <lambdabot> parse error on input `='
21:33:16 <etpace>  > let foo xs = foldl' (\acc (_:y:_) -> if y `elem` acc then acc 
21:33:16 <Cale> :t let foo xs = foldl' (\acc (_:y:_) -> if y `elem` acc then acc else (y:acc)) [] xs in foo
21:33:17 <lambdabot> forall t. (Eq t) => [[t]] -> [t]
21:33:31 <ddarius> ezyang: Actually, nevermind.
21:33:55 <Cale> > let foo xs = foldl' (\acc (_:y:_) -> if y `elem` acc then acc else (y:acc)) [] xs in foo . words $ "a b a c c a b a c"
21:33:56 <lambdabot>   "*Exception: <interactive>:1:154-206: Non-exhaustive patterns in lambda
21:34:00 <Cale> > let foo xs = foldl' (\acc (_:y:_) -> if y `elem` acc then acc else (y:acc)) [] xs in foo . words $ "a b a c c a b a c c"
21:34:01 <lambdabot>   "*Exception: <interactive>:1:154-206: Non-exhaustive patterns in lambda
21:34:04 <Cale> hmm
21:34:25 <ddarius> ezyang: The problem is just basically a type problem, though you could, technically view a covariant functor as a contravariant functor from the opposite category.
21:34:25 <etpace> try it on something like [["a","b","c"],["d","e","f"]]
21:35:00 <Cale> > let foo xs = foldl' (\acc (_:y:_) -> if y `elem` acc then acc else (y:acc)) [] xs in foo . words $ "abc def"
21:35:01 <lambdabot>   "eb"
21:35:07 <ddarius> ezyang: You may want to look at dinatural transformations though.
21:35:46 <Cale> etpace: the dropping of every other element is essential?
21:35:54 <ezyang> ddarius: Is that what would be formed between a covariant/contravariant functor? 
21:36:13 <etpace> it's getting fed a [[ByteString]] which is a CSV file, im just grabbing the value in the second column
21:36:14 <mtnviewmark> it isn't dropping every other element, it is taking only the second element of each list
21:36:20 <etpace> so all unique values in the second column
21:36:23 <Cale> Oh, I see
21:36:36 <mtnviewmark> Data.List.nub
21:36:43 <etpace> stack overflow
21:36:46 <ezyang> hm, not quite. 
21:36:48 <etpace> it's a very large file :P
21:37:07 <Cale> You'd still be better off with  nub . map (!! 1)
21:37:35 <mtnviewmark> let foo = nub . map (\(_:y:_) -> y) in foo . words $ "abc def"
21:37:42 <Cale> The foldl' isn't really helping, since you're accumulating lists anyway
21:37:48 <mtnviewmark> > let foo = nub . map (\(_:y:_) -> y) in foo . words $ "abc def"
21:37:48 <lambdabot>   <no location info>: lexical error at character '\FS'
21:38:02 <Cale> and that just forces evaluation only far enough to determine if the list is empty or not
21:38:14 <alexsuraci> is there a way to only install a cabal package's dependencies?
21:38:14 <etpace> aha
21:38:14 <mtnviewmark> > let foo = nub . map (\(_:y:_) -> y) in foo . words $ "abc def"
21:38:15 <lambdabot>   "be"
21:38:16 <Cale> You might also consider  map head . group . sort . map (!! 1)
21:38:35 <etpace> nub . map seems to do the job
21:39:05 <mtnviewmark> for very long lists, I bet that would be longer than nub
21:39:13 <mtnviewmark> it would depend on the characteristics of your data
21:39:27 <mtnviewmark> if you see many repeated values, then nub will probably be better
21:39:28 <Cale> It's asymptotically faster if you're using the whole list.
21:39:32 <etpace> what I don't understand is why having allHeaders makes the rest then beging to spaceleak
21:39:40 <etpace> allHeaders is retaining something I think
21:39:47 <mtnviewmark> (though I wonder if nub is defined to use a Set, which I'm pretty sure it does)
21:39:58 <Cale> No, it doesn't.
21:40:13 <Cale> :t nub
21:40:13 <lambdabot> forall a. (Eq a) => [a] -> [a]
21:40:19 <Cale> ^^ no way it could 
21:40:31 <mtnviewmark> @src nub
21:40:31 <lambdabot> nub = nubBy (==)
21:40:39 <Quaffe> nub is fast if there are only a few distinct elements I think, otherwise it is n^2
21:40:39 <mtnviewmark> @src nubBy
21:40:39 <lambdabot> nubBy eq []             =  []
21:40:40 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:40:53 <mtnviewmark> indeed
21:41:12 <Cale> > nub [1..]
21:41:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:41:32 <Cale> It works on infinite lists, which map head . group . sort won't.
21:41:55 <Quaffe> I'd never noticed that, handy...
21:41:58 <mtnviewmark> I suppose, if one needed it, and you could accept the Ordered constraint, building a nubViaSet would be very very easy
21:42:33 <etpace> theres too little code here to have a space leak :\
21:43:22 <mtnviewmark> or just    Data.Set.toList . Data.Set.fromList . map (!!1)
21:44:01 <mtnviewmark> > let foo = Data.Set.toList . Data.Set.fromList . map (!!1) in foo . words "abc def"
21:44:02 <nettok> how can i do [999..10] ?
21:44:02 <lambdabot>   Not in scope: `Data.Set.toList'Not in scope: `Data.Set.fromList'
21:44:13 <nettok> > [999..995]
21:44:15 <lambdabot>   []
21:44:30 <mtnviewmark> > [999,998..995]
21:44:31 <lambdabot>   [999,998,997,996,995]
21:44:45 <nettok> gracias
21:49:14 <ddarius> etpace: You need to force the state and likely also the components of the ParserState.  The easiest thing to do is probably to turn the fields into strict fields and use $! at any put.
21:50:26 <ddarius> Quaffe: nub is O(nk) where k is the number of distinct elements to be more precise.
21:52:45 <ketralnis> This is more a statistics question than a haskell question, so feel free to shunt me off if it's off-topic. Is there well-defined way to do kmeans over a big list of very sparse vectors without exploding them out into strict vectors?
21:52:59 <ddarius> (The running time of nub is extremely data dependent.)
21:53:10 <ketralnis> Or better, is there a module that somebody that has already done this work? :) Hackage lists one that requires strict vectors http://hackage.haskell.org/packages/archive/kmeans/0.1.1/doc/html/Data-KMeans.html
21:54:20 <Veinor> can you make nub O(n log k) if you assume an Ord instance?
21:55:43 <tommd> Veinor: Bart had a proposal to add "nubOrd" to base, I think he got agreement on it but he hasn't followed up with a final patch.
21:55:51 <Cale> Veinor: yes
21:56:14 <Veinor> I really wish there was a Set implementation that didn't require Ord
21:56:16 <Veinor> somehow
21:56:24 <tommd> That was a year ago, so if this is important to anyone ("this" being the quality of base) then perhaps someone should take over the proposal.
21:56:42 <Cale> Veinor: There is, it's just slow ;)
21:56:48 <Veinor> :D
21:57:54 <Veinor> that's one of the things that annoys me sometimes about haskell, is that a lot of the prelude-y stuff is written with simplicity and not speed in mind
21:58:32 <tommd> yeah, like powerset... no wait...
21:58:33 <Cale> simplicity is speed
21:58:41 <Cale> In a lot of cases
21:59:57 <alexsuraci> i'd rather have an idiomatic standard lib that betters with the language than a highly optimized one that no one likes to code in :)
22:00:24 <alexsuraci> if that 1-am-speak makes sense
22:03:17 <mtnviewmark> simplicity is a reasonable choice, since choosing between options usually requires knowledge of the problem at hand (c.f. nub implementations)
22:03:50 <mtnviewmark> i.e. there is no universally "fastest" nub implementation that covers all usage cases
22:08:38 <Veinor> my example would be lists, not nub
22:09:22 <blackdog> lists have some nice laziness properties
22:09:52 <c_wraith> lists are loops.
22:12:41 <Zao> Oh joy. GHC 6.10.4 doesn't do TupleSections.
22:14:59 <kniu> so I'm trying to build bytestring-mmap 0.2.1
22:15:14 <kniu> gives me a very strange error.
22:17:50 <kniu> @hpaste
22:17:50 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:18:12 <kniu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=27437
22:18:13 <kniu> yeah
22:18:29 <kniu> dons, you're the author.
22:18:41 <kniu> I have no idea what to do with this assembly.
22:24:27 <Cale> Veinor: Of all possible implementations of sequences, lists are as good as possible at one particular thing: sequential access.
22:24:35 <Veinor> true.
22:25:04 <Veinor> the problem is that that's one of the few things they're good at ;)
22:25:06 <Cale> and yeah, they essentially are our loops
22:25:45 <Cale> Just as a loop either doesn't run at all, or it consists of an iteration followed by another loop, a list is either empty or consists of an element followed by another list :)
22:26:00 <Veinor> true
22:27:23 <Cale> The difference is that writing things in terms of lists is much more composable than with loops, because if you want to do something to the result of each iteration of a loop, you have to put something new inside the loop, whereas with lists, you get to change things externally.
22:27:47 <Cale> (apply another higher order function)
22:29:58 <etpace> would map (+1) . filter odd iterate twice or once?
22:30:10 <Cale> once
22:30:30 <Cale> > map (+1) . filter odd $ [1..]
22:30:31 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
22:30:53 <Cale> ^^ that wouldn't work if it waited until it got to the end of the input before starting to map the function over the results :)
22:32:03 <ketralnis> If I bind string <- getContents and iterate that list twice (e.g. mapM_ putStr [string, string]), is the file read off of disk twice?
22:32:27 <ketralnis> Or in the case of, say, stdin, where it can't be read twice, what happens?
22:32:38 <Zao> It'll do The Right Thing.
22:33:05 <ketralnis> Well that's not very helpful :) Does that mean that it will read my entire infinitely large stdin into memory?
22:33:56 <Veinor> no, because tha'ts silly :)
22:34:15 <Veinor> testing it with stdin, I got interesting behavior
22:34:37 <Veinor> I put in 1 and 2 on separate lines
22:34:39 <Veinor> and got
22:34:51 <Veinor> 1i 1o 2i 2o 1o 2o
22:34:58 <Veinor> where i means 'my input echoed back', o means 'output'
22:35:09 <Zao> Prelude> <stdin>: hLookAhead: invalid argument (Bad file descriptor)
22:35:18 <Zao> Looks like it does amusing things with getContents.
22:35:54 <Veinor> but with regards to a file, I'm not sure
22:36:04 <Zao> Veinor: 1o can't print until 1i is read, and 2o can't print until 2i is read.
22:36:16 <Zao> Then both 1o and 2o can print, as those thunks are already forced.
22:36:19 <Veinor> right.
22:36:49 <Zao> Lazy IO is scary.
22:36:54 <ezyang> Why are coKliesli arrows w a -> b and not a -> w b? 
22:38:01 <ezyang> with composition (cK g) . (cK f) = g . extract . f 
22:38:24 <ezyang> I know that's very boring, but I don't see a theoretical reason why this shouldn't be the case. 
22:39:03 <ezyang> since co- seems to be operating only on the monad. 
22:41:45 <tensorpudding> huh, ghc raised a compile error about a source file lacking a final newline
22:43:45 <tensorpudding> the latest version of agda in cabal seems to be unbuildable due to a missing newline...
22:44:33 <adu> i thought that was supposed to be a warning, why is it erroring?
22:44:37 <kniu> what's the difference between the ghc binary that requires libtinfo and the one that doesn't require it?
22:44:59 <tensorpudding> Maybe GHC has -Werror
22:45:14 <adu> maybe
22:45:25 <adu> tensorpudding: what OS are you on?
22:45:41 <tensorpudding> Unix.
22:45:50 <adu> which unix?
22:45:56 <tensorpudding> BSD.
22:46:04 <tensorpudding> the free one
22:46:10 <adu> FreeBSD?
22:46:16 <tensorpudding> (I don't think that has to do with it)
22:46:47 <adu> i heard that there was a bug with newlines about 50 years ago
22:46:54 <adu> its probably not that
22:47:40 <tensorpudding> it is using -Werror, so the newline warning would be an error
22:50:22 <davekong> Will "foo <- return foo" actually copy foo to foo or is does the compiler somehow know not to?
22:51:03 <ezyang> davekong: It won't copy. 
22:51:09 <ketralnis> At worst it's just copying a pointer, right?
22:51:12 <tensorpudding> by putting the foo there, it'll shadow the old foo
22:51:15 <johnw> that depends on the monad, doesn't it?
22:51:33 <ezyang> foo <- return foo is a no-op in all monads that obey the monad laws. 
22:51:58 <johnw> k
22:52:01 <tensorpudding> it's equivalent to (return foo) >>= (\foo -> ... )
22:52:01 <davekong> sounds good
22:52:35 * ezyang is still kind of confused by coKliesli. 
22:53:49 <soupdragon> hey I need to do something but I dont know what help me find something to do ?
22:54:17 <ketralnis> soupdragon: implement a python->haskell compiler
22:54:52 <tommd> soupdragon: I just started designing (read: writing requirements) a command line gpx parser - want to build it?
22:55:21 <soupdragon> thanks for the sgugestions but there sare both too advanced for me
22:55:24 <Cale> soupdragon: Write a program which finds all partitions of an integer n, where a partition of n is defined as a nondecreasing list of positive integers whose sum is n.
22:55:46 <Cale> (or nonincreasing, if you prefer)
22:55:54 <tommd> soupdragon: Nonsense.  I've build the gps library so you can get simple distance/heading calculations and Tony made a GPX file parser.
22:56:02 * pikhq shall once again sum up the monad laws: "Do notation makes sense as a notation for imperative programs".
22:56:08 <tommd> Oh, and Neil/Bart/others have built great command line parsers.
22:56:38 <Cale> pikhq: The notation of most imperative languages doesn't satisfy the spirit of the associativity law.
22:57:02 * shapr hugs johnw 
22:57:25 <Cale> pikhq: Because of return and break having the funny call/cc'ish control effects that they do.
22:57:36 <pikhq> Cale: Ahright.
22:57:57 <pikhq> Darned control flow screwing up what was otherwise a nice intuitive notion of monad laws.
22:58:02 <tensorpudding> ugh, the dreaded haskell linking hits with a vengeance
22:58:05 <pikhq> :P
22:58:14 <pikhq> tensorpudding: ?
22:58:15 <tommd> tensorpudding: Whats the issue?
22:58:20 <johnw> hey shapr!!
22:58:31 <soupdragon> > let partitions n b | n < b = [[]] ; partitions n b | n >= b = (b : partitions (n - b) b) : partitions n (b + 1) in partitions 20
22:58:33 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:58:51 <shapr> johnw: Hiya! and actually, good night!
22:58:53 <tensorpudding> may it someday be possible that linking a large haskell app will not be ridiculously costly in memory and cycles?
22:59:19 <tommd> tensorpudding: I think you should blame GNU ld, not GHC
22:59:22 <pikhq> Yes, but you'll need to beat GNU into submission first.
22:59:38 <pikhq> This is actually a problem with all large programs that use the system linker.
22:59:44 <tensorpudding> The difference is minimal with gold, I tried that too.
22:59:58 <pikhq> Still the linker.
22:59:59 <tommd> tensorpudding: You can turn off the split-objs option (this came up recently on stackoverflow)
23:00:11 <tensorpudding> Oh damn, the build failed
23:00:15 <pikhq> GHC is literally just passsing objects to ld for that.
23:00:23 <tensorpudding> i didn't apportion enough space in my /tmp
23:00:34 <soupdragon> > let partitions 0 _ = [[]] ; partitions n b | n < b = [] ; partitions n b | n >= b = (map (b :) partitions (n - b) b) : partitions n (b + 1) in partitions 20
23:00:36 <lambdabot>   Couldn't match expected type `[[t]]'
23:00:36 <lambdabot>         against inferred type `t -> t ...
23:00:39 <tensorpudding> is there a way to tell cabal to use a different build directory?
23:00:42 <wli> tmpfs and swap
23:01:04 <tommd> tensorpudding: I think so, but also see Duncans answer on SO (http://stackoverflow.com/questions/3144722/how-can-i-build-cabal-install-on-eeepc-701-ubuntu-netbook-remix-1-6-lucid)
23:01:24 <soupdragon> > let partitions 0 _ = [[]] ; partitions n b | n < b = [] ; partitions n b | n >= b = map (b :) (partitions (n - b) b) ++ partitions n (b + 1) in partitions 5 1
23:01:25 <lambdabot>   [[1,1,1,1,1],[1,1,1,2],[1,1,3],[1,2,2],[1,4],[2,3],[5]]
23:01:28 <tensorpudding> my /tmp is an memory disk, so I can resize it fine
23:01:35 <tensorpudding> it's at 256 meg right now
23:01:55 <tensorpudding> since it's swap-backed i don't want it to be too big though
23:01:59 <tommd> I missed that you ment memory as in disk space - that is rather different.
23:03:07 <tommd> tensorpudding: Have you tried --objdir ?
23:03:24 <tommd> humm, nevermind
23:04:49 <tensorpudding> the performance might have been worsened somewhat by the fact that my build files were being pushed into swap by the boatload
23:05:00 <Phyx-> hmm how does one go about diagnosing a segfaulting ghc? doesn't?
23:06:47 <tommd> Phyx-: Reduce to reasonable example code and submit a ticket to Ian/SimonM.
23:07:52 <Phyx-> tommd: it's a corelib, but I don't know when it'll be fixed so :P and it's one of the last files it compiles :(
23:13:07 <tensorpudding> so dcoutts's post on SO suggests that GHC is going to get shared library support?
23:14:18 <Phyx-> didn't it have some form already for linux?
23:15:57 <AshleyS> Could someone help me to stop thinking iteratively with loops? I can't solve a facebook puzzle in Haskell
23:17:58 <blackdog>  don't ask to ask:)
23:18:06 <blackdog> just ask...
23:19:01 <pikhq> AshleyS: There are no loops. There is only lambda.
23:19:18 <tensorpudding> what kind of loop were you think of?
23:19:31 <pikhq> tensorpudding: GHC *possesses* shared library support as of 6.12. Note, only for *-linux-* systems ATM.
23:19:45 <tensorpudding> meh
23:19:54 <tensorpudding> that's no good for me now!
23:21:04 <AshleyS> tensorpudding: Please look at this puzzle: http://www.facebook.com/careers/puzzles.php#!/careers/puzzles.php?puzzle_id=20. How do you loop through the file's content and process it? The only solution I can think of uses a while loop.
23:21:44 <soupdragon> > replicate 4 1
23:21:45 <lambdabot>   [1,1,1,1]
23:22:59 <pikhq> AshleyS: Why, one simply reads in the file lazily, applies a function to the resulting list, and outputs! (note: do *not* do this for complex programs. Perfectly fine for simple "filter" programs, where you're basically just applying a function to the contents of a file.)
23:23:05 <pikhq> Lessee... IIRC,
23:23:07 <pikhq> :t readFile
23:23:08 <lambdabot> FilePath -> IO String
23:23:53 <soupdragon> > let partitions = knead (replicate n 1) ; knead j@(x:y:zs) = [j] ++ map ((x+y):) (knead zs) ++ knead (x+y:zs) ; knead j = [j] in partitions 6
23:23:54 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:23:54 <lambdabot>         against inferred type ...
23:24:18 <tensorpudding> readFile puts it into string form, then you can create a parsing function that takes that string and parses it
23:24:20 <Cale> do x <- readFile "foo.in"; ... do stuff with x ...   -- specifically, you'll probably want to apply the lines function
23:24:30 <Cale> (to break the input into lines)
23:24:46 <soupdragon> > let partitions n = knead (replicate n 1) ; knead j@(x:y:zs) = [j] ++ map ((x+y):) (knead zs) ++ knead (x+y:zs) ; knead j = [j] in partitions 6
23:24:47 <lambdabot>   [[1,1,1,1,1,1],[2,1,1,1,1],[2,2,1,1],[2,2,2],[2,2,2],[2,2,1,1],[2,3,1],[2,3...
23:24:52 <pikhq> Likely, yeah...
23:24:55 <soupdragon> ah that's not very good
23:25:05 <Cale> soupdragon: Want a hint?
23:25:09 <soupdragon> yes
23:25:33 <Cale> soupdragon: Consider first the function which finds all partitions of n with largest part at most k
23:25:41 <AshleyS> pikhq: But you can't apply a simple filter on the resulting list because the list's elements are dependant on one another to be processed.
23:25:44 <tensorpudding> either way, you'll have a list at some point
23:26:00 <tensorpudding> and you'll process that list through recursion on the tail
23:28:30 <pikhq> AshleyS: I fail to see how this prevents you from applying a function to a list.
23:28:39 <Cale> AshleyS: after getting the name of an accuser and a number n of accusations to follow, you'll want to apply splitAt n to the tail of the list in order to break it into the n accusations and the rest.
23:29:19 <AshleyS> Cale: Thanks this is starting to make more sense
23:30:41 <pikhq> AshleyS: Just as an example: I've actually written a full (moderately optimising) compiler that is written as nothing more than a filter.
23:30:52 <pikhq> Here's the main: main = getContents >>= putStrLn  comp  opt  parse
23:31:45 <soupdragon> I love that 
23:31:49 <pikhq> Sorry, s//./ Got my Emacs set up to render a few things using different characters in Haskell-mode buffers. Quite nice until you try copy-paste.
23:31:59 <soupdragon> > let partitions 0 _ = [[]] ; partitions n b | n < b = [] ; partitions n b | n >= b = map (b :) (partitions (n - b) b) ++ partitions n (b + 1) in partitions 5 1
23:32:00 <lambdabot>   [[1,1,1,1,1],[1,1,1,2],[1,1,3],[1,2,2],[1,4],[2,3],[5]]
23:32:21 <Cale> > let { parse [] = []; parse (x:xs) = let [accuser, ns] = words x; n = read ns; (accused, rest) = splitAt n xs in (accuser, accused) : parse rest } in parse ["Stephen 1", "Tommaso", "Tommaso 1", "Galileo", "George 2", "Isaac", "Stephen"]
23:32:22 <lambdabot>   [("Stephen",["Tommaso"]),("Tommaso",["Galileo"]),("George",["Isaac","Stephe...
23:32:34 <pikhq> soupdragon: You'd also love how () gets rendered as . :)
23:32:58 <RyanT5000> is there a way to make darcs annotate give reasonable output? i.e.: put the annotations at the beginning or end of each line
23:33:06 <Cale> AshleyS: Sorry that that's all compressed onto one line and uses pairs instead of a proper datatype, but there you go :)
23:33:43 <AshleyS> cale: Thanks
23:34:47 <Cale> RyanT5000: I don't know, but apparently there's a --human-readable option.
23:35:00 <RyanT5000> yeah; as far as i can tell, that does absolutely nothing :)
23:35:39 <RyanT5000> apparently nobody in #haskell ever cares about who wrote some code :)
23:36:16 <RyanT5000> take that, Lawrence Lessig and CC-By :P
23:36:41 <Cale> Elements of the Haskell hive-mind write identical code most of the time anyway.
23:36:48 <RyanT5000> hahaha
23:36:51 <RyanT5000> i wish :)
23:37:11 <RyanT5000> well, as long as it was identical to some good code
23:37:15 <Cale> hehe
23:37:46 <Cale> Yeah, one never needs to care about who it is as long as it's sufficiently well written. :)
23:38:46 <RyanT5000> yeah
23:39:41 <Cale> It'd be nice if it had a way to generate pretty HTML output coloured by author.
23:39:53 <RyanT5000> yeah
23:40:06 <RyanT5000> i pretty much want exactly what "svn blame" does
23:40:22 <RyanT5000> i'm frankly surprised at how bizarre annotate's output is
23:41:58 <AshleyS> Cale: I am confused by this: parse (x:xs) = let [accuser, ns] = words x;
23:42:15 <Cale> AshleyS: let ... in ...
23:42:27 <AshleyS> Cale: I don't understand what is assigned to accuser and ns.
23:42:28 <mee> wow, RWH is really well written. I wish I had sat down and worked through this book a long time ago rahter than try to understand stuff from reading blogs.
23:42:32 <Cale> is a syntax for making some declarations (following the let) available to the expression in the 'in'
23:42:43 <Cale> AshleyS: The first and second word of the line
23:43:12 <Cale> AshleyS: If there are a number of words different from 2, you'll get a pattern match failure there and the program will die, but we're assuming the input file is good.
23:43:34 <AshleyS> Cale: OK thanks.
23:43:38 <Cale> > words "Stephen 1"
23:43:39 <lambdabot>   ["Stephen","1"]
23:44:14 <Cale> Of course, ns is still a string, and we need it to be a number
23:44:27 <Cale> So  n = read ns  will parse it
23:45:12 <Cale> I also could have just put the read ns into the definition containing splitAt instead
23:45:18 <AshleyS> Its making more sense now, I just got tripped up at the start
23:45:35 <Cale> cool
23:45:40 <ClaudiusMaximus> @src interact
23:45:41 <lambdabot> interact f = do s <- getContents; putStr (f s)
23:46:02 <ClaudiusMaximus> @undo  do s <- getContents; putStr (f s)
23:46:02 <lambdabot> getContents >>= \ s -> putStr (f s)
23:46:42 <ClaudiusMaximus> @pl \f -> getContents >>= \ s -> putStr (f s)
23:46:42 <lambdabot> (getContents >>=) . (putStr .)
23:47:20 <kniu> oi
23:47:28 <kniu> screw this noise.
23:48:05 <ClaudiusMaximus> sorry.
23:48:43 <kniu> no, not you.
23:48:49 <kniu> trying to compile bytestring-mmap
23:49:01 <kniu> At first I thought it might be because I downloaded the wrong ghc binary.
23:49:10 <kniu> so I tried the one that didn't use libtinfo instead.
23:49:12 <kniu> Same problem.
23:49:21 <kniu> Then I tried building an earlier package.
23:49:34 <kniu> 0.2.0 and 0.1.* all have the same damn problem.
23:59:07 <Veinor> http://4chanarchive.org/images/g/1021226/1202313464429.jpg
23:59:34 <Zao> MY EYES!
23:59:53 <Zao> May I strongly recommend against linking NSFW images in here?
