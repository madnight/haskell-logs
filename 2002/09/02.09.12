00:15:43 <jemfinch> hmm.
00:15:44 <jemfinch> what's a prefix tree?
00:24:43 <jemfinch> "In practice I've needed all of the above, and wrestling with laziness is something that happens with every serious Haskell program I write."
00:25:03 <jemfinch> http://users.aber.ac.uk/ajc99/stricthaskell.html
00:27:23 <Pseudonym> Erm... a prefix tree is kinda like a trie, I think.
00:27:42 <Pseudonym> BTW, he's right as far as it goes.
00:27:48 <Pseudonym> Laziness is a blessing and a curse.
00:27:58 <jemfinch> how so?
00:29:03 <Pseudonym> Laziness incurs a cost.  For anywhere where the compiler can't prove that it's not needed, every type basically has to be a discriminated union of an object and a thunk.
00:29:15 <Pseudonym> It's implemented a bit more efficiently than this, of course.,
00:29:33 <Pseudonym> The other thing, is it can cause unexpected space leaks.
00:29:48 <Pseudonym> The code to generate an object can be bigger than the object itself.
00:30:12 <Pseudonym> By "code" I don't mean executable instructions, but rather the stuff associated with the thunk.
00:30:50 <jemfinch> so why is Haskell lazy, if it causes so much problem?
00:30:53 <Pseudonym> Concurrent Clean is a language with an interesting approach.  Like ML, laziness only happens where you explicitly ask for it.  Like Haskell, it's still a pure language.
00:31:05 <Pseudonym> Well it doesn't cause _so_ much problems.
00:31:20 <Pseudonym> And it does have benefits.
00:31:33 <jemfinch> I've read some of them, but what do you consider the benefits of laziness?
00:31:34 <Pseudonym> For example, garbage collector performance is (theoretically) much better.
00:31:48 <jemfinch> why's that?
00:32:15 <Pseudonym> If an object is consumed the moment it's produced and never seen again, generational garbage collectors are theoretically optimal.
00:32:37 <Pseudonym> In fact, in Haskell I'd say most memory is very short-lived.
00:35:15 <jemfinch> other than performance reasons, are there any disadvantages of laziness?
00:35:34 <jemfinch> (and, other than performance reasons, are there any *advantages* of laziness?)
00:36:41 <Chilli> laziness helps to modularise code
00:36:55 <Chilli> (see, John Hughes "Why functional programming matters?")
00:37:43 <jemfinch> how?
00:39:15 <jemfinch> I read that :)
00:41:12 * Heffalump reads scrollback and notes that having an explicit forall isn't Haskell 98, is it?
00:41:36 <jemfinch> howdy, Heffalump :)
00:42:21 <Heffalump> morning
00:43:44 <Pseudonym> Gotta go.  Night all/
00:43:45 <Pseudonym> \/quit
00:44:54 <norpan> hi all
00:45:06 <andersca> hello mr norp
01:31:12 <o3> norpan: did you get the URL?
01:32:04 <norpan> o3: yes, i've tried it, seems to work :)
01:32:11 <norpan> o3: but my problem remains...
01:32:16 <o3> norpan: oh?
01:32:44 <norpan> my problem is that i want already written c code that dlopens an .so-file to be able to use haskell code
01:33:11 <o3> and the haskell code is in the .so?
01:56:17 <Heffalump> hmm, would it be possible to link the .o file into a .so with a C stub?
01:59:41 <jemfinch> Heffalump: you also use SML, right?  Mind if I ask you an SML question?
02:02:07 <Heffalump> sure
02:02:57 <jemfinch> hmm...never mind, I got it :)
02:03:07 <jemfinch> don't worry, it was a pretty stupid question anyway :)
02:03:23 <Heffalump> ok :-)
02:10:34 <norpan> o3: yes, the haskell code is in the .so along with c wrapper code, but it wont run due to some technical stuff about the .so format
02:12:54 <Heffalump> YM you can call the C code but it can't call the Haskell code?
02:20:20 <norpan> no, the dynamic linker claims that there are errors in the so file
02:20:24 <norpan> at least i think so
02:21:07 <norpan> at runtime that is
02:21:22 <norpan> i haven't tried to dlopen it directly, perhaps i should try that
03:04:14 <o3> norpan: you may be able to dlopen() the .so and pass a pointer to the function
03:04:21 <o3> norpan: what platform is this for, btw?  linux?
03:04:31 <norpan> yes
03:04:42 <norpan> i'll try it later
03:05:06 <andersca> hi nörpan
03:05:22 <o3> norpan: hmm, how are you building the .so?  that would be _really_ neat if we can get it working with .so's! :)
03:08:56 <norpan> i'm just linking with ld -shared
03:10:51 <o3> loading .so's might be possible if there's a way to call dlopen() from haskell
03:11:05 <o3> norpan: keep in mind that the "dynamic linker" example i gave isn't really a dynamic linker, which is why it won't work on .so's
03:11:34 <norpan> yes, but as it was explained to me, it doesn't work to put haskell code in .so-files due to some conflict between ghc:s optimizations and the rules for how to place things in so files
03:15:49 <o3> that makes some sense.  is it possible at all to not have a .so file?
03:16:03 <o3> (and just make the .o file)
03:16:09 <o3> obviously that would be the easiest thing to do
03:16:17 <norpan> no, because the c program is fixed, and wants to dlopen an .so-file
03:16:28 <o3> :(
03:16:33 <norpan> think xmms or whatever
03:17:45 <o3> i'm confused.  the host program is written in C or haskell?
03:17:51 <Heffalump> C
03:17:53 <norpan> host program in C
03:18:09 <Heffalump> so it's a more general problem than dynamically loading Haskell code from within Haskell
03:18:12 <norpan> does dlopen and calls a specific function
03:18:20 * Heffalump reappears from reading through all the ghc-users threads
03:18:52 <norpan> many programs do this for plugins, i want to be able to write a plugin in Haskell
03:19:02 <norpan> without having to change the calling program
03:19:12 <andersca> use corba ;)
03:19:46 <o3> norpan: then you want to go through the FFI, no?
03:20:07 <o3> the example i gave is to demonstrate how to do it when have a host program written in haskell
03:20:13 <norpan> o3: yes, i have it working when the c program statically links with the haskell library (and a small c wrapper)
03:20:22 <norpan> o3: yes, i understand that
03:20:58 <o3> so you're trying to put all the haskell runtime stuff into the .so as well then?
03:21:03 <norpan> yes
03:21:15 <norpan> there is a small c wrapper that calls startupHaskell
03:21:21 <o3> ah.  in that case, good luck :-)
03:21:35 <norpan> o3: thanks
03:21:41 <norpan> but your program is interesting too
03:22:09 <o3> norpan: yousr will be more interesting when you get it working :)
03:22:22 <norpan> perhaps I can make a .so C file that imports Haskell .o-files in some way
03:23:25 <o3> perhaps that'll work
03:23:54 <norpan> then I'll have to design my own dynamic library format, I wish myself luck :)
03:26:32 <norpan> hmmm now I get segmentation fault instead
03:28:41 <Heffalump> do the foreign imports in RuntimeLoader.hs come from ghci?
03:29:58 <o3> Heffalump: yes, it's basically a "massaged" version of ghc/compiler/ghci/Linker.lhs (from the ghc source)
03:30:06 <o3> i should have written that in the non-existent docs :)
03:30:17 <Heffalump> right
04:12:37 * shapr thinks about http://www.pragmaticprogrammer.com/cgi-local/pragprog?MindCrayon
04:12:47 <shapr> hi shreya_
04:12:55 <shreya_> hey
04:12:58 <shapr> what's up?
04:13:06 <shreya_> Trying to get this darn ZIP drive working
04:13:11 <shreya_> Keep getting this error
04:13:13 <shreya_> [18:48:31] <root@shreya> mount -t vfat /dev/sda4 /mnt/zip100.0/
04:13:17 <shreya_> mount: the kernel does not recognize /dev/sda4 as a block device
04:13:17 <shreya_>        (maybe `insmod driver'?)
04:13:22 <shreya_> I have no idea why it is saying that
04:13:29 <shapr> do you have a zipdrive kernel module?
04:13:37 <shapr> I think I've seen one somewhere.
04:13:45 <shreya_> Um don't know
04:13:49 <shreya_> how do I check?
04:13:55 <shreya_> <-- newbie
04:13:57 <shapr> look for zip drive kernel modules
04:14:37 * shapr googles
04:14:47 <shreya_> Alright, i'll try that
04:14:52 <shapr> http://www.tldp.org/HOWTO/mini/ZIP-Drive-3.html
04:15:16 <shapr> you can check to see if you already have the kernel modules by doing "modprobe ppa"
04:15:28 <shapr> err
04:15:28 <shapr> well
04:15:39 <shapr> maybe you should read the howto, I don't want to give you bad advice.
04:15:54 <shreya_> Oooh
04:15:59 <shreya_> ppa!
04:16:15 <shreya_> [18:48:48] <root@shreya> modprobe ppa
04:16:17 <shreya_> Hint: insmod errors can be caused by incorrect module parameters, including invalid IO or IRQ parameters
04:16:20 <shapr> it seems to want the lp kernel module also
04:16:24 <shapr> try modprobe -v
04:16:35 <shapr> er, "modprobe -v ppa"
04:16:47 <shapr> iirc, that's the verbose switch, lets you see any errors that might have happened
04:18:59 * shapr has a sudden urge to switch to KDE
04:38:43 <shreya_> wb
04:38:45 <shapr> re
04:38:53 <shreya_> that modprobe -v ppr didn't say anything useful
04:39:03 <shapr> did it say anything?
04:39:26 <shreya_> let me see
04:39:53 <shreya_> [19:30:02] <root@shreya> modprobe -v ppa
04:39:54 <shreya_> Using /lib/modules/2.2.19/scsi/ppa.o
04:39:54 <shreya_> Symbol version prefix ''
04:39:54 <shreya_> Hint: insmod errors can be caused by incorrect module parameters, including invalid IO or IRQ parameters
04:40:54 <shapr> try it with insmod -v ppa
04:42:16 <shreya_> ok
04:42:27 <shreya_> whoah
04:42:31 <shreya_> that spammed a whole lot of crap
04:43:02 <shapr> you may want to pipe that through less or something
04:43:10 <shapr> insmod -v ppa|less
04:44:27 <shreya_> nah it's a bunch of useless crap
04:44:39 <shreya_> user function /lib/modules/2.2.19/scsi/ide-scsi.o
04:44:39 <shreya_> user function /lib/modules/2.2.19/scsi/imm.o
04:44:39 <shreya_> user function /lib/modules/2.2.19/scsi/osst.o
04:44:39 <shreya_> user function /lib/modules/2.2.19/scsi/ppa.o
04:44:43 <shreya_> basically a whole lot of that
04:44:46 <shapr> hmm
04:44:57 <shapr> sounds like you'll have to read the HOWTO
04:45:03 <shreya_> ok
04:47:39 <JC_freak> hi all
04:47:50 <shapr> hiya
04:48:17 <JC_freak> can someone give me a good explanation on how 'break' works in haskell
04:48:21 <JC_freak> plz
04:53:25 <dennisb> Prelude> break isDigit "abcde12345abcde"
04:53:25 <dennisb> ("abcde","12345abcde")
04:54:44 <JC_freak> ahh i c
04:56:13 <JC_freak> so thats how lines work
04:57:28 <JC_freak> so break ('a' ==) "bat"
04:57:41 <JC_freak> ("b","at")
04:57:49 <JC_freak> is that right?
04:57:49 <dennisb> yes, it's a useful function
04:58:09 <JC_freak> how about if i want to not include the 'a'
04:58:40 <dennisb> you want to remove it compleatly?
04:59:07 <JC_freak> yes so i want the out put to look like ("b","t")
04:59:20 <dennisb> don't think there us such a function (but easy to do anyway)
04:59:22 <cleverdra> break' x = let (a,b) = break x in (a, tail b)
05:00:31 <JC_freak> oh
05:01:16 <JC_freak> is (a,b) the list?
05:01:44 <cleverdra> What is 'the list'?
05:01:57 <cleverdra> (a,b) is the pair that break returns
05:02:10 <JC_freak> ohh
05:02:14 <dennisb> the second argument to break is missing, you have to add it
05:02:17 <JC_freak> x is the input string
05:02:29 <cleverdra> err, yes.
05:02:47 <cleverdra> err, yes -> dennisb.
05:03:29 <cleverdra> x is the first argument to break; a second argument is needed.  Is there a way to do this so that parameters need not be specified?
05:05:13 <dennisb> you could do it with a function composition
05:05:50 <cleverdra> foo (a,b) = (a, tail b) -- break' = foo . break
05:05:51 <cleverdra> right =)
05:05:52 <dennisb> break' f = (\(a,_:b)->(a,b)) . break f
05:06:04 <cleverdra> That's better, thank you.
05:06:16 <cleverdra> (where 'f' is unnecessary, of course)
05:06:30 <dennisb> well, not really
05:06:42 <dennisb> you need another composition then . in that case
05:06:56 <cleverdra> oh, right.
05:07:36 <cleverdra> actually, scratch that 'right'.  I'll ask Haskell about this later.
05:07:43 <shapr> ?
05:07:54 <shapr> is that a new nickname for Heffalump?
05:09:24 <dennisb> Mr. Haskell
05:09:43 * shapr grins
05:09:54 <Heffalump> whowhatwhichwhen?
05:10:06 * shapr laughs
05:10:17 <Heffalump> that's Dr Ganesh "Heffalump" Sittampalam to you, thankyouverymuch.
05:10:27 <Heffalump> :-p
05:10:27 * shapr grins
05:10:45 <shapr> Dr Ganesh "Haskell" Sittampalam
05:11:25 * shapr makes up a new honorific (horrorific?) of Gk short for Geek
05:11:38 <shapr> maybe Pgm short for Programmer?
05:11:58 <Heffalump> Ganesh Sittampalam D.Phil Gk Pgm
05:11:58 <Heffalump> cool.
05:12:04 * shapr grins
05:12:12 <shapr> Shae Erisson Gk Pgm
05:14:35 <cleverdra> shapr - you can pronounce it "Guk Pig'em"
05:15:07 * shapr grins
05:15:09 <shapr> hmmm
05:24:51 <olczyk> Is there a haskell mode for emacs?
05:24:56 <shapr> yup
05:24:57 <Heffalump> yes
05:25:26 <shapr> hi thaddeus, what's up?
05:25:46 <o3> olczyk: http://www.haskell.org/haskell-mode/
05:25:53 <olczyk> Saddam.
05:25:56 <o3> google is your friend
05:27:32 * olczyk listening to interview on radiowith Claire Shipman. Tonight she has an interview with Saddams girlfriend. She says he uses Viagra.
05:27:44 <shapr> scary
05:28:57 <olczyk> Found it. Thanks.
05:29:12 <shapr> hi olczyk, are you learning Haskell?
05:29:13 <norpan> who cares if Saddam uses Viagra?
05:30:57 <olczyk> A bit. I'm playing with a program written in Haskell.
05:31:07 <olczyk> It has some cryptic error messages.
05:32:04 <cleverdra> tsk tsk.  Another poor unix player.
05:32:33 <shapr> olczyk: which program?
05:32:48 <cleverdra> olczyk - type-related errors?
05:32:52 <olczyk> Something a friend wrote.
05:32:55 <shapr> oh, ok
05:33:02 <olczyk> Input related errors.
05:33:16 <olczyk> I inpput something and it tells me it's wrong but not why.
05:34:34 <shapr> o3: hey, I think you should post that example to ghc-users, it's nifty
05:35:32 <o3> shapr: i will
05:35:39 <shapr> cool
05:35:40 <o3> after this compilers assignment :)
05:35:42 <shapr> ok
05:35:45 <o3> (grumbles)
05:35:50 <norpan> yikes my QuickCheck test propToUpperIsUpper failed
05:35:54 <olczyk> Since there are so many people here, I think I will ask a question.
05:36:00 <Heffalump> norpan: that seems careless...
05:36:08 <shapr> yay, someone else is using QC
05:36:18 <olczyk> I was going to lear Smalltalk as my loty, but I decide I really *hate* it.
05:36:19 <norpan> it seems toUpper 'ÿ' is 'ß'
05:36:20 <Heffalump> you'd hope people at Chalmers would be, though :-)
05:36:32 <norpan> ghc gets it right
05:36:43 <shapr> olczyk: Smalltalk has very good things
05:36:48 <olczyk> So now I have to decide between Haskell, Erlang and OCaml.
05:36:50 <norpan> and toUpper 'ß' is '¿'
05:36:58 <Heffalump> that's impressively broken
05:37:02 <shapr> olczyk: what is the point of learning them for you?
05:37:04 <olczyk> I like the language, it's the environment that I hate.
05:37:19 <shapr> olczyk: I picked Haskell to learn a different way of thinking
05:37:25 <olczyk> It's just very slow to search for stuff.
05:37:34 <olczyk> No emacs mode ;)
05:37:45 <shapr> I use haskell-mode all the time.
05:37:46 <shapr> it's great.
05:37:51 <shapr> olczyk: you could try hIDE
05:37:53 <olczyk> All these small methods everywhere.
05:38:06 <olczyk> What's hIDE.
05:38:16 <o3> olczyk: small methods are bad?
05:38:21 <shapr> oh, you mean Smalltalk
05:38:32 <shapr> hi ChilliX
05:38:33 <olczyk> Two line methods. It depends.
05:38:48 <ChilliX> Hi shapr
05:38:49 <o3> greetings chilli
05:38:52 <cleverdra> I still need to think about OCaml (scared by the Standard ML tutorial, perhaps?) but Haskell and Erlang are definitely good lotys, though I wonder why you don't just learn both, or several.
05:39:18 <olczyk> I would hate to calculate Vornoi diagrams using one and two line methods.
05:39:23 <shapr> I have CLP on my list after FP
05:39:40 <olczyk> You lose sense of the algorithm. ( Just one example. )
05:39:46 <olczyk> CLP?
05:39:55 <shapr> constraint logic programming
05:40:00 <olczyk> Ah.
05:40:01 <shapr> prolog, mercury
05:40:05 <o3> olczyk: perhaps more liberal use of where clauses will solve that
05:40:13 <cleverdra> shapr - also Oz
05:40:37 <o3> i don't see what your beef is, though.  i think C programmers would die for two-line methods everywhere :)
05:40:44 <cleverdra> oldczyk - I suppose those small methods deal with something simpler.  (Forther's might write such, however)
05:41:08 <cleverdra> Blech.  UUOH.
05:41:56 <olczyk> I think tht learning all three at the same time is not a good idea ( unless they are very close
05:42:01 <Heffalump> prolog isn't CLP is it?
05:42:04 <olczyk> like CL and Scheme ).
05:42:33 <Heffalump> I think learning two very similar languages simultaneously is a recipe for disaster
05:42:48 <shapr> Heffalump: I thought prolog was CLP
05:43:01 <Heffalump> shapr: it doesn't work with constraints
05:43:17 <olczyk> I have nothing against small methods, but I don't think the 'language' forces it. I think
05:43:21 <shapr> my knowledge of CLP is nearly zero.. and will probably remain so till I'm happy with my Haskell fluency
05:43:30 <olczyk> ST IDEs make it hard to have large methods.
05:43:48 <shapr> olczyk: no, I think they make it easy to have small methods
05:44:03 <shapr> especially since the original Refactoring Browser was written for, and in, Smalltalk
05:44:11 <olczyk> No autoindenting. No color hilighting. No begin-end  sexp matching.
05:44:17 <shapr> nowadays the RB is in every Smalltalk environment
05:45:13 <olczyk> The biggest of all- when I need to take a break for Lunch, I can't print it out in a clean
05:45:15 <olczyk> way.
05:45:29 <shapr> you need a webpad ;-)
05:45:42 <shapr> as I've said before, Smalltalk has an Image problem.
05:45:49 <cleverdra> Heffalump - you say that in an 'infinite' way.  Do you mean at the same time?  Why?
05:46:06 <smkl> mercury and prolog aren't really CLP, but they have some support for constraints
05:46:17 <shapr> smkl: what really is CLP?
05:46:35 * shapr decides kde2 is intolerable, and switches to ion
05:46:36 <shapr> brb
05:46:53 <Heffalump> cleverdra: e.g. SML and O'Caml are quite similar but with annoying syntactic differences
05:46:59 <smkl> clp(R), clp(FD,S) ... concurrent constraint languages
05:48:11 <olczyk> I have no problem with images.
05:48:37 <olczyk> If you use an image with an emacs inferior mode like ilisp it can be very powerful.
05:49:06 <shapr> ahhh, that's much better
05:49:45 <olczyk> I have no problem with images.
05:49:46 <olczyk> If you use an image with an emacs inferior mode like ilisp it can be very powerful.
05:49:57 * olczyk repeats cause shapr was gone.
05:50:40 --- mode: card.freenode.net set +o Chilli
05:50:40 --- mode: ChanServ set -o Chilli
05:50:52 <Heffalump> I see Chilli's causing trouble.
05:51:07 <ChilliX> the server was causing trouble
05:51:14 <Heffalump> :-)
05:51:27 <Heffalump> OPN seems to get a lot of network problems for its size
05:52:12 <ChilliX> yeah, that's true
05:53:22 <Heffalump> not that I can talk, since I help run a network of 4 servers that has quite a lot of problems off and on
05:54:28 <ChilliX> which network?
05:54:54 <Heffalump> s'a semi-private one for Oxford people
05:56:08 <ChilliX> ic
05:56:36 <Heffalump> most of our problems tend to come from connectivity we don't control failing, though
05:58:38 <ChilliX> I am on /net and OPN
05:58:47 <ChilliX> and /net seems to have much less trouble
05:59:26 <Heffalump> how big is it?
06:03:17 <ChilliX> not very big: 6 server
06:03:57 <Heffalump> how many people?
06:04:26 <smkl> even ircnet has less trouble than freenode
06:05:13 <ChilliX> Heffalump: not sure; irc.slashnet.org
06:05:56 <Heffalump> 734 global users
06:06:07 <Heffalump> OPN has 10 times that
06:07:30 <ChilliX> ic
06:08:28 <ChilliX> oops...I could have checked that myself in the server log, sorry
06:09:12 <smkl>  /lusers
06:10:37 <Heffalump> I love the name of that command :-)
06:10:52 <Blizz_> hello
06:11:02 <Heffalump> 'lo
06:13:58 <ChilliX> smkl: or that...
06:15:24 * shapr returns from being distracted by a woman bearing ice cream
06:16:35 <shapr> hi Blizz_
06:16:41 <Blizz_> hi shapr
06:17:54 * shapr bounces
06:19:32 --- mode: ChanServ set +o Chilli
06:21:57 <ChilliX> thanks
06:26:50 <clinton> is there a somewhat free implimentation of curry?
06:27:38 <ChilliX> AFAIK there is a research implementation, which I would expect to be "somewhat" free
06:29:46 <clinton> ChilliX: which is?
06:30:23 <smkl> http://danae.uni-muenster.de/~lux/curry/ -- seems to have the HBC licence
06:34:26 <clinton> smkl: thanks, I'll give that a go...
06:34:58 <smkl> i think that is the only one that doesn't require prolog
06:37:47 <tmoertel> good mooooooooooorning haskellers!
06:37:53 <shapr> gooood morning tmoertel!!
06:38:07 <shapr> how's the northeast USA doing today?
06:38:23 <tmoertel> it's still here, which is good, i suppose ;-)
06:38:30 <Heffalump> better than it was 366 days ago, methinks
06:38:40 <shapr> truly :-(
06:38:45 <tmoertel> the nasty heat-wave has abated, another good thing
06:41:19 <ChilliX> well, I hope it is still nice and warm when PLI is!
06:41:52 <Heffalump> hmm, yes
06:41:55 <tmoertel> ChilliX: it ought to be warm, but not 90+ degF w/ 70+% humidity
06:42:08 <Heffalump> early registration deadline for PLI is today, everyone :-)
06:42:36 <ChilliX> so what is 90 degF in more standardised units?
06:42:53 <Heffalump> 33
06:43:12 <Heffalump> sorry, 32 Celsius
06:43:20 <Heffalump> (subtract 32, multiply by 5/9)
06:43:34 <ChilliX> and talking about the PLI-Early-Registration-Deadline, the (more or less) final programme of the Haskell Workshop is up: http://www.cse.unsw.edu.au/~chak/hw2002/
06:43:45 <ChilliX> Heffalump: thanks
06:44:40 <tmoertel> Here, let me do the math 90 degF + 70%+ humidity = hot and unpleasant ;-)
06:44:42 <Heffalump> has the programme changed from last week?
06:45:05 <ChilliX> it has times now and one 10min talk fixed
06:45:16 <ChilliX> so, slight changes
06:45:25 * tmoertel visits programme . . .
06:45:59 <ChilliX> tmoertel: are you going to attend?
06:46:07 <Heffalump> do you know what Koen is going to say about Read?
06:46:10 <tmoertel> yes
06:46:21 <ChilliX> good :-)
06:46:33 <tmoertel> I'll be there. Practically, I already am. (I live in Pittsburgh.)
06:46:36 <ChilliX> Heffalump: yeah, talk about the new implementation
06:46:51 <Heffalump> oh, I didn't know there was one :-)
06:47:09 <ChilliX> Heffalump: you see, the Haskell Workshop is very educational
06:47:33 <Blizz_> Given some data-type (type bla x = etc) what do I need first: the algorithm to deduce catamorphism or the catamorphism to deduce the algorithm?
06:47:46 <ChilliX> tmoertel: I figured that you are in PIT...thus, I thought there is a fair chance that you are going to come
06:48:02 <Heffalump> chillix: you don't want it to be educational for me before I attend, otherwise you reduce the chances of me attending :-)
06:48:14 <Heffalump> (though since I'm now registered for it there's no problem there in fact :-)
06:48:26 * Heffalump disappears for a while
06:49:11 <norpan> there, bugs reported about toUpper in both hugs and ghc .)
06:49:12 <ChilliX> Heffalump: hehe :-)
06:49:31 * shapr evangelizes Haskell to random people on various channels.
06:49:47 <Heffalump> you'd really think toUpper would be idempotent.
06:49:49 <ChilliX> shapr: yes, show them the light
06:49:59 <Heffalump> actually, that's a nice simple quickCheck property.
06:50:16 <norpan> Heffalump: in ghc it is, but ÿ should be mapped to U0178 if you'd want to be unicode compliant
06:50:46 * tmoertel thinks shapr should post to rec.food.drink.tea: "the other day, I put some Haskell in my Earl Grey, and it was simply delightful!"
06:50:49 <norpan> Heffalump: actually, my test was char => isUpper(toUpper char) || toUpper char == char
06:50:52 * shapr laughs
06:51:14 <norpan> err remove the char => bit
06:51:26 <ChilliX> Heffalump: yes, a comprehensive set of QC properties for the Prelude and standard libs would be great
06:51:27 <Heffalump> what's the second bit for?
06:51:38 <norpan> Heffalump: things that are neither upper or lower
06:51:39 <Heffalump> chillix: where would they go?
06:51:55 <Heffalump> oh, right, yes
06:52:12 <ChilliX> well, just as a set of extra modules to run regression tests on the prelude impls of the various Haskell systems
06:52:17 <norpan> but idempotency is even simpler
06:52:26 <Heffalump> but doesn't test isUpper
06:52:31 <jewel> tmoertel: are you one of those sad unbelievers who thinks tea is just a recreational thing?
06:52:44 <ChilliX> this way, the preludes of the various systems would at least do the same thing
06:52:47 * Heffalump doesn't like tea.
06:53:01 <Heffalump> chillix: hmm, yes
06:53:18 <ChilliX> QC would be perfect for that
06:53:24 <Heffalump> now I want to take my laptop with me on holiday tomorrow so I can start writing tests :-)
06:53:33 <ChilliX> :-)
06:53:39 <tmoertel> jewel: I don't think you would make that characterization if you saw my tea table.
06:53:42 <norpan> you could also test things like toLower.toUpper.toLower.toUpper = id :)
06:53:44 <ChilliX> where are you going for holiday?
06:53:47 <Heffalump> Ireland
06:53:54 <jewel> ah, a believer
06:53:58 <norpan> or wait, thats not true .)
06:54:06 <ChilliX> cool, have never been to Ireland
06:54:11 * jewel intends to leave Ireland for a holiday
06:54:29 * shapr likes Maté tea
06:54:46 <norpan> Ireland is nice
06:54:47 <Heffalump> leaving at 5am tomorrow morning though :/
06:54:54 <ChilliX> Heffalump: urgh
06:55:05 * ChilliX is addicted to Japanese green tea
06:55:07 * tmoertel is made thirsty by all this talk about tea, and runs off to make some . . .
06:55:15 <tmoertel> ChilliX: sencha?
06:55:35 <ChilliX> tmoertel: so da
06:55:36 <shapr> oh, I like Celestial Seasonings Morning Thunder tea also
06:56:25 * tmoertel thinks "morning thunder" sounds too much like an unpleasant after-coffee bathroom incident
06:56:29 <ChilliX> tmoertel: which is Japanese for "exactly" ;-)
06:56:39 <ChilliX> tmoertel: rotfl
06:58:29 <tmoertel> ChilliX: have you seen "we review teas"? (http://www.normbrero.com/cgi-bin/viewTea.cgi)
06:59:45 * tmoertel thinks "we review teas" should get an award for "the most practical use of a relational database on the internet"
06:59:52 <Blizz_> This is really a beginners question, but I need to know : is 'data Nat = Zero | Succ Nat' exactly the same as 'data Nat a = Zero a | Succ (Nat a)'?
07:00:16 <Heffalump> the former defines the natural numbers, the latter defines a list
07:00:21 <Heffalump> oh, no it doesn't
07:00:35 <Heffalump> the latter defines a pair of a natural number and some value, effectively
07:00:55 <Heffalump> Nat in the first one and Nat () in the second one would be the same thing, basically
07:01:07 <ChilliX> tmoertel: didn't know that
07:03:03 <Blizz_> mmm ok .. need some more studie on this part ;)
07:03:31 <ChilliX> tmoertel: problem is that is rather hard to get at *good* Japanese green tea outside of Japan *sigh*
07:04:22 * shapr tries to explain partial application and HOFs to a procedural programmer.
07:04:43 <cleverdra> shapr - what, are you finding it difficult?
07:04:51 <shapr> well, this person learned Java first
07:04:58 <ChilliX> HOFs is not too bad: function pointers, call backs, hooks, etc
07:05:08 <shapr> so the idea and usefulness of first class functions is not obvious
07:05:37 <shapr> hm, I'll try explaining it like that.
07:05:44 <cleverdra> Indeed.  If your language does not have a word for 'blue', you will be less sensitive to its presence.
07:05:59 <ChilliX> shapr: also for Java people, the mention of inner classes helps
07:06:06 <shapr> oh, good point!
07:06:06 <cleverdra> (hah, I have a study to back that up, but it's only partially relevant anyway)
07:06:26 <shapr> cleverdra: sapir-whorf study? tell me more
07:06:46 * tmoertel really does go to make some tea
07:08:30 <cleverdra> shapr - actually, yes =)  It's hidden in the (largish) swh.txt on lojban.org; it's a test given to English speakers and mumble-speakers, where mumble-speakers do not have a word for 'blue' (which isn't that surprising; blue is uncommon).  The test was, given one object and two others, to say which of the two others the first object was closer in color to.
07:09:06 <shapr> well, I didn't have a word for tope until recently...
07:09:09 <Blizz_> Heffalump: Can you tell why the list catamorphism algoritm has type (x, x->u->u) ?
07:09:13 <shapr> I'm still not really sure what it is
07:09:31 <shapr> cleverdra: otoh, lojban makes phrasing some thoughts much much simpler
07:09:40 <shapr> amazingly so
07:09:50 <cleverdra> shapr - the English speakers always grouped colors together, of course (blue is always closer in color to blue than green, right?) whereas the mumble-speakers gave seemingly random responses, which which turned out to be actually *true* on physical similarity.
07:10:38 <cleverdra> shapr - that is, the green object would be closer in color to the blue object than the blue2 object; the English speaker would always pick the blue2 object.
07:10:46 <shapr> interesting
07:10:53 <shapr> the opposite of sapir-whorf
07:11:04 <shapr> "how you speak gets in the way of thinking clearly"
07:11:09 <Heffalump> Blizz_: YM (u,x->u->u)
07:11:25 <Heffalump> and because those mirror the types of the list constructors
07:11:26 <cleverdra> Well, it fits with less-strict formulations of the hypothesis, where your language merely affects your perception =)
07:12:10 <cleverdra> shapr - you might say that language divides the world up differently than physicists do =)
07:12:39 <Blizz_> Heffalump: ok great thnx
07:13:56 <cleverdra> shapr - also, I was wrong yesterday about Erlang; local calls will *not* be updated.  To automatically update, you'd have to have the loop call itself by module (which could be done on command through message-passing).
07:14:27 <Blizz_> Heffalump: BTW with list constructor you mean (:)?
07:14:34 <Heffalump> IM [] and (:)
07:14:45 <Heffalump> [] :: List a, (:) :: a -> List a -> List a
07:15:03 <Heffalump> replace List a by u and you get roughly what you said for the types of the catamorphism arguments
07:15:43 <Blizz_> Heffalump : thnx
07:18:12 <shapr> cleverdra: oh, so erlang updates on a module level?
07:18:54 <shapr> I wonder how it handles changing interfaces... are they versioned? do you need to keep the old interface around? maybe there's a wrapper?
07:18:55 <shapr> hmm
07:18:59 <shapr> fascinating stuff
07:19:43 <cleverdra> shapr - yes; it always did that (there isn't anything *but* a module level, SAFAICT), but I thought that loop() -> loop(). would change to call the new module.
07:20:43 <shapr> module level runtime upgrades could be done with the AdvancedRuntimeLoader that o3 talks about in the comments of RuntimeLoader.hs
07:20:50 <cleverdra> shapr - if you load a new module of the same name, the last is unreachable (but the code seems to be live in a process -- I'll have to experiment more with that).  There *are* version numbers in *:module_info(), and they might be used.
07:21:04 <shapr> fascinating.
07:21:44 * shapr thinks about how best to build scripting in Haskell into hIDE with AdvancedRuntimeLoader
07:22:04 <Heffalump> how about writing AdvancedRuntimeLoader first? :-)
07:22:22 <shapr> Heffalump: I wanna think about what it needs to do first...
07:22:50 <shapr> I noticed in the ICFP run that we did just throw down code...
07:23:03 <shapr> and later I wished we'd been able to plug in strategies
07:23:33 <shapr> so I'm trying to think about major uses of a RuntimeLoader, and what constraints would come from those uses
07:23:40 <Heffalump> I don't think a runtime loader would have helped us there
07:23:57 <shapr> I meant "more design"
07:24:20 <Heffalump> ah, ok
07:24:24 <shapr> though from what I wrote that isn't obvious...
07:24:46 * shapr shouldn't have said "plug in" next to "RuntimeLoader", too confusing
07:26:18 <ChilliX> bed time for me
07:26:20 <ChilliX> 'night
07:26:24 <shapr> g'night ChilliX
07:26:36 <Blizz_> ChilliX: almost time for dinner for me ;)
07:27:28 <tmoertel> 'night, ChilliX.
07:27:53 <norpan> only 16:27 here
07:29:45 <Heffalump> 15:27 here
07:29:59 <tmoertel> 10:29 in PIT
07:30:04 <Blizz_> 16:30 here
07:30:30 <Blizz_> GMT + 1 
07:30:41 <Heffalump> that's GMT+2
07:30:44 <Heffalump> we're GMT+1
07:31:23 <shapr> 17:30 here
07:31:34 <shapr> Eastern European Time, GMT + 3
07:31:52 <norpan> GMT+2 is central europe summer time, sweden for instance
07:32:08 <Heffalump> I think even Spain and Portugal are on CET.
07:32:34 <Blizz_> c'mon people all major important european cities have GMT+1 (Amsterdam, Paris, Barcelona, Milan) ;)
07:32:44 <shapr> hey, what about Helsinki?
07:32:46 <norpan> Blizz_: yes, during winter
07:33:17 <Heffalump> it's GMT + 2 in most of Europe now.
07:33:24 <Heffalump> GMT + 1 in Britain
07:33:39 <Blizz_> I cal it GMT + 1 with timesavingtimecorrection
07:33:40 <norpan> all of the EU, except Britain and Finland
07:34:05 <Heffalump> what about Ireland?
07:34:39 <Blizz_> Ireland == United Kingdom == GMT + 1 (winter)
07:34:48 <norpan> oh, and Ireland
07:34:55 <Heffalump> errm, in winter UK = GMT
07:35:00 <Heffalump> in summer UK = GMT + 1
07:35:08 <Blizz_> arrghh that's what I meant
07:38:18 * Blizz_ is going to get himself something to eat, see you later
07:40:17 * shapr fights with a csv file
07:55:01 * shapr suddenly realizes he should have written a cvs parser in haskell
07:55:58 <norpan> cvs parser?
07:56:57 <shapr> I built a web survey in Zope, client wanted to import the data into ms excel
07:57:37 <norpan> ah, you _meant_ csv :)
07:58:10 <shapr> this is a very cool survey actually...
07:58:37 <shapr> students in .eu fill in their thoughts and ideas for improving schools
07:58:51 <shapr> so that they could learn more, have a more positive experience, etc
07:58:57 <Heffalump> how would you write out an .xls file, though?
07:59:05 <shapr> Heffalump: with ms excel =)
07:59:13 <shapr> I just want to process the data into gnumeric for testing
07:59:13 <Heffalump> YM use haskell to script Excel?
07:59:27 <delYsid> Use Spreadsheet::ExcelWriter
07:59:28 <delYsid> (perl)
07:59:42 <delYsid> or write out a .csv
07:59:58 <shapr> nah, just write something that understands the ms excel non-standard way of escaping chars like ^M, "
08:00:02 <shapr> that kind of thing
08:00:27 <Heffalump> delysid: that's all very well, but from Haskell...
08:00:30 <shapr> the number one comment I've seen going through this .csv file is "give us more computers and better 'net access"
08:00:31 <Heffalump> ah, ok
08:00:48 <Heffalump> kids at school + computers is generally a mess, IME
08:00:50 <shapr> one person says they have five computers for 450 students
08:01:17 <shapr> another person says they can find more and better research on the 'net, so they'd like to have better access.
08:01:19 <shapr> interesting stuff
08:01:22 <Heffalump> s/computers/PCs/ - it was good with BBCs.
08:01:23 <delYsid> well, I wouldnt have been able to do school at all without a comp. so it cant be that bad :)
08:01:36 <Heffalump> :-)
08:01:48 <Heffalump> computers are good for some things
08:03:04 <shapr> I tried to learn programming in high school, but it was extremely difficult on DOS, and with no 'net access
08:03:17 <shapr> no compiler, no documentation...
08:03:21 <delYsid> bah, DOS had qbasic.exe
08:03:26 <delYsid> I learned programming that way
08:03:29 <shapr> I seriously thought everybody wrote their programs in assembly with debug.com
08:03:47 <delYsid> qbaisc.exe had a nice help-system
08:04:12 <shapr> quick-basic was a commercial app
08:04:15 <Heffalump> everyone should learn that way :-)
08:04:18 <Heffalump> (or with Haskell, of course)
08:04:23 <Heffalump> qbasic wasn't
08:04:28 <Heffalump> qbasic came free with DOS
08:04:33 <shapr> I only had gwbasic
08:04:36 <delYsid> shapr: qbasic cam with 5.0
08:04:42 <delYsid> It was standard, included by default
08:04:44 <shapr> I didn't have it :-/
08:05:05 <shapr> my computer wasn't very standard though...
08:05:13 <shapr> just scrounged bits
08:05:14 <Heffalump> it all depended on DOS versions
08:05:23 <shapr> yah, PC-DOS vs MS-DOS
08:05:31 * delYsid installs gcc-3.2
08:05:37 <cleverdra> shapr - back when I was in the sixth grade or so, and playing Ultima5 most of the time, I started to (mentally) compose a letter to Origin in which I praised them for their programming skills &c spoke of how difficult it must've been to program every single possible combination of tiles =)
08:05:44 * shapr grins
08:06:40 <shapr> I've noticed that huge chunks of the java sdk could be refactored out
08:06:54 <shapr> I've also noticed that about the various emacs libs
08:07:17 <delYsid> sure
08:07:26 <cleverdra> shapr - like all the common-lisp stuff; you'd think that someone would make a module for that.
08:07:26 <delYsid> duplication is everywhere!
08:07:27 <shapr> seems to me the open source movement needs at least one or two "refactor masters"
08:07:58 <delYsid> bah
08:08:04 <shapr> you'd need a generic refactoring tool first...
08:08:11 <delYsid> What open source needs are people who do things, and not just talk about them
08:08:16 <shapr> heh, that's true
08:08:17 <Heffalump> yeah.
08:08:28 <delYsid> and you dont need any tool first
08:08:37 <delYsid> if you're good enough, you do it in an editor
08:08:43 <delYsid> like everyone else did the last 30 years
08:09:01 <Heffalump> a tool would make it faster and more practical
08:09:16 * cleverdra doesn't think that such as Emacs and JDK can really be refactored with a tool, though a tool might help direct the design.
08:10:07 <Heffalump> you use a tool to help, not to do all the work
08:10:58 <cleverdra> information tools are the most beneficial, no?  Where is this function, what calls it, how is it called (what constant data is it called with), where are bodies of code similar to its body, where are similarly-named functions; show me a tree of how control-flow can get from function A to this function.
08:11:30 <Heffalump> yeah
08:11:30 <shapr> lxr can do that for C
08:11:37 <Heffalump> but also "rename this method/variable"
08:11:52 <shapr> "extract method" is the hard one
08:11:54 <Heffalump> "turn calls of this method into this code"
08:11:56 <Heffalump> shapr: yeah
08:12:07 <Heffalump> one of our PhD students is working on Java refactoring
08:12:24 <cleverdra> Heffalump - indeed; that, when necessary, must be the most tedious and boring (and hence dangerous) kind of 'refactoring'
08:12:28 <shapr> I started a Python refactoring browser project once.
08:12:49 <shapr> cleverdra: an RB can do that for you, quite simple
08:12:55 <cleverdra> RB?
08:12:55 <shapr> er, 'simply'
08:12:59 <shapr> refactoring browser
08:13:15 <cleverdra> Err, oh.  /me seeks information.
08:13:18 <shapr> rename method/class/etc is really simple
08:13:25 <shapr> you just operate on the abstract syntax tree
08:13:37 <shapr> you need to be able to do source -> AST -> source
08:13:48 <norpan> i'd like an integrated haskell editor in which I can select names of the right type from a menu and so on
08:13:58 <shapr> names of right type? huh?
08:14:02 <norpan> like the chalmers alfa system
08:14:23 <Igloo> shapr: And not lose comments and whitespace along the way
08:14:31 <norpan> shapr: yes, like, here is a function of type a, then i can select among functions returning a
08:14:41 <shapr> Igloo: yah, that's one of the important bits
08:15:07 <cleverdra> Perhaps there should be a formal language (that is, with a formal grammar, syntax, semantics) for comments, or at least some comments.
08:15:18 <shapr> once you have a comment ast node, then it's pretty much a search and replace regular expression engine that operates on a tree of nodes.
08:15:23 <cleverdra> Then your RB can also change the names of a function in comments =)
08:15:40 <Igloo> clev: The problem is comments can be really all over the place
08:15:41 <tmoertel> you guys should check out Strafunski http://www.cs.vu.nl/Strafunski/
08:15:58 <shapr> tmoertel: iirc, Strafunski is used in the MetaEnvironment
08:15:59 <tmoertel> it was build for these kinds of xformations
08:16:17 <cleverdra> Igloo - they needn't be.
08:16:26 <shapr> the greatest concentration of information on this is at http://www.program-transformation.org/
08:16:31 <Igloo> e.g. in Haskell when you want to replace (+) with my_function you have to also do something with ( {- hello world -} + \n -- wibble\n )
08:16:49 <shapr> the MetaEnvironment is slowly being turned into debian packages
08:16:56 <cleverdra> hm.
08:17:15 <Igloo> And even ignoring the problem of what to do if you are replacing that you need to be able to rememer all the information for when it isn't actually touched
08:17:18 <shapr> I like the idea of an editor that operates on abstract syntax trees rather than source text
08:17:35 <norpan> shapr: yes, database instead of plain text
08:17:51 <shapr> that way an editor script can be polymorphic across languages, as long as the AST format is the same.
08:17:59 <Heffalump> shapr: what about scope rules?
08:18:18 <shapr> good question
08:18:47 <Heffalump> renaming stuff was one of the things IP did really well, cos it had this underlying "unique name" for every variable/method
08:19:10 <Heffalump> so you always knew what referred to a particular declaration
08:19:13 <shapr> well, IP takes a slightly different path...
08:19:15 <Heffalump> well, it always stored programs as ASTs
08:19:24 <shapr> right
08:19:24 <shapr> which is a very cool idea
08:20:38 <shapr> and the stored programs work unlike anything else...
08:24:13 --- mode: card.freenode.net set +ooo Chilli ChanServ Heffalump
08:30:56 <olczyk> Can someone help with an error that I am not sure is haskells?
08:30:58 <Heffalump> sure
08:31:33 <olczyk> When I try to make a project I keep getting an error message error in /usr/bin/ld -lreadline not found.
08:32:00 <Heffalump> do you have /usr/lib/libreadline.{something} ?
08:32:23 <olczyk> Checking /lib I find /lib/libreadline.so.4, /lib/libreadline.so.4.1
08:32:42 <olczyk> Checking /usr/lib I find /lib/libreadline.so.4, /lib/libreadline.so.4.2.
08:32:45 <cleverdra> olczyk - ldd the program in question
08:32:58 <cleverdra> olczyk - check 'ldconfig -p|egrep readline'
08:33:05 <Erwin> do you have a libreadline.so ?
08:33:12 <Erwin> You may need to install libreadline-dev if you are on Debian
08:33:17 <cleverdra> olczyk - also, what Erwin said.  You may need to create a symlink.
08:33:31 <Erwin> On Debian, the .so file is in the -dev package
08:33:55 <cleverdra> Erwin - the '.so file' would be identical to those =)  Perhaps the -dev package just creates the symlink.
08:33:56 <olczyk> I can't ldd I don't have a program.
08:34:09 <cleverdra> olczyk - if you don't have a program then you don't have an error because there is nothing to complain.
08:34:27 <cleverdra> olczyk - well, a config script might, sorry.
08:34:36 <cleverdra> And I see that you're talking about 'ld', sorry =)
08:34:41 <olczyk> Mandrake
08:35:08 <olczyk> I'm running a "make".
08:35:16 <cleverdra> olczyk - check 'ldconfig -p|egrep readline', as I said.  Make a symlink from one of those readlines to /lib/libreadline.so and call 'ldconfig'
08:36:02 <tmoertel> olczyk: when you do an "rpm -qa | grep readline" do you get both readline and readline-devel ?
08:40:10 * cleverdra assumes that olczyk just forgot to say 'thank you'.
08:40:54 * olczyk didn't find realine-devel. Was just off searching for the rpm.
08:42:02 <cleverdra> foolishness.  OK.
08:42:20 * shapr bounces happily
08:42:28 <shapr> yay, new nvidia drivers released
08:42:32 <cleverdra> (well, only wrt to the libraries; -devel probably has headers)
08:42:32 <shapr> I hope these are happier with SMP
08:45:20 * tmoertel notes that "rpm -ql readline-devel" includes /usr/lib/libreadline.so
08:45:32 <Heffalump> you need /usr/lib/libreadline.a to compile against it IIRC
08:45:59 <tmoertel> that, too, is part of readline-devel
08:46:56 <Heffalump> oh, readline-devel
08:46:58 <Heffalump> precisely
08:47:11 <Heffalump> readline just has the library to run with, i.e. .so.5.2 or whatever
08:52:39 <tmoertel> have you guys seen the web-based visualizations at http://tea.moertel.com/~thor/ravt/examples/WEB-VISUALIZATIONS/ ?
08:52:52 <shapr> I haven't
08:52:53 * shapr looks
08:52:58 <tmoertel> postman does well. it seems that many of the otherwise strong contenders have fatal flaws
08:53:16 <shapr> hm, cool
08:54:06 <shapr> these visualizations are coool
08:54:14 <tmoertel> tycon mismatch and radical too's bots kill themselves (murder-suicide style) when they can push another bot into water and their is more water beyond
08:54:23 <tmoertel> s/their/there/
08:54:45 <shapr> suckage
08:54:51 <shapr> the backoff mode works well
08:55:36 <tmoertel> tomas rokicki (of team radical too) wrote the javascript-based visualizer for RAVT (it's the first non-haskell tool and uses the new DumpGameAnalysis stream)
08:56:52 <tmoertel> postman does well against all 'bots except skipperdee
08:57:02 * olczyk got dropped.
08:57:15 <Heffalump> as a baby?
08:57:30 * tmoertel chuckles
08:58:06 * olczyk slaps Heffalump around a bit with a large trout
08:58:20 <shapr> that's awesome...
08:58:31 <shapr> I'm thrilled that Postman does so well
08:58:52 <Heffalump> it kind of depends what maps the judges use, though
08:59:02 <tmoertel> postman doesn't seem to have any fatal flaws, but many other bots do
08:59:20 <shapr> Heffalump and Igloo wrote the code really quickly...
08:59:26 <shapr> I did lots of testing =)
08:59:33 <shapr> so did other people.
08:59:49 <shapr> pesco and loom2 get code credit too
09:00:03 <Heffalump> I'm annoyed cos with better planning we could have done much better, so if we're doing ok then we could have been real contenders.
09:00:09 <tmoertel> that many other strong contenders have murder-suicide high in their strategy lists may fare wall for postman in multi-bot competition
09:00:28 <tmoertel> s/other/otherwise/
09:00:48 <shapr> I think Postman is best at delivering packages and not trying to be too fancy
09:01:07 <shapr> admittedly, if we'd had better planning we could have been fancy, but it seems that fancy can causes flaws.
09:01:24 <cleverdra> What is the reasoning behind murder-suicide?
09:01:41 <tmoertel> the m-s problem is subtle: when an m-s bot can push another bot into the water it does; however the m-s bot fails to realize on the following turn that the pushed robot is now dead (and lying in h2o)
09:01:52 <tmoertel> that's where it gets nasty
09:02:03 <shapr> Heffalump: we could still be one of the top three, since it's total games won that matters.
09:02:29 <tmoertel> the m-s bot notices that there is water *beyond* the now-dead bot and tries to push it *again*, stepping into water itself.
09:02:33 <Heffalump> no, it's total packages delivered
09:02:45 <shapr> Heffalump: you've got to admit this is an amazing entry for a team that hasn't done this before :-)
09:02:48 <tmoertel> actually, it's total weight of packages
09:02:53 <Heffalump> yes, sorry
09:03:14 <shapr> well, Postman is prioritized according to total package weight anyway.
09:03:31 <shapr> iirc, the strategy was "pick up as many as you can, and deliver heaviest first"
09:03:47 <Heffalump> it should have grouped the ones it picked up by destination
09:03:48 <shapr> Heffalump: how can we do better next year? what can we improve?
09:03:55 <shapr> that's true, that would have been better.
09:03:55 <Heffalump> I'm really annoyed I didn't notice that detail :-)
09:03:56 <cleverdra> tmoertel - I see... but why does it notice water beyond the bot over water at the bot?
09:04:02 <shapr> a metric of weight + distance
09:04:15 <cleverdra> (it has no memory, and can no longer sense water at that spot?)
09:04:16 <shapr> or, weight - distance
09:05:08 <shapr> Heffalump: it seems we would place third according to the visualizations.
09:05:20 <Heffalump> shapr: only on the bots tmoertel has seen
09:05:24 <shapr> that's true.
09:05:27 <tmoertel> cleverdra: no, it's a bug in the search tree implementation. m-s bots fail to realize that they can kill another bot and themselves in the same move
09:05:48 <tmoertel> cleverdra: they see a kill opportinity and take it, not considering that they may themselves die
09:06:35 <shapr> my goal for my first team entry was to just submit a working entry, no matter how stupid =)
09:06:47 <shapr> hi Arnia
09:06:52 <Arnia> Hi
09:06:59 <shapr> looking to learn Haskell?
09:07:08 <cleverdra> tmoertel - ah, now that you describe it as a 'bug' instead of a 'strategy', it's very clear.
09:07:32 <shapr> Arnia: maybe you're an experienced Haskeller looking for people to help?
09:07:59 <cleverdra> <Arnia> um, yes.  Is this channel for Hask L egg-beaters?
09:08:08 <Arnia> *grins* I'm a perpetual learner and novice... I'd never consider myself finished
09:08:30 * shapr blinks
09:08:38 <Arnia> And I'm looking to learn a language that allows elegent and algebraic descriptions of computation ;-)
09:08:47 <shapr> well then, I think you're in the right place.
09:09:06 <cleverdra> Indeed.
09:09:40 <cleverdra> shapr - I stretched; I think the 'egg-beater' comes from 'husks' of corn, which was enough to draw me to food-products while searching for a name-mangling.
09:09:41 <shapr> That sounds like a short description of Haskell.
09:10:08 <shapr> interesting
09:10:30 <olczyk> readline-devel helpd. had to download ncurses-devel too.Thanks.
09:10:41 <Arnia> I have a feeling that I'm going to be one of the only people in my year at uni (term starting on Oct 2nd) to actually like it though... *sighs* pity
09:10:50 <Heffalump> which uni?
09:11:25 <Arnia> Durham
09:12:13 <Heffalump> usually some people in each year like Haskell when taught it (though lots hate it)
09:12:23 <Heffalump> (from my experience here, anyway)
09:12:58 <shapr> that's surprising... I'd think CS majors would be fascinated by Haskell.
09:13:15 <Arnia> Yes... well, we get 'softened up' by Z in our first year... taught FP (using Haskell) in our second and then only a handful continue it in our third and final
09:13:21 <shapr> of course, I've never been exposed to a CS program...
09:13:25 <Heffalump> a lot of CS majors just see a CS degree as something they have to do to work with computers
09:13:25 <cleverdra> What languages are CS majors fascinated by, if not Haskell?
09:13:27 <shapr> what's Z?
09:13:33 <Heffalump> a specification language
09:13:35 <shapr> Heffalump: whoa extreme suckage
09:13:52 <Heffalump> (where CS majors = CS students here, the UK not having a concept of "majors")
09:13:55 <shapr> what a terrible way to enter the CS program
09:14:01 <Heffalump> I might be exaggerating the number of people who are like that
09:14:13 <Arnia> No... you're not. Most Compsci students are doing it to become rich coders
09:14:26 <shapr> good programmers get paid well
09:14:34 <cleverdra> Arnia - do they speak of wanting to emulate Bill Gates?
09:14:36 <shapr> avarice does not usually make for good programmers
09:14:39 <Heffalump> I'm a good programmer and I don't get paid (that) well :-)
09:15:03 <shapr> I'm a good programmer, and I my hourly rate is pretty small.
09:15:07 <Arnia> They're not good coders
09:15:07 <Arnia> I'm odd in that I'm a computer scientist... coding is something else, I prefer the theory and Haskell is close enough to the theory to make me fall for it ;-)
09:15:09 <shapr> but, I sure do get a lot of hours..
09:16:38 <Arnia> *grins* and the number of people who insist that C is a 'functional' programming language...
09:16:48 * cleverdra ascertains that his initial comment was rude an offensive; leaves.
09:16:59 <Heffalump> arnia: you should have come here :-) (Oxford)
09:17:04 <shapr> cleverdra: what?
09:17:26 <shapr> cleverdra: isn't your dad a major Perl hacker?
09:17:32 <Arnia> Hah... I live too close to Oxford (I come from High Wycombe) and I didn't like the atmosphere.
09:17:37 <Heffalump> ah :-)
09:17:54 <Arnia> Given that Oxford is a local town, it would have felt odd
09:17:59 <Heffalump> don't suppose you know a guy called Dan Kolb? (random High Wycombe person I know)
09:18:01 <shapr> my experience with programmers from Oxford (Heffalump, Igloo) has been positive so far.
09:18:57 <Arnia> Heffalump: No, sorry... Wycombe is fairly large
09:18:58 <Arnia> I like it in Durham... beautiful city (little traffic ;-))
09:19:10 <Heffalump> arnia: it was just a random thought, since he does computery stuff :-)
09:19:24 <Heffalump> Oxford has too much traffic. Far too many buses.
09:19:55 <Arnia> Yes... *has bad memories of busses nearly squashing him near the indoor market*
09:20:21 <Arnia> Oh... and near Waterstones...
09:20:30 <Arnia> In fact just about everywhere in Oxford :)
09:20:34 <Heffalump> :-)
09:21:24 <Arnia> *wonders what being lectured by Paul Callaghan will be like*
09:22:18 <Arnia> I'm jealous of a friend of mine in third year at Nottingham who has Graham Hutton as his supervisor on a parsing project
09:24:06 <Heffalump> heh
09:24:24 <Arnia> Anyway, what areas of Haskell are you interested in?
09:24:38 <Heffalump> all of us, or me in particular?
09:24:46 <Arnia> You in particular
09:24:50 <Heffalump> hmm
09:24:54 <Heffalump> using it for stuff :-)
09:25:03 <Heffalump> and transforming it
09:25:16 <Arnia> What sort of stuff and what do you mean by transforming it?
09:26:02 <Heffalump> the only big thing I've written in Haskell is a tool to transform programs written in a subset of Haskell
09:26:14 <Heffalump> by transform I essentially mean apply optimisations to
09:27:30 <cleverdra> shapr - yes, my dad is a Perl hacker, though not major in the sense that he's well-known in the Perl community.
09:27:47 <Arnia> Ah :)
09:27:48 <Arnia> I like the way that it neatly matches the way I view computations in the brain
09:31:47 <shapr> I'd like to hook up with the FP-Refactor guys
09:32:29 <Heffalump> at Kent?
09:32:38 <shapr> I think that's them.
09:34:45 <cleverdra> shapr - erm, why did you ask?
09:34:54 <olczyk> Is there a way to start ghc interpreter as an inferior mode in emacs?
09:38:16 <shapr> olczyk: M-x turn-on-haskell-ghci and then C-c C-l in your haskell source buffer.
09:38:40 <shapr> cleverdra: sadly, I don't remember why I asked.
09:38:45 * Arnia wonders at the power of Emacs again
10:02:59 <BlizzNL> I am trying to write a treemap function. I did, but the results are unexpected:
10:03:02 <BlizzNL> leaftree_map f = leafTree_cata ((\x -> Leaf (f x)), (\l r -> Split (leaftreemap f l) (leaftreemap f r)) )
10:03:25 <Heffalump> what is your type of trees?
10:03:43 <BlizzNL> data LeafTree a = Leaf a | Split (LeafTree a) (LeafTree a)
10:03:44 <Heffalump> data Tree a = Leaf a | Split (Tree a) (Tree a) ?
10:03:46 <Heffalump> ok.
10:04:11 <Heffalump> that looks correct to me
10:04:13 <Heffalump> what happens?
10:05:47 <BlizzNL> Well it returns a strange tree. I wrote a function which prints the tree:  printtree (leaftree_map (+2) (Split (Leaf 2) (Split (Leaf 3) (Leaf 1))) )
10:06:08 <Heffalump> oh, hangon
10:06:10 <BlizzNL> results in [6, 9, 7]
10:06:16 <Heffalump> you shouldn't make recursive calls to leaftreemap
10:06:19 <Heffalump> leafTree_cata does that for you
10:06:30 <Heffalump> so you should just have \l r -> Split l r
10:06:34 <Heffalump> or indeed just "Split"
10:06:43 <Heffalump> as the second element of that tuple
10:07:24 <BlizzNL> yep you are right (as always) thnx
10:29:57 <BlizzNL> strange connection losts
10:49:14 <BlizzNL> is everybody enjoying the silence or something ? ;)
10:49:34 <andersca> yes
10:50:31 <shapr> I'm writing for-pay Python at the moment
10:50:38 <andersca> nice
10:50:39 <andersca> python rocks
10:50:58 <shapr> ZCatalog is being pissy
10:51:19 <BlizzNL> I wrote for-pay MS ASP for 4 months ; that's torture :-)
10:51:42 <shapr> you could have used HaskellScript
10:51:48 <shapr> that would have made life much more fun
10:51:58 <shapr> especially for those who would later maintain that code.
10:52:15 <BlizzNL> shapr: Yes indeed :)
10:53:11 * Arnia is being expectant for plone
10:53:33 <shapr> plone is impressive, but it's not haskell ;-)
10:53:57 <shapr> I'd very much like to use Haskell in my for-pay Zope tasks, not sure how I could.
10:54:16 <Arnia> No... but I've been doing some graphical design for plone
10:54:30 <Arnia> Hmm... is there a python binding for haskell?
10:55:12 <shapr> not that I know of
10:55:25 <redcrosse> ever looked at this: http://epolyglot.sourceforge.net/epolyglot/book1.html
10:55:28 <shapr> I spent some time on TwistedHaskell, but I haven't had time to work on it the last few weeks.
10:55:29 <redcrosse> kinda interesting
10:55:52 <redcrosse> of course it's got eiffel in the middle
10:59:44 <Arnia> Hmm... I don't think Haskell could be used with Zope anyway... Zope is intensely OO and relies on a lot of state to work... it would be quite a task to embed a HaskellScript parser into the middle of the ZODB
11:00:02 <shapr> hmmm
11:00:16 <shapr> I think they would be powerful partners.
11:01:21 <Arnia> They would... but only if you can get them to work...
11:01:22 <Arnia> What you'd need is, perhaps, something like the Haskell CGI system as a binder... however the question is, how do you then access the ZODB and make sense of it in Haskell?
11:09:34 <shapr> I was thinking of something like "import haskell" in Python
11:09:52 <shapr> and then having haskell.toplevelmodule.functioname
11:10:07 <shapr> for example, haskell.Prelude.break
11:11:03 <Arnia> And the results get returned as HsData or similar?
11:11:41 <Arnia> Its possible I guess... just a matter of formally defining it and writing the C code for it (Python is very flexible on that front)
11:11:44 <shapr> yup
11:12:05 <shapr> I've heard that the FFI in GHC isn't totally scary.
11:12:11 <shapr> so it's possible.
11:12:13 <ibid> http://www.mit.jyu.fi/antkaij/tmp/pohja/VM.hs - something wacky ;-)
11:12:17 <ibid> argh
11:12:21 <ibid> http://www.mit.jyu.fi/antkaij/tmp/pohja/ - something wacky ;-)
11:12:29 <shapr> the idea of writing Python C extensions in Haskell is.... unusual.
11:12:54 <Arnia> Quite powerful though...
11:12:57 <shapr> ibid: cool
11:13:12 <shapr> Arnia: might be insanely scary, might be simple, I have no idea.
11:13:46 <shapr> would surely be 100% cool
11:13:51 <ibid> shapr: i intend to throw that (and something i have yet to write) to my students who have never seen haskell code :-)
11:14:16 <Arnia> FFI isn't my area... something to think about though. May do it for my 3rd year project though ;-)
11:14:19 <shapr> ibid: I think international treaties forbid that kind of torture.
11:14:31 <ibid> shapr: oh? :-)
11:14:39 * shapr grins
11:14:40 <ibid> shapr: can you make out what that is
11:14:45 <shapr> sure
11:14:58 <shapr> and I've been learning Haskell for almost exactly one year now.
11:15:07 <ibid> so what is it? :-)
11:15:18 <shapr> it's a stack based virtual machine
11:15:25 <ibid> riight
11:15:57 <ibid> continuation-based (at least in a primitive sense) i might add
11:16:05 <shapr> ibid: I wouldn't have know that except that, a) I love playing with Joy and b) I've seen other VMs in Haskell
11:16:22 * ibid has never seen a VM written in haskell
11:16:43 <ibid> what's Joy (besides that cool guy in debian)
11:16:58 <shapr> Joy is a stack based concatenative functional programming language
11:17:04 <ibid> right
11:17:09 <Arnia> Continuation parsing still has the capacity to blow my brain on occasions... especially the scheme used in Fudgets
11:17:54 <shapr> ibid: I wrote an approxEqual in Joy recently:
11:17:56 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
11:18:45 <shapr> I'd like to write a Joy VM in Haskell
11:18:52 <shapr> it's harder than it looks though.
11:18:55 <ibid> the idea is to give the students that and a very simple compiler targeting that for a very stupid language
11:19:00 <shapr> ohh
11:19:05 <ibid> their task: to understand the code and improve it :-)
11:19:13 <shapr> oh that sounds like fun
11:19:13 <ibid> (especially the language)
11:19:41 * Arnia feels very sorry for the students
11:19:45 <ibid> most of them have never seen anything else besides the standard imperative languages
11:19:58 <ibid> Arnia: :-)
11:20:17 <ibid> i intend to add lots of comments to the code though
11:20:38 <Arnia> I've got the pleasure of 'learning' haskell next year...
11:20:47 <shapr> Arnia: it's a gorgeous language.
11:21:15 <Arnia> Yes, I know... its the fact that I know it well enough to answer the exam paper that makes learning it a bit tricky
11:21:29 <ibid> so take the exam and be done with it
11:21:31 <Arnia> I'm going to the lectures cos they look cool
11:21:54 <Arnia> I can only take the exam at the end of the year
11:21:59 <shapr> suckage
11:22:00 <ibid> that's stupid
11:22:04 <shapr> broken educational system
11:22:14 <shapr> ibid put that far more succintly than I did :-)
11:22:18 <ibid> we allow people to take exams several times in a term
11:22:19 <Arnia> No... cos the practicals count as well, as does ill health
11:22:36 <shapr> I still side with ibid
11:22:40 <Arnia> The UK education system doesn't use credits... and you have little choice
11:22:44 <ibid> actually there are exam days about twice a month, but the list of courses you can take an exam on varies
11:22:55 <ibid> so come to finland :-)
11:23:01 <shapr> yah, come to europe
11:23:06 <Arnia> Nah, I like our system
11:23:07 <shapr> ;)
11:23:27 <Arnia> Means I actually have to work cos I only get one shot at it...
11:23:49 <ibid> well, i know a guy here who got his masters in three years
11:23:54 <shapr> cool
11:24:03 <shapr> I hope they do that in sweden also
11:24:09 <shapr> ibid: do you know if they do?
11:24:22 <ibid> do what?
11:24:26 <shapr> I could probably get an undergrad CS degree in a year that way.
11:24:39 <Arnia> I'd feel a bit dubious about the quality of the degree though...
11:24:51 <shapr> ibid: allow students to "test out" of classes
11:24:58 <shapr> Arnia: education is what you get out it yourself
11:25:01 <Arnia> Knowledge gained that quickly rarely sticks
11:25:32 <shapr> education makes it easier for you to learn, whether you actually do learn is your choice.
11:25:40 <ibid> well, he is a grad student with published refereed papers
11:25:55 <ibid> shapr: i would expect them to but i don't know
11:26:07 <shapr> I'll ask about that option, thanks for mentioning it.
11:26:23 <shapr> I'd like to have a degree, that could be a quick way of getting one.
11:26:54 <Arnia> In which case he's an exception... but its similar to cramming, its better to have the work spread out a bit and recapped through the year.
11:26:54 <Arnia> My undergrad degree is 3 years anyway... a masters is just a year on top of that
11:27:28 <shapr> in my experience, people can learn stuff for the test, or because they want to know it...
11:27:31 <ibid> shapr: of course, many courses include practical work, but often you can do them fast, too
11:27:40 <shapr> if you're learning for the test, it probably won't stick
11:27:48 <ibid> Arnia: i never intended to give the idea that he was not exceptional
11:28:02 <ibid> Arnia: the typical graduation time (masters) here is five years
11:28:50 <Arnia> Ah... all I know is that I finish each term mentally exhausted, but then Durham like to try and kill you with work :)
11:29:36 <ibid> Arnia: my masters degree is missing the thesis (which is mostly written). i now started my sixth year
11:29:45 <ibid> (i started the same year as that guy)
11:29:55 <shapr> ibid: we know you're just staying in school for the women ;-)
11:30:29 <ibid> shapr: nah, i'm a member of the staff there, so no problem with that even if i graduate :-)
11:30:33 <ibid> shapr: besides, what women :-)
11:30:38 <Arnia> Ah... our masters are generally not taught. They're research masters (unless you're crossing from another subject)
11:31:27 <shapr> ibid: jyvaskyla isn't covered in gorgeous young female students?
11:31:58 <ibid> Arnia: essentially, our masters reguire advanced studies in major subject and either subject studies in one minor subject or basic studies in two + enough credits
11:32:22 <ibid> Arnia: our BSc is essentially that except that you need to have only subject studies in your major
11:32:36 <ibid> shapr: not the it depts :-)
11:32:57 <ibid> shapr: there are lots of women in the liberal arts and edu depts
11:33:05 <Arnia> Ibid: We don't have the concepts of major and minor subjects
11:33:21 <shapr> maybe IT can be declared a liberal art?
11:33:47 <ibid> shapr: but those lie several hundred meters higher than the it depts (geographically)
11:33:51 <ibid> Arnia: no?
11:34:26 <shapr> ibid: you should try to get your office in the liberal arts building.
11:34:32 <ibid> Arnia: here, you apply for a right to study a certain major. you have pretty much freedom in choosing your minors (but often some of them are mandated)
11:34:35 <ibid> shapr: heh
11:35:14 <ibid> shapr: too far away from the auditoria :-)
11:35:16 <ibid> Arnia: for example, in my major subject (it), you have to have at least extended basic studies in math
11:36:03 <Arnia> ibid: that level of specialisation is done at our A Levels (16 to 18)... at bachelors level we have a course in a subject and we follow that course through for three years (although we get some choice in the modules we choose, we generally stick to a set course)
11:36:28 <Arnia> ibid: well... HNDs more... we specialise earlier
11:36:35 <ibid> HNDs?
11:37:09 <ibid> my minors are math (subject studies) and philosophy (basic studies)
11:37:14 <Arnia> ibid: Higher National Diplomas... sort of a vocational degree you can take if you don't want a full degree...
11:38:43 <ibid> oh, in case this confusess you: basic studies are 15 credits, subject studies 20 credits on top of that (often including a small thesis), advanced studies 35 credits on top of that (including a bigger thesis)
11:38:54 <Arnia> ibid: I'm currently on an Artificial Intelligence course...in my first year I had four determined modules (Formal Aspects, Computer Systems, Programming and Data Structures [Double]) and two electives I chose (Cognitive Psychology and Biological Psychology)
11:39:08 <ibid> a credit unit is supposedly equivalent to approximately 40 hours of active study time for the student
11:39:35 <ibid> masters is 160, bachelors is 120
11:40:09 <Arnia> This year I have no electives and my course consists of Logic Grammar and Software Tools, Software Applications Computer Systems II, Intro to Functional Programming and AI and Software Engineering [double]
11:40:24 <Arnia> Last year didn't count... this year does
11:40:39 <ibid> ok, i took...
11:40:47 <ibid> (i was originally a maths major)
11:41:46 <ibid> analysis 10 cu, linear algebra 5 cu, formal logic 2 cu, euclidean spaces 3 cu, english 1 cu (first year)
11:42:25 <Arnia> You chose linear algebra? :) Always bored me to tears... :)
11:43:31 <ibid> second year: programming 1 (4 cu), algorithms and data structures 2 (2 cu), programming 2 (5 cu), fundamentals of it (3 cu)
11:43:35 <ibid> Arnia: it was mandatory
11:44:03 <Arnia> ibid: bad luck :(
11:44:16 <ibid> oh yes, algebra (4 cu) in the first year too
11:45:08 <Arnia> Sounds fun :)
11:47:19 <ibid> third year: differential calculus in multiple dims (5 cu), discrete math (3 cu), microcomputer hardware (3 cu), data structures and algorithms 1 (3 cu), automata and formal languages (3 cu), seminar on programming languages (2 cu), principles of operating systems (2 cu)
11:47:50 <ibid> fourth year: officially switched majors to it
11:48:09 <Arnia> Ah :)
11:51:42 <ibid> fourth year: programming exercise and apprenticeship (15 cu) (given for my debian work and such:-), mandatory swedish (1 cu), introduction to logic (2 cu, philosophy dept), philosophy of sciences (2 cu), ethics (1 cu), databases (2 cu), java programming (2 cu), object-oriented development of information systems (3 cu), introduction to data communications (2 cu)
11:52:04 <ibid> fifth year: in december, graduated to bsc
11:52:38 <ibid> sorry, formal methods (3 cu, later amended to 4 cu) also in fourth year
11:54:33 <Arnia> I'm looking forward to my second year :)
11:54:48 <ibid> fifth year, before bsc: probability (4 cu), book exam on compilers (5 cu), advanced studies seminar (2 cu), maturity test (0 cu)
11:55:04 <ibid> oh, fourth year also included a course on ai (4 cu)
11:56:04 <ibid> fifth year, before bsc: a bsc thesis, naturally
11:58:20 <Arnia> Did you enjoy it all?
11:59:16 <ibid> fifth year, after bsc: introduction to philosophy (1 cu), history of philosophy (2 cu), classic opus in pilosophy (1 cu, i took some plato), social philosopy (1 cu), philosophy of man and culture (1 cu), special area (1 cu, i took political philosophy iirc), theory of knowledge and ontology (2 cu), software production (4 cu), software design tools and methods (2 cu)
11:59:33 <ibid> oh, and second year included  linear analysis (4 cu)
11:59:56 <ibid> and fourth year included a maths course on cryptography 4 cu
12:00:03 <ibid> sorry, linear analysis was 5 cu
12:00:07 <ibid> Arnia: not all of it
12:00:28 <Arnia> Any modules you regret taking?
12:00:55 <ibid> and now, i'm entering my sixth year, i'm teaching principles of programming languages, and taking oo programming as well as measure and integral theory
12:01:03 <ibid> Arnia: those that i regret were mandatory
12:01:20 <ibid> s/regret/look back with pain/
12:02:21 <Arnia> Heh... linear algebra? :)
12:02:22 <ibid> (oh, and i co-taught formal methods last spring)
12:02:29 <ibid> Arnia: no, it was cool
12:02:39 <ibid> Arnia: one of the greatest math courses i've ever taken
12:02:52 <ibid> Arnia: i guess it depends on the instructor :-)
12:03:04 <Arnia> Yeah :)
12:03:34 <ibid> probability was a hard one
12:03:35 <ibid> i hate it
12:03:50 <ibid> it's mandatory and i passed it barely, third time
12:03:55 <Arnia> *thinks statistics should be trampled into the earth*
12:04:01 <ibid> lowest possible passing score
12:04:20 <Arnia> Ah
12:04:55 <ibid> i think i missed theory of algorithms (fifth year before bsc, 3 cu)
12:05:21 <ibid> from the above list
12:05:52 <ibid> i think the coolest way to take a course is to teach it :-)
12:06:06 * ibid is going to get study credit for the popl course /me is teaching
12:06:55 <ibid> anyway, bed time
12:07:00 <Arnia> Bye :)
12:07:57 <ibid> oh, fifth year before bsc included a course on written communication (1 cu)
12:07:59 <ibid> but bye
12:36:02 * shapr bounces
12:40:05 <BlizzNL> aren't there some haskell libs for binary-, avl, fibonacci trees? 
12:40:11 <shapr> I think there are
12:40:19 <shapr> look at the FGL (functional graph library)
12:40:30 <shapr> also check out the Edison package that comes with GHC
12:40:51 <shapr> it was written by Chris Okasaki as some part of his book "Functional Data Structures"
12:40:52 <BlizzNL> shapr: thnx I will, I use Hugs98
13:33:51 * shapr bounces
14:11:29 * shapr wants more details on Pseudonym's three letter TODO codes
15:14:52 * shapr bounces
15:18:30 <olczyk> Quick question. Do any of the haskell systems come with debuggers at least of gdb functionality?
15:18:49 <shapr> you could try Hat
15:18:55 <shapr> it's a Haskell tracer
15:19:00 <shapr> works with GHC and NHC at least
15:19:13 <shapr> I don't know about debuggers, I use unit tests.
15:21:23 <shapr> stupid monad question...
15:21:39 <shapr> what do you do when you have a datatype that's already monadic, such as Gen Int
15:21:54 <shapr> and then you want to stick that into a different monad?
15:22:07 <shapr> I know about using join to turn Gen (Gen a) into Gen a
15:22:16 <shapr> I'm not sure about what to do when you start mixing monads
15:29:24 <tmoertel> shapr: it depends on what you want to do with it
15:30:06 <shapr> I vaguely understand bits and pieces about monads, but I want to understand more.
15:30:24 <tmoertel> john hughes has some great stuff, let me try and point you to it
15:30:41 <shapr> I've read one thing he wrote about Monads
15:30:45 <shapr> maybe I should try it again.
15:31:24 <tmoertel> see http://www.cs.chalmers.se/~augustss/AFP/monads.html
15:32:11 <tmoertel> there was a great set of presentations, still looking for them . . .
15:33:13 * tmoertel found it!
15:33:18 <tmoertel> this stuff is pure gold: http://www.md.chalmers.se/~rjmh/Combinators/
15:33:36 <shapr> thanks :-)
15:39:43 <tmoertel> shapr: more particular to your question: http://www.md.chalmers.se/~rjmh/Combinators/Monads/index.htm
15:42:44 * tmoertel has to run to a meeting . . .
15:43:44 * shapr reads
18:32:54 <Yoso> boo
18:33:18 <shapr> w00
18:33:20 <shapr> heya Yoso!
18:33:30 <shapr> Yoso: have you done Haskell before?
18:33:50 <Yoso> Nope.
18:34:06 <Yoso> Give me some compelling reasons why I should. :)
18:34:11 <Pseudonym> Become one of us... It won't hurt you...
18:34:14 * shapr grins
18:34:21 <Yoso> Pseudonym: What fun is that, then?
18:34:23 <shapr> Yoso: it's purely functional
18:34:30 <shapr> it uses significant whitespace
18:34:39 <Yoso> It's all fun and games until someone loses an eye...then it gets better.
18:34:44 <Pseudonym> It'll make you more attractive to the preferred sex.
18:35:09 <Yoso> That could be dangerous.
18:35:33 <shapr> Yoso: oh, I know one.. Haskell has the most mind bending concept in programming that I've found so far.
18:35:33 <Yoso> shapr: Toss a tutorial link my way.
18:35:46 <shapr> ok...
18:36:03 <Yoso> shapr: As I said earlier, I was in loooove with functional programming in university...but lost it all when I became a corporate whore.
18:36:24 <shapr> Yoso: grab the one on this page: http://www.isi.edu/~hdaume/
18:42:11 <shapr> Yoso: sadly, it's almost 5am here, so I'm gonna fall over unconscious now. think you'll be here tomorrow?
18:45:41 <Yoso> here? as in #haskell?
18:45:52 <Yoso> or here as in irc? :)
18:46:02 <Yoso> tomorrow's saturday, I don't irc in my free time
18:46:27 <shapr> oh
18:46:34 <shapr> tomorrow is friday for me
18:46:35 <shapr> I think
18:46:50 <Yoso> Yes, I am FutureMan
18:47:01 <shapr> :-)
18:47:12 <Yoso> ugh, this tutorial is pdf :P
18:47:14 <shapr> I'm off to greece for a week starting saturday
18:47:23 <Yoso> welcome to the age of html, fool :P
18:47:24 <shapr> Yoso: there's a postscript version
18:47:33 <Yoso> greece? excellent.
18:47:43 <Yoso> shag a earthy greek chick
18:47:53 <Yoso> on the beach, no less
18:47:58 <shapr> Yoso: what about this one: http://www.haskell.org/tutorial/
18:48:05 <shapr> Yoso: nay, I am happily and permanently attached.
18:48:26 <shapr> urf, sleeptime for me.
18:48:33 <Yoso> True, true. Nighty night.
18:49:02 <Pseudonym> Night.
20:02:33 <tmoertel> Yoso: Why use Haskell? One word: foldr.
20:03:05 * tmoertel slaps himself for not noticing that Yoso has left the building
20:06:32 <Jerub> yay for foldr
20:07:03 <Jerub> lambda functions and refferencial integrity are up there for me too
20:15:28 <Heffalump> both foldr and lambda abstraction, or their equivalent, exist in the MLs too, though
20:15:59 <Heffalump> same for referential transparency if you don't have mutable reference cells in the relevant code (and even in Haskell referential transparency isn't absolute)
20:19:36 <Jerub> Heffalump: but you know when you're violating it in haskell, because you've had to write the code to do it.
20:21:52 <Heffalump> I don't mean just unsafePerformIO
20:22:36 <Heffalump> things like the monomorphism restriction screw it up slightly, IIRC
20:22:59 <Jerub> I'm not really that experienced with haskell, so I wouldn't know.
20:24:04 <Jerub> I'm doing the introductory subject at uni atm (even so, I've 100% on all assessment so far, and I'm nearly overtaking the lecturer in posts to the subject newsgroup helping people who're having trouble)
20:25:01 <Heffalump> heh
20:25:06 <Heffalump> what uni?
20:25:16 <Heffalump> (I probably know this, but I've forgotten)
20:25:44 <Jerub> university of queensland, www.uq.edu.au (www.itee.uq.edu.au)
20:26:52 <Heffalump> oh yes, you were saying about being charged to use the labs, I remember now
20:59:27 <Pseudonym> BTW, if you're that far ahead, you might want to see if your uni library has a copy of "The Implementation of Functional Programming Languages" by Simon P-J.
20:59:36 <Pseudonym> et al
21:00:21 <Pseudonym> And the STG paper when you're finished that. :-)
21:16:41 * Jerub makes notes.
21:16:56 <Jerub> where can I find the STG paper?
21:19:29 <jemfinch> what's the STG paper?
21:22:21 <Pseudonym> Spineless Tagless G-Machine
21:22:27 <jemfinch> oh, wow.
21:22:33 * jemfinch won't even ask, he doesn't want to know ;)
21:23:04 <Pseudonym> It's the internal representation used by GHC.
21:23:30 <Pseudonym> http://citeseer.nj.nec.com/jones92implementing.html
21:26:05 <jemfinch> so if I wanted to implement an imperative language interpreter in Haskell, would it likely be easier or harder than implementing it in a more imperative language like SML?
21:26:33 <Pseudonym> That's a good question.
21:26:40 <Pseudonym> Not having tried it in both, I don't know.
21:26:55 <Pseudonym> http://citeseer.nj.nec.com/liang95monad.html
21:27:01 <Pseudonym> That's how you'd do it in Haskell, probably.
21:27:31 <jemfinch> that's an interesting abstract.
21:29:22 <jemfinch> "There are only 10 types of people in the world.  Those who understand binary, and those who don't."
21:31:30 <Pseudonym> :-)
21:31:42 <Jerub> does he reference?
21:31:42 <jemfinch> I found that entertaining.
21:31:54 <jemfinch> Micheal C. Neel is whose signature I've found it in.
21:32:07 <Pseudonym> Jerub: ?
21:32:38 <jemfinch> Pseudonym: this paper looks really interesting.  Of course, all the papers like these start that way, and then go into category theory or lambda calculus and lose me :)
21:33:06 <Pseudonym> Not this one.
21:33:18 <Pseudonym> It helps if you know about monads first, ghough.
21:33:32 <Jerub> Pseudonym: you can't use a phrase like that without referencing the original author, especially if its in the abstract to a paper.
21:34:14 <jemfinch> Pseudonym: I have a..."working" knowledge of them, I think.
21:34:24 <jemfinch> and this paper is certainly interesting enough to learn more about them.
21:34:26 <Pseudonym> Jerub: Sorry, you've lost me.  This is partly because it's Friday afternoon, so I'm a bit slow.
21:36:19 <Pseudonym> Actually, s/partly/mostly
21:38:26 <jemfinch> what's the origin/etymology of the term "monad"?
21:38:57 <Pseudonym> Category theory. :-)
21:39:04 <jemfinch> I mean, what did the word come from?
21:40:25 <Jerub> monadic functions
21:40:27 <Jerub> mathematics.
21:40:30 <Pseudonym> Hang on, I'm looking it up in my Greek lexicon.
21:40:54 <jemfinch> I could look it up in one my three :)
21:41:16 <Pseudonym> :-)
21:41:17 <jemfinch> it doesn't sound Greek to me, though.
21:42:20 <Pseudonym> MONADHN = solitary-wise, only
21:42:24 <Pseudonym> From MONOS.
21:42:35 <jemfinch> which lexicon did you look that up in?
21:42:42 <jemfinch> and is that omicron or omega?
21:42:48 <Pseudonym> LSJ
21:42:52 <jemfinch> which one?
21:42:53 <Pseudonym> It's omicron.
21:43:11 <Pseudonym> THe 1940 edition.
21:43:23 <jemfinch> hmm...my Middle Liddel is in my car.
21:43:30 <jemfinch> it's not in my Little Liddel :)
21:43:47 <jemfinch> ah, but there *is* monadzo
21:43:52 <Pseudonym> Hang on, I'll look it up on Perseus.
21:43:55 <jemfinch> "to be alone, live in solitude"
21:44:09 <jemfinch> so why is that you know so much about Greek?
21:44:32 <jemfinch> s/is/is it/
21:44:32 <Pseudonym> Guess it's a hobby of sorts.
21:44:41 <Pseudonym> Not modern Greek, of course.
21:44:49 <jemfinch> it's my major, though admittedly, I've still got the majority of my courses remaining :)
21:45:00 <Pseudonym> :-)
21:45:15 <Pseudonym> I actually don't know very much.  A little Koine.  That's about all.
21:45:17 <jemfinch> (well, Greek and Latin)
21:45:28 * Pseudonym is a science major, not a classicist
21:45:35 * Jerub is a CS/Maths major
21:45:38 <jemfinch> Koine isn't all that remarkably different than Attic -- it's really just a simple subset.
21:45:42 <Pseudonym> Yes.
21:45:50 <Pseudonym> Emphasis on the "simple". :-)
21:45:51 <jemfinch> simpler, that is...my typing tonight is horrid.
21:46:03 <Jerub> we don't have your liberal arts first/second year thingy either.
21:46:05 <Pseudonym> This is interesting: monadelphia = "posession of only one brother"
21:46:16 <jemfinch> I was surprised how much of the Bible I could read with no specific training in Koine, only with my Attic training.
21:46:30 <Pseudonym> I'm not surprised.
21:46:38 <jemfinch> I was ;)
21:46:43 <Pseudonym> Imagine going the other way, though.
21:46:57 <jemfinch> yeah, I wouldn't want to.
21:46:57 <Pseudonym> Only learning New Testament Greek and trying to read, I dunno, Plutarch or something.
21:47:14 <jemfinch> Koine almost completely lacks the optative.
21:47:22 <Pseudonym> Yes.
21:47:46 <Pseudonym> OK, MIddle Liddell has MONADIKOS: "consisting of units"
21:48:25 <Pseudonym> Or Aristotle uses MONADIKOS ARITHMOS to mean "abstract number".
21:48:34 <Pseudonym> We're getting pretty close here, I think.
21:48:39 <jemfinch> yeah, I think so :)
21:48:59 <jemfinch> well, it *formerly* didn't sound Greek to me :)
21:49:15 <Pseudonym> From MONOS, "a unit".
21:49:33 <jemfinch> or "alone" or "one and only" :)
21:49:37 <Pseudonym> Right.
21:49:58 <Pseudonym> Interesting that also has the mathematical sense of "unit", though.
21:50:50 <jemfinch> so what *is* your major, Pseudonym?
21:51:02 <Pseudonym> CS/Physics/some maths
21:51:06 <Pseudonym> Pretty standard.
21:51:23 <jemfinch> ah, ok.
21:51:41 <Pseudonym> http://www.perseus.tufts.edu/cgi-bin/perscoll?collection=Perseus:collection:PersInfo
21:51:48 <Pseudonym> In case you ever need it.
21:52:10 <jemfinch> I've already got Perseus' Greek and Latin morphological analysis pages bookmarked :)
21:52:14 <Pseudonym> :-)
21:52:22 <Pseudonym> I like the reverse LSJ search.
21:52:29 <jemfinch> what's that do?
21:52:32 <Pseudonym> And the way that the lexica are keyed into the documents.
21:52:38 <jemfinch> yeah, that's useful.
21:52:42 <Pseudonym> Oh, you can look up the English definitions in LSJ and get the Greek entries.
21:53:05 <Pseudonym> It will even suggest words that have similar definitions to the current entry you're looking at.
21:53:06 <jemfinch> that's useful, since there don't seem to be many English->Greek dictionaries out there.
21:53:24 <jemfinch> I'm curious how they do their morphological analysis.
21:53:45 <Pseudonym> For Koine there's an interesting book... hang on.
21:54:02 <Pseudonym> http://www.teknia.com/morphology/
21:54:05 <Pseudonym> That's the one.
21:54:41 <jemfinch> have you used it?
21:54:49 <Pseudonym> Apparently Attic/Koine is much, much more regular than most people realise.
21:54:55 <Pseudonym> I've flipped through it.
21:55:34 <Pseudonym> I'm guessing that you can do a pretty good guess on other dialects, too.
21:55:46 <jemfinch> hmm?
21:55:54 <Pseudonym> Applying similar rules.
21:55:59 <jemfinch> yeah, I would think so.
22:01:21 <Pseudonym> Damn, Perseus is a time sink.
22:01:34 <jemfinch> hehe :)
22:09:33 <jemfinch> ok, when I want to see the Array module's definition, where should I look?
22:11:09 <Pseudonym> Er... what do you mean?  The interface?
22:11:38 <jemfinch> yeah, the interface, but also the implementation, so I can see how it's implemented.
22:16:14 <Pseudonym> You might have to get the source.
22:16:28 <Pseudonym> It's implemented in terms of Foreign.Storable, I'm pretty sure,.
22:17:02 <jemfinch> hmm...is there a link to the interface online?
22:17:16 <Pseudonym> http://haskell.org/ghc/
22:17:38 <Pseudonym> Click on Documentation, then on "base" in the hierarchical Libraries section.
22:17:54 <jemfinch> are there any basic types that aren't members of Eq?
22:18:07 <Pseudonym> Functions.
22:18:11 <Pseudonym> Apart from that, I don't think so.
22:19:18 <sethk> Pseudonym, any opinion on Happy vs. Parsec?
22:19:58 <Pseudonym> Well, Happy is LALR(1) and pre-compiled.  So it has the potential to be more efficient (though I haven't benchmarked it) but less flexible.
22:20:06 <jemfinch> ok, so I can make a list of functions and I can make a list of Ints -- I can compare the list of Ints for equality, but not the list of functions.  How can List both be a member of Eq and not a member of Eq at the same time?
22:20:10 <Pseudonym> Also it requires a lexical analyser, but Parsec doesn't.
22:20:22 <Pseudonym> jemfinch: Yes.
22:20:26 <jemfinch> how?
22:20:39 <Pseudonym> Do you have Hugs handy?
22:20:46 <jemfinch> it's already open :)
22:20:52 <jemfinch> I've tried it, and it works like I expect.
22:20:59 <o3> i like parsec, personally
22:21:03 <jemfinch> but I want to know how [] is both Eq and not Eq, depending on what type it contains.
22:21:12 <jemfinch> because I want my Iterable class to be like that.
22:21:15 <Pseudonym> OK, look for Prelude.hs
22:21:34 <Pseudonym> You will see it says: instance Eq a => Eq [a] where
22:21:37 <sethk> o3: Why?  I'm leaning in that direction as well...
22:21:52 <Pseudonym> That's to be read as "if a is Eq, then [a] is Eq, and here's the detail..."
22:22:30 <Pseudonym> The summary: You can do more with Parsec, but possibly with a run-time cost.
22:22:59 <jemfinch> hmm...I'm not seeing any definitions in ghc-5.04/libraries/base/Prelude.hs
22:23:14 <o3> sethk: i like the design, i like the concept of parser combinations, and it feels very polished/professional
22:23:22 <Pseudonym> jemfinch: That's the GHC version, not the Hugs version. :-)
22:23:28 <Pseudonym> jemfinch: Try PrelList.hs instead.
22:23:59 <jemfinch> I've got the hugs version open :)
22:24:12 <sethk> o3: I've been using parser generators for many years, and at first glance Parsec looks like a major improvement.  If the performance difference is modest, it looks like a very attractive alternative.
22:24:25 <Pseudonym> sethk: That's what I figure, too.
22:24:43 <o3> sethk: well, it looks like the author had speed concerns in mine.  there are benchmarks on the parsec homepage too, if you're really interested
22:24:45 <jemfinch> Pseudonym: it seems that Haskell programmers don't really focus much on type inference.
22:24:47 <o3> s/mine/mind/
22:25:03 <Pseudonym> jemfinch: Yes and no.  Some do, some don't.
22:25:09 <o3> sethk: and yeah, the code just looks so much _cleaner_, because you're writing it directly, rather than going through a parser generator
22:25:28 <sethk> I HATE debugging lex/yacc parsers, and Happy is uses a lex/yacc model, and doesn't even have the #line directive.
22:26:08 <Pseudonym> jemfinch: Theoretically, in the absence of one or two corner cases, Haskell types can be completely inferred.
22:26:16 <o3> there's something very appealing about directly coding the parsing functions, rather than going through generators
22:26:31 <jemfinch> Pseudonym: so (and I'm assuming this, since I'm looking at the definition of Bool right now) a programmer can derive Eq, Ord, Enum, Read, Show, Bounded, and Ix (what's Ix?)?  Are there any other classes that can be derived?
22:26:44 <jemfinch> (and "derived" means "the compiler does the work for you," right?)
22:26:44 <Pseudonym> I think that's all, from memory.
22:26:56 <Pseudonym> Ix is the class of types which make sense as array indices.
22:27:06 <jemfinch> oh, that's really interesting.
22:27:09 <Pseudonym> Right, the compiler does the work for you.
22:27:12 <sethk> I did see the benchmarks on the Parsec web site.  I have a parser that I built today with Happy; I'm building it now with Parsec and I'll do a little benchmarking of my own...
22:27:20 <sethk> But the code is so much cleaner...
22:27:41 <jemfinch> Pseudonym: so I assume that when you derive Ord/Ix/Enum you'll want to make sure youre "data" definitions define things in the right order, right?
22:28:13 <jemfinch> Pseudonym: this Prelude.hs is *really* interesting to read, btw.
22:28:19 <Pseudonym> jemfinch: Yes.  However, sometimes you just want _an_ ordering, not a specific ordering.
22:28:35 <jemfinch> why would that be the case?
22:28:37 <Pseudonym> jemfinch: For example, if you just want to use the type as a key into a binary search tree.
22:28:45 <jemfinch> ooh, that's true.
22:29:32 <Pseudonym> AFK for a moment.
22:31:05 <sethk> O3:  I avoid code generators when possible.
22:31:10 <jemfinch> I'm really rather surprised how easy Haskell is to read now that I understand it.
22:32:04 <o3> sethk: same
22:32:21 <o3> jemfinch: the best thing about haskell is one thing which i find extremely hard (or impossible) to evangelise ...
22:32:34 <o3> jemfinch: you just find that things work the way you intend them to, if the program compiles
22:32:50 <jemfinch> o3: yeah, I learned that about static typing from the MLs.
22:33:14 <o3> it's a very bizarre thing; it's something which gradually dawns on you when you realise that hey, most of the time, things just work if it compiles :)
22:33:35 <jemfinch> I wrote an IRC bot (actually, two) in O'Caml, and that was the coolest feature of it.
22:33:47 <jemfinch> and O'Caml isn't *nearly* as safe as Haskell.
22:34:06 <jemfinch> what's the point of the Bounded class?
22:34:20 <Jerub> I've found haskell to be a wonderful language.
22:34:27 <Jerub> Types are georgeous in haskell.
22:34:34 <Jerub> I wish python's typing was half as good.
22:34:40 <jemfinch> Jerub: I'm really *really* interested in it.
22:34:49 <jemfinch> Jerub: you mean "static"?
22:35:14 <sethk> Python catches errors at run time...
22:35:29 <jemfinch> sethk: yup.
22:35:48 <Jerub> jemfinch: nonono.
22:35:48 <jemfinch> Jerub: Other than the static vs. dynamic issue, I haven't seen any problems with Python's typesystem.
22:35:50 <Jerub> I mean.
22:36:04 <Jerub> qsort :: Ord a => [a] -> a
22:36:16 <Jerub> not static, constrained.
22:36:42 <jemfinch> Jerub: Python's typesystem is constrained, it's just constrained dynamically, at runtime :)
22:36:55 <sethk> I use Python extensively, and for many things it is great, but comparing it to Haskell is really apples and oranges...
22:37:12 <jemfinch> sethk: I think they're a lot closer than, say, Python and O'Caml or SML.
22:37:18 <Jerub> jemfinch: but its no where near as good as haskell's.
22:37:22 <sethk> jemfinch: I can make all sorts of errors in Python that Haskell will block...
22:37:38 <jemfinch> sethk, Jerub: yes, I understand Python's typesystem is dynamic.
22:37:57 <sethk> Not just dynamic, but far less capable of inference and generalization.
22:38:29 <jemfinch> Jerub: Python's typesystem is actually *better* than Haskell's, in that, without *any* declarations, it never prevents a legal operation or allows an illegal operation.
22:38:36 <jemfinch> it's just that's it's dynamic.
22:38:44 <jemfinch> and its dynamicity allows it to do that.
22:38:48 <Jerub> jemfinch: Thats not a good thing.
22:39:02 <jemfinch> Jerub: not necessarily.  It probably depends on your problem domain.
22:39:12 <Jerub> jemfinch: programming good apis.
22:39:21 <jemfinch> hmm?
22:39:34 <o3> jemfinch: GHC has dynamic types, which addresses much of that program
22:39:38 <o3> grr, problem, i mean
22:39:47 <jemfinch> o3: ooh, interesting -- explain more.
22:39:54 <jemfinch> o3: note that I didn't say it was a "problem" :)
22:40:25 <jemfinch> hmm.
22:40:27 <jemfinch> Maybe is a Monad.
22:40:56 <sethk> Python blocks a lot of powerful heterogeneity
22:41:11 <jemfinch> sethk: eh?
22:41:44 <o3> jemfinch: true :).  dynamic types are basically things which carry type information with them.  you can then "coerce" them (i.e. cast them, in OO/procedural terminology) to its original type
22:42:08 <jemfinch> o3: is that related to forall at all?
22:42:18 <jemfinch> sethk: what heterogeneity does Python prevent?
22:42:32 <o3> jemfinch: it's just that you specifically declare a type of something to be "Dynamic", and then you can do something like "foo = (fromDyn myDynamicThing) :: OriginalType"
22:42:37 <o3> jemfinch: i don't think so, no
22:42:46 * jemfinch hopes that, even in this emotionless medium, y'all understand he's more interested in arguing than defending any given programming language.
22:43:11 <sethk> Well, just for an example, you can create a type using the data statement, and then have a list of that type, effectively a heterogeneous list.
22:43:23 <jemfinch> o3: ooh, that's interesting.  Is that basically like O'Caml's obj.magic, except safer (instead of a segfault, it errors)?
22:43:51 <jemfinch> sethk: I'm curious more about your statement "Python blocks a lot of powerful heterogeneity."
22:44:02 <o3> jemfinch: there are various fromDyn functions which will do different things if the object isn't of the type that you expect ... hang on a sec
22:44:34 <o3> http://www.haskell.org/ghc/docs/latest/html/base/Data.Dynamic.html
22:45:02 <sethk> jemfinch: my previous example?  heterogeneous lists?
22:45:02 <o3> it's a key feature for building extensible programs, but that's a rant for another day :)
22:45:25 <jemfinch> sethk: Python allows heterogenous lists.
22:45:57 <jemfinch> sethk: and, because the type tag is implicit, it doesn't require the data declaration.
22:46:10 <sethk> But as I described Haskell is proscribing that the list contain only certain types, but not all the same type...
22:46:42 <jemfinch> sethk: how does that differ from Python?
22:47:07 <sethk> In Python, for example, how can I say that a list can contain strings and floats but nothing else?
22:47:07 <jemfinch> o3: I think I'll have to bookmark that and read it later, when my Haskell skills have grown :)
22:47:26 <jemfinch> sethk: you're talking about static typing again.
22:48:12 <sethk> I'm talking about typing, some of which is indeed static.
22:48:26 <sethk> So, you can make the Python tradeoff (all dynamic, but not as safe).
22:48:51 <jemfinch> sethk: it's just as safe; that safety is determined at runtime, not compile time.
22:49:27 <sethk> Haskell dNo, it isn't just as safe.  I can construct an example of this, although not a trivial one...
22:50:03 <o3> it's two different approaches, i wouldn't bother comparing them :)
22:50:07 <jemfinch> sethk: it's *just* as safe.  Haskell assures at compile time that no illegal operation will occur; Python assures at runtime that no illegal operation will occur.  Both languages are *completely* safe in that regard.
22:50:24 <sethk> That isn't what is usually meant by "type safe"
22:50:49 <sethk> An operation can be legal, but semantically incorrect.
22:50:55 <jemfinch> sethk: Python is dynamically typesafe.  Haskell is statically type safe.
22:51:06 <Jerub> I'm more concerned about problems that happen when pythons dynamic typing allows strange behaviour like what I've experienced in the past.
22:51:22 <jemfinch> Jerub: what strange behavior?
22:51:33 <Jerub> Where through 5 levels of indirection, an int got passed to minidom (colspan of a table cell) instead of a string
22:51:43 <sethk> Well, that is a somewhat semantic question of how you define type safe, and your definition may be correct, but...
22:52:01 <Jerub> the error was raised when a strreplace was attempted, in order to remove &, < and > characters 
22:52:08 <sethk> Haskell ABSOLUTELY does a much better job of ensuring that what you are doing is what you intended to do.
22:52:15 <Jerub> python isn't just susceptable, its PRONE to that sort of thing.
22:52:16 <jemfinch> sethk: "type safe" simply means "does not perform operations on a type for which the type isn't qualified" -- whether that's done dynamically or statically is (definition-wise) irrelevant.
22:52:31 <Pseudonym> Back.
22:52:51 <jemfinch> Jerub: any dynamically typed language is prone to such errors.
22:53:07 <sethk> OK, so let's use different terminology, because what is important, really, is whether your program does what you wanted it to do, and whether you can ever really tell what it is going to do...
22:53:17 <Jerub> jemfinch: I maintain that haskell has a better typing system, because constraints avoid that issue.
22:53:51 <sethk> jemfinch:  You are making my point (any dynamically typed language is prone to such errors)
22:53:58 <jemfinch> Jerub: Python's typesystem and Haskell's typesystem are really rather similar, except that Haskell's is enforced at compile time and Python's is enforced at runtime.
22:54:25 <sethk> I have to disagree with that (and remember I'm a Python fan)
22:55:18 <Jerub> I also disagree, the point has been missed.
22:56:07 <Jerub> Python is suceptable to such a class of errors (as I have descriped), Haskell is not.
22:56:07 <jemfinch> Jerub: I wrote a class Iterable with methods imap, ifoldl, and ifoldr in Haskell.  Now, I can call imap f (any_member_of_Iterable) successfully.  In Python, they call "imap" "__iter__", and I can call map() successfully on any object that defines __iter__.
22:56:33 * jemfinch has never argued that Python isn't dynamically typed, people.
22:56:50 <jemfinch> I've readily admitted that Python is dynamically typed.
22:57:11 <jemfinch> that *doesn't* mean that Python's typesystem isn't significantly similar to Haskell's.  That's one of the reasons I like Haskell's typesystem more than SML's or O'Caml's.
22:57:40 <Jerub> jemfinch: what I'd like to be able to do is enforce that arguments to functions meet type constraints. __iter__() being well defined might be one of them. Runtime is fine.
22:57:54 <jemfinch> Haskell's typesystem is closer to Python's than it is to SML's, IMO.  The only *significant* difference between Python and Haskell is that Python's typechecking is lazy.
22:58:03 <jemfinch> Jerub: what you want is a statically typed Python.
22:58:21 <Chilli> If I may add my 2 cents...
22:58:33 <jemfinch> Jerub: Python *does* enforce that arguments to functions meet type constraints.  At runtime.
22:58:52 <sethk> But not necessarily the constaints that you intended to be enforced.
22:58:57 <Chilli> jemfinch: I think the reason that you say Haskell's and Python's type system are similar is because both language support what is called "ad-hoc polymorphism"
22:59:03 <Chilli> which ML doesn't support
22:59:07 <jemfinch> Chilli: yes.
22:59:11 <jemfinch> (which SML doesn't support)
22:59:20 <Chilli> yes, SML, sorry
22:59:21 <jemfinch> O'Caml supports ad hoc polymorphism via its objects.
22:59:55 <Chilli> however, Haskell's and SML's type system are very similar in that both are based on a Hindley-Millner type discipline
23:00:02 <jemfinch> Jerub, sethk: I'm just trying to convey that dynamic typing (like Python has) is just "lazy evaluation of typechecking"
23:00:30 <sethk> No, it is different in kind, not just in temporal application
23:00:45 <jemfinch> Chilli: they are, but most any dynamic typesystem is based on a hindley-millner typesystem, except that the type constraints are enforced at runtime.
23:01:06 <Chilli> I guess that Jerub and sethk disagree with you, as they feel that the bein Hindley-Millner makes them more similar as the presence or absence of adhoc polymorphism
23:01:41 <sethk> jemfinch:  I'm saying that in many cases Haskell will infer the "right" constraints where Python will infer the "wrong" constraints.
23:01:51 <jemfinch> Chilli: Dynamic typing is simply the situation in the Hindley-Millner typesystem where all types are defined as a single algebraic datatype.
23:02:14 <Chilli> jemfinch: I think you can't really call any dynamic type system Hindley-Millner
23:02:15 <jemfinch> sethk: Python doesn't infer constraints.  It *knows* constraints, and it *knows* when those constraints are violated.
23:02:38 <Pseudonym> jemfinch: Not quite, because of inheritance.
23:02:39 <jemfinch> sethk: because it analyzes constraints at runtime.
23:02:55 <Pseudonym> The model of a big discriminated union isn't _quite_ correct.
23:02:59 <Chilli> jemfinch: well ok, the point about just one type is taken
23:03:20 <Pseudonym> Just picking a nit.
23:03:34 <o3> you're all evil type theorists
23:03:41 <o3> must... stay... away
23:03:42 <Jerub> I love these sorts of conversations. They're delicious. Having hung on #php (I do php for work, its not my language of choice).
23:03:45 <jemfinch> Pseudonym: I'll think about that a bit, but I may have an argument against it in a second...
23:04:42 <Pseudonym> jemfinch: If Python has multiple inheritance, it's got to include that too. :_)
23:05:20 * Pseudonym is not a type theorist
23:05:55 <sethk> Bye, folks, I have to go program...
23:06:12 <o3> bye seth
23:09:39 <jemfinch> Jerub, sethk: I'm actually a big fan of static typing.  I generally like it better than dynamic typing.  It's just that I like to clear up some (of what I think are) misconceptions about dynamic typing when I see them.
23:09:42 <Pseudonym> Bye.
23:09:52 <Jerub> jemfinch: ya.
23:09:56 <o3> use static typing with dynamic types :)
23:10:02 <o3> all good!
23:10:19 <Jerub> I would prefer that opinions like "Dynamic typing is okay because we find all type errors in the unittests" would disappear.
23:10:31 <Jerub> test first and unit-tests don't make problems go away.
23:10:31 <jemfinch> o3: I was always curious why that was never an option in statically typed languages.
23:10:48 <jemfinch> Jerub: Dynamic typing has its places.
23:10:58 <jemfinch> Jerub: at the very least, IME, it makes prototyping easier.
23:11:19 <Jerub> jemfinch: but what about when the prototype becomes a product ;)
23:11:24 <o3> jemfinch: dynamic types are _really_ powerful in scripting (interpreted) languages though, arguably more so than with compiled ones
23:11:30 <o3> (that's my own opinion)
23:11:45 <o3> hmm, actually, i should update this runtime loading stuff to use dynamic types
23:12:11 <jemfinch> o3: I don't know why there's so much of a disparity between interpreted and compiled languages.  Conceivably, any language should be capable of both.
23:12:11 <Pseudonym> Even statically typed programs must have some degree of dynamic typing, even if it's called "preconditions".
23:12:17 <o3> with that, haskell is a powerful force not be trifled with :)
23:12:19 <jemfinch> o3: runtime loading stuff?
23:12:35 <Jerub> Chilli: thankyou for the voice of impartial reason earlier.
23:12:37 <Pseudonym> jemfinch: Not if the language has an escape back to the interpreter.
23:12:52 <o3> jemfinch: http://www.cse.unsw.edu.au/~andrep/ghc_runtime_loading/TextFilter-1.0.tar.gz
23:12:57 <Pseudonym> jemfinch: Nothing stopping it from being compiled, but if you need an interpreter too...
23:13:00 <o3> jemfinch: download, check out README, have fun
23:13:02 <jemfinch> Pseudonym: Many languages with access to the interpreter/compiler are compiled.
23:13:09 <jemfinch> Pseudonym: in fact, our good friend SML/NJ is one of them :)
23:13:15 <Pseudonym> jemfinch: Depends what you mean by "compiled".
23:13:26 <Pseudonym> jemfinch: Perl is compiled, to some extent.
23:13:41 <jemfinch> Pseudonym: SML/NJ compiles to native code, and yet still offers the compiler at runtime (if you want it)
23:14:11 <jemfinch> Pseudonym: what's the significance of making Maybe an instance of Monad?
23:14:25 <Pseudonym> jemfinch: Sure, and so does Lisp.  Java offers a bytecode implementation even if it's compiled to native code.
23:14:36 <Pseudonym> OK, on making Maybe an instance of Monad...
23:14:51 <Pseudonym> The idea is that it's the poor man's exception implementation.
23:14:53 * jemfinch loves this concurrency thing :)
23:15:06 <Pseudonym> Trouble is the cost of the context switch. :-)
23:15:19 <jemfinch> hehe :)
23:15:25 <o3> concurrency's all fun until you have to start proving things :D
23:15:33 <Pseudonym> Consider the bind operation on Maybe:
23:15:34 <o3> (sorry, just doing a concurrency subject at uni right now)
23:15:47 <Pseudonym> (Just x) >>= k   = k x
23:15:57 <Pseudonym> Nothing >>= k   = Nothing
23:16:25 <Pseudonym> Nothing propagates through a sequence of binds.
23:16:38 <Pseudonym> So returning Nothing is effectively like raising an exception.
23:16:44 <Pseudonym> As it kills subsequent computations.
23:16:45 <jemfinch> hmm.
23:16:56 <jemfinch> I'm going to have to learn Monads better :)
23:17:00 <Pseudonym> Yes. :-)
23:17:05 * jemfinch is still reading Prelude.hs.
23:17:13 <jemfinch> I've gotten to the part where lists are made an instance of Eq.
23:17:17 <Pseudonym> The nice part is it supports the NotJustMaybe idiom.
23:17:27 <Pseudonym> Allow me to explain.
23:17:41 <Pseudonym> Suppose you're writing a "lookup" method for an association.
23:17:54 <Pseudonym> lookup :: Assoc k v -> k -> Maybe v
23:18:00 <jemfinch> btw, as a small nitpick, I like the option datatype better than the Maybe datatype :) -- SOME 'a | NONE seems more...literal than Just a | Nothing
23:18:01 <Pseudonym> That's the obvious way to write it.
23:18:22 <Pseudonym> jemfinch: Point taken.  I personally detest the Either type.
23:18:32 <jemfinch> what's the point of the Either type?
23:18:33 <Pseudonym> For similar reasons.
23:18:41 <Pseudonym> data Either a b = Left a | Right b
23:18:42 * jemfinch just passed that on the way to the list definitions.
23:18:49 <jemfinch> what would that be better named?
23:18:52 <Pseudonym> It's a disjoint union.
23:19:09 <Pseudonym> Personally, I reckon if you need it, you're almost always better off defining your own type.
23:19:22 <jemfinch> yeah, I saw the definition :)  I guess I could use it when I needed a heterogenous list between only two types (though, most of the time, I need more than two types)
23:19:32 <Pseudonym> Right.
23:19:37 <Pseudonym> Anyway, back to Maybe...
23:19:52 <Pseudonym> The obvious thing is to return Just if the key is in the association and Nothing if it isn't.
23:19:52 <jemfinch> so it's basically error handling like in C?  Based on return values?
23:20:06 <Pseudonym> Kind of.
23:20:13 <jemfinch> except a little easier, since Nothing automatically propogates.
23:20:20 <Pseudonym> However... current thinking is that this is not quite the right thing to do.
23:20:29 <jemfinch> what would the proper thing to do be?
23:20:34 <Pseudonym> Sometimes you want to raise an exception.
23:20:50 <Pseudonym> Sometimes you're doing some kind of nondeterminism, and you want to fail at that point in order to backtrack.
23:21:08 <jemfinch> oh, ok.
23:21:11 <Pseudonym> The "proper" thing is to write it like this:
23:21:14 <jemfinch> Haskell has exceptions that can be caught?
23:21:22 <Pseudonym> lookup :: (Monad rm) => Assoc k v -> k -> rm v
23:21:26 <Pseudonym> Yes, it does.
23:21:51 <jemfinch> only inside a Monad, I assume.
23:22:03 <Pseudonym> http://haskell.cs.yale.edu/ghc/docs/latest/html/base/Control.Exception.html
23:22:04 <jemfinch> hmm.  List is an instance of Monad too.
23:22:14 <Pseudonym> Yes.  List is the poor man's nondeterminism monad.
23:22:34 <jemfinch> >>= seems rather...inefficient.
23:22:50 <jemfinch> (x:xs) >>= f = f x ++ (xs >>= f)
23:23:00 <Pseudonym> List monads == list comprehensions.
23:23:12 * jemfinch cringes whenever he sees ++ (or @ in ML)
23:23:30 <Jerub> whats wrong with ++ ?
23:23:45 <jemfinch> Jerub: it's inefficient.
23:23:55 <jemfinch> Jerub: it copies the entire left list.
23:24:02 <Pseudonym> [ f x | x <- xs; p x ] is the same as do { x <- xs; guard (p x); return (f x) }
23:24:18 <jemfinch> what's guard?
23:24:19 <Pseudonym> jemfinch: It does, but in a lazy language it's an amortised cost.
23:24:33 <Pseudonym> You only copy as much of the list as you need, and you only copy it as needed.
23:24:34 <jemfinch> Pseudonym: an amortised cost?  Interesting...how's that work?
23:24:45 <jemfinch> oh, ok.
23:24:54 <Pseudonym> Lazy languages turn amortised costs into real costs, most of the time.
23:24:56 <jemfinch> but in most circumstances, I'd imagine you'd use the whole list.
23:24:57 <Jerub> jemfinch: right, sorr,y go on.
23:25:44 <Pseudonym> Right, so in fact the cost of copying the list is effectively a constant factor.
23:26:09 <Pseudonym> guard :: (Monad m) => Bool -> m ()
23:26:12 <jemfinch> hmm.
23:26:26 <jemfinch> m ()?
23:26:28 <Pseudonym> It fails if the boolean is False and returns () if it's True.
23:26:32 <jemfinch> ooh, ok.
23:26:37 <Pseudonym> In, for example, the Maybe monad it's:
23:26:49 <Pseudonym> guard b = if b then Just () else Nothing
23:27:05 <Pseudonym> The effect is to kill the rest of the computation if b is False.
23:27:11 <jemfinch> I just know I'm going to love this Monad thing when I finally get used to it.
23:27:33 <Pseudonym> You just wait until you see the monad template library.
23:27:38 <Pseudonym> It's way, way cool.
23:27:41 <jemfinch> the monad tmeplate library?
23:28:40 <Pseudonym> Yes.  All of the stuff in the Control.Monad libraries.
23:28:57 <Pseudonym> You can basically stack monads on top of other monads.
23:29:18 <Pseudonym> So if you need backtrackable state (say), you stack a state monad on top of a nondeterminism monad.
23:29:44 <Pseudonym> If you need non-backtrackable state but you also need nondeterminism, you stack them the other way.
23:29:54 <Pseudonym> And you can stack anything on top of IO if you need that.
23:30:10 <Pseudonym> The modular interpreters paper gives you the general idea.
23:30:48 <jemfinch> yeah, I need a bit more Monad/Haskell experience to really get that paper, so it's minimized for the time being.
23:31:01 <Pseudonym> Fair enough.
23:31:39 <jemfinch> now, back to making Iterable a member of Eq.  I'm not quite understanding the way lists are made members of Eq.  I don't see where the restriction that for a list to be a member of Eq, it has to have elements of Eq is.
23:32:34 <Pseudonym> instance Eq a => Eq [a] where
23:32:47 <Pseudonym> Think of the => as a kinf of implication.
23:33:03 <Pseudonym> If a is in Eq, that implies that Eq [a] is in Eq.
23:33:19 <Pseudonym> sorry, that [a] is in Eq.
23:34:04 <Jerub> qsort :: Ord a => [a] -> a
23:34:15 <jemfinch> ah, ok, cool.
23:34:18 <Jerub> a must derive the order relation.
23:34:48 <jemfinch> Pseudonym: so I should be able to define == via ifoldr in my Iterable definition.
23:35:17 <Pseudonym> jemfinch: Or itoList.
23:35:40 <jemfinch> Pseudonym: would both be equally efficient because of Haskell's lazy evaluation?
23:36:02 <Pseudonym> jemfinch: I think the problem with ifoldr is that you need to iterate over _two_ Iterables.
23:36:16 <jemfinch> Pseudonym: ooh, that's true.
23:36:19 <Pseudonym> What you actually want is something like zip.
23:36:23 <jemfinch> hmm.
23:36:28 <jemfinch> I need a zip in this definition :)
23:36:32 <Pseudonym> But itoList will do.
23:36:54 * jemfinch doesn't know how useful this class will be when he gets done, but he'll have learned in the process of making it.
23:37:04 <Pseudonym> If an Iterable has a more efficient ==, of course developers can implement their own.
23:42:32 <jemfinch> hmm.
23:42:41 <Pseudonym> It sometimes happens.
23:42:42 <jemfinch> izip :: c a -> c b -> c (a, b)
23:43:05 <Pseudonym> Uhm... actually, I'm not sure that izip is so useful.
23:43:12 <jemfinch> why not?
23:43:40 <Pseudonym> Well how often do you need to do parallel iteration?
23:43:55 <jemfinch> what do you mean?
23:44:07 <jemfinch> isn't that the standard zip?
23:44:08 <Pseudonym> Iteration over two Iterables in parallel.
23:44:25 * Pseudonym thinks
23:44:33 <Pseudonym> Well yes it is...
23:44:36 <Pseudonym> Hmmm.
23:44:49 <Pseudonym> I'm not convinced that it's _that_ useful.
23:45:01 <jemfinch> I can make an izipWith, too.
23:45:01 <Pseudonym> Personally, I use zip rarely.
23:45:12 <Pseudonym> I use zipWith rarely, too. :-)
23:45:26 <jemfinch> zip is useful for making == :)
23:45:50 <Pseudonym> Hmmm.
23:45:52 <Pseudonym> Yes and no.
23:46:06 <Pseudonym> If the iterables are of differing lengths, one will be truncated.
23:46:29 <jemfinch> ok, my definition starts "class Iterable c a where" -- should my instance of Eq be "instance Eq a => Eq Iterable c a where"?
23:46:31 <jemfinch> ah, that's true.
23:46:40 <jemfinch> and [1,2] certainly isn't == to [1,2,3]
23:46:47 <Pseudonym> Left out some parentheses.
23:46:53 <Pseudonym> instance Eq a => Eq (Iterable c a) where
23:47:00 <jemfinch> ah, ok.
23:47:02 <Jerub> I used zipWith the other day.
23:47:13 <Pseudonym> Oh, I use it occasionally.
23:47:15 <Jerub> doing a tile puzzle.
23:47:55 <jemfinch> have you guys read the paper "Do We Need Dependent Types?"
23:48:04 <Jerub> is_solved board = 0 == foldr (+) 0 (zipWith (-) [1..] (concat board)) or something silly.
23:48:25 <Pseudonym> Oh, very cute.
23:48:43 <jemfinch> hehe :)
23:48:46 <Pseudonym> jemfinch: It's been a while.  I don't even remember what it was about.
23:48:53 <jemfinch> Pseudonym: what's the Bounded class for?
23:50:00 <Pseudonym> Well, it supports minBound and maxBound.
23:50:16 <Pseudonym> It's particularly useful in combination with, say, Enum.
23:50:34 <Pseudonym> Then you can implement a map over all values in the type using an array, say.
23:51:49 <Pseudonym> It's also used in, for example, the enumFrom constructor.
23:52:09 <Pseudonym> [1..] is infinite, but [False ..] is not.
23:52:30 <Pseudonym> Because Bool is bounded.
23:53:36 <jemfinch> hmm.
23:54:59 <Pseudonym> It's mostly for those situations where you need all values in a type, I think.
23:55:27 <jemfinch> ah, ok.
23:55:31 <Pseudonym> And you need them in a robust way.
23:55:37 <jemfinch> it almost seems it would be part of Enum.
23:55:44 <Pseudonym> Add a new type constructor and you still want the rest of your code to work.
23:56:02 <Pseudonym> Well, it makes sense apart from Enum.
23:56:59 <jemfinch> hmm...it says that Doubles are higher precision than Floats, but they seem to show the same.
23:57:08 <jemfinch> @eval schedule._schedule.schedule
23:57:13 <jemfinch> @eval time.time()
23:57:31 <jemfinch> oops, wrong channel :)
23:57:39 <Jerub> Hometime.
23:57:44 <Jerub> see you later.
23:58:18 <Pseudonym> Farewell.
23:58:49 <jemfinch> g'night :)
23:58:57 <Pseudonym> Uhm... which system are you testing that in?
23:58:57 <jemfinch> man, there *are* some cool things that Python can do :)
23:59:03 <jemfinch> Pseudonym: I wrote an IRC bot in Python.
23:59:12 <jemfinch> that's him.
23:59:21 <Pseudonym> Ooh.  What does he do?
23:59:34 <jemfinch> oh, way too much for explanation :)
23:59:45 <Pseudonym> Well do I /msg him?
23:59:45 <jemfinch> @rot13 "The quick brown fox jumps over the lazy dog."
23:59:46 <supybot> jemfinch: Gur dhvpx oebja sbk whzcf bire gur ynml qbt.
23:59:56 <jemfinch> @rot13 [rot13 "The quick brown fox jumps over the lazy dog."]
23:59:56 * Pseudonym laughs
23:59:57 <supybot> jemfinch: The quick brown fox jumps over the lazy dog.
