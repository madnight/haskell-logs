00:35:19 <olczyk> Anyone here?
00:57:07 <sethk> Anyone here?
01:01:55 <eivuokko> Hi :)
01:10:54 <sethk> Hi.  I'm struggling with a stack overflow.
01:32:07 <olczyk> Looking for a reference that describes the structure of programs and modules. Suggestions?
01:43:12 <BlizzNL> olczyk: I think The Haskell School of Expression - Hudak is ok, but you'll have to buy it
01:44:08 <BlizzNL> olczyk: I know it uses modules all the time to improve reuse, but hey I'm only at chapter 5
03:06:37 <norpan> hi all
03:16:06 <Blizz> norpan: hi
03:16:49 <norpan> how are things?
03:17:24 <Blizz> alright. I'm looking into a assignment on parsing XML but I am breaking my head over it
03:17:56 <norpan> an assignment? should you use parser generator or combinators or wrrite your own?
03:18:35 <Blizz> all information I got was that the parser should have this type : parse :: String -> (Book, String)
03:18:50 <Blizz> and ofcourse I have the Book data types
03:19:59 <Blizz> and a hint stating: u should use helper function like 'token' and 'many' .. yeah great assignment mr professor ;)
03:24:33 <Blizz> norpan: any way how are things in Sweden ? ;)
03:25:17 <norpan> Blizz: good, today is election day
03:25:28 <norpan> so i'm going away to vote soon
03:25:55 <Blizz> ahh I don't hope you have one of those 'Pim Fortuyn guys' like we did..
03:26:25 <norpan> no, there are seven established parties, none of which are radical in any way :)
03:27:11 <Blizz> ahh some moderate choices :)
03:27:36 <norpan> yes, the parties are actually quite alike
03:27:44 <norpan> with some small differences of course
03:29:15 <Blizz> We had this really aggressive campaigning, with lots of promises.. but now 6 month later everything is back to normal .. nothing changed
03:29:37 <norpan> that's about normal i'd think :)
03:30:23 <norpan> well, i'm going to vote for the liberal party, the biggest party is the socialist party, and they don't seem to do anything useful at all :)
03:31:08 <Blizz> I voted for the liberal party also, but not because I'm all that liberal, but because the socialist are way to freakin' social ;)
03:33:20 <norpan> seems like .nl is similar to sweden :)
03:36:07 <Blizz> I guess so, ow and don't forget that it rains here when it snows at your place ;)
03:37:34 * Blizz is getting himself something to eat..
03:38:24 <norpan> hmmm i should get going
05:06:41 <lightstep> hello. i just learned about monads and how the IO system works in haskell. i know that `do' is just a nice syntax for a very long lambda (combinator), that keeps me from touching the world directly from main. but what happens if i code main to be a combinator that sends its parameter to 2 different functions? ho do you prevent such situation from happening?
05:07:05 <ChilliX> which parameter?
05:07:15 <lightstep> the IO()
05:07:26 <lightstep> which is main's parameter
05:07:30 <ChilliX> you mean how it keeps you from copying "the world"?
05:07:37 <lightstep> yes
05:07:55 <ChilliX> well, the same way as an ADT keeps you from getting at it's internal representation
05:08:10 <ChilliX> the "real" type of IO is not exported
05:08:16 <ChilliX> (by the Prelude)
05:08:28 <ChilliX> ie, IO is an abstract type
05:08:30 <lightstep> i don't know how to put it in haskell, but in scheme, it' be (lambda (io) (f1 io) (f2 io))
05:08:53 <lightstep> which duplicates it
05:09:08 <norpan> IO () is not "the world" but an action that changes the world
05:09:14 <ChilliX> this scheme term in Haskell is: \io -> (f1 io) (f2 io)
05:09:25 <norpan> so you copy the action, but for it to change the world the action must be run
05:09:43 <norpan> and the only thing that can run actions is main
05:09:55 <norpan> or any function that main calls
05:09:58 * BlizzNL : for everybody who is interested in robotics and Eqypt (who isn't ;)) should read this ( http://www.cnn.com/2002/TECH/science/09/14/pyramids/index.html )and watch it a National Geographic Channel tomorrow
05:15:05 <lightstep> and if i make main a function of 2 arguments?
05:15:24 <lightstep> wouldn't i get the world on the second parameter?
05:17:24 <ChilliX> no
05:18:00 <ChilliX> the reason is that to do this, you would make use of the fact that IO a is (internally) defined to be a function
05:18:26 <ChilliX> however, you cannot make use of this, as the type of IO is not exported by the Prelude (as I said, it is abstract)
05:18:45 <ChilliX> (in fact, different Haskell system implement the IO type slightly differently)
05:19:11 <ChilliX> if you try to write such a program, you will get a type error from the Haskell system
05:19:21 <lightstep> so it is a (sorry bur the buzz) polimorphic, abstract, function-like-fut-not-function type?
05:19:29 <lightstep> the IO types?
05:19:37 <ChilliX> yes
05:19:48 <ChilliX> just as an example
05:19:49 <lightstep> ok
05:20:01 <ChilliX> if I define in a module M a type IO2 as follows
05:20:07 <ChilliX> module (IO) where
05:20:14 <ChilliX> oops
05:20:17 <ChilliX> again:
05:20:20 <ChilliX> module (IO2) where
05:20:44 <ChilliX> newtype IO2 a = IORep (World -> (World, a))
05:20:58 <ChilliX> then, this type IO2 is essentially a function type
05:21:12 <ChilliX> but a module importing M wouldn't know
05:21:17 <lightstep> what is IORep?
05:21:37 <lightstep> oh, nevermind
05:21:49 <ChilliX> as I have exported IO2 only as IO2 and not as IO2(..)  (the latter is Haskell's way of saying to export the type name *and* it's definition)
05:22:09 <ChilliX> in a newtype def, you need to provide a constructor name, that's IORep
05:22:20 <lightstep> yes, i forgot it for a sec
05:23:33 <ChilliX> *if* IO2 were defined as a "type", not "newtype", then the export would be transparent and you could exploit the fact that it is a function
05:24:16 <ChilliX> but newtype permits to make the export opaque
05:24:17 <lightstep> it's weird. i just can never figure out higher (more than, say, 2) order functions
05:25:09 <lightstep> the only problem with your example is that the world will be a haskell expression
05:33:19 <ChilliX> that's true for the real impl, too
05:51:36 * BlizzNL is lagging
06:04:27 <BlizzNL> Can anyone tell me what the algebra and catamorphism are on : 'data Nat = Zero | Succ Nat' ?
06:10:46 * BlizzNL is thinking: It seems that Heffalump is the only one with knowledge of cata-anamorphism.. I wonder when he's coming back ;)
06:59:41 <norpan> back
07:26:53 * BlizzNL switched from card.freenode.net to irc.openprojects.net hopefully it helps
11:21:03 <loom2> hi
11:27:04 <eivuokko> Hiya loom2 ;)
11:34:05 <loom2> hello eivoukko :)
11:54:32 <dark> map greet (names #haskell)
11:59:16 <BlizzNL> dark: hi :)
12:01:01 <ibid> hm
12:01:51 * ibid ditched the stack-based vm and went for a variation of a ra-machine, now looks much nicer :-)
12:02:02 <dark> ra?
12:02:17 <ibid> random-access
12:02:31 <ibid> and it works, too :-)
12:02:38 <Marvin--> eeek
12:02:40 <ibid> at least for my trivial test cases :-)
12:02:44 <Marvin--> I just had a look at the implementation of QuickCheck
12:02:50 <Marvin--> evil evil code
12:04:14 <ibid> http://www.mit.jyu.fi/antkaij/tmp/kolmas/ :-)
12:12:51 <loom2> any idea about when the icfp contest results will be available?
12:13:42 <Erwin> They should be announced during the conference, Oct 4-6 or such
12:15:23 <loom2> thanks
12:21:41 <BlizzNL> I am working on this assignment and I am really stuck. I have a XML document with analogous haskell data types. BTW its a Book example (book has title, author and a list of chapters.  
12:22:34 <BlizzNL> I need to write a parser in the following form : readBook :: String -> (Book, String)
12:23:26 <BlizzNL> It also suggests I use the - to be written - helper functions token, many an <*> .. anyone has a clue?
12:24:43 <Marvin--> uh, what's the <*> operator supposed to do?
12:25:21 <BlizzNL> something like this : readBook = token "<"
12:25:26 <Marvin--> what kind of parser tools are you allowed to use?
12:25:45 <BlizzNL> something like this : readBook = token "<book " <*> readAttra <*> token ">"
12:25:55 <BlizzNL> Marvin-- : nothin'
12:26:20 <Marvin--> BlizzNL: okay, ouch
12:26:27 <Marvin--> ah, so <*> is a "then" operator
12:26:42 <BlizzNL> Marvin--: if you say so ;)
12:27:02 <Marvin--> BlizzNL: well, first "<book ", then attributes, then ">"...
12:27:17 <BlizzNL> yes indeed
12:28:20 <Marvin--> well, maybe I shouldn't give away too much :/
12:28:44 <Marvin--> it's common to express simple parsers in terms of [a] -> [(b, [a])] functions
12:28:54 <BlizzNL> Marvin--: hehe yeah right 
12:29:18 <BlizzNL> Marvin--: I agree, but this is String -> (Book, String) -- no list
12:29:27 <Marvin--> you can use helper functions
12:29:38 <dark> Interesting, this means the parser cannot fail?
12:29:59 <BlizzNL> Marvin--: I read all about ambigious stuff.. but the professor told us not to worry about failing ;)
12:30:23 <Marvin--> BlizzNL: uh, so how are you going to express choice?
12:31:00 <BlizzNL> I have no idea that's why I am asking you ;)
12:32:38 <Marvin--> doh :)
12:33:18 <BlizzNL> Marvin--: I know this is too complex for a simple answer , but I could give it a shot ;)
12:33:29 <dark> I don't see how you can actually construct a Book using only those operators.
12:34:26 <BlizzNL> dark: you are not giving me much hope here ;)
12:35:52 <dark> BlizzNL: Do you get to define the Book type yourself?
12:36:32 <BlizzNL> No it was included, but I dunno if I get kicked out if I post it (flood)
12:37:00 <BlizzNL> data Book	= Book Book_Attr Title Author Date [Chapter] deriving (Eq, Show)
12:37:01 <BlizzNL> data Book_Attr	= Book_Attr { bookLang :: Lang } deriving (Eq, Show)
12:37:01 <BlizzNL> data Lang 	= English | Dutch deriving (Eq, Show)
12:37:01 <BlizzNL> newtype Title	= Title String deriving (Eq, Show)
12:37:01 <BlizzNL> newtype Author	= Author String deriving (Eq, Show)
12:37:01 <BlizzNL> newtype Date	= Date String deriving (Eq, Show)
12:37:03 <BlizzNL> newtype Chapter	= Chapter String deriving (Eq, Show)
12:37:22 * BlizzNL is still here .. no flood-kick ;)
12:37:30 <Marvin--> I can't see how you can write the 'many' function without choice
12:38:35 <BlizzNL> maybe there is a typo in the assignment and should it be readBook :: String -> [(Book, String)]
12:38:44 <dark> Marvin--: Is "many" supposed to take a parser as argument?  If it takes a token then it's easy :)
12:38:51 <Marvin--> dark: ah, true
12:39:03 <Marvin--> I always think in combinators when it comes to parsing
12:39:25 <BlizzNL> many get a function called readChapters as an argument
12:39:41 <dark> Ah... an ad-hoc parser :)
12:39:57 <dark> Heh, a Book has exactly one attribute?
12:40:13 <BlizzNL> dark: yep language
12:40:52 <dark> Is it just me or are these newtypes really ugly?
12:41:18 <BlizzNL> dark: why
12:41:49 <dark> Well I would just write "type Title = String" if I felt it needed a name.  Or, more likely, Book { title :: String }
12:42:17 <dark> If you make it a newtype, you have a lot of extra code in your functions just for packing and unpacking Title values, and they'll obscure the algorithms.
12:42:17 <Marvin--> I don't see why you'd need that many constructors :)
12:42:33 <BlizzNL> I can't do anything about this, it's part of the assignment
12:42:46 <dark> BlizzNL: Yeah I'm just undermining your professor's authority :-)
12:42:59 <Marvin--> :)
12:43:12 <Marvin--> thank god for monadic parser combinators though
12:43:14 <BlizzNL> dark : you definitely are ;)
12:44:06 <dark> Okay, if the book has only one of each of these types, then you probably don't need choices at all.  You can just match literal tokens in a fixed sequence.
12:44:22 <dark> This depends on the type of "many" :)
12:44:22 <Marvin--> yeah
12:44:52 <dark> However, you'll still need a primitive that allows you to extract, say, the title string.
12:45:01 <dark> Hmm, and some way to delimit it.
12:45:04 <BlizzNL> I have to define 'many' myself so that one is open for discussion
12:45:29 <dark> BlizzNL: Ah, you can add primitives that you need?
12:45:34 <BlizzNL> sure
12:46:07 <Marvin--> I still say you should let readBook use a helper readBook :: String -> [(Book, String)] ;)
12:46:16 <Marvin--> err, helper readBook' that is
12:46:22 <dark> Marvin: And import Parsec? :)
12:46:40 <BlizzNL> dark : that would be nice, but no allowed ;
12:46:57 <Marvin--> dark: Parsek is cooler ;)
12:47:08 <dark> Marvin: Hmm never heard of that.
12:47:50 <BlizzNL> But does anyone know a nice introductary read on ad-hoc parsers like the one a have to make?
12:48:04 <dark> BlizzNL: I think the first step is to write down the types for all the ad-hoc functions you'll need, like readTitle.
12:48:44 <dark> BlizzNL: As well as for the primitves... consider the type of token, for example.
12:49:14 <dark> BlizzNL: Given those types, you can make an approximate version of readBook, and I think it will be quite different from the example you gave :)
12:49:33 <Marvin--> dark: it's a lot like Parsec but a bit more general, and I think it has a few other advantages too. But most of all because it's written by one of my lecturers ;)
12:49:58 <BlizzNL> ok thnx for your help guys
12:50:31 <dark> Actually I can't really think of a useful type of <*> myself, given all the different data types here.
12:50:41 <dark> Unless you just make it polymorphic :)
12:51:13 <BlizzNL> don't push it dark ;)
12:51:16 <dark> And even then... what should readTitle <*> readAttr return?
12:51:32 <dark> BlizzNL: And here I was about to suggest using the State monad :-)
12:52:36 <Marvin--> monadic parsers all the way :)
12:52:52 <dark> Lately I've been doing monadic everything, I wonder if I'm overdoing it.
12:53:05 <Marvin--> but a simple recursive-descent [a] -> [(b, [a])] parser works for simple examples
12:53:13 <Marvin--> nah, monads rock
12:53:42 <dark> I made a monad transformer called RandT, which I use for randomizing algorithms (such as game map generation).  So I have functions of type RandT StateT Landscape ().
12:54:00 <Marvin--> :)
12:54:06 <dark> The original incarnation of this was based on Parsec, but I realized that the only Parsec function I actually used was anyToken :-)
12:54:35 <Marvin--> "doing something with the result of something else" is pretty common, that's why monads are common :P
12:54:44 <dark> This is because all Rand parsers have to consume a value if they test it (to avoid re-using random numbers), so none of the "parsers" fail.
12:55:04 <dark> Marvin: Yeah but it kills the whole idea of functional programming being better for parallel architectures :)
12:55:16 <Marvin--> obviously
12:55:17 <dark> Marvin: I'm fairly sure I have more sequencing in my program than I really need.
12:55:46 <Marvin--> *wave* I'm going to go play War3
12:56:33 <BlizzNL> what is war3?
12:56:58 <loom2> warcraft 3 i guess
12:59:05 <BlizzNL> loom2: ahh ofcourse
13:05:18 <BlizzNL> dark: do you know anything about ana-catamorphisms (fold/unfold) ?
13:05:26 <dark> Nope.
13:06:11 <BlizzNL> mmm it seems nobody does lately .. 
13:06:26 <dark> It sounds vaguely kinky.
13:07:04 <BlizzNL> It sure is :) I never heard from them since last week, but they are pretty cool
13:07:13 <dark> Cool, anamorphism and katamorphism are in the dictionary.
13:07:32 <dark> anamorphism is simple -> complex, katamorphism is complex -> simple
13:07:33 <BlizzNL> dark: not with babylon
13:07:46 <dark> Anamorphism is also defined as "A distorted image" :)
13:08:08 <dark> BlizzNL: I'm using dict, searching web1913 and WordNet.
13:08:24 <dark> WordNet is generally useless, it defines all words as synonyms of all other words and then gives quotes for the wrong word.
13:08:33 <BlizzNL> ahh .. I made a type http://www.dictoinary.com check it out ;)
13:08:45 <dark> So I was surprised that it made sense this time :)
13:13:42 <sethk> Anybody home?  I can use some help...
13:23:33 <BlizzNL> hi sethk: dunno if I can be of any help
13:25:02 <eivuokko> Could anyone recommend which of lambda calculus books is a good one?
13:29:39 <sethk> BlizzNL: hi, thanks for trying.  eivuokko, I have several and they are all strange but I think Hindley & Seldin is the most accessible
13:30:01 <eivuokko> Strange?
13:30:23 <sethk> Well, either too much detail or not enough
13:31:07 <sethk> The really detailed ones require familiarity with catagory theory and domain theory
13:32:05 <sethk> Meanwhile, what do you know about monads?
13:32:38 <eivuokko> Just that they create something that allows you to skip the non-ordered computation from laziness, right?
13:32:58 * eivuokko isn't really a haskell programmer
13:33:33 <eivuokko> Thanks for the tips. :)
13:33:43 <sethk> I'm doing something wrong here but I'm having trouble spotting it.  I'll throw some stuff out and see if anyone catches anything...
13:34:00 <sethk> The following program works, but runs out of stack space:
13:34:52 <sethk> Hold on, emacs won't paste into kvirc, I have to bring up another editor...
13:35:40 <sethk> ncommas [] cnt = cnt
13:35:47 <sethk> ncommas (',':cs) cnt = (ncommas cs) (cnt + 1)
13:35:54 <sethk> ncommas (c:cs) cnt = ncommas cs cnt
13:36:11 <sethk> --
13:36:14 <sethk> myMaximum v1 v2
13:36:23 <sethk> | v1 > v2 = v1
13:36:31 <sethk> | otherwise = v2
13:36:35 <sethk> --
13:37:17 <sethk> processLines ([[]]) = (0)
13:37:37 <sethk> correction to last line (can't cut and paste...)
13:37:41 <sethk> processLines ([[]]) lineno =*9(
13:37:48 <sethk> processLines ([[]]) lineno = (0)
13:37:53 <sethk> (Can't type either)
13:38:15 <sethk> processLines (l:ls) lineno = myMaximum (ncommas l 0) (processLines ls (lineno + 1))
13:38:20 <sethk> --
13:38:40 <sethk> With a main program that feeds processLines with a list of lines (type [String]) from a file.
13:38:42 <sethk> --
13:39:02 <sethk> Now, the problem with this is that it pushes a value onto the stack with each recursive call.
13:39:18 <sethk> I'm trying to find a syntax that doesn't do that, which is where I run into the monad type issue.
13:41:23 <sethk> So, if any heavy Haskell hackers should peek here, I think there is probably a simple answer to this.
13:43:39 <ustenzel> sethk: I think you need to make processLines tail recursive, the same way you did with ncommas.
13:47:09 <eivuokko> Isn't it bad you use oen function to do two things?  Why not map with ncommas first and then fold it with myMaximum?  (or tell me if I got something horribly wrong, please)
13:57:42 <sethk> EIVUOKKO:  I tried, but I get problems because I'm calling a non-monadic function from a monadic one.
13:57:46 <sethk> ustenzel:...
13:58:02 <eivuokko> Uhhuh, okie.
13:58:09 <sethk> ustenzel:  You are right, but I can't get the syntax somehow...
13:58:30 <sethk> I'll give you an example in a second (I have about 15 versions here...)
13:59:34 <sethk> The problem is I can't find a way to make it tail recursive but without using a combinator...
13:59:55 <ustenzel> use an accumulator.  isn't that standard practice?
14:00:02 <loom2> what is a combinator?
14:00:05 <sethk> Yes, in fact I tried that first...
14:00:16 <sethk> loom2:  A sequencing operator
14:01:10 <loom2> like >> and >>=?
14:02:03 <sethk> Yes, exactly.  I'm using them in the main part of the program to get the data from the file
14:03:06 <sethk> ustenzel:  Something strange (or perhaps not so strange):  The version using the accumulator also has a trace() call, and when I remove the trace() it compiles.
14:06:30 <sethk> It also chews up 200% of CPU
14:06:37 <sethk> I'll try it with nice...
14:07:03 <loom2> sethk: i rewrote it
14:07:17 <loom2> ncommas s = length $ filter (==',') s
14:07:22 <loom2> krewel ss = fst $ foldl fun (-1,-1) $ zip [1..length ss] $ map ncommas ss
14:07:27 <loom2>     where
14:07:32 <loom2>     fun a b = if snd a >= snd b then a else b
14:08:00 <sethk> OK, the fun finds the maximum of the two integers...
14:08:06 <loom2> when compiled with ghc, this takes constant 500 kilobytes of memory :)
14:08:31 <sethk> the filter extracts a string of commas?
14:08:52 <loom2> the filter throws away everything that is not a comma
14:08:59 <sethk> I don't follow the foldl
14:09:14 <loom2> i build a list of pairs
14:09:23 <loom2> first element is the line number
14:09:33 <loom2> second is the number of commas in that line
14:09:54 <loom2> fun takes one such pair
14:09:54 <sethk> and the zip and the map?
14:10:06 <loom2> and another one
14:10:22 <loom2> and returns the one that has a higher comma count
14:10:50 <loom2> the map transforms the list of strings to a list of comma counts
14:11:14 <loom2> and the zip combines the list of line numbers and the list of comma counts.
14:11:38 <loom2> everything clear?
14:11:57 <sethk> I think so, but I need to study it a bit...
14:12:12 <sethk> Work through a couple of lines with pencil and paper.
14:12:40 <loom2> ok.
14:15:53 <sethk> My main didn't like it, but I fixed that by adding a return(krewel...)
14:16:22 <loom2> main = putStrLn $ show $ krewel $ repeat [',']
14:16:31 <olczyk> Hi. I'm looking got a description of the general layout of programs/modules.
14:17:15 <sethk> loom2: Explain that to me, and why $ instead of the dot (composition) operator? Because it is infix?
14:18:48 <sethk> Also, how do I modify main() to account for reading the lines from a file?
14:19:33 <sethk> loom2:  Where does the input come from in your main?
14:19:44 <loom2> sethk: composition wouldn't work, except in the main function i gave you. but there it doesn't matter which is used.
14:19:56 <loom2> sethk: at least i wouldn't know
14:20:23 <loom2> sethk: infinitely many strings are generated by the repeat [',']
14:20:36 <ustenzel> loom2: main = ( putStrLn . show . krewel . repeat ) [','] should work too, right?
14:21:08 <loom2> ustenzel: yes
14:21:20 <sethk> loom2: ustenzel:  To move the program into the "real world" I need to run it against the lines in the file...
14:21:50 <ustenzel> ( lines . hGetContents ) handle
14:23:11 <sethk> ustenzel:  Yes, that is how I did it originally but it essentially crashes the machine.  Even running with nice it took 3 minutes to type in and execute a kill statement.  I need to do it line by line.
14:23:51 <ustenzel> Because it hogs memory?
14:23:57 <loom2> sethk: don't forget that haskell is lazy :)
14:24:23 <sethk> But non-deterministically lazy, at least w.r.t. getContents().
14:24:51 <sethk> According to Simon Marlow, I can't use getContents here without causing this problem.
14:25:24 <sethk> So I need some monadic code with repeated application of hGetLine, or some other method I haven't thought of.
14:25:26 <loom2> where is getContents() defined?
14:26:01 <sethk> It's part of IO.  But I'm using hGetContents (which shouldn't matter, I think, but which is in a different module).
14:29:08 <norpan> hmmmm
14:29:23 <norpan> socialist block won the elections here in sweden
14:29:47 <eivuokko> Was that a suprise? ;)
14:30:02 <loom2> sethk: is there a prelude function that splits a string at newlines?
14:30:15 <sethk> loom2:  yes, lines()
14:30:24 <loom2> sethk: thanks.
14:31:02 <Marvin--> sethk: why the ()? :)
14:31:18 <sethk> 20 years of programming in C and C++
14:31:49 <Marvin--> hehe
14:31:49 <sethk> Which is why I find Haskell so attractive :)
14:32:00 <loom2> 20 years? i'm impressed.
14:32:20 <Marvin--> loom2: what, that he hasn't gone insane yet?
14:32:49 <sethk> Marvin:  You are assuming facts that are not in evidence (my sanity, that is)...
14:33:08 <Marvin--> sethk: true
14:34:59 <loom2> Marvin--: i'm programming for five years now. twenty is a lot for me.
14:35:56 <sethk> It depends what you have to code.  At least, now, I have junior coders to whom I can pass some of the gruntwork.
14:36:26 <Marvin--> yay, minions
14:37:07 <loom2> 22 ~> zcat www/ebooks/novels/commandline-stephenson.txt.gz  | ./a.out 
14:37:07 <loom2> 895
14:37:24 <loom2> yay! it's almost a useful program :)
14:38:01 <sethk> a.out is the compiled version of what?
14:38:12 <norpan> time for bed
14:38:18 <loom2> yes. try ghc -Wall -O2 code.hs
14:39:13 <sethk> loom2:  I've lost the thread here.  What are we doing?
14:40:02 <loom2> sethk: the main function is main = do
14:40:07 <loom2>     l <- hGetContents stdin
14:40:11 <loom2>     putStrLn $ show $ krewel $ lines l
14:40:15 <loom2> that's it.
14:40:29 <sethk> Ah, then running the program with stdin pointed at the file.
14:40:30 <Marvin--> isn't 'hGetContents stdin' the same thing as 'getContents'?
14:40:42 <loom2> no idea. is it?
14:40:51 <Marvin--> (and iirc, putStrLn . show is 'print' :))
14:41:02 <sethk> logically, yes.  I'm not sure about the implementations, though...
14:41:17 <loom2> i need to go now.
14:41:20 <loom2> have fun.
14:41:28 <sethk> loom2: Thanks for the ideas.
14:41:42 <loom2> sethk: np
14:46:21 <sethk> Hmmmm... I'm getting the wrong answer.  Maybe a typo...
14:58:50 <BlizzNL> symbola :: Parser Char Char
14:58:50 <BlizzNL> symbola []			= []
14:58:50 <BlizzNL> symbola (x:xs)	| x=='a'	= [(xs, 'a')]
14:58:50 <BlizzNL> 		| otherwise	= []
14:59:28 <BlizzNL> I get an error stating this is an ambigious type signature... what's wrong?
15:00:09 <BlizzNL> I forgot this: type Parser a b = [a] -> [([a],b)]
15:00:24 <sethk> Is this your own Parser class or the Parser class from Parsec?
15:00:32 <loom2> sethk: was it a problem in your code or mine?
15:00:49 <sethk> loom2:  still checking...
15:01:00 <BlizzNL> my own
15:01:12 <loom2> sethk: what is the complete program supposed to do?
15:01:24 <sethk> zoom:  the answer is always one - which sounds like I fat fingered something...
15:03:03 <Marvin--> BlizzNL: I don't get any errors on that code
15:03:03 <sethk> BlizzNL: I see little squares on my IRC program here - for example after "symbola []" there are three little squares and then "=[]".  What characters are those, or are they white space?
15:03:36 <BlizzNL> no those are TABS
15:03:45 <Erwin> Here they show up as a tiny N on top of a tiny L
15:03:53 <Marvin--> BlizzNL: you sure that's the function you get a type error on?
15:04:22 <sethk> BlizzNL: I've solved a multitude of weird compiler errors by removing the tabs from files.  Maybe completely irrelevant here...
15:04:36 <BlizzNL> mmm
15:05:04 <sethk> loom2:  I'm still getting an answer of 1.  I dumped out the string and there are lines there, and the lines have commas...
15:05:55 <Marvin--> sethk: what are you trying to do?
15:06:24 <sethk> Something very simple, process each line of a file and find the maximum number of commas.
15:06:48 <BlizzNL> could it have to do with this being gofer code?
15:07:12 <sethk> BlizzNL:  No, I think I found the problem; embedded \r in the file...
15:08:13 <sethk> No, that wasn't it...
15:08:33 <BlizzNL> sethk: you get the same error?
15:09:45 <sethk> BlizzNL:  No, sorry, I was looking at the wrong file...
15:09:45 <sethk> BlizzNL:  Trying again...
15:11:24 * Marvin-- ponders being evil and giving sethk a one-liner for it
15:13:24 <Marvin--> sethk: what's your the code looking like?
15:13:28 <sethk> BlizzNL:  No errors, after cutting and pasting.
15:13:35 <sethk> Marvin -- wait a second...
15:13:59 <sethk> Marvin:  Mostly zoom2's code; don't want to usurp credit... here it is...
15:14:33 <sethk> ncommas s = length $ filter (==',') s
15:14:42 <sethk> krewel ss = fst $ foldl fun (-1,-1) $ zip [1..length ss] $ map ncommas ss
15:14:49 <sethk> where
15:14:56 <sethk> fun a b = if snd a >= snd b then a else b
15:15:00 <sethk> --
15:15:05 <Marvin--> ah, you want the line number too?
15:15:59 <BlizzNL> sethk: when i comment out the header (is this the right name for it) it works fine.. vage
15:16:21 <Marvin--> sethk: you can do zip [1..], since it'll break off when the shorter list is empty
15:16:32 <BlizzNL> Do i need to import something to use the Eq class?
15:16:42 <sethk> BlizzNL no, its in the prelude
15:16:54 <sethk> Marvin - but that doesn't explain why it isn't working, does it?
15:18:10 <Marvin--> sethk: no :)
15:18:25 <BlizzNL> sethk: i found it .. it was a stupid type (as always ;))
15:18:47 <sethk> BlizzNL:  yes, easy to miss...
15:19:13 <sethk> Marvin: I'm going step by step, ncommas is working properly...
15:19:25 <Marvin--> sethk: if you let the line number list ([1..]) be the second argument of zip, you can use 'maximum' instead of 'foldl fun (-1, -1)'
15:19:47 <Marvin--> since tuples are in Ord
15:20:07 <sethk> OK, I'll try it...
15:20:25 <Marvin--> and drop the fst while debugging so you get both the line number and the comma count
15:21:29 <sethk> Marvin: good call, dropping the first gets the correct answer; probably missing a "show" somewhere
15:21:47 <sethk> Now, on maximum, you mean just that, not applied to anything?
15:22:09 <Marvin--> maximum $ zip (map ncommas ss) [1..]
15:23:11 <jadrian> hello
15:23:18 <BlizzNL> jadrian: hi
15:23:22 <jadrian> hi BlizzNL
15:23:23 <sethk> jadrian: hi
15:23:41 <jadrian> hello sethk
15:25:22 <sethk> Marvin: now I want to get a list, [(line number, comma count)] for each line...
15:25:42 <Marvin--> sethk: drop the 'maximum' call? :)
15:25:47 <jadrian> I just mad a mistake in a classe declaration and ghci accepted it...
15:26:07 <jadrian> is this supposed to work :
15:26:10 <sethk> jadrian:  Then it isn't a mistake, by definition :)  (not really, of course)
15:26:22 <jadrian> instance Teste Int where
15:26:22 <jadrian>     s = 3 
15:26:41 <jadrian> opss that was the instance declaration
15:26:50 <jadrian> class Teste a where
15:26:51 <jadrian>     s :: Int 
15:27:04 <Marvin--> what's the problem?
15:27:25 <jadrian> Marvin--: well how do you use something like that s 'method'
15:27:43 <Marvin--> jadrian: uh, you don't
15:27:50 <Marvin--> haskell class != OO class
15:27:57 <jadrian> I know
15:28:12 <jadrian> that's why I put the ' ' in method
15:28:44 <jadrian> what is the point of accepting the declaration of s if it is unusable
15:29:08 <Marvin--> hmm
15:30:07 <sethk> jadrian:  Probably shouldn't be accepted, but harmless more or less...
15:30:21 <Marvin--> it's less work accepting it than filtering it out I suppose :)
15:30:43 <Marvin--> any declaration in a type class that doesn't use the type variable seems a bit...dumb
15:31:07 <jadrian> Marvin--: yes it seems, and it is trivial to filter it...
15:31:53 <Marvin--> jadrian: trivial, yes, but by ignoring the existance of them, you don't have to write the code for it in the interpreter
15:33:51 <Marvin--> sleepy time
15:34:51 <loom2> sethk: i'm back.
15:35:26 <sethk> OK, I think I have it working...
15:36:03 <loom2> sethk: so what was the bug?
15:36:25 <sethk> I was getting the line number; when I removed the "fst" I got the number of commas.
15:36:53 <loom2> i though you wanted the line number :)
15:37:15 <sethk> Sorry if I was unclear, I want both, but I see how to get that.
15:37:27 <jadrian> is there a way to use dependent types in haskell yet?
15:37:47 <jadrian> (types which depend on values...)
15:38:03 <sethk> jadrian:  If you mean functors, I believe the answer is no.
15:38:19 <jadrian> sethk: functors? I don't think so...
15:38:36 <sethk> Parameterized type definitions?
15:38:42 <jadrian> yes
15:38:57 <sethk> ML calls these functors, which may be incorrect.  Haskell doesn't have them yet.
15:39:21 <jadrian> I've heard about Cayenne and some other language...
15:39:41 <jadrian> I want to have some entities of some fixed size
15:39:49 <sethk> jadrian:  It is definitely an extremely useful capability...
15:40:03 <jadrian> I don't want to declare a datatype for each size
15:40:42 <sethk> jadrian:  You may be able to do that with polymorphic functionality in Haskell, combined with type classes...
15:41:07 <loom2> what are you talking about? can you give an example?
15:41:09 <jadrian> sethk: I'm checking the archives and I don't really like any of the ideas more than the one I had
15:41:42 <jadrian> my idea was simple (in fact it is not original, I just found it on the mailing list and I think I read it before)
15:41:51 <sethk> jadrian:  Tell us what you are trying to do; I've found things here that weren't anywhere in the archives...
15:42:12 <jadrian> which is to have a class which will give me the size like:
15:42:26 <jadrian> class Ch a where
15:42:33 <jadrian> size:: a->Int
15:42:34 <jadrian> ...
15:42:52 <jadrian> so every datatype will have a method size
15:43:05 <jadrian> similar to what happens in haskell arrays
15:43:17 <jadrian> you have a function that gives you the bounds
15:43:18 <sethk> OK, so you make those data types instances of the class Ch.  why doesn't that work for you?
15:43:30 <jadrian> the only diference is that in here size = const
15:43:49 <jadrian> seth like I said I have to declare a datatype for each size
15:44:10 <jadrian> I can do it like this but it is not an optimal solution IMO
15:44:19 <sethk> So you want the functionality of, say, sizeof() in C?
15:45:13 <jadrian> yes something like it
15:46:20 <jadrian> newtype Ch ChRepresentation 4
15:46:25 <sethk> Jadrian:  I agree that declaring a type for this is not a good idea; adds unjustifiable complexity.
15:47:05 <jadrian> sethk: some examples where you need this kind of stuff are:
15:47:15 <jadrian> sethk: Zn (Integers modulo n)
15:47:25 <jadrian> sethk: arrays with fixed size
15:48:35 <sethk> Jadrian:  You would have to be careful about introducing portability problems, but it could certainly be implemented...
15:49:25 <jadrian> sethk: I don't really care about portability... I using many extensions of ghc already :)
15:50:36 <sethk> jadrian:  I'll see if I can discover something clever, but probably you are correct and a good solution doesn't exist at this time.
15:51:11 <loom2> jadrian: just out of interest, what do you personally need this for?
15:51:41 <jadrian> loom2: genetic algorithm
15:51:50 <jadrian> loom2: chromossomes representation
15:53:08 <loom2> jadrian: ok. i don't know much about that.
15:53:41 <sethk> jadrian:  I've seen some work in that area on the O'Cml web site (although I think I spelled it wrong)
15:53:49 <jadrian> back sorry
15:53:51 <sethk> O'Cml, that is...
15:54:02 <loom2> o'caml.
15:54:13 <sethk> Right.
15:54:42 <jadrian> I don't really need any related work right now... 
15:55:08 <jadrian> My problem is a very common one I think...
15:55:13 <sethk> No, I meant that it might be a suitable language.  It has the feature (parameterized modules).
15:55:28 <jadrian> in this case it is about fixed size arrays
15:55:30 <jadrian> oh
15:55:42 <jadrian> nah... not enough time to play around with other languages
15:55:53 <jadrian> I have to do this and do it *fast*
15:56:45 <sethk> What are you doing, locating sequences?
15:57:31 <jadrian> sethk: Just (yet another) variation of genetic algorithms
15:57:51 <jadrian> sethk: well in fact genethic algorithms are not really the theme of the work
15:58:43 <jadrian> sethk: it is about creativity I want to change an 'intelengent' algorithm to improve his capability of having 'insights'
15:59:18 <sethk> So you mean genetic in terms of mimicking evolutionary processes.  But that doesn't match up with chromosomes...
16:00:27 <jadrian> sethk: I mean genetic in the classical "genetic algorithm" sense
16:01:26 <jadrian> sethk: I could probably generalize my idea to any search algorithm that kept multiple solutions along the way
16:01:41 <jadrian> anyway the application is not really important...
16:02:21 <sethk> This No, not for this problem, I'm just curious.
16:02:41 <jadrian> ok :)
16:03:21 <sethk> I've always found the concept to be dubious (although perhaps this is the voice of ignorance): about the only thing we are sure of in the field of genetics is that it is horribly inefficient.
16:07:01 <jadrian> sethk: lol :)
16:07:53 <jadrian> sethk: there are many things I like about them and many things I don't like
16:08:02 <jadrian> sethk: but for my idea they were kind of nice
16:09:03 <jadrian> now I'm mixing biology, psychology, comp. science and math...
16:09:23 <BlizzNL> jadrian: you shouldn't ;-)
16:09:44 <jadrian> BlizzNL: maybe not... short deadlines. I hate it
16:09:59 <jadrian> One of my problems was how to medle state...
16:10:09 <jadrian> Option 1: State Monad
16:10:25 <jadrian> the classical one, like in richard birds books
16:11:02 <jadrian> Option 2: Ghc ST Monad passed as an implicit parameter
16:11:17 <jadrian> like in John Hughs Global variables in haskell
16:11:51 <jadrian> I still have some doubts about which one would be the best
16:12:46 <sethk> Hey everyone, I have to go fix a problem ... thanks for the help and back in a short while I hope.
16:12:57 <jadrian> see ya sethk
16:13:29 <BlizzNL> bye sethk
16:16:26 <jadrian> bbl!
16:20:10 <jadrian> opss back
16:20:15 <jadrian> can I download this from somewhere?
16:20:17 <jadrian> http://www.dcs.glasgow.ac.uk/jfp/bibliography/References/mcbride2002:375.html
16:20:54 <BlizzNL> never heard of
16:22:46 <jadrian> oh well
16:23:03 <jadrian> I hate this Copyright stuff :(
16:23:28 <jadrian> http://www.dur.ac.uk/c.t.mcbride/
16:24:06 <BlizzNL> Bedtime- bye
16:25:29 <jadrian> Ah found it :))
16:25:43 <jadrian> http://www.dur.ac.uk/~dcs1ctm/faking.ps
19:12:10 <sethk> hello hdaume
19:12:30 <hdaume> hi...sorry i left abruptly on friday...i had a talk to go to
19:12:53 <sethk> No problem.
19:13:44 <hdaume> i don't suppose you managed to find out about that caret java thing... ;)
19:14:07 <sethk> Actually I forgot to look, but let me take a quick look now...
19:14:14 <hdaume> all right...thanks again
19:17:20 <sethk> OK, I think this wil work...
19:17:37 <sethk> You've already registered a listener for the click, as I recall
19:17:51 <hdaume> right
19:18:04 <sethk> when that listener fires, you can get it's position with getCaretPosition()
19:18:18 <sethk> Sorry, no, not getCaretPosition(), wait a second
19:18:30 <sethk> You move it with setCaretPosition
19:18:46 <sethk> Let me find where you get the mouse position from...
19:19:12 <hdaume> right now i have:
19:19:38 <hdaume> public void mouseClicked(MouseEvent e) { int pos = ctx.whole.getCaretPosition(); ... }
19:19:44 <hdaume> but this only works if the button clicked was button1
19:20:10 <sethk> That is, I think, because the caret position is actually changed by the click before you make the call...
19:20:22 <sethk> But you need the mouse pointer position in this case, not the caret position.
19:22:54 <sethk> I think, with the mouse event (the argument passed into the listener), you can invoke methods...
19:22:56 <sethk> getX()
19:22:59 <sethk> and getY()
19:23:26 <sethk> which you can then use as a location for setCaretPosition.
19:23:40 <sethk> You'll need to use a version of setCaretPosition that uses the X/Y location scheme
19:24:49 <hdaume> setCaretPosition is of type int -> void...it expects a character offset, not an x,y log
19:24:54 <hdaume> log = loc
19:25:24 <sethk> Yes, but there are other methods.  That one basically just moves the cursor with a text field...
19:25:48 <sethk> I think you can use the more general setLocation(x, y)
19:27:31 <hdaume> ok
19:29:48 <hdaume> bbiab
20:24:31 <sethk> Anybody home?
20:34:02 <olczyk_> Is there some document that describes the layout of modules/programs?
20:37:56 <sethk> The Haskell Report has it
20:46:39 <sethk> I need help with the Maybe syntax.
21:53:58 <tmoertel> hello, #haskellers!
21:54:20 <Pseudonym> Greetings.
21:55:38 <tmoertel> Has anybody built GHC 5.04.1 RPMS yet? If not, I might as well do it. (Chilli usually does, IIRC, but I haven't seen the normal announcement.)
21:56:28 * Pseudonym uses DEBs
21:57:03 <tmoertel> (Typically, Chilli announces his RPMs about 5 minutes before mine finish compiling.) :-)
21:58:50 * tmoertel commences downloading the GHC 5.04.1 sources
22:03:40 * tmoertel starts the first of two six-hour builds . . .
22:15:36 <Pseudonym> How fast is your machine?
22:19:05 <Pseudonym> Has anyone done a Haskell binding for Berkeley DB/DBM/GDBM/whatever?
22:22:58 <sethk> Pseudonym, do you mean a general purpose DBMS?
22:23:35 <Pseudonym> I mean something simpler than SQL.
22:24:24 <Pseudonym> And that doesn't require a database server to be around.
22:24:29 <Pseudonym> Something like Berkeley DB.
22:24:42 <sethk> I'm working on bindings for my database engine, which gives you SQL but also B-tree level access.
22:25:13 <Pseudonym> That's cool, but I think it might be overkill.
22:26:06 <sethk> It might be, but the engine already exists so it makes sense to provide the same functionality in the bindings.  I can see that for some cases it would be more complexity than is justified...
22:26:40 <Pseudonym> Of course, another benefit of using DBM/DB/GDBM is file-level compatability.
22:26:53 <Pseudonym> And compatibility, too.
22:27:33 <sethk> True, it is possible to do conversions but that isn't the same thing at all...
22:28:09 <sethk> Perhaps I can apply a subset of my bindings to Berkely DB and see how it works out...
22:29:20 <sethk> Or, perhaps, XML makes more sense as a platform independent file format (not as efficient, though).
22:31:50 <Pseudonym> Well, what I want is basically an on-disk key -> value mapping that I can modify randomly.
22:32:07 <sethk> XML has too much overhead, then...
22:32:53 <Chilli> tmoertel: I have just compiled it
22:33:05 <sethk> A b-tree does that very nicely, but the complexity is only justified if the number of rows is not small, in the thousands, at least.
22:33:19 <Chilli> tmoertel: had to cvompile again to get the haddock stuff working
22:33:35 <Pseudonym> sethk: There's also concurrency to consider.
22:33:43 <Pseudonym> Two mutators on the same file.
22:34:12 <sethk> Well, that's all taken care of in my system, fully multiuser with transactional semantics, even at the b-tree level.
22:34:29 <Pseudonym> Sure.  I meant in a straight XML file.
22:35:10 <sethk> I've been considering making XML a first class structure in the database engine, which brings all the other stuff with it.  There are some interesting papers about this floating around on the net...
22:35:45 <sethk> I'm not sure about the concept, though, as XML really was designed more as an interchange format...
22:35:46 <Pseudonym> Yes, we have the odd chuckle about that here.
22:36:22 <Pseudonym> Our product is a text DBS.  Z39.50 and all that.
22:36:31 <Pseudonym> XML + SQL = bad fit
22:37:11 <Pseudonym> But then, our clients generally don't want relations, they want documents.
22:37:18 <sethk> Yes, but as a way of passing data around in text format it isn't terrible, although it is overly complex...
22:37:54 <Pseudonym> Yes and no.  For structured documents, it's great, when you have stuff like XPath and XSLT.
22:38:05 <Pseudonym> Just as a file format it's not so useful on its own.
22:38:41 <sethk> It's becoming a thing that you have to support, at least to be able to parse it and translate it into your native formats.
22:39:58 <Pseudonym> Oh, what do you know.  GDBM is an example that comes with green card!
22:40:06 <Pseudonym> That answers that question. :-)
22:40:39 <sethk> I've been playing with HaXmL also  :)
22:40:47 <Pseudonym> Ah, but for a text database system, it makes sense for XML to be a native format.
22:41:10 <sethk> I'm not sure how you index it efficiently...
22:41:12 <Pseudonym> You let your users have access to XPath, XSLT, DOM bindings for your plugin language and you're all set.
22:41:59 <Pseudonym> http://citeseer.nj.nec.com/arnold-moore00architecture.html
22:42:02 <Pseudonym> That's our system.
22:42:26 <sethk> I'll look at it.  I'm working on something for AT&T where that might fit nicely...
22:42:38 <Pseudonym> Warning: Product is very expensive.
22:42:54 <sethk> They paid for Oracle...
22:43:03 <Pseudonym> Fair enough, then.
22:43:43 <sethk> You also want to add an "AT&T doesn't know what their own data means" surcharge...
22:43:58 <Pseudonym> That could be half our clients. :-)
22:44:37 <sethk> My favorite is US West (now Qwest); they constantly cut through their own cables...
22:47:29 <sethk> Hey, I just figured out how to use Maybe.  (Maybe there is hope for me yet)
23:01:21 <Pseudonym> Does anyone know who is responsible for GHC debian packages?
23:01:26 * tmoertel returns after a brief time away from computer
23:02:05 <tmoertel> Chilli: You're serious?  You've just built the RPMS?
23:02:12 <Chilli> yes
23:02:17 <Chilli> and just announced them actually
23:02:21 <Chilli> (for RH 7.3)
23:02:35 <Chilli> (I actually built them tonight, but had to rebuild due to Haddock problems)
23:02:41 <tmoertel> Did I not predict this very thing?
23:02:48 <Chilli> you did :-)
23:03:15 * tmoertel kills compilation on his build machine (and build machine is thankful)
23:03:23 <Chilli> got my announcement to haskell@haskell.org?
23:03:24 <tmoertel> Chilli:  what was the haddock problem?
23:03:31 <sethk> Chilli:  I've seen a problem where, sometimes, building on Red Hat, interactive doesn't get built.  Have you run into this?
23:03:39 <Chilli> the build system expects an inplace haddock
23:03:46 <Chilli> but there is none in the tar ball
23:03:58 <Chilli> sethk: no, haven't seen this
23:04:00 <tmoertel> Chilli: the announcement just dropped into my inbox, right now
23:04:35 <Chilli> good
23:04:58 * Chilli is off for a coffee - bbl
23:05:35 * tmoertel downloads Chilli's RPMs
23:08:16 <tmoertel> sethk: regarding the GHCi problem, that happens when you don't build twice: once for the compiler and again to bootstrap GHCi
23:09:43 <sethk> You have to do that even on an upgrade, for example when I build the new 5.04.1?
23:09:54 <tmoertel> sethk: yes
23:10:11 <sethk> OK.  Do I run ./configure a second time?
23:10:25 <tmoertel> sethk: are you using RPMs?
23:10:54 <sethk> No, actually I'm building from source, because I want to build it on 64 bit HP/UX so I'm practicing on platforms where the build is known to work.
23:11:31 <tmoertel> I usually build from RPMs, and they certainly run ./configure each time, so I would say, yes, run it a second time.
23:12:00 <tmoertel> *after* making sure that you have installed the compiler from the previous build attempt, of course
23:12:27 <sethk> ./configure, make, make install, then repeat the cycle.
23:12:53 <tmoertel> sethk: actually it's more like make, read a book, make install, and *then* repeate the cycle ;-)
23:13:50 <sethk> I stuck an extra 512 MB of ram in my Linux box and it builds somewhat faster.  Which is odd because, as several people have pointed out, it doesn't appear to be swapping during the long link operations...
23:14:34 <sethk> But it does still take a while.
23:14:40 <tmoertel> sethk: it's not odd because your machine is caching about 512 MB of files, enough to hold all of the sources
23:14:55 <sethk> Makes sense.
23:15:34 <tmoertel> my build box is 2-way smp but (at least as of 5.04) I couldn't use both processors during the build owing to dependency problems in the GHC make process
23:16:01 <tmoertel> Chilli: your RPMs appear to work just fine on a RHL 7.2 box
23:17:33 <sethk> tmoertel: on Linux, yes.  On Solaris it manages to find more concurrent operations.
23:18:10 <tmoertel> sethk: I mean I can't use "make -jN" with N>1 without build errors.
23:18:52 <sethk> Oh.  That isn't a dependency problem, that's a bug in the make process.  Not that it matters.
23:20:23 <tmoertel> I thought that the cause of the bug was a dependency problem.
23:21:05 <sethk> Well, semantics; plus I haven't looked into the details myself, so my info could be wrong...
23:24:38 * tmoertel rebuilds RAVT as a smoke test for GHC 5.04.1
23:26:54 * tmoertel rebuilds RAVT with -O2 as a second smoke test for GHC 5.04.1
23:37:54 <tmoertel> well, I must go to sleep. g'night, folks!
23:39:12 * tmoertel fades away into the distance . . .
23:40:43 <Pseudonym> Night.
23:43:47 <Chilli> re
