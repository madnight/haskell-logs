02:20:49 <PMode> hi
02:30:09 <Heffalump> hi
02:38:51 <PMode> Heffalump: i've a problem. i try to parse a graph (same problem as yesterday). if i want to parse the nodes (i assume Show <node-type>).
02:39:17 <PMode> okay, again: i don't know how to parse the nodes.
02:39:54 <PMode> Heffalump: the simpliest way is to look at http://pmode.dyndns.org/graph/Graph.hs
02:51:49 <Heffalump> hmm, I'm not particularly familiar with parsec
02:52:33 <PMode> Heffalump: how would you parse such a construct? 
03:01:41 <Heffalump> hmm
03:13:44 <PMode> Heffalump: no idea?
03:27:59 <Heffalump> I have some, but I'm a bit busy right now :-)
03:30:00 <PMode> Heffalump: k
03:33:05 <PMode> okay ciao
03:43:18 <Ig> "The result of the scoring will be announced during the ICFP
03:43:20 <Ig>      2002 conference"
03:43:43 * Ig looks confused and wonders if the ICFP invites are actually to this years conference
03:44:50 <ChilliX> ?
03:45:01 <ChilliX> ICFP contest result always are announced at ICFP
03:53:54 <Ig> My reading of that is that they won't be announced before, but maybe I'm just reading things into it
03:56:06 <ChilliX> no, won't be announced before
03:56:12 <ChilliX> it is part of the programme
03:57:00 <ChilliX> see http://icfp2002.cs.brown.edu/Papers/
03:57:10 <ChilliX> last entry on Oct 5
03:57:18 <ChilliX> has always been like this
03:57:19 <Ig> So how does "Wisdom: Up to 4 participating students on the team will receive free registration for the ICFP conference." work then?
03:57:49 <ChilliX> I guess, that they will be notified beforehand
03:58:11 <Ig> OK
03:59:21 <Heffalump> 9 Haskell entries
03:59:33 <Heffalump> chilli: how different was TeamGHC's 3 day entry from the lightning one?
03:59:56 <Heffalump> (I hope you fixed your manager thread, at least :-)
04:01:02 <ChilliX> where do they say 9 Haskell entries?
04:01:10 <Heffalump> I counted in http://icfpcontest.cse.ogi.edu/entries.html
04:01:18 * Ig raises an eyebrow at teams without a programming language
04:01:26 <Heffalump> hmm, another team called their bot postman
04:01:37 <Heffalump> lots of perl entries
04:01:43 <Ig> Does that include e.g. the Hackell, C++ entry?
04:01:51 <Heffalump> anything that mentions Haskell
04:01:58 <ChilliX> Heffalump: not that different
04:02:17 <Ig> We should have given our langauge as GHC 5.04 actually
04:02:26 <Heffalump> weren't we actually Haskell 98?
04:02:28 <ChilliX> essential the lightning entry plus a couple of hours extra work on the night before the deadline
04:02:33 <Heffalump> dunno about GHC specific libraries
04:02:39 <Ig> Well, I guess Haskell unqualified is pretty vague anyway
04:02:53 <ChilliX> we fixed two things
04:03:02 <Ig> We used hierarchial libraries a bit didn't we?
04:03:06 <ChilliX> * timeout routine to keep within the 1sec boundary
04:03:10 <Ig> Plus things like the Socket library
04:03:15 <Heffalump> true, but that's /almost/ Haskell 98 :-)
04:03:28 <ChilliX> * some more intelligence in dealing with other robots
04:03:32 <Ig> Hmmm  :-)
04:04:09 <Ig> Quite a few C entries
04:04:13 <Heffalump> chillix: the first would be fixing it to deal with CPU time as opposed to wall time? :-) (Julian Seward gave a talk to OxLUG on Sunday night and he was telling me about the manager thread which led to me pointing out the problem)
04:04:33 <Ig> Not that surprising I guess, it isn't a challenge that particularly lends itself to high-level languages
04:04:37 <ChilliX> Heffalump: that was fixed in the final entry
04:04:48 <ChilliX> quite annoying
04:04:52 <ChilliX> how did you deal with that
04:04:57 <Heffalump> ig: yeah, it was quite imperative in many ways
04:05:00 <Heffalump> chillix: we didn't
04:05:16 <Heffalump> it was somewhere on my to-do list but we didn't get a lot of things done I'd have liked to have
04:06:04 <Heffalump> with hindsight we should have started off agreeing some kind of top-level decision making process that focussed on making good use of the RAM/time limits
04:06:43 <Heffalump> but since our original design was basically "get data from server, work out what to do next in functional code, do it", that limited that kind of thing somewhat
04:07:30 <Ig> Once we had caching of Dijkstra stuff we could have done without a *vast* amount of work
04:07:50 <Heffalump> yeah, especially since we could have passed Dijkstra a limit of how much work it should do
04:08:25 <Heffalump> I think if any of us had heard of A* before we'd probably have used that, though I still haven't really looked into how it works so I don't know
04:09:53 <ChilliX> A* was mentioned by a few people
04:10:05 <ChilliX> why do you think it is that well suited to the problem?
04:10:15 <ChilliX> (I know A* and it didn't occur to me to use it)
04:10:24 <Ig> JS said you used it...
04:10:49 <Ig> We're guessing it was well suited as so many people did so
04:11:11 <Ig> What's your accent BTW?
04:12:05 <ChilliX> Ig: we used shortest-path based on priority queues
04:12:41 <ChilliX> it's pretty similar admitedly
04:13:04 <ChilliX> but out decision procedure is based on the subsumption architecture
04:13:52 <ChilliX> I have mentioned this to jens before: WHat did you guys think about the game rules?
04:14:10 <ChilliX> I think the way in which robots interact isn't very...aehm..sophisticated
04:14:20 <ChilliX> which means that a lot depends on luck
04:14:34 <ChilliX> in particular, it is easy to write malicious robots
04:14:55 <Ig> Being able to see other robot's bids might have meant it was possible to do something useful with them
04:14:57 <ChilliX> which can screw others in a multi-plkayer game up
04:15:12 <Ig> Without achieveing the goal themselves, you mean?
04:15:20 <ChilliX> exactly
04:15:50 <Ig> Not an awful lot of point, though  :-)
04:15:57 <ChilliX> it would have been better if a cleverly programmed robot could protect itself against this
04:16:05 <ChilliX> but I think, that's not possible
04:16:21 <Ig> Did you ever bid non-1?
04:16:37 <ChilliX> robots need not be malicious by intent, they can just be supidly programmed
04:16:51 <Ig> Very true
04:17:16 <ChilliX> moreover, I got the impression that if the worlds are not very vcarefully designed, a lot depends on luck in multi-player games
04:18:00 <ChilliX> eg, the same robot can score vastly differentyly just depending on it's starting position
04:18:01 <Ig> I agree
04:18:18 <ChilliX> vastly different as in factor of 7 between the scores
04:18:42 <Ig> And if there are any maps with narrow passages I don't think many packages will get delivered
04:18:42 <ChilliX> this indicates that the overall score may depend quite a lot on luck
04:18:55 <ChilliX> in multi-player scenarieos?
04:19:00 <Ig> Or maybe they will only run such maps with single robots
04:19:03 <Ig> Yeah
04:19:14 <ChilliX> what I implemented in the final entry
04:19:23 <ChilliX> is a strategy to keep out of the way of other robots
04:19:26 <ChilliX> to avoid tie ups
04:19:34 <ChilliX> it looks quite nice
04:19:44 <ChilliX> (I mean, the way the robot moves)
04:19:54 <ChilliX> but I am not convinced that it is all that good for scoring)
04:19:57 <Ig> Does it also avoid oscillating when the other robots move around?
04:20:07 <ChilliX> in a clash?
04:20:43 <ChilliX> or in the avoidance procedure?
04:21:10 <Ig> IM if you start between 2 places you want to go and you pick the less robot infested one, but then the one you have chosen becomes more infested, will you go to the other one instead?
04:21:18 <Ig> Thus potentially sitting in the middle oscillating
04:21:40 <ChilliX> we didn't get around to actually look for less invested areas
04:21:49 <ChilliX> (was on the todo list, though)
04:21:59 <ChilliX> but we avoid contacti8ng with individual bots
04:22:03 <ChilliX> like walk around them
04:22:19 <Ig> Ah, I see what you mean
04:22:28 <ChilliX> there is some chance for oscillating when both robots use exacly the same strategy
04:22:46 <ChilliX> but whenever there was a chance for that, I usually added some randomised parameter to the decision
04:22:53 <ChilliX> to break the cycle eventually
04:23:04 <ChilliX> (not sure whether that always works, though)
04:23:28 <Ig> :-)
04:25:45 <ChilliX> I am quite amazed about the number of submissions
04:26:30 <Ig> How does it compare to previous years?
04:26:43 <ChilliX> I am mean if you take in to account that it's quite some effort and that not that many fellow humans care that much about programming
04:26:54 <ChilliX> I think that it was about 110 or 120 last year
04:27:00 <ChilliX> it was way less the year before
04:27:10 <ChilliX> (last year was the first time it appeard on /.)
04:27:32 <ChilliX> so, last year, the organiser were quite...ahem...shocked
04:28:36 <ChilliX> hmm
04:28:44 <ChilliX> no, there seem to be actually 260 tar files, there
04:29:33 <Ig> % for i in "C++" OCaml Haskell Java Perl Python; do echo -n $i; grep -i $i entries.html | wc -l; done 
04:29:37 <Ig> C++     25
04:29:39 <Ig> OCaml     15
04:29:42 <Ig> Haskell     11
04:29:44 <Ig> Java     28
04:29:47 <Ig> Perl     12
04:29:49 <Ig> Python     19
04:30:05 <ChilliX> ok, found the info
04:30:09 <Ig> Oh, people write OCaml in different ways
04:30:09 <ChilliX> last year 171
04:30:21 <Ig> Caml     20
04:30:53 <Ig> Oh, give or take counting lightning entries twice
04:30:59 <jewel> notice java is the highest
04:31:47 <Ig> Oh, #dylan got second place last year
04:32:27 <ChilliX> jewel: no suprise here
04:32:59 <jewel> And the number of caml entries is double the no of haskell entries
04:33:14 <jewel> didn't know it was that popular
04:34:16 <ChilliX> Caml one the year before that
04:34:24 <ChilliX> since then, the caml entries went up :-)
04:34:30 <Ig> I can't find a list of teams/languages for last year
04:34:36 <ChilliX> neither can I
04:34:40 <ChilliX> it was on Xavier's slides
04:35:21 <ChilliX> you can imagine how excited SPJ was when Xavier had to announce at last ICFP that a Haskell entry one
04:35:35 <ChilliX> and he had to say the bragging thing
04:35:52 <ChilliX> one = won
04:36:15 <Ig> :-)
04:36:19 <ChilliX> (maybe OCaml wins this year and Xavier get's his revenge...)
04:36:29 <Ig> Is this the first time TeamGHC have entered?
04:36:34 <cleverdra> http://cristal.inria.fr/ICFP2001/prog-contest/results/all.html
04:36:43 <ChilliX> in this constalation, yes
04:37:13 <ChilliX> but I think some of the GHC people had participated before
04:37:20 <ChilliX> was the first time for me, though
04:37:24 <Ig> C++     20
04:37:25 <Ig> Caml     29
04:37:25 <Ig> Haskell     13
04:37:25 <Ig> Java     12
04:37:25 <Ig> Perl      4
04:37:27 <Ig> Python     10
04:37:29 <Ig> For 2001
04:37:39 <Ig> C++      4
04:37:39 <Ig> Caml     12
04:37:39 <Ig> Haskell      6
04:37:39 <Ig> Java      7
04:37:39 <Ig> Perl      4
04:37:42 <Ig> Python      1
04:37:44 <Ig> For 2000
04:38:06 <Ig> So it's only this year C++ and Java have really gotten huge
04:39:09 <ChilliX> still 20 C++ 
04:39:25 <ChilliX> in 2001
04:39:38 <Ig> Yeah, but 29 Caml
04:39:43 <ChilliX> in 2000 it was too a large degree FP languages
04:40:06 <ChilliX> as it was not announced on /. or some other language-neutral medium (maybe /. is Perl-centric though ;-)
04:41:04 * Ig realises we should have added bases to the list of places we'd like to go via when delivering packages
04:41:16 <Ig> :-)
04:41:36 <ChilliX> yeah, I didn't get around to this one either
04:43:00 <ChilliX> btw, what did Julian talk about at OxLUG?
04:43:04 <ChilliX> Valgrind?
04:43:14 <Ig> Yup
04:43:20 <ChilliX> Valgrind is cool
04:43:42 <Ig> Not usreful for sensible programming languages, though  :-P
04:43:52 <ChilliX> :-)
04:44:03 <ChilliX> *but* there are uses for C
04:44:04 <Ig> Bet yes, definitely cool
04:44:15 <ChilliX> like writing OS kernels ;-)
04:44:26 <Ig> Only because hardware can't interpret Haskell natively
04:44:32 <Heffalump> ig: I can think of a *huge* list of things we should have done :-)
04:44:53 <Ig> Heff: Yeah, but that one was just inserting about 10 characters
04:45:04 <Heffalump> ah :-)
04:46:14 <Heffalump> igloo: so you think Haskell is a suitable language for hardware to execute natively?
04:46:39 <Heffalump> oooh, paratrooper
04:46:49 <Ig> Given an infinite amount of RAM, possibly
04:49:04 <ChilliX> come on, every turing machine assumes an infinite amount of RAM! ;-)
04:49:33 <Heffalump> so how would you implement lambda abstraction etc in gates? :-)
04:50:03 <ChilliX> by creating a thunk!
04:50:52 <Ig> You can clearly port Linux and GHCi to hardware, so whether or not it is possible isn't really an issue
04:51:27 <Ig> And if you only want to write Haskell code you haven't lost anything. And it's faster.
04:51:34 <Heffalump> errm, remember the physical limitations on the size of chips
04:51:55 <Heffalump> cos of that, I'm not convinced you can "clearly" port them to hardware
04:52:00 <Ig> Hmmm
04:52:22 * tmoertel wants coffee
04:52:37 * Ig has no idea
04:52:41 <Heffalump> (I don't know what the physical limits are, assuming lots of money, current state-of-the-art engineering but no fundamentally new techniques, but I'm sure they exist)
04:52:47 * Heffalump wants lunch
05:50:39 <cleverdra> GPH is about performance.  Disappointing.
05:51:25 <Ig> What else could it be about?
05:51:55 <cleverdra> Ig - it could've been about Erlang-style concurrency.
05:52:27 <Ig> Is that a communicating processes style?
05:53:42 <cleverdra> I suppose so.  Erlang processes communicate by asynchronous message-passing.
05:54:26 <Ig> I wouldn't have expected GPH to do so then. Concurrent Haskell exists I think, but I've never looked at it
05:56:18 <cleverdra> Its unfinished tutorial starts with an example of parallizing fib, which is nifty in a performance sense but totally useless in dealing with real-world concurrency -- which is what I meant about it being disappointing.
05:57:08 * cleverdra has just started learning Haskell =)
05:58:06 <Ig> I don't read "parallel" and "concurrency" as being the same thing
05:59:10 <cleverdra> That was a hint, yes.
06:07:59 <ChilliX> cleverdra: for concurrency: http://haskell.org/ghc/docs/latest/html/base/Control.Concurrent.html
06:09:21 <ChilliX> or http://www.cse.unsw.edu.au/~chak/haskell/ports/
06:09:25 <ChilliX> which builds on the former
06:10:04 <cleverdra> Chillix - I just found the "Concurrent and Parallel" part of the user's guide =)  Thanks!
06:27:43 * ChilliX -> restart X, to test hacked DRM kernel module
06:37:12 * ChilliX is pleased with his hacking efforts and the speed of hardware-accelerated OpenGL on his laptop :-)
06:38:38 <Heffalump> are you doing anything interesting with openGL?
06:39:14 <ChilliX> no, just making it no crash X when any of the OpenGL screensavers runs on my laptop
06:39:18 <ChilliX> no = not
06:39:51 * ski says : Hi everybody !
06:40:07 <Heffalump> hi ski
06:40:29 <ChilliX> so far Intel and Dell have been quite successful at preventing a fully functional free X server for the i830 chipset in some laptop models using that chipset
06:40:33 * Heffalump thinks about upgrading ghc
06:40:49 <ChilliX> (not that I would call the proprietary one of XiG fully functional...)
06:41:16 <ChilliX> but now it works :-)
06:42:09 <ChilliX> you need to patch the i830 driver in X and two Linux kernel modules, though
06:42:37 * Heffalump hasn't got an i830, which is good as I don't fancy recompiling X
06:42:53 <ChilliX> I actually managed to do without recompiling all of X
06:43:22 <ChilliX> just the driver module for that particular chipset (which is dyamically loaded by the X server)
06:43:29 <Heffalump> ah, cool
06:43:55 <ChilliX> I am pretty pissed off with Intel and Dell, though
06:44:06 <ChilliX> they have been very uncooperative
06:44:19 <Heffalump> unfortunately voting with your feet and taking your money elsewhere is hard
06:44:34 <tmoertel> there's always PowerBook G4
06:44:38 <tmoertel> aka TiBook
06:44:39 <ChilliX> but I will do that
06:44:46 <ChilliX> my home machine is already an AMD
06:44:54 <Heffalump> do AMDs go well in laptops?
06:44:55 <ChilliX> I am, fed up with Intel
06:45:11 <Heffalump> and in general laptop support for Linux is rather patchy
06:45:18 <ChilliX> I think, Asus sells AMD-based laptops
06:45:30 <ChilliX> patchy is one thing
06:45:35 <ChilliX> but Intel refused to help us
06:45:38 <ChilliX> and Dell, too
06:45:44 * tmoertel types on ancient Linux-based laptop
06:45:47 <ChilliX> although for both it would have been very simple
06:45:55 <ChilliX> and this despite quite a number of people asking
06:46:25 <ChilliX> plus both ship broken BIOSes
06:46:34 <ChilliX> which led to the problems in the first place
06:46:44 <ChilliX> and then refuse to fix them
06:46:51 <ChilliX> not very customer friendly
06:47:24 <tmoertel> what's their excuse? "well, it works with WinXP"?
06:47:30 <ChilliX> exactly
06:47:42 <ChilliX> and do you know why it works with that?
06:47:54 <ChilliX> because the programmed around their broken BIOS
06:48:17 <tmoertel> or is it that their BIOS was broken for Win32?
06:48:28 <ChilliX> no, at least not that bad
06:48:36 <ChilliX> the BIOS is just crap
06:48:59 <ChilliX> and because the entirely ignore it in the Win driver (as in reimplement its functionality), they didn't notice/care
06:50:00 <ChilliX> but I'll get my revenge
06:50:07 <tmoertel> too bad openfirmware isn't more popular
06:50:31 <ChilliX> I have a web page about using Linux on the machine http://www.cse.unsw.edu.au/~chak/linux/c400.html
06:50:41 <ChilliX> and I am quite negative about both companies
06:50:49 <ChilliX> next thing, I'll post it on the XFree list
06:50:57 <ChilliX> which I know some of the Intel people read
06:51:32 <tmoertel> my guess is that there are some Intel engineers
06:51:33 <ChilliX> last time, this even made an Intel support person emailing me
06:51:36 <tmoertel> who would have helped through unofficial channels
06:51:38 <ChilliX> just to make empty promises
06:52:00 <ChilliX> I tried that without success (probably because I didn't knwo the right people)
06:52:20 <tmoertel> for these kinds of reasons my next laptop will probably be an Apple
06:52:32 <tmoertel> b.t.w. what's the state of GHC on PPC?
06:52:53 <ChilliX> it's supported on Mac OS X now
06:53:09 <tmoertel> via compile-to-C?
06:53:18 <ChilliX> guess so
06:54:13 <jewel> ChilliX:  I have a Dell Inspiron x200
06:55:24 <ChilliX> what chipset?
06:55:55 <ChilliX> some newer Dells use nVidia don't they?
06:58:06 <ChilliX> or do you mean Latitude x200?
06:58:30 <ChilliX> that has the same problem
07:00:03 <ChilliX> jewel?
07:02:40 <jewel> er latitude, yes
07:02:49 <jewel> it uses the 830M too
07:02:51 <ChilliX> ok, what are you doing so far?
07:03:00 <ChilliX> no X?  no Linux?
07:03:12 <jewel> I must confess I wasn't reading the earlier conversation
07:03:20 <jewel> just chimed in when I saw you were the C400 person
07:03:21 <ChilliX> what os are you rnning?
07:03:27 <jewel> I have X, linux
07:03:31 <jewel> sound, network
07:03:40 <jewel> sleep and suspend both work
07:03:43 <ChilliX> Know my page?
07:03:58 <jewel> but are there issues if you plug into and out of AC power with those modes
07:04:13 <ChilliX> I don't have any problems
07:05:05 <jewel> Yes, I've read your page, though not recently
07:05:25 <jewel> I haven't got the external firewire CD-ROM to work, but that's another matter
07:05:52 <ChilliX> the C400 doesn't use firewire for the CD-ROM
07:06:07 <ChilliX> so, have you used the patch from Jon Gans' page?
07:06:16 <jewel> Oh, and wireless works great. I just want to purchase a mini-PCI wireless card for it (lookign for a cheap  one)
07:07:05 <ChilliX> (I mean the patch for X)
07:07:09 <jewel> No I don't know about that patch
07:07:19 <ChilliX> so, how do you run X?
07:08:28 <jewel> I use that vanilla driver, let me check ...
07:08:37 <ChilliX> with only 256 colours?
07:08:57 <jewel> It's the i810 driver
07:09:12 <jewel> in 24bit mode
07:09:58 <jewel> I'm not exactly sure of the configuration, at some stage I was fooling around with X4.2 deb packages, but I did have it working before, perhaps not in true colour
07:10:02 <ChilliX> hmm, then I wonder whether Dell changed the BIOS for the x200
07:10:31 <ChilliX> it was always ok with 256 colours
07:11:12 <ChilliX> but the BIOS wouldn't allow the i810/i830 driver to use more colours in 1024x768
07:14:26 <jewel> Hmm, sorry my info isn't very reliable
07:14:39 <jewel> When I get a chance to do more laptop stuff I'll investigate
07:15:01 <jewel> My biggest issue is getting the suspend/resume to work properly
07:16:32 <jewel> ah, excellent, it appears to have the same modem
07:22:56 <jewel> http://people.debian.org/~jewel/dell/x200/
07:23:01 <jewel> some pictures there
07:23:17 * tmoertel builds robot proxy on Mac OS X w/ newly-installed GHC . . .
07:24:00 <ChilliX> nice
07:25:28 * tmoertel sees unpleasant "/usr/bin/ld: Undefined symbols: _recvAncillary, _sendAncillary"
07:26:20 <ChilliX> tmoertel: I vaguely remember having seen something similar on one of the list recently, but I am not entirely sure
07:26:38 * tmoertel digs through list archives
07:27:09 <ChilliX> guess, either glasgow-haskell-users or glasgow-haskell-bugs
07:28:10 <delYsid> hey
07:28:54 <ChilliX> Hi delYsid
07:47:33 * ChilliX is off for now
08:16:13 <dark> instance Functor (FiniteMap key) where
08:16:13 <dark>   fmap f = mapFM (const f)
08:16:17 <dark> Why isn't this standard?
08:21:10 <ski> is FiniteMap standard ?
08:22:14 <tmoertel> dark: my guess is because some uses of mapFM depend on the key, not just the element value, and fmap doesn't have those semantics
08:24:09 <tmoertel> nevertheless, I agree that mapFM (const f) probably makes the most sense
08:24:53 <dark> tmoertel: It makes for much cleaner code if I just want to transform the elements, anyway :)
08:25:40 <tmoertel> one could also use:
08:25:56 <tmoertel> fmap f = mapFM (curry f)
08:26:17 <Heffalump> yeah, but would that be a functor?
08:26:28 <dark> ski: Hmm I don't think it's in haskell98, but it comes with ghc :)
08:26:50 <Heffalump> in fact it certainly wouldn't be a functor
08:26:59 <tmoertel> Heffalump: but it does satisfy the type constraint:
08:27:10 <tmoertel> forall f a b. (Functor f) => (a -> b) -> f a -> f b
08:27:19 <Heffalump> no it doesn't
08:27:26 <tmoertel> you're right ;
08:27:42 <Heffalump> anyway, got to vanish
08:27:47 * tmoertel needs more coffee
08:31:38 <ski> dark : so is it ghc + hugs standard then ? or only ghc ?
08:34:27 <dark> ski: Both.
08:35:57 <ski> ok
09:16:23 <Ig> Aha, it can't cope with ([[2],[1,1]], [1,1,1,1])
09:17:48 <ski> what can't cope with that ?
09:17:57 <Ig> My nonogram solver
09:18:19 <ski> what is a nonogram ?
09:18:23 <Ig> Or my some-nonogram solver  :-)
09:18:25 <Ig> Ermmm
09:18:55 <Ig> http://www.puzzlemuseum.com/griddler/griddler.htm
09:20:19 <ski> ok, i think i get it
09:21:50 <ski> i think i will try a little to see if i can make a (partial ?) solver for nonogram puzzles.
09:23:24 * Ig works out I could probably fix it fairly easily and still have it perform acceptably on sensible sized nonograms. I think I'll have a go later
09:39:49 <tmoertel> anybody interested in visualizing ICFP contest robot games?
09:42:49 * tmoertel has to run an errand . . . b back soon
10:08:48 * Heffalump appears
10:13:30 <redcrosse> Heffalump: hash-haskell's robot's name is Postman, right?
10:14:18 <Heffalump> yep
10:14:22 <Heffalump> there's another one called postman
10:14:26 <redcrosse> ah...
10:14:39 <redcrosse> i saw a postman here: http://vortex.netdragons.com/~vagabond/
10:14:46 <redcrosse> just wondering if it was you guys
10:15:01 <Heffalump> MIMteam
10:15:01 <Heffalump> postman
10:15:03 <Heffalump> Ocaml
10:15:05 <Heffalump> is the other one
10:15:29 <Heffalump> I can't get to that site.
10:15:38 <Heffalump> oh, yes I can
10:16:30 <Heffalump> I think they must mean the other postman, since we've only given our binary to the Dylan people, afaik
10:16:38 <redcrosse> ok
10:17:12 <Heffalump> it would be nice if they were referring to us :-)
10:17:22 <redcrosse> yeah, it did pretty well
10:18:14 <Heffalump> the CPU time behaviour they describe seems plausible for us, though
10:18:58 <redcrosse> guess he should have used team name instead of robot name
10:19:00 <Heffalump> given that they don't have a link, perhaps they got our binary from one of us or from the dylan people
11:16:57 <jewel> we can hope
11:20:25 <loom2> re
11:24:13 <jewel> heya loom2
11:24:27 <jewel> interesting that these people talk about package hiding
11:24:29 <loom2> hey jewel
11:24:38 <jewel> does it really make sense to do that?
11:25:14 <loom2> i don't think so...
11:27:05 <tmoertel> hiding seems like a reasonable ploy
11:27:16 <Heffalump> in what context?
11:27:35 <tmoertel> when there are more packages than you can carry
11:27:53 <Heffalump> oh, cunning.
11:28:00 <Heffalump> errm, but "drops" get reported
11:28:32 <jewel> and you waste time ferrying them
11:28:40 <jewel> when someone could grab remaining packages
11:28:43 <tmoertel> true. in that case, you could only hide packages from dumb bots
11:28:55 <loom2> and you'll win against them anyway.
11:29:09 <tmoertel> so, hiding doesn't seem that effective after all
11:29:51 <Ig> We ought to find hiden packages if we approach from the right side and there aren't walls and things in the way
11:30:28 <Ig> But if they hide round corners or towards the outskirts of the board they might do well against us
13:50:59 <dark> Gah.  Now my main_loop function uses identifiers world, world', world'', and world'''.
13:51:04 <dark> Something is wrong :)
14:01:35 <tmoertel> dark: combinators are your friend
14:01:54 <toadx> combinators are tasty and tart
14:01:59 <Heffalump> how would they help him?
14:02:53 <tmoertel> you can create combinators to pass the state through
14:03:02 <tmoertel> rather than passing it by hand
14:03:17 <Heffalump> what kind of combinators?
14:03:30 * tmoertel tries to find an example in his code . . .
14:03:45 <Heffalump> there's a state monad, of course
14:07:52 * tmoertel found one . . .
14:08:54 <dark> I'd like to use the State monad but I already need the IO monad :)
14:09:15 <Heffalump> you can stack a ST monad on top of IO
14:09:21 * Heffalump does that in some code of his
14:09:24 <dark> Fortunately I can limit IO mostly to this main loop.
14:09:41 <dark> Heffalump: Hmm... would that help?  I'd have STrefs instead of IOrefs, right?
14:10:03 <Heffalump> sorry, not an ST monad
14:10:06 <dark> ("mostly" because some of the sub actions can schedule IO actions to be performed later in the main loop...)
14:10:09 <Heffalump> I meant your own State monad
14:10:20 <Heffalump> using a monad tranformer
14:10:23 <dark> Heffalump: Oh, cool.  You mean write a StateT for IO?
14:10:24 <Heffalump> newtype StT a m b = StT (a -> m (b, a))
14:10:28 <Heffalump> instance Monad m => Monad (StT a m) where
14:10:28 <Heffalump>     return a = liftSt (return a)
14:10:29 <Heffalump>     StT x >>= f = StT (\s -> x s >>= \(v,s') -> applSt (f v) s')
14:10:29 <Heffalump>     fail str = liftSt (fail str)
14:10:38 <Heffalump> well, a StateT for anything, which you then apply to IO
14:10:52 <Heffalump> applSt :: Monad m => StT a m b -> a -> m (b,a)
14:10:52 <Heffalump> applSt (StT g) y = g y
14:10:53 <dark> Control.Monad.State already defines a StateT :)
14:10:55 <Heffalump> liftSt :: Monad m => m b -> StT a m b
14:10:55 <Heffalump> liftSt m = StT (\s -> m >>= \v -> return (v,s))
14:10:59 <Heffalump> oh :-)
14:11:08 <Heffalump> my code is intended to work with hugs too
14:11:23 <Heffalump> and I wrote it well before hierarchical libraries came along
14:11:30 <dark> Hmm, if I do that, then maybe I can write most of the program in StateT IO.  But that does mean IO everywhere, instead of just State everywhere :)
14:11:56 <Heffalump> it ought to be possible to drop from StateT IO into StateT ()
14:12:04 <Heffalump> in the same way as you drop from IO in to pure functions
14:12:06 <Heffalump> TICBW
14:12:12 <Heffalump> anyway, bedtime for me.
14:12:16 <Heffalump> cya tomorrow.
14:12:19 * Heffalump disappears
14:17:29 * tmoertel puts combinators example on web site . . .
14:19:29 <tmoertel> it's http://www.moertel.com/~thor/parse-comb.txt
14:31:54 <Knuth> hi all. can anyone tell me how i can use hugs to execute haskell code
14:32:10 <Knuth> i first heard about haskell 10 minutes ago so i would like to try it
14:37:33 <dark> Sorry, I never used hugs.  I went straight from gofer to ghc.
14:38:49 <tmoertel> Knuth: you might want to see http://cvs.haskell.org/Hugs/pages/hugsman/index.html
14:39:18 <tmoertel> especially section 3
14:40:32 <Knuth> cool tmoertel thanx
14:42:42 <Knuth> l8er
14:50:02 <dark> Coolness... I can now run around the map and open and close doors, in my Haskell roguelike :)
14:50:34 <tmoertel> dark: excellent!
14:51:00 <dark> Maybe the next step will be items and inventory.  Or maybe monsters and combat :)  Not sure.
14:51:18 <tmoertel> combat will be hard w/o weapons ;-)
14:51:36 <dark> Or I can do a simple level generator, so that I have something more interesting to run around and close doors in :)
14:51:50 <dark> tmoertel: Well, the monsters will be unarmed too :)
14:52:20 <tmoertel> "you hurl yourself at the grid bug!"
14:52:26 <dark> ZAP :)
14:52:49 <dark> "You punch the cockatrice on the nose.  Uh-oh."
14:55:05 <dark> Actually, inventory is going to require some more design.  I want something more detailed than the usual "cloud of items that follows you around" model :)
14:58:25 <dark> For example, you can wear a belt.  Then you can hang a scrollcase from the belt.  You can put a scroll in the scrollcase.  You could stuff two scrolls in there, but that makes it harder to take out and read just one.
14:58:57 <dark> You can also wear a backpack, and get the "random bag of items" model back, but rummaging around in your backpack in mid-combat can be dangerous.
14:59:03 <dark> This is similar to the model used by Omega :)
15:04:18 <tmoertel> As long as I can foldr through the contents of my backpack ;-)
15:05:04 * tmoertel must walk the dog now . . .
15:05:15 <tmoertel> food for thought while I'm gone: http://tea.moertel.com/~thor/ravt/
15:13:58 <dark> tmoertel: Ooh, a curses module :)
15:15:07 <jlk> hello.
15:16:33 <jlk> where is a good tutorial on haskell?
15:22:43 <toadx> there are some at: http://www.haskell.org/bookshelf/ if you scroll down, but I have not really found any really comprehensive tutorials for haskell
15:26:17 * shapr boings
15:26:39 * shapr boings
15:28:05 <jlk> toadx, then how can I learn?
15:28:38 <toadx> well, I would still start with the tutorials
15:28:40 <jlk> oh.
15:28:46 <jlk> there is alot there.
15:29:16 <toadx> I didn't read all of them either, so there might be some real gems
15:29:44 <jlk> how is haskell on opengl?
15:30:03 <jlk> thank you toadx.
15:30:03 <jlk> :)
15:30:12 <toadx> try this one maybe: Yet Another Haskell Tutorial by Hal Daume III et al
15:30:21 <shapr> yah, that's a good tutorial.
15:31:00 <toadx> I have only done a little haskell+OpenGL but it worked pretty damn good for what I was doing
15:31:24 <jlk> which is the best version of haskell?
15:32:09 <jlk> are the runtimes free distribution? :)
15:32:10 <shapr> the latest :-)
15:32:13 <shapr> yup
15:32:20 <jlk> oh i like. :)
15:32:29 <jlk> share-ware games
15:33:24 <toadx> jlk: I use GHC, but I could not tell you if its the best
15:34:25 <jlk> how about windows type controls?
15:34:40 <toadx> like drop boxes and stuff?
15:34:46 <jlk> (ie database applications)
15:34:52 <jlk> yeah.
15:35:07 <shapr> er, how are database apps and windows controls similar?
15:35:23 <toadx> specifically for Microsoft Windows?
15:37:00 <jlk> yes windows. or multiplatform.
15:37:23 <toadx> There are a few, here is one: http://haskell.cs.yale.edu/ObjectIO/
15:37:28 <jlk> shapr, ie. means example.
15:37:47 <shapr> yah, I know what ie means
15:38:06 <shapr> what's a window control?
15:38:13 <toadx> I think ObjectIO is cross platform, but uses the native controls for each platform.
15:39:02 <jlk> I'm sure haskell handles dll linking, right?
15:39:13 <redcrosse> jlk: i haven't tried it, but you could use this (http://galois.com/~sof/hugs98.net/) for windows systems
15:41:30 * tmoertel returns from walking the dog
15:41:36 <shapr> hi tmoertel, what's up?
15:41:55 <tmoertel> just doing a little hacking on http://tea.moertel.com/~thor/ravt/
15:42:05 <jlk> great.
15:43:52 <shapr> tmoertel: neeto!
15:44:04 <jlk> yeah, this is nice.
15:44:07 <jlk> hey...
15:44:14 <tmoertel> jens is writing an OpenGL-based visualizer, right?
15:44:23 <tmoertel> maybe he can plug into what I have already done
15:44:27 <shapr> gtk2 visualizer
15:44:43 <shapr> the dylan guys did an OpenGL visualizer, though neither Heffalump nor I could get it to run.
15:44:47 <tmoertel> that makes more sense. 3d would have been gratuitous
15:45:01 <tmoertel> those darn dylan guys! ;-)
15:45:04 <shapr> heh
15:45:16 <shapr> I hope the ICFP judges release their server source
15:45:26 <shapr> that would make the RAVT much more powerful.
15:45:32 <jlk> I'm coming from lisp. How much more compact is code comparitively speaking in haskell? 
15:45:45 <tmoertel> it sure would make it much easier to deduce the state of the server
15:46:01 <shapr> jlk: quite a bit more in some cases.
15:46:10 <tmoertel> jlk: it depends on how much you use macros in lisp
15:46:55 <jlk> for sake of creation lets for now say no macros.
15:46:59 <tmoertel> if you're a macro master, you can probably create lisp as compact as haskell
15:47:21 <tmoertel> if you don't use macros, you're haskell code will likely be much more compact
15:47:23 <shapr> tmoertel: I've heard Template Haskell will be released at the ICFP
15:47:32 <shapr> finally, we will have Haskell Macros!
15:47:44 * tmoertel jumps for joy!
15:47:51 * shapr laughs
15:47:54 <jlk> $3k to $8k for allegro lisp.
15:47:58 <jlk> hah!
15:48:12 <tmoertel> why not cmu lisp or gnu lisp?
15:48:22 <tmoertel> $0
15:48:27 <dark> shapr: Sounds like overkill to me:)
15:48:29 <jlk> shapr, were is this held?
15:48:57 <jlk> tmoertel:cmu is buggy.
15:49:02 <jlk> :P
15:49:05 <dark> Though it would be nice to be able to define my own "deriving" clauses.
15:49:15 <jlk> gnu lisp is not updated.
15:49:29 <jlk> clisp is good.
15:49:33 <tmoertel> that's sad, regarding cmu and gnu lisps
15:49:34 <shapr> dark: quickCheck and HUnit will be able to build their TestLists
15:49:49 <tmoertel> this year ICFP is held in Pittsburgh, Pennsylvania
15:50:28 <toadx> allegro is just better all around
15:50:33 <jlk> Hey, what format can haskell compile to? P code or binary?
15:50:34 <toadx> except cost
15:50:45 <shapr> jlk: binary
15:50:50 <shapr> with a run time system
15:50:52 <jlk> tmoertel, a weekend I hope.
15:51:04 <jlk> oh nice.
15:51:04 <dark> shapr: I'm going to need a shortest path discovery algorithm for the monsters in my roguelike game.  Any chance I could use one from a robot?
15:51:04 <tmoertel> GHC compiles to binary, Hugs uses internal interpreter
15:51:33 <shapr> dark: it's Dijkstra's in the robot... everyone else seems to have used something called AStar that we'd never heard of
15:51:35 <tmoertel> jlk: yes 4-6 october: http://icfp2002.cs.brown.edu/
15:51:40 <shapr> or at least, I had never heard of
15:51:46 <dark> shapr: Thanks, I'll google :-)
15:52:02 <tmoertel> A* is a directed breadth-first search
15:52:05 <shapr> dark: hey, if you're going to stop working on uncc, will you release the source?
15:52:11 <shapr> I'd very much like to read it.
15:52:17 <tmoertel> heuristic directed, that is
15:52:30 <dark> shapr: I'm not going to stop working on it :)
15:52:32 <shapr> tmoertel: I should have tried harder to get you on the team =)
15:52:42 <dark> shapr: But yeah... maybe I should put it up for http somewhere.
15:52:49 <tmoertel> I didn't compete this year owing to time contraints
15:52:58 <tmoertel> but next year, I'll team up w/ you if you want
15:53:03 <shapr> yay!!!
15:53:06 <dark> Heh, "A*" is hard to google for :)
15:53:09 <tmoertel> and the #haskell crowd
15:53:29 <tmoertel> the problem w/ A* is that if the heuristic isn't good, it degrades into a BFS
15:53:38 * shapr bounces happily
15:53:39 <dark> shapr: I'm learning a lot more by working on two different projects, though :)
15:53:42 <Ig> Dijkstra is a heuristic directed breadth-first search too
15:53:45 <redcrosse> dark: i saw this (http://www.norvig.com/paip/search.lisp) on one of the team pages
15:53:53 <redcrosse> i guess that's a* in lisp
15:53:56 <Ig> Well, I'm not sure if the term "Dijkstra" alone implies the heuristic
15:54:32 <redcrosse> it's from "paradigms of ai programming" by norvig
15:55:29 <tmoertel> one of the best survey's on searching is by Korf
15:55:42 <tmoertel> s/survey's/surveys/
15:55:52 <shapr> dark: yah, that's a good point.
15:56:10 <shapr> I learned a tremendous amount from the ICFP contest, mostly by osmosis from the code (and code changes) of others.
15:56:44 <dark> shapr: All the little tricks that others use?
15:57:01 <shapr> yah, some of that
15:57:23 <shapr> it helps me to watch the steps that other people go through in their code
15:57:47 <dark> redcross: Curious, I don't see the heuristic :)
15:57:52 <ChoJin> what is icfp contest ?
15:58:18 <shapr> ChoJin: http://icfpcontest.cse.ogi.edu/
15:58:21 <dark> Unless it's the "exploring the least cost first" part, but that seems obvious.
15:58:40 <dark> shapr: Seeing Heffalump explain stuff on #haskell helps :)
16:01:09 <redcrosse> dark: sorry... i didn't actually read it myself. just saw that they mentioned it.
16:01:52 <redcrosse> dark: http://www.bluetail.com/~luke/icfp2002/
16:01:57 <redcrosse> that's the team if you're interested
16:02:03 <redcrosse> they did their entry in erlang
16:02:45 <shapr> Luke Gorrie
16:02:50 <shapr> he was threating to do his in elisp this year
16:03:11 <dark> No entries in Intercal? :)
16:03:20 <tmoertel> blue avengers had an excellent lightning entry last year
16:05:39 <shapr> I need to write up something on test driven development in Haskell.
16:05:48 <shapr> I wonder how that would work with QuickCheck
16:06:43 <shapr> Heffalump had a good idea to extend QuickCheck by saving the generated cases that fail the property test, and then adding those to a list of semi-static tests.
16:07:05 <shapr> I think that's a neat way of adding HUnit style testing to QC
16:10:00 * tmoertel takes a break to eat
16:13:28 * shapr bounces
16:13:34 <shapr> bok Knuth
16:13:46 <Knuth> hehe bok shapr. otkud si
16:13:57 <shapr> Knuth: sadly, that's about all the .hr I know :-)
16:14:05 <Knuth> :)))
16:14:35 <shapr> I can only converse in english and (somewhat) in french
16:14:51 <Knuth> otkud si means "where are you from"
16:14:55 <shapr> oh, neat!
16:14:58 <Knuth> thought you were croatian too
16:15:08 <shapr> nah, I've just know some.
16:15:17 <shapr> I'm from the USA, where are you from?
16:15:26 <Knuth> croatia :)
16:15:38 <shapr> ah, I see.
16:15:43 <shapr> are you studying functional programming there?
16:16:03 <Knuth> nope heard about haskell for the first time about an hour ago. (btw which state)
16:16:11 <shapr> I'm from the state of Alabama!
16:16:48 <Knuth> i am very interested in haskell. seems like a good 'nuff language to learn. (cool. i'd sure like to visit the US someday.)
16:16:50 <shapr> Alabama is mostly famous for bad things. Some good music did start there though.
16:16:58 <shapr> Yah, Haskell is great!
16:17:07 <shapr> Do you have prior programming experience?
16:17:26 <Knuth> some. basic, then pascal, now c and lisp
16:17:41 <shapr> Cool, if you've used lisp then Haskell will be easier to understand.
16:17:42 <Knuth> should suffice?
16:17:53 <Knuth> but i've used lisp for a short while
16:17:53 <shapr> Jumping from C to Haskell would be very exciting.
16:18:20 <Knuth> actually i used part of the summer to learn c and lisp
16:18:25 <Knuth> so i'm quite new to those too
16:18:28 * toadx jumped from C->LISP->Clean->O'Caml->Haskell ... it was exciting
16:18:29 <shapr> that's a good summer project.
16:18:43 <Knuth> heh yup.
16:18:59 <Knuth> i'm 17, going to third grade of high school in a week
16:19:01 <Knuth> you?
16:19:01 <shapr> toadx: I'll be jumping from Haskell to Mercury sometime in the next n years. after that, I have to renew my list.
16:19:17 <shapr> I'm just about to be 31, I'm a professional programmer.
16:19:41 <shapr> I've been living in Finland for about three years, and I'm about to move to Sweden.
16:20:03 <shapr> and I love programming!!
16:20:13 <Knuth> cool!
16:20:17 * shapr bounces
16:20:23 <Knuth> lol
16:20:31 * toadx remembers that he started with basic->pascal->c
16:20:47 <shapr> I'd suggest that you download some of the online tutorials and read through them, and ask questions here while yeou're reading.
16:20:47 <Knuth> btw any of you guys read taocp?
16:20:59 <toadx> some of it
16:21:02 <shapr> I haven't read it. Have you read sicp?
16:21:10 <Knuth> sicp=...?
16:21:16 <Knuth> taocp rules imho
16:21:25 <shapr> structure and interpretation of computer programs by abelsson, abelsson, and sussman
16:21:36 <Knuth> nope
16:21:36 <shapr> I think SICP rulez!
16:21:41 <Knuth> sounds cool though
16:21:47 <shapr> hi delYsid!
16:22:01 <toadx> http://ibiblio.org/Dave/Dr-Fun/df200002/df20000210.jpg (in case you have not seen it)
16:22:03 <shapr> Knuth: my number one book I recommend to programmers is SICP
16:22:23 <delYsid> yes, SICP just rocks
16:22:33 <ChoJin> what is sicp ?
16:22:37 <delYsid> hey shapr
16:22:42 <Knuth> really? i guess i better check my local bookstore for it then id like to check it out
16:22:46 <shapr> ChoJin: Structure and Interpretation of Computer Programs
16:22:47 <Knuth> better than taocp?
16:22:50 <delYsid> ChoJin: http://mitpress.mit.edu/sicp/
16:22:55 <shapr> Knuth: sicp is a free download!
16:23:03 <ChoJin> need to look in the laboratory if we have it
16:23:03 <shapr> I haven't read taocp, so I can't compare them.
16:23:20 <Knuth> shapr: free? you're kidding.
16:23:27 <shapr> it's free!
16:23:31 <delYsid> HTML completely available online
16:23:37 <delYsid> including samples and all that...
16:23:45 <shapr> I still bought the book because I wanted to have the hardcopy, but you can get it free first.
16:23:51 <shapr> it's like drugs... the first one is free...
16:23:57 <shapr> the other computer books cost lots of money.
16:23:58 <Knuth> sick
16:24:00 <Knuth> hehe
16:24:05 * shapr grins
16:24:31 <ChoJin> I don't see a pdf or postscript version
16:24:37 <delYsid> There is also a realmedia lecture recording of SICP 1986@MIT
16:25:00 <delYsid> ChoJin: Who needs pdf anyway?!
16:25:27 <Knuth> how can i dl it
16:25:28 <ChoJin> I need ps
16:25:29 <ChoJin> :)
16:25:35 <ChoJin> to print it
16:25:35 <Knuth> i can only see the html version
16:25:48 <delYsid> Knuth: Right, then, read it :)
16:26:13 <Knuth> hehe right
16:26:18 <delYsid> ChoJin: If you print sicp :), hehe, it will probably be cheaper to buy the book.
16:27:05 <Knuth> ok i have a question about haskell.
16:27:12 <shapr> yes?
16:27:20 <ChoJin> delYsid: I don't pay printing :)
16:27:36 <ChoJin> and with a2ps -s2 -4 it print 8 page on 1 :)
16:27:49 <Knuth> are the programs for it compiled and then executed or are they in the form of...
16:27:55 <Knuth> well...
16:28:03 <shapr> Knuth: mostly they are compiled
16:28:06 <Knuth> expressions which can be evaluated as in lisp
16:28:11 <Knuth> ok
16:28:14 <shapr> but there is Hugs and GHCi which are interpreted.
16:28:21 <Knuth> i see
16:28:29 <Knuth> i would like to use emacs as my editor
16:28:36 * Knuth loves emacs.
16:28:42 <shapr> I'm using ERC 2.93 $Revision: 1.294 $ with XEmacs 21.4 (patch 8) "Honest Recruiter" XEmacs Lucid!
16:28:46 <shapr> emacs is my irc client.
16:28:51 <delYsid> I'm using ERC 2.93 $Revision: 1.298 $ with Emacs 21.3.50.1!
16:28:56 <Knuth> heh cool
16:28:58 <ChoJin> Knuth: isn't hard to have this nick ? :)
16:28:58 <shapr> look, it's his irc client too!
16:29:02 * shapr grins
16:29:15 <Knuth> ChoJin: why?
16:29:28 <ChoJin> well, the comparaison is high
16:29:31 <delYsid> shapr: do you know that hober wrote a bot in elisp/erc for #emacs?
16:29:40 <dark> http://www.geocities.com/jheyesjones/astar.html
16:29:40 <Knuth> ChoJin: oh. lol
16:29:44 <dark> "A* Tutorial" :)
16:29:44 <shapr> yah, I saw him today on #emacs, it's cool!
16:30:05 * toadx is also using ERC
16:30:11 <Knuth> ok so, how can i set up emacs to work in haskell
16:30:14 <delYsid> heh, cool!
16:30:16 * delYsid is happy
16:30:18 <shapr> delYsid: I'm still interested in a Haskell irclib
16:30:25 <Knuth> i have hugs and hate it
16:30:31 <shapr> Knuth: what linux distro are you using?
16:30:38 <shapr> hugs is not bad
16:30:43 <shapr> it's just not an editor
16:30:52 <Knuth> using lfs
16:30:58 <Knuth> Linux From Scratch
16:31:05 <delYsid> heh, hardcore :)
16:31:09 <Knuth> yup :)
16:31:28 <ChoJin> btw for those who don't know: http://www.bagley.org/~doug/shootout/
16:31:33 <ChoJin> ocaml have a really good place :)
16:31:34 <shapr> well then, download the haskell-mode.el from haskell.org
16:31:39 <Knuth> i did
16:31:43 <shapr> install it
16:31:48 <Knuth> did
16:31:54 <delYsid> use it :)
16:31:57 <shapr> right
16:31:58 <Knuth> ?
16:32:02 <Knuth> how :)
16:32:06 <shapr> M-x turn-on-haskell-hugs to get hugs
16:32:15 <shapr> or M-x turn-on-haskell-ghci to get GHCi
16:32:29 <shapr> quite a few useful haskell editing bits in the haskell-mode
16:32:40 <Knuth> i dont have M-x turn-on-haskell-hugs
16:32:50 <shapr> have you loaded haskell-mode.el ?
16:32:51 <Knuth> i only have M-x haskell-hugs-mode
16:32:56 <shapr> M-x load-library haskell-mode
16:33:16 <Knuth> cannot open load file haskell-mode
16:33:22 * delYsid is considering filing a bug against haskell-mode in debian
16:33:25 <shapr> what about locate haskell-mode.el ?
16:33:28 <shapr> delYsid: what's the bug?
16:33:33 <shapr> the prompt with ghc5.04 ?
16:33:37 <delYsid> It puts its files directly into /usr/share/emacs/site-lisp/, without its own subdir
16:33:41 <shapr> oh
16:33:44 <Knuth> no such file
16:33:47 <shapr> delYsid: yah, file a bug
16:33:52 <shapr> Knuth: then you need to download it from haskell.org
16:33:57 <Knuth> i did!
16:33:59 <Knuth> oh wait
16:34:02 <Knuth> i have it..
16:34:03 <Knuth> under...
16:34:07 <Knuth> ~/haskell
16:34:21 <delYsid> shapr: will have to wait till I have a patch...
16:34:22 <shapr> well then, load it up
16:34:27 <shapr> delYsid: good point.
16:34:30 <delYsid> for simple things like that, I should really supply a patch too
16:34:35 <shapr> yah, I agree.
16:34:42 <shapr> I submitted a patch for the silly prompt bug.
16:34:59 <Knuth> ok turned on hugs
16:35:06 <delYsid> saw one of your bugreports against hOpenGL :)
16:35:25 <Knuth> how do i write a program now? hit me with the simplest example
16:35:29 <shapr> I still haven't followed that one to the end.
16:35:35 <shapr> module Main where
16:35:40 <delYsid> shapr: we have support for Gnus -> bugs.debian.org now, browse bugreports in summary buffers...
16:35:44 <shapr> main = putStr "hello world!"
16:35:56 <shapr> delYsid: oh spiffy!! where do I get that? how does it work?
16:36:18 <delYsid> shapr: ftp://ftp.tugraz.at/incoming/nnwebbugs.el
16:36:42 <delYsid> for my latest version (In Group buffer, do `G w debbugs RET package-name RET' after you loaded it
16:36:45 <Knuth> hmmm btw how can i make hugs turn on when i edit a hs file
16:37:14 <delYsid> You can also use maintainer@email instead of package-name there.
16:37:45 <shapr> Knuth: you can change your mode-alist (?) to turn on haskell-mode when editing .hs .lhs or etc
16:38:00 * shapr looks for the real name of that var
16:38:11 <shapr> ah, auto-mode-alist
16:38:19 <Knuth> oh i see i have it under .emacs
16:38:23 <shapr> for example: (setq auto-mode-alist (cons '("\\.sql$" . sql-mode) auto-mode-alist))
16:38:51 <ChoJin> shapr: btw, i am maintainer and co-maintainer for cwi-* package now :)
16:38:52 <Knuth> oh now that i have entered the program under emacs...
16:38:58 <shapr> ChoJin: awesome!
16:39:00 <Knuth> should i save it or...
16:39:05 <shapr> ChoJin: I still haven't gotten those to compile and run :-/
16:39:18 <ChoJin> dont try to compile it, its a nightmare
16:39:20 <shapr> Knuth: is the buffer in haskell-mode?
16:39:22 <delYsid> what's that cwi- stuff about anyway?
16:39:24 <ChoJin> thats why we are building package :)
16:39:27 <Knuth> yep i think
16:39:43 <shapr> delYsid: a generic syntax -> abstract syntax tree & abstract tree transformation setup
16:39:47 <ChoJin> shapr: we have all stratego package now, I am working on other to have "xt"
16:40:09 <delYsid> ic
16:40:11 <shapr> delYsid: I tried to persuade the Haskell refactoring guys to use that setup...
16:40:20 <shapr> they said they much prefer a pure haskell solution
16:40:43 <Knuth> shapr: how do i get the program to run now?
16:40:51 * delYsid shakes head
16:40:59 <shapr> they also said that learning emacs and several other frameworks was much overhead for the average user.
16:41:01 <delYsid> code should be rewritten by human brain power
16:41:15 <ChoJin> delYsid: you have a SGLR grammar (named SDF) and a bunch of tool to manipulate AST with a very elegant manner (and natural !)
16:41:37 <shapr> Knuth: if the buffer is in haskell-mode, and you've done M-x turn-on-haskell-hugs or M-x turn-on-haskell-ghci, depending on which one you want to use
16:41:48 <shapr> then you can hit C-c C-l to dump your buffer into hugs or ghci
16:41:52 <ChoJin> delYsid: see at http://www.lrde.epita.fr:800/cgi-bin/twiki/view/Projects/Transformers you will found some url 
16:41:59 <shapr> assuming everything works of course...
16:42:03 <Knuth> ok it worked
16:42:06 <shapr> yay!
16:42:07 <Knuth> but how do i run it?
16:42:10 <Knuth> hehe
16:42:15 <Knuth> now i have the prompt
16:42:16 <shapr> type "main" and hit enter
16:42:16 <Knuth> Main>
16:42:24 <shapr> er, without the quotes
16:42:25 <Knuth> WHOA!
16:42:27 <Knuth> RULEZ!
16:42:30 * shapr grins
16:42:53 <Knuth> now i know what they meant by "modular programming" hehe
16:42:55 <delYsid> comint-modes just rock :)
16:43:02 <Knuth> so you just need to enter the module name right?
16:43:13 <shapr> nah, in that case you typed a function name
16:43:27 <Knuth> hmmm
16:43:44 <shapr> if you want to see some interactive haskell stuff, try typing "[1..5]"
16:43:51 <shapr> or "1 + 1"
16:43:53 <ChoJin> btw in haskell mode my pc-select-mode become crazy
16:43:57 <delYsid> Hmm, are there any plans to make a ncurses interface to ObjectIO? I guess not
16:43:59 <ChoJin> anyone know why ?
16:44:09 <shapr> ChoJin: what kind of crazy?
16:44:18 <Knuth> heh cool. haskell kicks major butt.
16:44:23 <ChoJin> (I cannot use shift-Suppr shift-insert)
16:44:27 <shapr> Knuth: or try "map (+1) [1..5]"
16:44:36 <shapr> what's shift-Suppr ?
16:44:39 <Knuth> cool
16:44:39 <ChoJin> shift up/down ... work (to select)
16:44:52 <ChoJin> shapr: like under DOS/windows: cut/paste...
16:45:17 <shapr> ChoJin: I'd guess it's haskell-mode itself, which also has some other weird settings.
16:45:32 <delYsid> pythag:: [(Int,Int,Int)]
16:45:32 <delYsid> pythag = [(a,b,c) | c<-[2..], b<-[2..c-1], a<-[2..b-1], a<b, a^2+b^2 == c^2]
16:45:36 <delYsid> -- heh, isn't that cute
16:46:00 <Knuth> jeez its 2 am already...
16:46:07 <shapr> yes it is
16:46:10 <shapr> 3am here
16:46:19 <Knuth> heh cool
16:46:35 <ChoJin> I don't think it is the most efficient way :))
16:46:38 <Knuth> i should prolly get some sleep: i just returned from the seaside today...
16:46:41 <Knuth> er...yester-day
16:46:46 <delYsid> I still want a lazy pi
16:46:49 <shapr> Knuth: well, come back and we'll teach you more!
16:46:53 <Knuth> and havent slept really
16:47:07 <shapr> I have twelve or thirteen hours of j2ee work happening tomorrow
16:47:10 <shapr> I should also sleep.
16:47:39 <Knuth> shapr: sounds great! i cant thank you guys enough.
16:48:21 <Knuth> the people over at #c werent as tolerant toward newbies
16:49:40 <Knuth> shapr: so i guess i'll cya later. tomorrow perhaps?
16:51:47 * Knuth yawns, extracting the last whiff of oxygen from the room.
16:54:32 <Knuth> well, cya all tomorrow. nightie-night. thanx again, shapr!
17:23:58 * tmoertel returns from eating and other stuff
18:18:12 * Jerub yawns
19:33:09 <tche369> ls
19:42:21 <Jerub> I can't count the times I've done that.
23:27:05 <tmoertel> jens: are you still working on your robot visualization tool?
23:34:43 * tmoertel is going to bed
23:34:49 <tmoertel> g'nite all
