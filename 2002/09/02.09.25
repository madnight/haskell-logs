00:00:07 <sethk> The validity is hard to judge because who knows if the retrieval patterns accurately model real world use?
00:00:11 <Pseudonym> Right.
00:00:34 <Pseudonym> What's "real world use" anyway.
00:01:03 <sethk> Pseudonym:  I'm gathering information from installed systems now, but most of these are small as many of my users have embedded applications and use my engine because it has the smallest footprint for an ANSI SQL implementation.
00:02:06 <sethk> Pseudonym:  I had a very large installation at Bell Labs, but then Lucent axed the project (along with many, many others).
00:02:46 <sethk> Pseudonym:  Lucent actually sold off that part of Bell Labs, engineers and all, so it may restart.  The engineers want to restart it but management hasn't bought into it yet.
00:03:34 <Pseudonym> Good luck with it, it sounds kinda cool.
00:05:15 <sethk> Pseudonym:  My concurrency control algorithm is quite unique; its the only really good idea I've ever implemented where I never found others doing essentially the same thing.  Which means that either (1) it is a really creative idea or (2) there is a flaw in it that I'm unaware of.
00:07:10 <sethk> Pseudonym:  Its a solution to the "unsolvable" RDBMS phantom record problem.  I thought about patenting it but I was told that (1) software patents are a waste of money and (2) then anyone could reimplement it from the info in the patent application.
00:07:31 <Pseudonym> I'd be interested in more detail some time, if you don't mind.
00:07:39 <Pseudonym> If it's not a trade secret or anything. :-)
00:07:47 <norpan> software patents are bad
00:08:04 <Pseudonym> Software patents as currently implemented are bad.
00:08:13 <Pseudonym> In a perfect world, they might work.
00:08:14 <sethk> Pseudonym:  No, it's my own creation, about which I'm always happy to expound :)  I'd like to see it more widely used.
00:08:19 <norpan> any implemention will be bad
00:08:19 <Pseudonym> :-)
00:08:28 <norpan> in a perfect world no protection would be needed
00:08:34 <sethk> norpan, Pseudonym:  yes, and yes
00:08:34 <Pseudonym> True. :-)
00:08:52 <sethk> norpan:  It doesn't really provide much protection...
00:09:04 <Pseudonym> I think they could be made to work if a) there was a better test for obviousness, and b) the times were way, way shorter than they are.
00:09:17 <Pseudonym> It's the former thing which is the sticking point.
00:09:18 <norpan> software patents only provide food on the table for patent lawyers
00:09:31 <Pseudonym> Oh, yeah, and c) fewer lawyers.
00:09:42 <sethk> Norpan:  MIT sued Microsoft for patent infringement on some software that I wrote part of,  MIT won, and then MIT got less than the legal fees from Microsoft.
00:09:43 <norpan> given enough knowledge, everything is obvious
00:10:19 <Pseudonym> I'd rephrase that as "everything is obvious in retrospect".
00:10:24 <sethk> Most business that do patent licensing won't even accept software patens any more.
00:10:26 <norpan> programming really is more like a craft
00:10:55 <Pseudonym> Let me put it this way: I think that few software patents are "valid" in a moral sense.
00:11:19 <Pseudonym> The RSA patent was valid, IMO, for example.
00:11:33 <norpan> no software patents are valid in the "progress science" sense, they may be valid in the "make money" sense
00:11:46 <sethk> Pseudonym:  "You can't patent an idea", and in software, what isn't essentially an idea?
00:11:53 <Pseudonym> Yes and no.
00:12:10 <sethk> Norpan:  You could make that argument about any patent, not just software patens.
00:12:13 <Pseudonym> I think that patents on solving a problem make no sense.
00:12:29 <Pseudonym> For example, a patent on asymmetric encryption seems wrong.
00:12:36 <norpan> sethk: yes, indeed i can, but software patents are very different
00:12:45 <Pseudonym> But a specific technique, which is non-obvious, may be okay.
00:13:01 <Pseudonym> It's a tough call.  I do agree the current situation is insane, though.
00:13:22 <sethk> Norpan:  I don't disagree, but how would you describe the essence of the difference?
00:14:07 <norpan> "normal" patents are connected with much investment of the type of "testing whether this will work without too much radiation or vibrations or..." but software patents are just an idea, which is essentially just a spark of genoius, which would have happened with or without patents, therefore there is no society good in software patents
00:14:45 <andersca> ah, the good old patent discussion 
00:14:46 <Pseudonym> And the amount of testing sethk did on his algorithm is different because...?
00:14:51 <andersca> and I'm out of coffee
00:15:04 <Pseudonym> I'm not saying you're wrong.
00:15:13 <Pseudonym> Like sethk, I'm curious as to the difference.
00:15:27 <norpan> and normal patents allows "working around" the problem, which is often very possible with normal patents, but often impossible with software patents, because there often is only one real way to do something
00:15:46 <sethk> Norpan:  Well, to me the fact that it might encourage someone to pay me to do it is a societal good, albeit for a rather small segment of society  :)
00:16:02 <Pseudonym> I agree with you here, which is why I drew the distinction between patents on solving a problem and patents on specific methods for solving a problem.
00:16:40 <Pseudonym> In the modern world, I think you only need enough "protection" to get your product ahead first.
00:16:44 <sethk> Norpan, Pseudonym:  I don't agree that in general there are fewer ways to solve a software problem than another class of problems; quite the reverse, in fact.
00:16:51 <norpan> another thing with software patents is that they are generic to any computer program, whereas a normal patent is very specific to the field it was patented in
00:16:56 <Pseudonym> Once you've done that, there's no real "good" left in the patent.
00:17:23 <sethk> norpan:  Not necessarily.
00:17:27 <norpan> so, as a programmer you have to check the immense mass of software patents to know if you are violating any, any other engineer need only check patents in his small field
00:17:48 <Pseudonym> norpan: I think that's a consequence of the observable fact that too many patents are granted.
00:17:53 <sethk> norpan:  As to the logistics, I agree.
00:17:55 <Pseudonym> Not that patents are in principle bad.
00:18:09 <norpan> Pseudonym: one software patent is one too many
00:18:31 <Pseudonym> norpan: I'm not convinced.  One software patent, if it were narrow enough, wouldn't get in my way.
00:19:01 <norpan> well, the point is that how do you make an idea "narrow"?
00:19:06 <sethk> norpan, pseudonym:  The bottom line is that they are for all practical purposes unenforceable, and only get in the way of people who have a bent towards ethical behavior.
00:19:09 <norpan> an idea is what it is
00:19:16 <norpan> and should not be patented
00:19:18 <Pseudonym> sethk: Agreed.
00:19:40 <Chilli> Software patents (especially as they are implemented today) are like landmines
00:19:50 <Chilli> Lots of colateral damage
00:20:17 <sethk> Landmines aren't as bad.  After they blow up you can roast marshmellows over the damage  :)
00:20:29 <norpan> i have to go to work now
00:20:33 <norpan> see you in half an hour
00:20:41 <Pseudonym> I'm going home, so see you tomorrow.
00:20:47 <Chilli> sethk: :-)
00:20:57 <Pseudonym> Night everyone.
00:21:06 <Chilli> night
00:21:07 <Pseudonym> I'm glad this was a flame-free discussion, BTW.
00:21:09 <sethk> Pseudonym:  Night,  norpan:  bye
00:21:22 <Pseudonym> We functional programmers are a civil lot, apparently.
00:21:35 <sethk> I'm always puzzled when people flame about technical discussions, but then what do I know?
00:21:49 <Pseudonym> :-)
00:21:50 <Pseudonym> Night.
00:44:18 <norpan> oh
00:47:50 <sethk> oh?
00:51:05 <norpan> oh, you are still here!
00:51:53 <sethk> In a manner of speaking
00:55:10 <norpan> well, i understand that you are not "here" :)
00:57:46 <sethk> I'm also starting to fade out; it is about 1:00 AM here.
00:59:01 <norpan> well, you have my permission to go to bed
00:59:52 <sethk> Can't just yet, but soon.  Deadlines.
01:26:33 <andersca> hey marvin
01:28:22 <Marvin--> morning
01:39:31 <leander-> hi
01:40:54 <leander-> hm, greencard compiled fine, but there aren't any install instructions
01:43:25 <Marvin--> wtf is it with these files... they are indented SO weird
01:45:26 <Marvin--> and they've written their lexer as a *parser*?
01:46:20 <andersca> huh?
01:49:48 <Marvin--> pNumber = many1 (satisfy isDigit)
01:50:43 <Marvin--> and I'm having a hard time reading the code because some of it is indented halfway to China
01:51:11 <Marvin--> pLex =  determ $ many ( pIdent			<@ 	strType		<|>
01:51:11 <Marvin--> 												pNumber 		<@	TLitNum		<|>
01:51:32 <Marvin--> uh, except that every leading space on the second line is supposed to be a tab
01:51:56 <Marvin--> that second line is 147 characters long
01:52:00 <Marvin--> how the hell did they WRITE this?
01:53:27 <norpan> probably tabstop width 2 or something
01:53:29 <andersca> I assume this is when people use a "you don't deserve to pass" style response :)
01:53:48 <Marvin--> maybe
01:54:02 <Marvin--> ts=2 is exactly right
01:54:03 <norpan> i always indent using spaces, no tabs, never ever
01:54:17 <Marvin--> exactly, never ever tabs
01:54:36 <leander-> damn, i dunno how to install greencard
01:54:38 <andersca> I just use what emacs uses
01:54:39 <norpan> -- vim: sts=4 expandtab
01:54:45 <norpan> first line of all files
01:54:53 <Marvin--> I'm going to give them a tongue-lashing about not saying what the tabsize is
01:55:15 <norpan> hmmm some files has sts=2 actually :)
01:55:22 <norpan> i never press tab anyway
01:56:45 <norpan> autoindent and formatoptions+=r
01:56:53 <andersca> vim sucks
01:56:55 * andersca RUNS
01:57:19 <Marvin--> I usually have sts=4 or 8, and ts=8
01:57:30 <Marvin--> and expandtab of course
01:57:32 <Marvin--> well, not on Makefiles :)
01:57:37 <norpan> ts=8 is neccessary
01:58:50 <Marvin--> argh, they don't even say who they are! :) I'll have to go dig in their account *mutter*
01:59:48 <norpan> remove all files and never use them again, as punishment
02:00:27 <andersca> norpan: you are so mean
02:00:28 <Marvin--> hmm, too bad, I don't know who they are
02:00:43 <norpan> i tried green card once, but it never worked
02:00:43 * andersca fears handing in his assignment to Marvin--
02:01:11 <norpan> Marvin--: which files are those
02:01:35 <norpan> lab files?
02:01:51 <Marvin--> yes
02:02:02 <norpan> then removal of the files seems even better
02:02:05 <leander-> norpan: i'm sure it has to be installed anyhow (moved to the imports/ folder or something) but theres nothing written about ir
02:02:06 <norpan> "do it again"
02:02:07 <Marvin--> haha
02:02:25 <Marvin--> "Feeeel fel fel fel fel"
02:02:26 <leander-> unfortunately i need it for HopenGL
02:02:34 <norpan> leander-: oh
02:03:04 <norpan> Marvin--: "gör om, gör rätt"
02:04:06 <Marvin--> I think I'll fail them on making the lexer a parser, that's just wrong
02:04:33 <norpan> is it? the lexer is a sort of parser you know :)
02:04:41 <Marvin--> no, lexical analysis is flat
02:05:02 <Marvin--> well, all right, you CAN see it as a sub-case of parsing
02:05:10 <Marvin--> but it's very very very very inefficient to use a parser for lexing
02:05:21 <Marvin--> since it's just a linear analysis
02:05:49 <Marvin--> Hmm, systemet doesn't have any dark lagers from Germany?! There goes my october party idea
02:10:26 <leander-> #ToDo: install rules
02:10:29 <leander-> nice :(
02:12:33 <Marvin--> heh
02:29:36 <leander-> ah, now it works
02:30:13 <BlizzNL> anyone knows the difference between a 
02:30:15 <norpan> Marvin--: if you have efficient parser combinators, you should be able to use them for lexing as well
02:30:16 <BlizzNL> oeps
02:30:22 <Marvin--> <SATSER> ::= <SATS> [{<SATSER>}]
02:30:22 <Marvin--> haha
02:30:36 <norpan> Marvin--: triple redundancy? :)
02:30:40 <BlizzNL> anyone knows the difference between a type abstraction and a polymorphic type?
02:30:45 <Marvin--> so... one sats followed by zero or one of zero or more of satser...
02:31:25 <Marvin--> norpan: yeah, well, it's pretty much a waste to keep track of all the backtracking material
02:31:47 <Heffalump> a type abstraction is a lambda abstraction on types, and a polymorphic type is one with an outer forall, I'd say
02:31:52 <norpan> Marvin--: yes, but if know that you won't backtrack, you can tell the parser not to backtrack
02:32:15 <norpan> Marvin--: it's good to be able to use the same syntax
02:32:55 <Marvin--> norpan: well, they used different parser combinators for the lexer and the parser ;)
02:32:57 <BlizzNL> Heffalump: that
02:33:12 * BlizzNL is hitting the enter key spontaniously
02:33:17 <BlizzNL> will do ..
02:33:24 <Heffalump> is type abstraction in the context of the Girard-Reynolds calculus?
02:34:29 <Marvin--> argh, scp:ing files from a UTF-8 system to a non-UTF-8 system wasn't a good idea :)
02:34:54 <BlizzNL> Heffalump: I am figuring out the difference between : \/X:*.X->X and /\X:*.X->X
02:35:39 <Heffalump> do you mean \/ ?
02:35:47 <Heffalump> I'd have thought it'd be just \
02:36:07 <Heffalump> oh, hangon, is the former forall and the latter lambda?
02:36:22 <BlizzNL> Heffalump: yes! sometimes ascii falls short ;) 
02:36:27 <Heffalump> ok
02:36:29 <Marvin--> use \ for lambda :)
02:36:38 <Heffalump> it's normal to use /\ for capital lambda
02:36:43 <Marvin--> well, that's true
02:36:44 <Heffalump> which is what you use for types normally
02:37:02 <Marvin--> but I'd also use it for conjunction
02:37:09 <BlizzNL> Ow yes I mean capital lambda..
02:37:14 <Heffalump> BlizzNL: the former is what Haskell types are, and the latter is what GHC's core syntax uses
02:38:13 <BlizzNL> Heffalump : great thnx
02:41:56 <BlizzNL> Heffalump: Have you ever used Generic Haskell?
02:43:10 <BlizzNL> Heffalump: I am going to use that in the next few lectures and that's why I am looking into theory on types and kinds lately ;)
02:43:32 <Heffalump> no, I haven't
03:09:35 <leander-> Could not find interface file for `GL' <- does this mean a .hi file?
04:19:22 <Igloo> Yes, leander
04:44:46 * shapr bounces
04:45:36 <Igloo> Hey shapr  :-)
04:48:34 <shapr> hi Igloo!
05:13:51 * jewel curses
05:14:00 <jewel> I wasted two days figuring out that:
05:14:04 <jewel>  LineMappingTable operator=(LineMappingTable& table);
05:14:05 <jewel> should be
05:14:09 <jewel>  LineMappingTable& operator=(LineMappingTable& table);
05:15:21 <shapr> hi jewel, what are you doing?
05:15:30 <shapr> oh, that looks like C
05:15:32 <jewel> Writing a parser 
05:15:43 <jewel> Yeah, I wrote a silly C++ line number mapping table
05:15:58 <jewel> and that bug was corrupting stuff
05:16:45 <jewel> these legacy languages are evil
05:16:57 <ChilliX> indeed
05:17:14 <Igloo> Oooops
05:17:15 <Igloo> ghc foo.lhs 2>&1 | wc -l
05:17:15 <Igloo>    5837
05:17:36 <Igloo> foo.lhs being 3 lines, the most interesting one being main = putStrLn "Foo"
05:17:43 <shapr> hm
05:17:44 <jewel> lol
05:18:33 * Igloo goes to read mailing lists  :-)
05:18:45 * shapr reads pragprog
05:19:06 <shapr> seems there will be at least two LotY groups this year, one for Oz, and one for Common Lisp
05:19:52 <shapr> I'm going to stick with Haskell for at least another year or so.
05:20:07 <Igloo> Cool  :-)
05:20:14 <Igloo> What sort of language is Oz?
05:20:16 <ChilliX> shapr: you should finish your twisted binding after all
05:20:25 <shapr> I agree
05:20:29 <ChilliX> Igloo: constrained logic
05:20:36 <ChilliX> constrained = constraint
05:20:44 <shapr> plus I've ended up liking and enjoying Haskell more than any other language I've used.
05:21:11 <shapr> it has a lofty goal and vision, and most shocking, it comes very close to that goal.
05:21:20 <ChilliX> Igloo: they call it multi-paradigm as they can model all kinds of programming styles
05:21:41 <shapr> Oz has some cute Erlang-style tricks
05:21:53 <ChilliX> but it is dynamically typed and it's semantics is in a sense very operational (although it has a asmall core language)
05:22:03 <shapr> iirc, distributed process synchronization happens via unification, which is interesting.
05:22:17 <ChilliX> but far from new 
05:22:35 <shapr> imho, type inferencing in Haskell makes it dynamically statically typed
05:23:16 <ChilliX> maybe dynamically typed should be called runtime typed
05:23:26 <shapr> yah, it should be
05:23:52 <shapr> I like the code first, come back and put more specific type declarations in...
05:24:02 <shapr> ChilliX: I think you suggested that on the mailing list
05:25:02 <ChilliX> did I?
05:25:09 <shapr> I think so :-)
05:25:27 <shapr> maybe I'm confused...
05:25:34 <ChilliX> it might be
05:25:47 <shapr> the message I read said "write code, then come back and put more specific type declarations on it"
05:26:22 <shapr> and "if the types don't work as you expected, something probably needs fixing"
05:26:54 <ChilliX> sounds reasonable
05:27:18 <shapr> compile time type inferencing gives me the freedom of Python, with the strong points of static typing.
05:27:19 <shapr> I really like that.
05:27:37 <shapr> and I still have the option to make more specific types if I want to check my assumptions at some level.
05:27:47 <ChilliX> yep
05:27:48 * shapr writes Haskell advertising posters ;-)
05:28:41 <ChilliX> hehehe
05:29:08 <ChilliX> Haskell Workshop programme is finalised btw http://www.cse.unsw.edu.au/~chak/hw2002/
05:29:17 <ChilliX> got one more demo yesterday
05:29:43 <Heffalump> Bluespec?
05:30:06 <Igloo> Aaargg! I didn't think about what cvs -d would do in a GHC cvs tree root
05:30:22 <shapr> Igloo: now you have all of fptools?
05:30:23 --- topic: set to 'ANNOUNCE: GHC version 5.04.1 released || ICFP 2002 Robot Analysis and Visualization Toolkit 0.9 http://tea.moertel.com/~thor/ravt/ || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || Gtk+HS 0.14.10 released http://www.cse.unsw.edu.au/~chak/haskell/gtk/ || 2002 Haskell Workshop Programme http://www.cse.unsw.edu.au/~chak/hw2002/' by ChilliX
05:30:28 <ChilliX> Heffalump: yep
05:30:28 <Heffalump> igloo: wdym?
05:30:36 <Igloo> Yup, shapr  :-)
05:30:44 <Igloo> Heff: What shapr said
05:30:44 <shapr> I'm very much looking forward to Template Haskell
05:30:45 <ChilliX> Igloo: I made this mistake also a couple of times
05:31:03 <shapr> I read part of the paper on my vacation, it's powerful stuff.
05:31:14 <ChilliX> it is
05:31:17 --- topic: set to 'ANNOUNCE: GHC version 5.04.1 released || ICFP 2002 Robot Analysis and Visualization Toolkit 0.9 http://tea.moertel.com/~thor/ravt/ || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || Gtk+HS 0.14.10 released http://www.cse.unsw.edu.au/~chak/haskell/gtk/ || 2002 Haskell Workshop Programme http://www.cse.unsw.edu.au/~chak/hw2002/ || Try to get this topic to fill a whole screen' by Heffalump
05:31:23 * shapr laughs
05:31:27 <ChilliX> it already landed in the CVS HEAD
05:31:33 <ChilliX> hehe
05:32:44 * Igloo deletes the directories I didn't want and wonders how 400M has still disappeared
05:34:16 <Igloo> Oh, eeep, the installed GHC is taking up 450M
05:34:56 <shapr> it's not small
05:35:09 <shapr> I found another make -j2 dependecy bug yesterday
05:35:17 <ChilliX> 450M?
05:35:20 * Igloo will work on the assumption this is because of the mangler problems
05:35:55 <ChilliX> AttitudeAdjuster chak 162 (~): ll src/jibunmaki/i386/ghc-5.04.1-2.i386.rpm 
05:35:55 <ChilliX> -rw-r--r--    1 chak     chak     11916862 Sep 17 10:38 src/jibunmaki/i386/ghc-5
05:36:07 <ChilliX> .04.1-2.i386.rp
05:36:15 <ChilliX> rp = rpm *sigh*
05:36:18 <shapr> the name of your box is AttitudeAdjuster?
05:36:24 <Igloo> libHSbase_p.a is about 10 times the size of the 5.04 one - I'll try rebuilding and see what happens
05:36:25 <ChilliX> yes :-)
05:36:36 <shapr> cute :-)
05:36:44 <ChilliX> AttitudeAdjuster chak 163 (~): ll src/jibunmaki/i386/ghc-prof-5.04.1-2.i386.rpm  
05:36:44 <ChilliX> -rw-r--r--    1 chak     chak      7608257 Sep 17 10:38 src/jibunmaki/i386/ghc-prof-5.04.1-2.i386.rpm
05:36:54 <ChilliX> that's all the profiling stuff
05:37:11 <ChilliX> shapr: Do you know where it is from?
05:37:26 <shapr> not really
05:37:41 <shapr> in the US, if you say "someone needs their attitude adjusted"
05:37:54 <shapr> it usually means they're being a total pain
05:38:03 <shapr> and that they might get parking lot therapy.
05:38:14 <Igloo> That would explain my confusion at GHC needing so much space to build yesterday too
05:38:37 <shapr> http://c2.com/cgi-bin/wiki?ParkingLotTherapy
05:40:10 <shapr> is that the same attitude adjustment?
05:41:39 <shapr> when I built 5.04.1 it used a large amount of ram
05:41:42 <ChilliX> http://search.barnesandnoble.com/booksearch/isbnInquiry.asp?userid=0CRIT24LGL&isbn=0553575376
05:42:54 <shapr> oh, that sounds cool
05:43:08 <ChilliX> (it certainly is linked to the meaning that you describe)
05:43:12 <shapr> a bunch of people have recently said good things about Iain Banks to me
05:43:17 <ChilliX> It is extremely cool
05:43:37 <shapr> cool, I have to read his books then.
05:44:19 <ChilliX> I think I like "Excession" the best (not sure whether it is the best to start with)
05:45:36 <ChilliX> btw, it makes sense to distinguish between Iain Banks and Iain M. Banks
05:45:52 <shapr> oh
05:45:55 <ChilliX> same guy, but he uses the latter for all his SF
05:45:55 <shapr> ok
05:46:02 <shapr> ah, I see.
05:46:05 <shapr> interesting.
05:46:08 <ChilliX> and some of the non-SF is pretty tough
05:47:34 <shapr> sounds good to me...
05:47:52 <shapr> I've just reread all of the Terry Pratchett we own.
05:48:14 <ChilliX> all?  He wrote a lot...
05:48:31 <shapr> we own about 35 of his books
05:48:46 <ChilliX> ok, that *is* a lot
05:48:52 <shapr> I can usually read one in an evening.
05:49:04 <shapr> or several on a saturday :-)
05:49:54 <shapr> my favorite series is the "Johnny and the something" series.
05:50:06 <shapr> imho, they're even better than discworld.
05:50:26 <ChilliX> don't know that one
05:50:51 <shapr> "Johnny and the Bomb", "Johnny and the Dead", and "Only you can Save Mankind"
05:51:28 <ChilliX> ok
05:51:29 <shapr> there may be others in that series, but that's all we have in the bookshelf.
05:51:53 <ChilliX> similar style as discworld?
05:52:28 <shapr> yes, but even more so, imho
05:52:55 <shapr> have you read Good Omens, where Pratchett and Gaiman wrote it together?
05:52:56 <ChilliX> ic
05:53:03 <ChilliX> no
05:53:37 <shapr> that's kind of like getting Wadler and Hughes to spend a week trying to generalize Arrows ;-)
05:53:47 <shapr> whatever you end up with will be interesting
05:54:19 <ChilliX> hehehe
06:03:34 * Igloo spots "ar: libHSbase_p.a.tmp: Memory exhausted" and worries
06:04:33 <Igloo> Bah. Time to rebuild fro scratch then  :-/
06:07:28 <shapr> yow
06:07:50 <shapr> ghc 5.04.1 build took up a tremendous amount of disk,ram, and cpu here
06:08:10 <shapr> it kept biting into my swap space...
06:13:24 <shapr> hi pesco
06:17:17 <Igloo> Hmmm, should updates be instantly available from the public GHC CVS?
06:17:29 <ChilliX> no
06:17:34 <Igloo> Gah!
06:17:39 <ChilliX> it's mirrored at regular intervals
06:17:51 <Igloo> Nor from the cvsweb by the looks of it
06:18:02 <ChilliX> (annoying, but true for most public CVS repos)
06:18:13 <ChilliX> Igloo: nor cvsweb
06:18:56 <ChilliX> (Gnome has multiple public CVS mirrors and they are even out of sync for a small time frame around update time)
06:19:14 <ChilliX> (and you are directed to a random one via the usual DNS rotation setup)
06:19:32 <Igloo> Can't see it mentioned on the web pages - I'll check tomorrow I think
06:19:38 <Igloo> Heh
06:20:12 <ChilliX> do you need anythi9ng specific?
06:20:18 <ChilliX> (out of the repo)
06:21:07 <Igloo> fptools/ghc/driver/mangler/ghc-asm.lprl 1.88 is all I need I *think*
06:21:26 <ChilliX> ok, just a sec, I CVS update and send it
06:21:32 <Igloo> Cool, ta
06:24:52 <ChilliX> which email?  (I am on IP masq and haven't configured ip masq forwarding for irc dcc connections)
06:26:12 <ChilliX> Igloo?
06:26:28 <Igloo> igloo@earth.li  [sorry, was AFK]
06:26:49 <ChilliX> ok, sent
06:27:10 <Igloo> Thanks  :-)
06:27:17 <ChilliX> :-)
06:48:47 <pesco> hi shapr
06:53:22 <pesco> does anyone know from the top of their heads whether the HOpenGL coming with GHC 5.04.1 is still incomplete?
06:53:55 <shapr> it compiled just fine yesterday, though I haven't tried it out.
06:54:14 <pesco> Yes, it compiles, but the 5.04 one doesn't include much at all.
06:54:37 <shapr> I'd suggest asking on the HOpenGL list
06:54:39 <pesco> I emailed Sven Panne about it, he said it was in the process of being rewritten from scratch and hardly finished.
07:26:26 * shapr bounces
07:26:44 <shapr> pesco: if you find out more, I'm interested in the state of HOpenGL
07:55:31 * shapr bounces
07:55:55 <ChilliX> 'night
07:56:00 <shapr> hm, I had a question to ask, but I forgot it >:-(
07:56:03 <shapr> g'night ChilliX!
07:56:37 * shapr wonders what nifty things could come from a combination of Template Haskell and o3's runtime loader
07:57:32 <o3> re
07:57:38 <o3> that was nice timing
07:57:39 <shapr> hi o3!
07:57:41 <shapr> heh :-)
07:57:42 <o3> oh, just missed chilli
07:57:58 <o3> shapr: i'll have to wrap my head around template haskell later 8)
07:58:10 * BlizzNL wonders if anyone knows how to open a ps.z file.
07:58:19 <shapr> BlizzNL: on win32?
07:58:30 <shapr> o3: in short, template haskell is compile-time macros
07:58:47 <shapr> I was just thinking about run-time compilation macros
07:58:52 <BlizzNL> shapr: yes
07:59:16 <o3> BlizzNL: winzip should be able to open it
07:59:17 <shapr> BlizzNL: .z is just compressed, ghostview should open it transparently I think
07:59:32 <BlizzNL> shapr: gsview32 pops an error
07:59:38 <o3> shapr: nod, i know (i'm familiar with C++ templates), but i have to wrap my head around all the various uses of it
08:00:07 <shapr> BlizzNL: try o3's suggestion then, that'll probly fix it.
08:01:04 <BlizzNL> ok'll give it a shot
08:01:31 --- mode: ChanServ set +o tmoertel
08:02:06 <shapr> um
08:02:33 <shapr> interesting
08:02:36 <Heffalump> indeed.
08:02:48 * Heffalump suggests banning that hostmask if it keeps on
08:02:51 <shapr> I suspect he set his time-to-give-nick-password a bit too low
08:03:07 * shapr notes that Heffalump has such power in his grasp if he so chooses
08:03:19 <Heffalump> if I can remember how to talk to services :-)
08:03:22 * shapr grins
08:03:28 --- mode: ChanServ set +o Heffalump
08:03:37 <Heffalump> :-)
08:03:45 <Heffalump> anyway, I think the NickServ has taken over the nickname
08:04:22 <shapr> I think he just set his "enforce timelimit" too low
08:04:28 <Heffalump> right.
08:04:50 * shapr bounces
08:05:03 --- mode: Heffalump set -o Heffalump
08:05:08 --- mode: ChanServ set +o Heffalump
08:05:13 * shapr grins
08:05:15 <Heffalump> right, got it.
08:05:18 <shapr> ChanServ likes you.
08:05:29 <BlizzNL> o3: thnx it works
08:05:39 <o3> cool :)
08:06:15 <shapr> Heffalump: started on a webserver with runtime loading of modules?
08:06:39 <Heffalump> hogan.freenode appears to be going down
08:06:54 <shapr> ?
08:07:02 <Heffalump> the server
08:07:06 * Heffalump goes looking for another one close by
08:07:09 <shapr> oh
08:07:25 * shapr is using irc.eu.freenode.net
08:08:02 * Heffalump does that then
08:08:12 <Heffalump> and no, I haven't (re webserver)
08:08:32 <Heffalump> what I'd want is to have apache doing runtime loading of GHC compiled modules
08:08:32 <shapr> I'm most interested in an emacs clone :-)
08:08:39 <shapr> oh
08:08:55 <shapr> iirc, there is a mod_haskell ?
08:09:05 <o3> shapr: there might be after my thesis is finished ...
08:09:25 <o3> ("might" should be highlighted in big flashing text)
08:09:29 <shapr> heh
08:09:31 <Heffalump> there is one, yeah - hugs based
08:09:37 <shapr> oh, hugs based.
08:09:37 <shapr> hm
08:09:39 <Heffalump> they have a ghc version too but I don't think it works
08:10:14 <shapr> I wonder how close it is to working
08:10:26 <o3> i'll probably find out soon enough :D
08:10:39 <norpan> same problem again?
08:10:43 <shapr> the apache mod_* api is pretty simple
08:11:04 <o3> norpan: did you get my post about loading .so's?
08:11:10 <shapr> something like six separate chunks I think, most of which are rarely used.
08:11:15 <norpan> o3: yes
08:11:26 <norpan> o3: but that's not quite what i want, unfortunately
08:11:35 <o3> norpan: yeah, i thought so.  oh well :)
08:11:54 <shapr> ?
08:12:12 <shapr> I'd like to see all this dynamic/runtime loading collected in one place
08:12:37 <shapr> since I'm never sure if I'm missing something :-)
08:12:53 * shapr looks for mod_* docs
08:13:38 <o3> shapr: the example i did pretty much represents all my knowledge about it, except for using dynamic types to make it safer
08:13:54 <o3> but it'll go into ghc soon, since simonpj has asked to put it in
08:14:00 <shapr> I've read about dynamic types repeatedly, and I still have no idea what they do.
08:14:05 <norpan> well, I just need the equivalent of --mk-dll for linux, but unfortunately it seems like there are technical problems with the .so format gettin in the way :(
08:14:30 <Heffalump> o3: didn't someone say that your .so creation fails sometimes?
08:14:41 <o3> shapr: yeah, the docs on it are a bit confusing.  i plan to rewrite them some day so that normal human beings (ie the non-simon marlows among us :) can understand it
08:14:59 <shapr> Heffalump: if you mean Duncat Coutts with the "weird stack scavenge" that's a ghc5.04.0 bug I think
08:15:04 <Heffalump> ah, ok
08:15:07 <norpan> o3: why do you even want to use .so files when you can load .o files directly?
08:15:10 <o3> Heffalump: it always works, although i very occasionally get a bizarre message when the program terminates about some unknown stack value
08:15:12 <shapr> I got it a lot during our ICFP run
08:15:39 <shapr> something like "weird record during stack scavenge"
08:15:46 <o3> norpan: well, .so is kinda nicer i guess ... as i said, i'd really like for the whole thing to vanish and make ghc have proper dynamic loading
08:15:53 <shapr> and it usually happened when I tried to load a file more than twice
08:16:02 <o3> yeah, that's it
08:16:04 <shapr> what's proper dynload mean?
08:16:24 <norpan> using the ld.so linker
08:16:28 <o3> shapr: loading .so's without that weird stack error :)
08:16:31 <shapr> heh
08:16:37 <o3> norpan: we're already using the ld.so linker, which gets us 90% there
08:16:43 <norpan> ok
08:17:11 <andersca> hi norpan
08:17:29 <shapr> the stack error usually goes away if you restart ghc and try it again
08:18:04 <o3> (the "c_addDLL" function in the RuntimeLoader.hs file actually calls dlopen())
08:20:06 <norpan> hi andersca
08:20:12 <shapr> you mentioned you have to know the function name ahead of time, would it be sensible to add a getDirectory function that returns details of the names and types of the exported functions?
08:20:45 <shapr> or is that already obvious for a real/full RuntimeLoader ?
08:22:46 <shapr> I don't understand the difference between loadFunction and loading functions that are a Dynamic type
08:22:51 <Heffalump> even if you got a list of names and types, you wouldn't know which one to call
08:23:20 <shapr> maybe a python-style __doc__ ?
08:23:21 <o3> shapr: i can't think of a situation where you need that
08:23:35 <o3> (there's no equivalent for doing the same thing in C, is there?)
08:23:46 <shapr> I'm thinking of M-x load-library in emacs
08:24:13 <shapr> in xemacs at least, I get to autocomplete library names, and then function names when that library is loaded.
08:24:48 <o3> hmm, but if you load a .so, you should really know what function in the .so to call
08:24:59 <shapr> in Python, C modules can include a docstring for each function so you can get a few lines of documentation about it
08:25:13 <o3> maybe you want to call a "getFunctionList" function, which then returns you a list of functions ...
08:25:24 <shapr> yah, something like that.
08:25:59 <shapr> I'm just thinking of ways to get the interactivity of Python and (X)Emacs in your average Haskell app
08:26:49 <o3> you can certainly do it ... you jsut need to provide a good interface which modules can hook into
08:27:52 <shapr> I think a getFunctionList function that also includes stuff like a version variable would be generally useful to any Haskell app that wants dynamic loading
08:28:25 <shapr> I'm thinking of stuff like Erlang's runtime app upgrading
08:28:45 <o3> right.  as i said, you just need a good (i.e. well-designed) interface :)
08:28:51 <shapr> yah, I agree.
08:28:57 <norpan> how does type safety work, can the dynamic loader check the haskell types, or does it assume that they are correct?
08:29:14 <shapr> from the README:
08:29:17 <shapr> If you feel that loadFunction is a bit dangerous, you can always make the
08:29:17 <shapr> functions that you load be a Dynamic type, and use fromDyn to coerce it
08:29:17 <shapr> back to its original type; that way, you get type checking on the
08:29:17 <shapr> functions that you load.  I'll expand this demonstration program to
08:29:17 <shapr> include that feature in the future.
08:30:08 <norpan> how does that work with polymorph types?
08:30:08 <o3> basically, you can turn any type into a dynamic type, using a function called toDyn or something like that
08:30:28 <shapr> o3: in my experience, conventions often become standards, so I was thinking some of that stuff should be available (but not required) in the first runtime loader codebase that shows up in GHC
08:30:35 <o3> and then you can use fromDyn to convert that back to its original type -- fromDyn will fail if you try to coerce it to the type which it wasn't originally
08:31:17 <shapr> that way a module.o for a webserver could be plugged into a haskell-emacs if the functions were useful.
08:31:25 <o3> shapr: hmm, perhaps make it part of another module, so that people can choose to use it if they want to
08:31:29 <shapr> right
08:31:50 <shapr> what does a dynamic type do?
08:31:53 <shapr> why are they useful?
08:32:14 <o3> i mean have a RuntimeLoader and have another PluginSpecification module or whatever :)
08:32:28 <shapr> is it like being able to the in-memory bits of a Double as text or something and then casting back to a Double?
08:32:39 <o3> yeah, basically
08:32:51 <shapr> hm, neat
08:33:00 <shapr> I could use that in my IEEEDouble.hs module
08:33:06 <pesco> toDyn :: a -> Dynamic
08:33:18 <o3> the really neat thing is that the host application doesn't actually need to know about the type
08:33:19 <shapr> though a general purpose C struct module would be a better solution.
08:33:21 <pesco> fromDynamic :: Dynamic -> Maybe a
08:33:24 <o3> that twisted my mind for a while
08:33:30 <shapr> huh?
08:33:37 <shapr> o3: how so?
08:33:46 <shapr> pesco: yah, but how do I use one?
08:33:55 <o3> say you have a type called, i dunno, Foo
08:33:58 <Heffalump> fromDynamic . toDyn :: a -> Maybe b
08:34:08 <pesco> *g*
08:34:08 <o3> you convert Foo to Dynamic via toDyn
08:34:09 <shapr> I'd really like to build a Double from a bunch of bits
08:34:36 <o3> your host app then loads up a module with a function "foo :: Dynamic"
08:34:47 <pesco> [toDyn "hey", toDyn (3::Int)] :: Dynamic
08:34:50 <o3> your host app then loads up another function in the module, called "bar :: Dynamic -> String"
08:34:58 <Heffalump> ::[Dynamic] I'd hope
08:35:03 <pesco> sorry, yes of course.
08:35:12 <shapr> oh neat, the Dynamic carries its own type info?
08:35:16 <o3> you can then do "bar foo" (i.e. pass the dynamic type back to bar), and get a string from that
08:35:18 <pesco> shapr: exactly.
08:35:21 <o3> shapr: yes
08:35:26 <shapr> wow, that's cool
08:35:32 <Heffalump> fromDynamic.toDyn is cool though, depending on the context you use it in, it either behaves likes "Just" or like "const Nothing"
08:35:40 <o3> and the fantastic thing about that is that you can now make your _own_ types in the laodable module, and the host app doesn't need to know
08:35:51 <shapr> so how can I operate on a Dynamic type? can I treat it as a String, Integer, or what?
08:36:02 <Heffalump> shapr: just call fromDynamic on it
08:36:14 <o3> as long as you have that "bar" function which takes in the dynamic type, and changes it to some format the host app will understand, all your modules can start interacting with each other even if they use completely different types
08:36:44 <o3> so dynamic types are really powerful once you have loadable modules
08:36:45 * shapr thinks about that
08:36:50 <Heffalump> what package is the Dynamic module in?
08:36:57 <o3> Heffalump: i think lang
08:37:15 <o3> shapr: concrete example ... i'm working on a markup language at the moment, with loadable modules as plugins for various markup types
08:37:25 <o3> e.g. there's a Bold module, Italics module
08:37:58 <pesco> Is there a specific reason why there is no function to get the TypeRef of the contained value from a Dynamic?
08:38:15 <o3> of course, some types of markup take different number of parameters than other types.  for bold, you just need one argument -- the text to be bolded.  for a URL, you might want to take two arguments: the actual link, and the name to display in the document
08:38:15 <Heffalump> YM TypeRep?
08:38:29 <pesco> Yes.
08:38:33 <Heffalump> pesco: discourage VB programmers? :-)
08:38:40 * shapr snickers
08:38:47 <pesco> Huh?
08:38:55 <o3> so internally, each module stores it all in its own datatype, but the host app just demands that they can convert from their own internal representation to a string or whatever
08:39:08 <Heffalump> wouldn't want them thinking they could use Dynamic like a Variant, would we?
08:39:24 <pesco> I'm not familiar with VB. What's a Variant?
08:39:25 * shapr strongly dislikes Variants
08:39:36 <shapr> I've done VB, VBA, and VBScript... just say NO.
08:39:46 <pesco> NO.
08:39:53 <shapr> pesco: thank you :-)
08:40:00 <shapr> o3: it sounds like subclassing
08:40:03 <Heffalump> basically tagged values, like a Dynamic, but there are actually operations defined on them, I think
08:40:05 <shapr> er, but better
08:40:13 <shapr> it's like Interfaces in Zope 3
08:40:22 <o3> shapr: yeah, like interfaces
08:40:41 <shapr> you don't care what type is returned as long as it can be re/turned into one of [x,y,z] types.
08:40:45 <o3> but it allows for massive extensibility, since modules are free to add their own types
08:40:51 <Heffalump> hmm, fromDynamic breaks referential transparency, unless you look at the types too
08:40:53 <shapr> that's extremely cool
08:41:07 <shapr> Heffalump: yah, I wondered how it works with reftrans
08:41:07 <Heffalump> but I guess that's usually the case with referential transparency
08:41:26 <o3> what's referential transparency?
08:41:26 <shapr> o3: you're writing your thesis on this?
08:41:43 <o3> shapr: no, my thesis will be a haskell wiki
08:41:43 <shapr> http://c2.com/cgi-bin/wiki?ReferentialTransparency
08:41:52 <o3> ta
08:41:56 <Heffalump> o3: the fact that you can replace any expression by something it evaluates to
08:42:02 <o3> oh, right
08:42:22 <shapr> o3: sounds to me like the dynloader might get you famous in GHC circles :-)
08:42:46 <shapr> HaskellWiki would be cool, but imho, not as cool as dynloading.
08:42:48 <o3> shapr: chilli was keen to get me to write a paper for it, although i think i underestimated its usefulness
08:42:59 <shapr> your academic advisors may not agree, I don't know.
08:42:59 <o3> hopefully i'll get the chance one day :)
08:43:18 <shapr> o3: I would also be keen to read a paper about your loader.
08:43:48 <o3> shapr: well, the haskell wiki will feature dynamic loading ... it'll hopefully be a real demonstration of a "real-world" haskell project
08:43:53 <shapr> I'm an academic null though, so my opinion may not be representative.
08:44:20 <o3> and built to be a proper, extensible app (which IMHO not enough people do)
08:45:00 <shapr> I'm also interested in a HaskellWiki, though I was thinking of using WASH-CGI
08:45:19 <o3> all the dynloading stuff came out of me wanting to do this markup language, which was meant to be extensible from the very beginning
08:45:35 <o3> the extensibility is the important thing.  not enough projects are extensible :)
08:46:26 <o3> shapr: i'll try to provide various backends -- one for the haskell web server, one for wash-cgi, and one for an apache module.  but we'll see
08:46:58 <shapr> I'm not picky, anything that works :-)
08:47:20 <pesco> o3: Is there a way one can have a look at your dynloader?
08:47:37 <o3> pesco: http://www.algorithm.com.au/wiki/hacking/haskell.ghc_runtime_loading
08:48:01 <o3> check out vimacs while you're there ;)
08:48:06 <pesco> ta
08:48:30 <shapr> vimacs is scary
08:49:29 <o3> :D
08:49:57 <shapr> I'd prefer hemacs (haskell)
08:50:11 <shapr> as awesome as xemacs is, elisp sucks
08:50:26 <shapr> so does forced single-threading
08:50:37 * shapr is intimately aware of the good and bad points of xemacs
08:52:24 <shapr> of course, the best way to do that is to subversively replace the elisp engine with one written in Haskell
08:53:21 <o3> i want a haskell -> neverwinter nights bytecode compiler
08:53:31 <o3> that'll be fun :)
08:54:40 <shapr> nwn uses bytecode?
08:54:52 <shapr> I'll purchase the linux client when it's released...
08:55:11 <pesco> Have they still not got that out? Bioware stink. They should take some lessons from JohnC
08:55:50 <shapr> november 16th is the most recent estimate from tuxgames.com
08:55:54 <o3> yeah, it has its own scripting language which compiles to its own bytecode ...
08:56:03 <shapr> hmm
08:56:04 <shapr> interesting
08:56:12 <o3> pesco: or epic megagames :)
08:56:20 <o3> (unreal tournament 2003)
08:56:28 <pesco> o3: Oh, they too?
08:56:36 <shapr> I went into FPS withdrawals last night and got counterstrike running on winex on my system
08:56:45 <o3> pesco: yes, linux version is shipped with the UT2003 CDs
08:56:49 <shapr> I didn't get much sleep last night, but I got a major adrenaline fix =)
08:57:23 <pesco> o3: Oh right, and there's even the Gentoo UT2003 Live CD.
08:57:30 <o3> that too
08:57:42 <pesco> o3: I think I'm gonna try that, just because it's cool.
08:58:09 * shapr wonders how complicated nwn bytecode is...
08:58:10 <pesco> o3: Like back in the day when you'd just throw in the California Games 5.25" and boot right in.
08:58:41 <o3> shapr: i've reverse-engineered most of it.  i'm writing a compiler for it as an assignment ;)
08:58:49 <o3> (in haskell, of course)
08:59:59 <pesco> o3: "GHC now has the capability to load Haskell modules as a plugin!"
09:00:06 <pesco> Does that mean it's already in 5.04.1?
09:00:30 <shapr> o3: awesome
09:01:05 <adept> o3: whats newerwinter?
09:01:41 <o3> pesco: strictly speaking, it's actually been in there since ghci was implemented ... i just poked around and extracted all the useful bits, so that normal apps could use the functions
09:01:47 <shapr> http://nwn.bioware.com/
09:01:56 <pesco> o3: OIC.
09:02:00 <pesco> o3: Thats wonderful.
09:02:01 <o3> pesco: grab the TextFilter module and have a look; all the stuff you want is in a directory in that tarball
09:02:05 <o3> adept: a game :)
09:02:49 <adept> o3: and what you can script in that game? (i'm not lazy, /me already looking at nwn.bioware.com)
09:02:56 <shapr> hi dwalter, got your enforcement timeout increased?
09:03:26 <dwalter> shapr: come again?
09:03:36 <shapr> you were bouncing pretty hard earlier
09:03:52 <o3> adept: the game engine has its own scripting language, so you can script AI, for example.  or script what happens when a character picks up a particular item
09:04:11 <dwalter> shapr: broken startup script, my bad. my apologies for the noise.
09:05:24 <o3> adept: reasonably powerful stuff, in other words.  every single spell you cast is done via scripting -- all the visual effects, damage done to enemies, etc.  that gives you a reasonable idea of what the scripting language can do
09:06:11 <adept> o3: from their site it's not clear wether it's a MUD or single-played RPG ...
09:06:23 * adept plays ADOM meanwhile :)
09:06:24 <shapr> dwalter: no worries, just thought nickserv was killing you off with a one second timeout
09:06:37 <o3> adept: both, really
09:07:07 <adept> o3: sounds cool. thanks for a link
09:07:14 <dwalter> shapr: it was, and that made the bounce harder, I had to kill my client.
09:07:20 <shapr> yuck
09:08:04 <shapr> irc increases my effective IQ in the same way google does
09:11:24 * shapr reads about NWN linux client
09:11:43 <shapr> sounds like November is a very optimistic release date :-/
10:56:35 <engstad> Greets.
10:57:00 <engstad> I've got 2D points: data Point2d = Point2d { x, y :: Float }
10:57:14 <engstad> And 3D points: data Point3d = Point3d { x, y, z :: Float }
10:57:38 <engstad> But, it is telling me there are Multiple declarations of Point.y and Point.x. 
10:57:57 <engstad> Why is that?
10:59:37 <hdaume> because you are using the same field names for two different datatypes
10:59:58 <engstad> And I can't do that?
10:59:58 <hdaume> you need to make it something like 'data Point2d = Point2d { x2d, y2d :: Float }', etc...
11:00:07 <engstad> Aiks....
11:00:23 <hdaume> no, because 'data D = D { d :: t }' introduces a function 'd (D p) = p'
11:00:36 <engstad> Hmm, 
11:00:47 <hdaume> but if you have the same field names for two different datatypes, this will lead to conflicting types for 'x'
11:00:49 <hdaume> (in your case)
11:01:05 <hdaume> (one x will be Point2d -> Float, the other will be Point3d -> Float)
11:01:23 <engstad> It should intruduce function D.d instead..
11:01:37 <hdaume> :) there was discussion about this very topic on the mailing list recently
11:01:51 <hdaume> the problem is that then, D.d is ambiguous whether it refers to the datatype D or the module D
11:02:23 <engstad> Well, it's only a matter of syntax. I'd go for D_d as well.
11:03:11 <hdaume> you could always create two modules, Point2d and Point3d and have the data declarations in those, then you get the Point2d.x for free :)
11:03:22 <hdaume> (though having "submodules" would make this much nicer)
11:03:28 <engstad> Could I do: data Point = Pt3 { x,y,z :: Float} | Pt2 { x,y :: Float}
11:03:35 <hdaume> Yup
11:03:45 <hdaume> because that will give a constant type to x and y
11:03:50 <engstad> Ah, I see.
11:04:33 <engstad> ML languages have structures. Not in Haskell?
11:04:43 <hdaume> right
11:04:52 <engstad> How come?
11:05:27 <hdaume> it's not entirely clear why you need them -- type classes are supposed to solve the same problem.  though, see spj's "Modules as First Class Citizens" for more about that...
11:05:32 <hdaume> (i think that's the title of the paper)
11:06:27 <hdaume> i also get the impression that integrating something like structures into haskell is nontrivial
11:06:35 <hdaume> (though i really don't know much about it)
11:07:42 <engstad> I'm still not convinced that structures are better than objects, nor that (haskell) classes are better than these again.
11:08:09 <hdaume> object = structure + internal state?
11:09:23 <engstad> Yes, a'la Ocaml.
11:10:31 <engstad> It's a pity that Ocaml has both records and objects, but there is no direct relationsship between them.
11:10:56 <hdaume> then the obj/structure debate is really about state...imo, state is bad in most cases so i would prefer structs to objects.  sturctures/classes...hard to say...there certainly are times i'd really like structures...i came from an SML background before haskell.  now, there still are some times i'd like structures, but classes are really nice in some situations
11:13:49 <hdaume> imo, the sml equality type is just an ugly hack
11:14:21 <engstad> Well, state is "bad", but sometimes you can't get away with it. In those situations, it is nice to have a guarantee that the side effects are "contained" within a certain "object", instead of perculating through the system. 
11:15:03 <hdaume> true, but something like the ST monad accomplishes the same thing in haskell
11:15:39 <engstad> Yes, but the state monad machinery is expensive.
11:16:12 <engstad> Both syntactically and in execution.
11:17:15 <hdaume> perhaps in execution...i don't think it's syntactically expensive...i can write 'setPos obj x y' instead of 'obj.setPos(x,y)' or whatever.  as for execution, i have no clue...everythin in haskell is expensive in execution *grin*.
11:17:17 * hdaume sighs
11:19:36 <hdaume> hi
11:22:28 <engstad> hdaume: heh, that's true...
11:22:49 <engstad> hdaume: In principle, it should be faster, shouldn't it? Execution, I mean.
11:23:04 <hdaume> laziness hurts big time
11:23:32 <engstad> And why is that?
11:23:55 <hdaume> it means you get an extra level of indirection for everything unless the strictness analysis can identify that a particular value is strict.
11:24:04 <hdaume> so instead of '5', you get a pointer to '5'
11:24:47 <engstad> So, is the strictness analysis not good enough?
11:25:05 <hdaume> i would imagine that is one of the big problems (can't say for certain though)
11:25:23 <sethk> hdaume:  That isn't quite true.  In general a strict language will also have a pointer in that situation.
11:26:27 <hdaume> i suppose it depends on the circumstances.  i think that in a strict language you have to worry a lot less about things like nonterminating expressions
11:27:15 <sethk> hdaume:  That also depends.  A strict language can't handle the concept of an infinite list, so you can't get an out of control infinite list...
11:27:33 <sethk> hdaume:  But that is not really a performance problem caused by laziness.
11:28:21 <engstad> sethk: so what _is_ the reason for haskell slowness?
11:28:28 <sethk> hdaume:  It is true that, if every value is going to be forced, then a strict language will run faster because it doesn't spend time trying to determine whether to force...
11:28:34 <hdaume> perhaps not directly by laziness, but it's one of the things that laziness allows you to do
11:29:20 <sethk> hdaume:  I believe that part of the problem is that the lazy language is much more sensitive to the quality of the code.
11:30:10 <sethk> I would, in general, not agree that Haskell is always slower.  I did some performance testing and found, that with careful analysis of algorithms and coding, Haskell was only about 1/3 slower than C++.
11:30:34 <sethk> But a naive implementation of the same functionality was about 15X slower.
11:30:37 <engstad> C++ can be many things.. ;-)
11:30:48 <hdaume> but did you spend tons of time optimizing the C, too?
11:31:17 <engstad> My job is to optimize high level code.
11:31:23 <sethk> engstad:  True, but I've been writing C and C++ for twenty years, so I know how to write C code.  On the optimization question...
11:31:43 <sethk> I used similar optimization for both parts of the test.
11:31:58 <sethk> Now, this was one algorithm and doesn't prove anything about Haskell in general, but it is suggestive.
11:32:03 <hdaume> for instance, in manuel's AFP paper, he talks a lot about matrix/vector multiplication.  he optimizes the hell out of the haskell and gets it to run 2 times slower than the C.  but if he used pointer arith, etc., on the C, it would undoubtedly have gotten much faster.
11:32:26 <ibid> sethk: it would be cool to see both programs
11:33:01 <engstad> Manuel's AFP paper?
11:33:05 <sethk> ibid:  When I get back to my office I can post them.  I actually have three different ones I've been working with.
11:33:27 <hdaume> i do agree that quality of code in hs has a huge effect.  the problem is that fast hs code is almost always NOT "haskell-like" hs code
11:33:28 <sethk> hdaume:  As a rule of thumb he could probably double the C performance.
11:33:42 <hdaume> engstad: manuel chakravarty gave a precentation at AFP
11:33:49 <hdaume> presentation, even
11:33:54 <engstad> :-)
11:33:59 <engstad> Is it online somewhere?
11:34:09 <hdaume> probably...hold on
11:34:11 <sethk> hdaume:  Not "haskell-like" how, specifically?
11:34:44 <hdaume> http://www.cs.uu.nl/~johanj/afp/afp4/manuel.ps
11:34:48 <engstad> I guess by using tons of strictness annotations...
11:35:30 <hdaume> sethk: for instance, using tuples destroys performance; yet they are so basic to the language
11:35:48 <hdaume> for example:
11:35:55 <hdaume> assume the functions 'sum' and 'product' don't exist
11:36:03 <hdaume> you want to write a function that calcs the sum and product of a list
11:36:22 <hdaume> (foldr (+) 0 l, foldr (*) 1 l)
11:36:29 <hdaume> is much much much faster than
11:36:50 <hdaume> foldr (cross (+) (*)) (0,1) l
11:37:36 <hdaume> (where cross2 is the 'should-be-in-the-prelude' function: cross2 f g (x,y) e = (f x e, g y e))
11:37:43 <hdaume> (i meant cross2 in the foldr, obviously)
11:37:53 <hdaume> this should be faster because you're only traversing the list once
11:37:57 <hdaume> but it's like 10 times slower
11:38:45 <sethk> hdaume:  Not quite so obvious to me  :)  That is very interesting; I should look at the generated code and see why.
11:39:01 <Marvin--> hdaume: isn't that a typical place where you'd like to use unboxed tuples?
11:39:13 <hdaume> perhaps that would help...i didn't actually try it
11:39:39 <sethk> Marvin:  I've been wondering about exactly what that really does under the covers.
11:39:56 <hdaume> but the problem is that if you're using something like mapAccumL with randoms (updating a random generator), you get terrible performance because of all the tupling)
11:40:23 <sethk> hdaume:  Is that a language problem, or a compiler problem?
11:40:25 <hdaume> Marvin--: but you really shouldn't have to use unboxed tuples to get that to run well
11:40:27 <hdaume> compiler problem
11:41:00 <Marvin--> exactly
11:41:08 <sethk> hdaume:  So, fixable?
11:41:47 <hdaume> sethk: in theory, everything is fixable :)...or sort of.  what you really need to do to fix this is some sort of usage analysis to determine that you can do a destructive update within the tuple, instead of constantly creating new ones
11:42:05 <hdaume> such analysis was attempted in another language (blanking on the nam) and it's very very hard
11:42:57 <hdaume> (Sisal was the language)
11:43:02 <Marvin--> yeah, the persistence is both a blessing and a curse, so to speak :)
11:43:09 <hdaume> yeah
11:43:59 <Marvin--> How hard is it to write C code to use from Haskell? I mean, not as in foreign import, because the types there are pretty limited, aren't they?
11:44:10 <andersca> hey Marvin--
11:44:14 <Marvin--> Does ghc has some sort of C API for working with Haskell types?
11:44:20 <Marvin--> andersca: hello
11:44:21 <hdaume> you could also use combined compile-time and runtime-analysis...using reference counts at runtime could do this; there's a lot of overhead here though
11:44:31 <hdaume> Marvin--: it's quite easy
11:44:39 <andersca> Marvin--: nice lecture today
11:45:02 <sethk> hdaume:  reference counting tends to introduce bizarre bugs that are very hard to find...
11:45:20 <Marvin--> andersca: the lesson? Yeah, I thought it went pretty well
11:45:37 <hdaume> sethk: probably...i don't know much about it
11:45:50 <Marvin--> Reference counting in the Haskell code or the implementing C code?
11:45:51 <sethk> hdaume:  I know _too_ much about it.  :-)
11:46:19 <andersca> Marvin--: is it really necessary to use different names for all the types? (eg tau 1..inf)
11:46:26 <sethk> Marvin:  I assumed he meant within Haskell; hdaume:  correct?
11:46:27 <hdaume> sethk: *grin*...it would probably work for doing array updates in place (which i believe haskell really needs), but not for simple values
11:46:34 <andersca> Marvin--: if you know that x has type tau1, can't you juse use tau1 everywhere then?
11:47:01 <Heffalump> sethk: YM bizarre space leaks, or what?
11:47:29 <Marvin--> andersca: yeah, sure, in simple examples like these... But the point is to automate it as much as possible, to make the compiler/interpreter do it for us, right? :)
11:47:45 <andersca> yeah :)
11:48:10 <Marvin--> andersca: if you're interested in type inference I recommend the paper Typing Haskell in Haskell
11:48:15 <sethk> Heffalump:  More general.  Either (1) coders can increment or decrement reference counts, with the obvious problem when they screw up or (2) references exist to objects that were destroyed.
11:48:31 <sethk> Hefflump:  The latter is not supposed to happen, but it is hard to eliminate.
11:48:35 <hdaume> andersca: luca cardelli's 'basic polymorphic typechecking' is also excellent
11:49:59 <Heffalump> well, cyclic structures are the standard problem with reference counted structures
11:50:08 <engstad> Interesting... parallel arrays. That's surely quite useful.
11:50:35 <Marvin--> Heffalump: which works quite well in Python...
11:50:46 <hdaume> engstad: yeah...i think it's some of the best stuff going on in hs right now (though i'm biased)
11:50:58 <hdaume> Heffalump: does haskell have cyclic structures?
11:52:15 <engstad> hdaume: How come you're biased? Are you working on it?
11:52:30 <hdaume> no...i just use arrays more than most haskellers :)
11:52:39 <engstad> Ah, I C.
11:53:09 <Marvin--> hdaume: data Tree = data Tree = Leaf | Inner Tree Tree; t = Inner t t?
11:54:01 <hdaume> Marvin--: kinda...it's somehow different though (i was thinking 'a = 1:a' but same thing)...i don't know that this would cause ref cnt problems in the same way that cycl structs in for instance C would...
11:54:07 <hdaume> Marvin--: would it?
11:54:27 <Marvin--> hdaume: I don't know, I don't know much about GC and refcounting
11:54:53 <Marvin--> I think that to support cyclic GC in a Python module implemented in C, you have to specify some sort of parent/child relation
11:55:38 <Marvin--> ouch, I wonder who progs-8 are
11:55:46 <andersca> not us!
11:55:55 <andersca> what'd they do?
11:56:09 <Marvin--> they used init and last :-)
11:56:25 <Heffalump> I think that would cause a problem with ref counting
11:56:39 <Marvin--> but they used do notation though, yay
11:56:42 <hdaume> oh, well.
11:56:51 <andersca> like (xs:x) :)
11:57:33 <andersca> Marvin--: how should I write the notation for "return"? I need to have the return type in the environment, right?
11:58:15 <Marvin--> andersca: you've got functions or procedures in your language?
11:58:32 <andersca> Marvin--: procedures
11:58:49 <Marvin--> joy, that's not trivial to implement :)
11:59:13 <andersca> so my environment looks like
11:59:16 <andersca> type Environment = (Maybe Type, [(String, Type)])
11:59:21 <Marvin--> yes you need to pass around information about "the current function" in the environment
11:59:48 <andersca> I'm pondering just ditching functions and implementing them in lab4 :)
12:00:07 <Marvin--> if you want a challenge, implement goto
12:00:44 <Heffalump> in what kind of language?
12:00:45 <andersca> can you type-check goto?
12:00:55 <Marvin--> andersca: well, I mainly meant for lab 3
12:01:04 <Marvin--> Heffalump: a simple imperative language
12:01:19 <norpan> hi all
12:01:27 <andersca> Marvin--: I also thought about lambda expressions and Function variables
12:01:46 <Marvin--> andersca: but if you've got global variables and stuff, getting the scoping right isn't trivial
12:01:57 <Marvin--> hi norpan
12:01:57 <norpan> andersca: goto is a statement, do you have different types for statements+
12:02:29 <andersca> Marvin--: we don't have global variables...you can define a variable anywhere in a block though
12:02:39 <Marvin--> in the language we're using in the assignments in the Semantics course, gotos and labels are typed
12:03:08 <Marvin--> andersca: can you define procedures inside blocks or only on toplevel? Which procedures can call each others? Can you declare procedures inside procedures?
12:03:21 <andersca> only toplevel
12:04:38 <norpan> nu har jag skrivit till AstroNomic och sagt att jag vill vara med och spela deras fåniga spel :)
12:04:54 <Marvin--> okay, so remember to get recursive calls right too :)
12:05:07 <andersca> Marvin--: of course
12:05:22 <andersca> buildProgramList::[Function] -> [(String,Type)]
12:05:23 <andersca> buildProgramList [] = []
12:05:23 <andersca> buildProgramList ((Function name types ret _):fs) = (name, TFunction (map snd types) ret):buildProgramList fs
12:06:24 <hdaume> looks like that should be written using 'map'  :)
12:06:27 <Marvin--> heh, the most amusing thing about correcting these assignments is that people invent so funny names for their languages
12:07:14 <Marvin--> one group had the extension .fluff on all their example programs
12:07:25 <Heffalump> why is implementing goto hard?
12:07:47 <Marvin--> Heffalump: well it's harder than the minimum requirements anyway
12:08:06 <Marvin--> here's one group who call their language NUPL/1 (Nearly Useless Programming Language 1)
12:08:12 <Heffalump> ah, ok
12:09:22 <Marvin--> the minimum requirements are if and while, sequencing statements of course, and some boolean and integer operations in the expressions
12:10:02 <Heffalump> right
12:11:16 <hdaume> i'm so jealous of you people who actually have PL courses at your universities :(
12:11:30 <norpan> hehe
12:11:47 <norpan> that's what's computer science is all about
12:11:56 <andersca> yeah
12:12:23 <hdaume> there's a course here called 'programming languages: design and practice'...it's a grad level course that teaches HTML, XML, JavaScript and Perl.
12:12:24 * hdaume sighs
12:12:29 <hdaume> off to lunch...bbiab
12:12:31 <Marvin--> lol
12:13:42 <Heffalump> hdaume: what does that have to do with "design"? :-)
12:13:52 <Marvin--> *sigh* so many interesting papers to read and so little time
12:14:24 <andersca> Heffalump: I think HTML is the design part :)
12:14:55 <Marvin--> "Compiling Embedded Languages" cool, this I gotta read
12:15:08 <Heffalump> Marvin--: by whom?
12:15:29 <Marvin--> Conal Elliot
12:15:36 <Marvin--> I think it's about PAN
12:15:48 <Heffalump> is it the SAIG'00 paper?
12:15:51 <Marvin--> or Pan, or whatever's correct
12:16:03 <Marvin--> uh, dunno
12:16:10 <Heffalump> are there any co-authors?
12:16:16 <Heffalump> I think it's called Pan
12:16:26 <Heffalump> (I should know, my boss helped write it...)
12:16:43 <Marvin--> Sigbjørn Finne and Oege de Moor
12:17:04 <Heffalump> yeah, it is the one I'm thinking of then
12:17:14 <Marvin--> yah, says de Moor is in Oxford
12:17:31 <Heffalump> well, if he's not, he left rather suddenly :-)
12:29:59 <Marvin--> this paper is pretty cool
12:33:09 <Igloo> Speaking of which, is there a general trend in tenure no longer being given by universities?
12:33:17 <Heffalump> yes
12:33:23 <Heffalump> it doesn't exist in UK unis any more
12:33:31 <Heffalump> (even Oxford in theory, though in practice it does)
12:34:12 * Heffalump dunno about the US though
12:35:14 <hdaume> Heffalump: how do you pronounce de Moor's first name?
12:35:39 <Heffalump> Ooguh
12:35:53 <Marvin--> Dutch :)
12:36:17 <hdaume> okay :)...i've got his and bird's book and have been wondering for some time
12:36:18 <Igloo> Isn't the second syllable more like a hard g?
12:36:29 <Heffalump> igloo: wdym?
12:37:01 <Igloo> Like gerrrr without the errrr
12:37:19 <Heffalump> isn't that what I said though?
12:38:34 <Igloo> The way I read that the last sound was like at the start of "under"
12:38:57 <Igloo> Everyone should just learn the phonetic thingies, then this would be much easier  :-)
12:39:05 <Heffalump> what are the phonetic thingies?
12:39:45 <Igloo> The things dictionaries have
12:40:03 <Heffalump> is it documented anywhere?
12:40:06 <Igloo> Might be a phoenetic alphabet, can't remember OTTOMH
12:43:00 <hdaume> yeah, there's a standard phonetic alpha...i'm sure it's on the web somewhere :)
12:43:33 * Igloo can't see it anywhere obvious from wordnet's homepage
12:43:41 <Igloo> I'm sure jaffa or someone would know
12:44:07 <Marvin--> oh, yeah, and let's make IRC talk unicode so we can use the real symbols
12:53:05 <hdaume> there we go: http://www.arts.gla.ac.uk/IPA/fullchart.html
12:54:36 <Marvin--> and I'd be surprised if they weren't in the unicode standard
12:54:54 <Igloo> Wavs would be useful  :-)
12:55:08 <hdaume> you mean you don't know what a plosive uvular sounds like?
12:55:53 <Igloo> My education has been woefully inadequate
12:56:15 <hdaume> *grin*.  i actually had to memorize all that stuff at one point...it wasn't much fun
12:57:32 <Marvin--> heh
13:00:07 <Marvin--> "Today, with the GNU Hurd working"
13:00:09 <Marvin--> really? cool ;)
13:03:15 <Igloo> I heard X was working on it aaaages ago, which implies it's basically working to me
13:04:49 <norpan> "any year now"
13:11:31 --- topic: set to 'ANNOUNCE: GHC version 5.04.1 released || ICFP 2002 Robot Analysis and Visualization Toolkit 0.9 http://tea.moertel.com/~thor/ravt/ || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || Gtk+HS 0.14.10 released http://www.cse.unsw.edu.au/~chak/haskell/gtk/ || 2002 Haskell Workshop Programme http://www.cse.unsw.edu.au/~chak/hw2002/ || Try to get this topic to fill a whole screen | Don't use drugs, get high on hugs!' by andersca
13:13:15 <Marvin--> duuuuh
13:33:03 <Heffalump> marvin: you've been reading GNU/Linux FAQs :-)
14:27:20 <Igloo> Yay! Working GHC at last!
14:28:43 <Igloo> Oooo, and my first Template Haskell error message
14:28:53 <Igloo> Unfortunately it implies I need to rebuild GHC
14:28:54 <Heffalump> congratulations
14:28:57 <norpan> hehe
14:29:02 <Heffalump> <8 hours later...>
14:29:04 <Igloo> foo.lhs:6: Template Haskell bracket illegal in a stage-1 compiler
14:29:06 <norpan> I want template haskell too
14:29:43 <Heffalump> in a stage-1 compiler?
14:29:50 <Heffalump> norpan: well, prod Igloo until it works properly
14:30:12 <Heffalump> might take three years, but hey...
14:30:31 <Igloo> I;m guessing that means I need to recompile GHC with the stage-1 compiler to make a stage-2 fully featured compiler
14:30:40 <Heffalump> ahh.
14:30:44 <Heffalump> like ghci.
14:30:48 * Igloo should probably find some docs before continuing on this assumption though
14:30:54 <Heffalump> I still don't understand why that is necessary though.
14:31:06 <Igloo> For GHCi or TH?
14:31:11 <Heffalump> did you manage to persuade SPJ that it was a good idea for you to look at it, or are you just doing so anyway?
14:31:14 <Heffalump> for GHCi
14:31:25 <Igloo> I was doing so anyway
14:43:30 <BlizzNL> good evening all
15:06:40 * Igloo looks confused
15:06:48 <Igloo> Do you have to do anything special for ghci to be built?
15:07:11 <Heffalump> you're building from source, not a package?
15:07:17 <Igloo> Yes
15:07:26 <Heffalump> I don't /think/ so, but check the options in standard packages
15:07:39 <Heffalump> (presumably you are building it with the same version of ghc?)
15:07:55 <Igloo> I'm building what claims to be 5.05 with 5.04
15:08:00 <Igloo> Does it actually need to be the same version?
15:08:28 * Igloo thought that was a one-off things to get up from 4.x to 5.x+GHCi
15:09:12 <Heffalump> I'm not certain.
15:09:23 <Heffalump> no, actually, I am
15:09:30 <Heffalump> 5.02.2 -> 5.04 required two builds
15:11:21 <Igloo> Right, ta
15:13:19 <Igloo> Once I cvs update it won't notice though (if it checks version number only, as I got the impression it did)
18:01:15 * pesco is away: sleep
20:43:00 <sethk> Anybody home?????
20:43:16 <clausen> yep
20:43:22 <sethk> I have another "doesn't this fool get monads yet" question.
20:43:35 * clausen probably doesn't either, but ask away :)
20:43:54 <sethk> OK.  I have the following function returning a compiled regular expression:
20:44:50 <sethk> regexTrailingSpaces = regcomp " *$" 0
20:45:07 <sethk> Then I use it in a function to strip the trailing spaces from a string:
20:45:19 <sethk> exeTSRegex s = regexec regexTrailingSpaces s
20:45:59 <sethk> ghci complains because the type of regexTrailingSpaces is IO Regex instead of Regex (or VV; expected is Regex and inferred is IO Regex)
20:46:11 <sethk> I always have to think about which is which  :)
20:47:28 <sethk> Someone a couple of days ago suggested liftM for something like this, but the signature of liftM doesn't look right to me; it appears to translate one monad type into another monad type.
20:48:16 <clausen> hmmm
20:48:40 <clausen> can you please cut&paste the type signatures of everything
20:48:46 <clausen> (regcomp, regexTrailingSpaces)
20:49:13 <sethk> OK.  Hold on a second; I built a new version of kvirc today and I have to figure out how to paste into it   :)
20:50:01 <clausen> ;)
20:50:09 <clausen> BTW: keep prodding me by typing me name
20:50:12 <clausen> s/me/my/
20:50:14 * clausen multitaskig
20:50:36 <sethk> Clausen:  OK.
20:57:01 <sethk> Clausen:  regcomp::  String -> Int -> IO Regex
20:57:01 <sethk> Clausen:  regexTrailingSpaces:: IO Regex
20:57:56 <clausen> that looks right
20:57:58 <Pseudonym> Which regex library are you using?
20:58:00 <clausen> and what's the compile error?
20:59:19 <sethk> Clausen:  ghc 5.04.1 (ghci in this case)
20:59:19 <sethk> Clausen:  The regex library that is with the ghc distribution
20:59:19 <sethk> Clausen:      Couldn't match `Regex' against `IO Regex'
20:59:19 <sethk>         Expected type: Regex
20:59:19 <sethk>         Inferred type: IO Regex
20:59:20 <sethk>     In the first argument of `regexec', namely `regexTrailingSpaces'
20:59:22 <sethk>     In the definition of `execTSRegex': regexec regexTrailingSpaces s
21:00:08 <clausen> so, you want to do something like:
21:00:11 <Pseudonym> Exactly what module are you importing?
21:00:39 <clausen> well, you need to get the "pure regex"
21:00:43 <clausen> to do that, something like:
21:00:50 <clausen>  do pureRegEx <- regcomp ...
21:01:07 <sethk> Pseudonym:  import IO
21:01:07 <sethk> import Char
21:01:07 <sethk> import System (getProgName, getArgs)
21:01:07 <sethk> import Text.Regex.Posix
21:01:32 <Pseudonym> Ah!
21:01:34 <Pseudonym> Don't use that.
21:01:39 <Pseudonym> Use Text.Regex
21:01:39 <sethk> Clausen:  Is that part of hslibs, or another package?
21:01:51 <clausen> sethk: another package
21:01:56 <sethk> Pseudonym:  Don't use what???? :)
21:01:56 <clausen> sethk: I used it a while ago... google it!
21:02:03 <Pseudonym> Prelude> :module Text.Regex
21:02:03 <Pseudonym> Prelude Text.Regex> :info mkRegex
21:02:03 <Pseudonym> -- mkRegex is a variable
21:02:05 <Pseudonym> mkRegex :: String -> Regex
21:02:32 <sethk> Clausen:  Thanks, I'll google
21:02:43 <sethk> Pseudonym:  I'll try that, but why doesn't mine work?
21:03:48 <Pseudonym> Clausen gave the right answer here.  You need get the result from regcomp using monad bind
21:03:50 <Pseudonym> So:
21:04:28 <Pseudonym> do { re <- regcomp ... ; result <- regexec re ... }
21:04:46 <Pseudonym> Rather than: regexec (regcomp ...) ...
21:05:17 <Pseudonym> Text.Regex works better here because it doesn't use the IO monad at all.
21:06:27 <sethk> Pseudonym:  Oh, so don't import Text.Regex.Posix, just Text.Regex?
21:06:29 <Pseudonym> I think that Text.Regex.Posix is only there for compatibility (for people who used the old regex library, and for those who want a more direct mapping to the POSIX interface).
21:06:31 <Pseudonym> Yes.
21:06:49 <Pseudonym> Text.Regex is a more Haskell-esque interface.
21:07:13 <Pseudonym> Text.Regex.Posix is a more C-esque interface.
21:07:38 <sethk> Pseudonym:  Use matchRegex instead of regexec?
21:07:55 <Pseudonym> Yes, or matchRegexAll.
21:10:41 <sethk> Pseudonym:  It appears to be happy now.
21:11:24 <Pseudonym> Cool.
21:18:10 <sethk> Pseudonym:  I think I may be interpreting the definition of matchRegexAll
21:18:10 <sethk> The first argument is "everything before match", which is empty and
21:18:10 <sethk> the second argument which is "portion matched" has the original string,
21:18:10 <sethk> and the last two members of the tuple are empty.
21:18:35 <sethk> string is "testing          "
21:18:35 <sethk> regex is " *$"
21:19:03 <sethk> That last line is "space asterisk dollar sign"
21:19:23 <sethk> Return value is:   Just ("","testing      ","",[])
21:19:24 <o3> re
21:19:37 <sethk> Hi o3
21:20:25 <o3> hullo
21:21:19 <sethk> Pseudonym:  Never mind, I've seen this before; the file has DOS cr/lf instead of UNIX lf.
21:22:45 <Pseudonym> Ah. :-)
21:23:01 <sethk> But, perhaps "un never mind", because I typed that last test string at the console.
21:23:15 <Pseudonym> Try "  *[\r\n]*$"
21:23:38 <Pseudonym> Oh, hang on.
21:23:53 <sethk> Pseudonym:  Good idea but I already stripped the \r's.  :-)
21:24:29 <Pseudonym> OK, try mkRegexWithOpts "  *$" True True
21:24:36 <Pseudonym> instead of mkRegex "  *$"
21:24:51 <sethk> Pseudonym:  Does that have to do with single line/multi line?
21:24:54 <Pseudonym> Yes.
21:25:04 <Pseudonym> Are you familiar with the POSIX regex library?
21:25:36 <Pseudonym> The first bool is REG_NEWLINE.
21:25:46 <Pseudonym> The second one is REG_ICASE.
21:26:00 <sethk> Pseudonym:  Somewhat, but when I learned regular expressions we were in a version of UNIX older than BSD.
21:26:07 <Pseudonym> Ah. :-)
21:26:16 <Pseudonym> System 4 or something?
21:26:36 <sethk> Pseudonym:  3 actually; 4 was an AT&T internal release.
21:29:20 <Pseudonym> Oh, that's right.
23:43:18 <Pseudonym> Eeek.  Linux + threads == nightmare.
23:44:00 <clausen> pq?
23:44:16 * clausen had no problems with linux + threads
23:44:32 <Pseudonym> Ever tried sending a signal to a multithreaded program?
23:44:59 <Pseudonym> Ever tried fork()ing a process with one thread and wait()ing for it to finish in another?
23:45:24 <Pseudonym> We have an application which depends on this.
23:46:58 <Pseudonym> Basically, Linux threads are fine so long as you don't also want Unix processes.
23:47:20 <clausen> threads are a stupid idea, if you want this
23:47:26 <clausen> posix semantics are b0rked
23:47:43 <clausen> the concept of sending a signal to a "process" as in "group of threads" is unsound
23:48:38 <Pseudonym> How so?
23:48:51 <Pseudonym> Real programs just mask off signals in all threads but one.
23:49:40 <clausen> in posix, all the threads share one pid
23:49:45 <Pseudonym> Yes.
23:50:04 <clausen> basically, threads are implemented in the kernel
23:50:12 <clausen> which is too low a level of abstraction
23:50:32 <clausen> hmmm, I guess it's a religious issue :)
23:50:35 <Pseudonym> :-)
23:51:18 <Pseudonym> Let me put it this way: Much code in existence which people might want to port to Linux (like this one) depend on having both posix threads and unix processes being available at the same time.
23:52:27 <clausen> grrr, overloading in mercury is a PITA
23:52:34 <clausen> anyone know mercury?
23:52:54 * clausen is beginning to prefer haskell in a big way
23:52:56 <Pseudonym> Yes.
23:52:56 * Pseudonym wrote half the mode analyser
23:53:00 <clausen> aha
23:53:09 <clausen> Pseudonym: have I met you?
23:53:17 <Pseudonym> I don't know.  Who are you?
23:53:21 * clausen knows someone who did lots of the mode analyser
23:53:25 <clausen> members.optushome.com.au/clausen/photos
23:53:34 * clausen can't remember names
23:53:53 <Pseudonym> I don't think so.  I think you know Fergus.
23:54:00 <clausen> I do know fergus
23:54:11 <clausen> hmmm, I think it was one of my tutors
23:54:14 <clausen> damian, IIRC
23:54:36 <Pseudonym> Not Dave Overton?
23:54:46 <clausen> maybe...
23:54:47 * clausen googles
23:54:52 <Pseudonym> Or DJ?
23:55:45 <clausen> can't remember
23:55:54 <clausen> I think he did his honours thesis last year on it
23:56:50 <Pseudonym> http://www.cs.mu.oz.au/~dmo/
23:56:53 <Pseudonym> That guy?
23:57:43 <clausen> maybe... he doesn't have photos! grr
23:57:50 <clausen> he knew njh, if that helps, hehe
23:57:55 <clausen> but everyone knows njh
23:58:09 <Pseudonym> Anyway... yes, Mercury is crap.  I should know, I wrote some of it.
23:58:20 <clausen> hehe
23:58:28 <clausen> so, got some advice for my problem here?
23:58:31 <Pseudonym> I share an office with another ex-Mercurian, who also thinks Mercury is crap.
23:58:33 <Chilli> Pseudonym: why do you think it is crap?
23:58:33 <clausen> (note: it is for assessment for 471...)
23:58:51 <Pseudonym> Chilli: I'll answer your question in a moment.
23:58:58 <Pseudonym> clausen: What's the problem?
23:59:08 <Pseudonym> You might want to /msg, actually.
23:59:19 <clausen> Pseudonym: it might be of general interest actually
23:59:24 <Pseudonym> Maybe.
23:59:32 <clausen> haskell ppl might/should be mildly interested in seeing some mercury code
23:59:46 * clausen tries to create a dummy test case to simplify the problem
