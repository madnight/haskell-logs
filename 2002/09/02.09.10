01:11:49 <andersca> dennisb: sliff
02:37:27 <delYsid> ibid: Thanks for your help yesterday, it works now!
03:27:46 <delYsid> hmm, \begin{heval} works now, but I cant get arguments to work
04:13:44 <ibid> delYsid: great :-)
04:32:48 * shapr bounces
04:39:36 <delYsid> ibid: Can you explain why use use the list environment with just one \item?
04:39:57 <delYsid> s/use use/you use/
07:12:18 <tmoertel> hello, haskellers!
07:12:21 <Heffalump> hi
07:12:26 <ski> hi
07:13:15 <cleverdra> hello tmoertel.
07:14:16 <tmoertel> what's new in the land of haskell? anybody discover a new use for monads while I was asleep? ;-)
07:15:21 <Heffalump> my boss is currently trying to write an incremental attribute grammar using http://www.cse.ogi.edu/~magnus/Adaptive/
07:16:18 * tmoertel checks link
07:17:32 * tmoertel downloads "Monads for Incremental Computing" paper
07:17:42 <tmoertel> Heffalump: thanks for the link!
07:19:04 <ski> Heffalump: the same
07:27:51 <ChilliX> yep, good paper: will be present at ICFP this year
07:28:16 <Heffalump> present*ed*, surely :-)
07:28:29 <Heffalump> though I suppose it'll be present too
07:28:30 <ChilliX> yeah :-)
07:31:51 <ChilliX> g'night
07:31:59 <Heffalump> night
07:32:19 <tmoertel> ChilliX: 'night! (btw, tried c2hs last night, very cool)
07:32:35 <ChilliX> tmoertel: :-)
07:32:42 * Heffalump is intending to try c2hs when I get a spare moment to make ImageMagick bindings
07:33:10 <ChilliX> that would be useful indeed
07:33:28 <ChilliX> (let me know if you do the bidning, I'll link it from the c2hs page, then)
07:33:36 * ChilliX is really gone now
07:38:48 <shapr> has John Hughes released the new version of QuickCheck?
07:39:14 <shapr> as in, the one mentioned in his second QuickCheck paper?
07:45:16 <Heffalump> the monadic stuff?
07:46:51 <ski> it says "not yet online" at the homepage (http://www.cs.chalmers.se/~rjmh/QuickCheck/)
07:47:28 * tmoertel sips a cup of mauritius tea
07:48:57 <ski> what is mauritius tea ?
07:53:09 <tmoertel> ski: it's a black tea from Mauritius that, depite being only tea, has suprising vanilla notes
07:53:22 <ski> ok
07:56:09 <tmoertel> ski: http://tea.hypermart.net/countries/mauritiusfacts.html
07:56:57 * ski looks at link
08:01:38 <ski> I'll be going for today now
08:01:44 <ski> Bye
08:01:54 <shapr> cya next time ski
08:06:03 <tmoertel> 'night, ski!
08:12:44 <shapr> hi sethk
08:58:34 <sethk> hello
08:58:40 <shapr> hi hal
08:59:10 <shapr> cool, 26 unique users
08:59:15 <shapr> this channel is growing fast =)
08:59:55 <shapr> hello everybody!
09:00:08 <shapr> I want a Zope replacement written in Haskell.
09:00:25 <hdaume> what is Zope?
09:00:30 <hdaume> anyone know much java?
09:00:33 <shapr> that could work if the dynamic loading thread on ghc-users bears fruit.
09:00:38 <shapr> hdaume: I know far too much java :-/
09:00:45 <hdaume> *excellent*
09:00:54 <shapr> Zope is the "Z Object Publishing Environment"
09:01:04 <shapr> it's a content management system written in Python
09:01:07 <hdaume> ah
09:01:12 <hdaume> hi all...i'm trying to get a JTextField to not paste when middle clicked on (on solaris)...i've set editable to false and have added a mouse listener which does something different when middle-clicked on, but text still gets pasted in...any suggestions? (same thing happens in linux)
09:01:32 <hdaume> (sorry for the 'hi all' -- i asked on #java but no one likes me)
09:01:36 <shapr> heh
09:01:57 <shapr> I'm not sure how to do it, but I can figure it out really fast with jython
09:01:59 <shapr> just a moment...
09:02:02 * shapr opens jython
09:02:19 <hdaume> tnx
09:04:04 <sethk> Does the mouse listener get called before or after the unwanted paste occurs?
09:04:42 <hdaume> hard to say...i think after; i've tried calling e.consume() in the mouseClicked(..) function but that doesn't help.
09:04:55 <hdaume> lemme check tho
09:05:20 <sethk> For a quick test, just have your listener go into an infinite loop...
09:05:34 <hdaume> ah, good idea :)
09:06:11 <hdaume> damn javac for recongnizing unreachable statements
09:06:40 <sethk> Well, you can always loop for 2 billion cycles, or something
09:06:56 <hdaume> ah, it seems to call my mouse listener before the insertion
09:08:26 <sethk> Then it begins to make some sense.  It's been a while since I looked at this, and I think it is related to the multiple paste source issues in X...
09:08:50 <shapr> hm, could you redefine BUTTON2 in the keymap?
09:09:04 <sethk> There are basically two independent paste mechanisms in X, and it is easy to turn off paste for the wrong one...
09:09:27 <sethk> Shapr, that would turn it off for everything, not just the one field, wouldn't it?
09:09:45 <shapr> you can set keymaps per-component afaik
09:09:56 <sethk> Didn't know that...
09:10:11 <hdaume> hrm...okay...
09:10:20 <shapr> yah, jTextField.getKeymap()
09:10:23 * hdaume thinks he will have Shift+Button3 do what Button2 was supposed to :)
09:10:39 <shapr> sethk: I didn't know about the two different paste mechanisms, tell me more :-)
09:11:42 <sethk> Well, if you have KDE and emacs installed, you can see it very quickly.  Something highlighed will paste into emacs, but something capture with edit/copy will not...
09:12:01 <shapr> javax.swing.text.DefaultEditorKit$PasteAction@2b079a
09:12:13 <sethk> There is a global paste buffer...
09:13:19 <sethk> Then there are named paste buffer
09:14:21 <hdaume> ...still, shouldn't you not be allowed to paste in to a text field with setEditable(false)?
09:16:52 <sethk> No, because pasting is the same as setting the text value.  You can set the text through the API; setEditable just stops the user from changing it.
09:16:53 <shapr> that does sound sensible
09:17:16 <hdaume> but equivalently, cutting and pasting is *editing*, is it not?
09:17:38 <sethk> You are being logical, and we are talking about Java
09:17:43 <hdaume> *grin*
09:17:57 <sethk> I've run into this before...
09:18:38 <sethk> By the way, any opinions on the GUI libraries that are usable with Haskell?
09:19:17 <hdaume> the only one i've used is gtk2hs, which is usable
09:19:29 <hdaume> (then again, i'm using java to write a UI tool right now, so...)
09:20:01 <sethk> Yes, I've played with gtk2hs also.  He has released a gtk v2 compatible version a few days ago, I believe.
09:26:23 <hdaume> anyone know off the top of their head how to pop up a messagebox in swing?  i know there's some collection that provides a static function, but can't remember where it is....
09:26:41 <sethk> Hang on, I've got lots of code that does that...
09:28:23 <sethk> JOptionPane.showOptionDialog (or other JOptionPane stuff)
09:28:39 <hdaume> tnx (you'd think the swing tutorial would have a 'hello world' program doing that)
09:31:39 <sethk> As I said, we are talking about java...
09:40:43 * shapr gives up
09:40:52 <sethk> Bye
09:40:55 <shapr> bye sethk
09:41:02 <shapr> hdaume: that's scary stuff
09:41:37 <shapr> looks like you'd have to get hold of the EditorKit for the JTextField, and change which services it offers
09:42:11 <hdaume> not worth it :)
09:42:22 <shapr> yah, I agree
10:47:49 <shapr> hi delYsid
10:48:05 <delYsid> hey!
10:48:10 <delYsid> I've got my new display!
10:49:15 <shapr> spiffy!
10:52:47 <shapr> whew, done with paying work for today.
10:55:19 <hdaume> is that good or bad?
10:56:01 <delYsid> http://www.humanware.com/E/E1/E1B.html
11:00:57 <shapr> hdaume: that's good... now I have time to do Haskell stuff
11:01:46 <shapr> delYsid: neato
11:01:55 <shapr> I'm tempted to learn braille :-)
11:05:06 <hdaume> delYsid: cool
11:05:24 <delYsid> yay, I'm just trying to get used to it :)
11:05:52 <delYsid> But the ergonomics is good so far
12:01:39 * shapr bounces
12:23:41 * shapr installs subversion
12:23:49 <andersca_> woo
12:24:03 <shapr> it's installed.
12:24:13 <shapr> the debian package is easy to install.
12:24:16 <shapr> now what do I do with it....
12:24:30 * shapr reads subversion docs
12:34:36 <andersca_> hej marvin flarvin
12:34:42 <Marvin--> :)
12:34:49 <andersca_> whoops, right
12:34:52 <andersca_> this is #haskell, sorry :)
12:34:58 <Marvin--> haha
12:35:08 <andersca_> Marvin--: so, what's up for tomorrow?
12:35:09 <Marvin--> yeah, I haven't been neither here nor #swedesex for a while
12:35:31 <Marvin--> andersca_: good question, I'm not very involved in it... I know I'll be there selling beer, but that's about it for my part
12:35:43 <andersca_> Marvin--: I'm talking about the lecture :)
12:35:50 <Marvin--> andersca_: d'oh!
12:35:58 <Marvin--> And tomorrow is not Thursday either, gee I'm tired
12:36:23 <Marvin--> and for starters, it's not a lecture
12:36:27 <andersca_> ok
12:36:42 <Marvin--> I thought I'd let the students decide what to do with the hours
12:36:57 <andersca_> uh oh
12:37:22 <Marvin--> naturally I have a devious plan for what the choices are :)
12:37:51 <andersca_> Marvin--: I started writing a lisp interpreter :)
12:38:05 <andersca_> Main> run "(quote (a b c))"
12:38:05 <andersca_> "(a b c)"
12:38:11 <Marvin--> oh brother :)
12:38:11 <andersca_> that's all it can do right now :)
12:38:44 <Marvin--> I don't know any lisp so you better submit a formal grammar, type system and semantics, hah
12:39:04 <andersca_> I'm not doing this for the lab
12:39:07 <Marvin--> oh
12:39:13 <Marvin--> then you're just sick ;)
12:39:14 <andersca_> The lab isn't up yet :/
12:39:33 <Marvin--> hmm, I thought it was up... Maybe Marcin meant to put it up tomorrow
12:39:53 <Marvin--> nope, you're right
12:40:01 * shapr fights with subversion
12:40:05 <Marvin--> oh well, it's officially introduced on Thursday
12:40:29 <andersca_> cool
12:40:34 <andersca_> Marvin--: what's the fifth assignment?
12:40:42 <Marvin--> there's no fifth assignment, only four
12:40:48 <andersca_> there are five for gu students
12:40:53 <andersca_> right?
12:41:06 <Marvin--> well, in the sense that GU students have to do two things in assignment four... yes I suppose you could say so
12:41:11 <andersca_> oh, ok
12:41:18 <andersca_> does it involve writing a compiler?
12:41:33 <Marvin--> there are several things to choose from, I don't remember them all
12:41:37 <andersca_> cool
12:42:20 <Marvin--> the first three assignments are about creating an imperative language (syntax, typesystem, semantics)
12:42:27 <andersca_> nod
12:43:00 * Marvin-- shivers when he thinks what weird languages people will use
12:43:15 <andersca_> Marvin--: my lab partner likes to write C programs without any reserved words :)
12:43:29 <Marvin--> debug?
12:43:43 <Marvin--> or how many weirdoes are you anyway? ;)
12:43:59 <andersca_> yeah debug
12:44:06 <Marvin--> phew, one less person to worry about
12:44:09 <andersca_> oh right
12:44:41 * shapr creates his first subversion repository
12:44:43 * Marvin-- hopes many people will be clever and use haskell
12:45:05 <andersca_> Marvin--: we will, just because we're nice guys :)
12:45:13 <Marvin--> woohoo
12:46:08 --- mode: ChanServ set +o Chilli
13:04:58 <toadx> any used the haskell libraries for CGI or MySQL
13:05:22 <shapr> I've done some CGI stuff
13:05:28 <shapr> WASH-CGI is cool
13:05:38 <Marvin--> when I did CGI in Haskell I wrote my own little module, I didn't need anything advanced
13:06:11 <toadx> cool, I didn't see this one...
13:07:54 <Marvin--> How hard is it to write C extensions for Haskell, say with ghc? Does it have a C API?
13:08:06 <shapr> yah
13:08:12 <shapr> the famous FFI
13:08:17 <shapr> Foreign Function Interface
13:08:54 <hdaume> it's quite easy once you get the hang of it
13:09:36 <andersca_> Marvin--: when's the exercise tomorrow?
13:09:51 * shapr prefers morning exercise
13:09:55 <Marvin--> andersca_: 13.15
13:10:00 <Marvin--> well
13:10:09 <Marvin--> that's my time anyway, Christoffer's is at 15.15
13:10:11 <shapr> where's the exercise?
13:10:14 <andersca_> ok
13:10:33 * shapr considers taking a bus to chalmers and drinking beer with Marvin--
13:10:39 <Marvin--> shapr: :)
13:11:19 <shapr> actually, I'd have to leave now to be there in time :-(
13:11:27 <andersca_> hurry up then!
13:11:28 <andersca_> :)
13:11:57 <shapr> I think I'll wait till I'm living in Boden
16:42:48 <Pseudonym> comb f p1 p2 j n = = p1 (\x -> p2 (\y -> j (f x y)) (j x)) (p2 j n)
16:42:56 <Pseudonym> i think that's the most evil combinator I've ever written.
16:50:01 * shapr yawns
16:50:15 <Pseudonym> Why are you still awake?
16:50:32 * Pseudonym thinks . o O ( Or are you? )
16:50:33 <shapr> I tried to sleep.
16:50:37 <shapr> it didn't work.
16:51:03 <Pseudonym> Fairy nuff.
16:51:06 <Igloo> Are you troubled?
16:51:25 * Igloo doesn't think "comb" is a very useful name for the above  :-)
16:51:53 <hdaume> yuck
16:51:53 <hdaume> at least there's no need to comment it...it's obvious what it does :)
17:02:54 <Pseudonym> It used to be "combine", then I did some hand-transformation on it, and the legacy name stuck.
17:03:21 * Pseudonym wonders what it looks like in SK combinators
19:55:02 <tmoertel> can anybody find an error in or see a way to improve the haskell build rules in this makefile? http://tea.moertel.com/~thor/ravt/ravt-0.7.5/Makefile
19:55:42 <tmoertel> i think that the method i'm presently using is correct, does minimal work, and automatically maintains dependencies
19:56:06 <tmoertel> but i could be mistaken (as is often the case)
20:28:13 <olczyk> Can anyone tell me if there is a haskell compiler/interpreter that comes with a GUI toolkit?
20:32:50 <tmoertel> olczyk: I don't believe that any of the majors have a preferred GUI
20:33:42 <Pseudonym> There's a bunch of them.  Bindings to Tk, fudgets, OpenGL and so on.
20:33:48 <Pseudonym> But there's nothing standard.
20:34:09 <sethk> There is not a concensus, it is fair to say
20:34:24 <olczyk> I'm just worried about being able to build simple things quickly eg
20:34:51 <olczyk> this years icfp it would be useful to draw the board as you are analysing to
20:35:07 <olczyk> see that you implement the algorithms correctly.
20:35:11 <Pseudonym> http://haskell.org/libraries/#guigs
20:35:39 <Pseudonym> That's pretty much the state of play.
20:36:08 <sethk> I'm working with gtk+hs because (1) it is under active development and (2) I can build quick GUIs with python when Haskell isn't fast enough
20:36:22 <Pseudonym> For something quick 'n dirty like that, you're probably best off with a Tk binding.  Especially if you know Tk.
20:36:38 <jemfinch> sethk: you mean "when Haskell doesn't speed development enough for me", right?
20:36:49 <Pseudonym> Tk is not bad if you don't care how it looks and you're not too demanding.
20:36:50 <sethk> Yes, not talking about execution speed.
20:36:59 <jemfinch> sethk: just making sure :)
20:37:53 <Pseudonym> Personally, I think the Object IO library is the Way of the Future(tm) here.
20:38:05 <sethk> I think that after I have more Haskell experience python probably won't be any quicker, actually.
20:38:05 <Pseudonym> But that's just my bias.
20:38:20 <sethk> Last time I looked object I/O was only Windows.  Is that still true?
20:38:58 <Pseudonym> Yes.
20:39:09 <Pseudonym> That's why it's not the Way of the Present.
20:39:32 <tmoertel> indeed
20:39:40 <sethk> I like the structure and concept.  Are there plans to support other platforms, do you know?
20:40:11 <Pseudonym> I dunno.  Is there anyone here from Yale?
20:40:37 <tmoertel> From http://haskell.cs.yale.edu/ObjectIO/: "#
20:40:39 <tmoertel> Object I/O works under GHC-5.02 and higher for Windows. The Linux version is under development."
20:40:46 <Pseudonym> Gotcha.
20:40:58 <sethk> Hopefully by Linux they really mean X windows.
20:41:28 <Pseudonym> Well in theory there's more in ObjectIO than just GUI stuff,
20:41:39 <Pseudonym> But yes, probably they mean X Window.
20:42:27 <tmoertel> Gtk: "I intend to develope Gtk port for the next release."
20:42:35 <tmoertel> Source: http://free.top.bg/ka2_mail/
20:42:42 <sethk> X windows plus Posix will work.
20:42:53 <sethk> Is that separate from gtk+hs?
20:42:56 <olczyk> What about both Linux and WIndows?
20:43:31 <sethk> It (ObjectIO) already supports windows, so UNIX/Linux/etc. is what is missing.
20:44:16 <Pseudonym> BTW, the X Consortium hates it when people say "X Windows".
20:44:34 <Pseudonym> Have a look at the SYNOPSIS section of "man X".
20:44:59 <sethk> Why?
20:45:08 <sethk> Why do they hate it, not why should I look :)
20:45:13 <Pseudonym> I think it's too easily confused with the other Windows.
20:46:03 <sethk> I have about $400 worth of books that say X windows; I'm too old to change.
20:48:53 --- mode: card.freenode.net set +o Chilli
20:49:15 <tmoertel> who's going to be at the haskell workshop at icfp?
20:49:26 <tmoertel> (from #haskell)
20:49:39 <tmoertel> (show of hands, please) ;-)
20:49:51 <sethk> When and where is it?
20:50:06 <tmoertel> Pittsburgh on Thursday, 3 Oct
20:52:27 <sethk> Has anyone used a library with Haskell for the equivalent of Python's associative arrays, aka hash tables, or possibly implementing a tree structure of some sort?
20:53:20 <tmoertel> Data.FiniteMap is commonly used for this purpose.
20:53:31 <sethk> In base?
20:53:37 <tmoertel> Yes.
20:53:59 <sethk> I'll take a look...
20:54:23 <tmoertel> Haddock docs: http://www.haskell.org/ghc/docs/latest/html/base/Data.FiniteMap.html
20:54:45 <sethk> got it.
21:01:33 <sethk> in PlusFM, what do they mean by "Mappings in the second argument shadow those in the first"?
21:02:05 <Pseudonym> That means that if the first map maps, say, "foo" -> "bar" and the second maps "foo" -> "baz", it's the latter which is chosen in the plus'd map.
21:03:50 <sethk> This should be an interesting exercise...
21:12:56 <sethk> Anyone interested in a Happy (parser, not state of mind) question?
21:13:23 <Pseudonym> You might as well ask.
21:15:14 <sethk> OK.  I have the parser already written and working, it produces a list of lists.  Now I want to add some parsed data into my FiniteMap.  I have a main program which currently just prints the results.  Should I just code the rest in the .y file, or use the method that the parser exports?
21:15:49 <sethk> Or try to code actions that put the required data into the map directly?
21:17:12 <Pseudonym> I'd separate processing from parsing.  That is, call the parser and then do processing.
21:17:35 <Pseudonym> However, there are sometimes good reasons not to.  Like if you don't expect your program to get big and want to put it all in the one file.
21:18:43 <sethk> OK.  It is a monadic parser, and the function type is P [Line].  I'm not sure how to link this to the input file, as currently I'm opening and reading the file in the test program but not calling the exported function.  I'm calling "runParser" as in Simon's LexerText.ly example.
21:18:57 <sethk> LexerTest, not LexerText.
21:20:43 <Pseudonym> I don't understand.
21:20:54 <Pseudonym> You're reading in the contents of the input file into a string.
21:21:13 <Pseudonym> Then you call runParser on that string and it should give you a [Line], right?
21:22:05 <sethk> Yes, with hGetContents, and yes, but the function in the %name directive is not runParser.  Maybe all I have to do is change the %name line to use runParser
21:22:30 <Pseudonym> Erm...
21:22:41 <Pseudonym> In the LexerTest example, it uses %name calc.
21:23:00 <Pseudonym> Then there's another function, runCalc, which is an example of how to call calc.
21:23:06 <Pseudonym> I assume your runParser is like that runCalc?
21:23:32 <Pseudonym> One way to use it from the IO monad, by the way, might be something like this:
21:23:38 <sethk> Essentially, yes, although of course the type is different.
21:23:43 <Pseudonym> runParser :: String -> IO [Line]
21:24:32 <Pseudonym> runParser s = case parser s 1 of { ParseOk lines -> return lines; ParseError err -> fail err }
21:24:41 <Pseudonym> Actually, come to think of it, that'll work for any monad.
21:24:49 <Pseudonym> runParser :: (Monad m) => String -> m [Line]
21:25:42 <Pseudonym> Is that the sort of thing?
21:27:28 <sethk> Yes.  I don't quite understand Monads, really, yet; it is the only part of the language that I don't quite get.  30 years of imperative programming...
21:28:04 <Pseudonym> Which is odd, since monads are acually the most imperative part of Haskell.
21:28:09 <ibid> sethk: monads *are* imperative programming :-)
21:28:12 <Pseudonym> Or perhaps I should say "ironic".
21:28:20 <Pseudonym> No!  Monads are pure functional programming!
21:28:51 <ibid> sethk: monads form an imperative language which is embedded quite nicely in haskell
21:28:56 <ibid> Pseudonym: that too
21:29:07 <sethk> Yes, but I have problems calling non-monadic functions from monadic functions, and knowing when to use "do" and when to use ">>=" or ">>".
21:29:30 <ibid> sethk: think of >> as ; and >>= \x -> as assignment :-)
21:29:48 <Pseudonym> sethk: You might want to always use do.
21:29:56 <Pseudonym> At least until you've got the hang of it.
21:29:57 <ibid> sethk: and, actually, do adds that sugar
21:30:18 <Pseudonym> Yes, do is just syntactic sugar for >> and >>=.
21:30:42 <Pseudonym> do { x <- foo; bar } is the same as foo >>= \x -> bar
21:31:17 <ibid> so, essentially, >>= \x -> is just an inverted assignment statement, in the plankalül tradition ;-)
21:31:17 <sethk> Strangely, though, I find ">>=" and ">>" easier than do.  But I end up with an anonymous function (lambda) and I don't quite see to what it is applied.  Also, forget the sugar; I'm trying to understand what is really happening.
21:31:49 <Pseudonym> The anonymous function is passed as the second argument of >>=.  Something inside >>= calls it.
21:32:04 <Pseudonym> It's applied to whatever is the return value of the first argument.
21:32:11 <ibid> sethk: okay, when you do monadic programming, you are building a huge abstract function that the implementation applies to the world after you return it from main
21:32:30 <ibid> but yes, Pseudonym said it better :-)
21:33:33 <sethk> I get that on a conceptual level.  Let's take a look at a VERY simple example, which is in my lexer which is almost identical to the lexer in LexerTest.ly.  The fifth line has the lambda, so wait for it...
21:34:16 <Pseudonym> Note: This talk of "imperative" only really applies to the IO monad, though other monads also conceptually give you something like imperative programming.
21:34:25 <sethk> lexer :: (Token -> P a) -> P a
21:34:35 <Pseudonym> OK.
21:34:35 <sethk> lexer cont s = case s of
21:34:54 <sethk> [] -> cont TokenPreEOF ("\xff")
21:35:03 <ibid> Pseudonym: the other monads are also imperative, they just order something else than the world :-)
21:35:16 <sethk> ('\xff':cs) -> cont Token EOF []
21:35:18 <ibid> order around, that is
21:35:48 <sethk> ('\n':cs) -> \line -> lexer cont ('\x00':cs) (line+1)
21:36:00 <sethk> Now, what is the function and what is the argument in that last line?
21:36:27 <ibid> where is the monad? or is this monadic at all?
21:36:28 <Pseudonym> OK.  Do you know what the concrete type of P a is?
21:36:46 <Pseudonym> What this is, in fact, is a subtle bit of currying.
21:36:52 <Pseudonym> It's equivalent to:
21:36:58 <Pseudonym> lexer cont s line = case s of
21:37:07 <Pseudonym>     [] -> cont TokenPreWOF ("\xff") line
21:37:10 <ibid> ahh
21:37:11 <Pseudonym> -- etc etc
21:37:24 <Pseudonym>     ('\n':cs) -> lexer cont ('\x00':cs) (line+1)
21:37:48 <Pseudonym> The type P a is actually a function which takes a list of Chars and a line number.
21:38:25 <sethk> Let me paste in the type of lexer from the ghci :type output...
21:38:29 <Pseudonym> OK.
21:40:08 <sethk> wait a second, I have to pull a version that compiles out of RCS...
21:40:58 <sethk> *Main> :type lexer
21:41:07 <sethk> forall a.
21:41:27 <sethk> (Token -> String -> Int -> ParseResult a) -> String -> Int -> ParseResult a
21:41:57 <Pseudonym> SO actually, P a is the type String -> Int -> ParseResult a
21:42:27 <sethk> Yes, and ParserResult is lifted from Simon's example, it is only three lines so here it is:
21:42:33 <sethk> data ParseResult a
21:42:37 <sethk> = ParseOk a
21:42:44 <sethk> | ParseFail String
21:42:58 <Pseudonym> Right.
21:43:16 <sethk> With ParseOk and ParseFail either completing or printing out the error with line number.
21:43:27 <Pseudonym> So, you see, lexer actually takes _three_ arguments, not one as the declared type might lead you to believe.
21:43:36 <Pseudonym> But that's okay because of the wonders of currying.
21:43:56 <Pseudonym> To make things more confusing, the actual definition has _two_ arguments.
21:44:18 <Pseudonym> The lambda is just there to modify the third one.
21:44:53 <sethk> That's where I lose it.  The third one is, in fact, (line+1).  Do you mean that the lambda is to supply the value of line?
21:45:07 <Pseudonym> Yes.  In ther other case alternatives, it's implicit.
21:45:12 <Pseudonym> It's like saying:
21:45:15 <jemfinch> ok, I'm coming at Haskell from an O'Caml/SML and Python background -- is there any tutorial that's probably best for me?
21:45:29 <Pseudonym> ('\xff':cs) -> \line -> cont Token EOF [] line
21:46:16 <sethk> Oh ... because I'm not modifying line it can be implicit.
21:46:27 <Pseudonym> Yes, exactly.
21:46:48 <jemfinch> shapr: you around?
21:46:48 <sethk> jemfinch, I like Paul Hudak's book a lot.
21:46:58 <Pseudonym> I think he's asleep, jemfinch.
21:47:02 <jemfinch> sethk: books are out of my domain, I'm a broke college student :)
21:47:34 <Pseudonym> jemfinch: Did you look at te "Gentle Introduction"?
21:47:39 <Pseudonym> http://www.haskell.org/tutorial/
21:47:43 <sethk> I see.  I was looking at it backwards, as in (\x.x)y = y, but that isn't the right analogy.
21:47:55 <Pseudonym> Might be a bit basic for someone who's familiar with ML already.
21:48:03 <jemfinch> Pseudonym: I'm looking at that list right now, but since there were so many, I figured I'd ask about which one was best :)
21:48:50 <Pseudonym> sethk: Correct.  (\x. E x) = E if x does not appear in E
21:48:52 <jemfinch> (oops, I meant, I'm looking at http://www.haskell.org/bookshelf/ )
21:48:54 <sethk> Actually, I found that the tutorials explained what I already knew and didn't explain much else.
21:49:21 <Pseudonym> You know, by the way, that function application is left-associative?
21:49:24 <jemfinch> does Haskell have a module system, btw?
21:49:28 <Pseudonym> f x y = (f x) y
21:49:32 <Pseudonym> jemfinch: Yes it does.
21:49:41 <Pseudonym> It does not have first-class modules like ML, though.
21:49:49 <jemfinch> Pseudonym: ML doesn't have first-class modules either :)
21:50:06 <Pseudonym> Duh.  Yes.  Which one is it that does?
21:50:18 <jemfinch> there is, I think, one experimental ML compiler that has first-class modules.
21:50:21 <Pseudonym> Right.
21:50:24 <sethk> On the ghc list, Simon and Simon have a new improved module/package implementation due soon.
21:50:24 <jemfinch> Python has first-class modules :)
21:50:32 <Pseudonym> BTW, I hate SML.
21:50:37 <jemfinch> really?
21:50:42 <jemfinch> I liked it better than O'Caml.
21:50:47 <Pseudonym> Having to topologically sort your program is stupid.
21:50:54 <Pseudonym> IMO, of course.
21:51:05 <tmoertel> IMO, as well.
21:51:05 <jemfinch> what do you mean by "topologically sort your program"?
21:51:16 <sethk> I find the Haskell syntax much more intuitive.
21:51:19 <Pseudonym> I mean if you have mutually recursive functions, you shouldn't have to declare them together.
21:51:25 * jemfinch can't read Haskell yet.
21:52:16 <jemfinch> Pseudonym: there are arguments for both, I think -- topologically sorted programs are probably a bit easier to read because things like mutually recursive functions and datatypes are declared together.
21:52:45 <Pseudonym> The problem I have with it is that it requires restructuring your program if your dependencies change.
21:52:59 <Pseudonym> BTW, I don't like forward references in imperative languages either.
21:53:06 <jemfinch> forward references?
21:53:07 * Pseudonym finds them archaic
21:53:19 <jemfinch> (pardon my lack of terminological education :))
21:53:24 <sethk> How can you have mutual recursion without at least one forward reference?
21:53:41 <Pseudonym> sethk: Easy.  You compile a whole module at once.
21:54:08 <sethk> So the compiler discovers the type information on an earlier pass?
21:54:28 <Pseudonym> jemfinch: I mean having to declare something textually earlier than you use it.
21:54:43 <Pseudonym> sethk: Right.
21:54:58 <jemfinch> Pseudonym: ok.
21:55:13 <jemfinch> types are first-class in Haskell, right?
21:55:23 <sethk> well........
21:55:42 <Pseudonym> Haskell works on Hindley-Milner types.
21:55:48 <Pseudonym> With extensions.
21:56:09 <Pseudonym> If you know ML types, Haskell types should be straightforward, at least until you hit type classes.
21:56:28 <jemfinch> yeah, type classes are one of the things I find interesting about Haskell.
21:56:34 <jemfinch> are they widely used?
21:56:39 <Pseudonym> Absolutely.
21:57:18 <jemfinch> it seems they offer a lot of the maintainance flexibility of OOP.
21:57:28 <sethk> All, I have to go fix a core dump (not programmed in Haskell, obviously).  Back in a few...
21:57:37 <Pseudonym> Cool.
21:58:10 <Pseudonym> jemfinch: They do, but there is one piece of functionality that OOP gives you which Haskell doesn't (yet), and that's the ability to downcast.
21:58:26 <sethk> But to finish, quickly, you are saying that it is significant that "line" is not free in the lambda expression.
21:58:30 <Pseudonym> If the Child class derives from Parent, there's no way to dynamically cast a Parent to a Child.
21:58:39 <jemfinch> hmm.
21:58:59 <Pseudonym> sethk: It's significant that "line" is not free in the _other_ case alternatives.
21:59:14 <Pseudonym> Otherwise there's nowhere where it's bound.
21:59:15 <sethk> OK.
22:00:08 <Pseudonym> jemfinch: IMO that (and the associated "isa" operation) is probably the only thing which prevents "standard" OO code from having a natural mapping into Haskell.
22:00:10 * jemfinch is searching for his next language, Haskell is one of the contenders.
22:01:05 <sethk> In terms of bound or free, what is the difference between line (albeit implicit) and (line+1)?
22:01:41 <Pseudonym> In \line -> foo line
22:01:45 <Pseudonym> and \line -> bar (line+1)
22:01:58 <Pseudonym> line is bound by the time the lambda is called in each case.
22:02:08 <Pseudonym> In fact, line is "bound" by the lambda absraction.
22:02:43 <Pseudonym> jemfinch: What are the other contenders?
22:02:57 <jemfinch> Pseudonym: thus far, Dylan is the only serious contender.
22:03:17 <Pseudonym> What are you looking for in a "next" language?
22:04:02 <sethk> OK, essentially it never gets used in the other expressions so it kind of hangs around unstated.
22:04:09 <jemfinch> if I could *design* my next language, it would be a strictly typed, mostly functional, everything's-an-object language.
22:04:37 <jemfinch> with a decent protocol for imitating various types with user-defined classes.
22:04:42 <Pseudonym> sethk: Sort of.  It never gets modified in the other expressions, so it can be passed around implicitly.
22:04:50 <sethk> "Everything's an object" is fatally flawed.  But if I start talking about that I'll never get away from the terminal.
22:04:55 <Pseudonym> sethk: If you think of giving the lambda a name it makes more sense.
22:05:01 <sethk> I'll be back ASAP.
22:05:04 <Pseudonym> sethk: OK.
22:05:36 <Pseudonym> jemfinch: Tried Eiffel or Sather?
22:06:06 <jemfinch> Pseudonym: no, Eiffel has some flaws as far as its static typing system goes, and Sather seems...dated.
22:06:19 <Pseudonym> Fair enough.
22:06:32 <Pseudonym> They're pretty close in philosophy, though?
22:07:01 <jemfinch> Eiffel is more of an imperative-OO language than a functional-OO language, I think.
22:07:11 <Pseudonym> That's true.
22:07:30 <Pseudonym> Personally, I don't buy the "everything is an object" idea either, BTW.
22:07:42 <jemfinch> I've found it really useful in my Python development, at least.
22:07:56 <Pseudonym> Though Haskell has something similar.  Everything in Haskell is an algebraic data type.
22:08:04 <jemfinch> the ability to replace one object with another that's implemented in an entirely different fashion is helpful for maintainability.
22:08:11 <Pseudonym> Unless you have glasgow extensions turned on, anyway.
22:08:39 <jemfinch> for instance, a function that takes another function in Python can take any object that defines an __call__ method.
22:08:43 <Pseudonym> jemfinch: That's true, but I question whether or not you really need to replace an integer or a character.
22:08:52 <Pseudonym> In most cases.
22:09:18 <Pseudonym> Besides, if you have type classes, you do away with pretty much all of the cases where you would otherwise need it.
22:09:45 <Pseudonym> Second-order lambda calculus rules.
22:10:04 <jemfinch> the problem with having "types" that aren't objects is that while an integer might work fine at first implementation, later, when you want to change it to, say, a BigInt or something, you have to change your implementation.
22:10:36 <Pseudonym> Not if you have type classes, like I noted. :-)
22:10:51 <jemfinch> I'm going to have to look into this type class thing :)
22:11:06 <Pseudonym> The idea behind type classes is very cool.
22:11:27 <Pseudonym> If everything is an object, then your object is technically some data plus a dictionary of methods.
22:11:42 <Pseudonym> The dictionary is static, of course.
22:11:42 <jemfinch> yeah, that's true.
22:11:55 <Pseudonym> In Haskell, you pass the dictionary separately.
22:11:59 <jemfinch> it would have to be in a statically typed language, yes.
22:12:34 <Pseudonym> The benefit is that you can add superclasses to any type at will.
22:12:41 <jemfinch> what do you mean?
22:12:48 <Pseudonym> And just pass in whichever dictionary you need.
22:13:07 <Pseudonym> OK.  Haskell has the class Ord, which is the class of all types which are "orderable".
22:13:23 <Pseudonym> They support <, <=, > and >=.
22:13:34 <Pseudonym> And it's a subclass of Eq, the class of all types which support equality.
22:13:52 <Pseudonym> == and /= (which is Haskell's way of spelling "not equal")
22:14:04 <Pseudonym> With me so far?
22:14:15 <jemfinch> yup :)
22:14:31 <Pseudonym> OK.  You make a new type.  Then you find later you want it to be orderable.
22:14:49 <Pseudonym> In a pure OO language, you would have to go back to the type and add a superclass, or an interface.
22:15:22 <Pseudonym> In Haskell, you add a new instance of Ord which matches your type.
22:15:44 <Pseudonym> This is like adding an interface, except that it does not modify the type.
22:15:50 <jemfinch> that's pretty cool.
22:15:57 <Pseudonym> It is pretty cool.
22:16:21 <Pseudonym> So everything does not have to be an object.
22:16:44 <Pseudonym> What you pay for this functionality is that you have to pass the method dictionaries to any function which might need them.
22:16:57 <jemfinch> behind the scenes, that's what happening, right?
22:17:05 <jemfinch> I don't have to explicitly do it.
22:17:21 <Pseudonym> You need to explicitly add them in the type declaration but not in the actual code.
22:17:32 <jemfinch> yeah, that's what I thought.
22:17:53 <Pseudonym> So you might say, for example: sort :: (Ord a) => [a] -> [a]
22:18:13 <Pseudonym> That's like sort :: 'a list -> 'a list in ML
22:18:28 <jemfinch> yeah, I can read type declarations pretty well so far :)
22:18:31 <Pseudonym> Good. :-)
22:18:46 <Pseudonym> Well, the (Ord a) is actually an implicit argument to the sort function.
22:18:49 <jemfinch> so then it would just use the < and >= operators on the elements of the list?
22:18:53 <Pseudonym> Right.
22:19:17 <jemfinch> what if you used those operators on the elements but didn't declare the type of a to be Ord?
22:19:31 <Pseudonym> That would be a type error.
22:19:40 <Pseudonym> Your compiler would reject your program.
22:19:41 <jemfinch> ok, so typeclasses aren't inferred?
22:19:52 * jemfinch isn't really a huge fan of type inference in the first place.
22:20:03 <jemfinch> I'd much rather have operator overloading than type inference.
22:20:26 <Pseudonym> If you don't give your function a type signature, it's inferred.  If you give one, you have to put the type constraints in.
22:20:33 <jemfinch> so why are strings implemented as lists of chars, rather than, say, vectors of chars?
22:20:38 <Pseudonym> Yes,.
22:20:58 <Pseudonym> Mostly historical.  Miranda did it that way.
22:21:11 <jemfinch> it seems a bit...inefficient.
22:21:16 <Pseudonym> Well, it is and it isn't.
22:21:46 <Pseudonym> It interacts well with lazy evaluation.
22:21:57 <Pseudonym> You can read in a whole file from disk into a single string.
22:22:09 <Pseudonym> Even if it's a big file, you'll only read in as much as you use.
22:22:15 <jemfinch> ah, that's true.
22:22:19 * jemfinch hasn't worked with a lazy language before.
22:22:22 * Pseudonym nods
22:22:35 <Pseudonym> Personally, I think it makes sense to separate strings from streams, but that's just me.
22:22:45 <jemfinch> what do you mean by that?
22:22:51 <Pseudonym> I'd prefer to have an opaque String type with operations to turn it into lists and back again.
22:23:14 <jemfinch> yeah, I think that'd be nice, because then you'd have the option of implementing strings as vectors of chars and whatnot.
22:23:28 <Pseudonym> By "stream" I mean something like a Unix pipe.
22:23:38 <Pseudonym> Which is a good way to think of a lazy string.
22:23:54 <Pseudonym> Right.  The one catch is that Haskell doesn't have destructive update.
22:24:05 <Pseudonym> So changing a single character in a string requires copying the whole thing.
22:24:18 <Pseudonym> However, this is not necessarily a concern.  Java has that semantics too.
22:24:35 <Pseudonym> People live with read-only strings all over the place.
22:25:06 <jemfinch> in O'Caml, almost all functions are written so that all their arguments can be curried.  In SML, many functions are written with tupled arguments when it doesn't really make sense to curry the arguments.  Where does Haskell lie on that spectrum?
22:25:09 <Pseudonym> However, you have to understand that Haskell was basically originally designed because Miranda (its direct ancestor) was proprietary.
22:25:12 * jemfinch prefers immutable strings to mutable strings.
22:25:32 <Pseudonym> As a result, it carries a lot of historical baggage from Miranda.
22:25:50 <Pseudonym> OK.  In Haskell, you are encouraged to curry.
22:26:44 <Pseudonym> In fact, STG-based implementations (GHC and Hugs, dunno what NHC uses) remove the currying at compile time, so you get the efficiency of tuples.
22:27:03 <jemfinch> yeah, I figured as much.
22:27:10 <Pseudonym> It wasn't always the case.
22:27:33 * jemfinch likes that operators in Haskell can define their own precedence.
22:27:38 <Pseudonym> Yes, me too.
22:28:19 <jemfinch> hmm.
22:28:50 <jemfinch> "Expressions that result in some kind of a run-time error, such as 1/0, also have this value [bottom].  Such an error is not recoverable: programs will not continue past these errors."
22:29:05 <jemfinch> now, when I use ghci here and type "1/0" I get "Infinity"
22:30:12 <Pseudonym> Oh, there's lot of subtle bugs like that.
22:30:20 <Pseudonym> You should try 1 `div` 0 instead.
22:30:44 <Pseudonym> Nobody really implements the full Haskell 98 spec in very small corner cases like this one.
22:30:54 <Pseudonym> "Subtle bugs" probably isn't the right term.
22:30:58 <jemfinch> ghc.exe has encountered a problem and needs to close.  We are sorry for the inconvenience.
22:30:59 <jemfinch> :)
22:31:39 <jemfinch> so there's no way to recover from a divide-by-zero error?
22:31:50 <Pseudonym> Well it works for me under Unix.
22:32:02 <Pseudonym> What version are you running?
22:32:14 <jemfinch> 5.04, on Windows XP.
22:32:38 <Pseudonym> I'd submit that as a bug.
22:32:54 <jemfinch> I allowed it to do its error reporting and stuff.
22:33:50 <jemfinch> oooh, spiffy.
22:34:23 <jemfinch> so Haskell doesn't require the topological sorting that ML requires because "assignments" (definitions) aren't evaluated until they're used, is that it?
22:34:56 <jemfinch> is there a "unit" type in Haskell?
22:35:07 <Pseudonym> Yes, it's called ()
22:35:30 <Pseudonym> Well, sort of.  It doesn't require topologically sorting your functions because it compiles a module at a time.
22:35:39 <jemfinch> when I see a definition "ones = 1 : ones" that's just a definition of an infinite list, not a function, right?
22:35:43 <Pseudonym> Yes.
22:36:06 <Pseudonym> Though because of lambdas, there's a blurry distinction between a function and other kinds of definition.
22:36:14 <Pseudonym> A function is a definition which has a function type.
22:36:25 <jemfinch> in ML, when I want to delay the evaluation of code until I'm ready for it, I generally stick it into a function (maybe anonymous, maybe not) that takes () as an argument.
22:36:31 <jemfinch> is that kind of thing necessary in Haskell?
22:36:51 <Pseudonym> Nope.
22:37:00 <jemfinch> hmm.
22:37:03 <Pseudonym> You just do it and Haskell will wait until you need ot before it computes it.
22:37:34 <jemfinch> that's interesting.
22:37:42 <Pseudonym> Lazy evalution is really, really trippy.
22:37:52 <jemfinch> yeah, I'm taking a bit to get my head around it :)
22:38:10 <jemfinch> it seems that infinite lists fill the purpose of some functions, too.
22:38:18 <Pseudonym> Yes.  Like iterators.
22:39:13 <jemfinch> ok, whenever I try a definition in ghci, I'm getting a "parse error on input `=' "
22:39:21 <jemfinch> should I be using tabs instead of spaces, or what?
22:39:31 <Pseudonym> No, you should put it in a file and load that.
22:39:43 <jemfinch> can I not define functions in the interpreter?
22:39:43 <Pseudonym> You can't enter definitions in immediate mode.
22:39:46 <Pseudonym> No.
22:40:01 <jemfinch> oh, that's...interesting.  I can do that with Hugs, though, right?
22:40:11 <jemfinch> (and why does it require a file?)
22:40:32 <Pseudonym> You can't do it in Hugs either, but in Hugs you can edit the file from within Hugs.
22:40:58 <Pseudonym> Well, to have a definition you need to put it in a module, kind of thing.
22:41:19 <jemfinch> this is weird...it makes it kind of hard to experiment.
22:41:39 <Pseudonym> There is a work-around.  You could use a local definition.
22:41:49 <jemfinch> oh, how do I do that?
22:41:56 <Pseudonym> let factorial n = product [1..n] in factorial 5
22:41:56 <jemfinch> (and in what interpreter, ghci or hugs? :))
22:42:01 <Pseudonym> In either.
22:42:56 <jemfinch> now that's pretty pretty.
22:43:09 <jemfinch> hmm...lists print interestingly -- there's no space after the comma.
22:43:23 <Pseudonym> True.
22:43:42 <Pseudonym> BTW, if you need more than one rule you can do it using { } and ; like this:
22:43:57 <Pseudonym> let { factorial 0 = 1 ; factorial n = n * factorial (n-1) } in factorial 5
22:44:12 <jemfinch> ah, cool.
22:44:23 <jemfinch> I still think it's strange that you can't make new definitions at the toplevel.
22:44:41 <Pseudonym> Haskell isn't really designed to have a "toplevel".
22:45:10 <Pseudonym> It's designed to be compiled.
22:45:19 <jemfinch> so are SML and O'Caml :)
22:45:22 <Pseudonym> :-)
22:45:24 <Pseudonym> True.
22:45:39 <jemfinch> it's not the end of the world, it'll just slow down my experimentation a bit.
22:45:48 <jemfinch> how do I load a file with ghci?
22:46:03 <Pseudonym> If you're already in ghci, use:
22:46:05 <Pseudonym> :load file.hs
22:46:09 <Pseudonym> If you're not:
22:46:12 <Pseudonym> ghci file.hs
22:46:36 <jemfinch> ok, that shouldn't be so bad...and I'll get to edit it in my editor of choice :)
22:46:49 <Pseudonym> Hugs is a bit quicker if you're experimenting because you can type :e and edit the file from within hugs.
22:47:06 <Pseudonym> It uses your EDITOR variable under Unix.
22:47:11 <Pseudonym> Can't remember what it does in Win32.
22:47:23 <jemfinch> if I :load a file that defines definitions that are already defined, will the new definitions shadow the old ones?
22:47:32 <Pseudonym> Erm...
22:47:49 <Pseudonym> If you :load the same file, I think it will overwrite the last :load.
22:48:00 <Pseudonym> If that's what you menat.
22:48:07 <jemfinch> yeah, that's what I meant :)
22:48:10 <Pseudonym> Cool. :-)
22:48:14 <Pseudonym> Try it and find out.
22:48:28 <sethk> I'm back, and it definitely will replace the symbols.
22:48:36 <Pseudonym> There you go.
22:49:01 <jemfinch> sethk: so give me your treatise on "Everything's an object" :)
22:49:27 <Pseudonym> You didn't like mine?
22:49:29 * Pseudonym sulks
22:49:43 <jemfinch> Pseudonym: I did, but I wanted to hear his opinion too :)
22:49:47 <Pseudonym> :-)
22:49:58 <sethk> It will be interesting to see if I have the same reasons.
22:50:35 <sethk> It isn't really objects themselves, but their inherently one dimensional decomposition that causes the problems that can't be fixed.
22:51:42 <sethk> You need either multiple inheritence (as in C++) which creates uncontrollable relationships, or some kludge like Java interfaces which doesn't provide all the necessary functionality.
22:52:55 <sethk> Real life problems are not accurately modeled by a one dimensional hierarchy.  This creates what the literature is calling "cross connects" or horizontal dependencies among classes, after which you very quickly lose most of the encapsulation.
22:53:40 <sethk> There is a ton of literature about this problem, and a lot of proposed fixes, but all of them are seriously flawed.
22:53:54 <sethk> Climb down off soapbox...
22:54:37 <jemfinch> sethk: so how does Haskell solve that problem?
22:55:06 <jemfinch> (and multiple inheritance "as in C++" isn't the only option for multiple inheritance :))
22:55:24 <sethk> It doesn't exactly solve it because it doesn't have it to begin with.  I believe that what Simon P.J. is working on is a possibly viable solution.
22:55:36 <jemfinch> what's Simon P.J. working on?
22:56:03 <sethk> True, about multiple inheritence, but it is flawed from a theoretical perspective, and so all the implementations are flawed, although possibly in different ways.
22:56:42 <Pseudonym> OK, they weren't my reasons.
22:56:47 <jemfinch> uh oh.
22:56:49 <Pseudonym> I just said why Haskell typeclasses were better.
22:56:50 <sethk> He has an enhancement to Haskell that brings types closer to fully first class objects.  But I'm not an expert, so take a look at his on line stuff.
22:56:56 * jemfinch just printed an infinite list.
22:57:20 <Pseudonym> Quick, type control-C before you run out of bits!
22:57:21 <sethk> Oh, I agree about that.
22:57:23 <jemfinch> :)
22:57:35 <jemfinch> fib = 1 : 1 : [a+b | (a, b) <- zip fib (tail fib)]
22:57:39 <sethk> But Haskell type classes have a different purpose.
22:57:51 <sethk> Which brings up the other OO flaw the literature talks about...
22:57:53 <jemfinch> if you're curious, I can show y'all what that looks like in Python with its new generators.
22:58:35 <Pseudonym> Actually, Haskell type classes do solve most of the problems that the "everything is an object" philosophy is supposed to solve.
22:58:43 <sethk> That, in C++ at least, the class systems is trying to do three things at once, and as a result does none of them well.
22:59:04 <Pseudonym> The difference is that instead of adding a new superclass/interface to your type, you add the type to the set of types which support that interface.
22:59:41 <jemfinch> Pseudonym: I think I'll like that, I'll have to try it out.
22:59:57 <sethk> Which works extremely well and does indeed cover many practical requirements.
23:00:01 <Pseudonym> Yes.,
23:00:31 <sethk> But you could argue that, if the C++ class system were not trying to do other things at the same time, it could be tweaked to handle the interface problem better.
23:00:36 <sethk> But it is trying to handle:
23:00:40 <sethk> specialization
23:00:42 <sethk> encapsulation
23:00:57 <sethk> and interface specification
23:00:59 <sethk> all at once.
23:01:17 <sethk> And, as a result does none of them well.
23:01:29 <sethk> Java removes interface, so it is better but still not good.
23:01:48 <Pseudonym> I'm a bit of an odd-man-out kind of declarative programmer because I actually like C++.
23:02:01 <Pseudonym> I don't think it's theoretically very nice, but it's pragmatic and practical.
23:02:15 <Pseudonym> I use Perl for pretty much the same reasons.
23:02:24 <Pseudonym> But that's another story.
23:02:29 <jemfinch> what happens in Haskell is you "take 100 a_list_that_will_only_be_99_elements"?
23:02:37 <Pseudonym> You get 99 elements.
23:02:47 <jemfinch> ok, just checking :)
23:02:55 <Pseudonym> Try: take 10 [1..5]
23:03:08 <sethk> Spend two hours with Python, and you'll never touch Perl again.
23:03:34 <Pseudonym> People keep telling me that.  In fact, ESR once personally abused me for it at a conference.
23:03:38 <jemfinch> Pseudonym: I translated Perl's Text::Abbrev into Python earlier tonight.
23:03:45 <Pseudonym> OK, "abuse" is a bit strong.
23:04:02 <Pseudonym> I keep meaning to learn Python.  It's one of those things I should know.
23:04:15 <jemfinch> Pseudonym: if you'd like to compare the readability of the two, I'd be happy to show you my translated version of Text::Abbrev.
23:04:17 <Pseudonym> jemfinch: How fun was it?
23:04:33 <Pseudonym> Oh, I'm sold on the fact that Python has many benefits.
23:04:34 <jemfinch> it wasn't impossible, I used to love Perl back in the day before I learned Python.
23:04:41 <sethk> I recently translated 600 lines of Java into 53 lines of Python.
23:05:00 <jemfinch> I was just surprised that, for all the lauding of Perl's brevity, the Python version was only 19 lines versus Perl's 37 lines.
23:05:02 <Pseudonym> Well that shouldn't be hard.  Probably half of those lines were function qualifiers.
23:05:25 <sethk> Plus 1/4 were other useless statements.  But you still have to type them in.
23:05:29 <Pseudonym> public static final syncronised foobar
23:05:58 <Pseudonym> I think brevity is overrated, personally.
23:06:05 <Pseudonym> Succinctness isn't the same thing as brevity.
23:06:18 <sethk> Avoid redundency, don't talk in rhyme, it's quicker, and it takes less time.
23:07:21 <sethk> I actually have a very verbose programming style...
23:07:37 <sethk> So if my Python code is 53 lines, someone else's is probably 30 lines.
23:07:39 <jemfinch> I used to have a much more verbose programming style, until I learned O'Caml.
23:07:51 <jemfinch> I'd always try to find "real" names for variables and such.
23:08:19 <jemfinch> a (probably bad) habit I picked up in O'Caml is using single-letter variable names that indicate the type of the variable, nothing more.
23:08:47 <sethk> I still use long names; at my age I won't remember what they were supposed to be.
23:09:06 <jemfinch> let rec map f l = match l with [] -> [] | hd :: tl -> f hd :: map f tl
23:09:13 <jemfinch> it looks better on separate lines.
23:09:14 <Pseudonym> You could always take up Hungarian notation.
23:09:24 <jemfinch> ew, long names *and* type qualifiers...
23:10:05 <sethk> If you remember that, you may be almost as old as I am.  Probably heard about it from your grandfathers...
23:10:07 <jemfinch> hmm...Haskell is parsed via parser combinators, right?
23:10:29 <jemfinch> sethk: if I remember what?
23:10:33 <Pseudonym> Erm... I can't remember if they use Happy or Parsec.
23:10:44 <sethk> If you remember Hungarian notation.
23:10:52 <sethk> GHC uses Happy.
23:10:59 <jemfinch> oh...I know of it, I've never used it :)
23:11:06 <jemfinch> sethk: how old are you, if you don't mind answering? :)
23:11:08 <Pseudonym> Right.  Happy is LALR(1).
23:11:18 <sethk> Coming up on 50.
23:11:21 <jemfinch> oh, I thought Happy was a parser combinator thingy.
23:11:28 <jemfinch> wow...I'm not quite there yet :)
23:11:47 <Pseudonym> We might be talking about a different kind of Hungarian notation.
23:11:58 <sethk> No, Happy doesn't generate combinators.
23:12:02 <Pseudonym> I'm pretty sure that the Microsoft naming policy is only about 10 years old.
23:12:19 <Pseudonym> Certainly when I was Windows programming in the late 80s it hadn't been settled on fully yet.
23:12:49 <sethk> Really?  I used it in OS/2 in the early 80's and thought is was exceedingly dumb.  I haven't changed that opinion.
23:13:10 <Pseudonym> OK, it's that old, then.
23:13:27 <jemfinch> so what's the computational complexity of taking from fib?
23:13:27 <sethk> iThink so
23:13:34 <Pseudonym> I think it was formalised a bit later.  Early on they were using "i" and "b", but "lpf" wasn't invented yet.
23:13:51 <jemfinch> fib = 1 : 1 : [a+b | (a, b) <- zip fib (tail fib)]
23:14:08 <Pseudonym> take n fib should be O(n)
23:14:16 <sethk> I do, still, in C++ use Type and pType for a type and its pointer.
23:14:29 <jemfinch> Pseudonym: so it should be equivalent to a memoized fib function that calculates fib recursively?
23:15:06 <Pseudonym> Sort of, except that it takes O(n) time to traverse the list to the nth element.
23:15:53 <jemfinch> but since fib is defined recursively, I assume behind-the-scenes ghc is keeping the previous elements of fib around, right?
23:15:58 <Pseudonym> Yes.
23:16:16 <Pseudonym> fib is technically what we call a "constant applicative form", or CAF for short.
23:16:27 <jemfinch> oh, that's a term I don't know.
23:16:31 <Pseudonym> Basically, it's a top-level definition which doesn't have a function type.
23:17:25 <jemfinch> f s@(x:xs)             = x:s
23:17:26 <Pseudonym> Yeah, you usually don't need to know about them unless you're implementing Haskell or getting a very weird space leak.
23:17:29 <jemfinch> I don't like that syntax...
23:17:49 <Pseudonym> So don't use it, duh.
23:17:53 <Pseudonym> :-)
23:17:54 <jemfinch> :)
23:18:05 <jemfinch> so does tail-recursiveness matter in Haskell?
23:18:21 <Pseudonym> Not as much as you might think.
23:18:31 <jemfinch> why's that?
23:18:35 <Pseudonym> It's optimised like in real functional languages.
23:18:46 <Pseudonym> However, if you use non-tail recursion, remember you have lazy evaluation.
23:19:04 <Pseudonym> So if, for example, you have:
23:19:15 <Pseudonym> naturals n = n : naturals (n+1)
23:19:25 <Pseudonym> It's just as well you don't optimise the non-tail call.
23:19:31 <jemfinch> why?
23:19:40 <Pseudonym> Because otherwise you'd be in an infinite loop.
23:20:10 <Pseudonym> The recursive call to "naturals" is not performed until you actually need the tail of the list.
23:20:20 <sethk> Quickie:  do I need a -package for ghci to find FiniteMap?
23:20:47 <Pseudonym> I don't think you should nowadays.  Not if you import Data.FiniteMap
23:21:03 <sethk> OK, I left out the "Data."
23:21:06 <Pseudonym> So jemfinch, yes, it makes a difference.
23:21:28 <Pseudonym> But, for example, "last call modulo constructor" recursion is _not_ optimised.
23:22:29 <Pseudonym> If you have a function like:
23:22:33 <Pseudonym> append [] ys = ys
23:22:38 <Pseudonym> append (x:xs) ys = x : append xs ys
23:22:52 <Pseudonym> Some languages will optimise the recursive call to append here.
23:23:05 <Pseudonym> It's not really tail recursion, but it's tail recursion modulo a constructor.
23:23:15 <Pseudonym> Haskell can't do that.
23:24:05 <jemfinch> I'm having a bit of trouble understanding that.
23:24:26 <Pseudonym> Which part?
23:24:36 <jemfinch> "tail recursion modulo a constructor"
23:25:02 <Pseudonym> OK.  (:) is an operator which constructs a list.
23:25:08 <Pseudonym> A constructor.
23:25:18 <jemfinch> yeah, I got that :)
23:25:26 <Pseudonym> Because Haskell is functional (like ML), it's actually a function in disguise.
23:25:28 * jemfinch is reading through A Gentle Introduction while we're chatting.
23:25:36 <Pseudonym> append (x:xs) s = (:) x (append xs ys)
23:25:47 <Pseudonym> There's a recursive call to append there.
23:26:10 <jemfinch> yup, and it's not tail recursive.
23:26:14 <Pseudonym> Right.
23:26:30 <Pseudonym> However, some languages, strict ones, can make it tail recursive.
23:26:41 <jemfinch> really?
23:26:52 <jemfinch> I didn't know that -- I don't think any ML does...
23:26:56 <Pseudonym> Make a version of append where you pass in a "pointer" to the place to put the result.
23:27:18 <Pseudonym> Then what you do is construct the cell, then tail-call append passing in the "tail" part of the cell.
23:28:09 <jemfinch> oh, ok.
23:28:21 <Pseudonym> If you think about it, that's often how you implement "append" on singly-linked lists in an imperative language.
23:28:28 <Pseudonym> Except you use a loop rather than tail recursion.
23:29:01 <Pseudonym> Well you can't do that in Haskell because the first argument to append may be an infinite list.
23:30:17 <Pseudonym> Yeah, I'm not sure if any MLs do it.  Some of them might.
23:30:31 <Pseudonym> Prolog can do it, but Prolog has logic variables.
23:33:55 <jemfinch> do I specifically have to declare a type as being a member of a typeclass?
23:34:17 <Pseudonym> Unless it's a built-in instance, yes.
23:34:25 <jemfinch> built-in instance?
23:34:26 <Pseudonym> Some typeclasses can be automatically derived, however.
23:34:36 <Pseudonym> Yes.  Like Int is by default a member of Eq.
23:34:59 <Pseudonym> Typeclasses that you can automatically derive include Eq, Ord and Show.
23:35:17 <Pseudonym> You say: data Foo = A Int | B Char deriving (Eq,Show)
23:35:51 <jemfinch> oh, cool, typeclasses can define "default methods"
23:36:07 <Pseudonym> Only some of the built-in typeclasses.
23:36:11 <jemfinch> why is the keyword there "deriving"?
23:36:19 <jemfinch> can I define default methods in my own typeclasses?
23:36:35 <Pseudonym> Yes, but only in terms of other methods and functions.
23:36:43 <jemfinch> yeah, that makes sense.
23:36:57 * jemfinch is definitely more interested in Haskell than he was when he started learning about it.
23:37:19 <jemfinch> does Haskell have mutable (destructive update) arrays?
23:37:26 <Pseudonym> Yes, but they're tricky to use.
23:37:33 <Pseudonym> They hang off monads.
23:37:50 <jemfinch> so, conceivably, Haskell could have a hashtable.
23:39:58 <Pseudonym> In principle, sure.
23:39:58 <Pseudonym> But then, you could implement hash tables in terms of some other data structure.  You could store your primary table in a trie, for example.
23:40:02 <Pseudonym> Don't laugh on that one, BTW.  It's often cheaper to compare hash codes than full data structures.
23:40:23 <jemfinch> have you heard of Judy?
23:40:27 <Pseudonym> So a binary tree of hash codes isn't so dumb.
23:40:33 <Pseudonym> No.
23:40:40 <jemfinch> let me get you a link...
23:40:50 <jemfinch> basically, the "hash table" in its current form is obsolete :)
23:41:10 <Pseudonym> Sounds intriguing.
23:41:40 * jemfinch is still finding the link, hold on...
23:42:00 <jemfinch> ah... http://www.sourcejudy.com/
23:43:02 <jemfinch> basically, it's faster and more memory efficient than nearly every other (if not simple "every other") implementation of sets/maps.
23:43:49 <Pseudonym> I'll file it away for later.  Having network problems at the moment.
23:44:05 <Pseudonym> Though presumably there exists a route to it, since I can talk to you right now.
23:44:12 <jemfinch> I think it's implemented via hash-mapped array tries, or something similarly complex :)
23:44:52 * jemfinch has no real formal CS education, so some things are probably out of his reach at his current level of expertise.
23:52:57 * Pseudonym has always thought that tries were superior to hash tables
23:53:02 <sethk> Pseudonym, can I hit you with another >>= question?
23:53:07 <Pseudonym> Absolutely.
23:53:26 <sethk> OK.  The first line works, the second doesn't.  I'm not sure why.
23:53:42 <sethk> getargs >>= \args -> putStrLn ((!!) args 0)
23:54:04 <sethk> getargs >>= \args -> ((!!) args 0) >>= \name -> putStrLn name
23:54:34 <Pseudonym> The reason is that ((!!) args 0) isn't a monad.
23:54:48 <Pseudonym> getargs :: IO [String]
23:54:52 <Pseudonym> (!!) args 0 :: String
23:55:13 <Pseudonym> >>= expects a monad (like IO) as its first argument.
23:55:15 <sethk> Does that mean I can't do monad >>= non-monad >>= monad
23:55:22 <Pseudonym> No, however you can do this:
23:55:36 <Pseudonym> getargs >>= \args -> return ((!!) args 0) >>= \name -> putStrLn name
23:55:47 <Pseudonym> return :: (Monad m) => a -> m a
23:55:53 <Pseudonym> In this case, it's a -> IO a
23:56:16 <sethk> Ah, that's what return is good for.  (In addition to the case in the books.)
23:57:14 <sethk> Bingo.  I'm finally getting this, I hope.
23:57:25 <sethk> I'm not usually this slow.
