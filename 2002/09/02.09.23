00:01:16 <shapr> y0 dnm, ltns
00:01:23 <sethk> No, the interface file C2HSDeprecated.hi, in /usr/local/lib/c2hs-0.10.15/ghc5/import
00:01:23 <shapr> sethk: I'd prefer to wait for the debian package
00:02:08 <Chilli> ok, wehn you say you rebuild c2hs, which version did you rebuild
00:02:10 <Chilli> ?
00:02:12 <sethk> Chilli:  It was compiling GTypes.hs when it complained.
00:02:18 <sethk> Chilli:  0.10.15
00:02:46 <Chilli> are you sure, you rebuild with GHC 5.04.1 and not GHC 5.04?
00:02:53 <shapr> dnm: hey, you writing Haskell some nowadays?
00:03:49 <Chilli> sethk: what does "/usr/local/bin/c2hs-config --version" say?
00:03:57 <dnm> shapr: Yeah, same story as before. Write some of this, some of that. I'm all over the map. You know me.
00:03:59 <sethk> Chilli:  What I'm sure of is that I installed the 5.04.1 RPMs.  I'll check c2hs-config...
00:04:53 <shapr> dnm: yah, I know... what are you writing in Haskell?
00:04:59 <sethk> Chilli:  I think you are correct; I'm seeing 5.04.  But, then, since I just compiled both programs, wouldn't they both be 5.04?
00:05:29 <Chilli> depends, if you ran configure for c2hs before you had GHC 5.04.1 installed and you didn't dfelete the configure cache
00:05:46 <Chilli> and configured gtk+hs *after* you installed 5.04.1, they would use differen evrsions
00:05:55 <Chilli> different versions, that is
00:06:08 <sethk> Chilli:  No, I wiped out the cache file for both.
00:06:09 <Chilli> to recompile c2hs with a new version
00:06:47 <Chilli> you need to "make cleanall", "rm config.cache", and rerun ./configure
00:07:54 <Chilli> What does  "/usr/local/bin/c2hs-config --version" say?
00:07:57 <sethk> Chilli:  I just checked, my config.cache is about 1/2 hour old.  I did "make spotless" in both the c2hs and gtk+hs directories.
00:08:10 <Chilli> I think 0.10.15 already reports the version of GHC it is compiled for
00:08:46 <sethk> Chilli:  It says 5.04.  I just started a source build of 5.04.1, since RPM doesn't seem to be doing the right thing.  But I still don't understand why both aren't built with WHICHEVER compiler is lurking around.
00:09:29 <sethk> Chilli:  I have a ghc 5.04 in /usr/local/bin and a 5.04.1 in /usr/bin.
00:09:49 <Chilli> wwhich is earlier in your PATH?
00:10:02 <dnm> shapr: Some capabilities hacks relating to monads
00:10:11 <shapr> that sounds interesting
00:10:12 <Chilli> /usr/local/bin, I guess
00:10:34 <dnm> shapr: Some other security formalism things based off of CSP, and some things relaitng to Casper
00:10:51 <sethk> Chilli:  Yes, but perhaps one library is using a full path name rather than relying on the search path.
00:10:54 <Chilli> both use autoconf's standard macro
00:11:30 <Chilli> you can always specify an explicit --with-hc=<path> to ./configure to force a particular version of GHC
00:11:35 <shapr> dnm: I've only read a basic overview of capability security. I vaguely recall some discussion here that monads and capabilities would go well together.
00:12:41 <sethk> Chilli:  Then I'm still puzzled.  Well, I'll wipe out the 5.04 binaries and see what happens...
00:18:42 <Pseudonym> Home time for me.  Night all.
00:18:55 <sethk> Pseudonym:  good night
00:19:28 <sethk> Chilli:  After rebuilding, c2hs-config --version shows 5.04.1.  So, I'm not sure how, but it was indeed previously built with 5.04.
00:20:22 <sethk> Chilli:  However...now I'm getting "Fail: Preulde.read: no parse" on the gtk+hs build.
00:21:04 <Chilli> true, I forgot about that
00:21:12 <Chilli> that's a bug in GHC 5.04.1
00:21:29 <sethk> Chilli:  Workaround?
00:23:08 <Chilli> only in 0.10.17
00:23:16 <Chilli> (version of c2hs that is)
00:23:49 <Chilli> so, you will have to update to this version of c2hs of you want to use c2hs with GHC 5.04.1
00:23:51 <sethk> Chilli:  Haskell.org is down.  Do you know the URL for c2hs?
00:24:02 <Chilli> sure
00:24:14 <Chilli> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
00:24:38 * shapr grins
00:25:38 <sethk> Chilli:  Thanks...
00:25:45 * shapr bounces happily
00:26:28 <Chilli> :-)
00:26:58 <shapr> hi Marvin--
00:29:16 <sethk> Chilli:  Aha!  you are at unsw
00:29:38 <Chilli> true :-)
00:30:01 <Marvin--> morning
00:38:17 <andersca> hey Marvin--
00:38:35 <andersca> Marvin--: how do you describe type checking for functions taking more than one argument?
00:39:39 <sethk> Andersca:  You don't, as they don't exist.
00:39:53 <shapr> sethk: picky details :-)
00:40:22 <andersca> sethk: this is for the programming language course I'm taking, Marvin-- is supervising it
00:40:55 <sethk> andersca:  So you don't mean for Haskell, you mean in general?
00:41:02 <andersca> sethk: yeah
00:42:16 <sethk> andersca:  logically, it is the same situation as a function that takes a tuple argument in Haskell.
00:42:51 <andersca> sethk: nod
00:44:27 <Marvin--> andersca: what he said ;)
00:45:46 <Marvin--> I see no problem with having a '...' description... like \Gamma, x1:t1, x2:t2, ..., xn:tn |- stuff
00:46:57 <andersca> good idea
00:47:07 * andersca ponders adding a lambda expression
00:47:46 <Marvin--> If you're going to have more advanced things in your language, please for the love of god make expressions side effect free ;)
00:47:58 * shapr cheers for referential transparency
00:48:02 <andersca> Marvin--: they are
00:48:07 <andersca> Marvin--: functions aren't though
00:48:23 <andersca> Marvin--: but since we're using '=' for both assignment and comparison we can't have expressions with side-effects
00:49:03 <Marvin--> iiih, scary
00:49:03 <Marvin--> you CAN use multi-character operators you know...
00:50:13 <andersca> nah, just using = looks nicer
00:50:13 <andersca> :)
00:50:19 <andersca> Marvin--: where in the lexer should I put multi-char operators? as keywords?
00:50:34 * andersca didn't implement >= and <= because of that
00:50:46 <Marvin--> the characters you put in the 'symbols' variable will be parsed specially
00:51:20 <Marvin--> | isSpec c  = Sym [c] : lexer cs
00:51:21 <Marvin--> but
00:51:26 <Marvin--> | isSym c   = let (fs,rs) = span isSym cs
00:51:26 <Marvin-->                            in Sym (c:fs) : lexer rs
00:54:54 --- mode: card.freenode.net set +o ChanServ
00:54:57 <sethk> Marvin:  What's wrong with that?  Several languages do it.
00:54:58 <sethk> Chilli:  Will do.
00:55:00 <andersca> Marvin--: yay, it worked
00:55:25 <Marvin--> sethk: I don't mind that solution, as long as the grammar they hand in matches the parser :)
00:55:33 <Marvin--> sethk: (or rather, the other way around)
00:55:44 <andersca> Marvin--: so characters like , and ; should be in the specials list
00:56:01 <Marvin--> If their grammar says <foo> '<=' <bar> it should be parsed without spaces, if they say <foo> '<' '=' <bar> spaces are allowed
00:59:43 --- mode: card.freenode.net set +o ChanServ
01:00:09 <Marvin--> just as long as you don't try to write a parser for C#, that language has got a big moth***ing grammar
01:00:39 <andersca> yeah :)
01:01:39 <Marvin--> the modern day PL/I :(
01:01:47 <sethk> GNU might have a parser you could steal and adapt for Happy.  Does GNU support C#?
01:02:11 <sethk> Actually, PL/I was quite an interesting language at the time it came out.
01:02:32 <sethk> Not that I use it anymore...
01:02:36 <Marvin--> Every project to create "an ultimate programming language" is doomed to fail
01:02:44 <sethk> Or even admit I know how...
01:02:55 <Marvin--> I've never used it, I just have a theoretical knowledge of it
01:03:22 <Marvin--> oh, and don't encourage stealing grammar and parser in the presence of the assignment supervisor, will you? ;)
01:03:49 <sethk> Marvin:  I am encouraging code reuse, a very noble undertaking...
01:04:15 <Marvin--> sethk: yes, but not on programming assignments that I correct
01:04:37 <sethk> Marvin:  I'm safe - my last programming course was 25 years ago.
01:04:42 <Marvin--> sethk: :)
01:04:57 <Marvin--> sethk: well, seeing as andersca is one of my minions.. ;)
01:05:44 <sethk> Marvin:  Yes, but I don't think he's likely to turn in 3000 lines of really UGLY code... :-)
01:06:02 <sethk> And Yacc code is UGLY code
01:06:46 <Marvin--> oh, they are allowed to use parser generators, but that means they have to hand in the .y file(s)
01:07:16 <Marvin--> and neither yacc nor happy supports ebnf, do they?
01:07:24 <Marvin--> much easier to use parser combinators in haskell then :)
01:09:51 <sethk> Marvin:  I've been hacking up Happy a bit to support * and +, but it isn't completely working yet.
01:10:58 <Marvin--> cool
01:11:08 <Marvin--> hmm, I wonder which is faster of Parsec and Parsek
01:11:37 <shapr> iirc, Parsek doesn't have the try backtracker?
01:12:12 <Marvin--> hmm, what does it do? I've never used Parsec
01:12:53 <shapr> I vaguely recally that try can cause a big chunk of processing time to be wasted
01:13:06 <sethk> Marvin:  Parsec handles the backtracking very gracefully.  Good default behavior that you can override.  I don't know about Parsek.
01:13:07 <Marvin--> heh... From Parsek.hs: ''The aim was to get a library that was equally fast, without having to use the cumbersome "try" combinator. (That combinator is still supported, but is defined to be the identity function.)''
01:14:38 <Marvin--> Parsek is implemented with a monad wrapped around a deep embedding, to get rid of left-recursive binding
01:14:41 <sethk> Marvin - There is something to be said for explicit try modifiers.  If nothing else it makes the grammar more evident.
01:15:07 <Marvin--> sethk: well, as I said, I've never used Parsec so I wouldn't know how it's supposed to be used
01:17:57 <Marvin--> hmm, looking at an example, I see stat = choice [ ..., ifStat, whileStat, sequenceStat, try assignStat ]
01:18:18 <Marvin--> but why only try on the assignment and not on the rest? I don't see any principal differences between the functions
01:34:53 * shapr bounces
02:06:18 <Heffalump> morning
02:06:26 <Heffalump> shapr: do you know about Simonyi's new company, btw?
02:07:01 <shapr> no, tell me more!
02:07:05 <shapr> do you?
02:07:12 <Heffalump> it was in the news and stuff
02:07:21 * shapr googles
02:07:21 <Heffalump> http://www.intentionalsoftware.com/
02:09:38 <shapr> I don't have flash installed
02:09:39 <shapr> ptui
02:09:44 <Heffalump> hangon
02:09:52 <Heffalump> I'll give you the URL that goes straight to the front page
02:09:58 <shapr> yay!
02:10:02 <Heffalump> if my web browser would stop crashing, anyway
02:10:11 <shapr> :)
02:10:16 <Heffalump> http://www.intentionalsoftware.com/corporate.html
02:12:10 <Marvin--> iih, they use the word "synthesis"
02:12:26 <Heffalump> iih?
02:12:35 <Heffalump> it's a bit full of marketing-speak
02:12:39 <shapr> yah, a bit
02:12:48 <Heffalump> but the ideas behind IP were good, and AOP is cool in some ways
02:12:48 <Marvin--> it's buzzword compliant
02:12:55 <shapr> I'm not so fond of AOP.
02:13:00 <Marvin--> I'm too far behind on these new things
02:13:13 <Marvin--> is aspect-orientation something like component-orientation?
02:13:18 <shapr> nah
02:13:48 <shapr> the nutshell view is that it lets you hook all of your functions
02:14:02 <shapr> pre, post, around, and something else I forgot
02:14:03 <Heffalump> without having to change your original source
02:14:11 <Marvin--> oh
02:14:27 <Heffalump> pre,post, around and call, but call is a bit different from the others.
02:15:04 <Marvin--> ugh, I'd better get going to the university
02:15:04 <shapr> I know someone who's doing bug fixes on VC++ who very much wants to do IP, I should email him and ask him if he knows about the new company.
02:15:10 <shapr> Heffalump: what's call?
02:15:23 <shapr> er, what makes call different?
02:16:31 * shapr considers looking on google for call
02:16:41 <shapr> that would be too easy.
02:17:18 <Heffalump> it wouldn't really work, either
02:17:32 <Heffalump> oh, call isn't advice, it's part of the pointcut language, sorry
02:18:00 <Heffalump> anyway, it's a way of saying that somewhere on the call stack is a call to function f
03:04:14 <leander-> morning
03:04:50 <leander-> why does   let i = reverse("Hello World")   work, but
03:04:57 <leander->         let i = "Hello World"
03:04:57 <leander->         let i = reverse(i)
03:05:03 <leander-> doesn't ?
03:11:51 <clausen> you can't define "i" twice
03:13:12 <clausen> haskell doesn't have variables
03:13:34 <leander-> i just found it out (using a 2nd variable), so i cannot overwrite the content of a var?
03:13:41 <clausen> correct
03:13:48 <clausen> like I said, haskell doesn't have variables
03:13:55 <clausen> (hint: variable == vary-able)
03:14:18 <leander-> hm, only constants... 
03:14:42 <leander-> sounds like a big memory waste but probably i didn't understand it all ...
03:14:43 <clausen> and functions :)
03:14:43 <leander-> thx
03:14:53 <clausen> yeah, it does cost a bit more memory
03:14:56 <clausen> but there are big advantages
03:16:09 * leander- still has to rtfm
03:20:31 <leander-> what if i had a very big amount of mem assigned to i (e.g. a large picture), could i delete the origrinal 'var' after producing a edited version of it?
03:21:30 <clausen> haskell programmers use appropriate data structures
03:21:35 <clausen> that reuse unchanged portons
03:21:36 <clausen> portions
03:21:54 <clausen> but, if you say, wanted to change everything
03:22:03 <clausen> then you'd have to reallocate the entire thing
03:22:10 <leander-> let's say i inverted the image...
03:22:14 <clausen> right
03:22:20 <clausen> then it's expensive
03:22:21 <Heffalump> the garbage collector would detect that you didn't need the old one any more (if you really didn't) and would kill it
03:22:37 <clausen> Heffalump: AFAIK, it can't edit in-place, though
03:22:43 <Heffalump> no, it can't
03:22:51 <Heffalump> unless you use the ST or IO monads
03:22:52 <Igloo> The above reassignment to i ought to be legal
03:23:03 <Heffalump> which is what people do when they absolutely need to get in-place updates
03:23:14 <Heffalump> and in fact I think GHC might sometimes infer that it can do in-place updates, TICBW
03:23:23 * Igloo vanishes
03:23:32 <clausen> Igloo: please explain
03:23:48 <Heffalump> because the new binding will "shadow" the old binding
03:23:51 <Heffalump> it's not the same i in each case
03:25:14 <clausen> hmmm
03:25:24 <clausen> so it should be a recursive definition?
03:25:29 <clausen> i = f i
03:25:30 <clausen> ?
03:25:43 <Heffalump> wdym "it should be"?
03:26:09 <clausen> "should" is a strange word
03:26:17 <clausen> it can mean "if you try it"
03:26:19 <clausen> sort of
03:26:34 <clausen> "I should think not" for example
03:26:35 <clausen> hehe
03:26:47 <Heffalump> i = f i is recursive, yes
03:29:03 <leander-> btw ghc does compile the re-assignment (the string example above) w/o errors, but the program exits with an error message
03:29:28 <Heffalump> it's not a re-assignment, that's the point
03:29:30 <Heffalump> it's a different i
03:29:53 <Heffalump> let i = reverse i is recursive, though
03:29:56 <Heffalump> so it'll never terminate
03:30:05 <Heffalump> because the i on the RHS is the same as the i on the LHS
03:30:12 <Heffalump> which is probably why the program exits with an error
03:30:16 <leander-> ic! 
03:30:41 <leander-> thats more mathematical than C :)
03:30:48 <Heffalump> (GHC compiled programs can sometimes spot when they're in infinite loops)
03:32:58 <leander-> so i don't understand why there isn't a function to explicitly delete a var
03:33:47 <Heffalump> because it wouldn't be safe
03:34:01 <Heffalump> you could cause a program crash that way, if the variable really shouldn't have been deleted
03:34:26 <Heffalump> and keep remembering that they're not really variables :-)
03:35:02 <norpan> if you think of haskell variables as names of graphs... :)
03:35:16 <Heffalump> hmmm :-)
03:35:20 <Heffalump> nodes of graphs.
03:35:38 <norpan> well, yes, names of nodes of graphs :)
03:35:44 <Heffalump> yeah.
03:35:45 <leander-> yeah, but i don't know a better word than variable
03:35:58 <Heffalump> value, perhaps
03:36:00 <norpan> and if a graph has no name, it can safely be deleted
03:36:03 <leander-> ok, value
03:36:20 <Heffalump> if a node has no name and isn't pointed to by anything else
03:36:24 <norpan> yes
03:36:28 * Heffalump disappears
03:36:36 <clausen> leander- probably knows what "garbage collection" is ;)
03:36:50 <leander-> if the build in trash collector works perfect ...
03:36:51 <leander-> :)
03:36:54 <norpan> yes, and the compiler can sometimes derive this statically
03:37:13 <leander-> nice, so i can count on it... :)
03:37:29 <norpan> unfortunately you can't count on very much, so it's easy to get memory leaks
03:37:51 <leander-> mhm
04:49:58 <leander-> may i paste a few lines? i don't whats wrong with my (first) function, getting parser errors
04:50:03 <leander-> +know
04:51:03 <leander-> leorun x = 
04:51:03 <leander->     do
04:51:03 <leander->         if x < 10
04:51:03 <leander->             then do
04:51:03 <leander->                 leorun (x+1)
04:51:04 <leander->         putStrLn (x++"\n")
04:51:25 <leander-> i think this should count from 1 to 9, recursively
04:53:05 <cleverdra> Or 9 to 1.  One of those.
04:53:12 <leander-> yes
04:54:28 <cleverdra> I think the recursive call should be aligned with the second 'do', and the 'if' and 'putStrLn' should be aligned with the first 'do'.
04:54:33 <clausen> if requires an else
04:54:38 <clausen> you need a null statement
04:55:08 <clausen> there is a special form for what you want
04:55:10 * clausen looks for it
04:56:04 <clausen> "when"
04:56:17 <clausen> when (x < 10) (leorun (x+1))
04:57:34 <leander-> 'when' is not in scope :)
04:58:04 <Heffalump> import Monad
04:58:13 <clausen> "when" seems strange
04:58:20 * clausen wonders why it can't deal with more general monads
04:58:26 <Heffalump> it makes sense, in MonadZero
04:58:41 <Heffalump> oh, no, not MonadZero, just Monad
04:59:41 <leander-> ohh, with import Monad it doesn't accept my initial call "leorun 1" in the main anymore
05:07:43 * clausen off to bed
05:07:51 <clinton> how do I do something vaguely similar to this?
05:08:12 <clinton>     class (Bounded a, Enum a) => Cyclic a where
05:08:21 <clinton>         succ maxBound = minBound
05:08:28 <clinton>         pred minBound = maxBound
05:08:54 <clinton> the above code gives compile errors...
05:09:43 <ChilliX> you can't do it like this. because the functions that you attempt to define are not members of your new class Cyclic, but of Enum
05:09:48 <ChilliX> which for a is already defined
05:10:04 <ChilliX> you might get away with something like
05:10:54 <ChilliX> you can do something like
05:11:12 <ChilliX>   class (Bounded a, Enum a) => Cyclic a where
05:11:22 <ChilliX>     up maxBound = minBound
05:11:29 <ChilliX>     up x = succ x
05:11:45 <ChilliX> and similarily for down with pred
05:12:35 <clinton> I can't override functions in subclasses?
05:13:15 <ChilliX> no
05:13:40 <ChilliX> that's were the analogy between Haskell type classes and the OO class concept breaks down
05:14:59 <ChilliX> IIRC the reason for this is that Haskell supports type inference, which would not be deccidable otherwise
05:16:18 <clinton> so I can build new classes based on old ones by adding functions, but not by overridding functions?
05:16:42 <ChilliX> that's right
05:19:57 <ChilliX> depending on your application, there is a second way in which you can proceed
05:20:17 <ChilliX> if you want to make some new type an instance of your Cyclic
05:20:27 <ChilliX> you can just defined something like
05:20:34 <ChilliX> instance Enum T where
05:20:34 <ChilliX>   succ x | x == maxBound = minBound
05:20:34 <ChilliX> 	 | otherwise     = succ x
05:20:49 <ChilliX> (modulo indentation)
05:21:11 <clinton> where T is the type?
05:21:12 <ChilliX> ooops
05:21:34 <ChilliX> the succ should have been a non-cyclic version of succ
05:21:39 <ChilliX> yes, T is the new type
05:21:49 <ChilliX> if you want to make an existing type into a cyclic one
05:21:52 <ChilliX> you can use newtype
05:22:21 <ChilliX> eg, if you want to define a modulo ring (in the sense of algebra) from Int do
05:22:28 <clinton> doesn't succ x call itself indefinatly?
05:22:36 <ChilliX> newtype IntRing = MkIntRing Int
05:22:45 <clinton> if x /= maxBound
05:22:58 <ChilliX> yes, that's why I wrote comment after "oops"
05:23:16 <ChilliX> something like
05:23:21 <ChilliX> instance Enum T where
05:23:21 <ChilliX>   succ x | x == maxBound = minBound
05:23:21 <ChilliX> 	 | otherwise     = succNonCyclic x
05:23:28 <clinton> how would I make it the non-cyclic version of succ?
05:23:44 <ChilliX> depends on T
05:23:48 <ChilliX> eg
05:23:49 <clinton> Predule.succ?
05:23:56 <ChilliX> data T = C | D | E
05:24:10 <ChilliX> succNonCyclic C = D
05:24:14 <ChilliX> succNonCyclic D = E
05:24:36 <ChilliX> the same way succ is defined in "normal" instances of Enum
05:24:58 <clinton> I'd have to do that explicitally though?
05:25:03 <ChilliX> yes
05:25:18 <ChilliX> if you want to use "deriving Enum" you need to define a new type class
05:25:19 <clinton> I might as well go succNonCyclic E = C then.
05:25:37 <ChilliX> sure
05:26:06 <ChilliX> there is one more thing you can do
05:26:08 <clinton> can't I access the prelude version via Prelude.succ?
05:26:27 <ChilliX> data T = ... deriving (Eq, Bound, Enum)
05:26:40 <ChilliX> newtype TRing = TR T
05:26:47 <ChilliX> class Enum TRing of
05:27:14 <ChilliX>   succ (TR x) | x == maxBound = TR minBound
05:27:27 <ChilliX>     | otherwise = TR (succ x)
05:27:41 <ChilliX> now TRing is the cyclic version of T
05:27:49 <ChilliX> that's probably actually the best way to do it
05:28:20 <ChilliX> (but still the best way depends on your application; ie, on what is most convenient to use)
05:28:46 <leander-> i get parser errors again and again and again, it's so annoying...
05:29:28 <clinton> "class Enum TRing _of_"... is the 'of' different to where?
05:29:49 <ChilliX> no, "of" was just a mistake by me, must be "where" - sorry
05:30:25 * shapr boings
05:30:30 <ChilliX> Hi shapr
05:30:36 <shapr> hi ChilliX!
05:30:50 <shapr> how's the sunny south treating you?
05:31:35 <ChilliX> Well, mostly with sun...except today where we had mostly clouds
05:31:52 <ChilliX> but, we are surely progressing towards summer
05:32:09 <ChilliX> can already sit outside in our courtyard on weekends and surf via wireless :-)
05:32:25 <shapr> was it confusing to go from north of the equator to south of the equator? did you get two winters, or two summers?
05:32:40 <ChilliX> (but I think, I need an extra antenna; link quality is a bit flacky)
05:32:57 <ChilliX> shapr: confusing: yes!
05:32:58 <shapr> I'm looking forward to ubiquitous outside programming.
05:33:17 <ChilliX> two winters/two summers: neither really
05:33:22 <ChilliX> I moved in December
05:33:28 <ChilliX> end of Dec actually
05:33:39 <ChilliX> so I already had part of a winter before moving into summer
05:33:50 <ChilliX> but it was more summer than winter, I guess
05:33:55 <ChilliX> so 1.5 summer :-)
05:33:59 <shapr> heh, good choice.
05:34:26 <shapr> hey, is there a parr mailing list?
05:34:37 <shapr> I was wondering what other people have used it for.
05:34:57 <leander-> do i have to follow any indentation conventions? my tutorial says nothing about it...
05:35:28 <ChilliX> shapr: no mailing lists, still to experimental
05:35:41 <shapr> oh, ok.
05:35:45 <ChilliX> when it is all integrated in GHC and easier to use, I'll set up a mailing list
05:35:55 <ChilliX> to = too
05:36:06 <ChilliX> leander-: yes
05:36:06 <shapr> sounds good
05:36:12 <cleverdra> leander - you don't have to use the indentation at all.  I mostly follow what haskell-mode thinks.
05:36:25 <shapr> yah, same here.
05:36:32 <Igloo> Does haskell-mode put in braces and ;s for you?
05:36:32 <shapr> haskell-mode has taught me indentation.
05:36:45 <Igloo> Oh, or were those 2 unconnected statements?
05:37:25 <leander-> what is 'haskell-mode' ?
05:37:36 <shapr> haskell-mode does some nice things, autoindent after a type declaration does fill in the name for you.
05:37:41 <shapr> leander-: it's part of emacs
05:37:45 <shapr> what editor are you using?
05:37:49 <leander-> mcedit
05:38:01 <shapr> I haven't heard of that one.
05:38:12 <leander-> midnight commander/cooledit
05:38:15 <shapr> ah
05:38:26 <leander-> i like it very much
05:38:31 <shapr> iirc, cooledit is written entirely in Python
05:38:52 <Igloo> shapr: You mean foo :: String\n results in "foo " being inserted? (give or take a tab)
05:38:55 <leander-> you mean that x11 cooledit i guess
05:39:00 <shapr> Igloo: yup
05:39:38 <shapr> Igloo: it has a few other cool tricks also, such as C-c = re-indenting all of the pattern match statements for this function so that the :: and the = are all in the same column
05:41:11 <Igloo> Why does haskell.org always have to break just when I need it most?
05:41:11 <shapr> oh, and C-c > turns source into .lhs source, C-c w throws in a where, C-c o inserts "| otherwise ="
05:41:16 <shapr> what do you need?
05:41:43 <Igloo> CVS details and the canonical location of LambdaTeX
05:41:53 <shapr> oh
05:41:55 <Igloo> I can find the latter by googling, it's just annoying   :-)
05:42:02 <shapr> ghc cvs?
05:42:05 <Igloo> Yup
05:42:09 * shapr looks locally
05:42:35 <shapr> :pserver:anoncvs@glass.cse.ogi.edu:/cvs
05:43:25 <shapr> that what you need?
05:44:21 <Igloo> I would like the page that tells you what modules you need and what fptools magic you need to do too. It's not a problem, though, I'll just wait for it to get fixed  :-)
05:44:39 <shapr> oh
05:44:48 <norpan> hmmm, lambdatex seems nice
05:45:18 <shapr> hi norpan
05:58:51 <leander-> [last try] would some1 give me an example of how to print an integer?
05:59:23 <shapr> show 5
05:59:30 <norpan> leander-: if i is an integer you can print it with "print i"
05:59:32 <shapr> putStr (show 5)
06:00:17 <cleverdra> putStr (show n) where n = 5 :: Integer
06:00:42 <leander-> oh, it works with putStr but not with print.. thanks
06:01:15 <norpan> print is just putStrLn . show
06:02:05 <shapr> oh
06:02:09 <shapr> I didn't know that.
06:02:34 <leander-> and now even 1+1 works! ;)
06:04:01 <leander-> and even counting from 1 to 10! thanks again guys
06:08:11 <clinton> hmmm, chillix, you weren't by any chance at the UNSW programming competition?
06:08:44 <ChilliX> The one at Open Day? No.
06:08:55 <ChilliX> why?
06:09:18 <clinton> ah, I was in the team that came second...
06:09:24 <ChilliX> cool :-)
06:10:16 <shapr> clinton: did you use Haskell?
06:10:22 <clinton> I did...
06:10:24 <shapr> yay!
06:10:26 * shapr cheers
06:10:36 <clinton> didn't use it as well as I should have though...
06:11:05 <clinton> got two questions done in less than an hour, than got suck on one for the following two hours.
06:12:46 <clinton> in hindsight, should of chose the logic question. I'm surprised at how well logic problems sometimes fall out in haskell.
06:13:09 <shapr> haskell is very logical
06:13:13 <shapr> and sensible.
06:14:07 <clinton> I realise this now, with the benefit of hindsight. Just seemed to make sence at the time to attempt the functional problem.
06:16:58 <ChilliX> clinton: How many people where in your team?
06:17:19 <o3> hullo
06:17:32 <shapr> hi o3
06:17:51 <o3> oh, another UNSWean
06:17:58 <shapr> o3: I'm hoping your ghci research ends up with Haskell as a real 'scripting' language
06:19:03 <o3> shapr: it's hardly research ... all the capability was already in ghci :)  i just had to coerce it to play nicely ...
06:19:17 <clinton> ChilliX: 3
06:19:29 <o3> clinton: were you on simon(b)'s team?
06:20:04 <clinton> no, I'm from hurlstone...
06:20:22 <o3> oh, don't worry.  i'm confusing this with the ACM compo :)
06:20:48 <clinton> nah, this is the script kiddies comp...
06:21:17 <ChilliX> so, you are in Glenunga High?
06:21:42 <clinton> Hurlstone Agricultural High..
06:22:16 <ChilliX> oh, sorry
06:22:26 <ChilliX> the page I saw had the semi-finals it seems
06:24:05 <ChilliX> Did everybody in your team use Haskell?  (I am not sure about the rules of the comp.)
06:25:42 <clinton> no, only one person could be on the computer at a time... and they didn't know haskell... I probably should of taught them a little more though.
06:26:20 <ChilliX> ic
06:30:57 <clinton> most of the other teams used C and Visual Basic...
06:31:04 <shapr> hah
06:31:05 <shapr> scary
06:31:42 <clinton> Visual Basic makes me vomit, and C/C++ I haven't learnt.
06:32:14 <ChilliX> Well, that VB makes you vomit is a good indicator for good taste.
06:33:27 * shapr agrees
06:42:11 <norpan> Vomital Basic?
06:42:22 <shapr> Dysfunctional Programming
06:49:47 <BlizzNL> hello everybody
06:50:04 <shapr> hi BlizzNL, what's up?
06:50:59 <BlizzNL> nothing special just returning from a long day at the U 
06:57:40 * BlizzNL pushed on the red button ;)
07:02:22 * shapr bounces
07:02:39 <ChilliX> 'night
07:02:50 <BlizzNL> ChilliX: bye'
07:02:52 <shapr> g'night
07:04:41 <BlizzNL> I want to write the foldl function as a value definition, but Hugs is bugging me about 'Unresolved top-level overloading' or something: myfoldl = \f a xs -> if xs == [] then [] else myfoldl f (f a (head xs)) (tail xs)
07:05:36 <BlizzNL> the second pair [] should be an a , but that doesn't resolve it
07:07:10 <Heffalump> move the lambda args over to the left
07:07:14 <Heffalump> well, at least one of them
07:07:23 <Heffalump> so myfoldl f = \a xs -> if xs == [] then [] else ...
07:07:28 <Heffalump> it's the monomorphism restriction
07:10:03 <BlizzNL> Heffalump: you are right.. thnx
07:35:22 <Blizz>  Heffalump: I am reading some docs on haskell.org on this monomorphism restriction problem, but it's not perfectly clear_
07:35:48 <Heffalump> no, it's not
07:35:53 <Heffalump> it took me ages to get the hang of it
07:35:54 <Heffalump> basically:
07:36:04 <Blizz> I mean why does this work fine : myfac = fix (\f n -> if n < 3 then n else n * f (n-1)) where this result in an error : myfoldl = fix (\g f a xs -> if xs == [] then a else g f (f a (head xs)) (tail xs))
07:36:06 <Heffalump> foo = ..... is known as a "value" binding
07:36:08 <Heffalump> whereas
07:36:16 <Heffalump> foo x = .... is a "function" binding
07:36:40 <Heffalump> if the former would end up with a type with a forall in it - e.g. forall a . a -> a
07:36:44 <Heffalump> then it's not allowed
07:36:51 <Heffalump> but it's fine for function bindings to have that
07:37:26 <Heffalump> are you sure myfac is ok? What's does :t myfac give?
07:37:31 <Heffalump> s/What's/What/
07:37:58 <norpan> myfac will specialize to Integer I think
07:37:59 <Blizz> Heffalump: myfac is the faculty function e.g. 4 = 24
07:38:07 <Heffalump> oh, yes, specialisation of literals
07:38:09 <Heffalump> YM factorial.
07:38:16 <Heffalump> What type does it get, though?
07:38:35 <Blizz> I haven't decided yet ;)
07:38:44 <Marvin--> Heffalump: eh, what's wrong with forall a . a -> a? That's what id is... Otoh, types on the form (forall a . a -> a) -> b aren't allowed
07:38:48 <Heffalump> IM what type does hugs/ghci give it?
07:39:04 <norpan> Marvin--: the type is allowed, it just wont be inferred
07:39:12 <Heffalump> Marvin--: nothing wrong with it normally, it just violates the monomorphism restriction when a top-level value binding gets such a type.
07:39:16 <Marvin--> ah, right
07:39:17 <norpan> it's a restriction of the type inference algorithm
07:39:17 <Blizz> myfac has Int->Int inferred
07:39:34 <Heffalump> blizz: ok, so that's why it's all right
07:39:39 <norpan> if you put the right type signature on it, it's ok
07:39:40 <Heffalump> because that's not got a forall in it
07:39:57 <Heffalump> norpan: true
07:40:03 <Heffalump> sorry, I should have said that
07:40:32 <Blizz> norpan: what do you mean by that?
07:41:23 <norpan> Blizz: mean by what?
07:41:48 <Blizz> norpan: "put the right type signature on it" on what ;)
07:42:27 <norpan> Blizz: something like myfoldl :: (a -> b -> a) -> a -> [b] -> a
07:42:38 <Blizz> norpan: ohh I'm sorry I understand.. I shouldn't make it forall by defining the type signature, right?
07:43:53 <norpan> you could make it work just by putting the right type signature in
07:44:11 <norpan> the restriction is only for the type inference algorithm
07:45:48 <Blizz> norpan: ok I understand thanks
08:05:06 * BlizzNL has troubles keeping a connection to this server.. It seems to disconnect me after a few minutes of idleness
08:05:52 <shapr> BlizzNL: are you using irc.nl.freenode.net as your server?
08:06:17 <BlizzNL> no irc.openprojects.net
08:06:45 <BlizzNL> shapr: you think I should use yours?
08:06:47 <shapr> try the nl server, might work better
08:07:06 <shapr> irc.openprojects.net is a load-balancing hostname I think
08:07:14 <shapr> same with irc.eu.freenode.net etc
08:07:36 * BlizzNL is on irc.nl.freenode.net ;)
08:07:38 <shapr> yay
08:07:43 <shapr> I hope it helps :-)
08:07:47 <BlizzNL> me too :)
08:15:52 <shapr> what's a good profiling tool in debian?
08:16:51 <Igloo> I've always used GHC's profiling tools, but that's largely due to having problems getting the nhc stuff to work
08:17:05 <shapr> is there a good general purpose binary profiling tool?
08:17:11 <shapr> I could just use time in bash...
08:17:35 <Igloo> What information do you actually want?
08:17:36 <norpan> ghcs new profiling stuff is nice
08:17:45 <Igloo> What's changed, norpan?
08:17:47 <andersca> hey norpan
08:17:51 <norpan> hey
08:18:09 <shapr> Igloo: um... whether apt-build with gcc-3.2 and athlon-mp and -O2 actually changes anything.
08:18:14 <norpan> Igloo: some new methods in heap profiling at least
08:18:31 <norpan> that's the profiling i use, since memory usage often is more of a problem than cpu usage
08:19:08 <Igloo> Oh, well the space behaviour won't change then. I'd use time if I were you
08:19:15 <shapr> ok, thanks.
08:19:26 <shapr> hm, which package should I test....
08:19:48 <Igloo> Ah, OK, I've only ever used the default method - it has sufficed so far
08:20:49 <norpan> new stuff is the "retainer profiling"
08:20:49 <Igloo> Don't you want to time GHC rather than the binary it produces, actually? OAIC?
08:21:04 <Igloo> And the amount of RAM GHC uses could have changed
08:24:14 <Heffalump> he wants to see if it helps the produced binary, surely?
08:24:44 <Igloo> Well I doubt he's apt-building the produced binary, BICBW
08:26:31 <shapr> well
08:26:35 <Heffalump> what does apt-build do?
08:26:47 <Heffalump> OIC, right.
08:26:48 <Heffalump> yeah.
08:26:49 <shapr> it lets you have the good points of gentoo or ports
08:27:16 <shapr> someone on another channel is convinced that gentoo is good because you get optimized binaries that are noticeably faster
08:27:39 <shapr> I want to test that "custom-build is significantly faster" theory
08:35:40 <dennisb> I'm sure it's better. You might save up to a full second per day!
08:35:57 <shapr> well, I want to test it :-)
08:36:56 <Igloo> Being able to take advantage of possible speed improvements from gcc 3 is rather misleading as a general rule for how much better it will be, though
08:37:15 <dennisb> my computer is idle 98% of the day, I wouldn't notice
08:37:53 <Igloo> You might notice if the startup time of something went from 10s to 5s, though. Or compiling something took 10% less time
08:39:27 <dennisb> I might, but I don't turn of my computer and i'm not unhappy with the speed as it is today. I don't think it's a bad idea to optimize, just that other things are more important for me.
08:39:37 <shapr> I wonder if the athlon-mp stuff might make a worthwhile difference.
08:39:51 * shapr decides to test with flac
08:41:15 <dennisb> some of the packages in my redhat installation is for i686, like kernel, glibc, and some other packages. The rest is i386. But if it really was 20% faster compiles with ghc I would not say no
08:41:41 * Igloo would be interested in shapr's findings
08:41:52 <dennisb> oh, me too
08:42:36 <Igloo> Ideally you'd write a script to recompile ghc with the cross product of the options and time simpiling the same thing with each  :-)
08:43:06 <shapr> simpiling?
08:43:14 <Igloo> compiling
08:43:19 <shapr> oh
08:43:45 <shapr> I suspect spiffy options might make more difference on my AMD SMP machine
08:43:46 * Igloo looks at key layout - I don't think I hav much of an excuse for that one  :-)
08:43:48 <shapr> we'll see
08:51:19 <shapr> first test:
08:51:36 <shapr> i686 - flac -8 ap16_launch.wav  2.20s user 0.02s system 100% cpu 2.215 total
08:51:36 <shapr> MP - flac -8 ap16_launch.wav  2.18s user 0.02s system 99% cpu 2.209 total
08:52:11 <dennisb> what are you testing? What is flac?
08:52:22 <shapr> it's from flac.sf.net
08:52:28 <shapr> free lossless audio compression
08:52:48 <shapr> I don't use mp3s or oggs if I get the choice, bits are missing.
08:54:11 <shapr> things that use the most cpu on my system are XF86, xmms, and xemacs
08:54:38 <shapr> flac is single-threaded, so it doesn't test the MP specific optimizations.
08:56:05 <shapr> the first test says it might be worthwhile to apt-build ghc5
08:56:32 * shapr looks for a chunk of haskell source to use for timing ghc5
08:56:45 <shapr> does ghc5 does -j2 by default?
08:58:26 * shapr chooses ghc5.04.1
09:15:34 <shapr> make -j2  1337.63s user 102.26s system 160% cpu 14:55.31 total
09:15:36 <shapr> cute
09:15:40 <shapr> too bad it crapped out
09:23:44 <shapr> hi bryan
10:29:04 <olczyk> I'm looking for a realatively simple program that clearly demonstrates the advantage of
10:29:11 <shapr> ?
10:29:12 <olczyk> using higher order functions.
10:29:27 <Igloo> sortBy?
10:29:29 <olczyk> shapr:: ??
10:29:34 <andersca> map? :)
10:29:36 <shapr> what about "putStrLn map show [1..9]"
10:30:14 <Heffalump> you're missing a $
10:30:20 <shapr> oh, good point
10:30:29 <olczyk> How does it demonstrate the advantages of higher order functions?
10:30:38 <Heffalump> and that's not a great example
10:30:43 <shapr> it's simple :)
10:30:51 * olczyk agrees.
10:30:55 <Heffalump> since for(i=1;i<9;i++) printf("%d\n",i);
10:30:56 <Heffalump> is equivalent
10:31:01 <shapr> fair enough
10:31:14 * shapr thinks
10:31:18 <shapr> oh
10:31:47 <shapr> what about mapping an ord chr pipeline?
10:32:03 <shapr> hmm
10:32:16 <shapr> olczyk: have you used Python? or first class functions in other languages?
10:32:57 <olczyk> Somewhat. Im not sure I did in python.
10:33:12 <olczyk> Smalltalk/Ruby block closures I supose.
10:33:39 <shapr> you can use a function like a hammer to hit a bunch of nails in a row.
10:33:40 <olczyk> Function objects in C++ ( I invented them independently ).
10:33:52 <shapr> right
10:34:05 <olczyk> right.
10:34:08 <shapr> map is a higher order function because it takes a function as data
10:35:25 <shapr> so map, filter, foldr, etc all let you automate a function call
10:36:22 <olczyk> You gotta do better!
10:36:36 <shapr> umm
10:36:51 * shapr looks for handy source
10:37:17 <shapr> int2b128                :: String -> Integer -> String
10:37:17 <shapr> int2b128 stream integer = stream ++ (map (chr . fromInteger ) (debaseInt128 integer))
10:37:20 <olczyk> It doesn't have to be your code. Just not something so complex it hides the advantages.
10:38:50 <shapr> there's a network encoding where I need to turn an integer into a base 128 number and then send it
10:39:02 <shapr> and on the other end, turn it back into an integer
10:39:49 <shapr> well, I dunno if this is a good example...
10:40:14 <shapr> what about lambda?
10:40:22 <shapr> \x -> x + 1
10:40:35 <shapr> map (\x -> x + 1) [1..9]
10:41:29 <shapr> filter (\x -> (x / 2) == 0) [1..9]
10:41:42 <shapr> olczyk: looks useful?
10:41:58 <shapr> or maybe
10:43:05 <shapr> zipWith (*) [1..9] [9,8..1]
10:43:45 <shapr> map (putStr . show) (zipWith (*) [1..9] [9,8..1])
10:44:18 <olczyk> Hmm.What do filter and zipWith do?
10:44:39 <shapr> filter only gives you the items of a list that satisfy that condition
10:44:46 <shapr> olczyk: do you have hugs or ghci installed?
10:44:51 <shapr> and open?
10:45:06 <olczyk> Yes, but not on this machine. 
10:45:18 <shapr> well, it's easier if you can try these interactively.
10:45:38 <shapr> olczyk: have you gone through the Haskell Tutorial? I think it does a better job of explaining this than I do.
10:46:09 <Heffalump> for(i=1;i<9;i++) printf("%d",i*(10-i));
10:46:22 <Heffalump> you really should choose an example that would be *longer* in C if you can :-)
10:46:33 * olczyk boggles at figuring which which one that is. To many references available.
10:46:33 <shapr> Heffalump: you want to come up with one? :-)
10:46:58 <Heffalump> I need to go home now, I'll try and think of something good on the way.
10:47:08 <shapr> ok
10:47:23 <shapr> olczyk: http://www.isi.edu/~hdaume/
10:47:30 <shapr> that has Yet Another Haskell Tutorial there
10:47:42 <Igloo> But C does have higher order functions, just without much help from the type system
10:47:58 <Igloo> So you are unlikely to get a significantly shorter example
10:49:58 <Heffalump> it doesn't have anonymous functions
10:50:14 <Heffalump> and I'd compare it with sensible C code, not the direct equivalent
10:50:45 <Igloo> Would you compare sortBy to a functin that took a functino as an argument in C?
10:51:00 <Heffalump> hmm, I suppose
10:51:46 <shapr> aha
10:51:48 <shapr> http://www.cse.unsw.edu.au/~paull/cs1011/hof.html
10:51:49 <olczyk> qsort
10:52:14 <olczyk> Is Yat Another haskell Tutorial the name?
10:52:23 <shapr> yes it is.
10:52:40 <Igloo> The only win you'd get if anonymous functinos are important is something that uses a function argument multiple times on the RHS
10:53:15 <shapr> hi toadx
10:53:22 <toadx> hello!
10:53:25 <shapr> how are ya?
10:53:36 <toadx> pretty good
10:54:01 <shapr> learned any nifty coding tricks lately?
10:54:19 <toadx> no, but I found something that is hard to implement -- convolution on lists
10:54:55 <toadx> or perhaps that should be convolution of lists
10:56:07 <toadx> I have i 'simple' implemention that works for short lists. But if the lists are 4000+ elements each, the heap overflows (even if the heap is 400 megs)
10:56:33 <shapr> [[(x,y) | x <- [1..5] ,y <- [1..5] ]
10:56:51 <shapr> you want all combinations of the items?
10:57:43 <toadx> no convolution... http://www.ee.ed.ac.uk/~mjj/dspDemos/EE4/tutConvDisc.html
10:58:18 <toadx> I want to write a program to do the calculation in equation (2) on that page
12:02:23 <BlizzNL> I wrote my foldl function as a value definition like this: myfoldl f = \a xs -> if xs == [] then a else myfoldl f (f a (head xs)) (tail xs) which works fine but now I want to write it capturing the recursion in a fix like this:
12:02:40 <BlizzNL> fix e = e (fix e) myfoldl g = fix (\f a xs -> if xs == [] then a else g f (f a (head xs)) (tail xs))
12:02:54 <BlizzNL> this leads to a strange error
12:02:55 <Heffalump> looks good
12:02:58 <Heffalump> oh, what?
12:03:00 <BlizzNL> Heffalump: thnx ;)
12:03:12 <Heffalump> oh, you have one too many f
12:03:34 <Heffalump> "g f" should be just "g"
12:04:04 <Heffalump> oh, no.
12:04:07 <BlizzNL> Heffalump: no look at my first myfoldl it has that too 
12:04:19 <Heffalump> the problem is you're mixing up g and f completely
12:04:36 <Heffalump> the formal parameter g should be an f
12:04:43 <Heffalump> and the \f should be \g
12:05:05 <Heffalump> and *then* "g f" should be a "g", cos it's replacing "myfoldl f"
12:06:08 <BlizzNL> by formal parameter you mean the parameter before = ?
12:06:18 <Heffalump> yes
12:06:42 <Heffalump> if you have "f x = ..." and call it with "f 3", x is called the formal parameter and 3 the actual parameter
12:07:33 <BlizzNL> I should have remembered that from other languages.. I keep thinking in Haskell everything is harder ;)
12:09:18 <BlizzNL> But like always you are right and it works now.. you should teach, 'cause you're a really fast problem solver!
12:10:03 <Igloo> He does  :-)
12:10:50 * Heffalump works at Oxford uni, doing research and a bit of teaching
12:11:29 <BlizzNL> Heffalump: So you are working on your phd?
12:11:49 <Heffalump> no, done that
12:12:01 <Heffalump> I'm a postdoc
12:12:25 <BlizzNL> Heffalump: ahh ok great dr. Heffalump ;)
12:13:11 * BlizzNL is doing Software Technology (Msc) at Utrecht University
12:14:00 <Heffalump> funny you should mention that - http://urchin.earth.li/photopub/display?photo=/users/ganesh/banana/2009&rotate=270 :-)
12:14:14 <Heffalump> (the dr. Heffalump thing, not the Utrecht University thing)
12:14:22 <Heffalump> my boss was at Utrecht university.
12:14:24 <BlizzNL> Haha great!
12:14:38 <Heffalump> it's his business card that got edited for that photo :-0
12:14:38 <Heffalump> s/0/)/
12:16:14 <BlizzNL> Heffalump: what courses do you teach?
12:16:32 <Heffalump> varies - I don't lecture, just give classes or tutorials
12:17:03 <Heffalump> Functional Programming, Programming Languages, Compilers, Procedural Programming, Formal Program Design II are all names of courses I've taught for
12:18:15 <BlizzNL> IC
12:29:26 <Marvin--> you get a business card for giving classes and tutorials? hey! ;)
12:30:24 <Heffalump> it's not the most official of cards :-)
12:30:53 <Marvin--> I don't even get an unofficial one! :)
12:31:53 <Marvin--> ARGH, someone's been running ghc for 20 hours on the remote-login machine and it's taking all available cpu
12:32:05 <toadx> hehe
12:32:11 <Heffalump> how can one GHC process take 20 hours?
12:32:16 <Marvin--> beats me!
12:32:20 <Heffalump> unless it died badly, of course
12:32:27 <Marvin--> probably that
12:32:39 <Marvin--> and it's someone in the afp course, who definitely should know better..grrr
12:32:45 <Marvin--> (advanced functional programming)
12:33:39 <Marvin--> huh, this has GOT to be a conspiracy... So far, groups 4, 14, 24 and 34 have handed in the first assignments, but no others (I correct the even-numbered)
12:38:33 <andersca> oh, the programming languages ones?
12:39:07 <Marvin--> yep
12:39:23 <Marvin--> andersca: what are you people up to?! :)
12:39:37 <andersca> I'm group 12 :)
13:11:44 <norpan> hi all
13:11:55 <andersca> hello norpan
13:12:48 <norpan> what's up?
13:13:53 <andersca> norpan: still thinking about the function syntax 
13:14:10 <norpan> andersca: you poor bastard
13:14:59 <andersca> norpan: it's pathetic, isn't it
13:15:04 <norpan> yes
13:15:41 <Marvin--> heh
13:17:35 <andersca> ah well
13:17:45 * andersca isn't going to implement lambda expressions until lab4 anyway
14:20:38 <ChoJin> anyone from uk here ?
14:20:44 <Heffalump> meeeeeeeeee!
14:20:49 <Heffalump> and Igloo
14:23:12 <Marvin--> heh, Rule Britannia and all that, good concert though
14:23:37 <Marvin--> "we'll taaaake a cup of kiiindness yet"
16:18:23 * Igloo wonders why Chojin asked
16:18:58 * Heffalump too :-)
16:26:17 <ChoJin> Igloo: because I would like to know if in english you use "internship" or "training periode" ?
16:26:42 <ChoJin> americain use "internship" but dunno about "correct english"
16:27:04 <Igloo> Both, but for different things I think
16:27:25 <Igloo> Or maybe just internship
16:27:44 <Igloo> You have some period at the start of working for a company full time, but the name escapes me
16:27:48 <Heffalump> a training period would be different
16:27:51 <Heffalump> induction
16:28:05 <ChoJin> I talk about a guy going to a society for working, but for learning too
16:28:08 <Heffalump> internship is probably appropriate English, anyway
16:28:11 <ChoJin> "stage" in france
16:28:13 <Igloo> internship implies a period of working for a company without continuing afterwards necessarily
16:28:15 <Heffalump> training might not include working
16:28:30 <ChoJin> k
16:28:33 <ChoJin> thus internship
16:30:59 <toadx> there is also probation period
16:31:52 <Heffalump> oh, yes
16:32:58 <Igloo> That's the one
16:33:23 <ChoJin> k thx :)
16:39:27 <toadx> ChoJin: Internship == college student who gets paid 1/3 of what a normal employee gets, Probation == first six months of a job where you can be fired with less paperwork
16:40:08 <Heffalump> if interns get paid 1/3 of what normal employees get, Microsoft full-timers get paid (as opposed to have stock options for) shitloads.
16:43:01 <ChoJin> toadx: yeah, but in fact we had a troll about "is the word the same in english than in american"
16:43:04 <toadx> I should have said less than 1/3
16:43:19 <ChoJin> because in our dictionnary we don't find "internship" :)
16:43:39 <toadx> ChoJin: dunno, I only know american (and like 5 japanese words)
16:43:53 <Heffalump> toadx: then they get paid really shitloads :-)
16:43:57 <Igloo> You realise shitloads means "a lot", not "very little", right?
16:44:10 <Heffalump> it's not necessarily 6 months, it varies from job to job
16:53:38 <Heffalump> 'lo
16:55:40 <Pseudonym> G'day.
17:07:18 <toadx> oops. Was not paying attention :)
