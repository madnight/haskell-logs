00:08:33 <sethk> Pseudonym: Now I have the reverse problem, I have a variable of type IO Handle and wnat to use it in an expression that needs Handle.
00:09:23 <Marvin--> has anybody used Swierstra's parsing combinators?
00:09:38 <sethk> No.
00:09:51 <sethk> I mean I haven't not that everyone hasn't
00:10:27 <Marvin--> :)
00:11:35 <jemfinch> is there a place to submit bugs/tyops found in the Gentle Introduction to Haskell?
00:12:05 <sethk> I think the author has a web page with his email address.
00:15:39 <Pseudonym> sethk: That's what >>= is for.
00:15:53 <Pseudonym> make_a_handle >>= \h -> use_a_handle h
00:16:26 <sethk> OK, maybe I'm getting two convoluted here, I'm trying to work with two handles at once...
00:18:15 <sethk> Here is what I did, which almost worked...
00:18:21 <sethk> getargs >>=
00:18:39 <sethk> args -> return (((!!) args 0), ((!!) args 1)) >>=
00:18:57 <sethk> (name1, name2) -> return ((openFile name1 ReadMode), name2) >>=
00:19:39 <sethk> (ifile, ofile) -> ((hGetContents ifile), ofile) >>=
00:19:51 <sethk> where I get the "ifile is IO Handle, not Handle".
00:20:33 <sethk> (I'm not saying this is good code, I'm experimenting to see if I understand)
00:20:40 <Marvin--> sethk: wtf are you writing (!!) args 0=
00:20:49 <Marvin--> when you can write args !! 0?
00:21:11 <Marvin--> and you need lambdas
00:21:14 <Marvin--> >>= \foo
00:21:29 <Marvin--> or just use the frickin' do notation
00:22:02 <sethk> Yes, I know about the do notation; I'm trying to understand the combinators.
00:22:27 <sethk> As for ((!!) args 0), must be my (reverse) Polish ancestry...
00:22:51 <Marvin--> aha
00:23:01 <sethk> And all the lambdas are there, I think...
00:23:15 <Marvin--> <sethk> (name1, name2) -> return ((openFile name1 ReadMode), name2) >>=
00:23:26 <Marvin--> you'd need \(name1, name2) -> ...
00:23:51 <Marvin--> but if you do return (openFile ...) you'd get IO (IO Handle) which is kinda silly
00:24:12 <Marvin--> and because of the scoping rules you don't have to pass name2 on AGAIN
00:24:41 <sethk> I did have the \, I must have missed it on the copy.  I see about the return.  Why don't I need name2?
00:25:09 <Pseudonym> Sorry, I was AFK.
00:25:17 <Marvin--> let (args1, args2) = (args !! 0, args !! 1) in openFile name1 readMode >>= \ifile -> hGetContents ifile >>= ...
00:25:37 <Pseudonym> Yes, you don't need to pass names along like that.
00:26:32 <Marvin--> sethk: in \x -> a >>= \y -> b >>= \z -> c, the parentheses are \x -> a >>= (\y -> b >>= (\z -> c)) so you can always use "earlier" variables
00:26:38 <Marvin--> just like you'd expect when sequencing things
00:26:39 <sethk> Now you lost me, unless you mean "openFile args1" instead of "openFile name1"
00:26:39 <Pseudonym> getargs >>= \args -> let { name1 = args !! 0; name2 = args !! 1 } in openFile name1 ReadMode >>= ...
00:27:02 <sethk> OK...
00:27:07 <Marvin--> sethk: sorry, yes, args1
00:27:31 <Marvin--> sethk: or call it name1 directly :)
00:27:34 <Pseudonym> Or even better: getargs >>= \args -> let (name1:name2:_) = args in ...
00:27:46 * Marvin-- ndos at Pseudonym
00:28:02 <andersca_> morning
00:28:05 <Pseudonym> You might want to use do notation.  You might find it a lot less confusing.
00:28:21 <sethk> I'm trying to confuse myself, so I can unconfuse myself.
00:28:26 <Marvin--> Pseudonym: well, if the goal is to understand the combinators, then that kinda defeats the purpose...
00:28:30 <Pseudonym> Well true.
00:28:50 <Marvin--> One Of These Days, I'll try to understand Arrows
00:29:29 <Pseudonym> Arrows look both really elegant and gross overkill for most purposes.
00:29:43 <Pseudonym> Might just be me, though.
00:32:11 <Marvin--> hehe, it's probably true
00:32:24 <Marvin--> I got the impression that it's more of a theoretical experiment
00:33:38 <sethk> Hey, it works!!!!!
00:33:55 <Pseudonym> Woohoo!
00:34:22 <Pseudonym> ON that note, time for me to go home.
00:34:23 <Pseudonym> Bye all.
00:34:35 <sethk> That pattern match (name1:name2:_) works even if the array has only two members?
00:34:51 <sethk> Goodnight, thanks for the help
00:34:59 <Pseudonym> Yes.
00:35:02 <Marvin--> sethk: yep
00:35:05 <Marvin--> sethk: _ matches [] too
00:35:14 <Pseudonym> [a,b] is the same as a:b:[]
00:35:19 <Pseudonym> Night all.
00:35:25 <sethk> Night
00:36:40 <sethk> Marvin, I've got to go for a while; I have a coder here who needs help.  I might be back in a while.  Thanks for the help.
00:37:53 <Marvin--> no problemo
01:21:41 * tmoertel goes off to sleep
01:22:32 * tmoertel but not before mentioning that there now is an animate-ascii.el mode to animate RAVT visualizations in Emacs
01:42:20 <sethk> I anyone sees this and feels like writing an answer I will be grateful as soon as I regain consciousness.
01:42:37 <sethk> I have the following type defined by a data statement:
01:42:53 <sethk> data Element = Number Int
01:43:03 <sethk> | Fnumber Float
01:43:12 <sethk> | Name String
01:43:36 <sethk> which is part of a Happy parser.  Now, I have parsed, and I have a list of Elements.
01:43:49 <sethk> I want to take one of these elements and use it as the key to a FiniteMap.
01:44:05 <sethk> The particular Element that I will use is always a string, but of course the compiler
01:44:16 <sethk> can't know that.
01:44:41 <sethk> Since the key to FiniteMap must be an instance of Eq, how to I make Element an instance
01:44:56 <sethk> of Eq (assuming that this is the correct thing do do in the first place).
01:44:58 <sethk> TIA
02:05:26 <Heffalump> deriving Eq
02:05:43 <Heffalump> though in fact you need Ord to be a key for a FiniteMap
02:11:37 <norpan> just derive (Eq,Ord) and you'll be fine
02:11:45 <andersca> hi mr norp
02:11:49 <norpan> hi mr andersca
02:11:58 <andersca> norpan: I liked your poem
02:12:10 <norpan> andersca: thanks, i'm here to please
02:12:31 <andersca> norpan: I'm here too, please
02:34:45 <jemfinch> how does one read a type definition like, "elem :: Eq a => a -> [a] -> Bool"
02:34:47 <jemfinch> ?
02:35:14 <Heffalump> elem is a function that takes a value of type a, a list of elements each of type a, and returns a Boolean.
02:35:26 <Heffalump> 'a' can be any type you like, so long as it is an instance of class Eq.
02:35:37 <ChilliX> elem has the signature a -> [a] -> Bool provided a is one of the types in the set of types specified by Eq
02:36:12 <jemfinch> "elem takes an instance a of Eq and a list of a and returns a bool"?
02:36:29 <jemfinch> I'm pretty well-versed in ML, so I can handle everything but the "Eq a =>" part :)
02:37:04 <ChilliX> ok
02:37:21 <ChilliX> in ML it is a' -> a' list -> bool
02:37:29 <jemfinch> yeah :)
02:37:34 <Heffalump> ''a -> ''a list -> bool
02:37:35 <Heffalump> I think
02:37:39 <jemfinch> I didn't have problems with that part of the type definition.
02:37:40 <ChilliX> or that
02:37:42 <jemfinch> Heffalump: depends.
02:37:53 <Heffalump> the point about Eq a is that it forces a to be an equality type
02:37:57 <ChilliX> the point is that this distinction between types a and ''a in ML is fixed
02:38:04 <jemfinch> Heffalump: in SML, it'd be ''a -> ''a list -> bool, but in O'Caml, it'd be 'a -> 'a list -> bool.
02:38:08 <ChilliX> in Haskell it is definable
02:38:09 <Heffalump> ah, ok
02:38:20 <jemfinch> O'Caml doesn't do eqtypes.
02:38:22 * Heffalump uses SML not OCaml
02:38:33 <jemfinch> OCaml is significantly less "safe" than SML.  I like SML better.
02:38:55 <jemfinch> ("safe" here means "unlikely to raise exceptions")
02:39:51 <jemfinch> hmm.
02:39:59 <jemfinch> my ghc-5.04 crashes on "div 1 0"
02:40:56 <ChilliX> ghc or the produced binary?
02:41:02 <jemfinch> ghc.
02:41:19 <ChilliX> ghci terminates after raising an exception, which is a known bug
02:41:28 <jemfinch> oh, ok.
02:41:31 <ChilliX> maybe the two are related
02:41:32 <jemfinch> that's an interesting bug :)
02:41:47 <ChilliX> well, to do with signal handling and other tedious stuff
02:44:58 <jemfinch> hmm.
02:45:26 <jemfinch> [1,2,3] is of the type "Num a => [a]"
02:45:41 <jemfinch> how does one say "int list" in Haskell?
02:47:12 <ChilliX> [Int]
02:47:57 <ChilliX> if you want to force [1,2,3] to be an int list, do: [1,2,3] :: [Int]
02:48:11 <ChilliX> (but usually this is not needed, as the context will do that)
02:49:16 <jemfinch> wow, this is cool!
02:49:20 <jemfinch> I like Haskell's typeclasses.
02:49:35 <jemfinch> read "[1,2,3]" :: [Int]
02:49:36 <ChilliX> :-)
02:49:43 <ChilliX> yep, that's neat
02:50:02 <jemfinch> that's something that can't really be done easily in ML.
02:50:44 <ChilliX> AFAIK, ML doesn't really try to address the problem of overloading in any systematic way
02:50:54 <jemfinch> no, not really.
02:51:20 <jemfinch> I like this strange mix of OO and FP in Haskell much better than the ugly mix of OO and FP in O'Caml :)
02:52:47 <ChilliX> :-)
02:53:10 <norpan> If you think Haskell
02:53:19 <norpan> 's type classes are cool, try Cayenne :)
02:53:44 <norpan> "The drawback of such a powerful type system is that the type checking becomes undecidable."
02:53:59 <jemfinch> inferring?
02:54:06 <norpan> no, checking :)
02:55:02 <norpan> i wouldn't even try to think about inferring dependent types
02:55:12 <jemfinch> oh ok :)
02:56:49 <norpan> look at printf at the bottom of http://www.math.chalmers.se/~augustss/cayenne/examples.html
02:57:19 <jemfinch> does Haskell have dependent types?
02:57:22 <norpan> no
02:57:36 <norpan> not more than given through the type variables
02:58:44 <ChilliX> jemfinch: norpan's comment about type checking becoming undecidable was wrt to Cayenne, not Haskell
02:58:54 <jemfinch> yeah, I was just making sure :)
02:58:58 <jemfinch> What's Cayenne?
02:59:16 <norpan> experimental language which looks like haskell but has a more powerful type system
03:00:56 <jemfinch> when I see variable names preceded by a \, what does that mean?
03:01:06 <Heffalump> give some context
03:01:10 <norpan> jemfinch: lambda abstraction
03:01:12 <Heffalump> oh, a \ on its own
03:01:16 <Heffalump> not a "\,"
03:01:17 <andersca> norpan: is it the helper
03:01:18 <jemfinch> >  newDB :: StateT DB Bool
03:01:18 <jemfinch> >  newDB = addRec rec1 `thenST` \bool1 -> 
03:01:18 <jemfinch> >          addRec rec2 `thenST` \bool2 ->
03:01:18 <jemfinch> >	   delRec rec3 `thenST` \bool3 ->
03:01:18 <jemfinch> >	   returnST (bool1 && bool2 && bool3)
03:01:20 <norpan> jemfinch: to create an anonymous function
03:01:38 <Heffalump> yeah, "\a -> " is the equivalent of (S?)ML's "fn a => "
03:01:50 <jemfinch> oh, ok.
03:01:57 <jemfinch> that's what I thought, but it seems strange since they were on separate lines :)
03:01:58 <norpan> \x -> expr(x) means the function taking an argument x and producing the value expr(x)
03:02:43 <norpan> jemfinch: the example you gave is the way you wrote monad expressions before the "do" construct was introduced
03:02:50 <Heffalump> that example is a good place to introduce monadic "do" syntax.
03:03:03 <Heffalump> you could now write
03:03:04 <jemfinch> I'm reading "What the hell are Monads?" :)
03:03:14 <Heffalump> newDB = do bool1 <- addRec rec1
03:03:24 <Heffalump>            bool2 <- addRec rec2
03:03:35 <Heffalump>            bool3 <- delRec rec3
03:03:40 <norpan> provided that StateT is an instance of Monad with >>= being thenST of course
03:03:46 <Heffalump>            return (bool1 && bool2 && bool3)
03:03:47 <Heffalump> yeah.
03:03:57 <norpan> i must work some now .)
03:04:00 <Heffalump> and return being returnST
03:04:06 <jemfinch> yup :)
03:04:27 <jemfinch> that's where it goes on to explain it...that syntax makes a lot more sense now that I understand what it came from, though.
03:05:01 <jemfinch> now, what if I don't want to bother with capturing the result of a monadic operation?  Like, say, I don't want bool1 -- do I just use the wildcard _?
03:05:01 <Heffalump> yeah, that does help a lot
03:05:10 <Heffalump> just leave out the foo <- altogether
03:05:36 <Heffalump> leaving it out is effectively shorthand for _ <- 
03:05:38 <jemfinch> how would it look?
03:05:48 <Heffalump> newDB = do addRec rec1
03:05:54 <Heffalump> (...)
03:06:05 <jemfinch> oh, it's that simple.
03:09:48 <jemfinch> Heffalump: so you say you use SML?  For what things do you use Haskell, and what things do you use SML?
03:10:49 <Heffalump> I'm using SML for a project that needs to work under .NET
03:11:08 <Heffalump> there's an SML.NET compiler but no complete Haskell .NET compiler
03:11:22 <jemfinch> oh, that's cool.
03:11:31 <Heffalump> but I like SML's functors and I think I like not having the layout rule. Apart from that I prefer Haskell :-)
03:11:32 <jemfinch> so of the two, you'd rather work with Haskell?
03:11:36 <Heffalump> mostly, yeah.
03:11:44 <jemfinch> you don't like the layout rule?
03:12:02 <Heffalump> no, I make random mistakes and sometimes even GHC's error messages aren't helpful
03:12:14 <jemfinch> oh, ok.
03:12:33 <Heffalump> during the ICFP contest I had to get someone else to track down an error caused by it on two occasions
03:12:40 <jemfinch> I'm looking at the PLEAC for Haskell ( http://pleac.sourceforge.net/pleac_haskell/strings.html ) and there's some syntax there I don't recognize.
03:12:41 <Heffalump> which was really annoying
03:13:08 <Heffalump> which bits?
03:13:29 <jemfinch> well, first there's an ' s = "This is what you have" ' part, I got that much :)
03:13:42 <jemfinch> what are the s.last, s.match, etc. things?
03:13:48 <Heffalump> . is composition
03:14:01 <Heffalump> more usually written with spaces around it (that threw me for a second too)
03:14:03 <jemfinch> you can compose a string and a function?
03:14:12 <Heffalump> oh.
03:14:15 <Heffalump> errm.
03:14:22 * Heffalump withdraws that
03:14:34 <jemfinch> :)
03:15:16 <Heffalump> ghci gives a type error when I try that.
03:15:34 <jemfinch> so does hugs.
03:15:40 <Heffalump> it's possible they've redefined what . is
03:15:48 <Heffalump> (without saying so)
03:15:53 <jemfinch> well that's crazy.
03:15:59 <Heffalump> yeah.
03:16:10 <jemfinch> the point of PLEAC is to have examples in the language, not in some strange dialect with builtins redefined...
03:16:14 <Heffalump> actually, they've redefined !! too
03:16:30 <Heffalump> oh, you can redefine . and !! just by importing the Prelude "qualified"
03:16:37 <Heffalump> it's part of the language
03:16:41 <jemfinch> oh, ok.
03:16:42 <Heffalump> (I think)
03:16:46 <jemfinch> what do the redefinitions do?
03:16:50 <Heffalump> no idea :-)
03:16:53 <Heffalump> they don't seem to say.
03:17:01 <Heffalump> I'd guess !! has been redefined to do sectioning
03:17:14 <Heffalump> and . has been redefined to be application with the arguments switched
03:17:17 <Heffalump> so s.last = last s
03:17:32 <jemfinch> that's interesting.
03:17:49 <jemfinch> it's funny how the syntax becomes so much more like an OOPL with that in place.
03:17:49 <Heffalump> and as!!bs = [(Prelude.!!) as b | b <- bs]
03:17:54 <Heffalump> yeah
03:20:47 <jemfinch> thanks for the help...I'm going to bed now, and I'll pick up some more Haskell later tonight :)
04:43:29 * shapr awakens
05:12:06 <norpan> what's this
05:12:43 <BlizzNL> oeps forgot people get kicked for this kind of behaviour
05:13:33 <ChilliX> ?
05:17:31 <BlizzNL> ChilliX: I cut&pasted some code with a question and I got kicked out
05:18:20 <norpan> you have to talk slowly or the irc server will disconnect you :)
05:18:45 <ChilliX> I just saw:
05:18:49 <ChilliX>  BlizzNL has quit (Read error: 104 (Connection reset by peer))
05:18:51 <norpan> but if you have a good irc client it will talk slowly for you
05:18:54 <ChilliX> didn't look like a kick
05:19:24 <shapr> I think the irc server has kicks you if you flood
05:20:16 <shapr> hi ChilliX, how's code?
05:20:44 <shapr> hi norpan
05:20:48 * shapr bounces happily
05:21:06 <ChilliX> shapr: new version of c2hs is out, but I am sure you saw that
05:21:18 <shapr> yah, I've already installed it :-)
05:21:22 <shapr> I should add that to the topic
05:23:47 --- topic: set to 'ICFP 2002 Robot Analysis and Visualization Toolkit 0.8 http://tea.moertel.com/~thor/ravt/ || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || parr 0.2.3 released http://www.cse.unsw.edu.au/~chak/nepal/' by shapr
05:27:19 <shapr> er
05:27:27 <shapr> I have c2hs 0.10.15
05:27:37 <shapr> maybe I'm confused.
05:32:49 <norpan> i can only see the beginning of the topic anyway
05:33:06 <shapr> which irc client are you using?
05:33:13 <norpan> irssi
05:33:15 <shapr> oh
05:33:19 <norpan> it only shows one line of topic
05:33:20 <shapr> what's the max topic size for it?
05:33:30 <norpan> i can type /topic to see it all
05:35:12 * shapr pokes Erwin
05:35:54 <norpan> pleac for haskell looked nice
05:36:03 <shapr> norpan: I can put the most recent stuff in the beginning of the topic if that's easier for you.
05:36:27 <norpan> shapr: i don't usually read irc topics for news anyway :)
05:36:45 <shapr> ok :-)
05:42:21 * shapr wonders if the hIDE author ever shows up here
05:43:36 <shapr> I hope that thread on ghc-users turns up with runtime loading of haskell modules in an executable.
05:44:13 <shapr> I would very much like to switch to an editor scriptable in Haskell rather than elisp.
05:46:25 <ChilliX> shapr: tell jens about that
05:46:40 <ChilliX> it's an old wish of his
05:47:17 * shapr looks for the url of the thread
05:49:19 <shapr> jens: in case you haven't seen this thread: http://www.haskell.org/pipermail/glasgow-haskell-users/2002-August/003929.html
06:05:27 <norpan> i want to be able to make a "normal" library out of my haskell library, i hope that thread on ghc-users turns up with the possibility to make a .so library under unix with ghc :)
06:06:09 <Heffalump> is that not already possible?
06:06:15 <norpan> not on unix
06:06:16 <norpan> only on windows
06:06:21 <Heffalump> I've never tried but I sort of assumed it would be.
06:06:22 <Heffalump> oh :(
06:07:09 <norpan> simon m claims it's because the ELF format is too limited
06:07:17 <ChilliX> norpan: you can already make a "normal" statically linked lib out of a haskell lib
06:08:09 <norpan> ChilliX: how? see the thread on glasgow-haskell-users
06:08:49 <norpan> but perhaps the restriction is only for dynamic linking
06:09:46 <Heffalump> GHC packages are .a files
06:10:16 <norpan> Heffalump: that is true
06:10:20 <norpan> so it should be possible
06:10:25 <norpan> but i want dynamic linking
06:15:14 <ChilliX> norpan: yes, the restriction is only on dynamic linking
06:16:34 <norpan> but i WANT dynamic linking :(
06:16:41 <norpan> i want to be able to dlopen my libraries
06:17:13 <norpan> i want to be able to make plugins to different programs using shared libraries where the plugins are written in haskell
06:17:45 <shapr> iirc, the thread said ghc optimizations that place code next to data mean you can't do that...
06:18:06 <shapr> maybe you could ask for yet another ghc command-line switch?
06:18:20 <norpan> but why can the linker cope with those optimizations when linking statically
06:18:31 <norpan> i think it sucks :(
06:18:45 <shapr> I know nothing about linking.
06:18:51 <shapr> so I can't help you :-(
06:19:08 <ChilliX> norpan: plugins are a differnt issue
06:19:12 <ChilliX> they already work
06:19:27 <ChilliX> meaning, you there is no ready-made, nice to use interface
06:19:41 <ChilliX> but all the linking infrastructure etc is there
06:20:24 <ChilliX> the only thing you don't get is the sharing of libraries objects when multiple programs use the same libs, that's all
06:20:32 <norpan> i mean plugins to programs written in c, the plugins being dlopened which means they must be shared objects
06:20:45 <shapr> hi BlizzNL
06:20:53 <BlizzNL> Hi shapr
06:21:12 <shapr> you said earlier that you have a haskell question, do you still have that question?
06:21:27 <BlizzNL> yep
06:21:36 <shapr> what is that question?
06:21:45 <BlizzNL> Do you know about anaphormisms and cataphormisms?
06:21:49 * Heffalump does
06:21:54 <norpan> me too!
06:22:00 <BlizzNL> Great ;)
06:22:08 <Heffalump> well, YM anamorphisms and catamorphisms.
06:22:09 <ChilliX> norpan: if I am not completely mistaken, GHCi uses dlopen() to load your Haskell modules already today
06:22:15 <Heffalump> but yeah, banana brackets and all that.
06:22:19 <BlizzNL> I am kinda new to Haskell but pretty exited about it
06:22:21 <norpan> ChilliX: ghci uses severe magic
06:22:25 <ChilliX> norpan: I don't see any reason why a C program wouldn;t be able to do that
06:22:33 <ChilliX> norpan: true
06:22:44 <BlizzNL> Ok here it comes:
06:22:49 <ChilliX> BUT only because there Haskell functions are not foreign exported
06:22:50 <BlizzNL> type List_ana u x = u -> Either () (x, u)
06:22:50 <BlizzNL> list_ana :: List_ana u x -> u -> [x]
06:22:50 <BlizzNL> list_ana a = ana where 
06:22:50 <BlizzNL> 	ana u = case a u of
06:22:50 <BlizzNL> 		Left _ 		-> []
06:22:51 <BlizzNL> 		Right (x,y)	
06:23:08 <BlizzNL> This is the standard anamorphism, right?
06:23:25 <ChilliX> norpan: if you want to use the stuff from C, you need to foreign export it and then you can do away with quite some of the magic (I think, but I am quite sure)
06:23:53 <norpan> ChilliX: i already did all that and simon m said it couldn't be done because the elf dynamic linking mechanism is arcane
06:23:55 <Heffalump> so ghci opens .o files as shared objects?
06:24:08 <norpan> a.out: fatal error: LOOKS_LIKE_GHC_INFO- is incorrectly defined
06:24:14 <norpan> that's what I got
06:24:15 <Heffalump> BlizzNL: that sounds right
06:24:20 <BlizzNL> now, how do I define a list catamorphism that generates a list with all even number 
06:24:30 <Heffalump> all even numbered elements?
06:24:37 <Heffalump> that's not a catamorphism
06:25:00 <BlizzNL> for example something like my_ana_even 9, with the result : [8, 6, 4, 2]
06:25:20 <Heffalump> that's a list anamorphism
06:25:20 <ChilliX> Heffalump: I believe to remember from rummaging around in rts/Linker.c that it uses dlopen() to open the .o files
06:25:28 <Heffalump> ChilliX: right
06:25:43 <ChilliX> norpan: try asking andrep AT cse.unsw.edu.au about this
06:26:00 <BlizzNL> ow sorry I was confusing the two I mean anamorphism
06:26:29 <norpan> ChilliX: who is taht
06:26:35 <ChilliX> Andre Pang
06:26:48 <BlizzNL> normally I would do something like this : alleven n = filter even [1..n] ;-)
06:26:50 <Heffalump> blizzNL: you just want to make a function that given a number returns either Left () or Right (n,n-1)
06:26:54 <ChilliX> he recently did some plugin stuff with GHC for a project
06:27:01 <Heffalump> where n is the highest even number strictly less than the input number
06:27:02 <ChilliX> and he has some stuff running
06:27:17 <ChilliX> he loads the stuff in Haskell
06:27:35 <ChilliX> but I remember that he initially experimented with using foreign import and export
06:27:48 <ChilliX> and in the end, he got it working
06:28:00 <ChilliX> so, there must be some way to get C get access to the stuff
06:28:18 <BlizzNL> Heffalump: Yes indeed but I don't know how
06:28:26 <norpan> i've got everything compiled and linked, but get that run time error about LOOKS_LIKE_GHC_INFO-
06:28:43 <andersca> hi norpan
06:28:47 <ChilliX> no idea about that
06:28:56 <Heffalump> blizznl: have you made a start?
06:29:03 <ChilliX> I haven't played with it myself
06:29:10 <BlizzNL> yes wait a sec
06:29:37 <ChilliX> andre surely has the better overview over what might work and what won't
06:29:43 <BlizzNL> myeven = list_ana desctruct_myeven
06:29:55 <BlizzNL> destruct_myeven 0 = Left ()
06:30:09 <BlizzNL> destruct_myeven n = (n, n-1) 
06:30:26 <Heffalump> that won't work if you give it an odd number
06:30:43 <Heffalump> so just work out how to deal with odd numbers and deal with them separately
06:31:00 <BlizzNL> no that's true so I did :
06:31:01 <norpan> ChilliX: ok, i'll write him and say hello from you
06:31:06 <ChilliX> norpan: ok
06:31:36 <BlizzNL> destruct_myeven n | even n = Right(n, n-1)
06:32:17 <Igloo> [2,4..n] is much nicer than filter even [1..n] </tangent>
06:32:29 <BlizzNL> but this is where it's getting tricky, when it's odd I need to decrement the count(n) to keep iterating, but it keeps complaining about the type being incorrect etc.
06:32:50 <Heffalump> let me see the code?
06:33:29 <BlizzNL> Heffalump: I can't really because I was trying to simplify the question a bit by making you think it's about even and odd ;)
06:33:52 <BlizzNL> Heffalump: I't really a prime number generator  
06:34:38 <Heffalump> ok, show the code for that
06:36:27 <Heffalump> bah.
06:36:38 <Heffalump> I wish people wouldn't dive into private messages without asking me first.
06:36:51 <Heffalump> s/dive/paste 10s of lines/
06:38:02 <norpan> people have no manners nowadays :)
06:38:37 * tmoertel requires immediate coffee transfusion
06:40:28 <andersca> norpan E people
06:40:34 <andersca> therefore, norpan has no manners nowadays
06:41:39 <norpan> andersca `elem` people
06:42:50 <ChilliX> Ah, here he is
06:42:55 <ChilliX> o3: just talking about you
06:42:58 <o3> heh, i just got the email :)
06:43:02 <ChilliX> ic
06:43:03 <shapr> hi o3
06:43:08 <norpan> hi o3
06:43:08 <o3> hullo shapr
06:43:13 <o3> norpan :)
06:43:17 <shapr> we all want to hear about your ghc + linking experiences
06:43:18 <norpan> yes
06:43:24 <norpan> we are all anxious
06:43:29 <o3> erm
06:43:42 * shapr grins
06:43:44 <o3> hmm
06:43:58 <shapr> I'm interested in the dynamic linking thread from ghc-users
06:44:05 <o3> i really need to put together a sample little program to demonstrate it
06:44:09 <shapr> yes please!
06:44:20 <shapr> I want to use haskell as a scripting language.
06:44:36 <shapr> I'm also interested in runtime loading of modules for a haskell webserver
06:44:52 <o3> crikey, that sounds like what i'll need to do for my thesis :)
06:45:06 <Heffalump> what's your thesis about?
06:45:16 <o3> Heffalump: writing a wiki in haskell
06:45:20 <shapr> I know that erlang can do runtime upgrading of code, I'd like to see haskell do it also.
06:45:28 <BlizzNL> -- list anamorphism
06:45:28 <BlizzNL> type List_ana u x = u -> Either () (x, u)
06:45:28 <BlizzNL> list_ana :: List_ana u x -> u -> [x]
06:45:28 <BlizzNL> list_ana a = ana where 
06:45:28 <BlizzNL> 	ana u = case a u of
06:45:29 <BlizzNL> 		Left _ 		-> []
06:45:31 <o3> ChilliX: will you object if I use the name "hicky"? ;)
06:45:32 <BlizzNL> 		Right (x,y)	-> x : ana y
06:45:39 <Heffalump> lol
06:45:41 <shapr> o3: you're writing a HaskellWiki in Haskell?
06:45:54 <shapr> um, hicky has some unusual connotations in america
06:46:03 <o3> shapr: i know ;)
06:46:05 <Heffalump> I think that was his point :-)
06:46:07 <shapr> oh ok =)
06:46:12 <shapr> but um..
06:46:18 <shapr> no, never mind
06:46:20 <BlizzNL> How can I define a function which generated prime numbers on this one? (primegen = list_ana destruct_priemgen)
06:46:28 <o3> erm, who was the guy who asked about the dynamic linking?  that's you, shapr?
06:46:33 <norpan> me me me
06:46:43 * Heffalump , norpan and shapr are all interested in it
06:46:44 <shapr> o3: originally Heffalump many months ago, today it's norpan
06:47:00 <Heffalump> blizznl: so you want to start from 2 and work up?
06:47:21 <o3> oh, right.  hmm, i guess i really underestimated the value of all that dynamic linking stuff then
06:47:23 <o3> okay
06:47:29 <Heffalump> do you really need it to be an anamorphism? You can do it, but IMO it's not very natural.
06:47:36 <BlizzNL> yeah work up to a given n so : primegen 9 results in [7,5,3,2]
06:47:37 <norpan> well, i know it's possible under windows, i just need it under unix too
06:47:42 <Heffalump> oh, ok
06:47:52 <o3> norpan: how does it work in windows?
06:48:13 <andersca> what's "composite propositions"
06:48:32 <shapr> can't dynamic linking handle all of ["runtime upgrading","web server modules","haskell as a scripting language"] ?
06:48:39 <norpan> o3: there is a --mk-dll option to ghc
06:48:42 <shapr> or am I overestimating its power?
06:48:49 <o3> norpan: so it's just a standard dll, i see
06:48:50 <Heffalump> shapr: well, it's needed for all of those.
06:48:57 <Heffalump> you still need to write the code to do it :-)
06:49:01 <shapr> oh ok
06:49:26 <o3> a --make-me-a-webserver-module switch to ghc would be handy though :)
06:49:30 <o3> anyway
06:49:33 * shapr grins
06:49:41 <norpan> o3: i'm especially interested in what you've done, since simon m said what i want to do cannot be done :)
06:49:41 <shapr> o3: have you tried WASH-CGI ?
06:49:41 <ChilliX> o3: hicky?  I think I don't know the conotations shapr is aluding to
06:49:54 <o3> the dynamic linking stuff i've got at the moment is in a state of flux, since i'm trying to incorporate all of duncan's suggestions (from the ghc-users thread) into it
06:50:12 <Heffalump> chillix: love bite
06:50:13 <o3> ChilliX: i can demonstrate with you tomorrow what a hicky is, haha
06:50:16 <Heffalump> rotfl
06:50:24 <BlizzNL> Heffalump: Do you think it's possible (primegen)? If so can you give me a few pointers?
06:50:38 <Heffalump> blizznl: it's possible, you just need a function to decide whether something is a prime or not
06:50:42 <Heffalump> do you have one?
06:50:45 <shapr> I grew up in Alabama and Tennessee, in those places a hicky was a bruise on the neck usually given by that person's significant other
06:50:50 <BlizzNL> yes, wait
06:50:56 <ChilliX> shapr: ic
06:51:11 <Heffalump> ok, so use that like you did with the even stuff above
06:51:18 <ChilliX> o3: in this case, I do not object
06:51:32 <Heffalump> ChilliX wants o3 to give him a hicky?
06:51:40 <BlizzNL> dividable :: Int -> Int -> Bool
06:51:40 <BlizzNL> dividable a b = a `rem` b == 0
06:51:40 <BlizzNL> dividers :: Int -> [Int]
06:51:40 <BlizzNL> dividers x = filter (deelbaar x) [1..x]
06:51:40 <BlizzNL> prime :: Int -> Bool
06:51:40 <BlizzNL> prime x	= dividers x == [1, x]
06:51:50 <ChilliX> Heffalump: tststs, I don't object against calling the Haskell Wiki that
06:51:51 * tmoertel wonders what the "hicky project" logo would look like?
06:52:01 <ChilliX> tmoertel: well, that's petty clear
06:52:08 <shapr> tmoertel: you've been drafted to make it =)
06:52:11 <Heffalump> chillix: just checking :-)
06:52:20 <ChilliX> Heffalump: :-P
06:52:30 <shapr> um, wouldn't a piece of software named hicky be like saying "we suck" ?
06:53:17 <o3> ChilliX: phew, you worried me for a second
06:53:29 <BlizzNL> if I do something like this : 
06:53:30 <BlizzNL> priemgen = list_ana destruct_priemgen
06:53:30 <BlizzNL> destruct_priemgen 0 = Left ()				    
06:53:30 <BlizzNL> destruct_priemgen n | priem n = Right (n, n-1) 
06:53:30 <BlizzNL> 		    | otherwise Right(0, n-1)
06:53:43 <BlizzNL> This is almost correct, except for the zeros
06:54:09 <o3> erm
06:54:20 <BlizzNL> I need it to otherwise skip and decrement n but it NEEDS to add something to the list..
06:54:23 <o3> so who emailed me about the dl stuff?  norpan?
06:54:32 <Heffalump> blizznl: ok, so try making a recursive call to destruct_primegen
06:54:49 <o3> shapr, Heffalump, can you guys email me too?  i'll send out an email in the morning, i'll do a sample little program tonight with the newest RuntimeLoader module
06:55:00 <shapr> awesome
06:55:17 <Heffalump> andrep@cse.unsw.edu.au ?
06:55:35 <o3> yep
06:55:42 * jewel frowns at quoting email address in a logged channel
06:56:02 <shapr> hi jewel
06:56:11 <jewel> hello shapr
06:56:24 <shapr> yah, notice how ChilliX did it earlier, he use usernam AT hostname
06:56:39 <Heffalump> oh, sorry.
06:56:49 <o3> jewel: that's okay, i like getting special zoo offers anyway
06:57:01 * shapr grins
06:57:15 <shapr> hey, we should do our own Bayesian spam filter for a weekend project.
06:57:22 <Heffalump> I think spambots tend to look for mailto HREFs though
06:57:37 <shapr> I have 213 spam mails handy, anyone else collecting them?
06:57:42 <o3> shapr: esr already beat you to it
06:57:56 <shapr> in Haskell?
06:57:57 <Heffalump> I've got about 1800 since I started running spamassassin about 2 months ago
06:58:01 <jewel> I get these weird marijuana ones
06:58:08 <shapr> Heffalump: wow, you get lots more spam than I do
06:58:23 <Heffalump> I know people who get about 10 times as much as I do.
06:58:38 <Heffalump> most of mine gets trapped by spamassassin though, which is good
06:58:46 <BlizzNL> Heffalump: Thnx now it works!
06:58:52 <ChilliX> most of my spam is from haskell AT haskell.org ;-)
06:58:56 * shapr grins
06:58:59 <o3> Heffalump: i don't suppose their email address is webmaster AT cnet.com or something
06:59:07 <ChilliX> no, not true, more from the gnome lists
06:59:50 * Heffalump runs his list email through spamassassin too, which helps
07:00:10 <o3> Heffalump/slapr/norpan: i'll try to finish it by the morning.  (erm, that's in about 10 hours' time :)
07:00:11 <shapr> I have a gnus filter
07:00:52 <Heffalump> o3: cool :-)
07:01:09 <shapr> yay
07:03:08 <norpan> o3: thanks alot"!
07:03:22 <o3> i'll do my best
07:03:34 <o3> yeah, i don't have to be up until about 9:30.  should be possible :)
07:04:01 <shapr> o3: yes, many thanks.
07:04:01 * Heffalump wonders what the status of mod_haskell (http://losser.st-lab.cs.uu.nl/mod_haskell/) is
07:05:35 <o3> shapr: oh, i've had a look at WASH, but haven't really tried it
07:05:43 <o3> i'll have to play with it soon, though
07:06:32 <shapr> it doesn't compile with ghc5.04 but does with ghc5.04.1 or with ghc5.02
07:07:08 <Heffalump> is .1 out?
07:07:13 <shapr> I don't think so.
07:13:08 <shapr> Simon PJ says that .1 is imminent though.
07:13:17 <o3> Heffalump: do you know if there's a Haskell CGI module around?
07:13:22 <o3> (like CGI.pm for perl)
07:14:50 <Heffalump> umm
07:15:11 <Heffalump> yes, there is, because I've used one.
07:15:14 <norpan> Erik Meijer has a CGI library
07:15:15 * Heffalump --> look at what is code does.
07:15:17 <Heffalump> that's the bunny.
07:15:42 <Heffalump> % Original Version by Erik Meijer <erik@cs.ruu.nl>
07:15:42 <Heffalump> % Further hacked on by Sven Panne <Sven.Panne@informatik.uni-muenchen.de>
07:16:25 <o3> thanks
07:16:29 <o3> wow, another microsoftian
07:16:43 <Heffalump> he moved there about 18 months ago
07:17:04 <Heffalump> he's not in MSR though
07:18:54 <Heffalump> it would be nice for a CGI library to move into hslibs.
07:54:54 <BlizzNL> What's up with this Erik Meijer ? His name seems to popup everywere I look, lately
07:55:00 <Heffalump> like where?
07:55:25 <Heffalump> he did quite a lot of anamorphism/catamorphism type research
07:55:32 <Heffalump> which may be why you keep running into him
07:55:34 <BlizzNL> Ahh ;)
07:55:44 <BlizzNL> You see I was looking into those ;)
07:56:02 <BlizzNL> Heffalump: BTW He is also connected to my university (www.cs.uu.nl)
07:56:16 <Heffalump> yeah
07:56:18 <Heffalump> well, he left
07:56:58 <Heffalump> my boss was at UU about 15 years ago
07:57:34 <BlizzNL> ahh but there are still a lot publication he wrote as lecture material
08:10:14 <BlizzNL> This Haskell seems to be a very powerfull language. Now I slowly begin to understand why my professors like it so much
08:11:34 <shapr> it is a very powerful language
08:12:38 <Heffalump> I think I'd use the word "expressive" rather than "powerful"
08:13:30 <jadrian> hello
08:13:40 <shapr> hi jadrian
08:13:40 <Heffalump> hiya
08:14:25 <shapr> cool, 30 unique users on the channel
08:14:34 <shapr> we're still growing :-)
08:14:49 <Heffalump> wow, yes
08:15:21 <shapr> yay
08:15:25 <BlizzNL> Quite some inactive users too                        
08:15:25 <jadrian> yeap :)
08:15:43 <jadrian> so *I* was number 30 right? :)
08:15:56 <shapr> do you think we've reached the stable conversation point? should I advertise on the haskell list now?
08:16:13 <BlizzNL> 30 users is great. Channels with over 50 users start to be annoying
08:16:30 <shapr> so far, the #haskell users have been rather different.
08:16:41 <jadrian> do I get some sort of prize?
08:16:45 <jadrian> is it possible to declare something like this?
08:16:45 <shapr> the average Haskell user is... well, not average.
08:17:02 --- topic: set to 'ICFP 2002 Robot Analysis and Visualization Toolkit 0.8 http://tea.moertel.com/~thor/ravt/ || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || parr 0.2.3 released http://www.cse.unsw.edu.au/~chak/nepal/ || welcome jadrian! our 30th concurrent user! yay! we're growing!' by shapr
08:17:25 <shapr> gee, I wonder how large the topic can get.
08:17:49 <shapr> BlizzNL: I think this channel will be fun even with more than 50 users.
08:18:23 <BlizzNL> shapr: We'll see in a week or two ;)
08:18:28 <shapr> I'd like to add some content to the HaskellIrcChannel wiki page, but it's broken :-/
08:18:36 <shapr> bah humbug
08:18:52 <Heffalump> once o3 writes hicky, they can change the haskell.org wiki over to it :-)
08:18:56 <shapr> yes!
08:19:08 <shapr> I wonder when he'll have a usable prototype
08:19:13 <BlizzNL> Can someone explain this rather strange construction from the Prelude? (repeat x = xs where xs = x:xs)
08:19:16 <shapr> that's something I'd like to hack on
08:19:30 <Heffalump> blizznl: it's a definition that means repeat x = [x,x,x,x,x,x,x,x,x,....]
08:19:35 <shapr> BlizzNL: it's for making an infinite list of one item
08:19:37 <norpan> BlizzNL: recursive definition
08:19:55 <BlizzNL> Heffalump. shapr, norpan : thnx ;)
08:20:04 <Igloo> It's slightly strangely written to make sharing more likely to happen I think
08:20:08 <Heffalump> it could say repeat x = x:repeat x but doing it that way reduces the space usage
08:20:26 <BlizzNL> ahh ok 
08:20:27 <Igloo> No, it increases space usage but decreases time
08:20:39 <Igloo> (I think)
08:20:46 <Heffalump> no, it decreases space usage
08:21:09 <Heffalump> the first definition will lead to a cons cell with the left hand pointer going to x and the right hand pointer going to itself
08:21:26 <Heffalump> the second would lead to as many cons cells being created as elements were used in the list
08:21:32 <Heffalump> (I think)
08:21:32 <Igloo> Oh, I was thinking of cycle
08:21:39 <shapr> hi Igloo!
08:21:43 <Igloo> Hi
08:21:47 * shapr throws snow
08:21:52 * Heffalump wants snow
08:21:56 <Igloo> Maybe I wasn't, actually
08:22:00 <Heffalump> though I quite like the nice sunny weather we have now
08:22:03 * shapr throws snow at Heffalump
08:22:22 <shapr> I'm wearing a long sleeved thick sweater at my computer :-/
08:22:35 <jadrian> type Ref  = forall s.STRef s 
08:22:35 <jadrian> I've can use univ. quant. in data structures like:
08:22:35 <jadrian> data T2 = Mk2
08:22:35 <jadrian>   { pos  :: forall s.STRef s Int}
08:22:39 <shapr> mid-finland == really cold most of the time
08:22:40 <jadrian> but I'm going to use lots of "forall s.STRef s" so it would be nice to be able to create a type synonim
08:22:41 <norpan> i like the following expression: let xs = 1:1:zipWith (+) xs (tail xs) in xs
08:22:42 <Igloo> No, I think that if you have repeat something_big the something_big will sit in memory due to sharing
08:22:44 <jadrian> BlizzNL: I'm trying to be active :)
08:22:57 <shapr> jadrian: dude, you're lagging
08:23:00 <andersca> norpan: nice
08:23:02 <andersca> norpan: fib?
08:23:07 <norpan> andersca: fibs, yes
08:23:40 <BlizzNL> jadrian: You are a valuable contribution to this channel ;)
08:24:03 <shapr> all new jadrian, with 75% less lag!
08:24:17 <jadrian_> back
08:24:17 <jadrian_> did you see my question? 
08:24:30 <Heffalump> igloo: what sharing?
08:24:44 <shapr> wow, *** Ping time to jadrian is 00:01.26
08:24:50 <jadrian_> yeap :)
08:24:54 <norpan> jadrian_: if anything you would have type Ref a = forall s.STRef s a
08:25:04 <shapr> only 14 seconds to "jadrian" ++ "_"
08:25:05 <norpan> but I don't think you can have forall in type synonyms
08:25:19 <jadrian_> so is there a reason for not allowing this kind of type synonim?
08:25:42 <norpan> probably :)
08:25:49 <Heffalump> well, the one you stated is partially applied, which are disallowed because it makes type inference undecidable IIRC
08:25:59 <Heffalump> I dunno about norpan's one
08:26:13 <jadrian_> norpan: yes I know you can't, I noticed that :)
08:26:18 <jadrian_> norpan: but I can't really see a reason why...
08:26:34 <Heffalump> ask on the list
08:26:40 <BlizzNL> Anyone who knows about Helium?
08:26:45 <norpan> I don't think there should be any reason, since type synonyms are just ... synonyms
08:26:54 <norpan> shouldn't make type checking any harder
08:27:19 <jadrian_> norpan: I just wanted to avoid allways writing  forall s.STRef
08:27:19 <jadrian_> there is a good motive for this.
08:27:26 <shapr> BlizzNL: the inert gas?
08:27:40 <norpan> jadrian_: i think I've seen it before and the only reason was that is wasn't so :)
08:27:45 <BlizzNL> shapr: No the new haskell interpreter
08:27:57 <shapr> never heard of it
08:28:14 <jadrian_> I may want to change forall s.STRef s to IORef
08:28:14 <shapr> http://www.students.cs.uu.nl/people/rjchaaft/jHaskell/
08:28:20 <shapr> whoa cool
08:28:25 <jadrian_> :(
08:28:50 <BlizzNL> shapr: exactly
08:29:12 <norpan> yikes powerpoint
08:29:13 <cleverdra> blech, Java.
08:29:20 <norpan> lets see if openoffice.org is up to the task
08:29:56 <BlizzNL> Arjan van IJzendoorn is one of my teachers and I'l be in the beta-program
08:30:03 <shapr> I used Jython very much
08:30:12 <shapr> er, I do use jython very much.
08:30:16 <jadrian> Heffalump: opss I just noticed your answer sorry!!
08:30:22 <andersca> me and norpan have had lectures by john hughes
08:30:24 <andersca> haven't we norpan
08:30:25 <shapr> JHaskell would make my life even more fun.
08:30:41 <norpan> andersca: yes we have, and lennart augustsson
08:30:43 <shapr> I'd very much like to have lectures with John Hughes
08:30:49 <shapr> and Augustsson too!
08:31:01 <andersca> norpan: I haven't had any with lennart
08:31:04 <Heffalump> I thought Lennart spent all his time on Sandburst these days
08:31:12 <jadrian> Heffalump: norpans one doesn't work either so that is not the motive
08:31:21 <norpan> Heffalump: yes, but he was at chalmers before
08:31:30 <jadrian> Heffalump: you simply cannot use foralls in type synonims
08:31:33 <norpan> he gave a lecture about cayenne
08:31:38 <Heffalump> jadrian: right, just ask on the list then
08:31:41 <andersca> norpan: the pepper?
08:31:47 <jadrian> Heffalump: still what I actually needed was partial application
08:31:50 <Heffalump> I've only met him once (at AFP3, when he talked about Cayenne)
08:31:52 <norpan> andersca: the haskell-like language
08:31:54 <jadrian> Heffalump: thanks I will
08:32:04 <Heffalump> jadrian: why did you need partial application?
08:32:21 <jadrian> Heffalump: I have a 'record' of State referencies
08:32:34 <andersca> norpan: is it possible to write a palindrome checker just by composing functions?
08:32:35 <jadrian> Heffalump: I wanted to avoid typing: forall s.STRef s
08:32:41 <andersca> norpan: instead of palindrome x = x == reverse x
08:33:15 <BlizzNL> I have a catamorphism I'm breaking my head over: 
08:33:16 <BlizzNL> type List_alg x u = (u, x->u->u)
08:33:17 <BlizzNL> list_cata :: List_alg x u -> [x] -> u
08:33:17 <BlizzNL> list_cata (a, f) = cata where
08:33:17 <BlizzNL> 	cata []		= a
08:33:17 <BlizzNL> 	cata (x:xs)	= f x (cata xs)
08:33:18 <jadrian> Heffalump: also if I had a type synonim  type Env = forall s.STRef s, I'd be able to easily change it to type Env = IORef
08:33:57 <BlizzNL> I need a function repeat n - like repeat 4 = [4, 4, 4, 4]
08:34:28 <BlizzNL> a working example : prod 	= list_cata (1, (*))
08:34:34 <Heffalump> but type Env a = forall s.STRef s a
08:34:37 <Heffalump> will also do that for you
08:34:41 <Igloo> Heff: The x will stay in its fully evaluated form after you've looked at it once
08:35:38 <jadrian> Heffalump: of course!...
08:35:41 <Heffalump> igloo: hmm, true
08:35:46 <BlizzNL> ow damn I am confusing the again. I mean a anamorphism ofcourse
08:35:50 <jadrian> Heffalump: I wonder why I didn't think of that...
08:36:12 <Heffalump> actually, what you were trying to write probably doesn't make sense
08:36:18 <Heffalump> cos when you applied it to something and expand, you get
08:36:24 <Heffalump> Env a = (forall s.STRef s) a
08:36:39 <Heffalump> and that rhs isn't the same as (forall s.STRef s a), I don't think
08:36:54 <jadrian> Heffalump: I wonder why that works and my definition doesn't...
08:36:58 <Igloo> I think I had this problem at one point with concat replicate 10 $ replicate 10000 x running out of RAM but with the numbers the other way round it working fine
08:37:10 <jadrian> Heffalump: I can use   type A = IORef   or  type A a = IORef a    right?
08:37:16 <Igloo> FSVO 10000
08:37:28 <Heffalump> jadrian: what works?
08:37:40 <Heffalump> no, you can't use the former, partially applied type synonyms aren't allowed
08:37:47 <Heffalump> (AIUI)
08:37:49 <Heffalump> oh, hangon
08:38:03 <Heffalump> it's *using* them partially applied that isn't allowed, I think
08:38:05 <jadrian> Heffalump: right!
08:38:34 <Heffalump> igloo: hmm, ok
08:38:42 <dennisb> I think Augustsson is still att chalmers, it's just that he works 0% at the moment .-)
08:38:50 <andersca> dennisb: just like you? :)
08:38:51 <jadrian> Heffalump: yes... that is right :)
08:38:52 <norpan> hi dennisb!
08:38:54 <dennisb> yes
08:39:01 <andersca> dennisb: I'll come visit some day
08:39:06 <jadrian> Heffalump: both of those declarations (IORef ones) are correct
08:39:15 <Heffalump> right
08:39:44 <jadrian> Heffalump: that's why I was nto understanding why the ST one didn't work. That's it, I'm still not used to think with univ. quatifiers
08:39:51 <dennisb> andersca: well, make an appointment
08:39:59 <andersca> dennisb: now?
08:40:06 <andersca> dennisb: you can teach me about monads
08:40:14 <dennisb> no, but if you want to be sure to find me :-)
08:40:49 <dennisb> most of the time when I'm there it's because I have meetings and stuff that forces me to be there
08:41:02 <andersca> so you're at home now?
08:41:09 <dennisb> andersca: monads is simple
08:41:13 <dennisb> yes
08:41:35 <jadrian> Well I'm out, have fun!
08:41:35 <jadrian> Thanks Heffalump!!
08:41:42 <dennisb> just got home from chalmers, had a haskell course to teach from 15 today!
08:41:49 <andersca> which one?
08:42:06 <dennisb> for the international masters program
08:42:12 <BlizzNL> where is chalmers?
08:42:19 <shapr> gotheburg
08:42:25 <andersca> dennisb: ah
08:42:35 <BlizzNL> skylan: thnx
08:42:49 <shapr> BlizzNL: close to the southern tip of sweden
08:42:52 <dennisb> well, now i'm going to get something to eat..  you can't survive only on combinators..
08:42:59 <shapr> heh
08:43:02 <shapr> hi dennisb!
08:43:03 <shapr> bye!
08:43:07 <dennisb> bye
08:45:19 * BlizzNL is going to get something to eat too, later
08:45:28 <sethk> All, thanks for the answer earlier, and a quick question?
08:46:03 <sethk> I am creating my FiniteMap, which works but I don't have the return type I need for this function...
08:46:37 <sethk> addToMap fmap (l:ls) = addToFM fmap (l !! 14) l >> addToMap fmap ls
08:46:49 <sethk> The return type is m ()
08:46:55 <sethk> (that is, monad ())
08:47:09 --- mode: card.freenode.net set +o ChanServ
08:47:15 <sethk> but I want the return type to be FiniteMap key elt
08:47:56 <sethk> fmap is passed in to the first call as emptyFM
08:48:10 <ibid> why do you need a monad there?
08:48:37 <sethk> Not sure that I do, but it is called from a monadic main()
08:48:57 <ibid> monadic functions can call non-monadic functions
08:49:07 <ibid> it's the other way around that presents a problen
08:49:13 <Heffalump> try addToMap fmap (l:ls) = addToFM (addToMap fmap ls) (l!!14) l
08:49:24 <Heffalump> and addToMap fmap [] = fmap
08:49:36 <sethk> OK...
08:49:48 <Heffalump> though I'm sure addListToFM or similar exists
08:50:25 <ibid> Heffalump: unless he is writing the fm code himself (dunno if he is, i just got that impression...)
08:50:40 <sethk> Yes, but it isn't a simple list, it is a list of Elements (the one you suggested "deriving Eq" about)
08:50:51 <sethk> No, not trying to write my own FiniteMap
08:51:17 <Heffalump> ok
08:51:19 <o3> ld can take a looooong time to run
08:51:31 <sethk> and I'm trying to make a map of the 14th element of the list, not the entire list
08:51:35 <shapr> o3: on what hardware?
08:51:36 <Heffalump> the reason for that was discussed on ghc-users, wasn't it?
08:51:43 <sethk> the 14th element on a list of lists, that is
08:51:43 <o3> shapr: 500mhz celeron
08:51:46 <shapr> oh
08:51:51 <o3> it's taking 4 minutes to link this :)
08:52:09 <sethk> I added RAM to my box which helped a LOT on the ld time.
08:52:24 <o3> i'm not hitting disk at all
08:52:31 <o3> it's just taking ages to resolve all the symbols
08:53:45 <o3> well bugger me, this little example worked
08:53:50 <shapr> yay
08:54:19 <Heffalump> hmm, so o3 wants us to bugger him as well as wanting to give ChilliX a hicky?
08:54:46 <sethk> Heffalump, with your suggestion I get "couldn't match `FiniteMap a elt' against `elt -> FiniteMap a elt'
08:54:48 * o3 whistles
08:55:01 <Heffalump> sethk: I've probably got an extra argument or missed out an argument somewhere
08:55:19 <Heffalump> but I'm too lazy to work out which :-)
08:55:55 <sethk> OK, I'll play with it...
08:57:55 <o3> hmm, this is dirty as hell
08:57:59 <o3> ah, stuff it, it's only an example
08:58:05 * o3 does documentation
09:00:04 <sethk> We need an element argument to addToFM, I think we gave it only the key...
09:00:24 * Heffalump gave it an element, it was the final "l" in what I said
09:00:46 <sethk> I guess I missed it (time for new glasses)...
09:01:02 <Heffalump> :-)
09:01:35 <tmoertel> hash-haskell guys: check out http://tea.moertel.com/~thor/ravt/examples/skipperdee-vs-postman-venice.html (something tomas rokicki (of team radical too) built on top of RAVT)
09:03:06 <shapr> coool
09:03:30 <Heffalump> nice
09:03:35 <Heffalump> what's Postman doing stuck in that corner? :-(
09:03:39 <shapr> he got flushed
09:03:43 <Heffalump> oh, got pushed
09:03:43 <jewel> that bastard
09:04:01 <sethk> OK, I think I have my FiniteMap, and I'm trying to print itout, and it barfs on (show fmap) (No instance for (Show FiniteMap Element [Element])) arising from use of `show' .....)
09:04:01 <shapr> he killed postman!
09:04:10 <tmoertel> right now, a robot's loc gets set to (0,0) when it dies
09:04:13 <sethk> I have 'deriving Show' for Element...
09:04:17 <Heffalump> oh my god, they killed Postman!
09:04:21 <shapr> you bastards!
09:04:24 <tmoertel> we're working on improvements to the html visualizer, so it ought to get better
09:04:29 <shapr> um, hi user303
09:04:37 <tmoertel> jewel: did you ever get RAVT to build?
09:04:44 <Heffalump> sethk: I don't think FiniteMap has a show instance, you'll have to make one
09:05:04 <jewel> tmoertel: I don't recall, I don't think so
09:05:05 <shapr> hello user303, looking for Haskell help?
09:05:18 <tmoertel> Heffalump: correct no show for FM
09:05:21 <Heffalump> something like instance Show FiniteMap where show = show.fmToList
09:05:25 <Heffalump> would probably do for you
09:05:37 <Heffalump> oh, instance Show FiniteMap key elt where ....
09:05:44 <Heffalump> add brackets somewhere sensible
09:05:46 <Heffalump> and probably a newline
09:06:29 <sethk> You are composing "show" and "fmToList"?
09:06:31 <tmoertel> jewel: do you recall how the build failed?
09:06:40 <jewel> tmoertel: just a sec
09:06:42 <Heffalump> sethk: yes
09:06:58 <Heffalump> you could just do that manually instead of bothering with the Show instance, of course
09:07:00 <o3> is there a file parsing thingie in the standard haskell library?
09:07:04 <o3> like the basename/dirname commands in unix
09:07:10 <o3> filename parsing thingy, i mean
09:07:24 <shapr> o3: try GHC's Directory module
09:08:09 <o3> shapr: doesn't have one :(
09:08:11 <Heffalump> o3: doesn't look like there's one in standard haskell
09:08:38 <o3> ok, i'll just be lazy then
09:09:02 <o3> ah, this is cool
09:09:14 <o3> my example program is just a crappy text filter program
09:09:25 <o3> i have three modules, one does uppercase, one does lowercase, one does rot13
09:09:44 <o3> and i just realised rot13 doesn't compiled because chr and ord are hugs-specific, grr
09:10:36 <cleverdra> uc = do getLine >>= \s -> putStrLn . map (toLower) $ s; uc
09:10:41 <sethk> When I added some code to show the map, I got an error where the map is constructed.  Is this because of lazy evaluation (the map wasn't actually constructed before I showed it)?
09:10:44 <shapr> o3: http://www.haskell.org/ghc/docs/latest/html/base/System.Directory.html
09:10:46 <cleverdra> Of course, that's not pretty on EOF.
09:10:54 <Heffalump> sethk: possibly, yeah
09:11:17 <shapr> hm
09:11:18 <Heffalump> shapr: that doesn't do it
09:11:57 <shapr> yah, I just realized that :-/
09:12:03 <shapr> f00
09:12:46 <cleverdra> Heffalump - curiously, what do you want it for?
09:12:53 <Heffalump> cleverdra: want what?
09:13:19 <cleverdra> Hefflump - err, not you; o3
09:13:24 <Heffalump> if you mean dynamic loading, I'd like to be able to dynamically load compiled Haskell code into a webserver.
09:13:28 <Heffalump> ah :-)
09:13:53 <shapr> Heffalump: would runtime upgrading be comparable to webserver modules?
09:14:23 <Heffalump> I'm not entirely sure what you mean by runtime upgrading. Do you mean like what Erlang does (which I know nothing about)?
09:14:33 <shapr> yah, pretty much
09:14:45 * shapr thinks about it
09:14:52 <shapr> there actually are differences
09:15:11 <Heffalump> I dunno if Erlang provides better support for communicating data structures from one version to the next
09:15:28 <shapr> webserver modules can be sure that all older instances will removed from the running program before the new module version is loaded
09:15:30 <shapr> good question
09:15:37 <jewel> tmoertel: you have a lot of spare time?
09:16:11 <tmoertel> jewel: not a whole lot, but I make the most of what I have
09:16:23 <o3> shapr/heffalump/norpan: do you guys have automake 1.6?
09:16:58 <shapr> I do now.
09:17:07 <shapr> apt-get install automake1.6
09:17:34 <o3> ok, good
09:17:36 <o3> you'll need it for this
09:17:47 <shapr> spiffy!
09:17:57 <cleverdra> Hefflalump - I don't quite understand what you mean by that; one version of a module to the next?  One version of Erlang to the next?  It would be simple to have a server restart itself, passing sockets and various data (if that's what you mean).
09:18:15 <Heffalump> cleverdra: I dunno what Erlang does.
09:18:19 <shapr> cleverdra: nah, it's like upgrading a class that's been loaded into a JVM
09:18:26 <shapr> that's what I'm thinking of
09:18:29 <Heffalump> but I'd heard it supports dynamically upgrading running Erlang programs module-by-module
09:18:41 <shapr> I've heard that also.
09:18:41 <cleverdra> shapr - I'm familiar with Erlang; I have absolutely no idea what you refer to is like.
09:19:01 <cleverdra> Heffalump - yeah; there's not much to that:  c(foo)
09:19:10 <shapr> erlang can upgrade running programs
09:19:22 <shapr> that much I'm sure of...
09:19:25 <shapr> dunno how it does it though
09:19:32 <Heffalump> c(foo) ?
09:20:21 <cleverdra> Hefflaump - in an Erlang shell, that's a convenience function for: compile and load module 'foo'
09:21:06 <Heffalump> ah
09:21:12 <Heffalump> but if foo is already running, what happens to it?
09:21:59 <cleverdra> Heffalump - modules don't run.  A typical process in a loop/? that calls itself would be calling the new loop/? in its next iteration.
09:22:53 <Heffalump> right
09:23:02 <Heffalump> so all state is passed in the parameters?
09:23:29 <BlizzNL> I am still working on list anamorphisms and this time I need one that creates a list with n element of n.
09:23:36 <BlizzNL> For example : 'repeatn 3' results in [3, 3, 3].
09:23:42 <BlizzNL> Ofcourse I use the default anamorphism:
09:23:50 <cleverdra> Heffalump - except for process-dictionary state, which won't be affected, and for ets/mnesia &c -- state which is held by other processes.
09:23:53 <BlizzNL> type List_ana u x = u -> Either () (x, u)
09:23:53 <BlizzNL> list_ana :: List_ana u x -> u -> [x]
09:23:53 <BlizzNL> list_ana a = ana where 
09:23:53 <BlizzNL> 	ana u = case a u of
09:23:53 <BlizzNL> 		Left _ 		-> []
09:23:54 <BlizzNL> 		Right (x,y)	-> x : ana y
09:24:06 <BlizzNL> so:
09:24:06 <BlizzNL> repeatn	= list_ana destruct_repeatn
09:24:06 <BlizzNL> destruct_repeatn 0 = Left ()
09:24:06 <BlizzNL> destruct_repeatn n = ?? 
09:24:06 <BlizzNL> The problem is I need some kind of counter to accomplish this I think
09:24:18 <Heffalump> blizznl: please stop pasting the list_ana function, I know the definition :-)
09:24:42 <BlizzNL> Heffalump: Hehe ok ;) But it's a good excercise for me :)
09:24:42 <Heffalump> blizznl: just add an extra parameter to destruct_repeatn
09:27:47 <BlizzNL> Heffalump: I get a type error because it's nog a Either anymore
09:29:23 <Heffalump> you'll have to make repeatn n = list_ana (destruct_repeatn n) n
09:29:31 <Heffalump> it won't be possible otherwise, I think
09:30:33 <BlizzNL> Ok I'll try it.. May I ask where your ana-catamorphism knowledge comes from? A paper or something? (because I want to look into the subject)
09:30:48 <Heffalump> umm
09:30:53 <Heffalump> I can't really remember
09:31:03 <BlizzNL> Are you that old :)
09:31:05 <Heffalump> possibly partly from AFP3
09:31:18 <Heffalump> no, but I've been exposed to them quite a bit from different places
09:31:44 <BlizzNL> Ahh ok.. Do you know Sorting Morphisms by Lex Augusteijn?
09:31:52 <Heffalump> I was just about to recommend exactly that :-)
09:31:59 <BlizzNL> hehe ;)
09:32:12 <Heffalump> it's probably the first place I saw them
09:32:22 <BlizzNL> computer science research isn't that big
09:33:42 <Heffalump> Sorting Morphisms is in LNCS 1608 (and probably on Lex's homepage)
09:34:39 <BlizzNL> What's LNCS 1608?
09:34:54 <Heffalump> there's some more hard-core theory in "Generic Programming - An introduction" by Backhouse, Jansson, Jeuring and Meertens, also in that LNCS
09:34:59 <Heffalump> Springer Lecture Notes in Computer Science
09:35:03 <Heffalump> (number 1608)
09:35:18 <BlizzNL> Jearing is my professor ;)
09:50:46 <BlizzNL> Heffalump: Can you help me out with that stupid repeatn (which is an exercise(#3) from LNCS 1608). It really pisses me of when I am working on a new language and I turn into a newby again. I don't hope to stay one very long.. 
09:51:38 <Heffalump> what page number?
09:52:02 <BlizzNL> page number 6 on top
09:52:43 <Heffalump> that appears to be talking about list hylomorphisms
09:53:04 <BlizzNL> the hylomorphism is a combination of ana and cata
09:53:54 <BlizzNL> so the answer is xn = list_hylo (destruct_repeatn, (1, (*)))
09:54:24 <Heffalump> I still don't see an exercise that wants a function that generates [3,3,3] from 3
09:55:12 <BlizzNL> well, 'Exercise 3: write the xb function as a list hylomorphism'. 
09:56:53 <Heffalump> x^n ?
09:57:05 <BlizzNL> I thought well 'x to the power n' can be solved using the list_hylo mentioned above 
09:57:10 <BlizzNL> x^n exactly
09:57:38 <Heffalump> presumably it wants to make [x,x,x,x....x] and then fold * over it
09:58:13 <BlizzNL> yes ofcourse that's where xn = list_hylo (destruct_repeatn, (1, (*))) comes in
09:59:26 <Heffalump> OIC.
09:59:34 <Heffalump> but you don't want repeatn the way you described
09:59:56 <BlizzNL> ow why not?
10:00:41 <Heffalump> because what you described has repeatn 3 = [3,3,3] , repeatn 4 = [4,4,4,4], AFAICT
10:00:50 <Heffalump> you need something that takes two arguments, x and n
10:01:01 <Heffalump> and has repeatn 3 5 = [3,3,3,3,3]
10:01:32 <BlizzNL> ow yes ofcourse you are absolutely right
10:06:36 <cleverdra> repeatn _ 0 = [] -- repeatn x n = [x|repeatn x n-1]
10:08:09 <Heffalump> he wants it expressed as an anamorphism (unfold)
10:08:34 <cleverdra> I'll have to look that up.
10:13:08 <BlizzNL> -- repeat 3 5 ==> [3,3,3,3,3]
10:13:08 <BlizzNL> repeatn x n = list_ana (destruct_repeatn n) x
10:13:08 <BlizzNL> destruct_repeatn _ 0 = Left ()
10:13:08 <BlizzNL> destruct_repeatn x n | n > 0  = Right(x, n-1)  
10:13:37 <Heffalump> yep.
10:13:41 <BlizzNL> But the interpreter says it has no 'show' function
10:13:46 <Heffalump> for what?
10:14:08 <BlizzNL> ERROR - Cannot find "show" function for:
10:14:08 <BlizzNL> *** Expression : repeatn 3
10:14:08 <BlizzNL> *** Of type    : a -> [a] 
10:14:58 <Heffalump> give it another parameter
10:15:00 <cleverdra> err, you need to supply all the arguments.
10:15:10 <cleverdra> repeatn 3 -- is a curried function
10:15:51 <BlizzNL> ahh damn I'm getting sloppy
10:16:41 <sethk> All, when I see a "Non-exhaustive patterns in case" message, is there any way to get information on the data that failed to match the pattern?
10:17:15 <Heffalump> hmm, not as far as I know
10:17:24 <Heffalump> paste your patterns here if you want
10:17:46 <cleverdra> a backtrace would be more productive, I think.
10:18:10 <sethk> The backtrace, unfortunatley, is empty.
10:18:28 <sethk> I'll get the patterns...
10:18:43 <Heffalump> the Non-exhaustive patterns message is a compiler warning, not a runtime error
10:19:45 <sethk> Then, why do I see it with one input file (it's a Happy parser) but not with another?
10:19:59 <cleverdra> Oh, sorry.  I was thinking of Erlang, where it sometimes makes sense to be nonexhaustive (because anything else would be an error, anyway).
10:20:01 <Heffalump> oh, right, sorry
10:20:14 <Heffalump> so it is a runtime error, I'm just confused
10:20:33 <Heffalump> the way to sort that out is to look out for the compiler warnings about non exhaustive patterns, and fix them all
10:20:47 <Heffalump> if necessary just by adding cases that give informative error messages
10:21:06 <sethk> I thought of that, but I can't figure out how to print a string from within the lexer
10:21:23 <Heffalump> if your program is going to abort anyway, just use 
10:21:25 <o3> yay
10:21:25 <Heffalump> error "foo"
10:21:31 <Heffalump> that has type a, so can go anywhere
10:21:36 <sethk> OK...
10:21:38 <o3> example nearly finished
10:21:43 <Heffalump> and if it gets evaluated your program just aborts
10:23:03 <sethk> A bit more confusion:  I added an "otherwise" case with error, and now the program runs.  The error case never executes.
10:23:20 <sethk> guard, not case...
10:23:51 <Heffalump> interesting...
10:24:44 <sethk> Obviously, with an otherwise, there is no non-exhaustive pattern, but I don't understand why it works with the first input file without the otherwise
10:25:58 <o3> ===============================================
10:25:58 <o3> TextFilter-1.0.tar.gz is ready for distribution
10:25:58 <o3> ===============================================
10:26:00 <o3> werd :)
10:26:03 <Heffalump> o3: nice
10:26:12 <Heffalump> sethk: well, how about the second file that caused the error?
10:26:21 <Heffalump> or was it the first file that caused the error?
10:27:18 <sethk> The second; unfortunately the second has 33000 records, so I'll have to try and spot a pattern...
10:32:52 <o3> norpan/Heffalump: email sent
10:34:05 * Heffalump grabs
10:34:48 <o3> i'll stay on for another 20 minutes or so
10:35:29 <Heffalump> some warnings when compiling with ghc 5.04
10:35:35 <Heffalump> (just checking that they're expected)
10:35:47 <Heffalump> I think it's got to linking :-)
10:36:01 <o3> yeah, they're expected
10:36:09 <o3> i hope you read the README :)
10:36:54 <Heffalump> oh. no. :-)
10:36:58 <o3> haha
10:37:04 <Heffalump> I spied configure and dived straight into ./configure and make
10:37:19 <o3> otherwise you'll probably be thinking "err, what do i do now?" after the make :)
10:37:23 <Heffalump> oh, I should have done cd src before make.
10:37:28 <o3> doesn't really matter
10:37:30 <Heffalump> oh, I'd have looked at it then
10:37:51 <Heffalump> I hope you don't fail your compilers assignment :-)
10:38:10 <o3> ;)  better not, or i'll commit harikari
10:38:11 <cleverdra> Heffalump - what platform are you compiling to?
10:38:20 <Heffalump> linux i386
10:38:25 <Heffalump> (Redhat 7.3, ghc 5.04)
10:38:29 <cleverdra> Heffalump - if you succeed at all in that, please tell me =)
10:38:45 * Heffalump would imagine it's not dissimilar to what o3 uses
10:38:57 <cleverdra> Heffalump - I get SIGINT's, eventually.
10:39:15 <Heffalump> oh, your computer must be faster than mine :-)
10:39:23 * Heffalump is using a PIII-700, and it's still linking
10:39:47 <Heffalump> it seems to have finished building ok
10:40:07 <o3> no, it takes 4 minutes to link on my little machine
10:40:20 <Heffalump> I meant cleverdra's
10:40:35 <Heffalump> all seems to work fine for me
10:41:01 * Heffalump --> read the source
10:41:30 <o3> i like it how the plugins are so tiny (source-code wise)
10:41:39 <o3> i mean, hey, it is really simple, but still :)
10:44:47 <o3> cleverdra: what fails for you?
10:48:29 <o3> any other comments before i head off to bed?
10:50:08 <Heffalump> not from here, except that it looks nice
10:50:45 <o3> cool
10:51:14 <o3> well, that was a productive evening
10:51:21 <Heffalump> thank you very much :-)
10:51:37 <o3> tis okay, i've been meaning to do that for a while anyway
10:51:42 <o3> you guys just sped up the process :)
10:52:07 <o3> okay, night then!
10:52:20 <Heffalump> night
10:52:47 <Heffalump> if you're still around, what is the difference between a .o file and a .so file?
11:55:56 <Heffalump> 'lo
11:55:59 <shapr> hi
11:56:41 * shapr reads the runtime loader from o3
11:58:12 <shapr> neet stuff
12:06:15 <shapr> cool
12:06:49 <shapr> now I want hIDE to use that
12:06:55 <shapr> so I can script my editor with Haskell.
12:11:01 <Heffalump> heh
12:11:47 <Lunar^> Hi
12:12:04 <Heffalump> hi
14:40:19 <jemfinch> so only functions that accept typeclasses pay the cost for them, right?
14:40:48 <Heffalump> where "accept" = have them in the type
14:40:49 <Heffalump> yes
14:40:55 <jemfinch> ok, cool.
14:41:27 <jemfinch> so I can write a function that is at first generic, using a typeclass, and later specialize it to a specific type pretty easily, right?
14:41:43 <Heffalump> yep
14:42:17 <jemfinch> how much of a win is that?
14:42:17 <Heffalump> I /think/ you could specialise it by just writing foo :: specialised_type_of_bar \n foo = bar
14:42:22 <Heffalump> dunno, sorry
14:42:46 <Heffalump> not much, I'd imagine, you effectively save one parameter, which is just a pointer
14:43:38 <jemfinch> how are typeclasses implemented in GHC?  It passes around a dictionary of types->methods, right?
14:45:36 <Heffalump> AFAIK, yes
14:45:57 <Heffalump> oh, so that specialisation I suggested above wouldn't help, actually
14:46:03 <jemfinch> how is the dictionary implemented?  How is a "type" looked up?
14:46:13 <jemfinch> is it a binary tree, or just an array, or what?
14:46:37 <Igloo> You can ask GHC (at least) to make specialised variants with a SPECIALISE pragma
14:47:25 <Heffalump> no idea, sorry
14:47:35 <jemfinch> hmm...this is all interesting.
14:47:42 <jemfinch> I'll be back later tonight to ask more questions :)
16:06:10 * shapr bounces
16:06:18 <Heffalump> morning Chilli
16:18:50 <Heffalump> hi
16:18:59 <Heffalump> it must be Aussie-getting-up-time :-)
16:19:23 <Pseudonym> Actually it's Aussie-just-got-to-work time.
16:19:29 <Pseudonym> 9:18am
16:19:35 <Pseudonym> At least on the east coast.
16:19:56 <Pseudonym> In Perth they're probably just waking up.
16:25:35 <shapr> I'd like to spend some time in .au
16:25:50 <Heffalump> BTDT :-)
16:26:21 <Heffalump> I thought Perth was 8 hours ahead at this time of year and Sydney 11 hours, but I must have been confused
16:28:38 <Pseudonym> 10 hours
16:28:53 * Pseudonym is in the same time zone as Sydney
16:29:18 <Pseudonym> BTW, shapr, it is customary when visiting Australia for the first time to find a television camera and say, in the perkiest voice possible, "The people are so friendly!"
16:29:25 <shapr> ick
16:29:43 <shapr> I was thinking more about hanging out with my irc friends and drinking beer.
16:29:56 <shapr> and trying to scrape up people for a major coding bing.
16:29:59 <shapr> er, binge
16:30:23 <Pseudonym> Oh.  Well since you're not a minor world-famous-in-America starlet, you might be able to get away with it.
16:30:24 <shapr> friends + code = happiness
16:30:31 <Heffalump> :-)
16:31:13 <Pseudonym> {- drunk..  fix later -}
16:31:30 <shapr> heh
16:31:38 <shapr> do you really have comments like that in your code?
16:31:51 <Pseudonym> No.  I don't drink, oddly enough.
16:31:54 <shapr> I can't seem to code with any amount of alcohol is my bloodstream
16:32:08 <shapr> I drink about once a month or so
16:32:16 <Pseudonym> I have a refined system of repeated three letter combinations.
16:32:20 * Heffalump can code after one pint, but not after two
16:32:31 <shapr> Pseudonym: ok, what is it?
16:32:38 * shapr grits teeth
16:32:50 <Pseudonym> XXX means a kludge, or a bug which probably won't be fixed until someone asks for it.
16:32:53 <shapr> oh
16:33:01 <Pseudonym> YYY means something which must be fixed before checking in.
16:33:20 <Pseudonym> ZZZ means a possible performance problem.
16:33:22 <Pseudonym> And so on.
16:33:25 <shapr> neat
16:33:33 <Pseudonym> My code is littered with YYYs if I'm tired.
16:33:49 <shapr> I use XXX for anything that needs to be fixed at some point in the future
16:34:05 <shapr> I always write down opportunities for refactoring in my comments
16:34:29 <Pseudonym> Oh, yes, ZZZ is for refactoring opportunities, too.
16:34:58 <Pseudonym> I actually categorise my problems by how likely they are to be fixed any time soon.
16:35:06 <shapr> one of the few things I like about java is the comment tags
16:35:28 <Pseudonym> YYY means "fix even though you don't want to", ZZZ means "fix if bored" and so on.
16:35:32 <shapr> maybe we should petition to add your tags to Haddock
16:35:38 * Pseudonym laughs
16:35:52 <Pseudonym> The thing is, everyone wants different things from their personal system.
16:35:57 <shapr> hm
16:36:02 <shapr> are there some common tags?
16:36:26 <Pseudonym> Yes, javadoc is nice.
16:36:50 <Pseudonym> What I think might be nice is some way to make literate scripts also valid DocBook.
17:00:28 * shapr yawns
17:00:55 <Pseudonym> Inicdentally, now that I know someone is awake... :-)
17:01:06 <shapr> ?
17:01:10 <Pseudonym> Sorry, wrong window.
17:01:28 <Pseudonym> Ironic, considering what that looks like it's in response to. :_)
17:01:44 <shapr> yup
17:19:37 * shapr tries to install gtk+hs
17:19:52 <shapr> anyone else here installed the latest cvs version of gtk+hs ?
17:20:16 * shapr figures out the problem
17:22:03 <Chilli> hmm, I guess, I have
17:22:13 <Chilli> what's the problem?
17:23:03 * shapr grins
17:23:28 <shapr> just trying to figure out how to compile the examples
17:23:32 <shapr> then I saw the Makefile :-/
17:23:40 <Chilli> ok :-)
17:23:49 <Pseudonym> Oh, I know!  You type "make".  Hope this helps.
17:24:04 * shapr laughs
17:24:44 <Chilli> before releasing c2hs 0.10.16 I compiled all of base Gtk+HS and the glade extension 
17:24:49 <Chilli> I all seemed to be ok
17:25:00 <Chilli> I = it
17:25:05 <shapr> I'm using c2hs 0.10.15
17:25:40 <shapr> it looks like the freshmeat page on your web site for c2hs says 0.10.15 is the latest
17:25:43 * shapr checks again
17:25:57 <shapr> oh
17:25:59 <Chilli> only few differences
17:26:09 <shapr> now it says 0.10.16
17:26:25 <shapr> cool
17:26:49 <shapr> I should try new Haskell stuff when I'm awake.
17:26:54 <shapr> sadly, paying work often gets in the way.
17:27:10 <Pseudonym> We'll have none of those four-letter words around here, thankyou very much.
17:27:48 * shapr stops talking about wor.. um, paying endeavors
17:28:23 * shapr has great fun playing with the gkt demos
17:28:26 <shapr> er, gtk
17:31:37 <Chilli> ok, need to go to ameeting
17:31:50 <Pseudonym> Go meet.
17:32:15 <Pseudonym> At my place of... uh... where we do the "w" word, our flagship product used to be called "sim".
17:32:33 <shapr> just sim?
17:32:39 <Pseudonym> Odd thing.  We had a staff meeting on Monday, and they don't know what to call the meetings.
17:32:44 <Pseudonym> They used to be "sim meetings".
17:32:51 * Pseudonym thought that sounded like a rejected Maxis game
17:32:56 * shapr laughs
17:33:03 <Pseudonym> Can you imagine the gameplay?
17:33:05 <shapr> I would have called the monday meeting simulations.
17:33:20 <Pseudonym> Structured Information Manager
17:33:31 <shapr> good name
17:33:38 <Pseudonym> Well it's now called TeraText.
17:33:55 <shapr> I haven't heard of that.
17:33:59 <Pseudonym> "Tera" is meant to suggest "terabytes".  I have the feeling this will date quickly.
17:34:05 <shapr> I agree.
17:34:17 <Pseudonym> Five years ago, I had an honours textbook called "managing gigabytes".
17:34:23 <shapr> whereas PteraText might suggest that it's already dated.
17:34:27 <Pseudonym> That was a lot of information five years ago.
17:34:48 <Pseudonym> True!
17:35:48 <Pseudonym> Pterotext II, the lesser-know Pharaoh.
17:35:56 * shapr grins
17:36:22 <shapr> real legacy systems use papyrus.
17:36:56 <Pseudonym> Papyrus?  You were lucky,  We had to make do with clay tablets.
17:37:40 * shapr snickers
17:38:11 * shapr wonders if gtk+hs can do panel plugin
17:38:24 <shapr> hm, I think jens wrote a gtk+hs panel plugin already.
17:46:20 * shapr gives up on compiling hIDE and downloads the binary
17:53:26 <shapr> whoa, spiffy
17:54:03 <shapr> wow
17:54:43 <Pseudonym> You have pretty pictures, then?
17:55:00 <shapr> yup
17:55:32 <shapr> it can show a call graph, all functions that call a named function, dependendy graphs, etc
17:56:13 <shapr> the module window is an emacs speedbar-style tree widget that shows each module and its functions
17:56:29 <shapr> hm, doesn't let me double click on them to jump to in the source though
17:56:38 <Pseudonym> Sounds pretty, though.
17:57:03 <shapr> it's surprisingly nifty
17:57:37 <shapr> it has cvs integration of some type, and a build menu
17:57:47 <shapr> it also does reports, but I haven't figured out how to do a report configuration
17:58:42 <shapr> it's quite fast also
18:15:06 <shapr> hIDE is cool
18:15:17 <shapr> http://purl.org/net/shapr/hIDE.png
18:15:48 <shapr> I made a Postman project with hIDE, and took a screenshot with a bunch of windows open.
18:17:37 <shapr> time for me to sleep, good night all.
18:19:31 <tmoertel> 'night, shapr
18:21:47 <Pseudonym> Night.
18:23:14 <toadx> i think I will install hIDE soon!
20:45:32 <jemfinch> so do all operations in a do block have to use the same monad?
20:50:34 <Chilli> jemfinch: yes
20:51:43 <jemfinch> can do blocks be nested?
20:51:56 <jemfinch> (and are they most appropriately called "do blocks", or what should I call them?
20:52:19 <Chilli> usually, they are called do expressions
20:52:30 <Chilli> (in an FP languagfe everythign are expression after all)
20:52:39 <Chilli> you can nest them
20:52:45 <jemfinch> ah, that's true.
20:52:46 <Chilli> often you have to
20:52:47 <Chilli> as in
20:52:51 <Chilli> do
20:52:53 <Chilli>   something
20:52:56 <jemfinch> and they'll just return the result of the last operation in that monad, right?
20:52:58 <Chilli>   if cond then
20:53:01 <Chilli>     some more
20:53:06 <Chilli>     else do
20:53:11 <Chilli>       action1
20:53:14 <Chilli>       action2
20:53:24 <Chilli> yes
20:54:11 <Chilli> a do expression   do {...} :: m a   can be used anywhere, where an expression of type "m a" is permitted
20:54:17 <Chilli> where m is the monad of that do expression
20:54:24 <Chilli> Haskell is very compositional
20:54:43 <Chilli> as long as the type fits, you can use everything anywhere
20:57:37 <jemfinch> cool.
20:59:01 <jemfinch> so how does read work?
21:00:15 <Chilli> What aspect of it?
21:00:18 <Chilli> Overloading?
21:00:44 <jemfinch> so I've seen do expressions that return Monad (), but how do I get the value of something from inside a monad (if it's something useful, other than ())?
21:01:11 <jemfinch> Chilli: well, it returns a member of the Read class, but how does it actually convert the string to a type of the Read class?  Does it try *all* instances of the class until one works?
21:04:19 <Chilli> no
21:04:31 <Chilli> it is in the way overloading is compiled in Haskell
21:04:42 <Chilli> the basic idea is that if you have a function of the type, say'
21:04:57 <Chilli>   foo :: Read a => ... -> a
21:05:07 <Chilli> tehn foo is compiled onto foo' where
21:05:21 <Chilli> foo' :: ReadDict -> ... -> a
21:05:39 <Chilli> where ReadDict is a struture containing entry for every method of the read class
21:06:06 <Chilli> and where the type checker ensures that the structure value corresponding to whatever the type of a is at runtime is being passed to foo'
21:06:30 <Chilli> so, in a sense, you could say, the type checker arranges for the correct read instance being passed as a higher-order function argument to foo
21:06:58 <jemfinch> but that's the thing -- how does it know *which* read instance to allow to read the string?
21:08:57 <Chilli> well there are basically two scenarios
21:09:25 <Chilli> (1) foo is called by another function bar, which also has a Read a context, then it just passes on whatever is passed to bar
21:10:17 <Chilli> (2) or in the call to foo the type for a can be inferred from the context, then the type checker can actually statically select the right instance
21:10:28 <Chilli> ok, I'll haver to go to meeting now
21:10:30 <Chilli> cu later
21:10:34 <jemfinch> seeya
21:11:25 <dennisb> jemfinch: it knows by the type where it is used, if you use the result as an Int that is what read will try to convert to
21:11:56 <jemfinch> dennisb: hmm?
21:12:05 <jemfinch> what's the Read class definition?
21:12:17 <dennisb> look it up in the standard
21:12:56 * jemfinch is looking for the standard.
21:14:24 <dennisb> it works by dictionaries but you don't need to know that to write programs, the correct read will be selected by the system depending on what the return type is
21:16:11 <jemfinch> dennisb: I understand that typeclasses are implemented via a hidden first argument to a function that's basically a map from the types to the methods of the type.
21:16:32 <jemfinch> I still can't find the definition of the Read class.
21:18:02 <dennisb> so, read "44" + 5 will work since the + 5 tells the system read should parse an Int (well, 5 can be more then an int, but lets pretend). If you just write read "44" then it can't know what version of read to use
21:18:04 <dennisb> http://www.haskell.org/onlinereport/standard-prelude.html#$tRead
21:18:10 <jemfinch> Haskell can warn of non-exhaustive functions, right?
21:18:53 <dennisb> I don't know what you mean
21:19:09 * jemfinch goes to check...
21:19:09 <dennisb> functions not defined for all arguments?
21:19:13 <jemfinch> yeah.
21:19:35 <dennisb> you will get a runtime error, maybe there is a flag to get warnings
21:29:02 <tmoertel> dennisb: with GHC the -Wall ("all warnings" option) will flag non-exhaustive case scrutinees
21:29:43 <jemfinch> it's strange that you need a switch to enable that -- the MLs all warn about that be default.  Any idea why they decided to make it an option?
21:32:49 <dennisb> I guess it's because standard functions like head (x:xs) = x is usually defined like this. I guess people use the same style when writing programs, but I think it is a good idea to make functions exhaustive
21:32:59 <jemfinch> me too.
21:34:04 * jemfinch also thinks that although functions aren't in the Show class, Hugs should show me the type of the function when I just type the name of the function.
21:36:36 <Pseudonym> There's a problem with that.
21:36:52 <Pseudonym> Would that be the most general type or the instantiated type?
21:37:00 <jemfinch> what do you mean?
21:37:42 <Pseudonym> (+) :: (Num a) => a -> a -> a
21:38:01 <Pseudonym> Hang on.
21:38:03 * Pseudonym thinks
21:38:07 * dennisb just uses :t and is happy with that
21:38:12 <Pseudonym> Yes. :-)
21:38:36 <Pseudonym> Or :info in ghci.
21:38:51 <jemfinch> I dunno, I also don't see why I can't make new definitions at the toplevel interpreter ;)
21:39:15 <Pseudonym> Well that's easy.  It's because it _is_ an interpreter, not a compiler.
21:39:25 <Pseudonym> You can't make new definitions in gdb either.
21:39:32 <jemfinch> you can in smlnj and ocaml.
21:39:44 <jemfinch> btw, is it better style to use "where" or to use "let"?
21:40:46 <dennisb> in ghci you can do "let f x = x + 5"
21:41:02 <jemfinch> I mean for pulling out common subexpressions.
21:41:17 <Pseudonym> Depends.
21:41:40 <Pseudonym> Where is good because it can be used in more than one equation.
21:41:50 <Pseudonym> Let is good because it can be used inline.
21:41:54 <jemfinch> do you mean more than one scope?
21:42:00 <Pseudonym> Yes.
21:42:08 <jemfinch> ok, just checking :)
21:42:08 <Pseudonym> foo True = x + 1
21:42:11 <Pseudonym> foo False = x + 2
21:42:17 <Pseudonym>           where x = 5
21:42:17 <jemfinch> what do you mean by "Let is good because it can be used inline"?
21:42:33 <Pseudonym> Well, a where clause won't help you here:
21:42:53 <Pseudonym> foo = bar >>= \ x -> let y = x + 5 in ...
21:42:57 <jemfinch> how does the compiler know that that where only applies to foo and not to the definitions above foo, but at the same indentation level?
21:43:06 <Pseudonym> Offside rule.
21:43:22 <Pseudonym> When it's a new function, old where clauses die.
21:43:34 <jemfinch> so it only applies to the foo definition.
21:43:37 <Pseudonym> Right.
21:43:41 <dennisb> my let was to make a top level definition in the interpreter ghci
21:43:55 <jemfinch> if I had a bar defined right above foo, at the same indentation level, x would still only be defined for foo.
21:44:06 <jemfinch> dennisb: oooh...hmm...
21:44:40 <jemfinch> dennisb:
21:44:42 <jemfinch> er...
21:44:47 <jemfinch> dennisb: it doesn't work in hugs...
21:45:01 <dennisb> where does not work like in the example above
21:45:01 <jemfinch> nor in ghci.
21:45:12 <dennisb> jemfinch: in ghci it works, not in hugs
21:45:14 <jemfinch> Prelude> let square x = x*x
21:45:14 <jemfinch> ERROR - Syntax error in expression (unexpected end of input)
21:45:28 <jemfinch> (that was hugs, this is ghci:)
21:45:29 <jemfinch> Prelude> let square x = x*x
21:45:29 <jemfinch> <interactive>:1: parse error on input `='
21:45:45 <dennisb> I just pasted it into ghci and no error
21:46:23 <jemfinch> hmm.
21:46:25 <jemfinch> that's weird...
21:46:33 <jemfinch> it works now, and I started the interpreter and it works too.
21:46:44 <Pseudonym> Must just be you, then.
21:46:45 <dennisb> when you have a definition with several guards the "where" works for each of the branches
21:47:08 <jemfinch> Pseudonym: it worked the second time, strangely enough.
21:47:28 <Pseudonym> Probably a conspiracy.
21:47:44 * dennisb agrees
21:47:49 <jemfinch> :)
21:51:02 <jemfinch> hmm.  ghc-5.04 won't compile on my system.
22:00:21 <jemfinch> so they say that ghc generates fast code, but does so slowly (that is, it takes a long time to compile) -- why is that the case?
22:00:35 <jemfinch> c:\ghc\ghc-5.04\bin\ghc.exe: unknown package name: posix
22:04:24 <tmoertel> g'night, all
22:04:32 <jemfinch> g'night.
22:04:57 * tmoertel fades away
22:05:55 <Pseudonym> It's because GHC does a lot of optimisation.
22:06:33 <Pseudonym> Part of the trouble is that each kind of optimisation requires its own kind of analysis.
22:06:47 <Pseudonym> And the analyses are often fixpoint iteration-type things.
22:07:23 <jemfinch> by the way, if I have questions while you're answering another one, don't think that I'm not listening to your first answer...I just don't want to forget my questions.
22:07:33 <jemfinch> what are "fixpoint iteration-type things"?
22:07:46 <Pseudonym> Of course.  I know about concurrency.
22:07:54 <jemfinch> (also, do you know Python, so I can speak in Python idiom if I need to?)
22:07:58 <Pseudonym> You know Newton-Raphson root finding?
22:08:03 <jemfinch> yeah, I know that.
22:08:04 <Pseudonym> No, I don't know any python, sorry.
22:08:07 <jemfinch> ah, ok.
22:08:10 <Pseudonym> OK.  That's a fixpoint analysis.
22:08:22 <jemfinch> so "import ModuleName" takes all the names from the module and imports them into the local namespace?
22:08:24 <Pseudonym> You keep applying the same operation over and over again until you find something that's the same.
22:08:41 <Pseudonym> On import: Yes.  If you don't want that, you can "import qualified".
22:08:45 <jemfinch> and "import qualified ModuleName" just lets you do "ModuleName.name" to access definitions from that module.
22:08:53 <Pseudonym> Actually it's not in the local namespace as such.
22:09:28 <Pseudonym> When you use a name, if two unqualified imports conflict, you'll get a compiler error and you'll be told to qualify the name you used.
22:11:09 <sethk> Pseudonym, I have a program working in ghci.  Two .hs files.  One has a module statement, and the second imports the first.  Trying to compile, I get "failed to load interface for `BlipAmsParser".  What's that about?
22:11:20 <sethk> BlipAmsParser.hs is the one with the module statement.
22:11:49 <sethk> Second error line:  Could not find interface file for `BlipAmsParser'
22:12:07 <sethk> I need to construct an interface file?
22:12:26 <Pseudonym> Yes.
22:12:36 <Pseudonym> You should compile BlipAmsParser first.
22:12:49 <sethk> Separately?
22:13:48 <Pseudonym> Or together.
22:13:57 <Pseudonym> You could, in fact, do: ghc -c *.hs
22:14:07 <Pseudonym> Then it'll work out the dependencies for you.
22:15:50 <sethk> Ah, thanks, that worked...
22:20:18 <jemfinch> whoa.
22:20:24 <jemfinch> Arrays are weird in Haskell.
22:20:29 <Pseudonym> Yes they are.
22:20:43 <jemfinch> I'm guessing they're not used all that often...
22:20:55 <Pseudonym> Yes and no.
22:21:07 <Pseudonym> If the array isn't mutable, they're used all the time.
22:21:27 <Pseudonym> Especially with lazy evaluation.  You fill an array with function calls, and they're evaluated as they're used.
22:21:52 <Pseudonym> Otherwise, no, they're not used as often as in other languages.
22:21:54 <jemfinch> hmm...what situations would that be useful in?
22:21:58 <Pseudonym> Memoing.
22:22:02 <Pseudonym> For example.
22:22:22 <jemfinch> oh, that might be useful.  Can arrays be grown/shrunken?
22:23:29 <Pseudonym> Uhm... Arrays of type Array can't.
22:23:34 <Pseudonym> They're not mutable, after all.
22:24:22 <Pseudonym> No, it doesn't look like they can be.
22:24:44 <jemfinch> hmm.
22:25:15 <Pseudonym> Hang on.
22:25:18 <jemfinch> I'm supposed to write a matrix-multiplication routine in Haskell.
22:25:24 <jemfinch> s/routine/function/
22:25:38 <jemfinch> I don't know why I called it a routine, I never really call *anything* a routine :)
22:26:00 <sethk> Even if it has rim shots?
22:26:30 <Chilli> jemfinch: you don't need arrays that grow or shrink for matrix multiplication
22:26:54 <Pseudonym> Right.
22:26:59 <jemfinch> Chilli: no, you don't, but I was curious about their use for memoization.
22:27:20 <jemfinch> I'm interested to see how they'd be used for memoization.
22:27:30 <Pseudonym> Unfortunately the wiki is broken otherwise I'd show you a worked example.
22:29:00 <Pseudonym> Basically, if you only want to memoise a certain range, you build an array which maps values to function calls.
22:29:15 <Pseudonym> Then the first time you look up a value in the array, the call is executed.
22:29:24 <Pseudonym> After that, the value is there.
22:29:49 <Pseudonym> I also use arrays to build cyclic data structures.
22:29:55 <jemfinch> how's that?
22:30:05 <Pseudonym> OK, this part of the wiki _does_ work. :-)
22:30:07 <Pseudonym> http://haskell.org/wiki/wiki?TyingTheKnot
22:30:17 <Pseudonym> If you go down to the DFA example, there's some array code there.
22:33:42 <jemfinch> so is the Haskell community bigger or smaller than the ML community?
22:34:03 <Pseudonym> Hard question to answer.
22:34:19 <Pseudonym> ML is used more in industry, without a doubt.
22:34:26 <jemfinch> why do you say that?
22:34:36 <Pseudonym> I know some people who use ML in some quite diverse areas.
22:34:46 <Pseudonym> Haskell hasn't made much of an inroads there yet.
22:34:53 <Pseudonym> Unsurprising, since ML has been around for longer.
22:35:25 <Pseudonym> For example, biomedical informatics people often use ML for DNA sequencing and search problems.
22:35:52 <Pseudonym> If you think about it, ML is very well suited for that kind of problem.
22:35:59 <Pseudonym> So, arguably, is Haskell.
22:36:16 <jemfinch> any strictly typed, efficient language should be.
22:36:20 <Pseudonym> I think, though, that the Haskell community is more closely-knit, so it seems bigger.
22:36:35 <jemfinch> it's certainly less fragmented than the ML community.
22:36:38 <Pseudonym> Well, no.  Any strictly typed, efficient language with algebraic data types would be.
22:36:47 <jemfinch> ah, yes.
22:36:58 <Pseudonym> Thus distinguishing ML from Lisp.
22:37:08 <jemfinch> Lisp isn't strictly typed :)
22:37:09 <Pseudonym> Not that Lisp is strictly typed.
22:37:10 <Pseudonym> :-)
22:37:27 <Pseudonym> Still, in the absence of type errors, Lisp might be fine for that sort of problem, too.
22:37:47 <jemfinch> really, it seems the bioinformatics community hasn't really standardised on a language yet.
22:38:07 <jemfinch> I've seen even 180kloc programs written in *Perl*, of all languages, for bioinformatics.
22:38:09 <Pseudonym> No.  They keep their technology to themselves.  It's a cutthroat industry, that one.
22:38:42 <jemfinch> and I'm sure the Lisp conspiracy theorists probably think 90% of them use Lisp as their "secret weapon" and just won't say so :)
22:39:01 * Pseudonym laughs
22:39:03 * jemfinch hasn't gotten to the DFA stuff on that page yet, he's still trying to understand the DList stuff
22:40:14 <jemfinch> one thing I found out when I was learning O'Caml was that the vast majority of my knowledge came simply from "proximity curiosity" -- when I was looking up an answer to something, or reading something I'd been directed to, I'd read everything on the way there too.
22:40:57 <Pseudonym> Absolutely.
22:41:09 <Pseudonym> It's related to just plain playing around.
22:44:04 <jemfinch> so is there an "Iterable" class that lets me iterate over any instance of the class?
22:44:26 <Pseudonym> Erm... no, not really.
22:44:37 <jemfinch> oh, yeah...iteration...not functional...
22:44:39 <jemfinch> :)
22:44:44 <Pseudonym> I'm not sure what an interface like that would look like.
22:44:57 <Pseudonym> Many containers supply "fold", which sort of does what you want.
22:45:45 <Pseudonym> Or some way to serialise themselves to a list.
22:45:48 * jemfinch looks up the syntax to class definitions so he can show you what he means.
22:45:58 <Pseudonym> A lazily evaluated list, of course, so it has the effect of an iterator.
22:49:44 <jemfinch> gah, I'm having some trouble here.
22:50:03 <Pseudonym> Can you say it in English?
22:50:17 <jemfinch> how do I say "'a something" as part of a class definition?
22:50:32 <jemfinch> (note the quote)
22:50:36 <Pseudonym> Yes.
22:50:41 <Pseudonym> You want something like:
22:50:49 <Pseudonym> class Num a where
22:50:55 <Pseudonym>   foo :: bar -> baz
22:51:11 <jemfinch> the thing, though, is that it's a container.
22:51:19 <jemfinch> class (Eq a, Ord a) => Iterable a where
22:51:28 <jemfinch> I need that to be "Iterable a b" or something...
22:51:36 <Pseudonym> What you want is:
22:51:50 <Pseudonym> class (Eq a, Ord a) => Iterable c a where
22:51:58 <Pseudonym>     emptyContainer :: c a
22:52:00 <Pseudonym>     -- etc
22:52:05 <Pseudonym> That's one way of doing it
22:52:10 <jemfinch> ah, ok.
22:52:20 <Pseudonym> Not that this is polymorphic in the _constructor_.
22:52:29 <jemfinch> but I want the containers themselves to be Eq and Ord instances, too.
22:52:34 <Pseudonym> This is technically a "constructor class".
22:52:44 <Pseudonym> OK.
22:52:47 <Pseudonym> What you want is this:
22:52:51 <jemfinch> would I just do (Eq a, Ord a, Eq c, Ord c)?
22:52:52 <Pseudonym> class Iterable c a where
22:52:58 <Pseudonym>    -- operations on Iterable
22:52:59 <Pseudonym> Then:
22:53:16 <Pseudonym> instance (Eq a) => Eq (Iterable c a) where
22:53:19 <Pseudonym> and then:
22:53:27 <Pseudonym> instance (Ord a) => Ord (Iterable c a) where
22:53:31 <Pseudonym> Get it?
22:53:36 <jemfinch> ah, ok.
22:53:52 <Pseudonym> This is where typeclasses are different from OO classes.
22:53:55 <jemfinch> hmm...I like the way classes are done in Haskell.
22:54:03 <Pseudonym> You make the type, then you say what interfaces it supports.
22:54:05 <Pseudonym> Actually.
22:54:09 <Pseudonym> No, that's wrong.
22:54:23 <Pseudonym> instance (Eq a, Iterable c a) => Eq (c a) where
22:54:25 <jemfinch> just because this doesn't exist doesn't mean I can't make it work with all the unmodified library code I have...
22:54:31 <Pseudonym> instance (Ord a, Iterable c a) => Ord (c a) where
22:54:38 <Pseudonym> Duh.  Iterable isn't a type, it's a class.
22:55:16 <jemfinch> I'm going to have to scroll up and see that in a sec when I get done with the initial class definition.
22:55:20 <Pseudonym> Sure.
22:59:11 <jemfinch> hmm.
23:04:45 <jemfinch> purely functional containers in ML generally have the type signature " 'a -> 'a t -> 'a t " for their add operation -- is that the case in Haskell?
23:05:32 <Pseudonym> Yes.  For example, (:) :: a -> [a] -> [a]
23:05:40 <Pseudonym> The type [a] is actually short for [] a
23:05:41 <jemfinch> ok, just wanted to make sure :)
23:06:22 <jemfinch> ok, I'm pasting a bit now:
23:06:26 <jemfinch> class Iterable c a where
23:06:26 <jemfinch>     map  :: (a -> b) -> c a -> c b
23:06:26 <jemfinch>     foldl :: (b -> a -> b) -> b -> c a -> b
23:06:26 <jemfinch>     foldr :: (a -> b -> b) -> b -> c a -> b
23:06:26 <jemfinch>     filter :: (a -> Bool) -> c a -> c a
23:06:27 <jemfinch>     fromList :: [a] -> c a
23:06:29 <jemfinch>     toList :: c a -> [a]
23:06:57 <Pseudonym> Looks good to me.
23:07:19 <Pseudonym> First thing to note, though, is that map already has its own typeclass, Functor.
23:07:21 <jemfinch> it seems something like that would be useful for having generic mapping/filtering/folding constructs on different data types, like trees, lists, sets, etc.
23:07:31 <Pseudonym> So you might want to derive Iterable from Functor.
23:07:33 <jemfinch> yeah, I saw that, fmap.
23:07:55 <jemfinch> I'm curious why Functor stopped at fmap, instead of also providing the rest of the functions.
23:08:05 <Pseudonym> Functor is useful in other situations.
23:08:07 <jemfinch> (or at least filter/foldl/foldr)
23:08:36 <Pseudonym> For example, the identity container works with Functor.
23:08:42 <Pseudonym> data ID a = ID a
23:08:47 <Pseudonym> instance Functor ID where
23:08:56 <Pseudonym>    fmap f (ID x) = ID (f x)
23:09:06 <Pseudonym> It doesn't work with foldl, foldr, filter etc.
23:09:10 <Pseudonym> Not filter at least.
23:09:41 <jemfinch> why is the identity container useful?
23:10:44 <Pseudonym> Well, it's useful as a base case for containers-of-containers, or monad transformer.
23:11:07 <Pseudonym> If you have something that needs a container as a type argument, you can supply the identity container.
23:11:16 <Pseudonym> If you don't want to use a "real" container.
23:11:27 <Pseudonym> BTW, I just made up ID there.  It's not standard Haskell.
23:11:35 <jemfinch> oh, ok.
23:11:40 <Pseudonym> But, for example, fmap works on the IO monad.
23:11:51 <jemfinch> how's that work?
23:11:58 <jemfinch> I thought fmap worked on containers.
23:12:06 <Pseudonym> No, fmap works on Functors.
23:12:21 <Pseudonym> Containers are functors, but other things can be functors too.
23:12:26 <Pseudonym> Like the IO monad. :-)
23:12:31 <Pseudonym> Or any monad, for that matter.
23:12:47 <jemfinch> oh, gosh...what are Functors in *Haskell*?
23:12:51 * jemfinch already knows two definitions of Functors.
23:13:03 <Pseudonym> A functor is anything which supports the fmap operation.
23:13:09 <Pseudonym> That's all.
23:13:15 <jemfinch> ML has functors, C++ has functors...now Haskell has functors.
23:13:20 <Pseudonym> Prolog does too.
23:13:24 <Pseudonym> And they're something different again.
23:13:25 <jemfinch> geez!
23:13:45 <jemfinch> so how does the IO Monad support fmap; what does it to do the IO monad?
23:14:06 <Pseudonym> OK, consider this:
23:14:09 <Chilli> Haskell functors, like Haskell Monads, are what the mathematical (categorial) meaning of these terms suggests
23:14:36 <Pseudonym> return 1 :: IO Int
23:14:39 <Pseudonym> You know what that means?
23:14:52 <jemfinch> that it's an Int in the IO Monad?
23:14:55 <Pseudonym> Right.  Haskell is heavily based on category theory.
23:15:04 * jemfinch doesn't know any category theory.
23:15:05 <Pseudonym> It's an IO operation which returns an Int.
23:15:12 * Pseudonym knows precious little
23:15:26 <Pseudonym> But you don't need to know it really.
23:15:34 <Pseudonym> Only if you're proving your type checker correct.
23:15:39 <Pseudonym> Or something.
23:16:21 <Pseudonym> fmap (+1) (return 1) :: IO Int
23:16:36 <Pseudonym> That is an IO operation which returns an Integer (which ahppens to be 2).
23:17:05 <jemfinch> so how is that useful?
23:17:18 <Pseudonym> For the IO monad, it's not _that_ useful.
23:17:35 * Pseudonym has never used it
23:17:44 <Chilli> fmap is a map that works on all kinds of data structures
23:17:53 <Chilli> not just lists (like map)
23:18:06 <Chilli> as Monad is a subclass of Functor
23:18:14 <Chilli> in particula all monads support fmap
23:18:24 <jemfinch> Chilli: yeah, I'm curious why that class definition wasn't extended to include stuff like filter, foldl, and foldr.
23:18:32 <Chilli> meaning, you can use it on Maybe, Array, etc
23:18:39 <Pseudonym> Well, filter doesn't work on most monads.
23:18:46 <Pseudonym> And it doesn't make sense on Array, really.
23:19:03 <jemfinch> ah, that's true.
23:19:14 <jemfinch> well, map/foldl/foldr still make sense.
23:19:16 <Chilli> jemfinch: because the mathematical structure called a functor guarantees that there is a sensible definition for map, but nat that there is a sensible definition for filter & friends
23:19:27 <Chilli> eg, filter can only be defined on Monads with a zero
23:19:33 <Chilli> (MonadZero in Haskell)
23:19:42 <Chilli> not all Monads have a zero
23:19:58 <Chilli> a functor is like a group in maths, for example
23:20:01 <Chilli> it is a type 
23:20:05 <Chilli> with a couple of ops
23:20:12 <Pseudonym> I thought we dropped MonadZero.
23:20:13 <Chilli> that must satisfy a bunch of laws
23:20:40 <o3> chocolate!!!!
23:21:05 <Chilli> sorry, I meant MonadPlus
23:21:10 <jemfinch> Is there any reason why foldl/foldr couldn't be included in functor, though?
23:21:12 <Chilli> o3: tsss
23:21:17 <jemfinch> oh, wait.
23:21:24 <jemfinch> that would constrain the type.
23:21:26 <Chilli> o3: you mean liquid one?
23:21:32 <Chilli> jemfinch: same reason
23:21:36 <o3> Chilli: perhaps.  (looks at jaygee's)
23:22:14 <Pseudonym> foldl/foldr don't make sense on many monads
23:22:16 <Chilli> o3: hmm, bit early for CFG, but ok - can you wait 10 more mins or so?
23:22:28 <Chilli> Pseudonym: Lists are a monad too
23:22:37 <Pseudonym> Like I said: _many_ monads.
23:22:43 <Pseudonym> Not _all_ monads.
23:22:45 <Chilli> for a good use of fmap try
23:23:05 <o3> Chilli: 10 mins is good :)
23:23:07 <Chilli> fmap (+1) (Array.listArray (1, 10) [1..10])
23:23:24 <Chilli> Pseudonym: oh, sorry, I misread your message
23:23:37 <Pseudonym> That's cool.  I know it's late there.
23:24:41 <Pseudonym> I'm kinda curious about the chocolate, though.
23:26:33 <Chilli> o3: need to put the latest release of the FFI Addendum out first ;-)
23:27:04 <o3> Chilli: oh right, as you do :)
23:28:29 <jemfinch> can I import modules at the toplevel of hugs or ghci?
23:30:06 <jemfinch> anyone mind if I paste my new Iterable here?
23:30:30 <Pseudonym> I'm pretty sure you can do :module Module in ghci.
23:30:44 <jemfinch> ok, I'm pasting :)
23:30:50 <jemfinch> class Iterable c a where
23:30:52 <jemfinch>     imap  :: (a -> b) -> c a -> c b
23:30:52 <jemfinch>     ifoldl :: (b -> a -> b) -> b -> c a -> b
23:30:52 <jemfinch>     ifoldr :: (a -> b -> b) -> b -> c a -> b
23:30:52 <jemfinch>     ifromList :: [a] -> c a
23:30:52 <jemfinch>     itoList :: c a -> [a]
23:30:58 <andersca> dennisb?
23:31:10 <jemfinch> (I prefixed the names with "i" so they wouldn't conflict with builtin functions already defined)
23:31:40 <Pseudonym> Looks good to me.
23:31:51 <jemfinch> ok, so now I want to make lists an instance of that class.
23:31:52 <Pseudonym> I would derive Iterable from Functor, as previously mentioned.
23:31:59 <Pseudonym> OK.
23:32:03 <jemfinch> yeah, but I'm taking baby steps now :)
23:32:09 <Pseudonym> Fine. :-)
23:32:33 <Pseudonym> You want: instance Iterable [] a where
23:32:43 <jemfinch> ah, good.
23:32:45 <jemfinch> that's what I thought :)
23:34:10 <jemfinch> ah, sweet, it works ;)
23:35:18 <jemfinch> what would happen, btw, if I didn't name my method "imap" but instead named it just "map"?
23:35:48 <Pseudonym> Everything would be fine until you tried to use it.
23:36:06 <Pseudonym> At that point, your Haskell implementation would ask you to put a module qualification before that use.
23:36:39 <Pseudonym> Defining it is okay because the definitions are in different modules.
23:36:43 <jemfinch> so I'd have to type "Iterable.map"?
23:37:41 <Chilli> o3: ok, let's go for CFG!
23:37:50 <o3> Chilli: whee!  yay!
23:37:57 <o3> meet you down on level 1?
23:38:05 <Chilli> ok
23:38:06 <jemfinch> hmm.
23:38:08 <o3> ok
23:38:45 <jemfinch> Pseudonym: now I'm going to make itoList and ifromList have default implementations, using foldl (or foldr, I always forget which one to use :))
23:39:20 <jemfinch> ah, foldr.
23:39:53 <Pseudonym> Right.
23:40:03 <jemfinch> so I can just put this right under the type declaration of itoList:
23:40:06 <Pseudonym> fromList isn't so easy.
23:40:16 <jemfinch> itoList x = ifoldr (:) [] x
23:40:19 <Pseudonym> Yup.
23:40:33 <Pseudonym> And you can override it in a specific instance, of course.
23:40:33 <jemfinch> yeah, I don't think fromList is possible, since there's no way to add/subtract elements.
23:40:49 <Pseudonym> Right.  The thing is, this is Iterable, not Constructable.
23:40:56 <Pseudonym> :-)
23:41:08 <Pseudonym> There's nothing else which actually constructs containers here.
23:41:20 <jemfinch> of course -- in my instance [] a, I just did "itoList = id"
23:41:49 <jemfinch> with flexibility like this, who needs everything-is-an-object? :)
23:42:11 <Pseudonym> Precisely!
23:42:15 <jemfinch> are there any benchmarking functions available by default in hugs or ghci?
23:42:35 <Pseudonym> You can use :set +r in ghci
23:42:53 <jemfinch> I'm curious what the performance difference is between using the Iterable methods or the regular list functions.
23:42:55 <Pseudonym> :set +s in hugs
23:43:18 <Pseudonym> Since you're running interpreted, probably a little.
23:43:28 <Pseudonym> At least in number of cells/reductions.
23:43:51 <jemfinch> why does the Haskell 98 definition not allow multiple parameters in classes?  And what's the "Haskell 98 way" to get around that?
23:44:10 <Pseudonym> Because Haskell 98 is almost five years old./
23:44:30 <jemfinch> is Haskell going to get redefined ever?
23:44:32 <Pseudonym> Nobody seriously writes programs using the 98 subset.
23:44:33 <Pseudonym> Sure.
23:44:51 <Pseudonym> The purpose of Haskell 98 was to create a non-moving target.
23:44:59 <andersca> forall!
23:45:07 <jemfinch> andersca: eh?
23:45:30 <jemfinch> oh yeah...that should be in Iterable.
23:45:35 <jemfinch> hmmm...
23:45:40 <andersca> forall is Haskell 98
23:45:42 * jemfinch thinks of a good name.
23:45:45 <jemfinch> is it?
23:45:56 <jemfinch> I'm getting undefined variables in both ghci and hugs.
23:46:27 <andersca> run hugs -98
23:46:54 <jemfinch> hmm.
23:47:09 <jemfinch> if forall is Haskell 98, wouldn't it be in the default hugs?
23:47:34 <jemfinch> and now I'm getting 'unexpected keyword "forall"' when I try a :t forall
23:47:35 <Pseudonym> Uhm... forall is a keyword.  It's part of the type system.
23:47:46 <jemfinch> oh...why's that?
23:48:15 <Pseudonym> Existential types.  Long story.  Amongst other things, it's the way to get something close to actual OO in Haskell.
23:48:29 <Pseudonym> Suppose, for example, you want a list of Iterables.
23:48:32 <jemfinch> where can I read about it?
23:48:46 <Pseudonym> Can't do that without forall.
23:48:51 <jemfinch> why not?
23:48:55 <jemfinch> oooh.
23:48:55 <Pseudonym> Because list requires that all elements have the same tpe.
23:48:57 <Pseudonym> type
23:49:01 <Pseudonym> Not the same interface.
23:49:07 <jemfinch> yeah...that's not any good.
23:49:09 <Pseudonym> Type != interface.
23:49:14 <Pseudonym> OK, so here's what you do:
23:49:40 <jemfinch> is there something keeping them from making that the case?  Where type is == interface?
23:49:43 <Pseudonym> data ITERABLE a = forall c. (Iterable c a) => ITERABLE (c a)
23:50:00 <Pseudonym> That makes a concrete type (ITERABLE).
23:50:33 <Pseudonym> Where there's a single constructor with a single argument, which is of type (c a) for all c's which support the Iterable interface.
23:50:56 <Pseudonym> Then you can say:
23:51:04 <Pseudonym> iterables :: [ITERABLE Int]
23:51:19 <jemfinch> and that's completely typesafe?
23:51:27 <Pseudonym> iterables = [ ITERABLE [1,2,3], ITERABLE (fromList [4,5,6] :: Set Int) ]
23:51:29 <Pseudonym> Yes, it is.
23:51:54 <Pseudonym> See, type classes are implemented by implicit passing of dictionaries.
23:51:55 <jemfinch> it sounds kind of...hackish to me.
23:52:08 <jemfinch> not that I'm a good judge of that or anything...
23:52:08 <Pseudonym> To have a heterogeneous list like this, you need to store the dictionaries in the list somehow.
23:52:15 <Pseudonym> That's what the introduced constructor is for.
23:52:28 <Pseudonym> It actually is a pair of the dictionary and the data itself.
23:52:46 <jemfinch> so why can't this be built into the typesystem by default?
23:53:16 <Pseudonym> Well, it depends.  Is it more hackish to confuse interfaces and types, or more hackish to have to explicitly put them back when you need them?
23:53:51 <jemfinch> is there really a confusion between interfaces and types?  *Should* they be separate?
23:54:05 <Pseudonym> I find it nice to be able to add interfaces to an existing type at will.
23:54:28 <jemfinch> would that be confounded if interfaces and types were the same thing?
23:54:36 <Pseudonym> Yes, I think so.
23:54:40 <jemfinch> hmm.
23:55:00 <Pseudonym> In a more traditional OO language, wouldn't supporting the Iterable interface require modifying the list type?
23:55:01 <jemfinch> btw, where does the discussion of Haskell take place at?
23:55:10 <Pseudonym> You mean the language itself?
23:55:12 <jemfinch> yeah, it would.  I like how that's separate.
23:55:15 <jemfinch> yeah, the language itself.
23:55:35 <Pseudonym> http://haskell.org/mailinglist.html
23:55:42 <Pseudonym> Or there's comp.lang.functional.
23:55:52 <jemfinch> c.l.f hasn't been the most hopping place recently ;)
23:56:00 * Pseudonym hasn't been there in years
23:58:28 * jemfinch learns a lot from reading mailing list archives.
