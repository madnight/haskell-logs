00:00:12 <Pseudonym> Chilli: The problem with Mercury is its greatest strength: the mode system.
00:00:41 <clausen> also, I find the syntax less versatile than haskell
00:00:48 <Pseudonym> Do you know any Mercury, Chilli?
00:00:50 <clausen> for example, there is no pretty way to do function compostion
00:01:17 <Pseudonym> No there isn't, but it's less necessary.
00:01:22 <Chilli> Pseudonym: I know what the "features", have read a couple of papers, including examples programs
00:01:31 <clausen> Pseudonym: why?
00:01:34 <Chilli> but I have never used it for a "real" application
00:01:36 <clausen> (is this a FAQ?)
00:01:37 <Pseudonym> Nobody claimed that mercury is functional.
00:01:51 <Pseudonym> You use it less, let's put it that way.
00:02:00 * clausen is using it all over the place
00:02:08 <Chilli> I have done quite some Prolog programming and worked on combined functional logic programming for a while
00:02:12 <clausen> what's :- func all about then?
00:02:15 <Pseudonym> OK, one sticking point is higher-order predicates.
00:03:00 <Pseudonym> There's types and there's modes.  Modes are, in principle, annotations to the type tree.
00:03:38 <Pseudonym> For each node in the type tree, this is either "bound", or "free".  If it's free, then all subnodes are free too.
00:03:50 <Pseudonym> That's fine for data structures.
00:04:30 <Pseudonym> For higher-order stuff it gets more complex, because when you store a predicate in a data structure, you need to put the mode of the predicate in the inst of the data structure.
00:05:00 <Pseudonym> You have a double maintenance problem.  The inst declarations mirror the type declarations.
00:05:21 <Pseudonym> Moreover, a lot of library predicates and functions no longer work.
00:05:35 <Pseudonym> Uhm... ok, here's an example.
00:05:49 <Pseudonym> In Haskell you can have a type like FiniteMap String (Int -> Char)
00:06:05 <Pseudonym> And using the built-in FiniteMap, everything works nicely.
00:06:09 <Pseudonym> Not so in Mercury.
00:06:47 <Pseudonym> The Mercury equivalent of FiniteMap is map, which has operations like:
00:07:02 <Pseudonym> :- pred map:lookup(map(K,V), K, V).
00:07:10 <Pseudonym> :- mode map:lookup(in, in, out) is semidet.
00:07:20 <Pseudonym> Where "out" means free -> ground.
00:07:40 <Pseudonym> The trouble is, "ground" is not a usable inst for a predicate.
00:08:05 <Pseudonym> You actually want it to be free -> bound(pred(in, out)) or something like that.
00:08:22 <Chilli> ic
00:08:39 <Chilli> it is the co-variance of functions that messes it up
00:08:41 <Pseudonym> OK, that's one problem.
00:08:44 <Pseudonym> Yes, exactly.
00:08:58 <Pseudonym> The other problem is filling in free variables.
00:09:08 <Chilli> hmm, interesting point, never thought about that
00:09:10 <Pseudonym> I worked for 18 months on trying to get this to work in mode analysis.
00:09:25 <Pseudonym> Dave Overton took over and tried for a similar amount of time using a different approach.
00:09:41 <Pseudonym> Basically, the problem does not appear to have an efficient solution.
00:09:55 <Pseudonym> Chilli: Nor did anyone else until I tried it.
00:10:25 <Chilli> you mean, mode analysis for data structures containing functions is what you spent 18 month on?
00:10:28 <Pseudonym> Had I not been a Haskell programmer before I worked on Mercury, it may still be untried.
00:10:44 <Pseudonym> No, mode analysis for filling in free variables is what I spent 18 months on.
00:11:09 <Pseudonym> Mode analysis for data structures containing functions is easy.  It's the mode declarations which are hard on the programmer.
00:11:09 <Chilli> ic
00:11:27 <Pseudonym> The problem with filling in free variables is that they might be shared.
00:11:53 <Pseudonym> So you either need full Prolog unification (ouch) or you need to guarantee that they're _not_ shared.
00:12:09 <Pseudonym> Basically, like strong types, strong modes and strong determinism, you need strong alias information.
00:12:28 <Pseudonym> It's the strong alias analysis which doesn't appear to have an efficient solution.
00:13:45 <Chilli> ok, I can imagine that
00:14:03 <Pseudonym> And I can imagine how ugly it would be for the programmer, too.
00:14:28 <Pseudonym> Inst declarations are currently bad enough, if you need anything more complex than "free" and "ground".
00:14:48 <Chilli> yeah
00:15:15 <Pseudonym> I still think that pure logic programming can work, but I think Mercury has hit a few dead ends.
00:15:27 <Chilli> I find it really interesting how the simple fact that in pure FP all dataflow is fixed makes things sooo much easier
00:15:33 <Pseudonym> Yes.
00:16:14 <Chilli> How do you think it can work without running into the problems that Mercury encountered?
00:16:31 <Pseudonym> I don't know.  I think there are a couple of major research hurdles to overcome first.
00:17:40 <Pseudonym> clausen: I gotta go in a couple of minutes.  You'd better ask now. :-)
00:17:59 <clausen> it's not liking my lambda expression grrr
00:18:05 <clausen> in my test case:
00:18:29 <clausen> :- pred testPred(list(T)::in, maybe(list(T))::out) is det.
00:18:30 <clausen> testPred([], no).
00:18:30 <clausen> testPred(In, yes(Out)) :-
00:18:30 <clausen> 	Out = list__filter((pred(_T) is det :- true), In).
00:18:38 <Chilli> Pseudonym: ok
00:19:07 <clausen> pain.m:014:   error: undefined symbol `is/2'.
00:19:18 <clausen> pain.m:014:   syntax error in lambda expression (`:-').
00:19:20 <clausen> etc.
00:20:03 <Pseudonym> I think you need a type declaration in there.
00:20:28 <Pseudonym> Out = list__filter((pred(_X :: _T) is det :- true), In).
00:21:23 <clausen> s/type/mode/ ??
00:21:27 <Pseudonym> Oh, yeah, that's another problem which we constantly wrestled with.  Mercury is based on Prolog syntax.
00:21:30 <Pseudonym> No, type.
00:21:33 <Pseudonym> I think.
00:21:35 <Pseudonym> Hmmm.
00:21:38 <Pseudonym> No, mode, you're right.
00:21:46 <Pseudonym> Out = list__filter((pred(_X :: in) is det :- true), In).
00:21:57 <clausen> :- pred testPred(list(T)::in, maybe(list(T))::out) is det.
00:21:58 <clausen> testPred([], no).
00:21:58 <clausen> testPred(In, yes(Out)) :-
00:21:58 <clausen>         Out = list__filter(In, (pred(_T::in) is det :- true)).
00:21:59 <clausen> now I get:
00:22:03 <Pseudonym> Prolog syntax made sense once.
00:22:15 <Pseudonym> It meant we could bootstrap using Prolog.
00:22:17 <clausen> pain.m:014: In clause for predicate `pain:testPred/2':
00:22:17 <clausen> pain.m:014:   in unification of variable `Out'
00:22:17 <clausen> pain.m:014:   and term `list:filter(In, V_6)':
00:22:17 <clausen> pain.m:014:   type error in argument(s) of functor `list:filter/2'.
00:22:17 <clausen> pain.m:014:   Argument 1 (In) has type `(list:list(T))',
00:22:18 <clausen> pain.m:014:   expected type was `(pred T)'.
00:22:49 * clausen stares at that for a bit
00:22:51 <Pseudonym> Er... list__filter is a predicate.
00:22:55 <Pseudonym> Not a function.
00:23:00 <clausen> really?!
00:23:01 <Pseudonym> testPred(In, yes(Out)) :-
00:23:03 <clausen> I thought it had both
00:23:08 <Pseudonym> Maybe.
00:23:16 <Pseudonym> They might have added the function after my time.
00:23:30 <Pseudonym> When I was a Mercurian, everything was predicates.
00:23:47 <clausen> grep list__filter ~/common/mercury/library/list.m | grep func
00:23:48 <clausen> :- func list__filter(pred(X), list(X)) = list(X).
00:23:48 <clausen> :- func list__filter_map(func(X) = Y, list(X)) = list(Y).
00:23:48 <clausen> :- mode list__filter_map(func(in) = out is semidet, in) = out is det.
00:23:56 <Pseudonym> There you go.
00:24:20 <Pseudonym> OK...
00:24:30 <Pseudonym> Oh, you put the arguments around the wrong way.
00:24:40 <Pseudonym> Swap the arguments to list__filter.
00:25:37 <clausen> oops
00:26:02 <clausen> pain.m:014: In clause for `testPred(in, out)':
00:26:03 <norpan> hi all
00:26:03 <clausen> pain.m:014:   in argument 1 of call to function `list:filter/2':
00:26:03 <clausen> pain.m:014:   mode error: variable `V_6' has instantiatedness `/* unique */(pred((ground -> ground)) is det)',
00:26:03 <clausen> pain.m:014:   expected instantiatedness was `(pred((ground -> ground)) is semidet)'.
00:26:24 <Pseudonym> Oh, well you should make it semidet, then.
00:26:37 <Pseudonym> pred(_T::in) is semidet :- true
00:26:42 <clausen> ah, right
00:26:44 * clausen just figured that
00:26:47 <Pseudonym> Actually, you might want to use semidet_succeed instead of true.
00:26:54 <Pseudonym> It'll avoid a determinism warning.
00:27:20 * Pseudonym sighs... all coming back to me now...
00:27:32 <clausen> bugger, it works now
00:27:37 <clausen> so, my test case didn't capture the strange msg
00:27:47 <clausen> (BTW, I would have figured out those problems, just I'm trying to be quick...
00:27:52 <Pseudonym> Sure.
00:27:54 <clausen> and the error messages still aren't intuitive for me)
00:28:00 <Pseudonym> Who's running 471?  Is it Zoltan?
00:28:04 <clausen> yep
00:28:13 * clausen fixed the det warning, and it worked, hehe
00:28:19 <Pseudonym> :-)
00:28:27 * clausen is dying to talk to zoltan about chicks *grin*
00:28:28 <Pseudonym> Cool.  Glad to be of service.
00:28:35 * Pseudonym laughs
00:28:36 <clausen> that was just the test case
00:28:51 <clausen> I reckon he's a funny/social/blah blah blah person underneath
00:28:59 <clausen> just, he's too intimidating on the surface for anyone to go near him
00:29:06 <Pseudonym> Oh, he's quite funny when you get to know him.
00:29:13 * clausen thought so
00:29:19 <clausen> well, I'll keep trying then :)
00:29:31 <clausen> the class is so anti-social
00:29:33 <Pseudonym> If you prove yourself smart, that helps.
00:29:36 <clausen> I've been working hard on corrupting everyone :)
00:29:47 <Pseudonym> Zoltan likes smart people.
00:29:47 <clausen> he seems to smile/nod at me as he goes past
00:29:51 <clausen> I think I'm making progress :)
00:30:17 <Pseudonym> Anyway, good luck.
00:30:20 <clausen> hehehe thanks :)
00:30:27 <Pseudonym> Gotta go.  Night.
00:30:30 <clausen> thanks for the help
00:30:30 <clausen> cya
00:51:34 <clausen> grrr, /me got a simple test case too late :(
00:51:43 <clausen> :- pred testPred(list(list(string))::in, maybe(list(string))::out) is det.
00:51:43 <clausen> testPred(X, yes(Out)) :-
00:51:43 <clausen>         Out = string__append(X).
00:59:40 * clausen found the bug
00:59:45 <clausen> I had typed String, not string
00:59:46 <clausen> GRRRRR
00:59:56 <clausen> crap error msgs
01:43:01 <andersca> hey Marvin--
01:43:09 <andersca> Marvin--: is there a /pub today?
01:44:45 <Marvin--> andersca: no, sorry, next week
01:45:17 <andersca> ok
01:45:45 <Marvin--> we don't have much people, so we've been forced to go down to one pub per month instead of every second week :/
01:46:02 <andersca> that sucks :/
01:46:06 <andersca> need to reqruit some people
01:56:50 * Marvin-- quietly ponders whether ANYBODY can navigate on www.gnu.org without using the sitemap
01:57:51 <andersca> Marvin--: how do I print out more than one argument in python using %
01:58:02 <andersca> "foo %s %d" % foo, bar ?
01:58:12 <Marvin--> andersca: a tuple, yes, you probably have to parenthesise it
01:58:25 <andersca> cool
01:58:59 <andersca> nice way to use operator overloading
02:01:51 <Marvin--> yes and no... Python's operator overloading is a bit ad hoc
02:03:14 <Marvin--> when evaluating a + b, it tries first a.__add__(b), if that doesn't exist, it tries b.__radd__(a)
02:03:23 <Marvin--> add things like += and you're in for hell
02:03:26 <andersca> radd?
02:03:49 <Marvin--> reverse add or something
02:03:53 <Marvin--> or right add
02:04:06 <andersca> oh
02:04:11 <Marvin--> if the lhs doesn't provide an implementation, it asks the rhs instead
02:04:21 <andersca> interesting
02:05:33 <Marvin--> Hmm, gnu.org says that the APSL doesn't allow your to "make a modified version and use it for your own private purposes, without publishing your changes."
02:06:07 <Marvin--> but from what I read in the license: "You may use, reproduce, display, perform, modify and distribute Original Code, with or without Modifications, solely for Your internal research and development and/or Personal Use, provided that in each instance: ..."
02:06:37 <Marvin--> and the requirements are leaving copyright notices intact and providing the source code to your changes IF you distribute them
02:06:57 <Marvin--> I suppose there's a difference between personal use and private use
02:08:18 <Marvin--> ugh, seven assignments to correct so far
02:40:11 <Marvin--> I keep reading claesen instead of clausen
02:41:40 <Heffalump> with two 's's?
02:41:55 <Marvin--> well, that too
02:42:41 <clausen> ?
02:43:02 <Marvin--> Koen Claessen is lecturing in a course I'm taking right now
02:43:07 <clausen> ah :)
03:19:10 <Igloo> Yay! Different Template Haskell errors now!
03:19:54 <Heffalump> congratulations
03:20:01 <Heffalump> what can you do with the latest set?
03:21:53 <Igloo> Make more errors so far...
03:22:41 <Igloo> Oooo, got it down to "No instance for (Show Expr)"
03:22:50 <Igloo> Which is kind of a PITA really
03:23:36 <Heffalump> how big is an Expr?
03:23:41 <Heffalump> and can you just stick a deriving on it?
03:24:36 <Igloo> It's GHCs datatype
03:24:56 <Heffalump> ah
03:25:01 <Igloo> This particular one will be something not much bigger than Literal 5 I suspect
03:25:13 <Heffalump> well, you could put: instance Show Expr where show _ = ""
03:25:28 <Heffalump> or more helpfully: instance Show Expr where show _ = "<expr>"
03:25:33 <Igloo> Hmmm, and something I thought would work appears not to
03:25:38 <Heffalump> and then start filling it out with cases as you need to
03:25:51 <Igloo> Yeah, but I wanted to see what representation of it was being used  :-)
03:27:28 * Igloo separates code into 2 modules to see if that way I can make something vaguely interesting that compiles
03:28:55 <Igloo> Yay! Pointless reification and splicing works!
05:04:29 * pesco is back (gone 00:09:57)
07:01:41 <jewel> shapr san, how far is your work on twisted-haskell?
07:02:10 * Igloo tries to remember what san means - is it "master" or just a mark of respect?
07:02:27 <Chilli> It's Mr/Ms
07:02:45 <jewel> http://www.geocities.com/Tokyo/Towers/9264/titles.html
07:02:54 <Chilli> (at least that's the closest thing in English)
07:03:18 <Chilli> Master is "sama"
07:03:33 <Igloo> Right, OK - roughly what I meant by a mark of respect then
07:06:46 <shapr> hai jewel san
07:07:24 <shapr> jewel: I've just barely looked at it since I got back from vacation. Have you checked it out of CVS?
07:07:58 <shapr> y0 dnm
07:11:26 <Chilli> o-yasumi nasai (to stick with the Japanese theme ;-)
07:11:34 <shapr> ?
07:11:37 <shapr> what's that mean?
07:11:44 <Chilli> good night :-)
07:11:53 <shapr> oh! good night Chilli!
07:11:57 <Igloo> Night  :-)
07:13:15 <Chilli> (I'll be off to Pittsburgh tomorrow, but hopefully have a net connection there, too.)
07:13:38 <Heffalump> tomorrow?
07:13:42 <Heffalump> isn't that a bit early?
07:14:15 <Chilli> Bob Harper asked us whether we'd like to come over a bit earlier
07:14:36 <shapr> hey, are you going to meet Tom Moertel?
07:14:44 <Chilli> see some of whatever there is to see around there
07:14:46 <Igloo> They must like Chilli better, heff  :-)
07:14:50 <Heffalump> :-)
07:15:03 <Chilli> Igloo: ?
07:15:24 <Heffalump> presumably "we" is workshop organisers or PC members or both
07:15:24 <Chilli> shapr: he said, he'll be at PLI, so I expect to see him
07:15:28 <shapr> nifty
07:15:37 <Chilli> we = Gabi and I
07:15:41 <shapr> Heffalump: you're going also, aren't you?
07:15:43 <Heffalump> ahh
07:15:46 <Heffalump> shapr: yes
07:15:53 <shapr> cool, three people from #haskell
07:16:04 <Chilli> Heffalump: when are you coming?
07:16:06 <shapr> heh, I like the topic addition.
07:16:16 <Heffalump> umm, Wednesday I think
07:16:32 * Heffalump checks
07:16:36 <Chilli> Simon Marlow also comes on Wed
07:16:47 <Heffalump> yes, arrive Pittsburgh 14:45 Weds
07:16:51 <o3> wish i was going :(
07:16:58 <Heffalump> I guess a lot of people from the UK might be on that flight
07:17:07 <Chilli> true
07:17:29 <Chilli> o3: write a paper and go next time :-)
07:17:45 <shapr> o3: yah, write a runtime loader paper!
07:17:51 <o3> Chilli: sounds like a plan :)
07:18:06 <o3> shapr: i would if i had the time right now ...
07:18:16 <o3> Chilli: btw, are you going to mich's talk tomorrow?
07:18:20 <shapr> well, I'm glad you're waiting till next year
07:18:28 <shapr> I'm hoping to show up next year.
07:18:41 <Chilli> o3: sorry, but I have to catch a plane :-(
07:19:08 <Chilli> o3: give her my greetings and wish her good luck!
07:19:35 <Chilli> ok, night!
07:19:53 <shapr> g'night!
07:20:06 <shapr> hey, that means we'll hear how well Postman did
07:20:07 <shapr> cool
07:20:19 * Heffalump is not optimistic
07:20:49 <shapr> Heffalump: we wrote a bot that works and performs well, that's more than enough for me.
07:20:59 <shapr> and I learned *lots* from working with everybody.
07:21:03 <Heffalump> good good
07:21:14 <o3> Chilli: oh, g'night!
07:21:42 <Igloo> What's the difference between () and '() in LISP?
07:21:53 <shapr> one is quoted, aka un-eval'ed
07:22:08 <shapr> at least, that's true in elisp :-)
07:22:15 <Igloo> What difference does that make?
07:22:29 <shapr> whether you're passing a reference or a value
07:22:29 <Igloo> What function can tell the difference?
07:22:47 <shapr> so '(foo) passes a reference to a call to foo
07:22:59 <shapr> but (foo) passes the return value of that function.
07:22:59 <Igloo> No, () and '()
07:23:14 <Heffalump> don't they have different types?
07:23:25 <dennisb> types?
07:23:33 <Heffalump> I dunno what type () has but I'd expect '() to have type quote foo, if () has type foo
07:23:42 <Heffalump> oh. Lisp.
07:23:44 <dennisb> :-)
07:23:46 <Igloo> :-)
07:23:47 <Heffalump> well, runtime types.
07:26:08 * Igloo would need to see a function that behaved differently to have a hope of understanding. Maybe I should install a LISP environment
07:31:38 <pesco> Heffalump: () is a list.
07:31:52 <pesco> Heffalump: I don't think there's more of a type to that.
07:32:22 <pesco> Heffalump: '() is a symbol.
07:33:17 <Igloo> But you can cons something onto '()?
07:33:37 <shapr> Igloo: if you have emacs installed you can us M-x ielm
07:33:55 <pesco> Igloo: You can cons anything to anything.
07:34:12 <Igloo> shapr: If false VB is better than Haskell  :-)
07:34:28 <Heffalump> doesn't lisp have an eval operator?
07:34:37 <Heffalump> and if so, wouldn't it barf on () and accept '() ?
07:35:05 * Igloo hasn't come across one thus far
07:35:11 <pesco> Heffalump: Yes, LISP has an eval function. And I think it barfs on ().
07:35:19 <Igloo> Hmmm, OK
07:35:33 <Heffalump> right, so that's why I said they have different types
07:35:33 <Igloo> So why would you ever want to use () rather than '()?
07:35:33 <shapr> you quote stuff to have it evaluated later
07:35:37 <Heffalump> even if the types are only conceptual
07:35:47 <Heffalump> you need () for an empty list, surely?
07:35:53 <pesco> Yes.
07:35:58 <pesco> () is the empty list.
07:36:04 <Igloo> I haven't seen () used so far in this book
07:36:07 <Heffalump> and the null-testing operation will return true for () and false for anything else
07:36:12 <shapr> what book are you reading?
07:36:18 <Igloo> The Little LISPer
07:36:19 <Heffalump> and the cons-testing operation won't return true for '()
07:36:46 <pesco> What's cons-testing?
07:36:47 <Heffalump> so you want () cos it's a list and '() isn't
07:36:58 <Heffalump> can't you test whether somehing is a cons?
07:37:07 <pesco> Exactly, '() is the symbol which evaluates to ().
07:37:21 <Heffalump> where "evaluates to" means "when you explicitly run eval"
07:37:31 <pesco> Not really.
07:37:39 <pesco> Well, kind of.
07:37:48 <pesco> If you write () in a source file.
07:37:59 <pesco> That's a symbol, too. The ASCII characters forming ().
07:38:28 <pesco> So you could talk about your source code evaluating to ().
07:38:36 <pesco> Of course the interpreter calls eval on that.
07:38:46 <Igloo> This book seems to use '() where I would use [] in Haskell, which is making me wonder why it isn't just using ()
07:39:11 <pesco> Igloo: Can you give an example?
07:40:01 <Igloo> Oh, it says (null? '()) is true too
07:40:15 <Heffalump> oh.
07:40:16 <shapr> Lisp may be Haskell's closest non-pure functional relative, but it requires very different thinking.
07:40:20 <Heffalump> then I'm confused.
07:40:29 <Igloo> (it actually uses   (null? (quote ()))   in case I am screwing up in my translation)
07:40:35 <Heffalump> ML is closer to Haskell than Lisp is, AFAICT
07:40:45 <shapr> Some people have said, "why do I need to learn Haskell when I know Lisp? How can they be different?"
07:40:57 <shapr> Heffalump: er, I thought it was also pure?
07:41:02 <Heffalump> ML? no.
07:41:15 <shapr> oh, ok
07:41:18 <Heffalump> has references as part of the language, not a non-standard extension like unsafePerformIO is
07:41:24 <shapr> hm
07:41:45 <shapr> ML and variants are much closer to Haskell than Lisp of any flavor.
07:41:52 <Heffalump> yes.
07:42:12 <Igloo> define rember (lambda (a lat) (cond [(null? lat) (quote ())] [t (cond [(eq? (car lat) a) (cdr lat)] [t (rember a (cdr lat))])])))
07:42:34 <shapr> is that Common Lisp source?
07:42:48 <Igloo> It is idealised LISP, apparently
07:42:59 <Igloo> Probably idealized actually
07:43:02 <shapr> heh
07:43:31 <Igloo> Yup, idealized  :-)
07:44:26 * Igloo looks at pesco
07:44:35 <pesco> I'm trying to read it.
07:44:48 <pesco> I'm not a quick LISP reader.
07:44:48 <Igloo> :-)
07:45:05 <shapr> I know a chunk of elisp, and a smaller chunk of Scheme
07:45:12 <Igloo> This book calls ))])]))) aggravation brackets
07:45:17 * shapr laughs
07:45:24 <pesco> *g*
07:45:33 <shapr> I would like to have one of: a) better elisp knowledge b) haskell scripting in emacs
07:47:17 <Igloo> I think http://chaos.earth.li/~ian/lisp.txt is a valid rewriting of it, but I only started learning LISP today so ICBW  :-)
07:47:28 <shapr> why are you learning Lisp?
07:47:45 <Igloo> Primarily because I want to learn LISP
07:47:53 <shapr> good reason.
07:48:06 <Igloo> But also because I will likely want to read papers on metaprogramming that use LISP examples
07:48:16 <shapr> good point
07:48:24 <Igloo> The latter being what has prompted me to actually get around to it
07:48:27 <pesco> Igloo: Ok, I've read it and believe I know what it does, now ask me something.
07:48:32 <shapr> in that case, you'll probably end up reading about CL's metaobject protocol
07:48:42 <Igloo> I was actually going to learn Scheme, but the library didn't have The Little Schemer
07:48:53 <shapr> Igloo: um, read SICP
07:49:01 <shapr> please!
07:49:04 <Igloo> pesco: Why doesn't it use () instead of '()?
07:49:10 <Igloo> SICP?
07:49:18 <shapr> Structure and Interpretation of Computer Programs
07:49:24 <shapr> by Abelsson, Abelsson, and Sussman
07:49:25 <pesco> Igloo: Oh, sorry, missed it, I don't know.
07:49:30 <shapr> available freely online
07:49:31 <Igloo> :-)
07:49:39 <Igloo> Ta, shapr
07:49:41 * Igloo adds to TODO list
07:49:55 <shapr> when people tell me they want to become programmers, I say "read SICP first!"
07:50:00 <shapr> it's awesome.
07:50:37 * Igloo thought I was already a programmer, but never mind  :-)
07:50:51 <pesco> Igloo: Notice that it returns (quote ()), that is a list containing the symbol for the empty list.
07:51:09 <pesco> Igloo: I guess the returned list is supposed to contain symbols.
07:51:10 <Igloo> I thought the outer () were function application?
07:51:13 <shapr> http://mitpress.mit.edu/sicp/
07:51:31 <pesco> Igloo: No! () is not function application, it's list construction.
07:51:40 <Igloo> Hmmm, this book has already made me miss lunch. I hope you haven't made me miss dinner  :-)
07:52:07 <Heffalump> aren't you coming to the pub for dinner?
07:52:10 <pesco> Igloo: It's just that LISP represents functions as lists.
07:52:11 <Igloo> Yes
07:52:11 <shapr> SICP is fairly addictive.
07:52:21 <Heffalump> so all you have to do is not forget to leave
07:52:23 <Igloo> pesco: Losing me a bit now
07:52:25 <Heffalump> in time
07:52:35 <Heffalump> how can you represent a function as a list?
07:52:39 <shapr> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start
07:52:47 <Igloo> How do the outer brackets in (quote ()) differ from those in (and t t)?
07:52:52 <pesco> Igloo: Whether a list is actually evaluated as a function depends on the context, you might say.
07:53:00 <pesco> Igloo: They don't.
07:53:31 <Igloo> OK, are (quote ()) and '() the same?
07:53:40 <Igloo> He means a function call, Heff
07:53:51 <pesco> Igloo: No. '() is the symbol that evaluates to the empty list.
07:54:23 <pesco> Er.
07:54:26 <pesco> Wait.
07:54:32 <pesco> Did I just confuse myself?
07:54:44 <Igloo> Oh, there's a note in the back that answers my question. Sort of.
07:54:50 <pesco> I believe so.
07:55:00 <Igloo> "Some dialects use '() or () for (quote ())"
07:55:31 <Heffalump> aargh!
07:55:36 <Igloo> OK, I'm still not sure I get it, but now I think the reason is that it's stupid not me
07:55:37 <pesco> Forget anything I said. I think my brain just confused everything.
07:56:49 <pesco> I suppose anything you write is indeed evaluated. Where lists are evaluated as function applications.
07:56:59 <shapr> part of the reason Scheme was written, is because Lisp dialects have fragmented so much over time
07:57:31 <pesco> So if you did write () instead of (quote ()) it would barf, because it would try to eval the ().
07:58:05 <pesco> but evaluating (quote ()) yields (), so that's what becomes the result.
07:59:08 <pesco> That's it. You want something that _evaluates_ to (), not () itself, because that can't be evaluated, which every argument is.
07:59:11 <Igloo> Are foo and 'foo atoms?
07:59:24 <pesco> I don't know. What's an atom?
07:59:28 <Igloo> Oh
08:01:10 <pesco> shapr: What I find most cool about SICP is the introduction, where they compare computer programs to a magician's spells.
08:11:08 * Igloo realised something about the name "sexp" earlier today and wonders if it was deliberate at all  :-)
08:19:20 * Igloo boggles a bit at "tcLookup: `fromInteger' is not in scope"
09:51:06 <hdaume> does anyone know a good paper about monad composition?
09:51:43 <Heffalump> the modular interpreters paper?
09:51:59 <hdaume> which is that?
09:52:03 <hdaume> (author?)
09:52:07 <Heffalump> umm
09:52:09 <Heffalump> Mark Jones I think
09:54:20 <andersca> http://www.dcs.gla.ac.uk/~nww/Monad.html
09:54:31 * andersca met john hughes on his way to school
09:54:59 <Heffalump> that doesn't have the Modular Interpreters paper linked
09:55:01 <Heffalump> that I can spot
09:55:03 <Heffalump> hangon
09:55:17 <hdaume> k thanks
09:55:48 <Heffalump> @techreport{jonesmp93,
09:55:48 <Heffalump> author="M.P. Jones and L. Duponcheel",
09:55:48 <Heffalump> title="Composing Monads",
09:55:48 <Heffalump> institution="Yale University, New Haven, Connecticut, USA",
09:55:48 <Heffalump> year="1993",
09:55:50 <Heffalump> month=dec,
09:55:53 <Heffalump> number="YALEU/DCS/RR-1004",
09:55:55 <Heffalump> note="available from URL: \url{http://www.cse.ogi.edu/~mpj/pubs/RR-1004.ps}"}
09:56:06 <Heffalump> @inproceedings{liang95,
09:56:06 <Heffalump> author="S. Liang and P. Hudak and M.P. Jones",
09:56:06 <Heffalump> title="Monad Transformers and Modular Interpreters",
09:56:06 <Heffalump> booktitle="Conference Record of POPL'95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages",
09:56:09 <Heffalump> year=1995,
09:56:11 <Heffalump> publisher="ACM Press"
09:56:14 <Heffalump> }
09:56:15 <Heffalump> (sorry for flood)
09:56:59 <BlizzNL> if I have a type like this foo:: a -> b -> c how are the a, b and c called? something like 'polymorphic type identifiers' or something?
09:57:17 <Heffalump> type variables.
09:57:36 <BlizzNL> ok great, I am trying to get the hang of some haskell-slang ;)
09:58:15 <hdaume> thanks huff
09:58:19 <hdaume> heff :)
09:58:23 <Heffalump> :-)
10:05:46 <hdaume> grrr...i hate it when i mean to do something, switch screens, and then completely forget what i was going to do
10:05:46 <Heffalump> :-)
10:14:03 <shapr> happens to me a lot
10:15:51 <pesco> same here.
10:24:01 <hdaume> it's been happening to me more and more recently.  either i'm just getting senile or my GC module is broken
10:24:07 * shapr laughs
10:36:43 <freak_> .
10:36:44 <shapr> hiya
10:37:00 <dexter16-2> :)
10:37:27 <hdaume> hello
10:37:43 <shapr> dexter16-2: it looks like you've made two separate connections to the server, you can also connect to multiple channels from the same irc client
10:37:53 <shapr> hi hdaume, what's up?
10:38:20 <hdaume> not much.  ghc 5.04.1 has made me very happy :)
10:38:36 <shapr> I've built it, but not yet installed it
10:38:54 <hdaume> so far, i've only found one bug in it :)
10:39:17 <shapr> hi toadx
10:39:25 <toadx> hello!
10:39:40 <hdaume> anyone know what 'isDenormalized' in RealFloat does?
10:39:56 * shapr dunno
10:40:02 <shapr> sounds like one of those IEEE754 things
10:40:04 <hdaume> i assume it's some IEEE thing
10:40:05 <hdaume> hehe
10:40:22 <shapr> something like NaN, Infinity, etc
10:41:15 <toadx> http://research.microsoft.com/~hollasch/cgindex/coding/ieeefloat.html
10:41:27 <toadx> this page talks about denormalized numbers..
10:41:42 <toadx> If the exponent is all 0s, but the fraction is non-zero (else it would be interpreted as zero), then the value is a denormalized
10:41:48 <hdaume> ah
10:42:00 <hdaume> sounds pretty useless to me :)
10:42:31 <hdaume> anyone here know a bunch about elisp and uses the haskell editing mode for emacs?  :)
10:42:34 <shapr> wouldn't a denormalized number just be zero?
10:42:37 <toadx> it affects the min/max values you can represent
10:42:40 <hdaume> (or 1)
10:42:49 <shapr> hdaume: I know some about elisp, and use haskell-mode lots
10:42:54 <toadx> on that page there is a chart half-way done
10:43:04 <dexter16-2> I'm going to #apache if it exists...
10:43:14 <shapr> go for it
10:44:21 <hdaume> hrm...okay...so when you hit C-c C-l to load your program (or C-r to reload), it basically siezes control until ghci finishes loading and prints the prompt (noticed by the regexp)...when this takes a few minutes, it's very frustrating to have to wait for it to finish...is there any way to get around this so that you can continue interacting while it's (re)loading?
10:44:41 <shapr> not that I know of
10:44:49 <hdaume> durn
10:44:51 <shapr> emacs is single-threaded
10:45:03 <shapr> that's one reason I want to rewrite emacs in haskell
10:45:03 <hdaume> ah.  oh, well.
10:45:25 * hdaume sits calmly waiting for emacs
10:45:43 * toadx is waiting for a version of emacs in haskell that can act as a kpart :p
10:45:45 <shapr> I have found that compiling all .hs files to .o that you can get away with helps
10:46:22 <hdaume> yeah, that helps a lot...sometimes though i accidentally make a small change to something way up in my dep hierarchy and that causes reload to rebuild everything
10:46:43 <shapr> yah, I know that feeling
10:46:56 * hdaume is tempted to just kill emacs :)
10:47:12 <shapr> there's probably a way around it, I just don't know what it is...
10:47:24 <shapr> I do know that python-mode doesn't have that problem
10:49:05 * hdaume just wants a good haskell ide :)
10:49:19 <shapr> hdaume: have you seen hIDE ?
10:49:31 <shapr> haide.sf.net
10:49:35 <hdaume> yeah
10:49:46 <hdaume> should be good
10:49:59 <shapr> if you've been following ghc-users, you already know about the dynamic loading that o3 did
10:50:16 <shapr> and that duncan coutts (sp?) is interested in putting that into hIDE
10:51:44 <hdaume> yeah...i have high hopes for hIDE.  i'm not convinced that dynamic loading is necessary, but it would be cool.  i'm only worried that sometimes something good now is better than something excellent in the far future.
10:53:22 <shapr> well, hIDE uses emacs or vim for its editing component, so you get the best of both worlds
10:54:16 <hdaume> yeah...i'm not convinced of that either :)...i much prefer the single-window approach (ala VS) to the many-window approach 
10:56:08 <hdaume> it seems that by using an external editor, you're greatly limiting the cool editing capabilities you can do
10:57:29 <shapr> I'd like to have a purely haskell solution
10:57:39 <hdaume> me too :)
10:58:21 <shapr> I suspect the only way to get there would be to go from hIDE to replacing other components piece by piece
10:58:26 <hdaume> the thing is, doing editing components in gtk isn't hard...it even comes with emacs keybindings for gtk edit panes...
10:58:51 <hdaume> (dunno about vim -- i'm sure someone's written 'em though)
10:58:53 <shapr> well, go for it :-)
10:59:07 <hdaume> eh, i have other things eating up my time
10:59:12 <shapr> me too
10:59:24 <shapr> that's why I think the incremental approach is best
10:59:29 <hdaume> true
10:59:34 * toadx is redoing his website in haskell :)
11:00:27 <hdaume> sigh.  i get so much spam across the clean mailing list
11:00:36 <toadx> me too
11:00:45 <shapr> sounds like a dirty list
11:00:58 * toadx does not have an accent getting in his way
11:01:49 <shapr> something like é ?
11:24:44 * shapr boings
11:25:03 <shapr> toadx: how are you doing your site in Haskell?
11:27:52 <toadx> shapr: I have a bunch of content, like guestbook entries, log entries, etc, that gets updated occasionally through forms on the site and stored as XML. Right now, when you visit the page, the dynamic content is created by PHP scripts
11:28:17 <shapr> oh, you're going to use haskell scripts instead?
11:28:33 <toadx> But I think I am going to replace the PHP scripts with Haskell scripts, because Haskell has a better XML parser and HTML generator.
11:28:51 <toadx> Plus, I need to start doing fancier things like sessions
11:28:56 <shapr> cool
11:28:57 <hdaume> i did something like that using runhugs: i should warn you it's very slow and i'd recommend against it if you're using runhugs (there's a link off of my page [www.isi.edu/~hdaume] to a grad student database which is impl'd in haskell)
11:28:59 <toadx> shopping carts, and the like
11:29:00 <ibid> blahblahblah (oops)
11:29:10 <shapr> ibid: eh?
11:29:17 <ibid> just feeling bored :-)
11:29:21 <shapr> hi ibid!
11:29:29 * hdaume is off to class
11:29:32 <ibid> (listening to my own music from five years ago)
11:29:34 <ibid> hi shapr 
11:30:25 <toadx> hdaume: I was hoping to use something like WASH/CGI and compile to native code
11:33:36 <toadx> Plus, the content only changes every few days. So I was thinking that instead of generating the content dynamically everytime, I would just re-generate static html pages when the XML changes.
11:37:42 <shapr> hi letalis
11:37:48 <letalis> Hi
11:38:06 <letalis> I really could need some help here...
11:38:41 <ibid> shoot
11:39:07 <letalis> We're reading a course on haskell, using the SOE book.
11:39:48 <letalis> Now we're trying to do some animations, but we are really stuck.
11:40:18 <letalis> We need to generate random blocks and move them across the screen.
11:40:43 <letalis> But everything we try end up with type-errors of different kinds...
11:41:14 <toadx> mmmm. type errors.
11:41:18 <shapr> my favorite
11:41:42 <letalis> One try is to use getStdRandom(randomR(low,hi)) to get random sizes, but since we cant get them from IO Float to Float we have no use for them...
11:42:15 <shapr> ah, that sounds familiar.
11:42:21 <ibid> well, you can make your stuff into a function and then call that function from the io monad
11:42:54 <letalis> The thing is that our teacher has decided to not mention the monads in this course... :(
11:43:07 <letalis> Could you please explain?
11:43:28 <shapr> monads are like a separation from reality, but you can return stuff from them
11:43:33 <ibid> your teacher seems to have made a bad mistake, considering that the soe book is full of the io monad
11:43:45 <shapr> who's your teacher?
11:43:48 <shapr> we wanna know!
11:43:55 <letalis> Björn Lisper is his name.
11:43:59 <shapr> oh
11:44:01 <shapr> never mind.
11:44:15 <ibid> even his name spells it: he's not a haskeller :-) (bad one, i know)
11:44:28 <letalis> ;)
11:44:29 <shapr> I've been wondering for years if that guy changed his name to that...
11:44:33 <shapr> or if that's his real name.
11:44:57 <letalis> We have thought of it to, but noone has the guts to ask...
11:45:01 <Marvin--> mdh? Mälardalen?
11:45:08 <letalis> Yes
11:45:09 <shapr> letalis: I'd  ask him
11:45:21 <shapr> just to find out
11:45:23 * Marvin-- didn't know they did Haskell at mdh
11:45:29 <shapr> is lisper a real last swedish name?
11:45:41 <shapr> of course, I'd ask him because I changed my name =)
11:45:52 <Marvin--> you wouldn't believe the weird things people have for names here
11:45:54 <letalis> They have remade the functional programming course.
11:46:06 <shapr> Marvin--: I will soon, I'm moving to boden.se
11:46:33 <Marvin--> shapr: oh? What're you going to do there?
11:46:37 <letalis> Anyways, you think we should look into the monad-stuff?
11:46:41 <shapr> contract work hopefully :-)
11:46:45 <Marvin--> shapr: cool
11:46:47 <ibid> letalis: might be good
11:46:54 <Marvin--> letalis: look up the do notation
11:46:56 <shapr> contract work in Haskell even
11:47:00 <shapr> if I get my wish
11:47:47 <shapr> most of the .se people on here are waaaay south of Lulea
11:47:53 <letalis> Marvin--: We have tried every possibility with do we could think of, but, I guess were not the sharpest tools...
11:48:09 <shapr> how long does it take to travel from Lulea to stockholm or goteborg?
11:48:38 <letalis> shapr: by train?
11:48:51 <Marvin--> shapr: night trains... well, the entire night
11:49:45 <shapr> hi sockmonk
11:50:04 <sockmonk> hola
11:50:10 <shapr> como est as?
11:50:28 <shapr> is sockmonk short for sock monkey?
11:50:32 <sockmonk> bien, gracias
11:50:38 <sockmonk> yes
11:50:42 <shapr> cool..
11:50:51 <shapr> freenode allows large nicknames, you could use the entire name
11:50:54 <sockmonk> http://images.tfaw.com/coverst/med/s/smonkey46pic.jpg
11:51:12 <shapr> whoa that's cool :-)
11:51:19 <letalis> Thanks for the help, I guess we'll be back harassing you some other day if we don't solve our problem...
11:51:21 <sockmonk> started with a lame irc client that limited me to 8 chars, decided to keep it
11:51:25 <shapr> ok
11:51:38 <shapr> letalis: I'd suggest starting with just moving non-random blocks
11:51:52 <shapr> letalis: I'm pretty sure you're going to require Monads to get random values
11:51:57 <letalis> shapr: We'we managed to do that actually.
11:52:22 <letalis> shapr: But as soon as we try to use random numbers we get stuck...
11:52:35 <shapr> there was a short description of how to get random numbers on the haskell mailing list recently
11:52:49 <letalis> shapr: Thanks, we'll take a look at it.
11:52:49 <Marvin--> letalis: have a look at the RandomGen class in the Random module
11:52:58 <ibid> letalis: something like this might work:
11:53:16 <shapr> sockmonk: learning Haskell? long time user?
11:53:16 <ibid> main = do gen <- newStdGen
11:53:18 <ibid>           return $ foo (randoms gen)
11:53:50 <ibid> now, foo is [Float] -> () (or whatever thing you want for Float), and you can do with its argument whatever you like
11:54:14 <toadx> what about random    :: (Integer,Integer) -> Integer -> [Integer] ??
11:54:20 <sockmonk> shapr: not sure what it is. :-)
11:54:31 <shapr> sockmonk: how did you find this channel then?
11:54:41 <sockmonk> it was mentioned on #apache
11:54:43 <shapr> oh
11:54:53 <shapr> Haskell is a programming language
11:54:55 <sockmonk> i mostly do mod_perl programming
11:55:02 <shapr> it's a bit different from Perl
11:55:10 <shapr> maybe even a lot different.
11:55:21 <sockmonk> what's it best at?
11:55:26 <shapr> if you want to find more info, check out http://www.haskell.org/
11:55:40 <shapr> I'd say it's best at making concise maintainable code to solve a problem.
11:55:50 <sockmonk> was wondering how long it would take for someone to point out a FAQ. :-)
11:56:09 <sockmonk> how is that different from perl? </flamebait>
11:56:38 <shapr> well
11:56:44 <ibid> imao haskell is best at handling handling languages :-) (but it is good for many other things)
11:56:46 <shapr> Haskell isn't procedural.
11:57:08 <shapr> code in Haskell works like an equation.
11:57:27 <ibid> sort of like an equation
11:57:36 <shapr> because every call to a function can be replaced by the result of that function, you only need  to solve a function for a given input once per program
11:57:40 <shapr> well, once per execution
11:57:44 <sockmonk> kind of like lisp?
11:57:52 <shapr> lisp is somewhat like that
11:57:56 <ibid> yes, but hugely better
11:58:01 <ibid> and less parentheses
11:58:04 <shapr> heh, that too
11:58:18 * ibid loves the dollar operator
11:58:42 <shapr> Haskell has neat tricks like partial application.
11:58:53 * sockmonk adds haskell to his growing list of Things To Learn Someday
11:59:01 <ibid> sockmonk: here is a piece of code i've thrown at my students in the hopes of making them learn haskell and compiler/interpreter-writing in the middle of it:
11:59:10 <shapr> that means that if you give a function one argument, it returns a new function that takes only the remaining arguments.
11:59:11 <sockmonk> thanks for the intro. the site is laid out exceptionally well.
11:59:15 <ibid> http://www.mit.jyu.fi/antkaij/opetus/okp2002/demo/demo3/
11:59:18 <sockmonk> I'll learn more there as time allows
11:59:40 <shapr> ok, drop by and ask us questions when/if you want to learn more.
11:59:41 <shapr> f00
11:59:48 <ibid> bar
12:00:08 * shapr has started using metasyntactic variables instead of saying perkele
12:00:26 <ibid> ja vitut siitä :-)
12:00:31 * shapr snickers
12:00:45 <shapr> that too
12:01:00 <letalis> Thank you guys.
12:01:07 <letalis> \quit back to reality
12:01:12 <shapr> cya
12:02:39 <Marvin--> what, what's more real than haskell? :)
12:03:59 <ibid> Pascal, for it has a Real data type :-) (iirc)
12:04:40 <Marvin--> duh
12:06:46 <toadx> pascal was my first language (besides basic)
12:08:21 <Marvin--> pascal was my first language period
12:09:22 <ibid> my first language...
12:09:35 <ibid> first i programmed in, for real, was spectrum basic
12:09:40 <ibid> then came quick pascal
13:37:59 <engstad> Spectrum Basic.. heh..
13:41:21 <toadx> mine was TI Advanced Basic
13:42:37 <engstad> Mine was Commodore Basic. (C64).
13:43:02 <engstad> Actually, a friend of mine had a TI, so I did do some programming on his.
13:43:34 <toadx> I never had a C64 :( I really wanted an Atari 1040ST though, cuz one of my friends had one
13:43:51 <engstad> :-)
13:44:08 <engstad> I don't think kids nowadays have the same opportunities as we did.
13:44:41 <toadx> My first PC was a 286... It had no games but shipped with Turbo Pascal, so that's why I am a programmer now ;)
13:44:50 <engstad> :-)
13:44:59 <toadx> but computers don't ship with compilers anymore :(
13:45:32 <toadx> Unless you buy a Mandrake machine from Walmart.com...
13:45:52 <engstad> I remember, we created this hoppy computer club, and we invited someone to come over from the university. He was talking about cars and cdrs, and I had absolutely _no_ idea what he was talking about. :-) I was 13.
13:46:04 <engstad> s/hoppy/hobby/
13:46:18 <toadx> hahaha
13:46:29 <Marvin--> engstad: or s/hoppy/hoopy/ ;)
13:46:36 <engstad> *grin*
13:47:18 <engstad> See, I only knew Basic, Pascal and 6502/10 assembly, so it was quite a stretch. Lists???
13:47:31 <engstad> Programs as lists??? Wierd, I thought..
13:49:36 <toadx> What totally blew my mind was when I was running DOS and this guy told me he could hook up a second monitor and keyboard to his computer over the serial port using this thing called 'linux'
13:49:57 <toadx> and he could run multiple programs at once
13:50:12 <Marvin--> :P
13:50:14 <engstad> Now _THAT_ was amazing to me. 
13:50:30 <toadx> but I had a 286 at the time, so I had to wait to try it out ;(
13:50:31 <engstad> Multiple programs running at once. 
13:51:08 <engstad> Who actually came up with that crazy idea?
13:51:21 <engstad> Multi-tasking operating systems, that is.
13:52:23 <clausen> it's been around for ages
13:52:27 <clausen> maybe ITS was first?
13:52:36 <clausen> (incompatible timeshare system)
13:52:48 <clausen> earlys 60s,  I believe
13:56:49 <engstad> See yas!
13:57:20 <shapr> the first time I did any 'real' programming was with Java
13:57:25 <shapr> I'm such a newbie :-)
13:57:43 <gene9-afk> basic(rt11fb)->pascal(rt11xm)->c, asm(rt1xm)->turbo pascal/c(pc 286)->borland c++, asm(i386)->delphi, c++, fortran(i486)->python,ocaml(i586)->python,ocaml,haskell(i686)
13:58:02 <gene9-afk> this is my `languagelogical tree` =)
13:58:02 <shapr> that's a nice spread
13:58:48 <shapr> I did tiny bits of basic and asm on my XT, but then I gave it up as impossible and stuck with learning to use the apps
13:58:58 <shapr> I wish my XT had come with a real compiler
14:00:01 <gene9-afk> 8086?
14:00:09 <gene9-afk> or a beter?
14:00:11 <shapr> 8088
14:00:16 <shapr> er, no
14:00:17 <shapr> 8086
14:00:33 <shapr> I spend my college money on it :-0
14:00:37 <shapr> my mother was not happy
14:01:27 <shapr> I'm happy being a professional programmer though
14:01:50 <toadx> i'm not, I want to be a rock star.
14:02:04 <shapr> go for it
14:02:08 <shapr> I want to be a programmer
14:02:57 <toadx> I am working on it
14:03:08 <shapr> I can write lyrics :-)
14:03:15 <toadx> I hired a full-time composer/song writer
14:03:19 <shapr> oh, wow
14:03:32 <gene9-afk> i'm thiking about smalltalk, ada and pascal as a some kind of sieve for my current fp proggramming style
14:03:47 <shapr> I'd like to learn smalltalk at some point
14:03:53 <shapr> I want to learn Mercury next though
14:03:57 <gene9-afk> composer!?
14:04:09 <gene9-afk> wow
14:05:12 <shapr> it's time for counterstrike on winex!
14:05:15 <shapr> bbl
15:07:31 <engstad> I was reading about the basic algebraic types for haskell. Looks good.
15:10:50 <hdaume> cool :)
15:29:02 <engstad> Yes, I always felt that Num, Float etc. was a bit wrong.
15:29:44 <hdaume> engstad: where did that come from?
15:31:39 <engstad> Oh, its a proposal for Haskell: ftp://ftp.botik.ru/pub/local/Mechveliani/basAlgPropos/
15:33:29 <hdaume> yeah, i've read that...i meant where did your comment come from .... what prompted you to say that?
15:34:51 <engstad> Oh, I just finished reading the doc. :-)
15:35:35 <toadx> hdaume: Have you used WASH/CGI at all?
15:35:38 <hdaume> ah
15:35:43 <hdaume> nope
15:36:31 <toadx> hdaume: I was thinking that for my haskell based site I would use that and compile to native code to avoid the slowness of runhugs... thats all.
15:36:56 <hdaume> toadx: ah, okay.  yeah, just don't use runhugs :)
15:37:02 <hdaume> it's egregious
15:51:31 <toadx> I would never use runhugs, maybe runghci, but not runhugs :p
16:07:58 <dnm> Are there any compelling reasons to use Hugs at all these days?
16:08:05 <dnm> (Honest question, I'm curious)
16:08:24 <hdaume> *grin* i think it's faster (i don't know though -- i don't use it)
16:10:02 <hdaume> i use runhugs occasionally.  i threw together a shell script so i could type things like "cat x | sort | uniq -c | hs 'show . sum . map read . lines"  where 'hs' wraps its argument in "main = interact (...)"
16:10:57 <toadx> !!
16:11:01 <Heffalump> nice.
16:11:11 <Heffalump> I think hugs loads stuff faster than ghci does
16:11:59 <hdaume> unfortunately, that's like 10* slower than "perl -e '$s=0; while (<>) { $s += length($_); } print "$s\n"" which is depressing :(
16:19:49 <hdaume> i hope that oleg was joking in his most recent post to the mailing list
16:20:16 <Heffalump> the haskell list?
16:20:22 <hdaume> yeah
16:22:21 <Heffalump> rotfl
16:24:37 <Igloo> lol
16:26:07 <Heffalump> so, why bother with Template Haskell, when tricks like this are available?
16:27:37 <hdaume> *grin*...in order to do that i'd want a "me" object which is the string of the current program's source code :)
16:28:31 <Igloo> Reification. Obviously.
16:28:56 <hdaume> does anyone have a sense if i define: 'newtype ST a = ST (State,IO a)' and then make it an obvious instance of Monad and use this monad, if that is going to be slower than if i just did everything in IO?
16:29:27 <Heffalump> how are you intending to call this?
16:29:52 <hdaume> oops, i meant 'newtype ST a = ST (State -> (State, IO a))
16:30:00 <Heffalump> isn't the standard ST monad ST s a, where s is the "state thread" parameter?
16:30:11 <hdaume> and the run is: run (ST f) state = f state of type IO ()
16:30:25 <Heffalump> oh, ignore what I just said
16:30:29 <Heffalump> umm.
16:30:48 <Heffalump> I've written code with a manual state monad, and using GHC's ST monad, but not GHC's IO monad, and found no performance difference
16:30:57 <Heffalump> but I dunno if that says more about my code than GHC's ST monad.
16:32:05 <hdaume> hrm...i'll run some experiments then
16:32:44 * hdaume just about doubled the performance of a function by reversing the order of arguments and adding another auxiliary
16:32:58 * hdaume thinks the compiler should have done that for him
16:33:17 <Heffalump> what did the auxiliary do?
16:33:25 <hdaume> here's a basic version of the code:
16:33:38 <Heffalump> it's a bit much to expect a compiler to work out accumulating parameter optimisations on its own
16:33:48 <hdaume> myfunc gar = do ga <- readIORef gar; modify 1 gar
16:34:12 <hdaume>    where modify x ga@(stuff) | ... = modify (x+1) ga
16:34:17 <hdaume>            | ... = something
16:34:26 <hdaume> basically, i flipped the x and ga in modify and made it:
16:34:38 <hdaume>    where modify ga@(stuff) = modify' 1
16:34:49 <hdaume>              where modify' x | ... = modify' (x+1)
16:34:56 <hdaume> so it didn't pass ga around inside the loop
16:35:08 <hdaume> i don't know if that made any sense :)
16:35:11 <Heffalump> how big is ga?
16:35:29 <Heffalump> your original code is going to cause a pattern match against stuff on each iteration
16:35:33 <hdaume> it's a tuple of an int and another tuple...  ga@(sz,(arrK,arrE))
16:35:42 <Heffalump> I think it would take quite a specialised optimisation to spot that it wasn't necessary
16:35:52 <hdaume> but ga is never changed when a recursive call is made
16:36:13 <Heffalump> I suppose
17:00:25 <Chilli> Moin
17:00:57 <Heffalump> no, definitely evening.
17:01:01 <Heffalump> well, night
17:01:22 <Chilli> well, "moin" is day time independent
17:01:32 <Chilli> good for irc :-)
17:01:34 <Heffalump> oh, ok. I thought it meant "morning".
17:01:48 <Heffalump> ah. "Good Day".
17:01:56 <Chilli> yeah, kind of
17:02:15 <Igloo> s'not day, though
17:03:08 <Pseudonym> G'day.
17:03:09 <Chilli> The sun is blazing through *my* window at least ;-)
17:03:16 * Pseudonym late as usual
17:03:26 <Pseudonym> It's kinda overcast outside here.
17:03:39 <Pseudonym> Definitely morning, though.
17:03:49 <Igloo> You want curtains you do, or you'll get glare on your monitor  :-)
17:04:42 <Chilli> my machine is in the right spot, no glare :-)
17:05:14 <hdaume> my office doesn't have windows :(
17:05:14 <Pseudonym> At one workplace, a friend's monitor was right in the glare, so he cut three sides off a cardboard box and stuck it around his monitor.
17:05:30 <Pseudonym> A potentially witty cow orker wrote "PornShield(tm)" on the side.
17:05:41 <Igloo> Is that legal, hdaume?
17:05:41 <hdaume> hehe
17:05:56 <hdaume> i'm a grad student: they can do whatever they want to me :)
17:05:57 <Igloo> I have a feeling I heard it wasn't in the UK, BICBW
17:06:12 <Chilli> is it?
17:06:16 <hdaume> i'm in the US anyway...we enjoy torturing people
17:06:36 <Heffalump> we'd noticed :-)
17:06:38 <Igloo> is what?
17:06:49 <Heffalump> "it". He said that.
17:06:59 <dnm> hrm
17:07:22 * dnm looks for canonical electronic ML references, preferrably ones he can download and store locally
17:07:54 <Chilli> it = illegal
17:07:57 <Chilli> no
17:08:03 <Chilli> it = it illegal
17:09:01 <Igloo> I don't think it's legal in the UK, don't know about the US. I was hoping Heff would confirm it one way or the other, but apparently not
17:09:32 <Heffalump> I suspect it isn't legal in the UK, but I don't know for sure
17:09:45 <Heffalump> and it might be legal for grad students, since they aren't employed
17:10:03 <Heffalump> although a lot of employment protection stuff did get extended to other people in the last few years
17:13:49 <Heffalump> dnm: which ML flavour?
17:14:02 <Heffalump> the only canonical reference is the definition of SML, which I think is only available as a book
17:14:10 <Pseudonym> Eeek.  SML sucks.
17:14:16 <Heffalump> (a clear case of where Haskell is superior :-)
17:14:19 <Pseudonym> IMO, of course. :-)
17:14:22 * Heffalump is actually growing to like it
17:14:33 <Pseudonym> I like other ML variants.
17:14:37 <dnm> Heffalump: ML97/SML would be fine
17:14:47 <Heffalump> it's nice that it doesn't have the layout rule, in many ways
17:14:53 <Pseudonym> O'Caml is quite cool, for example.
17:14:57 <clausen> Pseudonym: btw, I found the problem
17:15:01 <Pseudonym> Oh?
17:15:04 <clausen> Pseudonym: I had typed String instead of string
17:15:09 <Pseudonym> Aha!
17:15:17 <clausen> the error messages were totally useless
17:15:19 * dnm did just surprisingly find an errant copy of the old, discontinued Harelquin MLWorks 2.0, which he thinks includes an HTML copy of the definition of SML
17:15:22 <Heffalump> well, it means you don't have to keep your code looking pretty when inserting debugging code
17:15:24 <clausen> mercury really needs better diagnostics
17:15:31 <Heffalump> dnm: oh, cool
17:15:39 <clausen> (it's really hard to do, I know)
17:15:50 * Heffalump just gets the definition of SML out of the library when he needs it, but I have the advantage of working in a university
17:16:06 <Pseudonym> clausen: It's a problem because it's not obvious who the diagnostics are intended for.
17:16:08 <clausen> that's a nice thing about haskell, actually... the compilers/interpreters tend to be helpful wrt errors
17:16:31 <Pseudonym> clausen: At the moment, they are effectively written for Prolog/Goedel/whatever programmers switching to Mercury.
17:16:48 <Pseudonym> Whereas GHC/Hugs error messages are written for newbies.
17:17:08 <Igloo> Unfortunately you can only keep things out for about 2 months AFAICT
17:17:08 <clausen> Pseudonym: convince me
17:17:11 <Pseudonym> One of the (many) design goals of Haskell 98 was to produce a language suitable for use as a first language.
17:17:37 <clausen> Pseudonym: like, mercury wasn't giving me the information
17:17:39 <Heffalump> igloo: well, currently I'm 2 minutes walk from the Library. I guess that'll increase slightly soon.
17:17:52 <Heffalump> But if a book really is needed lots, the research group can buy it
17:17:57 <clausen> well, it was, but it would take a good thinking about to arrive at the conclusion
17:18:03 <clausen> are there disadvantages to the hugs approach?
17:18:10 <Igloo> That doesn't help you use a book at a computer for more than 2 months, though
17:18:15 <Heffalump> if Hugs error messages are designed for newbies, I'd love to see what they'd give to people who aren't newbies.
17:18:16 <Igloo> 2 mins walk, not buying it
17:18:19 * hdaume is going home
17:18:25 <Pseudonym> clausen: No Prolog programmer would start a functor with an upper case letter by mistake, just like no Haskell programmer would write a data constructor without one by mistake.
17:18:30 <Heffalump> well, you can renew them.
17:18:44 <Igloo> Only a couple of times IIRC
17:18:52 <Pseudonym> clausen: BTW, what am I supposed to convince you of?
17:19:25 <Heffalump> igloo: I've never actually tried, but my impression was that the dept library basically let you do whatever you liked if noone else wanted it.
17:20:56 <Pseudonym> BTW, what I find the most frustrating about SML is not the syntax, but its approach to recursive functions.  You basically have to topologically sort your program.
17:21:09 <Pseudonym> Mutually recursive functions have to be declared together.
17:21:44 <Pseudonym> Forward references (e.g. in C) are bad enough, but actually having to do dependency analysis yourself, when it's so easy to write, is just insane.
17:21:49 <Pseudonym> Personal opinion, of course.
17:22:52 <clausen> <Pseudonym> clausen: It's a problem because it's not obvious who the diagnostics are intended for.
17:23:02 <clausen> why does it make a difference?
17:23:09 <Pseudonym> Oh, I see.
17:23:13 <clausen> would a "newbie-ized" mercury be a problem?
17:23:22 <clausen> I think everyone makes all kinds of mistakes
17:23:24 <Pseudonym> It wouldn't be a problem at all.
17:23:36 <Pseudonym> If someone would put in the effort.
17:23:47 <Pseudonym> Right now, the errors are written for Prolog programmers switching.
17:23:49 <clausen> I've just been programming lots in Java, so String comes out naturally
17:24:05 <Pseudonym> Experienced programmers do make different mistakes than newbies.
17:24:33 <clausen> is there literature on this?  it's an interesting topic
17:24:37 * clausen should look some day
17:24:38 <Pseudonym> I've never had an offside error in Haskell, for example (except when I've done global search and replace then compiled it straight away).
17:24:57 <clausen> your "except" is a good example why everyone makes all classes of mistakes
17:24:58 <Pseudonym> I did when I started off (in Orwell, Miranda and Miracula).
17:25:21 <Pseudonym> Yeah, I see what you mean.
17:25:36 <clausen> also, that String thing wasn't because I didn't know "String" was wrong
17:25:45 <Pseudonym> I think this might be covered a bit in "The Psychology of Computer Programming" by Gerard Weinberg.
17:25:47 <clausen> it's just that it happened at a subconcious level
17:26:12 <Pseudonym> It's an older book, but unimelb almost certainly has a copy in the library.
17:26:12 * clausen adds to his TODO list
17:26:40 <Pseudonym> I can't remember, though.  It's been a while since I last read it.
17:26:46 * Pseudonym adds it to his own TODO list
17:27:15 <Pseudonym> Sorry Gerald Weinberg, no Gerard.
17:27:48 <clausen> there might even be an honours project in that
17:27:55 <Pseudonym> There may well be.
17:27:56 <clausen> (making mercury friendly)
17:40:12 * Chilli -> airport
17:40:21 <Pseudonym> Where are you going?
17:40:29 <Pseudonym> To the airport, obviously.  I meant after that.
17:40:31 <Chilli> Pittsburgh
17:40:44 <Chilli> for ICFP, Haskell Workshop etc
17:40:57 <Pseudonym> Have much fun.
17:41:03 <Chilli> thanks :-)
17:41:21 <Chilli> hopefully, I'll have net access there
17:41:30 <Chilli> then, I'll drop by #haskell
17:41:40 * Chilli waves goodbye.
17:41:43 <Pseudonym> Byw.
17:41:46 <Igloo> Have fun!
17:45:56 <Heffalump> hmm, I don't actually know if the hotel has net access.
18:28:27 <Heffalump> 'lo
20:39:17 <sethk> Anyone about?
20:55:07 <Pseudonym> I am now.
20:55:15 <sethk> Pseudonym:  Hello
20:55:17 <Pseudonym> G'day.
20:55:44 <sethk> Interested in a performance question?
20:55:55 <Pseudonym> I guess.
20:56:12 <sethk> OK, you can always change your mind.  :)
20:56:44 <sethk> I have two Haskell programs, one built with Parsec and another using "ordinary" Haskell.
20:57:05 <sethk> The Parsec program runs very fast, and the Haskell program runs very slowly, and I'm trying to determine why.
20:57:23 <Pseudonym> OK.
20:57:26 <sethk> The Haskell program is much, much simpler.
20:57:49 <Pseudonym> Well I can tell you why the Parsec program is fast. :-)
20:57:56 <Pseudonym> Parsec is pretty well optimised.
20:58:21 <sethk> Yes, but the Haskell program is doing almost nothing.  Let me
20:58:21 <sethk> show you a bit of pseudocode:
20:58:47 <sethk> I have an ASCII file that I'm reformatting for database input.
20:59:02 <sethk> The ASCII file has fixed length character fields.
20:59:41 <Pseudonym> OK.
20:59:53 <sethk> read a line
20:59:53 <sethk> break the line into a list of strings, removing trailing white space
20:59:53 <sethk> write out a line as a comma separated text file
20:59:53 <sethk> continue until there are no more lines
21:00:04 <sethk> Hard to think of anything simpler.
21:00:17 <Pseudonym> How are you breaking the line?
21:00:57 <Pseudonym> There are several O(N^2) ways to do that, which is why I'm asking.
21:01:19 <sethk> I created a list of Int which has the length of each field,
21:01:19 <sethk> and then I grab a field from the string using take, and pass
21:01:19 <sethk> the rest of the line (and the rest of the list) in a tail recursive call.
21:01:36 <sethk> Using drop to pass the balance of the line
21:01:51 <Pseudonym> OK, that's O(N^2) in the number of fields.  How many fields are there?
21:02:02 <Pseudonym> Sorry.
21:02:17 <Pseudonym> No, it's O(N^2), but in a subtle way.
21:02:33 <sethk> Interesting, how?
21:03:02 <sethk> There are 244 fields.
21:03:20 <Pseudonym> That'll do it.
21:03:29 <sethk> Clearly there is something exponential going on here, but I don't see where
21:04:08 <sethk> There is also the stripping of white space with matchRegexAll,
21:04:08 <sethk> but I don't think that is the big time killer.
21:04:23 <Pseudonym> There are exactly 244 fields?
21:04:48 <sethk> Yes.  Some are empty, but that doesn't matter as they are space padded.
21:04:56 <Pseudonym> You might want to try using splitAt instead of take/drop.
21:05:08 <sethk> OK, let's see what happens...
21:13:26 <Pseudonym> If that doesn't help, we'll go on to how you build the comma separated file.
21:14:03 <sethk> Still coding.  I'm doing let (before, after) = splitAt x line
21:14:03 <sethk>                          in ....
21:14:03 <sethk> and the compiler is rejecting something.
21:14:48 <sethk> Never mind, typo
21:17:53 <sethk> Just a bit more time; I'm stripping the CR characters from the large
21:17:53 <sethk> input file.
21:29:40 <sethk> Appears to be running at roughly the same speed.
21:35:35 <sethk> pseudonym:  Replacing the output function with hPutLine (show xxx)
21:35:36 <sethk> also did not have any substantial effect.
21:47:10 <Pseudonym> Sorry, boss key.
21:47:41 <Pseudonym> Odd.  Do you know how to use the profiler?
21:47:48 <sethk> Pseudonym:  I rewrote the output function more efficiently, but since
21:47:48 <sethk> that wasn't the problem it didn't make much difference (although it is
21:47:48 <sethk> less ugly).
21:48:07 <sethk> No, is it difficult?  Where's the docs?
21:49:45 <sethk> I'm going to temporarily remove the code that strips the trailing spaces.
21:50:59 <sethk> That made only a very small difference.
21:53:28 <sethk> Definitely exponential.  100 records:  0.3 seconds
21:53:28 <sethk> 1000 records 32.104 seconds
21:56:04 <sethk> I take it back, the second time is for 10,000 records, so it appears to
21:56:04 <sethk> be linear (but very slow).
21:58:20 <sethk> However, when I remove the regex AND the write to the output file,
21:58:20 <sethk> 100,000 records takes 3.125 seconds (was 32.1)
21:59:07 <sethk> Pseudonym, now I have to go tend something.  Back in a bit...
22:21:09 <Pseudonym> I'm afraid I don't know much about the profiler muself.
22:21:19 <Pseudonym> Sorry, I'm coming and going, too.
22:21:44 <Pseudonym> The docs will be off http://haskell.org/ghc/
23:00:21 <sethk> I'm back.
23:17:40 <Pseudonym> I'm back.
23:18:28 <sethk> Hi.  I double checked, it is linear.  And the code writing the output file is actually more efficient than the code in the program that runs faster.  So I guess the profiler is the logical next step.
23:34:26 <sethk> pseudonym:  Still there?  I had to restart X.
23:46:53 <Pseudonym> Yes.
23:47:12 <sethk> Pseudonym:  I'm looking at the users guide now.
23:47:54 <Pseudonym> Never used it myself, incidentally.  I generally fire up ghci and test things by hand.
23:48:05 <Pseudonym> One of these days I really should.
23:48:26 <Pseudonym> My code is invariably fast enough, but that's probably because I don't write time-critical stuff.
23:49:17 <sethk> Profiling looks quite easy.  I'll see if I really understand it in a moment...
23:49:54 <Pseudonym> :-)
23:50:06 <Pseudonym> I suspect that if you've used a profiler before, it should be straightforward.
23:52:50 <Pseudonym> Gotta go.  Night everyone.
23:52:58 <sethk> Night
